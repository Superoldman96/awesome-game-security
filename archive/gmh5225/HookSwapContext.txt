Project Path: arc_gmh5225_HookSwapContext_wmlw0apd

Source Tree:

```txt
arc_gmh5225_HookSwapContext_wmlw0apd
├── Define.h
├── EtwHook.cpp
├── EtwHook.h
├── HookSwapContext.cpp
├── HookSwapContext.h
├── README.md
├── global.cpp
├── global.h
├── util.cpp
└── util.h

```

`Define.h`:

```h
#pragma once


typedef unsigned long long y64;
typedef unsigned long long u64;
typedef unsigned long long* pu64;
using i64 = __int64;
typedef volatile unsigned long long vu64;
typedef unsigned long u32;
typedef void* pv;
typedef void* pv64;
typedef unsigned short u16;
typedef unsigned char u8;
typedef unsigned char* pu8;
typedef unsigned long long QWORD;


#define __db __debugbreak

#ifdef dbgmode
#define dbgdb __db
#define __dbgdb dbgdb
#else
#define dbgdb() 
#define __dbgdb() 
#endif



#define RVA(Instr, InstrSize) ((DWORD64)Instr + InstrSize + *(LONG*)((DWORD64)Instr + (InstrSize - sizeof(LONG))))


#define PAGE_2MB_SIZE				0x200000
#define	CR3_FLAG_ALL_BITS			0xFFF0000000000FFF

typedef union _virt_addr_t
{
	ULONG64 value;
	struct
	{
		ULONG64 offset : 12;
		ULONG64 pt_index : 9;
		ULONG64 pd_index : 9;
		ULONG64 pdpt_index : 9;
		ULONG64 pml4_index : 9;
		ULONG64 reserved : 16;
	};
	struct
	{
		ULONG64 large_page_offset : 21;
	};
} virt_addr_t, * pvirt_addr_t;

typedef struct _CURDIR
{
	struct _UNICODE_STRING DosPath;                                         //0x0
	VOID* Handle;                                                           //0x10
} CURDIR, * PCURDIR;

union ThreadMiscFlags
{
	struct
	{
		ULONG AutoBoostActive : 1;                                        //0x74
		ULONG ReadyTransition : 1;                                        //0x74
		ULONG WaitNext : 1;                                               //0x74
		ULONG SystemAffinityActive : 1;                                   //0x74
		ULONG Alertable : 1;                                              //0x74
		ULONG UserStackWalkActive : 1;                                    //0x74
		ULONG ApcInterruptRequest : 1;                                    //0x74
		ULONG QuantumEndMigrate : 1;                                      //0x74
		ULONG UmsDirectedSwitchEnable : 1;                                //0x74
		ULONG TimerActive : 1;                                            //0x74
		ULONG SystemThread : 1;                                           //0x74
		ULONG ProcessDetachActive : 1;                                    //0x74
		ULONG CalloutActive : 1;                                          //0x74
		ULONG ScbReadyQueue : 1;                                          //0x74
		ULONG ApcQueueable : 1;                                           //0x74
		ULONG ReservedStackInUse : 1;                                     //0x74
		ULONG UmsPerformingSyscall : 1;                                   //0x74
		ULONG TimerSuspended : 1;                                         //0x74
		ULONG SuspendedWaitMode : 1;                                      //0x74
		ULONG SuspendSchedulerApcWait : 1;                                //0x74
		ULONG CetUserShadowStack : 1;                                     //0x74
		ULONG BypassProcessFreeze : 1;                                    //0x74
		ULONG Reserved : 10;                                              //0x74
	};
	LONG MiscFlags;                                                     //0x74
};

#define MemoryWorkingSetList 1
#define MemorySectionName 2
#define MemoryBasicVlmInformation 3
#define MemoryWorkingSetExList 4

typedef union _PSAPI_WORKING_SET_BLOCK {
	ULONG_PTR Flags;
	struct {
		ULONG_PTR Protection : 5;
		ULONG_PTR ShareCount : 3;
		ULONG_PTR Shared : 1;
		ULONG_PTR Reserved : 3;
#if defined(_WIN64)
		ULONG_PTR VirtualPage : 52;
#else
		ULONG_PTR VirtualPage : 20;
#endif
	};
} PSAPI_WORKING_SET_BLOCK, * PPSAPI_WORKING_SET_BLOCK;

typedef struct _PSAPI_WORKING_SET_INFORMATION {
	ULONG_PTR NumberOfEntries;
	PSAPI_WORKING_SET_BLOCK WorkingSetInfo[1];
} PSAPI_WORKING_SET_INFORMATION, * PPSAPI_WORKING_SET_INFORMATION;

typedef union _PSAPI_WORKING_SET_EX_BLOCK {
	ULONG_PTR Flags;
	union {
		struct {
			ULONG_PTR Valid : 1;
			ULONG_PTR ShareCount : 3;
			ULONG_PTR Win32Protection : 11;
			ULONG_PTR Shared : 1;
			ULONG_PTR Node : 6;
			ULONG_PTR Locked : 1;
			ULONG_PTR LargePage : 1;
			ULONG_PTR Reserved : 7;
			ULONG_PTR Bad : 1;

#if defined(_WIN64)
			ULONG_PTR ReservedUlong : 32;
#endif
		};
		struct {
			ULONG_PTR Valid : 1;            // Valid = 0 in this format.
			ULONG_PTR Reserved0 : 14;
			ULONG_PTR Shared : 1;
			ULONG_PTR Reserved1 : 15;
			ULONG_PTR Bad : 1;

#if defined(_WIN64)
			ULONG_PTR ReservedUlong : 32;
#endif
		} Invalid;
	};
} PSAPI_WORKING_SET_EX_BLOCK, * PPSAPI_WORKING_SET_EX_BLOCK;

typedef struct _PSAPI_WORKING_SET_EX_INFORMATION {
	PVOID VirtualAddress;
	PSAPI_WORKING_SET_EX_BLOCK VirtualAttributes;
} PSAPI_WORKING_SET_EX_INFORMATION, * PPSAPI_WORKING_SET_EX_INFORMATION;

typedef enum _KAPC_ENVIRONMENT
{
	OriginalApcEnvironment,
	AttachedApcEnvironment,
	CurrentApcEnvironment,
	InsertApcEnvironment
} KAPC_ENVIRONMENT, * PKAPC_ENVIRONMENT;

typedef VOID(NTAPI* PKNORMAL_ROUTINE)(
	PVOID NormalContext,
	PVOID SystemArgument1,
	PVOID SystemArgument2
	);

typedef VOID(NTAPI* PKRUNDOWN_ROUTINE)(PRKAPC Apc);

typedef VOID(NTAPI* PKNORMAL_ROUTINE)(
	PVOID NormalContext,
	PVOID SystemArgument1,
	PVOID SystemArgument2
	);

typedef VOID(NTAPI* PKKERNEL_ROUTINE)(
	PRKAPC Apc,
	PKNORMAL_ROUTINE* NormalRoutine,
	PVOID* NormalContext,
	PVOID* SystemArgument1,
	PVOID* SystemArgument2
	);

typedef struct _RTL_USER_PROCESS_PARAMETERS
{
	ULONG MaximumLength;                                                    //0x0
	ULONG Length;                                                           //0x4
	ULONG Flags;                                                            //0x8
	ULONG DebugFlags;                                                       //0xc
	VOID* ConsoleHandle;                                                    //0x10
	ULONG ConsoleFlags;                                                     //0x18
	VOID* StandardInput;                                                    //0x20
	VOID* StandardOutput;                                                   //0x28
	VOID* StandardError;                                                    //0x30
	struct _CURDIR CurrentDirectory;                                        //0x38
	struct _UNICODE_STRING DllPath;                                         //0x50
	struct _UNICODE_STRING ImagePathName;                                   //0x60
	struct _UNICODE_STRING CommandLine;                                     //0x70
	VOID* Environment;                                                      //0x80
	ULONG StartingX;                                                        //0x88
	ULONG StartingY;                                                        //0x8c
	ULONG CountX;                                                           //0x90
	ULONG CountY;                                                           //0x94
	ULONG CountCharsX;                                                      //0x98
	ULONG CountCharsY;                                                      //0x9c
	ULONG FillAttribute;                                                    //0xa0
	ULONG WindowFlags;                                                      //0xa4
	ULONG ShowWindowFlags;                                                  //0xa8
	struct _UNICODE_STRING WindowTitle;                                     //0xb0
	struct _UNICODE_STRING DesktopInfo;                                     //0xc0
	struct _UNICODE_STRING ShellInfo;                                       //0xd0
	struct _UNICODE_STRING RuntimeData;                                     //0xe0
} RTL_USER_PROCESS_PARAMETERS, * PRTL_USER_PROCESS_PARAMETERS;

typedef struct _PEB32 {
	UCHAR InheritedAddressSpace;
	UCHAR ReadImageFileExecOptions;
	UCHAR BeingDebugged;
	UCHAR Spare;
	ULONG Mutant;
	ULONG ImageBaseAddress;
	ULONG/*PPEB_LDR_DATA32*/ Ldr;
	ULONG ProcessParameters;
} PEB32, * PPEB32;

typedef struct _PEB64 {
	UCHAR InheritedAddressSpace;
	UCHAR ReadImageFileExecOptions;
	UCHAR BeingDebugged;
	UCHAR Spare;
	UCHAR Padding0[4];
	ULONG64 Mutant;
	ULONG64 ImageBaseAddress;
	ULONG64/*PPEB_LDR_DATA64*/ Ldr;
	RTL_USER_PROCESS_PARAMETERS* ProcessParameters;
} PEB64, * PPEB64;


typedef struct _PEB_LDR_DATA32 {
	ULONG Length;
	UCHAR Initialized;
	ULONG SsHandle;
	LIST_ENTRY32 InLoadOrderModuleList;
	LIST_ENTRY32 InMemoryOrderModuleList;
	LIST_ENTRY32 InInitializationOrderModuleList;
	ULONG EntryInProgress;
} PEB_LDR_DATA32, * PPEB_LDR_DATA32;

typedef struct _LDR_DATA_TABLE_ENTRY32 {
	LIST_ENTRY32 InLoadOrderLinks;
	LIST_ENTRY32 InMemoryOrderLinks;
	LIST_ENTRY32 InInitializationOrderLinks;
	ULONG DllBase;
	ULONG EntryPoint;
	ULONG SizeOfImage;
	UNICODE_STRING32 FullDllName;
	UNICODE_STRING32 BaseDllName;
	ULONG Flags;
	USHORT LoadCount;
	USHORT TlsIndex;
	LIST_ENTRY32 HashLinks;
	ULONG SectionPointer;
	ULONG CheckSum;
	ULONG TimeDateStamp;
	ULONG LoadedImports;
	ULONG EntryPointActivationContext;
	ULONG PatchInformation;
	LIST_ENTRY32 ForwarderLinks;
	LIST_ENTRY32 ServiceTagLinks;
	LIST_ENTRY32 StaticLinks;
	ULONG ContextInformation;
	ULONG OriginalBase;
	LARGE_INTEGER LoadTime;
} LDR_DATA_TABLE_ENTRY32, * PLDR_DATA_TABLE_ENTRY32;

typedef struct _PEB_LDR_DATA64 {
	ULONG Length;
	UCHAR Initialized;
	ULONG64 SsHandle;
	LIST_ENTRY64 InLoadOrderModuleList;
	LIST_ENTRY64 InMemoryOrderModuleList;
	LIST_ENTRY64 InInitializationOrderModuleList;
	ULONG64 EntryInProgress;
} PEB_LDR_DATA64, * PPEB_LDR_DATA64;

typedef struct _LDR_DATA_TABLE_ENTRY64 {
	LIST_ENTRY64 InLoadOrderLinks;
	LIST_ENTRY64 InMemoryOrderLinks;
	LIST_ENTRY64 InInitializationOrderLinks;
	ULONG64 DllBase;
	ULONG64 EntryPoint;
	ULONG64 SizeOfImage;
	UNICODE_STRING FullDllName;
	UNICODE_STRING BaseDllName;
	ULONG Flags;
	USHORT LoadCount;
	USHORT TlsIndex;
	LIST_ENTRY64 HashLinks;
	ULONG64 SectionPointer;
	ULONG64 CheckSum;
	ULONG64 TimeDateStamp;
	ULONG64 LoadedImports;
	ULONG64 EntryPointActivationContext;
	ULONG64 PatchInformation;
	LIST_ENTRY64 ForwarderLinks;
	LIST_ENTRY64 ServiceTagLinks;
	LIST_ENTRY64 StaticLinks;
	ULONG64 ContextInformation;
	ULONG64 OriginalBase;
	LARGE_INTEGER LoadTime;
} LDR_DATA_TABLE_ENTRY64, * PLDR_DATA_TABLE_ENTRY64;

#define RVA(Instr, InstrSize) ((DWORD64)Instr + InstrSize + *(LONG*)((DWORD64)Instr + (InstrSize - sizeof(LONG))))
#define RVA2(Instr, InstrSize, Off) ((DWORD64)Instr + InstrSize + *(LONG*)((DWORD64)Instr + Off))

//typedef enum _PROCESS_INFORMATION_CLASS
//{
//	ProcessBasicInformation = 0, // 0, q: PROCESS_BASIC_INFORMATION, PROCESS_EXTENDED_BASIC_INFORMATION
//	ProcessQuotaLimits, // qs: QUOTA_LIMITS, QUOTA_LIMITS_EX
//	ProcessIoCounters, // q: IO_COUNTERS
//	ProcessVmCounters, // q: VM_COUNTERS, VM_COUNTERS_EX
//	ProcessTimes, // q: KERNEL_USER_TIMES
//	ProcessBasePriority, // s: KPRIORITY
//	ProcessRaisePriority, // s: ULONG
//	ProcessDebugPort, // q: HANDLE
//	ProcessExceptionPort, // s: HANDLE
//	ProcessAccessToken, // s: PROCESS_ACCESS_TOKEN
//	ProcessLdtInformation, // 10
//	ProcessLdtSize,
//	ProcessDefaultHardErrorMode, // qs: ULONG
//	ProcessIoPortHandlers, // (kernel-mode only)
//	ProcessPooledUsageAndLimits, // q: POOLED_USAGE_AND_LIMITS
//	ProcessWorkingSetWatch, // q: PROCESS_WS_WATCH_INFORMATION[]; s: void
//	ProcessUserModeIOPL,
//	ProcessEnableAlignmentFaultFixup, // s: BOOLEAN
//	ProcessPriorityClass, // qs: PROCESS_PRIORITY_CLASS
//	ProcessWx86Information,
//	ProcessHandleCount, // 20, q: ULONG, PROCESS_HANDLE_INFORMATION
//	ProcessAffinityMask, // s: KAFFINITY
//	ProcessPriorityBoost, // qs: ULONG
//	ProcessDeviceMap, // qs: PROCESS_DEVICEMAP_INFORMATION, PROCESS_DEVICEMAP_INFORMATION_EX
//	ProcessSessionInformation, // q: PROCESS_SESSION_INFORMATION
//	ProcessForegroundInformation, // s: PROCESS_FOREGROUND_BACKGROUND
//	ProcessWow64Information, // q: ULONG_PTR
//	ProcessImageFileName, // q: UNICODE_STRING
//	ProcessLUIDDeviceMapsEnabled, // q: ULONG
//	ProcessBreakOnTermination, // qs: ULONG
//	ProcessDebugObjectHandle, // 30, q: HANDLE
//	ProcessDebugFlags, // qs: ULONG
//	ProcessHandleTracing, // q: PROCESS_HANDLE_TRACING_QUERY; s: size 0 disables, otherwise enables
//	ProcessIoPriority, // qs: ULONG
//	ProcessExecuteFlags, // qs: ULONG
//	ProcessResourceManagement,
//	ProcessCookie, // q: ULONG
//	ProcessImageInformation, // q: SECTION_IMAGE_INFORMATION
//	ProcessCycleTime, // q: PROCESS_CYCLE_TIME_INFORMATION
//	ProcessPagePriority, // q: ULONG
//	ProcessInstrumentationCallback, // 40
//	ProcessThreadStackAllocation, // s: PROCESS_STACK_ALLOCATION_INFORMATION, PROCESS_STACK_ALLOCATION_INFORMATION_EX
//	ProcessWorkingSetWatchEx, // q: PROCESS_WS_WATCH_INFORMATION_EX[]
//	ProcessImageFileNameWin32, // q: UNICODE_STRING
//	ProcessImageFileMapping, // q: HANDLE (input)
//	ProcessAffinityUpdateMode, // qs: PROCESS_AFFINITY_UPDATE_MODE
//	ProcessMemoryAllocationMode, // qs: PROCESS_MEMORY_ALLOCATION_MODE
//	ProcessGroupInformation, // q: USHORT[]
//	ProcessTokenVirtualizationEnabled, // s: ULONG
//	ProcessConsoleHostProcess, // q: ULONG_PTR
//	ProcessWindowInformation, // 50, q: PROCESS_WINDOW_INFORMATION
//	ProcessHandleInformation, // q: PROCESS_HANDLE_SNAPSHOT_INFORMATION // since WIN8
//	ProcessMitigationPolicy, // s: PROCESS_MITIGATION_POLICY_INFORMATION
//	ProcessDynamicFunctionTableInformation,
//	ProcessHandleCheckingMode,
//	ProcessKeepAliveCount, // q: PROCESS_KEEPALIVE_COUNT_INFORMATION
//	ProcessRevokeFileHandles, // s: PROCESS_REVOKE_FILE_HANDLES_INFORMATION
//	MaxProcessInfoClass
//} PROCESS_INFORMATION_CLASS;

typedef struct _DBGKD_DEBUG_DATA_HEADER64 {
	//
	// Link to other blocks
	//
	LIST_ENTRY64 List;

	//
	// This is a unique tag to identify the owner of the block.
	// If your component only uses one pool tag, use it for this, too.
	//
	ULONG           OwnerTag;

	//
	// This must be initialized to the size of the data block,
	// including this structure.
	//
	ULONG           Size;

} DBGKD_DEBUG_DATA_HEADER64, * PDBGKD_DEBUG_DATA_HEADER64;

typedef struct _KDDEBUGGER_DATA64 {

	DBGKD_DEBUG_DATA_HEADER64 Header;

	//
	// Base address of kernel image
	//
	ULONG64   KernBase;

	//
	// DbgBreakPointWithStatus is a function which takes an argument
	// and hits a breakpoint.  This field contains the address of the
	// breakpoint instruction.  When the debugger sees a breakpoint
	// at this address, it may retrieve the argument from the first
	// argument register, or on x86 the eax register.
	//
	ULONG64   BreakpointWithStatus;       // address of breakpoint

	//
	// Address of the saved context record during a bugcheck
	//
	// N.B. This is an automatic in KeBugcheckEx's frame, and
	// is only valid after a bugcheck.
	//
	ULONG64   SavedContext;

	//
	// help for walking stacks with user callbacks:
	//

	//
	// The address of the thread structure is provided in the
	// WAIT_STATE_CHANGE packet.  This is the offset from the base of
	// the thread structure to the pointer to the kernel stack frame
	// for the currently active usermode callback.
	//
	USHORT  ThCallbackStack;            // offset in thread data

	//
	// these values are offsets into that frame:
	//
	USHORT  NextCallback;               // saved pointer to next callback frame
	USHORT  FramePointer;               // saved frame pointer

	//
	// pad to a quad boundary
	//
	USHORT  PaeEnabled;

	//
	// Address of the kernel callout routine.
	//
	ULONG64   KiCallUserMode;             // kernel routine

	//
	// Address of the usermode entry point for callbacks.
	//
	ULONG64   KeUserCallbackDispatcher;   // address in ntdll

	//
	// Addresses of various kernel data structures and lists
	// that are of interest to the kernel debugger.
	//

	ULONG64   PsLoadedModuleList;
	ULONG64   PsActiveProcessHead;
	ULONG64   PspCidTable;

	ULONG64   ExpSystemResourcesList;
	ULONG64   ExpPagedPoolDescriptor;
	ULONG64   ExpNumberOfPagedPools;

	ULONG64   KeTimeIncrement;
	ULONG64   KeBugCheckCallbackListHead;
	ULONG64   KiBugcheckData;

	ULONG64   IopErrorLogListHead;

	ULONG64   ObpRootDirectoryObject;
	ULONG64   ObpTypeObjectType;

	ULONG64   MmSystemCacheStart;
	ULONG64   MmSystemCacheEnd;
	ULONG64   MmSystemCacheWs;

	ULONG64   MmPfnDatabase;
	ULONG64   MmSystemPtesStart;
	ULONG64   MmSystemPtesEnd;
	ULONG64   MmSubsectionBase;
	ULONG64   MmNumberOfPagingFiles;

	ULONG64   MmLowestPhysicalPage;
	ULONG64   MmHighestPhysicalPage;
	ULONG64   MmNumberOfPhysicalPages;

	ULONG64   MmMaximumNonPagedPoolInBytes;
	ULONG64   MmNonPagedSystemStart;
	ULONG64   MmNonPagedPoolStart;
	ULONG64   MmNonPagedPoolEnd;

	ULONG64   MmPagedPoolStart;
	ULONG64   MmPagedPoolEnd;
	ULONG64   MmPagedPoolInformation;
	ULONG64   MmPageSize;

	ULONG64   MmSizeOfPagedPoolInBytes;

	ULONG64   MmTotalCommitLimit;
	ULONG64   MmTotalCommittedPages;
	ULONG64   MmSharedCommit;
	ULONG64   MmDriverCommit;
	ULONG64   MmProcessCommit;
	ULONG64   MmPagedPoolCommit;
	ULONG64   MmExtendedCommit;

	ULONG64   MmZeroedPageListHead;
	ULONG64   MmFreePageListHead;
	ULONG64   MmStandbyPageListHead;
	ULONG64   MmModifiedPageListHead;
	ULONG64   MmModifiedNoWritePageListHead;
	ULONG64   MmAvailablePages;
	ULONG64   MmResidentAvailablePages;

	ULONG64   PoolTrackTable;
	ULONG64   NonPagedPoolDescriptor;

	ULONG64   MmHighestUserAddress;
	ULONG64   MmSystemRangeStart;
	ULONG64   MmUserProbeAddress;

	ULONG64   KdPrintCircularBuffer;
	ULONG64   KdPrintCircularBufferEnd;
	ULONG64   KdPrintWritePointer;
	ULONG64   KdPrintRolloverCount;

	ULONG64   MmLoadedUserImageList;

	// NT 5.1 Addition

	ULONG64   NtBuildLab;
	ULONG64   KiNormalSystemCall;

	// NT 5.0 hotfix addition

	ULONG64   KiProcessorBlock;
	ULONG64   MmUnloadedDrivers;
	ULONG64   MmLastUnloadedDriver;
	ULONG64   MmTriageActionTaken;
	ULONG64   MmSpecialPoolTag;
	ULONG64   KernelVerifier;
	ULONG64   MmVerifierData;
	ULONG64   MmAllocatedNonPagedPool;
	ULONG64   MmPeakCommitment;
	ULONG64   MmTotalCommitLimitMaximum;
	ULONG64   CmNtCSDVersion;

	// NT 5.1 Addition

	ULONG64   MmPhysicalMemoryBlock;
	ULONG64   MmSessionBase;
	ULONG64   MmSessionSize;
	ULONG64   MmSystemParentTablePage;

	// Server 2003 addition

	ULONG64   MmVirtualTranslationBase;

	USHORT    OffsetKThreadNextProcessor;
	USHORT    OffsetKThreadTeb;
	USHORT    OffsetKThreadKernelStack;
	USHORT    OffsetKThreadInitialStack;

	USHORT    OffsetKThreadApcProcess;
	USHORT    OffsetKThreadState;
	USHORT    OffsetKThreadBStore;
	USHORT    OffsetKThreadBStoreLimit;

	USHORT    SizeEProcess;
	USHORT    OffsetEprocessPeb;
	USHORT    OffsetEprocessParentCID;
	USHORT    OffsetEprocessDirectoryTableBase;

	USHORT    SizePrcb;
	USHORT    OffsetPrcbDpcRoutine;
	USHORT    OffsetPrcbCurrentThread;
	USHORT    OffsetPrcbMhz;

	USHORT    OffsetPrcbCpuType;
	USHORT    OffsetPrcbVendorString;
	USHORT    OffsetPrcbProcStateContext;
	USHORT    OffsetPrcbNumber;

	USHORT    SizeEThread;

	ULONG64   KdPrintCircularBufferPtr;
	ULONG64   KdPrintBufferSize;

	ULONG64   KeLoaderBlock;

	USHORT    SizePcr;
	USHORT    OffsetPcrSelfPcr;
	USHORT    OffsetPcrCurrentPrcb;
	USHORT    OffsetPcrContainedPrcb;

	USHORT    OffsetPcrInitialBStore;
	USHORT    OffsetPcrBStoreLimit;
	USHORT    OffsetPcrInitialStack;
	USHORT    OffsetPcrStackLimit;

	USHORT    OffsetPrcbPcrPage;
	USHORT    OffsetPrcbProcStateSpecialReg;
	USHORT    GdtR0Code;
	USHORT    GdtR0Data;

	USHORT    GdtR0Pcr;
	USHORT    GdtR3Code;
	USHORT    GdtR3Data;
	USHORT    GdtR3Teb;

	USHORT    GdtLdt;
	USHORT    GdtTss;
	USHORT    Gdt64R3CmCode;
	USHORT    Gdt64R3CmTeb;

	ULONG64   IopNumTriageDumpDataBlocks;
	ULONG64   IopTriageDumpDataBlocks;

	// Longhorn addition

	ULONG64   VfCrashDataBlock;
	ULONG64   MmBadPagesDetected;
	ULONG64   MmZeroedPageSingleBitErrorsDetected;

	// Windows 7 addition

	ULONG64   EtwpDebuggerData;
	USHORT    OffsetPrcbContext;

	// Windows 8 addition

	USHORT    OffsetPrcbMaxBreakpoints;
	USHORT    OffsetPrcbMaxWatchpoints;

	ULONG     OffsetKThreadStackLimit;
	ULONG     OffsetKThreadStackBase;
	ULONG     OffsetKThreadQueueListEntry;
	ULONG     OffsetEThreadIrpList;

	USHORT    OffsetPrcbIdleThread;
	USHORT    OffsetPrcbNormalDpcState;
	USHORT    OffsetPrcbDpcStack;
	USHORT    OffsetPrcbIsrStack;

	USHORT    SizeKDPC_STACK_FRAME;

	// Windows 8.1 Addition

	USHORT    OffsetKPriQueueThreadListHead;
	USHORT    OffsetKThreadWaitReason;

	// Windows 10 RS1 Addition

	USHORT    Padding;
	ULONG64   PteBase;

	// Windows 10 RS5 Addition

	ULONG64 RetpolineStubFunctionTable;
	ULONG RetpolineStubFunctionTableSize;
	ULONG RetpolineStubOffset;
	ULONG RetpolineStubSize;

} KDDEBUGGER_DATA64, * PKDDEBUGGER_DATA64;

typedef struct _DUMP_HEADER
{
	ULONG Signature;
	ULONG ValidDump;
	ULONG MajorVersion;
	ULONG MinorVersion;
	ULONG_PTR DirectoryTableBase;
	ULONG_PTR PfnDataBase;
	PLIST_ENTRY PsLoadedModuleList;
	PLIST_ENTRY PsActiveProcessHead;
	ULONG MachineImageType;
	ULONG NumberProcessors;
	ULONG BugCheckCode;
	ULONG_PTR BugCheckParameter1;
	ULONG_PTR BugCheckParameter2;
	ULONG_PTR BugCheckParameter3;
	ULONG_PTR BugCheckParameter4;
	CHAR VersionUser[32];
	struct _KDDEBUGGER_DATA64* KdDebuggerDataBlock;
} DUMP_HEADER, * PDUMP_HEADER;

C_ASSERT(FIELD_OFFSET(DUMP_HEADER, Signature) == 0);
C_ASSERT(FIELD_OFFSET(DUMP_HEADER, ValidDump) == 4);
C_ASSERT(FIELD_OFFSET(DUMP_HEADER, MajorVersion) == 8);
C_ASSERT(FIELD_OFFSET(DUMP_HEADER, MinorVersion) == 0xc);
C_ASSERT(FIELD_OFFSET(DUMP_HEADER, DirectoryTableBase) == 0x10);
C_ASSERT(FIELD_OFFSET(DUMP_HEADER, PfnDataBase) == 0x18);
C_ASSERT(FIELD_OFFSET(DUMP_HEADER, PsLoadedModuleList) == 0x20);
C_ASSERT(FIELD_OFFSET(DUMP_HEADER, PsActiveProcessHead) == 0x28);
C_ASSERT(FIELD_OFFSET(DUMP_HEADER, MachineImageType) == 0x30);
C_ASSERT(FIELD_OFFSET(DUMP_HEADER, NumberProcessors) == 0x34);
C_ASSERT(FIELD_OFFSET(DUMP_HEADER, BugCheckCode) == 0x38);
C_ASSERT(FIELD_OFFSET(DUMP_HEADER, BugCheckParameter1) == 0x40);
C_ASSERT(FIELD_OFFSET(DUMP_HEADER, BugCheckParameter2) == 0x48);
C_ASSERT(FIELD_OFFSET(DUMP_HEADER, BugCheckParameter3) == 0x50);
C_ASSERT(FIELD_OFFSET(DUMP_HEADER, BugCheckParameter4) == 0x58);
C_ASSERT(FIELD_OFFSET(DUMP_HEADER, KdDebuggerDataBlock) == 0x80);

typedef enum _SYSTEM_INFORMATION_CLASS
{
	SystemBasicInformation = 0x0,
	SystemProcessorInformation = 0x1,
	SystemPerformanceInformation = 0x2,
	SystemTimeOfDayInformation = 0x3,
	SystemPathInformation = 0x4,
	SystemProcessInformation = 0x5,
	SystemCallCountInformation = 0x6,
	SystemDeviceInformation = 0x7,
	SystemProcessorPerformanceInformation = 0x8,
	SystemFlagsInformation = 0x9,
	SystemCallTimeInformation = 0xa,
	SystemModuleInformation = 0xb,
	SystemLocksInformation = 0xc,
	SystemStackTraceInformation = 0xd,
	SystemPagedPoolInformation = 0xe,
	SystemNonPagedPoolInformation = 0xf,
	SystemHandleInformation = 0x10,
	SystemObjectInformation = 0x11,
	SystemPageFileInformation = 0x12,
	SystemVdmInstemulInformation = 0x13,
	SystemVdmBopInformation = 0x14,
	SystemFileCacheInformation = 0x15,
	SystemPoolTagInformation = 0x16,
	SystemInterruptInformation = 0x17,
	SystemDpcBehaviorInformation = 0x18,
	SystemFullMemoryInformation = 0x19,
	SystemLoadGdiDriverInformation = 0x1a,
	SystemUnloadGdiDriverInformation = 0x1b,
	SystemTimeAdjustmentInformation = 0x1c,
	SystemSummaryMemoryInformation = 0x1d,
	SystemMirrorMemoryInformation = 0x1e,
	SystemPerformanceTraceInformation = 0x1f,
	SystemObsolete0 = 0x20,
	SystemExceptionInformation = 0x21,
	SystemCrashDumpStateInformation = 0x22,
	SystemKernelDebuggerInformation = 0x23,
	SystemContextSwitchInformation = 0x24,
	SystemRegistryQuotaInformation = 0x25,
	SystemExtendServiceTableInformation = 0x26,
	SystemPrioritySeperation = 0x27,
	SystemVerifierAddDriverInformation = 0x28,
	SystemVerifierRemoveDriverInformation = 0x29,
	SystemProcessorIdleInformation = 0x2a,
	SystemLegacyDriverInformation = 0x2b,
	SystemCurrentTimeZoneInformation = 0x2c,
	SystemLookasideInformation = 0x2d,
	SystemTimeSlipNotification = 0x2e,
	SystemSessionCreate = 0x2f,
	SystemSessionDetach = 0x30,
	SystemSessionInformation = 0x31,
	SystemRangeStartInformation = 0x32,
	SystemVerifierInformation = 0x33,
	SystemVerifierThunkExtend = 0x34,
	SystemSessionProcessInformation = 0x35,
	SystemLoadGdiDriverInSystemSpace = 0x36,
	SystemNumaProcessorMap = 0x37,
	SystemPrefetcherInformation = 0x38,
	SystemExtendedProcessInformation = 0x39,
	SystemRecommendedSharedDataAlignment = 0x3a,
	SystemComPlusPackage = 0x3b,
	SystemNumaAvailableMemory = 0x3c,
	SystemProcessorPowerInformation = 0x3d,
	SystemEmulationBasicInformation = 0x3e,
	SystemEmulationProcessorInformation = 0x3f,
	SystemExtendedHandleInformation = 0x40,
	SystemLostDelayedWriteInformation = 0x41,
	SystemBigPoolInformation = 0x42,
	SystemSessionPoolTagInformation = 0x43,
	SystemSessionMappedViewInformation = 0x44,
	SystemHotpatchInformation = 0x45,
	SystemObjectSecurityMode = 0x46,
	SystemWatchdogTimerHandler = 0x47,
	SystemWatchdogTimerInformation = 0x48,
	SystemLogicalProcessorInformation = 0x49,
	SystemWow64SharedInformationObsolete = 0x4a,
	SystemRegisterFirmwareTableInformationHandler = 0x4b,
	SystemFirmwareTableInformation = 0x4c,
	SystemModuleInformationEx = 0x4d,
	SystemVerifierTriageInformation = 0x4e,
	SystemSuperfetchInformation = 0x4f,
	SystemMemoryListInformation = 0x50,
	SystemFileCacheInformationEx = 0x51,
	SystemThreadPriorityClientIdInformation = 0x52,
	SystemProcessorIdleCycleTimeInformation = 0x53,
	SystemVerifierCancellationInformation = 0x54,
	SystemProcessorPowerInformationEx = 0x55,
	SystemRefTraceInformation = 0x56,
	SystemSpecialPoolInformation = 0x57,
	SystemProcessIdInformation = 0x58,
	SystemErrorPortInformation = 0x59,
	SystemBootEnvironmentInformation = 0x5a,
	SystemHypervisorInformation = 0x5b,
	SystemVerifierInformationEx = 0x5c,
	SystemTimeZoneInformation = 0x5d,
	SystemImageFileExecutionOptionsInformation = 0x5e,
	SystemCoverageInformation = 0x5f,
	SystemPrefetchPatchInformation = 0x60,
	SystemVerifierFaultsInformation = 0x61,
	SystemSystemPartitionInformation = 0x62,
	SystemSystemDiskInformation = 0x63,
	SystemProcessorPerformanceDistribution = 0x64,
	SystemNumaProximityNodeInformation = 0x65,
	SystemDynamicTimeZoneInformation = 0x66,
	SystemCodeIntegrityInformation = 0x67,
	SystemProcessorMicrocodeUpdateInformation = 0x68,
	SystemProcessorBrandString = 0x69,
	SystemVirtualAddressInformation = 0x6a,
	SystemLogicalProcessorAndGroupInformation = 0x6b,
	SystemProcessorCycleTimeInformation = 0x6c,
	SystemStoreInformation = 0x6d,
	SystemRegistryAppendString = 0x6e,
	SystemAitSamplingValue = 0x6f,
	SystemVhdBootInformation = 0x70,
	SystemCpuQuotaInformation = 0x71,
	SystemNativeBasicInformation = 0x72,
	SystemErrorPortTimeouts = 0x73,
	SystemLowPriorityIoInformation = 0x74,
	SystemBootEntropyInformation = 0x75,
	SystemVerifierCountersInformation = 0x76,
	SystemPagedPoolInformationEx = 0x77,
	SystemSystemPtesInformationEx = 0x78,
	SystemNodeDistanceInformation = 0x79,
	SystemAcpiAuditInformation = 0x7a,
	SystemBasicPerformanceInformation = 0x7b,
	SystemQueryPerformanceCounterInformation = 0x7c,
	SystemSessionBigPoolInformation = 0x7d,
	SystemBootGraphicsInformation = 0x7e,
	SystemScrubPhysicalMemoryInformation = 0x7f,
	SystemBadPageInformation = 0x80,
	SystemProcessorProfileControlArea = 0x81,
	SystemCombinePhysicalMemoryInformation = 0x82,
	SystemEntropyInterruptTimingInformation = 0x83,
	SystemConsoleInformation = 0x84,
	SystemPlatformBinaryInformation = 0x85,
	SystemThrottleNotificationInformation = 0x86,
	SystemHypervisorProcessorCountInformation = 0x87,
	SystemDeviceDataInformation = 0x88,
	SystemDeviceDataEnumerationInformation = 0x89,
	SystemMemoryTopologyInformation = 0x8a,
	SystemMemoryChannelInformation = 0x8b,
	SystemBootLogoInformation = 0x8c,
	SystemProcessorPerformanceInformationEx = 0x8d,
	SystemSpare0 = 0x8e,
	SystemSecureBootPolicyInformation = 0x8f,
	SystemPageFileInformationEx = 0x90,
	SystemSecureBootInformation = 0x91,
	SystemEntropyInterruptTimingRawInformation = 0x92,
	SystemPortableWorkspaceEfiLauncherInformation = 0x93,
	SystemFullProcessInformation = 0x94,
	SystemKernelDebuggerInformationEx = 0x95,
	SystemBootMetadataInformation = 0x96,
	SystemSoftRebootInformation = 0x97,
	SystemElamCertificateInformation = 0x98,
	SystemOfflineDumpConfigInformation = 0x99,
	SystemProcessorFeaturesInformation = 0x9a,
	SystemRegistryReconciliationInformation = 0x9b,
	MaxSystemInfoClass = 0x9c,
} SYSTEM_INFORMATION_CLASS;

typedef struct _SYSTEM_MODULE_ENTRY {
	HANDLE Section;
	PVOID MappedBase;
	PVOID ImageBase;
	ULONG ImageSize;
	ULONG Flags;
	USHORT LoadOrderIndex;
	USHORT InitOrderIndex;
	USHORT LoadCount;
	USHORT OffsetToFileName;
	UCHAR FullPathName[256];
} SYSTEM_MODULE_ENTRY, * PSYSTEM_MODULE_ENTRY;

typedef struct _SYSTEM_MODULE_INFORMATION {
	ULONG Count;
	SYSTEM_MODULE_ENTRY Module[1];
} SYSTEM_MODULE_INFORMATION, * PSYSTEM_MODULE_INFORMATION;

typedef struct _SYSTEM_THREAD_INFORMATION
{
	LARGE_INTEGER KernelTime;
	LARGE_INTEGER UserTime;
	LARGE_INTEGER CreateTime;
	ULONG WaitTime;
	PVOID StartAddress;
	CLIENT_ID ClientId;
	KPRIORITY Priority;
	LONG BasePriority;
	ULONG ContextSwitches;
	ULONG ThreadState;
	KWAIT_REASON WaitReason;
}SYSTEM_THREAD_INFORMATION, * PSYSTEM_THREAD_INFORMATION;
typedef struct _SYSTEM_PROCESS_INFO
{
	ULONG NextEntryOffset;
	ULONG NumberOfThreads;
	LARGE_INTEGER WorkingSetPrivateSize;
	ULONG HardFaultCount;
	ULONG NumberOfThreadsHighWatermark;
	ULONGLONG CycleTime;
	LARGE_INTEGER CreateTime;
	LARGE_INTEGER UserTime;
	LARGE_INTEGER KernelTime;
	UNICODE_STRING ImageName;
	KPRIORITY BasePriority;
	HANDLE UniqueProcessId;
	HANDLE InheritedFromUniqueProcessId;
	ULONG HandleCount;
	ULONG SessionId;
	ULONG_PTR UniqueProcessKey;
	SIZE_T PeakVirtualSize;
	SIZE_T VirtualSize;
	ULONG PageFaultCount;
	SIZE_T PeakWorkingSetSize;
	SIZE_T WorkingSetSize;
	SIZE_T QuotaPeakPagedPoolUsage;
	SIZE_T QuotaPagedPoolUsage;
	SIZE_T QuotaPeakNonPagedPoolUsage;
	SIZE_T QuotaNonPagedPoolUsage;
	SIZE_T PagefileUsage;
	SIZE_T PeakPagefileUsage;
	SIZE_T PrivatePageCount;
	LARGE_INTEGER ReadOperationCount;
	LARGE_INTEGER WriteOperationCount;
	LARGE_INTEGER OtherOperationCount;
	LARGE_INTEGER ReadTransferCount;
	LARGE_INTEGER WriteTransferCount;
	LARGE_INTEGER OtherTransferCount;
	SYSTEM_THREAD_INFORMATION Threads[1];
}SYSTEM_PROCESS_INFO, * PSYSTEM_PROCESS_INFO;

typedef struct _SYSTEM_SESSION_PROCESS_INFORMATION
{
	ULONG SessionId;
	ULONG SizeOfBuf;
	PVOID Buffer;
}SYSTEM_SESSION_PROCESS_INFORMATION, * PSYSTEM_SESSION_PROCESS_INFORMATION;

typedef struct _OBJECT_TYPE_INFORMATION
{
	UNICODE_STRING TypeName;
	ULONG TotalNumberOfObjects;
	ULONG TotalNumberOfHandles;
	ULONG Reserved[40];
} OBJECT_TYPE_INFORMATION, * POBJECT_TYPE_INFORMATION;

typedef struct _SYSTEM_SERVICE_TABLE {
	LONG* ServiceTable;
	PVOID ServiceCounterTableBase;
	ULONG64 NumberOfService;
	PVOID ParamTableBase;
}_SYSTEM_SERVICE_TABLE, * PSYSTEM_SERVICE_TABLE;

typedef struct _SYSTEM_HANDLE_TABLE_ENTRY_INFO
{
	USHORT UniqueProcessId;
	USHORT CreatorBackTraceIndex;
	UCHAR ObjectTypeIndex;
	UCHAR HandleAttributes;
	USHORT HandleValue;
	PVOID Object;
	ULONG GrantedAccess;
}SYSTEM_HANDLE_TABLE_ENTRY_INFO, * PSYSTEM_HANDLE_TABLE_ENTRY_INFO;

typedef struct _SYSTEM_HANDLE_INFORMATION
{
	ULONG NumberOfHandles;
	SYSTEM_HANDLE_TABLE_ENTRY_INFO Handles[1];
}SYSTEM_HANDLE_INFORMATION, * PSYSTEM_HANDLE_INFORMATION;

typedef struct _SYSTEM_HANDLE_TABLE_ENTRY_INFO_EX
{
	PVOID Object;
	ULONG_PTR UniqueProcessId;
	ULONG_PTR HandleValue;
	ULONG GrantedAccess;
	USHORT CreatorBackTraceIndex;
	USHORT ObjectTypeIndex;
	ULONG HandleAttributes;
	ULONG Reserved;
}SYSTEM_HANDLE_TABLE_ENTRY_INFO_EX, * PSYSTEM_HANDLE_TABLE_ENTRY_INFO_EX;

typedef struct _SYSTEM_HANDLE_INFORMATION_EX
{
	ULONG_PTR NumberOfHandles;
	ULONG_PTR Reserved;
	SYSTEM_HANDLE_TABLE_ENTRY_INFO_EX Handles[1];
}SYSTEM_HANDLE_INFORMATION_EX, * PSYSTEM_HANDLE_INFORMATION_EX;

typedef struct _CFG_CALL_TARGET_INFO {
	ULONG_PTR Offset;
	ULONG_PTR Flags;
} CFG_CALL_TARGET_INFO, * PCFG_CALL_TARGET_INFO;

typedef struct _VM_INFORMATION
{
	DWORD NumberOfOffsets;
	DWORD MustBeZero;
	PVOID TargetsProcessed;
	PCFG_CALL_TARGET_INFO CallTargets;
	union _Section
	{
		HANDLE Section;
		DWORD64 Data;
	} Section;
	ULONG64 ExpectedFileOffset;
} VM_INFORMATION, * PVM_INFORMATION;

union MiscFlags
{
	struct
	{
		ULONG AutoBoostActive : 1;                                        //0x74
		ULONG ReadyTransition : 1;                                        //0x74
		ULONG WaitNext : 1;                                               //0x74
		ULONG SystemAffinityActive : 1;                                   //0x74
		ULONG Alertable : 1;                                              //0x74
		ULONG UserStackWalkActive : 1;                                    //0x74
		ULONG ApcInterruptRequest : 1;                                    //0x74
		ULONG QuantumEndMigrate : 1;                                      //0x74
		ULONG UmsDirectedSwitchEnable : 1;                                //0x74
		ULONG TimerActive : 1;                                            //0x74
		ULONG SystemThread : 1;                                           //0x74
		ULONG ProcessDetachActive : 1;                                    //0x74
		ULONG CalloutActive : 1;                                          //0x74
		ULONG ScbReadyQueue : 1;                                          //0x74
		ULONG ApcQueueable : 1;                                           //0x74
		ULONG ReservedStackInUse : 1;                                     //0x74
		ULONG UmsPerformingSyscall : 1;                                   //0x74
		ULONG TimerSuspended : 1;                                         //0x74
		ULONG SuspendedWaitMode : 1;                                      //0x74
		ULONG SuspendSchedulerApcWait : 1;                                //0x74
		ULONG CetUserShadowStack : 1;                                     //0x74
		ULONG BypassProcessFreeze : 1;                                    //0x74
		ULONG Reserved : 10;                                              //0x74
	};
	LONG AsLong;                                                     //0x74
};

typedef struct _KNONVOLATILE_CONTEXT_POINTERS {
	union {
		PM128A FloatingContext[16];
		struct {
			PM128A Xmm0;
			PM128A Xmm1;
			PM128A Xmm2;
			PM128A Xmm3;
			PM128A Xmm4;
			PM128A Xmm5;
			PM128A Xmm6;
			PM128A Xmm7;
			PM128A Xmm8;
			PM128A Xmm9;
			PM128A Xmm10;
			PM128A Xmm11;
			PM128A Xmm12;
			PM128A Xmm13;
			PM128A Xmm14;
			PM128A Xmm15;
		};
	};

	union {
		PULONG64 IntegerContext[16];
		struct {
			PULONG64 Rax;
			PULONG64 Rcx;
			PULONG64 Rdx;
			PULONG64 Rbx;
			PULONG64 Rsp;
			PULONG64 Rbp;
			PULONG64 Rsi;
			PULONG64 Rdi;
			PULONG64 R8;
			PULONG64 R9;
			PULONG64 R10;
			PULONG64 R11;
			PULONG64 R12;
			PULONG64 R13;
			PULONG64 R14;
			PULONG64 R15;
		};
	};

} KNONVOLATILE_CONTEXT_POINTERS, * PKNONVOLATILE_CONTEXT_POINTERS;

typedef struct _IMAGE_RUNTIME_FUNCTION_ENTRY RUNTIME_FUNCTION, * PRUNTIME_FUNCTION;

typedef struct _KSTACK_CONTROL
{
	ULONGLONG StackBase;                                                    //0x0
	union
	{
		ULONGLONG ActualLimit;                                              //0x8
		ULONGLONG StackExpansion : 1;                                         //0x8
	};
	struct
	{
		ULONGLONG StackBase;                                                    //0x10
		ULONGLONG StackLimit;                                                   //0x18
		ULONGLONG KernelStack;                                                  //0x20
		ULONGLONG InitialStack;                                                 //0x28
		ULONGLONG KernelShadowStackBase;                                        //0x30
		ULONGLONG KernelShadowStackLimit;										//0x38
		ULONGLONG KernelShadowStack;                                            //0x40
		ULONGLONG KernelShadowStackInitial;                                     //0x48
	} Previous;
}KERNEL_STACK_CONTROL, KSTACK_CONTROL, * PKERNEL_STACK_CONTROL, * PKSTACK_CONTROL;
static_assert(sizeof(KERNEL_STACK_CONTROL) == 0x50, "size mismatch");


//Physical or Virtual is Ok
//just assume it's not large page
#define IsAcrossPages(Address,size) (( PAGE_ALIGN((u64)Address+(u64)size) == PAGE_ALIGN(Address) ) ? FALSE : TRUE)

#define noinl __declspec(noinline)
#define naked __declspec(naked)
#define inl __forceinline
#define ConstStrLen(Str) ((sizeof(Str) - sizeof(Str[0])) / sizeof(Str[0]))
#define ToLower(Char) ((Char >= 'A' && Char <= 'Z') ? (Char + 32) : Char)
#define ToUpper(Char) ((Char >= 'a' && Char <= 'z') ? (Char - 'a') : Char)
#define NT_HEADER(Base) (PIMAGE_NT_HEADERS)((ULONG64)(Base) + ((PIMAGE_DOS_HEADER)(Base))->e_lfanew)
```

`EtwHook.cpp`:

```cpp
#include "global.h"
#include "ia32.h"
#include "hde/hde64.h"

#include "EtwHook.h"

typedef struct _WNODE_HEADER
{
	ULONG BufferSize;
	ULONG ProviderId;
	union {
		ULONG64 HistoricalContext;
		struct {
			ULONG Version;
			ULONG Linkage;
		};
	};
	union {
		HANDLE KernelHandle;
		LARGE_INTEGER TimeStamp;
	};
	GUID Guid;
	ULONG ClientContext;
	ULONG Flags;
} WNODE_HEADER, * PWNODE_HEADER;

typedef struct _EVENT_TRACE_PROPERTIES
{
	WNODE_HEADER Wnode;
	ULONG BufferSize;
	ULONG MinimumBuffers;
	ULONG MaximumBuffers;
	ULONG MaximumFileSize;
	ULONG LogFileMode;
	ULONG FlushTimer;
	ULONG EnableFlags;
	union {
		LONG AgeLimit;
		LONG FlushThreshold;
	} DUMMYUNIONNAME;
	ULONG NumberOfBuffers;
	ULONG FreeBuffers;
	ULONG EventsLost;
	ULONG BuffersWritten;
	ULONG LogBuffersLost;
	ULONG RealTimeBuffersLost;
	HANDLE LoggerThreadId;
	ULONG LogFileNameOffset;
	ULONG LoggerNameOffset;
} EVENT_TRACE_PROPERTIES, * PEVENT_TRACE_PROPERTIES;

typedef struct _CKCL_TRACE_PROPERIES : EVENT_TRACE_PROPERTIES
{
	ULONG64 Unknown[3];
	UNICODE_STRING ProviderName;
} CKCL_TRACE_PROPERTIES, * PCKCL_TRACE_PROPERTIES;

//#define EtwpStartTrace		1
//#define EtwpStopTrace			2
//#define EtwpQueryTrace		3
//#define EtwpUpdateTrace		4
//#define EtwpFlushTrace		5

#define WNODE_FLAG_TRACED_GUID			0x00020000  // denotes a trace
#define EVENT_TRACE_BUFFERING_MODE      0x00000400  // Buffering mode only
#define EVENT_TRACE_FLAG_SYSTEMCALL     0x00000080  // system calls


#define INFINITYHOOK_MAGIC_1 ((ULONG)0x501802)
#define INFINITYHOOK_MAGIC_2 ((USHORT)0xF33)

using HalQueryCounterFn = u64(*)();
HalQueryCounterFn OldHalQueryCounter = 0;

ULONG64 EtwHook::HookInternalGetCpuClock()
{
	if (::EtwHook.CustomFilterRoutine)
		::EtwHook.CustomFilterRoutine();
	else
		::EtwHook.InvokeSysCall();

	return __rdtsc();
}

ULONG64 EtwHook::HookHalQueryCounter()
{
	HookInternalGetCpuClock();
	return OldHalQueryCounter();
}

//TraceWhat = EVENT_TRACE_FLAG_SYSTEMCALL 
NTSTATUS EtwHook::ModifyTraceSettings(CKCL_TRACE_OPERATION Operation, ULONG TraceWhat)
{	
	//auto SetPreviousMode = [](KPROCESSOR_MODE NewMode, u64 thread = __readgsqword(0x188)) -> KPROCESSOR_MODE
	//{
	//	auto prvmodeOff = 0x232;//*(u32*)((u64)ImpGetFunAddr(ExGetPreviousMode) + 12);
	//	auto ret = *(u8*)(thread + prvmodeOff);
	//	*(u8*)(thread + prvmodeOff) = NewMode;
	//	return ret;
	//};

	CKCL_TRACE_PROPERTIES* property = (CKCL_TRACE_PROPERTIES*)KAlloc(PAGE_SIZE);

	wchar_t* provider_name = (wchar_t*)KAlloc(256 * sizeof(wchar_t));

	RtlZeroMemory(property, PAGE_SIZE);
	RtlZeroMemory(provider_name, 256 * sizeof(wchar_t));

	RtlCopyMemory(provider_name, E(L"Circular Kernel Context Logger"), sizeof(L"Circular Kernel Context Logger"));
	ImpCall(RtlInitUnicodeString, &property->ProviderName, (const wchar_t*)provider_name);

	property->Wnode.BufferSize = PAGE_SIZE;
	property->Wnode.Flags = 0x00020000;
	property->Wnode.Guid = { 0x54dea73a, 0xed1f, 0x42a4, { 0xaf, 0x71, 0x3e, 0x63, 0xd0, 0x56, 0xf1, 0x74 } };
	property->Wnode.ClientContext = 3;
	property->BufferSize = sizeof(unsigned long);
	property->MinimumBuffers = 2;
	property->MaximumBuffers = 2;
	property->LogFileMode = 0x00000400;

	unsigned long length = 0;
	if (Operation == CKCL_UPDATE_TRACE) 
		property->EnableFlags = TraceWhat; // 0x00000080; EVENT_TRACE_FLAG_SYSTEMCALL  

	//auto OrigMode = ImpCall(ExGetPreviousMode);
	//if (OrigMode == UserMode)
	//{
	//	SetPreviousMode(KernelMode);
	//}

	NTSTATUS status = ImpCall(ZwTraceControl, Operation, property, PAGE_SIZE, property, PAGE_SIZE, &length);

	//SetPreviousMode(OrigMode);

	KFree(provider_name);
	KFree(property);

	return status;
}

bool EtwHook::InitOffset()
{
	getKernelModuleByName(E("ntoskrnl.exe"), &NtBase, 0);

	//if (!PerfGlobalGroupMask)
	//{
	//	PerfGlobalGroupMask = FindPatternRange(ImpGetFunAddr(KeReleaseSpinLock), 0x30, E("F6 05"));
	//	if (PerfGlobalGroupMask)
	//		PerfGlobalGroupMask = PerfGlobalGroupMask + *(INT*)(PerfGlobalGroupMask + 2) + 7 - 6;
	//
	//	if (!PerfGlobalGroupMask)
	//	{
	//		PerfGlobalGroupMask = FindPatternRange(ImpGetFunAddr(KeReleaseSpinLock), 0x30, E("F7 05"));
	//		if (PerfGlobalGroupMask)
	//			PerfGlobalGroupMask = PerfGlobalGroupMask + *(INT*)(PerfGlobalGroupMask + 2) + 10 - 4;
	//	}
	//	if (!PerfGlobalGroupMask)
	//	{
	//		PerfGlobalGroupMask = FindPatternRange(ImpGetFunAddr(KeReleaseSpinLock), 0x30, E("0F BA"));
	//		if (PerfGlobalGroupMask)
	//			PerfGlobalGroupMask = PerfGlobalGroupMask + *(INT*)(PerfGlobalGroupMask + 3) + 8 - 4;
	//	}
	//
	//	if (!PerfGlobalGroupMask)
	//	{
	//		__db();
	//		ImpCall(DbgPrintEx, 0, 0, E("PerfGlobalGroupMask Not Found!\n"));
	//		return FALSE;
	//	}
	//}

	if (!EtwpDebuggerData)
	{
		do
		{
			EtwpDebuggerData = FindPatternSect(NtBase, E(".data"), E("2c 08 04 38 0c"));
			if (EtwpDebuggerData)
				break;

			EtwpDebuggerData = FindPatternSect(NtBase, E(".rdata"), E("2c 08 04 38 0c"));
			if (EtwpDebuggerData)
				break;

			EtwpDebuggerData = FindPatternSect(NtBase, E(".text"), E("2c 08 04 38 0c"));
			if (EtwpDebuggerData)
				break;

			__db();
		} while (false);
		EtwpDebuggerData -= 2;
	}
	
	pv* EtwpDebuggerDataSilo = *(pv**)(EtwpDebuggerData + 0x10);
	CkclWmiLoggerContext = EtwpDebuggerDataSilo[2];

	if (GetWinVer() <= 7601 || GetWinVer() >= 22000)
	{
		GetCpuClock = ((u64)CkclWmiLoggerContext + 0x18);
	}
	else
	{
		GetCpuClock = ((u64)CkclWmiLoggerContext + 0x28);
	}


	if (!SystemCallEntryPage)
	{
		SystemCallEntryPage = PAGE_ALIGN(GetSyscallEntry());
	}

	return EtwpDebuggerData && SystemCallEntryPage;
}

pv EtwHook::GetSyscallEntry()
{
	PVOID SyscallEntry = (PVOID)__readmsr(IA32_LSTAR);

	ULONG SizeOfSection = 0;
	PVOID SectionBase = FindSection(EPtr(::NtBase), E("KVASCODE"), &SizeOfSection);
	if (!SectionBase)
		return SyscallEntry;

	// Is the value within this KVA shadow region? If not, we're done.
	if (!(SyscallEntry >= SectionBase && SyscallEntry < (PVOID)((uintptr_t)SectionBase + SizeOfSection)))
		return SyscallEntry;

	// This is KiSystemCall64Shadow.
	hde64s HDE;
	for (PCHAR KiSystemServiceUser = (PCHAR)SyscallEntry; /* */; KiSystemServiceUser += HDE.len)
	{
		// Disassemble every instruction till the first near jmp (E9).
		if (!hde64_disasm(KiSystemServiceUser, &HDE))
			break;

		if (HDE.opcode != OPCODE_JMP_NEAR)
			continue;

		// Ignore jmps within the KVA shadow region.
		PVOID PossibleSyscallEntry = (PVOID)((u64)KiSystemServiceUser + (int)HDE.len + (int)HDE.imm.imm32);
		if (PossibleSyscallEntry >= SectionBase && PossibleSyscallEntry < (PVOID)((uintptr_t)SectionBase + SizeOfSection))
			continue;

		// Found KiSystemServiceUser.
		SyscallEntry = PossibleSyscallEntry;
		break;
	}

	return SyscallEntry;
}

VOID EtwHook::WatchDogThread(PVOID Param) {

	while (!::EtwHook.StopWatchDog)
	{
		if (GetWinVer() <= 18363)
		{
			if (*(u64*)::EtwHook.GetCpuClock != (u64)HookInternalGetCpuClock)
			{
				__dbgdb();
				*(u64*)::EtwHook.GetCpuClock = (u64)HookInternalGetCpuClock;
			}
		}
		else
		{
			if (*(HalQueryCounterFn*)(::EtwHook.HalpStallCounter + 0x70) != HookHalQueryCounter)
			{
				__dbgdb();
				*(HalQueryCounterFn*)(::EtwHook.HalpStallCounter + 0x70) = HookHalQueryCounter;
			}
		}

		KSleep(50);
	}

	ImpCall(KeSetEvent, &::EtwHook.WatchDogEvent, IO_KEYBOARD_INCREMENT, FALSE);
	ImpCall(PsTerminateSystemThread, STATUS_SUCCESS);
}

NTSTATUS EtwHook::Init(SyscallHookFn SyscallHookRoutine, CustomInvokeCall CustomFilter, ULONG HkEvent)
{
	//Turn off etw to prevent other hook 
	ModifyTraceSettings(CKCL_STOP_TRACE);

	if (!InitOffset())
		return STATUS_NOT_SUPPORTED;

	NTSTATUS Status = ModifyTraceSettings(CKCL_UPDATE_TRACE, HkEvent );
	if (Status != 0)
	{
		Status = ModifyTraceSettings(CKCL_START_TRACE);
		if (Status != 0) {
			return Status;
		}

		Status = ModifyTraceSettings(CKCL_UPDATE_TRACE, HkEvent);
		if (Status != 0) {
			return Status;
		}
	}

	//need to re-get cpuclock due to close and open etw
	if (!InitOffset())
		return STATUS_NOT_SUPPORTED;

	HkSyscall = SyscallHookRoutine;

	CustomFilterRoutine = CustomFilter;

	OldGetCpuClock = *(u64*)GetCpuClock;

	if (GetWinVer() <= 18363)
	{		
		*(u64*)GetCpuClock = (u64)HookInternalGetCpuClock;
	}
	else 
	{
		if (!HalpStallCounter)
		{
			pv KeQueryPerformanceCounter = GetProcAddress(this->NtBase, E("KeQueryPerformanceCounter"));
			if (!KeQueryPerformanceCounter)
				__db();

			// mov rdi, cs:HalpPerformanceCounter 
			auto rva = FindPatternRange(KeQueryPerformanceCounter, 0x100, E("48 8B 3D"));

			// mov rsi, cs:HalpPerformanceCounter win11
			if (!rva)
				rva = FindPatternRange(KeQueryPerformanceCounter, 0x100, E("48 8B 35"));

			//u poi(poi(nt!HalpStallCounter) + 70)
			HalpStallCounter = *(u64*)RVA2(rva, 7, 3);
		}

		if (!OldHalQueryCounter)
			OldHalQueryCounter = *(HalQueryCounterFn*)(HalpStallCounter + 0x70);
				
		*(u64*)GetCpuClock = 1;
		*(HalQueryCounterFn*)(HalpStallCounter + 0x70) = HookHalQueryCounter;
	}

	bIsInit = true;

	ImpCall(KeInitializeEvent, &WatchDogEvent, NotificationEvent, FALSE);
	HANDLE hSysThread = NULL;
	ImpCall(PsCreateSystemThread, &hSysThread, THREAD_ALL_ACCESS, NULL, NULL, NULL, WatchDogThread, NULL);
	if (hSysThread)
		ImpCall(ZwClose, hSysThread);

	return STATUS_SUCCESS;
}

NTSTATUS EtwHook::UnInit()
{
	if (!bIsInit)
		return 0;

	::EtwHook.StopWatchDog = true;
	ImpCall(KeWaitForSingleObject, &WatchDogEvent, Executive, KernelMode, FALSE, NULL);

	if (GetCpuClock)
		*(u64*)GetCpuClock = OldGetCpuClock;

	if (OldHalQueryCounter && HalpStallCounter) 
		*(u64*)(HalpStallCounter + 0x70) = (u64)OldHalQueryCounter;
	
	if (NT_SUCCESS(ModifyTraceSettings(CKCL_STOP_TRACE)))
	{
		ModifyTraceSettings(CKCL_START_TRACE);
	}

	bIsInit = false;

	//wait for syscall hook routine
	KSleep(100);
	return STATUS_SUCCESS;
}

#include "EtwHide.h"

void EtwHook::InvokeSysCall()
{
	if (ImpCall(KeGetCurrentIrql) > 0 || ImpCall(ExGetPreviousMode) == KernelMode)
		return;

	//increase speed
	if (!EtwHide.bIsInit || EtwHide.m_HiderProcess == ImpCall(IoGetCurrentProcess))
	{
		return;
	}


	auto CurrentThread = __readgsqword(0x188);
	u32 SystemCallIndex = *(u32*)(CurrentThread + 0x80);

	auto StackMax = __readgsqword(0x1A8);
	PVOID* StackFrame = (PVOID*)_AddressOfReturnAddress();
	UINT Offset = 0;
	// First walk backwards on the stack to find the 2 magic values.
	for (pv* StackCurrent = (pv*)StackMax; StackCurrent > StackFrame; --StackCurrent)
	{
		PULONG AsUlong = (PULONG)StackCurrent;
		if (*AsUlong != INFINITYHOOK_MAGIC_1)
		{
			continue;
		}
		// If the first magic is set, check for the second magic.
		--StackCurrent;

		PUSHORT AsShort = (PUSHORT)StackCurrent;
		if (*AsShort != INFINITYHOOK_MAGIC_2)
		{
			continue;
		}

		// Now we reverse the direction of the stack walk.
		for (;
			(u64)StackCurrent < StackMax;
			++StackCurrent)
		{
			PULONGLONG AsUlonglong = (PULONGLONG)StackCurrent;
			if (!(PAGE_ALIGN(*AsUlonglong) >= SystemCallEntryPage &&
				PAGE_ALIGN(*AsUlonglong) < (PVOID)((uintptr_t)SystemCallEntryPage + (PAGE_SIZE * 2))))
			{
				continue;
			}
			Offset = (u64)StackCurrent - (u64)StackFrame;

			break;
		}

		break;
	}
	
	if (Offset) {
		PVOID* StackCurrent = (pv*)((u64)StackFrame + Offset);
		if (*(u64*)StackCurrent >= (u64)SystemCallEntryPage &&
			*(u64*)StackCurrent < ((u64)SystemCallEntryPage + (PAGE_SIZE * 2)))
		{
			void** SystemCallFunction = &StackCurrent[9];
			if (HkSyscall)
			{
				HkSyscall(SystemCallIndex, SystemCallFunction);
			}
			else
			{
				DefaultSyscallHandler(SystemCallIndex, SystemCallFunction);
			}
		}
	}
}

void EtwHook::DefaultSyscallHandler(u32 SystemCallIndex, PVOID* SystemCallFunction)
{
	__dbgdb();
	return;
}

class EtwHook EtwHook;


```

`EtwHook.h`:

```h
#pragma once
#include <evntrace.h>

typedef enum CKCL_TRACE_OPERATION
{
	CKCL_START_TRACE = 1,
	CKCL_STOP_TRACE = 2,
	CKCL_QUERY_TRACE = 3,
	CKCL_UPDATE_TRACE = 4,
	CKCL_FLUSH_TRACE = 5
}CKCL_TRACE_OPERATION;

using CustomInvokeCall = void(*)();

class EtwHook
{
	using SyscallHookFn = void(*)(u32 SystemCallIndex, _Inout_ PVOID* SystemCallFunction);

private:
	//u8* PerfGlobalGroupMask = 0;
	u8* EtwpDebuggerData = 0;
	pv CkclWmiLoggerContext = 0;
	pv SystemCallEntryPage = 0;
	pv NtBase = 0;

	//HalpPerformanceCounter
	u64 HalpStallCounter = 0;

	u64 GetCpuClock = 0;
	u64 OldGetCpuClock = 0;
	SyscallHookFn HkSyscall = 0;
	CustomInvokeCall CustomFilterRoutine = 0;
	bool bIsInit = false;
	u64 StopWatchDog = false;
	KEVENT WatchDogEvent;

	static ULONG64 HookInternalGetCpuClock();

	static ULONG64 HookHalQueryCounter();

	bool InitOffset();
	
	static VOID WatchDogThread(PVOID Param);

public:

	static NTSTATUS ModifyTraceSettings(CKCL_TRACE_OPERATION Operation, ULONG TraceWhat = EVENT_TRACE_FLAG_SYSTEMCALL);
	
	static pv GetSyscallEntry();

	NTSTATUS Init(SyscallHookFn SyscallHookRoutine = 0, CustomInvokeCall CustomFilter = 0, ULONG HkEvent = EVENT_TRACE_FLAG_SYSTEMCALL);

	NTSTATUS UnInit();

	void InvokeSysCall();

	void DefaultSyscallHandler(u32 SystemCallIndex, PVOID* SystemCallFunction);
};

extern class EtwHook EtwHook;

```

`HookSwapContext.cpp`:

```cpp
#include "global.h"
#include "EtwHook.h"

#include "HookSwapContext.h"

void HkSwapContext()
{
	__db();
	//DbgPrintEx(0, 0, "Cur ThId %llx\n", PsGetCurrentThreadId());
	return;
}


void Workkk()
{
	// it is getcpuclock, safe for debugging.
	//if (GetWinVer() <= 18363)
	//	__db();


	auto CurrentThread = __readgsqword(0x188);
	auto StackMax = __readgsqword(0x1A8);
	PVOID* StackFrame = (PVOID*)_AddressOfReturnAddress();

	if ((u64)StackMax - (u64)StackFrame > 0x6000 || (u64)StackFrame > StackMax)
	{
		__db();
		return;
	}

	int FoundFlag = 0;
	for (pv* StackCurrent = (pv*)StackFrame; (u64)StackCurrent < StackMax; StackCurrent++)
	{
		if (FoundFlag == 0)
		{
			if (*(u32*)StackCurrent == 0x28)			
				FoundFlag++;
			continue;
		}

		if (FoundFlag == 1)
		{
			if (*(u32*)StackCurrent == 0x405A04)
			{
				HkSwapContext();
				break;
			}
		}
	}
}



void HookSwapContext()
{
	EtwHook.Init(0, Workkk, EVENT_TRACE_FLAG_CSWITCH);
}


```

`HookSwapContext.h`:

```h
#pragma once

void HookSwapContext();

```

`README.md`:

```md
# HookSwapContext

2小时写出来的代码，win10 测试通过

```

`global.cpp`:

```cpp
#include "global.h"


```

`global.h`:

```h
#pragma once

#include <ntifs.h>
#include <ntddk.h>
#include <ntimage.h>
#include <ntstrsafe.h>
#include <intrin.h>
#include <windef.h>
#include <stdint.h>
#pragma comment(lib,"Ksecdd.lib")

#include "DriverConfig.h"

#include "random.h"
#include "Crt.h"
#include "Define.h"
#include "Crypt.h"
#include "Import.h"

//eptred var
extern PVOID NtBase;
extern PDRIVER_OBJECT g_DriverObject;
extern "C" int _fltused;
extern std::_Prhand std::_Raise_handler;
void atexit();

#include "util.h"



//#define OPT_OFF #pragma optimize("", off)
//#define OPT_ON #pragma optimize("", on)



```

`util.cpp`:

```cpp
#include "global.h"
#include "PhysicalMemory.h"
#include "DispatchFunctions.h"
#include "util.h"

volatile u64 LastAllocation = 0;
volatile u64 LastAllocationAddress = 0;

NTSTATUS getKernelModuleByName(const char* moduleName, PVOID* moduleStart, size_t* moduleSize)
{
	if (!moduleStart)
		return STATUS_INVALID_PARAMETER;

	const auto listHeader = NQSI(SystemModuleInformation);
	if (!listHeader)
		return STATUS_MEMORY_NOT_ALLOCATED;

	auto currentModule = reinterpret_cast<PSYSTEM_MODULE_INFORMATION>(listHeader)->Module;
	for (size_t i = 0; i < reinterpret_cast<PSYSTEM_MODULE_INFORMATION>(listHeader)->Count; ++i, ++currentModule)
	{
		// \SystemRoot\system32\ntoskrnl.exe -> ntoskrnl.exe 
		const auto currentModuleName = reinterpret_cast<const char*>(currentModule->FullPathName + currentModule->OffsetToFileName);
		if (!strcmp(moduleName, currentModuleName))
		{
			*moduleStart = currentModule->ImageBase;
			if (moduleSize)
				*moduleSize = currentModule->ImageSize;
			KFree(listHeader);
			return STATUS_SUCCESS;
		}
	}
	KFree(listHeader);
	return STATUS_NOT_FOUND;
}

NTSTATUS GetProcessIdByProcessName(const wchar_t* ImageName, OUT HANDLE* OutPid )
{
	PSYSTEM_PROCESS_INFO pInfo = 0;
	PSYSTEM_PROCESS_INFO Buffer = 0;
	NTSTATUS Status = STATUS_UNSUCCESSFUL;
		
	Buffer = (PSYSTEM_PROCESS_INFO)NQSI(SystemProcessInformation);
	if (!Buffer) 
		return STATUS_UNSUCCESSFUL;

	pInfo = Buffer;

	Status = STATUS_UNSUCCESSFUL;
	for (;;)
	{
		if (pInfo->ImageName.Buffer && StrICmp(ImageName, pInfo->ImageName.Buffer, TRUE))
		{
			//__db();
			*OutPid = pInfo->UniqueProcessId;
			Status = 0;
			break;
		}
		else if (pInfo->NextEntryOffset)
			pInfo = (PSYSTEM_PROCESS_INFO)((PUCHAR)pInfo + pInfo->NextEntryOffset);
		else
			break;
	}

	KFree(Buffer);

	return Status;
}

#define IMAGE_FIRST_SECTION(NtHeader) (PIMAGE_SECTION_HEADER)(NtHeader + 1)
#define NT_HEADER(ModBase) (PIMAGE_NT_HEADERS)((ULONG64)(ModBase) + ((PIMAGE_DOS_HEADER)(ModBase))->e_lfanew)

PVOID FindSection(PVOID ModBase, const char* Name, PULONG SectSize)
{
	//get & enum sections
	PIMAGE_NT_HEADERS NT_Header = NT_HEADER(ModBase);
	PIMAGE_SECTION_HEADER Sect = IMAGE_FIRST_SECTION(NT_Header);

	for (PIMAGE_SECTION_HEADER pSect = Sect; pSect < Sect + NT_Header->FileHeader.NumberOfSections; pSect++)
	{
		//copy section name
		char SectName[9]; SectName[8] = 0;
		*(ULONG64*)&SectName[0] = *(ULONG64*)&pSect->Name[0];

		//check name
		if (StrICmp(Name, SectName, true))
		{
			//save size
			if (SectSize) {
				ULONG SSize = SizeAlign(max(pSect->Misc.VirtualSize, pSect->SizeOfRawData));
				*SectSize = SSize;
			}

			//ret full sect ptr
			return (PVOID)((ULONG64)ModBase + pSect->VirtualAddress);
		}
	}

	//no section
	return nullptr;
}

bool readByte(PVOID addr, UCHAR* ret)
{
	*ret = *(volatile char*)addr;
	return true;
}

//find pattern utils
#define InRange(x, a, b) (x >= a && x <= b) 
#define GetBits(x) (InRange(x, '0', '9') ? (x - '0') : (InRange(x, 'a', 'z') ? ((x - 'a') + 0xA) : ((x - 'A') + 0xA)) )
#define GetByte(x) ((UCHAR)(GetBits(x[0]) << 4 | GetBits(x[1])))

PUCHAR FindPatternSect(PVOID ModBase, const char* SectName, const char* Pattern)
{
	if (!ModBase) return nullptr;

//get sect range
	ULONG SectSize;
	PUCHAR ModuleStart = (PUCHAR)FindSection(ModBase, SectName, &SectSize);
	PUCHAR ModuleEnd = ModuleStart + SectSize;

	if (!ModuleStart) return nullptr;

	//scan pattern main
	PUCHAR FirstMatch = nullptr;
	const char* CurPatt = Pattern;
	if (*Pattern == '\0')
		CurPatt++;

	for (; ModuleStart < ModuleEnd; ++ModuleStart)
	{
		bool SkipByte = (*CurPatt == '\?');

		//hp(ModuleStart);
		UCHAR byte1;
		if (!readByte(ModuleStart, &byte1)) {
			auto addr2 = (u64)ModuleStart;
			addr2 &= 0xFFFFFFFFFFFFF000;
			addr2 += 0xFFF;
			ModuleStart = (PUCHAR)addr2;
			//sp("123");
			goto Skip;
		}

		if (SkipByte || byte1 == GetByte(CurPatt)) {
			if (!FirstMatch) FirstMatch = ModuleStart;
			if (SkipByte)
				CurPatt += 2;
			else
				CurPatt += 3;
			if (CurPatt[-1] == 0) return FirstMatch;
		}

		else if (FirstMatch) {
			ModuleStart = FirstMatch;
		Skip:
			FirstMatch = nullptr;
			CurPatt = Pattern;
		}
	}

	//failed
	return nullptr;
}

PUCHAR FindPatternRange(PVOID Start, u32 size, const char* Pattern)
{
	//get sect range
	PUCHAR ModuleStart = (PUCHAR)Start;
	PUCHAR ModuleEnd = ModuleStart + size;

	//scan pattern main
	PUCHAR FirstMatch = nullptr;
	const char* CurPatt = Pattern;
	if (*Pattern == '\0')
		CurPatt++;

	for (; ModuleStart < ModuleEnd; ++ModuleStart)
	{
		bool SkipByte = (*CurPatt == '\?');

		//hp(ModuleStart);
		UCHAR byte1;
		if (!readByte(ModuleStart, &byte1)) {
			auto addr2 = (u64)ModuleStart;
			addr2 &= 0xFFFFFFFFFFFFF000;
			addr2 += 0xFFF;
			ModuleStart = (PUCHAR)addr2;
			//sp("123");
			goto Skip;
		}

		if (SkipByte || byte1 == GetByte(CurPatt)) {
			if (!FirstMatch) FirstMatch = ModuleStart;
			SkipByte ? CurPatt += 2 : CurPatt += 3;
			if (CurPatt[-1] == 0) return FirstMatch;
		}

		else if (FirstMatch) {
			ModuleStart = FirstMatch;
		Skip:
			FirstMatch = nullptr;
			CurPatt = Pattern;
		}
	}

	//failed
	return nullptr;
}

PETHREAD LookupProcessThread(IN PEPROCESS pProcess)
{
	if (!pProcess)
		return 0;

	NTSTATUS status = STATUS_SUCCESS;
	PETHREAD thr = 0;
	HANDLE pid = ImpCall(PsGetProcessId, pProcess);
	auto Buf = NQSI(SystemProcessInformation);
	PSYSTEM_PROCESS_INFO pInfo = (PSYSTEM_PROCESS_INFO)Buf;

	// Find target thread	
	status = STATUS_NOT_FOUND;
	for (;;)
	{
		if (pInfo->UniqueProcessId == pid)
		{
			status = STATUS_SUCCESS;
			break;
		}
		else if (pInfo->NextEntryOffset)
			pInfo = (PSYSTEM_PROCESS_INFO)((PUCHAR)pInfo + pInfo->NextEntryOffset);
		else
			break;
	}

	status = STATUS_NOT_FOUND;

	// Get first thread
	for (ULONG i = 0; i < pInfo->NumberOfThreads; i++)
	{
		// Skip current thread
		if (/*pInfo->Threads[i].WaitReason == Suspended ||
			pInfo->Threads[i].ThreadState == 5 ||*/
			pInfo->Threads[i].ClientId.UniqueThread == ImpCall(PsGetCurrentThreadId))
		{
			continue;
		}

		status = ImpCall(PsLookupThreadByThreadId, pInfo->Threads[i].ClientId.UniqueThread, &thr);

		break;
	}

	KFree(Buf);

	return thr;

}


//NTSTATUS CopyPhysics(void* Dst, const void* PhySics, size_t _MaxCount)
//{
//	MM_COPY_ADDRESS copyaddr;
//	copyaddr.PhysicalAddress.QuadPart = (LONGLONG)PhySics;
//	SIZE_T copyed = 0;
//	return MmCopyMemory(Dst, copyaddr, _MaxCount, MM_COPY_MEMORY_PHYSICAL, &copyed);
//}


//void Log2File(const char* format, ...)
//{	
//	char msg[1024] = "";
//	va_list vl;
//	va_start(vl, format);
//	const int n = _vsnprintf(msg, sizeof(msg) / sizeof(char), format, vl);
//	msg[n] = '\0';
//	va_end(vl);
//	va_end(format);
//	UNICODE_STRING FileName;
//	OBJECT_ATTRIBUTES objAttr;
//	RtlInitUnicodeString(&FileName, L"\\DosDevices\\C:\\PPEngine.log");
//	InitializeObjectAttributes(&objAttr, &FileName,
//		OBJ_CASE_INSENSITIVE | OBJ_KERNEL_HANDLE,
//		NULL, NULL);
//	if (KeGetCurrentIrql() != PASSIVE_LEVEL)
//	{
//		return;
//	}
//	HANDLE handle;
//	IO_STATUS_BLOCK ioStatusBlock;
//	NTSTATUS ntstatus = ZwCreateFile(&handle,
//		FILE_APPEND_DATA,
//		&objAttr, &ioStatusBlock, NULL,
//		FILE_ATTRIBUTE_NORMAL,
//		FILE_SHARE_WRITE | FILE_SHARE_READ,
//		FILE_OPEN_IF,
//		FILE_SYNCHRONOUS_IO_NONALERT,
//		NULL, 0);
//	if (NT_SUCCESS(ntstatus))
//	{
//		size_t cb;
//		ntstatus = RtlStringCbLengthA(msg, sizeof(msg), &cb);
//		if (NT_SUCCESS(ntstatus))
//			ZwWriteFile(handle, NULL, NULL, NULL, &ioStatusBlock, msg, (ULONG)cb, NULL, NULL);
//		ZwClose(handle);
//	}
//}

ULONG g_dwBuildNumber = 0;
ULONG GetWinVer() 
{
	if (!g_dwBuildNumber)
	{
		ImpCall(PsGetVersion, 0, 0, &g_dwBuildNumber, 0);
	}	
	return g_dwBuildNumber;
}

typedef struct _SYSTEM_KERNEL_DEBUGGER_INFORMATION
{
	BOOLEAN DebuggerEnabled;
	BOOLEAN DebuggerNotPresent;
} SYSTEM_KERNEL_DEBUGGER_INFORMATION, * PSYSTEM_KERNEL_DEBUGGER_INFORMATION;

BOOLEAN IsKernelDebuggerPresent()
{
	SYSTEM_KERNEL_DEBUGGER_INFORMATION DebuggerInfo;
	ULONG RetLen = 0;
	ImpCall(ZwQuerySystemInformation, SystemKernelDebuggerInformation, &DebuggerInfo, 8, &RetLen);

	return !DebuggerInfo.DebuggerNotPresent;
}

PVOID GetCurrentProcessModule(const char* ModName, ULONG* ModSize, bool force64)
{
	auto Process = ImpCall(IoGetCurrentProcess);

	PPEB32 pPeb32 = (PPEB32)ImpCall(PsGetProcessWow64Process,Process);

	if (pPeb32 && !force64)
	{
		if (!pPeb32->Ldr)
			return nullptr;

		for (PLIST_ENTRY32 pListEntry = (PLIST_ENTRY32)((PPEB_LDR_DATA32)pPeb32->Ldr)->InLoadOrderModuleList.Flink;
			pListEntry != &((PPEB_LDR_DATA32)pPeb32->Ldr)->InLoadOrderModuleList;
			pListEntry = (PLIST_ENTRY32)pListEntry->Flink)
		{
			PLDR_DATA_TABLE_ENTRY32 pEntry = CONTAINING_RECORD(pListEntry, LDR_DATA_TABLE_ENTRY32, InLoadOrderLinks);

			if (StrICmp(ModName, (PWCH)pEntry->BaseDllName.Buffer, false))
			{
				if (ModSize)
				{
					*ModSize = pEntry->SizeOfImage;
				}

				return (PVOID)pEntry->DllBase;
			}
		}
	}
	else
	{
		PPEB64 PEB = ImpCall(PsGetProcessPeb, Process);
		if (!PEB || !PEB->Ldr)
			return nullptr;

		for (PLIST_ENTRY pListEntry = (PLIST_ENTRY)((PPEB_LDR_DATA64)(PEB->Ldr))->InLoadOrderModuleList.Flink;
			pListEntry != (PLIST_ENTRY)&((PPEB_LDR_DATA64)(PEB->Ldr))->InLoadOrderModuleList;
			pListEntry = pListEntry->Flink)
		{
			PLDR_DATA_TABLE_ENTRY64 pEntry = CONTAINING_RECORD(pListEntry, LDR_DATA_TABLE_ENTRY64, InLoadOrderLinks);

			if (StrICmp(ModName, pEntry->BaseDllName.Buffer, false))
			{
				if (ModSize)
				{
					*ModSize = pEntry->SizeOfImage;
				}

				return (PVOID)pEntry->DllBase;
			}
		}
	}

	return nullptr;
}

PVOID NQSI(SYSTEM_INFORMATION_CLASS Class)
{
	ULONG ret_size = 0;
	ImpCall(ZwQuerySystemInformation, Class, 0, 0, &ret_size);

	NTSTATUS status = 0;
	PVOID pInfo = 0;
	do
	{
		if (pInfo) KFree(pInfo);

		pInfo = KAlloc(ret_size);
		status = ImpCall(ZwQuerySystemInformation, Class, pInfo, ret_size, &ret_size);
	} while (status == STATUS_BUFFER_TOO_SMALL);

	return pInfo;
}




PVOID GetUserProcessModule(DWORD pid, const wchar_t* ModName)
{
	OperationData op;
	op.Module.ModName = ModName;// L"user32.dll";
	op.Process.Id = pid;
	auto status = Dispatch::GetModuleBase(&op);
	if (status)
		return 0;

	return op.Module.BaseAddress;
}

PEPROCESS GetUserProcessModule(const wchar_t* ProcessName, const wchar_t* ModName, __notnull pv* OutModBase)
{
	HANDLE Pid = 0;
	GetProcessIdByProcessName(ProcessName, &Pid);
	if (!Pid)
		return 0;

	OperationData op;
	op.Module.ModName = ModName;// L"user32.dll";
	op.Process.Id = (DWORD)Pid;
	auto status = Dispatch::GetModuleBase(&op);
	if (status)
		return 0;

	*OutModBase = op.Module.BaseAddress;

	PEPROCESS TargetProcess = 0;
	if (ImpCall(PsLookupProcessByProcessId, Pid, &TargetProcess))
		return 0;

	ImpCall(ObfDereferenceObject, TargetProcess);

	return TargetProcess;
}

NTSTATUS NTQM(PVOID UAddr, PMEMORY_BASIC_INFORMATION mbi)
{
	if (!mbi)
		return STATUS_INVALID_PARAMETER;

	NTSTATUS status = 0;

	//if (ImpCall(ExGetPreviousMode) == UserMode)
	//{
	//	PMEMORY_BASIC_INFORMATION UserMbi = (PMEMORY_BASIC_INFORMATION)UAlloc(0x1000);
	//	status = ImpCall(ZwQueryVirtualMemory, (HANDLE)-1, (pv)((u64)UAddr & ~0xFFF), MemoryBasicInformation,
	//		UserMbi, sizeof(MEMORY_BASIC_INFORMATION), 0);
	//
	//	*mbi = *UserMbi;
	//
	//	UFree(UserMbi);
	//}
	//else
	{
		status = ImpCall(ZwQueryVirtualMemory, (HANDLE)-1, (pv)((u64)UAddr & ~0xFFF), MemoryBasicInformation,
			mbi, sizeof(MEMORY_BASIC_INFORMATION), 0);
	}

	if (status != 0)
		memset(mbi, 0, sizeof(*mbi));

	return status;
}

NTSTATUS ReadFile(IN const wchar_t* FileName, OUT char** DataFreeByCaller, OUT SIZE_T* DataSize)
{
	HANDLE hFile = NULL;
	IO_STATUS_BLOCK sb = { 0 };
	NTSTATUS status = 0;
	LARGE_INTEGER Offset = { 0 };
	OBJECT_ATTRIBUTES object_attr = { 0 };
	//ANSI_STRING anFilePath = { 0 };
	UNICODE_STRING unFilePathName = { 0 };
	FILE_STANDARD_INFORMATION fsi = { 0 };
	LARGE_INTEGER Size = { 0 };

	ImpCall(RtlInitUnicodeString, &unFilePathName, FileName);
	//status = RtlAnsiStringToUnicodeString(&unFilePathName, &anFilePath, TRUE);
	//if (!NT_SUCCESS(status))
	//{
	//	return status;
	//}

	InitializeObjectAttributes(&object_attr, &unFilePathName, OBJ_CASE_INSENSITIVE, NULL, NULL);
	status = ImpCall(ZwCreateFile, &hFile, GENERIC_READ, &object_attr, &sb, NULL, FILE_ATTRIBUTE_NORMAL, FILE_SHARE_READ,
		FILE_OPEN, FILE_SYNCHRONOUS_IO_NONALERT | FILE_NON_DIRECTORY_FILE, NULL, 0);
	if (!NT_SUCCESS(status))
	{
		return status;
	}

	// 获取文件大小
	memset(&sb, 0, sizeof(sb));
	status = ImpCall(ZwQueryInformationFile, hFile, &sb, &fsi, sizeof(FILE_STANDARD_INFORMATION), FileStandardInformation);
	if (!NT_SUCCESS(status))
	{
		ImpCall(ZwClose, hFile);
		return status;
	}
	Size.QuadPart = fsi.EndOfFile.QuadPart;

	// 申请内存
	*DataFreeByCaller = (CHAR*)KAlloc(Size.QuadPart);
	if (*DataFreeByCaller == NULL)
	{
		ImpCall(ZwClose, hFile);
		return STATUS_INSUFFICIENT_RESOURCES;
	}

	// 读文件
	status = ImpCall(ZwReadFile, hFile, NULL, NULL, NULL, &sb, (PVOID)*DataFreeByCaller, (ULONG)Size.QuadPart, &Offset, NULL);
	if (!NT_SUCCESS(status))
	{
		KFree(*DataFreeByCaller);
		*DataFreeByCaller = 0;
		return status;
	}

	if (DataSize)
		*DataSize = Size.QuadPart;
	return ImpCall(ZwClose, hFile);
}

bool DeleteFile(PUNICODE_STRING Path)
{

	HANDLE hFile = NULL;
	OBJECT_ATTRIBUTES obj = { 0 };
	IO_STATUS_BLOCK IoStatck = { 0 };
	InitializeObjectAttributes(&obj, Path, OBJ_KERNEL_HANDLE | OBJ_CASE_INSENSITIVE, NULL, NULL);

	NTSTATUS NtStatus = ImpCall(ZwCreateFile, &hFile, FILE_READ_ACCESS, &obj, &IoStatck, NULL,
		FILE_ATTRIBUTE_NORMAL, FILE_SHARE_READ, FILE_OPEN, FILE_NON_DIRECTORY_FILE, NULL, NULL);
	if (!NT_SUCCESS(NtStatus))
		return FALSE;

	PFILE_OBJECT FileObject = NULL;
	NtStatus = ImpCall(ObReferenceObjectByHandle, hFile, FILE_ALL_ACCESS, *ImpGetVar(IoFileObjectType), KernelMode, (PVOID*)&FileObject, NULL);
	if (!NT_SUCCESS(NtStatus))
	{
		ImpCall(ZwClose, hFile);
		return FALSE;
	}
	ImpCall(ZwClose, hFile);

	FileObject->DeletePending = 0;
	FileObject->DeleteAccess = 1;
	FileObject->SharedDelete = 1;
	FileObject->SectionObjectPointer->DataSectionObject = NULL;
	FileObject->SectionObjectPointer->ImageSectionObject = NULL;
	FileObject->SectionObjectPointer->SharedCacheMap = NULL;
	NtStatus = ImpCall(ZwDeleteFile, &obj);
	ObDeref(FileObject);
	if (!NT_SUCCESS(NtStatus))
	{
		return FALSE;
	}
	return TRUE;
}

NTSTATUS WriteFile(PUNICODE_STRING filePath, PVOID data, ULONG length)
{
	NTSTATUS status;
	HANDLE fileHandle;
	OBJECT_ATTRIBUTES objAttr;
	IO_STATUS_BLOCK ioStatusBlock;

	// Initialize the object attributes to open the file
	InitializeObjectAttributes(&objAttr, filePath, OBJ_CASE_INSENSITIVE, NULL, NULL);

	// Open the file
	status = ZwCreateFile(&fileHandle, GENERIC_WRITE, &objAttr, &ioStatusBlock, NULL, FILE_ATTRIBUTE_NORMAL, 0, FILE_OVERWRITE_IF, FILE_SYNCHRONOUS_IO_NONALERT, NULL, 0);

	if (!NT_SUCCESS(status))
	{
		// File open failed
		return status;
	}

	// Write the data to the file
	status = ZwWriteFile(fileHandle, NULL, NULL, NULL, &ioStatusBlock, data, length, NULL, NULL);

	if (!NT_SUCCESS(status))
	{
		// Write operation failed
		ZwClose(fileHandle);
		return status;
	}

	// Close the file handle
	ZwClose(fileHandle);

	return STATUS_SUCCESS;
}

bool IsValidFileObject(PFILE_OBJECT FileObject)
{
	if (!IsValid(FileObject))
		return false;

	if (FileObject->Type != 5)
		return false;

	return true;
}

//Data free by caller, ret = C:\Users\Pipi\Desktop\1.exe 
POBJECT_NAME_INFORMATION GetFileNameInfo(PFILE_OBJECT FileObject)
{
	if (!IsValidFileObject(FileObject))
		return 0;

	POBJECT_NAME_INFORMATION ObjectNameInformation = 0;

	ImpCall(IoQueryFileDosDeviceName, FileObject, &ObjectNameInformation);

	if (ObjectNameInformation)
		*(PWCH)((u64)ObjectNameInformation->Name.Buffer + ObjectNameInformation->Name.Length) = L'\0';

	return ObjectNameInformation;
}

typedef NTSTATUS (NTAPI* _PsSuspendThread)(IN PETHREAD Thread, OUT PULONG PreviousSuspendCount OPTIONAL);
_PsSuspendThread PsSuspendThread = 0;

typedef u64 (__fastcall* _KeResumeThread)(IN PETHREAD Thread, IN ULONG One);
_KeResumeThread KeResumeThread = 0;

void InitSuspendResumeThread()
{
	auto rva =
		FindPatternSect(EPtr(::NtBase), E("PAGE"), E("F7 ? 74 00 00 20 00 75 ? 33 D2 48 8B ? E8"));
	PsSuspendThread = (_PsSuspendThread)RVA(rva + 14, 5);

	auto rva2 =
		FindPatternSect(EPtr(::NtBase), E("PAGE"), E("F7 ? 74 00 00 20 00 75 ? 48 8B ? E8"));
	if (rva2)
	{
		KeResumeThread = (_KeResumeThread)RVA(rva2 + 12, 5);
	}
	else
	{
		rva2 = FindPatternSect(EPtr(::NtBase), E(".text"), E("F7 ? 74 00 00 20 00 75 ? BA 01 00 00 00 48 8B ? E8"));
		if (!rva2)
			__db();
		KeResumeThread = (_KeResumeThread)RVA(rva2 + 17, 5);
	}
}

NTSTATUS SuspendThread(PETHREAD Thread)
{
	if (!Thread)
		return STATUS_NOT_FOUND;
	
	if (!PsSuspendThread || !KeResumeThread)
	{
		InitSuspendResumeThread();
	}

	if (!PsSuspendThread)
		return STATUS_PROCEDURE_NOT_FOUND;

	return PsSuspendThread(Thread, 0);
}

NTSTATUS ResumeThread(PETHREAD Thread)
{
	if (!Thread)
		return STATUS_NOT_FOUND;

	if (!PsSuspendThread || !KeResumeThread)
	{
		InitSuspendResumeThread();
	}

	if (!KeResumeThread)
		return STATUS_PROCEDURE_NOT_FOUND;

	KeResumeThread(Thread, 1);

	return 0;
}




```

`util.h`:

```h
#pragma once

NTSTATUS getKernelModuleByName(const char* moduleName, PVOID* moduleStart, size_t* moduleSize = 0);

NTSTATUS GetProcessIdByProcessName(const wchar_t* ImageName, OUT HANDLE* OutPid);

PVOID FindSection(PVOID ModBase, const char* Name, PULONG SectSize);

PUCHAR FindPatternSect(PVOID ModBase, const char* SectName, const char* Pattern);

PUCHAR FindPatternRange(PVOID Start, u32 size, const char* Pattern);

PETHREAD LookupProcessThread(IN PEPROCESS pProcess);

//NTSTATUS RtlSuperCopyMemory(IN VOID* Dst, IN CONST VOID* Src, IN ULONG Length);

//NTSTATUS RtlSuperWriteMemoryPipi(IN VOID* Dst, IN CONST VOID* Src, IN ULONG Length);

void Log2File(const char* format, ...);

//dwBuildNumber
ULONG GetWinVer();

BOOLEAN IsKernelDebuggerPresent();

PVOID GetProcAddress(PVOID ModBase, const char* Name);

PVOID GetCurrentProcessModule(const char* ModName, ULONG* ModSize = 0, bool force64 = 1);

PVOID NQSI(SYSTEM_INFORMATION_CLASS Class);

PVOID GetUserProcessModule(DWORD pid, const wchar_t* ModName);

PEPROCESS GetUserProcessModule(const wchar_t* ProcessName, const wchar_t* ModName, __notnull pv* OutModBase);

PEPROCESS GetEpro(HANDLE pid);

inl BOOLEAN IsProcessExit(PEPROCESS epro);

NTSTATUS ReadFile(IN const wchar_t* FileName, OUT char** DataFreeByCaller, OUT SIZE_T* DataSize);

bool DeleteFile(PUNICODE_STRING Path);

NTSTATUS WriteFile(PUNICODE_STRING filePath, PVOID data, ULONG length);

bool IsValidFileObject(PFILE_OBJECT FileObject);

POBJECT_NAME_INFORMATION GetFileNameInfo(PFILE_OBJECT FileObject);

#define LOCK(Lock) while (_InterlockedCompareExchange64(&Lock, 1, 0) == 1){;}

#define UNLOCK(Lock) (InterlockedExchange64(&Lock, 0))

#define SizeAlign(Size) ((Size + 0xFFF) & 0xFFFFFFFFFFFFF000)

inl void MemZero(PVOID Ptr, SIZE_T Size, UCHAR Filling = 0)
{
	__stosb((PUCHAR)Ptr, Filling, Size);
}

inl void MemCpy(PVOID Destination, PVOID Source, SIZE_T Count)
{
	__movsb((PUCHAR)Destination, (PUCHAR)Source, Count);
}

inl PVOID UAlloc(ULONG Size, ULONG Protect = PAGE_READWRITE, bool load = true)
{
	PVOID AllocBase = nullptr; SIZE_T SizeUL = SizeAlign(Size);	
#define LOCK_VM_IN_RAM 2
#define LOCK_VM_IN_WORKING_SET 1
	if (!ImpCall(ZwAllocateVirtualMemory, ZwCurrentProcess(), &AllocBase, 0, &SizeUL, MEM_COMMIT, Protect)) {
		//ZwLockVirtualMemory(ZwCurrentProcess(), &AllocBase, &SizeUL, LOCK_VM_IN_WORKING_SET | LOCK_VM_IN_RAM);
		if (load)
			MemZero(AllocBase, SizeUL);
	}
	return AllocBase;
}

inl DWORD UProtect(PVOID Address, ULONG Size, ULONG Protect)
{
	SIZE_T SizeUL = Size;
	u32 OldPro = 0;
	ImpCall(ZwProtectVirtualMemory, ZwCurrentProcess(), &Address, &SizeUL, Protect, &OldPro);
	return OldPro;
}

inl void UFree(PVOID Ptr)
{
	SIZE_T SizeUL = 0;
	ImpCall(ZwFreeVirtualMemory, ZwCurrentProcess(), &Ptr, &SizeUL, MEM_RELEASE);
}

//help to debug
extern volatile u64 LastAllocation;
extern volatile u64 LastAllocationAddress;


//kernel memory utils
inl PVOID KAlloc(u64 Size, bool exec = false, bool PagedPool = false)
{
	PVOID Buff = ImpCall(ExAllocatePoolWithTag,
		PagedPool ? POOL_TYPE::PagedPool : (exec ? NonPagedPool : NonPagedPoolNx),
		Size, GetRandomPoolTag());
	memset(Buff, 0, Size);

	LastAllocation = (u64)Buff;
	LastAllocationAddress = (u64)_ReturnAddress();
	return Buff;
}

inl void KFree(PVOID Ptr)
{
	if(Ptr)
		ImpCall(ExFreePoolWithTag, Ptr, 0);
}

inl PVOID GetModuleHandle(const char* ModName)
{
	return GetCurrentProcessModule(ModName);
}

inl KAPC_STATE KeStackAttach(PEPROCESS process)
{
	KAPC_STATE kapc;
	ImpCall(KeStackAttachProcess, process, &kapc);
	return kapc;
}

inl void KeStackDetach(KAPC_STATE* kapc)
{
	ImpCall(KeUnstackDetachProcess, kapc);
}

inl KPROCESSOR_MODE ExSetPreviousMode(KPROCESSOR_MODE NewMode, PETHREAD Thread = (PETHREAD)__readgsqword(0x188))
{
	auto ret = *(u8*)((u64)Thread + 0x232);
	*(u8*)((u64)Thread + 0x232) = NewMode;
	return ret;
}

inl KTRAP_FRAME* PsGetTrapFrame(PETHREAD Thread = (PETHREAD)__readgsqword(0x188))
{
	return *(KTRAP_FRAME**)((ULONG64)Thread + 0x90);
}

inl void PsSetTrapFrame(PETHREAD Thread, KTRAP_FRAME* tf)
{
	*(KTRAP_FRAME**)((ULONG64)Thread + 0x90) = tf;
}

inl PEPROCESS GetEpro(HANDLE pid)
{
	PEPROCESS epro = 0;
	ImpCall(PsLookupProcessByProcessId, pid, &epro);
	return epro;
}

inl BOOLEAN IsProcessExit(PEPROCESS epro)
{
	if (!epro)
	{
		__dbgdb();
		return TRUE;
	}

	return ImpCall(PsGetProcessExitStatus, epro) != STATUS_PENDING;
}

#define ObDeref ObfDeref

inl void ObfDeref(PVOID Obj)
{
	if(Obj)
		ImpCall(ObfDereferenceObject, Obj);
}

inl void KSleep(LONG milliseconds)
{
	LARGE_INTEGER interval;
	interval.QuadPart = -(10000 * milliseconds); // convert milliseconds to 100 nanosecond intervals
	ImpCall(KeDelayExecutionThread, KernelMode, FALSE, &interval);
}



template <class T>
inl bool IsCanonicalAddress(T address)
{
	u64 addr = *(u64*)&address;

	if (addr <= 0x1000)
		return false;

	if (
		((addr >= 0xFFFF800000000000) && (addr <= 0xFFFFFFFFFFFFFFFF)) ||
		((addr >= 0) && (addr <= 0x7FFFFFFFFFFF)) 		
		)
	{
		return true;
	}

	return false;
}

inl BOOLEAN IsValid(pv addr)
{
	if ((u64)addr <= 0x1000)
		return false;

	if (!IsCanonicalAddress(addr))
		return false;

	return ImpCall(MmIsAddressValid, addr);
}

inl BOOLEAN IsValid(u64 addr)
{
	if (addr < 0x1000)
		return false;
	return ImpCall(MmIsAddressValid, (pv)addr);
}

NTSTATUS NTQM(PVOID UAddr, PMEMORY_BASIC_INFORMATION mbi);

inl DECLSPEC_NORETURN VOID BugCheck(u32 Line)
{
	ImpCall(KeBugCheck, Line);
}

#define GetTickCount64 KeQueryInterruptTime

extern ULONG g_dwBuildNumber;


```