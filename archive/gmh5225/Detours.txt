Project Path: arc_gmh5225_Detours_oknkx4ba

Source Tree:

```txt
arc_gmh5225_Detours_oknkx4ba
├── CREDITS.md
├── LICENSE.md
├── Makefile
├── README.md
├── samples
│   ├── Makefile
│   ├── README.TXT
│   ├── comeasy
│   │   ├── Makefile
│   │   ├── comeasy.cpp
│   │   ├── wrotei.cpp
│   │   └── wrotei.rc
│   ├── commem
│   │   ├── Makefile
│   │   └── commem.cpp
│   ├── common.mak
│   ├── cping
│   │   ├── Makefile
│   │   ├── ReadMe.Txt
│   │   ├── cping.cpp
│   │   ├── cping.dat
│   │   └── iping.idl
│   ├── disas
│   │   ├── Makefile
│   │   ├── arm.asm
│   │   ├── disas.cpp
│   │   ├── ia64.asm
│   │   ├── unk.cpp
│   │   ├── x64.asm
│   │   └── x86.cpp
│   ├── dtest
│   │   ├── Makefile
│   │   ├── NORMAL_IA64.TXT
│   │   ├── NORMAL_X64.TXT
│   │   ├── NORMAL_X86.TXT
│   │   ├── dtarge.cpp
│   │   ├── dtarge.h
│   │   ├── dtarge.rc
│   │   └── dtest.cpp
│   ├── dumpe
│   │   ├── Makefile
│   │   └── dumpe.cpp
│   ├── dumpi
│   │   ├── Makefile
│   │   └── dumpi.cpp
│   ├── dynamic_alloc
│   │   ├── Makefile
│   │   ├── main.cpp
│   │   ├── x64.asm
│   │   └── x86.asm
│   ├── echo
│   │   ├── Makefile
│   │   ├── echofx.cpp
│   │   ├── echofx.rc
│   │   ├── echonul.cpp
│   │   └── main.cpp
│   ├── einst
│   │   ├── Makefile
│   │   ├── edll1x.cpp
│   │   ├── edll2x.cpp
│   │   ├── edll3x.cpp
│   │   └── einst.cpp
│   ├── excep
│   │   ├── Makefile
│   │   ├── excep.cpp
│   │   ├── firstexc.cpp
│   │   └── firstexc.h
│   ├── findfunc
│   │   ├── Makefile
│   │   ├── extend.cpp
│   │   ├── extend.rc
│   │   ├── findfunc.cpp
│   │   ├── symtest.cpp
│   │   ├── target.cpp
│   │   ├── target.h
│   │   └── target.rc
│   ├── impmunge
│   │   ├── Makefile
│   │   └── impmunge.cpp
│   ├── member
│   │   ├── Makefile
│   │   └── member.cpp
│   ├── opengl
│   │   ├── Makefile
│   │   ├── ogldet.cpp
│   │   ├── ogldet.rc
│   │   └── testogl.cpp
│   ├── payload
│   │   ├── Makefile
│   │   ├── payload.cpp
│   │   ├── payloadguid.hpp
│   │   └── payloadtarget.cpp
│   ├── region
│   │   ├── Makefile
│   │   └── region.cpp
│   ├── setdll
│   │   ├── Makefile
│   │   └── setdll.cpp
│   ├── simple
│   │   ├── Makefile
│   │   ├── simple.cpp
│   │   ├── simple.rc
│   │   └── sleep5.cpp
│   ├── simple_safe
│   │   ├── Makefile
│   │   ├── simple_safe.cpp
│   │   ├── simple_safe.rc
│   │   └── sleep5.cpp
│   ├── slept
│   │   ├── Makefile
│   │   ├── NORMAL_IA64.TXT
│   │   ├── NORMAL_X64.TXT
│   │   ├── NORMAL_X86.TXT
│   │   ├── dslept.cpp
│   │   ├── dslept.rc
│   │   ├── sleepbed.cpp
│   │   ├── sleepnew.cpp
│   │   ├── sleepold.cpp
│   │   ├── slept.cpp
│   │   ├── slept.h
│   │   ├── slept.rc
│   │   └── verify.cpp
│   ├── syelog
│   │   ├── Makefile
│   │   ├── sltest.cpp
│   │   ├── sltestp.cpp
│   │   ├── syelog.cpp
│   │   ├── syelog.h
│   │   └── syelogd.cpp
│   ├── talloc
│   │   ├── Makefile
│   │   ├── NORMAL_IA64.TXT
│   │   ├── NORMAL_X64.TXT
│   │   ├── talloc.cpp
│   │   ├── tdll1x.cpp
│   │   ├── tdll2x.cpp
│   │   ├── tdll3x.cpp
│   │   ├── tdll4x.cpp
│   │   ├── tdll5x.cpp
│   │   ├── tdll6x.cpp
│   │   ├── tdll7x.cpp
│   │   ├── tdll8x.cpp
│   │   └── tdll9x.cpp
│   ├── traceapi
│   │   ├── Makefile
│   │   ├── _win32.cpp
│   │   ├── testapi.cpp
│   │   ├── trcapi.cpp
│   │   └── trcapi.rc
│   ├── tracebld
│   │   ├── Makefile
│   │   ├── tracebld.cpp
│   │   ├── tracebld.h
│   │   ├── trcbld.cpp
│   │   └── trcbld.rc
│   ├── tracelnk
│   │   ├── Makefile
│   │   ├── trclnk.cpp
│   │   └── trclnk.rc
│   ├── tracemem
│   │   ├── Makefile
│   │   ├── trcmem.cpp
│   │   └── trcmem.rc
│   ├── tracereg
│   │   ├── Makefile
│   │   ├── trcreg.cpp
│   │   └── trcreg.rc
│   ├── traceser
│   │   ├── Makefile
│   │   ├── trcser.cpp
│   │   └── trcser.rc
│   ├── tracessl
│   │   ├── Makefile
│   │   ├── trcssl.cpp
│   │   └── trcssl.rc
│   ├── tracetcp
│   │   ├── Makefile
│   │   ├── trctcp.cpp
│   │   └── trctcp.rc
│   ├── tryman
│   │   ├── Makefile
│   │   ├── managed.cs
│   │   ├── size.cpp
│   │   ├── tryman.cpp
│   │   ├── tstman.cpp
│   │   └── tstman.rc
│   └── withdll
│       ├── Makefile
│       └── withdll.cpp
├── src
│   ├── Makefile
│   ├── creatwth.cpp
│   ├── detours.cpp
│   ├── detours.h
│   ├── detver.h
│   ├── disasm.cpp
│   ├── disolarm.cpp
│   ├── disolarm64.cpp
│   ├── disolia64.cpp
│   ├── disolx64.cpp
│   ├── disolx86.cpp
│   ├── image.cpp
│   ├── modules.cpp
│   └── uimports.cpp
├── system.mak
├── tests
│   ├── Makefile
│   ├── catch.hpp
│   ├── corruptor.cpp
│   ├── corruptor.h
│   ├── main.cpp
│   ├── payload.cpp
│   ├── payload.h
│   ├── process_helpers.cpp
│   ├── process_helpers.h
│   ├── test_image_api.cpp
│   └── test_module_api.cpp
└── vc
    ├── Detours.sln
    ├── Detours.vcxproj
    └── Detours.vcxproj.filters

```

`CREDITS.md`:

```md
# Detours Contributor Credits

The following individuals have helped identify specific bugs and improvements
in Detours. The entire Detours community has benefited from their help.

* Jay Krell:          Identified error in DetourFindPayload that caused a
                      incorrect failure when pcbData is NULL. (Build_342)

* Jay Krell:          Identified issue with VirtualSize == 0 files created in
                      NT 3.1 images. (Build_339)

* Igor Odnovorov:     Identified an issue with the placement of the trampoline
                      region when a function is detoured twice and the second
                      trampoline region is outside of the +/- 2GB range of
                      the target. (Build_337)

* Jay Krell:          Identified need for some programs to enumerate the
                      address of IAT entries. (Build_336)

* Calvin Hsia:        Identified need for some program to change the excluded
                      system region. (Build_336)

* Adam Smith:         Identified error in failure handling when VirtualProect
                      cannot make pages executable because the Prohibit
                      Dynamic Code Generation mitigation policy has been
                      applied to a process. (Build_335)

* Ben Faull:          Identified fix to detour_alloc_region_from_lo and
                      detour_alloc_region_from_hi that preserves ASLR entropy.
                      (Build_334)

* Shaoxiang Su:       Reported errors building with Visual Studio 2015.
                      (Build_332)

* Jay Krell:          Identified and resolved significant gaps in the X86, X64
                      and IA64 disassemblers for instruction found in code,
                      but seldom found in function prologues. (Build_331)

* Allan Murphy:       Identify error in rep and jmp ds: encodings. (Build_331)

* Philip Bacon:       Identified incorrect entry point return for pure
                      resource-only binaries. (Build_330)

* Jay Krell:          Identified failure in DetourAttachEx to update nAlign.
                      (Build_330)

* Sumit Sarin:        Helped debug error with packed binaries.
                      (Build_329)

* Nitya Kumar Sharma: Reported bug in DetourAfterWithDll for 32/64 agnostic
                      EXEs.
                      (Build_327)

* Richard Black:      Identified a large number of typos in documentation.
                      (Build_326)

* Michael Bilodeau:   Identified bug in DetourUpdateProcessWithDll when the
                      target process contains a Detours payload *after* all
                      valid PE binaries.
                      (Build_324)

* Meera Jindal:       Reported bug in identification of target address in
                      DetourCopyInstruction for jmp[] and call[] on x86 & x64,
                      the ff15 and ff25 opcodes.
                      (Build_323)

* Ken Johnson:        Assistance with SAL 2.0 annotations.
                      (Build_319)

* Nick Wood:          Identified bug in DetourFindFunction on ARM.
                      (Build_314)

* Mark Russinovich:   Helped debug DetourCreateProcessWithDllEx.
                      (Build_314)

* John Lin:           Implementation idea for DetoursCreateProcessWithDllEx.
                      (Build_314)

* Andrew Zawadowskiy  Reported an improper memory page permissions
                      vulnerability in Detours 2.1.  (Vulnerability does not
                      exist in versions later than Detours 2.1.)
                      (Build_223)

* Nightxie:           Identified bug in detour_alloc_round_up_to_region.
                      (Build_310)

* Diana Milirud:      Identified bug in B* instructions on ARM.
                      (Build_309)

* Juan Carlos         Identified correct MSIL entry point for unsigned MSIL.
  Luciani:            (Build_308)

* Lee Hunt            Suggested improvements in algorithm for allocation of
  Lawrence Landauer   trampoline regions on x64 to avoid collisions with
  Joe Laughlin:       system DLLs.
                      (Build_307)

* Tyler Sims          Identified bug in handling of "anycpu" MSIL binaries
  Darren Kennedy:     on x64.
                      (Build_307)

* Andre Vachon:       Help with optimized binaries.
                      (Build 301)

* Chris Mann:         Identified fix not forward ported from 2.2 to 3.0.
                      (Build_301)

* Mark Irving:        Identified bug with EXEs missing second import table.
                      (Build_300)

* Ben Schwarz:        Identified bug in handling of multi-byte NOPs.
                      (Build_300)

* Aaron Giles         Coded initial ARM/Thumb2 disassembler.
  Jared Henderson:    (Build_300)

* Doug Brubacher:     Coded initial x86 disassembler.
                      (Build_100)

```

`LICENSE.md`:

```md
# Copyright (c) Microsoft Corporation

All rights reserved.

# MIT License

Permission is hereby granted, free of charge, to any person obtaining a copy of
this software and associated documentation files (the "Software"), to deal in
the Software without restriction, including without limitation the rights to
use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies
of the Software, and to permit persons to whom the Software is furnished to do
so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.

```

`Makefile`:

```
##############################################################################
##
##  Makefile for Detours.
##
##  Microsoft Research Detours Package
##
##  Copyright (c) Microsoft Corporation.  All rights reserved.
##

ROOT = .
!include "$(ROOT)\system.mak"

all:
    cd "$(MAKEDIR)"
    @if exist "$(MAKEDIR)\core\makefile" cd "$(MAKEDIR)\core" && $(MAKE) /NOLOGO /$(MAKEFLAGS)
    cd "$(MAKEDIR)\src"
    @$(MAKE) /NOLOGO /$(MAKEFLAGS)
    cd "$(MAKEDIR)\samples"
    @$(MAKE) /NOLOGO /$(MAKEFLAGS)
    cd "$(MAKEDIR)\tests"
    @$(MAKE) /NOLOGO /$(MAKEFLAGS)
    @if exist "$(MAKEDIR)\bugs\makefile" cd "$(MAKEDIR)\bugs" && $(MAKE) /NOLOGO /$(MAKEFLAGS)
    cd "$(MAKEDIR)"

clean:
    cd "$(MAKEDIR)"
    @if exist "$(MAKEDIR)\core\makefile" cd "$(MAKEDIR)\core" && $(MAKE) /NOLOGO /$(MAKEFLAGS) clean
    cd "$(MAKEDIR)\src"
    @$(MAKE) /NOLOGO /$(MAKEFLAGS) clean
    cd "$(MAKEDIR)\samples"
    @$(MAKE) /NOLOGO /$(MAKEFLAGS) clean
    cd "$(MAKEDIR)\tests"
    @$(MAKE) /NOLOGO /$(MAKEFLAGS) clean
    @if exist "$(MAKEDIR)\bugs\makefile" cd "$(MAKEDIR)\bugs" && $(MAKE) /NOLOGO /$(MAKEFLAGS) clean
    cd "$(MAKEDIR)"

realclean: clean
    cd "$(MAKEDIR)"
    @if exist "$(MAKEDIR)\core\makefile" cd "$(MAKEDIR)\core" && $(MAKE) /NOLOGO /$(MAKEFLAGS) realclean
    cd "$(MAKEDIR)\src"
    @$(MAKE) /NOLOGO /$(MAKEFLAGS) realclean
    cd "$(MAKEDIR)\samples"
    @$(MAKE) /NOLOGO /$(MAKEFLAGS) realclean
    cd "$(MAKEDIR)\tests"
    @$(MAKE) /NOLOGO /$(MAKEFLAGS) realclean
    @if exist "$(MAKEDIR)\bugs\makefile" cd "$(MAKEDIR)\bugs" && $(MAKE) /NOLOGO /$(MAKEFLAGS) realclean
    cd "$(MAKEDIR)"
    -rmdir /q /s $(INCDS) 2> nul
    -rmdir /q /s $(LIBDS) 2> nul
    -rmdir /q /s $(BINDS) 2> nul
    -rmdir /q /s dist 2> nul
    -del docsrc\detours.chm 2> nul
    -del /q *.msi 2>nul
    -del /q /f /s *~ 2>nul

test:
    cd "$(MAKEDIR)\samples"
    @$(MAKE) /NOLOGO /$(MAKEFLAGS) test
    cd "$(MAKEDIR)\tests"
    @$(MAKE) /NOLOGO /$(MAKEFLAGS) test
    cd "$(MAKEDIR)"

################################################################# End of File.

```

`README.md`:

```md
# Microsoft Research Detours Package

Detours is a software package for monitoring and instrumenting API calls on Windows. Detours
has been used by many ISVs and  is also  used by product teams at Microsoft. Detours is now available under
a standard open source  license ([MIT](https://github.com/microsoft/Detours/blob/master/LICENSE.md)).  This simplifies licensing for programmers using Detours
and allows the community to support Detours using open source tools and processes.

Detours is compatible with the Windows NT family of 
operating systems: Windows NT, Windows XP, Windows Server 2003, Windows 7,
Windows 8, and Windows 10.  It cannot be used by Windows Store apps
because Detours requires APIs not available to those applications. 
This repo contains the source code for version 4.0.1 of Detours.

For technical documentation on Detours, see the [Detours Wiki](https://github.com/microsoft/Detours/wiki).
For directions on how to build and run samples, see the
samples [README.txt](https://github.com/Microsoft/Detours/blob/master/samples/README.TXT) file.

## Contributing

The [`Detours`](https://github.com/microsoft/detours) repository is where development is done.
Here are some ways you can participate in the project:

* [Answer questions](https://github.com/microsoft/detours/issues) about using Detours.
* [Improve the Wiki](https://github.com/microsoft/detours/wiki).
* [Submit bugs](https://github.com/microsoft/detours/issues) and help us verify fixes and changes as they are checked in.
* Review [source code changes](https://github.com/microsoft/detours/pulls).

Most contributions require you to agree to a Contributor License Agreement (CLA) declaring that
you have the right to, and actually do, grant us the rights to use your contribution.
For details, visit https://cla.opensource.microsoft.com.

When you submit a pull request, a CLA bot will automatically determine whether you need to provide
a CLA and decorate the PR appropriately (e.g., status check, comment). Simply follow the instructions
provided by the bot. You will only need to do this once across all repos using our CLA.

This project has adopted the [Microsoft Open Source Code of Conduct](https://opensource.microsoft.com/codeofconduct/). For more information see the [Code of Conduct FAQ](https://opensource.microsoft.com/codeofconduct/faq/) or contact [opencode@microsoft.com](mailto:opencode@microsoft.com) with any additional questions or comments.

## Issues, questions, and feedback

* Open an issue on [GitHub Issues](https://github.com/Microsoft/detours/issues).

## Mailing list for announcements

The detours-announce mailing list is a low-traffic email list for important announcements 
about the project, such as the availability of new versions of Detours.  To join it, send 
an email to listserv@lists.research.microsoft.com with a 
message body containing only the text SUBSCRIBE DETOURS-ANNOUNCE.
To leave it, send an email to listserv@lists.research.microsoft.com with a 
message body containing only the text UNSUBSCRIBE DETOURS-ANNOUNCE.


## License

Copyright (c) Microsoft Corporation. All rights reserved.

Licensed under the [MIT](LICENSE.md) License.

```

`samples/Makefile`:

```
##############################################################################
##
##  Makefile for Detours Test Programs.
##
##  Microsoft Research Detours Package
##
##  Copyright (c) Microsoft Corporation.  All rights reserved.
##
##  Note:
##    syelog, setdll, and withdll must be built first because a number of the
##    other samples depend on them.
##

ROOT=..
!include .\common.mak

##############################################################################

all:
    cd "$(MAKEDIR)\syelog"
    @$(MAKE) /NOLOGO /$(MAKEFLAGS)
    cd "$(MAKEDIR)\simple"
    @$(MAKE) /NOLOGO /$(MAKEFLAGS)
    cd "$(MAKEDIR)\simple_safe"
    @$(MAKE) /NOLOGO /$(MAKEFLAGS)
    cd "$(MAKEDIR)\slept"
    @$(MAKE) /NOLOGO /$(MAKEFLAGS)
    cd "$(MAKEDIR)\setdll"
    @$(MAKE) /NOLOGO /$(MAKEFLAGS)
    cd "$(MAKEDIR)\withdll"
    @$(MAKE) /NOLOGO /$(MAKEFLAGS)
    cd "$(MAKEDIR)\cping"
    @$(MAKE) /NOLOGO /$(MAKEFLAGS)
    cd "$(MAKEDIR)\disas"
    @$(MAKE) /NOLOGO /$(MAKEFLAGS)
    cd "$(MAKEDIR)\dtest"
    @$(MAKE) /NOLOGO /$(MAKEFLAGS)
    cd "$(MAKEDIR)\dumpe"
    @$(MAKE) /NOLOGO /$(MAKEFLAGS)
    cd "$(MAKEDIR)\dumpi"
    @$(MAKE) /NOLOGO /$(MAKEFLAGS)
    cd "$(MAKEDIR)\echo"
    @$(MAKE) /NOLOGO /$(MAKEFLAGS)
!IF "$(DETOURS_TARGET_PROCESSOR)" != "ARM64"
    cd "$(MAKEDIR)\einst"
    @$(MAKE) /NOLOGO /$(MAKEFLAGS)
!ENDIF
!IF "$(DETOURS_TARGET_PROCESSOR)" == "X86"
    cd "$(MAKEDIR)\excep"
    @$(MAKE) /NOLOGO /$(MAKEFLAGS)
!ENDIF
    cd "$(MAKEDIR)\comeasy"
    @$(MAKE) /NOLOGO /$(MAKEFLAGS)
    cd "$(MAKEDIR)\commem"
    @$(MAKE) /NOLOGO /$(MAKEFLAGS)
!IF "$(DETOURS_TARGET_PROCESSOR)" != "ARM64"
    cd "$(MAKEDIR)\findfunc"
    @$(MAKE) /NOLOGO /$(MAKEFLAGS)
!ENDIF
!IF "$(DETOURS_TARGET_PROCESSOR)" != "ARM" && "$(DETOURS_TARGET_PROCESSOR)" != "ARM64"
    cd "$(MAKEDIR)\member"
    @$(MAKE) /NOLOGO /$(MAKEFLAGS)
!ENDIF
    cd "$(MAKEDIR)\region"
    @$(MAKE) /NOLOGO /$(MAKEFLAGS)
!IF "$(DETOURS_TARGET_PROCESSOR)" == "X64" || "$(DETOURS_TARGET_PROCESSOR)" == "IA64"
    cd "$(MAKEDIR)\talloc"
    @$(MAKE) /NOLOGO /$(MAKEFLAGS)
!ENDIF
    cd "$(MAKEDIR)\traceapi"
    @$(MAKE) /NOLOGO /$(MAKEFLAGS)
    cd "$(MAKEDIR)\tracebld"
    @$(MAKE) /NOLOGO /$(MAKEFLAGS)
    cd "$(MAKEDIR)\tracemem"
    @$(MAKE) /NOLOGO /$(MAKEFLAGS)
    cd "$(MAKEDIR)\tracereg"
    @$(MAKE) /NOLOGO /$(MAKEFLAGS)
    cd "$(MAKEDIR)\traceser"
    @$(MAKE) /NOLOGO /$(MAKEFLAGS)
    cd "$(MAKEDIR)\tracessl"
    @$(MAKE) /NOLOGO /$(MAKEFLAGS)
    cd "$(MAKEDIR)\tracetcp"
    @$(MAKE) /NOLOGO /$(MAKEFLAGS)
    cd "$(MAKEDIR)\tracelnk"
    @$(MAKE) /NOLOGO /$(MAKEFLAGS)
!IF "$(DETOURS_TARGET_PROCESSOR)" != "ARM" && "$(DETOURS_TARGET_PROCESSOR)" != "ARM64"
    cd "$(MAKEDIR)\tryman"
    @$(MAKE) /NOLOGO /$(MAKEFLAGS)
!ENDIF
    cd "$(MAKEDIR)\impmunge"
    @$(MAKE) /NOLOGO /$(MAKEFLAGS)
    cd "$(MAKEDIR)\dynamic_alloc"
    @$(MAKE) /NOLOGO /$(MAKEFLAGS)
    cd "$(MAKEDIR)\payload"
    @$(MAKE) /NOLOGO /$(MAKEFLAGS)
    cd "$(MAKEDIR)"

clean:
    cd "$(MAKEDIR)\syelog"
    @$(MAKE) /NOLOGO /$(MAKEFLAGS) clean
    cd "$(MAKEDIR)\simple"
    @$(MAKE) /NOLOGO /$(MAKEFLAGS) clean
    cd "$(MAKEDIR)\simple_safe"
    @$(MAKE) /NOLOGO /$(MAKEFLAGS) clean
    cd "$(MAKEDIR)\slept"
    @$(MAKE) /NOLOGO /$(MAKEFLAGS) clean
    cd "$(MAKEDIR)\setdll"
    @$(MAKE) /NOLOGO /$(MAKEFLAGS) clean
    cd "$(MAKEDIR)\withdll"
    @$(MAKE) /NOLOGO /$(MAKEFLAGS) clean
    cd "$(MAKEDIR)\cping"
    @$(MAKE) /NOLOGO /$(MAKEFLAGS) clean
    cd "$(MAKEDIR)\disas"
    @$(MAKE) /NOLOGO /$(MAKEFLAGS) clean
    cd "$(MAKEDIR)\dtest"
    @$(MAKE) /NOLOGO /$(MAKEFLAGS) clean
    cd "$(MAKEDIR)\dumpe"
    @$(MAKE) /NOLOGO /$(MAKEFLAGS) clean
    cd "$(MAKEDIR)\dumpi"
    @$(MAKE) /NOLOGO /$(MAKEFLAGS) clean
    cd "$(MAKEDIR)\echo"
    @$(MAKE) /NOLOGO /$(MAKEFLAGS) clean
    cd "$(MAKEDIR)\einst"
    @$(MAKE) /NOLOGO /$(MAKEFLAGS) clean
    cd "$(MAKEDIR)\excep"
    @$(MAKE) /NOLOGO /$(MAKEFLAGS) clean
    cd "$(MAKEDIR)\comeasy"
    @$(MAKE) /NOLOGO /$(MAKEFLAGS) clean
    cd "$(MAKEDIR)\commem"
    @$(MAKE) /NOLOGO /$(MAKEFLAGS) clean
    cd "$(MAKEDIR)\findfunc"
    @$(MAKE) /NOLOGO /$(MAKEFLAGS) clean
    cd "$(MAKEDIR)\member"
    @$(MAKE) /NOLOGO /$(MAKEFLAGS) clean
    cd "$(MAKEDIR)\region"
    @$(MAKE) /NOLOGO /$(MAKEFLAGS) clean
    cd "$(MAKEDIR)\talloc"
    @$(MAKE) /NOLOGO /$(MAKEFLAGS) clean
    cd "$(MAKEDIR)\traceapi"
    @$(MAKE) /NOLOGO /$(MAKEFLAGS) clean
    cd "$(MAKEDIR)\tracebld"
    @$(MAKE) /NOLOGO /$(MAKEFLAGS) clean
    cd "$(MAKEDIR)\tracemem"
    @$(MAKE) /NOLOGO /$(MAKEFLAGS) clean
    cd "$(MAKEDIR)\tracereg"
    @$(MAKE) /NOLOGO /$(MAKEFLAGS) clean
    cd "$(MAKEDIR)\traceser"
    @$(MAKE) /NOLOGO /$(MAKEFLAGS) clean
    cd "$(MAKEDIR)\tracessl"
    @$(MAKE) /NOLOGO /$(MAKEFLAGS) clean
    cd "$(MAKEDIR)\tracetcp"
    @$(MAKE) /NOLOGO /$(MAKEFLAGS) clean
    cd "$(MAKEDIR)\tracelnk"
    @$(MAKE) /NOLOGO /$(MAKEFLAGS) clean
    cd "$(MAKEDIR)\tryman"
    @$(MAKE) /NOLOGO /$(MAKEFLAGS) clean
    cd "$(MAKEDIR)\impmunge"
    @$(MAKE) /NOLOGO /$(MAKEFLAGS) clean
    cd "$(MAKEDIR)\dynamic_alloc"
    @$(MAKE) /NOLOGO /$(MAKEFLAGS) clean
    cd "$(MAKEDIR)\payload"
    @$(MAKE) /NOLOGO /$(MAKEFLAGS) clean
    cd "$(MAKEDIR)"
    -rmdir lib32 2>nul
    -rmdir lib64 2>nul
    -rmdir include 2>nul

realclean:
    cd "$(MAKEDIR)\syelog"
    @$(MAKE) /NOLOGO /$(MAKEFLAGS) realclean
    cd "$(MAKEDIR)\simple"
    @$(MAKE) /NOLOGO /$(MAKEFLAGS) realclean
    cd "$(MAKEDIR)\simple_safe"
    @$(MAKE) /NOLOGO /$(MAKEFLAGS) realclean
    cd "$(MAKEDIR)\slept"
    @$(MAKE) /NOLOGO /$(MAKEFLAGS) realclean
    cd "$(MAKEDIR)\setdll"
    @$(MAKE) /NOLOGO /$(MAKEFLAGS) realclean
    cd "$(MAKEDIR)\withdll"
    @$(MAKE) /NOLOGO /$(MAKEFLAGS) realclean
    cd "$(MAKEDIR)\cping"
    @$(MAKE) /NOLOGO /$(MAKEFLAGS) realclean
    cd "$(MAKEDIR)\disas"
    @$(MAKE) /NOLOGO /$(MAKEFLAGS) realclean
    cd "$(MAKEDIR)\dtest"
    @$(MAKE) /NOLOGO /$(MAKEFLAGS) realclean
    cd "$(MAKEDIR)\dumpe"
    @$(MAKE) /NOLOGO /$(MAKEFLAGS) realclean
    cd "$(MAKEDIR)\dumpi"
    @$(MAKE) /NOLOGO /$(MAKEFLAGS) realclean
    cd "$(MAKEDIR)\echo"
    @$(MAKE) /NOLOGO /$(MAKEFLAGS) realclean
    cd "$(MAKEDIR)\einst"
    @$(MAKE) /NOLOGO /$(MAKEFLAGS) realclean
    cd "$(MAKEDIR)\excep"
    @$(MAKE) /NOLOGO /$(MAKEFLAGS) realclean
    cd "$(MAKEDIR)\comeasy"
    @$(MAKE) /NOLOGO /$(MAKEFLAGS) realclean
    cd "$(MAKEDIR)\commem"
    @$(MAKE) /NOLOGO /$(MAKEFLAGS) realclean
    cd "$(MAKEDIR)\findfunc"
    @$(MAKE) /NOLOGO /$(MAKEFLAGS) realclean
    cd "$(MAKEDIR)\member"
    @$(MAKE) /NOLOGO /$(MAKEFLAGS) realclean
    cd "$(MAKEDIR)\region"
    @$(MAKE) /NOLOGO /$(MAKEFLAGS) realclean
    cd "$(MAKEDIR)\talloc"
    @$(MAKE) /NOLOGO /$(MAKEFLAGS) realclean
    cd "$(MAKEDIR)\traceapi"
    @$(MAKE) /NOLOGO /$(MAKEFLAGS) realclean
    cd "$(MAKEDIR)\tracebld"
    @$(MAKE) /NOLOGO /$(MAKEFLAGS) realclean
    cd "$(MAKEDIR)\tracemem"
    @$(MAKE) /NOLOGO /$(MAKEFLAGS) realclean
    cd "$(MAKEDIR)\tracereg"
    @$(MAKE) /NOLOGO /$(MAKEFLAGS) realclean
    cd "$(MAKEDIR)\traceser"
    @$(MAKE) /NOLOGO /$(MAKEFLAGS) realclean
    cd "$(MAKEDIR)\tracessl"
    @$(MAKE) /NOLOGO /$(MAKEFLAGS) realclean
    cd "$(MAKEDIR)\tracetcp"
    @$(MAKE) /NOLOGO /$(MAKEFLAGS) realclean
    cd "$(MAKEDIR)\tracelnk"
    @$(MAKE) /NOLOGO /$(MAKEFLAGS) realclean
    cd "$(MAKEDIR)\tryman"
    @$(MAKE) /NOLOGO /$(MAKEFLAGS) realclean
    cd "$(MAKEDIR)\impmunge"
    @$(MAKE) /NOLOGO /$(MAKEFLAGS) realclean
    cd "$(MAKEDIR)\dynamic_alloc"
    @$(MAKE) /NOLOGO /$(MAKEFLAGS) realclean
    cd "$(MAKEDIR)\payload"
    @$(MAKE) /NOLOGO /$(MAKEFLAGS) realclean
    cd "$(MAKEDIR)"
    -rmdir lib32 2>nul
    -rmdir lib64 2>nul
    -rmdir include 2>nul

test:
    cd "$(MAKEDIR)\syelog"
    @$(MAKE) /NOLOGO /$(MAKEFLAGS) test
    cd "$(MAKEDIR)\simple"
    @$(MAKE) /NOLOGO /$(MAKEFLAGS) test
    cd "$(MAKEDIR)\simple_safe"
    @$(MAKE) /NOLOGO /$(MAKEFLAGS) test
!IF "$(DETOURS_TARGET_PROCESSOR)" != "ARM64"
    cd "$(MAKEDIR)\slept"
    @$(MAKE) /NOLOGO /$(MAKEFLAGS) test
    cd "$(MAKEDIR)\setdll"
    @$(MAKE) /NOLOGO /$(MAKEFLAGS) test
    cd "$(MAKEDIR)\withdll"
    @$(MAKE) /NOLOGO /$(MAKEFLAGS) test
!ENDIF
!IF "$(DETOURS_TARGET_PROCESSOR)" == "X86"
    cd "$(MAKEDIR)\cping"
#   @$(MAKE) /NOLOGO /$(MAKEFLAGS) test
!ENDIF
    cd "$(MAKEDIR)\disas"
    @$(MAKE) /NOLOGO /$(MAKEFLAGS) test
!IF "$(DETOURS_TARGET_PROCESSOR)" != "ARM64"
    cd "$(MAKEDIR)\dtest"
    @$(MAKE) /NOLOGO /$(MAKEFLAGS) test
!ENDIF
    cd "$(MAKEDIR)\dumpe"
    @$(MAKE) /NOLOGO /$(MAKEFLAGS) test
    cd "$(MAKEDIR)\dumpi"
    @$(MAKE) /NOLOGO /$(MAKEFLAGS) test
    cd "$(MAKEDIR)\echo"
    @$(MAKE) /NOLOGO /$(MAKEFLAGS) test
!IF "$(DETOURS_TARGET_PROCESSOR)" != "ARM64"
    cd "$(MAKEDIR)\einst"
    @$(MAKE) /NOLOGO /$(MAKEFLAGS) test
!ENDIF
!IF "$(DETOURS_TARGET_PROCESSOR)" == "X86"
    cd "$(MAKEDIR)\excep"
#   @$(MAKE) /NOLOGO /$(MAKEFLAGS) test
!ENDIF
!IF "$(DETOURS_TARGET_PROCESSOR)" != "ARM64"
    cd "$(MAKEDIR)\comeasy"
    @$(MAKE) /NOLOGO /$(MAKEFLAGS) test

    cd "$(MAKEDIR)\commem"
    @$(MAKE) /NOLOGO /$(MAKEFLAGS) test
    cd "$(MAKEDIR)\findfunc"
    @$(MAKE) /NOLOGO /$(MAKEFLAGS) test
    cd "$(MAKEDIR)\member"
    @$(MAKE) /NOLOGO /$(MAKEFLAGS) test
    cd "$(MAKEDIR)\region"
    @$(MAKE) /NOLOGO /$(MAKEFLAGS) test
!ENDIF
!IF "$(DETOURS_TARGET_PROCESSOR)" == "X64" || "$(DETOURS_TARGET_PROCESSOR)" == "IA64"
    cd "$(MAKEDIR)\talloc"
    @$(MAKE) /NOLOGO /$(MAKEFLAGS) test
!ENDIF
!IF "$(DETOURS_TARGET_PROCESSOR)" != "ARM64"
    cd "$(MAKEDIR)\traceapi"
    @$(MAKE) /NOLOGO /$(MAKEFLAGS) test
    cd "$(MAKEDIR)\tracebld"
    @$(MAKE) /NOLOGO /$(MAKEFLAGS) test
    cd "$(MAKEDIR)\tracemem"
    @$(MAKE) /NOLOGO /$(MAKEFLAGS) test
    cd "$(MAKEDIR)\tracereg"
    @$(MAKE) /NOLOGO /$(MAKEFLAGS) test
    cd "$(MAKEDIR)\traceser"
    @$(MAKE) /NOLOGO /$(MAKEFLAGS) test
!ENDIF
#    cd "$(MAKEDIR)\tracessl"
#    @$(MAKE) /NOLOGO /$(MAKEFLAGS) test
#    cd "$(MAKEDIR)\tracetcp"
#    @$(MAKE) /NOLOGO /$(MAKEFLAGS) test
!IF "$(DETOURS_TARGET_PROCESSOR)" != "ARM64"
    cd "$(MAKEDIR)\tracelnk"
    @$(MAKE) /NOLOGO /$(MAKEFLAGS) test
!ENDIF
    cd "$(MAKEDIR)\impmunge"
    @$(MAKE) /NOLOGO /$(MAKEFLAGS) test
    cd "$(MAKEDIR)\dynamic_alloc"
    @$(MAKE) /NOLOGO /$(MAKEFLAGS) test
    cd "$(MAKEDIR)\payload"
    @$(MAKE) /NOLOGO /$(MAKEFLAGS) test
    cd "$(MAKEDIR)"

##
################################################################# End of File.

```

`samples/README.TXT`:

```TXT
##############################################################################
##
##  Samples README File
##
##  Microsoft Research Detours Package
##
##  Copyright (c) Microsoft Corporation.  All rights reserved.
##

This README file describes how to set up your build environment, build
samples, and run tests.

BUILD ENVIRONMENT:
==================
We assume that you have a version of the Visual Studio IDE installed.  You can
download a free copy of the Visual Studio IDE from
https://visualstudio.microsoft.com.  During Visual Studio installation, make
sure that C/C++ tools are installed and that the Windows SDK is installed.

Clone the Detours git repo to a directory on your machine.  Choose a directory
that does not have spaces in the full path name.

BUILDING:
=========
Open a Developer Command Prompt for VS.  Note there are several different
flavors of the command prompt for different target architectures.  The
default Visual Studio Command prompt targets x86.  To target x64, choose
the "X64 Native Tools Command Prompt for VS"

Change directory to the samples directory for your git repo.  To build the
samples, type "nmake".

Note that you must build setdll and syslog in order to use many of the
other sample programs.

INSTALLING AND BUILDING VIA VCPKG:
==================================
You can download and install detours using the vcpkg(https://github.com/Microsoft/vcpkg) dependency manager:

    git clone https://github.com/Microsoft/vcpkg.git
    cd vcpkg
    ./bootstrap-vcpkg.sh
    ./vcpkg integrate install
    vcpkg install detours
    
The detours port in vcpkg is kept up to date by Microsoft team members and community contributors. If the version is out of date, please create an issue or pull request(https://github.com/Microsoft/vcpkg) on the vcpkg repository.

TESTING:
========
Each of the sample directories has a test, which can be invoked by typing
"nmake test", to demonstrate the usage of the sample.  With very few
exceptions, all of the executables also accept a "/?" command to display a
usage message.

To run all sample tests, change directory to the samples directory and type
"nmake test".  Note that some samples are architecture-specific.  Tests for
those samples be run only on supported architectures and will be skipped on
other architectures.

COMMENTS:
=========
The trace* samples log their output through the syelogd.exe daemon and hook
CreateProcessW to load themselves into any child processes.  For example,
typing "withdll -d:traceapi.dll cmd.exe" will create a command shell under
which all processes log their API calls through traceapi.dll.

```

`samples/comeasy/Makefile`:

```
##############################################################################
##
##  API Extension to Measure time slept.
##
##  Microsoft Research Detours Package
##
##  Copyright (c) Microsoft Corporation.  All rights reserved.
##

!include ..\common.mak

LIBS=$(LIBS) kernel32.lib

##############################################################################

all: dirs \
    $(BIND)\wrotei$(DETOURS_BITS).dll \
    $(BIND)\comeasy.exe \
!IF $(DETOURS_SOURCE_BROWSING)==1
    $(OBJD)\wrotei$(DETOURS_BITS).bsc \
    $(OBJD)\comeasy.bsc \
!ENDIF
    option

##############################################################################

clean:
    -del $(BIND)\wrotei*.* 2>nul
    -del $(BIND)\comeasy.* 2>nul
    -del $(BIND)\wrotei.* *~ 2>nul
    -rmdir /q /s $(OBJD) 2>nul

realclean: clean
    -rmdir /q /s $(OBJDS) 2>nul

dirs:
    @if not exist $(BIND) mkdir $(BIND) && echo.   Created $(BIND)
    @if not exist $(OBJD) mkdir $(OBJD) && echo.   Created $(OBJD)

##############################################################################

$(OBJD)\wrotei.obj : wrotei.cpp

$(OBJD)\wrotei.res : wrotei.rc

$(BIND)\wrotei$(DETOURS_BITS).dll $(BIND)\wrotei$(DETOURS_BITS).lib: \
        $(OBJD)\wrotei.obj $(OBJD)\wrotei.res $(DEPS)
    cl /LD $(CFLAGS) /Fe$(@R).dll /Fd$(@R).pdb \
        $(OBJD)\wrotei.obj $(OBJD)\wrotei.res \
        /link $(LINKFLAGS) /subsystem:console \
        /export:DetourFinishHelperProcess,@1,NONAME \
        $(LIBS) ole32.lib

$(OBJD)\wrotei$(DETOURS_BITS).bsc : $(OBJD)\wrotei.obj
    bscmake /v /n /o $@ $(OBJD)\wrotei.sbr

$(OBJD)\comeasy.obj : comeasy.cpp

$(BIND)\comeasy.exe : $(OBJD)\comeasy.obj $(DEPS)
    cl $(CFLAGS) /Fe$@ /Fd$(@R).pdb \
        $(OBJD)\comeasy.obj \
        /link $(LINKFLAGS) $(LIBS) ole32.lib \
        /subsystem:console /fixed:no

$(OBJD)\comeasy.bsc : $(OBJD)\comeasy.obj
    bscmake /v /n /o $@ $(OBJD)\comeasy.sbr

############################################### Install non-bit-size binaries.

!IF "$(DETOURS_OPTION_PROCESSOR)" != ""

$(OPTD)\wrotei$(DETOURS_OPTION_BITS).dll:
$(OPTD)\wrotei$(DETOURS_OPTION_BITS).pdb:

$(BIND)\wrotei$(DETOURS_OPTION_BITS).dll : $(OPTD)\wrotei$(DETOURS_OPTION_BITS).dll
    @if exist $? copy /y $? $(BIND) >nul && echo $@ copied from $(DETOURS_OPTION_PROCESSOR).
$(BIND)\wrotei$(DETOURS_OPTION_BITS).pdb : $(OPTD)\wrotei$(DETOURS_OPTION_BITS).pdb
    @if exist $? copy /y $? $(BIND) >nul && echo $@ copied from $(DETOURS_OPTION_PROCESSOR).

option: \
    $(BIND)\wrotei$(DETOURS_OPTION_BITS).dll \
    $(BIND)\wrotei$(DETOURS_OPTION_BITS).pdb \

!ELSE

option:

!ENDIF

##############################################################################

test: all
    @echo -------- Reseting test binaries to initial state. -----------------------
    $(BIND)\setdll.exe -r $(BIND)\comeasy.exe
    @echo.
    @echo -------- Should not load slept$(DETOURS_BITS).dll --------------------------------------
    $(BIND)\comeasy.exe
    @echo.
    @echo -------- Adding wrotei$(DETOURS_BITS).dll to comeasy.exe ------------------------------
    $(BIND)\setdll.exe -d:$(BIND)\wrotei$(DETOURS_BITS).dll $(BIND)\comeasy.exe
    @echo.
    @echo -------- Should load wrotei$(DETOURS_BITS).dll ----------------------------------------
    $(BIND)\comeasy.exe
    @echo.
    @echo -------- Removing wrotei$(DETOURS_BITS).dll from comeasy.exe --------------------------
    $(BIND)\setdll.exe -r $(BIND)\comeasy.exe
    @echo.
    @echo -------- Should not load wrotei$(DETOURS_BITS).dll ------------------------------------
    $(BIND)\comeasy.exe
    @echo.
    @echo -------- Should load wrotei$(DETOURS_BITS).dll dynamically using withdll.exe ----------
    $(BIND)\withdll.exe -d:$(BIND)\wrotei$(DETOURS_BITS).dll $(BIND)\comeasy.exe
    @echo.
    @echo -------- Test completed. ------------------------------------------------

################################################################# End of File.

```

`samples/comeasy/comeasy.cpp`:

```cpp
//////////////////////////////////////////////////////////////////////////////
//
//  Detour Test Program (comeasy.cpp of comeasy.exe)
//
//  Microsoft Research Detours Package
//
//  Copyright (c) Microsoft Corporation.  All rights reserved.
//

#include <ole2.h>
#include <windows.h>
#include <stdio.h>

//////////////////////////////////////////////////////////////////////////////
//
int __cdecl main(int argc, char **argv)
{
    HRESULT hr;

    (void)argc;
    (void)argv;

    LPSTREAM pStream = NULL;
    ULARGE_INTEGER ul;
    LARGE_INTEGER li;

    printf("comeasy.exe: Starting (at %p).\n", main);

    CoInitialize(NULL);

    hr = CreateStreamOnHGlobal(NULL, TRUE, &pStream);

    ul.QuadPart = 512;
    hr = pStream->SetSize(ul);

    li.QuadPart = 0;
    hr = pStream->Seek(li, STREAM_SEEK_SET, NULL);

    printf("comeasy.exe: First write.\n");
    fflush(stdout);

    li.QuadPart = 0;
    hr = pStream->Write(&ul, sizeof(ul), NULL);

    printf("comeasy.exe: Second write.\n");
    fflush(stdout);

    li.QuadPart = 1;
    hr = pStream->Write(&li, sizeof(li), NULL);

    printf("comeasy.exe: Third write.\n");
    fflush(stdout);

    li.QuadPart = 2;
    hr = pStream->Write(&li, sizeof(li), NULL);

    pStream->Release();
    pStream = NULL;

    CoUninitialize();

    printf("comeasy.exe: Exiting.\n\n");
    fflush(stdout);

    return 0;
}

//
///////////////////////////////////////////////////////////////// End of File.

```

`samples/comeasy/wrotei.cpp`:

```cpp
//////////////////////////////////////////////////////////////////////////////
//
//  Detour Test Program (wrotei.cpp of wrotei.dll)
//
//  Microsoft Research Detours Package
//
//  Copyright (c) Microsoft Corporation.  All rights reserved.
//
//  An example dynamically detouring a function.
//
#include <stdio.h>

//////////////////////////////////////////////////////////////////////////////
//
//  WARNING:
//
//  CINTERFACE must be defined so that the lpVtbl pointer is visible
//  on COM interfaces.  However, once we've defined it, we must use
//  coding conventions when accessing interface members, for example:
//      i->lpVtbl->Write
//  instead of the C++ syntax:
//      i->Write.
//  We must also pass the implicit "this" parameter explicitly:
//      i->lpVtbl->Write(i, pb, 0, NULL)
//  instead of the C++ syntax:
//      i->Write(pb, 0, NULL)
//
#define CINTERFACE
#include <ole2.h>
#include <windows.h>
#include <detours.h>

//////////////////////////////////////////////////////////////////////////////
//
LONG dwWrote = 0;

static int (WINAPI * TrueEntryPoint)(VOID) = NULL;
static int (WINAPI * RawEntryPoint)(VOID) = NULL;

//////////////////////////////////////////////////////////////////////////////
//
HRESULT (STDMETHODCALLTYPE *RealIStreamWrite)(IStream * This,
                                              const void *pv,
                                              ULONG cb,
                                              ULONG *pcbWritten) = NULL;

HRESULT STDMETHODCALLTYPE MineIStreamWrite(IStream * This,
                                           const void *pv,
                                           ULONG cb,
                                           ULONG *pcbWritten)
{
    HRESULT hr;
    ULONG cbWritten = 0;
    if (pcbWritten == NULL) {
        pcbWritten = &cbWritten;
    }

    hr = RealIStreamWrite(This, pv, cb, pcbWritten);

    for (;;) {
        LONG dwOld = dwWrote;
        LONG dwNew = dwOld + *pcbWritten;

        if (InterlockedCompareExchange(&dwWrote, dwNew, dwOld) == dwOld) {
            break;
        }
    }

    return hr;
}

//////////////////////////////////////////////////////////////////////////////
//
int WINAPI TimedEntryPoint(VOID)
{
    // We couldn't call CoInitializeEx in DllMain,
    // so we detour the vtable entries here...
    LONG error;
    LPSTREAM pStream = NULL;

    // Create a temporary object so we can get a vtable.
    CreateStreamOnHGlobal(NULL, TRUE, &pStream);

    // Apply the detour to the vtable.
    DetourTransactionBegin();
    DetourUpdateThread(GetCurrentThread());
    if (pStream != NULL) {
        RealIStreamWrite = pStream->lpVtbl->Write;
        DetourAttach(&(PVOID&)RealIStreamWrite, MineIStreamWrite);
    }
    error = DetourTransactionCommit();

    if (pStream != NULL) {
        pStream->lpVtbl->Release(pStream);
        pStream = NULL;
    }

    if (error == NO_ERROR) {
        printf("wrotei" DETOURS_STRINGIFY(DETOURS_BITS) ".dll:"
               " Detoured IStream::Wrote() from OnHGlobal.\n");
    }
    else {
        printf("wrotei" DETOURS_STRINGIFY(DETOURS_BITS) ".dll:"
               " Error detouring IStram::Wrote(): %ld\n", error);
    }

    printf("wrotei" DETOURS_STRINGIFY(DETOURS_BITS) ".dll:"
           " Calling EntryPoint\n\n");
    fflush(stdout);

    return TrueEntryPoint();
}

BOOL WINAPI DllMain(HINSTANCE hinst, DWORD dwReason, LPVOID reserved)
{
    LONG error;
    (void)hinst;
    (void)reserved;

    if (DetourIsHelperProcess()) {
        return TRUE;
    }

    if (dwReason == DLL_PROCESS_ATTACH) {
        DetourRestoreAfterWith();

        printf("wrotei" DETOURS_STRINGIFY(DETOURS_BITS) ".dll:"
               " Starting.\n");
        fflush(stdout);

        // NB: DllMain can't call LoadLibrary, so we hook the app entry point.
        TrueEntryPoint = (int (WINAPI *)(VOID))DetourGetEntryPoint(NULL);
        RawEntryPoint = TrueEntryPoint;

        DetourTransactionBegin();
        DetourUpdateThread(GetCurrentThread());
        DetourAttach(&(PVOID&)TrueEntryPoint, TimedEntryPoint);
        error = DetourTransactionCommit();

        if (error == NO_ERROR) {
            printf("wrotei" DETOURS_STRINGIFY(DETOURS_BITS) ".dll:"
                   " Detoured EntryPoint().\n");
        }
        else {
            printf("wrotei" DETOURS_STRINGIFY(DETOURS_BITS) ".dll:"
                   " Error detouring EntryPoint(): %ld\n", error);
        }
    }
    else if (dwReason == DLL_PROCESS_DETACH) {
        DetourTransactionBegin();
        DetourUpdateThread(GetCurrentThread());
        if (RealIStreamWrite != NULL) {
            DetourDetach(&(PVOID&)RealIStreamWrite, (PVOID)MineIStreamWrite);
        }
        DetourDetach(&(PVOID&)TrueEntryPoint, TimedEntryPoint);
        error = DetourTransactionCommit();

        printf("wrotei" DETOURS_STRINGIFY(DETOURS_BITS) ".dll:"
               " Removed IStream::Wrote() detours (%ld), wrote %ld bytes.\n",
               error, dwWrote);

        fflush(stdout);
    }
    return TRUE;
}
//
///////////////////////////////////////////////////////////////// End of File.

```

`samples/comeasy/wrotei.rc`:

```rc
//////////////////////////////////////////////////////////////////////////////
//
//  Version information for wrotei.rc.
//
//  Microsoft Research Detours Package
//
//  Copyright (c) Microsoft Corporation.  All rights reserved.
//

#include "detver.h"

#define VER_INTERNALNAME_STR        "wrotei" DETOURS_STRINGIFY(DETOURS_BITS)
#define VER_ORIGINALFILENAME_STR    "wrotei" DETOURS_STRINGIFY(DETOURS_BITS) ".dll"
#define VER_FILEDESCRIPTION_STR     "Detours COM Easy Sample"
#define VER_COMPANYNAME_STR         "Microsoft Corporation"

#include "common.ver"

```

`samples/commem/Makefile`:

```
##############################################################################
##
##  Makefile for Detours Test Programs.
##
##  Microsoft Research Detours Package
##
##  Copyright (c) Microsoft Corporation.  All rights reserved.
##

!include ..\common.mak

LIBS=$(LIBS) kernel32.lib

all: dirs \
    $(BIND)\commem.exe \
!IF $(DETOURS_SOURCE_BROWSING)==1
    $(OBJD)\commem.bsc
!ENDIF

clean:
    -del *~ *.obj *.sbr 2> nul
    -del $(BIND)\commem.* 2> nul
    -rmdir /q /s $(OBJD) 2>nul

realclean: clean
    -rmdir /q /s $(OBJDS) 2>nul

dirs:
    @if not exist $(BIND) mkdir $(BIND) && echo.   Created $(BIND)
    @if not exist $(OBJD) mkdir $(OBJD) && echo.   Created $(OBJD)

$(BIND)\commem.obj : commem.cpp

$(BIND)\commem.exe : $(OBJD)\commem.obj $(DEPS)
    cl $(CFLAGS) /Fe$@ /Fd$(@R).pdb $(OBJD)\commem.obj \
        /link $(LINKFLAGS) $(LIBS) ole32.lib /subsystem:console

$(OBJD)\commem.bsc : $(OBJD)\commem.obj
    bscmake /v /n /o $@ $(OBJD)\commem.sbr

##############################################################################

test: $(BIND)\commem.exe
    @echo.
    $(BIND)\commem.exe
    @echo.

################################################################# End of File.

```

`samples/commem/commem.cpp`:

```cpp
//////////////////////////////////////////////////////////////////////////////
//
//  Detour functions of a COM interface (commem.cpp of commem.exe)
//
//  Microsoft Research Detours Package
//
//  Copyright (c) Microsoft Corporation.  All rights reserved.
//
//
//
#include <stdio.h>

//////////////////////////////////////////////////////////////////////////////
//
//  WARNING:
//
//  CINTERFACE must be defined so that the lpVtbl pointer is visible
//  on COM interfaces.  However, once we've defined it, we must use
//  coding conventions when accessing interface members, for example:
//      i->lpVtbl->Write
//  instead of the C++ syntax:
//      i->Write.
//  We must also pass the implicit "this" parameter explicitly:
//      i->lpVtbl->Write(i, pb, 0, NULL)
//  instead of the C++ syntax:
//      i->Write(pb, 0, NULL)
//
#define CINTERFACE
#include <ole2.h>
#include <windows.h>
#include <detours.h>

//////////////////////////////////////////////////////////////////////////////
//
HRESULT (STDMETHODCALLTYPE *RealIStreamWrite)(IStream * This,
                                              const void *pv,
                                              ULONG cb,
                                              ULONG *pcbWritten) = NULL;

HRESULT STDMETHODCALLTYPE MineIStreamWrite(IStream * This,
                                           const void *pv,
                                           ULONG cb,
                                           ULONG *pcbWritten)
{
    HRESULT hr;
    ULONG cbWritten = 0;
    if (pcbWritten == NULL) {
        pcbWritten = &cbWritten;
    }

    printf("commem:   %p->IStreamWrite(pv=%p, cb=%ld)\n", This, pv, cb);
    hr = RealIStreamWrite(This, pv, cb, pcbWritten);
    printf("commem:   %p->IStreamWrite -> %08lx (pcbWritten=%ld)\n", This, hr, *pcbWritten);

    return hr;
}

//////////////////////////////////////////////////////////////////////////////
//
int main(int argc, char **argv)
{
    HRESULT hr;

    (void)argc;
    (void)argv;

    LPSTREAM pStream = NULL;
    ULARGE_INTEGER ul;
    LARGE_INTEGER li;

    CoInitialize(NULL);

    hr = CreateStreamOnHGlobal(NULL, TRUE, &pStream);

    RealIStreamWrite = pStream->lpVtbl->Write;

    ul.QuadPart = 512;
    hr = pStream->lpVtbl->SetSize(pStream, ul);
    li.QuadPart = 0;
    hr = pStream->lpVtbl->Seek(pStream, li, STREAM_SEEK_SET, NULL);

    printf("commem: Calling Write w/o before attach.\n");

    li.QuadPart = 0;
    hr = pStream->lpVtbl->Write(pStream, &ul, sizeof(ul), NULL);

    DetourTransactionBegin();
    DetourUpdateThread(GetCurrentThread());
    DetourAttach(&(PVOID&)RealIStreamWrite, MineIStreamWrite);
    DetourTransactionCommit();

    printf("commem: Calling Write w/o after attach.\n");

    li.QuadPart = 1;
    hr = pStream->lpVtbl->Write(pStream, &li, sizeof(li), NULL);

    DetourTransactionBegin();
    DetourUpdateThread(GetCurrentThread());
    DetourDetach(&(PVOID&)RealIStreamWrite, MineIStreamWrite);
    DetourTransactionCommit();

    printf("commem: Calling Write w/o after detach.\n");

    li.QuadPart = 2;
    hr = pStream->lpVtbl->Write(pStream, &li, sizeof(li), NULL);

    hr = pStream->lpVtbl->Release(pStream);
    pStream = NULL;

    CoUninitialize();

    return 0;
}


```

`samples/common.mak`:

```mak
##############################################################################
##
##  Common makefile for Detours test programs.
##
##  Microsoft Research Detours Package
##
##  Copyright (c) Microsoft Corporation.  All rights reserved.
##

!IF "$(ROOT)" == ""
ROOT = ..\..
!ENDIF
!include "$(ROOT)\system.mak"

!IF "$(DETOURS_SOURCE_BROWSING)" == ""
DETOURS_SOURCE_BROWSING=0
!ENDIF

##############################################################################

!IFNDEF CLIB
CLIB=/MT
!ENDIF

AFLAGS=/nologo /Zi /c /Fl
CFLAGS=/nologo /Zi $(CLIB) /Gm- /W4 /WX /we4777 /we4800 /Od /DDETOUR_DEBUG=$(DETOURS_DEBUG)

!IF $(DETOURS_SOURCE_BROWSING)==1
CFLAGS=$(CFLAGS) /FR
!ELSE
CFLAGS=$(CFLAGS) /I$(INCD)
!ENDIF

LIBFLAGS=/nologo
LINKFLAGS=/release /incremental:no /profile /nodefaultlib:oldnames.lib

!if defined(DETOURS_WIN_7) && defined(DETOURS_CL_17_OR_NEWER)
CFLAGS=$(CFLAGS) /D_USING_V110_SDK71_
!endif

!IF "$(DETOURS_TARGET_PROCESSOR)" == "X86"

ASM=ml

!ELSEIF "$(DETOURS_TARGET_PROCESSOR)" == "X64"

ASM=ml64

!ELSEIF "$(DETOURS_TARGET_PROCESSOR)" == "IA64"

ASM=ias
AFLAGS=-F COFF32_PLUS
CFLAGS=$(CFLAGS) /wd4163 # intrinsic rdtebex not available; using newer Windows headers with older compiler
#CFLAGS=$(CFLAGS) /wd4996 /wd4068

!ELSEIF "$(DETOURS_TARGET_PROCESSOR)" == "ARM"

ASM=armasm
AFLAGS=-coff_thumb2_only
CFLAGS=$(CFLAGS) /D_ARM_WINAPI_PARTITION_DESKTOP_SDK_AVAILABLE

CFLAGS=$(CFLAGS) /D_$(DETOURS_TARGET_PROCESSOR:X64=AMD64)_ # redundant with windows.h except for midl proxies

!ENDIF

DEPS = $(LIBD)\syelog.lib $(LIBD)\detours.lib
LIBS = $(DEPS)

##############################################################################
##

.SUFFIXES: .cpp .h .obj .rc .res

!ifdef DETOURS_ANALYZE
.cpp{$(OBJD)}.obj:
    $(CC) $(CFLAGS) /Fd$(OBJD)\vc.pdb /Fo$(OBJD)\ /c $<
!else
.cpp{$(OBJD)}.obj::
    $(CC) $(CFLAGS) /Fd$(OBJD)\vc.pdb /Fo$(OBJD)\ /c $<
!endif

.rc{$(OBJD)}.res:
    rc /nologo /DDETOURS_BITS=$(DETOURS_BITS) /fo$(@) /i$(INCD) $(*B).rc

##
################################################################# End of File.

```

`samples/cping/Makefile`:

```
##############################################################################
##
##  Makefile for Detours Test Programs.
##
##  Microsoft Research Detours Package
##
##  Copyright (c) Microsoft Corporation.  All rights reserved.
##

!include ..\common.mak

LIBS=$(LIBS) \
    kernel32.lib \
    user32.lib \
    shell32.lib \
    uuid.lib \
    ole32.lib \
    rpcrt4.lib \
    advapi32.lib \
    wsock32.lib \

# RpcProxy.h uses #ifdef WIN32.

!if "$(DETOURS_TARGET_PROCESSOR)" == "ARM"
CFLAGS = $(CFLAGS) /D_WIN32_WINNT=0x0500
!else
CFLAGS = $(CFLAGS) /D_WIN32_WINNT=0x0400
!endif

CFLAGS = $(CFLAGS) /Fd$(OBJD)\vc.pdb \
        /DCONST_VTABLE \
        /DCOBJMACROS -DWIN32 -DNT

C__FLAGS=-DENTRY_PREFIX=iping_ -DREGISTER_PROXY_DLL 
CPPFLAGS=

##############################################################################

.SUFFIXES: .c .cpp .h .idl .obj .res .rc

{$(OBJD)}.c{$(OBJD)}.obj:
    $(CC) $(CFLAGS:/W4=/W3) $(C__FLAGS) /I$(OBJD) /Fo$(OBJD)\ /c $<

!ifdef DETOURS_ANALYZE
.cpp{$(OBJD)}.obj:
    $(CC) $(CFLAGS) $(CPPFLAGS) /I$(OBJD) /Fo$(OBJD)\ /c $<
!else
.cpp{$(OBJD)}.obj::
    $(CC) $(CFLAGS) $(CPPFLAGS) /I$(OBJD) /Fo$(OBJD)\ /c $<
!endif

.rc{$(OBJD)}.res:
    rc /nologo /Fo$@ .\$(*B).rc

##############################################################################
##
C__FLAGS=-DENTRY_PREFIX=iping_ -DREGISTER_PROXY_DLL 
CPPFLAGS=


MIDLFLAGS=/nologo /Oif /no_format_opt

!IF "$(DETOURS_TARGET_PROCESSOR)" == "X86"
MIDLFLAGS=$(MIDLFLAGS) /no_robust /win32
!ELSEIF "$(DETOURS_TARGET_PROCESSOR)" == "IA64"
MIDLFLAGS=$(MIDLFLAGS) /ia64
!ELSEIF "$(DETOURS_TARGET_PROCESSOR)" == "X64"
MIDLFLAGS=$(MIDLFLAGS) /x64
!ELSEIF "$(DETOURS_TARGET_PROCESSOR)" == "ARM"
MIDLFLAGS=$(MIDLFLAGS) /arm32
!ELSEIF "$(DETOURS_TARGET_PROCESSOR)" == "ARM64"
MIDLFLAGS=$(MIDLFLAGS) /arm64
!ENDIF

OBJS = \
    $(OBJD)\cping.obj   \
    \
    $(OBJD)\iping_i.obj \
    $(OBJD)\iping_p.obj \
    $(OBJD)\iping_d.obj \

##############################################################################

all: dirs \
    $(BIND)\cping.exe   \
!IF $(DETOURS_SOURCE_BROWSING)==1
    $(OBJD)\cping.bsc
!ENDIF

##############################################################################

clean:
    -del iping.h *.c *.obj *.sbr *~ 2>nul
    -del $(BIND)\cping.* 2>nul
    -rmdir /q /s $(OBJD) 2>nul

realclean: clean
    -rmdir /q /s $(OBJDS) 2>nul

##############################################################################

dirs:
    @if not exist $(BIND) mkdir $(BIND) && echo.   Created $(BIND)
    @if not exist $(OBJD) mkdir $(OBJD) && echo.   Created $(OBJD)

$(OBJD)\cping.bsc : $(OBJS)
    bscmake /v /n /o $@ $(OBJS:.obj=.sbr)

$(BIND)\cping.exe : $(OBJS) $(DEPS)
    cl $(CFLAGS) /Fe$@ $(OBJS) /link $(LINKFLAGS) \
        /subsystem:console $(LIBS)

$(OBJD)\cping.obj: cping.cpp $(OBJD)\iping.h

##############################################################################
##
$(OBJD)\iping.h $(OBJD)\iping_d.c $(OBJD)\iping_i.c $(OBJD)\iping_p.c : iping.idl
    midl $(MIDLFLAGS) /out $(OBJD) /prefix all iping_ /dlldata iping_d.c iping.idl

$(OBJD)\iping_i.obj: $(OBJD)\iping_i.c
$(OBJD)\iping_p.obj: $(OBJD)\iping_p.c $(OBJD)\iping.h
$(OBJD)\iping_d.obj: $(OBJD)\iping_d.c

##############################################################################

test: $(BIND)\cping.exe
    start $(BIND)\cping.exe /s
    $(BIND)\cping.exe /p localhost

################################################################# End of File.

```

`samples/cping/ReadMe.Txt`:

```Txt
Microsoft Research Detours Package
==============================================================================
4/2/98

* Instrumentation:
    Read Pentium cycle counter

* PC configuration:
    DCOM/TCP, Windows NT Server 4.0,
    between two 300MHz Pentium boxes,
    Ethernet connecction

* Client test program:
    HRESULT get(SHORT, SHORT, LONG*)
    average over 1,000 calls
    midl /Oicf

* Results:
    get() {
                    <-- (1)
      IRpcChannelBuffer::SendReceive()) {
                    <-- (2)
        I_RpcSendReceive() {
                    <-- (3)
          send(soc, )
                    <-- (4)
          NtWaitForSingleObject(soc, )
                    <-- (5)
        } // end of RPC layer
                    <-- (6)
      } // end of channel object
                    <-- (7)
    } // end of client call
                            Average number
                               of Pentium cycles
    (1) NDR marshaling overhead (2 SHORTs)      13   K
                (No! of which 11K from GetBuffer,
                     of which 6.2K from I_RpcGetBuffer()!)
    (2) Channel object one-way (send) overhead       1.0 K
    (3) RPC layer one-way (send) overhead        5.3 K
    (4) TCP + all server work                      200   K
    (5) RPC layer one-way (recv) overhead        5.1 K
    (6) Channel object one-way (recv) overhead       2.2 K
    (7) NDR unmarshaling overhead (2 LONGs)      4.2 K

    (*) send() only                 17   K
    TOTAL CYCLES for client get(): 230 K

```

`samples/cping/cping.cpp`:

```cpp
//////////////////////////////////////////////////////////////////////////////
//
//  Module: cping.cpp (cping.exe)
//
//  Microsoft Research Detours Package
//
//  Copyright (c) Microsoft Corporation.  All rights reserved.
//
//  COM Ping text program.
//
#define _RPCRT4_
#define INITGUID
#include <winsock2.h>
#include <objbase.h>
#include <objidl.h>
#include <ocidl.h>
#include <olectl.h>
#include <shellapi.h>
#include <stdio.h>
#include <stdlib.h>
#pragma warning(push)
#if _MSC_VER > 1400
#pragma warning(disable:6102 6103) // /analyze warnings
#endif
#include <strsafe.h>
#pragma warning(pop)
#include <winnt.h>
#include <rpc.h>
#include <rpcdcep.h>
#include <detours.h>
#include "iping.h"

// ARM64 ReadTimeStampCounter is a function.
// ARM ReadTimeStampCounter is a declared function but not implemented.
// old IA64: ReadTimeStampCounter nonexisant.
// new IA64: ReadTimeStampCounter is a macro.
// old x86; ReadTimeStampCounter is a function.
// new x86: ReadTimeStampCounter is a macro.
// AMD64: ReadTimeStampCounter is a macro.

#if defined(_ARM64_) || defined(ReadTimeStampCounter)
#define GetTimeStamp() ReadTimeStampCounter()
#elif defined(_X86_) || defined(_AMD64_)
extern "C"
DWORD64
__rdtsc (
    VOID
    );
#pragma intrinsic(__rdtsc)
#define GetTimeStamp() __rdtsc()
#else
UINT64 GetTimeStamp(void)
{
    LARGE_INTEGER a = { 0 };
    QueryPerformanceCounter(&a);
    return a.QuadPart;
}
#endif

#define BE_VERBOSE
////////////////////////////////////////////////////////// Assertion Handling.
//
#pragma warning(disable:4127)   // Many of our asserts are constants.

#ifndef NODEBUG
#undef ASSERT
VOID PingAssertMessage(CONST PCHAR szMsg, CONST PCHAR szFile, ULONG nLine);
#define ASSERT(x)   \
do { if (!((int)(x))) { PingAssertMessage(#x, __FILE__, __LINE__); DebugBreak(); }} while (0)
;
#else   // NODEBUG
#undef ASSERT
#define ASSERT(x)
#endif  // NODEBUG

//////////////////////////////////////////////////////////////////////////////

#define wcssize(x)      ((wcslen(x) + 1) * sizeof(WCHAR))
#define strsize(x)      ((strlen(x) + 1) * sizeof(CHAR))

extern "C" {
    ULONG WINAPI iping_DllMain(HINSTANCE hinstDLL, DWORD fdwReason, LPVOID lpvReserved);
    HRESULT STDAPICALLTYPE iping_DllRegisterServer(void);
    HRESULT STDAPICALLTYPE iping_DllUnregisterServer(void);
    HRESULT STDAPICALLTYPE iping_DllGetClassObject(REFCLSID rclsid,
                                                   REFIID riid, PVOID *ppv);
    HRESULT STDAPICALLTYPE iping_DllCanUnloadNow(void);
}

STDAPI PingMessage(PCSTR msg, ...);

///////////////////////////////////////////////////////////////////// Globals.

void *              g_pBuffer = NULL;
WCHAR               g_wzServerName[128];
WCHAR               g_wzClientName[128];
ULONG               g_cbBufferMax = 262144;
double              g_dCyclesPerSecond = 0.0;
double              g_dMsPerCycle = 0.0;
double              g_dLatency = 0.0;
BOOL                g_fSummarize = TRUE;
ULONG               g_nFixedToClient = 0;
ULONG               g_nFixedToServer = 0;

//////////////////////////////////////////////////////////////////////////////
//
static CHAR s_szMessageBuf[2048];

STDAPI PingMessage(PCSTR msg, ...)
{
    HRESULT hr;
    double d = 0.0;                                     // Required for FP support
    (void)d;
    va_list args;

    va_start(args, msg);
    hr = StringCchVPrintfA(s_szMessageBuf, ARRAYSIZE(s_szMessageBuf), msg, args);
    va_end(args);
    if (FAILED(hr)) {
        return hr;
    }

    // OutputDebugStringA(s_szMessageBuf);

    printf("%s", s_szMessageBuf);
    return S_FALSE;
}

VOID PingAssertMessage(CONST PCHAR szMsg, CONST PCHAR szFile, ULONG nLine)
{
    PingMessage("%08lx ASSERT(%s) failed in %s, line %d.\n",
                GetCurrentThreadId(), szMsg, szFile, nLine);
    printf("ASSERT(%s) failed in %s, line %ld.\n", szMsg, szFile, nLine);
}

BOOLEAN CheckResult(HRESULT hr, PCSTR pszMsg, ...)
{
    if (FAILED(hr)) {
        HRESULT ihr;
        va_list args;

        va_start(args, pszMsg);
        ihr = StringCchVPrintfA(s_szMessageBuf, ARRAYSIZE(s_szMessageBuf), pszMsg, args);
        va_end(args);
        if (FAILED(ihr)) {
            return FALSE;
        }

        printf("  %-57.57s -> %08lx\n", s_szMessageBuf, hr);
        return FALSE;
    }
    return TRUE;
}

//////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////
//
#define NTSYSAPI            DECLSPEC_IMPORT
#define NTAPI               __stdcall
#define NTSTATUS            LONG
#define PIO_APC_ROUTINE     PVOID

typedef struct
{
    NTSTATUS    Status;
    LONG        Information;
} *PIO_STATUS_BLOCK;

NTSTATUS (NTAPI *Real_NtWaitForSingleObject)(HANDLE Handle,
                                             BOOLEAN Alertable,
                                             PLARGE_INTEGER Timeout) = NULL;

NTSTATUS (NTAPI *Real_NtDeviceIoControlFile)(HANDLE FileHandle,
                                             HANDLE Event,
                                             PIO_APC_ROUTINE ApcRoutine,
                                             PVOID ApcContext,
                                             PIO_STATUS_BLOCK IoStatusBlock,
                                             ULONG IoControlCode,
                                             PVOID InputBuffer,
                                             ULONG InputBufferLength,
                                             PVOID OutputBuffer,
                                             ULONG OutputBufferLength) = NULL;

//////////////////////////////////////////////////////////////////////////////
//
static LONG     s_nInCall = 0;
static ULONG    s_nThread = 0;

enum {
    E_MinValue = 0,
    E_SleepEx = 1,

    E_Proxy,

    E_I_RpcGetBuffer,
    E_I_RpcSendReceive,
    E_I_RpcFreeBuffer,
    E_I_RpcSend,
    E_I_RpcReceive,
    E_I_RpcFreePipeBuffer,
    E_I_RpcReallocPipeBuffer,
    E_I_RpcRequestMutex,
    E_I_RpcClearMutex,
    E_I_RpcAllocate,
    E_I_RpcFree,
    E_I_RpcPauseExecution,
    E_I_RpcMonitorAssociation,
    E_I_RpcStopMonitorAssociation,

    E_Recv,
    E_RecvFrom,
    E_NtWaitForSingleObject,
    E_NtDeviceIoControlFileRecv,
    E_NtDeviceIoControlFile,

    E_Send,
    E_SendTo,
    E_NtDeviceIoControlFileSend,

    E_DCOM,
    E_RPC,
    E_UDP,
    E_NET,

    E_MaxValue,

    E_DcomBeg = E_Proxy,
    E_DcomEnd = E_Proxy,

    E_RpcBeg = E_I_RpcGetBuffer,
    E_RpcEnd = E_I_RpcStopMonitorAssociation,

    E_UdpBeg = E_Send,
    E_UdpEnd = E_NtDeviceIoControlFileSend,

    E_NetBeg = E_Recv,
    E_NetEnd = E_NtDeviceIoControlFile,
};

PCHAR s_rszRouteNames[E_MaxValue] =
{
    "<NULL>",
    "SleepEx",
    "Proxy",
    "I_RpcGetBuffer",
    "I_RpcSendReceive",
    "I_RpcFreeBuffer",
    "I_RpcSend",
    "I_RpcReceive",
    "I_RpcFreePipeBuffer",
    "I_RpcReallocPipeBuffer",
    "I_RpcRequestMutex",
    "I_RpcClearMutex",
    "I_RpcAllocate",
    "I_RpcFree",
    "I_RpcPauseExecution",
    "I_RpcMonitorAssociation",
    "I_RpcStopMonitorAssociation",
    "Recv",
    "RecvFrom",
    "NtWaitForSingleObject",
    "NtDeviceIoControlRecv",
    "NtDeviceIoControlFile",
    "Send",
    "SendTo",
    "NtDeviceIoControlSend",
    "DCOM",
    "RPC",
    "UDP/TCP (Send Only)",
    "NET",
};

LONGLONG    s_rllCycles[E_MaxValue];
LONGLONG    s_rllTotals[E_MaxValue];
LONG        s_rllCounts[E_MaxValue];

class CRouteTime
{
  public:
    inline CRouteTime(LONG nRoute)
        {
            if (s_nInCall && GetCurrentThreadId() == s_nThread) {
                LONGLONG llBeg;
                m_nOldRoute = s_nRoute;
                m_llOldMinus = s_llMinus;

                s_nRoute = m_nRoute = nRoute;

                s_rllCounts[m_nRoute]++;
                s_llMinus = 0;
                ASSERT(m_nRoute != m_nOldRoute);

                llBeg = GetTimeStamp();
                m_llBeg = llBeg;
            }
            else {
                m_nRoute = 0;
            }
        }

    inline ~CRouteTime()
        {
            if (m_nRoute) {
                LONGLONG llEnd = GetTimeStamp();
                llEnd -= m_llBeg;
                s_rllTotals[m_nRoute] += llEnd;
                s_rllCycles[m_nRoute] += llEnd - s_llMinus;
                s_nRoute = m_nOldRoute;
                s_llMinus = m_llOldMinus + llEnd;
            }
        }

    inline BOOL Routed()
        {
            return m_nRoute;
        }

  public:
    ULONG       m_nRoute;
    ULONG       m_nOldRoute;
    LONGLONG    m_llBeg;
    LONGLONG    m_llOldMinus;
    static ULONG    s_nRoute;
    static LONGLONG s_llMinus;
};

ULONG       CRouteTime::s_nRoute = 0;
LONGLONG    CRouteTime::s_llMinus = 0;

VOID ZeroCycles(VOID)
{
    for (ULONG n = 0; n < E_MaxValue; n++) {
        s_rllCycles[n] = 0;
        s_rllTotals[n] = 0;
        s_rllCounts[n] = 0;
    }
}

VOID DumpCycles(LONG nRoute)
{
    if (s_rllCycles[nRoute] != 0 || s_rllTotals[nRoute] != 0) {
        printf(";;   %-21.21s %10I64d %8.3fms %10I64d %8.3fms :%6ld\n",
               s_rszRouteNames[nRoute],
               s_rllCycles[nRoute], (double)s_rllCycles[nRoute] * g_dMsPerCycle,
               s_rllTotals[nRoute], (double)s_rllTotals[nRoute] * g_dMsPerCycle,
               s_rllCounts[nRoute]);
    }
}

VOID SummarizeCycles(VOID)
{
    ULONG n;
    for (n = E_DCOM; n <= E_NET; n++) {
        s_rllCycles[n] = 0;
        s_rllTotals[n] = 0;
        s_rllCounts[n] = 0;
    }

    for (n = E_DcomBeg; n <= E_DcomEnd; n++) {
        s_rllCycles[E_DCOM] += s_rllCycles[n];
        s_rllTotals[E_DCOM] += s_rllTotals[n];
    }
    for (n = E_RpcBeg; n <= E_RpcEnd; n++) {
        s_rllCycles[E_RPC] += s_rllCycles[n];
        s_rllTotals[E_RPC] += s_rllTotals[n];
    }
    for (n = E_UdpBeg; n <= E_UdpEnd; n++) {
        s_rllCycles[E_UDP] += s_rllCycles[n];
        s_rllTotals[E_UDP] += s_rllTotals[n];
    }
    for (n = E_NetBeg; n <= E_NetEnd; n++) {
        s_rllCycles[E_NET] += s_rllCycles[n];
        s_rllTotals[E_NET] += s_rllTotals[n];
    }

#ifdef BE_VERBOSE
    printf("::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::"
           "::::::::::::::::::\n");
    printf(":: Protocol Cycles:\n");
    DumpCycles(E_DCOM);
    DumpCycles(E_RPC);
    DumpCycles(E_UDP);
    DumpCycles(E_NET);
#endif

    s_rllCycles[E_DCOM] /= s_rllCounts[E_DCOM];
    s_rllCycles[E_RPC] /= s_rllCounts[E_DCOM];
    s_rllCycles[E_UDP] /= s_rllCounts[E_DCOM];
    s_rllCycles[E_NET] /= s_rllCounts[E_DCOM];
    s_rllTotals[E_DCOM] /= s_rllCounts[E_DCOM];
    s_rllTotals[E_RPC] /= s_rllCounts[E_DCOM];
    s_rllTotals[E_UDP] /= s_rllCounts[E_DCOM];
    s_rllTotals[E_NET] /= s_rllCounts[E_DCOM];

#ifdef BE_VERBOSE
    printf("::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::"
           "::::::::::::::::::\n");
    printf(":: Protocol Cycles Per DCOM Call:\n");
    DumpCycles(E_DCOM);
    DumpCycles(E_RPC);
    DumpCycles(E_UDP);
    DumpCycles(E_NET);
#endif

    for (n = 0; n < E_DCOM; n++) {
        s_rllCycles[n] = 0;
        s_rllTotals[n] = 0;
        s_rllCounts[n] = 0;
    }
}

//////////////////////////////////////////////////////////////////////////////
//
DWORD (WINAPI * Real_SleepEx)(DWORD dwMilliseconds, BOOL bAlertable)
    = SleepEx;
int (WSAAPI * Real_send)(SOCKET s,
                         const char * buf, int len, int flags)
    = send;
int (WSAAPI * Real_sendto)(SOCKET s,
                           const char * buf, int len, int flags,
                           const struct sockaddr * to, int tolen)
    = sendto;
int (WSAAPI * Real_recv)(SOCKET s, char * buf, int len, int flags)
    = recv;
int (WSAAPI * Real_recvfrom)(SOCKET s,char * buf, int len, int flags,
                             struct sockaddr * from, int * fromlen)
    = recvfrom;

RPC_STATUS (RPC_ENTRY *
            Real_I_RpcGetBuffer)(RPC_MESSAGE * Message)
    = I_RpcGetBuffer;
RPC_STATUS (RPC_ENTRY *
            Real_I_RpcSendReceive)(RPC_MESSAGE * Message)
    = I_RpcSendReceive;
RPC_STATUS (RPC_ENTRY *
            Real_I_RpcFreeBuffer)(RPC_MESSAGE * Message)
    = I_RpcFreeBuffer;
RPC_STATUS (RPC_ENTRY *
            Real_I_RpcSend)(PRPC_MESSAGE Message)
    = I_RpcSend;
RPC_STATUS (RPC_ENTRY *
            Real_I_RpcReceive)(PRPC_MESSAGE Message,
                               unsigned int Size)
    = I_RpcReceive;
RPC_STATUS (RPC_ENTRY *
            Real_I_RpcFreePipeBuffer)(RPC_MESSAGE * Message)
    = I_RpcFreePipeBuffer;
RPC_STATUS (RPC_ENTRY *
            Real_I_RpcReallocPipeBuffer)(PRPC_MESSAGE Msg,
                                         unsigned int Size)
    = I_RpcReallocPipeBuffer;
void (RPC_ENTRY *
      Real_I_RpcRequestMutex)(I_RPC_MUTEX * Mutex)
    = I_RpcRequestMutex;
void (RPC_ENTRY *
      Real_I_RpcClearMutex)(I_RPC_MUTEX Mutex)
    = I_RpcClearMutex;
void * (RPC_ENTRY *
      Real_I_RpcAllocate)(unsigned int Size)
    = I_RpcAllocate;
void (RPC_ENTRY *
      Real_I_RpcFree)(void * Object)
    = I_RpcFree;
void (RPC_ENTRY *
      Real_I_RpcPauseExecution)(unsigned long Milliseconds)
    = I_RpcPauseExecution;

#if _MSC_VER < 1300
RPC_STATUS (RPC_ENTRY *
            Real_I_RpcMonitorAssociation)(RPC_BINDING_HANDLE Handle,
                                          PRPC_RUNDOWN RundownRoutine,
                                          void * Context)
    = I_RpcMonitorAssociation;
RPC_STATUS (RPC_ENTRY *
            Real_I_RpcStopMonitorAssociation)(RPC_BINDING_HANDLE Handle)
    = I_RpcStopMonitorAssociation;
#endif

//////////////////////////////////////////////////////////////////////////////
//
static DWORD WINAPI Catch_SleepEx(DWORD dwMilliseconds, BOOL bAlertable)
{
    CRouteTime rt(E_SleepEx);
    return Real_SleepEx(dwMilliseconds, bAlertable);
}

static int WSAAPI Catch_send(SOCKET s, const char * buf, int len, int flags)
{
    CRouteTime rt(E_Send);
    return Real_send(s, buf, len, flags);
}

static NTSTATUS NTAPI Catch_NtWaitForSingleObject(HANDLE Handle,
                                                  BOOLEAN Alertable,
                                                  PLARGE_INTEGER Timeout)
{
    CRouteTime rt(E_NtWaitForSingleObject);
    if (rt.Routed()) {
        //printf("WaitForSingle(%d, %I64d)\n", Alertable, Timeout->QuadPart);
    }

    return Real_NtWaitForSingleObject(Handle, Alertable, Timeout);
}

#define IO_CONTROL_AFD_SEND_DATAGRAM        0x12023
#define IO_CONTROL_AFD_SEND                 0x1201f
#define IO_CONTROL_AFD_RECV_DATAGRAM        0x1201b
#define IO_CONTROL_AFD_RECV                 0x12017

static NTSTATUS NTAPI Catch_NtDeviceIoControlFile(HANDLE FileHandle,
                                                  HANDLE Event,
                                                  PIO_APC_ROUTINE ApcRoutine,
                                                  PVOID ApcContext,
                                                  PIO_STATUS_BLOCK IoStatusBlock,
                                                  ULONG IoControlCode,
                                                  PVOID InputBuffer,
                                                  ULONG InputBufferLength,
                                                  PVOID OutputBuffer,
                                                  ULONG OutputBufferLength)
{
    if (IoControlCode == IO_CONTROL_AFD_SEND_DATAGRAM ||
        IoControlCode == IO_CONTROL_AFD_SEND) {
        CRouteTime rt(E_NtDeviceIoControlFileSend);
        NTSTATUS NtStatus = Real_NtDeviceIoControlFile(FileHandle,
                                                       Event,
                                                       ApcRoutine,
                                                       ApcContext,
                                                       IoStatusBlock,
                                                       IoControlCode,
                                                       InputBuffer,
                                                       InputBufferLength,
                                                       OutputBuffer,
                                                       OutputBufferLength);
        if (NtStatus == STATUS_PENDING) {
            LARGE_INTEGER li;
            li.QuadPart = INFINITE;
            Real_NtWaitForSingleObject(Event, FALSE, &li);
            NtStatus = IoStatusBlock->Status;
        }
        return NtStatus;
    }
    else if (IoControlCode == IO_CONTROL_AFD_RECV_DATAGRAM ||
             IoControlCode == IO_CONTROL_AFD_RECV) {
        CRouteTime rt(E_NtDeviceIoControlFileRecv);
        return Real_NtDeviceIoControlFile(FileHandle,
                                          Event,
                                          ApcRoutine,
                                          ApcContext,
                                          IoStatusBlock,
                                          IoControlCode,
                                          InputBuffer,
                                          InputBufferLength,
                                          OutputBuffer,
                                          OutputBufferLength);
    }
    else {
        CRouteTime rt(E_NtDeviceIoControlFile);
        if (rt.Routed()) {
            printf("IoControlCode: %08lx\n", IoControlCode);
            __debugbreak();
        }
        return Real_NtDeviceIoControlFile(FileHandle,
                                          Event,
                                          ApcRoutine,
                                          ApcContext,
                                          IoStatusBlock,
                                          IoControlCode,
                                          InputBuffer,
                                          InputBufferLength,
                                          OutputBuffer,
                                          OutputBufferLength);
    }
}


static RPC_STATUS RPC_ENTRY Catch_I_RpcGetBuffer(RPC_MESSAGE * Message)
{
    CRouteTime rt(E_I_RpcGetBuffer);
    return Real_I_RpcGetBuffer(Message);
}

static RPC_STATUS RPC_ENTRY Catch_I_RpcSendReceive(RPC_MESSAGE * Message)
{
    CRouteTime rt(E_I_RpcSendReceive);
    return Real_I_RpcSendReceive(Message);
}

static RPC_STATUS RPC_ENTRY Catch_I_RpcFreeBuffer(RPC_MESSAGE * Message)
{
    CRouteTime rt(E_I_RpcFreeBuffer);
    return Real_I_RpcFreeBuffer(Message);
}

static RPC_STATUS RPC_ENTRY Catch_I_RpcSend(PRPC_MESSAGE Message)
{
    CRouteTime rt(E_I_RpcSend);
    return Real_I_RpcSend(Message);
}

static RPC_STATUS RPC_ENTRY Catch_I_RpcReceive(PRPC_MESSAGE Message, unsigned int Size)
{
    CRouteTime rt(E_I_RpcReceive);
    return Real_I_RpcReceive(Message, Size);
}

static RPC_STATUS RPC_ENTRY Catch_I_RpcFreePipeBuffer(RPC_MESSAGE * Message)
{
    CRouteTime rt(E_I_RpcFreePipeBuffer);
    return Real_I_RpcFreePipeBuffer(Message);
}

static RPC_STATUS RPC_ENTRY Catch_I_RpcReallocPipeBuffer(PRPC_MESSAGE Message,
                                                         unsigned int NewSize)
{
    CRouteTime rt(E_I_RpcReallocPipeBuffer);
    return Real_I_RpcReallocPipeBuffer(Message, NewSize);
}

static void RPC_ENTRY Catch_I_RpcRequestMutex(I_RPC_MUTEX * Mutex)
{
    CRouteTime rt(E_I_RpcRequestMutex);
    Real_I_RpcRequestMutex(Mutex);
}

static void RPC_ENTRY Catch_I_RpcClearMutex(I_RPC_MUTEX Mutex)
{
    CRouteTime rt(E_I_RpcClearMutex);
    Real_I_RpcClearMutex(Mutex);
}

static void * RPC_ENTRY Catch_I_RpcAllocate(unsigned int Size)
{
    CRouteTime rt(E_I_RpcAllocate);
    return Real_I_RpcAllocate(Size);
}

static void RPC_ENTRY Catch_I_RpcFree(void * Object)
{
    CRouteTime rt(E_I_RpcFree);
    Real_I_RpcFree(Object);
}

static void RPC_ENTRY Catch_I_RpcPauseExecution(unsigned long Milliseconds)
{
    CRouteTime rt(E_I_RpcPauseExecution);
    Real_I_RpcPauseExecution(Milliseconds);
}

#if _MSC_VER < 1300
static RPC_STATUS RPC_ENTRY Catch_I_RpcMonitorAssociation(RPC_BINDING_HANDLE Handle,
                                                          PRPC_RUNDOWN RundownRoutine,
                                                          void * Context)
{
    CRouteTime rt(E_I_RpcMonitorAssociation);
    return Real_I_RpcMonitorAssociation(Handle, RundownRoutine, Context);
}

static RPC_STATUS RPC_ENTRY Catch_I_RpcStopMonitorAssociation(RPC_BINDING_HANDLE Handle)
{
    CRouteTime rt(E_I_RpcStopMonitorAssociation);
    return Real_I_RpcStopMonitorAssociation(Handle);
}
#endif

static STDMETHODIMP Catch_IPing_Ping(IPing *pip)
{
    HRESULT hr;
    InterlockedIncrement(&s_nInCall);
    {
        CRouteTime rt(E_Proxy);
        hr = pip->Ping();
    }
    InterlockedDecrement(&s_nInCall);
    return hr;
}

static STDMETHODIMP Catch_IPing_PingToServer(IPing *pip, LPSTR pszString)
{
    HRESULT hr;
    InterlockedIncrement(&s_nInCall);
    {
        CRouteTime rt(E_Proxy);
        hr = pip->PingToServer(pszString);
    }
    InterlockedDecrement(&s_nInCall);
    return hr;
}

static STDMETHODIMP Catch_IPing_PingToClient(IPing *pip, LPSTR *ppszString)
{
    HRESULT hr;
    InterlockedIncrement(&s_nInCall);
    {
        CRouteTime rt(E_Proxy);
        hr = pip->PingToClient(ppszString);
    }
    InterlockedDecrement(&s_nInCall);
    return hr;
}

//////////////////////////////////////////////////////////////////////////////
//
LONG RerouteEntryPoints(VOID)
{
    Real_NtWaitForSingleObject
        = ((NTSTATUS (NTAPI *)(HANDLE,
                               BOOLEAN,
                               PLARGE_INTEGER))
           DetourFindFunction("ntdll.dll", "NtWaitForSingleObject"));

    Real_NtDeviceIoControlFile
        = ((NTSTATUS (NTAPI *)(HANDLE,
                               HANDLE,
                               PIO_APC_ROUTINE,
                               PVOID,
                               PIO_STATUS_BLOCK,
                               ULONG,
                               PVOID,
                               ULONG,
                               PVOID,
                               ULONG))
           DetourFindFunction("ntdll.dll", "NtDeviceIoControlFile"));

    DetourTransactionBegin();
    DetourUpdateThread(GetCurrentThread());

    DetourAttach(&(PVOID&)Real_NtWaitForSingleObject,
                 Catch_NtWaitForSingleObject);
    DetourAttach(&(PVOID&)Real_NtDeviceIoControlFile,
                 Catch_NtDeviceIoControlFile);

    DetourAttach(&(PVOID&)Real_SleepEx,
                 Catch_SleepEx);
    DetourAttach(&(PVOID&)Real_send,
                 Catch_send);
    DetourAttach(&(PVOID&)Real_I_RpcGetBuffer,
                 Catch_I_RpcGetBuffer);
    DetourAttach(&(PVOID&)Real_I_RpcSendReceive,
                 Catch_I_RpcSendReceive);
    DetourAttach(&(PVOID&)Real_I_RpcFreeBuffer,
                 Catch_I_RpcFreeBuffer);
    DetourAttach(&(PVOID&)Real_I_RpcSend,
                 Catch_I_RpcSend);
    DetourAttach(&(PVOID&)Real_I_RpcReceive,
                 Catch_I_RpcReceive);
    DetourAttach(&(PVOID&)Real_I_RpcFreePipeBuffer,
                 Catch_I_RpcFreePipeBuffer);
    DetourAttach(&(PVOID&)Real_I_RpcReallocPipeBuffer,
                 Catch_I_RpcReallocPipeBuffer);
    DetourAttach(&(PVOID&)Real_I_RpcRequestMutex,
                 Catch_I_RpcRequestMutex);
    DetourAttach(&(PVOID&)Real_I_RpcClearMutex,
                 Catch_I_RpcClearMutex);
    DetourAttach(&(PVOID&)Real_I_RpcAllocate,
                 Catch_I_RpcAllocate);
    DetourAttach(&(PVOID&)Real_I_RpcFree,
                 Catch_I_RpcFree);
    DetourAttach(&(PVOID&)Real_I_RpcPauseExecution,
                 Catch_I_RpcPauseExecution);
#if _MSC_VER < 1300
    DetourAttach(&(PVOID&)Real_I_RpcMonitorAssociation,
                 Catch_I_RpcMonitorAssociation);
    DetourAttach(&(PVOID&)Real_I_RpcStopMonitorAssociation,
                 Catch_I_RpcStopMonitorAssociation);
#endif

    return DetourTransactionCommit();
}

//////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////// Classes.

class CNetPingFactory : public IClassFactory
{
  public:
    CNetPingFactory();
    ~CNetPingFactory();

    // IUnknown
    STDMETHODIMP    QueryInterface(REFIID riid, void** ppv);
    STDMETHODIMP_(ULONG) AddRef(void);
    STDMETHODIMP_(ULONG) Release(void);

    // IClassFactory
    STDMETHODIMP    CreateInstance(LPUNKNOWN punkOuter, REFIID iid, void **ppv);
    STDMETHODIMP    LockServer(BOOL fLock);

  public:
    static HRESULT  InitSystem(VOID);
    static HRESULT  FiniSystem(VOID);

    static HRESULT  InitObject(VOID);
    static HRESULT  FiniObject(VOID);

    static HRESULT  Lock(BOOL fLock);

    static HRESULT  Wait(VOID);

  private:
    LONG            m_cRef;

    static HANDLE   s_hevtDone;
    static LONG     s_nObjects;
    static LONG     s_nLocks;
};

class CNetPingObject : public IPing
{
  public:
    CNetPingObject();
    ~CNetPingObject();

    // IUnknown
    STDMETHODIMP    QueryInterface(REFIID iid, void **ppv);
    STDMETHODIMP_(ULONG) AddRef(void);
    STDMETHODIMP_(ULONG) Release(void);

    // IPing
    STDMETHODIMP    Ping();
    STDMETHODIMP    PingToServer(LPSTR pszString);
    STDMETHODIMP    PingToClient(LPSTR *ppszString);
    STDMETHODIMP    PingToClientSize(ULONG cbOut);

  private:
    LONG        m_cRef;
    ULONG       m_cbLast;
    ULONG       m_cbOut;
};

/////////////////////////////////////////////////////////////////////// GUIDs.

DEFINE_GUID(CLSID_NetPingObject,
            0xdecdbeed, 0xd1ac, 0x11d1, 0x96, 0xbc, 0x00, 0xaa, 0x00, 0x57, 0x3f, 0xb0);

/////////////////////////////////////////////////////////// Initialize String.
//
void InitializeString(LPSTR pszString, LONG cbSize)
{
    ASSERT(cbSize >= 1);

    while (cbSize-- > 1) {
        *pszString++ = '+';
    }
    *pszString = '\0';
}

BOOL GetKeyValue(HKEY hRootKey, PWCHAR pwzKey, PWCHAR pwzValueName, PWCHAR pwzValue,
                 DWORD cbValue)
{
    HKEY        hKey;
    WCHAR       wzKey[256];
    HRESULT     hr;

    hr = StringCchCopyW(wzKey, ARRAYSIZE(wzKey), pwzKey);
    if (FAILED(hr)) {
        return FALSE;
    }

    if (RegOpenKeyExW(hRootKey, wzKey, 0, KEY_READ, &hKey) != NO_ERROR) {
      abort:
        pwzValue[0] = '\0';
        return FALSE;
    }

    DWORD nType = 0;
    cbValue -= sizeof(WCHAR);
    if (RegQueryValueExW(hKey, pwzValueName, 0, &nType, (PBYTE)pwzValue, &cbValue)
        != NO_ERROR || nType != REG_SZ) {

        RegCloseKey(hKey);
        goto abort;
    }

    RegCloseKey(hKey);

    cbValue /= sizeof(WCHAR);
    pwzValue[cbValue] = L'\0';

    return TRUE;
}

static BOOLEAN SetKeyAndValue(HKEY hRootKey,
                              PWCHAR pwzKey, PWCHAR pwzSubkey,
                              PWCHAR pwzValueName, PWCHAR pwzValue)
{
    HKEY        hKey;
    WCHAR       wzKey[256];
    HRESULT     hr;

    hr = StringCchCopyW(wzKey, ARRAYSIZE(wzKey), pwzKey);
    if (FAILED(hr)) {
        return FALSE;
    }

    if (pwzSubkey != NULL) {
        hr = StringCchCatW(wzKey, ARRAYSIZE(wzKey), L"\\");
        if (FAILED(hr)) {
            return FALSE;
        }
        hr = StringCchCatW(wzKey, ARRAYSIZE(wzKey), pwzSubkey);
        if (FAILED(hr)) {
            return FALSE;
        }
    }

    if (RegCreateKeyExW(hRootKey, wzKey, 0, NULL, REG_OPTION_NON_VOLATILE,
                        KEY_ALL_ACCESS, NULL, &hKey, NULL) != ERROR_SUCCESS) {
        return FALSE;
    }

    if (pwzValue != NULL) {
        RegSetValueExW(hKey, pwzValueName, 0, REG_SZ,
                       (BYTE *)pwzValue, (DWORD)wcssize(pwzValue));
    }
    RegCloseKey(hKey);
    return TRUE;
}

static BOOLEAN SetKeyAndValue(HKEY hRootKey,
                              PWCHAR pwzKey, PWCHAR pwzSubkey,
                              PWCHAR pwzValueName,
                              PBYTE pbData, ULONG cbData)
{
    HKEY        hKey;
    WCHAR       wzKey[256];
    HRESULT     hr;

    hr = StringCchCopyW(wzKey, ARRAYSIZE(wzKey), pwzKey);
    if (FAILED(hr)) {
        return FALSE;
    }

    if (pwzSubkey != NULL) {
        hr = StringCchCatW(wzKey, ARRAYSIZE(wzKey), L"\\");
        if (FAILED(hr)) {
            return FALSE;
        }
        hr = StringCchCatW(wzKey, ARRAYSIZE(wzKey), pwzSubkey);
        if (FAILED(hr)) {
            return FALSE;
        }
    }

    if (RegCreateKeyExW(hRootKey, wzKey, 0, NULL, REG_OPTION_NON_VOLATILE,
                        KEY_ALL_ACCESS, NULL, &hKey, NULL) != ERROR_SUCCESS) {
        return FALSE;
    }

    if (pbData != NULL) {
        RegSetValueExW(hKey, pwzValueName, 0, REG_BINARY, pbData, cbData);
    }
    RegCloseKey(hKey);
    return TRUE;
}

static void Register(void)
{

    WCHAR wzModule[256];
    WCHAR wzName[256];
    WCHAR wzValue[256];
    WCHAR wzClass[48];
    WCHAR wzKey[256];
    PWCHAR pwz;
    HRESULT hr;

    BYTE rgEveryone[] = {
        0x01,0x00,0x04,0x80,0x34,0x00,0x00,0x00,0x50,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
        0x14,0x00,0x00,0x00,0x02,0x00,0x20,0x00,0x01,0x00,0x00,0x00,0x00,0x00,0x18,0x00,
        0x01,0x00,0x00,0x00,0x01,0x01,0x00,0x00,0x00,0x00,0x00,0x01,0x00,0x00,0x00,0x00,
        0x00,0x00,0x00,0x00,0x01,0x05,0x00,0x00,0x00,0x00,0x00,0x05,0x15,0x00,0x00,0x00,
        0xa0,0x65,0xcf,0x7e,0x78,0x4b,0x9b,0x5f,0xe7,0x7c,0x87,0x70,0x32,0x7f,0x00,0x00,
        0x01,0x05,0x00,0x00,0x00,0x00,0x00,0x05,0x15,0x00,0x00,0x00,0xa0,0x65,0xcf,0x7e,
        0x78,0x4b,0x9b,0x5f,0xe7,0x7c,0x87,0x70,0x32,0x7f,0x00,0x00
    };

    GetModuleFileNameW(NULL, wzModule, sizeof(wzModule)/sizeof(WCHAR));
    if ((pwz = wcsrchr(wzModule, '\\')) != NULL) {
        hr = StringCchCopyW(wzName, ARRAYSIZE(wzName), pwz + 1);
    }
    else if ((pwz = wcsrchr(wzModule, ':')) != NULL) {
        hr = StringCchCopyW(wzName, ARRAYSIZE(wzName), pwz + 1);
    }
    else {
        hr = StringCchCopyW(wzName, ARRAYSIZE(wzName), wzModule);
    }
    CheckResult(hr, "IPing_DllRegisterServer");

    // printf("Server: %ls / %ls\n", wzModule, wzName);

    StringFromGUID2(CLSID_NetPingObject, wzClass, ARRAYSIZE(wzClass));
    // printf("  Class: %ls\n", wzClass);
    hr = StringCchCopyW(wzKey, ARRAYSIZE(wzKey), L"CLSID\\");
    CheckResult(hr, "IPing_DllRegisterServer");
    hr = StringCchCatW(wzKey, ARRAYSIZE(wzKey), wzClass);
    CheckResult(hr, "IPing_DllRegisterServer");

    SetKeyAndValue(HKEY_CLASSES_ROOT, wzKey, NULL, NULL, L"COM Ping Network Server");
    hr = StringCchPrintfW(wzValue, ARRAYSIZE(wzValue), L"%ls /s", wzModule);
    CheckResult(hr, "IPing_DllRegisterServer");
    SetKeyAndValue(HKEY_CLASSES_ROOT, wzKey, L"LocalServer32", NULL, wzValue);
    SetKeyAndValue(HKEY_CLASSES_ROOT, wzKey, L"LaunchPermission", NULL, L"Y");
    SetKeyAndValue(HKEY_CLASSES_ROOT, wzKey, NULL, L"AppID", wzClass);

    hr = StringCchCopyW(wzKey, ARRAYSIZE(wzKey), L"AppID\\");
    CheckResult(hr, "IPing_DllRegisterServer");
    hr = StringCchCatW(wzKey, ARRAYSIZE(wzKey), wzClass);
    CheckResult(hr, "IPing_DllRegisterServer");
    SetKeyAndValue(HKEY_CLASSES_ROOT, wzKey, NULL, NULL, L"COM Ping Network Server");
    SetKeyAndValue(HKEY_CLASSES_ROOT, wzKey, NULL, L"RunAs", L"Interactive User");
    SetKeyAndValue(HKEY_CLASSES_ROOT, wzKey, NULL, L"AccessPermission",
                   rgEveryone, sizeof(rgEveryone));

    hr = StringCchCopyW(wzKey, ARRAYSIZE(wzKey), L"AppID\\");
    CheckResult(hr, "IPing_DllRegisterServer");
    hr = StringCchCatW(wzKey, ARRAYSIZE(wzKey), wzName);
    CheckResult(hr, "IPing_DllRegisterServer");

    SetKeyAndValue(HKEY_CLASSES_ROOT, wzKey, NULL, L"AppID", wzClass);

    /////////////////////////////////////////////////// Register Proxy & Stub.
    //
    iping_DllRegisterServer();
    CheckResult(hr, "IPing_DllRegisterServer");

    //////////////////////////////////////////////// Register Processor Speed.
    //
    DWORD   cycles = 0;

    hr = StringCchCopyW(wzKey, ARRAYSIZE(wzKey), L"Software\\Microsoft\\Detours\\ProcessorCycles");
    CheckResult(hr, "IPing_DllRegisterServer");

    if (GetKeyValue(HKEY_LOCAL_MACHINE, wzKey, NULL, wzValue, sizeof(wzValue))) {
        cycles = _wtoi(wzValue);

        printf("[Recorded Cycles/Second: %ld]\n", cycles);
    }

    if (cycles  < 10000) {
        LONGLONG llBeg;
        LONGLONG llEnd;

        printf("[Calibrating Processors...]\r");

        LARGE_INTEGER liBeg;
        LARGE_INTEGER liEnd;
        LARGE_INTEGER liBrk;
        LARGE_INTEGER liFrq;

        QueryPerformanceFrequency(&liFrq);
        QueryPerformanceCounter(&liBeg);
        llBeg = GetTimeStamp();
        liBrk.QuadPart = liBeg.QuadPart + liFrq.QuadPart * 5;
        do {
            QueryPerformanceCounter(&liEnd);
            llEnd = GetTimeStamp();
        } while (liEnd.QuadPart < liBrk.QuadPart);

        double secs = (double)(liEnd.QuadPart - liBeg.QuadPart) / (double)liFrq.QuadPart;
        double clks = (double)(llEnd - llBeg);
        double cycs = clks / secs;

        cycles = (DWORD)cycs;
        printf("[Measured Cycles/Second: %ld]          \n", cycles);

        hr = StringCchPrintfW(wzValue, ARRAYSIZE(wzValue), L"%d", cycles);
        CheckResult(hr, "IPing_DllRegisterServer");

        SetKeyAndValue(HKEY_LOCAL_MACHINE, wzKey, NULL, NULL, wzValue);
    }
}

void Unregister(void)
{
    ///////////////////////////////////////////////// Unregister Proxy & Stub.
    //
    HRESULT hr = iping_DllUnregisterServer();
    if (FAILED(hr)) {
        CheckResult(hr, "IPing_DllUnregisterServer");
    }
}

//////////////////////////////////////////////////////////////////////////////
//
HRESULT GetClockInfo(LONGLONG *pllCyclesPerSecond)
{
    WCHAR   wzKey[512];
    WCHAR   wzValue[128];
    LONG    cbValue;
    HRESULT hr;

    ////////////////////////////////////////////////////////// Check Registry.

    cbValue = sizeof(wzValue);
    hr = StringCchCopyW(wzKey, ARRAYSIZE(wzKey), L"Software\\Microsoft\\Detours\\ProcessorCycles");
    CheckResult(hr, "GetClockInfo");

    if (RegQueryValueW(HKEY_LOCAL_MACHINE, wzKey, wzValue, &cbValue) == NO_ERROR) {
        *pllCyclesPerSecond = _wtoi(wzValue);
        return S_OK;
    }
    *pllCyclesPerSecond = 1000000;
    return E_FAIL;
}

///////////////////////////////////////////////////////// CNetPingFactory.
//
LONG    CNetPingFactory::s_nObjects = 0;
LONG    CNetPingFactory::s_nLocks = 0;
HANDLE  CNetPingFactory::s_hevtDone = NULL;

CNetPingFactory::CNetPingFactory()
{
    m_cRef = 1;
}


CNetPingFactory::~CNetPingFactory()
{
    m_cRef = 0;
}

ULONG CNetPingFactory::AddRef(void)
{
    return InterlockedIncrement(&m_cRef);
}

ULONG CNetPingFactory::Release(void)
{
    if (InterlockedDecrement(&m_cRef) == 0) {
        delete this;
        return 0;
    }
    return 1;
}

HRESULT CNetPingFactory::InitSystem(VOID)
{
    s_nObjects = 0;
    s_nLocks = 0;

    s_hevtDone = CreateEvent(NULL, FALSE, FALSE, NULL);
    if (s_hevtDone == NULL) {
        HRESULT hr = HRESULT_FROM_WIN32(GetLastError());
        CheckResult(hr, "Server: CreateEvent");
        exit(hr);
    }

    return S_OK;
}

HRESULT CNetPingFactory::FiniSystem(VOID)
{
    if (s_hevtDone != NULL) {
        CloseHandle(s_hevtDone);
        s_hevtDone = NULL;
    }
    return S_OK;
}


HRESULT CNetPingFactory::InitObject(VOID)
{
    InterlockedIncrement(&s_nObjects);
    return S_OK;
}

HRESULT CNetPingFactory::FiniObject(VOID)
{
    if (InterlockedDecrement(&s_nObjects) == 0 && s_nLocks == 0)
        SetEvent(s_hevtDone);
    return S_OK;
}

HRESULT CNetPingFactory::Lock(BOOL fLock)
{
    if (fLock) {
        InterlockedIncrement(&s_nLocks);
    }

    else {
        if (InterlockedDecrement(&s_nLocks) == 0 && s_nObjects == 0)
            SetEvent(s_hevtDone);
    }
    return S_OK;
}

HRESULT CNetPingFactory::Wait(VOID)
{
    DWORD dwWaitResult;
    MSG msg;

    for (;;) {
        dwWaitResult = MsgWaitForMultipleObjects(1, &s_hevtDone,
                                                 FALSE, INFINITE,
                                                 QS_ALLINPUT);

        if (dwWaitResult == WAIT_OBJECT_0) {
            ResetEvent(s_hevtDone);
            break;
        }

        while (PeekMessage(&msg, NULL, 0, 0, PM_REMOVE)) {
            TranslateMessage(&msg);
            DispatchMessage(&msg);
        }
    }
    return S_OK;
}

STDMETHODIMP CNetPingFactory::QueryInterface(REFIID riid, void** ppv)
{
    if (ppv == NULL) {
        return E_INVALIDARG;
    }
    if (riid == IID_IClassFactory || riid == IID_IUnknown) {
        *ppv = (IClassFactory *) this;
        AddRef();
        return S_OK;
    }
    *ppv = NULL;
    return E_NOINTERFACE;
}

HRESULT CNetPingFactory::LockServer (BOOL fLock)
{
    return Lock(fLock);
}

STDMETHODIMP CNetPingFactory::CreateInstance(LPUNKNOWN punkOuter,
                                             REFIID riid, void** ppv)
{
    LPUNKNOWN   punk;
    HRESULT     hr;

    *ppv = NULL;

    if (punkOuter != NULL) {
        return CLASS_E_NOAGGREGATION;
    }

    printf("  Server: IClassFactory:CreateInstance\n");

    punk = new CNetPingObject;
    if (punk == NULL) {
        return E_OUTOFMEMORY;
    }

    hr = punk->QueryInterface(riid, ppv);
    punk->Release();
    return hr;
}

/////////////////////////////////////////////////////////////// CNetPingObject.
//
CNetPingObject::CNetPingObject()
{
    m_cRef = 1;
    m_cbLast = ~0u;
    m_cbOut = 2;
    CNetPingFactory::InitObject();
}

CNetPingObject::~CNetPingObject()
{
    CNetPingFactory::FiniObject();
}

STDMETHODIMP CNetPingObject::QueryInterface(REFIID riid, void** ppv)
{
    if (ppv == NULL) {
        return E_INVALIDARG;
    }
    if (riid == IID_IUnknown || riid == IID_IPing) {
        *ppv = (IPing *) this;
        AddRef();
        return S_OK;
    }
    *ppv = NULL;
    return E_NOINTERFACE;
}

STDMETHODIMP_(ULONG) CNetPingObject::AddRef(void)
{
    return InterlockedIncrement(&m_cRef);
}

STDMETHODIMP_(ULONG) CNetPingObject::Release(void)
{
    if (InterlockedDecrement(&m_cRef) == 0) {
        delete this;
        return 0;
    }
    return 1;
}

STDMETHODIMP CNetPingObject::Ping()
{
    return S_OK;
}

STDMETHODIMP CNetPingObject::PingToServer(LPSTR pszString)
{
    (void)pszString;
    return S_OK;
}

STDMETHODIMP CNetPingObject::PingToClient(LPSTR *ppszString)
{
    LPSTR pszString = (LPSTR)CoTaskMemAlloc(m_cbOut);
    if (pszString == NULL) {
        return E_OUTOFMEMORY;
    }

    CopyMemory(pszString, g_pBuffer, m_cbOut);
    *ppszString = pszString;

    return S_OK;
}

STDMETHODIMP CNetPingObject::PingToClientSize(ULONG cbOut)
{
    if (cbOut < 1) {
        return E_INVALIDARG;
    }

    InitializeString((LPSTR)g_pBuffer, cbOut);
    m_cbOut = cbOut;
    return S_OK;
}

//////////////////////////////////////////////////////////////////////////////
//
class CSampleRecord
{
  public:
    DOUBLE      m_dTime;
    FILETIME    m_nWhen;
    LONG        m_cbToClient;
    LONG        m_cbToServer;
    DOUBLE      m_dDcom;
    DOUBLE      m_dRpc;
    DOUBLE      m_dUdp;
    DOUBLE      m_dNet;

  protected:
    static LONG s_cbToClient;
    static LONG s_cbToServer;

  public:
    CSampleRecord();
    CSampleRecord(IPing *pIPing, LONG cbToClient, LONG cbToServer);

    HRESULT     Measure(IPing *pIPing, LONG cbToClient, LONG cbToServer);
    HRESULT     Write();

    double      GetTime()           { return m_dTime; }
    FILETIME    GetWhen()           { return m_nWhen; }
    LONG        GetToClient()       { return m_cbToClient; }
    LONG        GetToServer()       { return m_cbToServer; }

};

//////////////////////////////////////////////////////////////////////////////
//
LONG CSampleRecord::s_cbToClient = 0;
LONG CSampleRecord::s_cbToServer = 0;

//////////////////////////////////////////////////////////////////////////////
//
CSampleRecord::CSampleRecord()
{
    m_dTime = 0;
    m_dDcom = 0;
    m_dRpc = 0;
    m_dUdp = 0;
    m_dNet = 0;
}

CSampleRecord::CSampleRecord(IPing *pIPing, LONG cbToClient, LONG cbToServer)
{
    Measure(pIPing, cbToClient, cbToServer);
}

HRESULT CSampleRecord::Measure(IPing *pIPing, LONG cbToClient, LONG cbToServer)
{
    HRESULT hr;
    LONGLONG llBeg;
    LONGLONG llEnd;

    GetSystemTimeAsFileTime(&m_nWhen);
    m_cbToClient = cbToClient;
    m_cbToServer = cbToServer;

    if (cbToClient == 0 && cbToServer == 0) {
        llBeg = GetTimeStamp();
        hr = Catch_IPing_Ping(pIPing);
        llEnd = GetTimeStamp();
    }
    else if (cbToClient) {
        if (s_cbToClient != cbToClient) {
            hr = pIPing->PingToClientSize(cbToClient);
            s_cbToClient = cbToClient;
        }

        LPSTR pszString = NULL;

        llBeg = GetTimeStamp();
        hr = Catch_IPing_PingToClient(pIPing, &pszString);
        llEnd = GetTimeStamp();

        if (pszString) {
            LONG cb = (LONG)strlen(pszString) + 1;
            ASSERT(cb == cbToClient);
            CoTaskMemFree(pszString);
            pszString = NULL;
        }
    }
    else {
        if (s_cbToServer != cbToServer) {
            InitializeString((LPSTR)g_pBuffer, cbToServer);
            s_cbToServer = cbToServer;
        }

        llBeg = GetTimeStamp();
        hr = Catch_IPing_PingToServer(pIPing, (LPSTR)g_pBuffer);
        llEnd = GetTimeStamp();
    }

    if (FAILED(hr)) {
        printf(";; Operation failed: %08lx\n", hr);
        exit(999);
    }

    if (g_fSummarize) {
        SummarizeCycles();
        m_dDcom = (double)s_rllCycles[E_DCOM] * g_dMsPerCycle;
        m_dRpc = (double)s_rllCycles[E_RPC] * g_dMsPerCycle;
        m_dUdp = (double)s_rllCycles[E_UDP] * g_dMsPerCycle;
        m_dNet = (double)s_rllCycles[E_NET] * g_dMsPerCycle;
    }

    m_dTime = (double)(llEnd - llBeg) * g_dMsPerCycle;

    return S_OK;
}

HRESULT CSampleRecord::Write()
{
    SYSTEMTIME  st;
    FILETIME ft;

    FileTimeToLocalFileTime(&m_nWhen, &ft);
    FileTimeToSystemTime(&ft, &st);

    printf("%02d/%02d %2d:%02d:%02d %6ld %ld %6.3f [ %6.3f %6.3f %6.3f %6.3f ]\n",
           st.wMonth, st.wDay, st.wHour, st.wMinute, st.wSecond,
           m_cbToClient, m_cbToServer, m_dTime,
           m_dDcom, m_dRpc, m_dUdp, m_dNet);

    return S_OK;
}

//////////////////////////////////////////////////////////////////////////////
//
double NetTest(HKEY hNetwork, IPing *pIPing,
               BOOLEAN fToClient, LONG cbPacket, LONG nCount)
{
    //////////////////////////////////////////////////////////////////// ToClient.
    //
    HRESULT hr;
    double msAvg = 0.0;
    double msMin = 1.0e12;
    double msMax = 0.0;
    ULONG nMax = 999;
    ULONG nMin = 999;

    if (fToClient) {
        printf(">Client %6ld %6ld ", cbPacket, nCount);
    }
    else {
        printf(">Server %6ld %6ld ", cbPacket, nCount);
    }

    for (LONG n = 0; n < nCount; n++) {
        double ms;

        if (fToClient) {
            ms = CSampleRecord(pIPing, cbPacket, 0).GetTime();
        }
        else {
            ms = CSampleRecord(pIPing, 0, cbPacket).GetTime();
        }

        if (ms < 0) {
            break;
        }

        if (msMin > ms) {
            msMin = ms;
            nMin = n;
        }
        if (msMax < ms) {
            msMax = ms;
            nMax = n;
        }
        msAvg += ms;
    }

    if (nCount) {
        msAvg /= nCount;
    }

    if (cbPacket == 0) {
        g_dLatency = msMin;
    }

    double mbps = (double)cbPacket / msMin;
    mbps *= 8.0 * 1000.0 / 1024.0 / 1024.0;

    double mbps2 = (double)cbPacket / (msMin - g_dLatency);
    mbps2 *= 8.0 * 1000.0 / 1024.0 / 1024.0;
    if (cbPacket == 0) {
        mbps2 = 0;
    }

    if (hNetwork != NULL) {
        WCHAR wzKey[64];
        WCHAR wzLatency[64];

        if (fToClient) {
            hr = StringCchPrintfW(wzKey, ARRAYSIZE(wzKey), L"ToClient\\%d", cbPacket);
            CheckResult(hr, "NetTest");
        }
        else {
            hr = StringCchPrintfW(wzKey, ARRAYSIZE(wzKey), L"ToServer\\%d", cbPacket);
            CheckResult(hr, "NetTest");
        }
        hr = StringCchPrintfW(wzLatency, ARRAYSIZE(wzLatency), L"%I64d", msAvg);
        CheckResult(hr, "NetTest");

        RegSetValueW(hNetwork, wzKey, REG_SZ, wzLatency, (DWORD)wcssize(wzLatency));
    }

    printf("%8.3f %8.3f %8.3f %9.4f %8.3f %9.4f%3ld\n",
           msMin,
           msAvg,
           msMax,
           mbps,
           msMin - g_dLatency,
           mbps2,
           nMax);
    return mbps;
}

//////////////////////////////////////////////////////////////////////// main.

static WCHAR    wzServers[32][64];
static int      nServers = 0;

void Sample_Fixed(IPing *pIPing)
{
    CSampleRecord csrRecords[512];
    LONG nRecords = 0;
    HRESULT hr;

    double dAvg = 0;
    double dMin = 500000.0;
    double dMax = 0.0;
    double dMinDcom = dMin;
    double dMinRpc = dMin;
    double dMinUdp = dMin;
    double dMinNet = dMin;

    for (int i = 0; i < 512; i++) {
        CSampleRecord& csr = csrRecords[nRecords++];

        hr = csr.Measure(pIPing, g_nFixedToClient, g_nFixedToServer);
        double d = csr.GetTime();
        if (dMin > d) {
            dMin = d;
        }
        if (dMax < d) {
            dMax = d;
        }
        if (dMinDcom > csr.m_dDcom) {
            dMinDcom = csr.m_dDcom;
        }
        if (dMinRpc > csr.m_dRpc) {
            dMinRpc = csr.m_dRpc;
        }
        if (dMinUdp > csr.m_dUdp) {
            dMinUdp = csr.m_dUdp;
        }
        if (dMinNet > csr.m_dNet) {
            dMinNet = csr.m_dNet;
        }
        dAvg += d;
    }

    dAvg /= 512;
    printf("size: %ld, min: %.3f, max: %.3f avg: %.3f [ %8.3f %8.3f %8.3f %8.3f ]\n",
           g_nFixedToClient, dMin, dMax, dAvg, dMinDcom, dMinRpc, dMinUdp, dMinNet);
    for (int n = 0; n < nRecords; n++) {
        csrRecords[n].Write();
    }
}

void Sample_Simple(IPing *pIPing)
{
    CSampleRecord csrRecords[512];
    LONG nRecords = 0;
    HRESULT hr;

    for (int cb = 0; cb < 64000; cb = cb ? cb << 1 : 32) {
        double n[5];
        int i = 0;

        for (; i < 5; i++) {
            CSampleRecord& csr = csrRecords[nRecords++];

            hr = csr.Measure(pIPing, cb, 0);
            n[i] = csr.GetTime();
        }

        double nAvg = 0;
        double nApx = 0;
        double nMin = n[0];
        double nMax = n[0];

        for (i = 0; i < 5; i++) {
            if (nMin > n[i]) {
                nMin = n[i];
            }
            if (nMax < n[i]) {
                nMax = n[i];
            }
            nAvg += n[i];
        }
        nApx = nAvg - nMax;
        nAvg /= 5;
        nApx /= 4;
        printf("min: %8.3f ms (%6d) %7.3f%7.3f%7.3f%7.3f%7.3f:%8.3f%8.3f\n",
               nMin, cb, n[0], n[1], n[2], n[3], n[4], nAvg, nApx);
    }
    for (int n = 0; n < nRecords; n++) {
        csrRecords[n].Write();
    }
}

void Sample_More(IPing *pIPing)
{
    CSampleRecord csrRecords[64];
    LONG nRecords = 0;

    for (int cb = 0; cb < 64000; cb = cb ? cb << 1 : 32) {
        int i = 0;
        for (; i < 64; i++) {
            CSampleRecord& csr = csrRecords[nRecords++];

            csr.Measure(pIPing, cb, 0);
        }

        double nAvg = 0;
        double nMin = csrRecords[0].GetTime();
        double nMax = csrRecords[0].GetTime();

        for (i = 0; i < 64; i++) {
            double n = csrRecords[i].GetTime();

            if (nMin > n) {
                nMin = n;
            }
            if (nMax < n) {
                nMax = n;
            }
            nAvg += n;
        }
        nAvg /= i;
        printf("min: %8.3f ms (%6d) : %8.3f %8.3f\n",
               nMin, cb, nMax, nAvg);

        for (int n = 0; n < nRecords; n++) {
            csrRecords[n].Write();
        }
        nRecords = 0;
    }
}

void Sample_Less(IPing *pIPing)
{
    CSampleRecord csrRecords[16];
    LONG nRecords = 0;

    for (int cb = 0; cb < 64000; cb = cb ? cb << 1 : 16) {
        int i = 0;
        for (; i < 16; i++) {
            CSampleRecord& csr = csrRecords[nRecords++];

            csr.Measure(pIPing, cb, 0);
        }

        double nAvg = 0;
        double nMin = csrRecords[0].GetTime();
        double nMax = csrRecords[0].GetTime();

        for (i = 0; i < 16; i++) {
            double n = csrRecords[i].GetTime();

            if (nMin > n) {
                nMin = n;
            }
            if (nMax < n) {
                nMax = n;
            }
            nAvg += n;
        }
        nAvg /= i;
        printf("min: %8.3f ms (%6d) : %8.3f %8.3f\n",
               nMin, cb, nMax, nAvg);

        for (int n = 0; n < nRecords; n++) {
            csrRecords[n].Write();
        }
        nRecords = 0;
    }
}

void Sample_Profile(IPing *pIPing)
{
    CSampleRecord csrRecords[64];

    double dbZero = 0;

    printf("\nPacket_Size_ Min_Latency Max_Latency Avg_Latency "
           "Relative_Bnd ___Bandwidth\n");

    for (int cb = 0; cb < 256 * 1024;) {
        int n = 0;
        for (; n < 64; n++) {
            CSampleRecord& csr = csrRecords[n];
            csr.Measure(pIPing, cb, 0);
        }

        double dbAvg = 0;
        double dbMin = csrRecords[0].GetTime();
        double dbMax = csrRecords[0].GetTime();
        LONG nMin = 0;
        LONG nMax = 0;

        for (n = 0; n < 64; n++) {
            double db = csrRecords[n].GetTime();

            if (dbMin > db) {
                dbMin = db;
                nMin = n;
            }
            if (dbMax < db) {
                dbMax = db;
                nMax = n;
            }
            dbAvg += db;
        }
        dbAvg /= n;
        if (cb == 0) {
            dbZero = dbMin;
        }

        double dbBnd = 0;
        if (dbMin > dbZero) {
            dbBnd = ((8 * cb) * 1000.0) / (1024 * 1024);
            dbBnd /= dbMin - dbZero;
        }
        double dbReal = ((8 * cb) * 1000.0) / (1024 * 1024) / dbMin;

        printf("%6d bytes %9.3fms %9.3fms %9.3fms %8.3fMbps %8.3fMbps\r",
               cb, dbMin, dbMax, dbAvg, dbBnd, dbReal);

        csrRecords[nMin].Write();

        if (cb < 2048) {
            cb++;
        }
        else if (cb < 4096) {
            cb += 2;
        }
        else if (cb < 8192) {
            cb += 8;
        }
        else if (cb < 16384) {
            cb += 32;
        }
        else {
            cb += 128;
        }
    }
}

//////////////////////////////////////////////////////////////////////////////
//
class CInit
{
  public:
    CInit(HINSTANCE hinst)
        {
            m_hinst = hinst;

            AllocConsole();

            // initialize COM for free-threading
            HRESULT hr = CoInitializeEx(NULL, COINIT_MULTITHREADED);
            if (FAILED(hr)) {
                CheckResult(hr, "CoInitializeEx");
                exit(hr);
            }

            ULONG ul = iping_DllMain(m_hinst, DLL_PROCESS_ATTACH, NULL);
            ASSERT(ul);
        }

    ~CInit()
        {
            ULONG ul = iping_DllMain(m_hinst, DLL_PROCESS_DETACH, NULL);
            ASSERT(ul);

            CoUninitialize();
        }

  private:
    HINSTANCE   m_hinst;
};

class CInitStub
{
  public:
    CInitStub()
        {
            m_dwRegister = ~0u;

            IClassFactory *pClassFactory = NULL;
            HRESULT hr = iping_DllGetClassObject(IID_IPing,
                                                 IID_IUnknown,
                                                 (void **)&pClassFactory);
            if (FAILED(hr)) {
                CheckResult(hr, "IPing_DllGetClassObject");
                ASSERT(SUCCEEDED(hr));
            }

            if (pClassFactory) {
                hr = CoRegisterClassObject(IID_IPing,
                                           pClassFactory,
                                           CLSCTX_SERVER,
                                           REGCLS_MULTIPLEUSE,
                                           &m_dwRegister);
                if (FAILED(hr)) {
                    ASSERT(SUCCEEDED(hr));
                    CheckResult(hr, "CoRegisterClassObject(IID_IPing)\n");
                }
                pClassFactory->Release();
                pClassFactory = NULL;
            }
        }

    ~CInitStub()
        {
            if (m_dwRegister != ~0u) {
                CoRevokeClassObject(m_dwRegister);
                m_dwRegister = ~0u;
            }
        }

  private:
    DWORD       m_dwRegister;
};

///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
//
int __cdecl main(void)
{
    CInit cinit(GetModuleHandle(NULL));
    int argc;
    WCHAR **argv = CommandLineToArgvW(GetCommandLineW(), &argc);

    HRESULT hr;
    BOOLEAN fUnreg = FALSE;
    BOOLEAN fNeedHelp = FALSE;
    BOOLEAN fServer = FALSE;
    BOOLEAN fLong = FALSE;
    BOOLEAN fProfile = FALSE;
    BOOLEAN fInstrument = TRUE;
    BOOLEAN fFixed = FALSE;

    s_nThread = GetCurrentThreadId();

    printf("Ping Network Server: [" __DATE__ " " __TIME__ "]\n");
    int arg = 1;
    for (; arg < argc; arg++) {
        if (argv[arg][0] == '-' || argv[arg][0] == '/') {
            WCHAR *argn = argv[arg] + 1;
            WCHAR *argp = argn;
            while (*argp && *argp != ':') {
                argp++;
            }
            if (*argp == ':') {
                *argp++ = '\0';
            }

            switch (argn[0]) {

              case 'f':                                 // Fixed
              case 'F':
                fFixed = TRUE;
                g_nFixedToClient = _wtoi(argp);
                g_nFixedToServer = 0;
                break;

              case 'i':
              case 'I':                                 // Instrument
                fInstrument = !fInstrument;
                break;

              case 'n':                                 // Null
              case 'N':
                fFixed = TRUE;
                g_nFixedToClient = g_nFixedToServer = 0;
                break;

              case 'l':                                 // Long-term loop
              case 'L':
                fLong = !fLong;
                break;

              case 'p':                                 // Profile Network
              case 'P':
                fProfile = !fProfile;
                break;

              case 's':                                 // Server
              case 'S':
                fServer = !fServer;
                break;

              case 'u':                                 // Unregister
              case 'U':
                fUnreg = !fUnreg;
                break;

              case 'x':                                 // Xtract Data
              case 'X':
                g_fSummarize = !g_fSummarize;
                break;

              case '?':                                 // Help
                fNeedHelp = TRUE;
                break;

              case '\0':                                // Local Host
                hr = StringCchCopyW(wzServers[nServers++], ARRAYSIZE(wzServers[nServers++]),
                               L"localhost");
                if (FAILED(hr)) {
                    return 900;
                }
                ASSERT(nServers <= 32);
                break;

              default:
                fNeedHelp = TRUE;
                printf("Bad argument: %ls\n", argv[arg]);
                break;
            }
        }
        else {
            hr = StringCchCopyW(wzServers[nServers++], ARRAYSIZE(wzServers[nServers++]), argv[arg]);
            if (FAILED(hr)) {
                return 900;
            }
            ASSERT(nServers <= 32);
        }
    }
    if (argc == 1 || (nServers == 0 && !fUnreg && !fServer)) {
        fNeedHelp = TRUE;
    }

    if (fNeedHelp) {
        printf("Usage:\n"
               "    cping [options] [hosts]  ..or.. cping [options] /s\n"
               "Options:\n"
               "    /u      : Unregister.\n"
               "    /s      : Act as a server, waiting for clients.\n"
               "    /?      : Display this help screen.\n"
               "Client Options:\n"
               "    /l      : Long-term loop test.                (Default: %3s)\n"
               "    /p      : Profile test.                       (Default: %3s)\n"
               "    /n      : Null (0 length) test.               (Default: Off)\n"
               "    /f:size : Fixed sized packets.                (Default: %3s)\n"
               "    /x      : Xtract detailed DCOM/RPC/NET data.  (Default: %3s)\n"
               "    /i      : Toggle instrumentation.             (Default: %3s)\n",
               fLong        ? "On" : "Off",
               fProfile     ? "On" : "Off",
               fFixed       ? "On" : "Off",
               g_fSummarize ? "Off" : "Off",
               fInstrument  ? "On" : "Off");

        exit(1);
    }

    //////////////////////////////////////////////////////////////////////////
    if (fUnreg) {
        Unregister();
    }
    else {
        //////////////////////////////////////////////////////////////////////////////
        //
        CInitStub cinitstub;

        // Register in the registry.
        Register();

        if (fInstrument) {
            RerouteEntryPoints();
        }

        LONGLONG llCycles;
        hr = GetClockInfo(&llCycles);
        ASSERT(SUCCEEDED(hr));
        g_dCyclesPerSecond = (double)llCycles;
        g_dMsPerCycle = (double)1000.0 / (double)llCycles;

        g_pBuffer = CoTaskMemAlloc(g_cbBufferMax);
        ASSERT(g_pBuffer != NULL);

        if (fServer) {
            // register the class-object with OLE
            CNetPingFactory::InitSystem();

            CNetPingFactory *pClassFactory = new CNetPingFactory;

            printf("Registering.\n");
            DWORD dwRegister;
            hr = CoRegisterClassObject(CLSID_NetPingObject, pClassFactory,
                                       CLSCTX_SERVER, REGCLS_MULTIPLEUSE, &dwRegister);
            printf("Releasing Registered.\n");
            pClassFactory->Release();
            if (FAILED(hr)) {
                CheckResult(hr, "Server: CoRegisterClassObject");
                ASSERT(SUCCEEDED(hr));
            }

            printf("  Server: Waiting   <<<Press Ctrl-C to stop.>>>\n");

            while (fServer) {
                CNetPingFactory::Wait();
            }

            hr = CoRevokeClassObject(dwRegister);
            if (FAILED(hr)) {
                CheckResult(hr, "Server: CoRevokeClassObject");
                ASSERT(SUCCEEDED(hr));
            }

            CNetPingFactory::FiniSystem();
        }
        else if (nServers) {
            LONGLONG llBeg;
            LONGLONG llEnd;
            COSERVERINFO csi;
            MULTI_QI mq;

            //////////////////////////////////////////////////////////////////
            //
            printf("Processor Speed: %.0f MHz\n", g_dCyclesPerSecond / 1000000.0);

            DWORD dwSize = ARRAYSIZE(g_wzClientName);
            GetComputerNameW(g_wzClientName, &dwSize);

            printf(";;; %ls - %.0f MHz\n",
                    g_wzClientName,
                    g_dCyclesPerSecond / 1000000.0);

            for (int n = 0; n < nServers; n++) {
                if (g_wzServerName[0] == '\\' && g_wzServerName[1] == '\\') {
                    hr = StringCchCopyW(g_wzServerName, ARRAYSIZE(g_wzServerName), wzServers[n] + 2);
                }
                else {
                    hr = StringCchCopyW(g_wzServerName, ARRAYSIZE(g_wzServerName), wzServers[n]);
                }
                CheckResult(hr, "Main");

                printf("Server: %ls->%ls\n", g_wzClientName, g_wzServerName);

                printf(";; %ls %ls\n", g_wzClientName, g_wzServerName);

                ZeroMemory(&csi, sizeof(csi));
                csi.pwszName = wzServers[n];

                // create a remote instance of the object on the argv[1] machine
                mq.pIID = &IID_IPing;
                mq.pItf = NULL;
                mq.hr = S_OK;
                llBeg = GetTimeStamp();
                hr = CoCreateInstanceEx(CLSID_NetPingObject, NULL, CLSCTX_SERVER,
                                        &csi, 1, &mq);
                llEnd = GetTimeStamp();

                printf("  CoCreateInstanceEx: %0.4f seconds (%lu ticks)\n",
                       (double)(llEnd - llBeg)/(double)llCycles,
                       (ULONG)(llEnd - llBeg));

                CheckResult(mq.hr, "CoCreateInstanceEx [mq]");
                CheckResult(hr, "CoCreateInstanceEx");

                if (FAILED(hr)) {
                    CheckResult(hr, "CoCreateInstanceEx");
                    continue;
                }

                //////////////////////////////////////////////////////////////////
                //
                IPing *pIPing = (IPing *)mq.pItf;

                hr = pIPing->Ping();
                if (FAILED(hr)) {
                    CheckResult(hr, "Ping");
                }
                ASSERT(SUCCEEDED(hr));
                hr = Catch_IPing_Ping(pIPing);
                if (FAILED(hr)) {
                    CheckResult(hr, "Ping");
                }
                ASSERT(SUCCEEDED(hr));
                ZeroCycles();

                if (fFixed) {
                    Sample_Fixed(pIPing);
                }
                else if (fProfile) {
                    Sample_Profile(pIPing);
                }
                else {
                    Sample_Simple(pIPing);
                    if (fLong) {
                        for (;;) {
                            Sample_More(pIPing);

                            for (int j = 0; j < 5; j++) {
                                Sleep(20000);
                                Sample_Simple(pIPing);
                            }
                            Sleep(20000);

                            for (int i = 0; i < 18; i++) {
                                Sample_Less(pIPing);

                                for (int j = 0; j < 3; j++) {
                                    Sleep(20000);
                                    Sample_Simple(pIPing);
                                }
                                Sleep(20000);
                            }
                        }
                    }
                }

                pIPing->Release();
            }
        }

        if (g_pBuffer) {
            CoTaskMemFree(g_pBuffer);
            g_pBuffer = NULL;
        }

        Sleep(2);

        if (fInstrument && !g_fSummarize && s_rllCounts[E_Proxy]) {
            printf("::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::"
                   "::::::::::::::::::\n");
            printf(":: Instrumented Cycles:     _____Function Time__  "
                   "________Total Time__ : Count\n");
            LONG n = E_DCOM;
            for (; n < E_MaxValue; n++) {
                s_rllCycles[n] = 0;
                s_rllTotals[n] = 0;
                s_rllCounts[n] = 0;
            }

            for (n = E_MinValue + 1; n < E_MaxValue; n++) {
                DumpCycles(n);
            }

            printf("::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::"
                   "::::::::::::::::::\n");
            printf(":: Protocol Cycles:\n");
            for (n = E_DcomBeg; n <= E_DcomEnd; n++) {
                s_rllCycles[E_DCOM] += s_rllCycles[n];
                s_rllTotals[E_DCOM] += s_rllTotals[n];
                s_rllCounts[E_DCOM] += s_rllCounts[n];
            }
            for (n = E_RpcBeg; n <= E_RpcEnd; n++) {
                s_rllCycles[E_RPC] += s_rllCycles[n];
                s_rllTotals[E_RPC] += s_rllTotals[n];
                s_rllCounts[E_RPC] += s_rllCounts[n];
            }
            for (n = E_UdpBeg; n <= E_UdpEnd; n++) {
                s_rllCycles[E_UDP] += s_rllCycles[n];
                s_rllTotals[E_UDP] += s_rllTotals[n];
                s_rllCounts[E_UDP] += s_rllCounts[n];
            }
            for (n = E_NetBeg; n <= E_NetEnd; n++) {
                s_rllTotals[E_NET] += s_rllCycles[n];
                s_rllCycles[E_NET] += s_rllTotals[n];
                s_rllCounts[E_NET] += s_rllCounts[n];
            }
            DumpCycles(E_DCOM);
            DumpCycles(E_RPC);
            DumpCycles(E_UDP);
            DumpCycles(E_NET);

            printf("::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::"
                   "::::::::::::::::::\n");
            printf(":: Protocol Cycles Per DCOM Call:\n");
            s_rllCycles[E_DCOM] /= s_rllCounts[E_DCOM];
            s_rllCycles[E_RPC] /= s_rllCounts[E_DCOM];
            s_rllCycles[E_UDP] /= s_rllCounts[E_DCOM];
            s_rllCycles[E_NET] /= s_rllCounts[E_DCOM];

            s_rllTotals[E_DCOM] /= s_rllCounts[E_DCOM];
            s_rllTotals[E_RPC] /= s_rllCounts[E_DCOM];
            s_rllTotals[E_UDP] /= s_rllCounts[E_DCOM];
            s_rllTotals[E_NET] /= s_rllCounts[E_DCOM];

            DumpCycles(E_DCOM);
            DumpCycles(E_RPC);
            DumpCycles(E_UDP);
            DumpCycles(E_NET);
        }
    }
    return 0;
}

//
///////////////////////////////////////////////////////////////// End of File.

```

`samples/cping/iping.idl`:

```idl
//////////////////////////////////////////////////////////////////////////////
//
//  Module: iping.idl (cping.exe - COM Ping)
//
//  Microsoft Research Detours Package
//
//  Copyright (c) Microsoft Corporation.  All rights reserved.
//
import "objidl.idl";
import "oaidl.idl";
import "oleidl.idl";


[object, uuid(decdbeef-d1ac-11d1-96bc-00aa00573fb0), pointer_default(unique)]
interface IPing : IUnknown
{
    HRESULT     Ping(void);
    HRESULT     PingToServer([in] LPSTR pszString);
    HRESULT     PingToClient([out] LPSTR *ppszString);
    HRESULT     PingToClientSize([in] ULONG cbOut);
};
//
///////////////////////////////////////////////////////////////// End of File.

```

`samples/disas/Makefile`:

```
##############################################################################
##
##  Makefile for Detours Test Programs.
##
##  Microsoft Research Detours Package
##
##  Copyright (c) Microsoft Corporation.  All rights reserved.
##

!include ..\common.mak

# temporarily disable this test for ARM64
!if "$(DETOURS_TARGET_PROCESSOR)" != "ARM64"

LIBS=$(LIBS) kernel32.lib

all: dirs \
    $(BIND)\disas.exe \
!IF $(DETOURS_SOURCE_BROWSING)==1
    $(OBJD)\disas.bsc
!ENDIF

clean:
    -del *~ *.obj *.sbr *.lst 2>nul
    -del $(BIND)\disas.* 2> nul 
    -rmdir /q /s $(OBJD) 2>nul

realclean: clean
    -rmdir /q /s $(OBJDS) 2>nul

dirs:
    @if not exist $(BIND) mkdir $(BIND) && echo.   Created $(BIND)
    @if not exist $(OBJD) mkdir $(OBJD) && echo.   Created $(OBJD)

!IF "$(DETOURS_TARGET_PROCESSOR)" == "X86"
$(OBJD)\disasm.obj : x86.cpp
    cl $(CFLAGS) /Fe$@ /FAcs /Fa$(OBJD)\x86.lst \
        /Fd$(@R).pdb /Fo$(OBJD)\disasm.obj /c x86.cpp
!ELSEIF "$(DETOURS_TARGET_PROCESSOR)" == "X64"
$(OBJD)\disasm.obj : x64.asm
    $(ASM) $(AFLAGS) /Fo$(OBJD)\disasm.obj /Fl$(OBJD)\x64.lst x64.asm
!ELSEIF "$(DETOURS_TARGET_PROCESSOR)" == "IA64"
$(OBJD)\disasm.obj : ia64.asm
    $(ASM) $(AFLAGS) -o $(OBJD)\disasm.obj ia64.asm
!ELSEIF "$(DETOURS_TARGET_PROCESSOR)" == "ARM"
$(OBJD)\disasm.obj : arm.asm
    $(ASM) $(AFLAGS) -list $(OBJD)\arm.lst -o $(OBJD)\disasm.obj arm.asm
!ENDIF

$(BIND)\disas.obj : disas.cpp

$(BIND)\disas.exe : $(OBJD)\disas.obj $(OBJD)\disasm.obj $(DEPS)
    cl $(CFLAGS) /Fe$@ /FAcs /Fa$(OBJD)\disas.lst /Fd$(@R).pdb \
        $(OBJD)\disas.obj $(OBJD)\disasm.obj \
        /link $(LINKFLAGS) $(LIBS) /subsystem:console /entry:WinMainCRTStartup

$(OBJD)\disas.bsc : $(OBJD)\disas.obj
    bscmake /v /n /o $@ $(OBJD)\disas.sbr

##############################################################################

test: $(BIND)\disas.exe
    $(BIND)\disas.exe

##############################################################################

!else

all:
test:
clean:
realclean:

!endif

################################################################# End of File.

```

`samples/disas/arm.asm`:

```asm
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
;;  Detours Test Program (rlo.asm/disas.exe)
;;
;;  Microsoft Research Detours Package
;;
;;  Copyright (c) Microsoft Corporation.  All rights reserved.
;;

        MACRO
        BREAK
        DCW 0xdefe
        MEND

        AREA    |.text|,ALIGN=2,CODE,READONLY

        AREA    |.text|,CODE,READONLY

        ALIGN 0x1000

        EXPORT  |TestCodes|
|TestCodes|

;        dcw 0xf8df,0xe00e                               ; 94  = -16 = -12 ; 94 ; 98 + e = a6
;        BREAK                                           ; 98  = -14 = -10 ; 98 ; 9c
;        dcw 0xf8df,0xe00a                               ; 9a  = -12 = -8  ; 98 ; 9c + a = a6
;        BREAK                                           ; 9e =  -8 = -4   ; 9c ; a0
;        dcw 0xf8df,0xe002                               ; a0 =  -6 = -2   ; a0 ; a4 + 2 = a6
;        BREAK                                           ; a4 =  -2        ; a4 ; a8
;        movs r2, r0                                     ; a6 <===
;        movs r3, r0                                     ;
;        BREAK
;        BREAK
;
;        ldr     lr,=0xa98765
;        ldr     pc,=0xa98765
;        ldr     pc,=0xa98765
;        ldr     pc,=0xa98765
;        BREAK
;       BREAK

        BREAK
        ldr     lr, =0xa98765
        BREAK
        blx     lr

        BREAK
        pop     pc
        BREAK
        pop     {r11,pc}
        BREAK
        pop     {r10,r11,pc}
        BREAK
        pop     {r9,r10,r11,pc}
        BREAK
        pop     {r1,r2,r3,r4,r5,r6,r7,r8,r9,r10,r11,pc}

        BREAK
        ldr.w     r0,=0xa98765
        BREAK
        nop
        ldr.w     r0,=0xa98765
        BREAK
        nop
        nop
        ldr.w     r0,=0xa98765

        BREAK
        ldr     r0,=0xa98765
        BREAK
        ldr.w   r0,=0xa98765
        BREAK
        ldr.w   r0,=0xa98765
        BREAK
        ldr     r0,=0xa98765
        BREAK
        ldr.w   r0,=0xa98765
        BREAK
        ldr.w   r0,=0xa98765
        BREAK
        ldr     r0,=0xa98765
        BREAK
        ldr.w   r0,=0xa98765
        BREAK
        ldr.w   r0,=0xa98765

        BREAK
        ldr     r0,=0xa98765
        BREAK
        nop
        ldr     r0,=0xa98765
        BREAK
        nop
        nop
        ldr     r0,=0xa98765

        BREAK
        nop
        ldr     r0,=0xa
        BREAK
        ldr     r0,=0xa9
        BREAK
        ldr     r0,=0xa98
        BREAK
        ldr     r0,=0xa987
        BREAK
        ldr     r0,=0xa9876
        BREAK
        ldr     r0,=0xa98765
        BREAK
        ldr     r0,=0xa987654
        BREAK
        ldr     r0,=0xa9876543

        ;; Simple instructions.
        BREAK
        adds r0,r0, #5                                  ; 1d40
        BREAK
        movs r2, #0                                     ; 2200
        BREAK
        movs r3, #0                                     ; 2300
        BREAK
        bx lr                                           ; 4770 [FFFFFFFF]

        ;; Known 16-bit instructions
        BREAK
        mov r11, sp                                     ; 46eb
        BREAK
        movs r2, r0                                     ; 0002
        BREAK
        push r0, r1                                     ; b403
        BREAK
        str r3,[r7,#0x28]                               ; 62bb
        BREAK
        bx r5                                           ; 4728 [FFFFFFFF]
        BREAK
        blx r5                                          ; 47a8
        BREAK
        DCW 0x4878 ;  ldr r0, [PC + 0x1E0]              ; 4878
        BREAK
        str r3,[r7,#0x1C]                               ; 61fb
        BREAK
        ldr r3,[r7,#0x38]                               ; 6bbb
        BREAK
        add r3,sp,#0xCC                                 ; ab33
        BREAK
        cbz r2,+0x56                                    ; b34a [00xx1510]
        BREAK
        cbnz r2,+0x56                                   ; bb4a [00xx1514]
        BREAK
        push {r0,r2,r4,r6,lr}                           ; b555
        BREAK
        nop                                             ; bf00

        ;; Placeholder for IT instruction
        BREAK
        bne +0x6E                                       ; d135 [00xx1538] -??? d137
        BREAK
        svc #0x24                                       ; df24
        BREAK
        b +0x7FE                                        ; e3fd [00xx1cd0] -??? e3ff

        ;; 32 bit test codes
        BREAK
        adds r0,r7,#8                                   ; f1170008
        BREAK
        str r3,[r5,#0x677]                              ; f8c53677
        BREAK
        ldrsh r10,[r5,#0x5A5]                           ; f9b5a5a5
        BREAK
        DCW 0xf89f,0x55a5 ;ldrb r5, [+0x5A5]            ; f89f55a5
        BREAK
        bls.w +0x86;    0xf240; 0x8043; //              ; f2408041 [00xx157A]
        BREAK
        bl +0xFE;    0xf7ff; 0xff80; //
        BREAK
        bl +0xFFE;    0xf7ff; 0xff80; //
        BREAK
        bl +0xFFFE;    0xf7ff; 0xff80; //
        BREAK
        bl +0xFFFFE;    0xf7ff; 0xff80; //
        BREAK
        bl +0xFFFFFE;    0xf7ff; 0xff80; //
        BREAK
        bl +0xF0;    0xf7ff; 0xff80; //
        BREAK
        bl +0xFF0;    0xf7ff; 0xff80; //
        BREAK
        bl +0xFFF0;    0xf7ff; 0xff80; //
        BREAK
        bl +0xFFFF0;    0xf7ff; 0xff80; //
        BREAK
        bl +0xFFFFF0;    0xf7ff; 0xff80; //
        BREAK
        bl +0xF00;    0xf7ff; 0xff80; //
        BREAK
        bl +0xFF00;    0xf7ff; 0xff80; //
        BREAK
        bl +0xFFF00;    0xf7ff; 0xff80; //
        BREAK
        bl +0xFFFF00;    0xf7ff; 0xff80; //
        BREAK
        DCW 0xf7ff,0xff80
        ;bl +0xFFFFFF00;    0xf7ff; 0xff80; //
        BREAK
        DCW 0xf7ff,0xbe02
        ;        b.w ;    0xf7ff; 0xbe02; //  (10053528)
        BREAK
        push {r7,r11,lr};    0xe92d; 0x4880; //

        ;; 32 bit expected results
        BREAK
        adds r0,r7,#8                                   ; 0xf1170008
        BREAK
        str r3,[r5,#0x677]                              ; 0xf8c53677
        BREAK
        ldrsh r10,[r5,#0x5A5]                           ; 0xf9b5a5a5

        BREAK
        DCW 0xf6af,0xfbd2
        ; bl (0008ef3c);    ResultCode(4, 0xf6af, 0xfbd2, Target(ADDRESS(&g_pTestCodes32[i*2], 0xFFFFFF00))); // 0xf7ff, 0xff80: -> 0xf6affbd2
        BREAK
        bl (00090300);    ResultCode(4, 0xf6af, 0xba54, Target(ADDRESS(&g_pTestCodes32[i*2], 0xFFFFFC04))); // 0xf7ff, 0xff80: -> f6afba54 bl (00090300)
        BREAK
        push {r7,r11,lr};    ResultCode(4, 0xe92d, 0x4880); // 0xe92d, 0x4880: //

        BREAK
        BREAK

|TestCodes_end|

        END

```

`samples/disas/disas.cpp`:

```cpp
/////////////////////////////////////////////////////////////////////////////
//
//  Module: disas.cpp (disas.exe - Detours Test Program)
//
//  Microsoft Research Detours Package
//
//  Copyright (c) Microsoft Corporation.  All rights reserved.
//

#define DETOURS_INTERNAL
#include <detours.h>
#include <stdio.h>
#include <stdlib.h>

///////////////////////////////////////////////////////////////////////// ARM.
//
#ifdef DETOURS_ARM

extern "C" BYTE TestCodes[];

void DumpMemoryFragment(PBYTE pbData, ULONG cbData, ULONG cbSpace)
{
    ULONG n = 0;
    if (cbData >= 4) {
        printf("%04x%04x ", ((PUSHORT)pbData)[0], ((PUSHORT)pbData)[1]);
        n += 4;
    }
    else if (cbData >= 2) {
        printf("%04x ", *((PUSHORT)pbData));
        n += 2;
    }

    for (; n < cbSpace; n++) {
        if (n < cbData) {
            printf("%02x", pbData[n]);
        }
        else {
            printf("  ");
        }
    }
    if (n < cbData) {
        printf(".");
    }
    else {
        printf(" ");
    }
}

inline ULONG fetch_thumb_opcode(PBYTE pbCode)
{
    ULONG Opcode = *(UINT16 *)&pbCode[0];
    if (Opcode >= 0xe800) {
        Opcode = (Opcode << 16) | *(UINT16 *)&pbCode[2];
    }
    return Opcode;
}

BOOL IsTerminate(PBYTE pbSrc)
{
    ULONG opcode = fetch_thumb_opcode(pbSrc);

    if ((opcode & 0xff87) == 0x4700) {
        // bx r
        return TRUE;
    }

#if 0
    if ((opcode & 0xfbf08f00) == 0xf2400c00) {          // movw r12,#xxxx
        return TRUE;
    }

    if ((opcode == 0xf8dcf000) {                 // ldr  pc,[r12]
                ULONG Immediate = ((opcode2 << 12) & 0xf7000000) |
                                  ((opcode2 <<  1) & 0x08000000) |
                                  ((opcode2 << 16) & 0x00ff0000) |
                                  ((opcode  >>  4) & 0x0000f700) |
                                  ((opcode  >> 15) & 0x00000800) |
                                  ((opcode  >>  0) & 0x000000ff);
                PBYTE pbTarget = *(PBYTE *)Immediate;
                if (detour_is_imported(pbCode, pbTarget)) {
                    PBYTE pbNew = *(PBYTE *)pbTarget;
                    DETOUR_TRACE(("%p->%p: skipped over import table.\n", pbCode, pbNew));
                    return pbNew;
                }
            }
        }
    }
#endif

    return FALSE;
}

#endif // DETOURS_ARM

///////////////////////////////////////////////////////////////// X86 and X64.
//
#if defined(DETOURS_X86) || defined(DETOURS_X64)

extern "C" BYTE TestCodes[];

void DumpMemoryFragment(PBYTE pbData, ULONG cbData, ULONG cbSpace)
{
    ULONG n = 0;
    for (; n < cbSpace; n++) {
        if (n < cbData) {
            printf("%02x", pbData[n]);
        }
        else {
            printf("  ");
        }
    }
    if (n < cbData) {
        printf(".");
    }
    else {
        printf(" ");
    }
}

BOOL IsTerminate(PBYTE pbSrc)
{
    if ((0xC3 == pbSrc[0] && 0x00 == pbSrc[1]) ||       // bx lr
        0xCB == pbSrc[0] ||                             // RETF
        0xC2 == pbSrc[0] ||                             // RET dw
        0xCA == pbSrc[0] ||                             // RETF dw
        0xEB == pbSrc[0] ||                             // JMP ob
        0xE9 == pbSrc[0] ||                             // JMP ol
        0xEA == pbSrc[0]) {                             // JMP ol

        return TRUE;
    }
    if (0xff == pbSrc[0] && 0x25 == pbSrc[1])           // JMP [addr]
        return TRUE;
    return FALSE;
}

#endif // DETOURS_X86 || DETOURS_X64

/////////////////////////////////////////////////////////// X86, X64, and ARM.
//
#if defined(DETOURS_X86) || defined(DETOURS_X64) || defined(DETOURS_ARM)
struct BasicBlockLink
{
  public:
    BasicBlockLink *    m_pNext;
    PBYTE               m_pbEntry;
    PCHAR               m_pszName;

  public:
    BasicBlockLink(PBYTE pbEntry, PCHAR pszName = NULL)
    {
        m_pNext = NULL;
        m_pbEntry = pbEntry;
        m_pszName = pszName;

        *s_ppTail = this;
        s_ppTail = &m_pNext;
    }

    BasicBlockLink * Next()
    {
        return m_pNext;
    }

    static BasicBlockLink * GetListHead()
    {
        return s_pHead;
    }

  protected:
    static BasicBlockLink *     s_pHead;
    static BasicBlockLink **    s_ppTail;
};

BasicBlockLink *    BasicBlockLink::s_pHead = NULL;
BasicBlockLink **   BasicBlockLink::s_ppTail = &BasicBlockLink::s_pHead;

static PBYTE s_pbBegin = NULL;
static PBYTE s_pbLimit = NULL;

int TestDetourCopyInstruction(PBYTE pbSrcInstruction, PCHAR pszFunction)
{
    PBYTE pbSrc = pbSrcInstruction;
    ULONG nIns = 0;

    if (pszFunction) {
        printf("%s:\n", pszFunction);
    }
    for (; nIns < 4096; nIns++) {
        BYTE rbDst[128];
        PVOID pbDstPool = (PVOID)(rbDst + sizeof(rbDst));
        LONG lExtra = 0;
        PVOID pbTarget = NULL;
        ULONG cbStep = (ULONG)((PBYTE)DetourCopyInstruction(rbDst, &pbDstPool, pbSrc,
                                                            &pbTarget, &lExtra) - pbSrc);

        printf("    %p:", pbSrc);
        DumpMemoryFragment(rbDst, cbStep, 10);
        printf(" ");
        DumpMemoryFragment(rbDst, cbStep, 10);
        if (pbTarget) {
            if (pbTarget == DETOUR_INSTRUCTION_TARGET_DYNAMIC) {
                printf("  Dynamic\n");
            }
            else {
                printf(" %p%c\n", pbTarget,
                       (pbTarget >= s_pbBegin && pbTarget < s_pbLimit) ? ' ' : '!');
            }
        }
        else {
            printf("\n");
        }

        if (pbTarget && pbTarget != DETOUR_INSTRUCTION_TARGET_DYNAMIC) {
            if (pbTarget > pbSrc &&
                pbTarget >= s_pbBegin &&
                pbTarget < s_pbLimit
               ) {
                (void) new BasicBlockLink((PBYTE)pbTarget, NULL);
            }
        }

        if (IsTerminate(pbSrc)) {
            break;
        }

        pbSrc += cbStep;
    }
    return nIns;
}

BOOL CALLBACK ExportCallback(_In_opt_ PVOID pContext,
                             _In_ ULONG nOrdinal,
                             _In_opt_ LPCSTR pszName,
                             _In_opt_ PVOID pCode)
{
    (void)pContext;
    (void)nOrdinal;
    (void)pCode;

    (VOID) new BasicBlockLink((PBYTE)pCode, pszName ? pszName : "[NO NAME]");
    return TRUE;
}
#endif // DETOURS_X86 || DETOURS_X64

//////////////////////////////////////////////////////////////////////// IA64.
//
#ifdef DETOURS_IA64
#pragma warning(disable: 4201)  // ignore warning about unnamed sturcture in union.

void DumpHi(PBYTE pbData, ULONG cbData, ULONG cbSpace)
{
    ULONG n = 0;
    for (; n < cbSpace; n++) {
        if (n < cbData) {
            printf("%02x", pbData[(cbData - 1) - n]);
        }
        else {
            printf("  ");
        }
    }
    printf("\n");
}

struct DETOUR_IA64_BUNDLE_DISASSEMBLE : public DETOUR_IA64_BUNDLE
{
  public:
    void SetBrx(UINT64 raw)
    {
        SetBrl();
        SetBrlImm(raw);
    }

    void Dis()
    {
        const char szUnitNames[17] = "?aimbflx?AIMBFLX";

        printf("%p: ", data);
        BYTE nTemplate = GetTemplate();
        BYTE nInst0 = GetInst0();
        BYTE nInst1 = GetInst1();
        BYTE nInst2 = GetInst2();
        BYTE nUnit0 = GetUnit0();
        BYTE nUnit1 = GetUnit1();
        BYTE nUnit2 = GetUnit2();
        if (nUnit1 == L_UNIT) { // MLX instruction
            UINT64 d2 = (
                         //          0x0000000000fffff0
                         ((wide[1] & 0x00fffff000000000) >> 32) |
                         //          0x000000ffff000000
                         ((wide[0] & 0xffff000000000000) >> 24) |
                         //          0x7fffff0000000000
                         ((wide[1] & 0x00000000007fffff) << 40) |
                         //          0x8000000000000000
                         ((wide[1] & 0x0800000000000000) <<  4)
                        );
            printf("%02x %c%01x %010I64lx %c%01x %016I64lx",
                   nTemplate,
                   szUnitNames[nUnit0], nInst0, GetData0(),
                   szUnitNames[nUnit2], nInst2, d2);
        }
        else {
            printf("%02x %c%01x %010I64lx %c%01x %010I64lx %c%01x %010I64lx",
                   nTemplate,
                   szUnitNames[nUnit0], nInst0, GetData0(),
                   szUnitNames[nUnit1], nInst1, GetData1(),
                   szUnitNames[nUnit2], nInst2, GetData2());
        }

        if (IsBrl()) {
            printf(" brl  %p", GetBrlTarget());
        }
        else if (IsMovlGp()) {
            printf(" movl gp=%p", GetMovlGp());
        }
        if ((wide[0] & 0xfffffc000603ffff) == 0x002024000200100b &&
            wide[1] == 0x0004000000203008) {

            ULONG64 offset =
                ((wide[0] & 0x0000000001fc0000) >> 18) |  // imm7b
                ((wide[0] & 0x000001ff00000000) >> 25) |  // imm9d
                ((wide[0] & 0x00000000f8000000) >> 11);   // imm5c
            if (wide[0] & 0x0000020000000000) {
                offset |= 0xffffffffffe00000;
            }
            printf(" imm=%016I64lx", offset);
        }
        printf("\n");
    }
};

//////////////////////////////////////////////////////////////////////////////
//
BOOL CALLBACK ExportCallbackIA64(_In_opt_ PVOID pContext,
                                 _In_ ULONG nOrdinal,
                                 _In_opt_ LPCSTR pszName,
                                 _In_opt_ PVOID pCode)
{
    (void)pContext;
    (void)nOrdinal;

    DETOUR_IA64_BUNDLE_DISASSEMBLE *pb = *(DETOUR_IA64_BUNDLE_DISASSEMBLE **)pCode;
    DETOUR_IA64_BUNDLE temp;

    if (!pb[0].Copy(&temp)) {
        printf("%s:\n  ", pszName ? pszName : "[NO NAME]");
        pb[0].Dis();
    }
    return TRUE;
}

#if 0
void TestBoth()
{
    LPVOID pvBase = VirtualAlloc((PBYTE)0x800000000, 0x10000,
                                 MEM_RESERVE | MEM_COMMIT,
                                 PAGE_EXECUTE_READWRITE);

    DETOUR_IA64_BUNDLE *pbBase = (DETOUR_IA64_BUNDLE *)pvBase;
    DETOUR_IA64_BUNDLE *pb = pbBase;

    printf("TestBoth:\n");
    for (UINT64 i = 0x10; i < 0x8000000000000000; i <<= 1) {
        pb->SetMovlGp(i);
        if (pb->GetMovlGp() != i) {
            printf("Error in MovlGp!\n");
            return;
        }
        pb++;

        pb->SetBrl(i);
        if (pb->GetBrlEip() != i) {
            printf("Error in Brl!\n");
            return;
        }
        pb++;
    }

    for (UINT64 i = (UINT64)(INT64)-0x10; i > 0; i <<= 1) {
        pb->SetMovlGp(i);
        if (pb->GetMovlGp() != i) {
            printf("Error in MovlGp!\n");
            return;
        }
        pb++;

        pb->SetBrl(i);
        if (pb->GetBrlEip() != i) {
            printf("Error in Brl!\n");
            return;
        }
        pb++;
    }

    printf("u %p %p\n", pbBase, pb);
}
#endif
#endif // DETOURS_IA64

int WINAPI WinMain(HINSTANCE hinst, HINSTANCE hprev, LPSTR lpszCmdLine, int nCmdShow)
{
    (void)hprev;
    (void)hinst;
    (void)lpszCmdLine;
    (void)nCmdShow;

    // Bug report, but it works here.
    // 07ff8`4b783054 49ba 70b3d93a d40fb998 mov r10,98B90FD43AD9B370h
    //
    {
        static const UCHAR mov_r10_imm64[] = {0x49, 0xba, 1, 2, 3, 4, 5, 6, 7, 8 };

        PVOID const after = DetourCopyInstructionX64(0, 0, const_cast<PUCHAR>(mov_r10_imm64), 0, 0);

        if (after != &mov_r10_imm64 + 1)
        {
            printf("mov_r10_imm64 failed, expected:%p vs. got:%p\n", &mov_r10_imm64 + 1, after);
            if (IsDebuggerPresent())
            {
                __debugbreak();
                DetourCopyInstructionX64(0, 0, const_cast<PUCHAR>(mov_r10_imm64), 0, 0);
            }
            return 1;
        }
    }

#ifdef DETOURS_IA64
    // First we check the pre-canned TestCodes from disasm.asm
    //
    PBYTE pbTest = *(PBYTE*)WinMain;
    for (;; pbTest += 16) {
        DETOUR_IA64_BUNDLE_DISASSEMBLE *pb = (DETOUR_IA64_BUNDLE_DISASSEMBLE *)pbTest;

        pb->Dis();
        if (pbTest[0] == 0xff) {
            break;
        }
        DumpHi(pbTest, 16, 16);
    }

#if 0
    printf("\n\n");

    DETOUR_IA64_BUNDLE_DISASSEMBLE *pb = (DETOUR_IA64_BUNDLE_DISASSEMBLE *)pbTest;
    DETOUR_IA64_BUNDLE_DISASSEMBLE *pbBeg = pb;
    DWORD dwOld;
    VirtualProtect(pb, 0x2000, PAGE_EXECUTE_READWRITE, &dwOld);
    printf("%p: (%d)\n", pb, sizeof(pb));
    pb++;
    printf("%p: (%d)\n", pb, sizeof(pb));
    pb++; pb->SetBrx(0);
    pb++; pb->SetBrx(0);
    pb++; pb->SetBrx(0);
    pb++; pb->SetBrx(0xffffffffffffffff);
    pb++; pb->SetBrx(0x0fffffffffffffff);
    pb++; pb->SetBrx(0x00ffffffffffffff);
    pb++; pb->SetBrx(0x000fffffffffffff);
    pb++; pb->SetBrx(0x0000ffffffffffff);
    pb++; pb->SetBrx(0x00000fffffffffff);
    pb++; pb->SetBrx(0x000000ffffffffff);
    pb++; pb->SetBrx(0x0000000fffffffff);
    pb++; pb->SetBrx(0x00000000ffffffff);
    pb++; pb->SetBrx(0x000000000fffffff);
    pb++; pb->SetBrx(0x0000000000ffffff);
    pb++; pb->SetBrx(0x00000000000fffff);
    pb++; pb->SetBrx(0x000000000000ffff);
    pb++; pb->SetBrx(0x0000000000000fff);
    pb++; pb->SetBrx(0x00000000000000ff);
    pb++; pb->SetBrx(0x000000000000000f);
    pb++; pb->SetBrx(0x0000000000000000);
    pb++; pb->SetBrx(0xffffffffffffffff);
    pb++; pb->SetBrx(0xffffffffffffffff);
    pb->SetInst0(0xff);
    pb->SetData0(0xffffffffffffffff);
    printf("%p:\n", pb);
    DETOUR_IA64_BUNDLE_DISASSEMBLE *pbEnd = pb;
    for (pb = pbBeg; pb < pbEnd; pb++) {
        printf("  %p: ", pb);
        DumpHi((BYTE*)pb, 16, 16);
    }
#endif

#if 1
    {
        // Then we check all of the code we can find in user32.dll
        //
        printf("\n");
        HINSTANCE hInst = LoadLibraryA("user32.dll");
        printf("Loaded: user32.dll: %p\n", hInst);

        PBYTE pbEntry = (PBYTE)DetourGetEntryPoint(hInst);
        printf("Entry: %p\n", pbEntry);
        ExportCallbackIA64(NULL, 0, "[Entry]", pbEntry);
        DetourEnumerateExports(hInst, NULL, ExportCallbackIA64);
    }

    {
        // Then we check all of the code we can find in opengl32.dll
        //
        printf("\n");
        HINSTANCE hInst = LoadLibraryA("opengl32.dll");
        printf("Loaded: opengl32.dll: %p\n", hInst);

        PBYTE pbEntry = (PBYTE)DetourGetEntryPoint(hInst);
        printf("Entry: %p\n", pbEntry);
        ExportCallbackIA64(NULL, 0, "[Entry]", pbEntry);
        DetourEnumerateExports(hInst, NULL, ExportCallbackIA64);
    }

    printf("\n");
    for (HINSTANCE hInst = NULL; (hInst = DetourEnumerateModules(hInst)) != NULL;) {
        CHAR szModuleName[512];
        GetModuleFileNameA(hInst, szModuleName,
                           sizeof(szModuleName)/sizeof(szModuleName[0]));
        printf("%p : %s\n", hInst, szModuleName);
        DetourEnumerateExports(hInst, NULL, ExportCallbackIA64);
    }

    printf("\n");
#endif
#if 0
    TestBoth();
#endif
#endif // DETOURS_IA64

#if defined(DETOURS_X64) || defined(DETOURS_X86)
    // First we check the pre-canned TestCodes from disasm.asm
    //
    PBYTE pbBegin = (PBYTE)DetourCodeFromPointer(TestCodes, NULL);
    printf("%p:\n", pbBegin);
    for (PBYTE pbTest = pbBegin;;) {
        if (pbTest[0] != 0xcc) {    // int 3
            printf("%08lx  ", (ULONG)(pbTest - pbBegin));
            DumpMemoryFragment(pbTest, 8, 8);
            printf("\n");
            printf("failed on last.\n");
            return 1;
        }
        pbTest++;

        if (pbTest[0] == 0x70 || pbTest[0] == 0x71) {
            printf("[%p]:\n", pbTest);
        }
        BYTE rbDst[128];
        PVOID pbDstPool = (PVOID)(rbDst + sizeof(rbDst));
        LONG lExtra = 0;
        PVOID pbTarget = NULL;
        PBYTE pbNext = (PBYTE)DetourCopyInstruction(rbDst, &pbDstPool, pbTest,
                                                    &pbTarget, &lExtra);

        LONG cbTest = (LONG)(pbNext - pbTest);

        printf("%08lx  ", (ULONG)(pbTest - pbBegin));
        DumpMemoryFragment(pbTest, cbTest, 12);
        printf("[%16p] ", pbTarget);
        DumpMemoryFragment(rbDst, cbTest + lExtra, 11);
        printf("\n");

        if (pbTest[cbTest] != 0xcc) {
            printf("failed!\n");
            return 1;
        }

        pbTest += cbTest;

        if (pbTest[0] == 0xcc && pbTest[1] == 0xcc) {
            break;
        }
    }

#if 0
    // Then we check all of the code we can find in user32.dll
    //
    HINSTANCE hInst = LoadLibraryA("user32.dll");
    printf("Loaded: user32.dll: %p\n", hInst);

    s_pbBegin = (PBYTE)hInst;
    s_pbLimit = s_pbBegin + DetourGetModuleSize(hInst);

    PBYTE pbEntry = DetourGetEntryPoint(hInst);
    (VOID) new BasicBlockLink(pbEntry, "user32.dll");

    DetourEnumerateExports(hInst, NULL, ExportCallback);

    ULONG nIns = 0;
    for (BasicBlockLink *pLink = BasicBlockLink::GetListHead();
         pLink; pLink = pLink->Next()) {

        nIns += TestDetourCopyInstruction(pLink->m_pbEntry, pLink->m_pszName);
        if (nIns > 100000) {
            break;
        }
    }
    printf("Disassembled %d instructions.\n", nIns);
#endif
#endif // DETOURS_X86 || DETOURS_X64

#ifdef DETOURS_ARM
    // Create an output buffer and fill it with debugbreaks.
    //
    PBYTE pbBuffer
        = (PBYTE)VirtualAlloc(NULL, 0x400, MEM_COMMIT|MEM_RESERVE, PAGE_EXECUTE_READWRITE);
    for (PBYTE pbOut = pbBuffer; pbOut < pbBuffer + 0x400;) {
        *pbOut++ = 0xfe;
        *pbOut++ = 0xde;
    }
    PBYTE pbDst = pbBuffer;
    PVOID pvDstPool = (PVOID)(pbBuffer + 0x400);

    // First we check the pre-canned TestCodes from disasm.asm
    //
    PBYTE pbBegin = (PBYTE)DetourCodeFromPointer(TestCodes, NULL);
    printf("%p: (TestCodes %p) => %p\n", pbBegin, TestCodes, pbBuffer);
    for (PBYTE pbSrc = pbBegin;;) {
        if (pbSrc[0] != 0xfe && pbSrc[1] != 0xde) {    // BREAK
            printf("%08x  ", pbSrc - pbBegin);
            DumpMemoryFragment(pbSrc, 8, 8);
            printf("\n");
            printf("failed on last.\n");
            return 1;
        }
        pbSrc += 2;
        *pbDst++ = 0xfe;
        *pbDst++ = 0xde;

        if ((pbSrc[0] == 0x00 && pbSrc[1] == 0xbf) &&  // NOP
            (pbSrc[2] != 0xfe && pbSrc[3] != 0xde)) {    // BREAK
            // Skip over a single NOP so we can test alignment.
            pbSrc += 2;
        }

        if ((pbSrc[0] == 0x00 && pbSrc[1] == 0xbf) &&  // NOP
            (pbSrc[2] != 0xfe && pbSrc[3] != 0xde)) {    // BREAK
            // If there is a second NOP, then we insert alignment.
            pbSrc += 2;
            *pbDst++ = 0x00;
            *pbDst++ = 0xbf;
        }


        LONG lExtra = 0;
        PVOID pbTarget = NULL;
        PBYTE pbNext = (PBYTE)DetourCopyInstruction(pbDst, &pvDstPool, pbSrc, &pbTarget, &lExtra);

        LONG cbTest = (LONG)(pbNext - pbSrc);

        printf("%08x  ", pbSrc - pbBegin);
        DumpMemoryFragment(pbSrc, cbTest, 4);
        printf("[%8p] ", pbTarget);
        DumpMemoryFragment(pbDst, cbTest + lExtra, 16);
        printf("\n");

        if (pbSrc[cbTest] != 0xfe || pbSrc[cbTest+1] != 0xde) {
            printf("%p: failed! (pbSrc[n]=%02x, pbSrc[n+1]=%02x\n",
                   pbSrc,
                   pbSrc[cbTest], pbSrc[cbTest+1]);
            __debugbreak();
            pbNext = (PBYTE)DetourCopyInstruction(pbDst, &pvDstPool, pbSrc, &pbTarget, &lExtra);
            cbTest = (LONG)(pbNext - pbSrc);
            return 1;
        }

        pbDst += cbTest + lExtra;
        pbSrc += cbTest;

        if (pbSrc[0] == 0xfe && pbSrc[1] == 0xde &&
            pbSrc[2] == 0xfe && pbSrc[3] == 0xde) {
            break;
        }
    }

#if 0
    // Then we check all of the code we can find in user32.dll
    //
    HINSTANCE hInst = LoadLibraryA("user32.dll");
    printf("Loaded: user32.dll: %p\n", hInst);

    s_pbBegin = (PBYTE)hInst;
    s_pbLimit = s_pbBegin + DetourGetModuleSize(hInst);

    PBYTE pbEntry = DetourGetEntryPoint(hInst);
    (VOID) new BasicBlockLink(pbEntry, "user32.dll");

    DetourEnumerateExports(hInst, NULL, ExportCallback);

    ULONG nIns = 0;
    for (BasicBlockLink *pLink = BasicBlockLink::GetListHead();
         pLink; pLink = pLink->Next()) {

        nIns += TestDetourCopyInstruction(pLink->m_pbEntry, pLink->m_pszName);
        if (nIns > 100000) {
            break;
        }
    }
    printf("Disassembled %d instructions.\n", nIns);
#endif
#endif // DETOURS_ARM

    return 0;
}
//
///////////////////////////////////////////////////////////////// End of File.

```

`samples/disas/ia64.asm`:

```asm
/////////////////////////////////////////////////////////////////////////////
//
//  Detours Test Program (ia64.asm/disas.exe)
//
//  Microsoft Research Detours Package
//
//  Copyright (c) Microsoft Corporation.  All rights reserved.
//

    .section .text
    .proc  TestCodes#
    .global TestCodes#
    .align 64

TestCodes:
{   .mii
        and     r21 = 7, r32
        mux1    r25 = r33, @brcst
        add     r16 = r32, r34
} { .mmb
        cmp.ge  p9 = 0, r34
        mov     r8 = r32
(p9)    br.ret.spnt b0
  ;;
}
// align on an 8-byte boundary
{   .mmi
        cmp.ne  p15 = 0, r21   //Low 3 bits zero?
        cmp.gt  p10 = 0x30, r34
        cmp.eq  p6, p7 = 0, r33
} { .mmb
        nop.m   0
        nop.m   0
(p15)   br.cond.dpnt Align_Loop
  ;;
} { .mmi
(p7)    mov     r27 = 0x88
(p6)    mov     r27 = 0x90
        tbit.nz p14,p13 = r32, 3 // is aligned on 8-bytes (to align on 16 before FP loop)?
} { .mbb
        nop.m   0
(p10)   br.cond.dpnt Aligned_Short  // blocks < 48 bytes
(p7)    br.cond.dpnt Aligned_Long;  // do 8-byte stores for non-zero fills, 16-byte f0 for zero-fills
  ;;
}

// zero-fills >= 48 bytes goes through an f0 16-byte store loop
Aligned_FP_Long:
{   .mmi
        add     r28 = 0x80, r27
        add     r29 = 0x100, r27
        add     r30 = 0x180, r27
} { .mmi
(p14)   add     r14 = 0x88, r32
(p14)   st8     [r32] = r0, 8
(p14)   add     r34 = -0x8, r34
  ;;
} { .mmi
(p13)   add     r14 = 0x80, r32
        cmp.ge  p7 = r34, r27
        add     r27 = 0x200, r27
} { .mmi
        add     r15 = 0x180, r32
        add     r17 = 0x200, r32
        nop.i   0
  ;;
} { .mmi
        add     r26 = 0x280, r32
        cmp.ge  p8 = r34, r28
        cmp.ge  p9 = r34, r29
} { .mmi
        stf.spill   [r32] = f0       // Line 0
(p7)    stf.spill   [r14] = f0,0x80  // Line +1 0x80
        add     r28 = 0x200, r28
  ;;
} { .mmi
(p8)    stf.spill   [r14] = f0   // Line +2 0x100
(p9)    stf.spill   [r15] = f0   // Line +3 0x180
        cmp.ge  p10 = r34, r28
} { .mmi
        cmp.ge  p11 = r34, r30
        cmp.ge  p12 = r34, r27
        nop.i   0
  ;;
} { .mmi
(p11)   stf.spill   [r17] = f0   // Line +4 0x200
(p12)   stf.spill   [r26] = f0, 0x80 // Line +5 0x280
        add    r31 = 0x10, r32
  ;;
}

    .align 32
Long_FP_loop:
{   .mmi
(p10)   stf.spill   [r26] = f0, 0x80 // Line +6
        stf.spill   [r31] = f0, 0x20
        cmp.le  p15,p12 = 0x40, r34
} { .mmb
        add     r32 = 0x20, r32
        add     r34 = -0x20, r34
(p12)   br.cond.dpnt Aligned_Short
  ;;
} { .mmi
(p15)   stf.spill   [r32] = f0, 0x20
(p15)   stf.spill   [r31] = f0, 0x20
        cmp.le  p15,p12 = 0x40, r34
} { .mmb
        add     r21 = -0x60, r34
        add     r34 = -0x20, r34
(p12)   br.cond.dpnt Aligned_Short
  ;;
} { .mmi
(p15)   stf.spill   [r32] = f0, 0x20
(p15)   stf.spill   [r31] = f0, 0x20
        cmp.le  p15,p12 = 0x40, r34
} { .mmb
        cmp.ge  p10 = r21, r28
        add     r34 = -0x20, r34
(p12)   br.cond.dpnt Aligned_Short
  ;;
} { .mmi
(p15)   stf.spill   [r32] = f0, 0x20
(p15)   stf.spill   [r31] = f0, 0x20
        cmp.le  p15,p12 = 0x40, r34
} { .mbb
        add     r34 = -0x20, r34
(p15)   br.cond.sptk.many   Long_FP_loop
        br.cond.dpnt.many   Aligned_Short
  ;;
}

    .align 32
// >= 48 bytes non-zero fills go through a 8-byte store based loop
Aligned_Long:
{   .mmi
        add     r28 = 0x80, r27
        add     r29 = 0x100, r27
        add     r30 = 0x180, r27
} { .mmi
        add     r14 = 0x80, r32
        cmp.ge  p7 = r34, r27
        nop.i   0
  ;;
} { .mmi
        add     r26 = 0x180, r32
        cmp.ge  p8 = r34, r28
        add     r31 = 8, r32
} { .mmi
        st8     [r32] = r25
(p7)    st8     [r14] = r25, 0x80
        cmp.ge  p9 = r34, r29
  ;;
} { .mmi
(p8)    st8     [r14] = r25
(p9)    st8     [r26] = r25, 0x80
        cmp.ge  p10 = r34, r30
  ;;
}
    .align 32
Long_loop:
{   .mmi
(p10)   st8     [r26] = r25, 0x80
        st8     [r31] = r25, 0x10
        cmp.le  p15,p12 = 0x20, r34
} { .mmb
        add     r32 = 0x10, r32
        add     r34 = -0x10, r34
(p12)   br.cond.dpnt Aligned_Short
  ;;
} { .mmi
(p15)   st8     [r32] = r25, 0x10
(p15)   st8     [r31] = r25, 0x10
        cmp.le  p15,p12 = 0x20, r34
} { .mmb
        nop.m   0
        add     r34 = -0x10, r34
(p12)   br.cond.dpnt Aligned_Short
  ;;
} { .mmi
(p15)   st8     [r32] = r25, 0x10
(p15)   st8     [r31] = r25, 0x10
        cmp.le  p15,p12 = 0x20, r34
} { .mmb
        nop.m   0
        add     r34 = -0x10, r34
(p12)   br.cond.dpnt Aligned_Short
  ;;
} { .mmi
(p15)   st8     [r32] = r25, 0x10
(p15)   st8     [r31] = r25, 0x10
        cmp.le  p15,p12 = 0x20, r34
} { .mmb
        nop.m   0
        add     r34 = -0x10, r34
(p12)   br.cond.dpnt Aligned_Short
  ;;
} { .mmi
(p15)   st8     [r32] = r25, 0x10
(p15)   st8     [r31] = r25, 0x10
        cmp.le  p15,p12 = 0x20, r34
} { .mmb
        nop.m   0
        add     r34 = -0x10, r34
(p12)   br.cond.dpnt Aligned_Short
  ;;
} { .mmi
(p15)   st8     [r32] = r25, 0x10
(p15)   st8     [r31] = r25, 0x10
        cmp.le  p15,p12 = 0x20, r34
} { .mmb
        add     r21 = -0x30, r34
        add     r34 = -0x10, r34
(p12)   br.cond.dpnt Aligned_Short
  ;;
} { .mmi
(p15)   st8     [r32] = r25, 0x10
(p15)   st8     [r31] = r25, 0x10
        cmp.le  p15,p12 = 0x20, r34
} { .mmb
        cmp.ge  p10 = r21, r30
        add     r34 = -0x10, r34
(p12)   br.cond.dpnt Aligned_Short
  ;;
} { .mmi
(p15)   st8     [r32] = r25, 0x10
(p15)   st8     [r31] = r25, 0x10
        cmp.le  p15,p12 = 0x20, r34
} { .mmb
        add     r34 = -0x10, r34
        nop.m   0
(p15)   br.cond.sptk.many Long_loop
  ;;

}

//
// Do partial word stores
//
    .align 32
Aligned_Short:
{   .mmi
        and     r27 = 2, r34
        add     r31 = 8, r32
        tbit.nz p6 = r34, 0   //bit 0 on?
} { .mmb
        cmp.le  p11 = 0x10, r34
        cmp.eq  p10 = 0, r34
(p10)   br.ret.dpnt  b0
  ;;
} { .mmi
(p11)   st8     [r32] = r25, 0x10
(p11)   st8     [r31] = r25, 0x10
        cmp.le  p12 = 0x20, r34
} { .mmi
        add     r17 = -2, r16
        add     r18 = -4, r16
        tbit.nz p9 = r34, 3   //odd number of st8s?
  ;;
} { .mmi
(p12)   st8     [r32] = r25, 0x10
(p12)   st8     [r31] = r25, 0x10
        nop.i   0
} { .mmi
(p6)    add     r18 = -1, r18
(p6)    add     r16 = -1, r16
        cmp.ne  p7 = 0, r27
  ;;
} { .mmi
(p9)    st8     [r32] = r25
(p6)    st1     [r16] = r25
        tbit.nz p8 = r34, 2   //bit 2 on?
} { .mmi
(p7)    add     r18 = -2, r18
(p6)    add     r17 = -1, r17
        nop.i   0
  ;;
} { .mmb
(p8)    st4     [r18] = r25
(p7)    st2     [r17] = r25
        br.ret.sptk.many b0
  ;;
}

    .align 32
// Align the input pointer to an 8-byte boundary
Align_Loop:
{   .mmi
        st1     [r32] = r33,1
        add     r21 = 1, r21
        cmp.eq  p15 = 1, r34
} { .mmb
        cmp.ge  p11 = 0x30, r34
        add     r34 = -1, r34
(p15)   br.ret.dpnt  b0
  ;;
} { .mmb
        cmp.gt  p10 = 8, r21
        cmp.eq  p6, p7 = 0, r33
(p10)   br.cond.sptk Align_Loop
  ;;
} { .mmi
(p7)    mov     r27 = 0x88
(p6)    mov     r27 = 0x90
        tbit.nz p14,p13 = r32, 3 // is aligned on 8-bytes (to align on 16 before FP loop)?
} { .bbb
(p11)   br.cond.dpnt Aligned_Short  // blocks < 48 bytes
(p7)    br.cond.dpnt Aligned_Long;  // non-zero fills
        br.cond.dptk Aligned_FP_Long; // zero fills
  ;;
}
    .endp  TestCodes#

    .proc  Again#
Again:
    brl         TestCodes
    brl         TestCodes
    brl         TestCodes
    brl         TestCodes
    brl         TestCodes
    brl         TestCodes
    brl         TestCodes
    brl         TestCodes
    brl         TestCodes
    brl         TestCodes
    brl         Fore1
    brl         Fore2
    brl         Fore3
    brl         Fore4
    brl         Fore5
    brl         Fore6
    brl         Fore7
    .endp  Again#

    data4       0xffffff00
    data4       0xffffffff
    data4       0xffffffff
    data4       0xffffffff
    .align 64

    data4       0xffffff00
    data4       0xffffffff
    data4       0xffffffff
    data4       0xffffffff

{
    addl   r2=0xffffffffffffffff, gp ;;
    ld8    r2=[r2]
    nop.i  0 ;;
}
{
    addl   r2=0xfffffffffffffff0, gp ;;
    ld8    r2=[r2]
    nop.i  0 ;;
}
{
    addl   r2=0xffffffffffffff00, gp ;;
    ld8    r2=[r2]
    nop.i  0 ;;
}
{
    addl   r2=0xfffffffffffff000, gp ;;
    ld8    r2=[r2]
    nop.i  0 ;;
}
{
    addl   r2=0xfffffffffffff000, gp ;;
    ld8    r2=[r2]
    nop.i  0 ;;
}
{
    addl   r2=0xffffffffffff0000, gp ;;
    ld8    r2=[r2]
    nop.i  0 ;;
}
{
    addl   r2=0xfffffffffff00000, gp ;;
    ld8    r2=[r2]
    nop.i  0 ;;
}
{
    addl   r2=0xffffffffffe00000, gp ;;
    ld8    r2=[r2]
    nop.i  0 ;;
}
{
    addl   r2=0x00000000001fffff, gp ;;
    ld8    r2=[r2]
    nop.i  0 ;;
}
{
    addl   r2=0x00000000000fffff, gp ;;
    ld8    r2=[r2]
    nop.i  0 ;;
}
{
    addl   r2=0x000000000000ffff, gp ;;
    ld8    r2=[r2]
    nop.i  0 ;;
}
{
    addl   r2=0x0000000000000fff, gp ;;
    ld8    r2=[r2]
    nop.i  0 ;;
}
{
    addl   r2=0x00000000000000ff, gp ;;
    ld8    r2=[r2]
    nop.i  0 ;;
}
{
    addl   r2=0x000000000000000f, gp ;;
    ld8    r2=[r2]
    nop.i  0 ;;
}
{
    addl   r2=0x0000000000000000, gp ;;
    ld8    r2=[r2]
    nop.i  0 ;;
}
{
    addl   r2=0x0000000000000001, gp ;;
    ld8    r2=[r2]
    nop.i  0 ;;
}
{
    addl   r2=0x0000000000000002, gp ;;
    ld8    r2=[r2]
    nop.i  0 ;;
}
{
    addl   r2=0x0000000000000004, gp ;;
    ld8    r2=[r2]
    nop.i  0 ;;
}
{
    addl   r2=0x0000000000000008, gp ;;
    ld8    r2=[r2]
    nop.i  0 ;;
}
{
    addl   r2=0x0000000000000010, gp ;;
    ld8    r2=[r2]
    nop.i  0 ;;
}
{
    addl   r2=0x0000000000000020, gp ;;
    ld8    r2=[r2]
    nop.i  0 ;;
}
{
    addl   r2=0x0000000000000040, gp ;;
    ld8    r2=[r2]
    nop.i  0 ;;
}
{
    addl   r2=0x0000000000000080, gp ;;
    ld8    r2=[r2]
    nop.i  0 ;;
}
{
    addl   r2=0x0000000000000100, gp ;;
    ld8    r2=[r2]
    nop.i  0 ;;
}
{
    addl   r2=0x0000000000000200, gp ;;
    ld8    r2=[r2]
    nop.i  0 ;;
}
{
    addl   r2=0x0000000000000400, gp ;;
    ld8    r2=[r2]
    nop.i  0 ;;
}
{
    addl   r2=0x0000000000000800, gp ;;
    ld8    r2=[r2]
    nop.i  0 ;;
}
{
    addl   r2=0x0000000000001000, gp ;;
    ld8    r2=[r2]
    nop.i  0 ;;
}
{
    addl   r2=0x0000000000002000, gp ;;
    ld8    r2=[r2]
    nop.i  0 ;;
}
{
    addl   r2=0x0000000000004000, gp ;;
    ld8    r2=[r2]
    nop.i  0 ;;
}
{
    addl   r2=0x0000000000008000, gp ;;
    ld8    r2=[r2]
    nop.i  0 ;;
}
{
    addl   r2=0x0000000000010000, gp ;;
    ld8    r2=[r2]
    nop.i  0 ;;
}
{
    addl   r2=0x0000000000020000, gp ;;
    ld8    r2=[r2]
    nop.i  0 ;;
}
{
    addl   r2=0x0000000000040000, gp ;;
    ld8    r2=[r2]
    nop.i  0 ;;
}
{
    addl   r2=0x0000000000080000, gp ;;
    ld8    r2=[r2]
    nop.i  0 ;;
}
{
    addl   r2=0x0000000000100000, gp ;;
    ld8    r2=[r2]
    nop.i  0 ;;
}
{
    addl   r2=0xffffffffffe00000, gp ;;
    ld8    r2=[r2]
    nop.i  0 ;;
}

    data4       0
    .align 64

    .align 64                                           ;
    .proc  Fore1#
Fore1:
    brl         Fore2
    .endp  Fore1#

    data4       0
    .align 64

    .proc  Fore2#
Fore2:
    brl         Fore3
    .endp  Fore2#

    data4       0
    .align 64

    .proc  Fore3#
Fore3:
    brl         Fore3
    movl        gp = 0xffffffffffffffff
    brl         Fore4
    movl        gp = 0x0000000000000000
    movl        gp = 0x0000000000000001
    movl        gp = 0x0000000000000002
    movl        gp = 0x0000000000000004
    movl        gp = 0x0000000000000008
    movl        gp = 0x0000000000000010
    movl        gp = 0x0000000000000020
    movl        gp = 0x0000000000000040
    movl        gp = 0x0000000000000080
    movl        gp = 0x0000000000000100
    movl        gp = 0x0000000000000200
    movl        gp = 0x0000000000000400
    movl        gp = 0x0000000000000800
    movl        gp = 0x0000000000001000
    movl        gp = 0x0000000000002000
    movl        gp = 0x0000000000004000
    brl         Fore4
    movl        gp = 0x0000000000000000
    brl         Fore4
    movl        gp = 0x0000000000000001
    brl         Fore4
    movl        gp = 0x0000000000000002
    brl         Fore4
    movl        gp = 0x0000000000000004
    brl         Fore4
    movl        gp = 0x0000000000000008
    brl         Fore4
    movl        gp = 0x0000000000000010
    brl         Fore4
    movl        gp = 0x0000000000000020
    brl         Fore4
    movl        gp = 0x0000000000000040
    brl         Fore4
    movl        gp = 0x0000000000000080
    brl         Fore4
    movl        gp = 0x0000000000000100
    brl         Fore4
    movl        gp = 0x0000000000000200
    brl         Fore4
    movl        gp = 0x0000000000000400
    brl         Fore4
    movl        gp = 0x0000000000000800
    brl         Fore4
    movl        gp = 0x0000000000001000
    brl         Fore4
    movl        gp = 0x0000000000002000
    brl         Fore4
    movl        gp = 0x0000000000004000
    brl         Fore4
    movl        gp = 0x0000000000008000
    brl         Fore4
    movl        gp = 0x0000000000010000
    brl         Fore4
    movl        gp = 0x0000000000020000
    brl         Fore4
    movl        gp = 0x0000000000040000
    brl         Fore4
    movl        gp = 0x0000000000080000
    brl         Fore4
    movl        gp = 0x0000000000100000
    brl         Fore4
    movl        gp = 0x0000000000200000
    brl         Fore4
    movl        gp = 0x0000000000400000
    brl         Fore4
    movl        gp = 0x0000000000800000
    brl         Fore4
    movl        gp = 0x0000000001000000
    brl         Fore4
    movl        gp = 0x0000000002000000
    brl         Fore4
    movl        gp = 0x0000000004000000
    brl         Fore4
    movl        gp = 0x0000000008000000
    brl         Fore4
    movl        gp = 0x0000000010000000
    brl         Fore4
    movl        gp = 0x0000000020000000
    brl         Fore4
    movl        gp = 0x0000000040000000
    brl         Fore4
    movl        gp = 0x0000000080000000
    brl         Fore4
    movl        gp = 0x0000000100000000
    brl         Fore4
    movl        gp = 0x0000000200000000
    brl         Fore4
    movl        gp = 0x0000000400000000
    brl         Fore4
    movl        gp = 0x0000000800000000
    brl         Fore4
    movl        gp = 0x0000001000000000
    brl         Fore4
    movl        gp = 0x0000002000000000
    brl         Fore4
    movl        gp = 0x0000004000000000
    brl         Fore4
    movl        gp = 0x0000008000000000
    brl         Fore4
    movl        gp = 0x0000010000000000
    brl         Fore4
    movl        gp = 0x0000020000000000
    brl         Fore4
    movl        gp = 0x0000040000000000
    brl         Fore4
    movl        gp = 0x0000080000000000
    brl         Fore4
    movl        gp = 0x0000100000000000
    brl         Fore4
    movl        gp = 0x0000200000000000
    brl         Fore4
    movl        gp = 0x0000400000000000
    brl         Fore4
    movl        gp = 0x0000800000000000
    brl         Fore4
    movl        gp = 0x0001000000000000
    brl         Fore4
    movl        gp = 0x0002000000000000
    brl         Fore4
    movl        gp = 0x0004000000000000
    brl         Fore4
    movl        gp = 0x0008000000000000
    brl         Fore4
    movl        gp = 0x0010000000000000
    brl         Fore4
    movl        gp = 0x0020000000000000
    brl         Fore4
    movl        gp = 0x0040000000000000
    brl         Fore4
    movl        gp = 0x0080000000000000
    brl         Fore4
    movl        gp = 0x0100000000000000
    brl         Fore4
    movl        gp = 0x0200000000000000
    brl         Fore4
    movl        gp = 0x0400000000000000
    brl         Fore4
    movl        gp = 0x0800000000000000
    brl         Fore4
    movl        gp = 0x1000000000000000
    brl         Fore4
    movl        gp = 0x2000000000000000
    brl         Fore4
    movl        gp = 0x4000000000000000
    brl         Fore4
    movl        gp = 0x8000000000000000
    brl         Fore4
    movl        gp = 0xffffffffffffffff
    brl         Fore4
    movl        gp = 0x0000000000000000
    brl         Fore4
    movl        gp = 0xfffffffffffffffe
    brl         Fore4
    movl        gp = 0xfffffffffffffffc
    brl         Fore4
    movl        gp = 0xfffffffffffffff8
    brl         Fore4
    movl        gp = 0xfffffffffffffff0
    brl         Fore4
    movl        gp = 0xffffffffffffffe0
    brl         Fore4
    movl        gp = 0xffffffffffffffc0
    brl         Fore4
    movl        gp = 0xffffffffffffff80
    brl         Fore4
    movl        gp = 0xffffffffffffff00
    brl         Fore4
    movl        gp = 0xfffffffffffffe00
    brl         Fore4
    movl        gp = 0xfffffffffffffc00
    brl         Fore4
    movl        gp = 0xfffffffffffff800
    brl         Fore4
    movl        gp = 0xfffffffffffff000
    brl         Fore4
    movl        gp = 0xffffffffffffe000
    brl         Fore4
    movl        gp = 0xffffffffffffc000
    brl         Fore4
    movl        gp = 0xffffffffffff8000
    brl         Fore4
    movl        gp = 0xffffffffffff0000
    brl         Fore4
    movl        gp = 0xfffffffffffe0000
    brl         Fore4
    movl        gp = 0xfffffffffffc0000
    brl         Fore4
    movl        gp = 0xfffffffffff80000
    brl         Fore4
    movl        gp = 0xfffffffffff00000
    brl         Fore4
    movl        gp = 0xffffffffffe00000
    brl         Fore4
    movl        gp = 0xffffffffffc00000
    brl         Fore4
    movl        gp = 0xffffffffff800000
    brl         Fore4
    movl        gp = 0xffffffffff000000
    brl         Fore4
    movl        gp = 0xfffffffffe000000
    brl         Fore4
    movl        gp = 0xfffffffffc000000
    brl         Fore4
    movl        gp = 0xfffffffff8000000
    brl         Fore4
    movl        gp = 0xfffffffff0000000
    brl         Fore4
    movl        gp = 0xffffffffe0000000
    brl         Fore4
    movl        gp = 0xffffffffc0000000
    brl         Fore4
    movl        gp = 0xffffffff80000000
    brl         Fore4
    movl        gp = 0xffffffff00000000
    brl         Fore4
    movl        gp = 0xfffffffe00000000
    brl         Fore4
    movl        gp = 0xfffffffc00000000
    brl         Fore4
    movl        gp = 0xfffffff800000000
    brl         Fore4
    movl        gp = 0xfffffff000000000
    brl         Fore4
    movl        gp = 0xffffffe000000000
    brl         Fore4
    movl        gp = 0xffffffc000000000
    brl         Fore4
    movl        gp = 0xffffff8000000000
    brl         Fore4
    movl        gp = 0xffffff0000000000
    brl         Fore4
    movl        gp = 0xfffffe0000000000
    brl         Fore4
    movl        gp = 0xfffffc0000000000
    brl         Fore4
    movl        gp = 0xfffff80000000000
    brl         Fore4
    movl        gp = 0xfffff00000000000
    brl         Fore4
    movl        gp = 0xffffe00000000000
    brl         Fore4
    movl        gp = 0xffffc00000000000
    brl         Fore4
    movl        gp = 0xffff800000000000
    brl         Fore4
    movl        gp = 0xffff000000000000
    brl         Fore4
    movl        gp = 0xfffe000000000000
    brl         Fore4
    movl        gp = 0xfffc000000000000
    brl         Fore4
    movl        gp = 0xfff8000000000000
    brl         Fore4
    movl        gp = 0xfff0000000000000
    brl         Fore4
    movl        gp = 0xffe0000000000000
    brl         Fore4
    movl        gp = 0xffc0000000000000
    brl         Fore4
    movl        gp = 0xff80000000000000
    brl         Fore4
    movl        gp = 0xff00000000000000
    brl         Fore4
    movl        gp = 0xfe00000000000000
    brl         Fore4
    movl        gp = 0xfc00000000000000
    brl         Fore4
    movl        gp = 0xf800000000000000
    brl         Fore4
    movl        gp = 0xf000000000000000
    brl         Fore4
    movl        gp = 0xe000000000000000
    brl         Fore4
    movl        gp = 0xc000000000000000
    brl         Fore4
    movl        gp = 0x8000000000000000
    brl         Fore4
    movl        gp = 0x0000000000000000
    brl         Fore4
    movl        gp = 0x0000000000000000
    brl         Fore4
    brl.sptk.many Fore4
    brl.sptk.many Fore4
    brl.sptk.many Fore4
    brl.sptk.many Fore4

    movl        gp = 0xf0f0f0f0f0f0f0f0
    brl.sptk.many Fore9
Fore9:
    brl.sptk.few Fore8
Fore8:
    brl.sptk.few Fore8
    brl.sptk.few Fore8
    brl.sptk.few Fore8
    data1       0x05,0x00,0x00,0x00,0x01,0x00,0xff,0xff,0xff,0xff,0x7f,0x00,0xf0,0xff,0xff,0xc8
    data1       0x05,0x00,0x00,0x00,0x01,0x00,0xff,0xff,0xff,0xff,0x7f,0x00,0xf0,0xff,0xff,0xc0
    data1       0x05,0x00,0x00,0x00,0x01,0x00,0xff,0xff,0xff,0xff,0x7f,0x00,0xf0,0xff,0xff,0xc8
    data1       0x05,0x00,0x00,0x00,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xc0
    data1       0x04,0x00,0x00,0x00,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xc0
    data1       0x25,0x00,0x00,0x00,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xc0
    data1       0x45,0x00,0x00,0x00,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xc0
    data1       0x85,0x00,0x00,0x00,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xc0
    data1       0x05,0x01,0x00,0x00,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xc0
    data1       0x05,0x02,0x00,0x00,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xc0
    data1       0x05,0x04,0x00,0x00,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xc0
    data1       0x05,0x08,0x00,0x00,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xc0
    data1       0x05,0x10,0x00,0x00,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xc0
    data1       0x05,0x20,0x00,0x00,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xc0
    data1       0x05,0x40,0x00,0x00,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xc0
    data1       0x05,0x80,0x00,0x00,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xc0
    data1       0x05,0x00,0x01,0x00,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xc0
    data1       0x05,0x00,0x02,0x00,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xc0
    data1       0x05,0x00,0x04,0x00,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xc0
    data1       0x05,0x00,0x08,0x00,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xc0
    data1       0x05,0x00,0x10,0x00,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xc0
    data1       0x05,0x00,0x20,0x00,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xc0
    data1       0x05,0x00,0x40,0x00,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xc0
    data1       0x05,0x00,0x80,0x00,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xc0
    data1       0x05,0x00,0x00,0x01,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xc0
    data1       0x05,0x00,0x00,0x02,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xc0
    data1       0x05,0x00,0x00,0x04,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xc0
    data1       0x05,0x00,0x00,0x08,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xc0
    data1       0x05,0x00,0x00,0x10,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xc0
    data1       0x05,0x00,0x00,0x20,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xc0
    data1       0x05,0x00,0x00,0x40,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xc0
    data1       0x05,0x00,0x00,0x80,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xc0
    data1       0x05,0x00,0x00,0x00,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xc0
    data1       0x05,0x00,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xc0
    data1       0x05,0x00,0x00,0x00,0x05,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xc0
    data1       0x05,0x00,0x00,0x00,0x09,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xc0
    data1       0x05,0x00,0x00,0x00,0x11,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xc0
    data1       0x05,0x00,0x00,0x00,0x21,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xc0
    data1       0x05,0x00,0x00,0x00,0x41,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xc0
    data1       0x05,0x00,0x00,0x00,0x81,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xc0
    data1       0x05,0x00,0x00,0x00,0x01,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xc0
    data1       0x05,0x00,0x00,0x00,0x01,0x02,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xc0
    data1       0x05,0x00,0x00,0x00,0x01,0x04,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xc0
    data1       0x05,0x00,0x00,0x00,0x01,0x08,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xc0
    data1       0x05,0x00,0x00,0x00,0x01,0x10,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xc0
    data1       0x05,0x00,0x00,0x00,0x01,0x20,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xc0
    data1       0x05,0x00,0x00,0x00,0x01,0x40,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xc0
    data1       0x05,0x00,0x00,0x00,0x01,0x80,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xc0
    data4       0xffffffff
    data4       0xffffffff
    data4       0xffffffff
    data4       0xffffffff
    movl        gp = 0xf0f0f0f0f0f0f0f0

{   .mii
        nop.m 0
        nop.i 0
        nop.i 0
}
{   .mmi
        nop.m 0
        nop.m 0
        nop.i 0
}
{ .mmb
        nop.m 0
        nop.m 0
        nop.b 0
}
{ .mmf
        nop.m 0
        nop.m 0
        nop.f 0
}
{ .mbb
        nop.m 0
        nop.b 0
        nop.b 0
}
    movl        gp = 0x0000000000000000
{ .mlx
    flushrs
    movl        gp = 0x0000000000000000
}
    movl        gp = 0x0000000000000000
    .endp  Fore3#

    data4       0
    .align 64

    .proc  Fore4#
Fore4:
    movl        gp = 0x0000000000000000
    brl         Fore5
    .endp  Fore4#

    data4       0
    .align 64

    data4       0
    .align 64

    .proc  Fore5#
Fore5:
    movl        gp = 0xffffffffffffffff
    brl         Fore6
    .endp  Fore5#

    data4       0
    .align 64

    .proc  Fore6#
Fore6:
    movl        gp = 0x0000000000000000
    brl         Fore7
    .endp  Fore6#

    data4       0
    .align 64

    .proc  Fore7#
Fore7:
    movl        gp = 0xffffffffffffffff
    brl         Fore6
    brl.call.dptk.many b0=Fore6
    br.call.dptk.many b0=Fore6
    br.ret.dpnt.many b0
    br.ret.dptk.many b0
    br.ret.spnt.many b0
    br.ret.sptk.many b0
    .endp  Fore7#

    data4       0
    .align 64

    .proc  Call8#
Call8:
{
        alloc  r41=ar.pfs, 10, 0, 8, 0
        adds   r49=0, r39
        mov    r40=rp
}
{
        adds   r48=0, r38
        adds   r47=0, r37
        adds   r46=0, r36 ;;
}
{
        adds   r45=0, r35
        adds   r44=0, r34
        adds   r43=0, r33
}
{
        movl   gp = 0xffffffffffffffff ;;
}
{
        adds   r42=0, r32
        brl.call.sptk.few rp=Call8Real  ;;
}
Call8Real:
{
        movl   gp = 0xffffffffffffffff ;;
}
{
        nop.m  0
        mov    rp=r40, +0 ;;
        mov.i  ar.pfs=r41
}
{
        nop.m  0
        nop.m  0
        br.ret.sptk.many rp ;;
}
    .endp  Call8#

    data4       0
    .align 64

    .proc  Pass8#
Pass8:
{
        alloc  r41=ar.pfs, 11, 0, 8, 0
        mov    r40=rp
}
{
        adds   r50=0, r39
        adds   r49=0, r38
        adds   r48=0, r37 ;;
}
{
        adds   r47=0, r36
        adds   r46=0, r35
        adds   r45=0, r34
}
{
        adds   r44=0, r33
        adds   r43=0, r32
        adds   r42=0, gp  ;;
}
{
        movl   gp = 0xffffffffffffffff ;;
}
{
        brl.call.sptk.few rp=Pass8Real  ;;
}
Pass8Real:
{
        adds   gp=0, r42
        mov    rp=r40, +0 ;;
        mov.i  ar.pfs=r41
}
{
        nop.m  0
        nop.m  0
        br.ret.sptk.many rp ;;
}
    .endp  Pass8#

    data4       0
    .align 64

    .proc  Last#
Last:
    data4       0xffffffff
    data4       0xffffffff
    data4       0xffffffff
    data4       0xffffffff
    .skip       0x1000
    data4       0xffffffff
    data4       0xffffffff
    data4       0xffffffff
    data4       0xffffffff
    .endp  Last#

// End

```

`samples/disas/unk.cpp`:

```cpp
/////////////////////////////////////////////////////////////////////////////
//
//  Detours Test Program (x86.asm of disas.exe)
//
//  Microsoft Research Detours Package
//
//  Copyright (c) Microsoft Corporation.  All rights reserved.
//

static int value = 0;

extern "C" void TestCodes()
{
    value++;
}

```

`samples/disas/x64.asm`:

```asm
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
;;  Detours Test Program (x64.asm/disas.exe)
;;
;;  Microsoft Research Detours Package
;;
;;  Copyright (c) Microsoft Corporation.  All rights reserved.
;;

.xlist
.list
.code

PUBLIC  TestCodes

_TEXT   SEGMENT

TestCodes   PROC

begin:
faraway:
        int 3
        nop
        int 3
        db      066h,090h ; // 2-byte NOP.
        int 3
        db      00fh, 01fh, 000h ; // 3-byte NOP.
        int 3
        db      00fh, 01fh, 040h, 000h ; // 4-byte NOP.
        int 3
        db      00fh, 01fh, 044h, 000h, 000h ; // 5-byte NOP.
        int 3
        db      066h, 00fh, 01fh, 044h, 000h, 000h ; // 6-byte NOP.
        int 3
        db      00fh, 01fh, 080h, 000h, 000h, 000h, 000h ; // 7-byte NOP.
        int 3
        db      00fh, 01fh, 084h, 000h, 000h, 000h, 000h, 000h ; // 8-byte NOP.
        int 3
        db      066h, 00fh, 01fh, 084h, 000h, 000h, 000h, 000h, 000h ; // 9-byte NOP.
        int 3
        mov     rax, cr8
        int 3
        mov     rcx, cr8
        int 3
        mov     rdx, cr8
        int 3
        mov     rbx, cr8
        int 3
        mov     rsp, cr8
        int 3
        mov     rbp, cr8
        int 3
        mov     rsi, cr8
        int 3
        mov     rdi, cr8
        int 3
        mov     r8, cr8
        int 3
        mov     r9, cr8
        int 3
        mov     r10, cr8
        int 3
        mov     r11, cr8
        int 3
        mov     r12, cr8
        int 3
        mov     r13, cr8
        int 3
        mov     r14, cr8
        int 3
        mov     r15, cr8
        int 3
        mov     cr8, rax
        int 3
        mov     cr8, rcx
        int 3
        mov     cr8, rdx
        int 3
        mov     cr8, rbx
        int 3
        mov     cr8, rsp
        int 3
        mov     cr8, rbp
        int 3
        mov     cr8, rsi
        int 3
        mov     cr8, rdi
        int 3
        mov     cr8, r8
        int 3
        mov     cr8, r9
        int 3
        mov     cr8, r10
        int 3
        mov     cr8, r11
        int 3
        mov     cr8, r12
        int 3
        mov     cr8, r13
        int 3
        mov     cr8, r14
        int 3
        mov     cr8, r15
        int 3
        xor     rax, rax
        int 3
        xor     rcx, rcx
        int 3
        xor     rdx, rdx
        int 3
        xor     rbx, rbx
        int 3
        xor     rsp, rsp
        int 3
        xor     rbp, rbp
        int 3
        xor     rsi, rsi
        int 3
        xor     rdi, rdi
        int 3
        xor     r8, r8
        int 3
        xor     r9, r9
        int 3
        xor     r10, r10
        int 3
        xor     r11, r11
        int 3
        xor     r12, r12
        int 3
        xor     r13, r13
        int 3
        xor     r14, r14
        int 3
        xor     r15, r15
        int 3
        jmp     rax
        int 3
        jmp     rbx
        int 3
        jmp     rcx
        int 3
        jmp     rdx
        int 3
        push    rax
        int 3
        push    rbx
        int 3
        push    rcx
        int 3
        push    rdx
        int 3
        push    0
        int 3
        pop     rax
        int 3
        pop     rbx
        int 3
        pop     rcx
        int 3
        pop     rdx
        int 3
        mov     rax,[value]
        int 3
        sub     rsp,0418h
        int 3
        mov     [rsp+0410h],rbx
        int 3
        mov     [rsp+0408h],rsi
        int 3
        mov     [rsp+0400h],rdi
        int 3
        mov     [rsp+03f8h],r12
        int 3
        mov     [rsp+03f0h],r13
        int 3
        mov     [rsp+03e8h],r14
        int 3
        mov     [rsp+03e0h],r15
        int 3
        add     [rax],al                                ; 0000
        int 3
        add     [rcx],al                                ; 0001
        int 3
        add     [rbx],al                                ; 0003
        int 3
        add     [rax+rax],al                            ; 000400
        int 3
        add     [rdi],al                                ; 0007
        int 3
        add     [rax],cl                                ; 0008
        int 3
        add     [rdi],cl                                ; 000f
        int 3
        add     [rax],dl                                ; 0010
        int 3
        add     [rdi],bl                                ; 001f
        int 3
        add     [rax],ah                                ; 0020
        int 3
        add     [rdi],bh                                ; 003f
        int 3
        add     [rax+03bh],cl                           ; 00483b
        int 3
        add     [rdi],bh                                ; 007f00
        int 3
        add     [rax+040000000h],al                     ; 008000000040
        int 3
        add     bh,bh                                   ; 00ff
        int 3
        add     [rax],eax                               ; 0100
        int 3
        add     al,[rax]                                ; 0200
        int 3
        add     eax,06603ebc3h                          ; 05c3eb0366
        int 3
        syscall                                         ; 0f05
        int 3
        prefetchw      byte ptr [rcx]                   ; 0f0d09
        int 3
        prefetchnta    byte ptr [rcx]                   ; 0f1801
        int 3
        prefetchnta    byte ptr [rax+rdx]               ; 0f180410
        int 3
        jb             again                            ; 0f8247070000
        int 3
        jnb            again                            ; 0f8306050000
        int 3
        je             again                            ; 0f8432010000
        int 3
        jne            again                            ; 0f8508010000
        int 3
        jnbe           again                            ; 0f878a000000
        int 3
        ldmxcsr        dword ptr [rcx+034h]             ; 0fae5134
        int 3
        stmxcsr        dword ptr [rcx+034h]             ; 0fae5934
        int 3
        and            ecx,[rdx+rbx*4]                  ; 230c9a
        int 3
        xor            eax,eax                          ; 33c0
        int 3
        xor            ecx,ecx                          ; 33c9
        int 3
        xor            edx,ecx                          ; 33d1
        int 3
        xor            edx,edx                          ; 33d2
        int 3
        add            r10d,010001h                     ; 4181c201000100
        int 3
        and            r11d,0ffffh                      ; 4181e3ffff0000
        int 3
        mov            eax,r8d                          ; 418bc0
        int 3
        mov            byte ptr [r11],00h               ; 41c60300
        int 3
        call           qword ptr [r9+030h]              ; 41ff5130
        int 3
        call           qword ptr [r9+r8*8]              ; 43ff14c1
        int 3
        mov            [rcx+034h],r8d                   ; 44894134
        int 3
        mov            [rsp+030h],r9d                   ; 44894c2430
        int 3
        mov            r8d,[rcx]                        ; 448b01
        int 3
        mov            r9d,[rcx]                        ; 448b09
        int 3
        mov            r8d,[rax+058h]                   ; 448b4058
        int 3
        mov            r8d,[rsp+02ch]                   ; 448b44242c
        int 3
        mov            r8d,eax                          ; 448bc0
        int 3
        mov            r8d,edx                          ; 448bc2
        int 3
        xor            r8b,r8b                          ; 4532c0
        int 3
        mov            r9d,r8d                          ; 458bc8
        int 3
        lea            r11d,[r9+rax]                    ; 458d1c01
        int 3
        add            rdx,rcx                          ; 4803d1
        int 3
        or             rsi,rdx                          ; 480bf2
        int 3
        movnti         [rcx],rax                        ; 480fc301
        int 3
        and            rax,0fe000000h                   ; 4825000000fe
        int 3
        sub            rax,rcx                          ; 482bc1
        int 3
        sub            rdx,rcx                          ; 482bd1
        int 3
        cmp            rdi,rbp                          ; 483bfd
        int 3
        push           rbp                              ; 4855
        int 3
        add            rcx,03d0h                        ; 4881c1d0030000
        int 3
        add            rsp,0c8h                         ; 4881c4c8000000
        int 3
        and            rdx,0fe000000h                   ; 4881e2000000fe
        int 3
        sub            rsp,0c8h                         ; 4881ecc8000000
        int 3
        sub            rsp,03d0h                        ; 4881ecd0030000
        int 3
        add            rax,040h                         ; 4883c040
        int 3
        add            rcx,08h                          ; 4883c108
        int 3
        add            rcx,040h                         ; 4883c140
        int 3
        add            rsp,08h                          ; 4883c408
        int 3
        add            rsi,09h                          ; 4883c609
        int 3
        add            rdi,01h                          ; 4883c701
        int 3
        and            rcx,0f8h                         ; 4883e1f8
        int 3
        sub            rax,040h                         ; 4883e840
        int 3
        sub            rdx,08h                          ; 4883ea08
        int 3
        sub            rdx,040h                         ; 4883ea40
        int 3
        sub            rsp,08h                          ; 4883ec08
        int 3
        sub            rsi,08h                          ; 4883ee08
        int 3
        sub            rdi,01h                          ; 4883ef01
        int 3
        test           rax,rax                          ; 4885c0
        int 3
        test           rdx,rdx                          ; 4885d2
        int 3
        mov            [rsp],rax                        ; 48890424
        int 3
        mov            [rsp],rbp                        ; 48892c24
        int 3
        mov            [rsp],rsi                        ; 48893424
        int 3
        mov            [rsp],rdi                        ; 48893c24
        int 3
        mov            [rcx+08h],rax                    ; 48894108
        int 3
        mov            [rcx+078h],rax                   ; 48894178
        int 3
        mov            [rcx-08h],rax                    ; 488941f8
        int 3
        mov            [rsp+018h],rax                   ; 4889442418
        int 3
        mov            [rcx+010h],rdx                   ; 48895110
        int 3
        mov            [rsp+08h],rbx                    ; 48895c2408
        int 3
        mov            [rsp+018h],rsi                   ; 4889742418
        int 3
        mov            [rsp+08h],rdi                    ; 48897c2408
        int 3
        mov            [rsp+010h],rdi                   ; 48897c2410
        int 3
        mov            [rcx+098h],rax                   ; 48898198000000
        int 3
        mov            [rcx+080h],rcx                   ; 48898980000000
        int 3
        mov            [rcx+088h],rdx                   ; 48899188000000
        int 3
        mov            [rcx+090h],rbx                   ; 48899990000000
        int 3
        mov            [rcx+0a0h],rbp                   ; 4889a9a0000000
        int 3
        mov            [rcx+0a8h],rsi                   ; 4889b1a8000000
        int 3
        mov            [rcx+0b0h],rdi                   ; 4889b9b0000000
        int 3
        mov            rax,[rcx]                        ; 488b01
        int 3
        mov            rax,[rcx+rdx]                    ; 488b0411
        int 3
        mov            rax,[value]                      ; 488b05318c0100
        int 3
        mov            rcx,[rsp]                        ; 488b0c24
        int 3
        mov            rsi,[rsp]                        ; 488b3424
        int 3
        mov            rdi,[rsp]                        ; 488b3c24
        int 3
        mov            rax,[rax+018h]                   ; 488b4018
        int 3
        mov            rax,[rcx+078h]                   ; 488b4178
        int 3
        mov            rax,[rdx+020h]                   ; 488b4220
        int 3
        mov            rax,[rsp+08h]                    ; 488b442408
        int 3
        mov            rcx,[rcx+08h]                    ; 488b4908
        int 3
        mov            rcx,[rsp+020h]                   ; 488b4c2420
        int 3
        mov            rdx,[rsp+08h]                    ; 488b542408
        int 3
        mov            rdi,[rsp+08h]                    ; 488b7c2408
        int 3
        mov            rax,[rcx+098h]                   ; 488b8198000000
        int 3
        mov            rax,[rcx+0f8h]                   ; 488b81f8000000
        int 3
        cmp            ebx,0                            ;
        int 3
        cmp            rbx,0                            ;
        int 3
        cmp            byte ptr [value],77h             ; 803d........77
        int 3
        cmp            dword ptr [value],77h            ; 833d........77
        int 3
        cmp            qword ptr [value],77h            ; 48833d........77
        int 3
        cmp            dword ptr [value],77777777h      ; 813d........77777777
        int 3
        cmp            qword ptr [value],77777777h      ; 48813d........77777777
        int 3
nearby:
        jo      nearby                                  ; 70xx
        int 3
        jno     nearby                                  ; 71xx
        int 3
        jb      nearby                                  ; 72xx
        int 3
        jae     nearby                                  ; 73xx
        int 3
        je      nearby                                  ; 74xx
        int 3
        jne     nearby                                  ; 75xx
        int 3
        jbe     nearby                                  ; 76xx
        int 3
        ja      nearby                                  ; 77xx
        int 3
        js      nearby                                  ; 78xx
        int 3
        jns     nearby                                  ; 79xx
        int 3
        jp      nearby                                  ; 7axx
        int 3
        jnp     nearby                                  ; 7bxx
        int 3
        jl      nearby                                  ; 7cxx
        int 3
        jge     nearby                                  ; 7dxx
        int 3
        jle     nearby                                  ; 7exx
        int 3
        jg      nearby                                  ; 7fxx
        int 3
        jmp     nearby                                  ; ebxx

        int 3
        jo      faraway                                 ; 0f80xxxxxxxx
        int 3
        jno     faraway                                 ; 0f81xxxxxxxx
        int 3
        jb      faraway                                 ; 0f82xxxxxxxx
        int 3
        jae     faraway                                 ; 0f83xxxxxxxx
        int 3
        je      faraway                                 ; 0f84xxxxxxxx
        int 3
        jne     faraway                                 ; 0f85xxxxxxxx
        int 3
        jbe     faraway                                 ; 0f86xxxxxxxx
        int 3
        ja      faraway                                 ; 0f87xxxxxxxx
        int 3
        js      faraway                                 ; 0f88xxxxxxxx
        int 3
        jns     faraway                                 ; 0f89xxxxxxxx
        int 3
        jp      faraway                                 ; 0f8axxxxxxxx
        int 3
        jnp     faraway                                 ; 0f8bxxxxxxxx
        int 3
        jl      faraway                                 ; 0f8cxxxxxxxx
        int 3
        jge     faraway                                 ; 0f8dxxxxxxxx
        int 3
        jle     faraway                                 ; 0f8exxxxxxxx
        int 3
        jg      faraway                                 ; 0f8fxxxxxxxx
        int 3
        jmp     faraway                                 ; e9xxxxxxxx

        int 3
        lea     rax,[rsp]                               ; 488d0424        
        int 3
        mov rcx,0BADC0DEBA5Eh                           ;  48b95ebadec0ad0b0000 
        int 3
        cmp     rax,rcx                                 ;  483bc1

        int 3
        sub rsp, 28h
        int 3
        add rsp,28h
        int 3
        ret
        int 3


;; The list is terminated by two "int 3" in a row.
again:
        int 3
        int 3
TestCodes   ENDP

value   QWORD   0

_TEXT   ENDS
END

```

`samples/disas/x86.cpp`:

```cpp
/////////////////////////////////////////////////////////////////////////////
//
//  Detours Test Program (x86.asm of disas.exe)
//
//  Microsoft Research Detours Package
//
//  Copyright (c) Microsoft Corporation.  All rights reserved.
//

static int value = 0;

extern "C" void __declspec(naked) TestCodes()
{
    __asm {
// Each instruction is proceeded by an "int 3".
      faraway:
        int 3;
        nop;        // 1-byte NOP.
        int 3;
        _emit 0x66; // 2-byte NOP.
        _emit 0x90;
        int 3;
        _emit 0x0f; // 3-byte NOP.
        _emit 0x1f;
        _emit 0x00;
        int 3;
        _emit 0x0f; // 4-byte NOP.
        _emit 0x1f;
        _emit 0x40;
        _emit 0x00;
        int 3;
        _emit 0x0f; // 5-byte NOP.
        _emit 0x1f;
        _emit 0x44;
        _emit 0x00;
        _emit 0x00;
        int 3;
        _emit 0x66; // 6-byte NOP.
        _emit 0x0f;
        _emit 0x1f;
        _emit 0x44;
        _emit 0x00;
        _emit 0x00;
        int 3;
        _emit 0x0f; // 7-byte NOP.
        _emit 0x1f;
        _emit 0x80;
        _emit 0x00;
        _emit 0x00;
        _emit 0x00;
        _emit 0x00;
        int 3;
        _emit 0x0f; // 8-byte NOP.
        _emit 0x1f;
        _emit 0x84;
        _emit 0x00;
        _emit 0x00;
        _emit 0x00;
        _emit 0x00;
        _emit 0x00;
        int 3;
        _emit 0x66; // 9-byte NOP.
        _emit 0x0f;
        _emit 0x1f;
        _emit 0x84;
        _emit 0x00;
        _emit 0x00;
        _emit 0x00;
        _emit 0x00;
        _emit 0x00;
        int 3;
        mov     ecx, eax;
        int 3;
        mov     ebx, 0ffff000eh;
        int 3;
        call    ebx;
        int 3;
        call    dword ptr [eax];
        int 3;
        call    dword ptr [ebx];
        int 3;
        call    dword ptr [ecx];
        int 3;
        call    dword ptr [edx];
        int 3;
        jmp     dword ptr [eax];
        int 3;
        jmp     dword ptr [ebx];
        int 3;
        jmp     dword ptr [ecx];
        int 3;
        jmp     dword ptr [edx];
        int 3;
        call    ecx;
        int 3;
        call    eax;
        int 3;
        mov     ebx, 0ffff000eh;
        int 3;
        push    eax;
        int 3;
        call    ebx;
        int 3;
        cmp     ebx, 0;
        int 3;
        cmp     byte ptr [value], 77h;
        int 3;
        cmp     dword ptr [value], 77h;
        int 3;
        cmp     dword ptr [value], 77777777h;
      nearby:
        int 3
        jo      nearby                                  ; 70xx
        int 3
        jno     nearby                                  ; 71xx
        int 3
        jb      nearby                                  ; 72xx
        int 3
        jae     nearby                                  ; 73xx
        int 3
        je      nearby                                  ; 74xx
        int 3
        jne     nearby                                  ; 75xx
        int 3
        jbe     nearby                                  ; 76xx
        int 3
        ja      nearby                                  ; 77xx
        int 3
        js      nearby                                  ; 78xx
        int 3
        jns     nearby                                  ; 79xx
        int 3
        jp      nearby                                  ; 7axx
        int 3
        jnp     nearby                                  ; 7bxx
        int 3
        jl      nearby                                  ; 7cxx
        int 3
        jge     nearby                                  ; 7dxx
        int 3
        jle     nearby                                  ; 7exx
        int 3
        jg      nearby                                  ; 7fxx

        int 3
        jo      faraway                                 ; 0f80xx
        int 3
        jno     faraway                                 ; 0f81xx
        int 3
        jb      faraway                                 ; 0f82xx
        int 3
        jae     faraway                                 ; 0f83xx
        int 3
        je      faraway                                 ; 0f84xx
        int 3
        jne     faraway                                 ; 0f85xx
        int 3
        jbe     faraway                                 ; 0f86xx
        int 3
        ja      faraway                                 ; 0f87xx
        int 3
        js      faraway                                 ; 0f88xx
        int 3
        jns     faraway                                 ; 0f89xx
        int 3
        jp      faraway                                 ; 0f8axx
        int 3
        jnp     faraway                                 ; 0f8bxx
        int 3
        jl      faraway                                 ; 0f8cxx
        int 3
        jge     faraway                                 ; 0f8dxx
        int 3
        jle     faraway                                 ; 0f8exx
        int 3
        jg      faraway                                 ; 0f8fxx

// The list is terminated by two "int 3" in a row.
        int 3;
        int 3;
        ret;
    }
}


```

`samples/dtest/Makefile`:

```
##############################################################################
##
##  Makefile for Detours Test Programs.
##
##  Microsoft Research Detours Package
##
##  Copyright (c) Microsoft Corporation.  All rights reserved.
##

!include ..\common.mak

LIBS=$(LIBS) kernel32.lib

all: dirs \
    $(BIND)\dtarge$(DETOURS_BITS).dll \
    $(BIND)\dtest.exe \
!IF $(DETOURS_SOURCE_BROWSING)==1
    $(OBJD)\dtarge$(DETOURS_BITS).bsc \
    $(OBJD)\dtest.bsc \
!ENDIF
    option

clean:
    -del *~ *.obj *.sbr 2> nul
    -del $(BIND)\dtest.* $(BIND)\dtarge*.* 2> nul
    -rmdir /q /s $(OBJD) 2>nul

realclean: clean
    -rmdir /q /s $(OBJDS) 2>nul

dirs:
    @if not exist $(BIND) mkdir $(BIND) && echo.   Created $(BIND)
    @if not exist $(OBJD) mkdir $(OBJD) && echo.   Created $(OBJD)

$(OBJD)\dtarge.obj : dtarge.cpp

$(OBJD)\dtarge.res : dtarge.rc

$(BIND)\dtarge$(DETOURS_BITS).dll $(BIND)\dtarge$(DETOURS_BITS).lib: \
        $(OBJD)\dtarge.obj $(OBJD)\dtarge.res $(DEPS)
    cl /LD $(CFLAGS) \
        /Fe$(@R).dll \
        /Fd$(@R).pdb \
        $(OBJD)\dtarge.obj $(OBJD)\dtarge.res \
        /link $(LINKFLAGS) /subsystem:console \
        /export:Target0 \
        /export:Target1 \
        /export:Target2 \
        /export:Target3 \
        /export:Target4 \
        /export:Target5 \
        /export:Target6 \
        /export:Target7 \
        /export:Target8 \
        /export:Target9 \
        /export:Target10 \
        /export:Target11 \
        /export:Target12 \
        /export:Target13 \
        /export:Target14 \
        /export:Target15 \
        /export:Target16 \
        /export:TargetV \
        /export:TargetR \
        $(LIBS)

$(OBJD)\dtarge$(DETOURS_BITS).bsc : $(OBJD)\dtarge.obj
    bscmake /v /n /o $@ $(OBJD)\dtarge.sbr

$(OBJD)\dtest.obj : dtest.cpp

$(BIND)\dtest.exe : $(OBJD)\dtest.obj $(BIND)\dtarge$(DETOURS_BITS).lib $(DEPS)
    cl $(CFLAGS) /Fe$@ /Fd$(@R).pdb $(OBJD)\dtest.obj \
        /link $(LINKFLAGS) $(LIBS) $(BIND)\dtarge$(DETOURS_BITS).lib \
        /subsystem:console /entry:WinMainCRTStartup

$(OBJD)\dtest.bsc : $(OBJD)\dtest.obj
    bscmake /v /n /o $@ $(OBJD)\dtest.sbr

############################################### Install non-bit-size binaries.

!IF "$(DETOURS_OPTION_PROCESSOR)" != ""

$(OPTD)\dtarge$(DETOURS_OPTION_BITS).dll:
$(OPTD)\dtarge$(DETOURS_OPTION_BITS).pdb:

$(BIND)\dtarge$(DETOURS_OPTION_BITS).dll : $(OPTD)\dtarge$(DETOURS_OPTION_BITS).dll
    @if exist $? copy /y $? $(BIND) >nul && echo $@ copied from $(DETOURS_OPTION_PROCESSOR).
$(BIND)\dtarge$(DETOURS_OPTION_BITS).pdb : $(OPTD)\dtarge$(DETOURS_OPTION_BITS).pdb
    @if exist $? copy /y $? $(BIND) >nul && echo $@ copied from $(DETOURS_OPTION_PROCESSOR).

option: \
    $(BIND)\dtarge$(DETOURS_OPTION_BITS).dll \
    $(BIND)\dtarge$(DETOURS_OPTION_BITS).pdb \

!ELSE

option:

!ENDIF

##############################################################################

test: all
    $(BIND)\dtest.exe

################################################################# End of File.

```

`samples/dtest/NORMAL_IA64.TXT`:

```TXT
    ..\..\bin.IA64\dtest.exe
Calling LocalTarget1 w/o detour
  LocalTarget1 (1)
Calling LocalTarget1 w/ detour
  MyLocalTarget1 (2)
  LocalTarget1 (2)
Calling Target0 function.
  MyTarget0 ()
Calling TargetN functions.
  MyLocalTarget1 (1)
  LocalTarget1 (1)
  MyTarget0 ()
  MyTarget1 (1)
  MyTarget2 (1,2)
  MyTarget3 (1,2,3)
  MyTarget4 (1,2,3,4)
  MyTarget5 (1,2,3,4,5)
  MyTarget6 (1,2,3,4,5,6)
  MyTarget7 (1,2,3,4,5,6,7)
  MyTarget8 (1,2,3,4,5,6,7,8)
  MyTarget9 (1,2,3,4,5,6,7,8,9)
  MyTarget10(1,2,3,4,5,6,7,8,9,10)
  MyTarget11(1,2,3,4,5,6,7,8,9,10,11)
  MyTarget12(1,2,3,4,5,6,7,8,9,10,11,12)
  MyTarget13(1,2,3,4,5,6,7,8,9,10,11,12,13)
  MyTarget14(1,2,3,4,5,6,7,8,9,10,11,12,13,14)
  MyTarget15(1,2,3,4,5,6,7,8,9,10,11,12,13,14,15)
  MyTarget16(1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16)
  MyTargetV (0)
  MyTargetV (0,1)
  MyTargetV (0,1,2)
  MyTargetV (0,1,2,3)
  MyTargetV (0,1,2,3,4)
  MyTargetV (0,1,2,3,4,5)
  MyTargetV (0,1,2,3,4,5,6)
  MyTargetV (0,1,2,3,4,5,6,7)
  MyTargetV (0,1,2,3,4,5,6,7,8)
  MyTargetV (0,1,2,3,4,5,6,7,8,9)
  MyTargetV (0,1,2,3,4,5,6,7,8,9,10)
  MyTargetV (0,1,2,3,4,5,6,7,8,9,10,11)
  MyTargetV (0,1,2,3,4,5,6,7,8,9,10,11,12)
  MyTargetV (0,1,2,3,4,5,6,7,8,9,10,11,12,13)
  MyTargetV (0,1,2,3,4,5,6,7,8,9,10,11,12,13,14)
  MyTargetV (0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15)
  MyTargetV (0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16)
  MyTargetR (0,1,2,3,4)
  MyTargetR (0,1,2,3,3)
  MyTargetR (0,1,2,3,2)
  MyTargetR (0,1,2,3,1)
....................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................  MyTargetR (0,1,2,3,4,5,6,7,8,9,10,4)
  MyTargetR (0,1,2,3,4,5,6,7,8,9,10,3)
  MyTargetR (0,1,2,3,4,5,6,7,8,9,10,2)
  MyTargetR (0,1,2,3,4,5,6,7,8,9,10,1)
 => 3011
Calling Target0 again with 1 detour.
  MyTarget0 ()
Calling Target0 again with 2 detours.
  Starting Target0_1.
  MyTarget0 ()
  End Target0_1.
Calling Target0 again with 3 detours.
  Starting Target0_2.
  Starting Target0_1.
  MyTarget0 ()
  End Target0_1.
  End Target0_2.
Calling Target0 again with 4 detours.
  Starting Target0_3.
  Starting Target0_2.
  Starting Target0_1.
  MyTarget0 ()
  End Target0_1.
  End Target0_2.
  End Target0_3.
Done.
    Target0 ()
    Target0 ()
    Target1 (1)
    Target2 (1,2)
    Target3 (1,2,3)
    Target4 (1,2,3,4)
    Target5 (1,2,3,4,5)
    Target6 (1,2,3,4,5,6)
    Target7 (1,2,3,4,5,6,7)
    Target8 (1,2,3,4,5,6,7,8)
    Target9 (1,2,3,4,5,6,7,8,9)
    Target10(1,2,3,4,5,6,7,8,9,10)
    Target11(1,2,3,4,5,6,7,8,9,10,11)
    Target12(1,2,3,4,5,6,7,8,9,10,11,12)
    Target13(1,2,3,4,5,6,7,8,9,10,11,12,13)
    Target14(1,2,3,4,5,6,7,8,9,10,11,12,13,14)
    Target15(1,2,3,4,5,6,7,8,9,10,11,12,13,14,15)
    Target16(1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16)
    TargetV (0)
    TargetV (0,1)
    TargetV (0,1,2)
    TargetV (0,1,2,3)
    TargetV (0,1,2,3,4)
    TargetV (0,1,2,3,4,5)
    TargetV (0,1,2,3,4,5,6)
    TargetV (0,1,2,3,4,5,6,7)
    TargetV (0,1,2,3,4,5,6,7,8)
    TargetV (0,1,2,3,4,5,6,7,8,9)
    TargetV (0,1,2,3,4,5,6,7,8,9,10)
    TargetV (0,1,2,3,4,5,6,7,8,9,10,11)
    TargetV (0,1,2,3,4,5,6,7,8,9,10,11,12)
    TargetV (0,1,2,3,4,5,6,7,8,9,10,11,12,13)
    TargetV (0,1,2,3,4,5,6,7,8,9,10,11,12,13,14)
    TargetV (0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15)
    TargetV (0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16)
:::    TargetR (0,1,2,3,1)
:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::    TargetR (0,1,2,3,4,5,6,7,8,9,10,1)
    Target0 ()
    Target0 ()
    Target0 ()
    Target0 ()

```

`samples/dtest/NORMAL_X64.TXT`:

```TXT
    ..\..\bin.X64\dtest.exe
Calling LocalTarget1 w/o detour
  LocalTarget1 (1)
Calling LocalTarget1 w/ detour
  MyLocalTarget1 (2)
  LocalTarget1 (2)
Calling Target0 function.
  MyTarget0 ()
Calling TargetN functions.
  MyLocalTarget1 (1)
  LocalTarget1 (1)
  MyTarget0 ()
  MyTarget1 (1)
  MyTarget2 (1,2)
  MyTarget3 (1,2,3)
  MyTarget4 (1,2,3,4)
  MyTarget5 (1,2,3,4,5)
  MyTarget6 (1,2,3,4,5,6)
  MyTarget7 (1,2,3,4,5,6,7)
  MyTarget8 (1,2,3,4,5,6,7,8)
  MyTarget9 (1,2,3,4,5,6,7,8,9)
  MyTarget10(1,2,3,4,5,6,7,8,9,10)
  MyTarget11(1,2,3,4,5,6,7,8,9,10,11)
  MyTarget12(1,2,3,4,5,6,7,8,9,10,11,12)
  MyTarget13(1,2,3,4,5,6,7,8,9,10,11,12,13)
  MyTarget14(1,2,3,4,5,6,7,8,9,10,11,12,13,14)
  MyTarget15(1,2,3,4,5,6,7,8,9,10,11,12,13,14,15)
  MyTarget16(1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16)
  MyTargetV (0)
  MyTargetV (0,1)
  MyTargetV (0,1,2)
  MyTargetV (0,1,2,3)
  MyTargetV (0,1,2,3,4)
  MyTargetV (0,1,2,3,4,5)
  MyTargetV (0,1,2,3,4,5,6)
  MyTargetV (0,1,2,3,4,5,6,7)
  MyTargetV (0,1,2,3,4,5,6,7,8)
  MyTargetV (0,1,2,3,4,5,6,7,8,9)
  MyTargetV (0,1,2,3,4,5,6,7,8,9,10)
  MyTargetV (0,1,2,3,4,5,6,7,8,9,10,11)
  MyTargetV (0,1,2,3,4,5,6,7,8,9,10,11,12)
  MyTargetV (0,1,2,3,4,5,6,7,8,9,10,11,12,13)
  MyTargetV (0,1,2,3,4,5,6,7,8,9,10,11,12,13,14)
  MyTargetV (0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15)
  MyTargetV (0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16)
  MyTargetR (0,1,2,3,4)
  MyTargetR (0,1,2,3,3)
  MyTargetR (0,1,2,3,2)
  MyTargetR (0,1,2,3,1)
....................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................  MyTargetR (0,1,2,3,4,5,6,7,8,9,10,4)
  MyTargetR (0,1,2,3,4,5,6,7,8,9,10,3)
  MyTargetR (0,1,2,3,4,5,6,7,8,9,10,2)
  MyTargetR (0,1,2,3,4,5,6,7,8,9,10,1)
 => 3011
Calling Target0 again with 1 detour.
  MyTarget0 ()
Calling Target0 again with 2 detours.
  Starting Target0_1.
  MyTarget0 ()
  End Target0_1.
Calling Target0 again with 3 detours.
  Starting Target0_2.
  Starting Target0_1.
  MyTarget0 ()
  End Target0_1.
  End Target0_2.
Calling Target0 again with 4 detours.
  Starting Target0_3.
  Starting Target0_2.
  Starting Target0_1.
  MyTarget0 ()
  End Target0_1.
  End Target0_2.
  End Target0_3.
Done.
    Target0 ()
    Target0 ()
    Target1 (1)
    Target2 (1,2)
    Target3 (1,2,3)
    Target4 (1,2,3,4)
    Target5 (1,2,3,4,5)
    Target6 (1,2,3,4,5,6)
    Target7 (1,2,3,4,5,6,7)
    Target8 (1,2,3,4,5,6,7,8)
    Target9 (1,2,3,4,5,6,7,8,9)
    Target10(1,2,3,4,5,6,7,8,9,10)
    Target11(1,2,3,4,5,6,7,8,9,10,11)
    Target12(1,2,3,4,5,6,7,8,9,10,11,12)
    Target13(1,2,3,4,5,6,7,8,9,10,11,12,13)
    Target14(1,2,3,4,5,6,7,8,9,10,11,12,13,14)
    Target15(1,2,3,4,5,6,7,8,9,10,11,12,13,14,15)
    Target16(1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16)
    TargetV (0)
    TargetV (0,1)
    TargetV (0,1,2)
    TargetV (0,1,2,3)
    TargetV (0,1,2,3,4)
    TargetV (0,1,2,3,4,5)
    TargetV (0,1,2,3,4,5,6)
    TargetV (0,1,2,3,4,5,6,7)
    TargetV (0,1,2,3,4,5,6,7,8)
    TargetV (0,1,2,3,4,5,6,7,8,9)
    TargetV (0,1,2,3,4,5,6,7,8,9,10)
    TargetV (0,1,2,3,4,5,6,7,8,9,10,11)
    TargetV (0,1,2,3,4,5,6,7,8,9,10,11,12)
    TargetV (0,1,2,3,4,5,6,7,8,9,10,11,12,13)
    TargetV (0,1,2,3,4,5,6,7,8,9,10,11,12,13,14)
    TargetV (0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15)
    TargetV (0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16)
:::    TargetR (0,1,2,3,1)
:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::    TargetR (0,1,2,3,4,5,6,7,8,9,10,1)
    Target0 ()
    Target0 ()
    Target0 ()
    Target0 ()

```

`samples/dtest/NORMAL_X86.TXT`:

```TXT
    ..\..\bin.X86\dtest.exe
Calling LocalTarget1 w/o detour
  LocalTarget1 (1)
Calling LocalTarget1 w/ detour
  MyLocalTarget1 (2)
  LocalTarget1 (2)
Calling Target0 function.
  MyTarget0 ()
Calling TargetN functions.
  MyLocalTarget1 (1)
  LocalTarget1 (1)
  MyTarget0 ()
  MyTarget1 (1)
  MyTarget2 (1,2)
  MyTarget3 (1,2,3)
  MyTarget4 (1,2,3,4)
  MyTarget5 (1,2,3,4,5)
  MyTarget6 (1,2,3,4,5,6)
  MyTarget7 (1,2,3,4,5,6,7)
  MyTarget8 (1,2,3,4,5,6,7,8)
  MyTarget9 (1,2,3,4,5,6,7,8,9)
  MyTarget10(1,2,3,4,5,6,7,8,9,10)
  MyTarget11(1,2,3,4,5,6,7,8,9,10,11)
  MyTarget12(1,2,3,4,5,6,7,8,9,10,11,12)
  MyTarget13(1,2,3,4,5,6,7,8,9,10,11,12,13)
  MyTarget14(1,2,3,4,5,6,7,8,9,10,11,12,13,14)
  MyTarget15(1,2,3,4,5,6,7,8,9,10,11,12,13,14,15)
  MyTarget16(1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16)
  MyTargetV (0)
  MyTargetV (0,1)
  MyTargetV (0,1,2)
  MyTargetV (0,1,2,3)
  MyTargetV (0,1,2,3,4)
  MyTargetV (0,1,2,3,4,5)
  MyTargetV (0,1,2,3,4,5,6)
  MyTargetV (0,1,2,3,4,5,6,7)
  MyTargetV (0,1,2,3,4,5,6,7,8)
  MyTargetV (0,1,2,3,4,5,6,7,8,9)
  MyTargetV (0,1,2,3,4,5,6,7,8,9,10)
  MyTargetV (0,1,2,3,4,5,6,7,8,9,10,11)
  MyTargetV (0,1,2,3,4,5,6,7,8,9,10,11,12)
  MyTargetV (0,1,2,3,4,5,6,7,8,9,10,11,12,13)
  MyTargetV (0,1,2,3,4,5,6,7,8,9,10,11,12,13,14)
  MyTargetV (0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15)
  MyTargetV (0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16)
  MyTargetR (0,1,2,3,4)
  MyTargetR (0,1,2,3,3)
  MyTargetR (0,1,2,3,2)
  MyTargetR (0,1,2,3,1)
....................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................  MyTargetR (0,1,2,3,4,5,6,7,8,9,10,4)
  MyTargetR (0,1,2,3,4,5,6,7,8,9,10,3)
  MyTargetR (0,1,2,3,4,5,6,7,8,9,10,2)
  MyTargetR (0,1,2,3,4,5,6,7,8,9,10,1)
 => 3011
Calling Target0 again with 1 detour.
  MyTarget0 ()
Calling Target0 again with 2 detours.
  Starting Target0_1.
  MyTarget0 ()
  End Target0_1.
Calling Target0 again with 3 detours.
  Starting Target0_2.
  Starting Target0_1.
  MyTarget0 ()
  End Target0_1.
  End Target0_2.
Calling Target0 again with 4 detours.
  Starting Target0_3.
  Starting Target0_2.
  Starting Target0_1.
  MyTarget0 ()
  End Target0_1.
  End Target0_2.
  End Target0_3.
Done.
    Target0 ()
    Target0 ()
    Target1 (1)
    Target2 (1,2)
    Target3 (1,2,3)
    Target4 (1,2,3,4)
    Target5 (1,2,3,4,5)
    Target6 (1,2,3,4,5,6)
    Target7 (1,2,3,4,5,6,7)
    Target8 (1,2,3,4,5,6,7,8)
    Target9 (1,2,3,4,5,6,7,8,9)
    Target10(1,2,3,4,5,6,7,8,9,10)
    Target11(1,2,3,4,5,6,7,8,9,10,11)
    Target12(1,2,3,4,5,6,7,8,9,10,11,12)
    Target13(1,2,3,4,5,6,7,8,9,10,11,12,13)
    Target14(1,2,3,4,5,6,7,8,9,10,11,12,13,14)
    Target15(1,2,3,4,5,6,7,8,9,10,11,12,13,14,15)
    Target16(1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16)
    TargetV (0)
    TargetV (0,1)
    TargetV (0,1,2)
    TargetV (0,1,2,3)
    TargetV (0,1,2,3,4)
    TargetV (0,1,2,3,4,5)
    TargetV (0,1,2,3,4,5,6)
    TargetV (0,1,2,3,4,5,6,7)
    TargetV (0,1,2,3,4,5,6,7,8)
    TargetV (0,1,2,3,4,5,6,7,8,9)
    TargetV (0,1,2,3,4,5,6,7,8,9,10)
    TargetV (0,1,2,3,4,5,6,7,8,9,10,11)
    TargetV (0,1,2,3,4,5,6,7,8,9,10,11,12)
    TargetV (0,1,2,3,4,5,6,7,8,9,10,11,12,13)
    TargetV (0,1,2,3,4,5,6,7,8,9,10,11,12,13,14)
    TargetV (0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15)
    TargetV (0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16)
:::    TargetR (0,1,2,3,1)
:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::    TargetR (0,1,2,3,4,5,6,7,8,9,10,1)
    Target0 ()
    Target0 ()
    Target0 ()
    Target0 ()

```

`samples/dtest/dtarge.cpp`:

```cpp
//////////////////////////////////////////////////////////////////////////////
//
//  Detours Test Program (dtarge.dll)
//
//  Microsoft Research Detours Package
//
//  Copyright (c) Microsoft Corporation.  All rights reserved.
//
#include <stdio.h>
#include <windows.h>
#include "dtarge.h"

DWORD_PTR WINAPI Target0()
{
    printf("    Target0 ()\n");
    return 1000;
}

DWORD_PTR WINAPI Target1(DWORD_PTR v1)
{
    printf("    Target1 (%ld)\n",
           (DWORD)v1);
    return 1001;
}

DWORD_PTR WINAPI Target2(DWORD_PTR v1, DWORD_PTR v2)
{
    printf("    Target2 (%ld,%ld)\n",
           (DWORD)v1, (DWORD)v2);
    return 1002;
}

DWORD_PTR WINAPI Target3(DWORD_PTR v1, DWORD_PTR v2, DWORD_PTR v3)
{
    printf("    Target3 (%ld,%ld,%ld)\n",
           (DWORD)v1, (DWORD)v2, (DWORD)v3);
    return 1003;
}

DWORD_PTR WINAPI Target4(DWORD_PTR v1, DWORD_PTR v2, DWORD_PTR v3, DWORD_PTR v4)
{
    printf("    Target4 (%ld,%ld,%ld,%ld)\n",
           (DWORD)v1, (DWORD)v2, (DWORD)v3, (DWORD)v4);
    return 1004;
}

DWORD_PTR WINAPI Target5(DWORD_PTR v1, DWORD_PTR v2, DWORD_PTR v3, DWORD_PTR v4,
                         DWORD_PTR v5)
{
    printf("    Target5 (%ld,%ld,%ld,%ld,%ld)\n",
           (DWORD)v1, (DWORD)v2, (DWORD)v3, (DWORD)v4,
           (DWORD)v5);
    return 1005;
}

DWORD_PTR WINAPI Target6(DWORD_PTR v1, DWORD_PTR v2, DWORD_PTR v3, DWORD_PTR v4,
                         DWORD_PTR v5, DWORD_PTR v6)
{
    printf("    Target6 (%ld,%ld,%ld,%ld,%ld,%ld)\n",
           (DWORD)v1, (DWORD)v2, (DWORD)v3, (DWORD)v4,
           (DWORD)v5, (DWORD)v6);
    return 1006;
}

DWORD_PTR WINAPI Target7(DWORD_PTR v1, DWORD_PTR v2, DWORD_PTR v3, DWORD_PTR v4,
                         DWORD_PTR v5, DWORD_PTR v6, DWORD_PTR v7)
{
    printf("    Target7 (%ld,%ld,%ld,%ld,%ld,%ld,%ld)\n",
           (DWORD)v1, (DWORD)v2, (DWORD)v3, (DWORD)v4,
           (DWORD)v5, (DWORD)v6, (DWORD)v7);
    return 1007;
}

DWORD_PTR WINAPI Target8(DWORD_PTR v1, DWORD_PTR v2, DWORD_PTR v3, DWORD_PTR v4,
                         DWORD_PTR v5, DWORD_PTR v6, DWORD_PTR v7, DWORD_PTR v8)
{
    printf("    Target8 (%ld,%ld,%ld,%ld,%ld,%ld,%ld,%ld)\n",
           (DWORD)v1, (DWORD)v2, (DWORD)v3, (DWORD)v4,
           (DWORD)v5, (DWORD)v6, (DWORD)v7, (DWORD)v8);
    return 1008;
}

DWORD_PTR WINAPI Target9(DWORD_PTR v1, DWORD_PTR v2, DWORD_PTR v3, DWORD_PTR v4,
                         DWORD_PTR v5, DWORD_PTR v6, DWORD_PTR v7, DWORD_PTR v8,
                         DWORD_PTR v9)
{
    printf("    Target9 (%ld,%ld,%ld,%ld,%ld,%ld,%ld,%ld,%ld)\n",
           (DWORD)v1, (DWORD)v2, (DWORD)v3, (DWORD)v4,
           (DWORD)v5, (DWORD)v6, (DWORD)v7, (DWORD)v8,
           (DWORD)v9);
    return 1009;
}

DWORD_PTR WINAPI Target10(DWORD_PTR v1, DWORD_PTR v2, DWORD_PTR v3, DWORD_PTR v4,
                          DWORD_PTR v5, DWORD_PTR v6, DWORD_PTR v7, DWORD_PTR v8,
                          DWORD_PTR v9, DWORD_PTR v10)
{
    printf("    Target10(%ld,%ld,%ld,%ld,%ld,%ld,%ld,%ld,%ld,%ld)\n",
           (DWORD)v1, (DWORD)v2, (DWORD)v3, (DWORD)v4,
           (DWORD)v5, (DWORD)v6, (DWORD)v7, (DWORD)v8,
           (DWORD)v9, (DWORD)v10);
    return 1010;
}

DWORD_PTR WINAPI Target11(DWORD_PTR v1, DWORD_PTR v2, DWORD_PTR v3, DWORD_PTR v4,
                          DWORD_PTR v5, DWORD_PTR v6, DWORD_PTR v7, DWORD_PTR v8,
                          DWORD_PTR v9, DWORD_PTR v10, DWORD_PTR v11)
{
    printf("    Target11(%ld,%ld,%ld,%ld,%ld,%ld,%ld,%ld,%ld,%ld,%ld)\n",
           (DWORD)v1, (DWORD)v2, (DWORD)v3, (DWORD)v4,
           (DWORD)v5, (DWORD)v6, (DWORD)v7, (DWORD)v8,
           (DWORD)v9, (DWORD)v10, (DWORD)v11);
    return 1011;
}

DWORD_PTR WINAPI Target12(DWORD_PTR v1, DWORD_PTR v2, DWORD_PTR v3, DWORD_PTR v4,
                          DWORD_PTR v5, DWORD_PTR v6, DWORD_PTR v7, DWORD_PTR v8,
                          DWORD_PTR v9, DWORD_PTR v10, DWORD_PTR v11, DWORD_PTR v12)
{
    printf("    Target12(%ld,%ld,%ld,%ld,%ld,%ld,%ld,%ld,%ld,%ld,%ld,%ld)\n",
           (DWORD)v1, (DWORD)v2, (DWORD)v3, (DWORD)v4,
           (DWORD)v5, (DWORD)v6, (DWORD)v7, (DWORD)v8,
           (DWORD)v9, (DWORD)v10, (DWORD)v11, (DWORD)v12);
    return 1012;
}

DWORD_PTR WINAPI Target13(DWORD_PTR v1, DWORD_PTR v2, DWORD_PTR v3, DWORD_PTR v4,
                          DWORD_PTR v5, DWORD_PTR v6, DWORD_PTR v7, DWORD_PTR v8,
                          DWORD_PTR v9, DWORD_PTR v10, DWORD_PTR v11, DWORD_PTR v12,
                          DWORD_PTR v13)
{
    printf("    Target13(%ld,%ld,%ld,%ld,%ld,%ld,%ld,%ld,%ld,%ld,%ld,%ld,%ld)\n",
           (DWORD)v1, (DWORD)v2, (DWORD)v3, (DWORD)v4,
           (DWORD)v5, (DWORD)v6, (DWORD)v7, (DWORD)v8,
           (DWORD)v9, (DWORD)v10, (DWORD)v11, (DWORD)v12,
           (DWORD)v13);
    return 1013;
}

DWORD_PTR WINAPI Target14(DWORD_PTR v1, DWORD_PTR v2, DWORD_PTR v3, DWORD_PTR v4,
                          DWORD_PTR v5, DWORD_PTR v6, DWORD_PTR v7, DWORD_PTR v8,
                          DWORD_PTR v9, DWORD_PTR v10, DWORD_PTR v11, DWORD_PTR v12,
                          DWORD_PTR v13, DWORD_PTR v14)
{
    printf("    Target14(%ld,%ld,%ld,%ld,%ld,%ld,%ld,%ld,%ld,%ld,%ld,%ld,%ld,%ld)\n",
           (DWORD)v1, (DWORD)v2, (DWORD)v3, (DWORD)v4,
           (DWORD)v5, (DWORD)v6, (DWORD)v7, (DWORD)v8,
           (DWORD)v9, (DWORD)v10, (DWORD)v11, (DWORD)v12,
           (DWORD)v13, (DWORD)v14);
    return 1014;
}

DWORD_PTR WINAPI Target15(DWORD_PTR v1, DWORD_PTR v2, DWORD_PTR v3, DWORD_PTR v4,
                          DWORD_PTR v5, DWORD_PTR v6, DWORD_PTR v7, DWORD_PTR v8,
                          DWORD_PTR v9, DWORD_PTR v10, DWORD_PTR v11, DWORD_PTR v12,
                          DWORD_PTR v13, DWORD_PTR v14, DWORD_PTR v15)
{
    printf("    Target15(%ld,%ld,%ld,%ld,%ld,%ld,%ld,%ld,%ld,%ld,%ld,%ld,%ld,%ld,%ld)\n",
           (DWORD)v1, (DWORD)v2, (DWORD)v3, (DWORD)v4,
           (DWORD)v5, (DWORD)v6, (DWORD)v7, (DWORD)v8,
           (DWORD)v9, (DWORD)v10, (DWORD)v11, (DWORD)v12,
           (DWORD)v13, (DWORD)v14, (DWORD)v15);
    return 1015;
}

DWORD_PTR WINAPI Target16(DWORD_PTR v1, DWORD_PTR v2, DWORD_PTR v3, DWORD_PTR v4,
                          DWORD_PTR v5, DWORD_PTR v6, DWORD_PTR v7, DWORD_PTR v8,
                          DWORD_PTR v9, DWORD_PTR v10, DWORD_PTR v11, DWORD_PTR v12,
                          DWORD_PTR v13, DWORD_PTR v14, DWORD_PTR v15, DWORD_PTR v16)
{
    printf("    Target16(%ld,%ld,%ld,%ld,%ld,%ld,%ld,%ld,%ld,%ld,%ld,%ld,%ld,%ld,%ld,%ld)\n",
           (DWORD)v1, (DWORD)v2, (DWORD)v3, (DWORD)v4,
           (DWORD)v5, (DWORD)v6, (DWORD)v7, (DWORD)v8,
           (DWORD)v9, (DWORD)v10, (DWORD)v11, (DWORD)v12,
           (DWORD)v13, (DWORD)v14, (DWORD)v15, (DWORD)v16);
    return 1016;
}

DWORD_PTR WINAPI TargetV(DWORD_PTR v1, ...)
{
    DWORD_PTR args[32];

    va_list va;
    va_start(va, v1);

    int argc = 0;
    for (args[argc++] = v1; args[argc-1] != 0;) {
        args[argc++] = va_arg(va, DWORD_PTR);
    }
    va_end(va);

    printf("    TargetV (");
    int i = argc - 1;
    for (; i > 0; i--) {
        printf("%ld,", (DWORD)args[i]);
    }
    printf("%ld)\n", (DWORD)args[0]);

    return 1000 + argc;
}

DWORD_PTR WINAPI TargetR(DWORD_PTR v1, ...)
{
    DWORD_PTR args[32];

    va_list va;
    va_start(va, v1);

    int argc = 0;
    for (args[argc++] = v1; args[argc-1] != 0;) {
        args[argc++] = va_arg(va, DWORD_PTR);
    }
    va_end(va);

    if (v1 > 1) {
        printf(":");
        switch (argc) {
          default:
            return TargetR(0) + 1;
          case 1:
            return TargetR(args[0] - 1) + 1;
          case 2:
            return TargetR(args[0] - 1, args[1]) + 1;
          case 3:
            return TargetR(args[0] - 1, args[1], args[2]) + 1;
          case 4:
            return TargetR(args[0] - 1, args[1], args[2], args[3]) + 1;
          case 5:
            return TargetR(args[0] - 1, args[1], args[2], args[3],
                           args[4]) + 1;
          case 6:
            return TargetR(args[0] - 1, args[1], args[2], args[3],
                           args[4], args[5]) + 1;
          case 7:
            return TargetR(args[0] - 1, args[1], args[2], args[3],
                           args[4], args[5], args[6]) + 1;
          case 8:
            return TargetR(args[0] - 1, args[1], args[2], args[3],
                           args[4], args[5], args[6], args[7]) + 1;
          case 9:
            return TargetR(args[0] - 1, args[1], args[2], args[3],
                           args[4], args[5], args[6], args[7],
                           args[8]) + 1;
          case 10:
            return TargetR(args[0] - 1, args[1], args[2], args[3],
                           args[4], args[5], args[6], args[7],
                           args[8], args[9]) + 1;
          case 11:
            return TargetR(args[0] - 1, args[1], args[2], args[3],
                           args[4], args[5], args[6], args[7],
                           args[8], args[9], args[10]) + 1;
          case 12:
            return TargetR(args[0] - 1, args[1], args[2], args[3],
                           args[4], args[5], args[6], args[7],
                           args[8], args[9], args[10], args[11]) + 1;
          case 13:
            return TargetR(args[0] - 1, args[1], args[2], args[3],
                           args[4], args[5], args[6], args[7],
                           args[8], args[9], args[10], args[11],
                           args[12]) + 1;
          case 14:
            return TargetR(args[0] - 1, args[1], args[2], args[3],
                           args[4], args[5], args[6], args[7],
                           args[8], args[9], args[10], args[11],
                           args[12], args[13]) + 1;
          case 15:
            return TargetR(args[0] - 1, args[1], args[2], args[3],
                           args[4], args[5], args[6], args[7],
                           args[8], args[9], args[10], args[11],
                           args[12], args[13], args[14]) + 1;
          case 16:
            return TargetR(args[0] - 1, args[1], args[2], args[3],
                           args[4], args[5], args[6], args[7],
                           args[8], args[9], args[10], args[11],
                           args[12], args[13], args[14], args[15]) + 1;
          case 17:
            return TargetR(args[0] - 1, args[1], args[2], args[3],
                           args[4], args[5], args[6], args[7],
                           args[8], args[9], args[10], args[11],
                           args[12], args[13], args[14], args[15],
                           args[16]) + 1;
        }
    }

    printf("    TargetR (");
    int i = argc - 1;
    for (; i > 0; i--) {
        printf("%ld,", (DWORD)args[i]);
    }
    printf("%ld)\n", (DWORD)args[0]);

    return 2000 + argc;
}


BOOL WINAPI DllMain(HINSTANCE hinst, DWORD dwReason, LPVOID reserved)
{
    (void)hinst;
    (void)dwReason;
    (void)reserved;

    return TRUE;
}

//
///////////////////////////////////////////////////////////////// End of File.

```

`samples/dtest/dtarge.h`:

```h
//////////////////////////////////////////////////////////////////////////////
//
//  Detours Test Program (dtarge.h of dtarge.dll)
//
//  Microsoft Research Detours Package
//
//  Copyright (c) Microsoft Corporation.  All rights reserved.
//
#pragma once

#if (_MSC_VER < 1299)
typedef DWORD DWORD_PTR;
#endif

DWORD_PTR WINAPI Target0();
DWORD_PTR WINAPI Target1(DWORD_PTR v1);
DWORD_PTR WINAPI Target2(DWORD_PTR v1, DWORD_PTR v2);
DWORD_PTR WINAPI Target3(DWORD_PTR v1, DWORD_PTR v2, DWORD_PTR v3);
DWORD_PTR WINAPI Target4(DWORD_PTR v1, DWORD_PTR v2, DWORD_PTR v3, DWORD_PTR v4);
DWORD_PTR WINAPI Target5(DWORD_PTR v1, DWORD_PTR v2, DWORD_PTR v3, DWORD_PTR v4,
                         DWORD_PTR v5);
DWORD_PTR WINAPI Target6(DWORD_PTR v1, DWORD_PTR v2, DWORD_PTR v3, DWORD_PTR v4,
                         DWORD_PTR v5, DWORD_PTR v6);
DWORD_PTR WINAPI Target7(DWORD_PTR v1, DWORD_PTR v2, DWORD_PTR v3, DWORD_PTR v4,
                         DWORD_PTR v5, DWORD_PTR v6, DWORD_PTR v7);
DWORD_PTR WINAPI Target8(DWORD_PTR v1, DWORD_PTR v2, DWORD_PTR v3, DWORD_PTR v4,
                         DWORD_PTR v5, DWORD_PTR v6, DWORD_PTR v7, DWORD_PTR v8);
DWORD_PTR WINAPI Target9(DWORD_PTR v1, DWORD_PTR v2, DWORD_PTR v3, DWORD_PTR v4,
                         DWORD_PTR v5, DWORD_PTR v6, DWORD_PTR v7, DWORD_PTR v8,
                         DWORD_PTR v9);
DWORD_PTR WINAPI Target10(DWORD_PTR v1, DWORD_PTR v2, DWORD_PTR v3, DWORD_PTR v4,
                          DWORD_PTR v5, DWORD_PTR v6, DWORD_PTR v7, DWORD_PTR v8,
                          DWORD_PTR v9, DWORD_PTR v10);
DWORD_PTR WINAPI Target11(DWORD_PTR v1, DWORD_PTR v2, DWORD_PTR v3, DWORD_PTR v4,
                          DWORD_PTR v5, DWORD_PTR v6, DWORD_PTR v7, DWORD_PTR v8,
                          DWORD_PTR v9, DWORD_PTR v10, DWORD_PTR v11);
DWORD_PTR WINAPI Target12(DWORD_PTR v1, DWORD_PTR v2, DWORD_PTR v3, DWORD_PTR v4,
                          DWORD_PTR v5, DWORD_PTR v6, DWORD_PTR v7, DWORD_PTR v8,
                          DWORD_PTR v9, DWORD_PTR v10, DWORD_PTR v11, DWORD_PTR v12);
DWORD_PTR WINAPI Target13(DWORD_PTR v1, DWORD_PTR v2, DWORD_PTR v3, DWORD_PTR v4,
                          DWORD_PTR v5, DWORD_PTR v6, DWORD_PTR v7, DWORD_PTR v8,
                          DWORD_PTR v9, DWORD_PTR v10, DWORD_PTR v11, DWORD_PTR v12,
                          DWORD_PTR v13);
DWORD_PTR WINAPI Target14(DWORD_PTR v1, DWORD_PTR v2, DWORD_PTR v3, DWORD_PTR v4,
                          DWORD_PTR v5, DWORD_PTR v6, DWORD_PTR v7, DWORD_PTR v8,
                          DWORD_PTR v9, DWORD_PTR v10, DWORD_PTR v11, DWORD_PTR v12,
                          DWORD_PTR v13, DWORD_PTR v14);
DWORD_PTR WINAPI Target15(DWORD_PTR v1, DWORD_PTR v2, DWORD_PTR v3, DWORD_PTR v4,
                          DWORD_PTR v5, DWORD_PTR v6, DWORD_PTR v7, DWORD_PTR v8,
                          DWORD_PTR v9, DWORD_PTR v10, DWORD_PTR v11, DWORD_PTR v12,
                          DWORD_PTR v13, DWORD_PTR v14, DWORD_PTR v15);
DWORD_PTR WINAPI Target16(DWORD_PTR v1, DWORD_PTR v2, DWORD_PTR v3, DWORD_PTR v4,
                          DWORD_PTR v5, DWORD_PTR v6, DWORD_PTR v7, DWORD_PTR v8,
                          DWORD_PTR v9, DWORD_PTR v10, DWORD_PTR v11, DWORD_PTR v12,
                          DWORD_PTR v13, DWORD_PTR v14, DWORD_PTR v15, DWORD_PTR v16);
DWORD_PTR WINAPI TargetV(DWORD_PTR v1, ...);
DWORD_PTR WINAPI TargetR(DWORD_PTR v1, ...);

//
///////////////////////////////////////////////////////////////// End of File.

```

`samples/dtest/dtarge.rc`:

```rc
//////////////////////////////////////////////////////////////////////////////
//
//  Version information for dtarge.rc.
//
//  Microsoft Research Detours Package
//
//  Copyright (c) Microsoft Corporation.  All rights reserved.
//

#include "detver.h"

#define VER_INTERNALNAME_STR        "dtarge" DETOURS_STRINGIFY(DETOURS_BITS)
#define VER_ORIGINALFILENAME_STR    "dtarge" DETOURS_STRINGIFY(DETOURS_BITS) ".dll"
#define VER_FILEDESCRIPTION_STR     "Detours Test Module"
#define VER_COMPANYNAME_STR         "Microsoft Corporation"

#include "common.ver"

```

`samples/dtest/dtest.cpp`:

```cpp
//////////////////////////////////////////////////////////////////////////////
//
//  Detours Test Program (dtest.cpp of dtest.exe)
//
//  Microsoft Research Detours Package
//
//  Copyright (c) Microsoft Corporation.  All rights reserved.
//
#include <stdio.h>
#include <stdarg.h>
#include <windows.h>
#pragma warning(push)
#if _MSC_VER > 1400
#pragma warning(disable:6102 6103) // /analyze warnings
#endif
#include <strsafe.h>
#pragma warning(pop)
#include <detours.h>
#include "dtarge.h"

DWORD_PTR WINAPI LocalTarget1(DWORD_PTR v1);

////////////////////////////////////////////////////// Multi-Argument Detours.
//
DWORD_PTR (WINAPI * Trampoline_LocalTarget1)(DWORD_PTR v1) = LocalTarget1;

DWORD_PTR (WINAPI * Trampoline_Target0)() = Target0;
DWORD_PTR (WINAPI * Trampoline_Target1)(DWORD_PTR v1) = Target1;
DWORD_PTR (WINAPI * Trampoline_Target2)(DWORD_PTR v1, DWORD_PTR v2) = Target2;
DWORD_PTR (WINAPI * Trampoline_Target3)
    (DWORD_PTR v1, DWORD_PTR v2, DWORD_PTR v3) = Target3;
DWORD_PTR (WINAPI * Trampoline_Target4)
    (DWORD_PTR v1, DWORD_PTR v2, DWORD_PTR v3, DWORD_PTR v4) = Target4;
DWORD_PTR (WINAPI * Trampoline_Target5)
    (DWORD_PTR v1, DWORD_PTR v2, DWORD_PTR v3, DWORD_PTR v4,
     DWORD_PTR v5) = Target5;
DWORD_PTR (WINAPI * Trampoline_Target6)
    (DWORD_PTR v1, DWORD_PTR v2, DWORD_PTR v3, DWORD_PTR v4,
     DWORD_PTR v5, DWORD_PTR v6) = Target6;
DWORD_PTR (WINAPI * Trampoline_Target7)
    (DWORD_PTR v1, DWORD_PTR v2, DWORD_PTR v3, DWORD_PTR v4,
     DWORD_PTR v5, DWORD_PTR v6, DWORD_PTR v7) = Target7;
DWORD_PTR (WINAPI * Trampoline_Target8)
    (DWORD_PTR v1, DWORD_PTR v2, DWORD_PTR v3, DWORD_PTR v4,
     DWORD_PTR v5, DWORD_PTR v6, DWORD_PTR v7, DWORD_PTR v8) = Target8;
DWORD_PTR (WINAPI * Trampoline_Target9)
    (DWORD_PTR v1, DWORD_PTR v2, DWORD_PTR v3, DWORD_PTR v4,
     DWORD_PTR v5, DWORD_PTR v6, DWORD_PTR v7, DWORD_PTR v8,
     DWORD_PTR v9) = Target9;
DWORD_PTR (WINAPI * Trampoline_Target10)
    (DWORD_PTR v1, DWORD_PTR v2, DWORD_PTR v3, DWORD_PTR v4,
     DWORD_PTR v5, DWORD_PTR v6, DWORD_PTR v7, DWORD_PTR v8,
     DWORD_PTR v9, DWORD_PTR v10) = Target10;
DWORD_PTR (WINAPI * Trampoline_Target11)
    (DWORD_PTR v1, DWORD_PTR v2, DWORD_PTR v3, DWORD_PTR v4,
     DWORD_PTR v5, DWORD_PTR v6, DWORD_PTR v7, DWORD_PTR v8,
     DWORD_PTR v9, DWORD_PTR v10, DWORD_PTR v11) = Target11;
DWORD_PTR (WINAPI * Trampoline_Target12)
    (DWORD_PTR v1, DWORD_PTR v2, DWORD_PTR v3, DWORD_PTR v4,
     DWORD_PTR v5, DWORD_PTR v6, DWORD_PTR v7, DWORD_PTR v8,
     DWORD_PTR v9, DWORD_PTR v10, DWORD_PTR v11, DWORD_PTR v12) = Target12;
DWORD_PTR (WINAPI * Trampoline_Target13)
    (DWORD_PTR v1, DWORD_PTR v2, DWORD_PTR v3, DWORD_PTR v4,
     DWORD_PTR v5, DWORD_PTR v6, DWORD_PTR v7, DWORD_PTR v8,
     DWORD_PTR v9, DWORD_PTR v10, DWORD_PTR v11, DWORD_PTR v12,
     DWORD_PTR v13) = Target13;
DWORD_PTR (WINAPI * Trampoline_Target14)
    (DWORD_PTR v1, DWORD_PTR v2, DWORD_PTR v3, DWORD_PTR v4,
     DWORD_PTR v5, DWORD_PTR v6, DWORD_PTR v7, DWORD_PTR v8,
     DWORD_PTR v9, DWORD_PTR v10, DWORD_PTR v11, DWORD_PTR v12,
     DWORD_PTR v13, DWORD_PTR v14) = Target14;
DWORD_PTR (WINAPI * Trampoline_Target15)
    (DWORD_PTR v1, DWORD_PTR v2, DWORD_PTR v3, DWORD_PTR v4,
     DWORD_PTR v5, DWORD_PTR v6, DWORD_PTR v7, DWORD_PTR v8,
     DWORD_PTR v9, DWORD_PTR v10, DWORD_PTR v11, DWORD_PTR v12,
     DWORD_PTR v13, DWORD_PTR v14, DWORD_PTR v15) = Target15;
DWORD_PTR (WINAPI * Trampoline_Target16)
    (DWORD_PTR v1, DWORD_PTR v2, DWORD_PTR v3, DWORD_PTR v4,
     DWORD_PTR v5, DWORD_PTR v6, DWORD_PTR v7, DWORD_PTR v8,
     DWORD_PTR v9, DWORD_PTR v10, DWORD_PTR v11, DWORD_PTR v12,
     DWORD_PTR v13, DWORD_PTR v14, DWORD_PTR v15, DWORD_PTR v16) = Target16;
DWORD_PTR (WINAPI * Trampoline_TargetV)(DWORD_PTR v1, ...) = TargetV;
DWORD_PTR (WINAPI * Trampoline_TargetR)(DWORD_PTR v1, ...) = TargetR;

//////////////////////////////////////////////////////////////////////////////
//
VOID dprintf(const char * fmt, ...)
{
    CHAR szBuf[1024];

    va_list args;
    va_start(args, fmt);
    StringCchPrintfA(szBuf, sizeof(szBuf), fmt, args);
    va_end(args);

    OutputDebugStringA(szBuf);
}

//////////////////////////////////////////////////////////////////////////////
//
DWORD_PTR WINAPI LocalTarget1(DWORD_PTR v1)
{
    printf("  LocalTarget1 (%ld)\n", (DWORD)v1);
    // dprintf("LocalTarget1\n");
    // __debugbreak();
    return 9000;
}

//////////////////////////////////////////////////////////////////////////////
//
DWORD_PTR WINAPI MyLocalTarget1(DWORD_PTR v1)
{
    printf("  MyLocalTarget1 (%ld)\n",
           (DWORD)v1);
    // dprintf("LocalTarget1, Trampoline_LocalTarget1=%p\n", Trampoline_LocalTarget1);
    return Trampoline_LocalTarget1(v1);
}

DWORD_PTR WINAPI MyTarget0()
{
    printf("  MyTarget0 ()\n");
    return Trampoline_Target0();
}

DWORD_PTR WINAPI MyTarget1(DWORD_PTR v1)
{
    printf("  MyTarget1 (%ld)\n",
           (DWORD)v1);
    return Trampoline_Target1(v1);
}

DWORD_PTR WINAPI MyTarget2(DWORD_PTR v1, DWORD_PTR v2)
{
    printf("  MyTarget2 (%ld,%ld)\n",
           (DWORD)v1, (DWORD)v2);
    return Trampoline_Target2(v1,v2);
}

DWORD_PTR WINAPI MyTarget3(DWORD_PTR v1, DWORD_PTR v2, DWORD_PTR v3)
{
    printf("  MyTarget3 (%ld,%ld,%ld)\n",
           (DWORD)v1, (DWORD)v2, (DWORD)v3);
    return Trampoline_Target3(v1,v2,v3);
}

DWORD_PTR WINAPI MyTarget4(DWORD_PTR v1, DWORD_PTR v2, DWORD_PTR v3, DWORD_PTR v4)
{
    printf("  MyTarget4 (%ld,%ld,%ld,%ld)\n",
           (DWORD)v1, (DWORD)v2, (DWORD)v3, (DWORD)v4);
    return Trampoline_Target4(v1,v2,v3,v4);
}

DWORD_PTR WINAPI MyTarget5(DWORD_PTR v1, DWORD_PTR v2, DWORD_PTR v3, DWORD_PTR v4,
                           DWORD_PTR v5)
{
    printf("  MyTarget5 (%ld,%ld,%ld,%ld,%ld)\n",
           (DWORD)v1, (DWORD)v2, (DWORD)v3, (DWORD)v4,
           (DWORD)v5);
    return Trampoline_Target5(v1,v2,v3,v4,v5);
}

DWORD_PTR WINAPI MyTarget6(DWORD_PTR v1, DWORD_PTR v2, DWORD_PTR v3, DWORD_PTR v4,
                           DWORD_PTR v5, DWORD_PTR v6)
{
    printf("  MyTarget6 (%ld,%ld,%ld,%ld,%ld,%ld)\n",
           (DWORD)v1, (DWORD)v2, (DWORD)v3, (DWORD)v4,
           (DWORD)v5, (DWORD)v6);
    return Trampoline_Target6(v1,v2,v3,v4,v5,v6);
}

DWORD_PTR WINAPI MyTarget7(DWORD_PTR v1, DWORD_PTR v2, DWORD_PTR v3, DWORD_PTR v4,
                           DWORD_PTR v5, DWORD_PTR v6, DWORD_PTR v7)
{
    printf("  MyTarget7 (%ld,%ld,%ld,%ld,%ld,%ld,%ld)\n",
           (DWORD)v1, (DWORD)v2, (DWORD)v3, (DWORD)v4,
           (DWORD)v5, (DWORD)v6, (DWORD)v7);
    return Trampoline_Target7(v1,v2,v3,v4,v5,v6,v7);
}

DWORD_PTR WINAPI MyTarget8(DWORD_PTR v1, DWORD_PTR v2, DWORD_PTR v3, DWORD_PTR v4,
                           DWORD_PTR v5, DWORD_PTR v6, DWORD_PTR v7, DWORD_PTR v8)
{
    printf("  MyTarget8 (%ld,%ld,%ld,%ld,%ld,%ld,%ld,%ld)\n",
           (DWORD)v1, (DWORD)v2, (DWORD)v3, (DWORD)v4,
           (DWORD)v5, (DWORD)v6, (DWORD)v7, (DWORD)v8);
    return Trampoline_Target8(v1,v2,v3,v4,v5,v6,v7,v8);
}

DWORD_PTR WINAPI MyTarget9(DWORD_PTR v1, DWORD_PTR v2, DWORD_PTR v3, DWORD_PTR v4,
                         DWORD_PTR v5, DWORD_PTR v6, DWORD_PTR v7, DWORD_PTR v8,
                         DWORD_PTR v9)
{
    printf("  MyTarget9 (%ld,%ld,%ld,%ld,%ld,%ld,%ld,%ld,%ld)\n",
           (DWORD)v1, (DWORD)v2, (DWORD)v3, (DWORD)v4,
           (DWORD)v5, (DWORD)v6, (DWORD)v7, (DWORD)v8,
           (DWORD)v9);
    return Trampoline_Target9(v1,v2,v3,v4,v5,v6,v7,v8,v9);
}

DWORD_PTR WINAPI MyTarget10(DWORD_PTR v1, DWORD_PTR v2, DWORD_PTR v3, DWORD_PTR v4,
                            DWORD_PTR v5, DWORD_PTR v6, DWORD_PTR v7, DWORD_PTR v8,
                            DWORD_PTR v9, DWORD_PTR v10)
{
    printf("  MyTarget10(%ld,%ld,%ld,%ld,%ld,%ld,%ld,%ld,%ld,%ld)\n",
           (DWORD)v1, (DWORD)v2, (DWORD)v3, (DWORD)v4,
           (DWORD)v5, (DWORD)v6, (DWORD)v7, (DWORD)v8,
           (DWORD)v9, (DWORD)v10);
    return Trampoline_Target10(v1,v2,v3,v4,v5,v6,v7,v8,v9,v10);
}

DWORD_PTR WINAPI MyTarget11(DWORD_PTR v1, DWORD_PTR v2, DWORD_PTR v3, DWORD_PTR v4,
                            DWORD_PTR v5, DWORD_PTR v6, DWORD_PTR v7, DWORD_PTR v8,
                            DWORD_PTR v9, DWORD_PTR v10, DWORD_PTR v11)
{
    printf("  MyTarget11(%ld,%ld,%ld,%ld,%ld,%ld,%ld,%ld,%ld,%ld,%ld)\n",
           (DWORD)v1, (DWORD)v2, (DWORD)v3, (DWORD)v4,
           (DWORD)v5, (DWORD)v6, (DWORD)v7, (DWORD)v8,
           (DWORD)v9, (DWORD)v10, (DWORD)v11);
    return Trampoline_Target11(v1,v2,v3,v4,v5,v6,v7,v8,v9,v10,v11);
}

DWORD_PTR WINAPI MyTarget12(DWORD_PTR v1, DWORD_PTR v2, DWORD_PTR v3, DWORD_PTR v4,
                            DWORD_PTR v5, DWORD_PTR v6, DWORD_PTR v7, DWORD_PTR v8,
                            DWORD_PTR v9, DWORD_PTR v10, DWORD_PTR v11, DWORD_PTR v12)
{
    printf("  MyTarget12(%ld,%ld,%ld,%ld,%ld,%ld,%ld,%ld,%ld,%ld,%ld,%ld)\n",
           (DWORD)v1, (DWORD)v2, (DWORD)v3, (DWORD)v4,
           (DWORD)v5, (DWORD)v6, (DWORD)v7, (DWORD)v8,
           (DWORD)v9, (DWORD)v10, (DWORD)v11, (DWORD)v12);
    return Trampoline_Target12(v1,v2,v3,v4,v5,v6,v7,v8,v9,v10,v11,v12);
}

DWORD_PTR WINAPI MyTarget13(DWORD_PTR v1, DWORD_PTR v2, DWORD_PTR v3, DWORD_PTR v4,
                            DWORD_PTR v5, DWORD_PTR v6, DWORD_PTR v7, DWORD_PTR v8,
                            DWORD_PTR v9, DWORD_PTR v10, DWORD_PTR v11, DWORD_PTR v12,
                            DWORD_PTR v13)
{
    printf("  MyTarget13(%ld,%ld,%ld,%ld,%ld,%ld,%ld,%ld,%ld,%ld,%ld,%ld,%ld)\n",
           (DWORD)v1, (DWORD)v2, (DWORD)v3, (DWORD)v4,
           (DWORD)v5, (DWORD)v6, (DWORD)v7, (DWORD)v8,
           (DWORD)v9, (DWORD)v10, (DWORD)v11, (DWORD)v12,
           (DWORD)v13);
    return Trampoline_Target13(v1,v2,v3,v4,v5,v6,v7,v8,v9,v10,v11,v12,v13);
}

DWORD_PTR WINAPI MyTarget14(DWORD_PTR v1, DWORD_PTR v2, DWORD_PTR v3, DWORD_PTR v4,
                            DWORD_PTR v5, DWORD_PTR v6, DWORD_PTR v7, DWORD_PTR v8,
                            DWORD_PTR v9, DWORD_PTR v10, DWORD_PTR v11, DWORD_PTR v12,
                            DWORD_PTR v13, DWORD_PTR v14)
{
    printf("  MyTarget14(%ld,%ld,%ld,%ld,%ld,%ld,%ld,%ld,%ld,%ld,%ld,%ld,%ld,%ld)\n",
           (DWORD)v1, (DWORD)v2, (DWORD)v3, (DWORD)v4,
           (DWORD)v5, (DWORD)v6, (DWORD)v7, (DWORD)v8,
           (DWORD)v9, (DWORD)v10, (DWORD)v11, (DWORD)v12,
           (DWORD)v13, (DWORD)v14);
    return Trampoline_Target14(v1,v2,v3,v4,v5,v6,v7,v8,v9,v10,v11,v12,v13,v14);
}

DWORD_PTR WINAPI MyTarget15(DWORD_PTR v1, DWORD_PTR v2, DWORD_PTR v3, DWORD_PTR v4,
                            DWORD_PTR v5, DWORD_PTR v6, DWORD_PTR v7, DWORD_PTR v8,
                            DWORD_PTR v9, DWORD_PTR v10, DWORD_PTR v11, DWORD_PTR v12,
                            DWORD_PTR v13, DWORD_PTR v14, DWORD_PTR v15)
{
    printf("  MyTarget15(%ld,%ld,%ld,%ld,%ld,%ld,%ld,%ld,%ld,%ld,%ld,%ld,%ld,%ld,%ld)\n",
           (DWORD)v1, (DWORD)v2, (DWORD)v3, (DWORD)v4,
           (DWORD)v5, (DWORD)v6, (DWORD)v7, (DWORD)v8,
           (DWORD)v9, (DWORD)v10, (DWORD)v11, (DWORD)v12,
           (DWORD)v13, (DWORD)v14, (DWORD)v15);
    return Trampoline_Target15(v1,v2,v3,v4,v5,v6,v7,v8,v9,v10,v11,v12,v13,v14,v15);
}

DWORD_PTR WINAPI MyTarget16(DWORD_PTR v1, DWORD_PTR v2, DWORD_PTR v3, DWORD_PTR v4,
                            DWORD_PTR v5, DWORD_PTR v6, DWORD_PTR v7, DWORD_PTR v8,
                            DWORD_PTR v9, DWORD_PTR v10, DWORD_PTR v11, DWORD_PTR v12,
                            DWORD_PTR v13, DWORD_PTR v14, DWORD_PTR v15, DWORD_PTR v16)
{
    printf("  MyTarget16(%ld,%ld,%ld,%ld,%ld,%ld,%ld,%ld,%ld,%ld,%ld,%ld,%ld,%ld,%ld,%ld)\n",
           (DWORD)v1, (DWORD)v2, (DWORD)v3, (DWORD)v4,
           (DWORD)v5, (DWORD)v6, (DWORD)v7, (DWORD)v8,
           (DWORD)v9, (DWORD)v10, (DWORD)v11, (DWORD)v12,
           (DWORD)v13, (DWORD)v14, (DWORD)v15, (DWORD)v16);
    return Trampoline_Target16(v1,v2,v3,v4,v5,v6,v7,v8,v9,v10,v11,v12,v13,v14,v15,v16);
}

DWORD_PTR WINAPI MyTargetV(DWORD_PTR v1, ...)
{
    DWORD_PTR args[32];

    va_list va;
    va_start(va, v1);

    int argc = 0;
    for (args[argc++] = v1; args[argc-1] != 0;) {
        args[argc++] = va_arg(va, DWORD_PTR);
    }
    va_end(va);

    printf("  MyTargetV (");
    int i = argc - 1;
    for (; i > 0; i--) {
        printf("%ld,", (DWORD)args[i]);
    }
    printf("%ld)\n", (DWORD)args[0]);

    switch (argc) {
      default:
        return Trampoline_TargetV(0);
      case 1:
        return Trampoline_TargetV(args[0]);
      case 2:
        return Trampoline_TargetV(args[0], args[1]);
      case 3:
        return Trampoline_TargetV(args[0], args[1], args[2]);
      case 4:
        return Trampoline_TargetV(args[0], args[1], args[2], args[3]);
      case 5:
        return Trampoline_TargetV(args[0], args[1], args[2], args[3],
                                  args[4]);
      case 6:
        return Trampoline_TargetV(args[0], args[1], args[2], args[3],
                                  args[4], args[5]);
      case 7:
        return Trampoline_TargetV(args[0], args[1], args[2], args[3],
                                  args[4], args[5], args[6]);
      case 8:
        return Trampoline_TargetV(args[0], args[1], args[2], args[3],
                                  args[4], args[5], args[6], args[7]);
      case 9:
        return Trampoline_TargetV(args[0], args[1], args[2], args[3],
                                  args[4], args[5], args[6], args[7],
                                  args[8]);
      case 10:
        return Trampoline_TargetV(args[0], args[1], args[2], args[3],
                                  args[4], args[5], args[6], args[7],
                                  args[8], args[9]);
      case 11:
        return Trampoline_TargetV(args[0], args[1], args[2], args[3],
                                  args[4], args[5], args[6], args[7],
                                  args[8], args[9], args[10]);
      case 12:
        return Trampoline_TargetV(args[0], args[1], args[2], args[3],
                                  args[4], args[5], args[6], args[7],
                                  args[8], args[9], args[10], args[11]);
      case 13:
        return Trampoline_TargetV(args[0], args[1], args[2], args[3],
                                  args[4], args[5], args[6], args[7],
                                  args[8], args[9], args[10], args[11],
                                  args[12]);
      case 14:
        return Trampoline_TargetV(args[0], args[1], args[2], args[3],
                                  args[4], args[5], args[6], args[7],
                                  args[8], args[9], args[10], args[11],
                                  args[12], args[13]);
      case 15:
        return Trampoline_TargetV(args[0], args[1], args[2], args[3],
                                  args[4], args[5], args[6], args[7],
                                  args[8], args[9], args[10], args[11],
                                  args[12], args[13], args[14]);
      case 16:
        return Trampoline_TargetV(args[0], args[1], args[2], args[3],
                                  args[4], args[5], args[6], args[7],
                                  args[8], args[9], args[10], args[11],
                                  args[12], args[13], args[14], args[15]);
      case 17:
        return Trampoline_TargetV(args[0], args[1], args[2], args[3],
                                  args[4], args[5], args[6], args[7],
                                  args[8], args[9], args[10], args[11],
                                  args[12], args[13], args[14], args[15],
                                  args[16]);
    }
}

DWORD_PTR WINAPI MyTargetR(DWORD_PTR v1, ...)
{
    DWORD_PTR args[32];

    va_list va;
    va_start(va, v1);

    int argc = 0;
    for (args[argc++] = v1; args[argc-1] != 0;) {
        args[argc++] = va_arg(va, DWORD_PTR);
    }
    va_end(va);

    if (v1 < 5) {
        printf("  MyTargetR (");
        int i = argc - 1;
        for (; i > 0; i--) {
            printf("%ld,", (DWORD)args[i]);
        }
        printf("%ld)\n", (DWORD)args[0]);
    }
    else {
        printf(".");
    }

    switch (argc) {
      default:
        return Trampoline_TargetR(0);
      case 1:
        return Trampoline_TargetR(args[0]);
      case 2:
        return Trampoline_TargetR(args[0], args[1]);
      case 3:
        return Trampoline_TargetR(args[0], args[1], args[2]);
      case 4:
        return Trampoline_TargetR(args[0], args[1], args[2], args[3]);
      case 5:
        return Trampoline_TargetR(args[0], args[1], args[2], args[3],
                                  args[4]);
      case 6:
        return Trampoline_TargetR(args[0], args[1], args[2], args[3],
                                  args[4], args[5]);
      case 7:
        return Trampoline_TargetR(args[0], args[1], args[2], args[3],
                                  args[4], args[5], args[6]);
      case 8:
        return Trampoline_TargetR(args[0], args[1], args[2], args[3],
                                  args[4], args[5], args[6], args[7]);
      case 9:
        return Trampoline_TargetR(args[0], args[1], args[2], args[3],
                                  args[4], args[5], args[6], args[7],
                                  args[8]);
      case 10:
        return Trampoline_TargetR(args[0], args[1], args[2], args[3],
                                  args[4], args[5], args[6], args[7],
                                  args[8], args[9]);
      case 11:
        return Trampoline_TargetR(args[0], args[1], args[2], args[3],
                                  args[4], args[5], args[6], args[7],
                                  args[8], args[9], args[10]);
      case 12:
        return Trampoline_TargetR(args[0], args[1], args[2], args[3],
                                  args[4], args[5], args[6], args[7],
                                  args[8], args[9], args[10], args[11]);
      case 13:
        return Trampoline_TargetR(args[0], args[1], args[2], args[3],
                                  args[4], args[5], args[6], args[7],
                                  args[8], args[9], args[10], args[11],
                                  args[12]);
      case 14:
        return Trampoline_TargetR(args[0], args[1], args[2], args[3],
                                  args[4], args[5], args[6], args[7],
                                  args[8], args[9], args[10], args[11],
                                  args[12], args[13]);
      case 15:
        return Trampoline_TargetR(args[0], args[1], args[2], args[3],
                                  args[4], args[5], args[6], args[7],
                                  args[8], args[9], args[10], args[11],
                                  args[12], args[13], args[14]);
      case 16:
        return Trampoline_TargetR(args[0], args[1], args[2], args[3],
                                  args[4], args[5], args[6], args[7],
                                  args[8], args[9], args[10], args[11],
                                  args[12], args[13], args[14], args[15]);
      case 17:
        return Trampoline_TargetR(args[0], args[1], args[2], args[3],
                                  args[4], args[5], args[6], args[7],
                                  args[8], args[9], args[10], args[11],
                                  args[12], args[13], args[14], args[15],
                                  args[16]);
    }
}

/////////////////////////////////////////////////////////// Recursive Detours.
//
DWORD_PTR (WINAPI * Trampoline_Target0_1)() = NULL;
DWORD_PTR (WINAPI * Trampoline_Target0_2)() = NULL;
DWORD_PTR (WINAPI * Trampoline_Target0_3)() = NULL;

static DWORD_PTR WINAPI MyTarget0_1()
{
    printf("  Starting Target0_1.\n");
    DWORD_PTR rv = Trampoline_Target0_1();
    printf("  End Target0_1.\n");
    return rv;
}

static DWORD_PTR WINAPI MyTarget0_2()
{
    printf("  Starting Target0_2.\n");
    DWORD_PTR rv = Trampoline_Target0_2();
    printf("  End Target0_2.\n");
    return rv;
}

static DWORD_PTR WINAPI MyTarget0_3()
{
    printf("  Starting Target0_3.\n");
    DWORD_PTR rv = Trampoline_Target0_3();
    printf("  End Target0_3.\n");
    return rv;
}

//////////////////////////////////////////////////////////////////////////////
//
int WINAPI WinMain(HINSTANCE hinst, HINSTANCE hprev, LPSTR lpszCmdLine, int nCmdShow)
{
    (void)hinst;
    (void)hprev;
    (void)lpszCmdLine;
    (void)nCmdShow;

    printf("Calling LocalTarget1 w/o detour\n");
    LocalTarget1(1);

    DetourTransactionBegin();
    DetourUpdateThread(GetCurrentThread());
    DetourAttach(&(PVOID&)Trampoline_LocalTarget1, MyLocalTarget1);
    DetourTransactionCommit();

    printf("Calling LocalTarget1 w/ detour\n");
    LocalTarget1(2);

    DetourTransactionBegin();
    DetourUpdateThread(GetCurrentThread());
    DetourAttach(&(PVOID&)Trampoline_Target0, MyTarget0);
    DetourTransactionCommit();

    printf("Calling Target0 function.\n");
    //dprintf("- Trampoline_Target0:: %p\n", Trampoline_Target0);
    //dprintf("- Target0           :: %p\n", Target0);
    Target0();

    DetourTransactionBegin();
    DetourUpdateThread(GetCurrentThread());
    DetourAttach(&(PVOID&)Trampoline_Target1, MyTarget1);
    DetourAttach(&(PVOID&)Trampoline_Target2, MyTarget2);
    DetourAttach(&(PVOID&)Trampoline_Target3, MyTarget3);
    DetourAttach(&(PVOID&)Trampoline_Target4, MyTarget4);
    DetourAttach(&(PVOID&)Trampoline_Target5, MyTarget5);
    DetourAttach(&(PVOID&)Trampoline_Target6, MyTarget6);
    DetourAttach(&(PVOID&)Trampoline_Target7, MyTarget7);
    DetourAttach(&(PVOID&)Trampoline_Target8, MyTarget8);
    DetourAttach(&(PVOID&)Trampoline_Target9, MyTarget9);
    DetourAttach(&(PVOID&)Trampoline_Target10, MyTarget10);
    DetourAttach(&(PVOID&)Trampoline_Target11, MyTarget11);
    DetourAttach(&(PVOID&)Trampoline_Target12, MyTarget12);
    DetourAttach(&(PVOID&)Trampoline_Target13, MyTarget13);
    DetourAttach(&(PVOID&)Trampoline_Target14, MyTarget14);
    DetourAttach(&(PVOID&)Trampoline_Target15, MyTarget15);
    DetourAttach(&(PVOID&)Trampoline_Target16, MyTarget16);
    DetourAttach(&(PVOID&)Trampoline_TargetV, MyTargetV);
    DetourAttach(&(PVOID&)Trampoline_TargetR, MyTargetR);
    DetourTransactionCommit();

    printf("Calling TargetN functions.\n");
    LocalTarget1(1);
    Target0();
    Target1(1);
    Target2(1,2);
    Target3(1,2,3);
    Target4(1,2,3,4);
    Target5(1,2,3,4,5);
    Target6(1,2,3,4,5,6);
    Target7(1,2,3,4,5,6,7);
    Target8(1,2,3,4,5,6,7,8);
    Target9(1,2,3,4,5,6,7,8,9);
    Target10(1,2,3,4,5,6,7,8,9,10);
    Target11(1,2,3,4,5,6,7,8,9,10,11);
    Target12(1,2,3,4,5,6,7,8,9,10,11,12);
    Target13(1,2,3,4,5,6,7,8,9,10,11,12,13);
    Target14(1,2,3,4,5,6,7,8,9,10,11,12,13,14);
    Target15(1,2,3,4,5,6,7,8,9,10,11,12,13,14,15);
    Target16(1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16);
    TargetV(0);
    TargetV(1,0);
    TargetV(2,1,0);
    TargetV(3,2,1,0);
    TargetV(4,3,2,1,0);
    TargetV(5,4,3,2,1,0);
    TargetV(6,5,4,3,2,1,0);
    TargetV(7,6,5,4,3,2,1,0);
    TargetV(8,7,6,5,4,3,2,1,0);
    TargetV(9,8,7,6,5,4,3,2,1,0);
    TargetV(10,9,8,7,6,5,4,3,2,1,0);
    TargetV(11,10,9,8,7,6,5,4,3,2,1,0);
    TargetV(12,11,10,9,8,7,6,5,4,3,2,1,0);
    TargetV(13,12,11,10,9,8,7,6,5,4,3,2,1,0);
    TargetV(14,13,12,11,10,9,8,7,6,5,4,3,2,1,0);
    TargetV(15,14,13,12,11,10,9,8,7,6,5,4,3,2,1,0);
    TargetV(16,15,14,13,12,11,10,9,8,7,6,5,4,3,2,1,0);
    TargetR(4,3,2,1,0);
    DWORD_PTR rv = TargetR(100,10,9,8,7,6,5,4,3,2,1,0);
    printf(" => %ld\n", (DWORD)rv);

    Trampoline_Target0_1 = Target0;
    Trampoline_Target0_2 = Target0;
    Trampoline_Target0_3 = Target0;

    //dprintf("Trampoline_Target0_1 = %p\n", DetourCodeFromPointer(Trampoline_Target0_1, NULL));
    //__debugbreak();

    printf("Calling Target0 again with 1 detour.\n");
    Target0();

    DetourTransactionBegin();
    DetourUpdateThread(GetCurrentThread());
    DetourAttach(&(PVOID&)Trampoline_Target0_1, MyTarget0_1);
    DetourTransactionCommit();

    //dprintf("Trampoline_Target0_2 = %p\n", DetourCodeFromPointer(Trampoline_Target0_2, NULL));
    //__debugbreak();
    printf("Calling Target0 again with 2 detours.\n");
    Target0();

    DetourTransactionBegin();
    DetourUpdateThread(GetCurrentThread());
    DetourAttach(&(PVOID&)Trampoline_Target0_2, MyTarget0_2);
    DetourTransactionCommit();

    //dprintf("Trampoline_Target0_3 = %p\n", DetourCodeFromPointer(Trampoline_Target0_3, NULL));
    //__debugbreak();
    printf("Calling Target0 again with 3 detours.\n");
    Target0();


    DetourTransactionBegin();
    DetourUpdateThread(GetCurrentThread());
    DetourAttach(&(PVOID&)Trampoline_Target0_3, MyTarget0_3);
    DetourTransactionCommit();

    //dprintf("Trampoline_Target0_3 = %p\n", DetourCodeFromPointer(Trampoline_Target0_3, NULL));
    //__debugbreak();
    printf("Calling Target0 again with 4 detours.\n");
    Target0();

    DetourTransactionBegin();
    DetourUpdateThread(GetCurrentThread());
    DetourDetach(&(PVOID&)Trampoline_Target0, MyTarget0);
    DetourDetach(&(PVOID&)Trampoline_Target1, MyTarget1);
    DetourDetach(&(PVOID&)Trampoline_Target2, MyTarget2);
    DetourDetach(&(PVOID&)Trampoline_Target3, MyTarget3);
    DetourDetach(&(PVOID&)Trampoline_Target4, MyTarget4);
    DetourDetach(&(PVOID&)Trampoline_Target5, MyTarget5);
    DetourDetach(&(PVOID&)Trampoline_Target6, MyTarget6);
    DetourDetach(&(PVOID&)Trampoline_Target7, MyTarget7);
    DetourDetach(&(PVOID&)Trampoline_Target8, MyTarget8);
    DetourDetach(&(PVOID&)Trampoline_Target9, MyTarget9);
    DetourDetach(&(PVOID&)Trampoline_Target10, MyTarget10);
    DetourDetach(&(PVOID&)Trampoline_Target11, MyTarget11);
    DetourDetach(&(PVOID&)Trampoline_Target12, MyTarget12);
    DetourDetach(&(PVOID&)Trampoline_Target13, MyTarget13);
    DetourDetach(&(PVOID&)Trampoline_Target14, MyTarget14);
    DetourDetach(&(PVOID&)Trampoline_Target15, MyTarget15);
    DetourDetach(&(PVOID&)Trampoline_Target16, MyTarget16);
    DetourDetach(&(PVOID&)Trampoline_TargetV, MyTargetV);
    DetourDetach(&(PVOID&)Trampoline_TargetR, MyTargetR);
    DetourTransactionCommit();

    printf("Done.\n");

    return 0;
}

//
///////////////////////////////////////////////////////////////// End of File.

```

`samples/dumpe/Makefile`:

```
##############################################################################
##
##  Makefile for Detours Test Programs.
##
##  Microsoft Research Detours Package
##
##  Copyright (c) Microsoft Corporation.  All rights reserved.
##

!include ..\common.mak

LIBS=$(LIBS) kernel32.lib

all: dirs \
    $(BIND)\dumpe.exe \
!IF $(DETOURS_SOURCE_BROWSING)==1
    $(OBJD)\dumpe.bsc
!ENDIF

clean:
    -del *~ 2>nul
    -del $(BIND)\dumpe.* 2>nul
    -rmdir /q /s $(OBJD) 2>nul

realclean: clean
    -rmdir /q /s $(OBJDS) 2>nul

dirs:
    @if not exist $(BIND) mkdir $(BIND) && echo.   Created $(BIND)
    @if not exist $(OBJD) mkdir $(OBJD) && echo.   Created $(OBJD)

$(OBJD)\dumpe.obj : dumpe.cpp

$(BIND)\dumpe.exe : $(OBJD)\dumpe.obj $(DEPS)
    cl $(CFLAGS) /Fe$@ /Fd$(@R).pdb $(OBJD)\dumpe.obj \
        /link $(LINKFLAGS) $(LIBS) \
        /subsystem:console

$(OBJD)\dumpe.bsc : $(OBJD)\dumpe.obj
    bscmake /v /n /o $@ $(OBJD)\dumpe.sbr

##############################################################################

test: $(BIND)\dumpe.exe
    $(BIND)\dumpe.exe $(BIND)\slept.dll

testx: $(BIND)\dumpe.exe
    cd $(MAKEDIR)\..\..\src
    nmake
    cd $(MAKEDIR)
    if exist $(SYSTEMROOT)\system32\browseui.dll $(BIND)\dumpe.exe browseui.dll

################################################################# End of File.

```

`samples/dumpe/dumpe.cpp`:

```cpp
//////////////////////////////////////////////////////////////////////////////
//
//  Detours Test Program (dumpe.cpp of dumpe.exe)
//
//  Microsoft Research Detours Package
//
//  Copyright (c) Microsoft Corporation.  All rights reserved.
//
#include <stdio.h>
#include <stdlib.h>
#include <windows.h>
#include <ole2.h>
#include <shellapi.h>
#include "detours.h"

//////////////////////////////////////////////////////////////////////////////
//
#ifndef NODEBUG
#undef ASSERT
VOID DetourAssertMessage(CONST PCHAR szMsg, CONST PCHAR szFile, DWORD nLine);

#define ASSERT(x)   \
do { if (!(x)) { DetourAssertMessage(#x, __FILE__, __LINE__); DebugBreak(); }} while (0)
    ;
#undef ASSERTX
#define ASSERTX(x)   \
do { if (!(x)) { DetourAssertMessage(#x, __FILE__, __LINE__); PCHAR p=(PCHAR)(x); *p = 1; }} while (0)
    ;
#else   // NODEBUG
#undef ASSERT
#define ASSERT(x)
#undef ASSERTX
#define ASSERTX(x)
#endif  // NODEBUG
//
//////////////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////// Error Messages.
//
VOID DetourAssertMessage(CONST PCHAR szMsg, CONST PCHAR szFile, DWORD nLine)
{
    printf("ASSERT(%s) failed in %s, line %ld.", szMsg, szFile, nLine);
}



static BOOL CALLBACK ExportCallback(PVOID pContext,
                                    ULONG nOrdinal,
                                    LPCSTR pszSymbol,
                                    PVOID pbTarget)
{
    (void)pContext;

    printf("    %7ld      %p %-30s\n",
           (ULONG)nOrdinal,
           pbTarget,
           pszSymbol ? pszSymbol : "[NONAME]");
    return TRUE;
}

BOOL DumpFile(PCHAR pszPath)
{
    HINSTANCE hInst = LoadLibraryA(pszPath);
    if (hInst == NULL) {
        printf("Unable to load %s: Error %ld\n", pszPath, GetLastError());
        return FALSE;
    }

    printf("%s @ %p\n", pszPath, hInst);

    PVOID pbEntry = DetourGetEntryPoint(hInst);
    printf("  EntryPoint: %p\n", pbEntry);

    printf("    Ordinal      RVA     Name\n");
    DetourEnumerateExports(hInst, NULL, ExportCallback);

    return TRUE;
}

//////////////////////////////////////////////////////////////////////////////
//
void PrintUsage(void)
{
    printf("Usage:\n"
           "    dumpe [.dll files]\n"
           "Misc. Options:\n"
           "    /?       : Help screen.\n");
}

//////////////////////////////////////////////////////////////////////// main.
//
int CDECL main(int argc, char **argv)
{
    BOOL fNeedHelp = FALSE;

    int arg = 1;
    for (; arg < argc; arg++) {
        if (argv[arg][0] == '-' || argv[arg][0] == '/') {
            CHAR *argn = argv[arg] + 1;
            CHAR *argp = argn;
            while (*argp && *argp != ':')
                argp++;
            if (*argp == ':')
                *argp++ = '\0';

            switch (argn[0]) {

            case '?':                                   // Help.
                fNeedHelp = TRUE;
                break;

            default:
                fNeedHelp = TRUE;
                printf("Bad argument: %s:%s\n", argn, argp);
                break;
            }
        }
        else {
            DumpFile(argv[arg]);
        }
    }
    if (fNeedHelp || argc == 1) {
        PrintUsage();
        return 1;
    }
    return 0;
}

// End of File

```

`samples/dumpi/Makefile`:

```
##############################################################################
##
##  Makefile for Detours Test Programs - Dump Imports
##
##  Microsoft Research Detours Package
##
##  Copyright (c) Microsoft Corporation.  All rights reserved.
##

!include ..\common.mak

LIBS=$(LIBS) kernel32.lib

all: dirs \
    $(BIND)\dumpi.exe \
!IF $(DETOURS_SOURCE_BROWSING)==1
    $(OBJD)\dumpi.bsc \
!ENDIF

clean:
    -del *~ 2>nul
    -del $(BIND)\dumpi.* 2>nul
    -rmdir /q /s $(OBJD) 2>nul

realclean: clean
    -rmdir /q /s $(OBJDS) 2>nul

dirs:
    @if not exist $(BIND) mkdir $(BIND) && echo.   Created $(BIND)
    @if not exist $(OBJD) mkdir $(OBJD) && echo.   Created $(OBJD)

$(OBJD)\dumpi.obj : dumpi.cpp

$(BIND)\dumpi.exe : $(OBJD)\dumpi.obj $(DEPS)
    cl $(CFLAGS) /Fe$@ /Fd$(@R).pdb $(OBJD)\dumpi.obj \
        /link $(LINKFLAGS) $(LIBS) \
        /subsystem:console

$(OBJD)\dumpi.bsc : $(OBJD)\dumpi.obj
    bscmake /v /n /o $@ $(OBJD)\dumpi.sbr

##############################################################################

test: $(BIND)\dumpi.exe
    $(BIND)\dumpi.exe $(BIND)\slept.dll $(BIND)\sleepold.exe

################################################################# End of File.

```

`samples/dumpi/dumpi.cpp`:

```cpp
//////////////////////////////////////////////////////////////////////////////
//
//  Detours Test Program (dumpi.cpp of dumpi.exe)
//
//  Microsoft Research Detours Package
//
//  Copyright (c) Microsoft Corporation.  All rights reserved.
//
#include <stdio.h>
#include <stdlib.h>
#include <windows.h>
#include <shellapi.h>
#pragma warning(push)
#if _MSC_VER > 1400
#pragma warning(disable:6102 6103) // /analyze warnings
#endif
#include <strsafe.h>
#pragma warning(pop)
#include <detours.h>

////////////////////////////////////////////////////////////// Error Messages.
//
VOID AssertMessage(PCSTR szMsg, PCSTR szFile, DWORD nLine)
{
    printf("ASSERT(%s) failed in %s, line %ld.", szMsg, szFile, nLine);
}

#define ASSERT(x)   \
do { if (!(x)) { AssertMessage(#x, __FILE__, __LINE__); DebugBreak(); }} while (0)
    ;

//////////////////////////////////////////////////////////////////////////////
//
static CHAR s_szFile[MAX_PATH] = "\0";

static BOOL CALLBACK ListFileCallback(_In_opt_ PVOID pContext,
                                      _In_z_ LPCSTR pszOrigFile,
                                      _In_z_ LPCSTR pszFile,
                                      _Outptr_result_maybenull_ LPCSTR *ppszOutFile)
{
    (void)pContext;
    (void)pszFile;

    *ppszOutFile = NULL;

    StringCchCopyA(s_szFile, sizeof(s_szFile), pszOrigFile);

    PCHAR psz;
    if ((psz = strchr(s_szFile, '.')) != NULL) {
        *psz = '\0';
    }
    return TRUE;
}

BOOL CALLBACK ListSymbolCallback(_In_opt_ PVOID pContext,
                                 _In_ ULONG nOrigOrdinal,
                                 _In_ ULONG nOrdinal,
                                 _Out_ ULONG *pnOutOrdinal,
                                 _In_opt_z_ LPCSTR pszOrigSymbol,
                                 _In_opt_z_ LPCSTR pszSymbol,
                                 _Outptr_result_maybenull_ LPCSTR *ppszOutSymbol)
{
    (void)pContext;
    (void)nOrdinal;
    (void)pszSymbol;

    *ppszOutSymbol = NULL;
    *pnOutOrdinal = 0;

    if (nOrigOrdinal != 0) {
        printf("  %s::#%ld\n",
               s_szFile, nOrigOrdinal);
    }
    else {
        printf("  %s::%s\n",
               s_szFile, pszOrigSymbol);
    }

    return TRUE;
}

BOOL DimpFile(PCHAR pszPath)
{
    BOOL bGood = TRUE;
    HANDLE hOld = INVALID_HANDLE_VALUE;
    PDETOUR_BINARY pBinary = NULL;


    hOld = CreateFileA(pszPath,
                       GENERIC_READ,
                       FILE_SHARE_READ,
                       NULL,
                       OPEN_EXISTING,
                       FILE_ATTRIBUTE_NORMAL,
                       NULL);

    if (hOld == INVALID_HANDLE_VALUE) {
        printf("%s: Failed to open input file with error: %ld\n",
               pszPath, GetLastError());
        bGood = FALSE;
        goto end;
    }

    if ((pBinary = DetourBinaryOpen(hOld)) == NULL) {
        printf("%s: DetourBinaryOpen failed: %ld\n", pszPath, GetLastError());
        goto end;
    }

    if (hOld != INVALID_HANDLE_VALUE) {
        CloseHandle(hOld);
        hOld = INVALID_HANDLE_VALUE;
    }

    printf("%s:\n", pszPath);
    if (!DetourBinaryEditImports(pBinary,
                                 NULL,
                                 NULL,
                                 ListFileCallback,
                                 ListSymbolCallback,
                                 NULL)) {

        printf("%s: DetourBinaryEditImports failed: %ld\n", pszPath, GetLastError());
    }

    DetourBinaryClose(pBinary);
    pBinary = NULL;

  end:
    if (pBinary) {
        DetourBinaryClose(pBinary);
        pBinary = NULL;
    }
    if (hOld != INVALID_HANDLE_VALUE) {
        CloseHandle(hOld);
        hOld = INVALID_HANDLE_VALUE;
    }
    return bGood;
}

//////////////////////////////////////////////////////////////////////////////
int DimpArgument(char *dir, char *argp, int fDoSubs)
{
    //////////////////////////////////////////////////////////////////////////

    WIN32_FIND_DATAA wfd;
    HANDLE  hFind = NULL;
    char    name[1024];
    int     nFound = 0;

    StringCchCopyA(name, sizeof(name), dir ? dir : "");
    StringCchCatA(name, sizeof(name), argp);

    hFind = FindFirstFileA(name, &wfd);
    if (hFind != INVALID_HANDLE_VALUE) {
        do {
            if (!(wfd.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY)) {
                StringCchCopyA(name, sizeof(name), dir ? dir : "");
                StringCchCatA(name, sizeof(name), wfd.cFileName);

                nFound += DimpFile(name);
            }
        } while (FindNextFileA(hFind, &wfd));
        FindClose(hFind);
    }

    if (fDoSubs) {
        StringCchCopyA(name, sizeof(name), dir ? dir : "");
        StringCchCatA(name, sizeof(name), "*");

        hFind = FindFirstFileA(name, &wfd);
        if (hFind == INVALID_HANDLE_VALUE)
            return nFound;

        do {
            if ((wfd.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY) &&
                wfd.cFileName[0] != '.') {

                StringCchCopyA(name, sizeof(name), dir ? dir : "");
                StringCchCatA(name, sizeof(name), wfd.cFileName);
                StringCchCatA(name, sizeof(name), "\\");

                nFound += DimpArgument(name, argp, fDoSubs);
            }
        } while (FindNextFileA(hFind, &wfd));
        FindClose(hFind);
    }
    return nFound;
}


//////////////////////////////////////////////////////////////////////////////
//
void PrintUsage(void)
{
    printf("Usage:\n"
           "    dimp [options] binary_files\n"
           "Options:\n"
           "    /s           : Recurse through subdirectories.\n"
           "    /?           : This help screen.\n"
           "Examples:\n"
           "    dimp /s *.exe\n"
           "");
}

//////////////////////////////////////////////////////////////////////// main.
//
int CDECL main(int argc, char **argv)
{
    BOOL fNeedHelp = FALSE;
    BOOL fSubdirs = FALSE;

    int arg = 1;
    for (; arg < argc; arg++) {
        if (argv[arg][0] == '-' || argv[arg][0] == '/') {
            CHAR *argn = argv[arg] + 1;
            CHAR *argp = argn;
            while (*argp && *argp != ':')
                argp++;
            if (*argp == ':')
                *argp++ = '\0';

            switch (argn[0]) {

              case 's':                                 // Do Subdirectories.
              case 'S':
                fSubdirs = TRUE;
                break;

              case '?':                                 // Help.
                fNeedHelp = TRUE;
                break;

              default:
                fNeedHelp = TRUE;
                printf("Bad argument: %s:%s\n", argn, argp);
                break;
            }
        }
        else {
            CHAR szDir[MAX_PATH] = "";
            CHAR szArg[MAX_PATH] = "";
            PCHAR pszDir;

            if ((pszDir = strrchr(argv[arg], '\\')) != NULL) {
                *pszDir++ = '\0';
                StringCchCopyA(szArg, sizeof(szArg), pszDir);
                StringCchCopyA(szDir, sizeof(szDir), argv[arg]);
                StringCchCatA(szDir, sizeof(szDir), "\\");
            }
            else {
                if (GetCurrentDirectoryA(sizeof(szDir), szDir) > 3) {
                    StringCchCatA(szDir, sizeof(szDir), "\\");
                }
                StringCchCopyA(szArg, sizeof(szArg), argv[arg]);
            }

            DimpArgument(szDir, szArg, fSubdirs);
        }
    }
    if (argc == 1) {
        fNeedHelp = TRUE;
    }
    if (fNeedHelp) {
        PrintUsage();
        return 1;
    }
    return 0;
}

// End of File

```

`samples/dynamic_alloc/Makefile`:

```
##############################################################################
##
##  Makefile for Detours Test Programs.
##
##  Microsoft Research Detours Package
##
##  Copyright (c) Microsoft Corporation.  All rights reserved.
##

!include ..\common.mak

# This test is x86 only
!IF "$(DETOURS_TARGET_PROCESSOR)" == "X86" || "$(DETOURS_TARGET_PROCESSOR)" == "X64"

TARGET_NAME=dalloc
CFLAGS=\
    $(CFLAGS)\
    /EHsc\

LIBS=$(LIBS)\
    user32.lib\

all: dirs $(BIND)\$(TARGET_NAME).exe

##############################################################################

clean:
    -del $(BIND)\$(TARGET_NAME).* 2>nul
    -rmdir /q /s $(OBJD) 2>nul

realclean: clean
    -rmdir /q /s $(OBJDS) 2>nul

##############################################################################

dirs:
    @if not exist $(BIND) mkdir $(BIND) && echo.   Created $(BIND)
    @if not exist $(OBJD) mkdir $(OBJD) && echo.   Created $(OBJD)

!IF "$(DETOURS_TARGET_PROCESSOR)" == "X64"
$(OBJD)\asm.obj : x64.asm
    $(ASM) $(AFLAGS) /Fl$(OBJD)\x64.lst /Fo$(OBJD)\asm.obj x64.asm
!ELSE
$(OBJD)\asm.obj : x86.asm
    $(ASM) $(AFLAGS) /Fl$(OBJD)\x86.lst /Fo$(OBJD)\asm.obj x86.asm
!ENDIF

$(OBJD)\main.obj : main.cpp

$(BIND)\$(TARGET_NAME).exe : $(OBJD)\main.obj $(OBJD)\asm.obj $(DEPS)
    link\
        /SUBSYSTEM:CONSOLE\
        $(LINKFLAGS)\
        $(LIBS)\
        /PDB:"$(@R).pdb"\
        /OUT:"$@"\
        $**\

##############################################################################

test: all
    $(BIND)\$(TARGET_NAME).exe

##############################################################################

!ELSE

all:
  @echo The platform `$(DETOURS_TARGET_PROCESSOR)` is not supported.  Skipping.
test:
  @echo The platform `$(DETOURS_TARGET_PROCESSOR)` is not supported.  Skipping.
clean:
realclean:

!ENDIF

################################################################# End of File.

```

`samples/dynamic_alloc/main.cpp`:

```cpp
//////////////////////////////////////////////////////////////////////////////
//
//  Detours Test Program
//
//  Microsoft Research Detours Package
//
//  Copyright (c) Microsoft Corporation.  All rights reserved.
//
//  This is a test program to test the DetourAllocateRegionWithinJumpBounds
//  API, that dynamically allocates an executable region adjacent to a given
//  address so that we can use the region as a detour function.
//
//  This test program detours the function `target_function`.  Instead of
//  simply specifying a code segment as a detour function, we specify a
//  dynamically-allocated region into which we copy the code, altering the
//  return value, from the assembly function `CodeTemplate` as a template.
//
#define _CRT_SECURE_NO_WARNINGS
#include <iostream>
#include <functional>
#include <assert.h>
#include <windows.h>
#include <detours.h>

extern "C" {
  void *CodeTemplate();
  void *CodeTemplate_End();
}

void Log(PCSTR format, ...) {
  char linebuf[1024];
  va_list v;
  va_start(v, format);
  wvsprintfA(linebuf, format, v);
  va_end(v);
  OutputDebugStringA(linebuf);
}

// This is a target function to be detoured.  When detoured, it's expected to
// return a non-nullptr value.
void *target_function() {
  std::cout << '+' << __FUNCTION__ << std::endl;
  return nullptr;
}

// Helper function to sandwich a given function between `DetourTransactionBegin`
// and `DetourTransactionCommit`/`DetourTransactionAbort`.
bool DetourTransaction(std::function<bool()> callback) {
  LONG status = DetourTransactionBegin();
  if (status != NO_ERROR) {
    Log("DetourTransactionBegin failed with %08x\n", status);
    return status == NO_ERROR;
  }

  if (callback()) {
    status = DetourTransactionCommit();
    if (status != NO_ERROR) {
      Log("DetourTransactionCommit failed with %08x\n", status);
    }
  }
  else {
    status = DetourTransactionAbort();
    if (status == NO_ERROR) {
      Log("Aborted transaction.\n");
    }
    else {
      Log("DetourTransactionAbort failed with %08x\n", status);
    }
  }
  return status == NO_ERROR;
}

// This class manages one dynamically-allocated region that is allocated by
// the Detours API `DetourAllocateRegionWithinJumpBounds`, to which we can
// push binary data sequentially to use it as a detour function.
class CodeRegionFactory final {
  template <typename T>
  static const T *at(const void *base, uint32_t offset) {
    return
      reinterpret_cast<const T*>(
        reinterpret_cast<const uint8_t*>(base) + offset);
  }

  template <typename T>
  static T *at(void *base, uint32_t offset) {
    return
      reinterpret_cast<T*>(
        reinterpret_cast<uint8_t*>(base) + offset);
  }

  void *region_ = nullptr;
  uint8_t *current_ = nullptr,
          *current_end_ = nullptr;

public:
  CodeRegionFactory(const void *source) {
    DWORD new_region_size = 0;
    auto new_region_address =
      DetourAllocateRegionWithinJumpBounds(source, &new_region_size);
    if (new_region_address) {
      region_ = current_ = at<uint8_t>(new_region_address, 0);
      current_end_ = current_ + new_region_size;
    }
    else {
      Log("Cannot find a region near %p\n", source);
    }
  }

  ~CodeRegionFactory() {
    if (region_
        && !VirtualFree(region_, 0, MEM_RELEASE)) {
      Log("VirtualFree failed - %08x\n", GetLastError());
    }
  }

  // Pushes binary data to the region if there is enough space, and returns
  // the start address of a copy in the region if succeeded.
  void *PushTemplate(const void *start,
                     const void *end) {
    auto diff = at<uint8_t>(end, 0) - at<uint8_t>(start, 0);
    if (diff < 0 || current_ + diff > current_end_)
      return nullptr;
    auto start_pos = current_;
    memcpy(start_pos, start, diff);
    current_ += diff;
    return start_pos;
  }
};

int main(int, char**) {
  std::cout << "1. target_function() without Detour" << std::endl;
  auto ret = target_function();
  std::cout << ret << std::endl;
  assert(!ret);

  CodeRegionFactory factory(target_function);

  void *detour_destination,
       *detour_target = reinterpret_cast<void*>(target_function);

  // Fill the allocated page with as many instances as possible of the code
  // template, and pick the last instance
  while (auto p = factory.PushTemplate(CodeTemplate,
                                       CodeTemplate_End)) {
    detour_destination = p;
  }

  bool is_detoured = false;
  DetourTransaction([&]() {
    PDETOUR_TRAMPOLINE trampoline = nullptr;
    void *target = nullptr,
         *detour = nullptr;
    auto status = DetourAttachEx(&detour_target,
                                 detour_destination,
                                 &trampoline,
                                 &target,
                                 &detour);
    if (status != NO_ERROR) {
      Log("DetourAttachEx failed - %08x\n", status);
      return false;
    }
    is_detoured = true;
    std::cout
      << "detour: " << target << " --> " << detour
      << " (trampoline: " << trampoline << " )"
      << std::endl;
    return true;
  });

  // Attach failed for some reason.  Bail out.
  if (!is_detoured)
    return 1;

  std::cout << "2. target_function() with Detour" << std::endl;
  ret = target_function();
  std::cout << ret << std::endl;
  assert(ret); // The return value is cracked by the detour function

  DetourTransaction([&]() {
    auto status = DetourDetach(&detour_target, detour_destination);
    if (status != NO_ERROR) {
      Log("DetourDetach failed - %08x\n", status);
      return false;
    }
    return true;
  });

  std::cout << "3. target_function() without Detour" << std::endl;
  ret = target_function();
  std::cout << ret << std::endl;
  assert(!ret);

  return 0;
}
```

`samples/dynamic_alloc/x64.asm`:

```asm
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
;;  Detours Test Program
;;
;;  Microsoft Research Detours Package
;;
;;  Copyright (c) Microsoft Corporation.  All rights reserved.
;;
PUBLIC CodeTemplate
PUBLIC CodeTemplate_End

_TEXT SEGMENT

CodeTemplate PROC
  nop
  nop
  mov rax, 0deadbeef00000000h
  nop
  ret
CodeTemplate_End::
CodeTemplate ENDP

_TEXT ENDS

END

```

`samples/dynamic_alloc/x86.asm`:

```asm
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
;;  Detours Test Program
;;
;;  Microsoft Research Detours Package
;;
;;  Copyright (c) Microsoft Corporation.  All rights reserved.
;;
.386
.model flat,C

PUBLIC CodeTemplate
PUBLIC CodeTemplate_End

_TEXT SEGMENT

CodeTemplate PROC
  nop
  nop
  nop
  mov eax, 0deadbeefh
  nop
  nop
  nop
  ret
CodeTemplate_End::
CodeTemplate ENDP

_TEXT ENDS

END

```

`samples/echo/Makefile`:

```
##############################################################################
##
##  Detours Test Program
##
##  Microsoft Research Detours Package
##
##  Copyright (c) Microsoft Corporation.  All rights reserved.
##

!include ..\common.mak

LIBS=$(LIBS) kernel32.lib

##############################################################################

all: dirs \
    $(BIND)\echofx$(DETOURS_BITS).dll \
    $(BIND)\echonul.exe \
    \
!IF $(DETOURS_SOURCE_BROWSING)==1
    $(OBJD)\echofx$(DETOURS_BITS).bsc \
    $(OBJD)\echonul.bsc \
!ENDIF
    option

##############################################################################

dirs:
    @if not exist $(BIND) mkdir $(BIND) && echo.   Created $(BIND)
    @if not exist $(OBJD) mkdir $(OBJD) && echo.   Created $(OBJD)

$(OBJD)\echofx.obj : echofx.cpp

$(OBJD)\echofx.res : echofx.rc

$(BIND)\echofx$(DETOURS_BITS).dll $(BIND)\echofx$(DETOURS_BITS).lib: \
        $(OBJD)\echofx.obj $(OBJD)\echofx.res $(DEPS) $(BIND)\echonul.lib
    cl /LD $(CFLAGS) /Fe$@ /Fd$(@R).pdb \
        $(OBJD)\echofx.obj $(OBJD)\echofx.res \
        /link $(LINKFLAGS) /subsystem:console \
        /export:DetourFinishHelperProcess,@1,NONAME \
        /export:Mine_Echo \
        $(LIBS) $(BIND)\echonul.lib

$(OBJD)\echofx$(DETOURS_BITS).bsc : $(OBJD)\echofx.obj
    bscmake /v /n /o $@ $(OBJD)\echofx.sbr

$(OBJD)\echonul.obj : echonul.cpp
$(OBJD)\main.obj : main.cpp

$(BIND)\echonul.exe $(BIND)\echonul.lib: $(OBJD)\main.obj $(OBJD)\echonul.obj
    cl $(CFLAGS) /Zl /Fe$(BIND)\echonul.exe /Fd$(@R).pdb \
        $(OBJD)\main.obj $(OBJD)\echonul.obj \
        /link $(LINKFLAGS) \
        /export:Echo \
        /subsystem:console

$(OBJD)\echonul.bsc : echonul.obj
    bscmake /v /n /o $@ echonul.sbr

##############################################################################

clean:
    -del *~ 2>nul
    -del $(BIND)\echofx*.* 2>nul
    -del $(BIND)\echonul.* 2>nul
    -rmdir /q /s $(OBJD) 2>nul

realclean: clean
    -rmdir /q /s $(OBJDS) 2>nul

############################################### Install non-bit-size binaries.

!IF "$(DETOURS_OPTION_PROCESSOR)" != ""

$(OPTD)\echofx$(DETOURS_OPTION_BITS).dll:
$(OPTD)\echofx$(DETOURS_OPTION_BITS).pdb:

$(BIND)\echofx$(DETOURS_OPTION_BITS).dll : $(OPTD)\echofx$(DETOURS_OPTION_BITS).dll
    @if exist $? copy /y $? $(BIND) >nul && echo $@ copied from $(DETOURS_OPTION_PROCESSOR).
$(BIND)\echofx$(DETOURS_OPTION_BITS).pdb : $(OPTD)\echofx$(DETOURS_OPTION_BITS).pdb
    @if exist $? copy /y $? $(BIND) >nul && echo $@ copied from $(DETOURS_OPTION_PROCESSOR).

option: \
    $(BIND)\echofx$(DETOURS_OPTION_BITS).dll \
    $(BIND)\echofx$(DETOURS_OPTION_BITS).pdb \

!ELSE

option:

!ENDIF

##############################################################################

test: all
    @echo -------- Should echo nothing. --------------------------------------
    -$(BIND)\echonul.exe
    @echo -------- Should echo Hello World. ----------------------------------
    -$(BIND)\withdll.exe -d:$(BIND)\echofx$(DETOURS_BITS).dll $(BIND)\echonul.exe
    @echo.

testd: all
    @echo.
    -windbg -o -g -G $(BIND)\withdll.exe -d:$(BIND)\echofx$(DETOURS_BITS).dll $(BIND)\echonul.exe
    @echo.

################################################################# End of File.

```

`samples/echo/echofx.cpp`:

```cpp
//
//
//
#include <windows.h>
#include <detours.h>
#include <stdio.h>

int WINAPI Echo(PCSTR pszMsg);

static int (WINAPI * Real_Echo)(PCSTR pszMsg) = Echo;

int WINAPI Mine_Echo(PCSTR pszMsg)
{
    printf("Echo(%s)\n", pszMsg);
    return Real_Echo(pszMsg);
}

BOOL WINAPI DllMain(HINSTANCE hinst, DWORD dwReason, LPVOID reserved)
{
    LONG error;
    (void)hinst;
    (void)reserved;

    if (DetourIsHelperProcess()) {
        return TRUE;
    }

    if (dwReason == DLL_PROCESS_ATTACH) {
        DetourRestoreAfterWith();

        printf("echofx" DETOURS_STRINGIFY(DETOURS_BITS) ".dll:"
               " Starting.\n");
        fflush(stdout);

        DetourTransactionBegin();
        DetourUpdateThread(GetCurrentThread());
        DetourAttach(&(PVOID&)Real_Echo, Mine_Echo);
        error = DetourTransactionCommit();

        if (error == NO_ERROR) {
            printf("echofx" DETOURS_STRINGIFY(DETOURS_BITS) ".dll:"
                   " Detoured Echo().\n");
        }
        else {
            printf("echofx" DETOURS_STRINGIFY(DETOURS_BITS) ".dll:"
                   " Error detouring Echo(): %ld\n", error);
        }
    }
    else if (dwReason == DLL_PROCESS_DETACH) {
        DetourTransactionBegin();
        DetourUpdateThread(GetCurrentThread());
        DetourDetach(&(PVOID&)Real_Echo, Mine_Echo);
        error = DetourTransactionCommit();

        printf("echofx" DETOURS_STRINGIFY(DETOURS_BITS) ".dll:"
               " Removed Echo() (result=%ld)\n", error);
        fflush(stdout);
    }
    return TRUE;
}

```

`samples/echo/echofx.rc`:

```rc
//////////////////////////////////////////////////////////////////////////////
//
//  Version information for echofx.rc.
//
//  Microsoft Research Detours Package
//
//  Copyright (c) Microsoft Corporation.  All rights reserved.
//

#include "detver.h"

#define VER_INTERNALNAME_STR        "echofx" DETOURS_STRINGIFY(DETOURS_BITS)
#define VER_ORIGINALFILENAME_STR    "echofx" DETOURS_STRINGIFY(DETOURS_BITS) ".dll"
#define VER_FILEDESCRIPTION_STR     "Detours Echo Interception Module"
#define VER_COMPANYNAME_STR         "Microsoft Corporation"

#include "common.ver"

```

`samples/echo/echonul.cpp`:

```cpp
//
//
//
#include <windows.h>

int WINAPI Echo(PCSTR pszMsg)
{
    int sum = 0;
    while (*pszMsg) {
        sum = sum + *pszMsg++;
    }
    return sum;
}

int main()
{
    return 0;
}

```

`samples/echo/main.cpp`:

```cpp
//
//
//
#include <windows.h>

int WINAPI Echo(PCSTR pszMsg);

extern "C" int __stdcall mainCRTStartup(HINSTANCE hInstance,
                             HINSTANCE hPrevInstance,
                             LPSTR lpCmdLine,
                             int nCmdShow
                            )
{
    (void)hInstance;
    (void)hPrevInstance;
    (void)lpCmdLine;
    (void)nCmdShow;

    Echo("Hello World");
    Echo("Goodbye World");

    return 0x99;
}


```

`samples/einst/Makefile`:

```
##############################################################################
##
##  Makefile for Detours Test Programs.
##
##  Microsoft Research Detours Package
##
##  Copyright (c) Microsoft Corporation.  All rights reserved.
##

!include ..\common.mak

# ARM64 does not like base addresses below 4GB.
# Append two extra zeros for it.
#
!if "$(DETOURS_TARGET_PROCESSOR)" == "ARM64"
EDLL1X_BASE=0x710000000
EDLL2X_BASE=0x720000000
EDLL3X_BASE=0x730000000
!else
EDLL1X_BASE=0x7100000
EDLL2X_BASE=0x7200000
EDLL3X_BASE=0x7300000
!endif

LIBS=$(LIBS) kernel32.lib user32.lib

all: dirs \
    $(BIND)\edll1x$(DETOURS_BITS).dll \
    $(BIND)\edll2x$(DETOURS_BITS).dll \
    $(BIND)\edll3x$(DETOURS_BITS).dll \
    $(BIND)\einst.exe \
    \
!IF $(DETOURS_SOURCE_BROWSING)==1
    $(OBJD)\edll1x$(DETOURS_BITS).bsc \
    $(OBJD)\edll2x$(DETOURS_BITS).bsc \
    $(OBJD)\edll3x$(DETOURS_BITS).bsc \
    $(OBJD)\einst.bsc \
!ENDIF
    option

clean:
    -del *~ 2>nul
    -del $(BIND)\edll1x*.* 2>nul
    -del $(BIND)\edll2x*.* 2>nul
    -del $(BIND)\edll3x*.* 2>nul
    -del $(BIND)\einst.* 2>nul
    -rmdir /q /s $(OBJD) 2>nul

realclean: clean
    -rmdir /q /s $(OBJDS) 2>nul

dirs:
    @if not exist $(BIND) mkdir $(BIND) && echo.   Created $(BIND)
    @if not exist $(OBJD) mkdir $(OBJD) && echo.   Created $(OBJD)

##############################################################################

$(OBJD)\einst.obj : einst.cpp

$(BIND)\einst.exe : $(OBJD)\einst.obj $(DEPS)
    cl $(CFLAGS) /Fe$@ /Fd$(@R).pdb $(OBJD)\einst.obj \
        /link $(LINKFLAGS) $(LIBS) \
        $(BIND)\edll1x$(DETOURS_BITS).lib $(BIND)\edll2x$(DETOURS_BITS).lib $(BIND)\edll3x$(DETOURS_BITS).lib \
        /subsystem:console /entry:WinMainCRTStartup

$(OBJD)\einst.bsc : $(OBJD)\einst.obj
    bscmake /v /n /o $@ $(OBJD)\einst.sbr

$(OBJD)\edll1x.obj : edll1x.cpp

$(BIND)\edll1x$(DETOURS_BITS).dll : $(OBJD)\edll1x.obj $(DEPS)
    cl $(CFLAGS) /Fe$@ /Fd$(@R).pdb \
        $(OBJD)\edll1x.obj /LD \
        /link $(LINKFLAGS) $(LIBS) \
        /subsystem:windows \
        /base:$(EDLL1X_BASE)

$(OBJD)\edll1x$(DETOURS_BITS).bsc : $(OBJD)\edll1x.obj
    bscmake /v /n /o $@ $(OBJD)\edll1x.sbr

$(OBJD)\edll2x.obj : edll2x.cpp

$(BIND)\edll2x$(DETOURS_BITS).dll : $(OBJD)\edll2x.obj $(DEPS)
    cl $(CFLAGS) /Fe$@ /Fd$(@R).pdb \
        $(OBJD)\edll2x.obj /LD \
        /link $(LINKFLAGS) $(LIBS) \
        /subsystem:console \
        /base:$(EDLL2X_BASE)

$(OBJD)\edll2x$(DETOURS_BITS).bsc : $(OBJD)\edll2x.obj
    bscmake /v /n /o $@ $(OBJD)\edll2x.sbr

$(OBJD)\edll3x.obj : edll3x.cpp

$(BIND)\edll3x$(DETOURS_BITS).dll : $(OBJD)\edll3x.obj $(DEPS)
    cl $(CFLAGS) /Fe$@ /Fd$(@R).pdb \
        $(OBJD)\edll3x.obj /LD \
        /link $(LINKFLAGS) $(LIBS) \
        /subsystem:console \
        /base:$(EDLL3X_BASE)

$(OBJD)\edll3x$(DETOURS_BITS).bsc : $(OBJD)\edll3x.obj
    bscmake /v /n /o $@ $(OBJD)\edll3x.sbr

############################################### Install non-bit-size binaries.

!IF "$(DETOURS_OPTION_PROCESSOR)" != ""

$(OPTD)\edll1x$(DETOURS_OPTION_BITS).dll:
$(OPTD)\edll1x$(DETOURS_OPTION_BITS).pdb:
$(OPTD)\edll2x$(DETOURS_OPTION_BITS).dll:
$(OPTD)\edll2x$(DETOURS_OPTION_BITS).pdb:
$(OPTD)\edll3x$(DETOURS_OPTION_BITS).dll:
$(OPTD)\edll3x$(DETOURS_OPTION_BITS).pdb:

$(BIND)\edll1x$(DETOURS_OPTION_BITS).dll : $(OPTD)\edll1x$(DETOURS_OPTION_BITS).dll
    @if exist $? copy /y $? $(BIND) >nul && echo $@ copied from $(DETOURS_OPTION_PROCESSOR).
$(BIND)\edll1x$(DETOURS_OPTION_BITS).pdb : $(OPTD)\edll1x$(DETOURS_OPTION_BITS).pdb
    @if exist $? copy /y $? $(BIND) >nul && echo $@ copied from $(DETOURS_OPTION_PROCESSOR).
$(BIND)\edll2x$(DETOURS_OPTION_BITS).dll : $(OPTD)\edll2x$(DETOURS_OPTION_BITS).dll
    @if exist $? copy /y $? $(BIND) >nul && echo $@ copied from $(DETOURS_OPTION_PROCESSOR).
$(BIND)\edll2x$(DETOURS_OPTION_BITS).pdb : $(OPTD)\edll2x$(DETOURS_OPTION_BITS).pdb
    @if exist $? copy /y $? $(BIND) >nul && echo $@ copied from $(DETOURS_OPTION_PROCESSOR).
$(BIND)\edll3x$(DETOURS_OPTION_BITS).dll : $(OPTD)\edll3x$(DETOURS_OPTION_BITS).dll
    @if exist $? copy /y $? $(BIND) >nul && echo $@ copied from $(DETOURS_OPTION_PROCESSOR).
$(BIND)\edll3x$(DETOURS_OPTION_BITS).pdb : $(OPTD)\edll3x$(DETOURS_OPTION_BITS).pdb
    @if exist $? copy /y $? $(BIND) >nul && echo $@ copied from $(DETOURS_OPTION_PROCESSOR).

option: \
    $(BIND)\edll1x$(DETOURS_OPTION_BITS).dll \
    $(BIND)\edll1x$(DETOURS_OPTION_BITS).pdb \
    $(BIND)\edll2x$(DETOURS_OPTION_BITS).dll \
    $(BIND)\edll2x$(DETOURS_OPTION_BITS).pdb \
    $(BIND)\edll3x$(DETOURS_OPTION_BITS).dll \
    $(BIND)\edll3x$(DETOURS_OPTION_BITS).pdb \

!ELSE

option:

!ENDIF

##############################################################################

test: all
    $(BIND)\einst.exe

################################################################# End of File.

```

`samples/einst/edll1x.cpp`:

```cpp
//////////////////////////////////////////////////////////////////////////////
//
//  Detours Test Program (edll1x.cpp of edll1x.dll)
//
//  Microsoft Research Detours Package
//
//  Copyright (c) Microsoft Corporation.  All rights reserved.
//
#include <stdio.h>
#include <windows.h>
#include <detours.h>

//////////////////////////////////////////////////////////////////// DLL Stuff
//
struct CPrivateStuff
{
    DETOUR_SECTION_HEADER   header;
    DETOUR_SECTION_RECORD   record;
    CHAR                    szMessage[32];
};

#pragma data_seg(".detour")

static CPrivateStuff private_stuff = {
    DETOUR_SECTION_HEADER_DECLARE(sizeof(CPrivateStuff)),
    {
        (sizeof(CPrivateStuff) - sizeof(DETOUR_SECTION_HEADER)),
        0,
        { /* d9ab8a40-f4cc-11d1-b6d7-006097b010e3 */
            0xd9ab8a40,
            0xf4cc,
            0x11d1,
            {0xb6, 0xd7, 0x00, 0x60, 0x97, 0xb0, 0x10, 0xe3}
        }
    },
    "The First Dll!"
};
#pragma data_seg()

__declspec(dllexport) VOID WINAPI EDll1Function(VOID)
{
    return;
}

__declspec(dllexport) ULONG WINAPI
DllMain(HINSTANCE hInstance, DWORD dwReason, PVOID lpReserved)
{
    (void)hInstance;
    (void)dwReason;
    (void)lpReserved;

    return TRUE;
}

///////////////////////////////////////////////////////////////// End of File.

```

`samples/einst/edll2x.cpp`:

```cpp
//////////////////////////////////////////////////////////////////////////////
//
//  Detours Test Program (edll2x.cpp of einst.exe/edll2x.dll)
//
//  Microsoft Research Detours Package
//
//  Copyright (c) Microsoft Corporation.  All rights reserved.
//
#include <stdio.h>
#include <windows.h>
#include <detours.h>

//////////////////////////////////////////////////////////////////// DLL Stuff
//
struct CPrivateStuff
{
    DETOUR_SECTION_HEADER   header;
    DETOUR_SECTION_RECORD   record;
    CHAR                    szMessage[32];
};

#pragma data_seg(".detour")

static CPrivateStuff private_stuff = {
    DETOUR_SECTION_HEADER_DECLARE(sizeof(CPrivateStuff)),
    {
        (sizeof(CPrivateStuff) - sizeof(DETOUR_SECTION_HEADER)),
        0,
        { /* d9ab8a40-f4cc-11d1-b6d7-006097b010e3 */
            0xd9ab8a40,
            0xf4cc,
            0x11d1,
            {0xb6, 0xd7, 0x00, 0x60, 0x97, 0xb0, 0x10, 0xe3}
        }
    },
    "The Second Dll!"
};
#pragma data_seg()

__declspec(dllexport) VOID WINAPI EDll2Function(VOID)
{
    return;
}

__declspec(dllexport) ULONG WINAPI
DllMain(HINSTANCE hInstance, DWORD dwReason, PVOID lpReserved)
{
    (void)hInstance;
    (void)dwReason;
    (void)lpReserved;

    return TRUE;
}

///////////////////////////////////////////////////////////////// End of File.

```

`samples/einst/edll3x.cpp`:

```cpp
//////////////////////////////////////////////////////////////////////////////
//
//  Detours Test Program (edll3x.cpp of einst.exe/edll3x.dll)
//
//  Microsoft Research Detours Package
//
//  Copyright (c) Microsoft Corporation.  All rights reserved.
//
#include <stdio.h>
#include <windows.h>
#include <detours.h>

//////////////////////////////////////////////////////////////////// DLL Stuff
//
struct CPrivateStuffPart1
{
    DETOUR_SECTION_RECORD   header;
    CHAR                    szMessage[48];
};

struct CPrivateStuffPart2
{
    DETOUR_SECTION_RECORD   header;
    CHAR                    szMessage[64];
};

struct CPrivateStuff
{
    DETOUR_SECTION_HEADER   header;
    CPrivateStuffPart1      record1;
    CPrivateStuffPart2      record2;
};

#pragma data_seg(".detour")

static CPrivateStuff private_stuff = {
    DETOUR_SECTION_HEADER_DECLARE(sizeof(CPrivateStuff)),
    {
        {
            sizeof(CPrivateStuffPart1),
            0,
            { /* d9ab8a41-f4cc-11d1-b6d7-006097b010e3 */
                0xd9ab8a41,
                0xf4cc,
                0x11d1,
                {0xb6, 0xd7, 0x00, 0x60, 0x97, 0xb0, 0x10, 0xe3}
            }
        },
        "The Third DLL Part One!"
    },
    {
        {
            sizeof(CPrivateStuffPart2),
            0,
            { /* d9ab8a40-f4cc-11d1-b6d7-006097b010e3 */
                0xd9ab8a40,
                0xf4cc,
                0x11d1,
                {0xb6, 0xd7, 0x00, 0x60, 0x97, 0xb0, 0x10, 0xe3}
            }
        },
        "The Third DLL Part Two!"
    }
};
#pragma data_seg()

__declspec(dllexport) VOID WINAPI EDll3Function(VOID)
{
    return;
}

__declspec(dllexport) ULONG WINAPI
DllMain(HINSTANCE hInstance, DWORD dwReason, PVOID lpReserved)
{
    (void)hInstance;
    (void)dwReason;
    (void)lpReserved;

    return TRUE;
}

///////////////////////////////////////////////////////////////// End of File.

```

`samples/einst/einst.cpp`:

```cpp
//////////////////////////////////////////////////////////////////////////////
//
//  Detours Test Program (einst.cpp of einst.exe)
//
//  Microsoft Research Detours Package
//
//  Copyright (c) Microsoft Corporation.  All rights reserved.
//
#include <stdio.h>
#include <windows.h>
#include <detours.h>

struct CPrivateStuff
{
    DETOUR_SECTION_HEADER   header;
    DETOUR_SECTION_RECORD   record;
    CHAR                    szMessage[32];
};

#ifdef INCLUDE_THIS
#pragma data_seg(".detour")

static CPrivateStuff private_stuff = {
    DETOUR_SECTION_HEADER_DECLARE(sizeof(CPrivateStuff)),
    {
        (sizeof(CPrivateStuff) - sizeof(DETOUR_SECTION_HEADER)),
        0,
        { /* d9ab8a40-f4cc-11d1-b6d7-006097b010e3 */
            0xd9ab8a40,
            0xf4cc,
            0x11d1,
            {0xb6, 0xd7, 0x00, 0x60, 0x97, 0xb0, 0x10, 0xe3}
        }
    },
    "The Application!"
};
#pragma data_seg()
#endif

GUID my_guid =
{ /* d9ab8a40-f4cc-11d1-b6d7-006097b010e3 */
    0xd9ab8a40,
    0xf4cc,
    0x11d1,
    {0xb6, 0xd7, 0x00, 0x60, 0x97, 0xb0, 0x10, 0xe3}
};

__declspec(dllimport) VOID WINAPI EDll1Function(VOID);
__declspec(dllimport) VOID WINAPI EDll2Function(VOID);
__declspec(dllimport) VOID WINAPI EDll3Function(VOID);

void FindPayload(HINSTANCE hinst)
{
    CHAR szModuleName[256];
    GetModuleFileNameA(hinst, szModuleName, ARRAYSIZE(szModuleName));
    printf("  %p : %s\n", hinst, szModuleName);

    ULONG cbData = 0;
    PBYTE pbData = (PBYTE)DetourFindPayload(hinst, my_guid, &cbData);

    if (pbData) {
        printf("  %08p..%08p : %50.50s\n",
               pbData,
               pbData + cbData,
               pbData);
    }
}

int WINAPI WinMain(HINSTANCE hinst, HINSTANCE hprev, LPSTR lpszCmdLine, int nCmdShow)
{
    (void)hinst;
    (void)hprev;
    (void)lpszCmdLine;
    (void)nCmdShow;

    printf("Source .EXE:\n");
    FindPayload(NULL);
    printf("\n");

    printf("DLL and EXE binaries loaded:\n");

    EDll1Function();
    EDll2Function();
    EDll3Function();

    for (HINSTANCE hiter = NULL; (hiter = DetourEnumerateModules(hiter)) != NULL;) {
        FindPayload(hiter);
    }

    if ((PVOID)hinst == (PVOID)lpszCmdLine) {
        DispatchMessage(NULL);                          // Force load of gdi32.dll
    }

    return 0;
}

//
///////////////////////////////////////////////////////////////// End of File.

```

`samples/excep/Makefile`:

```
##############################################################################
##
##  Makefile for Detours Test Programs.
##
##  Microsoft Research Detours Package
##
##  Copyright (c) Microsoft Corporation.  All rights reserved.
##

!include ..\common.mak

LIBS=$(LIBS) kernel32.lib

all: dirs \
    $(BIND)\excep.exe \
!IF $(DETOURS_SOURCE_BROWSING)==1
    $(OBJD)\excep.bsc
!ENDIF

clean:
    -del *~ 2>nul
    -del $(BIND)\excep.* 2>nul
    -rmdir /q /s $(OBJD) 2>nul

realclean: clean
    -rmdir /q /s $(OBJDS) 2>nul

dirs:
    @if not exist $(BIND) mkdir $(BIND) && echo.   Created $(BIND)
    @if not exist $(OBJD) mkdir $(OBJD) && echo.   Created $(OBJD)

$(OBJD)\excep.obj : excep.cpp
$(OBJD)\firstexc.obj : firstexc.cpp

$(BIND)\excep.exe : $(OBJD)\excep.obj $(OBJD)\firstexc.obj $(DEPS)
    cl $(CFLAGS) /Fe$@ /Fd$(@R).pdb $(OBJD)\excep.obj $(OBJD)\firstexc.obj \
        /link $(LINKFLAGS) $(LIBS) /subsystem:console /entry:WinMainCRTStartup

$(OBJD)\excep.bsc : $(OBJD)\excep.obj
    bscmake /v /n /o $@ $(OBJD)\excep.sbr

##############################################################################

test: $(BIND)\excep.exe
    $(BIND)\excep.exe

################################################################# End of File.

```

`samples/excep/excep.cpp`:

```cpp
//////////////////////////////////////////////////////////////////////////////
//
//  First Chance Exception Handling Test Program (excep.cpp of excep.exe)
//
//  Microsoft Research Detours Package
//
//  Copyright (c) Microsoft Corporation.  All rights reserved.
//
//  For more information on exception handling, see "A Crash Course on the
//  Depths of Win32 Structured Exception Handling," by Matt Pietrek in the
//  January 1997 issue of Microsoft Systems Journal.
//
#include <stdio.h>
#include <windows.h>
#include <detours.h>
#include "firstexc.h"

//////////////////////////////////////////////////////////////////////////////
//
static LPVOID   s_pvData = NULL;
static DWORD    s_dwDataPerm = 0;

static LONG ExceptCatch(LONG nTry, DWORD dwException, LPEXCEPTION_POINTERS pinfo)
{
    printf("      ExceptCatch(%ld, %08lx, %08lx)\n", nTry, dwException, (ULONG)pinfo);
#ifdef INCLUDE_THIS
    if (nTry == 0) {
        return EXCEPTION_CONTINUE_EXECUTION;
    }
#endif
    return EXCEPTION_EXECUTE_HANDLER;
}

static int BadCode(int nTry)
{
    printf("    BadCode(Try:%d)\n", nTry);
    printf("      BadCode -> %ld\n", *(PULONG)s_pvData);
    ((PULONG)s_pvData)[0] = 0;
    printf("      BadCode -> %ld\n", *(PULONG)s_pvData);
    ((PULONG)s_pvData)[-1] = 0;
    printf("      BadCode -> %ld\n", *(PULONG)s_pvData);

    return 0;
}

void safe(int nTry)
{
    __try {
        printf("  try(%d)\n", nTry);
        BadCode(nTry);
        printf("  good(%d)\n", nTry);
    } __except(ExceptCatch(nTry,
                           GetExceptionCode(),
                           GetExceptionInformation())) {
        DWORD dwExcept = GetExceptionCode();

        printf("  handler(%d) : %08lx\n", nTry, dwExcept);
    }
}

void raw(int nTry)
{
    BadCode(nTry);
}

LONG WINAPI MyVirtualFaultFilter(PEXCEPTION_POINTERS pException)
{
    PEXCEPTION_RECORD pExceptRec = pException->ExceptionRecord;

    if (pExceptRec->ExceptionCode == 0xc0000005) {
        printf("--        Memory access exception.\n");
        if (pExceptRec->NumberParameters >= 2 &&
            pExceptRec->ExceptionInformation[1] >= (ULONG)s_pvData &&
            pExceptRec->ExceptionInformation[1] <= (ULONG)s_pvData + sizeof(ULONG)) {

            VirtualProtect(s_pvData, sizeof(ULONG), PAGE_READWRITE, &s_dwDataPerm);
            printf("--        Changed permissions.\n");
            return EXCEPTION_CONTINUE_EXECUTION;
        }
    }
    return EXCEPTION_CONTINUE_SEARCH;
}

int WINAPI WinMain(HINSTANCE hinst, HINSTANCE hprev, LPSTR lpszCmdLine, int nCmdShow)
{
    (void)hinst;
    (void)hprev;
    (void)lpszCmdLine;
    (void)nCmdShow;

    s_pvData = VirtualAlloc(NULL, sizeof(ULONG), MEM_RESERVE|MEM_COMMIT, PAGE_READWRITE);
    if (s_pvData == NULL) {
        printf("VirtualAlloc failed: %ld\n", GetLastError());
        return 0;
    }
    *(PULONG)s_pvData = 1;

    VirtualProtect(s_pvData, sizeof(ULONG), PAGE_READONLY, &s_dwDataPerm);

    DetourFirstChanceExceptionFilter(MyVirtualFaultFilter);

    printf("main\n");
    printf("--------------------------------------------------\n");
    int nTry = 0;
    for (; nTry < 1; nTry++) {
        // safe(nTry);
    }
    printf("-- safe ------------------------------------------\n");
    safe(nTry);
    VirtualProtect(s_pvData, sizeof(ULONG), PAGE_READWRITE, &s_dwDataPerm);
    *(PULONG)s_pvData = 1;
    VirtualProtect(s_pvData, sizeof(ULONG), PAGE_READONLY, &s_dwDataPerm);

    printf("-- raw -------------------------------------------\n");
    printf("*\n");
    printf("* NB: The second attempt to write will fail because it isn't handled.\n");
    printf("*\n");
    raw(nTry);
    printf("--------------------------------------------------\n");
    printf("exit\n");

    return 0;
}
//
///////////////////////////////////////////////////////////////// End of File.

```

`samples/excep/firstexc.cpp`:

```cpp
//////////////////////////////////////////////////////////////////////////////
//
//  Detours Test Program (firstexc.cpp of firstexc.lib)
//
//  Microsoft Research Detours Package
//
//  Copyright (c) Microsoft Corporation.  All rights reserved.
//
//  For more information on exception handling, see "A Crash Course on the
//  Depths of Win32 Structured Exception Handling," by Matt Pietrek in the
//  January 1997 issue of Microsoft Systems Journal.
//
#include <stdio.h>
#include <windows.h>
#include "detours.h"
#include "firstexc.h"

#if _MSC_VER > 1000
#pragma warning(disable: 4740)
#endif

//////////////////////////////////////////////////////////////////////////////
//
static BOOL                         s_bExceptionDetourInstalled = FALSE;
static LPTOP_LEVEL_EXCEPTION_FILTER s_pFirstChanceFilter = NULL;

ULONG (NTAPI *Real_NtContinue)(IN PCONTEXT ContextRecord,
                             IN BOOLEAN TestAlerts) = NULL;

VOID (NTAPI *Real_KiUserExceptionDispatcher)(IN PEXCEPTION_RECORD ExceptionRecord,
                                        IN PCONTEXT ContextFrame) = NULL;

//////////////////////////////////////////////////////////////////////////////
//
//  This function effectively removes all try..catch frames for the current
//  stack.  It forces all exceptions to be treated as unhandled exceptions.
//
#pragma warning(push)
#pragma warning(disable: 4733)
static VOID WINAPI RemoveAllExceptionHandlers(VOID)
{
    // The basic, OS defined exception frame
    struct EXCEPTION_REGISTRATION
    {
        EXCEPTION_REGISTRATION* prev;
        FARPROC handler;
    };

    EXCEPTION_REGISTRATION * pVCExcRec = NULL;
    EXCEPTION_REGISTRATION * pLastGood = NULL;

    __asm mov eax, FS:[0];
    __asm mov [pVCExcRec], eax;

    for (pLastGood = pVCExcRec; (ULONG)pVCExcRec != ~0ul; ) {
        if ((ULONG)pVCExcRec >= 0x30000000)
            break;

        pLastGood = pVCExcRec;
        pVCExcRec = (EXCEPTION_REGISTRATION *)(pVCExcRec->prev);
    }

    __asm mov eax, [pLastGood];
    __asm mov FS:[0], eax;
}
#pragma warning(pop)

//////////////////////////////////////////////////////////////////////////////
// Routine Description:
//
//    This routine is entered on return from kernel mode to dispatch a user
//    mode exception. If a frame based handler handles the exception, then
//    the execution is continued. Else last chance processing is performed.
//
//    NOTE:  This procedure is not called, but rather dispatched to.
//           It depends on there not being a return address on the stack
//           (assumption w.r.t. argument offsets.)
//
// Arguments:
//    ExceptionRecord (esp+0) - Supplies a pointer to an exception record.
//    ContextRecord (esp+4) - Supplies a pointer to a context frame.
//
// Return Value:
//    None.
//
static VOID __declspec(naked) NTAPI
Detour_KiUserExceptionDispatcher(PEXCEPTION_RECORD pExceptRec,
                                 CONTEXT *pContext)
{
    __asm {
        xor     eax, eax                ; // Create fake return address on stack.
        push    eax                     ; // (Generally, we are called by the kernel.)

        push    ebp                     ; // Prolog
        mov     ebp, esp                ;
        sub     esp, __LOCAL_SIZE       ;
    }

    LPTOP_LEVEL_EXCEPTION_FILTER pFirstChanceFilter;
    EXCEPTION_POINTERS ep;
    DWORD dwReturn;
    DWORD dwError;

    ep.ExceptionRecord = pExceptRec;
    ep.ContextRecord = pContext;
    pFirstChanceFilter = s_pFirstChanceFilter;
    dwReturn = EXCEPTION_CONTINUE_SEARCH;
    dwError = 0;

    if (s_pFirstChanceFilter) {
        dwReturn = pFirstChanceFilter(&ep);
    }

    if (dwReturn == EXCEPTION_CONTINUE_EXECUTION) {
        dwError = Real_NtContinue(pContext, 0);
        // This call should *NEVER* return.  If it does, we want to fail to the debugger.
        RemoveAllExceptionHandlers();
    }

    if (dwReturn == EXCEPTION_EXECUTE_HANDLER) {        // Special: Call debugger.
        RemoveAllExceptionHandlers();
    }

    __asm {
        mov     ebx, pExceptRec         ;
        mov     ecx, pContext           ;
        push    ecx                     ;
        push    ebx                     ;
        mov     eax, [Real_KiUserExceptionDispatcher];
        jmp     eax                     ;
        ;
        ; The above code should never return.
        ;
        int     3                       ; // Break!
        ;
        mov     esp, ebp                ; // Epilog
        pop     ebp                     ;
        ret                             ;
    }
}

//////////////////////////////////////////////////////////////////////////////
//
//  Set the first-chance exception filter.
//
//  Returns the pointer to the last first-chance exception filter if there
//  was one.  If this is the first first-chance exception filter, installs
//  the necessary detour and acquires the appropriate function pointers.
//  If the parameter is NULL, first-chance exception filtering is disabled.
//
//  A first-chance exception filter should always return one of three
//  possible codes:
//
//    EXCEPTION_CONTINUE_SEARCH:
//        The exception was not handled by this filter; continue the
//        search for the appropriate exception handler.
//
//    EXCEPTION_CONTINUE_EXECUTION:
//        The exception was handled by this filter; continue execution
//        at the point were the exception was thrown.
//
//    EXCEPTION_EXECUTE_HANDLER:
//        Drastic failure in the exception filter.  Process the
//        exception as if no exception handlers were installed.
//        (i.e. Give the user a chance to invoke the debugger.)
//
LPTOP_LEVEL_EXCEPTION_FILTER WINAPI
DetourFirstChanceExceptionFilter(LPTOP_LEVEL_EXCEPTION_FILTER pNewFirstChanceFilter)
{
    if (!s_bExceptionDetourInstalled) {
        s_bExceptionDetourInstalled = TRUE;

        Real_NtContinue = (ULONG (NTAPI *)(IN PCONTEXT, IN BOOLEAN))
            DetourFindFunction("ntdll.dll", "NtContinue");
        Real_KiUserExceptionDispatcher =
            (VOID (NTAPI *)(IN PEXCEPTION_RECORD, IN PCONTEXT))
            DetourFindFunction("ntdll.dll", "KiUserExceptionDispatcher");

        DetourTransactionBegin();
        DetourUpdateThread(GetCurrentThread());
        DetourAttach(&(PVOID&)Real_KiUserExceptionDispatcher,
                       Detour_KiUserExceptionDispatcher);
        DetourTransactionCommit();
    }

    LPTOP_LEVEL_EXCEPTION_FILTER pOldFirstChanceFilter = s_pFirstChanceFilter;
    s_pFirstChanceFilter = pNewFirstChanceFilter;
    return pOldFirstChanceFilter;
}
//
///////////////////////////////////////////////////////////////// End of File.

```

`samples/excep/firstexc.h`:

```h
//////////////////////////////////////////////////////////////////////////////
//
//  Detours Test Program (firstexc.h of firstexc.exe)
//
//  Microsoft Research Detours Package
//
//  Copyright (c) Microsoft Corporation.  All rights reserved.
//

#pragma once
#ifndef _FIRSTEXC_H_
#define _FIRSTEXC_H_

/////////////////////////////////////////////// First Chance Exception Filter.
//
LPTOP_LEVEL_EXCEPTION_FILTER WINAPI
DetourFirstChanceExceptionFilter(LPTOP_LEVEL_EXCEPTION_FILTER lpTopLevelFilter);

#endif // _FIRSTEXC_H_
//
////////////////////////////////////////////////////////////////  End of File.

```

`samples/findfunc/Makefile`:

```
##############################################################################
##
##  Program to test DetourFindFunction.
##
##  Microsoft Research Detours Package
##
##  Copyright (c) Microsoft Corporation.  All rights reserved.
##

!include ..\common.mak

# ARM64 does not like base addresses below 4GB.
# Append two extra zeros for it.
#
!if "$(DETOURS_TARGET_PROCESSOR)" == "ARM64"
TARGET_BASE=0x190000000
EXTEND_BASE=0x1a0000000
!else
TARGET_BASE=0x1900000
EXTEND_BASE=0x1a00000
!endif

LIBS=$(LIBS) kernel32.lib

##############################################################################

all: dirs \
    $(BIND)\target$(DETOURS_BITS).dll \
    $(BIND)\extend$(DETOURS_BITS).dll \
    $(BIND)\findfunc.exe \
    $(BIND)\symtest.exe \
    $(BIND)\dbghelp.dll \
    \
!IF $(DETOURS_SOURCE_BROWSING)==1
    $(OBJD)\target$(DETOURS_BITS).bsc \
    $(OBJD)\extend$(DETOURS_BITS).bsc \
    $(OBJD)\findfunc.bsc \
    $(OBJD)\symtest.bsc \
!ENDIF
    option

##############################################################################

dirs:
    @if not exist $(BIND) mkdir $(BIND) && echo.   Created $(BIND)
    @if not exist $(OBJD) mkdir $(OBJD) && echo.   Created $(OBJD)

$(OBJD)\target.obj : target.cpp

$(OBJD)\target.res : target.rc

$(BIND)\target$(DETOURS_BITS).dll $(BIND)\target$(DETOURS_BITS).lib: \
        $(OBJD)\target.obj $(OBJD)\target.res $(DEPS)
    cl /LD $(CFLAGS) /Fe$(@R).dll /Fd$(@R).pdb \
        $(OBJD)\target.obj $(OBJD)\target.res \
        /link $(LINKFLAGS) /subsystem:console \
        /export:Target \
        /base:$(TARGET_BASE) \
        $(LIBS)

$(OBJD)\target$(DETOURS_BITS).bsc : $(OBJD)\target.obj
    bscmake /v /n /o $@ $(OBJD)\target.sbr

$(OBJD)\extend.obj : extend.cpp

$(OBJD)\extend.res : extend.rc

$(BIND)\extend$(DETOURS_BITS).dll $(BIND)\extend$(DETOURS_BITS).lib: \
        $(OBJD)\extend.obj $(OBJD)\extend.res $(DEPS)
    cl /LD $(CFLAGS) /Fe$(@R).dll /Fd$(@R).pdb \
        $(OBJD)\extend.obj $(OBJD)\extend.res \
        /link $(LINKFLAGS) /subsystem:console \
        /export:DetourFinishHelperProcess,@1,NONAME \
        /base:$(EXTEND_BASE) \
        $(LIBS)

$(OBJD)\extend$(DETOURS_BITS).bsc : $(OBJD)\extend.obj
    bscmake /v /n /o $@ $(OBJD)\extend.sbr

$(OBJD)\findfunc.obj : findfunc.cpp

$(BIND)\findfunc.exe : $(OBJD)\findfunc.obj $(BIND)\target$(DETOURS_BITS).lib $(DEPS)
    cl $(CFLAGS) /Fe$@ /Fd$(@R).pdb $(OBJD)\findfunc.obj \
        /link $(LINKFLAGS) $(LIBS) \
        /subsystem:console /fixed:no $(BIND)\target$(DETOURS_BITS).lib

$(OBJD)\findfunc.bsc : $(OBJD)\findfunc.obj
    bscmake /v /n /o $@ $(OBJD)\findfunc.sbr

$(OBJD)\symtest.obj : symtest.cpp

$(BIND)\symtest.exe : $(OBJD)\symtest.obj $(BIND)\target$(DETOURS_BITS).lib $(DEPS)
    cl $(CFLAGS) /Fe$@ /Fd$(@R).pdb $(OBJD)\symtest.obj \
        /link $(LINKFLAGS) $(LIBS) \
        /subsystem:console /fixed:no $(BIND)\target$(DETOURS_BITS).lib

$(OBJD)\symtest.bsc : $(OBJD)\symtest.obj
    bscmake /v /n /o $@ $(OBJD)\symtest.sbr

# We try to get the 64-bit dbghelp first because it is a lot more useful.
$(BIND)\dbghelp.dll : {"$(PROGRAMFILES)\Debugging Tools for Windows 64-bit";$(PATH)}dbghelp.dll
    -copy $** $(BIND)\dbghelp.dll 

##############################################################################

clean:
    -del *~ 2>nul
    -del $(BIND)\target*.* $(BIND)\extend*.* 2>nul
    -del $(BIND)\findfunc.* $(BIND)\symtest.* $(BIND)\dbghelp.dll 2>nul
    -rmdir /q /s $(OBJD) 2>nul

realclean: clean
    -rmdir /q /s $(OBJDS) 2>nul

############################################### Install non-bit-size binaries.

!IF "$(DETOURS_OPTION_PROCESSOR)" != ""

$(OPTD)\extend$(DETOURS_OPTION_BITS).dll:
$(OPTD)\extend$(DETOURS_OPTION_BITS).pdb:
$(OPTD)\target$(DETOURS_OPTION_BITS).dll:
$(OPTD)\target$(DETOURS_OPTION_BITS).pdb:

$(BIND)\extend$(DETOURS_OPTION_BITS).dll : $(OPTD)\extend$(DETOURS_OPTION_BITS).dll
    @if exist $? copy /y $? $(BIND) >nul && echo $@ copied from $(DETOURS_OPTION_PROCESSOR).
$(BIND)\extend$(DETOURS_OPTION_BITS).pdb : $(OPTD)\extend$(DETOURS_OPTION_BITS).pdb
    @if exist $? copy /y $? $(BIND) >nul && echo $@ copied from $(DETOURS_OPTION_PROCESSOR).
$(BIND)\target$(DETOURS_OPTION_BITS).dll : $(OPTD)\target$(DETOURS_OPTION_BITS).dll
    @if exist $? copy /y $? $(BIND) >nul && echo $@ copied from $(DETOURS_OPTION_PROCESSOR).
$(BIND)\target$(DETOURS_OPTION_BITS).pdb : $(OPTD)\target$(DETOURS_OPTION_BITS).pdb
    @if exist $? copy /y $? $(BIND) >nul && echo $@ copied from $(DETOURS_OPTION_PROCESSOR).

option: \
    $(BIND)\extend$(DETOURS_OPTION_BITS).dll \
    $(BIND)\extend$(DETOURS_OPTION_BITS).pdb \
    $(BIND)\target$(DETOURS_OPTION_BITS).dll \
    $(BIND)\target$(DETOURS_OPTION_BITS).pdb \

!ELSE

option:

!ENDIF

##############################################################################

verbose: all
    cls
    $(BIND)\symtest.exe

test: all
    @echo -------- Reseting test binaries to initial state. -----------------------
    $(BIND)\setdll.exe -r $(BIND)\findfunc.exe
    @echo.
    @echo -------- Should not load extend$(DETOURS_BITS).dll--------------------------------------
    $(BIND)\findfunc.exe
    @echo.
    @echo -------- Adding extend$(DETOURS_BITS).dll to findfunc.exe ------------------------------
    $(BIND)\setdll.exe -d:$(BIND)\extend$(DETOURS_BITS).dll $(BIND)\findfunc.exe
    @echo.
    @echo -------- Should load extend$(DETOURS_BITS).dll statically ------------------------------
    $(BIND)\findfunc.exe
    @echo.
    @echo -------- Removing extend$(DETOURS_BITS).dll from findfunc.exe --------------------------
    $(BIND)\setdll.exe -r $(BIND)\findfunc.exe
    @echo.
    @echo -------- Should not load extend$(DETOURS_BITS).dll -------------------------------------
    $(BIND)\findfunc.exe
    @echo.
    @echo -------- Should load extend$(DETOURS_BITS).dll dynamically using withdll.exe -----------
    $(BIND)\withdll.exe -d:$(BIND)\extend$(DETOURS_BITS).dll $(BIND)\findfunc.exe
    @echo.
    @echo -------- Should list symbols using symtest.exe -----------
    $(BIND)\symtest.exe
    @echo.
    @echo -------- Test completed. ------------------------------------------------

################################################################# End of File.

```

`samples/findfunc/extend.cpp`:

```cpp
//////////////////////////////////////////////////////////////////////////////
//
//  Detour Test Program (extend.cpp of extend.dll)
//
//  Microsoft Research Detours Package
//
//  Copyright (c) Microsoft Corporation.  All rights reserved.
//
//  An example dynamically detouring a function.
//
#include <stdio.h>
#include <windows.h>
#include "detours.h"

static LONG nExtends = 0;
static LONG nInterns = 0;

static DWORD (WINAPI * TrueTarget)(DWORD dwCount) = NULL;
static DWORD (WINAPI * TrueHidden)(DWORD dwCount) = NULL;
static int (WINAPI * TrueEntryPoint)(VOID) = NULL;

// Extend is a detour for Target.
static DWORD WINAPI Extend(DWORD dwCount)
{
    InterlockedIncrement(&nExtends);

    printf("extend" DETOURS_STRINGIFY(DETOURS_BITS) ".dll: Extend    (%ld) -> %ld.\n", dwCount, dwCount + 1000);
    dwCount = TrueTarget(dwCount + 1000);
    printf("extend" DETOURS_STRINGIFY(DETOURS_BITS) ".dll: Extend    (.....) -> %ld.\n", dwCount);
    return dwCount;
}

// Intern is a detour for Hidden.
static DWORD WINAPI Intern(DWORD dwCount)
{
    InterlockedIncrement(&nInterns);

    printf("extend" DETOURS_STRINGIFY(DETOURS_BITS) ".dll:    Intern (%ld) -> %ld.\n", dwCount, dwCount + 10);
    dwCount = TrueHidden(dwCount + 10);
    printf("extend" DETOURS_STRINGIFY(DETOURS_BITS) ".dll:    Intern (.....) -> %ld.\n", dwCount);
    return dwCount;
}

static int WINAPI ExtendEntryPoint()
{
    // We couldn't call LoadLibrary in DllMain, so our functions here.
    LONG error;

    // We separate out the functions in the export table (Target)
    // from the ones that require debug symbols (Hidden).
    TrueTarget =
        (DWORD (WINAPI *)(DWORD))
        DetourFindFunction("target" DETOURS_STRINGIFY(DETOURS_BITS) ".dll", "Target");
    DetourTransactionBegin();
    DetourUpdateThread(GetCurrentThread());
    DetourAttach(&(PVOID&)TrueTarget, Extend);
    error = DetourTransactionCommit();

    if (error == NO_ERROR) {
        printf("extend" DETOURS_STRINGIFY(DETOURS_BITS) ".dll: Detoured Target().\n");
    }
    else {
        printf("extend" DETOURS_STRINGIFY(DETOURS_BITS) ".dll: Error detouring Target(): %ld\n", error);
    }

    // Now try to detour the functions requiring debug symbols.
    TrueHidden =
        (DWORD (WINAPI *)(DWORD))
        DetourFindFunction("target" DETOURS_STRINGIFY(DETOURS_BITS) ".dll", "Hidden");
    if (TrueHidden == NULL) {
        error = GetLastError();
        printf("extend" DETOURS_STRINGIFY(DETOURS_BITS) ".dll: TrueHidden = %p (error = %ld)\n", TrueHidden, error);
    }

    DetourTransactionBegin();
    DetourUpdateThread(GetCurrentThread());
    DetourAttach(&(PVOID&)TrueHidden, Intern);
    error = DetourTransactionCommit();

    if (error == NO_ERROR) {
        printf("extend" DETOURS_STRINGIFY(DETOURS_BITS) ".dll: Detoured Hidden().\n");
    }
    else {
        printf("extend" DETOURS_STRINGIFY(DETOURS_BITS) ".dll: Error detouring Hidden(): %ld\n", error);
    }

    // Now let the application start executing.
    printf("extend" DETOURS_STRINGIFY(DETOURS_BITS) ".dll: Calling EntryPoint\n");
    fflush(stdout);

    return TrueEntryPoint();
}

BOOL WINAPI DllMain(HINSTANCE hinst, DWORD dwReason, LPVOID reserved)
{
    LONG error;
    (void)hinst;
    (void)reserved;

    if (DetourIsHelperProcess()) {
        return TRUE;
    }

    if (dwReason == DLL_PROCESS_ATTACH) {
        DetourRestoreAfterWith();

        printf("extend" DETOURS_STRINGIFY(DETOURS_BITS) ".dll: Starting.\n");
        fflush(stdout);

        // NB: DllMain can't call LoadLibrary, so we hook the app entry point.

        TrueEntryPoint = (int (WINAPI *)())DetourGetEntryPoint(NULL);

        DetourTransactionBegin();
        DetourUpdateThread(GetCurrentThread());
        DetourAttach(&(PVOID&)TrueEntryPoint, ExtendEntryPoint);
        error = DetourTransactionCommit();

        if (error == NO_ERROR) {
            printf("extend" DETOURS_STRINGIFY(DETOURS_BITS) ".dll: Detoured EntryPoint().\n");
        }
        else {
            printf("extend" DETOURS_STRINGIFY(DETOURS_BITS) ".dll: Error detouring EntryPoint(): %ld\n", error);
        }
    }
    else if (dwReason == DLL_PROCESS_DETACH) {
        DetourTransactionBegin();
        DetourUpdateThread(GetCurrentThread());

        // Detach functions found from the export table.
        if (TrueTarget != NULL) {
            DetourDetach(&(PVOID&)TrueTarget, (PVOID)Extend);
        }

        // Detach functions found from debug symbols.
        if (TrueHidden != NULL) {
            DetourDetach(&(PVOID&)TrueHidden, (PVOID)Intern);
        }

        // Detach the entry point.
        DetourDetach(&(PVOID&)TrueEntryPoint, ExtendEntryPoint);
        error = DetourTransactionCommit();

        printf("extend" DETOURS_STRINGIFY(DETOURS_BITS) ".dll: Removed Target() detours (%ld), %ld/%ld calls.\n",
               error, nExtends, nInterns);

        fflush(stdout);
    }
    return TRUE;
}
//
///////////////////////////////////////////////////////////////// End of File.

```

`samples/findfunc/extend.rc`:

```rc
//////////////////////////////////////////////////////////////////////////////
//
//  Version information for extend.rc.
//
//  Microsoft Research Detours Package
//
//  Copyright (c) Microsoft Corporation.  All rights reserved.
//

#include "detver.h"

#define VER_INTERNALNAME_STR        "extend" DETOURS_STRINGIFY(DETOURS_BITS)
#define VER_ORIGINALFILENAME_STR    "extend" DETOURS_STRINGIFY(DETOURS_BITS) ".dll"
#define VER_FILEDESCRIPTION_STR     "Detours Dyanmic Interception Test Module"
#define VER_COMPANYNAME_STR         "Microsoft Corporation"

#include "common.ver"

```

`samples/findfunc/findfunc.cpp`:

```cpp
//////////////////////////////////////////////////////////////////////////////
//
//  Detour Test Program (findfunc.cpp of findfunc.exe)
//
//  Microsoft Research Detours Package
//
//  Copyright (c) Microsoft Corporation.  All rights reserved.
//

#include <windows.h>
#include <stdio.h>
#include <detours.h>
#include "target.h"

int __cdecl main(void)
{
    printf("findfunc.exe: Starting.\n");
    fflush(stdout);

    printf("DLLs:\n");
    for (HMODULE hModule = NULL; (hModule = DetourEnumerateModules(hModule)) != NULL;) {
        CHAR szName[MAX_PATH] = { 0 };
        GetModuleFileNameA(hModule, szName, sizeof(szName) - 1);
        printf("  %p: %s\n", hModule, szName);
    }

    DWORD dwCount = 10000;
    for (int i = 0; i < 3; i++) {
        printf("findfunc.exe: Calling (%ld).\n", dwCount);
        dwCount = Target(dwCount) + 10000;
    }
    return 0;
}
//
///////////////////////////////////////////////////////////////// End of File.

```

`samples/findfunc/symtest.cpp`:

```cpp
//////////////////////////////////////////////////////////////////////////////
//
//  Detour Test Program (symtest.cpp of symtest.exe)
//
//  Microsoft Research Detours Package
//
//  Copyright (c) Microsoft Corporation.  All rights reserved.
//

#include <windows.h>
#include <stdio.h>
#pragma warning(push)
#if _MSC_VER > 1400
#pragma warning(disable:6102 6103) // /analyze warnings
#endif
#include <strsafe.h>
#pragma warning(pop)
#include <detours.h>
#include "target.h"

#if (_MSC_VER < 1299)
#include <imagehlp.h>
typedef IMAGEHLP_MODULE IMAGEHLP_MODULE64;
typedef PIMAGEHLP_MODULE PIMAGEHLP_MODULE64;
typedef IMAGEHLP_SYMBOL SYMBOL_INFO;
typedef PIMAGEHLP_SYMBOL PSYMBOL_INFO;
#else
#pragma warning(push)
#pragma warning(disable:4091) // empty typedef
#include <dbghelp.h>
#pragma warning(pop)
#endif

//////////////////////////////////////////////////////////////////////////////
//
typedef LPAPI_VERSION (NTAPI *PF_ImagehlpApiVersionEx)(LPAPI_VERSION AppVersion);

typedef BOOL (NTAPI *PF_SymInitialize)(IN HANDLE hProcess,
                                       IN LPCSTR UserSearchPath,
                                       IN BOOL fInvadeProcess);
typedef DWORD (NTAPI *PF_SymSetOptions)(IN DWORD SymOptions);
typedef DWORD (NTAPI *PF_SymGetOptions)(VOID);
typedef DWORD64 (NTAPI *PF_SymLoadModule64)(IN HANDLE hProcess,
                                            IN HANDLE hFile,
                                            IN PSTR ImageName,
                                            IN PSTR ModuleName,
                                            IN DWORD64 BaseOfDll,
                                            IN DWORD SizeOfDll);
typedef BOOL (NTAPI *PF_SymGetModuleInfo64)(IN HANDLE hProcess,
                                            IN DWORD64 qwAddr,
                                            OUT PIMAGEHLP_MODULE64 ModuleInfo);
typedef BOOL (NTAPI *PF_SymFromName)(IN HANDLE hProcess,
                                     IN LPSTR Name,
                                     OUT PSYMBOL_INFO Symbol);
#if (_MSC_VER < 1299)
typedef BOOL (NTAPI *PF_SymRegisterCallback64)();
typedef BOOL (NTAPI *PF_SymEnumerateModules64)();
typedef BOOL (NTAPI *PF_SymEnumSymbols)();
#else
typedef BOOL (NTAPI *PF_SymRegisterCallback64)(IN HANDLE hProcess,
                                               IN PSYMBOL_REGISTERED_CALLBACK64
                                               CallbackFunction,
                                               IN ULONG64 UserContext);
typedef BOOL (NTAPI *PF_SymEnumerateModules64)(IN HANDLE hProcess,
                                               IN PSYM_ENUMMODULES_CALLBACK64
                                               EnumModulesCallback,
                                               IN PVOID UserContext);
typedef BOOL (NTAPI *PF_SymEnumSymbols)(IN HANDLE hProcess,
                                        IN ULONG64 BaseOfDll,
                                        IN PCSTR Mask,
                                        IN PSYM_ENUMERATESYMBOLS_CALLBACK
                                        EnumSymbolsCallback,
                                        IN PVOID UserContext);
#endif

PF_ImagehlpApiVersionEx     pfImagehlpApiVersionEx = NULL;
PF_SymInitialize            pfSymInitialize = NULL;
PF_SymSetOptions            pfSymSetOptions = NULL;
PF_SymGetOptions            pfSymGetOptions = NULL;
PF_SymLoadModule64          pfSymLoadModule64 = NULL;
PF_SymGetModuleInfo64       pfSymGetModuleInfo64 = NULL;
PF_SymFromName              pfSymFromName = NULL;
PF_SymRegisterCallback64    pfSymRegisterCallback64 = NULL;
PF_SymEnumerateModules64    pfSymEnumerateModules64 = NULL;
PF_SymEnumSymbols           pfSymEnumSymbols = NULL;

//////////////////////////////////////////////////////////////////////////////
//

#if (_MSC_VER > 1299)
static BOOL WINAPI SymEnumerateCallback(
                                        PCSTR pszModule,
                                        DWORD64 base,
                                        PVOID pvUserContext)
{
    (void)pvUserContext;
    printf("  %p: %s\n", (PVOID)base, pszModule);
    return TRUE;
}

static int nSymbolCount = 0;
static BOOL WINAPI SymEnumerateSymbols(PSYMBOL_INFO pSym,
                                       ULONG size,
                                       PVOID pvUserContext)
{
    (void)size;
    (void)pvUserContext;
    if (strstr(pSym->Name, "Target") != NULL ||
        strstr(pSym->Name, "Hidden") != NULL) {
        printf("  %p: %s\n", (PVOID)pSym->Address, pSym->Name);
        nSymbolCount++;
    }
    else if (nSymbolCount < 5) {
        printf("  %p: %s\n", (PVOID)pSym->Address, pSym->Name);
        nSymbolCount++;
    }
    return TRUE;
}

static void truncate(PCHAR data)
{
    size_t len = strlen(data);
    if (len > 0 && data[len-1] == '\r') {
        data[--len] = '\0';
    }
    if (len > 0 && data[len-1] == '\n') {
        data[--len] = '\0';
    }
}

BOOL WINAPI CallbackFunction(HANDLE hProcess, ULONG action, ULONG64 data, ULONG64 context)
{
    (void)context;

    switch (action) {
      case CBA_DEBUG_INFO:
        truncate((PCHAR)data);
        printf("::> %s\n", (PCHAR)data);
        return TRUE;

      case CBA_DEFERRED_SYMBOL_LOAD_CANCEL:
        printf("::> proc=%p action=%08lx data=%p\n",
                      (PVOID)hProcess,
                      action,
                      (PVOID)data);
        {
            PIMAGEHLP_DEFERRED_SYMBOL_LOAD64 pi = (PIMAGEHLP_DEFERRED_SYMBOL_LOAD64)data;
            printf("pi->SizeOfStruct = %ld\n", pi->SizeOfStruct);
            printf("pi->BaseOfImage  = %p\n", (PVOID)(size_t)pi->BaseOfImage);
            printf("pi->CheckSum     = %8lx\n", pi->CheckSum);
            printf("pi->FileName     = %p [%s]\n", pi->FileName, pi->FileName);
            printf("pi->Reparse      = %d\n", pi->Reparse);
        }
        return FALSE;
      default:
        printf("::> proc=%p action=%08lx data=%p\n",
                      (PVOID)hProcess,
                      action,
                      (PVOID)data);
        return FALSE;
    }
}
#endif

int __cdecl main(void)
{
    printf("symtest.exe: Starting.\n");
    fflush(stdout);

    //////////////////////////////////////////////////////// Get the functions.
    //
    HMODULE hDbgHelp = LoadLibraryA("dbghelp.dll");
    if (hDbgHelp == NULL) {
        printf("Couldn't load dbghelp.dll");
        return 1;
    }

    pfImagehlpApiVersionEx
        = (PF_ImagehlpApiVersionEx)GetProcAddress(hDbgHelp,
                                                  "ImagehlpApiVersionEx");
    pfSymInitialize
        = (PF_SymInitialize)GetProcAddress(hDbgHelp, "SymInitialize");
    pfSymSetOptions
        = (PF_SymSetOptions)GetProcAddress(hDbgHelp, "SymSetOptions");
    pfSymGetOptions
        = (PF_SymGetOptions)GetProcAddress(hDbgHelp, "SymGetOptions");
    pfSymLoadModule64
        = (PF_SymLoadModule64)GetProcAddress(hDbgHelp, "SymLoadModule64");
    pfSymGetModuleInfo64
        = (PF_SymGetModuleInfo64)GetProcAddress(hDbgHelp, "SymGetModuleInfo64");
    pfSymFromName
        = (PF_SymFromName)GetProcAddress(hDbgHelp, "SymFromName");
    pfSymRegisterCallback64
        = (PF_SymRegisterCallback64)GetProcAddress(hDbgHelp, "SymRegisterCallback64");
    pfSymEnumerateModules64
        = (PF_SymEnumerateModules64)GetProcAddress(hDbgHelp, "SymEnumerateModules64");
    pfSymEnumSymbols
        = (PF_SymEnumSymbols)GetProcAddress(hDbgHelp, "SymEnumSymbols");

    //////////////////////////////////////////////////////////////////////////////
    //
    HANDLE hProcess = GetCurrentProcess();

    API_VERSION av;
    ZeroMemory(&av, sizeof(av));
    av.MajorVersion = API_VERSION_NUMBER;

    pfImagehlpApiVersionEx(&av);
    printf("  Version: %d.%d (%d)\n",
                  av.MajorVersion,
                  av.MinorVersion,
                  API_VERSION_NUMBER);

    if (!pfSymInitialize(hProcess, NULL, FALSE)) {
        printf("SymInitialize failed: %ld\n", GetLastError());
        return 1;
    }

#if (_MSC_VER > 1299)
    pfSymRegisterCallback64(hProcess, CallbackFunction, NULL);
#endif

    DWORD dw = pfSymGetOptions();
    printf("GetOptions = %08lx\n", dw);
    dw &= ~(SYMOPT_CASE_INSENSITIVE |
            SYMOPT_UNDNAME |
            SYMOPT_DEFERRED_LOADS |
            0);
    dw |= (
#if defined(SYMOPT_EXACT_SYMBOLS)
           SYMOPT_EXACT_SYMBOLS |
#endif
#if defined(SYMOPT_DEBUG)
           SYMOPT_DEBUG |
#endif
#if defined(SYMOPT_NO_UNQUALIFIED_LOADS)
           SYMOPT_NO_UNQUALIFIED_LOADS |
#endif
#if defined(SYMOPT_FAIL_CRITICAL_ERRORS)
           SYMOPT_FAIL_CRITICAL_ERRORS |
#endif
#if defined(SYMOPT_INCLUDE_32BIT_MODULES)
           SYMOPT_INCLUDE_32BIT_MODULES |
#endif
           0);
    printf("SetOptions = %08lx\n", dw);
    pfSymSetOptions(dw);

    /////////////////////////////////////////////// First, try GetProcAddress.
    //
    PCHAR pszFile = "target" DETOURS_STRINGIFY(DETOURS_BITS) ".dll";
    HMODULE hModule = LoadLibraryA(pszFile);
    if (hModule == NULL) {
        printf("LoadLibraryA(%s) failed: %ld\n", pszFile, GetLastError());
        return 2;
    }

    ////////////////////////////////////////////////////// Then try ImageHelp.
    //
#if (_MSC_VER > 1299)

    //CHAR szFull[MAX_PATH];
    //GetModuleFileNameA(hModule, szFull, sizeof(szFull));
    printf("SymLoadModule64(%s) will be called.\n", pszFile /*szFull*/);
    DWORD64 loaded = pfSymLoadModule64(hProcess, NULL,
                                       (PCHAR)pszFile/*szFull*/, NULL,
                                       (DWORD64)hModule, 0);
    if (loaded == 0) {
        printf("SymLoadModule64(%p) failed: %ld\n", hProcess, GetLastError());
        printf("\n");
    }
    else {
        printf("SymLoadModule64(%p) succeeded: 0x%p\n", hProcess, (PVOID)loaded);
    }

    CHAR szModName[512];

    printf("Modules:\n");
// The first parameter of PSYM_ENUMMODULES_CALLBACK64 changed from PSTR to PCSTR
// between Windows 2003 and Windows 7. Cast here to work with either.
    pfSymEnumerateModules64(hProcess, (PSYM_ENUMMODULES_CALLBACK64)SymEnumerateCallback, NULL);
    printf("\n");

    IMAGEHLP_MODULE64 modinfo;
    ZeroMemory(&modinfo, sizeof(modinfo));
    modinfo.SizeOfStruct = sizeof(modinfo);
    if (!pfSymGetModuleInfo64(hProcess, (DWORD64)hModule, &modinfo)) {
        printf("SymGetModuleInfo64(%p, %p) [64] failed: %ld\n",
                      hProcess, hModule, GetLastError());
    }
    else {
        printf("SymGetModuleInfo64(%p, %p) [64] succeeded: %ld\n",
                      hProcess, hModule, GetLastError());
        StringCchCopyA(szModName, ARRAYSIZE(szModName), modinfo.ModuleName);
        StringCchCatA(szModName, ARRAYSIZE(szModName), "!");

        printf("NumSyms:         %ld\n", modinfo.NumSyms);
        printf("SymType:         %d\n", modinfo.SymType);
        printf("ModuleName:      %s\n", modinfo.ModuleName);
        printf("ImageName:       %s\n", modinfo.ImageName);
        printf("LoadedImageName: %s\n", modinfo.LoadedImageName);
    }

    printf("\n");
    fflush(stdout);

    printf("DLLs:\n");
    for (hModule = NULL; (hModule = DetourEnumerateModules(hModule)) != NULL;) {
        CHAR szName[MAX_PATH];
        GetModuleFileNameA(hModule, szName, sizeof(szName));
        printf("  %p: %s\n", hModule, szName);
    }

    if (pfSymEnumSymbols == NULL) {
        printf("Couldn't find SymEnumSymbols.\n");
    }
    else {
        printf("===Enum===\n");
        SetLastError(0);
        nSymbolCount = 0;
        if (!pfSymEnumSymbols(hProcess, loaded, NULL, SymEnumerateSymbols, NULL)) {
            printf("SymEnumSymbols() failed: %ld\n",
                          GetLastError());
        }
    }

    // Look for specific symbols.
    struct CFullSymbol : SYMBOL_INFO {
        CHAR szRestOfName[MAX_SYM_NAME];
    } symbol;
    CHAR szFullName[512];

    // Look for Target
    StringCchCopyA(szFullName, ARRAYSIZE(szFullName), szModName);
    StringCchCatA(szFullName, ARRAYSIZE(szFullName), "Target");
    printf("Symbol: [%s]\n", szFullName);

    ZeroMemory(&symbol, sizeof(symbol));
    symbol.SizeOfStruct = sizeof(SYMBOL_INFO);
#ifdef DBHLPAPI
    symbol.MaxNameLen = MAX_SYM_NAME;
#else
    symbol.MaxNameLength = MAX_SYM_NAME;
#endif

    SetLastError(0);
    if (!pfSymFromName(hProcess, szFullName, &symbol)) {
        printf("--SymFromName(%s) failed: %ld\n", szFullName, GetLastError());
    }
    if (symbol.Address != 0) {
        printf("--SymFromName(%s) succeeded\n", szFullName);
    }

    printf("%s => %p\n\n", szFullName, (PBYTE)symbol.Address);

    // Look for Hidden
    StringCchCopyA(szFullName, ARRAYSIZE(szFullName), szModName);
    StringCchCatA(szFullName, ARRAYSIZE(szFullName), "Hidden");
    printf("Symbol: [%s]\n", szFullName);

    ZeroMemory(&symbol, sizeof(symbol));
    symbol.SizeOfStruct = sizeof(SYMBOL_INFO);
#ifdef DBHLPAPI
    symbol.MaxNameLen = MAX_SYM_NAME;
#else
    symbol.MaxNameLength = MAX_SYM_NAME;
#endif

    SetLastError(0);
    if (!pfSymFromName(hProcess, szFullName, &symbol)) {
        printf("--SymFromName(%s) failed: %ld\n", szFullName, GetLastError());
    }
    if (symbol.Address != 0) {
        printf("--SymFromName(%s) succeeded\n", szFullName);
    }

    printf("%s => %p\n\n", szFullName, (PBYTE)symbol.Address);
#endif

    // We call Target once to insure it is loaded.
    Target(0);
    return 0;
}
//
///////////////////////////////////////////////////////////////// End of File.

```

`samples/findfunc/target.cpp`:

```cpp
//////////////////////////////////////////////////////////////////////////////
//
//  Detour Test Program (target.cpp of target.dll)
//
//  Microsoft Research Detours Package
//
//  Copyright (c) Microsoft Corporation.  All rights reserved.
//

#include <stdio.h>
#include <windows.h>
#include "target.h"

extern "C" DWORD WINAPI Hidden(DWORD dwCount)
{
    printf("target.dll:     Hidden(%ld) -> %ld.\n", dwCount, dwCount + 1);
    return dwCount + 1;
}

// We use this point to ensure Hidden isn't inlined.
static DWORD (WINAPI * SelfHidden)(DWORD dwCount) = Hidden;

DWORD WINAPI Target(DWORD dwCount)
{
    printf("target.dll:   Target  (%ld) -> %ld.\n", dwCount, dwCount + 100);
    dwCount = SelfHidden(dwCount + 100);
    printf("target.dll:   Target  (.....) -> %ld.\n", dwCount);
    return dwCount;
}

BOOL WINAPI DllMain(HINSTANCE hinst, DWORD dwReason, LPVOID reserved)
{
    (void)hinst;
    (void)dwReason;
    (void)reserved;

    return TRUE;
}

//
///////////////////////////////////////////////////////////////// End of File.

```

`samples/findfunc/target.h`:

```h
//////////////////////////////////////////////////////////////////////////////
//
//  Detour Test Program (target.h of target.dll)
//
//  Microsoft Research Detours Package
//
//  Copyright (c) Microsoft Corporation.  All rights reserved.
//
#pragma once

DWORD WINAPI Target(DWORD dwCount);

//
///////////////////////////////////////////////////////////////// End of File.

```

`samples/findfunc/target.rc`:

```rc
//////////////////////////////////////////////////////////////////////////////
//
//  Version information for target.rc.
//
//  Microsoft Research Detours Package
//
//  Copyright (c) Microsoft Corporation.  All rights reserved.
//

#include "detver.h"

#define VER_INTERNALNAME_STR        "target" DETOURS_STRINGIFY(DETOURS_BITS)
#define VER_ORIGINALFILENAME_STR    "target" DETOURS_STRINGIFY(DETOURS_BITS) ".dll"
#define VER_FILEDESCRIPTION_STR     "Detours Test Module"
#define VER_COMPANYNAME_STR         "Microsoft Corporation"

#include "common.ver"

```

`samples/impmunge/Makefile`:

```
##############################################################################
##
##  Makefile for Detours Test Programs.
##
##  Microsoft Research Detours Package
##
##  Copyright (c) Microsoft Corporation.  All rights reserved.
##

!include ..\common.mak

LIBS=$(LIBS) kernel32.lib

all: dirs \
    $(BIND)\impmunge.exe    \
!IF $(DETOURS_SOURCE_BROWSING)==1
    $(OBJD)\impmunge.bsc
!ENDIF

##############################################################################

clean:
    -del *~ test.exe.* 2>nul
    -del $(BIND)\impmunge.* 2>nul
    -rmdir /q /s $(OBJD) 2>nul

realclean: clean
    -rmdir /q /s $(OBJDS) 2>nul

##############################################################################

dirs:
    @if not exist $(BIND) mkdir $(BIND) && echo.   Created $(BIND)
    @if not exist $(OBJD) mkdir $(OBJD) && echo.   Created $(OBJD)

$(OBJD)\impmunge.obj : impmunge.cpp

$(BIND)\impmunge.exe : $(OBJD)\impmunge.obj $(DEPS)
    cl $(CFLAGS) /Fe$@ /Fd$(@R).pdb $(OBJD)\impmunge.obj \
        /link $(LINKFLAGS) $(LIBS) imagehlp.lib /subsystem:console

$(OBJD)\impmunge.bsc : $(OBJD)\impmunge.obj
    bscmake /v /n /o $@ $(OBJD)\impmunge.sbr

##############################################################################

test: $(BIND)\impmunge.exe
    $(BIND)\impmunge.exe /m /o:test.exe.1 $(BIND)\impmunge.exe
    $(BIND)\impmunge.exe /m /l- /o:test.exe.2 test.exe.1
    $(BIND)\impmunge.exe /m /l- /o:test.exe.3 test.exe.2
    $(BIND)\impmunge.exe /m /l- /o:test.exe.4 test.exe.3
    $(BIND)\impmunge.exe /l test.exe.4
    $(BIND)\impmunge.exe /r /l- /o:test.exe.0 test.exe.4
    $(BIND)\impmunge.exe /l test.exe.0

################################################################# End of File.

```

`samples/impmunge/impmunge.cpp`:

```cpp
//////////////////////////////////////////////////////////////////////////////
//
//  Detours Test Program (impmunge.cpp of impmunge.exe)
//
//  Microsoft Research Detours Package
//
//  Copyright (c) Microsoft Corporation.  All rights reserved.
//
#include <stdio.h>
#include <stdlib.h>
#include <windows.h>
#pragma warning(push)
#if _MSC_VER > 1400
#pragma warning(disable:6102 6103) // /analyze warnings
#endif
#include <strsafe.h>
#include <detours.h>
#pragma warning(disable:4091) // empty typedef
#include <imagehlp.h>
#pragma warning(pop)

////////////////////////////////////////////////////////////// Error Messages.
//
VOID AssertMessage(PCSTR szMsg, PCSTR szFile, DWORD nLine)
{
    printf("ASSERT(%s) failed in %s, line %ld.", szMsg, szFile, nLine);
}

#define ASSERT(x)   \
do { if (!(x)) { AssertMessage(#x, __FILE__, __LINE__); DebugBreak(); }} while (0)
    ;


//////////////////////////////////////////////////////////////////////////////
//
static BOOLEAN s_fRestore = FALSE;
static BOOLEAN s_fList = TRUE;
static BOOLEAN s_fMunge = FALSE;
static BOOLEAN s_fToSymbols = FALSE;

//////////////////////////////////////////////////////////////////////////////
//
static BOOL CALLBACK ListByway(_In_opt_ PVOID pContext,
                               _In_opt_ LPCSTR pszFile,
                               _Outptr_result_maybenull_ LPCSTR *ppszOutFile)
{
    (void)pContext;
    (void)ppszOutFile;

    printf("  byway   -------------------------------- %s\n", pszFile ? pszFile : "");
    return TRUE;
}

static BOOL CALLBACK ListFile(_In_opt_ PVOID pContext,
                              _In_ LPCSTR pszOrigFile,
                              _In_ LPCSTR pszFile,
                              _Outptr_result_maybenull_ LPCSTR *ppszOutFile)
{
    (void)pContext;
    (void)ppszOutFile;

    printf("  file    %-32.32s %-32.32s\n",
           pszOrigFile ? pszOrigFile : "",
           pszFile ? pszFile : "");
    return TRUE;
}

static BOOL CALLBACK ListSymbol(_In_opt_ PVOID pContext,
                                _In_ ULONG nOrigOrdinal,
                                _In_ ULONG nOrdinal,
                                _Out_ ULONG *pnOutOrdinal,
                                _In_opt_ LPCSTR pszOrigSymbol,
                                _In_opt_ LPCSTR pszSymbol,
                                _Outptr_result_maybenull_ LPCSTR *ppszOutSymbol)
{
    (void)pContext;
    (void)pnOutOrdinal;
    (void)ppszOutSymbol;

    char szOrig[80];
    char szLast[80];

    if (pszOrigSymbol == NULL) {
        StringCchPrintfA(szOrig, sizeof(szOrig), "#%d", nOrigOrdinal);
        pszOrigSymbol = szOrig;
    }
    if (pszSymbol == NULL) {
        StringCchPrintfA(szLast, sizeof(szLast), "#%d", nOrdinal);
        pszSymbol = szLast;
    }

    printf("  symbol  %-32.32s %-32.32s\n", pszOrigSymbol, pszSymbol);
    return TRUE;
}

static BOOL CALLBACK ListCommit(PVOID pContext)
{
    (void)pContext;

    printf("  commit\n");
    return TRUE;
}

//////////////////////////////////////////////////////////////////////////////
//
struct MUNGE_STATE
{
    BOOL fLastWasByway;
    LONG nBywayCount;
    CHAR szBuffer[512];
};

static BOOL CALLBACK MungeByway(_In_opt_ PVOID pContext,
                                _In_opt_ LPCSTR pszFile,
                                _Outptr_result_maybenull_ LPCSTR *ppszOutFile)
{
    MUNGE_STATE *pState = (MUNGE_STATE *)pContext;

    printf("|");

    if (pState->fLastWasByway) {
        return TRUE;
    }

    pState->fLastWasByway = TRUE;

    if (pszFile == NULL) {
        StringCchPrintfA(pState->szBuffer, sizeof(pState->szBuffer), "mb_munge_%d.dll", pState->nBywayCount++);
        *ppszOutFile = pState->szBuffer;
    }
    return TRUE;
}

static BOOL CALLBACK MungeFile(_In_opt_ PVOID pContext,
                               _In_ LPCSTR pszOrigFile,
                               _In_ LPCSTR pszFile,
                               _Outptr_result_maybenull_ LPCSTR *ppszOutFile)
{
    (void)pszOrigFile;
    MUNGE_STATE *pState = (MUNGE_STATE *)pContext;

    pState->fLastWasByway = FALSE;

    printf("*");
    StringCchPrintfA(pState->szBuffer, sizeof(pState->szBuffer), "mf_%s", pszFile);
    *ppszOutFile = pState->szBuffer;
    return TRUE;
}

static BOOL CALLBACK MungeSymbol(_In_opt_ PVOID pContext,
                                 _In_ ULONG nOrigOrdinal,
                                 _In_ ULONG nOrdinal,
                                 _Out_ ULONG *pnOutOrdinal,
                                 _In_opt_ LPCSTR pszOrigSymbol,
                                 _In_opt_ LPCSTR pszSymbol,
                                 _Outptr_result_maybenull_ LPCSTR *ppszOutSymbol)
{
    (void)nOrigOrdinal;
    (void)pszOrigSymbol;
    MUNGE_STATE *pState = (MUNGE_STATE *)pContext;

    pState->fLastWasByway = FALSE;

    printf(".");
    if (nOrdinal != 0) {
        if (s_fToSymbols) {
            StringCchPrintfA(pState->szBuffer, sizeof(pState->szBuffer), "mo_%d", (int)nOrdinal);
            *pnOutOrdinal = 0;
            *ppszOutSymbol = pState->szBuffer;
        }
        else {
            *pnOutOrdinal = 10000 + nOrdinal;
            *ppszOutSymbol = NULL;
        }
    }
    else {
        StringCchPrintfA(pState->szBuffer, sizeof(pState->szBuffer), "ms_%s", pszSymbol);
        *pnOutOrdinal = 0;
        *ppszOutSymbol = pState->szBuffer;
    }
    return TRUE;
}

static BOOL CALLBACK MungeCommit(PVOID pContext)
{
    MUNGE_STATE *pState = (MUNGE_STATE *)pContext;

    pState->fLastWasByway = FALSE;

    printf("\n");
    (void)pContext;
    return TRUE;
}

//////////////////////////////////////////////////////////////////////////////
//
static BOOL CALLBACK RestoreByway(_In_opt_ PVOID pContext,
                                  _In_opt_ LPCSTR pszFile,
                                  _Outptr_result_maybenull_ LPCSTR *ppszOutFile)
{
    (void)pContext;
    (void)pszFile;

    *ppszOutFile = NULL;
    return TRUE;
}

static BOOL CALLBACK RestoreFile(_In_opt_ PVOID pContext,
                                 _In_ LPCSTR pszOrigFile,
                                 _In_ LPCSTR pszFile,
                                 _Outptr_result_maybenull_ LPCSTR *ppszOutFile)
{
    (void)pContext;
    (void)pszFile;

    *ppszOutFile = pszOrigFile;
    return TRUE;
}

static BOOL CALLBACK RestoreSymbol(_In_opt_ PVOID pContext,
                                   _In_ ULONG nOrigOrdinal,
                                   _In_ ULONG nOrdinal,
                                   _Out_ ULONG *pnOutOrdinal,
                                   _In_opt_ LPCSTR pszOrigSymbol,
                                   _In_opt_ LPCSTR pszSymbol,
                                   _Outptr_result_maybenull_ LPCSTR *ppszOutSymbol)
{
    (void)pContext;
    (void)nOrdinal;
    (void)pszSymbol;

    *pnOutOrdinal = nOrigOrdinal;
    *ppszOutSymbol = pszOrigSymbol;
    return TRUE;
}

static BOOL CALLBACK RestoreCommit(PVOID pContext)
{
    (void)pContext;
    return TRUE;
}

//////////////////////////////////////////////////////////////////////////////
//

BOOL EditFile(PCHAR pszInput, PCHAR pszOutput)
{
    BOOL fGood = TRUE;

    HANDLE hOld = INVALID_HANDLE_VALUE;
    HANDLE hNew = INVALID_HANDLE_VALUE;
    PDETOUR_BINARY pBinary = NULL;

    if (pszOutput != NULL) {
        printf("%s -> %s:\n", pszInput, pszOutput);
    }
    else {
        printf("%s:\n", pszInput);
    }

    hOld = CreateFileA(pszInput,
                       GENERIC_READ,
                       FILE_SHARE_READ,
                       NULL,
                       OPEN_EXISTING,
                       FILE_ATTRIBUTE_NORMAL,
                       NULL);

    if (hOld == INVALID_HANDLE_VALUE) {
        printf("Couldn't open input file: %s, error: %ld\n",
               pszInput, GetLastError());
        fGood = FALSE;
        goto end;
    }

    if ((pBinary = DetourBinaryOpen(hOld)) == NULL) {
        printf("DetourBinaryOpen failed: %ld\n", GetLastError());
        goto end;
    }

    if (hOld != INVALID_HANDLE_VALUE) {
        CloseHandle(hOld);
        hOld = INVALID_HANDLE_VALUE;
    }

    if (s_fRestore) {
        if (!DetourBinaryEditImports(pBinary,
                                     NULL,
                                     RestoreByway,
                                     RestoreFile,
                                     RestoreSymbol,
                                     RestoreCommit)) {

            printf("DetourBinaryEditImports for munge failed: %ld\n", GetLastError());
        }
    }

    if (s_fMunge) {
        MUNGE_STATE state;
        state.fLastWasByway = FALSE;
        state.nBywayCount = 1;

        if (!DetourBinaryEditImports(pBinary,
                                     &state,
                                     MungeByway,
                                     MungeFile,
                                     MungeSymbol,
                                     MungeCommit)) {

            printf("DetourBinaryEditImports for munge failed: %ld\n", GetLastError());
        }
    }

    if (s_fList) {
        if (!DetourBinaryEditImports(pBinary,
                                     NULL,
                                     ListByway,
                                     ListFile,
                                     ListSymbol,
                                     ListCommit)) {

            printf("DetourBinaryEditImports for list failed: %ld\n", GetLastError());
        }
    }

    if (pszOutput != NULL) {
        hNew = CreateFileA(pszOutput,
                           GENERIC_WRITE | GENERIC_READ, 0, NULL, CREATE_ALWAYS,
                           FILE_ATTRIBUTE_NORMAL | FILE_FLAG_SEQUENTIAL_SCAN, NULL);
        if (hNew == INVALID_HANDLE_VALUE) {
            printf("Couldn't open output file: %s, error: %ld\n",
                   pszOutput, GetLastError());
            fGood = FALSE;
            goto end;
        }

        if (!DetourBinaryWrite(pBinary, hNew)) {
            printf("DetourBinaryWrite failed: %ld\n", GetLastError());
            fGood = FALSE;
        }

        CloseHandle(hNew);
        hNew = INVALID_HANDLE_VALUE;
    }

    DetourBinaryClose(pBinary);
    pBinary = NULL;


    if (fGood && pszOutput != NULL) {
        if (!BindImageEx(BIND_NO_BOUND_IMPORTS, pszOutput, ".", ".", NULL)) {
            printf("Warning: Couldn't bind binary %s: %ld\n", pszOutput, GetLastError());
        }
    }

  end:
    if (pBinary) {
        DetourBinaryClose(pBinary);
        pBinary = NULL;
    }
    if (hNew != INVALID_HANDLE_VALUE) {
        CloseHandle(hNew);
        hNew = INVALID_HANDLE_VALUE;
    }
    if (hOld != INVALID_HANDLE_VALUE) {
        CloseHandle(hOld);
        hOld = INVALID_HANDLE_VALUE;
    }
    return fGood;
}

//////////////////////////////////////////////////////////////////////////////
//
void PrintUsage(void)
{
    printf("Usage:\n"
           "    impmunge [options] binary_files\n"
           "Options:\n"
           "    /l           : List imports.\n"
           "    /l-          : Don't list imports.\n"
           "    /m           : Munge imports.\n"
           "    /r           : Remove import munges.\n"
           "    /o:file      : Set name of output file; must be include with /m or /r.\n"
           "    /?           : This help screen.\n");
}

//////////////////////////////////////////////////////////////////////// main.
//
int CDECL main(int argc, char **argv)
{
    BOOL fNeedHelp = FALSE;
    PCHAR pszOutput = NULL;

    int arg = 1;
    for (; arg < argc && !fNeedHelp; arg++) {
        if (argv[arg][0] == '-' || argv[arg][0] == '/') {
            CHAR *argn = argv[arg] + 1;
            CHAR *argp = argn;
            while (*argp && *argp != ':')
                argp++;
            if (*argp == ':')
                *argp++ = '\0';

            switch (argn[0]) {

              case 'l':                                 // List contents of import table.
              case 'L':
                s_fList = (argn[1] != '-');
                break;

              case 'm':                                 // Munge import table.
              case 'M':
                s_fMunge = (argn[1] != '-');
                break;

              case 'o':                                 // Set output file name.
              case 'O':
                pszOutput = argp;
                break;
              case 'r':                                 // Restore file to unmunged state.
              case 'R':
                s_fRestore = (argn[1] != '-');
                break;

              case 's':                                 // Munge ordinals to symbols
              case 'S':
                s_fToSymbols = true;
                break;

              case '?':                                 // Help
                fNeedHelp = TRUE;
                break;

              default:
                fNeedHelp = TRUE;
                printf("Bad argument: %s:%s\n", argn, argp);
                break;
            }
        }
        else {
            if (!s_fList && !s_fMunge && !s_fRestore) {
                fNeedHelp = TRUE;
                break;
            }
            if (pszOutput == NULL && (s_fMunge || s_fRestore)) {
                fNeedHelp = TRUE;
                break;
            }

            EditFile(argv[arg], pszOutput);
            pszOutput = NULL;
        }
    }
    if (argc == 1) {
        fNeedHelp = TRUE;
    }
    if (fNeedHelp) {
        PrintUsage();
        return 1;
    }
    return 0;
}

// End of File

```

`samples/member/Makefile`:

```
##############################################################################
##
##  Makefile for Detours Test Programs.
##
##  Microsoft Research Detours Package
##
##  Copyright (c) Microsoft Corporation.  All rights reserved.
##

!include ..\common.mak

LIBS=$(LIBS) kernel32.lib

all: dirs \
    $(BIND)\member.exe \
!IF $(DETOURS_SOURCE_BROWSING)==1
    $(OBJD)\member.bsc
!ENDIF

clean:
    -del *~ 2> nul
    -del $(BIND)\member.* 2> nul
    -rmdir /q /s $(OBJD) 2>nul

realclean: clean
    -rmdir /q /s $(OBJDS) 2>nul

dirs:
    @if not exist $(BIND) mkdir $(BIND) && echo.   Created $(BIND)
    @if not exist $(OBJD) mkdir $(OBJD) && echo.   Created $(OBJD)

$(OBJD)\member.obj : member.cpp

$(BIND)\member.exe : $(OBJD)\member.obj $(DEPS)
    cl $(CFLAGS) /Fe$@ /Fd$(@R).pdb $(OBJD)\member.obj \
        /link $(LINKFLAGS) $(LIBS) /subsystem:console

$(OBJD)\member.bsc : $(OBJD)\member.obj
    bscmake /v /n /o $@ $(OBJD)\member.sbr

##############################################################################

test: $(BIND)\member.exe
    @echo.
    $(BIND)\member.exe
    @echo.

################################################################# End of File.

```

`samples/member/member.cpp`:

```cpp
//////////////////////////////////////////////////////////////////////////////
//
//  Test a detour of a member function (member.cpp of member.exe)
//
//  Microsoft Research Detours Package
//
//  Copyright (c) Microsoft Corporation.  All rights reserved.
//
//  By default, C++ member functions use the __thiscall calling convention.
//  In order to Detour a member function, both the trampoline and the detour
//  must have exactly the same calling convention as the target function.
//  Unfortunately, the VC compiler does not support a __thiscall, so the only
//  way to create legal detour and trampoline functions is by making them
//  class members of a "detour" class.
//
//  In addition, C++ does not support converting a pointer to a member
//  function to an arbitrary pointer.  To get a raw pointer, the address of
//  the member function must be moved into a temporary member-function
//  pointer, then passed by taking it's address, then de-referencing it.
//  Fortunately, the compiler will optimize the code to remove the extra
//  pointer operations.
//
//  If X::Target is a virtual function, the following code will *NOT* work
//  because &X::Target is the address of a thunk that does a virtual call,
//  not the real address of the X::Target.  You can get the real address
//  of X::Target by looking directly in the VTBL for class X, but there
//  is no legal way to 1) get the address of X's VTBL or 2) get the offset
//  of ::Target within that VTBL.  You can of course, figure these out for
//  a particular class and function, but there is no general way to do so.
//
#include <stdio.h>

#include <windows.h>
#include <detours.h>

#include "..\slept\verify.cpp"

//////////////////////////////////////////////////////////////// Target Class.
//
class CMember
{
  public:
    void Target(void);
};

void CMember::Target(void)
{
    printf("  CMember::Target!   (this:%p)\n", this);
}

//////////////////////////////////////////////////////////////// Detour Class.
//
class CDetour /* add ": public CMember" to enable access to member variables... */
{
  public:
    void Mine_Target(void);
    static void (CDetour::* Real_Target)(void);

    // Class shouldn't have any member variables or virtual functions.
};

void CDetour::Mine_Target(void)
{
    printf("  CDetour::Mine_Target! (this:%p)\n", this);
    (this->*Real_Target)();
}

void (CDetour::* CDetour::Real_Target)(void) = (void (CDetour::*)(void))&CMember::Target;

//////////////////////////////////////////////////////////////////////////////
//
int main(int argc, char **argv)
{
    (void)argc;
    (void)argv;

    //////////////////////////////////////////////////////////////////////////
    //

    void (CMember::* pfTarget)(void) = &CMember::Target;
    void (CDetour::* pfMine)(void) = &CDetour::Mine_Target;

    Verify("CMember::Target      ", *(PBYTE*)&pfTarget);
    Verify("*CDetour::Real_Target", *(PBYTE*)&CDetour::Real_Target);
    Verify("CDetour::Mine_Target ", *(PBYTE*)&pfMine);

    printf("\n");

    DetourTransactionBegin();
    DetourUpdateThread(GetCurrentThread());

    DetourAttach(&(PVOID&)CDetour::Real_Target,
                 *(PBYTE*)&pfMine);

    LONG l = DetourTransactionCommit();
    printf("DetourTransactionCommit = %ld\n", l);
    printf("\n");

    Verify("CMember::Target      ", *(PBYTE*)&pfTarget);
    Verify("*CDetour::Real_Target", *(&(PBYTE&)CDetour::Real_Target));
    Verify("CDetour::Mine_Target ", *(PBYTE*)&pfMine);
    printf("\n");

    //////////////////////////////////////////////////////////////////////////
    //
    CMember target;

    printf("Calling CMember (w/o Detour):\n");
    (((CDetour*)&target)->*CDetour::Real_Target)();

    printf("Calling CMember (will be detoured):\n");
    target.Target();

    return 0;
}


```

`samples/opengl/Makefile`:

```
######################################################################
##
##  Hook test for glFinish
##

!include ..\common.mak

LIBS=$(LIBS) kernel32.lib gdi32.lib

##############################################################################

all: dirs \
    $(BIND)\ogldet$(DETOURS_BITS).dll \
    $(BIND)\testogl.exe \
    \
!IF $(DETOURS_SOURCE_BROWSING)==1
    $(OBJD)\ogldet$(DETOURS_BITS).bsc \
    $(OBJD)\testogl.bsc \
!ENDIF
    option

##############################################################################

dirs:
    @if not exist $(BIND) mkdir $(BIND) && echo.   Created $(BIND)
    @if not exist $(OBJD) mkdir $(OBJD) && echo.   Created $(OBJD)

$(OBJD)\ogldet.obj : ogldet.cpp

$(OBJD)\ogldet.res : ogldet.rc

$(BIND)\ogldet$(DETOURS_BITS).dll $(BIND)\ogldet$(DETOURS_BITS).lib: \
        $(OBJD)\ogldet.obj $(OBJD)\ogldet.res $(DEPS)
    cl /LD $(CFLAGS) /Fe$(@R).dll /Fd$(@R).pdb \
        $(OBJD)\ogldet.obj $(OBJD)\ogldet.res \
        /link $(LINKFLAGS) /subsystem:console \
        /export:DetourFinishHelperProcess,@1,NONAME \
        /export:hookedGlFinish \
        $(LIBS) opengl32.lib

$(OBJD)\ogldet$(DETOURS_BITS).bsc : $(OBJD)\ogldet.obj
    bscmake /v /n /o $@ $(OBJD)\ogldet.sbr

$(OBJD)\testogl.obj : testogl.cpp

$(BIND)\testogl.exe : $(OBJD)\testogl.obj $(DEPS)
    cl $(CFLAGS) /Fe$@ /Fd$(@R).pdb $(OBJD)\testogl.obj \
        /link $(LINKFLAGS) $(LIBS) opengl32.lib \
        /subsystem:console

$(OBJD)\testogl.bsc : $(OBJD)\testogl.obj
    bscmake /v /n /o $@ $(OBJD)\testogl.sbr

##############################################################################

clean:
    -del *~ 2>nul
    -del $(BIND)\ogldet*.* 2>nul
    -del $(BIND)\testogl.* 2>nul
    -rmdir /q /s $(OBJD) 2>nul

realclean: clean
    -rmdir /q /s $(OBJDS) 2>nul

############################################### Install non-bit-size binaries.

!IF "$(DETOURS_OPTION_PROCESSOR)" != ""

$(OPTD)\olgdet$(DETOURS_OPTION_BITS).dll:
$(OPTD)\olgdet$(DETOURS_OPTION_BITS).pdb:

$(BIND)\olgdet$(DETOURS_OPTION_BITS).dll : $(OPTD)\olgdet$(DETOURS_OPTION_BITS).dll
    @if exist $? copy /y $? $(BIND) >nul && echo $@ copied from $(DETOURS_OPTION_PROCESSOR).
$(BIND)\olgdet$(DETOURS_OPTION_BITS).pdb : $(OPTD)\olgdet$(DETOURS_OPTION_BITS).pdb
    @if exist $? copy /y $? $(BIND) >nul && echo $@ copied from $(DETOURS_OPTION_PROCESSOR).

option: \
    $(BIND)\olgdet$(DETOURS_OPTION_BITS).dll \
    $(BIND)\olgdet$(DETOURS_OPTION_BITS).pdb \

!ELSE

option:

!ENDIF

##############################################################################

test: all
    @echo -------- Reseting test binaries to initial state. ---------------------
    $(BIND)\setdll.exe -r $(BIND)\testogl.exe
    @echo.
    @echo -------- Should not load ogldet$(DETOURS_BITS).dll -----------------------------------
    $(BIND)\testogl.exe
    @echo.
    @echo -------- Adding ogldet$(DETOURS_BITS).dll to testogl.exe ------------------------------
    $(BIND)\setdll.exe -d:$(BIND)\ogldet$(DETOURS_BITS).dll $(BIND)\testogl.exe
    @echo.
    @echo -------- Should load ogldet$(DETOURS_BITS).dll statically ----------------------------
    $(BIND)\testogl.exe
    @echo.
    @echo -------- Removing ogldet$(DETOURS_BITS).dll from testogl.exe --------------------------
    $(BIND)\setdll.exe -r $(BIND)\testogl.exe
    @echo.
    @echo -------- Should not load ogldet$(DETOURS_BITS).dll -----------------------------------
    $(BIND)\testogl.exe
    @echo.
    @echo -------- Should load ogldet$(DETOURS_BITS).dll dynamically using withdll.exe----------
    $(BIND)\withdll.exe -d:$(BIND)\ogldet$(DETOURS_BITS).dll $(BIND)\testogl.exe
    @echo.

################################################################# End of File.

```

`samples/opengl/ogldet.cpp`:

```cpp
//////////////////////////////////////////////////////////////////////////////
//
//  Module:     ogldet.dll
//
//  This DLL is based on the sample simple.dll. A detour is inserted for
//  the OpenGL glFinish function.
//
#include <stdio.h>
#include <windows.h>
#include <GL/gl.h>
#include "detours.h"

static void (WINAPI * trueGlFinish)(void) = glFinish;

void WINAPI hookedGlFinish(void)
{
    printf("ogldet" DETOURS_STRINGIFY(DETOURS_BITS) ".dll:"
           " hookedGlFinish Starting.\n");
    fflush(stdout);

    trueGlFinish();

    printf("ogldet" DETOURS_STRINGIFY(DETOURS_BITS) ".dll:"
           " hookedGlFinish done.\n");
    fflush(stdout);
}

BOOL WINAPI DllMain(HINSTANCE hinst, DWORD dwReason, LPVOID reserved)
{
    LONG error;
    (void)hinst;
    (void)reserved;

    if (DetourIsHelperProcess()) {
        return TRUE;
    }

    if (dwReason == DLL_PROCESS_ATTACH) {
        DetourRestoreAfterWith();

        printf("ogldet" DETOURS_STRINGIFY(DETOURS_BITS) ".dll:"
               " Starting.\n");
        fflush(stdout);

        DetourTransactionBegin();
        DetourUpdateThread(GetCurrentThread());
        DetourAttach(&(PVOID&)trueGlFinish, hookedGlFinish);
        error = DetourTransactionCommit();

        if (error == NO_ERROR) {
            printf("ogldet" DETOURS_STRINGIFY(DETOURS_BITS) ".dll:"
                   " Detoured glFinish().\n");
        }
        else {
            printf("ogldet" DETOURS_STRINGIFY(DETOURS_BITS) ".dll:"
                   " Error detouring glFinish(): %d\n", error);
        }
    }
    else if (dwReason == DLL_PROCESS_DETACH) {
        DetourTransactionBegin();
        DetourUpdateThread(GetCurrentThread());
        DetourDetach(&(PVOID&)trueGlFinish, hookedGlFinish);
        error = DetourTransactionCommit();

        printf("ogldet" DETOURS_STRINGIFY(DETOURS_BITS) ".dll:"
               " Removed detour glFinish() (result=%d)\n", error);
        fflush(stdout);
    }

    return TRUE;
}

//
///////////////////////////////////////////////////////////////// End of File.

```

`samples/opengl/ogldet.rc`:

```rc
//////////////////////////////////////////////////////////////////////////////
//
//  Version information for ogldet.rc.
//
//  Microsoft Research Detours Package
//
//  Copyright (c) Microsoft Corporation.  All rights reserved.
//

#include "detver.h"

#define VER_INTERNALNAME_STR        "ogldet" DETOURS_STRINGIFY(DETOURS_BITS)
#define VER_ORIGINALFILENAME_STR    "ogldet" DETOURS_STRINGIFY(DETOURS_BITS) ".dll"
#define VER_FILEDESCRIPTION_STR     "Detours Open GL Test Module"
#define VER_COMPANYNAME_STR         "Microsoft Corporation"

#include "common.ver"

```

`samples/opengl/testogl.cpp`:

```cpp
//////////////////////////////////////////////////////////////////////////////
//
//  File:       testogl.cpp
//  Module:     testogl.exe (oglsimple.dll)
//

#include <windows.h>
#include <stdio.h>
#include <GL/gl.h>

int __cdecl main()
{
    printf("testogl.exe: Starting\n");
    fflush(stdout);

    glFinish();

    printf("testogl.exe: done\n");
    fflush(stdout);

    return 0;
}
//
///////////////////////////////////////////////////////////////// End of File.

```

`samples/payload/Makefile`:

```
##############################################################################
##
##  Makefile for Detours Test Programs.
##
##  Microsoft Research Detours Package
##
##  Copyright (c) Microsoft Corporation.  All rights reserved.
##

!include ..\common.mak

LIBS=$(LIBS) kernel32.lib
CFLAGS=$(CFLAGS) /EHsc

all: dirs \
    $(BIND)\payload.exe \
    $(BIND)\payloadtarget.exe

clean:
    -del *~ 2>nul
    -del $(BIND)\payload.* 2>nul
    -del $(BIND)\payloadtarget.* 2>nul
    -rmdir /q /s $(OBJD) 2>nul

realclean: clean
    -rmdir /q /s $(OBJDS) 2>nul

dirs:
    @if not exist $(BIND) mkdir $(BIND) && echo.   Created $(BIND)
    @if not exist $(OBJD) mkdir $(OBJD) && echo.   Created $(OBJD)

$(OBJD)\payload.obj : payload.cpp

$(BIND)\payload.exe : $(OBJD)\payload.obj $(DEPS)
    link\
        /SUBSYSTEM:CONSOLE\
        $(LINKFLAGS)\
        $(LIBS)\
        /PDB:"$(@R).pdb"\
        /OUT:"$@"\
        $**\

$(OBJD)\payloadtarget.obj : payloadtarget.cpp

$(BIND)\payloadtarget.exe : $(OBJD)\payloadtarget.obj $(DEPS)
    link\
        /SUBSYSTEM:CONSOLE\
        $(LINKFLAGS)\
        $(LIBS)\
        /PDB:"$(@R).pdb"\
        /OUT:"$@"\
        $**\

##############################################################################

test: $(BIND)\payload.exe $(BIND)\payloadtarget.exe
    $(BIND)\payload.exe

################################################################# End of File.

```

`samples/payload/payload.cpp`:

```cpp
#include <iostream>
#include <string>
#include <windows.h>
#include <detours.h>

#include "payloadguid.hpp"

HANDLE hChildProcess = NULL;
HANDLE hChildThread = NULL;

__declspec(noreturn) void HandleApiFailure(const char* api)
{
    DWORD lastErr = GetLastError();
    std::cout << "payload.exe: " << api << " failed (" << lastErr << ')' << std::endl;

    if (hChildThread != NULL)
    {
        CloseHandle(hChildThread);
    }

    if (hChildProcess != NULL)
    {
        TerminateProcess(hChildProcess, 1);
        CloseHandle(hChildProcess);
    }

    ExitProcess(1);
}

std::wstring GetProcessFileName(HANDLE process)
{
    DWORD exeLocation_size = MAX_PATH + 1;

    std::wstring exeLocation;
    exeLocation.resize(exeLocation_size);

    if (!QueryFullProcessImageNameW(process, 0, &exeLocation[0], &exeLocation_size))
    {
        HandleApiFailure("QueryFullProcessImageNameW");
    }

    exeLocation.resize(exeLocation_size);
    return exeLocation;
}

void StartChild()
{
    std::wstring target = GetProcessFileName(GetCurrentProcess());
    target.erase(target.rfind(L'\\') + 1);
    target += L"payloadtarget.exe";

    STARTUPINFOW si = { sizeof(si) };
    PROCESS_INFORMATION pi;
    if (!CreateProcessW(target.c_str(), NULL, NULL, NULL, false,
        CREATE_SUSPENDED, NULL, NULL, &si, &pi))
    {
        HandleApiFailure("CreateProcessW");
    }

    hChildProcess = pi.hProcess;
    hChildThread = pi.hThread;
}

template<typename T>
volatile T* InjectPayload(HANDLE hProcess, T payload, REFGUID guid)
{
    return static_cast<volatile T*>(
        DetourCopyPayloadToProcessEx(hProcess,guid, &payload, sizeof(payload)));
}

int main()
{
    StartChild();

    // give the child a handle to ourself
    HANDLE targetHandleToParent;
    if (!DuplicateHandle(GetCurrentProcess(), GetCurrentProcess(),
        hChildProcess, &targetHandleToParent, 0, false, DUPLICATE_SAME_ACCESS))
    {
        HandleApiFailure("DuplicateHandle");
    }

    if (!InjectPayload(hChildProcess, targetHandleToParent, PARENT_HANDLE_PAYLOAD))
    {
        HandleApiFailure("DetourCopyPayloadToProcessEx");
    }

    // inject a payload in ourself containing zero data
    // the goal is for the child process to find this payload
    // and fill it with random data, to test DetourFindRemotePayload
    volatile random_payload_t* payloadAddr =
        InjectPayload<random_payload_t>(GetCurrentProcess(), 0, RANDOM_DATA_PAYLOAD);
    if (!payloadAddr)
    {
        HandleApiFailure("DetourCopyPayloadToProcessEx");
    }

    if (!ResumeThread(hChildThread))
    {
        HandleApiFailure("ResumeThread");
    }

    CloseHandle(hChildThread);
    hChildThread = NULL;

    if (WaitForSingleObject(hChildProcess, INFINITE) == WAIT_FAILED)
    {
        HandleApiFailure("WaitForSingleObject");
    }

    DWORD exitCode;
    if (!GetExitCodeProcess(hChildProcess, &exitCode))
    {
        HandleApiFailure("GetExitCodeProcess");
    }

    // the exit code should match the random data the child process gave us
    random_payload_t payload = *payloadAddr;
    if (exitCode == payload)
    {
        std::cout << "Success, exit code (0x" << std::uppercase << std::hex << exitCode
            << ") matches payload content (0x" << payload << ')' << std::endl;
        return 0;
    }
    else
    {
        std::cout << "Error, exit code (0x" << std::uppercase  << std::hex << exitCode
            << ") does not matches payload content (0x" << payload << ')' << std::endl;
        return 1;
    }
}
```

`samples/payload/payloadguid.hpp`:

```hpp
#pragma once
#include <guiddef.h>

// {C2569A74-12FE-4E06-8F02-8DF13E39A266}
const GUID PARENT_HANDLE_PAYLOAD =
{ 0xc2569a74, 0x12fe, 0x4e06, { 0x8f, 0x2, 0x8d, 0xf1, 0x3e, 0x39, 0xa2, 0x66 } };

// {CB5230ED-04FA-4C47-B606-AC09B2777601}
const GUID RANDOM_DATA_PAYLOAD =
{ 0xcb5230ed, 0x4fa, 0x4c47, { 0xb6, 0x6, 0xac, 0x9, 0xb2, 0x77, 0x76, 0x1 } };

typedef unsigned int random_payload_t;
```

`samples/payload/payloadtarget.cpp`:

```cpp
#define _CRT_RAND_S
#include <stdlib.h>

#include <iostream>
#include <windows.h>
#include <detours.h>

#include "payloadguid.hpp"

HANDLE hParent = NULL;

__declspec(noreturn) void HandleApiFailure(const char* api)
{
    DWORD lastErr = GetLastError();
    std::cout << "payloadtarget.exe: " << api << " failed (" << lastErr << ')' << std::endl;

    if (hParent)
    {
        CloseHandle(hParent);
    }

    ExitProcess(1);
}

int main()
{
    DWORD payloadSize;
    void* payloadAddr = DetourFindPayloadEx(PARENT_HANDLE_PAYLOAD, &payloadSize);
    if (!payloadAddr || payloadSize != sizeof(HANDLE))
    {
        HandleApiFailure("DetourFindPayloadEx");
    }

    hParent = *static_cast<HANDLE*>(payloadAddr);

    DWORD randomPayloadSize;
    void* randomPayload = DetourFindRemotePayload(hParent, RANDOM_DATA_PAYLOAD, &randomPayloadSize);
    if (!randomPayload || randomPayloadSize != sizeof(random_payload_t))
    {
        HandleApiFailure("DetourFindRemotePayload");
    }

    random_payload_t randomData;
    if (rand_s(&randomData) != 0)
    {
        HandleApiFailure("rand_s");
    }


    if (!WriteProcessMemory(hParent, randomPayload, &randomData, sizeof(randomData), NULL))
    {
        HandleApiFailure("WriteProcessMemory");
    }

    CloseHandle(hParent);
    hParent = NULL;

    // conversion to int return type is potentially undefined
    ExitProcess(randomData);
}
```

`samples/region/Makefile`:

```
##############################################################################
##
##  Makefile for Detours Test Programs.
##
##  Microsoft Research Detours Package
##
##  Copyright (c) Microsoft Corporation.  All rights reserved.
##

!include ..\common.mak

LIBS=$(LIBS) kernel32.lib

all: dirs \
    $(BIND)\region.exe \
!IF $(DETOURS_SOURCE_BROWSING)==1
    $(OBJD)\region.bsc
!ENDIF

clean:
    -del *~ 2> nul
    -del $(BIND)\region.* 2> nul
    -rmdir /q /s $(OBJD) 2>nul

realclean: clean
    -rmdir /q /s $(OBJDS) 2>nul

dirs:
    @if not exist $(BIND) mkdir $(BIND) && echo.   Created $(BIND)
    @if not exist $(OBJD) mkdir $(OBJD) && echo.   Created $(OBJD)

$(OBJD)\region.obj : region.cpp

$(BIND)\region.exe : $(OBJD)\region.obj $(DEPS)
    cl $(CFLAGS) /Fe$@ /Fd$(@R).pdb $(OBJD)\region.obj \
        /link $(LINKFLAGS) $(LIBS) /subsystem:console

$(OBJD)\region.bsc : $(OBJD)\region.obj
    bscmake /v /n /o $@ $(OBJD)\region.sbr

##############################################################################

test: $(BIND)\region.exe
    @echo.
    $(BIND)\region.exe
    @echo.

################################################################# End of File.

```

`samples/region/region.cpp`:

```cpp
//////////////////////////////////////////////////////////////////////////////
//
//  Test the different system region bounds (region.cpp of region.exe)
//
//  Microsoft Research Detours Package
//
//  Copyright (c) Microsoft Corporation.  All rights reserved.
//
#include <stdio.h>

#include <windows.h>
#include <detours.h>

//////////////////////////////////////////////////////////////////////////////
//
static DWORD (WINAPI * TrueSleepEx)(DWORD dwMilliseconds, BOOL bAlertable) = SleepEx;

DWORD WINAPI LoudSleepEx(DWORD dwMilliseconds, BOOL bAlertable)
{
    DWORD dwBeg = GetTickCount();
    DWORD ret = TrueSleepEx(dwMilliseconds, bAlertable);
    DWORD dwEnd = GetTickCount();

    printf("Slept %lu ticks.\n", dwEnd - dwBeg);
    return ret;
}

//////////////////////////////////////////////////////////////////////////////
//
PVOID AttachAndDetach(DWORD dwMilliseconds)
{
    LONG error;
    PVOID trampoline;

    DetourTransactionBegin();
    DetourUpdateThread(GetCurrentThread());
    DetourAttach(&(PVOID&)TrueSleepEx, LoudSleepEx);
    error = DetourTransactionCommit();

    printf("Attach: %ld, Trampoline: %p\n", error, TrueSleepEx);

    trampoline = TrueSleepEx;

    printf("\n");
    printf("Sleep(%lu)\n", dwMilliseconds);
    Sleep(dwMilliseconds);
    printf("\n");

    DetourTransactionBegin();
    DetourUpdateThread(GetCurrentThread());
    DetourDetach(&(PVOID&)TrueSleepEx, LoudSleepEx);
    error = DetourTransactionCommit();

    return trampoline;
}

int main(int argc, char **argv)
{
    (void)argc;
    (void)argv;

    // First, save the default system region.

    PVOID pDefaultLower = DetourSetSystemRegionLowerBound(NULL);
    PVOID pDefaultUpper = DetourSetSystemRegionUpperBound(NULL);

    // Now attach the detour with the default system region.

    DetourSetSystemRegionLowerBound(pDefaultLower);
    DetourSetSystemRegionUpperBound(pDefaultUpper);

    printf("%p..%p: ", pDefaultLower, pDefaultUpper);
    PVOID pTramp1 = AttachAndDetach(10);

    printf("%p..%p: ", pDefaultLower, pDefaultUpper);
    PVOID pTramp2 = AttachAndDetach(10);

    // Now attach the detour with a smaller system region.

    PVOID pSmallerLower = (PVOID)( ((ULONG_PTR)pTramp1) & ~(ULONG_PTR)0x3fffffff );
    PVOID pSmallerUpper = (PVOID)( ((ULONG_PTR)pTramp1 + 0x3fffffff) & ~(ULONG_PTR)0x3fffffff );

    DetourSetSystemRegionLowerBound(pSmallerLower);
    DetourSetSystemRegionUpperBound(pSmallerUpper);

    printf("%p..%p: ", pSmallerLower, pSmallerUpper);
    PVOID pTramp3 = AttachAndDetach(20);

    printf("Sleep(30)\n");
    Sleep(30);
    printf("\n");

    if (pTramp1 != pTramp2) {
        printf("!!!!!! Trampoling allocation is not deterministic.  %p != %p\n", pTramp1, pTramp2);
        return 1;
    }
    else if (pTramp2 == pTramp3) {
        printf("!!!!!! Trampoling allocation doesn't skip region.  %p == %p\n", pTramp2, pTramp3);
        return 2;
    }

    return 0;
}


```

`samples/setdll/Makefile`:

```
##############################################################################
##
##  Makefile for Detours Test Programs.
##
##  Microsoft Research Detours Package
##
##  Copyright (c) Microsoft Corporation.  All rights reserved.
##

!include ..\common.mak

LIBS=$(LIBS) kernel32.lib

all: dirs \
    $(BIND)\setdll.exe \
!IF $(DETOURS_SOURCE_BROWSING)==1
    $(OBJD)\setdll.bsc \
!ENDIF
    option

##############################################################################

clean:
    -del *~ 2>nul
    -del $(BIND)\setdll.* 2>nul
    -rmdir /q /s $(OBJD) 2>nul

realclean: clean
    -rmdir /q /s $(OBJDS) 2>nul

##############################################################################

dirs:
    @if not exist $(BIND) mkdir $(BIND) && echo.   Created $(BIND)
    @if not exist $(OBJD) mkdir $(OBJD) && echo.   Created $(OBJD)

$(OBJD)\setdll.obj : setdll.cpp

$(BIND)\setdll.exe : $(OBJD)\setdll.obj $(DEPS)
    cl $(CFLAGS) /Fe$@ /Fd$(@R).pdb $(OBJD)\setdll.obj \
        /link $(LINKFLAGS) $(LIBS) /subsystem:console

$(OBJD)\setdll.bsc : $(OBJD)\setdll.obj
    bscmake /v /n /o $@ $(OBJD)\setdll.sbr

############################################### Install non-bit-size binaries.

option:

##############################################################################

test: all
    @echo -------- Reseting test binaries to initial state. -----------------------
    $(BIND)\setdll.exe -d:$(BIND)\slept$(DETOURS_BITS).dll $(BIND)\sleepold.exe
    @echo -------- Should load slept$(DETOURS_BITS).dll statically -------------------------------
    $(BIND)\sleepold.exe
    @echo -------- Reseting test binaries to initial state. -----------------------
    $(BIND)\setdll.exe -r $(BIND)\sleepold.exe
    @echo -------- Should not load slept$(DETOURS_BITS).dll --------------------------------------
    $(BIND)\sleepold.exe

################################################################# End of File.

```

`samples/setdll/setdll.cpp`:

```cpp
//////////////////////////////////////////////////////////////////////////////
//
//  Detours Test Program (setdll.cpp of setdll.exe)
//
//  Microsoft Research Detours Package
//
//  Copyright (c) Microsoft Corporation.  All rights reserved.
//
#include <stdio.h>
#include <stdlib.h>
#include <windows.h>
#include <shellapi.h>
#include <detours.h>
#pragma warning(push)
#if _MSC_VER > 1400
#pragma warning(disable:6102 6103) // /analyze warnings
#endif
#include <strsafe.h>
#pragma warning(pop)

////////////////////////////////////////////////////////////// Error Messages.
//
VOID AssertMessage(PCSTR szMsg, PCSTR szFile, DWORD nLine)
{
    printf("ASSERT(%s) failed in %s, line %ld.", szMsg, szFile, nLine);
}

#define ASSERT(x)   \
do { if (!(x)) { AssertMessage(#x, __FILE__, __LINE__); DebugBreak(); }} while (0)
    ;


//////////////////////////////////////////////////////////////////////////////
//
static BOOLEAN  s_fRemove = FALSE;
static CHAR     s_szDllPath[MAX_PATH] = "";

//////////////////////////////////////////////////////////////////////////////
//
//  This code verifies that the named DLL has been configured correctly
//  to be imported into the target process.  DLLs must export a function with
//  ordinal #1 so that the import table touch-up magic works.
//
static BOOL CALLBACK ExportCallback(_In_opt_ PVOID pContext,
                                    _In_ ULONG nOrdinal,
                                    _In_opt_ LPCSTR pszName,
                                    _In_opt_ PVOID pCode)
{
    (void)pContext;
    (void)pCode;
    (void)pszName;

    if (nOrdinal == 1) {
        *((BOOL *)pContext) = TRUE;
    }
    return TRUE;
}

BOOL DoesDllExportOrdinal1(PCHAR pszDllPath)
{
    HMODULE hDll = LoadLibraryExA(pszDllPath, NULL, DONT_RESOLVE_DLL_REFERENCES);
    if (hDll == NULL) {
        printf("setdll.exe: LoadLibraryEx(%s) failed with error %ld.\n",
               pszDllPath,
               GetLastError());
        return FALSE;
    }

    BOOL validFlag = FALSE;
    DetourEnumerateExports(hDll, &validFlag, ExportCallback);
    FreeLibrary(hDll);
    return validFlag;
}

//////////////////////////////////////////////////////////////////////////////
//
static BOOL CALLBACK ListBywayCallback(_In_opt_ PVOID pContext,
                                       _In_opt_ LPCSTR pszFile,
                                       _Outptr_result_maybenull_ LPCSTR *ppszOutFile)
{
    (void)pContext;

    *ppszOutFile = pszFile;
    if (pszFile) {
        printf("    %s\n", pszFile);
    }
    return TRUE;
}

static BOOL CALLBACK ListFileCallback(_In_opt_ PVOID pContext,
                                      _In_ LPCSTR pszOrigFile,
                                      _In_ LPCSTR pszFile,
                                      _Outptr_result_maybenull_ LPCSTR *ppszOutFile)
{
    (void)pContext;

    *ppszOutFile = pszFile;
    printf("    %s -> %s\n", pszOrigFile, pszFile);
    return TRUE;
}

static BOOL CALLBACK AddBywayCallback(_In_opt_ PVOID pContext,
                                      _In_opt_ LPCSTR pszFile,
                                      _Outptr_result_maybenull_ LPCSTR *ppszOutFile)
{
    PBOOL pbAddedDll = (PBOOL)pContext;
    if (!pszFile && !*pbAddedDll) {                     // Add new byway.
        *pbAddedDll = TRUE;
        *ppszOutFile = s_szDllPath;
    }
    return TRUE;
}

BOOL SetFile(PCHAR pszPath)
{
    BOOL bGood = TRUE;
    HANDLE hOld = INVALID_HANDLE_VALUE;
    HANDLE hNew = INVALID_HANDLE_VALUE;
    PDETOUR_BINARY pBinary = NULL;

    CHAR szOrg[MAX_PATH];
    CHAR szNew[MAX_PATH];
    CHAR szOld[MAX_PATH];

    szOld[0] = '\0';
    szNew[0] = '\0';

    StringCchCopyA(szOrg, sizeof(szOrg), pszPath);
    StringCchCopyA(szNew, sizeof(szNew), szOrg);
    StringCchCatA(szNew, sizeof(szNew), "#");
    StringCchCopyA(szOld, sizeof(szOld), szOrg);
    StringCchCatA(szOld, sizeof(szOld), "~");
    printf("  %s:\n", pszPath);

    hOld = CreateFileA(szOrg,
                       GENERIC_READ,
                       FILE_SHARE_READ,
                       NULL,
                       OPEN_EXISTING,
                       FILE_ATTRIBUTE_NORMAL,
                       NULL);

    if (hOld == INVALID_HANDLE_VALUE) {
        printf("Couldn't open input file: %s, error: %ld\n",
               szOrg, GetLastError());
        bGood = FALSE;
        goto end;
    }

    hNew = CreateFileA(szNew,
                       GENERIC_WRITE | GENERIC_READ, 0, NULL, CREATE_ALWAYS,
                       FILE_ATTRIBUTE_NORMAL | FILE_FLAG_SEQUENTIAL_SCAN, NULL);
    if (hNew == INVALID_HANDLE_VALUE) {
        printf("Couldn't open output file: %s, error: %ld\n",
               szNew, GetLastError());
        bGood = FALSE;
        goto end;
    }

    if ((pBinary = DetourBinaryOpen(hOld)) == NULL) {
        printf("DetourBinaryOpen failed: %ld\n", GetLastError());
        goto end;
    }

    if (hOld != INVALID_HANDLE_VALUE) {
        CloseHandle(hOld);
        hOld = INVALID_HANDLE_VALUE;
    }

    {
        BOOL bAddedDll = FALSE;

        DetourBinaryResetImports(pBinary);

        if (!s_fRemove) {
            if (!DetourBinaryEditImports(pBinary,
                                         &bAddedDll,
                                         AddBywayCallback, NULL, NULL, NULL)) {
                printf("DetourBinaryEditImports failed: %ld\n", GetLastError());
            }
        }

        if (!DetourBinaryEditImports(pBinary, NULL,
                                     ListBywayCallback, ListFileCallback,
                                     NULL, NULL)) {

            printf("DetourBinaryEditImports failed: %ld\n", GetLastError());
        }

        if (!DetourBinaryWrite(pBinary, hNew)) {
            printf("DetourBinaryWrite failed: %ld\n", GetLastError());
            bGood = FALSE;
        }

        DetourBinaryClose(pBinary);
        pBinary = NULL;

        if (hNew != INVALID_HANDLE_VALUE) {
            CloseHandle(hNew);
            hNew = INVALID_HANDLE_VALUE;
        }

        if (bGood) {
            if (!DeleteFileA(szOld)) {
                DWORD dwError = GetLastError();
                if (dwError != ERROR_FILE_NOT_FOUND) {
                    printf("Warning: Couldn't delete %s: %ld\n", szOld, dwError);
                    bGood = FALSE;
                }
            }
            if (!MoveFileA(szOrg, szOld)) {
                printf("Error: Couldn't back up %s to %s: %ld\n",
                       szOrg, szOld, GetLastError());
                bGood = FALSE;
            }
            if (!MoveFileA(szNew, szOrg)) {
                printf("Error: Couldn't install %s as %s: %ld\n",
                       szNew, szOrg, GetLastError());
                bGood = FALSE;
            }
        }

        DeleteFileA(szNew);
    }


  end:
    if (pBinary) {
        DetourBinaryClose(pBinary);
        pBinary = NULL;
    }
    if (hNew != INVALID_HANDLE_VALUE) {
        CloseHandle(hNew);
        hNew = INVALID_HANDLE_VALUE;
    }
    if (hOld != INVALID_HANDLE_VALUE) {
        CloseHandle(hOld);
        hOld = INVALID_HANDLE_VALUE;
    }
    return bGood;
}

//////////////////////////////////////////////////////////////////////////////
//
void PrintUsage(void)
{
    printf("Usage:\n"
           "    setdll [options] binary_files\n"
           "Options:\n"
           "    /d:file.dll  : Add file.dll binary files\n"
           "    /r           : Remove extra DLLs from binary files\n"
           "    /?           : This help screen.\n");
}

//////////////////////////////////////////////////////////////////////// main.
//
int CDECL main(int argc, char **argv)
{
    BOOL fNeedHelp = FALSE;
    PCHAR pszFilePart = NULL;

    int arg = 1;
    for (; arg < argc; arg++) {
        if (argv[arg][0] == '-' || argv[arg][0] == '/') {
            CHAR *argn = argv[arg] + 1;
            CHAR *argp = argn;
            while (*argp && *argp != ':' && *argp != '=')
                argp++;
            if (*argp == ':' || *argp == '=')
                *argp++ = '\0';

            switch (argn[0]) {

              case 'd':                                 // Set DLL
              case 'D':
                if ((strchr(argp, ':') != NULL || strchr(argp, '\\') != NULL) &&
                    GetFullPathNameA(argp, sizeof(s_szDllPath), s_szDllPath, &pszFilePart)) {
                }
                else {
                    StringCchPrintfA(s_szDllPath, sizeof(s_szDllPath), "%s", argp);
                }
                break;

              case 'r':                                 // Remove extra set DLLs.
              case 'R':
                s_fRemove = TRUE;
                break;

              case '?':                                 // Help
                fNeedHelp = TRUE;
                break;

              default:
                fNeedHelp = TRUE;
                printf("Bad argument: %s:%s\n", argn, argp);
                break;
            }
        }
    }
    if (argc == 1) {
        fNeedHelp = TRUE;
    }
    if (!s_fRemove && s_szDllPath[0] == 0) {
        fNeedHelp = TRUE;
    }
    if (fNeedHelp) {
        PrintUsage();
        return 1;
    }


    if (s_fRemove) {
        printf("Removing extra DLLs from binary files.\n");
    }
    else {
        if (!DoesDllExportOrdinal1(s_szDllPath)) {
            printf("Error: %hs does not export function with ordinal #1.\n",
                   s_szDllPath);
            return 2;
        }
        printf("Adding %hs to binary files.\n", s_szDllPath);
    }

    for (arg = 1; arg < argc; arg++) {
        if (argv[arg][0] != '-' && argv[arg][0] != '/') {
            SetFile(argv[arg]);
        }
    }
    return 0;
}

// End of File

```

`samples/simple/Makefile`:

```
##############################################################################
##
##  API Extention to Measure time slept.
##
##  Microsoft Research Detours Package
##
##  Copyright (c) Microsoft Corporation.  All rights reserved.
##

!include ..\common.mak

LIBS=$(LIBS) kernel32.lib

##############################################################################

all: dirs \
    $(BIND)\simple$(DETOURS_BITS).dll \
    $(BIND)\sleep5.exe \
    \
!IF $(DETOURS_SOURCE_BROWSING)==1
    $(OBJD)\simple$(DETOURS_BITS).bsc \
    $(OBJD)\sleep5.bsc \
!ENDIF
    option

##############################################################################

dirs:
    @if not exist $(BIND) mkdir $(BIND) && echo.   Created $(BIND)
    @if not exist $(OBJD) mkdir $(OBJD) && echo.   Created $(OBJD)

$(OBJD)\simple.obj : simple.cpp

$(OBJD)\simple.res : simple.rc

$(BIND)\simple$(DETOURS_BITS).dll $(BIND)\simple$(DETOURS_BITS).lib: \
        $(OBJD)\simple.obj $(OBJD)\simple.res $(DEPS)
    cl /LD $(CFLAGS) /Fe$(@R).dll /Fd$(@R).pdb \
        $(OBJD)\simple.obj $(OBJD)\simple.res \
        /link $(LINKFLAGS) /subsystem:console \
        /export:DetourFinishHelperProcess,@1,NONAME \
        /export:TimedSleepEx \
        $(LIBS)

$(OBJD)\simple$(DETOURS_BITS).bsc : $(OBJD)\simple.obj
    bscmake /v /n /o $@ $(OBJD)\simple.sbr

$(OBJD)\sleep5.obj : sleep5.cpp

$(BIND)\sleep5.exe : $(OBJD)\sleep5.obj $(DEPS)
    cl $(CFLAGS) /Fe$@ /Fd$(@R).pdb $(OBJD)\sleep5.obj \
        /link $(LINKFLAGS) $(LIBS) \
        /subsystem:console

$(OBJD)\sleep5.bsc : $(OBJD)\sleep5.obj
    bscmake /v /n /o $@ $(OBJD)\sleep5.sbr

##############################################################################

clean:
    -del *~ 2>nul
    -del $(BIND)\simple*.* 2>nul
    -del $(BIND)\sleep5.* 2>nul
    -rmdir /q /s $(OBJD) 2>nul

realclean: clean
    -rmdir /q /s $(OBJDS) 2>nul

############################################### Install non-bit-size binaries.

!IF "$(DETOURS_OPTION_PROCESSOR)" != ""

$(OPTD)\simple$(DETOURS_OPTION_BITS).dll:
$(OPTD)\simple$(DETOURS_OPTION_BITS).pdb:

$(BIND)\simple$(DETOURS_OPTION_BITS).dll : $(OPTD)\simple$(DETOURS_OPTION_BITS).dll
    @if exist $? copy /y $? $(BIND) >nul && echo $@ copied from $(DETOURS_OPTION_PROCESSOR).
$(BIND)\simple$(DETOURS_OPTION_BITS).pdb : $(OPTD)\simple$(DETOURS_OPTION_BITS).pdb
    @if exist $? copy /y $? $(BIND) >nul && echo $@ copied from $(DETOURS_OPTION_PROCESSOR).

option: \
    $(BIND)\simple$(DETOURS_OPTION_BITS).dll \
    $(BIND)\simple$(DETOURS_OPTION_BITS).pdb \

!ELSE

option:

!ENDIF

##############################################################################

test: all
    @echo -------- Reseting test binaries to initial state. ---------------------
    $(BIND)\setdll.exe -r $(BIND)\sleep5.exe
    @echo.
    @echo -------- Should not load simple$(DETOURS_BITS).dll -----------------------------------
    $(BIND)\sleep5.exe
    @echo.
    @echo -------- Adding simple$(DETOURS_BITS).dll to sleep5.exe ------------------------------
    $(BIND)\setdll.exe -d:$(BIND)\simple$(DETOURS_BITS).dll $(BIND)\sleep5.exe
    @echo.
    @echo -------- Should load simple$(DETOURS_BITS).dll statically ----------------------------
    $(BIND)\sleep5.exe
    @echo.
    @echo -------- Removing simple$(DETOURS_BITS).dll from sleep5.exe --------------------------
    $(BIND)\setdll.exe -r $(BIND)\sleep5.exe
    @echo.
    @echo -------- Should not load simple$(DETOURS_BITS).dll -----------------------------------
    $(BIND)\sleep5.exe
    @echo.
    @echo -------- Should load simple$(DETOURS_BITS).dll dynamically using withdll.exe----------
    $(BIND)\withdll.exe -d:$(BIND)\simple$(DETOURS_BITS).dll $(BIND)\sleep5.exe
    @echo.

debug: all
    windbg -o $(BIND)\withdll.exe -d:$(BIND)\simple$(DETOURS_BITS).dll $(BIND)\sleep5.exe


################################################################# End of File.

```

`samples/simple/simple.cpp`:

```cpp
//////////////////////////////////////////////////////////////////////////////
//
//  Detours Test Program (simple.cpp of simple.dll)
//
//  Microsoft Research Detours Package
//
//  Copyright (c) Microsoft Corporation.  All rights reserved.
//
//  This DLL will detour the Windows SleepEx API so that TimedSleep function
//  gets called instead.  TimedSleepEx records the before and after times, and
//  calls the real SleepEx API through the TrueSleepEx function pointer.
//
#include <stdio.h>
#include <windows.h>
#include "detours.h"

static LONG dwSlept = 0;
static DWORD (WINAPI * TrueSleepEx)(DWORD dwMilliseconds, BOOL bAlertable) = SleepEx;

DWORD WINAPI TimedSleepEx(DWORD dwMilliseconds, BOOL bAlertable)
{
    DWORD dwBeg = GetTickCount();
    DWORD ret = TrueSleepEx(dwMilliseconds, bAlertable);
    DWORD dwEnd = GetTickCount();

    InterlockedExchangeAdd(&dwSlept, dwEnd - dwBeg);

    return ret;
}

BOOL WINAPI DllMain(HINSTANCE hinst, DWORD dwReason, LPVOID reserved)
{
    LONG error;
    (void)hinst;
    (void)reserved;

    if (DetourIsHelperProcess()) {
        return TRUE;
    }

    if (dwReason == DLL_PROCESS_ATTACH) {
        DetourRestoreAfterWith();

        printf("simple" DETOURS_STRINGIFY(DETOURS_BITS) ".dll:"
               " Starting.\n");
        fflush(stdout);

        DetourTransactionBegin();
        DetourUpdateThread(GetCurrentThread());
        DetourAttach(&(PVOID&)TrueSleepEx, TimedSleepEx);
        error = DetourTransactionCommit();

        if (error == NO_ERROR) {
            printf("simple" DETOURS_STRINGIFY(DETOURS_BITS) ".dll:"
                   " Detoured SleepEx().\n");
        }
        else {
            printf("simple" DETOURS_STRINGIFY(DETOURS_BITS) ".dll:"
                   " Error detouring SleepEx(): %ld\n", error);
        }
    }
    else if (dwReason == DLL_PROCESS_DETACH) {
        DetourTransactionBegin();
        DetourUpdateThread(GetCurrentThread());
        DetourDetach(&(PVOID&)TrueSleepEx, TimedSleepEx);
        error = DetourTransactionCommit();

        printf("simple" DETOURS_STRINGIFY(DETOURS_BITS) ".dll:"
               " Removed SleepEx() (result=%ld), slept %ld ticks.\n", error, dwSlept);
        fflush(stdout);
    }
    return TRUE;
}

//
///////////////////////////////////////////////////////////////// End of File.

```

`samples/simple/simple.rc`:

```rc
//////////////////////////////////////////////////////////////////////////////
//
//  Version information for simple.rc.
//
//  Microsoft Research Detours Package
//
//  Copyright (c) Microsoft Corporation.  All rights reserved.
//

#include "detver.h"

#define VER_INTERNALNAME_STR        "simple" DETOURS_STRINGIFY(DETOURS_BITS)
#define VER_ORIGINALFILENAME_STR    "simple" DETOURS_STRINGIFY(DETOURS_BITS) ".dll"
#define VER_FILEDESCRIPTION_STR     "Detours Test Module"
#define VER_COMPANYNAME_STR         "Microsoft Corporation"

#include "common.ver"

```

`samples/simple/sleep5.cpp`:

```cpp
//////////////////////////////////////////////////////////////////////////////
//
//  Detours Test Program (sleep5.cpp of sleep5.exe)
//
//  Microsoft Research Detours Package
//
//  Copyright (c) Microsoft Corporation.  All rights reserved.
//

#include <windows.h>
#include <stdio.h>
#include <stdlib.h>

int __cdecl main(int argc, char ** argv)
{
    if (argc == 2) {
        Sleep(atoi(argv[1]) * 1000);
    }
    else {
        printf("sleep5.exe: Starting.\n");

        Sleep(5000);

        printf("sleep5.exe: Done sleeping.\n");
    }
    return 0;
}
//
///////////////////////////////////////////////////////////////// End of File.

```

`samples/simple_safe/Makefile`:

```
##############################################################################
##
##  API Extention to Measure time slept.
##
##  Microsoft Research Detours Package
##
##  Copyright (c) Microsoft Corporation.  All rights reserved.
##

!include ..\common.mak

LIBS=$(LIBS) kernel32.lib
CFLAGS=$(CFLAGS) /std:c++14

##############################################################################

all: dirs \
    $(BIND)\simple_safe$(DETOURS_BITS).dll \
    $(BIND)\sleep5.exe \
    \
!IF $(DETOURS_SOURCE_BROWSING)==1
    $(OBJD)\simple_safe$(DETOURS_BITS).bsc \
    $(OBJD)\sleep5.bsc \
!ENDIF
    option

##############################################################################

dirs:
    @if not exist $(BIND) mkdir $(BIND) && echo.   Created $(BIND)
    @if not exist $(OBJD) mkdir $(OBJD) && echo.   Created $(OBJD)

$(OBJD)\simple_safe.obj : simple_safe.cpp

$(OBJD)\simple_safe.res : simple_safe.rc

$(BIND)\simple_safe$(DETOURS_BITS).dll $(BIND)\simple_safe$(DETOURS_BITS).lib: \
        $(OBJD)\simple_safe.obj $(OBJD)\simple_safe.res $(DEPS)
    cl /LD $(CFLAGS) /Fe$(@R).dll /Fd$(@R).pdb \
        $(OBJD)\simple_safe.obj $(OBJD)\simple_safe.res \
        /link $(LINKFLAGS) /subsystem:console \
        /export:DetourFinishHelperProcess,@1,NONAME \
        /export:TimedSleepEx \
        $(LIBS)

$(OBJD)\simple_safe$(DETOURS_BITS).bsc : $(OBJD)\simple_safe.obj
    bscmake /v /n /o $@ $(OBJD)\simple_safe.sbr

$(OBJD)\sleep5.obj : sleep5.cpp

$(BIND)\sleep5.exe : $(OBJD)\sleep5.obj $(DEPS)
    cl $(CFLAGS) /Fe$@ /Fd$(@R).pdb $(OBJD)\sleep5.obj \
        /link $(LINKFLAGS) $(LIBS) \
        /subsystem:console

$(OBJD)\sleep5.bsc : $(OBJD)\sleep5.obj
    bscmake /v /n /o $@ $(OBJD)\sleep5.sbr

##############################################################################

clean:
    -del *~ 2>nul
    -del $(BIND)\simple_safe*.* 2>nul
    -del $(BIND)\sleep5.* 2>nul
    -rmdir /q /s $(OBJD) 2>nul

realclean: clean
    -rmdir /q /s $(OBJDS) 2>nul

############################################### Install non-bit-size binaries.

!IF "$(DETOURS_OPTION_PROCESSOR)" != ""

$(OPTD)\simple_safe$(DETOURS_OPTION_BITS).dll:
$(OPTD)\simple_safe$(DETOURS_OPTION_BITS).pdb:

$(BIND)\simple_safe$(DETOURS_OPTION_BITS).dll : $(OPTD)\simple_safe$(DETOURS_OPTION_BITS).dll
    @if exist $? copy /y $? $(BIND) >nul && echo $@ copied from $(DETOURS_OPTION_PROCESSOR).
$(BIND)\simple_safe$(DETOURS_OPTION_BITS).pdb : $(OPTD)\simple_safe$(DETOURS_OPTION_BITS).pdb
    @if exist $? copy /y $? $(BIND) >nul && echo $@ copied from $(DETOURS_OPTION_PROCESSOR).

option: \
    $(BIND)\simple_safe$(DETOURS_OPTION_BITS).dll \
    $(BIND)\simple_safe$(DETOURS_OPTION_BITS).pdb \

!ELSE

option:

!ENDIF

##############################################################################

test: all
    @echo -------- Reseting test binaries to initial state. ---------------------
    $(BIND)\setdll.exe -r $(BIND)\sleep5.exe
    @echo.
    @echo -------- Should not load simple_safe$(DETOURS_BITS).dll -----------------------------------
    $(BIND)\sleep5.exe
    @echo.
    @echo -------- Adding simple_safe$(DETOURS_BITS).dll to sleep5.exe ------------------------------
    $(BIND)\setdll.exe -d:$(BIND)\simple_safe$(DETOURS_BITS).dll $(BIND)\sleep5.exe
    @echo.
    @echo -------- Should load simple_safe$(DETOURS_BITS).dll statically ----------------------------
    $(BIND)\sleep5.exe
    @echo.
    @echo -------- Removing simple_safe$(DETOURS_BITS).dll from sleep5.exe --------------------------
    $(BIND)\setdll.exe -r $(BIND)\sleep5.exe
    @echo.
    @echo -------- Should not load simple_safe$(DETOURS_BITS).dll -----------------------------------
    $(BIND)\sleep5.exe
    @echo.
    @echo -------- Should load simple_safe$(DETOURS_BITS).dll dynamically using withdll.exe----------
    $(BIND)\withdll.exe -d:$(BIND)\simple_safe$(DETOURS_BITS).dll $(BIND)\sleep5.exe
    @echo.

debug: all
    windbg -o $(BIND)\withdll.exe -d:$(BIND)\simple_safe$(DETOURS_BITS).dll $(BIND)\sleep5.exe


################################################################# End of File.

```

`samples/simple_safe/simple_safe.cpp`:

```cpp
//////////////////////////////////////////////////////////////////////////////
//
//  Detours Test Program (simple_safe.cpp of simple_safe.dll)
//
//  Microsoft Research Detours Package
//
//  Copyright (c) Microsoft Corporation.  All rights reserved.
//
//  This DLL will detour the Windows SleepEx API so that TimedSleep function
//  gets called instead.  TimedSleepEx records the before and after times, and
//  calls the real SleepEx API through the TrueSleepEx function pointer.
//
//  The difference between simple and simple_safe is that simple_safe
//  uses the C++ 14 overloads which help prevent mismatching types.
//
#include <stdio.h>
#include <windows.h>
#include "detours.h"

static LONG dwSlept = 0;
static DWORD (WINAPI * TrueSleepEx)(DWORD dwMilliseconds, BOOL bAlertable) = SleepEx;

DWORD WINAPI TimedSleepEx(DWORD dwMilliseconds, BOOL bAlertable)
{
    DWORD dwBeg = GetTickCount();
    DWORD ret = TrueSleepEx(dwMilliseconds, bAlertable);
    DWORD dwEnd = GetTickCount();

    InterlockedExchangeAdd(&dwSlept, dwEnd - dwBeg);

    return ret;
}

BOOL WINAPI DllMain(HINSTANCE hinst, DWORD dwReason, LPVOID reserved)
{
    LONG error;
    (void)hinst;
    (void)reserved;

    if (DetourIsHelperProcess()) {
        return TRUE;
    }

    if (dwReason == DLL_PROCESS_ATTACH) {
        DetourRestoreAfterWith();

        printf("simple_safe" DETOURS_STRINGIFY(DETOURS_BITS) ".dll:"
               " Starting.\n");
        fflush(stdout);

        DetourTransactionBegin();
        DetourUpdateThread(GetCurrentThread());
        DetourAttach(&TrueSleepEx, TimedSleepEx);
        error = DetourTransactionCommit();

        if (error == NO_ERROR) {
            printf("simple_safe" DETOURS_STRINGIFY(DETOURS_BITS) ".dll:"
                   " Detoured SleepEx().\n");
        }
        else {
            printf("simple_safe" DETOURS_STRINGIFY(DETOURS_BITS) ".dll:"
                   " Error detouring SleepEx(): %ld\n", error);
        }
    }
    else if (dwReason == DLL_PROCESS_DETACH) {
        DetourTransactionBegin();
        DetourUpdateThread(GetCurrentThread());
        DetourDetach(&TrueSleepEx, TimedSleepEx);
        error = DetourTransactionCommit();

        printf("simple_safe" DETOURS_STRINGIFY(DETOURS_BITS) ".dll:"
               " Removed SleepEx() (result=%ld), slept %ld ticks.\n", error, dwSlept);
        fflush(stdout);
    }
    return TRUE;
}

//
///////////////////////////////////////////////////////////////// End of File.

```

`samples/simple_safe/simple_safe.rc`:

```rc
//////////////////////////////////////////////////////////////////////////////
//
//  Version information for simple_safe.rc.
//
//  Microsoft Research Detours Package
//
//  Copyright (c) Microsoft Corporation.  All rights reserved.
//

#include "detver.h"

#define VER_INTERNALNAME_STR        "simple_safe" DETOURS_STRINGIFY(DETOURS_BITS)
#define VER_ORIGINALFILENAME_STR    "simple_safe" DETOURS_STRINGIFY(DETOURS_BITS) ".dll"
#define VER_FILEDESCRIPTION_STR     "Detours Test Module"
#define VER_COMPANYNAME_STR         "Microsoft Corporation"

#include "common.ver"

```

`samples/simple_safe/sleep5.cpp`:

```cpp
//////////////////////////////////////////////////////////////////////////////
//
//  Detours Test Program (sleep5.cpp of sleep5.exe)
//
//  Microsoft Research Detours Package
//
//  Copyright (c) Microsoft Corporation.  All rights reserved.
//

#include <windows.h>
#include <stdio.h>
#include <stdlib.h>

int __cdecl main(int argc, char ** argv)
{
    if (argc == 2) {
        Sleep(atoi(argv[1]) * 1000);
    }
    else {
        printf("sleep5.exe: Starting.\n");

        Sleep(5000);

        printf("sleep5.exe: Done sleeping.\n");
    }
    return 0;
}
//
///////////////////////////////////////////////////////////////// End of File.

```

`samples/slept/Makefile`:

```
##############################################################################
##
##  API Extension to Measure time slept.
##
##  Microsoft Research Detours Package
##
##  Copyright (c) Microsoft Corporation.  All rights reserved.
##

!include ..\common.mak

CFLAGS = $(CFLAGS:/Od=/O2)

LIBS=$(LIBS) kernel32.lib

##############################################################################

all: dirs \
    $(BIND)\slept$(DETOURS_BITS).dll \
    $(BIND)\dslept$(DETOURS_BITS).dll \
    $(BIND)\sleepold.exe \
    $(BIND)\sleepnew.exe \
    $(BIND)\sleepbed.exe \
    \
!IF $(DETOURS_SOURCE_BROWSING)==1
    $(OBJD)\slept$(DETOURS_BITS).bsc \
    $(OBJD)\dslept$(DETOURS_BITS).bsc \
    $(OBJD)\sleepold.bsc \
    $(OBJD)\sleepnew.bsc \
    $(OBJD)\sleepbed.bsc \
!ENDIF
    option

##############################################################################

dirs:
    @if not exist $(BIND) mkdir $(BIND) && echo.   Created $(BIND)
    @if not exist $(OBJD) mkdir $(OBJD) && echo.   Created $(OBJD)

$(OBJD)\slept.obj : slept.cpp verify.cpp

$(OBJD)\slept.res : slept.rc

$(BIND)\slept$(DETOURS_BITS).dll $(BIND)\slept$(DETOURS_BITS).lib: \
        $(OBJD)\slept.obj $(OBJD)\slept.res $(DEPS)
    cl /LD $(CFLAGS) /Fe$(@R).dll /Fd$(@R).pdb \
        $(OBJD)\slept.obj $(OBJD)\slept.res\
        /link $(LINKFLAGS) /subsystem:console \
        /export:DetourFinishHelperProcess,@1,NONAME \
        /export:TimedSleepEx \
        /export:UntimedSleepEx \
        /export:GetSleptTicks \
        /export:TestTicks \
        /export:TestTicksEx \
        $(LIBS)

$(OBJD)\slept$(DETOURS_BITS).bsc : $(OBJD)\slept.obj
    bscmake /v /n /o $@ $(OBJD)\slept.sbr

$(OBJD)\dslept.obj : dslept.cpp verify.cpp

$(OBJD)\dslept.res : dslept.rc

$(BIND)\dslept$(DETOURS_BITS).dll $(BIND)\dslept$(DETOURS_BITS).lib: \
        $(OBJD)\dslept.obj $(OBJD)\dslept.res $(DEPS)
    cl /LD $(CFLAGS) /Fe$(@R).dll /Fd$(@R).pdb \
        $(OBJD)\dslept.obj $(OBJD)\dslept.res \
        /link $(LINKFLAGS) /subsystem:console \
        /export:DetourFinishHelperProcess,@1,NONAME \
        /export:TimedSleepEx \
        /export:UntimedSleepEx \
        /export:GetSleptTicks \
        $(LIBS)

$(OBJD)\dslept$(DETOURS_BITS).bsc : $(OBJD)\dslept.obj
    bscmake /v /n /o $@ $(OBJD)\dslept.sbr

$(OBJD)\sleepold.obj : sleepold.cpp verify.cpp

$(BIND)\sleepold.exe : $(OBJD)\sleepold.obj $(DEPS)
    cl $(CFLAGS) /Fe$@ /Fd$(@R).pdb $(OBJD)\sleepold.obj \
        /link $(LINKFLAGS) $(LIBS) \
        /subsystem:console /fixed:no

$(OBJD)\sleepold.bsc : $(OBJD)\sleepold.obj
    bscmake /v /n /o $@ $(OBJD)\sleepold.sbr

$(OBJD)\sleepnew.obj : sleepnew.cpp verify.cpp

$(BIND)\sleepnew.exe : $(OBJD)\sleepnew.obj $(BIND)\slept$(DETOURS_BITS).lib $(DEPS)
    cl $(CFLAGS) /Fe$@ /Fd$(@R).pdb $(OBJD)\sleepnew.obj \
        /link $(LINKFLAGS) $(LIBS) \
        /subsystem:console /fixed:no $(BIND)\slept$(DETOURS_BITS).lib

$(OBJD)\sleepnew.bsc : $(OBJD)\sleepnew.obj
    bscmake /v /n /o $@ $(OBJD)\sleepnew.sbr

$(OBJD)\sleepbed.obj : sleepbed.cpp verify.cpp

$(BIND)\sleepbed.exe : $(OBJD)\sleepbed.obj $(DEPS)
    cl $(CFLAGS) /Fe$@ /Fd$(@R).pdb $(OBJD)\sleepbed.obj \
        /link $(LINKFLAGS) $(LIBS) \
        /subsystem:console /fixed:no

$(OBJD)\sleepbed.bsc : $(OBJD)\sleepbed.obj
    bscmake /v /n /o $@ $(OBJD)\sleepbed.sbr

##############################################################################

clean:
    -del *~ 2>nul
    -del $(BIND)\slept*.* 2>nul
    -del $(BIND)\dslept*.* 2>nul
    -del $(BIND)\sleepold.* 2>nul
    -del $(BIND)\sleepnew.* 2>nul
    -del $(BIND)\sleepbed.* 2>nul
    -rmdir /q /s $(OBJD) 2>nul

realclean: clean
    -rmdir /q /s $(OBJDS) 2>nul

############################################### Install non-bit-size binaries.

!IF "$(DETOURS_OPTION_PROCESSOR)" != ""

$(OPTD)\slept$(DETOURS_OPTION_BITS).dll:
$(OPTD)\slept$(DETOURS_OPTION_BITS).pdb:
$(OPTD)\dslept$(DETOURS_OPTION_BITS).dll:
$(OPTD)\dslept$(DETOURS_OPTION_BITS).pdb:

$(BIND)\slept$(DETOURS_OPTION_BITS).dll: $(OPTD)\slept$(DETOURS_OPTION_BITS).dll
    @if exist $? copy /y $? $(BIND) >nul && echo $@ copied from $(DETOURS_OPTION_PROCESSOR).
$(BIND)\slept$(DETOURS_OPTION_BITS).pdb: $(OPTD)\slept$(DETOURS_OPTION_BITS).pdb
    @if exist $? copy /y $? $(BIND) >nul && echo $@ copied from $(DETOURS_OPTION_PROCESSOR).
$(BIND)\dslept$(DETOURS_OPTION_BITS).dll: $(OPTD)\dslept$(DETOURS_OPTION_BITS).dll
    @if exist $? copy /y $? $(BIND) >nul && echo $@ copied from $(DETOURS_OPTION_PROCESSOR).
$(BIND)\dslept$(DETOURS_OPTION_BITS).pdb: $(OPTD)\dslept$(DETOURS_OPTION_BITS).pdb
    @if exist $? copy /y $? $(BIND) >nul && echo $@ copied from $(DETOURS_OPTION_PROCESSOR).

option: \
    $(BIND)\slept$(DETOURS_OPTION_BITS).dll \
    $(BIND)\slept$(DETOURS_OPTION_BITS).pdb \
    $(BIND)\dslept$(DETOURS_OPTION_BITS).dll \
    $(BIND)\dslept$(DETOURS_OPTION_BITS).pdb \

!ELSE

option:

!ENDIF

##############################################################################

skype: all
    start windbg -G -o $(BIND)\withdll.exe -d:$(BIND)\slept$(DETOURS_BITS).dll "C:\Program Files (x86)\Skype\Phone\Skype.exe"

test: all
    @echo -------- Reseting test binaries to initial state. -----------------------
    $(BIND)\setdll.exe -r $(BIND)\sleepold.exe
    @echo.
    @echo -------- Should load detour self ----------------------------------------
    $(BIND)\sleepbed.exe
    @echo.
    @echo -------- Should load slept$(DETOURS_BITS).dll statically -------------------------------
    $(BIND)\sleepnew.exe
    @echo.
    @echo -------- Should not load slept$(DETOURS_BITS).dll --------------------------------------
    $(BIND)\sleepold.exe
    @echo.
    @echo -------- Adding slept$(DETOURS_BITS).dll to sleepold.exe -------------------------------
    $(BIND)\setdll.exe -d:$(BIND)\slept$(DETOURS_BITS).dll $(BIND)\sleepold.exe
    @echo.
    @echo -------- Should load slept$(DETOURS_BITS).dll statically -------------------------------
    $(BIND)\sleepold.exe
    @echo.
    @echo -------- Replacing slept$(DETOURS_BITS).dll with dslept$(DETOURS_BITS).dll in sleepold.exe ------------
    $(BIND)\setdll.exe -r $(BIND)\sleepold.exe
    $(BIND)\setdll.exe -d:$(BIND)\dslept$(DETOURS_BITS).dll $(BIND)\sleepold.exe
    @echo.
    @echo -------- Should load dslept$(DETOURS_BITS).dll instead of slept$(DETOURS_BITS).dll --------------------
    $(BIND)\sleepold.exe
    @echo.
    @echo -------- Removing dslept$(DETOURS_BITS).dll from sleepold.exe --------------------------
    $(BIND)\setdll.exe -r $(BIND)\sleepold.exe
    @echo.
    @echo -------- Should not load dslept$(DETOURS_BITS).dll or slept$(DETOURS_BITS).dll ------------------------
    $(BIND)\sleepold.exe
    @echo.
    @echo -------- Should load slept$(DETOURS_BITS).dll dynamically using withdll.exe ------------
    $(BIND)\withdll.exe -d:$(BIND)\slept$(DETOURS_BITS).dll $(BIND)\sleepold.exe
    @echo.
    @echo -------- Test completed. ------------------------------------------------

################################################################# End of File.

```

`samples/slept/NORMAL_IA64.TXT`:

```TXT
-------- Reseting test binaries to initial state. -----------------------
    ..\..\bin.IA64\setdll.exe -r ..\..\bin.IA64\sleepold.exe
Removing extra DLLs from binary files.
  ..\..\bin.IA64\sleepold.exe:
    KERNEL32.dll -> KERNEL32.dll

-------- Should load detour self ----------------------------------------
    ..\..\bin.IA64\sleepbed.exe
sleepbed.exe: Starting.
sleepbed.exe: ExeEntry=000000013F702DD0, DllEntry=0000000000000000
  SleepEx = 0000000077898980 [0000000077845300]
    0000000077898980: 08181d0a 80054002 04004240 0400c400
    0000000077898990: 11300142 00215002 80004200 00000020
    00000000778989A0: 13000000 01000000 00001000 80a50050

sleepbed.exe: Detoured SleepEx().
sleepbed.exe: After detour.
  SleepEx = 0000000077898980 [0000000077845300]
    0000000077898980: 05000000 0100bfff ffff7f00 b879ffc8  [0000000037890330]
    0000000077898990: 11300142 00215002 80004200 00000020
    00000000778989A0: 13000000 01000000 00001000 80a50050

sleepbed.exe: Calling Sleep for 1 second.
sleepbed.exe: Calling SleepEx for 1 second.
sleepbed.exe: Calling Sleep again for 1 second.
sleepbed.exe: Calling TimedSleepEx for 1 second.
sleepbed.exe: Calling UntimedSleepEx for 1 second.
sleepbed.exe: Done sleeping.

sleepbed.exe: Removed SleepEx() detour (0), slept 2000 ticks.
sleepbed.exe: GetSleptTicks() = 2000


-------- Should load slept64.dll statically -------------------------------
    ..\..\bin.IA64\sleepnew.exe
slept64.dll:  Starting.
slept64.dll:  ExeEntry=000000013F18CA50, DllEntry=000006FAEE9F6D80
  SleepEx = 0000000077898980 [0000000077845300]
    0000000077898980: 08181d0a 80054002 04004240 0400c400
    0000000077898990: 11300142 00215002 80004200 00000020
    00000000778989A0: 13000000 01000000 00001000 80a50050

sleepnew.exe: Starting.
  SleepEx = 0000000077898980 [0000000077845300]
    0000000077898980: 05000000 0100bfff ffff7f00 b879ffc8  [0000000037890330]
    0000000077898990: 11300142 00215002 80004200 00000020
    00000000778989A0: 13000000 01000000 00001000 80a50050

sleepnew.exe: Calling Sleep for 1 second.
sleepnew.exe: Calling SleepEx for 1 second.
sleepnew.exe: Calling Sleep again for 1 second.
sleepnew.exe: Calling TimedSleep for 1 second.
sleepnew.exe: Calling UntimedSleep for 1 second.
sleepnew.exe: Done sleeping.

sleepnew.exe: GetSleptTicks() = 2000

slept64.dll:  Detoured SleepEx().
slept64.dll:  Removed SleepEx() detour (0), slept 2000 ticks.

-------- Should not load slept64.dll --------------------------------------
    ..\..\bin.IA64\sleepold.exe
sleepold.exe: Starting (at 000000013F80C288).
  SleepEx = 0000000077898980 [0000000077845300]
    0000000077898980: 08181d0a 80054002 04004240 0400c400
    0000000077898990: 11300142 00215002 80004200 00000020
    00000000778989A0: 13000000 01000000 00001000 80a50050

sleepold.exe: Calling Sleep for 1 second.
sleepold.exe: Calling SleepEx for 1 second.
sleepold.exe: Calling Sleep again for 1 second.
sleepold.exe: Done sleeping.


-------- Adding slept64.dll to sleepold.exe -------------------------------
    ..\..\bin.IA64\setdll.exe -d:..\..\bin.IA64\slept64.dll ..\..\bin.IA64\sleepold.exe
Adding c:\Code\Detours\bin.IA64\slept64.dll to binary files.
  ..\..\bin.IA64\sleepold.exe:
    c:\Code\Detours\bin.IA64\slept64.dll
    KERNEL32.dll -> KERNEL32.dll

-------- Should load slept64.dll statically -------------------------------
    ..\..\bin.IA64\sleepold.exe
slept64.dll:  Starting.
slept64.dll:  ExeEntry=000000013F4FCAB0, DllEntry=000006FAEE9F6D80
  SleepEx = 0000000077898980 [0000000077845300]
    0000000077898980: 08181d0a 80054002 04004240 0400c400
    0000000077898990: 11300142 00215002 80004200 00000020
    00000000778989A0: 13000000 01000000 00001000 80a50050

sleepold.exe: Starting (at 000000013F4FC288).
  SleepEx = 0000000077898980 [0000000077845300]
    0000000077898980: 05000000 0100bfff ffff7f00 b879ffc8  [0000000037890330]
    0000000077898990: 11300142 00215002 80004200 00000020
    00000000778989A0: 13000000 01000000 00001000 80a50050

sleepold.exe: Calling Sleep for 1 second.
sleepold.exe: Calling SleepEx for 1 second.
sleepold.exe: Calling Sleep again for 1 second.
sleepold.exe: Done sleeping.

slept64.dll:  Detoured SleepEx().
slept64.dll:  Removed SleepEx() detour (0), slept 1000 ticks.

-------- Replacing slept64.dll with dslept64.dll in sleepold.exe ------------
    ..\..\bin.IA64\setdll.exe -r ..\..\bin.IA64\sleepold.exe
Removing extra DLLs from binary files.
  ..\..\bin.IA64\sleepold.exe:
    KERNEL32.dll -> KERNEL32.dll
    ..\..\bin.IA64\setdll.exe -d:..\..\bin.IA64\dslept64.dll ..\..\bin.IA64\sleepold.exe
Adding c:\Code\Detours\bin.IA64\dslept64.dll to binary files.
  ..\..\bin.IA64\sleepold.exe:
    c:\Code\Detours\bin.IA64\dslept64.dll
    KERNEL32.dll -> KERNEL32.dll

-------- Should load dslept64.dll instead of slept64.dll --------------------
    ..\..\bin.IA64\sleepold.exe
dslept64.dll:  Starting.
  SleepEx = 0000000077898980 [0000000077845300]
    0000000077898980: 08181d0a 80054002 04004240 0400c400
    0000000077898990: 11300142 00215002 80004200 00000020
    00000000778989A0: 13000000 01000000 00001000 80a50050

  EntryPoint = 000000013F12D580 [000000013F16CAB0]
    000000013F12D580: 01080d06 80050002 00620040 04080084
    000000013F12D590: 13000000 01000000 00001000 90eb0050
    000000013F12D5A0: 13080044 00210000 00001000 c0fcff58
  EntryPoint after attach = 000000013F12D580 [000000013F16CAB0]
    000000013F12D580: 05000000 0100bfff ffff7f00 b82dffc8  [00000000FF120330]
    000000013F12D590: 13000000 01000000 00001000 90eb0050
    000000013F12D5A0: 13080044 00210000 00001000 c0fcff58
  EntryPoint trampoline = 00000000FF120300 [00000000FF1203B0]
    00000000FF120300: 05000000 01003f01 00000020 00f00267
    00000000FF120310: 01080d06 80050002 00620040 04080084
    00000000FF120320: 05000000 01004000 00000000 78d200c0  [000000013F12D590]
dslept64.dll:  Detoured EntryPoint().
dslept64.dll:  Detoured SleepEx().
  SleepEx = 0000000077898980 [0000000077845300]
    0000000077898980: 05000000 0100bfff ffff7f00 b879ffc8  [0000000037890330]
    0000000077898990: 11300142 00215002 80004200 00000020
    00000000778989A0: 13000000 01000000 00001000 80a50050

dslept64.dll:  Calling EntryPoint
sleepold.exe: Starting (at 000000013F16C288).
  SleepEx = 0000000077898980 [0000000077845300]
    0000000077898980: 05000000 0100bfff ffff7f00 b879ffc8  [0000000037890330]
    0000000077898990: 11300142 00215002 80004200 00000020
    00000000778989A0: 13000000 01000000 00001000 80a50050

sleepold.exe: Calling Sleep for 1 second.
sleepold.exe: Calling SleepEx for 1 second.
sleepold.exe: Calling Sleep again for 1 second.
sleepold.exe: Done sleeping.

dslept64.dll:  Removed Sleep() detours (0), slept 1000 ticks.

-------- Removing dslept64.dll from sleepold.exe --------------------------
    ..\..\bin.IA64\setdll.exe -r ..\..\bin.IA64\sleepold.exe
Removing extra DLLs from binary files.
  ..\..\bin.IA64\sleepold.exe:
    KERNEL32.dll -> KERNEL32.dll

-------- Should not load dslept64.dll or slept64.dll ------------------------
    ..\..\bin.IA64\sleepold.exe
sleepold.exe: Starting (at 000000013FCEC288).
  SleepEx = 0000000077898980 [0000000077845300]
    0000000077898980: 08181d0a 80054002 04004240 0400c400
    0000000077898990: 11300142 00215002 80004200 00000020
    00000000778989A0: 13000000 01000000 00001000 80a50050

sleepold.exe: Calling Sleep for 1 second.
sleepold.exe: Calling SleepEx for 1 second.
sleepold.exe: Calling Sleep again for 1 second.
sleepold.exe: Done sleeping.


-------- Should load slept64.dll dynamically using withdll.exe ------------
    ..\..\bin.IA64\withdll.exe -d:..\..\bin.IA64\slept64.dll ..\..\bin.IA64\sleepold.exe
withdll.exe: Starting: `..\..\bin.IA64\sleepold.exe'
withdll.exe:   with `c:\Code\Detours\bin.IA64\slept64.dll'
slept64.dll:  Starting.
slept64.dll:  ExeEntry=000000013FBFCAB0, DllEntry=000006FAEE9F6D80
  SleepEx = 0000000077898980 [0000000077845300]
    0000000077898980: 08181d0a 80054002 04004240 0400c400
    0000000077898990: 11300142 00215002 80004200 00000020
    00000000778989A0: 13000000 01000000 00001000 80a50050

sleepold.exe: Starting (at 000000013FBFC288).
  SleepEx = 0000000077898980 [0000000077845300]
    0000000077898980: 05000000 0100bfff ffff7f00 b879ffc8  [0000000037890330]
    0000000077898990: 11300142 00215002 80004200 00000020
    00000000778989A0: 13000000 01000000 00001000 80a50050

sleepold.exe: Calling Sleep for 1 second.
sleepold.exe: Calling SleepEx for 1 second.
sleepold.exe: Calling Sleep again for 1 second.
sleepold.exe: Done sleeping.

slept64.dll:  Detoured SleepEx().
slept64.dll:  Removed SleepEx() detour (0), slept 1030 ticks.

-------- Test completed. ------------------------------------------------

```

`samples/slept/NORMAL_X64.TXT`:

```TXT
-------- Reseting test binaries to initial state. -----------------------
    ..\..\bin.X64\setdll.exe -r ..\..\bin.X64\sleepold.exe
Removing extra DLLs from binary files.
  ..\..\bin.X64\sleepold.exe:
    KERNEL32.dll -> KERNEL32.dll

-------- Should load detour self ----------------------------------------
    ..\..\bin.X64\sleepbed.exe
sleepbed.exe: Starting.
sleepbed.exe: ExeEntry=000000013FE863E0, DllEntry=000000013FE9E610
  SleepEx = 000007FEFD541150 [0000000076912B60]
    000007FEFD541150: 4c8bdc
    000007FEFD541153: 49895b08
    000007FEFD541157: 89542410

sleepbed.exe: Detoured SleepEx().
sleepbed.exe: After detour.
  SleepEx = 000007FEFD541150 [0000000076912B60]
    000007FEFD541150: e923f0ff bf                          [000007FEBD540178]
    000007FEFD541155: cc                                   [FFFFFFFFFFFFFFFF]
    000007FEFD541156: cc                                   [FFFFFFFFFFFFFFFF]

sleepbed.exe: Calling Sleep for 1 second.
sleepbed.exe: Calling SleepEx for 1 second.
sleepbed.exe: Calling Sleep again for 1 second.
sleepbed.exe: Calling TimedSleepEx for 1 second.
sleepbed.exe: Calling UntimedSleepEx for 1 second.
sleepbed.exe: Done sleeping.

sleepbed.exe: Removed SleepEx() detour (0), slept 4056 ticks.
sleepbed.exe: GetSleptTicks() = 4056


-------- Should load slept64.dll statically -------------------------------
    ..\..\bin.X64\sleepnew.exe
slept64.dll:  Starting.
slept64.dll:  ExeEntry=000000013F56484C, DllEntry=000007FEF2E78B74
  SleepEx = 000007FEFD541150 [0000000076912B60]
    000007FEFD541150: 4c8bdc
    000007FEFD541153: 49895b08
    000007FEFD541157: 89542410

sleepnew.exe: Starting.
  SleepEx = 000007FEFD541150 [0000000076912B60]
    000007FEFD541150: e923f0ff bf                          [000007FEBD540178]
    000007FEFD541155: cc                                   [FFFFFFFFFFFFFFFF]
    000007FEFD541156: cc                                   [FFFFFFFFFFFFFFFF]

sleepnew.exe: Calling Sleep for 1 second.
sleepnew.exe: Calling SleepEx for 1 second.
sleepnew.exe: Calling Sleep again for 1 second.
sleepnew.exe: Calling TimedSleep for 1 second.
sleepnew.exe: Calling UntimedSleep for 1 second.
sleepnew.exe: Done sleeping.

sleepnew.exe: GetSleptTicks() = 4056

slept64.dll:  Detoured SleepEx().
slept64.dll:  Removed SleepEx() detour (0), slept 4056 ticks.

-------- Should not load slept64.dll --------------------------------------
    ..\..\bin.X64\sleepold.exe
sleepold.exe: Starting (at 000000013FEF1350).
  SleepEx = 000007FEFD541150 [0000000076912B60]
    000007FEFD541150: 4c8bdc
    000007FEFD541153: 49895b08
    000007FEFD541157: 89542410

sleepold.exe: Calling Sleep for 1 second.
sleepold.exe: Calling SleepEx for 1 second.
sleepold.exe: Calling Sleep again for 1 second.
sleepold.exe: Done sleeping.


-------- Adding slept64.dll to sleepold.exe -------------------------------
    ..\..\bin.X64\setdll.exe -d:..\..\bin.X64\slept64.dll ..\..\bin.X64\sleepold.exe
Adding c:\Code\detours\bin.X64\slept64.dll to binary files.
  ..\..\bin.X64\sleepold.exe:
    c:\Code\detours\bin.X64\slept64.dll
    KERNEL32.dll -> KERNEL32.dll

-------- Should load slept64.dll statically -------------------------------
    ..\..\bin.X64\sleepold.exe
slept64.dll:  Starting.
slept64.dll:  ExeEntry=000000013F554ADC, DllEntry=000007FEF2E78B74
  SleepEx = 000007FEFD541150 [0000000076912B60]
    000007FEFD541150: 4c8bdc
    000007FEFD541153: 49895b08
    000007FEFD541157: 89542410

sleepold.exe: Starting (at 000000013F551350).
  SleepEx = 000007FEFD541150 [0000000076912B60]
    000007FEFD541150: e923f0ff bf                          [000007FEBD540178]
    000007FEFD541155: cc                                   [FFFFFFFFFFFFFFFF]
    000007FEFD541156: cc                                   [FFFFFFFFFFFFFFFF]

sleepold.exe: Calling Sleep for 1 second.
sleepold.exe: Calling SleepEx for 1 second.
sleepold.exe: Calling Sleep again for 1 second.
sleepold.exe: Done sleeping.

slept64.dll:  Detoured SleepEx().
slept64.dll:  Removed SleepEx() detour (0), slept 3042 ticks.

-------- Replacing slept64.dll with dslept64.dll in sleepold.exe ------------
    ..\..\bin.X64\setdll.exe -r ..\..\bin.X64\sleepold.exe
Removing extra DLLs from binary files.
  ..\..\bin.X64\sleepold.exe:
    KERNEL32.dll -> KERNEL32.dll
    ..\..\bin.X64\setdll.exe -d:..\..\bin.X64\dslept64.dll ..\..\bin.X64\sleepold.exe
Adding c:\Code\detours\bin.X64\dslept64.dll to binary files.
  ..\..\bin.X64\sleepold.exe:
    c:\Code\detours\bin.X64\dslept64.dll
    KERNEL32.dll -> KERNEL32.dll

-------- Should load dslept64.dll instead of slept64.dll --------------------
    ..\..\bin.X64\sleepold.exe
dslept64.dll:  Starting.
  SleepEx = 000007FEFD541150 [0000000076912B60]
    000007FEFD541150: 4c8bdc
    000007FEFD541153: 49895b08
    000007FEFD541157: 89542410

  EntryPoint = 000000013FB24ADC
    000000013FB24ADC: 4883ec28
    000000013FB24AE0: e8875f00 00                          [000000013FB2AA6C]
    000000013FB24AE5: 4883c428
  EntryPoint after attach = 000000013FB24ADC
    000000013FB24ADC: e997b6ff bf                          [00000000FFB20178]
    000000013FB24AE1: cc                                   [FFFFFFFFFFFFFFFF]
    000000013FB24AE2: cc                                   [FFFFFFFFFFFFFFFF]
  EntryPoint trampoline = 00000000FFB20120
    00000000FFB20120: 4883ec28
    00000000FFB20124: e843a900 40                          [000000013FB2AA6C]
    00000000FFB20129: ff253900 0000
dslept64.dll:  Detoured EntryPoint().
dslept64.dll:  Detoured SleepEx().
  SleepEx = 000007FEFD541150 [0000000076912B60]
    000007FEFD541150: e923f0ff bf                          [000007FEBD540178]
    000007FEFD541155: cc                                   [FFFFFFFFFFFFFFFF]
    000007FEFD541156: cc                                   [FFFFFFFFFFFFFFFF]

dslept64.dll:  Calling EntryPoint
sleepold.exe: Starting (at 000000013FB21350).
  SleepEx = 000007FEFD541150 [0000000076912B60]
    000007FEFD541150: e923f0ff bf                          [000007FEBD540178]
    000007FEFD541155: cc                                   [FFFFFFFFFFFFFFFF]
    000007FEFD541156: cc                                   [FFFFFFFFFFFFFFFF]

sleepold.exe: Calling Sleep for 1 second.
sleepold.exe: Calling SleepEx for 1 second.
sleepold.exe: Calling Sleep again for 1 second.
sleepold.exe: Done sleeping.

dslept64.dll:  Removed Sleep() detours (0), slept 3042 ticks.

-------- Removing dslept64.dll from sleepold.exe --------------------------
    ..\..\bin.X64\setdll.exe -r ..\..\bin.X64\sleepold.exe
Removing extra DLLs from binary files.
  ..\..\bin.X64\sleepold.exe:
    KERNEL32.dll -> KERNEL32.dll

-------- Should not load dslept64.dll or slept64.dll ------------------------
    ..\..\bin.X64\sleepold.exe
sleepold.exe: Starting (at 000000013F551350).
  SleepEx = 000007FEFD541150 [0000000076912B60]
    000007FEFD541150: 4c8bdc
    000007FEFD541153: 49895b08
    000007FEFD541157: 89542410

sleepold.exe: Calling Sleep for 1 second.
sleepold.exe: Calling SleepEx for 1 second.
sleepold.exe: Calling Sleep again for 1 second.
sleepold.exe: Done sleeping.


-------- Should load slept64.dll dynamically using withdll.exe ------------
    ..\..\bin.X64\withdll.exe -d:..\..\bin.X64\slept64.dll ..\..\bin.X64\sleepold.exe
withdll.exe: Starting: `..\..\bin.X64\sleepold.exe'
withdll.exe:   with `c:\Code\detours\bin.X64\slept64.dll'
slept64.dll:  Starting.
slept64.dll:  ExeEntry=000000013FE84ADC, DllEntry=000007FEF3108B74
  SleepEx = 000007FEFD541150 [0000000076912B60]
    000007FEFD541150: 4c8bdc
    000007FEFD541153: 49895b08
    000007FEFD541157: 89542410

sleepold.exe: Starting (at 000000013FE81350).
  SleepEx = 000007FEFD541150 [0000000076912B60]
    000007FEFD541150: e923f0ff bf                          [000007FEBD540178]
    000007FEFD541155: cc                                   [FFFFFFFFFFFFFFFF]
    000007FEFD541156: cc                                   [FFFFFFFFFFFFFFFF]

sleepold.exe: Calling Sleep for 1 second.
sleepold.exe: Calling SleepEx for 1 second.
sleepold.exe: Calling Sleep again for 1 second.
sleepold.exe: Done sleeping.

slept64.dll:  Detoured SleepEx().
slept64.dll:  Removed SleepEx() detour (0), slept 3042 ticks.

-------- Test completed. ------------------------------------------------

```

`samples/slept/NORMAL_X86.TXT`:

```TXT
-------- Reseting test binaries to initial state. -----------------------
    ..\..\bin.X86\setdll.exe -r ..\..\bin.X86\sleepold.exe
Removing extra DLLs from binary files.
  ..\..\bin.X86\sleepold.exe:
    KERNEL32.dll -> KERNEL32.dll

-------- Should load detour self ----------------------------------------
    ..\..\bin.X86\sleepbed.exe
sleepbed.exe: Starting.
sleepbed.exe: ExeEntry=00B1572E, DllEntry=00000000
  SleepEx = 74F51215
    74F51215: 8bff
    74F51217: 55
    74F51218: 8bec

sleepbed.exe: Detoured SleepEx().
sleepbed.exe: After detour.
  SleepEx = 74F51215
    74F51215: e95600bc 8b                          [00B11270]
    74F5121A: 5d
    74F5121B: ebed                                 [74F5120A]

sleepbed.exe: Calling Sleep for 1 second.
sleepbed.exe: Calling SleepEx for 1 second.
sleepbed.exe: Calling Sleep again for 1 second.
sleepbed.exe: Calling TimedSleepEx for 1 second.
sleepbed.exe: Calling UntimedSleepEx for 1 second.
sleepbed.exe: Done sleeping.

sleepbed.exe: Removed SleepEx() detour (0), slept 2028 ticks.
sleepbed.exe: GetSleptTicks() = 2028


-------- Should load slept32.dll statically -------------------------------
    ..\..\bin.X86\sleepnew.exe
slept32.dll:  Starting.
slept32.dll:  ExeEntry=012D3B1A, DllEntry=7248702E
  SleepEx = 74F51215
    74F51215: 8bff
    74F51217: 55
    74F51218: 8bec

sleepnew.exe: Starting.
  SleepEx = 74F51215
    74F51215: e9560053 fd                          [72481270]
    74F5121A: 5d
    74F5121B: ebed                                 [74F5120A]

sleepnew.exe: Calling Sleep for 1 second.
sleepnew.exe: Calling SleepEx for 1 second.
sleepnew.exe: Calling Sleep again for 1 second.
sleepnew.exe: Calling TimedSleep for 1 second.
sleepnew.exe: Calling UntimedSleep for 1 second.
sleepnew.exe: Done sleeping.

sleepnew.exe: GetSleptTicks() = 2028

slept32.dll:  Detoured SleepEx().
slept32.dll:  Removed SleepEx() detour (0), slept 2028 ticks.

-------- Should not load slept32.dll --------------------------------------
    ..\..\bin.X86\sleepold.exe
sleepold.exe: Starting (at 00971260).
  SleepEx = 74F51215
    74F51215: 8bff
    74F51217: 55
    74F51218: 8bec

sleepold.exe: Calling Sleep for 1 second.
sleepold.exe: Calling SleepEx for 1 second.
sleepold.exe: Calling Sleep again for 1 second.
sleepold.exe: Done sleeping.


-------- Adding slept32.dll to sleepold.exe -------------------------------
    ..\..\bin.X86\setdll.exe -d:..\..\bin.X86\slept32.dll ..\..\bin.X86\sleepold.exe
Adding c:\Code\detours\bin.X86\slept32.dll to binary files.
  ..\..\bin.X86\sleepold.exe:
    c:\Code\detours\bin.X86\slept32.dll
    KERNEL32.dll -> KERNEL32.dll

-------- Should load slept32.dll statically -------------------------------
    ..\..\bin.X86\sleepold.exe
slept32.dll:  Starting.
slept32.dll:  ExeEntry=00AF3D4C, DllEntry=7248702E
  SleepEx = 74F51215
    74F51215: 8bff
    74F51217: 55
    74F51218: 8bec

sleepold.exe: Starting (at 00AF1260).
  SleepEx = 74F51215
    74F51215: e9560053 fd                          [72481270]
    74F5121A: 5d
    74F5121B: ebed                                 [74F5120A]

sleepold.exe: Calling Sleep for 1 second.
sleepold.exe: Calling SleepEx for 1 second.
sleepold.exe: Calling Sleep again for 1 second.
sleepold.exe: Done sleeping.

slept32.dll:  Detoured SleepEx().
slept32.dll:  Removed SleepEx() detour (0), slept 1014 ticks.

-------- Replacing slept32.dll with dslept32.dll in sleepold.exe ------------
    ..\..\bin.X86\setdll.exe -r ..\..\bin.X86\sleepold.exe
Removing extra DLLs from binary files.
  ..\..\bin.X86\sleepold.exe:
    KERNEL32.dll -> KERNEL32.dll
    ..\..\bin.X86\setdll.exe -d:..\..\bin.X86\dslept32.dll ..\..\bin.X86\sleepold.exe
Adding c:\Code\detours\bin.X86\dslept32.dll to binary files.
  ..\..\bin.X86\sleepold.exe:
    c:\Code\detours\bin.X86\dslept32.dll
    KERNEL32.dll -> KERNEL32.dll

-------- Should load dslept32.dll instead of slept32.dll --------------------
    ..\..\bin.X86\sleepold.exe
dslept32.dll:  Starting.
  SleepEx = 74F51215
    74F51215: 8bff
    74F51217: 55
    74F51218: 8bec

  EntryPoint = 00263D4C
    00263D4C: e8d75400 00                          [00269228]
    00263D51: e995feff ff                          [00263BEB]
    00263D56: 3b0d8412 2800
  EntryPoint after attach = 00263D4C
    00263D4C: e96fd502 72                          [722912C0]
    00263D51: e995feff ff                          [00263BEB]
    00263D56: 3b0d8412 2800
  EntryPoint trampoline = 402500D8
    402500D8: e84b9101 c0                          [00269228]
    402500DD: e96f3c01 c0                          [00263D51]
    402500E2: cc                                   [FFFFFFFF]
dslept32.dll:  Detoured EntryPoint().
dslept32.dll:  Detoured SleepEx().
  SleepEx = 74F51215
    74F51215: e9560034 fd                          [72291270]
    74F5121A: 5d
    74F5121B: ebed                                 [74F5120A]

dslept32.dll:  Calling EntryPoint
sleepold.exe: Starting (at 00261260).
  SleepEx = 74F51215
    74F51215: e9560034 fd                          [72291270]
    74F5121A: 5d
    74F5121B: ebed                                 [74F5120A]

sleepold.exe: Calling Sleep for 1 second.
sleepold.exe: Calling SleepEx for 1 second.
sleepold.exe: Calling Sleep again for 1 second.
sleepold.exe: Done sleeping.

dslept32.dll:  Removed Sleep() detours (0), slept 1014 ticks.

-------- Removing dslept32.dll from sleepold.exe --------------------------
    ..\..\bin.X86\setdll.exe -r ..\..\bin.X86\sleepold.exe
Removing extra DLLs from binary files.
  ..\..\bin.X86\sleepold.exe:
    KERNEL32.dll -> KERNEL32.dll

-------- Should not load dslept32.dll or slept32.dll ------------------------
    ..\..\bin.X86\sleepold.exe
sleepold.exe: Starting (at 00E01260).
  SleepEx = 74F51215
    74F51215: 8bff
    74F51217: 55
    74F51218: 8bec

sleepold.exe: Calling Sleep for 1 second.
sleepold.exe: Calling SleepEx for 1 second.
sleepold.exe: Calling Sleep again for 1 second.
sleepold.exe: Done sleeping.


-------- Should load slept32.dll dynamically using withdll.exe ------------
    ..\..\bin.X86\withdll.exe -d:..\..\bin.X86\slept32.dll ..\..\bin.X86\sleepold.exe
withdll.exe: Starting: `..\..\bin.X86\sleepold.exe'
withdll.exe:   with `c:\Code\detours\bin.X86\slept32.dll'
slept32.dll:  Starting.
slept32.dll:  ExeEntry=011A3D4C, DllEntry=7248702E
  SleepEx = 74F51215
    74F51215: 8bff
    74F51217: 55
    74F51218: 8bec

sleepold.exe: Starting (at 011A1260).
  SleepEx = 74F51215
    74F51215: e9560053 fd                          [72481270]
    74F5121A: 5d
    74F5121B: ebed                                 [74F5120A]

sleepold.exe: Calling Sleep for 1 second.
sleepold.exe: Calling SleepEx for 1 second.
sleepold.exe: Calling Sleep again for 1 second.
sleepold.exe: Done sleeping.

slept32.dll:  Detoured SleepEx().
slept32.dll:  Removed SleepEx() detour (0), slept 1014 ticks.

-------- Test completed. ------------------------------------------------

```

`samples/slept/dslept.cpp`:

```cpp
//////////////////////////////////////////////////////////////////////////////
//
//  Detour Test Program (dslept.cpp of dslept.dll)
//
//  Microsoft Research Detours Package
//
//  Copyright (c) Microsoft Corporation.  All rights reserved.
//
//  An example dynamically detouring a function.
//
#include <stdio.h>
#include <windows.h>
#include "detours.h"
#include "slept.h"

#include "verify.cpp"

LONG dwSlept = 0;

static DWORD (WINAPI * TrueSleepEx)(DWORD dwMilliseconds, BOOL bAlertable) = NULL;
static int (WINAPI * TrueEntryPoint)(VOID) = NULL;
static int (WINAPI * RawEntryPoint)(VOID) = NULL;

DWORD WINAPI UntimedSleepEx(DWORD dwMilliseconds, BOOL bAlertable)
{
    if (TrueSleepEx != NULL) {
        return TrueSleepEx(dwMilliseconds, bAlertable);
    }
    return 0;
}

DWORD WINAPI TimedSleepEx(DWORD dwMilliseconds, BOOL bAlertable)
{
    DWORD dwBeg = GetTickCount();
    DWORD ret = TrueSleepEx(dwMilliseconds, bAlertable);
    DWORD dwEnd = GetTickCount();

    InterlockedExchangeAdd(&dwSlept, dwEnd - dwBeg);
    return ret;
}

DWORD WINAPI GetSleptTicks(VOID)
{
    return dwSlept;
}

int WINAPI TimedEntryPoint(VOID)
{
    // We couldn't call LoadLibrary in DllMain,
    // so we detour SleepEx here...
    LONG error;

    TrueSleepEx = (DWORD (WINAPI *)(DWORD, BOOL))
        DetourFindFunction("kernel32.dll", "SleepEx");

    DetourTransactionBegin();
    DetourUpdateThread(GetCurrentThread());
    DetourAttach(&(PVOID&)TrueSleepEx, TimedSleepEx);
    error = DetourTransactionCommit();

    if (error == NO_ERROR) {
        printf("dslept" DETOURS_STRINGIFY(DETOURS_BITS) ".dll: "
               " Detoured SleepEx().\n");

    }
    else {
        printf("dslept" DETOURS_STRINGIFY(DETOURS_BITS) ".dll: "
               " Error detouring SleepEx(): %ld\n", error);
    }

    Verify("SleepEx", (PVOID)SleepEx);
    printf("\n");
    fflush(stdout);

    printf("dslept" DETOURS_STRINGIFY(DETOURS_BITS) ".dll: "
           " Calling EntryPoint\n");
    fflush(stdout);

    return TrueEntryPoint();
}

BOOL WINAPI DllMain(HINSTANCE hinst, DWORD dwReason, LPVOID reserved)
{
    LONG error;
    (void)hinst;
    (void)reserved;

    if (DetourIsHelperProcess()) {
        return TRUE;
    }

    if (dwReason == DLL_PROCESS_ATTACH) {
        DetourRestoreAfterWith();

        printf("dslept" DETOURS_STRINGIFY(DETOURS_BITS) ".dll: "
               " Starting.\n");
        Verify("SleepEx", (PVOID)SleepEx);
        printf("\n");
        fflush(stdout);

        // NB: DllMain can't call LoadLibrary, so we hook the app entry point.
        TrueEntryPoint = (int (WINAPI *)(VOID))DetourGetEntryPoint(NULL);
        RawEntryPoint = TrueEntryPoint;

        Verify("EntryPoint", RawEntryPoint);

        DetourTransactionBegin();
        DetourUpdateThread(GetCurrentThread());
        DetourAttach(&(PVOID&)TrueEntryPoint, TimedEntryPoint);
        error = DetourTransactionCommit();

        Verify("EntryPoint after attach", RawEntryPoint);
        Verify("EntryPoint trampoline", TrueEntryPoint);

        if (error == NO_ERROR) {
            printf("dslept" DETOURS_STRINGIFY(DETOURS_BITS) ".dll: "
                   " Detoured EntryPoint().\n");
        }
        else {
            printf("dslept" DETOURS_STRINGIFY(DETOURS_BITS) ".dll: "
                   " Error detouring EntryPoint(): %ld\n", error);
        }
    }
    else if (dwReason == DLL_PROCESS_DETACH) {
        DetourTransactionBegin();
        DetourUpdateThread(GetCurrentThread());
        if (TrueSleepEx != NULL) {
            DetourDetach(&(PVOID&)TrueSleepEx, (PVOID)TimedSleepEx);
        }
        DetourDetach(&(PVOID&)TrueEntryPoint, TimedEntryPoint);
        error = DetourTransactionCommit();

        printf("dslept" DETOURS_STRINGIFY(DETOURS_BITS) ".dll: "
               " Removed Sleep() detours (%ld), slept %ld ticks.\n", error, dwSlept);

        fflush(stdout);
    }
    return TRUE;
}
//
///////////////////////////////////////////////////////////////// End of File.

```

`samples/slept/dslept.rc`:

```rc
//////////////////////////////////////////////////////////////////////////////
//
//  Version information for dslept.rc.
//
//  Microsoft Research Detours Package
//
//  Copyright (c) Microsoft Corporation.  All rights reserved.
//

#include "detver.h"

#define VER_INTERNALNAME_STR        "dslept" DETOURS_STRINGIFY(DETOURS_BITS)
#define VER_ORIGINALFILENAME_STR    "dslept" DETOURS_STRINGIFY(DETOURS_BITS) ".dll"
#define VER_FILEDESCRIPTION_STR     "Detours Sleep Interception Module"
#define VER_COMPANYNAME_STR         "Microsoft Corporation"

#include "common.ver"

```

`samples/slept/sleepbed.cpp`:

```cpp
//////////////////////////////////////////////////////////////////////////////
//
//  Detour Test Program (sleepbed.cpp of sleepbed.exe)
//
//  Microsoft Research Detours Package
//
//  Copyright (c) Microsoft Corporation.  All rights reserved.
//

#include <windows.h>
#include <stdio.h>

#include "verify.cpp"

static BOOL fBroke = FALSE;
static LONG dwSlept = 0;
static DWORD (WINAPI * TrueSleepEx)(DWORD dwMilliseconds, BOOL bAlertable)
    = SleepEx;

DWORD WINAPI UntimedSleepEx(DWORD dwMilliseconds, BOOL bAlertable)
{
    return TrueSleepEx(dwMilliseconds, bAlertable);
}

DWORD WINAPI TimedSleepEx(DWORD dwMilliseconds, BOOL bAlertable)
{
    DWORD dwBeg = GetTickCount();
    DWORD ret = TrueSleepEx(dwMilliseconds, bAlertable);
    DWORD dwEnd = GetTickCount();

    if (!fBroke) {
        fBroke = TRUE;
        // DebugBreak();
    }

    InterlockedExchangeAdd(&dwSlept, dwEnd - dwBeg);
    return ret;
}

DWORD WINAPI GetSleptTicks(VOID)
{
    return dwSlept;
}

//
///////////////////////////////////////////////////////////////// End of File.

int __cdecl main(void)
{
    int error = 0;

    printf("sleepbed.exe: Starting.\n");
    PVOID pbExeEntry = DetourGetEntryPoint(NULL);
    printf("sleepbed.exe: ExeEntry=%p\n", pbExeEntry);

    Verify("SleepEx", (PVOID)SleepEx);
    printf("\n");
    fflush(stdout);

    DetourTransactionBegin();
    DetourUpdateThread(GetCurrentThread());
    DetourAttach(&(PVOID&)TrueSleepEx, TimedSleepEx);
    error = DetourTransactionCommit();

    if (error == NO_ERROR) {
        printf("sleepbed.exe: Detoured SleepEx().\n");
    }
    else {
        printf("sleepbed.exe: Error detouring SleepEx(): %d\n", error);
        return error;
    }
    fflush(stdout);

    printf("sleepbed.exe: After detour.\n");
    Verify("SleepEx", (PBYTE)SleepEx);
    printf("\n");
    fflush(stdout);

    printf("sleepbed.exe: Calling Sleep for 1 second.\n");
    Sleep(1000);
    printf("sleepbed.exe: Calling SleepEx for 1 second.\n");
    SleepEx(1000, true);
    printf("sleepbed.exe: Calling Sleep again for 1 second.\n");
    Sleep(1000);
    printf("sleepbed.exe: Calling TimedSleepEx for 1 second.\n");
    TimedSleepEx(1000, false);
    printf("sleepbed.exe: Calling UntimedSleepEx for 1 second.\n");
    UntimedSleepEx(1000, false);
    printf("sleepbed.exe: Done sleeping.\n\n");

    DetourTransactionBegin();
    DetourUpdateThread(GetCurrentThread());
    DetourDetach(&(PVOID&)TrueSleepEx, TimedSleepEx);
    error = DetourTransactionCommit();
    printf("sleepbed.exe: Removed SleepEx() detour (%d), slept %ld ticks.\n",
           error, dwSlept);
    fflush(stdout);

    printf("sleepbed.exe: GetSleptTicks() = %ld\n\n", GetSleptTicks());
    return error;
}
//
///////////////////////////////////////////////////////////////// End of File.

```

`samples/slept/sleepnew.cpp`:

```cpp
//////////////////////////////////////////////////////////////////////////////
//
//  Detour Test Program (sleepnew.cpp of sleepnew.exe)
//
//  Microsoft Research Detours Package
//
//  Copyright (c) Microsoft Corporation.  All rights reserved.
//

#include <windows.h>
#include <stdio.h>
#include "slept.h"

#include "verify.cpp"

int __cdecl main(void)
{
    printf("sleepnew.exe: Starting.\n");
    Verify("SleepEx", (PBYTE)SleepEx);
    printf("\n");
    fflush(stdout);

    printf("sleepnew.exe: Calling Sleep for 1 second.\n");
    Sleep(1000);
    printf("sleepnew.exe: Calling SleepEx for 1 second.\n");
    SleepEx(1000, true);
    printf("sleepnew.exe: Calling Sleep again for 1 second.\n");
    Sleep(1000);
    printf("sleepnew.exe: Calling TimedSleep for 1 second.\n");
    TimedSleepEx(1000, FALSE);
    printf("sleepnew.exe: Calling UntimedSleep for 1 second.\n");
    UntimedSleepEx(1000, FALSE);
    printf("sleepnew.exe: Done sleeping.\n\n");

#if 0
    // This code enumerates the virtual address space and attempts to reserve
    // all unused space below 8GB.
    //
    for (PBYTE pbTry = (PBYTE)0x10000; pbTry < (PBYTE)0x200000000;) {
        MEMORY_BASIC_INFORMATION mbi;

        if (!VirtualQuery(pbTry, &mbi, sizeof(mbi))) {
            break;
        }

        if (mbi.State == MEM_FREE && mbi.RegionSize > 0x10000) {
            PBYTE pbBase = (PBYTE)((((ULONG_PTR)pbTry) + 0xffff) & 0xffffffffffff0000);
            SIZE_T cbTry = mbi.RegionSize & 0xffffffffffff0000;
            if (cbTry > 0x40000000) {
                cbTry = 0x40000000;
            }
            PVOID pvRegion = VirtualAlloc(pbBase, cbTry,
                                          MEM_RESERVE,
                                          PAGE_NOACCESS);
            if (pvRegion == NULL) {
                printf("---%p..%p failed.\n", pbBase, mbi.RegionSize - 0x10000);
            }
            else {
                continue;
            }
        }

        printf("   %p..%p %6x [%p]\n",
               mbi.BaseAddress, (PBYTE)mbi.BaseAddress + mbi.RegionSize - 1,
               mbi.State,
               pbTry);

        pbTry = (PBYTE)mbi.BaseAddress + mbi.RegionSize;
    }
#endif

    printf("sleepnew.exe: GetSleptTicks() = %ld\n\n", GetSleptTicks());
    return 0;
}
//
///////////////////////////////////////////////////////////////// End of File.

```

`samples/slept/sleepold.cpp`:

```cpp
//////////////////////////////////////////////////////////////////////////////
//
//  Detour Test Program (sleepold.cpp of sleepold.exe)
//
//  Microsoft Research Detours Package
//
//  Copyright (c) Microsoft Corporation.  All rights reserved.
//

#include <windows.h>
#include <stdio.h>

#include "verify.cpp"

int __cdecl main(int argc, char **argv)
{
    BOOL fQuiet = FALSE;

    if (argc == 2 && _stricmp(argv[1], "-quiet") == 0) {
        fQuiet = TRUE;
    }

    //
    // Verify what the code looks like.
    //
    printf("sleepold.exe: Starting (at %p).\n", main);
    if (!fQuiet) {
        Verify("SleepEx", (PBYTE)SleepEx);
        printf("\n");
    }
    fflush(stdout);

    //
    // See if another process wants us to wait on a shared event.
    // This helps in testing loading a DLL into a new process.

    if (argc == 2 && _stricmp(argv[1], "-wait") == 0) {
        HANDLE hEvent = OpenEventA(SYNCHRONIZE, FALSE, "detours_load_test_event");
        if (hEvent) {
            printf("sleepold.exe: Waiting for detours_load_test_event to be set.\n");
            fflush(stdout);
            WaitForSingleObject(hEvent, INFINITE);
        }
        else {
            printf("sleepold.exe: Couldn't open detours_load_test_event.\n");
        }
    }

    //
    // Try out sleep (which may be detours).
    //
    printf("sleepold.exe: Calling Sleep for 1 second.\n");
    Sleep(1000);

    printf("sleepold.exe: Calling SleepEx for 1 second.\n");
    SleepEx(1000, false);

    printf("sleepold.exe: Calling Sleep again for 1 second.\n");
    Sleep(1000);

    // DebugBreak();

    printf("sleepold.exe: Done sleeping.\n\n");
    fflush(stdout);

    return 0;
}
//
///////////////////////////////////////////////////////////////// End of File.

```

`samples/slept/slept.cpp`:

```cpp
//////////////////////////////////////////////////////////////////////////////
//
//  Detour Test Program (slept.cpp of slept.dll)
//
//  Microsoft Research Detours Package
//
//  Copyright (c) Microsoft Corporation.  All rights reserved.
//
#include <stdio.h>
#include <windows.h>
#include "detours.h"
#include "slept.h"

#include "verify.cpp"

static BOOL fBroke = FALSE;
static LONG dwSlept = 0;
static DWORD (WINAPI * TrueSleepEx)(DWORD dwMilliseconds, BOOL bAlertable) = SleepEx;

DWORD WINAPI UntimedSleepEx(DWORD dwMilliseconds, BOOL bAlertable)
{
    return TrueSleepEx(dwMilliseconds, bAlertable);
}

DWORD WINAPI TimedSleepEx(DWORD dwMilliseconds, BOOL bAlertable)
{
    DWORD dwBeg = GetTickCount();
    DWORD ret = TrueSleepEx(dwMilliseconds, bAlertable);
    DWORD dwEnd = GetTickCount();

    if (!fBroke) {
        fBroke = TRUE;
        // DebugBreak();
    }

    InterlockedExchangeAdd(&dwSlept, dwEnd - dwBeg);
    return ret;
}

DWORD WINAPI GetSleptTicks(VOID)
{
    return dwSlept;
}

DWORD WINAPI TestTicks(VOID)
{
    return TestTicksEx(0);
}

DWORD WINAPI TestTicksEx(DWORD Add)
{
    PDWORD pdw = new DWORD [Add + 1];

    if (pdw != NULL) {
        pdw[0] = dwSlept;
        for (DWORD n = 1; n < Add + 1; n++) {
            pdw[n] = pdw[n-1] + 1;
        }

        for (DWORD n = 1; n < Add + 1; n++) {
            pdw[n-1] = pdw[n-1] - 1;
        }

        for (DWORD n = 1; n < Add + 1; n++) {
            pdw[n] = pdw[n-1] + 1;
        }

        Add = pdw[Add] - Add;

        delete [] pdw;
    }
    else {
        Add = dwSlept + Add;
    }

    return Add;
}

BOOL WINAPI DllMain(HINSTANCE hinst, DWORD dwReason, LPVOID reserved)
{
    LONG error;
    (void)hinst;
    (void)reserved;

    if (DetourIsHelperProcess()) {
        return TRUE;
    }

    if (dwReason == DLL_PROCESS_ATTACH) {
        DetourRestoreAfterWith();

        printf("slept" DETOURS_STRINGIFY(DETOURS_BITS) ".dll: "
               " Starting.\n");
        PVOID pbExeEntry = DetourGetEntryPoint(NULL);
        PVOID pbDllEntry = DetourGetEntryPoint(hinst);
        printf("slept" DETOURS_STRINGIFY(DETOURS_BITS) ".dll: "
               " ExeEntry=%p, DllEntry=%p\n", pbExeEntry, pbDllEntry);

        Verify("SleepEx", (PVOID)SleepEx);
        printf("\n");
        fflush(stdout);

        DetourTransactionBegin();
        DetourUpdateThread(GetCurrentThread());
        DetourAttach(&(PVOID&)TrueSleepEx, TimedSleepEx);
        error = DetourTransactionCommit();

        if (error == NO_ERROR) {
            printf("slept" DETOURS_STRINGIFY(DETOURS_BITS) ".dll: "
                   " Detoured SleepEx() @ %p.\n", TrueSleepEx);
        }
        else {
            printf("slept" DETOURS_STRINGIFY(DETOURS_BITS) ".dll: "
                   " Error detouring SleepEx(): %ld\n", error);
        }
    }
    else if (dwReason == DLL_PROCESS_DETACH) {
        DetourTransactionBegin();
        DetourUpdateThread(GetCurrentThread());
        DetourDetach(&(PVOID&)TrueSleepEx, TimedSleepEx);
        error = DetourTransactionCommit();
        printf("slept" DETOURS_STRINGIFY(DETOURS_BITS) ".dll: "
               " Removed SleepEx() detour (%ld), slept %ld ticks.\n", error, dwSlept);
        fflush(stdout);
    }
    return TRUE;
}

//
///////////////////////////////////////////////////////////////// End of File.

```

`samples/slept/slept.h`:

```h
//////////////////////////////////////////////////////////////////////////////
//
//  Detour Test Program (slept.h of slept.dll)
//
//  Microsoft Research Detours Package
//
//  Copyright (c) Microsoft Corporation.  All rights reserved.
//
#pragma once

DWORD WINAPI UntimedSleepEx(DWORD dwMilliseconds, BOOL bAlertable);
DWORD WINAPI TimedSleepEx(DWORD dwMilliseconds, BOOL bAlertable);
DWORD WINAPI GetSleptTicks(VOID);
DWORD WINAPI TestTicks(VOID);
DWORD WINAPI TestTicksEx(DWORD Add);

//
///////////////////////////////////////////////////////////////// End of File.

```

`samples/slept/slept.rc`:

```rc
//////////////////////////////////////////////////////////////////////////////
//
//  Version information for sleep.rc.
//
//  Microsoft Research Detours Package
//
//  Copyright (c) Microsoft Corporation.  All rights reserved.
//

#include "detver.h"

#define VER_INTERNALNAME_STR        "sleep" DETOURS_STRINGIFY(DETOURS_BITS)
#define VER_ORIGINALFILENAME_STR    "sleep" DETOURS_STRINGIFY(DETOURS_BITS) ".dll"
#define VER_FILEDESCRIPTION_STR     "Detours Sleep Test Module"
#define VER_COMPANYNAME_STR         "Microsoft Corporation"

#include "common.ver"

```

`samples/slept/verify.cpp`:

```cpp
//////////////////////////////////////////////////////////////////////////////
//
//  Detour Test Program (verify.cpp)
//
//  Microsoft Research Detours Package
//
//  Copyright (c) Microsoft Corporation.  All rights reserved.
//

#include <detours.h>

static VOID Dump(PBYTE pbBytes, LONG nBytes, PBYTE pbTarget)
{
    for (LONG n = 0; n < nBytes; n += 16) {
        printf("    %p: ", pbBytes + n);
        for (LONG m = n; m < n + 16; m++) {
            if (m >= nBytes) {
                printf("  ");
            }
            else {
                printf("%02x", pbBytes[m]);
            }
            if (m % 4 == 3) {
                printf(" ");
            }
        }
        if (n == 0 && pbTarget != DETOUR_INSTRUCTION_TARGET_NONE) {
            printf(" [%p]", pbTarget);
        }
        printf("\n");
    }
}

static VOID Decode(PCSTR pszDesc, PBYTE pbCode, PBYTE pbOther, PBYTE pbPointer, LONG nInst)
{
    if (pbCode != pbPointer) {
        printf("  %s = %p [%p]\n", pszDesc, pbCode, pbPointer);
    }
    else {
        printf("  %s = %p\n", pszDesc, pbCode);
    }

    if (pbCode == pbOther) {
        printf("    ... unchanged ...\n");
        return;
    }

    PBYTE pbSrc = pbCode;
    PBYTE pbEnd;
    PVOID pbTarget;
    for (LONG n = 0; n < nInst; n++) {
        pbEnd = (PBYTE)DetourCopyInstruction(NULL, NULL, pbSrc, &pbTarget, NULL);
        Dump(pbSrc, (int)(pbEnd - pbSrc), (PBYTE)pbTarget);
        pbSrc = pbEnd;
    }
}


VOID WINAPI Verify(PCHAR pszFunc, PVOID pvPointer)
{
    PVOID pvCode = DetourCodeFromPointer(pvPointer, NULL);

    Decode(pszFunc, (PBYTE)pvCode, NULL, (PBYTE)pvPointer, 3);
}

VOID WINAPI VerifyEx(PCHAR pszFunc, PVOID pvPointer, LONG nInst)
{
    PVOID pvCode = DetourCodeFromPointer(pvPointer, NULL);

    Decode(pszFunc, (PBYTE)pvCode, NULL, (PBYTE)pvPointer, nInst);
}

//
///////////////////////////////////////////////////////////////// End of File.

```

`samples/syelog/Makefile`:

```
##############################################################################
##
##  Makefile for Detours.
##
##  Microsoft Research Detours Package
##
##  Copyright (c) Microsoft Corporation.  All rights reserved.
##
##############################################################################

TARGETOS=WINNT
!include ..\common.mak

LIBS=$(LIBS) kernel32.lib

##############################################################################

all: dirs \
    $(INCD)\syelog.h        \
    $(LIBD)\syelog.lib  \
    $(BIND)\syelogd.exe \
    \
    $(BIND)\sltest.exe  \
    $(BIND)\sltestp.exe     \
    \
!IF $(DETOURS_SOURCE_BROWSING)==1
    $(OBJD)\syelogd.bsc \
    $(OBJD)\sltest.bsc  \
    $(OBJD)\sltestp.bsc     \
!ENDIF

##############################################################################
##
clean:
    -del *~ test.txt 2> nul
    -del $(INCD)\syelog.* 2>nul
    -del $(LIBD)\syelog.* 2>nul
    -del $(BIND)\syelogd.* 2>nul
    -del $(BIND)\sltest.* 2>nul
    -del $(BIND)\sltestp.* 2>nul
    -rmdir /q /s $(OBJD) 2>nul

realclean: clean
    -rmdir /q /s $(OBJDS) 2>nul

##############################################################################

dirs:
    @if not exist $(INCD) mkdir $(INCD) && echo.   Created $(INCD)
    @if not exist $(LIBD) mkdir $(LIBD) && echo.   Created $(LIBD)
    @if not exist $(BIND) mkdir $(BIND) && echo.   Created $(BIND)
    @if not exist $(OBJD) mkdir $(OBJD) && echo.   Created $(OBJD)

$(OBJD)\syelog.obj : syelog.cpp syelog.h
$(OBJD)\syelogd.obj: syelogd.cpp syelog.h
$(OBJD)\sltest.obj: sltest.cpp syelog.h
$(OBJD)\sltestp.obj: sltestp.cpp syelog.h

$(INCD)\syelog.h : syelog.h
    copy syelog.h $@

$(LIBD)\syelog.lib : $(OBJD)\syelog.obj
    link /lib $(LIBFLAGS) /out:$@ $(OBJD)\syelog.obj

$(BIND)\sltest.exe: $(OBJD)\sltest.obj $(OBJD)\syelog.obj $(DEPS)
    $(CC) $(CFLAGS) /Fe$@ /Fd$(@R).pdb $(OBJD)\sltest.obj \
        /link $(LINKFLAGS) $(LIBS)

$(OBJD)\sltest.bsc : $(OBJD)\sltest.obj
    bscmake /v /n /o $@ $(OBJD)\sltest.sbr

$(BIND)\sltestp.exe: $(OBJD)\sltestp.obj $(DEPS)
    $(CC) $(CFLAGS) /Fe$@ /Fd$(@R).pdb $(OBJD)\sltestp.obj \
        /link $(LINKFLAGS) $(LIBS)

$(OBJD)\sltestp.bsc : $(OBJD)\sltestp.obj
    bscmake /v /n /o $@ $(OBJD)\sltestp.sbr

$(LIBD)\detours.lib:
    cd $(ROOT)\src
    nmake /nologo
    cd $(MAKEDIR)

$(BIND)\syelogd.exe: $(OBJD)\syelogd.obj $(DEPS)
    $(CC) $(CFLAGS) /Fe$@ /Fd$(@R).pdb $(OBJD)\syelogd.obj \
        /link $(LINKFLAGS) ws2_32.lib mswsock.lib advapi32.lib

$(OBJD)\syelogd.bsc : $(OBJD)\syelogd.obj
    bscmake /v /n /o $@ $(OBJD)\syelogd.sbr

##############################################################################

test: $(BIND)\syelogd.exe $(BIND)\sltest.exe $(BIND)\sltestp.exe
    @echo -------- Logging output to test.txt ------------
    start $(BIND)\syelogd.exe test.txt
    $(BIND)\sleep5.exe 1
    $(BIND)\sltestp.exe
    $(BIND)\sltest.exe /x
    type test.txt

################################################################# End of File.

```

`samples/syelog/sltest.cpp`:

```cpp
//////////////////////////////////////////////////////////////////////////////
//
//  Detours Test Program (sltest.cpp of sltest.exe)
//
//  Microsoft Research Detours Package
//
//  Copyright (c) Microsoft Corporation.  All rights reserved.
//
//  Test the named-pipe-based connection with syelog.lib to the syelog
//  system-event logger.
//
#include <windows.h>
#include <stdio.h>
#include <stdlib.h>
#include <stddef.h>
#pragma warning(push)
#if _MSC_VER > 1400
#pragma warning(disable:6102 6103) // /analyze warnings
#endif
#include <strsafe.h>
#pragma warning(pop)
#include "syelog.h"
#include "detours.h"

extern "C" {

    HANDLE ( WINAPI *
             Real_CreateFileW)(LPCWSTR a0,
                               DWORD a1,
                               DWORD a2,
                               LPSECURITY_ATTRIBUTES a3,
                               DWORD a4,
                               DWORD a5,
                               HANDLE a6)
        = CreateFileW;

    BOOL ( WINAPI *
           Real_WriteFile)(HANDLE hFile,
                           LPCVOID lpBuffer,
                           DWORD nNumberOfBytesToWrite,
                           LPDWORD lpNumberOfBytesWritten,
                           LPOVERLAPPED lpOverlapped)
        = WriteFile;
    BOOL ( WINAPI *
           Real_FlushFileBuffers)(HANDLE hFile)
        = FlushFileBuffers;
    BOOL ( WINAPI *
           Real_CloseHandle)(HANDLE hObject)
        = CloseHandle;

    BOOL ( WINAPI *
           Real_WaitNamedPipeW)(LPCWSTR lpNamedPipeName, DWORD nTimeOut)
        = WaitNamedPipeW;
    BOOL ( WINAPI *
           Real_SetNamedPipeHandleState)(HANDLE hNamedPipe,
                                         LPDWORD lpMode,
                                         LPDWORD lpMaxCollectionCount,
                                         LPDWORD lpCollectDataTimeout)
        = SetNamedPipeHandleState;

    DWORD ( WINAPI *
            Real_GetCurrentProcessId)(VOID)
        = GetCurrentProcessId;
    VOID ( WINAPI *
           Real_GetSystemTimeAsFileTime)(LPFILETIME lpSystemTimeAsFileTime)
        = GetSystemTimeAsFileTime;

    VOID ( WINAPI *
           Real_InitializeCriticalSection)(LPCRITICAL_SECTION lpSection)
        = InitializeCriticalSection;
    VOID ( WINAPI *
           Real_EnterCriticalSection)(LPCRITICAL_SECTION lpSection)
        = EnterCriticalSection;
    VOID ( WINAPI *
           Real_LeaveCriticalSection)(LPCRITICAL_SECTION lpSection)
        = LeaveCriticalSection;
}

int main(int argc, char **argv)
{
    BOOL fNeedHelp = FALSE;
    BOOL fRequestExitOnClose = FALSE;

    int arg = 1;
    for (; arg < argc && (argv[arg][0] == '-' || argv[arg][0] == '/'); arg++) {
        CHAR *argn = argv[arg] + 1;
        CHAR *argp = argn;
        while (*argp && *argp != ':') {
            argp++;
        }
        if (*argp == ':') {
            *argp++ = '\0';
        }

        switch (argn[0]) {

          case 'x':                                 // Request exit on close.
          case 'X':
            fRequestExitOnClose = TRUE;
            break;

          case '?':                                 // Help.
            fNeedHelp = TRUE;
            break;

          default:
            fNeedHelp = TRUE;
            printf("SLTEST: Bad argument: %s:%s\n", argn, argp);
            break;
        }
    }

    if (fNeedHelp) {
        printf("Usage:\n"
               "    sltest.exe [options] message\n"
               "Options:\n"
               "    /x         Ask syelogd.exe to terminate when this connect closes.\n"
               "    /?         Display this help message.\n"
               "\n");
        exit(1);
    }

    SyelogOpen("sltest", SYELOG_FACILITY_APPLICATION);
    if (arg >= argc) {
        Syelog(SYELOG_SEVERITY_INFORMATION, "Hello World! [1 of 4]");
        Syelog(SYELOG_SEVERITY_INFORMATION, "Hello World! [2 of 4]");
        Syelog(SYELOG_SEVERITY_INFORMATION, "Hello World! [3 of 4]");
        Syelog(SYELOG_SEVERITY_INFORMATION, "Hello World! [4 of 4]");
    }
    else {
        CHAR Buffer[1024] = "";

        for (; arg < argc; arg++) {
            StringCchCatA(Buffer, ARRAYSIZE(Buffer), argv[arg]);
            if (arg + 1 < argc) {
                StringCchCatA(Buffer, ARRAYSIZE(Buffer), " ");
            }
        }
        Syelog(SYELOG_SEVERITY_INFORMATION, Buffer);
    }

    SyelogClose(fRequestExitOnClose);

    return 0;
}

```

`samples/syelog/sltestp.cpp`:

```cpp
//////////////////////////////////////////////////////////////////////////////
//
//  Detours Test Program (sltestp.cpp of sltestp.exe)
//
//  Microsoft Research Detours Package
//
//  Copyright (c) Microsoft Corporation.  All rights reserved.
//
//  Test the named-pipe-based connection to the syelog system-event logger.
//
#include <windows.h>
#include <stdio.h>
#include <stdlib.h>
#include <stddef.h>
#pragma warning(push)
#if _MSC_VER > 1400
#pragma warning(disable:6102 6103) // /analyze warnings
#endif
#include <strsafe.h>
#pragma warning(pop)
#include "syelog.h"

VOID MyErrExit(PCSTR pszMsg)
{
    fprintf(stderr, "Error %s: %ld\n", pszMsg, GetLastError());
    exit(1);
}

DWORD main(int argc, char *argv[])
{
    HANDLE hPipe;
    SYELOG_MESSAGE Message;
    BOOL fSuccess;
    DWORD cbWritten, dwMode;

    // Try to open a named pipe; wait for it, if necessary.

    TIME_ZONE_INFORMATION tzi;
    GetTimeZoneInformation(&tzi);

    for (;;) {
        hPipe = CreateFileW(SYELOG_PIPE_NAMEW,  // pipe name
                            GENERIC_WRITE,      // write access only
                            0,                  // no sharing
                            NULL,               // no security attributes
                            OPEN_EXISTING,      // opens existing pipe
                            0,                  // default attributes
                            NULL);              // no template file

        // Break if the pipe handle is valid.
         if (hPipe != INVALID_HANDLE_VALUE)
            break;

        // Exit if an error other than ERROR_PIPE_BUSY occurs.

        if (GetLastError() != ERROR_PIPE_BUSY)
            MyErrExit("Could not open pipe");

        // All pipe instances are busy, so wait for 1 seconds.

        if (!WaitNamedPipeW(SYELOG_PIPE_NAMEW, 1000))
            MyErrExit("Could not open pipe");
    }

    // The pipe connected; change to message-read mode.
    dwMode = PIPE_READMODE_MESSAGE;
    fSuccess = SetNamedPipeHandleState(hPipe,    // pipe handle
                                       &dwMode,  // new pipe mode
                                       NULL,     // don't set maximum bytes
                                       NULL);    // don't set maximum time
    if (!fSuccess)
        MyErrExit("SetNamedPipeHandleState");

    // Send a message to the pipe server.

    memset(&Message, 0, sizeof(Message));

    StringCchCopyA(Message.szMessage, ARRAYSIZE(Message.szMessage),
                   (argc > 1) ? argv[1] : "sltestp: hello world!");

    Message.nFacility = SYELOG_FACILITY_APPLICATION;
    Message.nSeverity = SYELOG_SEVERITY_INFORMATION;
    Message.nProcessId = GetCurrentProcessId();
    GetSystemTimeAsFileTime(&Message.ftOccurance);
    PCSTR pszEnd = Message.szMessage;
    for (; *pszEnd; pszEnd++) {
        // no internal contents.
    }
    Message.nBytes = (USHORT)(pszEnd - ((PCSTR)&Message) + 1);

    fSuccess = WriteFile(hPipe,                  // pipe handle
                         &Message,             // message
                         Message.nBytes, // message length
                         &cbWritten,             // bytes written
                         NULL);                  // not overlapped
    if (! fSuccess)
        MyErrExit("WriteFile");

    CloseHandle(hPipe);

    GetTimeZoneInformation(&tzi);

    return 0;
}

```

`samples/syelog/syelog.cpp`:

```cpp
//////////////////////////////////////////////////////////////////////////////
//
//  Detours Test Program (syelog.cpp of syelog.lib)
//
//  Microsoft Research Detours Package
//
//  Copyright (c) Microsoft Corporation.  All rights reserved.
//
#include <windows.h>
#include <stdarg.h>
#include <stddef.h>
#include <stdlib.h>
#include "detours.h"
#include "syelog.h"

#include <stdio.h>

//////////////////////////////////////////////////////////////////////////////
extern "C" {
    extern HANDLE ( WINAPI * Real_CreateFileW)(LPCWSTR a0,
                                               DWORD a1,
                                               DWORD a2,
                                               LPSECURITY_ATTRIBUTES a3,
                                               DWORD a4,
                                               DWORD a5,
                                               HANDLE a6);
    extern BOOL ( WINAPI * Real_WriteFile)(HANDLE hFile,
                                           LPCVOID lpBuffer,
                                           DWORD nNumberOfBytesToWrite,
                                           LPDWORD lpNumberOfBytesWritten,
                                           LPOVERLAPPED lpOverlapped);
    extern BOOL ( WINAPI * Real_FlushFileBuffers)(HANDLE hFile);
    extern BOOL ( WINAPI * Real_CloseHandle)(HANDLE hObject);

    extern BOOL ( WINAPI * Real_WaitNamedPipeW)(LPCWSTR lpNamedPipeName, DWORD nTimeOut);
    extern BOOL ( WINAPI * Real_SetNamedPipeHandleState)(HANDLE hNamedPipe,
                                                         LPDWORD lpMode,
                                                         LPDWORD lpMaxCollectionCount,
                                                         LPDWORD lpCollectDataTimeout);

    extern DWORD ( WINAPI * Real_GetCurrentProcessId)(VOID);
    extern VOID ( WINAPI * Real_GetSystemTimeAsFileTime)(LPFILETIME lpSystemTimeAsFileTime);

    extern VOID ( WINAPI * Real_InitializeCriticalSection)(LPCRITICAL_SECTION lpSection);
    extern VOID ( WINAPI * Real_EnterCriticalSection)(LPCRITICAL_SECTION lpSection);
    extern VOID ( WINAPI * Real_LeaveCriticalSection)(LPCRITICAL_SECTION lpSection);
}

///////////////////////////////////////////////////////////////////// VPrintf.
//
// Completely side-effect free printf replacement (but no FP numbers).
//
static PCHAR do_base(PCHAR pszOut, UINT64 nValue, UINT nBase, PCSTR pszDigits)
{
    CHAR szTmp[96];
    int nDigit = sizeof(szTmp)-2;
    for (; nDigit >= 0; nDigit--) {
        szTmp[nDigit] = pszDigits[nValue % nBase];
        nValue /= nBase;
    }
    for (nDigit = 0; nDigit < sizeof(szTmp) - 2 && szTmp[nDigit] == '0'; nDigit++) {
        // skip leading zeros.
    }
    for (; nDigit < sizeof(szTmp) - 1; nDigit++) {
        *pszOut++ = szTmp[nDigit];
    }
    *pszOut = '\0';
    return pszOut;
}

static PCHAR do_str(PCHAR pszOut, PCHAR pszEnd, PCSTR pszIn)
{
    while (*pszIn && pszOut < pszEnd) {
        *pszOut++ = *pszIn++;
    }
    *pszOut = '\0';
    return pszOut;
}

static PCHAR do_wstr(PCHAR pszOut, PCHAR pszEnd, PCWSTR pszIn)
{
    while (*pszIn && pszOut < pszEnd) {
        *pszOut++ = (CHAR)*pszIn++;
    }
    *pszOut = '\0';
    return pszOut;
}

static PCHAR do_estr(PCHAR pszOut, PCHAR pszEnd, PCSTR pszIn)
{
    while (*pszIn && pszOut < pszEnd) {
        if (*pszIn == '<') {
            if (pszOut + 4 > pszEnd) {
                break;
            }
            pszIn++;
            *pszOut++ = '&';
            *pszOut++ = 'l';
            *pszOut++ = 't';
            *pszOut++ = ';';
        }
        else if (*pszIn == '>') {
            if (pszOut + 4 > pszEnd) {
                break;
            }
            pszIn++;
            *pszOut++ = '&';
            *pszOut++ = 'g';
            *pszOut++ = 't';
            *pszOut++ = ';';
        }
        else if (*pszIn == '&') {
            if (pszOut + 5 > pszEnd) {
                break;
            }
            pszIn++;
            *pszOut++ = '&';
            *pszOut++ = 'a';
            *pszOut++ = 'm';
            *pszOut++ = 'p';
            *pszOut++ = ';';
        }
        else if (*pszIn == '\"') {
            if (pszOut + 6 > pszEnd) {
                break;
            }
            pszIn++;
            *pszOut++ = '&';
            *pszOut++ = 'q';
            *pszOut++ = 'u';
            *pszOut++ = 'o';
            *pszOut++ = 't';
            *pszOut++ = ';';
        }
        else if (*pszIn == '\'') {
            if (pszOut + 6 > pszEnd) {
                break;
            }
            pszIn++;
            *pszOut++ = '&';
            *pszOut++ = 'a';
            *pszOut++ = 'p';
            *pszOut++ = 'o';
            *pszOut++ = 's';
            *pszOut++ = ';';
        }
        else if (*pszIn  < ' ') {
            BYTE c = (BYTE)(*pszIn++);
            if (c < 10 && pszOut + 4 <= pszEnd) {
                *pszOut++ = '&';
                *pszOut++ = '#';
                *pszOut++ = '0' + (c % 10);
                *pszOut++ = ';';
            }
            else if (c < 100 && pszOut + 5 <= pszEnd) {
                *pszOut++ = '&';
                *pszOut++ = '#';
                *pszOut++ = '0' + ((c / 10) % 10);
                *pszOut++ = '0' + (c % 10);
                *pszOut++ = ';';
            }
            else if (c < 1000 && pszOut + 6 <= pszEnd) {
                *pszOut++ = '&';
                *pszOut++ = '#';
                *pszOut++ = '0' + ((c / 100) % 10);
                *pszOut++ = '0' + ((c / 10) % 10);
                *pszOut++ = '0' + (c % 10);
                *pszOut++ = ';';
            }
            else {
                break;
            }
        }
        else {
            *pszOut++ = *pszIn++;
        }
    }
    *pszOut = '\0';
    return pszOut;
}

static PCHAR do_ewstr(PCHAR pszOut, PCHAR pszEnd, PCWSTR pszIn)
{
    while (*pszIn && pszOut < pszEnd) {
        if (*pszIn == '<') {
            if (pszOut + 4 > pszEnd) {
                break;
            }
            pszIn++;
            *pszOut++ = '&';
            *pszOut++ = 'l';
            *pszOut++ = 't';
            *pszOut++ = ';';
        }
        else if (*pszIn == '>') {
            if (pszOut + 4 > pszEnd) {
                break;
            }
            pszIn++;
            *pszOut++ = '&';
            *pszOut++ = 'g';
            *pszOut++ = 't';
            *pszOut++ = ';';
        }
        else if (*pszIn == '&') {
            if (pszOut + 5 > pszEnd) {
                break;
            }
            pszIn++;
            *pszOut++ = '&';
            *pszOut++ = 'a';
            *pszOut++ = 'm';
            *pszOut++ = 'p';
            *pszOut++ = ';';
        }
        else if (*pszIn == '\"') {
            if (pszOut + 6 > pszEnd) {
                break;
            }
            pszIn++;
            *pszOut++ = '&';
            *pszOut++ = 'q';
            *pszOut++ = 'u';
            *pszOut++ = 'o';
            *pszOut++ = 't';
            *pszOut++ = ';';
        }
        else if (*pszIn == '\'') {
            if (pszOut + 6 > pszEnd) {
                break;
            }
            pszIn++;
            *pszOut++ = '&';
            *pszOut++ = 'a';
            *pszOut++ = 'p';
            *pszOut++ = 'o';
            *pszOut++ = 's';
            *pszOut++ = ';';
        }
        else if (*pszIn  < ' ' || *pszIn > 127) {
            WCHAR c = *pszIn++;
            if (c < 10 && pszOut + 4 <= pszEnd) {
                *pszOut++ = '&';
                *pszOut++ = '#';
                *pszOut++ = '0' + (CHAR)(c % 10);
                *pszOut++ = ';';
            }
            else if (c < 100 && pszOut + 5 <= pszEnd) {
                *pszOut++ = '&';
                *pszOut++ = '#';
                *pszOut++ = '0' + (CHAR)((c / 10) % 10);
                *pszOut++ = '0' + (CHAR)(c % 10);
                *pszOut++ = ';';
            }
            else if (c < 1000 && pszOut + 6 <= pszEnd) {
                *pszOut++ = '&';
                *pszOut++ = '#';
                *pszOut++ = '0' + (CHAR)((c / 100) % 10);
                *pszOut++ = '0' + (CHAR)((c / 10) % 10);
                *pszOut++ = '0' + (CHAR)(c % 10);
                *pszOut++ = ';';
            }
            else {
                break;
            }
        }
        else {
            *pszOut++ = (CHAR)*pszIn++;
        }
    }
    *pszOut = '\0';
    return pszOut;
}

#if _MSC_VER >= 1900
#pragma warning(push)
#pragma warning(disable:4456) // declaration hides previous local declaration
#endif

VOID VSafePrintf(PCSTR pszMsg, va_list args, PCHAR pszBuffer, LONG cbBuffer)
{
    PCHAR pszOut = pszBuffer;
    PCHAR pszEnd = pszBuffer + cbBuffer - 1;
    pszBuffer[0] = '\0';

    __try {
        while (*pszMsg && pszOut < pszEnd) {
            if (*pszMsg == '%') {
                CHAR szHead[4] = "";
                INT nLen;
                INT nWidth = 0;
                INT nPrecision = 0;
                BOOL fLeft = FALSE;
                BOOL fPositive = FALSE;
                BOOL fPound = FALSE;
                BOOL fBlank = FALSE;
                BOOL fZero = FALSE;
                BOOL fDigit = FALSE;
                BOOL fSmall = FALSE;
                BOOL fLarge = FALSE;
                BOOL f64Bit = FALSE;
                PCSTR pszArg = pszMsg;

                pszMsg++;

                for (; (*pszMsg == '-' ||
                        *pszMsg == '+' ||
                        *pszMsg == '#' ||
                        *pszMsg == ' ' ||
                        *pszMsg == '0'); pszMsg++) {
                    switch (*pszMsg) {
                      case '-': fLeft = TRUE; break;
                      case '+': fPositive = TRUE; break;
                      case '#': fPound = TRUE; break;
                      case ' ': fBlank = TRUE; break;
                      case '0': fZero = TRUE; break;
                    }
                }

                if (*pszMsg == '*') {
                    nWidth = va_arg(args, INT);
                    pszMsg++;
                }
                else {
                    while (*pszMsg >= '0' && *pszMsg <= '9') {
                        nWidth = nWidth * 10 + (*pszMsg++ - '0');
                    }
                }
                if (*pszMsg == '.') {
                    pszMsg++;
                    fDigit = TRUE;
                    if (*pszMsg == '*') {
                        nPrecision = va_arg(args, INT);
                        pszMsg++;
                    }
                    else {
                        while (*pszMsg >= '0' && *pszMsg <= '9') {
                            nPrecision = nPrecision * 10 + (*pszMsg++ - '0');
                        }
                    }
                }

                if (*pszMsg == 'h') {
                    fSmall = TRUE;
                    pszMsg++;
                }
                else if (*pszMsg == 'l') {
                    fLarge = TRUE;
                    pszMsg++;
                }
                else if (*pszMsg == 'I' && pszMsg[1] == '6' && pszMsg[2] == '4') {
                    f64Bit = TRUE;
                    pszMsg += 3;
                }

                if (*pszMsg == 's' || *pszMsg == 'e' || *pszMsg == 'c') {
                    // We ignore the length, precision, and alignment
                    // to avoid using a temporary buffer.

                    if (*pszMsg == 's') { // [GalenH] need to not use temp.
                        PVOID pvData = va_arg(args, PVOID);

                        pszMsg++;

                        if (fSmall) {
                            fLarge = FALSE;
                        }

                        __try {
                            if (pvData == NULL) {
                                pszOut = do_str(pszOut, pszEnd, "<NULL>");
                            }
                            else if (pvData < (PVOID)0x10000) {
                                pszOut = do_str(pszOut, pszEnd, "#");
                                pszOut = do_base(pszOut, (UINT64)pvData, 16,
                                             "0123456789ABCDEF");
                                pszOut = do_str(pszOut, pszEnd, "#");
                            }
                            else if (fLarge) {
                                pszOut = do_wstr(pszOut, pszEnd, (PWCHAR)pvData);
                            }
                            else {
                                pszOut = do_str(pszOut, pszEnd, (PCHAR)pvData);
                            }
                        } __except(EXCEPTION_EXECUTE_HANDLER) {
                            pszOut = do_str(pszOut, pszEnd, "-");
                            pszOut = do_base(pszOut, (UINT64)pvData, 16,
                                             "0123456789ABCDEF");
                            pszOut = do_str(pszOut, pszEnd, "-");
                        }
                    }
                    else if (*pszMsg == 'e')    {   // Escape the string.
                        PVOID pvData = va_arg(args, PVOID);

                        pszMsg++;

                        if (fSmall) {
                            fLarge = FALSE;
                        }

                        __try {
                            if (pvData == NULL) {
                                pszOut = do_str(pszOut, pszEnd, "<NULL>");
                            }
                            else if (pvData < (PVOID)0x10000) {
                                pszOut = do_str(pszOut, pszEnd, ">");
                                pszOut = do_base(pszOut, (UINT64)pvData, 16,
                                             "0123456789ABCDEF");
                                pszOut = do_str(pszOut, pszEnd, ">");
                            }
                            else if (fLarge) {
                                pszOut = do_ewstr(pszOut, pszEnd, (PWCHAR)pvData);
                            }
                            else {
                                pszOut = do_estr(pszOut, pszEnd, (PCHAR)pvData);
                            }
                        } __except(EXCEPTION_EXECUTE_HANDLER) {
                            pszOut = do_str(pszOut, pszEnd, "-");
                            pszOut = do_base(pszOut, (UINT64)pvData, 16,
                                             "0123456789ABCDEF");
                            pszOut = do_str(pszOut, pszEnd, "-");
                        }
                    }
                    else {
                        CHAR szTemp[2];
                        pszMsg++;

                        szTemp[0] = (CHAR)va_arg(args, INT);
                        szTemp[1] = '\0';
                        pszOut = do_str(pszOut, pszEnd, szTemp);
                    }
                }
                else if (*pszMsg == 'd' || *pszMsg == 'i' || *pszMsg == 'o' ||
                         *pszMsg == 'x' || *pszMsg == 'X' || *pszMsg == 'b' ||
                         *pszMsg == 'u') {
                    CHAR szTemp[128];
                    UINT64 value;
                    if (f64Bit) {
                        value = va_arg(args, UINT64);
                    }
                    else {
                        value = va_arg(args, UINT);
                    }

                    if (*pszMsg == 'x') {
                        pszMsg++;
                        nLen = (int)(do_base(szTemp, value, 16, "0123456789abcdef") - szTemp);
                        if (fPound && value) {
                            do_str(szHead, szHead + sizeof(szHead) - 1, "0x");
                        }
                    }
                    else if (*pszMsg == 'X') {
                        pszMsg++;
                        nLen = (int)(do_base(szTemp, value, 16, "0123456789ABCDEF") - szTemp);
                        if (fPound && value) {
                            do_str(szHead, szHead + sizeof(szHead) - 1, "0X");
                        }
                    }
                    else if (*pszMsg == 'd') {
                        pszMsg++;
                        if ((INT64)value < 0) {
                            value = -(INT64)value;
                            do_str(szHead, szHead + sizeof(szHead) - 1, "-");
                        }
                        else if (fPositive) {
                            if (value > 0) {
                                do_str(szHead, szHead + sizeof(szHead) - 1, "+");
                            }
                        }
                        else if (fBlank) {
                            if (value > 0) {
                                do_str(szHead, szHead + sizeof(szHead) - 1, " ");
                            }
                        }
                        nLen = (int)(do_base(szTemp, value, 10, "0123456789") - szTemp);
                        nPrecision = 0;
                    }
                    else if (*pszMsg == 'u') {
                        pszMsg++;
                        nLen = (int)(do_base(szTemp, value, 10, "0123456789") - szTemp);
                        nPrecision = 0;
                    }
                    else if (*pszMsg == 'o') {
                        pszMsg++;
                        nLen = (int)(do_base(szTemp, value, 8, "01234567") - szTemp);
                        nPrecision = 0;

                        if (fPound && value) {
                            do_str(szHead, szHead + sizeof(szHead) - 1, "0");
                        }
                    }
                    else if (*pszMsg == 'b') {
                        pszMsg++;
                        nLen = (int)(do_base(szTemp, value, 2, "01") - szTemp);
                        nPrecision = 0;

                        if (fPound && value) {
                            do_str(szHead, szHead + sizeof(szHead) - 1, "0b");
                        }
                    }
                    else {
                        pszMsg++;
                        if ((INT64)value < 0) {
                            value = -(INT64)value;
                            do_str(szHead, szHead + sizeof(szHead) - 1, "-");
                        }
                        else if (fPositive) {
                            if (value > 0) {
                                do_str(szHead, szHead + sizeof(szHead) - 1, "+");
                            }
                        }
                        else if (fBlank) {
                            if (value > 0) {
                                do_str(szHead, szHead + sizeof(szHead) - 1, " ");
                            }
                        }
                        nLen = (int)(do_base(szTemp, value, 10, "0123456789") - szTemp);
                        nPrecision = 0;
                    }

                    INT nHead = 0;
                    for (; szHead[nHead]; nHead++) {
                        // Count characters in head string.
                    }

                    if (fLeft) {
                        if (nHead) {
                            pszOut = do_str(pszOut, pszEnd, szHead);
                            nLen += nHead;
                        }
                        pszOut = do_str(pszOut, pszEnd, szTemp);
                        for (; nLen < nWidth && pszOut < pszEnd; nLen++) {
                            *pszOut++ = ' ';
                        }
                    }
                    else if (fZero) {
                        if (nHead) {
                            pszOut = do_str(pszOut, pszEnd, szHead);
                            nLen += nHead;
                        }
                        for (; nLen < nWidth && pszOut < pszEnd; nLen++) {
                            *pszOut++ = '0';
                        }
                        pszOut = do_str(pszOut, pszEnd, szTemp);
                    }
                    else {
                        if (nHead) {
                            nLen += nHead;
                        }
                        for (; nLen < nWidth && pszOut < pszEnd; nLen++) {
                            *pszOut++ = ' ';
                        }
                        if (nHead) {
                            pszOut = do_str(pszOut, pszEnd, szHead);
                        }
                        pszOut = do_str(pszOut, pszEnd, szTemp);
                    }
                }
                else if (*pszMsg == 'p') {
                    CHAR szTemp[64];
                    ULONG_PTR value;
                    value = va_arg(args, ULONG_PTR);

                    if ((INT64)value == (INT64)-1 ||
                        (INT64)value == (INT64)-2) {
                        if (*pszMsg == 'p') {
                            pszMsg++;
                        }
                        szTemp[0] = '-';
                        szTemp[1] = ((INT64)value == (INT64)-1) ? '1' : '2';
                        szTemp[2] = '\0';
                        nLen = 2;
                    }
                    else {
                        if (*pszMsg == 'p') {
                            pszMsg++;
                            nLen = (int)(do_base(szTemp, (UINT64)value, 16, "0123456789abcdef") - szTemp);
                            if (fPound && value) {
                                do_str(szHead, szHead + sizeof(szHead) - 1, "0x");
                            }
                        }
                        else {
                            pszMsg++;
                            nLen = (int)(do_base(szTemp, (UINT64)value, 16, "0123456789ABCDEF") - szTemp);
                            if (fPound && value) {
                                do_str(szHead, szHead + sizeof(szHead) - 1, "0x");
                            }
                        }
                    }

                    INT nHead = 0;
                    for (; szHead[nHead]; nHead++) {
                        // Count characters in head string.
                    }

                    if (nHead) {
                        pszOut = do_str(pszOut, pszEnd, szHead);
                        nLen += nHead;
                    }
                    for (; nLen < nWidth && pszOut < pszEnd; nLen++) {
                        *pszOut++ = '0';
                    }
                    pszOut = do_str(pszOut, pszEnd, szTemp);
                }
                else {
                    pszMsg++;
                    while (pszArg < pszMsg && pszOut < pszEnd) {
                        *pszOut++ = *pszArg++;
                    }
                }
            }
            else {
                if (pszOut < pszEnd) {
                    *pszOut++ = *pszMsg++;
                }
            }
        }
        *pszOut = '\0';
        pszBuffer[cbBuffer - 1] = '\0';
    } __except(EXCEPTION_EXECUTE_HANDLER) {
        PCHAR pszOut = pszBuffer;
        *pszOut = '\0';
        pszOut = do_str(pszOut, pszEnd, "-exception:");
        pszOut = do_base(pszOut, (UINT64)GetExceptionCode(), 10, "0123456789");
        pszOut = do_str(pszOut, pszEnd, "-");
    }
}

#if _MSC_VER >= 1900
#pragma warning(pop)
#endif

PCHAR SafePrintf(PCHAR pszBuffer, LONG cbBuffer, PCSTR pszMsg, ...)
{
    va_list args;
    va_start(args, pszMsg);
    VSafePrintf(pszMsg, args, pszBuffer, cbBuffer);
    va_end(args);

    while (*pszBuffer) {
        pszBuffer++;
    }
    return pszBuffer;
}

//////////////////////////////////////////////////////////////////////////////
//
static CRITICAL_SECTION s_csPipe;                       // Guards access to hPipe.
static HANDLE           s_hPipe = INVALID_HANDLE_VALUE;
static DWORD            s_nPipeError = 0;
static FILETIME         s_ftRetry = {0,0};
static BYTE             s_nFacility = SYELOG_FACILITY_APPLICATION;
static CHAR             s_szIdent[256] = "";
static DWORD            s_nProcessId = 0;

static inline INT syelogCompareTimes(CONST PFILETIME pft1, CONST PFILETIME pft2)
{
    INT64 ut1 = *(PINT64)pft1;
    INT64 ut2 = *(PINT64)pft2;

    if (ut1 < ut2) {
        return -1;
    }
    else if (ut1 > ut2) {
        return 1;
    }
    else {
        return 0;
    }
}

static inline VOID syelogAddMilliseconds(PFILETIME pft, DWORD nMilliseconds)
{
    *(PINT64&)pft += ((INT64)nMilliseconds * 10000);
}

//////////////////////////////////////////////////////////////////////////////
//
// Tries to insure that a named-pipe connection to the system log is open
// If the pipe closes, the next call will immediately try to re-open the pipe.
// If the pipe doesn't open again, we wait 5 minutes before trying again.
// We wait 5 minutes, because each attempt may take up to a full second to
// time out.
//
static BOOL syelogIsOpen(PFILETIME pftLog)
{
    if (s_hPipe != INVALID_HANDLE_VALUE) {
        return TRUE;
    }

    if (syelogCompareTimes(pftLog, &s_ftRetry) < 0) {
        return FALSE;
    }

    s_hPipe = Real_CreateFileW(SYELOG_PIPE_NAMEW,
                               GENERIC_WRITE, 0, NULL, OPEN_EXISTING,
                               SECURITY_ANONYMOUS, NULL);
    if (s_hPipe != INVALID_HANDLE_VALUE) {
        DWORD dwMode = PIPE_READMODE_MESSAGE;
        if (Real_SetNamedPipeHandleState(s_hPipe, &dwMode, NULL, NULL)) {
            return TRUE;
        }
    }

    if (Real_WaitNamedPipeW(SYELOG_PIPE_NAMEW, 2000)) { // Wait 2 seconds.
        // Pipe connected, change to message-read mode.
        //
        s_hPipe = Real_CreateFileW(SYELOG_PIPE_NAMEW,
                                   GENERIC_WRITE, 0, NULL, OPEN_EXISTING,
                                   SECURITY_ANONYMOUS, NULL);
        if (s_hPipe != INVALID_HANDLE_VALUE) {
            DWORD dwMode = PIPE_READMODE_MESSAGE;
            if (Real_SetNamedPipeHandleState(s_hPipe, &dwMode, NULL, NULL)) {
                return TRUE;
            }
        }
    }

    // Couldn't open pipe.
    s_ftRetry = *pftLog;
    syelogAddMilliseconds(&s_ftRetry, 300000);           // Wait 5 minute before retry.

    return FALSE;
}

VOID SyelogOpen(PCSTR pszIdentifier, BYTE nFacility)
{
    Real_InitializeCriticalSection(&s_csPipe);

    if (pszIdentifier) {
        PCHAR pszOut = s_szIdent;
        PCHAR pszEnd = s_szIdent + ARRAYSIZE(s_szIdent) - 1;
        pszOut = do_str(pszOut, pszEnd, pszIdentifier);
        pszOut = do_str(pszOut, pszEnd, ": ");
        *pszEnd = '\0';
    }
    else {
        s_szIdent[0] = '\0';
    }

    s_nFacility = nFacility;
    s_nProcessId = Real_GetCurrentProcessId();
}

VOID SyelogExV(BOOL fTerminate, BYTE nSeverity, PCSTR pszMsgf, va_list args)
{
    SYELOG_MESSAGE Message;
    DWORD cbWritten = 0;

    Real_GetSystemTimeAsFileTime(&Message.ftOccurance);
    Message.fTerminate = fTerminate;
    Message.nFacility = s_nFacility;
    Message.nSeverity = nSeverity;
    Message.nProcessId = s_nProcessId;
    PCHAR pszBuf = Message.szMessage;
    PCHAR pszEnd = Message.szMessage + ARRAYSIZE(Message.szMessage) - 1;
    if (s_szIdent[0]) {
        pszBuf = do_str(pszBuf, pszEnd, s_szIdent);
    }
    *pszEnd = '\0';
    VSafePrintf(pszMsgf, args,
                pszBuf, (int)(Message.szMessage + sizeof(Message.szMessage) - 1 - pszBuf));

    pszEnd = Message.szMessage;
    for (; *pszEnd; pszEnd++) {
        // no internal contents.
    }

    // Insure that the message always ends with a '\n'
    //
    if (pszEnd > Message.szMessage) {
        if (pszEnd[-1] != '\n') {
            *pszEnd++ = '\n';
            *pszEnd++ = '\0';
        }
        else {
            *pszEnd++ = '\0';
        }
    }
    else {
        *pszEnd++ = '\n';
        *pszEnd++ = '\0';
    }
    Message.nBytes = (USHORT)(pszEnd - ((PCSTR)&Message));

    Real_EnterCriticalSection(&s_csPipe);

    if (syelogIsOpen(&Message.ftOccurance)) {
        if (!Real_WriteFile(s_hPipe, &Message, Message.nBytes, &cbWritten, NULL)) {
            s_nPipeError = GetLastError();
            if (s_nPipeError == ERROR_BAD_IMPERSONATION_LEVEL) {
                // Don't close the file just for a temporary impersonation level.
            }
            else {
                if (s_hPipe != INVALID_HANDLE_VALUE) {
                    Real_CloseHandle(s_hPipe);
                    s_hPipe = INVALID_HANDLE_VALUE;
                }
                if (syelogIsOpen(&Message.ftOccurance)) {
                    Real_WriteFile(s_hPipe, &Message, Message.nBytes, &cbWritten, NULL);
                }
            }
        }
    }

    Real_LeaveCriticalSection(&s_csPipe);
}

VOID SyelogV(BYTE nSeverity, PCSTR pszMsgf, va_list args)
{
    SyelogExV(FALSE, nSeverity, pszMsgf, args);
}

VOID Syelog(BYTE nSeverity, PCSTR pszMsgf, ...)
{
    va_list args;
    va_start(args, pszMsgf);
    SyelogExV(FALSE, nSeverity, pszMsgf, args);
    va_end(args);
}

VOID SyelogEx(BOOL fTerminate, BYTE nSeverity, PCSTR pszMsgf, ...)
{
    va_list args;
    va_start(args, pszMsgf);
    SyelogExV(fTerminate, nSeverity, pszMsgf, args);
    va_end(args);
}

VOID SyelogClose(BOOL fTerminate)
{
    if (fTerminate) {
        SyelogEx(TRUE, SYELOG_SEVERITY_NOTICE, "Requesting exit on close.\n");
    }

    Real_EnterCriticalSection(&s_csPipe);

    if (s_hPipe != INVALID_HANDLE_VALUE) {
        Real_FlushFileBuffers(s_hPipe);
        Real_CloseHandle(s_hPipe);
        s_hPipe = INVALID_HANDLE_VALUE;
    }

    Real_LeaveCriticalSection(&s_csPipe);
}
//
///////////////////////////////////////////////////////////////// End of File.

```

`samples/syelog/syelog.h`:

```h
//////////////////////////////////////////////////////////////////////////////
//
//  Detours Test Program (syelog.h of syelog.lib)
//
//  Microsoft Research Detours Package
//
//  Copyright (c) Microsoft Corporation.  All rights reserved.
//
#pragma once
#ifndef _SYELOGD_H_
#define _SYELOGD_H_
#include <stdarg.h>

#pragma pack(push, 1)
#pragma warning(push)
#pragma warning(disable: 4200)

//////////////////////////////////////////////////////////////////////////////
//
//
#define SYELOG_PIPE_NAMEA       "\\\\.\\pipe\\syelog"
#define SYELOG_PIPE_NAMEW       L"\\\\.\\pipe\\syelog"
#ifdef UNICODE
#define SYELOG_PIPE_NAME        SYELOG_PIPE_NAMEW
#else
#define SYELOG_PIPE_NAME        SYELOG_PIPE_NAMEA
#endif

//////////////////////////////////////////////////////////////////////////////
//
#define SYELOG_MAXIMUM_MESSAGE  4086    // 4096 - sizeof(header stuff)

typedef struct _SYELOG_MESSAGE
{
    USHORT      nBytes;
    BYTE        nFacility;
    BYTE        nSeverity;
    DWORD       nProcessId;
    FILETIME    ftOccurance;
    BOOL        fTerminate;
    CHAR        szMessage[SYELOG_MAXIMUM_MESSAGE];
} SYELOG_MESSAGE, *PSYELOG_MESSAGE;


// Facility Codes.
//
#define SYELOG_FACILITY_KERNEL          0x10            // OS Kernel
#define SYELOG_FACILITY_SECURITY        0x20            // OS Security
#define SYELOG_FACILITY_LOGGING         0x30            // OS Logging-internal
#define SYELOG_FACILITY_SERVICE         0x40            // User-mode system daemon
#define SYELOG_FACILITY_APPLICATION     0x50            // User-mode application
#define SYELOG_FACILITY_USER            0x60            // User self-generated.
#define SYELOG_FACILITY_LOCAL0          0x70            // Locally defined.
#define SYELOG_FACILITY_LOCAL1          0x71            // Locally defined.
#define SYELOG_FACILITY_LOCAL2          0x72            // Locally defined.
#define SYELOG_FACILITY_LOCAL3          0x73            // Locally defined.
#define SYELOG_FACILITY_LOCAL4          0x74            // Locally defined.
#define SYELOG_FACILITY_LOCAL5          0x75            // Locally defined.
#define SYELOG_FACILITY_LOCAL6          0x76            // Locally defined.
#define SYELOG_FACILITY_LOCAL7          0x77            // Locally defined.
#define SYELOG_FACILITY_LOCAL8          0x78            // Locally defined.
#define SYELOG_FACILITY_LOCAL9          0x79            // Locally defined.

// Severity Codes.
//
#define SYELOG_SEVERITY_FATAL           0x00            // System is dead.
#define SYELOG_SEVERITY_ALERT           0x10            // Take action immediately.
#define SYELOG_SEVERITY_CRITICAL        0x20            // Critical condition.
#define SYELOG_SEVERITY_ERROR           0x30            // Error
#define SYELOG_SEVERITY_WARNING         0x40            // Warning
#define SYELOG_SEVERITY_NOTICE          0x50            // Significant condition.
#define SYELOG_SEVERITY_INFORMATION     0x60            // Informational
#define SYELOG_SEVERITY_AUDIT_FAIL      0x66            // Audit Failed
#define SYELOG_SEVERITY_AUDIT_PASS      0x67            // Audit Succeeeded
#define SYELOG_SEVERITY_DEBUG           0x70            // Debugging

// Logging Functions.
//
VOID SyelogOpen(PCSTR pszIdentifier, BYTE nFacility);
VOID Syelog(BYTE nSeverity, PCSTR pszMsgf, ...);
VOID SyelogV(BYTE nSeverity, PCSTR pszMsgf, va_list args);
VOID SyelogClose(BOOL fTerminate);

#pragma warning(pop)
#pragma pack(pop)

#endif //  _SYELOGD_H_
//
///////////////////////////////////////////////////////////////// End of File.

```

`samples/syelog/syelogd.cpp`:

```cpp
//////////////////////////////////////////////////////////////////////////////
//
//  Detours Test Program (syelogd.cpp of syelogd.exe)
//
//  Microsoft Research Detours Package
//
//  Copyright (c) Microsoft Corporation.  All rights reserved.
//
#include <windows.h>
#include <stdio.h>
#include <stdlib.h>
#include <stddef.h>
#pragma warning(push)
#if _MSC_VER > 1400
#pragma warning(disable:6102 6103) // /analyze warnings
#endif
#include <strsafe.h>
#pragma warning(pop)
#include "syelog.h"

#if (_MSC_VER < 1299)
typedef ULONG * PULONG_PTR;
typedef ULONG ULONG_PTR;
typedef LONG * PLONG_PTR;
typedef LONG LONG_PTR;
#endif

enum {
    CLIENT_AWAITING_PIPE_ACCEPT = 0x21,
    CLIENT_AWAITING_PIPE_DATA   = 0x22,
};

typedef struct _CLIENT : OVERLAPPED
{
    HANDLE          hPipe;
    BOOL            fAwaitingAccept;
    PVOID           Zero;
    SYELOG_MESSAGE  Message;
} CLIENT, *PCLIENT;

//////////////////////////////////////////////////////////////////////////////
//
BOOL        s_fLogToScreen  = TRUE;     // Log output to screen.
BOOL        s_fExitAfterOne = FALSE;
BOOL        s_fDeltaTime    = FALSE;
HANDLE      s_hOutFile      = INVALID_HANDLE_VALUE;

LONG        s_nActiveClients = 0;
LONGLONG    s_llStartTime = 0;
LONGLONG    s_llLastTime = 0;

BOOL LogMessageV(BYTE nSeverity, PCHAR pszMsg, ...);

//////////////////////////////////////////////////////////////////////////////
//
VOID MyErrExit(PCSTR pszMsg)
{
    DWORD error = GetLastError();

    LogMessageV(SYELOG_SEVERITY_FATAL, "Error %d in %s.", error, pszMsg);
    fprintf(stderr, "SYELOGD: Error %ld in %s.\n", error, pszMsg);
    fflush(stderr);
    exit(1);
}

//////////////////////////////////////////////////////////////////////////////
//
static PCSTR FileTimeToString(PCHAR pszBuffer, DWORD cbBuffer, FILETIME ftTime)
{
    (void)cbBuffer;

    static BOOL bGotTzi = FALSE;
    static DWORD dwTzi = TIME_ZONE_ID_UNKNOWN;
    static TIME_ZONE_INFORMATION tzi;
    if (!bGotTzi) {
        dwTzi = GetTimeZoneInformation(&tzi);
        if (dwTzi == TIME_ZONE_ID_UNKNOWN) {
            ZeroMemory(&tzi, sizeof(tzi));
        }
        bGotTzi = TRUE;
    }
    SYSTEMTIME stUtc;
    SYSTEMTIME stLocal;

    pszBuffer[0] = '\0';

    if (s_fDeltaTime) {
        if (s_llLastTime == 0) {
            s_llLastTime = s_llStartTime;
        }

        ULARGE_INTEGER ul;
        ul.LowPart = ftTime.dwLowDateTime;
        ul.HighPart = ftTime.dwHighDateTime;

        LONG64 delta = ul.QuadPart - s_llLastTime;
        s_llLastTime = ul.QuadPart;
        delta /= 10000;

        StringCchPrintfA(pszBuffer, cbBuffer, "%7I64d", delta);
    }
    else {
        if (!FileTimeToSystemTime(&ftTime, &stUtc)) {
            StringCchPrintfA(pszBuffer, cbBuffer, "ft:%16I64d", *(LONGLONG *)&ftTime);
            return pszBuffer;
        }
        else if (!SystemTimeToTzSpecificLocalTime(&tzi, &stUtc, &stLocal)) {
            CopyMemory(&stLocal, &stUtc, sizeof(stLocal));
        }

        StringCchPrintfA(pszBuffer, cbBuffer, "%4d%02d%02d%02d%02d%02d%03d",
                         stLocal.wYear,
                         stLocal.wMonth,
                         stLocal.wDay,
                         stLocal.wHour,
                         stLocal.wMinute,
                         stLocal.wSecond,
                         stLocal.wMilliseconds);
    }
    return pszBuffer;
}

BOOL CloseConnection(PCLIENT pClient)
{
    LogMessageV(SYELOG_SEVERITY_INFORMATION, "Client closed pipe.");

    InterlockedDecrement(&s_nActiveClients);
    if (pClient != NULL) {
        if (pClient->hPipe != INVALID_HANDLE_VALUE) {
            FlushFileBuffers(pClient->hPipe);
            if (!DisconnectNamedPipe(pClient->hPipe)) {
                MyErrExit("DisconnectNamedPipe");
            }
            CloseHandle(pClient->hPipe);
            pClient->hPipe = INVALID_HANDLE_VALUE;
        }
        GlobalFree(pClient);
        pClient = NULL;
    }

    if (s_fExitAfterOne) {
        ExitProcess(0);
    }
    return TRUE;
}

// Creates a pipe instance and initiate an accept request.
//
PCLIENT CreatePipeConnection(HANDLE hCompletionPort)
{
    HANDLE hPipe = CreateNamedPipe(SYELOG_PIPE_NAME,           // pipe name
                                   PIPE_ACCESS_INBOUND |       // read-only access
                                   FILE_FLAG_OVERLAPPED,       // overlapped mode
                                   PIPE_TYPE_MESSAGE |         // message-type pipe
                                   PIPE_READMODE_MESSAGE |     // message read mode
                                   PIPE_WAIT,                   // blocking mode
                                   PIPE_UNLIMITED_INSTANCES,   // unlimited instances
                                   0,                          // output buffer size
                                   0,                          // input buffer size
                                   20000,                      // client time-out
                                   NULL);                      // no security attributes
    if (hPipe == INVALID_HANDLE_VALUE) {
        MyErrExit("CreatePipe");
    }

    // Allocate the client data structure.
    //
    PCLIENT pClient = (PCLIENT) GlobalAlloc(GPTR, sizeof(CLIENT));
    if (pClient == NULL) {
        MyErrExit("GlobalAlloc pClient");
    }

    ZeroMemory(pClient, sizeof(*pClient));
    pClient->hPipe = hPipe;
    pClient->fAwaitingAccept = TRUE;

    // Associate file with our complietion port.
    //
    if (!CreateIoCompletionPort(pClient->hPipe, hCompletionPort, (ULONG_PTR)pClient, 0)) {
        MyErrExit("CreateIoComplietionPort pClient");
    }

    if (!ConnectNamedPipe(hPipe, pClient)) {
        if (GetLastError() != ERROR_IO_PENDING &&
            GetLastError() != ERROR_PIPE_LISTENING) {
            MyErrExit("ConnectNamedPipe");
        }
    }
    else {
        LogMessageV(SYELOG_SEVERITY_INFORMATION,
                    "ConnectNamedPipe accepted immediately.");
    }
    return pClient;
}

BOOL LogMessageV(BYTE nSeverity, PCHAR pszMsg, ...)
{
    FILETIME ftOccurance;
    CHAR szTime[64];
    GetSystemTimeAsFileTime(&ftOccurance);
    FileTimeToString(szTime, sizeof(szTime), ftOccurance);

    if (s_fLogToScreen) {
        printf(s_fDeltaTime
               ? "%-7.7s ---- --.%02x: "
               : "%-17.17s ---- --.%02x: "
               , szTime, nSeverity);
        va_list args;
        va_start(args, pszMsg);
        vprintf(pszMsg, args);
        va_end(args);
        printf("\n");
    }
    if (s_hOutFile != INVALID_HANDLE_VALUE) {
        DWORD cbWritten = 0;
        CHAR szBuf[4096] = "";
        PCHAR pcchEnd = szBuf + ARRAYSIZE(szBuf) - 2;
        PCHAR pcchCur = szBuf;
        HRESULT hr;

        hr = StringCchPrintfExA(pcchCur, pcchEnd - pcchCur,
                                &pcchCur, NULL, STRSAFE_NULL_ON_FAILURE,
                                s_fDeltaTime
                                ? "%-7.7s ---- --.%02x: "
                                : "%-17.17s ---- --.%02x: "
                                , szTime, nSeverity);
        if (FAILED(hr)) {
            goto Cleanup;
        }

        va_list args;
        va_start(args, pszMsg);
        hr = StringCchPrintfExA(pcchCur, pcchEnd - pcchCur,
                                &pcchCur, NULL, STRSAFE_NULL_ON_FAILURE,
                                pszMsg, args);
        va_end(args);
        if (FAILED(hr)) {
            goto Cleanup;
        }

        hr = StringCchPrintfExA(pcchCur, (szBuf + ARRAYSIZE(szBuf)) - pcchCur,
                                &pcchCur, NULL, STRSAFE_NULL_ON_FAILURE,
                                 "\n");
        if (FAILED(hr)) {
            goto Cleanup;
        }

      Cleanup:
        WriteFile(s_hOutFile, szBuf, (DWORD)(pcchCur - szBuf), &cbWritten, NULL);
    }
    return TRUE;
}

BOOL LogMessage(PSYELOG_MESSAGE pMessage, DWORD nBytes)
{
    // Sanity check the size of the message.
    //
    if (nBytes > pMessage->nBytes) {
        nBytes = pMessage->nBytes;
    }
    if (nBytes >= sizeof(*pMessage)) {
        nBytes = sizeof(*pMessage) - 1;
    }

    // Don't log message if there isn't and message text.
    //
    if (nBytes <= offsetof(SYELOG_MESSAGE, szMessage)) {
        return FALSE;
    }

    CHAR szTime[64];
    FileTimeToString(szTime, sizeof(szTime), pMessage->ftOccurance);

    PCHAR pszMsg = pMessage->szMessage;
    while (*pszMsg) {
        pszMsg++;
    }
    while (pszMsg > pMessage->szMessage && isspace(pszMsg[-1])) {
        *--pszMsg = '\0';
    }

    if (s_fLogToScreen) {
        printf(s_fDeltaTime
               ? "%-7.7s %4d %02x.%02x: %s\n"
               : "%-17.17s %4d %02x.%02x: %s\n",
               szTime,
               pMessage->nProcessId,
               pMessage->nFacility,
               pMessage->nSeverity,
               pMessage->szMessage);
    }
    if (s_hOutFile != INVALID_HANDLE_VALUE) {
        DWORD cbWritten = 0;
        CHAR szBuf[4096];
        PCHAR pcchEnd = szBuf + ARRAYSIZE(szBuf);
        PCHAR pcchCur = szBuf;
        HRESULT hr;

        hr = StringCchPrintfExA(pcchCur, pcchEnd - pcchCur,
                                &pcchCur, NULL, STRSAFE_NULL_ON_FAILURE,
                                s_fDeltaTime
                                ? "%-7.7s %4d %02x.%02x: %s\n"
                                : "%-17.17s %4d %02x.%02x: %s\n",
                                szTime,
                                pMessage->nProcessId,
                                pMessage->nFacility,
                                pMessage->nSeverity,
                                pMessage->szMessage);
        if (FAILED(hr)) {
            goto Cleanup;
        }

      Cleanup:
        WriteFile(s_hOutFile, szBuf, (DWORD)(pcchCur - szBuf), &cbWritten, NULL);
    }
    return TRUE;
}

DWORD WINAPI WorkerThread(LPVOID pvVoid)
{
    PCLIENT pClient;
    BOOL b;
    LPOVERLAPPED lpo;
    DWORD nBytes;
    HANDLE hCompletionPort = (HANDLE)pvVoid;

    for (BOOL fKeepLooping = TRUE; fKeepLooping;) {
        pClient = NULL;
        lpo = NULL;
        nBytes = 0;
        b = GetQueuedCompletionStatus(hCompletionPort,
                                      &nBytes, (PULONG_PTR)&pClient, &lpo, INFINITE);

        if (!b || lpo == NULL) {
            fKeepLooping = FALSE;
            MyErrExit("GetQueuedCompletionState");
            break;
        }
        else if (!b) {
            if (pClient) {
                if (GetLastError() == ERROR_BROKEN_PIPE) {
                    LogMessageV(SYELOG_SEVERITY_INFORMATION, "Client closed pipe.");
                }
                else {
                    LogMessageV(SYELOG_SEVERITY_ERROR,
                                "GetQueuedCompletionStatus failed %d [%p]",
                                GetLastError(), pClient);
                }
                CloseConnection(pClient);
            }
            continue;
        }

        if (pClient->fAwaitingAccept) {
            InterlockedIncrement(&s_nActiveClients);
            pClient->fAwaitingAccept = FALSE;
            b = ReadFile(pClient->hPipe,
                         &pClient->Message,
                         sizeof(pClient->Message),
                         &nBytes,
                         pClient);
            if (!b) {
                if (GetLastError() != ERROR_IO_PENDING) {
                    LogMessageV(SYELOG_SEVERITY_ERROR,
                                "ReadFile failed %d.", GetLastError());
                    continue;
                }
            }

            CreatePipeConnection(hCompletionPort);
        }
        else {
            if (nBytes < offsetof(SYELOG_MESSAGE, szMessage)) {
                CloseConnection(pClient);
            }

            if (pClient->Message.fTerminate) {
                LogMessageV(SYELOG_SEVERITY_NOTICE,
                            "Client requested terminate on next connection close.");
                s_fExitAfterOne = TRUE;
            }

            LogMessage(&pClient->Message, nBytes);

            b = ReadFile(pClient->hPipe,
                         &pClient->Message,
                         sizeof(pClient->Message),
                         &nBytes,
                         pClient);
            if (!b && GetLastError() == ERROR_BROKEN_PIPE) {
                CloseConnection(pClient);
            }
        }
    }
    return 0;
}

BOOL CreateWorkers(HANDLE hCompletionPort)
{
    DWORD dwThread;
    HANDLE hThread;
    DWORD i;
    SYSTEM_INFO SystemInfo;

    GetSystemInfo(&SystemInfo);

    for (i = 0; i < 2 * SystemInfo.dwNumberOfProcessors; i++) {
        hThread = CreateThread(NULL, 0, WorkerThread, hCompletionPort, 0, &dwThread);
        if (!hThread) {
            MyErrExit("CreateThread WorkerThread");
            // Unreachable: return FALSE;
        }
        CloseHandle(hThread);
    }
    return TRUE;
}

//////////////////////////////////////////////////////////////////////////////
//
BOOL WINAPI ControlHandler(DWORD dwCtrlType)
{
    switch (dwCtrlType) {
      case CTRL_C_EVENT:
      case CTRL_BREAK_EVENT:
      case CTRL_CLOSE_EVENT:
      case CTRL_LOGOFF_EVENT:
      case CTRL_SHUTDOWN_EVENT:
        LogMessageV(SYELOG_SEVERITY_INFORMATION, "User requested stop.");
        printf("\nSYELOGD: Closing connections.\n");
        if (s_hOutFile != INVALID_HANDLE_VALUE) {
            printf("Closing file.\n");
            FlushFileBuffers(s_hOutFile);
            CloseHandle(s_hOutFile);
            s_hOutFile = INVALID_HANDLE_VALUE;
        }
        ExitProcess(0);
    }
    return FALSE;
}

DWORD main(int argc, char **argv)
{
    HANDLE hCompletionPort;
    BOOL fNeedHelp = FALSE;

    GetSystemTimeAsFileTime((FILETIME *)&s_llStartTime);
    SetConsoleCtrlHandler(ControlHandler, TRUE);

    int arg = 1;
    for (; arg < argc; arg++) {
        if (argv[arg][0] == '-' || argv[arg][0] == '/') {
            CHAR *argn = argv[arg] + 1;
            CHAR *argp = argn;
            while (*argp && *argp != ':') {
                argp++;
            }
            if (*argp == ':') {
                *argp++ = '\0';
            }

            switch (argn[0]) {

              case 'd':                                 // Delta time.
              case 'D':
                s_fDeltaTime = TRUE;
                break;

              case 'o':                                 // Only one.
              case 'O':
                s_fExitAfterOne = TRUE;
                break;

              case 'q':                                 // Quiet.
              case 'Q':
                s_fLogToScreen = FALSE;
                break;

              case '?':                                 // Help.
                fNeedHelp = TRUE;
                break;

              default:
                fNeedHelp = TRUE;
                printf("SYELOGD: Bad argument: %s:%s\n", argn, argp);
                break;
            }
        }
        else {
            if (s_hOutFile != INVALID_HANDLE_VALUE) {
                printf("SYELOGD: Error, more than one output file specified.\n\n");
                fNeedHelp = TRUE;
                break;
            }

            s_hOutFile = CreateFileA(argv[arg],
                                     GENERIC_WRITE,
                                     FILE_SHARE_READ,
                                     NULL,
                                     CREATE_ALWAYS,
                                     FILE_ATTRIBUTE_NORMAL |
                                     FILE_FLAG_SEQUENTIAL_SCAN,
                                     NULL);
            if (s_hOutFile == INVALID_HANDLE_VALUE) {
                printf("SYELOGD: Error opening output file: %s: %ld\n\n",
                       argv[arg], GetLastError());
                fNeedHelp = TRUE;
                break;
            }
            else {
                printf("SYELOGD: Logging to %s.\n", argv[arg]);
            }
        }
    }
    if (fNeedHelp) {
        printf("Usage:\n"
               "    syelogd [options] {output_file}\n"
               "Options:\n"
               "    /d         List delta time in ms from previous event (not absolute time).\n"
               "    /o         Exit after one client disconnects.\n"
               "    /q         Disable event logging to screen (quiet mode).\n"
               "    /?         Display this help message.\n"
               "Summary:\n"
               "    If given, all events will be logged to the output file.\n"
               "\n");
        exit(1);
    }


    // Create the completion port.
    hCompletionPort = CreateIoCompletionPort(INVALID_HANDLE_VALUE, NULL, NULL, 0);
    if (hCompletionPort == NULL) {
        MyErrExit("CreateIoCompletionPort");
    }

    // Create completion port worker threads.
    //
    CreateWorkers(hCompletionPort);
    CreatePipeConnection(hCompletionPort);

    printf("SYELOGD: Ready for clients.  Press Ctrl-C to stop.\n");
    while (argc) {
        Sleep(10000);
    }

    SetConsoleCtrlHandler(ControlHandler, FALSE);

    if (s_hOutFile != INVALID_HANDLE_VALUE) {
        FlushFileBuffers(s_hOutFile);
        CloseHandle(s_hOutFile);
        s_hOutFile = INVALID_HANDLE_VALUE;
    }

    return 0;
}
//
//////////////////////////////////////////////////////////////////////////////

```

`samples/talloc/Makefile`:

```
##############################################################################
##
##  Makefile for Detours Test Programs.
##
##  Microsoft Research Detours Package
##
##  Copyright (c) Microsoft Corporation.  All rights reserved.
##

!include ..\common.mak

# This test tests the allocation algorithm. .dlls are carefully placed
# immediately adjacent to each other to force the algorithm to look more places.

# /noentry keeps the .dlls small, so they all fit at their bases

!if "$(DETOURS_TARGET_PROCESSOR:64=)" == "$(DETOURS_TARGET_PROCESSOR)"
# 32bit bases
DETOURS_TALLOC1=0x28000000
DETOURS_TALLOC2=0x38000000
DETOURS_TALLOC3=0x48050000
DETOURS_TALLOC4=0x58000000
DETOURS_TALLOC5=0x68000000
DETOURS_TALLOC6=0x68010000
DETOURS_TALLOC7=0x68020000
DETOURS_TALLOC8=0x68030000
DETOURS_TALLOC9=0x68040000
!else
# 64bit bases
DETOURS_TALLOC1=0x280000000
DETOURS_TALLOC2=0x380000000
DETOURS_TALLOC3=0x480050000
DETOURS_TALLOC4=0x580000000
DETOURS_TALLOC5=0x680000000
DETOURS_TALLOC6=0x680010000
DETOURS_TALLOC7=0x680020000
DETOURS_TALLOC8=0x680030000
DETOURS_TALLOC9=0x680040000
!endif

LIBS=$(LIBS) kernel32.lib psapi.lib

all: dirs \
    $(BIND)\tdll1x$(DETOURS_BITS).dll \
    $(BIND)\tdll2x$(DETOURS_BITS).dll \
    $(BIND)\tdll3x$(DETOURS_BITS).dll \
    $(BIND)\tdll4x$(DETOURS_BITS).dll \
    $(BIND)\tdll5x$(DETOURS_BITS).dll \
    $(BIND)\tdll6x$(DETOURS_BITS).dll \
    $(BIND)\tdll7x$(DETOURS_BITS).dll \
    $(BIND)\tdll8x$(DETOURS_BITS).dll \
    $(BIND)\tdll9x$(DETOURS_BITS).dll \
    $(BIND)\talloc.exe \
    \
!IF $(DETOURS_SOURCE_BROWSING)==1
    $(OBJD)\tdll1x$(DETOURS_BITS).bsc \
    $(OBJD)\tdll2x$(DETOURS_BITS).bsc \
    $(OBJD)\tdll3x$(DETOURS_BITS).bsc \
    $(OBJD)\tdll4x$(DETOURS_BITS).bsc \
    $(OBJD)\tdll5x$(DETOURS_BITS).bsc \
    $(OBJD)\tdll6x$(DETOURS_BITS).bsc \
    $(OBJD)\tdll7x$(DETOURS_BITS).bsc \
    $(OBJD)\tdll8x$(DETOURS_BITS).bsc \
    $(OBJD)\tdll9x$(DETOURS_BITS).bsc \
    $(OBJD)\talloc.bsc \
!ENDIF
    option

clean:
    -del *~ 2>nul
    -del $(BIND)\tdll1x* 2>nul
    -del $(BIND)\tdll2x* 2>nul
    -del $(BIND)\tdll3x* 2>nul
    -del $(BIND)\tdll4x* 2>nul
    -del $(BIND)\tdll5x* 2>nul
    -del $(BIND)\tdll6x* 2>nul
    -del $(BIND)\tdll7x* 2>nul
    -del $(BIND)\tdll8x* 2>nul
    -del $(BIND)\tdll9x* 2>nul
    -del $(BIND)\talloc* 2>nul
    -rmdir /q /s $(OBJD) 2>nul

realclean: clean
    -rmdir /q /s $(OBJDS) 2>nul

dirs:
    @if not exist $(BIND) mkdir $(BIND) && echo.   Created $(BIND)
    @if not exist $(OBJD) mkdir $(OBJD) && echo.   Created $(OBJD)

##############################################################################

$(OBJD)\talloc.obj : talloc.cpp

$(BIND)\talloc.exe : $(OBJD)\talloc.obj $(DEPS)
    cl $(CFLAGS) /Fe$@ /Fd$(@R).pdb $(OBJD)\talloc.obj \
        /link $(LINKFLAGS) $(LIBS) \
        $(BIND)\tdll1x$(DETOURS_BITS).lib \
        $(BIND)\tdll2x$(DETOURS_BITS).lib \
        $(BIND)\tdll3x$(DETOURS_BITS).lib \
        $(BIND)\tdll4x$(DETOURS_BITS).lib \
        $(BIND)\tdll5x$(DETOURS_BITS).lib \
        $(BIND)\tdll6x$(DETOURS_BITS).lib \
        $(BIND)\tdll7x$(DETOURS_BITS).lib \
        $(BIND)\tdll8x$(DETOURS_BITS).lib \
        $(BIND)\tdll9x$(DETOURS_BITS).lib \
        /subsystem:console /entry:WinMainCRTStartup

$(OBJD)\talloc.bsc : $(OBJD)\talloc.obj
    bscmake /v /n /o $@ $(OBJD)\talloc.sbr

$(OBJD)\tdll1x.obj : tdll1x.cpp

# /noentry keeps the .dlls small, so they all fit at their bases
$(BIND)\tdll1x$(DETOURS_BITS).dll : $(OBJD)\tdll1x.obj $(DEPS)
    cl $(CFLAGS) /Fe$@ /Fd$(@R).pdb \
        $(OBJD)\tdll1x.obj /LD \
        /link $(LINKFLAGS:/profile=/fixed) $(LIBS) \
        /subsystem:windows \
        /noentry \
        /base:$(DETOURS_TALLOC1)

$(OBJD)\tdll1x$(DETOURS_BITS).bsc : $(OBJD)\tdll1x.obj
    bscmake /v /n /o $@ $(OBJD)\tdll1x.sbr

$(OBJD)\tdll2x.obj : tdll2x.cpp

# /noentry keeps the .dlls small, so they all fit at their bases
$(BIND)\tdll2x$(DETOURS_BITS).dll : $(OBJD)\tdll2x.obj $(DEPS)
    cl $(CFLAGS) /Fe$@ /Fd$(@R).pdb \
        $(OBJD)\tdll2x.obj /LD \
        /link $(LINKFLAGS:/profile=/fixed) $(LIBS) \
        /subsystem:console \
        /noentry \
        /base:$(DETOURS_TALLOC2)

$(OBJD)\tdll2x$(DETOURS_BITS).bsc : $(OBJD)\tdll2x.obj
    bscmake /v /n /o $@ $(OBJD)\tdll2x.sbr

$(OBJD)\tdll3x.obj : tdll3x.cpp

# /noentry keeps the .dlls small, so they all fit at their bases
$(BIND)\tdll3x$(DETOURS_BITS).dll : $(OBJD)\tdll3x.obj $(DEPS)
    cl $(CFLAGS) /Fe$@ /Fd$(@R).pdb \
        $(OBJD)\tdll3x.obj /LD \
        /link $(LINKFLAGS:/profile=/fixed) $(LIBS) \
        /subsystem:console \
        /noentry \
        /base:$(DETOURS_TALLOC3)

$(OBJD)\tdll3x$(DETOURS_BITS).bsc : $(OBJD)\tdll3x.obj
    bscmake /v /n /o $@ $(OBJD)\tdll3x.sbr

$(OBJD)\tdll4x.obj : tdll4x.cpp

# /noentry keeps the .dlls small, so they all fit at their bases
$(BIND)\tdll4x$(DETOURS_BITS).dll : $(OBJD)\tdll4x.obj $(DEPS)
    cl $(CFLAGS) /Fe$@ /Fd$(@R).pdb \
        $(OBJD)\tdll4x.obj /LD \
        /link $(LINKFLAGS:/profile=/fixed) $(LIBS) \
        /subsystem:console \
        /noentry \
        /base:$(DETOURS_TALLOC4)

$(OBJD)\tdll4x$(DETOURS_BITS).bsc : $(OBJD)\tdll4x.obj
    bscmake /v /n /o $@ $(OBJD)\tdll4x.sbr


$(OBJD)\tdll5x.obj : tdll5x.cpp

# /noentry keeps the .dlls small, so they all fit at their bases
$(BIND)\tdll5x$(DETOURS_BITS).dll : $(OBJD)\tdll5x.obj $(DEPS)
    cl $(CFLAGS) /Fe$@ /Fd$(@R).pdb \
        $(OBJD)\tdll5x.obj /LD \
        /link $(LINKFLAGS:/profile=/fixed) $(LIBS) \
        /subsystem:console \
        /noentry \
        /base:$(DETOURS_TALLOC5)

$(OBJD)\tdll5x$(DETOURS_BITS).bsc : $(OBJD)\tdll5x.obj
    bscmake /v /n /o $@ $(OBJD)\tdll5x.sbr

$(OBJD)\tdll6x.obj : tdll6x.cpp

# /noentry keeps the .dlls small, so they all fit at their bases
$(BIND)\tdll6x$(DETOURS_BITS).dll : $(OBJD)\tdll6x.obj $(DEPS)
    cl $(CFLAGS) /Fe$@ /Fd$(@R).pdb \
        $(OBJD)\tdll6x.obj /LD \
        /link $(LINKFLAGS:/profile=/fixed) $(LIBS) \
        /subsystem:console \
        /noentry \
        /base:$(DETOURS_TALLOC6)

$(OBJD)\tdll6x$(DETOURS_BITS).bsc : $(OBJD)\tdll6x.obj
    bscmake /v /n /o $@ $(OBJD)\tdll6x.sbr


$(OBJD)\tdll7x.obj : tdll7x.cpp

# /noentry keeps the .dlls small, so they all fit at their bases
$(BIND)\tdll7x$(DETOURS_BITS).dll : $(OBJD)\tdll7x.obj $(DEPS)
    cl $(CFLAGS) /Fe$@ /Fd$(@R).pdb \
        $(OBJD)\tdll7x.obj /LD \
        /link $(LINKFLAGS:/profile=/fixed) $(LIBS) \
        /subsystem:console \
        /noentry \
        /base:$(DETOURS_TALLOC7)

$(OBJD)\tdll7x$(DETOURS_BITS).bsc : $(OBJD)\tdll7x.obj
    bscmake /v /n /o $@ $(OBJD)\tdll7x.sbr


$(OBJD)\tdll8x.obj : tdll8x.cpp

# /noentry keeps the .dlls small, so they all fit at their bases
$(BIND)\tdll8x$(DETOURS_BITS).dll : $(OBJD)\tdll8x.obj $(DEPS)
    cl $(CFLAGS) /Fe$@ /Fd$(@R).pdb \
        $(OBJD)\tdll8x.obj /LD \
        /link $(LINKFLAGS:/profile=/fixed) $(LIBS) \
        /subsystem:console \
        /noentry \
        /base:$(DETOURS_TALLOC8)

$(OBJD)\tdll8x$(DETOURS_BITS).bsc : $(OBJD)\tdll8x.obj
    bscmake /v /n /o $@ $(OBJD)\tdll8x.sbr


$(OBJD)\tdll9x.obj : tdll9x.cpp

# /noentry keeps the .dlls small, so they all fit at their bases
$(BIND)\tdll9x$(DETOURS_BITS).dll : $(OBJD)\tdll9x.obj $(DEPS)
    cl $(CFLAGS) /Fe$@ /Fd$(@R).pdb \
        $(OBJD)\tdll9x.obj /LD \
        /link $(LINKFLAGS:/profile=/fixed) $(LIBS) \
        /subsystem:console \
        /noentry \
        /base:$(DETOURS_TALLOC9)

$(OBJD)\tdll9x$(DETOURS_BITS).bsc : $(OBJD)\tdll9x.obj
    bscmake /v /n /o $@ $(OBJD)\tdll9x.sbr

############################################### Install non-bit-size binaries.

!IF "$(DETOURS_OPTION_PROCESSOR)" != ""

$(OPTD)\tdll1x$(DETOURS_OPTION_BITS).dll:
$(OPTD)\tdll1x$(DETOURS_OPTION_BITS).pdb:
$(OPTD)\tdll2x$(DETOURS_OPTION_BITS).dll:
$(OPTD)\tdll2x$(DETOURS_OPTION_BITS).pdb:
$(OPTD)\tdll3x$(DETOURS_OPTION_BITS).dll:
$(OPTD)\tdll3x$(DETOURS_OPTION_BITS).pdb:
$(OPTD)\tdll4x$(DETOURS_OPTION_BITS).dll:
$(OPTD)\tdll4x$(DETOURS_OPTION_BITS).pdb:
$(OPTD)\tdll5x$(DETOURS_OPTION_BITS).dll:
$(OPTD)\tdll5x$(DETOURS_OPTION_BITS).pdb:
$(OPTD)\tdll6x$(DETOURS_OPTION_BITS).dll:
$(OPTD)\tdll6x$(DETOURS_OPTION_BITS).pdb:
$(OPTD)\tdll7x$(DETOURS_OPTION_BITS).dll:
$(OPTD)\tdll7x$(DETOURS_OPTION_BITS).pdb:
$(OPTD)\tdll8x$(DETOURS_OPTION_BITS).dll:
$(OPTD)\tdll8x$(DETOURS_OPTION_BITS).pdb:
$(OPTD)\tdll9x$(DETOURS_OPTION_BITS).dll:
$(OPTD)\tdll9x$(DETOURS_OPTION_BITS).pdb:

$(BIND)\tdll1x$(DETOURS_OPTION_BITS).dll : $(OPTD)\tdll1x$(DETOURS_OPTION_BITS).dll
    @if exist $? copy /y $? $(BIND) >nul && echo $@ copied from $(DETOURS_OPTION_PROCESSOR).
$(BIND)\tdll1x$(DETOURS_OPTION_BITS).pdb : $(OPTD)\tdll1x$(DETOURS_OPTION_BITS).pdb
    @if exist $? copy /y $? $(BIND) >nul && echo $@ copied from $(DETOURS_OPTION_PROCESSOR).
$(BIND)\tdll2x$(DETOURS_OPTION_BITS).dll : $(OPTD)\tdll2x$(DETOURS_OPTION_BITS).dll
    @if exist $? copy /y $? $(BIND) >nul && echo $@ copied from $(DETOURS_OPTION_PROCESSOR).
$(BIND)\tdll2x$(DETOURS_OPTION_BITS).pdb : $(OPTD)\tdll2x$(DETOURS_OPTION_BITS).pdb
    @if exist $? copy /y $? $(BIND) >nul && echo $@ copied from $(DETOURS_OPTION_PROCESSOR).
$(BIND)\tdll3x$(DETOURS_OPTION_BITS).dll : $(OPTD)\tdll3x$(DETOURS_OPTION_BITS).dll
    @if exist $? copy /y $? $(BIND) >nul && echo $@ copied from $(DETOURS_OPTION_PROCESSOR).
$(BIND)\tdll3x$(DETOURS_OPTION_BITS).pdb : $(OPTD)\tdll3x$(DETOURS_OPTION_BITS).pdb
    @if exist $? copy /y $? $(BIND) >nul && echo $@ copied from $(DETOURS_OPTION_PROCESSOR).
$(BIND)\tdll4x$(DETOURS_OPTION_BITS).dll : $(OPTD)\tdll4x$(DETOURS_OPTION_BITS).dll
    @if exist $? copy /y $? $(BIND) >nul && echo $@ copied from $(DETOURS_OPTION_PROCESSOR).
$(BIND)\tdll4x$(DETOURS_OPTION_BITS).pdb : $(OPTD)\tdll4x$(DETOURS_OPTION_BITS).pdb
    @if exist $? copy /y $? $(BIND) >nul && echo $@ copied from $(DETOURS_OPTION_PROCESSOR).
$(BIND)\tdll5x$(DETOURS_OPTION_BITS).dll : $(OPTD)\tdll5x$(DETOURS_OPTION_BITS).dll
    @if exist $? copy /y $? $(BIND) >nul && echo $@ copied from $(DETOURS_OPTION_PROCESSOR).
$(BIND)\tdll5x$(DETOURS_OPTION_BITS).pdb : $(OPTD)\tdll5x$(DETOURS_OPTION_BITS).pdb
    @if exist $? copy /y $? $(BIND) >nul && echo $@ copied from $(DETOURS_OPTION_PROCESSOR).
$(BIND)\tdll6x$(DETOURS_OPTION_BITS).dll : $(OPTD)\tdll6x$(DETOURS_OPTION_BITS).dll
    @if exist $? copy /y $? $(BIND) >nul && echo $@ copied from $(DETOURS_OPTION_PROCESSOR).
$(BIND)\tdll6x$(DETOURS_OPTION_BITS).pdb : $(OPTD)\tdll6x$(DETOURS_OPTION_BITS).pdb
    @if exist $? copy /y $? $(BIND) >nul && echo $@ copied from $(DETOURS_OPTION_PROCESSOR).
$(BIND)\tdll7x$(DETOURS_OPTION_BITS).dll : $(OPTD)\tdll7x$(DETOURS_OPTION_BITS).dll
    @if exist $? copy /y $? $(BIND) >nul && echo $@ copied from $(DETOURS_OPTION_PROCESSOR).
$(BIND)\tdll7x$(DETOURS_OPTION_BITS).pdb : $(OPTD)\tdll7x$(DETOURS_OPTION_BITS).pdb
    @if exist $? copy /y $? $(BIND) >nul && echo $@ copied from $(DETOURS_OPTION_PROCESSOR).
$(BIND)\tdll8x$(DETOURS_OPTION_BITS).dll : $(OPTD)\tdll8x$(DETOURS_OPTION_BITS).dll
    @if exist $? copy /y $? $(BIND) >nul && echo $@ copied from $(DETOURS_OPTION_PROCESSOR).
$(BIND)\tdll8x$(DETOURS_OPTION_BITS).pdb : $(OPTD)\tdll8x$(DETOURS_OPTION_BITS).pdb
    @if exist $? copy /y $? $(BIND) >nul && echo $@ copied from $(DETOURS_OPTION_PROCESSOR).
$(BIND)\tdll9x$(DETOURS_OPTION_BITS).dll : $(OPTD)\tdll9x$(DETOURS_OPTION_BITS).dll
    @if exist $? copy /y $? $(BIND) >nul && echo $@ copied from $(DETOURS_OPTION_PROCESSOR).
$(BIND)\tdll9x$(DETOURS_OPTION_BITS).pdb : $(OPTD)\tdll9x$(DETOURS_OPTION_BITS).pdb
    @if exist $? copy /y $? $(BIND) >nul && echo $@ copied from $(DETOURS_OPTION_PROCESSOR).

option: \
    $(BIND)\tdll1x$(DETOURS_OPTION_BITS).dll \
    $(BIND)\tdll1x$(DETOURS_OPTION_BITS).pdb \
    $(BIND)\tdll2x$(DETOURS_OPTION_BITS).dll \
    $(BIND)\tdll2x$(DETOURS_OPTION_BITS).pdb \
    $(BIND)\tdll3x$(DETOURS_OPTION_BITS).dll \
    $(BIND)\tdll3x$(DETOURS_OPTION_BITS).pdb \
    $(BIND)\tdll4x$(DETOURS_OPTION_BITS).dll \
    $(BIND)\tdll4x$(DETOURS_OPTION_BITS).pdb \
    $(BIND)\tdll5x$(DETOURS_OPTION_BITS).dll \
    $(BIND)\tdll5x$(DETOURS_OPTION_BITS).pdb \
    $(BIND)\tdll6x$(DETOURS_OPTION_BITS).dll \
    $(BIND)\tdll6x$(DETOURS_OPTION_BITS).pdb \
    $(BIND)\tdll7x$(DETOURS_OPTION_BITS).dll \
    $(BIND)\tdll7x$(DETOURS_OPTION_BITS).pdb \
    $(BIND)\tdll8x$(DETOURS_OPTION_BITS).dll \
    $(BIND)\tdll8x$(DETOURS_OPTION_BITS).pdb \
    $(BIND)\tdll9x$(DETOURS_OPTION_BITS).dll \
    $(BIND)\tdll9x$(DETOURS_OPTION_BITS).pdb \

!ELSE

option:

!ENDIF

##############################################################################

test: all
    $(BIND)\talloc.exe

################################################################# End of File.

```

`samples/talloc/NORMAL_IA64.TXT`:

```TXT
talloc.exe: Detoured functions.

       Address         Size: Typ Sta Prot Ini : Contents
  ------------ ------------: --- --- ---- --- : -----------------
Exe:                                                    13f660000
     100000000     3f660000:     fre  ---     : 
     13f660000         2000: img com  r-- rcx : TALLOC.EXE
     13f6ce000    100802000:     fre  ---     : 
Dll1:                                                   280000000
     200000000     3fed0000:     fre  ---     : 
     23fed0000        10000: pri com  r-x rwx : 
     23fee0000         2000: pri res      --- : 
     23fee2000         e000:     fre  ---     : 
     23fef0000        10000: pri res      --- : 
     23ff00000       100000: pri res      --- : 
     240000000     40000000: pri res      --- : 
     280000000         2000: img com  r-- rcx : TDLL1X64.DLL
     280028000         8000:     fre  ---     : 
     280030000     7ffd0000: pri res      --- : 
Dll2:                                                   380000000
     300000000     80000000: pri res      --- : 
     380000000         2000: img com  r-- rcx : TDLL2X64.DLL
     380028000         8000:     fre  ---     : 
     380030000     40000000: pri res      --- : 
     3c0030000       100000: pri res      --- : 
     3c0130000        10000: pri res      --- : 
     3c0140000         2000: pri res      --- : 
     3c0142000         e000:     fre  ---     : 
     3c0150000        10000: pri com  r-x rwx : 
     3c0160000     3fea0000:     fre  ---     : 
Dll3:                                                   480000000
     400000000     40000000: pri res      --- : 
     440000000       100000: pri res      --- : 
     440100000        10000: pri res      --- : 
     440110000         2000: pri res      --- : 
     440112000         e000:     fre  ---     : 
     440120000        10000: pri com  r-x rwx : 
     440130000     3fed0000:     fre  ---     : 
     480000000         2000: img com  r-- rcx : TDLL3X64.DLL
     480028000         8000:     fre  ---     : 
     480030000     7ffd0000: pri res      --- : 
Dll4:                                                   580000000
     500000000     80000000: pri res      --- : 
     580000000         2000: img com  r-- rcx : TDLL4X64.DLL
     580028000     3fea8000:     fre  ---     : 
     5bfed0000        10000: pri com  r-x rwx : 
     5bfee0000         2000: pri res      --- : 
     5bfee2000         e000:     fre  ---     : 
     5bfef0000        10000: pri res      --- : 
     5bff00000       100000: pri res      --- : 
     5c0000000     40000000: pri res      --- : 
Dll5:                                                   680000000
     600000000        f0000:     fre  ---     : 
     6000f0000        10000: pri com  r-x rwx : 
     600100000     7ff00000: pri res      --- : 
     680000000         2000: img com  r-- rcx : TDLL5X64.DLL
     680028000        18000:     fre  ---     : 
     680040000         2000: img com  r-- rcx : TDLL6X64.DLL
     680068000        18000:     fre  ---     : 
     680080000         2000: img com  r-- rcx : TDLL7X64.DLL
     6800a8000        18000:     fre  ---     : 
     6800c0000         2000: img com  r-- rcx : TDLL8X64.DLL
     6800e8000        18000:     fre  ---     : 
     680100000         2000: img com  r-- rcx : TDLL9X64.DLL
     680128000         8000:     fre  ---     : 
     680130000     7fe00000: pri res      --- : 
     6fff30000        10000: pri com  r-x rwx : 
     6fff40000  6f3fbdd0000:     fre  ---     : 

talloc.exe: 1 calls to Dll1Function

```

`samples/talloc/NORMAL_X64.TXT`:

```TXT
talloc.exe: Detoured functions.

       Address         Size: Typ Sta Prot Ini : Contents
  ------------ ------------: --- --- ---- --- : -----------------
Exe:                                                    13f7f0000
     100000000     3f7f0000:     fre  ---     : 
     13f7f0000         1000: img com  r-- rcx : TALLOC.EXE
     13f81e000    1006b2000:     fre  ---     : 
Dll1:                                                   280000000
     200000000     3fed0000:     fre  ---     : 
     23fed0000        10000: pri com  r-x rwx : 
     23fee0000         1000: pri res      --- : 
     23fee1000         f000:     fre  ---     : 
     23fef0000        10000: pri res      --- : 
     23ff00000       100000: pri res      --- : 
     240000000     40000000: pri res      --- : 
     280000000         1000: img com  r-- rcx : TDLL1X64.DLL
     280010000     7fff0000: pri res      --- : 
Dll2:                                                   380000000
     300000000     80000000: pri res      --- : 
     380000000         1000: img com  r-- rcx : TDLL2X64.DLL
     380010000     40000000: pri res      --- : 
     3c0010000       100000: pri res      --- : 
     3c0110000        10000: pri res      --- : 
     3c0120000         1000: pri res      --- : 
     3c0121000         f000:     fre  ---     : 
     3c0130000        10000: pri com  r-x rwx : 
     3c0140000     3fec0000:     fre  ---     : 
Dll3:                                                   480000000
     400000000     40000000: pri res      --- : 
     440000000       100000: pri res      --- : 
     440100000        10000: pri res      --- : 
     440110000         1000: pri res      --- : 
     440111000         f000:     fre  ---     : 
     440120000        10000: pri com  r-x rwx : 
     440130000     3fed0000:     fre  ---     : 
     480000000         1000: img com  r-- rcx : TDLL3X64.DLL
     480010000     7fff0000: pri res      --- : 
Dll4:                                                   580000000
     500000000     80000000: pri res      --- : 
     580000000         1000: img com  r-- rcx : TDLL4X64.DLL
     580010000     3fec0000:     fre  ---     : 
     5bfed0000        10000: pri com  r-x rwx : 
     5bfee0000         1000: pri res      --- : 
     5bfee1000         f000:     fre  ---     : 
     5bfef0000        10000: pri res      --- : 
     5bff00000       100000: pri res      --- : 
     5c0000000     40000000: pri res      --- : 
Dll5:                                                   680000000
     600000000        f0000:     fre  ---     : 
     6000f0000        10000: pri com  r-x rwx : 
     600100000     7ff00000: pri res      --- : 
     680000000         1000: img com  r-- rcx : TDLL5X64.DLL
     680010000        30000:     fre  ---     : 
     680040000         1000: img com  r-- rcx : TDLL6X64.DLL
     680050000        30000:     fre  ---     : 
     680080000         1000: img com  r-- rcx : TDLL7X64.DLL
     680090000        30000:     fre  ---     : 
     6800c0000         1000: img com  r-- rcx : TDLL8X64.DLL
     6800d0000        30000:     fre  ---     : 
     680100000         1000: img com  r-- rcx : TDLL9X64.DLL
     680110000     7fe00000: pri res      --- : 
     6fff10000        10000: pri com  r-x rwx : 
     6fff20000  7f7fdf70000:     fre  ---     : 

talloc.exe: 1 calls to Dll1Function

```

`samples/talloc/talloc.cpp`:

```cpp
//////////////////////////////////////////////////////////////////////////////
//
//  Detours Test Program (talloc.cpp of talloc.exe)
//
//  Microsoft Research Detours Package
//
//  Copyright (c) Microsoft Corporation.  All rights reserved.
//
#define PSAPI_VERSION 2
#include <stdio.h>
#include <stdlib.h>
#include <windows.h>
#pragma warning(push)
#if _MSC_VER > 1400
#pragma warning(disable:6102 6103) // /analyze warnings
#endif
#include <strsafe.h>
#pragma warning(pop)
#include <psapi.h>
#include <detours.h>

//////////////////////////////////////////////////////////////////////////////

void TypeToString(DWORD Type, char *pszBuffer, size_t cBuffer)
{
    if (Type == MEM_IMAGE) {
        StringCchPrintfA(pszBuffer, cBuffer, "img");
    }
    else if (Type == MEM_MAPPED) {
        StringCchPrintfA(pszBuffer, cBuffer, "map");
    }
    else if (Type == MEM_PRIVATE) {
        StringCchPrintfA(pszBuffer, cBuffer, "pri");
    }
    else if (Type == 0) {
        StringCchPrintfA(pszBuffer, cBuffer, "   ");
    }
    else {
        StringCchPrintfA(pszBuffer, cBuffer, "%x", Type);
    }
}

void StateToString(DWORD State, char *pszBuffer, size_t cBuffer)
{
    if (State == MEM_COMMIT) {
        StringCchPrintfA(pszBuffer, cBuffer, "com");
    }
    else if (State == MEM_FREE) {
        StringCchPrintfA(pszBuffer, cBuffer, "fre");
    }
    else if (State == MEM_RESERVE) {
        StringCchPrintfA(pszBuffer, cBuffer, "res");
    }
    else {
        StringCchPrintfA(pszBuffer, cBuffer, "%x", State);
    }
}

void ProtectToString(DWORD Protect, char *pszBuffer, size_t cBuffer)
{
    if (Protect == 0) {
        StringCchPrintfA(pszBuffer, cBuffer, "");
    }
    else if (Protect == PAGE_EXECUTE) {
        StringCchPrintfA(pszBuffer, cBuffer, "--x");
    }
    else if (Protect == PAGE_EXECUTE_READ) {
        StringCchPrintfA(pszBuffer, cBuffer, "r-x");
    }
    else if (Protect == PAGE_EXECUTE_READWRITE) {
        StringCchPrintfA(pszBuffer, cBuffer, "rwx");
    }
    else if (Protect == PAGE_EXECUTE_WRITECOPY) {
        StringCchPrintfA(pszBuffer, cBuffer, "rcx");
    }
    else if (Protect == PAGE_NOACCESS) {
        StringCchPrintfA(pszBuffer, cBuffer, "---");
    }
    else if (Protect == PAGE_READONLY) {
        StringCchPrintfA(pszBuffer, cBuffer, "r--");
    }
    else if (Protect == PAGE_READWRITE) {
        StringCchPrintfA(pszBuffer, cBuffer, "rw-");
    }
    else if (Protect == PAGE_WRITECOPY) {
        StringCchPrintfA(pszBuffer, cBuffer, "rc-");
    }
    else if (Protect == (PAGE_GUARD | PAGE_EXECUTE)) {
        StringCchPrintfA(pszBuffer, cBuffer, "g--x");
    }
    else if (Protect == (PAGE_GUARD | PAGE_EXECUTE_READ)) {
        StringCchPrintfA(pszBuffer, cBuffer, "gr-x");
    }
    else if (Protect == (PAGE_GUARD | PAGE_EXECUTE_READWRITE)) {
        StringCchPrintfA(pszBuffer, cBuffer, "grwx");
    }
    else if (Protect == (PAGE_GUARD | PAGE_EXECUTE_WRITECOPY)) {
        StringCchPrintfA(pszBuffer, cBuffer, "grcx");
    }
    else if (Protect == (PAGE_GUARD | PAGE_NOACCESS)) {
        StringCchPrintfA(pszBuffer, cBuffer, "g---");
    }
    else if (Protect == (PAGE_GUARD | PAGE_READONLY)) {
        StringCchPrintfA(pszBuffer, cBuffer, "gr--");
    }
    else if (Protect == (PAGE_GUARD | PAGE_READWRITE)) {
        StringCchPrintfA(pszBuffer, cBuffer, "grw-");
    }
    else if (Protect == (PAGE_GUARD | PAGE_WRITECOPY)) {
        StringCchPrintfA(pszBuffer, cBuffer, "grc-");
    }
    else {
        StringCchPrintfA(pszBuffer, cBuffer, "%x", Protect);
    }
}

ULONG PadToPage(ULONG Size)
{
    return (Size & 0xfff)
        ? Size + 0x1000 - (Size & 0xfff)
        : Size;
}

size_t NextAt(size_t start)
{
    size_t next = start;

    for (;;) {
        MEMORY_BASIC_INFORMATION mbi;

        ZeroMemory(&mbi, sizeof(mbi));
        if (VirtualQuery((PVOID)next, &mbi, sizeof(mbi)) == 0) {
            break;
        }
        if ((mbi.RegionSize & 0xfff) == 0xfff) {
            break;
        }

        if ((size_t)mbi.AllocationBase != start) {
            break;
        }

        next = (size_t)mbi.BaseAddress + mbi.RegionSize;
    }
    return next;
}

size_t RoundUpRegion(size_t value)
{
    size_t diff = value & 0xffff;
    return (diff != 0) ? value + 0x10000 - diff : value;
}

VOID DumpProcessHeaders()
{
    printf("  %12s %12s: %3s %3s %4s %3s : %8s\n",
           "Address", "Size", "Typ", "Sta", "Prot", "Ini", "Contents");
    printf("  %12s %12s: %3s %3s %4s %3s : %8s\n",
           "------------", "------------", "---", "---", "----", "---", "-----------------");
}

BOOL DumpProcess(UINT64 lo64, UINT64 hi64)
{
#ifdef _WIN64
    ULONG_PTR lo = lo64;
    ULONG_PTR hi = hi64;
#else
    ULONG_PTR lo = (size_t)(lo64 >> 4);
    ULONG_PTR hi = (size_t)(hi64 >> 4);
#endif

    size_t base;
    size_t next;

    MEMORY_BASIC_INFORMATION mbi;

    for (next = lo; next < hi;) {
        base = next;
        ZeroMemory(&mbi, sizeof(mbi));
        if (VirtualQuery((PVOID)base, &mbi, sizeof(mbi)) == 0) {
            break;
        }
        if ((mbi.RegionSize & 0xfff) == 0xfff) {
            break;
        }

        if ((size_t)mbi.BaseAddress < lo) {
            base = (size_t)mbi.BaseAddress;
        }

        size_t size = ((size_t)mbi.BaseAddress + mbi.RegionSize) - base;
        next = (size_t)mbi.BaseAddress + mbi.RegionSize;

        CHAR szType[16];
        TypeToString(mbi.Type, szType, ARRAYSIZE(szType));
        CHAR szState[16];
        StateToString(mbi.State, szState, ARRAYSIZE(szState));
        CHAR szProtect[16];
        ProtectToString(mbi.Protect, szProtect, ARRAYSIZE(szProtect));
        CHAR szAllocProtect[16];
        ProtectToString(mbi.AllocationProtect, szAllocProtect, ARRAYSIZE(szAllocProtect));

        CHAR szFile[MAX_PATH];
        szFile[0] = '\0';
        DWORD cb = 0;
        PCHAR pszFile = szFile;

        if (base == (size_t)mbi.AllocationBase) {
            next = NextAt(base);

            cb = GetMappedFileNameA(GetCurrentProcess(),
                                    mbi.AllocationBase, szFile, ARRAYSIZE(szFile));
            if (cb > 0) {
                for (DWORD c = 0; c < cb; c++) {
                    szFile[c] = (char)toupper(szFile[c]);
                }
                szFile[cb] = '\0';
            }
            else {
                szFile[0] = '\0';
            }
            if ((pszFile = strrchr(szFile, '\\')) == NULL) {
                pszFile = szFile;
            }
            else {
                pszFile++;
            }
        }

        printf("%c %12zx %12zx: %3s %3s %4s %3s : %s\n",
               " *"[base == (size_t)mbi.AllocationBase],
               base,
               size,
               szType,
               szState,
               szProtect,
               szAllocProtect,
               pszFile);
    }
    return TRUE;
}

//////////////////////////////////////////////////////////////////////////////

__declspec(dllimport) DWORD WINAPI Dll1Function(DWORD Value);
__declspec(dllimport) DWORD WINAPI Dll2Function(DWORD Value);
__declspec(dllimport) DWORD WINAPI Dll3Function(DWORD Value);
__declspec(dllimport) DWORD WINAPI Dll4Function(DWORD Value);
__declspec(dllimport) DWORD WINAPI Dll5Function(DWORD Value);
__declspec(dllimport) DWORD WINAPI Dll6Function(DWORD Value);
__declspec(dllimport) DWORD WINAPI Dll7Function(DWORD Value);
__declspec(dllimport) DWORD WINAPI Dll8Function(DWORD Value);
__declspec(dllimport) DWORD WINAPI Dll9Function(DWORD Value);

static LONG dwCountDll1 = 0;
static LONG dwCountDll2 = 0;
static LONG dwCountDll3 = 0;
static LONG dwCountDll4 = 0;
static LONG dwCountDll5 = 0;
static LONG dwCountDll6 = 0;
static LONG dwCountDll7 = 0;
static LONG dwCountDll8 = 0;
static LONG dwCountDll9 = 0;

static DWORD (WINAPI * TrueDll1Function)(DWORD Value) = Dll1Function;
static DWORD (WINAPI * TrueDll2Function)(DWORD Value) = Dll2Function;
static DWORD (WINAPI * TrueDll3Function)(DWORD Value) = Dll3Function;
static DWORD (WINAPI * TrueDll4Function)(DWORD Value) = Dll4Function;
static DWORD (WINAPI * TrueDll5Function)(DWORD Value) = Dll5Function;
static DWORD (WINAPI * TrueDll6Function)(DWORD Value) = Dll6Function;
static DWORD (WINAPI * TrueDll7Function)(DWORD Value) = Dll7Function;
static DWORD (WINAPI * TrueDll8Function)(DWORD Value) = Dll8Function;
static DWORD (WINAPI * TrueDll9Function)(DWORD Value) = Dll9Function;

DWORD WINAPI MineDll1Function(DWORD Value)
{
    Value = TrueDll1Function(Value);
    InterlockedIncrement(&dwCountDll1);

    return Value;
}

DWORD WINAPI MineDll2Function(DWORD Value)
{
    Value = TrueDll2Function(Value);
    InterlockedIncrement(&dwCountDll2);

    return Value;
}

DWORD WINAPI MineDll3Function(DWORD Value)
{
    Value = TrueDll3Function(Value);
    InterlockedIncrement(&dwCountDll3);

    return Value;
}

DWORD WINAPI MineDll4Function(DWORD Value)
{
    Value = TrueDll4Function(Value);
    InterlockedIncrement(&dwCountDll4);

    return Value;
}

DWORD WINAPI MineDll5Function(DWORD Value)
{
    Value = TrueDll5Function(Value);
    InterlockedIncrement(&dwCountDll5);

    return Value;
}

DWORD WINAPI MineDll6Function(DWORD Value)
{
    Value = TrueDll6Function(Value);
    InterlockedIncrement(&dwCountDll6);

    return Value;
}

DWORD WINAPI MineDll7Function(DWORD Value)
{
    Value = TrueDll7Function(Value);
    InterlockedIncrement(&dwCountDll7);

    return Value;
}

DWORD WINAPI MineDll8Function(DWORD Value)
{
    Value = TrueDll8Function(Value);
    InterlockedIncrement(&dwCountDll8);

    return Value;
}

DWORD WINAPI MineDll9Function(DWORD Value)
{
    Value = TrueDll9Function(Value);
    InterlockedIncrement(&dwCountDll9);

    return Value;
}

void Reserve(ULONG_PTR addr, ULONG_PTR size)
{
    PVOID mem = VirtualAlloc((PVOID)addr, size, MEM_RESERVE, PAGE_NOACCESS);
    if (mem != (PVOID)addr) {
        printf("*** Reservation failed: %p != %p\n", mem, (PVOID)addr);
    }
}

int WINAPI WinMain(HINSTANCE hinst, HINSTANCE hprev, LPSTR lpszCmdLine, int nCmdShow)
{
    (void)hinst;
    (void)hprev;
    (void)lpszCmdLine;
    (void)nCmdShow;
    DWORD error = NO_ERROR;

    size_t Dll1 = (size_t)LoadLibraryA("tdll1x" DETOURS_STRINGIFY(DETOURS_BITS) ".dll");
    size_t Dll2 = (size_t)LoadLibraryA("tdll2x" DETOURS_STRINGIFY(DETOURS_BITS) ".dll");
    size_t Dll3 = (size_t)LoadLibraryA("tdll3x" DETOURS_STRINGIFY(DETOURS_BITS) ".dll");
    size_t Dll4 = (size_t)LoadLibraryA("tdll4x" DETOURS_STRINGIFY(DETOURS_BITS) ".dll");
    size_t Dll5 = (size_t)LoadLibraryA("tdll5x" DETOURS_STRINGIFY(DETOURS_BITS) ".dll");
    size_t Dll6 = (size_t)LoadLibraryA("tdll6x" DETOURS_STRINGIFY(DETOURS_BITS) ".dll");
    size_t Dll7 = (size_t)LoadLibraryA("tdll7x" DETOURS_STRINGIFY(DETOURS_BITS) ".dll");
    size_t Dll8 = (size_t)LoadLibraryA("tdll8x" DETOURS_STRINGIFY(DETOURS_BITS) ".dll");
    size_t Dll9 = (size_t)LoadLibraryA("tdll9x" DETOURS_STRINGIFY(DETOURS_BITS) ".dll");

    size_t DllEnd = RoundUpRegion(NextAt(Dll1));
    ULONG_PTR DllSize = (DllEnd - Dll1);

    (void)Dll6;
    (void)Dll7;
    (void)Dll8;

    // Force allocation below moving lower.
    Reserve(Dll1 - 0x40000000, 0x40000000);
    Reserve(Dll1 - 0x40100000, 0x00100000);
    Reserve(Dll1 - 0x40110000, 0x00010000);
    Reserve(Dll1 - 0x40120000, 0x00001000);
    Reserve(Dll1 + DllSize, 0x80000000 - DllSize);

    // Force allocation above moving higher.
    Reserve(Dll2 - 0x80000000, 0x80000000);
    Reserve(Dll2 + DllSize, 0x40000000);
    Reserve(Dll2 + 0x40000000 + DllSize, 0x00100000);
    Reserve(Dll2 + 0x40100000 + DllSize, 0x00010000);
    Reserve(Dll2 + 0x40110000 + DllSize, 0x00001000);

    // Force allocation below moving higher.
    Reserve(Dll3 - 0x80000000, 0x40000000);
    Reserve(Dll3 - 0x40000000, 0x00100000);
    Reserve(Dll3 - 0x3ff00000, 0x00010000);
    Reserve(Dll3 - 0x3fef0000, 0x00001000);
    Reserve(Dll3 + DllSize, 0x80000000 - DllSize);

    // Force allocation above moving lower.
    Reserve(Dll4 - 0x80000000, 0x80000000);
    Reserve(Dll4 + 0x40000000, 0x40000000);
    Reserve(Dll4 + 0x3ff00000, 0x00100000);
    Reserve(Dll4 + 0x3fef0000, 0x00010000);
    Reserve(Dll4 + 0x3fee0000, 0x00001000);

    // Force allocation above and below.
    Reserve(Dll5 - 0x7ff00000, 0x7ff00000);
    Reserve(Dll9 + DllSize, 0x7fe00000);

    DetourTransactionBegin();
    DetourUpdateThread(GetCurrentThread());
    DetourAttach(&(PVOID&)TrueDll1Function, MineDll1Function);
    error = DetourTransactionCommit();
    if (error != NO_ERROR) {
      failed:
        printf("talloc.exe: Error detouring functions: %ld\n", error);
        exit(1);
    }

    DetourTransactionBegin();
    DetourUpdateThread(GetCurrentThread());
    DetourAttach(&(PVOID&)TrueDll2Function, MineDll2Function);
    error = DetourTransactionCommit();
    if (error != NO_ERROR) {
        goto failed;
    }

    DetourTransactionBegin();
    DetourUpdateThread(GetCurrentThread());
    DetourAttach(&(PVOID&)TrueDll3Function, MineDll3Function);
    error = DetourTransactionCommit();
    if (error != NO_ERROR) {
        goto failed;
    }

    DetourTransactionBegin();
    DetourUpdateThread(GetCurrentThread());
    DetourAttach(&(PVOID&)TrueDll4Function, MineDll4Function);
    error = DetourTransactionCommit();
    if (error != NO_ERROR) {
        goto failed;
    }

    DetourTransactionBegin();
    DetourUpdateThread(GetCurrentThread());
    DetourAttach(&(PVOID&)TrueDll5Function, MineDll5Function);
    error = DetourTransactionCommit();
    if (error != NO_ERROR) {
        goto failed;
    }

    DetourTransactionBegin();
    DetourUpdateThread(GetCurrentThread());
    DetourAttach(&(PVOID&)TrueDll6Function, MineDll6Function);
    error = DetourTransactionCommit();
    if (error != NO_ERROR) {
        goto failed;
    }

    DetourTransactionBegin();
    DetourUpdateThread(GetCurrentThread());
    DetourAttach(&(PVOID&)TrueDll7Function, MineDll7Function);
    error = DetourTransactionCommit();
    if (error != NO_ERROR) {
        goto failed;
    }

    DetourTransactionBegin();
    DetourUpdateThread(GetCurrentThread());
    DetourAttach(&(PVOID&)TrueDll8Function, MineDll8Function);
    error = DetourTransactionCommit();
    if (error != NO_ERROR) {
        goto failed;
    }

    DetourTransactionBegin();
    DetourUpdateThread(GetCurrentThread());
    DetourAttach(&(PVOID&)TrueDll9Function, MineDll9Function);
    error = DetourTransactionCommit();
    if (error != NO_ERROR) {
        goto failed;
    }

    printf("talloc.exe: Detoured functions.\n");
    printf("\n");

    DumpProcessHeaders();
    printf("%-47s %17zx\n", "Exe:", (size_t)GetModuleHandleW(NULL));
    DumpProcess(0x100000000, 0x200000000);
    printf("%-47s %17zx\n", "Dll1:", Dll1);
    DumpProcess(0x200000000, 0x300000000);
    printf("%-47s %17zx\n", "Dll2:", Dll2);
    DumpProcess(0x300000000, 0x400000000);
    printf("%-47s %17zx\n", "Dll3:", Dll3);
    DumpProcess(0x400000000, 0x500000000);
    printf("%-47s %17zx\n", "Dll4:", Dll4);
    DumpProcess(0x500000000, 0x600000000);
    printf("%-47s %17zx\n", "Dll5:", Dll5);
    DumpProcess(0x600000000, 0x700000000);
    fflush(stdout);

    Dll1Function(1);
    Dll2Function(2);
    Dll2Function(3);
    Dll3Function(4);
    Dll3Function(5);
    Dll3Function(6);
    Dll4Function(7);
    Dll5Function(8);
    Dll6Function(9);
    Dll7Function(10);
    Dll8Function(10);
    Dll9Function(10);

    DetourTransactionBegin();
    DetourUpdateThread(GetCurrentThread());
    DetourDetach(&(PVOID&)TrueDll1Function, MineDll1Function);
    DetourDetach(&(PVOID&)TrueDll2Function, MineDll2Function);
    DetourDetach(&(PVOID&)TrueDll3Function, MineDll3Function);
    DetourDetach(&(PVOID&)TrueDll4Function, MineDll4Function);
    DetourDetach(&(PVOID&)TrueDll5Function, MineDll5Function);
    DetourDetach(&(PVOID&)TrueDll6Function, MineDll6Function);
    DetourDetach(&(PVOID&)TrueDll7Function, MineDll7Function);
    DetourDetach(&(PVOID&)TrueDll8Function, MineDll8Function);
    DetourDetach(&(PVOID&)TrueDll9Function, MineDll9Function);
    error = DetourTransactionCommit();
    if (error != NO_ERROR) {
        goto failed;
    }

    printf("\n");
    printf("talloc.exe: %ld calls to Dll1Function\n", dwCountDll1);
    fflush(stdout);

    return 0;
}

//
///////////////////////////////////////////////////////////////// End of File.

```

`samples/talloc/tdll1x.cpp`:

```cpp
//////////////////////////////////////////////////////////////////////////////
//
//  Detours Test Program (tdll1x.cpp of talloc.exe/tdll1x.dll)
//
//  Microsoft Research Detours Package
//
//  Copyright (c) Microsoft Corporation.  All rights reserved.
//

//////////////////////////////////////////////////////////////////// DLL Stuff
//
__declspec(dllexport) unsigned long __stdcall Dll1Function(unsigned long Value)
{
    return Value + 1;
}

///////////////////////////////////////////////////////////////// End of File.

```

`samples/talloc/tdll2x.cpp`:

```cpp
//////////////////////////////////////////////////////////////////////////////
//
//  Detours Test Program (tdll2x.cpp of talloc.exe/tdll2x.dll)
//
//  Microsoft Research Detours Package
//
//  Copyright (c) Microsoft Corporation.  All rights reserved.
//

//////////////////////////////////////////////////////////////////// DLL Stuff
//
__declspec(dllexport) unsigned long __stdcall Dll2Function(unsigned long Value)
{
    return Value + 1;
}

///////////////////////////////////////////////////////////////// End of File.

```

`samples/talloc/tdll3x.cpp`:

```cpp
//////////////////////////////////////////////////////////////////////////////
//
//  Detours Test Program (tdll3x.cpp of talloc.exe/tdll3x.dll)
//
//  Microsoft Research Detours Package
//
//  Copyright (c) Microsoft Corporation.  All rights reserved.
//

//////////////////////////////////////////////////////////////////// DLL Stuff
//
__declspec(dllexport) unsigned long __stdcall Dll3Function(unsigned long Value)
{
    return Value + 1;
}

///////////////////////////////////////////////////////////////// End of File.

```

`samples/talloc/tdll4x.cpp`:

```cpp
//////////////////////////////////////////////////////////////////////////////
//
//  Detours Test Program (tdll4x.cpp of talloc.exe/tdll4x.dll)
//
//  Microsoft Research Detours Package
//
//  Copyright (c) Microsoft Corporation.  All rights reserved.
//

//////////////////////////////////////////////////////////////////// DLL Stuff
//
__declspec(dllexport) unsigned long __stdcall Dll4Function(unsigned long Value)
{
    return Value + 1;
}

///////////////////////////////////////////////////////////////// End of File.

```

`samples/talloc/tdll5x.cpp`:

```cpp
//////////////////////////////////////////////////////////////////////////////
//
//  Detours Test Program (tdll5x.cpp of talloc.exe/tdll5x.dll)
//
//  Microsoft Research Detours Package
//
//  Copyright (c) Microsoft Corporation.  All rights reserved.
//

//////////////////////////////////////////////////////////////////// DLL Stuff
//
__declspec(dllexport) unsigned long __stdcall Dll5Function(unsigned long Value)
{
    return Value + 1;
}

///////////////////////////////////////////////////////////////// End of File.

```

`samples/talloc/tdll6x.cpp`:

```cpp
//////////////////////////////////////////////////////////////////////////////
//
//  Detours Test Program (tdll6x.cpp of talloc.exe/tdll6x.dll)
//
//  Microsoft Research Detours Package
//
//  Copyright (c) Microsoft Corporation.  All rights reserved.
//

//////////////////////////////////////////////////////////////////// DLL Stuff
//
__declspec(dllexport) unsigned long __stdcall Dll6Function(unsigned long Value)
{
    return Value + 1;
}

///////////////////////////////////////////////////////////////// End of File.

```

`samples/talloc/tdll7x.cpp`:

```cpp
//////////////////////////////////////////////////////////////////////////////
//
//  Detours Test Program (tdll7x.cpp of talloc.exe/tdll7x.dll)
//
//  Microsoft Research Detours Package
//
//  Copyright (c) Microsoft Corporation.  All rights reserved.
//

//////////////////////////////////////////////////////////////////// DLL Stuff
//
__declspec(dllexport) unsigned long __stdcall Dll7Function(unsigned long Value)
{
    return Value + 1;
}

///////////////////////////////////////////////////////////////// End of File.

```

`samples/talloc/tdll8x.cpp`:

```cpp
//////////////////////////////////////////////////////////////////////////////
//
//  Detours Test Program (tdll8x.cpp of talloc.exe/tdll8x.dll)
//
//  Microsoft Research Detours Package
//
//  Copyright (c) Microsoft Corporation.  All rights reserved.
//

//////////////////////////////////////////////////////////////////// DLL Stuff
//
__declspec(dllexport) unsigned long __stdcall Dll8Function(unsigned long Value)
{
    return Value + 1;
}

///////////////////////////////////////////////////////////////// End of File.

```

`samples/talloc/tdll9x.cpp`:

```cpp
//////////////////////////////////////////////////////////////////////////////
//
//  Detours Test Program (tdll9x.cpp of talloc.exe/tdll9x.dll)
//
//  Microsoft Research Detours Package
//
//  Copyright (c) Microsoft Corporation.  All rights reserved.
//

//////////////////////////////////////////////////////////////////// DLL Stuff
//
__declspec(dllexport) unsigned long __stdcall Dll9Function(unsigned long Value)
{
    return Value + 1;
}

///////////////////////////////////////////////////////////////// End of File.

```

`samples/traceapi/Makefile`:

```
##############################################################################
##
##  Utility to trace Win32 APIs.
##
##  Microsoft Research Detours Package
##
##  Copyright (c) Microsoft Corporation.  All rights reserved.
##

!include ..\common.mak

LIBS=$(LIBS) kernel32.lib gdi32.lib user32.lib shell32.lib advapi32.lib ole32.lib ws2_32.lib

##############################################################################

all: dirs \
    $(BIND)\trcapi$(DETOURS_BITS).dll \
    $(BIND)\testapi.exe \
!IF $(DETOURS_SOURCE_BROWSING)==1
    $(OBJD)\trcapi$(DETOURS_BITS).bsc \
    $(OBJD)\testapi.bsc \
!ENDIF
    option

##############################################################################

clean:
    -del *~ test.txt 2>nul
    -del $(BIND)\trcapi*.* $(BIND)\testapi.* 2>nul
    -rmdir /q /s $(OBJD) 2>nul

realclean: clean
    -rmdir /q /s $(OBJDS) 2>nul

dirs:
    @if not exist $(BIND) mkdir $(BIND) && echo.   Created $(BIND)
    @if not exist $(OBJD) mkdir $(OBJD) && echo.   Created $(OBJD)

$(OBJD)\trcapi.obj : trcapi.cpp _win32.cpp

$(OBJD)\trcapi.res : trcapi.rc

$(BIND)\trcapi$(DETOURS_BITS).dll: $(OBJD)\trcapi.obj $(OBJD)\trcapi.res $(DEPS)
    cl /LD $(CFLAGS) /Fe$@ /Fd$(@R).pdb \
        $(OBJD)\trcapi.obj $(OBJD)\trcapi.res \
        /link $(LINKFLAGS) /release /subsystem:console \
        /export:DetourFinishHelperProcess,@1,NONAME \
        $(LIBS)

$(OBJD)\trcapi$(DETOURS_BITS).bsc : $(OBJD)\trcapi.obj
    bscmake /v /n /o $@ $(OBJD)\trcapi.sbr

$(OBJD)\testapi.obj : testapi.cpp trcapi.cpp _win32.cpp

$(BIND)\testapi.exe : $(OBJD)\testapi.obj $(DEPS)
    cl $(CFLAGS) /Fe$@ /Fd$(@R).pdb $(OBJD)\testapi.obj \
        /link $(LINKFLAGS) $(LIBS) \
        /subsystem:console /fixed:no

$(OBJD)\testapi.bsc : $(OBJD)\testapi.obj
    bscmake /v /n /o $@ $(OBJD)\testapi.sbr

############################################### Install non-bit-size binaries.

!IF "$(DETOURS_OPTION_PROCESSOR)" != ""

$(OPTD)\trcapi$(DETOURS_OPTION_BITS).dll:
$(OPTD)\trcapi$(DETOURS_OPTION_BITS).pdb:

$(BIND)\trcapi$(DETOURS_OPTION_BITS).dll : $(OPTD)\trcapi$(DETOURS_OPTION_BITS).dll
    @if exist $? copy /y $? $(BIND) >nul && echo $@ copied from $(DETOURS_OPTION_PROCESSOR).
$(BIND)\trcapi$(DETOURS_OPTION_BITS).pdb : $(OPTD)\trcapi$(DETOURS_OPTION_BITS).pdb
    @if exist $? copy /y $? $(BIND) >nul && echo $@ copied from $(DETOURS_OPTION_PROCESSOR).

option: \
    $(BIND)\trcapi$(DETOURS_OPTION_BITS).dll \
    $(BIND)\trcapi$(DETOURS_OPTION_BITS).pdb \

!ELSE

option:

!ENDIF

##############################################################################

test: all
    @echo -------- Logging output to test.txt ------------
    start $(BIND)\syelogd.exe /o test.txt
    $(BIND)\sleep5.exe 1
    @echo -------- Should load trcapi$(DETOURS_BITS).dll dynamically using withdll.exe ------------
    $(BIND)\withdll -d:$(BIND)\trcapi$(DETOURS_BITS).dll $(BIND)\sleepold.exe
    @echo -------- Log from syelog -------------
    type test.txt

debug: all
    @echo -------- Logging output to test.txt ------------
    start $(BIND)\syelogd.exe /o test.txt
    $(BIND)\sleep5.exe 1
    @echo -------- Should load trcapi$(DETOURS_BITS).dll dynamically using withdll.exe ------------
    windbg -o -g -G $(BIND)\withdll -d:$(BIND)\trcapi$(DETOURS_BITS).dll $(BIND)\sleepold.exe
    @echo -------- Log from syelog -------------
    type test.txt

calc: all
    @echo -------- Logging output to test.txt ------------
    start $(BIND)\syelogd.exe /q /o test.txt
    $(BIND)\sleep5.exe 1
    @echo -------- Should load trcapi$(DETOURS_BITS).dll dynamically using withdll.exe ------------
    $(BIND)\withdll -d:$(BIND)\trcapi$(DETOURS_BITS).dll $(SYSTEMROOT)\System32\calc.exe
    @echo -------- Log from syelog -------------
    wc test.txt

explorer: all
    @echo -------- Logging output to test.txt ------------
    start $(BIND)\syelogd.exe /q /o test.txt
    $(BIND)\sleep5.exe 1
    @echo -------- Should load trcapi$(DETOURS_BITS).dll dynamically using withdll.exe ------------
    $(BIND)\withdll -d:$(BIND)\trcapi$(DETOURS_BITS).dll $(SYSTEMROOT)\explorer.exe
    @echo -------- Log from syelog -------------
    wc test.txt

wordpad: all
    @echo -------- Logging output to test.txt ------------
    start $(BIND)\syelogd.exe /q /o test.txt
    $(BIND)\sleep5.exe 1
    @echo -------- Should load trcapi$(DETOURS_BITS).dll dynamically using withdll.exe ------------
    $(BIND)\withdll -d:$(BIND)\trcapi$(DETOURS_BITS).dll $(PROGRAMFILES)\Windows NT\Accessories\wordpad.exe
    @echo -------- Log from syelog -------------
    wc test.txt

notepad: all
    @echo -------- Logging output to test.txt ------------
    start $(BIND)\syelogd.exe /q /o test.txt
    $(BIND)\sleep5.exe 1
    @echo -------- Should load trcapi$(DETOURS_BITS).dll dynamically using withdll.exe ------------
    $(BIND)\withdll -d:$(BIND)\trcapi$(DETOURS_BITS).dll $(SYSTEMROOT)\notepad.exe
    @echo -------- Log from syelog -------------
    wc test.txt

ie: all
    @echo -------- Logging output to test.txt ------------
    start $(BIND)\syelogd.exe /q /o test.txt
    $(BIND)\sleep5.exe 1
    @echo -------- Should load trcapi$(DETOURS_BITS).dll dynamically using withdll.exe ------------
    windbg -g -G -o $(BIND)\withdll -d:$(BIND)\trcapi$(DETOURS_BITS).dll "$(PROGRAMFILES)\Internet Explorer\iexplore.exe"
    @echo -------- Log from syelog -------------
    wc test.txt

ws: all
    $(BIND)\withdll -d:$(BIND)\trcapi$(DETOURS_BITS).dll $(BIND)\WebServiceTester.exe

################################################################# End of File.

```

`samples/traceapi/_win32.cpp`:

```cpp
//////////////////////////////////////////////////////////////////////////////
//
//  Detours Test Program (_win32.cpp of traceapi.dll)
//
//  Microsoft Research Detours Package
//
//  Copyright (c) Microsoft Corporation.  All rights reserved.
//

///////////////////////////////////////////////////////////////// Trampolines.
//
int (__stdcall * Real_AbortDoc)(HDC a0)
    = AbortDoc;

BOOL (__stdcall * Real_AbortPath)(HDC a0)
    = AbortPath;

HKL (__stdcall * Real_ActivateKeyboardLayout)(HKL a0,
                                              UINT a1)
    = ActivateKeyboardLayout;

ATOM (__stdcall * Real_AddAtomA)(LPCSTR a0)
    = AddAtomA;

ATOM (__stdcall * Real_AddAtomW)(LPCWSTR a0)
    = AddAtomW;

int (__stdcall * Real_AddFontResourceA)(LPCSTR a0)
    = AddFontResourceA;

int (__stdcall * Real_AddFontResourceW)(LPCWSTR a0)
    = AddFontResourceW;

BOOL (__stdcall * Real_AdjustWindowRect)(LPRECT a0,
                                         DWORD a1,
                                         BOOL a2)
    = AdjustWindowRect;

BOOL (__stdcall * Real_AdjustWindowRectEx)(LPRECT a0,
                                           DWORD a1,
                                           BOOL a2,
                                           DWORD a3)
    = AdjustWindowRectEx;

BOOL (__stdcall * Real_AllocConsole)(void)
    = AllocConsole;

BOOL (__stdcall * Real_AngleArc)(HDC a0,
                                 int a1,
                                 int a2,
                                 DWORD a3,
                                 FLOAT a4,
                                 FLOAT a5)
    = AngleArc;

BOOL (__stdcall * Real_AnimatePalette)(HPALETTE a0,
                                       UINT a1,
                                       UINT a2,
                                       CONST PALETTEENTRY* a3)
    = AnimatePalette;

BOOL (__stdcall * Real_AnyPopup)(void)
    = AnyPopup;

BOOL (__stdcall * Real_AppendMenuA)(HMENU a0,
                                    UINT a1,
                                    UINT_PTR a2,
                                    LPCSTR a3)
    = AppendMenuA;

BOOL (__stdcall * Real_AppendMenuW)(HMENU a0,
                                    UINT a1,
                                    UINT_PTR a2,
                                    LPCWSTR a3)
    = AppendMenuW;

BOOL (__stdcall * Real_Arc)(HDC a0,
                            int a1,
                            int a2,
                            int a3,
                            int a4,
                            int a5,
                            int a6,
                            int a7,
                            int a8)
    = Arc;

BOOL (__stdcall * Real_ArcTo)(HDC a0,
                              int a1,
                              int a2,
                              int a3,
                              int a4,
                              int a5,
                              int a6,
                              int a7,
                              int a8)
    = ArcTo;

BOOL (__stdcall * Real_AreFileApisANSI)(void)
    = AreFileApisANSI;

UINT (__stdcall * Real_ArrangeIconicWindows)(HWND a0)
    = ArrangeIconicWindows;

BOOL (__stdcall * Real_AttachThreadInput)(DWORD a0,
                                          DWORD a1,
                                          BOOL a2)
    = AttachThreadInput;

BOOL (__stdcall * Real_BackupRead)(HANDLE a0,
                                   LPBYTE a1,
                                   DWORD a2,
                                   LPDWORD a3,
                                   BOOL a4,
                                   BOOL a5,
                                   LPVOID* a6)
    = BackupRead;

BOOL (__stdcall * Real_BackupSeek)(HANDLE a0,
                                   DWORD a1,
                                   DWORD a2,
                                   LPDWORD a3,
                                   LPDWORD a4,
                                   LPVOID* a5)
    = BackupSeek;

BOOL (__stdcall * Real_BackupWrite)(HANDLE a0,
                                    LPBYTE a1,
                                    DWORD a2,
                                    LPDWORD a3,
                                    BOOL a4,
                                    BOOL a5,
                                    LPVOID* a6)
    = BackupWrite;

BOOL (__stdcall * Real_Beep)(DWORD a0,
                             DWORD a1)
    = Beep;

HDWP (__stdcall * Real_BeginDeferWindowPos)(int a0)
    = BeginDeferWindowPos;

HDC (__stdcall * Real_BeginPaint)(HWND a0,
                                  LPPAINTSTRUCT a1)
    = BeginPaint;

BOOL (__stdcall * Real_BeginPath)(HDC a0)
    = BeginPath;

HANDLE (__stdcall * Real_BeginUpdateResourceA)(LPCSTR a0,
                                               BOOL a1)
    = BeginUpdateResourceA;

HANDLE (__stdcall * Real_BeginUpdateResourceW)(LPCWSTR a0,
                                               BOOL a1)
    = BeginUpdateResourceW;

HRESULT (__stdcall * Real_BindMoniker)(IMoniker* a0,
                                       DWORD a1,
                                       CONST IID& a2,
                                       LPVOID* a3)
    = BindMoniker;

BOOL (__stdcall * Real_BitBlt)(HDC a0,
                               int a1,
                               int a2,
                               int a3,
                               int a4,
                               HDC a5,
                               int a6,
                               int a7,
                               DWORD a8)
    = BitBlt;

BOOL (__stdcall * Real_BringWindowToTop)(HWND a0)
    = BringWindowToTop;

long (__stdcall * Real_BroadcastSystemMessageA)(DWORD a0,
                                                LPDWORD a1,
                                                UINT a2,
                                                WPARAM a3,
                                                LPARAM a4)
    = BroadcastSystemMessageA;

long (__stdcall * Real_BroadcastSystemMessageW)(DWORD a0,
                                                LPDWORD a1,
                                                UINT a2,
                                                WPARAM a3,
                                                LPARAM a4)
    = BroadcastSystemMessageW;

BOOL (__stdcall * Real_BuildCommDCBA)(LPCSTR a0,
                                      LPDCB a1)
    = BuildCommDCBA;

BOOL (__stdcall * Real_BuildCommDCBAndTimeoutsA)(LPCSTR a0,
                                                 LPDCB a1,
                                                 LPCOMMTIMEOUTS a2)
    = BuildCommDCBAndTimeoutsA;

BOOL (__stdcall * Real_BuildCommDCBAndTimeoutsW)(LPCWSTR a0,
                                                 LPDCB a1,
                                                 LPCOMMTIMEOUTS a2)
    = BuildCommDCBAndTimeoutsW;

BOOL (__stdcall * Real_BuildCommDCBW)(LPCWSTR a0,
                                      LPDCB a1)
    = BuildCommDCBW;

HRESULT (__stdcall * Real_CLSIDFromProgID)(LPCOLESTR a0,
                                           LPGUID a1)
    = CLSIDFromProgID;

#ifdef _WIN32_WINNT_WIN7
HRESULT (__stdcall * Real_CLSIDFromString)(LPCOLESTR a0,
                                           LPGUID a1)
    = CLSIDFromString;
#else
HRESULT (__stdcall * Real_CLSIDFromString)(LPOLESTR a0,
                                           LPGUID a1)
    = CLSIDFromString;
#endif

BOOL (__stdcall * Real_CallMsgFilterA)(LPMSG a0,
                                       int a1)
    = CallMsgFilterA;

BOOL (__stdcall * Real_CallMsgFilterW)(LPMSG a0,
                                       int a1)
    = CallMsgFilterW;

BOOL (__stdcall * Real_CallNamedPipeA)(LPCSTR a0,
                                       LPVOID a1,
                                       DWORD a2,
                                       LPVOID a3,
                                       DWORD a4,
                                       LPDWORD a5,
                                       DWORD a6)
    = CallNamedPipeA;

BOOL (__stdcall * Real_CallNamedPipeW)(LPCWSTR a0,
                                       LPVOID a1,
                                       DWORD a2,
                                       LPVOID a3,
                                       DWORD a4,
                                       LPDWORD a5,
                                       DWORD a6)
    = CallNamedPipeW;

LRESULT (__stdcall * Real_CallNextHookEx)(HHOOK a0,
                                          int a1,
                                          WPARAM a2,
                                          LPARAM a3)
    = CallNextHookEx;

LRESULT (__stdcall * Real_CallWindowProcA)(WNDPROC a0,
                                           HWND a1,
                                           UINT a2,
                                           WPARAM a3,
                                           LPARAM a4)
    = CallWindowProcA;

LRESULT (__stdcall * Real_CallWindowProcW)(WNDPROC a0,
                                           HWND a1,
                                           UINT a2,
                                           WPARAM a3,
                                           LPARAM a4)
    = CallWindowProcW;

BOOL (__stdcall * Real_CancelDC)(HDC a0)
    = CancelDC;

BOOL (__stdcall * Real_CancelIo)(HANDLE a0)
    = CancelIo;

BOOL (__stdcall * Real_CancelWaitableTimer)(HANDLE a0)
    = CancelWaitableTimer;

WORD (__stdcall * Real_CascadeWindows)(HWND a0,
                                       UINT a1,
                                       CONST RECT* a2,
                                       UINT a3,
                                       CONST HWND * a4)
    = CascadeWindows;

BOOL (__stdcall * Real_ChangeClipboardChain)(HWND a0,
                                             HWND a1)
    = ChangeClipboardChain;

LONG (__stdcall * Real_ChangeDisplaySettingsA)(LPDEVMODEA a0,
                                               DWORD a1)
    = ChangeDisplaySettingsA;

LONG (__stdcall * Real_ChangeDisplaySettingsExA)(LPCSTR a0,
                                                 LPDEVMODEA a1,
                                                 HWND a2,
                                                 DWORD a3,
                                                 LPVOID a4)
    = ChangeDisplaySettingsExA;

LONG (__stdcall * Real_ChangeDisplaySettingsExW)(LPCWSTR a0,
                                                 LPDEVMODEW a1,
                                                 HWND a2,
                                                 DWORD a3,
                                                 LPVOID a4)
    = ChangeDisplaySettingsExW;

LONG (__stdcall * Real_ChangeDisplaySettingsW)(LPDEVMODEW a0,
                                               DWORD a1)
    = ChangeDisplaySettingsW;

BOOL (__stdcall * Real_ChangeMenuA)(HMENU a0,
                                    UINT a1,
                                    LPCSTR a2,
                                    UINT a3,
                                    UINT a4)
    = ChangeMenuA;

BOOL (__stdcall * Real_ChangeMenuW)(HMENU a0,
                                    UINT a1,
                                    LPCWSTR a2,
                                    UINT a3,
                                    UINT a4)
    = ChangeMenuW;

LPSTR (__stdcall * Real_CharLowerA)(LPSTR a0)
    = CharLowerA;

DWORD (__stdcall * Real_CharLowerBuffA)(LPSTR a0,
                                        DWORD a1)
    = CharLowerBuffA;

DWORD (__stdcall * Real_CharLowerBuffW)(LPWSTR a0,
                                        DWORD a1)
    = CharLowerBuffW;

LPWSTR (__stdcall * Real_CharLowerW)(LPWSTR a0)
    = CharLowerW;

LPSTR (__stdcall * Real_CharNextA)(LPCSTR a0)
    = CharNextA;

LPSTR (__stdcall * Real_CharNextExA)(WORD a0,
                                     LPCSTR a1,
                                     DWORD a2)
    = CharNextExA;

LPWSTR (__stdcall * Real_CharNextW)(LPCWSTR a0)
    = CharNextW;

LPSTR (__stdcall * Real_CharPrevA)(LPCSTR a0,
                                   LPCSTR a1)
    = CharPrevA;

LPSTR (__stdcall * Real_CharPrevExA)(WORD a0,
                                     LPCSTR a1,
                                     LPCSTR a2,
                                     DWORD a3)
    = CharPrevExA;

LPWSTR (__stdcall * Real_CharPrevW)(LPCWSTR a0,
                                    LPCWSTR a1)
    = CharPrevW;

BOOL (__stdcall * Real_CharToOemA)(LPCSTR a0,
                                   LPSTR a1)
    = CharToOemA;

BOOL (__stdcall * Real_CharToOemBuffA)(LPCSTR a0,
                                       LPSTR a1,
                                       DWORD a2)
    = CharToOemBuffA;

BOOL (__stdcall * Real_CharToOemBuffW)(LPCWSTR a0,
                                       LPSTR a1,
                                       DWORD a2)
    = CharToOemBuffW;

BOOL (__stdcall * Real_CharToOemW)(LPCWSTR a0,
                                   LPSTR a1)
    = CharToOemW;

LPSTR (__stdcall * Real_CharUpperA)(LPSTR a0)
    = CharUpperA;

DWORD (__stdcall * Real_CharUpperBuffA)(LPSTR a0,
                                        DWORD a1)
    = CharUpperBuffA;

DWORD (__stdcall * Real_CharUpperBuffW)(LPWSTR a0,
                                        DWORD a1)
    = CharUpperBuffW;

LPWSTR (__stdcall * Real_CharUpperW)(LPWSTR a0)
    = CharUpperW;

BOOL (__stdcall * Real_CheckColorsInGamut)(
                                           HDC a0,
#ifdef GDIPLUS_TS_QUERYVER
                                           LPRGBTRIPLE a1,
#else
                                           LPVOID a1,
#endif
                                           LPVOID a2,
                                           DWORD a3
                                          )
    = CheckColorsInGamut;

BOOL (__stdcall * Real_CheckDlgButton)(HWND a0,
                                       int a1,
                                       UINT a2)
    = CheckDlgButton;

DWORD (__stdcall * Real_CheckMenuItem)(HMENU a0,
                                       UINT a1,
                                       UINT a2)
    = CheckMenuItem;

BOOL (__stdcall * Real_CheckMenuRadioItem)(HMENU a0,
                                           UINT a1,
                                           UINT a2,
                                           UINT a3,
                                           UINT a4)
    = CheckMenuRadioItem;

BOOL (__stdcall * Real_CheckRadioButton)(HWND a0,
                                         int a1,
                                         int a2,
                                         int a3)
    = CheckRadioButton;

HWND (__stdcall * Real_ChildWindowFromPoint)(HWND a0,
                                             POINT a1)
    = ChildWindowFromPoint;

HWND (__stdcall * Real_ChildWindowFromPointEx)(HWND a0,
                                               POINT a1,
                                               UINT a2)
    = ChildWindowFromPointEx;

int (__stdcall * Real_ChoosePixelFormat)(HDC a0,
                                         CONST PIXELFORMATDESCRIPTOR* a1)
    = ChoosePixelFormat;

BOOL (__stdcall * Real_Chord)(HDC a0,
                              int a1,
                              int a2,
                              int a3,
                              int a4,
                              int a5,
                              int a6,
                              int a7,
                              int a8)
    = Chord;

BOOL (__stdcall * Real_ClearCommBreak)(HANDLE a0)
    = ClearCommBreak;

BOOL (__stdcall * Real_ClearCommError)(HANDLE a0,
                                       LPDWORD a1,
                                       LPCOMSTAT a2)
    = ClearCommError;

BOOL (__stdcall * Real_ClientToScreen)(HWND a0,
                                       LPPOINT a1)
    = ClientToScreen;

BOOL (__stdcall * Real_ClipCursor)(CONST RECT* a0)
    = ClipCursor;

BOOL (__stdcall * Real_CloseClipboard)(void)
    = CloseClipboard;

BOOL (__stdcall * Real_CloseDesktop)(HDESK a0)
    = CloseDesktop;

HENHMETAFILE (__stdcall * Real_CloseEnhMetaFile)(HDC a0)
    = CloseEnhMetaFile;

BOOL (__stdcall * Real_CloseFigure)(HDC a0)
    = CloseFigure;

BOOL (__stdcall * Real_CloseHandle)(HANDLE a0)
    = CloseHandle;

HMETAFILE (__stdcall * Real_CloseMetaFile)(HDC a0)
    = CloseMetaFile;

BOOL (__stdcall * Real_CloseWindow)(HWND a0)
    = CloseWindow;

BOOL (__stdcall * Real_CloseWindowStation)(HWINSTA a0)
    = CloseWindowStation;

ULONG (__stdcall * Real_CoAddRefServerProcess)(void)
    = CoAddRefServerProcess;

DWORD (__stdcall * Real_CoBuildVersion)(void)
    = CoBuildVersion;

HRESULT (__stdcall * Real_CoCopyProxy)(IUnknown* a0,
                                       IUnknown** a1)
    = CoCopyProxy;

HRESULT (__stdcall * Real_CoCreateFreeThreadedMarshaler)(LPUNKNOWN a0,
                                                         LPUNKNOWN* a1)
    = CoCreateFreeThreadedMarshaler;

HRESULT (__stdcall * Real_CoCreateGuid)(GUID* a0)
    = CoCreateGuid;

HRESULT (__stdcall * Real_CoCreateInstance)(CONST IID& a0,
                                            LPUNKNOWN a1,
                                            DWORD a2,
                                            CONST IID& a3,
                                            LPVOID* a4)
    = CoCreateInstance;

HRESULT (__stdcall * Real_CoCreateInstanceEx)(CONST IID& a0,
                                              IUnknown* a1,
                                              DWORD a2,
                                              COSERVERINFO* a3,
                                              DWORD a4,
                                              MULTI_QI* a5)
    = CoCreateInstanceEx;

HRESULT (__stdcall * Real_CoDisconnectObject)(LPUNKNOWN a0,
                                              DWORD a1)
    = CoDisconnectObject;

BOOL (__stdcall * Real_CoDosDateTimeToFileTime)(WORD a0,
                                                WORD a1,
                                                FILETIME* a2)
    = CoDosDateTimeToFileTime;

HRESULT (__stdcall * Real_CoFileTimeNow)(FILETIME* a0)
    = CoFileTimeNow;

BOOL (__stdcall * Real_CoFileTimeToDosDateTime)(FILETIME* a0,
                                                LPWORD a1,
                                                LPWORD a2)
    = CoFileTimeToDosDateTime;

void (__stdcall * Real_CoFreeAllLibraries)(void)
    = CoFreeAllLibraries;

void (__stdcall * Real_CoFreeLibrary)(HINSTANCE a0)
    = CoFreeLibrary;

void (__stdcall * Real_CoFreeUnusedLibraries)(void)
    = CoFreeUnusedLibraries;

HRESULT (__stdcall * Real_CoGetCallContext)(CONST IID& a0,
                                            void** a1)
    = CoGetCallContext;

HRESULT (__stdcall * Real_CoGetClassObject)(CONST IID& a0,
                                            DWORD a1,
                                            LPVOID a2,
                                            CONST IID& a3,
                                            LPVOID* a4)
    = CoGetClassObject;

DWORD (__stdcall * Real_CoGetCurrentProcess)(void)
    = CoGetCurrentProcess;

HRESULT (__stdcall * Real_CoGetInstanceFromFile)(COSERVERINFO* a0,
                                                 CLSID* a1,
                                                 IUnknown* a2,
                                                 DWORD a3,
                                                 DWORD a4,
                                                 OLECHAR* a5,
                                                 DWORD a6,
                                                 MULTI_QI* a7)
    = CoGetInstanceFromFile;

HRESULT (__stdcall * Real_CoGetInstanceFromIStorage)(COSERVERINFO* a0,
                                                     CLSID* a1,
                                                     IUnknown* a2,
                                                     DWORD a3,
                                                     IStorage* a4,
                                                     DWORD a5,
                                                     MULTI_QI* a6)
    = CoGetInstanceFromIStorage;

HRESULT (__stdcall * Real_CoGetInterfaceAndReleaseStream)(LPSTREAM a0,
                                                          CONST IID& a1,
                                                          LPVOID* a2)
    = CoGetInterfaceAndReleaseStream;

HRESULT (__stdcall * Real_CoGetMalloc)(DWORD a0,
                                       IMalloc** a1)
    = CoGetMalloc;

HRESULT (__stdcall * Real_CoGetMarshalSizeMax)(ULONG* a0,
                                               CONST IID& a1,
                                               LPUNKNOWN a2,
                                               DWORD a3,
                                               LPVOID a4,
                                               DWORD a5)
    = CoGetMarshalSizeMax;

HRESULT (__stdcall * Real_CoGetObject)(LPCWSTR a0,
                                       BIND_OPTS* a1,
                                       CONST IID& a2,
                                       void** a3)
    = CoGetObject;

HRESULT (__stdcall * Real_CoGetPSClsid)(CONST IID& a0,
                                        CLSID* a1)
    = CoGetPSClsid;

HRESULT (__stdcall * Real_CoGetStandardMarshal)(CONST IID& a0,
                                                LPUNKNOWN a1,
                                                DWORD a2,
                                                LPVOID a3,
                                                DWORD a4,
                                                IMarshal** a5)
    = CoGetStandardMarshal;

HRESULT (__stdcall * Real_CoGetStdMarshalEx)(LPUNKNOWN a0,
                                             DWORD a1,
                                             LPUNKNOWN* a2)
    = CoGetStdMarshalEx;

HRESULT (__stdcall * Real_CoGetTreatAsClass)(CONST IID& a0,
                                             LPGUID a1)
    = CoGetTreatAsClass;

HRESULT (__stdcall * Real_CoImpersonateClient)(void)
    = CoImpersonateClient;

HRESULT (__stdcall * Real_CoInitialize)(LPVOID a0)
    = CoInitialize;

HRESULT (__stdcall * Real_CoInitializeEx)(LPVOID a0,
                                          DWORD a1)
    = CoInitializeEx;

HRESULT (__stdcall * Real_CoInitializeSecurity)(PSECURITY_DESCRIPTOR a0,
                                                LONG a1,
                                                SOLE_AUTHENTICATION_SERVICE* a2,
                                                void* a3,
                                                DWORD a4,
                                                DWORD a5,
                                                void* a6,
                                                DWORD a7,
                                                void* a8)
    = CoInitializeSecurity;

BOOL (__stdcall * Real_CoIsHandlerConnected)(LPUNKNOWN a0)
    = CoIsHandlerConnected;

BOOL (__stdcall * Real_CoIsOle1Class)(CONST IID& a0)
    = CoIsOle1Class;

HINSTANCE (__stdcall * Real_CoLoadLibrary)(LPOLESTR a0,
                                           BOOL a1)
    = CoLoadLibrary;

HRESULT (__stdcall * Real_CoLockObjectExternal)(LPUNKNOWN a0,
                                                BOOL a1,
                                                BOOL a2)
    = CoLockObjectExternal;

HRESULT (__stdcall * Real_CoMarshalHresult)(LPSTREAM a0,
                                            HRESULT a1)
    = CoMarshalHresult;

HRESULT (__stdcall * Real_CoMarshalInterThreadInterfaceInStream)(CONST IID& a0,
                                                                 LPUNKNOWN a1,
                                                                 LPSTREAM* a2)
    = CoMarshalInterThreadInterfaceInStream;

HRESULT (__stdcall * Real_CoMarshalInterface)(LPSTREAM a0,
                                              CONST IID& a1,
                                              LPUNKNOWN a2,
                                              DWORD a3,
                                              LPVOID a4,
                                              DWORD a5)
    = CoMarshalInterface;

HRESULT (__stdcall * Real_CoQueryAuthenticationServices)(DWORD* a0,
                                                         SOLE_AUTHENTICATION_SERVICE** a1)
    = CoQueryAuthenticationServices;

HRESULT (__stdcall * Real_CoQueryClientBlanket)(DWORD* a0,
                                                DWORD* a1,
                                                OLECHAR** a2,
                                                DWORD* a3,
                                                DWORD* a4,
                                                RPC_AUTHZ_HANDLE* a5,
                                                DWORD* a6)
    = CoQueryClientBlanket;

HRESULT (__stdcall * Real_CoQueryProxyBlanket)(IUnknown* a0,
                                               DWORD* a1,
                                               DWORD* a2,
                                               OLECHAR** a3,
                                               DWORD* a4,
                                               DWORD* a5,
                                               RPC_AUTH_IDENTITY_HANDLE* a6,
                                               DWORD* a7)
    = CoQueryProxyBlanket;

HRESULT (__stdcall * Real_CoRegisterChannelHook)(CONST GUID& a0,
                                                 IChannelHook* a1)
    = CoRegisterChannelHook;

HRESULT (__stdcall * Real_CoRegisterClassObject)(CONST IID& a0,
                                                 LPUNKNOWN a1,
                                                 DWORD a2,
                                                 DWORD a3,
                                                 LPDWORD a4)
    = CoRegisterClassObject;

HRESULT (__stdcall * Real_CoRegisterMallocSpy)(IMallocSpy* a0)
    = CoRegisterMallocSpy;

HRESULT (__stdcall * Real_CoRegisterMessageFilter)(LPMESSAGEFILTER a0,
                                                   LPMESSAGEFILTER* a1)
    = CoRegisterMessageFilter;

HRESULT (__stdcall * Real_CoRegisterPSClsid)(CONST IID& a0,
                                             CONST IID& a1)
    = CoRegisterPSClsid;

HRESULT (__stdcall * Real_CoRegisterSurrogate)(LPSURROGATE a0)
    = CoRegisterSurrogate;

HRESULT (__stdcall * Real_CoReleaseMarshalData)(LPSTREAM a0)
    = CoReleaseMarshalData;

ULONG (__stdcall * Real_CoReleaseServerProcess)(void)
    = CoReleaseServerProcess;

HRESULT (__stdcall * Real_CoResumeClassObjects)(void)
    = CoResumeClassObjects;

HRESULT (__stdcall * Real_CoRevertToSelf)(void)
    = CoRevertToSelf;

HRESULT (__stdcall * Real_CoRevokeClassObject)(DWORD a0)
    = CoRevokeClassObject;

HRESULT (__stdcall * Real_CoRevokeMallocSpy)(void)
    = CoRevokeMallocSpy;

HRESULT (__stdcall * Real_CoSetProxyBlanket)(IUnknown* a0,
                                             DWORD a1,
                                             DWORD a2,
                                             OLECHAR* a3,
                                             DWORD a4,
                                             DWORD a5,
                                             RPC_AUTH_IDENTITY_HANDLE a6,
                                             DWORD a7)
    = CoSetProxyBlanket;

HRESULT (__stdcall * Real_CoSuspendClassObjects)(void)
    = CoSuspendClassObjects;

HRESULT (__stdcall * Real_CoSwitchCallContext)(IUnknown* a0,
                                               IUnknown** a1)
    = CoSwitchCallContext;

LPVOID (__stdcall * Real_CoTaskMemAlloc)(SIZE_T a0)
    = CoTaskMemAlloc;

void (__stdcall * Real_CoTaskMemFree)(LPVOID a0)
    = CoTaskMemFree;

LPVOID (__stdcall * Real_CoTaskMemRealloc)(LPVOID a0,
                                           SIZE_T a1)
    = CoTaskMemRealloc;

HRESULT (__stdcall * Real_CoTreatAsClass)(CONST IID& a0,
                                          CONST IID& a1)
    = CoTreatAsClass;

void (__stdcall * Real_CoUninitialize)(void)
    = CoUninitialize;

HRESULT (__stdcall * Real_CoUnmarshalHresult)(LPSTREAM a0,
                                              HRESULT* a1)
    = CoUnmarshalHresult;

HRESULT (__stdcall * Real_CoUnmarshalInterface)(LPSTREAM a0,
                                                CONST IID& a1,
                                                LPVOID* a2)
    = CoUnmarshalInterface;

BOOL (__stdcall * Real_ColorMatchToTarget)(HDC a0,
                                           HDC a1,
                                           DWORD a2)
    = ColorMatchToTarget;

int (__stdcall * Real_CombineRgn)(HRGN a0,
                                  HRGN a1,
                                  HRGN a2,
                                  int a3)
    = CombineRgn;

BOOL (__stdcall * Real_CombineTransform)(LPXFORM a0,
                                         CONST XFORM* a1,
                                         CONST XFORM* a2)
    = CombineTransform;

BOOL (__stdcall * Real_CommConfigDialogA)(LPCSTR a0,
                                          HWND a1,
                                          LPCOMMCONFIG a2)
    = CommConfigDialogA;

BOOL (__stdcall * Real_CommConfigDialogW)(LPCWSTR a0,
                                          HWND a1,
                                          LPCOMMCONFIG a2)
    = CommConfigDialogW;

LONG (__stdcall * Real_CompareFileTime)(CONST FILETIME* a0,
                                        CONST FILETIME* a1)
    = CompareFileTime;

int (__stdcall * Real_CompareStringA)(LCID a0,
                                      DWORD a1,
                                      LPCSTR a2,
                                      int a3,
                                      LPCSTR a4,
                                      int a5)
    = CompareStringA;

int (__stdcall * Real_CompareStringW)(LCID a0,
                                      DWORD a1,
                                      LPCWSTR a2,
                                      int a3,
                                      LPCWSTR a4,
                                      int a5)
    = CompareStringW;

BOOL (__stdcall * Real_ConnectNamedPipe)(HANDLE a0,
                                         LPOVERLAPPED a1)
    = ConnectNamedPipe;

#if !defined(DETOURS_ARM)
BOOL (__stdcall * Real_ContinueDebugEvent)(DWORD a0,
                                           DWORD a1,
                                           DWORD a2)
    = ContinueDebugEvent;
#endif // !DETOURS_ARM

LCID (__stdcall * Real_ConvertDefaultLocale)(LCID a0)
    = ConvertDefaultLocale;

LPVOID (__stdcall * Real_ConvertThreadToFiber)(LPVOID a0)
    = ConvertThreadToFiber;

int (__stdcall * Real_CopyAcceleratorTableA)(HACCEL a0,
                                             LPACCEL a1,
                                             int a2)
    = CopyAcceleratorTableA;

int (__stdcall * Real_CopyAcceleratorTableW)(HACCEL a0,
                                             LPACCEL a1,
                                             int a2)
    = CopyAcceleratorTableW;

HENHMETAFILE (__stdcall * Real_CopyEnhMetaFileA)(HENHMETAFILE a0,
                                                 LPCSTR a1)
    = CopyEnhMetaFileA;

HENHMETAFILE (__stdcall * Real_CopyEnhMetaFileW)(HENHMETAFILE a0,
                                                 LPCWSTR a1)
    = CopyEnhMetaFileW;

BOOL (__stdcall * Real_CopyFileA)(LPCSTR a0,
                                  LPCSTR a1,
                                  BOOL a2)
    = CopyFileA;

BOOL (__stdcall * Real_CopyFileExA)(LPCSTR a0,
                                    LPCSTR a1,
                                    LPPROGRESS_ROUTINE a2,
                                    LPVOID a3,
                                    LPBOOL a4,
                                    DWORD a5)
    = CopyFileExA;

BOOL (__stdcall * Real_CopyFileExW)(LPCWSTR a0,
                                    LPCWSTR a1,
                                    LPPROGRESS_ROUTINE a2,
                                    LPVOID a3,
                                    LPBOOL a4,
                                    DWORD a5)
    = CopyFileExW;

BOOL (__stdcall * Real_CopyFileW)(LPCWSTR a0,
                                  LPCWSTR a1,
                                  BOOL a2)
    = CopyFileW;

HICON (__stdcall * Real_CopyIcon)(HICON a0)
    = CopyIcon;

HANDLE (__stdcall * Real_CopyImage)(HANDLE a0,
                                    UINT a1,
                                    int a2,
                                    int a3,
                                    UINT a4)
    = CopyImage;

HMETAFILE (__stdcall * Real_CopyMetaFileA)(HMETAFILE a0,
                                           LPCSTR a1)
    = CopyMetaFileA;

HMETAFILE (__stdcall * Real_CopyMetaFileW)(HMETAFILE a0,
                                           LPCWSTR a1)
    = CopyMetaFileW;

BOOL (__stdcall * Real_CopyRect)(LPRECT a0,
                                 CONST RECT* a1)
    = CopyRect;

int (__stdcall * Real_CountClipboardFormats)(void)
    = CountClipboardFormats;

HACCEL (__stdcall * Real_CreateAcceleratorTableA)(LPACCEL a0,
                                                  int a1)
    = CreateAcceleratorTableA;

HACCEL (__stdcall * Real_CreateAcceleratorTableW)(LPACCEL a0,
                                                  int a1)
    = CreateAcceleratorTableW;

HRESULT (__stdcall * Real_CreateAntiMoniker)(IMoniker** a0)
    = CreateAntiMoniker;

HRESULT (__stdcall * Real_CreateBindCtx)(DWORD a0,
                                         IBindCtx** a1)
    = CreateBindCtx;

HBITMAP (__stdcall * Real_CreateBitmap)(int a0,
                                        int a1,
                                        UINT a2,
                                        UINT a3,
                                        CONST void* a4)
    = CreateBitmap;

HBITMAP (__stdcall * Real_CreateBitmapIndirect)(CONST BITMAP* a0)
    = CreateBitmapIndirect;

HBRUSH (__stdcall * Real_CreateBrushIndirect)(CONST LOGBRUSH* a0)
    = CreateBrushIndirect;

BOOL (__stdcall * Real_CreateCaret)(HWND a0,
                                    HBITMAP a1,
                                    int a2,
                                    int a3)
    = CreateCaret;

HRESULT (__stdcall * Real_CreateClassMoniker)(CONST IID& a0,
                                              IMoniker** a1)
    = CreateClassMoniker;

HCOLORSPACE (__stdcall * Real_CreateColorSpaceA)(LPLOGCOLORSPACEA a0)
    = CreateColorSpaceA;

HCOLORSPACE (__stdcall * Real_CreateColorSpaceW)(LPLOGCOLORSPACEW a0)
    = CreateColorSpaceW;

HBITMAP (__stdcall * Real_CreateCompatibleBitmap)(HDC a0,
                                                  int a1,
                                                  int a2)
    = CreateCompatibleBitmap;

HDC (__stdcall * Real_CreateCompatibleDC)(HDC a0)
    = CreateCompatibleDC;

HANDLE (__stdcall * Real_CreateConsoleScreenBuffer)(DWORD a0,
                                                    DWORD a1,
                                                    CONST SECURITY_ATTRIBUTES* a2,
                                                    DWORD a3,
                                                    LPVOID a4)
    = CreateConsoleScreenBuffer;

HCURSOR (__stdcall * Real_CreateCursor)(HINSTANCE a0,
                                        int a1,
                                        int a2,
                                        int a3,
                                        int a4,
                                        CONST void* a5,
                                        CONST void* a6)
    = CreateCursor;

HDC (__stdcall * Real_CreateDCA)(LPCSTR a0,
                                 LPCSTR a1,
                                 LPCSTR a2,
                                 CONST DEVMODEA * a3)
    = CreateDCA;

HDC (__stdcall * Real_CreateDCW)(LPCWSTR a0,
                                 LPCWSTR a1,
                                 LPCWSTR a2,
                                 CONST DEVMODEW * a3)
    = CreateDCW;

HBRUSH (__stdcall * Real_CreateDIBPatternBrush)(HGLOBAL a0,
                                                UINT a1)
    = CreateDIBPatternBrush;

HBRUSH (__stdcall * Real_CreateDIBPatternBrushPt)(CONST void* a0,
                                                  UINT a1)
    = CreateDIBPatternBrushPt;

HBITMAP (__stdcall * Real_CreateDIBSection)(HDC a0,
                                            CONST BITMAPINFO* a1,
                                            UINT a2,
                                            void** a3,
                                            HANDLE a4,
                                            DWORD a5)
    = CreateDIBSection;

HBITMAP (__stdcall * Real_CreateDIBitmap)(HDC a0,
                                          CONST BITMAPINFOHEADER* a1,
                                          DWORD a2,
                                          CONST void* a3,
                                          CONST BITMAPINFO* a4,
                                          UINT a5)
    = CreateDIBitmap;

HRESULT (__stdcall * Real_CreateDataAdviseHolder)(LPDATAADVISEHOLDER* a0)
    = CreateDataAdviseHolder;

HRESULT (__stdcall * Real_CreateDataCache)(LPUNKNOWN a0,
                                           CONST IID& a1,
                                           CONST IID& a2,
                                           LPVOID* a3)
    = CreateDataCache;

#if _MSC_VER < 1300
HDESK (__stdcall * Real_CreateDesktopA)(LPSTR a0,
                                        LPSTR a1,
                                        LPDEVMODEA a2,
                                        DWORD a3,
                                        ACCESS_MASK a4,
                                        LPSECURITY_ATTRIBUTES a5)
    = CreateDesktopA;
#else
HDESK (__stdcall * Real_CreateDesktopA)(LPCSTR a0,
                                        LPCSTR a1,
                                        LPDEVMODEA a2,
                                        DWORD a3,
                                        ACCESS_MASK a4,
                                        LPSECURITY_ATTRIBUTES a5)
    = CreateDesktopA;

#endif

#if _MSC_VER < 1300
HDESK (__stdcall * Real_CreateDesktopW)(LPWSTR a0,
                                        LPWSTR a1,
                                        LPDEVMODEW a2,
                                        DWORD a3,
                                        ACCESS_MASK a4,
                                        LPSECURITY_ATTRIBUTES a5)
    = CreateDesktopW;
#else
HDESK (__stdcall * Real_CreateDesktopW)(LPCWSTR a0,
                                        LPCWSTR a1,
                                        LPDEVMODEW a2,
                                        DWORD a3,
                                        ACCESS_MASK a4,
                                        LPSECURITY_ATTRIBUTES a5)
    = CreateDesktopW;
#endif

HWND (__stdcall * Real_CreateDialogIndirectParamA)(HINSTANCE a0,
                                                   LPCDLGTEMPLATEA a1,
                                                   HWND a2,
                                                   DLGPROC a3,
                                                   LPARAM a4)
    = CreateDialogIndirectParamA;

HWND (__stdcall * Real_CreateDialogIndirectParamW)(HINSTANCE a0,
                                                   LPCDLGTEMPLATEW a1,
                                                   HWND a2,
                                                   DLGPROC a3,
                                                   LPARAM a4)
    = CreateDialogIndirectParamW;

HWND (__stdcall * Real_CreateDialogParamA)(HINSTANCE a0,
                                           LPCSTR a1,
                                           HWND a2,
                                           DLGPROC a3,
                                           LPARAM a4)
    = CreateDialogParamA;

HWND (__stdcall * Real_CreateDialogParamW)(HINSTANCE a0,
                                           LPCWSTR a1,
                                           HWND a2,
                                           DLGPROC a3,
                                           LPARAM a4)
    = CreateDialogParamW;

BOOL (__stdcall * Real_CreateDirectoryA)(LPCSTR a0,
                                         LPSECURITY_ATTRIBUTES a1)
    = CreateDirectoryA;

BOOL (__stdcall * Real_CreateDirectoryExA)(LPCSTR a0,
                                           LPCSTR a1,
                                           LPSECURITY_ATTRIBUTES a2)
    = CreateDirectoryExA;

BOOL (__stdcall * Real_CreateDirectoryExW)(LPCWSTR a0,
                                           LPCWSTR a1,
                                           LPSECURITY_ATTRIBUTES a2)
    = CreateDirectoryExW;

BOOL (__stdcall * Real_CreateDirectoryW)(LPCWSTR a0,
                                         LPSECURITY_ATTRIBUTES a1)
    = CreateDirectoryW;

HBITMAP (__stdcall * Real_CreateDiscardableBitmap)(HDC a0,
                                                   int a1,
                                                   int a2)
    = CreateDiscardableBitmap;

HRGN (__stdcall * Real_CreateEllipticRgn)(int a0,
                                          int a1,
                                          int a2,
                                          int a3)
    = CreateEllipticRgn;

HRGN (__stdcall * Real_CreateEllipticRgnIndirect)(CONST RECT* a0)
    = CreateEllipticRgnIndirect;

HDC (__stdcall * Real_CreateEnhMetaFileA)(HDC a0,
                                          LPCSTR a1,
                                          CONST RECT* a2,
                                          LPCSTR a3)
    = CreateEnhMetaFileA;

HDC (__stdcall * Real_CreateEnhMetaFileW)(HDC a0,
                                          LPCWSTR a1,
                                          CONST RECT* a2,
                                          LPCWSTR a3)
    = CreateEnhMetaFileW;

HANDLE (__stdcall * Real_CreateEventA)(LPSECURITY_ATTRIBUTES a0,
                                       BOOL a1,
                                       BOOL a2,
                                       LPCSTR a3)
    = CreateEventA;

HANDLE (__stdcall * Real_CreateEventW)(LPSECURITY_ATTRIBUTES a0,
                                       BOOL a1,
                                       BOOL a2,
                                       LPCWSTR a3)
    = CreateEventW;

LPVOID (__stdcall * Real_CreateFiber)(ULONG_PTR a0,
                                      LPFIBER_START_ROUTINE a1,
                                      LPVOID a2)
    = CreateFiber;

HANDLE (__stdcall * Real_CreateFileA)(LPCSTR a0,
                                      DWORD a1,
                                      DWORD a2,
                                      LPSECURITY_ATTRIBUTES a3,
                                      DWORD a4,
                                      DWORD a5,
                                      HANDLE a6)
    = CreateFileA;

HANDLE (__stdcall * Real_CreateFileMappingA)(HANDLE a0,
                                             LPSECURITY_ATTRIBUTES a1,
                                             DWORD a2,
                                             DWORD a3,
                                             DWORD a4,
                                             LPCSTR a5)
    = CreateFileMappingA;

HANDLE (__stdcall * Real_CreateFileMappingW)(HANDLE a0,
                                             LPSECURITY_ATTRIBUTES a1,
                                             DWORD a2,
                                             DWORD a3,
                                             DWORD a4,
                                             LPCWSTR a5)
    = CreateFileMappingW;

HRESULT (__stdcall * Real_CreateFileMoniker)(LPCOLESTR a0,
                                             IMoniker** a1)
    = CreateFileMoniker;

HANDLE (__stdcall * Real_CreateFileW)(LPCWSTR a0,
                                      DWORD a1,
                                      DWORD a2,
                                      LPSECURITY_ATTRIBUTES a3,
                                      DWORD a4,
                                      DWORD a5,
                                      HANDLE a6)
    = CreateFileW;

HFONT (__stdcall * Real_CreateFontA)(int a0,
                                     int a1,
                                     int a2,
                                     int a3,
                                     int a4,
                                     DWORD a5,
                                     DWORD a6,
                                     DWORD a7,
                                     DWORD a8,
                                     DWORD a9,
                                     DWORD a10,
                                     DWORD a11,
                                     DWORD a12,
                                     LPCSTR a13)
    = CreateFontA;

HFONT (__stdcall * Real_CreateFontIndirectA)(CONST LOGFONTA* a0)
    = CreateFontIndirectA;

HFONT (__stdcall * Real_CreateFontIndirectW)(CONST LOGFONTW* a0)
    = CreateFontIndirectW;

HFONT (__stdcall * Real_CreateFontW)(int a0,
                                     int a1,
                                     int a2,
                                     int a3,
                                     int a4,
                                     DWORD a5,
                                     DWORD a6,
                                     DWORD a7,
                                     DWORD a8,
                                     DWORD a9,
                                     DWORD a10,
                                     DWORD a11,
                                     DWORD a12,
                                     LPCWSTR a13)
    = CreateFontW;

HRESULT (__stdcall * Real_CreateGenericComposite)(IMoniker* a0,
                                                  IMoniker* a1,
                                                  IMoniker** a2)
    = CreateGenericComposite;

HPALETTE (__stdcall * Real_CreateHalftonePalette)(HDC a0)
    = CreateHalftonePalette;

HBRUSH (__stdcall * Real_CreateHatchBrush)(int a0,
                                           COLORREF a1)
    = CreateHatchBrush;

HDC (__stdcall * Real_CreateICA)(LPCSTR a0,
                                 LPCSTR a1,
                                 LPCSTR a2,
                                 CONST DEVMODEA* a3)
    = CreateICA;

HDC (__stdcall * Real_CreateICW)(LPCWSTR a0,
                                 LPCWSTR a1,
                                 LPCWSTR a2,
                                 CONST DEVMODEW* a3)
    = CreateICW;

HRESULT (__stdcall * Real_CreateILockBytesOnHGlobal)(HGLOBAL a0,
                                                     BOOL a1,
                                                     ILockBytes** a2)
    = CreateILockBytesOnHGlobal;

HICON (__stdcall * Real_CreateIcon)(HINSTANCE a0,
                                    int a1,
                                    int a2,
                                    BYTE a3,
                                    BYTE a4,
                                    CONST BYTE* a5,
                                    CONST BYTE* a6)
    = CreateIcon;

HICON (__stdcall * Real_CreateIconFromResource)(PBYTE a0,
                                                DWORD a1,
                                                BOOL a2,
                                                DWORD a3)
    = CreateIconFromResource;

HICON (__stdcall * Real_CreateIconFromResourceEx)(PBYTE a0,
                                                  DWORD a1,
                                                  BOOL a2,
                                                  DWORD a3,
                                                  int a4,
                                                  int a5,
                                                  UINT a6)
    = CreateIconFromResourceEx;

HICON (__stdcall * Real_CreateIconIndirect)(PICONINFO a0)
    = CreateIconIndirect;

HANDLE (__stdcall * Real_CreateIoCompletionPort)(HANDLE a0,
                                                 HANDLE a1,
                                                 ULONG_PTR a2,
                                                 DWORD a3)
    = CreateIoCompletionPort;

HRESULT (__stdcall * Real_CreateItemMoniker)(LPCOLESTR a0,
                                             LPCOLESTR a1,
                                             IMoniker** a2)
    = CreateItemMoniker;

#if _MSC_VER < 1300
HWND (__stdcall * Real_CreateMDIWindowA)(LPSTR a0,
                                         LPSTR a1,
                                         DWORD a2,
                                         int a3,
                                         int a4,
                                         int a5,
                                         int a6,
                                         HWND a7,
                                         HINSTANCE a8,
                                         LPARAM a9)
    = CreateMDIWindowA;
#else
HWND (__stdcall * Real_CreateMDIWindowA)(LPCSTR a0,
                                         LPCSTR a1,
                                         DWORD a2,
                                         int a3,
                                         int a4,
                                         int a5,
                                         int a6,
                                         HWND a7,
                                         HINSTANCE a8,
                                         LPARAM a9)
    = CreateMDIWindowA;
#endif

#if _MSC_VER < 1300
HWND (__stdcall * Real_CreateMDIWindowW)(LPWSTR a0,
                                         LPWSTR a1,
                                         DWORD a2,
                                         int a3,
                                         int a4,
                                         int a5,
                                         int a6,
                                         HWND a7,
                                         HINSTANCE a8,
                                         LPARAM a9)
    = CreateMDIWindowW;
#else
HWND (__stdcall * Real_CreateMDIWindowW)(LPCWSTR a0,
                                         LPCWSTR a1,
                                         DWORD a2,
                                         int a3,
                                         int a4,
                                         int a5,
                                         int a6,
                                         HWND a7,
                                         HINSTANCE a8,
                                         LPARAM a9)
    = CreateMDIWindowW;
#endif

HANDLE (__stdcall * Real_CreateMailslotA)(LPCSTR a0,
                                          DWORD a1,
                                          DWORD a2,
                                          LPSECURITY_ATTRIBUTES a3)
    = CreateMailslotA;

HANDLE (__stdcall * Real_CreateMailslotW)(LPCWSTR a0,
                                          DWORD a1,
                                          DWORD a2,
                                          LPSECURITY_ATTRIBUTES a3)
    = CreateMailslotW;

HMENU (__stdcall * Real_CreateMenu)(void)
    = CreateMenu;

HDC (__stdcall * Real_CreateMetaFileA)(LPCSTR a0)
    = CreateMetaFileA;

HDC (__stdcall * Real_CreateMetaFileW)(LPCWSTR a0)
    = CreateMetaFileW;

HANDLE (__stdcall * Real_CreateMutexA)(LPSECURITY_ATTRIBUTES a0,
                                       BOOL a1,
                                       LPCSTR a2)
    = CreateMutexA;

HANDLE (__stdcall * Real_CreateMutexW)(LPSECURITY_ATTRIBUTES a0,
                                       BOOL a1,
                                       LPCWSTR a2)
    = CreateMutexW;

HANDLE (__stdcall * Real_CreateNamedPipeA)(LPCSTR a0,
                                           DWORD a1,
                                           DWORD a2,
                                           DWORD a3,
                                           DWORD a4,
                                           DWORD a5,
                                           DWORD a6,
                                           LPSECURITY_ATTRIBUTES a7)
    = CreateNamedPipeA;

HANDLE (__stdcall * Real_CreateNamedPipeW)(LPCWSTR a0,
                                           DWORD a1,
                                           DWORD a2,
                                           DWORD a3,
                                           DWORD a4,
                                           DWORD a5,
                                           DWORD a6,
                                           LPSECURITY_ATTRIBUTES a7)
    = CreateNamedPipeW;

HRESULT (__stdcall * Real_CreateOleAdviseHolder)(LPOLEADVISEHOLDER* a0)
    = CreateOleAdviseHolder;

HPALETTE (__stdcall * Real_CreatePalette)(CONST LOGPALETTE* a0)
    = CreatePalette;

HBRUSH (__stdcall * Real_CreatePatternBrush)(HBITMAP a0)
    = CreatePatternBrush;

HPEN (__stdcall * Real_CreatePen)(int a0,
                                  int a1,
                                  COLORREF a2)
    = CreatePen;

HPEN (__stdcall * Real_CreatePenIndirect)(CONST LOGPEN* a0)
    = CreatePenIndirect;

BOOL (__stdcall * Real_CreatePipe)(PHANDLE a0,
                                   PHANDLE a1,
                                   LPSECURITY_ATTRIBUTES a2,
                                   DWORD a3)
    = CreatePipe;

HRESULT (__stdcall * Real_CreatePointerMoniker)(LPUNKNOWN a0,
                                                IMoniker** a1)
    = CreatePointerMoniker;

HRGN (__stdcall * Real_CreatePolyPolygonRgn)(CONST POINT* a0,
                                             CONST INT* a1,
                                             int a2,
                                             int a3)
    = CreatePolyPolygonRgn;

HRGN (__stdcall * Real_CreatePolygonRgn)(CONST POINT* a0,
                                         int a1,
                                         int a2)
    = CreatePolygonRgn;

HMENU (__stdcall * Real_CreatePopupMenu)(void)
    = CreatePopupMenu;

BOOL (__stdcall * Real_CreateProcessA)(LPCSTR a0,
                                       LPSTR a1,
                                       LPSECURITY_ATTRIBUTES a2,
                                       LPSECURITY_ATTRIBUTES a3,
                                       BOOL a4,
                                       DWORD a5,
                                       LPVOID a6,
                                       LPCSTR a7,
                                       LPSTARTUPINFOA a8,
                                       LPPROCESS_INFORMATION a9)
    = CreateProcessA;

BOOL (__stdcall * Real_CreateProcessW)(LPCWSTR a0,
                                       LPWSTR a1,
                                       LPSECURITY_ATTRIBUTES a2,
                                       LPSECURITY_ATTRIBUTES a3,
                                       BOOL a4,
                                       DWORD a5,
                                       LPVOID a6,
                                       LPCWSTR a7,
                                       LPSTARTUPINFOW a8,
                                       LPPROCESS_INFORMATION a9)
    = CreateProcessW;

BOOL (__stdcall * Real_CreateProcessAsUserA)(
  __in_opt     HANDLE hToken,
  __in_opt     LPCSTR lpApplicationName,
  __inout_opt  LPSTR lpCommandLine,
  __in_opt     LPSECURITY_ATTRIBUTES lpProcessAttributes,
  __in_opt     LPSECURITY_ATTRIBUTES lpThreadAttributes,
  __in         BOOL bInheritHandles,
  __in         DWORD dwCreationFlags,
  __in_opt     LPVOID lpEnvironment,
  __in_opt     LPCSTR lpCurrentDirectory,
  __in         LPSTARTUPINFOA lpStartupInfo,
  __out        LPPROCESS_INFORMATION lpProcessInformation
                                       ) = CreateProcessAsUserA;

BOOL (__stdcall * Real_CreateProcessAsUserW)(
  __in_opt     HANDLE hToken,
  __in_opt     LPCWSTR lpApplicationName,
  __inout_opt  LPWSTR lpCommandLine,
  __in_opt     LPSECURITY_ATTRIBUTES lpProcessAttributes,
  __in_opt     LPSECURITY_ATTRIBUTES lpThreadAttributes,
  __in         BOOL bInheritHandles,
  __in         DWORD dwCreationFlags,
  __in_opt     LPVOID lpEnvironment,
  __in_opt     LPCWSTR lpCurrentDirectory,
  __in         LPSTARTUPINFOW lpStartupInfo,
  __out        LPPROCESS_INFORMATION lpProcessInformation
) = CreateProcessAsUserW;

#if(_WIN32_WINNT >= 0x0500)

BOOL (WINAPI * Real_CreateProcessWithLogonW)(
  __in         LPCWSTR lpUsername,
  __in_opt     LPCWSTR lpDomain,
  __in         LPCWSTR lpPassword,
  __in         DWORD dwLogonFlags,
  __in_opt     LPCWSTR lpApplicationName,
  __inout_opt  LPWSTR lpCommandLine,
  __in         DWORD dwCreationFlags,
  __in_opt     LPVOID lpEnvironment,
  __in_opt     LPCWSTR lpCurrentDirectory,
  __in         LPSTARTUPINFOW lpStartupInfo,
  __out        LPPROCESS_INFORMATION lpProcessInfo
) = CreateProcessWithLogonW;

BOOL (WINAPI * Real_CreateProcessWithTokenW)(
  __in         HANDLE hToken,
  __in         DWORD dwLogonFlags,
  __in_opt     LPCWSTR lpApplicationName,
  __inout_opt  LPWSTR lpCommandLine,
  __in         DWORD dwCreationFlags,
  __in_opt     LPVOID lpEnvironment,
  __in_opt     LPCWSTR lpCurrentDirectory,
  __in         LPSTARTUPINFOW lpStartupInfo,
  __out        LPPROCESS_INFORMATION lpProcessInfo
) = CreateProcessWithTokenW;
#endif

HRGN (__stdcall * Real_CreateRectRgn)(int a0,
                                      int a1,
                                      int a2,
                                      int a3)
    = CreateRectRgn;

HRGN (__stdcall * Real_CreateRectRgnIndirect)(CONST RECT* a0)
    = CreateRectRgnIndirect;

HANDLE (__stdcall * Real_CreateRemoteThread)(HANDLE a0,
                                             LPSECURITY_ATTRIBUTES a1,
                                             ULONG_PTR a2,
                                             LPTHREAD_START_ROUTINE a3,
                                             LPVOID a4,
                                             DWORD a5,
                                             LPDWORD a6)
    = CreateRemoteThread;

HRGN (__stdcall * Real_CreateRoundRectRgn)(int a0,
                                           int a1,
                                           int a2,
                                           int a3,
                                           int a4,
                                           int a5)
    = CreateRoundRectRgn;

BOOL (__stdcall * Real_CreateScalableFontResourceA)(DWORD a0,
                                                    LPCSTR a1,
                                                    LPCSTR a2,
                                                    LPCSTR a3)
    = CreateScalableFontResourceA;

BOOL (__stdcall * Real_CreateScalableFontResourceW)(DWORD a0,
                                                    LPCWSTR a1,
                                                    LPCWSTR a2,
                                                    LPCWSTR a3)
    = CreateScalableFontResourceW;

HANDLE (__stdcall * Real_CreateSemaphoreA)(LPSECURITY_ATTRIBUTES a0,
                                           LONG a1,
                                           LONG a2,
                                           LPCSTR a3)
    = CreateSemaphoreA;

HANDLE (__stdcall * Real_CreateSemaphoreW)(LPSECURITY_ATTRIBUTES a0,
                                           LONG a1,
                                           LONG a2,
                                           LPCWSTR a3)
    = CreateSemaphoreW;

HBRUSH (__stdcall * Real_CreateSolidBrush)(COLORREF a0)
    = CreateSolidBrush;

HRESULT (__stdcall * Real_CreateStdProgressIndicator)(HWND a0,
                                                      LPCOLESTR a1,
                                                      IBindStatusCallback* a2,
                                                      IBindStatusCallback** a3)
    = CreateStdProgressIndicator;

HRESULT (__stdcall * Real_CreateStreamOnHGlobal)(HGLOBAL a0,
                                                 BOOL a1,
                                                 LPSTREAM* a2)
    = CreateStreamOnHGlobal;

DWORD (__stdcall * Real_CreateTapePartition)(HANDLE a0,
                                             DWORD a1,
                                             DWORD a2,
                                             DWORD a3)
    = CreateTapePartition;

HANDLE (__stdcall * Real_CreateThread)(LPSECURITY_ATTRIBUTES a0,
                                       ULONG_PTR a1,
                                       LPTHREAD_START_ROUTINE a2,
                                       LPVOID a3,
                                       DWORD a4,
                                       LPDWORD a5)
    = CreateThread;

HANDLE (__stdcall * Real_CreateWaitableTimerA)(LPSECURITY_ATTRIBUTES a0,
                                               BOOL a1,
                                               LPCSTR a2)
    = CreateWaitableTimerA;

HANDLE (__stdcall * Real_CreateWaitableTimerW)(LPSECURITY_ATTRIBUTES a0,
                                               BOOL a1,
                                               LPCWSTR a2)
    = CreateWaitableTimerW;

HWND (__stdcall * Real_CreateWindowExA)(DWORD a0,
                                        LPCSTR a1,
                                        LPCSTR a2,
                                        DWORD a3,
                                        int a4,
                                        int a5,
                                        int a6,
                                        int a7,
                                        HWND a8,
                                        HMENU a9,
                                        HINSTANCE a10,
                                        LPVOID a11)
    = CreateWindowExA;

HWND (__stdcall * Real_CreateWindowExW)(DWORD a0,
                                        LPCWSTR a1,
                                        LPCWSTR a2,
                                        DWORD a3,
                                        int a4,
                                        int a5,
                                        int a6,
                                        int a7,
                                        HWND a8,
                                        HMENU a9,
                                        HINSTANCE a10,
                                        LPVOID a11)
    = CreateWindowExW;

#if _MSC_VER < 1300
HWINSTA (__stdcall * Real_CreateWindowStationA)(LPSTR a0,
                                                DWORD a1,
                                                ACCESS_MASK a2,
                                                LPSECURITY_ATTRIBUTES a3)
    = CreateWindowStationA;
#else
HWINSTA (__stdcall * Real_CreateWindowStationA)(LPCSTR a0,
                                                DWORD a1,
                                                ACCESS_MASK a2,
                                                LPSECURITY_ATTRIBUTES a3)
    = CreateWindowStationA;
#endif

#if _MSC_VER < 1300
HWINSTA (__stdcall * Real_CreateWindowStationW)(LPWSTR a0,
                                                DWORD a1,
                                                ACCESS_MASK a2,
                                                LPSECURITY_ATTRIBUTES a3)
    = CreateWindowStationW;
#else
HWINSTA (__stdcall * Real_CreateWindowStationW)(LPCWSTR a0,
                                                DWORD a1,
                                                ACCESS_MASK a2,
                                                LPSECURITY_ATTRIBUTES a3)
    = CreateWindowStationW;
#endif

BOOL (__stdcall * Real_DPtoLP)(HDC a0,
                               POINT* a1,
                               int a2)
    = DPtoLP;

BOOL (__stdcall * Real_DdeAbandonTransaction)(DWORD a0,
                                              HCONV a1,
                                              DWORD a2)
    = DdeAbandonTransaction;

LPBYTE (__stdcall * Real_DdeAccessData)(HDDEDATA a0,
                                        LPDWORD a1)
    = DdeAccessData;

HDDEDATA (__stdcall * Real_DdeAddData)(HDDEDATA a0,
                                       LPBYTE a1,
                                       DWORD a2,
                                       DWORD a3)
    = DdeAddData;

HDDEDATA (__stdcall * Real_DdeClientTransaction)(LPBYTE a0,
                                                 DWORD a1,
                                                 HCONV a2,
                                                 HSZ a3,
                                                 UINT a4,
                                                 UINT a5,
                                                 DWORD a6,
                                                 LPDWORD a7)
    = DdeClientTransaction;

int (__stdcall * Real_DdeCmpStringHandles)(HSZ a0,
                                           HSZ a1)
    = DdeCmpStringHandles;

HCONV (__stdcall * Real_DdeConnect)(DWORD a0,
                                    HSZ a1,
                                    HSZ a2,
                                    PCONVCONTEXT a3)
    = DdeConnect;

HCONVLIST (__stdcall * Real_DdeConnectList)(DWORD a0,
                                            HSZ a1,
                                            HSZ a2,
                                            HCONVLIST a3,
                                            PCONVCONTEXT a4)
    = DdeConnectList;

HDDEDATA (__stdcall * Real_DdeCreateDataHandle)(DWORD a0,
                                                LPBYTE a1,
                                                DWORD a2,
                                                DWORD a3,
                                                HSZ a4,
                                                UINT a5,
                                                UINT a6)
    = DdeCreateDataHandle;

HSZ (__stdcall * Real_DdeCreateStringHandleA)(DWORD a0,
                                              LPCSTR a1,
                                              int a2)
    = DdeCreateStringHandleA;

HSZ (__stdcall * Real_DdeCreateStringHandleW)(DWORD a0,
                                              LPCWSTR a1,
                                              int a2)
    = DdeCreateStringHandleW;

BOOL (__stdcall * Real_DdeDisconnect)(HCONV a0)
    = DdeDisconnect;

BOOL (__stdcall * Real_DdeDisconnectList)(HCONVLIST a0)
    = DdeDisconnectList;

BOOL (__stdcall * Real_DdeEnableCallback)(DWORD a0,
                                          HCONV a1,
                                          UINT a2)
    = DdeEnableCallback;

BOOL (__stdcall * Real_DdeFreeDataHandle)(HDDEDATA a0)
    = DdeFreeDataHandle;

BOOL (__stdcall * Real_DdeFreeStringHandle)(DWORD a0,
                                            HSZ a1)
    = DdeFreeStringHandle;

DWORD (__stdcall * Real_DdeGetData)(HDDEDATA a0,
                                    LPBYTE a1,
                                    DWORD a2,
                                    DWORD a3)
    = DdeGetData;

UINT (__stdcall * Real_DdeGetLastError)(DWORD a0)
    = DdeGetLastError;

BOOL (__stdcall * Real_DdeImpersonateClient)(HCONV a0)
    = DdeImpersonateClient;

BOOL (__stdcall * Real_DdeKeepStringHandle)(DWORD a0,
                                            HSZ a1)
    = DdeKeepStringHandle;

HDDEDATA (__stdcall * Real_DdeNameService)(DWORD a0,
                                           HSZ a1,
                                           HSZ a2,
                                           UINT a3)
    = DdeNameService;

BOOL (__stdcall * Real_DdePostAdvise)(DWORD a0,
                                      HSZ a1,
                                      HSZ a2)
    = DdePostAdvise;

UINT (__stdcall * Real_DdeQueryConvInfo)(HCONV a0,
                                         DWORD a1,
                                         CONVINFO* a2)
    = DdeQueryConvInfo;

HCONV (__stdcall * Real_DdeQueryNextServer)(HCONVLIST a0,
                                            HCONV a1)
    = DdeQueryNextServer;

DWORD (__stdcall * Real_DdeQueryStringA)(DWORD a0,
                                         HSZ a1,
                                         LPSTR a2,
                                         DWORD a3,
                                         int a4)
    = DdeQueryStringA;

DWORD (__stdcall * Real_DdeQueryStringW)(DWORD a0,
                                         HSZ a1,
                                         LPWSTR a2,
                                         DWORD a3,
                                         int a4)
    = DdeQueryStringW;

HCONV (__stdcall * Real_DdeReconnect)(HCONV a0)
    = DdeReconnect;

BOOL (__stdcall * Real_DdeSetQualityOfService)(HWND a0,
                                               CONST SECURITY_QUALITY_OF_SERVICE* a1,
                                               PSECURITY_QUALITY_OF_SERVICE a2)
    = DdeSetQualityOfService;

BOOL (__stdcall * Real_DdeSetUserHandle)(HCONV a0,
                                         DWORD a1,
                                         ULONG_PTR a2)
    = DdeSetUserHandle;

BOOL (__stdcall * Real_DdeUnaccessData)(HDDEDATA a0)
    = DdeUnaccessData;

BOOL (__stdcall * Real_DdeUninitialize)(DWORD a0)
    = DdeUninitialize;

BOOL (__stdcall * Real_DebugActiveProcess)(DWORD a0)
    = DebugActiveProcess;

BOOL (__stdcall * Real_DebugActiveProcessStop)(DWORD a0)
    = DebugActiveProcessStop;

void (__stdcall * Real_DebugBreak)(void)
    = DebugBreak;

LRESULT (__stdcall * Real_DefDlgProcA)(HWND a0,
                                       UINT a1,
                                       WPARAM a2,
                                       LPARAM a3)
    = DefDlgProcA;

LRESULT (__stdcall * Real_DefDlgProcW)(HWND a0,
                                       UINT a1,
                                       WPARAM a2,
                                       LPARAM a3)
    = DefDlgProcW;

LRESULT (__stdcall * Real_DefFrameProcA)(HWND a0,
                                         HWND a1,
                                         UINT a2,
                                         WPARAM a3,
                                         LPARAM a4)
    = DefFrameProcA;

LRESULT (__stdcall * Real_DefFrameProcW)(HWND a0,
                                         HWND a1,
                                         UINT a2,
                                         WPARAM a3,
                                         LPARAM a4)
    = DefFrameProcW;

LRESULT (__stdcall * Real_DefMDIChildProcA)(HWND a0,
                                            UINT a1,
                                            WPARAM a2,
                                            LPARAM a3)
    = DefMDIChildProcA;

LRESULT (__stdcall * Real_DefMDIChildProcW)(HWND a0,
                                            UINT a1,
                                            WPARAM a2,
                                            LPARAM a3)
    = DefMDIChildProcW;

LRESULT (__stdcall * Real_DefWindowProcA)(HWND a0,
                                          UINT a1,
                                          WPARAM a2,
                                          LPARAM a3)
    = DefWindowProcA;

LRESULT (__stdcall * Real_DefWindowProcW)(HWND a0,
                                          UINT a1,
                                          WPARAM a2,
                                          LPARAM a3)
    = DefWindowProcW;

HDWP (__stdcall * Real_DeferWindowPos)(HDWP a0,
                                       HWND a1,
                                       HWND a2,
                                       int a3,
                                       int a4,
                                       int a5,
                                       int a6,
                                       UINT a7)
    = DeferWindowPos;

BOOL (__stdcall * Real_DefineDosDeviceA)(DWORD a0,
                                         LPCSTR a1,
                                         LPCSTR a2)
    = DefineDosDeviceA;

BOOL (__stdcall * Real_DefineDosDeviceW)(DWORD a0,
                                         LPCWSTR a1,
                                         LPCWSTR a2)
    = DefineDosDeviceW;

ATOM (__stdcall * Real_DeleteAtom)(ATOM a0)
    = DeleteAtom;

BOOL (__stdcall * Real_DeleteColorSpace)(HCOLORSPACE a0)
    = DeleteColorSpace;

BOOL (__stdcall * Real_DeleteDC)(HDC a0)
    = DeleteDC;

BOOL (__stdcall * Real_DeleteEnhMetaFile)(HENHMETAFILE a0)
    = DeleteEnhMetaFile;

void (__stdcall * Real_DeleteFiber)(LPVOID a0)
    = DeleteFiber;

BOOL (__stdcall * Real_DeleteFileA)(LPCSTR a0)
    = DeleteFileA;

BOOL (__stdcall * Real_DeleteFileW)(LPCWSTR a0)
    = DeleteFileW;

BOOL (__stdcall * Real_DeleteMenu)(HMENU a0,
                                   UINT a1,
                                   UINT a2)
    = DeleteMenu;

BOOL (__stdcall * Real_DeleteMetaFile)(HMETAFILE a0)
    = DeleteMetaFile;

BOOL (__stdcall * Real_DeleteObject)(HGDIOBJ a0)
    = DeleteObject;

int (__stdcall * Real_DescribePixelFormat)(HDC a0,
                                           int a1,
                                           UINT a2,
                                           PIXELFORMATDESCRIPTOR* a3)
    = DescribePixelFormat;

BOOL (__stdcall * Real_DestroyAcceleratorTable)(HACCEL a0)
    = DestroyAcceleratorTable;

BOOL (__stdcall * Real_DestroyCaret)(void)
    = DestroyCaret;

BOOL (__stdcall * Real_DestroyCursor)(HCURSOR a0)
    = DestroyCursor;

BOOL (__stdcall * Real_DestroyIcon)(HICON a0)
    = DestroyIcon;

BOOL (__stdcall * Real_DestroyMenu)(HMENU a0)
    = DestroyMenu;

BOOL (__stdcall * Real_DestroyWindow)(HWND a0)
    = DestroyWindow;

BOOL (__stdcall * Real_DeviceIoControl)(HANDLE a0,
                                        DWORD a1,
                                        LPVOID a2,
                                        DWORD a3,
                                        LPVOID a4,
                                        DWORD a5,
                                        LPDWORD a6,
                                        LPOVERLAPPED a7)
    = DeviceIoControl;

INT_PTR (__stdcall * Real_DialogBoxIndirectParamA)(HINSTANCE a0,
                                                   LPCDLGTEMPLATEA a1,
                                                   HWND a2,
                                                   DLGPROC a3,
                                                   LPARAM a4)
    = DialogBoxIndirectParamA;

INT_PTR (__stdcall * Real_DialogBoxIndirectParamW)(HINSTANCE a0,
                                                   LPCDLGTEMPLATEW a1,
                                                   HWND a2,
                                                   DLGPROC a3,
                                                   LPARAM a4)
    = DialogBoxIndirectParamW;

INT_PTR (__stdcall * Real_DialogBoxParamA)(HINSTANCE a0,
                                           LPCSTR a1,
                                           HWND a2,
                                           DLGPROC a3,
                                           LPARAM a4)
    = DialogBoxParamA;

INT_PTR (__stdcall * Real_DialogBoxParamW)(HINSTANCE a0,
                                           LPCWSTR a1,
                                           HWND a2,
                                           DLGPROC a3,
                                           LPARAM a4)
    = DialogBoxParamW;

BOOL (__stdcall * Real_DisableThreadLibraryCalls)(HMODULE a0)
    = DisableThreadLibraryCalls;

BOOL (__stdcall * Real_DisconnectNamedPipe)(HANDLE a0)
    = DisconnectNamedPipe;

LRESULT (__stdcall * Real_DispatchMessageA)(CONST MSG* a0)
    = DispatchMessageA;

LRESULT (__stdcall * Real_DispatchMessageW)(CONST MSG* a0)
    = DispatchMessageW;

int (__stdcall * Real_DlgDirListA)(HWND a0,
                                   LPSTR a1,
                                   int a2,
                                   int a3,
                                   UINT a4)
    = DlgDirListA;

int (__stdcall * Real_DlgDirListComboBoxA)(HWND a0,
                                           LPSTR a1,
                                           int a2,
                                           int a3,
                                           UINT a4)
    = DlgDirListComboBoxA;

int (__stdcall * Real_DlgDirListComboBoxW)(HWND a0,
                                           LPWSTR a1,
                                           int a2,
                                           int a3,
                                           UINT a4)
    = DlgDirListComboBoxW;

int (__stdcall * Real_DlgDirListW)(HWND a0,
                                   LPWSTR a1,
                                   int a2,
                                   int a3,
                                   UINT a4)
    = DlgDirListW;

BOOL (__stdcall * Real_DlgDirSelectComboBoxExA)(HWND a0,
                                                LPSTR a1,
                                                int a2,
                                                int a3)
    = DlgDirSelectComboBoxExA;

BOOL (__stdcall * Real_DlgDirSelectComboBoxExW)(HWND a0,
                                                LPWSTR a1,
                                                int a2,
                                                int a3)
    = DlgDirSelectComboBoxExW;

BOOL (__stdcall * Real_DlgDirSelectExA)(HWND a0,
                                        LPSTR a1,
                                        int a2,
                                        int a3)
    = DlgDirSelectExA;

BOOL (__stdcall * Real_DlgDirSelectExW)(HWND a0,
                                        LPWSTR a1,
                                        int a2,
                                        int a3)
    = DlgDirSelectExW;

HRESULT (__stdcall * Real_DoDragDrop)(IDataObject* a0,
                                      IDropSource* a1,
                                      DWORD a2,
                                      LPDWORD a3)
    = DoDragDrop;

BOOL (__stdcall * Real_DosDateTimeToFileTime)(WORD a0,
                                              WORD a1,
                                              LPFILETIME a2)
    = DosDateTimeToFileTime;

BOOL (__stdcall * Real_DragDetect)(HWND a0,
                                   POINT a1)
    = DragDetect;

DWORD (__stdcall * Real_DragObject)(HWND a0,
                                    HWND a1,
                                    UINT a2,
                                    ULONG_PTR a3,
                                    HCURSOR a4)
    = DragObject;

BOOL (__stdcall * Real_DrawAnimatedRects)(HWND a0,
                                          int a1,
                                          CONST RECT* a2,
                                          CONST RECT* a3)
    = DrawAnimatedRects;

BOOL (__stdcall * Real_DrawCaption)(HWND a0,
                                    HDC a1,
                                    CONST RECT* a2,
                                    UINT a3)
    = DrawCaption;

BOOL (__stdcall * Real_DrawEdge)(HDC a0,
                                 LPRECT a1,
                                 UINT a2,
                                 UINT a3)
    = DrawEdge;

int (__stdcall * Real_DrawEscape)(HDC a0,
                                  int a1,
                                  int a2,
                                  LPCSTR a3)
    = DrawEscape;

BOOL (__stdcall * Real_DrawFocusRect)(HDC a0,
                                      CONST RECT* a1)
    = DrawFocusRect;

BOOL (__stdcall * Real_DrawFrameControl)(HDC a0,
                                         LPRECT a1,
                                         UINT a2,
                                         UINT a3)
    = DrawFrameControl;

BOOL (__stdcall * Real_DrawIcon)(HDC a0,
                                 int a1,
                                 int a2,
                                 HICON a3)
    = DrawIcon;

BOOL (__stdcall * Real_DrawIconEx)(HDC a0,
                                   int a1,
                                   int a2,
                                   HICON a3,
                                   int a4,
                                   int a5,
                                   UINT a6,
                                   HBRUSH a7,
                                   UINT a8)
    = DrawIconEx;

BOOL (__stdcall * Real_DrawMenuBar)(HWND a0)
    = DrawMenuBar;

BOOL (__stdcall * Real_DrawStateA)(HDC a0,
                                   HBRUSH a1,
                                   DRAWSTATEPROC a2,
                                   LPARAM a3,
                                   WPARAM a4,
                                   int a5,
                                   int a6,
                                   int a7,
                                   int a8,
                                   UINT a9)
    = DrawStateA;

BOOL (__stdcall * Real_DrawStateW)(HDC a0,
                                   HBRUSH a1,
                                   DRAWSTATEPROC a2,
                                   LPARAM a3,
                                   WPARAM a4,
                                   int a5,
                                   int a6,
                                   int a7,
                                   int a8,
                                   UINT a9)
    = DrawStateW;

int (__stdcall * Real_DrawTextA)(HDC a0,
                                 LPCSTR a1,
                                 int a2,
                                 LPRECT a3,
                                 UINT a4)
    = DrawTextA;

int (__stdcall * Real_DrawTextExA)(HDC a0,
                                   LPSTR a1,
                                   int a2,
                                   LPRECT a3,
                                   UINT a4,
                                   LPDRAWTEXTPARAMS a5)
    = DrawTextExA;

int (__stdcall * Real_DrawTextExW)(HDC a0,
                                   LPWSTR a1,
                                   int a2,
                                   LPRECT a3,
                                   UINT a4,
                                   LPDRAWTEXTPARAMS a5)
    = DrawTextExW;

int (__stdcall * Real_DrawTextW)(HDC a0,
                                 LPCWSTR a1,
                                 int a2,
                                 LPRECT a3,
                                 UINT a4)
    = DrawTextW;

BOOL (__stdcall * Real_DuplicateHandle)(HANDLE a0,
                                        HANDLE a1,
                                        HANDLE a2,
                                        LPHANDLE a3,
                                        DWORD a4,
                                        BOOL a5,
                                        DWORD a6)
    = DuplicateHandle;

BOOL (__stdcall * Real_Ellipse)(HDC a0,
                                int a1,
                                int a2,
                                int a3,
                                int a4)
    = Ellipse;

BOOL (__stdcall * Real_EmptyClipboard)(void)
    = EmptyClipboard;

BOOL (__stdcall * Real_EnableMenuItem)(HMENU a0,
                                       UINT a1,
                                       UINT a2)
    = EnableMenuItem;

BOOL (__stdcall * Real_EnableScrollBar)(HWND a0,
                                        UINT a1,
                                        UINT a2)
    = EnableScrollBar;

BOOL (__stdcall * Real_EnableWindow)(HWND a0,
                                     BOOL a1)
    = EnableWindow;

BOOL (__stdcall * Real_EndDeferWindowPos)(HDWP a0)
    = EndDeferWindowPos;

BOOL (__stdcall * Real_EndDialog)(HWND a0,
                                  INT_PTR a1)
    = EndDialog;

int (__stdcall * Real_EndDoc)(HDC a0)
    = EndDoc;

int (__stdcall * Real_EndPage)(HDC a0)
    = EndPage;

BOOL (__stdcall * Real_EndPaint)(HWND a0,
                                 CONST PAINTSTRUCT* a1)
    = EndPaint;

BOOL (__stdcall * Real_EndPath)(HDC a0)
    = EndPath;

BOOL (__stdcall * Real_EndUpdateResourceA)(HANDLE a0,
                                           BOOL a1)
    = EndUpdateResourceA;

BOOL (__stdcall * Real_EndUpdateResourceW)(HANDLE a0,
                                           BOOL a1)
    = EndUpdateResourceW;

BOOL (__stdcall * Real_EnumCalendarInfoA)(CALINFO_ENUMPROCA a0,
                                          LCID a1,
                                          CALID a2,
                                          CALTYPE a3)
    = EnumCalendarInfoA;

BOOL (__stdcall * Real_EnumCalendarInfoW)(CALINFO_ENUMPROCW a0,
                                          LCID a1,
                                          CALID a2,
                                          CALTYPE a3)
    = EnumCalendarInfoW;

BOOL (__stdcall * Real_EnumChildWindows)(HWND a0,
                                         WNDENUMPROC a1,
                                         LPARAM a2)
    = EnumChildWindows;

UINT (__stdcall * Real_EnumClipboardFormats)(UINT a0)
    = EnumClipboardFormats;

BOOL (__stdcall * Real_EnumDateFormatsA)(DATEFMT_ENUMPROCA a0,
                                         LCID a1,
                                         DWORD a2)
    = EnumDateFormatsA;

BOOL (__stdcall * Real_EnumDateFormatsW)(DATEFMT_ENUMPROCW a0,
                                         LCID a1,
                                         DWORD a2)
    = EnumDateFormatsW;

BOOL (__stdcall * Real_EnumDesktopWindows)(HDESK a0,
                                           WNDENUMPROC a1,
                                           LPARAM a2)
    = EnumDesktopWindows;

BOOL (__stdcall * Real_EnumDesktopsA)(HWINSTA a0,
                                      DESKTOPENUMPROCA a1,
                                      LPARAM a2)
    = EnumDesktopsA;

BOOL (__stdcall * Real_EnumDesktopsW)(HWINSTA a0,
                                      DESKTOPENUMPROCW a1,
                                      LPARAM a2)
    = EnumDesktopsW;

BOOL (__stdcall * Real_EnumDisplaySettingsA)(LPCSTR a0,
                                             DWORD a1,
                                             LPDEVMODEA a2)
    = EnumDisplaySettingsA;

BOOL (__stdcall * Real_EnumDisplaySettingsW)(LPCWSTR a0,
                                             DWORD a1,
                                             LPDEVMODEW a2)
    = EnumDisplaySettingsW;

BOOL (__stdcall * Real_EnumEnhMetaFile)(HDC a0,
                                        HENHMETAFILE a1,
                                        ENHMFENUMPROC a2,
                                        LPVOID a3,
                                        CONST RECT* a4)
    = EnumEnhMetaFile;

int (__stdcall * Real_EnumFontFamiliesA)(HDC a0,
                                         LPCSTR a1,
                                         FONTENUMPROCA a2,
                                         LPARAM a3)
    = EnumFontFamiliesA;

int (__stdcall * Real_EnumFontFamiliesExA)(HDC a0,
                                           LPLOGFONTA a1,
                                           FONTENUMPROCA a2,
                                           LPARAM a3,
                                           DWORD a4)
    = EnumFontFamiliesExA;

int (__stdcall * Real_EnumFontFamiliesExW)(HDC a0,
                                           LPLOGFONTW a1,
                                           FONTENUMPROCW a2,
                                           LPARAM a3,
                                           DWORD a4)
    = EnumFontFamiliesExW;

int (__stdcall * Real_EnumFontFamiliesW)(HDC a0,
                                         LPCWSTR a1,
                                         FONTENUMPROCW a2,
                                         LPARAM a3)
    = EnumFontFamiliesW;

int (__stdcall * Real_EnumFontsA)(HDC a0,
                                  LPCSTR a1,
                                  FONTENUMPROCA a2,
                                  LPARAM a3)
    = EnumFontsA;

int (__stdcall * Real_EnumFontsW)(HDC a0,
                                  LPCWSTR a1,
                                  FONTENUMPROCW a2,
                                  LPARAM a3)
    = EnumFontsW;

int (__stdcall * Real_EnumICMProfilesA)(HDC a0,
                                        ICMENUMPROCA a1,
                                        LPARAM a2)
    = EnumICMProfilesA;

int (__stdcall * Real_EnumICMProfilesW)(HDC a0,
                                        ICMENUMPROCW a1,
                                        LPARAM a2)
    = EnumICMProfilesW;

BOOL (__stdcall * Real_EnumMetaFile)(HDC a0,
                                     HMETAFILE a1,
                                     MFENUMPROC a2,
                                     LPARAM a3)
    = EnumMetaFile;

int (__stdcall * Real_EnumObjects)(HDC a0,
                                   int a1,
                                   GOBJENUMPROC a2,
                                   LPARAM a3)
    = EnumObjects;

int (__stdcall * Real_EnumPropsA)(HWND a0,
                                  PROPENUMPROCA a1)
    = EnumPropsA;

int (__stdcall * Real_EnumPropsExA)(HWND a0,
                                    PROPENUMPROCEXA a1,
                                    LPARAM a2)
    = EnumPropsExA;

int (__stdcall * Real_EnumPropsExW)(HWND a0,
                                    PROPENUMPROCEXW a1,
                                    LPARAM a2)
    = EnumPropsExW;

int (__stdcall * Real_EnumPropsW)(HWND a0,
                                  PROPENUMPROCW a1)
    = EnumPropsW;

#if _MSC_VER < 1300
BOOL (__stdcall * Real_EnumResourceLanguagesA)(HMODULE a0,
                                               LPCSTR a1,
                                               LPCSTR a2,
                                               ENUMRESLANGPROC a3,
                                               LONG a4)
    = EnumResourceLanguagesA;
#else
BOOL (__stdcall * Real_EnumResourceLanguagesA)(HMODULE a0,
                                               LPCSTR a1,
                                               LPCSTR a2,
                                               ENUMRESLANGPROCA a3,
                                               LONG_PTR a4)
    = EnumResourceLanguagesA;
#endif

#if _MSC_VER < 1300
BOOL (__stdcall * Real_EnumResourceLanguagesW)(HMODULE a0,
                                               LPCWSTR a1,
                                               LPCWSTR a2,
                                               ENUMRESLANGPROC a3,
                                               LONG a4)
    = EnumResourceLanguagesW;
#else
BOOL (__stdcall * Real_EnumResourceLanguagesW)(HMODULE a0,
                                               LPCWSTR a1,
                                               LPCWSTR a2,
                                               ENUMRESLANGPROCW a3,
                                               LONG_PTR a4)
    = EnumResourceLanguagesW;
#endif

#if _MSC_VER < 1300
BOOL (__stdcall * Real_EnumResourceNamesA)(HMODULE a0,
                                           LPCSTR a1,
                                           ENUMRESNAMEPROC a2,
                                           LONG a3)
    = EnumResourceNamesA;
#else
BOOL (__stdcall * Real_EnumResourceNamesA)(HMODULE a0,
                                           LPCSTR a1,
                                           ENUMRESNAMEPROCA a2,
                                           LONG_PTR a3)
    = EnumResourceNamesA;
#endif

#if _MSC_VER < 1300
BOOL (__stdcall * Real_EnumResourceNamesW)(HMODULE a0,
                                           LPCWSTR a1,
                                           ENUMRESNAMEPROC a2,
                                           LONG a3)
    = EnumResourceNamesW;
#else
BOOL (__stdcall * Real_EnumResourceNamesW)(HMODULE a0,
                                           LPCWSTR a1,
                                           ENUMRESNAMEPROCW a2,
                                           LONG_PTR a3)
    = EnumResourceNamesW;
#endif

#if _MSC_VER < 1300
BOOL (__stdcall * Real_EnumResourceTypesA)(HMODULE a0,
                                           ENUMRESTYPEPROC a1,
                                           LONG a2)
    = EnumResourceTypesA;
#else
BOOL (__stdcall * Real_EnumResourceTypesA)(HMODULE a0,
                                           ENUMRESTYPEPROCA a1,
                                           LONG_PTR a2)
    = EnumResourceTypesA;
#endif

#if _MSC_VER < 1300
BOOL (__stdcall * Real_EnumResourceTypesW)(HMODULE a0,
                                           ENUMRESTYPEPROC a1,
                                           LONG a2)
    = EnumResourceTypesW;
#else
BOOL (__stdcall * Real_EnumResourceTypesW)(HMODULE a0,
                                           ENUMRESTYPEPROCW a1,
                                           LONG_PTR a2)
    = EnumResourceTypesW;
#endif

BOOL (__stdcall * Real_EnumSystemCodePagesA)(CODEPAGE_ENUMPROCA a0,
                                             DWORD a1)
    = EnumSystemCodePagesA;

BOOL (__stdcall * Real_EnumSystemCodePagesW)(CODEPAGE_ENUMPROCW a0,
                                             DWORD a1)
    = EnumSystemCodePagesW;

#if(WINVER >= 0x0500)
BOOL (__stdcall * Real_EnumSystemLocalesA)(LOCALE_ENUMPROCA a0,
                                           DWORD a1)
    = EnumSystemLocalesA;

BOOL (__stdcall * Real_EnumSystemLocalesW)(LOCALE_ENUMPROCW a0,
                                           DWORD a1)
    = EnumSystemLocalesW;
#endif // (WINVER >= 0x0500)

BOOL (__stdcall * Real_EnumThreadWindows)(DWORD a0,
                                          WNDENUMPROC a1,
                                          LPARAM a2)
    = EnumThreadWindows;

BOOL (__stdcall * Real_EnumTimeFormatsA)(TIMEFMT_ENUMPROCA a0,
                                         LCID a1,
                                         DWORD a2)
    = EnumTimeFormatsA;

BOOL (__stdcall * Real_EnumTimeFormatsW)(TIMEFMT_ENUMPROCW a0,
                                         LCID a1,
                                         DWORD a2)
    = EnumTimeFormatsW;

BOOL (__stdcall * Real_EnumWindowStationsA)(WINSTAENUMPROCA a0,
                                            LPARAM a1)
    = EnumWindowStationsA;

BOOL (__stdcall * Real_EnumWindowStationsW)(WINSTAENUMPROCW a0,
                                            LPARAM a1)
    = EnumWindowStationsW;

BOOL (__stdcall * Real_EnumWindows)(WNDENUMPROC a0,
                                    LPARAM a1)
    = EnumWindows;

BOOL (__stdcall * Real_EqualRect)(CONST RECT* a0,
                                  CONST RECT* a1)
    = EqualRect;

BOOL (__stdcall * Real_EqualRgn)(HRGN a0,
                                 HRGN a1)
    = EqualRgn;

DWORD (__stdcall * Real_EraseTape)(HANDLE a0,
                                   DWORD a1,
                                   BOOL a2)
    = EraseTape;

int (__stdcall * Real_Escape)(HDC a0,
                              int a1,
                              int a2,
                              LPCSTR a3,
                              LPVOID a4)
    = Escape;

BOOL (__stdcall * Real_EscapeCommFunction)(HANDLE a0,
                                           DWORD a1)
    = EscapeCommFunction;

int (__stdcall * Real_ExcludeClipRect)(HDC a0,
                                       int a1,
                                       int a2,
                                       int a3,
                                       int a4)
    = ExcludeClipRect;

int (__stdcall * Real_ExcludeUpdateRgn)(HDC a0,
                                        HWND a1)
    = ExcludeUpdateRgn;

void (__stdcall * Real_ExitProcess)(UINT a0)
    = ExitProcess;

void (__stdcall * Real_ExitThread)(DWORD a0)
    = ExitThread;

BOOL (__stdcall * Real_ExitWindowsEx)(UINT a0,
                                      DWORD a1)
    = ExitWindowsEx;

DWORD (__stdcall * Real_ExpandEnvironmentStringsA)(LPCSTR a0,
                                                   LPSTR a1,
                                                   DWORD a2)
    = ExpandEnvironmentStringsA;

DWORD (__stdcall * Real_ExpandEnvironmentStringsW)(LPCWSTR a0,
                                                   LPWSTR a1,
                                                   DWORD a2)
    = ExpandEnvironmentStringsW;

HPEN (__stdcall * Real_ExtCreatePen)(DWORD a0,
                                     DWORD a1,
                                     CONST LOGBRUSH* a2,
                                     DWORD a3,
                                     CONST DWORD* a4)
    = ExtCreatePen;

HRGN (__stdcall * Real_ExtCreateRegion)(CONST XFORM* a0,
                                        DWORD a1,
                                        CONST RGNDATA* a2)
    = ExtCreateRegion;

int (__stdcall * Real_ExtEscape)(HDC a0,
                                 int a1,
                                 int a2,
                                 LPCSTR a3,
                                 int a4,
                                 LPSTR a5)
    = ExtEscape;

BOOL (__stdcall * Real_ExtFloodFill)(HDC a0,
                                     int a1,
                                     int a2,
                                     COLORREF a3,
                                     UINT a4)
    = ExtFloodFill;

int (__stdcall * Real_ExtSelectClipRgn)(HDC a0,
                                        HRGN a1,
                                        int a2)
    = ExtSelectClipRgn;

BOOL (__stdcall * Real_ExtTextOutA)(HDC a0,
                                    int a1,
                                    int a2,
                                    UINT a3,
                                    CONST RECT* a4,
                                    LPCSTR a5,
                                    UINT a6,
                                    CONST INT* a7)
    = ExtTextOutA;

BOOL (__stdcall * Real_ExtTextOutW)(HDC a0,
                                    int a1,
                                    int a2,
                                    UINT a3,
                                    CONST RECT* a4,
                                    LPCWSTR a5,
                                    UINT a6,
                                    CONST INT* a7)
    = ExtTextOutW;

void (__stdcall * Real_FatalAppExitA)(UINT a0,
                                      LPCSTR a1)
    = FatalAppExitA;

void (__stdcall * Real_FatalAppExitW)(UINT a0,
                                      LPCWSTR a1)
    = FatalAppExitW;

void (__stdcall * Real_FatalExit)(int a0)
    = FatalExit;

BOOL (__stdcall * Real_FileTimeToDosDateTime)(CONST FILETIME* a0,
                                              LPWORD a1,
                                              LPWORD a2)
    = FileTimeToDosDateTime;

BOOL (__stdcall * Real_FileTimeToLocalFileTime)(CONST FILETIME* a0,
                                                LPFILETIME a1)
    = FileTimeToLocalFileTime;

BOOL (__stdcall * Real_FileTimeToSystemTime)(CONST FILETIME* a0,
                                             LPSYSTEMTIME a1)
    = FileTimeToSystemTime;

BOOL (__stdcall * Real_FillConsoleOutputAttribute)(HANDLE a0,
                                                   WORD a1,
                                                   DWORD a2,
                                                   COORD a3,
                                                   LPDWORD a4)
    = FillConsoleOutputAttribute;

BOOL (__stdcall * Real_FillConsoleOutputCharacterA)(HANDLE a0,
                                                    CHAR a1,
                                                    DWORD a2,
                                                    COORD a3,
                                                    LPDWORD a4)
    = FillConsoleOutputCharacterA;

BOOL (__stdcall * Real_FillConsoleOutputCharacterW)(HANDLE a0,
                                                    WCHAR a1,
                                                    DWORD a2,
                                                    COORD a3,
                                                    LPDWORD a4)
    = FillConsoleOutputCharacterW;

BOOL (__stdcall * Real_FillPath)(HDC a0)
    = FillPath;

int (__stdcall * Real_FillRect)(HDC a0,
                                CONST RECT* a1,
                                HBRUSH a2)
    = FillRect;

BOOL (__stdcall * Real_FillRgn)(HDC a0,
                                HRGN a1,
                                HBRUSH a2)
    = FillRgn;

ATOM (__stdcall * Real_FindAtomA)(LPCSTR a0)
    = FindAtomA;

ATOM (__stdcall * Real_FindAtomW)(LPCWSTR a0)
    = FindAtomW;

BOOL (__stdcall * Real_FindClose)(HANDLE a0)
    = FindClose;

BOOL (__stdcall * Real_FindCloseChangeNotification)(HANDLE a0)
    = FindCloseChangeNotification;

HANDLE (__stdcall * Real_FindFirstChangeNotificationA)(LPCSTR a0,
                                                       BOOL a1,
                                                       DWORD a2)
    = FindFirstChangeNotificationA;

HANDLE (__stdcall * Real_FindFirstChangeNotificationW)(LPCWSTR a0,
                                                       BOOL a1,
                                                       DWORD a2)
    = FindFirstChangeNotificationW;

HANDLE (__stdcall * Real_FindFirstFileA)(LPCSTR a0,
                                         LPWIN32_FIND_DATAA a1)
    = FindFirstFileA;

HANDLE (__stdcall * Real_FindFirstFileExA)(LPCSTR a0,
                                           FINDEX_INFO_LEVELS a1,
                                           LPVOID a2,
                                           FINDEX_SEARCH_OPS a3,
                                           LPVOID a4,
                                           DWORD a5)
    = FindFirstFileExA;

HANDLE (__stdcall * Real_FindFirstFileExW)(LPCWSTR a0,
                                           FINDEX_INFO_LEVELS a1,
                                           LPVOID a2,
                                           FINDEX_SEARCH_OPS a3,
                                           LPVOID a4,
                                           DWORD a5)
    = FindFirstFileExW;

HANDLE (__stdcall * Real_FindFirstFileW)(LPCWSTR a0,
                                         LPWIN32_FIND_DATAW a1)
    = FindFirstFileW;

BOOL (__stdcall * Real_FindNextChangeNotification)(HANDLE a0)
    = FindNextChangeNotification;

BOOL (__stdcall * Real_FindNextFileA)(HANDLE a0,
                                      LPWIN32_FIND_DATAA a1)
    = FindNextFileA;

BOOL (__stdcall * Real_FindNextFileW)(HANDLE a0,
                                      LPWIN32_FIND_DATAW a1)
    = FindNextFileW;

HRSRC (__stdcall * Real_FindResourceA)(HMODULE a0,
                                       LPCSTR a1,
                                       LPCSTR a2)
    = FindResourceA;

HRSRC (__stdcall * Real_FindResourceExA)(HMODULE a0,
                                         LPCSTR a1,
                                         LPCSTR a2,
                                         WORD a3)
    = FindResourceExA;

HRSRC (__stdcall * Real_FindResourceExW)(HMODULE a0,
                                         LPCWSTR a1,
                                         LPCWSTR a2,
                                         WORD a3)
    = FindResourceExW;

HRSRC (__stdcall * Real_FindResourceW)(HMODULE a0,
                                       LPCWSTR a1,
                                       LPCWSTR a2)
    = FindResourceW;

HWND (__stdcall * Real_FindWindowA)(LPCSTR a0,
                                    LPCSTR a1)
    = FindWindowA;

HWND (__stdcall * Real_FindWindowExA)(HWND a0,
                                      HWND a1,
                                      LPCSTR a2,
                                      LPCSTR a3)
    = FindWindowExA;

HWND (__stdcall * Real_FindWindowExW)(HWND a0,
                                      HWND a1,
                                      LPCWSTR a2,
                                      LPCWSTR a3)
    = FindWindowExW;

HWND (__stdcall * Real_FindWindowW)(LPCWSTR a0,
                                    LPCWSTR a1)
    = FindWindowW;

BOOL (__stdcall * Real_FixBrushOrgEx)(HDC a0,
                                      int a1,
                                      int a2,
                                      POINT* a3)
    = FixBrushOrgEx;

BOOL (__stdcall * Real_FlashWindow)(HWND a0,
                                    BOOL a1)
    = FlashWindow;

BOOL (__stdcall * Real_FlattenPath)(HDC a0)
    = FlattenPath;

BOOL (__stdcall * Real_FloodFill)(HDC a0,
                                  int a1,
                                  int a2,
                                  COLORREF a3)
    = FloodFill;

BOOL (__stdcall * Real_FlushConsoleInputBuffer)(HANDLE a0)
    = FlushConsoleInputBuffer;

BOOL (__stdcall * Real_FlushFileBuffers)(HANDLE a0)
    = FlushFileBuffers;

BOOL (__stdcall * Real_FlushViewOfFile)(LPCVOID a0,
                                        SIZE_T a1)
    = FlushViewOfFile;

HRESULT (__stdcall * Real_FmtIdToPropStgName)(CONST FMTID* a0,
                                              LPOLESTR a1)
    = FmtIdToPropStgName;

int (__stdcall * Real_FoldStringA)(DWORD a0,
                                   LPCSTR a1,
                                   int a2,
                                   LPSTR a3,
                                   int a4)
    = FoldStringA;

int (__stdcall * Real_FoldStringW)(DWORD a0,
                                   LPCWSTR a1,
                                   int a2,
                                   LPWSTR a3,
                                   int a4)
    = FoldStringW;

DWORD (__stdcall * Real_FormatMessageA)(DWORD a0,
                                        LPCVOID a1,
                                        DWORD a2,
                                        DWORD a3,
                                        LPSTR a4,
                                        DWORD a5,
                                        va_list* a6)
    = FormatMessageA;

DWORD (__stdcall * Real_FormatMessageW)(DWORD a0,
                                        LPCVOID a1,
                                        DWORD a2,
                                        DWORD a3,
                                        LPWSTR a4,
                                        DWORD a5,
                                        va_list* a6)
    = FormatMessageW;

int (__stdcall * Real_FrameRect)(HDC a0,
                                 CONST RECT* a1,
                                 HBRUSH a2)
    = FrameRect;

BOOL (__stdcall * Real_FrameRgn)(HDC a0,
                                 HRGN a1,
                                 HBRUSH a2,
                                 int a3,
                                 int a4)
    = FrameRgn;

BOOL (__stdcall * Real_FreeConsole)(void)
    = FreeConsole;

BOOL (__stdcall * Real_FreeDDElParam)(UINT a0,
                                      LPARAM a1)
    = FreeDDElParam;

BOOL (__stdcall * Real_FreeEnvironmentStringsA)(LPSTR a0)
    = FreeEnvironmentStringsA;

BOOL (__stdcall * Real_FreeEnvironmentStringsW)(LPWSTR a0)
    = FreeEnvironmentStringsW;

BOOL (__stdcall * Real_FreeLibrary)(HMODULE a0)
    = FreeLibrary;

void (__stdcall * Real_FreeLibraryAndExitThread)(HMODULE a0,
                                                 DWORD a1)
    = FreeLibraryAndExitThread;

HRESULT (__stdcall * Real_FreePropVariantArray)(ULONG a0,
                                                PROPVARIANT* a1)
    = FreePropVariantArray;

BOOL (__stdcall * Real_FreeResource)(HGLOBAL a0)
    = FreeResource;

BOOL (__stdcall * Real_GdiComment)(HDC a0,
                                   UINT a1,
                                   CONST BYTE* a2)
    = GdiComment;

BOOL (__stdcall * Real_GdiFlush)(void)
    = GdiFlush;

DWORD (__stdcall * Real_GdiGetBatchLimit)(void)
    = GdiGetBatchLimit;

DWORD (__stdcall * Real_GdiSetBatchLimit)(DWORD a0)
    = GdiSetBatchLimit;

BOOL (__stdcall * Real_GenerateConsoleCtrlEvent)(DWORD a0,
                                                 DWORD a1)
    = GenerateConsoleCtrlEvent;

UINT (__stdcall * Real_GetACP)(void)
    = GetACP;

HWND (__stdcall * Real_GetActiveWindow)(void)
    = GetActiveWindow;

int (__stdcall * Real_GetArcDirection)(HDC a0)
    = GetArcDirection;

BOOL (__stdcall * Real_GetAspectRatioFilterEx)(HDC a0,
                                               SIZE* a1)
    = GetAspectRatioFilterEx;

SHORT (__stdcall * Real_GetAsyncKeyState)(int a0)
    = GetAsyncKeyState;

UINT (__stdcall * Real_GetAtomNameA)(ATOM a0,
                                     LPSTR a1,
                                     int a2)
    = GetAtomNameA;

UINT (__stdcall * Real_GetAtomNameW)(ATOM a0,
                                     LPWSTR a1,
                                     int a2)
    = GetAtomNameW;

BOOL (__stdcall * Real_GetBinaryTypeA)(LPCSTR a0,
                                       LPDWORD a1)
    = GetBinaryTypeA;

BOOL (__stdcall * Real_GetBinaryTypeW)(LPCWSTR a0,
                                       LPDWORD a1)
    = GetBinaryTypeW;

LONG (__stdcall * Real_GetBitmapBits)(HBITMAP a0,
                                      LONG a1,
                                      LPVOID a2)
    = GetBitmapBits;

BOOL (__stdcall * Real_GetBitmapDimensionEx)(HBITMAP a0,
                                             SIZE* a1)
    = GetBitmapDimensionEx;

COLORREF (__stdcall * Real_GetBkColor)(HDC a0)
    = GetBkColor;

int (__stdcall * Real_GetBkMode)(HDC a0)
    = GetBkMode;

UINT (__stdcall * Real_GetBoundsRect)(HDC a0,
                                      LPRECT a1,
                                      UINT a2)
    = GetBoundsRect;

BOOL (__stdcall * Real_GetBrushOrgEx)(HDC a0,
                                      POINT* a1)
    = GetBrushOrgEx;

BOOL (__stdcall * Real_GetCPInfo)(UINT a0,
                                  LPCPINFO a1)
    = GetCPInfo;

HWND (__stdcall * Real_GetCapture)(void)
    = GetCapture;

UINT (__stdcall * Real_GetCaretBlinkTime)(void)
    = GetCaretBlinkTime;

BOOL (__stdcall * Real_GetCaretPos)(POINT* a0)
    = GetCaretPos;

BOOL (__stdcall * Real_GetCharABCWidthsA)(HDC a0,
                                          UINT a1,
                                          UINT a2,
                                          LPABC a3)
    = GetCharABCWidthsA;

BOOL (__stdcall * Real_GetCharABCWidthsFloatA)(HDC a0,
                                               UINT a1,
                                               UINT a2,
                                               LPABCFLOAT a3)
    = GetCharABCWidthsFloatA;

BOOL (__stdcall * Real_GetCharABCWidthsFloatW)(HDC a0,
                                               UINT a1,
                                               UINT a2,
                                               LPABCFLOAT a3)
    = GetCharABCWidthsFloatW;

BOOL (__stdcall * Real_GetCharABCWidthsW)(HDC a0,
                                          UINT a1,
                                          UINT a2,
                                          LPABC a3)
    = GetCharABCWidthsW;

BOOL (__stdcall * Real_GetCharWidth32A)(HDC a0,
                                        UINT a1,
                                        UINT a2,
                                        LPINT a3)
    = GetCharWidth32A;

BOOL (__stdcall * Real_GetCharWidth32W)(HDC a0,
                                        UINT a1,
                                        UINT a2,
                                        LPINT a3)
    = GetCharWidth32W;

BOOL (__stdcall * Real_GetCharWidthA)(HDC a0,
                                      UINT a1,
                                      UINT a2,
                                      LPINT a3)
    = GetCharWidthA;

BOOL (__stdcall * Real_GetCharWidthFloatA)(HDC a0,
                                           UINT a1,
                                           UINT a2,
                                           PFLOAT a3)
    = GetCharWidthFloatA;

BOOL (__stdcall * Real_GetCharWidthFloatW)(HDC a0,
                                           UINT a1,
                                           UINT a2,
                                           PFLOAT a3)
    = GetCharWidthFloatW;

BOOL (__stdcall * Real_GetCharWidthW)(HDC a0,
                                      UINT a1,
                                      UINT a2,
                                      LPINT a3)
    = GetCharWidthW;

DWORD (__stdcall * Real_GetCharacterPlacementA)(HDC a0,
                                                LPCSTR a1,
                                                int a2,
                                                int a3,
                                                LPGCP_RESULTSA a4,
                                                DWORD a5)
    = GetCharacterPlacementA;

DWORD (__stdcall * Real_GetCharacterPlacementW)(HDC a0,
                                                LPCWSTR a1,
                                                int a2,
                                                int a3,
                                                LPGCP_RESULTSW a4,
                                                DWORD a5)
    = GetCharacterPlacementW;

HRESULT (__stdcall * Real_GetClassFile)(LPCOLESTR a0,
                                        CLSID* a1)
    = GetClassFile;

BOOL (__stdcall * Real_GetClassInfoA)(HINSTANCE a0,
                                      LPCSTR a1,
                                      LPWNDCLASSA a2)
    = GetClassInfoA;

BOOL (__stdcall * Real_GetClassInfoExA)(HINSTANCE a0,
                                        LPCSTR a1,
                                        LPWNDCLASSEXA a2)
    = GetClassInfoExA;

BOOL (__stdcall * Real_GetClassInfoExW)(HINSTANCE a0,
                                        LPCWSTR a1,
                                        LPWNDCLASSEXW a2)
    = GetClassInfoExW;

BOOL (__stdcall * Real_GetClassInfoW)(HINSTANCE a0,
                                      LPCWSTR a1,
                                      LPWNDCLASSW a2)
    = GetClassInfoW;

DWORD (__stdcall * Real_GetClassLongA)(HWND a0,
                                       int a1)
    = GetClassLongA;

DWORD (__stdcall * Real_GetClassLongW)(HWND a0,
                                       int a1)
    = GetClassLongW;

int (__stdcall * Real_GetClassNameA)(HWND a0,
                                     LPSTR a1,
                                     int a2)
    = GetClassNameA;

int (__stdcall * Real_GetClassNameW)(HWND a0,
                                     LPWSTR a1,
                                     int a2)
    = GetClassNameW;

WORD (__stdcall * Real_GetClassWord)(HWND a0,
                                     int a1)
    = GetClassWord;

BOOL (__stdcall * Real_GetClientRect)(HWND a0,
                                      LPRECT a1)
    = GetClientRect;

int (__stdcall * Real_GetClipBox)(HDC a0,
                                  LPRECT a1)
    = GetClipBox;

BOOL (__stdcall * Real_GetClipCursor)(LPRECT a0)
    = GetClipCursor;

int (__stdcall * Real_GetClipRgn)(HDC a0,
                                  HRGN a1)
    = GetClipRgn;

HANDLE (__stdcall * Real_GetClipboardData)(UINT a0)
    = GetClipboardData;

int (__stdcall * Real_GetClipboardFormatNameA)(UINT a0,
                                               LPSTR a1,
                                               int a2)
    = GetClipboardFormatNameA;

int (__stdcall * Real_GetClipboardFormatNameW)(UINT a0,
                                               LPWSTR a1,
                                               int a2)
    = GetClipboardFormatNameW;

HWND (__stdcall * Real_GetClipboardOwner)(void)
    = GetClipboardOwner;

HWND (__stdcall * Real_GetClipboardViewer)(void)
    = GetClipboardViewer;

BOOL (__stdcall * Real_GetColorAdjustment)(HDC a0,
                                           LPCOLORADJUSTMENT a1)
    = GetColorAdjustment;

HCOLORSPACE (__stdcall * Real_GetColorSpace)(HDC a0)
    = GetColorSpace;

BOOL (__stdcall * Real_GetCommConfig)(HANDLE a0,
                                      LPCOMMCONFIG a1,
                                      LPDWORD a2)
    = GetCommConfig;

BOOL (__stdcall * Real_GetCommMask)(HANDLE a0,
                                    LPDWORD a1)
    = GetCommMask;

BOOL (__stdcall * Real_GetCommModemStatus)(HANDLE a0,
                                           LPDWORD a1)
    = GetCommModemStatus;

BOOL (__stdcall * Real_GetCommProperties)(HANDLE a0,
                                          LPCOMMPROP a1)
    = GetCommProperties;

BOOL (__stdcall * Real_GetCommState)(HANDLE a0,
                                     LPDCB a1)
    = GetCommState;

BOOL (__stdcall * Real_GetCommTimeouts)(HANDLE a0,
                                        LPCOMMTIMEOUTS a1)
    = GetCommTimeouts;

LPSTR (__stdcall * Real_GetCommandLineA)(void)
    = GetCommandLineA;

LPWSTR (__stdcall * Real_GetCommandLineW)(void)
    = GetCommandLineW;

BOOL (__stdcall * Real_GetComputerNameA)(LPSTR a0,
                                         LPDWORD a1)
    = GetComputerNameA;

BOOL (__stdcall * Real_GetComputerNameW)(LPWSTR a0,
                                         LPDWORD a1)
    = GetComputerNameW;

UINT (__stdcall * Real_GetConsoleCP)(void)
    = GetConsoleCP;

BOOL (__stdcall * Real_GetConsoleCursorInfo)(HANDLE a0,
                                             PCONSOLE_CURSOR_INFO a1)
    = GetConsoleCursorInfo;

BOOL (__stdcall * Real_GetConsoleMode)(HANDLE a0,
                                       LPDWORD a1)
    = GetConsoleMode;

UINT (__stdcall * Real_GetConsoleOutputCP)(void)
    = GetConsoleOutputCP;

BOOL (__stdcall * Real_GetConsoleScreenBufferInfo)(HANDLE a0,
                                                   PCONSOLE_SCREEN_BUFFER_INFO a1)
    = GetConsoleScreenBufferInfo;

DWORD (__stdcall * Real_GetConsoleTitleA)(LPSTR a0,
                                          DWORD a1)
    = GetConsoleTitleA;

DWORD (__stdcall * Real_GetConsoleTitleW)(LPWSTR a0,
                                          DWORD a1)
    = GetConsoleTitleW;

HRESULT (__stdcall * Real_GetConvertStg)(IStorage* a0)
    = GetConvertStg;

int (__stdcall * Real_GetCurrencyFormatA)(LCID a0,
                                          DWORD a1,
                                          LPCSTR a2,
                                          CONST CURRENCYFMTA* a3,
                                          LPSTR a4,
                                          int a5)
    = GetCurrencyFormatA;

int (__stdcall * Real_GetCurrencyFormatW)(LCID a0,
                                          DWORD a1,
                                          LPCWSTR a2,
                                          CONST CURRENCYFMTW* a3,
                                          LPWSTR a4,
                                          int a5)
    = GetCurrencyFormatW;

DWORD (__stdcall * Real_GetCurrentDirectoryA)(DWORD a0,
                                              LPSTR a1)
    = GetCurrentDirectoryA;

DWORD (__stdcall * Real_GetCurrentDirectoryW)(DWORD a0,
                                              LPWSTR a1)
    = GetCurrentDirectoryW;

HGDIOBJ (__stdcall * Real_GetCurrentObject)(HDC a0,
                                            UINT a1)
    = GetCurrentObject;

BOOL (__stdcall * Real_GetCurrentPositionEx)(HDC a0,
                                             POINT* a1)
    = GetCurrentPositionEx;

HANDLE (__stdcall * Real_GetCurrentProcess)(void)
    = GetCurrentProcess;

DWORD (__stdcall * Real_GetCurrentProcessId)(void)
    = GetCurrentProcessId;

DWORD (__stdcall * Real_GetCurrentThreadId)(void)
    = GetCurrentThreadId;

HCURSOR (__stdcall * Real_GetCursor)(void)
    = GetCursor;

BOOL (__stdcall * Real_GetCursorPos)(POINT* a0)
    = GetCursorPos;

HDC (__stdcall * Real_GetDC)(HWND a0)
    = GetDC;

HDC (__stdcall * Real_GetDCEx)(HWND a0,
                               HRGN a1,
                               DWORD a2)
    = GetDCEx;

BOOL (__stdcall * Real_GetDCOrgEx)(HDC a0,
                                   POINT* a1)
    = GetDCOrgEx;

UINT (__stdcall * Real_GetDIBColorTable)(HDC a0,
                                         UINT a1,
                                         UINT a2,
                                         RGBQUAD* a3)
    = GetDIBColorTable;

int (__stdcall * Real_GetDIBits)(HDC a0,
                                 HBITMAP a1,
                                 UINT a2,
                                 UINT a3,
                                 LPVOID a4,
                                 LPBITMAPINFO a5,
                                 UINT a6)
    = GetDIBits;

int (__stdcall * Real_GetDateFormatA)(LCID a0,
                                      DWORD a1,
                                      CONST SYSTEMTIME* a2,
                                      LPCSTR a3,
                                      LPSTR a4,
                                      int a5)
    = GetDateFormatA;

int (__stdcall * Real_GetDateFormatW)(LCID a0,
                                      DWORD a1,
                                      CONST SYSTEMTIME* a2,
                                      LPCWSTR a3,
                                      LPWSTR a4,
                                      int a5)
    = GetDateFormatW;

BOOL (__stdcall * Real_GetDefaultCommConfigA)(LPCSTR a0,
                                              LPCOMMCONFIG a1,
                                              LPDWORD a2)
    = GetDefaultCommConfigA;

BOOL (__stdcall * Real_GetDefaultCommConfigW)(LPCWSTR a0,
                                              LPCOMMCONFIG a1,
                                              LPDWORD a2)
    = GetDefaultCommConfigW;

HWND (__stdcall * Real_GetDesktopWindow)(void)
    = GetDesktopWindow;

int (__stdcall * Real_GetDeviceCaps)(HDC a0,
                                     int a1)
    = GetDeviceCaps;

BOOL (__stdcall * Real_GetDeviceGammaRamp)(HDC a0,
                                           LPVOID a1)
    = GetDeviceGammaRamp;

long (__stdcall * Real_GetDialogBaseUnits)(void)
    = GetDialogBaseUnits;

BOOL (__stdcall * Real_GetDiskFreeSpaceA)(LPCSTR a0,
                                          LPDWORD a1,
                                          LPDWORD a2,
                                          LPDWORD a3,
                                          LPDWORD a4)
    = GetDiskFreeSpaceA;

BOOL (__stdcall * Real_GetDiskFreeSpaceExA)(LPCSTR a0,
                                            union _ULARGE_INTEGER* a1,
                                            union _ULARGE_INTEGER* a2,
                                            union _ULARGE_INTEGER* a3)
    = GetDiskFreeSpaceExA;

BOOL (__stdcall * Real_GetDiskFreeSpaceExW)(LPCWSTR a0,
                                            union _ULARGE_INTEGER* a1,
                                            union _ULARGE_INTEGER* a2,
                                            union _ULARGE_INTEGER* a3)
    = GetDiskFreeSpaceExW;

BOOL (__stdcall * Real_GetDiskFreeSpaceW)(LPCWSTR a0,
                                          LPDWORD a1,
                                          LPDWORD a2,
                                          LPDWORD a3,
                                          LPDWORD a4)
    = GetDiskFreeSpaceW;

int (__stdcall * Real_GetDlgCtrlID)(HWND a0)
    = GetDlgCtrlID;

HWND (__stdcall * Real_GetDlgItem)(HWND a0,
                                   int a1)
    = GetDlgItem;

UINT (__stdcall * Real_GetDlgItemInt)(HWND a0,
                                      int a1,
                                      BOOL* a2,
                                      BOOL a3)
    = GetDlgItemInt;

UINT (__stdcall * Real_GetDlgItemTextA)(HWND a0,
                                        int a1,
                                        LPSTR a2,
                                        int a3)
    = GetDlgItemTextA;

UINT (__stdcall * Real_GetDlgItemTextW)(HWND a0,
                                        int a1,
                                        LPWSTR a2,
                                        int a3)
    = GetDlgItemTextW;

UINT (__stdcall * Real_GetDoubleClickTime)(void)
    = GetDoubleClickTime;

UINT (__stdcall * Real_GetDriveTypeA)(LPCSTR a0)
    = GetDriveTypeA;

UINT (__stdcall * Real_GetDriveTypeW)(LPCWSTR a0)
    = GetDriveTypeW;

HENHMETAFILE (__stdcall * Real_GetEnhMetaFileA)(LPCSTR a0)
    = GetEnhMetaFileA;

UINT (__stdcall * Real_GetEnhMetaFileBits)(HENHMETAFILE a0,
                                           UINT a1,
                                           LPBYTE a2)
    = GetEnhMetaFileBits;

UINT (__stdcall * Real_GetEnhMetaFileDescriptionA)(HENHMETAFILE a0,
                                                   UINT a1,
                                                   LPSTR a2)
    = GetEnhMetaFileDescriptionA;

UINT (__stdcall * Real_GetEnhMetaFileDescriptionW)(HENHMETAFILE a0,
                                                   UINT a1,
                                                   LPWSTR a2)
    = GetEnhMetaFileDescriptionW;

UINT (__stdcall * Real_GetEnhMetaFileHeader)(HENHMETAFILE a0,
                                             UINT a1,
                                             ENHMETAHEADER* a2)
    = GetEnhMetaFileHeader;

UINT (__stdcall * Real_GetEnhMetaFilePaletteEntries)(HENHMETAFILE a0,
                                                     UINT a1,
                                                     PALETTEENTRY* a2)
    = GetEnhMetaFilePaletteEntries;

UINT (__stdcall * Real_GetEnhMetaFilePixelFormat)(HENHMETAFILE a0,
                                                  UINT a1,
                                                  PIXELFORMATDESCRIPTOR* a2)
    = GetEnhMetaFilePixelFormat;

HENHMETAFILE (__stdcall * Real_GetEnhMetaFileW)(LPCWSTR a0)
    = GetEnhMetaFileW;

#undef GetEnvironmentStrings

LPSTR (__stdcall * Real_GetEnvironmentStrings)(void)
    = GetEnvironmentStrings;

LPWSTR (__stdcall * Real_GetEnvironmentStringsW)(void)
    = GetEnvironmentStringsW;

DWORD (__stdcall * Real_GetEnvironmentVariableA)(LPCSTR a0,
                                                 LPSTR a1,
                                                 DWORD a2)
    = GetEnvironmentVariableA;

DWORD (__stdcall * Real_GetEnvironmentVariableW)(LPCWSTR a0,
                                                 LPWSTR a1,
                                                 DWORD a2)
    = GetEnvironmentVariableW;

BOOL (__stdcall * Real_GetExitCodeProcess)(HANDLE a0,
                                           LPDWORD a1)
    = GetExitCodeProcess;

BOOL (__stdcall * Real_GetExitCodeThread)(HANDLE a0,
                                          LPDWORD a1)
    = GetExitCodeThread;

DWORD (__stdcall * Real_GetFileAttributesA)(LPCSTR a0)
    = GetFileAttributesA;

BOOL (__stdcall * Real_GetFileAttributesExA)(LPCSTR a0,
                                             enum _GET_FILEEX_INFO_LEVELS a1,
                                             LPVOID a2)
    = GetFileAttributesExA;

BOOL (__stdcall * Real_GetFileAttributesExW)(LPCWSTR a0,
                                             enum _GET_FILEEX_INFO_LEVELS a1,
                                             LPVOID a2)
    = GetFileAttributesExW;

DWORD (__stdcall * Real_GetFileAttributesW)(LPCWSTR a0)
    = GetFileAttributesW;

BOOL (__stdcall * Real_GetFileInformationByHandle)(HANDLE a0,
                                                   LPBY_HANDLE_FILE_INFORMATION a1)
    = GetFileInformationByHandle;

DWORD (__stdcall * Real_GetFileSize)(HANDLE a0,
                                     LPDWORD a1)
    = GetFileSize;

BOOL (__stdcall * Real_GetFileTime)(HANDLE a0,
                                    LPFILETIME a1,
                                    LPFILETIME a2,
                                    LPFILETIME a3)
    = GetFileTime;

DWORD (__stdcall * Real_GetFileType)(HANDLE a0)
    = GetFileType;

HWND (__stdcall * Real_GetFocus)(void)
    = GetFocus;

DWORD (__stdcall * Real_GetFontData)(HDC a0,
                                     DWORD a1,
                                     DWORD a2,
                                     LPVOID a3,
                                     DWORD a4)
    = GetFontData;

DWORD (__stdcall * Real_GetFontLanguageInfo)(HDC a0)
    = GetFontLanguageInfo;

HWND (__stdcall * Real_GetForegroundWindow)(void)
    = GetForegroundWindow;

DWORD (__stdcall * Real_GetFullPathNameA)(LPCSTR a0,
                                          DWORD a1,
                                          LPSTR a2,
                                          LPSTR* a3)
    = GetFullPathNameA;

DWORD (__stdcall * Real_GetFullPathNameW)(LPCWSTR a0,
                                          DWORD a1,
                                          LPWSTR a2,
                                          LPWSTR* a3)
    = GetFullPathNameW;

DWORD (__stdcall * Real_GetGlyphOutlineA)(HDC a0,
                                          UINT a1,
                                          UINT a2,
                                          LPGLYPHMETRICS a3,
                                          DWORD a4,
                                          LPVOID a5,
                                          CONST MAT2* a6)
    = GetGlyphOutlineA;

DWORD (__stdcall * Real_GetGlyphOutlineW)(HDC a0,
                                          UINT a1,
                                          UINT a2,
                                          LPGLYPHMETRICS a3,
                                          DWORD a4,
                                          LPVOID a5,
                                          CONST MAT2* a6)
    = GetGlyphOutlineW;

int (__stdcall * Real_GetGraphicsMode)(HDC a0)
    = GetGraphicsMode;

HRESULT (__stdcall * Real_GetHGlobalFromILockBytes)(ILockBytes* a0,
                                                    HGLOBAL* a1)
    = GetHGlobalFromILockBytes;

HRESULT (__stdcall * Real_GetHGlobalFromStream)(LPSTREAM a0,
                                                HGLOBAL* a1)
    = GetHGlobalFromStream;

BOOL (__stdcall * Real_GetHandleInformation)(HANDLE a0,
                                             LPDWORD a1)
    = GetHandleInformation;

BOOL (__stdcall * Real_GetICMProfileA)(HDC a0,
                                       LPDWORD a1,
                                       LPSTR a2)
    = GetICMProfileA;

BOOL (__stdcall * Real_GetICMProfileW)(HDC a0,
                                       LPDWORD a1,
                                       LPWSTR a2)
    = GetICMProfileW;

BOOL (__stdcall * Real_GetIconInfo)(HICON a0,
                                    PICONINFO a1)
    = GetIconInfo;

BOOL (__stdcall * Real_GetInputState)(void)
    = GetInputState;

UINT (__stdcall * Real_GetKBCodePage)(void)
    = GetKBCodePage;

DWORD (__stdcall * Real_GetKerningPairsA)(HDC a0,
                                          DWORD a1,
                                          KERNINGPAIR* a2)
    = GetKerningPairsA;

DWORD (__stdcall * Real_GetKerningPairsW)(HDC a0,
                                          DWORD a1,
                                          KERNINGPAIR* a2)
    = GetKerningPairsW;

int (__stdcall * Real_GetKeyNameTextA)(LONG a0,
                                       LPSTR a1,
                                       int a2)
    = GetKeyNameTextA;

int (__stdcall * Real_GetKeyNameTextW)(LONG a0,
                                       LPWSTR a1,
                                       int a2)
    = GetKeyNameTextW;

SHORT (__stdcall * Real_GetKeyState)(int a0)
    = GetKeyState;

HKL (__stdcall * Real_GetKeyboardLayout)(DWORD a0)
    = GetKeyboardLayout;

int (__stdcall * Real_GetKeyboardLayoutList)(int a0,
                                             HKL* a1)
    = GetKeyboardLayoutList;

BOOL (__stdcall * Real_GetKeyboardLayoutNameA)(LPSTR a0)
    = GetKeyboardLayoutNameA;

BOOL (__stdcall * Real_GetKeyboardLayoutNameW)(LPWSTR a0)
    = GetKeyboardLayoutNameW;

BOOL (__stdcall * Real_GetKeyboardState)(PBYTE a0)
    = GetKeyboardState;

int (__stdcall * Real_GetKeyboardType)(int a0)
    = GetKeyboardType;

HWND (__stdcall * Real_GetLastActivePopup)(HWND a0)
    = GetLastActivePopup;

void (__stdcall * Real_GetLocalTime)(LPSYSTEMTIME a0)
    = GetLocalTime;

int (__stdcall * Real_GetLocaleInfoA)(LCID a0,
                                      LCTYPE a1,
                                      LPSTR a2,
                                      int a3)
    = GetLocaleInfoA;

int (__stdcall * Real_GetLocaleInfoW)(LCID a0,
                                      LCTYPE a1,
                                      LPWSTR a2,
                                      int a3)
    = GetLocaleInfoW;

BOOL (__stdcall * Real_GetLogColorSpaceA)(HCOLORSPACE a0,
                                          LOGCOLORSPACEA* a1,
                                          DWORD a2)
    = GetLogColorSpaceA;

BOOL (__stdcall * Real_GetLogColorSpaceW)(HCOLORSPACE a0,
                                          LOGCOLORSPACEW* a1,
                                          DWORD a2)
    = GetLogColorSpaceW;

DWORD (__stdcall * Real_GetLogicalDriveStringsA)(DWORD a0,
                                                 LPSTR a1)
    = GetLogicalDriveStringsA;

DWORD (__stdcall * Real_GetLogicalDriveStringsW)(DWORD a0,
                                                 LPWSTR a1)
    = GetLogicalDriveStringsW;

DWORD (__stdcall * Real_GetLogicalDrives)(void)
    = GetLogicalDrives;

BOOL (__stdcall * Real_GetMailslotInfo)(HANDLE a0,
                                        LPDWORD a1,
                                        LPDWORD a2,
                                        LPDWORD a3,
                                        LPDWORD a4)
    = GetMailslotInfo;

int (__stdcall * Real_GetMapMode)(HDC a0)
    = GetMapMode;

HMENU (__stdcall * Real_GetMenu)(HWND a0)
    = GetMenu;

LONG (__stdcall * Real_GetMenuCheckMarkDimensions)(void)
    = GetMenuCheckMarkDimensions;

DWORD (__stdcall * Real_GetMenuContextHelpId)(HMENU a0)
    = GetMenuContextHelpId;

UINT (__stdcall * Real_GetMenuDefaultItem)(HMENU a0,
                                           UINT a1,
                                           UINT a2)
    = GetMenuDefaultItem;

int (__stdcall * Real_GetMenuItemCount)(HMENU a0)
    = GetMenuItemCount;

UINT (__stdcall * Real_GetMenuItemID)(HMENU a0,
                                      int a1)
    = GetMenuItemID;

BOOL (__stdcall * Real_GetMenuItemInfoA)(HMENU a0,
                                         UINT a1,
                                         BOOL a2,
                                         LPMENUITEMINFOA a3)
    = GetMenuItemInfoA;

BOOL (__stdcall * Real_GetMenuItemInfoW)(HMENU a0,
                                         UINT a1,
                                         BOOL a2,
                                         LPMENUITEMINFOW a3)
    = GetMenuItemInfoW;

BOOL (__stdcall * Real_GetMenuItemRect)(HWND a0,
                                        HMENU a1,
                                        UINT a2,
                                        LPRECT a3)
    = GetMenuItemRect;

UINT (__stdcall * Real_GetMenuState)(HMENU a0,
                                     UINT a1,
                                     UINT a2)
    = GetMenuState;

int (__stdcall * Real_GetMenuStringA)(HMENU a0,
                                      UINT a1,
                                      LPSTR a2,
                                      int a3,
                                      UINT a4)
    = GetMenuStringA;

int (__stdcall * Real_GetMenuStringW)(HMENU a0,
                                      UINT a1,
                                      LPWSTR a2,
                                      int a3,
                                      UINT a4)
    = GetMenuStringW;

BOOL (__stdcall * Real_GetMessageA)(LPMSG a0,
                                    HWND a1,
                                    UINT a2,
                                    UINT a3)
    = GetMessageA;

LPARAM (__stdcall * Real_GetMessageExtraInfo)(void)
    = GetMessageExtraInfo;

DWORD (__stdcall * Real_GetMessagePos)(void)
    = GetMessagePos;

LONG (__stdcall * Real_GetMessageTime)(void)
    = GetMessageTime;

BOOL (__stdcall * Real_GetMessageW)(LPMSG a0,
                                    HWND a1,
                                    UINT a2,
                                    UINT a3)
    = GetMessageW;

HMETAFILE (__stdcall * Real_GetMetaFileA)(LPCSTR a0)
    = GetMetaFileA;

UINT (__stdcall * Real_GetMetaFileBitsEx)(HMETAFILE a0,
                                          UINT a1,
                                          LPVOID a2)
    = GetMetaFileBitsEx;

HMETAFILE (__stdcall * Real_GetMetaFileW)(LPCWSTR a0)
    = GetMetaFileW;

int (__stdcall * Real_GetMetaRgn)(HDC a0,
                                  HRGN a1)
    = GetMetaRgn;

BOOL (__stdcall * Real_GetMiterLimit)(HDC a0,
                                      PFLOAT a1)
    = GetMiterLimit;

DWORD (__stdcall * Real_GetModuleFileNameA)(HMODULE a0,
                                            LPSTR a1,
                                            DWORD a2)
    = GetModuleFileNameA;

DWORD (__stdcall * Real_GetModuleFileNameW)(HMODULE a0,
                                            LPWSTR a1,
                                            DWORD a2)
    = GetModuleFileNameW;

HMODULE (__stdcall * Real_GetModuleHandleA)(LPCSTR a0)
    = GetModuleHandleA;

HMODULE (__stdcall * Real_GetModuleHandleW)(LPCWSTR a0)
    = GetModuleHandleW;

BOOL (__stdcall * Real_GetNamedPipeHandleStateA)(HANDLE a0,
                                                 LPDWORD a1,
                                                 LPDWORD a2,
                                                 LPDWORD a3,
                                                 LPDWORD a4,
                                                 LPSTR a5,
                                                 DWORD a6)
    = GetNamedPipeHandleStateA;

BOOL (__stdcall * Real_GetNamedPipeHandleStateW)(HANDLE a0,
                                                 LPDWORD a1,
                                                 LPDWORD a2,
                                                 LPDWORD a3,
                                                 LPDWORD a4,
                                                 LPWSTR a5,
                                                 DWORD a6)
    = GetNamedPipeHandleStateW;

BOOL (__stdcall * Real_GetNamedPipeInfo)(HANDLE a0,
                                         LPDWORD a1,
                                         LPDWORD a2,
                                         LPDWORD a3,
                                         LPDWORD a4)
    = GetNamedPipeInfo;

COLORREF (__stdcall * Real_GetNearestColor)(HDC a0,
                                            COLORREF a1)
    = GetNearestColor;

UINT (__stdcall * Real_GetNearestPaletteIndex)(HPALETTE a0,
                                               COLORREF a1)
    = GetNearestPaletteIndex;

HWND (__stdcall * Real_GetNextDlgGroupItem)(HWND a0,
                                            HWND a1,
                                            BOOL a2)
    = GetNextDlgGroupItem;

HWND (__stdcall * Real_GetNextDlgTabItem)(HWND a0,
                                          HWND a1,
                                          BOOL a2)
    = GetNextDlgTabItem;

int (__stdcall * Real_GetNumberFormatA)(LCID a0,
                                        DWORD a1,
                                        LPCSTR a2,
                                        CONST NUMBERFMTA* a3,
                                        LPSTR a4,
                                        int a5)
    = GetNumberFormatA;

int (__stdcall * Real_GetNumberFormatW)(LCID a0,
                                        DWORD a1,
                                        LPCWSTR a2,
                                        CONST NUMBERFMTW* a3,
                                        LPWSTR a4,
                                        int a5)
    = GetNumberFormatW;

BOOL (__stdcall * Real_GetNumberOfConsoleInputEvents)(HANDLE a0,
                                                      LPDWORD a1)
    = GetNumberOfConsoleInputEvents;

BOOL (__stdcall * Real_GetNumberOfConsoleMouseButtons)(LPDWORD a0)
    = GetNumberOfConsoleMouseButtons;

UINT (__stdcall * Real_GetOEMCP)(void)
    = GetOEMCP;

int (__stdcall * Real_GetObjectA)(HGDIOBJ a0,
                                  int a1,
                                  LPVOID a2)
    = GetObjectA;

DWORD (__stdcall * Real_GetObjectType)(HGDIOBJ a0)
    = GetObjectType;

int (__stdcall * Real_GetObjectW)(HGDIOBJ a0,
                                  int a1,
                                  LPVOID a2)
    = GetObjectW;

HWND (__stdcall * Real_GetOpenClipboardWindow)(void)
    = GetOpenClipboardWindow;

UINT (__stdcall * Real_GetOutlineTextMetricsA)(HDC a0,
                                               UINT a1,
                                               LPOUTLINETEXTMETRICA a2)
    = GetOutlineTextMetricsA;

UINT (__stdcall * Real_GetOutlineTextMetricsW)(HDC a0,
                                               UINT a1,
                                               LPOUTLINETEXTMETRICW a2)
    = GetOutlineTextMetricsW;

BOOL (__stdcall * Real_GetOverlappedResult)(HANDLE a0,
                                            LPOVERLAPPED a1,
                                            LPDWORD a2,
                                            BOOL a3)
    = GetOverlappedResult;

UINT (__stdcall * Real_GetPaletteEntries)(HPALETTE a0,
                                          UINT a1,
                                          UINT a2,
                                          PALETTEENTRY* a3)
    = GetPaletteEntries;

HWND (__stdcall * Real_GetParent)(HWND a0)
    = GetParent;

int (__stdcall * Real_GetPath)(HDC a0,
                               POINT* a1,
                               LPBYTE a2,
                               int a3)
    = GetPath;

COLORREF (__stdcall * Real_GetPixel)(HDC a0,
                                     int a1,
                                     int a2)
    = GetPixel;

int (__stdcall * Real_GetPixelFormat)(HDC a0)
    = GetPixelFormat;

int (__stdcall * Real_GetPolyFillMode)(HDC a0)
    = GetPolyFillMode;

DWORD (__stdcall * Real_GetPriorityClass)(HANDLE a0)
    = GetPriorityClass;

int (__stdcall * Real_GetPriorityClipboardFormat)(UINT* a0,
                                                  int a1)
    = GetPriorityClipboardFormat;

UINT (__stdcall * Real_GetPrivateProfileIntA)(LPCSTR a0,
                                              LPCSTR a1,
                                              INT a2,
                                              LPCSTR a3)
    = GetPrivateProfileIntA;

UINT (__stdcall * Real_GetPrivateProfileIntW)(LPCWSTR a0,
                                              LPCWSTR a1,
                                              INT a2,
                                              LPCWSTR a3)
    = GetPrivateProfileIntW;

DWORD (__stdcall * Real_GetPrivateProfileSectionA)(LPCSTR a0,
                                                   LPSTR a1,
                                                   DWORD a2,
                                                   LPCSTR a3)
    = GetPrivateProfileSectionA;

DWORD (__stdcall * Real_GetPrivateProfileSectionNamesA)(LPSTR a0,
                                                        DWORD a1,
                                                        LPCSTR a2)
    = GetPrivateProfileSectionNamesA;

DWORD (__stdcall * Real_GetPrivateProfileSectionNamesW)(LPWSTR a0,
                                                        DWORD a1,
                                                        LPCWSTR a2)
    = GetPrivateProfileSectionNamesW;

DWORD (__stdcall * Real_GetPrivateProfileSectionW)(LPCWSTR a0,
                                                   LPWSTR a1,
                                                   DWORD a2,
                                                   LPCWSTR a3)
    = GetPrivateProfileSectionW;

DWORD (__stdcall * Real_GetPrivateProfileStringA)(LPCSTR a0,
                                                  LPCSTR a1,
                                                  LPCSTR a2,
                                                  LPSTR a3,
                                                  DWORD a4,
                                                  LPCSTR a5)
    = GetPrivateProfileStringA;

DWORD (__stdcall * Real_GetPrivateProfileStringW)(LPCWSTR a0,
                                                  LPCWSTR a1,
                                                  LPCWSTR a2,
                                                  LPWSTR a3,
                                                  DWORD a4,
                                                  LPCWSTR a5)
    = GetPrivateProfileStringW;

BOOL (__stdcall * Real_GetPrivateProfileStructA)(LPCSTR a0,
                                                 LPCSTR a1,
                                                 LPVOID a2,
                                                 UINT a3,
                                                 LPCSTR a4)
    = GetPrivateProfileStructA;

BOOL (__stdcall * Real_GetPrivateProfileStructW)(LPCWSTR a0,
                                                 LPCWSTR a1,
                                                 LPVOID a2,
                                                 UINT a3,
                                                 LPCWSTR a4)
    = GetPrivateProfileStructW;

FARPROC (__stdcall * Real_GetProcAddress)(HMODULE a0,
                                          LPCSTR a1)
    = GetProcAddress;

BOOL (__stdcall * Real_GetProcessAffinityMask)(HANDLE a0,
                                               PDWORD_PTR a1,
                                               PDWORD_PTR a2)
    = GetProcessAffinityMask;

DWORD (__stdcall * Real_GetProcessHeaps)(DWORD a0,
                                         PHANDLE a1)
    = GetProcessHeaps;

BOOL (__stdcall * Real_GetProcessShutdownParameters)(LPDWORD a0,
                                                     LPDWORD a1)
    = GetProcessShutdownParameters;

BOOL (__stdcall * Real_GetProcessTimes)(HANDLE a0,
                                        LPFILETIME a1,
                                        LPFILETIME a2,
                                        LPFILETIME a3,
                                        LPFILETIME a4)
    = GetProcessTimes;

DWORD (__stdcall * Real_GetProcessVersion)(DWORD a0)
    = GetProcessVersion;

HWINSTA (__stdcall * Real_GetProcessWindowStation)(void)
    = GetProcessWindowStation;

BOOL (__stdcall * Real_GetProcessWorkingSetSize)(HANDLE a0,
                                                 PSIZE_T a1,
                                                 PSIZE_T a2)
    = GetProcessWorkingSetSize;

UINT (__stdcall * Real_GetProfileIntA)(LPCSTR a0,
                                       LPCSTR a1,
                                       INT a2)
    = GetProfileIntA;

UINT (__stdcall * Real_GetProfileIntW)(LPCWSTR a0,
                                       LPCWSTR a1,
                                       INT a2)
    = GetProfileIntW;

DWORD (__stdcall * Real_GetProfileSectionA)(LPCSTR a0,
                                            LPSTR a1,
                                            DWORD a2)
    = GetProfileSectionA;

DWORD (__stdcall * Real_GetProfileSectionW)(LPCWSTR a0,
                                            LPWSTR a1,
                                            DWORD a2)
    = GetProfileSectionW;

DWORD (__stdcall * Real_GetProfileStringA)(LPCSTR a0,
                                           LPCSTR a1,
                                           LPCSTR a2,
                                           LPSTR a3,
                                           DWORD a4)
    = GetProfileStringA;

DWORD (__stdcall * Real_GetProfileStringW)(LPCWSTR a0,
                                           LPCWSTR a1,
                                           LPCWSTR a2,
                                           LPWSTR a3,
                                           DWORD a4)
    = GetProfileStringW;

HANDLE (__stdcall * Real_GetPropA)(HWND a0,
                                   LPCSTR a1)
    = GetPropA;

HANDLE (__stdcall * Real_GetPropW)(HWND a0,
                                   LPCWSTR a1)
    = GetPropW;

DWORD (__stdcall * Real_GetQueueStatus)(UINT a0)
    = GetQueueStatus;

BOOL (__stdcall * Real_GetQueuedCompletionStatus)(HANDLE a0,
                                                  LPDWORD a1,
                                                  PULONG_PTR a2,
                                                  LPOVERLAPPED* a3,
                                                  DWORD a4)
    = GetQueuedCompletionStatus;

int (__stdcall * Real_GetROP2)(HDC a0)
    = GetROP2;

BOOL (__stdcall * Real_GetRasterizerCaps)(LPRASTERIZER_STATUS a0,
                                          UINT a1)
    = GetRasterizerCaps;

DWORD (__stdcall * Real_GetRegionData)(HRGN a0,
                                       DWORD a1,
                                       LPRGNDATA a2)
    = GetRegionData;

int (__stdcall * Real_GetRgnBox)(HRGN a0,
                                 LPRECT a1)
    = GetRgnBox;

HRESULT (__stdcall * Real_GetRunningObjectTable)(DWORD a0,
                                                 LPRUNNINGOBJECTTABLE* a1)
    = GetRunningObjectTable;

BOOL (__stdcall * Real_GetScrollInfo)(HWND a0,
                                      int a1,
                                      LPSCROLLINFO a2)
    = GetScrollInfo;

int (__stdcall * Real_GetScrollPos)(HWND a0,
                                    int a1)
    = GetScrollPos;

BOOL (__stdcall * Real_GetScrollRange)(HWND a0,
                                       int a1,
                                       LPINT a2,
                                       LPINT a3)
    = GetScrollRange;

DWORD (__stdcall * Real_GetShortPathNameA)(LPCSTR a0,
                                           LPSTR a1,
                                           DWORD a2)
    = GetShortPathNameA;

DWORD (__stdcall * Real_GetShortPathNameW)(LPCWSTR a0,
                                           LPWSTR a1,
                                           DWORD a2)
    = GetShortPathNameW;

void (__stdcall * Real_GetStartupInfoA)(LPSTARTUPINFOA a0)
    = GetStartupInfoA;

void (__stdcall * Real_GetStartupInfoW)(LPSTARTUPINFOW a0)
    = GetStartupInfoW;

HANDLE (__stdcall * Real_GetStdHandle)(DWORD a0)
    = GetStdHandle;

HGDIOBJ (__stdcall * Real_GetStockObject)(int a0)
    = GetStockObject;

int (__stdcall * Real_GetStretchBltMode)(HDC a0)
    = GetStretchBltMode;

HMENU (__stdcall * Real_GetSubMenu)(HMENU a0,
                                    int a1)
    = GetSubMenu;

DWORD (__stdcall * Real_GetSysColor)(int a0)
    = GetSysColor;

HBRUSH (__stdcall * Real_GetSysColorBrush)(int a0)
    = GetSysColorBrush;

LCID (__stdcall * Real_GetSystemDefaultLCID)(void)
    = GetSystemDefaultLCID;

LANGID (__stdcall * Real_GetSystemDefaultLangID)(void)
    = GetSystemDefaultLangID;

UINT (__stdcall * Real_GetSystemDirectoryA)(LPSTR a0,
                                            UINT a1)
    = GetSystemDirectoryA;

UINT (__stdcall * Real_GetSystemDirectoryW)(LPWSTR a0,
                                            UINT a1)
    = GetSystemDirectoryW;

void (__stdcall * Real_GetSystemInfo)(LPSYSTEM_INFO a0)
    = GetSystemInfo;

HMENU (__stdcall * Real_GetSystemMenu)(HWND a0,
                                       BOOL a1)
    = GetSystemMenu;

int (__stdcall * Real_GetSystemMetrics)(int a0)
    = GetSystemMetrics;

UINT (__stdcall * Real_GetSystemPaletteEntries)(HDC a0,
                                                UINT a1,
                                                UINT a2,
                                                PALETTEENTRY* a3)
    = GetSystemPaletteEntries;

UINT (__stdcall * Real_GetSystemPaletteUse)(HDC a0)
    = GetSystemPaletteUse;

BOOL (__stdcall * Real_GetSystemPowerStatus)(LPSYSTEM_POWER_STATUS a0)
    = GetSystemPowerStatus;

void (__stdcall * Real_GetSystemTime)(LPSYSTEMTIME a0)
    = GetSystemTime;

BOOL (__stdcall * Real_GetSystemTimeAdjustment)(PDWORD a0,
                                                PDWORD a1,
                                                PBOOL a2)
    = GetSystemTimeAdjustment;

void (__stdcall * Real_GetSystemTimeAsFileTime)(LPFILETIME a0)
    = GetSystemTimeAsFileTime;

#if _MSC_VER < 1300
DWORD (__stdcall * Real_GetTabbedTextExtentA)(HDC a0,
                                              LPCSTR a1,
                                              int a2,
                                              int a3,
                                              INT* a4)
    = GetTabbedTextExtentA;
#else
DWORD (__stdcall * Real_GetTabbedTextExtentA)(HDC a0,
                                              LPCSTR a1,
                                              int a2,
                                              int a3,
                                              CONST INT* a4)
    = GetTabbedTextExtentA;
#endif

#if _MSC_VER < 1300
DWORD (__stdcall * Real_GetTabbedTextExtentW)(HDC a0,
                                              LPCWSTR a1,
                                              int a2,
                                              int a3,
                                              INT* a4)
    = GetTabbedTextExtentW;
#else
DWORD (__stdcall * Real_GetTabbedTextExtentW)(HDC a0,
                                              LPCWSTR a1,
                                              int a2,
                                              int a3,
                                              CONST INT* a4)
    = GetTabbedTextExtentW;
#endif

DWORD (__stdcall * Real_GetTapeParameters)(HANDLE a0,
                                           DWORD a1,
                                           LPDWORD a2,
                                           LPVOID a3)
    = GetTapeParameters;

DWORD (__stdcall * Real_GetTapePosition)(HANDLE a0,
                                         DWORD a1,
                                         LPDWORD a2,
                                         LPDWORD a3,
                                         LPDWORD a4)
    = GetTapePosition;

DWORD (__stdcall * Real_GetTapeStatus)(HANDLE a0)
    = GetTapeStatus;

UINT (__stdcall * Real_GetTempFileNameA)(LPCSTR a0,
                                         LPCSTR a1,
                                         UINT a2,
                                         LPSTR a3)
    = GetTempFileNameA;

UINT (__stdcall * Real_GetTempFileNameW)(LPCWSTR a0,
                                         LPCWSTR a1,
                                         UINT a2,
                                         LPWSTR a3)
    = GetTempFileNameW;

DWORD (__stdcall * Real_GetTempPathA)(DWORD a0,
                                      LPSTR a1)
    = GetTempPathA;

DWORD (__stdcall * Real_GetTempPathW)(DWORD a0,
                                      LPWSTR a1)
    = GetTempPathW;

UINT (__stdcall * Real_GetTextAlign)(HDC a0)
    = GetTextAlign;

int (__stdcall * Real_GetTextCharacterExtra)(HDC a0)
    = GetTextCharacterExtra;

int (__stdcall * Real_GetTextCharset)(HDC a0)
    = GetTextCharset;

int (__stdcall * Real_GetTextCharsetInfo)(HDC a0,
                                          LPFONTSIGNATURE a1,
                                          DWORD a2)
    = GetTextCharsetInfo;

COLORREF (__stdcall * Real_GetTextColor)(HDC a0)
    = GetTextColor;

BOOL (__stdcall * Real_GetTextExtentExPointA)(HDC a0,
                                              LPCSTR a1,
                                              int a2,
                                              int a3,
                                              LPINT a4,
                                              LPINT a5,
                                              SIZE* a6)
    = GetTextExtentExPointA;

BOOL (__stdcall * Real_GetTextExtentExPointW)(HDC a0,
                                              LPCWSTR a1,
                                              int a2,
                                              int a3,
                                              LPINT a4,
                                              LPINT a5,
                                              SIZE* a6)
    = GetTextExtentExPointW;

BOOL (__stdcall * Real_GetTextExtentPoint32A)(HDC a0,
                                              LPCSTR a1,
                                              int a2,
                                              SIZE* a3)
    = GetTextExtentPoint32A;

BOOL (__stdcall * Real_GetTextExtentPoint32W)(HDC a0,
                                              LPCWSTR a1,
                                              int a2,
                                              SIZE* a3)
    = GetTextExtentPoint32W;

BOOL (__stdcall * Real_GetTextExtentPointA)(HDC a0,
                                            LPCSTR a1,
                                            int a2,
                                            SIZE* a3)
    = GetTextExtentPointA;

BOOL (__stdcall * Real_GetTextExtentPointW)(HDC a0,
                                            LPCWSTR a1,
                                            int a2,
                                            SIZE* a3)
    = GetTextExtentPointW;

int (__stdcall * Real_GetTextFaceA)(HDC a0,
                                    int a1,
                                    LPSTR a2)
    = GetTextFaceA;

int (__stdcall * Real_GetTextFaceW)(HDC a0,
                                    int a1,
                                    LPWSTR a2)
    = GetTextFaceW;

BOOL (__stdcall * Real_GetTextMetricsA)(HDC a0,
                                        LPTEXTMETRICA a1)
    = GetTextMetricsA;

BOOL (__stdcall * Real_GetTextMetricsW)(HDC a0,
                                        LPTEXTMETRICW a1)
    = GetTextMetricsW;

BOOL (__stdcall * Real_GetThreadContext)(HANDLE a0,
                                         LPCONTEXT a1)
    = GetThreadContext;

HDESK (__stdcall * Real_GetThreadDesktop)(DWORD a0)
    = GetThreadDesktop;

#if(WINVER >= 0x0500)
LCID (__stdcall * Real_GetThreadLocale)(void)
    = GetThreadLocale;
#endif // (WINVER >= 0x0500)

int (__stdcall * Real_GetThreadPriority)(HANDLE a0)
    = GetThreadPriority;

BOOL (__stdcall * Real_GetThreadPriorityBoost)(HANDLE a0,
                                               PBOOL a1)
    = GetThreadPriorityBoost;

BOOL (__stdcall * Real_GetThreadSelectorEntry)(HANDLE a0,
                                               DWORD a1,
                                               LPLDT_ENTRY a2)
    = GetThreadSelectorEntry;

BOOL (__stdcall * Real_GetThreadTimes)(HANDLE a0,
                                       LPFILETIME a1,
                                       LPFILETIME a2,
                                       LPFILETIME a3,
                                       LPFILETIME a4)
    = GetThreadTimes;

DWORD (__stdcall * Real_GetTickCount)(void)
    = GetTickCount;

int (__stdcall * Real_GetTimeFormatA)(LCID a0,
                                      DWORD a1,
                                      CONST SYSTEMTIME* a2,
                                      LPCSTR a3,
                                      LPSTR a4,
                                      int a5)
    = GetTimeFormatA;

int (__stdcall * Real_GetTimeFormatW)(LCID a0,
                                      DWORD a1,
                                      CONST SYSTEMTIME* a2,
                                      LPCWSTR a3,
                                      LPWSTR a4,
                                      int a5)
    = GetTimeFormatW;

DWORD (__stdcall * Real_GetTimeZoneInformation)(LPTIME_ZONE_INFORMATION a0)
    = GetTimeZoneInformation;

HWND (__stdcall * Real_GetTopWindow)(HWND a0)
    = GetTopWindow;

BOOL (__stdcall * Real_GetUpdateRect)(HWND a0,
                                      LPRECT a1,
                                      BOOL a2)
    = GetUpdateRect;

int (__stdcall * Real_GetUpdateRgn)(HWND a0,
                                    HRGN a1,
                                    BOOL a2)
    = GetUpdateRgn;

LCID (__stdcall * Real_GetUserDefaultLCID)(void)
    = GetUserDefaultLCID;

LANGID (__stdcall * Real_GetUserDefaultLangID)(void)
    = GetUserDefaultLangID;

BOOL (__stdcall * Real_GetUserObjectInformationA)(HANDLE a0,
                                                  int a1,
                                                  PVOID a2,
                                                  DWORD a3,
                                                  LPDWORD a4)
    = GetUserObjectInformationA;

BOOL (__stdcall * Real_GetUserObjectInformationW)(HANDLE a0,
                                                  int a1,
                                                  PVOID a2,
                                                  DWORD a3,
                                                  LPDWORD a4)
    = GetUserObjectInformationW;

BOOL (__stdcall * Real_GetUserObjectSecurity)(HANDLE a0,
                                              PSECURITY_INFORMATION a1,
                                              PSECURITY_DESCRIPTOR a2,
                                              DWORD a3,
                                              LPDWORD a4)
    = GetUserObjectSecurity;

DWORD (__stdcall * Real_GetVersion)(void)
    = GetVersion;

BOOL (__stdcall * Real_GetVersionExA)(LPOSVERSIONINFOA a0)
    = GetVersionExA;

BOOL (__stdcall * Real_GetVersionExW)(LPOSVERSIONINFOW a0)
    = GetVersionExW;

BOOL (__stdcall * Real_GetViewportExtEx)(HDC a0,
                                         SIZE* a1)
    = GetViewportExtEx;

BOOL (__stdcall * Real_GetViewportOrgEx)(HDC a0,
                                         POINT* a1)
    = GetViewportOrgEx;

BOOL (__stdcall * Real_GetVolumeInformationA)(LPCSTR a0,
                                              LPSTR a1,
                                              DWORD a2,
                                              LPDWORD a3,
                                              LPDWORD a4,
                                              LPDWORD a5,
                                              LPSTR a6,
                                              DWORD a7)
    = GetVolumeInformationA;

BOOL (__stdcall * Real_GetVolumeInformationW)(LPCWSTR a0,
                                              LPWSTR a1,
                                              DWORD a2,
                                              LPDWORD a3,
                                              LPDWORD a4,
                                              LPDWORD a5,
                                              LPWSTR a6,
                                              DWORD a7)
    = GetVolumeInformationW;

UINT (__stdcall * Real_GetWinMetaFileBits)(HENHMETAFILE a0,
                                           UINT a1,
                                           LPBYTE a2,
                                           INT a3,
                                           HDC a4)
    = GetWinMetaFileBits;

HWND (__stdcall * Real_GetWindow)(HWND a0,
                                  UINT a1)
    = GetWindow;

DWORD (__stdcall * Real_GetWindowContextHelpId)(HWND a0)
    = GetWindowContextHelpId;

HDC (__stdcall * Real_GetWindowDC)(HWND a0)
    = GetWindowDC;

BOOL (__stdcall * Real_GetWindowExtEx)(HDC a0,
                                       SIZE* a1)
    = GetWindowExtEx;

LONG (__stdcall * Real_GetWindowLongA)(HWND a0,
                                       int a1)
    = GetWindowLongA;

LONG (__stdcall * Real_GetWindowLongW)(HWND a0,
                                       int a1)
    = GetWindowLongW;

BOOL (__stdcall * Real_GetWindowOrgEx)(HDC a0,
                                       POINT* a1)
    = GetWindowOrgEx;

BOOL (__stdcall * Real_GetWindowPlacement)(HWND a0,
                                           WINDOWPLACEMENT* a1)
    = GetWindowPlacement;

BOOL (__stdcall * Real_GetWindowRect)(HWND a0,
                                      LPRECT a1)
    = GetWindowRect;

int (__stdcall * Real_GetWindowRgn)(HWND a0,
                                    HRGN a1)
    = GetWindowRgn;

int (__stdcall * Real_GetWindowTextA)(HWND a0,
                                      LPSTR a1,
                                      int a2)
    = GetWindowTextA;

int (__stdcall * Real_GetWindowTextLengthA)(HWND a0)
    = GetWindowTextLengthA;

int (__stdcall * Real_GetWindowTextLengthW)(HWND a0)
    = GetWindowTextLengthW;

int (__stdcall * Real_GetWindowTextW)(HWND a0,
                                      LPWSTR a1,
                                      int a2)
    = GetWindowTextW;

DWORD (__stdcall * Real_GetWindowThreadProcessId)(HWND a0,
                                                  LPDWORD a1)
    = GetWindowThreadProcessId;

WORD (__stdcall * Real_GetWindowWord)(HWND a0,
                                      int a1)
    = GetWindowWord;

UINT (__stdcall * Real_GetWindowsDirectoryA)(LPSTR a0,
                                             UINT a1)
    = GetWindowsDirectoryA;

UINT (__stdcall * Real_GetWindowsDirectoryW)(LPWSTR a0,
                                             UINT a1)
    = GetWindowsDirectoryW;

BOOL (__stdcall * Real_GetWorldTransform)(HDC a0,
                                          XFORM* a1)
    = GetWorldTransform;

ATOM (__stdcall * Real_GlobalAddAtomA)(LPCSTR a0)
    = GlobalAddAtomA;

ATOM (__stdcall * Real_GlobalAddAtomW)(LPCWSTR a0)
    = GlobalAddAtomW;

HGLOBAL (__stdcall * Real_GlobalAlloc)(UINT a0,
                                       SIZE_T a1)
    = GlobalAlloc;

#if _MSC_VER < 1300
UINT (__stdcall * Real_GlobalCompact)(DWORD a0)
    = GlobalCompact;
#else
SIZE_T (__stdcall * Real_GlobalCompact)(DWORD a0)
    = GlobalCompact;
#endif

ATOM (__stdcall * Real_GlobalDeleteAtom)(ATOM a0)
    = GlobalDeleteAtom;

ATOM (__stdcall * Real_GlobalFindAtomA)(LPCSTR a0)
    = GlobalFindAtomA;

ATOM (__stdcall * Real_GlobalFindAtomW)(LPCWSTR a0)
    = GlobalFindAtomW;

void (__stdcall * Real_GlobalFix)(HGLOBAL a0)
    = GlobalFix;

UINT (__stdcall * Real_GlobalFlags)(HGLOBAL a0)
    = GlobalFlags;

HGLOBAL (__stdcall * Real_GlobalFree)(HGLOBAL a0)
    = GlobalFree;

UINT (__stdcall * Real_GlobalGetAtomNameA)(ATOM a0,
                                           LPSTR a1,
                                           int a2)
    = GlobalGetAtomNameA;

UINT (__stdcall * Real_GlobalGetAtomNameW)(ATOM a0,
                                           LPWSTR a1,
                                           int a2)
    = GlobalGetAtomNameW;

HGLOBAL (__stdcall * Real_GlobalHandle)(LPCVOID a0)
    = GlobalHandle;

LPVOID (__stdcall * Real_GlobalLock)(HGLOBAL a0)
    = GlobalLock;

void (__stdcall * Real_GlobalMemoryStatus)(LPMEMORYSTATUS a0)
    = GlobalMemoryStatus;

HGLOBAL (__stdcall * Real_GlobalReAlloc)(HGLOBAL a0,
                                         SIZE_T a1,
                                         UINT a2)
    = GlobalReAlloc;

SIZE_T (__stdcall * Real_GlobalSize)(HGLOBAL a0)
    = GlobalSize;

BOOL (__stdcall * Real_GlobalUnWire)(HGLOBAL a0)
    = GlobalUnWire;

void (__stdcall * Real_GlobalUnfix)(HGLOBAL a0)
    = GlobalUnfix;

BOOL (__stdcall * Real_GlobalUnlock)(HGLOBAL a0)
    = GlobalUnlock;

LPVOID (__stdcall * Real_GlobalWire)(HGLOBAL a0)
    = GlobalWire;

BOOL (__stdcall * Real_GrayStringA)(HDC a0,
                                    HBRUSH a1,
                                    GRAYSTRINGPROC a2,
                                    LPARAM a3,
                                    int a4,
                                    int a5,
                                    int a6,
                                    int a7,
                                    int a8)
    = GrayStringA;

BOOL (__stdcall * Real_GrayStringW)(HDC a0,
                                    HBRUSH a1,
                                    GRAYSTRINGPROC a2,
                                    LPARAM a3,
                                    int a4,
                                    int a5,
                                    int a6,
                                    int a7,
                                    int a8)
    = GrayStringW;

BOOL (__stdcall * Real_HeapLock)(HANDLE a0)
    = HeapLock;

BOOL (__stdcall * Real_HeapUnlock)(HANDLE a0)
    = HeapUnlock;

BOOL (__stdcall * Real_HideCaret)(HWND a0)
    = HideCaret;

BOOL (__stdcall * Real_HiliteMenuItem)(HWND a0,
                                       HMENU a1,
                                       UINT a2,
                                       UINT a3)
    = HiliteMenuItem;

#ifdef _WIN32_WINNT_WIN7
HRESULT (__stdcall * Real_IIDFromString)(LPCOLESTR a0,
                                         LPGUID a1)
    = IIDFromString;
#else
HRESULT (__stdcall * Real_IIDFromString)(LPOLESTR a0,
                                         LPGUID a1)
    = IIDFromString;
#endif

BOOL (__stdcall * Real_ImpersonateDdeClientWindow)(HWND a0,
                                                   HWND a1)
    = ImpersonateDdeClientWindow;

BOOL (__stdcall * Real_InSendMessage)(void)
    = InSendMessage;

BOOL (__stdcall * Real_InflateRect)(LPRECT a0,
                                    int a1,
                                    int a2)
    = InflateRect;

BOOL (__stdcall * Real_InitAtomTable)(DWORD a0)
    = InitAtomTable;

BOOL (__stdcall * Real_InsertMenuA)(HMENU a0,
                                    UINT a1,
                                    UINT a2,
                                    UINT_PTR a3,
                                    LPCSTR a4)
    = InsertMenuA;

BOOL (__stdcall * Real_InsertMenuW)(HMENU a0,
                                    UINT a1,
                                    UINT a2,
                                    UINT_PTR a3,
                                    LPCWSTR a4)
    = InsertMenuW;

BOOL (__stdcall * Real_InsertMenuItemA)(HMENU a0,
                                        UINT a1,
                                        BOOL a2,
                                        LPCMENUITEMINFOA a3)
    = InsertMenuItemA;

BOOL (__stdcall * Real_InsertMenuItemW)(HMENU a0,
                                        UINT a1,
                                        BOOL a2,
                                        LPCMENUITEMINFOW a3)
    = InsertMenuItemW;

int (__stdcall * Real_IntersectClipRect)(HDC a0,
                                         int a1,
                                         int a2,
                                         int a3,
                                         int a4)
    = IntersectClipRect;

BOOL (__stdcall * Real_IntersectRect)(LPRECT a0,
                                      CONST RECT* a1,
                                      CONST RECT* a2)
    = IntersectRect;

BOOL (__stdcall * Real_InvalidateRect)(HWND a0,
                                       CONST RECT* a1,
                                       BOOL a2)
    = InvalidateRect;

BOOL (__stdcall * Real_InvalidateRgn)(HWND a0,
                                      HRGN a1,
                                      BOOL a2)
    = InvalidateRgn;

BOOL (__stdcall * Real_InvertRect)(HDC a0,
                                   CONST RECT* a1)
    = InvertRect;

BOOL (__stdcall * Real_InvertRgn)(HDC a0,
                                  HRGN a1)
    = InvertRgn;

BOOL (__stdcall * Real_IsAccelerator)(HACCEL a0,
                                      int a1,
                                      LPMSG a2,
                                      WORD* a3)
    = IsAccelerator;

BOOL (__stdcall * Real_IsBadCodePtr)(FARPROC a0)
    = IsBadCodePtr;

BOOL (__stdcall * Real_IsBadHugeReadPtr)(CONST void* a0,
                                         UINT_PTR a1)
    = IsBadHugeReadPtr;

BOOL (__stdcall * Real_IsBadHugeWritePtr)(LPVOID a0,
                                          UINT_PTR a1)
    = IsBadHugeWritePtr;

BOOL (__stdcall * Real_IsBadReadPtr)(CONST void* a0,
                                     UINT_PTR a1)
    = IsBadReadPtr;

BOOL (__stdcall * Real_IsBadStringPtrA)(LPCSTR a0,
                                        UINT_PTR a1)
    = IsBadStringPtrA;

BOOL (__stdcall * Real_IsBadStringPtrW)(LPCWSTR a0,
                                        UINT_PTR a1)
    = IsBadStringPtrW;

BOOL (__stdcall * Real_IsBadWritePtr)(LPVOID a0,
                                      UINT_PTR a1)
    = IsBadWritePtr;

BOOL (__stdcall * Real_IsCharAlphaA)(CHAR a0)
    = IsCharAlphaA;

BOOL (__stdcall * Real_IsCharAlphaNumericA)(CHAR a0)
    = IsCharAlphaNumericA;

BOOL (__stdcall * Real_IsCharAlphaNumericW)(WCHAR a0)
    = IsCharAlphaNumericW;

BOOL (__stdcall * Real_IsCharAlphaW)(WCHAR a0)
    = IsCharAlphaW;

BOOL (__stdcall * Real_IsCharLowerA)(CHAR a0)
    = IsCharLowerA;

BOOL (__stdcall * Real_IsCharLowerW)(WCHAR a0)
    = IsCharLowerW;

BOOL (__stdcall * Real_IsCharUpperA)(CHAR a0)
    = IsCharUpperA;

BOOL (__stdcall * Real_IsCharUpperW)(WCHAR a0)
    = IsCharUpperW;

BOOL (__stdcall * Real_IsChild)(HWND a0,
                                HWND a1)
    = IsChild;

BOOL (__stdcall * Real_IsClipboardFormatAvailable)(UINT a0)
    = IsClipboardFormatAvailable;

BOOL (__stdcall * Real_IsDBCSLeadByte)(BYTE a0)
    = IsDBCSLeadByte;

BOOL (__stdcall * Real_IsDBCSLeadByteEx)(UINT a0,
                                         BYTE a1)
    = IsDBCSLeadByteEx;

BOOL (__stdcall * Real_IsDebuggerPresent)(void)
    = IsDebuggerPresent;

BOOL (__stdcall * Real_IsDialogMessageA)(HWND a0,
                                         LPMSG a1)
    = IsDialogMessageA;

BOOL (__stdcall * Real_IsDialogMessageW)(HWND a0,
                                         LPMSG a1)
    = IsDialogMessageW;

UINT (__stdcall * Real_IsDlgButtonChecked)(HWND a0,
                                           int a1)
    = IsDlgButtonChecked;

BOOL (__stdcall * Real_IsIconic)(HWND a0)
    = IsIconic;

BOOL (__stdcall * Real_IsMenu)(HMENU a0)
    = IsMenu;

#if !defined(DETOURS_ARM)
BOOL (__stdcall * Real_IsProcessorFeaturePresent)(DWORD a0)
    = IsProcessorFeaturePresent;
#endif // !DETOURS_ARM

BOOL (__stdcall * Real_IsRectEmpty)(CONST RECT* a0)
    = IsRectEmpty;

BOOL (__stdcall * Real_IsValidCodePage)(UINT a0)
    = IsValidCodePage;

BOOL (__stdcall * Real_IsValidLocale)(LCID a0,
                                      DWORD a1)
    = IsValidLocale;

BOOL (__stdcall * Real_IsWindow)(HWND a0)
    = IsWindow;

BOOL (__stdcall * Real_IsWindowEnabled)(HWND a0)
    = IsWindowEnabled;

BOOL (__stdcall * Real_IsWindowUnicode)(HWND a0)
    = IsWindowUnicode;

BOOL (__stdcall * Real_IsWindowVisible)(HWND a0)
    = IsWindowVisible;

BOOL (__stdcall * Real_IsZoomed)(HWND a0)
    = IsZoomed;

BOOL (__stdcall * Real_KillTimer)(HWND a0,
                                  UINT_PTR a1)
    = KillTimer;

BOOL (__stdcall * Real_LPtoDP)(HDC a0,
                               POINT* a1,
                               int a2)
    = LPtoDP;

BOOL (__stdcall * Real_LineDDA)(int a0,
                                int a1,
                                int a2,
                                int a3,
                                LINEDDAPROC a4,
                                LPARAM a5)
    = LineDDA;

BOOL (__stdcall * Real_LineTo)(HDC a0,
                               int a1,
                               int a2)
    = LineTo;

HACCEL (__stdcall * Real_LoadAcceleratorsA)(HINSTANCE a0,
                                            LPCSTR a1)
    = LoadAcceleratorsA;

HACCEL (__stdcall * Real_LoadAcceleratorsW)(HINSTANCE a0,
                                            LPCWSTR a1)
    = LoadAcceleratorsW;

HBITMAP (__stdcall * Real_LoadBitmapA)(HINSTANCE a0,
                                       LPCSTR a1)
    = LoadBitmapA;

HBITMAP (__stdcall * Real_LoadBitmapW)(HINSTANCE a0,
                                       LPCWSTR a1)
    = LoadBitmapW;

HCURSOR (__stdcall * Real_LoadCursorA)(HINSTANCE a0,
                                       LPCSTR a1)
    = LoadCursorA;

HCURSOR (__stdcall * Real_LoadCursorFromFileA)(LPCSTR a0)
    = LoadCursorFromFileA;

HCURSOR (__stdcall * Real_LoadCursorFromFileW)(LPCWSTR a0)
    = LoadCursorFromFileW;

HCURSOR (__stdcall * Real_LoadCursorW)(HINSTANCE a0,
                                       LPCWSTR a1)
    = LoadCursorW;

HICON (__stdcall * Real_LoadIconA)(HINSTANCE a0,
                                   LPCSTR a1)
    = LoadIconA;

HICON (__stdcall * Real_LoadIconW)(HINSTANCE a0,
                                   LPCWSTR a1)
    = LoadIconW;

HANDLE (__stdcall * Real_LoadImageA)(HINSTANCE a0,
                                     LPCSTR a1,
                                     UINT a2,
                                     int a3,
                                     int a4,
                                     UINT a5)
    = LoadImageA;

HANDLE (__stdcall * Real_LoadImageW)(HINSTANCE a0,
                                     LPCWSTR a1,
                                     UINT a2,
                                     int a3,
                                     int a4,
                                     UINT a5)
    = LoadImageW;

HKL (__stdcall * Real_LoadKeyboardLayoutA)(LPCSTR a0,
                                           UINT a1)
    = LoadKeyboardLayoutA;

HKL (__stdcall * Real_LoadKeyboardLayoutW)(LPCWSTR a0,
                                           UINT a1)
    = LoadKeyboardLayoutW;

HMODULE (__stdcall * Real_LoadLibraryA)(LPCSTR a0)
    = LoadLibraryA;

HMODULE (__stdcall * Real_LoadLibraryExA)(LPCSTR a0,
                                          HANDLE a1,
                                          DWORD a2)
    = LoadLibraryExA;

HMODULE (__stdcall * Real_LoadLibraryExW)(LPCWSTR a0,
                                          HANDLE a1,
                                          DWORD a2)
    = LoadLibraryExW;

HMODULE (__stdcall * Real_LoadLibraryW)(LPCWSTR a0)
    = LoadLibraryW;

HMENU (__stdcall * Real_LoadMenuA)(HINSTANCE a0,
                                   LPCSTR a1)
    = LoadMenuA;

HMENU (__stdcall * Real_LoadMenuIndirectA)(CONST MENUTEMPLATEA* a0)
    = LoadMenuIndirectA;

HMENU (__stdcall * Real_LoadMenuIndirectW)(CONST MENUTEMPLATEW* a0)
    = LoadMenuIndirectW;

HMENU (__stdcall * Real_LoadMenuW)(HINSTANCE a0,
                                   LPCWSTR a1)
    = LoadMenuW;

DWORD (__stdcall * Real_LoadModule)(LPCSTR a0,
                                    LPVOID a1)
    = LoadModule;

HGLOBAL (__stdcall * Real_LoadResource)(HMODULE a0,
                                        HRSRC a1)
    = LoadResource;

int (__stdcall * Real_LoadStringA)(HINSTANCE a0,
                                   UINT a1,
                                   LPSTR a2,
                                   int a3)
    = LoadStringA;

int (__stdcall * Real_LoadStringW)(HINSTANCE a0,
                                   UINT a1,
                                   LPWSTR a2,
                                   int a3)
    = LoadStringW;

#if _MSC_VER < 1300
HLOCAL (__stdcall * Real_LocalAlloc)(UINT a0,
                                     UINT a1)
    = LocalAlloc;
#else
HLOCAL (__stdcall * Real_LocalAlloc)(UINT a0,
                                     SIZE_T a1)
    = LocalAlloc;
#endif

#if _MSC_VER < 1300
UINT (__stdcall * Real_LocalCompact)(UINT a0)
    = LocalCompact;
#else
SIZE_T (__stdcall * Real_LocalCompact)(UINT a0)
    = LocalCompact;
#endif

BOOL (__stdcall * Real_LocalFileTimeToFileTime)(CONST FILETIME* a0,
                                                LPFILETIME a1)
    = LocalFileTimeToFileTime;

UINT (__stdcall * Real_LocalFlags)(HLOCAL a0)
    = LocalFlags;

HLOCAL (__stdcall * Real_LocalFree)(HLOCAL a0)
    = LocalFree;

HLOCAL (__stdcall * Real_LocalHandle)(LPCVOID a0)
    = LocalHandle;

LPVOID (__stdcall * Real_LocalLock)(HLOCAL a0)
    = LocalLock;

#if _MSC_VER < 1300
HLOCAL (__stdcall * Real_LocalReAlloc)(HLOCAL a0,
                                       UINT a1,
                                       UINT a2)
    = LocalReAlloc;
#else
HLOCAL (__stdcall * Real_LocalReAlloc)(HLOCAL a0,
                                       SIZE_T a1,
                                       UINT a2)
    = LocalReAlloc;
#endif

#if _MSC_VER < 1300
UINT (__stdcall * Real_LocalShrink)(HLOCAL a0,
                                      UINT a1)
    = LocalShrink;
#else
SIZE_T (__stdcall * Real_LocalShrink)(HLOCAL a0,
                                      UINT a1)
    = LocalShrink;
#endif

#if _MSC_VER < 1300
UINT (__stdcall * Real_LocalSize)(HLOCAL a0)
    = LocalSize;
#else
SIZE_T (__stdcall * Real_LocalSize)(HLOCAL a0)
    = LocalSize;
#endif

BOOL (__stdcall * Real_LocalUnlock)(HLOCAL a0)
    = LocalUnlock;

BOOL (__stdcall * Real_LockFile)(HANDLE a0,
                                 DWORD a1,
                                 DWORD a2,
                                 DWORD a3,
                                 DWORD a4)
    = LockFile;

BOOL (__stdcall * Real_LockFileEx)(HANDLE a0,
                                   DWORD a1,
                                   DWORD a2,
                                   DWORD a3,
                                   DWORD a4,
                                   LPOVERLAPPED a5)
    = LockFileEx;

LPVOID (__stdcall * Real_LockResource)(HGLOBAL a0)
    = LockResource;

BOOL (__stdcall * Real_LockWindowUpdate)(HWND a0)
    = LockWindowUpdate;

int (__stdcall * Real_LookupIconIdFromDirectory)(PBYTE a0,
                                                 BOOL a1)
    = LookupIconIdFromDirectory;

int (__stdcall * Real_LookupIconIdFromDirectoryEx)(PBYTE a0,
                                                   BOOL a1,
                                                   int a2,
                                                   int a3,
                                                   UINT a4)
    = LookupIconIdFromDirectoryEx;

BOOL (__stdcall * Real_MapDialogRect)(HWND a0,
                                      LPRECT a1)
    = MapDialogRect;

LPVOID (__stdcall * Real_MapViewOfFile)(HANDLE a0,
                                        DWORD a1,
                                        DWORD a2,
                                        DWORD a3,
                                        SIZE_T a4)
    = MapViewOfFile;

LPVOID (__stdcall * Real_MapViewOfFileEx)(HANDLE a0,
                                          DWORD a1,
                                          DWORD a2,
                                          DWORD a3,
                                          SIZE_T a4,
                                          LPVOID a5)
    = MapViewOfFileEx;

UINT (__stdcall * Real_MapVirtualKeyA)(UINT a0,
                                       UINT a1)
    = MapVirtualKeyA;

UINT (__stdcall * Real_MapVirtualKeyExA)(UINT a0,
                                         UINT a1,
                                         HKL a2)
    = MapVirtualKeyExA;

UINT (__stdcall * Real_MapVirtualKeyExW)(UINT a0,
                                         UINT a1,
                                         HKL a2)
    = MapVirtualKeyExW;

UINT (__stdcall * Real_MapVirtualKeyW)(UINT a0,
                                       UINT a1)
    = MapVirtualKeyW;

int (__stdcall * Real_MapWindowPoints)(HWND a0,
                                       HWND a1,
                                       POINT* a2,
                                       UINT a3)
    = MapWindowPoints;

BOOL (__stdcall * Real_MaskBlt)(HDC a0,
                                int a1,
                                int a2,
                                int a3,
                                int a4,
                                HDC a5,
                                int a6,
                                int a7,
                                HBITMAP a8,
                                int a9,
                                int a10,
                                DWORD a11)
    = MaskBlt;

int (__stdcall * Real_MenuItemFromPoint)(HWND a0,
                                         HMENU a1,
                                         POINT a2)
    = MenuItemFromPoint;

BOOL (__stdcall * Real_MessageBeep)(UINT a0)
    = MessageBeep;

int (__stdcall * Real_MessageBoxA)(HWND a0,
                                   LPCSTR a1,
                                   LPCSTR a2,
                                   UINT a3)
    = MessageBoxA;

int (__stdcall * Real_MessageBoxExA)(HWND a0,
                                     LPCSTR a1,
                                     LPCSTR a2,
                                     UINT a3,
                                     WORD a4)
    = MessageBoxExA;

int (__stdcall * Real_MessageBoxExW)(HWND a0,
                                     LPCWSTR a1,
                                     LPCWSTR a2,
                                     UINT a3,
                                     WORD a4)
    = MessageBoxExW;

#if _MSC_VER < 1300
int (__stdcall * Real_MessageBoxIndirectA)(MSGBOXPARAMSA* a0)
    = MessageBoxIndirectA;
#else
int (__stdcall * Real_MessageBoxIndirectA)(CONST MSGBOXPARAMSA* a0)
    = MessageBoxIndirectA;
#endif

#if _MSC_VER < 1300
int (__stdcall * Real_MessageBoxIndirectW)(MSGBOXPARAMSW* a0)
    = MessageBoxIndirectW;
#else
int (__stdcall * Real_MessageBoxIndirectW)(CONST MSGBOXPARAMSW* a0)
    = MessageBoxIndirectW;
#endif

int (__stdcall * Real_MessageBoxW)(HWND a0,
                                   LPCWSTR a1,
                                   LPCWSTR a2,
                                   UINT a3)
    = MessageBoxW;

HRESULT (__stdcall * Real_MkParseDisplayName)(IBindCtx* a0,
                                              LPCOLESTR a1,
                                              ULONG* a2,
                                              IMoniker** a3)
    = MkParseDisplayName;

BOOL (__stdcall * Real_ModifyMenuA)(HMENU a0,
                                    UINT a1,
                                    UINT a2,
                                    UINT_PTR a3,
                                    LPCSTR a4)
    = ModifyMenuA;

BOOL (__stdcall * Real_ModifyMenuW)(HMENU a0,
                                    UINT a1,
                                    UINT a2,
                                    UINT_PTR a3,
                                    LPCWSTR a4)
    = ModifyMenuW;

BOOL (__stdcall * Real_ModifyWorldTransform)(HDC a0,
                                             CONST XFORM* a1,
                                             DWORD a2)
    = ModifyWorldTransform;

HRESULT (__stdcall * Real_MonikerCommonPrefixWith)(IMoniker* a0,
                                                   IMoniker* a1,
                                                   IMoniker** a2)
    = MonikerCommonPrefixWith;

HRESULT (__stdcall * Real_MonikerRelativePathTo)(IMoniker* a0,
                                                 IMoniker* a1,
                                                 IMoniker** a2,
                                                 BOOL a3)
    = MonikerRelativePathTo;

BOOL (__stdcall * Real_MoveFileA)(LPCSTR a0,
                                  LPCSTR a1)
    = MoveFileA;

BOOL (__stdcall * Real_MoveFileExA)(LPCSTR a0,
                                    LPCSTR a1,
                                    DWORD a2)
    = MoveFileExA;

BOOL (__stdcall * Real_MoveFileExW)(LPCWSTR a0,
                                    LPCWSTR a1,
                                    DWORD a2)
    = MoveFileExW;

BOOL (__stdcall * Real_MoveFileW)(LPCWSTR a0,
                                  LPCWSTR a1)
    = MoveFileW;

BOOL (__stdcall * Real_MoveToEx)(HDC a0,
                                 int a1,
                                 int a2,
                                 POINT* a3)
    = MoveToEx;

BOOL (__stdcall * Real_MoveWindow)(HWND a0,
                                   int a1,
                                   int a2,
                                   int a3,
                                   int a4,
                                   BOOL a5)
    = MoveWindow;

#if _MSC_VER < 1300
DWORD (__stdcall * Real_MsgWaitForMultipleObjects)(DWORD a0,
                                                   HANDLE * a1,
                                                   BOOL a2,
                                                   DWORD a3,
                                                   DWORD a4)
    = MsgWaitForMultipleObjects;
#else
DWORD (__stdcall * Real_MsgWaitForMultipleObjects)(DWORD a0,
                                                   CONST HANDLE * a1,
                                                   BOOL a2,
                                                   DWORD a3,
                                                   DWORD a4)
    = MsgWaitForMultipleObjects;
#endif

#if _MSC_VER < 1300
DWORD (__stdcall * Real_MsgWaitForMultipleObjectsEx)(DWORD a0,
                                                     HANDLE * a1,
                                                     DWORD a2,
                                                     DWORD a3,
                                                     DWORD a4)
    = MsgWaitForMultipleObjectsEx;
#else
DWORD (__stdcall * Real_MsgWaitForMultipleObjectsEx)(DWORD a0,
                                                     CONST HANDLE * a1,
                                                     DWORD a2,
                                                     DWORD a3,
                                                     DWORD a4)
    = MsgWaitForMultipleObjectsEx;
#endif

int (__stdcall * Real_MulDiv)(int a0,
                              int a1,
                              int a2)
    = MulDiv;

DWORD (__stdcall * Real_OemKeyScan)(WORD a0)
    = OemKeyScan;

BOOL (__stdcall * Real_OemToCharA)(LPCSTR a0,
                                   LPSTR a1)
    = OemToCharA;

BOOL (__stdcall * Real_OemToCharBuffA)(LPCSTR a0,
                                       LPSTR a1,
                                       DWORD a2)
    = OemToCharBuffA;

BOOL (__stdcall * Real_OemToCharBuffW)(LPCSTR a0,
                                       LPWSTR a1,
                                       DWORD a2)
    = OemToCharBuffW;

BOOL (__stdcall * Real_OemToCharW)(LPCSTR a0,
                                   LPWSTR a1)
    = OemToCharW;

int (__stdcall * Real_OffsetClipRgn)(HDC a0,
                                     int a1,
                                     int a2)
    = OffsetClipRgn;

BOOL (__stdcall * Real_OffsetRect)(LPRECT a0,
                                   int a1,
                                   int a2)
    = OffsetRect;

int (__stdcall * Real_OffsetRgn)(HRGN a0,
                                 int a1,
                                 int a2)
    = OffsetRgn;

BOOL (__stdcall * Real_OffsetViewportOrgEx)(HDC a0,
                                            int a1,
                                            int a2,
                                            POINT* a3)
    = OffsetViewportOrgEx;

BOOL (__stdcall * Real_OffsetWindowOrgEx)(HDC a0,
                                          int a1,
                                          int a2,
                                          POINT* a3)
    = OffsetWindowOrgEx;

DWORD (__stdcall * Real_OleBuildVersion)(void)
    = OleBuildVersion;

HRESULT (__stdcall * Real_OleConvertIStorageToOLESTREAM)(IStorage* a0,
                                                         LPOLESTREAM a1)
    = OleConvertIStorageToOLESTREAM;

HRESULT (__stdcall * Real_OleConvertIStorageToOLESTREAMEx)(IStorage* a0,
                                                           CLIPFORMAT a1,
                                                           LONG a2,
                                                           LONG a3,
                                                           DWORD a4,
                                                           LPSTGMEDIUM a5,
                                                           LPOLESTREAM a6)
    = OleConvertIStorageToOLESTREAMEx;

HRESULT (__stdcall * Real_OleConvertOLESTREAMToIStorage)(LPOLESTREAM a0,
                                                         LPSTORAGE a1,
                                                         CONST DVTARGETDEVICE* a2)
    = OleConvertOLESTREAMToIStorage;

HRESULT (__stdcall * Real_OleConvertOLESTREAMToIStorageEx)(LPOLESTREAM a0,
                                                           LPSTORAGE a1,
                                                           CLIPFORMAT* a2,
                                                           LONG* a3,
                                                           LONG* a4,
                                                           DWORD* a5,
                                                           LPSTGMEDIUM a6)
    = OleConvertOLESTREAMToIStorageEx;

HRESULT (__stdcall * Real_OleCreate)(CONST IID& a0,
                                     CONST IID& a1,
                                     DWORD a2,
                                     LPFORMATETC a3,
                                     LPOLECLIENTSITE a4,
                                     LPSTORAGE a5,
                                     LPVOID* a6)
    = OleCreate;

HRESULT (__stdcall * Real_OleCreateDefaultHandler)(CONST IID& a0,
                                                   LPUNKNOWN a1,
                                                   CONST IID& a2,
                                                   LPVOID* a3)
    = OleCreateDefaultHandler;

HRESULT (__stdcall * Real_OleCreateEmbeddingHelper)(CONST IID& a0,
                                                    LPUNKNOWN a1,
                                                    DWORD a2,
                                                    LPCLASSFACTORY a3,
                                                    CONST IID& a4,
                                                    LPVOID* a5)
    = OleCreateEmbeddingHelper;

HRESULT (__stdcall * Real_OleCreateEx)(CONST IID& a0,
                                       CONST IID& a1,
                                       DWORD a2,
                                       DWORD a3,
                                       ULONG a4,
                                       DWORD* a5,
                                       LPFORMATETC a6,
                                       IAdviseSink* a7,
                                       DWORD* a8,
                                       LPOLECLIENTSITE a9,
                                       LPSTORAGE a10,
                                       LPVOID* a11)
    = OleCreateEx;

HRESULT (__stdcall * Real_OleCreateFromData)(IDataObject* a0,
                                             CONST IID& a1,
                                             DWORD a2,
                                             LPFORMATETC a3,
                                             LPOLECLIENTSITE a4,
                                             LPSTORAGE a5,
                                             LPVOID* a6)
    = OleCreateFromData;

HRESULT (__stdcall * Real_OleCreateFromDataEx)(IDataObject* a0,
                                               CONST IID& a1,
                                               DWORD a2,
                                               DWORD a3,
                                               ULONG a4,
                                               DWORD* a5,
                                               LPFORMATETC a6,
                                               IAdviseSink* a7,
                                               DWORD* a8,
                                               LPOLECLIENTSITE a9,
                                               LPSTORAGE a10,
                                               LPVOID* a11)
    = OleCreateFromDataEx;

HRESULT (__stdcall * Real_OleCreateFromFile)(CONST IID& a0,
                                             LPCOLESTR a1,
                                             CONST IID& a2,
                                             DWORD a3,
                                             LPFORMATETC a4,
                                             LPOLECLIENTSITE a5,
                                             LPSTORAGE a6,
                                             LPVOID* a7)
    = OleCreateFromFile;

HRESULT (__stdcall * Real_OleCreateFromFileEx)(CONST IID& a0,
                                               LPCOLESTR a1,
                                               CONST IID& a2,
                                               DWORD a3,
                                               DWORD a4,
                                               ULONG a5,
                                               DWORD* a6,
                                               LPFORMATETC a7,
                                               IAdviseSink* a8,
                                               DWORD* a9,
                                               LPOLECLIENTSITE a10,
                                               LPSTORAGE a11,
                                               LPVOID* a12)
    = OleCreateFromFileEx;

HRESULT (__stdcall * Real_OleCreateLink)(IMoniker* a0,
                                         CONST IID& a1,
                                         DWORD a2,
                                         LPFORMATETC a3,
                                         LPOLECLIENTSITE a4,
                                         LPSTORAGE a5,
                                         LPVOID* a6)
    = OleCreateLink;

HRESULT (__stdcall * Real_OleCreateLinkEx)(IMoniker* a0,
                                           CONST IID& a1,
                                           DWORD a2,
                                           DWORD a3,
                                           ULONG a4,
                                           DWORD* a5,
                                           LPFORMATETC a6,
                                           IAdviseSink* a7,
                                           DWORD* a8,
                                           LPOLECLIENTSITE a9,
                                           LPSTORAGE a10,
                                           LPVOID* a11)
    = OleCreateLinkEx;

HRESULT (__stdcall * Real_OleCreateLinkFromData)(IDataObject* a0,
                                                 CONST IID& a1,
                                                 DWORD a2,
                                                 LPFORMATETC a3,
                                                 LPOLECLIENTSITE a4,
                                                 LPSTORAGE a5,
                                                 LPVOID* a6)
    = OleCreateLinkFromData;

HRESULT (__stdcall * Real_OleCreateLinkFromDataEx)(IDataObject* a0,
                                                   CONST IID& a1,
                                                   DWORD a2,
                                                   DWORD a3,
                                                   ULONG a4,
                                                   DWORD* a5,
                                                   LPFORMATETC a6,
                                                   IAdviseSink* a7,
                                                   DWORD* a8,
                                                   LPOLECLIENTSITE a9,
                                                   LPSTORAGE a10,
                                                   LPVOID* a11)
    = OleCreateLinkFromDataEx;

HRESULT (__stdcall * Real_OleCreateLinkToFile)(LPCOLESTR a0,
                                               CONST IID& a1,
                                               DWORD a2,
                                               LPFORMATETC a3,
                                               LPOLECLIENTSITE a4,
                                               LPSTORAGE a5,
                                               LPVOID* a6)
    = OleCreateLinkToFile;

HRESULT (__stdcall * Real_OleCreateLinkToFileEx)(LPCOLESTR a0,
                                                 CONST IID& a1,
                                                 DWORD a2,
                                                 DWORD a3,
                                                 ULONG a4,
                                                 DWORD* a5,
                                                 LPFORMATETC a6,
                                                 IAdviseSink* a7,
                                                 DWORD* a8,
                                                 LPOLECLIENTSITE a9,
                                                 LPSTORAGE a10,
                                                 LPVOID* a11)
    = OleCreateLinkToFileEx;

HOLEMENU (__stdcall * Real_OleCreateMenuDescriptor)(HMENU a0,
                                                    LPOLEMENUGROUPWIDTHS a1)
    = OleCreateMenuDescriptor;

HRESULT (__stdcall * Real_OleCreateStaticFromData)(IDataObject* a0,
                                                   CONST IID& a1,
                                                   DWORD a2,
                                                   LPFORMATETC a3,
                                                   LPOLECLIENTSITE a4,
                                                   LPSTORAGE a5,
                                                   LPVOID* a6)
    = OleCreateStaticFromData;

HRESULT (__stdcall * Real_OleDestroyMenuDescriptor)(HOLEMENU a0)
    = OleDestroyMenuDescriptor;

HRESULT (__stdcall * Real_OleDoAutoConvert)(LPSTORAGE a0,
                                            LPGUID a1)
    = OleDoAutoConvert;

HRESULT (__stdcall * Real_OleDraw)(LPUNKNOWN a0,
                                   DWORD a1,
                                   HDC a2,
                                   LPCRECT a3)
    = OleDraw;

HANDLE (__stdcall * Real_OleDuplicateData)(HANDLE a0,
                                           CLIPFORMAT a1,
                                           UINT a2)
    = OleDuplicateData;

HRESULT (__stdcall * Real_OleFlushClipboard)(void)
    = OleFlushClipboard;

HRESULT (__stdcall * Real_OleGetAutoConvert)(CONST IID& a0,
                                             LPGUID a1)
    = OleGetAutoConvert;

HRESULT (__stdcall * Real_OleGetClipboard)(IDataObject** a0)
    = OleGetClipboard;

HGLOBAL (__stdcall * Real_OleGetIconOfClass)(CONST IID& a0,
                                             LPOLESTR a1,
                                             BOOL a2)
    = OleGetIconOfClass;

HGLOBAL (__stdcall * Real_OleGetIconOfFile)(LPOLESTR a0,
                                            BOOL a1)
    = OleGetIconOfFile;

HRESULT (__stdcall * Real_OleInitialize)(LPVOID a0)
    = OleInitialize;

HRESULT (__stdcall * Real_OleIsCurrentClipboard)(IDataObject* a0)
    = OleIsCurrentClipboard;

BOOL (__stdcall * Real_OleIsRunning)(IOleObject* a0)
    = OleIsRunning;

HRESULT (__stdcall * Real_OleLoad)(LPSTORAGE a0,
                                   CONST IID& a1,
                                   LPOLECLIENTSITE a2,
                                   LPVOID* a3)
    = OleLoad;

HRESULT (__stdcall * Real_OleLoadFromStream)(LPSTREAM a0,
                                             CONST IID& a1,
                                             LPVOID* a2)
    = OleLoadFromStream;

HRESULT (__stdcall * Real_OleLockRunning)(LPUNKNOWN a0,
                                          BOOL a1,
                                          BOOL a2)
    = OleLockRunning;

HGLOBAL (__stdcall * Real_OleMetafilePictFromIconAndLabel)(HICON a0,
                                                           LPOLESTR a1,
                                                           LPOLESTR a2,
                                                           UINT a3)
    = OleMetafilePictFromIconAndLabel;

HRESULT (__stdcall * Real_OleNoteObjectVisible)(LPUNKNOWN a0,
                                                BOOL a1)
    = OleNoteObjectVisible;

HRESULT (__stdcall * Real_OleQueryCreateFromData)(IDataObject* a0)
    = OleQueryCreateFromData;

HRESULT (__stdcall * Real_OleQueryLinkFromData)(IDataObject* a0)
    = OleQueryLinkFromData;

HRESULT (__stdcall * Real_OleRegEnumFormatEtc)(CONST IID& a0,
                                               DWORD a1,
                                               IEnumFORMATETC** a2)
    = OleRegEnumFormatEtc;

HRESULT (__stdcall * Real_OleRegEnumVerbs)(CONST IID& a0,
                                           IEnumOLEVERB** a1)
    = OleRegEnumVerbs;

HRESULT (__stdcall * Real_OleRegGetMiscStatus)(CONST IID& a0,
                                               DWORD a1,
                                               DWORD* a2)
    = OleRegGetMiscStatus;

HRESULT (__stdcall * Real_OleRegGetUserType)(CONST IID& a0,
                                             DWORD a1,
                                             LPOLESTR* a2)
    = OleRegGetUserType;

HRESULT (__stdcall * Real_OleRun)(LPUNKNOWN a0)
    = OleRun;

HRESULT (__stdcall * Real_OleSave)(LPPERSISTSTORAGE a0,
                                   LPSTORAGE a1,
                                   BOOL a2)
    = OleSave;

HRESULT (__stdcall * Real_OleSaveToStream)(IPersistStream* a0,
                                           LPSTREAM a1)
    = OleSaveToStream;

HRESULT (__stdcall * Real_OleSetAutoConvert)(CONST IID& a0,
                                             CONST IID& a1)
    = OleSetAutoConvert;

HRESULT (__stdcall * Real_OleSetClipboard)(IDataObject* a0)
    = OleSetClipboard;

HRESULT (__stdcall * Real_OleSetContainedObject)(LPUNKNOWN a0,
                                                 BOOL a1)
    = OleSetContainedObject;

HRESULT (__stdcall * Real_OleSetMenuDescriptor)(HOLEMENU a0,
                                                HWND a1,
                                                HWND a2,
                                                LPOLEINPLACEFRAME a3,
                                                LPOLEINPLACEACTIVEOBJECT a4)
    = OleSetMenuDescriptor;

HRESULT (__stdcall * Real_OleTranslateAccelerator)(LPOLEINPLACEFRAME a0,
                                                   LPOLEINPLACEFRAMEINFO a1,
                                                   LPMSG a2)
    = OleTranslateAccelerator;

void (__stdcall * Real_OleUninitialize)(void)
    = OleUninitialize;

BOOL (__stdcall * Real_OpenClipboard)(HWND a0)
    = OpenClipboard;

#if _MSC_VER < 1300
HDESK (__stdcall * Real_OpenDesktopA)(LPSTR a0,
                                      DWORD a1,
                                      BOOL a2,
                                      ACCESS_MASK a3)
    = OpenDesktopA;
#else
HDESK (__stdcall * Real_OpenDesktopA)(LPCSTR a0,
                                      DWORD a1,
                                      BOOL a2,
                                      ACCESS_MASK a3)
    = OpenDesktopA;
#endif

#if _MSC_VER < 1300
HDESK (__stdcall * Real_OpenDesktopW)(LPWSTR a0,
                                      DWORD a1,
                                      BOOL a2,
                                      ACCESS_MASK a3)
    = OpenDesktopW;
#else
HDESK (__stdcall * Real_OpenDesktopW)(LPCWSTR a0,
                                      DWORD a1,
                                      BOOL a2,
                                      ACCESS_MASK a3)
    = OpenDesktopW;
#endif

HANDLE (__stdcall * Real_OpenEventA)(DWORD a0,
                                     BOOL a1,
                                     LPCSTR a2)
    = OpenEventA;

HANDLE (__stdcall * Real_OpenEventW)(DWORD a0,
                                     BOOL a1,
                                     LPCWSTR a2)
    = OpenEventW;

HFILE (__stdcall * Real_OpenFile)(LPCSTR a0,
                                  LPOFSTRUCT a1,
                                  UINT a2)
    = OpenFile;

HANDLE (__stdcall * Real_OpenFileMappingA)(DWORD a0,
                                           BOOL a1,
                                           LPCSTR a2)
    = OpenFileMappingA;

HANDLE (__stdcall * Real_OpenFileMappingW)(DWORD a0,
                                           BOOL a1,
                                           LPCWSTR a2)
    = OpenFileMappingW;

BOOL (__stdcall * Real_OpenIcon)(HWND a0)
    = OpenIcon;

HDESK (__stdcall * Real_OpenInputDesktop)(DWORD a0,
                                          BOOL a1,
                                          ACCESS_MASK a2)
    = OpenInputDesktop;

HANDLE (__stdcall * Real_OpenMutexA)(DWORD a0,
                                     BOOL a1,
                                     LPCSTR a2)
    = OpenMutexA;

HANDLE (__stdcall * Real_OpenMutexW)(DWORD a0,
                                     BOOL a1,
                                     LPCWSTR a2)
    = OpenMutexW;

HANDLE (__stdcall * Real_OpenProcess)(DWORD a0,
                                      BOOL a1,
                                      DWORD pid)
    = OpenProcess;

BOOL (__stdcall * Real_OpenProcessToken)(__in   HANDLE ProcessHandle,
                                         __in   DWORD DesiredAccess,
                                         __out  PHANDLE TokenHandle
                                        )
    = OpenProcessToken;

HANDLE (__stdcall * Real_OpenSemaphoreA)(DWORD a0,
                                         BOOL a1,
                                         LPCSTR a2)
    = OpenSemaphoreA;

HANDLE (__stdcall * Real_OpenSemaphoreW)(DWORD a0,
                                         BOOL a1,
                                         LPCWSTR a2)
    = OpenSemaphoreW;

HANDLE (__stdcall * Real_OpenWaitableTimerA)(DWORD a0,
                                             BOOL a1,
                                             LPCSTR a2)
    = OpenWaitableTimerA;

HANDLE (__stdcall * Real_OpenWaitableTimerW)(DWORD a0,
                                             BOOL a1,
                                             LPCWSTR a2)
    = OpenWaitableTimerW;

#if _MSC_VER < 1300
HWINSTA (__stdcall * Real_OpenWindowStationA)(LPSTR a0,
                                              BOOL a1,
                                              ACCESS_MASK a2)
    = OpenWindowStationA;
#else
HWINSTA (__stdcall * Real_OpenWindowStationA)(LPCSTR a0,
                                              BOOL a1,
                                              ACCESS_MASK a2)
    = OpenWindowStationA;
#endif

#if _MSC_VER < 1300
HWINSTA (__stdcall * Real_OpenWindowStationW)(LPWSTR a0,
                                              BOOL a1,
                                              ACCESS_MASK a2)
    = OpenWindowStationW;
#else
HWINSTA (__stdcall * Real_OpenWindowStationW)(LPCWSTR a0,
                                              BOOL a1,
                                              ACCESS_MASK a2)
    = OpenWindowStationW;
#endif

void (__stdcall * Real_OutputDebugStringA)(LPCSTR a0)
    = OutputDebugStringA;

void (__stdcall * Real_OutputDebugStringW)(LPCWSTR a0)
    = OutputDebugStringW;

LPARAM (__stdcall * Real_PackDDElParam)(UINT a0,
                                        UINT_PTR a1,
                                        UINT_PTR a2)
    = PackDDElParam;

BOOL (__stdcall * Real_PaintDesktop)(HDC a0)
    = PaintDesktop;

BOOL (__stdcall * Real_PaintRgn)(HDC a0,
                                 HRGN a1)
    = PaintRgn;

BOOL (__stdcall * Real_PatBlt)(HDC a0,
                               int a1,
                               int a2,
                               int a3,
                               int a4,
                               DWORD a5)
    = PatBlt;

HRGN (__stdcall * Real_PathToRegion)(HDC a0)
    = PathToRegion;

BOOL (__stdcall * Real_PeekConsoleInputA)(HANDLE a0,
                                          PINPUT_RECORD a1,
                                          DWORD a2,
                                          LPDWORD a3)
    = PeekConsoleInputA;

BOOL (__stdcall * Real_PeekConsoleInputW)(HANDLE a0,
                                          PINPUT_RECORD a1,
                                          DWORD a2,
                                          LPDWORD a3)
    = PeekConsoleInputW;

BOOL (__stdcall * Real_PeekMessageA)(LPMSG a0,
                                     HWND a1,
                                     UINT a2,
                                     UINT a3,
                                     UINT a4)
    = PeekMessageA;

BOOL (__stdcall * Real_PeekMessageW)(LPMSG a0,
                                     HWND a1,
                                     UINT a2,
                                     UINT a3,
                                     UINT a4)
    = PeekMessageW;

BOOL (__stdcall * Real_PeekNamedPipe)(HANDLE a0,
                                      LPVOID a1,
                                      DWORD a2,
                                      LPDWORD a3,
                                      LPDWORD a4,
                                      LPDWORD a5)
    = PeekNamedPipe;

BOOL (__stdcall * Real_Pie)(HDC a0,
                            int a1,
                            int a2,
                            int a3,
                            int a4,
                            int a5,
                            int a6,
                            int a7,
                            int a8)
    = Pie;

BOOL (__stdcall * Real_PlayEnhMetaFile)(HDC a0,
                                        HENHMETAFILE a1,
                                        CONST RECT* a2)
    = PlayEnhMetaFile;

BOOL (__stdcall * Real_PlayEnhMetaFileRecord)(HDC a0,
                                              LPHANDLETABLE a1,
                                              CONST ENHMETARECORD* a2,
                                              UINT a3)
    = PlayEnhMetaFileRecord;

BOOL (__stdcall * Real_PlayMetaFile)(HDC a0,
                                     HMETAFILE a1)
    = PlayMetaFile;

BOOL (__stdcall * Real_PlayMetaFileRecord)(HDC a0,
                                           LPHANDLETABLE a1,
                                           LPMETARECORD a2,
                                           UINT a3)
    = PlayMetaFileRecord;

BOOL (__stdcall * Real_PlgBlt)(HDC a0,
                               CONST POINT* a1,
                               HDC a2,
                               int a3,
                               int a4,
                               int a5,
                               int a6,
                               HBITMAP a7,
                               int a8,
                               int a9)
    = PlgBlt;

BOOL (__stdcall * Real_PolyBezier)(HDC a0,
                                   CONST POINT* a1,
                                   DWORD a2)
    = PolyBezier;

BOOL (__stdcall * Real_PolyBezierTo)(HDC a0,
                                     CONST POINT* a1,
                                     DWORD a2)
    = PolyBezierTo;

BOOL (__stdcall * Real_PolyDraw)(HDC a0,
                                 CONST POINT* a1,
                                 CONST BYTE* a2,
                                 int a3)
    = PolyDraw;

BOOL (__stdcall * Real_PolyPolygon)(HDC a0,
                                    CONST POINT* a1,
                                    CONST INT* a2,
                                    int a3)
    = PolyPolygon;

BOOL (__stdcall * Real_PolyPolyline)(HDC a0,
                                     CONST POINT* a1,
                                     CONST DWORD* a2,
                                     DWORD a3)
    = PolyPolyline;

BOOL (__stdcall * Real_PolyTextOutA)(HDC a0,
                                     CONST POLYTEXTA* a1,
                                     int a2)
    = PolyTextOutA;

BOOL (__stdcall * Real_PolyTextOutW)(HDC a0,
                                     CONST POLYTEXTW* a1,
                                     int a2)
    = PolyTextOutW;

BOOL (__stdcall * Real_Polygon)(HDC a0,
                                CONST POINT* a1,
                                int a2)
    = Polygon;

BOOL (__stdcall * Real_Polyline)(HDC a0,
                                 CONST POINT* a1,
                                 int a2)
    = Polyline;

BOOL (__stdcall * Real_PolylineTo)(HDC a0,
                                   CONST POINT* a1,
                                   DWORD a2)
    = PolylineTo;

BOOL (__stdcall * Real_PostMessageA)(HWND a0,
                                     UINT a1,
                                     WPARAM a2,
                                     LPARAM a3)
    = PostMessageA;

BOOL (__stdcall * Real_PostMessageW)(HWND a0,
                                     UINT a1,
                                     WPARAM a2,
                                     LPARAM a3)
    = PostMessageW;

BOOL (__stdcall * Real_PostQueuedCompletionStatus)(HANDLE a0,
                                                   DWORD a1,
                                                   ULONG_PTR a2,
                                                   LPOVERLAPPED a3)
    = PostQueuedCompletionStatus;

void (__stdcall * Real_PostQuitMessage)(int a0)
    = PostQuitMessage;

BOOL (__stdcall * Real_PostThreadMessageA)(DWORD a0,
                                           UINT a1,
                                           WPARAM a2,
                                           LPARAM a3)
    = PostThreadMessageA;

BOOL (__stdcall * Real_PostThreadMessageW)(DWORD a0,
                                           UINT a1,
                                           WPARAM a2,
                                           LPARAM a3)
    = PostThreadMessageW;

DWORD (__stdcall * Real_PrepareTape)(HANDLE a0,
                                     DWORD a1,
                                     BOOL a2)
    = PrepareTape;

HRESULT (__stdcall * Real_ProgIDFromCLSID)(CONST IID& a0,
                                           LPOLESTR* a1)
    = ProgIDFromCLSID;

HRESULT (__stdcall * Real_PropVariantClear)(PROPVARIANT* a0)
    = PropVariantClear;

HRESULT (__stdcall * Real_PropVariantCopy)(PROPVARIANT* a0,
                                           CONST PROPVARIANT* a1)
    = PropVariantCopy;

BOOL (__stdcall * Real_PtInRect)(CONST RECT* a0,
                                 POINT a1)
    = PtInRect;

BOOL (__stdcall * Real_PtInRegion)(HRGN a0,
                                   int a1,
                                   int a2)
    = PtInRegion;

BOOL (__stdcall * Real_PtVisible)(HDC a0,
                                  int a1,
                                  int a2)
    = PtVisible;

BOOL (__stdcall * Real_PulseEvent)(HANDLE a0)
    = PulseEvent;

BOOL (__stdcall * Real_PurgeComm)(HANDLE a0,
                                  DWORD a1)
    = PurgeComm;

DWORD (__stdcall * Real_QueryDosDeviceA)(LPCSTR a0,
                                         LPSTR a1,
                                         DWORD a2)
    = QueryDosDeviceA;

DWORD (__stdcall * Real_QueryDosDeviceW)(LPCWSTR a0,
                                         LPWSTR a1,
                                         DWORD a2)
    = QueryDosDeviceW;

BOOL (__stdcall * Real_QueryPerformanceCounter)(LARGE_INTEGER* a0)
    = QueryPerformanceCounter;

BOOL (__stdcall * Real_QueryPerformanceFrequency)(LARGE_INTEGER* a0)
    = QueryPerformanceFrequency;

DWORD (__stdcall * Real_QueueUserAPC)(PAPCFUNC a0,
                                      HANDLE a1,
                                      ULONG_PTR a2)
    = QueueUserAPC;

void (__stdcall * Real_RaiseException)(DWORD a0,
                                       DWORD a1,
                                       DWORD a2,
                                       CONST ULONG_PTR* a3)
    = RaiseException;

HRESULT (__stdcall * Real_ReadClassStg)(LPSTORAGE a0,
                                        CLSID* a1)
    = ReadClassStg;

HRESULT (__stdcall * Real_ReadClassStm)(LPSTREAM a0,
                                        CLSID* a1)
    = ReadClassStm;

BOOL (__stdcall * Real_ReadConsoleA)(
                                     HANDLE a0,
                                     LPVOID a1,
                                     DWORD a2,
                                     LPDWORD a3,
#ifdef ENABLE_INSERT_MODE
                                     PCONSOLE_READCONSOLE_CONTROL a4
#else
                                     LPVOID a4
#endif
                                    )
    = ReadConsoleA;

BOOL (__stdcall * Real_ReadConsoleInputA)(HANDLE a0,
                                          PINPUT_RECORD a1,
                                          DWORD a2,
                                          LPDWORD a3)
    = ReadConsoleInputA;

BOOL (__stdcall * Real_ReadConsoleInputW)(HANDLE a0,
                                          PINPUT_RECORD a1,
                                          DWORD a2,
                                          LPDWORD a3)
    = ReadConsoleInputW;

BOOL (__stdcall * Real_ReadConsoleOutputA)(HANDLE a0,
                                           PCHAR_INFO a1,
                                           COORD a2,
                                           COORD a3,
                                           PSMALL_RECT a4)
    = ReadConsoleOutputA;

BOOL (__stdcall * Real_ReadConsoleOutputAttribute)(HANDLE a0,
                                                   LPWORD a1,
                                                   DWORD a2,
                                                   COORD a3,
                                                   LPDWORD a4)
    = ReadConsoleOutputAttribute;

BOOL (__stdcall * Real_ReadConsoleOutputCharacterA)(HANDLE a0,
                                                    LPSTR a1,
                                                    DWORD a2,
                                                    COORD a3,
                                                    LPDWORD a4)
    = ReadConsoleOutputCharacterA;

BOOL (__stdcall * Real_ReadConsoleOutputCharacterW)(HANDLE a0,
                                                    LPWSTR a1,
                                                    DWORD a2,
                                                    COORD a3,
                                                    LPDWORD a4)
    = ReadConsoleOutputCharacterW;

BOOL (__stdcall * Real_ReadConsoleOutputW)(HANDLE a0,
                                           PCHAR_INFO a1,
                                           COORD a2,
                                           COORD a3,
                                           PSMALL_RECT a4)
    = ReadConsoleOutputW;

BOOL (__stdcall * Real_ReadConsoleW)(
                                     HANDLE a0,
                                     LPVOID a1,
                                     DWORD a2,
                                     LPDWORD a3,
#ifdef ENABLE_INSERT_MODE
                                     PCONSOLE_READCONSOLE_CONTROL a4
#else
                                     LPVOID a4
#endif
                                    )
    = ReadConsoleW;

BOOL (__stdcall * Real_ReadDirectoryChangesW)(HANDLE a0,
                                              LPVOID a1,
                                              DWORD a2,
                                              BOOL a3,
                                              DWORD a4,
                                              LPDWORD a5,
                                              LPOVERLAPPED a6,
                                              LPOVERLAPPED_COMPLETION_ROUTINE a7)
    = ReadDirectoryChangesW;

BOOL (__stdcall * Real_ReadFile)(HANDLE a0,
                                 LPVOID a1,
                                 DWORD a2,
                                 LPDWORD a3,
                                 LPOVERLAPPED a4)
    = ReadFile;

BOOL (__stdcall * Real_ReadFileEx)(HANDLE a0,
                                   LPVOID a1,
                                   DWORD a2,
                                   LPOVERLAPPED a3,
                                   LPOVERLAPPED_COMPLETION_ROUTINE a4)
    = ReadFileEx;

HRESULT (__stdcall * Real_ReadFmtUserTypeStg)(LPSTORAGE a0,
                                              CLIPFORMAT* a1,
                                              LPOLESTR* a2)
    = ReadFmtUserTypeStg;

BOOL (__stdcall * Real_ReadProcessMemory)(HANDLE a0,
                                          LPCVOID a1,
                                          LPVOID a2,
                                          DWORD_PTR a3,
                                          PDWORD_PTR a4)
    = ReadProcessMemory;

UINT (__stdcall * Real_RealizePalette)(HDC a0)
    = RealizePalette;

BOOL (__stdcall * Real_RectInRegion)(HRGN a0,
                                     CONST RECT* a1)
    = RectInRegion;

BOOL (__stdcall * Real_RectVisible)(HDC a0,
                                    CONST RECT* a1)
    = RectVisible;

BOOL (__stdcall * Real_Rectangle)(HDC a0,
                                  int a1,
                                  int a2,
                                  int a3,
                                  int a4)
    = Rectangle;

BOOL (__stdcall * Real_RedrawWindow)(HWND a0,
                                     CONST RECT* a1,
                                     HRGN a2,
                                     UINT a3)
    = RedrawWindow;

ATOM (__stdcall * Real_RegisterClassA)(CONST WNDCLASSA* a0)
    = RegisterClassA;

ATOM (__stdcall * Real_RegisterClassExA)(CONST WNDCLASSEXA* a0)
    = RegisterClassExA;

ATOM (__stdcall * Real_RegisterClassExW)(CONST WNDCLASSEXW* a0)
    = RegisterClassExW;

ATOM (__stdcall * Real_RegisterClassW)(CONST WNDCLASSW* a0)
    = RegisterClassW;

UINT (__stdcall * Real_RegisterClipboardFormatA)(LPCSTR a0)
    = RegisterClipboardFormatA;

UINT (__stdcall * Real_RegisterClipboardFormatW)(LPCWSTR a0)
    = RegisterClipboardFormatW;

HRESULT (__stdcall * Real_RegisterDragDrop)(HWND a0,
                                            IDropTarget* a1)
    = RegisterDragDrop;

BOOL (__stdcall * Real_RegisterHotKey)(HWND a0,
                                       int a1,
                                       UINT a2,
                                       UINT a3)
    = RegisterHotKey;

UINT (__stdcall * Real_RegisterWindowMessageA)(LPCSTR a0)
    = RegisterWindowMessageA;

UINT (__stdcall * Real_RegisterWindowMessageW)(LPCWSTR a0)
    = RegisterWindowMessageW;

BOOL (__stdcall * Real_ReleaseCapture)(void)
    = ReleaseCapture;

int (__stdcall * Real_ReleaseDC)(HWND a0,
                                 HDC a1)
    = ReleaseDC;

BOOL (__stdcall * Real_ReleaseMutex)(HANDLE a0)
    = ReleaseMutex;

BOOL (__stdcall * Real_ReleaseSemaphore)(HANDLE a0,
                                         LONG a1,
                                         LPLONG a2)
    = ReleaseSemaphore;

void (__stdcall * Real_ReleaseStgMedium)(LPSTGMEDIUM a0)
    = ReleaseStgMedium;

BOOL (__stdcall * Real_RemoveDirectoryA)(LPCSTR a0)
    = RemoveDirectoryA;

BOOL (__stdcall * Real_RemoveDirectoryW)(LPCWSTR a0)
    = RemoveDirectoryW;

BOOL (__stdcall * Real_RemoveFontResourceA)(LPCSTR a0)
    = RemoveFontResourceA;

BOOL (__stdcall * Real_RemoveFontResourceW)(LPCWSTR a0)
    = RemoveFontResourceW;

BOOL (__stdcall * Real_RemoveMenu)(HMENU a0,
                                   UINT a1,
                                   UINT a2)
    = RemoveMenu;

HANDLE (__stdcall * Real_RemovePropA)(HWND a0,
                                      LPCSTR a1)
    = RemovePropA;

HANDLE (__stdcall * Real_RemovePropW)(HWND a0,
                                      LPCWSTR a1)
    = RemovePropW;

BOOL (__stdcall * Real_ReplyMessage)(LRESULT a0)
    = ReplyMessage;

HDC (__stdcall * Real_ResetDCA)(HDC a0,
                                CONST DEVMODEA* a1)
    = ResetDCA;

HDC (__stdcall * Real_ResetDCW)(HDC a0,
                                CONST DEVMODEW* a1)
    = ResetDCW;

BOOL (__stdcall * Real_ResetEvent)(HANDLE a0)
    = ResetEvent;

BOOL (__stdcall * Real_ResizePalette)(HPALETTE a0,
                                      UINT a1)
    = ResizePalette;

BOOL (__stdcall * Real_RestoreDC)(HDC a0,
                                  int a1)
    = RestoreDC;

DWORD (__stdcall * Real_ResumeThread)(HANDLE a0)
    = ResumeThread;

LPARAM (__stdcall * Real_ReuseDDElParam)(LPARAM a0,
                                         UINT a1,
                                         UINT a2,
                                         UINT_PTR a3,
                                         UINT_PTR a4)
    = ReuseDDElParam;

HRESULT (__stdcall * Real_RevokeDragDrop)(HWND a0)
    = RevokeDragDrop;

BOOL (__stdcall * Real_RoundRect)(HDC a0,
                                  int a1,
                                  int a2,
                                  int a3,
                                  int a4,
                                  int a5,
                                  int a6)
    = RoundRect;

int (__stdcall * Real_SaveDC)(HDC a0)
    = SaveDC;

BOOL (__stdcall * Real_ScaleViewportExtEx)(HDC a0,
                                           int a1,
                                           int a2,
                                           int a3,
                                           int a4,
                                           SIZE* a5)
    = ScaleViewportExtEx;

BOOL (__stdcall * Real_ScaleWindowExtEx)(HDC a0,
                                         int a1,
                                         int a2,
                                         int a3,
                                         int a4,
                                         SIZE* a5)
    = ScaleWindowExtEx;

BOOL (__stdcall * Real_ScreenToClient)(HWND a0,
                                       POINT* a1)
    = ScreenToClient;

BOOL (__stdcall * Real_ScrollConsoleScreenBufferA)(HANDLE a0,
                                                   CONST SMALL_RECT* a1,
                                                   CONST SMALL_RECT* a2,
                                                   COORD a3,
                                                   CONST CHAR_INFO* a4)
    = ScrollConsoleScreenBufferA;

BOOL (__stdcall * Real_ScrollConsoleScreenBufferW)(HANDLE a0,
                                                   CONST SMALL_RECT* a1,
                                                   CONST SMALL_RECT* a2,
                                                   COORD a3,
                                                   CONST CHAR_INFO* a4)
    = ScrollConsoleScreenBufferW;

BOOL (__stdcall * Real_ScrollDC)(HDC a0,
                                 int a1,
                                 int a2,
                                 CONST RECT* a3,
                                 CONST RECT* a4,
                                 HRGN a5,
                                 LPRECT a6)
    = ScrollDC;

BOOL (__stdcall * Real_ScrollWindow)(HWND a0,
                                     int a1,
                                     int a2,
                                     CONST RECT* a3,
                                     CONST RECT* a4)
    = ScrollWindow;

int (__stdcall * Real_ScrollWindowEx)(HWND a0,
                                      int a1,
                                      int a2,
                                      CONST RECT* a3,
                                      CONST RECT* a4,
                                      HRGN a5,
                                      LPRECT a6,
                                      UINT a7)
    = ScrollWindowEx;

DWORD (__stdcall * Real_SearchPathA)(LPCSTR a0,
                                     LPCSTR a1,
                                     LPCSTR a2,
                                     DWORD a3,
                                     LPSTR a4,
                                     LPSTR* a5)
    = SearchPathA;

DWORD (__stdcall * Real_SearchPathW)(LPCWSTR a0,
                                     LPCWSTR a1,
                                     LPCWSTR a2,
                                     DWORD a3,
                                     LPWSTR a4,
                                     LPWSTR* a5)
    = SearchPathW;

BOOL (__stdcall * Real_SelectClipPath)(HDC a0,
                                       int a1)
    = SelectClipPath;

int (__stdcall * Real_SelectClipRgn)(HDC a0,
                                     HRGN a1)
    = SelectClipRgn;

HGDIOBJ (__stdcall * Real_SelectObject)(HDC a0,
                                        HGDIOBJ a1)
    = SelectObject;

HPALETTE (__stdcall * Real_SelectPalette)(HDC a0,
                                          HPALETTE a1,
                                          BOOL a2)
    = SelectPalette;

LRESULT (__stdcall * Real_SendDlgItemMessageA)(HWND a0,
                                               int a1,
                                               UINT a2,
                                               WPARAM a3,
                                               LPARAM a4)
    = SendDlgItemMessageA;

LRESULT (__stdcall * Real_SendDlgItemMessageW)(HWND a0,
                                               int a1,
                                               UINT a2,
                                               WPARAM a3,
                                               LPARAM a4)
    = SendDlgItemMessageW;

LRESULT (__stdcall * Real_SendMessageA)(HWND a0,
                                        UINT a1,
                                        WPARAM a2,
                                        LPARAM a3)
    = SendMessageA;

BOOL (__stdcall * Real_SendMessageCallbackA)(HWND a0,
                                             UINT a1,
                                             WPARAM a2,
                                             LPARAM a3,
                                             SENDASYNCPROC a4,
                                             ULONG_PTR a5)
    = SendMessageCallbackA;

BOOL (__stdcall * Real_SendMessageCallbackW)(HWND a0,
                                             UINT a1,
                                             WPARAM a2,
                                             LPARAM a3,
                                             SENDASYNCPROC a4,
                                             ULONG_PTR a5)
    = SendMessageCallbackW;

LRESULT (__stdcall * Real_SendMessageTimeoutA)(HWND a0,
                                               UINT a1,
                                               WPARAM a2,
                                               LPARAM a3,
                                               UINT a4,
                                               UINT a5,
                                               PULONG_PTR a6)
    = SendMessageTimeoutA;

LRESULT (__stdcall * Real_SendMessageTimeoutW)(HWND a0,
                                               UINT a1,
                                               WPARAM a2,
                                               LPARAM a3,
                                               UINT a4,
                                               UINT a5,
                                               PULONG_PTR a6)
    = SendMessageTimeoutW;

LRESULT (__stdcall * Real_SendMessageW)(HWND a0,
                                        UINT a1,
                                        WPARAM a2,
                                        LPARAM a3)
    = SendMessageW;

BOOL (__stdcall * Real_SendNotifyMessageA)(HWND a0,
                                           UINT a1,
                                           WPARAM a2,
                                           LPARAM a3)
    = SendNotifyMessageA;

BOOL (__stdcall * Real_SendNotifyMessageW)(HWND a0,
                                           UINT a1,
                                           WPARAM a2,
                                           LPARAM a3)
    = SendNotifyMessageW;

int (__stdcall * Real_SetAbortProc)(HDC a0,
                                    ABORTPROC a1)
    = SetAbortProc;

HWND (__stdcall * Real_SetActiveWindow)(HWND a0)
    = SetActiveWindow;

int (__stdcall * Real_SetArcDirection)(HDC a0,
                                       int a1)
    = SetArcDirection;

LONG (__stdcall * Real_SetBitmapBits)(HBITMAP a0,
                                      DWORD a1,
                                      CONST void* a2)
    = SetBitmapBits;

BOOL (__stdcall * Real_SetBitmapDimensionEx)(HBITMAP a0,
                                             int a1,
                                             int a2,
                                             SIZE* a3)
    = SetBitmapDimensionEx;

COLORREF (__stdcall * Real_SetBkColor)(HDC a0,
                                       COLORREF a1)
    = SetBkColor;

int (__stdcall * Real_SetBkMode)(HDC a0,
                                 int a1)
    = SetBkMode;

UINT (__stdcall * Real_SetBoundsRect)(HDC a0,
                                      CONST RECT* a1,
                                      UINT a2)
    = SetBoundsRect;

BOOL (__stdcall * Real_SetBrushOrgEx)(HDC a0,
                                      int a1,
                                      int a2,
                                      POINT* a3)
    = SetBrushOrgEx;

HWND (__stdcall * Real_SetCapture)(HWND a0)
    = SetCapture;

BOOL (__stdcall * Real_SetCaretBlinkTime)(UINT a0)
    = SetCaretBlinkTime;

BOOL (__stdcall * Real_SetCaretPos)(int a0,
                                    int a1)
    = SetCaretPos;

DWORD (__stdcall * Real_SetClassLongA)(HWND a0,
                                       int a1,
                                       LONG a2)
    = SetClassLongA;

DWORD (__stdcall * Real_SetClassLongW)(HWND a0,
                                       int a1,
                                       LONG a2)
    = SetClassLongW;

WORD (__stdcall * Real_SetClassWord)(HWND a0,
                                     int a1,
                                     WORD a2)
    = SetClassWord;

HANDLE (__stdcall * Real_SetClipboardData)(UINT a0,
                                           HANDLE a1)
    = SetClipboardData;

HWND (__stdcall * Real_SetClipboardViewer)(HWND a0)
    = SetClipboardViewer;

BOOL (__stdcall * Real_SetColorAdjustment)(HDC a0,
                                           CONST COLORADJUSTMENT* a1)
    = SetColorAdjustment;

HCOLORSPACE (__stdcall * Real_SetColorSpace)(HDC a0,
                                             HCOLORSPACE a1)
    = SetColorSpace;

BOOL (__stdcall * Real_SetCommBreak)(HANDLE a0)
    = SetCommBreak;

BOOL (__stdcall * Real_SetCommConfig)(HANDLE a0,
                                      LPCOMMCONFIG a1,
                                      DWORD a2)
    = SetCommConfig;

BOOL (__stdcall * Real_SetCommMask)(HANDLE a0,
                                    DWORD a1)
    = SetCommMask;

BOOL (__stdcall * Real_SetCommState)(HANDLE a0,
                                     LPDCB a1)
    = SetCommState;

BOOL (__stdcall * Real_SetCommTimeouts)(HANDLE a0,
                                        LPCOMMTIMEOUTS a1)
    = SetCommTimeouts;

BOOL (__stdcall * Real_SetComputerNameA)(LPCSTR a0)
    = SetComputerNameA;

BOOL (__stdcall * Real_SetComputerNameW)(LPCWSTR a0)
    = SetComputerNameW;

BOOL (__stdcall * Real_SetConsoleActiveScreenBuffer)(HANDLE a0)
    = SetConsoleActiveScreenBuffer;

BOOL (__stdcall * Real_SetConsoleCP)(UINT a0)
    = SetConsoleCP;

BOOL (__stdcall * Real_SetConsoleCtrlHandler)(PHANDLER_ROUTINE a0,
                                              BOOL a1)
    = SetConsoleCtrlHandler;

BOOL (__stdcall * Real_SetConsoleCursorInfo)(HANDLE a0,
                                             CONST CONSOLE_CURSOR_INFO* a1)
    = SetConsoleCursorInfo;

BOOL (__stdcall * Real_SetConsoleCursorPosition)(HANDLE a0,
                                                 COORD a1)
    = SetConsoleCursorPosition;

BOOL (__stdcall * Real_SetConsoleMode)(HANDLE a0,
                                       DWORD a1)
    = SetConsoleMode;

BOOL (__stdcall * Real_SetConsoleOutputCP)(UINT a0)
    = SetConsoleOutputCP;

BOOL (__stdcall * Real_SetConsoleScreenBufferSize)(HANDLE a0,
                                                   COORD a1)
    = SetConsoleScreenBufferSize;

BOOL (__stdcall * Real_SetConsoleTextAttribute)(HANDLE a0,
                                                WORD a1)
    = SetConsoleTextAttribute;

BOOL (__stdcall * Real_SetConsoleTitleA)(LPCSTR a0)
    = SetConsoleTitleA;

BOOL (__stdcall * Real_SetConsoleTitleW)(LPCWSTR a0)
    = SetConsoleTitleW;

BOOL (__stdcall * Real_SetConsoleWindowInfo)(HANDLE a0,
                                             BOOL a1,
                                             CONST SMALL_RECT* a2)
    = SetConsoleWindowInfo;

HRESULT (__stdcall * Real_SetConvertStg)(LPSTORAGE a0,
                                         BOOL a1)
    = SetConvertStg;

BOOL (__stdcall * Real_SetCurrentDirectoryA)(LPCSTR a0)
    = SetCurrentDirectoryA;

BOOL (__stdcall * Real_SetCurrentDirectoryW)(LPCWSTR a0)
    = SetCurrentDirectoryW;

HCURSOR (__stdcall * Real_SetCursor)(HCURSOR a0)
    = SetCursor;

BOOL (__stdcall * Real_SetCursorPos)(int a0,
                                     int a1)
    = SetCursorPos;

UINT (__stdcall * Real_SetDIBColorTable)(HDC a0,
                                         UINT a1,
                                         UINT a2,
                                         CONST RGBQUAD* a3)
    = SetDIBColorTable;

int (__stdcall * Real_SetDIBits)(HDC a0,
                                 HBITMAP a1,
                                 UINT a2,
                                 UINT a3,
                                 CONST void* a4,
                                 CONST BITMAPINFO* a5,
                                 UINT a6)
    = SetDIBits;

int (__stdcall * Real_SetDIBitsToDevice)(HDC a0,
                                         int a1,
                                         int a2,
                                         DWORD a3,
                                         DWORD a4,
                                         int a5,
                                         int a6,
                                         UINT a7,
                                         UINT a8,
                                         CONST void* a9,
                                         CONST BITMAPINFO* a10,
                                         UINT a11)
    = SetDIBitsToDevice;

BOOL (__stdcall * Real_SetDefaultCommConfigA)(LPCSTR a0,
                                              LPCOMMCONFIG a1,
                                              DWORD a2)
    = SetDefaultCommConfigA;

BOOL (__stdcall * Real_SetDefaultCommConfigW)(LPCWSTR a0,
                                              LPCOMMCONFIG a1,
                                              DWORD a2)
    = SetDefaultCommConfigW;

BOOL (__stdcall * Real_SetDeviceGammaRamp)(HDC a0,
                                           LPVOID a1)
    = SetDeviceGammaRamp;

BOOL (__stdcall * Real_SetDlgItemInt)(HWND a0,
                                      int a1,
                                      UINT a2,
                                      BOOL a3)
    = SetDlgItemInt;

BOOL (__stdcall * Real_SetDlgItemTextA)(HWND a0,
                                        int a1,
                                        LPCSTR a2)
    = SetDlgItemTextA;

BOOL (__stdcall * Real_SetDlgItemTextW)(HWND a0,
                                        int a1,
                                        LPCWSTR a2)
    = SetDlgItemTextW;

BOOL (__stdcall * Real_SetDoubleClickTime)(UINT a0)
    = SetDoubleClickTime;

BOOL (__stdcall * Real_SetEndOfFile)(HANDLE a0)
    = SetEndOfFile;

HENHMETAFILE (__stdcall * Real_SetEnhMetaFileBits)(UINT a0,
                                                   CONST BYTE* a1)
    = SetEnhMetaFileBits;

BOOL (__stdcall * Real_SetEnvironmentVariableA)(LPCSTR a0,
                                                LPCSTR a1)
    = SetEnvironmentVariableA;

BOOL (__stdcall * Real_SetEnvironmentVariableW)(LPCWSTR a0,
                                                LPCWSTR a1)
    = SetEnvironmentVariableW;

UINT (__stdcall * Real_SetErrorMode)(UINT a0)
    = SetErrorMode;

BOOL (__stdcall * Real_SetEvent)(HANDLE a0)
    = SetEvent;

void (__stdcall * Real_SetFileApisToANSI)(void)
    = SetFileApisToANSI;

void (__stdcall * Real_SetFileApisToOEM)(void)
    = SetFileApisToOEM;

BOOL (__stdcall * Real_SetFileAttributesA)(LPCSTR a0,
                                           DWORD a1)
    = SetFileAttributesA;

BOOL (__stdcall * Real_SetFileAttributesW)(LPCWSTR a0,
                                           DWORD a1)
    = SetFileAttributesW;

DWORD (__stdcall * Real_SetFilePointer)(HANDLE a0,
                                        LONG a1,
                                        PLONG a2,
                                        DWORD a3)
    = SetFilePointer;

BOOL (__stdcall * Real_SetFileTime)(HANDLE a0,
                                    CONST FILETIME* a1,
                                    CONST FILETIME* a2,
                                    CONST FILETIME* a3)
    = SetFileTime;

HWND (__stdcall * Real_SetFocus)(HWND a0)
    = SetFocus;

BOOL (__stdcall * Real_SetForegroundWindow)(HWND a0)
    = SetForegroundWindow;

int (__stdcall * Real_SetGraphicsMode)(HDC a0,
                                       int a1)
    = SetGraphicsMode;

UINT (__stdcall * Real_SetHandleCount)(UINT a0)
    = SetHandleCount;

BOOL (__stdcall * Real_SetHandleInformation)(HANDLE a0,
                                             DWORD a1,
                                             DWORD a2)
    = SetHandleInformation;

int (__stdcall * Real_SetICMMode)(HDC a0,
                                  int a1)
    = SetICMMode;

BOOL (__stdcall * Real_SetICMProfileA)(HDC a0,
                                       LPSTR a1)
    = SetICMProfileA;

BOOL (__stdcall * Real_SetICMProfileW)(HDC a0,
                                       LPWSTR a1)
    = SetICMProfileW;

BOOL (__stdcall * Real_SetKeyboardState)(LPBYTE a0)
    = SetKeyboardState;

BOOL (__stdcall * Real_SetLocalTime)(CONST SYSTEMTIME* a0)
    = SetLocalTime;

BOOL (__stdcall * Real_SetLocaleInfoA)(LCID a0,
                                       LCTYPE a1,
                                       LPCSTR a2)
    = SetLocaleInfoA;

BOOL (__stdcall * Real_SetLocaleInfoW)(LCID a0,
                                       LCTYPE a1,
                                       LPCWSTR a2)
    = SetLocaleInfoW;

BOOL (__stdcall * Real_SetMailslotInfo)(HANDLE a0,
                                        DWORD a1)
    = SetMailslotInfo;

int (__stdcall * Real_SetMapMode)(HDC a0,
                                  int a1)
    = SetMapMode;

DWORD (__stdcall * Real_SetMapperFlags)(HDC a0,
                                        DWORD a1)
    = SetMapperFlags;

BOOL (__stdcall * Real_SetMenu)(HWND a0,
                                HMENU a1)
    = SetMenu;

BOOL (__stdcall * Real_SetMenuContextHelpId)(HMENU a0,
                                             DWORD a1)
    = SetMenuContextHelpId;

BOOL (__stdcall * Real_SetMenuDefaultItem)(HMENU a0,
                                           UINT a1,
                                           UINT a2)
    = SetMenuDefaultItem;

BOOL (__stdcall * Real_SetMenuItemBitmaps)(HMENU a0,
                                           UINT a1,
                                           UINT a2,
                                           HBITMAP a3,
                                           HBITMAP a4)
    = SetMenuItemBitmaps;

BOOL (__stdcall * Real_SetMenuItemInfoA)(HMENU a0,
                                         UINT a1,
                                         BOOL a2,
                                         CONST MENUITEMINFOA* a3)
    = SetMenuItemInfoA;

BOOL (__stdcall * Real_SetMenuItemInfoW)(HMENU a0,
                                         UINT a1,
                                         BOOL a2,
                                         CONST MENUITEMINFOW* a3)
    = SetMenuItemInfoW;

LPARAM (__stdcall * Real_SetMessageExtraInfo)(LPARAM a0)
    = SetMessageExtraInfo;

BOOL (__stdcall * Real_SetMessageQueue)(int a0)
    = SetMessageQueue;

HMETAFILE (__stdcall * Real_SetMetaFileBitsEx)(UINT a0,
                                               CONST BYTE* a1)
    = SetMetaFileBitsEx;

int (__stdcall * Real_SetMetaRgn)(HDC a0)
    = SetMetaRgn;

BOOL (__stdcall * Real_SetMiterLimit)(HDC a0,
                                      FLOAT a1,
                                      PFLOAT a2)
    = SetMiterLimit;

BOOL (__stdcall * Real_SetNamedPipeHandleState)(HANDLE a0,
                                                LPDWORD a1,
                                                LPDWORD a2,
                                                LPDWORD a3)
    = SetNamedPipeHandleState;

UINT (__stdcall * Real_SetPaletteEntries)(HPALETTE a0,
                                          UINT a1,
                                          UINT a2,
                                          CONST PALETTEENTRY* a3)
    = SetPaletteEntries;

HWND (__stdcall * Real_SetParent)(HWND a0,
                                  HWND a1)
    = SetParent;

COLORREF (__stdcall * Real_SetPixel)(HDC a0,
                                     int a1,
                                     int a2,
                                     COLORREF a3)
    = SetPixel;

BOOL (__stdcall * Real_SetPixelFormat)(HDC a0,
                                       int a1,
                                       CONST PIXELFORMATDESCRIPTOR* a2)
    = SetPixelFormat;

BOOL (__stdcall * Real_SetPixelV)(HDC a0,
                                  int a1,
                                  int a2,
                                  COLORREF a3)
    = SetPixelV;

int (__stdcall * Real_SetPolyFillMode)(HDC a0,
                                       int a1)
    = SetPolyFillMode;

BOOL (__stdcall * Real_SetPriorityClass)(HANDLE a0,
                                         DWORD a1)
    = SetPriorityClass;

BOOL (__stdcall * Real_SetProcessAffinityMask)(HANDLE a0,
                                               DWORD_PTR a1)
    = SetProcessAffinityMask;

BOOL (__stdcall * Real_SetProcessShutdownParameters)(DWORD a0,
                                                     DWORD a1)
    = SetProcessShutdownParameters;

BOOL (__stdcall * Real_SetProcessWindowStation)(HWINSTA a0)
    = SetProcessWindowStation;

BOOL (__stdcall * Real_SetProcessWorkingSetSize)(HANDLE a0,
                                                 SIZE_T a1,
                                                 SIZE_T a2)
    = SetProcessWorkingSetSize;

BOOL (__stdcall * Real_SetPropA)(HWND a0,
                                 LPCSTR a1,
                                 HANDLE a2)
    = SetPropA;

BOOL (__stdcall * Real_SetPropW)(HWND a0,
                                 LPCWSTR a1,
                                 HANDLE a2)
    = SetPropW;

int (__stdcall * Real_SetROP2)(HDC a0,
                               int a1)
    = SetROP2;

BOOL (__stdcall * Real_SetRect)(LPRECT a0,
                                int a1,
                                int a2,
                                int a3,
                                int a4)
    = SetRect;

BOOL (__stdcall * Real_SetRectEmpty)(LPRECT a0)
    = SetRectEmpty;

BOOL (__stdcall * Real_SetRectRgn)(HRGN a0,
                                   int a1,
                                   int a2,
                                   int a3,
                                   int a4)
    = SetRectRgn;

int (__stdcall * Real_SetScrollInfo)(HWND a0,
                                     int a1,
                                     LPCSCROLLINFO a2,
                                     BOOL a3)
    = SetScrollInfo;

int (__stdcall * Real_SetScrollPos)(HWND a0,
                                    int a1,
                                    int a2,
                                    BOOL a3)
    = SetScrollPos;

BOOL (__stdcall * Real_SetScrollRange)(HWND a0,
                                       int a1,
                                       int a2,
                                       int a3,
                                       BOOL a4)
    = SetScrollRange;

BOOL (__stdcall * Real_SetStdHandle)(DWORD a0,
                                     HANDLE a1)
    = SetStdHandle;

int (__stdcall * Real_SetStretchBltMode)(HDC a0,
                                         int a1)
    = SetStretchBltMode;

BOOL (__stdcall * Real_SetSysColors)(int a0,
                                     CONST INT* a1,
                                     CONST COLORREF* a2)
    = SetSysColors;

BOOL (__stdcall * Real_SetSystemCursor)(HCURSOR a0,
                                        DWORD a1)
    = SetSystemCursor;

UINT (__stdcall * Real_SetSystemPaletteUse)(HDC a0,
                                            UINT a1)
    = SetSystemPaletteUse;

BOOL (__stdcall * Real_SetSystemPowerState)(BOOL a0,
                                            BOOL a1)
    = SetSystemPowerState;

BOOL (__stdcall * Real_SetSystemTime)(CONST SYSTEMTIME* a0)
    = SetSystemTime;

BOOL (__stdcall * Real_SetSystemTimeAdjustment)(DWORD a0,
                                                BOOL a1)
    = SetSystemTimeAdjustment;

DWORD (__stdcall * Real_SetTapeParameters)(HANDLE a0,
                                           DWORD a1,
                                           LPVOID a2)
    = SetTapeParameters;

DWORD (__stdcall * Real_SetTapePosition)(HANDLE a0,
                                         DWORD a1,
                                         DWORD a2,
                                         DWORD a3,
                                         DWORD a4,
                                         BOOL a5)
    = SetTapePosition;

UINT (__stdcall * Real_SetTextAlign)(HDC a0,
                                     UINT a1)
    = SetTextAlign;

int (__stdcall * Real_SetTextCharacterExtra)(HDC a0,
                                             int a1)
    = SetTextCharacterExtra;

COLORREF (__stdcall * Real_SetTextColor)(HDC a0,
                                         COLORREF a1)
    = SetTextColor;

BOOL (__stdcall * Real_SetTextJustification)(HDC a0,
                                             int a1,
                                             int a2)
    = SetTextJustification;

DWORD_PTR (__stdcall * Real_SetThreadAffinityMask)(HANDLE a0,
                                               DWORD_PTR a1)
    = SetThreadAffinityMask;

BOOL (__stdcall * Real_SetThreadContext)(HANDLE a0,
                                         CONST CONTEXT* a1)
    = SetThreadContext;

BOOL (__stdcall * Real_SetThreadDesktop)(HDESK a0)
    = SetThreadDesktop;

DWORD (__stdcall * Real_SetThreadIdealProcessor)(HANDLE a0,
                                                 DWORD a1)
    = SetThreadIdealProcessor;

#if(WINVER >= 0x0500)
BOOL (__stdcall * Real_SetThreadLocale)(LCID a0)
    = SetThreadLocale;
#endif // (WINVER >= 0x0500)

BOOL (__stdcall * Real_SetThreadPriority)(HANDLE a0,
                                          int a1)
    = SetThreadPriority;

BOOL (__stdcall * Real_SetThreadPriorityBoost)(HANDLE a0,
                                               BOOL a1)
    = SetThreadPriorityBoost;

BOOL (__stdcall * Real_SetTimeZoneInformation)(CONST TIME_ZONE_INFORMATION* a0)
    = SetTimeZoneInformation;

UINT_PTR (__stdcall * Real_SetTimer)(HWND a0,
                                     UINT_PTR a1,
                                     UINT a2,
                                     TIMERPROC a3)
    = SetTimer;

LPTOP_LEVEL_EXCEPTION_FILTER (__stdcall * Real_SetUnhandledExceptionFilter)(LPTOP_LEVEL_EXCEPTION_FILTER a0)
    = SetUnhandledExceptionFilter;

BOOL (__stdcall * Real_SetUserObjectInformationA)(HANDLE a0,
                                                  int a1,
                                                  PVOID a2,
                                                  DWORD a3)
    = SetUserObjectInformationA;

BOOL (__stdcall * Real_SetUserObjectInformationW)(HANDLE a0,
                                                  int a1,
                                                  PVOID a2,
                                                  DWORD a3)
    = SetUserObjectInformationW;

BOOL (__stdcall * Real_SetUserObjectSecurity)(HANDLE a0,
                                              PSECURITY_INFORMATION a1,
                                              PSECURITY_DESCRIPTOR a2)
    = SetUserObjectSecurity;

BOOL (__stdcall * Real_SetViewportExtEx)(HDC a0,
                                         int a1,
                                         int a2,
                                         SIZE* a3)
    = SetViewportExtEx;

BOOL (__stdcall * Real_SetViewportOrgEx)(HDC a0,
                                         int a1,
                                         int a2,
                                         POINT* a3)
    = SetViewportOrgEx;

BOOL (__stdcall * Real_SetVolumeLabelA)(LPCSTR a0,
                                        LPCSTR a1)
    = SetVolumeLabelA;

BOOL (__stdcall * Real_SetVolumeLabelW)(LPCWSTR a0,
                                        LPCWSTR a1)
    = SetVolumeLabelW;

BOOL (__stdcall * Real_SetWaitableTimer)(HANDLE a0,
                                         CONST LARGE_INTEGER* a1,
                                         LONG a2,
                                         PTIMERAPCROUTINE a3,
                                         LPVOID a4,
                                         BOOL a5)
    = SetWaitableTimer;

HENHMETAFILE (__stdcall * Real_SetWinMetaFileBits)(UINT a0,
                                                   CONST BYTE* a1,
                                                   HDC a2,
                                                   CONST METAFILEPICT* a3)
    = SetWinMetaFileBits;

BOOL (__stdcall * Real_SetWindowContextHelpId)(HWND a0,
                                               DWORD a1)
    = SetWindowContextHelpId;

BOOL (__stdcall * Real_SetWindowExtEx)(HDC a0,
                                       int a1,
                                       int a2,
                                       SIZE* a3)
    = SetWindowExtEx;

LONG (__stdcall * Real_SetWindowLongA)(HWND a0,
                                       int a1,
                                       LONG a2)
    = SetWindowLongA;

LONG (__stdcall * Real_SetWindowLongW)(HWND a0,
                                       int a1,
                                       LONG a2)
    = SetWindowLongW;

BOOL (__stdcall * Real_SetWindowOrgEx)(HDC a0,
                                       int a1,
                                       int a2,
                                       POINT* a3)
    = SetWindowOrgEx;

BOOL (__stdcall * Real_SetWindowPlacement)(HWND a0,
                                           CONST WINDOWPLACEMENT* a1)
    = SetWindowPlacement;

BOOL (__stdcall * Real_SetWindowPos)(HWND a0,
                                     HWND a1,
                                     int a2,
                                     int a3,
                                     int a4,
                                     int a5,
                                     UINT a6)
    = SetWindowPos;

int (__stdcall * Real_SetWindowRgn)(HWND a0,
                                    HRGN a1,
                                    BOOL a2)
    = SetWindowRgn;

BOOL (__stdcall * Real_SetWindowTextA)(HWND a0,
                                       LPCSTR a1)
    = SetWindowTextA;

BOOL (__stdcall * Real_SetWindowTextW)(HWND a0,
                                       LPCWSTR a1)
    = SetWindowTextW;

WORD (__stdcall * Real_SetWindowWord)(HWND a0,
                                      int a1,
                                      WORD a2)
    = SetWindowWord;

HHOOK (__stdcall * Real_SetWindowsHookA)(int a0,
                                         HOOKPROC a1)
    = SetWindowsHookA;

HHOOK (__stdcall * Real_SetWindowsHookExA)(int a0,
                                           HOOKPROC a1,
                                           HINSTANCE a2,
                                           DWORD a3)
    = SetWindowsHookExA;

HHOOK (__stdcall * Real_SetWindowsHookExW)(int a0,
                                           HOOKPROC a1,
                                           HINSTANCE a2,
                                           DWORD a3)
    = SetWindowsHookExW;

HHOOK (__stdcall * Real_SetWindowsHookW)(int a0,
                                         HOOKPROC a1)
    = SetWindowsHookW;

BOOL (__stdcall * Real_SetWorldTransform)(HDC a0,
                                          CONST XFORM* a1)
    = SetWorldTransform;

BOOL (__stdcall * Real_SetupComm)(HANDLE a0,
                                  DWORD a1,
                                  DWORD a2)
    = SetupComm;

BOOL (__stdcall * Real_ShowCaret)(HWND a0)
    = ShowCaret;

int (__stdcall * Real_ShowCursor)(BOOL a0)
    = ShowCursor;

BOOL (__stdcall * Real_ShowOwnedPopups)(HWND a0,
                                        BOOL a1)
    = ShowOwnedPopups;

BOOL (__stdcall * Real_ShowScrollBar)(HWND a0,
                                      int a1,
                                      BOOL a2)
    = ShowScrollBar;

BOOL (__stdcall * Real_ShowWindow)(HWND a0,
                                   int a1)
    = ShowWindow;

BOOL (__stdcall * Real_ShowWindowAsync)(HWND a0,
                                        int a1)
    = ShowWindowAsync;

DWORD (__stdcall * Real_SignalObjectAndWait)(HANDLE a0,
                                             HANDLE a1,
                                             DWORD a2,
                                             BOOL a3)
    = SignalObjectAndWait;

DWORD (__stdcall * Real_SizeofResource)(HMODULE a0,
                                        HRSRC a1)
    = SizeofResource;

DWORD (__stdcall * Real_SleepEx)(DWORD a0,
                                 BOOL a1)
    = SleepEx;

int (__stdcall * Real_StartDocA)(HDC a0,
                                 CONST DOCINFOA* a1)
    = StartDocA;

int (__stdcall * Real_StartDocW)(HDC a0,
                                 CONST DOCINFOW* a1)
    = StartDocW;

int (__stdcall * Real_StartPage)(HDC a0)
    = StartPage;

HRESULT (__stdcall * Real_StgCreateDocfile)(CONST OLECHAR* a0,
                                            DWORD a1,
                                            DWORD a2,
                                            IStorage** a3)
    = StgCreateDocfile;

HRESULT (__stdcall * Real_StgCreateDocfileOnILockBytes)(ILockBytes* a0,
                                                        DWORD a1,
                                                        DWORD a2,
                                                        IStorage** a3)
    = StgCreateDocfileOnILockBytes;

HRESULT (__stdcall * Real_StgCreatePropSetStg)(IStorage* a0,
                                               DWORD a1,
                                               IPropertySetStorage** a2)
    = StgCreatePropSetStg;

HRESULT (__stdcall * Real_StgCreatePropStg)(IUnknown* a0,
                                            CONST IID& a1,
                                            CONST CLSID* a2,
                                            DWORD a3,
                                            DWORD a4,
                                            IPropertyStorage** a5)
    = StgCreatePropStg;

#if _MSC_VER < 1300
HRESULT (__stdcall * Real_StgCreateStorageEx)(CONST WCHAR* a0,
                                              DWORD a1,
                                              DWORD a2,
                                              DWORD a3,
                                              void* a4,
                                              void* a5,
                                              CONST IID& a6,
                                              void** a7)
    = StgCreateStorageEx;
#else
HRESULT (__stdcall * Real_StgCreateStorageEx)(CONST WCHAR* a0,
                                              DWORD a1,
                                              DWORD a2,
                                              DWORD a3,
                                              STGOPTIONS* a4,
                                              void* a5,
                                              CONST IID& a6,
                                              void** a7)
    = StgCreateStorageEx;
#endif

HRESULT (__stdcall * Real_StgGetIFillLockBytesOnFile)(CONST OLECHAR* a0,
                                                      IFillLockBytes** a1)
    = StgGetIFillLockBytesOnFile;

HRESULT (__stdcall * Real_StgGetIFillLockBytesOnILockBytes)(ILockBytes* a0,
                                                            IFillLockBytes** a1)
    = StgGetIFillLockBytesOnILockBytes;

HRESULT (__stdcall * Real_StgIsStorageFile)(CONST OLECHAR* a0)
    = StgIsStorageFile;

HRESULT (__stdcall * Real_StgIsStorageILockBytes)(ILockBytes* a0)
    = StgIsStorageILockBytes;

HRESULT (__stdcall * Real_StgOpenAsyncDocfileOnIFillLockBytes)(IFillLockBytes* a0,
                                                               DWORD a1,
                                                               DWORD a2,
                                                               IStorage** a3)
    = StgOpenAsyncDocfileOnIFillLockBytes;

HRESULT (__stdcall * Real_StgOpenPropStg)(IUnknown* a0,
                                          CONST IID& a1,
                                          DWORD a2,
                                          DWORD a3,
                                          IPropertyStorage** a4)
    = StgOpenPropStg;

HRESULT (__stdcall * Real_StgOpenStorage)(CONST OLECHAR* a0,
                                          IStorage* a1,
                                          DWORD a2,
                                          SNB a3,
                                          DWORD a4,
                                          IStorage** a5)
    = StgOpenStorage;

#if _MSC_VER < 1300
HRESULT (__stdcall * Real_StgOpenStorageEx)(CONST WCHAR* a0,
                                            DWORD a1,
                                            DWORD a2,
                                            DWORD a3,
                                            void* a4,
                                            void* a5,
                                            CONST IID& a6,
                                            void** a7)
    = StgOpenStorageEx;
#else
HRESULT (__stdcall * Real_StgOpenStorageEx)(CONST WCHAR* a0,
                                            DWORD a1,
                                            DWORD a2,
                                            DWORD a3,
                                            STGOPTIONS* a4,
                                            void* a5,
                                            CONST IID& a6,
                                            void** a7)
    = StgOpenStorageEx;
#endif

HRESULT (__stdcall * Real_StgOpenStorageOnILockBytes)(ILockBytes* a0,
                                                      IStorage* a1,
                                                      DWORD a2,
                                                      SNB a3,
                                                      DWORD a4,
                                                      IStorage** a5)
    = StgOpenStorageOnILockBytes;

HRESULT (__stdcall * Real_StgSetTimes)(CONST OLECHAR* a0,
                                       CONST FILETIME* a1,
                                       CONST FILETIME* a2,
                                       CONST FILETIME* a3)
    = StgSetTimes;

BOOL (__stdcall * Real_StretchBlt)(HDC a0,
                                   int a1,
                                   int a2,
                                   int a3,
                                   int a4,
                                   HDC a5,
                                   int a6,
                                   int a7,
                                   int a8,
                                   int a9,
                                   DWORD a10)
    = StretchBlt;

int (__stdcall * Real_StretchDIBits)(HDC a0,
                                     int a1,
                                     int a2,
                                     int a3,
                                     int a4,
                                     int a5,
                                     int a6,
                                     int a7,
                                     int a8,
                                     CONST void* a9,
                                     CONST BITMAPINFO* a10,
                                     UINT a11,
                                     DWORD a12)
    = StretchDIBits;

HRESULT (__stdcall * Real_StringFromCLSID)(CONST IID& a0,
                                           LPOLESTR* a1)
    = StringFromCLSID;

int (__stdcall * Real_StringFromGUID2)(CONST GUID& a0,
                                       LPOLESTR a1,
                                       int a2)
    = StringFromGUID2;

HRESULT (__stdcall * Real_StringFromIID)(CONST IID& a0,
                                         LPOLESTR* a1)
    = StringFromIID;

BOOL (__stdcall * Real_StrokeAndFillPath)(HDC a0)
    = StrokeAndFillPath;

BOOL (__stdcall * Real_StrokePath)(HDC a0)
    = StrokePath;

BOOL (__stdcall * Real_SubtractRect)(LPRECT a0,
                                     CONST RECT* a1,
                                     CONST RECT* a2)
    = SubtractRect;

DWORD (__stdcall * Real_SuspendThread)(HANDLE a0)
    = SuspendThread;

BOOL (__stdcall * Real_SwapBuffers)(HDC a0)
    = SwapBuffers;

BOOL (__stdcall * Real_SwapMouseButton)(BOOL a0)
    = SwapMouseButton;

BOOL (__stdcall * Real_SwitchDesktop)(HDESK a0)
    = SwitchDesktop;

void (__stdcall * Real_SwitchToFiber)(LPVOID a0)
    = SwitchToFiber;

BOOL (__stdcall * Real_SwitchToThread)(void)
    = SwitchToThread;

BOOL (__stdcall * Real_SystemParametersInfoA)(UINT a0,
                                              UINT a1,
                                              PVOID a2,
                                              UINT a3)
    = SystemParametersInfoA;

BOOL (__stdcall * Real_SystemParametersInfoW)(UINT a0,
                                              UINT a1,
                                              PVOID a2,
                                              UINT a3)
    = SystemParametersInfoW;

BOOL (__stdcall * Real_SystemTimeToFileTime)(CONST SYSTEMTIME* a0,
                                             LPFILETIME a1)
    = SystemTimeToFileTime;

BOOL (__stdcall * Real_SystemTimeToTzSpecificLocalTime)(
#ifdef PIPE_ACCEPT_REMOTE_CLIENTS
                                                        const TIME_ZONE_INFORMATION *a0,
                                                        const SYSTEMTIME *a1,
#else
                                                        LPTIME_ZONE_INFORMATION a0,
                                                        LPSYSTEMTIME a1,
#endif
                                                        LPSYSTEMTIME a2
                                                       )
    = SystemTimeToTzSpecificLocalTime;

#if _MSC_VER < 1300
LONG (__stdcall * Real_TabbedTextOutA)(HDC a0,
                                       int a1,
                                       int a2,
                                       LPCSTR a3,
                                       int a4,
                                       int a5,
                                       INT* a6,
                                       int a7)
    = TabbedTextOutA;
#else
LONG (__stdcall * Real_TabbedTextOutA)(HDC a0,
                                       int a1,
                                       int a2,
                                       LPCSTR a3,
                                       int a4,
                                       int a5,
                                       CONST INT* a6,
                                       int a7)
    = TabbedTextOutA;
#endif

#if _MSC_VER < 1300
LONG (__stdcall * Real_TabbedTextOutW)(HDC a0,
                                       int a1,
                                       int a2,
                                       LPCWSTR a3,
                                       int a4,
                                       int a5,
                                       INT* a6,
                                       int a7)
    = TabbedTextOutW;
#else
LONG (__stdcall * Real_TabbedTextOutW)(HDC a0,
                                       int a1,
                                       int a2,
                                       LPCWSTR a3,
                                       int a4,
                                       int a5,
                                       CONST INT* a6,
                                       int a7)
    = TabbedTextOutW;
#endif

BOOL (__stdcall * Real_TerminateProcess)(HANDLE a0,
                                         UINT a1)
    = TerminateProcess;

BOOL (__stdcall * Real_TerminateThread)(HANDLE a0,
                                        DWORD a1)
    = TerminateThread;

BOOL (__stdcall * Real_TextOutA)(HDC a0,
                                 int a1,
                                 int a2,
                                 LPCSTR a3,
                                 int a4)
    = TextOutA;

BOOL (__stdcall * Real_TextOutW)(HDC a0,
                                 int a1,
                                 int a2,
                                 LPCWSTR a3,
                                 int a4)
    = TextOutW;

WORD (__stdcall * Real_TileWindows)(HWND a0,
                                    UINT a1,
                                    CONST RECT* a2,
                                    UINT a3,
                                    CONST HWND * a4)
    = TileWindows;

#if _MSC_VER < 1300
int (__stdcall * Real_ToAscii)(UINT a0,
                               UINT a1,
                               BYTE* a2,
                               LPWORD a3,
                               UINT a4)
    = ToAscii;
#else
int (__stdcall * Real_ToAscii)(UINT a0,
                               UINT a1,
                               CONST BYTE* a2,
                               LPWORD a3,
                               UINT a4)
    = ToAscii;
#endif

#if _MSC_VER < 1300
int (__stdcall * Real_ToAsciiEx)(UINT a0,
                                 UINT a1,
                                 BYTE* a2,
                                 LPWORD a3,
                                 UINT a4,
                                 HKL a5)
    = ToAsciiEx;
#else
int (__stdcall * Real_ToAsciiEx)(UINT a0,
                                 UINT a1,
                                 CONST BYTE* a2,
                                 LPWORD a3,
                                 UINT a4,
                                 HKL a5)
    = ToAsciiEx;
#endif

#if _MSC_VER < 1300
int (__stdcall * Real_ToUnicode)(UINT a0,
                                 UINT a1,
                                 BYTE* a2,
                                 LPWSTR a3,
                                 int a4,
                                 UINT a5)
    = ToUnicode;
#else
int (__stdcall * Real_ToUnicode)(UINT a0,
                                 UINT a1,
                                 CONST BYTE* a2,
                                 LPWSTR a3,
                                 int a4,
                                 UINT a5)
    = ToUnicode;
#endif

#if _MSC_VER < 1300
int (__stdcall * Real_ToUnicodeEx)(UINT a0,
                                   UINT a1,
                                   BYTE* a2,
                                   LPWSTR a3,
                                   int a4,
                                   UINT a5,
                                   HKL a6)
    = ToUnicodeEx;
#else
int (__stdcall * Real_ToUnicodeEx)(UINT a0,
                                   UINT a1,
                                   CONST BYTE* a2,
                                   LPWSTR a3,
                                   int a4,
                                   UINT a5,
                                   HKL a6)
    = ToUnicodeEx;
#endif

BOOL (__stdcall * Real_TrackMouseEvent)(TRACKMOUSEEVENT* a0)
    = TrackMouseEvent;

BOOL (__stdcall * Real_TrackPopupMenu)(HMENU a0,
                                       UINT a1,
                                       int a2,
                                       int a3,
                                       int a4,
                                       HWND a5,
                                       CONST RECT* a6)
    = TrackPopupMenu;

BOOL (__stdcall * Real_TrackPopupMenuEx)(HMENU a0,
                                         UINT a1,
                                         int a2,
                                         int a3,
                                         HWND a4,
                                         LPTPMPARAMS a5)
    = TrackPopupMenuEx;

BOOL (__stdcall * Real_TransactNamedPipe)(HANDLE a0,
                                          LPVOID a1,
                                          DWORD a2,
                                          LPVOID a3,
                                          DWORD a4,
                                          LPDWORD a5,
                                          LPOVERLAPPED a6)
    = TransactNamedPipe;

int (__stdcall * Real_TranslateAcceleratorA)(HWND a0,
                                             HACCEL a1,
                                             LPMSG a2)
    = TranslateAcceleratorA;

int (__stdcall * Real_TranslateAcceleratorW)(HWND a0,
                                             HACCEL a1,
                                             LPMSG a2)
    = TranslateAcceleratorW;

BOOL (__stdcall * Real_TranslateCharsetInfo)(DWORD* a0,
                                             CHARSETINFO* a1,
                                             DWORD a2)
    = TranslateCharsetInfo;

BOOL (__stdcall * Real_TranslateMDISysAccel)(HWND a0,
                                             LPMSG a1)
    = TranslateMDISysAccel;

BOOL (__stdcall * Real_TranslateMessage)(CONST MSG* a0)
    = TranslateMessage;

BOOL (__stdcall * Real_TransmitCommChar)(HANDLE a0,
                                         char a1)
    = TransmitCommChar;

#if DETOUR_TryEnterCriticalSection_EVEN_IF_IT_EXERCISES_A_BUG_IN_RtlLookupFunctionTable
BOOL (__stdcall * Real_TryEnterCriticalSection)(LPCRITICAL_SECTION a0)
    = TryEnterCriticalSection;
#endif

BOOL (__stdcall * Real_UnhookWindowsHook)(int a0,
                                          HOOKPROC a1)
    = UnhookWindowsHook;

BOOL (__stdcall * Real_UnhookWindowsHookEx)(HHOOK a0)
    = UnhookWindowsHookEx;

BOOL (__stdcall * Real_UnionRect)(LPRECT a0,
                                  CONST RECT* a1,
                                  CONST RECT* a2)
    = UnionRect;

BOOL (__stdcall * Real_UnloadKeyboardLayout)(HKL a0)
    = UnloadKeyboardLayout;

BOOL (__stdcall * Real_UnlockFile)(HANDLE a0,
                                   DWORD a1,
                                   DWORD a2,
                                   DWORD a3,
                                   DWORD a4)
    = UnlockFile;

BOOL (__stdcall * Real_UnlockFileEx)(HANDLE a0,
                                     DWORD a1,
                                     DWORD a2,
                                     DWORD a3,
                                     LPOVERLAPPED a4)
    = UnlockFileEx;

BOOL (__stdcall * Real_UnmapViewOfFile)(LPCVOID a0)
    = UnmapViewOfFile;

BOOL (__stdcall * Real_UnpackDDElParam)(UINT a0,
                                        LPARAM a1,
                                        PUINT_PTR a2,
                                        PUINT_PTR a3)
    = UnpackDDElParam;

BOOL (__stdcall * Real_UnrealizeObject)(HGDIOBJ a0)
    = UnrealizeObject;

BOOL (__stdcall * Real_UnregisterClassA)(LPCSTR a0,
                                         HINSTANCE a1)
    = UnregisterClassA;

BOOL (__stdcall * Real_UnregisterClassW)(LPCWSTR a0,
                                         HINSTANCE a1)
    = UnregisterClassW;

BOOL (__stdcall * Real_UnregisterHotKey)(HWND a0,
                                         int a1)
    = UnregisterHotKey;

BOOL (__stdcall * Real_UpdateColors)(HDC a0)
    = UpdateColors;

BOOL (__stdcall * Real_UpdateResourceA)(HANDLE a0,
                                        LPCSTR a1,
                                        LPCSTR a2,
                                        WORD a3,
                                        LPVOID a4,
                                        DWORD a5)
    = UpdateResourceA;

BOOL (__stdcall * Real_UpdateResourceW)(HANDLE a0,
                                        LPCWSTR a1,
                                        LPCWSTR a2,
                                        WORD a3,
                                        LPVOID a4,
                                        DWORD a5)
    = UpdateResourceW;

BOOL (__stdcall * Real_UpdateWindow)(HWND a0)
    = UpdateWindow;

BOOL (__stdcall * Real_ValidateRect)(HWND a0,
                                     CONST RECT* a1)
    = ValidateRect;

BOOL (__stdcall * Real_ValidateRgn)(HWND a0,
                                    HRGN a1)
    = ValidateRgn;

DWORD (__stdcall * Real_VerLanguageNameA)(DWORD a0,
                                          LPSTR a1,
                                          DWORD a2)
    = VerLanguageNameA;

DWORD (__stdcall * Real_VerLanguageNameW)(DWORD a0,
                                          LPWSTR a1,
                                          DWORD a2)
    = VerLanguageNameW;

LPVOID (__stdcall * Real_VirtualAllocEx)(HANDLE a0,
                                         LPVOID a1,
                                         SIZE_T a2,
                                         DWORD a3,
                                         DWORD a4)
    = VirtualAllocEx;

BOOL (__stdcall * Real_VirtualFreeEx)(HANDLE a0,
                                      LPVOID a1,
                                      SIZE_T a2,
                                      DWORD a3)
    = VirtualFreeEx;

BOOL (__stdcall * Real_VirtualProtectEx)(HANDLE a0,
                                         LPVOID a1,
                                         SIZE_T a2,
                                         DWORD a3,
                                         PDWORD a4)
    = VirtualProtectEx;

DWORD_PTR (__stdcall * Real_VirtualQueryEx)(HANDLE a0,
                                        LPCVOID a1,
                                        PMEMORY_BASIC_INFORMATION a2,
                                        DWORD_PTR a3)
    = VirtualQueryEx;

SHORT (__stdcall * Real_VkKeyScanA)(CHAR a0)
    = VkKeyScanA;

SHORT (__stdcall * Real_VkKeyScanExA)(CHAR a0,
                                      HKL a1)
    = VkKeyScanExA;

SHORT (__stdcall * Real_VkKeyScanExW)(WCHAR a0,
                                      HKL a1)
    = VkKeyScanExW;

SHORT (__stdcall * Real_VkKeyScanW)(WCHAR a0)
    = VkKeyScanW;

SOCKET (__stdcall * Real_WSAAccept)(SOCKET a0,
                                    sockaddr* a1,
                                    LPINT a2,
                                    LPCONDITIONPROC a3,
                                    DWORD_PTR a4)
    = WSAAccept;

INT (__stdcall * Real_WSAAddressToStringA)(LPSOCKADDR a0,
                                           DWORD a1,
                                           LPWSAPROTOCOL_INFOA a2,
                                           LPSTR a3,
                                           LPDWORD a4)
    = WSAAddressToStringA;

INT (__stdcall * Real_WSAAddressToStringW)(LPSOCKADDR a0,
                                           DWORD a1,
                                           LPWSAPROTOCOL_INFOW a2,
                                           LPWSTR a3,
                                           LPDWORD a4)
    = WSAAddressToStringW;

HANDLE (__stdcall * Real_WSAAsyncGetHostByAddr)(HWND a0,
                                                u_int a1,
                                                CONST char* a2,
                                                int a3,
                                                int a4,
                                                char* a5,
                                                int a6)
    = WSAAsyncGetHostByAddr;

HANDLE (__stdcall * Real_WSAAsyncGetHostByName)(HWND a0,
                                                u_int a1,
                                                CONST char* a2,
                                                char* a3,
                                                int a4)
    = WSAAsyncGetHostByName;

HANDLE (__stdcall * Real_WSAAsyncGetProtoByName)(HWND a0,
                                                 u_int a1,
                                                 CONST char* a2,
                                                 char* a3,
                                                 int a4)
    = WSAAsyncGetProtoByName;

HANDLE (__stdcall * Real_WSAAsyncGetProtoByNumber)(HWND a0,
                                                   u_int a1,
                                                   int a2,
                                                   char* a3,
                                                   int a4)
    = WSAAsyncGetProtoByNumber;

HANDLE (__stdcall * Real_WSAAsyncGetServByName)(HWND a0,
                                                u_int a1,
                                                CONST char* a2,
                                                CONST char* a3,
                                                char* a4,
                                                int a5)
    = WSAAsyncGetServByName;

HANDLE (__stdcall * Real_WSAAsyncGetServByPort)(HWND a0,
                                                u_int a1,
                                                int a2,
                                                CONST char* a3,
                                                char* a4,
                                                int a5)
    = WSAAsyncGetServByPort;

int (__stdcall * Real_WSAAsyncSelect)(SOCKET a0,
                                      HWND a1,
                                      u_int a2,
                                      long a3)
    = WSAAsyncSelect;

int (__stdcall * Real_WSACancelAsyncRequest)(HANDLE a0)
    = WSACancelAsyncRequest;

int (__stdcall * Real_WSACancelBlockingCall)(void)
    = WSACancelBlockingCall;

int (__stdcall * Real_WSACleanup)(void)
    = WSACleanup;

BOOL (__stdcall * Real_WSACloseEvent)(HANDLE a0)
    = WSACloseEvent;

int (__stdcall * Real_WSAConnect)(SOCKET a0,
                                  CONST sockaddr* a1,
                                  int a2,
                                  LPWSABUF a3,
                                  LPWSABUF a4,
                                  LPQOS a5,
                                  LPQOS a6)
    = WSAConnect;

HANDLE (__stdcall * Real_WSACreateEvent)(void)
    = WSACreateEvent;

int (__stdcall * Real_WSADuplicateSocketA)(SOCKET a0,
                                           DWORD a1,
                                           LPWSAPROTOCOL_INFOA a2)
    = WSADuplicateSocketA;

int (__stdcall * Real_WSADuplicateSocketW)(SOCKET a0,
                                           DWORD a1,
                                           LPWSAPROTOCOL_INFOW a2)
    = WSADuplicateSocketW;

INT (__stdcall * Real_WSAEnumNameSpaceProvidersA)(LPDWORD a0,
                                                  LPWSANAMESPACE_INFOA a1)
    = WSAEnumNameSpaceProvidersA;

INT (__stdcall * Real_WSAEnumNameSpaceProvidersW)(LPDWORD a0,
                                                  LPWSANAMESPACE_INFOW a1)
    = WSAEnumNameSpaceProvidersW;

int (__stdcall * Real_WSAEnumNetworkEvents)(SOCKET a0,
                                            HANDLE a1,
                                            LPWSANETWORKEVENTS a2)
    = WSAEnumNetworkEvents;

int (__stdcall * Real_WSAEnumProtocolsA)(LPINT a0,
                                         LPWSAPROTOCOL_INFOA a1,
                                         LPDWORD a2)
    = WSAEnumProtocolsA;

int (__stdcall * Real_WSAEnumProtocolsW)(LPINT a0,
                                         LPWSAPROTOCOL_INFOW a1,
                                         LPDWORD a2)
    = WSAEnumProtocolsW;

int (__stdcall * Real_WSAEventSelect)(SOCKET a0,
                                      HANDLE a1,
                                      long a2)
    = WSAEventSelect;

BOOL (__stdcall * Real_WSAGetOverlappedResult)(SOCKET a0,
                                               LPWSAOVERLAPPED a1,
                                               LPDWORD a2,
                                               BOOL a3,
                                               LPDWORD a4)
    = WSAGetOverlappedResult;

BOOL (__stdcall * Real_WSAGetQOSByName)(SOCKET a0,
                                        LPWSABUF a1,
                                        LPQOS a2)
    = WSAGetQOSByName;

INT (__stdcall * Real_WSAGetServiceClassInfoA)(LPGUID a0,
                                               LPGUID a1,
                                               LPDWORD a2,
                                               LPWSASERVICECLASSINFOA a3)
    = WSAGetServiceClassInfoA;

INT (__stdcall * Real_WSAGetServiceClassInfoW)(LPGUID a0,
                                               LPGUID a1,
                                               LPDWORD a2,
                                               LPWSASERVICECLASSINFOW a3)
    = WSAGetServiceClassInfoW;

INT (__stdcall * Real_WSAGetServiceClassNameByClassIdA)(LPGUID a0,
                                                        LPSTR a1,
                                                        LPDWORD a2)
    = WSAGetServiceClassNameByClassIdA;

INT (__stdcall * Real_WSAGetServiceClassNameByClassIdW)(LPGUID a0,
                                                        LPWSTR a1,
                                                        LPDWORD a2)
    = WSAGetServiceClassNameByClassIdW;

int (__stdcall * Real_WSAHtonl)(SOCKET a0,
                                u_long a1,
                                u_long* a2)
    = WSAHtonl;

int (__stdcall * Real_WSAHtons)(SOCKET a0,
                                u_short a1,
                                u_short* a2)
    = WSAHtons;

INT (__stdcall * Real_WSAInstallServiceClassA)(LPWSASERVICECLASSINFOA a0)
    = WSAInstallServiceClassA;

INT (__stdcall * Real_WSAInstallServiceClassW)(LPWSASERVICECLASSINFOW a0)
    = WSAInstallServiceClassW;

int (__stdcall * Real_WSAIoctl)(SOCKET a0,
                                DWORD a1,
                                LPVOID a2,
                                DWORD a3,
                                LPVOID a4,
                                DWORD a5,
                                LPDWORD a6,
                                LPWSAOVERLAPPED a7,
                                LPWSAOVERLAPPED_COMPLETION_ROUTINE a8)
    = WSAIoctl;

BOOL (__stdcall * Real_WSAIsBlocking)(void)
    = WSAIsBlocking;

SOCKET (__stdcall * Real_WSAJoinLeaf)(SOCKET a0,
                                      CONST sockaddr* a1,
                                      int a2,
                                      LPWSABUF a3,
                                      LPWSABUF a4,
                                      LPQOS a5,
                                      LPQOS a6,
                                      DWORD a7)
    = WSAJoinLeaf;

INT (__stdcall * Real_WSALookupServiceBeginA)(LPWSAQUERYSETA a0,
                                              DWORD a1,
                                              LPHANDLE a2)
    = WSALookupServiceBeginA;

INT (__stdcall * Real_WSALookupServiceBeginW)(LPWSAQUERYSETW a0,
                                              DWORD a1,
                                              LPHANDLE a2)
    = WSALookupServiceBeginW;

INT (__stdcall * Real_WSALookupServiceEnd)(HANDLE a0)
    = WSALookupServiceEnd;

INT (__stdcall * Real_WSALookupServiceNextA)(HANDLE a0,
                                             DWORD a1,
                                             LPDWORD a2,
                                             LPWSAQUERYSETA a3)
    = WSALookupServiceNextA;

INT (__stdcall * Real_WSALookupServiceNextW)(HANDLE a0,
                                             DWORD a1,
                                             LPDWORD a2,
                                             LPWSAQUERYSETW a3)
    = WSALookupServiceNextW;

int (__stdcall * Real_WSANtohl)(SOCKET a0,
                                u_long a1,
                                u_long* a2)
    = WSANtohl;

int (__stdcall * Real_WSANtohs)(SOCKET a0,
                                u_short a1,
                                u_short* a2)
    = WSANtohs;

INT (__stdcall * Real_WSAProviderConfigChange)(LPHANDLE a0,
                                               LPWSAOVERLAPPED a1,
                                               LPWSAOVERLAPPED_COMPLETION_ROUTINE a2)
    = WSAProviderConfigChange;

int (__stdcall * Real_WSARecv)(SOCKET a0,
                               LPWSABUF a1,
                               DWORD a2,
                               LPDWORD a3,
                               LPDWORD a4,
                               LPWSAOVERLAPPED a5,
                               LPWSAOVERLAPPED_COMPLETION_ROUTINE a6)
    = WSARecv;

int (__stdcall * Real_WSARecvDisconnect)(SOCKET a0,
                                         LPWSABUF a1)
    = WSARecvDisconnect;

int (__stdcall * Real_WSARecvFrom)(SOCKET a0,
                                   LPWSABUF a1,
                                   DWORD a2,
                                   LPDWORD a3,
                                   LPDWORD a4,
                                   sockaddr* a5,
                                   LPINT a6,
                                   LPWSAOVERLAPPED a7,
                                   LPWSAOVERLAPPED_COMPLETION_ROUTINE a8)
    = WSARecvFrom;

INT (__stdcall * Real_WSARemoveServiceClass)(LPGUID a0)
    = WSARemoveServiceClass;

BOOL (__stdcall * Real_WSAResetEvent)(HANDLE a0)
    = WSAResetEvent;

int (__stdcall * Real_WSASend)(SOCKET a0,
                               LPWSABUF a1,
                               DWORD a2,
                               LPDWORD a3,
                               DWORD a4,
                               LPWSAOVERLAPPED a5,
                               LPWSAOVERLAPPED_COMPLETION_ROUTINE a6)
    = WSASend;

int (__stdcall * Real_WSASendDisconnect)(SOCKET a0,
                                         LPWSABUF a1)
    = WSASendDisconnect;

int (__stdcall * Real_WSASendTo)(SOCKET a0,
                                 LPWSABUF a1,
                                 DWORD a2,
                                 LPDWORD a3,
                                 DWORD a4,
                                 CONST sockaddr* a5,
                                 int a6,
                                 LPWSAOVERLAPPED a7,
                                 LPWSAOVERLAPPED_COMPLETION_ROUTINE a8)
    = WSASendTo;

FARPROC (__stdcall * Real_WSASetBlockingHook)(FARPROC a0)
    = WSASetBlockingHook;

BOOL (__stdcall * Real_WSASetEvent)(HANDLE a0)
    = WSASetEvent;

INT (__stdcall * Real_WSASetServiceA)(LPWSAQUERYSETA a0,
                                      WSAESETSERVICEOP a1,
                                      DWORD a2)
    = WSASetServiceA;

INT (__stdcall * Real_WSASetServiceW)(LPWSAQUERYSETW a0,
                                      WSAESETSERVICEOP a1,
                                      DWORD a2)
    = WSASetServiceW;

SOCKET (__stdcall * Real_WSASocketA)(int a0,
                                     int a1,
                                     int a2,
                                     LPWSAPROTOCOL_INFOA a3,
                                     GROUP a4,
                                     DWORD a5)
    = WSASocketA;

SOCKET (__stdcall * Real_WSASocketW)(int a0,
                                     int a1,
                                     int a2,
                                     LPWSAPROTOCOL_INFOW a3,
                                     GROUP a4,
                                     DWORD a5)
    = WSASocketW;

int (__stdcall * Real_WSAStartup)(WORD a0,
                                  LPWSADATA a1)
    = WSAStartup;

INT (__stdcall * Real_WSAStringToAddressA)(LPSTR a0,
                                           INT a1,
                                           LPWSAPROTOCOL_INFOA a2,
                                           LPSOCKADDR a3,
                                           LPINT a4)
    = WSAStringToAddressA;

INT (__stdcall * Real_WSAStringToAddressW)(LPWSTR a0,
                                           INT a1,
                                           LPWSAPROTOCOL_INFOW a2,
                                           LPSOCKADDR a3,
                                           LPINT a4)
    = WSAStringToAddressW;

int (__stdcall * Real_WSAUnhookBlockingHook)(void)
    = WSAUnhookBlockingHook;

DWORD (__stdcall * Real_WSAWaitForMultipleEvents)(DWORD a0,
                                                  CONST HANDLE * a1,
                                                  BOOL a2,
                                                  DWORD a3,
                                                  BOOL a4)
    = WSAWaitForMultipleEvents;

BOOL (__stdcall * Real_WaitCommEvent)(HANDLE a0,
                                      LPDWORD a1,
                                      LPOVERLAPPED a2)
    = WaitCommEvent;

#if !defined(DETOURS_ARM)
BOOL (__stdcall * Real_WaitForDebugEvent)(LPDEBUG_EVENT a0,
                                          DWORD a1)
    = WaitForDebugEvent;
#endif // !DETOUR_ARM

DWORD (__stdcall * Real_WaitForInputIdle)(HANDLE a0,
                                          DWORD a1)
    = WaitForInputIdle;

DWORD (__stdcall * Real_WaitForMultipleObjects)(DWORD a0,
                                                CONST HANDLE * a1,
                                                BOOL a2,
                                                DWORD a3)
    = WaitForMultipleObjects;

DWORD (__stdcall * Real_WaitForMultipleObjectsEx)(DWORD a0,
                                                  CONST HANDLE * a1,
                                                  BOOL a2,
                                                  DWORD a3,
                                                  BOOL a4)
    = WaitForMultipleObjectsEx;

DWORD (__stdcall * Real_WaitForSingleObject)(HANDLE a0,
                                             DWORD a1)
    = WaitForSingleObject;

DWORD (__stdcall * Real_WaitForSingleObjectEx)(HANDLE a0,
                                               DWORD a1,
                                               BOOL a2)
    = WaitForSingleObjectEx;

BOOL (__stdcall * Real_WaitMessage)(void)
    = WaitMessage;

BOOL (__stdcall * Real_WaitNamedPipeA)(LPCSTR a0,
                                       DWORD a1)
    = WaitNamedPipeA;

BOOL (__stdcall * Real_WaitNamedPipeW)(LPCWSTR a0,
                                       DWORD a1)
    = WaitNamedPipeW;

BOOL (__stdcall * Real_WidenPath)(HDC a0)
    = WidenPath;

UINT (__stdcall * Real_WinExec)(LPCSTR a0,
                                UINT a1)
    = WinExec;

BOOL (__stdcall * Real_WinHelpA)(HWND a0,
                                 LPCSTR a1,
                                 UINT a2,
                                 ULONG_PTR a3)
    = WinHelpA;

BOOL (__stdcall * Real_WinHelpW)(HWND a0,
                                 LPCWSTR a1,
                                 UINT a2,
                                 ULONG_PTR a3)
    = WinHelpW;

HWND (__stdcall * Real_WindowFromDC)(HDC a0)
    = WindowFromDC;

HWND (__stdcall * Real_WindowFromPoint)(POINT a0)
    = WindowFromPoint;

HRESULT (__stdcall * Real_WriteClassStg)(LPSTORAGE a0,
                                         CONST IID& a1)
    = WriteClassStg;

HRESULT (__stdcall * Real_WriteClassStm)(LPSTREAM a0,
                                         CONST IID& a1)
    = WriteClassStm;

BOOL (__stdcall * Real_WriteConsoleA)(HANDLE a0,
                                      CONST void* a1,
                                      DWORD a2,
                                      LPDWORD a3,
                                      LPVOID a4)
    = WriteConsoleA;

BOOL (__stdcall * Real_WriteConsoleInputA)(HANDLE a0,
                                           CONST INPUT_RECORD* a1,
                                           DWORD a2,
                                           LPDWORD a3)
    = WriteConsoleInputA;

BOOL (__stdcall * Real_WriteConsoleInputW)(HANDLE a0,
                                           CONST INPUT_RECORD* a1,
                                           DWORD a2,
                                           LPDWORD a3)
    = WriteConsoleInputW;

BOOL (__stdcall * Real_WriteConsoleOutputA)(HANDLE a0,
                                            CONST CHAR_INFO* a1,
                                            COORD a2,
                                            COORD a3,
                                            PSMALL_RECT a4)
    = WriteConsoleOutputA;

BOOL (__stdcall * Real_WriteConsoleOutputAttribute)(HANDLE a0,
                                                    CONST WORD* a1,
                                                    DWORD a2,
                                                    COORD a3,
                                                    LPDWORD a4)
    = WriteConsoleOutputAttribute;

BOOL (__stdcall * Real_WriteConsoleOutputCharacterA)(HANDLE a0,
                                                     LPCSTR a1,
                                                     DWORD a2,
                                                     COORD a3,
                                                     LPDWORD a4)
    = WriteConsoleOutputCharacterA;

BOOL (__stdcall * Real_WriteConsoleOutputCharacterW)(HANDLE a0,
                                                     LPCWSTR a1,
                                                     DWORD a2,
                                                     COORD a3,
                                                     LPDWORD a4)
    = WriteConsoleOutputCharacterW;

BOOL (__stdcall * Real_WriteConsoleOutputW)(HANDLE a0,
                                            CONST CHAR_INFO* a1,
                                            COORD a2,
                                            COORD a3,
                                            PSMALL_RECT a4)
    = WriteConsoleOutputW;

BOOL (__stdcall * Real_WriteConsoleW)(HANDLE a0,
                                      CONST void* a1,
                                      DWORD a2,
                                      LPDWORD a3,
                                      LPVOID a4)
    = WriteConsoleW;

BOOL (__stdcall * Real_WriteFile)(HANDLE a0,
                                  LPCVOID a1,
                                  DWORD a2,
                                  LPDWORD a3,
                                  LPOVERLAPPED a4)
    = WriteFile;

BOOL (__stdcall * Real_WriteFileEx)(HANDLE a0,
                                    LPCVOID a1,
                                    DWORD a2,
                                    LPOVERLAPPED a3,
                                    LPOVERLAPPED_COMPLETION_ROUTINE a4)
    = WriteFileEx;

HRESULT (__stdcall * Real_WriteFmtUserTypeStg)(LPSTORAGE a0,
                                               CLIPFORMAT a1,
                                               LPOLESTR a2)
    = WriteFmtUserTypeStg;

BOOL (__stdcall * Real_WritePrivateProfileSectionA)(LPCSTR a0,
                                                    LPCSTR a1,
                                                    LPCSTR a2)
    = WritePrivateProfileSectionA;

BOOL (__stdcall * Real_WritePrivateProfileSectionW)(LPCWSTR a0,
                                                    LPCWSTR a1,
                                                    LPCWSTR a2)
    = WritePrivateProfileSectionW;

BOOL (__stdcall * Real_WritePrivateProfileStringA)(LPCSTR a0,
                                                   LPCSTR a1,
                                                   LPCSTR a2,
                                                   LPCSTR a3)
    = WritePrivateProfileStringA;

BOOL (__stdcall * Real_WritePrivateProfileStringW)(LPCWSTR a0,
                                                   LPCWSTR a1,
                                                   LPCWSTR a2,
                                                   LPCWSTR a3)
    = WritePrivateProfileStringW;

BOOL (__stdcall * Real_WritePrivateProfileStructA)(LPCSTR a0,
                                                   LPCSTR a1,
                                                   LPVOID a2,
                                                   UINT a3,
                                                   LPCSTR a4)
    = WritePrivateProfileStructA;

BOOL (__stdcall * Real_WritePrivateProfileStructW)(LPCWSTR a0,
                                                   LPCWSTR a1,
                                                   LPVOID a2,
                                                   UINT a3,
                                                   LPCWSTR a4)
    = WritePrivateProfileStructW;

#if _MSC_VER < 1300
BOOL (__stdcall * Real_WriteProcessMemory)(HANDLE a0,
                                           LPVOID a1,
                                           LPVOID a2,
                                           DWORD_PTR a3,
                                           PDWORD_PTR a4)
    = WriteProcessMemory;
#else
BOOL (__stdcall * Real_WriteProcessMemory)(HANDLE a0,
                                           LPVOID a1,
                                           LPCVOID a2,
                                           DWORD_PTR a3,
                                           PDWORD_PTR a4)
    = WriteProcessMemory;
#endif

BOOL (__stdcall * Real_WriteProfileSectionA)(LPCSTR a0,
                                             LPCSTR a1)
    = WriteProfileSectionA;

BOOL (__stdcall * Real_WriteProfileSectionW)(LPCWSTR a0,
                                             LPCWSTR a1)
    = WriteProfileSectionW;

BOOL (__stdcall * Real_WriteProfileStringA)(LPCSTR a0,
                                            LPCSTR a1,
                                            LPCSTR a2)
    = WriteProfileStringA;

BOOL (__stdcall * Real_WriteProfileStringW)(LPCWSTR a0,
                                            LPCWSTR a1,
                                            LPCWSTR a2)
    = WriteProfileStringW;

DWORD (__stdcall * Real_WriteTapemark)(HANDLE a0,
                                       DWORD a1,
                                       DWORD a2,
                                       BOOL a3)
    = WriteTapemark;

int (__stdcall * Real___WSAFDIsSet)(SOCKET a0,
                                    fd_set* a1)
    = __WSAFDIsSet;

long (__stdcall * Real__hread)(HFILE a0,
                               LPVOID a1,
                               long a2)
    = _hread;

long (__stdcall * Real__hwrite)(HFILE a0,
                                LPCSTR a1,
                                long a2)
    = _hwrite;

HFILE (__stdcall * Real__lclose)(HFILE a0)
    = _lclose;

HFILE (__stdcall * Real__lcreat)(LPCSTR a0,
                                 int a1)
    = _lcreat;

LONG (__stdcall * Real__llseek)(HFILE a0,
                                LONG a1,
                                int a2)
    = _llseek;

HFILE (__stdcall * Real__lopen)(LPCSTR a0,
                                int a1)
    = _lopen;

UINT (__stdcall * Real__lread)(HFILE a0,
                               LPVOID a1,
                               UINT a2)
    = _lread;

UINT (__stdcall * Real__lwrite)(HFILE a0,
                                LPCSTR a1,
                                UINT a2)
    = _lwrite;

SOCKET (__stdcall * Real_accept)(SOCKET a0,
                                 sockaddr* a1,
                                 int* a2)
    = accept;

int (__stdcall * Real_bind)(SOCKET a0,
                            CONST sockaddr* a1,
                            int a2)
    = bind;

int (__stdcall * Real_closesocket)(SOCKET a0)
    = closesocket;

int (__stdcall * Real_connect)(SOCKET a0,
                               CONST sockaddr* a1,
                               int a2)
    = connect;

hostent * (__stdcall * Real_gethostbyaddr)(CONST char* a0,
                                          int a1,
                                          int a2)
    = gethostbyaddr;

hostent * (__stdcall * Real_gethostbyname)(CONST char* a0)
    = gethostbyname;

int (__stdcall * Real_gethostname)(char* a0,
                                   int a1)
    = gethostname;

int (__stdcall * Real_getpeername)(SOCKET a0,
                                   sockaddr* a1,
                                   int* a2)
    = getpeername;

protoent * (__stdcall * Real_getprotobyname)(CONST char* a0)
    = getprotobyname;

protoent * (__stdcall * Real_getprotobynumber)(int a0)
    = getprotobynumber;

servent * (__stdcall * Real_getservbyname)(CONST char* a0,
                                           CONST char* a1)
    = getservbyname;

servent * (__stdcall * Real_getservbyport)(int a0,
                                           CONST char* a1)
    = getservbyport;

int (__stdcall * Real_getsockname)(SOCKET a0,
                                   sockaddr* a1,
                                   int* a2)
    = getsockname;

int (__stdcall * Real_getsockopt)(SOCKET a0,
                                  int a1,
                                  int a2,
                                  char* a3,
                                  int* a4)
    = getsockopt;

u_long (__stdcall * Real_htonl)(u_long a0)
    = htonl;

u_short (__stdcall * Real_htons)(u_short a0)
    = htons;

unsigned long (__stdcall * Real_inet_addr)(CONST char* a0)
    = inet_addr;

char * (__stdcall * Real_inet_ntoa)(in_addr a0)
    = inet_ntoa;

int (__stdcall * Real_ioctlsocket)(SOCKET a0,
                                   long a1,
                                   u_long* a2)
    = ioctlsocket;

void (__stdcall * Real_keybd_event)(BYTE a0,
                                    BYTE a1,
                                    DWORD a2,
                                    ULONG_PTR a3)
    = keybd_event;

int (__stdcall * Real_listen)(SOCKET a0,
                              int a1)
    = listen;

void (__stdcall * Real_mouse_event)(DWORD a0,
                                    DWORD a1,
                                    DWORD a2,
                                    DWORD a3,
                                    ULONG_PTR a4)
    = mouse_event;

u_long (__stdcall * Real_ntohl)(u_long a0)
    = ntohl;

u_short (__stdcall * Real_ntohs)(u_short a0)
    = ntohs;

int (__stdcall * Real_recv)(SOCKET a0,
                            char* a1,
                            int a2,
                            int a3)
    = recv;

int (__stdcall * Real_recvfrom)(SOCKET a0,
                                char* a1,
                                int a2,
                                int a3,
                                sockaddr* a4,
                                int* a5)
    = recvfrom;

int (__stdcall * Real_select)(int a0,
                              fd_set* a1,
                              fd_set* a2,
                              fd_set* a3,
                              CONST timeval* a4)
    = select;

int (__stdcall * Real_send)(SOCKET a0,
                            CONST char* a1,
                            int a2,
                            int a3)
    = send;

int (__stdcall * Real_sendto)(SOCKET a0,
                              CONST char* a1,
                              int a2,
                              int a3,
                              CONST sockaddr* a4,
                              int a5)
    = sendto;

int (__stdcall * Real_setsockopt)(SOCKET a0,
                                  int a1,
                                  int a2,
                                  CONST char* a3,
                                  int a4)
    = setsockopt;

int (__stdcall * Real_shutdown)(SOCKET a0,
                                int a1)
    = shutdown;

SOCKET (__stdcall * Real_socket)(int a0,
                                 int a1,
                                 int a2)
    = socket;

///////////////////////////////////////////////////////////////////// Detours.
//

int __stdcall Mine_AbortDoc(HDC a0)
{
    _PrintEnter("AbortDoc(%p)\n", a0);

    int rv = 0;
    __try {
        rv = Real_AbortDoc(a0);
    } __finally {
        _PrintExit("AbortDoc() -> %x\n", rv);
    };
    return rv;
}

BOOL __stdcall Mine_AbortPath(HDC a0)
{
    _PrintEnter("AbortPath(%p)\n", a0);

    BOOL rv = 0;
    __try {
        rv = Real_AbortPath(a0);
    } __finally {
        _PrintExit("AbortPath() -> %x\n", rv);
    };
    return rv;
}

HKL __stdcall Mine_ActivateKeyboardLayout(HKL a0,
                                          UINT a1)
{
    _PrintEnter("ActivateKeyboardLayout(%p,%p)\n", a0, a1);

    HKL rv = 0;
    __try {
        rv = Real_ActivateKeyboardLayout(a0, a1);
    } __finally {
        _PrintExit("ActivateKeyboardLayout(,) -> %p\n", rv);
    };
    return rv;
}

ATOM __stdcall Mine_AddAtomA(LPCSTR a0)
{
    _PrintEnter("AddAtomA(%hs)\n", a0);

    ATOM rv = 0;
    __try {
        rv = Real_AddAtomA(a0);
    } __finally {
        _PrintExit("AddAtomA() -> %x\n", rv);
    };
    return rv;
}

ATOM __stdcall Mine_AddAtomW(LPCWSTR a0)
{
    _PrintEnter("AddAtomW(%ls)\n", a0);

    ATOM rv = 0;
    __try {
        rv = Real_AddAtomW(a0);
    } __finally {
        _PrintExit("AddAtomW() -> %x\n", rv);
    };
    return rv;
}

int __stdcall Mine_AddFontResourceA(LPCSTR a0)
{
    _PrintEnter("AddFontResourceA(%hs)\n", a0);

    int rv = 0;
    __try {
        rv = Real_AddFontResourceA(a0);
    } __finally {
        _PrintExit("AddFontResourceA() -> %x\n", rv);
    };
    return rv;
}

int __stdcall Mine_AddFontResourceW(LPCWSTR a0)
{
    _PrintEnter("AddFontResourceW(%ls)\n", a0);

    int rv = 0;
    __try {
        rv = Real_AddFontResourceW(a0);
    } __finally {
        _PrintExit("AddFontResourceW() -> %x\n", rv);
    };
    return rv;
}

BOOL __stdcall Mine_AdjustWindowRect(LPRECT a0,
                                     DWORD a1,
                                     BOOL a2)
{
    _PrintEnter("AdjustWindowRect(%p,%p,%p)\n", a0, a1, a2);

    BOOL rv = 0;
    __try {
        rv = Real_AdjustWindowRect(a0, a1, a2);
    } __finally {
        _PrintExit("AdjustWindowRect(,,) -> %x\n", rv);
    };
    return rv;
}

BOOL __stdcall Mine_AdjustWindowRectEx(LPRECT a0,
                                       DWORD a1,
                                       BOOL a2,
                                       DWORD a3)
{
    _PrintEnter("AdjustWindowRectEx(%p,%p,%p,%p)\n", a0, a1, a2, a3);

    BOOL rv = 0;
    __try {
        rv = Real_AdjustWindowRectEx(a0, a1, a2, a3);
    } __finally {
        _PrintExit("AdjustWindowRectEx(,,,) -> %x\n", rv);
    };
    return rv;
}

BOOL __stdcall Mine_AllocConsole(void)
{
    _PrintEnter("AllocConsole()\n");

    BOOL rv = 0;
    __try {
        rv = Real_AllocConsole();
    } __finally {
        _PrintExit("AllocConsole() -> %x\n", rv);
    };
    return rv;
}

BOOL __stdcall Mine_AngleArc(HDC a0,
                             int a1,
                             int a2,
                             DWORD a3,
                             FLOAT a4,
                             FLOAT a5)
{
    _PrintEnter("AngleArc(%p,%p,%p,%p,%p,%p)\n", a0, a1, a2, a3, a4, a5);

    BOOL rv = 0;
    __try {
        rv = Real_AngleArc(a0, a1, a2, a3, a4, a5);
    } __finally {
        _PrintExit("AngleArc(,,,,,) -> %x\n", rv);
    };
    return rv;
}

BOOL __stdcall Mine_AnimatePalette(HPALETTE a0,
                                   UINT a1,
                                   UINT a2,
                                   PALETTEENTRY* a3)
{
    _PrintEnter("AnimatePalette(%p,%p,%p,%p)\n", a0, a1, a2, a3);

    BOOL rv = 0;
    __try {
        rv = Real_AnimatePalette(a0, a1, a2, a3);
    } __finally {
        _PrintExit("AnimatePalette(,,,) -> %x\n", rv);
    };
    return rv;
}

BOOL __stdcall Mine_AnyPopup(void)
{
    _PrintEnter("AnyPopup()\n");

    BOOL rv = 0;
    __try {
        rv = Real_AnyPopup();
    } __finally {
        _PrintExit("AnyPopup() -> %x\n", rv);
    };
    return rv;
}

BOOL __stdcall Mine_AppendMenuA(HMENU a0,
                                UINT a1,
                                UINT_PTR a2,
                                LPCSTR a3)
{
    _PrintEnter("AppendMenuA(%p,%p,%p,%hs)\n", a0, a1, a2, a3);

    BOOL rv = 0;
    __try {
        rv = Real_AppendMenuA(a0, a1, a2, a3);
    } __finally {
        _PrintExit("AppendMenuA(,,,) -> %x\n", rv);
    };
    return rv;
}

BOOL __stdcall Mine_AppendMenuW(HMENU a0,
                                UINT a1,
                                UINT_PTR a2,
                                LPCWSTR a3)
{
    _PrintEnter("AppendMenuW(%p,%p,%p,%ls)\n", a0, a1, a2, a3);

    BOOL rv = 0;
    __try {
        rv = Real_AppendMenuW(a0, a1, a2, a3);
    } __finally {
        _PrintExit("AppendMenuW(,,,) -> %x\n", rv);
    };
    return rv;
}

BOOL __stdcall Mine_Arc(HDC a0,
                        int a1,
                        int a2,
                        int a3,
                        int a4,
                        int a5,
                        int a6,
                        int a7,
                        int a8)
{
    _PrintEnter("Arc(%p,%p,%p,%p,%p,%p,%p,%p,%p)\n", a0, a1, a2, a3, a4, a5, a6, a7, a8);

    BOOL rv = 0;
    __try {
        rv = Real_Arc(a0, a1, a2, a3, a4, a5, a6, a7, a8);
    } __finally {
        _PrintExit("Arc(,,,,,,,,) -> %x\n", rv);
    };
    return rv;
}

BOOL __stdcall Mine_ArcTo(HDC a0,
                          int a1,
                          int a2,
                          int a3,
                          int a4,
                          int a5,
                          int a6,
                          int a7,
                          int a8)
{
    _PrintEnter("ArcTo(%p,%p,%p,%p,%p,%p,%p,%p,%p)\n", a0, a1, a2, a3, a4, a5, a6, a7, a8);

    BOOL rv = 0;
    __try {
        rv = Real_ArcTo(a0, a1, a2, a3, a4, a5, a6, a7, a8);
    } __finally {
        _PrintExit("ArcTo(,,,,,,,,) -> %x\n", rv);
    };
    return rv;
}

BOOL __stdcall Mine_AreFileApisANSI(void)
{
    _PrintEnter("AreFileApisANSI()\n");

    BOOL rv = 0;
    __try {
        rv = Real_AreFileApisANSI();
    } __finally {
        _PrintExit("AreFileApisANSI() -> %x\n", rv);
    };
    return rv;
}

UINT __stdcall Mine_ArrangeIconicWindows(HWND a0)
{
    _PrintEnter("ArrangeIconicWindows(%p)\n", a0);

    UINT rv = 0;
    __try {
        rv = Real_ArrangeIconicWindows(a0);
    } __finally {
        _PrintExit("ArrangeIconicWindows() -> %x\n", rv);
    };
    return rv;
}

BOOL __stdcall Mine_AttachThreadInput(DWORD a0,
                                      DWORD a1,
                                      BOOL a2)
{
    _PrintEnter("AttachThreadInput(%p,%p,%p)\n", a0, a1, a2);

    BOOL rv = 0;
    __try {
        rv = Real_AttachThreadInput(a0, a1, a2);
    } __finally {
        _PrintExit("AttachThreadInput(,,) -> %x\n", rv);
    };
    return rv;
}

BOOL __stdcall Mine_BackupRead(HANDLE a0,
                               LPBYTE a1,
                               DWORD a2,
                               LPDWORD a3,
                               BOOL a4,
                               BOOL a5,
                               LPVOID* a6)
{
    _PrintEnter("BackupRead(%p,%p,%p,%p,%p,%p,%p)\n", a0, a1, a2, a3, a4, a5, a6);

    BOOL rv = 0;
    __try {
        rv = Real_BackupRead(a0, a1, a2, a3, a4, a5, a6);
    } __finally {
        _PrintExit("BackupRead(,,,,,,) -> %x\n", rv);
    };
    return rv;
}

BOOL __stdcall Mine_BackupSeek(HANDLE a0,
                               DWORD a1,
                               DWORD a2,
                               LPDWORD a3,
                               LPDWORD a4,
                               LPVOID* a5)
{
    _PrintEnter("BackupSeek(%p,%p,%p,%p,%p,%p)\n", a0, a1, a2, a3, a4, a5);

    BOOL rv = 0;
    __try {
        rv = Real_BackupSeek(a0, a1, a2, a3, a4, a5);
    } __finally {
        _PrintExit("BackupSeek(,,,,,) -> %x\n", rv);
    };
    return rv;
}

BOOL __stdcall Mine_BackupWrite(HANDLE a0,
                                LPBYTE a1,
                                DWORD a2,
                                LPDWORD a3,
                                BOOL a4,
                                BOOL a5,
                                LPVOID* a6)
{
    _PrintEnter("BackupWrite(%p,%p,%p,%p,%p,%p,%p)\n", a0, a1, a2, a3, a4, a5, a6);

    BOOL rv = 0;
    __try {
        rv = Real_BackupWrite(a0, a1, a2, a3, a4, a5, a6);
    } __finally {
        _PrintExit("BackupWrite(,,,,,,) -> %x\n", rv);
    };
    return rv;
}

BOOL __stdcall Mine_Beep(DWORD a0,
                         DWORD a1)
{
    _PrintEnter("Beep(%p,%p)\n", a0, a1);

    BOOL rv = 0;
    __try {
        rv = Real_Beep(a0, a1);
    } __finally {
        _PrintExit("Beep(,) -> %x\n", rv);
    };
    return rv;
}

HDWP __stdcall Mine_BeginDeferWindowPos(int a0)
{
    _PrintEnter("BeginDeferWindowPos(%p)\n", a0);

    HDWP rv = 0;
    __try {
        rv = Real_BeginDeferWindowPos(a0);
    } __finally {
        _PrintExit("BeginDeferWindowPos() -> %p\n", rv);
    };
    return rv;
}

HDC __stdcall Mine_BeginPaint(HWND a0,
                              LPPAINTSTRUCT a1)
{
    _PrintEnter("BeginPaint(%p,%p)\n", a0, a1);

    HDC rv = 0;
    __try {
        rv = Real_BeginPaint(a0, a1);
    } __finally {
        _PrintExit("BeginPaint(,) -> %p\n", rv);
    };
    return rv;
}

BOOL __stdcall Mine_BeginPath(HDC a0)
{
    _PrintEnter("BeginPath(%p)\n", a0);

    BOOL rv = 0;
    __try {
        rv = Real_BeginPath(a0);
    } __finally {
        _PrintExit("BeginPath() -> %x\n", rv);
    };
    return rv;
}

HANDLE __stdcall Mine_BeginUpdateResourceA(LPCSTR a0,
                                           BOOL a1)
{
    _PrintEnter("BeginUpdateResourceA(%hs,%p)\n", a0, a1);

    HANDLE rv = 0;
    __try {
        rv = Real_BeginUpdateResourceA(a0, a1);
    } __finally {
        _PrintExit("BeginUpdateResourceA(,) -> %p\n", rv);
    };
    return rv;
}

HANDLE __stdcall Mine_BeginUpdateResourceW(LPCWSTR a0,
                                           BOOL a1)
{
    _PrintEnter("BeginUpdateResourceW(%ls,%p)\n", a0, a1);

    HANDLE rv = 0;
    __try {
        rv = Real_BeginUpdateResourceW(a0, a1);
    } __finally {
        _PrintExit("BeginUpdateResourceW(,) -> %p\n", rv);
    };
    return rv;
}

HRESULT __stdcall Mine_BindMoniker(IMoniker* a0,
                                   DWORD a1,
                                   CONST IID& a2,
                                   LPVOID* a3)
{
    _PrintEnter("BindMoniker(%p,%p,%p,%p)\n", a0, a1, a2, a3);

    HRESULT rv = 0;
    __try {
        rv = Real_BindMoniker(a0, a1, a2, a3);
    } __finally {
        _PrintExit("BindMoniker(,,,) -> %x\n", rv);
    };
    return rv;
}

BOOL __stdcall Mine_BitBlt(HDC a0,
                           int a1,
                           int a2,
                           int a3,
                           int a4,
                           HDC a5,
                           int a6,
                           int a7,
                           DWORD a8)
{
    _PrintEnter("BitBlt(%p,%p,%p,%p,%p,%p,%p,%p,%p)\n", a0, a1, a2, a3, a4, a5, a6, a7, a8);

    BOOL rv = 0;
    __try {
        rv = Real_BitBlt(a0, a1, a2, a3, a4, a5, a6, a7, a8);
    } __finally {
        _PrintExit("BitBlt(,,,,,,,,) -> %x\n", rv);
    };
    return rv;
}

BOOL __stdcall Mine_BringWindowToTop(HWND a0)
{
    _PrintEnter("BringWindowToTop(%p)\n", a0);

    BOOL rv = 0;
    __try {
        rv = Real_BringWindowToTop(a0);
    } __finally {
        _PrintExit("BringWindowToTop() -> %x\n", rv);
    };
    return rv;
}

long __stdcall Mine_BroadcastSystemMessageA(DWORD a0,
                                            LPDWORD a1,
                                            UINT a2,
                                            WPARAM a3,
                                            LPARAM a4)
{
    _PrintEnter("BroadcastSystemMessageA(%p,%p,%p,%p,%p)\n", a0, a1, a2, a3, a4);

    long rv = 0;
    __try {
        rv = Real_BroadcastSystemMessageA(a0, a1, a2, a3, a4);
    } __finally {
        _PrintExit("BroadcastSystemMessageA(,,,,) -> %x\n", rv);
    };
    return rv;
}

long __stdcall Mine_BroadcastSystemMessageW(DWORD a0,
                                            LPDWORD a1,
                                            UINT a2,
                                            WPARAM a3,
                                            LPARAM a4)
{
    _PrintEnter("BroadcastSystemMessageW(%p,%p,%p,%p,%p)\n", a0, a1, a2, a3, a4);

    long rv = 0;
    __try {
        rv = Real_BroadcastSystemMessageW(a0, a1, a2, a3, a4);
    } __finally {
        _PrintExit("BroadcastSystemMessageW(,,,,) -> %x\n", rv);
    };
    return rv;
}

BOOL __stdcall Mine_BuildCommDCBA(LPCSTR a0,
                                  LPDCB a1)
{
    _PrintEnter("BuildCommDCBA(%hs,%p)\n", a0, a1);

    BOOL rv = 0;
    __try {
        rv = Real_BuildCommDCBA(a0, a1);
    } __finally {
        _PrintExit("BuildCommDCBA(,) -> %x\n", rv);
    };
    return rv;
}

BOOL __stdcall Mine_BuildCommDCBAndTimeoutsA(LPCSTR a0,
                                             LPDCB a1,
                                             LPCOMMTIMEOUTS a2)
{
    _PrintEnter("BuildCommDCBAndTimeoutsA(%hs,%p,%p)\n", a0, a1, a2);

    BOOL rv = 0;
    __try {
        rv = Real_BuildCommDCBAndTimeoutsA(a0, a1, a2);
    } __finally {
        _PrintExit("BuildCommDCBAndTimeoutsA(,,) -> %x\n", rv);
    };
    return rv;
}

BOOL __stdcall Mine_BuildCommDCBAndTimeoutsW(LPCWSTR a0,
                                             LPDCB a1,
                                             LPCOMMTIMEOUTS a2)
{
    _PrintEnter("BuildCommDCBAndTimeoutsW(%ls,%p,%p)\n", a0, a1, a2);

    BOOL rv = 0;
    __try {
        rv = Real_BuildCommDCBAndTimeoutsW(a0, a1, a2);
    } __finally {
        _PrintExit("BuildCommDCBAndTimeoutsW(,,) -> %x\n", rv);
    };
    return rv;
}

BOOL __stdcall Mine_BuildCommDCBW(LPCWSTR a0,
                                  LPDCB a1)
{
    _PrintEnter("BuildCommDCBW(%ls,%p)\n", a0, a1);

    BOOL rv = 0;
    __try {
        rv = Real_BuildCommDCBW(a0, a1);
    } __finally {
        _PrintExit("BuildCommDCBW(,) -> %x\n", rv);
    };
    return rv;
}

HRESULT __stdcall Mine_CLSIDFromProgID(LPCOLESTR a0,
                                       LPGUID a1)
{
    _PrintEnter("CLSIDFromProgID(%p,%p)\n", a0, a1);

    HRESULT rv = 0;
    __try {
        rv = Real_CLSIDFromProgID(a0, a1);
    } __finally {
        _PrintExit("CLSIDFromProgID(,) -> %p\n", rv);
    };
    return rv;
}

HRESULT __stdcall Mine_CLSIDFromString(LPOLESTR a0,
                                       LPGUID a1)
{
    _PrintEnter("CLSIDFromString(%p,%p)\n", a0, a1);

    HRESULT rv = 0;
    __try {
        rv = Real_CLSIDFromString(a0, a1);
    } __finally {
        _PrintExit("CLSIDFromString(,) -> %p\n", rv);
    };
    return rv;
}

BOOL __stdcall Mine_CallMsgFilterA(LPMSG a0,
                                   int a1)
{
    _PrintEnter("CallMsgFilterA(%p,%p)\n", a0, a1);

    BOOL rv = 0;
    __try {
        rv = Real_CallMsgFilterA(a0, a1);
    } __finally {
        _PrintExit("CallMsgFilterA(,) -> %x\n", rv);
    };
    return rv;
}

BOOL __stdcall Mine_CallMsgFilterW(LPMSG a0,
                                   int a1)
{
    _PrintEnter("CallMsgFilterW(%p,%p)\n", a0, a1);

    BOOL rv = 0;
    __try {
        rv = Real_CallMsgFilterW(a0, a1);
    } __finally {
        _PrintExit("CallMsgFilterW(,) -> %x\n", rv);
    };
    return rv;
}

BOOL __stdcall Mine_CallNamedPipeA(LPCSTR a0,
                                   LPVOID a1,
                                   DWORD a2,
                                   LPVOID a3,
                                   DWORD a4,
                                   LPDWORD a5,
                                   DWORD a6)
{
    _PrintEnter("CallNamedPipeA(%hs,%p,%p,%p,%p,%p,%p)\n", a0, a1, a2, a3, a4, a5, a6);

    BOOL rv = 0;
    __try {
        rv = Real_CallNamedPipeA(a0, a1, a2, a3, a4, a5, a6);
    } __finally {
        _PrintExit("CallNamedPipeA(,,,,,,) -> %x\n", rv);
    };
    return rv;
}

BOOL __stdcall Mine_CallNamedPipeW(LPCWSTR a0,
                                   LPVOID a1,
                                   DWORD a2,
                                   LPVOID a3,
                                   DWORD a4,
                                   LPDWORD a5,
                                   DWORD a6)
{
    _PrintEnter("CallNamedPipeW(%ls,%p,%p,%p,%p,%p,%p)\n", a0, a1, a2, a3, a4, a5, a6);

    BOOL rv = 0;
    __try {
        rv = Real_CallNamedPipeW(a0, a1, a2, a3, a4, a5, a6);
    } __finally {
        _PrintExit("CallNamedPipeW(,,,,,,) -> %x\n", rv);
    };
    return rv;
}

LRESULT __stdcall Mine_CallNextHookEx(HHOOK a0,
                                      int a1,
                                      WPARAM a2,
                                      LPARAM a3)
{
    _PrintEnter("CallNextHookEx(%p,%p,%p,%p)\n", a0, a1, a2, a3);

    LRESULT rv = 0;
    __try {
        rv = Real_CallNextHookEx(a0, a1, a2, a3);
    } __finally {
        _PrintExit("CallNextHookEx(,,,) -> %x\n", rv);
    };
    return rv;
}

LRESULT __stdcall Mine_CallWindowProcA(WNDPROC a0,
                                       HWND a1,
                                       UINT a2,
                                       WPARAM a3,
                                       LPARAM a4)
{
    _PrintEnter("CallWindowProcA(%p,%p,%p,%p,%p)\n", a0, a1, a2, a3, a4);

    LRESULT rv = 0;
    __try {
        rv = Real_CallWindowProcA(a0, a1, a2, a3, a4);
    } __finally {
        _PrintExit("CallWindowProcA(,,,,) -> %x\n", rv);
    };
    return rv;
}

LRESULT __stdcall Mine_CallWindowProcW(WNDPROC a0,
                                       HWND a1,
                                       UINT a2,
                                       WPARAM a3,
                                       LPARAM a4)
{
    _PrintEnter("CallWindowProcW(%p,%p,%p,%p,%p)\n", a0, a1, a2, a3, a4);

    LRESULT rv = 0;
    __try {
        rv = Real_CallWindowProcW(a0, a1, a2, a3, a4);
    } __finally {
        _PrintExit("CallWindowProcW(,,,,) -> %x\n", rv);
    };
    return rv;
}

BOOL __stdcall Mine_CancelDC(HDC a0)
{
    _PrintEnter("CancelDC(%p)\n", a0);

    BOOL rv = 0;
    __try {
        rv = Real_CancelDC(a0);
    } __finally {
        _PrintExit("CancelDC() -> %x\n", rv);
    };
    return rv;
}

BOOL __stdcall Mine_CancelIo(HANDLE a0)
{
    _PrintEnter("CancelIo(%p)\n", a0);

    BOOL rv = 0;
    __try {
        rv = Real_CancelIo(a0);
    } __finally {
        _PrintExit("CancelIo() -> %x\n", rv);
    };
    return rv;
}

BOOL __stdcall Mine_CancelWaitableTimer(HANDLE a0)
{
    _PrintEnter("CancelWaitableTimer(%p)\n", a0);

    BOOL rv = 0;
    __try {
        rv = Real_CancelWaitableTimer(a0);
    } __finally {
        _PrintExit("CancelWaitableTimer() -> %x\n", rv);
    };
    return rv;
}

WORD __stdcall Mine_CascadeWindows(HWND a0,
                                   UINT a1,
                                   RECT* a2,
                                   UINT a3,
                                   struct HWND__** a4)
{
    _PrintEnter("CascadeWindows(%p,%p,%p,%p,%p)\n", a0, a1, a2, a3, a4);

    WORD rv = 0;
    __try {
        rv = Real_CascadeWindows(a0, a1, a2, a3, a4);
    } __finally {
        _PrintExit("CascadeWindows(,,,,) -> %x\n", rv);
    };
    return rv;
}

BOOL __stdcall Mine_ChangeClipboardChain(HWND a0,
                                         HWND a1)
{
    _PrintEnter("ChangeClipboardChain(%p,%p)\n", a0, a1);

    BOOL rv = 0;
    __try {
        rv = Real_ChangeClipboardChain(a0, a1);
    } __finally {
        _PrintExit("ChangeClipboardChain(,) -> %x\n", rv);
    };
    return rv;
}

LONG __stdcall Mine_ChangeDisplaySettingsA(LPDEVMODEA a0,
                                           DWORD a1)
{
    _PrintEnter("ChangeDisplaySettingsA(%p,%p)\n", a0, a1);

    LONG rv = 0;
    __try {
        rv = Real_ChangeDisplaySettingsA(a0, a1);
    } __finally {
        _PrintExit("ChangeDisplaySettingsA(,) -> %x\n", rv);
    };
    return rv;
}

LONG __stdcall Mine_ChangeDisplaySettingsExA(LPCSTR a0,
                                             LPDEVMODEA a1,
                                             HWND a2,
                                             DWORD a3,
                                             LPVOID a4)
{
    _PrintEnter("ChangeDisplaySettingsExA(%hs,%p,%p,%p,%p)\n", a0, a1, a2, a3, a4);

    LONG rv = 0;
    __try {
        rv = Real_ChangeDisplaySettingsExA(a0, a1, a2, a3, a4);
    } __finally {
        _PrintExit("ChangeDisplaySettingsExA(,,,,) -> %x\n", rv);
    };
    return rv;
}

LONG __stdcall Mine_ChangeDisplaySettingsExW(LPCWSTR a0,
                                             LPDEVMODEW a1,
                                             HWND a2,
                                             DWORD a3,
                                             LPVOID a4)
{
    _PrintEnter("ChangeDisplaySettingsExW(%ls,%p,%p,%p,%p)\n", a0, a1, a2, a3, a4);

    LONG rv = 0;
    __try {
        rv = Real_ChangeDisplaySettingsExW(a0, a1, a2, a3, a4);
    } __finally {
        _PrintExit("ChangeDisplaySettingsExW(,,,,) -> %x\n", rv);
    };
    return rv;
}

LONG __stdcall Mine_ChangeDisplaySettingsW(LPDEVMODEW a0,
                                           DWORD a1)
{
    _PrintEnter("ChangeDisplaySettingsW(%p,%p)\n", a0, a1);

    LONG rv = 0;
    __try {
        rv = Real_ChangeDisplaySettingsW(a0, a1);
    } __finally {
        _PrintExit("ChangeDisplaySettingsW(,) -> %x\n", rv);
    };
    return rv;
}

BOOL __stdcall Mine_ChangeMenuA(HMENU a0,
                                UINT a1,
                                LPCSTR a2,
                                UINT a3,
                                UINT a4)
{
    _PrintEnter("ChangeMenuA(%p,%p,%hs,%p,%p)\n", a0, a1, a2, a3, a4);

    BOOL rv = 0;
    __try {
        rv = Real_ChangeMenuA(a0, a1, a2, a3, a4);
    } __finally {
        _PrintExit("ChangeMenuA(,,,,) -> %x\n", rv);
    };
    return rv;
}

BOOL __stdcall Mine_ChangeMenuW(HMENU a0,
                                UINT a1,
                                LPCWSTR a2,
                                UINT a3,
                                UINT a4)
{
    _PrintEnter("ChangeMenuW(%p,%p,%ls,%p,%p)\n", a0, a1, a2, a3, a4);

    BOOL rv = 0;
    __try {
        rv = Real_ChangeMenuW(a0, a1, a2, a3, a4);
    } __finally {
        _PrintExit("ChangeMenuW(,,,,) -> %x\n", rv);
    };
    return rv;
}

LPSTR __stdcall Mine_CharLowerA(LPSTR a0)
{
    _PrintEnter("CharLowerA(%hs)\n", a0);

    LPSTR rv = 0;
    __try {
        rv = Real_CharLowerA(a0);
    } __finally {
        _PrintExit("CharLowerA(%hs) -> %hs\n", a0, rv);
    };
    return rv;
}

DWORD __stdcall Mine_CharLowerBuffA(LPSTR a0,
                                    DWORD a1)
{
    _PrintEnter("CharLowerBuffA(%hs,%p)\n", a0, a1);

    DWORD rv = 0;
    __try {
        rv = Real_CharLowerBuffA(a0, a1);
    } __finally {
        _PrintExit("CharLowerBuffA(%hs,) -> %x\n", a0, rv);
    };
    return rv;
}

DWORD __stdcall Mine_CharLowerBuffW(LPWSTR a0,
                                    DWORD a1)
{
    _PrintEnter("CharLowerBuffW(%ls,%p)\n", a0, a1);

    DWORD rv = 0;
    __try {
        rv = Real_CharLowerBuffW(a0, a1);
    } __finally {
        _PrintExit("CharLowerBuffW(%ls,) -> %x\n", a0, rv);
    };
    return rv;
}

LPWSTR __stdcall Mine_CharLowerW(LPWSTR a0)
{
    _PrintEnter("CharLowerW(%ls)\n", a0);

    LPWSTR rv = 0;
    __try {
        rv = Real_CharLowerW(a0);
    } __finally {
        _PrintExit("CharLowerW(%ls) -> %ls\n", a0, rv);
    };
    return rv;
}

LPSTR __stdcall Mine_CharNextA(LPCSTR a0)
{
    _PrintEnter("CharNextA(%hs)\n", a0);

    LPSTR rv = 0;
    __try {
        rv = Real_CharNextA(a0);
    } __finally {
        _PrintExit("CharNextA() -> %hs\n", rv);
    };
    return rv;
}

LPSTR __stdcall Mine_CharNextExA(WORD a0,
                                 LPCSTR a1,
                                 DWORD a2)
{
    _PrintEnter("CharNextExA(%p,%hs,%p)\n", a0, a1, a2);

    LPSTR rv = 0;
    __try {
        rv = Real_CharNextExA(a0, a1, a2);
    } __finally {
        _PrintExit("CharNextExA(,,) -> %hs\n", rv);
    };
    return rv;
}

LPWSTR __stdcall Mine_CharNextW(LPCWSTR a0)
{
    _PrintEnter("CharNextW(%ls)\n", a0);

    LPWSTR rv = 0;
    __try {
        rv = Real_CharNextW(a0);
    } __finally {
        _PrintExit("CharNextW() -> %ls\n", rv);
    };
    return rv;
}

LPSTR __stdcall Mine_CharPrevA(LPCSTR a0,
                               LPCSTR a1)
{
    _PrintEnter("CharPrevA(%hs,%hs)\n", a0, a1);

    LPSTR rv = 0;
    __try {
        rv = Real_CharPrevA(a0, a1);
    } __finally {
        _PrintExit("CharPrevA(,) -> %hs\n", rv);
    };
    return rv;
}

LPSTR __stdcall Mine_CharPrevExA(WORD a0,
                                 LPCSTR a1,
                                 LPCSTR a2,
                                 DWORD a3)
{
    _PrintEnter("CharPrevExA(%p,%hs,%hs,%p)\n", a0, a1, a2, a3);

    LPSTR rv = 0;
    __try {
        rv = Real_CharPrevExA(a0, a1, a2, a3);
    } __finally {
        _PrintExit("CharPrevExA(,,,) -> %hs\n", rv);
    };
    return rv;
}

LPWSTR __stdcall Mine_CharPrevW(LPCWSTR a0,
                                LPCWSTR a1)
{
    _PrintEnter("CharPrevW(%ls,%ls)\n", a0, a1);

    LPWSTR rv = 0;
    __try {
        rv = Real_CharPrevW(a0, a1);
    } __finally {
        _PrintExit("CharPrevW(,) -> %ls\n", rv);
    };
    return rv;
}

BOOL __stdcall Mine_CharToOemA(LPCSTR a0,
                               LPSTR a1)
{
    _PrintEnter("CharToOemA(%hs,%p)\n", a0, a1);

    BOOL rv = 0;
    __try {
        rv = Real_CharToOemA(a0, a1);
    } __finally {
        _PrintExit("CharToOemA(,%hs) -> %x\n", a1, rv);
    };
    return rv;
}

BOOL __stdcall Mine_CharToOemBuffA(LPCSTR a0,
                                   LPSTR a1,
                                   DWORD a2)
{
    _PrintEnter("CharToOemBuffA(%hs,%p,%p)\n", a0, a1, a2);

    BOOL rv = 0;
    __try {
        rv = Real_CharToOemBuffA(a0, a1, a2);
    } __finally {
        _PrintExit("CharToOemBuffA(,%hs,) -> %x\n", a1, rv);
    };
    return rv;
}

BOOL __stdcall Mine_CharToOemBuffW(LPCWSTR a0,
                                   LPSTR a1,
                                   DWORD a2)
{
    _PrintEnter("CharToOemBuffW(%ls,%p,%p)\n", a0, a1, a2);

    BOOL rv = 0;
    __try {
        rv = Real_CharToOemBuffW(a0, a1, a2);
    } __finally {
        _PrintExit("CharToOemBuffW(,%hs,) -> %x\n", a1, rv);
    };
    return rv;
}

BOOL __stdcall Mine_CharToOemW(LPCWSTR a0,
                               LPSTR a1)
{
    _PrintEnter("CharToOemW(%ls,%p)\n", a0, a1);

    BOOL rv = 0;
    __try {
        rv = Real_CharToOemW(a0, a1);
    } __finally {
        _PrintExit("CharToOemW(,%hs) -> %x\n", a1, rv);
    };
    return rv;
}

LPSTR __stdcall Mine_CharUpperA(LPSTR a0)
{
    _PrintEnter("CharUpperA(%hs)\n", a0);

    LPSTR rv = 0;
    __try {
        rv = Real_CharUpperA(a0);
    } __finally {
        _PrintExit("CharUpperA(%hs) -> %hs\n", a0, rv);
    };
    return rv;
}

DWORD __stdcall Mine_CharUpperBuffA(LPSTR a0,
                                    DWORD a1)
{
    _PrintEnter("CharUpperBuffA(%hs,%p)\n", a0, a1);

    DWORD rv = 0;
    __try {
        rv = Real_CharUpperBuffA(a0, a1);
    } __finally {
        _PrintExit("CharUpperBuffA(%hs,) -> %x\n", a0, rv);
    };
    return rv;
}

DWORD __stdcall Mine_CharUpperBuffW(LPWSTR a0,
                                    DWORD a1)
{
    _PrintEnter("CharUpperBuffW(%ls,%p)\n", a0, a1);

    DWORD rv = 0;
    __try {
        rv = Real_CharUpperBuffW(a0, a1);
    } __finally {
        _PrintExit("CharUpperBuffW(%ls,) -> %x\n", a0, rv);
    };
    return rv;
}

LPWSTR __stdcall Mine_CharUpperW(LPWSTR a0)
{
    _PrintEnter("CharUpperW(%ls)\n", a0);

    LPWSTR rv = 0;
    __try {
        rv = Real_CharUpperW(a0);
    } __finally {
        _PrintExit("CharUpperW(%ls) -> %ls\n", a0, rv);
    };
    return rv;
}

BOOL __stdcall Mine_CheckColorsInGamut(
                                       HDC a0,
#ifdef GDIPLUS_TS_QUERYVER
                                       LPRGBTRIPLE a1,
#else
                                       LPVOID a1,
#endif
                                       LPVOID a2,
                                       DWORD a3
                                      )
{
    _PrintEnter("CheckColorsInGamut(%p,%p,%p,%p)\n", a0, a1, a2, a3);

    BOOL rv = 0;
    __try {
        rv = Real_CheckColorsInGamut(a0, a1, a2, a3);
    } __finally {
        _PrintExit("CheckColorsInGamut(,,,) -> %x\n", rv);
    };
    return rv;
}

BOOL __stdcall Mine_CheckDlgButton(HWND a0,
                                   int a1,
                                   UINT a2)
{
    _PrintEnter("CheckDlgButton(%p,%p,%p)\n", a0, a1, a2);

    BOOL rv = 0;
    __try {
        rv = Real_CheckDlgButton(a0, a1, a2);
    } __finally {
        _PrintExit("CheckDlgButton(,,) -> %x\n", rv);
    };
    return rv;
}

DWORD __stdcall Mine_CheckMenuItem(HMENU a0,
                                   UINT a1,
                                   UINT a2)
{
    _PrintEnter("CheckMenuItem(%p,%p,%p)\n", a0, a1, a2);

    DWORD rv = 0;
    __try {
        rv = Real_CheckMenuItem(a0, a1, a2);
    } __finally {
        _PrintExit("CheckMenuItem(,,) -> %x\n", rv);
    };
    return rv;
}

BOOL __stdcall Mine_CheckMenuRadioItem(HMENU a0,
                                       UINT a1,
                                       UINT a2,
                                       UINT a3,
                                       UINT a4)
{
    _PrintEnter("CheckMenuRadioItem(%p,%p,%p,%p,%p)\n", a0, a1, a2, a3, a4);

    BOOL rv = 0;
    __try {
        rv = Real_CheckMenuRadioItem(a0, a1, a2, a3, a4);
    } __finally {
        _PrintExit("CheckMenuRadioItem(,,,,) -> %x\n", rv);
    };
    return rv;
}

BOOL __stdcall Mine_CheckRadioButton(HWND a0,
                                     int a1,
                                     int a2,
                                     int a3)
{
    _PrintEnter("CheckRadioButton(%p,%p,%p,%p)\n", a0, a1, a2, a3);

    BOOL rv = 0;
    __try {
        rv = Real_CheckRadioButton(a0, a1, a2, a3);
    } __finally {
        _PrintExit("CheckRadioButton(,,,) -> %x\n", rv);
    };
    return rv;
}

HWND __stdcall Mine_ChildWindowFromPoint(HWND a0,
                                         POINT a1)
{
    _PrintEnter("ChildWindowFromPoint(%p,%p)\n", a0, a1);

    HWND rv = 0;
    __try {
        rv = Real_ChildWindowFromPoint(a0, a1);
    } __finally {
        _PrintExit("ChildWindowFromPoint(,) -> %p\n", rv);
    };
    return rv;
}

HWND __stdcall Mine_ChildWindowFromPointEx(HWND a0,
                                           POINT a1,
                                           UINT a2)
{
    _PrintEnter("ChildWindowFromPointEx(%p,%p,%p)\n", a0, a1, a2);

    HWND rv = 0;
    __try {
        rv = Real_ChildWindowFromPointEx(a0, a1, a2);
    } __finally {
        _PrintExit("ChildWindowFromPointEx(,,) -> %p\n", rv);
    };
    return rv;
}

int __stdcall Mine_ChoosePixelFormat(HDC a0,
                                     PIXELFORMATDESCRIPTOR* a1)
{
    _PrintEnter("ChoosePixelFormat(%p,%p)\n", a0, a1);

    int rv = 0;
    __try {
        rv = Real_ChoosePixelFormat(a0, a1);
    } __finally {
        _PrintExit("ChoosePixelFormat(,) -> %x\n", rv);
    };
    return rv;
}

BOOL __stdcall Mine_Chord(HDC a0,
                          int a1,
                          int a2,
                          int a3,
                          int a4,
                          int a5,
                          int a6,
                          int a7,
                          int a8)
{
    _PrintEnter("Chord(%p,%p,%p,%p,%p,%p,%p,%p,%p)\n", a0, a1, a2, a3, a4, a5, a6, a7, a8);

    BOOL rv = 0;
    __try {
        rv = Real_Chord(a0, a1, a2, a3, a4, a5, a6, a7, a8);
    } __finally {
        _PrintExit("Chord(,,,,,,,,) -> %x\n", rv);
    };
    return rv;
}

BOOL __stdcall Mine_ClearCommBreak(HANDLE a0)
{
    _PrintEnter("ClearCommBreak(%p)\n", a0);

    BOOL rv = 0;
    __try {
        rv = Real_ClearCommBreak(a0);
    } __finally {
        _PrintExit("ClearCommBreak() -> %x\n", rv);
    };
    return rv;
}

BOOL __stdcall Mine_ClearCommError(HANDLE a0,
                                   LPDWORD a1,
                                   LPCOMSTAT a2)
{
    _PrintEnter("ClearCommError(%p,%p,%p)\n", a0, a1, a2);

    BOOL rv = 0;
    __try {
        rv = Real_ClearCommError(a0, a1, a2);
    } __finally {
        _PrintExit("ClearCommError(,,) -> %x\n", rv);
    };
    return rv;
}

BOOL __stdcall Mine_ClientToScreen(HWND a0,
                                   POINT* a1)
{
    _PrintEnter("ClientToScreen(%p,%p)\n", a0, a1);

    BOOL rv = 0;
    __try {
        rv = Real_ClientToScreen(a0, a1);
    } __finally {
        _PrintExit("ClientToScreen(,) -> %x\n", rv);
    };
    return rv;
}

BOOL __stdcall Mine_ClipCursor(RECT* a0)
{
    _PrintEnter("ClipCursor(%p)\n", a0);

    BOOL rv = 0;
    __try {
        rv = Real_ClipCursor(a0);
    } __finally {
        _PrintExit("ClipCursor() -> %x\n", rv);
    };
    return rv;
}

BOOL __stdcall Mine_CloseClipboard(void)
{
    _PrintEnter("CloseClipboard()\n");

    BOOL rv = 0;
    __try {
        rv = Real_CloseClipboard();
    } __finally {
        _PrintExit("CloseClipboard() -> %x\n", rv);
    };
    return rv;
}

BOOL __stdcall Mine_CloseDesktop(HDESK a0)
{
    _PrintEnter("CloseDesktop(%p)\n", a0);

    BOOL rv = 0;
    __try {
        rv = Real_CloseDesktop(a0);
    } __finally {
        _PrintExit("CloseDesktop() -> %x\n", rv);
    };
    return rv;
}

HENHMETAFILE __stdcall Mine_CloseEnhMetaFile(HDC a0)
{
    _PrintEnter("CloseEnhMetaFile(%p)\n", a0);

    HENHMETAFILE rv = 0;
    __try {
        rv = Real_CloseEnhMetaFile(a0);
    } __finally {
        _PrintExit("CloseEnhMetaFile() -> %p\n", rv);
    };
    return rv;
}

BOOL __stdcall Mine_CloseFigure(HDC a0)
{
    _PrintEnter("CloseFigure(%p)\n", a0);

    BOOL rv = 0;
    __try {
        rv = Real_CloseFigure(a0);
    } __finally {
        _PrintExit("CloseFigure() -> %x\n", rv);
    };
    return rv;
}

BOOL __stdcall Mine_CloseHandle(HANDLE a0)
{
    _PrintEnter("CloseHandle(%p)\n", a0);

    BOOL rv = 0;
    __try {
        rv = Real_CloseHandle(a0);
    } __finally {
        _PrintExit("CloseHandle() -> %x\n", rv);
    };
    return rv;
}

HMETAFILE __stdcall Mine_CloseMetaFile(HDC a0)
{
    _PrintEnter("CloseMetaFile(%p)\n", a0);

    HMETAFILE rv = 0;
    __try {
        rv = Real_CloseMetaFile(a0);
    } __finally {
        _PrintExit("CloseMetaFile() -> %p\n", rv);
    };
    return rv;
}

BOOL __stdcall Mine_CloseWindow(HWND a0)
{
    _PrintEnter("CloseWindow(%p)\n", a0);

    BOOL rv = 0;
    __try {
        rv = Real_CloseWindow(a0);
    } __finally {
        _PrintExit("CloseWindow() -> %x\n", rv);
    };
    return rv;
}

BOOL __stdcall Mine_CloseWindowStation(HWINSTA a0)
{
    _PrintEnter("CloseWindowStation(%p)\n", a0);

    BOOL rv = 0;
    __try {
        rv = Real_CloseWindowStation(a0);
    } __finally {
        _PrintExit("CloseWindowStation() -> %x\n", rv);
    };
    return rv;
}

ULONG __stdcall Mine_CoAddRefServerProcess(void)
{
    _PrintEnter("CoAddRefServerProcess()\n");

    ULONG rv = 0;
    __try {
        rv = Real_CoAddRefServerProcess();
    } __finally {
        _PrintExit("CoAddRefServerProcess() -> %x\n", rv);
    };
    return rv;
}

DWORD __stdcall Mine_CoBuildVersion(void)
{
    _PrintEnter("CoBuildVersion()\n");

    DWORD rv = 0;
    __try {
        rv = Real_CoBuildVersion();
    } __finally {
        _PrintExit("CoBuildVersion() -> %x\n", rv);
    };
    return rv;
}

HRESULT __stdcall Mine_CoCopyProxy(IUnknown* a0,
                                   IUnknown** a1)
{
    _PrintEnter("CoCopyProxy(%p,%p)\n", a0, a1);

    HRESULT rv = 0;
    __try {
        rv = Real_CoCopyProxy(a0, a1);
    } __finally {
        _PrintExit("CoCopyProxy(,) -> %x\n", rv);
    };
    return rv;
}

HRESULT __stdcall Mine_CoCreateFreeThreadedMarshaler(LPUNKNOWN a0,
                                                     LPUNKNOWN* a1)
{
    _PrintEnter("CoCreateFreeThreadedMarshaler(%p,%p)\n", a0, a1);

    HRESULT rv = 0;
    __try {
        rv = Real_CoCreateFreeThreadedMarshaler(a0, a1);
    } __finally {
        _PrintExit("CoCreateFreeThreadedMarshaler(,) -> %x\n", rv);
    };
    return rv;
}

HRESULT __stdcall Mine_CoCreateGuid(GUID* a0)
{
    _PrintEnter("CoCreateGuid(%p)\n", a0);

    HRESULT rv = 0;
    __try {
        rv = Real_CoCreateGuid(a0);
    } __finally {
        _PrintExit("CoCreateGuid() -> %x\n", rv);
    };
    return rv;
}

HRESULT __stdcall Mine_CoCreateInstance(CONST IID& a0,
                                        LPUNKNOWN a1,
                                        DWORD a2,
                                        CONST IID& a3,
                                        LPVOID* a4)
{
    _PrintEnter("CoCreateInstance(%p,%p,%p,%p,%p)\n", a0, a1, a2, a3, a4);

    HRESULT rv = 0;
    __try {
        rv = Real_CoCreateInstance(a0, a1, a2, a3, a4);
    } __finally {
        _PrintExit("CoCreateInstance(,,,,) -> %x\n", rv);
    };
    return rv;
}

HRESULT __stdcall Mine_CoCreateInstanceEx(CONST IID& a0,
                                          IUnknown* a1,
                                          DWORD a2,
                                          COSERVERINFO* a3,
                                          DWORD a4,
                                          MULTI_QI* a5)
{
    _PrintEnter("CoCreateInstanceEx(%p,%p,%p,%p,%p,%p)\n", a0, a1, a2, a3, a4, a5);

    HRESULT rv = 0;
    __try {
        rv = Real_CoCreateInstanceEx(a0, a1, a2, a3, a4, a5);
    } __finally {
        _PrintExit("CoCreateInstanceEx(,,,,,) -> %x\n", rv);
    };
    return rv;
}

HRESULT __stdcall Mine_CoDisconnectObject(LPUNKNOWN a0,
                                          DWORD a1)
{
    _PrintEnter("CoDisconnectObject(%p,%p)\n", a0, a1);

    HRESULT rv = 0;
    __try {
        rv = Real_CoDisconnectObject(a0, a1);
    } __finally {
        _PrintExit("CoDisconnectObject(,) -> %x\n", rv);
    };
    return rv;
}

BOOL __stdcall Mine_CoDosDateTimeToFileTime(WORD a0,
                                            WORD a1,
                                            FILETIME* a2)
{
    _PrintEnter("CoDosDateTimeToFileTime(%p,%p,%p)\n", a0, a1, a2);

    BOOL rv = 0;
    __try {
        rv = Real_CoDosDateTimeToFileTime(a0, a1, a2);
    } __finally {
        _PrintExit("CoDosDateTimeToFileTime(,,) -> %x\n", rv);
    };
    return rv;
}

HRESULT __stdcall Mine_CoFileTimeNow(FILETIME* a0)
{
    _PrintEnter("CoFileTimeNow(%p)\n", a0);

    HRESULT rv = 0;
    __try {
        rv = Real_CoFileTimeNow(a0);
    } __finally {
        _PrintExit("CoFileTimeNow() -> %x\n", rv);
    };
    return rv;
}

BOOL __stdcall Mine_CoFileTimeToDosDateTime(FILETIME* a0,
                                            LPWORD a1,
                                            LPWORD a2)
{
    _PrintEnter("CoFileTimeToDosDateTime(%p,%p,%p)\n", a0, a1, a2);

    BOOL rv = 0;
    __try {
        rv = Real_CoFileTimeToDosDateTime(a0, a1, a2);
    } __finally {
        _PrintExit("CoFileTimeToDosDateTime(,,) -> %x\n", rv);
    };
    return rv;
}

void __stdcall Mine_CoFreeAllLibraries(void)
{
    _PrintEnter("CoFreeAllLibraries()\n");

    __try {
        Real_CoFreeAllLibraries();
    } __finally {
        _PrintExit("CoFreeAllLibraries() ->\n");
    };
}

void __stdcall Mine_CoFreeLibrary(HINSTANCE a0)
{
    _PrintEnter("CoFreeLibrary(%p)\n", a0);

    __try {
        Real_CoFreeLibrary(a0);
    } __finally {
        _PrintExit("CoFreeLibrary() ->\n");
    };
}

void __stdcall Mine_CoFreeUnusedLibraries(void)
{
    _PrintEnter("CoFreeUnusedLibraries()\n");

    __try {
        Real_CoFreeUnusedLibraries();
    } __finally {
        _PrintExit("CoFreeUnusedLibraries() ->\n");
    };
}

HRESULT __stdcall Mine_CoGetCallContext(CONST IID& a0,
                                        void** a1)
{
    _PrintEnter("CoGetCallContext(%p,%p)\n", a0, a1);

    HRESULT rv = 0;
    __try {
        rv = Real_CoGetCallContext(a0, a1);
    } __finally {
        _PrintExit("CoGetCallContext(,) -> %x\n", rv);
    };
    return rv;
}

HRESULT __stdcall Mine_CoGetClassObject(CONST IID& a0,
                                        DWORD a1,
                                        LPVOID a2,
                                        CONST IID& a3,
                                        LPVOID* a4)
{
    _PrintEnter("CoGetClassObject(%p,%p,%p,%p,%p)\n", a0, a1, a2, a3, a4);

    HRESULT rv = 0;
    __try {
        rv = Real_CoGetClassObject(a0, a1, a2, a3, a4);
    } __finally {
        _PrintExit("CoGetClassObject(,,,,) -> %x\n", rv);
    };
    return rv;
}

DWORD __stdcall Mine_CoGetCurrentProcess(void)
{
    _PrintEnter("CoGetCurrentProcess()\n");

    DWORD rv = 0;
    __try {
        rv = Real_CoGetCurrentProcess();
    } __finally {
        _PrintExit("CoGetCurrentProcess() -> %x\n", rv);
    };
    return rv;
}

HRESULT __stdcall Mine_CoGetInstanceFromFile(COSERVERINFO* a0,
                                             CLSID* a1,
                                             IUnknown* a2,
                                             DWORD a3,
                                             DWORD a4,
                                             OLECHAR* a5,
                                             DWORD a6,
                                             MULTI_QI* a7)
{
    _PrintEnter("CoGetInstanceFromFile(%p,%p,%p,%p,%p,%p,%p,%p)\n", a0, a1, a2, a3, a4, a5, a6, a7);

    HRESULT rv = 0;
    __try {
        rv = Real_CoGetInstanceFromFile(a0, a1, a2, a3, a4, a5, a6, a7);
    } __finally {
        _PrintExit("CoGetInstanceFromFile(,,,,,,,) -> %x\n", rv);
    };
    return rv;
}

HRESULT __stdcall Mine_CoGetInstanceFromIStorage(COSERVERINFO* a0,
                                                 CLSID* a1,
                                                 IUnknown* a2,
                                                 DWORD a3,
                                                 IStorage* a4,
                                                 DWORD a5,
                                                 MULTI_QI* a6)
{
    _PrintEnter("CoGetInstanceFromIStorage(%p,%p,%p,%p,%p,%p,%p)\n", a0, a1, a2, a3, a4, a5, a6);

    HRESULT rv = 0;
    __try {
        rv = Real_CoGetInstanceFromIStorage(a0, a1, a2, a3, a4, a5, a6);
    } __finally {
        _PrintExit("CoGetInstanceFromIStorage(,,,,,,) -> %x\n", rv);
    };
    return rv;
}

HRESULT __stdcall Mine_CoGetInterfaceAndReleaseStream(LPSTREAM a0,
                                                      CONST IID& a1,
                                                      LPVOID* a2)
{
    _PrintEnter("CoGetInterfaceAndReleaseStream(%p,%p,%p)\n", a0, a1, a2);

    HRESULT rv = 0;
    __try {
        rv = Real_CoGetInterfaceAndReleaseStream(a0, a1, a2);
    } __finally {
        _PrintExit("CoGetInterfaceAndReleaseStream(,,) -> %x\n", rv);
    };
    return rv;
}

HRESULT __stdcall Mine_CoGetMalloc(DWORD a0,
                                   IMalloc** a1)
{
    _PrintEnter("CoGetMalloc(%p,%p)\n", a0, a1);

    HRESULT rv = 0;
    __try {
        rv = Real_CoGetMalloc(a0, a1);
    } __finally {
        _PrintExit("CoGetMalloc(,) -> %x\n", rv);
    };
    return rv;
}

HRESULT __stdcall Mine_CoGetMarshalSizeMax(ULONG* a0,
                                           CONST IID& a1,
                                           LPUNKNOWN a2,
                                           DWORD a3,
                                           LPVOID a4,
                                           DWORD a5)
{
    _PrintEnter("CoGetMarshalSizeMax(%p,%p,%p,%p,%p,%p)\n", a0, a1, a2, a3, a4, a5);

    HRESULT rv = 0;
    __try {
        rv = Real_CoGetMarshalSizeMax(a0, a1, a2, a3, a4, a5);
    } __finally {
        _PrintExit("CoGetMarshalSizeMax(,,,,,) -> %x\n", rv);
    };
    return rv;
}

HRESULT __stdcall Mine_CoGetObject(LPCWSTR a0,
                                   BIND_OPTS* a1,
                                   CONST IID& a2,
                                   void** a3)
{
    _PrintEnter("CoGetObject(%p,%p,%p,%p)\n", a0, a1, a2, a3);

    HRESULT rv = 0;
    __try {
        rv = Real_CoGetObject(a0, a1, a2, a3);
    } __finally {
        _PrintExit("CoGetObject(,,,) -> %x\n", rv);
    };
    return rv;
}

HRESULT __stdcall Mine_CoGetPSClsid(CONST IID& a0,
                                    CLSID* a1)
{
    _PrintEnter("CoGetPSClsid(%p,%p)\n", a0, a1);

    HRESULT rv = 0;
    __try {
        rv = Real_CoGetPSClsid(a0, a1);
    } __finally {
        _PrintExit("CoGetPSClsid(,) -> %x\n", rv);
    };
    return rv;
}

HRESULT __stdcall Mine_CoGetStandardMarshal(CONST IID& a0,
                                            LPUNKNOWN a1,
                                            DWORD a2,
                                            LPVOID a3,
                                            DWORD a4,
                                            IMarshal** a5)
{
    _PrintEnter("CoGetStandardMarshal(%p,%p,%p,%p,%p,%p)\n", a0, a1, a2, a3, a4, a5);

    HRESULT rv = 0;
    __try {
        rv = Real_CoGetStandardMarshal(a0, a1, a2, a3, a4, a5);
    } __finally {
        _PrintExit("CoGetStandardMarshal(,,,,,) -> %x\n", rv);
    };
    return rv;
}

HRESULT __stdcall Mine_CoGetStdMarshalEx(LPUNKNOWN a0,
                                         DWORD a1,
                                         LPUNKNOWN* a2)
{
    _PrintEnter("CoGetStdMarshalEx(%p,%p,%p)\n", a0, a1, a2);

    HRESULT rv = 0;
    __try {
        rv = Real_CoGetStdMarshalEx(a0, a1, a2);
    } __finally {
        _PrintExit("CoGetStdMarshalEx(,,) -> %x\n", rv);
    };
    return rv;
}

HRESULT __stdcall Mine_CoGetTreatAsClass(CONST IID& a0,
                                         LPGUID a1)
{
    _PrintEnter("CoGetTreatAsClass(%p,%p)\n", a0, a1);

    HRESULT rv = 0;
    __try {
        rv = Real_CoGetTreatAsClass(a0, a1);
    } __finally {
        _PrintExit("CoGetTreatAsClass(,) -> %x\n", rv);
    };
    return rv;
}

HRESULT __stdcall Mine_CoImpersonateClient(void)
{
    _PrintEnter("CoImpersonateClient()\n");

    HRESULT rv = 0;
    __try {
        rv = Real_CoImpersonateClient();
    } __finally {
        _PrintExit("CoImpersonateClient() -> %x\n", rv);
    };
    return rv;
}

HRESULT __stdcall Mine_CoInitialize(LPVOID a0)
{
    _PrintEnter("CoInitialize(%p)\n", a0);

    HRESULT rv = 0;
    __try {
        rv = Real_CoInitialize(a0);
    } __finally {
        _PrintExit("CoInitialize() -> %x\n", rv);
    };
    return rv;
}

HRESULT __stdcall Mine_CoInitializeEx(LPVOID a0,
                                      DWORD a1)
{
    _PrintEnter("CoInitializeEx(%p,%p)\n", a0, a1);

    HRESULT rv = 0;
    __try {
        rv = Real_CoInitializeEx(a0, a1);
    } __finally {
        _PrintExit("CoInitializeEx(,) -> %x\n", rv);
    };
    return rv;
}

HRESULT __stdcall Mine_CoInitializeSecurity(PSECURITY_DESCRIPTOR a0,
                                            LONG a1,
                                            SOLE_AUTHENTICATION_SERVICE* a2,
                                            void* a3,
                                            DWORD a4,
                                            DWORD a5,
                                            void* a6,
                                            DWORD a7,
                                            void* a8)
{
    _PrintEnter("CoInitializeSecurity(%p,%p,%p,%p,%p,%p,%p,%p,%p)\n", a0, a1, a2, a3, a4, a5, a6, a7, a8);

    HRESULT rv = 0;
    __try {
        rv = Real_CoInitializeSecurity(a0, a1, a2, a3, a4, a5, a6, a7, a8);
    } __finally {
        _PrintExit("CoInitializeSecurity(,,,,,,,,) -> %x\n", rv);
    };
    return rv;
}

BOOL __stdcall Mine_CoIsHandlerConnected(LPUNKNOWN a0)
{
    _PrintEnter("CoIsHandlerConnected(%p)\n", a0);

    BOOL rv = 0;
    __try {
        rv = Real_CoIsHandlerConnected(a0);
    } __finally {
        _PrintExit("CoIsHandlerConnected() -> %x\n", rv);
    };
    return rv;
}

BOOL __stdcall Mine_CoIsOle1Class(CONST IID& a0)
{
    _PrintEnter("CoIsOle1Class(%p)\n", a0);

    BOOL rv = 0;
    __try {
        rv = Real_CoIsOle1Class(a0);
    } __finally {
        _PrintExit("CoIsOle1Class() -> %x\n", rv);
    };
    return rv;
}

HINSTANCE __stdcall Mine_CoLoadLibrary(LPOLESTR a0,
                                       BOOL a1)
{
    _PrintEnter("CoLoadLibrary(%p,%p)\n", a0, a1);

    HINSTANCE rv = 0;
    __try {
        rv = Real_CoLoadLibrary(a0, a1);
    } __finally {
        _PrintExit("CoLoadLibrary(,) -> %p\n", rv);
    };
    return rv;
}

HRESULT __stdcall Mine_CoLockObjectExternal(LPUNKNOWN a0,
                                            BOOL a1,
                                            BOOL a2)
{
    _PrintEnter("CoLockObjectExternal(%p,%p,%p)\n", a0, a1, a2);

    HRESULT rv = 0;
    __try {
        rv = Real_CoLockObjectExternal(a0, a1, a2);
    } __finally {
        _PrintExit("CoLockObjectExternal(,,) -> %x\n", rv);
    };
    return rv;
}

HRESULT __stdcall Mine_CoMarshalHresult(LPSTREAM a0,
                                        HRESULT a1)
{
    _PrintEnter("CoMarshalHresult(%p,%p)\n", a0, a1);

    HRESULT rv = 0;
    __try {
        rv = Real_CoMarshalHresult(a0, a1);
    } __finally {
        _PrintExit("CoMarshalHresult(,) -> %x\n", rv);
    };
    return rv;
}

HRESULT __stdcall Mine_CoMarshalInterThreadInterfaceInStream(CONST IID& a0,
                                                             LPUNKNOWN a1,
                                                             LPSTREAM* a2)
{
    _PrintEnter("CoMarshalInterThreadInterfaceInStream(%p,%p,%p)\n", a0, a1, a2);

    HRESULT rv = 0;
    __try {
        rv = Real_CoMarshalInterThreadInterfaceInStream(a0, a1, a2);
    } __finally {
        _PrintExit("CoMarshalInterThreadInterfaceInStream(,,) -> %x\n", rv);
    };
    return rv;
}

HRESULT __stdcall Mine_CoMarshalInterface(LPSTREAM a0,
                                          CONST IID& a1,
                                          LPUNKNOWN a2,
                                          DWORD a3,
                                          LPVOID a4,
                                          DWORD a5)
{
    _PrintEnter("CoMarshalInterface(%p,%p,%p,%p,%p,%p)\n", a0, a1, a2, a3, a4, a5);

    HRESULT rv = 0;
    __try {
        rv = Real_CoMarshalInterface(a0, a1, a2, a3, a4, a5);
    } __finally {
        _PrintExit("CoMarshalInterface(,,,,,) -> %x\n", rv);
    };
    return rv;
}

HRESULT __stdcall Mine_CoQueryAuthenticationServices(DWORD* a0,
                                                     SOLE_AUTHENTICATION_SERVICE** a1)
{
    _PrintEnter("CoQueryAuthenticationServices(%p,%p)\n", a0, a1);

    HRESULT rv = 0;
    __try {
        rv = Real_CoQueryAuthenticationServices(a0, a1);
    } __finally {
        _PrintExit("CoQueryAuthenticationServices(,) -> %x\n", rv);
    };
    return rv;
}

HRESULT __stdcall Mine_CoQueryClientBlanket(DWORD* a0,
                                            DWORD* a1,
                                            OLECHAR** a2,
                                            DWORD* a3,
                                            DWORD* a4,
                                            RPC_AUTHZ_HANDLE* a5,
                                            DWORD* a6)
{
    _PrintEnter("CoQueryClientBlanket(%p,%p,%p,%p,%p,%p,%p)\n", a0, a1, a2, a3, a4, a5, a6);

    HRESULT rv = 0;
    __try {
        rv = Real_CoQueryClientBlanket(a0, a1, a2, a3, a4, a5, a6);
    } __finally {
        _PrintExit("CoQueryClientBlanket(,,,,,,) -> %x\n", rv);
    };
    return rv;
}

HRESULT __stdcall Mine_CoQueryProxyBlanket(IUnknown* a0,
                                           DWORD* a1,
                                           DWORD* a2,
                                           OLECHAR** a3,
                                           DWORD* a4,
                                           DWORD* a5,
                                           RPC_AUTH_IDENTITY_HANDLE* a6,
                                           DWORD* a7)
{
    _PrintEnter("CoQueryProxyBlanket(%p,%p,%p,%p,%p,%p,%p,%p)\n", a0, a1, a2, a3, a4, a5, a6, a7);

    HRESULT rv = 0;
    __try {
        rv = Real_CoQueryProxyBlanket(a0, a1, a2, a3, a4, a5, a6, a7);
    } __finally {
        _PrintExit("CoQueryProxyBlanket(,,,,,,,) -> %x\n", rv);
    };
    return rv;
}

HRESULT __stdcall Mine_CoRegisterChannelHook(CONST GUID& a0,
                                             IChannelHook* a1)
{
    _PrintEnter("CoRegisterChannelHook(%p,%p)\n", a0, a1);

    HRESULT rv = 0;
    __try {
        rv = Real_CoRegisterChannelHook(a0, a1);
    } __finally {
        _PrintExit("CoRegisterChannelHook(,) -> %x\n", rv);
    };
    return rv;
}

HRESULT __stdcall Mine_CoRegisterClassObject(CONST IID& a0,
                                             LPUNKNOWN a1,
                                             DWORD a2,
                                             DWORD a3,
                                             LPDWORD a4)
{
    _PrintEnter("CoRegisterClassObject(%p,%p,%p,%p,%p)\n", a0, a1, a2, a3, a4);

    HRESULT rv = 0;
    __try {
        rv = Real_CoRegisterClassObject(a0, a1, a2, a3, a4);
    } __finally {
        _PrintExit("CoRegisterClassObject(,,,,) -> %x\n", rv);
    };
    return rv;
}

HRESULT __stdcall Mine_CoRegisterMallocSpy(IMallocSpy* a0)
{
    _PrintEnter("CoRegisterMallocSpy(%p)\n", a0);

    HRESULT rv = 0;
    __try {
        rv = Real_CoRegisterMallocSpy(a0);
    } __finally {
        _PrintExit("CoRegisterMallocSpy() -> %x\n", rv);
    };
    return rv;
}

HRESULT __stdcall Mine_CoRegisterMessageFilter(LPMESSAGEFILTER a0,
                                               LPMESSAGEFILTER* a1)
{
    _PrintEnter("CoRegisterMessageFilter(%p,%p)\n", a0, a1);

    HRESULT rv = 0;
    __try {
        rv = Real_CoRegisterMessageFilter(a0, a1);
    } __finally {
        _PrintExit("CoRegisterMessageFilter(,) -> %x\n", rv);
    };
    return rv;
}

HRESULT __stdcall Mine_CoRegisterPSClsid(CONST IID& a0,
                                         CONST IID& a1)
{
    _PrintEnter("CoRegisterPSClsid(%p,%p)\n", a0, a1);

    HRESULT rv = 0;
    __try {
        rv = Real_CoRegisterPSClsid(a0, a1);
    } __finally {
        _PrintExit("CoRegisterPSClsid(,) -> %x\n", rv);
    };
    return rv;
}

HRESULT __stdcall Mine_CoRegisterSurrogate(LPSURROGATE a0)
{
    _PrintEnter("CoRegisterSurrogate(%p)\n", a0);

    HRESULT rv = 0;
    __try {
        rv = Real_CoRegisterSurrogate(a0);
    } __finally {
        _PrintExit("CoRegisterSurrogate() -> %x\n", rv);
    };
    return rv;
}

HRESULT __stdcall Mine_CoReleaseMarshalData(LPSTREAM a0)
{
    _PrintEnter("CoReleaseMarshalData(%p)\n", a0);

    HRESULT rv = 0;
    __try {
        rv = Real_CoReleaseMarshalData(a0);
    } __finally {
        _PrintExit("CoReleaseMarshalData() -> %x\n", rv);
    };
    return rv;
}

ULONG __stdcall Mine_CoReleaseServerProcess(void)
{
    _PrintEnter("CoReleaseServerProcess()\n");

    ULONG rv = 0;
    __try {
        rv = Real_CoReleaseServerProcess();
    } __finally {
        _PrintExit("CoReleaseServerProcess() -> %x\n", rv);
    };
    return rv;
}

HRESULT __stdcall Mine_CoResumeClassObjects(void)
{
    _PrintEnter("CoResumeClassObjects()\n");

    HRESULT rv = 0;
    __try {
        rv = Real_CoResumeClassObjects();
    } __finally {
        _PrintExit("CoResumeClassObjects() -> %x\n", rv);
    };
    return rv;
}

HRESULT __stdcall Mine_CoRevertToSelf(void)
{
    _PrintEnter("CoRevertToSelf()\n");

    HRESULT rv = 0;
    __try {
        rv = Real_CoRevertToSelf();
    } __finally {
        _PrintExit("CoRevertToSelf() -> %x\n", rv);
    };
    return rv;
}

HRESULT __stdcall Mine_CoRevokeClassObject(DWORD a0)
{
    _PrintEnter("CoRevokeClassObject(%p)\n", a0);

    HRESULT rv = 0;
    __try {
        rv = Real_CoRevokeClassObject(a0);
    } __finally {
        _PrintExit("CoRevokeClassObject() -> %x\n", rv);
    };
    return rv;
}

HRESULT __stdcall Mine_CoRevokeMallocSpy(void)
{
    _PrintEnter("CoRevokeMallocSpy()\n");

    HRESULT rv = 0;
    __try {
        rv = Real_CoRevokeMallocSpy();
    } __finally {
        _PrintExit("CoRevokeMallocSpy() -> %x\n", rv);
    };
    return rv;
}

HRESULT __stdcall Mine_CoSetProxyBlanket(IUnknown* a0,
                                         DWORD a1,
                                         DWORD a2,
                                         OLECHAR* a3,
                                         DWORD a4,
                                         DWORD a5,
                                         RPC_AUTH_IDENTITY_HANDLE a6,
                                         DWORD a7)
{
    _PrintEnter("CoSetProxyBlanket(%p,%p,%p,%p,%p,%p,%p,%p)\n", a0, a1, a2, a3, a4, a5, a6, a7);

    HRESULT rv = 0;
    __try {
        rv = Real_CoSetProxyBlanket(a0, a1, a2, a3, a4, a5, a6, a7);
    } __finally {
        _PrintExit("CoSetProxyBlanket(,,,,,,,) -> %x\n", rv);
    };
    return rv;
}

HRESULT __stdcall Mine_CoSuspendClassObjects(void)
{
    _PrintEnter("CoSuspendClassObjects()\n");

    HRESULT rv = 0;
    __try {
        rv = Real_CoSuspendClassObjects();
    } __finally {
        _PrintExit("CoSuspendClassObjects() -> %x\n", rv);
    };
    return rv;
}

HRESULT __stdcall Mine_CoSwitchCallContext(IUnknown* a0,
                                           IUnknown** a1)
{
    _PrintEnter("CoSwitchCallContext(%p,%p)\n", a0, a1);

    HRESULT rv = 0;
    __try {
        rv = Real_CoSwitchCallContext(a0, a1);
    } __finally {
        _PrintExit("CoSwitchCallContext(,) -> %x\n", rv);
    };
    return rv;
}

LPVOID __stdcall Mine_CoTaskMemAlloc(SIZE_T a0)
{
    _PrintEnter("CoTaskMemAlloc(%p)\n", a0);

    LPVOID rv = 0;
    __try {
        rv = Real_CoTaskMemAlloc(a0);
    } __finally {
        _PrintExit("CoTaskMemAlloc() -> %p\n", rv);
    };
    return rv;
}

void __stdcall Mine_CoTaskMemFree(LPVOID a0)
{
    _PrintEnter("CoTaskMemFree(%p)\n", a0);

    __try {
        Real_CoTaskMemFree(a0);
    } __finally {
        _PrintExit("CoTaskMemFree() ->\n");
    };
}

LPVOID __stdcall Mine_CoTaskMemRealloc(LPVOID a0,
                                       SIZE_T a1)
{
    _PrintEnter("CoTaskMemRealloc(%p,%p)\n", a0, a1);

    LPVOID rv = 0;
    __try {
        rv = Real_CoTaskMemRealloc(a0, a1);
    } __finally {
        _PrintExit("CoTaskMemRealloc(,) -> %p\n", rv);
    };
    return rv;
}

HRESULT __stdcall Mine_CoTreatAsClass(CONST IID& a0,
                                      CONST IID& a1)
{
    _PrintEnter("CoTreatAsClass(%p,%p)\n", a0, a1);

    HRESULT rv = 0;
    __try {
        rv = Real_CoTreatAsClass(a0, a1);
    } __finally {
        _PrintExit("CoTreatAsClass(,) -> %x\n", rv);
    };
    return rv;
}

void __stdcall Mine_CoUninitialize(void)
{
    _PrintEnter("CoUninitialize()\n");

    __try {
        Real_CoUninitialize();
    } __finally {
        _PrintExit("CoUninitialize() ->\n");
    };
}

HRESULT __stdcall Mine_CoUnmarshalHresult(LPSTREAM a0,
                                          HRESULT* a1)
{
    _PrintEnter("CoUnmarshalHresult(%p,%p)\n", a0, a1);

    HRESULT rv = 0;
    __try {
        rv = Real_CoUnmarshalHresult(a0, a1);
    } __finally {
        _PrintExit("CoUnmarshalHresult(,) -> %x\n", rv);
    };
    return rv;
}

HRESULT __stdcall Mine_CoUnmarshalInterface(LPSTREAM a0,
                                            CONST IID& a1,
                                            LPVOID* a2)
{
    _PrintEnter("CoUnmarshalInterface(%p,%p,%p)\n", a0, a1, a2);

    HRESULT rv = 0;
    __try {
        rv = Real_CoUnmarshalInterface(a0, a1, a2);
    } __finally {
        _PrintExit("CoUnmarshalInterface(,,) -> %x\n", rv);
    };
    return rv;
}

BOOL __stdcall Mine_ColorMatchToTarget(HDC a0,
                                       HDC a1,
                                       DWORD a2)
{
    _PrintEnter("ColorMatchToTarget(%p,%p,%p)\n", a0, a1, a2);

    BOOL rv = 0;
    __try {
        rv = Real_ColorMatchToTarget(a0, a1, a2);
    } __finally {
        _PrintExit("ColorMatchToTarget(,,) -> %x\n", rv);
    };
    return rv;
}

int __stdcall Mine_CombineRgn(HRGN a0,
                              HRGN a1,
                              HRGN a2,
                              int a3)
{
    _PrintEnter("CombineRgn(%p,%p,%p,%p)\n", a0, a1, a2, a3);

    int rv = 0;
    __try {
        rv = Real_CombineRgn(a0, a1, a2, a3);
    } __finally {
        _PrintExit("CombineRgn(,,,) -> %x\n", rv);
    };
    return rv;
}

BOOL __stdcall Mine_CombineTransform(XFORM* a0,
                                     XFORM* a1,
                                     XFORM* a2)
{
    _PrintEnter("CombineTransform(%p,%p,%p)\n", a0, a1, a2);

    BOOL rv = 0;
    __try {
        rv = Real_CombineTransform(a0, a1, a2);
    } __finally {
        _PrintExit("CombineTransform(,,) -> %x\n", rv);
    };
    return rv;
}

BOOL __stdcall Mine_CommConfigDialogA(LPCSTR a0,
                                      HWND a1,
                                      LPCOMMCONFIG a2)
{
    _PrintEnter("CommConfigDialogA(%hs,%p,%p)\n", a0, a1, a2);

    BOOL rv = 0;
    __try {
        rv = Real_CommConfigDialogA(a0, a1, a2);
    } __finally {
        _PrintExit("CommConfigDialogA(,,) -> %x\n", rv);
    };
    return rv;
}

BOOL __stdcall Mine_CommConfigDialogW(LPCWSTR a0,
                                      HWND a1,
                                      LPCOMMCONFIG a2)
{
    _PrintEnter("CommConfigDialogW(%ls,%p,%p)\n", a0, a1, a2);

    BOOL rv = 0;
    __try {
        rv = Real_CommConfigDialogW(a0, a1, a2);
    } __finally {
        _PrintExit("CommConfigDialogW(,,) -> %x\n", rv);
    };
    return rv;
}

LONG __stdcall Mine_CompareFileTime(FILETIME* a0,
                                    FILETIME* a1)
{
    _PrintEnter("CompareFileTime(%p,%p)\n", a0, a1);

    LONG rv = 0;
    __try {
        rv = Real_CompareFileTime(a0, a1);
    } __finally {
        _PrintExit("CompareFileTime(,) -> %x\n", rv);
    };
    return rv;
}

int __stdcall Mine_CompareStringA(LCID a0,
                                  DWORD a1,
                                  LPCSTR a2,
                                  int a3,
                                  LPCSTR a4,
                                  int a5)
{
    _PrintEnter("CompareStringA(%p,%p,%hs,%p,%hs,%p)\n", a0, a1, a2, a3, a4, a5);

    int rv = 0;
    __try {
        rv = Real_CompareStringA(a0, a1, a2, a3, a4, a5);
    } __finally {
        _PrintExit("CompareStringA(,,,,,) -> %x\n", rv);
    };
    return rv;
}

int __stdcall Mine_CompareStringW(LCID a0,
                                  DWORD a1,
                                  LPCWSTR a2,
                                  int a3,
                                  LPCWSTR a4,
                                  int a5)
{
    _PrintEnter("CompareStringW(%p,%p,%ls,%p,%ls,%p)\n", a0, a1, a2, a3, a4, a5);

    int rv = 0;
    __try {
        rv = Real_CompareStringW(a0, a1, a2, a3, a4, a5);
    } __finally {
        _PrintExit("CompareStringW(,,,,,) -> %x\n", rv);
    };
    return rv;
}

BOOL __stdcall Mine_ConnectNamedPipe(HANDLE a0,
                                     LPOVERLAPPED a1)
{
    _PrintEnter("ConnectNamedPipe(%p,%p)\n", a0, a1);

    BOOL rv = 0;
    __try {
        rv = Real_ConnectNamedPipe(a0, a1);
    } __finally {
        _PrintExit("ConnectNamedPipe(,) -> %x\n", rv);
    };
    return rv;
}

#if !defined(DETOURS_ARM)
BOOL __stdcall Mine_ContinueDebugEvent(DWORD a0,
                                       DWORD a1,
                                       DWORD a2)
{
    _PrintEnter("ContinueDebugEvent(%p,%p,%p)\n", a0, a1, a2);

    BOOL rv = 0;
    __try {
        rv = Real_ContinueDebugEvent(a0, a1, a2);
    } __finally {
        _PrintExit("ContinueDebugEvent(,,) -> %x\n", rv);
    };
    return rv;
}
#endif // !DETOURS_ARM

LCID __stdcall Mine_ConvertDefaultLocale(LCID a0)
{
    _PrintEnter("ConvertDefaultLocale(%p)\n", a0);

    LCID rv = 0;
    __try {
        rv = Real_ConvertDefaultLocale(a0);
    } __finally {
        _PrintExit("ConvertDefaultLocale() -> %x\n", rv);
    };
    return rv;
}

LPVOID __stdcall Mine_ConvertThreadToFiber(LPVOID a0)
{
    _PrintEnter("ConvertThreadToFiber(%p)\n", a0);

    LPVOID rv = 0;
    __try {
        rv = Real_ConvertThreadToFiber(a0);
    } __finally {
        _PrintExit("ConvertThreadToFiber() -> %p\n", rv);
    };
    return rv;
}

int __stdcall Mine_CopyAcceleratorTableA(HACCEL a0,
                                         ACCEL* a1,
                                         int a2)
{
    _PrintEnter("CopyAcceleratorTableA(%p,%p,%p)\n", a0, a1, a2);

    int rv = 0;
    __try {
        rv = Real_CopyAcceleratorTableA(a0, a1, a2);
    } __finally {
        _PrintExit("CopyAcceleratorTableA(,,) -> %x\n", rv);
    };
    return rv;
}

int __stdcall Mine_CopyAcceleratorTableW(HACCEL a0,
                                         ACCEL* a1,
                                         int a2)
{
    _PrintEnter("CopyAcceleratorTableW(%p,%p,%p)\n", a0, a1, a2);

    int rv = 0;
    __try {
        rv = Real_CopyAcceleratorTableW(a0, a1, a2);
    } __finally {
        _PrintExit("CopyAcceleratorTableW(,,) -> %x\n", rv);
    };
    return rv;
}

HENHMETAFILE __stdcall Mine_CopyEnhMetaFileA(HENHMETAFILE a0,
                                             LPCSTR a1)
{
    _PrintEnter("CopyEnhMetaFileA(%p,%hs)\n", a0, a1);

    HENHMETAFILE rv = 0;
    __try {
        rv = Real_CopyEnhMetaFileA(a0, a1);
    } __finally {
        _PrintExit("CopyEnhMetaFileA(,) -> %p\n", rv);
    };
    return rv;
}

HENHMETAFILE __stdcall Mine_CopyEnhMetaFileW(HENHMETAFILE a0,
                                             LPCWSTR a1)
{
    _PrintEnter("CopyEnhMetaFileW(%p,%ls)\n", a0, a1);

    HENHMETAFILE rv = 0;
    __try {
        rv = Real_CopyEnhMetaFileW(a0, a1);
    } __finally {
        _PrintExit("CopyEnhMetaFileW(,) -> %p\n", rv);
    };
    return rv;
}

BOOL __stdcall Mine_CopyFileA(LPCSTR a0,
                              LPCSTR a1,
                              BOOL a2)
{
    _PrintEnter("CopyFileA(%hs,%hs,%p)\n", a0, a1, a2);

    BOOL rv = 0;
    __try {
        rv = Real_CopyFileA(a0, a1, a2);
    } __finally {
        _PrintExit("CopyFileA(,,) -> %x\n", rv);
    };
    return rv;
}

BOOL __stdcall Mine_CopyFileExA(LPCSTR a0,
                                LPCSTR a1,
                                LPPROGRESS_ROUTINE a2,
                                LPVOID a3,
                                LPBOOL a4,
                                DWORD a5)
{
    _PrintEnter("CopyFileExA(%hs,%hs,%p,%p,%p,%p)\n", a0, a1, a2, a3, a4, a5);

    BOOL rv = 0;
    __try {
        rv = Real_CopyFileExA(a0, a1, a2, a3, a4, a5);
    } __finally {
        _PrintExit("CopyFileExA(,,,,,) -> %x\n", rv);
    };
    return rv;
}

BOOL __stdcall Mine_CopyFileExW(LPCWSTR a0,
                                LPCWSTR a1,
                                LPPROGRESS_ROUTINE a2,
                                LPVOID a3,
                                LPBOOL a4,
                                DWORD a5)
{
    _PrintEnter("CopyFileExW(%ls,%ls,%p,%p,%p,%p)\n", a0, a1, a2, a3, a4, a5);

    BOOL rv = 0;
    __try {
        rv = Real_CopyFileExW(a0, a1, a2, a3, a4, a5);
    } __finally {
        _PrintExit("CopyFileExW(,,,,,) -> %x\n", rv);
    };
    return rv;
}

BOOL __stdcall Mine_CopyFileW(LPCWSTR a0,
                              LPCWSTR a1,
                              BOOL a2)
{
    _PrintEnter("CopyFileW(%ls,%ls,%p)\n", a0, a1, a2);

    BOOL rv = 0;
    __try {
        rv = Real_CopyFileW(a0, a1, a2);
    } __finally {
        _PrintExit("CopyFileW(,,) -> %x\n", rv);
    };
    return rv;
}

HICON __stdcall Mine_CopyIcon(HICON a0)
{
    _PrintEnter("CopyIcon(%p)\n", a0);

    HICON rv = 0;
    __try {
        rv = Real_CopyIcon(a0);
    } __finally {
        _PrintExit("CopyIcon() -> %p\n", rv);
    };
    return rv;
}

HANDLE __stdcall Mine_CopyImage(HANDLE a0,
                                UINT a1,
                                int a2,
                                int a3,
                                UINT a4)
{
    _PrintEnter("CopyImage(%p,%p,%p,%p,%p)\n", a0, a1, a2, a3, a4);

    HANDLE rv = 0;
    __try {
        rv = Real_CopyImage(a0, a1, a2, a3, a4);
    } __finally {
        _PrintExit("CopyImage(,,,,) -> %p\n", rv);
    };
    return rv;
}

HMETAFILE __stdcall Mine_CopyMetaFileA(HMETAFILE a0,
                                       LPCSTR a1)
{
    _PrintEnter("CopyMetaFileA(%p,%hs)\n", a0, a1);

    HMETAFILE rv = 0;
    __try {
        rv = Real_CopyMetaFileA(a0, a1);
    } __finally {
        _PrintExit("CopyMetaFileA(,) -> %p\n", rv);
    };
    return rv;
}

HMETAFILE __stdcall Mine_CopyMetaFileW(HMETAFILE a0,
                                       LPCWSTR a1)
{
    _PrintEnter("CopyMetaFileW(%p,%ls)\n", a0, a1);

    HMETAFILE rv = 0;
    __try {
        rv = Real_CopyMetaFileW(a0, a1);
    } __finally {
        _PrintExit("CopyMetaFileW(,) -> %p\n", rv);
    };
    return rv;
}

BOOL __stdcall Mine_CopyRect(LPRECT a0,
                             RECT* a1)
{
    _PrintEnter("CopyRect(%p,%p)\n", a0, a1);

    BOOL rv = 0;
    __try {
        rv = Real_CopyRect(a0, a1);
    } __finally {
        _PrintExit("CopyRect(,) -> %x\n", rv);
    };
    return rv;
}

int __stdcall Mine_CountClipboardFormats(void)
{
    _PrintEnter("CountClipboardFormats()\n");

    int rv = 0;
    __try {
        rv = Real_CountClipboardFormats();
    } __finally {
        _PrintExit("CountClipboardFormats() -> %x\n", rv);
    };
    return rv;
}

HACCEL __stdcall Mine_CreateAcceleratorTableA(ACCEL* a0,
                                              int a1)
{
    _PrintEnter("CreateAcceleratorTableA(%p,%p)\n", a0, a1);

    HACCEL rv = 0;
    __try {
        rv = Real_CreateAcceleratorTableA(a0, a1);
    } __finally {
        _PrintExit("CreateAcceleratorTableA(,) -> %p\n", rv);
    };
    return rv;
}

HACCEL __stdcall Mine_CreateAcceleratorTableW(ACCEL* a0,
                                              int a1)
{
    _PrintEnter("CreateAcceleratorTableW(%p,%p)\n", a0, a1);

    HACCEL rv = 0;
    __try {
        rv = Real_CreateAcceleratorTableW(a0, a1);
    } __finally {
        _PrintExit("CreateAcceleratorTableW(,) -> %p\n", rv);
    };
    return rv;
}

HRESULT __stdcall Mine_CreateAntiMoniker(IMoniker** a0)
{
    _PrintEnter("CreateAntiMoniker(%p)\n", a0);

    HRESULT rv = 0;
    __try {
        rv = Real_CreateAntiMoniker(a0);
    } __finally {
        _PrintExit("CreateAntiMoniker() -> %x\n", rv);
    };
    return rv;
}

HRESULT __stdcall Mine_CreateBindCtx(DWORD a0,
                                     IBindCtx** a1)
{
    _PrintEnter("CreateBindCtx(%p,%p)\n", a0, a1);

    HRESULT rv = 0;
    __try {
        rv = Real_CreateBindCtx(a0, a1);
    } __finally {
        _PrintExit("CreateBindCtx(,) -> %x\n", rv);
    };
    return rv;
}

HBITMAP __stdcall Mine_CreateBitmap(int a0,
                                    int a1,
                                    UINT a2,
                                    UINT a3,
                                    void* a4)
{
    _PrintEnter("CreateBitmap(%p,%p,%p,%p,%p)\n", a0, a1, a2, a3, a4);

    HBITMAP rv = 0;
    __try {
        rv = Real_CreateBitmap(a0, a1, a2, a3, a4);
    } __finally {
        _PrintExit("CreateBitmap(,,,,) -> %p\n", rv);
    };
    return rv;
}

HBITMAP __stdcall Mine_CreateBitmapIndirect(BITMAP* a0)
{
    _PrintEnter("CreateBitmapIndirect(%p)\n", a0);

    HBITMAP rv = 0;
    __try {
        rv = Real_CreateBitmapIndirect(a0);
    } __finally {
        _PrintExit("CreateBitmapIndirect() -> %p\n", rv);
    };
    return rv;
}

HBRUSH __stdcall Mine_CreateBrushIndirect(LOGBRUSH* a0)
{
    _PrintEnter("CreateBrushIndirect(%p)\n", a0);

    HBRUSH rv = 0;
    __try {
        rv = Real_CreateBrushIndirect(a0);
    } __finally {
        _PrintExit("CreateBrushIndirect() -> %p\n", rv);
    };
    return rv;
}

BOOL __stdcall Mine_CreateCaret(HWND a0,
                                HBITMAP a1,
                                int a2,
                                int a3)
{
    _PrintEnter("CreateCaret(%p,%p,%p,%p)\n", a0, a1, a2, a3);

    BOOL rv = 0;
    __try {
        rv = Real_CreateCaret(a0, a1, a2, a3);
    } __finally {
        _PrintExit("CreateCaret(,,,) -> %x\n", rv);
    };
    return rv;
}

HRESULT __stdcall Mine_CreateClassMoniker(CONST IID& a0,
                                          IMoniker** a1)
{
    _PrintEnter("CreateClassMoniker(%p,%p)\n", a0, a1);

    HRESULT rv = 0;
    __try {
        rv = Real_CreateClassMoniker(a0, a1);
    } __finally {
        _PrintExit("CreateClassMoniker(,) -> %x\n", rv);
    };
    return rv;
}

HCOLORSPACE __stdcall Mine_CreateColorSpaceA(LOGCOLORSPACEA* a0)
{
    _PrintEnter("CreateColorSpaceA(%p)\n", a0);

    HCOLORSPACE rv = 0;
    __try {
        rv = Real_CreateColorSpaceA(a0);
    } __finally {
        _PrintExit("CreateColorSpaceA() -> %p\n", rv);
    };
    return rv;
}

HCOLORSPACE __stdcall Mine_CreateColorSpaceW(LOGCOLORSPACEW* a0)
{
    _PrintEnter("CreateColorSpaceW(%p)\n", a0);

    HCOLORSPACE rv = 0;
    __try {
        rv = Real_CreateColorSpaceW(a0);
    } __finally {
        _PrintExit("CreateColorSpaceW() -> %p\n", rv);
    };
    return rv;
}

HBITMAP __stdcall Mine_CreateCompatibleBitmap(HDC a0,
                                              int a1,
                                              int a2)
{
    _PrintEnter("CreateCompatibleBitmap(%p,%p,%p)\n", a0, a1, a2);

    HBITMAP rv = 0;
    __try {
        rv = Real_CreateCompatibleBitmap(a0, a1, a2);
    } __finally {
        _PrintExit("CreateCompatibleBitmap(,,) -> %p\n", rv);
    };
    return rv;
}

HDC __stdcall Mine_CreateCompatibleDC(HDC a0)
{
    _PrintEnter("CreateCompatibleDC(%p)\n", a0);

    HDC rv = 0;
    __try {
        rv = Real_CreateCompatibleDC(a0);
    } __finally {
        _PrintExit("CreateCompatibleDC() -> %p\n", rv);
    };
    return rv;
}

HANDLE __stdcall Mine_CreateConsoleScreenBuffer(DWORD a0,
                                                DWORD a1,
                                                SECURITY_ATTRIBUTES* a2,
                                                DWORD a3,
                                                LPVOID a4)
{
    _PrintEnter("CreateConsoleScreenBuffer(%p,%p,%p,%p,%p)\n", a0, a1, a2, a3, a4);

    HANDLE rv = 0;
    __try {
        rv = Real_CreateConsoleScreenBuffer(a0, a1, a2, a3, a4);
    } __finally {
        _PrintExit("CreateConsoleScreenBuffer(,,,,) -> %p\n", rv);
    };
    return rv;
}

HCURSOR __stdcall Mine_CreateCursor(HINSTANCE a0,
                                    int a1,
                                    int a2,
                                    int a3,
                                    int a4,
                                    void* a5,
                                    void* a6)
{
    _PrintEnter("CreateCursor(%p,%p,%p,%p,%p,%p,%p)\n", a0, a1, a2, a3, a4, a5, a6);

    HCURSOR rv = 0;
    __try {
        rv = Real_CreateCursor(a0, a1, a2, a3, a4, a5, a6);
    } __finally {
        _PrintExit("CreateCursor(,,,,,,) -> %p\n", rv);
    };
    return rv;
}

HDC __stdcall Mine_CreateDCA(LPCSTR a0,
                             LPCSTR a1,
                             LPCSTR a2,
                             CONST DEVMODEA* a3)
{
    _PrintEnter("CreateDCA(%hs,%hs,%hs,%p)\n", a0, a1, a2, a3);

    HDC rv = 0;
    __try {
        rv = Real_CreateDCA(a0, a1, a2, a3);
    } __finally {
        _PrintExit("CreateDCA(,,,) -> %p\n", rv);
    };
    return rv;
}

HDC __stdcall Mine_CreateDCW(LPCWSTR a0,
                             LPCWSTR a1,
                             LPCWSTR a2,
                             CONST DEVMODEW* a3)
{
    _PrintEnter("CreateDCW(%ls,%ls,%ls,%p)\n", a0, a1, a2, a3);

    HDC rv = 0;
    __try {
        rv = Real_CreateDCW(a0, a1, a2, a3);
    } __finally {
        _PrintExit("CreateDCW(,,,) -> %p\n", rv);
    };
    return rv;
}

HBRUSH __stdcall Mine_CreateDIBPatternBrush(HGLOBAL a0,
                                            UINT a1)
{
    _PrintEnter("CreateDIBPatternBrush(%p,%p)\n", a0, a1);

    HBRUSH rv = 0;
    __try {
        rv = Real_CreateDIBPatternBrush(a0, a1);
    } __finally {
        _PrintExit("CreateDIBPatternBrush(,) -> %p\n", rv);
    };
    return rv;
}

HBRUSH __stdcall Mine_CreateDIBPatternBrushPt(void* a0,
                                              UINT a1)
{
    _PrintEnter("CreateDIBPatternBrushPt(%p,%p)\n", a0, a1);

    HBRUSH rv = 0;
    __try {
        rv = Real_CreateDIBPatternBrushPt(a0, a1);
    } __finally {
        _PrintExit("CreateDIBPatternBrushPt(,) -> %p\n", rv);
    };
    return rv;
}

HBITMAP __stdcall Mine_CreateDIBSection(HDC a0,
                                        BITMAPINFO* a1,
                                        UINT a2,
                                        void** a3,
                                        HANDLE a4,
                                        DWORD a5)
{
    _PrintEnter("CreateDIBSection(%p,%p,%p,%p,%p,%p)\n", a0, a1, a2, a3, a4, a5);

    HBITMAP rv = 0;
    __try {
        rv = Real_CreateDIBSection(a0, a1, a2, a3, a4, a5);
    } __finally {
        _PrintExit("CreateDIBSection(,,,,,) -> %p\n", rv);
    };
    return rv;
}

HBITMAP __stdcall Mine_CreateDIBitmap(HDC a0,
                                      BITMAPINFOHEADER* a1,
                                      DWORD a2,
                                      void* a3,
                                      BITMAPINFO* a4,
                                      UINT a5)
{
    _PrintEnter("CreateDIBitmap(%p,%p,%p,%p,%p,%p)\n", a0, a1, a2, a3, a4, a5);

    HBITMAP rv = 0;
    __try {
        rv = Real_CreateDIBitmap(a0, a1, a2, a3, a4, a5);
    } __finally {
        _PrintExit("CreateDIBitmap(,,,,,) -> %p\n", rv);
    };
    return rv;
}

HRESULT __stdcall Mine_CreateDataAdviseHolder(LPDATAADVISEHOLDER* a0)
{
    _PrintEnter("CreateDataAdviseHolder(%p)\n", a0);

    HRESULT rv = 0;
    __try {
        rv = Real_CreateDataAdviseHolder(a0);
    } __finally {
        _PrintExit("CreateDataAdviseHolder() -> %x\n", rv);
    };
    return rv;
}

HRESULT __stdcall Mine_CreateDataCache(LPUNKNOWN a0,
                                       CONST IID& a1,
                                       CONST IID& a2,
                                       LPVOID* a3)
{
    _PrintEnter("CreateDataCache(%p,%p,%p,%p)\n", a0, a1, a2, a3);

    HRESULT rv = 0;
    __try {
        rv = Real_CreateDataCache(a0, a1, a2, a3);
    } __finally {
        _PrintExit("CreateDataCache(,,,) -> %x\n", rv);
    };
    return rv;
}

#if _MSC_VER < 1300
HDESK __stdcall Mine_CreateDesktopA(LPSTR a0,
                                    LPSTR a1,
                                    LPDEVMODEA a2,
                                    DWORD a3,
                                    ACCESS_MASK a4,
                                    LPSECURITY_ATTRIBUTES a5)
#else
HDESK __stdcall Mine_CreateDesktopA(LPCSTR a0,
                                    LPCSTR a1,
                                    LPDEVMODEA a2,
                                    DWORD a3,
                                    ACCESS_MASK a4,
                                    LPSECURITY_ATTRIBUTES a5)
#endif
{
    _PrintEnter("CreateDesktopA(%hs,%hs,%p,%p,%p,%p)\n", a0, a1, a2, a3, a4, a5);

    HDESK rv = 0;
    __try {
        rv = Real_CreateDesktopA(a0, a1, a2, a3, a4, a5);
    } __finally {
        _PrintExit("CreateDesktopA(,,,,,) -> %p\n", rv);
    };
    return rv;
}

#if _MSC_VER < 1300
HDESK __stdcall Mine_CreateDesktopW(LPWSTR a0, // NT 3.51 and older. NT4?
                                    LPWSTR a1, // NT 3.51 and older. NT4?
                                    LPDEVMODEW a2,
                                    DWORD a3,
                                    ACCESS_MASK a4,
                                    LPSECURITY_ATTRIBUTES a5)
#else
HDESK __stdcall Mine_CreateDesktopW(LPCWSTR a0, // Windows 2000 and newer; NT4?
                                    LPCWSTR a1, // Windows 2000 and newer; NT4?
                                    LPDEVMODEW a2,
                                    DWORD a3,
                                    ACCESS_MASK a4,
                                    LPSECURITY_ATTRIBUTES a5)
#endif
{
    _PrintEnter("CreateDesktopW(%ls,%ls,%p,%p,%p,%p)\n", a0, a1, a2, a3, a4, a5);

    HDESK rv = 0;
    __try {
        rv = Real_CreateDesktopW(a0, a1, a2, a3, a4, a5);
    } __finally {
        _PrintExit("CreateDesktopW(,,,,,) -> %p\n", rv);
    };
    return rv;
}

HWND __stdcall Mine_CreateDialogIndirectParamA(HINSTANCE a0,
                                               LPCDLGTEMPLATEA a1,
                                               HWND a2,
                                               DLGPROC a3,
                                               LPARAM a4)
{
    _PrintEnter("CreateDialogIndirectParamA(%p,%p,%p,%p,%p)\n", a0, a1, a2, a3, a4);

    HWND rv = 0;
    __try {
        rv = Real_CreateDialogIndirectParamA(a0, a1, a2, a3, a4);
    } __finally {
        _PrintExit("CreateDialogIndirectParamA(,,,,) -> %p\n", rv);
    };
    return rv;
}

HWND __stdcall Mine_CreateDialogIndirectParamW(HINSTANCE a0,
                                               LPCDLGTEMPLATEW a1,
                                               HWND a2,
                                               DLGPROC a3,
                                               LPARAM a4)
{
    _PrintEnter("CreateDialogIndirectParamW(%p,%p,%p,%p,%p)\n", a0, a1, a2, a3, a4);

    HWND rv = 0;
    __try {
        rv = Real_CreateDialogIndirectParamW(a0, a1, a2, a3, a4);
    } __finally {
        _PrintExit("CreateDialogIndirectParamW(,,,,) -> %p\n", rv);
    };
    return rv;
}

HWND __stdcall Mine_CreateDialogParamA(HINSTANCE a0,
                                       LPCSTR a1,
                                       HWND a2,
                                       DLGPROC a3,
                                       LPARAM a4)
{
    _PrintEnter("CreateDialogParamA(%p,%hs,%p,%p,%p)\n", a0, a1, a2, a3, a4);

    HWND rv = 0;
    __try {
        rv = Real_CreateDialogParamA(a0, a1, a2, a3, a4);
    } __finally {
        _PrintExit("CreateDialogParamA(,,,,) -> %p\n", rv);
    };
    return rv;
}

HWND __stdcall Mine_CreateDialogParamW(HINSTANCE a0,
                                       LPCWSTR a1,
                                       HWND a2,
                                       DLGPROC a3,
                                       LPARAM a4)
{
    _PrintEnter("CreateDialogParamW(%p,%ls,%p,%p,%p)\n", a0, a1, a2, a3, a4);

    HWND rv = 0;
    __try {
        rv = Real_CreateDialogParamW(a0, a1, a2, a3, a4);
    } __finally {
        _PrintExit("CreateDialogParamW(,,,,) -> %p\n", rv);
    };
    return rv;
}

BOOL __stdcall Mine_CreateDirectoryA(LPCSTR a0,
                                     LPSECURITY_ATTRIBUTES a1)
{
    _PrintEnter("CreateDirectoryA(%hs,%p)\n", a0, a1);

    BOOL rv = 0;
    __try {
        rv = Real_CreateDirectoryA(a0, a1);
    } __finally {
        _PrintExit("CreateDirectoryA(,) -> %x\n", rv);
    };
    return rv;
}

BOOL __stdcall Mine_CreateDirectoryExA(LPCSTR a0,
                                       LPCSTR a1,
                                       LPSECURITY_ATTRIBUTES a2)
{
    _PrintEnter("CreateDirectoryExA(%hs,%hs,%p)\n", a0, a1, a2);

    BOOL rv = 0;
    __try {
        rv = Real_CreateDirectoryExA(a0, a1, a2);
    } __finally {
        _PrintExit("CreateDirectoryExA(,,) -> %x\n", rv);
    };
    return rv;
}

BOOL __stdcall Mine_CreateDirectoryExW(LPCWSTR a0,
                                       LPCWSTR a1,
                                       LPSECURITY_ATTRIBUTES a2)
{
    _PrintEnter("CreateDirectoryExW(%ls,%ls,%p)\n", a0, a1, a2);

    BOOL rv = 0;
    __try {
        rv = Real_CreateDirectoryExW(a0, a1, a2);
    } __finally {
        _PrintExit("CreateDirectoryExW(,,) -> %x\n", rv);
    };
    return rv;
}

BOOL __stdcall Mine_CreateDirectoryW(LPCWSTR a0,
                                     LPSECURITY_ATTRIBUTES a1)
{
    _PrintEnter("CreateDirectoryW(%ls,%p)\n", a0, a1);

    BOOL rv = 0;
    __try {
        rv = Real_CreateDirectoryW(a0, a1);
    } __finally {
        _PrintExit("CreateDirectoryW(,) -> %x\n", rv);
    };
    return rv;
}

HBITMAP __stdcall Mine_CreateDiscardableBitmap(HDC a0,
                                               int a1,
                                               int a2)
{
    _PrintEnter("CreateDiscardableBitmap(%p,%p,%p)\n", a0, a1, a2);

    HBITMAP rv = 0;
    __try {
        rv = Real_CreateDiscardableBitmap(a0, a1, a2);
    } __finally {
        _PrintExit("CreateDiscardableBitmap(,,) -> %p\n", rv);
    };
    return rv;
}

HRGN __stdcall Mine_CreateEllipticRgn(int a0,
                                      int a1,
                                      int a2,
                                      int a3)
{
    _PrintEnter("CreateEllipticRgn(%p,%p,%p,%p)\n", a0, a1, a2, a3);

    HRGN rv = 0;
    __try {
        rv = Real_CreateEllipticRgn(a0, a1, a2, a3);
    } __finally {
        _PrintExit("CreateEllipticRgn(,,,) -> %p\n", rv);
    };
    return rv;
}

HRGN __stdcall Mine_CreateEllipticRgnIndirect(RECT* a0)
{
    _PrintEnter("CreateEllipticRgnIndirect(%p)\n", a0);

    HRGN rv = 0;
    __try {
        rv = Real_CreateEllipticRgnIndirect(a0);
    } __finally {
        _PrintExit("CreateEllipticRgnIndirect() -> %p\n", rv);
    };
    return rv;
}

HDC __stdcall Mine_CreateEnhMetaFileA(HDC a0,
                                      LPCSTR a1,
                                      RECT* a2,
                                      LPCSTR a3)
{
    _PrintEnter("CreateEnhMetaFileA(%p,%hs,%p,%hs)\n", a0, a1, a2, a3);

    HDC rv = 0;
    __try {
        rv = Real_CreateEnhMetaFileA(a0, a1, a2, a3);
    } __finally {
        _PrintExit("CreateEnhMetaFileA(,,,) -> %p\n", rv);
    };
    return rv;
}

HDC __stdcall Mine_CreateEnhMetaFileW(HDC a0,
                                      LPCWSTR a1,
                                      RECT* a2,
                                      LPCWSTR a3)
{
    _PrintEnter("CreateEnhMetaFileW(%p,%ls,%p,%ls)\n", a0, a1, a2, a3);

    HDC rv = 0;
    __try {
        rv = Real_CreateEnhMetaFileW(a0, a1, a2, a3);
    } __finally {
        _PrintExit("CreateEnhMetaFileW(,,,) -> %p\n", rv);
    };
    return rv;
}

HANDLE __stdcall Mine_CreateEventA(LPSECURITY_ATTRIBUTES a0,
                                   BOOL a1,
                                   BOOL a2,
                                   LPCSTR a3)
{
    _PrintEnter("CreateEventA(%p,%p,%p,%hs)\n", a0, a1, a2, a3);

    HANDLE rv = 0;
    __try {
        rv = Real_CreateEventA(a0, a1, a2, a3);
    } __finally {
        _PrintExit("CreateEventA(,,,) -> %p\n", rv);
    };
    return rv;
}

HANDLE __stdcall Mine_CreateEventW(LPSECURITY_ATTRIBUTES a0,
                                   BOOL a1,
                                   BOOL a2,
                                   LPCWSTR a3)
{
    _PrintEnter("CreateEventW(%p,%p,%p,%ls)\n", a0, a1, a2, a3);

    HANDLE rv = 0;
    __try {
        rv = Real_CreateEventW(a0, a1, a2, a3);
    } __finally {
        _PrintExit("CreateEventW(,,,) -> %p\n", rv);
    };
    return rv;
}

LPVOID __stdcall Mine_CreateFiber(ULONG_PTR a0,
                                  LPFIBER_START_ROUTINE a1,
                                  LPVOID a2)
{
    _PrintEnter("CreateFiber(%p,%p,%p)\n", a0, a1, a2);

    LPVOID rv = 0;
    __try {
        rv = Real_CreateFiber(a0, a1, a2);
    } __finally {
        _PrintExit("CreateFiber(,,) -> %p\n", rv);
    };
    return rv;
}

HANDLE __stdcall Mine_CreateFileA(LPCSTR a0,
                                  DWORD a1,
                                  DWORD a2,
                                  LPSECURITY_ATTRIBUTES a3,
                                  DWORD a4,
                                  DWORD a5,
                                  HANDLE a6)
{
    _PrintEnter("CreateFileA(%hs,%p,%p,%p,%p,%p,%p)\n", a0, a1, a2, a3, a4, a5, a6);

    HANDLE rv = 0;
    __try {
        rv = Real_CreateFileA(a0, a1, a2, a3, a4, a5, a6);
    } __finally {
        _PrintExit("CreateFileA(,,,,,,) -> %p\n", rv);
    };
    return rv;
}

HANDLE __stdcall Mine_CreateFileMappingA(HANDLE a0,
                                         LPSECURITY_ATTRIBUTES a1,
                                         DWORD a2,
                                         DWORD a3,
                                         DWORD a4,
                                         LPCSTR a5)
{
    _PrintEnter("CreateFileMappingA(%p,%p,%p,%p,%p,%hs)\n", a0, a1, a2, a3, a4, a5);

    HANDLE rv = 0;
    __try {
        rv = Real_CreateFileMappingA(a0, a1, a2, a3, a4, a5);
    } __finally {
        _PrintExit("CreateFileMappingA(,,,,,) -> %p\n", rv);
    };
    return rv;
}

HANDLE __stdcall Mine_CreateFileMappingW(HANDLE a0,
                                         LPSECURITY_ATTRIBUTES a1,
                                         DWORD a2,
                                         DWORD a3,
                                         DWORD a4,
                                         LPCWSTR a5)
{
    _PrintEnter("CreateFileMappingW(%p,%p,%p,%p,%p,%ls)\n", a0, a1, a2, a3, a4, a5);

    HANDLE rv = 0;
    __try {
        rv = Real_CreateFileMappingW(a0, a1, a2, a3, a4, a5);
    } __finally {
        _PrintExit("CreateFileMappingW(,,,,,) -> %p\n", rv);
    };
    return rv;
}

HRESULT __stdcall Mine_CreateFileMoniker(LPCOLESTR a0,
                                         IMoniker** a1)
{
    _PrintEnter("CreateFileMoniker(%p,%p)\n", a0, a1);

    HRESULT rv = 0;
    __try {
        rv = Real_CreateFileMoniker(a0, a1);
    } __finally {
        _PrintExit("CreateFileMoniker(,) -> %x\n", rv);
    };
    return rv;
}

HANDLE __stdcall Mine_CreateFileW(LPCWSTR a0,
                                  DWORD a1,
                                  DWORD a2,
                                  LPSECURITY_ATTRIBUTES a3,
                                  DWORD a4,
                                  DWORD a5,
                                  HANDLE a6)
{
    _PrintEnter("CreateFileW(%ls,%p,%p,%p,%p,%p,%p)\n", a0, a1, a2, a3, a4, a5, a6);

    HANDLE rv = 0;
    __try {
        rv = Real_CreateFileW(a0, a1, a2, a3, a4, a5, a6);
    } __finally {
        _PrintExit("CreateFileW(,,,,,,) -> %p\n", rv);
    };
    return rv;
}

HFONT __stdcall Mine_CreateFontA(int a0,
                                 int a1,
                                 int a2,
                                 int a3,
                                 int a4,
                                 DWORD a5,
                                 DWORD a6,
                                 DWORD a7,
                                 DWORD a8,
                                 DWORD a9,
                                 DWORD a10,
                                 DWORD a11,
                                 DWORD a12,
                                 LPCSTR a13)
{
    _PrintEnter("CreateFontA(%p,%p,%p,%p,%p,%p,%p,%p,%p,%p,%p,%p,%p,%hs)\n", a0, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13);

    HFONT rv = 0;
    __try {
        rv = Real_CreateFontA(a0, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13);
    } __finally {
        _PrintExit("CreateFontA(,,,,,,,,,,,,,) -> %p\n", rv);
    };
    return rv;
}

HFONT __stdcall Mine_CreateFontIndirectA(LOGFONTA* a0)
{
    _PrintEnter("CreateFontIndirectA(%p)\n", a0);

    HFONT rv = 0;
    __try {
        rv = Real_CreateFontIndirectA(a0);
    } __finally {
        _PrintExit("CreateFontIndirectA() -> %p\n", rv);
    };
    return rv;
}

HFONT __stdcall Mine_CreateFontIndirectW(LOGFONTW* a0)
{
    _PrintEnter("CreateFontIndirectW(%p)\n", a0);

    HFONT rv = 0;
    __try {
        rv = Real_CreateFontIndirectW(a0);
    } __finally {
        _PrintExit("CreateFontIndirectW() -> %p\n", rv);
    };
    return rv;
}

HFONT __stdcall Mine_CreateFontW(int a0,
                                 int a1,
                                 int a2,
                                 int a3,
                                 int a4,
                                 DWORD a5,
                                 DWORD a6,
                                 DWORD a7,
                                 DWORD a8,
                                 DWORD a9,
                                 DWORD a10,
                                 DWORD a11,
                                 DWORD a12,
                                 LPCWSTR a13)
{
    _PrintEnter("CreateFontW(%p,%p,%p,%p,%p,%p,%p,%p,%p,%p,%p,%p,%p,%ls)\n", a0, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13);

    HFONT rv = 0;
    __try {
        rv = Real_CreateFontW(a0, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13);
    } __finally {
        _PrintExit("CreateFontW(,,,,,,,,,,,,,) -> %p\n", rv);
    };
    return rv;
}

HRESULT __stdcall Mine_CreateGenericComposite(IMoniker* a0,
                                              IMoniker* a1,
                                              IMoniker** a2)
{
    _PrintEnter("CreateGenericComposite(%p,%p,%p)\n", a0, a1, a2);

    HRESULT rv = 0;
    __try {
        rv = Real_CreateGenericComposite(a0, a1, a2);
    } __finally {
        _PrintExit("CreateGenericComposite(,,) -> %x\n", rv);
    };
    return rv;
}

HPALETTE __stdcall Mine_CreateHalftonePalette(HDC a0)
{
    _PrintEnter("CreateHalftonePalette(%p)\n", a0);

    HPALETTE rv = 0;
    __try {
        rv = Real_CreateHalftonePalette(a0);
    } __finally {
        _PrintExit("CreateHalftonePalette() -> %p\n", rv);
    };
    return rv;
}

HBRUSH __stdcall Mine_CreateHatchBrush(int a0,
                                       COLORREF a1)
{
    _PrintEnter("CreateHatchBrush(%p,%p)\n", a0, a1);

    HBRUSH rv = 0;
    __try {
        rv = Real_CreateHatchBrush(a0, a1);
    } __finally {
        _PrintExit("CreateHatchBrush(,) -> %p\n", rv);
    };
    return rv;
}

HDC __stdcall Mine_CreateICA(LPCSTR a0,
                             LPCSTR a1,
                             LPCSTR a2,
                             CONST DEVMODEA* a3)
{
    _PrintEnter("CreateICA(%hs,%hs,%hs,%p)\n", a0, a1, a2, a3);

    HDC rv = 0;
    __try {
        rv = Real_CreateICA(a0, a1, a2, a3);
    } __finally {
        _PrintExit("CreateICA(,,,) -> %p\n", rv);
    };
    return rv;
}

HDC __stdcall Mine_CreateICW(LPCWSTR a0,
                             LPCWSTR a1,
                             LPCWSTR a2,
                             CONST DEVMODEW* a3)
{
    _PrintEnter("CreateICW(%ls,%ls,%ls,%p)\n", a0, a1, a2, a3);

    HDC rv = 0;
    __try {
        rv = Real_CreateICW(a0, a1, a2, a3);
    } __finally {
        _PrintExit("CreateICW(,,,) -> %p\n", rv);
    };
    return rv;
}

HRESULT __stdcall Mine_CreateILockBytesOnHGlobal(HGLOBAL a0,
                                                 BOOL a1,
                                                 ILockBytes** a2)
{
    _PrintEnter("CreateILockBytesOnHGlobal(%p,%p,%p)\n", a0, a1, a2);

    HRESULT rv = 0;
    __try {
        rv = Real_CreateILockBytesOnHGlobal(a0, a1, a2);
    } __finally {
        _PrintExit("CreateILockBytesOnHGlobal(,,) -> %x\n", rv);
    };
    return rv;
}

HICON __stdcall Mine_CreateIcon(HINSTANCE a0,
                                int a1,
                                int a2,
                                BYTE a3,
                                BYTE a4,
                                BYTE* a5,
                                BYTE* a6)
{
    _PrintEnter("CreateIcon(%p,%p,%p,%p,%p,%p,%p)\n", a0, a1, a2, a3, a4, a5, a6);

    HICON rv = 0;
    __try {
        rv = Real_CreateIcon(a0, a1, a2, a3, a4, a5, a6);
    } __finally {
        _PrintExit("CreateIcon(,,,,,,) -> %p\n", rv);
    };
    return rv;
}

HICON __stdcall Mine_CreateIconFromResource(PBYTE a0,
                                            DWORD a1,
                                            BOOL a2,
                                            DWORD a3)
{
    _PrintEnter("CreateIconFromResource(%p,%p,%p,%p)\n", a0, a1, a2, a3);

    HICON rv = 0;
    __try {
        rv = Real_CreateIconFromResource(a0, a1, a2, a3);
    } __finally {
        _PrintExit("CreateIconFromResource(,,,) -> %p\n", rv);
    };
    return rv;
}

HICON __stdcall Mine_CreateIconFromResourceEx(PBYTE a0,
                                              DWORD a1,
                                              BOOL a2,
                                              DWORD a3,
                                              int a4,
                                              int a5,
                                              UINT a6)
{
    _PrintEnter("CreateIconFromResourceEx(%p,%p,%p,%p,%p,%p,%p)\n", a0, a1, a2, a3, a4, a5, a6);

    HICON rv = 0;
    __try {
        rv = Real_CreateIconFromResourceEx(a0, a1, a2, a3, a4, a5, a6);
    } __finally {
        _PrintExit("CreateIconFromResourceEx(,,,,,,) -> %p\n", rv);
    };
    return rv;
}

HICON __stdcall Mine_CreateIconIndirect(PICONINFO a0)
{
    _PrintEnter("CreateIconIndirect(%p)\n", a0);

    HICON rv = 0;
    __try {
        rv = Real_CreateIconIndirect(a0);
    } __finally {
        _PrintExit("CreateIconIndirect() -> %p\n", rv);
    };
    return rv;
}

HANDLE __stdcall Mine_CreateIoCompletionPort(HANDLE a0,
                                             HANDLE a1,
                                             ULONG_PTR a2,
                                             DWORD a3)
{
    _PrintEnter("CreateIoCompletionPort(%p,%p,%p,%p)\n", a0, a1, a2, a3);

    HANDLE rv = 0;
    __try {
        rv = Real_CreateIoCompletionPort(a0, a1, a2, a3);
    } __finally {
        _PrintExit("CreateIoCompletionPort(,,,) -> %p\n", rv);
    };
    return rv;
}

HRESULT __stdcall Mine_CreateItemMoniker(LPCOLESTR a0,
                                         LPCOLESTR a1,
                                         IMoniker** a2)
{
    _PrintEnter("CreateItemMoniker(%p,%p,%p)\n", a0, a1, a2);

    HRESULT rv = 0;
    __try {
        rv = Real_CreateItemMoniker(a0, a1, a2);
    } __finally {
        _PrintExit("CreateItemMoniker(,,) -> %x\n", rv);
    };
    return rv;
}

#if _MSC_VER < 1300
HWND __stdcall Mine_CreateMDIWindowA(LPSTR a0, // NT 3.51 and older. NT4?
                                     LPSTR a1, // NT 3.51 and older. NT4?
                                     DWORD a2,
                                     int a3,
                                     int a4,
                                     int a5,
                                     int a6,
                                     HWND a7,
                                     HINSTANCE a8,
                                     LPARAM a9)
#else
HWND __stdcall Mine_CreateMDIWindowA(LPCSTR a0, // Windows 2000 and newer; NT4?
                                     LPCSTR a1, // Windows 2000 and newer; NT4?
                                     DWORD a2,
                                     int a3,
                                     int a4,
                                     int a5,
                                     int a6,
                                     HWND a7,
                                     HINSTANCE a8,
                                     LPARAM a9)
#endif
{
    _PrintEnter("CreateMDIWindowA(%hs,%hs,%p,%p,%p,%p,%p,%p,%p,%p)\n", a0, a1, a2, a3, a4, a5, a6, a7, a8, a9);

    HWND rv = 0;
    __try {
        rv = Real_CreateMDIWindowA(a0, a1, a2, a3, a4, a5, a6, a7, a8, a9);
    } __finally {
        _PrintExit("CreateMDIWindowA(,,,,,,,,,) -> %p\n", rv);
    };
    return rv;
}

#if _MSC_VER < 1300
HWND __stdcall Mine_CreateMDIWindowW(LPWSTR a0,
                                     LPWSTR a1,
                                     DWORD a2,
                                     int a3,
                                     int a4,
                                     int a5,
                                     int a6,
                                     HWND a7,
                                     HINSTANCE a8,
                                     LPARAM a9)
#else
HWND __stdcall Mine_CreateMDIWindowW(LPCWSTR a0,
                                     LPCWSTR a1,
                                     DWORD a2,
                                     int a3,
                                     int a4,
                                     int a5,
                                     int a6,
                                     HWND a7,
                                     HINSTANCE a8,
                                     LPARAM a9)
#endif
{
    _PrintEnter("CreateMDIWindowW(%ls,%ls,%p,%p,%p,%p,%p,%p,%p,%p)\n", a0, a1, a2, a3, a4, a5, a6, a7, a8, a9);

    HWND rv = 0;
    __try {
        rv = Real_CreateMDIWindowW(a0, a1, a2, a3, a4, a5, a6, a7, a8, a9);
    } __finally {
        _PrintExit("CreateMDIWindowW(,,,,,,,,,) -> %p\n", rv);
    };
    return rv;
}

HANDLE __stdcall Mine_CreateMailslotA(LPCSTR a0,
                                      DWORD a1,
                                      DWORD a2,
                                      LPSECURITY_ATTRIBUTES a3)
{
    _PrintEnter("CreateMailslotA(%hs,%p,%p,%p)\n", a0, a1, a2, a3);

    HANDLE rv = 0;
    __try {
        rv = Real_CreateMailslotA(a0, a1, a2, a3);
    } __finally {
        _PrintExit("CreateMailslotA(,,,) -> %p\n", rv);
    };
    return rv;
}

HANDLE __stdcall Mine_CreateMailslotW(LPCWSTR a0,
                                      DWORD a1,
                                      DWORD a2,
                                      LPSECURITY_ATTRIBUTES a3)
{
    _PrintEnter("CreateMailslotW(%ls,%p,%p,%p)\n", a0, a1, a2, a3);

    HANDLE rv = 0;
    __try {
        rv = Real_CreateMailslotW(a0, a1, a2, a3);
    } __finally {
        _PrintExit("CreateMailslotW(,,,) -> %p\n", rv);
    };
    return rv;
}

HMENU __stdcall Mine_CreateMenu(void)
{
    _PrintEnter("CreateMenu()\n");

    HMENU rv = 0;
    __try {
        rv = Real_CreateMenu();
    } __finally {
        _PrintExit("CreateMenu() -> %p\n", rv);
    };
    return rv;
}

HDC __stdcall Mine_CreateMetaFileA(LPCSTR a0)
{
    _PrintEnter("CreateMetaFileA(%hs)\n", a0);

    HDC rv = 0;
    __try {
        rv = Real_CreateMetaFileA(a0);
    } __finally {
        _PrintExit("CreateMetaFileA() -> %p\n", rv);
    };
    return rv;
}

HDC __stdcall Mine_CreateMetaFileW(LPCWSTR a0)
{
    _PrintEnter("CreateMetaFileW(%ls)\n", a0);

    HDC rv = 0;
    __try {
        rv = Real_CreateMetaFileW(a0);
    } __finally {
        _PrintExit("CreateMetaFileW() -> %p\n", rv);
    };
    return rv;
}

HANDLE __stdcall Mine_CreateMutexA(LPSECURITY_ATTRIBUTES a0,
                                   BOOL a1,
                                   LPCSTR a2)
{
    _PrintEnter("CreateMutexA(%p,%p,%hs)\n", a0, a1, a2);

    HANDLE rv = 0;
    __try {
        rv = Real_CreateMutexA(a0, a1, a2);
    } __finally {
        _PrintExit("CreateMutexA(,,) -> %p\n", rv);
    };
    return rv;
}

HANDLE __stdcall Mine_CreateMutexW(LPSECURITY_ATTRIBUTES a0,
                                   BOOL a1,
                                   LPCWSTR a2)
{
    _PrintEnter("CreateMutexW(%p,%p,%ls)\n", a0, a1, a2);

    HANDLE rv = 0;
    __try {
        rv = Real_CreateMutexW(a0, a1, a2);
    } __finally {
        _PrintExit("CreateMutexW(,,) -> %p\n", rv);
    };
    return rv;
}

HANDLE __stdcall Mine_CreateNamedPipeA(LPCSTR a0,
                                       DWORD a1,
                                       DWORD a2,
                                       DWORD a3,
                                       DWORD a4,
                                       DWORD a5,
                                       DWORD a6,
                                       LPSECURITY_ATTRIBUTES a7)
{
    _PrintEnter("CreateNamedPipeA(%hs,%p,%p,%p,%p,%p,%p,%p)\n", a0, a1, a2, a3, a4, a5, a6, a7);

    HANDLE rv = 0;
    __try {
        rv = Real_CreateNamedPipeA(a0, a1, a2, a3, a4, a5, a6, a7);
    } __finally {
        _PrintExit("CreateNamedPipeA(,,,,,,,) -> %p\n", rv);
    };
    return rv;
}

HANDLE __stdcall Mine_CreateNamedPipeW(LPCWSTR a0,
                                       DWORD a1,
                                       DWORD a2,
                                       DWORD a3,
                                       DWORD a4,
                                       DWORD a5,
                                       DWORD a6,
                                       LPSECURITY_ATTRIBUTES a7)
{
    _PrintEnter("CreateNamedPipeW(%ls,%p,%p,%p,%p,%p,%p,%p)\n", a0, a1, a2, a3, a4, a5, a6, a7);

    HANDLE rv = 0;
    __try {
        rv = Real_CreateNamedPipeW(a0, a1, a2, a3, a4, a5, a6, a7);
    } __finally {
        _PrintExit("CreateNamedPipeW(,,,,,,,) -> %p\n", rv);
    };
    return rv;
}

HRESULT __stdcall Mine_CreateOleAdviseHolder(LPOLEADVISEHOLDER* a0)
{
    _PrintEnter("CreateOleAdviseHolder(%p)\n", a0);

    HRESULT rv = 0;
    __try {
        rv = Real_CreateOleAdviseHolder(a0);
    } __finally {
        _PrintExit("CreateOleAdviseHolder() -> %x\n", rv);
    };
    return rv;
}

HPALETTE __stdcall Mine_CreatePalette(LOGPALETTE* a0)
{
    _PrintEnter("CreatePalette(%p)\n", a0);

    HPALETTE rv = 0;
    __try {
        rv = Real_CreatePalette(a0);
    } __finally {
        _PrintExit("CreatePalette() -> %p\n", rv);
    };
    return rv;
}

HBRUSH __stdcall Mine_CreatePatternBrush(HBITMAP a0)
{
    _PrintEnter("CreatePatternBrush(%p)\n", a0);

    HBRUSH rv = 0;
    __try {
        rv = Real_CreatePatternBrush(a0);
    } __finally {
        _PrintExit("CreatePatternBrush() -> %p\n", rv);
    };
    return rv;
}

HPEN __stdcall Mine_CreatePen(int a0,
                              int a1,
                              COLORREF a2)
{
    _PrintEnter("CreatePen(%p,%p,%p)\n", a0, a1, a2);

    HPEN rv = 0;
    __try {
        rv = Real_CreatePen(a0, a1, a2);
    } __finally {
        _PrintExit("CreatePen(,,) -> %p\n", rv);
    };
    return rv;
}

HPEN __stdcall Mine_CreatePenIndirect(LOGPEN* a0)
{
    _PrintEnter("CreatePenIndirect(%p)\n", a0);

    HPEN rv = 0;
    __try {
        rv = Real_CreatePenIndirect(a0);
    } __finally {
        _PrintExit("CreatePenIndirect() -> %p\n", rv);
    };
    return rv;
}

BOOL __stdcall Mine_CreatePipe(PHANDLE a0,
                               PHANDLE a1,
                               LPSECURITY_ATTRIBUTES a2,
                               DWORD a3)
{
    _PrintEnter("CreatePipe(%p,%p,%p,%p)\n", a0, a1, a2, a3);

    BOOL rv = 0;
    __try {
        rv = Real_CreatePipe(a0, a1, a2, a3);
    } __finally {
        _PrintExit("CreatePipe(,,,) -> %x\n", rv);
    };
    return rv;
}

HRESULT __stdcall Mine_CreatePointerMoniker(LPUNKNOWN a0,
                                            IMoniker** a1)
{
    _PrintEnter("CreatePointerMoniker(%p,%p)\n", a0, a1);

    HRESULT rv = 0;
    __try {
        rv = Real_CreatePointerMoniker(a0, a1);
    } __finally {
        _PrintExit("CreatePointerMoniker(,) -> %x\n", rv);
    };
    return rv;
}

HRGN __stdcall Mine_CreatePolyPolygonRgn(POINT* a0,
                                         INT* a1,
                                         int a2,
                                         int a3)
{
    _PrintEnter("CreatePolyPolygonRgn(%p,%p,%p,%p)\n", a0, a1, a2, a3);

    HRGN rv = 0;
    __try {
        rv = Real_CreatePolyPolygonRgn(a0, a1, a2, a3);
    } __finally {
        _PrintExit("CreatePolyPolygonRgn(,,,) -> %p\n", rv);
    };
    return rv;
}

HRGN __stdcall Mine_CreatePolygonRgn(POINT* a0,
                                     int a1,
                                     int a2)
{
    _PrintEnter("CreatePolygonRgn(%p,%p,%p)\n", a0, a1, a2);

    HRGN rv = 0;
    __try {
        rv = Real_CreatePolygonRgn(a0, a1, a2);
    } __finally {
        _PrintExit("CreatePolygonRgn(,,) -> %p\n", rv);
    };
    return rv;
}

HMENU __stdcall Mine_CreatePopupMenu(void)
{
    _PrintEnter("CreatePopupMenu()\n");

    HMENU rv = 0;
    __try {
        rv = Real_CreatePopupMenu();
    } __finally {
        _PrintExit("CreatePopupMenu() -> %p\n", rv);
    };
    return rv;
}

BOOL __stdcall Mine_CreateProcessA(LPCSTR lpApplicationName,
                                   LPSTR lpCommandLine,
                                   LPSECURITY_ATTRIBUTES lpProcessAttributes,
                                   LPSECURITY_ATTRIBUTES lpThreadAttributes,
                                   BOOL bInheritHandles,
                                   DWORD dwCreationFlags,
                                   LPVOID lpEnvironment,
                                   LPCSTR lpCurrentDirectory,
                                   LPSTARTUPINFOA lpStartupInfo,
                                   LPPROCESS_INFORMATION lpProcessInformation)
{
    _PrintEnter("CreateProcessA(%hs,%hs,%p,%p,%p,%p,%p,%hs,%p,%p)\n",
                lpApplicationName,
                lpCommandLine,
                lpProcessAttributes,
                lpThreadAttributes,
                bInheritHandles,
                dwCreationFlags,
                lpEnvironment,
                lpCurrentDirectory,
                lpStartupInfo,
                lpProcessInformation);

    PROCESS_INFORMATION procInfo;
    if (lpProcessInformation == NULL) {
        lpProcessInformation= &procInfo;
        ZeroMemory(&procInfo, sizeof(procInfo));
    }

    BOOL rv = 0;
    __try {
        rv = DetourCreateProcessWithDllExA(lpApplicationName,
                                           lpCommandLine,
                                           lpProcessAttributes,
                                           lpThreadAttributes,
                                           bInheritHandles,
                                           dwCreationFlags,
                                           lpEnvironment,
                                           lpCurrentDirectory,
                                           lpStartupInfo,
                                           lpProcessInformation,
                                           s_szDllPath,
                                           Real_CreateProcessA);
    } __finally {
        _PrintExit("CreateProcessA(,,,,,,,,,) -> %x (proc:%d/%p, thrd:%d/%p\n", rv,
                   lpProcessInformation->dwProcessId,
                   lpProcessInformation->hProcess,
                   lpProcessInformation->dwThreadId,
                   lpProcessInformation->hThread);
    };
    return rv;
}

BOOL __stdcall Mine_CreateProcessW(LPCWSTR lpApplicationName,
                                   LPWSTR lpCommandLine,
                                   LPSECURITY_ATTRIBUTES lpProcessAttributes,
                                   LPSECURITY_ATTRIBUTES lpThreadAttributes,
                                   BOOL bInheritHandles,
                                   DWORD dwCreationFlags,
                                   LPVOID lpEnvironment,
                                   LPCWSTR lpCurrentDirectory,
                                   LPSTARTUPINFOW lpStartupInfo,
                                   LPPROCESS_INFORMATION lpProcessInformation)
{
    _PrintEnter("CreateProcessW(%ls,%ls,%p,%p,%p,%p,%p,%ls,%p,%p)\n",
                lpApplicationName,
                lpCommandLine,
                lpProcessAttributes,
                lpThreadAttributes,
                bInheritHandles,
                dwCreationFlags,
                lpEnvironment,
                lpCurrentDirectory,
                lpStartupInfo,
                lpProcessInformation);

    PROCESS_INFORMATION procInfo;
    if (lpProcessInformation == NULL) {
        lpProcessInformation= &procInfo;
        ZeroMemory(&procInfo, sizeof(procInfo));
    }

    BOOL rv = 0;
    __try {
        rv = DetourCreateProcessWithDllExW(lpApplicationName,
                                           lpCommandLine,
                                           lpProcessAttributes,
                                           lpThreadAttributes,
                                           bInheritHandles,
                                           dwCreationFlags,
                                           lpEnvironment,
                                           lpCurrentDirectory,
                                           lpStartupInfo,
                                           lpProcessInformation,
                                           s_szDllPath,
                                           Real_CreateProcessW);
    } __finally {
        _PrintExit("CreateProcessW(,,,,,,,,,) -> %x (proc:%d/%p, thrd:%d/%p\n", rv,
                   lpProcessInformation->dwProcessId,
                   lpProcessInformation->hProcess,
                   lpProcessInformation->dwThreadId,
                   lpProcessInformation->hThread);
    };
    return rv;
}

BOOL __stdcall Mine_CreateProcessAsUserA(
  __in_opt     HANDLE hToken,
  __in_opt     LPCSTR lpApplicationName,
  __inout_opt  LPSTR lpCommandLine,
  __in_opt     LPSECURITY_ATTRIBUTES lpProcessAttributes,
  __in_opt     LPSECURITY_ATTRIBUTES lpThreadAttributes,
  __in         BOOL bInheritHandles,
  __in         DWORD dwCreationFlags,
  __in_opt     LPVOID lpEnvironment,
  __in_opt     LPCSTR lpCurrentDirectory,
  __in         LPSTARTUPINFOA lpStartupInfo,
  __out        LPPROCESS_INFORMATION lpProcessInformation
                                        )
{
    _PrintEnter("CreateProcessAsUserA(%ls,%ls,%p,%p,%p,%p,%p,%ls,%p,%p)\n",
                lpApplicationName,
                lpCommandLine,
                lpProcessAttributes,
                lpThreadAttributes,
                bInheritHandles,
                dwCreationFlags,
                lpEnvironment,
                lpCurrentDirectory,
                lpStartupInfo,
                lpProcessInformation);

    PROCESS_INFORMATION procInfo;
    if (lpProcessInformation == NULL) {
        lpProcessInformation= &procInfo;
        ZeroMemory(&procInfo, sizeof(procInfo));
    }

    BOOL rv = 0;
    __try {
        rv = Real_CreateProcessAsUserA(hToken,
                                       lpApplicationName,
                                       lpCommandLine,
                                       lpProcessAttributes,
                                       lpThreadAttributes,
                                       bInheritHandles,
                                       dwCreationFlags,
                                       lpEnvironment,
                                       lpCurrentDirectory,
                                       lpStartupInfo,
                                       lpProcessInformation);
    } __finally {
        _PrintExit("CreateProcessAsUserAW(,,,,,,,,,) -> %x (proc:%d/%p, thrd:%d/%p\n", rv,
                   lpProcessInformation->dwProcessId,
                   lpProcessInformation->hProcess,
                   lpProcessInformation->dwThreadId,
                   lpProcessInformation->hThread);
    };
    return rv;
}

BOOL __stdcall Mine_CreateProcessAsUserW(
  __in_opt     HANDLE hToken,
  __in_opt     LPCWSTR lpApplicationName,
  __inout_opt  LPWSTR lpCommandLine,
  __in_opt     LPSECURITY_ATTRIBUTES lpProcessAttributes,
  __in_opt     LPSECURITY_ATTRIBUTES lpThreadAttributes,
  __in         BOOL bInheritHandles,
  __in         DWORD dwCreationFlags,
  __in_opt     LPVOID lpEnvironment,
  __in_opt     LPCWSTR lpCurrentDirectory,
  __in         LPSTARTUPINFOW lpStartupInfo,
  __out        LPPROCESS_INFORMATION lpProcessInformation
                                        )
{
    _PrintEnter("CreateProcessAsUserW(%ls,%ls,%p,%p,%p,%p,%p,%ls,%p,%p)\n",
                lpApplicationName,
                lpCommandLine,
                lpProcessAttributes,
                lpThreadAttributes,
                bInheritHandles,
                dwCreationFlags,
                lpEnvironment,
                lpCurrentDirectory,
                lpStartupInfo,
                lpProcessInformation);

    PROCESS_INFORMATION procInfo;
    if (lpProcessInformation == NULL) {
        lpProcessInformation= &procInfo;
        ZeroMemory(&procInfo, sizeof(procInfo));
    }

    BOOL rv = 0;
    __try {
        rv = Real_CreateProcessAsUserW(hToken,
                                       lpApplicationName,
                                       lpCommandLine,
                                       lpProcessAttributes,
                                       lpThreadAttributes,
                                       bInheritHandles,
                                       dwCreationFlags,
                                       lpEnvironment,
                                       lpCurrentDirectory,
                                       lpStartupInfo,
                                       lpProcessInformation);
    } __finally {
        _PrintExit("CreateProcessAsUserW(,,,,,,,,,) -> %x (proc:%d/%p, thrd:%d/%p\n", rv,
                   lpProcessInformation->dwProcessId,
                   lpProcessInformation->hProcess,
                   lpProcessInformation->dwThreadId,
                   lpProcessInformation->hThread);
    };
    return rv;
}

#if(_WIN32_WINNT >= 0x0500)
BOOL WINAPI Mine_CreateProcessWithLogonW(
  __in         LPCWSTR lpUsername,
  __in_opt     LPCWSTR lpDomain,
  __in         LPCWSTR lpPassword,
  __in         DWORD dwLogonFlags,
  __in_opt     LPCWSTR lpApplicationName,
  __inout_opt  LPWSTR lpCommandLine,
  __in         DWORD dwCreationFlags,
  __in_opt     LPVOID lpEnvironment,
  __in_opt     LPCWSTR lpCurrentDirectory,
  __in         LPSTARTUPINFOW lpStartupInfo,
  __out        LPPROCESS_INFORMATION lpProcessInfo
                                        )
{
    _PrintEnter("CreateProcessWithLogonW(%ls,%ls,%ls,%d,%ls,%ls,%p,%p,%ls,%p,%p)\n",
                lpUsername,
                lpDomain,
                lpPassword,
                dwLogonFlags,
                lpApplicationName,
                lpCommandLine,
                dwCreationFlags,
                lpEnvironment,
                lpCurrentDirectory,
                lpStartupInfo,
                lpProcessInfo);

    PROCESS_INFORMATION procInfo;
    if (lpProcessInfo == NULL) {
        lpProcessInfo= &procInfo;
        ZeroMemory(&procInfo, sizeof(procInfo));
    }

    BOOL rv = 0;
    __try {
        rv = Real_CreateProcessWithLogonW(
                lpUsername,
                lpDomain,
                lpPassword,
                dwLogonFlags,
                lpApplicationName,
                lpCommandLine,
                dwCreationFlags,
                lpEnvironment,
                lpCurrentDirectory,
                lpStartupInfo,
                lpProcessInfo);
    } __finally {
        _PrintExit("CreateProcessWithLogonW(,,,,,,,,,) -> %x (proc:%d/%p, thrd:%d/%p\n", rv,
                   lpProcessInfo->dwProcessId,
                   lpProcessInfo->hProcess,
                   lpProcessInfo->dwThreadId,
                   lpProcessInfo->hThread);
    };
    return rv;
}

BOOL WINAPI Mine_CreateProcessWithTokenW(
  __in         HANDLE hToken,
  __in         DWORD dwLogonFlags,
  __in_opt     LPCWSTR lpApplicationName,
  __inout_opt  LPWSTR lpCommandLine,
  __in         DWORD dwCreationFlags,
  __in_opt     LPVOID lpEnvironment,
  __in_opt     LPCWSTR lpCurrentDirectory,
  __in         LPSTARTUPINFOW lpStartupInfo,
  __out        LPPROCESS_INFORMATION lpProcessInfo
)
{
    _PrintEnter("CreateProcessWithTokenW(%ls,%ls,%p,%p,%ls,%p,%p)\n",
                lpApplicationName,
                lpCommandLine,
                dwCreationFlags,
                lpEnvironment,
                lpCurrentDirectory,
                lpStartupInfo,
                lpProcessInfo);

    PROCESS_INFORMATION procInfo;
    if (lpProcessInfo == NULL) {
        lpProcessInfo= &procInfo;
        ZeroMemory(&procInfo, sizeof(procInfo));
    }

    BOOL rv = 0;
    __try {
        rv = Real_CreateProcessWithTokenW(hToken,
                                          dwLogonFlags,
                                          lpApplicationName,
                                          lpCommandLine,
                                          dwCreationFlags,
                                          lpEnvironment,
                                          lpCurrentDirectory,
                                          lpStartupInfo,
                                          lpProcessInfo);
    } __finally {
        _PrintExit("CreateProcessWithTokenW(,,,,,,,,,) -> %x (proc:%d/%p, thrd:%d/%p\n", rv,
                   lpProcessInfo->dwProcessId,
                   lpProcessInfo->hProcess,
                   lpProcessInfo->dwThreadId,
                   lpProcessInfo->hThread);
    };
    return rv;
}
#endif // (_WIN32_WINNT >= 0x0500)

HRGN __stdcall Mine_CreateRectRgn(int a0,
                                  int a1,
                                  int a2,
                                  int a3)
{
    _PrintEnter("CreateRectRgn(%p,%p,%p,%p)\n", a0, a1, a2, a3);

    HRGN rv = 0;
    __try {
        rv = Real_CreateRectRgn(a0, a1, a2, a3);
    } __finally {
        _PrintExit("CreateRectRgn(,,,) -> %p\n", rv);
    };
    return rv;
}

HRGN __stdcall Mine_CreateRectRgnIndirect(RECT* a0)
{
    _PrintEnter("CreateRectRgnIndirect(%p)\n", a0);

    HRGN rv = 0;
    __try {
        rv = Real_CreateRectRgnIndirect(a0);
    } __finally {
        _PrintExit("CreateRectRgnIndirect() -> %p\n", rv);
    };
    return rv;
}

HANDLE __stdcall Mine_CreateRemoteThread(HANDLE a0,
                                         LPSECURITY_ATTRIBUTES a1,
                                         ULONG_PTR a2,
                                         LPTHREAD_START_ROUTINE a3,
                                         LPVOID a4,
                                         DWORD a5,
                                         LPDWORD a6)
{
    _PrintEnter("CreateRemoteThread(%p,%p,%p,%p,%p,%p,%p)\n", a0, a1, a2, a3, a4, a5, a6);

    HANDLE rv = 0;
    __try {
        rv = Real_CreateRemoteThread(a0, a1, a2, a3, a4, a5, a6);
    } __finally {
        _PrintExit("CreateRemoteThread(,,,,,,) -> %p\n", rv);
    };
    return rv;
}

HRGN __stdcall Mine_CreateRoundRectRgn(int a0,
                                       int a1,
                                       int a2,
                                       int a3,
                                       int a4,
                                       int a5)
{
    _PrintEnter("CreateRoundRectRgn(%p,%p,%p,%p,%p,%p)\n", a0, a1, a2, a3, a4, a5);

    HRGN rv = 0;
    __try {
        rv = Real_CreateRoundRectRgn(a0, a1, a2, a3, a4, a5);
    } __finally {
        _PrintExit("CreateRoundRectRgn(,,,,,) -> %p\n", rv);
    };
    return rv;
}

BOOL __stdcall Mine_CreateScalableFontResourceA(DWORD a0,
                                                LPCSTR a1,
                                                LPCSTR a2,
                                                LPCSTR a3)
{
    _PrintEnter("CreateScalableFontResourceA(%p,%hs,%hs,%hs)\n", a0, a1, a2, a3);

    BOOL rv = 0;
    __try {
        rv = Real_CreateScalableFontResourceA(a0, a1, a2, a3);
    } __finally {
        _PrintExit("CreateScalableFontResourceA(,,,) -> %x\n", rv);
    };
    return rv;
}

BOOL __stdcall Mine_CreateScalableFontResourceW(DWORD a0,
                                                LPCWSTR a1,
                                                LPCWSTR a2,
                                                LPCWSTR a3)
{
    _PrintEnter("CreateScalableFontResourceW(%p,%ls,%ls,%ls)\n", a0, a1, a2, a3);

    BOOL rv = 0;
    __try {
        rv = Real_CreateScalableFontResourceW(a0, a1, a2, a3);
    } __finally {
        _PrintExit("CreateScalableFontResourceW(,,,) -> %x\n", rv);
    };
    return rv;
}

HANDLE __stdcall Mine_CreateSemaphoreA(LPSECURITY_ATTRIBUTES a0,
                                       LONG a1,
                                       LONG a2,
                                       LPCSTR a3)
{
    _PrintEnter("CreateSemaphoreA(%p,%p,%p,%hs)\n", a0, a1, a2, a3);

    HANDLE rv = 0;
    __try {
        rv = Real_CreateSemaphoreA(a0, a1, a2, a3);
    } __finally {
        _PrintExit("CreateSemaphoreA(,,,) -> %p\n", rv);
    };
    return rv;
}

HANDLE __stdcall Mine_CreateSemaphoreW(LPSECURITY_ATTRIBUTES a0,
                                       LONG a1,
                                       LONG a2,
                                       LPCWSTR a3)
{
    _PrintEnter("CreateSemaphoreW(%p,%p,%p,%ls)\n", a0, a1, a2, a3);

    HANDLE rv = 0;
    __try {
        rv = Real_CreateSemaphoreW(a0, a1, a2, a3);
    } __finally {
        _PrintExit("CreateSemaphoreW(,,,) -> %p\n", rv);
    };
    return rv;
}

HBRUSH __stdcall Mine_CreateSolidBrush(COLORREF a0)
{
    _PrintEnter("CreateSolidBrush(%p)\n", a0);

    HBRUSH rv = 0;
    __try {
        rv = Real_CreateSolidBrush(a0);
    } __finally {
        _PrintExit("CreateSolidBrush() -> %p\n", rv);
    };
    return rv;
}

HRESULT __stdcall Mine_CreateStdProgressIndicator(HWND a0,
                                                  LPCOLESTR a1,
                                                  IBindStatusCallback* a2,
                                                  IBindStatusCallback** a3)
{
    _PrintEnter("CreateStdProgressIndicator(%p,%p,%p,%p)\n", a0, a1, a2, a3);

    HRESULT rv = 0;
    __try {
        rv = Real_CreateStdProgressIndicator(a0, a1, a2, a3);
    } __finally {
        _PrintExit("CreateStdProgressIndicator(,,,) -> %p\n", rv);
    };
    return rv;
}

HRESULT __stdcall Mine_CreateStreamOnHGlobal(HGLOBAL a0,
                                             BOOL a1,
                                             LPSTREAM* a2)
{
    _PrintEnter("CreateStreamOnHGlobal(%p,%p,%p)\n", a0, a1, a2);

    HRESULT rv = 0;
    __try {
        rv = Real_CreateStreamOnHGlobal(a0, a1, a2);
    } __finally {
        _PrintExit("CreateStreamOnHGlobal(,,) -> %p\n", rv);
    };
    return rv;
}

DWORD __stdcall Mine_CreateTapePartition(HANDLE a0,
                                         DWORD a1,
                                         DWORD a2,
                                         DWORD a3)
{
    _PrintEnter("CreateTapePartition(%p,%p,%p,%p)\n", a0, a1, a2, a3);

    DWORD rv = 0;
    __try {
        rv = Real_CreateTapePartition(a0, a1, a2, a3);
    } __finally {
        _PrintExit("CreateTapePartition(,,,) -> %x\n", rv);
    };
    return rv;
}

HANDLE __stdcall Mine_CreateThread(LPSECURITY_ATTRIBUTES a0,
                                   ULONG_PTR a1,
                                   LPTHREAD_START_ROUTINE a2,
                                   LPVOID a3,
                                   DWORD a4,
                                   LPDWORD a5)
{
    _PrintEnter("CreateThread(%p,%p,%p,%p,%p,%p)\n", a0, a1, a2, a3, a4, a5);

    HANDLE rv = 0;
    __try {
        rv = Real_CreateThread(a0, a1, a2, a3, a4, a5);
    } __finally {
        _PrintExit("CreateThread(,,,,,) -> %p\n", rv);
    };
    return rv;
}

HANDLE __stdcall Mine_CreateWaitableTimerA(LPSECURITY_ATTRIBUTES a0,
                                           BOOL a1,
                                           LPCSTR a2)
{
    _PrintEnter("CreateWaitableTimerA(%p,%p,%hs)\n", a0, a1, a2);

    HANDLE rv = 0;
    __try {
        rv = Real_CreateWaitableTimerA(a0, a1, a2);
    } __finally {
        _PrintExit("CreateWaitableTimerA(,,) -> %p\n", rv);
    };
    return rv;
}

HANDLE __stdcall Mine_CreateWaitableTimerW(LPSECURITY_ATTRIBUTES a0,
                                           BOOL a1,
                                           LPCWSTR a2)
{
    _PrintEnter("CreateWaitableTimerW(%p,%p,%ls)\n", a0, a1, a2);

    HANDLE rv = 0;
    __try {
        rv = Real_CreateWaitableTimerW(a0, a1, a2);
    } __finally {
        _PrintExit("CreateWaitableTimerW(,,) -> %p\n", rv);
    };
    return rv;
}

HWND __stdcall Mine_CreateWindowExA(DWORD a0,
                                    LPCSTR a1,
                                    LPCSTR a2,
                                    DWORD a3,
                                    int a4,
                                    int a5,
                                    int a6,
                                    int a7,
                                    HWND a8,
                                    HMENU a9,
                                    HINSTANCE a10,
                                    LPVOID a11)
{
    _PrintEnter("CreateWindowExA(%p,%hs,%hs,%p,%p,%p,%p,%p,%p,%p,%p,%p)\n", a0, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11);

    HWND rv = 0;
    __try {
        rv = Real_CreateWindowExA(a0, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11);
    } __finally {
        _PrintExit("CreateWindowExA(,,,,,,,,,,,) -> %p\n", rv);
    };
    return rv;
}

HWND __stdcall Mine_CreateWindowExW(DWORD a0,
                                    LPCWSTR a1,
                                    LPCWSTR a2,
                                    DWORD a3,
                                    int a4,
                                    int a5,
                                    int a6,
                                    int a7,
                                    HWND a8,
                                    HMENU a9,
                                    HINSTANCE a10,
                                    LPVOID a11)
{
    _PrintEnter("CreateWindowExW(%p,%ls,%ls,%p,%p,%p,%p,%p,%p,%p,%p,%p)\n", a0, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11);

    HWND rv = 0;
    __try {
        rv = Real_CreateWindowExW(a0, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11);
    } __finally {
        _PrintExit("CreateWindowExW(,,,,,,,,,,,) -> %p\n", rv);
    };
    return rv;
}

#if _MSC_VER < 1300
HWINSTA __stdcall Mine_CreateWindowStationA(LPSTR a0,
                                            DWORD a1,
                                            ACCESS_MASK a2,
                                            LPSECURITY_ATTRIBUTES a3)
#else
HWINSTA __stdcall Mine_CreateWindowStationA(LPCSTR a0,
                                            DWORD a1,
                                            ACCESS_MASK a2,
                                            LPSECURITY_ATTRIBUTES a3)
#endif
{
    _PrintEnter("CreateWindowStationA(%hs,%p,%p,%p)\n", a0, a1, a2, a3);

    HWINSTA rv = 0;
    __try {
        rv = Real_CreateWindowStationA(a0, a1, a2, a3);
    } __finally {
        _PrintExit("CreateWindowStationA(,,,) -> %p\n", rv);
    };
    return rv;
}

#if _MSC_VER < 1300
HWINSTA __stdcall Mine_CreateWindowStationW(LPWSTR a0,
                                            DWORD a1,
                                            ACCESS_MASK a2,
                                            LPSECURITY_ATTRIBUTES a3)
#else
HWINSTA __stdcall Mine_CreateWindowStationW(LPCWSTR a0,
                                            DWORD a1,
                                            ACCESS_MASK a2,
                                            LPSECURITY_ATTRIBUTES a3)
#endif
{
    _PrintEnter("CreateWindowStationW(%ls,%p,%p,%p)\n", a0, a1, a2, a3);

    HWINSTA rv = 0;
    __try {
        rv = Real_CreateWindowStationW(a0, a1, a2, a3);
    } __finally {
        _PrintExit("CreateWindowStationW(,,,) -> %p\n", rv);
    };
    return rv;
}

BOOL __stdcall Mine_DPtoLP(HDC a0,
                           POINT* a1,
                           int a2)
{
    _PrintEnter("DPtoLP(%p,%p,%p)\n", a0, a1, a2);

    BOOL rv = 0;
    __try {
        rv = Real_DPtoLP(a0, a1, a2);
    } __finally {
        _PrintExit("DPtoLP(,,) -> %x\n", rv);
    };
    return rv;
}

BOOL __stdcall Mine_DdeAbandonTransaction(DWORD a0,
                                          HCONV a1,
                                          DWORD a2)
{
    _PrintEnter("DdeAbandonTransaction(%p,%p,%p)\n", a0, a1, a2);

    BOOL rv = 0;
    __try {
        rv = Real_DdeAbandonTransaction(a0, a1, a2);
    } __finally {
        _PrintExit("DdeAbandonTransaction(,,) -> %p\n", rv);
    };
    return rv;
}

LPBYTE __stdcall Mine_DdeAccessData(HDDEDATA a0,
                                    LPDWORD a1)
{
    _PrintEnter("DdeAccessData(%p,%p)\n", a0, a1);

    LPBYTE rv = 0;
    __try {
        rv = Real_DdeAccessData(a0, a1);
    } __finally {
        _PrintExit("DdeAccessData(,) -> %p\n", rv);
    };
    return rv;
}

HDDEDATA __stdcall Mine_DdeAddData(HDDEDATA a0,
                                   LPBYTE a1,
                                   DWORD a2,
                                   DWORD a3)
{
    _PrintEnter("DdeAddData(%p,%p,%p,%p)\n", a0, a1, a2, a3);

    HDDEDATA rv = 0;
    __try {
        rv = Real_DdeAddData(a0, a1, a2, a3);
    } __finally {
        _PrintExit("DdeAddData(,,,) -> %p\n", rv);
    };
    return rv;
}

HDDEDATA __stdcall Mine_DdeClientTransaction(LPBYTE a0,
                                             DWORD a1,
                                             HCONV a2,
                                             HSZ a3,
                                             UINT a4,
                                             UINT a5,
                                             DWORD a6,
                                             LPDWORD a7)
{
    _PrintEnter("DdeClientTransaction(%p,%p,%p,%p,%p,%p,%p,%p)\n", a0, a1, a2, a3, a4, a5, a6, a7);

    HDDEDATA rv = 0;
    __try {
        rv = Real_DdeClientTransaction(a0, a1, a2, a3, a4, a5, a6, a7);
    } __finally {
        _PrintExit("DdeClientTransaction(,,,,,,,) -> %p\n", rv);
    };
    return rv;
}

int __stdcall Mine_DdeCmpStringHandles(HSZ a0,
                                       HSZ a1)
{
    _PrintEnter("DdeCmpStringHandles(%p,%p)\n", a0, a1);

    int rv = 0;
    __try {
        rv = Real_DdeCmpStringHandles(a0, a1);
    } __finally {
        _PrintExit("DdeCmpStringHandles(,) -> %x\n", rv);
    };
    return rv;
}

HCONV __stdcall Mine_DdeConnect(DWORD a0,
                                HSZ a1,
                                HSZ a2,
                                PCONVCONTEXT a3)
{
    _PrintEnter("DdeConnect(%p,%p,%p,%p)\n", a0, a1, a2, a3);

    HCONV rv = 0;
    __try {
        rv = Real_DdeConnect(a0, a1, a2, a3);
    } __finally {
        _PrintExit("DdeConnect(,,,) -> %p\n", rv);
    };
    return rv;
}

HCONVLIST __stdcall Mine_DdeConnectList(DWORD a0,
                                        HSZ a1,
                                        HSZ a2,
                                        HCONVLIST a3,
                                        PCONVCONTEXT a4)
{
    _PrintEnter("DdeConnectList(%p,%p,%p,%p,%p)\n", a0, a1, a2, a3, a4);

    HCONVLIST rv = 0;
    __try {
        rv = Real_DdeConnectList(a0, a1, a2, a3, a4);
    } __finally {
        _PrintExit("DdeConnectList(,,,,) -> %p\n", rv);
    };
    return rv;
}

HDDEDATA __stdcall Mine_DdeCreateDataHandle(DWORD a0,
                                            LPBYTE a1,
                                            DWORD a2,
                                            DWORD a3,
                                            HSZ a4,
                                            UINT a5,
                                            UINT a6)
{
    _PrintEnter("DdeCreateDataHandle(%p,%p,%p,%p,%p,%p,%p)\n", a0, a1, a2, a3, a4, a5, a6);

    HDDEDATA rv = 0;
    __try {
        rv = Real_DdeCreateDataHandle(a0, a1, a2, a3, a4, a5, a6);
    } __finally {
        _PrintExit("DdeCreateDataHandle(,,,,,,) -> %p\n", rv);
    };
    return rv;
}

HSZ __stdcall Mine_DdeCreateStringHandleA(DWORD a0,
                                          LPCSTR a1,
                                          int a2)
{
    _PrintEnter("DdeCreateStringHandleA(%p,%hs,%p)\n", a0, a1, a2);

    HSZ rv = 0;
    __try {
        rv = Real_DdeCreateStringHandleA(a0, a1, a2);
    } __finally {
        _PrintExit("DdeCreateStringHandleA(,,) -> %p\n", rv);
    };
    return rv;
}

HSZ __stdcall Mine_DdeCreateStringHandleW(DWORD a0,
                                          LPCWSTR a1,
                                          int a2)
{
    _PrintEnter("DdeCreateStringHandleW(%p,%ls,%p)\n", a0, a1, a2);

    HSZ rv = 0;
    __try {
        rv = Real_DdeCreateStringHandleW(a0, a1, a2);
    } __finally {
        _PrintExit("DdeCreateStringHandleW(,,) -> %p\n", rv);
    };
    return rv;
}

BOOL __stdcall Mine_DdeDisconnect(HCONV a0)
{
    _PrintEnter("DdeDisconnect(%p)\n", a0);

    BOOL rv = 0;
    __try {
        rv = Real_DdeDisconnect(a0);
    } __finally {
        _PrintExit("DdeDisconnect() -> %p\n", rv);
    };
    return rv;
}

BOOL __stdcall Mine_DdeDisconnectList(HCONVLIST a0)
{
    _PrintEnter("DdeDisconnectList(%p)\n", a0);

    BOOL rv = 0;
    __try {
        rv = Real_DdeDisconnectList(a0);
    } __finally {
        _PrintExit("DdeDisconnectList() -> %p\n", rv);
    };
    return rv;
}

BOOL __stdcall Mine_DdeEnableCallback(DWORD a0,
                                      HCONV a1,
                                      UINT a2)
{
    _PrintEnter("DdeEnableCallback(%p,%p,%p)\n", a0, a1, a2);

    BOOL rv = 0;
    __try {
        rv = Real_DdeEnableCallback(a0, a1, a2);
    } __finally {
        _PrintExit("DdeEnableCallback(,,) -> %p\n", rv);
    };
    return rv;
}

BOOL __stdcall Mine_DdeFreeDataHandle(HDDEDATA a0)
{
    _PrintEnter("DdeFreeDataHandle(%p)\n", a0);

    BOOL rv = 0;
    __try {
        rv = Real_DdeFreeDataHandle(a0);
    } __finally {
        _PrintExit("DdeFreeDataHandle() -> %p\n", rv);
    };
    return rv;
}

BOOL __stdcall Mine_DdeFreeStringHandle(DWORD a0,
                                        HSZ a1)
{
    _PrintEnter("DdeFreeStringHandle(%p,%p)\n", a0, a1);

    BOOL rv = 0;
    __try {
        rv = Real_DdeFreeStringHandle(a0, a1);
    } __finally {
        _PrintExit("DdeFreeStringHandle(,) -> %p\n", rv);
    };
    return rv;
}

DWORD __stdcall Mine_DdeGetData(HDDEDATA a0,
                                LPBYTE a1,
                                DWORD a2,
                                DWORD a3)
{
    _PrintEnter("DdeGetData(%p,%p,%p,%p)\n", a0, a1, a2, a3);

    DWORD rv = 0;
    __try {
        rv = Real_DdeGetData(a0, a1, a2, a3);
    } __finally {
        _PrintExit("DdeGetData(,,,) -> %p\n", rv);
    };
    return rv;
}

UINT __stdcall Mine_DdeGetLastError(DWORD a0)
{
    _PrintEnter("DdeGetLastError(%p)\n", a0);

    UINT rv = 0;
    __try {
        rv = Real_DdeGetLastError(a0);
    } __finally {
        _PrintExit("DdeGetLastError() -> %p\n", rv);
    };
    return rv;
}

BOOL __stdcall Mine_DdeImpersonateClient(HCONV a0)
{
    _PrintEnter("DdeImpersonateClient(%p)\n", a0);

    BOOL rv = 0;
    __try {
        rv = Real_DdeImpersonateClient(a0);
    } __finally {
        _PrintExit("DdeImpersonateClient() -> %p\n", rv);
    };
    return rv;
}

BOOL __stdcall Mine_DdeKeepStringHandle(DWORD a0,
                                        HSZ a1)
{
    _PrintEnter("DdeKeepStringHandle(%p,%p)\n", a0, a1);

    BOOL rv = 0;
    __try {
        rv = Real_DdeKeepStringHandle(a0, a1);
    } __finally {
        _PrintExit("DdeKeepStringHandle(,) -> %p\n", rv);
    };
    return rv;
}

HDDEDATA __stdcall Mine_DdeNameService(DWORD a0,
                                       HSZ a1,
                                       HSZ a2,
                                       UINT a3)
{
    _PrintEnter("DdeNameService(%p,%p,%p,%p)\n", a0, a1, a2, a3);

    HDDEDATA rv = 0;
    __try {
        rv = Real_DdeNameService(a0, a1, a2, a3);
    } __finally {
        _PrintExit("DdeNameService(,,,) -> %p\n", rv);
    };
    return rv;
}

BOOL __stdcall Mine_DdePostAdvise(DWORD a0,
                                  HSZ a1,
                                  HSZ a2)
{
    _PrintEnter("DdePostAdvise(%p,%p,%p)\n", a0, a1, a2);

    BOOL rv = 0;
    __try {
        rv = Real_DdePostAdvise(a0, a1, a2);
    } __finally {
        _PrintExit("DdePostAdvise(,,) -> %p\n", rv);
    };
    return rv;
}

UINT __stdcall Mine_DdeQueryConvInfo(HCONV a0,
                                     DWORD a1,
                                     CONVINFO* a2)
{
    _PrintEnter("DdeQueryConvInfo(%p,%p,%p)\n", a0, a1, a2);

    UINT rv = 0;
    __try {
        rv = Real_DdeQueryConvInfo(a0, a1, a2);
    } __finally {
        _PrintExit("DdeQueryConvInfo(,,) -> %p\n", rv);
    };
    return rv;
}

HCONV __stdcall Mine_DdeQueryNextServer(HCONVLIST a0,
                                        HCONV a1)
{
    _PrintEnter("DdeQueryNextServer(%p,%p)\n", a0, a1);

    HCONV rv = 0;
    __try {
        rv = Real_DdeQueryNextServer(a0, a1);
    } __finally {
        _PrintExit("DdeQueryNextServer(,) -> %p\n", rv);
    };
    return rv;
}

DWORD __stdcall Mine_DdeQueryStringA(DWORD a0,
                                     HSZ a1,
                                     LPSTR a2,
                                     DWORD a3,
                                     int a4)
{
    _PrintEnter("DdeQueryStringA(%p,%p,%hs,%p,%p)\n", a0, a1, a2, a3, a4);

    DWORD rv = 0;
    __try {
        rv = Real_DdeQueryStringA(a0, a1, a2, a3, a4);
    } __finally {
        _PrintExit("DdeQueryStringA(,,%hs,,) -> %p\n", a2, rv);
    };
    return rv;
}

DWORD __stdcall Mine_DdeQueryStringW(DWORD a0,
                                     HSZ a1,
                                     LPWSTR a2,
                                     DWORD a3,
                                     int a4)
{
    _PrintEnter("DdeQueryStringW(%p,%p,%ls,%p,%p)\n", a0, a1, a2, a3, a4);

    DWORD rv = 0;
    __try {
        rv = Real_DdeQueryStringW(a0, a1, a2, a3, a4);
    } __finally {
        _PrintExit("DdeQueryStringW(,,%ls,,) -> %p\n", a2, rv);
    };
    return rv;
}

HCONV __stdcall Mine_DdeReconnect(HCONV a0)
{
    _PrintEnter("DdeReconnect(%p)\n", a0);

    HCONV rv = 0;
    __try {
        rv = Real_DdeReconnect(a0);
    } __finally {
        _PrintExit("DdeReconnect() -> %p\n", rv);
    };
    return rv;
}

BOOL __stdcall Mine_DdeSetQualityOfService(HWND a0,
                                           PSECURITY_QUALITY_OF_SERVICE a1,
                                           PSECURITY_QUALITY_OF_SERVICE a2)
{
    _PrintEnter("DdeSetQualityOfService(%p,%p,%p)\n", a0, a1, a2);

    BOOL rv = 0;
    __try {
        rv = Real_DdeSetQualityOfService(a0, a1, a2);
    } __finally {
        _PrintExit("DdeSetQualityOfService(,,) -> %p\n", rv);
    };
    return rv;
}

BOOL __stdcall Mine_DdeSetUserHandle(HCONV a0,
                                     DWORD a1,
                                     ULONG_PTR a2)
{
    _PrintEnter("DdeSetUserHandle(%p,%x,%p)\n", a0, a1, a2);

    BOOL rv = 0;
    __try {
        rv = Real_DdeSetUserHandle(a0, a1, a2);
    } __finally {
        _PrintExit("DdeSetUserHandle(,,) -> %p\n", rv);
    };
    return rv;
}

BOOL __stdcall Mine_DdeUnaccessData(HDDEDATA a0)
{
    _PrintEnter("DdeUnaccessData(%p)\n", a0);

    BOOL rv = 0;
    __try {
        rv = Real_DdeUnaccessData(a0);
    } __finally {
        _PrintExit("DdeUnaccessData() -> %p\n", rv);
    };
    return rv;
}

BOOL __stdcall Mine_DdeUninitialize(DWORD a0)
{
    _PrintEnter("DdeUninitialize(%p)\n", a0);

    BOOL rv = 0;
    __try {
        rv = Real_DdeUninitialize(a0);
    } __finally {
        _PrintExit("DdeUninitialize() -> %p\n", rv);
    };
    return rv;
}

BOOL __stdcall Mine_DebugActiveProcess(DWORD a0)
{
    _PrintEnter("DebugActiveProcess(pid=%d)\n", a0);

    BOOL rv = 0;
    __try {
        rv = Real_DebugActiveProcess(a0);
    } __finally {
        _PrintExit("DebugActiveProcess() -> %p\n", rv);
    };
    return rv;
}

BOOL __stdcall Mine_DebugActiveProcessStop(DWORD a0)
{
    _PrintEnter("DebugActiveProcessStop(pid=%d)\n", a0);

    BOOL rv = 0;
    __try {
        rv = Real_DebugActiveProcess(a0);
    } __finally {
        _PrintExit("DebugActiveProcessStop() -> %p\n", rv);
    };
    return rv;
}

void __stdcall Mine_DebugBreak(void)
{
    _PrintEnter("DebugBreak()\n");

    __try {
        Real_DebugBreak();
    } __finally {
        _PrintExit("DebugBreak() ->\n");
    };
}

LRESULT __stdcall Mine_DefDlgProcA(HWND a0,
                                   UINT a1,
                                   WPARAM a2,
                                   LPARAM a3)
{
    _PrintEnter("DefDlgProcA(%p,%p,%p,%p)\n", a0, a1, a2, a3);

    LRESULT rv = 0;
    __try {
        rv = Real_DefDlgProcA(a0, a1, a2, a3);
    } __finally {
        _PrintExit("DefDlgProcA(,,,) -> %p\n", rv);
    };
    return rv;
}

LRESULT __stdcall Mine_DefDlgProcW(HWND a0,
                                   UINT a1,
                                   WPARAM a2,
                                   LPARAM a3)
{
    _PrintEnter("DefDlgProcW(%p,%p,%p,%p)\n", a0, a1, a2, a3);

    LRESULT rv = 0;
    __try {
        rv = Real_DefDlgProcW(a0, a1, a2, a3);
    } __finally {
        _PrintExit("DefDlgProcW(,,,) -> %p\n", rv);
    };
    return rv;
}

LRESULT __stdcall Mine_DefFrameProcA(HWND a0,
                                     HWND a1,
                                     UINT a2,
                                     WPARAM a3,
                                     LPARAM a4)
{
    _PrintEnter("DefFrameProcA(%p,%p,%p,%p,%p)\n", a0, a1, a2, a3, a4);

    LRESULT rv = 0;
    __try {
        rv = Real_DefFrameProcA(a0, a1, a2, a3, a4);
    } __finally {
        _PrintExit("DefFrameProcA(,,,,) -> %p\n", rv);
    };
    return rv;
}

LRESULT __stdcall Mine_DefFrameProcW(HWND a0,
                                     HWND a1,
                                     UINT a2,
                                     WPARAM a3,
                                     LPARAM a4)
{
    _PrintEnter("DefFrameProcW(%p,%p,%p,%p,%p)\n", a0, a1, a2, a3, a4);

    LRESULT rv = 0;
    __try {
        rv = Real_DefFrameProcW(a0, a1, a2, a3, a4);
    } __finally {
        _PrintExit("DefFrameProcW(,,,,) -> %p\n", rv);
    };
    return rv;
}

LRESULT __stdcall Mine_DefMDIChildProcA(HWND a0,
                                        UINT a1,
                                        WPARAM a2,
                                        LPARAM a3)
{
    _PrintEnter("DefMDIChildProcA(%p,%p,%p,%p)\n", a0, a1, a2, a3);

    LRESULT rv = 0;
    __try {
        rv = Real_DefMDIChildProcA(a0, a1, a2, a3);
    } __finally {
        _PrintExit("DefMDIChildProcA(,,,) -> %p\n", rv);
    };
    return rv;
}

LRESULT __stdcall Mine_DefMDIChildProcW(HWND a0,
                                        UINT a1,
                                        WPARAM a2,
                                        LPARAM a3)
{
    _PrintEnter("DefMDIChildProcW(%p,%p,%p,%p)\n", a0, a1, a2, a3);

    LRESULT rv = 0;
    __try {
        rv = Real_DefMDIChildProcW(a0, a1, a2, a3);
    } __finally {
        _PrintExit("DefMDIChildProcW(,,,) -> %p\n", rv);
    };
    return rv;
}

LRESULT __stdcall Mine_DefWindowProcA(HWND a0,
                                      UINT a1,
                                      WPARAM a2,
                                      LPARAM a3)
{
    _PrintEnter("DefWindowProcA(%p,%p,%p,%p)\n", a0, a1, a2, a3);

    LRESULT rv = 0;
    __try {
        rv = Real_DefWindowProcA(a0, a1, a2, a3);
    } __finally {
        _PrintExit("DefWindowProcA(,,,) -> %p\n", rv);
    };
    return rv;
}

LRESULT __stdcall Mine_DefWindowProcW(HWND a0,
                                      UINT a1,
                                      WPARAM a2,
                                      LPARAM a3)
{
    _PrintEnter("DefWindowProcW(%p,%p,%p,%p)\n", a0, a1, a2, a3);

    LRESULT rv = 0;
    __try {
        rv = Real_DefWindowProcW(a0, a1, a2, a3);
    } __finally {
        _PrintExit("DefWindowProcW(,,,) -> %p\n", rv);
    };
    return rv;
}

HDWP __stdcall Mine_DeferWindowPos(HDWP a0,
                                   HWND a1,
                                   HWND a2,
                                   int a3,
                                   int a4,
                                   int a5,
                                   int a6,
                                   UINT a7)
{
    _PrintEnter("DeferWindowPos(%p,%p,%p,%p,%p,%p,%p,%p)\n", a0, a1, a2, a3, a4, a5, a6, a7);

    HDWP rv = 0;
    __try {
        rv = Real_DeferWindowPos(a0, a1, a2, a3, a4, a5, a6, a7);
    } __finally {
        _PrintExit("DeferWindowPos(,,,,,,,) -> %p\n", rv);
    };
    return rv;
}

BOOL __stdcall Mine_DefineDosDeviceA(DWORD a0,
                                     LPCSTR a1,
                                     LPCSTR a2)
{
    _PrintEnter("DefineDosDeviceA(%p,%hs,%hs)\n", a0, a1, a2);

    BOOL rv = 0;
    __try {
        rv = Real_DefineDosDeviceA(a0, a1, a2);
    } __finally {
        _PrintExit("DefineDosDeviceA(,,) -> %p\n", rv);
    };
    return rv;
}

BOOL __stdcall Mine_DefineDosDeviceW(DWORD a0,
                                     LPCWSTR a1,
                                     LPCWSTR a2)
{
    _PrintEnter("DefineDosDeviceW(%p,%ls,%ls)\n", a0, a1, a2);

    BOOL rv = 0;
    __try {
        rv = Real_DefineDosDeviceW(a0, a1, a2);
    } __finally {
        _PrintExit("DefineDosDeviceW(,,) -> %p\n", rv);
    };
    return rv;
}

ATOM __stdcall Mine_DeleteAtom(ATOM a0)
{
    _PrintEnter("DeleteAtom(%p)\n", a0);

    ATOM rv = 0;
    __try {
        rv = Real_DeleteAtom(a0);
    } __finally {
        _PrintExit("DeleteAtom() -> %p\n", rv);
    };
    return rv;
}

BOOL __stdcall Mine_DeleteColorSpace(HCOLORSPACE a0)
{
    _PrintEnter("DeleteColorSpace(%p)\n", a0);

    BOOL rv = 0;
    __try {
        rv = Real_DeleteColorSpace(a0);
    } __finally {
        _PrintExit("DeleteColorSpace() -> %p\n", rv);
    };
    return rv;
}

BOOL __stdcall Mine_DeleteDC(HDC a0)
{
    _PrintEnter("DeleteDC(%p)\n", a0);

    BOOL rv = 0;
    __try {
        rv = Real_DeleteDC(a0);
    } __finally {
        _PrintExit("DeleteDC() -> %p\n", rv);
    };
    return rv;
}

BOOL __stdcall Mine_DeleteEnhMetaFile(HENHMETAFILE a0)
{
    _PrintEnter("DeleteEnhMetaFile(%p)\n", a0);

    BOOL rv = 0;
    __try {
        rv = Real_DeleteEnhMetaFile(a0);
    } __finally {
        _PrintExit("DeleteEnhMetaFile() -> %p\n", rv);
    };
    return rv;
}

void __stdcall Mine_DeleteFiber(LPVOID a0)
{
    _PrintEnter("DeleteFiber(%p)\n", a0);

    __try {
        Real_DeleteFiber(a0);
    } __finally {
        _PrintExit("DeleteFiber() ->\n");
    };
}

BOOL __stdcall Mine_DeleteFileA(LPCSTR a0)
{
    _PrintEnter("DeleteFileA(%hs)\n", a0);

    BOOL rv = 0;
    __try {
        rv = Real_DeleteFileA(a0);
    } __finally {
        _PrintExit("DeleteFileA() -> %p\n", rv);
    };
    return rv;
}

BOOL __stdcall Mine_DeleteFileW(LPCWSTR a0)
{
    _PrintEnter("DeleteFileW(%ls)\n", a0);

    BOOL rv = 0;
    __try {
        rv = Real_DeleteFileW(a0);
    } __finally {
        _PrintExit("DeleteFileW() -> %p\n", rv);
    };
    return rv;
}

BOOL __stdcall Mine_DeleteMenu(HMENU a0,
                               UINT a1,
                               UINT a2)
{
    _PrintEnter("DeleteMenu(%p,%p,%p)\n", a0, a1, a2);

    BOOL rv = 0;
    __try {
        rv = Real_DeleteMenu(a0, a1, a2);
    } __finally {
        _PrintExit("DeleteMenu(,,) -> %p\n", rv);
    };
    return rv;
}

BOOL __stdcall Mine_DeleteMetaFile(HMETAFILE a0)
{
    _PrintEnter("DeleteMetaFile(%p)\n", a0);

    BOOL rv = 0;
    __try {
        rv = Real_DeleteMetaFile(a0);
    } __finally {
        _PrintExit("DeleteMetaFile() -> %p\n", rv);
    };
    return rv;
}

BOOL __stdcall Mine_DeleteObject(HGDIOBJ a0)
{
    _PrintEnter("DeleteObject(%p)\n", a0);

    BOOL rv = 0;
    __try {
        rv = Real_DeleteObject(a0);
    } __finally {
        _PrintExit("DeleteObject() -> %p\n", rv);
    };
    return rv;
}

int __stdcall Mine_DescribePixelFormat(HDC a0,
                                       int a1,
                                       UINT a2,
                                       PIXELFORMATDESCRIPTOR* a3)
{
    _PrintEnter("DescribePixelFormat(%p,%p,%p,%p)\n", a0, a1, a2, a3);

    int rv = 0;
    __try {
        rv = Real_DescribePixelFormat(a0, a1, a2, a3);
    } __finally {
        _PrintExit("DescribePixelFormat(,,,) -> %p\n", rv);
    };
    return rv;
}

BOOL __stdcall Mine_DestroyAcceleratorTable(HACCEL a0)
{
    _PrintEnter("DestroyAcceleratorTable(%p)\n", a0);

    BOOL rv = 0;
    __try {
        rv = Real_DestroyAcceleratorTable(a0);
    } __finally {
        _PrintExit("DestroyAcceleratorTable() -> %p\n", rv);
    };
    return rv;
}

BOOL __stdcall Mine_DestroyCaret(void)
{
    _PrintEnter("DestroyCaret()\n");

    BOOL rv = 0;
    __try {
        rv = Real_DestroyCaret();
    } __finally {
        _PrintExit("DestroyCaret() -> %p\n", rv);
    };
    return rv;
}

BOOL __stdcall Mine_DestroyCursor(HCURSOR a0)
{
    _PrintEnter("DestroyCursor(%p)\n", a0);

    BOOL rv = 0;
    __try {
        rv = Real_DestroyCursor(a0);
    } __finally {
        _PrintExit("DestroyCursor() -> %p\n", rv);
    };
    return rv;
}

BOOL __stdcall Mine_DestroyIcon(HICON a0)
{
    _PrintEnter("DestroyIcon(%p)\n", a0);

    BOOL rv = 0;
    __try {
        rv = Real_DestroyIcon(a0);
    } __finally {
        _PrintExit("DestroyIcon() -> %p\n", rv);
    };
    return rv;
}

BOOL __stdcall Mine_DestroyMenu(HMENU a0)
{
    _PrintEnter("DestroyMenu(%p)\n", a0);

    BOOL rv = 0;
    __try {
        rv = Real_DestroyMenu(a0);
    } __finally {
        _PrintExit("DestroyMenu() -> %p\n", rv);
    };
    return rv;
}

BOOL __stdcall Mine_DestroyWindow(HWND a0)
{
    _PrintEnter("DestroyWindow(%p)\n", a0);

    BOOL rv = 0;
    __try {
        rv = Real_DestroyWindow(a0);
    } __finally {
        _PrintExit("DestroyWindow() -> %p\n", rv);
    };
    return rv;
}

BOOL __stdcall Mine_DeviceIoControl(HANDLE a0,
                                    DWORD a1,
                                    LPVOID a2,
                                    DWORD a3,
                                    LPVOID a4,
                                    DWORD a5,
                                    LPDWORD a6,
                                    LPOVERLAPPED a7)
{
    _PrintEnter("DeviceIoControl(%p,%p,%p,%p,%p,%p,%p,%p)\n", a0, a1, a2, a3, a4, a5, a6, a7);

    BOOL rv = 0;
    __try {
        rv = Real_DeviceIoControl(a0, a1, a2, a3, a4, a5, a6, a7);
    } __finally {
        _PrintExit("DeviceIoControl(,,,,,,,) -> %p\n", rv);
    };
    return rv;
}

INT_PTR __stdcall Mine_DialogBoxIndirectParamA(HINSTANCE a0,
                                               LPCDLGTEMPLATEA a1,
                                               HWND a2,
                                               DLGPROC a3,
                                               LPARAM a4)
{
    _PrintEnter("DialogBoxIndirectParamA(%p,%p,%p,%p,%p)\n", a0, a1, a2, a3, a4);

    INT_PTR rv = 0;
    __try {
        rv = Real_DialogBoxIndirectParamA(a0, a1, a2, a3, a4);
    } __finally {
        _PrintExit("DialogBoxIndirectParamA(,,,,) -> %p\n", rv);
    };
    return rv;
}

INT_PTR __stdcall Mine_DialogBoxIndirectParamW(HINSTANCE a0,
                                               LPCDLGTEMPLATEW a1,
                                               HWND a2,
                                               DLGPROC a3,
                                               LPARAM a4)
{
    _PrintEnter("DialogBoxIndirectParamW(%p,%p,%p,%p,%p)\n", a0, a1, a2, a3, a4);

    INT_PTR rv = 0;
    __try {
        rv = Real_DialogBoxIndirectParamW(a0, a1, a2, a3, a4);
    } __finally {
        _PrintExit("DialogBoxIndirectParamW(,,,,) -> %p\n", rv);
    };
    return rv;
}

INT_PTR __stdcall Mine_DialogBoxParamA(HINSTANCE a0,
                                       LPCSTR a1,
                                       HWND a2,
                                       DLGPROC a3,
                                       LPARAM a4)
{
    _PrintEnter("DialogBoxParamA(%p,%hs,%p,%p,%p)\n", a0, a1, a2, a3, a4);

    INT_PTR rv = 0;
    __try {
        rv = Real_DialogBoxParamA(a0, a1, a2, a3, a4);
    } __finally {
        _PrintExit("DialogBoxParamA(,,,,) -> %p\n", rv);
    };
    return rv;
}

INT_PTR __stdcall Mine_DialogBoxParamW(HINSTANCE a0,
                                       LPCWSTR a1,
                                       HWND a2,
                                       DLGPROC a3,
                                       LPARAM a4)
{
    _PrintEnter("DialogBoxParamW(%p,%ls,%p,%p,%p)\n", a0, a1, a2, a3, a4);

    INT_PTR rv = 0;
    __try {
        rv = Real_DialogBoxParamW(a0, a1, a2, a3, a4);
    } __finally {
        _PrintExit("DialogBoxParamW(,,,,) -> %p\n", rv);
    };
    return rv;
}

BOOL __stdcall Mine_DisableThreadLibraryCalls(HMODULE a0)
{
    _PrintEnter("DisableThreadLibraryCalls(%p)\n", a0);

    BOOL rv = 0;
    __try {
        rv = Real_DisableThreadLibraryCalls(a0);
    } __finally {
        _PrintExit("DisableThreadLibraryCalls() -> %p\n", rv);
    };
    return rv;
}

BOOL __stdcall Mine_DisconnectNamedPipe(HANDLE a0)
{
    _PrintEnter("DisconnectNamedPipe(%p)\n", a0);

    BOOL rv = 0;
    __try {
        rv = Real_DisconnectNamedPipe(a0);
    } __finally {
        _PrintExit("DisconnectNamedPipe() -> %p\n", rv);
    };
    return rv;
}

LRESULT __stdcall Mine_DispatchMessageA(MSG* a0)
{
    _PrintEnter("DispatchMessageA(%p)\n", a0);

    LRESULT rv = 0;
    __try {
        rv = Real_DispatchMessageA(a0);
    } __finally {
        _PrintExit("DispatchMessageA() -> %p\n", rv);
    };
    return rv;
}

LRESULT __stdcall Mine_DispatchMessageW(MSG* a0)
{
    _PrintEnter("DispatchMessageW(%p)\n", a0);

    LRESULT rv = 0;
    __try {
        rv = Real_DispatchMessageW(a0);
    } __finally {
        _PrintExit("DispatchMessageW() -> %p\n", rv);
    };
    return rv;
}

int __stdcall Mine_DlgDirListA(HWND a0,
                               LPSTR a1,
                               int a2,
                               int a3,
                               UINT a4)
{
    _PrintEnter("DlgDirListA(%p,%hs,%p,%p,%p)\n", a0, a1, a2, a3, a4);

    int rv = 0;
    __try {
        rv = Real_DlgDirListA(a0, a1, a2, a3, a4);
    } __finally {
        _PrintExit("DlgDirListA(,%hs,,,) -> %p\n", a1, rv);
    };
    return rv;
}

int __stdcall Mine_DlgDirListComboBoxA(HWND a0,
                                       LPSTR a1,
                                       int a2,
                                       int a3,
                                       UINT a4)
{
    _PrintEnter("DlgDirListComboBoxA(%p,%hs,%p,%p,%p)\n", a0, a1, a2, a3, a4);

    int rv = 0;
    __try {
        rv = Real_DlgDirListComboBoxA(a0, a1, a2, a3, a4);
    } __finally {
        _PrintExit("DlgDirListComboBoxA(,%hs,,,) -> %p\n", a1, rv);
    };
    return rv;
}

int __stdcall Mine_DlgDirListComboBoxW(HWND a0,
                                       LPWSTR a1,
                                       int a2,
                                       int a3,
                                       UINT a4)
{
    _PrintEnter("DlgDirListComboBoxW(%p,%ls,%p,%p,%p)\n", a0, a1, a2, a3, a4);

    int rv = 0;
    __try {
        rv = Real_DlgDirListComboBoxW(a0, a1, a2, a3, a4);
    } __finally {
        _PrintExit("DlgDirListComboBoxW(,%ls,,,) -> %p\n", a1, rv);
    };
    return rv;
}

int __stdcall Mine_DlgDirListW(HWND a0,
                               LPWSTR a1,
                               int a2,
                               int a3,
                               UINT a4)
{
    _PrintEnter("DlgDirListW(%p,%ls,%p,%p,%p)\n", a0, a1, a2, a3, a4);

    int rv = 0;
    __try {
        rv = Real_DlgDirListW(a0, a1, a2, a3, a4);
    } __finally {
        _PrintExit("DlgDirListW(,%ls,,,) -> %p\n", a1, rv);
    };
    return rv;
}

BOOL __stdcall Mine_DlgDirSelectComboBoxExA(HWND a0,
                                            LPSTR a1,
                                            int a2,
                                            int a3)
{
    _PrintEnter("DlgDirSelectComboBoxExA(%p,%p,%p,%p)\n", a0, a1, a2, a3);

    BOOL rv = 0;
    __try {
        rv = Real_DlgDirSelectComboBoxExA(a0, a1, a2, a3);
    } __finally {
        _PrintExit("DlgDirSelectComboBoxExA(,%hs,,) -> %p\n", a1, rv);
    };
    return rv;
}

BOOL __stdcall Mine_DlgDirSelectComboBoxExW(HWND a0,
                                            LPWSTR a1,
                                            int a2,
                                            int a3)
{
    _PrintEnter("DlgDirSelectComboBoxExW(%p,%p,%p,%p)\n", a0, a1, a2, a3);

    BOOL rv = 0;
    __try {
        rv = Real_DlgDirSelectComboBoxExW(a0, a1, a2, a3);
    } __finally {
        _PrintExit("DlgDirSelectComboBoxExW(,%ls,,) -> %p\n", a1, rv);
    };
    return rv;
}

BOOL __stdcall Mine_DlgDirSelectExA(HWND a0,
                                    LPSTR a1,
                                    int a2,
                                    int a3)
{
    _PrintEnter("DlgDirSelectExA(%p,%p,%p,%p)\n", a0, a1, a2, a3);

    BOOL rv = 0;
    __try {
        rv = Real_DlgDirSelectExA(a0, a1, a2, a3);
    } __finally {
        _PrintExit("DlgDirSelectExA(,%hs,,) -> %p\n", a1, rv);
    };
    return rv;
}

BOOL __stdcall Mine_DlgDirSelectExW(HWND a0,
                                    LPWSTR a1,
                                    int a2,
                                    int a3)
{
    _PrintEnter("DlgDirSelectExW(%p,%p,%p,%p)\n", a0, a1, a2, a3);

    BOOL rv = 0;
    __try {
        rv = Real_DlgDirSelectExW(a0, a1, a2, a3);
    } __finally {
        _PrintExit("DlgDirSelectExW(,%ls,,) -> %p\n", a1, rv);
    };
    return rv;
}

HRESULT __stdcall Mine_DoDragDrop(IDataObject* a0,
                                  IDropSource* a1,
                                  DWORD a2,
                                  LPDWORD a3)
{
    _PrintEnter("DoDragDrop(%p,%p,%p,%p)\n", a0, a1, a2, a3);

    HRESULT rv = 0;
    __try {
        rv = Real_DoDragDrop(a0, a1, a2, a3);
    } __finally {
        _PrintExit("DoDragDrop(,,,) -> %p\n", rv);
    };
    return rv;
}

BOOL __stdcall Mine_DosDateTimeToFileTime(WORD a0,
                                          WORD a1,
                                          LPFILETIME a2)
{
    _PrintEnter("DosDateTimeToFileTime(%p,%p,%p)\n", a0, a1, a2);

    BOOL rv = 0;
    __try {
        rv = Real_DosDateTimeToFileTime(a0, a1, a2);
    } __finally {
        _PrintExit("DosDateTimeToFileTime(,,) -> %p\n", rv);
    };
    return rv;
}

BOOL __stdcall Mine_DragDetect(HWND a0,
                               POINT a1)
{
    _PrintEnter("DragDetect(%p,%p)\n", a0, a1);

    BOOL rv = 0;
    __try {
        rv = Real_DragDetect(a0, a1);
    } __finally {
        _PrintExit("DragDetect(,) -> %p\n", rv);
    };
    return rv;
}

DWORD __stdcall Mine_DragObject(HWND a0,
                                HWND a1,
                                UINT a2,
                                ULONG_PTR a3,
                                HCURSOR a4)
{
    _PrintEnter("DragObject(%p,%p,%p,%p,%p)\n", a0, a1, a2, a3, a4);

    DWORD rv = 0;
    __try {
        rv = Real_DragObject(a0, a1, a2, a3, a4);
    } __finally {
        _PrintExit("DragObject(,,,,) -> %p\n", rv);
    };
    return rv;
}

BOOL __stdcall Mine_DrawAnimatedRects(HWND a0,
                                      int a1,
                                      RECT* a2,
                                      RECT* a3)
{
    _PrintEnter("DrawAnimatedRects(%p,%p,%p,%p)\n", a0, a1, a2, a3);

    BOOL rv = 0;
    __try {
        rv = Real_DrawAnimatedRects(a0, a1, a2, a3);
    } __finally {
        _PrintExit("DrawAnimatedRects(,,,) -> %p\n", rv);
    };
    return rv;
}

BOOL __stdcall Mine_DrawCaption(HWND a0,
                                HDC a1,
                                RECT* a2,
                                UINT a3)
{
    _PrintEnter("DrawCaption(%p,%p,%p,%p)\n", a0, a1, a2, a3);

    BOOL rv = 0;
    __try {
        rv = Real_DrawCaption(a0, a1, a2, a3);
    } __finally {
        _PrintExit("DrawCaption(,,,) -> %p\n", rv);
    };
    return rv;
}

BOOL __stdcall Mine_DrawEdge(HDC a0,
                             LPRECT a1,
                             UINT a2,
                             UINT a3)
{
    _PrintEnter("DrawEdge(%p,%p,%p,%p)\n", a0, a1, a2, a3);

    BOOL rv = 0;
    __try {
        rv = Real_DrawEdge(a0, a1, a2, a3);
    } __finally {
        _PrintExit("DrawEdge(,,,) -> %p\n", rv);
    };
    return rv;
}

int __stdcall Mine_DrawEscape(HDC a0,
                              int a1,
                              int a2,
                              LPCSTR a3)
{
    _PrintEnter("DrawEscape(%p,%p,%p,%hs)\n", a0, a1, a2, a3);

    int rv = 0;
    __try {
        rv = Real_DrawEscape(a0, a1, a2, a3);
    } __finally {
        _PrintExit("DrawEscape(,,,) -> %p\n", rv);
    };
    return rv;
}

BOOL __stdcall Mine_DrawFocusRect(HDC a0,
                                  RECT* a1)
{
    _PrintEnter("DrawFocusRect(%p,%p)\n", a0, a1);

    BOOL rv = 0;
    __try {
        rv = Real_DrawFocusRect(a0, a1);
    } __finally {
        _PrintExit("DrawFocusRect(,) -> %p\n", rv);
    };
    return rv;
}

BOOL __stdcall Mine_DrawFrameControl(HDC a0,
                                     LPRECT a1,
                                     UINT a2,
                                     UINT a3)
{
    _PrintEnter("DrawFrameControl(%p,%p,%p,%p)\n", a0, a1, a2, a3);

    BOOL rv = 0;
    __try {
        rv = Real_DrawFrameControl(a0, a1, a2, a3);
    } __finally {
        _PrintExit("DrawFrameControl(,,,) -> %p\n", rv);
    };
    return rv;
}

BOOL __stdcall Mine_DrawIcon(HDC a0,
                             int a1,
                             int a2,
                             HICON a3)
{
    _PrintEnter("DrawIcon(%p,%p,%p,%p)\n", a0, a1, a2, a3);

    BOOL rv = 0;
    __try {
        rv = Real_DrawIcon(a0, a1, a2, a3);
    } __finally {
        _PrintExit("DrawIcon(,,,) -> %p\n", rv);
    };
    return rv;
}

BOOL __stdcall Mine_DrawIconEx(HDC a0,
                               int a1,
                               int a2,
                               HICON a3,
                               int a4,
                               int a5,
                               UINT a6,
                               HBRUSH a7,
                               UINT a8)
{
    _PrintEnter("DrawIconEx(%p,%p,%p,%p,%p,%p,%p,%p,%p)\n", a0, a1, a2, a3, a4, a5, a6, a7, a8);

    BOOL rv = 0;
    __try {
        rv = Real_DrawIconEx(a0, a1, a2, a3, a4, a5, a6, a7, a8);
    } __finally {
        _PrintExit("DrawIconEx(,,,,,,,,) -> %p\n", rv);
    };
    return rv;
}

BOOL __stdcall Mine_DrawMenuBar(HWND a0)
{
    _PrintEnter("DrawMenuBar(%p)\n", a0);

    BOOL rv = 0;
    __try {
        rv = Real_DrawMenuBar(a0);
    } __finally {
        _PrintExit("DrawMenuBar() -> %p\n", rv);
    };
    return rv;
}

BOOL __stdcall Mine_DrawStateA(HDC a0,
                               HBRUSH a1,
                               DRAWSTATEPROC a2,
                               LPARAM a3,
                               WPARAM a4,
                               int a5,
                               int a6,
                               int a7,
                               int a8,
                               UINT a9)
{
    _PrintEnter("DrawStateA(%p,%p,%p,%p,%p,%p,%p,%p,%p,%p)\n", a0, a1, a2, a3, a4, a5, a6, a7, a8, a9);

    BOOL rv = 0;
    __try {
        rv = Real_DrawStateA(a0, a1, a2, a3, a4, a5, a6, a7, a8, a9);
    } __finally {
        _PrintExit("DrawStateA(,,,,,,,,,) -> %p\n", rv);
    };
    return rv;
}

BOOL __stdcall Mine_DrawStateW(HDC a0,
                               HBRUSH a1,
                               DRAWSTATEPROC a2,
                               LPARAM a3,
                               WPARAM a4,
                               int a5,
                               int a6,
                               int a7,
                               int a8,
                               UINT a9)
{
    _PrintEnter("DrawStateW(%p,%p,%p,%p,%p,%p,%p,%p,%p,%p)\n", a0, a1, a2, a3, a4, a5, a6, a7, a8, a9);

    BOOL rv = 0;
    __try {
        rv = Real_DrawStateW(a0, a1, a2, a3, a4, a5, a6, a7, a8, a9);
    } __finally {
        _PrintExit("DrawStateW(,,,,,,,,,) -> %p\n", rv);
    };
    return rv;
}

int __stdcall Mine_DrawTextA(HDC a0,
                             LPCSTR a1,
                             int a2,
                             LPRECT a3,
                             UINT a4)
{
    _PrintEnter("DrawTextA(%p,%hs,%p,%p,%p)\n", a0, a1, a2, a3, a4);

    int rv = 0;
    __try {
        rv = Real_DrawTextA(a0, a1, a2, a3, a4);
    } __finally {
        _PrintExit("DrawTextA(,,,,) -> %p\n", rv);
    };
    return rv;
}

int __stdcall Mine_DrawTextExA(HDC a0,
                               LPSTR a1,
                               int a2,
                               LPRECT a3,
                               UINT a4,
                               LPDRAWTEXTPARAMS a5)
{
    _PrintEnter("DrawTextExA(%p,%hs,%p,%p,%p,%p)\n", a0, a1, a2, a3, a4, a5);

    int rv = 0;
    __try {
        rv = Real_DrawTextExA(a0, a1, a2, a3, a4, a5);
    } __finally {
        _PrintExit("DrawTextExA(,%hs,,,,) -> %p\n", a1, rv);
    };
    return rv;
}

int __stdcall Mine_DrawTextExW(HDC a0,
                               LPWSTR a1,
                               int a2,
                               LPRECT a3,
                               UINT a4,
                               LPDRAWTEXTPARAMS a5)
{
    _PrintEnter("DrawTextExW(%p,%ls,%p,%p,%p,%p)\n", a0, a1, a2, a3, a4, a5);

    int rv = 0;
    __try {
        rv = Real_DrawTextExW(a0, a1, a2, a3, a4, a5);
    } __finally {
        _PrintExit("DrawTextExW(,%ls,,,,) -> %p\n", a1, rv);
    };
    return rv;
}

int __stdcall Mine_DrawTextW(HDC a0,
                             LPCWSTR a1,
                             int a2,
                             LPRECT a3,
                             UINT a4)
{
    _PrintEnter("DrawTextW(%p,%ls,%p,%p,%p)\n", a0, a1, a2, a3, a4);

    int rv = 0;
    __try {
        rv = Real_DrawTextW(a0, a1, a2, a3, a4);
    } __finally {
        _PrintExit("DrawTextW(,,,,) -> %p\n", rv);
    };
    return rv;
}

BOOL __stdcall Mine_DuplicateHandle(HANDLE a0,
                                    HANDLE a1,
                                    HANDLE a2,
                                    LPHANDLE a3,
                                    DWORD a4,
                                    BOOL a5,
                                    DWORD a6)
{
    _PrintEnter("DuplicateHandle(%p,%p,%p,%p,%p,%p,%p)\n", a0, a1, a2, a3, a4, a5, a6);

    BOOL rv = 0;
    __try {
        rv = Real_DuplicateHandle(a0, a1, a2, a3, a4, a5, a6);
    } __finally {
        _PrintExit("DuplicateHandle(,,,%p,,,) -> %p\n", a3 != NULL ? *a3 : NULL, rv);
    };
    return rv;
}

BOOL __stdcall Mine_Ellipse(HDC a0,
                            int a1,
                            int a2,
                            int a3,
                            int a4)
{
    _PrintEnter("Ellipse(%p,%p,%p,%p,%p)\n", a0, a1, a2, a3, a4);

    BOOL rv = 0;
    __try {
        rv = Real_Ellipse(a0, a1, a2, a3, a4);
    } __finally {
        _PrintExit("Ellipse(,,,,) -> %p\n", rv);
    };
    return rv;
}

BOOL __stdcall Mine_EmptyClipboard(void)
{
    _PrintEnter("EmptyClipboard()\n");

    BOOL rv = 0;
    __try {
        rv = Real_EmptyClipboard();
    } __finally {
        _PrintExit("EmptyClipboard() -> %p\n", rv);
    };
    return rv;
}

BOOL __stdcall Mine_EnableMenuItem(HMENU a0,
                                   UINT a1,
                                   UINT a2)
{
    _PrintEnter("EnableMenuItem(%p,%p,%p)\n", a0, a1, a2);

    BOOL rv = 0;
    __try {
        rv = Real_EnableMenuItem(a0, a1, a2);
    } __finally {
        _PrintExit("EnableMenuItem(,,) -> %p\n", rv);
    };
    return rv;
}

BOOL __stdcall Mine_EnableScrollBar(HWND a0,
                                    UINT a1,
                                    UINT a2)
{
    _PrintEnter("EnableScrollBar(%p,%p,%p)\n", a0, a1, a2);

    BOOL rv = 0;
    __try {
        rv = Real_EnableScrollBar(a0, a1, a2);
    } __finally {
        _PrintExit("EnableScrollBar(,,) -> %p\n", rv);
    };
    return rv;
}

BOOL __stdcall Mine_EnableWindow(HWND a0,
                                 BOOL a1)
{
    _PrintEnter("EnableWindow(%p,%p)\n", a0, a1);

    BOOL rv = 0;
    __try {
        rv = Real_EnableWindow(a0, a1);
    } __finally {
        _PrintExit("EnableWindow(,) -> %p\n", rv);
    };
    return rv;
}

BOOL __stdcall Mine_EndDeferWindowPos(HDWP a0)
{
    _PrintEnter("EndDeferWindowPos(%p)\n", a0);

    BOOL rv = 0;
    __try {
        rv = Real_EndDeferWindowPos(a0);
    } __finally {
        _PrintExit("EndDeferWindowPos() -> %p\n", rv);
    };
    return rv;
}

BOOL __stdcall Mine_EndDialog(HWND a0,
                              INT_PTR a1)
{
    _PrintEnter("EndDialog(%p,%p)\n", a0, a1);

    BOOL rv = 0;
    __try {
        rv = Real_EndDialog(a0, a1);
    } __finally {
        _PrintExit("EndDialog(,) -> %p\n", rv);
    };
    return rv;
}

int __stdcall Mine_EndDoc(HDC a0)
{
    _PrintEnter("EndDoc(%p)\n", a0);

    int rv = 0;
    __try {
        rv = Real_EndDoc(a0);
    } __finally {
        _PrintExit("EndDoc() -> %p\n", rv);
    };
    return rv;
}

int __stdcall Mine_EndPage(HDC a0)
{
    _PrintEnter("EndPage(%p)\n", a0);

    int rv = 0;
    __try {
        rv = Real_EndPage(a0);
    } __finally {
        _PrintExit("EndPage() -> %p\n", rv);
    };
    return rv;
}

BOOL __stdcall Mine_EndPaint(HWND a0,
                             PAINTSTRUCT* a1)
{
    _PrintEnter("EndPaint(%p,%p)\n", a0, a1);

    BOOL rv = 0;
    __try {
        rv = Real_EndPaint(a0, a1);
    } __finally {
        _PrintExit("EndPaint(,) -> %p\n", rv);
    };
    return rv;
}

BOOL __stdcall Mine_EndPath(HDC a0)
{
    _PrintEnter("EndPath(%p)\n", a0);

    BOOL rv = 0;
    __try {
        rv = Real_EndPath(a0);
    } __finally {
        _PrintExit("EndPath() -> %p\n", rv);
    };
    return rv;
}

BOOL __stdcall Mine_EndUpdateResourceA(HANDLE a0,
                                       BOOL a1)
{
    _PrintEnter("EndUpdateResourceA(%p,%p)\n", a0, a1);

    BOOL rv = 0;
    __try {
        rv = Real_EndUpdateResourceA(a0, a1);
    } __finally {
        _PrintExit("EndUpdateResourceA(,) -> %p\n", rv);
    };
    return rv;
}

BOOL __stdcall Mine_EndUpdateResourceW(HANDLE a0,
                                       BOOL a1)
{
    _PrintEnter("EndUpdateResourceW(%p,%p)\n", a0, a1);

    BOOL rv = 0;
    __try {
        rv = Real_EndUpdateResourceW(a0, a1);
    } __finally {
        _PrintExit("EndUpdateResourceW(,) -> %p\n", rv);
    };
    return rv;
}

BOOL __stdcall Mine_EnumCalendarInfoA(CALINFO_ENUMPROCA a0,
                                      LCID a1,
                                      CALID a2,
                                      CALTYPE a3)
{
    _PrintEnter("EnumCalendarInfoA(%p,%p,%p,%p)\n", a0, a1, a2, a3);

    BOOL rv = 0;
    __try {
        rv = Real_EnumCalendarInfoA(a0, a1, a2, a3);
    } __finally {
        _PrintExit("EnumCalendarInfoA(,,,) -> %p\n", rv);
    };
    return rv;
}

BOOL __stdcall Mine_EnumCalendarInfoW(CALINFO_ENUMPROCW a0,
                                      LCID a1,
                                      CALID a2,
                                      CALTYPE a3)
{
    _PrintEnter("EnumCalendarInfoW(%p,%p,%p,%p)\n", a0, a1, a2, a3);

    BOOL rv = 0;
    __try {
        rv = Real_EnumCalendarInfoW(a0, a1, a2, a3);
    } __finally {
        _PrintExit("EnumCalendarInfoW(,,,) -> %p\n", rv);
    };
    return rv;
}

BOOL __stdcall Mine_EnumChildWindows(HWND a0,
                                     WNDENUMPROC a1,
                                     LPARAM a2)
{
    _PrintEnter("EnumChildWindows(%p,%p,%p)\n", a0, a1, a2);

    BOOL rv = 0;
    __try {
        rv = Real_EnumChildWindows(a0, a1, a2);
    } __finally {
        _PrintExit("EnumChildWindows(,,) -> %p\n", rv);
    };
    return rv;
}

UINT __stdcall Mine_EnumClipboardFormats(UINT a0)
{
    _PrintEnter("EnumClipboardFormats(%p)\n", a0);

    UINT rv = 0;
    __try {
        rv = Real_EnumClipboardFormats(a0);
    } __finally {
        _PrintExit("EnumClipboardFormats() -> %p\n", rv);
    };
    return rv;
}

BOOL __stdcall Mine_EnumDateFormatsA(DATEFMT_ENUMPROCA a0,
                                     LCID a1,
                                     DWORD a2)
{
    _PrintEnter("EnumDateFormatsA(%p,%p,%p)\n", a0, a1, a2);

    BOOL rv = 0;
    __try {
        rv = Real_EnumDateFormatsA(a0, a1, a2);
    } __finally {
        _PrintExit("EnumDateFormatsA(,,) -> %p\n", rv);
    };
    return rv;
}

BOOL __stdcall Mine_EnumDateFormatsW(DATEFMT_ENUMPROCW a0,
                                     LCID a1,
                                     DWORD a2)
{
    _PrintEnter("EnumDateFormatsW(%p,%p,%p)\n", a0, a1, a2);

    BOOL rv = 0;
    __try {
        rv = Real_EnumDateFormatsW(a0, a1, a2);
    } __finally {
        _PrintExit("EnumDateFormatsW(,,) -> %p\n", rv);
    };
    return rv;
}

BOOL __stdcall Mine_EnumDesktopWindows(HDESK a0,
                                       WNDENUMPROC a1,
                                       LPARAM a2)
{
    _PrintEnter("EnumDesktopWindows(%p,%p,%p)\n", a0, a1, a2);

    BOOL rv = 0;
    __try {
        rv = Real_EnumDesktopWindows(a0, a1, a2);
    } __finally {
        _PrintExit("EnumDesktopWindows(,,) -> %p\n", rv);
    };
    return rv;
}

BOOL __stdcall Mine_EnumDesktopsA(HWINSTA a0,
                                  DESKTOPENUMPROCA a1,
                                  LPARAM a2)
{
    _PrintEnter("EnumDesktopsA(%p,%p,%p)\n", a0, a1, a2);

    BOOL rv = 0;
    __try {
        rv = Real_EnumDesktopsA(a0, a1, a2);
    } __finally {
        _PrintExit("EnumDesktopsA(,,) -> %p\n", rv);
    };
    return rv;
}

BOOL __stdcall Mine_EnumDesktopsW(HWINSTA a0,
                                  DESKTOPENUMPROCW a1,
                                  LPARAM a2)
{
    _PrintEnter("EnumDesktopsW(%p,%p,%p)\n", a0, a1, a2);

    BOOL rv = 0;
    __try {
        rv = Real_EnumDesktopsW(a0, a1, a2);
    } __finally {
        _PrintExit("EnumDesktopsW(,,) -> %p\n", rv);
    };
    return rv;
}

BOOL __stdcall Mine_EnumDisplaySettingsA(LPCSTR a0,
                                         DWORD a1,
                                         LPDEVMODEA a2)
{
    _PrintEnter("EnumDisplaySettingsA(%hs,%p,%p)\n", a0, a1, a2);

    BOOL rv = 0;
    __try {
        rv = Real_EnumDisplaySettingsA(a0, a1, a2);
    } __finally {
        _PrintExit("EnumDisplaySettingsA(,,) -> %p\n", rv);
    };
    return rv;
}

BOOL __stdcall Mine_EnumDisplaySettingsW(LPCWSTR a0,
                                         DWORD a1,
                                         LPDEVMODEW a2)
{
    _PrintEnter("EnumDisplaySettingsW(%ls,%p,%p)\n", a0, a1, a2);

    BOOL rv = 0;
    __try {
        rv = Real_EnumDisplaySettingsW(a0, a1, a2);
    } __finally {
        _PrintExit("EnumDisplaySettingsW(,,) -> %p\n", rv);
    };
    return rv;
}

BOOL __stdcall Mine_EnumEnhMetaFile(HDC a0,
                                    HENHMETAFILE a1,
                                    ENHMFENUMPROC a2,
                                    LPVOID a3,
                                    RECT* a4)
{
    _PrintEnter("EnumEnhMetaFile(%p,%p,%p,%p,%p)\n", a0, a1, a2, a3, a4);

    BOOL rv = 0;
    __try {
        rv = Real_EnumEnhMetaFile(a0, a1, a2, a3, a4);
    } __finally {
        _PrintExit("EnumEnhMetaFile(,,,,) -> %p\n", rv);
    };
    return rv;
}

int __stdcall Mine_EnumFontFamiliesA(HDC a0,
                                     LPCSTR a1,
                                     FONTENUMPROCA a2,
                                     LPARAM a3)
{
    _PrintEnter("EnumFontFamiliesA(%p,%hs,%p,%p)\n", a0, a1, a2, a3);

    int rv = 0;
    __try {
        rv = Real_EnumFontFamiliesA(a0, a1, a2, a3);
    } __finally {
        _PrintExit("EnumFontFamiliesA(,,,) -> %p\n", rv);
    };
    return rv;
}

int __stdcall Mine_EnumFontFamiliesExA(HDC a0,
                                       LPLOGFONTA a1,
                                       FONTENUMPROCA a2,
                                       LPARAM a3,
                                       DWORD a4)
{
    _PrintEnter("EnumFontFamiliesExA(%p,%p,%p,%p,%p)\n", a0, a1, a2, a3, a4);

    int rv = 0;
    __try {
        rv = Real_EnumFontFamiliesExA(a0, a1, a2, a3, a4);
    } __finally {
        _PrintExit("EnumFontFamiliesExA(,,,,) -> %p\n", rv);
    };
    return rv;
}

int __stdcall Mine_EnumFontFamiliesExW(HDC a0,
                                       LPLOGFONTW a1,
                                       FONTENUMPROCW a2,
                                       LPARAM a3,
                                       DWORD a4)
{
    _PrintEnter("EnumFontFamiliesExW(%p,%p,%p,%p,%p)\n", a0, a1, a2, a3, a4);

    int rv = 0;
    __try {
        rv = Real_EnumFontFamiliesExW(a0, a1, a2, a3, a4);
    } __finally {
        _PrintExit("EnumFontFamiliesExW(,,,,) -> %p\n", rv);
    };
    return rv;
}

int __stdcall Mine_EnumFontFamiliesW(HDC a0,
                                     LPCWSTR a1,
                                     FONTENUMPROCW a2,
                                     LPARAM a3)
{
    _PrintEnter("EnumFontFamiliesW(%p,%ls,%p,%p)\n", a0, a1, a2, a3);

    int rv = 0;
    __try {
        rv = Real_EnumFontFamiliesW(a0, a1, a2, a3);
    } __finally {
        _PrintExit("EnumFontFamiliesW(,,,) -> %p\n", rv);
    };
    return rv;
}

int __stdcall Mine_EnumFontsA(HDC a0,
                              LPCSTR a1,
                              FONTENUMPROCA a2,
                              LPARAM a3)
{
    _PrintEnter("EnumFontsA(%p,%hs,%p,%p)\n", a0, a1, a2, a3);

    int rv = 0;
    __try {
        rv = Real_EnumFontsA(a0, a1, a2, a3);
    } __finally {
        _PrintExit("EnumFontsA(,,,) -> %p\n", rv);
    };
    return rv;
}

int __stdcall Mine_EnumFontsW(HDC a0,
                              LPCWSTR a1,
                              FONTENUMPROCW a2,
                              LPARAM a3)
{
    _PrintEnter("EnumFontsW(%p,%ls,%p,%p)\n", a0, a1, a2, a3);

    int rv = 0;
    __try {
        rv = Real_EnumFontsW(a0, a1, a2, a3);
    } __finally {
        _PrintExit("EnumFontsW(,,,) -> %p\n", rv);
    };
    return rv;
}

int __stdcall Mine_EnumICMProfilesA(HDC a0,
                                    ICMENUMPROCA a1,
                                    LPARAM a2)
{
    _PrintEnter("EnumICMProfilesA(%p,%p,%p)\n", a0, a1, a2);

    int rv = 0;
    __try {
        rv = Real_EnumICMProfilesA(a0, a1, a2);
    } __finally {
        _PrintExit("EnumICMProfilesA(,,) -> %p\n", rv);
    };
    return rv;
}

int __stdcall Mine_EnumICMProfilesW(HDC a0,
                                    ICMENUMPROCW a1,
                                    LPARAM a2)
{
    _PrintEnter("EnumICMProfilesW(%p,%p,%p)\n", a0, a1, a2);

    int rv = 0;
    __try {
        rv = Real_EnumICMProfilesW(a0, a1, a2);
    } __finally {
        _PrintExit("EnumICMProfilesW(,,) -> %p\n", rv);
    };
    return rv;
}

BOOL __stdcall Mine_EnumMetaFile(HDC a0,
                                 HMETAFILE a1,
                                 MFENUMPROC a2,
                                 LPARAM a3)
{
    _PrintEnter("EnumMetaFile(%p,%p,%p,%p)\n", a0, a1, a2, a3);

    BOOL rv = 0;
    __try {
        rv = Real_EnumMetaFile(a0, a1, a2, a3);
    } __finally {
        _PrintExit("EnumMetaFile(,,,) -> %p\n", rv);
    };
    return rv;
}

int __stdcall Mine_EnumObjects(HDC a0,
                               int a1,
                               GOBJENUMPROC a2,
                               LPARAM a3)
{
    _PrintEnter("EnumObjects(%p,%p,%p,%p)\n", a0, a1, a2, a3);

    int rv = 0;
    __try {
        rv = Real_EnumObjects(a0, a1, a2, a3);
    } __finally {
        _PrintExit("EnumObjects(,,,) -> %p\n", rv);
    };
    return rv;
}

int __stdcall Mine_EnumPropsA(HWND a0,
                              PROPENUMPROCA a1)
{
    _PrintEnter("EnumPropsA(%p,%p)\n", a0, a1);

    int rv = 0;
    __try {
        rv = Real_EnumPropsA(a0, a1);
    } __finally {
        _PrintExit("EnumPropsA(,) -> %p\n", rv);
    };
    return rv;
}

int __stdcall Mine_EnumPropsExA(HWND a0,
                                PROPENUMPROCEXA a1,
                                LPARAM a2)
{
    _PrintEnter("EnumPropsExA(%p,%p,%p)\n", a0, a1, a2);

    int rv = 0;
    __try {
        rv = Real_EnumPropsExA(a0, a1, a2);
    } __finally {
        _PrintExit("EnumPropsExA(,,) -> %p\n", rv);
    };
    return rv;
}

int __stdcall Mine_EnumPropsExW(HWND a0,
                                PROPENUMPROCEXW a1,
                                LPARAM a2)
{
    _PrintEnter("EnumPropsExW(%p,%p,%p)\n", a0, a1, a2);

    int rv = 0;
    __try {
        rv = Real_EnumPropsExW(a0, a1, a2);
    } __finally {
        _PrintExit("EnumPropsExW(,,) -> %p\n", rv);
    };
    return rv;
}

int __stdcall Mine_EnumPropsW(HWND a0,
                              PROPENUMPROCW a1)
{
    _PrintEnter("EnumPropsW(%p,%p)\n", a0, a1);

    int rv = 0;
    __try {
        rv = Real_EnumPropsW(a0, a1);
    } __finally {
        _PrintExit("EnumPropsW(,) -> %p\n", rv);
    };
    return rv;
}

#if _MSC_VER < 1300
BOOL __stdcall Mine_EnumResourceLanguagesA(HMODULE a0,
                                           LPCSTR a1,
                                           LPCSTR a2,
                                           ENUMRESLANGPROC a3,
                                           LONG_PTR a4)
#else
BOOL __stdcall Mine_EnumResourceLanguagesA(HMODULE a0,
                                           LPCSTR a1,
                                           LPCSTR a2,
                                           ENUMRESLANGPROCA a3,
                                           LONG_PTR a4)
#endif
{
    _PrintEnter("EnumResourceLanguagesA(%p,%hs,%hs,%p,%p)\n", a0, a1, a2, a3, a4);

    BOOL rv = 0;
    __try {
        rv = Real_EnumResourceLanguagesA(a0, a1, a2, a3, a4);
    } __finally {
        _PrintExit("EnumResourceLanguagesA(,,,,) -> %p\n", rv);
    };
    return rv;
}

#if _MSC_VER < 1300
BOOL __stdcall Mine_EnumResourceLanguagesW(HMODULE a0,
                                           LPCWSTR a1,
                                           LPCWSTR a2,
                                           ENUMRESLANGPROC a3,
                                           LONG_PTR a4)
#else
BOOL __stdcall Mine_EnumResourceLanguagesW(HMODULE a0,
                                           LPCWSTR a1,
                                           LPCWSTR a2,
                                           ENUMRESLANGPROCW a3,
                                           LONG_PTR a4)
#endif
{
    _PrintEnter("EnumResourceLanguagesW(%p,%ls,%ls,%p,%p)\n", a0, a1, a2, a3, a4);

    BOOL rv = 0;
    __try {
        rv = Real_EnumResourceLanguagesW(a0, a1, a2, a3, a4);
    } __finally {
        _PrintExit("EnumResourceLanguagesW(,,,,) -> %p\n", rv);
    };
    return rv;
}

#if _MSC_VER < 1300
BOOL __stdcall Mine_EnumResourceNamesA(HMODULE a0,
                                       LPCSTR a1,
                                       ENUMRESNAMEPROC a2,
                                       LONG_PTR a3)
#else
BOOL __stdcall Mine_EnumResourceNamesA(HMODULE a0,
                                       LPCSTR a1,
                                       ENUMRESNAMEPROCA a2,
                                       LONG_PTR a3)
#endif
{
    _PrintEnter("EnumResourceNamesA(%p,%hs,%p,%p)\n", a0, a1, a2, a3);

    BOOL rv = 0;
    __try {
        rv = Real_EnumResourceNamesA(a0, a1, a2, a3);
    } __finally {
        _PrintExit("EnumResourceNamesA(,,,) -> %p\n", rv);
    };
    return rv;
}

#if _MSC_VER < 1300
BOOL __stdcall Mine_EnumResourceNamesW(HMODULE a0,
                                       LPCWSTR a1,
                                       ENUMRESNAMEPROC a2,
                                       LONG_PTR a3)
#else
BOOL __stdcall Mine_EnumResourceNamesW(HMODULE a0,
                                       LPCWSTR a1,
                                       ENUMRESNAMEPROCW a2,
                                       LONG_PTR a3)
#endif
{
    _PrintEnter("EnumResourceNamesW(%p,%ls,%p,%p)\n", a0, a1, a2, a3);

    BOOL rv = 0;
    __try {
        rv = Real_EnumResourceNamesW(a0, a1, a2, a3);
    } __finally {
        _PrintExit("EnumResourceNamesW(,,,) -> %p\n", rv);
    };
    return rv;
}

#if _MSC_VER < 1300
BOOL __stdcall Mine_EnumResourceTypesA(HMODULE a0,
                                       ENUMRESTYPEPROC a1,
                                       LONG_PTR a2)
#else
BOOL __stdcall Mine_EnumResourceTypesA(HMODULE a0,
                                       ENUMRESTYPEPROCA a1,
                                       LONG_PTR a2)
#endif
{
    _PrintEnter("EnumResourceTypesA(%p,%p,%p)\n", a0, a1, a2);

    BOOL rv = 0;
    __try {
        rv = Real_EnumResourceTypesA(a0, a1, a2);
    } __finally {
        _PrintExit("EnumResourceTypesA(,,) -> %p\n", rv);
    };
    return rv;
}

#if _MSC_VER < 1300
BOOL __stdcall Mine_EnumResourceTypesW(HMODULE a0,
                                       ENUMRESTYPEPROC a1,
                                       LONG_PTR a2)
#else
BOOL __stdcall Mine_EnumResourceTypesW(HMODULE a0,
                                       ENUMRESTYPEPROCW a1,
                                       LONG_PTR a2)
#endif
{
    _PrintEnter("EnumResourceTypesW(%p,%p,%p)\n", a0, a1, a2);

    BOOL rv = 0;
    __try {
        rv = Real_EnumResourceTypesW(a0, a1, a2);
    } __finally {
        _PrintExit("EnumResourceTypesW(,,) -> %p\n", rv);
    };
    return rv;
}

BOOL __stdcall Mine_EnumSystemCodePagesA(CODEPAGE_ENUMPROCA a0,
                                         DWORD a1)
{
    _PrintEnter("EnumSystemCodePagesA(%p,%p)\n", a0, a1);

    BOOL rv = 0;
    __try {
        rv = Real_EnumSystemCodePagesA(a0, a1);
    } __finally {
        _PrintExit("EnumSystemCodePagesA(,) -> %p\n", rv);
    };
    return rv;
}

BOOL __stdcall Mine_EnumSystemCodePagesW(CODEPAGE_ENUMPROCW a0,
                                         DWORD a1)
{
    _PrintEnter("EnumSystemCodePagesW(%p,%p)\n", a0, a1);

    BOOL rv = 0;
    __try {
        rv = Real_EnumSystemCodePagesW(a0, a1);
    } __finally {
        _PrintExit("EnumSystemCodePagesW(,) -> %p\n", rv);
    };
    return rv;
}

#if(WINVER >= 0x0500)
BOOL __stdcall Mine_EnumSystemLocalesA(LOCALE_ENUMPROCA a0,
                                       DWORD a1)
{
    _PrintEnter("EnumSystemLocalesA(%p,%p)\n", a0, a1);

    BOOL rv = 0;
    __try {
        rv = Real_EnumSystemLocalesA(a0, a1);
    } __finally {
        _PrintExit("EnumSystemLocalesA(,) -> %p\n", rv);
    };
    return rv;
}

BOOL __stdcall Mine_EnumSystemLocalesW(LOCALE_ENUMPROCW a0,
                                       DWORD a1)
{
    _PrintEnter("EnumSystemLocalesW(%p,%p)\n", a0, a1);

    BOOL rv = 0;
    __try {
        rv = Real_EnumSystemLocalesW(a0, a1);
    } __finally {
        _PrintExit("EnumSystemLocalesW(,) -> %p\n", rv);
    };
    return rv;
}
#endif // (WINVER >= 0x0500)

BOOL __stdcall Mine_EnumThreadWindows(DWORD a0,
                                      WNDENUMPROC a1,
                                      LPARAM a2)
{
    _PrintEnter("EnumThreadWindows(%p,%p,%p)\n", a0, a1, a2);

    BOOL rv = 0;
    __try {
        rv = Real_EnumThreadWindows(a0, a1, a2);
    } __finally {
        _PrintExit("EnumThreadWindows(,,) -> %p\n", rv);
    };
    return rv;
}

BOOL __stdcall Mine_EnumTimeFormatsA(TIMEFMT_ENUMPROCA a0,
                                     LCID a1,
                                     DWORD a2)
{
    _PrintEnter("EnumTimeFormatsA(%p,%p,%p)\n", a0, a1, a2);

    BOOL rv = 0;
    __try {
        rv = Real_EnumTimeFormatsA(a0, a1, a2);
    } __finally {
        _PrintExit("EnumTimeFormatsA(,,) -> %p\n", rv);
    };
    return rv;
}

BOOL __stdcall Mine_EnumTimeFormatsW(TIMEFMT_ENUMPROCW a0,
                                     LCID a1,
                                     DWORD a2)
{
    _PrintEnter("EnumTimeFormatsW(%p,%p,%p)\n", a0, a1, a2);

    BOOL rv = 0;
    __try {
        rv = Real_EnumTimeFormatsW(a0, a1, a2);
    } __finally {
        _PrintExit("EnumTimeFormatsW(,,) -> %p\n", rv);
    };
    return rv;
}

BOOL __stdcall Mine_EnumWindowStationsA(WINSTAENUMPROCA a0,
                                        LPARAM a1)
{
    _PrintEnter("EnumWindowStationsA(%p,%p)\n", a0, a1);

    BOOL rv = 0;
    __try {
        rv = Real_EnumWindowStationsA(a0, a1);
    } __finally {
        _PrintExit("EnumWindowStationsA(,) -> %p\n", rv);
    };
    return rv;
}

BOOL __stdcall Mine_EnumWindowStationsW(WINSTAENUMPROCW a0,
                                        LPARAM a1)
{
    _PrintEnter("EnumWindowStationsW(%p,%p)\n", a0, a1);

    BOOL rv = 0;
    __try {
        rv = Real_EnumWindowStationsW(a0, a1);
    } __finally {
        _PrintExit("EnumWindowStationsW(,) -> %p\n", rv);
    };
    return rv;
}

BOOL __stdcall Mine_EnumWindows(WNDENUMPROC a0,
                                LPARAM a1)
{
    _PrintEnter("EnumWindows(%p,%p)\n", a0, a1);

    BOOL rv = 0;
    __try {
        rv = Real_EnumWindows(a0, a1);
    } __finally {
        _PrintExit("EnumWindows(,) -> %p\n", rv);
    };
    return rv;
}

BOOL __stdcall Mine_EqualRect(RECT* a0,
                              RECT* a1)
{
    _PrintEnter("EqualRect(%p,%p)\n", a0, a1);

    BOOL rv = 0;
    __try {
        rv = Real_EqualRect(a0, a1);
    } __finally {
        _PrintExit("EqualRect(,) -> %p\n", rv);
    };
    return rv;
}

BOOL __stdcall Mine_EqualRgn(HRGN a0,
                             HRGN a1)
{
    _PrintEnter("EqualRgn(%p,%p)\n", a0, a1);

    BOOL rv = 0;
    __try {
        rv = Real_EqualRgn(a0, a1);
    } __finally {
        _PrintExit("EqualRgn(,) -> %p\n", rv);
    };
    return rv;
}

DWORD __stdcall Mine_EraseTape(HANDLE a0,
                               DWORD a1,
                               BOOL a2)
{
    _PrintEnter("EraseTape(%p,%p,%p)\n", a0, a1, a2);

    DWORD rv = 0;
    __try {
        rv = Real_EraseTape(a0, a1, a2);
    } __finally {
        _PrintExit("EraseTape(,,) -> %p\n", rv);
    };
    return rv;
}

int __stdcall Mine_Escape(HDC a0,
                          int a1,
                          int a2,
                          LPCSTR a3,
                          LPVOID a4)
{
    _PrintEnter("Escape(%p,%p,%p,%hs,%p)\n", a0, a1, a2, a3, a4);

    int rv = 0;
    __try {
        rv = Real_Escape(a0, a1, a2, a3, a4);
    } __finally {
        _PrintExit("Escape(,,,,) -> %p\n", rv);
    };
    return rv;
}

BOOL __stdcall Mine_EscapeCommFunction(HANDLE a0,
                                       DWORD a1)
{
    _PrintEnter("EscapeCommFunction(%p,%p)\n", a0, a1);

    BOOL rv = 0;
    __try {
        rv = Real_EscapeCommFunction(a0, a1);
    } __finally {
        _PrintExit("EscapeCommFunction(,) -> %p\n", rv);
    };
    return rv;
}

int __stdcall Mine_ExcludeClipRect(HDC a0,
                                   int a1,
                                   int a2,
                                   int a3,
                                   int a4)
{
    _PrintEnter("ExcludeClipRect(%p,%p,%p,%p,%p)\n", a0, a1, a2, a3, a4);

    int rv = 0;
    __try {
        rv = Real_ExcludeClipRect(a0, a1, a2, a3, a4);
    } __finally {
        _PrintExit("ExcludeClipRect(,,,,) -> %p\n", rv);
    };
    return rv;
}

int __stdcall Mine_ExcludeUpdateRgn(HDC a0,
                                    HWND a1)
{
    _PrintEnter("ExcludeUpdateRgn(%p,%p)\n", a0, a1);

    int rv = 0;
    __try {
        rv = Real_ExcludeUpdateRgn(a0, a1);
    } __finally {
        _PrintExit("ExcludeUpdateRgn(,) -> %p\n", rv);
    };
    return rv;
}

void __stdcall Mine_ExitProcess(UINT a0)
{
    _PrintEnter("ExitProcess(%p)\n", a0);

    __try {
        Real_ExitProcess(a0);
    } __finally {
        _PrintExit("ExitProcess() ->\n");
    };
}

void __stdcall Mine_ExitThread(DWORD a0)
{
    _PrintEnter("ExitThread(%p)\n", a0);

    __try {
        Real_ExitThread(a0);
    } __finally {
        _PrintExit("ExitThread() ->\n");
    };
}

BOOL __stdcall Mine_ExitWindowsEx(UINT a0,
                                  DWORD a1)
{
    _PrintEnter("ExitWindowsEx(%p,%p)\n", a0, a1);

    BOOL rv = 0;
    __try {
        rv = Real_ExitWindowsEx(a0, a1);
    } __finally {
        _PrintExit("ExitWindowsEx(,) -> %p\n", rv);
    };
    return rv;
}

DWORD __stdcall Mine_ExpandEnvironmentStringsA(LPCSTR a0,
                                               LPSTR a1,
                                               DWORD a2)
{
    _PrintEnter("ExpandEnvironmentStringsA(%hs,%p,%p)\n", a0, a1, a2);

    DWORD rv = 0;
    __try {
        rv = Real_ExpandEnvironmentStringsA(a0, a1, a2);
    } __finally {
        _PrintExit("ExpandEnvironmentStringsA(,%hs,) -> %p\n", a1, rv);
    };
    return rv;
}

DWORD __stdcall Mine_ExpandEnvironmentStringsW(LPCWSTR a0,
                                               LPWSTR a1,
                                               DWORD a2)
{
    _PrintEnter("ExpandEnvironmentStringsW(%ls,%p,%p)\n", a0, a1, a2);

    DWORD rv = 0;
    __try {
        rv = Real_ExpandEnvironmentStringsW(a0, a1, a2);
    } __finally {
        _PrintExit("ExpandEnvironmentStringsW(,%ls,) -> %p\n", a1, rv);
    };
    return rv;
}

HPEN __stdcall Mine_ExtCreatePen(DWORD a0,
                                 DWORD a1,
                                 LOGBRUSH* a2,
                                 DWORD a3,
                                 DWORD* a4)
{
    _PrintEnter("ExtCreatePen(%p,%p,%p,%p,%p)\n", a0, a1, a2, a3, a4);

    HPEN rv = 0;
    __try {
        rv = Real_ExtCreatePen(a0, a1, a2, a3, a4);
    } __finally {
        _PrintExit("ExtCreatePen(,,,,) -> %p\n", rv);
    };
    return rv;
}

HRGN __stdcall Mine_ExtCreateRegion(XFORM* a0,
                                    DWORD a1,
                                    RGNDATA* a2)
{
    _PrintEnter("ExtCreateRegion(%p,%p,%p)\n", a0, a1, a2);

    HRGN rv = 0;
    __try {
        rv = Real_ExtCreateRegion(a0, a1, a2);
    } __finally {
        _PrintExit("ExtCreateRegion(,,) -> %p\n", rv);
    };
    return rv;
}

int __stdcall Mine_ExtEscape(HDC a0,
                             int a1,
                             int a2,
                             LPCSTR a3,
                             int a4,
                             LPSTR a5)
{
    _PrintEnter("ExtEscape(%p,%p,%p,%hs,%p,%p)\n", a0, a1, a2, a3, a4, a5);

    int rv = 0;
    __try {
        rv = Real_ExtEscape(a0, a1, a2, a3, a4, a5);
    } __finally {
        _PrintExit("ExtEscape(,,,,,%hs) -> %p\n", a5, rv);
    };
    return rv;
}

BOOL __stdcall Mine_ExtFloodFill(HDC a0,
                                 int a1,
                                 int a2,
                                 COLORREF a3,
                                 UINT a4)
{
    _PrintEnter("ExtFloodFill(%p,%p,%p,%p,%p)\n", a0, a1, a2, a3, a4);

    BOOL rv = 0;
    __try {
        rv = Real_ExtFloodFill(a0, a1, a2, a3, a4);
    } __finally {
        _PrintExit("ExtFloodFill(,,,,) -> %p\n", rv);
    };
    return rv;
}

int __stdcall Mine_ExtSelectClipRgn(HDC a0,
                                    HRGN a1,
                                    int a2)
{
    _PrintEnter("ExtSelectClipRgn(%p,%p,%p)\n", a0, a1, a2);

    int rv = 0;
    __try {
        rv = Real_ExtSelectClipRgn(a0, a1, a2);
    } __finally {
        _PrintExit("ExtSelectClipRgn(,,) -> %p\n", rv);
    };
    return rv;
}

BOOL __stdcall Mine_ExtTextOutA(HDC a0,
                                int a1,
                                int a2,
                                UINT a3,
                                RECT* a4,
                                LPCSTR a5,
                                UINT a6,
                                INT* a7)
{
    _PrintEnter("ExtTextOutA(%p,%p,%p,%p,%p,%hs,%p,%p)\n", a0, a1, a2, a3, a4, a5, a6, a7);

    BOOL rv = 0;
    __try {
        rv = Real_ExtTextOutA(a0, a1, a2, a3, a4, a5, a6, a7);
    } __finally {
        _PrintExit("ExtTextOutA(,,,,,,,) -> %p\n", rv);
    };
    return rv;
}

BOOL __stdcall Mine_ExtTextOutW(HDC a0,
                                int a1,
                                int a2,
                                UINT a3,
                                RECT* a4,
                                LPCWSTR a5,
                                UINT a6,
                                INT* a7)
{
    _PrintEnter("ExtTextOutW(%p,%p,%p,%p,%p,%ls,%p,%p)\n", a0, a1, a2, a3, a4, a5, a6, a7);

    BOOL rv = 0;
    __try {
        rv = Real_ExtTextOutW(a0, a1, a2, a3, a4, a5, a6, a7);
    } __finally {
        _PrintExit("ExtTextOutW(,,,,,,,) -> %p\n", rv);
    };
    return rv;
}

void __stdcall Mine_FatalAppExitA(UINT a0,
                                  LPCSTR a1)
{
    _PrintEnter("FatalAppExitA(%p,%hs)\n", a0, a1);

    __try {
        Real_FatalAppExitA(a0, a1);
    } __finally {
        _PrintExit("FatalAppExitA(,) ->\n");
    };
}

void __stdcall Mine_FatalAppExitW(UINT a0,
                                  LPCWSTR a1)
{
    _PrintEnter("FatalAppExitW(%p,%ls)\n", a0, a1);

    __try {
        Real_FatalAppExitW(a0, a1);
    } __finally {
        _PrintExit("FatalAppExitW(,) ->\n");
    };
}

void __stdcall Mine_FatalExit(int a0)
{
    _PrintEnter("FatalExit(%p)\n", a0);

    __try {
        Real_FatalExit(a0);
    } __finally {
        _PrintExit("FatalExit() ->\n");
    };
}

BOOL __stdcall Mine_FileTimeToDosDateTime(FILETIME* a0,
                                          LPWORD a1,
                                          LPWORD a2)
{
    _PrintEnter("FileTimeToDosDateTime(%p,%p,%p)\n", a0, a1, a2);

    BOOL rv = 0;
    __try {
        rv = Real_FileTimeToDosDateTime(a0, a1, a2);
    } __finally {
        _PrintExit("FileTimeToDosDateTime(,,) -> %p\n", rv);
    };
    return rv;
}

BOOL __stdcall Mine_FileTimeToLocalFileTime(FILETIME* a0,
                                            LPFILETIME a1)
{
    _PrintEnter("FileTimeToLocalFileTime(%p,%p)\n", a0, a1);

    BOOL rv = 0;
    __try {
        rv = Real_FileTimeToLocalFileTime(a0, a1);
    } __finally {
        _PrintExit("FileTimeToLocalFileTime(,) -> %p\n", rv);
    };
    return rv;
}

BOOL __stdcall Mine_FileTimeToSystemTime(FILETIME* a0,
                                         LPSYSTEMTIME a1)
{
    _PrintEnter("FileTimeToSystemTime(%p,%p)\n", a0, a1);

    BOOL rv = 0;
    __try {
        rv = Real_FileTimeToSystemTime(a0, a1);
    } __finally {
        _PrintExit("FileTimeToSystemTime(,) -> %p\n", rv);
    };
    return rv;
}

BOOL __stdcall Mine_FillConsoleOutputAttribute(HANDLE a0,
                                               WORD a1,
                                               DWORD a2,
                                               COORD a3,
                                               LPDWORD a4)
{
    _PrintEnter("FillConsoleOutputAttribute(%p,%p,%p,%p,%p)\n", a0, a1, a2, a3, a4);

    BOOL rv = 0;
    __try {
        rv = Real_FillConsoleOutputAttribute(a0, a1, a2, a3, a4);
    } __finally {
        _PrintExit("FillConsoleOutputAttribute(,,,,) -> %p\n", rv);
    };
    return rv;
}

BOOL __stdcall Mine_FillConsoleOutputCharacterA(HANDLE a0,
                                                CHAR a1,
                                                DWORD a2,
                                                COORD a3,
                                                LPDWORD a4)
{
    _PrintEnter("FillConsoleOutputCharacterA(%p,%p,%p,%p,%p)\n", a0, a1, a2, a3, a4);

    BOOL rv = 0;
    __try {
        rv = Real_FillConsoleOutputCharacterA(a0, a1, a2, a3, a4);
    } __finally {
        _PrintExit("FillConsoleOutputCharacterA(,,,,) -> %p\n", rv);
    };
    return rv;
}

BOOL __stdcall Mine_FillConsoleOutputCharacterW(HANDLE a0,
                                                WCHAR a1,
                                                DWORD a2,
                                                COORD a3,
                                                LPDWORD a4)
{
    _PrintEnter("FillConsoleOutputCharacterW(%p,%p,%p,%p,%p)\n", a0, a1, a2, a3, a4);

    BOOL rv = 0;
    __try {
        rv = Real_FillConsoleOutputCharacterW(a0, a1, a2, a3, a4);
    } __finally {
        _PrintExit("FillConsoleOutputCharacterW(,,,,) -> %p\n", rv);
    };
    return rv;
}

BOOL __stdcall Mine_FillPath(HDC a0)
{
    _PrintEnter("FillPath(%p)\n", a0);

    BOOL rv = 0;
    __try {
        rv = Real_FillPath(a0);
    } __finally {
        _PrintExit("FillPath() -> %p\n", rv);
    };
    return rv;
}

int __stdcall Mine_FillRect(HDC a0,
                            RECT* a1,
                            HBRUSH a2)
{
    _PrintEnter("FillRect(%p,%p,%p)\n", a0, a1, a2);

    int rv = 0;
    __try {
        rv = Real_FillRect(a0, a1, a2);
    } __finally {
        _PrintExit("FillRect(,,) -> %p\n", rv);
    };
    return rv;
}

BOOL __stdcall Mine_FillRgn(HDC a0,
                            HRGN a1,
                            HBRUSH a2)
{
    _PrintEnter("FillRgn(%p,%p,%p)\n", a0, a1, a2);

    BOOL rv = 0;
    __try {
        rv = Real_FillRgn(a0, a1, a2);
    } __finally {
        _PrintExit("FillRgn(,,) -> %p\n", rv);
    };
    return rv;
}

ATOM __stdcall Mine_FindAtomA(LPCSTR a0)
{
    _PrintEnter("FindAtomA(%hs)\n", a0);

    ATOM rv = 0;
    __try {
        rv = Real_FindAtomA(a0);
    } __finally {
        _PrintExit("FindAtomA() -> %p\n", rv);
    };
    return rv;
}

ATOM __stdcall Mine_FindAtomW(LPCWSTR a0)
{
    _PrintEnter("FindAtomW(%ls)\n", a0);

    ATOM rv = 0;
    __try {
        rv = Real_FindAtomW(a0);
    } __finally {
        _PrintExit("FindAtomW() -> %p\n", rv);
    };
    return rv;
}

BOOL __stdcall Mine_FindClose(HANDLE a0)
{
    _PrintEnter("FindClose(%p)\n", a0);

    BOOL rv = 0;
    __try {
        rv = Real_FindClose(a0);
    } __finally {
        _PrintExit("FindClose() -> %p\n", rv);
    };
    return rv;
}

BOOL __stdcall Mine_FindCloseChangeNotification(HANDLE a0)
{
    _PrintEnter("FindCloseChangeNotification(%p)\n", a0);

    BOOL rv = 0;
    __try {
        rv = Real_FindCloseChangeNotification(a0);
    } __finally {
        _PrintExit("FindCloseChangeNotification() -> %p\n", rv);
    };
    return rv;
}

HANDLE __stdcall Mine_FindFirstChangeNotificationA(LPCSTR a0,
                                                   BOOL a1,
                                                   DWORD a2)
{
    _PrintEnter("FindFirstChangeNotificationA(%hs,%p,%p)\n", a0, a1, a2);

    HANDLE rv = 0;
    __try {
        rv = Real_FindFirstChangeNotificationA(a0, a1, a2);
    } __finally {
        _PrintExit("FindFirstChangeNotificationA(,,) -> %p\n", rv);
    };
    return rv;
}

HANDLE __stdcall Mine_FindFirstChangeNotificationW(LPCWSTR a0,
                                                   BOOL a1,
                                                   DWORD a2)
{
    _PrintEnter("FindFirstChangeNotificationW(%ls,%p,%p)\n", a0, a1, a2);

    HANDLE rv = 0;
    __try {
        rv = Real_FindFirstChangeNotificationW(a0, a1, a2);
    } __finally {
        _PrintExit("FindFirstChangeNotificationW(,,) -> %p\n", rv);
    };
    return rv;
}

HANDLE __stdcall Mine_FindFirstFileA(LPCSTR a0,
                                     LPWIN32_FIND_DATAA a1)
{
    _PrintEnter("FindFirstFileA(%hs,%p)\n", a0, a1);

    HANDLE rv = 0;
    __try {
        rv = Real_FindFirstFileA(a0, a1);
    } __finally {
        _PrintExit("FindFirstFileA(,) -> %p\n", rv);
    };
    return rv;
}

HANDLE __stdcall Mine_FindFirstFileExA(LPCSTR a0,
                                       FINDEX_INFO_LEVELS a1,
                                       LPVOID a2,
                                       FINDEX_SEARCH_OPS a3,
                                       LPVOID a4,
                                       DWORD a5)
{
    _PrintEnter("FindFirstFileExA(%hs,%p,%p,%p,%p,%p)\n", a0, a1, a2, a3, a4, a5);

    HANDLE rv = 0;
    __try {
        rv = Real_FindFirstFileExA(a0, a1, a2, a3, a4, a5);
    } __finally {
        _PrintExit("FindFirstFileExA(,,,,,) -> %p\n", rv);
    };
    return rv;
}

HANDLE __stdcall Mine_FindFirstFileExW(LPCWSTR a0,
                                       FINDEX_INFO_LEVELS a1,
                                       LPVOID a2,
                                       FINDEX_SEARCH_OPS a3,
                                       LPVOID a4,
                                       DWORD a5)
{
    _PrintEnter("FindFirstFileExW(%ls,%p,%p,%p,%p,%p)\n", a0, a1, a2, a3, a4, a5);

    HANDLE rv = 0;
    __try {
        rv = Real_FindFirstFileExW(a0, a1, a2, a3, a4, a5);
    } __finally {
        _PrintExit("FindFirstFileExW(,,,,,) -> %p\n", rv);
    };
    return rv;
}

HANDLE __stdcall Mine_FindFirstFileW(LPCWSTR a0,
                                     LPWIN32_FIND_DATAW a1)
{
    _PrintEnter("FindFirstFileW(%ls,%p)\n", a0, a1);

    HANDLE rv = 0;
    __try {
        rv = Real_FindFirstFileW(a0, a1);
    } __finally {
        _PrintExit("FindFirstFileW(,) -> %p\n", rv);
    };
    return rv;
}

BOOL __stdcall Mine_FindNextChangeNotification(HANDLE a0)
{
    _PrintEnter("FindNextChangeNotification(%p)\n", a0);

    BOOL rv = 0;
    __try {
        rv = Real_FindNextChangeNotification(a0);
    } __finally {
        _PrintExit("FindNextChangeNotification() -> %p\n", rv);
    };
    return rv;
}

BOOL __stdcall Mine_FindNextFileA(HANDLE a0,
                                  LPWIN32_FIND_DATAA a1)
{
    _PrintEnter("FindNextFileA(%p,%p)\n", a0, a1);

    BOOL rv = 0;
    __try {
        rv = Real_FindNextFileA(a0, a1);
    } __finally {
        _PrintExit("FindNextFileA(,) -> %p\n", rv);
    };
    return rv;
}

BOOL __stdcall Mine_FindNextFileW(HANDLE a0,
                                  LPWIN32_FIND_DATAW a1)
{
    _PrintEnter("FindNextFileW(%p,%p)\n", a0, a1);

    BOOL rv = 0;
    __try {
        rv = Real_FindNextFileW(a0, a1);
    } __finally {
        _PrintExit("FindNextFileW(,) -> %p\n", rv);
    };
    return rv;
}

HRSRC __stdcall Mine_FindResourceA(HMODULE a0,
                                   LPCSTR a1,
                                   LPCSTR a2)
{
    _PrintEnter("FindResourceA(%p,%hs,%hs)\n", a0, a1, a2);

    HRSRC rv = 0;
    __try {
        rv = Real_FindResourceA(a0, a1, a2);
    } __finally {
        _PrintExit("FindResourceA(,,) -> %p\n", rv);
    };
    return rv;
}

HRSRC __stdcall Mine_FindResourceExA(HMODULE a0,
                                     LPCSTR a1,
                                     LPCSTR a2,
                                     WORD a3)
{
    _PrintEnter("FindResourceExA(%p,%hs,%hs,%p)\n", a0, a1, a2, a3);

    HRSRC rv = 0;
    __try {
        rv = Real_FindResourceExA(a0, a1, a2, a3);
    } __finally {
        _PrintExit("FindResourceExA(,,,) -> %p\n", rv);
    };
    return rv;
}

HRSRC __stdcall Mine_FindResourceExW(HMODULE a0,
                                     LPCWSTR a1,
                                     LPCWSTR a2,
                                     WORD a3)
{
    _PrintEnter("FindResourceExW(%p,%ls,%ls,%p)\n", a0, a1, a2, a3);

    HRSRC rv = 0;
    __try {
        rv = Real_FindResourceExW(a0, a1, a2, a3);
    } __finally {
        _PrintExit("FindResourceExW(,,,) -> %p\n", rv);
    };
    return rv;
}

HRSRC __stdcall Mine_FindResourceW(HMODULE a0,
                                   LPCWSTR a1,
                                   LPCWSTR a2)
{
    _PrintEnter("FindResourceW(%p,%ls,%ls)\n", a0, a1, a2);

    HRSRC rv = 0;
    __try {
        rv = Real_FindResourceW(a0, a1, a2);
    } __finally {
        _PrintExit("FindResourceW(,,) -> %p\n", rv);
    };
    return rv;
}

HWND __stdcall Mine_FindWindowA(LPCSTR a0,
                                LPCSTR a1)
{
    _PrintEnter("FindWindowA(%hs,%hs)\n", a0, a1);

    HWND rv = 0;
    __try {
        rv = Real_FindWindowA(a0, a1);
    } __finally {
        _PrintExit("FindWindowA(,) -> %p\n", rv);
    };
    return rv;
}

HWND __stdcall Mine_FindWindowExA(HWND a0,
                                  HWND a1,
                                  LPCSTR a2,
                                  LPCSTR a3)
{
    _PrintEnter("FindWindowExA(%p,%p,%hs,%hs)\n", a0, a1, a2, a3);

    HWND rv = 0;
    __try {
        rv = Real_FindWindowExA(a0, a1, a2, a3);
    } __finally {
        _PrintExit("FindWindowExA(,,,) -> %p\n", rv);
    };
    return rv;
}

HWND __stdcall Mine_FindWindowExW(HWND a0,
                                  HWND a1,
                                  LPCWSTR a2,
                                  LPCWSTR a3)
{
    _PrintEnter("FindWindowExW(%p,%p,%ls,%ls)\n", a0, a1, a2, a3);

    HWND rv = 0;
    __try {
        rv = Real_FindWindowExW(a0, a1, a2, a3);
    } __finally {
        _PrintExit("FindWindowExW(,,,) -> %p\n", rv);
    };
    return rv;
}

HWND __stdcall Mine_FindWindowW(LPCWSTR a0,
                                LPCWSTR a1)
{
    _PrintEnter("FindWindowW(%ls,%ls)\n", a0, a1);

    HWND rv = 0;
    __try {
        rv = Real_FindWindowW(a0, a1);
    } __finally {
        _PrintExit("FindWindowW(,) -> %p\n", rv);
    };
    return rv;
}

BOOL __stdcall Mine_FixBrushOrgEx(HDC a0,
                                  int a1,
                                  int a2,
                                  POINT* a3)
{
    _PrintEnter("FixBrushOrgEx(%p,%p,%p,%p)\n", a0, a1, a2, a3);

    BOOL rv = 0;
    __try {
        rv = Real_FixBrushOrgEx(a0, a1, a2, a3);
    } __finally {
        _PrintExit("FixBrushOrgEx(,,,) -> %p\n", rv);
    };
    return rv;
}

BOOL __stdcall Mine_FlashWindow(HWND a0,
                                BOOL a1)
{
    _PrintEnter("FlashWindow(%p,%p)\n", a0, a1);

    BOOL rv = 0;
    __try {
        rv = Real_FlashWindow(a0, a1);
    } __finally {
        _PrintExit("FlashWindow(,) -> %p\n", rv);
    };
    return rv;
}

BOOL __stdcall Mine_FlattenPath(HDC a0)
{
    _PrintEnter("FlattenPath(%p)\n", a0);

    BOOL rv = 0;
    __try {
        rv = Real_FlattenPath(a0);
    } __finally {
        _PrintExit("FlattenPath() -> %p\n", rv);
    };
    return rv;
}

BOOL __stdcall Mine_FloodFill(HDC a0,
                              int a1,
                              int a2,
                              COLORREF a3)
{
    _PrintEnter("FloodFill(%p,%p,%p,%p)\n", a0, a1, a2, a3);

    BOOL rv = 0;
    __try {
        rv = Real_FloodFill(a0, a1, a2, a3);
    } __finally {
        _PrintExit("FloodFill(,,,) -> %p\n", rv);
    };
    return rv;
}

BOOL __stdcall Mine_FlushConsoleInputBuffer(HANDLE a0)
{
    _PrintEnter("FlushConsoleInputBuffer(%p)\n", a0);

    BOOL rv = 0;
    __try {
        rv = Real_FlushConsoleInputBuffer(a0);
    } __finally {
        _PrintExit("FlushConsoleInputBuffer() -> %p\n", rv);
    };
    return rv;
}

BOOL __stdcall Mine_FlushFileBuffers(HANDLE a0)
{
    _PrintEnter("FlushFileBuffers(%p)\n", a0);

    BOOL rv = 0;
    __try {
        rv = Real_FlushFileBuffers(a0);
    } __finally {
        _PrintExit("FlushFileBuffers() -> %p\n", rv);
    };
    return rv;
}

BOOL __stdcall Mine_FlushViewOfFile(LPCVOID a0,
                                    SIZE_T a1)
{
    _PrintEnter("FlushViewOfFile(%p,%p)\n", a0, a1);

    BOOL rv = 0;
    __try {
        rv = Real_FlushViewOfFile(a0, a1);
    } __finally {
        _PrintExit("FlushViewOfFile(,) -> %p\n", rv);
    };
    return rv;
}

HRESULT __stdcall Mine_FmtIdToPropStgName(FMTID* a0,
                                          LPOLESTR a1)
{
    _PrintEnter("FmtIdToPropStgName(%p,%p)\n", a0, a1);

    HRESULT rv = 0;
    __try {
        rv = Real_FmtIdToPropStgName(a0, a1);
    } __finally {
        _PrintExit("FmtIdToPropStgName(,) -> %p\n", rv);
    };
    return rv;
}

int __stdcall Mine_FoldStringA(DWORD a0,
                               LPCSTR a1,
                               int a2,
                               LPSTR a3,
                               int a4)
{
    _PrintEnter("FoldStringA(%p,%hs,%p,%p,%p)\n", a0, a1, a2, a3, a4);

    int rv = 0;
    __try {
        rv = Real_FoldStringA(a0, a1, a2, a3, a4);
    } __finally {
        _PrintExit("FoldStringA(,,,%hs,) -> %p\n", a3, rv);
    };
    return rv;
}

int __stdcall Mine_FoldStringW(DWORD a0,
                               LPCWSTR a1,
                               int a2,
                               LPWSTR a3,
                               int a4)
{
    _PrintEnter("FoldStringW(%p,%ls,%p,%p,%p)\n", a0, a1, a2, a3, a4);

    int rv = 0;
    __try {
        rv = Real_FoldStringW(a0, a1, a2, a3, a4);
    } __finally {
        _PrintExit("FoldStringW(,,,%ls,) -> %p\n", a3, rv);
    };
    return rv;
}

DWORD __stdcall Mine_FormatMessageA(DWORD a0,
                                    LPCVOID a1,
                                    DWORD a2,
                                    DWORD a3,
                                    LPSTR a4,
                                    DWORD a5,
                                    va_list* a6)
{
    _PrintEnter("FormatMessageA(%p,%p,%p,%p,%p,%p,%p)\n", a0, a1, a2, a3, a4, a5, a6);

    DWORD rv = 0;
    __try {
        rv = Real_FormatMessageA(a0, a1, a2, a3, a4, a5, a6);
    } __finally {
        _PrintExit("FormatMessageA(,,,,%hs,,) -> %p\n", a4, rv);
    };
    return rv;
}

DWORD __stdcall Mine_FormatMessageW(DWORD a0,
                                    LPCVOID a1,
                                    DWORD a2,
                                    DWORD a3,
                                    LPWSTR a4,
                                    DWORD a5,
                                    va_list* a6)
{
    _PrintEnter("FormatMessageW(%p,%p,%p,%p,%p,%p,%p)\n", a0, a1, a2, a3, a4, a5, a6);

    DWORD rv = 0;
    __try {
        rv = Real_FormatMessageW(a0, a1, a2, a3, a4, a5, a6);
    } __finally {
        _PrintExit("FormatMessageW(,,,,%ls,,) -> %p\n", a4, rv);
    };
    return rv;
}

int __stdcall Mine_FrameRect(HDC a0,
                             RECT* a1,
                             HBRUSH a2)
{
    _PrintEnter("FrameRect(%p,%p,%p)\n", a0, a1, a2);

    int rv = 0;
    __try {
        rv = Real_FrameRect(a0, a1, a2);
    } __finally {
        _PrintExit("FrameRect(,,) -> %p\n", rv);
    };
    return rv;
}

BOOL __stdcall Mine_FrameRgn(HDC a0,
                             HRGN a1,
                             HBRUSH a2,
                             int a3,
                             int a4)
{
    _PrintEnter("FrameRgn(%p,%p,%p,%p,%p)\n", a0, a1, a2, a3, a4);

    BOOL rv = 0;
    __try {
        rv = Real_FrameRgn(a0, a1, a2, a3, a4);
    } __finally {
        _PrintExit("FrameRgn(,,,,) -> %p\n", rv);
    };
    return rv;
}

BOOL __stdcall Mine_FreeConsole(void)
{
    _PrintEnter("FreeConsole()\n");

    BOOL rv = 0;
    __try {
        rv = Real_FreeConsole();
    } __finally {
        _PrintExit("FreeConsole() -> %p\n", rv);
    };
    return rv;
}

BOOL __stdcall Mine_FreeDDElParam(UINT a0,
                                  LPARAM a1)
{
    _PrintEnter("FreeDDElParam(%p,%p)\n", a0, a1);

    BOOL rv = 0;
    __try {
        rv = Real_FreeDDElParam(a0, a1);
    } __finally {
        _PrintExit("FreeDDElParam(,) -> %p\n", rv);
    };
    return rv;
}

BOOL __stdcall Mine_FreeEnvironmentStringsA(LPSTR a0)
{
    _PrintEnter("FreeEnvironmentStringsA(%hs)\n", a0);

    BOOL rv = 0;
    __try {
        rv = Real_FreeEnvironmentStringsA(a0);
    } __finally {
        _PrintExit("FreeEnvironmentStringsA() -> %p\n", rv);
    };
    return rv;
}

BOOL __stdcall Mine_FreeEnvironmentStringsW(LPWSTR a0)
{
    _PrintEnter("FreeEnvironmentStringsW(%ls)\n", a0);

    BOOL rv = 0;
    __try {
        rv = Real_FreeEnvironmentStringsW(a0);
    } __finally {
        _PrintExit("FreeEnvironmentStringsW() -> %p\n", rv);
    };
    return rv;
}

BOOL __stdcall Mine_FreeLibrary(HMODULE a0)
{
    _PrintEnter("FreeLibrary(%p)\n", a0);

    BOOL rv = 0;
    __try {
        rv = Real_FreeLibrary(a0);
    } __finally {
        _PrintExit("FreeLibrary() -> %p\n", rv);
    };
    return rv;
}

void __stdcall Mine_FreeLibraryAndExitThread(HMODULE a0,
                                             DWORD a1)
{
    _PrintEnter("FreeLibraryAndExitThread(%p,%p)\n", a0, a1);

    __try {
        Real_FreeLibraryAndExitThread(a0, a1);
    } __finally {
        _PrintExit("FreeLibraryAndExitThread(,) ->\n");
    };
}

HRESULT __stdcall Mine_FreePropVariantArray(ULONG a0,
                                            PROPVARIANT* a1)
{
    _PrintEnter("FreePropVariantArray(%p,%p)\n", a0, a1);

    HRESULT rv = 0;
    __try {
        rv = Real_FreePropVariantArray(a0, a1);
    } __finally {
        _PrintExit("FreePropVariantArray(,) -> %p\n", rv);
    };
    return rv;
}

BOOL __stdcall Mine_FreeResource(HGLOBAL a0)
{
    _PrintEnter("FreeResource(%p)\n", a0);

    BOOL rv = 0;
    __try {
        rv = Real_FreeResource(a0);
    } __finally {
        _PrintExit("FreeResource() -> %p\n", rv);
    };
    return rv;
}

BOOL __stdcall Mine_GdiComment(HDC a0,
                               UINT a1,
                               BYTE* a2)
{
    _PrintEnter("GdiComment(%p,%p,%p)\n", a0, a1, a2);

    BOOL rv = 0;
    __try {
        rv = Real_GdiComment(a0, a1, a2);
    } __finally {
        _PrintExit("GdiComment(,,) -> %p\n", rv);
    };
    return rv;
}

BOOL __stdcall Mine_GdiFlush(void)
{
    _PrintEnter("GdiFlush()\n");

    BOOL rv = 0;
    __try {
        rv = Real_GdiFlush();
    } __finally {
        _PrintExit("GdiFlush() -> %p\n", rv);
    };
    return rv;
}

DWORD __stdcall Mine_GdiGetBatchLimit(void)
{
    _PrintEnter("GdiGetBatchLimit()\n");

    DWORD rv = 0;
    __try {
        rv = Real_GdiGetBatchLimit();
    } __finally {
        _PrintExit("GdiGetBatchLimit() -> %p\n", rv);
    };
    return rv;
}

DWORD __stdcall Mine_GdiSetBatchLimit(DWORD a0)
{
    _PrintEnter("GdiSetBatchLimit(%p)\n", a0);

    DWORD rv = 0;
    __try {
        rv = Real_GdiSetBatchLimit(a0);
    } __finally {
        _PrintExit("GdiSetBatchLimit() -> %p\n", rv);
    };
    return rv;
}

BOOL __stdcall Mine_GenerateConsoleCtrlEvent(DWORD a0,
                                             DWORD a1)
{
    _PrintEnter("GenerateConsoleCtrlEvent(%p,%p)\n", a0, a1);

    BOOL rv = 0;
    __try {
        rv = Real_GenerateConsoleCtrlEvent(a0, a1);
    } __finally {
        _PrintExit("GenerateConsoleCtrlEvent(,) -> %p\n", rv);
    };
    return rv;
}

UINT __stdcall Mine_GetACP(void)
{
    _PrintEnter("GetACP()\n");

    UINT rv = 0;
    __try {
        rv = Real_GetACP();
    } __finally {
        _PrintExit("GetACP() -> %p\n", rv);
    };
    return rv;
}

HWND __stdcall Mine_GetActiveWindow(void)
{
    _PrintEnter("GetActiveWindow()\n");

    HWND rv = 0;
    __try {
        rv = Real_GetActiveWindow();
    } __finally {
        _PrintExit("GetActiveWindow() -> %p\n", rv);
    };
    return rv;
}

int __stdcall Mine_GetArcDirection(HDC a0)
{
    _PrintEnter("GetArcDirection(%p)\n", a0);

    int rv = 0;
    __try {
        rv = Real_GetArcDirection(a0);
    } __finally {
        _PrintExit("GetArcDirection() -> %p\n", rv);
    };
    return rv;
}

BOOL __stdcall Mine_GetAspectRatioFilterEx(HDC a0,
                                           SIZE* a1)
{
    _PrintEnter("GetAspectRatioFilterEx(%p,%p)\n", a0, a1);

    BOOL rv = 0;
    __try {
        rv = Real_GetAspectRatioFilterEx(a0, a1);
    } __finally {
        _PrintExit("GetAspectRatioFilterEx(,) -> %p\n", rv);
    };
    return rv;
}

SHORT __stdcall Mine_GetAsyncKeyState(int a0)
{
    _PrintEnter("GetAsyncKeyState(%p)\n", a0);

    SHORT rv = 0;
    __try {
        rv = Real_GetAsyncKeyState(a0);
    } __finally {
        _PrintExit("GetAsyncKeyState() -> %p\n", rv);
    };
    return rv;
}

UINT __stdcall Mine_GetAtomNameA(ATOM a0,
                                 LPSTR a1,
                                 int a2)
{
    _PrintEnter("GetAtomNameA(%p,%p,%p)\n", a0, a1, a2);

    UINT rv = 0;
    __try {
        rv = Real_GetAtomNameA(a0, a1, a2);
    } __finally {
        _PrintExit("GetAtomNameA(,%hs,) -> %p\n", a1, rv);
    };
    return rv;
}

UINT __stdcall Mine_GetAtomNameW(ATOM a0,
                                 LPWSTR a1,
                                 int a2)
{
    _PrintEnter("GetAtomNameW(%p,%p,%p)\n", a0, a1, a2);

    UINT rv = 0;
    __try {
        rv = Real_GetAtomNameW(a0, a1, a2);
    } __finally {
        _PrintExit("GetAtomNameW(,%ls,) -> %p\n", a1, rv);
    };
    return rv;
}

BOOL __stdcall Mine_GetBinaryTypeA(LPCSTR a0,
                                   LPDWORD a1)
{
    _PrintEnter("GetBinaryTypeA(%hs,%p)\n", a0, a1);

    BOOL rv = 0;
    __try {
        rv = Real_GetBinaryTypeA(a0, a1);
    } __finally {
        _PrintExit("GetBinaryTypeA(,) -> %p\n", rv);
    };
    return rv;
}

BOOL __stdcall Mine_GetBinaryTypeW(LPCWSTR a0,
                                   LPDWORD a1)
{
    _PrintEnter("GetBinaryTypeW(%ls,%p)\n", a0, a1);

    BOOL rv = 0;
    __try {
        rv = Real_GetBinaryTypeW(a0, a1);
    } __finally {
        _PrintExit("GetBinaryTypeW(,) -> %p\n", rv);
    };
    return rv;
}

LONG __stdcall Mine_GetBitmapBits(HBITMAP a0,
                                  LONG a1,
                                  LPVOID a2)
{
    _PrintEnter("GetBitmapBits(%p,%p,%p)\n", a0, a1, a2);

    LONG rv = 0;
    __try {
        rv = Real_GetBitmapBits(a0, a1, a2);
    } __finally {
        _PrintExit("GetBitmapBits(,,) -> %p\n", rv);
    };
    return rv;
}

BOOL __stdcall Mine_GetBitmapDimensionEx(HBITMAP a0,
                                         SIZE* a1)
{
    _PrintEnter("GetBitmapDimensionEx(%p,%p)\n", a0, a1);

    BOOL rv = 0;
    __try {
        rv = Real_GetBitmapDimensionEx(a0, a1);
    } __finally {
        _PrintExit("GetBitmapDimensionEx(,) -> %p\n", rv);
    };
    return rv;
}

COLORREF __stdcall Mine_GetBkColor(HDC a0)
{
    _PrintEnter("GetBkColor(%p)\n", a0);

    COLORREF rv = 0;
    __try {
        rv = Real_GetBkColor(a0);
    } __finally {
        _PrintExit("GetBkColor() -> %p\n", rv);
    };
    return rv;
}

int __stdcall Mine_GetBkMode(HDC a0)
{
    _PrintEnter("GetBkMode(%p)\n", a0);

    int rv = 0;
    __try {
        rv = Real_GetBkMode(a0);
    } __finally {
        _PrintExit("GetBkMode() -> %p\n", rv);
    };
    return rv;
}

UINT __stdcall Mine_GetBoundsRect(HDC a0,
                                  LPRECT a1,
                                  UINT a2)
{
    _PrintEnter("GetBoundsRect(%p,%p,%p)\n", a0, a1, a2);

    UINT rv = 0;
    __try {
        rv = Real_GetBoundsRect(a0, a1, a2);
    } __finally {
        _PrintExit("GetBoundsRect(,,) -> %p\n", rv);
    };
    return rv;
}

BOOL __stdcall Mine_GetBrushOrgEx(HDC a0,
                                  POINT* a1)
{
    _PrintEnter("GetBrushOrgEx(%p,%p)\n", a0, a1);

    BOOL rv = 0;
    __try {
        rv = Real_GetBrushOrgEx(a0, a1);
    } __finally {
        _PrintExit("GetBrushOrgEx(,) -> %p\n", rv);
    };
    return rv;
}

BOOL __stdcall Mine_GetCPInfo(UINT a0,
                              LPCPINFO a1)
{
    _PrintEnter("GetCPInfo(%p,%p)\n", a0, a1);

    BOOL rv = 0;
    __try {
        rv = Real_GetCPInfo(a0, a1);
    } __finally {
        _PrintExit("GetCPInfo(,) -> %p\n", rv);
    };
    return rv;
}

HWND __stdcall Mine_GetCapture(void)
{
    _PrintEnter("GetCapture()\n");

    HWND rv = 0;
    __try {
        rv = Real_GetCapture();
    } __finally {
        _PrintExit("GetCapture() -> %p\n", rv);
    };
    return rv;
}

UINT __stdcall Mine_GetCaretBlinkTime(void)
{
    _PrintEnter("GetCaretBlinkTime()\n");

    UINT rv = 0;
    __try {
        rv = Real_GetCaretBlinkTime();
    } __finally {
        _PrintExit("GetCaretBlinkTime() -> %p\n", rv);
    };
    return rv;
}

BOOL __stdcall Mine_GetCaretPos(POINT* a0)
{
    _PrintEnter("GetCaretPos(%p)\n", a0);

    BOOL rv = 0;
    __try {
        rv = Real_GetCaretPos(a0);
    } __finally {
        _PrintExit("GetCaretPos() -> %p\n", rv);
    };
    return rv;
}

BOOL __stdcall Mine_GetCharABCWidthsA(HDC a0,
                                      UINT a1,
                                      UINT a2,
                                      LPABC a3)
{
    _PrintEnter("GetCharABCWidthsA(%p,%p,%p,%p)\n", a0, a1, a2, a3);

    BOOL rv = 0;
    __try {
        rv = Real_GetCharABCWidthsA(a0, a1, a2, a3);
    } __finally {
        _PrintExit("GetCharABCWidthsA(,,,) -> %p\n", rv);
    };
    return rv;
}

BOOL __stdcall Mine_GetCharABCWidthsFloatA(HDC a0,
                                           UINT a1,
                                           UINT a2,
                                           LPABCFLOAT a3)
{
    _PrintEnter("GetCharABCWidthsFloatA(%p,%p,%p,%p)\n", a0, a1, a2, a3);

    BOOL rv = 0;
    __try {
        rv = Real_GetCharABCWidthsFloatA(a0, a1, a2, a3);
    } __finally {
        _PrintExit("GetCharABCWidthsFloatA(,,,) -> %p\n", rv);
    };
    return rv;
}

BOOL __stdcall Mine_GetCharABCWidthsFloatW(HDC a0,
                                           UINT a1,
                                           UINT a2,
                                           LPABCFLOAT a3)
{
    _PrintEnter("GetCharABCWidthsFloatW(%p,%p,%p,%p)\n", a0, a1, a2, a3);

    BOOL rv = 0;
    __try {
        rv = Real_GetCharABCWidthsFloatW(a0, a1, a2, a3);
    } __finally {
        _PrintExit("GetCharABCWidthsFloatW(,,,) -> %p\n", rv);
    };
    return rv;
}

BOOL __stdcall Mine_GetCharABCWidthsW(HDC a0,
                                      UINT a1,
                                      UINT a2,
                                      LPABC a3)
{
    _PrintEnter("GetCharABCWidthsW(%p,%p,%p,%p)\n", a0, a1, a2, a3);

    BOOL rv = 0;
    __try {
        rv = Real_GetCharABCWidthsW(a0, a1, a2, a3);
    } __finally {
        _PrintExit("GetCharABCWidthsW(,,,) -> %p\n", rv);
    };
    return rv;
}

BOOL __stdcall Mine_GetCharWidth32A(HDC a0,
                                    UINT a1,
                                    UINT a2,
                                    LPINT a3)
{
    _PrintEnter("GetCharWidth32A(%p,%p,%p,%p)\n", a0, a1, a2, a3);

    BOOL rv = 0;
    __try {
        rv = Real_GetCharWidth32A(a0, a1, a2, a3);
    } __finally {
        _PrintExit("GetCharWidth32A(,,,) -> %p\n", rv);
    };
    return rv;
}

BOOL __stdcall Mine_GetCharWidth32W(HDC a0,
                                    UINT a1,
                                    UINT a2,
                                    LPINT a3)
{
    _PrintEnter("GetCharWidth32W(%p,%p,%p,%p)\n", a0, a1, a2, a3);

    BOOL rv = 0;
    __try {
        rv = Real_GetCharWidth32W(a0, a1, a2, a3);
    } __finally {
        _PrintExit("GetCharWidth32W(,,,) -> %p\n", rv);
    };
    return rv;
}

BOOL __stdcall Mine_GetCharWidthA(HDC a0,
                                  UINT a1,
                                  UINT a2,
                                  LPINT a3)
{
    _PrintEnter("GetCharWidthA(%p,%p,%p,%p)\n", a0, a1, a2, a3);

    BOOL rv = 0;
    __try {
        rv = Real_GetCharWidthA(a0, a1, a2, a3);
    } __finally {
        _PrintExit("GetCharWidthA(,,,) -> %p\n", rv);
    };
    return rv;
}

BOOL __stdcall Mine_GetCharWidthFloatA(HDC a0,
                                       UINT a1,
                                       UINT a2,
                                       PFLOAT a3)
{
    _PrintEnter("GetCharWidthFloatA(%p,%p,%p,%p)\n", a0, a1, a2, a3);

    BOOL rv = 0;
    __try {
        rv = Real_GetCharWidthFloatA(a0, a1, a2, a3);
    } __finally {
        _PrintExit("GetCharWidthFloatA(,,,) -> %p\n", rv);
    };
    return rv;
}

BOOL __stdcall Mine_GetCharWidthFloatW(HDC a0,
                                       UINT a1,
                                       UINT a2,
                                       PFLOAT a3)
{
    _PrintEnter("GetCharWidthFloatW(%p,%p,%p,%p)\n", a0, a1, a2, a3);

    BOOL rv = 0;
    __try {
        rv = Real_GetCharWidthFloatW(a0, a1, a2, a3);
    } __finally {
        _PrintExit("GetCharWidthFloatW(,,,) -> %p\n", rv);
    };
    return rv;
}

BOOL __stdcall Mine_GetCharWidthW(HDC a0,
                                  UINT a1,
                                  UINT a2,
                                  LPINT a3)
{
    _PrintEnter("GetCharWidthW(%p,%p,%p,%p)\n", a0, a1, a2, a3);

    BOOL rv = 0;
    __try {
        rv = Real_GetCharWidthW(a0, a1, a2, a3);
    } __finally {
        _PrintExit("GetCharWidthW(,,,) -> %p\n", rv);
    };
    return rv;
}

DWORD __stdcall Mine_GetCharacterPlacementA(HDC a0,
                                            LPCSTR a1,
                                            int a2,
                                            int a3,
                                            LPGCP_RESULTSA a4,
                                            DWORD a5)
{
    _PrintEnter("GetCharacterPlacementA(%p,%hs,%p,%p,%p,%p)\n", a0, a1, a2, a3, a4, a5);

    DWORD rv = 0;
    __try {
        rv = Real_GetCharacterPlacementA(a0, a1, a2, a3, a4, a5);
    } __finally {
        _PrintExit("GetCharacterPlacementA(,,,,,) -> %p\n", rv);
    };
    return rv;
}

DWORD __stdcall Mine_GetCharacterPlacementW(HDC a0,
                                            LPCWSTR a1,
                                            int a2,
                                            int a3,
                                            LPGCP_RESULTSW a4,
                                            DWORD a5)
{
    _PrintEnter("GetCharacterPlacementW(%p,%ls,%p,%p,%p,%p)\n", a0, a1, a2, a3, a4, a5);

    DWORD rv = 0;
    __try {
        rv = Real_GetCharacterPlacementW(a0, a1, a2, a3, a4, a5);
    } __finally {
        _PrintExit("GetCharacterPlacementW(,,,,,) -> %p\n", rv);
    };
    return rv;
}

HRESULT __stdcall Mine_GetClassFile(LPCOLESTR a0,
                                    CLSID* a1)
{
    _PrintEnter("GetClassFile(%p,%p)\n", a0, a1);

    HRESULT rv = 0;
    __try {
        rv = Real_GetClassFile(a0, a1);
    } __finally {
        _PrintExit("GetClassFile(,) -> %p\n", rv);
    };
    return rv;
}

BOOL __stdcall Mine_GetClassInfoA(HINSTANCE a0,
                                  LPCSTR a1,
                                  LPWNDCLASSA a2)
{
    _PrintEnter("GetClassInfoA(%p,%hs,%p)\n", a0, a1, a2);

    BOOL rv = 0;
    __try {
        rv = Real_GetClassInfoA(a0, a1, a2);
    } __finally {
        _PrintExit("GetClassInfoA(,,) -> %p\n", rv);
    };
    return rv;
}

BOOL __stdcall Mine_GetClassInfoExA(HINSTANCE a0,
                                    LPCSTR a1,
                                    LPWNDCLASSEXA a2)
{
    _PrintEnter("GetClassInfoExA(%p,%hs,%p)\n", a0, a1, a2);

    BOOL rv = 0;
    __try {
        rv = Real_GetClassInfoExA(a0, a1, a2);
    } __finally {
        _PrintExit("GetClassInfoExA(,,) -> %p\n", rv);
    };
    return rv;
}

BOOL __stdcall Mine_GetClassInfoExW(HINSTANCE a0,
                                    LPCWSTR a1,
                                    LPWNDCLASSEXW a2)
{
    _PrintEnter("GetClassInfoExW(%p,%ls,%p)\n", a0, a1, a2);

    BOOL rv = 0;
    __try {
        rv = Real_GetClassInfoExW(a0, a1, a2);
    } __finally {
        _PrintExit("GetClassInfoExW(,,) -> %p\n", rv);
    };
    return rv;
}

BOOL __stdcall Mine_GetClassInfoW(HINSTANCE a0,
                                  LPCWSTR a1,
                                  LPWNDCLASSW a2)
{
    _PrintEnter("GetClassInfoW(%p,%ls,%p)\n", a0, a1, a2);

    BOOL rv = 0;
    __try {
        rv = Real_GetClassInfoW(a0, a1, a2);
    } __finally {
        _PrintExit("GetClassInfoW(,,) -> %p\n", rv);
    };
    return rv;
}

DWORD __stdcall Mine_GetClassLongA(HWND a0,
                                   int a1)
{
    _PrintEnter("GetClassLongA(%p,%p)\n", a0, a1);

    DWORD rv = 0;
    __try {
        rv = Real_GetClassLongA(a0, a1);
    } __finally {
        _PrintExit("GetClassLongA(,) -> %p\n", rv);
    };
    return rv;
}

DWORD __stdcall Mine_GetClassLongW(HWND a0,
                                   int a1)
{
    _PrintEnter("GetClassLongW(%p,%p)\n", a0, a1);

    DWORD rv = 0;
    __try {
        rv = Real_GetClassLongW(a0, a1);
    } __finally {
        _PrintExit("GetClassLongW(,) -> %p\n", rv);
    };
    return rv;
}

int __stdcall Mine_GetClassNameA(HWND a0,
                                 LPSTR a1,
                                 int a2)
{
    _PrintEnter("GetClassNameA(%p,%p,%p)\n", a0, a1, a2);

    int rv = 0;
    __try {
        rv = Real_GetClassNameA(a0, a1, a2);
    } __finally {
        _PrintExit("GetClassNameA(,%hs,) -> %p\n", a1, rv);
    };
    return rv;
}

int __stdcall Mine_GetClassNameW(HWND a0,
                                 LPWSTR a1,
                                 int a2)
{
    _PrintEnter("GetClassNameW(%p,%p,%p)\n", a0, a1, a2);

    int rv = 0;
    __try {
        rv = Real_GetClassNameW(a0, a1, a2);
    } __finally {
        _PrintExit("GetClassNameW(,%ls,) -> %p\n", a1, rv);
    };
    return rv;
}

WORD __stdcall Mine_GetClassWord(HWND a0,
                                 int a1)
{
    _PrintEnter("GetClassWord(%p,%p)\n", a0, a1);

    WORD rv = 0;
    __try {
        rv = Real_GetClassWord(a0, a1);
    } __finally {
        _PrintExit("GetClassWord(,) -> %p\n", rv);
    };
    return rv;
}

BOOL __stdcall Mine_GetClientRect(HWND a0,
                                  LPRECT a1)
{
    _PrintEnter("GetClientRect(%p,%p)\n", a0, a1);

    BOOL rv = 0;
    __try {
        rv = Real_GetClientRect(a0, a1);
    } __finally {
        _PrintExit("GetClientRect(,) -> %p\n", rv);
    };
    return rv;
}

int __stdcall Mine_GetClipBox(HDC a0,
                              LPRECT a1)
{
    _PrintEnter("GetClipBox(%p,%p)\n", a0, a1);

    int rv = 0;
    __try {
        rv = Real_GetClipBox(a0, a1);
    } __finally {
        _PrintExit("GetClipBox(,) -> %p\n", rv);
    };
    return rv;
}

BOOL __stdcall Mine_GetClipCursor(LPRECT a0)
{
    _PrintEnter("GetClipCursor(%p)\n", a0);

    BOOL rv = 0;
    __try {
        rv = Real_GetClipCursor(a0);
    } __finally {
        _PrintExit("GetClipCursor() -> %p\n", rv);
    };
    return rv;
}

int __stdcall Mine_GetClipRgn(HDC a0,
                              HRGN a1)
{
    _PrintEnter("GetClipRgn(%p,%p)\n", a0, a1);

    int rv = 0;
    __try {
        rv = Real_GetClipRgn(a0, a1);
    } __finally {
        _PrintExit("GetClipRgn(,) -> %p\n", rv);
    };
    return rv;
}

HANDLE __stdcall Mine_GetClipboardData(UINT a0)
{
    _PrintEnter("GetClipboardData(%p)\n", a0);

    HANDLE rv = 0;
    __try {
        rv = Real_GetClipboardData(a0);
    } __finally {
        _PrintExit("GetClipboardData() -> %p\n", rv);
    };
    return rv;
}

int __stdcall Mine_GetClipboardFormatNameA(UINT a0,
                                           LPSTR a1,
                                           int a2)
{
    _PrintEnter("GetClipboardFormatNameA(%p,%p,%p)\n", a0, a1, a2);

    int rv = 0;
    __try {
        rv = Real_GetClipboardFormatNameA(a0, a1, a2);
    } __finally {
        _PrintExit("GetClipboardFormatNameA(,%hs,) -> %p\n", a1, rv);
    };
    return rv;
}

int __stdcall Mine_GetClipboardFormatNameW(UINT a0,
                                           LPWSTR a1,
                                           int a2)
{
    _PrintEnter("GetClipboardFormatNameW(%p,%p,%p)\n", a0, a1, a2);

    int rv = 0;
    __try {
        rv = Real_GetClipboardFormatNameW(a0, a1, a2);
    } __finally {
        _PrintExit("GetClipboardFormatNameW(,%ls,) -> %p\n", a1, rv);
    };
    return rv;
}

HWND __stdcall Mine_GetClipboardOwner(void)
{
    _PrintEnter("GetClipboardOwner()\n");

    HWND rv = 0;
    __try {
        rv = Real_GetClipboardOwner();
    } __finally {
        _PrintExit("GetClipboardOwner() -> %p\n", rv);
    };
    return rv;
}

HWND __stdcall Mine_GetClipboardViewer(void)
{
    _PrintEnter("GetClipboardViewer()\n");

    HWND rv = 0;
    __try {
        rv = Real_GetClipboardViewer();
    } __finally {
        _PrintExit("GetClipboardViewer() -> %p\n", rv);
    };
    return rv;
}

BOOL __stdcall Mine_GetColorAdjustment(HDC a0,
                                       LPCOLORADJUSTMENT a1)
{
    _PrintEnter("GetColorAdjustment(%p,%p)\n", a0, a1);

    BOOL rv = 0;
    __try {
        rv = Real_GetColorAdjustment(a0, a1);
    } __finally {
        _PrintExit("GetColorAdjustment(,) -> %p\n", rv);
    };
    return rv;
}

HCOLORSPACE __stdcall Mine_GetColorSpace(HDC a0)
{
    _PrintEnter("GetColorSpace(%p)\n", a0);

    HCOLORSPACE rv = 0;
    __try {
        rv = Real_GetColorSpace(a0);
    } __finally {
        _PrintExit("GetColorSpace() -> %p\n", rv);
    };
    return rv;
}

BOOL __stdcall Mine_GetCommConfig(HANDLE a0,
                                  LPCOMMCONFIG a1,
                                  LPDWORD a2)
{
    _PrintEnter("GetCommConfig(%p,%p,%p)\n", a0, a1, a2);

    BOOL rv = 0;
    __try {
        rv = Real_GetCommConfig(a0, a1, a2);
    } __finally {
        _PrintExit("GetCommConfig(,,) -> %p\n", rv);
    };
    return rv;
}

BOOL __stdcall Mine_GetCommMask(HANDLE a0,
                                LPDWORD a1)
{
    _PrintEnter("GetCommMask(%p,%p)\n", a0, a1);

    BOOL rv = 0;
    __try {
        rv = Real_GetCommMask(a0, a1);
    } __finally {
        _PrintExit("GetCommMask(,) -> %p\n", rv);
    };
    return rv;
}

BOOL __stdcall Mine_GetCommModemStatus(HANDLE a0,
                                       LPDWORD a1)
{
    _PrintEnter("GetCommModemStatus(%p,%p)\n", a0, a1);

    BOOL rv = 0;
    __try {
        rv = Real_GetCommModemStatus(a0, a1);
    } __finally {
        _PrintExit("GetCommModemStatus(,) -> %p\n", rv);
    };
    return rv;
}

BOOL __stdcall Mine_GetCommProperties(HANDLE a0,
                                      LPCOMMPROP a1)
{
    _PrintEnter("GetCommProperties(%p,%p)\n", a0, a1);

    BOOL rv = 0;
    __try {
        rv = Real_GetCommProperties(a0, a1);
    } __finally {
        _PrintExit("GetCommProperties(,) -> %p\n", rv);
    };
    return rv;
}

BOOL __stdcall Mine_GetCommState(HANDLE a0,
                                 LPDCB a1)
{
    _PrintEnter("GetCommState(%p,%p)\n", a0, a1);

    BOOL rv = 0;
    __try {
        rv = Real_GetCommState(a0, a1);
    } __finally {
        _PrintExit("GetCommState(,) -> %p\n", rv);
    };
    return rv;
}

BOOL __stdcall Mine_GetCommTimeouts(HANDLE a0,
                                    LPCOMMTIMEOUTS a1)
{
    _PrintEnter("GetCommTimeouts(%p,%p)\n", a0, a1);

    BOOL rv = 0;
    __try {
        rv = Real_GetCommTimeouts(a0, a1);
    } __finally {
        _PrintExit("GetCommTimeouts(,) -> %p\n", rv);
    };
    return rv;
}

LPSTR __stdcall Mine_GetCommandLineA(void)
{
    _PrintEnter("GetCommandLineA()\n");

    LPSTR rv = 0;
    __try {
        rv = Real_GetCommandLineA();
    } __finally {
        _PrintExit("GetCommandLineA() -> %hs\n", rv);
    };
    return rv;
}

LPWSTR __stdcall Mine_GetCommandLineW(void)
{
    _PrintEnter("GetCommandLineW()\n");

    LPWSTR rv = 0;
    __try {
        rv = Real_GetCommandLineW();
    } __finally {
        _PrintExit("GetCommandLineW() -> %ls\n", rv);
    };
    return rv;
}

BOOL __stdcall Mine_GetComputerNameA(LPSTR a0,
                                     LPDWORD a1)
{
    _PrintEnter("GetComputerNameA(%p,%p)\n", a0, a1);

    BOOL rv = 0;
    __try {
        rv = Real_GetComputerNameA(a0, a1);
    } __finally {
        _PrintExit("GetComputerNameA(%hs,) -> %p\n", a0, rv);
    };
    return rv;
}

BOOL __stdcall Mine_GetComputerNameW(LPWSTR a0,
                                     LPDWORD a1)
{
    _PrintEnter("GetComputerNameW(%p,%p)\n", a0, a1);

    BOOL rv = 0;
    __try {
        rv = Real_GetComputerNameW(a0, a1);
    } __finally {
        _PrintExit("GetComputerNameW(%ls,) -> %p\n", a0, rv);
    };
    return rv;
}

UINT __stdcall Mine_GetConsoleCP(void)
{
    _PrintEnter("GetConsoleCP()\n");

    UINT rv = 0;
    __try {
        rv = Real_GetConsoleCP();
    } __finally {
        _PrintExit("GetConsoleCP() -> %p\n", rv);
    };
    return rv;
}

BOOL __stdcall Mine_GetConsoleCursorInfo(HANDLE a0,
                                         PCONSOLE_CURSOR_INFO a1)
{
    _PrintEnter("GetConsoleCursorInfo(%p,%p)\n", a0, a1);

    BOOL rv = 0;
    __try {
        rv = Real_GetConsoleCursorInfo(a0, a1);
    } __finally {
        _PrintExit("GetConsoleCursorInfo(,) -> %p\n", rv);
    };
    return rv;
}

BOOL __stdcall Mine_GetConsoleMode(HANDLE a0,
                                   LPDWORD a1)
{
    _PrintEnter("GetConsoleMode(%p,%p)\n", a0, a1);

    BOOL rv = 0;
    __try {
        rv = Real_GetConsoleMode(a0, a1);
    } __finally {
        _PrintExit("GetConsoleMode(,) -> %p\n", rv);
    };
    return rv;
}

UINT __stdcall Mine_GetConsoleOutputCP(void)
{
    _PrintEnter("GetConsoleOutputCP()\n");

    UINT rv = 0;
    __try {
        rv = Real_GetConsoleOutputCP();
    } __finally {
        _PrintExit("GetConsoleOutputCP() -> %p\n", rv);
    };
    return rv;
}

BOOL __stdcall Mine_GetConsoleScreenBufferInfo(HANDLE a0,
                                               PCONSOLE_SCREEN_BUFFER_INFO a1)
{
    _PrintEnter("GetConsoleScreenBufferInfo(%p,%p)\n", a0, a1);

    BOOL rv = 0;
    __try {
        rv = Real_GetConsoleScreenBufferInfo(a0, a1);
    } __finally {
        _PrintExit("GetConsoleScreenBufferInfo(,) -> %p\n", rv);
    };
    return rv;
}

DWORD __stdcall Mine_GetConsoleTitleA(LPSTR a0,
                                      DWORD a1)
{
    _PrintEnter("GetConsoleTitleA(%p,%p)\n", a0, a1);

    DWORD rv = 0;
    __try {
        rv = Real_GetConsoleTitleA(a0, a1);
    } __finally {
        _PrintExit("GetConsoleTitleA(%hs,) -> %p\n", a0, rv);
    };
    return rv;
}

DWORD __stdcall Mine_GetConsoleTitleW(LPWSTR a0,
                                      DWORD a1)
{
    _PrintEnter("GetConsoleTitleW(%p,%p)\n", a0, a1);

    DWORD rv = 0;
    __try {
        rv = Real_GetConsoleTitleW(a0, a1);
    } __finally {
        _PrintExit("GetConsoleTitleW(%ls,) -> %p\n", a0, rv);
    };
    return rv;
}

HRESULT __stdcall Mine_GetConvertStg(LPSTORAGE a0)
{
    _PrintEnter("GetConvertStg(%p)\n", a0);

    HRESULT rv = 0;
    __try {
        rv = Real_GetConvertStg(a0);
    } __finally {
        _PrintExit("GetConvertStg() -> %p\n", rv);
    };
    return rv;
}

int __stdcall Mine_GetCurrencyFormatA(LCID a0,
                                      DWORD a1,
                                      LPCSTR a2,
                                      CURRENCYFMTA* a3,
                                      LPSTR a4,
                                      int a5)
{
    _PrintEnter("GetCurrencyFormatA(%p,%p,%hs,%p,%p,%p)\n", a0, a1, a2, a3, a4, a5);

    int rv = 0;
    __try {
        rv = Real_GetCurrencyFormatA(a0, a1, a2, a3, a4, a5);
    } __finally {
        _PrintExit("GetCurrencyFormatA(,,,,%hs,) -> %p\n", a4, rv);
    };
    return rv;
}

int __stdcall Mine_GetCurrencyFormatW(LCID a0,
                                      DWORD a1,
                                      LPCWSTR a2,
                                      CURRENCYFMTW* a3,
                                      LPWSTR a4,
                                      int a5)
{
    _PrintEnter("GetCurrencyFormatW(%p,%p,%ls,%p,%p,%p)\n", a0, a1, a2, a3, a4, a5);

    int rv = 0;
    __try {
        rv = Real_GetCurrencyFormatW(a0, a1, a2, a3, a4, a5);
    } __finally {
        _PrintExit("GetCurrencyFormatW(,,,,%ls,) -> %p\n", a4, rv);
    };
    return rv;
}

DWORD __stdcall Mine_GetCurrentDirectoryA(DWORD a0,
                                          LPSTR a1)
{
    _PrintEnter("GetCurrentDirectoryA(%p,%p)\n", a0, a1);

    DWORD rv = 0;
    __try {
        rv = Real_GetCurrentDirectoryA(a0, a1);
    } __finally {
        _PrintExit("GetCurrentDirectoryA(,%hs) -> %p\n", a1, rv);
    };
    return rv;
}

DWORD __stdcall Mine_GetCurrentDirectoryW(DWORD a0,
                                          LPWSTR a1)
{
    _PrintEnter("GetCurrentDirectoryW(%p,%p)\n", a0, a1);

    DWORD rv = 0;
    __try {
        rv = Real_GetCurrentDirectoryW(a0, a1);
    } __finally {
        _PrintExit("GetCurrentDirectoryW(,%ls) -> %p\n", a1, rv);
    };
    return rv;
}

HGDIOBJ __stdcall Mine_GetCurrentObject(HDC a0,
                                        UINT a1)
{
    _PrintEnter("GetCurrentObject(%p,%p)\n", a0, a1);

    HGDIOBJ rv = 0;
    __try {
        rv = Real_GetCurrentObject(a0, a1);
    } __finally {
        _PrintExit("GetCurrentObject(,) -> %p\n", rv);
    };
    return rv;
}

BOOL __stdcall Mine_GetCurrentPositionEx(HDC a0,
                                         POINT* a1)
{
    _PrintEnter("GetCurrentPositionEx(%p,%p)\n", a0, a1);

    BOOL rv = 0;
    __try {
        rv = Real_GetCurrentPositionEx(a0, a1);
    } __finally {
        _PrintExit("GetCurrentPositionEx(,) -> %p\n", rv);
    };
    return rv;
}

HANDLE __stdcall Mine_GetCurrentProcess(void)
{
    _PrintEnter("GetCurrentProcess()\n");

    HANDLE rv = 0;
    __try {
        rv = Real_GetCurrentProcess();
    } __finally {
        _PrintExit("GetCurrentProcess() -> %p\n", rv);
    };
    return rv;
}

DWORD __stdcall Mine_GetCurrentProcessId(void)
{
    _PrintEnter("GetCurrentProcessId()\n");

    DWORD rv = 0;
    __try {
        rv = Real_GetCurrentProcessId();
    } __finally {
        _PrintExit("GetCurrentProcessId() -> %p\n", rv);
    };
    return rv;
}

DWORD __stdcall Mine_GetCurrentThreadId(void)
{
    _PrintEnter("GetCurrentThreadId()\n");

    DWORD rv = 0;
    __try {
        rv = Real_GetCurrentThreadId();
    } __finally {
        _PrintExit("GetCurrentThreadId() -> %p\n", rv);
    };
    return rv;
}

HCURSOR __stdcall Mine_GetCursor(void)
{
    _PrintEnter("GetCursor()\n");

    HCURSOR rv = 0;
    __try {
        rv = Real_GetCursor();
    } __finally {
        _PrintExit("GetCursor() -> %p\n", rv);
    };
    return rv;
}

BOOL __stdcall Mine_GetCursorPos(POINT* a0)
{
    _PrintEnter("GetCursorPos(%p)\n", a0);

    BOOL rv = 0;
    __try {
        rv = Real_GetCursorPos(a0);
    } __finally {
        _PrintExit("GetCursorPos() -> %p\n", rv);
    };
    return rv;
}

HDC __stdcall Mine_GetDC(HWND a0)
{
    _PrintEnter("GetDC(%p)\n", a0);

    HDC rv = 0;
    __try {
        rv = Real_GetDC(a0);
    } __finally {
        _PrintExit("GetDC() -> %p\n", rv);
    };
    return rv;
}

HDC __stdcall Mine_GetDCEx(HWND a0,
                           HRGN a1,
                           DWORD a2)
{
    _PrintEnter("GetDCEx(%p,%p,%p)\n", a0, a1, a2);

    HDC rv = 0;
    __try {
        rv = Real_GetDCEx(a0, a1, a2);
    } __finally {
        _PrintExit("GetDCEx(,,) -> %p\n", rv);
    };
    return rv;
}

BOOL __stdcall Mine_GetDCOrgEx(HDC a0,
                               POINT* a1)
{
    _PrintEnter("GetDCOrgEx(%p,%p)\n", a0, a1);

    BOOL rv = 0;
    __try {
        rv = Real_GetDCOrgEx(a0, a1);
    } __finally {
        _PrintExit("GetDCOrgEx(,) -> %p\n", rv);
    };
    return rv;
}

UINT __stdcall Mine_GetDIBColorTable(HDC a0,
                                     UINT a1,
                                     UINT a2,
                                     RGBQUAD* a3)
{
    _PrintEnter("GetDIBColorTable(%p,%p,%p,%p)\n", a0, a1, a2, a3);

    UINT rv = 0;
    __try {
        rv = Real_GetDIBColorTable(a0, a1, a2, a3);
    } __finally {
        _PrintExit("GetDIBColorTable(,,,) -> %p\n", rv);
    };
    return rv;
}

int __stdcall Mine_GetDIBits(HDC a0,
                             HBITMAP a1,
                             UINT a2,
                             UINT a3,
                             LPVOID a4,
                             LPBITMAPINFO a5,
                             UINT a6)
{
    _PrintEnter("GetDIBits(%p,%p,%p,%p,%p,%p,%p)\n", a0, a1, a2, a3, a4, a5, a6);

    int rv = 0;
    __try {
        rv = Real_GetDIBits(a0, a1, a2, a3, a4, a5, a6);
    } __finally {
        _PrintExit("GetDIBits(,,,,,,) -> %p\n", rv);
    };
    return rv;
}

int __stdcall Mine_GetDateFormatA(LCID a0,
                                  DWORD a1,
                                  SYSTEMTIME* a2,
                                  LPCSTR a3,
                                  LPSTR a4,
                                  int a5)
{
    _PrintEnter("GetDateFormatA(%p,%p,%p,%hs,%p,%p)\n", a0, a1, a2, a3, a4, a5);

    int rv = 0;
    __try {
        rv = Real_GetDateFormatA(a0, a1, a2, a3, a4, a5);
    } __finally {
        _PrintExit("GetDateFormatA(,,,,%hs,) -> %p\n", a4, rv);
    };
    return rv;
}

int __stdcall Mine_GetDateFormatW(LCID a0,
                                  DWORD a1,
                                  SYSTEMTIME* a2,
                                  LPCWSTR a3,
                                  LPWSTR a4,
                                  int a5)
{
    _PrintEnter("GetDateFormatW(%p,%p,%p,%ls,%p,%p)\n", a0, a1, a2, a3, a4, a5);

    int rv = 0;
    __try {
        rv = Real_GetDateFormatW(a0, a1, a2, a3, a4, a5);
    } __finally {
        _PrintExit("GetDateFormatW(,,,,%ls,) -> %p\n", a4, rv);
    };
    return rv;
}

BOOL __stdcall Mine_GetDefaultCommConfigA(LPCSTR a0,
                                          LPCOMMCONFIG a1,
                                          LPDWORD a2)
{
    _PrintEnter("GetDefaultCommConfigA(%hs,%p,%p)\n", a0, a1, a2);

    BOOL rv = 0;
    __try {
        rv = Real_GetDefaultCommConfigA(a0, a1, a2);
    } __finally {
        _PrintExit("GetDefaultCommConfigA(,,) -> %p\n", rv);
    };
    return rv;
}

BOOL __stdcall Mine_GetDefaultCommConfigW(LPCWSTR a0,
                                          LPCOMMCONFIG a1,
                                          LPDWORD a2)
{
    _PrintEnter("GetDefaultCommConfigW(%ls,%p,%p)\n", a0, a1, a2);

    BOOL rv = 0;
    __try {
        rv = Real_GetDefaultCommConfigW(a0, a1, a2);
    } __finally {
        _PrintExit("GetDefaultCommConfigW(,,) -> %p\n", rv);
    };
    return rv;
}

HWND __stdcall Mine_GetDesktopWindow(void)
{
    _PrintEnter("GetDesktopWindow()\n");

    HWND rv = 0;
    __try {
        rv = Real_GetDesktopWindow();
    } __finally {
        _PrintExit("GetDesktopWindow() -> %p\n", rv);
    };
    return rv;
}

int __stdcall Mine_GetDeviceCaps(HDC a0,
                                 int a1)
{
    _PrintEnter("GetDeviceCaps(%p,%p)\n", a0, a1);

    int rv = 0;
    __try {
        rv = Real_GetDeviceCaps(a0, a1);
    } __finally {
        _PrintExit("GetDeviceCaps(,) -> %p\n", rv);
    };
    return rv;
}

BOOL __stdcall Mine_GetDeviceGammaRamp(HDC a0,
                                       LPVOID a1)
{
    _PrintEnter("GetDeviceGammaRamp(%p,%p)\n", a0, a1);

    BOOL rv = 0;
    __try {
        rv = Real_GetDeviceGammaRamp(a0, a1);
    } __finally {
        _PrintExit("GetDeviceGammaRamp(,) -> %p\n", rv);
    };
    return rv;
}

long __stdcall Mine_GetDialogBaseUnits(void)
{
    _PrintEnter("GetDialogBaseUnits()\n");

    long rv = 0;
    __try {
        rv = Real_GetDialogBaseUnits();
    } __finally {
        _PrintExit("GetDialogBaseUnits() -> %p\n", rv);
    };
    return rv;
}

BOOL __stdcall Mine_GetDiskFreeSpaceA(LPCSTR a0,
                                      LPDWORD a1,
                                      LPDWORD a2,
                                      LPDWORD a3,
                                      LPDWORD a4)
{
    _PrintEnter("GetDiskFreeSpaceA(%hs,%p,%p,%p,%p)\n", a0, a1, a2, a3, a4);

    BOOL rv = 0;
    __try {
        rv = Real_GetDiskFreeSpaceA(a0, a1, a2, a3, a4);
    } __finally {
        _PrintExit("GetDiskFreeSpaceA(,,,,) -> %p\n", rv);
    };
    return rv;
}

BOOL __stdcall Mine_GetDiskFreeSpaceExA(LPCSTR a0,
                                        union _ULARGE_INTEGER* a1,
                                        union _ULARGE_INTEGER* a2,
                                        union _ULARGE_INTEGER* a3)
{
    _PrintEnter("GetDiskFreeSpaceExA(%hs,%p,%p,%p)\n", a0, a1, a2, a3);

    BOOL rv = 0;
    __try {
        rv = Real_GetDiskFreeSpaceExA(a0, a1, a2, a3);
    } __finally {
        _PrintExit("GetDiskFreeSpaceExA(,,,) -> %p\n", rv);
    };
    return rv;
}

BOOL __stdcall Mine_GetDiskFreeSpaceExW(LPCWSTR a0,
                                        union _ULARGE_INTEGER* a1,
                                        union _ULARGE_INTEGER* a2,
                                        union _ULARGE_INTEGER* a3)
{
    _PrintEnter("GetDiskFreeSpaceExW(%ls,%p,%p,%p)\n", a0, a1, a2, a3);

    BOOL rv = 0;
    __try {
        rv = Real_GetDiskFreeSpaceExW(a0, a1, a2, a3);
    } __finally {
        _PrintExit("GetDiskFreeSpaceExW(,,,) -> %p\n", rv);
    };
    return rv;
}

BOOL __stdcall Mine_GetDiskFreeSpaceW(LPCWSTR a0,
                                      LPDWORD a1,
                                      LPDWORD a2,
                                      LPDWORD a3,
                                      LPDWORD a4)
{
    _PrintEnter("GetDiskFreeSpaceW(%ls,%p,%p,%p,%p)\n", a0, a1, a2, a3, a4);

    BOOL rv = 0;
    __try {
        rv = Real_GetDiskFreeSpaceW(a0, a1, a2, a3, a4);
    } __finally {
        _PrintExit("GetDiskFreeSpaceW(,,,,) -> %p\n", rv);
    };
    return rv;
}

int __stdcall Mine_GetDlgCtrlID(HWND a0)
{
    _PrintEnter("GetDlgCtrlID(%p)\n", a0);

    int rv = 0;
    __try {
        rv = Real_GetDlgCtrlID(a0);
    } __finally {
        _PrintExit("GetDlgCtrlID() -> %p\n", rv);
    };
    return rv;
}

HWND __stdcall Mine_GetDlgItem(HWND a0,
                               int a1)
{
    _PrintEnter("GetDlgItem(%p,%p)\n", a0, a1);

    HWND rv = 0;
    __try {
        rv = Real_GetDlgItem(a0, a1);
    } __finally {
        _PrintExit("GetDlgItem(,) -> %p\n", rv);
    };
    return rv;
}

UINT __stdcall Mine_GetDlgItemInt(HWND a0,
                                  int a1,
                                  BOOL* a2,
                                  BOOL a3)
{
    _PrintEnter("GetDlgItemInt(%p,%p,%p,%p)\n", a0, a1, a2, a3);

    UINT rv = 0;
    __try {
        rv = Real_GetDlgItemInt(a0, a1, a2, a3);
    } __finally {
        _PrintExit("GetDlgItemInt(,,,) -> %p\n", rv);
    };
    return rv;
}

UINT __stdcall Mine_GetDlgItemTextA(HWND a0,
                                    int a1,
                                    LPSTR a2,
                                    int a3)
{
    _PrintEnter("GetDlgItemTextA(%p,%p,%p,%p)\n", a0, a1, a2, a3);

    UINT rv = 0;
    __try {
        rv = Real_GetDlgItemTextA(a0, a1, a2, a3);
    } __finally {
        _PrintExit("GetDlgItemTextA(,,%hs,) -> %p\n", a2, rv);
    };
    return rv;
}

UINT __stdcall Mine_GetDlgItemTextW(HWND a0,
                                    int a1,
                                    LPWSTR a2,
                                    int a3)
{
    _PrintEnter("GetDlgItemTextW(%p,%p,%p,%p)\n", a0, a1, a2, a3);

    UINT rv = 0;
    __try {
        rv = Real_GetDlgItemTextW(a0, a1, a2, a3);
    } __finally {
        _PrintExit("GetDlgItemTextW(,,%ls,) -> %p\n", a2, rv);
    };
    return rv;
}

UINT __stdcall Mine_GetDoubleClickTime(void)
{
    _PrintEnter("GetDoubleClickTime()\n");

    UINT rv = 0;
    __try {
        rv = Real_GetDoubleClickTime();
    } __finally {
        _PrintExit("GetDoubleClickTime() -> %p\n", rv);
    };
    return rv;
}

UINT __stdcall Mine_GetDriveTypeA(LPCSTR a0)
{
    _PrintEnter("GetDriveTypeA(%hs)\n", a0);

    UINT rv = 0;
    __try {
        rv = Real_GetDriveTypeA(a0);
    } __finally {
        _PrintExit("GetDriveTypeA() -> %p\n", rv);
    };
    return rv;
}

UINT __stdcall Mine_GetDriveTypeW(LPCWSTR a0)
{
    _PrintEnter("GetDriveTypeW(%ls)\n", a0);

    UINT rv = 0;
    __try {
        rv = Real_GetDriveTypeW(a0);
    } __finally {
        _PrintExit("GetDriveTypeW() -> %p\n", rv);
    };
    return rv;
}

HENHMETAFILE __stdcall Mine_GetEnhMetaFileA(LPCSTR a0)
{
    _PrintEnter("GetEnhMetaFileA(%hs)\n", a0);

    HENHMETAFILE rv = 0;
    __try {
        rv = Real_GetEnhMetaFileA(a0);
    } __finally {
        _PrintExit("GetEnhMetaFileA() -> %p\n", rv);
    };
    return rv;
}

UINT __stdcall Mine_GetEnhMetaFileBits(HENHMETAFILE a0,
                                       UINT a1,
                                       LPBYTE a2)
{
    _PrintEnter("GetEnhMetaFileBits(%p,%p,%p)\n", a0, a1, a2);

    UINT rv = 0;
    __try {
        rv = Real_GetEnhMetaFileBits(a0, a1, a2);
    } __finally {
        _PrintExit("GetEnhMetaFileBits(,,) -> %p\n", rv);
    };
    return rv;
}

UINT __stdcall Mine_GetEnhMetaFileDescriptionA(HENHMETAFILE a0,
                                               UINT a1,
                                               LPSTR a2)
{
    _PrintEnter("GetEnhMetaFileDescriptionA(%p,%p,%p)\n", a0, a1, a2);

    UINT rv = 0;
    __try {
        rv = Real_GetEnhMetaFileDescriptionA(a0, a1, a2);
    } __finally {
        _PrintExit("GetEnhMetaFileDescriptionA(,,%hs) -> %p\n", a2, rv);
    };
    return rv;
}

UINT __stdcall Mine_GetEnhMetaFileDescriptionW(HENHMETAFILE a0,
                                               UINT a1,
                                               LPWSTR a2)
{
    _PrintEnter("GetEnhMetaFileDescriptionW(%p,%p,%p)\n", a0, a1, a2);

    UINT rv = 0;
    __try {
        rv = Real_GetEnhMetaFileDescriptionW(a0, a1, a2);
    } __finally {
        _PrintExit("GetEnhMetaFileDescriptionW(,,%ls) -> %p\n", a2, rv);
    };
    return rv;
}

UINT __stdcall Mine_GetEnhMetaFileHeader(HENHMETAFILE a0,
                                         UINT a1,
                                         ENHMETAHEADER* a2)
{
    _PrintEnter("GetEnhMetaFileHeader(%p,%p,%p)\n", a0, a1, a2);

    UINT rv = 0;
    __try {
        rv = Real_GetEnhMetaFileHeader(a0, a1, a2);
    } __finally {
        _PrintExit("GetEnhMetaFileHeader(,,) -> %p\n", rv);
    };
    return rv;
}

UINT __stdcall Mine_GetEnhMetaFilePaletteEntries(HENHMETAFILE a0,
                                                 UINT a1,
                                                 PALETTEENTRY* a2)
{
    _PrintEnter("GetEnhMetaFilePaletteEntries(%p,%p,%p)\n", a0, a1, a2);

    UINT rv = 0;
    __try {
        rv = Real_GetEnhMetaFilePaletteEntries(a0, a1, a2);
    } __finally {
        _PrintExit("GetEnhMetaFilePaletteEntries(,,) -> %p\n", rv);
    };
    return rv;
}

UINT __stdcall Mine_GetEnhMetaFilePixelFormat(HENHMETAFILE a0,
                                              UINT a1,
                                              PIXELFORMATDESCRIPTOR* a2)
{
    _PrintEnter("GetEnhMetaFilePixelFormat(%p,%p,%p)\n", a0, a1, a2);

    UINT rv = 0;
    __try {
        rv = Real_GetEnhMetaFilePixelFormat(a0, a1, a2);
    } __finally {
        _PrintExit("GetEnhMetaFilePixelFormat(,,) -> %p\n", rv);
    };
    return rv;
}

HENHMETAFILE __stdcall Mine_GetEnhMetaFileW(LPCWSTR a0)
{
    _PrintEnter("GetEnhMetaFileW(%ls)\n", a0);

    HENHMETAFILE rv = 0;
    __try {
        rv = Real_GetEnhMetaFileW(a0);
    } __finally {
        _PrintExit("GetEnhMetaFileW() -> %p\n", rv);
    };
    return rv;
}

LPSTR __stdcall Mine_GetEnvironmentStrings(void)
{
    _PrintEnter("GetEnvironmentStrings()\n");

    LPSTR rv = 0;
    __try {
        rv = Real_GetEnvironmentStrings();
    } __finally {
        _PrintExit("GetEnvironmentStrings() -> %hs\n", rv);
    };
    return rv;
}

LPWSTR __stdcall Mine_GetEnvironmentStringsW(void)
{
    _PrintEnter("GetEnvironmentStringsW()\n");

    LPWSTR rv = 0;
    __try {
        rv = Real_GetEnvironmentStringsW();
    } __finally {
        _PrintExit("GetEnvironmentStringsW() -> %ls\n", rv);
    };
    return rv;
}

DWORD __stdcall Mine_GetEnvironmentVariableA(LPCSTR a0,
                                             LPSTR a1,
                                             DWORD a2)
{
    _PrintEnter("GetEnvironmentVariableA(%hs,%p,%p)\n", a0, a1, a2);

    DWORD rv = 0;
    __try {
        rv = Real_GetEnvironmentVariableA(a0, a1, a2);
    } __finally {
        _PrintExit("GetEnvironmentVariableA(,%hs,) -> %p\n", a1, rv);
    };
    return rv;
}

DWORD __stdcall Mine_GetEnvironmentVariableW(LPCWSTR a0,
                                             LPWSTR a1,
                                             DWORD a2)
{
    _PrintEnter("GetEnvironmentVariableW(%ls,%p,%p)\n", a0, a1, a2);

    DWORD rv = 0;
    __try {
        rv = Real_GetEnvironmentVariableW(a0, a1, a2);
    } __finally {
        _PrintExit("GetEnvironmentVariableW(,%ls,) -> %p\n", a1, rv);
    };
    return rv;
}

BOOL __stdcall Mine_GetExitCodeProcess(HANDLE a0,
                                       LPDWORD a1)
{
    _PrintEnter("GetExitCodeProcess(%p,%p)\n", a0, a1);

    BOOL rv = 0;
    __try {
        rv = Real_GetExitCodeProcess(a0, a1);
    } __finally {
        _PrintExit("GetExitCodeProcess(,) -> %p\n", rv);
    };
    return rv;
}

BOOL __stdcall Mine_GetExitCodeThread(HANDLE a0,
                                      LPDWORD a1)
{
    _PrintEnter("GetExitCodeThread(%p,%p)\n", a0, a1);

    BOOL rv = 0;
    __try {
        rv = Real_GetExitCodeThread(a0, a1);
    } __finally {
        _PrintExit("GetExitCodeThread(,) -> %p\n", rv);
    };
    return rv;
}

DWORD __stdcall Mine_GetFileAttributesA(LPCSTR a0)
{
    _PrintEnter("GetFileAttributesA(%hs)\n", a0);

    DWORD rv = 0;
    __try {
        rv = Real_GetFileAttributesA(a0);
    } __finally {
        _PrintExit("GetFileAttributesA() -> %p\n", rv);
    };
    return rv;
}

BOOL __stdcall Mine_GetFileAttributesExA(LPCSTR a0,
                                         enum _GET_FILEEX_INFO_LEVELS a1,
                                         LPVOID a2)
{
    _PrintEnter("GetFileAttributesExA(%hs,%p,%p)\n", a0, a1, a2);

    BOOL rv = 0;
    __try {
        rv = Real_GetFileAttributesExA(a0, a1, a2);
    } __finally {
        _PrintExit("GetFileAttributesExA(,,) -> %p\n", rv);
    };
    return rv;
}

BOOL __stdcall Mine_GetFileAttributesExW(LPCWSTR a0,
                                         enum _GET_FILEEX_INFO_LEVELS a1,
                                         LPVOID a2)
{
    _PrintEnter("GetFileAttributesExW(%ls,%p,%p)\n", a0, a1, a2);

    BOOL rv = 0;
    __try {
        rv = Real_GetFileAttributesExW(a0, a1, a2);
    } __finally {
        _PrintExit("GetFileAttributesExW(,,) -> %p\n", rv);
    };
    return rv;
}

DWORD __stdcall Mine_GetFileAttributesW(LPCWSTR a0)
{
    _PrintEnter("GetFileAttributesW(%ls)\n", a0);

    DWORD rv = 0;
    __try {
        rv = Real_GetFileAttributesW(a0);
    } __finally {
        _PrintExit("GetFileAttributesW() -> %p\n", rv);
    };
    return rv;
}

BOOL __stdcall Mine_GetFileInformationByHandle(HANDLE a0,
                                               LPBY_HANDLE_FILE_INFORMATION a1)
{
    _PrintEnter("GetFileInformationByHandle(%p,%p)\n", a0, a1);

    BOOL rv = 0;
    __try {
        rv = Real_GetFileInformationByHandle(a0, a1);
    } __finally {
        _PrintExit("GetFileInformationByHandle(,) -> %p\n", rv);
    };
    return rv;
}

DWORD __stdcall Mine_GetFileSize(HANDLE a0,
                                 LPDWORD a1)
{
    _PrintEnter("GetFileSize(%p,%p)\n", a0, a1);

    DWORD rv = 0;
    __try {
        rv = Real_GetFileSize(a0, a1);
    } __finally {
        _PrintExit("GetFileSize(,) -> %p\n", rv);
    };
    return rv;
}

BOOL __stdcall Mine_GetFileTime(HANDLE a0,
                                LPFILETIME a1,
                                LPFILETIME a2,
                                LPFILETIME a3)
{
    _PrintEnter("GetFileTime(%p,%p,%p,%p)\n", a0, a1, a2, a3);

    BOOL rv = 0;
    __try {
        rv = Real_GetFileTime(a0, a1, a2, a3);
    } __finally {
        _PrintExit("GetFileTime(,,,) -> %p\n", rv);
    };
    return rv;
}

DWORD __stdcall Mine_GetFileType(HANDLE a0)
{
    _PrintEnter("GetFileType(%p)\n", a0);

    DWORD rv = 0;
    __try {
        rv = Real_GetFileType(a0);
    } __finally {
        _PrintExit("GetFileType() -> %p\n", rv);
    };
    return rv;
}

HWND __stdcall Mine_GetFocus(void)
{
    _PrintEnter("GetFocus()\n");

    HWND rv = 0;
    __try {
        rv = Real_GetFocus();
    } __finally {
        _PrintExit("GetFocus() -> %p\n", rv);
    };
    return rv;
}

DWORD __stdcall Mine_GetFontData(HDC a0,
                                 DWORD a1,
                                 DWORD a2,
                                 LPVOID a3,
                                 DWORD a4)
{
    _PrintEnter("GetFontData(%p,%p,%p,%p,%p)\n", a0, a1, a2, a3, a4);

    DWORD rv = 0;
    __try {
        rv = Real_GetFontData(a0, a1, a2, a3, a4);
    } __finally {
        _PrintExit("GetFontData(,,,,) -> %p\n", rv);
    };
    return rv;
}

DWORD __stdcall Mine_GetFontLanguageInfo(HDC a0)
{
    _PrintEnter("GetFontLanguageInfo(%p)\n", a0);

    DWORD rv = 0;
    __try {
        rv = Real_GetFontLanguageInfo(a0);
    } __finally {
        _PrintExit("GetFontLanguageInfo() -> %p\n", rv);
    };
    return rv;
}

HWND __stdcall Mine_GetForegroundWindow(void)
{
    _PrintEnter("GetForegroundWindow()\n");

    HWND rv = 0;
    __try {
        rv = Real_GetForegroundWindow();
    } __finally {
        _PrintExit("GetForegroundWindow() -> %p\n", rv);
    };
    return rv;
}

DWORD __stdcall Mine_GetFullPathNameA(LPCSTR a0,
                                      DWORD a1,
                                      LPSTR a2,
                                      LPSTR* a3)
{
    _PrintEnter("GetFullPathNameA(%hs,%p,%p,%p)\n", a0, a1, a2, a3);

    DWORD rv = 0;
    __try {
        rv = Real_GetFullPathNameA(a0, a1, a2, a3);
    } __finally {
        _PrintExit("GetFullPathNameA(,,%hs,) -> %p\n", a2, rv);
    };
    return rv;
}

DWORD __stdcall Mine_GetFullPathNameW(LPCWSTR a0,
                                      DWORD a1,
                                      LPWSTR a2,
                                      LPWSTR* a3)
{
    _PrintEnter("GetFullPathNameW(%ls,%p,%p,%p)\n", a0, a1, a2, a3);

    DWORD rv = 0;
    __try {
        rv = Real_GetFullPathNameW(a0, a1, a2, a3);
    } __finally {
        _PrintExit("GetFullPathNameW(,,%ls,) -> %p\n", a2, rv);
    };
    return rv;
}

DWORD __stdcall Mine_GetGlyphOutlineA(HDC a0,
                                      UINT a1,
                                      UINT a2,
                                      LPGLYPHMETRICS a3,
                                      DWORD a4,
                                      LPVOID a5,
                                      MAT2* a6)
{
    _PrintEnter("GetGlyphOutlineA(%p,%p,%p,%p,%p,%p,%p)\n", a0, a1, a2, a3, a4, a5, a6);

    DWORD rv = 0;
    __try {
        rv = Real_GetGlyphOutlineA(a0, a1, a2, a3, a4, a5, a6);
    } __finally {
        _PrintExit("GetGlyphOutlineA(,,,,,,) -> %p\n", rv);
    };
    return rv;
}

DWORD __stdcall Mine_GetGlyphOutlineW(HDC a0,
                                      UINT a1,
                                      UINT a2,
                                      LPGLYPHMETRICS a3,
                                      DWORD a4,
                                      LPVOID a5,
                                      MAT2* a6)
{
    _PrintEnter("GetGlyphOutlineW(%p,%p,%p,%p,%p,%p,%p)\n", a0, a1, a2, a3, a4, a5, a6);

    DWORD rv = 0;
    __try {
        rv = Real_GetGlyphOutlineW(a0, a1, a2, a3, a4, a5, a6);
    } __finally {
        _PrintExit("GetGlyphOutlineW(,,,,,,) -> %p\n", rv);
    };
    return rv;
}

int __stdcall Mine_GetGraphicsMode(HDC a0)
{
    _PrintEnter("GetGraphicsMode(%p)\n", a0);

    int rv = 0;
    __try {
        rv = Real_GetGraphicsMode(a0);
    } __finally {
        _PrintExit("GetGraphicsMode() -> %p\n", rv);
    };
    return rv;
}

HRESULT __stdcall Mine_GetHGlobalFromILockBytes(ILockBytes* a0,
                                                HGLOBAL* a1)
{
    _PrintEnter("GetHGlobalFromILockBytes(%p,%p)\n", a0, a1);

    HRESULT rv = 0;
    __try {
        rv = Real_GetHGlobalFromILockBytes(a0, a1);
    } __finally {
        _PrintExit("GetHGlobalFromILockBytes(,) -> %p\n", rv);
    };
    return rv;
}

HRESULT __stdcall Mine_GetHGlobalFromStream(LPSTREAM a0,
                                            HGLOBAL* a1)
{
    _PrintEnter("GetHGlobalFromStream(%p,%p)\n", a0, a1);

    HRESULT rv = 0;
    __try {
        rv = Real_GetHGlobalFromStream(a0, a1);
    } __finally {
        _PrintExit("GetHGlobalFromStream(,) -> %p\n", rv);
    };
    return rv;
}

BOOL __stdcall Mine_GetHandleInformation(HANDLE a0,
                                         LPDWORD a1)
{
    _PrintEnter("GetHandleInformation(%p,%p)\n", a0, a1);

    BOOL rv = 0;
    __try {
        rv = Real_GetHandleInformation(a0, a1);
    } __finally {
        _PrintExit("GetHandleInformation(,) -> %p\n", rv);
    };
    return rv;
}

BOOL __stdcall Mine_GetICMProfileA(HDC a0,
                                   LPDWORD a1,
                                   LPSTR a2)
{
    _PrintEnter("GetICMProfileA(%p,%p,%p)\n", a0, a1, a2);

    BOOL rv = 0;
    __try {
        rv = Real_GetICMProfileA(a0, a1, a2);
    } __finally {
        _PrintExit("GetICMProfileA(,,%hs) -> %p\n", a2, rv);
    };
    return rv;
}

BOOL __stdcall Mine_GetICMProfileW(HDC a0,
                                   LPDWORD a1,
                                   LPWSTR a2)
{
    _PrintEnter("GetICMProfileW(%p,%p,%p)\n", a0, a1, a2);

    BOOL rv = 0;
    __try {
        rv = Real_GetICMProfileW(a0, a1, a2);
    } __finally {
        _PrintExit("GetICMProfileW(,,%ls) -> %p\n", a2, rv);
    };
    return rv;
}

BOOL __stdcall Mine_GetIconInfo(HICON a0,
                                PICONINFO a1)
{
    _PrintEnter("GetIconInfo(%p,%p)\n", a0, a1);

    BOOL rv = 0;
    __try {
        rv = Real_GetIconInfo(a0, a1);
    } __finally {
        _PrintExit("GetIconInfo(,) -> %p\n", rv);
    };
    return rv;
}

BOOL __stdcall Mine_GetInputState(void)
{
    _PrintEnter("GetInputState()\n");

    BOOL rv = 0;
    __try {
        rv = Real_GetInputState();
    } __finally {
        _PrintExit("GetInputState() -> %p\n", rv);
    };
    return rv;
}

UINT __stdcall Mine_GetKBCodePage(void)
{
    _PrintEnter("GetKBCodePage()\n");

    UINT rv = 0;
    __try {
        rv = Real_GetKBCodePage();
    } __finally {
        _PrintExit("GetKBCodePage() -> %p\n", rv);
    };
    return rv;
}

DWORD __stdcall Mine_GetKerningPairsA(HDC a0,
                                      DWORD a1,
                                      KERNINGPAIR* a2)
{
    _PrintEnter("GetKerningPairsA(%p,%p,%p)\n", a0, a1, a2);

    DWORD rv = 0;
    __try {
        rv = Real_GetKerningPairsA(a0, a1, a2);
    } __finally {
        _PrintExit("GetKerningPairsA(,,) -> %p\n", rv);
    };
    return rv;
}

DWORD __stdcall Mine_GetKerningPairsW(HDC a0,
                                      DWORD a1,
                                      KERNINGPAIR* a2)
{
    _PrintEnter("GetKerningPairsW(%p,%p,%p)\n", a0, a1, a2);

    DWORD rv = 0;
    __try {
        rv = Real_GetKerningPairsW(a0, a1, a2);
    } __finally {
        _PrintExit("GetKerningPairsW(,,) -> %p\n", rv);
    };
    return rv;
}

int __stdcall Mine_GetKeyNameTextA(LONG a0,
                                   LPSTR a1,
                                   int a2)
{
    _PrintEnter("GetKeyNameTextA(%p,%p,%p)\n", a0, a1, a2);

    int rv = 0;
    __try {
        rv = Real_GetKeyNameTextA(a0, a1, a2);
    } __finally {
        _PrintExit("GetKeyNameTextA(,%hs,) -> %p\n", a1, rv);
    };
    return rv;
}

int __stdcall Mine_GetKeyNameTextW(LONG a0,
                                   LPWSTR a1,
                                   int a2)
{
    _PrintEnter("GetKeyNameTextW(%p,%p,%p)\n", a0, a1, a2);

    int rv = 0;
    __try {
        rv = Real_GetKeyNameTextW(a0, a1, a2);
    } __finally {
        _PrintExit("GetKeyNameTextW(,%ls,) -> %p\n", a1, rv);
    };
    return rv;
}

SHORT __stdcall Mine_GetKeyState(int a0)
{
    _PrintEnter("GetKeyState(%p)\n", a0);

    SHORT rv = 0;
    __try {
        rv = Real_GetKeyState(a0);
    } __finally {
        _PrintExit("GetKeyState() -> %p\n", rv);
    };
    return rv;
}

HKL __stdcall Mine_GetKeyboardLayout(DWORD a0)
{
    _PrintEnter("GetKeyboardLayout(%p)\n", a0);

    HKL rv = 0;
    __try {
        rv = Real_GetKeyboardLayout(a0);
    } __finally {
        _PrintExit("GetKeyboardLayout() -> %p\n", rv);
    };
    return rv;
}

int __stdcall Mine_GetKeyboardLayoutList(int a0,
                                         HKL* a1)
{
    _PrintEnter("GetKeyboardLayoutList(%p,%p)\n", a0, a1);

    int rv = 0;
    __try {
        rv = Real_GetKeyboardLayoutList(a0, a1);
    } __finally {
        _PrintExit("GetKeyboardLayoutList(,) -> %p\n", rv);
    };
    return rv;
}

BOOL __stdcall Mine_GetKeyboardLayoutNameA(LPSTR a0)
{
    _PrintEnter("GetKeyboardLayoutNameA(%p)\n", a0);

    BOOL rv = 0;
    __try {
        rv = Real_GetKeyboardLayoutNameA(a0);
    } __finally {
        _PrintExit("GetKeyboardLayoutNameA(%hs) -> %p\n", a0, rv);
    };
    return rv;
}

BOOL __stdcall Mine_GetKeyboardLayoutNameW(LPWSTR a0)
{
    _PrintEnter("GetKeyboardLayoutNameW(%p)\n", a0);

    BOOL rv = 0;
    __try {
        rv = Real_GetKeyboardLayoutNameW(a0);
    } __finally {
        _PrintExit("GetKeyboardLayoutNameW(%ls) -> %p\n", a0, rv);
    };
    return rv;
}

BOOL __stdcall Mine_GetKeyboardState(PBYTE a0)
{
    _PrintEnter("GetKeyboardState(%p)\n", a0);

    BOOL rv = 0;
    __try {
        rv = Real_GetKeyboardState(a0);
    } __finally {
        _PrintExit("GetKeyboardState() -> %p\n", rv);
    };
    return rv;
}

int __stdcall Mine_GetKeyboardType(int a0)
{
    _PrintEnter("GetKeyboardType(%p)\n", a0);

    int rv = 0;
    __try {
        rv = Real_GetKeyboardType(a0);
    } __finally {
        _PrintExit("GetKeyboardType() -> %p\n", rv);
    };
    return rv;
}

HWND __stdcall Mine_GetLastActivePopup(HWND a0)
{
    _PrintEnter("GetLastActivePopup(%p)\n", a0);

    HWND rv = 0;
    __try {
        rv = Real_GetLastActivePopup(a0);
    } __finally {
        _PrintExit("GetLastActivePopup() -> %p\n", rv);
    };
    return rv;
}

void __stdcall Mine_GetLocalTime(LPSYSTEMTIME a0)
{
    _PrintEnter("GetLocalTime(%p)\n", a0);

    __try {
        Real_GetLocalTime(a0);
    } __finally {
        _PrintExit("GetLocalTime() ->\n");
    };
}

int __stdcall Mine_GetLocaleInfoA(LCID a0,
                                  LCTYPE a1,
                                  LPSTR a2,
                                  int a3)
{
    _PrintEnter("GetLocaleInfoA(%p,%p,%p,%p)\n", a0, a1, a2, a3);

    int rv = 0;
    __try {
        rv = Real_GetLocaleInfoA(a0, a1, a2, a3);
    } __finally {
        _PrintExit("GetLocaleInfoA(,,%hs,) -> %p\n", a2, rv);
    };
    return rv;
}

int __stdcall Mine_GetLocaleInfoW(LCID a0,
                                  LCTYPE a1,
                                  LPWSTR a2,
                                  int a3)
{
    _PrintEnter("GetLocaleInfoW(%p,%p,%p,%p)\n", a0, a1, a2, a3);

    int rv = 0;
    __try {
        rv = Real_GetLocaleInfoW(a0, a1, a2, a3);
    } __finally {
        _PrintExit("GetLocaleInfoW(,,%ls,) -> %p\n", a2, rv);
    };
    return rv;
}

BOOL __stdcall Mine_GetLogColorSpaceA(HCOLORSPACE a0,
                                      LOGCOLORSPACEA* a1,
                                      DWORD a2)
{
    _PrintEnter("GetLogColorSpaceA(%p,%p,%p)\n", a0, a1, a2);

    BOOL rv = 0;
    __try {
        rv = Real_GetLogColorSpaceA(a0, a1, a2);
    } __finally {
        _PrintExit("GetLogColorSpaceA(,,) -> %p\n", rv);
    };
    return rv;
}

BOOL __stdcall Mine_GetLogColorSpaceW(HCOLORSPACE a0,
                                      LOGCOLORSPACEW* a1,
                                      DWORD a2)
{
    _PrintEnter("GetLogColorSpaceW(%p,%p,%p)\n", a0, a1, a2);

    BOOL rv = 0;
    __try {
        rv = Real_GetLogColorSpaceW(a0, a1, a2);
    } __finally {
        _PrintExit("GetLogColorSpaceW(,,) -> %p\n", rv);
    };
    return rv;
}

DWORD __stdcall Mine_GetLogicalDriveStringsA(DWORD a0,
                                             LPSTR a1)
{
    _PrintEnter("GetLogicalDriveStringsA(%p,%p)\n", a0, a1);

    DWORD rv = 0;
    __try {
        rv = Real_GetLogicalDriveStringsA(a0, a1);
    } __finally {
        _PrintExit("GetLogicalDriveStringsA(,%hs) -> %p\n", a1, rv);
    };
    return rv;
}

DWORD __stdcall Mine_GetLogicalDriveStringsW(DWORD a0,
                                             LPWSTR a1)
{
    _PrintEnter("GetLogicalDriveStringsW(%p,%p)\n", a0, a1);

    DWORD rv = 0;
    __try {
        rv = Real_GetLogicalDriveStringsW(a0, a1);
    } __finally {
        _PrintExit("GetLogicalDriveStringsW(,%ls) -> %p\n", a1, rv);
    };
    return rv;
}

DWORD __stdcall Mine_GetLogicalDrives(void)
{
    _PrintEnter("GetLogicalDrives()\n");

    DWORD rv = 0;
    __try {
        rv = Real_GetLogicalDrives();
    } __finally {
        _PrintExit("GetLogicalDrives() -> %p\n", rv);
    };
    return rv;
}

BOOL __stdcall Mine_GetMailslotInfo(HANDLE a0,
                                    LPDWORD a1,
                                    LPDWORD a2,
                                    LPDWORD a3,
                                    LPDWORD a4)
{
    _PrintEnter("GetMailslotInfo(%p,%p,%p,%p,%p)\n", a0, a1, a2, a3, a4);

    BOOL rv = 0;
    __try {
        rv = Real_GetMailslotInfo(a0, a1, a2, a3, a4);
    } __finally {
        _PrintExit("GetMailslotInfo(,,,,) -> %p\n", rv);
    };
    return rv;
}

int __stdcall Mine_GetMapMode(HDC a0)
{
    _PrintEnter("GetMapMode(%p)\n", a0);

    int rv = 0;
    __try {
        rv = Real_GetMapMode(a0);
    } __finally {
        _PrintExit("GetMapMode() -> %p\n", rv);
    };
    return rv;
}

HMENU __stdcall Mine_GetMenu(HWND a0)
{
    _PrintEnter("GetMenu(%p)\n", a0);

    HMENU rv = 0;
    __try {
        rv = Real_GetMenu(a0);
    } __finally {
        _PrintExit("GetMenu() -> %p\n", rv);
    };
    return rv;
}

LONG __stdcall Mine_GetMenuCheckMarkDimensions(void)
{
    _PrintEnter("GetMenuCheckMarkDimensions()\n");

    LONG rv = 0;
    __try {
        rv = Real_GetMenuCheckMarkDimensions();
    } __finally {
        _PrintExit("GetMenuCheckMarkDimensions() -> %p\n", rv);
    };
    return rv;
}

DWORD __stdcall Mine_GetMenuContextHelpId(HMENU a0)
{
    _PrintEnter("GetMenuContextHelpId(%p)\n", a0);

    DWORD rv = 0;
    __try {
        rv = Real_GetMenuContextHelpId(a0);
    } __finally {
        _PrintExit("GetMenuContextHelpId() -> %p\n", rv);
    };
    return rv;
}

UINT __stdcall Mine_GetMenuDefaultItem(HMENU a0,
                                       UINT a1,
                                       UINT a2)
{
    _PrintEnter("GetMenuDefaultItem(%p,%p,%p)\n", a0, a1, a2);

    UINT rv = 0;
    __try {
        rv = Real_GetMenuDefaultItem(a0, a1, a2);
    } __finally {
        _PrintExit("GetMenuDefaultItem(,,) -> %p\n", rv);
    };
    return rv;
}

int __stdcall Mine_GetMenuItemCount(HMENU a0)
{
    _PrintEnter("GetMenuItemCount(%p)\n", a0);

    int rv = 0;
    __try {
        rv = Real_GetMenuItemCount(a0);
    } __finally {
        _PrintExit("GetMenuItemCount() -> %p\n", rv);
    };
    return rv;
}

UINT __stdcall Mine_GetMenuItemID(HMENU a0,
                                  int a1)
{
    _PrintEnter("GetMenuItemID(%p,%p)\n", a0, a1);

    UINT rv = 0;
    __try {
        rv = Real_GetMenuItemID(a0, a1);
    } __finally {
        _PrintExit("GetMenuItemID(,) -> %p\n", rv);
    };
    return rv;
}

BOOL __stdcall Mine_GetMenuItemInfoA(HMENU a0,
                                     UINT a1,
                                     BOOL a2,
                                     LPMENUITEMINFOA a3)
{
    _PrintEnter("GetMenuItemInfoA(%p,%p,%p,%p)\n", a0, a1, a2, a3);

    BOOL rv = 0;
    __try {
        rv = Real_GetMenuItemInfoA(a0, a1, a2, a3);
    } __finally {
        _PrintExit("GetMenuItemInfoA(,,,) -> %p\n", rv);
    };
    return rv;
}

BOOL __stdcall Mine_GetMenuItemInfoW(HMENU a0,
                                     UINT a1,
                                     BOOL a2,
                                     LPMENUITEMINFOW a3)
{
    _PrintEnter("GetMenuItemInfoW(%p,%p,%p,%p)\n", a0, a1, a2, a3);

    BOOL rv = 0;
    __try {
        rv = Real_GetMenuItemInfoW(a0, a1, a2, a3);
    } __finally {
        _PrintExit("GetMenuItemInfoW(,,,) -> %p\n", rv);
    };
    return rv;
}

BOOL __stdcall Mine_GetMenuItemRect(HWND a0,
                                    HMENU a1,
                                    UINT a2,
                                    LPRECT a3)
{
    _PrintEnter("GetMenuItemRect(%p,%p,%p,%p)\n", a0, a1, a2, a3);

    BOOL rv = 0;
    __try {
        rv = Real_GetMenuItemRect(a0, a1, a2, a3);
    } __finally {
        _PrintExit("GetMenuItemRect(,,,) -> %p\n", rv);
    };
    return rv;
}

UINT __stdcall Mine_GetMenuState(HMENU a0,
                                 UINT a1,
                                 UINT a2)
{
    _PrintEnter("GetMenuState(%p,%p,%p)\n", a0, a1, a2);

    UINT rv = 0;
    __try {
        rv = Real_GetMenuState(a0, a1, a2);
    } __finally {
        _PrintExit("GetMenuState(,,) -> %p\n", rv);
    };
    return rv;
}

int __stdcall Mine_GetMenuStringA(HMENU a0,
                                  UINT a1,
                                  LPSTR a2,
                                  int a3,
                                  UINT a4)
{
    _PrintEnter("GetMenuStringA(%p,%p,%p,%p,%p)\n", a0, a1, a2, a3, a4);

    int rv = 0;
    __try {
        rv = Real_GetMenuStringA(a0, a1, a2, a3, a4);
    } __finally {
        _PrintExit("GetMenuStringA(,,%hs,,) -> %p\n", a2, rv);
    };
    return rv;
}

int __stdcall Mine_GetMenuStringW(HMENU a0,
                                  UINT a1,
                                  LPWSTR a2,
                                  int a3,
                                  UINT a4)
{
    _PrintEnter("GetMenuStringW(%p,%p,%p,%p,%p)\n", a0, a1, a2, a3, a4);

    int rv = 0;
    __try {
        rv = Real_GetMenuStringW(a0, a1, a2, a3, a4);
    } __finally {
        _PrintExit("GetMenuStringW(,,%ls,,) -> %p\n", a2, rv);
    };
    return rv;
}

BOOL __stdcall Mine_GetMessageA(LPMSG a0,
                                HWND a1,
                                UINT a2,
                                UINT a3)
{
    _PrintEnter("GetMessageA(%p,%p,%p,%p)\n", a0, a1, a2, a3);

    BOOL rv = 0;
    __try {
        rv = Real_GetMessageA(a0, a1, a2, a3);
    } __finally {
        _PrintExit("GetMessageA(,,,) -> %p\n", rv);
    };
    return rv;
}

LPARAM __stdcall Mine_GetMessageExtraInfo(void)
{
    _PrintEnter("GetMessageExtraInfo()\n");

    LPARAM rv = 0;
    __try {
        rv = Real_GetMessageExtraInfo();
    } __finally {
        _PrintExit("GetMessageExtraInfo() -> %p\n", rv);
    };
    return rv;
}

DWORD __stdcall Mine_GetMessagePos(void)
{
    _PrintEnter("GetMessagePos()\n");

    DWORD rv = 0;
    __try {
        rv = Real_GetMessagePos();
    } __finally {
        _PrintExit("GetMessagePos() -> %p\n", rv);
    };
    return rv;
}

LONG __stdcall Mine_GetMessageTime(void)
{
    _PrintEnter("GetMessageTime()\n");

    LONG rv = 0;
    __try {
        rv = Real_GetMessageTime();
    } __finally {
        _PrintExit("GetMessageTime() -> %p\n", rv);
    };
    return rv;
}

BOOL __stdcall Mine_GetMessageW(LPMSG a0,
                                HWND a1,
                                UINT a2,
                                UINT a3)
{
    _PrintEnter("GetMessageW(%p,%p,%p,%p)\n", a0, a1, a2, a3);

    BOOL rv = 0;
    __try {
        rv = Real_GetMessageW(a0, a1, a2, a3);
    } __finally {
        _PrintExit("GetMessageW(,,,) -> %p\n", rv);
    };
    return rv;
}

HMETAFILE __stdcall Mine_GetMetaFileA(LPCSTR a0)
{
    _PrintEnter("GetMetaFileA(%hs)\n", a0);

    HMETAFILE rv = 0;
    __try {
        rv = Real_GetMetaFileA(a0);
    } __finally {
        _PrintExit("GetMetaFileA() -> %p\n", rv);
    };
    return rv;
}

UINT __stdcall Mine_GetMetaFileBitsEx(HMETAFILE a0,
                                      UINT a1,
                                      LPVOID a2)
{
    _PrintEnter("GetMetaFileBitsEx(%p,%p,%p)\n", a0, a1, a2);

    UINT rv = 0;
    __try {
        rv = Real_GetMetaFileBitsEx(a0, a1, a2);
    } __finally {
        _PrintExit("GetMetaFileBitsEx(,,) -> %p\n", rv);
    };
    return rv;
}

HMETAFILE __stdcall Mine_GetMetaFileW(LPCWSTR a0)
{
    _PrintEnter("GetMetaFileW(%ls)\n", a0);

    HMETAFILE rv = 0;
    __try {
        rv = Real_GetMetaFileW(a0);
    } __finally {
        _PrintExit("GetMetaFileW() -> %p\n", rv);
    };
    return rv;
}

int __stdcall Mine_GetMetaRgn(HDC a0,
                              HRGN a1)
{
    _PrintEnter("GetMetaRgn(%p,%p)\n", a0, a1);

    int rv = 0;
    __try {
        rv = Real_GetMetaRgn(a0, a1);
    } __finally {
        _PrintExit("GetMetaRgn(,) -> %p\n", rv);
    };
    return rv;
}

BOOL __stdcall Mine_GetMiterLimit(HDC a0,
                                  PFLOAT a1)
{
    _PrintEnter("GetMiterLimit(%p,%p)\n", a0, a1);

    BOOL rv = 0;
    __try {
        rv = Real_GetMiterLimit(a0, a1);
    } __finally {
        _PrintExit("GetMiterLimit(,) -> %p\n", rv);
    };
    return rv;
}

DWORD __stdcall Mine_GetModuleFileNameA(HMODULE a0,
                                        LPSTR a1,
                                        DWORD a2)
{
    _PrintEnter("GetModuleFileNameA(%p,%p,%p)\n", a0, a1, a2);

    DWORD rv = 0;
    __try {
        rv = Real_GetModuleFileNameA(a0, a1, a2);
    } __finally {
        _PrintExit("GetModuleFileNameA(,%hs,) -> %p\n", a1, rv);
    };
    return rv;
}

DWORD __stdcall Mine_GetModuleFileNameW(HMODULE a0,
                                        LPWSTR a1,
                                        DWORD a2)
{
    _PrintEnter("GetModuleFileNameW(%p,%p,%p)\n", a0, a1, a2);

    DWORD rv = 0;
    __try {
        rv = Real_GetModuleFileNameW(a0, a1, a2);
    } __finally {
        _PrintExit("GetModuleFileNameW(,%ls,) -> %p\n", a1, rv);
    };
    return rv;
}

HMODULE __stdcall Mine_GetModuleHandleA(LPCSTR a0)
{
    _PrintEnter("GetModuleHandleA(%hs)\n", a0);

    HMODULE rv = 0;
    __try {
        rv = Real_GetModuleHandleA(a0);
    } __finally {
        _PrintExit("GetModuleHandleA() -> %p\n", rv);
    };
    return rv;
}

HMODULE __stdcall Mine_GetModuleHandleW(LPCWSTR a0)
{
    _PrintEnter("GetModuleHandleW(%ls)\n", a0);

    HMODULE rv = 0;
    __try {
        rv = Real_GetModuleHandleW(a0);
    } __finally {
        _PrintExit("GetModuleHandleW() -> %p\n", rv);
    };
    return rv;
}

BOOL __stdcall Mine_GetNamedPipeHandleStateA(HANDLE a0,
                                             LPDWORD a1,
                                             LPDWORD a2,
                                             LPDWORD a3,
                                             LPDWORD a4,
                                             LPSTR a5,
                                             DWORD a6)
{
    _PrintEnter("GetNamedPipeHandleStateA(%p,%p,%p,%p,%p,%p,%p)\n", a0, a1, a2, a3, a4, a5, a6);

    BOOL rv = 0;
    __try {
        rv = Real_GetNamedPipeHandleStateA(a0, a1, a2, a3, a4, a5, a6);
    } __finally {
        _PrintExit("GetNamedPipeHandleStateA(,,,,,%hs,) -> %p\n", a5, rv);
    };
    return rv;
}

BOOL __stdcall Mine_GetNamedPipeHandleStateW(HANDLE a0,
                                             LPDWORD a1,
                                             LPDWORD a2,
                                             LPDWORD a3,
                                             LPDWORD a4,
                                             LPWSTR a5,
                                             DWORD a6)
{
    _PrintEnter("GetNamedPipeHandleStateW(%p,%p,%p,%p,%p,%p,%p)\n", a0, a1, a2, a3, a4, a5, a6);

    BOOL rv = 0;
    __try {
        rv = Real_GetNamedPipeHandleStateW(a0, a1, a2, a3, a4, a5, a6);
    } __finally {
        _PrintExit("GetNamedPipeHandleStateW(,,,,,%ls,) -> %p\n", a5, rv);
    };
    return rv;
}

BOOL __stdcall Mine_GetNamedPipeInfo(HANDLE a0,
                                     LPDWORD a1,
                                     LPDWORD a2,
                                     LPDWORD a3,
                                     LPDWORD a4)
{
    _PrintEnter("GetNamedPipeInfo(%p,%p,%p,%p,%p)\n", a0, a1, a2, a3, a4);

    BOOL rv = 0;
    __try {
        rv = Real_GetNamedPipeInfo(a0, a1, a2, a3, a4);
    } __finally {
        _PrintExit("GetNamedPipeInfo(,,,,) -> %p\n", rv);
    };
    return rv;
}

COLORREF __stdcall Mine_GetNearestColor(HDC a0,
                                        COLORREF a1)
{
    _PrintEnter("GetNearestColor(%p,%p)\n", a0, a1);

    COLORREF rv = 0;
    __try {
        rv = Real_GetNearestColor(a0, a1);
    } __finally {
        _PrintExit("GetNearestColor(,) -> %p\n", rv);
    };
    return rv;
}

UINT __stdcall Mine_GetNearestPaletteIndex(HPALETTE a0,
                                           COLORREF a1)
{
    _PrintEnter("GetNearestPaletteIndex(%p,%p)\n", a0, a1);

    UINT rv = 0;
    __try {
        rv = Real_GetNearestPaletteIndex(a0, a1);
    } __finally {
        _PrintExit("GetNearestPaletteIndex(,) -> %p\n", rv);
    };
    return rv;
}

HWND __stdcall Mine_GetNextDlgGroupItem(HWND a0,
                                        HWND a1,
                                        BOOL a2)
{
    _PrintEnter("GetNextDlgGroupItem(%p,%p,%p)\n", a0, a1, a2);

    HWND rv = 0;
    __try {
        rv = Real_GetNextDlgGroupItem(a0, a1, a2);
    } __finally {
        _PrintExit("GetNextDlgGroupItem(,,) -> %p\n", rv);
    };
    return rv;
}

HWND __stdcall Mine_GetNextDlgTabItem(HWND a0,
                                      HWND a1,
                                      BOOL a2)
{
    _PrintEnter("GetNextDlgTabItem(%p,%p,%p)\n", a0, a1, a2);

    HWND rv = 0;
    __try {
        rv = Real_GetNextDlgTabItem(a0, a1, a2);
    } __finally {
        _PrintExit("GetNextDlgTabItem(,,) -> %p\n", rv);
    };
    return rv;
}

int __stdcall Mine_GetNumberFormatA(LCID a0,
                                    DWORD a1,
                                    LPCSTR a2,
                                    NUMBERFMTA* a3,
                                    LPSTR a4,
                                    int a5)
{
    _PrintEnter("GetNumberFormatA(%p,%p,%hs,%p,%p,%p)\n", a0, a1, a2, a3, a4, a5);

    int rv = 0;
    __try {
        rv = Real_GetNumberFormatA(a0, a1, a2, a3, a4, a5);
    } __finally {
        _PrintExit("GetNumberFormatA(,,,,%hs,) -> %p\n", a4, rv);
    };
    return rv;
}

int __stdcall Mine_GetNumberFormatW(LCID a0,
                                    DWORD a1,
                                    LPCWSTR a2,
                                    NUMBERFMTW* a3,
                                    LPWSTR a4,
                                    int a5)
{
    _PrintEnter("GetNumberFormatW(%p,%p,%ls,%p,%p,%p)\n", a0, a1, a2, a3, a4, a5);

    int rv = 0;
    __try {
        rv = Real_GetNumberFormatW(a0, a1, a2, a3, a4, a5);
    } __finally {
        _PrintExit("GetNumberFormatW(,,,,%ls,) -> %p\n", a4, rv);
    };
    return rv;
}

BOOL __stdcall Mine_GetNumberOfConsoleInputEvents(HANDLE a0,
                                                  LPDWORD a1)
{
    _PrintEnter("GetNumberOfConsoleInputEvents(%p,%p)\n", a0, a1);

    BOOL rv = 0;
    __try {
        rv = Real_GetNumberOfConsoleInputEvents(a0, a1);
    } __finally {
        _PrintExit("GetNumberOfConsoleInputEvents(,) -> %p\n", rv);
    };
    return rv;
}

BOOL __stdcall Mine_GetNumberOfConsoleMouseButtons(LPDWORD a0)
{
    _PrintEnter("GetNumberOfConsoleMouseButtons(%p)\n", a0);

    BOOL rv = 0;
    __try {
        rv = Real_GetNumberOfConsoleMouseButtons(a0);
    } __finally {
        _PrintExit("GetNumberOfConsoleMouseButtons() -> %p\n", rv);
    };
    return rv;
}

UINT __stdcall Mine_GetOEMCP(void)
{
    _PrintEnter("GetOEMCP()\n");

    UINT rv = 0;
    __try {
        rv = Real_GetOEMCP();
    } __finally {
        _PrintExit("GetOEMCP() -> %p\n", rv);
    };
    return rv;
}

int __stdcall Mine_GetObjectA(HGDIOBJ a0,
                              int a1,
                              LPVOID a2)
{
    _PrintEnter("GetObjectA(%p,%p,%p)\n", a0, a1, a2);

    int rv = 0;
    __try {
        rv = Real_GetObjectA(a0, a1, a2);
    } __finally {
        _PrintExit("GetObjectA(,,) -> %p\n", rv);
    };
    return rv;
}

DWORD __stdcall Mine_GetObjectType(HGDIOBJ a0)
{
    _PrintEnter("GetObjectType(%p)\n", a0);

    DWORD rv = 0;
    __try {
        rv = Real_GetObjectType(a0);
    } __finally {
        _PrintExit("GetObjectType() -> %p\n", rv);
    };
    return rv;
}

int __stdcall Mine_GetObjectW(HGDIOBJ a0,
                              int a1,
                              LPVOID a2)
{
    _PrintEnter("GetObjectW(%p,%p,%p)\n", a0, a1, a2);

    int rv = 0;
    __try {
        rv = Real_GetObjectW(a0, a1, a2);
    } __finally {
        _PrintExit("GetObjectW(,,) -> %p\n", rv);
    };
    return rv;
}

HWND __stdcall Mine_GetOpenClipboardWindow(void)
{
    _PrintEnter("GetOpenClipboardWindow()\n");

    HWND rv = 0;
    __try {
        rv = Real_GetOpenClipboardWindow();
    } __finally {
        _PrintExit("GetOpenClipboardWindow() -> %p\n", rv);
    };
    return rv;
}

UINT __stdcall Mine_GetOutlineTextMetricsA(HDC a0,
                                           UINT a1,
                                           LPOUTLINETEXTMETRICA a2)
{
    _PrintEnter("GetOutlineTextMetricsA(%p,%p,%p)\n", a0, a1, a2);

    UINT rv = 0;
    __try {
        rv = Real_GetOutlineTextMetricsA(a0, a1, a2);
    } __finally {
        _PrintExit("GetOutlineTextMetricsA(,,) -> %p\n", rv);
    };
    return rv;
}

UINT __stdcall Mine_GetOutlineTextMetricsW(HDC a0,
                                           UINT a1,
                                           LPOUTLINETEXTMETRICW a2)
{
    _PrintEnter("GetOutlineTextMetricsW(%p,%p,%p)\n", a0, a1, a2);

    UINT rv = 0;
    __try {
        rv = Real_GetOutlineTextMetricsW(a0, a1, a2);
    } __finally {
        _PrintExit("GetOutlineTextMetricsW(,,) -> %p\n", rv);
    };
    return rv;
}

BOOL __stdcall Mine_GetOverlappedResult(HANDLE a0,
                                        LPOVERLAPPED a1,
                                        LPDWORD a2,
                                        BOOL a3)
{
    _PrintEnter("GetOverlappedResult(%p,%p,%p,%p)\n", a0, a1, a2, a3);

    BOOL rv = 0;
    __try {
        rv = Real_GetOverlappedResult(a0, a1, a2, a3);
    } __finally {
        _PrintExit("GetOverlappedResult(,,,) -> %p\n", rv);
    };
    return rv;
}

UINT __stdcall Mine_GetPaletteEntries(HPALETTE a0,
                                      UINT a1,
                                      UINT a2,
                                      PALETTEENTRY* a3)
{
    _PrintEnter("GetPaletteEntries(%p,%p,%p,%p)\n", a0, a1, a2, a3);

    UINT rv = 0;
    __try {
        rv = Real_GetPaletteEntries(a0, a1, a2, a3);
    } __finally {
        _PrintExit("GetPaletteEntries(,,,) -> %p\n", rv);
    };
    return rv;
}

HWND __stdcall Mine_GetParent(HWND a0)
{
    _PrintEnter("GetParent(%p)\n", a0);

    HWND rv = 0;
    __try {
        rv = Real_GetParent(a0);
    } __finally {
        _PrintExit("GetParent() -> %p\n", rv);
    };
    return rv;
}

int __stdcall Mine_GetPath(HDC a0,
                           POINT* a1,
                           LPBYTE a2,
                           int a3)
{
    _PrintEnter("GetPath(%p,%p,%p,%p)\n", a0, a1, a2, a3);

    int rv = 0;
    __try {
        rv = Real_GetPath(a0, a1, a2, a3);
    } __finally {
        _PrintExit("GetPath(,,,) -> %p\n", rv);
    };
    return rv;
}

COLORREF __stdcall Mine_GetPixel(HDC a0,
                                 int a1,
                                 int a2)
{
    _PrintEnter("GetPixel(%p,%p,%p)\n", a0, a1, a2);

    COLORREF rv = 0;
    __try {
        rv = Real_GetPixel(a0, a1, a2);
    } __finally {
        _PrintExit("GetPixel(,,) -> %p\n", rv);
    };
    return rv;
}

int __stdcall Mine_GetPixelFormat(HDC a0)
{
    _PrintEnter("GetPixelFormat(%p)\n", a0);

    int rv = 0;
    __try {
        rv = Real_GetPixelFormat(a0);
    } __finally {
        _PrintExit("GetPixelFormat() -> %p\n", rv);
    };
    return rv;
}

int __stdcall Mine_GetPolyFillMode(HDC a0)
{
    _PrintEnter("GetPolyFillMode(%p)\n", a0);

    int rv = 0;
    __try {
        rv = Real_GetPolyFillMode(a0);
    } __finally {
        _PrintExit("GetPolyFillMode() -> %p\n", rv);
    };
    return rv;
}

DWORD __stdcall Mine_GetPriorityClass(HANDLE a0)
{
    _PrintEnter("GetPriorityClass(%p)\n", a0);

    DWORD rv = 0;
    __try {
        rv = Real_GetPriorityClass(a0);
    } __finally {
        _PrintExit("GetPriorityClass() -> %p\n", rv);
    };
    return rv;
}

int __stdcall Mine_GetPriorityClipboardFormat(UINT* a0,
                                              int a1)
{
    _PrintEnter("GetPriorityClipboardFormat(%p,%p)\n", a0, a1);

    int rv = 0;
    __try {
        rv = Real_GetPriorityClipboardFormat(a0, a1);
    } __finally {
        _PrintExit("GetPriorityClipboardFormat(,) -> %p\n", rv);
    };
    return rv;
}

UINT __stdcall Mine_GetPrivateProfileIntA(LPCSTR a0,
                                          LPCSTR a1,
                                          INT a2,
                                          LPCSTR a3)
{
    _PrintEnter("GetPrivateProfileIntA(%hs,%hs,%p,%hs)\n", a0, a1, a2, a3);

    UINT rv = 0;
    __try {
        rv = Real_GetPrivateProfileIntA(a0, a1, a2, a3);
    } __finally {
        _PrintExit("GetPrivateProfileIntA(,,,) -> %p\n", rv);
    };
    return rv;
}

UINT __stdcall Mine_GetPrivateProfileIntW(LPCWSTR a0,
                                          LPCWSTR a1,
                                          INT a2,
                                          LPCWSTR a3)
{
    _PrintEnter("GetPrivateProfileIntW(%ls,%ls,%p,%ls)\n", a0, a1, a2, a3);

    UINT rv = 0;
    __try {
        rv = Real_GetPrivateProfileIntW(a0, a1, a2, a3);
    } __finally {
        _PrintExit("GetPrivateProfileIntW(,,,) -> %p\n", rv);
    };
    return rv;
}

DWORD __stdcall Mine_GetPrivateProfileSectionA(LPCSTR a0,
                                               LPSTR a1,
                                               DWORD a2,
                                               LPCSTR a3)
{
    _PrintEnter("GetPrivateProfileSectionA(%hs,%p,%p,%hs)\n", a0, a1, a2, a3);

    DWORD rv = 0;
    __try {
        rv = Real_GetPrivateProfileSectionA(a0, a1, a2, a3);
    } __finally {
        _PrintExit("GetPrivateProfileSectionA(,%hs,,) -> %p\n", a1, rv);
    };
    return rv;
}

DWORD __stdcall Mine_GetPrivateProfileSectionNamesA(LPSTR a0,
                                                    DWORD a1,
                                                    LPCSTR a2)
{
    _PrintEnter("GetPrivateProfileSectionNamesA(%p,%p,%hs)\n", a0, a1, a2);

    DWORD rv = 0;
    __try {
        rv = Real_GetPrivateProfileSectionNamesA(a0, a1, a2);
    } __finally {
        _PrintExit("GetPrivateProfileSectionNamesA(%hs,,) -> %p\n", a0, rv);
    };
    return rv;
}

DWORD __stdcall Mine_GetPrivateProfileSectionNamesW(LPWSTR a0,
                                                    DWORD a1,
                                                    LPCWSTR a2)
{
    _PrintEnter("GetPrivateProfileSectionNamesW(%p,%p,%ls)\n", a0, a1, a2);

    DWORD rv = 0;
    __try {
        rv = Real_GetPrivateProfileSectionNamesW(a0, a1, a2);
    } __finally {
        _PrintExit("GetPrivateProfileSectionNamesW(%ls,,) -> %p\n", a0, rv);
    };
    return rv;
}

DWORD __stdcall Mine_GetPrivateProfileSectionW(LPCWSTR a0,
                                               LPWSTR a1,
                                               DWORD a2,
                                               LPCWSTR a3)
{
    _PrintEnter("GetPrivateProfileSectionW(%ls,%p,%p,%ls)\n", a0, a1, a2, a3);

    DWORD rv = 0;
    __try {
        rv = Real_GetPrivateProfileSectionW(a0, a1, a2, a3);
    } __finally {
        _PrintExit("GetPrivateProfileSectionW(,%ls,,) -> %p\n", a1, rv);
    };
    return rv;
}

DWORD __stdcall Mine_GetPrivateProfileStringA(LPCSTR a0,
                                              LPCSTR a1,
                                              LPCSTR a2,
                                              LPSTR a3,
                                              DWORD a4,
                                              LPCSTR a5)
{
    _PrintEnter("GetPrivateProfileStringA(%hs,%hs,%hs,%p,%p,%hs)\n", a0, a1, a2, a3, a4, a5);

    DWORD rv = 0;
    __try {
        rv = Real_GetPrivateProfileStringA(a0, a1, a2, a3, a4, a5);
    } __finally {
        _PrintExit("GetPrivateProfileStringA(,,,%hs,,) -> %p\n", a3, rv);
    };
    return rv;
}

DWORD __stdcall Mine_GetPrivateProfileStringW(LPCWSTR a0,
                                              LPCWSTR a1,
                                              LPCWSTR a2,
                                              LPWSTR a3,
                                              DWORD a4,
                                              LPCWSTR a5)
{
    _PrintEnter("GetPrivateProfileStringW(%ls,%ls,%ls,%p,%p,%ls)\n", a0, a1, a2, a3, a4, a5);

    DWORD rv = 0;
    __try {
        rv = Real_GetPrivateProfileStringW(a0, a1, a2, a3, a4, a5);
    } __finally {
        _PrintExit("GetPrivateProfileStringW(,,,%ls,,) -> %p\n", a3, rv);
    };
    return rv;
}

BOOL __stdcall Mine_GetPrivateProfileStructA(LPCSTR a0,
                                             LPCSTR a1,
                                             LPVOID a2,
                                             UINT a3,
                                             LPCSTR a4)
{
    _PrintEnter("GetPrivateProfileStructA(%hs,%hs,%p,%p,%hs)\n", a0, a1, a2, a3, a4);

    BOOL rv = 0;
    __try {
        rv = Real_GetPrivateProfileStructA(a0, a1, a2, a3, a4);
    } __finally {
        _PrintExit("GetPrivateProfileStructA(,,,,) -> %p\n", rv);
    };
    return rv;
}

BOOL __stdcall Mine_GetPrivateProfileStructW(LPCWSTR a0,
                                             LPCWSTR a1,
                                             LPVOID a2,
                                             UINT a3,
                                             LPCWSTR a4)
{
    _PrintEnter("GetPrivateProfileStructW(%ls,%ls,%p,%p,%ls)\n", a0, a1, a2, a3, a4);

    BOOL rv = 0;
    __try {
        rv = Real_GetPrivateProfileStructW(a0, a1, a2, a3, a4);
    } __finally {
        _PrintExit("GetPrivateProfileStructW(,,,,) -> %p\n", rv);
    };
    return rv;
}

FARPROC __stdcall Mine_GetProcAddress(HMODULE a0,
                                      LPCSTR a1)
{
    _PrintEnter("GetProcAddress(%p,%hs)\n", a0, a1);

    FARPROC rv = 0;
    __try {
        rv = Real_GetProcAddress(a0, a1);
    } __finally {
        _PrintExit("GetProcAddress(,) -> %p\n", rv);
    };
    return rv;
}

BOOL __stdcall Mine_GetProcessAffinityMask(HANDLE a0,
                                           PDWORD_PTR a1,
                                           PDWORD_PTR a2)
{
    _PrintEnter("GetProcessAffinityMask(%p,%p,%p)\n", a0, a1, a2);

    BOOL rv = 0;
    __try {
        rv = Real_GetProcessAffinityMask(a0, a1, a2);
    } __finally {
        _PrintExit("GetProcessAffinityMask(,,) -> %p\n", rv);
    };
    return rv;
}

DWORD __stdcall Mine_GetProcessHeaps(DWORD a0,
                                     PHANDLE a1)
{
    _PrintEnter("GetProcessHeaps(%p,%p)\n", a0, a1);

    DWORD rv = 0;
    __try {
        rv = Real_GetProcessHeaps(a0, a1);
    } __finally {
        _PrintExit("GetProcessHeaps(,) -> %p\n", rv);
    };
    return rv;
}

BOOL __stdcall Mine_GetProcessShutdownParameters(LPDWORD a0,
                                                 LPDWORD a1)
{
    _PrintEnter("GetProcessShutdownParameters(%p,%p)\n", a0, a1);

    BOOL rv = 0;
    __try {
        rv = Real_GetProcessShutdownParameters(a0, a1);
    } __finally {
        _PrintExit("GetProcessShutdownParameters(,) -> %p\n", rv);
    };
    return rv;
}

BOOL __stdcall Mine_GetProcessTimes(HANDLE a0,
                                    LPFILETIME a1,
                                    LPFILETIME a2,
                                    LPFILETIME a3,
                                    LPFILETIME a4)
{
    _PrintEnter("GetProcessTimes(%p,%p,%p,%p,%p)\n", a0, a1, a2, a3, a4);

    BOOL rv = 0;
    __try {
        rv = Real_GetProcessTimes(a0, a1, a2, a3, a4);
    } __finally {
        _PrintExit("GetProcessTimes(,,,,) -> %p\n", rv);
    };
    return rv;
}

DWORD __stdcall Mine_GetProcessVersion(DWORD a0)
{
    _PrintEnter("GetProcessVersion(%p)\n", a0);

    DWORD rv = 0;
    __try {
        rv = Real_GetProcessVersion(a0);
    } __finally {
        _PrintExit("GetProcessVersion() -> %p\n", rv);
    };
    return rv;
}

HWINSTA __stdcall Mine_GetProcessWindowStation(void)
{
    _PrintEnter("GetProcessWindowStation()\n");

    HWINSTA rv = 0;
    __try {
        rv = Real_GetProcessWindowStation();
    } __finally {
        _PrintExit("GetProcessWindowStation() -> %p\n", rv);
    };
    return rv;
}

BOOL __stdcall Mine_GetProcessWorkingSetSize(HANDLE a0,
                                             PSIZE_T a1,
                                             PSIZE_T a2)
{
    _PrintEnter("GetProcessWorkingSetSize(%p,%p,%p)\n", a0, a1, a2);

    BOOL rv = 0;
    __try {
        rv = Real_GetProcessWorkingSetSize(a0, a1, a2);
    } __finally {
        _PrintExit("GetProcessWorkingSetSize(,,) -> %p\n", rv);
    };
    return rv;
}

UINT __stdcall Mine_GetProfileIntA(LPCSTR a0,
                                   LPCSTR a1,
                                   INT a2)
{
    _PrintEnter("GetProfileIntA(%hs,%hs,%p)\n", a0, a1, a2);

    UINT rv = 0;
    __try {
        rv = Real_GetProfileIntA(a0, a1, a2);
    } __finally {
        _PrintExit("GetProfileIntA(,,) -> %p\n", rv);
    };
    return rv;
}

UINT __stdcall Mine_GetProfileIntW(LPCWSTR a0,
                                   LPCWSTR a1,
                                   INT a2)
{
    _PrintEnter("GetProfileIntW(%ls,%ls,%p)\n", a0, a1, a2);

    UINT rv = 0;
    __try {
        rv = Real_GetProfileIntW(a0, a1, a2);
    } __finally {
        _PrintExit("GetProfileIntW(,,) -> %p\n", rv);
    };
    return rv;
}

DWORD __stdcall Mine_GetProfileSectionA(LPCSTR a0,
                                        LPSTR a1,
                                        DWORD a2)
{
    _PrintEnter("GetProfileSectionA(%hs,%p,%p)\n", a0, a1, a2);

    DWORD rv = 0;
    __try {
        rv = Real_GetProfileSectionA(a0, a1, a2);
    } __finally {
        _PrintExit("GetProfileSectionA(,%hs,) -> %p\n", a1, rv);
    };
    return rv;
}

DWORD __stdcall Mine_GetProfileSectionW(LPCWSTR a0,
                                        LPWSTR a1,
                                        DWORD a2)
{
    _PrintEnter("GetProfileSectionW(%ls,%p,%p)\n", a0, a1, a2);

    DWORD rv = 0;
    __try {
        rv = Real_GetProfileSectionW(a0, a1, a2);
    } __finally {
        _PrintExit("GetProfileSectionW(,%ls,) -> %p\n", a1, rv);
    };
    return rv;
}

DWORD __stdcall Mine_GetProfileStringA(LPCSTR a0,
                                       LPCSTR a1,
                                       LPCSTR a2,
                                       LPSTR a3,
                                       DWORD a4)
{
    _PrintEnter("GetProfileStringA(%hs,%hs,%hs,%p,%p)\n", a0, a1, a2, a3, a4);

    DWORD rv = 0;
    __try {
        rv = Real_GetProfileStringA(a0, a1, a2, a3, a4);
    } __finally {
        _PrintExit("GetProfileStringA(,,,%hs,) -> %p\n", a3, rv);
    };
    return rv;
}

DWORD __stdcall Mine_GetProfileStringW(LPCWSTR a0,
                                       LPCWSTR a1,
                                       LPCWSTR a2,
                                       LPWSTR a3,
                                       DWORD a4)
{
    _PrintEnter("GetProfileStringW(%ls,%ls,%ls,%p,%p)\n", a0, a1, a2, a3, a4);

    DWORD rv = 0;
    __try {
        rv = Real_GetProfileStringW(a0, a1, a2, a3, a4);
    } __finally {
        _PrintExit("GetProfileStringW(,,,%ls,) -> %p\n", a3, rv);
    };
    return rv;
}

HANDLE __stdcall Mine_GetPropA(HWND a0,
                               LPCSTR a1)
{
    _PrintEnter("GetPropA(%p,%hs)\n", a0, a1);

    HANDLE rv = 0;
    __try {
        rv = Real_GetPropA(a0, a1);
    } __finally {
        _PrintExit("GetPropA(,) -> %p\n", rv);
    };
    return rv;
}

HANDLE __stdcall Mine_GetPropW(HWND a0,
                               LPCWSTR a1)
{
    _PrintEnter("GetPropW(%p,%ls)\n", a0, a1);

    HANDLE rv = 0;
    __try {
        rv = Real_GetPropW(a0, a1);
    } __finally {
        _PrintExit("GetPropW(,) -> %p\n", rv);
    };
    return rv;
}

DWORD __stdcall Mine_GetQueueStatus(UINT a0)
{
    _PrintEnter("GetQueueStatus(%p)\n", a0);

    DWORD rv = 0;
    __try {
        rv = Real_GetQueueStatus(a0);
    } __finally {
        _PrintExit("GetQueueStatus() -> %p\n", rv);
    };
    return rv;
}

BOOL __stdcall Mine_GetQueuedCompletionStatus(HANDLE a0,
                                              LPDWORD a1,
                                              PULONG_PTR a2,
                                              LPOVERLAPPED* a3,
                                              DWORD a4)
{
    _PrintEnter("GetQueuedCompletionStatus(%p,%p,%p,%p,%p)\n", a0, a1, a2, a3, a4);

    BOOL rv = 0;
    __try {
        rv = Real_GetQueuedCompletionStatus(a0, a1, a2, a3, a4);
    } __finally {
        _PrintExit("GetQueuedCompletionStatus(,,,,) -> %p\n", rv);
    };
    return rv;
}

int __stdcall Mine_GetROP2(HDC a0)
{
    _PrintEnter("GetROP2(%p)\n", a0);

    int rv = 0;
    __try {
        rv = Real_GetROP2(a0);
    } __finally {
        _PrintExit("GetROP2() -> %p\n", rv);
    };
    return rv;
}

BOOL __stdcall Mine_GetRasterizerCaps(LPRASTERIZER_STATUS a0,
                                      UINT a1)
{
    _PrintEnter("GetRasterizerCaps(%p,%p)\n", a0, a1);

    BOOL rv = 0;
    __try {
        rv = Real_GetRasterizerCaps(a0, a1);
    } __finally {
        _PrintExit("GetRasterizerCaps(,) -> %p\n", rv);
    };
    return rv;
}

DWORD __stdcall Mine_GetRegionData(HRGN a0,
                                   DWORD a1,
                                   LPRGNDATA a2)
{
    _PrintEnter("GetRegionData(%p,%p,%p)\n", a0, a1, a2);

    DWORD rv = 0;
    __try {
        rv = Real_GetRegionData(a0, a1, a2);
    } __finally {
        _PrintExit("GetRegionData(,,) -> %p\n", rv);
    };
    return rv;
}

int __stdcall Mine_GetRgnBox(HRGN a0,
                             LPRECT a1)
{
    _PrintEnter("GetRgnBox(%p,%p)\n", a0, a1);

    int rv = 0;
    __try {
        rv = Real_GetRgnBox(a0, a1);
    } __finally {
        _PrintExit("GetRgnBox(,) -> %p\n", rv);
    };
    return rv;
}

HRESULT __stdcall Mine_GetRunningObjectTable(DWORD a0,
                                             LPRUNNINGOBJECTTABLE* a1)
{
    _PrintEnter("GetRunningObjectTable(%p,%p)\n", a0, a1);

    HRESULT rv = 0;
    __try {
        rv = Real_GetRunningObjectTable(a0, a1);
    } __finally {
        _PrintExit("GetRunningObjectTable(,) -> %p\n", rv);
    };
    return rv;
}

BOOL __stdcall Mine_GetScrollInfo(HWND a0,
                                  int a1,
                                  LPSCROLLINFO a2)
{
    _PrintEnter("GetScrollInfo(%p,%p,%p)\n", a0, a1, a2);

    BOOL rv = 0;
    __try {
        rv = Real_GetScrollInfo(a0, a1, a2);
    } __finally {
        _PrintExit("GetScrollInfo(,,) -> %p\n", rv);
    };
    return rv;
}

int __stdcall Mine_GetScrollPos(HWND a0,
                                int a1)
{
    _PrintEnter("GetScrollPos(%p,%p)\n", a0, a1);

    int rv = 0;
    __try {
        rv = Real_GetScrollPos(a0, a1);
    } __finally {
        _PrintExit("GetScrollPos(,) -> %p\n", rv);
    };
    return rv;
}

BOOL __stdcall Mine_GetScrollRange(HWND a0,
                                   int a1,
                                   LPINT a2,
                                   LPINT a3)
{
    _PrintEnter("GetScrollRange(%p,%p,%p,%p)\n", a0, a1, a2, a3);

    BOOL rv = 0;
    __try {
        rv = Real_GetScrollRange(a0, a1, a2, a3);
    } __finally {
        _PrintExit("GetScrollRange(,,,) -> %p\n", rv);
    };
    return rv;
}

DWORD __stdcall Mine_GetShortPathNameA(LPCSTR a0,
                                       LPSTR a1,
                                       DWORD a2)
{
    _PrintEnter("GetShortPathNameA(%hs,%p,%p)\n", a0, a1, a2);

    DWORD rv = 0;
    __try {
        rv = Real_GetShortPathNameA(a0, a1, a2);
    } __finally {
        _PrintExit("GetShortPathNameA(,%hs,) -> %p\n", a1, rv);
    };
    return rv;
}

DWORD __stdcall Mine_GetShortPathNameW(LPCWSTR a0,
                                       LPWSTR a1,
                                       DWORD a2)
{
    _PrintEnter("GetShortPathNameW(%ls,%p,%p)\n", a0, a1, a2);

    DWORD rv = 0;
    __try {
        rv = Real_GetShortPathNameW(a0, a1, a2);
    } __finally {
        _PrintExit("GetShortPathNameW(,%ls,) -> %p\n", a1, rv);
    };
    return rv;
}

void __stdcall Mine_GetStartupInfoA(LPSTARTUPINFOA a0)
{
    _PrintEnter("GetStartupInfoA(%p)\n", a0);

    __try {
        Real_GetStartupInfoA(a0);
    } __finally {
        _PrintExit("GetStartupInfoA() ->\n");
    };
}

void __stdcall Mine_GetStartupInfoW(LPSTARTUPINFOW a0)
{
    _PrintEnter("GetStartupInfoW(%p)\n", a0);

    __try {
        Real_GetStartupInfoW(a0);
    } __finally {
        _PrintExit("GetStartupInfoW() ->\n");
    };
}

HANDLE __stdcall Mine_GetStdHandle(DWORD a0)
{
    _PrintEnter("GetStdHandle(%p)\n", a0);

    HANDLE rv = 0;
    __try {
        rv = Real_GetStdHandle(a0);
    } __finally {
        _PrintExit("GetStdHandle() -> %p\n", rv);
    };
    return rv;
}

HGDIOBJ __stdcall Mine_GetStockObject(int a0)
{
    _PrintEnter("GetStockObject(%p)\n", a0);

    HGDIOBJ rv = 0;
    __try {
        rv = Real_GetStockObject(a0);
    } __finally {
        _PrintExit("GetStockObject() -> %p\n", rv);
    };
    return rv;
}

int __stdcall Mine_GetStretchBltMode(HDC a0)
{
    _PrintEnter("GetStretchBltMode(%p)\n", a0);

    int rv = 0;
    __try {
        rv = Real_GetStretchBltMode(a0);
    } __finally {
        _PrintExit("GetStretchBltMode() -> %p\n", rv);
    };
    return rv;
}

HMENU __stdcall Mine_GetSubMenu(HMENU a0,
                                int a1)
{
    _PrintEnter("GetSubMenu(%p,%p)\n", a0, a1);

    HMENU rv = 0;
    __try {
        rv = Real_GetSubMenu(a0, a1);
    } __finally {
        _PrintExit("GetSubMenu(,) -> %p\n", rv);
    };
    return rv;
}

DWORD __stdcall Mine_GetSysColor(int a0)
{
    _PrintEnter("GetSysColor(%p)\n", a0);

    DWORD rv = 0;
    __try {
        rv = Real_GetSysColor(a0);
    } __finally {
        _PrintExit("GetSysColor() -> %p\n", rv);
    };
    return rv;
}

HBRUSH __stdcall Mine_GetSysColorBrush(int a0)
{
    _PrintEnter("GetSysColorBrush(%p)\n", a0);

    HBRUSH rv = 0;
    __try {
        rv = Real_GetSysColorBrush(a0);
    } __finally {
        _PrintExit("GetSysColorBrush() -> %p\n", rv);
    };
    return rv;
}

LCID __stdcall Mine_GetSystemDefaultLCID(void)
{
    _PrintEnter("GetSystemDefaultLCID()\n");

    LCID rv = 0;
    __try {
        rv = Real_GetSystemDefaultLCID();
    } __finally {
        _PrintExit("GetSystemDefaultLCID() -> %p\n", rv);
    };
    return rv;
}

LANGID __stdcall Mine_GetSystemDefaultLangID(void)
{
    _PrintEnter("GetSystemDefaultLangID()\n");

    LANGID rv = 0;
    __try {
        rv = Real_GetSystemDefaultLangID();
    } __finally {
        _PrintExit("GetSystemDefaultLangID() -> %p\n", rv);
    };
    return rv;
}

UINT __stdcall Mine_GetSystemDirectoryA(LPSTR a0,
                                        UINT a1)
{
    _PrintEnter("GetSystemDirectoryA(%p,%p)\n", a0, a1);

    UINT rv = 0;
    __try {
        rv = Real_GetSystemDirectoryA(a0, a1);
    } __finally {
        _PrintExit("GetSystemDirectoryA(%hs,) -> %p\n", a0, rv);
    };
    return rv;
}

UINT __stdcall Mine_GetSystemDirectoryW(LPWSTR a0,
                                        UINT a1)
{
    _PrintEnter("GetSystemDirectoryW(%p,%p)\n", a0, a1);

    UINT rv = 0;
    __try {
        rv = Real_GetSystemDirectoryW(a0, a1);
    } __finally {
        _PrintExit("GetSystemDirectoryW(%ls,) -> %p\n", a0, rv);
    };
    return rv;
}

void __stdcall Mine_GetSystemInfo(LPSYSTEM_INFO a0)
{
    _PrintEnter("GetSystemInfo(%p)\n", a0);

    __try {
        Real_GetSystemInfo(a0);
    } __finally {
        _PrintExit("GetSystemInfo() ->\n");
    };
}

HMENU __stdcall Mine_GetSystemMenu(HWND a0,
                                   BOOL a1)
{
    _PrintEnter("GetSystemMenu(%p,%p)\n", a0, a1);

    HMENU rv = 0;
    __try {
        rv = Real_GetSystemMenu(a0, a1);
    } __finally {
        _PrintExit("GetSystemMenu(,) -> %p\n", rv);
    };
    return rv;
}

int __stdcall Mine_GetSystemMetrics(int a0)
{
    _PrintEnter("GetSystemMetrics(%p)\n", a0);

    int rv = 0;
    __try {
        rv = Real_GetSystemMetrics(a0);
    } __finally {
        _PrintExit("GetSystemMetrics() -> %p\n", rv);
    };
    return rv;
}

UINT __stdcall Mine_GetSystemPaletteEntries(HDC a0,
                                            UINT a1,
                                            UINT a2,
                                            PALETTEENTRY* a3)
{
    _PrintEnter("GetSystemPaletteEntries(%p,%p,%p,%p)\n", a0, a1, a2, a3);

    UINT rv = 0;
    __try {
        rv = Real_GetSystemPaletteEntries(a0, a1, a2, a3);
    } __finally {
        _PrintExit("GetSystemPaletteEntries(,,,) -> %p\n", rv);
    };
    return rv;
}

UINT __stdcall Mine_GetSystemPaletteUse(HDC a0)
{
    _PrintEnter("GetSystemPaletteUse(%p)\n", a0);

    UINT rv = 0;
    __try {
        rv = Real_GetSystemPaletteUse(a0);
    } __finally {
        _PrintExit("GetSystemPaletteUse() -> %p\n", rv);
    };
    return rv;
}

BOOL __stdcall Mine_GetSystemPowerStatus(LPSYSTEM_POWER_STATUS a0)
{
    _PrintEnter("GetSystemPowerStatus(%p)\n", a0);

    BOOL rv = 0;
    __try {
        rv = Real_GetSystemPowerStatus(a0);
    } __finally {
        _PrintExit("GetSystemPowerStatus() -> %p\n", rv);
    };
    return rv;
}

void __stdcall Mine_GetSystemTime(LPSYSTEMTIME a0)
{
    _PrintEnter("GetSystemTime(%p)\n", a0);

    __try {
        Real_GetSystemTime(a0);
    } __finally {
        _PrintExit("GetSystemTime() ->\n");
    };
}

BOOL __stdcall Mine_GetSystemTimeAdjustment(PDWORD a0,
                                            PDWORD a1,
                                            PBOOL a2)
{
    _PrintEnter("GetSystemTimeAdjustment(%p,%p,%p)\n", a0, a1, a2);

    BOOL rv = 0;
    __try {
        rv = Real_GetSystemTimeAdjustment(a0, a1, a2);
    } __finally {
        _PrintExit("GetSystemTimeAdjustment(,,) -> %p\n", rv);
    };
    return rv;
}

void __stdcall Mine_GetSystemTimeAsFileTime(LPFILETIME a0)
{
    _PrintEnter("GetSystemTimeAsFileTime(%p)\n", a0);

    __try {
        Real_GetSystemTimeAsFileTime(a0);
    } __finally {
        _PrintExit("GetSystemTimeAsFileTime() ->\n");
    };
}

DWORD __stdcall Mine_GetTabbedTextExtentA(HDC a0,
                                          LPCSTR a1,
                                          int a2,
                                          int a3,
                                          INT* a4)
{
    _PrintEnter("GetTabbedTextExtentA(%p,%hs,%p,%p,%p)\n", a0, a1, a2, a3, a4);

    DWORD rv = 0;
    __try {
        rv = Real_GetTabbedTextExtentA(a0, a1, a2, a3, a4);
    } __finally {
        _PrintExit("GetTabbedTextExtentA(,,,,) -> %p\n", rv);
    };
    return rv;
}

DWORD __stdcall Mine_GetTabbedTextExtentW(HDC a0,
                                          LPCWSTR a1,
                                          int a2,
                                          int a3,
                                          INT* a4)
{
    _PrintEnter("GetTabbedTextExtentW(%p,%ls,%p,%p,%p)\n", a0, a1, a2, a3, a4);

    DWORD rv = 0;
    __try {
        rv = Real_GetTabbedTextExtentW(a0, a1, a2, a3, a4);
    } __finally {
        _PrintExit("GetTabbedTextExtentW(,,,,) -> %p\n", rv);
    };
    return rv;
}

DWORD __stdcall Mine_GetTapeParameters(HANDLE a0,
                                       DWORD a1,
                                       LPDWORD a2,
                                       LPVOID a3)
{
    _PrintEnter("GetTapeParameters(%p,%p,%p,%p)\n", a0, a1, a2, a3);

    DWORD rv = 0;
    __try {
        rv = Real_GetTapeParameters(a0, a1, a2, a3);
    } __finally {
        _PrintExit("GetTapeParameters(,,,) -> %p\n", rv);
    };
    return rv;
}

DWORD __stdcall Mine_GetTapePosition(HANDLE a0,
                                     DWORD a1,
                                     LPDWORD a2,
                                     LPDWORD a3,
                                     LPDWORD a4)
{
    _PrintEnter("GetTapePosition(%p,%p,%p,%p,%p)\n", a0, a1, a2, a3, a4);

    DWORD rv = 0;
    __try {
        rv = Real_GetTapePosition(a0, a1, a2, a3, a4);
    } __finally {
        _PrintExit("GetTapePosition(,,,,) -> %p\n", rv);
    };
    return rv;
}

DWORD __stdcall Mine_GetTapeStatus(HANDLE a0)
{
    _PrintEnter("GetTapeStatus(%p)\n", a0);

    DWORD rv = 0;
    __try {
        rv = Real_GetTapeStatus(a0);
    } __finally {
        _PrintExit("GetTapeStatus() -> %p\n", rv);
    };
    return rv;
}

UINT __stdcall Mine_GetTempFileNameA(LPCSTR a0,
                                     LPCSTR a1,
                                     UINT a2,
                                     LPSTR a3)
{
    _PrintEnter("GetTempFileNameA(%hs,%hs,%p,%p)\n", a0, a1, a2, a3);

    UINT rv = 0;
    __try {
        rv = Real_GetTempFileNameA(a0, a1, a2, a3);
    } __finally {
        _PrintExit("GetTempFileNameA(,,,%hs) -> %p\n", a3, rv);
    };
    return rv;
}

UINT __stdcall Mine_GetTempFileNameW(LPCWSTR a0,
                                     LPCWSTR a1,
                                     UINT a2,
                                     LPWSTR a3)
{
    _PrintEnter("GetTempFileNameW(%ls,%ls,%p,%p)\n", a0, a1, a2, a3);

    UINT rv = 0;
    __try {
        rv = Real_GetTempFileNameW(a0, a1, a2, a3);
    } __finally {
        _PrintExit("GetTempFileNameW(,,,%ls) -> %p\n", a3, rv);
    };
    return rv;
}

DWORD __stdcall Mine_GetTempPathA(DWORD a0,
                                  LPSTR a1)
{
    _PrintEnter("GetTempPathA(%p,%p)\n", a0, a1);

    DWORD rv = 0;
    __try {
        rv = Real_GetTempPathA(a0, a1);
    } __finally {
        _PrintExit("GetTempPathA(,%hs) -> %p\n", a1, rv);
    };
    return rv;
}

DWORD __stdcall Mine_GetTempPathW(DWORD a0,
                                  LPWSTR a1)
{
    _PrintEnter("GetTempPathW(%p,%p)\n", a0, a1);

    DWORD rv = 0;
    __try {
        rv = Real_GetTempPathW(a0, a1);
    } __finally {
        _PrintExit("GetTempPathW(,%ls) -> %p\n", a1, rv);
    };
    return rv;
}

UINT __stdcall Mine_GetTextAlign(HDC a0)
{
    _PrintEnter("GetTextAlign(%p)\n", a0);

    UINT rv = 0;
    __try {
        rv = Real_GetTextAlign(a0);
    } __finally {
        _PrintExit("GetTextAlign() -> %p\n", rv);
    };
    return rv;
}

int __stdcall Mine_GetTextCharacterExtra(HDC a0)
{
    _PrintEnter("GetTextCharacterExtra(%p)\n", a0);

    int rv = 0;
    __try {
        rv = Real_GetTextCharacterExtra(a0);
    } __finally {
        _PrintExit("GetTextCharacterExtra() -> %p\n", rv);
    };
    return rv;
}

int __stdcall Mine_GetTextCharset(HDC a0)
{
    _PrintEnter("GetTextCharset(%p)\n", a0);

    int rv = 0;
    __try {
        rv = Real_GetTextCharset(a0);
    } __finally {
        _PrintExit("GetTextCharset() -> %p\n", rv);
    };
    return rv;
}

int __stdcall Mine_GetTextCharsetInfo(HDC a0,
                                      LPFONTSIGNATURE a1,
                                      DWORD a2)
{
    _PrintEnter("GetTextCharsetInfo(%p,%p,%p)\n", a0, a1, a2);

    int rv = 0;
    __try {
        rv = Real_GetTextCharsetInfo(a0, a1, a2);
    } __finally {
        _PrintExit("GetTextCharsetInfo(,,) -> %p\n", rv);
    };
    return rv;
}

COLORREF __stdcall Mine_GetTextColor(HDC a0)
{
    _PrintEnter("GetTextColor(%p)\n", a0);

    COLORREF rv = 0;
    __try {
        rv = Real_GetTextColor(a0);
    } __finally {
        _PrintExit("GetTextColor() -> %p\n", rv);
    };
    return rv;
}

BOOL __stdcall Mine_GetTextExtentExPointA(HDC a0,
                                          LPCSTR a1,
                                          int a2,
                                          int a3,
                                          LPINT a4,
                                          LPINT a5,
                                          SIZE* a6)
{
    _PrintEnter("GetTextExtentExPointA(%p,%hs,%p,%p,%p,%p,%p)\n", a0, a1, a2, a3, a4, a5, a6);

    BOOL rv = 0;
    __try {
        rv = Real_GetTextExtentExPointA(a0, a1, a2, a3, a4, a5, a6);
    } __finally {
        _PrintExit("GetTextExtentExPointA(,,,,,,) -> %p\n", rv);
    };
    return rv;
}

BOOL __stdcall Mine_GetTextExtentExPointW(HDC a0,
                                          LPCWSTR a1,
                                          int a2,
                                          int a3,
                                          LPINT a4,
                                          LPINT a5,
                                          SIZE* a6)
{
    _PrintEnter("GetTextExtentExPointW(%p,%ls,%p,%p,%p,%p,%p)\n", a0, a1, a2, a3, a4, a5, a6);

    BOOL rv = 0;
    __try {
        rv = Real_GetTextExtentExPointW(a0, a1, a2, a3, a4, a5, a6);
    } __finally {
        _PrintExit("GetTextExtentExPointW(,,,,,,) -> %p\n", rv);
    };
    return rv;
}

BOOL __stdcall Mine_GetTextExtentPoint32A(HDC a0,
                                          LPCSTR a1,
                                          int a2,
                                          SIZE* a3)
{
    _PrintEnter("GetTextExtentPoint32A(%p,%hs,%p,%p)\n", a0, a1, a2, a3);

    BOOL rv = 0;
    __try {
        rv = Real_GetTextExtentPoint32A(a0, a1, a2, a3);
    } __finally {
        _PrintExit("GetTextExtentPoint32A(,,,) -> %p\n", rv);
    };
    return rv;
}

BOOL __stdcall Mine_GetTextExtentPoint32W(HDC a0,
                                          LPCWSTR a1,
                                          int a2,
                                          SIZE* a3)
{
    _PrintEnter("GetTextExtentPoint32W(%p,%ls,%p,%p)\n", a0, a1, a2, a3);

    BOOL rv = 0;
    __try {
        rv = Real_GetTextExtentPoint32W(a0, a1, a2, a3);
    } __finally {
        _PrintExit("GetTextExtentPoint32W(,,,) -> %p\n", rv);
    };
    return rv;
}

BOOL __stdcall Mine_GetTextExtentPointA(HDC a0,
                                        LPCSTR a1,
                                        int a2,
                                        SIZE* a3)
{
    _PrintEnter("GetTextExtentPointA(%p,%hs,%p,%p)\n", a0, a1, a2, a3);

    BOOL rv = 0;
    __try {
        rv = Real_GetTextExtentPointA(a0, a1, a2, a3);
    } __finally {
        _PrintExit("GetTextExtentPointA(,,,) -> %p\n", rv);
    };
    return rv;
}

BOOL __stdcall Mine_GetTextExtentPointW(HDC a0,
                                        LPCWSTR a1,
                                        int a2,
                                        SIZE* a3)
{
    _PrintEnter("GetTextExtentPointW(%p,%ls,%p,%p)\n", a0, a1, a2, a3);

    BOOL rv = 0;
    __try {
        rv = Real_GetTextExtentPointW(a0, a1, a2, a3);
    } __finally {
        _PrintExit("GetTextExtentPointW(,,,) -> %p\n", rv);
    };
    return rv;
}

int __stdcall Mine_GetTextFaceA(HDC a0,
                                int a1,
                                LPSTR a2)
{
    _PrintEnter("GetTextFaceA(%p,%p,%p)\n", a0, a1, a2);

    int rv = 0;
    __try {
        rv = Real_GetTextFaceA(a0, a1, a2);
    } __finally {
        _PrintExit("GetTextFaceA(,,%hs) -> %p\n", a2, rv);
    };
    return rv;
}

int __stdcall Mine_GetTextFaceW(HDC a0,
                                int a1,
                                LPWSTR a2)
{
    _PrintEnter("GetTextFaceW(%p,%p,%p)\n", a0, a1, a2);

    int rv = 0;
    __try {
        rv = Real_GetTextFaceW(a0, a1, a2);
    } __finally {
        _PrintExit("GetTextFaceW(,,%ls) -> %p\n", a2, rv);
    };
    return rv;
}

BOOL __stdcall Mine_GetTextMetricsA(HDC a0,
                                    LPTEXTMETRICA a1)
{
    _PrintEnter("GetTextMetricsA(%p,%p)\n", a0, a1);

    BOOL rv = 0;
    __try {
        rv = Real_GetTextMetricsA(a0, a1);
    } __finally {
        _PrintExit("GetTextMetricsA(,) -> %p\n", rv);
    };
    return rv;
}

BOOL __stdcall Mine_GetTextMetricsW(HDC a0,
                                    LPTEXTMETRICW a1)
{
    _PrintEnter("GetTextMetricsW(%p,%p)\n", a0, a1);

    BOOL rv = 0;
    __try {
        rv = Real_GetTextMetricsW(a0, a1);
    } __finally {
        _PrintExit("GetTextMetricsW(,) -> %p\n", rv);
    };
    return rv;
}

BOOL __stdcall Mine_GetThreadContext(HANDLE a0,
                                     LPCONTEXT a1)
{
    _PrintEnter("GetThreadContext(%p,%p)\n", a0, a1);

    BOOL rv = 0;
    __try {
        rv = Real_GetThreadContext(a0, a1);
    } __finally {
        _PrintExit("GetThreadContext(,) -> %p\n", rv);
    };
    return rv;
}

HDESK __stdcall Mine_GetThreadDesktop(DWORD a0)
{
    _PrintEnter("GetThreadDesktop(%p)\n", a0);

    HDESK rv = 0;
    __try {
        rv = Real_GetThreadDesktop(a0);
    } __finally {
        _PrintExit("GetThreadDesktop() -> %p\n", rv);
    };
    return rv;
}

#if(WINVER >= 0x0500)
LCID __stdcall Mine_GetThreadLocale(void)
{
    _PrintEnter("GetThreadLocale()\n");

    LCID rv = 0;
    __try {
        rv = Real_GetThreadLocale();
    } __finally {
        _PrintExit("GetThreadLocale() -> %p\n", rv);
    };
    return rv;
}
#endif // (WINVER >= 0x0500)

int __stdcall Mine_GetThreadPriority(HANDLE a0)
{
    _PrintEnter("GetThreadPriority(%p)\n", a0);

    int rv = 0;
    __try {
        rv = Real_GetThreadPriority(a0);
    } __finally {
        _PrintExit("GetThreadPriority() -> %p\n", rv);
    };
    return rv;
}

BOOL __stdcall Mine_GetThreadPriorityBoost(HANDLE a0,
                                           PBOOL a1)
{
    _PrintEnter("GetThreadPriorityBoost(%p,%p)\n", a0, a1);

    BOOL rv = 0;
    __try {
        rv = Real_GetThreadPriorityBoost(a0, a1);
    } __finally {
        _PrintExit("GetThreadPriorityBoost(,) -> %p\n", rv);
    };
    return rv;
}

BOOL __stdcall Mine_GetThreadSelectorEntry(HANDLE a0,
                                           DWORD a1,
                                           LPLDT_ENTRY a2)
{
    _PrintEnter("GetThreadSelectorEntry(%p,%p,%p)\n", a0, a1, a2);

    BOOL rv = 0;
    __try {
        rv = Real_GetThreadSelectorEntry(a0, a1, a2);
    } __finally {
        _PrintExit("GetThreadSelectorEntry(,,) -> %p\n", rv);
    };
    return rv;
}

BOOL __stdcall Mine_GetThreadTimes(HANDLE a0,
                                   LPFILETIME a1,
                                   LPFILETIME a2,
                                   LPFILETIME a3,
                                   LPFILETIME a4)
{
    _PrintEnter("GetThreadTimes(%p,%p,%p,%p,%p)\n", a0, a1, a2, a3, a4);

    BOOL rv = 0;
    __try {
        rv = Real_GetThreadTimes(a0, a1, a2, a3, a4);
    } __finally {
        _PrintExit("GetThreadTimes(,,,,) -> %p\n", rv);
    };
    return rv;
}

DWORD __stdcall Mine_GetTickCount(void)
{
    _PrintEnter("GetTickCount()\n");

    DWORD rv = 0;
    __try {
        rv = Real_GetTickCount();
    } __finally {
        _PrintExit("GetTickCount() -> %p\n", rv);
    };
    return rv;
}

int __stdcall Mine_GetTimeFormatA(LCID a0,
                                  DWORD a1,
                                  SYSTEMTIME* a2,
                                  LPCSTR a3,
                                  LPSTR a4,
                                  int a5)
{
    _PrintEnter("GetTimeFormatA(%p,%p,%p,%hs,%p,%p)\n", a0, a1, a2, a3, a4, a5);

    int rv = 0;
    __try {
        rv = Real_GetTimeFormatA(a0, a1, a2, a3, a4, a5);
    } __finally {
        _PrintExit("GetTimeFormatA(,,,,%hs,) -> %p\n", a4, rv);
    };
    return rv;
}

int __stdcall Mine_GetTimeFormatW(LCID a0,
                                  DWORD a1,
                                  SYSTEMTIME* a2,
                                  LPCWSTR a3,
                                  LPWSTR a4,
                                  int a5)
{
    _PrintEnter("GetTimeFormatW(%p,%p,%p,%ls,%p,%p)\n", a0, a1, a2, a3, a4, a5);

    int rv = 0;
    __try {
        rv = Real_GetTimeFormatW(a0, a1, a2, a3, a4, a5);
    } __finally {
        _PrintExit("GetTimeFormatW(,,,,%ls,) -> %p\n", a4, rv);
    };
    return rv;
}

DWORD __stdcall Mine_GetTimeZoneInformation(LPTIME_ZONE_INFORMATION a0)
{
    _PrintEnter("GetTimeZoneInformation(%p)\n", a0);

    DWORD rv = 0;
    __try {
        rv = Real_GetTimeZoneInformation(a0);
    } __finally {
        _PrintExit("GetTimeZoneInformation() -> %p\n", rv);
    };
    return rv;
}

HWND __stdcall Mine_GetTopWindow(HWND a0)
{
    _PrintEnter("GetTopWindow(%p)\n", a0);

    HWND rv = 0;
    __try {
        rv = Real_GetTopWindow(a0);
    } __finally {
        _PrintExit("GetTopWindow() -> %p\n", rv);
    };
    return rv;
}

BOOL __stdcall Mine_GetUpdateRect(HWND a0,
                                  LPRECT a1,
                                  BOOL a2)
{
    _PrintEnter("GetUpdateRect(%p,%p,%p)\n", a0, a1, a2);

    BOOL rv = 0;
    __try {
        rv = Real_GetUpdateRect(a0, a1, a2);
    } __finally {
        _PrintExit("GetUpdateRect(,,) -> %p\n", rv);
    };
    return rv;
}

int __stdcall Mine_GetUpdateRgn(HWND a0,
                                HRGN a1,
                                BOOL a2)
{
    _PrintEnter("GetUpdateRgn(%p,%p,%p)\n", a0, a1, a2);

    int rv = 0;
    __try {
        rv = Real_GetUpdateRgn(a0, a1, a2);
    } __finally {
        _PrintExit("GetUpdateRgn(,,) -> %p\n", rv);
    };
    return rv;
}

LCID __stdcall Mine_GetUserDefaultLCID(void)
{
    _PrintEnter("GetUserDefaultLCID()\n");

    LCID rv = 0;
    __try {
        rv = Real_GetUserDefaultLCID();
    } __finally {
        _PrintExit("GetUserDefaultLCID() -> %p\n", rv);
    };
    return rv;
}

LANGID __stdcall Mine_GetUserDefaultLangID(void)
{
    _PrintEnter("GetUserDefaultLangID()\n");

    LANGID rv = 0;
    __try {
        rv = Real_GetUserDefaultLangID();
    } __finally {
        _PrintExit("GetUserDefaultLangID() -> %p\n", rv);
    };
    return rv;
}

BOOL __stdcall Mine_GetUserObjectInformationA(HANDLE a0,
                                              int a1,
                                              PVOID a2,
                                              DWORD a3,
                                              LPDWORD a4)
{
    _PrintEnter("GetUserObjectInformationA(%p,%p,%p,%p,%p)\n", a0, a1, a2, a3, a4);

    BOOL rv = 0;
    __try {
        rv = Real_GetUserObjectInformationA(a0, a1, a2, a3, a4);
    } __finally {
        _PrintExit("GetUserObjectInformationA(,,,,) -> %p\n", rv);
    };
    return rv;
}

BOOL __stdcall Mine_GetUserObjectInformationW(HANDLE a0,
                                              int a1,
                                              PVOID a2,
                                              DWORD a3,
                                              LPDWORD a4)
{
    _PrintEnter("GetUserObjectInformationW(%p,%p,%p,%p,%p)\n", a0, a1, a2, a3, a4);

    BOOL rv = 0;
    __try {
        rv = Real_GetUserObjectInformationW(a0, a1, a2, a3, a4);
    } __finally {
        _PrintExit("GetUserObjectInformationW(,,,,) -> %p\n", rv);
    };
    return rv;
}

BOOL __stdcall Mine_GetUserObjectSecurity(HANDLE a0,
                                          PSECURITY_INFORMATION a1,
                                          PSECURITY_DESCRIPTOR a2,
                                          DWORD a3,
                                          LPDWORD a4)
{
    _PrintEnter("GetUserObjectSecurity(%p,%p,%p,%p,%p)\n", a0, a1, a2, a3, a4);

    BOOL rv = 0;
    __try {
        rv = Real_GetUserObjectSecurity(a0, a1, a2, a3, a4);
    } __finally {
        _PrintExit("GetUserObjectSecurity(,,,,) -> %p\n", rv);
    };
    return rv;
}

DWORD __stdcall Mine_GetVersion(void)
{
    _PrintEnter("GetVersion()\n");

    DWORD rv = 0;
    __try {
        rv = Real_GetVersion();
    } __finally {
        _PrintExit("GetVersion() -> %p\n", rv);
    };
    return rv;
}

BOOL __stdcall Mine_GetVersionExA(LPOSVERSIONINFOA a0)
{
    _PrintEnter("GetVersionExA(%p)\n", a0);

    BOOL rv = 0;
    __try {
        rv = Real_GetVersionExA(a0);
    } __finally {
        _PrintExit("GetVersionExA() -> %p\n", rv);
    };
    return rv;
}

BOOL __stdcall Mine_GetVersionExW(LPOSVERSIONINFOW a0)
{
    _PrintEnter("GetVersionExW(%p)\n", a0);

    BOOL rv = 0;
    __try {
        rv = Real_GetVersionExW(a0);
    } __finally {
        _PrintExit("GetVersionExW() -> %p\n", rv);
    };
    return rv;
}

BOOL __stdcall Mine_GetViewportExtEx(HDC a0,
                                     SIZE* a1)
{
    _PrintEnter("GetViewportExtEx(%p,%p)\n", a0, a1);

    BOOL rv = 0;
    __try {
        rv = Real_GetViewportExtEx(a0, a1);
    } __finally {
        _PrintExit("GetViewportExtEx(,) -> %p\n", rv);
    };
    return rv;
}

BOOL __stdcall Mine_GetViewportOrgEx(HDC a0,
                                     POINT* a1)
{
    _PrintEnter("GetViewportOrgEx(%p,%p)\n", a0, a1);

    BOOL rv = 0;
    __try {
        rv = Real_GetViewportOrgEx(a0, a1);
    } __finally {
        _PrintExit("GetViewportOrgEx(,) -> %p\n", rv);
    };
    return rv;
}

BOOL __stdcall Mine_GetVolumeInformationA(LPCSTR a0,
                                          LPSTR a1,
                                          DWORD a2,
                                          LPDWORD a3,
                                          LPDWORD a4,
                                          LPDWORD a5,
                                          LPSTR a6,
                                          DWORD a7)
{
    _PrintEnter("GetVolumeInformationA(%hs,%p,%p,%p,%p,%p,%p,%p)\n", a0, a1, a2, a3, a4, a5, a6, a7);

    BOOL rv = 0;
    __try {
        rv = Real_GetVolumeInformationA(a0, a1, a2, a3, a4, a5, a6, a7);
    } __finally {
        _PrintExit("GetVolumeInformationA(,%hs,,,,,%hs,) -> %p\n", a1, a6, rv);
    };
    return rv;
}

BOOL __stdcall Mine_GetVolumeInformationW(LPCWSTR a0,
                                          LPWSTR a1,
                                          DWORD a2,
                                          LPDWORD a3,
                                          LPDWORD a4,
                                          LPDWORD a5,
                                          LPWSTR a6,
                                          DWORD a7)
{
    _PrintEnter("GetVolumeInformationW(%ls,%p,%p,%p,%p,%p,%p,%p)\n", a0, a1, a2, a3, a4, a5, a6, a7);

    BOOL rv = 0;
    __try {
        rv = Real_GetVolumeInformationW(a0, a1, a2, a3, a4, a5, a6, a7);
    } __finally {
        _PrintExit("GetVolumeInformationW(,%ls,,,,,%ls,) -> %p\n", a1, a6, rv);
    };
    return rv;
}

UINT __stdcall Mine_GetWinMetaFileBits(HENHMETAFILE a0,
                                       UINT a1,
                                       LPBYTE a2,
                                       INT a3,
                                       HDC a4)
{
    _PrintEnter("GetWinMetaFileBits(%p,%p,%p,%p,%p)\n", a0, a1, a2, a3, a4);

    UINT rv = 0;
    __try {
        rv = Real_GetWinMetaFileBits(a0, a1, a2, a3, a4);
    } __finally {
        _PrintExit("GetWinMetaFileBits(,,,,) -> %p\n", rv);
    };
    return rv;
}

HWND __stdcall Mine_GetWindow(HWND a0,
                              UINT a1)
{
    _PrintEnter("GetWindow(%p,%p)\n", a0, a1);

    HWND rv = 0;
    __try {
        rv = Real_GetWindow(a0, a1);
    } __finally {
        _PrintExit("GetWindow(,) -> %p\n", rv);
    };
    return rv;
}

DWORD __stdcall Mine_GetWindowContextHelpId(HWND a0)
{
    _PrintEnter("GetWindowContextHelpId(%p)\n", a0);

    DWORD rv = 0;
    __try {
        rv = Real_GetWindowContextHelpId(a0);
    } __finally {
        _PrintExit("GetWindowContextHelpId() -> %p\n", rv);
    };
    return rv;
}

HDC __stdcall Mine_GetWindowDC(HWND a0)
{
    _PrintEnter("GetWindowDC(%p)\n", a0);

    HDC rv = 0;
    __try {
        rv = Real_GetWindowDC(a0);
    } __finally {
        _PrintExit("GetWindowDC() -> %p\n", rv);
    };
    return rv;
}

BOOL __stdcall Mine_GetWindowExtEx(HDC a0,
                                   SIZE* a1)
{
    _PrintEnter("GetWindowExtEx(%p,%p)\n", a0, a1);

    BOOL rv = 0;
    __try {
        rv = Real_GetWindowExtEx(a0, a1);
    } __finally {
        _PrintExit("GetWindowExtEx(,) -> %p\n", rv);
    };
    return rv;
}

LONG __stdcall Mine_GetWindowLongA(HWND a0,
                                   int a1)
{
    _PrintEnter("GetWindowLongA(%p,%p)\n", a0, a1);

    LONG rv = 0;
    __try {
        rv = Real_GetWindowLongA(a0, a1);
    } __finally {
        _PrintExit("GetWindowLongA(,) -> %p\n", rv);
    };
    return rv;
}

LONG __stdcall Mine_GetWindowLongW(HWND a0,
                                   int a1)
{
    _PrintEnter("GetWindowLongW(%p,%p)\n", a0, a1);

    LONG rv = 0;
    __try {
        rv = Real_GetWindowLongW(a0, a1);
    } __finally {
        _PrintExit("GetWindowLongW(,) -> %p\n", rv);
    };
    return rv;
}

BOOL __stdcall Mine_GetWindowOrgEx(HDC a0,
                                   POINT* a1)
{
    _PrintEnter("GetWindowOrgEx(%p,%p)\n", a0, a1);

    BOOL rv = 0;
    __try {
        rv = Real_GetWindowOrgEx(a0, a1);
    } __finally {
        _PrintExit("GetWindowOrgEx(,) -> %p\n", rv);
    };
    return rv;
}

BOOL __stdcall Mine_GetWindowPlacement(HWND a0,
                                       WINDOWPLACEMENT* a1)
{
    _PrintEnter("GetWindowPlacement(%p,%p)\n", a0, a1);

    BOOL rv = 0;
    __try {
        rv = Real_GetWindowPlacement(a0, a1);
    } __finally {
        _PrintExit("GetWindowPlacement(,) -> %p\n", rv);
    };
    return rv;
}

BOOL __stdcall Mine_GetWindowRect(HWND a0,
                                  LPRECT a1)
{
    _PrintEnter("GetWindowRect(%p,%p)\n", a0, a1);

    BOOL rv = 0;
    __try {
        rv = Real_GetWindowRect(a0, a1);
    } __finally {
        _PrintExit("GetWindowRect(,) -> %p\n", rv);
    };
    return rv;
}

int __stdcall Mine_GetWindowRgn(HWND a0,
                                HRGN a1)
{
    _PrintEnter("GetWindowRgn(%p,%p)\n", a0, a1);

    int rv = 0;
    __try {
        rv = Real_GetWindowRgn(a0, a1);
    } __finally {
        _PrintExit("GetWindowRgn(,) -> %p\n", rv);
    };
    return rv;
}

int __stdcall Mine_GetWindowTextA(HWND a0,
                                  LPSTR a1,
                                  int a2)
{
    _PrintEnter("GetWindowTextA(%p,%p,%p)\n", a0, a1, a2);

    int rv = 0;
    __try {
        rv = Real_GetWindowTextA(a0, a1, a2);
    } __finally {
        _PrintExit("GetWindowTextA(,%hs,) -> %p\n", a1, rv);
    };
    return rv;
}

int __stdcall Mine_GetWindowTextLengthA(HWND a0)
{
    _PrintEnter("GetWindowTextLengthA(%p)\n", a0);

    int rv = 0;
    __try {
        rv = Real_GetWindowTextLengthA(a0);
    } __finally {
        _PrintExit("GetWindowTextLengthA() -> %p\n", rv);
    };
    return rv;
}

int __stdcall Mine_GetWindowTextLengthW(HWND a0)
{
    _PrintEnter("GetWindowTextLengthW(%p)\n", a0);

    int rv = 0;
    __try {
        rv = Real_GetWindowTextLengthW(a0);
    } __finally {
        _PrintExit("GetWindowTextLengthW() -> %p\n", rv);
    };
    return rv;
}

int __stdcall Mine_GetWindowTextW(HWND a0,
                                  LPWSTR a1,
                                  int a2)
{
    _PrintEnter("GetWindowTextW(%p,%p,%p)\n", a0, a1, a2);

    int rv = 0;
    __try {
        rv = Real_GetWindowTextW(a0, a1, a2);
    } __finally {
        _PrintExit("GetWindowTextW(,%ls,) -> %p\n", a1, rv);
    };
    return rv;
}

DWORD __stdcall Mine_GetWindowThreadProcessId(HWND a0,
                                              LPDWORD a1)
{
    _PrintEnter("GetWindowThreadProcessId(%p,%p)\n", a0, a1);

    DWORD rv = 0;
    __try {
        rv = Real_GetWindowThreadProcessId(a0, a1);
    } __finally {
        _PrintExit("GetWindowThreadProcessId(,) -> %p\n", rv);
    };
    return rv;
}

WORD __stdcall Mine_GetWindowWord(HWND a0,
                                  int a1)
{
    _PrintEnter("GetWindowWord(%p,%p)\n", a0, a1);

    WORD rv = 0;
    __try {
        rv = Real_GetWindowWord(a0, a1);
    } __finally {
        _PrintExit("GetWindowWord(,) -> %p\n", rv);
    };
    return rv;
}

UINT __stdcall Mine_GetWindowsDirectoryA(LPSTR a0,
                                         UINT a1)
{
    _PrintEnter("GetWindowsDirectoryA(%p,%p)\n", a0, a1);

    UINT rv = 0;
    __try {
        rv = Real_GetWindowsDirectoryA(a0, a1);
    } __finally {
        _PrintExit("GetWindowsDirectoryA(%hs,) -> %p\n", a0, rv);
    };
    return rv;
}

UINT __stdcall Mine_GetWindowsDirectoryW(LPWSTR a0,
                                         UINT a1)
{
    _PrintEnter("GetWindowsDirectoryW(%p,%p)\n", a0, a1);

    UINT rv = 0;
    __try {
        rv = Real_GetWindowsDirectoryW(a0, a1);
    } __finally {
        _PrintExit("GetWindowsDirectoryW(%ls,) -> %p\n", a0, rv);
    };
    return rv;
}

BOOL __stdcall Mine_GetWorldTransform(HDC a0,
                                      XFORM* a1)
{
    _PrintEnter("GetWorldTransform(%p,%p)\n", a0, a1);

    BOOL rv = 0;
    __try {
        rv = Real_GetWorldTransform(a0, a1);
    } __finally {
        _PrintExit("GetWorldTransform(,) -> %p\n", rv);
    };
    return rv;
}

ATOM __stdcall Mine_GlobalAddAtomA(LPCSTR a0)
{
    _PrintEnter("GlobalAddAtomA(%hs)\n", a0);

    ATOM rv = 0;
    __try {
        rv = Real_GlobalAddAtomA(a0);
    } __finally {
        _PrintExit("GlobalAddAtomA() -> %p\n", rv);
    };
    return rv;
}

ATOM __stdcall Mine_GlobalAddAtomW(LPCWSTR a0)
{
    _PrintEnter("GlobalAddAtomW(%ls)\n", a0);

    ATOM rv = 0;
    __try {
        rv = Real_GlobalAddAtomW(a0);
    } __finally {
        _PrintExit("GlobalAddAtomW() -> %p\n", rv);
    };
    return rv;
}

HGLOBAL __stdcall Mine_GlobalAlloc(UINT a0,
                                   SIZE_T a1)
{
    _PrintEnter("GlobalAlloc(%p,%p)\n", a0, a1);

    HGLOBAL rv = 0;
    __try {
        rv = Real_GlobalAlloc(a0, a1);
    } __finally {
        _PrintExit("GlobalAlloc(,) -> %p\n", rv);
    };
    return rv;
}

SIZE_T __stdcall Mine_GlobalCompact(DWORD a0)
{
    _PrintEnter("GlobalCompact(%p)\n", a0);

    SIZE_T rv = 0;
    __try {
        rv = Real_GlobalCompact(a0);
    } __finally {
        _PrintExit("GlobalCompact() -> %p\n", rv);
    };
    return rv;
}

ATOM __stdcall Mine_GlobalDeleteAtom(ATOM a0)
{
    _PrintEnter("GlobalDeleteAtom(%p)\n", a0);

    ATOM rv = 0;
    __try {
        rv = Real_GlobalDeleteAtom(a0);
    } __finally {
        _PrintExit("GlobalDeleteAtom() -> %p\n", rv);
    };
    return rv;
}

ATOM __stdcall Mine_GlobalFindAtomA(LPCSTR a0)
{
    _PrintEnter("GlobalFindAtomA(%hs)\n", a0);

    ATOM rv = 0;
    __try {
        rv = Real_GlobalFindAtomA(a0);
    } __finally {
        _PrintExit("GlobalFindAtomA() -> %p\n", rv);
    };
    return rv;
}

ATOM __stdcall Mine_GlobalFindAtomW(LPCWSTR a0)
{
    _PrintEnter("GlobalFindAtomW(%ls)\n", a0);

    ATOM rv = 0;
    __try {
        rv = Real_GlobalFindAtomW(a0);
    } __finally {
        _PrintExit("GlobalFindAtomW() -> %p\n", rv);
    };
    return rv;
}

void __stdcall Mine_GlobalFix(HGLOBAL a0)
{
    _PrintEnter("GlobalFix(%p)\n", a0);

    __try {
        Real_GlobalFix(a0);
    } __finally {
        _PrintExit("GlobalFix() ->\n");
    };
}

UINT __stdcall Mine_GlobalFlags(HGLOBAL a0)
{
    _PrintEnter("GlobalFlags(%p)\n", a0);

    UINT rv = 0;
    __try {
        rv = Real_GlobalFlags(a0);
    } __finally {
        _PrintExit("GlobalFlags() -> %p\n", rv);
    };
    return rv;
}

HGLOBAL __stdcall Mine_GlobalFree(HGLOBAL a0)
{
    _PrintEnter("GlobalFree(%p)\n", a0);

    HGLOBAL rv = 0;
    __try {
        rv = Real_GlobalFree(a0);
    } __finally {
        _PrintExit("GlobalFree() -> %p\n", rv);
    };
    return rv;
}

UINT __stdcall Mine_GlobalGetAtomNameA(ATOM a0,
                                       LPSTR a1,
                                       int a2)
{
    _PrintEnter("GlobalGetAtomNameA(%p,%p,%p)\n", a0, a1, a2);

    UINT rv = 0;
    __try {
        rv = Real_GlobalGetAtomNameA(a0, a1, a2);
    } __finally {
        _PrintExit("GlobalGetAtomNameA(,%hs,) -> %p\n", a1, rv);
    };
    return rv;
}

UINT __stdcall Mine_GlobalGetAtomNameW(ATOM a0,
                                       LPWSTR a1,
                                       int a2)
{
    _PrintEnter("GlobalGetAtomNameW(%p,%p,%p)\n", a0, a1, a2);

    UINT rv = 0;
    __try {
        rv = Real_GlobalGetAtomNameW(a0, a1, a2);
    } __finally {
        _PrintExit("GlobalGetAtomNameW(,%ls,) -> %p\n", a1, rv);
    };
    return rv;
}

HGLOBAL __stdcall Mine_GlobalHandle(LPCVOID a0)
{
    _PrintEnter("GlobalHandle(%p)\n", a0);

    HGLOBAL rv = 0;
    __try {
        rv = Real_GlobalHandle(a0);
    } __finally {
        _PrintExit("GlobalHandle() -> %p\n", rv);
    };
    return rv;
}

LPVOID __stdcall Mine_GlobalLock(HGLOBAL a0)
{
    _PrintEnter("GlobalLock(%p)\n", a0);

    LPVOID rv = 0;
    __try {
        rv = Real_GlobalLock(a0);
    } __finally {
        _PrintExit("GlobalLock() -> %p\n", rv);
    };
    return rv;
}

void __stdcall Mine_GlobalMemoryStatus(LPMEMORYSTATUS a0)
{
    _PrintEnter("GlobalMemoryStatus(%p)\n", a0);

    __try {
        Real_GlobalMemoryStatus(a0);
    } __finally {
        _PrintExit("GlobalMemoryStatus() ->\n");
    };
}

HGLOBAL __stdcall Mine_GlobalReAlloc(HGLOBAL a0,
                                     SIZE_T a1,
                                     UINT a2)
{
    _PrintEnter("GlobalReAlloc(%p,%p,%p)\n", a0, a1, a2);

    HGLOBAL rv = 0;
    __try {
        rv = Real_GlobalReAlloc(a0, a1, a2);
    } __finally {
        _PrintExit("GlobalReAlloc(,,) -> %p\n", rv);
    };
    return rv;
}

SIZE_T __stdcall Mine_GlobalSize(HGLOBAL a0)
{
    _PrintEnter("GlobalSize(%p)\n", a0);

    SIZE_T rv = 0;
    __try {
        rv = Real_GlobalSize(a0);
    } __finally {
        _PrintExit("GlobalSize() -> %p\n", rv);
    };
    return rv;
}

BOOL __stdcall Mine_GlobalUnWire(HGLOBAL a0)
{
    _PrintEnter("GlobalUnWire(%p)\n", a0);

    BOOL rv = 0;
    __try {
        rv = Real_GlobalUnWire(a0);
    } __finally {
        _PrintExit("GlobalUnWire() -> %p\n", rv);
    };
    return rv;
}

void __stdcall Mine_GlobalUnfix(HGLOBAL a0)
{
    _PrintEnter("GlobalUnfix(%p)\n", a0);

    __try {
        Real_GlobalUnfix(a0);
    } __finally {
        _PrintExit("GlobalUnfix() ->\n");
    };
}

BOOL __stdcall Mine_GlobalUnlock(HGLOBAL a0)
{
    _PrintEnter("GlobalUnlock(%p)\n", a0);

    BOOL rv = 0;
    __try {
        rv = Real_GlobalUnlock(a0);
    } __finally {
        _PrintExit("GlobalUnlock() -> %p\n", rv);
    };
    return rv;
}

LPVOID __stdcall Mine_GlobalWire(HGLOBAL a0)
{
    _PrintEnter("GlobalWire(%p)\n", a0);

    LPVOID rv = 0;
    __try {
        rv = Real_GlobalWire(a0);
    } __finally {
        _PrintExit("GlobalWire() -> %p\n", rv);
    };
    return rv;
}

BOOL __stdcall Mine_GrayStringA(HDC a0,
                                HBRUSH a1,
                                GRAYSTRINGPROC a2,
                                LPARAM a3,
                                int a4,
                                int a5,
                                int a6,
                                int a7,
                                int a8)
{
    _PrintEnter("GrayStringA(%p,%p,%p,%p,%p,%p,%p,%p,%p)\n", a0, a1, a2, a3, a4, a5, a6, a7, a8);

    BOOL rv = 0;
    __try {
        rv = Real_GrayStringA(a0, a1, a2, a3, a4, a5, a6, a7, a8);
    } __finally {
        _PrintExit("GrayStringA(,,,,,,,,) -> %p\n", rv);
    };
    return rv;
}

BOOL __stdcall Mine_GrayStringW(HDC a0,
                                HBRUSH a1,
                                GRAYSTRINGPROC a2,
                                LPARAM a3,
                                int a4,
                                int a5,
                                int a6,
                                int a7,
                                int a8)
{
    _PrintEnter("GrayStringW(%p,%p,%p,%p,%p,%p,%p,%p,%p)\n", a0, a1, a2, a3, a4, a5, a6, a7, a8);

    BOOL rv = 0;
    __try {
        rv = Real_GrayStringW(a0, a1, a2, a3, a4, a5, a6, a7, a8);
    } __finally {
        _PrintExit("GrayStringW(,,,,,,,,) -> %p\n", rv);
    };
    return rv;
}

BOOL __stdcall Mine_HeapLock(HANDLE a0)
{
    _PrintEnter("HeapLock(%p)\n", a0);

    BOOL rv = 0;
    __try {
        rv = Real_HeapLock(a0);
    } __finally {
        _PrintExit("HeapLock() -> %p\n", rv);
    };
    return rv;
}

BOOL __stdcall Mine_HeapUnlock(HANDLE a0)
{
    _PrintEnter("HeapUnlock(%p)\n", a0);

    BOOL rv = 0;
    __try {
        rv = Real_HeapUnlock(a0);
    } __finally {
        _PrintExit("HeapUnlock() -> %p\n", rv);
    };
    return rv;
}

BOOL __stdcall Mine_HideCaret(HWND a0)
{
    _PrintEnter("HideCaret(%p)\n", a0);

    BOOL rv = 0;
    __try {
        rv = Real_HideCaret(a0);
    } __finally {
        _PrintExit("HideCaret() -> %p\n", rv);
    };
    return rv;
}

BOOL __stdcall Mine_HiliteMenuItem(HWND a0,
                                   HMENU a1,
                                   UINT a2,
                                   UINT a3)
{
    _PrintEnter("HiliteMenuItem(%p,%p,%p,%p)\n", a0, a1, a2, a3);

    BOOL rv = 0;
    __try {
        rv = Real_HiliteMenuItem(a0, a1, a2, a3);
    } __finally {
        _PrintExit("HiliteMenuItem(,,,) -> %p\n", rv);
    };
    return rv;
}

HRESULT __stdcall Mine_IIDFromString(LPOLESTR a0,
                                     LPGUID a1)
{
    _PrintEnter("IIDFromString(%p,%p)\n", a0, a1);

    HRESULT rv = 0;
    __try {
        rv = Real_IIDFromString(a0, a1);
    } __finally {
        _PrintExit("IIDFromString(,) -> %p\n", rv);
    };
    return rv;
}

BOOL __stdcall Mine_ImpersonateDdeClientWindow(HWND a0,
                                               HWND a1)
{
    _PrintEnter("ImpersonateDdeClientWindow(%p,%p)\n", a0, a1);

    BOOL rv = 0;
    __try {
        rv = Real_ImpersonateDdeClientWindow(a0, a1);
    } __finally {
        _PrintExit("ImpersonateDdeClientWindow(,) -> %p\n", rv);
    };
    return rv;
}

BOOL __stdcall Mine_InSendMessage(void)
{
    _PrintEnter("InSendMessage()\n");

    BOOL rv = 0;
    __try {
        rv = Real_InSendMessage();
    } __finally {
        _PrintExit("InSendMessage() -> %p\n", rv);
    };
    return rv;
}

BOOL __stdcall Mine_InflateRect(LPRECT a0,
                                int a1,
                                int a2)
{
    _PrintEnter("InflateRect(%p,%p,%p)\n", a0, a1, a2);

    BOOL rv = 0;
    __try {
        rv = Real_InflateRect(a0, a1, a2);
    } __finally {
        _PrintExit("InflateRect(,,) -> %p\n", rv);
    };
    return rv;
}

BOOL __stdcall Mine_InitAtomTable(DWORD a0)
{
    _PrintEnter("InitAtomTable(%p)\n", a0);

    BOOL rv = 0;
    __try {
        rv = Real_InitAtomTable(a0);
    } __finally {
        _PrintExit("InitAtomTable() -> %p\n", rv);
    };
    return rv;
}

BOOL __stdcall Mine_InsertMenuA(HMENU a0,
                                UINT a1,
                                UINT a2,
                                UINT_PTR a3,
                                LPCSTR a4)
{
    _PrintEnter("InsertMenuA(%p,%p,%p,%p,%hs)\n", a0, a1, a2, a3, a4);

    BOOL rv = 0;
    __try {
        rv = Real_InsertMenuA(a0, a1, a2, a3, a4);
    } __finally {
        _PrintExit("InsertMenuA(,,,,) -> %p\n", rv);
    };
    return rv;
}

BOOL __stdcall Mine_InsertMenuItemA(HMENU a0,
                                    UINT a1,
                                    BOOL a2,
                                    MENUITEMINFOA* a3)
{
    _PrintEnter("InsertMenuItemA(%p,%p,%p,%p)\n", a0, a1, a2, a3);

    BOOL rv = 0;
    __try {
        rv = Real_InsertMenuItemA(a0, a1, a2, a3);
    } __finally {
        _PrintExit("InsertMenuItemA(,,,) -> %p\n", rv);
    };
    return rv;
}

BOOL __stdcall Mine_InsertMenuItemW(HMENU a0,
                                    UINT a1,
                                    BOOL a2,
                                    MENUITEMINFOW* a3)
{
    _PrintEnter("InsertMenuItemW(%p,%p,%p,%p)\n", a0, a1, a2, a3);

    BOOL rv = 0;
    __try {
        rv = Real_InsertMenuItemW(a0, a1, a2, a3);
    } __finally {
        _PrintExit("InsertMenuItemW(,,,) -> %p\n", rv);
    };
    return rv;
}

BOOL __stdcall Mine_InsertMenuW(HMENU a0,
                                UINT a1,
                                UINT a2,
                                UINT_PTR a3,
                                LPCWSTR a4)
{
    _PrintEnter("InsertMenuW(%p,%p,%p,%p,%ls)\n", a0, a1, a2, a3, a4);

    BOOL rv = 0;
    __try {
        rv = Real_InsertMenuW(a0, a1, a2, a3, a4);
    } __finally {
        _PrintExit("InsertMenuW(,,,,) -> %p\n", rv);
    };
    return rv;
}

int __stdcall Mine_IntersectClipRect(HDC a0,
                                     int a1,
                                     int a2,
                                     int a3,
                                     int a4)
{
    _PrintEnter("IntersectClipRect(%p,%p,%p,%p,%p)\n", a0, a1, a2, a3, a4);

    int rv = 0;
    __try {
        rv = Real_IntersectClipRect(a0, a1, a2, a3, a4);
    } __finally {
        _PrintExit("IntersectClipRect(,,,,) -> %p\n", rv);
    };
    return rv;
}

BOOL __stdcall Mine_IntersectRect(LPRECT a0,
                                  RECT* a1,
                                  RECT* a2)
{
    _PrintEnter("IntersectRect(%p,%p,%p)\n", a0, a1, a2);

    BOOL rv = 0;
    __try {
        rv = Real_IntersectRect(a0, a1, a2);
    } __finally {
        _PrintExit("IntersectRect(,,) -> %p\n", rv);
    };
    return rv;
}

BOOL __stdcall Mine_InvalidateRect(HWND a0,
                                   RECT* a1,
                                   BOOL a2)
{
    _PrintEnter("InvalidateRect(%p,%p,%p)\n", a0, a1, a2);

    BOOL rv = 0;
    __try {
        rv = Real_InvalidateRect(a0, a1, a2);
    } __finally {
        _PrintExit("InvalidateRect(,,) -> %p\n", rv);
    };
    return rv;
}

BOOL __stdcall Mine_InvalidateRgn(HWND a0,
                                  HRGN a1,
                                  BOOL a2)
{
    _PrintEnter("InvalidateRgn(%p,%p,%p)\n", a0, a1, a2);

    BOOL rv = 0;
    __try {
        rv = Real_InvalidateRgn(a0, a1, a2);
    } __finally {
        _PrintExit("InvalidateRgn(,,) -> %p\n", rv);
    };
    return rv;
}

BOOL __stdcall Mine_InvertRect(HDC a0,
                               RECT* a1)
{
    _PrintEnter("InvertRect(%p,%p)\n", a0, a1);

    BOOL rv = 0;
    __try {
        rv = Real_InvertRect(a0, a1);
    } __finally {
        _PrintExit("InvertRect(,) -> %p\n", rv);
    };
    return rv;
}

BOOL __stdcall Mine_InvertRgn(HDC a0,
                              HRGN a1)
{
    _PrintEnter("InvertRgn(%p,%p)\n", a0, a1);

    BOOL rv = 0;
    __try {
        rv = Real_InvertRgn(a0, a1);
    } __finally {
        _PrintExit("InvertRgn(,) -> %p\n", rv);
    };
    return rv;
}

BOOL __stdcall Mine_IsAccelerator(HACCEL a0,
                                  int a1,
                                  LPMSG a2,
                                  WORD* a3)
{
    _PrintEnter("IsAccelerator(%p,%p,%p,%p)\n", a0, a1, a2, a3);

    BOOL rv = 0;
    __try {
        rv = Real_IsAccelerator(a0, a1, a2, a3);
    } __finally {
        _PrintExit("IsAccelerator(,,,) -> %p\n", rv);
    };
    return rv;
}

BOOL __stdcall Mine_IsBadCodePtr(FARPROC a0)
{
    _PrintEnter("IsBadCodePtr(%p)\n", a0);

    BOOL rv = 0;
    __try {
        rv = Real_IsBadCodePtr(a0);
    } __finally {
        _PrintExit("IsBadCodePtr() -> %p\n", rv);
    };
    return rv;
}

BOOL __stdcall Mine_IsBadHugeReadPtr(void* a0,
                                     UINT_PTR a1)
{
    _PrintEnter("IsBadHugeReadPtr(%p,%p)\n", a0, a1);

    BOOL rv = 0;
    __try {
        rv = Real_IsBadHugeReadPtr(a0, a1);
    } __finally {
        _PrintExit("IsBadHugeReadPtr(,) -> %p\n", rv);
    };
    return rv;
}

BOOL __stdcall Mine_IsBadHugeWritePtr(LPVOID a0,
                                      UINT_PTR a1)
{
    _PrintEnter("IsBadHugeWritePtr(%p,%p)\n", a0, a1);

    BOOL rv = 0;
    __try {
        rv = Real_IsBadHugeWritePtr(a0, a1);
    } __finally {
        _PrintExit("IsBadHugeWritePtr(,) -> %p\n", rv);
    };
    return rv;
}

BOOL __stdcall Mine_IsBadReadPtr(void* a0,
                                 UINT_PTR a1)
{
    _PrintEnter("IsBadReadPtr(%p,%p)\n", a0, a1);

    BOOL rv = 0;
    __try {
        rv = Real_IsBadReadPtr(a0, a1);
    } __finally {
        _PrintExit("IsBadReadPtr(,) -> %p\n", rv);
    };
    return rv;
}

BOOL __stdcall Mine_IsBadStringPtrA(LPCSTR a0,
                                    UINT_PTR a1)
{
    _PrintEnter("IsBadStringPtrA(%hs,%p)\n", a0, a1);

    BOOL rv = 0;
    __try {
        rv = Real_IsBadStringPtrA(a0, a1);
    } __finally {
        _PrintExit("IsBadStringPtrA(,) -> %p\n", rv);
    };
    return rv;
}

BOOL __stdcall Mine_IsBadStringPtrW(LPCWSTR a0,
                                    UINT_PTR a1)
{
    _PrintEnter("IsBadStringPtrW(%ls,%p)\n", a0, a1);

    BOOL rv = 0;
    __try {
        rv = Real_IsBadStringPtrW(a0, a1);
    } __finally {
        _PrintExit("IsBadStringPtrW(,) -> %p\n", rv);
    };
    return rv;
}

BOOL __stdcall Mine_IsBadWritePtr(LPVOID a0,
                                  UINT_PTR a1)
{
    _PrintEnter("IsBadWritePtr(%p,%p)\n", a0, a1);

    BOOL rv = 0;
    __try {
        rv = Real_IsBadWritePtr(a0, a1);
    } __finally {
        _PrintExit("IsBadWritePtr(,) -> %p\n", rv);
    };
    return rv;
}

BOOL __stdcall Mine_IsCharAlphaA(CHAR a0)
{
    _PrintEnter("IsCharAlphaA(%p)\n", a0);

    BOOL rv = 0;
    __try {
        rv = Real_IsCharAlphaA(a0);
    } __finally {
        _PrintExit("IsCharAlphaA() -> %p\n", rv);
    };
    return rv;
}

BOOL __stdcall Mine_IsCharAlphaNumericA(CHAR a0)
{
    _PrintEnter("IsCharAlphaNumericA(%p)\n", a0);

    BOOL rv = 0;
    __try {
        rv = Real_IsCharAlphaNumericA(a0);
    } __finally {
        _PrintExit("IsCharAlphaNumericA() -> %p\n", rv);
    };
    return rv;
}

BOOL __stdcall Mine_IsCharAlphaNumericW(WCHAR a0)
{
    _PrintEnter("IsCharAlphaNumericW(%p)\n", a0);

    BOOL rv = 0;
    __try {
        rv = Real_IsCharAlphaNumericW(a0);
    } __finally {
        _PrintExit("IsCharAlphaNumericW() -> %p\n", rv);
    };
    return rv;
}

BOOL __stdcall Mine_IsCharAlphaW(WCHAR a0)
{
    _PrintEnter("IsCharAlphaW(%p)\n", a0);

    BOOL rv = 0;
    __try {
        rv = Real_IsCharAlphaW(a0);
    } __finally {
        _PrintExit("IsCharAlphaW() -> %p\n", rv);
    };
    return rv;
}

BOOL __stdcall Mine_IsCharLowerA(CHAR a0)
{
    _PrintEnter("IsCharLowerA(%p)\n", a0);

    BOOL rv = 0;
    __try {
        rv = Real_IsCharLowerA(a0);
    } __finally {
        _PrintExit("IsCharLowerA() -> %p\n", rv);
    };
    return rv;
}

BOOL __stdcall Mine_IsCharLowerW(WCHAR a0)
{
    _PrintEnter("IsCharLowerW(%p)\n", a0);

    BOOL rv = 0;
    __try {
        rv = Real_IsCharLowerW(a0);
    } __finally {
        _PrintExit("IsCharLowerW() -> %p\n", rv);
    };
    return rv;
}

BOOL __stdcall Mine_IsCharUpperA(CHAR a0)
{
    _PrintEnter("IsCharUpperA(%p)\n", a0);

    BOOL rv = 0;
    __try {
        rv = Real_IsCharUpperA(a0);
    } __finally {
        _PrintExit("IsCharUpperA() -> %p\n", rv);
    };
    return rv;
}

BOOL __stdcall Mine_IsCharUpperW(WCHAR a0)
{
    _PrintEnter("IsCharUpperW(%p)\n", a0);

    BOOL rv = 0;
    __try {
        rv = Real_IsCharUpperW(a0);
    } __finally {
        _PrintExit("IsCharUpperW() -> %p\n", rv);
    };
    return rv;
}

BOOL __stdcall Mine_IsChild(HWND a0,
                            HWND a1)
{
    _PrintEnter("IsChild(%p,%p)\n", a0, a1);

    BOOL rv = 0;
    __try {
        rv = Real_IsChild(a0, a1);
    } __finally {
        _PrintExit("IsChild(,) -> %p\n", rv);
    };
    return rv;
}

BOOL __stdcall Mine_IsClipboardFormatAvailable(UINT a0)
{
    _PrintEnter("IsClipboardFormatAvailable(%p)\n", a0);

    BOOL rv = 0;
    __try {
        rv = Real_IsClipboardFormatAvailable(a0);
    } __finally {
        _PrintExit("IsClipboardFormatAvailable() -> %p\n", rv);
    };
    return rv;
}

BOOL __stdcall Mine_IsDBCSLeadByte(BYTE a0)
{
    _PrintEnter("IsDBCSLeadByte(%p)\n", a0);

    BOOL rv = 0;
    __try {
        rv = Real_IsDBCSLeadByte(a0);
    } __finally {
        _PrintExit("IsDBCSLeadByte() -> %p\n", rv);
    };
    return rv;
}

BOOL __stdcall Mine_IsDBCSLeadByteEx(UINT a0,
                                     BYTE a1)
{
    _PrintEnter("IsDBCSLeadByteEx(%p,%p)\n", a0, a1);

    BOOL rv = 0;
    __try {
        rv = Real_IsDBCSLeadByteEx(a0, a1);
    } __finally {
        _PrintExit("IsDBCSLeadByteEx(,) -> %p\n", rv);
    };
    return rv;
}

BOOL __stdcall Mine_IsDebuggerPresent(void)
{
    _PrintEnter("IsDebuggerPresent()\n");

    BOOL rv = 0;
    __try {
        rv = Real_IsDebuggerPresent();
    } __finally {
        _PrintExit("IsDebuggerPresent() -> %p\n", rv);
    };
    return rv;
}

BOOL __stdcall Mine_IsDialogMessageA(HWND a0,
                                     LPMSG a1)
{
    _PrintEnter("IsDialogMessageA(%p,%p)\n", a0, a1);

    BOOL rv = 0;
    __try {
        rv = Real_IsDialogMessageA(a0, a1);
    } __finally {
        _PrintExit("IsDialogMessageA(,) -> %p\n", rv);
    };
    return rv;
}

BOOL __stdcall Mine_IsDialogMessageW(HWND a0,
                                     LPMSG a1)
{
    _PrintEnter("IsDialogMessageW(%p,%p)\n", a0, a1);

    BOOL rv = 0;
    __try {
        rv = Real_IsDialogMessageW(a0, a1);
    } __finally {
        _PrintExit("IsDialogMessageW(,) -> %p\n", rv);
    };
    return rv;
}

UINT __stdcall Mine_IsDlgButtonChecked(HWND a0,
                                       int a1)
{
    _PrintEnter("IsDlgButtonChecked(%p,%p)\n", a0, a1);

    UINT rv = 0;
    __try {
        rv = Real_IsDlgButtonChecked(a0, a1);
    } __finally {
        _PrintExit("IsDlgButtonChecked(,) -> %p\n", rv);
    };
    return rv;
}

BOOL __stdcall Mine_IsIconic(HWND a0)
{
    _PrintEnter("IsIconic(%p)\n", a0);

    BOOL rv = 0;
    __try {
        rv = Real_IsIconic(a0);
    } __finally {
        _PrintExit("IsIconic() -> %p\n", rv);
    };
    return rv;
}

BOOL __stdcall Mine_IsMenu(HMENU a0)
{
    _PrintEnter("IsMenu(%p)\n", a0);

    BOOL rv = 0;
    __try {
        rv = Real_IsMenu(a0);
    } __finally {
        _PrintExit("IsMenu() -> %p\n", rv);
    };
    return rv;
}

#if !defined(DETOURS_ARM)
BOOL __stdcall Mine_IsProcessorFeaturePresent(DWORD a0)
{
    _PrintEnter("IsProcessorFeaturePresent(%p)\n", a0);

    BOOL rv = 0;
    __try {
        rv = Real_IsProcessorFeaturePresent(a0);
    } __finally {
        _PrintExit("IsProcessorFeaturePresent() -> %p\n", rv);
    };
    return rv;
}
#endif // !DETOURS_ARM

BOOL __stdcall Mine_IsRectEmpty(RECT* a0)
{
    _PrintEnter("IsRectEmpty(%p)\n", a0);

    BOOL rv = 0;
    __try {
        rv = Real_IsRectEmpty(a0);
    } __finally {
        _PrintExit("IsRectEmpty() -> %p\n", rv);
    };
    return rv;
}

BOOL __stdcall Mine_IsValidCodePage(UINT a0)
{
    _PrintEnter("IsValidCodePage(%p)\n", a0);

    BOOL rv = 0;
    __try {
        rv = Real_IsValidCodePage(a0);
    } __finally {
        _PrintExit("IsValidCodePage() -> %p\n", rv);
    };
    return rv;
}

BOOL __stdcall Mine_IsValidLocale(LCID a0,
                                  DWORD a1)
{
    _PrintEnter("IsValidLocale(%p,%p)\n", a0, a1);

    BOOL rv = 0;
    __try {
        rv = Real_IsValidLocale(a0, a1);
    } __finally {
        _PrintExit("IsValidLocale(,) -> %p\n", rv);
    };
    return rv;
}

BOOL __stdcall Mine_IsWindow(HWND a0)
{
    _PrintEnter("IsWindow(%p)\n", a0);

    BOOL rv = 0;
    __try {
        rv = Real_IsWindow(a0);
    } __finally {
        _PrintExit("IsWindow() -> %p\n", rv);
    };
    return rv;
}

BOOL __stdcall Mine_IsWindowEnabled(HWND a0)
{
    _PrintEnter("IsWindowEnabled(%p)\n", a0);

    BOOL rv = 0;
    __try {
        rv = Real_IsWindowEnabled(a0);
    } __finally {
        _PrintExit("IsWindowEnabled() -> %p\n", rv);
    };
    return rv;
}

BOOL __stdcall Mine_IsWindowUnicode(HWND a0)
{
    _PrintEnter("IsWindowUnicode(%p)\n", a0);

    BOOL rv = 0;
    __try {
        rv = Real_IsWindowUnicode(a0);
    } __finally {
        _PrintExit("IsWindowUnicode() -> %p\n", rv);
    };
    return rv;
}

BOOL __stdcall Mine_IsWindowVisible(HWND a0)
{
    _PrintEnter("IsWindowVisible(%p)\n", a0);

    BOOL rv = 0;
    __try {
        rv = Real_IsWindowVisible(a0);
    } __finally {
        _PrintExit("IsWindowVisible() -> %p\n", rv);
    };
    return rv;
}

BOOL __stdcall Mine_IsZoomed(HWND a0)
{
    _PrintEnter("IsZoomed(%p)\n", a0);

    BOOL rv = 0;
    __try {
        rv = Real_IsZoomed(a0);
    } __finally {
        _PrintExit("IsZoomed() -> %p\n", rv);
    };
    return rv;
}

BOOL __stdcall Mine_KillTimer(HWND a0,
                              UINT_PTR a1)
{
    _PrintEnter("KillTimer(%p,%p)\n", a0, a1);

    BOOL rv = 0;
    __try {
        rv = Real_KillTimer(a0, a1);
    } __finally {
        _PrintExit("KillTimer(,) -> %p\n", rv);
    };
    return rv;
}

BOOL __stdcall Mine_LPtoDP(HDC a0,
                           POINT* a1,
                           int a2)
{
    _PrintEnter("LPtoDP(%p,%p,%p)\n", a0, a1, a2);

    BOOL rv = 0;
    __try {
        rv = Real_LPtoDP(a0, a1, a2);
    } __finally {
        _PrintExit("LPtoDP(,,) -> %p\n", rv);
    };
    return rv;
}

BOOL __stdcall Mine_LineDDA(int a0,
                            int a1,
                            int a2,
                            int a3,
                            LINEDDAPROC a4,
                            LPARAM a5)
{
    _PrintEnter("LineDDA(%p,%p,%p,%p,%p,%p)\n", a0, a1, a2, a3, a4, a5);

    BOOL rv = 0;
    __try {
        rv = Real_LineDDA(a0, a1, a2, a3, a4, a5);
    } __finally {
        _PrintExit("LineDDA(,,,,,) -> %p\n", rv);
    };
    return rv;
}

BOOL __stdcall Mine_LineTo(HDC a0,
                           int a1,
                           int a2)
{
    _PrintEnter("LineTo(%p,%p,%p)\n", a0, a1, a2);

    BOOL rv = 0;
    __try {
        rv = Real_LineTo(a0, a1, a2);
    } __finally {
        _PrintExit("LineTo(,,) -> %p\n", rv);
    };
    return rv;
}

HACCEL __stdcall Mine_LoadAcceleratorsA(HINSTANCE a0,
                                        LPCSTR a1)
{
    _PrintEnter("LoadAcceleratorsA(%p,%hs)\n", a0, a1);

    HACCEL rv = 0;
    __try {
        rv = Real_LoadAcceleratorsA(a0, a1);
    } __finally {
        _PrintExit("LoadAcceleratorsA(,) -> %p\n", rv);
    };
    return rv;
}

HACCEL __stdcall Mine_LoadAcceleratorsW(HINSTANCE a0,
                                        LPCWSTR a1)
{
    _PrintEnter("LoadAcceleratorsW(%p,%ls)\n", a0, a1);

    HACCEL rv = 0;
    __try {
        rv = Real_LoadAcceleratorsW(a0, a1);
    } __finally {
        _PrintExit("LoadAcceleratorsW(,) -> %p\n", rv);
    };
    return rv;
}

HBITMAP __stdcall Mine_LoadBitmapA(HINSTANCE a0,
                                   LPCSTR a1)
{
    _PrintEnter("LoadBitmapA(%p,%hs)\n", a0, a1);

    HBITMAP rv = 0;
    __try {
        rv = Real_LoadBitmapA(a0, a1);
    } __finally {
        _PrintExit("LoadBitmapA(,) -> %p\n", rv);
    };
    return rv;
}

HBITMAP __stdcall Mine_LoadBitmapW(HINSTANCE a0,
                                   LPCWSTR a1)
{
    _PrintEnter("LoadBitmapW(%p,%ls)\n", a0, a1);

    HBITMAP rv = 0;
    __try {
        rv = Real_LoadBitmapW(a0, a1);
    } __finally {
        _PrintExit("LoadBitmapW(,) -> %p\n", rv);
    };
    return rv;
}

HCURSOR __stdcall Mine_LoadCursorA(HINSTANCE a0,
                                   LPCSTR a1)
{
    _PrintEnter("LoadCursorA(%p,%hs)\n", a0, a1);

    HCURSOR rv = 0;
    __try {
        rv = Real_LoadCursorA(a0, a1);
    } __finally {
        _PrintExit("LoadCursorA(,) -> %p\n", rv);
    };
    return rv;
}

HCURSOR __stdcall Mine_LoadCursorFromFileA(LPCSTR a0)
{
    _PrintEnter("LoadCursorFromFileA(%hs)\n", a0);

    HCURSOR rv = 0;
    __try {
        rv = Real_LoadCursorFromFileA(a0);
    } __finally {
        _PrintExit("LoadCursorFromFileA() -> %p\n", rv);
    };
    return rv;
}

HCURSOR __stdcall Mine_LoadCursorFromFileW(LPCWSTR a0)
{
    _PrintEnter("LoadCursorFromFileW(%ls)\n", a0);

    HCURSOR rv = 0;
    __try {
        rv = Real_LoadCursorFromFileW(a0);
    } __finally {
        _PrintExit("LoadCursorFromFileW() -> %p\n", rv);
    };
    return rv;
}

HCURSOR __stdcall Mine_LoadCursorW(HINSTANCE a0,
                                   LPCWSTR a1)
{
    _PrintEnter("LoadCursorW(%p,%ls)\n", a0, a1);

    HCURSOR rv = 0;
    __try {
        rv = Real_LoadCursorW(a0, a1);
    } __finally {
        _PrintExit("LoadCursorW(,) -> %p\n", rv);
    };
    return rv;
}

HICON __stdcall Mine_LoadIconA(HINSTANCE a0,
                               LPCSTR a1)
{
    _PrintEnter("LoadIconA(%p,%hs)\n", a0, a1);

    HICON rv = 0;
    __try {
        rv = Real_LoadIconA(a0, a1);
    } __finally {
        _PrintExit("LoadIconA(,) -> %p\n", rv);
    };
    return rv;
}

HICON __stdcall Mine_LoadIconW(HINSTANCE a0,
                               LPCWSTR a1)
{
    _PrintEnter("LoadIconW(%p,%ls)\n", a0, a1);

    HICON rv = 0;
    __try {
        rv = Real_LoadIconW(a0, a1);
    } __finally {
        _PrintExit("LoadIconW(,) -> %p\n", rv);
    };
    return rv;
}

HANDLE __stdcall Mine_LoadImageA(HINSTANCE a0,
                                 LPCSTR a1,
                                 UINT a2,
                                 int a3,
                                 int a4,
                                 UINT a5)
{
    _PrintEnter("LoadImageA(%p,%hs,%p,%p,%p,%p)\n", a0, a1, a2, a3, a4, a5);

    HANDLE rv = 0;
    __try {
        rv = Real_LoadImageA(a0, a1, a2, a3, a4, a5);
    } __finally {
        _PrintExit("LoadImageA(,,,,,) -> %p\n", rv);
    };
    return rv;
}

HANDLE __stdcall Mine_LoadImageW(HINSTANCE a0,
                                 LPCWSTR a1,
                                 UINT a2,
                                 int a3,
                                 int a4,
                                 UINT a5)
{
    _PrintEnter("LoadImageW(%p,%ls,%p,%p,%p,%p)\n", a0, a1, a2, a3, a4, a5);

    HANDLE rv = 0;
    __try {
        rv = Real_LoadImageW(a0, a1, a2, a3, a4, a5);
    } __finally {
        _PrintExit("LoadImageW(,,,,,) -> %p\n", rv);
    };
    return rv;
}

HKL __stdcall Mine_LoadKeyboardLayoutA(LPCSTR a0,
                                       UINT a1)
{
    _PrintEnter("LoadKeyboardLayoutA(%hs,%p)\n", a0, a1);

    HKL rv = 0;
    __try {
        rv = Real_LoadKeyboardLayoutA(a0, a1);
    } __finally {
        _PrintExit("LoadKeyboardLayoutA(,) -> %p\n", rv);
    };
    return rv;
}

HKL __stdcall Mine_LoadKeyboardLayoutW(LPCWSTR a0,
                                       UINT a1)
{
    _PrintEnter("LoadKeyboardLayoutW(%ls,%p)\n", a0, a1);

    HKL rv = 0;
    __try {
        rv = Real_LoadKeyboardLayoutW(a0, a1);
    } __finally {
        _PrintExit("LoadKeyboardLayoutW(,) -> %p\n", rv);
    };
    return rv;
}

HMODULE __stdcall Mine_LoadLibraryA(LPCSTR a0)
{
    _PrintEnter("LoadLibraryA(%hs)\n", a0);

    HMODULE rv = 0;
    __try {
        rv = Real_LoadLibraryA(a0);
    } __finally {
        _PrintExit("LoadLibraryA() -> %p\n", rv);
    };
    return rv;
}

HMODULE __stdcall Mine_LoadLibraryExA(LPCSTR a0,
                                      HANDLE a1,
                                      DWORD a2)
{
    _PrintEnter("LoadLibraryExA(%hs,%p,%p)\n", a0, a1, a2);

    HMODULE rv = 0;
    __try {
        rv = Real_LoadLibraryExA(a0, a1, a2);
    } __finally {
        _PrintExit("LoadLibraryExA(,,) -> %p\n", rv);
    };
    return rv;
}

HMODULE __stdcall Mine_LoadLibraryExW(LPCWSTR a0,
                                      HANDLE a1,
                                      DWORD a2)
{
    _PrintEnter("LoadLibraryExW(%ls,%p,%p)\n", a0, a1, a2);

    HMODULE rv = 0;
    __try {
        rv = Real_LoadLibraryExW(a0, a1, a2);
    } __finally {
        _PrintExit("LoadLibraryExW(,,) -> %p\n", rv);
    };
    return rv;
}

HMODULE __stdcall Mine_LoadLibraryW(LPCWSTR a0)
{
    _PrintEnter("LoadLibraryW(%ls)\n", a0);

    HMODULE rv = 0;
    __try {
        rv = Real_LoadLibraryW(a0);
    } __finally {
        _PrintExit("LoadLibraryW() -> %p\n", rv);
    };
    return rv;
}

HMENU __stdcall Mine_LoadMenuA(HINSTANCE a0,
                               LPCSTR a1)
{
    _PrintEnter("LoadMenuA(%p,%hs)\n", a0, a1);

    HMENU rv = 0;
    __try {
        rv = Real_LoadMenuA(a0, a1);
    } __finally {
        _PrintExit("LoadMenuA(,) -> %p\n", rv);
    };
    return rv;
}

HMENU __stdcall Mine_LoadMenuIndirectA(MENUTEMPLATEA* a0)
{
    _PrintEnter("LoadMenuIndirectA(%p)\n", a0);

    HMENU rv = 0;
    __try {
        rv = Real_LoadMenuIndirectA(a0);
    } __finally {
        _PrintExit("LoadMenuIndirectA() -> %p\n", rv);
    };
    return rv;
}

HMENU __stdcall Mine_LoadMenuIndirectW(MENUTEMPLATEW* a0)
{
    _PrintEnter("LoadMenuIndirectW(%p)\n", a0);

    HMENU rv = 0;
    __try {
        rv = Real_LoadMenuIndirectW(a0);
    } __finally {
        _PrintExit("LoadMenuIndirectW() -> %p\n", rv);
    };
    return rv;
}

HMENU __stdcall Mine_LoadMenuW(HINSTANCE a0,
                               LPCWSTR a1)
{
    _PrintEnter("LoadMenuW(%p,%ls)\n", a0, a1);

    HMENU rv = 0;
    __try {
        rv = Real_LoadMenuW(a0, a1);
    } __finally {
        _PrintExit("LoadMenuW(,) -> %p\n", rv);
    };
    return rv;
}

DWORD __stdcall Mine_LoadModule(LPCSTR a0,
                                LPVOID a1)
{
    _PrintEnter("LoadModule(%hs,%p)\n", a0, a1);

    DWORD rv = 0;
    __try {
        rv = Real_LoadModule(a0, a1);
    } __finally {
        _PrintExit("LoadModule(,) -> %p\n", rv);
    };
    return rv;
}

HGLOBAL __stdcall Mine_LoadResource(HMODULE a0,
                                    HRSRC a1)
{
    _PrintEnter("LoadResource(%p,%p)\n", a0, a1);

    HGLOBAL rv = 0;
    __try {
        rv = Real_LoadResource(a0, a1);
    } __finally {
        _PrintExit("LoadResource(,) -> %p\n", rv);
    };
    return rv;
}

int __stdcall Mine_LoadStringA(HINSTANCE a0,
                               UINT a1,
                               LPSTR a2,
                               int a3)
{
    _PrintEnter("LoadStringA(%p,%p,%p,%p)\n", a0, a1, a2, a3);

    int rv = 0;
    __try {
        rv = Real_LoadStringA(a0, a1, a2, a3);
    } __finally {
        _PrintExit("LoadStringA(,,%hs,) -> %p\n", a2, rv);
    };
    return rv;
}

int __stdcall Mine_LoadStringW(HINSTANCE a0,
                               UINT a1,
                               LPWSTR a2,
                               int a3)
{
    _PrintEnter("LoadStringW(%p,%p,%p,%p)\n", a0, a1, a2, a3);

    int rv = 0;
    __try {
        rv = Real_LoadStringW(a0, a1, a2, a3);
    } __finally {
        _PrintExit("LoadStringW(,,%ls,) -> %p\n", a2, rv);
    };
    return rv;
}

HLOCAL __stdcall Mine_LocalAlloc(UINT a0,
                                 SIZE_T a1)
{
    _PrintEnter("LocalAlloc(%p,%p)\n", a0, a1);

    HLOCAL rv = 0;
    __try {
        rv = Real_LocalAlloc(a0, a1);
    } __finally {
        _PrintExit("LocalAlloc(,) -> %p\n", rv);
    };
    return rv;
}

SIZE_T __stdcall Mine_LocalCompact(UINT a0)
{
    _PrintEnter("LocalCompact(%p)\n", a0);

    SIZE_T rv = 0;
    __try {
        rv = Real_LocalCompact(a0);
    } __finally {
        _PrintExit("LocalCompact() -> %p\n", rv);
    };
    return rv;
}

BOOL __stdcall Mine_LocalFileTimeToFileTime(FILETIME* a0,
                                            LPFILETIME a1)
{
    _PrintEnter("LocalFileTimeToFileTime(%p,%p)\n", a0, a1);

    BOOL rv = 0;
    __try {
        rv = Real_LocalFileTimeToFileTime(a0, a1);
    } __finally {
        _PrintExit("LocalFileTimeToFileTime(,) -> %p\n", rv);
    };
    return rv;
}

UINT __stdcall Mine_LocalFlags(HLOCAL a0)
{
    _PrintEnter("LocalFlags(%p)\n", a0);

    UINT rv = 0;
    __try {
        rv = Real_LocalFlags(a0);
    } __finally {
        _PrintExit("LocalFlags() -> %p\n", rv);
    };
    return rv;
}

HLOCAL __stdcall Mine_LocalFree(HLOCAL a0)
{
    _PrintEnter("LocalFree(%p)\n", a0);

    HLOCAL rv = 0;
    __try {
        rv = Real_LocalFree(a0);
    } __finally {
        _PrintExit("LocalFree() -> %p\n", rv);
    };
    return rv;
}

HLOCAL __stdcall Mine_LocalHandle(LPCVOID a0)
{
    _PrintEnter("LocalHandle(%p)\n", a0);

    HLOCAL rv = 0;
    __try {
        rv = Real_LocalHandle(a0);
    } __finally {
        _PrintExit("LocalHandle() -> %p\n", rv);
    };
    return rv;
}

LPVOID __stdcall Mine_LocalLock(HLOCAL a0)
{
    _PrintEnter("LocalLock(%p)\n", a0);

    LPVOID rv = 0;
    __try {
        rv = Real_LocalLock(a0);
    } __finally {
        _PrintExit("LocalLock() -> %p\n", rv);
    };
    return rv;
}

HLOCAL __stdcall Mine_LocalReAlloc(HLOCAL a0,
                                   SIZE_T a1,
                                   UINT a2)
{
    _PrintEnter("LocalReAlloc(%p,%p,%p)\n", a0, a1, a2);

    HLOCAL rv = 0;
    __try {
        rv = Real_LocalReAlloc(a0, a1, a2);
    } __finally {
        _PrintExit("LocalReAlloc(,,) -> %p\n", rv);
    };
    return rv;
}

SIZE_T __stdcall Mine_LocalShrink(HLOCAL a0,
                                  UINT a1)
{
    _PrintEnter("LocalShrink(%p,%p)\n", a0, a1);

    SIZE_T rv = 0;
    __try {
        rv = Real_LocalShrink(a0, a1);
    } __finally {
        _PrintExit("LocalShrink(,) -> %p\n", rv);
    };
    return rv;
}

SIZE_T __stdcall Mine_LocalSize(HLOCAL a0)
{
    _PrintEnter("LocalSize(%p)\n", a0);

    SIZE_T rv = 0;
    __try {
        rv = Real_LocalSize(a0);
    } __finally {
        _PrintExit("LocalSize() -> %p\n", rv);
    };
    return rv;
}

BOOL __stdcall Mine_LocalUnlock(HLOCAL a0)
{
    _PrintEnter("LocalUnlock(%p)\n", a0);

    BOOL rv = 0;
    __try {
        rv = Real_LocalUnlock(a0);
    } __finally {
        _PrintExit("LocalUnlock() -> %p\n", rv);
    };
    return rv;
}

BOOL __stdcall Mine_LockFile(HANDLE a0,
                             DWORD a1,
                             DWORD a2,
                             DWORD a3,
                             DWORD a4)
{
    _PrintEnter("LockFile(%p,%p,%p,%p,%p)\n", a0, a1, a2, a3, a4);

    BOOL rv = 0;
    __try {
        rv = Real_LockFile(a0, a1, a2, a3, a4);
    } __finally {
        _PrintExit("LockFile(,,,,) -> %p\n", rv);
    };
    return rv;
}

BOOL __stdcall Mine_LockFileEx(HANDLE a0,
                               DWORD a1,
                               DWORD a2,
                               DWORD a3,
                               DWORD a4,
                               LPOVERLAPPED a5)
{
    _PrintEnter("LockFileEx(%p,%p,%p,%p,%p,%p)\n", a0, a1, a2, a3, a4, a5);

    BOOL rv = 0;
    __try {
        rv = Real_LockFileEx(a0, a1, a2, a3, a4, a5);
    } __finally {
        _PrintExit("LockFileEx(,,,,,) -> %p\n", rv);
    };
    return rv;
}

LPVOID __stdcall Mine_LockResource(HGLOBAL a0)
{
    _PrintEnter("LockResource(%p)\n", a0);

    LPVOID rv = 0;
    __try {
        rv = Real_LockResource(a0);
    } __finally {
        _PrintExit("LockResource() -> %p\n", rv);
    };
    return rv;
}

BOOL __stdcall Mine_LockWindowUpdate(HWND a0)
{
    _PrintEnter("LockWindowUpdate(%p)\n", a0);

    BOOL rv = 0;
    __try {
        rv = Real_LockWindowUpdate(a0);
    } __finally {
        _PrintExit("LockWindowUpdate() -> %p\n", rv);
    };
    return rv;
}

int __stdcall Mine_LookupIconIdFromDirectory(PBYTE a0,
                                             BOOL a1)
{
    _PrintEnter("LookupIconIdFromDirectory(%p,%p)\n", a0, a1);

    int rv = 0;
    __try {
        rv = Real_LookupIconIdFromDirectory(a0, a1);
    } __finally {
        _PrintExit("LookupIconIdFromDirectory(,) -> %p\n", rv);
    };
    return rv;
}

int __stdcall Mine_LookupIconIdFromDirectoryEx(PBYTE a0,
                                               BOOL a1,
                                               int a2,
                                               int a3,
                                               UINT a4)
{
    _PrintEnter("LookupIconIdFromDirectoryEx(%p,%p,%p,%p,%p)\n", a0, a1, a2, a3, a4);

    int rv = 0;
    __try {
        rv = Real_LookupIconIdFromDirectoryEx(a0, a1, a2, a3, a4);
    } __finally {
        _PrintExit("LookupIconIdFromDirectoryEx(,,,,) -> %p\n", rv);
    };
    return rv;
}

BOOL __stdcall Mine_MapDialogRect(HWND a0,
                                  LPRECT a1)
{
    _PrintEnter("MapDialogRect(%p,%p)\n", a0, a1);

    BOOL rv = 0;
    __try {
        rv = Real_MapDialogRect(a0, a1);
    } __finally {
        _PrintExit("MapDialogRect(,) -> %p\n", rv);
    };
    return rv;
}

LPVOID __stdcall Mine_MapViewOfFile(HANDLE a0,
                                    DWORD a1,
                                    DWORD a2,
                                    DWORD a3,
                                    SIZE_T a4)
{
    _PrintEnter("MapViewOfFile(%p,%p,%p,%p,%p)\n", a0, a1, a2, a3, a4);

    LPVOID rv = 0;
    __try {
        rv = Real_MapViewOfFile(a0, a1, a2, a3, a4);
    } __finally {
        _PrintExit("MapViewOfFile(,,,,) -> %p\n", rv);
    };
    return rv;
}

LPVOID __stdcall Mine_MapViewOfFileEx(HANDLE a0,
                                      DWORD a1,
                                      DWORD a2,
                                      DWORD a3,
                                      SIZE_T a4,
                                      LPVOID a5)
{
    _PrintEnter("MapViewOfFileEx(%p,%p,%p,%p,%p,%p)\n", a0, a1, a2, a3, a4, a5);

    LPVOID rv = 0;
    __try {
        rv = Real_MapViewOfFileEx(a0, a1, a2, a3, a4, a5);
    } __finally {
        _PrintExit("MapViewOfFileEx(,,,,,) -> %p\n", rv);
    };
    return rv;
}

UINT __stdcall Mine_MapVirtualKeyA(UINT a0,
                                   UINT a1)
{
    _PrintEnter("MapVirtualKeyA(%p,%p)\n", a0, a1);

    UINT rv = 0;
    __try {
        rv = Real_MapVirtualKeyA(a0, a1);
    } __finally {
        _PrintExit("MapVirtualKeyA(,) -> %p\n", rv);
    };
    return rv;
}

UINT __stdcall Mine_MapVirtualKeyExA(UINT a0,
                                     UINT a1,
                                     HKL a2)
{
    _PrintEnter("MapVirtualKeyExA(%p,%p,%p)\n", a0, a1, a2);

    UINT rv = 0;
    __try {
        rv = Real_MapVirtualKeyExA(a0, a1, a2);
    } __finally {
        _PrintExit("MapVirtualKeyExA(,,) -> %p\n", rv);
    };
    return rv;
}

UINT __stdcall Mine_MapVirtualKeyExW(UINT a0,
                                     UINT a1,
                                     HKL a2)
{
    _PrintEnter("MapVirtualKeyExW(%p,%p,%p)\n", a0, a1, a2);

    UINT rv = 0;
    __try {
        rv = Real_MapVirtualKeyExW(a0, a1, a2);
    } __finally {
        _PrintExit("MapVirtualKeyExW(,,) -> %p\n", rv);
    };
    return rv;
}

UINT __stdcall Mine_MapVirtualKeyW(UINT a0,
                                   UINT a1)
{
    _PrintEnter("MapVirtualKeyW(%p,%p)\n", a0, a1);

    UINT rv = 0;
    __try {
        rv = Real_MapVirtualKeyW(a0, a1);
    } __finally {
        _PrintExit("MapVirtualKeyW(,) -> %p\n", rv);
    };
    return rv;
}

int __stdcall Mine_MapWindowPoints(HWND a0,
                                   HWND a1,
                                   POINT* a2,
                                   UINT a3)
{
    _PrintEnter("MapWindowPoints(%p,%p,%p,%p)\n", a0, a1, a2, a3);

    int rv = 0;
    __try {
        rv = Real_MapWindowPoints(a0, a1, a2, a3);
    } __finally {
        _PrintExit("MapWindowPoints(,,,) -> %p\n", rv);
    };
    return rv;
}

BOOL __stdcall Mine_MaskBlt(HDC a0,
                            int a1,
                            int a2,
                            int a3,
                            int a4,
                            HDC a5,
                            int a6,
                            int a7,
                            HBITMAP a8,
                            int a9,
                            int a10,
                            DWORD a11)
{
    _PrintEnter("MaskBlt(%p,%p,%p,%p,%p,%p,%p,%p,%p,%p,%p,%p)\n", a0, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11);

    BOOL rv = 0;
    __try {
        rv = Real_MaskBlt(a0, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11);
    } __finally {
        _PrintExit("MaskBlt(,,,,,,,,,,,) -> %p\n", rv);
    };
    return rv;
}

int __stdcall Mine_MenuItemFromPoint(HWND a0,
                                     HMENU a1,
                                     POINT a2)
{
    _PrintEnter("MenuItemFromPoint(%p,%p,%p)\n", a0, a1, a2);

    int rv = 0;
    __try {
        rv = Real_MenuItemFromPoint(a0, a1, a2);
    } __finally {
        _PrintExit("MenuItemFromPoint(,,) -> %p\n", rv);
    };
    return rv;
}

BOOL __stdcall Mine_MessageBeep(UINT a0)
{
    _PrintEnter("MessageBeep(%p)\n", a0);

    BOOL rv = 0;
    __try {
        rv = Real_MessageBeep(a0);
    } __finally {
        _PrintExit("MessageBeep() -> %p\n", rv);
    };
    return rv;
}

int __stdcall Mine_MessageBoxA(HWND a0,
                               LPCSTR a1,
                               LPCSTR a2,
                               UINT a3)
{
    _PrintEnter("MessageBoxA(%p,%hs,%hs,%p)\n", a0, a1, a2, a3);

    int rv = 0;
    __try {
        rv = Real_MessageBoxA(a0, a1, a2, a3);
    } __finally {
        _PrintExit("MessageBoxA(,,,) -> %p\n", rv);
    };
    return rv;
}

int __stdcall Mine_MessageBoxExA(HWND a0,
                                 LPCSTR a1,
                                 LPCSTR a2,
                                 UINT a3,
                                 WORD a4)
{
    _PrintEnter("MessageBoxExA(%p,%hs,%hs,%p,%p)\n", a0, a1, a2, a3, a4);

    int rv = 0;
    __try {
        rv = Real_MessageBoxExA(a0, a1, a2, a3, a4);
    } __finally {
        _PrintExit("MessageBoxExA(,,,,) -> %p\n", rv);
    };
    return rv;
}

int __stdcall Mine_MessageBoxExW(HWND a0,
                                 LPCWSTR a1,
                                 LPCWSTR a2,
                                 UINT a3,
                                 WORD a4)
{
    _PrintEnter("MessageBoxExW(%p,%ls,%ls,%p,%p)\n", a0, a1, a2, a3, a4);

    int rv = 0;
    __try {
        rv = Real_MessageBoxExW(a0, a1, a2, a3, a4);
    } __finally {
        _PrintExit("MessageBoxExW(,,,,) -> %p\n", rv);
    };
    return rv;
}

int __stdcall Mine_MessageBoxIndirectA(MSGBOXPARAMSA* a0)
{
    _PrintEnter("MessageBoxIndirectA(%p)\n", a0);

    int rv = 0;
    __try {
        rv = Real_MessageBoxIndirectA(a0);
    } __finally {
        _PrintExit("MessageBoxIndirectA() -> %p\n", rv);
    };
    return rv;
}

int __stdcall Mine_MessageBoxIndirectW(MSGBOXPARAMSW* a0)
{
    _PrintEnter("MessageBoxIndirectW(%p)\n", a0);

    int rv = 0;
    __try {
        rv = Real_MessageBoxIndirectW(a0);
    } __finally {
        _PrintExit("MessageBoxIndirectW() -> %p\n", rv);
    };
    return rv;
}

int __stdcall Mine_MessageBoxW(HWND a0,
                               LPCWSTR a1,
                               LPCWSTR a2,
                               UINT a3)
{
    _PrintEnter("MessageBoxW(%p,%ls,%ls,%p)\n", a0, a1, a2, a3);

    int rv = 0;
    __try {
        rv = Real_MessageBoxW(a0, a1, a2, a3);
    } __finally {
        _PrintExit("MessageBoxW(,,,) -> %p\n", rv);
    };
    return rv;
}

HRESULT __stdcall Mine_MkParseDisplayName(IBindCtx* a0,
                                          LPCOLESTR a1,
                                          ULONG* a2,
                                          IMoniker** a3)
{
    _PrintEnter("MkParseDisplayName(%p,%p,%p,%p)\n", a0, a1, a2, a3);

    HRESULT rv = 0;
    __try {
        rv = Real_MkParseDisplayName(a0, a1, a2, a3);
    } __finally {
        _PrintExit("MkParseDisplayName(,,,) -> %p\n", rv);
    };
    return rv;
}

BOOL __stdcall Mine_ModifyMenuA(HMENU a0,
                                UINT a1,
                                UINT a2,
                                UINT_PTR a3,
                                LPCSTR a4)
{
    _PrintEnter("ModifyMenuA(%p,%p,%p,%p,%hs)\n", a0, a1, a2, a3, a4);

    BOOL rv = 0;
    __try {
        rv = Real_ModifyMenuA(a0, a1, a2, a3, a4);
    } __finally {
        _PrintExit("ModifyMenuA(,,,,) -> %p\n", rv);
    };
    return rv;
}

BOOL __stdcall Mine_ModifyMenuW(HMENU a0,
                                UINT a1,
                                UINT a2,
                                UINT_PTR a3,
                                LPCWSTR a4)
{
    _PrintEnter("ModifyMenuW(%p,%p,%p,%p,%ls)\n", a0, a1, a2, a3, a4);

    BOOL rv = 0;
    __try {
        rv = Real_ModifyMenuW(a0, a1, a2, a3, a4);
    } __finally {
        _PrintExit("ModifyMenuW(,,,,) -> %p\n", rv);
    };
    return rv;
}

BOOL __stdcall Mine_ModifyWorldTransform(HDC a0,
                                         XFORM* a1,
                                         DWORD a2)
{
    _PrintEnter("ModifyWorldTransform(%p,%p,%p)\n", a0, a1, a2);

    BOOL rv = 0;
    __try {
        rv = Real_ModifyWorldTransform(a0, a1, a2);
    } __finally {
        _PrintExit("ModifyWorldTransform(,,) -> %p\n", rv);
    };
    return rv;
}

HRESULT __stdcall Mine_MonikerCommonPrefixWith(IMoniker* a0,
                                               IMoniker* a1,
                                               IMoniker** a2)
{
    _PrintEnter("MonikerCommonPrefixWith(%p,%p,%p)\n", a0, a1, a2);

    HRESULT rv = 0;
    __try {
        rv = Real_MonikerCommonPrefixWith(a0, a1, a2);
    } __finally {
        _PrintExit("MonikerCommonPrefixWith(,,) -> %p\n", rv);
    };
    return rv;
}

HRESULT __stdcall Mine_MonikerRelativePathTo(IMoniker* a0,
                                             IMoniker* a1,
                                             IMoniker** a2,
                                             BOOL a3)
{
    _PrintEnter("MonikerRelativePathTo(%p,%p,%p,%p)\n", a0, a1, a2, a3);

    HRESULT rv = 0;
    __try {
        rv = Real_MonikerRelativePathTo(a0, a1, a2, a3);
    } __finally {
        _PrintExit("MonikerRelativePathTo(,,,) -> %p\n", rv);
    };
    return rv;
}

BOOL __stdcall Mine_MoveFileA(LPCSTR a0,
                              LPCSTR a1)
{
    _PrintEnter("MoveFileA(%hs,%hs)\n", a0, a1);

    BOOL rv = 0;
    __try {
        rv = Real_MoveFileA(a0, a1);
    } __finally {
        _PrintExit("MoveFileA(,) -> %p\n", rv);
    };
    return rv;
}

BOOL __stdcall Mine_MoveFileExA(LPCSTR a0,
                                LPCSTR a1,
                                DWORD a2)
{
    _PrintEnter("MoveFileExA(%hs,%hs,%p)\n", a0, a1, a2);

    BOOL rv = 0;
    __try {
        rv = Real_MoveFileExA(a0, a1, a2);
    } __finally {
        _PrintExit("MoveFileExA(,,) -> %p\n", rv);
    };
    return rv;
}

BOOL __stdcall Mine_MoveFileExW(LPCWSTR a0,
                                LPCWSTR a1,
                                DWORD a2)
{
    _PrintEnter("MoveFileExW(%ls,%ls,%p)\n", a0, a1, a2);

    BOOL rv = 0;
    __try {
        rv = Real_MoveFileExW(a0, a1, a2);
    } __finally {
        _PrintExit("MoveFileExW(,,) -> %p\n", rv);
    };
    return rv;
}

BOOL __stdcall Mine_MoveFileW(LPCWSTR a0,
                              LPCWSTR a1)
{
    _PrintEnter("MoveFileW(%ls,%ls)\n", a0, a1);

    BOOL rv = 0;
    __try {
        rv = Real_MoveFileW(a0, a1);
    } __finally {
        _PrintExit("MoveFileW(,) -> %p\n", rv);
    };
    return rv;
}

BOOL __stdcall Mine_MoveToEx(HDC a0,
                             int a1,
                             int a2,
                             POINT* a3)
{
    _PrintEnter("MoveToEx(%p,%p,%p,%p)\n", a0, a1, a2, a3);

    BOOL rv = 0;
    __try {
        rv = Real_MoveToEx(a0, a1, a2, a3);
    } __finally {
        _PrintExit("MoveToEx(,,,) -> %p\n", rv);
    };
    return rv;
}

BOOL __stdcall Mine_MoveWindow(HWND a0,
                               int a1,
                               int a2,
                               int a3,
                               int a4,
                               BOOL a5)
{
    _PrintEnter("MoveWindow(%p,%p,%p,%p,%p,%p)\n", a0, a1, a2, a3, a4, a5);

    BOOL rv = 0;
    __try {
        rv = Real_MoveWindow(a0, a1, a2, a3, a4, a5);
    } __finally {
        _PrintExit("MoveWindow(,,,,,) -> %p\n", rv);
    };
    return rv;
}

DWORD __stdcall Mine_MsgWaitForMultipleObjects(DWORD a0,
                                               void** a1,
                                               BOOL a2,
                                               DWORD a3,
                                               DWORD a4)
{
    _PrintEnter("MsgWaitForMultipleObjects(%p,%p,%p,%p,%p)\n", a0, a1, a2, a3, a4);

    DWORD rv = 0;
    __try {
        rv = Real_MsgWaitForMultipleObjects(a0, a1, a2, a3, a4);
    } __finally {
        _PrintExit("MsgWaitForMultipleObjects(,,,,) -> %p\n", rv);
    };
    return rv;
}

DWORD __stdcall Mine_MsgWaitForMultipleObjectsEx(DWORD a0,
                                                 void** a1,
                                                 DWORD a2,
                                                 DWORD a3,
                                                 DWORD a4)
{
    _PrintEnter("MsgWaitForMultipleObjectsEx(%p,%p,%p,%p,%p)\n", a0, a1, a2, a3, a4);

    DWORD rv = 0;
    __try {
        rv = Real_MsgWaitForMultipleObjectsEx(a0, a1, a2, a3, a4);
    } __finally {
        _PrintExit("MsgWaitForMultipleObjectsEx(,,,,) -> %p\n", rv);
    };
    return rv;
}

int __stdcall Mine_MulDiv(int a0,
                          int a1,
                          int a2)
{
    _PrintEnter("MulDiv(%p,%p,%p)\n", a0, a1, a2);

    int rv = 0;
    __try {
        rv = Real_MulDiv(a0, a1, a2);
    } __finally {
        _PrintExit("MulDiv(,,) -> %p\n", rv);
    };
    return rv;
}

DWORD __stdcall Mine_OemKeyScan(WORD a0)
{
    _PrintEnter("OemKeyScan(%p)\n", a0);

    DWORD rv = 0;
    __try {
        rv = Real_OemKeyScan(a0);
    } __finally {
        _PrintExit("OemKeyScan() -> %p\n", rv);
    };
    return rv;
}

BOOL __stdcall Mine_OemToCharA(LPCSTR a0,
                               LPSTR a1)
{
    _PrintEnter("OemToCharA(%hs,%p)\n", a0, a1);

    BOOL rv = 0;
    __try {
        rv = Real_OemToCharA(a0, a1);
    } __finally {
        _PrintExit("OemToCharA(,%hs) -> %p\n", a1, rv);
    };
    return rv;
}

BOOL __stdcall Mine_OemToCharBuffA(LPCSTR a0,
                                   LPSTR a1,
                                   DWORD a2)
{
    _PrintEnter("OemToCharBuffA(%hs,%p,%p)\n", a0, a1, a2);

    BOOL rv = 0;
    __try {
        rv = Real_OemToCharBuffA(a0, a1, a2);
    } __finally {
        _PrintExit("OemToCharBuffA(,%hs,) -> %p\n", a1, rv);
    };
    return rv;
}

BOOL __stdcall Mine_OemToCharBuffW(LPCSTR a0,
                                   LPWSTR a1,
                                   DWORD a2)
{
    _PrintEnter("OemToCharBuffW(%hs,%p,%p)\n", a0, a1, a2);

    BOOL rv = 0;
    __try {
        rv = Real_OemToCharBuffW(a0, a1, a2);
    } __finally {
        _PrintExit("OemToCharBuffW(,%ls,) -> %p\n", a1, rv);
    };
    return rv;
}

BOOL __stdcall Mine_OemToCharW(LPCSTR a0,
                               LPWSTR a1)
{
    _PrintEnter("OemToCharW(%hs,%p)\n", a0, a1);

    BOOL rv = 0;
    __try {
        rv = Real_OemToCharW(a0, a1);
    } __finally {
        _PrintExit("OemToCharW(,%ls) -> %p\n", a1, rv);
    };
    return rv;
}

int __stdcall Mine_OffsetClipRgn(HDC a0,
                                 int a1,
                                 int a2)
{
    _PrintEnter("OffsetClipRgn(%p,%p,%p)\n", a0, a1, a2);

    int rv = 0;
    __try {
        rv = Real_OffsetClipRgn(a0, a1, a2);
    } __finally {
        _PrintExit("OffsetClipRgn(,,) -> %p\n", rv);
    };
    return rv;
}

BOOL __stdcall Mine_OffsetRect(LPRECT a0,
                               int a1,
                               int a2)
{
    _PrintEnter("OffsetRect(%p,%p,%p)\n", a0, a1, a2);

    BOOL rv = 0;
    __try {
        rv = Real_OffsetRect(a0, a1, a2);
    } __finally {
        _PrintExit("OffsetRect(,,) -> %p\n", rv);
    };
    return rv;
}

int __stdcall Mine_OffsetRgn(HRGN a0,
                             int a1,
                             int a2)
{
    _PrintEnter("OffsetRgn(%p,%p,%p)\n", a0, a1, a2);

    int rv = 0;
    __try {
        rv = Real_OffsetRgn(a0, a1, a2);
    } __finally {
        _PrintExit("OffsetRgn(,,) -> %p\n", rv);
    };
    return rv;
}

BOOL __stdcall Mine_OffsetViewportOrgEx(HDC a0,
                                        int a1,
                                        int a2,
                                        POINT* a3)
{
    _PrintEnter("OffsetViewportOrgEx(%p,%p,%p,%p)\n", a0, a1, a2, a3);

    BOOL rv = 0;
    __try {
        rv = Real_OffsetViewportOrgEx(a0, a1, a2, a3);
    } __finally {
        _PrintExit("OffsetViewportOrgEx(,,,) -> %p\n", rv);
    };
    return rv;
}

BOOL __stdcall Mine_OffsetWindowOrgEx(HDC a0,
                                      int a1,
                                      int a2,
                                      POINT* a3)
{
    _PrintEnter("OffsetWindowOrgEx(%p,%p,%p,%p)\n", a0, a1, a2, a3);

    BOOL rv = 0;
    __try {
        rv = Real_OffsetWindowOrgEx(a0, a1, a2, a3);
    } __finally {
        _PrintExit("OffsetWindowOrgEx(,,,) -> %p\n", rv);
    };
    return rv;
}

DWORD __stdcall Mine_OleBuildVersion(void)
{
    _PrintEnter("OleBuildVersion()\n");

    DWORD rv = 0;
    __try {
        rv = Real_OleBuildVersion();
    } __finally {
        _PrintExit("OleBuildVersion() -> %p\n", rv);
    };
    return rv;
}

HRESULT __stdcall Mine_OleConvertIStorageToOLESTREAM(LPSTORAGE a0,
                                                     LPOLESTREAM a1)
{
    _PrintEnter("OleConvertIStorageToOLESTREAM(%p,%p)\n", a0, a1);

    HRESULT rv = 0;
    __try {
        rv = Real_OleConvertIStorageToOLESTREAM(a0, a1);
    } __finally {
        _PrintExit("OleConvertIStorageToOLESTREAM(,) -> %p\n", rv);
    };
    return rv;
}

HRESULT __stdcall Mine_OleConvertIStorageToOLESTREAMEx(LPSTORAGE a0,
                                                       CLIPFORMAT a1,
                                                       LONG a2,
                                                       LONG a3,
                                                       DWORD a4,
                                                       LPSTGMEDIUM a5,
                                                       LPOLESTREAM a6)
{
    _PrintEnter("OleConvertIStorageToOLESTREAMEx(%p,%p,%p,%p,%p,%p,%p)\n", a0, a1, a2, a3, a4, a5, a6);

    HRESULT rv = 0;
    __try {
        rv = Real_OleConvertIStorageToOLESTREAMEx(a0, a1, a2, a3, a4, a5, a6);
    } __finally {
        _PrintExit("OleConvertIStorageToOLESTREAMEx(,,,,,,) -> %p\n", rv);
    };
    return rv;
}

HRESULT __stdcall Mine_OleConvertOLESTREAMToIStorage(LPOLESTREAM a0,
                                                     LPSTORAGE a1,
                                                     DVTARGETDEVICE* a2)
{
    _PrintEnter("OleConvertOLESTREAMToIStorage(%p,%p,%p)\n", a0, a1, a2);

    HRESULT rv = 0;
    __try {
        rv = Real_OleConvertOLESTREAMToIStorage(a0, a1, a2);
    } __finally {
        _PrintExit("OleConvertOLESTREAMToIStorage(,,) -> %p\n", rv);
    };
    return rv;
}

HRESULT __stdcall Mine_OleConvertOLESTREAMToIStorageEx(LPOLESTREAM a0,
                                                       LPSTORAGE a1,
                                                       CLIPFORMAT* a2,
                                                       LONG* a3,
                                                       LONG* a4,
                                                       DWORD* a5,
                                                       LPSTGMEDIUM a6)
{
    _PrintEnter("OleConvertOLESTREAMToIStorageEx(%p,%p,%p,%p,%p,%p,%p)\n", a0, a1, a2, a3, a4, a5, a6);

    HRESULT rv = 0;
    __try {
        rv = Real_OleConvertOLESTREAMToIStorageEx(a0, a1, a2, a3, a4, a5, a6);
    } __finally {
        _PrintExit("OleConvertOLESTREAMToIStorageEx(,,,,,,) -> %p\n", rv);
    };
    return rv;
}

HRESULT __stdcall Mine_OleCreate(CONST IID& a0,
                                 CONST IID& a1,
                                 DWORD a2,
                                 LPFORMATETC a3,
                                 LPOLECLIENTSITE a4,
                                 LPSTORAGE a5,
                                 LPVOID* a6)
{
    _PrintEnter("OleCreate(%p,%p,%p,%p,%p,%p,%p)\n", a0, a1, a2, a3, a4, a5, a6);

    HRESULT rv = 0;
    __try {
        rv = Real_OleCreate(a0, a1, a2, a3, a4, a5, a6);
    } __finally {
        _PrintExit("OleCreate(,,,,,,) -> %p\n", rv);
    };
    return rv;
}

HRESULT __stdcall Mine_OleCreateDefaultHandler(CONST IID& a0,
                                               LPUNKNOWN a1,
                                               CONST IID& a2,
                                               LPVOID* a3)
{
    _PrintEnter("OleCreateDefaultHandler(%p,%p,%p,%p)\n", a0, a1, a2, a3);

    HRESULT rv = 0;
    __try {
        rv = Real_OleCreateDefaultHandler(a0, a1, a2, a3);
    } __finally {
        _PrintExit("OleCreateDefaultHandler(,,,) -> %p\n", rv);
    };
    return rv;
}

HRESULT __stdcall Mine_OleCreateEmbeddingHelper(CONST IID& a0,
                                                LPUNKNOWN a1,
                                                DWORD a2,
                                                LPCLASSFACTORY a3,
                                                CONST IID& a4,
                                                LPVOID* a5)
{
    _PrintEnter("OleCreateEmbeddingHelper(%p,%p,%p,%p,%p,%p)\n", a0, a1, a2, a3, a4, a5);

    HRESULT rv = 0;
    __try {
        rv = Real_OleCreateEmbeddingHelper(a0, a1, a2, a3, a4, a5);
    } __finally {
        _PrintExit("OleCreateEmbeddingHelper(,,,,,) -> %p\n", rv);
    };
    return rv;
}

HRESULT __stdcall Mine_OleCreateEx(CONST IID& a0,
                                   CONST IID& a1,
                                   DWORD a2,
                                   DWORD a3,
                                   ULONG a4,
                                   DWORD* a5,
                                   LPFORMATETC a6,
                                   IAdviseSink* a7,
                                   DWORD* a8,
                                   LPOLECLIENTSITE a9,
                                   LPSTORAGE a10,
                                   LPVOID* a11)
{
    _PrintEnter("OleCreateEx(%p,%p,%p,%p,%p,%p,%p,%p,%p,%p,%p,%p)\n", a0, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11);

    HRESULT rv = 0;
    __try {
        rv = Real_OleCreateEx(a0, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11);
    } __finally {
        _PrintExit("OleCreateEx(,,,,,,,,,,,) -> %p\n", rv);
    };
    return rv;
}

HRESULT __stdcall Mine_OleCreateFromData(IDataObject* a0,
                                         CONST IID& a1,
                                         DWORD a2,
                                         LPFORMATETC a3,
                                         LPOLECLIENTSITE a4,
                                         LPSTORAGE a5,
                                         LPVOID* a6)
{
    _PrintEnter("OleCreateFromData(%p,%p,%p,%p,%p,%p,%p)\n", a0, a1, a2, a3, a4, a5, a6);

    HRESULT rv = 0;
    __try {
        rv = Real_OleCreateFromData(a0, a1, a2, a3, a4, a5, a6);
    } __finally {
        _PrintExit("OleCreateFromData(,,,,,,) -> %p\n", rv);
    };
    return rv;
}

HRESULT __stdcall Mine_OleCreateFromDataEx(IDataObject* a0,
                                           CONST IID& a1,
                                           DWORD a2,
                                           DWORD a3,
                                           ULONG a4,
                                           DWORD* a5,
                                           LPFORMATETC a6,
                                           IAdviseSink* a7,
                                           DWORD* a8,
                                           LPOLECLIENTSITE a9,
                                           LPSTORAGE a10,
                                           LPVOID* a11)
{
    _PrintEnter("OleCreateFromDataEx(%p,%p,%p,%p,%p,%p,%p,%p,%p,%p,%p,%p)\n", a0, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11);

    HRESULT rv = 0;
    __try {
        rv = Real_OleCreateFromDataEx(a0, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11);
    } __finally {
        _PrintExit("OleCreateFromDataEx(,,,,,,,,,,,) -> %p\n", rv);
    };
    return rv;
}

HRESULT __stdcall Mine_OleCreateFromFile(CONST IID& a0,
                                         LPCOLESTR a1,
                                         CONST IID& a2,
                                         DWORD a3,
                                         LPFORMATETC a4,
                                         LPOLECLIENTSITE a5,
                                         LPSTORAGE a6,
                                         LPVOID* a7)
{
    _PrintEnter("OleCreateFromFile(%p,%p,%p,%p,%p,%p,%p,%p)\n", a0, a1, a2, a3, a4, a5, a6, a7);

    HRESULT rv = 0;
    __try {
        rv = Real_OleCreateFromFile(a0, a1, a2, a3, a4, a5, a6, a7);
    } __finally {
        _PrintExit("OleCreateFromFile(,,,,,,,) -> %p\n", rv);
    };
    return rv;
}

HRESULT __stdcall Mine_OleCreateFromFileEx(CONST IID& a0,
                                           LPCOLESTR a1,
                                           CONST IID& a2,
                                           DWORD a3,
                                           DWORD a4,
                                           ULONG a5,
                                           DWORD* a6,
                                           LPFORMATETC a7,
                                           IAdviseSink* a8,
                                           DWORD* a9,
                                           LPOLECLIENTSITE a10,
                                           LPSTORAGE a11,
                                           LPVOID* a12)
{
    _PrintEnter("OleCreateFromFileEx(%p,%p,%p,%p,%p,%p,%p,%p,%p,%p,%p,%p,%p)\n", a0, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12);

    HRESULT rv = 0;
    __try {
        rv = Real_OleCreateFromFileEx(a0, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12);
    } __finally {
        _PrintExit("OleCreateFromFileEx(,,,,,,,,,,,,) -> %p\n", rv);
    };
    return rv;
}

HRESULT __stdcall Mine_OleCreateLink(IMoniker* a0,
                                     CONST IID& a1,
                                     DWORD a2,
                                     LPFORMATETC a3,
                                     LPOLECLIENTSITE a4,
                                     LPSTORAGE a5,
                                     LPVOID* a6)
{
    _PrintEnter("OleCreateLink(%p,%p,%p,%p,%p,%p,%p)\n", a0, a1, a2, a3, a4, a5, a6);

    HRESULT rv = 0;
    __try {
        rv = Real_OleCreateLink(a0, a1, a2, a3, a4, a5, a6);
    } __finally {
        _PrintExit("OleCreateLink(,,,,,,) -> %p\n", rv);
    };
    return rv;
}

HRESULT __stdcall Mine_OleCreateLinkEx(IMoniker* a0,
                                       CONST IID& a1,
                                       DWORD a2,
                                       DWORD a3,
                                       ULONG a4,
                                       DWORD* a5,
                                       LPFORMATETC a6,
                                       IAdviseSink* a7,
                                       DWORD* a8,
                                       LPOLECLIENTSITE a9,
                                       LPSTORAGE a10,
                                       LPVOID* a11)
{
    _PrintEnter("OleCreateLinkEx(%p,%p,%p,%p,%p,%p,%p,%p,%p,%p,%p,%p)\n", a0, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11);

    HRESULT rv = 0;
    __try {
        rv = Real_OleCreateLinkEx(a0, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11);
    } __finally {
        _PrintExit("OleCreateLinkEx(,,,,,,,,,,,) -> %p\n", rv);
    };
    return rv;
}

HRESULT __stdcall Mine_OleCreateLinkFromData(IDataObject* a0,
                                             CONST IID& a1,
                                             DWORD a2,
                                             LPFORMATETC a3,
                                             LPOLECLIENTSITE a4,
                                             LPSTORAGE a5,
                                             LPVOID* a6)
{
    _PrintEnter("OleCreateLinkFromData(%p,%p,%p,%p,%p,%p,%p)\n", a0, a1, a2, a3, a4, a5, a6);

    HRESULT rv = 0;
    __try {
        rv = Real_OleCreateLinkFromData(a0, a1, a2, a3, a4, a5, a6);
    } __finally {
        _PrintExit("OleCreateLinkFromData(,,,,,,) -> %p\n", rv);
    };
    return rv;
}

HRESULT __stdcall Mine_OleCreateLinkFromDataEx(IDataObject* a0,
                                               CONST IID& a1,
                                               DWORD a2,
                                               DWORD a3,
                                               ULONG a4,
                                               DWORD* a5,
                                               LPFORMATETC a6,
                                               IAdviseSink* a7,
                                               DWORD* a8,
                                               LPOLECLIENTSITE a9,
                                               LPSTORAGE a10,
                                               LPVOID* a11)
{
    _PrintEnter("OleCreateLinkFromDataEx(%p,%p,%p,%p,%p,%p,%p,%p,%p,%p,%p,%p)\n", a0, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11);

    HRESULT rv = 0;
    __try {
        rv = Real_OleCreateLinkFromDataEx(a0, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11);
    } __finally {
        _PrintExit("OleCreateLinkFromDataEx(,,,,,,,,,,,) -> %p\n", rv);
    };
    return rv;
}

HRESULT __stdcall Mine_OleCreateLinkToFile(LPCOLESTR a0,
                                           CONST IID& a1,
                                           DWORD a2,
                                           LPFORMATETC a3,
                                           LPOLECLIENTSITE a4,
                                           LPSTORAGE a5,
                                           LPVOID* a6)
{
    _PrintEnter("OleCreateLinkToFile(%p,%p,%p,%p,%p,%p,%p)\n", a0, a1, a2, a3, a4, a5, a6);

    HRESULT rv = 0;
    __try {
        rv = Real_OleCreateLinkToFile(a0, a1, a2, a3, a4, a5, a6);
    } __finally {
        _PrintExit("OleCreateLinkToFile(,,,,,,) -> %p\n", rv);
    };
    return rv;
}

HRESULT __stdcall Mine_OleCreateLinkToFileEx(LPCOLESTR a0,
                                             CONST IID& a1,
                                             DWORD a2,
                                             DWORD a3,
                                             ULONG a4,
                                             DWORD* a5,
                                             LPFORMATETC a6,
                                             IAdviseSink* a7,
                                             DWORD* a8,
                                             LPOLECLIENTSITE a9,
                                             LPSTORAGE a10,
                                             LPVOID* a11)
{
    _PrintEnter("OleCreateLinkToFileEx(%p,%p,%p,%p,%p,%p,%p,%p,%p,%p,%p,%p)\n", a0, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11);

    HRESULT rv = 0;
    __try {
        rv = Real_OleCreateLinkToFileEx(a0, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11);
    } __finally {
        _PrintExit("OleCreateLinkToFileEx(,,,,,,,,,,,) -> %p\n", rv);
    };
    return rv;
}

HOLEMENU __stdcall Mine_OleCreateMenuDescriptor(HMENU a0,
                                                LPOLEMENUGROUPWIDTHS a1)
{
    _PrintEnter("OleCreateMenuDescriptor(%p,%p)\n", a0, a1);

    HOLEMENU rv = 0;
    __try {
        rv = Real_OleCreateMenuDescriptor(a0, a1);
    } __finally {
        _PrintExit("OleCreateMenuDescriptor(,) -> %p\n", rv);
    };
    return rv;
}

HRESULT __stdcall Mine_OleCreateStaticFromData(IDataObject* a0,
                                               CONST IID& a1,
                                               DWORD a2,
                                               LPFORMATETC a3,
                                               LPOLECLIENTSITE a4,
                                               LPSTORAGE a5,
                                               LPVOID* a6)
{
    _PrintEnter("OleCreateStaticFromData(%p,%p,%p,%p,%p,%p,%p)\n", a0, a1, a2, a3, a4, a5, a6);

    HRESULT rv = 0;
    __try {
        rv = Real_OleCreateStaticFromData(a0, a1, a2, a3, a4, a5, a6);
    } __finally {
        _PrintExit("OleCreateStaticFromData(,,,,,,) -> %p\n", rv);
    };
    return rv;
}

HRESULT __stdcall Mine_OleDestroyMenuDescriptor(HOLEMENU a0)
{
    _PrintEnter("OleDestroyMenuDescriptor(%p)\n", a0);

    HRESULT rv = 0;
    __try {
        rv = Real_OleDestroyMenuDescriptor(a0);
    } __finally {
        _PrintExit("OleDestroyMenuDescriptor() -> %p\n", rv);
    };
    return rv;
}

HRESULT __stdcall Mine_OleDoAutoConvert(LPSTORAGE a0,
                                        LPGUID a1)
{
    _PrintEnter("OleDoAutoConvert(%p,%p)\n", a0, a1);

    HRESULT rv = 0;
    __try {
        rv = Real_OleDoAutoConvert(a0, a1);
    } __finally {
        _PrintExit("OleDoAutoConvert(,) -> %p\n", rv);
    };
    return rv;
}

HRESULT __stdcall Mine_OleDraw(LPUNKNOWN a0,
                               DWORD a1,
                               HDC a2,
                               LPCRECT a3)
{
    _PrintEnter("OleDraw(%p,%p,%p,%p)\n", a0, a1, a2, a3);

    HRESULT rv = 0;
    __try {
        rv = Real_OleDraw(a0, a1, a2, a3);
    } __finally {
        _PrintExit("OleDraw(,,,) -> %p\n", rv);
    };
    return rv;
}

HANDLE __stdcall Mine_OleDuplicateData(HANDLE a0,
                                       CLIPFORMAT a1,
                                       UINT a2)
{
    _PrintEnter("OleDuplicateData(%p,%p,%p)\n", a0, a1, a2);

    HANDLE rv = 0;
    __try {
        rv = Real_OleDuplicateData(a0, a1, a2);
    } __finally {
        _PrintExit("OleDuplicateData(,,) -> %p\n", rv);
    };
    return rv;
}

HRESULT __stdcall Mine_OleFlushClipboard(void)
{
    _PrintEnter("OleFlushClipboard()\n");

    HRESULT rv = 0;
    __try {
        rv = Real_OleFlushClipboard();
    } __finally {
        _PrintExit("OleFlushClipboard() -> %p\n", rv);
    };
    return rv;
}

HRESULT __stdcall Mine_OleGetAutoConvert(CONST IID& a0,
                                         LPGUID a1)
{
    _PrintEnter("OleGetAutoConvert(%p,%p)\n", a0, a1);

    HRESULT rv = 0;
    __try {
        rv = Real_OleGetAutoConvert(a0, a1);
    } __finally {
        _PrintExit("OleGetAutoConvert(,) -> %p\n", rv);
    };
    return rv;
}

HRESULT __stdcall Mine_OleGetClipboard(IDataObject** a0)
{
    _PrintEnter("OleGetClipboard(%p)\n", a0);

    HRESULT rv = 0;
    __try {
        rv = Real_OleGetClipboard(a0);
    } __finally {
        _PrintExit("OleGetClipboard() -> %p\n", rv);
    };
    return rv;
}

HGLOBAL __stdcall Mine_OleGetIconOfClass(CONST IID& a0,
                                         LPOLESTR a1,
                                         BOOL a2)
{
    _PrintEnter("OleGetIconOfClass(%p,%p,%p)\n", a0, a1, a2);

    HGLOBAL rv = 0;
    __try {
        rv = Real_OleGetIconOfClass(a0, a1, a2);
    } __finally {
        _PrintExit("OleGetIconOfClass(,,) -> %p\n", rv);
    };
    return rv;
}

HGLOBAL __stdcall Mine_OleGetIconOfFile(LPOLESTR a0,
                                        BOOL a1)
{
    _PrintEnter("OleGetIconOfFile(%p,%p)\n", a0, a1);

    HGLOBAL rv = 0;
    __try {
        rv = Real_OleGetIconOfFile(a0, a1);
    } __finally {
        _PrintExit("OleGetIconOfFile(,) -> %p\n", rv);
    };
    return rv;
}

HRESULT __stdcall Mine_OleInitialize(LPVOID a0)
{
    _PrintEnter("OleInitialize(%p)\n", a0);

    HRESULT rv = 0;
    __try {
        rv = Real_OleInitialize(a0);
    } __finally {
        _PrintExit("OleInitialize() -> %p\n", rv);
    };
    return rv;
}

HRESULT __stdcall Mine_OleIsCurrentClipboard(IDataObject* a0)
{
    _PrintEnter("OleIsCurrentClipboard(%p)\n", a0);

    HRESULT rv = 0;
    __try {
        rv = Real_OleIsCurrentClipboard(a0);
    } __finally {
        _PrintExit("OleIsCurrentClipboard() -> %p\n", rv);
    };
    return rv;
}

BOOL __stdcall Mine_OleIsRunning(IOleObject* a0)
{
    _PrintEnter("OleIsRunning(%p)\n", a0);

    BOOL rv = 0;
    __try {
        rv = Real_OleIsRunning(a0);
    } __finally {
        _PrintExit("OleIsRunning() -> %p\n", rv);
    };
    return rv;
}

HRESULT __stdcall Mine_OleLoad(LPSTORAGE a0,
                               CONST IID& a1,
                               LPOLECLIENTSITE a2,
                               LPVOID* a3)
{
    _PrintEnter("OleLoad(%p,%p,%p,%p)\n", a0, a1, a2, a3);

    HRESULT rv = 0;
    __try {
        rv = Real_OleLoad(a0, a1, a2, a3);
    } __finally {
        _PrintExit("OleLoad(,,,) -> %p\n", rv);
    };
    return rv;
}

HRESULT __stdcall Mine_OleLoadFromStream(LPSTREAM a0,
                                         CONST IID& a1,
                                         LPVOID* a2)
{
    _PrintEnter("OleLoadFromStream(%p,%p,%p)\n", a0, a1, a2);

    HRESULT rv = 0;
    __try {
        rv = Real_OleLoadFromStream(a0, a1, a2);
    } __finally {
        _PrintExit("OleLoadFromStream(,,) -> %p\n", rv);
    };
    return rv;
}

HRESULT __stdcall Mine_OleLockRunning(LPUNKNOWN a0,
                                      BOOL a1,
                                      BOOL a2)
{
    _PrintEnter("OleLockRunning(%p,%p,%p)\n", a0, a1, a2);

    HRESULT rv = 0;
    __try {
        rv = Real_OleLockRunning(a0, a1, a2);
    } __finally {
        _PrintExit("OleLockRunning(,,) -> %p\n", rv);
    };
    return rv;
}

HGLOBAL __stdcall Mine_OleMetafilePictFromIconAndLabel(HICON a0,
                                                       LPOLESTR a1,
                                                       LPOLESTR a2,
                                                       UINT a3)
{
    _PrintEnter("OleMetafilePictFromIconAndLabel(%p,%p,%p,%p)\n", a0, a1, a2, a3);

    HGLOBAL rv = 0;
    __try {
        rv = Real_OleMetafilePictFromIconAndLabel(a0, a1, a2, a3);
    } __finally {
        _PrintExit("OleMetafilePictFromIconAndLabel(,,,) -> %p\n", rv);
    };
    return rv;
}

HRESULT __stdcall Mine_OleNoteObjectVisible(LPUNKNOWN a0,
                                            BOOL a1)
{
    _PrintEnter("OleNoteObjectVisible(%p,%p)\n", a0, a1);

    HRESULT rv = 0;
    __try {
        rv = Real_OleNoteObjectVisible(a0, a1);
    } __finally {
        _PrintExit("OleNoteObjectVisible(,) -> %p\n", rv);
    };
    return rv;
}

HRESULT __stdcall Mine_OleQueryCreateFromData(IDataObject* a0)
{
    _PrintEnter("OleQueryCreateFromData(%p)\n", a0);

    HRESULT rv = 0;
    __try {
        rv = Real_OleQueryCreateFromData(a0);
    } __finally {
        _PrintExit("OleQueryCreateFromData() -> %p\n", rv);
    };
    return rv;
}

HRESULT __stdcall Mine_OleQueryLinkFromData(IDataObject* a0)
{
    _PrintEnter("OleQueryLinkFromData(%p)\n", a0);

    HRESULT rv = 0;
    __try {
        rv = Real_OleQueryLinkFromData(a0);
    } __finally {
        _PrintExit("OleQueryLinkFromData() -> %p\n", rv);
    };
    return rv;
}

HRESULT __stdcall Mine_OleRegEnumFormatEtc(CONST IID& a0,
                                           DWORD a1,
                                           IEnumFORMATETC** a2)
{
    _PrintEnter("OleRegEnumFormatEtc(%p,%p,%p)\n", a0, a1, a2);

    HRESULT rv = 0;
    __try {
        rv = Real_OleRegEnumFormatEtc(a0, a1, a2);
    } __finally {
        _PrintExit("OleRegEnumFormatEtc(,,) -> %p\n", rv);
    };
    return rv;
}

HRESULT __stdcall Mine_OleRegEnumVerbs(CONST IID& a0,
                                       IEnumOLEVERB** a1)
{
    _PrintEnter("OleRegEnumVerbs(%p,%p)\n", a0, a1);

    HRESULT rv = 0;
    __try {
        rv = Real_OleRegEnumVerbs(a0, a1);
    } __finally {
        _PrintExit("OleRegEnumVerbs(,) -> %p\n", rv);
    };
    return rv;
}

HRESULT __stdcall Mine_OleRegGetMiscStatus(CONST IID& a0,
                                           DWORD a1,
                                           DWORD* a2)
{
    _PrintEnter("OleRegGetMiscStatus(%p,%p,%p)\n", a0, a1, a2);

    HRESULT rv = 0;
    __try {
        rv = Real_OleRegGetMiscStatus(a0, a1, a2);
    } __finally {
        _PrintExit("OleRegGetMiscStatus(,,) -> %p\n", rv);
    };
    return rv;
}

HRESULT __stdcall Mine_OleRegGetUserType(CONST IID& a0,
                                         DWORD a1,
                                         LPOLESTR* a2)
{
    _PrintEnter("OleRegGetUserType(%p,%p,%p)\n", a0, a1, a2);

    HRESULT rv = 0;
    __try {
        rv = Real_OleRegGetUserType(a0, a1, a2);
    } __finally {
        _PrintExit("OleRegGetUserType(,,) -> %p\n", rv);
    };
    return rv;
}

HRESULT __stdcall Mine_OleRun(LPUNKNOWN a0)
{
    _PrintEnter("OleRun(%p)\n", a0);

    HRESULT rv = 0;
    __try {
        rv = Real_OleRun(a0);
    } __finally {
        _PrintExit("OleRun() -> %p\n", rv);
    };
    return rv;
}

HRESULT __stdcall Mine_OleSave(LPPERSISTSTORAGE a0,
                               LPSTORAGE a1,
                               BOOL a2)
{
    _PrintEnter("OleSave(%p,%p,%p)\n", a0, a1, a2);

    HRESULT rv = 0;
    __try {
        rv = Real_OleSave(a0, a1, a2);
    } __finally {
        _PrintExit("OleSave(,,) -> %p\n", rv);
    };
    return rv;
}

HRESULT __stdcall Mine_OleSaveToStream(IPersistStream* a0,
                                       LPSTREAM a1)
{
    _PrintEnter("OleSaveToStream(%p,%p)\n", a0, a1);

    HRESULT rv = 0;
    __try {
        rv = Real_OleSaveToStream(a0, a1);
    } __finally {
        _PrintExit("OleSaveToStream(,) -> %p\n", rv);
    };
    return rv;
}

HRESULT __stdcall Mine_OleSetAutoConvert(CONST IID& a0,
                                         CONST IID& a1)
{
    _PrintEnter("OleSetAutoConvert(%p,%p)\n", a0, a1);

    HRESULT rv = 0;
    __try {
        rv = Real_OleSetAutoConvert(a0, a1);
    } __finally {
        _PrintExit("OleSetAutoConvert(,) -> %p\n", rv);
    };
    return rv;
}

HRESULT __stdcall Mine_OleSetClipboard(IDataObject* a0)
{
    _PrintEnter("OleSetClipboard(%p)\n", a0);

    HRESULT rv = 0;
    __try {
        rv = Real_OleSetClipboard(a0);
    } __finally {
        _PrintExit("OleSetClipboard() -> %p\n", rv);
    };
    return rv;
}

HRESULT __stdcall Mine_OleSetContainedObject(LPUNKNOWN a0,
                                             BOOL a1)
{
    _PrintEnter("OleSetContainedObject(%p,%p)\n", a0, a1);

    HRESULT rv = 0;
    __try {
        rv = Real_OleSetContainedObject(a0, a1);
    } __finally {
        _PrintExit("OleSetContainedObject(,) -> %p\n", rv);
    };
    return rv;
}

HRESULT __stdcall Mine_OleSetMenuDescriptor(HOLEMENU a0,
                                            HWND a1,
                                            HWND a2,
                                            LPOLEINPLACEFRAME a3,
                                            LPOLEINPLACEACTIVEOBJECT a4)
{
    _PrintEnter("OleSetMenuDescriptor(%p,%p,%p,%p,%p)\n", a0, a1, a2, a3, a4);

    HRESULT rv = 0;
    __try {
        rv = Real_OleSetMenuDescriptor(a0, a1, a2, a3, a4);
    } __finally {
        _PrintExit("OleSetMenuDescriptor(,,,,) -> %p\n", rv);
    };
    return rv;
}

HRESULT __stdcall Mine_OleTranslateAccelerator(LPOLEINPLACEFRAME a0,
                                               LPOLEINPLACEFRAMEINFO a1,
                                               LPMSG a2)
{
    _PrintEnter("OleTranslateAccelerator(%p,%p,%p)\n", a0, a1, a2);

    HRESULT rv = 0;
    __try {
        rv = Real_OleTranslateAccelerator(a0, a1, a2);
    } __finally {
        _PrintExit("OleTranslateAccelerator(,,) -> %p\n", rv);
    };
    return rv;
}

void __stdcall Mine_OleUninitialize(void)
{
    _PrintEnter("OleUninitialize()\n");

    __try {
        Real_OleUninitialize();
    } __finally {
        _PrintExit("OleUninitialize() ->\n");
    };
}

BOOL __stdcall Mine_OpenClipboard(HWND a0)
{
    _PrintEnter("OpenClipboard(%p)\n", a0);

    BOOL rv = 0;
    __try {
        rv = Real_OpenClipboard(a0);
    } __finally {
        _PrintExit("OpenClipboard() -> %p\n", rv);
    };
    return rv;
}

#if _MSC_VER < 1300
HDESK __stdcall Mine_OpenDesktopA(LPSTR a0,
                                  DWORD a1,
                                  BOOL a2,
                                  ACCESS_MASK a3)
#else
HDESK __stdcall Mine_OpenDesktopA(LPCSTR a0,
                                  DWORD a1,
                                  BOOL a2,
                                  ACCESS_MASK a3)
#endif
{
    _PrintEnter("OpenDesktopA(%hs,%p,%p,%p)\n", a0, a1, a2, a3);

    HDESK rv = 0;
    __try {
        rv = Real_OpenDesktopA(a0, a1, a2, a3);
    } __finally {
        _PrintExit("OpenDesktopA(,,,) -> %p\n", rv);
    };
    return rv;
}

#if _MSC_VER < 1300
HDESK __stdcall Mine_OpenDesktopW(LPWSTR a0,
                                  DWORD a1,
                                  BOOL a2,
                                  ACCESS_MASK a3)
#else
HDESK __stdcall Mine_OpenDesktopW(LPCWSTR a0,
                                  DWORD a1,
                                  BOOL a2,
                                  ACCESS_MASK a3)
#endif
{
    _PrintEnter("OpenDesktopW(%ls,%p,%p,%p)\n", a0, a1, a2, a3);

    HDESK rv = 0;
    __try {
        rv = Real_OpenDesktopW(a0, a1, a2, a3);
    } __finally {
        _PrintExit("OpenDesktopW(,,,) -> %p\n", rv);
    };
    return rv;
}

HANDLE __stdcall Mine_OpenEventA(DWORD a0,
                                 BOOL a1,
                                 LPCSTR a2)
{
    _PrintEnter("OpenEventA(%p,%p,%hs)\n", a0, a1, a2);

    HANDLE rv = 0;
    __try {
        rv = Real_OpenEventA(a0, a1, a2);
    } __finally {
        _PrintExit("OpenEventA(,,) -> %p\n", rv);
    };
    return rv;
}

HANDLE __stdcall Mine_OpenEventW(DWORD a0,
                                 BOOL a1,
                                 LPCWSTR a2)
{
    _PrintEnter("OpenEventW(%p,%p,%ls)\n", a0, a1, a2);

    HANDLE rv = 0;
    __try {
        rv = Real_OpenEventW(a0, a1, a2);
    } __finally {
        _PrintExit("OpenEventW(,,) -> %p\n", rv);
    };
    return rv;
}

HFILE __stdcall Mine_OpenFile(LPCSTR a0,
                              LPOFSTRUCT a1,
                              UINT a2)
{
    _PrintEnter("OpenFile(%hs,%p,%p)\n", a0, a1, a2);

    HFILE rv = 0;
    __try {
        rv = Real_OpenFile(a0, a1, a2);
    } __finally {
        _PrintExit("OpenFile(,,) -> %p\n", rv);
    };
    return rv;
}

HANDLE __stdcall Mine_OpenFileMappingA(DWORD a0,
                                       BOOL a1,
                                       LPCSTR a2)
{
    _PrintEnter("OpenFileMappingA(%p,%p,%hs)\n", a0, a1, a2);

    HANDLE rv = 0;
    __try {
        rv = Real_OpenFileMappingA(a0, a1, a2);
    } __finally {
        _PrintExit("OpenFileMappingA(,,) -> %p\n", rv);
    };
    return rv;
}

HANDLE __stdcall Mine_OpenFileMappingW(DWORD a0,
                                       BOOL a1,
                                       LPCWSTR a2)
{
    _PrintEnter("OpenFileMappingW(%p,%p,%ls)\n", a0, a1, a2);

    HANDLE rv = 0;
    __try {
        rv = Real_OpenFileMappingW(a0, a1, a2);
    } __finally {
        _PrintExit("OpenFileMappingW(,,) -> %p\n", rv);
    };
    return rv;
}

BOOL __stdcall Mine_OpenIcon(HWND a0)
{
    _PrintEnter("OpenIcon(%p)\n", a0);

    BOOL rv = 0;
    __try {
        rv = Real_OpenIcon(a0);
    } __finally {
        _PrintExit("OpenIcon() -> %p\n", rv);
    };
    return rv;
}

HDESK __stdcall Mine_OpenInputDesktop(DWORD a0,
                                      BOOL a1,
                                      ACCESS_MASK a2)
{
    _PrintEnter("OpenInputDesktop(%p,%p,%p)\n", a0, a1, a2);

    HDESK rv = 0;
    __try {
        rv = Real_OpenInputDesktop(a0, a1, a2);
    } __finally {
        _PrintExit("OpenInputDesktop(,,) -> %p\n", rv);
    };
    return rv;
}

HANDLE __stdcall Mine_OpenMutexA(DWORD a0,
                                 BOOL a1,
                                 LPCSTR a2)
{
    _PrintEnter("OpenMutexA(%p,%p,%hs)\n", a0, a1, a2);

    HANDLE rv = 0;
    __try {
        rv = Real_OpenMutexA(a0, a1, a2);
    } __finally {
        _PrintExit("OpenMutexA(,,) -> %p\n", rv);
    };
    return rv;
}

HANDLE __stdcall Mine_OpenMutexW(DWORD a0,
                                 BOOL a1,
                                 LPCWSTR a2)
{
    _PrintEnter("OpenMutexW(%p,%p,%ls)\n", a0, a1, a2);

    HANDLE rv = 0;
    __try {
        rv = Real_OpenMutexW(a0, a1, a2);
    } __finally {
        _PrintExit("OpenMutexW(,,) -> %p\n", rv);
    };
    return rv;
}

HANDLE __stdcall Mine_OpenProcess(DWORD a0,
                                  BOOL a1,
                                  DWORD pid)
{
    _PrintEnter("OpenProcess(%p,%p,pid=%d)\n", a0, a1, pid);

    HANDLE rv = 0;
    __try {
        rv = Real_OpenProcess(a0, a1, pid);
    } __finally {
        _PrintExit("OpenProcess(,,) -> %p\n", rv);
    };
    return rv;
}

BOOL __stdcall Mine_OpenProcessToken(__in   HANDLE ProcessHandle,
                                     __in   DWORD DesiredAccess,
                                     __out  PHANDLE TokenHandle
                                    )
{
    _PrintEnter("OpenProcessToken(%p,%p,%p)\n",
                ProcessHandle,
                DesiredAccess,
                TokenHandle);

    BOOL rv = 0;
    __try {
        rv = Real_OpenProcessToken(ProcessHandle,
                                   DesiredAccess,
                                   TokenHandle);

    } __finally {
        _PrintExit("OpenProcessToken(,,%p) -> %p\n",
                   TokenHandle != NULL ? *TokenHandle : 0,
                   rv);
    };
    return rv;
}

HANDLE __stdcall Mine_OpenSemaphoreA(DWORD a0,
                                     BOOL a1,
                                     LPCSTR a2)
{
    _PrintEnter("OpenSemaphoreA(%p,%p,%hs)\n", a0, a1, a2);

    HANDLE rv = 0;
    __try {
        rv = Real_OpenSemaphoreA(a0, a1, a2);
    } __finally {
        _PrintExit("OpenSemaphoreA(,,) -> %p\n", rv);
    };
    return rv;
}

HANDLE __stdcall Mine_OpenSemaphoreW(DWORD a0,
                                     BOOL a1,
                                     LPCWSTR a2)
{
    _PrintEnter("OpenSemaphoreW(%p,%p,%ls)\n", a0, a1, a2);

    HANDLE rv = 0;
    __try {
        rv = Real_OpenSemaphoreW(a0, a1, a2);
    } __finally {
        _PrintExit("OpenSemaphoreW(,,) -> %p\n", rv);
    };
    return rv;
}

HANDLE __stdcall Mine_OpenWaitableTimerA(DWORD a0,
                                         BOOL a1,
                                         LPCSTR a2)
{
    _PrintEnter("OpenWaitableTimerA(%p,%p,%hs)\n", a0, a1, a2);

    HANDLE rv = 0;
    __try {
        rv = Real_OpenWaitableTimerA(a0, a1, a2);
    } __finally {
        _PrintExit("OpenWaitableTimerA(,,) -> %p\n", rv);
    };
    return rv;
}

HANDLE __stdcall Mine_OpenWaitableTimerW(DWORD a0,
                                         BOOL a1,
                                         LPCWSTR a2)
{
    _PrintEnter("OpenWaitableTimerW(%p,%p,%ls)\n", a0, a1, a2);

    HANDLE rv = 0;
    __try {
        rv = Real_OpenWaitableTimerW(a0, a1, a2);
    } __finally {
        _PrintExit("OpenWaitableTimerW(,,) -> %p\n", rv);
    };
    return rv;
}

#if _MSC_VER < 1300
HWINSTA __stdcall Mine_OpenWindowStationA(LPSTR a0,
                                          BOOL a1,
                                          ACCESS_MASK a2)
#else
HWINSTA __stdcall Mine_OpenWindowStationA(LPCSTR a0,
                                          BOOL a1,
                                          ACCESS_MASK a2)
#endif
{
    _PrintEnter("OpenWindowStationA(%hs,%p,%p)\n", a0, a1, a2);

    HWINSTA rv = 0;
    __try {
        rv = Real_OpenWindowStationA(a0, a1, a2);
    } __finally {
        _PrintExit("OpenWindowStationA(,,) -> %p\n", rv);
    };
    return rv;
}

#if _MSC_VER < 1300
HWINSTA __stdcall Mine_OpenWindowStationW(LPWSTR a0,
                                          BOOL a1,
                                          ACCESS_MASK a2)
#else
HWINSTA __stdcall Mine_OpenWindowStationW(LPCWSTR a0,
                                          BOOL a1,
                                          ACCESS_MASK a2)
#endif
{
    _PrintEnter("OpenWindowStationW(%ls,%p,%p)\n", a0, a1, a2);

    HWINSTA rv = 0;
    __try {
        rv = Real_OpenWindowStationW(a0, a1, a2);
    } __finally {
        _PrintExit("OpenWindowStationW(,,) -> %p\n", rv);
    };
    return rv;
}

void __stdcall Mine_OutputDebugStringA(LPCSTR a0)
{
    _PrintEnter("OutputDebugStringA(%hs)\n", a0);

    __try {
        Real_OutputDebugStringA(a0);
    } __finally {
        _PrintExit("OutputDebugStringA() ->\n");
    };
}

void __stdcall Mine_OutputDebugStringW(LPCWSTR a0)
{
    _PrintEnter("OutputDebugStringW(%ls)\n", a0);

    __try {
        Real_OutputDebugStringW(a0);
    } __finally {
        _PrintExit("OutputDebugStringW() ->\n");
    };
}

LPARAM __stdcall Mine_PackDDElParam(UINT a0,
                                    UINT_PTR a1,
                                    UINT_PTR a2)
{
    _PrintEnter("PackDDElParam(%p,%p,%p)\n", a0, a1, a2);

    LPARAM rv = 0;
    __try {
        rv = Real_PackDDElParam(a0, a1, a2);
    } __finally {
        _PrintExit("PackDDElParam(,,) -> %p\n", rv);
    };
    return rv;
}

BOOL __stdcall Mine_PaintDesktop(HDC a0)
{
    _PrintEnter("PaintDesktop(%p)\n", a0);

    BOOL rv = 0;
    __try {
        rv = Real_PaintDesktop(a0);
    } __finally {
        _PrintExit("PaintDesktop() -> %p\n", rv);
    };
    return rv;
}

BOOL __stdcall Mine_PaintRgn(HDC a0,
                             HRGN a1)
{
    _PrintEnter("PaintRgn(%p,%p)\n", a0, a1);

    BOOL rv = 0;
    __try {
        rv = Real_PaintRgn(a0, a1);
    } __finally {
        _PrintExit("PaintRgn(,) -> %p\n", rv);
    };
    return rv;
}

BOOL __stdcall Mine_PatBlt(HDC a0,
                           int a1,
                           int a2,
                           int a3,
                           int a4,
                           DWORD a5)
{
    _PrintEnter("PatBlt(%p,%p,%p,%p,%p,%p)\n", a0, a1, a2, a3, a4, a5);

    BOOL rv = 0;
    __try {
        rv = Real_PatBlt(a0, a1, a2, a3, a4, a5);
    } __finally {
        _PrintExit("PatBlt(,,,,,) -> %p\n", rv);
    };
    return rv;
}

HRGN __stdcall Mine_PathToRegion(HDC a0)
{
    _PrintEnter("PathToRegion(%p)\n", a0);

    HRGN rv = 0;
    __try {
        rv = Real_PathToRegion(a0);
    } __finally {
        _PrintExit("PathToRegion() -> %p\n", rv);
    };
    return rv;
}

BOOL __stdcall Mine_PeekConsoleInputA(HANDLE a0,
                                      PINPUT_RECORD a1,
                                      DWORD a2,
                                      LPDWORD a3)
{
    _PrintEnter("PeekConsoleInputA(%p,%p,%p,%p)\n", a0, a1, a2, a3);

    BOOL rv = 0;
    __try {
        rv = Real_PeekConsoleInputA(a0, a1, a2, a3);
    } __finally {
        _PrintExit("PeekConsoleInputA(,,,) -> %p\n", rv);
    };
    return rv;
}

BOOL __stdcall Mine_PeekConsoleInputW(HANDLE a0,
                                      PINPUT_RECORD a1,
                                      DWORD a2,
                                      LPDWORD a3)
{
    _PrintEnter("PeekConsoleInputW(%p,%p,%p,%p)\n", a0, a1, a2, a3);

    BOOL rv = 0;
    __try {
        rv = Real_PeekConsoleInputW(a0, a1, a2, a3);
    } __finally {
        _PrintExit("PeekConsoleInputW(,,,) -> %p\n", rv);
    };
    return rv;
}

BOOL __stdcall Mine_PeekMessageA(LPMSG a0,
                                 HWND a1,
                                 UINT a2,
                                 UINT a3,
                                 UINT a4)
{
    _PrintEnter("PeekMessageA(%p,%p,%p,%p,%p)\n", a0, a1, a2, a3, a4);

    BOOL rv = 0;
    __try {
        rv = Real_PeekMessageA(a0, a1, a2, a3, a4);
    } __finally {
        _PrintExit("PeekMessageA(,,,,) -> %p\n", rv);
    };
    return rv;
}

BOOL __stdcall Mine_PeekMessageW(LPMSG a0,
                                 HWND a1,
                                 UINT a2,
                                 UINT a3,
                                 UINT a4)
{
    _PrintEnter("PeekMessageW(%p,%p,%p,%p,%p)\n", a0, a1, a2, a3, a4);

    BOOL rv = 0;
    __try {
        rv = Real_PeekMessageW(a0, a1, a2, a3, a4);
    } __finally {
        _PrintExit("PeekMessageW(,,,,) -> %p\n", rv);
    };
    return rv;
}

BOOL __stdcall Mine_PeekNamedPipe(HANDLE a0,
                                  LPVOID a1,
                                  DWORD a2,
                                  LPDWORD a3,
                                  LPDWORD a4,
                                  LPDWORD a5)
{
    _PrintEnter("PeekNamedPipe(%p,%p,%p,%p,%p,%p)\n", a0, a1, a2, a3, a4, a5);

    BOOL rv = 0;
    __try {
        rv = Real_PeekNamedPipe(a0, a1, a2, a3, a4, a5);
    } __finally {
        _PrintExit("PeekNamedPipe(,,,,,) -> %p\n", rv);
    };
    return rv;
}

BOOL __stdcall Mine_Pie(HDC a0,
                        int a1,
                        int a2,
                        int a3,
                        int a4,
                        int a5,
                        int a6,
                        int a7,
                        int a8)
{
    _PrintEnter("Pie(%p,%p,%p,%p,%p,%p,%p,%p,%p)\n", a0, a1, a2, a3, a4, a5, a6, a7, a8);

    BOOL rv = 0;
    __try {
        rv = Real_Pie(a0, a1, a2, a3, a4, a5, a6, a7, a8);
    } __finally {
        _PrintExit("Pie(,,,,,,,,) -> %p\n", rv);
    };
    return rv;
}

BOOL __stdcall Mine_PlayEnhMetaFile(HDC a0,
                                    HENHMETAFILE a1,
                                    RECT* a2)
{
    _PrintEnter("PlayEnhMetaFile(%p,%p,%p)\n", a0, a1, a2);

    BOOL rv = 0;
    __try {
        rv = Real_PlayEnhMetaFile(a0, a1, a2);
    } __finally {
        _PrintExit("PlayEnhMetaFile(,,) -> %p\n", rv);
    };
    return rv;
}

BOOL __stdcall Mine_PlayEnhMetaFileRecord(HDC a0,
                                          LPHANDLETABLE a1,
                                          ENHMETARECORD* a2,
                                          UINT a3)
{
    _PrintEnter("PlayEnhMetaFileRecord(%p,%p,%p,%p)\n", a0, a1, a2, a3);

    BOOL rv = 0;
    __try {
        rv = Real_PlayEnhMetaFileRecord(a0, a1, a2, a3);
    } __finally {
        _PrintExit("PlayEnhMetaFileRecord(,,,) -> %p\n", rv);
    };
    return rv;
}

BOOL __stdcall Mine_PlayMetaFile(HDC a0,
                                 HMETAFILE a1)
{
    _PrintEnter("PlayMetaFile(%p,%p)\n", a0, a1);

    BOOL rv = 0;
    __try {
        rv = Real_PlayMetaFile(a0, a1);
    } __finally {
        _PrintExit("PlayMetaFile(,) -> %p\n", rv);
    };
    return rv;
}

BOOL __stdcall Mine_PlayMetaFileRecord(HDC a0,
                                       LPHANDLETABLE a1,
                                       LPMETARECORD a2,
                                       UINT a3)
{
    _PrintEnter("PlayMetaFileRecord(%p,%p,%p,%p)\n", a0, a1, a2, a3);

    BOOL rv = 0;
    __try {
        rv = Real_PlayMetaFileRecord(a0, a1, a2, a3);
    } __finally {
        _PrintExit("PlayMetaFileRecord(,,,) -> %p\n", rv);
    };
    return rv;
}

BOOL __stdcall Mine_PlgBlt(HDC a0,
                           POINT* a1,
                           HDC a2,
                           int a3,
                           int a4,
                           int a5,
                           int a6,
                           HBITMAP a7,
                           int a8,
                           int a9)
{
    _PrintEnter("PlgBlt(%p,%p,%p,%p,%p,%p,%p,%p,%p,%p)\n", a0, a1, a2, a3, a4, a5, a6, a7, a8, a9);

    BOOL rv = 0;
    __try {
        rv = Real_PlgBlt(a0, a1, a2, a3, a4, a5, a6, a7, a8, a9);
    } __finally {
        _PrintExit("PlgBlt(,,,,,,,,,) -> %p\n", rv);
    };
    return rv;
}

BOOL __stdcall Mine_PolyBezier(HDC a0,
                               POINT* a1,
                               DWORD a2)
{
    _PrintEnter("PolyBezier(%p,%p,%p)\n", a0, a1, a2);

    BOOL rv = 0;
    __try {
        rv = Real_PolyBezier(a0, a1, a2);
    } __finally {
        _PrintExit("PolyBezier(,,) -> %p\n", rv);
    };
    return rv;
}

BOOL __stdcall Mine_PolyBezierTo(HDC a0,
                                 POINT* a1,
                                 DWORD a2)
{
    _PrintEnter("PolyBezierTo(%p,%p,%p)\n", a0, a1, a2);

    BOOL rv = 0;
    __try {
        rv = Real_PolyBezierTo(a0, a1, a2);
    } __finally {
        _PrintExit("PolyBezierTo(,,) -> %p\n", rv);
    };
    return rv;
}

BOOL __stdcall Mine_PolyDraw(HDC a0,
                             POINT* a1,
                             BYTE* a2,
                             int a3)
{
    _PrintEnter("PolyDraw(%p,%p,%p,%p)\n", a0, a1, a2, a3);

    BOOL rv = 0;
    __try {
        rv = Real_PolyDraw(a0, a1, a2, a3);
    } __finally {
        _PrintExit("PolyDraw(,,,) -> %p\n", rv);
    };
    return rv;
}

BOOL __stdcall Mine_PolyPolygon(HDC a0,
                                POINT* a1,
                                INT* a2,
                                int a3)
{
    _PrintEnter("PolyPolygon(%p,%p,%p,%p)\n", a0, a1, a2, a3);

    BOOL rv = 0;
    __try {
        rv = Real_PolyPolygon(a0, a1, a2, a3);
    } __finally {
        _PrintExit("PolyPolygon(,,,) -> %p\n", rv);
    };
    return rv;
}

BOOL __stdcall Mine_PolyPolyline(HDC a0,
                                 POINT* a1,
                                 DWORD* a2,
                                 DWORD a3)
{
    _PrintEnter("PolyPolyline(%p,%p,%p,%p)\n", a0, a1, a2, a3);

    BOOL rv = 0;
    __try {
        rv = Real_PolyPolyline(a0, a1, a2, a3);
    } __finally {
        _PrintExit("PolyPolyline(,,,) -> %p\n", rv);
    };
    return rv;
}

BOOL __stdcall Mine_PolyTextOutA(HDC a0,
                                 POLYTEXTA* a1,
                                 int a2)
{
    _PrintEnter("PolyTextOutA(%p,%p,%p)\n", a0, a1, a2);

    BOOL rv = 0;
    __try {
        rv = Real_PolyTextOutA(a0, a1, a2);
    } __finally {
        _PrintExit("PolyTextOutA(,,) -> %p\n", rv);
    };
    return rv;
}

BOOL __stdcall Mine_PolyTextOutW(HDC a0,
                                 POLYTEXTW* a1,
                                 int a2)
{
    _PrintEnter("PolyTextOutW(%p,%p,%p)\n", a0, a1, a2);

    BOOL rv = 0;
    __try {
        rv = Real_PolyTextOutW(a0, a1, a2);
    } __finally {
        _PrintExit("PolyTextOutW(,,) -> %p\n", rv);
    };
    return rv;
}

BOOL __stdcall Mine_Polygon(HDC a0,
                            POINT* a1,
                            int a2)
{
    _PrintEnter("Polygon(%p,%p,%p)\n", a0, a1, a2);

    BOOL rv = 0;
    __try {
        rv = Real_Polygon(a0, a1, a2);
    } __finally {
        _PrintExit("Polygon(,,) -> %p\n", rv);
    };
    return rv;
}

BOOL __stdcall Mine_Polyline(HDC a0,
                             POINT* a1,
                             int a2)
{
    _PrintEnter("Polyline(%p,%p,%p)\n", a0, a1, a2);

    BOOL rv = 0;
    __try {
        rv = Real_Polyline(a0, a1, a2);
    } __finally {
        _PrintExit("Polyline(,,) -> %p\n", rv);
    };
    return rv;
}

BOOL __stdcall Mine_PolylineTo(HDC a0,
                               POINT* a1,
                               DWORD a2)
{
    _PrintEnter("PolylineTo(%p,%p,%p)\n", a0, a1, a2);

    BOOL rv = 0;
    __try {
        rv = Real_PolylineTo(a0, a1, a2);
    } __finally {
        _PrintExit("PolylineTo(,,) -> %p\n", rv);
    };
    return rv;
}

BOOL __stdcall Mine_PostMessageA(HWND a0,
                                 UINT a1,
                                 WPARAM a2,
                                 LPARAM a3)
{
    _PrintEnter("PostMessageA(%p,%p,%p,%p)\n", a0, a1, a2, a3);

    BOOL rv = 0;
    __try {
        rv = Real_PostMessageA(a0, a1, a2, a3);
    } __finally {
        _PrintExit("PostMessageA(,,,) -> %p\n", rv);
    };
    return rv;
}

BOOL __stdcall Mine_PostMessageW(HWND a0,
                                 UINT a1,
                                 WPARAM a2,
                                 LPARAM a3)
{
    _PrintEnter("PostMessageW(%p,%p,%p,%p)\n", a0, a1, a2, a3);

    BOOL rv = 0;
    __try {
        rv = Real_PostMessageW(a0, a1, a2, a3);
    } __finally {
        _PrintExit("PostMessageW(,,,) -> %p\n", rv);
    };
    return rv;
}

BOOL __stdcall Mine_PostQueuedCompletionStatus(HANDLE a0,
                                               DWORD a1,
                                               ULONG_PTR a2,
                                               LPOVERLAPPED a3)
{
    _PrintEnter("PostQueuedCompletionStatus(%p,%p,%p,%p)\n", a0, a1, a2, a3);

    BOOL rv = 0;
    __try {
        rv = Real_PostQueuedCompletionStatus(a0, a1, a2, a3);
    } __finally {
        _PrintExit("PostQueuedCompletionStatus(,,,) -> %p\n", rv);
    };
    return rv;
}

void __stdcall Mine_PostQuitMessage(int a0)
{
    _PrintEnter("PostQuitMessage(%p)\n", a0);

    __try {
        Real_PostQuitMessage(a0);
    } __finally {
        _PrintExit("PostQuitMessage() ->\n");
    };
}

BOOL __stdcall Mine_PostThreadMessageA(DWORD a0,
                                       UINT a1,
                                       WPARAM a2,
                                       LPARAM a3)
{
    _PrintEnter("PostThreadMessageA(%p,%p,%p,%p)\n", a0, a1, a2, a3);

    BOOL rv = 0;
    __try {
        rv = Real_PostThreadMessageA(a0, a1, a2, a3);
    } __finally {
        _PrintExit("PostThreadMessageA(,,,) -> %p\n", rv);
    };
    return rv;
}

BOOL __stdcall Mine_PostThreadMessageW(DWORD a0,
                                       UINT a1,
                                       WPARAM a2,
                                       LPARAM a3)
{
    _PrintEnter("PostThreadMessageW(%p,%p,%p,%p)\n", a0, a1, a2, a3);

    BOOL rv = 0;
    __try {
        rv = Real_PostThreadMessageW(a0, a1, a2, a3);
    } __finally {
        _PrintExit("PostThreadMessageW(,,,) -> %p\n", rv);
    };
    return rv;
}

DWORD __stdcall Mine_PrepareTape(HANDLE a0,
                                 DWORD a1,
                                 BOOL a2)
{
    _PrintEnter("PrepareTape(%p,%p,%p)\n", a0, a1, a2);

    DWORD rv = 0;
    __try {
        rv = Real_PrepareTape(a0, a1, a2);
    } __finally {
        _PrintExit("PrepareTape(,,) -> %p\n", rv);
    };
    return rv;
}

HRESULT __stdcall Mine_ProgIDFromCLSID(CONST IID& a0,
                                       LPOLESTR* a1)
{
    _PrintEnter("ProgIDFromCLSID(%p,%p)\n", a0, a1);

    HRESULT rv = 0;
    __try {
        rv = Real_ProgIDFromCLSID(a0, a1);
    } __finally {
        _PrintExit("ProgIDFromCLSID(,) -> %p\n", rv);
    };
    return rv;
}

HRESULT __stdcall Mine_PropVariantClear(PROPVARIANT* a0)
{
    _PrintEnter("PropVariantClear(%p)\n", a0);

    HRESULT rv = 0;
    __try {
        rv = Real_PropVariantClear(a0);
    } __finally {
        _PrintExit("PropVariantClear() -> %p\n", rv);
    };
    return rv;
}

HRESULT __stdcall Mine_PropVariantCopy(PROPVARIANT* a0,
                                       PROPVARIANT* a1)
{
    _PrintEnter("PropVariantCopy(%p,%p)\n", a0, a1);

    HRESULT rv = 0;
    __try {
        rv = Real_PropVariantCopy(a0, a1);
    } __finally {
        _PrintExit("PropVariantCopy(,) -> %p\n", rv);
    };
    return rv;
}

BOOL __stdcall Mine_PtInRect(RECT* a0,
                             POINT a1)
{
    _PrintEnter("PtInRect(%p,%p)\n", a0, a1);

    BOOL rv = 0;
    __try {
        rv = Real_PtInRect(a0, a1);
    } __finally {
        _PrintExit("PtInRect(,) -> %p\n", rv);
    };
    return rv;
}

BOOL __stdcall Mine_PtInRegion(HRGN a0,
                               int a1,
                               int a2)
{
    _PrintEnter("PtInRegion(%p,%p,%p)\n", a0, a1, a2);

    BOOL rv = 0;
    __try {
        rv = Real_PtInRegion(a0, a1, a2);
    } __finally {
        _PrintExit("PtInRegion(,,) -> %p\n", rv);
    };
    return rv;
}

BOOL __stdcall Mine_PtVisible(HDC a0,
                              int a1,
                              int a2)
{
    _PrintEnter("PtVisible(%p,%p,%p)\n", a0, a1, a2);

    BOOL rv = 0;
    __try {
        rv = Real_PtVisible(a0, a1, a2);
    } __finally {
        _PrintExit("PtVisible(,,) -> %p\n", rv);
    };
    return rv;
}

BOOL __stdcall Mine_PulseEvent(HANDLE a0)
{
    _PrintEnter("PulseEvent(%p)\n", a0);

    BOOL rv = 0;
    __try {
        rv = Real_PulseEvent(a0);
    } __finally {
        _PrintExit("PulseEvent() -> %p\n", rv);
    };
    return rv;
}

BOOL __stdcall Mine_PurgeComm(HANDLE a0,
                              DWORD a1)
{
    _PrintEnter("PurgeComm(%p,%p)\n", a0, a1);

    BOOL rv = 0;
    __try {
        rv = Real_PurgeComm(a0, a1);
    } __finally {
        _PrintExit("PurgeComm(,) -> %p\n", rv);
    };
    return rv;
}

DWORD __stdcall Mine_QueryDosDeviceA(LPCSTR a0,
                                     LPSTR a1,
                                     DWORD a2)
{
    _PrintEnter("QueryDosDeviceA(%hs,%p,%p)\n", a0, a1, a2);

    DWORD rv = 0;
    __try {
        rv = Real_QueryDosDeviceA(a0, a1, a2);
    } __finally {
        _PrintExit("QueryDosDeviceA(,%hs,) -> %p\n", a1, rv);
    };
    return rv;
}

DWORD __stdcall Mine_QueryDosDeviceW(LPCWSTR a0,
                                     LPWSTR a1,
                                     DWORD a2)
{
    _PrintEnter("QueryDosDeviceW(%ls,%p,%p)\n", a0, a1, a2);

    DWORD rv = 0;
    __try {
        rv = Real_QueryDosDeviceW(a0, a1, a2);
    } __finally {
        _PrintExit("QueryDosDeviceW(,%ls,) -> %p\n", a1, rv);
    };
    return rv;
}

BOOL __stdcall Mine_QueryPerformanceCounter(LARGE_INTEGER* a0)
{
    _PrintEnter("QueryPerformanceCounter(%p)\n", a0);

    BOOL rv = 0;
    __try {
        rv = Real_QueryPerformanceCounter(a0);
    } __finally {
        _PrintExit("QueryPerformanceCounter() -> %p\n", rv);
    };
    return rv;
}

BOOL __stdcall Mine_QueryPerformanceFrequency(LARGE_INTEGER* a0)
{
    _PrintEnter("QueryPerformanceFrequency(%p)\n", a0);

    BOOL rv = 0;
    __try {
        rv = Real_QueryPerformanceFrequency(a0);
    } __finally {
        _PrintExit("QueryPerformanceFrequency() -> %p\n", rv);
    };
    return rv;
}

DWORD __stdcall Mine_QueueUserAPC(PAPCFUNC a0,
                                  HANDLE a1,
                                  ULONG_PTR a2)
{
    _PrintEnter("QueueUserAPC(%p,%p,%p)\n", a0, a1, a2);

    DWORD rv = 0;
    __try {
        rv = Real_QueueUserAPC(a0, a1, a2);
    } __finally {
        _PrintExit("QueueUserAPC(,,) -> %p\n", rv);
    };
    return rv;
}

void __stdcall Mine_RaiseException(DWORD a0,
                                   DWORD a1,
                                   DWORD a2,
                                   ULONG_PTR* a3)
{
    _PrintEnter("RaiseException(%p,%p,%p,%p)\n", a0, a1, a2, a3);

    __try {
        Real_RaiseException(a0, a1, a2, a3);
    } __finally {
        _PrintExit("RaiseException(,,,) ->\n");
    };
}

HRESULT __stdcall Mine_ReadClassStg(LPSTORAGE a0,
                                    CLSID* a1)
{
    _PrintEnter("ReadClassStg(%p,%p)\n", a0, a1);

    HRESULT rv = 0;
    __try {
        rv = Real_ReadClassStg(a0, a1);
    } __finally {
        _PrintExit("ReadClassStg(,) -> %p\n", rv);
    };
    return rv;
}

HRESULT __stdcall Mine_ReadClassStm(LPSTREAM a0,
                                    CLSID* a1)
{
    _PrintEnter("ReadClassStm(%p,%p)\n", a0, a1);

    HRESULT rv = 0;
    __try {
        rv = Real_ReadClassStm(a0, a1);
    } __finally {
        _PrintExit("ReadClassStm(,) -> %p\n", rv);
    };
    return rv;
}

BOOL __stdcall Mine_ReadConsoleA(
                                 HANDLE a0,
                                 LPVOID a1,
                                 DWORD a2,
                                 LPDWORD a3,
#ifdef ENABLE_INSERT_MODE
                                 PCONSOLE_READCONSOLE_CONTROL a4
#else
                                 LPVOID a4
#endif
                                )
{
    _PrintEnter("ReadConsoleA(%p,%p,%p,%p,%p)\n", a0, a1, a2, a3, a4);

    BOOL rv = 0;
    __try {
        rv = Real_ReadConsoleA(a0, a1, a2, a3, a4);
    } __finally {
        _PrintExit("ReadConsoleA(,,,,) -> %p\n", rv);
    };
    return rv;
}

BOOL __stdcall Mine_ReadConsoleInputA(HANDLE a0,
                                      PINPUT_RECORD a1,
                                      DWORD a2,
                                      LPDWORD a3)
{
    _PrintEnter("ReadConsoleInputA(%p,%p,%p,%p)\n", a0, a1, a2, a3);

    BOOL rv = 0;
    __try {
        rv = Real_ReadConsoleInputA(a0, a1, a2, a3);
    } __finally {
        _PrintExit("ReadConsoleInputA(,,,) -> %p\n", rv);
    };
    return rv;
}

BOOL __stdcall Mine_ReadConsoleInputW(HANDLE a0,
                                      PINPUT_RECORD a1,
                                      DWORD a2,
                                      LPDWORD a3)
{
    _PrintEnter("ReadConsoleInputW(%p,%p,%p,%p)\n", a0, a1, a2, a3);

    BOOL rv = 0;
    __try {
        rv = Real_ReadConsoleInputW(a0, a1, a2, a3);
    } __finally {
        _PrintExit("ReadConsoleInputW(,,,) -> %p\n", rv);
    };
    return rv;
}

BOOL __stdcall Mine_ReadConsoleOutputA(HANDLE a0,
                                       PCHAR_INFO a1,
                                       COORD a2,
                                       COORD a3,
                                       PSMALL_RECT a4)
{
    _PrintEnter("ReadConsoleOutputA(%p,%p,%p,%p,%p)\n", a0, a1, a2, a3, a4);

    BOOL rv = 0;
    __try {
        rv = Real_ReadConsoleOutputA(a0, a1, a2, a3, a4);
    } __finally {
        _PrintExit("ReadConsoleOutputA(,,,,) -> %p\n", rv);
    };
    return rv;
}

BOOL __stdcall Mine_ReadConsoleOutputAttribute(HANDLE a0,
                                               LPWORD a1,
                                               DWORD a2,
                                               COORD a3,
                                               LPDWORD a4)
{
    _PrintEnter("ReadConsoleOutputAttribute(%p,%p,%p,%p,%p)\n", a0, a1, a2, a3, a4);

    BOOL rv = 0;
    __try {
        rv = Real_ReadConsoleOutputAttribute(a0, a1, a2, a3, a4);
    } __finally {
        _PrintExit("ReadConsoleOutputAttribute(,,,,) -> %p\n", rv);
    };
    return rv;
}

BOOL __stdcall Mine_ReadConsoleOutputCharacterA(HANDLE a0,
                                                LPSTR a1,
                                                DWORD a2,
                                                COORD a3,
                                                LPDWORD a4)
{
    _PrintEnter("ReadConsoleOutputCharacterA(%p,%p,%p,%p,%p)\n", a0, a1, a2, a3, a4);

    BOOL rv = 0;
    __try {
        rv = Real_ReadConsoleOutputCharacterA(a0, a1, a2, a3, a4);
    } __finally {
        _PrintExit("ReadConsoleOutputCharacterA(,%hs,,,) -> %p\n", a1, rv);
    };
    return rv;
}

BOOL __stdcall Mine_ReadConsoleOutputCharacterW(HANDLE a0,
                                                LPWSTR a1,
                                                DWORD a2,
                                                COORD a3,
                                                LPDWORD a4)
{
    _PrintEnter("ReadConsoleOutputCharacterW(%p,%p,%p,%p,%p)\n", a0, a1, a2, a3, a4);

    BOOL rv = 0;
    __try {
        rv = Real_ReadConsoleOutputCharacterW(a0, a1, a2, a3, a4);
    } __finally {
        _PrintExit("ReadConsoleOutputCharacterW(,%ls,,,) -> %p\n", a1, rv);
    };
    return rv;
}

BOOL __stdcall Mine_ReadConsoleOutputW(HANDLE a0,
                                       PCHAR_INFO a1,
                                       COORD a2,
                                       COORD a3,
                                       PSMALL_RECT a4)
{
    _PrintEnter("ReadConsoleOutputW(%p,%p,%p,%p,%p)\n", a0, a1, a2, a3, a4);

    BOOL rv = 0;
    __try {
        rv = Real_ReadConsoleOutputW(a0, a1, a2, a3, a4);
    } __finally {
        _PrintExit("ReadConsoleOutputW(,,,,) -> %p\n", rv);
    };
    return rv;
}

BOOL __stdcall Mine_ReadConsoleW(
                                 HANDLE a0,
                                 LPVOID a1,
                                 DWORD a2,
                                 LPDWORD a3,
#ifdef ENABLE_INSERT_MODE
                                 PCONSOLE_READCONSOLE_CONTROL a4
#else
                                 LPVOID a4
#endif
                                )
{
    _PrintEnter("ReadConsoleW(%p,%p,%p,%p,%p)\n", a0, a1, a2, a3, a4);

    BOOL rv = 0;
    __try {
        rv = Real_ReadConsoleW(a0, a1, a2, a3, a4);
    } __finally {
        _PrintExit("ReadConsoleW(,,,,) -> %p\n", rv);
    };
    return rv;
}

BOOL __stdcall Mine_ReadDirectoryChangesW(HANDLE a0,
                                          LPVOID a1,
                                          DWORD a2,
                                          BOOL a3,
                                          DWORD a4,
                                          LPDWORD a5,
                                          LPOVERLAPPED a6,
                                          LPOVERLAPPED_COMPLETION_ROUTINE a7)
{
    _PrintEnter("ReadDirectoryChangesW(%p,%p,%p,%p,%p,%p,%p,%p)\n", a0, a1, a2, a3, a4, a5, a6, a7);

    BOOL rv = 0;
    __try {
        rv = Real_ReadDirectoryChangesW(a0, a1, a2, a3, a4, a5, a6, a7);
    } __finally {
        _PrintExit("ReadDirectoryChangesW(,,,,,,,) -> %p\n", rv);
    };
    return rv;
}

BOOL __stdcall Mine_ReadFile(HANDLE a0,
                             LPVOID a1,
                             DWORD a2,
                             LPDWORD a3,
                             LPOVERLAPPED a4)
{
    _PrintEnter("ReadFile(%p,%p,%p,%p,%p)\n", a0, a1, a2, a3, a4);

    BOOL rv = 0;
    __try {
        rv = Real_ReadFile(a0, a1, a2, a3, a4);
    } __finally {
        _PrintExit("ReadFile(,,,,) -> %p\n", rv);
    };
    return rv;
}

BOOL __stdcall Mine_ReadFileEx(HANDLE a0,
                               LPVOID a1,
                               DWORD a2,
                               LPOVERLAPPED a3,
                               LPOVERLAPPED_COMPLETION_ROUTINE a4)
{
    _PrintEnter("ReadFileEx(%p,%p,%p,%p,%p)\n", a0, a1, a2, a3, a4);

    BOOL rv = 0;
    __try {
        rv = Real_ReadFileEx(a0, a1, a2, a3, a4);
    } __finally {
        _PrintExit("ReadFileEx(,,,,) -> %p\n", rv);
    };
    return rv;
}

HRESULT __stdcall Mine_ReadFmtUserTypeStg(LPSTORAGE a0,
                                          CLIPFORMAT* a1,
                                          LPOLESTR* a2)
{
    _PrintEnter("ReadFmtUserTypeStg(%p,%p,%p)\n", a0, a1, a2);

    HRESULT rv = 0;
    __try {
        rv = Real_ReadFmtUserTypeStg(a0, a1, a2);
    } __finally {
        _PrintExit("ReadFmtUserTypeStg(,,) -> %p\n", rv);
    };
    return rv;
}

BOOL __stdcall Mine_ReadProcessMemory(HANDLE a0,
                                      LPCVOID lpBase,
                                      LPVOID lpBuf,
                                      DWORD_PTR nSize,
                                      PDWORD_PTR a4)
{
    _PrintEnter("ReadProcessMemory(%p,@%p..%p,%p,%p)\n",
                a0, lpBase,
                (PBYTE)lpBase + ((nSize > 0) ? nSize - 1 : 0),
                lpBuf, a4);

    BOOL rv = 0;
    __try {
        rv = Real_ReadProcessMemory(a0, lpBase, lpBuf, nSize, a4);
    } __finally {
        _PrintExit("ReadProcessMemory(,,,,) -> %p\n", rv);
    };
    return rv;
}

UINT __stdcall Mine_RealizePalette(HDC a0)
{
    _PrintEnter("RealizePalette(%p)\n", a0);

    UINT rv = 0;
    __try {
        rv = Real_RealizePalette(a0);
    } __finally {
        _PrintExit("RealizePalette() -> %p\n", rv);
    };
    return rv;
}

BOOL __stdcall Mine_RectInRegion(HRGN a0,
                                 RECT* a1)
{
    _PrintEnter("RectInRegion(%p,%p)\n", a0, a1);

    BOOL rv = 0;
    __try {
        rv = Real_RectInRegion(a0, a1);
    } __finally {
        _PrintExit("RectInRegion(,) -> %p\n", rv);
    };
    return rv;
}

BOOL __stdcall Mine_RectVisible(HDC a0,
                                RECT* a1)
{
    _PrintEnter("RectVisible(%p,%p)\n", a0, a1);

    BOOL rv = 0;
    __try {
        rv = Real_RectVisible(a0, a1);
    } __finally {
        _PrintExit("RectVisible(,) -> %p\n", rv);
    };
    return rv;
}

BOOL __stdcall Mine_Rectangle(HDC a0,
                              int a1,
                              int a2,
                              int a3,
                              int a4)
{
    _PrintEnter("Rectangle(%p,%p,%p,%p,%p)\n", a0, a1, a2, a3, a4);

    BOOL rv = 0;
    __try {
        rv = Real_Rectangle(a0, a1, a2, a3, a4);
    } __finally {
        _PrintExit("Rectangle(,,,,) -> %p\n", rv);
    };
    return rv;
}

BOOL __stdcall Mine_RedrawWindow(HWND a0,
                                 RECT* a1,
                                 HRGN a2,
                                 UINT a3)
{
    _PrintEnter("RedrawWindow(%p,%p,%p,%p)\n", a0, a1, a2, a3);

    BOOL rv = 0;
    __try {
        rv = Real_RedrawWindow(a0, a1, a2, a3);
    } __finally {
        _PrintExit("RedrawWindow(,,,) -> %p\n", rv);
    };
    return rv;
}

ATOM __stdcall Mine_RegisterClassA(WNDCLASSA* a0)
{
    _PrintEnter("RegisterClassA(%p)\n", a0);

    ATOM rv = 0;
    __try {
        rv = Real_RegisterClassA(a0);
    } __finally {
        _PrintExit("RegisterClassA() -> %p\n", rv);
    };
    return rv;
}

ATOM __stdcall Mine_RegisterClassExA(WNDCLASSEXA* a0)
{
    _PrintEnter("RegisterClassExA(%p)\n", a0);

    ATOM rv = 0;
    __try {
        rv = Real_RegisterClassExA(a0);
    } __finally {
        _PrintExit("RegisterClassExA() -> %p\n", rv);
    };
    return rv;
}

ATOM __stdcall Mine_RegisterClassExW(WNDCLASSEXW* a0)
{
    _PrintEnter("RegisterClassExW(%p)\n", a0);

    ATOM rv = 0;
    __try {
        rv = Real_RegisterClassExW(a0);
    } __finally {
        _PrintExit("RegisterClassExW() -> %p\n", rv);
    };
    return rv;
}

ATOM __stdcall Mine_RegisterClassW(WNDCLASSW* a0)
{
    _PrintEnter("RegisterClassW(%p)\n", a0);

    ATOM rv = 0;
    __try {
        rv = Real_RegisterClassW(a0);
    } __finally {
        _PrintExit("RegisterClassW() -> %p\n", rv);
    };
    return rv;
}

UINT __stdcall Mine_RegisterClipboardFormatA(LPCSTR a0)
{
    _PrintEnter("RegisterClipboardFormatA(%hs)\n", a0);

    UINT rv = 0;
    __try {
        rv = Real_RegisterClipboardFormatA(a0);
    } __finally {
        _PrintExit("RegisterClipboardFormatA() -> %p\n", rv);
    };
    return rv;
}

UINT __stdcall Mine_RegisterClipboardFormatW(LPCWSTR a0)
{
    _PrintEnter("RegisterClipboardFormatW(%ls)\n", a0);

    UINT rv = 0;
    __try {
        rv = Real_RegisterClipboardFormatW(a0);
    } __finally {
        _PrintExit("RegisterClipboardFormatW() -> %p\n", rv);
    };
    return rv;
}

HRESULT __stdcall Mine_RegisterDragDrop(HWND a0,
                                        IDropTarget* a1)
{
    _PrintEnter("RegisterDragDrop(%p,%p)\n", a0, a1);

    HRESULT rv = 0;
    __try {
        rv = Real_RegisterDragDrop(a0, a1);
    } __finally {
        _PrintExit("RegisterDragDrop(,) -> %p\n", rv);
    };
    return rv;
}

BOOL __stdcall Mine_RegisterHotKey(HWND a0,
                                   int a1,
                                   UINT a2,
                                   UINT a3)
{
    _PrintEnter("RegisterHotKey(%p,%p,%p,%p)\n", a0, a1, a2, a3);

    BOOL rv = 0;
    __try {
        rv = Real_RegisterHotKey(a0, a1, a2, a3);
    } __finally {
        _PrintExit("RegisterHotKey(,,,) -> %p\n", rv);
    };
    return rv;
}

UINT __stdcall Mine_RegisterWindowMessageA(LPCSTR a0)
{
    _PrintEnter("RegisterWindowMessageA(%hs)\n", a0);

    UINT rv = 0;
    __try {
        rv = Real_RegisterWindowMessageA(a0);
    } __finally {
        _PrintExit("RegisterWindowMessageA() -> %p\n", rv);
    };
    return rv;
}

UINT __stdcall Mine_RegisterWindowMessageW(LPCWSTR a0)
{
    _PrintEnter("RegisterWindowMessageW(%ls)\n", a0);

    UINT rv = 0;
    __try {
        rv = Real_RegisterWindowMessageW(a0);
    } __finally {
        _PrintExit("RegisterWindowMessageW() -> %p\n", rv);
    };
    return rv;
}

BOOL __stdcall Mine_ReleaseCapture(void)
{
    _PrintEnter("ReleaseCapture()\n");

    BOOL rv = 0;
    __try {
        rv = Real_ReleaseCapture();
    } __finally {
        _PrintExit("ReleaseCapture() -> %p\n", rv);
    };
    return rv;
}

int __stdcall Mine_ReleaseDC(HWND a0,
                             HDC a1)
{
    _PrintEnter("ReleaseDC(%p,%p)\n", a0, a1);

    int rv = 0;
    __try {
        rv = Real_ReleaseDC(a0, a1);
    } __finally {
        _PrintExit("ReleaseDC(,) -> %p\n", rv);
    };
    return rv;
}

BOOL __stdcall Mine_ReleaseMutex(HANDLE a0)
{
    _PrintEnter("ReleaseMutex(%p)\n", a0);

    BOOL rv = 0;
    __try {
        rv = Real_ReleaseMutex(a0);
    } __finally {
        _PrintExit("ReleaseMutex() -> %p\n", rv);
    };
    return rv;
}

BOOL __stdcall Mine_ReleaseSemaphore(HANDLE a0,
                                     LONG a1,
                                     LPLONG a2)
{
    _PrintEnter("ReleaseSemaphore(%p,%p,%p)\n", a0, a1, a2);

    BOOL rv = 0;
    __try {
        rv = Real_ReleaseSemaphore(a0, a1, a2);
    } __finally {
        _PrintExit("ReleaseSemaphore(,,) -> %p\n", rv);
    };
    return rv;
}

void __stdcall Mine_ReleaseStgMedium(LPSTGMEDIUM a0)
{
    _PrintEnter("ReleaseStgMedium(%p)\n", a0);

    __try {
        Real_ReleaseStgMedium(a0);
    } __finally {
        _PrintExit("ReleaseStgMedium() ->\n");
    };
}

BOOL __stdcall Mine_RemoveDirectoryA(LPCSTR a0)
{
    _PrintEnter("RemoveDirectoryA(%hs)\n", a0);

    BOOL rv = 0;
    __try {
        rv = Real_RemoveDirectoryA(a0);
    } __finally {
        _PrintExit("RemoveDirectoryA() -> %p\n", rv);
    };
    return rv;
}

BOOL __stdcall Mine_RemoveDirectoryW(LPCWSTR a0)
{
    _PrintEnter("RemoveDirectoryW(%ls)\n", a0);

    BOOL rv = 0;
    __try {
        rv = Real_RemoveDirectoryW(a0);
    } __finally {
        _PrintExit("RemoveDirectoryW() -> %p\n", rv);
    };
    return rv;
}

BOOL __stdcall Mine_RemoveFontResourceA(LPCSTR a0)
{
    _PrintEnter("RemoveFontResourceA(%hs)\n", a0);

    BOOL rv = 0;
    __try {
        rv = Real_RemoveFontResourceA(a0);
    } __finally {
        _PrintExit("RemoveFontResourceA() -> %p\n", rv);
    };
    return rv;
}

BOOL __stdcall Mine_RemoveFontResourceW(LPCWSTR a0)
{
    _PrintEnter("RemoveFontResourceW(%ls)\n", a0);

    BOOL rv = 0;
    __try {
        rv = Real_RemoveFontResourceW(a0);
    } __finally {
        _PrintExit("RemoveFontResourceW() -> %p\n", rv);
    };
    return rv;
}

BOOL __stdcall Mine_RemoveMenu(HMENU a0,
                               UINT a1,
                               UINT a2)
{
    _PrintEnter("RemoveMenu(%p,%p,%p)\n", a0, a1, a2);

    BOOL rv = 0;
    __try {
        rv = Real_RemoveMenu(a0, a1, a2);
    } __finally {
        _PrintExit("RemoveMenu(,,) -> %p\n", rv);
    };
    return rv;
}

HANDLE __stdcall Mine_RemovePropA(HWND a0,
                                  LPCSTR a1)
{
    _PrintEnter("RemovePropA(%p,%hs)\n", a0, a1);

    HANDLE rv = 0;
    __try {
        rv = Real_RemovePropA(a0, a1);
    } __finally {
        _PrintExit("RemovePropA(,) -> %p\n", rv);
    };
    return rv;
}

HANDLE __stdcall Mine_RemovePropW(HWND a0,
                                  LPCWSTR a1)
{
    _PrintEnter("RemovePropW(%p,%ls)\n", a0, a1);

    HANDLE rv = 0;
    __try {
        rv = Real_RemovePropW(a0, a1);
    } __finally {
        _PrintExit("RemovePropW(,) -> %p\n", rv);
    };
    return rv;
}

BOOL __stdcall Mine_ReplyMessage(LRESULT a0)
{
    _PrintEnter("ReplyMessage(%p)\n", a0);

    BOOL rv = 0;
    __try {
        rv = Real_ReplyMessage(a0);
    } __finally {
        _PrintExit("ReplyMessage() -> %p\n", rv);
    };
    return rv;
}

HDC __stdcall Mine_ResetDCA(HDC a0,
                            CONST DEVMODEA* a1)
{
    _PrintEnter("ResetDCA(%p,%p)\n", a0, a1);

    HDC rv = 0;
    __try {
        rv = Real_ResetDCA(a0, a1);
    } __finally {
        _PrintExit("ResetDCA(,) -> %p\n", rv);
    };
    return rv;
}

HDC __stdcall Mine_ResetDCW(HDC a0,
                            CONST DEVMODEW* a1)
{
    _PrintEnter("ResetDCW(%p,%p)\n", a0, a1);

    HDC rv = 0;
    __try {
        rv = Real_ResetDCW(a0, a1);
    } __finally {
        _PrintExit("ResetDCW(,) -> %p\n", rv);
    };
    return rv;
}

BOOL __stdcall Mine_ResetEvent(HANDLE a0)
{
    _PrintEnter("ResetEvent(%p)\n", a0);

    BOOL rv = 0;
    __try {
        rv = Real_ResetEvent(a0);
    } __finally {
        _PrintExit("ResetEvent() -> %p\n", rv);
    };
    return rv;
}

BOOL __stdcall Mine_ResizePalette(HPALETTE a0,
                                  UINT a1)
{
    _PrintEnter("ResizePalette(%p,%p)\n", a0, a1);

    BOOL rv = 0;
    __try {
        rv = Real_ResizePalette(a0, a1);
    } __finally {
        _PrintExit("ResizePalette(,) -> %p\n", rv);
    };
    return rv;
}

BOOL __stdcall Mine_RestoreDC(HDC a0,
                              int a1)
{
    _PrintEnter("RestoreDC(%p,%p)\n", a0, a1);

    BOOL rv = 0;
    __try {
        rv = Real_RestoreDC(a0, a1);
    } __finally {
        _PrintExit("RestoreDC(,) -> %p\n", rv);
    };
    return rv;
}

DWORD __stdcall Mine_ResumeThread(HANDLE a0)
{
    _PrintEnter("ResumeThread(%p)\n", a0);

    DWORD rv = 0;
    __try {
        rv = Real_ResumeThread(a0);
    } __finally {
        _PrintExit("ResumeThread() -> %p\n", rv);
    };
    return rv;
}

LPARAM __stdcall Mine_ReuseDDElParam(LPARAM a0,
                                     UINT a1,
                                     UINT a2,
                                     UINT_PTR a3,
                                     UINT_PTR a4)
{
    _PrintEnter("ReuseDDElParam(%p,%p,%p,%p,%p)\n", a0, a1, a2, a3, a4);

    LPARAM rv = 0;
    __try {
        rv = Real_ReuseDDElParam(a0, a1, a2, a3, a4);
    } __finally {
        _PrintExit("ReuseDDElParam(,,,,) -> %p\n", rv);
    };
    return rv;
}

HRESULT __stdcall Mine_RevokeDragDrop(HWND a0)
{
    _PrintEnter("RevokeDragDrop(%p)\n", a0);

    HRESULT rv = 0;
    __try {
        rv = Real_RevokeDragDrop(a0);
    } __finally {
        _PrintExit("RevokeDragDrop() -> %p\n", rv);
    };
    return rv;
}

BOOL __stdcall Mine_RoundRect(HDC a0,
                              int a1,
                              int a2,
                              int a3,
                              int a4,
                              int a5,
                              int a6)
{
    _PrintEnter("RoundRect(%p,%p,%p,%p,%p,%p,%p)\n", a0, a1, a2, a3, a4, a5, a6);

    BOOL rv = 0;
    __try {
        rv = Real_RoundRect(a0, a1, a2, a3, a4, a5, a6);
    } __finally {
        _PrintExit("RoundRect(,,,,,,) -> %p\n", rv);
    };
    return rv;
}

int __stdcall Mine_SaveDC(HDC a0)
{
    _PrintEnter("SaveDC(%p)\n", a0);

    int rv = 0;
    __try {
        rv = Real_SaveDC(a0);
    } __finally {
        _PrintExit("SaveDC() -> %p\n", rv);
    };
    return rv;
}

BOOL __stdcall Mine_ScaleViewportExtEx(HDC a0,
                                       int a1,
                                       int a2,
                                       int a3,
                                       int a4,
                                       SIZE* a5)
{
    _PrintEnter("ScaleViewportExtEx(%p,%p,%p,%p,%p,%p)\n", a0, a1, a2, a3, a4, a5);

    BOOL rv = 0;
    __try {
        rv = Real_ScaleViewportExtEx(a0, a1, a2, a3, a4, a5);
    } __finally {
        _PrintExit("ScaleViewportExtEx(,,,,,) -> %p\n", rv);
    };
    return rv;
}

BOOL __stdcall Mine_ScaleWindowExtEx(HDC a0,
                                     int a1,
                                     int a2,
                                     int a3,
                                     int a4,
                                     SIZE* a5)
{
    _PrintEnter("ScaleWindowExtEx(%p,%p,%p,%p,%p,%p)\n", a0, a1, a2, a3, a4, a5);

    BOOL rv = 0;
    __try {
        rv = Real_ScaleWindowExtEx(a0, a1, a2, a3, a4, a5);
    } __finally {
        _PrintExit("ScaleWindowExtEx(,,,,,) -> %p\n", rv);
    };
    return rv;
}

BOOL __stdcall Mine_ScreenToClient(HWND a0,
                                   POINT* a1)
{
    _PrintEnter("ScreenToClient(%p,%p)\n", a0, a1);

    BOOL rv = 0;
    __try {
        rv = Real_ScreenToClient(a0, a1);
    } __finally {
        _PrintExit("ScreenToClient(,) -> %p\n", rv);
    };
    return rv;
}

BOOL __stdcall Mine_ScrollConsoleScreenBufferA(HANDLE a0,
                                               SMALL_RECT* a1,
                                               SMALL_RECT* a2,
                                               COORD a3,
                                               CHAR_INFO* a4)
{
    _PrintEnter("ScrollConsoleScreenBufferA(%p,%p,%p,%p,%p)\n", a0, a1, a2, a3, a4);

    BOOL rv = 0;
    __try {
        rv = Real_ScrollConsoleScreenBufferA(a0, a1, a2, a3, a4);
    } __finally {
        _PrintExit("ScrollConsoleScreenBufferA(,,,,) -> %p\n", rv);
    };
    return rv;
}

BOOL __stdcall Mine_ScrollConsoleScreenBufferW(HANDLE a0,
                                               SMALL_RECT* a1,
                                               SMALL_RECT* a2,
                                               COORD a3,
                                               CHAR_INFO* a4)
{
    _PrintEnter("ScrollConsoleScreenBufferW(%p,%p,%p,%p,%p)\n", a0, a1, a2, a3, a4);

    BOOL rv = 0;
    __try {
        rv = Real_ScrollConsoleScreenBufferW(a0, a1, a2, a3, a4);
    } __finally {
        _PrintExit("ScrollConsoleScreenBufferW(,,,,) -> %p\n", rv);
    };
    return rv;
}

BOOL __stdcall Mine_ScrollDC(HDC a0,
                             int a1,
                             int a2,
                             RECT* a3,
                             RECT* a4,
                             HRGN a5,
                             LPRECT a6)
{
    _PrintEnter("ScrollDC(%p,%p,%p,%p,%p,%p,%p)\n", a0, a1, a2, a3, a4, a5, a6);

    BOOL rv = 0;
    __try {
        rv = Real_ScrollDC(a0, a1, a2, a3, a4, a5, a6);
    } __finally {
        _PrintExit("ScrollDC(,,,,,,) -> %p\n", rv);
    };
    return rv;
}

BOOL __stdcall Mine_ScrollWindow(HWND a0,
                                 int a1,
                                 int a2,
                                 RECT* a3,
                                 RECT* a4)
{
    _PrintEnter("ScrollWindow(%p,%p,%p,%p,%p)\n", a0, a1, a2, a3, a4);

    BOOL rv = 0;
    __try {
        rv = Real_ScrollWindow(a0, a1, a2, a3, a4);
    } __finally {
        _PrintExit("ScrollWindow(,,,,) -> %p\n", rv);
    };
    return rv;
}

int __stdcall Mine_ScrollWindowEx(HWND a0,
                                  int a1,
                                  int a2,
                                  RECT* a3,
                                  RECT* a4,
                                  HRGN a5,
                                  LPRECT a6,
                                  UINT a7)
{
    _PrintEnter("ScrollWindowEx(%p,%p,%p,%p,%p,%p,%p,%p)\n", a0, a1, a2, a3, a4, a5, a6, a7);

    int rv = 0;
    __try {
        rv = Real_ScrollWindowEx(a0, a1, a2, a3, a4, a5, a6, a7);
    } __finally {
        _PrintExit("ScrollWindowEx(,,,,,,,) -> %p\n", rv);
    };
    return rv;
}

DWORD __stdcall Mine_SearchPathA(LPCSTR a0,
                                 LPCSTR a1,
                                 LPCSTR a2,
                                 DWORD a3,
                                 LPSTR a4,
                                 LPSTR* a5)
{
    _PrintEnter("SearchPathA(%hs,%hs,%hs,%p,%p,%p)\n", a0, a1, a2, a3, a4, a5);

    DWORD rv = 0;
    __try {
        rv = Real_SearchPathA(a0, a1, a2, a3, a4, a5);
    } __finally {
        _PrintExit("SearchPathA(,,,,%hs,) -> %p\n", a4, rv);
    };
    return rv;
}

DWORD __stdcall Mine_SearchPathW(LPCWSTR a0,
                                 LPCWSTR a1,
                                 LPCWSTR a2,
                                 DWORD a3,
                                 LPWSTR a4,
                                 LPWSTR* a5)
{
    _PrintEnter("SearchPathW(%ls,%ls,%ls,%p,%p,%p)\n", a0, a1, a2, a3, a4, a5);

    DWORD rv = 0;
    __try {
        rv = Real_SearchPathW(a0, a1, a2, a3, a4, a5);
    } __finally {
        _PrintExit("SearchPathW(,,,,%ls,) -> %p\n", a4, rv);
    };
    return rv;
}

BOOL __stdcall Mine_SelectClipPath(HDC a0,
                                   int a1)
{
    _PrintEnter("SelectClipPath(%p,%p)\n", a0, a1);

    BOOL rv = 0;
    __try {
        rv = Real_SelectClipPath(a0, a1);
    } __finally {
        _PrintExit("SelectClipPath(,) -> %p\n", rv);
    };
    return rv;
}

int __stdcall Mine_SelectClipRgn(HDC a0,
                                 HRGN a1)
{
    _PrintEnter("SelectClipRgn(%p,%p)\n", a0, a1);

    int rv = 0;
    __try {
        rv = Real_SelectClipRgn(a0, a1);
    } __finally {
        _PrintExit("SelectClipRgn(,) -> %p\n", rv);
    };
    return rv;
}

HGDIOBJ __stdcall Mine_SelectObject(HDC a0,
                                    HGDIOBJ a1)
{
    _PrintEnter("SelectObject(%p,%p)\n", a0, a1);

    HGDIOBJ rv = 0;
    __try {
        rv = Real_SelectObject(a0, a1);
    } __finally {
        _PrintExit("SelectObject(,) -> %p\n", rv);
    };
    return rv;
}

HPALETTE __stdcall Mine_SelectPalette(HDC a0,
                                      HPALETTE a1,
                                      BOOL a2)
{
    _PrintEnter("SelectPalette(%p,%p,%p)\n", a0, a1, a2);

    HPALETTE rv = 0;
    __try {
        rv = Real_SelectPalette(a0, a1, a2);
    } __finally {
        _PrintExit("SelectPalette(,,) -> %p\n", rv);
    };
    return rv;
}

LRESULT __stdcall Mine_SendDlgItemMessageA(HWND a0,
                                           int a1,
                                           UINT a2,
                                           WPARAM a3,
                                           LPARAM a4)
{
    _PrintEnter("SendDlgItemMessageA(%p,%p,%p,%p,%p)\n", a0, a1, a2, a3, a4);

    LRESULT rv = 0;
    __try {
        rv = Real_SendDlgItemMessageA(a0, a1, a2, a3, a4);
    } __finally {
        _PrintExit("SendDlgItemMessageA(,,,,) -> %p\n", rv);
    };
    return rv;
}

LRESULT __stdcall Mine_SendDlgItemMessageW(HWND a0,
                                           int a1,
                                           UINT a2,
                                           WPARAM a3,
                                           LPARAM a4)
{
    _PrintEnter("SendDlgItemMessageW(%p,%p,%p,%p,%p)\n", a0, a1, a2, a3, a4);

    LRESULT rv = 0;
    __try {
        rv = Real_SendDlgItemMessageW(a0, a1, a2, a3, a4);
    } __finally {
        _PrintExit("SendDlgItemMessageW(,,,,) -> %p\n", rv);
    };
    return rv;
}

LRESULT __stdcall Mine_SendMessageA(HWND a0,
                                    UINT a1,
                                    WPARAM a2,
                                    LPARAM a3)
{
    _PrintEnter("SendMessageA(%p,%p,%p,%p)\n", a0, a1, a2, a3);

    LRESULT rv = 0;
    __try {
        rv = Real_SendMessageA(a0, a1, a2, a3);
    } __finally {
        _PrintExit("SendMessageA(,,,) -> %p\n", rv);
    };
    return rv;
}

BOOL __stdcall Mine_SendMessageCallbackA(HWND a0,
                                         UINT a1,
                                         WPARAM a2,
                                         LPARAM a3,
                                         SENDASYNCPROC a4,
                                         ULONG_PTR a5)
{
    _PrintEnter("SendMessageCallbackA(%p,%p,%p,%p,%p,%p)\n", a0, a1, a2, a3, a4, a5);

    BOOL rv = 0;
    __try {
        rv = Real_SendMessageCallbackA(a0, a1, a2, a3, a4, a5);
    } __finally {
        _PrintExit("SendMessageCallbackA(,,,,,) -> %p\n", rv);
    };
    return rv;
}

BOOL __stdcall Mine_SendMessageCallbackW(HWND a0,
                                         UINT a1,
                                         WPARAM a2,
                                         LPARAM a3,
                                         SENDASYNCPROC a4,
                                         ULONG_PTR a5)
{
    _PrintEnter("SendMessageCallbackW(%p,%p,%p,%p,%p,%p)\n", a0, a1, a2, a3, a4, a5);

    BOOL rv = 0;
    __try {
        rv = Real_SendMessageCallbackW(a0, a1, a2, a3, a4, a5);
    } __finally {
        _PrintExit("SendMessageCallbackW(,,,,,) -> %p\n", rv);
    };
    return rv;
}

LRESULT __stdcall Mine_SendMessageTimeoutA(HWND a0,
                                           UINT a1,
                                           WPARAM a2,
                                           LPARAM a3,
                                           UINT a4,
                                           UINT a5,
                                           PULONG_PTR a6)
{
    _PrintEnter("SendMessageTimeoutA(%p,%p,%p,%p,%p,%p,%p)\n", a0, a1, a2, a3, a4, a5, a6);

    LRESULT rv = 0;
    __try {
        rv = Real_SendMessageTimeoutA(a0, a1, a2, a3, a4, a5, a6);
    } __finally {
        _PrintExit("SendMessageTimeoutA(,,,,,,) -> %p\n", rv);
    };
    return rv;
}

LRESULT __stdcall Mine_SendMessageTimeoutW(HWND a0,
                                           UINT a1,
                                           WPARAM a2,
                                           LPARAM a3,
                                           UINT a4,
                                           UINT a5,
                                           PULONG_PTR a6)
{
    _PrintEnter("SendMessageTimeoutW(%p,%p,%p,%p,%p,%p,%p)\n", a0, a1, a2, a3, a4, a5, a6);

    LRESULT rv = 0;
    __try {
        rv = Real_SendMessageTimeoutW(a0, a1, a2, a3, a4, a5, a6);
    } __finally {
        _PrintExit("SendMessageTimeoutW(,,,,,,) -> %p\n", rv);
    };
    return rv;
}

LRESULT __stdcall Mine_SendMessageW(HWND a0,
                                    UINT a1,
                                    WPARAM a2,
                                    LPARAM a3)
{
    _PrintEnter("SendMessageW(%p,%p,%p,%p)\n", a0, a1, a2, a3);

    LRESULT rv = 0;
    __try {
        rv = Real_SendMessageW(a0, a1, a2, a3);
    } __finally {
        _PrintExit("SendMessageW(,,,) -> %p\n", rv);
    };
    return rv;
}

BOOL __stdcall Mine_SendNotifyMessageA(HWND a0,
                                       UINT a1,
                                       WPARAM a2,
                                       LPARAM a3)
{
    _PrintEnter("SendNotifyMessageA(%p,%p,%p,%p)\n", a0, a1, a2, a3);

    BOOL rv = 0;
    __try {
        rv = Real_SendNotifyMessageA(a0, a1, a2, a3);
    } __finally {
        _PrintExit("SendNotifyMessageA(,,,) -> %p\n", rv);
    };
    return rv;
}

BOOL __stdcall Mine_SendNotifyMessageW(HWND a0,
                                       UINT a1,
                                       WPARAM a2,
                                       LPARAM a3)
{
    _PrintEnter("SendNotifyMessageW(%p,%p,%p,%p)\n", a0, a1, a2, a3);

    BOOL rv = 0;
    __try {
        rv = Real_SendNotifyMessageW(a0, a1, a2, a3);
    } __finally {
        _PrintExit("SendNotifyMessageW(,,,) -> %p\n", rv);
    };
    return rv;
}

int __stdcall Mine_SetAbortProc(HDC a0,
                                ABORTPROC a1)
{
    _PrintEnter("SetAbortProc(%p,%p)\n", a0, a1);

    int rv = 0;
    __try {
        rv = Real_SetAbortProc(a0, a1);
    } __finally {
        _PrintExit("SetAbortProc(,) -> %p\n", rv);
    };
    return rv;
}

HWND __stdcall Mine_SetActiveWindow(HWND a0)
{
    _PrintEnter("SetActiveWindow(%p)\n", a0);

    HWND rv = 0;
    __try {
        rv = Real_SetActiveWindow(a0);
    } __finally {
        _PrintExit("SetActiveWindow() -> %p\n", rv);
    };
    return rv;
}

int __stdcall Mine_SetArcDirection(HDC a0,
                                   int a1)
{
    _PrintEnter("SetArcDirection(%p,%p)\n", a0, a1);

    int rv = 0;
    __try {
        rv = Real_SetArcDirection(a0, a1);
    } __finally {
        _PrintExit("SetArcDirection(,) -> %p\n", rv);
    };
    return rv;
}

LONG __stdcall Mine_SetBitmapBits(HBITMAP a0,
                                  DWORD a1,
                                  void* a2)
{
    _PrintEnter("SetBitmapBits(%p,%p,%p)\n", a0, a1, a2);

    LONG rv = 0;
    __try {
        rv = Real_SetBitmapBits(a0, a1, a2);
    } __finally {
        _PrintExit("SetBitmapBits(,,) -> %p\n", rv);
    };
    return rv;
}

BOOL __stdcall Mine_SetBitmapDimensionEx(HBITMAP a0,
                                         int a1,
                                         int a2,
                                         SIZE* a3)
{
    _PrintEnter("SetBitmapDimensionEx(%p,%p,%p,%p)\n", a0, a1, a2, a3);

    BOOL rv = 0;
    __try {
        rv = Real_SetBitmapDimensionEx(a0, a1, a2, a3);
    } __finally {
        _PrintExit("SetBitmapDimensionEx(,,,) -> %p\n", rv);
    };
    return rv;
}

COLORREF __stdcall Mine_SetBkColor(HDC a0,
                                   COLORREF a1)
{
    _PrintEnter("SetBkColor(%p,%p)\n", a0, a1);

    COLORREF rv = 0;
    __try {
        rv = Real_SetBkColor(a0, a1);
    } __finally {
        _PrintExit("SetBkColor(,) -> %p\n", rv);
    };
    return rv;
}

int __stdcall Mine_SetBkMode(HDC a0,
                             int a1)
{
    _PrintEnter("SetBkMode(%p,%p)\n", a0, a1);

    int rv = 0;
    __try {
        rv = Real_SetBkMode(a0, a1);
    } __finally {
        _PrintExit("SetBkMode(,) -> %p\n", rv);
    };
    return rv;
}

UINT __stdcall Mine_SetBoundsRect(HDC a0,
                                  RECT* a1,
                                  UINT a2)
{
    _PrintEnter("SetBoundsRect(%p,%p,%p)\n", a0, a1, a2);

    UINT rv = 0;
    __try {
        rv = Real_SetBoundsRect(a0, a1, a2);
    } __finally {
        _PrintExit("SetBoundsRect(,,) -> %p\n", rv);
    };
    return rv;
}

BOOL __stdcall Mine_SetBrushOrgEx(HDC a0,
                                  int a1,
                                  int a2,
                                  POINT* a3)
{
    _PrintEnter("SetBrushOrgEx(%p,%p,%p,%p)\n", a0, a1, a2, a3);

    BOOL rv = 0;
    __try {
        rv = Real_SetBrushOrgEx(a0, a1, a2, a3);
    } __finally {
        _PrintExit("SetBrushOrgEx(,,,) -> %p\n", rv);
    };
    return rv;
}

HWND __stdcall Mine_SetCapture(HWND a0)
{
    _PrintEnter("SetCapture(%p)\n", a0);

    HWND rv = 0;
    __try {
        rv = Real_SetCapture(a0);
    } __finally {
        _PrintExit("SetCapture() -> %p\n", rv);
    };
    return rv;
}

BOOL __stdcall Mine_SetCaretBlinkTime(UINT a0)
{
    _PrintEnter("SetCaretBlinkTime(%p)\n", a0);

    BOOL rv = 0;
    __try {
        rv = Real_SetCaretBlinkTime(a0);
    } __finally {
        _PrintExit("SetCaretBlinkTime() -> %p\n", rv);
    };
    return rv;
}

BOOL __stdcall Mine_SetCaretPos(int a0,
                                int a1)
{
    _PrintEnter("SetCaretPos(%p,%p)\n", a0, a1);

    BOOL rv = 0;
    __try {
        rv = Real_SetCaretPos(a0, a1);
    } __finally {
        _PrintExit("SetCaretPos(,) -> %p\n", rv);
    };
    return rv;
}

DWORD __stdcall Mine_SetClassLongA(HWND a0,
                                   int a1,
                                   LONG a2)
{
    _PrintEnter("SetClassLongA(%p,%p,%p)\n", a0, a1, a2);

    DWORD rv = 0;
    __try {
        rv = Real_SetClassLongA(a0, a1, a2);
    } __finally {
        _PrintExit("SetClassLongA(,,) -> %p\n", rv);
    };
    return rv;
}

DWORD __stdcall Mine_SetClassLongW(HWND a0,
                                   int a1,
                                   LONG a2)
{
    _PrintEnter("SetClassLongW(%p,%p,%p)\n", a0, a1, a2);

    DWORD rv = 0;
    __try {
        rv = Real_SetClassLongW(a0, a1, a2);
    } __finally {
        _PrintExit("SetClassLongW(,,) -> %p\n", rv);
    };
    return rv;
}

WORD __stdcall Mine_SetClassWord(HWND a0,
                                 int a1,
                                 WORD a2)
{
    _PrintEnter("SetClassWord(%p,%p,%p)\n", a0, a1, a2);

    WORD rv = 0;
    __try {
        rv = Real_SetClassWord(a0, a1, a2);
    } __finally {
        _PrintExit("SetClassWord(,,) -> %p\n", rv);
    };
    return rv;
}

HANDLE __stdcall Mine_SetClipboardData(UINT a0,
                                       HANDLE a1)
{
    _PrintEnter("SetClipboardData(%p,%p)\n", a0, a1);

    HANDLE rv = 0;
    __try {
        rv = Real_SetClipboardData(a0, a1);
    } __finally {
        _PrintExit("SetClipboardData(,) -> %p\n", rv);
    };
    return rv;
}

HWND __stdcall Mine_SetClipboardViewer(HWND a0)
{
    _PrintEnter("SetClipboardViewer(%p)\n", a0);

    HWND rv = 0;
    __try {
        rv = Real_SetClipboardViewer(a0);
    } __finally {
        _PrintExit("SetClipboardViewer() -> %p\n", rv);
    };
    return rv;
}

BOOL __stdcall Mine_SetColorAdjustment(HDC a0,
                                       COLORADJUSTMENT* a1)
{
    _PrintEnter("SetColorAdjustment(%p,%p)\n", a0, a1);

    BOOL rv = 0;
    __try {
        rv = Real_SetColorAdjustment(a0, a1);
    } __finally {
        _PrintExit("SetColorAdjustment(,) -> %p\n", rv);
    };
    return rv;
}

HCOLORSPACE __stdcall Mine_SetColorSpace(HDC a0,
                                         HCOLORSPACE a1)
{
    _PrintEnter("SetColorSpace(%p,%p)\n", a0, a1);

    HCOLORSPACE rv = 0;
    __try {
        rv = Real_SetColorSpace(a0, a1);
    } __finally {
        _PrintExit("SetColorSpace(,) -> %p\n", rv);
    };
    return rv;
}

BOOL __stdcall Mine_SetCommBreak(HANDLE a0)
{
    _PrintEnter("SetCommBreak(%p)\n", a0);

    BOOL rv = 0;
    __try {
        rv = Real_SetCommBreak(a0);
    } __finally {
        _PrintExit("SetCommBreak() -> %p\n", rv);
    };
    return rv;
}

BOOL __stdcall Mine_SetCommConfig(HANDLE a0,
                                  LPCOMMCONFIG a1,
                                  DWORD a2)
{
    _PrintEnter("SetCommConfig(%p,%p,%p)\n", a0, a1, a2);

    BOOL rv = 0;
    __try {
        rv = Real_SetCommConfig(a0, a1, a2);
    } __finally {
        _PrintExit("SetCommConfig(,,) -> %p\n", rv);
    };
    return rv;
}

BOOL __stdcall Mine_SetCommMask(HANDLE a0,
                                DWORD a1)
{
    _PrintEnter("SetCommMask(%p,%p)\n", a0, a1);

    BOOL rv = 0;
    __try {
        rv = Real_SetCommMask(a0, a1);
    } __finally {
        _PrintExit("SetCommMask(,) -> %p\n", rv);
    };
    return rv;
}

BOOL __stdcall Mine_SetCommState(HANDLE a0,
                                 LPDCB a1)
{
    _PrintEnter("SetCommState(%p,%p)\n", a0, a1);

    BOOL rv = 0;
    __try {
        rv = Real_SetCommState(a0, a1);
    } __finally {
        _PrintExit("SetCommState(,) -> %p\n", rv);
    };
    return rv;
}

BOOL __stdcall Mine_SetCommTimeouts(HANDLE a0,
                                    LPCOMMTIMEOUTS a1)
{
    _PrintEnter("SetCommTimeouts(%p,%p)\n", a0, a1);

    BOOL rv = 0;
    __try {
        rv = Real_SetCommTimeouts(a0, a1);
    } __finally {
        _PrintExit("SetCommTimeouts(,) -> %p\n", rv);
    };
    return rv;
}

BOOL __stdcall Mine_SetComputerNameA(LPCSTR a0)
{
    _PrintEnter("SetComputerNameA(%hs)\n", a0);

    BOOL rv = 0;
    __try {
        rv = Real_SetComputerNameA(a0);
    } __finally {
        _PrintExit("SetComputerNameA() -> %p\n", rv);
    };
    return rv;
}

BOOL __stdcall Mine_SetComputerNameW(LPCWSTR a0)
{
    _PrintEnter("SetComputerNameW(%ls)\n", a0);

    BOOL rv = 0;
    __try {
        rv = Real_SetComputerNameW(a0);
    } __finally {
        _PrintExit("SetComputerNameW() -> %p\n", rv);
    };
    return rv;
}

BOOL __stdcall Mine_SetConsoleActiveScreenBuffer(HANDLE a0)
{
    _PrintEnter("SetConsoleActiveScreenBuffer(%p)\n", a0);

    BOOL rv = 0;
    __try {
        rv = Real_SetConsoleActiveScreenBuffer(a0);
    } __finally {
        _PrintExit("SetConsoleActiveScreenBuffer() -> %p\n", rv);
    };
    return rv;
}

BOOL __stdcall Mine_SetConsoleCP(UINT a0)
{
    _PrintEnter("SetConsoleCP(%p)\n", a0);

    BOOL rv = 0;
    __try {
        rv = Real_SetConsoleCP(a0);
    } __finally {
        _PrintExit("SetConsoleCP() -> %p\n", rv);
    };
    return rv;
}

BOOL __stdcall Mine_SetConsoleCtrlHandler(PHANDLER_ROUTINE a0,
                                          BOOL a1)
{
    _PrintEnter("SetConsoleCtrlHandler(%p,%p)\n", a0, a1);

    BOOL rv = 0;
    __try {
        rv = Real_SetConsoleCtrlHandler(a0, a1);
    } __finally {
        _PrintExit("SetConsoleCtrlHandler(,) -> %p\n", rv);
    };
    return rv;
}

BOOL __stdcall Mine_SetConsoleCursorInfo(HANDLE a0,
                                         CONSOLE_CURSOR_INFO* a1)
{
    _PrintEnter("SetConsoleCursorInfo(%p,%p)\n", a0, a1);

    BOOL rv = 0;
    __try {
        rv = Real_SetConsoleCursorInfo(a0, a1);
    } __finally {
        _PrintExit("SetConsoleCursorInfo(,) -> %p\n", rv);
    };
    return rv;
}

BOOL __stdcall Mine_SetConsoleCursorPosition(HANDLE a0,
                                             COORD a1)
{
    _PrintEnter("SetConsoleCursorPosition(%p,%p)\n", a0, a1);

    BOOL rv = 0;
    __try {
        rv = Real_SetConsoleCursorPosition(a0, a1);
    } __finally {
        _PrintExit("SetConsoleCursorPosition(,) -> %p\n", rv);
    };
    return rv;
}

BOOL __stdcall Mine_SetConsoleMode(HANDLE a0,
                                   DWORD a1)
{
    _PrintEnter("SetConsoleMode(%p,%p)\n", a0, a1);

    BOOL rv = 0;
    __try {
        rv = Real_SetConsoleMode(a0, a1);
    } __finally {
        _PrintExit("SetConsoleMode(,) -> %p\n", rv);
    };
    return rv;
}

BOOL __stdcall Mine_SetConsoleOutputCP(UINT a0)
{
    _PrintEnter("SetConsoleOutputCP(%p)\n", a0);

    BOOL rv = 0;
    __try {
        rv = Real_SetConsoleOutputCP(a0);
    } __finally {
        _PrintExit("SetConsoleOutputCP() -> %p\n", rv);
    };
    return rv;
}

BOOL __stdcall Mine_SetConsoleScreenBufferSize(HANDLE a0,
                                               COORD a1)
{
    _PrintEnter("SetConsoleScreenBufferSize(%p,%p)\n", a0, a1);

    BOOL rv = 0;
    __try {
        rv = Real_SetConsoleScreenBufferSize(a0, a1);
    } __finally {
        _PrintExit("SetConsoleScreenBufferSize(,) -> %p\n", rv);
    };
    return rv;
}

BOOL __stdcall Mine_SetConsoleTextAttribute(HANDLE a0,
                                            WORD a1)
{
    _PrintEnter("SetConsoleTextAttribute(%p,%p)\n", a0, a1);

    BOOL rv = 0;
    __try {
        rv = Real_SetConsoleTextAttribute(a0, a1);
    } __finally {
        _PrintExit("SetConsoleTextAttribute(,) -> %p\n", rv);
    };
    return rv;
}

BOOL __stdcall Mine_SetConsoleTitleA(LPCSTR a0)
{
    _PrintEnter("SetConsoleTitleA(%hs)\n", a0);

    BOOL rv = 0;
    __try {
        rv = Real_SetConsoleTitleA(a0);
    } __finally {
        _PrintExit("SetConsoleTitleA() -> %p\n", rv);
    };
    return rv;
}

BOOL __stdcall Mine_SetConsoleTitleW(LPCWSTR a0)
{
    _PrintEnter("SetConsoleTitleW(%ls)\n", a0);

    BOOL rv = 0;
    __try {
        rv = Real_SetConsoleTitleW(a0);
    } __finally {
        _PrintExit("SetConsoleTitleW() -> %p\n", rv);
    };
    return rv;
}

BOOL __stdcall Mine_SetConsoleWindowInfo(HANDLE a0,
                                         BOOL a1,
                                         SMALL_RECT* a2)
{
    _PrintEnter("SetConsoleWindowInfo(%p,%p,%p)\n", a0, a1, a2);

    BOOL rv = 0;
    __try {
        rv = Real_SetConsoleWindowInfo(a0, a1, a2);
    } __finally {
        _PrintExit("SetConsoleWindowInfo(,,) -> %p\n", rv);
    };
    return rv;
}

HRESULT __stdcall Mine_SetConvertStg(LPSTORAGE a0,
                                     BOOL a1)
{
    _PrintEnter("SetConvertStg(%p,%p)\n", a0, a1);

    HRESULT rv = 0;
    __try {
        rv = Real_SetConvertStg(a0, a1);
    } __finally {
        _PrintExit("SetConvertStg(,) -> %p\n", rv);
    };
    return rv;
}

BOOL __stdcall Mine_SetCurrentDirectoryA(LPCSTR a0)
{
    _PrintEnter("SetCurrentDirectoryA(%hs)\n", a0);

    BOOL rv = 0;
    __try {
        rv = Real_SetCurrentDirectoryA(a0);
    } __finally {
        _PrintExit("SetCurrentDirectoryA() -> %p\n", rv);
    };
    return rv;
}

BOOL __stdcall Mine_SetCurrentDirectoryW(LPCWSTR a0)
{
    _PrintEnter("SetCurrentDirectoryW(%ls)\n", a0);

    BOOL rv = 0;
    __try {
        rv = Real_SetCurrentDirectoryW(a0);
    } __finally {
        _PrintExit("SetCurrentDirectoryW() -> %p\n", rv);
    };
    return rv;
}

HCURSOR __stdcall Mine_SetCursor(HCURSOR a0)
{
    _PrintEnter("SetCursor(%p)\n", a0);

    HCURSOR rv = 0;
    __try {
        rv = Real_SetCursor(a0);
    } __finally {
        _PrintExit("SetCursor() -> %p\n", rv);
    };
    return rv;
}

BOOL __stdcall Mine_SetCursorPos(int a0,
                                 int a1)
{
    _PrintEnter("SetCursorPos(%p,%p)\n", a0, a1);

    BOOL rv = 0;
    __try {
        rv = Real_SetCursorPos(a0, a1);
    } __finally {
        _PrintExit("SetCursorPos(,) -> %p\n", rv);
    };
    return rv;
}

UINT __stdcall Mine_SetDIBColorTable(HDC a0,
                                     UINT a1,
                                     UINT a2,
                                     RGBQUAD* a3)
{
    _PrintEnter("SetDIBColorTable(%p,%p,%p,%p)\n", a0, a1, a2, a3);

    UINT rv = 0;
    __try {
        rv = Real_SetDIBColorTable(a0, a1, a2, a3);
    } __finally {
        _PrintExit("SetDIBColorTable(,,,) -> %p\n", rv);
    };
    return rv;
}

int __stdcall Mine_SetDIBits(HDC a0,
                             HBITMAP a1,
                             UINT a2,
                             UINT a3,
                             void* a4,
                             BITMAPINFO* a5,
                             UINT a6)
{
    _PrintEnter("SetDIBits(%p,%p,%p,%p,%p,%p,%p)\n", a0, a1, a2, a3, a4, a5, a6);

    int rv = 0;
    __try {
        rv = Real_SetDIBits(a0, a1, a2, a3, a4, a5, a6);
    } __finally {
        _PrintExit("SetDIBits(,,,,,,) -> %p\n", rv);
    };
    return rv;
}

int __stdcall Mine_SetDIBitsToDevice(HDC a0,
                                     int a1,
                                     int a2,
                                     DWORD a3,
                                     DWORD a4,
                                     int a5,
                                     int a6,
                                     UINT a7,
                                     UINT a8,
                                     void* a9,
                                     BITMAPINFO* a10,
                                     UINT a11)
{
    _PrintEnter("SetDIBitsToDevice(%p,%p,%p,%p,%p,%p,%p,%p,%p,%p,%p,%p)\n", a0, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11);

    int rv = 0;
    __try {
        rv = Real_SetDIBitsToDevice(a0, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11);
    } __finally {
        _PrintExit("SetDIBitsToDevice(,,,,,,,,,,,) -> %p\n", rv);
    };
    return rv;
}

BOOL __stdcall Mine_SetDefaultCommConfigA(LPCSTR a0,
                                          LPCOMMCONFIG a1,
                                          DWORD a2)
{
    _PrintEnter("SetDefaultCommConfigA(%hs,%p,%p)\n", a0, a1, a2);

    BOOL rv = 0;
    __try {
        rv = Real_SetDefaultCommConfigA(a0, a1, a2);
    } __finally {
        _PrintExit("SetDefaultCommConfigA(,,) -> %p\n", rv);
    };
    return rv;
}

BOOL __stdcall Mine_SetDefaultCommConfigW(LPCWSTR a0,
                                          LPCOMMCONFIG a1,
                                          DWORD a2)
{
    _PrintEnter("SetDefaultCommConfigW(%ls,%p,%p)\n", a0, a1, a2);

    BOOL rv = 0;
    __try {
        rv = Real_SetDefaultCommConfigW(a0, a1, a2);
    } __finally {
        _PrintExit("SetDefaultCommConfigW(,,) -> %p\n", rv);
    };
    return rv;
}

BOOL __stdcall Mine_SetDeviceGammaRamp(HDC a0,
                                       LPVOID a1)
{
    _PrintEnter("SetDeviceGammaRamp(%p,%p)\n", a0, a1);

    BOOL rv = 0;
    __try {
        rv = Real_SetDeviceGammaRamp(a0, a1);
    } __finally {
        _PrintExit("SetDeviceGammaRamp(,) -> %p\n", rv);
    };
    return rv;
}

BOOL __stdcall Mine_SetDlgItemInt(HWND a0,
                                  int a1,
                                  UINT a2,
                                  BOOL a3)
{
    _PrintEnter("SetDlgItemInt(%p,%p,%p,%p)\n", a0, a1, a2, a3);

    BOOL rv = 0;
    __try {
        rv = Real_SetDlgItemInt(a0, a1, a2, a3);
    } __finally {
        _PrintExit("SetDlgItemInt(,,,) -> %p\n", rv);
    };
    return rv;
}

BOOL __stdcall Mine_SetDlgItemTextA(HWND a0,
                                    int a1,
                                    LPCSTR a2)
{
    _PrintEnter("SetDlgItemTextA(%p,%p,%hs)\n", a0, a1, a2);

    BOOL rv = 0;
    __try {
        rv = Real_SetDlgItemTextA(a0, a1, a2);
    } __finally {
        _PrintExit("SetDlgItemTextA(,,) -> %p\n", rv);
    };
    return rv;
}

BOOL __stdcall Mine_SetDlgItemTextW(HWND a0,
                                    int a1,
                                    LPCWSTR a2)
{
    _PrintEnter("SetDlgItemTextW(%p,%p,%ls)\n", a0, a1, a2);

    BOOL rv = 0;
    __try {
        rv = Real_SetDlgItemTextW(a0, a1, a2);
    } __finally {
        _PrintExit("SetDlgItemTextW(,,) -> %p\n", rv);
    };
    return rv;
}

BOOL __stdcall Mine_SetDoubleClickTime(UINT a0)
{
    _PrintEnter("SetDoubleClickTime(%p)\n", a0);

    BOOL rv = 0;
    __try {
        rv = Real_SetDoubleClickTime(a0);
    } __finally {
        _PrintExit("SetDoubleClickTime() -> %p\n", rv);
    };
    return rv;
}

BOOL __stdcall Mine_SetEndOfFile(HANDLE a0)
{
    _PrintEnter("SetEndOfFile(%p)\n", a0);

    BOOL rv = 0;
    __try {
        rv = Real_SetEndOfFile(a0);
    } __finally {
        _PrintExit("SetEndOfFile() -> %p\n", rv);
    };
    return rv;
}

HENHMETAFILE __stdcall Mine_SetEnhMetaFileBits(UINT a0,
                                               BYTE* a1)
{
    _PrintEnter("SetEnhMetaFileBits(%p,%p)\n", a0, a1);

    HENHMETAFILE rv = 0;
    __try {
        rv = Real_SetEnhMetaFileBits(a0, a1);
    } __finally {
        _PrintExit("SetEnhMetaFileBits(,) -> %p\n", rv);
    };
    return rv;
}

BOOL __stdcall Mine_SetEnvironmentVariableA(LPCSTR a0,
                                            LPCSTR a1)
{
    _PrintEnter("SetEnvironmentVariableA(%hs,%hs)\n", a0, a1);

    BOOL rv = 0;
    __try {
        rv = Real_SetEnvironmentVariableA(a0, a1);
    } __finally {
        _PrintExit("SetEnvironmentVariableA(,) -> %p\n", rv);
    };
    return rv;
}

BOOL __stdcall Mine_SetEnvironmentVariableW(LPCWSTR a0,
                                            LPCWSTR a1)
{
    _PrintEnter("SetEnvironmentVariableW(%ls,%ls)\n", a0, a1);

    BOOL rv = 0;
    __try {
        rv = Real_SetEnvironmentVariableW(a0, a1);
    } __finally {
        _PrintExit("SetEnvironmentVariableW(,) -> %p\n", rv);
    };
    return rv;
}

UINT __stdcall Mine_SetErrorMode(UINT a0)
{
    _PrintEnter("SetErrorMode(%p)\n", a0);

    UINT rv = 0;
    __try {
        rv = Real_SetErrorMode(a0);
    } __finally {
        _PrintExit("SetErrorMode() -> %p\n", rv);
    };
    return rv;
}

BOOL __stdcall Mine_SetEvent(HANDLE a0)
{
    _PrintEnter("SetEvent(%p)\n", a0);

    BOOL rv = 0;
    __try {
        rv = Real_SetEvent(a0);
    } __finally {
        _PrintExit("SetEvent() -> %p\n", rv);
    };
    return rv;
}

void __stdcall Mine_SetFileApisToANSI(void)
{
    _PrintEnter("SetFileApisToANSI()\n");

    __try {
        Real_SetFileApisToANSI();
    } __finally {
        _PrintExit("SetFileApisToANSI() ->\n");
    };
}

void __stdcall Mine_SetFileApisToOEM(void)
{
    _PrintEnter("SetFileApisToOEM()\n");

    __try {
        Real_SetFileApisToOEM();
    } __finally {
        _PrintExit("SetFileApisToOEM() ->\n");
    };
}

BOOL __stdcall Mine_SetFileAttributesA(LPCSTR a0,
                                       DWORD a1)
{
    _PrintEnter("SetFileAttributesA(%hs,%p)\n", a0, a1);

    BOOL rv = 0;
    __try {
        rv = Real_SetFileAttributesA(a0, a1);
    } __finally {
        _PrintExit("SetFileAttributesA(,) -> %p\n", rv);
    };
    return rv;
}

BOOL __stdcall Mine_SetFileAttributesW(LPCWSTR a0,
                                       DWORD a1)
{
    _PrintEnter("SetFileAttributesW(%ls,%p)\n", a0, a1);

    BOOL rv = 0;
    __try {
        rv = Real_SetFileAttributesW(a0, a1);
    } __finally {
        _PrintExit("SetFileAttributesW(,) -> %p\n", rv);
    };
    return rv;
}

DWORD __stdcall Mine_SetFilePointer(HANDLE a0,
                                    LONG a1,
                                    PLONG a2,
                                    DWORD a3)
{
    _PrintEnter("SetFilePointer(%p,%p,%p,%p)\n", a0, a1, a2, a3);

    DWORD rv = 0;
    __try {
        rv = Real_SetFilePointer(a0, a1, a2, a3);
    } __finally {
        _PrintExit("SetFilePointer(,,,) -> %p\n", rv);
    };
    return rv;
}

BOOL __stdcall Mine_SetFileTime(HANDLE a0,
                                FILETIME* a1,
                                FILETIME* a2,
                                FILETIME* a3)
{
    _PrintEnter("SetFileTime(%p,%p,%p,%p)\n", a0, a1, a2, a3);

    BOOL rv = 0;
    __try {
        rv = Real_SetFileTime(a0, a1, a2, a3);
    } __finally {
        _PrintExit("SetFileTime(,,,) -> %p\n", rv);
    };
    return rv;
}

HWND __stdcall Mine_SetFocus(HWND a0)
{
    _PrintEnter("SetFocus(%p)\n", a0);

    HWND rv = 0;
    __try {
        rv = Real_SetFocus(a0);
    } __finally {
        _PrintExit("SetFocus() -> %p\n", rv);
    };
    return rv;
}

BOOL __stdcall Mine_SetForegroundWindow(HWND a0)
{
    _PrintEnter("SetForegroundWindow(%p)\n", a0);

    BOOL rv = 0;
    __try {
        rv = Real_SetForegroundWindow(a0);
    } __finally {
        _PrintExit("SetForegroundWindow() -> %p\n", rv);
    };
    return rv;
}

int __stdcall Mine_SetGraphicsMode(HDC a0,
                                   int a1)
{
    _PrintEnter("SetGraphicsMode(%p,%p)\n", a0, a1);

    int rv = 0;
    __try {
        rv = Real_SetGraphicsMode(a0, a1);
    } __finally {
        _PrintExit("SetGraphicsMode(,) -> %p\n", rv);
    };
    return rv;
}

UINT __stdcall Mine_SetHandleCount(UINT a0)
{
    _PrintEnter("SetHandleCount(%p)\n", a0);

    UINT rv = 0;
    __try {
        rv = Real_SetHandleCount(a0);
    } __finally {
        _PrintExit("SetHandleCount() -> %p\n", rv);
    };
    return rv;
}

BOOL __stdcall Mine_SetHandleInformation(HANDLE a0,
                                         DWORD a1,
                                         DWORD a2)
{
    _PrintEnter("SetHandleInformation(%p,%p,%p)\n", a0, a1, a2);

    BOOL rv = 0;
    __try {
        rv = Real_SetHandleInformation(a0, a1, a2);
    } __finally {
        _PrintExit("SetHandleInformation(,,) -> %p\n", rv);
    };
    return rv;
}

int __stdcall Mine_SetICMMode(HDC a0,
                              int a1)
{
    _PrintEnter("SetICMMode(%p,%p)\n", a0, a1);

    int rv = 0;
    __try {
        rv = Real_SetICMMode(a0, a1);
    } __finally {
        _PrintExit("SetICMMode(,) -> %p\n", rv);
    };
    return rv;
}

BOOL __stdcall Mine_SetICMProfileA(HDC a0,
                                   LPSTR a1)
{
    _PrintEnter("SetICMProfileA(%p,%hs)\n", a0, a1);

    BOOL rv = 0;
    __try {
        rv = Real_SetICMProfileA(a0, a1);
    } __finally {
        _PrintExit("SetICMProfileA(,) -> %p\n", rv);
    };
    return rv;
}

BOOL __stdcall Mine_SetICMProfileW(HDC a0,
                                   LPWSTR a1)
{
    _PrintEnter("SetICMProfileW(%p,%ls)\n", a0, a1);

    BOOL rv = 0;
    __try {
        rv = Real_SetICMProfileW(a0, a1);
    } __finally {
        _PrintExit("SetICMProfileW(,) -> %p\n", rv);
    };
    return rv;
}

BOOL __stdcall Mine_SetKeyboardState(LPBYTE a0)
{
    _PrintEnter("SetKeyboardState(%p)\n", a0);

    BOOL rv = 0;
    __try {
        rv = Real_SetKeyboardState(a0);
    } __finally {
        _PrintExit("SetKeyboardState() -> %p\n", rv);
    };
    return rv;
}

BOOL __stdcall Mine_SetLocalTime(SYSTEMTIME* a0)
{
    _PrintEnter("SetLocalTime(%p)\n", a0);

    BOOL rv = 0;
    __try {
        rv = Real_SetLocalTime(a0);
    } __finally {
        _PrintExit("SetLocalTime() -> %p\n", rv);
    };
    return rv;
}

BOOL __stdcall Mine_SetLocaleInfoA(LCID a0,
                                   LCTYPE a1,
                                   LPCSTR a2)
{
    _PrintEnter("SetLocaleInfoA(%p,%p,%hs)\n", a0, a1, a2);

    BOOL rv = 0;
    __try {
        rv = Real_SetLocaleInfoA(a0, a1, a2);
    } __finally {
        _PrintExit("SetLocaleInfoA(,,) -> %p\n", rv);
    };
    return rv;
}

BOOL __stdcall Mine_SetLocaleInfoW(LCID a0,
                                   LCTYPE a1,
                                   LPCWSTR a2)
{
    _PrintEnter("SetLocaleInfoW(%p,%p,%ls)\n", a0, a1, a2);

    BOOL rv = 0;
    __try {
        rv = Real_SetLocaleInfoW(a0, a1, a2);
    } __finally {
        _PrintExit("SetLocaleInfoW(,,) -> %p\n", rv);
    };
    return rv;
}

BOOL __stdcall Mine_SetMailslotInfo(HANDLE a0,
                                    DWORD a1)
{
    _PrintEnter("SetMailslotInfo(%p,%p)\n", a0, a1);

    BOOL rv = 0;
    __try {
        rv = Real_SetMailslotInfo(a0, a1);
    } __finally {
        _PrintExit("SetMailslotInfo(,) -> %p\n", rv);
    };
    return rv;
}

int __stdcall Mine_SetMapMode(HDC a0,
                              int a1)
{
    _PrintEnter("SetMapMode(%p,%p)\n", a0, a1);

    int rv = 0;
    __try {
        rv = Real_SetMapMode(a0, a1);
    } __finally {
        _PrintExit("SetMapMode(,) -> %p\n", rv);
    };
    return rv;
}

DWORD __stdcall Mine_SetMapperFlags(HDC a0,
                                    DWORD a1)
{
    _PrintEnter("SetMapperFlags(%p,%p)\n", a0, a1);

    DWORD rv = 0;
    __try {
        rv = Real_SetMapperFlags(a0, a1);
    } __finally {
        _PrintExit("SetMapperFlags(,) -> %p\n", rv);
    };
    return rv;
}

BOOL __stdcall Mine_SetMenu(HWND a0,
                            HMENU a1)
{
    _PrintEnter("SetMenu(%p,%p)\n", a0, a1);

    BOOL rv = 0;
    __try {
        rv = Real_SetMenu(a0, a1);
    } __finally {
        _PrintExit("SetMenu(,) -> %p\n", rv);
    };
    return rv;
}

BOOL __stdcall Mine_SetMenuContextHelpId(HMENU a0,
                                         DWORD a1)
{
    _PrintEnter("SetMenuContextHelpId(%p,%p)\n", a0, a1);

    BOOL rv = 0;
    __try {
        rv = Real_SetMenuContextHelpId(a0, a1);
    } __finally {
        _PrintExit("SetMenuContextHelpId(,) -> %p\n", rv);
    };
    return rv;
}

BOOL __stdcall Mine_SetMenuDefaultItem(HMENU a0,
                                       UINT a1,
                                       UINT a2)
{
    _PrintEnter("SetMenuDefaultItem(%p,%p,%p)\n", a0, a1, a2);

    BOOL rv = 0;
    __try {
        rv = Real_SetMenuDefaultItem(a0, a1, a2);
    } __finally {
        _PrintExit("SetMenuDefaultItem(,,) -> %p\n", rv);
    };
    return rv;
}

BOOL __stdcall Mine_SetMenuItemBitmaps(HMENU a0,
                                       UINT a1,
                                       UINT a2,
                                       HBITMAP a3,
                                       HBITMAP a4)
{
    _PrintEnter("SetMenuItemBitmaps(%p,%p,%p,%p,%p)\n", a0, a1, a2, a3, a4);

    BOOL rv = 0;
    __try {
        rv = Real_SetMenuItemBitmaps(a0, a1, a2, a3, a4);
    } __finally {
        _PrintExit("SetMenuItemBitmaps(,,,,) -> %p\n", rv);
    };
    return rv;
}

BOOL __stdcall Mine_SetMenuItemInfoA(HMENU a0,
                                     UINT a1,
                                     BOOL a2,
                                     MENUITEMINFOA* a3)
{
    _PrintEnter("SetMenuItemInfoA(%p,%p,%p,%p)\n", a0, a1, a2, a3);

    BOOL rv = 0;
    __try {
        rv = Real_SetMenuItemInfoA(a0, a1, a2, a3);
    } __finally {
        _PrintExit("SetMenuItemInfoA(,,,) -> %p\n", rv);
    };
    return rv;
}

BOOL __stdcall Mine_SetMenuItemInfoW(HMENU a0,
                                     UINT a1,
                                     BOOL a2,
                                     MENUITEMINFOW* a3)
{
    _PrintEnter("SetMenuItemInfoW(%p,%p,%p,%p)\n", a0, a1, a2, a3);

    BOOL rv = 0;
    __try {
        rv = Real_SetMenuItemInfoW(a0, a1, a2, a3);
    } __finally {
        _PrintExit("SetMenuItemInfoW(,,,) -> %p\n", rv);
    };
    return rv;
}

LPARAM __stdcall Mine_SetMessageExtraInfo(LPARAM a0)
{
    _PrintEnter("SetMessageExtraInfo(%p)\n", a0);

    LPARAM rv = 0;
    __try {
        rv = Real_SetMessageExtraInfo(a0);
    } __finally {
        _PrintExit("SetMessageExtraInfo() -> %p\n", rv);
    };
    return rv;
}

BOOL __stdcall Mine_SetMessageQueue(int a0)
{
    _PrintEnter("SetMessageQueue(%p)\n", a0);

    BOOL rv = 0;
    __try {
        rv = Real_SetMessageQueue(a0);
    } __finally {
        _PrintExit("SetMessageQueue() -> %p\n", rv);
    };
    return rv;
}

HMETAFILE __stdcall Mine_SetMetaFileBitsEx(UINT a0,
                                           BYTE* a1)
{
    _PrintEnter("SetMetaFileBitsEx(%p,%p)\n", a0, a1);

    HMETAFILE rv = 0;
    __try {
        rv = Real_SetMetaFileBitsEx(a0, a1);
    } __finally {
        _PrintExit("SetMetaFileBitsEx(,) -> %p\n", rv);
    };
    return rv;
}

int __stdcall Mine_SetMetaRgn(HDC a0)
{
    _PrintEnter("SetMetaRgn(%p)\n", a0);

    int rv = 0;
    __try {
        rv = Real_SetMetaRgn(a0);
    } __finally {
        _PrintExit("SetMetaRgn() -> %p\n", rv);
    };
    return rv;
}

BOOL __stdcall Mine_SetMiterLimit(HDC a0,
                                  FLOAT a1,
                                  PFLOAT a2)
{
    _PrintEnter("SetMiterLimit(%p,%p,%p)\n", a0, a1, a2);

    BOOL rv = 0;
    __try {
        rv = Real_SetMiterLimit(a0, a1, a2);
    } __finally {
        _PrintExit("SetMiterLimit(,,) -> %p\n", rv);
    };
    return rv;
}

BOOL __stdcall Mine_SetNamedPipeHandleState(HANDLE a0,
                                            LPDWORD a1,
                                            LPDWORD a2,
                                            LPDWORD a3)
{
    _PrintEnter("SetNamedPipeHandleState(%p,%p,%p,%p)\n", a0, a1, a2, a3);

    BOOL rv = 0;
    __try {
        rv = Real_SetNamedPipeHandleState(a0, a1, a2, a3);
    } __finally {
        _PrintExit("SetNamedPipeHandleState(,,,) -> %p\n", rv);
    };
    return rv;
}

UINT __stdcall Mine_SetPaletteEntries(HPALETTE a0,
                                      UINT a1,
                                      UINT a2,
                                      PALETTEENTRY* a3)
{
    _PrintEnter("SetPaletteEntries(%p,%p,%p,%p)\n", a0, a1, a2, a3);

    UINT rv = 0;
    __try {
        rv = Real_SetPaletteEntries(a0, a1, a2, a3);
    } __finally {
        _PrintExit("SetPaletteEntries(,,,) -> %p\n", rv);
    };
    return rv;
}

HWND __stdcall Mine_SetParent(HWND a0,
                              HWND a1)
{
    _PrintEnter("SetParent(%p,%p)\n", a0, a1);

    HWND rv = 0;
    __try {
        rv = Real_SetParent(a0, a1);
    } __finally {
        _PrintExit("SetParent(,) -> %p\n", rv);
    };
    return rv;
}

COLORREF __stdcall Mine_SetPixel(HDC a0,
                                 int a1,
                                 int a2,
                                 COLORREF a3)
{
    _PrintEnter("SetPixel(%p,%p,%p,%p)\n", a0, a1, a2, a3);

    COLORREF rv = 0;
    __try {
        rv = Real_SetPixel(a0, a1, a2, a3);
    } __finally {
        _PrintExit("SetPixel(,,,) -> %p\n", rv);
    };
    return rv;
}

BOOL __stdcall Mine_SetPixelFormat(HDC a0,
                                   int a1,
                                   PIXELFORMATDESCRIPTOR* a2)
{
    _PrintEnter("SetPixelFormat(%p,%p,%p)\n", a0, a1, a2);

    BOOL rv = 0;
    __try {
        rv = Real_SetPixelFormat(a0, a1, a2);
    } __finally {
        _PrintExit("SetPixelFormat(,,) -> %p\n", rv);
    };
    return rv;
}

BOOL __stdcall Mine_SetPixelV(HDC a0,
                              int a1,
                              int a2,
                              COLORREF a3)
{
    _PrintEnter("SetPixelV(%p,%p,%p,%p)\n", a0, a1, a2, a3);

    BOOL rv = 0;
    __try {
        rv = Real_SetPixelV(a0, a1, a2, a3);
    } __finally {
        _PrintExit("SetPixelV(,,,) -> %p\n", rv);
    };
    return rv;
}

int __stdcall Mine_SetPolyFillMode(HDC a0,
                                   int a1)
{
    _PrintEnter("SetPolyFillMode(%p,%p)\n", a0, a1);

    int rv = 0;
    __try {
        rv = Real_SetPolyFillMode(a0, a1);
    } __finally {
        _PrintExit("SetPolyFillMode(,) -> %p\n", rv);
    };
    return rv;
}

BOOL __stdcall Mine_SetPriorityClass(HANDLE a0,
                                     DWORD a1)
{
    _PrintEnter("SetPriorityClass(%p,%p)\n", a0, a1);

    BOOL rv = 0;
    __try {
        rv = Real_SetPriorityClass(a0, a1);
    } __finally {
        _PrintExit("SetPriorityClass(,) -> %p\n", rv);
    };
    return rv;
}

BOOL __stdcall Mine_SetProcessAffinityMask(HANDLE a0,
                                           DWORD_PTR a1)
{
    _PrintEnter("SetProcessAffinityMask(%p,%p)\n", a0, a1);

    BOOL rv = 0;
    __try {
        rv = Real_SetProcessAffinityMask(a0, a1);
    } __finally {
        _PrintExit("SetProcessAffinityMask(,) -> %p\n", rv);
    };
    return rv;
}

BOOL __stdcall Mine_SetProcessShutdownParameters(DWORD a0,
                                                 DWORD a1)
{
    _PrintEnter("SetProcessShutdownParameters(%p,%p)\n", a0, a1);

    BOOL rv = 0;
    __try {
        rv = Real_SetProcessShutdownParameters(a0, a1);
    } __finally {
        _PrintExit("SetProcessShutdownParameters(,) -> %p\n", rv);
    };
    return rv;
}

BOOL __stdcall Mine_SetProcessWindowStation(HWINSTA a0)
{
    _PrintEnter("SetProcessWindowStation(%p)\n", a0);

    BOOL rv = 0;
    __try {
        rv = Real_SetProcessWindowStation(a0);
    } __finally {
        _PrintExit("SetProcessWindowStation() -> %p\n", rv);
    };
    return rv;
}

BOOL __stdcall Mine_SetProcessWorkingSetSize(HANDLE a0,
                                             SIZE_T a1,
                                             SIZE_T a2)
{
    _PrintEnter("SetProcessWorkingSetSize(%p,%p,%p)\n", a0, a1, a2);

    BOOL rv = 0;
    __try {
        rv = Real_SetProcessWorkingSetSize(a0, a1, a2);
    } __finally {
        _PrintExit("SetProcessWorkingSetSize(,,) -> %p\n", rv);
    };
    return rv;
}

BOOL __stdcall Mine_SetPropA(HWND a0,
                             LPCSTR a1,
                             HANDLE a2)
{
    _PrintEnter("SetPropA(%p,%hs,%p)\n", a0, a1, a2);

    BOOL rv = 0;
    __try {
        rv = Real_SetPropA(a0, a1, a2);
    } __finally {
        _PrintExit("SetPropA(,,) -> %p\n", rv);
    };
    return rv;
}

BOOL __stdcall Mine_SetPropW(HWND a0,
                             LPCWSTR a1,
                             HANDLE a2)
{
    _PrintEnter("SetPropW(%p,%ls,%p)\n", a0, a1, a2);

    BOOL rv = 0;
    __try {
        rv = Real_SetPropW(a0, a1, a2);
    } __finally {
        _PrintExit("SetPropW(,,) -> %p\n", rv);
    };
    return rv;
}

int __stdcall Mine_SetROP2(HDC a0,
                           int a1)
{
    _PrintEnter("SetROP2(%p,%p)\n", a0, a1);

    int rv = 0;
    __try {
        rv = Real_SetROP2(a0, a1);
    } __finally {
        _PrintExit("SetROP2(,) -> %p\n", rv);
    };
    return rv;
}

BOOL __stdcall Mine_SetRect(LPRECT a0,
                            int a1,
                            int a2,
                            int a3,
                            int a4)
{
    _PrintEnter("SetRect(%p,%p,%p,%p,%p)\n", a0, a1, a2, a3, a4);

    BOOL rv = 0;
    __try {
        rv = Real_SetRect(a0, a1, a2, a3, a4);
    } __finally {
        _PrintExit("SetRect(,,,,) -> %p\n", rv);
    };
    return rv;
}

BOOL __stdcall Mine_SetRectEmpty(LPRECT a0)
{
    _PrintEnter("SetRectEmpty(%p)\n", a0);

    BOOL rv = 0;
    __try {
        rv = Real_SetRectEmpty(a0);
    } __finally {
        _PrintExit("SetRectEmpty() -> %p\n", rv);
    };
    return rv;
}

BOOL __stdcall Mine_SetRectRgn(HRGN a0,
                               int a1,
                               int a2,
                               int a3,
                               int a4)
{
    _PrintEnter("SetRectRgn(%p,%p,%p,%p,%p)\n", a0, a1, a2, a3, a4);

    BOOL rv = 0;
    __try {
        rv = Real_SetRectRgn(a0, a1, a2, a3, a4);
    } __finally {
        _PrintExit("SetRectRgn(,,,,) -> %p\n", rv);
    };
    return rv;
}

int __stdcall Mine_SetScrollInfo(HWND a0,
                                 int a1,
                                 LPCSCROLLINFO a2,
                                 BOOL a3)
{
    _PrintEnter("SetScrollInfo(%p,%p,%p,%p)\n", a0, a1, a2, a3);

    int rv = 0;
    __try {
        rv = Real_SetScrollInfo(a0, a1, a2, a3);
    } __finally {
        _PrintExit("SetScrollInfo(,,,) -> %p\n", rv);
    };
    return rv;
}

int __stdcall Mine_SetScrollPos(HWND a0,
                                int a1,
                                int a2,
                                BOOL a3)
{
    _PrintEnter("SetScrollPos(%p,%p,%p,%p)\n", a0, a1, a2, a3);

    int rv = 0;
    __try {
        rv = Real_SetScrollPos(a0, a1, a2, a3);
    } __finally {
        _PrintExit("SetScrollPos(,,,) -> %p\n", rv);
    };
    return rv;
}

BOOL __stdcall Mine_SetScrollRange(HWND a0,
                                   int a1,
                                   int a2,
                                   int a3,
                                   BOOL a4)
{
    _PrintEnter("SetScrollRange(%p,%p,%p,%p,%p)\n", a0, a1, a2, a3, a4);

    BOOL rv = 0;
    __try {
        rv = Real_SetScrollRange(a0, a1, a2, a3, a4);
    } __finally {
        _PrintExit("SetScrollRange(,,,,) -> %p\n", rv);
    };
    return rv;
}

BOOL __stdcall Mine_SetStdHandle(DWORD a0,
                                 HANDLE a1)
{
    _PrintEnter("SetStdHandle(%p,%p)\n", a0, a1);

    BOOL rv = 0;
    __try {
        rv = Real_SetStdHandle(a0, a1);
    } __finally {
        _PrintExit("SetStdHandle(,) -> %p\n", rv);
    };
    return rv;
}

int __stdcall Mine_SetStretchBltMode(HDC a0,
                                     int a1)
{
    _PrintEnter("SetStretchBltMode(%p,%p)\n", a0, a1);

    int rv = 0;
    __try {
        rv = Real_SetStretchBltMode(a0, a1);
    } __finally {
        _PrintExit("SetStretchBltMode(,) -> %p\n", rv);
    };
    return rv;
}

BOOL __stdcall Mine_SetSysColors(int a0,
                                 INT* a1,
                                 COLORREF* a2)
{
    _PrintEnter("SetSysColors(%p,%p,%p)\n", a0, a1, a2);

    BOOL rv = 0;
    __try {
        rv = Real_SetSysColors(a0, a1, a2);
    } __finally {
        _PrintExit("SetSysColors(,,) -> %p\n", rv);
    };
    return rv;
}

BOOL __stdcall Mine_SetSystemCursor(HCURSOR a0,
                                    DWORD a1)
{
    _PrintEnter("SetSystemCursor(%p,%p)\n", a0, a1);

    BOOL rv = 0;
    __try {
        rv = Real_SetSystemCursor(a0, a1);
    } __finally {
        _PrintExit("SetSystemCursor(,) -> %p\n", rv);
    };
    return rv;
}

UINT __stdcall Mine_SetSystemPaletteUse(HDC a0,
                                        UINT a1)
{
    _PrintEnter("SetSystemPaletteUse(%p,%p)\n", a0, a1);

    UINT rv = 0;
    __try {
        rv = Real_SetSystemPaletteUse(a0, a1);
    } __finally {
        _PrintExit("SetSystemPaletteUse(,) -> %p\n", rv);
    };
    return rv;
}

BOOL __stdcall Mine_SetSystemPowerState(BOOL a0,
                                        BOOL a1)
{
    _PrintEnter("SetSystemPowerState(%p,%p)\n", a0, a1);

    BOOL rv = 0;
    __try {
        rv = Real_SetSystemPowerState(a0, a1);
    } __finally {
        _PrintExit("SetSystemPowerState(,) -> %p\n", rv);
    };
    return rv;
}

BOOL __stdcall Mine_SetSystemTime(SYSTEMTIME* a0)
{
    _PrintEnter("SetSystemTime(%p)\n", a0);

    BOOL rv = 0;
    __try {
        rv = Real_SetSystemTime(a0);
    } __finally {
        _PrintExit("SetSystemTime() -> %p\n", rv);
    };
    return rv;
}

BOOL __stdcall Mine_SetSystemTimeAdjustment(DWORD a0,
                                            BOOL a1)
{
    _PrintEnter("SetSystemTimeAdjustment(%p,%p)\n", a0, a1);

    BOOL rv = 0;
    __try {
        rv = Real_SetSystemTimeAdjustment(a0, a1);
    } __finally {
        _PrintExit("SetSystemTimeAdjustment(,) -> %p\n", rv);
    };
    return rv;
}

DWORD __stdcall Mine_SetTapeParameters(HANDLE a0,
                                       DWORD a1,
                                       LPVOID a2)
{
    _PrintEnter("SetTapeParameters(%p,%p,%p)\n", a0, a1, a2);

    DWORD rv = 0;
    __try {
        rv = Real_SetTapeParameters(a0, a1, a2);
    } __finally {
        _PrintExit("SetTapeParameters(,,) -> %p\n", rv);
    };
    return rv;
}

DWORD __stdcall Mine_SetTapePosition(HANDLE a0,
                                     DWORD a1,
                                     DWORD a2,
                                     DWORD a3,
                                     DWORD a4,
                                     BOOL a5)
{
    _PrintEnter("SetTapePosition(%p,%p,%p,%p,%p,%p)\n", a0, a1, a2, a3, a4, a5);

    DWORD rv = 0;
    __try {
        rv = Real_SetTapePosition(a0, a1, a2, a3, a4, a5);
    } __finally {
        _PrintExit("SetTapePosition(,,,,,) -> %p\n", rv);
    };
    return rv;
}

UINT __stdcall Mine_SetTextAlign(HDC a0,
                                 UINT a1)
{
    _PrintEnter("SetTextAlign(%p,%p)\n", a0, a1);

    UINT rv = 0;
    __try {
        rv = Real_SetTextAlign(a0, a1);
    } __finally {
        _PrintExit("SetTextAlign(,) -> %p\n", rv);
    };
    return rv;
}

int __stdcall Mine_SetTextCharacterExtra(HDC a0,
                                         int a1)
{
    _PrintEnter("SetTextCharacterExtra(%p,%p)\n", a0, a1);

    int rv = 0;
    __try {
        rv = Real_SetTextCharacterExtra(a0, a1);
    } __finally {
        _PrintExit("SetTextCharacterExtra(,) -> %p\n", rv);
    };
    return rv;
}

COLORREF __stdcall Mine_SetTextColor(HDC a0,
                                     COLORREF a1)
{
    _PrintEnter("SetTextColor(%p,%p)\n", a0, a1);

    COLORREF rv = 0;
    __try {
        rv = Real_SetTextColor(a0, a1);
    } __finally {
        _PrintExit("SetTextColor(,) -> %p\n", rv);
    };
    return rv;
}

BOOL __stdcall Mine_SetTextJustification(HDC a0,
                                         int a1,
                                         int a2)
{
    _PrintEnter("SetTextJustification(%p,%p,%p)\n", a0, a1, a2);

    BOOL rv = 0;
    __try {
        rv = Real_SetTextJustification(a0, a1, a2);
    } __finally {
        _PrintExit("SetTextJustification(,,) -> %p\n", rv);
    };
    return rv;
}

DWORD_PTR __stdcall Mine_SetThreadAffinityMask(HANDLE a0,
                                           DWORD_PTR a1)
{
    _PrintEnter("SetThreadAffinityMask(%p,%p)\n", a0, a1);

    DWORD_PTR rv = 0;
    __try {
        rv = Real_SetThreadAffinityMask(a0, a1);
    } __finally {
        _PrintExit("SetThreadAffinityMask(,) -> %p\n", rv);
    };
    return rv;
}

BOOL __stdcall Mine_SetThreadContext(HANDLE a0,
                                     CONTEXT* a1)
{
    _PrintEnter("SetThreadContext(%p,%p)\n", a0, a1);

    BOOL rv = 0;
    __try {
        rv = Real_SetThreadContext(a0, a1);
    } __finally {
        _PrintExit("SetThreadContext(,) -> %p\n", rv);
    };
    return rv;
}

BOOL __stdcall Mine_SetThreadDesktop(HDESK a0)
{
    _PrintEnter("SetThreadDesktop(%p)\n", a0);

    BOOL rv = 0;
    __try {
        rv = Real_SetThreadDesktop(a0);
    } __finally {
        _PrintExit("SetThreadDesktop() -> %p\n", rv);
    };
    return rv;
}

DWORD __stdcall Mine_SetThreadIdealProcessor(HANDLE a0,
                                             DWORD a1)
{
    _PrintEnter("SetThreadIdealProcessor(%p,%p)\n", a0, a1);

    DWORD rv = 0;
    __try {
        rv = Real_SetThreadIdealProcessor(a0, a1);
    } __finally {
        _PrintExit("SetThreadIdealProcessor(,) -> %p\n", rv);
    };
    return rv;
}

#if(WINVER >= 0x0500)
BOOL __stdcall Mine_SetThreadLocale(LCID a0)
{
    _PrintEnter("SetThreadLocale(%p)\n", a0);

    BOOL rv = 0;
    __try {
        rv = Real_SetThreadLocale(a0);
    } __finally {
        _PrintExit("SetThreadLocale() -> %p\n", rv);
    };
    return rv;
}
#endif // (WINVER >= 0x0500)

BOOL __stdcall Mine_SetThreadPriority(HANDLE a0,
                                      int a1)
{
    _PrintEnter("SetThreadPriority(%p,%p)\n", a0, a1);

    BOOL rv = 0;
    __try {
        rv = Real_SetThreadPriority(a0, a1);
    } __finally {
        _PrintExit("SetThreadPriority(,) -> %p\n", rv);
    };
    return rv;
}

BOOL __stdcall Mine_SetThreadPriorityBoost(HANDLE a0,
                                           BOOL a1)
{
    _PrintEnter("SetThreadPriorityBoost(%p,%p)\n", a0, a1);

    BOOL rv = 0;
    __try {
        rv = Real_SetThreadPriorityBoost(a0, a1);
    } __finally {
        _PrintExit("SetThreadPriorityBoost(,) -> %p\n", rv);
    };
    return rv;
}

BOOL __stdcall Mine_SetTimeZoneInformation(TIME_ZONE_INFORMATION* a0)
{
    _PrintEnter("SetTimeZoneInformation(%p)\n", a0);

    BOOL rv = 0;
    __try {
        rv = Real_SetTimeZoneInformation(a0);
    } __finally {
        _PrintExit("SetTimeZoneInformation() -> %p\n", rv);
    };
    return rv;
}

UINT_PTR __stdcall Mine_SetTimer(HWND a0,
                                 UINT_PTR a1,
                                 UINT a2,
                                 TIMERPROC a3)
{
    _PrintEnter("SetTimer(%p,%p,%p,%p)\n", a0, a1, a2, a3);

    UINT_PTR rv = 0;
    __try {
        rv = Real_SetTimer(a0, a1, a2, a3);
    } __finally {
        _PrintExit("SetTimer(,,,) -> %p\n", rv);
    };
    return rv;
}

LPTOP_LEVEL_EXCEPTION_FILTER __stdcall Mine_SetUnhandledExceptionFilter(LPTOP_LEVEL_EXCEPTION_FILTER a0)
{
    _PrintEnter("SetUnhandledExceptionFilter(%p)\n", a0);

    LPTOP_LEVEL_EXCEPTION_FILTER rv = 0;
    __try {
        rv = Real_SetUnhandledExceptionFilter(a0);
    } __finally {
        _PrintExit("SetUnhandledExceptionFilter() -> %p\n", rv);
    };
    return rv;
}

BOOL __stdcall Mine_SetUserObjectInformationA(HANDLE a0,
                                              int a1,
                                              PVOID a2,
                                              DWORD a3)
{
    _PrintEnter("SetUserObjectInformationA(%p,%p,%p,%p)\n", a0, a1, a2, a3);

    BOOL rv = 0;
    __try {
        rv = Real_SetUserObjectInformationA(a0, a1, a2, a3);
    } __finally {
        _PrintExit("SetUserObjectInformationA(,,,) -> %p\n", rv);
    };
    return rv;
}

BOOL __stdcall Mine_SetUserObjectInformationW(HANDLE a0,
                                              int a1,
                                              PVOID a2,
                                              DWORD a3)
{
    _PrintEnter("SetUserObjectInformationW(%p,%p,%p,%p)\n", a0, a1, a2, a3);

    BOOL rv = 0;
    __try {
        rv = Real_SetUserObjectInformationW(a0, a1, a2, a3);
    } __finally {
        _PrintExit("SetUserObjectInformationW(,,,) -> %p\n", rv);
    };
    return rv;
}

BOOL __stdcall Mine_SetUserObjectSecurity(HANDLE a0,
                                          PSECURITY_INFORMATION a1,
                                          PSECURITY_DESCRIPTOR a2)
{
    _PrintEnter("SetUserObjectSecurity(%p,%p,%p)\n", a0, a1, a2);

    BOOL rv = 0;
    __try {
        rv = Real_SetUserObjectSecurity(a0, a1, a2);
    } __finally {
        _PrintExit("SetUserObjectSecurity(,,) -> %p\n", rv);
    };
    return rv;
}

BOOL __stdcall Mine_SetViewportExtEx(HDC a0,
                                     int a1,
                                     int a2,
                                     SIZE* a3)
{
    _PrintEnter("SetViewportExtEx(%p,%p,%p,%p)\n", a0, a1, a2, a3);

    BOOL rv = 0;
    __try {
        rv = Real_SetViewportExtEx(a0, a1, a2, a3);
    } __finally {
        _PrintExit("SetViewportExtEx(,,,) -> %p\n", rv);
    };
    return rv;
}

BOOL __stdcall Mine_SetViewportOrgEx(HDC a0,
                                     int a1,
                                     int a2,
                                     POINT* a3)
{
    _PrintEnter("SetViewportOrgEx(%p,%p,%p,%p)\n", a0, a1, a2, a3);

    BOOL rv = 0;
    __try {
        rv = Real_SetViewportOrgEx(a0, a1, a2, a3);
    } __finally {
        _PrintExit("SetViewportOrgEx(,,,) -> %p\n", rv);
    };
    return rv;
}

BOOL __stdcall Mine_SetVolumeLabelA(LPCSTR a0,
                                    LPCSTR a1)
{
    _PrintEnter("SetVolumeLabelA(%hs,%hs)\n", a0, a1);

    BOOL rv = 0;
    __try {
        rv = Real_SetVolumeLabelA(a0, a1);
    } __finally {
        _PrintExit("SetVolumeLabelA(,) -> %p\n", rv);
    };
    return rv;
}

BOOL __stdcall Mine_SetVolumeLabelW(LPCWSTR a0,
                                    LPCWSTR a1)
{
    _PrintEnter("SetVolumeLabelW(%ls,%ls)\n", a0, a1);

    BOOL rv = 0;
    __try {
        rv = Real_SetVolumeLabelW(a0, a1);
    } __finally {
        _PrintExit("SetVolumeLabelW(,) -> %p\n", rv);
    };
    return rv;
}

BOOL __stdcall Mine_SetWaitableTimer(HANDLE a0,
                                     LARGE_INTEGER* a1,
                                     LONG a2,
                                     PTIMERAPCROUTINE a3,
                                     LPVOID a4,
                                     BOOL a5)
{
    _PrintEnter("SetWaitableTimer(%p,%p,%p,%p,%p,%p)\n", a0, a1, a2, a3, a4, a5);

    BOOL rv = 0;
    __try {
        rv = Real_SetWaitableTimer(a0, a1, a2, a3, a4, a5);
    } __finally {
        _PrintExit("SetWaitableTimer(,,,,,) -> %p\n", rv);
    };
    return rv;
}

HENHMETAFILE __stdcall Mine_SetWinMetaFileBits(UINT a0,
                                               BYTE* a1,
                                               HDC a2,
                                               METAFILEPICT* a3)
{
    _PrintEnter("SetWinMetaFileBits(%p,%p,%p,%p)\n", a0, a1, a2, a3);

    HENHMETAFILE rv = 0;
    __try {
        rv = Real_SetWinMetaFileBits(a0, a1, a2, a3);
    } __finally {
        _PrintExit("SetWinMetaFileBits(,,,) -> %p\n", rv);
    };
    return rv;
}

BOOL __stdcall Mine_SetWindowContextHelpId(HWND a0,
                                           DWORD a1)
{
    _PrintEnter("SetWindowContextHelpId(%p,%p)\n", a0, a1);

    BOOL rv = 0;
    __try {
        rv = Real_SetWindowContextHelpId(a0, a1);
    } __finally {
        _PrintExit("SetWindowContextHelpId(,) -> %p\n", rv);
    };
    return rv;
}

BOOL __stdcall Mine_SetWindowExtEx(HDC a0,
                                   int a1,
                                   int a2,
                                   SIZE* a3)
{
    _PrintEnter("SetWindowExtEx(%p,%p,%p,%p)\n", a0, a1, a2, a3);

    BOOL rv = 0;
    __try {
        rv = Real_SetWindowExtEx(a0, a1, a2, a3);
    } __finally {
        _PrintExit("SetWindowExtEx(,,,) -> %p\n", rv);
    };
    return rv;
}

LONG __stdcall Mine_SetWindowLongA(HWND a0,
                                   int a1,
                                   LONG a2)
{
    _PrintEnter("SetWindowLongA(%p,%p,%p)\n", a0, a1, a2);

    LONG rv = 0;
    __try {
        rv = Real_SetWindowLongA(a0, a1, a2);
    } __finally {
        _PrintExit("SetWindowLongA(,,) -> %p\n", rv);
    };
    return rv;
}

LONG __stdcall Mine_SetWindowLongW(HWND a0,
                                   int a1,
                                   LONG a2)
{
    _PrintEnter("SetWindowLongW(%p,%p,%p)\n", a0, a1, a2);

    LONG rv = 0;
    __try {
        rv = Real_SetWindowLongW(a0, a1, a2);
    } __finally {
        _PrintExit("SetWindowLongW(,,) -> %p\n", rv);
    };
    return rv;
}

BOOL __stdcall Mine_SetWindowOrgEx(HDC a0,
                                   int a1,
                                   int a2,
                                   POINT* a3)
{
    _PrintEnter("SetWindowOrgEx(%p,%p,%p,%p)\n", a0, a1, a2, a3);

    BOOL rv = 0;
    __try {
        rv = Real_SetWindowOrgEx(a0, a1, a2, a3);
    } __finally {
        _PrintExit("SetWindowOrgEx(,,,) -> %p\n", rv);
    };
    return rv;
}

BOOL __stdcall Mine_SetWindowPlacement(HWND a0,
                                       WINDOWPLACEMENT* a1)
{
    _PrintEnter("SetWindowPlacement(%p,%p)\n", a0, a1);

    BOOL rv = 0;
    __try {
        rv = Real_SetWindowPlacement(a0, a1);
    } __finally {
        _PrintExit("SetWindowPlacement(,) -> %p\n", rv);
    };
    return rv;
}

BOOL __stdcall Mine_SetWindowPos(HWND a0,
                                 HWND a1,
                                 int a2,
                                 int a3,
                                 int a4,
                                 int a5,
                                 UINT a6)
{
    _PrintEnter("SetWindowPos(%p,%p,%p,%p,%p,%p,%p)\n", a0, a1, a2, a3, a4, a5, a6);

    BOOL rv = 0;
    __try {
        rv = Real_SetWindowPos(a0, a1, a2, a3, a4, a5, a6);
    } __finally {
        _PrintExit("SetWindowPos(,,,,,,) -> %p\n", rv);
    };
    return rv;
}

int __stdcall Mine_SetWindowRgn(HWND a0,
                                HRGN a1,
                                BOOL a2)
{
    _PrintEnter("SetWindowRgn(%p,%p,%p)\n", a0, a1, a2);

    int rv = 0;
    __try {
        rv = Real_SetWindowRgn(a0, a1, a2);
    } __finally {
        _PrintExit("SetWindowRgn(,,) -> %p\n", rv);
    };
    return rv;
}

BOOL __stdcall Mine_SetWindowTextA(HWND a0,
                                   LPCSTR a1)
{
    _PrintEnter("SetWindowTextA(%p,%hs)\n", a0, a1);

    BOOL rv = 0;
    __try {
        rv = Real_SetWindowTextA(a0, a1);
    } __finally {
        _PrintExit("SetWindowTextA(,) -> %p\n", rv);
    };
    return rv;
}

BOOL __stdcall Mine_SetWindowTextW(HWND a0,
                                   LPCWSTR a1)
{
    _PrintEnter("SetWindowTextW(%p,%ls)\n", a0, a1);

    BOOL rv = 0;
    __try {
        rv = Real_SetWindowTextW(a0, a1);
    } __finally {
        _PrintExit("SetWindowTextW(,) -> %p\n", rv);
    };
    return rv;
}

WORD __stdcall Mine_SetWindowWord(HWND a0,
                                  int a1,
                                  WORD a2)
{
    _PrintEnter("SetWindowWord(%p,%p,%p)\n", a0, a1, a2);

    WORD rv = 0;
    __try {
        rv = Real_SetWindowWord(a0, a1, a2);
    } __finally {
        _PrintExit("SetWindowWord(,,) -> %p\n", rv);
    };
    return rv;
}

HHOOK __stdcall Mine_SetWindowsHookA(int a0,
                                     HOOKPROC a1)
{
    _PrintEnter("SetWindowsHookA(%p,%p)\n", a0, a1);

    HHOOK rv = 0;
    __try {
        rv = Real_SetWindowsHookA(a0, a1);
    } __finally {
        _PrintExit("SetWindowsHookA(,) -> %p\n", rv);
    };
    return rv;
}

HHOOK __stdcall Mine_SetWindowsHookExA(int a0,
                                       HOOKPROC a1,
                                       HINSTANCE a2,
                                       DWORD a3)
{
    _PrintEnter("SetWindowsHookExA(%p,%p,%p,%p)\n", a0, a1, a2, a3);

    HHOOK rv = 0;
    __try {
        rv = Real_SetWindowsHookExA(a0, a1, a2, a3);
    } __finally {
        _PrintExit("SetWindowsHookExA(,,,) -> %p\n", rv);
    };
    return rv;
}

HHOOK __stdcall Mine_SetWindowsHookExW(int a0,
                                       HOOKPROC a1,
                                       HINSTANCE a2,
                                       DWORD a3)
{
    _PrintEnter("SetWindowsHookExW(%p,%p,%p,%p)\n", a0, a1, a2, a3);

    HHOOK rv = 0;
    __try {
        rv = Real_SetWindowsHookExW(a0, a1, a2, a3);
    } __finally {
        _PrintExit("SetWindowsHookExW(,,,) -> %p\n", rv);
    };
    return rv;
}

HHOOK __stdcall Mine_SetWindowsHookW(int a0,
                                     HOOKPROC a1)
{
    _PrintEnter("SetWindowsHookW(%p,%p)\n", a0, a1);

    HHOOK rv = 0;
    __try {
        rv = Real_SetWindowsHookW(a0, a1);
    } __finally {
        _PrintExit("SetWindowsHookW(,) -> %p\n", rv);
    };
    return rv;
}

BOOL __stdcall Mine_SetWorldTransform(HDC a0,
                                      XFORM* a1)
{
    _PrintEnter("SetWorldTransform(%p,%p)\n", a0, a1);

    BOOL rv = 0;
    __try {
        rv = Real_SetWorldTransform(a0, a1);
    } __finally {
        _PrintExit("SetWorldTransform(,) -> %p\n", rv);
    };
    return rv;
}

BOOL __stdcall Mine_SetupComm(HANDLE a0,
                              DWORD a1,
                              DWORD a2)
{
    _PrintEnter("SetupComm(%p,%p,%p)\n", a0, a1, a2);

    BOOL rv = 0;
    __try {
        rv = Real_SetupComm(a0, a1, a2);
    } __finally {
        _PrintExit("SetupComm(,,) -> %p\n", rv);
    };
    return rv;
}

BOOL __stdcall Mine_ShowCaret(HWND a0)
{
    _PrintEnter("ShowCaret(%p)\n", a0);

    BOOL rv = 0;
    __try {
        rv = Real_ShowCaret(a0);
    } __finally {
        _PrintExit("ShowCaret() -> %p\n", rv);
    };
    return rv;
}

int __stdcall Mine_ShowCursor(BOOL a0)
{
    _PrintEnter("ShowCursor(%p)\n", a0);

    int rv = 0;
    __try {
        rv = Real_ShowCursor(a0);
    } __finally {
        _PrintExit("ShowCursor() -> %p\n", rv);
    };
    return rv;
}

BOOL __stdcall Mine_ShowOwnedPopups(HWND a0,
                                    BOOL a1)
{
    _PrintEnter("ShowOwnedPopups(%p,%p)\n", a0, a1);

    BOOL rv = 0;
    __try {
        rv = Real_ShowOwnedPopups(a0, a1);
    } __finally {
        _PrintExit("ShowOwnedPopups(,) -> %p\n", rv);
    };
    return rv;
}

BOOL __stdcall Mine_ShowScrollBar(HWND a0,
                                  int a1,
                                  BOOL a2)
{
    _PrintEnter("ShowScrollBar(%p,%p,%p)\n", a0, a1, a2);

    BOOL rv = 0;
    __try {
        rv = Real_ShowScrollBar(a0, a1, a2);
    } __finally {
        _PrintExit("ShowScrollBar(,,) -> %p\n", rv);
    };
    return rv;
}

BOOL __stdcall Mine_ShowWindow(HWND a0,
                               int a1)
{
    _PrintEnter("ShowWindow(%p,%p)\n", a0, a1);

    BOOL rv = 0;
    __try {
        rv = Real_ShowWindow(a0, a1);
    } __finally {
        _PrintExit("ShowWindow(,) -> %p\n", rv);
    };
    return rv;
}

BOOL __stdcall Mine_ShowWindowAsync(HWND a0,
                                    int a1)
{
    _PrintEnter("ShowWindowAsync(%p,%p)\n", a0, a1);

    BOOL rv = 0;
    __try {
        rv = Real_ShowWindowAsync(a0, a1);
    } __finally {
        _PrintExit("ShowWindowAsync(,) -> %p\n", rv);
    };
    return rv;
}

DWORD __stdcall Mine_SignalObjectAndWait(HANDLE a0,
                                         HANDLE a1,
                                         DWORD a2,
                                         BOOL a3)
{
    _PrintEnter("SignalObjectAndWait(%p,%p,%p,%p)\n", a0, a1, a2, a3);

    DWORD rv = 0;
    __try {
        rv = Real_SignalObjectAndWait(a0, a1, a2, a3);
    } __finally {
        _PrintExit("SignalObjectAndWait(,,,) -> %p\n", rv);
    };
    return rv;
}

DWORD __stdcall Mine_SizeofResource(HMODULE a0,
                                    HRSRC a1)
{
    _PrintEnter("SizeofResource(%p,%p)\n", a0, a1);

    DWORD rv = 0;
    __try {
        rv = Real_SizeofResource(a0, a1);
    } __finally {
        _PrintExit("SizeofResource(,) -> %p\n", rv);
    };
    return rv;
}

DWORD __stdcall Mine_SleepEx(DWORD a0,
                             BOOL a1)
{
    _PrintEnter("SleepEx(%p,%p)\n", a0, a1);

    DWORD rv = 0;
    __try {
        rv = Real_SleepEx(a0, a1);
    } __finally {
        _PrintExit("SleepEx(,) -> %p\n", rv);
    };
    return rv;
}

int __stdcall Mine_StartDocA(HDC a0,
                             DOCINFOA* a1)
{
    _PrintEnter("StartDocA(%p,%p)\n", a0, a1);

    int rv = 0;
    __try {
        rv = Real_StartDocA(a0, a1);
    } __finally {
        _PrintExit("StartDocA(,) -> %p\n", rv);
    };
    return rv;
}

int __stdcall Mine_StartDocW(HDC a0,
                             DOCINFOW* a1)
{
    _PrintEnter("StartDocW(%p,%p)\n", a0, a1);

    int rv = 0;
    __try {
        rv = Real_StartDocW(a0, a1);
    } __finally {
        _PrintExit("StartDocW(,) -> %p\n", rv);
    };
    return rv;
}

int __stdcall Mine_StartPage(HDC a0)
{
    _PrintEnter("StartPage(%p)\n", a0);

    int rv = 0;
    __try {
        rv = Real_StartPage(a0);
    } __finally {
        _PrintExit("StartPage() -> %p\n", rv);
    };
    return rv;
}

HRESULT __stdcall Mine_StgCreateDocfile(OLECHAR* a0,
                                        DWORD a1,
                                        DWORD a2,
                                        IStorage** a3)
{
    _PrintEnter("StgCreateDocfile(%p,%p,%p,%p)\n", a0, a1, a2, a3);

    HRESULT rv = 0;
    __try {
        rv = Real_StgCreateDocfile(a0, a1, a2, a3);
    } __finally {
        _PrintExit("StgCreateDocfile(,,,) -> %p\n", rv);
    };
    return rv;
}

HRESULT __stdcall Mine_StgCreateDocfileOnILockBytes(ILockBytes* a0,
                                                    DWORD a1,
                                                    DWORD a2,
                                                    IStorage** a3)
{
    _PrintEnter("StgCreateDocfileOnILockBytes(%p,%p,%p,%p)\n", a0, a1, a2, a3);

    HRESULT rv = 0;
    __try {
        rv = Real_StgCreateDocfileOnILockBytes(a0, a1, a2, a3);
    } __finally {
        _PrintExit("StgCreateDocfileOnILockBytes(,,,) -> %p\n", rv);
    };
    return rv;
}

HRESULT __stdcall Mine_StgCreatePropSetStg(IStorage* a0,
                                           DWORD a1,
                                           IPropertySetStorage** a2)
{
    _PrintEnter("StgCreatePropSetStg(%p,%p,%p)\n", a0, a1, a2);

    HRESULT rv = 0;
    __try {
        rv = Real_StgCreatePropSetStg(a0, a1, a2);
    } __finally {
        _PrintExit("StgCreatePropSetStg(,,) -> %p\n", rv);
    };
    return rv;
}

HRESULT __stdcall Mine_StgCreatePropStg(IUnknown* a0,
                                        CONST IID& a1,
                                        CLSID* a2,
                                        DWORD a3,
                                        DWORD a4,
                                        IPropertyStorage** a5)
{
    _PrintEnter("StgCreatePropStg(%p,%p,%p,%p,%p,%p)\n", a0, a1, a2, a3, a4, a5);

    HRESULT rv = 0;
    __try {
        rv = Real_StgCreatePropStg(a0, a1, a2, a3, a4, a5);
    } __finally {
        _PrintExit("StgCreatePropStg(,,,,,) -> %p\n", rv);
    };
    return rv;
}

#if _MSC_VER < 1300
HRESULT __stdcall Mine_StgCreateStorageEx(WCHAR* a0,
                                          DWORD a1,
                                          DWORD a2,
                                          DWORD a3,
                                          void* a4,
                                          void* a5,
                                          CONST IID& a6,
                                          void** a7)
#else
HRESULT __stdcall Mine_StgCreateStorageEx(WCHAR* a0,
                                          DWORD a1,
                                          DWORD a2,
                                          DWORD a3,
                                          STGOPTIONS* a4,
                                          void* a5,
                                          CONST IID& a6,
                                          void** a7)
#endif
{
    _PrintEnter("StgCreateStorageEx(%p,%p,%p,%p,%p,%p,%p,%p)\n", a0, a1, a2, a3, a4, a5, a6, a7);

    HRESULT rv = 0;
    __try {
        rv = Real_StgCreateStorageEx(a0, a1, a2, a3, a4, a5, a6, a7);
    } __finally {
        _PrintExit("StgCreateStorageEx(,,,,,,,) -> %p\n", rv);
    };
    return rv;
}

HRESULT __stdcall Mine_StgGetIFillLockBytesOnFile(OLECHAR* a0,
                                                  IFillLockBytes** a1)
{
    _PrintEnter("StgGetIFillLockBytesOnFile(%p,%p)\n", a0, a1);

    HRESULT rv = 0;
    __try {
        rv = Real_StgGetIFillLockBytesOnFile(a0, a1);
    } __finally {
        _PrintExit("StgGetIFillLockBytesOnFile(,) -> %p\n", rv);
    };
    return rv;
}

HRESULT __stdcall Mine_StgGetIFillLockBytesOnILockBytes(ILockBytes* a0,
                                                        IFillLockBytes** a1)
{
    _PrintEnter("StgGetIFillLockBytesOnILockBytes(%p,%p)\n", a0, a1);

    HRESULT rv = 0;
    __try {
        rv = Real_StgGetIFillLockBytesOnILockBytes(a0, a1);
    } __finally {
        _PrintExit("StgGetIFillLockBytesOnILockBytes(,) -> %p\n", rv);
    };
    return rv;
}

HRESULT __stdcall Mine_StgIsStorageFile(OLECHAR* a0)
{
    _PrintEnter("StgIsStorageFile(%p)\n", a0);

    HRESULT rv = 0;
    __try {
        rv = Real_StgIsStorageFile(a0);
    } __finally {
        _PrintExit("StgIsStorageFile() -> %p\n", rv);
    };
    return rv;
}

HRESULT __stdcall Mine_StgIsStorageILockBytes(ILockBytes* a0)
{
    _PrintEnter("StgIsStorageILockBytes(%p)\n", a0);

    HRESULT rv = 0;
    __try {
        rv = Real_StgIsStorageILockBytes(a0);
    } __finally {
        _PrintExit("StgIsStorageILockBytes() -> %p\n", rv);
    };
    return rv;
}

HRESULT __stdcall Mine_StgOpenAsyncDocfileOnIFillLockBytes(IFillLockBytes* a0,
                                                           DWORD a1,
                                                           DWORD a2,
                                                           IStorage** a3)
{
    _PrintEnter("StgOpenAsyncDocfileOnIFillLockBytes(%p,%p,%p,%p)\n", a0, a1, a2, a3);

    HRESULT rv = 0;
    __try {
        rv = Real_StgOpenAsyncDocfileOnIFillLockBytes(a0, a1, a2, a3);
    } __finally {
        _PrintExit("StgOpenAsyncDocfileOnIFillLockBytes(,,,) -> %p\n", rv);
    };
    return rv;
}

HRESULT __stdcall Mine_StgOpenPropStg(IUnknown* a0,
                                      CONST IID& a1,
                                      DWORD a2,
                                      DWORD a3,
                                      IPropertyStorage** a4)
{
    _PrintEnter("StgOpenPropStg(%p,%p,%p,%p,%p)\n", a0, a1, a2, a3, a4);

    HRESULT rv = 0;
    __try {
        rv = Real_StgOpenPropStg(a0, a1, a2, a3, a4);
    } __finally {
        _PrintExit("StgOpenPropStg(,,,,) -> %p\n", rv);
    };
    return rv;
}

HRESULT __stdcall Mine_StgOpenStorage(OLECHAR* a0,
                                      IStorage* a1,
                                      DWORD a2,
                                      SNB a3,
                                      DWORD a4,
                                      IStorage** a5)
{
    _PrintEnter("StgOpenStorage(%p,%p,%p,%p,%p,%p)\n", a0, a1, a2, a3, a4, a5);

    HRESULT rv = 0;
    __try {
        rv = Real_StgOpenStorage(a0, a1, a2, a3, a4, a5);
    } __finally {
        _PrintExit("StgOpenStorage(,,,,,) -> %p\n", rv);
    };
    return rv;
}

#if _MSC_VER < 1300
HRESULT __stdcall Mine_StgOpenStorageEx(WCHAR* a0,
                                        DWORD a1,
                                        DWORD a2,
                                        DWORD a3,
                                        void* a4,
                                        void* a5,
                                        CONST IID& a6,
                                        void** a7)
#else
HRESULT __stdcall Mine_StgOpenStorageEx(WCHAR* a0,
                                        DWORD a1,
                                        DWORD a2,
                                        DWORD a3,
                                        STGOPTIONS* a4,
                                        void* a5,
                                        CONST IID& a6,
                                        void** a7)
#endif
{
    _PrintEnter("StgOpenStorageEx(%p,%p,%p,%p,%p,%p,%p,%p)\n", a0, a1, a2, a3, a4, a5, a6, a7);

    HRESULT rv = 0;
    __try {
        rv = Real_StgOpenStorageEx(a0, a1, a2, a3, a4, a5, a6, a7);
    } __finally {
        _PrintExit("StgOpenStorageEx(,,,,,,,) -> %p\n", rv);
    };
    return rv;
}

HRESULT __stdcall Mine_StgOpenStorageOnILockBytes(ILockBytes* a0,
                                                  IStorage* a1,
                                                  DWORD a2,
                                                  SNB a3,
                                                  DWORD a4,
                                                  IStorage** a5)
{
    _PrintEnter("StgOpenStorageOnILockBytes(%p,%p,%p,%p,%p,%p)\n", a0, a1, a2, a3, a4, a5);

    HRESULT rv = 0;
    __try {
        rv = Real_StgOpenStorageOnILockBytes(a0, a1, a2, a3, a4, a5);
    } __finally {
        _PrintExit("StgOpenStorageOnILockBytes(,,,,,) -> %p\n", rv);
    };
    return rv;
}

HRESULT __stdcall Mine_StgSetTimes(OLECHAR* a0,
                                   FILETIME* a1,
                                   FILETIME* a2,
                                   FILETIME* a3)
{
    _PrintEnter("StgSetTimes(%p,%p,%p,%p)\n", a0, a1, a2, a3);

    HRESULT rv = 0;
    __try {
        rv = Real_StgSetTimes(a0, a1, a2, a3);
    } __finally {
        _PrintExit("StgSetTimes(,,,) -> %p\n", rv);
    };
    return rv;
}

BOOL __stdcall Mine_StretchBlt(HDC a0,
                               int a1,
                               int a2,
                               int a3,
                               int a4,
                               HDC a5,
                               int a6,
                               int a7,
                               int a8,
                               int a9,
                               DWORD a10)
{
    _PrintEnter("StretchBlt(%p,%p,%p,%p,%p,%p,%p,%p,%p,%p,%p)\n", a0, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10);

    BOOL rv = 0;
    __try {
        rv = Real_StretchBlt(a0, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10);
    } __finally {
        _PrintExit("StretchBlt(,,,,,,,,,,) -> %p\n", rv);
    };
    return rv;
}

int __stdcall Mine_StretchDIBits(HDC a0,
                                 int a1,
                                 int a2,
                                 int a3,
                                 int a4,
                                 int a5,
                                 int a6,
                                 int a7,
                                 int a8,
                                 void* a9,
                                 BITMAPINFO* a10,
                                 UINT a11,
                                 DWORD a12)
{
    _PrintEnter("StretchDIBits(%p,%p,%p,%p,%p,%p,%p,%p,%p,%p,%p,%p,%p)\n", a0, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12);

    int rv = 0;
    __try {
        rv = Real_StretchDIBits(a0, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12);
    } __finally {
        _PrintExit("StretchDIBits(,,,,,,,,,,,,) -> %p\n", rv);
    };
    return rv;
}

HRESULT __stdcall Mine_StringFromCLSID(CONST IID& a0,
                                       LPOLESTR* a1)
{
    _PrintEnter("StringFromCLSID(%p,%p)\n", a0, a1);

    HRESULT rv = 0;
    __try {
        rv = Real_StringFromCLSID(a0, a1);
    } __finally {
        _PrintExit("StringFromCLSID(,) -> %p\n", rv);
    };
    return rv;
}

int __stdcall Mine_StringFromGUID2(CONST GUID& a0,
                                   LPOLESTR a1,
                                   int a2)
{
    _PrintEnter("StringFromGUID2(%p,%p,%p)\n", a0, a1, a2);

    int rv = 0;
    __try {
        rv = Real_StringFromGUID2(a0, a1, a2);
    } __finally {
        _PrintExit("StringFromGUID2(,,) -> %p\n", rv);
    };
    return rv;
}

HRESULT __stdcall Mine_StringFromIID(CONST IID& a0,
                                     LPOLESTR* a1)
{
    _PrintEnter("StringFromIID(%p,%p)\n", a0, a1);

    HRESULT rv = 0;
    __try {
        rv = Real_StringFromIID(a0, a1);
    } __finally {
        _PrintExit("StringFromIID(,) -> %p\n", rv);
    };
    return rv;
}

BOOL __stdcall Mine_StrokeAndFillPath(HDC a0)
{
    _PrintEnter("StrokeAndFillPath(%p)\n", a0);

    BOOL rv = 0;
    __try {
        rv = Real_StrokeAndFillPath(a0);
    } __finally {
        _PrintExit("StrokeAndFillPath() -> %p\n", rv);
    };
    return rv;
}

BOOL __stdcall Mine_StrokePath(HDC a0)
{
    _PrintEnter("StrokePath(%p)\n", a0);

    BOOL rv = 0;
    __try {
        rv = Real_StrokePath(a0);
    } __finally {
        _PrintExit("StrokePath() -> %p\n", rv);
    };
    return rv;
}

BOOL __stdcall Mine_SubtractRect(LPRECT a0,
                                 RECT* a1,
                                 RECT* a2)
{
    _PrintEnter("SubtractRect(%p,%p,%p)\n", a0, a1, a2);

    BOOL rv = 0;
    __try {
        rv = Real_SubtractRect(a0, a1, a2);
    } __finally {
        _PrintExit("SubtractRect(,,) -> %p\n", rv);
    };
    return rv;
}

DWORD __stdcall Mine_SuspendThread(HANDLE a0)
{
    _PrintEnter("SuspendThread(%p)\n", a0);

    DWORD rv = 0;
    __try {
        rv = Real_SuspendThread(a0);
    } __finally {
        _PrintExit("SuspendThread() -> %p\n", rv);
    };
    return rv;
}

BOOL __stdcall Mine_SwapBuffers(HDC a0)
{
    _PrintEnter("SwapBuffers(%p)\n", a0);

    BOOL rv = 0;
    __try {
        rv = Real_SwapBuffers(a0);
    } __finally {
        _PrintExit("SwapBuffers() -> %p\n", rv);
    };
    return rv;
}

BOOL __stdcall Mine_SwapMouseButton(BOOL a0)
{
    _PrintEnter("SwapMouseButton(%p)\n", a0);

    BOOL rv = 0;
    __try {
        rv = Real_SwapMouseButton(a0);
    } __finally {
        _PrintExit("SwapMouseButton() -> %p\n", rv);
    };
    return rv;
}

BOOL __stdcall Mine_SwitchDesktop(HDESK a0)
{
    _PrintEnter("SwitchDesktop(%p)\n", a0);

    BOOL rv = 0;
    __try {
        rv = Real_SwitchDesktop(a0);
    } __finally {
        _PrintExit("SwitchDesktop() -> %p\n", rv);
    };
    return rv;
}

void __stdcall Mine_SwitchToFiber(LPVOID a0)
{
    _PrintEnter("SwitchToFiber(%p)\n", a0);

    __try {
        Real_SwitchToFiber(a0);
    } __finally {
        _PrintExit("SwitchToFiber() ->\n");
    };
}

BOOL __stdcall Mine_SwitchToThread(void)
{
    _PrintEnter("SwitchToThread()\n");

    BOOL rv = 0;
    __try {
        rv = Real_SwitchToThread();
    } __finally {
        _PrintExit("SwitchToThread() -> %p\n", rv);
    };
    return rv;
}

BOOL __stdcall Mine_SystemParametersInfoA(UINT a0,
                                          UINT a1,
                                          PVOID a2,
                                          UINT a3)
{
    _PrintEnter("SystemParametersInfoA(%p,%p,%p,%p)\n", a0, a1, a2, a3);

    BOOL rv = 0;
    __try {
        rv = Real_SystemParametersInfoA(a0, a1, a2, a3);
    } __finally {
        _PrintExit("SystemParametersInfoA(,,,) -> %p\n", rv);
    };
    return rv;
}

BOOL __stdcall Mine_SystemParametersInfoW(UINT a0,
                                          UINT a1,
                                          PVOID a2,
                                          UINT a3)
{
    _PrintEnter("SystemParametersInfoW(%p,%p,%p,%p)\n", a0, a1, a2, a3);

    BOOL rv = 0;
    __try {
        rv = Real_SystemParametersInfoW(a0, a1, a2, a3);
    } __finally {
        _PrintExit("SystemParametersInfoW(,,,) -> %p\n", rv);
    };
    return rv;
}

BOOL __stdcall Mine_SystemTimeToFileTime(SYSTEMTIME* a0,
                                         LPFILETIME a1)
{
    _PrintEnter("SystemTimeToFileTime(%p,%p)\n", a0, a1);

    BOOL rv = 0;
    __try {
        rv = Real_SystemTimeToFileTime(a0, a1);
    } __finally {
        _PrintExit("SystemTimeToFileTime(,) -> %p\n", rv);
    };
    return rv;
}

BOOL __stdcall Mine_SystemTimeToTzSpecificLocalTime(
#ifdef PIPE_ACCEPT_REMOTE_CLIENTS
                                                    const TIME_ZONE_INFORMATION *a0,
                                                    const SYSTEMTIME *a1,
#else
                                                    LPTIME_ZONE_INFORMATION a0,
                                                    LPSYSTEMTIME a1,
#endif
                                                    LPSYSTEMTIME a2
                                                   )
{
    _PrintEnter("SystemTimeToTzSpecificLocalTime(%p,%p,%p)\n", a0, a1, a2);

    BOOL rv = 0;
    __try {
        rv = Real_SystemTimeToTzSpecificLocalTime(a0, a1, a2);
    } __finally {
        _PrintExit("SystemTimeToTzSpecificLocalTime(,,) -> %p\n", rv);
    };
    return rv;
}

LONG __stdcall Mine_TabbedTextOutA(HDC a0,
                                   int a1,
                                   int a2,
                                   LPCSTR a3,
                                   int a4,
                                   int a5,
                                   INT* a6,
                                   int a7)
{
    _PrintEnter("TabbedTextOutA(%p,%p,%p,%hs,%p,%p,%p,%p)\n", a0, a1, a2, a3, a4, a5, a6, a7);

    LONG rv = 0;
    __try {
        rv = Real_TabbedTextOutA(a0, a1, a2, a3, a4, a5, a6, a7);
    } __finally {
        _PrintExit("TabbedTextOutA(,,,,,,,) -> %p\n", rv);
    };
    return rv;
}

LONG __stdcall Mine_TabbedTextOutW(HDC a0,
                                   int a1,
                                   int a2,
                                   LPCWSTR a3,
                                   int a4,
                                   int a5,
                                   INT* a6,
                                   int a7)
{
    _PrintEnter("TabbedTextOutW(%p,%p,%p,%ls,%p,%p,%p,%p)\n", a0, a1, a2, a3, a4, a5, a6, a7);

    LONG rv = 0;
    __try {
        rv = Real_TabbedTextOutW(a0, a1, a2, a3, a4, a5, a6, a7);
    } __finally {
        _PrintExit("TabbedTextOutW(,,,,,,,) -> %p\n", rv);
    };
    return rv;
}

BOOL __stdcall Mine_TerminateProcess(HANDLE a0,
                                     UINT a1)
{
    _PrintEnter("TerminateProcess(%p,%p)\n", a0, a1);

    BOOL rv = 0;
    __try {
        rv = Real_TerminateProcess(a0, a1);
    } __finally {
        _PrintExit("TerminateProcess(,) -> %p\n", rv);
    };
    return rv;
}

BOOL __stdcall Mine_TerminateThread(HANDLE a0,
                                    DWORD a1)
{
    _PrintEnter("TerminateThread(%p,%p)\n", a0, a1);

    BOOL rv = 0;
    __try {
        rv = Real_TerminateThread(a0, a1);
    } __finally {
        _PrintExit("TerminateThread(,) -> %p\n", rv);
    };
    return rv;
}

BOOL __stdcall Mine_TextOutA(HDC a0,
                             int a1,
                             int a2,
                             LPCSTR a3,
                             int a4)
{
    _PrintEnter("TextOutA(%p,%p,%p,%hs,%p)\n", a0, a1, a2, a3, a4);

    BOOL rv = 0;
    __try {
        rv = Real_TextOutA(a0, a1, a2, a3, a4);
    } __finally {
        _PrintExit("TextOutA(,,,,) -> %p\n", rv);
    };
    return rv;
}

BOOL __stdcall Mine_TextOutW(HDC a0,
                             int a1,
                             int a2,
                             LPCWSTR a3,
                             int a4)
{
    _PrintEnter("TextOutW(%p,%p,%p,%ls,%p)\n", a0, a1, a2, a3, a4);

    BOOL rv = 0;
    __try {
        rv = Real_TextOutW(a0, a1, a2, a3, a4);
    } __finally {
        _PrintExit("TextOutW(,,,,) -> %p\n", rv);
    };
    return rv;
}

WORD __stdcall Mine_TileWindows(HWND a0,
                                UINT a1,
                                RECT* a2,
                                UINT a3,
                                struct HWND__** a4)
{
    _PrintEnter("TileWindows(%p,%p,%p,%p,%p)\n", a0, a1, a2, a3, a4);

    WORD rv = 0;
    __try {
        rv = Real_TileWindows(a0, a1, a2, a3, a4);
    } __finally {
        _PrintExit("TileWindows(,,,,) -> %p\n", rv);
    };
    return rv;
}

int __stdcall Mine_ToAscii(UINT a0,
                           UINT a1,
                           BYTE* a2,
                           LPWORD a3,
                           UINT a4)
{
    _PrintEnter("ToAscii(%p,%p,%p,%p,%p)\n", a0, a1, a2, a3, a4);

    int rv = 0;
    __try {
        rv = Real_ToAscii(a0, a1, a2, a3, a4);
    } __finally {
        _PrintExit("ToAscii(,,,,) -> %p\n", rv);
    };
    return rv;
}

int __stdcall Mine_ToAsciiEx(UINT a0,
                             UINT a1,
                             BYTE* a2,
                             LPWORD a3,
                             UINT a4,
                             HKL a5)
{
    _PrintEnter("ToAsciiEx(%p,%p,%p,%p,%p,%p)\n", a0, a1, a2, a3, a4, a5);

    int rv = 0;
    __try {
        rv = Real_ToAsciiEx(a0, a1, a2, a3, a4, a5);
    } __finally {
        _PrintExit("ToAsciiEx(,,,,,) -> %p\n", rv);
    };
    return rv;
}

int __stdcall Mine_ToUnicode(UINT a0,
                             UINT a1,
                             BYTE* a2,
                             LPWSTR a3,
                             int a4,
                             UINT a5)
{
    _PrintEnter("ToUnicode(%p,%p,%p,%p,%p,%p)\n", a0, a1, a2, a3, a4, a5);

    int rv = 0;
    __try {
        rv = Real_ToUnicode(a0, a1, a2, a3, a4, a5);
    } __finally {
        _PrintExit("ToUnicode(,,,%ls,,) -> %p\n", a3, rv);
    };
    return rv;
}

int __stdcall Mine_ToUnicodeEx(UINT a0,
                               UINT a1,
                               BYTE* a2,
                               LPWSTR a3,
                               int a4,
                               UINT a5,
                               HKL a6)
{
    _PrintEnter("ToUnicodeEx(%p,%p,%p,%p,%p,%p,%p)\n", a0, a1, a2, a3, a4, a5, a6);

    int rv = 0;
    __try {
        rv = Real_ToUnicodeEx(a0, a1, a2, a3, a4, a5, a6);
    } __finally {
        _PrintExit("ToUnicodeEx(,,,%ls,,,) -> %p\n", a3, rv);
    };
    return rv;
}

BOOL __stdcall Mine_TrackMouseEvent(TRACKMOUSEEVENT* a0)
{
    _PrintEnter("TrackMouseEvent(%p)\n", a0);

    BOOL rv = 0;
    __try {
        rv = Real_TrackMouseEvent(a0);
    } __finally {
        _PrintExit("TrackMouseEvent() -> %p\n", rv);
    };
    return rv;
}

BOOL __stdcall Mine_TrackPopupMenu(HMENU a0,
                                   UINT a1,
                                   int a2,
                                   int a3,
                                   int a4,
                                   HWND a5,
                                   RECT* a6)
{
    _PrintEnter("TrackPopupMenu(%p,%p,%p,%p,%p,%p,%p)\n", a0, a1, a2, a3, a4, a5, a6);

    BOOL rv = 0;
    __try {
        rv = Real_TrackPopupMenu(a0, a1, a2, a3, a4, a5, a6);
    } __finally {
        _PrintExit("TrackPopupMenu(,,,,,,) -> %p\n", rv);
    };
    return rv;
}

BOOL __stdcall Mine_TrackPopupMenuEx(HMENU a0,
                                     UINT a1,
                                     int a2,
                                     int a3,
                                     HWND a4,
                                     LPTPMPARAMS a5)
{
    _PrintEnter("TrackPopupMenuEx(%p,%p,%p,%p,%p,%p)\n", a0, a1, a2, a3, a4, a5);

    BOOL rv = 0;
    __try {
        rv = Real_TrackPopupMenuEx(a0, a1, a2, a3, a4, a5);
    } __finally {
        _PrintExit("TrackPopupMenuEx(,,,,,) -> %p\n", rv);
    };
    return rv;
}

BOOL __stdcall Mine_TransactNamedPipe(HANDLE a0,
                                      LPVOID a1,
                                      DWORD a2,
                                      LPVOID a3,
                                      DWORD a4,
                                      LPDWORD a5,
                                      LPOVERLAPPED a6)
{
    _PrintEnter("TransactNamedPipe(%p,%p,%p,%p,%p,%p,%p)\n", a0, a1, a2, a3, a4, a5, a6);

    BOOL rv = 0;
    __try {
        rv = Real_TransactNamedPipe(a0, a1, a2, a3, a4, a5, a6);
    } __finally {
        _PrintExit("TransactNamedPipe(,,,,,,) -> %p\n", rv);
    };
    return rv;
}

int __stdcall Mine_TranslateAcceleratorA(HWND a0,
                                         HACCEL a1,
                                         LPMSG a2)
{
    _PrintEnter("TranslateAcceleratorA(%p,%p,%p)\n", a0, a1, a2);

    int rv = 0;
    __try {
        rv = Real_TranslateAcceleratorA(a0, a1, a2);
    } __finally {
        _PrintExit("TranslateAcceleratorA(,,) -> %p\n", rv);
    };
    return rv;
}

int __stdcall Mine_TranslateAcceleratorW(HWND a0,
                                         HACCEL a1,
                                         LPMSG a2)
{
    _PrintEnter("TranslateAcceleratorW(%p,%p,%p)\n", a0, a1, a2);

    int rv = 0;
    __try {
        rv = Real_TranslateAcceleratorW(a0, a1, a2);
    } __finally {
        _PrintExit("TranslateAcceleratorW(,,) -> %p\n", rv);
    };
    return rv;
}

BOOL __stdcall Mine_TranslateCharsetInfo(DWORD* a0,
                                         CHARSETINFO* a1,
                                         DWORD a2)
{
    _PrintEnter("TranslateCharsetInfo(%p,%p,%p)\n", a0, a1, a2);

    BOOL rv = 0;
    __try {
        rv = Real_TranslateCharsetInfo(a0, a1, a2);
    } __finally {
        _PrintExit("TranslateCharsetInfo(,,) -> %p\n", rv);
    };
    return rv;
}

BOOL __stdcall Mine_TranslateMDISysAccel(HWND a0,
                                         LPMSG a1)
{
    _PrintEnter("TranslateMDISysAccel(%p,%p)\n", a0, a1);

    BOOL rv = 0;
    __try {
        rv = Real_TranslateMDISysAccel(a0, a1);
    } __finally {
        _PrintExit("TranslateMDISysAccel(,) -> %p\n", rv);
    };
    return rv;
}

BOOL __stdcall Mine_TranslateMessage(MSG* a0)
{
    _PrintEnter("TranslateMessage(%p)\n", a0);

    BOOL rv = 0;
    __try {
        rv = Real_TranslateMessage(a0);
    } __finally {
        _PrintExit("TranslateMessage() -> %p\n", rv);
    };
    return rv;
}

BOOL __stdcall Mine_TransmitCommChar(HANDLE a0,
                                     char a1)
{
    _PrintEnter("TransmitCommChar(%p,%p)\n", a0, a1);

    BOOL rv = 0;
    __try {
        rv = Real_TransmitCommChar(a0, a1);
    } __finally {
        _PrintExit("TransmitCommChar(,) -> %p\n", rv);
    };
    return rv;
}

#if DETOUR_TryEnterCriticalSection_EVEN_IF_IT_EXERCISES_A_BUG_IN_RtlLookupFunctionTable
BOOL __stdcall Mine_TryEnterCriticalSection(LPCRITICAL_SECTION a0)
{
    _PrintEnter("TryEnterCriticalSection(%p)\n", a0);

    BOOL rv = 0;
    __try {
        rv = Real_TryEnterCriticalSection(a0);
    } __finally {
        _PrintExit("TryEnterCriticalSection() -> %p\n", rv);
    };
    return rv;
}
#endif

BOOL __stdcall Mine_UnhookWindowsHook(int a0,
                                      HOOKPROC a1)
{
    _PrintEnter("UnhookWindowsHook(%p,%p)\n", a0, a1);

    BOOL rv = 0;
    __try {
        rv = Real_UnhookWindowsHook(a0, a1);
    } __finally {
        _PrintExit("UnhookWindowsHook(,) -> %p\n", rv);
    };
    return rv;
}

BOOL __stdcall Mine_UnhookWindowsHookEx(HHOOK a0)
{
    _PrintEnter("UnhookWindowsHookEx(%p)\n", a0);

    BOOL rv = 0;
    __try {
        rv = Real_UnhookWindowsHookEx(a0);
    } __finally {
        _PrintExit("UnhookWindowsHookEx() -> %p\n", rv);
    };
    return rv;
}

BOOL __stdcall Mine_UnionRect(LPRECT a0,
                              RECT* a1,
                              RECT* a2)
{
    _PrintEnter("UnionRect(%p,%p,%p)\n", a0, a1, a2);

    BOOL rv = 0;
    __try {
        rv = Real_UnionRect(a0, a1, a2);
    } __finally {
        _PrintExit("UnionRect(,,) -> %p\n", rv);
    };
    return rv;
}

BOOL __stdcall Mine_UnloadKeyboardLayout(HKL a0)
{
    _PrintEnter("UnloadKeyboardLayout(%p)\n", a0);

    BOOL rv = 0;
    __try {
        rv = Real_UnloadKeyboardLayout(a0);
    } __finally {
        _PrintExit("UnloadKeyboardLayout() -> %p\n", rv);
    };
    return rv;
}

BOOL __stdcall Mine_UnlockFile(HANDLE a0,
                               DWORD a1,
                               DWORD a2,
                               DWORD a3,
                               DWORD a4)
{
    _PrintEnter("UnlockFile(%p,%p,%p,%p,%p)\n", a0, a1, a2, a3, a4);

    BOOL rv = 0;
    __try {
        rv = Real_UnlockFile(a0, a1, a2, a3, a4);
    } __finally {
        _PrintExit("UnlockFile(,,,,) -> %p\n", rv);
    };
    return rv;
}

BOOL __stdcall Mine_UnlockFileEx(HANDLE a0,
                                 DWORD a1,
                                 DWORD a2,
                                 DWORD a3,
                                 LPOVERLAPPED a4)
{
    _PrintEnter("UnlockFileEx(%p,%p,%p,%p,%p)\n", a0, a1, a2, a3, a4);

    BOOL rv = 0;
    __try {
        rv = Real_UnlockFileEx(a0, a1, a2, a3, a4);
    } __finally {
        _PrintExit("UnlockFileEx(,,,,) -> %p\n", rv);
    };
    return rv;
}

BOOL __stdcall Mine_UnmapViewOfFile(LPCVOID a0)
{
    _PrintEnter("UnmapViewOfFile(%p)\n", a0);

    BOOL rv = 0;
    __try {
        rv = Real_UnmapViewOfFile(a0);
    } __finally {
        _PrintExit("UnmapViewOfFile() -> %p\n", rv);
    };
    return rv;
}

BOOL __stdcall Mine_UnpackDDElParam(UINT a0,
                                    LPARAM a1,
                                    PUINT_PTR a2,
                                    PUINT_PTR a3)
{
    _PrintEnter("UnpackDDElParam(%p,%p,%p,%p)\n", a0, a1, a2, a3);

    BOOL rv = 0;
    __try {
        rv = Real_UnpackDDElParam(a0, a1, a2, a3);
    } __finally {
        _PrintExit("UnpackDDElParam(,,,) -> %p\n", rv);
    };
    return rv;
}

BOOL __stdcall Mine_UnrealizeObject(HGDIOBJ a0)
{
    _PrintEnter("UnrealizeObject(%p)\n", a0);

    BOOL rv = 0;
    __try {
        rv = Real_UnrealizeObject(a0);
    } __finally {
        _PrintExit("UnrealizeObject() -> %p\n", rv);
    };
    return rv;
}

BOOL __stdcall Mine_UnregisterClassA(LPCSTR a0,
                                     HINSTANCE a1)
{
    _PrintEnter("UnregisterClassA(%hs,%p)\n", a0, a1);

    BOOL rv = 0;
    __try {
        rv = Real_UnregisterClassA(a0, a1);
    } __finally {
        _PrintExit("UnregisterClassA(,) -> %p\n", rv);
    };
    return rv;
}

BOOL __stdcall Mine_UnregisterClassW(LPCWSTR a0,
                                     HINSTANCE a1)
{
    _PrintEnter("UnregisterClassW(%ls,%p)\n", a0, a1);

    BOOL rv = 0;
    __try {
        rv = Real_UnregisterClassW(a0, a1);
    } __finally {
        _PrintExit("UnregisterClassW(,) -> %p\n", rv);
    };
    return rv;
}

BOOL __stdcall Mine_UnregisterHotKey(HWND a0,
                                     int a1)
{
    _PrintEnter("UnregisterHotKey(%p,%p)\n", a0, a1);

    BOOL rv = 0;
    __try {
        rv = Real_UnregisterHotKey(a0, a1);
    } __finally {
        _PrintExit("UnregisterHotKey(,) -> %p\n", rv);
    };
    return rv;
}

BOOL __stdcall Mine_UpdateColors(HDC a0)
{
    _PrintEnter("UpdateColors(%p)\n", a0);

    BOOL rv = 0;
    __try {
        rv = Real_UpdateColors(a0);
    } __finally {
        _PrintExit("UpdateColors() -> %p\n", rv);
    };
    return rv;
}

BOOL __stdcall Mine_UpdateResourceA(HANDLE a0,
                                    LPCSTR a1,
                                    LPCSTR a2,
                                    WORD a3,
                                    LPVOID a4,
                                    DWORD a5)
{
    _PrintEnter("UpdateResourceA(%p,%hs,%hs,%p,%p,%p)\n", a0, a1, a2, a3, a4, a5);

    BOOL rv = 0;
    __try {
        rv = Real_UpdateResourceA(a0, a1, a2, a3, a4, a5);
    } __finally {
        _PrintExit("UpdateResourceA(,,,,,) -> %p\n", rv);
    };
    return rv;
}

BOOL __stdcall Mine_UpdateResourceW(HANDLE a0,
                                    LPCWSTR a1,
                                    LPCWSTR a2,
                                    WORD a3,
                                    LPVOID a4,
                                    DWORD a5)
{
    _PrintEnter("UpdateResourceW(%p,%ls,%ls,%p,%p,%p)\n", a0, a1, a2, a3, a4, a5);

    BOOL rv = 0;
    __try {
        rv = Real_UpdateResourceW(a0, a1, a2, a3, a4, a5);
    } __finally {
        _PrintExit("UpdateResourceW(,,,,,) -> %p\n", rv);
    };
    return rv;
}

BOOL __stdcall Mine_UpdateWindow(HWND a0)
{
    _PrintEnter("UpdateWindow(%p)\n", a0);

    BOOL rv = 0;
    __try {
        rv = Real_UpdateWindow(a0);
    } __finally {
        _PrintExit("UpdateWindow() -> %p\n", rv);
    };
    return rv;
}

BOOL __stdcall Mine_ValidateRect(HWND a0,
                                 RECT* a1)
{
    _PrintEnter("ValidateRect(%p,%p)\n", a0, a1);

    BOOL rv = 0;
    __try {
        rv = Real_ValidateRect(a0, a1);
    } __finally {
        _PrintExit("ValidateRect(,) -> %p\n", rv);
    };
    return rv;
}

BOOL __stdcall Mine_ValidateRgn(HWND a0,
                                HRGN a1)
{
    _PrintEnter("ValidateRgn(%p,%p)\n", a0, a1);

    BOOL rv = 0;
    __try {
        rv = Real_ValidateRgn(a0, a1);
    } __finally {
        _PrintExit("ValidateRgn(,) -> %p\n", rv);
    };
    return rv;
}

DWORD __stdcall Mine_VerLanguageNameA(DWORD a0,
                                      LPSTR a1,
                                      DWORD a2)
{
    _PrintEnter("VerLanguageNameA(%p,%p,%p)\n", a0, a1, a2);

    DWORD rv = 0;
    __try {
        rv = Real_VerLanguageNameA(a0, a1, a2);
    } __finally {
        _PrintExit("VerLanguageNameA(,,) -> %p\n", rv);
    };
    return rv;
}

DWORD __stdcall Mine_VerLanguageNameW(DWORD a0,
                                      LPWSTR a1,
                                      DWORD a2)
{
    _PrintEnter("VerLanguageNameW(%p,%p,%p)\n", a0, a1, a2);

    DWORD rv = 0;
    __try {
        rv = Real_VerLanguageNameW(a0, a1, a2);
    } __finally {
        _PrintExit("VerLanguageNameW(,,) -> %p\n", rv);
    };
    return rv;
}

LPVOID __stdcall Mine_VirtualAllocEx(HANDLE a0,
                                     LPVOID a1,
                                     SIZE_T a2,
                                     DWORD a3,
                                     DWORD a4)
{
    _PrintEnter("VirtualAllocEx(%p,%p,%p,%p,%p)\n", a0, a1, a2, a3, a4);

    LPVOID rv = 0;
    __try {
        rv = Real_VirtualAllocEx(a0, a1, a2, a3, a4);
    } __finally {
        _PrintExit("VirtualAllocEx(,,,,) -> %p\n", rv);
    };
    return rv;
}

BOOL __stdcall Mine_VirtualFreeEx(HANDLE a0,
                                  LPVOID a1,
                                  SIZE_T a2,
                                  DWORD a3)
{
    _PrintEnter("VirtualFreeEx(%p,%p,%p,%p)\n", a0, a1, a2, a3);

    BOOL rv = 0;
    __try {
        rv = Real_VirtualFreeEx(a0, a1, a2, a3);
    } __finally {
        _PrintExit("VirtualFreeEx(,,,) -> %p\n", rv);
    };
    return rv;
}

BOOL __stdcall Mine_VirtualProtectEx(HANDLE a0,
                                     LPVOID a1,
                                     SIZE_T a2,
                                     DWORD a3,
                                     PDWORD a4)
{
    _PrintEnter("VirtualProtectEx(%p,%p,%p,%p,%p)\n", a0, a1, a2, a3, a4);

    BOOL rv = 0;
    __try {
        rv = Real_VirtualProtectEx(a0, a1, a2, a3, a4);
    } __finally {
        _PrintExit("VirtualProtectEx(,,,,) -> %p\n", rv);
    };
    return rv;
}

DWORD_PTR __stdcall Mine_VirtualQueryEx(HANDLE a0,
                                        LPCVOID a1,
                                        PMEMORY_BASIC_INFORMATION a2,
                                        DWORD_PTR a3)
{
    _PrintEnter("VirtualQueryEx(%p,%p,%p,%p)\n", a0, a1, a2, a3);

    DWORD_PTR rv = 0;
    __try {
        rv = Real_VirtualQueryEx(a0, a1, a2, a3);
    } __finally {
        _PrintExit("VirtualQueryEx(,,,) -> %p\n", rv);
    };
    return rv;
}

SHORT __stdcall Mine_VkKeyScanA(CHAR a0)
{
    _PrintEnter("VkKeyScanA(%p)\n", a0);

    SHORT rv = 0;
    __try {
        rv = Real_VkKeyScanA(a0);
    } __finally {
        _PrintExit("VkKeyScanA() -> %p\n", rv);
    };
    return rv;
}

SHORT __stdcall Mine_VkKeyScanExA(CHAR a0,
                                  HKL a1)
{
    _PrintEnter("VkKeyScanExA(%p,%p)\n", a0, a1);

    SHORT rv = 0;
    __try {
        rv = Real_VkKeyScanExA(a0, a1);
    } __finally {
        _PrintExit("VkKeyScanExA(,) -> %p\n", rv);
    };
    return rv;
}

SHORT __stdcall Mine_VkKeyScanExW(WCHAR a0,
                                  HKL a1)
{
    _PrintEnter("VkKeyScanExW(%p,%p)\n", a0, a1);

    SHORT rv = 0;
    __try {
        rv = Real_VkKeyScanExW(a0, a1);
    } __finally {
        _PrintExit("VkKeyScanExW(,) -> %p\n", rv);
    };
    return rv;
}

SHORT __stdcall Mine_VkKeyScanW(WCHAR a0)
{
    _PrintEnter("VkKeyScanW(%p)\n", a0);

    SHORT rv = 0;
    __try {
        rv = Real_VkKeyScanW(a0);
    } __finally {
        _PrintExit("VkKeyScanW() -> %p\n", rv);
    };
    return rv;
}

SOCKET __stdcall Mine_WSAAccept(SOCKET a0,
                                sockaddr* a1,
                                LPINT a2,
                                LPCONDITIONPROC a3,
                                DWORD_PTR a4)
{
    _PrintEnter("WSAAccept(%p,%p,%p,%p,%p)\n", a0, a1, a2, a3, a4);

    SOCKET rv = 0;
    __try {
        rv = Real_WSAAccept(a0, a1, a2, a3, a4);
    } __finally {
        _PrintExit("WSAAccept(,,,,) -> %p\n", rv);
    };
    return rv;
}

INT __stdcall Mine_WSAAddressToStringA(LPSOCKADDR a0,
                                       DWORD a1,
                                       LPWSAPROTOCOL_INFOA a2,
                                       LPSTR a3,
                                       LPDWORD a4)
{
    _PrintEnter("WSAAddressToStringA(%p,%p,%p,%p,%p)\n", a0, a1, a2, a3, a4);

    INT rv = 0;
    __try {
        rv = Real_WSAAddressToStringA(a0, a1, a2, a3, a4);
    } __finally {
        _PrintExit("WSAAddressToStringA(,,,,) -> %p\n", rv);
    };
    return rv;
}

INT __stdcall Mine_WSAAddressToStringW(LPSOCKADDR a0,
                                       DWORD a1,
                                       LPWSAPROTOCOL_INFOW a2,
                                       LPWSTR a3,
                                       LPDWORD a4)
{
    _PrintEnter("WSAAddressToStringW(%p,%p,%p,%p,%p)\n", a0, a1, a2, a3, a4);

    INT rv = 0;
    __try {
        rv = Real_WSAAddressToStringW(a0, a1, a2, a3, a4);
    } __finally {
        _PrintExit("WSAAddressToStringW(,,,,) -> %p\n", rv);
    };
    return rv;
}

HANDLE __stdcall Mine_WSAAsyncGetHostByAddr(HWND a0,
                                            u_int a1,
                                            char* a2,
                                            int a3,
                                            int a4,
                                            char* a5,
                                            int a6)
{
    _PrintEnter("WSAAsyncGetHostByAddr(%p,%p,%p,%p,%p,%p,%p)\n", a0, a1, a2, a3, a4, a5, a6);

    HANDLE rv = 0;
    __try {
        rv = Real_WSAAsyncGetHostByAddr(a0, a1, a2, a3, a4, a5, a6);
    } __finally {
        _PrintExit("WSAAsyncGetHostByAddr(,,,,,,) -> %p\n", rv);
    };
    return rv;
}

HANDLE __stdcall Mine_WSAAsyncGetHostByName(HWND a0,
                                            u_int a1,
                                            char* a2,
                                            char* a3,
                                            int a4)
{
    _PrintEnter("WSAAsyncGetHostByName(%p,%p,%p,%p,%p)\n", a0, a1, a2, a3, a4);

    HANDLE rv = 0;
    __try {
        rv = Real_WSAAsyncGetHostByName(a0, a1, a2, a3, a4);
    } __finally {
        _PrintExit("WSAAsyncGetHostByName(,,,,) -> %p\n", rv);
    };
    return rv;
}

HANDLE __stdcall Mine_WSAAsyncGetProtoByName(HWND a0,
                                             u_int a1,
                                             char* a2,
                                             char* a3,
                                             int a4)
{
    _PrintEnter("WSAAsyncGetProtoByName(%p,%p,%p,%p,%p)\n", a0, a1, a2, a3, a4);

    HANDLE rv = 0;
    __try {
        rv = Real_WSAAsyncGetProtoByName(a0, a1, a2, a3, a4);
    } __finally {
        _PrintExit("WSAAsyncGetProtoByName(,,,,) -> %p\n", rv);
    };
    return rv;
}

HANDLE __stdcall Mine_WSAAsyncGetProtoByNumber(HWND a0,
                                               u_int a1,
                                               int a2,
                                               char* a3,
                                               int a4)
{
    _PrintEnter("WSAAsyncGetProtoByNumber(%p,%p,%p,%p,%p)\n", a0, a1, a2, a3, a4);

    HANDLE rv = 0;
    __try {
        rv = Real_WSAAsyncGetProtoByNumber(a0, a1, a2, a3, a4);
    } __finally {
        _PrintExit("WSAAsyncGetProtoByNumber(,,,,) -> %p\n", rv);
    };
    return rv;
}

HANDLE __stdcall Mine_WSAAsyncGetServByName(HWND a0,
                                            u_int a1,
                                            char* a2,
                                            char* a3,
                                            char* a4,
                                            int a5)
{
    _PrintEnter("WSAAsyncGetServByName(%p,%p,%p,%p,%p,%p)\n", a0, a1, a2, a3, a4, a5);

    HANDLE rv = 0;
    __try {
        rv = Real_WSAAsyncGetServByName(a0, a1, a2, a3, a4, a5);
    } __finally {
        _PrintExit("WSAAsyncGetServByName(,,,,,) -> %p\n", rv);
    };
    return rv;
}

HANDLE __stdcall Mine_WSAAsyncGetServByPort(HWND a0,
                                            u_int a1,
                                            int a2,
                                            char* a3,
                                            char* a4,
                                            int a5)
{
    _PrintEnter("WSAAsyncGetServByPort(%p,%p,%p,%p,%p,%p)\n", a0, a1, a2, a3, a4, a5);

    HANDLE rv = 0;
    __try {
        rv = Real_WSAAsyncGetServByPort(a0, a1, a2, a3, a4, a5);
    } __finally {
        _PrintExit("WSAAsyncGetServByPort(,,,,,) -> %p\n", rv);
    };
    return rv;
}

int __stdcall Mine_WSAAsyncSelect(SOCKET a0,
                                  HWND a1,
                                  u_int a2,
                                  long a3)
{
    _PrintEnter("WSAAsyncSelect(%p,%p,%p,%p)\n", a0, a1, a2, a3);

    int rv = 0;
    __try {
        rv = Real_WSAAsyncSelect(a0, a1, a2, a3);
    } __finally {
        _PrintExit("WSAAsyncSelect(,,,) -> %p\n", rv);
    };
    return rv;
}

int __stdcall Mine_WSACancelAsyncRequest(HANDLE a0)
{
    _PrintEnter("WSACancelAsyncRequest(%p)\n", a0);

    int rv = 0;
    __try {
        rv = Real_WSACancelAsyncRequest(a0);
    } __finally {
        _PrintExit("WSACancelAsyncRequest() -> %p\n", rv);
    };
    return rv;
}

int __stdcall Mine_WSACancelBlockingCall(void)
{
    _PrintEnter("WSACancelBlockingCall()\n");

    int rv = 0;
    __try {
        rv = Real_WSACancelBlockingCall();
    } __finally {
        _PrintExit("WSACancelBlockingCall() -> %p\n", rv);
    };
    return rv;
}

int __stdcall Mine_WSACleanup(void)
{
    _PrintEnter("WSACleanup()\n");

    int rv = 0;
    __try {
        rv = Real_WSACleanup();
    } __finally {
        _PrintExit("WSACleanup() -> %p\n", rv);
    };
    return rv;
}

BOOL __stdcall Mine_WSACloseEvent(HANDLE a0)
{
    _PrintEnter("WSACloseEvent(%p)\n", a0);

    BOOL rv = 0;
    __try {
        rv = Real_WSACloseEvent(a0);
    } __finally {
        _PrintExit("WSACloseEvent() -> %p\n", rv);
    };
    return rv;
}

int __stdcall Mine_WSAConnect(SOCKET a0,
                              sockaddr* a1,
                              int a2,
                              LPWSABUF a3,
                              LPWSABUF a4,
                              LPQOS a5,
                              LPQOS a6)
{
    _PrintEnter("WSAConnect(%p,%p,%p,%p,%p,%p,%p)\n", a0, a1, a2, a3, a4, a5, a6);

    int rv = 0;
    __try {
        rv = Real_WSAConnect(a0, a1, a2, a3, a4, a5, a6);
    } __finally {
        _PrintExit("WSAConnect(,,,,,,) -> %p\n", rv);
    };
    return rv;
}

HANDLE __stdcall Mine_WSACreateEvent(void)
{
    _PrintEnter("WSACreateEvent()\n");

    HANDLE rv = 0;
    __try {
        rv = Real_WSACreateEvent();
    } __finally {
        _PrintExit("WSACreateEvent() -> %p\n", rv);
    };
    return rv;
}

int __stdcall Mine_WSADuplicateSocketA(SOCKET a0,
                                       DWORD a1,
                                       LPWSAPROTOCOL_INFOA a2)
{
    _PrintEnter("WSADuplicateSocketA(%p,%p,%p)\n", a0, a1, a2);

    int rv = 0;
    __try {
        rv = Real_WSADuplicateSocketA(a0, a1, a2);
    } __finally {
        _PrintExit("WSADuplicateSocketA(,,) -> %p\n", rv);
    };
    return rv;
}

int __stdcall Mine_WSADuplicateSocketW(SOCKET a0,
                                       DWORD a1,
                                       LPWSAPROTOCOL_INFOW a2)
{
    _PrintEnter("WSADuplicateSocketW(%p,%p,%p)\n", a0, a1, a2);

    int rv = 0;
    __try {
        rv = Real_WSADuplicateSocketW(a0, a1, a2);
    } __finally {
        _PrintExit("WSADuplicateSocketW(,,) -> %p\n", rv);
    };
    return rv;
}

INT __stdcall Mine_WSAEnumNameSpaceProvidersA(LPDWORD a0,
                                              LPWSANAMESPACE_INFOA a1)
{
    _PrintEnter("WSAEnumNameSpaceProvidersA(%p,%p)\n", a0, a1);

    INT rv = 0;
    __try {
        rv = Real_WSAEnumNameSpaceProvidersA(a0, a1);
    } __finally {
        _PrintExit("WSAEnumNameSpaceProvidersA(,) -> %p\n", rv);
    };
    return rv;
}

INT __stdcall Mine_WSAEnumNameSpaceProvidersW(LPDWORD a0,
                                              LPWSANAMESPACE_INFOW a1)
{
    _PrintEnter("WSAEnumNameSpaceProvidersW(%p,%p)\n", a0, a1);

    INT rv = 0;
    __try {
        rv = Real_WSAEnumNameSpaceProvidersW(a0, a1);
    } __finally {
        _PrintExit("WSAEnumNameSpaceProvidersW(,) -> %p\n", rv);
    };
    return rv;
}

int __stdcall Mine_WSAEnumNetworkEvents(SOCKET a0,
                                        HANDLE a1,
                                        LPWSANETWORKEVENTS a2)
{
    _PrintEnter("WSAEnumNetworkEvents(%p,%p,%p)\n", a0, a1, a2);

    int rv = 0;
    __try {
        rv = Real_WSAEnumNetworkEvents(a0, a1, a2);
    } __finally {
        _PrintExit("WSAEnumNetworkEvents(,,) -> %p\n", rv);
    };
    return rv;
}

int __stdcall Mine_WSAEnumProtocolsA(LPINT a0,
                                     LPWSAPROTOCOL_INFOA a1,
                                     LPDWORD a2)
{
    _PrintEnter("WSAEnumProtocolsA(%p,%p,%p)\n", a0, a1, a2);

    int rv = 0;
    __try {
        rv = Real_WSAEnumProtocolsA(a0, a1, a2);
    } __finally {
        _PrintExit("WSAEnumProtocolsA(,,) -> %p\n", rv);
    };
    return rv;
}

int __stdcall Mine_WSAEnumProtocolsW(LPINT a0,
                                     LPWSAPROTOCOL_INFOW a1,
                                     LPDWORD a2)
{
    _PrintEnter("WSAEnumProtocolsW(%p,%p,%p)\n", a0, a1, a2);

    int rv = 0;
    __try {
        rv = Real_WSAEnumProtocolsW(a0, a1, a2);
    } __finally {
        _PrintExit("WSAEnumProtocolsW(,,) -> %p\n", rv);
    };
    return rv;
}

int __stdcall Mine_WSAEventSelect(SOCKET a0,
                                  HANDLE a1,
                                  long a2)
{
    _PrintEnter("WSAEventSelect(%p,%p,%p)\n", a0, a1, a2);

    int rv = 0;
    __try {
        rv = Real_WSAEventSelect(a0, a1, a2);
    } __finally {
        _PrintExit("WSAEventSelect(,,) -> %p\n", rv);
    };
    return rv;
}

BOOL __stdcall Mine_WSAGetOverlappedResult(SOCKET a0,
                                           LPWSAOVERLAPPED a1,
                                           LPDWORD a2,
                                           BOOL a3,
                                           LPDWORD a4)
{
    _PrintEnter("WSAGetOverlappedResult(%p,%p,%p,%p,%p)\n", a0, a1, a2, a3, a4);

    BOOL rv = 0;
    __try {
        rv = Real_WSAGetOverlappedResult(a0, a1, a2, a3, a4);
    } __finally {
        _PrintExit("WSAGetOverlappedResult(,,,,) -> %p\n", rv);
    };
    return rv;
}

BOOL __stdcall Mine_WSAGetQOSByName(SOCKET a0,
                                    LPWSABUF a1,
                                    LPQOS a2)
{
    _PrintEnter("WSAGetQOSByName(%p,%p,%p)\n", a0, a1, a2);

    BOOL rv = 0;
    __try {
        rv = Real_WSAGetQOSByName(a0, a1, a2);
    } __finally {
        _PrintExit("WSAGetQOSByName(,,) -> %p\n", rv);
    };
    return rv;
}

INT __stdcall Mine_WSAGetServiceClassInfoA(LPGUID a0,
                                           LPGUID a1,
                                           LPDWORD a2,
                                           LPWSASERVICECLASSINFOA a3)
{
    _PrintEnter("WSAGetServiceClassInfoA(%p,%p,%p,%p)\n", a0, a1, a2, a3);

    INT rv = 0;
    __try {
        rv = Real_WSAGetServiceClassInfoA(a0, a1, a2, a3);
    } __finally {
        _PrintExit("WSAGetServiceClassInfoA(,,,) -> %p\n", rv);
    };
    return rv;
}

INT __stdcall Mine_WSAGetServiceClassInfoW(LPGUID a0,
                                           LPGUID a1,
                                           LPDWORD a2,
                                           LPWSASERVICECLASSINFOW a3)
{
    _PrintEnter("WSAGetServiceClassInfoW(%p,%p,%p,%p)\n", a0, a1, a2, a3);

    INT rv = 0;
    __try {
        rv = Real_WSAGetServiceClassInfoW(a0, a1, a2, a3);
    } __finally {
        _PrintExit("WSAGetServiceClassInfoW(,,,) -> %p\n", rv);
    };
    return rv;
}

INT __stdcall Mine_WSAGetServiceClassNameByClassIdA(LPGUID a0,
                                                    LPSTR a1,
                                                    LPDWORD a2)
{
    _PrintEnter("WSAGetServiceClassNameByClassIdA(%p,%p,%p)\n", a0, a1, a2);

    INT rv = 0;
    __try {
        rv = Real_WSAGetServiceClassNameByClassIdA(a0, a1, a2);
    } __finally {
        _PrintExit("WSAGetServiceClassNameByClassIdA(,,) -> %p\n", rv);
    };
    return rv;
}

INT __stdcall Mine_WSAGetServiceClassNameByClassIdW(LPGUID a0,
                                                    LPWSTR a1,
                                                    LPDWORD a2)
{
    _PrintEnter("WSAGetServiceClassNameByClassIdW(%p,%p,%p)\n", a0, a1, a2);

    INT rv = 0;
    __try {
        rv = Real_WSAGetServiceClassNameByClassIdW(a0, a1, a2);
    } __finally {
        _PrintExit("WSAGetServiceClassNameByClassIdW(,,) -> %p\n", rv);
    };
    return rv;
}

int __stdcall Mine_WSAHtonl(SOCKET a0,
                            u_long a1,
                            u_long* a2)
{
    _PrintEnter("WSAHtonl(%p,%p,%p)\n", a0, a1, a2);

    int rv = 0;
    __try {
        rv = Real_WSAHtonl(a0, a1, a2);
    } __finally {
        _PrintExit("WSAHtonl(,,) -> %p\n", rv);
    };
    return rv;
}

int __stdcall Mine_WSAHtons(SOCKET a0,
                            u_short a1,
                            u_short* a2)
{
    _PrintEnter("WSAHtons(%p,%p,%p)\n", a0, a1, a2);

    int rv = 0;
    __try {
        rv = Real_WSAHtons(a0, a1, a2);
    } __finally {
        _PrintExit("WSAHtons(,,) -> %p\n", rv);
    };
    return rv;
}

INT __stdcall Mine_WSAInstallServiceClassA(LPWSASERVICECLASSINFOA a0)
{
    _PrintEnter("WSAInstallServiceClassA(%p)\n", a0);

    INT rv = 0;
    __try {
        rv = Real_WSAInstallServiceClassA(a0);
    } __finally {
        _PrintExit("WSAInstallServiceClassA() -> %p\n", rv);
    };
    return rv;
}

INT __stdcall Mine_WSAInstallServiceClassW(LPWSASERVICECLASSINFOW a0)
{
    _PrintEnter("WSAInstallServiceClassW(%p)\n", a0);

    INT rv = 0;
    __try {
        rv = Real_WSAInstallServiceClassW(a0);
    } __finally {
        _PrintExit("WSAInstallServiceClassW() -> %p\n", rv);
    };
    return rv;
}

int __stdcall Mine_WSAIoctl(SOCKET a0,
                            DWORD a1,
                            LPVOID a2,
                            DWORD a3,
                            LPVOID a4,
                            DWORD a5,
                            LPDWORD a6,
                            LPWSAOVERLAPPED a7,
                            LPWSAOVERLAPPED_COMPLETION_ROUTINE a8)
{
    _PrintEnter("WSAIoctl(%p,%p,%p,%p,%p,%p,%p,%p,%p)\n", a0, a1, a2, a3, a4, a5, a6, a7, a8);

    int rv = 0;
    __try {
        rv = Real_WSAIoctl(a0, a1, a2, a3, a4, a5, a6, a7, a8);
    } __finally {
        _PrintExit("WSAIoctl(,,,,,,,,) -> %p\n", rv);
    };
    return rv;
}

BOOL __stdcall Mine_WSAIsBlocking(void)
{
    _PrintEnter("WSAIsBlocking()\n");

    BOOL rv = 0;
    __try {
        rv = Real_WSAIsBlocking();
    } __finally {
        _PrintExit("WSAIsBlocking() -> %p\n", rv);
    };
    return rv;
}

SOCKET __stdcall Mine_WSAJoinLeaf(SOCKET a0,
                                  sockaddr* a1,
                                  int a2,
                                  LPWSABUF a3,
                                  LPWSABUF a4,
                                  LPQOS a5,
                                  LPQOS a6,
                                  DWORD a7)
{
    _PrintEnter("WSAJoinLeaf(%p,%p,%p,%p,%p,%p,%p,%p)\n", a0, a1, a2, a3, a4, a5, a6, a7);

    SOCKET rv = 0;
    __try {
        rv = Real_WSAJoinLeaf(a0, a1, a2, a3, a4, a5, a6, a7);
    } __finally {
        _PrintExit("WSAJoinLeaf(,,,,,,,) -> %p\n", rv);
    };
    return rv;
}

INT __stdcall Mine_WSALookupServiceBeginA(LPWSAQUERYSETA a0,
                                          DWORD a1,
                                          LPHANDLE a2)
{
    _PrintEnter("WSALookupServiceBeginA(%p,%p,%p)\n", a0, a1, a2);

    INT rv = 0;
    __try {
        rv = Real_WSALookupServiceBeginA(a0, a1, a2);
    } __finally {
        _PrintExit("WSALookupServiceBeginA(,,) -> %p\n", rv);
    };
    return rv;
}

INT __stdcall Mine_WSALookupServiceBeginW(LPWSAQUERYSETW a0,
                                          DWORD a1,
                                          LPHANDLE a2)
{
    _PrintEnter("WSALookupServiceBeginW(%p,%p,%p)\n", a0, a1, a2);

    INT rv = 0;
    __try {
        rv = Real_WSALookupServiceBeginW(a0, a1, a2);
    } __finally {
        _PrintExit("WSALookupServiceBeginW(,,) -> %p\n", rv);
    };
    return rv;
}

INT __stdcall Mine_WSALookupServiceEnd(HANDLE a0)
{
    _PrintEnter("WSALookupServiceEnd(%p)\n", a0);

    INT rv = 0;
    __try {
        rv = Real_WSALookupServiceEnd(a0);
    } __finally {
        _PrintExit("WSALookupServiceEnd() -> %p\n", rv);
    };
    return rv;
}

INT __stdcall Mine_WSALookupServiceNextA(HANDLE a0,
                                         DWORD a1,
                                         LPDWORD a2,
                                         LPWSAQUERYSETA a3)
{
    _PrintEnter("WSALookupServiceNextA(%p,%p,%p,%p)\n", a0, a1, a2, a3);

    INT rv = 0;
    __try {
        rv = Real_WSALookupServiceNextA(a0, a1, a2, a3);
    } __finally {
        _PrintExit("WSALookupServiceNextA(,,,) -> %p\n", rv);
    };
    return rv;
}

INT __stdcall Mine_WSALookupServiceNextW(HANDLE a0,
                                         DWORD a1,
                                         LPDWORD a2,
                                         LPWSAQUERYSETW a3)
{
    _PrintEnter("WSALookupServiceNextW(%p,%p,%p,%p)\n", a0, a1, a2, a3);

    INT rv = 0;
    __try {
        rv = Real_WSALookupServiceNextW(a0, a1, a2, a3);
    } __finally {
        _PrintExit("WSALookupServiceNextW(,,,) -> %p\n", rv);
    };
    return rv;
}

int __stdcall Mine_WSANtohl(SOCKET a0,
                            u_long a1,
                            u_long* a2)
{
    _PrintEnter("WSANtohl(%p,%p,%p)\n", a0, a1, a2);

    int rv = 0;
    __try {
        rv = Real_WSANtohl(a0, a1, a2);
    } __finally {
        _PrintExit("WSANtohl(,,) -> %p\n", rv);
    };
    return rv;
}

int __stdcall Mine_WSANtohs(SOCKET a0,
                            u_short a1,
                            u_short* a2)
{
    _PrintEnter("WSANtohs(%p,%p,%p)\n", a0, a1, a2);

    int rv = 0;
    __try {
        rv = Real_WSANtohs(a0, a1, a2);
    } __finally {
        _PrintExit("WSANtohs(,,) -> %p\n", rv);
    };
    return rv;
}

INT __stdcall Mine_WSAProviderConfigChange(LPHANDLE a0,
                                           LPWSAOVERLAPPED a1,
                                           LPWSAOVERLAPPED_COMPLETION_ROUTINE a2)
{
    _PrintEnter("WSAProviderConfigChange(%p,%p,%p)\n", a0, a1, a2);

    INT rv = 0;
    __try {
        rv = Real_WSAProviderConfigChange(a0, a1, a2);
    } __finally {
        _PrintExit("WSAProviderConfigChange(,,) -> %p\n", rv);
    };
    return rv;
}

int __stdcall Mine_WSARecv(SOCKET a0,
                           LPWSABUF a1,
                           DWORD a2,
                           LPDWORD a3,
                           LPDWORD a4,
                           LPWSAOVERLAPPED a5,
                           LPWSAOVERLAPPED_COMPLETION_ROUTINE a6)
{
    _PrintEnter("WSARecv(%p,%p,%p,%p,%p,%p,%p)\n", a0, a1, a2, a3, a4, a5, a6);

    int rv = 0;
    __try {
        rv = Real_WSARecv(a0, a1, a2, a3, a4, a5, a6);
    } __finally {
        _PrintExit("WSARecv(,,,,,,) -> %p\n", rv);
    };
    return rv;
}

int __stdcall Mine_WSARecvDisconnect(SOCKET a0,
                                     LPWSABUF a1)
{
    _PrintEnter("WSARecvDisconnect(%p,%p)\n", a0, a1);

    int rv = 0;
    __try {
        rv = Real_WSARecvDisconnect(a0, a1);
    } __finally {
        _PrintExit("WSARecvDisconnect(,) -> %p\n", rv);
    };
    return rv;
}

int __stdcall Mine_WSARecvFrom(SOCKET a0,
                               LPWSABUF a1,
                               DWORD a2,
                               LPDWORD a3,
                               LPDWORD a4,
                               sockaddr* a5,
                               LPINT a6,
                               LPWSAOVERLAPPED a7,
                               LPWSAOVERLAPPED_COMPLETION_ROUTINE a8)
{
    _PrintEnter("WSARecvFrom(%p,%p,%p,%p,%p,%p,%p,%p,%p)\n", a0, a1, a2, a3, a4, a5, a6, a7, a8);

    int rv = 0;
    __try {
        rv = Real_WSARecvFrom(a0, a1, a2, a3, a4, a5, a6, a7, a8);
    } __finally {
        _PrintExit("WSARecvFrom(,,,,,,,,) -> %p\n", rv);
    };
    return rv;
}

INT __stdcall Mine_WSARemoveServiceClass(LPGUID a0)
{
    _PrintEnter("WSARemoveServiceClass(%p)\n", a0);

    INT rv = 0;
    __try {
        rv = Real_WSARemoveServiceClass(a0);
    } __finally {
        _PrintExit("WSARemoveServiceClass() -> %p\n", rv);
    };
    return rv;
}

BOOL __stdcall Mine_WSAResetEvent(HANDLE a0)
{
    _PrintEnter("WSAResetEvent(%p)\n", a0);

    BOOL rv = 0;
    __try {
        rv = Real_WSAResetEvent(a0);
    } __finally {
        _PrintExit("WSAResetEvent() -> %p\n", rv);
    };
    return rv;
}

int __stdcall Mine_WSASend(SOCKET a0,
                           LPWSABUF a1,
                           DWORD a2,
                           LPDWORD a3,
                           DWORD a4,
                           LPWSAOVERLAPPED a5,
                           LPWSAOVERLAPPED_COMPLETION_ROUTINE a6)
{
    _PrintEnter("WSASend(%p,%p,%p,%p,%p,%p,%p)\n", a0, a1, a2, a3, a4, a5, a6);

    int rv = 0;
    __try {
        rv = Real_WSASend(a0, a1, a2, a3, a4, a5, a6);
    } __finally {
        _PrintExit("WSASend(,,,,,,) -> %p\n", rv);
    };
    return rv;
}

int __stdcall Mine_WSASendDisconnect(SOCKET a0,
                                     LPWSABUF a1)
{
    _PrintEnter("WSASendDisconnect(%p,%p)\n", a0, a1);

    int rv = 0;
    __try {
        rv = Real_WSASendDisconnect(a0, a1);
    } __finally {
        _PrintExit("WSASendDisconnect(,) -> %p\n", rv);
    };
    return rv;
}

int __stdcall Mine_WSASendTo(SOCKET a0,
                             LPWSABUF a1,
                             DWORD a2,
                             LPDWORD a3,
                             DWORD a4,
                             sockaddr* a5,
                             int a6,
                             LPWSAOVERLAPPED a7,
                             LPWSAOVERLAPPED_COMPLETION_ROUTINE a8)
{
    _PrintEnter("WSASendTo(%p,%p,%p,%p,%p,%p,%p,%p,%p)\n", a0, a1, a2, a3, a4, a5, a6, a7, a8);

    int rv = 0;
    __try {
        rv = Real_WSASendTo(a0, a1, a2, a3, a4, a5, a6, a7, a8);
    } __finally {
        _PrintExit("WSASendTo(,,,,,,,,) -> %p\n", rv);
    };
    return rv;
}

FARPROC __stdcall Mine_WSASetBlockingHook(FARPROC a0)
{
    _PrintEnter("WSASetBlockingHook(%p)\n", a0);

    FARPROC rv = 0;
    __try {
        rv = Real_WSASetBlockingHook(a0);
    } __finally {
        _PrintExit("WSASetBlockingHook() -> %p\n", rv);
    };
    return rv;
}

BOOL __stdcall Mine_WSASetEvent(HANDLE a0)
{
    _PrintEnter("WSASetEvent(%p)\n", a0);

    BOOL rv = 0;
    __try {
        rv = Real_WSASetEvent(a0);
    } __finally {
        _PrintExit("WSASetEvent() -> %p\n", rv);
    };
    return rv;
}

INT __stdcall Mine_WSASetServiceA(LPWSAQUERYSETA a0,
                                  WSAESETSERVICEOP a1,
                                  DWORD a2)
{
    _PrintEnter("WSASetServiceA(%p,%p,%p)\n", a0, a1, a2);

    INT rv = 0;
    __try {
        rv = Real_WSASetServiceA(a0, a1, a2);
    } __finally {
        _PrintExit("WSASetServiceA(,,) -> %p\n", rv);
    };
    return rv;
}

INT __stdcall Mine_WSASetServiceW(LPWSAQUERYSETW a0,
                                  WSAESETSERVICEOP a1,
                                  DWORD a2)
{
    _PrintEnter("WSASetServiceW(%p,%p,%p)\n", a0, a1, a2);

    INT rv = 0;
    __try {
        rv = Real_WSASetServiceW(a0, a1, a2);
    } __finally {
        _PrintExit("WSASetServiceW(,,) -> %p\n", rv);
    };
    return rv;
}

SOCKET __stdcall Mine_WSASocketA(int a0,
                                 int a1,
                                 int a2,
                                 LPWSAPROTOCOL_INFOA a3,
                                 GROUP a4,
                                 DWORD a5)
{
    _PrintEnter("WSASocketA(%p,%p,%p,%p,%p,%p)\n", a0, a1, a2, a3, a4, a5);

    SOCKET rv = 0;
    __try {
        rv = Real_WSASocketA(a0, a1, a2, a3, a4, a5);
    } __finally {
        _PrintExit("WSASocketA(,,,,,) -> %p\n", rv);
    };
    return rv;
}

SOCKET __stdcall Mine_WSASocketW(int a0,
                                 int a1,
                                 int a2,
                                 LPWSAPROTOCOL_INFOW a3,
                                 GROUP a4,
                                 DWORD a5)
{
    _PrintEnter("WSASocketW(%p,%p,%p,%p,%p,%p)\n", a0, a1, a2, a3, a4, a5);

    SOCKET rv = 0;
    __try {
        rv = Real_WSASocketW(a0, a1, a2, a3, a4, a5);
    } __finally {
        _PrintExit("WSASocketW(,,,,,) -> %p\n", rv);
    };
    return rv;
}

int __stdcall Mine_WSAStartup(WORD a0,
                              LPWSADATA a1)
{
    _PrintEnter("WSAStartup(%p,%p)\n", a0, a1);

    int rv = 0;
    __try {
        rv = Real_WSAStartup(a0, a1);
    } __finally {
        _PrintExit("WSAStartup(,) -> %p\n", rv);
    };
    return rv;
}

INT __stdcall Mine_WSAStringToAddressA(LPSTR a0,
                                       INT a1,
                                       LPWSAPROTOCOL_INFOA a2,
                                       LPSOCKADDR a3,
                                       LPINT a4)
{
    _PrintEnter("WSAStringToAddressA(%p,%p,%p,%p,%p)\n", a0, a1, a2, a3, a4);

    INT rv = 0;
    __try {
        rv = Real_WSAStringToAddressA(a0, a1, a2, a3, a4);
    } __finally {
        _PrintExit("WSAStringToAddressA(,,,,) -> %p\n", rv);
    };
    return rv;
}

INT __stdcall Mine_WSAStringToAddressW(LPWSTR a0,
                                       INT a1,
                                       LPWSAPROTOCOL_INFOW a2,
                                       LPSOCKADDR a3,
                                       LPINT a4)
{
    _PrintEnter("WSAStringToAddressW(%p,%p,%p,%p,%p)\n", a0, a1, a2, a3, a4);

    INT rv = 0;
    __try {
        rv = Real_WSAStringToAddressW(a0, a1, a2, a3, a4);
    } __finally {
        _PrintExit("WSAStringToAddressW(,,,,) -> %p\n", rv);
    };
    return rv;
}

int __stdcall Mine_WSAUnhookBlockingHook(void)
{
    _PrintEnter("WSAUnhookBlockingHook()\n");

    int rv = 0;
    __try {
        rv = Real_WSAUnhookBlockingHook();
    } __finally {
        _PrintExit("WSAUnhookBlockingHook() -> %p\n", rv);
    };
    return rv;
}

DWORD __stdcall Mine_WSAWaitForMultipleEvents(DWORD a0,
                                              void** a1,
                                              BOOL a2,
                                              DWORD a3,
                                              BOOL a4)
{
    _PrintEnter("WSAWaitForMultipleEvents(%p,%p,%p,%p,%p)\n", a0, a1, a2, a3, a4);

    DWORD rv = 0;
    __try {
        rv = Real_WSAWaitForMultipleEvents(a0, a1, a2, a3, a4);
    } __finally {
        _PrintExit("WSAWaitForMultipleEvents(,,,,) -> %p\n", rv);
    };
    return rv;
}

BOOL __stdcall Mine_WaitCommEvent(HANDLE a0,
                                  LPDWORD a1,
                                  LPOVERLAPPED a2)
{
    _PrintEnter("WaitCommEvent(%p,%p,%p)\n", a0, a1, a2);

    BOOL rv = 0;
    __try {
        rv = Real_WaitCommEvent(a0, a1, a2);
    } __finally {
        _PrintExit("WaitCommEvent(,,) -> %p\n", rv);
    };
    return rv;
}

#if !defined(DETOURS_ARM)
BOOL __stdcall Mine_WaitForDebugEvent(LPDEBUG_EVENT a0,
                                      DWORD a1)
{
    _PrintEnter("WaitForDebugEvent(%p,%p)\n", a0, a1);

    BOOL rv = 0;
    __try {
        rv = Real_WaitForDebugEvent(a0, a1);
    } __finally {
        if (rv) {
            _PrintExit("WaitForDebugEvent(%d,) -> %p\n", a0->dwDebugEventCode, rv);
        }
        else {
            _PrintExit("WaitForDebugEvent(,) -> %p\n", rv);
        }
    };
    return rv;
}
#endif // !DETOURS_ARM

DWORD __stdcall Mine_WaitForInputIdle(HANDLE a0,
                                      DWORD a1)
{
    _PrintEnter("WaitForInputIdle(%p,%p)\n", a0, a1);

    DWORD rv = 0;
    __try {
        rv = Real_WaitForInputIdle(a0, a1);
    } __finally {
        _PrintExit("WaitForInputIdle(,) -> %p\n", rv);
    };
    return rv;
}

DWORD __stdcall Mine_WaitForMultipleObjects(DWORD a0,
                                            void** a1,
                                            BOOL a2,
                                            DWORD a3)
{
    _PrintEnter("WaitForMultipleObjects(%p,%p,%p,%p)\n", a0, a1, a2, a3);

    DWORD rv = 0;
    __try {
        rv = Real_WaitForMultipleObjects(a0, a1, a2, a3);
    } __finally {
        _PrintExit("WaitForMultipleObjects(,,,) -> %p\n", rv);
    };
    return rv;
}

DWORD __stdcall Mine_WaitForMultipleObjectsEx(DWORD a0,
                                              void** a1,
                                              BOOL a2,
                                              DWORD a3,
                                              BOOL a4)
{
    _PrintEnter("WaitForMultipleObjectsEx(%p,%p,%p,%p,%p)\n", a0, a1, a2, a3, a4);

    DWORD rv = 0;
    __try {
        rv = Real_WaitForMultipleObjectsEx(a0, a1, a2, a3, a4);
    } __finally {
        _PrintExit("WaitForMultipleObjectsEx(,,,,) -> %p\n", rv);
    };
    return rv;
}

DWORD __stdcall Mine_WaitForSingleObject(HANDLE a0,
                                         DWORD a1)
{
    _PrintEnter("WaitForSingleObject(%p,%p)\n", a0, a1);

    DWORD rv = 0;
    __try {
        rv = Real_WaitForSingleObject(a0, a1);
    } __finally {
        _PrintExit("WaitForSingleObject(,) -> %p\n", rv);
    };
    return rv;
}

DWORD __stdcall Mine_WaitForSingleObjectEx(HANDLE a0,
                                           DWORD a1,
                                           BOOL a2)
{
    _PrintEnter("WaitForSingleObjectEx(%p,%p,%p)\n", a0, a1, a2);

    DWORD rv = 0;
    __try {
        rv = Real_WaitForSingleObjectEx(a0, a1, a2);
    } __finally {
        _PrintExit("WaitForSingleObjectEx(,,) -> %p\n", rv);
    };
    return rv;
}

BOOL __stdcall Mine_WaitMessage(void)
{
    _PrintEnter("WaitMessage()\n");

    BOOL rv = 0;
    __try {
        rv = Real_WaitMessage();
    } __finally {
        _PrintExit("WaitMessage() -> %p\n", rv);
    };
    return rv;
}

BOOL __stdcall Mine_WaitNamedPipeA(LPCSTR a0,
                                   DWORD a1)
{
    _PrintEnter("WaitNamedPipeA(%hs,%p)\n", a0, a1);

    BOOL rv = 0;
    __try {
        rv = Real_WaitNamedPipeA(a0, a1);
    } __finally {
        _PrintExit("WaitNamedPipeA(,) -> %p\n", rv);
    };
    return rv;
}

BOOL __stdcall Mine_WaitNamedPipeW(LPCWSTR a0,
                                   DWORD a1)
{
    _PrintEnter("WaitNamedPipeW(%ls,%p)\n", a0, a1);

    BOOL rv = 0;
    __try {
        rv = Real_WaitNamedPipeW(a0, a1);
    } __finally {
        _PrintExit("WaitNamedPipeW(,) -> %p\n", rv);
    };
    return rv;
}

BOOL __stdcall Mine_WidenPath(HDC a0)
{
    _PrintEnter("WidenPath(%p)\n", a0);

    BOOL rv = 0;
    __try {
        rv = Real_WidenPath(a0);
    } __finally {
        _PrintExit("WidenPath() -> %p\n", rv);
    };
    return rv;
}

UINT __stdcall Mine_WinExec(LPCSTR a0,
                            UINT a1)
{
    _PrintEnter("WinExec(%hs,%p)\n", a0, a1);

    UINT rv = 0;
    __try {
        rv = Real_WinExec(a0, a1);
    } __finally {
        _PrintExit("WinExec(,) -> %p\n", rv);
    };
    return rv;
}

BOOL __stdcall Mine_WinHelpA(HWND a0,
                             LPCSTR a1,
                             UINT a2,
                             ULONG_PTR a3)
{
    _PrintEnter("WinHelpA(%p,%hs,%p,%p)\n", a0, a1, a2, a3);

    BOOL rv = 0;
    __try {
        rv = Real_WinHelpA(a0, a1, a2, a3);
    } __finally {
        _PrintExit("WinHelpA(,,,) -> %p\n", rv);
    };
    return rv;
}

BOOL __stdcall Mine_WinHelpW(HWND a0,
                             LPCWSTR a1,
                             UINT a2,
                             ULONG_PTR a3)
{
    _PrintEnter("WinHelpW(%p,%ls,%p,%p)\n", a0, a1, a2, a3);

    BOOL rv = 0;
    __try {
        rv = Real_WinHelpW(a0, a1, a2, a3);
    } __finally {
        _PrintExit("WinHelpW(,,,) -> %p\n", rv);
    };
    return rv;
}

HWND __stdcall Mine_WindowFromDC(HDC a0)
{
    _PrintEnter("WindowFromDC(%p)\n", a0);

    HWND rv = 0;
    __try {
        rv = Real_WindowFromDC(a0);
    } __finally {
        _PrintExit("WindowFromDC() -> %p\n", rv);
    };
    return rv;
}

HWND __stdcall Mine_WindowFromPoint(POINT a0)
{
    _PrintEnter("WindowFromPoint(%p)\n", a0);

    HWND rv = 0;
    __try {
        rv = Real_WindowFromPoint(a0);
    } __finally {
        _PrintExit("WindowFromPoint() -> %p\n", rv);
    };
    return rv;
}

HRESULT __stdcall Mine_WriteClassStg(LPSTORAGE a0,
                                     CONST IID& a1)
{
    _PrintEnter("WriteClassStg(%p,%p)\n", a0, a1);

    HRESULT rv = 0;
    __try {
        rv = Real_WriteClassStg(a0, a1);
    } __finally {
        _PrintExit("WriteClassStg(,) -> %p\n", rv);
    };
    return rv;
}

HRESULT __stdcall Mine_WriteClassStm(LPSTREAM a0,
                                     CONST IID& a1)
{
    _PrintEnter("WriteClassStm(%p,%p)\n", a0, a1);

    HRESULT rv = 0;
    __try {
        rv = Real_WriteClassStm(a0, a1);
    } __finally {
        _PrintExit("WriteClassStm(,) -> %p\n", rv);
    };
    return rv;
}

BOOL __stdcall Mine_WriteConsoleA(HANDLE a0,
                                  void* a1,
                                  DWORD a2,
                                  LPDWORD a3,
                                  LPVOID a4)
{
    _PrintEnter("WriteConsoleA(%p,%p,%p,%p,%p)\n", a0, a1, a2, a3, a4);

    BOOL rv = 0;
    __try {
        rv = Real_WriteConsoleA(a0, a1, a2, a3, a4);
    } __finally {
        _PrintExit("WriteConsoleA(,,,,) -> %p\n", rv);
    };
    return rv;
}

BOOL __stdcall Mine_WriteConsoleInputA(HANDLE a0,
                                       INPUT_RECORD* a1,
                                       DWORD a2,
                                       LPDWORD a3)
{
    _PrintEnter("WriteConsoleInputA(%p,%p,%p,%p)\n", a0, a1, a2, a3);

    BOOL rv = 0;
    __try {
        rv = Real_WriteConsoleInputA(a0, a1, a2, a3);
    } __finally {
        _PrintExit("WriteConsoleInputA(,,,) -> %p\n", rv);
    };
    return rv;
}

BOOL __stdcall Mine_WriteConsoleInputW(HANDLE a0,
                                       INPUT_RECORD* a1,
                                       DWORD a2,
                                       LPDWORD a3)
{
    _PrintEnter("WriteConsoleInputW(%p,%p,%p,%p)\n", a0, a1, a2, a3);

    BOOL rv = 0;
    __try {
        rv = Real_WriteConsoleInputW(a0, a1, a2, a3);
    } __finally {
        _PrintExit("WriteConsoleInputW(,,,) -> %p\n", rv);
    };
    return rv;
}

BOOL __stdcall Mine_WriteConsoleOutputA(HANDLE a0,
                                        CHAR_INFO* a1,
                                        COORD a2,
                                        COORD a3,
                                        PSMALL_RECT a4)
{
    _PrintEnter("WriteConsoleOutputA(%p,%p,%p,%p,%p)\n", a0, a1, a2, a3, a4);

    BOOL rv = 0;
    __try {
        rv = Real_WriteConsoleOutputA(a0, a1, a2, a3, a4);
    } __finally {
        _PrintExit("WriteConsoleOutputA(,,,,) -> %p\n", rv);
    };
    return rv;
}

BOOL __stdcall Mine_WriteConsoleOutputAttribute(HANDLE a0,
                                                WORD* a1,
                                                DWORD a2,
                                                COORD a3,
                                                LPDWORD a4)
{
    _PrintEnter("WriteConsoleOutputAttribute(%p,%p,%p,%p,%p)\n", a0, a1, a2, a3, a4);

    BOOL rv = 0;
    __try {
        rv = Real_WriteConsoleOutputAttribute(a0, a1, a2, a3, a4);
    } __finally {
        _PrintExit("WriteConsoleOutputAttribute(,,,,) -> %p\n", rv);
    };
    return rv;
}

BOOL __stdcall Mine_WriteConsoleOutputCharacterA(HANDLE a0,
                                                 LPCSTR a1,
                                                 DWORD a2,
                                                 COORD a3,
                                                 LPDWORD a4)
{
    _PrintEnter("WriteConsoleOutputCharacterA(%p,%hs,%p,%p,%p)\n", a0, a1, a2, a3, a4);

    BOOL rv = 0;
    __try {
        rv = Real_WriteConsoleOutputCharacterA(a0, a1, a2, a3, a4);
    } __finally {
        _PrintExit("WriteConsoleOutputCharacterA(,,,,) -> %p\n", rv);
    };
    return rv;
}

BOOL __stdcall Mine_WriteConsoleOutputCharacterW(HANDLE a0,
                                                 LPCWSTR a1,
                                                 DWORD a2,
                                                 COORD a3,
                                                 LPDWORD a4)
{
    _PrintEnter("WriteConsoleOutputCharacterW(%p,%ls,%p,%p,%p)\n", a0, a1, a2, a3, a4);

    BOOL rv = 0;
    __try {
        rv = Real_WriteConsoleOutputCharacterW(a0, a1, a2, a3, a4);
    } __finally {
        _PrintExit("WriteConsoleOutputCharacterW(,,,,) -> %p\n", rv);
    };
    return rv;
}

BOOL __stdcall Mine_WriteConsoleOutputW(HANDLE a0,
                                        CHAR_INFO* a1,
                                        COORD a2,
                                        COORD a3,
                                        PSMALL_RECT a4)
{
    _PrintEnter("WriteConsoleOutputW(%p,%p,%p,%p,%p)\n", a0, a1, a2, a3, a4);

    BOOL rv = 0;
    __try {
        rv = Real_WriteConsoleOutputW(a0, a1, a2, a3, a4);
    } __finally {
        _PrintExit("WriteConsoleOutputW(,,,,) -> %p\n", rv);
    };
    return rv;
}

BOOL __stdcall Mine_WriteConsoleW(HANDLE a0,
                                  void* a1,
                                  DWORD a2,
                                  LPDWORD a3,
                                  LPVOID a4)
{
    _PrintEnter("WriteConsoleW(%p,%p,%p,%p,%p)\n", a0, a1, a2, a3, a4);

    BOOL rv = 0;
    __try {
        rv = Real_WriteConsoleW(a0, a1, a2, a3, a4);
    } __finally {
        _PrintExit("WriteConsoleW(,,,,) -> %p\n", rv);
    };
    return rv;
}

BOOL __stdcall Mine_WriteFile(HANDLE a0,
                              LPCVOID a1,
                              DWORD a2,
                              LPDWORD a3,
                              LPOVERLAPPED a4)
{
    _PrintEnter("WriteFile(%p,%p,%p,%p,%p)\n", a0, a1, a2, a3, a4);

    BOOL rv = 0;
    __try {
        rv = Real_WriteFile(a0, a1, a2, a3, a4);
    } __finally {
        _PrintExit("WriteFile(,,,,) -> %p\n", rv);
    };
    return rv;
}

BOOL __stdcall Mine_WriteFileEx(HANDLE a0,
                                LPCVOID a1,
                                DWORD a2,
                                LPOVERLAPPED a3,
                                LPOVERLAPPED_COMPLETION_ROUTINE a4)
{
    _PrintEnter("WriteFileEx(%p,%p,%p,%p,%p)\n", a0, a1, a2, a3, a4);

    BOOL rv = 0;
    __try {
        rv = Real_WriteFileEx(a0, a1, a2, a3, a4);
    } __finally {
        _PrintExit("WriteFileEx(,,,,) -> %p\n", rv);
    };
    return rv;
}

HRESULT __stdcall Mine_WriteFmtUserTypeStg(LPSTORAGE a0,
                                           CLIPFORMAT a1,
                                           LPOLESTR a2)
{
    _PrintEnter("WriteFmtUserTypeStg(%p,%p,%p)\n", a0, a1, a2);

    HRESULT rv = 0;
    __try {
        rv = Real_WriteFmtUserTypeStg(a0, a1, a2);
    } __finally {
        _PrintExit("WriteFmtUserTypeStg(,,) -> %p\n", rv);
    };
    return rv;
}

BOOL __stdcall Mine_WritePrivateProfileSectionA(LPCSTR a0,
                                                LPCSTR a1,
                                                LPCSTR a2)
{
    _PrintEnter("WritePrivateProfileSectionA(%hs,%hs,%hs)\n", a0, a1, a2);

    BOOL rv = 0;
    __try {
        rv = Real_WritePrivateProfileSectionA(a0, a1, a2);
    } __finally {
        _PrintExit("WritePrivateProfileSectionA(,,) -> %p\n", rv);
    };
    return rv;
}

BOOL __stdcall Mine_WritePrivateProfileSectionW(LPCWSTR a0,
                                                LPCWSTR a1,
                                                LPCWSTR a2)
{
    _PrintEnter("WritePrivateProfileSectionW(%ls,%ls,%ls)\n", a0, a1, a2);

    BOOL rv = 0;
    __try {
        rv = Real_WritePrivateProfileSectionW(a0, a1, a2);
    } __finally {
        _PrintExit("WritePrivateProfileSectionW(,,) -> %p\n", rv);
    };
    return rv;
}

BOOL __stdcall Mine_WritePrivateProfileStringA(LPCSTR a0,
                                               LPCSTR a1,
                                               LPCSTR a2,
                                               LPCSTR a3)
{
    _PrintEnter("WritePrivateProfileStringA(%hs,%hs,%hs,%hs)\n", a0, a1, a2, a3);

    BOOL rv = 0;
    __try {
        rv = Real_WritePrivateProfileStringA(a0, a1, a2, a3);
    } __finally {
        _PrintExit("WritePrivateProfileStringA(,,,) -> %p\n", rv);
    };
    return rv;
}

BOOL __stdcall Mine_WritePrivateProfileStringW(LPCWSTR a0,
                                               LPCWSTR a1,
                                               LPCWSTR a2,
                                               LPCWSTR a3)
{
    _PrintEnter("WritePrivateProfileStringW(%ls,%ls,%ls,%ls)\n", a0, a1, a2, a3);

    BOOL rv = 0;
    __try {
        rv = Real_WritePrivateProfileStringW(a0, a1, a2, a3);
    } __finally {
        _PrintExit("WritePrivateProfileStringW(,,,) -> %p\n", rv);
    };
    return rv;
}

BOOL __stdcall Mine_WritePrivateProfileStructA(LPCSTR a0,
                                               LPCSTR a1,
                                               LPVOID a2,
                                               UINT a3,
                                               LPCSTR a4)
{
    _PrintEnter("WritePrivateProfileStructA(%hs,%hs,%p,%p,%hs)\n", a0, a1, a2, a3, a4);

    BOOL rv = 0;
    __try {
        rv = Real_WritePrivateProfileStructA(a0, a1, a2, a3, a4);
    } __finally {
        _PrintExit("WritePrivateProfileStructA(,,,,) -> %p\n", rv);
    };
    return rv;
}

BOOL __stdcall Mine_WritePrivateProfileStructW(LPCWSTR a0,
                                               LPCWSTR a1,
                                               LPVOID a2,
                                               UINT a3,
                                               LPCWSTR a4)
{
    _PrintEnter("WritePrivateProfileStructW(%ls,%ls,%p,%p,%ls)\n", a0, a1, a2, a3, a4);

    BOOL rv = 0;
    __try {
        rv = Real_WritePrivateProfileStructW(a0, a1, a2, a3, a4);
    } __finally {
        _PrintExit("WritePrivateProfileStructW(,,,,) -> %p\n", rv);
    };
    return rv;
}

BOOL __stdcall Mine_WriteProcessMemory(HANDLE a0,
                                       LPVOID lpBase,
                                       LPVOID lpBuf,
                                       DWORD_PTR nSize,
                                       PDWORD_PTR a4)
{
    _PrintEnter("WriteProcessMemory(%p,@%p..%p,%p,%p)\n",
                a0, lpBase,
                (PBYTE)lpBase + ((nSize > 0) ? nSize - 1 : 0),
                lpBuf, a4);

    BOOL rv = 0;
    __try {
        rv = Real_WriteProcessMemory(a0, lpBase, lpBuf, nSize, a4);
    } __finally {
        _PrintExit("WriteProcessMemory(,,,,) -> %p\n", rv);
    };
    return rv;
}

BOOL __stdcall Mine_WriteProfileSectionA(LPCSTR a0,
                                         LPCSTR a1)
{
    _PrintEnter("WriteProfileSectionA(%hs,%hs)\n", a0, a1);

    BOOL rv = 0;
    __try {
        rv = Real_WriteProfileSectionA(a0, a1);
    } __finally {
        _PrintExit("WriteProfileSectionA(,) -> %p\n", rv);
    };
    return rv;
}

BOOL __stdcall Mine_WriteProfileSectionW(LPCWSTR a0,
                                         LPCWSTR a1)
{
    _PrintEnter("WriteProfileSectionW(%ls,%ls)\n", a0, a1);

    BOOL rv = 0;
    __try {
        rv = Real_WriteProfileSectionW(a0, a1);
    } __finally {
        _PrintExit("WriteProfileSectionW(,) -> %p\n", rv);
    };
    return rv;
}

BOOL __stdcall Mine_WriteProfileStringA(LPCSTR a0,
                                        LPCSTR a1,
                                        LPCSTR a2)
{
    _PrintEnter("WriteProfileStringA(%hs,%hs,%hs)\n", a0, a1, a2);

    BOOL rv = 0;
    __try {
        rv = Real_WriteProfileStringA(a0, a1, a2);
    } __finally {
        _PrintExit("WriteProfileStringA(,,) -> %p\n", rv);
    };
    return rv;
}

BOOL __stdcall Mine_WriteProfileStringW(LPCWSTR a0,
                                        LPCWSTR a1,
                                        LPCWSTR a2)
{
    _PrintEnter("WriteProfileStringW(%ls,%ls,%ls)\n", a0, a1, a2);

    BOOL rv = 0;
    __try {
        rv = Real_WriteProfileStringW(a0, a1, a2);
    } __finally {
        _PrintExit("WriteProfileStringW(,,) -> %p\n", rv);
    };
    return rv;
}

DWORD __stdcall Mine_WriteTapemark(HANDLE a0,
                                   DWORD a1,
                                   DWORD a2,
                                   BOOL a3)
{
    _PrintEnter("WriteTapemark(%p,%p,%p,%p)\n", a0, a1, a2, a3);

    DWORD rv = 0;
    __try {
        rv = Real_WriteTapemark(a0, a1, a2, a3);
    } __finally {
        _PrintExit("WriteTapemark(,,,) -> %p\n", rv);
    };
    return rv;
}

int __stdcall Mine___WSAFDIsSet(SOCKET a0,
                                fd_set* a1)
{
    _PrintEnter("__WSAFDIsSet(%p,%p)\n", a0, a1);

    int rv = 0;
    __try {
        rv = Real___WSAFDIsSet(a0, a1);
    } __finally {
        _PrintExit("__WSAFDIsSet(,) -> %p\n", rv);
    };
    return rv;
}

long __stdcall Mine__hread(HFILE a0,
                           LPVOID a1,
                           long a2)
{
    _PrintEnter("_hread(%p,%p,%p)\n", a0, a1, a2);

    long rv = 0;
    __try {
        rv = Real__hread(a0, a1, a2);
    } __finally {
        _PrintExit("_hread(,,) -> %p\n", rv);
    };
    return rv;
}

long __stdcall Mine__hwrite(HFILE a0,
                            LPCSTR a1,
                            long a2)
{
    _PrintEnter("_hwrite(%p,%hs,%p)\n", a0, a1, a2);

    long rv = 0;
    __try {
        rv = Real__hwrite(a0, a1, a2);
    } __finally {
        _PrintExit("_hwrite(,,) -> %p\n", rv);
    };
    return rv;
}

HFILE __stdcall Mine__lclose(HFILE a0)
{
    _PrintEnter("_lclose(%p)\n", a0);

    HFILE rv = 0;
    __try {
        rv = Real__lclose(a0);
    } __finally {
        _PrintExit("_lclose() -> %p\n", rv);
    };
    return rv;
}

HFILE __stdcall Mine__lcreat(LPCSTR a0,
                             int a1)
{
    _PrintEnter("_lcreat(%hs,%p)\n", a0, a1);

    HFILE rv = 0;
    __try {
        rv = Real__lcreat(a0, a1);
    } __finally {
        _PrintExit("_lcreat(,) -> %p\n", rv);
    };
    return rv;
}

LONG __stdcall Mine__llseek(HFILE a0,
                            LONG a1,
                            int a2)
{
    _PrintEnter("_llseek(%p,%p,%p)\n", a0, a1, a2);

    LONG rv = 0;
    __try {
        rv = Real__llseek(a0, a1, a2);
    } __finally {
        _PrintExit("_llseek(,,) -> %p\n", rv);
    };
    return rv;
}

HFILE __stdcall Mine__lopen(LPCSTR a0,
                            int a1)
{
    _PrintEnter("_lopen(%hs,%p)\n", a0, a1);

    HFILE rv = 0;
    __try {
        rv = Real__lopen(a0, a1);
    } __finally {
        _PrintExit("_lopen(,) -> %p\n", rv);
    };
    return rv;
}

UINT __stdcall Mine__lread(HFILE a0,
                           LPVOID a1,
                           UINT a2)
{
    _PrintEnter("_lread(%p,%p,%p)\n", a0, a1, a2);

    UINT rv = 0;
    __try {
        rv = Real__lread(a0, a1, a2);
    } __finally {
        _PrintExit("_lread(,,) -> %p\n", rv);
    };
    return rv;
}

UINT __stdcall Mine__lwrite(HFILE a0,
                            LPCSTR a1,
                            UINT a2)
{
    _PrintEnter("_lwrite(%p,%hs,%p)\n", a0, a1, a2);

    UINT rv = 0;
    __try {
        rv = Real__lwrite(a0, a1, a2);
    } __finally {
        _PrintExit("_lwrite(,,) -> %p\n", rv);
    };
    return rv;
}

SOCKET __stdcall Mine_accept(SOCKET a0,
                             sockaddr* a1,
                             int* a2)
{
    _PrintEnter("accept(%p,%p,%p)\n", a0, a1, a2);

    SOCKET rv = 0;
    __try {
        rv = Real_accept(a0, a1, a2);
    } __finally {
        _PrintExit("accept(,,) -> %p\n", rv);
    };
    return rv;
}

int __stdcall Mine_bind(SOCKET a0,
                        sockaddr* a1,
                        int a2)
{
    _PrintEnter("bind(%p,%p,%p)\n", a0, a1, a2);

    int rv = 0;
    __try {
        rv = Real_bind(a0, a1, a2);
    } __finally {
        _PrintExit("bind(,,) -> %p\n", rv);
    };
    return rv;
}

int __stdcall Mine_closesocket(SOCKET a0)
{
    _PrintEnter("closesocket(%p)\n", a0);

    int rv = 0;
    __try {
        rv = Real_closesocket(a0);
    } __finally {
        _PrintExit("closesocket() -> %p\n", rv);
    };
    return rv;
}

int __stdcall Mine_connect(SOCKET a0,
                           sockaddr* a1,
                           int a2)
{
    _PrintEnter("connect(%p,%p,%p)\n", a0, a1, a2);

    int rv = 0;
    __try {
        rv = Real_connect(a0, a1, a2);
    } __finally {
        _PrintExit("connect(,,) -> %p\n", rv);
    };
    return rv;
}

hostent* __stdcall Mine_gethostbyaddr(char* a0,
                                      int a1,
                                      int a2)
{
    _PrintEnter("gethostbyaddr(%p,%p,%p)\n", a0, a1, a2);

    hostent* rv = 0;
    __try {
        rv = Real_gethostbyaddr(a0, a1, a2);
    } __finally {
        _PrintExit("gethostbyaddr(,,) -> %p\n", rv);
    };
    return rv;
}

hostent* __stdcall Mine_gethostbyname(char* a0)
{
    _PrintEnter("gethostbyname(%p)\n", a0);

    hostent* rv = 0;
    __try {
        rv = Real_gethostbyname(a0);
    } __finally {
        _PrintExit("gethostbyname() -> %p\n", rv);
    };
    return rv;
}

int __stdcall Mine_gethostname(char* a0,
                               int a1)
{
    _PrintEnter("gethostname(%p,%p)\n", a0, a1);

    int rv = 0;
    __try {
        rv = Real_gethostname(a0, a1);
    } __finally {
        _PrintExit("gethostname(,) -> %p\n", rv);
    };
    return rv;
}

int __stdcall Mine_getpeername(SOCKET a0,
                               sockaddr* a1,
                               int* a2)
{
    _PrintEnter("getpeername(%p,%p,%p)\n", a0, a1, a2);

    int rv = 0;
    __try {
        rv = Real_getpeername(a0, a1, a2);
    } __finally {
        _PrintExit("getpeername(,,) -> %p\n", rv);
    };
    return rv;
}

protoent* __stdcall Mine_getprotobyname(char* a0)
{
    _PrintEnter("getprotobyname(%p)\n", a0);

    protoent* rv = 0;
    __try {
        rv = Real_getprotobyname(a0);
    } __finally {
        _PrintExit("getprotobyname() -> %p\n", rv);
    };
    return rv;
}

protoent* __stdcall Mine_getprotobynumber(int a0)
{
    _PrintEnter("getprotobynumber(%p)\n", a0);

    protoent* rv = 0;
    __try {
        rv = Real_getprotobynumber(a0);
    } __finally {
        _PrintExit("getprotobynumber() -> %p\n", rv);
    };
    return rv;
}

servent* __stdcall Mine_getservbyname(char* a0,
                                      char* a1)
{
    _PrintEnter("getservbyname(%p,%p)\n", a0, a1);

    servent* rv = 0;
    __try {
        rv = Real_getservbyname(a0, a1);
    } __finally {
        _PrintExit("getservbyname(,) -> %p\n", rv);
    };
    return rv;
}

servent* __stdcall Mine_getservbyport(int a0,
                                      char* a1)
{
    _PrintEnter("getservbyport(%p,%p)\n", a0, a1);

    servent* rv = 0;
    __try {
        rv = Real_getservbyport(a0, a1);
    } __finally {
        _PrintExit("getservbyport(,) -> %p\n", rv);
    };
    return rv;
}

int __stdcall Mine_getsockname(SOCKET a0,
                               sockaddr* a1,
                               int* a2)
{
    _PrintEnter("getsockname(%p,%p,%p)\n", a0, a1, a2);

    int rv = 0;
    __try {
        rv = Real_getsockname(a0, a1, a2);
    } __finally {
        _PrintExit("getsockname(,,) -> %p\n", rv);
    };
    return rv;
}

int __stdcall Mine_getsockopt(SOCKET a0,
                              int a1,
                              int a2,
                              char* a3,
                              int* a4)
{
    _PrintEnter("getsockopt(%p,%p,%p,%p,%p)\n", a0, a1, a2, a3, a4);

    int rv = 0;
    __try {
        rv = Real_getsockopt(a0, a1, a2, a3, a4);
    } __finally {
        _PrintExit("getsockopt(,,,,) -> %p\n", rv);
    };
    return rv;
}

u_long __stdcall Mine_htonl(u_long a0)
{
    _PrintEnter("htonl(%p)\n", a0);

    u_long rv = 0;
    __try {
        rv = Real_htonl(a0);
    } __finally {
        _PrintExit("htonl() -> %p\n", rv);
    };
    return rv;
}

u_short __stdcall Mine_htons(u_short a0)
{
    _PrintEnter("htons(%p)\n", a0);

    u_short rv = 0;
    __try {
        rv = Real_htons(a0);
    } __finally {
        _PrintExit("htons() -> %p\n", rv);
    };
    return rv;
}

unsigned long __stdcall Mine_inet_addr(char* a0)
{
    _PrintEnter("inet_addr(%p)\n", a0);

    unsigned long rv = 0;
    __try {
        rv = Real_inet_addr(a0);
    } __finally {
        _PrintExit("inet_addr() -> %p\n", rv);
    };
    return rv;
}

char* __stdcall Mine_inet_ntoa(in_addr a0)
{
    _PrintEnter("inet_ntoa(%p)\n", a0);

    char* rv = 0;
    __try {
        rv = Real_inet_ntoa(a0);
    } __finally {
        _PrintExit("inet_ntoa() -> %p\n", rv);
    };
    return rv;
}

int __stdcall Mine_ioctlsocket(SOCKET a0,
                               long a1,
                               u_long* a2)
{
    _PrintEnter("ioctlsocket(%p,%p,%p)\n", a0, a1, a2);

    int rv = 0;
    __try {
        rv = Real_ioctlsocket(a0, a1, a2);
    } __finally {
        _PrintExit("ioctlsocket(,,) -> %p\n", rv);
    };
    return rv;
}

void __stdcall Mine_keybd_event(BYTE a0,
                                BYTE a1,
                                DWORD a2,
                                ULONG_PTR a3)
{
    _PrintEnter("keybd_event(%p,%p,%p,%p)\n", a0, a1, a2, a3);

    __try {
        Real_keybd_event(a0, a1, a2, a3);
    } __finally {
        _PrintExit("keybd_event(,,,) ->\n");
    };
}

int __stdcall Mine_listen(SOCKET a0,
                          int a1)
{
    _PrintEnter("listen(%p,%p)\n", a0, a1);

    int rv = 0;
    __try {
        rv = Real_listen(a0, a1);
    } __finally {
        _PrintExit("listen(,) -> %p\n", rv);
    };
    return rv;
}

void __stdcall Mine_mouse_event(DWORD a0,
                                DWORD a1,
                                DWORD a2,
                                DWORD a3,
                                ULONG_PTR a4)
{
    _PrintEnter("mouse_event(%p,%p,%p,%p,%p)\n", a0, a1, a2, a3, a4);

    __try {
        Real_mouse_event(a0, a1, a2, a3, a4);
    } __finally {
        _PrintExit("mouse_event(,,,,) ->\n");
    };
}

u_long __stdcall Mine_ntohl(u_long a0)
{
    _PrintEnter("ntohl(%p)\n", a0);

    u_long rv = 0;
    __try {
        rv = Real_ntohl(a0);
    } __finally {
        _PrintExit("ntohl() -> %p\n", rv);
    };
    return rv;
}

u_short __stdcall Mine_ntohs(u_short a0)
{
    _PrintEnter("ntohs(%p)\n", a0);

    u_short rv = 0;
    __try {
        rv = Real_ntohs(a0);
    } __finally {
        _PrintExit("ntohs() -> %p\n", rv);
    };
    return rv;
}

int __stdcall Mine_recv(SOCKET a0,
                        char* a1,
                        int a2,
                        int a3)
{
    _PrintEnter("recv(%p,%p,%p,%p)\n", a0, a1, a2, a3);

    int rv = 0;
    __try {
        rv = Real_recv(a0, a1, a2, a3);
    } __finally {
        _PrintExit("recv(,,,) -> %p\n", rv);
    };
    return rv;
}

int __stdcall Mine_recvfrom(SOCKET a0,
                            char* a1,
                            int a2,
                            int a3,
                            sockaddr* a4,
                            int* a5)
{
    _PrintEnter("recvfrom(%p,%p,%p,%p,%p,%p)\n", a0, a1, a2, a3, a4, a5);

    int rv = 0;
    __try {
        rv = Real_recvfrom(a0, a1, a2, a3, a4, a5);
    } __finally {
        _PrintExit("recvfrom(,,,,,) -> %p\n", rv);
    };
    return rv;
}

int __stdcall Mine_select(int a0,
                          fd_set* a1,
                          fd_set* a2,
                          fd_set* a3,
                          timeval* a4)
{
    _PrintEnter("select(%p,%p,%p,%p,%p)\n", a0, a1, a2, a3, a4);

    int rv = 0;
    __try {
        rv = Real_select(a0, a1, a2, a3, a4);
    } __finally {
        _PrintExit("select(,,,,) -> %p\n", rv);
    };
    return rv;
}

int __stdcall Mine_send(SOCKET a0,
                        char* a1,
                        int a2,
                        int a3)
{
    _PrintEnter("send(%p,%p,%p,%p)\n", a0, a1, a2, a3);

    int rv = 0;
    __try {
        rv = Real_send(a0, a1, a2, a3);
    } __finally {
        _PrintExit("send(,,,) -> %p\n", rv);
    };
    return rv;
}

int __stdcall Mine_sendto(SOCKET a0,
                          char* a1,
                          int a2,
                          int a3,
                          sockaddr* a4,
                          int a5)
{
    _PrintEnter("sendto(%p,%p,%p,%p,%p,%p)\n", a0, a1, a2, a3, a4, a5);

    int rv = 0;
    __try {
        rv = Real_sendto(a0, a1, a2, a3, a4, a5);
    } __finally {
        _PrintExit("sendto(,,,,,) -> %p\n", rv);
    };
    return rv;
}

int __stdcall Mine_setsockopt(SOCKET a0,
                              int a1,
                              int a2,
                              char* a3,
                              int a4)
{
    _PrintEnter("setsockopt(%p,%p,%p,%p,%p)\n", a0, a1, a2, a3, a4);

    int rv = 0;
    __try {
        rv = Real_setsockopt(a0, a1, a2, a3, a4);
    } __finally {
        _PrintExit("setsockopt(,,,,) -> %p\n", rv);
    };
    return rv;
}

int __stdcall Mine_shutdown(SOCKET a0,
                            int a1)
{
    _PrintEnter("shutdown(%p,%p)\n", a0, a1);

    int rv = 0;
    __try {
        rv = Real_shutdown(a0, a1);
    } __finally {
        _PrintExit("shutdown(,) -> %p\n", rv);
    };
    return rv;
}

SOCKET __stdcall Mine_socket(int a0,
                             int a1,
                             int a2)
{
    _PrintEnter("socket(%x,%x,%x)\n", a0, a1, a2);

    SOCKET rv = 0;
    __try {
        rv = Real_socket(a0, a1, a2);
    } __finally {
        _PrintExit("socket(,,) -> %p\n", rv);
    };
    return rv;
}

////////////////////////////////////////////////////////////// AttachDetours.
//
static PCHAR DetRealName(PCHAR psz)
{
    PCHAR pszBeg = psz;
    // Move to end of name.
    while (*psz) {
        psz++;
    }
    // Move back through A-Za-z0-9 names.
    while (psz > pszBeg &&
           ((psz[-1] >= 'A' && psz[-1] <= 'Z') ||
            (psz[-1] >= 'a' && psz[-1] <= 'z') ||
            (psz[-1] >= '0' && psz[-1] <= '9'))) {
        psz--;
    }
    return psz;
}

static VOID Dump(PBYTE pbBytes, LONG nBytes, PBYTE pbTarget)
{
    CHAR szBuffer[256];
    PCHAR pszBuffer = szBuffer;

    for (LONG n = 0; n < nBytes; n += 12) {
        pszBuffer += StringCchPrintfA(pszBuffer, sizeof(szBuffer), "  %p: ", pbBytes + n);
        for (LONG m = n; m < n + 12; m++) {
            if (m >= nBytes) {
                pszBuffer += StringCchPrintfA(pszBuffer, sizeof(szBuffer), "   ");
            }
            else {
                pszBuffer += StringCchPrintfA(pszBuffer, sizeof(szBuffer), "%02x ", pbBytes[m]);
            }
        }
        if (n == 0) {
            pszBuffer += StringCchPrintfA(pszBuffer, sizeof(szBuffer), "[%p]", pbTarget);
        }
        pszBuffer += StringCchPrintfA(pszBuffer, sizeof(szBuffer), "\n");
    }

    Syelog(SYELOG_SEVERITY_INFORMATION, "%s", szBuffer);
}

static VOID Decode(PBYTE pbCode, LONG nInst)
{
    PBYTE pbSrc = pbCode;
    PBYTE pbEnd;
    PBYTE pbTarget;
    for (LONG n = 0; n < nInst; n++) {
        pbTarget = NULL;
        pbEnd = (PBYTE)DetourCopyInstruction(NULL, NULL, (PVOID)pbSrc, (PVOID*)&pbTarget, NULL);
        Dump(pbSrc, (int)(pbEnd - pbSrc), pbTarget);
        pbSrc = pbEnd;

        if (pbTarget != NULL) {
            break;
        }
    }
}

VOID DetAttach(PVOID *ppvReal, PVOID pvMine, PCHAR psz)
{
    PVOID pvReal = NULL;
    if (ppvReal == NULL) {
        ppvReal = &pvReal;
    }

    LONG l = DetourAttach(ppvReal, pvMine);
    if (l != 0) {
        Syelog(SYELOG_SEVERITY_NOTICE,
               "Attach failed: `%s': error %d\n", DetRealName(psz), l);

        Decode((PBYTE)*ppvReal, 3);
    }
}

VOID DetDetach(PVOID *ppvReal, PVOID pvMine, PCHAR psz)
{
    LONG l = DetourDetach(ppvReal, pvMine);
    if (l != 0) {
#if 0
        Syelog(SYELOG_SEVERITY_NOTICE,
               "Detach failed: `%s': error %d\n", DetRealName(psz), l);
#else
        (void)psz;
#endif
    }
}

#define ATTACH(x)       DetAttach(&(PVOID&)Real_##x,Mine_##x,#x)
#define DETACH(x)       DetDetach(&(PVOID&)Real_##x,Mine_##x,#x)

LONG AttachDetours(VOID)
{
    DetourTransactionBegin();
    DetourUpdateThread(GetCurrentThread());

    // For this many APIs, we'll ignore one or two can't be detoured.
    DetourSetIgnoreTooSmall(TRUE);

    ATTACH(AbortDoc);
    ATTACH(AbortPath);
    ATTACH(ActivateKeyboardLayout);
    ATTACH(AddAtomA);
    ATTACH(AddAtomW);
    ATTACH(AddFontResourceA);
    ATTACH(AddFontResourceW);
    ATTACH(AdjustWindowRect);
    ATTACH(AdjustWindowRectEx);
    ATTACH(AllocConsole);
    ATTACH(AngleArc);
    ATTACH(AnimatePalette);
    ATTACH(AnyPopup);
    ATTACH(AppendMenuA);
    ATTACH(AppendMenuW);
    ATTACH(Arc);
    ATTACH(ArcTo);
    ATTACH(AreFileApisANSI);
    ATTACH(ArrangeIconicWindows);
    ATTACH(AttachThreadInput);
    ATTACH(BackupRead);
    ATTACH(BackupSeek);
    ATTACH(BackupWrite);
    ATTACH(Beep);
    ATTACH(BeginDeferWindowPos);
    ATTACH(BeginPaint);
    ATTACH(BeginPath);
    ATTACH(BeginUpdateResourceA);
    ATTACH(BeginUpdateResourceW);
    ATTACH(BindMoniker);
    ATTACH(BitBlt);
    ATTACH(BringWindowToTop);
    ATTACH(BroadcastSystemMessageA);
    ATTACH(BroadcastSystemMessageW);
    ATTACH(BuildCommDCBA);
    ATTACH(BuildCommDCBAndTimeoutsA);
    ATTACH(BuildCommDCBAndTimeoutsW);
    ATTACH(BuildCommDCBW);
    ATTACH(CLSIDFromProgID);
    ATTACH(CLSIDFromString);
    ATTACH(CallMsgFilterA);
    ATTACH(CallMsgFilterW);
    ATTACH(CallNamedPipeA);
    ATTACH(CallNamedPipeW);
    ATTACH(CallNextHookEx);
    ATTACH(CallWindowProcA);
    ATTACH(CallWindowProcW);
    ATTACH(CancelDC);
    ATTACH(CancelIo);
    ATTACH(CancelWaitableTimer);
    ATTACH(CascadeWindows);
    ATTACH(ChangeClipboardChain);
    ATTACH(ChangeDisplaySettingsA);
    ATTACH(ChangeDisplaySettingsExA);
    ATTACH(ChangeDisplaySettingsExW);
    ATTACH(ChangeDisplaySettingsW);
    ATTACH(ChangeMenuA);
    ATTACH(ChangeMenuW);
    ATTACH(CharLowerA);
    ATTACH(CharLowerBuffA);
    ATTACH(CharLowerBuffW);
    ATTACH(CharLowerW);
    ATTACH(CharNextA);
    ATTACH(CharNextExA);
    ATTACH(CharNextW);
    ATTACH(CharPrevA);
    ATTACH(CharPrevExA);
    ATTACH(CharPrevW);
    ATTACH(CharToOemA);
    ATTACH(CharToOemBuffA);
    ATTACH(CharToOemBuffW);
    ATTACH(CharToOemW);
    ATTACH(CharUpperA);
    ATTACH(CharUpperBuffA);
    ATTACH(CharUpperBuffW);
    ATTACH(CharUpperW);
    ATTACH(CheckColorsInGamut);
    ATTACH(CheckDlgButton);
    ATTACH(CheckMenuItem);
    ATTACH(CheckMenuRadioItem);
    ATTACH(CheckRadioButton);
    ATTACH(ChildWindowFromPoint);
    ATTACH(ChildWindowFromPointEx);
    ATTACH(ChoosePixelFormat);
    ATTACH(Chord);
    ATTACH(ClearCommBreak);
    ATTACH(ClearCommError);
    ATTACH(ClientToScreen);
    ATTACH(ClipCursor);
    ATTACH(CloseClipboard);
    ATTACH(CloseDesktop);
    ATTACH(CloseEnhMetaFile);
    ATTACH(CloseFigure);
    ATTACH(CloseHandle);
    ATTACH(CloseMetaFile);
    ATTACH(CloseWindow);
    ATTACH(CloseWindowStation);
    ATTACH(CoAddRefServerProcess);
    ATTACH(CoBuildVersion);
    ATTACH(CoCopyProxy);
    ATTACH(CoCreateFreeThreadedMarshaler);
    ATTACH(CoCreateGuid);
    ATTACH(CoCreateInstance);
    ATTACH(CoCreateInstanceEx);
    ATTACH(CoDisconnectObject);
    ATTACH(CoDosDateTimeToFileTime);
    ATTACH(CoFileTimeNow);
    ATTACH(CoFileTimeToDosDateTime);
    ATTACH(CoFreeAllLibraries);
    ATTACH(CoFreeLibrary);
    ATTACH(CoFreeUnusedLibraries);
    ATTACH(CoGetCallContext);
    ATTACH(CoGetClassObject);
    ATTACH(CoGetCurrentProcess);
    ATTACH(CoGetInstanceFromFile);
    ATTACH(CoGetInstanceFromIStorage);
    ATTACH(CoGetInterfaceAndReleaseStream);
    ATTACH(CoGetMalloc);
    ATTACH(CoGetMarshalSizeMax);
    ATTACH(CoGetObject);
    ATTACH(CoGetPSClsid);
    ATTACH(CoGetStandardMarshal);
    ATTACH(CoGetStdMarshalEx);
    ATTACH(CoGetTreatAsClass);
    ATTACH(CoImpersonateClient);
    ATTACH(CoInitialize);
    ATTACH(CoInitializeEx);
    ATTACH(CoInitializeSecurity);
    ATTACH(CoIsHandlerConnected);
    ATTACH(CoIsOle1Class);
    ATTACH(CoLoadLibrary);
    ATTACH(CoLockObjectExternal);
    ATTACH(CoMarshalHresult);
    ATTACH(CoMarshalInterThreadInterfaceInStream);
    ATTACH(CoMarshalInterface);
    ATTACH(CoQueryAuthenticationServices);
    ATTACH(CoQueryClientBlanket);
    ATTACH(CoQueryProxyBlanket);
    ATTACH(CoRegisterChannelHook);
    ATTACH(CoRegisterClassObject);
    ATTACH(CoRegisterMallocSpy);
    ATTACH(CoRegisterMessageFilter);
    ATTACH(CoRegisterPSClsid);
    ATTACH(CoRegisterSurrogate);
    ATTACH(CoReleaseMarshalData);
    ATTACH(CoReleaseServerProcess);
    ATTACH(CoResumeClassObjects);
    ATTACH(CoRevertToSelf);
    ATTACH(CoRevokeClassObject);
    ATTACH(CoRevokeMallocSpy);
    ATTACH(CoSetProxyBlanket);
    ATTACH(CoSuspendClassObjects);
    ATTACH(CoSwitchCallContext);
    ATTACH(CoTaskMemAlloc);
    ATTACH(CoTaskMemFree);
    ATTACH(CoTaskMemRealloc);
    ATTACH(CoTreatAsClass);
    ATTACH(CoUninitialize);
    ATTACH(CoUnmarshalHresult);
    ATTACH(CoUnmarshalInterface);
    ATTACH(ColorMatchToTarget);
    ATTACH(CombineRgn);
    ATTACH(CombineTransform);
    ATTACH(CommConfigDialogA);
    ATTACH(CommConfigDialogW);
    ATTACH(CompareFileTime);
    ATTACH(CompareStringA);
    ATTACH(CompareStringW);
    ATTACH(ConnectNamedPipe);
#if !defined(DETOURS_ARM)
    ATTACH(ContinueDebugEvent);
#endif // !DETOURS_ARM
    ATTACH(ConvertDefaultLocale);
    ATTACH(ConvertThreadToFiber);
    ATTACH(CopyAcceleratorTableA);
    ATTACH(CopyAcceleratorTableW);
    ATTACH(CopyEnhMetaFileA);
    ATTACH(CopyEnhMetaFileW);
    ATTACH(CopyFileA);
    ATTACH(CopyFileExA);
    ATTACH(CopyFileExW);
    ATTACH(CopyFileW);
    ATTACH(CopyIcon);
    ATTACH(CopyImage);
    ATTACH(CopyMetaFileA);
    ATTACH(CopyMetaFileW);
    ATTACH(CopyRect);
    ATTACH(CountClipboardFormats);
    ATTACH(CreateAcceleratorTableA);
    ATTACH(CreateAcceleratorTableW);
    ATTACH(CreateAntiMoniker);
    ATTACH(CreateBindCtx);
    ATTACH(CreateBitmap);
    ATTACH(CreateBitmapIndirect);
    ATTACH(CreateBrushIndirect);
    ATTACH(CreateCaret);
    ATTACH(CreateClassMoniker);
    ATTACH(CreateColorSpaceA);
    ATTACH(CreateColorSpaceW);
    ATTACH(CreateCompatibleBitmap);
    ATTACH(CreateCompatibleDC);
    ATTACH(CreateConsoleScreenBuffer);
    ATTACH(CreateCursor);
    ATTACH(CreateDCA);
    ATTACH(CreateDCW);
    ATTACH(CreateDIBPatternBrush);
    ATTACH(CreateDIBPatternBrushPt);
    ATTACH(CreateDIBSection);
    ATTACH(CreateDIBitmap);
    ATTACH(CreateDataAdviseHolder);
    ATTACH(CreateDataCache);
    ATTACH(CreateDesktopA);
    ATTACH(CreateDesktopW);
    ATTACH(CreateDialogIndirectParamA);
    ATTACH(CreateDialogIndirectParamW);
    ATTACH(CreateDialogParamA);
    ATTACH(CreateDialogParamW);
    ATTACH(CreateDirectoryA);
    ATTACH(CreateDirectoryExA);
    ATTACH(CreateDirectoryExW);
    ATTACH(CreateDirectoryW);
    ATTACH(CreateDiscardableBitmap);
    ATTACH(CreateEllipticRgn);
    ATTACH(CreateEllipticRgnIndirect);
    ATTACH(CreateEnhMetaFileA);
    ATTACH(CreateEnhMetaFileW);
    ATTACH(CreateEventA);
    ATTACH(CreateEventW);
    ATTACH(CreateFiber);
    ATTACH(CreateFileA);
    ATTACH(CreateFileMappingA);
    ATTACH(CreateFileMappingW);
    ATTACH(CreateFileMoniker);
    ATTACH(CreateFileW);
    ATTACH(CreateFontA);
    ATTACH(CreateFontIndirectA);
    ATTACH(CreateFontIndirectW);
    ATTACH(CreateFontW);
    ATTACH(CreateGenericComposite);
    ATTACH(CreateHalftonePalette);
    ATTACH(CreateHatchBrush);
    ATTACH(CreateICA);
    ATTACH(CreateICW);
    ATTACH(CreateILockBytesOnHGlobal);
    ATTACH(CreateIcon);
    ATTACH(CreateIconFromResource);
    ATTACH(CreateIconFromResourceEx);
    ATTACH(CreateIconIndirect);
    ATTACH(CreateIoCompletionPort);
    ATTACH(CreateItemMoniker);
    ATTACH(CreateMDIWindowA);
    ATTACH(CreateMDIWindowW);
    ATTACH(CreateMailslotA);
    ATTACH(CreateMailslotW);
    ATTACH(CreateMenu);
    ATTACH(CreateMetaFileA);
    ATTACH(CreateMetaFileW);
    ATTACH(CreateMutexA);
    ATTACH(CreateMutexW);
    ATTACH(CreateNamedPipeA);
    ATTACH(CreateNamedPipeW);
    ATTACH(CreateOleAdviseHolder);
    ATTACH(CreatePalette);
    ATTACH(CreatePatternBrush);
    ATTACH(CreatePen);
    ATTACH(CreatePenIndirect);
    ATTACH(CreatePipe);
    ATTACH(CreatePointerMoniker);
    ATTACH(CreatePolyPolygonRgn);
    ATTACH(CreatePolygonRgn);
    ATTACH(CreatePopupMenu);
    ATTACH(CreateProcessA);
    ATTACH(CreateProcessW);
    ATTACH(CreateProcessAsUserA);
    ATTACH(CreateProcessAsUserW);
#if(_WIN32_WINNT >= 0x0500)
    ATTACH(CreateProcessWithLogonW);
    ATTACH(CreateProcessWithTokenW);
#endif //(_WIN32_WINNT >= 0x0500)
    ATTACH(CreateRectRgn);
    ATTACH(CreateRectRgnIndirect);
    ATTACH(CreateRemoteThread);
    ATTACH(CreateRoundRectRgn);
    ATTACH(CreateScalableFontResourceA);
    ATTACH(CreateScalableFontResourceW);
    ATTACH(CreateSemaphoreA);
    ATTACH(CreateSemaphoreW);
    ATTACH(CreateSolidBrush);
    ATTACH(CreateStdProgressIndicator);
    ATTACH(CreateStreamOnHGlobal);
    ATTACH(CreateTapePartition);
    ATTACH(CreateThread);
    ATTACH(CreateWaitableTimerA);
    ATTACH(CreateWaitableTimerW);
    ATTACH(CreateWindowExA);
    ATTACH(CreateWindowExW);
    ATTACH(CreateWindowStationA);
    ATTACH(CreateWindowStationW);
    ATTACH(DPtoLP);
    ATTACH(DdeAbandonTransaction);
    ATTACH(DdeAccessData);
    ATTACH(DdeAddData);
    ATTACH(DdeClientTransaction);
    ATTACH(DdeCmpStringHandles);
    ATTACH(DdeConnect);
    ATTACH(DdeConnectList);
    ATTACH(DdeCreateDataHandle);
    ATTACH(DdeCreateStringHandleA);
    ATTACH(DdeCreateStringHandleW);
    ATTACH(DdeDisconnect);
    ATTACH(DdeDisconnectList);
    ATTACH(DdeEnableCallback);
    ATTACH(DdeFreeDataHandle);
    ATTACH(DdeFreeStringHandle);
    ATTACH(DdeGetData);
    ATTACH(DdeGetLastError);
    ATTACH(DdeImpersonateClient);
    ATTACH(DdeKeepStringHandle);
    ATTACH(DdeNameService);
    ATTACH(DdePostAdvise);
    ATTACH(DdeQueryConvInfo);
    ATTACH(DdeQueryNextServer);
    ATTACH(DdeQueryStringA);
    ATTACH(DdeQueryStringW);
    ATTACH(DdeReconnect);
    ATTACH(DdeSetQualityOfService);
    ATTACH(DdeSetUserHandle);
    ATTACH(DdeUnaccessData);
    ATTACH(DdeUninitialize);
    ATTACH(DebugActiveProcess);
    ATTACH(DebugActiveProcessStop);
    ATTACH(DebugBreak);
    ATTACH(DefDlgProcA);
    ATTACH(DefDlgProcW);
    ATTACH(DefFrameProcA);
    ATTACH(DefFrameProcW);
    ATTACH(DefMDIChildProcA);
    ATTACH(DefMDIChildProcW);
    ATTACH(DefWindowProcA);
    ATTACH(DefWindowProcW);
    ATTACH(DeferWindowPos);
    ATTACH(DefineDosDeviceA);
    ATTACH(DefineDosDeviceW);
    ATTACH(DeleteAtom);
    ATTACH(DeleteColorSpace);
    ATTACH(DeleteDC);
    ATTACH(DeleteEnhMetaFile);
    ATTACH(DeleteFiber);
    ATTACH(DeleteFileA);
    ATTACH(DeleteFileW);
    ATTACH(DeleteMenu);
    ATTACH(DeleteMetaFile);
    ATTACH(DeleteObject);
    ATTACH(DescribePixelFormat);
    ATTACH(DestroyAcceleratorTable);
    ATTACH(DestroyCaret);
    ATTACH(DestroyCursor);
    ATTACH(DestroyIcon);
    ATTACH(DestroyMenu);
    ATTACH(DestroyWindow);
    ATTACH(DeviceIoControl);
    ATTACH(DialogBoxIndirectParamA);
    ATTACH(DialogBoxIndirectParamW);
    ATTACH(DialogBoxParamA);
    ATTACH(DialogBoxParamW);
    ATTACH(DisableThreadLibraryCalls);
    ATTACH(DisconnectNamedPipe);
    ATTACH(DispatchMessageA);
    ATTACH(DispatchMessageW);
    ATTACH(DlgDirListA);
    ATTACH(DlgDirListComboBoxA);
    ATTACH(DlgDirListComboBoxW);
    ATTACH(DlgDirListW);
    ATTACH(DlgDirSelectComboBoxExA);
    ATTACH(DlgDirSelectComboBoxExW);
    ATTACH(DlgDirSelectExA);
    ATTACH(DlgDirSelectExW);
    ATTACH(DoDragDrop);
    ATTACH(DosDateTimeToFileTime);
    ATTACH(DragDetect);
    ATTACH(DragObject);
    ATTACH(DrawAnimatedRects);
    ATTACH(DrawCaption);
    ATTACH(DrawEdge);
    ATTACH(DrawEscape);
    ATTACH(DrawFocusRect);
    ATTACH(DrawFrameControl);
    ATTACH(DrawIcon);
    ATTACH(DrawIconEx);
    ATTACH(DrawMenuBar);
    ATTACH(DrawStateA);
    ATTACH(DrawStateW);
    ATTACH(DrawTextA);
    ATTACH(DrawTextExA);
    ATTACH(DrawTextExW);
    ATTACH(DrawTextW);
    ATTACH(DuplicateHandle);
    ATTACH(Ellipse);
    ATTACH(EmptyClipboard);
    ATTACH(EnableMenuItem);
    ATTACH(EnableScrollBar);
    ATTACH(EnableWindow);
    ATTACH(EndDeferWindowPos);
    ATTACH(EndDialog);
    ATTACH(EndDoc);
    ATTACH(EndPage);
    ATTACH(EndPaint);
    ATTACH(EndPath);
    ATTACH(EndUpdateResourceA);
    ATTACH(EndUpdateResourceW);
    ATTACH(EnumCalendarInfoA);
    ATTACH(EnumCalendarInfoW);
    ATTACH(EnumChildWindows);
    ATTACH(EnumClipboardFormats);
    ATTACH(EnumDateFormatsA);
    ATTACH(EnumDateFormatsW);
    ATTACH(EnumDesktopWindows);
    ATTACH(EnumDesktopsA);
    ATTACH(EnumDesktopsW);
    ATTACH(EnumDisplaySettingsA);
    ATTACH(EnumDisplaySettingsW);
    ATTACH(EnumEnhMetaFile);
    ATTACH(EnumFontFamiliesA);
    ATTACH(EnumFontFamiliesExA);
    ATTACH(EnumFontFamiliesExW);
    ATTACH(EnumFontFamiliesW);
    ATTACH(EnumFontsA);
    ATTACH(EnumFontsW);
    ATTACH(EnumICMProfilesA);
    ATTACH(EnumICMProfilesW);
    ATTACH(EnumMetaFile);
    ATTACH(EnumObjects);
    ATTACH(EnumPropsA);
    ATTACH(EnumPropsExA);
    ATTACH(EnumPropsExW);
    ATTACH(EnumPropsW);
    ATTACH(EnumResourceLanguagesA);
    ATTACH(EnumResourceLanguagesW);
    ATTACH(EnumResourceNamesA);
    ATTACH(EnumResourceNamesW);
    ATTACH(EnumResourceTypesA);
    ATTACH(EnumResourceTypesW);
    ATTACH(EnumSystemCodePagesA);
    ATTACH(EnumSystemCodePagesW);
#if(WINVER >= 0x0500)
    ATTACH(EnumSystemLocalesA);
    ATTACH(EnumSystemLocalesW);
#endif // (WINVER >= 0x0500)
    ATTACH(EnumThreadWindows);
    ATTACH(EnumTimeFormatsA);
    ATTACH(EnumTimeFormatsW);
    ATTACH(EnumWindowStationsA);
    ATTACH(EnumWindowStationsW);
    ATTACH(EnumWindows);
    ATTACH(EqualRect);
    ATTACH(EqualRgn);
    ATTACH(EraseTape);
    ATTACH(Escape);
    ATTACH(EscapeCommFunction);
    ATTACH(ExcludeClipRect);
    ATTACH(ExcludeUpdateRgn);
    ATTACH(ExitProcess);
    ATTACH(ExitThread);
    ATTACH(ExitWindowsEx);
    ATTACH(ExpandEnvironmentStringsA);
    ATTACH(ExpandEnvironmentStringsW);
    ATTACH(ExtCreatePen);
    ATTACH(ExtCreateRegion);
    ATTACH(ExtEscape);
    ATTACH(ExtFloodFill);
    ATTACH(ExtSelectClipRgn);
    ATTACH(ExtTextOutA);
    ATTACH(ExtTextOutW);
    ATTACH(FatalAppExitA);
    ATTACH(FatalAppExitW);
    ATTACH(FatalExit);
    ATTACH(FileTimeToDosDateTime);
    ATTACH(FileTimeToLocalFileTime);
    ATTACH(FileTimeToSystemTime);
    ATTACH(FillConsoleOutputAttribute);
    ATTACH(FillConsoleOutputCharacterA);
    ATTACH(FillConsoleOutputCharacterW);
    ATTACH(FillPath);
    ATTACH(FillRect);
    ATTACH(FillRgn);
    ATTACH(FindAtomA);
    ATTACH(FindAtomW);
    ATTACH(FindClose);
    ATTACH(FindCloseChangeNotification);
    ATTACH(FindFirstChangeNotificationA);
    ATTACH(FindFirstChangeNotificationW);
    ATTACH(FindFirstFileA);
    ATTACH(FindFirstFileExA);
    ATTACH(FindFirstFileExW);
    ATTACH(FindFirstFileW);
    ATTACH(FindNextChangeNotification);
    ATTACH(FindNextFileA);
    ATTACH(FindNextFileW);
    ATTACH(FindResourceA);
    ATTACH(FindResourceExA);
    ATTACH(FindResourceExW);
    ATTACH(FindResourceW);
    ATTACH(FindWindowA);
    ATTACH(FindWindowExA);
    ATTACH(FindWindowExW);
    ATTACH(FindWindowW);
    ATTACH(FixBrushOrgEx);
    ATTACH(FlashWindow);
    ATTACH(FlattenPath);
    ATTACH(FloodFill);
    ATTACH(FlushConsoleInputBuffer);
    ATTACH(FlushFileBuffers);
    ATTACH(FlushViewOfFile);
    ATTACH(FmtIdToPropStgName);
    ATTACH(FoldStringA);
    ATTACH(FoldStringW);
    ATTACH(FormatMessageA);
    ATTACH(FormatMessageW);
    ATTACH(FrameRect);
    ATTACH(FrameRgn);
    ATTACH(FreeConsole);
    ATTACH(FreeDDElParam);
    ATTACH(FreeEnvironmentStringsA);
    ATTACH(FreeEnvironmentStringsW);
    ATTACH(FreeLibrary);
    ATTACH(FreeLibraryAndExitThread);
    ATTACH(FreePropVariantArray);
    ATTACH(FreeResource);
    ATTACH(GdiComment);
    ATTACH(GdiFlush);
    ATTACH(GdiGetBatchLimit);
    ATTACH(GdiSetBatchLimit);
    ATTACH(GenerateConsoleCtrlEvent);
    ATTACH(GetACP);
    ATTACH(GetActiveWindow);
    ATTACH(GetArcDirection);
    ATTACH(GetAspectRatioFilterEx);
    ATTACH(GetAsyncKeyState);
    ATTACH(GetAtomNameA);
    ATTACH(GetAtomNameW);
    ATTACH(GetBinaryTypeA);
    ATTACH(GetBinaryTypeW);
    ATTACH(GetBitmapBits);
    ATTACH(GetBitmapDimensionEx);
    ATTACH(GetBkColor);
    ATTACH(GetBkMode);
    ATTACH(GetBoundsRect);
    ATTACH(GetBrushOrgEx);
    ATTACH(GetCPInfo);
    ATTACH(GetCapture);
    ATTACH(GetCaretBlinkTime);
    ATTACH(GetCaretPos);
    ATTACH(GetCharABCWidthsA);
    ATTACH(GetCharABCWidthsFloatA);
    ATTACH(GetCharABCWidthsFloatW);
    ATTACH(GetCharABCWidthsW);
    ATTACH(GetCharWidth32A);
    ATTACH(GetCharWidth32W);
    ATTACH(GetCharWidthA);
    ATTACH(GetCharWidthFloatA);
    ATTACH(GetCharWidthFloatW);
    ATTACH(GetCharWidthW);
    ATTACH(GetCharacterPlacementA);
    ATTACH(GetCharacterPlacementW);
    ATTACH(GetClassFile);
    ATTACH(GetClassInfoA);
    ATTACH(GetClassInfoExA);
    ATTACH(GetClassInfoExW);
    ATTACH(GetClassInfoW);
    ATTACH(GetClassLongA);
    ATTACH(GetClassLongW);
    ATTACH(GetClassNameA);
    ATTACH(GetClassNameW);
    ATTACH(GetClassWord);
    ATTACH(GetClientRect);
    ATTACH(GetClipBox);
    ATTACH(GetClipCursor);
    ATTACH(GetClipRgn);
    ATTACH(GetClipboardData);
    ATTACH(GetClipboardFormatNameA);
    ATTACH(GetClipboardFormatNameW);
    ATTACH(GetClipboardOwner);
    ATTACH(GetClipboardViewer);
    ATTACH(GetColorAdjustment);
    ATTACH(GetColorSpace);
    ATTACH(GetCommConfig);
    ATTACH(GetCommMask);
    ATTACH(GetCommModemStatus);
    ATTACH(GetCommProperties);
    ATTACH(GetCommState);
    ATTACH(GetCommTimeouts);
    ATTACH(GetCommandLineA);
    ATTACH(GetCommandLineW);
    ATTACH(GetComputerNameA);
    ATTACH(GetComputerNameW);
    ATTACH(GetConsoleCP);
    ATTACH(GetConsoleCursorInfo);
    ATTACH(GetConsoleMode);
    ATTACH(GetConsoleOutputCP);
    ATTACH(GetConsoleScreenBufferInfo);
    ATTACH(GetConsoleTitleA);
    ATTACH(GetConsoleTitleW);
    ATTACH(GetConvertStg);
    ATTACH(GetCurrencyFormatA);
    ATTACH(GetCurrencyFormatW);
    ATTACH(GetCurrentDirectoryA);
    ATTACH(GetCurrentDirectoryW);
    ATTACH(GetCurrentObject);
    ATTACH(GetCurrentPositionEx);
    ATTACH(GetCurrentProcess);
    ATTACH(GetCurrentProcessId);
    ATTACH(GetCurrentThreadId);
    ATTACH(GetCursor);
    ATTACH(GetCursorPos);
    ATTACH(GetDC);
    ATTACH(GetDCEx);
    ATTACH(GetDCOrgEx);
    ATTACH(GetDIBColorTable);
    ATTACH(GetDIBits);
    ATTACH(GetDateFormatA);
    ATTACH(GetDateFormatW);
    ATTACH(GetDefaultCommConfigA);
    ATTACH(GetDefaultCommConfigW);
    ATTACH(GetDesktopWindow);
    ATTACH(GetDeviceCaps);
    ATTACH(GetDeviceGammaRamp);
    ATTACH(GetDialogBaseUnits);
    ATTACH(GetDiskFreeSpaceA);
    ATTACH(GetDiskFreeSpaceExA);
    ATTACH(GetDiskFreeSpaceExW);
    ATTACH(GetDiskFreeSpaceW);
    ATTACH(GetDlgCtrlID);
    ATTACH(GetDlgItem);
    ATTACH(GetDlgItemInt);
    ATTACH(GetDlgItemTextA);
    ATTACH(GetDlgItemTextW);
    ATTACH(GetDoubleClickTime);
    ATTACH(GetDriveTypeA);
    ATTACH(GetDriveTypeW);
    ATTACH(GetEnhMetaFileA);
    ATTACH(GetEnhMetaFileBits);
    ATTACH(GetEnhMetaFileDescriptionA);
    ATTACH(GetEnhMetaFileDescriptionW);
    ATTACH(GetEnhMetaFileHeader);
    ATTACH(GetEnhMetaFilePaletteEntries);
    ATTACH(GetEnhMetaFilePixelFormat);
    ATTACH(GetEnhMetaFileW);
    ATTACH(GetEnvironmentStrings);
    ATTACH(GetEnvironmentStringsW);
    ATTACH(GetEnvironmentVariableA);
    ATTACH(GetEnvironmentVariableW);
    ATTACH(GetExitCodeProcess);
    ATTACH(GetExitCodeThread);
    ATTACH(GetFileAttributesA);
    ATTACH(GetFileAttributesExA);
    ATTACH(GetFileAttributesExW);
    ATTACH(GetFileAttributesW);
    ATTACH(GetFileInformationByHandle);
    ATTACH(GetFileSize);
    ATTACH(GetFileTime);
    ATTACH(GetFileType);
    ATTACH(GetFocus);
    ATTACH(GetFontData);
    ATTACH(GetFontLanguageInfo);
    ATTACH(GetForegroundWindow);
    ATTACH(GetFullPathNameA);
    ATTACH(GetFullPathNameW);
    ATTACH(GetGlyphOutlineA);
    ATTACH(GetGlyphOutlineW);
    ATTACH(GetGraphicsMode);
    ATTACH(GetHGlobalFromILockBytes);
    ATTACH(GetHGlobalFromStream);
    ATTACH(GetHandleInformation);
    ATTACH(GetICMProfileA);
    ATTACH(GetICMProfileW);
    ATTACH(GetIconInfo);
    ATTACH(GetInputState);
    ATTACH(GetKBCodePage);
    ATTACH(GetKerningPairsA);
    ATTACH(GetKerningPairsW);
    ATTACH(GetKeyNameTextA);
    ATTACH(GetKeyNameTextW);
    ATTACH(GetKeyState);
    ATTACH(GetKeyboardLayout);
    ATTACH(GetKeyboardLayoutList);
    ATTACH(GetKeyboardLayoutNameA);
    ATTACH(GetKeyboardLayoutNameW);
    ATTACH(GetKeyboardState);
    ATTACH(GetKeyboardType);
    ATTACH(GetLastActivePopup);
    ATTACH(GetLocalTime);
    ATTACH(GetLocaleInfoA);
    ATTACH(GetLocaleInfoW);
    ATTACH(GetLogColorSpaceA);
    ATTACH(GetLogColorSpaceW);
    ATTACH(GetLogicalDriveStringsA);
    ATTACH(GetLogicalDriveStringsW);
    ATTACH(GetLogicalDrives);
    ATTACH(GetMailslotInfo);
    ATTACH(GetMapMode);
    ATTACH(GetMenu);
    ATTACH(GetMenuCheckMarkDimensions);
    ATTACH(GetMenuContextHelpId);
    ATTACH(GetMenuDefaultItem);
    ATTACH(GetMenuItemCount);
    ATTACH(GetMenuItemID);
    ATTACH(GetMenuItemInfoA);
    ATTACH(GetMenuItemInfoW);
    ATTACH(GetMenuItemRect);
    ATTACH(GetMenuState);
    ATTACH(GetMenuStringA);
    ATTACH(GetMenuStringW);
    ATTACH(GetMessageA);
    ATTACH(GetMessageExtraInfo);
    ATTACH(GetMessagePos);
    ATTACH(GetMessageTime);
    ATTACH(GetMessageW);
    ATTACH(GetMetaFileA);
    ATTACH(GetMetaFileBitsEx);
    ATTACH(GetMetaFileW);
    ATTACH(GetMetaRgn);
    ATTACH(GetMiterLimit);
    ATTACH(GetModuleFileNameA);
    ATTACH(GetModuleFileNameW);
    ATTACH(GetModuleHandleA);
    ATTACH(GetModuleHandleW);
    ATTACH(GetNamedPipeHandleStateA);
    ATTACH(GetNamedPipeHandleStateW);
    ATTACH(GetNamedPipeInfo);
    ATTACH(GetNearestColor);
    ATTACH(GetNearestPaletteIndex);
    ATTACH(GetNextDlgGroupItem);
    ATTACH(GetNextDlgTabItem);
    ATTACH(GetNumberFormatA);
    ATTACH(GetNumberFormatW);
    ATTACH(GetNumberOfConsoleInputEvents);
    ATTACH(GetNumberOfConsoleMouseButtons);
    ATTACH(GetOEMCP);
    ATTACH(GetObjectA);
    ATTACH(GetObjectType);
    ATTACH(GetObjectW);
    ATTACH(GetOpenClipboardWindow);
    ATTACH(GetOutlineTextMetricsA);
    ATTACH(GetOutlineTextMetricsW);
    ATTACH(GetOverlappedResult);
    ATTACH(GetPaletteEntries);
    ATTACH(GetParent);
    ATTACH(GetPath);
    ATTACH(GetPixel);
    ATTACH(GetPixelFormat);
    ATTACH(GetPolyFillMode);
    ATTACH(GetPriorityClass);
    ATTACH(GetPriorityClipboardFormat);
    ATTACH(GetPrivateProfileIntA);
    ATTACH(GetPrivateProfileIntW);
    ATTACH(GetPrivateProfileSectionA);
    ATTACH(GetPrivateProfileSectionNamesA);
    ATTACH(GetPrivateProfileSectionNamesW);
    ATTACH(GetPrivateProfileSectionW);
    ATTACH(GetPrivateProfileStringA);
    ATTACH(GetPrivateProfileStringW);
    ATTACH(GetPrivateProfileStructA);
    ATTACH(GetPrivateProfileStructW);
    ATTACH(GetProcAddress);
    ATTACH(GetProcessAffinityMask);
    ATTACH(GetProcessHeaps);
    ATTACH(GetProcessShutdownParameters);
    ATTACH(GetProcessTimes);
    ATTACH(GetProcessVersion);
    ATTACH(GetProcessWindowStation);
    ATTACH(GetProcessWorkingSetSize);
    ATTACH(GetProfileIntA);
    ATTACH(GetProfileIntW);
    ATTACH(GetProfileSectionA);
    ATTACH(GetProfileSectionW);
    ATTACH(GetProfileStringA);
    ATTACH(GetProfileStringW);
    ATTACH(GetPropA);
    ATTACH(GetPropW);
    ATTACH(GetQueueStatus);
    ATTACH(GetQueuedCompletionStatus);
    ATTACH(GetROP2);
    ATTACH(GetRasterizerCaps);
    ATTACH(GetRegionData);
    ATTACH(GetRgnBox);
    ATTACH(GetRunningObjectTable);
    ATTACH(GetScrollInfo);
    ATTACH(GetScrollPos);
    ATTACH(GetScrollRange);
    ATTACH(GetShortPathNameA);
    ATTACH(GetShortPathNameW);
    ATTACH(GetStartupInfoA);
    ATTACH(GetStartupInfoW);
    ATTACH(GetStdHandle);
    ATTACH(GetStockObject);
    ATTACH(GetStretchBltMode);
    ATTACH(GetSubMenu);
    ATTACH(GetSysColor);
    ATTACH(GetSysColorBrush);
    ATTACH(GetSystemDefaultLCID);
    ATTACH(GetSystemDefaultLangID);
    ATTACH(GetSystemDirectoryA);
    ATTACH(GetSystemDirectoryW);
    ATTACH(GetSystemInfo);
    ATTACH(GetSystemMenu);
    ATTACH(GetSystemMetrics);
    ATTACH(GetSystemPaletteEntries);
    ATTACH(GetSystemPaletteUse);
    ATTACH(GetSystemPowerStatus);
    ATTACH(GetSystemTime);
    ATTACH(GetSystemTimeAdjustment);
    ATTACH(GetSystemTimeAsFileTime);
    ATTACH(GetTabbedTextExtentA);
    ATTACH(GetTabbedTextExtentW);
    ATTACH(GetTapeParameters);
    ATTACH(GetTapePosition);
    ATTACH(GetTapeStatus);
    ATTACH(GetTempFileNameA);
    ATTACH(GetTempFileNameW);
    ATTACH(GetTempPathA);
    ATTACH(GetTempPathW);
    ATTACH(GetTextAlign);
    ATTACH(GetTextCharacterExtra);
    ATTACH(GetTextCharset);
    ATTACH(GetTextCharsetInfo);
    ATTACH(GetTextColor);
    ATTACH(GetTextExtentExPointA);
    ATTACH(GetTextExtentExPointW);
    ATTACH(GetTextExtentPoint32A);
    ATTACH(GetTextExtentPoint32W);
    ATTACH(GetTextExtentPointA);
    ATTACH(GetTextExtentPointW);
    ATTACH(GetTextFaceA);
    ATTACH(GetTextFaceW);
    ATTACH(GetTextMetricsA);
    ATTACH(GetTextMetricsW);
    ATTACH(GetThreadContext);
    ATTACH(GetThreadDesktop);
#if(WINVER >= 0x0500)
    ATTACH(GetThreadLocale);
#endif // (WINVER >= 0x0500)
    ATTACH(GetThreadPriority);
    ATTACH(GetThreadPriorityBoost);
    ATTACH(GetThreadSelectorEntry);
    ATTACH(GetThreadTimes);
    ATTACH(GetTickCount);
    ATTACH(GetTimeFormatA);
    ATTACH(GetTimeFormatW);
    ATTACH(GetTimeZoneInformation);
    ATTACH(GetTopWindow);
    ATTACH(GetUpdateRect);
    ATTACH(GetUpdateRgn);
    ATTACH(GetUserDefaultLCID);
    ATTACH(GetUserDefaultLangID);
    ATTACH(GetUserObjectInformationA);
    ATTACH(GetUserObjectInformationW);
    ATTACH(GetUserObjectSecurity);
    ATTACH(GetVersion);
    ATTACH(GetVersionExA);
    ATTACH(GetVersionExW);
    ATTACH(GetViewportExtEx);
    ATTACH(GetViewportOrgEx);
    ATTACH(GetVolumeInformationA);
    ATTACH(GetVolumeInformationW);
    ATTACH(GetWinMetaFileBits);
    ATTACH(GetWindow);
    ATTACH(GetWindowContextHelpId);
    ATTACH(GetWindowDC);
    ATTACH(GetWindowExtEx);
    ATTACH(GetWindowLongA);
    ATTACH(GetWindowLongW);
    ATTACH(GetWindowOrgEx);
    ATTACH(GetWindowPlacement);
    ATTACH(GetWindowRect);
    ATTACH(GetWindowRgn);
    ATTACH(GetWindowTextA);
    ATTACH(GetWindowTextLengthA);
    ATTACH(GetWindowTextLengthW);
    ATTACH(GetWindowTextW);
    ATTACH(GetWindowThreadProcessId);
    ATTACH(GetWindowWord);
    ATTACH(GetWindowsDirectoryA);
    ATTACH(GetWindowsDirectoryW);
    ATTACH(GetWorldTransform);
    ATTACH(GlobalAddAtomA);
    ATTACH(GlobalAddAtomW);
    ATTACH(GlobalAlloc);
    ATTACH(GlobalCompact);
    ATTACH(GlobalDeleteAtom);
    ATTACH(GlobalFindAtomA);
    ATTACH(GlobalFindAtomW);
    ATTACH(GlobalFix);
    ATTACH(GlobalFlags);
    ATTACH(GlobalFree);
    ATTACH(GlobalGetAtomNameA);
    ATTACH(GlobalGetAtomNameW);
    ATTACH(GlobalHandle);
    ATTACH(GlobalLock);
    ATTACH(GlobalMemoryStatus);
    ATTACH(GlobalReAlloc);
    ATTACH(GlobalSize);
    ATTACH(GlobalUnWire);
    ATTACH(GlobalUnfix);
    ATTACH(GlobalUnlock);
    ATTACH(GlobalWire);
    ATTACH(GrayStringA);
    ATTACH(GrayStringW);
    ATTACH(HeapLock);
    ATTACH(HeapUnlock);
    ATTACH(HideCaret);
    ATTACH(HiliteMenuItem);
    ATTACH(IIDFromString);
    ATTACH(ImpersonateDdeClientWindow);
    ATTACH(InSendMessage);
    ATTACH(InflateRect);
    ATTACH(InitAtomTable);
    ATTACH(InsertMenuA);
    ATTACH(InsertMenuItemA);
    ATTACH(InsertMenuItemW);
    ATTACH(InsertMenuW);
    ATTACH(IntersectClipRect);
    ATTACH(IntersectRect);
    ATTACH(InvalidateRect);
    ATTACH(InvalidateRgn);
    ATTACH(InvertRect);
    ATTACH(InvertRgn);
    ATTACH(IsAccelerator);
    ATTACH(IsBadCodePtr);
    ATTACH(IsBadHugeReadPtr);
    ATTACH(IsBadHugeWritePtr);
    ATTACH(IsBadReadPtr);
    ATTACH(IsBadStringPtrA);
    ATTACH(IsBadStringPtrW);
    ATTACH(IsBadWritePtr);
    ATTACH(IsCharAlphaA);
    ATTACH(IsCharAlphaNumericA);
    ATTACH(IsCharAlphaNumericW);
    ATTACH(IsCharAlphaW);
    ATTACH(IsCharLowerA);
    ATTACH(IsCharLowerW);
    ATTACH(IsCharUpperA);
    ATTACH(IsCharUpperW);
    ATTACH(IsChild);
    ATTACH(IsClipboardFormatAvailable);
    ATTACH(IsDBCSLeadByte);
    ATTACH(IsDBCSLeadByteEx);
    ATTACH(IsDebuggerPresent);
    ATTACH(IsDialogMessageA);
    ATTACH(IsDialogMessageW);
    ATTACH(IsDlgButtonChecked);
    ATTACH(IsIconic);
    ATTACH(IsMenu);
#if !defined(DETOURS_ARM)
    ATTACH(IsProcessorFeaturePresent);
#endif // !DETOURS_ARM
    ATTACH(IsRectEmpty);
    ATTACH(IsValidCodePage);
    ATTACH(IsValidLocale);
    ATTACH(IsWindow);
    ATTACH(IsWindowEnabled);
    ATTACH(IsWindowUnicode);
    ATTACH(IsWindowVisible);
    ATTACH(IsZoomed);
    ATTACH(KillTimer);
    ATTACH(LPtoDP);
    ATTACH(LineDDA);
    ATTACH(LineTo);
    ATTACH(LoadAcceleratorsA);
    ATTACH(LoadAcceleratorsW);
    ATTACH(LoadBitmapA);
    ATTACH(LoadBitmapW);
    ATTACH(LoadCursorA);
    ATTACH(LoadCursorFromFileA);
    ATTACH(LoadCursorFromFileW);
    ATTACH(LoadCursorW);
    ATTACH(LoadIconA);
    ATTACH(LoadIconW);
    ATTACH(LoadImageA);
    ATTACH(LoadImageW);
    ATTACH(LoadKeyboardLayoutA);
    ATTACH(LoadKeyboardLayoutW);
    ATTACH(LoadLibraryA);
    ATTACH(LoadLibraryExA);
    ATTACH(LoadLibraryExW);
    ATTACH(LoadLibraryW);
    ATTACH(LoadMenuA);
    ATTACH(LoadMenuIndirectA);
    ATTACH(LoadMenuIndirectW);
    ATTACH(LoadMenuW);
    ATTACH(LoadModule);
    ATTACH(LoadResource);
    ATTACH(LoadStringA);
    ATTACH(LoadStringW);
    ATTACH(LocalAlloc);
    ATTACH(LocalCompact);
    ATTACH(LocalFileTimeToFileTime);
    ATTACH(LocalFlags);
    ATTACH(LocalFree);
    ATTACH(LocalHandle);
    ATTACH(LocalLock);
    ATTACH(LocalReAlloc);
    ATTACH(LocalShrink);
    ATTACH(LocalSize);
    ATTACH(LocalUnlock);
    ATTACH(LockFile);
    ATTACH(LockFileEx);
    ATTACH(LockResource);
    ATTACH(LockWindowUpdate);
    ATTACH(LookupIconIdFromDirectory);
    ATTACH(LookupIconIdFromDirectoryEx);
    ATTACH(MapDialogRect);
    ATTACH(MapViewOfFile);
    ATTACH(MapViewOfFileEx);
    ATTACH(MapVirtualKeyA);
    ATTACH(MapVirtualKeyExA);
    ATTACH(MapVirtualKeyExW);
    ATTACH(MapVirtualKeyW);
    ATTACH(MapWindowPoints);
    ATTACH(MaskBlt);
    ATTACH(MenuItemFromPoint);
    ATTACH(MessageBeep);
    ATTACH(MessageBoxA);
    ATTACH(MessageBoxExA);
    ATTACH(MessageBoxExW);
    ATTACH(MessageBoxIndirectA);
    ATTACH(MessageBoxIndirectW);
    ATTACH(MessageBoxW);
    ATTACH(MkParseDisplayName);
    ATTACH(ModifyMenuA);
    ATTACH(ModifyMenuW);
    ATTACH(ModifyWorldTransform);
    ATTACH(MonikerCommonPrefixWith);
    ATTACH(MonikerRelativePathTo);
    ATTACH(MoveFileA);
    ATTACH(MoveFileExA);
    ATTACH(MoveFileExW);
    ATTACH(MoveFileW);
    ATTACH(MoveToEx);
    ATTACH(MoveWindow);
    ATTACH(MsgWaitForMultipleObjects);
    ATTACH(MsgWaitForMultipleObjectsEx);
    ATTACH(MulDiv);
    ATTACH(OemKeyScan);
    ATTACH(OemToCharA);
    ATTACH(OemToCharBuffA);
    ATTACH(OemToCharBuffW);
    ATTACH(OemToCharW);
    ATTACH(OffsetClipRgn);
    ATTACH(OffsetRect);
    ATTACH(OffsetRgn);
    ATTACH(OffsetViewportOrgEx);
    ATTACH(OffsetWindowOrgEx);
    ATTACH(OleBuildVersion);
    ATTACH(OleConvertIStorageToOLESTREAM);
    ATTACH(OleConvertIStorageToOLESTREAMEx);
    ATTACH(OleConvertOLESTREAMToIStorage);
    ATTACH(OleConvertOLESTREAMToIStorageEx);
    ATTACH(OleCreate);
    ATTACH(OleCreateDefaultHandler);
    ATTACH(OleCreateEmbeddingHelper);
    ATTACH(OleCreateEx);
    ATTACH(OleCreateFromData);
    ATTACH(OleCreateFromDataEx);
    ATTACH(OleCreateFromFile);
    ATTACH(OleCreateFromFileEx);
    ATTACH(OleCreateLink);
    ATTACH(OleCreateLinkEx);
    ATTACH(OleCreateLinkFromData);
    ATTACH(OleCreateLinkFromDataEx);
    ATTACH(OleCreateLinkToFile);
    ATTACH(OleCreateLinkToFileEx);
    ATTACH(OleCreateMenuDescriptor);
    ATTACH(OleCreateStaticFromData);
    ATTACH(OleDestroyMenuDescriptor);
    ATTACH(OleDoAutoConvert);
    ATTACH(OleDraw);
    ATTACH(OleDuplicateData);
    ATTACH(OleFlushClipboard);
    ATTACH(OleGetAutoConvert);
    ATTACH(OleGetClipboard);
    ATTACH(OleGetIconOfClass);
    ATTACH(OleGetIconOfFile);
    ATTACH(OleInitialize);
    ATTACH(OleIsCurrentClipboard);
    ATTACH(OleIsRunning);
    ATTACH(OleLoad);
    ATTACH(OleLoadFromStream);
    ATTACH(OleLockRunning);
    ATTACH(OleMetafilePictFromIconAndLabel);
    ATTACH(OleNoteObjectVisible);
    ATTACH(OleQueryCreateFromData);
    ATTACH(OleQueryLinkFromData);
    ATTACH(OleRegEnumFormatEtc);
    ATTACH(OleRegEnumVerbs);
    ATTACH(OleRegGetMiscStatus);
    ATTACH(OleRegGetUserType);
    ATTACH(OleRun);
    ATTACH(OleSave);
    ATTACH(OleSaveToStream);
    ATTACH(OleSetAutoConvert);
    ATTACH(OleSetClipboard);
    ATTACH(OleSetContainedObject);
    ATTACH(OleSetMenuDescriptor);
    ATTACH(OleTranslateAccelerator);
    ATTACH(OleUninitialize);
    ATTACH(OpenClipboard);
    ATTACH(OpenDesktopA);
    ATTACH(OpenDesktopW);
    ATTACH(OpenEventA);
    ATTACH(OpenEventW);
    ATTACH(OpenFile);
    ATTACH(OpenFileMappingA);
    ATTACH(OpenFileMappingW);
    ATTACH(OpenIcon);
    ATTACH(OpenInputDesktop);
    ATTACH(OpenMutexA);
    ATTACH(OpenMutexW);
    ATTACH(OpenProcess);
    ATTACH(OpenProcessToken);
    ATTACH(OpenSemaphoreA);
    ATTACH(OpenSemaphoreW);
    ATTACH(OpenWaitableTimerA);
    ATTACH(OpenWaitableTimerW);
    ATTACH(OpenWindowStationA);
    ATTACH(OpenWindowStationW);
    ATTACH(OutputDebugStringA);
    ATTACH(OutputDebugStringW);
    ATTACH(PackDDElParam);
    ATTACH(PaintDesktop);
    ATTACH(PaintRgn);
    ATTACH(PatBlt);
    ATTACH(PathToRegion);
    ATTACH(PeekConsoleInputA);
    ATTACH(PeekConsoleInputW);
    ATTACH(PeekMessageA);
    ATTACH(PeekMessageW);
    ATTACH(PeekNamedPipe);
    ATTACH(Pie);
    ATTACH(PlayEnhMetaFile);
    ATTACH(PlayEnhMetaFileRecord);
    ATTACH(PlayMetaFile);
    ATTACH(PlayMetaFileRecord);
    ATTACH(PlgBlt);
    ATTACH(PolyBezier);
    ATTACH(PolyBezierTo);
    ATTACH(PolyDraw);
    ATTACH(PolyPolygon);
    ATTACH(PolyPolyline);
    ATTACH(PolyTextOutA);
    ATTACH(PolyTextOutW);
    ATTACH(Polygon);
    ATTACH(Polyline);
    ATTACH(PolylineTo);
    ATTACH(PostMessageA);
    ATTACH(PostMessageW);
    ATTACH(PostQueuedCompletionStatus);
    ATTACH(PostQuitMessage);
    ATTACH(PostThreadMessageA);
    ATTACH(PostThreadMessageW);
    ATTACH(PrepareTape);
    ATTACH(ProgIDFromCLSID);
    ATTACH(PropVariantClear);
    ATTACH(PropVariantCopy);
    ATTACH(PtInRect);
    ATTACH(PtInRegion);
    ATTACH(PtVisible);
    ATTACH(PulseEvent);
    ATTACH(PurgeComm);
    ATTACH(QueryDosDeviceA);
    ATTACH(QueryDosDeviceW);
    ATTACH(QueryPerformanceCounter);
    ATTACH(QueryPerformanceFrequency);
    ATTACH(QueueUserAPC);
    ATTACH(RaiseException);
    ATTACH(ReadClassStg);
    ATTACH(ReadClassStm);
    ATTACH(ReadConsoleA);
    ATTACH(ReadConsoleInputA);
    ATTACH(ReadConsoleInputW);
    ATTACH(ReadConsoleOutputA);
    ATTACH(ReadConsoleOutputAttribute);
    ATTACH(ReadConsoleOutputCharacterA);
    ATTACH(ReadConsoleOutputCharacterW);
    ATTACH(ReadConsoleOutputW);
    ATTACH(ReadConsoleW);
    ATTACH(ReadDirectoryChangesW);
    ATTACH(ReadFile);
    ATTACH(ReadFileEx);
    ATTACH(ReadFmtUserTypeStg);
    ATTACH(ReadProcessMemory);
    ATTACH(RealizePalette);
    ATTACH(RectInRegion);
    ATTACH(RectVisible);
    ATTACH(Rectangle);
    ATTACH(RedrawWindow);
    ATTACH(RegisterClassA);
    ATTACH(RegisterClassExA);
    ATTACH(RegisterClassExW);
    ATTACH(RegisterClassW);
    ATTACH(RegisterClipboardFormatA);
    ATTACH(RegisterClipboardFormatW);
    ATTACH(RegisterDragDrop);
    ATTACH(RegisterHotKey);
    ATTACH(RegisterWindowMessageA);
    ATTACH(RegisterWindowMessageW);
    ATTACH(ReleaseCapture);
    ATTACH(ReleaseDC);
    ATTACH(ReleaseMutex);
    ATTACH(ReleaseSemaphore);
    ATTACH(ReleaseStgMedium);
    ATTACH(RemoveDirectoryA);
    ATTACH(RemoveDirectoryW);
    ATTACH(RemoveFontResourceA);
    ATTACH(RemoveFontResourceW);
    ATTACH(RemoveMenu);
    ATTACH(RemovePropA);
    ATTACH(RemovePropW);
    ATTACH(ReplyMessage);
    ATTACH(ResetDCA);
    ATTACH(ResetDCW);
    ATTACH(ResetEvent);
    ATTACH(ResizePalette);
    ATTACH(RestoreDC);
    ATTACH(ResumeThread);
    ATTACH(ReuseDDElParam);
    ATTACH(RevokeDragDrop);
    ATTACH(RoundRect);
    ATTACH(SaveDC);
    ATTACH(ScaleViewportExtEx);
    ATTACH(ScaleWindowExtEx);
    ATTACH(ScreenToClient);
    ATTACH(ScrollConsoleScreenBufferA);
    ATTACH(ScrollConsoleScreenBufferW);
    ATTACH(ScrollDC);
    ATTACH(ScrollWindow);
    ATTACH(ScrollWindowEx);
    ATTACH(SearchPathA);
    ATTACH(SearchPathW);
    ATTACH(SelectClipPath);
    ATTACH(SelectClipRgn);
    ATTACH(SelectObject);
    ATTACH(SelectPalette);
    ATTACH(SendDlgItemMessageA);
    ATTACH(SendDlgItemMessageW);
    ATTACH(SendMessageA);
    ATTACH(SendMessageCallbackA);
    ATTACH(SendMessageCallbackW);
    ATTACH(SendMessageTimeoutA);
    ATTACH(SendMessageTimeoutW);
    ATTACH(SendMessageW);
    ATTACH(SendNotifyMessageA);
    ATTACH(SendNotifyMessageW);
    ATTACH(SetAbortProc);
    ATTACH(SetActiveWindow);
    ATTACH(SetArcDirection);
    ATTACH(SetBitmapBits);
    ATTACH(SetBitmapDimensionEx);
    ATTACH(SetBkColor);
    ATTACH(SetBkMode);
    ATTACH(SetBoundsRect);
    ATTACH(SetBrushOrgEx);
    ATTACH(SetCapture);
    ATTACH(SetCaretBlinkTime);
    ATTACH(SetCaretPos);
    ATTACH(SetClassLongA);
    ATTACH(SetClassLongW);
    ATTACH(SetClassWord);
    ATTACH(SetClipboardData);
    ATTACH(SetClipboardViewer);
    ATTACH(SetColorAdjustment);
    ATTACH(SetColorSpace);
    ATTACH(SetCommBreak);
    ATTACH(SetCommConfig);
    ATTACH(SetCommMask);
    ATTACH(SetCommState);
    ATTACH(SetCommTimeouts);
    ATTACH(SetComputerNameA);
    ATTACH(SetComputerNameW);
    ATTACH(SetConsoleActiveScreenBuffer);
    ATTACH(SetConsoleCP);
    ATTACH(SetConsoleCtrlHandler);
    ATTACH(SetConsoleCursorInfo);
    ATTACH(SetConsoleCursorPosition);
    ATTACH(SetConsoleMode);
    ATTACH(SetConsoleOutputCP);
    ATTACH(SetConsoleScreenBufferSize);
    ATTACH(SetConsoleTextAttribute);
    ATTACH(SetConsoleTitleA);
    ATTACH(SetConsoleTitleW);
    ATTACH(SetConsoleWindowInfo);
    ATTACH(SetConvertStg);
    ATTACH(SetCurrentDirectoryA);
    ATTACH(SetCurrentDirectoryW);
    ATTACH(SetCursor);
    ATTACH(SetCursorPos);
    ATTACH(SetDIBColorTable);
    ATTACH(SetDIBits);
    ATTACH(SetDIBitsToDevice);
    ATTACH(SetDefaultCommConfigA);
    ATTACH(SetDefaultCommConfigW);
    ATTACH(SetDeviceGammaRamp);
    ATTACH(SetDlgItemInt);
    ATTACH(SetDlgItemTextA);
    ATTACH(SetDlgItemTextW);
    ATTACH(SetDoubleClickTime);
    ATTACH(SetEndOfFile);
    ATTACH(SetEnhMetaFileBits);
    ATTACH(SetEnvironmentVariableA);
    ATTACH(SetEnvironmentVariableW);
    ATTACH(SetErrorMode);
    ATTACH(SetEvent);
    ATTACH(SetFileApisToANSI);
    ATTACH(SetFileApisToOEM);
    ATTACH(SetFileAttributesA);
    ATTACH(SetFileAttributesW);
    ATTACH(SetFilePointer);
    ATTACH(SetFileTime);
    ATTACH(SetFocus);
    ATTACH(SetForegroundWindow);
    ATTACH(SetGraphicsMode);
    ATTACH(SetHandleCount);
    ATTACH(SetHandleInformation);
    ATTACH(SetICMMode);
    ATTACH(SetICMProfileA);
    ATTACH(SetICMProfileW);
    ATTACH(SetKeyboardState);
    ATTACH(SetLocalTime);
    ATTACH(SetLocaleInfoA);
    ATTACH(SetLocaleInfoW);
    ATTACH(SetMailslotInfo);
    ATTACH(SetMapMode);
    ATTACH(SetMapperFlags);
    ATTACH(SetMenu);
    ATTACH(SetMenuContextHelpId);
    ATTACH(SetMenuDefaultItem);
    ATTACH(SetMenuItemBitmaps);
    ATTACH(SetMenuItemInfoA);
    ATTACH(SetMenuItemInfoW);
    ATTACH(SetMessageExtraInfo);
    ATTACH(SetMessageQueue);
    ATTACH(SetMetaFileBitsEx);
    ATTACH(SetMetaRgn);
    ATTACH(SetMiterLimit);
    ATTACH(SetNamedPipeHandleState);
    ATTACH(SetPaletteEntries);
    ATTACH(SetParent);
    ATTACH(SetPixel);
    ATTACH(SetPixelFormat);
    ATTACH(SetPixelV);
    ATTACH(SetPolyFillMode);
    ATTACH(SetPriorityClass);
    ATTACH(SetProcessAffinityMask);
    ATTACH(SetProcessShutdownParameters);
    ATTACH(SetProcessWindowStation);
    ATTACH(SetProcessWorkingSetSize);
    ATTACH(SetPropA);
    ATTACH(SetPropW);
    ATTACH(SetROP2);
    ATTACH(SetRect);
    ATTACH(SetRectEmpty);
    ATTACH(SetRectRgn);
    ATTACH(SetScrollInfo);
    ATTACH(SetScrollPos);
    ATTACH(SetScrollRange);
    ATTACH(SetStdHandle);
    ATTACH(SetStretchBltMode);
    ATTACH(SetSysColors);
    ATTACH(SetSystemCursor);
    ATTACH(SetSystemPaletteUse);
    ATTACH(SetSystemPowerState);
    ATTACH(SetSystemTime);
    ATTACH(SetSystemTimeAdjustment);
    ATTACH(SetTapeParameters);
    ATTACH(SetTapePosition);
    ATTACH(SetTextAlign);
    ATTACH(SetTextCharacterExtra);
    ATTACH(SetTextColor);
    ATTACH(SetTextJustification);
    ATTACH(SetThreadAffinityMask);
    ATTACH(SetThreadContext);
    ATTACH(SetThreadDesktop);
    ATTACH(SetThreadIdealProcessor);
#if(WINVER >= 0x0500)
    ATTACH(SetThreadLocale);
#endif // (WINVER >= 0x0500)
    ATTACH(SetThreadPriority);
    ATTACH(SetThreadPriorityBoost);
    ATTACH(SetTimeZoneInformation);
    ATTACH(SetTimer);
    ATTACH(SetUnhandledExceptionFilter);
    ATTACH(SetUserObjectInformationA);
    ATTACH(SetUserObjectInformationW);
    ATTACH(SetUserObjectSecurity);
    ATTACH(SetViewportExtEx);
    ATTACH(SetViewportOrgEx);
    ATTACH(SetVolumeLabelA);
    ATTACH(SetVolumeLabelW);
    ATTACH(SetWaitableTimer);
    ATTACH(SetWinMetaFileBits);
    ATTACH(SetWindowContextHelpId);
    ATTACH(SetWindowExtEx);
    ATTACH(SetWindowLongA);
    ATTACH(SetWindowLongW);
    ATTACH(SetWindowOrgEx);
    ATTACH(SetWindowPlacement);
    ATTACH(SetWindowPos);
    ATTACH(SetWindowRgn);
    ATTACH(SetWindowTextA);
    ATTACH(SetWindowTextW);
    ATTACH(SetWindowWord);
    ATTACH(SetWindowsHookA);
    ATTACH(SetWindowsHookExA);
    ATTACH(SetWindowsHookExW);
    ATTACH(SetWindowsHookW);
    ATTACH(SetWorldTransform);
    ATTACH(SetupComm);
    ATTACH(ShowCaret);
    ATTACH(ShowCursor);
    ATTACH(ShowOwnedPopups);
    ATTACH(ShowScrollBar);
    ATTACH(ShowWindow);
    ATTACH(ShowWindowAsync);
    ATTACH(SignalObjectAndWait);
    ATTACH(SizeofResource);
    ATTACH(SleepEx);
    ATTACH(StartDocA);
    ATTACH(StartDocW);
    ATTACH(StartPage);
    ATTACH(StgCreateDocfile);
    ATTACH(StgCreateDocfileOnILockBytes);
    ATTACH(StgCreatePropSetStg);
    ATTACH(StgCreatePropStg);
    ATTACH(StgCreateStorageEx);
    ATTACH(StgGetIFillLockBytesOnFile);
    ATTACH(StgGetIFillLockBytesOnILockBytes);
    ATTACH(StgIsStorageFile);
    ATTACH(StgIsStorageILockBytes);
    ATTACH(StgOpenAsyncDocfileOnIFillLockBytes);
    ATTACH(StgOpenPropStg);
    ATTACH(StgOpenStorage);
    ATTACH(StgOpenStorageEx);
    ATTACH(StgOpenStorageOnILockBytes);
    ATTACH(StgSetTimes);
    ATTACH(StretchBlt);
    ATTACH(StretchDIBits);
    ATTACH(StringFromCLSID);
    ATTACH(StringFromGUID2);
    ATTACH(StringFromIID);
    ATTACH(StrokeAndFillPath);
    ATTACH(StrokePath);
    ATTACH(SubtractRect);
    ATTACH(SuspendThread);
    ATTACH(SwapBuffers);
    ATTACH(SwapMouseButton);
    ATTACH(SwitchDesktop);
    ATTACH(SwitchToFiber);
    ATTACH(SwitchToThread);
    ATTACH(SystemParametersInfoA);
    ATTACH(SystemParametersInfoW);
    ATTACH(SystemTimeToFileTime);
    ATTACH(SystemTimeToTzSpecificLocalTime);
    ATTACH(TabbedTextOutA);
    ATTACH(TabbedTextOutW);
    ATTACH(TerminateProcess);
    ATTACH(TerminateThread);
    ATTACH(TextOutA);
    ATTACH(TextOutW);
    ATTACH(TileWindows);
    ATTACH(ToAscii);
    ATTACH(ToAsciiEx);
    ATTACH(ToUnicode);
    ATTACH(ToUnicodeEx);
    ATTACH(TrackMouseEvent);
    ATTACH(TrackPopupMenu);
    ATTACH(TrackPopupMenuEx);
    ATTACH(TransactNamedPipe);
    ATTACH(TranslateAcceleratorA);
    ATTACH(TranslateAcceleratorW);
    ATTACH(TranslateCharsetInfo);
    ATTACH(TranslateMDISysAccel);
    ATTACH(TranslateMessage);
    ATTACH(TransmitCommChar);
#if DETOUR_TryEnterCriticalSection_EVEN_IF_IT_EXERCISES_A_BUG_IN_RtlLookupFunctionTable
    ATTACH(TryEnterCriticalSection);
#endif
    ATTACH(UnhookWindowsHook);
    ATTACH(UnhookWindowsHookEx);
    ATTACH(UnionRect);
    ATTACH(UnloadKeyboardLayout);
    ATTACH(UnlockFile);
    ATTACH(UnlockFileEx);
    ATTACH(UnmapViewOfFile);
    ATTACH(UnpackDDElParam);
    ATTACH(UnrealizeObject);
    ATTACH(UnregisterClassA);
    ATTACH(UnregisterClassW);
    ATTACH(UnregisterHotKey);
    ATTACH(UpdateColors);
    ATTACH(UpdateResourceA);
    ATTACH(UpdateResourceW);
    ATTACH(UpdateWindow);
    ATTACH(ValidateRect);
    ATTACH(ValidateRgn);
    ATTACH(VerLanguageNameA);
    ATTACH(VerLanguageNameW);
    ATTACH(VirtualAllocEx);
    ATTACH(VirtualFreeEx);
    ATTACH(VirtualProtectEx);
    ATTACH(VirtualQueryEx);
    ATTACH(VkKeyScanA);
    ATTACH(VkKeyScanExA);
    ATTACH(VkKeyScanExW);
    ATTACH(VkKeyScanW);
    ATTACH(WSAAccept);
    ATTACH(WSAAddressToStringA);
    ATTACH(WSAAddressToStringW);
    ATTACH(WSAAsyncGetHostByAddr);
    ATTACH(WSAAsyncGetHostByName);
    ATTACH(WSAAsyncGetProtoByName);
    ATTACH(WSAAsyncGetProtoByNumber);
    ATTACH(WSAAsyncGetServByName);
    ATTACH(WSAAsyncGetServByPort);
    ATTACH(WSAAsyncSelect);
    ATTACH(WSACancelAsyncRequest);
    ATTACH(WSACancelBlockingCall);
    ATTACH(WSACleanup);
    ATTACH(WSACloseEvent);
    ATTACH(WSAConnect);
    ATTACH(WSACreateEvent);
    ATTACH(WSADuplicateSocketA);
    ATTACH(WSADuplicateSocketW);
    ATTACH(WSAEnumNameSpaceProvidersA);
    ATTACH(WSAEnumNameSpaceProvidersW);
    ATTACH(WSAEnumNetworkEvents);
    ATTACH(WSAEnumProtocolsA);
    ATTACH(WSAEnumProtocolsW);
    ATTACH(WSAEventSelect);
    ATTACH(WSAGetOverlappedResult);
    ATTACH(WSAGetQOSByName);
    ATTACH(WSAGetServiceClassInfoA);
    ATTACH(WSAGetServiceClassInfoW);
    ATTACH(WSAGetServiceClassNameByClassIdA);
    ATTACH(WSAGetServiceClassNameByClassIdW);
    ATTACH(WSAHtonl);
    ATTACH(WSAHtons);
    ATTACH(WSAInstallServiceClassA);
    ATTACH(WSAInstallServiceClassW);
    ATTACH(WSAIoctl);
    ATTACH(WSAIsBlocking);
    ATTACH(WSAJoinLeaf);
    ATTACH(WSALookupServiceBeginA);
    ATTACH(WSALookupServiceBeginW);
    ATTACH(WSALookupServiceEnd);
    ATTACH(WSALookupServiceNextA);
    ATTACH(WSALookupServiceNextW);
    ATTACH(WSANtohl);
    ATTACH(WSANtohs);
    ATTACH(WSAProviderConfigChange);
    ATTACH(WSARecv);
    ATTACH(WSARecvDisconnect);
    ATTACH(WSARecvFrom);
    ATTACH(WSARemoveServiceClass);
    ATTACH(WSAResetEvent);
    ATTACH(WSASend);
    ATTACH(WSASendDisconnect);
    ATTACH(WSASendTo);
    ATTACH(WSASetBlockingHook);
    ATTACH(WSASetEvent);
    ATTACH(WSASetServiceA);
    ATTACH(WSASetServiceW);
    ATTACH(WSASocketA);
    ATTACH(WSASocketW);
    ATTACH(WSAStartup);
    ATTACH(WSAStringToAddressA);
    ATTACH(WSAStringToAddressW);
    ATTACH(WSAUnhookBlockingHook);
    ATTACH(WSAWaitForMultipleEvents);
    ATTACH(WaitCommEvent);
#if !defined(DETOURS_ARM)
    ATTACH(WaitForDebugEvent);
#endif // !DETOURS_ARM
    ATTACH(WaitForInputIdle);
    ATTACH(WaitForMultipleObjects);
    ATTACH(WaitForMultipleObjectsEx);
    ATTACH(WaitForSingleObject);
    ATTACH(WaitForSingleObjectEx);
    ATTACH(WaitMessage);
    ATTACH(WaitNamedPipeA);
    ATTACH(WaitNamedPipeW);
    ATTACH(WidenPath);
    ATTACH(WinExec);
    ATTACH(WinHelpA);
    ATTACH(WinHelpW);
    ATTACH(WindowFromDC);
    ATTACH(WindowFromPoint);
    ATTACH(WriteClassStg);
    ATTACH(WriteClassStm);
    ATTACH(WriteConsoleA);
    ATTACH(WriteConsoleInputA);
    ATTACH(WriteConsoleInputW);
    ATTACH(WriteConsoleOutputA);
    ATTACH(WriteConsoleOutputAttribute);
    ATTACH(WriteConsoleOutputCharacterA);
    ATTACH(WriteConsoleOutputCharacterW);
    ATTACH(WriteConsoleOutputW);
    ATTACH(WriteConsoleW);
    ATTACH(WriteFile);
    ATTACH(WriteFileEx);
    ATTACH(WriteFmtUserTypeStg);
    ATTACH(WritePrivateProfileSectionA);
    ATTACH(WritePrivateProfileSectionW);
    ATTACH(WritePrivateProfileStringA);
    ATTACH(WritePrivateProfileStringW);
    ATTACH(WritePrivateProfileStructA);
    ATTACH(WritePrivateProfileStructW);
    ATTACH(WriteProcessMemory);
    ATTACH(WriteProfileSectionA);
    ATTACH(WriteProfileSectionW);
    ATTACH(WriteProfileStringA);
    ATTACH(WriteProfileStringW);
    ATTACH(WriteTapemark);
    ATTACH(__WSAFDIsSet);
    ATTACH(_hread);
    ATTACH(_hwrite);
    ATTACH(_lclose);
    ATTACH(_lcreat);
    ATTACH(_llseek);
    ATTACH(_lopen);
    ATTACH(_lread);
    ATTACH(_lwrite);
    ATTACH(accept);
    ATTACH(bind);
    ATTACH(closesocket);
    ATTACH(connect);
    ATTACH(gethostbyaddr);
    ATTACH(gethostbyname);
    ATTACH(gethostname);
    ATTACH(getpeername);
    ATTACH(getprotobyname);
    ATTACH(getprotobynumber);
    ATTACH(getservbyname);
    ATTACH(getservbyport);
    ATTACH(getsockname);
    ATTACH(getsockopt);
    ATTACH(htonl);
    ATTACH(htons);
    ATTACH(inet_addr);
    ATTACH(inet_ntoa);
    ATTACH(ioctlsocket);
    ATTACH(keybd_event);
    ATTACH(listen);
    ATTACH(mouse_event);
    ATTACH(ntohl);
    ATTACH(ntohs);
    ATTACH(recv);
    ATTACH(recvfrom);
    ATTACH(select);
    ATTACH(send);
    ATTACH(sendto);
    ATTACH(setsockopt);
    ATTACH(shutdown);
    ATTACH(socket);

    PVOID *ppbFailedPointer = NULL;
    LONG error = DetourTransactionCommitEx(&ppbFailedPointer);
    if (error != 0) {
        printf("traceapi.dll: Attach transaction failed to commit. Error %ld (%p/%p)",
               error, ppbFailedPointer, *ppbFailedPointer);
        return error;
    }
    return 0;
}

LONG DetachDetours(VOID)
{
    DetourTransactionBegin();
    DetourUpdateThread(GetCurrentThread());

    // For this many APIs, we'll ignore one or two can't be detoured.
    DetourSetIgnoreTooSmall(TRUE);

    DETACH(AbortDoc);
    DETACH(AbortPath);
    DETACH(ActivateKeyboardLayout);
    DETACH(AddAtomA);
    DETACH(AddAtomW);
    DETACH(AddFontResourceA);
    DETACH(AddFontResourceW);
    DETACH(AdjustWindowRect);
    DETACH(AdjustWindowRectEx);
    DETACH(AllocConsole);
    DETACH(AngleArc);
    DETACH(AnimatePalette);
    DETACH(AnyPopup);
    DETACH(AppendMenuA);
    DETACH(AppendMenuW);
    DETACH(Arc);
    DETACH(ArcTo);
    DETACH(AreFileApisANSI);
    DETACH(ArrangeIconicWindows);
    DETACH(AttachThreadInput);
    DETACH(BackupRead);
    DETACH(BackupSeek);
    DETACH(BackupWrite);
    DETACH(Beep);
    DETACH(BeginDeferWindowPos);
    DETACH(BeginPaint);
    DETACH(BeginPath);
    DETACH(BeginUpdateResourceA);
    DETACH(BeginUpdateResourceW);
    DETACH(BindMoniker);
    DETACH(BitBlt);
    DETACH(BringWindowToTop);
    DETACH(BroadcastSystemMessageA);
    DETACH(BroadcastSystemMessageW);
    DETACH(BuildCommDCBA);
    DETACH(BuildCommDCBAndTimeoutsA);
    DETACH(BuildCommDCBAndTimeoutsW);
    DETACH(BuildCommDCBW);
    DETACH(CLSIDFromProgID);
    DETACH(CLSIDFromString);
    DETACH(CallMsgFilterA);
    DETACH(CallMsgFilterW);
    DETACH(CallNamedPipeA);
    DETACH(CallNamedPipeW);
    DETACH(CallNextHookEx);
    DETACH(CallWindowProcA);
    DETACH(CallWindowProcW);
    DETACH(CancelDC);
    DETACH(CancelIo);
    DETACH(CancelWaitableTimer);
    DETACH(CascadeWindows);
    DETACH(ChangeClipboardChain);
    DETACH(ChangeDisplaySettingsA);
    DETACH(ChangeDisplaySettingsExA);
    DETACH(ChangeDisplaySettingsExW);
    DETACH(ChangeDisplaySettingsW);
    DETACH(ChangeMenuA);
    DETACH(ChangeMenuW);
    DETACH(CharLowerA);
    DETACH(CharLowerBuffA);
    DETACH(CharLowerBuffW);
    DETACH(CharLowerW);
    DETACH(CharNextA);
    DETACH(CharNextExA);
    DETACH(CharNextW);
    DETACH(CharPrevA);
    DETACH(CharPrevExA);
    DETACH(CharPrevW);
    DETACH(CharToOemA);
    DETACH(CharToOemBuffA);
    DETACH(CharToOemBuffW);
    DETACH(CharToOemW);
    DETACH(CharUpperA);
    DETACH(CharUpperBuffA);
    DETACH(CharUpperBuffW);
    DETACH(CharUpperW);
    DETACH(CheckColorsInGamut);
    DETACH(CheckDlgButton);
    DETACH(CheckMenuItem);
    DETACH(CheckMenuRadioItem);
    DETACH(CheckRadioButton);
    DETACH(ChildWindowFromPoint);
    DETACH(ChildWindowFromPointEx);
    DETACH(ChoosePixelFormat);
    DETACH(Chord);
    DETACH(ClearCommBreak);
    DETACH(ClearCommError);
    DETACH(ClientToScreen);
    DETACH(ClipCursor);
    DETACH(CloseClipboard);
    DETACH(CloseDesktop);
    DETACH(CloseEnhMetaFile);
    DETACH(CloseFigure);
    DETACH(CloseHandle);
    DETACH(CloseMetaFile);
    DETACH(CloseWindow);
    DETACH(CloseWindowStation);
    DETACH(CoAddRefServerProcess);
    DETACH(CoBuildVersion);
    DETACH(CoCopyProxy);
    DETACH(CoCreateFreeThreadedMarshaler);
    DETACH(CoCreateGuid);
    DETACH(CoCreateInstance);
    DETACH(CoCreateInstanceEx);
    DETACH(CoDisconnectObject);
    DETACH(CoDosDateTimeToFileTime);
    DETACH(CoFileTimeNow);
    DETACH(CoFileTimeToDosDateTime);
    DETACH(CoFreeAllLibraries);
    DETACH(CoFreeLibrary);
    DETACH(CoFreeUnusedLibraries);
    DETACH(CoGetCallContext);
    DETACH(CoGetClassObject);
    DETACH(CoGetCurrentProcess);
    DETACH(CoGetInstanceFromFile);
    DETACH(CoGetInstanceFromIStorage);
    DETACH(CoGetInterfaceAndReleaseStream);
    DETACH(CoGetMalloc);
    DETACH(CoGetMarshalSizeMax);
    DETACH(CoGetObject);
    DETACH(CoGetPSClsid);
    DETACH(CoGetStandardMarshal);
    DETACH(CoGetStdMarshalEx);
    DETACH(CoGetTreatAsClass);
    DETACH(CoImpersonateClient);
    DETACH(CoInitialize);
    DETACH(CoInitializeEx);
    DETACH(CoInitializeSecurity);
    DETACH(CoIsHandlerConnected);
    DETACH(CoIsOle1Class);
    DETACH(CoLoadLibrary);
    DETACH(CoLockObjectExternal);
    DETACH(CoMarshalHresult);
    DETACH(CoMarshalInterThreadInterfaceInStream);
    DETACH(CoMarshalInterface);
    DETACH(CoQueryAuthenticationServices);
    DETACH(CoQueryClientBlanket);
    DETACH(CoQueryProxyBlanket);
    DETACH(CoRegisterChannelHook);
    DETACH(CoRegisterClassObject);
    DETACH(CoRegisterMallocSpy);
    DETACH(CoRegisterMessageFilter);
    DETACH(CoRegisterPSClsid);
    DETACH(CoRegisterSurrogate);
    DETACH(CoReleaseMarshalData);
    DETACH(CoReleaseServerProcess);
    DETACH(CoResumeClassObjects);
    DETACH(CoRevertToSelf);
    DETACH(CoRevokeClassObject);
    DETACH(CoRevokeMallocSpy);
    DETACH(CoSetProxyBlanket);
    DETACH(CoSuspendClassObjects);
    DETACH(CoSwitchCallContext);
    DETACH(CoTaskMemAlloc);
    DETACH(CoTaskMemFree);
    DETACH(CoTaskMemRealloc);
    DETACH(CoTreatAsClass);
    DETACH(CoUninitialize);
    DETACH(CoUnmarshalHresult);
    DETACH(CoUnmarshalInterface);
    DETACH(ColorMatchToTarget);
    DETACH(CombineRgn);
    DETACH(CombineTransform);
    DETACH(CommConfigDialogA);
    DETACH(CommConfigDialogW);
    DETACH(CompareFileTime);
    DETACH(CompareStringA);
    DETACH(CompareStringW);
    DETACH(ConnectNamedPipe);
#if !defined(DETOURS_ARM)
    DETACH(ContinueDebugEvent);
#endif // !DETOURS_ARM
    DETACH(ConvertDefaultLocale);
    DETACH(ConvertThreadToFiber);
    DETACH(CopyAcceleratorTableA);
    DETACH(CopyAcceleratorTableW);
    DETACH(CopyEnhMetaFileA);
    DETACH(CopyEnhMetaFileW);
    DETACH(CopyFileA);
    DETACH(CopyFileExA);
    DETACH(CopyFileExW);
    DETACH(CopyFileW);
    DETACH(CopyIcon);
    DETACH(CopyImage);
    DETACH(CopyMetaFileA);
    DETACH(CopyMetaFileW);
    DETACH(CopyRect);
    DETACH(CountClipboardFormats);
    DETACH(CreateAcceleratorTableA);
    DETACH(CreateAcceleratorTableW);
    DETACH(CreateAntiMoniker);
    DETACH(CreateBindCtx);
    DETACH(CreateBitmap);
    DETACH(CreateBitmapIndirect);
    DETACH(CreateBrushIndirect);
    DETACH(CreateCaret);
    DETACH(CreateClassMoniker);
    DETACH(CreateColorSpaceA);
    DETACH(CreateColorSpaceW);
    DETACH(CreateCompatibleBitmap);
    DETACH(CreateCompatibleDC);
    DETACH(CreateConsoleScreenBuffer);
    DETACH(CreateCursor);
    DETACH(CreateDCA);
    DETACH(CreateDCW);
    DETACH(CreateDIBPatternBrush);
    DETACH(CreateDIBPatternBrushPt);
    DETACH(CreateDIBSection);
    DETACH(CreateDIBitmap);
    DETACH(CreateDataAdviseHolder);
    DETACH(CreateDataCache);
    DETACH(CreateDesktopA);
    DETACH(CreateDesktopW);
    DETACH(CreateDialogIndirectParamA);
    DETACH(CreateDialogIndirectParamW);
    DETACH(CreateDialogParamA);
    DETACH(CreateDialogParamW);
    DETACH(CreateDirectoryA);
    DETACH(CreateDirectoryExA);
    DETACH(CreateDirectoryExW);
    DETACH(CreateDirectoryW);
    DETACH(CreateDiscardableBitmap);
    DETACH(CreateEllipticRgn);
    DETACH(CreateEllipticRgnIndirect);
    DETACH(CreateEnhMetaFileA);
    DETACH(CreateEnhMetaFileW);
    DETACH(CreateEventA);
    DETACH(CreateEventW);
    DETACH(CreateFiber);
    DETACH(CreateFileA);
    DETACH(CreateFileMappingA);
    DETACH(CreateFileMappingW);
    DETACH(CreateFileMoniker);
    DETACH(CreateFileW);
    DETACH(CreateFontA);
    DETACH(CreateFontIndirectA);
    DETACH(CreateFontIndirectW);
    DETACH(CreateFontW);
    DETACH(CreateGenericComposite);
    DETACH(CreateHalftonePalette);
    DETACH(CreateHatchBrush);
    DETACH(CreateICA);
    DETACH(CreateICW);
    DETACH(CreateILockBytesOnHGlobal);
    DETACH(CreateIcon);
    DETACH(CreateIconFromResource);
    DETACH(CreateIconFromResourceEx);
    DETACH(CreateIconIndirect);
    DETACH(CreateIoCompletionPort);
    DETACH(CreateItemMoniker);
    DETACH(CreateMDIWindowA);
    DETACH(CreateMDIWindowW);
    DETACH(CreateMailslotA);
    DETACH(CreateMailslotW);
    DETACH(CreateMenu);
    DETACH(CreateMetaFileA);
    DETACH(CreateMetaFileW);
    DETACH(CreateMutexA);
    DETACH(CreateMutexW);
    DETACH(CreateNamedPipeA);
    DETACH(CreateNamedPipeW);
    DETACH(CreateOleAdviseHolder);
    DETACH(CreatePalette);
    DETACH(CreatePatternBrush);
    DETACH(CreatePen);
    DETACH(CreatePenIndirect);
    DETACH(CreatePipe);
    DETACH(CreatePointerMoniker);
    DETACH(CreatePolyPolygonRgn);
    DETACH(CreatePolygonRgn);
    DETACH(CreatePopupMenu);
    DETACH(CreateProcessA);
    DETACH(CreateProcessW);
    DETACH(CreateProcessAsUserA);
    DETACH(CreateProcessAsUserW);
#if(_WIN32_WINNT >= 0x0500)
    DETACH(CreateProcessWithLogonW);
    DETACH(CreateProcessWithTokenW);
#endif //(_WIN32_WINNT >= 0x0500)
    DETACH(CreateRectRgn);
    DETACH(CreateRectRgnIndirect);
    DETACH(CreateRemoteThread);
    DETACH(CreateRoundRectRgn);
    DETACH(CreateScalableFontResourceA);
    DETACH(CreateScalableFontResourceW);
    DETACH(CreateSemaphoreA);
    DETACH(CreateSemaphoreW);
    DETACH(CreateSolidBrush);
    DETACH(CreateStdProgressIndicator);
    DETACH(CreateStreamOnHGlobal);
    DETACH(CreateTapePartition);
    DETACH(CreateThread);
    DETACH(CreateWaitableTimerA);
    DETACH(CreateWaitableTimerW);
    DETACH(CreateWindowExA);
    DETACH(CreateWindowExW);
    DETACH(CreateWindowStationA);
    DETACH(CreateWindowStationW);
    DETACH(DPtoLP);
    DETACH(DdeAbandonTransaction);
    DETACH(DdeAccessData);
    DETACH(DdeAddData);
    DETACH(DdeClientTransaction);
    DETACH(DdeCmpStringHandles);
    DETACH(DdeConnect);
    DETACH(DdeConnectList);
    DETACH(DdeCreateDataHandle);
    DETACH(DdeCreateStringHandleA);
    DETACH(DdeCreateStringHandleW);
    DETACH(DdeDisconnect);
    DETACH(DdeDisconnectList);
    DETACH(DdeEnableCallback);
    DETACH(DdeFreeDataHandle);
    DETACH(DdeFreeStringHandle);
    DETACH(DdeGetData);
    DETACH(DdeGetLastError);
    DETACH(DdeImpersonateClient);
    DETACH(DdeKeepStringHandle);
    DETACH(DdeNameService);
    DETACH(DdePostAdvise);
    DETACH(DdeQueryConvInfo);
    DETACH(DdeQueryNextServer);
    DETACH(DdeQueryStringA);
    DETACH(DdeQueryStringW);
    DETACH(DdeReconnect);
    DETACH(DdeSetQualityOfService);
    DETACH(DdeSetUserHandle);
    DETACH(DdeUnaccessData);
    DETACH(DdeUninitialize);
    DETACH(DebugActiveProcess);
    DETACH(DebugActiveProcessStop);
    DETACH(DebugBreak);
    DETACH(DefDlgProcA);
    DETACH(DefDlgProcW);
    DETACH(DefFrameProcA);
    DETACH(DefFrameProcW);
    DETACH(DefMDIChildProcA);
    DETACH(DefMDIChildProcW);
    DETACH(DefWindowProcA);
    DETACH(DefWindowProcW);
    DETACH(DeferWindowPos);
    DETACH(DefineDosDeviceA);
    DETACH(DefineDosDeviceW);
    DETACH(DeleteAtom);
    DETACH(DeleteColorSpace);
    DETACH(DeleteDC);
    DETACH(DeleteEnhMetaFile);
    DETACH(DeleteFiber);
    DETACH(DeleteFileA);
    DETACH(DeleteFileW);
    DETACH(DeleteMenu);
    DETACH(DeleteMetaFile);
    DETACH(DeleteObject);
    DETACH(DescribePixelFormat);
    DETACH(DestroyAcceleratorTable);
    DETACH(DestroyCaret);
    DETACH(DestroyCursor);
    DETACH(DestroyIcon);
    DETACH(DestroyMenu);
    DETACH(DestroyWindow);
    DETACH(DeviceIoControl);
    DETACH(DialogBoxIndirectParamA);
    DETACH(DialogBoxIndirectParamW);
    DETACH(DialogBoxParamA);
    DETACH(DialogBoxParamW);
    DETACH(DisableThreadLibraryCalls);
    DETACH(DisconnectNamedPipe);
    DETACH(DispatchMessageA);
    DETACH(DispatchMessageW);
    DETACH(DlgDirListA);
    DETACH(DlgDirListComboBoxA);
    DETACH(DlgDirListComboBoxW);
    DETACH(DlgDirListW);
    DETACH(DlgDirSelectComboBoxExA);
    DETACH(DlgDirSelectComboBoxExW);
    DETACH(DlgDirSelectExA);
    DETACH(DlgDirSelectExW);
    DETACH(DoDragDrop);
    DETACH(DosDateTimeToFileTime);
    DETACH(DragDetect);
    DETACH(DragObject);
    DETACH(DrawAnimatedRects);
    DETACH(DrawCaption);
    DETACH(DrawEdge);
    DETACH(DrawEscape);
    DETACH(DrawFocusRect);
    DETACH(DrawFrameControl);
    DETACH(DrawIcon);
    DETACH(DrawIconEx);
    DETACH(DrawMenuBar);
    DETACH(DrawStateA);
    DETACH(DrawStateW);
    DETACH(DrawTextA);
    DETACH(DrawTextExA);
    DETACH(DrawTextExW);
    DETACH(DrawTextW);
    DETACH(DuplicateHandle);
    DETACH(Ellipse);
    DETACH(EmptyClipboard);
    DETACH(EnableMenuItem);
    DETACH(EnableScrollBar);
    DETACH(EnableWindow);
    DETACH(EndDeferWindowPos);
    DETACH(EndDialog);
    DETACH(EndDoc);
    DETACH(EndPage);
    DETACH(EndPaint);
    DETACH(EndPath);
    DETACH(EndUpdateResourceA);
    DETACH(EndUpdateResourceW);
    DETACH(EnumCalendarInfoA);
    DETACH(EnumCalendarInfoW);
    DETACH(EnumChildWindows);
    DETACH(EnumClipboardFormats);
    DETACH(EnumDateFormatsA);
    DETACH(EnumDateFormatsW);
    DETACH(EnumDesktopWindows);
    DETACH(EnumDesktopsA);
    DETACH(EnumDesktopsW);
    DETACH(EnumDisplaySettingsA);
    DETACH(EnumDisplaySettingsW);
    DETACH(EnumEnhMetaFile);
    DETACH(EnumFontFamiliesA);
    DETACH(EnumFontFamiliesExA);
    DETACH(EnumFontFamiliesExW);
    DETACH(EnumFontFamiliesW);
    DETACH(EnumFontsA);
    DETACH(EnumFontsW);
    DETACH(EnumICMProfilesA);
    DETACH(EnumICMProfilesW);
    DETACH(EnumMetaFile);
    DETACH(EnumObjects);
    DETACH(EnumPropsA);
    DETACH(EnumPropsExA);
    DETACH(EnumPropsExW);
    DETACH(EnumPropsW);
    DETACH(EnumResourceLanguagesA);
    DETACH(EnumResourceLanguagesW);
    DETACH(EnumResourceNamesA);
    DETACH(EnumResourceNamesW);
    DETACH(EnumResourceTypesA);
    DETACH(EnumResourceTypesW);
    DETACH(EnumSystemCodePagesA);
    DETACH(EnumSystemCodePagesW);
#if(WINVER >= 0x0500)
    DETACH(EnumSystemLocalesA);
    DETACH(EnumSystemLocalesW);
#endif // (WINVER >= 0x0500)
    DETACH(EnumThreadWindows);
    DETACH(EnumTimeFormatsA);
    DETACH(EnumTimeFormatsW);
    DETACH(EnumWindowStationsA);
    DETACH(EnumWindowStationsW);
    DETACH(EnumWindows);
    DETACH(EqualRect);
    DETACH(EqualRgn);
    DETACH(EraseTape);
    DETACH(Escape);
    DETACH(EscapeCommFunction);
    DETACH(ExcludeClipRect);
    DETACH(ExcludeUpdateRgn);
    DETACH(ExitProcess);
    DETACH(ExitThread);
    DETACH(ExitWindowsEx);
    DETACH(ExpandEnvironmentStringsA);
    DETACH(ExpandEnvironmentStringsW);
    DETACH(ExtCreatePen);
    DETACH(ExtCreateRegion);
    DETACH(ExtEscape);
    DETACH(ExtFloodFill);
    DETACH(ExtSelectClipRgn);
    DETACH(ExtTextOutA);
    DETACH(ExtTextOutW);
    DETACH(FatalAppExitA);
    DETACH(FatalAppExitW);
    DETACH(FatalExit);
    DETACH(FileTimeToDosDateTime);
    DETACH(FileTimeToLocalFileTime);
    DETACH(FileTimeToSystemTime);
    DETACH(FillConsoleOutputAttribute);
    DETACH(FillConsoleOutputCharacterA);
    DETACH(FillConsoleOutputCharacterW);
    DETACH(FillPath);
    DETACH(FillRect);
    DETACH(FillRgn);
    DETACH(FindAtomA);
    DETACH(FindAtomW);
    DETACH(FindClose);
    DETACH(FindCloseChangeNotification);
    DETACH(FindFirstChangeNotificationA);
    DETACH(FindFirstChangeNotificationW);
    DETACH(FindFirstFileA);
    DETACH(FindFirstFileExA);
    DETACH(FindFirstFileExW);
    DETACH(FindFirstFileW);
    DETACH(FindNextChangeNotification);
    DETACH(FindNextFileA);
    DETACH(FindNextFileW);
    DETACH(FindResourceA);
    DETACH(FindResourceExA);
    DETACH(FindResourceExW);
    DETACH(FindResourceW);
    DETACH(FindWindowA);
    DETACH(FindWindowExA);
    DETACH(FindWindowExW);
    DETACH(FindWindowW);
    DETACH(FixBrushOrgEx);
    DETACH(FlashWindow);
    DETACH(FlattenPath);
    DETACH(FloodFill);
    DETACH(FlushConsoleInputBuffer);
    DETACH(FlushFileBuffers);
    DETACH(FlushViewOfFile);
    DETACH(FmtIdToPropStgName);
    DETACH(FoldStringA);
    DETACH(FoldStringW);
    DETACH(FormatMessageA);
    DETACH(FormatMessageW);
    DETACH(FrameRect);
    DETACH(FrameRgn);
    DETACH(FreeConsole);
    DETACH(FreeDDElParam);
    DETACH(FreeEnvironmentStringsA);
    DETACH(FreeEnvironmentStringsW);
    DETACH(FreeLibrary);
    DETACH(FreeLibraryAndExitThread);
    DETACH(FreePropVariantArray);
    DETACH(FreeResource);
    DETACH(GdiComment);
    DETACH(GdiFlush);
    DETACH(GdiGetBatchLimit);
    DETACH(GdiSetBatchLimit);
    DETACH(GenerateConsoleCtrlEvent);
    DETACH(GetACP);
    DETACH(GetActiveWindow);
    DETACH(GetArcDirection);
    DETACH(GetAspectRatioFilterEx);
    DETACH(GetAsyncKeyState);
    DETACH(GetAtomNameA);
    DETACH(GetAtomNameW);
    DETACH(GetBinaryTypeA);
    DETACH(GetBinaryTypeW);
    DETACH(GetBitmapBits);
    DETACH(GetBitmapDimensionEx);
    DETACH(GetBkColor);
    DETACH(GetBkMode);
    DETACH(GetBoundsRect);
    DETACH(GetBrushOrgEx);
    DETACH(GetCPInfo);
    DETACH(GetCapture);
    DETACH(GetCaretBlinkTime);
    DETACH(GetCaretPos);
    DETACH(GetCharABCWidthsA);
    DETACH(GetCharABCWidthsFloatA);
    DETACH(GetCharABCWidthsFloatW);
    DETACH(GetCharABCWidthsW);
    DETACH(GetCharWidth32A);
    DETACH(GetCharWidth32W);
    DETACH(GetCharWidthA);
    DETACH(GetCharWidthFloatA);
    DETACH(GetCharWidthFloatW);
    DETACH(GetCharWidthW);
    DETACH(GetCharacterPlacementA);
    DETACH(GetCharacterPlacementW);
    DETACH(GetClassFile);
    DETACH(GetClassInfoA);
    DETACH(GetClassInfoExA);
    DETACH(GetClassInfoExW);
    DETACH(GetClassInfoW);
    DETACH(GetClassLongA);
    DETACH(GetClassLongW);
    DETACH(GetClassNameA);
    DETACH(GetClassNameW);
    DETACH(GetClassWord);
    DETACH(GetClientRect);
    DETACH(GetClipBox);
    DETACH(GetClipCursor);
    DETACH(GetClipRgn);
    DETACH(GetClipboardData);
    DETACH(GetClipboardFormatNameA);
    DETACH(GetClipboardFormatNameW);
    DETACH(GetClipboardOwner);
    DETACH(GetClipboardViewer);
    DETACH(GetColorAdjustment);
    DETACH(GetColorSpace);
    DETACH(GetCommConfig);
    DETACH(GetCommMask);
    DETACH(GetCommModemStatus);
    DETACH(GetCommProperties);
    DETACH(GetCommState);
    DETACH(GetCommTimeouts);
    DETACH(GetCommandLineA);
    DETACH(GetCommandLineW);
    DETACH(GetComputerNameA);
    DETACH(GetComputerNameW);
    DETACH(GetConsoleCP);
    DETACH(GetConsoleCursorInfo);
    DETACH(GetConsoleMode);
    DETACH(GetConsoleOutputCP);
    DETACH(GetConsoleScreenBufferInfo);
    DETACH(GetConsoleTitleA);
    DETACH(GetConsoleTitleW);
    DETACH(GetConvertStg);
    DETACH(GetCurrencyFormatA);
    DETACH(GetCurrencyFormatW);
    DETACH(GetCurrentDirectoryA);
    DETACH(GetCurrentDirectoryW);
    DETACH(GetCurrentObject);
    DETACH(GetCurrentPositionEx);
    DETACH(GetCurrentProcess);
    DETACH(GetCurrentProcessId);
    DETACH(GetCurrentThreadId);
    DETACH(GetCursor);
    DETACH(GetCursorPos);
    DETACH(GetDC);
    DETACH(GetDCEx);
    DETACH(GetDCOrgEx);
    DETACH(GetDIBColorTable);
    DETACH(GetDIBits);
    DETACH(GetDateFormatA);
    DETACH(GetDateFormatW);
    DETACH(GetDefaultCommConfigA);
    DETACH(GetDefaultCommConfigW);
    DETACH(GetDesktopWindow);
    DETACH(GetDeviceCaps);
    DETACH(GetDeviceGammaRamp);
    DETACH(GetDialogBaseUnits);
    DETACH(GetDiskFreeSpaceA);
    DETACH(GetDiskFreeSpaceExA);
    DETACH(GetDiskFreeSpaceExW);
    DETACH(GetDiskFreeSpaceW);
    DETACH(GetDlgCtrlID);
    DETACH(GetDlgItem);
    DETACH(GetDlgItemInt);
    DETACH(GetDlgItemTextA);
    DETACH(GetDlgItemTextW);
    DETACH(GetDoubleClickTime);
    DETACH(GetDriveTypeA);
    DETACH(GetDriveTypeW);
    DETACH(GetEnhMetaFileA);
    DETACH(GetEnhMetaFileBits);
    DETACH(GetEnhMetaFileDescriptionA);
    DETACH(GetEnhMetaFileDescriptionW);
    DETACH(GetEnhMetaFileHeader);
    DETACH(GetEnhMetaFilePaletteEntries);
    DETACH(GetEnhMetaFilePixelFormat);
    DETACH(GetEnhMetaFileW);
    DETACH(GetEnvironmentStrings);
    DETACH(GetEnvironmentStringsW);
    DETACH(GetEnvironmentVariableA);
    DETACH(GetEnvironmentVariableW);
    DETACH(GetExitCodeProcess);
    DETACH(GetExitCodeThread);
    DETACH(GetFileAttributesA);
    DETACH(GetFileAttributesExA);
    DETACH(GetFileAttributesExW);
    DETACH(GetFileAttributesW);
    DETACH(GetFileInformationByHandle);
    DETACH(GetFileSize);
    DETACH(GetFileTime);
    DETACH(GetFileType);
    DETACH(GetFocus);
    DETACH(GetFontData);
    DETACH(GetFontLanguageInfo);
    DETACH(GetForegroundWindow);
    DETACH(GetFullPathNameA);
    DETACH(GetFullPathNameW);
    DETACH(GetGlyphOutlineA);
    DETACH(GetGlyphOutlineW);
    DETACH(GetGraphicsMode);
    DETACH(GetHGlobalFromILockBytes);
    DETACH(GetHGlobalFromStream);
    DETACH(GetHandleInformation);
    DETACH(GetICMProfileA);
    DETACH(GetICMProfileW);
    DETACH(GetIconInfo);
    DETACH(GetInputState);
    DETACH(GetKBCodePage);
    DETACH(GetKerningPairsA);
    DETACH(GetKerningPairsW);
    DETACH(GetKeyNameTextA);
    DETACH(GetKeyNameTextW);
    DETACH(GetKeyState);
    DETACH(GetKeyboardLayout);
    DETACH(GetKeyboardLayoutList);
    DETACH(GetKeyboardLayoutNameA);
    DETACH(GetKeyboardLayoutNameW);
    DETACH(GetKeyboardState);
    DETACH(GetKeyboardType);
    DETACH(GetLastActivePopup);
    DETACH(GetLocalTime);
    DETACH(GetLocaleInfoA);
    DETACH(GetLocaleInfoW);
    DETACH(GetLogColorSpaceA);
    DETACH(GetLogColorSpaceW);
    DETACH(GetLogicalDriveStringsA);
    DETACH(GetLogicalDriveStringsW);
    DETACH(GetLogicalDrives);
    DETACH(GetMailslotInfo);
    DETACH(GetMapMode);
    DETACH(GetMenu);
    DETACH(GetMenuCheckMarkDimensions);
    DETACH(GetMenuContextHelpId);
    DETACH(GetMenuDefaultItem);
    DETACH(GetMenuItemCount);
    DETACH(GetMenuItemID);
    DETACH(GetMenuItemInfoA);
    DETACH(GetMenuItemInfoW);
    DETACH(GetMenuItemRect);
    DETACH(GetMenuState);
    DETACH(GetMenuStringA);
    DETACH(GetMenuStringW);
    DETACH(GetMessageA);
    DETACH(GetMessageExtraInfo);
    DETACH(GetMessagePos);
    DETACH(GetMessageTime);
    DETACH(GetMessageW);
    DETACH(GetMetaFileA);
    DETACH(GetMetaFileBitsEx);
    DETACH(GetMetaFileW);
    DETACH(GetMetaRgn);
    DETACH(GetMiterLimit);
    DETACH(GetModuleFileNameA);
    DETACH(GetModuleFileNameW);
    DETACH(GetModuleHandleA);
    DETACH(GetModuleHandleW);
    DETACH(GetNamedPipeHandleStateA);
    DETACH(GetNamedPipeHandleStateW);
    DETACH(GetNamedPipeInfo);
    DETACH(GetNearestColor);
    DETACH(GetNearestPaletteIndex);
    DETACH(GetNextDlgGroupItem);
    DETACH(GetNextDlgTabItem);
    DETACH(GetNumberFormatA);
    DETACH(GetNumberFormatW);
    DETACH(GetNumberOfConsoleInputEvents);
    DETACH(GetNumberOfConsoleMouseButtons);
    DETACH(GetOEMCP);
    DETACH(GetObjectA);
    DETACH(GetObjectType);
    DETACH(GetObjectW);
    DETACH(GetOpenClipboardWindow);
    DETACH(GetOutlineTextMetricsA);
    DETACH(GetOutlineTextMetricsW);
    DETACH(GetOverlappedResult);
    DETACH(GetPaletteEntries);
    DETACH(GetParent);
    DETACH(GetPath);
    DETACH(GetPixel);
    DETACH(GetPixelFormat);
    DETACH(GetPolyFillMode);
    DETACH(GetPriorityClass);
    DETACH(GetPriorityClipboardFormat);
    DETACH(GetPrivateProfileIntA);
    DETACH(GetPrivateProfileIntW);
    DETACH(GetPrivateProfileSectionA);
    DETACH(GetPrivateProfileSectionNamesA);
    DETACH(GetPrivateProfileSectionNamesW);
    DETACH(GetPrivateProfileSectionW);
    DETACH(GetPrivateProfileStringA);
    DETACH(GetPrivateProfileStringW);
    DETACH(GetPrivateProfileStructA);
    DETACH(GetPrivateProfileStructW);
    DETACH(GetProcAddress);
    DETACH(GetProcessAffinityMask);
    DETACH(GetProcessHeaps);
    DETACH(GetProcessShutdownParameters);
    DETACH(GetProcessTimes);
    DETACH(GetProcessVersion);
    DETACH(GetProcessWindowStation);
    DETACH(GetProcessWorkingSetSize);
    DETACH(GetProfileIntA);
    DETACH(GetProfileIntW);
    DETACH(GetProfileSectionA);
    DETACH(GetProfileSectionW);
    DETACH(GetProfileStringA);
    DETACH(GetProfileStringW);
    DETACH(GetPropA);
    DETACH(GetPropW);
    DETACH(GetQueueStatus);
    DETACH(GetQueuedCompletionStatus);
    DETACH(GetROP2);
    DETACH(GetRasterizerCaps);
    DETACH(GetRegionData);
    DETACH(GetRgnBox);
    DETACH(GetRunningObjectTable);
    DETACH(GetScrollInfo);
    DETACH(GetScrollPos);
    DETACH(GetScrollRange);
    DETACH(GetShortPathNameA);
    DETACH(GetShortPathNameW);
    DETACH(GetStartupInfoA);
    DETACH(GetStartupInfoW);
    DETACH(GetStdHandle);
    DETACH(GetStockObject);
    DETACH(GetStretchBltMode);
    DETACH(GetSubMenu);
    DETACH(GetSysColor);
    DETACH(GetSysColorBrush);
    DETACH(GetSystemDefaultLCID);
    DETACH(GetSystemDefaultLangID);
    DETACH(GetSystemDirectoryA);
    DETACH(GetSystemDirectoryW);
    DETACH(GetSystemInfo);
    DETACH(GetSystemMenu);
    DETACH(GetSystemMetrics);
    DETACH(GetSystemPaletteEntries);
    DETACH(GetSystemPaletteUse);
    DETACH(GetSystemPowerStatus);
    DETACH(GetSystemTime);
    DETACH(GetSystemTimeAdjustment);
    DETACH(GetSystemTimeAsFileTime);
    DETACH(GetTabbedTextExtentA);
    DETACH(GetTabbedTextExtentW);
    DETACH(GetTapeParameters);
    DETACH(GetTapePosition);
    DETACH(GetTapeStatus);
    DETACH(GetTempFileNameA);
    DETACH(GetTempFileNameW);
    DETACH(GetTempPathA);
    DETACH(GetTempPathW);
    DETACH(GetTextAlign);
    DETACH(GetTextCharacterExtra);
    DETACH(GetTextCharset);
    DETACH(GetTextCharsetInfo);
    DETACH(GetTextColor);
    DETACH(GetTextExtentExPointA);
    DETACH(GetTextExtentExPointW);
    DETACH(GetTextExtentPoint32A);
    DETACH(GetTextExtentPoint32W);
    DETACH(GetTextExtentPointA);
    DETACH(GetTextExtentPointW);
    DETACH(GetTextFaceA);
    DETACH(GetTextFaceW);
    DETACH(GetTextMetricsA);
    DETACH(GetTextMetricsW);
    DETACH(GetThreadContext);
    DETACH(GetThreadDesktop);
#if(WINVER >= 0x0500)
    DETACH(GetThreadLocale);
#endif // (WINVER >= 0x0500)
    DETACH(GetThreadPriority);
    DETACH(GetThreadPriorityBoost);
    DETACH(GetThreadSelectorEntry);
    DETACH(GetThreadTimes);
    DETACH(GetTickCount);
    DETACH(GetTimeFormatA);
    DETACH(GetTimeFormatW);
    DETACH(GetTimeZoneInformation);
    DETACH(GetTopWindow);
    DETACH(GetUpdateRect);
    DETACH(GetUpdateRgn);
    DETACH(GetUserDefaultLCID);
    DETACH(GetUserDefaultLangID);
    DETACH(GetUserObjectInformationA);
    DETACH(GetUserObjectInformationW);
    DETACH(GetUserObjectSecurity);
    DETACH(GetVersion);
    DETACH(GetVersionExA);
    DETACH(GetVersionExW);
    DETACH(GetViewportExtEx);
    DETACH(GetViewportOrgEx);
    DETACH(GetVolumeInformationA);
    DETACH(GetVolumeInformationW);
    DETACH(GetWinMetaFileBits);
    DETACH(GetWindow);
    DETACH(GetWindowContextHelpId);
    DETACH(GetWindowDC);
    DETACH(GetWindowExtEx);
    DETACH(GetWindowLongA);
    DETACH(GetWindowLongW);
    DETACH(GetWindowOrgEx);
    DETACH(GetWindowPlacement);
    DETACH(GetWindowRect);
    DETACH(GetWindowRgn);
    DETACH(GetWindowTextA);
    DETACH(GetWindowTextLengthA);
    DETACH(GetWindowTextLengthW);
    DETACH(GetWindowTextW);
    DETACH(GetWindowThreadProcessId);
    DETACH(GetWindowWord);
    DETACH(GetWindowsDirectoryA);
    DETACH(GetWindowsDirectoryW);
    DETACH(GetWorldTransform);
    DETACH(GlobalAddAtomA);
    DETACH(GlobalAddAtomW);
    DETACH(GlobalAlloc);
    DETACH(GlobalCompact);
    DETACH(GlobalDeleteAtom);
    DETACH(GlobalFindAtomA);
    DETACH(GlobalFindAtomW);
    DETACH(GlobalFix);
    DETACH(GlobalFlags);
    DETACH(GlobalFree);
    DETACH(GlobalGetAtomNameA);
    DETACH(GlobalGetAtomNameW);
    DETACH(GlobalHandle);
    DETACH(GlobalLock);
    DETACH(GlobalMemoryStatus);
    DETACH(GlobalReAlloc);
    DETACH(GlobalSize);
    DETACH(GlobalUnWire);
    DETACH(GlobalUnfix);
    DETACH(GlobalUnlock);
    DETACH(GlobalWire);
    DETACH(GrayStringA);
    DETACH(GrayStringW);
    DETACH(HeapLock);
    DETACH(HeapUnlock);
    DETACH(HideCaret);
    DETACH(HiliteMenuItem);
    DETACH(IIDFromString);
    DETACH(ImpersonateDdeClientWindow);
    DETACH(InSendMessage);
    DETACH(InflateRect);
    DETACH(InitAtomTable);
    DETACH(InsertMenuA);
    DETACH(InsertMenuItemA);
    DETACH(InsertMenuItemW);
    DETACH(InsertMenuW);
    DETACH(IntersectClipRect);
    DETACH(IntersectRect);
    DETACH(InvalidateRect);
    DETACH(InvalidateRgn);
    DETACH(InvertRect);
    DETACH(InvertRgn);
    DETACH(IsAccelerator);
    DETACH(IsBadCodePtr);
    DETACH(IsBadHugeReadPtr);
    DETACH(IsBadHugeWritePtr);
    DETACH(IsBadReadPtr);
    DETACH(IsBadStringPtrA);
    DETACH(IsBadStringPtrW);
    DETACH(IsBadWritePtr);
    DETACH(IsCharAlphaA);
    DETACH(IsCharAlphaNumericA);
    DETACH(IsCharAlphaNumericW);
    DETACH(IsCharAlphaW);
    DETACH(IsCharLowerA);
    DETACH(IsCharLowerW);
    DETACH(IsCharUpperA);
    DETACH(IsCharUpperW);
    DETACH(IsChild);
    DETACH(IsClipboardFormatAvailable);
    DETACH(IsDBCSLeadByte);
    DETACH(IsDBCSLeadByteEx);
    DETACH(IsDebuggerPresent);
    DETACH(IsDialogMessageA);
    DETACH(IsDialogMessageW);
    DETACH(IsDlgButtonChecked);
    DETACH(IsIconic);
    DETACH(IsMenu);
#if !defined(DETOURS_ARM)
    DETACH(IsProcessorFeaturePresent);
#endif // !DETOURS_ARM
    DETACH(IsRectEmpty);
    DETACH(IsValidCodePage);
    DETACH(IsValidLocale);
    DETACH(IsWindow);
    DETACH(IsWindowEnabled);
    DETACH(IsWindowUnicode);
    DETACH(IsWindowVisible);
    DETACH(IsZoomed);
    DETACH(KillTimer);
    DETACH(LPtoDP);
    DETACH(LineDDA);
    DETACH(LineTo);
    DETACH(LoadAcceleratorsA);
    DETACH(LoadAcceleratorsW);
    DETACH(LoadBitmapA);
    DETACH(LoadBitmapW);
    DETACH(LoadCursorA);
    DETACH(LoadCursorFromFileA);
    DETACH(LoadCursorFromFileW);
    DETACH(LoadCursorW);
    DETACH(LoadIconA);
    DETACH(LoadIconW);
    DETACH(LoadImageA);
    DETACH(LoadImageW);
    DETACH(LoadKeyboardLayoutA);
    DETACH(LoadKeyboardLayoutW);
    DETACH(LoadLibraryA);
    DETACH(LoadLibraryExA);
    DETACH(LoadLibraryExW);
    DETACH(LoadLibraryW);
    DETACH(LoadMenuA);
    DETACH(LoadMenuIndirectA);
    DETACH(LoadMenuIndirectW);
    DETACH(LoadMenuW);
    DETACH(LoadModule);
    DETACH(LoadResource);
    DETACH(LoadStringA);
    DETACH(LoadStringW);
    DETACH(LocalAlloc);
    DETACH(LocalCompact);
    DETACH(LocalFileTimeToFileTime);
    DETACH(LocalFlags);
    DETACH(LocalFree);
    DETACH(LocalHandle);
    DETACH(LocalLock);
    DETACH(LocalReAlloc);
    DETACH(LocalShrink);
    DETACH(LocalSize);
    DETACH(LocalUnlock);
    DETACH(LockFile);
    DETACH(LockFileEx);
    DETACH(LockResource);
    DETACH(LockWindowUpdate);
    DETACH(LookupIconIdFromDirectory);
    DETACH(LookupIconIdFromDirectoryEx);
    DETACH(MapDialogRect);
    DETACH(MapViewOfFile);
    DETACH(MapViewOfFileEx);
    DETACH(MapVirtualKeyA);
    DETACH(MapVirtualKeyExA);
    DETACH(MapVirtualKeyExW);
    DETACH(MapVirtualKeyW);
    DETACH(MapWindowPoints);
    DETACH(MaskBlt);
    DETACH(MenuItemFromPoint);
    DETACH(MessageBeep);
    DETACH(MessageBoxA);
    DETACH(MessageBoxExA);
    DETACH(MessageBoxExW);
    DETACH(MessageBoxIndirectA);
    DETACH(MessageBoxIndirectW);
    DETACH(MessageBoxW);
    DETACH(MkParseDisplayName);
    DETACH(ModifyMenuA);
    DETACH(ModifyMenuW);
    DETACH(ModifyWorldTransform);
    DETACH(MonikerCommonPrefixWith);
    DETACH(MonikerRelativePathTo);
    DETACH(MoveFileA);
    DETACH(MoveFileExA);
    DETACH(MoveFileExW);
    DETACH(MoveFileW);
    DETACH(MoveToEx);
    DETACH(MoveWindow);
    DETACH(MsgWaitForMultipleObjects);
    DETACH(MsgWaitForMultipleObjectsEx);
    DETACH(MulDiv);
    DETACH(OemKeyScan);
    DETACH(OemToCharA);
    DETACH(OemToCharBuffA);
    DETACH(OemToCharBuffW);
    DETACH(OemToCharW);
    DETACH(OffsetClipRgn);
    DETACH(OffsetRect);
    DETACH(OffsetRgn);
    DETACH(OffsetViewportOrgEx);
    DETACH(OffsetWindowOrgEx);
    DETACH(OleBuildVersion);
    DETACH(OleConvertIStorageToOLESTREAM);
    DETACH(OleConvertIStorageToOLESTREAMEx);
    DETACH(OleConvertOLESTREAMToIStorage);
    DETACH(OleConvertOLESTREAMToIStorageEx);
    DETACH(OleCreate);
    DETACH(OleCreateDefaultHandler);
    DETACH(OleCreateEmbeddingHelper);
    DETACH(OleCreateEx);
    DETACH(OleCreateFromData);
    DETACH(OleCreateFromDataEx);
    DETACH(OleCreateFromFile);
    DETACH(OleCreateFromFileEx);
    DETACH(OleCreateLink);
    DETACH(OleCreateLinkEx);
    DETACH(OleCreateLinkFromData);
    DETACH(OleCreateLinkFromDataEx);
    DETACH(OleCreateLinkToFile);
    DETACH(OleCreateLinkToFileEx);
    DETACH(OleCreateMenuDescriptor);
    DETACH(OleCreateStaticFromData);
    DETACH(OleDestroyMenuDescriptor);
    DETACH(OleDoAutoConvert);
    DETACH(OleDraw);
    DETACH(OleDuplicateData);
    DETACH(OleFlushClipboard);
    DETACH(OleGetAutoConvert);
    DETACH(OleGetClipboard);
    DETACH(OleGetIconOfClass);
    DETACH(OleGetIconOfFile);
    DETACH(OleInitialize);
    DETACH(OleIsCurrentClipboard);
    DETACH(OleIsRunning);
    DETACH(OleLoad);
    DETACH(OleLoadFromStream);
    DETACH(OleLockRunning);
    DETACH(OleMetafilePictFromIconAndLabel);
    DETACH(OleNoteObjectVisible);
    DETACH(OleQueryCreateFromData);
    DETACH(OleQueryLinkFromData);
    DETACH(OleRegEnumFormatEtc);
    DETACH(OleRegEnumVerbs);
    DETACH(OleRegGetMiscStatus);
    DETACH(OleRegGetUserType);
    DETACH(OleRun);
    DETACH(OleSave);
    DETACH(OleSaveToStream);
    DETACH(OleSetAutoConvert);
    DETACH(OleSetClipboard);
    DETACH(OleSetContainedObject);
    DETACH(OleSetMenuDescriptor);
    DETACH(OleTranslateAccelerator);
    DETACH(OleUninitialize);
    DETACH(OpenClipboard);
    DETACH(OpenDesktopA);
    DETACH(OpenDesktopW);
    DETACH(OpenEventA);
    DETACH(OpenEventW);
    DETACH(OpenFile);
    DETACH(OpenFileMappingA);
    DETACH(OpenFileMappingW);
    DETACH(OpenIcon);
    DETACH(OpenInputDesktop);
    DETACH(OpenMutexA);
    DETACH(OpenMutexW);
    DETACH(OpenProcess);
    DETACH(OpenProcessToken);
    DETACH(OpenSemaphoreA);
    DETACH(OpenSemaphoreW);
    DETACH(OpenWaitableTimerA);
    DETACH(OpenWaitableTimerW);
    DETACH(OpenWindowStationA);
    DETACH(OpenWindowStationW);
    DETACH(OutputDebugStringA);
    DETACH(OutputDebugStringW);
    DETACH(PackDDElParam);
    DETACH(PaintDesktop);
    DETACH(PaintRgn);
    DETACH(PatBlt);
    DETACH(PathToRegion);
    DETACH(PeekConsoleInputA);
    DETACH(PeekConsoleInputW);
    DETACH(PeekMessageA);
    DETACH(PeekMessageW);
    DETACH(PeekNamedPipe);
    DETACH(Pie);
    DETACH(PlayEnhMetaFile);
    DETACH(PlayEnhMetaFileRecord);
    DETACH(PlayMetaFile);
    DETACH(PlayMetaFileRecord);
    DETACH(PlgBlt);
    DETACH(PolyBezier);
    DETACH(PolyBezierTo);
    DETACH(PolyDraw);
    DETACH(PolyPolygon);
    DETACH(PolyPolyline);
    DETACH(PolyTextOutA);
    DETACH(PolyTextOutW);
    DETACH(Polygon);
    DETACH(Polyline);
    DETACH(PolylineTo);
    DETACH(PostMessageA);
    DETACH(PostMessageW);
    DETACH(PostQueuedCompletionStatus);
    DETACH(PostQuitMessage);
    DETACH(PostThreadMessageA);
    DETACH(PostThreadMessageW);
    DETACH(PrepareTape);
    DETACH(ProgIDFromCLSID);
    DETACH(PropVariantClear);
    DETACH(PropVariantCopy);
    DETACH(PtInRect);
    DETACH(PtInRegion);
    DETACH(PtVisible);
    DETACH(PulseEvent);
    DETACH(PurgeComm);
    DETACH(QueryDosDeviceA);
    DETACH(QueryDosDeviceW);
    DETACH(QueryPerformanceCounter);
    DETACH(QueryPerformanceFrequency);
    DETACH(QueueUserAPC);
    DETACH(RaiseException);
    DETACH(ReadClassStg);
    DETACH(ReadClassStm);
    DETACH(ReadConsoleA);
    DETACH(ReadConsoleInputA);
    DETACH(ReadConsoleInputW);
    DETACH(ReadConsoleOutputA);
    DETACH(ReadConsoleOutputAttribute);
    DETACH(ReadConsoleOutputCharacterA);
    DETACH(ReadConsoleOutputCharacterW);
    DETACH(ReadConsoleOutputW);
    DETACH(ReadConsoleW);
    DETACH(ReadDirectoryChangesW);
    DETACH(ReadFile);
    DETACH(ReadFileEx);
    DETACH(ReadFmtUserTypeStg);
    DETACH(ReadProcessMemory);
    DETACH(RealizePalette);
    DETACH(RectInRegion);
    DETACH(RectVisible);
    DETACH(Rectangle);
    DETACH(RedrawWindow);
    DETACH(RegisterClassA);
    DETACH(RegisterClassExA);
    DETACH(RegisterClassExW);
    DETACH(RegisterClassW);
    DETACH(RegisterClipboardFormatA);
    DETACH(RegisterClipboardFormatW);
    DETACH(RegisterDragDrop);
    DETACH(RegisterHotKey);
    DETACH(RegisterWindowMessageA);
    DETACH(RegisterWindowMessageW);
    DETACH(ReleaseCapture);
    DETACH(ReleaseDC);
    DETACH(ReleaseMutex);
    DETACH(ReleaseSemaphore);
    DETACH(ReleaseStgMedium);
    DETACH(RemoveDirectoryA);
    DETACH(RemoveDirectoryW);
    DETACH(RemoveFontResourceA);
    DETACH(RemoveFontResourceW);
    DETACH(RemoveMenu);
    DETACH(RemovePropA);
    DETACH(RemovePropW);
    DETACH(ReplyMessage);
    DETACH(ResetDCA);
    DETACH(ResetDCW);
    DETACH(ResetEvent);
    DETACH(ResizePalette);
    DETACH(RestoreDC);
    DETACH(ResumeThread);
    DETACH(ReuseDDElParam);
    DETACH(RevokeDragDrop);
    DETACH(RoundRect);
    DETACH(SaveDC);
    DETACH(ScaleViewportExtEx);
    DETACH(ScaleWindowExtEx);
    DETACH(ScreenToClient);
    DETACH(ScrollConsoleScreenBufferA);
    DETACH(ScrollConsoleScreenBufferW);
    DETACH(ScrollDC);
    DETACH(ScrollWindow);
    DETACH(ScrollWindowEx);
    DETACH(SearchPathA);
    DETACH(SearchPathW);
    DETACH(SelectClipPath);
    DETACH(SelectClipRgn);
    DETACH(SelectObject);
    DETACH(SelectPalette);
    DETACH(SendDlgItemMessageA);
    DETACH(SendDlgItemMessageW);
    DETACH(SendMessageA);
    DETACH(SendMessageCallbackA);
    DETACH(SendMessageCallbackW);
    DETACH(SendMessageTimeoutA);
    DETACH(SendMessageTimeoutW);
    DETACH(SendMessageW);
    DETACH(SendNotifyMessageA);
    DETACH(SendNotifyMessageW);
    DETACH(SetAbortProc);
    DETACH(SetActiveWindow);
    DETACH(SetArcDirection);
    DETACH(SetBitmapBits);
    DETACH(SetBitmapDimensionEx);
    DETACH(SetBkColor);
    DETACH(SetBkMode);
    DETACH(SetBoundsRect);
    DETACH(SetBrushOrgEx);
    DETACH(SetCapture);
    DETACH(SetCaretBlinkTime);
    DETACH(SetCaretPos);
    DETACH(SetClassLongA);
    DETACH(SetClassLongW);
    DETACH(SetClassWord);
    DETACH(SetClipboardData);
    DETACH(SetClipboardViewer);
    DETACH(SetColorAdjustment);
    DETACH(SetColorSpace);
    DETACH(SetCommBreak);
    DETACH(SetCommConfig);
    DETACH(SetCommMask);
    DETACH(SetCommState);
    DETACH(SetCommTimeouts);
    DETACH(SetComputerNameA);
    DETACH(SetComputerNameW);
    DETACH(SetConsoleActiveScreenBuffer);
    DETACH(SetConsoleCP);
    DETACH(SetConsoleCtrlHandler);
    DETACH(SetConsoleCursorInfo);
    DETACH(SetConsoleCursorPosition);
    DETACH(SetConsoleMode);
    DETACH(SetConsoleOutputCP);
    DETACH(SetConsoleScreenBufferSize);
    DETACH(SetConsoleTextAttribute);
    DETACH(SetConsoleTitleA);
    DETACH(SetConsoleTitleW);
    DETACH(SetConsoleWindowInfo);
    DETACH(SetConvertStg);
    DETACH(SetCurrentDirectoryA);
    DETACH(SetCurrentDirectoryW);
    DETACH(SetCursor);
    DETACH(SetCursorPos);
    DETACH(SetDIBColorTable);
    DETACH(SetDIBits);
    DETACH(SetDIBitsToDevice);
    DETACH(SetDefaultCommConfigA);
    DETACH(SetDefaultCommConfigW);
    DETACH(SetDeviceGammaRamp);
    DETACH(SetDlgItemInt);
    DETACH(SetDlgItemTextA);
    DETACH(SetDlgItemTextW);
    DETACH(SetDoubleClickTime);
    DETACH(SetEndOfFile);
    DETACH(SetEnhMetaFileBits);
    DETACH(SetEnvironmentVariableA);
    DETACH(SetEnvironmentVariableW);
    DETACH(SetErrorMode);
    DETACH(SetEvent);
    DETACH(SetFileApisToANSI);
    DETACH(SetFileApisToOEM);
    DETACH(SetFileAttributesA);
    DETACH(SetFileAttributesW);
    DETACH(SetFilePointer);
    DETACH(SetFileTime);
    DETACH(SetFocus);
    DETACH(SetForegroundWindow);
    DETACH(SetGraphicsMode);
    DETACH(SetHandleCount);
    DETACH(SetHandleInformation);
    DETACH(SetICMMode);
    DETACH(SetICMProfileA);
    DETACH(SetICMProfileW);
    DETACH(SetKeyboardState);
    DETACH(SetLocalTime);
    DETACH(SetLocaleInfoA);
    DETACH(SetLocaleInfoW);
    DETACH(SetMailslotInfo);
    DETACH(SetMapMode);
    DETACH(SetMapperFlags);
    DETACH(SetMenu);
    DETACH(SetMenuContextHelpId);
    DETACH(SetMenuDefaultItem);
    DETACH(SetMenuItemBitmaps);
    DETACH(SetMenuItemInfoA);
    DETACH(SetMenuItemInfoW);
    DETACH(SetMessageExtraInfo);
    DETACH(SetMessageQueue);
    DETACH(SetMetaFileBitsEx);
    DETACH(SetMetaRgn);
    DETACH(SetMiterLimit);
    DETACH(SetNamedPipeHandleState);
    DETACH(SetPaletteEntries);
    DETACH(SetParent);
    DETACH(SetPixel);
    DETACH(SetPixelFormat);
    DETACH(SetPixelV);
    DETACH(SetPolyFillMode);
    DETACH(SetPriorityClass);
    DETACH(SetProcessAffinityMask);
    DETACH(SetProcessShutdownParameters);
    DETACH(SetProcessWindowStation);
    DETACH(SetProcessWorkingSetSize);
    DETACH(SetPropA);
    DETACH(SetPropW);
    DETACH(SetROP2);
    DETACH(SetRect);
    DETACH(SetRectEmpty);
    DETACH(SetRectRgn);
    DETACH(SetScrollInfo);
    DETACH(SetScrollPos);
    DETACH(SetScrollRange);
    DETACH(SetStdHandle);
    DETACH(SetStretchBltMode);
    DETACH(SetSysColors);
    DETACH(SetSystemCursor);
    DETACH(SetSystemPaletteUse);
    DETACH(SetSystemPowerState);
    DETACH(SetSystemTime);
    DETACH(SetSystemTimeAdjustment);
    DETACH(SetTapeParameters);
    DETACH(SetTapePosition);
    DETACH(SetTextAlign);
    DETACH(SetTextCharacterExtra);
    DETACH(SetTextColor);
    DETACH(SetTextJustification);
    DETACH(SetThreadAffinityMask);
    DETACH(SetThreadContext);
    DETACH(SetThreadDesktop);
    DETACH(SetThreadIdealProcessor);
#if(WINVER >= 0x0500)
    DETACH(SetThreadLocale);
#endif // (WINVER >= 0x0500)
    DETACH(SetThreadPriority);
    DETACH(SetThreadPriorityBoost);
    DETACH(SetTimeZoneInformation);
    DETACH(SetTimer);
    DETACH(SetUnhandledExceptionFilter);
    DETACH(SetUserObjectInformationA);
    DETACH(SetUserObjectInformationW);
    DETACH(SetUserObjectSecurity);
    DETACH(SetViewportExtEx);
    DETACH(SetViewportOrgEx);
    DETACH(SetVolumeLabelA);
    DETACH(SetVolumeLabelW);
    DETACH(SetWaitableTimer);
    DETACH(SetWinMetaFileBits);
    DETACH(SetWindowContextHelpId);
    DETACH(SetWindowExtEx);
    DETACH(SetWindowLongA);
    DETACH(SetWindowLongW);
    DETACH(SetWindowOrgEx);
    DETACH(SetWindowPlacement);
    DETACH(SetWindowPos);
    DETACH(SetWindowRgn);
    DETACH(SetWindowTextA);
    DETACH(SetWindowTextW);
    DETACH(SetWindowWord);
    DETACH(SetWindowsHookA);
    DETACH(SetWindowsHookExA);
    DETACH(SetWindowsHookExW);
    DETACH(SetWindowsHookW);
    DETACH(SetWorldTransform);
    DETACH(SetupComm);
    DETACH(ShowCaret);
    DETACH(ShowCursor);
    DETACH(ShowOwnedPopups);
    DETACH(ShowScrollBar);
    DETACH(ShowWindow);
    DETACH(ShowWindowAsync);
    DETACH(SignalObjectAndWait);
    DETACH(SizeofResource);
    DETACH(SleepEx);
    DETACH(StartDocA);
    DETACH(StartDocW);
    DETACH(StartPage);
    DETACH(StgCreateDocfile);
    DETACH(StgCreateDocfileOnILockBytes);
    DETACH(StgCreatePropSetStg);
    DETACH(StgCreatePropStg);
    DETACH(StgCreateStorageEx);
    DETACH(StgGetIFillLockBytesOnFile);
    DETACH(StgGetIFillLockBytesOnILockBytes);
    DETACH(StgIsStorageFile);
    DETACH(StgIsStorageILockBytes);
    DETACH(StgOpenAsyncDocfileOnIFillLockBytes);
    DETACH(StgOpenPropStg);
    DETACH(StgOpenStorage);
    DETACH(StgOpenStorageEx);
    DETACH(StgOpenStorageOnILockBytes);
    DETACH(StgSetTimes);
    DETACH(StretchBlt);
    DETACH(StretchDIBits);
    DETACH(StringFromCLSID);
    DETACH(StringFromGUID2);
    DETACH(StringFromIID);
    DETACH(StrokeAndFillPath);
    DETACH(StrokePath);
    DETACH(SubtractRect);
    DETACH(SuspendThread);
    DETACH(SwapBuffers);
    DETACH(SwapMouseButton);
    DETACH(SwitchDesktop);
    DETACH(SwitchToFiber);
    DETACH(SwitchToThread);
    DETACH(SystemParametersInfoA);
    DETACH(SystemParametersInfoW);
    DETACH(SystemTimeToFileTime);
    DETACH(SystemTimeToTzSpecificLocalTime);
    DETACH(TabbedTextOutA);
    DETACH(TabbedTextOutW);
    DETACH(TerminateProcess);
    DETACH(TerminateThread);
    DETACH(TextOutA);
    DETACH(TextOutW);
    DETACH(TileWindows);
    DETACH(ToAscii);
    DETACH(ToAsciiEx);
    DETACH(ToUnicode);
    DETACH(ToUnicodeEx);
    DETACH(TrackMouseEvent);
    DETACH(TrackPopupMenu);
    DETACH(TrackPopupMenuEx);
    DETACH(TransactNamedPipe);
    DETACH(TranslateAcceleratorA);
    DETACH(TranslateAcceleratorW);
    DETACH(TranslateCharsetInfo);
    DETACH(TranslateMDISysAccel);
    DETACH(TranslateMessage);
    DETACH(TransmitCommChar);
#if DETOUR_TryEnterCriticalSection_EVEN_IF_IT_EXERCISES_A_BUG_IN_RtlLookupFunctionTable
    DETACH(TryEnterCriticalSection);
#endif
    DETACH(UnhookWindowsHook);
    DETACH(UnhookWindowsHookEx);
    DETACH(UnionRect);
    DETACH(UnloadKeyboardLayout);
    DETACH(UnlockFile);
    DETACH(UnlockFileEx);
    DETACH(UnmapViewOfFile);
    DETACH(UnpackDDElParam);
    DETACH(UnrealizeObject);
    DETACH(UnregisterClassA);
    DETACH(UnregisterClassW);
    DETACH(UnregisterHotKey);
    DETACH(UpdateColors);
    DETACH(UpdateResourceA);
    DETACH(UpdateResourceW);
    DETACH(UpdateWindow);
    DETACH(ValidateRect);
    DETACH(ValidateRgn);
    DETACH(VerLanguageNameA);
    DETACH(VerLanguageNameW);
    DETACH(VirtualAllocEx);
    DETACH(VirtualFreeEx);
    DETACH(VirtualProtectEx);
    DETACH(VirtualQueryEx);
    DETACH(VkKeyScanA);
    DETACH(VkKeyScanExA);
    DETACH(VkKeyScanExW);
    DETACH(VkKeyScanW);
    DETACH(WSAAccept);
    DETACH(WSAAddressToStringA);
    DETACH(WSAAddressToStringW);
    DETACH(WSAAsyncGetHostByAddr);
    DETACH(WSAAsyncGetHostByName);
    DETACH(WSAAsyncGetProtoByName);
    DETACH(WSAAsyncGetProtoByNumber);
    DETACH(WSAAsyncGetServByName);
    DETACH(WSAAsyncGetServByPort);
    DETACH(WSAAsyncSelect);
    DETACH(WSACancelAsyncRequest);
    DETACH(WSACancelBlockingCall);
    DETACH(WSACleanup);
    DETACH(WSACloseEvent);
    DETACH(WSAConnect);
    DETACH(WSACreateEvent);
    DETACH(WSADuplicateSocketA);
    DETACH(WSADuplicateSocketW);
    DETACH(WSAEnumNameSpaceProvidersA);
    DETACH(WSAEnumNameSpaceProvidersW);
    DETACH(WSAEnumNetworkEvents);
    DETACH(WSAEnumProtocolsA);
    DETACH(WSAEnumProtocolsW);
    DETACH(WSAEventSelect);
    DETACH(WSAGetOverlappedResult);
    DETACH(WSAGetQOSByName);
    DETACH(WSAGetServiceClassInfoA);
    DETACH(WSAGetServiceClassInfoW);
    DETACH(WSAGetServiceClassNameByClassIdA);
    DETACH(WSAGetServiceClassNameByClassIdW);
    DETACH(WSAHtonl);
    DETACH(WSAHtons);
    DETACH(WSAInstallServiceClassA);
    DETACH(WSAInstallServiceClassW);
    DETACH(WSAIoctl);
    DETACH(WSAIsBlocking);
    DETACH(WSAJoinLeaf);
    DETACH(WSALookupServiceBeginA);
    DETACH(WSALookupServiceBeginW);
    DETACH(WSALookupServiceEnd);
    DETACH(WSALookupServiceNextA);
    DETACH(WSALookupServiceNextW);
    DETACH(WSANtohl);
    DETACH(WSANtohs);
    DETACH(WSAProviderConfigChange);
    DETACH(WSARecv);
    DETACH(WSARecvDisconnect);
    DETACH(WSARecvFrom);
    DETACH(WSARemoveServiceClass);
    DETACH(WSAResetEvent);
    DETACH(WSASend);
    DETACH(WSASendDisconnect);
    DETACH(WSASendTo);
    DETACH(WSASetBlockingHook);
    DETACH(WSASetEvent);
    DETACH(WSASetServiceA);
    DETACH(WSASetServiceW);
    DETACH(WSASocketA);
    DETACH(WSASocketW);
    DETACH(WSAStartup);
    DETACH(WSAStringToAddressA);
    DETACH(WSAStringToAddressW);
    DETACH(WSAUnhookBlockingHook);
    DETACH(WSAWaitForMultipleEvents);
    DETACH(WaitCommEvent);
#if !defined(DETOURS_ARM)
    DETACH(WaitForDebugEvent);
#endif // !DETOURS_ARM
    DETACH(WaitForInputIdle);
    DETACH(WaitForMultipleObjects);
    DETACH(WaitForMultipleObjectsEx);
    DETACH(WaitForSingleObject);
    DETACH(WaitForSingleObjectEx);
    DETACH(WaitMessage);
    DETACH(WaitNamedPipeA);
    DETACH(WaitNamedPipeW);
    DETACH(WidenPath);
    DETACH(WinExec);
    DETACH(WinHelpA);
    DETACH(WinHelpW);
    DETACH(WindowFromDC);
    DETACH(WindowFromPoint);
    DETACH(WriteClassStg);
    DETACH(WriteClassStm);
    DETACH(WriteConsoleA);
    DETACH(WriteConsoleInputA);
    DETACH(WriteConsoleInputW);
    DETACH(WriteConsoleOutputA);
    DETACH(WriteConsoleOutputAttribute);
    DETACH(WriteConsoleOutputCharacterA);
    DETACH(WriteConsoleOutputCharacterW);
    DETACH(WriteConsoleOutputW);
    DETACH(WriteConsoleW);
    DETACH(WriteFile);
    DETACH(WriteFileEx);
    DETACH(WriteFmtUserTypeStg);
    DETACH(WritePrivateProfileSectionA);
    DETACH(WritePrivateProfileSectionW);
    DETACH(WritePrivateProfileStringA);
    DETACH(WritePrivateProfileStringW);
    DETACH(WritePrivateProfileStructA);
    DETACH(WritePrivateProfileStructW);
    DETACH(WriteProcessMemory);
    DETACH(WriteProfileSectionA);
    DETACH(WriteProfileSectionW);
    DETACH(WriteProfileStringA);
    DETACH(WriteProfileStringW);
    DETACH(WriteTapemark);
    DETACH(__WSAFDIsSet);
    DETACH(_hread);
    DETACH(_hwrite);
    DETACH(_lclose);
    DETACH(_lcreat);
    DETACH(_llseek);
    DETACH(_lopen);
    DETACH(_lread);
    DETACH(_lwrite);
    DETACH(accept);
    DETACH(bind);
    DETACH(closesocket);
    DETACH(connect);
    DETACH(gethostbyaddr);
    DETACH(gethostbyname);
    DETACH(gethostname);
    DETACH(getpeername);
    DETACH(getprotobyname);
    DETACH(getprotobynumber);
    DETACH(getservbyname);
    DETACH(getservbyport);
    DETACH(getsockname);
    DETACH(getsockopt);
    DETACH(htonl);
    DETACH(htons);
    DETACH(inet_addr);
    DETACH(inet_ntoa);
    DETACH(ioctlsocket);
    DETACH(keybd_event);
    DETACH(listen);
    DETACH(mouse_event);
    DETACH(ntohl);
    DETACH(ntohs);
    DETACH(recv);
    DETACH(recvfrom);
    DETACH(select);
    DETACH(send);
    DETACH(sendto);
    DETACH(setsockopt);
    DETACH(shutdown);
    DETACH(socket);

    if (DetourTransactionCommit() != 0) {
        PVOID *ppbFailedPointer = NULL;
        LONG error = DetourTransactionCommitEx(&ppbFailedPointer);

        printf("traceapi.dll: Detach transaction failed to commit. Error %ld (%p/%p)",
               error, ppbFailedPointer, *ppbFailedPointer);
        return error;
    }
    return 0;
}
//
///////////////////////////////////////////////////////////////// End of File.

```

`samples/traceapi/testapi.cpp`:

```cpp
//////////////////////////////////////////////////////////////////////////////
//
//  Detours Test Program (testapi.cpp of testapi.exe)
//
//  Microsoft Research Detours Package
//
//  Copyright (c) Microsoft Corporation.  All rights reserved.
//
#include "trcapi.cpp"

#if (_MSC_VER < 1299)
typedef ULONG * PULONG_PTR;
typedef ULONG ULONG_PTR;
typedef LONG * PLONG_PTR;
typedef LONG LONG_PTR;
#endif

VOID SyelogOpen(PCSTR pszIdentifier, BYTE nFacility)
{
    (void)pszIdentifier;
    (void)nFacility;
}

VOID SyelogExV(BOOL fTerminate, BYTE nSeverity, PCSTR pszMsgf, va_list args)
{
    (void)fTerminate;

    CHAR szBuffer[1024];
    PCHAR psz = szBuffer;
    BOOL fLf = FALSE;

    StringCchPrintfA(psz, szBuffer + sizeof(szBuffer) - psz, "--.%02x: ", nSeverity);
    while (*psz) {
        psz++;
    }

    StringCchVPrintfA(psz, szBuffer + sizeof(szBuffer) - psz, pszMsgf, args);
    for (psz = szBuffer; *psz; psz++) {
        if (*psz == '\n') {
            if (fLf) {
                *psz = '\0';
                break;
            }
            fLf = TRUE;
        }
    }
    if (!fLf) {
        *psz++ = '\n';
        *psz = '\0';
    }
    printf("%s", szBuffer);
    Real_OutputDebugStringA(szBuffer);
}

VOID SyelogV(BYTE nSeverity, PCSTR pszMsgf, va_list args)
{
    SyelogExV(FALSE, nSeverity, pszMsgf, args);
}

VOID Syelog(BYTE nSeverity, PCSTR pszMsgf, ...)
{
    va_list args;
    va_start(args, pszMsgf);
    SyelogExV(FALSE, nSeverity, pszMsgf, args);
    va_end(args);
}

VOID SyelogEx(BOOL fTerminate, BYTE nSeverity, PCSTR pszMsgf, ...)
{
    va_list args;
    va_start(args, pszMsgf);
    SyelogExV(fTerminate, nSeverity, pszMsgf, args);
    va_end(args);
}

VOID SyelogClose(BOOL fTerminate)
{
    (void)fTerminate;
}

DWORD main(int argc, char **argv)
{
    (void)argc;
    (void)argv;

    printf("testapi: Starting\n");
    ProcessAttach(NULL);
    Sleep(100);
    ProcessDetach(NULL);

    return 0;
}
//
//////////////////////////////////////////////////////////////////////////////

```

`samples/traceapi/trcapi.cpp`:

```cpp
//////////////////////////////////////////////////////////////////////////////
//
//  Detours Test Program (trcapi.cpp of trcapi.dll)
//
//  Microsoft Research Detours Package
//
//  Copyright (c) Microsoft Corporation.  All rights reserved.
//
#undef WIN32_LEAN_AND_MEAN
#define _WIN32_WINNT        0x400
#define WIN32
#define NT
#define _WINSOCK_DEPRECATED_NO_WARNINGS

#define DBG_TRACE   0

#if _MSC_VER >= 1300
#include <winsock2.h>
#endif
#include <windows.h>
#include <stdio.h>
#pragma warning(push)
#if _MSC_VER > 1400
#pragma warning(disable:6102 6103) // /analyze warnings
#endif
#include <strsafe.h>
#pragma warning(pop)
#include "detours.h"
#include "syelog.h"

#if (_MSC_VER < 1299)
#define LONG_PTR    LONG
#define ULONG_PTR   ULONG
#define PLONG_PTR   PLONG
#define PULONG_PTR  PULONG
#define INT_PTR     INT
#define UINT_PTR    UINT
#define PINT_PTR    PINT
#define PUINT_PTR   PUINT
#define DWORD_PTR   DWORD
#define PDWORD_PTR  PDWORD
#endif

#pragma warning(disable:4996)   // We don't care about deprecated APIs.

//////////////////////////////////////////////////////////////////////////////
#pragma warning(disable:4127)   // Many of our asserts are constants.

#define ASSERT_ALWAYS(x)   \
    do {                                                        \
    if (!(x)) {                                                 \
            AssertMessage(#x, __FILE__, __LINE__);              \
            DebugBreak();                                       \
    }                                                           \
    } while (0)

#ifndef NDEBUG
#define ASSERT(x)           ASSERT_ALWAYS(x)
#else
#define ASSERT(x)
#endif

#define UNUSED(c)    (c) = (c)

//////////////////////////////////////////////////////////////////////////////
static HMODULE s_hInst = NULL;
static WCHAR s_wzDllPath[MAX_PATH];
static CHAR s_szDllPath[MAX_PATH];

BOOL ProcessEnumerate();
BOOL InstanceEnumerate(HINSTANCE hInst);

VOID _PrintEnter(const CHAR *psz, ...);
VOID _PrintExit(const CHAR *psz, ...);
VOID _Print(const CHAR *psz, ...);
VOID _VPrint(PCSTR msg, va_list args, PCHAR pszBuf, LONG cbBuf);

VOID AssertMessage(CONST PCHAR pszMsg, CONST PCHAR pszFile, ULONG nLine);

//////////////////////////////////////////////////////////////////////////////
//
// Trampolines
//
extern "C" {
    //  Trampolines for SYELOG library.
    //
    extern HANDLE (WINAPI *Real_CreateFileW)(LPCWSTR a0, DWORD a1, DWORD a2,
                                             LPSECURITY_ATTRIBUTES a3, DWORD a4, DWORD a5,
                                             HANDLE a6);
    extern BOOL (WINAPI *Real_WriteFile)(HANDLE hFile,
                                         LPCVOID lpBuffer,
                                         DWORD nNumberOfBytesToWrite,
                                         LPDWORD lpNumberOfBytesWritten,
                                         LPOVERLAPPED lpOverlapped);
    extern BOOL (WINAPI *Real_FlushFileBuffers)(HANDLE hFile);
    extern BOOL (WINAPI *Real_CloseHandle)(HANDLE hObject);
    extern BOOL (WINAPI *Real_WaitNamedPipeW)(LPCWSTR lpNamedPipeName, DWORD nTimeOut);
    extern BOOL (WINAPI *Real_SetNamedPipeHandleState)(HANDLE hNamedPipe,
                                                       LPDWORD lpMode,
                                                       LPDWORD lpMaxCollectionCount,
                                                       LPDWORD lpCollectDataTimeout);
    extern DWORD (WINAPI *Real_GetCurrentProcessId)(VOID);
    extern VOID (WINAPI *Real_GetSystemTimeAsFileTime)(LPFILETIME lpSystemTimeAsFileTime);

    VOID ( WINAPI * Real_InitializeCriticalSection)(LPCRITICAL_SECTION lpSection)
        = InitializeCriticalSection;
    VOID ( WINAPI * Real_EnterCriticalSection)(LPCRITICAL_SECTION lpSection)
        = EnterCriticalSection;
    VOID ( WINAPI * Real_LeaveCriticalSection)(LPCRITICAL_SECTION lpSection)
        = LeaveCriticalSection;
}

#include "_win32.cpp"

////////////////////////////////////////////////////////////// Logging System.
//
static BOOL s_bLog = FALSE;
static LONG s_nTlsIndent = -1;
static LONG s_nTlsThread = -1;
static LONG s_nThreadCnt = 0;

VOID _PrintEnter(const CHAR *psz, ...)
{
    DWORD dwErr = GetLastError();

    LONG nIndent = 0;
    LONG nThread = 0;
    if (s_nTlsIndent >= 0) {
        nIndent = (LONG)(LONG_PTR)TlsGetValue(s_nTlsIndent);
        TlsSetValue(s_nTlsIndent, (PVOID)(LONG_PTR)(nIndent + 1));
    }
    if (s_nTlsThread >= 0) {
        nThread = (LONG)(LONG_PTR)TlsGetValue(s_nTlsThread);
    }

    if (s_bLog && psz) {
        CHAR szBuf[1024];
        PCHAR pszBuf = szBuf;
        PCHAR pszEnd = szBuf + ARRAYSIZE(szBuf) - 1;
        LONG nLen = (nIndent > 0) ? (nIndent < 35 ? nIndent * 2 : 70) : 0;
        *pszBuf++ = (CHAR)('0' + ((nThread / 100) % 10));
        *pszBuf++ = (CHAR)('0' + ((nThread / 10) % 10));
        *pszBuf++ = (CHAR)('0' + ((nThread / 1) % 10));
        *pszBuf++ = ' ';
        while (nLen-- > 0) {
            *pszBuf++ = ' ';
        }
        *pszBuf++ = '+';
        *pszBuf = '\0';

        va_list  args;
        va_start(args, psz);

        while ((*pszBuf++ = *psz++) != 0 && pszBuf < pszEnd) {
            // Copy characters.
        }
        *pszEnd = '\0';
        SyelogV(SYELOG_SEVERITY_INFORMATION, szBuf, args);

        va_end(args);
    }
    SetLastError(dwErr);
}

VOID _PrintExit(const CHAR *psz, ...)
{
    DWORD dwErr = GetLastError();

    LONG nIndent = 0;
    LONG nThread = 0;
    if (s_nTlsIndent >= 0) {
        nIndent = (LONG)(LONG_PTR)TlsGetValue(s_nTlsIndent) - 1;
        ASSERT_ALWAYS(nIndent >= 0);
        TlsSetValue(s_nTlsIndent, (PVOID)(LONG_PTR)nIndent);
    }
    if (s_nTlsThread >= 0) {
        nThread = (LONG)(LONG_PTR)TlsGetValue(s_nTlsThread);
    }

    if (s_bLog && psz) {
        CHAR szBuf[1024];
        PCHAR pszEnd = szBuf + ARRAYSIZE(szBuf) - 1;
        PCHAR pszBuf = szBuf;
        LONG nLen = (nIndent > 0) ? (nIndent < 35 ? nIndent * 2 : 70) : 0;
        *pszBuf++ = (CHAR)('0' + ((nThread / 100) % 10));
        *pszBuf++ = (CHAR)('0' + ((nThread / 10) % 10));
        *pszBuf++ = (CHAR)('0' + ((nThread / 1) % 10));
        *pszBuf++ = ' ';
        while (nLen-- > 0) {
            *pszBuf++ = ' ';
        }
        *pszBuf++ = '-';
        *pszBuf = '\0';

        va_list  args;
        va_start(args, psz);

        while ((*pszBuf++ = *psz++) != 0 && pszBuf < pszEnd) {
            // Copy characters.
        }
        *pszEnd = '\0';
        SyelogV(SYELOG_SEVERITY_INFORMATION, szBuf, args);

        va_end(args);
    }
    SetLastError(dwErr);
}

VOID _Print(const CHAR *psz, ...)
{
    DWORD dwErr = GetLastError();

    LONG nIndent = 0;
    LONG nThread = 0;
    if (s_nTlsIndent >= 0) {
        nIndent = (LONG)(LONG_PTR)TlsGetValue(s_nTlsIndent);
    }
    if (s_nTlsThread >= 0) {
        nThread = (LONG)(LONG_PTR)TlsGetValue(s_nTlsThread);
    }

    if (s_bLog && psz) {
        CHAR szBuf[1024];
        PCHAR pszEnd = szBuf + ARRAYSIZE(szBuf) - 1;
        PCHAR pszBuf = szBuf;
        LONG nLen = (nIndent > 0) ? (nIndent < 35 ? nIndent * 2 : 70) : 0;
        *pszBuf++ = (CHAR)('0' + ((nThread / 100) % 10));
        *pszBuf++ = (CHAR)('0' + ((nThread / 10) % 10));
        *pszBuf++ = (CHAR)('0' + ((nThread / 1) % 10));
        *pszBuf++ = ' ';
        while (nLen-- > 0) {
            *pszBuf++ = ' ';
        }
        *pszBuf = '\0';

        va_list  args;
        va_start(args, psz);

        while ((*pszBuf++ = *psz++) != 0 && pszBuf < pszEnd) {
            // Copy characters.
        }
        *pszEnd = '\0';
        SyelogV(SYELOG_SEVERITY_INFORMATION, szBuf, args);

        va_end(args);
    }
    SetLastError(dwErr);
}

VOID AssertMessage(CONST PCHAR pszMsg, CONST PCHAR pszFile, ULONG nLine)
{
    Syelog(SYELOG_SEVERITY_FATAL,
           "ASSERT(%s) failed in %s, line %d.\n", pszMsg, pszFile, nLine);
}

//////////////////////////////////////////////////////////////////////////////
//
PIMAGE_NT_HEADERS NtHeadersForInstance(HINSTANCE hInst)
{
    PIMAGE_DOS_HEADER pDosHeader = (PIMAGE_DOS_HEADER)hInst;
    __try {
        if (pDosHeader->e_magic != IMAGE_DOS_SIGNATURE) {
            SetLastError(ERROR_BAD_EXE_FORMAT);
            return NULL;
        }

        PIMAGE_NT_HEADERS pNtHeader = (PIMAGE_NT_HEADERS)((PBYTE)pDosHeader +
                                                          pDosHeader->e_lfanew);
        if (pNtHeader->Signature != IMAGE_NT_SIGNATURE) {
            SetLastError(ERROR_INVALID_EXE_SIGNATURE);
            return NULL;
        }
        if (pNtHeader->FileHeader.SizeOfOptionalHeader == 0) {
            SetLastError(ERROR_EXE_MARKED_INVALID);
            return NULL;
        }
        return pNtHeader;
    } __except(EXCEPTION_EXECUTE_HANDLER) {
    }
    SetLastError(ERROR_EXE_MARKED_INVALID);

    return NULL;
}

BOOL InstanceEnumerate(HINSTANCE hInst)
{
    WCHAR wzDllName[MAX_PATH];

    PIMAGE_NT_HEADERS pinh = NtHeadersForInstance(hInst);
    if (pinh && Real_GetModuleFileNameW(hInst, wzDllName, ARRAYSIZE(wzDllName))) {
        Syelog(SYELOG_SEVERITY_INFORMATION, "### %p: %ls\n", hInst, wzDllName);
        return TRUE;
    }
    return FALSE;
}

BOOL ProcessEnumerate()
{
    Syelog(SYELOG_SEVERITY_INFORMATION,
           "######################################################### Binaries\n");

    PBYTE pbNext;
    for (PBYTE pbRegion = (PBYTE)0x10000;; pbRegion = pbNext) {
        MEMORY_BASIC_INFORMATION mbi;
        ZeroMemory(&mbi, sizeof(mbi));

        if (VirtualQuery((PVOID)pbRegion, &mbi, sizeof(mbi)) <= 0) {
            break;
        }
        pbNext = (PBYTE)mbi.BaseAddress + mbi.RegionSize;

        // Skip free regions, reserver regions, and guard pages.
        //
        if (mbi.State == MEM_FREE || mbi.State == MEM_RESERVE) {
            continue;
        }
        if (mbi.Protect & PAGE_GUARD || mbi.Protect & PAGE_NOCACHE) {
            continue;
        }
        if (mbi.Protect == PAGE_NOACCESS) {
            continue;
        }

        // Skip over regions from the same allocation...
        {
            MEMORY_BASIC_INFORMATION mbiStep;

            while (VirtualQuery((PVOID)pbNext, &mbiStep, sizeof(mbiStep)) > 0) {
                if ((PBYTE)mbiStep.AllocationBase != pbRegion) {
                    break;
                }
                pbNext = (PBYTE)mbiStep.BaseAddress + mbiStep.RegionSize;
                mbi.Protect |= mbiStep.Protect;
            }
        }

        WCHAR wzDllName[MAX_PATH];
        PIMAGE_NT_HEADERS pinh = NtHeadersForInstance((HINSTANCE)pbRegion);

        if (pinh &&
            Real_GetModuleFileNameW((HINSTANCE)pbRegion,wzDllName,ARRAYSIZE(wzDllName))) {

            Syelog(SYELOG_SEVERITY_INFORMATION,
                   "### %p..%p: %ls\n", pbRegion, pbNext, wzDllName);
        }
        else {
            Syelog(SYELOG_SEVERITY_INFORMATION,
                   "### %p..%p: State=%04x, Protect=%08x\n",
                   pbRegion, pbNext, mbi.State, mbi.Protect);
        }
    }
    Syelog(SYELOG_SEVERITY_INFORMATION, "###\n");

    LPVOID lpvEnv = Real_GetEnvironmentStrings();
    Syelog(SYELOG_SEVERITY_INFORMATION, "### Env= %08x [%08x %08x]\n",
           lpvEnv, ((PVOID*)lpvEnv)[0], ((PVOID*)lpvEnv)[1]);

    return TRUE;
}

//////////////////////////////////////////////////////////////////////////////
//
// DLL module information
//
BOOL ThreadAttach(HMODULE hDll)
{
    (void)hDll;

    if (s_nTlsIndent >= 0) {
        TlsSetValue(s_nTlsIndent, (PVOID)0);
    }
    if (s_nTlsThread >= 0) {
        LONG nThread = InterlockedIncrement(&s_nThreadCnt);
        TlsSetValue(s_nTlsThread, (PVOID)(LONG_PTR)nThread);
    }
    return TRUE;
}

BOOL ThreadDetach(HMODULE hDll)
{
    (void)hDll;

    if (s_nTlsIndent >= 0) {
        TlsSetValue(s_nTlsIndent, (PVOID)0);
    }
    if (s_nTlsThread >= 0) {
        TlsSetValue(s_nTlsThread, (PVOID)0);
    }
    return TRUE;
}

BOOL ProcessAttach(HMODULE hDll)
{
    s_bLog = FALSE;
    s_nTlsIndent = TlsAlloc();
    s_nTlsThread = TlsAlloc();
    ThreadAttach(hDll);

    WCHAR wzExeName[MAX_PATH];

    s_hInst = hDll;
    Real_GetModuleFileNameW(hDll, s_wzDllPath, ARRAYSIZE(s_wzDllPath));
    Real_GetModuleFileNameW(NULL, wzExeName, ARRAYSIZE(wzExeName));
    StringCchPrintfA(s_szDllPath, ARRAYSIZE(s_szDllPath), "%ls", s_wzDllPath);

    SyelogOpen("trcapi" DETOURS_STRINGIFY(DETOURS_BITS), SYELOG_FACILITY_APPLICATION);
    ProcessEnumerate();

    LONG error = AttachDetours();
    if (error != NO_ERROR) {
        Syelog(SYELOG_SEVERITY_FATAL, "### Error attaching detours: %d\n", error);
    }

    s_bLog = TRUE;
    return TRUE;
}

BOOL ProcessDetach(HMODULE hDll)
{
    ThreadDetach(hDll);
    s_bLog = FALSE;

    LONG error = DetachDetours();
    if (error != NO_ERROR) {
        Syelog(SYELOG_SEVERITY_FATAL, "### Error detaching detours: %d\n", error);
    }

    Syelog(SYELOG_SEVERITY_NOTICE, "### Closing.\n");
    SyelogClose(FALSE);

    if (s_nTlsIndent >= 0) {
        TlsFree(s_nTlsIndent);
    }
    if (s_nTlsThread >= 0) {
        TlsFree(s_nTlsThread);
    }
    return TRUE;
}

BOOL APIENTRY DllMain(HINSTANCE hModule, DWORD dwReason, PVOID lpReserved)
{
    (void)hModule;
    (void)lpReserved;
    BOOL ret;

    if (DetourIsHelperProcess()) {
        return TRUE;
    }

    switch (dwReason) {
      case DLL_PROCESS_ATTACH:
        DetourRestoreAfterWith();
        OutputDebugStringA("trcapi" DETOURS_STRINGIFY(DETOURS_BITS) ".dll:"
                           " DllMain DLL_PROCESS_ATTACH\n");
        return ProcessAttach(hModule);
      case DLL_PROCESS_DETACH:
        ret = ProcessDetach(hModule);
        OutputDebugStringA("trcapi" DETOURS_STRINGIFY(DETOURS_BITS) ".dll:"
                           " DllMain DLL_PROCESS_DETACH\n");
        return ret;
      case DLL_THREAD_ATTACH:
        OutputDebugStringA("trcapi" DETOURS_STRINGIFY(DETOURS_BITS) ".dll:"
                           " DllMain DLL_THREAD_ATTACH\n");
        return ThreadAttach(hModule);
      case DLL_THREAD_DETACH:
        OutputDebugStringA("trcapi" DETOURS_STRINGIFY(DETOURS_BITS) ".dll:"
                           " DllMain DLL_THREAD_DETACH\n");
        return ThreadDetach(hModule);
    }
    return TRUE;
}
//
///////////////////////////////////////////////////////////////// End of File.

```

`samples/traceapi/trcapi.rc`:

```rc
//////////////////////////////////////////////////////////////////////////////
//
//  Version information for trcapi.rc.
//
//  Microsoft Research Detours Package
//
//  Copyright (c) Microsoft Corporation.  All rights reserved.
//

#include "detver.h"

#define VER_INTERNALNAME_STR        "trcapi" DETOURS_STRINGIFY(DETOURS_BITS)
#define VER_ORIGINALFILENAME_STR    "trcapi" DETOURS_STRINGIFY(DETOURS_BITS) ".dll"
#define VER_FILEDESCRIPTION_STR     "Detours Win32 API Tracing Module"
#define VER_COMPANYNAME_STR         "Microsoft Corporation"

#include "common.ver"

```

`samples/tracebld/Makefile`:

```
##############################################################################
##
##  Utility to registry and file access APIs.
##
##  Microsoft Research Detours Package
##
##  Copyright (c) Microsoft Corporation.  All rights reserved.
##

!include ..\common.mak

LIBS=$(LIBS) kernel32.lib

##############################################################################

all: dirs \
    $(BIND)\trcbld$(DETOURS_BITS).dll \
    $(BIND)\tracebld.exe \
    \
!IF $(DETOURS_SOURCE_BROWSING)==1
    $(OBJD)\trcbld$(DETOURS_BITS).bsc    \
    $(OBJD)\tracebld.bsc    \
!ENDIF
    option

##############################################################################

clean:
    -del *~ test.txt log.*.xml 2>nul
    -del $(BIND)\tracebld.* $(BIND)\trcbld*.* 2>nul
    -rmdir /q /s $(OBJD) 2>nul

realclean: clean
    -rmdir /q /s $(OBJDS) 2>nul

dirs:
    @if not exist $(BIND) mkdir $(BIND) && echo.   Created $(BIND)
    @if not exist $(OBJD) mkdir $(OBJD) && echo.   Created $(OBJD)

##############################################################################

$(OBJD)\trcbld.obj : trcbld.cpp
$(OBJD)\trcbld.res : trcbld.rc
$(BIND)\trcbld$(DETOURS_BITS).dll : $(OBJD)\trcbld.obj $(OBJD)\trcbld.res $(DEPS)
    cl /LD $(CFLAGS) /Fe$@ /Fd$(@R).pdb \
        $(OBJD)\trcbld.obj $(OBJD)\trcbld.res \
        /link $(LINKFLAGS) /release /subsystem:console \
        /export:DetourFinishHelperProcess,@1,NONAME \
        $(LIBS)

$(OBJD)\trcbld$(DETOURS_BITS).bsc : $(OBJD)\trcbld.obj
    bscmake /v /n /o $@ $(OBJD)\trcbld.sbr

$(OBJD)\tracebld.obj : tracebld.cpp

$(BIND)\tracebld.exe : $(OBJD)\tracebld.obj $(DEPS)
    cl $(CFLAGS) /Fe$@ /Fd$(@R).pdb $(OBJD)\tracebld.obj \
        /link $(LINKFLAGS) $(LIBS) \
        /subsystem:console /fixed:no

$(OBJD)\tracebld.bsc : $(OBJD)\tracebld.obj
    bscmake /v /n /o $@ $(OBJD)\tracebld.sbr

############################################### Install non-bit-size binaries.

!IF "$(DETOURS_OPTION_PROCESSOR)" != ""

$(OPTD)\trcbld$(DETOURS_OPTION_BITS).dll:
$(OPTD)\trcbld$(DETOURS_OPTION_BITS).pdb:

$(BIND)\trcbld$(DETOURS_OPTION_BITS).dll : $(OPTD)\trcbld$(DETOURS_OPTION_BITS).dll
    @if exist $? copy /y $? $(BIND) >nul && echo $@ copied from $(DETOURS_OPTION_PROCESSOR).
$(BIND)\trcbld$(DETOURS_OPTION_BITS).pdb : $(OPTD)\trcbld$(DETOURS_OPTION_BITS).pdb
    @if exist $? copy /y $? $(BIND) >nul && echo $@ copied from $(DETOURS_OPTION_PROCESSOR).

option: \
    $(BIND)\trcbld$(DETOURS_OPTION_BITS).dll \
    $(BIND)\trcbld$(DETOURS_OPTION_BITS).pdb \

!ELSE

option:

!ENDIF

##############################################################################

test: all
    -del log.*.xml 2>nul
    $(BIND)\tracebld.exe /o:log %COMSPEC% /c dir
    @echo -------- Log from log.00000000 ---------------------
    type log.00000000.xml

test0: all
    -del log.*.xml 2>nul
    $(BIND)\tracebld.exe /o:log %COMSPEC% /c xx.cmd
    @echo -------- Log from log.00000000 ---------------------
    type log.00000000.xml
    @echo -------- Log from log.00000001 ---------------------
    type log.00000001.xml

test1: all
    set FooBAR=1
    -del log.*.xml 2>nul
    @echo -------- Logging output to log ------------
    -rmdir /q /s obj 2>nul
    $(BIND)\tracebld.exe /o:log nmake.exe test2
    @echo -------- Log from log.00000000 ---------------------
    type log.00000000.xml | findstr /c:"t:Line"
    type log.00000002.xml | findstr /c:"t:Line"

test1d: all
    -del log.*.xml 2>nul
    @echo -------- Logging output to log ------------
    -rmdir /q /s obj 2>nul
    windbg -g -G -o $(BIND)\tracebld.exe /o:log nmake.exe test2
    @echo -------- Log from log.00000000 ---------------------
    type log.00000000.xml | findstr /c:"t:Line"
    type log.00000002.xml | findstr /c:"t:Line"


test2: all
    -del foo.txt
    echo foo1 >> foo.txt
    echo foo2 >> foo.txt
    echo foo3 >> foo.txt
    -del log.foo.xml
    -mkdir obj
    cmd.exe /c "set Foo=BAR&&cmd.exe /c echo. FOO=%Foo%"
    cl /LD $(CFLAGS) /Tp<< @<<obj\response.txt > log.foo.xml
#include <windows.h>
<<
/Feobj\tbtest.exe /Fd$(@R).pdb $(DET_SRC)
/link $(LINKFLAGS) /subsystem:console
/export:DetourFinishHelperProcess,@1 
<<NOKEEP
    type $(BIND)\trcbld.cpp | findstr CreateFile
    echo int main() { return 0; } > obj\test.cpp
    cl /c /Foobj\test.obj obj\test.cpp
    -del tbtest.* 2>nul

test3: all
    -del log.*.xml 2>nul
    @echo -------- Logging output to log ------------
    -rmdir /q /s foo
    $(BIND)\tracebld.exe /o:log xcopy.exe $(BIND)\trcbld.cpp foo\ /y
    @echo -------- Log from log.00000000 ---------------------
    type log.00000000.xml

test4: all
    -del log.*.xml 2>nul
    echo int main() { return 0; } > obj\test.cpp
    $(BIND)\tracebld.exe /o:log cl /c /Foobj\test.obj obj\test.cpp
    @echo -------- Log from log.00000000 ---------------------
    type log.00000000.xml

################################################################# End of File.

```

`samples/tracebld/tracebld.cpp`:

```cpp
//////////////////////////////////////////////////////////////////////////////
//
//  Detours Test Program (tracebld.cpp of tracebld.exe)
//
//  Microsoft Research Detours Package
//
//  Copyright (c) Microsoft Corporation.  All rights reserved.
//
#include <windows.h>
#include <stdio.h>
#include <stdlib.h>
#include <stddef.h>
#pragma warning(push)
#if _MSC_VER > 1400
#pragma warning(disable:6102 6103) // /analyze warnings
#endif
#include <strsafe.h>
#pragma warning(pop)
#include <detours.h>
#include "tracebld.h"

#if (_MSC_VER < 1299)
typedef ULONG * PULONG_PTR;
typedef ULONG ULONG_PTR;
typedef LONG * PLONG_PTR;
typedef LONG LONG_PTR;
#endif

//////////////////////////////////////////////////////////////////////////////
#pragma warning(disable:4127)   // Many of our asserts are constants.

#define ASSERT_ALWAYS(x)   \
    do {                                                        \
    if (!(x)) {                                                 \
            AssertMessage(#x, __FILE__, __LINE__);              \
            DebugBreak();                                       \
    }                                                           \
    } while (0)

#ifndef NDEBUG
#define ASSERT(x)           ASSERT_ALWAYS(x)
#else
#define ASSERT(x)
#endif

#define UNUSED(c)       (c) = (c)

//////////////////////////////////////////////////////////////////////////////

enum {
    CLIENT_AWAITING_PIPE_ACCEPT = 0x21,
    CLIENT_AWAITING_PIPE_DATA   = 0x22,
};

typedef struct _CLIENT : OVERLAPPED
{
    HANDLE          hPipe;
    LONG            nClient;
    HANDLE          hFile;
    BOOL            fAwaitingAccept;
    PVOID           Zero;
    TBLOG_MESSAGE   Message;

    BOOL LogMessage(PTBLOG_MESSAGE pMessage, DWORD nBytes);
    BOOL LogMessageV(PCHAR pszMsg, ...);
} CLIENT, *PCLIENT;

//////////////////////////////////////////////////////////////////////////////
//
CHAR        s_szLogFile[MAX_PATH];
CHAR        s_szPipe[MAX_PATH];
LONG        s_nActiveClients = 0;
LONG        s_nTotalClients = 0;
LONGLONG    s_llStartTime;
BOOL        s_fVerbose = FALSE;
TBLOG_PAYLOAD s_Payload;

//////////////////////////////////////////////////////////////////////////////
//
VOID MyErrExit(PCSTR pszMsg)
{
    DWORD error = GetLastError();

    fprintf(stderr, "TRACEBLD: Error %ld in %s.\n", error, pszMsg);
    fflush(stderr);
    exit(1);
}

//////////////////////////////////////////////////////////////////////////////
//
BOOL CLIENT::LogMessageV(PCHAR pszMsg, ...)
{
    DWORD cbWritten = 0;
    CHAR szBuf[1024];
    PCHAR pcchEnd = szBuf + ARRAYSIZE(szBuf) - 2;
    PCHAR pcchCur = szBuf;
    HRESULT hr;

    va_list args;
    va_start(args, pszMsg);
    hr = StringCchVPrintfExA(pcchCur, pcchEnd - pcchCur,
                             &pcchCur, NULL, STRSAFE_NULL_ON_FAILURE,
                             pszMsg, args);
    va_end(args);
    if (FAILED(hr)) {
        goto cleanup;
    }

    hr = StringCchPrintfExA(pcchCur, szBuf + (ARRAYSIZE(szBuf)) - pcchCur,
                            &pcchCur, NULL, STRSAFE_NULL_ON_FAILURE,
                            "\n");

  cleanup:
    WriteFile(hFile, szBuf, (DWORD)(pcchCur - szBuf), &cbWritten, NULL);
    return TRUE;
}

BOOL CLIENT::LogMessage(PTBLOG_MESSAGE pMessage, DWORD nBytes)
{
    // Sanity check the size of the message.
    //
    if (nBytes > pMessage->nBytes) {
        nBytes = pMessage->nBytes;
    }
    if (nBytes >= sizeof(*pMessage)) {
        nBytes = sizeof(*pMessage) - 1;
    }

    // Don't log message if there isn't and message text.
    //
    DWORD cbWrite = nBytes - offsetof(TBLOG_MESSAGE, szMessage);
    if (cbWrite <= 0 ) {
        return TRUE;
    }

    if (s_fVerbose) {
        printf("[%s]", pMessage->szMessage);
    }

    DWORD cbWritten = 0;
    WriteFile(hFile, pMessage->szMessage, cbWrite, &cbWritten, NULL);
    return TRUE;
}

BOOL CloseConnection(PCLIENT pClient)
{
    InterlockedDecrement(&s_nActiveClients);
    if (pClient != NULL) {
        if (pClient->hPipe != INVALID_HANDLE_VALUE) {
            //FlushFileBuffers(pClient->hPipe);
            if (!DisconnectNamedPipe(pClient->hPipe)) {
                DWORD error = GetLastError();
                pClient->LogMessageV("<!-- Error %d in DisconnectNamedPipe. -->\n", error);
            }
            CloseHandle(pClient->hPipe);
            pClient->hPipe = INVALID_HANDLE_VALUE;
        }
        if (pClient->hFile != INVALID_HANDLE_VALUE) {
            CloseHandle(pClient->hFile);
            pClient->hFile = INVALID_HANDLE_VALUE;
        }
        GlobalFree(pClient);
        pClient = NULL;
    }
    return TRUE;
}

// Creates a pipe instance and initiate an accept request.
//
PCLIENT CreatePipeConnection(HANDLE hCompletionPort, LONG nClient)
{
    HANDLE hPipe = CreateNamedPipeA(s_szPipe,                   // pipe name
                                    PIPE_ACCESS_INBOUND |       // read-only access
                                    FILE_FLAG_OVERLAPPED,       // overlapped mode
                                    PIPE_TYPE_MESSAGE |         // message-type pipe
                                    PIPE_READMODE_MESSAGE |     // message read mode
                                    PIPE_WAIT,                  // blocking mode
                                    PIPE_UNLIMITED_INSTANCES,   // unlimited instances
                                    0,                          // output buffer size
                                    0,                          // input buffer size
                                    20000,                      // client time-out
                                    NULL);                      // no security attributes
    if (hPipe == INVALID_HANDLE_VALUE) {
        MyErrExit("CreateNamedPipe");
    }

    // Allocate the client data structure.
    //
    PCLIENT pClient = (PCLIENT) GlobalAlloc(GPTR, sizeof(CLIENT));
    if (pClient == NULL) {
        MyErrExit("GlobalAlloc pClient");
    }

    CHAR szLogFile[MAX_PATH];
    StringCchPrintfA(szLogFile, ARRAYSIZE(szLogFile), "%s.%08d.xml", s_szLogFile, nClient);

    ZeroMemory(pClient, sizeof(*pClient));
    pClient->hPipe = hPipe;
    pClient->nClient = nClient;
    pClient->fAwaitingAccept = TRUE;
    pClient->hFile = CreateFileA(szLogFile,
                                 GENERIC_WRITE,
                                 FILE_SHARE_READ,
                                 NULL,
                                 CREATE_ALWAYS,
                                 FILE_ATTRIBUTE_NORMAL |
                                 FILE_FLAG_SEQUENTIAL_SCAN,
                                 NULL);
    if (pClient->hFile == INVALID_HANDLE_VALUE) {
        fprintf(stderr, "TRACEBLD: Error opening output file: %s: %ld\n\n",
                szLogFile, GetLastError());
        fflush(stderr);
        MyErrExit("CreateFile");
    }

    // Associate file with our complietion port.
    //
    if (!CreateIoCompletionPort(pClient->hPipe, hCompletionPort, (ULONG_PTR)pClient, 0)) {
        MyErrExit("CreateIoComplietionPort pClient");
    }

    if (!ConnectNamedPipe(hPipe, pClient)) {
        DWORD error = GetLastError();

        if (error == ERROR_IO_PENDING) {
            return NULL;
        }
        if (error == ERROR_PIPE_CONNECTED) {
#if 0
            pClient->LogMessageV("<!-- ConnectNamedPipe client already connected. -->");
#endif
            pClient->fAwaitingAccept = FALSE;
        }
        else if (error != ERROR_IO_PENDING &&
                 error != ERROR_PIPE_LISTENING) {

            MyErrExit("ConnectNamedPipe");
        }
    }
    else {
        fprintf(stderr, "*** ConnectNamedPipe accepted immediately.\n");
#if 0
        pClient->LogMessageV("<!-- ConnectNamedPipe accepted immediately. -->");
#endif
        pClient->fAwaitingAccept = FALSE;
    }
    return pClient;
}

BOOL DoRead(PCLIENT pClient)
{
    SetLastError(NO_ERROR);
    DWORD nBytes = 0;
    BOOL b = ReadFile(pClient->hPipe, &pClient->Message, sizeof(pClient->Message),
                      &nBytes, pClient);

    DWORD error = GetLastError();

    if (b && error == NO_ERROR) {
        return TRUE;
    }
    if (error == ERROR_BROKEN_PIPE) {
        pClient->LogMessageV("<!-- **** ReadFile 002 *** ERROR_BROKEN_PIPE [%d] -->\n", nBytes);
        CloseConnection(pClient);
        return TRUE;
    }
    else if (error == ERROR_INVALID_HANDLE) {
        // ?
        pClient->LogMessageV("<!-- **** ReadFile 002 *** ERROR_INVALID_HANDLE -->\n");
        // I have no idea why this happens.  Our remedy is to drop the connection.
        return TRUE;
    }
    else if (error != ERROR_IO_PENDING) {
        if (b) {
            pClient->LogMessageV("<!-- **** ReadFile 002 succeeded: %d -->\n", error);
        }
        else {
            pClient->LogMessageV("<!-- **** ReadFile 002 failed: %d -->\n", error);
        }
        CloseConnection(pClient);
    }
    return TRUE;
}

DWORD WINAPI WorkerThread(LPVOID pvVoid)
{
    PCLIENT pClient;
    BOOL b;
    LPOVERLAPPED lpo;
    DWORD nBytes;
    HANDLE hCompletionPort = (HANDLE)pvVoid;

    for (BOOL fKeepLooping = TRUE; fKeepLooping;) {
        pClient = NULL;
        lpo = NULL;
        nBytes = 0;
        b = GetQueuedCompletionStatus(hCompletionPort,
                                      &nBytes, (PULONG_PTR)&pClient, &lpo, INFINITE);

        if (!b) {
            if (pClient) {
                if (GetLastError() == ERROR_BROKEN_PIPE) {
                    pClient->LogMessageV("<!-- Client closed pipe. -->");
                }
                else {
                    pClient->LogMessageV("<!-- *** GetQueuedCompletionStatus failed %d -->",
                                         GetLastError());
                }
                CloseConnection(pClient);
            }
            continue;
        }

        if (pClient->fAwaitingAccept) {
            BOOL fAgain = TRUE;
            while (fAgain) {
                LONG nClient = InterlockedIncrement(&s_nTotalClients);
                InterlockedIncrement(&s_nActiveClients);
                pClient->fAwaitingAccept = FALSE;

                PCLIENT pNew = CreatePipeConnection(hCompletionPort, nClient);

                fAgain = FALSE;
                if (pNew != NULL) {
                    fAgain = !pNew->fAwaitingAccept;
                    DoRead(pNew);
                }
            }
        }
        else {
            if (nBytes <= offsetof(TBLOG_MESSAGE, szMessage)) {
                pClient->LogMessageV("</t:Process>\n");
                CloseConnection(pClient);
                continue;
            }
            pClient->LogMessage(&pClient->Message, nBytes);
        }

        DoRead(pClient);
    }
    return 0;
}

BOOL CreateWorkers(HANDLE hCompletionPort)
{
    DWORD dwThread;
    HANDLE hThread;
    DWORD i;
    SYSTEM_INFO SystemInfo;

    GetSystemInfo(&SystemInfo);

    for (i = 0; i < 1; i++) {
        hThread = CreateThread(NULL, 0, WorkerThread, hCompletionPort, 0, &dwThread);
        if (!hThread) {
            MyErrExit("CreateThread WorkerThread");
            // Unreachable: return FALSE;
        }
        CloseHandle(hThread);
    }
    return TRUE;
}

DWORD CopyEnvironment(PWCHAR pwzzOut, PCWSTR pwzzIn)
{
    PCWSTR pwzzBeg = pwzzOut;
    while (*pwzzIn) {
        while (*pwzzIn) {
            *pwzzOut++ = *pwzzIn++;
        }
        *pwzzOut++ = *pwzzIn++;   // Copy zero.
    }
    *pwzzOut++ = '\0';    // Add last zero.

    return (DWORD)(pwzzOut - pwzzBeg);
}

//////////////////////////////////////////////////////////////////////////////
//
DWORD main(int argc, char **argv)
{
    HANDLE hCompletionPort;
    BOOL fNeedHelp = FALSE;
    WCHAR wzzDrop[1024] = L"build\0nmake\0";

    GetSystemTimeAsFileTime((FILETIME *)&s_llStartTime);
    StringCchPrintfA(s_szPipe, ARRAYSIZE(s_szPipe), "%s.%d", TBLOG_PIPE_NAME, GetCurrentProcessId());

    int arg = 1;
    for (; arg < argc && (argv[arg][0] == '-' || argv[arg][0] == '/'); arg++) {
        CHAR *argn = argv[arg] + 1;
        CHAR *argp = argn;
        while (*argp && *argp != ':' && *argp != '=') {
            argp++;
        }
        if (*argp == ':' || *argp == '=') {
            *argp++ = '\0';
        }

        switch (argn[0]) {

          case 'd':                                     // Drop Processes
          case 'D':
            if (*argp) {
                PWCHAR pwz = wzzDrop;
                while (*argp) {
                    if (*argp == ';') {
                        *pwz++ = '\0';
                    }
                    else {
                        *pwz++ = *argp++;
                    }
                }
                *pwz++ = '\0';
                *pwz = '\0';
            }
          case 'o':                                 // Output file.
          case 'O':
            StringCchCopyA(s_szLogFile, ARRAYSIZE(s_szLogFile), argp);
            break;

          case 'v':                                     // Verbose
          case 'V':
            s_fVerbose = TRUE;
            break;

          case '?':                                 // Help.
            fNeedHelp = TRUE;
            break;

          default:
            fNeedHelp = TRUE;
            printf("TRACEBLD: Bad argument: %s:%s\n", argn, argp);
            break;
        }
    }

    if (arg >= argc) {
        fNeedHelp = TRUE;
    }

    if (fNeedHelp) {
        printf("Usage:\n"
               "    tracebld [options] command {command arguments}\n"
               "Options:\n"
               "    /o:file    Log all events to the output files.\n"
               "    /?         Display this help message.\n"
               "Summary:\n"
               "    Runs the build commands and figures out which files have dependencies..\n"
               "\n");
        exit(9001);
    }

    // Create the completion port.
    hCompletionPort = CreateIoCompletionPort(INVALID_HANDLE_VALUE, NULL, NULL, 0);
    if (hCompletionPort == NULL) {
        MyErrExit("CreateIoCompletionPort");
    }

    // Create completion port worker threads.
    //
    CreateWorkers(hCompletionPort);
    CreatePipeConnection(hCompletionPort, 0);

    printf("TRACEBLD: Ready for clients.  Press Ctrl-C to stop.\n");

    /////////////////////////////////////////////////////////// Validate DLLs.
    //
    CHAR szTmpPath[MAX_PATH];
    CHAR szExePath[MAX_PATH];
    CHAR szDllPath[MAX_PATH];
    PCHAR pszFilePart = NULL;

    if (!GetModuleFileNameA(NULL, szTmpPath, ARRAYSIZE(szTmpPath))) {
        printf("TRACEBLD: Couldn't retreive exe name.\n");
        return 9002;
    }
    if (!GetFullPathNameA(szTmpPath, ARRAYSIZE(szExePath), szExePath, &pszFilePart) ||
        pszFilePart == NULL) {
        printf("TRACEBLD: Error: %s is not a valid path name..\n", szTmpPath);
        return 9002;
    }

    StringCchCopyA(pszFilePart, szExePath + ARRAYSIZE(szExePath) - pszFilePart,
             "trcbld" DETOURS_STRINGIFY(DETOURS_BITS) ".dll");
    StringCchCopyA(szDllPath, ARRAYSIZE(szDllPath), szExePath);

    //////////////////////////////////////////////////////////////////////////
    STARTUPINFOA si;
    PROCESS_INFORMATION pi;
    CHAR szCommand[2048];
    CHAR szExe[MAX_PATH];
    CHAR szFullExe[MAX_PATH] = "\0";
    PCHAR pszFileExe = NULL;

    ZeroMemory(&si, sizeof(si));
    ZeroMemory(&pi, sizeof(pi));
    si.cb = sizeof(si);

    szCommand[0] = L'\0';

    StringCchCopyA(szExe, sizeof(szExe), argv[arg]);
    for (; arg < argc; arg++) {
        if (strchr(argv[arg], ' ') != NULL || strchr(argv[arg], '\t') != NULL) {
            StringCchCatA(szCommand, sizeof(szCommand), "\"");
            StringCchCatA(szCommand, sizeof(szCommand), argv[arg]);
            StringCchCatA(szCommand, sizeof(szCommand), "\"");
        }
        else {
            StringCchCatA(szCommand, sizeof(szCommand), argv[arg]);
        }

        if (arg + 1 < argc) {
            StringCchCatA(szCommand, sizeof(szCommand), " ");
        }
    }
    printf("TRACEBLD: Starting: `%s'\n", szCommand);
    printf("TRACEBLD:   with `%s'\n", szDllPath);
    fflush(stdout);

    DWORD dwFlags = CREATE_DEFAULT_ERROR_MODE | CREATE_SUSPENDED;

    SetLastError(0);
    SearchPathA(NULL, szExe, ".exe", ARRAYSIZE(szFullExe), szFullExe, &pszFileExe);


    if (!DetourCreateProcessWithDllExA(szFullExe[0] ? szFullExe : NULL, szCommand,
                                       NULL, NULL, TRUE, dwFlags, NULL, NULL,
                                       &si, &pi, szDllPath, NULL)) {
        printf("TRACEBLD: DetourCreateProcessWithDllEx failed: %ld\n", GetLastError());
        ExitProcess(9007);
    }

    ZeroMemory(&s_Payload, sizeof(s_Payload));
    s_Payload.nParentProcessId = GetCurrentProcessId();
    s_Payload.nTraceProcessId = GetCurrentProcessId();
    s_Payload.nGeneology = 1;
    s_Payload.rGeneology[0] = 0;
    StringCchCopyW(s_Payload.wzStdin, ARRAYSIZE(s_Payload.wzStdin), L"\\\\.\\CONIN$");
    StringCchCopyW(s_Payload.wzStdout, ARRAYSIZE(s_Payload.wzStdout), L"\\\\.\\CONOUT$");
    StringCchCopyW(s_Payload.wzStderr, ARRAYSIZE(s_Payload.wzStderr), L"\\\\.\\CONOUT$");
    StringCchCopyW(s_Payload.wzParents, ARRAYSIZE(s_Payload.wzParents), L"");
    CopyEnvironment(s_Payload.wzzDrop, wzzDrop);
    LPWCH pwStrings = GetEnvironmentStringsW();
    CopyEnvironment(s_Payload.wzzEnvironment, pwStrings);
    FreeEnvironmentStringsW(pwStrings);

    if (!DetourCopyPayloadToProcess(pi.hProcess, s_guidTrace,
                                    &s_Payload, sizeof(s_Payload))) {
        printf("TRACEBLD: DetourCopyPayloadToProcess failed: %ld\n", GetLastError());
        ExitProcess(9008);
    }

    ResumeThread(pi.hThread);

    WaitForSingleObject(pi.hProcess, INFINITE);

    DWORD dwResult = 0;
    if (!GetExitCodeProcess(pi.hProcess, &dwResult)) {
        printf("TRACEBLD: GetExitCodeProcess failed: %ld\n", GetLastError());
        return 9008;
    }

    printf("TRACEBLD: %ld processes.\n", s_nTotalClients);

    return dwResult;
}
//
//////////////////////////////////////////////////////////////////////////////

```

`samples/tracebld/tracebld.h`:

```h
//////////////////////////////////////////////////////////////////////////////
//
//  Detours Test Program (tracebld.h of tracebld.exe)
//
//  Microsoft Research Detours Package
//
//  Copyright (c) Microsoft Corporation.  All rights reserved.
//
#pragma once
#ifndef _TRACEBLD_H_
#define _TRACEBLD_H_
#include <stdarg.h>

//////////////////////////////////////////////////////////////////////////////
//
//
#define TBLOG_PIPE_NAMEA       "\\\\.\\pipe\\tracebuild"
#define TBLOG_PIPE_NAMEW       L"\\\\.\\pipe\\tracebuild"
#ifdef UNICODE
#define TBLOG_PIPE_NAME        TBLOG_PIPE_NAMEW
#else
#define TBLOG_PIPE_NAME        TBLOG_PIPE_NAMEA
#endif

//////////////////////////////////////////////////////////////////////////////
//
typedef struct _TBLOG_MESSAGE
{
    DWORD       nBytes;
    CHAR        szMessage[32764]; // 32768 - sizeof(nBytes)
} TBLOG_MESSAGE, *PTBLOG_MESSAGE;

typedef struct _TBLOG_PAYLOAD
{
    DWORD       nParentProcessId;
    DWORD       nTraceProcessId;
    DWORD       nGeneology;
    DWORD       rGeneology[64];
    WCHAR       wzParents[256];
    WCHAR       wzStdin[256];
    WCHAR       wzStdout[256];
    WCHAR       wzStderr[256];
    BOOL        fStdoutAppend;
    BOOL        fStderrAppend;
    WCHAR       wzzDrop[1024];  // Like an environment: zero terminated strings with a last zero.
    WCHAR       wzzEnvironment[32768];
} TBLOG_PAYLOAD, *PTBLOG_PAYLOAD;

// Shared state payload guid.
//
const GUID s_guidTrace = {
    0xd8e2dc69, 0x3004, 0x453e,
    {0x94, 0x15, 0x19, 0x0e, 0x79, 0xe8, 0x93, 0x52}
};


#endif //  _TRACEBLD_H_
//
///////////////////////////////////////////////////////////////// End of File.

```

`samples/tracebld/trcbld.cpp`:

```cpp
/////////////////////////////////////////////////////////////////////////////
//
//  Detours Test Program (trcbld.cpp of trcbld.dll)
//
//  Microsoft Research Detours Package
//
//  Copyright (c) Microsoft Corporation.  All rights reserved.
//

#define _WIN32_WINNT        0x0500
#define WIN32
#define NT

#define DBG_TRACE   0

#include <windows.h>
#include <stdio.h>
#pragma warning(push)
#if _MSC_VER > 1400
#pragma warning(disable:6102 6103) // /analyze warnings
#endif
#include <strsafe.h>
#pragma warning(pop)
#include "detours.h"
#include "tracebld.h"

#define PULONG_PTR          PVOID
#define PLONG_PTR           PVOID
#define ULONG_PTR           PVOID

//////////////////////////////////////////////////////////////////////////////

#pragma warning(disable:4127)   // Many of our asserts are constants.

#define DEBUG_BREAK() DebugBreak()

#define ASSERT_ALWAYS(x)   \
    do {                                                        \
        if (!(x)) {                                             \
            AssertFailed(#x, __FILE__, __LINE__);               \
            DebugBreak();                                       \
        }                                                       \
    } while (0)

#ifndef NDEBUG
#define ASSERT(x)           ASSERT_ALWAYS(x)
#else
#define ASSERT(x)
#endif

#define UNUSED(c)       (c) = (c)

//////////////////////////////////////////////////////////////////////////////
static HMODULE s_hInst = NULL;
static HMODULE s_hKernel32 = NULL;
static CHAR s_szDllPath[MAX_PATH];
static TBLOG_PAYLOAD s_Payload;
static TBLOG_PAYLOAD s_ChildPayload;
static CRITICAL_SECTION s_csChildPayload;
static DWORD s_nTraceProcessId = 0;
static LONG s_nChildCnt = 0;

static CRITICAL_SECTION s_csPipe;                       // Guards access to hPipe.
static HANDLE           s_hPipe = INVALID_HANDLE_VALUE;
static TBLOG_MESSAGE    s_rMessage;

// Logging Functions.
//
VOID Tblog(PCSTR pszMsgf, ...);
VOID TblogV(PCSTR pszMsgf, va_list args);

VOID VSafePrintf(PCSTR pszMsg, va_list args, PCHAR pszBuffer, LONG cbBuffer);
PCHAR SafePrintf(PCHAR pszBuffer, LONG cbBuffer, PCSTR pszMsg, ...);

LONG EnterFunc();
VOID ExitFunc();
VOID Print(PCSTR psz, ...);
VOID NoteRead(PCSTR psz);
VOID NoteRead(PCWSTR pwz);
VOID NoteWrite(PCSTR psz);
VOID NoteWrite(PCWSTR pwz);
VOID NoteDelete(PCSTR psz);
VOID NoteDelete(PCWSTR pwz);
VOID NoteCleanup(PCSTR psz);
VOID NoteCleanup(PCWSTR pwz);

PBYTE LoadFile(HANDLE hFile, DWORD cbFile);
static PCHAR RemoveReturns(PCHAR pszBuffer);
static PWCHAR RemoveReturns(PWCHAR pwzBuffer);

VOID AssertFailed(CONST PCHAR pszMsg, CONST PCHAR pszFile, ULONG nLine);

int WINAPI Mine_EntryPoint(VOID);
VOID WINAPI Mine_ExitProcess(UINT a0);

//////////////////////////////////////////////////////////////////////////////
//
int (WINAPI * Real_EntryPoint)(VOID)
    = NULL;

BOOL (WINAPI * Real_CreateDirectoryW)(LPCWSTR a0,
                                      LPSECURITY_ATTRIBUTES a1)
    = CreateDirectoryW;

BOOL (WINAPI * Real_CreateDirectoryExW)(LPCWSTR a0,
                                        LPCWSTR a1,
                                        LPSECURITY_ATTRIBUTES a2)
    = CreateDirectoryExW;

HANDLE (WINAPI * Real_CreateFileW)(LPCWSTR a0,
                                   DWORD a1,
                                   DWORD a2,
                                   LPSECURITY_ATTRIBUTES a3,
                                   DWORD a4,
                                   DWORD a5,
                                   HANDLE a6)
    = CreateFileW;

HANDLE (WINAPI * Real_CreateFileMappingW)(HANDLE hFile,
                                         LPSECURITY_ATTRIBUTES lpAttributes,
                                         DWORD flProtect,
                                         DWORD dwMaximumSizeHigh,
                                         DWORD dwMaximumSizeLow,
                                         LPCWSTR lpName
                                        )
    = CreateFileMappingW;

BOOL (WINAPI * Real_CreatePipe)(PHANDLE hReadPipe,
                                PHANDLE hWritePipe,
                                LPSECURITY_ATTRIBUTES lpPipeAttributes,
                                DWORD nSize)
    = CreatePipe;

BOOL (WINAPI * Real_CloseHandle)(HANDLE a0)
    = CloseHandle;

BOOL (WINAPI * Real_DuplicateHandle)(HANDLE hSourceProcessHandle,
                                     HANDLE hSourceHandle,
                                     HANDLE hTargetProcessHandle,
                                     LPHANDLE lpTargetHandle,
                                     DWORD dwDesiredAccess,
                                     BOOL bInheritHandle,
                                     DWORD dwOptions)
    = DuplicateHandle;

BOOL (WINAPI * Real_CreateProcessW)(LPCWSTR lpApplicationName,
                                    LPWSTR lpCommandLine,
                                    LPSECURITY_ATTRIBUTES lpProcessAttributes,
                                    LPSECURITY_ATTRIBUTES lpThreadAttributes,
                                    BOOL bInheritHandles,
                                    DWORD dwCreationFlags,
                                    LPVOID lpEnvironment,
                                    LPCWSTR lpCurrentDirectory,
                                    LPSTARTUPINFOW lpStartupInfo,
                                    LPPROCESS_INFORMATION lpProcessInformation)
    = CreateProcessW;

BOOL (WINAPI * Real_CreateProcessA)(LPCSTR lpApplicationName,
                                    LPSTR lpCommandLine,
                                    LPSECURITY_ATTRIBUTES lpProcessAttributes,
                                    LPSECURITY_ATTRIBUTES lpThreadAttributes,
                                    BOOL bInheritHandles,
                                    DWORD dwCreationFlags,
                                    LPVOID lpEnvironment,
                                    LPCSTR lpCurrentDirectory,
                                    LPSTARTUPINFOA lpStartupInfo,
                                    LPPROCESS_INFORMATION lpProcessInformation)
    = CreateProcessA;

BOOL (WINAPI * Real_DeleteFileW)(LPCWSTR a0)
    = DeleteFileW;
BOOL (WINAPI * Real_DeviceIoControl)(HANDLE a0,
                                     DWORD dwIoControlCode,
                                     LPVOID lpInBuffer,
                                     DWORD nInBufferSize,
                                     LPVOID lpOutBuffer,
                                     DWORD nOutBufferSize,
                                     LPDWORD lpBytesReturned,
                                     LPOVERLAPPED lpOverlapped)
    = DeviceIoControl;

DWORD (WINAPI * Real_GetFileAttributesW)(LPCWSTR a0)
    = GetFileAttributesW;

BOOL (WINAPI * Real_MoveFileWithProgressW)(LPCWSTR lpExistingFileName,
                                           LPCWSTR lpNewFileName,
                                           LPPROGRESS_ROUTINE lpProgressRoutine,
                                           LPVOID lpData,
                                           DWORD dwFlags)
    = MoveFileWithProgressW;

BOOL (WINAPI * Real_MoveFileA)(LPCSTR a0,
                               LPCSTR a1)
    = MoveFileA;

BOOL (WINAPI * Real_MoveFileW)(LPCWSTR a0,
                               LPCWSTR a12)
    = MoveFileW;

BOOL (WINAPI * Real_MoveFileExA)(LPCSTR a0,
                                 LPCSTR a1,
                                 DWORD a2)
    = MoveFileExA;

BOOL (WINAPI * Real_MoveFileExW)(LPCWSTR a0,
                                 LPCWSTR a1,
                                 DWORD a2)
    = MoveFileExW;

BOOL (WINAPI * Real_CopyFileExA)(LPCSTR a0,
                                 LPCSTR a1,
                                 LPPROGRESS_ROUTINE a2,
                                 LPVOID a4,
                                 LPBOOL a5,
                                 DWORD a6)
    = CopyFileExA;

BOOL (WINAPI * Real_CopyFileExW)(LPCWSTR a0,
                                 LPCWSTR a1,
                                 LPPROGRESS_ROUTINE a2,
                                 LPVOID a4,
                                 LPBOOL a5,
                                 DWORD a6)
    = CopyFileExW;

BOOL (WINAPI * Real_PrivCopyFileExW)(LPCWSTR  lpExistingFileName,
                                     LPCWSTR  lpNewFileName,
                                     LPPROGRESS_ROUTINE  lpProgressRoutine,
                                     LPVOID  lpData,
                                     LPBOOL  pbCancel,
                                     DWORD  dwCopyFlags)
    = NULL;

BOOL (WINAPI * Real_CreateHardLinkA)(LPCSTR a0,
                                     LPCSTR a1,
                                     LPSECURITY_ATTRIBUTES a2)
    = CreateHardLinkA;

BOOL (WINAPI * Real_CreateHardLinkW)(LPCWSTR a0,
                                     LPCWSTR a1,
                                     LPSECURITY_ATTRIBUTES a2)
    = CreateHardLinkW;

BOOL (WINAPI * Real_SetStdHandle)(DWORD a0,
                                  HANDLE a1)
    = SetStdHandle;

HMODULE (WINAPI * Real_LoadLibraryA)(LPCSTR a0)
    = LoadLibraryA;

HMODULE (WINAPI * Real_LoadLibraryW)(LPCWSTR a0)
    = LoadLibraryW;

HMODULE (WINAPI * Real_LoadLibraryExA)(LPCSTR a0,
                                       HANDLE a1,
                                       DWORD a2)
    = LoadLibraryExA;

HMODULE (WINAPI * Real_LoadLibraryExW)(LPCWSTR a0,
                                       HANDLE a1,
                                       DWORD a2)
    = LoadLibraryExW;

DWORD (WINAPI * Real_SetFilePointer)(HANDLE hFile,
                                     LONG lDistanceToMove,
                                     PLONG lpDistanceToMoveHigh,
                                     DWORD dwMoveMethod)
    = SetFilePointer;

BOOL (WINAPI * Real_SetFilePointerEx)(HANDLE hFile,
                                      LARGE_INTEGER liDistanceToMove,
                                      PLARGE_INTEGER lpNewFilePointer,
                                      DWORD dwMoveMethod)
    = SetFilePointerEx;

BOOL (WINAPI * Real_ReadFile)(HANDLE a0,
                                 LPVOID a1,
                                 DWORD a2,
                                 LPDWORD a3,
                                 LPOVERLAPPED a4)
    = ReadFile;

BOOL (WINAPI * Real_ReadFileEx)(HANDLE a0,
                                   LPVOID a1,
                                   DWORD a2,
                                   LPOVERLAPPED a3,
                                   LPOVERLAPPED_COMPLETION_ROUTINE a4)
    = ReadFileEx;

BOOL (WINAPI * Real_WriteFile)(HANDLE a0,
                                  LPCVOID a1,
                                  DWORD a2,
                                  LPDWORD a3,
                                  LPOVERLAPPED a4)
    = WriteFile;

BOOL (WINAPI * Real_WriteFileEx)(HANDLE a0,
                                    LPCVOID a1,
                                    DWORD a2,
                                    LPOVERLAPPED a3,
                                    LPOVERLAPPED_COMPLETION_ROUTINE a4)
    = WriteFileEx;

BOOL (WINAPI * Real_WriteConsoleA)(HANDLE a0,
                                      const VOID* a1,
                                      DWORD a2,
                                      LPDWORD a3,
                                      LPVOID a4)
    = WriteConsoleA;

BOOL (WINAPI * Real_WriteConsoleW)(HANDLE a0,
                                      const VOID* a1,
                                      DWORD a2,
                                      LPDWORD a3,
                                      LPVOID a4)
    = WriteConsoleW;

VOID (WINAPI * Real_ExitProcess)(UINT a0)
    = ExitProcess;

DWORD (WINAPI * Real_ExpandEnvironmentStringsA)(PCSTR lpSrc, PCHAR lpDst, DWORD nSize)
    = ExpandEnvironmentStringsA;

DWORD (WINAPI * Real_ExpandEnvironmentStringsW)(PCWSTR lpSrc, PWCHAR lpDst, DWORD nSize)
    = ExpandEnvironmentStringsW;

DWORD (WINAPI * Real_GetEnvironmentVariableA)(PCSTR lpName, PCHAR lpBuffer, DWORD nSize)
    = GetEnvironmentVariableA;

DWORD (WINAPI * Real_GetEnvironmentVariableW)(PCWSTR lpName, PWCHAR lpBuffer, DWORD nSize)
    = GetEnvironmentVariableW;

PCWSTR (CDECL * Real_wgetenv)(PCWSTR var) = NULL;
PCSTR (CDECL * Real_getenv)(PCSTR var) = NULL;
DWORD (CDECL * Real_getenv_s)(DWORD *pValue, PCHAR pBuffer, DWORD cBuffer, PCSTR varname) = NULL;
DWORD (CDECL * Real_wgetenv_s)(DWORD *pValue, PWCHAR pBuffer, DWORD cBuffer, PCWSTR varname) = NULL;
DWORD (CDECL * Real_dupenv_s)(PCHAR *ppBuffer, DWORD *pcBuffer, PCSTR varname) = NULL;
DWORD (CDECL * Real_wdupenv_s)(PWCHAR *ppBuffer, DWORD *pcBuffer, PCWSTR varname) = NULL;

//////////////////////////////////////////////////////////////////////////////
//
static VOID Copy(PWCHAR pwzDst, PCWSTR pwzSrc)
{
    while (*pwzSrc) {
        *pwzDst++ = *pwzSrc++;
    }
    *pwzDst = '\0';
}

static DWORD Size(PCWSTR pwzSrc)
{
    DWORD c = 0;
    while (pwzSrc[c]) {
        c++;
    }
    return c;
}

static PCWSTR Save(PCWSTR pwzSrc)
{
    DWORD c = (Size(pwzSrc) + 1) * sizeof(WCHAR);
    PWCHAR pwzDst = (PWCHAR)GlobalAlloc(GPTR, c);
    CopyMemory(pwzDst, pwzSrc, c);

    return pwzDst;
}

static BOOL HasSpace(PCWSTR pwz)
{
    for (; *pwz; pwz++) {
        if (*pwz == ' ' || *pwz == '\t' || *pwz == '\r' || *pwz == '\n') {
            return TRUE;
        }
    }
    return FALSE;
}

static BOOL HasChar(PCWSTR pwz, WCHAR w)
{
    for (; *pwz; pwz++) {
        if (*pwz == w) {
            return TRUE;
        }
    }
    return FALSE;
}

static DWORD Compare(PCWSTR pwzA, PCWSTR pwzB)
{
    for (;;) {
        WCHAR cA = *pwzA++;
        WCHAR cB = *pwzB++;

        if (cA >= 'A' && cA <= 'Z') {
            cA += ('a' - 'A');
        }
        if (cB >= 'A' && cB <= 'Z') {
            cB += ('a' - 'A');
        }

        if (cA == 0 && cB == 0) {
            return 0;
        }
        if (cA != cB) {
            return cA - cB;
        }
    }
}

static DWORD Compare(PCWSTR pwzA, PCSTR pszB)
{
    for (;;) {
        WCHAR cA = *pwzA++;
        WCHAR cB = *pszB++;

        if (cA >= 'A' && cA <= 'Z') {
            cA += ('a' - 'A');
        }
        if (cB >= 'A' && cB <= 'Z') {
            cB += ('a' - 'A');
        }

        if (cA == 0 && cB == 0) {
            return 0;
        }
        if (cA != cB) {
            return cA - cB;
        }
    }
}

static DWORD Compare(PCSTR pszA, PCSTR pszB)
{
    for (;;) {
        CHAR cA = *pszA++;
        CHAR cB = *pszB++;

        if (cA >= 'A' && cA <= 'Z') {
            cA += ('a' - 'A');
        }
        if (cB >= 'A' && cB <= 'Z') {
            cB += ('a' - 'A');
        }

        if (cA == 0 && cB == 0) {
            return 0;
        }
        if (cA != cB) {
            return cA - cB;
        }
    }
}

//////////////////////////////////////////////////////////////////////////////

static PCSTR s_rpszMsvcrNames[] = {
    "msvcr80.dll",
    "msvcr80d.dll",
    "msvcr71.dll",
    "msvcr71d.dll",
    "msvcr70.dll",
    "msvcr70d.dll",
    NULL
};

HMODULE s_hMsvcr = NULL;
PCSTR s_pszMsvcr = NULL;

static BOOL WINAPI ImportFileCallback(PVOID pContext, HMODULE hFile, PCSTR pszFile)
{
    UNUSED(pContext);

    if (pszFile != NULL) {
        for (int i = 0; s_rpszMsvcrNames[i]; i++) {
            if (Compare(pszFile, s_rpszMsvcrNames[i]) == 0) {
                s_hMsvcr = hFile;
                s_pszMsvcr = s_rpszMsvcrNames[i];
                return FALSE;
            }
        }
    }
    return TRUE;
}

BOOL FindMsvcr()
{
    DetourEnumerateImports(NULL, NULL, ImportFileCallback, NULL);

    if (s_hMsvcr != NULL) {
        return TRUE;
    }

    return FALSE;
}

BOOL FindProc(PVOID * ppvCode, PCSTR pwzFunc)
{
    PVOID pv = GetProcAddress(s_hMsvcr, pwzFunc);
    if (pv != NULL) {
        *ppvCode = pv;
        return TRUE;
    }
    else {
        *ppvCode = NULL;
        return FALSE;
    }
}

//////////////////////////////////////////////////////////////////////////////
//
struct EnvInfo
{
    DWORD   m_nHash;
    DWORD   m_nIndex;
    PCWSTR  m_pwzVar;
    PCWSTR  m_pwzVal;
    BOOL    m_fDefined;
    BOOL    m_fUsed;
    BOOL    m_fOriginal;
};

//////////////////////////////////////////////////////////////////////////////
//
class EnvVars
{
  private:
    static CRITICAL_SECTION s_csLock;
    static DWORD            s_nVars;
    static DWORD            s_nCapacity;
    static EnvInfo **       s_pVars;

  private:
    static DWORD Hash(PCWSTR pwzVar)
    {
        DWORD hash = 5381;
        while (*pwzVar != 0) {
            WCHAR c = *pwzVar++;
            if (c >= 'A' && c <= 'Z') {
                c += ('a' - 'A');
            }
            hash = ((hash << 5) + hash) + c;
        }
        return hash;
    }

    static VOID LockAcquire()
    {
        EnterCriticalSection(&s_csLock);
    }

    static VOID LockRelease()
    {
        LeaveCriticalSection(&s_csLock);
    }

    static VOID Resize(DWORD nCapacity);
    static VOID Set(EnvInfo *info);
    static EnvInfo * Find(PCWSTR pwzVar);

  public:
    static BOOL Equal(PCWSTR pwzA, PCWSTR pwzB)
    {
        return (Compare(pwzA, pwzB) == 0);
    }

  public:
    static VOID Initialize();
    static VOID Dump();

    static VOID Add(PCWSTR pwzVar, PCWSTR pwzVal);

    static VOID Used(PCWSTR pwzVar);
    static VOID Used(PCSTR pszVar);
};

CRITICAL_SECTION    EnvVars::s_csLock;
DWORD               EnvVars::s_nVars = 0;
DWORD               EnvVars::s_nCapacity = 0;
EnvInfo **          EnvVars::s_pVars = NULL;

VOID EnvVars::Initialize()
{
    InitializeCriticalSection(&s_csLock);

    Resize(919);
}

VOID EnvVars::Resize(DWORD nCapacity)
{
    if (nCapacity > s_nCapacity) {
        DWORD nOld = s_nCapacity;
        EnvInfo ** pOld = s_pVars;

        // DEBUG_BREAK();

        s_pVars = (EnvInfo **)GlobalAlloc(GPTR, nCapacity * sizeof(EnvInfo *));
        s_nCapacity = nCapacity;

        if (pOld != NULL) {
            for (DWORD n = 0; n < nOld; n++) {
                if (pOld[n] != NULL) {
                    Set(pOld[n]);
                }
            }
            GlobalFree((HGLOBAL)pOld);
            pOld = NULL;
        }
    }
}

VOID EnvVars::Set(EnvInfo *info)
{
    DWORD hash = info->m_nHash;
    DWORD slot = hash % s_nCapacity;
    DWORD death = 0;

    // Find an empty slot.
    for (; s_pVars[slot] != NULL; slot = (slot + 1) % s_nCapacity) {
        if (++death > s_nCapacity) {
            // We should have dropped out at some point...
            DEBUG_BREAK();
        }
    }

    s_pVars[slot] = info;
}

EnvInfo * EnvVars::Find(PCWSTR pwzVar)
{
    DWORD hash = Hash(pwzVar);
    DWORD slot = hash % s_nCapacity;

    LockAcquire();

    // Find the the matching slot, or an empty one.
    for (; s_pVars[slot] != NULL; slot = (slot + 1) % s_nCapacity) {
        if (Equal(s_pVars[slot]->m_pwzVar, pwzVar)) {
            LockRelease();
            return s_pVars[slot];
        }
    }
    LockRelease();
    return NULL;
}

VOID EnvVars::Add(PCWSTR pwzVar, PCWSTR pwzVal)
{
    if (pwzVar == NULL) {
        return;
    }

    WCHAR wzVar[MAX_PATH];
    PWCHAR pwzDst = wzVar;
    while (*pwzVar) {
        if (*pwzVar >= 'a' && *pwzVar <= 'z') {
            *pwzDst++ = *pwzVar - ('a' - 'A');
        }
        else {
            *pwzDst++ = *pwzVar;
        }
        pwzVar++;
    }
    *pwzDst = '\0';
    pwzVar = wzVar;

    WCHAR wzVal[] = L"";
    if (pwzVal != NULL) {
        while (*pwzVal == ' ' || *pwzVal == '\t') {
            *pwzVal++;
        }
    }
    else {
        pwzVal = wzVal;
    }

    // Tblog("<!-- ::Add var=[%le] val=[%le] -->\n", pwzVar, pwzVal);
    LockAcquire();

    // DEBUG_BREAK();

    DWORD hash = Hash(pwzVar);
    DWORD slot = hash % s_nCapacity;
    EnvInfo *info = NULL;
    DWORD death = 0;

    // Find the the matching slot, or an empty one.
    for (; s_pVars[slot] != NULL; slot = (slot + 1) % s_nCapacity) {
        if (Equal(s_pVars[slot]->m_pwzVar, pwzVar)) {
            LockRelease();
            return;
        }
        if (++death > s_nCapacity) {
            // We should have dropped out at some point...
            DEBUG_BREAK();
        }
    }

    // Add the var to list of known vars.
    info = (EnvInfo *)GlobalAlloc(GPTR, sizeof(EnvInfo));
    info->m_nHash = hash;
    info->m_nIndex = s_nVars++;
    info->m_pwzVar = Save(pwzVar);
    info->m_pwzVal = Save(pwzVal);
    if (pwzVal[0] == '\0') {
        info->m_fDefined = FALSE;
        info->m_fUsed = TRUE;
    }
    else {
        info->m_fDefined = TRUE;
    }
    s_pVars[slot] = info;

    // Check if we should grow the table.
    if (s_nVars > (s_nCapacity / 2)) {
        Resize(s_nCapacity * 2 - 1);
    }

    LockRelease();
}

VOID EnvVars::Used(PCWSTR pwzVar)
{
    if (pwzVar != NULL) {
        // Tblog("<!-- Used [%le] -->\n", pwzVar);
        EnvInfo *pInfo = Find(pwzVar);
        if (pInfo) {
            pInfo->m_fUsed = TRUE;
        }
#if 0
        else {
            Add(pwzVar, NULL);
        }
#endif
    }
}

VOID EnvVars::Used(PCSTR pszVar)
{
    if (pszVar != NULL) {
        WCHAR wzVar[MAX_PATH];
        PWCHAR pwzVar = wzVar;
        while (*pszVar) {
            *pwzVar++ = *pszVar++;
        }
        *pwzVar = '\0';

        Used(wzVar);
    }
}

VOID EnvVars::Dump()
{
    if (s_nVars == 0) {
        return;
    }

    LockAcquire();

    Tblog("<t:Vars>\n");

    // Remove any variables that match the original environment.
    PCWSTR pwzz = s_Payload.wzzEnvironment;
    while (*pwzz) {
        WCHAR wzVar[MAX_PATH];
        PWCHAR pwzVar = wzVar;

        while (*pwzz && *pwzz != '=') {
            *pwzVar++ = *pwzz++;
        }
        *pwzVar = '\0';
        if (*pwzz == '=') {
            pwzz++;
        }

        EnvInfo *pInfo = Find(wzVar);
        if (pInfo) {
            if (Compare(pwzz, pInfo->m_pwzVal) == 0) {
                pInfo->m_fUsed = FALSE;
            }
        }
        pwzz += Size(pwzz) + 1;
    }


    EnvInfo ** pSorted = (EnvInfo **)GlobalAlloc(GPTR, s_nVars * sizeof(EnvInfo *));

    for (DWORD n = 0; n < s_nCapacity; n++) {
        if (s_pVars[n] != NULL) {
            if (s_pVars[n]->m_nIndex > s_nVars) {
                DEBUG_BREAK();
            }
            pSorted[s_pVars[n]->m_nIndex] = s_pVars[n];
        }
    }

    for (DWORD n = 0; n < s_nVars; n++) {
        EnvInfo *pInfo = pSorted[n];

        if (pInfo == NULL) {
            Print("<!-- Warning: Missing %d of %d -->\n", n, s_nVars);
            continue;
        }

        if (pInfo->m_fUsed && pInfo->m_pwzVal[0]) {
            Print("<t:Var var=\"%le\">%le</t:Var>\n", pInfo->m_pwzVar, pInfo->m_pwzVal);
        }
    }
    GlobalFree((HGLOBAL)pSorted);

    Tblog("</t:Vars>\n");

    LockRelease();
}

void SaveEnvironment()
{
    LPWCH pwStrings = GetEnvironmentStringsW();
    PCWSTR pwEnv = (PCWSTR)pwStrings;

    while (*pwEnv != '\0') {
        WCHAR wzVar[MAX_PATH];
        PWCHAR pwzDst = wzVar;
        PCWSTR pwzVal = NULL;

        if (*pwEnv == '=') {
            *pwzDst++ = *pwEnv++;
        }
        while (*pwEnv != '\0' && *pwEnv != '=') {
            *pwzDst++ = *pwEnv++;
        }
        *pwzDst++ = '\0';

        if (*pwEnv == '=') {
            pwEnv++;
        }

        pwzVal = pwEnv;
        while (*pwEnv != '\0') {
            pwEnv++;
        }
        if (*pwEnv == '\0') {
            pwEnv++;
        }
        if (wzVar[0] != '=') {
            EnvVars::Add(wzVar, pwzVal);
        }
    }
    FreeEnvironmentStringsW(pwStrings);
}

//////////////////////////////////////////////////////////////////////////////
//
struct ProcInfo
{
    HANDLE  m_hProc;
    DWORD   m_nProcId;
    DWORD   m_nProc;
};

class Procs
{
  private:
    static CRITICAL_SECTION s_csLock;
    static DWORD            s_nProcs;
    static ProcInfo         s_rProcs[4049];

  private:
    static ProcInfo& HashToSlot(HANDLE handle)
    {
        return s_rProcs[((DWORD_PTR)handle) % ARRAYSIZE(s_rProcs)];
    }

    static VOID LockAcquire()
    {
        EnterCriticalSection(&s_csLock);
    }

    static VOID LockRelease()
    {
        LeaveCriticalSection(&s_csLock);
    }

  public:
    static VOID Initialize();
    static ProcInfo * Create(HANDLE hProc, DWORD nProcId);
    static BOOL Close(HANDLE hProc);
};

CRITICAL_SECTION    Procs::s_csLock;
DWORD               Procs::s_nProcs = 0;
ProcInfo            Procs::s_rProcs[4049];

VOID Procs::Initialize()
{
    InitializeCriticalSection(&s_csLock);
    for (DWORD i = 0; i < ARRAYSIZE(s_rProcs); i++) {
        s_rProcs[i].m_hProc = INVALID_HANDLE_VALUE;
    }
}

ProcInfo * Procs::Create(HANDLE hProc, DWORD nProcId)
{
    LockAcquire();
    s_nProcs++;
    ProcInfo& slot = HashToSlot(hProc);
    slot.m_hProc = hProc;
    slot.m_nProcId = nProcId;
    slot.m_nProc = s_nProcs;
    Print("<!-- CreateProcess (%d)-->\n", slot.m_nProc);
    LockRelease();

    return &slot;
}

BOOL Procs::Close(HANDLE hProc)
{
    BOOL first = false;

    LockAcquire();
    ProcInfo& slot = HashToSlot(hProc);
    if (slot.m_hProc == hProc) {
        first = true;
        Print("<!-- CloseProcess (%d)-->\n", slot.m_nProc);
        slot.m_hProc = INVALID_HANDLE_VALUE;
        slot.m_nProcId = 0;
        slot.m_nProc = 0;
        s_nProcs--;
    }
    LockRelease();

    return first;
}

//////////////////////////////////////////////////////////////////////////////
//
struct FileInfo
{
    DWORD   m_nHash;
    DWORD   m_nIndex;

    BOOL    m_fCantRead;        // Set for file that are opened Create
    BOOL    m_fRead;
    BOOL    m_fWrite;

    BOOL    m_fDelete;
    BOOL    m_fCleanup;
    BOOL    m_fSystemPath;
    BOOL    m_fTemporaryPath;
    BOOL    m_fTemporaryFile;

    DWORD   m_cbRead;
    DWORD   m_cbWrite;

    BOOL    m_fAppend;
    BOOL    m_fAbsorbed;        // Absorbed by TraceBld.
    BOOL    m_fDirectory;

    PCWSTR  m_pwzPath;
    PBYTE   m_pbContent;
    DWORD   m_cbContent;

};

//////////////////////////////////////////////////////////////////////////////
//
class FileNames
{
  private:
    static CRITICAL_SECTION s_csLock;
    static DWORD            s_nFiles;
    static DWORD            s_nCapacity;
    static FileInfo **      s_pFiles;

  public:
    static WCHAR            s_wzSysPath[MAX_PATH];
    static WCHAR            s_wzS64Path[MAX_PATH];
    static WCHAR            s_wzTmpPath[MAX_PATH];
    static WCHAR            s_wzExePath[MAX_PATH];
    static DWORD            s_wcSysPath;
    static DWORD            s_wcS64Path;
    static DWORD            s_wcTmpPath;
    static DWORD            s_wcExePath;

  private:
    static DWORD Hash(PCWSTR pwzFile)
    {
        DWORD hash = 5381;
        while (*pwzFile != 0) {
            WCHAR c = *pwzFile++;
            if (c >= 'A' && c <= 'Z') {
                c += ('a' - 'A');
            }
            hash = ((hash << 5) + hash) + c;
        }
        return hash;
    }

    static VOID LockAcquire()
    {
        EnterCriticalSection(&s_csLock);
    }

    static VOID LockRelease()
    {
        LeaveCriticalSection(&s_csLock);
    }

    static VOID Resize(DWORD nCapacity);
    static VOID Set(FileInfo *info);
    static VOID Replace(PWCHAR pwzBuffer, PWCHAR pwzDstEnd, DWORD cwOld, PCWSTR pwzNew);

  public:
    static BOOL Equal(PCWSTR pwzA, PCWSTR pwzB)
    {
        return (Compare(pwzA, pwzB) == 0);
    }

    static BOOL PrefixMatch(PCWSTR pwzFile, PCWSTR pwzPrefix)
    {
        for (;;) {
            WCHAR cFile = *pwzFile++;
            WCHAR cPrefix = *pwzPrefix++;

            if (cFile >= 'A' && cFile <= 'Z') {
                cFile += ('a' - 'A');
            }
            if (cPrefix >= 'A' && cPrefix <= 'Z') {
                cPrefix += ('a' - 'A');
            }

            if (cPrefix == 0) {
                return TRUE;
            }
            if (cFile != cPrefix) {
                return FALSE;
            }
        }
    }

    static BOOL SuffixMatch(PCWSTR pwzFile, PCWSTR pwzSuffix)
    {
        // Move both pointers to the end of the strings.
        PCWSTR pwzFileBeg = pwzFile;
        while (*pwzFile) {
            pwzFile++;
        }

        PCWSTR pwzSuffixBeg = pwzSuffix;
        while (*pwzSuffix) {
            pwzSuffix++;
        }

        // Now walk backwards comparing strings.
        for (;;) {
            WCHAR cFile = (pwzFile > pwzFileBeg) ? *--pwzFile : 0;
            WCHAR cSuffix = (pwzSuffix > pwzSuffixBeg) ? *--pwzSuffix : 0;

            if (cFile >= 'A' && cFile <= 'Z') {
                cFile += ('a' - 'A');
            }
            if (cSuffix >= 'A' && cSuffix <= 'Z') {
                cSuffix += ('a' - 'A');
            }

            if (cSuffix == 0) {
                return TRUE;
            }
            if (cFile != cSuffix) {
                return FALSE;
            }
        }
    }

    static VOID EndInSlash(PWCHAR pwzPath)
    {
        if (*pwzPath) {
            while (*pwzPath) {
                pwzPath++;
            }
            if (pwzPath[-1] != '\\') {
                *pwzPath++ = '\\';
                *pwzPath = '\0';
            }
        }
    }

  public:
    static VOID Initialize();
    static VOID Dump();
    static FileInfo * FindPartial(PCWSTR pwzPath);
    static FileInfo * FindPartial(PCSTR pszPath);
    static FileInfo * FindFull(PCWSTR pwzPath);
    static PCWSTR ParameterizeName(PWCHAR pwzDst, DWORD cMaxDst, PCWSTR pwzPath);
    static PCWSTR ParameterizeName(PWCHAR pwzDst, DWORD cMaxDst, FileInfo *pInfo);
    static VOID ParameterizeLine(PWCHAR pwzDst, PWCHAR pwzDstEnd);
};

CRITICAL_SECTION    FileNames::s_csLock;
DWORD               FileNames::s_nFiles = 0;
DWORD               FileNames::s_nCapacity = 0;
FileInfo **         FileNames::s_pFiles;
WCHAR               FileNames::s_wzSysPath[MAX_PATH];
WCHAR               FileNames::s_wzS64Path[MAX_PATH];
WCHAR               FileNames::s_wzTmpPath[MAX_PATH];
WCHAR               FileNames::s_wzExePath[MAX_PATH];
DWORD               FileNames::s_wcSysPath;
DWORD               FileNames::s_wcS64Path;
DWORD               FileNames::s_wcTmpPath;
DWORD               FileNames::s_wcExePath;

VOID FileNames::Initialize()
{
    InitializeCriticalSection(&s_csLock);

    s_wzSysPath[0] = '\0';
    GetSystemDirectoryW(s_wzSysPath, ARRAYSIZE(s_wzSysPath));
    EndInSlash(s_wzSysPath);

    s_wzS64Path[0] = '\0';
    GetWindowsDirectoryW(s_wzS64Path, ARRAYSIZE(s_wzS64Path));
    EndInSlash(s_wzS64Path);
    Copy(s_wzS64Path + Size(s_wzS64Path), L"SysWOW64\\");

    s_wzTmpPath[0] = '\0';
    GetTempPathW(ARRAYSIZE(s_wzTmpPath), s_wzTmpPath);
    EndInSlash(s_wzTmpPath);

    s_wzExePath[0] = '\0';
    GetModuleFileNameW(NULL, s_wzExePath, ARRAYSIZE(s_wzExePath));
    PWCHAR pwzLast = s_wzExePath;
    for (PWCHAR pwz = s_wzExePath; *pwz; pwz++) {
        if (*pwz == '\\') {
            pwzLast = pwz;
        }
    }
    if (*pwzLast == '\\') {
        *++pwzLast = '\0';
    }

    s_wcSysPath = Size(s_wzSysPath);
    s_wcS64Path = Size(s_wzS64Path);
    s_wcTmpPath = Size(s_wzTmpPath);
    s_wcExePath = Size(s_wzExePath);

    Resize(4049);
}

VOID FileNames::Resize(DWORD nCapacity)
{
    if (nCapacity > s_nCapacity) {
        DWORD nOld = s_nCapacity;
        FileInfo ** pOld = s_pFiles;

        s_pFiles = (FileInfo **)GlobalAlloc(GPTR, nCapacity * sizeof(FileInfo *));
        s_nCapacity = nCapacity;

        if (pOld != NULL) {
            for (DWORD n = 0; n < nOld; n++) {
                if (pOld[n] != NULL) {
                    Set(pOld[n]);
                }
            }
            GlobalFree((HGLOBAL)pOld);
            pOld = NULL;
        }
        s_nCapacity = nCapacity;
    }
}

VOID FileNames::Set(FileInfo *info)
{
    DWORD hash = info->m_nHash;
    DWORD slot = hash % s_nCapacity;
    DWORD death = 0;

    // Find an empty slot.
    for (; s_pFiles[slot] != NULL; slot = (slot + 1) % s_nCapacity) {
        if (++death > s_nCapacity) {
            // We should have dropped out at some point...
            DEBUG_BREAK();
        }
    }

    s_pFiles[slot] = info;
}

FileInfo * FileNames::FindFull(PCWSTR pwzPath)
{
    if (pwzPath == NULL) {
        return NULL;
    }

    LockAcquire();

    DWORD hash = Hash(pwzPath);
    DWORD slot = hash % s_nCapacity;
    FileInfo *info = NULL;
    DWORD death = 0;

    // Find the the matching slot, or an empty one.
    for (; s_pFiles[slot] != NULL; slot = (slot + 1) % s_nCapacity) {
        if (Equal(s_pFiles[slot]->m_pwzPath, pwzPath)) {
            info = s_pFiles[slot];
            goto succeed;
        }
        if (++death > s_nCapacity) {
            // We should have dropped out at some point...
            DEBUG_BREAK();
        }
    }

    // Add the file to list of known files.
    info = (FileInfo *)GlobalAlloc(GPTR, sizeof(FileInfo));
    info->m_nHash = hash;
    info->m_nIndex = s_nFiles++;
    info->m_pwzPath = Save(pwzPath);
    info->m_fSystemPath = (PrefixMatch(info->m_pwzPath, s_wzSysPath) ||
                           PrefixMatch(info->m_pwzPath, s_wzS64Path));
    info->m_fTemporaryPath = PrefixMatch(info->m_pwzPath, s_wzTmpPath);
    info->m_fTemporaryFile = SuffixMatch(info->m_pwzPath, L".tmp");

    s_pFiles[slot] = info;

    // Check if we should grow the table.
    if (s_nFiles > (s_nCapacity / 2)) {
        Resize(s_nCapacity * 2 - 1);
    }

  succeed:
    LockRelease();

    return info;
}

FileInfo * FileNames::FindPartial(PCWSTR pwzPath)
{
    WCHAR wzPath[MAX_PATH];
    PWCHAR pwzFile = NULL;

    if (!GetFullPathNameW(pwzPath, ARRAYSIZE(wzPath), wzPath, &pwzFile)) {
        return FindFull(pwzPath);
    }
    else {
        return FindFull(wzPath);
    }
}

FileInfo * FileNames::FindPartial(PCSTR pwzPath)
{
    WCHAR wzPath[MAX_PATH];
    PWCHAR pwzFile = wzPath;

    while (*pwzPath) {
        *pwzFile++ = *pwzPath++;
    }
    *pwzFile = '\0';

    return FindPartial(wzPath);
}

PCWSTR FileNames::ParameterizeName(PWCHAR pwzDst, DWORD cMaxDst, FileInfo *pInfo)
{
    return ParameterizeName(pwzDst, cMaxDst, pInfo->m_pwzPath);
}

PCWSTR FileNames::ParameterizeName(PWCHAR pwzDst, DWORD cMaxDst, PCWSTR pwzPath)
{
    if (PrefixMatch(pwzPath, s_wzSysPath)) {
        Copy(pwzDst, L"%SYSDIR%\\");
        Copy(pwzDst + Size(pwzDst), pwzPath + s_wcSysPath);
        goto finish;
    }
    else if (PrefixMatch(pwzPath, s_wzS64Path)) {
        Copy(pwzDst, L"%SYSDIR%\\");
        Copy(pwzDst + Size(pwzDst), pwzPath + s_wcS64Path);
        goto finish;
    }
    else if (PrefixMatch(pwzPath, s_wzTmpPath)) {
        Copy(pwzDst, L"%TMPDIR%\\");
        Copy(pwzDst + Size(pwzDst), pwzPath + s_wcTmpPath);
        goto finish;
    }
    else {
        Copy(pwzDst, pwzPath);

      finish:
#if 0 // to convert to all lower case.
        for (PWCHAR pwz = pwzDst; *pwz && pwz < pwzDst + cMaxDst; pwz++) {
            if (*pwz >= 'A' && *pwz <= 'Z') {
                *pwz = 'a' + (*pwz - 'A');
            }
        }
#else
        (void)cMaxDst;
#endif
        return pwzDst;
    }
}

VOID FileNames::Replace(PWCHAR pwzDst, PWCHAR pwzDstEnd, DWORD cwOld, PCWSTR pwzNew)
{
    DWORD cwNew = Size(pwzNew);
    DWORD cwDst = Size(pwzDst);

    if (cwOld < cwNew) {        // We have to insert.
        if ((cwDst + cwNew - cwOld) >= (DWORD)(pwzDstEnd - pwzDst)) {
            // Won't fit, so abort.
            return;
        }

        PWCHAR pwzTo = pwzDst + cwDst + (cwNew - cwOld);
        PWCHAR pwzFm = pwzDst + cwDst;

        while (pwzTo >= pwzDst) {
            *pwzTo-- = *pwzFm--;
        }
    }
    else if (cwOld > cwNew) {  // We have to remove.
        PWCHAR pwzTo = pwzDst + cwNew;
        PWCHAR pwzFm = pwzDst + cwOld;

        while (*pwzFm) {
            *pwzTo++ = *pwzFm++;
        }
        *pwzTo = '\0';
    }

    // Now write the new string.
    while (*pwzNew) {
        *pwzDst++ = *pwzNew++;
    }
}

VOID FileNames::ParameterizeLine(PWCHAR pwzDst, PWCHAR pwzDstEnd)
{
    for (; *pwzDst != '\0'; pwzDst++) {
        if (PrefixMatch(pwzDst, s_wzSysPath)) {
            Replace(pwzDst, pwzDstEnd, s_wcSysPath, L"%SYSDIR%\\");
        }
        else if (PrefixMatch(pwzDst, s_wzS64Path)) {
            Replace(pwzDst, pwzDstEnd, s_wcS64Path, L"%SYSDIR%\\");
        }
        else if (PrefixMatch(pwzDst, s_wzTmpPath)) {
            Replace(pwzDst, pwzDstEnd, s_wcTmpPath, L"%TMPDIR%\\");
        }
    }
}

VOID FileNames::Dump()
{
    WCHAR wzPath[MAX_PATH];

    if (s_nFiles == 0) {
        return;
    }

    LockAcquire();

    Tblog("<t:Files>\n");

    FileInfo ** pSorted = (FileInfo **)GlobalAlloc(GPTR, s_nFiles * sizeof(FileInfo *));

    for (DWORD n = 0; n < s_nCapacity; n++) {
        if (s_pFiles[n] != NULL) {
            if (s_pFiles[n]->m_nIndex > s_nFiles) {
                DEBUG_BREAK();
            }
            pSorted[s_pFiles[n]->m_nIndex] = s_pFiles[n];
        }
    }

    for (DWORD n = 0; n < s_nFiles; n++) {
        FileInfo *pInfo = pSorted[n];

        if (pInfo == NULL) {
            Print("<!-- Warning: Missing %d of %d -->\n", n, s_nFiles);
            continue;
        }

        BOOL fRead = pInfo->m_fRead;
        BOOL fWrite = pInfo->m_fWrite;
        BOOL fDelete = (pInfo->m_fDelete);
        BOOL fCleanup = (pInfo->m_fCleanup);
        BOOL fAppend = (pInfo->m_fAppend);

#if 0
        if (fDelete && !fRead && !fWrite) {
            Print("<!-- Discarding: %ls -->\n", pInfo->m_pwzPath);
            // Discard pipe files only passed to children.
            continue;
        }
#endif
        if (pInfo->m_fAbsorbed) {
            // Discard response fles
            continue;
        }

        if (PrefixMatch(pInfo->m_pwzPath, s_wzExePath) ||
            PrefixMatch(pInfo->m_pwzPath, s_wzSysPath) ||
            PrefixMatch(pInfo->m_pwzPath, s_wzS64Path)) {
            // Discard files from exec directory (because considered internal to code).
            continue;
        }

#if 1 // Ignore PIPEs.
        if (FileNames::PrefixMatch(pInfo->m_pwzPath, L"\\\\.\\PIPE\\")) {
            continue;
        }
#endif
        if (FileNames::SuffixMatch(pInfo->m_pwzPath, L"\\conout$")) {
            continue;
        }
        if (FileNames::SuffixMatch(pInfo->m_pwzPath, L"\\conin$")) {
            continue;
        }
        if (FileNames::SuffixMatch(pInfo->m_pwzPath, L"\\nul")) {
            continue;
        }

        ParameterizeName(wzPath, ARRAYSIZE(wzPath), pInfo);

        if (pInfo->m_fDirectory) {
            Print("<t:File mkdir=\"true\">%ls</t:File>\n", wzPath);
            continue;
        }

        if (!fRead && !fWrite && !fDelete && !fCleanup) {
            // Discard do "none" files.
            continue;
        }

        if (pInfo->m_pbContent == NULL ||
            pInfo->m_fDelete ||
            pInfo->m_fCleanup ||
            pInfo->m_fWrite) {

            Print("<t:File%s%s%s%s%s>%ls</t:File>\n",
                  fRead ? " read=\"true\"" : "",
                  fWrite ? " write=\"true\"" : "",
                  fDelete ? " delete=\"true\"" : "",
                  fCleanup ? " cleanup=\"true\"" : "",
                  fAppend ? " append=\"true\"" : "",
                  // size=\"%d\" pInfo->m_cbContent,
                  wzPath);
        }
        else if ((pInfo->m_pbContent)[0] == 0xff && (pInfo->m_pbContent)[1] == 0xfe) {
            // Unicode
            Print("<t:File%s%s%s%s%s>%ls<t:Data>%le</t:Data></t:File>\n",
                  fRead ? " read=\"true\"" : "",
                  fWrite ? " write=\"true\"" : "",
                  fDelete ? " delete=\"true\"" : "",
                  fCleanup ? " cleanup=\"true\"" : "",
                  fAppend ? " append=\"true\"" : "",
                  //  size=\"%d\" pInfo->m_cbContent,
                  wzPath,
                  RemoveReturns((PWCHAR)pInfo->m_pbContent));
        }
        else {
            // Ascii
            Print("<t:File%s%s%s%s%s>%ls<t:Data>%he</t:Data></t:File>\n",
                  fRead ? " read=\"true\"" : "",
                  fWrite ? " write=\"true\"" : "",
                  fDelete ? " delete=\"true\"" : "",
                  fCleanup ? " cleanup=\"true\"" : "",
                  fAppend ? " append=\"true\"" : "",
                  //  size=\"%d\" pInfo->m_cbContent,
                  wzPath,
                  RemoveReturns((PCHAR)pInfo->m_pbContent));
        }

        if (pInfo->m_pbContent != NULL) {
            GlobalFree((HGLOBAL)pInfo->m_pbContent);
            pInfo->m_pbContent = NULL;
        }
    }
    GlobalFree((HGLOBAL)pSorted);

    Tblog("</t:Files>\n");

    LockRelease();
}


//////////////////////////////////////////////////////////////////////////////
//
class OpenFiles
{
  private:
    struct SLOT
    {
        HANDLE      m_hHandle;
        FileInfo *  m_pFile;
        ProcInfo *  m_pProc;
    };

  private:
    static CRITICAL_SECTION s_csLock;
    static DWORD            s_nHandles;
    static SLOT             s_rHandles[4049];

  private:
    static SLOT& HashToSlot(HANDLE handle)
    {
        return s_rHandles[((DWORD_PTR)handle) % ARRAYSIZE(s_rHandles)];
    }

    static VOID LockAcquire()
    {
        EnterCriticalSection(&s_csLock);
    }

    static VOID LockRelease()
    {
        LeaveCriticalSection(&s_csLock);
    }

  public:
    static VOID Initialize();

    static VOID SetWrite(HANDLE hFile, DWORD cbData)
    {
        SLOT& slot = HashToSlot(hFile);
        if (slot.m_hHandle == hFile) {
            slot.m_pFile->m_fWrite = TRUE;
            slot.m_pFile->m_cbWrite += cbData;
        }
    }

    static VOID SetRead(HANDLE hFile, DWORD cbData)
    {
        SLOT& slot = HashToSlot(hFile);
        if (slot.m_hHandle == hFile) {
            slot.m_pFile->m_fRead = TRUE;
            slot.m_pFile->m_cbRead += cbData;
        }
    }

    static BOOL Forget(HANDLE handle);
    static BOOL Remember(HANDLE hFile, FileInfo *pInfo);
    static BOOL Remember(HANDLE hProc, ProcInfo *pInfo);
    static FileInfo * RecallFile(HANDLE hFile);
    static ProcInfo * RecallProc(HANDLE hProc);
};

CRITICAL_SECTION    OpenFiles::s_csLock;  // Guards access to OpenFile stuctures.
DWORD               OpenFiles::s_nHandles = 0;
OpenFiles::SLOT     OpenFiles::s_rHandles[4049];

VOID OpenFiles::Initialize()
{
    InitializeCriticalSection(&s_csLock);
    for (DWORD n = 0; n < ARRAYSIZE(s_rHandles); n++) {
        s_rHandles[n].m_hHandle = INVALID_HANDLE_VALUE;
        s_rHandles[n].m_pFile = NULL;
        s_rHandles[n].m_pProc = NULL;
    }
}

BOOL OpenFiles::Forget(HANDLE handle)
{
    LockAcquire();
    OpenFiles::SLOT& slot = HashToSlot(handle);

    if (slot.m_hHandle == handle    ) {
        slot.m_hHandle = INVALID_HANDLE_VALUE;
        slot.m_pFile = NULL;
        slot.m_pProc = NULL;
        s_nHandles--;
    }
    LockRelease();
    return FALSE;
}

BOOL OpenFiles::Remember(HANDLE hFile, FileInfo *pFile)
{
    LockAcquire();

    OpenFiles::SLOT& slot = HashToSlot(hFile);
    if (slot.m_hHandle != hFile && slot.m_hHandle != INVALID_HANDLE_VALUE) {
        // hash collision
        DEBUG_BREAK();
    }

    slot.m_hHandle = hFile;
    slot.m_pFile = pFile;
    slot.m_pProc = NULL;
    s_nHandles++;

    LockRelease();

    return TRUE;
}

BOOL OpenFiles::Remember(HANDLE hProc, ProcInfo *pProc)
{
    LockAcquire();

    OpenFiles::SLOT& slot = HashToSlot(hProc);
    if (slot.m_hHandle != hProc && slot.m_hHandle != INVALID_HANDLE_VALUE) {
        // hash collision
        DEBUG_BREAK();
    }

    slot.m_hHandle = hProc;
    slot.m_pProc = pProc;
    slot.m_pFile = NULL;
    s_nHandles++;

    LockRelease();

    return TRUE;
}

FileInfo * OpenFiles::RecallFile(HANDLE hFile)
{
    LockAcquire();

    OpenFiles::SLOT& slot = HashToSlot(hFile);

    if (slot.m_hHandle == hFile) {
        LockRelease();
        return slot.m_pFile;
    }
    LockRelease();
    return NULL;
}

ProcInfo * OpenFiles::RecallProc(HANDLE hProc)
{
    LockAcquire();

    OpenFiles::SLOT& slot = HashToSlot(hProc);

    if (slot.m_hHandle == hProc) {
        LockRelease();
        return slot.m_pProc;
    }
    LockRelease();
    return NULL;
}

///////////////////////////////////////////////////////////////////// VPrintf.
//
// Completely side-effect free printf replacement (but no FP numbers).
//
static PCHAR do_base(PCHAR pszOut, UINT64 nValue, UINT nBase, PCSTR pszDigits)
{
    CHAR szTmp[96];
    int nDigit = sizeof(szTmp)-2;
    for (; nDigit >= 0; nDigit--) {
        szTmp[nDigit] = pszDigits[nValue % nBase];
        nValue /= nBase;
    }
    for (nDigit = 0; nDigit < sizeof(szTmp) - 2 && szTmp[nDigit] == '0'; nDigit++) {
        // skip leading zeros.
    }
    for (; nDigit < sizeof(szTmp) - 1; nDigit++) {
        *pszOut++ = szTmp[nDigit];
    }
    *pszOut = '\0';
    return pszOut;
}

static PCHAR do_str(PCHAR pszOut, PCHAR pszEnd, PCSTR pszIn)
{
    while (*pszIn && pszOut < pszEnd) {
        *pszOut++ = *pszIn++;
    }
    *pszOut = '\0';
    return pszOut;
}

static PCHAR do_wstr(PCHAR pszOut, PCHAR pszEnd, PCWSTR pszIn)
{
    while (*pszIn && pszOut < pszEnd) {
        *pszOut++ = (CHAR)*pszIn++;
    }
    *pszOut = '\0';
    return pszOut;
}

static PCHAR do_estr(PCHAR pszOut, PCHAR pszEnd, PCSTR pszIn)
{
    while (*pszIn && pszOut < pszEnd) {
        if (*pszIn == '<') {
            if (pszOut + 4 > pszEnd) {
                break;
            }
            pszIn++;
            *pszOut++ = '&';
            *pszOut++ = 'l';
            *pszOut++ = 't';
            *pszOut++ = ';';
        }
        else if (*pszIn == '>') {
            if (pszOut + 4 > pszEnd) {
                break;
            }
            pszIn++;
            *pszOut++ = '&';
            *pszOut++ = 'g';
            *pszOut++ = 't';
            *pszOut++ = ';';
        }
        else if (*pszIn == '&') {
            if (pszOut + 5 > pszEnd) {
                break;
            }
            pszIn++;
            *pszOut++ = '&';
            *pszOut++ = 'a';
            *pszOut++ = 'm';
            *pszOut++ = 'p';
            *pszOut++ = ';';
        }
        else if (*pszIn == '\"') {
            if (pszOut + 6 > pszEnd) {
                break;
            }
            pszIn++;
            *pszOut++ = '&';
            *pszOut++ = 'q';
            *pszOut++ = 'u';
            *pszOut++ = 'o';
            *pszOut++ = 't';
            *pszOut++ = ';';
        }
        else if (*pszIn == '\'') {
            if (pszOut + 6 > pszEnd) {
                break;
            }
            pszIn++;
            *pszOut++ = '&';
            *pszOut++ = 'a';
            *pszOut++ = 'p';
            *pszOut++ = 'o';
            *pszOut++ = 's';
            *pszOut++ = ';';
        }
        else if (*pszIn  < ' ') {
            BYTE c = (BYTE)(*pszIn++);
            if (c < 10 && pszOut + 4 <= pszEnd) {
                *pszOut++ = '&';
                *pszOut++ = '#';
                *pszOut++ = '0' + (c % 10);
                *pszOut++ = ';';
            }
            else if (c < 100 && pszOut + 5 <= pszEnd) {
                *pszOut++ = '&';
                *pszOut++ = '#';
                *pszOut++ = '0' + ((c / 10) % 10);
                *pszOut++ = '0' + (c % 10);
                *pszOut++ = ';';
            }
            else if (c < 1000 && pszOut + 6 <= pszEnd) {
                *pszOut++ = '&';
                *pszOut++ = '#';
                *pszOut++ = '0' + ((c / 100) % 10);
                *pszOut++ = '0' + ((c / 10) % 10);
                *pszOut++ = '0' + (c % 10);
                *pszOut++ = ';';
            }
            else {
                break;
            }
        }
        else {
            *pszOut++ = *pszIn++;
        }
    }
    *pszOut = '\0';
    return pszOut;
}

static PCHAR do_ewstr(PCHAR pszOut, PCHAR pszEnd, PCWSTR pszIn)
{
    while (*pszIn && pszOut < pszEnd) {
        if (*pszIn == '<') {
            if (pszOut + 4 > pszEnd) {
                break;
            }
            pszIn++;
            *pszOut++ = '&';
            *pszOut++ = 'l';
            *pszOut++ = 't';
            *pszOut++ = ';';
        }
        else if (*pszIn == '>') {
            if (pszOut + 4 > pszEnd) {
                break;
            }
            pszIn++;
            *pszOut++ = '&';
            *pszOut++ = 'g';
            *pszOut++ = 't';
            *pszOut++ = ';';
        }
        else if (*pszIn == '&') {
            if (pszOut + 5 > pszEnd) {
                break;
            }
            pszIn++;
            *pszOut++ = '&';
            *pszOut++ = 'a';
            *pszOut++ = 'm';
            *pszOut++ = 'p';
            *pszOut++ = ';';
        }
        else if (*pszIn == '\"') {
            if (pszOut + 6 > pszEnd) {
                break;
            }
            pszIn++;
            *pszOut++ = '&';
            *pszOut++ = 'q';
            *pszOut++ = 'u';
            *pszOut++ = 'o';
            *pszOut++ = 't';
            *pszOut++ = ';';
        }
        else if (*pszIn == '\'') {
            if (pszOut + 6 > pszEnd) {
                break;
            }
            pszIn++;
            *pszOut++ = '&';
            *pszOut++ = 'a';
            *pszOut++ = 'p';
            *pszOut++ = 'o';
            *pszOut++ = 's';
            *pszOut++ = ';';
        }
        else if (*pszIn  < ' ' || *pszIn > 127) {
            WCHAR c = *pszIn++;
            if (c < 10 && pszOut + 4 <= pszEnd) {
                *pszOut++ = '&';
                *pszOut++ = '#';
                *pszOut++ = '0' + (CHAR)(c % 10);
                *pszOut++ = ';';
            }
            else if (c < 100 && pszOut + 5 <= pszEnd) {
                *pszOut++ = '&';
                *pszOut++ = '#';
                *pszOut++ = '0' + (CHAR)((c / 10) % 10);
                *pszOut++ = '0' + (CHAR)(c % 10);
                *pszOut++ = ';';
            }
            else if (c < 1000 && pszOut + 6 <= pszEnd) {
                *pszOut++ = '&';
                *pszOut++ = '#';
                *pszOut++ = '0' + (CHAR)((c / 100) % 10);
                *pszOut++ = '0' + (CHAR)((c / 10) % 10);
                *pszOut++ = '0' + (CHAR)(c % 10);
                *pszOut++ = ';';
            }
            else {
                break;
            }
        }
        else {
            *pszOut++ = (CHAR)*pszIn++;
        }
    }
    *pszOut = '\0';
    return pszOut;
}

#if _MSC_VER >= 1900
#pragma warning(push)
#pragma warning(disable:4456) // declaration hides previous local declaration
#endif

VOID VSafePrintf(PCSTR pszMsg, va_list args, PCHAR pszBuffer, LONG cbBuffer)
{
    PCHAR pszOut = pszBuffer;
    PCHAR pszEnd = pszBuffer + cbBuffer - 1;
    pszBuffer[0] = '\0';

    __try {
        while (*pszMsg && pszOut < pszEnd) {
            if (*pszMsg == '%') {
                CHAR szHead[4] = "";
                INT nLen;
                INT nWidth = 0;
                INT nPrecision = 0;
                BOOL fLeft = FALSE;
                BOOL fPositive = FALSE;
                BOOL fPound = FALSE;
                BOOL fBlank = FALSE;
                BOOL fZero = FALSE;
                BOOL fDigit = FALSE;
                BOOL fSmall = FALSE;
                BOOL fLarge = FALSE;
                BOOL f64Bit = FALSE;
                PCSTR pszArg = pszMsg;

                pszMsg++;

                for (; (*pszMsg == '-' ||
                        *pszMsg == '+' ||
                        *pszMsg == '#' ||
                        *pszMsg == ' ' ||
                        *pszMsg == '0'); pszMsg++) {
                    switch (*pszMsg) {
                      case '-': fLeft = TRUE; break;
                      case '+': fPositive = TRUE; break;
                      case '#': fPound = TRUE; break;
                      case ' ': fBlank = TRUE; break;
                      case '0': fZero = TRUE; break;
                    }
                }

                if (*pszMsg == '*') {
                    nWidth = va_arg(args, INT);
                    pszMsg++;
                }
                else {
                    while (*pszMsg >= '0' && *pszMsg <= '9') {
                        nWidth = nWidth * 10 + (*pszMsg++ - '0');
                    }
                }
                if (*pszMsg == '.') {
                    pszMsg++;
                    fDigit = TRUE;
                    if (*pszMsg == '*') {
                        nPrecision = va_arg(args, INT);
                        pszMsg++;
                    }
                    else {
                        while (*pszMsg >= '0' && *pszMsg <= '9') {
                            nPrecision = nPrecision * 10 + (*pszMsg++ - '0');
                        }
                    }
                }

                if (*pszMsg == 'h') {
                    fSmall = TRUE;
                    pszMsg++;
                }
                else if (*pszMsg == 'l') {
                    fLarge = TRUE;
                    pszMsg++;
                }
                else if (*pszMsg == 'I' && pszMsg[1] == '6' && pszMsg[2] == '4') {
                    f64Bit = TRUE;
                    pszMsg += 3;
                }

                if (*pszMsg == 's' || *pszMsg == 'e' || *pszMsg == 'c') {
                    // We ignore the length, precision, and alignment
                    // to avoid using a temporary buffer.

                    if (*pszMsg == 's') { // [GalenH] need to not use temp.
                        PVOID pvData = va_arg(args, PVOID);

                        pszMsg++;

                        if (fSmall) {
                            fLarge = FALSE;
                        }

                        __try {
                            if (pvData == NULL) {
                                pszOut = do_str(pszOut, pszEnd, "-NULL-");
                            }
                            else if (fLarge) {
                                pszOut = do_wstr(pszOut, pszEnd, (PWCHAR)pvData);
                            }
                            else {
                                pszOut = do_str(pszOut, pszEnd, (PCHAR)pvData);
                            }
                        } __except(EXCEPTION_EXECUTE_HANDLER) {
                            pszOut = do_str(pszOut, pszEnd, "-");
                            pszOut = do_base(pszOut, (UINT64)pvData, 16,
                                             "0123456789ABCDEF");
                            pszOut = do_str(pszOut, pszEnd, "-");
                        }
                    }
                    else if (*pszMsg == 'e')    {   // Escape the string.
                        PVOID pvData = va_arg(args, PVOID);

                        pszMsg++;

                        if (fSmall) {
                            fLarge = FALSE;
                        }

                        __try {
                            if (pvData == NULL) {
                                pszOut = do_str(pszOut, pszEnd, "-NULL-");
                            }
                            else if (fLarge) {
                                pszOut = do_ewstr(pszOut, pszEnd, (PWCHAR)pvData);
                            }
                            else {
                                pszOut = do_estr(pszOut, pszEnd, (PCHAR)pvData);
                            }
                        } __except(EXCEPTION_EXECUTE_HANDLER) {
                            pszOut = do_str(pszOut, pszEnd, "-");
                            pszOut = do_base(pszOut, (UINT64)pvData, 16,
                                             "0123456789ABCDEF");
                            pszOut = do_str(pszOut, pszEnd, "-");
                        }
                    }
                    else {
                        CHAR szTemp[2];
                        pszMsg++;

                        szTemp[0] = (CHAR)va_arg(args, INT);
                        szTemp[1] = '\0';
                        pszOut = do_str(pszOut, pszEnd, szTemp);
                    }
                }
                else if (*pszMsg == 'd' || *pszMsg == 'i' || *pszMsg == 'o' ||
                         *pszMsg == 'x' || *pszMsg == 'X' || *pszMsg == 'b' ||
                         *pszMsg == 'u') {
                    CHAR szTemp[128];
                    UINT64 value;
                    if (f64Bit) {
                        value = va_arg(args, UINT64);
                    }
                    else {
                        value = va_arg(args, UINT);
                    }

                    if (*pszMsg == 'x') {
                        pszMsg++;
                        nLen = (int)(do_base(szTemp, value, 16, "0123456789abcdef") - szTemp);
                        if (fPound && value) {
                            do_str(szHead, szHead + sizeof(szHead) - 1, "0x");
                        }
                    }
                    else if (*pszMsg == 'X') {
                        pszMsg++;
                        nLen = (int)(do_base(szTemp, value, 16, "0123456789ABCDEF") - szTemp);
                        if (fPound && value) {
                            do_str(szHead, szHead + sizeof(szHead) - 1, "0X");
                        }
                    }
                    else if (*pszMsg == 'd') {
                        pszMsg++;
                        if ((INT64)value < 0) {
                            value = -(INT64)value;
                            do_str(szHead, szHead + sizeof(szHead) - 1, "-");
                        }
                        else if (fPositive) {
                            if (value > 0) {
                                do_str(szHead, szHead + sizeof(szHead) - 1, "+");
                            }
                        }
                        else if (fBlank) {
                            if (value > 0) {
                                do_str(szHead, szHead + sizeof(szHead) - 1, " ");
                            }
                        }
                        nLen = (int)(do_base(szTemp, value, 10, "0123456789") - szTemp);
                        nPrecision = 0;
                    }
                    else if (*pszMsg == 'u') {
                        pszMsg++;
                        nLen = (int)(do_base(szTemp, value, 10, "0123456789") - szTemp);
                        nPrecision = 0;
                    }
                    else if (*pszMsg == 'o') {
                        pszMsg++;
                        nLen = (int)(do_base(szTemp, value, 8, "01234567") - szTemp);
                        nPrecision = 0;

                        if (fPound && value) {
                            do_str(szHead, szHead + sizeof(szHead) - 1, "0");
                        }
                    }
                    else if (*pszMsg == 'b') {
                        pszMsg++;
                        nLen = (int)(do_base(szTemp, value, 2, "01") - szTemp);
                        nPrecision = 0;

                        if (fPound && value) {
                            do_str(szHead, szHead + sizeof(szHead) - 1, "0b");
                        }
                    }
                    else {
                        pszMsg++;
                        if ((INT64)value < 0) {
                            value = -(INT64)value;
                            do_str(szHead, szHead + sizeof(szHead) - 1, "-");
                        }
                        else if (fPositive) {
                            if (value > 0) {
                                do_str(szHead, szHead + sizeof(szHead) - 1, "+");
                            }
                        }
                        else if (fBlank) {
                            if (value > 0) {
                                do_str(szHead, szHead + sizeof(szHead) - 1, " ");
                            }
                        }
                        nLen = (int)(do_base(szTemp, value, 10, "0123456789") - szTemp);
                        nPrecision = 0;
                    }

                    INT nHead = 0;
                    for (; szHead[nHead]; nHead++) {
                        // Count characters in head string.
                    }

                    if (fLeft) {
                        if (nHead) {
                            pszOut = do_str(pszOut, pszEnd, szHead);
                            nLen += nHead;
                        }
                        pszOut = do_str(pszOut, pszEnd, szTemp);
                        for (; nLen < nWidth && pszOut < pszEnd; nLen++) {
                            *pszOut++ = ' ';
                        }
                    }
                    else if (fZero) {
                        if (nHead) {
                            pszOut = do_str(pszOut, pszEnd, szHead);
                            nLen += nHead;
                        }
                        for (; nLen < nWidth && pszOut < pszEnd; nLen++) {
                            *pszOut++ = '0';
                        }
                        pszOut = do_str(pszOut, pszEnd, szTemp);
                    }
                    else {
                        if (nHead) {
                            nLen += nHead;
                        }
                        for (; nLen < nWidth && pszOut < pszEnd; nLen++) {
                            *pszOut++ = ' ';
                        }
                        if (nHead) {
                            pszOut = do_str(pszOut, pszEnd, szHead);
                        }
                        pszOut = do_str(pszOut, pszEnd, szTemp);
                    }
                }
                else if (*pszMsg == 'p') {
                    CHAR szTemp[64];
                    ULONG_PTR value;
                    value = va_arg(args, ULONG_PTR);

                    if (*pszMsg == 'p') {
                        pszMsg++;
                        nLen = (int)(do_base(szTemp, (UINT64)value, 16, "0123456789abcdef") - szTemp);
                        if (fPound && value) {
                            do_str(szHead, szHead + sizeof(szHead) - 1, "0x");
                        }
                    }
                    else {
                        pszMsg++;
                        nLen = (int)(do_base(szTemp, (UINT64)value, 16, "0123456789ABCDEF") - szTemp);
                        if (fPound && value) {
                            do_str(szHead, szHead + sizeof(szHead) - 1, "0x");
                        }
                    }

                    INT nHead = 0;
                    for (; szHead[nHead]; nHead++) {
                        // Count characters in head string.
                    }

                    if (nHead) {
                        pszOut = do_str(pszOut, pszEnd, szHead);
                        nLen += nHead;
                    }
                    for (; nLen < nWidth && pszOut < pszEnd; nLen++) {
                        *pszOut++ = '0';
                    }
                    pszOut = do_str(pszOut, pszEnd, szTemp);
                }
                else {
                    pszMsg++;
                    while (pszArg < pszMsg && pszOut < pszEnd) {
                        *pszOut++ = *pszArg++;
                    }
                }
            }
            else {
                if (pszOut < pszEnd) {
                    *pszOut++ = *pszMsg++;
                }
            }
        }
        *pszOut = '\0';
        pszBuffer[cbBuffer - 1] = '\0';
    } __except(EXCEPTION_EXECUTE_HANDLER) {
        PCHAR pszOut = pszBuffer;
        *pszOut = '\0';
        pszOut = do_str(pszOut, pszEnd, "-exception:");
        pszOut = do_base(pszOut, (UINT64)GetExceptionCode(), 10, "0123456789");
        pszOut = do_str(pszOut, pszEnd, "-");
    }
}

#if _MSC_VER >= 1900
#pragma warning(pop)
#endif

PCHAR SafePrintf(PCHAR pszBuffer, LONG cbBuffer, PCSTR pszMsg, ...)
{
    va_list args;
    va_start(args, pszMsg);
    VSafePrintf(pszMsg, args, pszBuffer, cbBuffer);
    va_end(args);

    while (*pszBuffer) {
        pszBuffer++;
    }
    return pszBuffer;
}

//////////////////////////////////////////////////////////////////////////////
//
BOOL TblogOpen()
{
    EnterCriticalSection(&s_csPipe);

    WCHAR wzPipe[256];
    StringCchPrintfW(wzPipe, ARRAYSIZE(wzPipe), L"%ls.%d", TBLOG_PIPE_NAMEW, s_nTraceProcessId);

    for (int retries = 0; retries < 10; retries++) {
        WaitNamedPipeW(wzPipe, 10000); // Wait up to 10 seconds for a pipe to appear.

        s_hPipe = Real_CreateFileW(wzPipe, GENERIC_WRITE, 0, NULL, OPEN_EXISTING, 0, NULL);
        if (s_hPipe != INVALID_HANDLE_VALUE) {
            DWORD dwMode = PIPE_READMODE_MESSAGE;
            if (SetNamedPipeHandleState(s_hPipe, &dwMode, NULL, NULL)) {
                LeaveCriticalSection(&s_csPipe);
                return TRUE;
            }
        }
    }

    LeaveCriticalSection(&s_csPipe);

    // Couldn't open pipe.
    DEBUG_BREAK();
    Real_ExitProcess(9990);
    return FALSE;
}

VOID TblogV(PCSTR pszMsgf, va_list args)
{
    if (s_hPipe == INVALID_HANDLE_VALUE) {
        return;
    }

    EnterCriticalSection(&s_csPipe);

    DWORD cbWritten = 0;

    PCHAR pszBuf = s_rMessage.szMessage;
    VSafePrintf(pszMsgf, args,
                pszBuf, (int)(s_rMessage.szMessage + sizeof(s_rMessage.szMessage) - pszBuf));

    PCHAR pszEnd = s_rMessage.szMessage;
    for (; *pszEnd; pszEnd++) {
        // no internal contents.
    }
    s_rMessage.nBytes = (DWORD)(pszEnd - ((PCSTR)&s_rMessage));

    // If the write fails, then we abort
    if (s_hPipe != INVALID_HANDLE_VALUE) {
        if (!Real_WriteFile(s_hPipe, &s_rMessage, s_rMessage.nBytes, &cbWritten, NULL)) {
            Real_ExitProcess(9991);
        }
    }

    LeaveCriticalSection(&s_csPipe);
}

VOID Tblog(PCSTR pszMsgf, ...)
{
    if (s_hPipe == INVALID_HANDLE_VALUE) {
        return;
    }

    va_list args;
    va_start(args, pszMsgf);
    TblogV(pszMsgf, args);
    va_end(args);
}

VOID TblogClose()
{
    EnterCriticalSection(&s_csPipe);

    if (s_hPipe != INVALID_HANDLE_VALUE) {
        DWORD cbWritten = 0;

        s_rMessage.nBytes = 0;

        Real_WriteFile(s_hPipe, &s_rMessage, 4, &cbWritten, NULL);
        FlushFileBuffers(s_hPipe);
        Real_CloseHandle(s_hPipe);
        s_hPipe = INVALID_HANDLE_VALUE;
    }

    LeaveCriticalSection(&s_csPipe);
}

/////////////////////////////////////////////////////////////
// Detours
//
static BOOL IsInherited(HANDLE hHandle)
{
    DWORD dwFlags;

    if (GetHandleInformation(hHandle, &dwFlags)) {
        return (dwFlags & HANDLE_FLAG_INHERIT) ? TRUE : FALSE;
    }
    return FALSE;
}

static void SaveStdHandleName(HANDLE hFile, PWCHAR pwzBuffer, BOOL *fAppend)
{
    pwzBuffer[0] = '\0';

    if ((hFile != INVALID_HANDLE_VALUE) && IsInherited(hFile)) {
        FileInfo * pInfo = OpenFiles::RecallFile(hFile);
        if (pInfo) {
            Copy(pwzBuffer, pInfo->m_pwzPath);
            if (pInfo->m_fAppend && fAppend != NULL) {
                *fAppend = TRUE;
            }
        }
    }
}

static void LoadStdHandleName(DWORD id, PCWSTR pwzBuffer, BOOL fAppend)
{
    HANDLE hFile = GetStdHandle(id);

    if ((hFile != INVALID_HANDLE_VALUE) && pwzBuffer[0] != '\0') {
        FileInfo *pInfo = FileNames::FindPartial(pwzBuffer);
        if (fAppend) {
            pInfo->m_fAppend = TRUE;
        }
        OpenFiles::Remember(hFile, pInfo);
    }
}

BOOL CreateProcessInternals(HANDLE hProcess, DWORD nProcessId, PCHAR pszId,
                            HANDLE hStdin, HANDLE hStdout, HANDLE hStderr)
{
    EnterCriticalSection(&s_csChildPayload);

    ProcInfo *proc = Procs::Create(hProcess, nProcessId);
    OpenFiles::Remember(hProcess, proc);

    ZeroMemory(&s_ChildPayload, sizeof(s_ChildPayload));
    CopyMemory(&s_ChildPayload, &s_Payload, sizeof(s_ChildPayload));

    s_ChildPayload.nParentProcessId = GetCurrentProcessId();
    s_ChildPayload.rGeneology[s_ChildPayload.nGeneology]
        = (DWORD)InterlockedIncrement(&s_nChildCnt);
    s_ChildPayload.nGeneology++;

    SaveStdHandleName(hStdin, s_ChildPayload.wzStdin, NULL);
    SaveStdHandleName(hStdout, s_ChildPayload.wzStdout, &s_ChildPayload.fStdoutAppend);
    SaveStdHandleName(hStderr, s_ChildPayload.wzStderr, &s_ChildPayload.fStderrAppend);

    DetourCopyPayloadToProcess(hProcess, s_guidTrace, &s_ChildPayload, sizeof(s_ChildPayload));

    for (DWORD i = 0; i < s_ChildPayload.nGeneology; i++) {
        pszId = SafePrintf(pszId, 16, "%d.", s_ChildPayload.rGeneology[i]);
    }
    *pszId = '\0';

    LeaveCriticalSection(&s_csChildPayload);

    return TRUE;
}

BOOL WINAPI Mine_CreateProcessW(LPCWSTR lpApplicationName,
                                LPWSTR lpCommandLine,
                                LPSECURITY_ATTRIBUTES lpProcessAttributes,
                                LPSECURITY_ATTRIBUTES lpThreadAttributes,
                                BOOL bInheritHandles,
                                DWORD dwCreationFlags,
                                LPVOID lpEnvironment,
                                LPCWSTR lpCurrentDirectory,
                                LPSTARTUPINFOW lpStartupInfo,
                                LPPROCESS_INFORMATION lpProcessInformation)
{
    EnterFunc();

    if (lpCommandLine == NULL) {
        lpCommandLine = (LPWSTR)lpApplicationName;
    }

    CHAR szProc[MAX_PATH];
    BOOL rv = 0;
    __try {
        LPPROCESS_INFORMATION ppi = lpProcessInformation;
        PROCESS_INFORMATION pi;
        if (ppi == NULL) {
            ppi = &pi;
        }

        rv = DetourCreateProcessWithDllExW(lpApplicationName,
                                           lpCommandLine,
                                           lpProcessAttributes,
                                           lpThreadAttributes,
                                           bInheritHandles,
                                           dwCreationFlags | CREATE_SUSPENDED,
                                           lpEnvironment,
                                           lpCurrentDirectory,
                                           lpStartupInfo,
                                           ppi,
                                           s_szDllPath,
                                           Real_CreateProcessW);

        if (rv) {
            HANDLE hStdin = GetStdHandle(STD_INPUT_HANDLE);
            HANDLE hStdout = GetStdHandle(STD_OUTPUT_HANDLE);
            HANDLE hStderr = GetStdHandle(STD_ERROR_HANDLE);

            if (lpStartupInfo != NULL && (lpStartupInfo->dwFlags & STARTF_USESTDHANDLES) != 0) {
                hStdin = lpStartupInfo->hStdInput;
                hStdout = lpStartupInfo->hStdOutput;
                hStderr = lpStartupInfo->hStdError;
            }
            CreateProcessInternals(ppi->hProcess, ppi->dwProcessId,
                                   szProc, hStdin, hStdout, hStderr);

            Print("<t:Child id=\"::%hs::\">\n", szProc);

            WCHAR wzPath[MAX_PATH];
            FileInfo *pInfo = NULL;
            if (lpApplicationName == NULL) {
                PWCHAR pwzDst = wzPath;
                PWCHAR pwzSrc = lpCommandLine;

                if (*pwzSrc == '\"') {
                    WCHAR cQuote = *pwzSrc++;

                    while (*pwzSrc && *pwzSrc != cQuote) {
                        *pwzDst++ = *pwzSrc++;
                    }
                    *pwzDst++ = '\0';
                }
                else {
                    while (*pwzSrc && *pwzSrc != ' ' && *pwzSrc != '\t') {
                        if (*pwzSrc == '\t') {
                            *pwzSrc = ' ';
                        }
                        *pwzDst++ = *pwzSrc++;
                    }
                    *pwzDst++ = '\0';
                }
                pInfo = FileNames::FindPartial(wzPath);
            }
            else {
                pInfo = FileNames::FindPartial(lpApplicationName);
            }

            Print("<t:Executable>%ls</t:Executable>\n",
                  FileNames::ParameterizeName(wzPath, ARRAYSIZE(wzPath), pInfo));
            Print("<t:Line>%le</t:Line>\n", lpCommandLine);
            Print("</t:Child>\n");

            if (pInfo) {
                pInfo->m_fAbsorbed = true;
            }

            if (!(dwCreationFlags & CREATE_SUSPENDED)) {
                ResumeThread(ppi->hThread);
            }

            if (ppi == &pi) {
                Real_CloseHandle(ppi->hThread);
                Real_CloseHandle(ppi->hProcess);
            }
        }
    } __finally {
        ExitFunc();
        if (!rv) {
            Print("<!-- Warning: CreateProcessW failed %d: %ls; %ls -->\n",
                  GetLastError(), lpApplicationName, lpCommandLine);
        }
    }
    return rv;
}

BOOL WINAPI Mine_CreateProcessA(LPCSTR lpApplicationName,
                                LPSTR lpCommandLine,
                                LPSECURITY_ATTRIBUTES lpProcessAttributes,
                                LPSECURITY_ATTRIBUTES lpThreadAttributes,
                                BOOL bInheritHandles,
                                DWORD dwCreationFlags,
                                LPVOID lpEnvironment,
                                LPCSTR lpCurrentDirectory,
                                LPSTARTUPINFOA lpStartupInfo,
                                LPPROCESS_INFORMATION lpProcessInformation)
{
    EnterFunc();

    if (lpCommandLine == NULL) {
        lpCommandLine = (LPSTR)lpApplicationName;
    }

    CHAR szProc[MAX_PATH];
    BOOL rv = 0;
    __try {
        LPPROCESS_INFORMATION ppi = lpProcessInformation;
        PROCESS_INFORMATION pi;
        if (ppi == NULL) {
            ppi = &pi;
        }

        rv = DetourCreateProcessWithDllExA(lpApplicationName,
                                           lpCommandLine,
                                           lpProcessAttributes,
                                           lpThreadAttributes,
                                           bInheritHandles,
                                           dwCreationFlags | CREATE_SUSPENDED,
                                           lpEnvironment,
                                           lpCurrentDirectory,
                                           lpStartupInfo,
                                           ppi,
                                           s_szDllPath,
                                           Real_CreateProcessA);

        if (rv) {
            HANDLE hStdin = GetStdHandle(STD_INPUT_HANDLE);
            HANDLE hStdout = GetStdHandle(STD_OUTPUT_HANDLE);
            HANDLE hStderr = GetStdHandle(STD_ERROR_HANDLE);

            if (lpStartupInfo != NULL && (lpStartupInfo->dwFlags & STARTF_USESTDHANDLES) != 0) {
                hStdin = lpStartupInfo->hStdInput;
                hStdout = lpStartupInfo->hStdOutput;
                hStderr = lpStartupInfo->hStdError;
            }
            CreateProcessInternals(ppi->hProcess, ppi->dwProcessId,
                                   szProc, hStdin, hStdout, hStderr);

            Print("<t:Child id=\"::%hs::\">\n", szProc);

            WCHAR wzPath[MAX_PATH];
            FileInfo *pInfo = NULL;
            if (lpApplicationName == NULL) {
                PCHAR pszDst = szProc;
                PCHAR pszSrc = lpCommandLine;

                if (*pszSrc == '\"') {
                    CHAR cQuote = *pszSrc++;

                    while (*pszSrc && *pszSrc != cQuote) {
                        *pszDst++ = *pszSrc++;
                    }
                    *pszDst++ = '\0';
                }
                else {
                    while (*pszSrc && *pszSrc != ' ' && *pszSrc != '\t') {
                        if (*pszSrc == '\t') {
                            *pszSrc = ' ';
                        }
                        *pszDst++ = *pszSrc++;
                    }
                    *pszDst++ = '\0';
                }
                pInfo = FileNames::FindPartial(szProc);
            }
            else {
                pInfo = FileNames::FindPartial(lpApplicationName);
            }

            Print("<t:Executable>%ls</t:Executable>\n",
                  FileNames::ParameterizeName(wzPath, ARRAYSIZE(wzPath), pInfo));
            Print("<t:Line>%he</t:Line>\n", lpCommandLine);
            Print("</t:Child>\n");

            if (pInfo) {
                pInfo->m_fAbsorbed = true;
            }

            if (!(dwCreationFlags & CREATE_SUSPENDED)) {
                ResumeThread(ppi->hThread);
            }
            if (ppi == &pi) {
                Real_CloseHandle(ppi->hThread);
                Real_CloseHandle(ppi->hProcess);
            }
        }
    } __finally {
        ExitFunc();
        if (!rv) {
            Print("<!-- Warning: CreateProcessA failed %d: %hs; %hs -->\n",
                  GetLastError(), lpApplicationName, lpCommandLine);
        }
    }
    return rv;
}

//
//////////////////////////////////////////////////////////////////////////////

BOOL WINAPI Mine_CopyFileExA(LPCSTR a0,
                             LPCSTR a1,
                             LPPROGRESS_ROUTINE a2,
                             LPVOID a3,
                             LPBOOL a4,
                             DWORD a5)
{
    EnterFunc();

    BOOL rv = 0;
    __try {
        rv = Real_CopyFileExA(a0, a1, a2, a3, a4, a5);
    } __finally {
        ExitFunc();
        if (rv) {
#if 0
            Print("<!-- CopyFileExA %he to %he -->\n", a0, a1);
#endif
            NoteRead(a0);
            NoteWrite(a1);
        }
    };
    return rv;
}

BOOL WINAPI Mine_CopyFileExW(LPCWSTR a0,
                             LPCWSTR a1,
                             LPPROGRESS_ROUTINE a2,
                             LPVOID a3,
                             LPBOOL a4,
                             DWORD a5)
{
    EnterFunc();

    BOOL rv = 0;
    __try {
#if 0
        Print("\n");
        Print("<!-- CopyFileExW %le to %le before -->\n", a0, a1);
#endif
        rv = Real_CopyFileExW(a0, a1, a2, a3, a4, a5);
    } __finally {
        ExitFunc();
        if (rv) {
#if 0
            Print("<!-- CopyFileExW %le to %le -->\n", a0, a1);
#endif
            NoteRead(a0);
            NoteWrite(a1);
        }
    };
    return rv;
}

BOOL WINAPI Mine_PrivCopyFileExW(LPCWSTR a0,
                                 LPCWSTR a1,
                                 LPPROGRESS_ROUTINE a2,
                                 LPVOID a3,
                                 LPBOOL a4,
                                 DWORD a5)
{
    EnterFunc();

    BOOL rv = 0;
    __try {
        rv = Real_PrivCopyFileExW(a0, a1, a2, a3, a4, a5);
    } __finally {
        ExitFunc();
        if (rv) {
#if 0
            Print("<!-- PrivCopyFileExW %le to %le -->\n", a0, a1);
#endif
            NoteRead(a0);
            NoteWrite(a1);
        }
    };
    return rv;
}

BOOL WINAPI Mine_CreateHardLinkA(LPCSTR a0,
                                 LPCSTR a1,
                                 LPSECURITY_ATTRIBUTES a2)
{
    EnterFunc();

    BOOL rv = 0;
    __try {
        rv = Real_CreateHardLinkA(a0, a1, a2);
    } __finally {
        ExitFunc();
        if (rv) {
#if 0
            Print("<!-- CreateHardLinkA %he to %he -->\n", a0, a1);
#endif
            NoteRead(a1);
            NoteWrite(a0);
        }
    };
    return rv;
}

BOOL WINAPI Mine_CreateHardLinkW(LPCWSTR a0,
                                 LPCWSTR a1,
                                 LPSECURITY_ATTRIBUTES a2)
{
    EnterFunc();

    BOOL rv = 0;
    __try {
        rv = Real_CreateHardLinkW(a0, a1, a2);
    } __finally {
        ExitFunc();
        if (rv) {
#if 0
            Print("<!-- CreateHardLinkW %le to %le -->\n", a0, a1);
#endif
            NoteRead(a1);
            NoteWrite(a0);
        }
    };
    return rv;
}

BOOL WINAPI Mine_CloseHandle(HANDLE a0)
{
    /*int nIndent =*/ EnterFunc();

    BOOL rv = 0;
    __try {
        ProcInfo * pProc = OpenFiles::RecallProc(a0);
        if (pProc != NULL) {
            Procs::Close(pProc->m_hProc);
        }

        FileInfo * pFile = OpenFiles::RecallFile(a0);
        if (pFile != NULL) {
            DWORD dwErr = GetLastError();
            pFile->m_cbContent = GetFileSize(a0, NULL);
            if (pFile->m_cbContent == INVALID_FILE_SIZE) {
                pFile->m_cbContent = 0;
            }

            if (pFile->m_fCantRead) {
                if (pFile->m_fRead) {
#if 0
                    Print("<!-- Warning: Removing read from %le -->\n", pFile->m_pwzPath);
#endif
                    pFile->m_fRead = FALSE;
                }
            }

            // Here we should think about reading the file contents as appropriate.
            if (pFile->m_fTemporaryPath && pFile->m_fRead && !pFile->m_fAbsorbed &&
                !pFile->m_fDelete && !pFile->m_fCleanup && !pFile->m_fWrite &&
                pFile->m_pbContent == NULL &&
                pFile->m_cbContent < 16384) {

                pFile->m_pbContent = LoadFile(a0, pFile->m_cbContent);
            }

            SetLastError(dwErr);
        }
        rv = Real_CloseHandle(a0);
    } __finally {
        ExitFunc();
        if (rv /* && nIndent == 0*/) {
            OpenFiles::Forget(a0);
        }
    };
    return rv;
}

BOOL WINAPI Mine_DuplicateHandle(HANDLE hSourceProcessHandle,
                                 HANDLE hSourceHandle,
                                 HANDLE hTargetProcessHandle,
                                 LPHANDLE lpTargetHandle,
                                 DWORD dwDesiredAccess,
                                 BOOL bInheritHandle,
                                 DWORD dwOptions)
{
    HANDLE hTemp = INVALID_HANDLE_VALUE;
    EnterFunc();

    BOOL rv = 0;
    __try {
        if (lpTargetHandle == NULL) {
            lpTargetHandle = &hTemp;
        }
        *lpTargetHandle = INVALID_HANDLE_VALUE;

        rv = Real_DuplicateHandle(hSourceProcessHandle,
                                  hSourceHandle,
                                  hTargetProcessHandle,
                                  lpTargetHandle,
                                  dwDesiredAccess,
                                  bInheritHandle,
                                  dwOptions);
    } __finally {
        ExitFunc();
        if (*lpTargetHandle != INVALID_HANDLE_VALUE) {
            FileInfo *pInfo = OpenFiles::RecallFile(hSourceHandle);
            if (pInfo) {
                OpenFiles::Remember(*lpTargetHandle, pInfo);
            }
        }
    };
    return rv;
}

static LONG s_nPipeCnt = 0;

BOOL WINAPI Mine_CreatePipe(PHANDLE hReadPipe,
                            PHANDLE hWritePipe,
                            LPSECURITY_ATTRIBUTES lpPipeAttributes,
                            DWORD nSize)
{
    HANDLE hRead = INVALID_HANDLE_VALUE;
    HANDLE hWrite = INVALID_HANDLE_VALUE;

    if (hReadPipe == NULL) {
        hReadPipe = &hRead;
    }
    if (hWritePipe == NULL) {
        hWritePipe = &hWrite;
    }

    /*int nIndent = */ EnterFunc();
    BOOL rv = 0;
    __try {
        rv = Real_CreatePipe(hReadPipe, hWritePipe, lpPipeAttributes, nSize);
    } __finally {
        ExitFunc();
        if (rv) {
            CHAR szPipe[128];

            SafePrintf(szPipe, ARRAYSIZE(szPipe), "\\\\.\\PIPE\\Temp.%d.%d",
                       GetCurrentProcessId(),
                       InterlockedIncrement(&s_nPipeCnt));

            FileInfo *pInfo = FileNames::FindPartial(szPipe);

            pInfo->m_fCleanup = TRUE;
            OpenFiles::Remember(*hReadPipe, pInfo);
            OpenFiles::Remember(*hWritePipe, pInfo);
        }
    };
    return rv;
}

BOOL WINAPI Mine_CreateDirectoryW(LPCWSTR a0,
                                  LPSECURITY_ATTRIBUTES a1)
{
    /* int nIndent = */ EnterFunc();
    BOOL rv = 0;
    __try {
        rv = Real_CreateDirectoryW(a0, a1);
    } __finally {
        ExitFunc();
        if (rv) {
            FileInfo *pInfo = FileNames::FindPartial(a0);
            pInfo->m_fDirectory = TRUE;
        }
    };
    return rv;
}

BOOL WINAPI Mine_CreateDirectoryExW(LPCWSTR a0,
                                    LPCWSTR a1,
                                    LPSECURITY_ATTRIBUTES a2)
{
    /* int nIndent = */ EnterFunc();
    BOOL rv = 0;
    __try {
        rv = Real_CreateDirectoryExW(a0, a1, a2);
    } __finally {
        ExitFunc();
        if (rv) {
            FileInfo *pInfo = FileNames::FindPartial(a1);
            pInfo->m_fDirectory = TRUE;
        }
    };
    return rv;
}

HANDLE WINAPI Mine_CreateFileW(LPCWSTR a0,
                               DWORD access,
                               DWORD share,
                               LPSECURITY_ATTRIBUTES a3,
                               DWORD create,
                               DWORD flags,
                               HANDLE a6)
{
    /* int nIndent = */ EnterFunc();
    HANDLE rv = 0;
    __try {
        rv = Real_CreateFileW(a0, access, share, a3, create, flags, a6);
    } __finally {
        ExitFunc();
#if 0
            Print("<!-- CreateFileW(%le, ac=%08x, cr=%08x, fl=%08x -->\n",
                  a0,
                  access,
                  create,
                  flags);
#endif

        if (access != 0 && /* nIndent == 0 && */ rv != INVALID_HANDLE_VALUE) {

            FileInfo *pInfo = FileNames::FindPartial(a0);

            // FILE_FLAG_WRITE_THROUGH              0x80000000
            // FILE_FLAG_OVERLAPPED                 0x40000000
            // FILE_FLAG_NO_BUFFERING               0x20000000
            // FILE_FLAG_RANDOM_ACCESS              0x10000000
            // FILE_FLAG_SEQUENTIAL_SCAN            0x08000000
            // FILE_FLAG_DELETE_ON_CLOSE            0x04000000
            // FILE_FLAG_BACKUP_SEMANTICS           0x02000000
            // FILE_FLAG_POSIX_SEMANTICS            0x01000000
            // FILE_FLAG_OPEN_REPARSE_POINT         0x00200000
            // FILE_FLAG_OPEN_NO_RECALL             0x00100000
            // FILE_FLAG_FIRST_PIPE_INSTANCE        0x00080000
            // FILE_ATTRIBUTE_ENCRYPTED             0x00004000
            // FILE_ATTRIBUTE_NOT_CONTENT_INDEXED   0x00002000
            // FILE_ATTRIBUTE_OFFLINE               0x00001000
            // FILE_ATTRIBUTE_COMPRESSED            0x00000800
            // FILE_ATTRIBUTE_REPARSE_POINT         0x00000400
            // FILE_ATTRIBUTE_SPARSE_FILE           0x00000200
            // FILE_ATTRIBUTE_TEMPORARY             0x00000100
            // FILE_ATTRIBUTE_NORMAL                0x00000080
            // FILE_ATTRIBUTE_DEVICE                0x00000040
            // FILE_ATTRIBUTE_ARCHIVE               0x00000020
            // FILE_ATTRIBUTE_DIRECTORY             0x00000010
            // FILE_ATTRIBUTE_SYSTEM                0x00000004
            // FILE_ATTRIBUTE_HIDDEN                0x00000002
            // FILE_ATTRIBUTE_READONLY              0x00000001

            // CREATE_NEW          1
            // CREATE_ALWAYS       2
            // OPEN_EXISTING       3
            // OPEN_ALWAYS         4
            // TRUNCATE_EXISTING   5

            if (create == CREATE_NEW ||
                create == CREATE_ALWAYS ||
                create == TRUNCATE_EXISTING) {

                if (!pInfo->m_fRead) {
                    pInfo->m_fCantRead = TRUE;
                }
            }
            else if (create == OPEN_EXISTING) {
            }
            else if (create == OPEN_ALWAYS) {
                // pInfo->m_fAppend = TRUE;    // !!!
            }

            if ((flags & FILE_FLAG_DELETE_ON_CLOSE)) {
                pInfo->m_fCleanup = TRUE;
            }

            OpenFiles::Remember(rv, pInfo);
        }
    };
    return rv;
}

HANDLE WINAPI Mine_CreateFileMappingW(HANDLE hFile,
                                      LPSECURITY_ATTRIBUTES a1,
                                      DWORD flProtect,
                                      DWORD a3,
                                      DWORD a4,
                                      LPCWSTR a5)
{
    /* int nIndent = */ EnterFunc();
    HANDLE rv = 0;
    __try {
        rv = Real_CreateFileMappingW(hFile, a1, flProtect, a3, a4, a5);
    } __finally {
        ExitFunc();
        if (rv != INVALID_HANDLE_VALUE) {

            FileInfo *pInfo = OpenFiles::RecallFile(hFile);

            if (pInfo != NULL) {
                switch (flProtect) {
                  case PAGE_READONLY:
                    pInfo->m_fRead = TRUE;
                    break;
                  case PAGE_READWRITE:
                    pInfo->m_fRead = TRUE;
                    pInfo->m_fWrite = TRUE;
                    break;
                  case PAGE_WRITECOPY:
                    pInfo->m_fRead = TRUE;
                    break;
                  case PAGE_EXECUTE_READ:
                    pInfo->m_fRead = TRUE;
                    break;
                  case PAGE_EXECUTE_READWRITE:
                    pInfo->m_fRead = TRUE;
                    pInfo->m_fWrite = TRUE;
                    break;
                }
            }
        }
    };
    return rv;
}

BOOL WINAPI Mine_DeleteFileW(LPCWSTR a0)
{
    EnterFunc();

    BOOL rv = 0;
    __try {
        rv = Real_DeleteFileW(a0);
    } __finally {
        ExitFunc();
#if 0
        Print("<!-- DeleteFileW(%le -->\n", a0);
#endif
        NoteDelete(a0);
    };
    return rv;
}

static VOID Dump(LPVOID pvData, DWORD cbData)
{
    CHAR szBuffer[128];
    PBYTE pbData = (PBYTE)pvData;

    for (DWORD i = 0; i < cbData; i += 16) {
        PCHAR psz = szBuffer;
        psz = SafePrintf(psz, (LONG)(szBuffer + ARRAYSIZE(szBuffer) - psz), "%4d: ", i);

        for (DWORD j = i; j < i + 16; j++) {
            if (j < cbData) {
                psz = SafePrintf(psz, (LONG)(szBuffer + ARRAYSIZE(szBuffer) - psz),
                                 "%02x", pbData[j]);
            }
            else {
                psz = SafePrintf(psz, (LONG)(szBuffer + ARRAYSIZE(szBuffer) - psz), "  ");
            }
        }

        for (DWORD j = i; j < i + 16; j++) {
            if (j < cbData) {
                if (pbData[j] >= ' ' && pbData[j] <= 127) {
                    psz = SafePrintf(psz, (LONG)(szBuffer + ARRAYSIZE(szBuffer) - psz),
                                     "%c", pbData[j]);
                }
                else {
                    psz = SafePrintf(psz, (LONG)(szBuffer + ARRAYSIZE(szBuffer) - psz), ".");
                }
            }
            else {
                psz = SafePrintf(psz, (LONG)(szBuffer + ARRAYSIZE(szBuffer) - psz), " ");
            }
        }
        Print("%s\n", szBuffer);
    }
}

BOOL WINAPI Mine_DeviceIoControl(HANDLE a0,
                                 DWORD a1,
                                 LPVOID a2,
                                 DWORD a3,
                                 LPVOID a4,
                                 DWORD a5,
                                 LPDWORD a6,
                                 LPOVERLAPPED a7)
{
    EnterFunc();
    DWORD d6 = 0;
    if (a6 == NULL) {
        a6 = &d6;

    }

    BOOL rv = 0;
    __try {
        rv = Real_DeviceIoControl(a0, a1, a2, a3, a4, a5, a6, a7);
    } __finally {
        ExitFunc();
        OpenFiles::SetRead(a0, 0);
        OpenFiles::SetWrite(a0, 0);
        if (rv && a1 != 0x390008 && a1 != 0x4d0008 && a1 != 0x6d0008) {
            FileInfo *pInfo = OpenFiles::RecallFile(a0);

            DWORD DeviceType    = (a1 & 0xffff0000) >> 16;
            DWORD Access        = (a1 & 0x0000c000) >> 14;
            DWORD Function      = (a1 & 0x00003ffc) >> 2;
            DWORD Method        = (a1 & 0x00000003) >> 0;

            if (pInfo) {
                Print("<!-- DeviceIoControl %x [dev=%x,acc=%x,fun=%x,mth=%x] on %ls! -->\n",
                      a1, DeviceType, Access, Function, Method, pInfo->m_pwzPath);
            }
            else {
                Print("<!-- DeviceIoControl %x [dev=%x,acc=%x,fun=%x,mth=%x,in=%d,out=%d/%d] on (%x)! -->\n",
                      a1, DeviceType, Access, Function, Method, a3, *a6, a5, a0);

                if (a3 > 0) {
                    Dump(a2, a3);
                }
                if (a5 > 0) {
                    Dump(a4, (*a6 < a5) ? *a6 : a5);
                }
            }
        }
    };
    return rv;
}

DWORD WINAPI Mine_GetFileAttributesW(LPCWSTR a0)
{
    EnterFunc();

    DWORD rv = 0;
    __try {
        rv = Real_GetFileAttributesW(a0);
    } __finally {
        ExitFunc();
    };
    return rv;
}

BOOL WINAPI Mine_MoveFileWithProgressW(LPCWSTR a0,
                                       LPCWSTR a1,
                                       LPPROGRESS_ROUTINE a2,
                                       LPVOID a3,
                                       DWORD a4)
{
    EnterFunc();

    BOOL rv = 0;
    __try {
        rv = Real_MoveFileWithProgressW(a0, a1, a2, a3, a4);
    } __finally {
        ExitFunc();
        if (rv) {
            NoteRead(a0);
            NoteWrite(a1);
        }
    };
    return rv;
}

BOOL WINAPI Mine_MoveFileA(LPCSTR a0,
                           LPCSTR a1)
{
    EnterFunc();

    BOOL rv = 0;
    __try {
        rv = Real_MoveFileA(a0, a1);
    } __finally {
        ExitFunc();
        if (rv) {
            NoteRead(a0);
            NoteCleanup(a0);
            NoteWrite(a1);
        }
    };
    return rv;
}

BOOL WINAPI Mine_MoveFileW(LPCWSTR a0,
                           LPCWSTR a1)
{
    EnterFunc();

    BOOL rv = 0;
    __try {
        rv = Real_MoveFileW(a0, a1);
    } __finally {
        ExitFunc();
        if (rv) {
            NoteRead(a0);
            NoteCleanup(a0);
            NoteWrite(a1);
        }
    };
    return rv;
}

BOOL WINAPI Mine_MoveFileExA(LPCSTR a0,
                             LPCSTR a1,
                             DWORD a2)
{
    EnterFunc();

    BOOL rv = 0;
    __try {
        rv = Real_MoveFileExA(a0, a1, a2);
    } __finally {
        ExitFunc();
        if (rv) {
            NoteRead(a0);
            NoteCleanup(a0);
            NoteWrite(a1);
        }
    };
    return rv;
}

BOOL WINAPI Mine_MoveFileExW(LPCWSTR a0,
                             LPCWSTR a1,
                             DWORD a2)
{
    EnterFunc();

    BOOL rv = 0;
    __try {
        rv = Real_MoveFileExW(a0, a1, a2);
    } __finally {
        ExitFunc();
        if (rv) {
            NoteRead(a0);
            NoteCleanup(a0);
            NoteWrite(a1);
        }
    };
    return rv;
}

void SetHandle(PCSTR pszName, HANDLE h)
{
#if 0
    FileInfo *pInfo = OpenFiles::RecallFile(h);

    if (pInfo != NULL) {
        Tblog("<!-- hset: %hs (%x) %ls -->\n", pszName, h, pInfo->m_pwzPath);
    }
    else {
        Tblog("<!-- hset: %hs (%x) ***Unknown*** -->\n", pszName, h);
    }
#else
    (void)pszName;
    (void)h;
#endif
}


BOOL WINAPI Mine_SetStdHandle(DWORD a0,
                              HANDLE a1)
{
    EnterFunc();

    BOOL rv = 0;
    __try {
        rv = Real_SetStdHandle(a0, a1);
        if (rv && a1 != 0) {
            switch (a0) {
              case STD_INPUT_HANDLE:
                SetHandle("stdin", a1);
                break;
              case STD_OUTPUT_HANDLE:
                SetHandle("stdout", a1);
                break;
              case STD_ERROR_HANDLE:
                SetHandle("stderr", a1);
                break;
            }
        }
    } __finally {
        ExitFunc();
    };
    return rv;
}

HMODULE WINAPI Mine_LoadLibraryA(LPCSTR a0)
{
    EnterFunc();

    HMODULE rv = 0;
    __try {
        rv = Real_LoadLibraryA(a0);
    } __finally {
        ExitFunc();
    };
    return rv;
}

HMODULE WINAPI Mine_LoadLibraryW(LPCWSTR a0)
{
    EnterFunc();

    HMODULE rv = 0;
    __try {
        rv = Real_LoadLibraryW(a0);
    } __finally {
        ExitFunc();
    };
    return rv;
}

HMODULE WINAPI Mine_LoadLibraryExA(LPCSTR a0,
                                   HANDLE a1,
                                   DWORD a2)
{
    EnterFunc();

    HMODULE rv = 0;
    __try {
        rv = Real_LoadLibraryExA(a0, a1, a2);
    } __finally {
        ExitFunc();
    };
    return rv;
}

HMODULE WINAPI Mine_LoadLibraryExW(LPCWSTR a0,
                                   HANDLE a1,
                                   DWORD a2)
{
    EnterFunc();

    HMODULE rv = 0;
    __try {
        rv = Real_LoadLibraryExW(a0, a1, a2);
    } __finally {
        ExitFunc();
    };
    return rv;
}

DWORD WINAPI Mine_SetFilePointer(HANDLE hFile,
                                 LONG lDistanceToMove,
                                 PLONG lpDistanceToMoveHigh,
                                 DWORD dwMoveMethod)
{
    EnterFunc();

    DWORD rv = 0;
    __try {
        rv = Real_SetFilePointer(hFile,
                                 lDistanceToMove,
                                 lpDistanceToMoveHigh,
                                 dwMoveMethod);
    } __finally {
        LONG high = 0;
        if (lpDistanceToMoveHigh == NULL) {
            lpDistanceToMoveHigh = &high;
        }

        FileInfo * pInfo = OpenFiles::RecallFile(hFile);
        if (pInfo != NULL) {
            if (dwMoveMethod == FILE_END && lDistanceToMove == 0xffffffff) {
#if 0
                Print("<!-- SetFilePointer(APPEND, %le) -->\n",
                      pInfo->m_pwzPath);
#endif
                pInfo->m_fAppend = TRUE;
            }
#if 0
            else if (dwMoveMethod == FILE_END) {
                Print("<!-- SetFilePointer(END:%08x:%08x, %le) -->\n",
                      (int)lDistanceToMove,
                      *lpDistanceToMoveHigh,
                      pInfo->m_pwzPath);
            }
            else if (dwMoveMethod == FILE_BEGIN) {
                Print("<!-- SetFilePointer(BEG:%08x:%08x, %le) -->\n",
                      (int)lDistanceToMove,
                      *lpDistanceToMoveHigh,
                      pInfo->m_pwzPath);
            }
            else if (dwMoveMethod == FILE_CURRENT) {
                Print("<!-- SetFilePointer(CUR:%08x:%08x, %le) -->\n",
                      (int)lDistanceToMove,
                      *lpDistanceToMoveHigh,
                      pInfo->m_pwzPath);
            }
#endif
        }
        ExitFunc();
    };
    return rv;
}

BOOL WINAPI Mine_SetFilePointerEx(HANDLE hFile,
                                  LARGE_INTEGER liDistanceToMove,
                                  PLARGE_INTEGER lpNewFilePointer,
                                  DWORD dwMoveMethod)
{
    EnterFunc();

    BOOL rv = 0;
    __try {
        rv = Real_SetFilePointerEx(hFile,
                                   liDistanceToMove,
                                   lpNewFilePointer,
                                   dwMoveMethod);
    } __finally {
#if 0
        FileInfo * pInfo = OpenFiles::RecallFile(hFile);
        if (pInfo != NULL) {
            if (dwMoveMethod == FILE_END) {
                Print("<!-- SetFilePointerEx(END:%I64d, %le) -->\n",
                      liDistanceToMove.QuadPart,
                      pInfo->m_pwzPath);
            }
            else if (dwMoveMethod == FILE_BEGIN) {
                Print("<!-- SetFilePointerEx(BEG:%I64d, %le) -->\n",
                      liDistanceToMove.QuadPart,
                      pInfo->m_pwzPath);
            }
            else if (dwMoveMethod == FILE_CURRENT) {
                Print("<!-- SetFilePointerEx(CUR:%I64d, %le) -->\n",
                      liDistanceToMove.QuadPart,
                      pInfo->m_pwzPath);
            }
        }
#endif
        ExitFunc();
    };
    return rv;
}

BOOL WINAPI Mine_ReadFile(HANDLE a0,
                          LPVOID a1,
                          DWORD a2,
                          LPDWORD a3,
                          LPOVERLAPPED a4)
{
    EnterFunc();

    BOOL rv = 0;
    __try {
        rv = Real_ReadFile(a0, a1, a2, a3, a4);
    } __finally {
        if (rv) {
            OpenFiles::SetRead(a0, a2);
        }
        ExitFunc();
    };
    return rv;
}

BOOL WINAPI Mine_ReadFileEx(HANDLE a0,
                            LPVOID a1,
                            DWORD a2,
                            LPOVERLAPPED a3,
                            LPOVERLAPPED_COMPLETION_ROUTINE a4)
{
    EnterFunc();

    BOOL rv = 0;
    __try {
        rv = Real_ReadFileEx(a0, a1, a2, a3, a4);
    } __finally {
        if (rv) {
            OpenFiles::SetRead(a0, a2);
        }
        ExitFunc();
    };
    return rv;
}

BOOL WINAPI Mine_WriteFile(HANDLE a0,
                           LPCVOID a1,
                           DWORD a2,
                           LPDWORD a3,
                           LPOVERLAPPED a4)
{
    EnterFunc();

    BOOL rv = 0;
    __try {
        rv = Real_WriteFile(a0, a1, a2, a3, a4);
    } __finally {
        OpenFiles::SetWrite(a0, a2);
        ExitFunc();
    };
    return rv;
}

BOOL WINAPI Mine_WriteFileEx(HANDLE a0,
                             LPCVOID a1,
                             DWORD a2,
                             LPOVERLAPPED a3,
                             LPOVERLAPPED_COMPLETION_ROUTINE a4)
{
    EnterFunc();

    BOOL rv = 0;
    __try {
        rv = Real_WriteFileEx(a0, a1, a2, a3, a4);
    } __finally {
        OpenFiles::SetWrite(a0, a2);
        ExitFunc();
    };
    return rv;
}

BOOL WINAPI Mine_WriteConsoleA(HANDLE a0,
                                  const VOID* a1,
                                  DWORD a2,
                                  LPDWORD a3,
                                  LPVOID a4)
{
    EnterFunc();

    BOOL rv = 0;
    __try {
        rv = Real_WriteConsoleA(a0, a1, a2, a3, a4);
    } __finally {
        OpenFiles::SetWrite(a0, a2);
        ExitFunc();
    };
    return rv;
}

BOOL WINAPI Mine_WriteConsoleW(HANDLE a0,
                                  const VOID* a1,
                                  DWORD a2,
                                  LPDWORD a3,
                                  LPVOID a4)
{
    EnterFunc();

    BOOL rv = 0;
    __try {
        rv = Real_WriteConsoleW(a0, a1, a2, a3, a4);
    } __finally {
        OpenFiles::SetWrite(a0, a2);
        ExitFunc();
    };
    return rv;
}

//////////////////////////////////////////////////////////////////////////////
//
DWORD WINAPI Mine_ExpandEnvironmentStringsA(PCSTR lpSrc, PCHAR lpDst, DWORD nSize)
{
    EnterFunc();
    DWORD rv = 0;
    __try {
        rv = Real_ExpandEnvironmentStringsA(lpSrc, lpDst, nSize);
    }
    __finally {
        if (rv > 0) {
#if 0
            Print("<!-- ExpandEnvironmentStringsA(%he) -->\n", lpSrc);
#endif
        }
        ExitFunc();
    };
    return rv;
}

DWORD WINAPI Mine_ExpandEnvironmentStringsW(PCWSTR lpSrc, PWCHAR lpDst, DWORD nSize)
{
    EnterFunc();
    DWORD rv = 0;
    __try {
        rv = Real_ExpandEnvironmentStringsW(lpSrc, lpDst, nSize);
    }
    __finally {
        if (rv > 0) {
#if 0
            Print("<!-- ExpandEnvironmentStringsW(%le) -->\n", lpSrc);
#endif
        }
        ExitFunc();
    };
    return rv;
}

DWORD WINAPI Mine_GetEnvironmentVariableA(PCSTR lpName, PCHAR lpBuffer, DWORD nSize)
{
    EnterFunc();
    DWORD rv = 0;
    __try {
        rv = Real_GetEnvironmentVariableA(lpName, lpBuffer, nSize);
        //        if (rv > 0 && rv < nSize && lpBuffer != NULL) {
        //            EnvVars::Used(lpName);
        //        }
    }
    __finally {
        EnvVars::Used(lpName);
        ExitFunc();
    };
    return rv;
}

DWORD WINAPI Mine_GetEnvironmentVariableW(PCWSTR lpName, PWCHAR lpBuffer, DWORD nSize)
{
    EnterFunc();
    DWORD rv = 0;
    __try {
        rv = Real_GetEnvironmentVariableW(lpName, lpBuffer, nSize);
        //        if (rv > 0 && rv < nSize && lpBuffer != NULL) {
        //            EnvVars::Used(lpName);
        //        }
    }
    __finally {
        EnvVars::Used(lpName);
        ExitFunc();
    };
    return rv;
}

PCWSTR CDECL Mine_wgetenv(PCWSTR var)
{
    EnterFunc();
    PCWSTR rv = 0;
    __try {
        rv = Real_wgetenv(var);
        //        if (rv != NULL) {
        //            EnvVars::Used(var);
        //        }
    }
    __finally {
        EnvVars::Used(var);
        ExitFunc();
    }
    return rv;
}

PCSTR CDECL Mine_getenv(PCSTR var)
{
    EnterFunc();
    PCSTR rv = 0;
    __try {
        rv = Real_getenv(var);
        //        if (rv) {
        //            EnvVars::Used(var);
        //        }
    }
    __finally {
        EnvVars::Used(var);
        ExitFunc();
    }
    return rv;
}

DWORD CDECL Mine_getenv_s(DWORD *pValue, PCHAR pBuffer, DWORD cBuffer, PCSTR varname)
{
    EnterFunc();
    DWORD rv = 0;
    __try {
        DWORD value;
        if (pValue == NULL) {
            pValue = &value;
        }
        rv = Real_getenv_s(pValue, pBuffer, cBuffer, varname);
        //        if (rv == 0 && *pValue > 0) {
        //            EnvVars::Used(varname);
        //        }
    }
    __finally {
        EnvVars::Used(varname);
        ExitFunc();
    }
    return rv;
}

DWORD CDECL Mine_wgetenv_s(DWORD *pValue, PWCHAR pBuffer, DWORD cBuffer, PCWSTR varname)
{
    EnterFunc();
    DWORD rv = 0;
    __try {
        DWORD value;
        if (pValue == NULL) {
            pValue = &value;
        }
        rv = Real_wgetenv_s(pValue, pBuffer, cBuffer, varname);
        //        if (rv == 0 && *pValue > 0) {
        //            EnvVars::Used(varname);
        //        }
    }
    __finally {
        EnvVars::Used(varname);
        ExitFunc();
    }
    return rv;
}

DWORD CDECL Mine_dupenv_s(PCHAR *ppBuffer, DWORD *pcBuffer, PCSTR varname)
{
    EnterFunc();
    DWORD rv = 0;
    __try {
        PCHAR pb;
        DWORD cb;
        if (ppBuffer == NULL) {
            ppBuffer = &pb;
        }
        if (pcBuffer == NULL) {
            pcBuffer = &cb;
        }
        rv = Real_dupenv_s(ppBuffer, pcBuffer, varname);
        //        if (rv == 0 && *pcBuffer > 0 && *ppBuffer != NULL) {
        //            EnvVars::Used(varname);
        //        }
    }
    __finally {
        EnvVars::Used(varname);
        ExitFunc();
    }
    return rv;
}

DWORD CDECL Mine_wdupenv_s(PWCHAR *ppBuffer, DWORD *pcBuffer, PCWSTR varname)
{
    EnterFunc();
    DWORD rv = 0;
    __try {
        PWCHAR pb;
        DWORD cb;
        if (ppBuffer == NULL) {
            ppBuffer = &pb;
        }
        if (pcBuffer == NULL) {
            pcBuffer = &cb;
        }
        rv = Real_wdupenv_s(ppBuffer, pcBuffer, varname);
        //        if (rv == 0 && *pcBuffer > 0 && *ppBuffer != NULL) {
        //            EnvVars::Used(varname);
        //        }
    }
    __finally {
        EnvVars::Used(varname);
        ExitFunc();
    }
    return rv;
}


/////////////////////////////////////////////////////////////
// AttachDetours
//
LONG AttachDetours(VOID)
{
    DetourTransactionBegin();
    DetourUpdateThread(GetCurrentThread());

    DetourAttach(&(PVOID&)Real_EntryPoint, Mine_EntryPoint);
    DetourAttach(&(PVOID&)Real_ExitProcess, Mine_ExitProcess);
    DetourAttach(&(PVOID&)Real_CopyFileExA, Mine_CopyFileExA);
    DetourAttach(&(PVOID&)Real_CopyFileExW, Mine_CopyFileExW);
    DetourAttach(&(PVOID&)Real_PrivCopyFileExW, Mine_PrivCopyFileExW);
    DetourAttach(&(PVOID&)Real_CreateHardLinkA, Mine_CreateHardLinkA);
    DetourAttach(&(PVOID&)Real_CreateHardLinkW, Mine_CreateHardLinkW);
    DetourAttach(&(PVOID&)Real_CreateDirectoryW, Mine_CreateDirectoryW);
    DetourAttach(&(PVOID&)Real_CreateDirectoryExW, Mine_CreateDirectoryExW);
    DetourAttach(&(PVOID&)Real_CreateFileW, Mine_CreateFileW);
    DetourAttach(&(PVOID&)Real_CreatePipe, Mine_CreatePipe);
    DetourAttach(&(PVOID&)Real_CreateFileMappingW, Mine_CreateFileMappingW);
    DetourAttach(&(PVOID&)Real_CloseHandle, Mine_CloseHandle);
    DetourAttach(&(PVOID&)Real_DuplicateHandle, Mine_DuplicateHandle);
    DetourAttach(&(PVOID&)Real_CreateProcessW, Mine_CreateProcessW);
    DetourAttach(&(PVOID&)Real_CreateProcessA, Mine_CreateProcessA);
    DetourAttach(&(PVOID&)Real_DeleteFileW, Mine_DeleteFileW);
    DetourAttach(&(PVOID&)Real_DeviceIoControl, Mine_DeviceIoControl);
    DetourAttach(&(PVOID&)Real_GetFileAttributesW, Mine_GetFileAttributesW);
    DetourAttach(&(PVOID&)Real_MoveFileA, Mine_MoveFileA);
    DetourAttach(&(PVOID&)Real_MoveFileW, Mine_MoveFileW);
    DetourAttach(&(PVOID&)Real_MoveFileExA, Mine_MoveFileExA);
    DetourAttach(&(PVOID&)Real_MoveFileExW, Mine_MoveFileExW);
    DetourAttach(&(PVOID&)Real_MoveFileWithProgressW, Mine_MoveFileWithProgressW);
    DetourAttach(&(PVOID&)Real_SetStdHandle, Mine_SetStdHandle);
    DetourAttach(&(PVOID&)Real_LoadLibraryA, Mine_LoadLibraryA);
    DetourAttach(&(PVOID&)Real_LoadLibraryW, Mine_LoadLibraryW);
    DetourAttach(&(PVOID&)Real_LoadLibraryExA, Mine_LoadLibraryExA);
    DetourAttach(&(PVOID&)Real_LoadLibraryExW, Mine_LoadLibraryExW);
    DetourAttach(&(PVOID&)Real_SetFilePointer, Mine_SetFilePointer);
    DetourAttach(&(PVOID&)Real_SetFilePointerEx, Mine_SetFilePointerEx);
    DetourAttach(&(PVOID&)Real_ReadFile, Mine_ReadFile);
    DetourAttach(&(PVOID&)Real_ReadFileEx, Mine_ReadFileEx);
    DetourAttach(&(PVOID&)Real_WriteFile, Mine_WriteFile);
    DetourAttach(&(PVOID&)Real_WriteFileEx, Mine_WriteFileEx);
    DetourAttach(&(PVOID&)Real_WriteConsoleA, Mine_WriteConsoleA);
    DetourAttach(&(PVOID&)Real_WriteConsoleW, Mine_WriteConsoleW);
    DetourAttach(&(PVOID&)Real_ExpandEnvironmentStringsA, Mine_ExpandEnvironmentStringsA);
    DetourAttach(&(PVOID&)Real_ExpandEnvironmentStringsW, Mine_ExpandEnvironmentStringsW);
    DetourAttach(&(PVOID&)Real_GetEnvironmentVariableA, Mine_GetEnvironmentVariableA);
    DetourAttach(&(PVOID&)Real_GetEnvironmentVariableW, Mine_GetEnvironmentVariableW);

    return DetourTransactionCommit();
}

LONG DetachDetours(VOID)
{
    DetourTransactionBegin();
    DetourUpdateThread(GetCurrentThread());

    DetourDetach(&(PVOID&)Real_EntryPoint, Mine_EntryPoint);
    DetourAttach(&(PVOID&)Real_ExitProcess, Mine_ExitProcess);
    DetourDetach(&(PVOID&)Real_CopyFileExA, Mine_CopyFileExA);
    DetourDetach(&(PVOID&)Real_CopyFileExW, Mine_CopyFileExW);
    DetourDetach(&(PVOID&)Real_PrivCopyFileExW, Mine_PrivCopyFileExW);
    DetourDetach(&(PVOID&)Real_CreateHardLinkA, Mine_CreateHardLinkA);
    DetourDetach(&(PVOID&)Real_CreateHardLinkW, Mine_CreateHardLinkW);
    DetourDetach(&(PVOID&)Real_CreateDirectoryW, Mine_CreateDirectoryW);
    DetourDetach(&(PVOID&)Real_CreateDirectoryExW, Mine_CreateDirectoryExW);
    DetourDetach(&(PVOID&)Real_CreateFileW, Mine_CreateFileW);
    DetourDetach(&(PVOID&)Real_CreatePipe, Mine_CreatePipe);
    DetourDetach(&(PVOID&)Real_CreateFileMappingW, Mine_CreateFileMappingW);
    DetourDetach(&(PVOID&)Real_CloseHandle, Mine_CloseHandle);
    DetourDetach(&(PVOID&)Real_DuplicateHandle, Mine_DuplicateHandle);
    DetourDetach(&(PVOID&)Real_CreateProcessW, Mine_CreateProcessW);
    DetourDetach(&(PVOID&)Real_CreateProcessA, Mine_CreateProcessA);
    DetourDetach(&(PVOID&)Real_DeleteFileW, Mine_DeleteFileW);
    DetourDetach(&(PVOID&)Real_DeviceIoControl, Mine_DeviceIoControl);
    DetourDetach(&(PVOID&)Real_GetFileAttributesW, Mine_GetFileAttributesW);
    DetourDetach(&(PVOID&)Real_MoveFileA, Mine_MoveFileA);
    DetourDetach(&(PVOID&)Real_MoveFileW, Mine_MoveFileW);
    DetourDetach(&(PVOID&)Real_MoveFileExA, Mine_MoveFileExA);
    DetourDetach(&(PVOID&)Real_MoveFileExW, Mine_MoveFileExW);
    DetourDetach(&(PVOID&)Real_MoveFileWithProgressW, Mine_MoveFileWithProgressW);
    DetourDetach(&(PVOID&)Real_SetStdHandle, Mine_SetStdHandle);
    DetourDetach(&(PVOID&)Real_LoadLibraryA, Mine_LoadLibraryA);
    DetourDetach(&(PVOID&)Real_LoadLibraryW, Mine_LoadLibraryW);
    DetourDetach(&(PVOID&)Real_LoadLibraryExA, Mine_LoadLibraryExA);
    DetourDetach(&(PVOID&)Real_LoadLibraryExW, Mine_LoadLibraryExW);
    DetourDetach(&(PVOID&)Real_SetFilePointer, Mine_SetFilePointer);
    DetourDetach(&(PVOID&)Real_SetFilePointerEx, Mine_SetFilePointerEx);
    DetourDetach(&(PVOID&)Real_ReadFile, Mine_ReadFile);
    DetourDetach(&(PVOID&)Real_ReadFileEx, Mine_ReadFileEx);
    DetourDetach(&(PVOID&)Real_WriteFile, Mine_WriteFile);
    DetourDetach(&(PVOID&)Real_WriteFileEx, Mine_WriteFileEx);
    DetourDetach(&(PVOID&)Real_WriteConsoleA, Mine_WriteConsoleA);
    DetourDetach(&(PVOID&)Real_WriteConsoleW, Mine_WriteConsoleW);
    DetourDetach(&(PVOID&)Real_ExpandEnvironmentStringsA, Mine_ExpandEnvironmentStringsA);
    DetourDetach(&(PVOID&)Real_ExpandEnvironmentStringsW, Mine_ExpandEnvironmentStringsW);
    DetourDetach(&(PVOID&)Real_GetEnvironmentVariableA, Mine_GetEnvironmentVariableA);
    DetourDetach(&(PVOID&)Real_GetEnvironmentVariableW, Mine_GetEnvironmentVariableW);

    if (Real_getenv) { DetourDetach(&(PVOID&)Real_getenv, Mine_getenv); }
    if (Real_getenv_s) { DetourDetach(&(PVOID&)Real_getenv_s, Mine_getenv_s); }
    if (Real_wgetenv) { DetourDetach(&(PVOID&)Real_wgetenv, Mine_wgetenv); }
    if (Real_wgetenv_s) { DetourDetach(&(PVOID&)Real_wgetenv, Mine_wgetenv_s); }
    if (Real_dupenv_s) { DetourDetach(&(PVOID&)Real_dupenv_s, Mine_dupenv_s); }
    if (Real_wdupenv_s) { DetourDetach(&(PVOID&)Real_wdupenv_s, Mine_wdupenv_s); }

    return DetourTransactionCommit();
}
//
//////////////////////////////////////////////////////////////////////////////

VOID NoteRead(PCSTR psz)
{
    FileInfo *pInfo = FileNames::FindPartial(psz);
    pInfo->m_fRead = TRUE;
}

VOID NoteRead(PCWSTR pwz)
{
    FileInfo *pInfo = FileNames::FindPartial(pwz);
    pInfo->m_fRead = TRUE;
}

VOID NoteWrite(PCSTR psz)
{
    FileInfo *pInfo = FileNames::FindPartial(psz);
    pInfo->m_fWrite = TRUE;
    if (!pInfo->m_fRead) {
        pInfo->m_fCantRead = TRUE;
    }
}

VOID NoteWrite(PCWSTR pwz)
{
    FileInfo *pInfo = FileNames::FindPartial(pwz);
    pInfo->m_fWrite = TRUE;
    if (!pInfo->m_fRead) {
        pInfo->m_fCantRead = TRUE;
    }
}

VOID NoteDelete(PCSTR psz)
{
    FileInfo *pInfo = FileNames::FindPartial(psz);
    if (pInfo->m_fWrite || pInfo->m_fRead) {
        pInfo->m_fCleanup = TRUE;
    }
    else {
        pInfo->m_fDelete = TRUE;
    }
    if (!pInfo->m_fRead) {
        pInfo->m_fCantRead = TRUE;
    }
}

VOID NoteDelete(PCWSTR pwz)
{
    FileInfo *pInfo = FileNames::FindPartial(pwz);
    if (pInfo->m_fWrite || pInfo->m_fRead) {
        pInfo->m_fCleanup = TRUE;
    }
    else {
        pInfo->m_fDelete = TRUE;
    }
    if (!pInfo->m_fRead) {
        pInfo->m_fCantRead = TRUE;
    }
}

VOID NoteCleanup(PCSTR psz)
{
    FileInfo *pInfo = FileNames::FindPartial(psz);
    pInfo->m_fCleanup = TRUE;
}

VOID NoteCleanup(PCWSTR pwz)
{
    FileInfo *pInfo = FileNames::FindPartial(pwz);
    pInfo->m_fCleanup = TRUE;
}

////////////////////////////////////////////////////////////// Logging System.
//
static BOOL s_bLog = 1;
static LONG s_nTlsIndent = -1;
static LONG s_nTlsThread = -1;
static LONG s_nThreadCnt = 0;

LONG EnterFunc()
{
    DWORD dwErr = GetLastError();

    LONG nIndent = 0;
    LONG nThread = 0;
    if (s_nTlsIndent >= 0) {
        nIndent = (LONG)(LONG_PTR)TlsGetValue(s_nTlsIndent);
        TlsSetValue(s_nTlsIndent, (PVOID)(LONG_PTR)(nIndent + 1));
    }
    if (s_nTlsThread >= 0) {
        nThread = (LONG)(LONG_PTR)TlsGetValue(s_nTlsThread);
    }

    SetLastError(dwErr);

    return nIndent;
}

VOID ExitFunc()
{
    DWORD dwErr = GetLastError();

    LONG nIndent = 0;
    LONG nThread = 0;
    if (s_nTlsIndent >= 0) {
        nIndent = (LONG)(LONG_PTR)TlsGetValue(s_nTlsIndent) - 1;
        ASSERT(nIndent >= 0);
        TlsSetValue(s_nTlsIndent, (PVOID)(LONG_PTR)nIndent);
    }
    if (s_nTlsThread >= 0) {
        nThread = (LONG)(LONG_PTR)TlsGetValue(s_nTlsThread);
    }

    SetLastError(dwErr);
}

VOID Print(const CHAR *psz, ...)
{
    DWORD dwErr = GetLastError();

    if (s_bLog && psz) {
        va_list  args;
        va_start(args, psz);

        TblogV(psz, args);

        va_end(args);
    }

    SetLastError(dwErr);
}

VOID AssertFailed(CONST PCHAR pszMsg, CONST PCHAR pszFile, ULONG nLine)
{
    Tblog("ASSERT(%hs) failed in %s, line %d.\n", pszMsg, pszFile, nLine);
}

//////////////////////////////////////////////////////////////////////////////
//
// DLL module information
//
BOOL ThreadAttach(HMODULE hDll)
{
    (void)hDll;

    if (s_nTlsIndent >= 0) {
        TlsSetValue(s_nTlsIndent, (PVOID)0);
    }
    if (s_nTlsThread >= 0) {
        LONG nThread = InterlockedIncrement(&s_nThreadCnt);
        TlsSetValue(s_nTlsThread, (PVOID)(LONG_PTR)nThread);
    }
    return TRUE;
}

BOOL ThreadDetach(HMODULE hDll)
{
    (void)hDll;

    if (s_nTlsIndent >= 0) {
        TlsSetValue(s_nTlsIndent, (PVOID)0);
    }
    if (s_nTlsThread >= 0) {
        TlsSetValue(s_nTlsThread, (PVOID)0);
    }
    return TRUE;
}

BOOL ProcessAttach(HMODULE hDll)
{
    InitializeCriticalSection(&s_csPipe);
    InitializeCriticalSection(&s_csChildPayload);

    Procs::Initialize();
    EnvVars::Initialize();
    FileNames::Initialize();
    OpenFiles::Initialize();

    s_bLog = FALSE;
    s_nTlsIndent = TlsAlloc();
    s_nTlsThread = TlsAlloc();

    s_hInst = hDll;
    s_hKernel32 = NULL;

    PBYTE xCreate = (PBYTE)DetourCodeFromPointer((PVOID)Real_CreateProcessW, NULL);
    PTBLOG_PAYLOAD pPayload = NULL;

    for (HMODULE hMod = NULL; (hMod = DetourEnumerateModules(hMod)) != NULL;) {
        ULONG cbData;
        PVOID pvData = DetourFindPayload(hMod, s_guidTrace, &cbData);

        if (pvData != NULL && pPayload == NULL) {
            pPayload = (PTBLOG_PAYLOAD)pvData;
        }

        ULONG cbMod = DetourGetModuleSize(hMod);

        if (((PBYTE)hMod) < xCreate && ((PBYTE)hMod + cbMod) > xCreate) {
            s_hKernel32 = hMod;
        }
    }

    ZeroMemory(&s_Payload, sizeof(s_Payload));

    if (pPayload == NULL) {
        return FALSE;
    }

    CopyMemory(&s_Payload, pPayload, sizeof(s_Payload));

    LoadStdHandleName(STD_INPUT_HANDLE, s_Payload.wzStdin, FALSE);
    LoadStdHandleName(STD_OUTPUT_HANDLE, s_Payload.wzStdout, s_Payload.fStdoutAppend);
    LoadStdHandleName(STD_ERROR_HANDLE, s_Payload.wzStderr, s_Payload.fStderrAppend);
    s_nTraceProcessId = s_Payload.nTraceProcessId;

    GetModuleFileNameA(s_hInst, s_szDllPath, ARRAYSIZE(s_szDllPath));

    // Find hidden functions.
    Real_PrivCopyFileExW =
        (BOOL (WINAPI *)(LPCWSTR, LPCWSTR, LPPROGRESS_ROUTINE, LPVOID, LPBOOL, DWORD))
        GetProcAddress(s_hKernel32, "PrivCopyFileExW");
    if (Real_PrivCopyFileExW == NULL) {
        DEBUG_BREAK();
    }

    LONG error = AttachDetours();
    if (error != NO_ERROR) {
        DEBUG_BREAK();
        Tblog("<!-- Error attaching detours: %d -->\n", error);
    }

    ThreadAttach(hDll);

    s_bLog = TRUE;
    return TRUE;
}

BOOL ProcessDetach(HMODULE hDll)
{
    ThreadDetach(hDll);
    s_bLog = FALSE;

    LONG error = DetachDetours();
    if (error != NO_ERROR) {
        Tblog("<!-- Error detaching detours: %d -->\n", error);
    }

    TblogClose();

    if (s_nTlsIndent >= 0) {
        TlsFree(s_nTlsIndent);
    }
    if (s_nTlsThread >= 0) {
        TlsFree(s_nTlsThread);
    }
    return TRUE;
}

inline VOID UpdateIfRoom(PWCHAR& pwzDst, PWCHAR pwzDstEnd, WCHAR c)
{
    if (pwzDst < pwzDstEnd) {
        *pwzDst++ = c;  // Write character if room in buffer.
    }
    else {
        pwzDst++;       // If no room, just advance pointer (to alloc calculation)
    }
}

static PCHAR RemoveReturns(PCHAR pszBuffer)
{
    PCHAR pszIn = pszBuffer;
    PCHAR pszOut = pszBuffer;

    while (*pszIn) {
        if (*pszIn == '\r') {
            pszIn++;
            continue;
        }
        *pszOut++ = *pszIn++;
    }
    *pszOut = '\0';

    return pszBuffer;
}

static PWCHAR RemoveReturns(PWCHAR pwzBuffer)
{
    PWCHAR pwzIn = pwzBuffer;
    PWCHAR pwzOut = pwzBuffer;

    while (*pwzIn) {
        if (*pwzIn == '\r') {
            pwzIn++;
            continue;
        }
        *pwzOut++ = *pwzIn++;
    }
    *pwzOut = '\0';

    return pwzBuffer;
}

PBYTE LoadFile(HANDLE hFile, DWORD cbFile)
{
    PBYTE pbFile = (PBYTE)GlobalAlloc(GPTR, cbFile + 3);
    if (pbFile == NULL) {
        return NULL;
    }

    DWORD cbRead = 0;
    Real_SetFilePointer(hFile, 0, NULL, FILE_BEGIN);
    Real_ReadFile(hFile, pbFile, cbFile, &cbRead, NULL);

    // Make sure the file is zero terminated.
    pbFile[cbRead + 0] = 0;
    pbFile[cbRead + 1] = 0;
    pbFile[cbRead + 2] = 0;

    return pbFile;
}

PWCHAR More(PCWSTR pwzPath, PWCHAR pwzDst, PWCHAR pwzDstEnd)
{
    HANDLE hFile = Real_CreateFileW(pwzPath, GENERIC_READ, 0, NULL, OPEN_EXISTING, 0, NULL);
    if (hFile == INVALID_HANDLE_VALUE) {
        return NULL;
    }

    FileInfo *pInfo = FileNames::FindPartial(pwzPath);
    pInfo->m_fAbsorbed = true;

    DWORD cbFile = Real_SetFilePointer(hFile, 0, NULL, FILE_END);
    DWORD cbRead = 0;

    PCHAR pszFile = (PCHAR)GlobalAlloc(GPTR, cbFile + 2);   // 2 bytes null for Unicode or Ascii.
    if (pszFile != NULL) {
        Real_SetFilePointer(hFile, 0, NULL, FILE_BEGIN);
        Real_ReadFile(hFile, pszFile, cbFile, &cbRead, NULL);

        if (((PUCHAR)pszFile)[0] == 0xff && ((PUCHAR)pszFile)[1] == 0xfe) {
            // Unicode
            PWCHAR pwzFile = ((PWCHAR)pszFile) + 1;
            PCWSTR pwzIn = pwzFile;
            while (*pwzIn) {
                if (*pwzIn == ' ' || *pwzIn == '\t' || *pwzIn == '\r' || *pwzIn == '\n') {
                    UpdateIfRoom(pwzDst, pwzDstEnd, ' ');
                    while (*pwzIn == ' ' || *pwzIn == '\t' || *pwzIn == '\r' || *pwzIn == '\n') {
                        pwzIn++;
                    }
                }
                else {
                    UpdateIfRoom(pwzDst, pwzDstEnd, *pwzIn++);
                }
            }
        }
        else {
            PCSTR pszIn = pszFile;
            while (*pszIn) {
                if (*pszIn == ' ' || *pszIn == '\t' || *pszIn == '\r' || *pszIn == '\n') {
                    UpdateIfRoom(pwzDst, pwzDstEnd, ' ');
                    while (*pszIn == ' ' || *pszIn == '\t' || *pszIn == '\r' || *pszIn == '\n') {
                        pszIn++;
                    }
                }
                else {
                    UpdateIfRoom(pwzDst, pwzDstEnd, *pszIn++);
                }
            }
        }

        GlobalFree(pszFile);
    }

    Real_CloseHandle(hFile);

    return pwzDst;
}

// This function is called twice.  On the first call, pwzDstEnd <= pwzDst and
// no data is copied, but pwzDst is advanced so we can see how big of a
// buffer is needed to hold the command line.
//
// On the second call, the command line is actually populated.
PWCHAR LoadCommandLine(PCWSTR pwz, PWCHAR pwzDst, PWCHAR pwzDstEnd)
{
    while (*pwz) {
        PCWSTR pwzArgBeg = NULL;
        PCWSTR pwzArgEnd = NULL;
        WCHAR cQuote = '\0';
        BOOL fMore = false;

        if (*pwz == '@') {
            fMore = true;
            pwz++;
        }

        if (*pwz == '\"' || *pwz == '\'') {
            cQuote = *pwz++;

            pwzArgBeg = pwz;
            while (*pwz != '\0' && *pwz != cQuote) {
                pwz++;
            }
            pwzArgEnd = pwz;

            if (*pwz == cQuote) {
                pwz++;
            }
        }
        else {
            pwzArgBeg = pwz;
            while (*pwz != '\0' && *pwz != ' ' && *pwz != '\t' && *pwz != '\n' && *pwz != '\r') {
                pwz++;
            }
            pwzArgEnd = pwz;
        }

        if (fMore) {
            // More arguments!
            WCHAR wzPath[MAX_PATH];
            PWCHAR pwzPath = wzPath;
            PCWSTR pwzTmp = pwzArgBeg + 1;
            while (pwzTmp < pwzArgEnd && pwzPath < wzPath + ARRAYSIZE(wzPath)-2) {
                *pwzPath++ = *pwzTmp++;
            }
            *pwzPath = '\0';

            PWCHAR pwzOut = More(wzPath, pwzDst, pwzDstEnd);
            if (pwzOut != NULL) {
                pwzDst = pwzOut;

                cQuote = 0;
                pwzArgBeg = pwzArgEnd;
            }
        }

        if (cQuote) {
            UpdateIfRoom(pwzDst, pwzDstEnd, cQuote);
        }
        for (; pwzArgBeg < pwzArgEnd; pwzArgBeg++) {
            UpdateIfRoom(pwzDst, pwzDstEnd, *pwzArgBeg);
        }
        if (cQuote) {
            UpdateIfRoom(pwzDst, pwzDstEnd, cQuote);
        }

        if (*pwz) {
            UpdateIfRoom(pwzDst, pwzDstEnd, ' ');
        }

        // skip over separating spaces.
        while (*pwz == ' ' || *pwz == '\t' || *pwz == '\n' || *pwz == '\r') {
            pwz++;
        }
    }
    return pwzDst;
}

void TestHandle(PCSTR pszName, HANDLE h)
{
    FileInfo *pInfo = OpenFiles::RecallFile(h);

    if (pInfo != NULL) {
#if 1 // Ignore PIPEs.
        if (FileNames::PrefixMatch(pInfo->m_pwzPath, L"\\\\.\\PIPE\\")) {
            // Ignore;
        }
        else
#endif
            if (FileNames::SuffixMatch(pInfo->m_pwzPath, L"\\conout$")) {
            // Ignore;
        }
        else if (FileNames::SuffixMatch(pInfo->m_pwzPath, L"\\conin$")) {
            // Ignore;
        }
        else if (FileNames::SuffixMatch(pInfo->m_pwzPath, L"\\nul")) {
            // Ignore;
        }
        else {
            Tblog("<%hs%hs>%le</%hs>\n",
                  pszName, pInfo->m_fAppend ? " append=\"true\"" : "", pInfo->m_pwzPath, pszName);
        }
    }
    else {
        Tblog("<!-- hand: %hs (%x) ***Unknown*** -->\n", pszName, h);
    }
}

LONG WINAPI DetourAttachIf(PVOID *ppPointer, PVOID pDetour)
{
    if (*ppPointer == NULL) {
        Tblog("<!-- DetourAttachIf failed: %p -->\n", pDetour);
        return NO_ERROR;
    }

    PDETOUR_TRAMPOLINE pRealTrampoline;
    PVOID pRealTarget;
    PVOID pRealDetour;

    LONG err = DetourAttachEx(ppPointer, pDetour, &pRealTrampoline, &pRealTarget, &pRealDetour);
    if (err == NO_ERROR) {
        // Tblog("<!-- DetourAttachIf %p at %p -->\n", pDetour, pRealTarget);
        return NO_ERROR;
    }
    return err;
}

int WINAPI Mine_EntryPoint(VOID)
{
    // This function is invoked instead of the process EntryPoint (Real_EntryPoint).

    TblogOpen();

    SaveEnvironment();

    {
        CHAR szExeName[MAX_PATH];
        CHAR szId[128];
        CHAR szParent[128];
        WCHAR wzPath[MAX_PATH];
        PCHAR pszExeName = szExeName;

        // Get the base command line (skipping over the executable name)
        PCWSTR pwzLine = GetCommandLineW();
        if (*pwzLine == '\"') {
            pwzLine++;
            while (*pwzLine && *pwzLine != '\"') {
                pwzLine++;
            }
            if (*pwzLine == '\"') {
                pwzLine++;
            }
        }
        else {
            while (*pwzLine && *pwzLine != ' ' && *pwzLine != '\t') {
                pwzLine++;
            }
        }
        while (*pwzLine && (*pwzLine == ' ' || *pwzLine == '\t')) {
            pwzLine++;
        }

        // Get the root executable name.
        if (GetModuleFileNameA(0, szExeName, ARRAYSIZE(szExeName))) {
            PCHAR psz = szExeName;

            while (*psz) {
                psz++;
            }

            while (psz > szExeName && psz[-1] != ':' && psz[-1] != '\\' && psz[-1] != '/') {
                psz--;
            }
            pszExeName = psz;
            while (*psz && *psz != '.') {
                psz++;
            }
            *psz = '\0';
        }
        else {
            szExeName[0] = '\0';
        }

        // Start the XML process node.
        Tblog("<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n");
        {
            PCHAR pszId = szId;
            PCHAR pszParent = szParent;
            for (DWORD i = 0; i < s_Payload.nGeneology; i++) {
                pszId = SafePrintf(pszId, 16, "%d.", s_Payload.rGeneology[i]);
                if (i < s_Payload.nGeneology - 1) {
                    pszParent = SafePrintf(pszParent, 16, "%d.", s_Payload.rGeneology[i]);
                }
            }
            *pszId = '\0';
            *pszParent = '\0';

            if (szParent[0] == '\0') {
                Tblog("<t:Process id=\"::%hs::\"", szId);
            }
            else {
                Tblog("<t:Process id=\"::%hs::\" parentId=\"::%hs::\"", szId, szParent);
            }

            Tblog(" par=\"%ls\" exe=\"%hs\"", s_Payload.wzParents, pszExeName);

            BOOL drop = false;
            PCWSTR pwzz = s_Payload.wzzDrop;
            while (*pwzz) {
                if (Compare(pwzz, pszExeName) == 0) {
                    // match
                    drop = true;
                    break;
                }
                pwzz += Size(pwzz) + 1;
            }
            if (drop) {
                Tblog(" drop=\"true\"");
            }
        }

        {
            PWCHAR pwz = s_Payload.wzParents;
            while (*pwz) {
                pwz++;
            }
            *pwz++ = '/';
            PCSTR psz = pszExeName;
            while (*psz) {
                *pwz++ = *psz++;
            }
            *pwz = '\0';
        }


        if (HasChar(pwzLine, '|')) {
            Tblog(" pipes=\"true\"");
        }
        if (HasChar(pwzLine, '>')) {
            Tblog(" redirects=\"true\"");
        }

        Tblog(" xmlns:t=\"http://schemas.microsoft.com/research/tracebld/2008\">\n");

        // Get the directory.
        DWORD dwSize = GetCurrentDirectoryA(ARRAYSIZE(szExeName), szExeName);
        if (dwSize > 0 && dwSize < ARRAYSIZE(szExeName)) {
            Tblog("<t:Directory>%hs</t:Directory>\n", szExeName);
        }

        // Get the real executable name.
        wzPath[0] = '\0';
        if (GetModuleFileNameA(0, szExeName, ARRAYSIZE(szExeName))) {
            FileInfo *pInfo = FileNames::FindPartial(szExeName);
            Tblog("<t:Executable>%ls</t:Executable>\n",
                  FileNames::ParameterizeName(wzPath, ARRAYSIZE(wzPath), pInfo));
        }

        // Construct the processed command line.
        PWCHAR pwzDstEnd = (PWCHAR)pwzLine;
        PWCHAR pwzDst = pwzDstEnd;
        pwzDst = LoadCommandLine(pwzLine, pwzDst, pwzDstEnd);
        DWORD wcNew = (DWORD)((pwzDst - pwzDstEnd) + 1);
        PWCHAR pwzFin = (PWCHAR)GlobalAlloc(GPTR, wcNew * sizeof(WCHAR));
        pwzDst = pwzFin;
        pwzDstEnd = pwzFin + wcNew;
        pwzDst = LoadCommandLine(pwzLine, pwzDst, pwzDstEnd);
        *pwzDst = '\0';

        FileNames::ParameterizeLine(pwzFin, pwzFin + wcNew);
        if (HasSpace(wzPath)) {
            Tblog("<t:Line>&quot;%le&quot; %le</t:Line>\n", wzPath, pwzFin);
        }
        else {
            Tblog("<t:Line>%le %le</t:Line>\n", wzPath, pwzFin);
        }

        TestHandle("t:StdIn", GetStdHandle(STD_INPUT_HANDLE));
        TestHandle("t:StdOut", GetStdHandle(STD_OUTPUT_HANDLE));
        TestHandle("t:StdErr", GetStdHandle(STD_ERROR_HANDLE));
    }

    if (FindMsvcr()) {
        FindProc(&(PVOID&)Real_getenv, "getenv");
        FindProc(&(PVOID&)Real_wgetenv, "_wgetenv");
        FindProc(&(PVOID&)Real_getenv_s, "getenv_s");
        FindProc(&(PVOID&)Real_wgetenv_s, "_wgetenv_s");
        FindProc(&(PVOID&)Real_dupenv_s, "_dupenv_s");
        FindProc(&(PVOID&)Real_wdupenv_s, "_wdupenv_s");

        DetourTransactionBegin();
        DetourUpdateThread(GetCurrentThread());

        DetourAttachIf(&(PVOID&)Real_getenv, Mine_getenv);
        DetourAttachIf(&(PVOID&)Real_getenv_s, Mine_getenv_s);
        DetourAttachIf(&(PVOID&)Real_wgetenv, Mine_wgetenv);
        DetourAttachIf(&(PVOID&)Real_wgetenv, Mine_wgetenv_s);
        DetourAttachIf(&(PVOID&)Real_dupenv_s, Mine_dupenv_s);
        DetourAttachIf(&(PVOID&)Real_wdupenv_s, Mine_wdupenv_s);

        DetourTransactionCommit();
    }

    return Real_EntryPoint();
}

VOID WINAPI Mine_ExitProcess(UINT a0)
{
    if (a0 & 0x80000000) {
        Tblog("<t:Return>%d</t:Return>\n", -(int)a0);
    }
    else {
        Tblog("<t:Return>%d</t:Return>\n", a0);
    }

    FileNames::Dump();
    EnvVars::Dump();

    TblogClose();

    Real_ExitProcess(a0);
}

BOOL APIENTRY DllMain(HINSTANCE hModule, DWORD dwReason, PVOID lpReserved)
{
    (void)hModule;
    (void)lpReserved;

    if (DetourIsHelperProcess()) {
        return TRUE;
    }

    if (dwReason == DLL_PROCESS_ATTACH) {
        DetourRestoreAfterWith();
        Real_EntryPoint = (int (WINAPI *)(VOID))DetourGetEntryPoint(NULL);
        return ProcessAttach(hModule);
    }
    else if (dwReason == DLL_PROCESS_DETACH) {
        return ProcessDetach(hModule);
    }
    else if (dwReason == DLL_THREAD_ATTACH) {
        return ThreadAttach(hModule);
    }
    else if (dwReason == DLL_THREAD_DETACH) {
        return ThreadDetach(hModule);
    }
    return TRUE;
}
//
///////////////////////////////////////////////////////////////// End of File.

```

`samples/tracebld/trcbld.rc`:

```rc
//////////////////////////////////////////////////////////////////////////////
//
//  Version information for trcbld.rc.
//
//  Microsoft Research Detours Package
//
//  Copyright (c) Microsoft Corporation.  All rights reserved.
//

#include "detver.h"

#define VER_INTERNALNAME_STR        "trcbld" DETOURS_STRINGIFY(DETOURS_BITS)
#define VER_ORIGINALFILENAME_STR    "trcbld" DETOURS_STRINGIFY(DETOURS_BITS) ".dll"
#define VER_FILEDESCRIPTION_STR     "Detours Build Tracing Module"
#define VER_COMPANYNAME_STR         "Microsoft Corporation"

#include "common.ver"

```

`samples/tracelnk/Makefile`:

```
##############################################################################
##
##  Utility to trace Dynamic Linking.
##
##  Microsoft Research Detours Package
##
##  Copyright (c) Microsoft Corporation.  All rights reserved.
##

!include ..\common.mak

LIBS=$(LIBS) kernel32.lib

##############################################################################

all: dirs \
    $(BIND)\trclnk$(DETOURS_BITS).dll \
!IF $(DETOURS_SOURCE_BROWSING)==1
    $(OBJD)\trclnk$(DETOURS_BITS).bsc \
!ENDIF
    option

##############################################################################

clean:
    -del *~ test.txt 2>nul
    -del $(BIND)\trclnk*.* 2>nul
    -rmdir /q /s $(OBJD) 2>nul

realclean: clean
    -rmdir /q /s $(OBJDS) 2>nul

dirs:
    @if not exist $(BIND) mkdir $(BIND) && echo .   Created $(BIND)
    @if not exist $(OBJD) mkdir $(OBJD) && echo .   Created $(OBJD)

##############################################################################

$(OBJD)\trclnk.obj : trclnk.cpp

$(OBJD)\trclnk.res : trclnk.rc

$(BIND)\trclnk$(DETOURS_BITS).dll : $(OBJD)\trclnk.obj $(OBJD)\trclnk.res $(DEPS)
    cl /LD $(CFLAGS) /Fe$@ /Fd$(@R).pdb \
        $(OBJD)\trclnk.obj $(OBJD)\trclnk.res \
        /link $(LINKFLAGS) /subsystem:console \
        /export:DetourFinishHelperProcess,@1,NONAME \
        $(LIBS)

$(OBJD)\trclnk$(DETOURS_BITS).bsc : $(OBJD)\trclnk.obj
    bscmake /v /n /o $@ $(OBJD)\trclnk.sbr

############################################### Install non-bit-size binaries.

!IF "$(DETOURS_OPTION_PROCESSOR)" != ""

$(OPTD)\trclnk$(DETOURS_OPTION_BITS).dll:
$(OPTD)\trclnk$(DETOURS_OPTION_BITS).pdb:

$(BIND)\trclnk$(DETOURS_OPTION_BITS).dll : $(OPTD)\trclnk$(DETOURS_OPTION_BITS).dll
    @if exist $? copy /y $? $(BIND) >nul && echo $@ copied from $(DETOURS_OPTION_PROCESSOR).
$(BIND)\trclnk$(DETOURS_OPTION_BITS).pdb : $(OPTD)\trclnk$(DETOURS_OPTION_BITS).pdb
    @if exist $? copy /y $? $(BIND) >nul && echo $@ copied from $(DETOURS_OPTION_PROCESSOR).

option: \
    $(BIND)\trclnk$(DETOURS_OPTION_BITS).dll \
    $(BIND)\trclnk$(DETOURS_OPTION_BITS).pdb \

!ELSE

option:

!ENDIF

##############################################################################

notepad: all
    @echo -------- Logging output to test.txt ------------
    start $(BIND)\syelogd.exe /o test.txt
    $(BIND)\sleep5.exe 1
    @echo -------- Should load trclnk$(DETOURS_BITS).dll dynamically using withdll.exe ------------
    @echo .
    @echo ** NOTE NOTE NOTE NOTE NOTE NOTE NOTE NOTE NOTE NOTE NOTE **
    @echo **
    @echo ** Close the NotePad window to continue test.
    @echo **
    @echo ** NOTE NOTE NOTE NOTE NOTE NOTE NOTE NOTE NOTE NOTE NOTE **
    @echo .
    $(BIND)\withdll -d:$(BIND)\trclnk$(DETOURS_BITS).dll $(SYSTEMROOT)\system32\notepad.exe
    @echo -------- Log from syelog -------------
    type test.txt

test: all
    @echo -------- Logging output to test.txt ------------
    start $(BIND)\syelogd.exe /o test.txt
    $(BIND)\sleep5.exe 1
    @echo -------- Should load trclnk$(DETOURS_BITS).dll dynamically using withdll.exe ------------
    @echo .
    $(BIND)\withdll -d:$(BIND)\trclnk$(DETOURS_BITS).dll $(SYSTEMROOT)\system32\cmd.exe /c dir
    @echo -------- Log from syelog -------------
    type test.txt

################################################################# End of File.

```

`samples/tracelnk/trclnk.cpp`:

```cpp
//////////////////////////////////////////////////////////////////////////////
//
//  Detours Test Program (trclnk.cpp of trclnk.dll)
//
//  Microsoft Research Detours Package
//
//  Copyright (c) Microsoft Corporation.  All rights reserved.
//
#define _WIN32_WINNT        0x0400
#define WIN32
#define NT

#define DBG_TRACE   0

#include <windows.h>
#include <stdio.h>
#include "detours.h"
#include "syelog.h"

#define PULONG_PTR          PVOID
#define PLONG_PTR           PVOID
#define ULONG_PTR           PVOID
#define ENUMRESNAMEPROCA    PVOID
#define ENUMRESNAMEPROCW    PVOID
#define ENUMRESLANGPROCA    PVOID
#define ENUMRESLANGPROCW    PVOID
#define ENUMRESTYPEPROCA    PVOID
#define ENUMRESTYPEPROCW    PVOID
#define STGOPTIONS          PVOID

//////////////////////////////////////////////////////////////////////////////
#pragma warning(disable:4127)   // Many of our asserts are constants.

#define ASSERT_ALWAYS(x)   \
    do {                                                        \
    if (!(x)) {                                                 \
            AssertMessage(#x, __FILE__, __LINE__);              \
            DebugBreak();                                       \
    }                                                           \
    } while (0)

#ifndef NDEBUG
#define ASSERT(x)           ASSERT_ALWAYS(x)
#else
#define ASSERT(x)
#endif

#define UNUSED(c)    (c) = (c)

//////////////////////////////////////////////////////////////////////////////
static HMODULE s_hInst = NULL;
static WCHAR s_wzDllPath[MAX_PATH];

BOOL ProcessEnumerate();
BOOL InstanceEnumerate(HINSTANCE hInst);
BOOL ImportEnumerate(HINSTANCE hInst);

VOID _PrintEnter(const CHAR *psz, ...);
VOID _PrintExit(const CHAR *psz, ...);
VOID _Print(const CHAR *psz, ...);
VOID _VPrint(PCSTR msg, va_list args, PCHAR pszBuf, LONG cbBuf);

VOID AssertMessage(CONST PCHAR pszMsg, CONST PCHAR pszFile, ULONG nLine);

//////////////////////////////////////////////////////////////////////////////
//
// Trampolines
//
extern "C" {
    //  Trampolines for SYELOG library.
    //
    HANDLE (WINAPI *
            Real_CreateFileW)(LPCWSTR a0, DWORD a1, DWORD a2,
                              LPSECURITY_ATTRIBUTES a3, DWORD a4, DWORD a5,
                              HANDLE a6)
        = CreateFileW;

    BOOL (WINAPI *
          Real_WriteFile)(HANDLE hFile,
                          LPCVOID lpBuffer,
                          DWORD nNumberOfBytesToWrite,
                          LPDWORD lpNumberOfBytesWritten,
                          LPOVERLAPPED lpOverlapped)
        = WriteFile;
    BOOL (WINAPI *
          Real_FlushFileBuffers)(HANDLE hFile)
        = FlushFileBuffers;
    BOOL (WINAPI *
          Real_CloseHandle)(HANDLE hObject)
        = CloseHandle;

    BOOL (WINAPI *
          Real_WaitNamedPipeW)(LPCWSTR lpNamedPipeName, DWORD nTimeOut)
        = WaitNamedPipeW;
    BOOL (WINAPI *
          Real_SetNamedPipeHandleState)(HANDLE hNamedPipe,
                                        LPDWORD lpMode,
                                        LPDWORD lpMaxCollectionCount,
                                        LPDWORD lpCollectDataTimeout)
        = SetNamedPipeHandleState;

    DWORD (WINAPI *
           Real_GetCurrentProcessId)(VOID)
        = GetCurrentProcessId;
    VOID (WINAPI *
          Real_GetSystemTimeAsFileTime)(LPFILETIME lpSystemTimeAsFileTime)
        = GetSystemTimeAsFileTime;

    VOID (WINAPI *
          Real_InitializeCriticalSection)(LPCRITICAL_SECTION lpSection)
        = InitializeCriticalSection;
    VOID (WINAPI *
          Real_EnterCriticalSection)(LPCRITICAL_SECTION lpSection)
        = EnterCriticalSection;
    VOID (WINAPI *
          Real_LeaveCriticalSection)(LPCRITICAL_SECTION lpSection)
        = LeaveCriticalSection;
}

BOOL (WINAPI *
      Real_FreeLibrary)(HMODULE a0)
    = FreeLibrary;

DWORD (WINAPI *
       Real_GetModuleFileNameW)(HMODULE a0,
                                LPWSTR a1,
                                DWORD a2)
    = GetModuleFileNameW;

HMODULE (WINAPI *
         Real_GetModuleHandleW)(LPCWSTR a0)
    = GetModuleHandleW;

FARPROC (WINAPI *
         Real_GetProcAddress)(HMODULE a0,
                              LPCSTR a1)
    = GetProcAddress;

HMODULE (WINAPI *
         Real_LoadLibraryExW)(LPCWSTR a0,
                              HANDLE a1,
                              DWORD a2)
    = LoadLibraryExW;

HMODULE (WINAPI *
         Real_LoadLibraryW)(LPCWSTR a0)
    = LoadLibraryW;

//////////////////////////////////////////////////////////////////////////////
//
BOOL WINAPI Mine_FreeLibrary(HMODULE a0)
{
    (void)a0;

    return TRUE;
}

DWORD WINAPI Mine_GetModuleFileNameW(HMODULE a0,
                                     LPWSTR a1,
                                     DWORD a2)
{
    return Real_GetModuleFileNameW(a0, a1, a2);
}

HMODULE WINAPI Mine_GetModuleHandleW(LPCWSTR a0)
{
    return Real_GetModuleHandleW(a0);
}

FARPROC WINAPI Mine_GetProcAddress(HMODULE a0,
                                   LPCSTR a1)
{
    _PrintEnter("GetProcAddress(%p,%hs)\n", a0, a1);

    FARPROC rv = 0;
    __try {
        rv = Real_GetProcAddress(a0, a1);
    } __finally {
        _PrintExit("GetProcAddress(,) -> %p\n", rv);
    };
    return rv;
}

HMODULE WINAPI Mine_LoadLibraryExW(LPCWSTR a0,
                                   HANDLE a1,
                                   DWORD a2)
{
    _PrintEnter("LoadLibraryExW(%ls,%p,%x)\n", a0, a1, a2);

    HMODULE rv = 0;
    __try {
        rv = Real_LoadLibraryExW(a0, a1, a2);
    } __finally {
        _PrintExit("LoadLibraryExW(,,) -> %p\n", rv);
        if (rv) {
            InstanceEnumerate(rv);
            ImportEnumerate(rv);
        }
    };
    return rv;
}

HMODULE WINAPI Mine_LoadLibraryW(LPCWSTR a0)
{
    _PrintEnter("LoadLibraryW(%ls)\n", a0);

    HMODULE rv = 0;
    __try {
        rv = Real_LoadLibraryW(a0);
    } __finally {
        _PrintExit("LoadLibraryW() -> %p\n", rv);
    };
    return rv;
}

/////////////////////////////////////////////////////////////
// AttachDetours
//
PCHAR DetRealName(PCHAR psz)
{
    PCHAR pszBeg = psz;
    // Move to end of name.
    while (*psz) {
        psz++;
    }
    // Move back through A-Za-z0-9 names.
    while (psz > pszBeg &&
           ((psz[-1] >= 'A' && psz[-1] <= 'Z') ||
            (psz[-1] >= 'a' && psz[-1] <= 'z') ||
            (psz[-1] >= '0' && psz[-1] <= '9'))) {
        psz--;
    }
    return psz;
}

VOID DetAttach(PVOID *ppbReal, PVOID pbMine, PCHAR psz)
{
    LONG l = DetourAttach(ppbReal, pbMine);
    if (l != 0) {
        Syelog(SYELOG_SEVERITY_NOTICE,
               "Attach failed: `%s': error %d\n", DetRealName(psz), l);
    }
}

VOID DetDetach(PVOID *ppbReal, PVOID pbMine, PCHAR psz)
{
    LONG l = DetourDetach(ppbReal, pbMine);
    if (l != 0) {
        Syelog(SYELOG_SEVERITY_NOTICE,
               "Detach failed: `%s': error %d\n", DetRealName(psz), l);
    }
}

#define ATTACH(x)       DetAttach(&(PVOID&)Real_##x,Mine_##x,#x)
#define DETACH(x)       DetDetach(&(PVOID&)Real_##x,Mine_##x,#x)

LONG AttachDetours(VOID)
{
    DetourTransactionBegin();
    DetourUpdateThread(GetCurrentThread());

    ATTACH(FreeLibrary);
    ATTACH(GetModuleHandleW);
    ATTACH(GetProcAddress);
    ATTACH(LoadLibraryExW);
    ATTACH(LoadLibraryW);

    return DetourTransactionCommit();
}

LONG DetachDetours(VOID)
{
    DetourTransactionBegin();
    DetourUpdateThread(GetCurrentThread());

    DETACH(FreeLibrary);
    DETACH(GetModuleHandleW);
    DETACH(GetProcAddress);
    DETACH(LoadLibraryExW);
    DETACH(LoadLibraryW);

    return DetourTransactionCommit();
}

////////////////////////////////////////////////////////////// Logging System.
//
static BOOL s_bLog = 1;
static LONG s_nTlsIndent = -1;
static LONG s_nTlsThread = -1;
static LONG s_nThreadCnt = 0;

VOID _PrintEnter(const CHAR *psz, ...)
{
    DWORD dwErr = GetLastError();

    LONG nIndent = 0;
    LONG nThread = 0;
    if (s_nTlsIndent >= 0) {
        nIndent = (LONG)(LONG_PTR)TlsGetValue(s_nTlsIndent);
        TlsSetValue(s_nTlsIndent, (PVOID)(LONG_PTR)(nIndent + 1));
    }
    if (s_nTlsThread >= 0) {
        nThread = (LONG)(LONG_PTR)TlsGetValue(s_nTlsThread);
    }

    if (s_bLog && psz) {
        CHAR szBuf[1024];
        PCHAR pszBuf = szBuf;
        PCHAR pszEnd = szBuf + ARRAYSIZE(szBuf) - 1;
        LONG nLen = (nIndent > 0) ? (nIndent < 35 ? nIndent * 2 : 70) : 0;
        *pszBuf++ = (CHAR)('0' + ((nThread / 100) % 10));
        *pszBuf++ = (CHAR)('0' + ((nThread / 10) % 10));
        *pszBuf++ = (CHAR)('0' + ((nThread / 1) % 10));
        *pszBuf++ = ' ';
        while (nLen-- > 0) {
            *pszBuf++ = ' ';
        }

        va_list  args;
        va_start(args, psz);

        while ((*pszBuf++ = *psz++) != 0 && pszBuf < pszEnd) {
            // Copy characters.
        }
        *pszEnd = '\0';
        SyelogV(SYELOG_SEVERITY_INFORMATION, szBuf, args);

        va_end(args);
    }
    SetLastError(dwErr);
}

VOID _PrintExit(const CHAR *psz, ...)
{
    DWORD dwErr = GetLastError();

    LONG nIndent = 0;
    LONG nThread = 0;
    if (s_nTlsIndent >= 0) {
        nIndent = (LONG)(LONG_PTR)TlsGetValue(s_nTlsIndent) - 1;
        ASSERT(nIndent >= 0);
        TlsSetValue(s_nTlsIndent, (PVOID)(LONG_PTR)nIndent);
    }
    if (s_nTlsThread >= 0) {
        nThread = (LONG)(LONG_PTR)TlsGetValue(s_nTlsThread);
    }

    if (s_bLog && psz) {
        CHAR szBuf[1024];
        PCHAR pszBuf = szBuf;
        PCHAR pszEnd = szBuf + ARRAYSIZE(szBuf) - 1;
        LONG nLen = (nIndent > 0) ? (nIndent < 35 ? nIndent * 2 : 70) : 0;
        *pszBuf++ = (CHAR)('0' + ((nThread / 100) % 10));
        *pszBuf++ = (CHAR)('0' + ((nThread / 10) % 10));
        *pszBuf++ = (CHAR)('0' + ((nThread / 1) % 10));
        *pszBuf++ = ' ';
        while (nLen-- > 0) {
            *pszBuf++ = ' ';
        }

        va_list  args;
        va_start(args, psz);

        while ((*pszBuf++ = *psz++) != 0 && pszBuf < pszEnd) {
            // Copy characters.
        }
        *pszEnd = '\0';
        SyelogV(SYELOG_SEVERITY_INFORMATION, szBuf, args);

        va_end(args);
    }
    SetLastError(dwErr);
}

VOID _Print(const CHAR *psz, ...)
{
    DWORD dwErr = GetLastError();

    LONG nIndent = 0;
    LONG nThread = 0;
    if (s_nTlsIndent >= 0) {
        nIndent = (LONG)(LONG_PTR)TlsGetValue(s_nTlsIndent);
    }
    if (s_nTlsThread >= 0) {
        nThread = (LONG)(LONG_PTR)TlsGetValue(s_nTlsThread);
    }

    if (s_bLog && psz) {
        CHAR szBuf[1024];
        PCHAR pszBuf = szBuf;
        PCHAR pszEnd = szBuf + ARRAYSIZE(szBuf) - 1;
        LONG nLen = (nIndent > 0) ? (nIndent < 35 ? nIndent * 2 : 70) : 0;
        *pszBuf++ = (CHAR)('0' + ((nThread / 100) % 10));
        *pszBuf++ = (CHAR)('0' + ((nThread / 10) % 10));
        *pszBuf++ = (CHAR)('0' + ((nThread / 1) % 10));
        *pszBuf++ = ' ';
        while (nLen-- > 0) {
            *pszBuf++ = ' ';
        }

        va_list  args;
        va_start(args, psz);

        while ((*pszBuf++ = *psz++) != 0 && pszBuf < pszEnd) {
            // Copy characters.
        }
        *pszEnd = '\0';
        SyelogV(SYELOG_SEVERITY_INFORMATION, szBuf, args);

        va_end(args);
    }
    SetLastError(dwErr);
}

VOID AssertMessage(CONST PCHAR pszMsg, CONST PCHAR pszFile, ULONG nLine)
{
    Syelog(SYELOG_SEVERITY_FATAL,
           "ASSERT(%s) failed in %s, line %d.\n", pszMsg, pszFile, nLine);
}

//////////////////////////////////////////////////////////////////////////////
//
PIMAGE_NT_HEADERS NtHeadersForInstance(HINSTANCE hInst)
{
    PIMAGE_DOS_HEADER pDosHeader = (PIMAGE_DOS_HEADER)hInst;
    __try {
        if (pDosHeader->e_magic != IMAGE_DOS_SIGNATURE) {
            SetLastError(ERROR_BAD_EXE_FORMAT);
            return NULL;
        }

        PIMAGE_NT_HEADERS pNtHeader = (PIMAGE_NT_HEADERS)((PBYTE)pDosHeader +
                                                          pDosHeader->e_lfanew);
        if (pNtHeader->Signature != IMAGE_NT_SIGNATURE) {
            SetLastError(ERROR_INVALID_EXE_SIGNATURE);
            return NULL;
        }
        if (pNtHeader->FileHeader.SizeOfOptionalHeader == 0) {
            SetLastError(ERROR_EXE_MARKED_INVALID);
            return NULL;
        }
        return pNtHeader;
    } __except(EXCEPTION_EXECUTE_HANDLER) {
    }
    SetLastError(ERROR_EXE_MARKED_INVALID);

    return NULL;
}

static inline PBYTE RvaToVa(PBYTE pbBase, DWORD nOffset)
{
    return nOffset ? pbBase + nOffset : NULL;
}

#if _MSC_VER >= 1900
#pragma warning(push)
#pragma warning(disable:4456) // declaration hides previous local declaration
#endif

BOOL ImportEnumerate(HINSTANCE hInst)
{
    PBYTE pbBase = (PBYTE)hInst;
    PIMAGE_NT_HEADERS pNtHeader;                    // Read & Write
    PIMAGE_SECTION_HEADER pSectionHeaders;
    DWORD nPeOffset;
    DWORD nSectionsOffset;

    ////////////////////////////////////////////////////// Process DOS Header.
    //
    PIMAGE_DOS_HEADER pDosHeader = (PIMAGE_DOS_HEADER)pbBase;
    if (pDosHeader->e_magic != IMAGE_DOS_SIGNATURE) {
        return FALSE;
    }
    nPeOffset = pDosHeader->e_lfanew;

    /////////////////////////////////////////////////////// Process PE Header.
    //
    pNtHeader = (PIMAGE_NT_HEADERS)RvaToVa(pbBase, nPeOffset);
    if (pNtHeader->Signature != IMAGE_NT_SIGNATURE) {
        return FALSE;
    }
    if (pNtHeader->FileHeader.SizeOfOptionalHeader == 0) {
        return FALSE;
    }
    nSectionsOffset = nPeOffset
        + sizeof(pNtHeader->Signature)
        + sizeof(pNtHeader->FileHeader)
        + pNtHeader->FileHeader.SizeOfOptionalHeader;

    ///////////////////////////////////////////////// Process Section Headers.
    //
    pSectionHeaders = (PIMAGE_SECTION_HEADER)RvaToVa(pbBase, nSectionsOffset);

    //////////////////////////////////////////////////////// Get Import Table.
    //
    DWORD rvaImageDirectory = pNtHeader->OptionalHeader
        .DataDirectory[IMAGE_DIRECTORY_ENTRY_IMPORT].VirtualAddress;
    PIMAGE_IMPORT_DESCRIPTOR iidp
        = (PIMAGE_IMPORT_DESCRIPTOR)RvaToVa(pbBase, rvaImageDirectory);

    if (iidp == NULL) {
        return FALSE;
    }

    DWORD nFiles = 0;
    for (; iidp[nFiles].Characteristics != 0; nFiles++) {
        // Count the files.
    }

    for (DWORD n = 0; n < nFiles; n++, iidp++) {
        DWORD rvaName = iidp->Name;
        PCHAR pszName = (PCHAR)RvaToVa(pbBase, rvaName);

        DWORD rvaThunk = (DWORD)iidp->OriginalFirstThunk;
        PIMAGE_THUNK_DATA pThunk = (PIMAGE_THUNK_DATA)RvaToVa(pbBase, rvaThunk);
        rvaThunk = (DWORD)iidp->FirstThunk;
        PIMAGE_THUNK_DATA pBoundThunk = (PIMAGE_THUNK_DATA)RvaToVa(pbBase, rvaThunk);

        Syelog(SYELOG_SEVERITY_INFORMATION,
               "%s [%p %p]\n", pszName, pThunk, pBoundThunk);

        DWORD nNames = 0;
        if (pThunk == NULL) {
            break;
        }

        for (; pThunk[nNames].u1.Ordinal; nNames++) {
            // Count the imports.
        }

        for (DWORD f = 0; f < nNames; f++) {
            DWORD nOrdinal = 0;
            PCHAR pszName = NULL;
            PDWORD pFunc = (PDWORD)pBoundThunk[f].u1.Function;
            DWORD rvaName = (DWORD)pThunk[f].u1.Ordinal;

            if (rvaName & IMAGE_ORDINAL_FLAG) {
                nOrdinal = IMAGE_ORDINAL(rvaName);
            }
            else {
                PIMAGE_IMPORT_BY_NAME pName
                    = (PIMAGE_IMPORT_BY_NAME)RvaToVa(pbBase, rvaName);
                if (pName) {
                    pszName = (PCHAR)pName->Name;
                }
            }
            Syelog(SYELOG_SEVERITY_INFORMATION,
                   "  %-32.32s %4I64d %p\n", pszName, nOrdinal, pFunc);
        }
    }
    return TRUE;
}

#if _MSC_VER >= 1900
#pragma warning(pop)
#endif

BOOL InstanceEnumerate(HINSTANCE hInst)
{
    WCHAR wzDllName[MAX_PATH];

    PIMAGE_NT_HEADERS pinh = NtHeadersForInstance(hInst);
    if (pinh && Real_GetModuleFileNameW(hInst, wzDllName, ARRAYSIZE(wzDllName))) {
        Syelog(SYELOG_SEVERITY_INFORMATION,
               "### %08lx: %-43.43ls %08x\n",
               hInst, wzDllName, pinh->OptionalHeader.CheckSum);
        return TRUE;
    }
    return FALSE;
}

BOOL ProcessEnumerate()
{
    Syelog(SYELOG_SEVERITY_INFORMATION,
           "######################################################### Binaries\n");
    for (HINSTANCE hInst = NULL; (hInst = DetourEnumerateModules(hInst)) != NULL;) {
        InstanceEnumerate(hInst);
    }
    Syelog(SYELOG_SEVERITY_INFORMATION, "###\n");

    return ImportEnumerate(GetModuleHandle(NULL));
}

//////////////////////////////////////////////////////////////////////////////
//
// DLL module information
//
BOOL ThreadAttach(HMODULE hDll)
{
    (void)hDll;

    if (s_nTlsIndent >= 0) {
        TlsSetValue(s_nTlsIndent, (PVOID)0);
    }
    if (s_nTlsThread >= 0) {
        LONG nThread = InterlockedIncrement(&s_nThreadCnt);
        TlsSetValue(s_nTlsThread, (PVOID)(LONG_PTR)nThread);
    }
    return TRUE;
}

BOOL ThreadDetach(HMODULE hDll)
{
    (void)hDll;

    if (s_nTlsIndent >= 0) {
        TlsSetValue(s_nTlsIndent, (PVOID)0);
    }
    if (s_nTlsThread >= 0) {
        TlsSetValue(s_nTlsThread, (PVOID)0);
    }
    return TRUE;
}

BOOL ProcessAttach(HMODULE hDll)
{
    s_bLog = FALSE;
    s_nTlsIndent = TlsAlloc();
    s_nTlsThread = TlsAlloc();
    ThreadAttach(hDll);

    WCHAR wzExeName[MAX_PATH];

    s_hInst = hDll;
    Real_GetModuleFileNameW(hDll, s_wzDllPath, ARRAYSIZE(s_wzDllPath));
    Real_GetModuleFileNameW(NULL, wzExeName, ARRAYSIZE(wzExeName));

    SyelogOpen("trclnk" DETOURS_STRINGIFY(DETOURS_BITS), SYELOG_FACILITY_APPLICATION);
    ProcessEnumerate();

    LONG error = AttachDetours();
    if (error != NO_ERROR) {
        Syelog(SYELOG_SEVERITY_FATAL, "### Error attaching detours: %d\n", error);
    }

    s_bLog = TRUE;
    return TRUE;
}

BOOL ProcessDetach(HMODULE hDll)
{
    ThreadDetach(hDll);
    s_bLog = FALSE;

    LONG error = DetachDetours();
    if (error != NO_ERROR) {
        Syelog(SYELOG_SEVERITY_FATAL, "### Error detaching detours: %d\n", error);
    }

    Syelog(SYELOG_SEVERITY_NOTICE, "### Closing.\n");
    SyelogClose(FALSE);

    if (s_nTlsIndent >= 0) {
        TlsFree(s_nTlsIndent);
    }
    if (s_nTlsThread >= 0) {
        TlsFree(s_nTlsThread);
    }
    return TRUE;
}

BOOL APIENTRY DllMain(HINSTANCE hModule, DWORD dwReason, PVOID lpReserved)
{
    (void)hModule;
    (void)lpReserved;

    if (DetourIsHelperProcess()) {
        return TRUE;
    }

    switch (dwReason) {
      case DLL_PROCESS_ATTACH:
        DetourRestoreAfterWith();
        return ProcessAttach(hModule);
      case DLL_PROCESS_DETACH:
        return ProcessDetach(hModule);
      case DLL_THREAD_ATTACH:
        return ThreadAttach(hModule);
      case DLL_THREAD_DETACH:
        return ThreadDetach(hModule);
    }
    return TRUE;
}
//
///////////////////////////////////////////////////////////////// End of File.

```

`samples/tracelnk/trclnk.rc`:

```rc
//////////////////////////////////////////////////////////////////////////////
//
//  Version information for trclnk.rc.
//
//  Microsoft Research Detours Package
//
//  Copyright (c) Microsoft Corporation.  All rights reserved.
//

#include "detver.h"

#define VER_INTERNALNAME_STR        "trclnk" DETOURS_STRINGIFY(DETOURS_BITS)
#define VER_ORIGINALFILENAME_STR    "trclnk" DETOURS_STRINGIFY(DETOURS_BITS) ".dll"
#define VER_FILEDESCRIPTION_STR     "Detours Dynamic Linking Trace Module"
#define VER_COMPANYNAME_STR         "Microsoft Corporation"

#include "common.ver"

```

`samples/tracemem/Makefile`:

```
##############################################################################
##
##  Utility to trace HeapAlloc APIs.
##
##  Microsoft Research Detours Package
##
##  Copyright (c) Microsoft Corporation.  All rights reserved.
##

!include ..\common.mak

LIBS=$(LIBS) kernel32.lib

all: dirs \
    $(BIND)\trcmem$(DETOURS_BITS).dll \
!IF $(DETOURS_SOURCE_BROWSING)==1
    $(OBJD)\trcmem$(DETOURS_BITS).bsc \
!ENDIF
    option

clean:
    -del *~ test.txt 2>nul
    -del $(BIND)\trcmem*.* 2>nul
    -rmdir /q /s $(OBJD) 2>nul

dirs:
    @if not exist $(BIND) mkdir $(BIND) && echo.   Created $(BIND)
    @if not exist $(OBJD) mkdir $(OBJD) && echo.   Created $(OBJD)

realclean: clean
    -rmdir /q /s $(OBJDS) 2>nul

##############################################################################

$(OBJD)\trcmem.obj : trcmem.cpp

$(OBJD)\trcmem.res : trcmem.rc

$(BIND)\trcmem$(DETOURS_BITS).dll : $(OBJD)\trcmem.obj $(OBJD)\trcmem.res $(DEPS)
    cl /LD $(CFLAGS) /Fe$@ /Fd$(@R).pdb \
        $(OBJD)\trcmem.obj $(OBJD)\trcmem.res \
        /link $(LINKFLAGS) /subsystem:console \
        /export:DetourFinishHelperProcess,@1,NONAME \
        $(LIBS)

$(OBJD)\trcmem$(DETOURS_BITS).bsc : $(OBJD)\trcmem.obj
    bscmake /v /n /o $@ $(OBJD)\trcmem.sbr

############################################### Install non-bit-size binaries.

!IF "$(DETOURS_OPTION_PROCESSOR)" != ""

$(OPTD)\trcmem$(DETOURS_OPTION_BITS).dll:
$(OPTD)\trcmem$(DETOURS_OPTION_BITS).pdb:

$(BIND)\trcmem$(DETOURS_OPTION_BITS).dll : $(OPTD)\trcmem$(DETOURS_OPTION_BITS).dll
    @if exist $? copy /y $? $(BIND) >nul && echo $@ copied from $(DETOURS_OPTION_PROCESSOR).
$(BIND)\trcmem$(DETOURS_OPTION_BITS).pdb : $(OPTD)\trcmem$(DETOURS_OPTION_BITS).pdb
    @if exist $? copy /y $? $(BIND) >nul && echo $@ copied from $(DETOURS_OPTION_PROCESSOR).

option: \
    $(BIND)\trcmem$(DETOURS_OPTION_BITS).dll \
    $(BIND)\trcmem$(DETOURS_OPTION_BITS).pdb \

!ELSE

option:

!ENDIF

##############################################################################

test: all
    @echo -------- Logging output to test.txt ------------
    start $(BIND)\syelogd.exe /o test.txt
    $(BIND)\sleep5.exe 1
    @echo -------- Should load trcmem$(DETOURS_BITS).dll dynamically using withdll.exe ------------
    $(BIND)\withdll -d:$(BIND)\trcmem$(DETOURS_BITS).dll $(BIND)\sleepold.exe
    @echo -------- Log from syelog -------------
    type test.txt

################################################################# End of File.

```

`samples/tracemem/trcmem.cpp`:

```cpp
//////////////////////////////////////////////////////////////////////////////
//
//  Detours Test Program (trcmem.cpp of trcmem.dll)
//
//  Microsoft Research Detours Package
//
//  Copyright (c) Microsoft Corporation.  All rights reserved.
//
#define _WIN32_WINNT        0x0400
#define WIN32
#define NT

#define DBG_TRACE   0

#include <windows.h>
#include <stdio.h>
#include "detours.h"
#include "syelog.h"

#define PULONG_PTR          PVOID
#define PLONG_PTR           PVOID
#define ULONG_PTR           PVOID
#define ENUMRESNAMEPROCA    PVOID
#define ENUMRESNAMEPROCW    PVOID
#define ENUMRESLANGPROCA    PVOID
#define ENUMRESLANGPROCW    PVOID
#define ENUMRESTYPEPROCA    PVOID
#define ENUMRESTYPEPROCW    PVOID
#define STGOPTIONS          PVOID

//////////////////////////////////////////////////////////////////////////////

#pragma warning(disable:4127)   // Many of our asserts are constants.

#define ASSERT_ALWAYS(x)   \
    do {                                                        \
    if (!(x)) {                                                 \
            AssertMessage(#x, __FILE__, __LINE__);              \
            DebugBreak();                                       \
    }                                                           \
    } while (0)

#ifndef NDEBUG
#define ASSERT(x)           ASSERT_ALWAYS(x)
#else
#define ASSERT(x)
#endif

#define UNUSED(c)    (c) = (c)

//////////////////////////////////////////////////////////////////////////////
static HMODULE s_hInst = NULL;
static CHAR s_szDllPath[MAX_PATH];

VOID _PrintEnter(const CHAR *psz, ...);
VOID _PrintExit(const CHAR *psz, ...);
VOID _Print(const CHAR *psz, ...);
VOID _VPrint(PCSTR msg, va_list args, PCHAR pszBuf, LONG cbBuf);

VOID AssertMessage(CONST PCHAR pszMsg, CONST PCHAR pszFile, ULONG nLine);

//////////////////////////////////////////////////////////////////////////////
// Trampolines
//
extern "C" {

    HANDLE (WINAPI *
            Real_CreateFileW)(LPCWSTR a0,
                              DWORD a1,
                              DWORD a2,
                              LPSECURITY_ATTRIBUTES a3,
                              DWORD a4,
                              DWORD a5,
                              HANDLE a6)
        = CreateFileW;

    BOOL (WINAPI *
          Real_WriteFile)(HANDLE hFile,
                          LPCVOID lpBuffer,
                          DWORD nNumberOfBytesToWrite,
                          LPDWORD lpNumberOfBytesWritten,
                          LPOVERLAPPED lpOverlapped)
        = WriteFile;
    BOOL (WINAPI *
          Real_FlushFileBuffers)(HANDLE hFile)
        = FlushFileBuffers;
    BOOL (WINAPI *
          Real_CloseHandle)(HANDLE hObject)
        = CloseHandle;

    BOOL (WINAPI *
          Real_WaitNamedPipeW)(LPCWSTR lpNamedPipeName, DWORD nTimeOut)
        = WaitNamedPipeW;
    BOOL (WINAPI *
          Real_SetNamedPipeHandleState)(HANDLE hNamedPipe,
                                        LPDWORD lpMode,
                                        LPDWORD lpMaxCollectionCount,
                                        LPDWORD lpCollectDataTimeout)
        = SetNamedPipeHandleState;

    DWORD (WINAPI *
           Real_GetCurrentProcessId)(VOID)
        = GetCurrentProcessId;
    VOID (WINAPI *
          Real_GetSystemTimeAsFileTime)(LPFILETIME lpSystemTimeAsFileTime)
        = GetSystemTimeAsFileTime;

    VOID (WINAPI *
          Real_InitializeCriticalSection)(LPCRITICAL_SECTION lpSection)
        = InitializeCriticalSection;
    VOID (WINAPI *
          Real_EnterCriticalSection)(LPCRITICAL_SECTION lpSection)
        = EnterCriticalSection;
    VOID (WINAPI *
          Real_LeaveCriticalSection)(LPCRITICAL_SECTION lpSection)
        = LeaveCriticalSection;
}

#if _MSC_VER < 1300
LPVOID (WINAPI *
        Real_HeapAlloc)(HANDLE hHeap, DWORD dwFlags, DWORD dwBytes)
    = HeapAlloc;
#else
LPVOID (WINAPI *
        Real_HeapAlloc)(HANDLE hHeap, DWORD dwFlags, DWORD_PTR dwBytes)
    = HeapAlloc;
#endif

DWORD (WINAPI * Real_GetModuleFileNameW)(HMODULE a0,
                                         LPWSTR a1,
                                         DWORD a2)
    = GetModuleFileNameW;

DWORD (WINAPI * Real_GetModuleFileNameA)(HMODULE a0,
                                         LPSTR a1,
                                         DWORD a2)
    = GetModuleFileNameA;

BOOL (WINAPI * Real_CreateProcessW)(LPCWSTR a0,
                                    LPWSTR a1,
                                    LPSECURITY_ATTRIBUTES a2,
                                    LPSECURITY_ATTRIBUTES a3,
                                    BOOL a4,
                                    DWORD a5,
                                    LPVOID a6,
                                    LPCWSTR a7,
                                    struct _STARTUPINFOW* a8,
                                    LPPROCESS_INFORMATION a9)
    = CreateProcessW;

//////////////////////////////////////////////////////////////////////////////
// Detours
//
#if _MSC_VER < 1300
LPVOID WINAPI Mine_HeapAlloc(HANDLE hHeap, DWORD dwFlags, DWORD dwBytes)
#else
LPVOID WINAPI Mine_HeapAlloc(HANDLE hHeap, DWORD dwFlags, DWORD_PTR dwBytes)
#endif
{
    _PrintEnter("HeapAlloc(%p, %x, %p))\n", hHeap, dwFlags, dwBytes);

    LPVOID rv = 0;
    __try {
        rv = Real_HeapAlloc(hHeap, dwFlags, dwBytes);
    } __finally {
        _PrintExit("HeapAlloc() -> %p\n", rv);
    };
    return rv;
}

BOOL WINAPI Mine_CreateProcessW(LPCWSTR lpApplicationName,
                                LPWSTR lpCommandLine,
                                LPSECURITY_ATTRIBUTES lpProcessAttributes,
                                LPSECURITY_ATTRIBUTES lpThreadAttributes,
                                BOOL bInheritHandles,
                                DWORD dwCreationFlags,
                                LPVOID lpEnvironment,
                                LPCWSTR lpCurrentDirectory,
                                LPSTARTUPINFOW lpStartupInfo,
                                LPPROCESS_INFORMATION lpProcessInformation)
{
    _PrintEnter("CreateProcessW(%ls,%ls,%p,%p,%x,%x,%p,%ls,%p,%p)\n",
                lpApplicationName,
                lpCommandLine,
                lpProcessAttributes,
                lpThreadAttributes,
                bInheritHandles,
                dwCreationFlags,
                lpEnvironment,
                lpCurrentDirectory,
                lpStartupInfo,
                lpProcessInformation);

    _Print("Calling DetourCreateProcessWithDllExW(,%hs)\n", s_szDllPath);

    BOOL rv = 0;
    __try {
        rv = DetourCreateProcessWithDllExW(lpApplicationName,
                                           lpCommandLine,
                                           lpProcessAttributes,
                                           lpThreadAttributes,
                                           bInheritHandles,
                                           dwCreationFlags,
                                           lpEnvironment,
                                           lpCurrentDirectory,
                                           lpStartupInfo,
                                           lpProcessInformation,
                                           s_szDllPath,
                                           Real_CreateProcessW);
    } __finally {
        _PrintExit("CreateProcessW(,,,,,,,,,) -> %x\n", rv);
    };
    return rv;
}

//////////////////////////////////////////////////////////////////////////////
// AttachDetours
//
PCHAR DetRealName(PCHAR psz)
{
    PCHAR pszBeg = psz;
    // Move to end of name.
    while (*psz) {
        psz++;
    }
    // Move back through A-Za-z0-9 names.
    while (psz > pszBeg &&
           ((psz[-1] >= 'A' && psz[-1] <= 'Z') ||
            (psz[-1] >= 'a' && psz[-1] <= 'z') ||
            (psz[-1] >= '0' && psz[-1] <= '9'))) {
        psz--;
    }
    return psz;
}

VOID DetAttach(PVOID *ppbReal, PVOID pbMine, PCHAR psz)
{
    LONG l = DetourAttach(ppbReal, pbMine);
    if (l != 0) {
        Syelog(SYELOG_SEVERITY_NOTICE,
               "Attach failed: `%s': error %d\n", DetRealName(psz), l);
    }
}

VOID DetDetach(PVOID *ppbReal, PVOID pbMine, PCHAR psz)
{
    LONG l = DetourDetach(ppbReal, pbMine);
    if (l != 0) {
        Syelog(SYELOG_SEVERITY_NOTICE,
               "Detach failed: `%s': error %d\n", DetRealName(psz), l);
    }
}

#define ATTACH(x)       DetAttach(&(PVOID&)Real_##x,Mine_##x,#x)
#define DETACH(x)       DetDetach(&(PVOID&)Real_##x,Mine_##x,#x)

LONG AttachDetours(VOID)
{
    DetourTransactionBegin();
    DetourUpdateThread(GetCurrentThread());

    ATTACH(CreateProcessW);
    ATTACH(HeapAlloc);

    return DetourTransactionCommit();
}

LONG DetachDetours(VOID)
{
    DetourTransactionBegin();
    DetourUpdateThread(GetCurrentThread());

    DETACH(CreateProcessW);
    DETACH(HeapAlloc);

    return DetourTransactionCommit();
}

////////////////////////////////////////////////////////////// Logging System.
//
static BOOL s_bLog = FALSE;
static LONG s_nTlsIndent = -1;
static LONG s_nTlsThread = -1;
static LONG s_nThreadCnt = 0;

VOID _PrintEnter(const CHAR *psz, ...)
{
    DWORD dwErr = GetLastError();

    LONG nIndent = 0;
    LONG nThread = 0;
    if (s_nTlsIndent >= 0) {
        nIndent = (LONG)(LONG_PTR)TlsGetValue(s_nTlsIndent);
        TlsSetValue(s_nTlsIndent, (PVOID)(LONG_PTR)(nIndent + 1));
    }
    if (s_nTlsThread >= 0) {
        nThread = (LONG)(LONG_PTR)TlsGetValue(s_nTlsThread);
    }

    if (s_bLog && psz) {
        CHAR szBuf[1024];
        PCHAR pszBuf = szBuf;
        PCHAR pszEnd = szBuf + ARRAYSIZE(szBuf) - 1;
        LONG nLen = (nIndent > 0) ? (nIndent < 35 ? nIndent * 2 : 70) : 0;
        *pszBuf++ = (CHAR)('0' + ((nThread / 100) % 10));
        *pszBuf++ = (CHAR)('0' + ((nThread / 10) % 10));
        *pszBuf++ = (CHAR)('0' + ((nThread / 1) % 10));
        *pszBuf++ = ' ';
        while (nLen-- > 0) {
            *pszBuf++ = ' ';
        }

        va_list  args;
        va_start(args, psz);

        while ((*pszBuf++ = *psz++) != 0 && pszBuf < pszEnd) {
            // Copy characters.
        }
        *pszEnd = '\0';
        SyelogV(SYELOG_SEVERITY_INFORMATION, szBuf, args);

        va_end(args);
    }
    SetLastError(dwErr);
}

VOID _PrintExit(const CHAR *psz, ...)
{
    DWORD dwErr = GetLastError();

    LONG nIndent = 0;
    LONG nThread = 0;
    if (s_nTlsIndent >= 0) {
        nIndent = (LONG)(LONG_PTR)TlsGetValue(s_nTlsIndent) - 1;
        ASSERT(nIndent >= 0);
        TlsSetValue(s_nTlsIndent, (PVOID)(LONG_PTR)nIndent);
    }
    if (s_nTlsThread >= 0) {
        nThread = (LONG)(LONG_PTR)TlsGetValue(s_nTlsThread);
    }

    if (s_bLog && psz) {
        CHAR szBuf[1024];
        PCHAR pszBuf = szBuf;
        PCHAR pszEnd = szBuf + ARRAYSIZE(szBuf) - 1;
        LONG nLen = (nIndent > 0) ? (nIndent < 35 ? nIndent * 2 : 70) : 0;
        *pszBuf++ = (CHAR)('0' + ((nThread / 100) % 10));
        *pszBuf++ = (CHAR)('0' + ((nThread / 10) % 10));
        *pszBuf++ = (CHAR)('0' + ((nThread / 1) % 10));
        *pszBuf++ = ' ';
        while (nLen-- > 0) {
            *pszBuf++ = ' ';
        }

        va_list  args;
        va_start(args, psz);

        while ((*pszBuf++ = *psz++) != 0 && pszBuf < pszEnd) {
            // Copy characters.
        }
        *pszEnd = '\0';
        SyelogV(SYELOG_SEVERITY_INFORMATION,
                szBuf, args);

        va_end(args);
    }
    SetLastError(dwErr);
}

VOID _Print(const CHAR *psz, ...)
{
    DWORD dwErr = GetLastError();

    LONG nIndent = 0;
    LONG nThread = 0;
    if (s_nTlsIndent >= 0) {
        nIndent = (LONG)(LONG_PTR)TlsGetValue(s_nTlsIndent);
    }
    if (s_nTlsThread >= 0) {
        nThread = (LONG)(LONG_PTR)TlsGetValue(s_nTlsThread);
    }

    if (s_bLog && psz) {
        CHAR szBuf[1024];
        PCHAR pszBuf = szBuf;
        PCHAR pszEnd = szBuf + ARRAYSIZE(szBuf) - 1;
        LONG nLen = (nIndent > 0) ? (nIndent < 35 ? nIndent * 2 : 70) : 0;
        *pszBuf++ = (CHAR)('0' + ((nThread / 100) % 10));
        *pszBuf++ = (CHAR)('0' + ((nThread / 10) % 10));
        *pszBuf++ = (CHAR)('0' + ((nThread / 1) % 10));
        *pszBuf++ = ' ';
        while (nLen-- > 0) {
            *pszBuf++ = ' ';
        }

        va_list  args;
        va_start(args, psz);

        while ((*pszBuf++ = *psz++) != 0 && pszBuf < pszEnd) {
            // Copy characters.
        }
        *pszEnd = '\0';
        SyelogV(SYELOG_SEVERITY_INFORMATION,
                szBuf, args);

        va_end(args);
    }

    SetLastError(dwErr);
}

VOID AssertMessage(CONST PCHAR pszMsg, CONST PCHAR pszFile, ULONG nLine)
{
    Syelog(SYELOG_SEVERITY_FATAL,
           "ASSERT(%s) failed in %s, line %d.\n", pszMsg, pszFile, nLine);
}

//////////////////////////////////////////////////////////////////////////////
//
// DLL module information
//
BOOL ThreadAttach(HMODULE hDll)
{
    (void)hDll;

    if (s_nTlsIndent >= 0) {
        TlsSetValue(s_nTlsIndent, (PVOID)0);
    }
    if (s_nTlsThread >= 0) {
        LONG nThread = InterlockedIncrement(&s_nThreadCnt);
        TlsSetValue(s_nTlsThread, (PVOID)(LONG_PTR)nThread);
    }
    return TRUE;
}

BOOL ThreadDetach(HMODULE hDll)
{
    (void)hDll;

    if (s_nTlsIndent >= 0) {
        TlsSetValue(s_nTlsIndent, (PVOID)0);
    }
    if (s_nTlsThread >= 0) {
        TlsSetValue(s_nTlsThread, (PVOID)0);
    }
    return TRUE;
}

BOOL ProcessAttach(HMODULE hDll)
{
    s_bLog = FALSE;
    s_nTlsIndent = TlsAlloc();
    s_nTlsThread = TlsAlloc();

    WCHAR wzExePath[MAX_PATH];

    s_hInst = hDll;
    Real_GetModuleFileNameA(s_hInst, s_szDllPath, ARRAYSIZE(s_szDllPath));
    Real_GetModuleFileNameW(NULL, wzExePath, ARRAYSIZE(wzExePath));

    SyelogOpen("trcmem" DETOURS_STRINGIFY(DETOURS_BITS), SYELOG_FACILITY_APPLICATION);
    Syelog(SYELOG_SEVERITY_INFORMATION, "##########################################\n");
    Syelog(SYELOG_SEVERITY_INFORMATION, "### %ls\n", wzExePath);

    LONG error = AttachDetours();
    if (error != NO_ERROR) {
        Syelog(SYELOG_SEVERITY_FATAL, "### Error attaching detours: %d\n", error);
    }

    ThreadAttach(hDll);

    s_bLog = TRUE;
    return TRUE;
}

BOOL ProcessDetach(HMODULE hDll)
{
    ThreadDetach(hDll);
    s_bLog = FALSE;

    LONG error = DetachDetours();
    if (error != NO_ERROR) {
        Syelog(SYELOG_SEVERITY_FATAL, "### Error detaching detours: %d\n", error);
    }

    Syelog(SYELOG_SEVERITY_NOTICE, "### Closing.\n");
    SyelogClose(FALSE);

    if (s_nTlsIndent >= 0) {
        TlsFree(s_nTlsIndent);
    }
    if (s_nTlsThread >= 0) {
        TlsFree(s_nTlsThread);
    }
    return TRUE;
}

BOOL APIENTRY DllMain(HINSTANCE hModule, DWORD dwReason, PVOID lpReserved)
{
    (void)hModule;
    (void)lpReserved;

    if (DetourIsHelperProcess()) {
        return TRUE;
    }

    switch (dwReason) {
      case DLL_PROCESS_ATTACH:
        DetourRestoreAfterWith();
        return ProcessAttach(hModule);
      case DLL_PROCESS_DETACH:
        return ProcessDetach(hModule);
      case DLL_THREAD_ATTACH:
        return ThreadAttach(hModule);
      case DLL_THREAD_DETACH:
        return ThreadDetach(hModule);
    }
    return TRUE;
}
//
///////////////////////////////////////////////////////////////// End of File.

```

`samples/tracemem/trcmem.rc`:

```rc
//////////////////////////////////////////////////////////////////////////////
//
//  Version information for trcmem.rc.
//
//  Microsoft Research Detours Package
//
//  Copyright (c) Microsoft Corporation.  All rights reserved.
//

#include "detver.h"

#define VER_INTERNALNAME_STR        "trcmem" DETOURS_STRINGIFY(DETOURS_BITS)
#define VER_ORIGINALFILENAME_STR    "trcmem" DETOURS_STRINGIFY(DETOURS_BITS) ".dll"
#define VER_FILEDESCRIPTION_STR     "Detours Memory Trace Module"
#define VER_COMPANYNAME_STR         "Microsoft Corporation"

#include "common.ver"

```

`samples/tracereg/Makefile`:

```
##############################################################################
##
##  Utility to registry and file access APIs.
##
##  Microsoft Research Detours Package
##
##  Copyright (c) Microsoft Corporation.  All rights reserved.
##

!include ..\common.mak

LIBS=$(LIBS) kernel32.lib advapi32.lib

all: dirs \
    $(BIND)\trcreg$(DETOURS_BITS).dll \
!IF $(DETOURS_SOURCE_BROWSING)==1
    $(OBJD)\trcreg$(DETOURS_BITS).bsc \
!ENDIF
    option

dirs:
    @if not exist $(BIND) mkdir $(BIND) && echo.   Created $(BIND)
    @if not exist $(OBJD) mkdir $(OBJD) && echo.   Created $(OBJD)

clean:
    -del *~ test.txt 2>nul
    -del $(BIND)\trcreg*.* 2>nul
    -rmdir /q /s $(OBJD) 2>nul

realclean: clean
    -rmdir /q /s $(OBJDS) 2>nul

##############################################################################

$(OBJD)\trcreg.obj : trcreg.cpp

$(OBJD)\trcreg.res : trcreg.rc

$(BIND)\trcreg$(DETOURS_BITS).dll : $(OBJD)\trcreg.obj $(OBJD)\trcreg.res $(DEPS)
    cl /LD $(CFLAGS) /Fe$@ /Fd$(@R).pdb \
        $(OBJD)\trcreg.obj $(OBJD)\trcreg.res \
        /link $(LINKFLAGS) /subsystem:console \
        /export:DetourFinishHelperProcess,@1,NONAME \
        $(LIBS)

$(OBJD)\trcreg$(DETOURS_BITS).bsc : $(OBJD)\trcreg.obj
    bscmake /v /n /o $@ $(OBJD)\trcreg.sbr

############################################### Install non-bit-size binaries.

!IF "$(DETOURS_OPTION_PROCESSOR)" != ""

$(OPTD)\trcreg$(DETOURS_OPTION_BITS).dll:
$(OPTD)\trcreg$(DETOURS_OPTION_BITS).pdb:

$(BIND)\trcreg$(DETOURS_OPTION_BITS).dll : $(OPTD)\trcreg$(DETOURS_OPTION_BITS).dll
    @if exist $? copy /y $? $(BIND) >nul && echo $@ copied from $(DETOURS_OPTION_PROCESSOR).
$(BIND)\trcreg$(DETOURS_OPTION_BITS).pdb : $(OPTD)\trcreg$(DETOURS_OPTION_BITS).pdb
    @if exist $? copy /y $? $(BIND) >nul && echo $@ copied from $(DETOURS_OPTION_PROCESSOR).

option: \
    $(BIND)\trcreg$(DETOURS_OPTION_BITS).dll \
    $(BIND)\trcreg$(DETOURS_OPTION_BITS).pdb \

!ELSE

option:

!ENDIF

##############################################################################

test: all
    @echo -------- Logging output to test.txt ------------
    start $(BIND)\syelogd.exe /o test.txt
    $(BIND)\sleep5.exe 1
    @echo -------- Should load trcreg$(DETOURS_BITS).dll dynamically using withdll.exe ------------
    $(BIND)\withdll -d:$(BIND)\trcreg$(DETOURS_BITS).dll $(BIND)\sleepold.exe
    @echo -------- Log from syelog -------------
    type test.txt

################################################################# End of File.

```

`samples/tracereg/trcreg.cpp`:

```cpp
//////////////////////////////////////////////////////////////////////////////
//
//  Detours Test Program (trcreg.cpp of trcreg.dll)
//
//  Microsoft Research Detours Package
//
//  Copyright (c) Microsoft Corporation.  All rights reserved.
//
#define _WIN32_WINNT        0x0400
#define WIN32
#define NT

#define DBG_TRACE   0

#include <windows.h>
#include <stdio.h>
#include "detours.h"
#include "syelog.h"

#define PULONG_PTR          PVOID
#define PLONG_PTR           PVOID
#define ULONG_PTR           PVOID
#define ENUMRESNAMEPROCA    PVOID
#define ENUMRESNAMEPROCW    PVOID
#define ENUMRESLANGPROCA    PVOID
#define ENUMRESLANGPROCW    PVOID
#define ENUMRESTYPEPROCA    PVOID
#define ENUMRESTYPEPROCW    PVOID
#define STGOPTIONS          PVOID

//////////////////////////////////////////////////////////////////////////////
#pragma warning(disable:4127)   // Many of our asserts are constants.

#define ASSERT_ALWAYS(x)   \
    do {                                                        \
    if (!(x)) {                                                 \
            AssertMessage(#x, __FILE__, __LINE__);              \
            DebugBreak();                                       \
    }                                                           \
    } while (0)

#ifndef NDEBUG
#define ASSERT(x)           ASSERT_ALWAYS(x)
#else
#define ASSERT(x)
#endif

#define UNUSED(c)       (c) = (c)

//////////////////////////////////////////////////////////////////////////////
static HMODULE s_hInst = NULL;
static CHAR s_szDllPath[MAX_PATH];

BOOL ProcessEnumerate();
BOOL InstanceEnumerate(HINSTANCE hInst);

VOID _PrintEnter(PCSTR psz, ...);
VOID _PrintExit(PCSTR psz, ...);
VOID _Print(PCSTR psz, ...);

VOID AssertMessage(CONST PCHAR pszMsg, CONST PCHAR pszFile, ULONG nLine);

//////////////////////////////////////////////////////////////////////////////
//
extern "C" {
    HANDLE (WINAPI *
            Real_CreateFileW)(LPCWSTR a0,
                              DWORD a1,
                              DWORD a2,
                              LPSECURITY_ATTRIBUTES a3,
                              DWORD a4,
                              DWORD a5,
                              HANDLE a6)
        = CreateFileW;

    BOOL (WINAPI *
          Real_WriteFile)(HANDLE hFile,
                          LPCVOID lpBuffer,
                          DWORD nNumberOfBytesToWrite,
                          LPDWORD lpNumberOfBytesWritten,
                          LPOVERLAPPED lpOverlapped)
        = WriteFile;
    BOOL (WINAPI *
          Real_FlushFileBuffers)(HANDLE hFile)
        = FlushFileBuffers;
    BOOL (WINAPI *
          Real_CloseHandle)(HANDLE hObject)
        = CloseHandle;

    BOOL (WINAPI *
          Real_WaitNamedPipeW)(LPCWSTR lpNamedPipeName, DWORD nTimeOut)
        = WaitNamedPipeW;
    BOOL (WINAPI *
          Real_SetNamedPipeHandleState)(HANDLE hNamedPipe,
                                        LPDWORD lpMode,
                                        LPDWORD lpMaxCollectionCount,
                                        LPDWORD lpCollectDataTimeout)
        = SetNamedPipeHandleState;

    DWORD (WINAPI *
           Real_GetCurrentProcessId)(VOID)
        = GetCurrentProcessId;
    VOID (WINAPI *
          Real_GetSystemTimeAsFileTime)(LPFILETIME lpSystemTimeAsFileTime)
        = GetSystemTimeAsFileTime;

    VOID (WINAPI *
          Real_InitializeCriticalSection)(LPCRITICAL_SECTION lpSection)
        = InitializeCriticalSection;
    VOID (WINAPI *
          Real_EnterCriticalSection)(LPCRITICAL_SECTION lpSection)
        = EnterCriticalSection;
    VOID (WINAPI *
          Real_LeaveCriticalSection)(LPCRITICAL_SECTION lpSection)
        = LeaveCriticalSection;
}

//////////////////////////////////////////////////////////////////////////////
//

BOOL (WINAPI * Real_CopyFileExA)(LPCSTR a0,
                                 LPCSTR a1,
                                 LPPROGRESS_ROUTINE a2,
                                 LPVOID a3,
                                 LPBOOL a4,
                                 DWORD a5)
    = CopyFileExA;

BOOL (WINAPI * Real_CopyFileExW)(LPCWSTR a0,
                                 LPCWSTR a1,
                                 LPPROGRESS_ROUTINE a2,
                                 LPVOID a3,
                                 LPBOOL a4,
                                 DWORD a5)
    = CopyFileExW;

BOOL (WINAPI * Real_CreateDirectoryExW)(LPCWSTR a0,
                                        LPCWSTR a1,
                                        LPSECURITY_ATTRIBUTES a2)
    = CreateDirectoryExW;

BOOL (WINAPI * Real_CreateDirectoryW)(LPCWSTR a0,
                                      LPSECURITY_ATTRIBUTES a1)
    = CreateDirectoryW;

BOOL (WINAPI * Real_CreateProcessW)(LPCWSTR lpApplicationName,
                                    LPWSTR lpCommandLine,
                                    LPSECURITY_ATTRIBUTES lpProcessAttributes,
                                    LPSECURITY_ATTRIBUTES lpThreadAttributes,
                                    BOOL bInheritHandles,
                                    DWORD dwCreationFlags,
                                    LPVOID lpEnvironment,
                                    LPCWSTR lpCurrentDirectory,
                                    LPSTARTUPINFOW lpStartupInfo,
                                    LPPROCESS_INFORMATION lpProcessInformation)
    = CreateProcessW;

BOOL (WINAPI * Real_DeleteFileA)(LPCSTR a0)
    = DeleteFileA;

BOOL (WINAPI * Real_DeleteFileW)(LPCWSTR a0)
    = DeleteFileW;

HANDLE (WINAPI * Real_FindFirstFileExA)(LPCSTR a0,
                                        FINDEX_INFO_LEVELS a1,
                                        LPVOID a2,
                                        FINDEX_SEARCH_OPS a3,
                                        LPVOID a4,
                                        DWORD a5)
    = FindFirstFileExA;

HANDLE (WINAPI * Real_FindFirstFileExW)(LPCWSTR a0,
                                        FINDEX_INFO_LEVELS a1,
                                        LPVOID a2,
                                        FINDEX_SEARCH_OPS a3,
                                        LPVOID a4,
                                        DWORD a5)
    = FindFirstFileExW;

DWORD (WINAPI * Real_GetFileAttributesW)(LPCWSTR a0)
    = GetFileAttributesW;

DWORD (WINAPI * Real_GetModuleFileNameW)(HMODULE a0,
                                         LPWSTR a1,
                                         DWORD a2)
    = GetModuleFileNameW;

DWORD (WINAPI * Real_GetModuleFileNameA)(HMODULE a0,
                                         LPSTR a1,
                                         DWORD a2)
    = GetModuleFileNameA;

FARPROC (WINAPI * Real_GetProcAddress)(struct HINSTANCE__* a0,
                                       LPCSTR a1)
    = GetProcAddress;

HMODULE (WINAPI * Real_LoadLibraryExW)(LPCWSTR a0,
                                       HANDLE a1,
                                       DWORD a2)
    = LoadLibraryExW;

BOOL (WINAPI * Real_MoveFileA)(LPCSTR a0,
                               LPCSTR a1)
    = MoveFileA;

BOOL (WINAPI * Real_MoveFileExA)(LPCSTR a0,
                                 LPCSTR a1,
                                 DWORD a2)
    = MoveFileExA;

BOOL (WINAPI * Real_MoveFileExW)(LPCWSTR a0,
                                 LPCWSTR a1,
                                 DWORD a2)
    = MoveFileExW;

BOOL (WINAPI * Real_MoveFileW)(LPCWSTR a0,
                               LPCWSTR a1)
    = MoveFileW;

HFILE (WINAPI * Real_OpenFile)(LPCSTR a0,
                               struct _OFSTRUCT* a1,
                               UINT a2)
    = OpenFile;

LONG (WINAPI * Real_RegCreateKeyExA)(HKEY a0,
                                     LPCSTR a1,
                                     DWORD a2,
                                     LPSTR a3,
                                     DWORD a4,
                                     REGSAM a5,
                                     LPSECURITY_ATTRIBUTES a6,
                                     PHKEY a7,
                                     LPDWORD a8)
    = RegCreateKeyExA;

LONG (WINAPI * Real_RegCreateKeyExW)(HKEY a0,
                                     LPCWSTR a1,
                                     DWORD a2,
                                     LPWSTR a3,
                                     DWORD a4,
                                     REGSAM a5,
                                     LPSECURITY_ATTRIBUTES a6,
                                     PHKEY a7,
                                     LPDWORD a8)
    = RegCreateKeyExW;

LONG (WINAPI * Real_RegDeleteKeyA)(HKEY a0,
                                   LPCSTR a1)
    = RegDeleteKeyA;

LONG (WINAPI * Real_RegDeleteKeyW)(HKEY a0,
                                   LPCWSTR a1)
    = RegDeleteKeyW;

LONG (WINAPI * Real_RegDeleteValueA)(HKEY a0,
                                     LPCSTR a1)
    = RegDeleteValueA;


LONG (WINAPI * Real_RegDeleteValueW)(HKEY a0,
                                     LPCWSTR a1)
    = RegDeleteValueW;

LONG (WINAPI * Real_RegEnumKeyExA)(HKEY a0,
                                   DWORD a1,
                                   LPSTR a2,
                                   LPDWORD a3,
                                   LPDWORD a4,
                                   LPSTR a5,
                                   LPDWORD a6,
                                   struct _FILETIME* a7)
    = RegEnumKeyExA;

LONG (WINAPI * Real_RegEnumKeyExW)(HKEY a0,
                                   DWORD a1,
                                   LPWSTR a2,
                                   LPDWORD a3,
                                   LPDWORD a4,
                                   LPWSTR a5,
                                   LPDWORD a6,
                                   struct _FILETIME* a7)
    = RegEnumKeyExW;

LONG (WINAPI * Real_RegEnumValueA)(HKEY a0,
                                   DWORD a1,
                                   LPSTR a2,
                                   LPDWORD a3,
                                   LPDWORD a4,
                                   LPDWORD a5,
                                   LPBYTE a6,
                                   LPDWORD a7)
    = RegEnumValueA;

LONG (WINAPI * Real_RegEnumValueW)(HKEY a0,
                                   DWORD a1,
                                   LPWSTR a2,
                                   LPDWORD a3,
                                   LPDWORD a4,
                                   LPDWORD a5,
                                   LPBYTE a6,
                                   LPDWORD a7)
    = RegEnumValueW;

LONG (WINAPI * Real_RegOpenKeyExA)(HKEY a0,
                                   LPCSTR a1,
                                   DWORD a2,
                                   REGSAM a3,
                                   PHKEY a4)
    = RegOpenKeyExA;

LONG (WINAPI * Real_RegOpenKeyExW)(HKEY a0,
                                   LPCWSTR a1,
                                   DWORD a2,
                                   REGSAM a3,
                                   PHKEY a4)
    = RegOpenKeyExW;

LONG (WINAPI * Real_RegQueryInfoKeyA)(HKEY a0,
                                      LPSTR a1,
                                      LPDWORD a2,
                                      LPDWORD a3,
                                      LPDWORD a4,
                                      LPDWORD a5,
                                      LPDWORD a6,
                                      LPDWORD a7,
                                      LPDWORD a8,
                                      LPDWORD a9,
                                      LPDWORD a10,
                                      struct _FILETIME* a11)
    = RegQueryInfoKeyA;

LONG (WINAPI * Real_RegQueryInfoKeyW)(HKEY a0,
                                      LPWSTR a1,
                                      LPDWORD a2,
                                      LPDWORD a3,
                                      LPDWORD a4,
                                      LPDWORD a5,
                                      LPDWORD a6,
                                      LPDWORD a7,
                                      LPDWORD a8,
                                      LPDWORD a9,
                                      LPDWORD a10,
                                      struct _FILETIME* a11)
    = RegQueryInfoKeyW;

LONG (WINAPI * Real_RegQueryValueExA)(HKEY a0,
                                      LPCSTR a1,
                                      LPDWORD a2,
                                      LPDWORD a3,
                                      LPBYTE a4,
                                      LPDWORD a5)
    = RegQueryValueExA;

LONG (WINAPI * Real_RegQueryValueExW)(HKEY a0,
                                      LPCWSTR a1,
                                      LPDWORD a2,
                                      LPDWORD a3,
                                      LPBYTE a4,
                                      LPDWORD a5)
    = RegQueryValueExW;

LONG (WINAPI * Real_RegSetValueExA)(HKEY a0,
                                    LPCSTR a1,
                                    DWORD a2,
                                    DWORD a3,
                                    const BYTE* a4,
                                    DWORD a5)
    = RegSetValueExA;

LONG (WINAPI * Real_RegSetValueExW)(HKEY a0,
                                    LPCWSTR a1,
                                    DWORD a2,
                                    DWORD a3,
                                    const BYTE* a4,
                                    DWORD a5)
    = RegSetValueExW;

HFILE (WINAPI * Real__lcreat)(LPCSTR a0,
                              int a1)
    = _lcreat;

HFILE (WINAPI * Real__lopen)(LPCSTR a0,
                             int a1)
    = _lopen;

/////////////////////////////////////////////////////////////
// Detours
//
BOOL WINAPI Mine_WaitNamedPipeW(LPCWSTR lpNamedPipeName, DWORD nTimeOut)
{
    return Real_WaitNamedPipeW(lpNamedPipeName, nTimeOut);
}

BOOL WINAPI Mine_CloseHandle(HANDLE hObject)
{
    return Real_CloseHandle(hObject);
}

VOID WINAPI Mine_GetSystemTimeAsFileTime(LPFILETIME lpSystemTimeAsFileTime)
{
    Real_GetSystemTimeAsFileTime(lpSystemTimeAsFileTime);
}

BOOL WINAPI Mine_SetNamedPipeHandleState(HANDLE hNamedPipe,
                                            LPDWORD lpMode,
                                            LPDWORD lpMaxCollectionCount,
                                            LPDWORD lpCollectDataTimeout)
{
    return Real_SetNamedPipeHandleState(hNamedPipe,
                                        lpMode,
                                        lpMaxCollectionCount,
                                        lpCollectDataTimeout);
}

BOOL WINAPI Mine_WriteFile(HANDLE hFile,
                           LPCVOID lpBuffer,
                           DWORD nNumberOfBytesToWrite,
                           LPDWORD lpNumberOfBytesWritten,
                           LPOVERLAPPED lpOverlapped)
{
    return Real_WriteFile(hFile,
                          lpBuffer,
                          nNumberOfBytesToWrite,
                          lpNumberOfBytesWritten,
                          lpOverlapped);
}

BOOL WINAPI Mine_CreateProcessW(LPCWSTR lpApplicationName,
                                LPWSTR lpCommandLine,
                                LPSECURITY_ATTRIBUTES lpProcessAttributes,
                                LPSECURITY_ATTRIBUTES lpThreadAttributes,
                                BOOL bInheritHandles,
                                DWORD dwCreationFlags,
                                LPVOID lpEnvironment,
                                LPCWSTR lpCurrentDirectory,
                                LPSTARTUPINFOW lpStartupInfo,
                                LPPROCESS_INFORMATION lpProcessInformation)
{
    _PrintEnter("CreateProcessW(%ls,%ls,%p,%p,%x,%x,%p,%ls,%p,%p)\n",
                lpApplicationName,
                lpCommandLine,
                lpProcessAttributes,
                lpThreadAttributes,
                bInheritHandles,
                dwCreationFlags,
                lpEnvironment,
                lpCurrentDirectory,
                lpStartupInfo,
                lpProcessInformation);

    _Print("Calling DetourCreateProcessWithDllExW(,%hs)\n", s_szDllPath);

    BOOL rv = 0;
    __try {
        rv = DetourCreateProcessWithDllExW(lpApplicationName,
                                           lpCommandLine,
                                           lpProcessAttributes,
                                           lpThreadAttributes,
                                           bInheritHandles,
                                           dwCreationFlags,
                                           lpEnvironment,
                                           lpCurrentDirectory,
                                           lpStartupInfo,
                                           lpProcessInformation,
                                           s_szDllPath,
                                           Real_CreateProcessW);
    } __finally {
        _PrintExit("CreateProcessW(,,,,,,,,,) -> %x\n", rv);
    };
    return rv;
}

//
//////////////////////////////////////////////////////////////////////////////

BOOL WINAPI Mine_CopyFileExA(LPCSTR a0,
                             LPCSTR a1,
                             LPPROGRESS_ROUTINE a2,
                             LPVOID a3,
                             LPBOOL a4,
                             DWORD a5)
{
    _PrintEnter("CopyFileExA(%hs,%hs,%p,%p,%p,%x)\n", a0, a1, a2, a3, a4, a5);

    BOOL rv = 0;
    __try {
        rv = Real_CopyFileExA(a0, a1, a2, a3, a4, a5);
    } __finally {
        _PrintExit("CopyFileExA(,,,,,) -> %x\n", rv);
    };
    return rv;
}

BOOL WINAPI Mine_CopyFileExW(LPCWSTR a0,
                             LPCWSTR a1,
                             LPPROGRESS_ROUTINE a2,
                             LPVOID a3,
                             LPBOOL a4,
                             DWORD a5)
{
    _PrintEnter("CopyFileExW(%ls,%ls,%p,%p,%p,%x)\n", a0, a1, a2, a3, a4, a5);

    BOOL rv = 0;
    __try {
        rv = Real_CopyFileExW(a0, a1, a2, a3, a4, a5);
    } __finally {
        _PrintExit("CopyFileExW(,,,,,) -> %x\n", rv);
    };
    return rv;
}

BOOL WINAPI Mine_CreateDirectoryExW(LPCWSTR a0,
                                    LPCWSTR a1,
                                    LPSECURITY_ATTRIBUTES a2)
{
    _PrintEnter("CreateDirectoryExW(%ls,%ls,%p)\n", a0, a1, a2);

    BOOL rv = 0;
    __try {
        rv = Real_CreateDirectoryExW(a0, a1, a2);
    } __finally {
        _PrintExit("CreateDirectoryExW(,,) -> %x\n", rv);
    };
    return rv;
}

BOOL WINAPI Mine_CreateDirectoryW(LPCWSTR a0,
                                  LPSECURITY_ATTRIBUTES a1)
{
    _PrintEnter("CreateDirectoryW(%ls,%p)\n", a0, a1);

    BOOL rv = 0;
    __try {
        rv = Real_CreateDirectoryW(a0, a1);
    } __finally {
        _PrintExit("CreateDirectoryW(,) -> %x\n", rv);
    };
    return rv;
}

HANDLE WINAPI Mine_CreateFileW(LPCWSTR a0,
                               DWORD a1,
                               DWORD a2,
                               LPSECURITY_ATTRIBUTES a3,
                               DWORD a4,
                               DWORD a5,
                               HANDLE a6)
{
    _PrintEnter(NULL);
    HANDLE rv = 0;
    __try {
        rv = Real_CreateFileW(a0, a1, a2, a3, a4, a5, a6);
    } __finally {
        _PrintExit("CreateFileW(%ls,%x,%x,%p,%x,%x,%p) -> %p\n",
                   a0, a1, a2, a3, a4, a5, a6, rv);
    };
    return rv;
}

BOOL WINAPI Mine_DeleteFileA(LPCSTR a0)
{
    _PrintEnter("DeleteFileA(%hs)\n", a0);

    BOOL rv = 0;
    __try {
        rv = Real_DeleteFileA(a0);
    } __finally {
        _PrintExit("DeleteFileA() -> %x\n", rv);
    };
    return rv;
}

BOOL WINAPI Mine_DeleteFileW(LPCWSTR a0)
{
    _PrintEnter("DeleteFileW(%ls)\n", a0);

    BOOL rv = 0;
    __try {
        rv = Real_DeleteFileW(a0);
    } __finally {
        _PrintExit("DeleteFileW() -> %x\n", rv);
    };
    return rv;
}

HANDLE WINAPI Mine_FindFirstFileExA(LPCSTR a0,
                                    FINDEX_INFO_LEVELS a1,
                                    LPVOID a2,
                                    FINDEX_SEARCH_OPS a3,
                                    LPVOID a4,
                                    DWORD a5)
{
    _PrintEnter("FindFirstFileExA(%hs,%p,%p,%x,%p,%x)\n", a0, a1, a2, a3, a4, a5);

    HANDLE rv = 0;
    __try {
        rv = Real_FindFirstFileExA(a0, a1, a2, a3, a4, a5);
    } __finally {
        _PrintExit("FindFirstFileExA(,,,,,) -> %p\n", rv);
    };
    return rv;
}

HANDLE WINAPI Mine_FindFirstFileExW(LPCWSTR a0,
                                    FINDEX_INFO_LEVELS a1,
                                    LPVOID a2,
                                    FINDEX_SEARCH_OPS a3,
                                    LPVOID a4,
                                    DWORD a5)
{
    _PrintEnter(NULL);

    HANDLE rv = 0;
    __try {
        rv = Real_FindFirstFileExW(a0, a1, a2, a3, a4, a5);
    } __finally {
        _PrintExit("FindFirstFileExW(%ls,%x,%p,%x,%p,%x) -> %p\n",
                   a0, a1, a2, a3, a4, a5, rv);
    };
    return rv;
}

DWORD WINAPI Mine_GetFileAttributesW(LPCWSTR a0)
{
    _PrintEnter(NULL);

    DWORD rv = 0;
    __try {
        rv = Real_GetFileAttributesW(a0);
    } __finally {
        _PrintExit("GetFileAttributesW(%ls) -> %x\n", a0, rv);
    };
    return rv;
}

DWORD WINAPI Mine_GetModuleFileNameW(HMODULE a0, LPWSTR a1, DWORD a2)
{
    _PrintEnter("GetModuleFileNameW(%p,%p,%x)\n", a0, a1, a2);
    DWORD rv = 0;
    __try {
        rv = Real_GetModuleFileNameW(a0, a1, a2);
    } __finally {
        _PrintExit("GetModuleFileNameW(%p,%p:%ls,%p) -> %p\n", a0, a1, a1, a2, rv);
    };
    return rv;
}

FARPROC WINAPI Mine_GetProcAddress(HINSTANCE a0,
                                   LPCSTR a1)
{
    WCHAR wzModule[MAX_PATH] = L"";
    PWCHAR pwzModule = wzModule;
    if (Real_GetModuleFileNameW(a0, wzModule, ARRAYSIZE(wzModule)) != 0) {
        if ((pwzModule = wcsrchr(wzModule, '\\')) == NULL) {
            if ((pwzModule = wcsrchr(wzModule, ':')) == NULL) {
                pwzModule = wzModule;
            }
            else {
                pwzModule++;                            // Skip ':'
            }
        }
        else {
            pwzModule++;                                // Skip '\\'
        }
    }
    else {
        wzModule[0] = '\0';
    }

    _PrintEnter(NULL);
    FARPROC rv = 0;
    __try {
        rv = Real_GetProcAddress(a0, a1);
    } __finally {
        if (pwzModule[0] == 0) {
            _PrintExit("GetProcAddress(%p,%hs) -> %p\n", a0, a1, rv);
        }
        else {
            _PrintExit("GetProcAddress(%p:%ls,%hs) -> %p\n", a0, pwzModule, a1, rv);
        }
    };
    return rv;
}

HMODULE WINAPI Mine_LoadLibraryExW(LPCWSTR a0,
                                   HANDLE a1,
                                   DWORD a2)
{
    _PrintEnter("LoadLibraryExW(%ls,%p,%x)\n", a0, a1, a2);

    HMODULE rv = 0;
    __try {
        rv = Real_LoadLibraryExW(a0, a1, a2);
    } __finally {
        _PrintExit("LoadLibraryExW(,,) -> %p\n", rv);
        if (rv) {
            InstanceEnumerate(rv);
        }
    };
    return rv;
}

BOOL WINAPI Mine_MoveFileA(LPCSTR a0,
                           LPCSTR a1)
{
    _PrintEnter("MoveFileA(%hs,%hs)\n", a0, a1);

    BOOL rv = 0;
    __try {
        rv = Real_MoveFileA(a0, a1);
    } __finally {
        _PrintExit("MoveFileA(,) -> %x\n", rv);
    };
    return rv;
}

BOOL WINAPI Mine_MoveFileExA(LPCSTR a0,
                             LPCSTR a1,
                             DWORD a2)
{
    _PrintEnter("MoveFileExA(%hs,%hs,%x)\n", a0, a1, a2);

    BOOL rv = 0;
    __try {
        rv = Real_MoveFileExA(a0, a1, a2);
    } __finally {
        _PrintExit("MoveFileExA(,,) -> %x\n", rv);
    };
    return rv;
}

BOOL WINAPI Mine_MoveFileExW(LPCWSTR a0,
                             LPCWSTR a1,
                             DWORD a2)
{
    _PrintEnter("MoveFileExW(%ls,%ls,%x)\n", a0, a1, a2);

    BOOL rv = 0;
    __try {
        rv = Real_MoveFileExW(a0, a1, a2);
    } __finally {
        _PrintExit("MoveFileExW(,,) -> %x\n", rv);
    };
    return rv;
}

BOOL WINAPI Mine_MoveFileW(LPCWSTR a0,
                           LPCWSTR a1)
{
    _PrintEnter("MoveFileW(%ls,%ls)\n", a0, a1);

    BOOL rv = 0;
    __try {
        rv = Real_MoveFileW(a0, a1);
    } __finally {
        _PrintExit("MoveFileW(,) -> %x\n", rv);
    };
    return rv;
}

HFILE WINAPI Mine_OpenFile(LPCSTR a0,
                           LPOFSTRUCT a1,
                           UINT a2)
{
    _PrintEnter("OpenFile(%hs,%p,%x)\n", a0, a1, a2);

    HFILE rv = 0;
    __try {
        rv = Real_OpenFile(a0, a1, a2);
    } __finally {
        _PrintExit("OpenFile(,,) -> %p\n", rv);
    };
    return rv;
}

LONG WINAPI Mine_RegCreateKeyExA(HKEY a0,
                                 LPCSTR a1,
                                 DWORD a2,
                                 LPSTR a3,
                                 DWORD a4,
                                 REGSAM a5,
                                 LPSECURITY_ATTRIBUTES a6,
                                 PHKEY a7,
                                 LPDWORD a8)
{
    _PrintEnter("RegCreateKeyExA(%p,%hs,%x,%hs,%x,%x,%p,%p,%p)\n", a0, a1, a2, a3, a4, a5, a6, a7, a8);

    LONG rv = 0;
    __try {
        rv = Real_RegCreateKeyExA(a0, a1, a2, a3, a4, a5, a6, a7, a8);
    } __finally {
        _PrintExit("RegCreateKeyExA(,,,,,,,,) -> %x\n", rv);
    };
    return rv;
}

LONG WINAPI Mine_RegCreateKeyExW(HKEY a0,
                                 LPCWSTR a1,
                                 DWORD a2,
                                 LPWSTR a3,
                                 DWORD a4,
                                 REGSAM a5,
                                 LPSECURITY_ATTRIBUTES a6,
                                 PHKEY a7,
                                 LPDWORD a8)
{
    _PrintEnter(NULL);
    LONG rv = 0;
    __try {
        rv = Real_RegCreateKeyExW(a0, a1, a2, a3, a4, a5, a6, a7, a8);
    } __finally {
        _PrintExit("RegCreateKeyExW(%p,%ls,%x,%ls,%x,%x,%p,%p,%p) -> %x\n",
                   a0, a1, a2, a3, a4, a5, a6, a7, a8, rv);
    };
    return rv;
}

LONG WINAPI Mine_RegDeleteKeyA(HKEY a0,
                               LPCSTR a1)
{
    _PrintEnter(NULL);
    LONG rv = 0;
    __try {
        rv = Real_RegDeleteKeyA(a0, a1);
    } __finally {
        _PrintExit("RegDeleteKeyA(%p,%hs) -> %x\n", a0, a1, rv);
    };
    return rv;
}

LONG WINAPI Mine_RegDeleteKeyW(HKEY a0,
                               LPCWSTR a1)
{
    _PrintEnter(NULL);
    LONG rv = 0;
    __try {
        rv = Real_RegDeleteKeyW(a0, a1);
    } __finally {
        _PrintExit("RegDeleteKeyW(%p,%ls) -> %x\n", a0, a1, rv);
    };
    return rv;
}

LONG WINAPI Mine_RegDeleteValueA(HKEY a0,
                                 LPCSTR a1)
{
    _PrintEnter("RegDeleteValueA(%p,%hs)\n", a0, a1);

    LONG rv = 0;
    __try {
        rv = Real_RegDeleteValueA(a0, a1);
    } __finally {
        _PrintExit("RegDeleteValueA(,) -> %x\n", rv);
    };
    return rv;
}

LONG WINAPI Mine_RegDeleteValueW(HKEY a0,
                                 LPCWSTR a1)
{
    _PrintEnter("RegDeleteValueW(%p,%ls)\n", a0, a1);

    LONG rv = 0;
    __try {
        rv = Real_RegDeleteValueW(a0, a1);
    } __finally {
        _PrintExit("RegDeleteValueW(,) -> %x\n", rv);
    };
    return rv;
}

LONG WINAPI Mine_RegEnumKeyExA(HKEY a0,
                               DWORD a1,
                               LPSTR a2,
                               LPDWORD a3,
                               LPDWORD a4,
                               LPSTR a5,
                               LPDWORD a6,
                               LPFILETIME a7)
{
    _PrintEnter("RegEnumKeyExA(%p,%x,%p,%p,%p,%hs,%p,%p)\n", a0, a1, a2, a3, a4, a5, a6, a7);

    LONG rv = 0;
    __try {
        rv = Real_RegEnumKeyExA(a0, a1, a2, a3, a4, a5, a6, a7);
    } __finally {
        _PrintExit("RegEnumKeyExA(,,%hs,,,%hs,,) -> %x\n", a2, a5, rv);
    };
    return rv;
}

LONG WINAPI Mine_RegEnumKeyExW(HKEY a0,
                               DWORD a1,
                               LPWSTR a2,
                               LPDWORD a3,
                               LPDWORD a4,
                               LPWSTR a5,
                               LPDWORD a6,
                               struct _FILETIME* a7)
{
    _PrintEnter("RegEnumKeyExW(%p,%x,%p,%p,%p,%ls,%p,%p)\n", a0, a1, a2, a3, a4, a5, a6, a7);

    LONG rv = 0;
    __try {
        rv = Real_RegEnumKeyExW(a0, a1, a2, a3, a4, a5, a6, a7);
    } __finally {
        _PrintExit("RegEnumKeyExW(,,%ls,,,%ls,,) -> %x\n", a2, a5, rv);
    };
    return rv;
}

LONG WINAPI Mine_RegEnumValueA(HKEY a0,
                               DWORD a1,
                               LPSTR a2,
                               LPDWORD a3,
                               LPDWORD a4,
                               LPDWORD a5,
                               LPBYTE a6,
                               LPDWORD a7)
{
    _PrintEnter("RegEnumValueA(%p,%x,%p,%p,%p,%p,%p,%p)\n", a0, a1, a2, a3, a4, a5, a6, a7);

    LONG rv = 0;
    __try {
        rv = Real_RegEnumValueA(a0, a1, a2, a3, a4, a5, a6, a7);
    } __finally {
        _PrintExit("RegEnumValueA(,,%hs,,,,,) -> %x\n", a2, rv);
    };
    return rv;
}

LONG WINAPI Mine_RegEnumValueW(HKEY a0,
                               DWORD a1,
                               LPWSTR a2,
                               LPDWORD a3,
                               LPDWORD a4,
                               LPDWORD a5,
                               LPBYTE a6,
                               LPDWORD a7)
{
    _PrintEnter("RegEnumValueW(%p,%x,%p,%p,%p,%p,%p,%p)\n", a0, a1, a2, a3, a4, a5, a6, a7);

    LONG rv = 0;
    __try {
        rv = Real_RegEnumValueW(a0, a1, a2, a3, a4, a5, a6, a7);
    } __finally {
        _PrintExit("RegEnumValueW(,,%ls,,,,,) -> %x\n", a2, rv);
    };
    return rv;
}

LONG WINAPI Mine_RegOpenKeyExA(HKEY a0,
                               LPCSTR a1,
                               DWORD a2,
                               REGSAM a3,
                               PHKEY a4)
{
    _PrintEnter(NULL);

    LONG rv = 0;
    __try {
        rv = Real_RegOpenKeyExA(a0, a1, a2, a3, a4);
    } __finally {
        _PrintExit("RegOpenKeyExA(%p,%hs,%x,%x,%p) -> %x\n",
                   a0, a1, a2, a3, a4, rv);
    };
    return rv;
}

LONG WINAPI Mine_RegOpenKeyExW(HKEY a0,
                               LPCWSTR a1,
                               DWORD a2,
                               REGSAM a3,
                               PHKEY a4)
{
    _PrintEnter(NULL);

    LONG rv = 0;
    __try {
        rv = Real_RegOpenKeyExW(a0, a1, a2, a3, a4);
    } __finally {
        _PrintExit("RegOpenKeyExW(%p,%ls,%x,%x,%p) -> %x\n",
                   a0, a1, a2, a3, a4, rv);
    };
    return rv;
}

LONG WINAPI Mine_RegQueryInfoKeyA(HKEY a0,
                                  LPSTR a1,
                                  LPDWORD a2,
                                  LPDWORD a3,
                                  LPDWORD a4,
                                  LPDWORD a5,
                                  LPDWORD a6,
                                  LPDWORD a7,
                                  LPDWORD a8,
                                  LPDWORD a9,
                                  LPDWORD a10,
                                  LPFILETIME a11)
{
    _PrintEnter("RegQueryInfoKeyA(%p,%p,%p,%p,%p,%p,%p,%p,%p,%p,%p,%p)\n",
                a0, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11);

    LONG rv = 0;
    __try {
        rv = Real_RegQueryInfoKeyA(a0, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11);
    } __finally {
        _PrintExit("RegQueryInfoKeyA(,%hs,,,,,,,,,,) -> %x\n", a1, rv);
    };
    return rv;
}

LONG WINAPI Mine_RegQueryInfoKeyW(HKEY a0,
                                  LPWSTR a1,
                                  LPDWORD a2,
                                  LPDWORD a3,
                                  LPDWORD a4,
                                  LPDWORD a5,
                                  LPDWORD a6,
                                  LPDWORD a7,
                                  LPDWORD a8,
                                  LPDWORD a9,
                                  LPDWORD a10,
                                  LPFILETIME a11)
{
    _PrintEnter("RegQueryInfoKeyW(%p,%p,%p,%p,%p,%p,%p,%p,%p,%p,%p,%p)\n",
                a0, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11);

    LONG rv = 0;
    __try {
        rv = Real_RegQueryInfoKeyW(a0, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11);
    } __finally {
        _PrintExit("RegQueryInfoKeyW(,%ls,,,,,,,,,,) -> %x\n", a1, rv);
    };
    return rv;
}

LONG WINAPI Mine_RegQueryValueExA(HKEY a0,
                                  LPCSTR a1,
                                  LPDWORD a2,
                                  LPDWORD a3,
                                  LPBYTE a4,
                                  LPDWORD a5)
{
    _PrintEnter(NULL);

    LONG rv = 0;
    __try {
        rv = Real_RegQueryValueExA(a0, a1, a2, a3, a4, a5);
    } __finally {
        _PrintExit("RegQueryValueExA(%p,%hs,%p,%p,%p,%p) -> %x\n",
                   a0, a1, a2, a3, a4, a5, rv);
    };
    return rv;
}

LONG WINAPI Mine_RegQueryValueExW(HKEY a0,
                                  LPCWSTR a1,
                                  LPDWORD a2,
                                  LPDWORD a3,
                                  LPBYTE a4,
                                  LPDWORD a5)
{
    _PrintEnter(NULL);
    LONG rv = 0;
    __try {
        rv = Real_RegQueryValueExW(a0, a1, a2, a3, a4, a5);
    } __finally {
        _PrintExit("RegQueryValueExW(%p,%ls,%p,%p,%p,%p) -> %x\n",
                    a0, a1, a2, a3, a4, a5, rv);
    };
    return rv;
}

LONG WINAPI Mine_RegSetValueExA(HKEY a0,
                                LPCSTR a1,
                                DWORD a2,
                                DWORD a3,
                                BYTE* a4,
                                DWORD a5)
{
    _PrintEnter(NULL);
    LONG rv = 0;
    __try {
        rv = Real_RegSetValueExA(a0, a1, a2, a3, a4, a5);
    } __finally {
        _PrintExit("RegSetValueExA(%p,%hs,%x,%x,%p,%x) -> %x\n",
                   a0, a1, a2, a3, a4, a5, rv);
    };
    return rv;
}

LONG WINAPI Mine_RegSetValueExW(HKEY a0,
                                   LPCWSTR a1,
                                   DWORD a2,
                                   DWORD a3,
                                   BYTE* a4,
                                   DWORD a5)
{
    _PrintEnter(NULL);
    LONG rv = 0;
    __try {
        rv = Real_RegSetValueExW(a0, a1, a2, a3, a4, a5);
    } __finally {
        _PrintExit("RegSetValueExW(%p,%ls,%x,%x,%p,%x) -> %x\n",
                   a0, a1, a2, a3, a4, a5, rv);
    };
    return rv;
}

HFILE WINAPI Mine__lcreat(LPCSTR a0, int a1)
{
    _PrintEnter(NULL);
    HFILE rv = 0;
    __try {
        rv = Real__lcreat(a0, a1);
    } __finally {
        _PrintExit("_lcreat(%hs,%x) -> %p\n", a0, a1, rv);
    };
    return rv;
}

HFILE WINAPI Mine__lopen(LPCSTR a0, int a1)
{
    _PrintEnter(NULL);
    HFILE rv = 0;
    __try {
        rv = Real__lopen(a0, a1);
    } __finally {
        _PrintEnter("_lopen(%hs,%x) -> %p\n", a0, a1, rv);
    };
    return rv;
}

/////////////////////////////////////////////////////////////
// AttachDetours
//
PCHAR DetRealName(PCHAR psz)
{
    PCHAR pszBeg = psz;
    // Move to end of name.
    while (*psz) {
        psz++;
    }
    // Move back through A-Za-z0-9 names.
    while (psz > pszBeg &&
           ((psz[-1] >= 'A' && psz[-1] <= 'Z') ||
            (psz[-1] >= 'a' && psz[-1] <= 'z') ||
            (psz[-1] >= '0' && psz[-1] <= '9'))) {
        psz--;
    }
    return psz;
}

VOID DetAttach(PVOID *ppbReal, PVOID pbMine, PCHAR psz)
{
    LONG l = DetourAttach(ppbReal, pbMine);
    if (l != 0) {
        Syelog(SYELOG_SEVERITY_NOTICE,
               "Attach failed: `%s': error %d\n", DetRealName(psz), l);
    }
}

VOID DetDetach(PVOID *ppbReal, PVOID pbMine, PCHAR psz)
{
    LONG l = DetourDetach(ppbReal, pbMine);
    if (l != 0) {
        Syelog(SYELOG_SEVERITY_NOTICE,
               "Detach failed: `%s': error %d\n", DetRealName(psz), l);
    }
}

#define ATTACH(x)       DetAttach(&(PVOID&)Real_##x,Mine_##x,#x)
#define DETACH(x)       DetDetach(&(PVOID&)Real_##x,Mine_##x,#x)

LONG AttachDetours(VOID)
{
    DetourTransactionBegin();
    DetourUpdateThread(GetCurrentThread());

    ATTACH(CloseHandle);
    ATTACH(CopyFileExA);
    ATTACH(CopyFileExW);
    ATTACH(CreateDirectoryExW);
    ATTACH(CreateDirectoryW);
    ATTACH(CreateFileW);
    ATTACH(CreateProcessW);
    ATTACH(DeleteFileA);
    ATTACH(DeleteFileW);
    ATTACH(FindFirstFileExA);
    ATTACH(FindFirstFileExW);
    ATTACH(GetFileAttributesW);
    ATTACH(GetModuleFileNameW);
    ATTACH(GetProcAddress);
    ATTACH(GetSystemTimeAsFileTime);
    ATTACH(LoadLibraryExW);
    ATTACH(MoveFileA);
    ATTACH(MoveFileExA);
    ATTACH(MoveFileExW);
    ATTACH(MoveFileW);
    ATTACH(OpenFile);
    ATTACH(RegCreateKeyExA);
    ATTACH(RegCreateKeyExW);
    ATTACH(RegDeleteKeyA);
    ATTACH(RegDeleteKeyW);
    ATTACH(RegDeleteValueA);
    ATTACH(RegDeleteValueW);
    ATTACH(RegEnumKeyExA);
    ATTACH(RegEnumKeyExW);
    ATTACH(RegEnumValueA);
    ATTACH(RegEnumValueW);
    ATTACH(RegOpenKeyExA);
    ATTACH(RegOpenKeyExW);
    ATTACH(RegQueryInfoKeyA);
    ATTACH(RegQueryInfoKeyW);
    ATTACH(RegQueryValueExA);
    ATTACH(RegQueryValueExW);
    ATTACH(RegSetValueExA);
    ATTACH(RegSetValueExW);
    ATTACH(SetNamedPipeHandleState);
    ATTACH(WaitNamedPipeW);
    ATTACH(WriteFile);
    ATTACH(_lcreat);
    ATTACH(_lopen);

    return DetourTransactionCommit();
}

LONG DetachDetours(VOID)
{
    DetourTransactionBegin();
    DetourUpdateThread(GetCurrentThread());

    DETACH(CloseHandle);
    DETACH(CopyFileExA);
    DETACH(CopyFileExW);
    DETACH(CreateDirectoryExW);
    DETACH(CreateDirectoryW);
    DETACH(CreateFileW);
    DETACH(CreateProcessW);
    DETACH(DeleteFileA);
    DETACH(DeleteFileW);
    DETACH(FindFirstFileExA);
    DETACH(FindFirstFileExW);
    DETACH(GetFileAttributesW);
    DETACH(GetModuleFileNameW);
    DETACH(GetProcAddress);
    DETACH(GetSystemTimeAsFileTime);
    DETACH(LoadLibraryExW);
    DETACH(MoveFileA);
    DETACH(MoveFileExA);
    DETACH(MoveFileExW);
    DETACH(MoveFileW);
    DETACH(OpenFile);
    DETACH(RegCreateKeyExA);
    DETACH(RegCreateKeyExW);
    DETACH(RegDeleteKeyA);
    DETACH(RegDeleteKeyW);
    DETACH(RegDeleteValueA);
    DETACH(RegDeleteValueW);
    DETACH(RegEnumKeyExA);
    DETACH(RegEnumKeyExW);
    DETACH(RegEnumValueA);
    DETACH(RegEnumValueW);
    DETACH(RegOpenKeyExA);
    DETACH(RegOpenKeyExW);
    DETACH(RegQueryInfoKeyA);
    DETACH(RegQueryInfoKeyW);
    DETACH(RegQueryValueExA);
    DETACH(RegQueryValueExW);
    DETACH(RegSetValueExA);
    DETACH(RegSetValueExW);
    DETACH(SetNamedPipeHandleState);
    DETACH(WaitNamedPipeW);
    DETACH(WriteFile);
    DETACH(_lcreat);
    DETACH(_lopen);

    return DetourTransactionCommit();
}
//
//////////////////////////////////////////////////////////////////////////////


////////////////////////////////////////////////////////////// Logging System.
//
static BOOL s_bLog = 1;
static LONG s_nTlsIndent = -1;
static LONG s_nTlsThread = -1;
static LONG s_nThreadCnt = 0;

VOID _PrintEnter(const CHAR *psz, ...)
{
    DWORD dwErr = GetLastError();

    LONG nIndent = 0;
    LONG nThread = 0;
    if (s_nTlsIndent >= 0) {
        nIndent = (LONG)(LONG_PTR)TlsGetValue(s_nTlsIndent);
        TlsSetValue(s_nTlsIndent, (PVOID)(LONG_PTR)(nIndent + 1));
    }
    if (s_nTlsThread >= 0) {
        nThread = (LONG)(LONG_PTR)TlsGetValue(s_nTlsThread);
    }

    if (s_bLog && psz) {
        CHAR szBuf[1024];
        PCHAR pszBuf = szBuf;
        PCHAR pszEnd = szBuf + ARRAYSIZE(szBuf) - 1;
        LONG nLen = (nIndent > 0) ? (nIndent < 35 ? nIndent * 2 : 70) : 0;
        *pszBuf++ = (CHAR)('0' + ((nThread / 100) % 10));
        *pszBuf++ = (CHAR)('0' + ((nThread / 10) % 10));
        *pszBuf++ = (CHAR)('0' + ((nThread / 1) % 10));
        *pszBuf++ = ' ';
        while (nLen-- > 0) {
            *pszBuf++ = ' ';
        }

        va_list  args;
        va_start(args, psz);

        while ((*pszBuf++ = *psz++) != 0 && pszBuf < pszEnd) {
            // Copy characters.
        }
        *pszEnd = '\0';
        SyelogV(SYELOG_SEVERITY_INFORMATION,
                szBuf, args);

        va_end(args);
    }
    SetLastError(dwErr);
}

VOID _PrintExit(const CHAR *psz, ...)
{
    DWORD dwErr = GetLastError();

    LONG nIndent = 0;
    LONG nThread = 0;
    if (s_nTlsIndent >= 0) {
        nIndent = (LONG)(LONG_PTR)TlsGetValue(s_nTlsIndent) - 1;
        ASSERT(nIndent >= 0);
        TlsSetValue(s_nTlsIndent, (PVOID)(LONG_PTR)nIndent);
    }
    if (s_nTlsThread >= 0) {
        nThread = (LONG)(LONG_PTR)TlsGetValue(s_nTlsThread);
    }

    if (s_bLog && psz) {
        CHAR szBuf[1024];
        PCHAR pszBuf = szBuf;
        PCHAR pszEnd = szBuf + ARRAYSIZE(szBuf) - 1;
        LONG nLen = (nIndent > 0) ? (nIndent < 35 ? nIndent * 2 : 70) : 0;
        *pszBuf++ = (CHAR)('0' + ((nThread / 100) % 10));
        *pszBuf++ = (CHAR)('0' + ((nThread / 10) % 10));
        *pszBuf++ = (CHAR)('0' + ((nThread / 1) % 10));
        *pszBuf++ = ' ';
        while (nLen-- > 0) {
            *pszBuf++ = ' ';
        }

        va_list  args;
        va_start(args, psz);

        while ((*pszBuf++ = *psz++) != 0 && pszBuf < pszEnd) {
            // Copy characters.
        }
        *pszEnd = '\0';
        SyelogV(SYELOG_SEVERITY_INFORMATION,
                szBuf, args);

        va_end(args);
    }
    SetLastError(dwErr);
}

VOID _Print(const CHAR *psz, ...)
{
    DWORD dwErr = GetLastError();

    LONG nIndent = 0;
    LONG nThread = 0;
    if (s_nTlsIndent >= 0) {
        nIndent = (LONG)(LONG_PTR)TlsGetValue(s_nTlsIndent);
    }
    if (s_nTlsThread >= 0) {
        nThread = (LONG)(LONG_PTR)TlsGetValue(s_nTlsThread);
    }

    if (s_bLog && psz) {
        CHAR szBuf[1024];
        PCHAR pszBuf = szBuf;
        PCHAR pszEnd = szBuf + ARRAYSIZE(szBuf) - 1;
        LONG nLen = (nIndent > 0) ? (nIndent < 35 ? nIndent * 2 : 70) : 0;
        *pszBuf++ = (CHAR)('0' + ((nThread / 100) % 10));
        *pszBuf++ = (CHAR)('0' + ((nThread / 10) % 10));
        *pszBuf++ = (CHAR)('0' + ((nThread / 1) % 10));
        *pszBuf++ = ' ';
        while (nLen-- > 0) {
            *pszBuf++ = ' ';
        }

        va_list  args;
        va_start(args, psz);

        while ((*pszBuf++ = *psz++) != 0 && pszBuf < pszEnd) {
            // Copy characters.
        }
        *pszEnd = '\0';
        SyelogV(SYELOG_SEVERITY_INFORMATION,
                szBuf, args);

        va_end(args);
    }

    SetLastError(dwErr);
}

VOID AssertMessage(CONST PCHAR pszMsg, CONST PCHAR pszFile, ULONG nLine)
{
    Syelog(SYELOG_SEVERITY_FATAL,
           "ASSERT(%s) failed in %s, line %d.\n", pszMsg, pszFile, nLine);
}

//////////////////////////////////////////////////////////////////////////////
//
PIMAGE_NT_HEADERS NtHeadersForInstance(HINSTANCE hInst)
{
    PIMAGE_DOS_HEADER pDosHeader = (PIMAGE_DOS_HEADER)hInst;
    __try {
        if (pDosHeader->e_magic != IMAGE_DOS_SIGNATURE) {
            SetLastError(ERROR_BAD_EXE_FORMAT);
            return NULL;
        }

        PIMAGE_NT_HEADERS pNtHeader = (PIMAGE_NT_HEADERS)((PBYTE)pDosHeader +
                                                          pDosHeader->e_lfanew);
        if (pNtHeader->Signature != IMAGE_NT_SIGNATURE) {
            SetLastError(ERROR_INVALID_EXE_SIGNATURE);
            return NULL;
        }
        if (pNtHeader->FileHeader.SizeOfOptionalHeader == 0) {
            SetLastError(ERROR_EXE_MARKED_INVALID);
            return NULL;
        }
        return pNtHeader;
    } __except(EXCEPTION_EXECUTE_HANDLER) {
    }
    SetLastError(ERROR_EXE_MARKED_INVALID);

    return NULL;
}

BOOL InstanceEnumerate(HINSTANCE hInst)
{
    WCHAR wzDllName[MAX_PATH];

    PIMAGE_NT_HEADERS pinh = NtHeadersForInstance(hInst);
    if (pinh && Real_GetModuleFileNameW(hInst, wzDllName, ARRAYSIZE(wzDllName))) {
        Syelog(SYELOG_SEVERITY_INFORMATION,
               "### %08lx: %-43.43ls %08x\n",
               hInst, wzDllName, pinh->OptionalHeader.CheckSum);
        return TRUE;
    }
    return FALSE;
}

BOOL ProcessEnumerate()
{
    Syelog(SYELOG_SEVERITY_INFORMATION,
           "######################################################### Binaries\n");
    for (HINSTANCE hInst = NULL; (hInst = DetourEnumerateModules(hInst)) != NULL;) {
        InstanceEnumerate(hInst);
    }
    return TRUE;
}

//////////////////////////////////////////////////////////////////////////////
//
// DLL module information
//
BOOL ThreadAttach(HMODULE hDll)
{
    (void)hDll;

    if (s_nTlsIndent >= 0) {
        TlsSetValue(s_nTlsIndent, (PVOID)0);
    }
    if (s_nTlsThread >= 0) {
        LONG nThread = InterlockedIncrement(&s_nThreadCnt);
        TlsSetValue(s_nTlsThread, (PVOID)(LONG_PTR)nThread);
    }
    return TRUE;
}

BOOL ThreadDetach(HMODULE hDll)
{
    (void)hDll;

    if (s_nTlsIndent >= 0) {
        TlsSetValue(s_nTlsIndent, (PVOID)0);
    }
    if (s_nTlsThread >= 0) {
        TlsSetValue(s_nTlsThread, (PVOID)0);
    }
    return TRUE;
}

BOOL ProcessAttach(HMODULE hDll)
{
    s_bLog = FALSE;
    s_nTlsIndent = TlsAlloc();
    s_nTlsThread = TlsAlloc();

    s_hInst = hDll;
    Real_GetModuleFileNameA(s_hInst, s_szDllPath, ARRAYSIZE(s_szDllPath));

    SyelogOpen("trcreg" DETOURS_STRINGIFY(DETOURS_BITS), SYELOG_FACILITY_APPLICATION);
    ProcessEnumerate();

    LONG error = AttachDetours();
    if (error != NO_ERROR) {
        Syelog(SYELOG_SEVERITY_FATAL, "### Error attaching detours: %d\n", error);
    }

    ThreadAttach(hDll);

    s_bLog = TRUE;
    return TRUE;
}

BOOL ProcessDetach(HMODULE hDll)
{
    ThreadDetach(hDll);
    s_bLog = FALSE;

    LONG error = DetachDetours();
    if (error != NO_ERROR) {
        Syelog(SYELOG_SEVERITY_FATAL, "### Error detaching detours: %d\n", error);
    }

    Syelog(SYELOG_SEVERITY_NOTICE, "### Closing.\n");
    SyelogClose(FALSE);

    if (s_nTlsIndent >= 0) {
        TlsFree(s_nTlsIndent);
    }
    if (s_nTlsThread >= 0) {
        TlsFree(s_nTlsThread);
    }
    return TRUE;
}

BOOL APIENTRY DllMain(HINSTANCE hModule, DWORD dwReason, PVOID lpReserved)
{
    (void)hModule;
    (void)lpReserved;

    if (DetourIsHelperProcess()) {
        return TRUE;
    }

    switch (dwReason) {
      case DLL_PROCESS_ATTACH:
        DetourRestoreAfterWith();
        return ProcessAttach(hModule);
      case DLL_PROCESS_DETACH:
        return ProcessDetach(hModule);
      case DLL_THREAD_ATTACH:
        return ThreadAttach(hModule);
      case DLL_THREAD_DETACH:
        return ThreadDetach(hModule);
    }
    return TRUE;
}
//
///////////////////////////////////////////////////////////////// End of File.

```

`samples/tracereg/trcreg.rc`:

```rc
//////////////////////////////////////////////////////////////////////////////
//
//  Version information for trcreg.rc.
//
//  Microsoft Research Detours Package
//
//  Copyright (c) Microsoft Corporation.  All rights reserved.
//

#include "detver.h"

#define VER_INTERNALNAME_STR        "trcreg" DETOURS_STRINGIFY(DETOURS_BITS)
#define VER_ORIGINALFILENAME_STR    "trcreg" DETOURS_STRINGIFY(DETOURS_BITS) ".dll"
#define VER_FILEDESCRIPTION_STR     "Detours Registry Trace Module"
#define VER_COMPANYNAME_STR         "Microsoft Corporation"

#include "common.ver"

```

`samples/traceser/Makefile`:

```
##############################################################################
##
##  Utility to trace serial (COM1, COM2, etc.) APIs.
##
##  Microsoft Research Detours Package
##
##  Copyright (c) Microsoft Corporation.  All rights reserved.
##

!include ..\common.mak

LIBS=$(LIBS) kernel32.lib

all: dirs \
    $(BIND)\trcser$(DETOURS_BITS).dll \
!IF $(DETOURS_SOURCE_BROWSING)==1
    $(OBJD)\trcser$(DETOURS_BITS).bsc \
!ENDIF
    option

dirs:
    @if not exist $(BIND) mkdir $(BIND) && echo.   Created $(BIND)
    @if not exist $(OBJD) mkdir $(OBJD) && echo.   Created $(OBJD)

clean:
    -del *~ test.txt 2>nul
    -del $(BIND)\trcser*.* 2>nul
    -rmdir /q /s $(OBJD) 2>nul

realclean: clean
    -rmdir /q /s $(OBJDS) 2>nul

##############################################################################

$(OBJD)\trcser.obj: trcser.cpp

$(OBJD)\trcser.res: trcser.rc

$(BIND)\trcser$(DETOURS_BITS).dll: $(OBJD)\trcser.obj $(OBJD)\trcser.res $(DEPS)
    cl /LD $(CFLAGS) /Fe$@ /Fd$(@R).pdb \
        $(OBJD)\trcser.obj $(OBJD)\trcser.res \
        /link $(LINKFLAGS) /subsystem:console \
        /export:DetourFinishHelperProcess,@1,NONAME \
        $(LIBS)

$(OBJD)\trcser$(DETOURS_BITS).bsc : $(OBJD)\trcser.obj
    bscmake /v /n /o $@ $(OBJD)\trcser.sbr

############################################### Install non-bit-size binaries.

!IF "$(DETOURS_OPTION_PROCESSOR)" != ""

$(OPTD)\trcser$(DETOURS_OPTION_BITS).dll:
$(OPTD)\trcser$(DETOURS_OPTION_BITS).pdb:

$(BIND)\trcser$(DETOURS_OPTION_BITS).dll : $(OPTD)\trcser$(DETOURS_OPTION_BITS).dll
    @if exist $? copy /y $? $(BIND) >nul && echo $@ copied from $(DETOURS_OPTION_PROCESSOR).
$(BIND)\trcser$(DETOURS_OPTION_BITS).pdb : $(OPTD)\trcser$(DETOURS_OPTION_BITS).pdb
    @if exist $? copy /y $? $(BIND) >nul && echo $@ copied from $(DETOURS_OPTION_PROCESSOR).

option: \
    $(BIND)\trcser$(DETOURS_OPTION_BITS).dll \
    $(BIND)\trcser$(DETOURS_OPTION_BITS).pdb \

!ELSE

option:

!ENDIF

##############################################################################

test: all
    @echo -------- Logging output to test.txt ------------
    start $(BIND)\syelogd.exe /o test.txt
    $(BIND)\sleep5.exe 1
    @echo -------- Should load trcser$(DETOURS_BITS).dll dynamically using withdll.exe ------------
    $(BIND)\withdll -d:$(BIND)\trcser$(DETOURS_BITS).dll $(BIND)\sleepold.exe
    @echo -------- Log from syelog -------------
    type test.txt

################################################################# End of File.

```

`samples/traceser/trcser.cpp`:

```cpp
//////////////////////////////////////////////////////////////////////////////
//
//  Detours Test Program (trcser.cpp of trcser.dll)
//
//  Microsoft Research Detours Package
//
//  Copyright (c) Microsoft Corporation.  All rights reserved.
//
#define _WIN32_WINNT        0x0400
#define WIN32
#define NT

#define DBG_TRACE   0

#include <windows.h>
#include <stdio.h>
#include "detours.h"
#include "syelog.h"

#define PULONG_PTR          PVOID
#define PLONG_PTR           PVOID
#define ULONG_PTR           PVOID
#define ENUMRESNAMEPROCA    PVOID
#define ENUMRESNAMEPROCW    PVOID
#define ENUMRESLANGPROCA    PVOID
#define ENUMRESLANGPROCW    PVOID
#define ENUMRESTYPEPROCA    PVOID
#define ENUMRESTYPEPROCW    PVOID
#define STGOPTIONS          PVOID

//////////////////////////////////////////////////////////////////////
#pragma warning(disable:4127)   // Many of our asserts are constants.

#define ASSERT_ALWAYS(x)   \
    do {                                                        \
    if (!(x)) {                                                 \
            AssertMessage(#x, __FILE__, __LINE__);              \
            DebugBreak();                                       \
    }                                                           \
    } while (0)

#ifndef NDEBUG
#define ASSERT(x)           ASSERT_ALWAYS(x)
#else
#define ASSERT(x)
#endif

#define UNUSED(c)       (c) = (c)

//////////////////////////////////////////////////////////////////////
static HMODULE s_hInst = NULL;
static CHAR s_szDllPath[MAX_PATH];

VOID _PrintDump(HANDLE h, PCHAR pszData, INT cbData);
VOID _PrintEnter(PCSTR psz, ...);
VOID _PrintExit(PCSTR psz, ...);
VOID _Print(PCSTR psz, ...);

VOID AssertMessage(CONST PCHAR pszMsg, CONST PCHAR pszFile, ULONG nLine);

//////////////////////////////////////////////////////////////////////////////
//
extern "C" {
    HANDLE (WINAPI * Real_CreateFileW)(LPCWSTR a0,
                                       DWORD a1,
                                       DWORD a2,
                                       LPSECURITY_ATTRIBUTES a3,
                                       DWORD a4,
                                       DWORD a5,
                                       HANDLE a6)
        = CreateFileW;

    BOOL (WINAPI * Real_WriteFile)(HANDLE hFile,
                                     LPCVOID lpBuffer,
                                     DWORD nNumberOfBytesToWrite,
                                     LPDWORD lpNumberOfBytesWritten,
                                     LPOVERLAPPED lpOverlapped)
        = WriteFile;
    BOOL (WINAPI * Real_FlushFileBuffers)(HANDLE hFile)
        = FlushFileBuffers;
    BOOL (WINAPI * Real_CloseHandle)(HANDLE hObject)
        = CloseHandle;

    BOOL (WINAPI * Real_WaitNamedPipeW)(LPCWSTR lpNamedPipeName, DWORD nTimeOut)
        = WaitNamedPipeW;
    BOOL (WINAPI * Real_SetNamedPipeHandleState)(HANDLE hNamedPipe,
                                                   LPDWORD lpMode,
                                                   LPDWORD lpMaxCollectionCount,
                                                   LPDWORD lpCollectDataTimeout)
        = SetNamedPipeHandleState;

    DWORD (WINAPI * Real_GetCurrentProcessId)(VOID)
        = GetCurrentProcessId;
    VOID (WINAPI * Real_GetSystemTimeAsFileTime)(LPFILETIME lpSystemTimeAsFileTime)
        = GetSystemTimeAsFileTime;

    VOID (WINAPI * Real_InitializeCriticalSection)(LPCRITICAL_SECTION lpSection)
        = InitializeCriticalSection;
    VOID (WINAPI * Real_EnterCriticalSection)(LPCRITICAL_SECTION lpSection)
        = EnterCriticalSection;
    VOID (WINAPI * Real_LeaveCriticalSection)(LPCRITICAL_SECTION lpSection)
        = LeaveCriticalSection;
}

DWORD (WINAPI * Real_GetModuleFileNameW)(HMODULE a0,
                                         LPWSTR a1,
                                         DWORD a2)
    = GetModuleFileNameW;

DWORD (WINAPI * Real_GetModuleFileNameA)(HMODULE a0,
                                         LPSTR a1,
                                         DWORD a2)
    = GetModuleFileNameA;

BOOL (WINAPI * Real_CreateProcessW)(LPCWSTR a0,
                                    LPWSTR a1,
                                    LPSECURITY_ATTRIBUTES a2,
                                    LPSECURITY_ATTRIBUTES a3,
                                    BOOL a4,
                                    DWORD a5,
                                    LPVOID a6,
                                    LPCWSTR a7,
                                    struct _STARTUPINFOW* a8,
                                    LPPROCESS_INFORMATION a9)
    = CreateProcessW;

BOOL (WINAPI * Real_BuildCommDCBA)(LPCSTR a0,
                                   struct _DCB* a1)
    = BuildCommDCBA;

BOOL (WINAPI * Real_BuildCommDCBAndTimeoutsA)(LPCSTR a0,
                                              struct _DCB* a1,
                                              struct _COMMTIMEOUTS* a2)
    = BuildCommDCBAndTimeoutsA;

BOOL (WINAPI * Real_BuildCommDCBAndTimeoutsW)(LPCWSTR a0,
                                              struct _DCB* a1,
                                              struct _COMMTIMEOUTS* a2)
    = BuildCommDCBAndTimeoutsW;

BOOL (WINAPI * Real_BuildCommDCBW)(LPCWSTR a0,
                                   struct _DCB* a1)
    = BuildCommDCBW;

BOOL (WINAPI * Real_ClearCommBreak)(HANDLE a0)
    = ClearCommBreak;

BOOL (WINAPI * Real_ClearCommError)(HANDLE a0,
                                    LPDWORD a1,
                                    struct _COMSTAT* a2)
    = ClearCommError;

HANDLE (WINAPI * Real_CreateFileA)(LPCSTR a0,
                                   DWORD a1,
                                   DWORD a2,
                                   LPSECURITY_ATTRIBUTES a3,
                                   DWORD a4,
                                   DWORD a5,
                                   HANDLE a6)
    = CreateFileA;

BOOL (WINAPI * Real_EscapeCommFunction)(HANDLE a0,
                                        DWORD a1)
    = EscapeCommFunction;

BOOL (WINAPI * Real_GetCommConfig)(HANDLE a0,
                                   LPCOMMCONFIG a1,
                                   LPDWORD a2)
    = GetCommConfig;

BOOL (WINAPI * Real_GetCommMask)(HANDLE a0,
                                 LPDWORD a1)
    = GetCommMask;

BOOL (WINAPI * Real_GetCommModemStatus)(HANDLE a0,
                                        LPDWORD a1)
    = GetCommModemStatus;

BOOL (WINAPI * Real_GetCommProperties)(HANDLE a0,
                                       LPCOMMPROP a1)
    = GetCommProperties;

BOOL (WINAPI * Real_GetCommState)(HANDLE a0,
                                  struct _DCB* a1)
    = GetCommState;

BOOL (WINAPI * Real_GetCommTimeouts)(HANDLE a0,
                                     struct _COMMTIMEOUTS* a1)
    = GetCommTimeouts;

DWORD (WINAPI * Real_GetCurrentThreadId)(void)
    = GetCurrentThreadId;

BOOL (WINAPI * Real_GetOverlappedResult)(HANDLE a0,
                                         LPOVERLAPPED a1,
                                         LPDWORD a2,
                                         BOOL a3)
    = GetOverlappedResult;

BOOL (WINAPI * Real_PurgeComm)(HANDLE a0,
                               DWORD a1)
    = PurgeComm;

BOOL (WINAPI * Real_ReadFile)(HANDLE a0,
                              LPVOID a1,
                              DWORD a2,
                              LPDWORD a3,
                              LPOVERLAPPED a4)
    = ReadFile;

BOOL (WINAPI * Real_SetCommBreak)(HANDLE a0)
    = SetCommBreak;

BOOL (WINAPI * Real_SetCommConfig)(HANDLE a0,
                                   LPCOMMCONFIG a1,
                                   DWORD a2)
    = SetCommConfig;

BOOL (WINAPI * Real_SetCommMask)(HANDLE a0,
                                 DWORD a1)
    = SetCommMask;

BOOL (WINAPI * Real_SetCommState)(HANDLE a0,
                                  struct _DCB* a1)
    = SetCommState;

BOOL (WINAPI * Real_SetCommTimeouts)(HANDLE a0,
                                     struct _COMMTIMEOUTS* a1)
    = SetCommTimeouts;

BOOL (WINAPI * Real_SetupComm)(HANDLE a0,
                               DWORD a1,
                               DWORD a2)
    = SetupComm;

BOOL (WINAPI * Real_TransmitCommChar)(HANDLE a0,
                                      char a1)
    = TransmitCommChar;

BOOL (WINAPI * Real_WaitCommEvent)(HANDLE a0,
                                   LPDWORD a1,
                                   LPOVERLAPPED a2)
    = WaitCommEvent;

/////////////////////////////////////////////////////////////
// Detours
//

BOOL WINAPI Mine_CreateProcessW(LPCWSTR lpApplicationName,
                                LPWSTR lpCommandLine,
                                LPSECURITY_ATTRIBUTES lpProcessAttributes,
                                LPSECURITY_ATTRIBUTES lpThreadAttributes,
                                BOOL bInheritHandles,
                                DWORD dwCreationFlags,
                                LPVOID lpEnvironment,
                                LPCWSTR lpCurrentDirectory,
                                LPSTARTUPINFOW lpStartupInfo,
                                LPPROCESS_INFORMATION lpProcessInformation)
{
    _PrintEnter("CreateProcessW(%ls,%ls,%p,%p,%x,%x,%p,%ls,%p,%p)\n",
                lpApplicationName,
                lpCommandLine,
                lpProcessAttributes,
                lpThreadAttributes,
                bInheritHandles,
                dwCreationFlags,
                lpEnvironment,
                lpCurrentDirectory,
                lpStartupInfo,
                lpProcessInformation);

    _Print("Calling DetourCreateProcessWithDllExW(,%hs)\n", s_szDllPath);

    BOOL rv = 0;
    __try {
        rv = DetourCreateProcessWithDllExW(lpApplicationName,
                                           lpCommandLine,
                                           lpProcessAttributes,
                                           lpThreadAttributes,
                                           bInheritHandles,
                                           dwCreationFlags,
                                           lpEnvironment,
                                           lpCurrentDirectory,
                                           lpStartupInfo,
                                           lpProcessInformation,
                                           s_szDllPath,
                                           Real_CreateProcessW);
    } __finally {
        _PrintExit("CreateProcessW(,,,,,,,,,) -> %x\n", rv);
    };
    return rv;
}

BOOL WINAPI Mine_BuildCommDCBA(LPCSTR a0,
                               LPDCB a1)
{
    _PrintEnter("BuildCommDCBA(%hs,%p)\n", a0, a1);

    BOOL rv = 0;
    __try {
        rv = Real_BuildCommDCBA(a0, a1);
    } __finally {
        _PrintExit("BuildCommDCBA(,) -> %x\n", rv);
    };
    return rv;
}

BOOL WINAPI Mine_BuildCommDCBAndTimeoutsA(LPCSTR a0,
                                          LPDCB a1,
                                          LPCOMMTIMEOUTS a2)
{
    _PrintEnter("BuildCommDCBAndTimeoutsA(%hs,%p,%p)\n", a0, a1, a2);

    BOOL rv = 0;
    __try {
        rv = Real_BuildCommDCBAndTimeoutsA(a0, a1, a2);
    } __finally {
        _PrintExit("BuildCommDCBAndTimeoutsA(,,) -> %x\n", rv);
    };
    return rv;
}

BOOL WINAPI Mine_BuildCommDCBAndTimeoutsW(LPCWSTR a0,
                                          LPDCB a1,
                                          LPCOMMTIMEOUTS a2)
{
    _PrintEnter("BuildCommDCBAndTimeoutsW(%ls,%p,%p)\n", a0, a1, a2);

    BOOL rv = 0;
    __try {
        rv = Real_BuildCommDCBAndTimeoutsW(a0, a1, a2);
    } __finally {
        _PrintExit("BuildCommDCBAndTimeoutsW(,,) -> %x\n", rv);
    };
    return rv;
}

BOOL WINAPI Mine_BuildCommDCBW(LPCWSTR a0,
                               LPDCB a1)
{
    _PrintEnter("BuildCommDCBW(%ls,%p)\n", a0, a1);

    BOOL rv = 0;
    __try {
        rv = Real_BuildCommDCBW(a0, a1);
    } __finally {
        _PrintExit("BuildCommDCBW(,) -> %x\n", rv);
    };
    return rv;
}

BOOL WINAPI Mine_ClearCommBreak(HANDLE a0)
{
    _PrintEnter("ClearCommBreak(%p)\n", a0);

    BOOL rv = 0;
    __try {
        rv = Real_ClearCommBreak(a0);
    } __finally {
        _PrintExit("ClearCommBreak() -> %x\n", rv);
    };
    return rv;
}

BOOL WINAPI Mine_ClearCommError(HANDLE a0,
                                LPDWORD a1,
                                LPCOMSTAT a2)
{
    _PrintEnter("ClearCommError(%p,%p,%p)\n", a0, a1, a2);

    BOOL rv = 0;
    __try {
        rv = Real_ClearCommError(a0, a1, a2);
    } __finally {
        _PrintExit("ClearCommError(,,) -> %x\n", rv);
    };
    return rv;
}

BOOL WINAPI Mine_CloseHandle(HANDLE a0)
{
    _PrintEnter("CloseHandle(%p)\n", a0);

    BOOL rv = 0;
    __try {
        rv = Real_CloseHandle(a0);
    } __finally {
        _PrintExit("CloseHandle() -> %x\n", rv);
    };
    return rv;
}

HANDLE WINAPI Mine_CreateFileA(LPCSTR a0,
                               DWORD a1,
                               DWORD a2,
                               LPSECURITY_ATTRIBUTES a3,
                               DWORD a4,
                               DWORD a5,
                               HANDLE a6)
{
    _PrintEnter("CreateFileA(%hs,%x,%x,%p,%x,%x,%p)\n", a0, a1, a2, a3, a4, a5, a6);

    HANDLE rv = 0;
    __try {
        rv = Real_CreateFileA(a0, a1, a2, a3, a4, a5, a6);
    } __finally {
        _PrintExit("CreateFileA(,,,,,,) -> %p\n", rv);
    };
    return rv;
}

HANDLE WINAPI Mine_CreateFileW(LPCWSTR a0,
                               DWORD a1,
                               DWORD a2,
                               LPSECURITY_ATTRIBUTES a3,
                               DWORD a4,
                               DWORD a5,
                               HANDLE a6)
{
    _PrintEnter("CreateFileW(%ls,%x,%x,%p,%x,%x,%p)\n", a0, a1, a2, a3, a4, a5, a6);

    HANDLE rv = 0;
    __try {
        rv = Real_CreateFileW(a0, a1, a2, a3, a4, a5, a6);
    } __finally {
        _PrintExit("CreateFileW(,,,,,,) -> %p\n", rv);
    };
    return rv;
}

BOOL WINAPI Mine_EscapeCommFunction(HANDLE a0,
                                    DWORD a1)
{
    _PrintEnter("EscapeCommFunction(%p,%x)\n", a0, a1);

    BOOL rv = 0;
    __try {
        rv = Real_EscapeCommFunction(a0, a1);
    } __finally {
        _PrintExit("EscapeCommFunction(,) -> %x\n", rv);
    };
    return rv;
}

BOOL WINAPI Mine_GetCommConfig(HANDLE a0,
                               LPCOMMCONFIG a1,
                               LPDWORD a2)
{
    _PrintEnter("GetCommConfig(%p,%p,%p)\n", a0, a1, a2);

    BOOL rv = 0;
    __try {
        rv = Real_GetCommConfig(a0, a1, a2);
    } __finally {
        _PrintExit("GetCommConfig(,,) -> %x\n", rv);
    };
    return rv;
}

BOOL WINAPI Mine_GetCommMask(HANDLE a0,
                                LPDWORD a1)
{
    _PrintEnter("GetCommMask(%p,%p)\n", a0, a1);

    BOOL rv = 0;
    __try {
        rv = Real_GetCommMask(a0, a1);
    } __finally {
        _PrintExit("GetCommMask(,) -> %x\n", rv);
    };
    return rv;
}

BOOL WINAPI Mine_GetCommModemStatus(HANDLE a0,
                                    LPDWORD a1)
{
    _PrintEnter("GetCommModemStatus(%p,%p)\n", a0, a1);

    BOOL rv = 0;
    __try {
        rv = Real_GetCommModemStatus(a0, a1);
    } __finally {
        _PrintExit("GetCommModemStatus(,) -> %x\n", rv);
    };
    return rv;
}

BOOL WINAPI Mine_GetCommProperties(HANDLE a0,
                                   LPCOMMPROP a1)
{
    _PrintEnter("GetCommProperties(%p,%p)\n", a0, a1);

    BOOL rv = 0;
    __try {
        rv = Real_GetCommProperties(a0, a1);
    } __finally {
        _PrintExit("GetCommProperties(,) -> %x\n", rv);
    };
    return rv;
}

BOOL WINAPI Mine_GetCommState(HANDLE a0,
                              LPDCB a1)
{
    _PrintEnter("GetCommState(%p,%p)\n", a0, a1);

    BOOL rv = 0;
    __try {
        rv = Real_GetCommState(a0, a1);
    } __finally {
        _PrintExit("GetCommState(,) -> %x\n", rv);
    };
    return rv;
}

BOOL WINAPI Mine_GetCommTimeouts(HANDLE a0,
                                 LPCOMMTIMEOUTS a1)
{
    _PrintEnter("GetCommTimeouts(%p,%p)\n", a0, a1);

    BOOL rv = 0;
    __try {
        rv = Real_GetCommTimeouts(a0, a1);
    } __finally {
        _PrintExit("GetCommTimeouts(,) -> %x\n", rv);
    };
    return rv;
}

DWORD WINAPI Mine_GetCurrentThreadId(void)
{
    _PrintEnter("GetCurrentThreadId()\n");

    DWORD rv = 0;
    __try {
        rv = Real_GetCurrentThreadId();
    } __finally {
        _PrintExit("GetCurrentThreadId() -> %x\n", rv);
    };
    return rv;
}

DWORD WINAPI Mine_GetModuleFileNameW(HINSTANCE a0,
                                     LPWSTR a1,
                                     DWORD a2)
{
    _PrintEnter("GetModuleFileNameW(%p,%p,%x)\n", a0, a1, a2);

    DWORD rv = 0;
    __try {
        rv = Real_GetModuleFileNameW(a0, a1, a2);
    } __finally {
        _PrintExit("GetModuleFileNameW(,%ls,) -> %x\n", a1, rv);
    };
    return rv;
}

BOOL WINAPI Mine_GetOverlappedResult(HANDLE a0,
                                     LPOVERLAPPED a1,
                                     LPDWORD a2,
                                     BOOL a3)
{
    _PrintEnter("GetOverlappedResult(%p,%p,%p,%x)\n", a0, a1, a2, a3);

    BOOL rv = 0;
    __try {
        rv = Real_GetOverlappedResult(a0, a1, a2, a3);
    } __finally {
        _PrintExit("GetOverlappedResult(,,,) -> %x\n", rv);
    };
    return rv;
}

BOOL WINAPI Mine_PurgeComm(HANDLE a0,
                           DWORD a1)
{
    _PrintEnter("PurgeComm(%p,%x)\n", a0, a1);

    BOOL rv = 0;
    __try {
        rv = Real_PurgeComm(a0, a1);
    } __finally {
        _PrintExit("PurgeComm(,) -> %x\n", rv);
    };
    return rv;
}

BOOL WINAPI Mine_ReadFile(HANDLE a0,
                          LPVOID a1,
                          DWORD a2,
                          LPDWORD a3,
                          LPOVERLAPPED a4)
{
    _PrintEnter("ReadFile(%p,%p,%x,%p,%p)\n", a0, a1, a2, a3, a4);

    BOOL rv = 0;
    __try {
        rv = Real_ReadFile(a0, a1, a2, a3, a4);
    } __finally {
        _PrintExit("ReadFile(,,,,) -> %x\n", rv);
    };
    return rv;
}

BOOL WINAPI Mine_SetCommBreak(HANDLE a0)
{
    _PrintEnter("SetCommBreak(%p)\n", a0);

    BOOL rv = 0;
    __try {
        rv = Real_SetCommBreak(a0);
    } __finally {
        _PrintExit("SetCommBreak() -> %x\n", rv);
    };
    return rv;
}

BOOL WINAPI Mine_SetCommConfig(HANDLE a0,
                               LPCOMMCONFIG a1,
                               DWORD a2)
{
    _PrintEnter("SetCommConfig(%p,%p,%x)\n", a0, a1, a2);

    BOOL rv = 0;
    __try {
        rv = Real_SetCommConfig(a0, a1, a2);
    } __finally {
        _PrintExit("SetCommConfig(,,) -> %x\n", rv);
    };
    return rv;
}

BOOL WINAPI Mine_SetCommMask(HANDLE a0,
                             DWORD a1)
{
    _PrintEnter("SetCommMask(%p,%x)\n", a0, a1);

    BOOL rv = 0;
    __try {
        rv = Real_SetCommMask(a0, a1);
    } __finally {
        _PrintExit("SetCommMask(,) -> %x\n", rv);
    };
    return rv;
}

BOOL WINAPI Mine_SetCommState(HANDLE a0,
                              LPDCB a1)
{
    _PrintEnter("SetCommState(%p,%p)\n", a0, a1);

    BOOL rv = 0;
    __try {
        rv = Real_SetCommState(a0, a1);
    } __finally {
        _PrintExit("SetCommState(,) -> %x\n", rv);
    };
    return rv;
}

BOOL WINAPI Mine_SetCommTimeouts(HANDLE a0,
                                 LPCOMMTIMEOUTS a1)
{
    _PrintEnter("SetCommTimeouts(%p,%p)\n", a0, a1);

    BOOL rv = 0;
    __try {
        rv = Real_SetCommTimeouts(a0, a1);
    } __finally {
        _PrintExit("SetCommTimeouts(,) -> %x\n", rv);
    };
    return rv;
}

BOOL WINAPI Mine_SetupComm(HANDLE a0,
                           DWORD a1,
                           DWORD a2)
{
    _PrintEnter("SetupComm(%p,%x,%x)\n", a0, a1, a2);

    BOOL rv = 0;
    __try {
        rv = Real_SetupComm(a0, a1, a2);
    } __finally {
        _PrintExit("SetupComm(,,) -> %x\n", rv);
    };
    return rv;
}

BOOL WINAPI Mine_TransmitCommChar(HANDLE a0,
                                  char a1)
{
    _PrintEnter("TransmitCommChar(%p,%x)\n", a0, a1);

    BOOL rv = 0;
    __try {
        rv = Real_TransmitCommChar(a0, a1);
    } __finally {
        _PrintExit("TransmitCommChar(,) -> %x\n", rv);
    };
    return rv;
}

BOOL WINAPI Mine_WaitCommEvent(HANDLE a0,
                               LPDWORD a1,
                               LPOVERLAPPED a2)
{
    _PrintEnter("WaitCommEvent(%p,%p,%p)\n", a0, a1, a2);

    BOOL rv = 0;
    __try {
        rv = Real_WaitCommEvent(a0, a1, a2);
    } __finally {
        _PrintExit("WaitCommEvent(,,) -> %x\n", rv);
    };
    return rv;
}

BOOL WINAPI Mine_WriteFile(HANDLE a0,
                           LPCVOID a1,
                           DWORD a2,
                           LPDWORD a3,
                           LPOVERLAPPED a4)
{
    _PrintEnter("WriteFile(%p,%p,%x,%p,%p)\n", a0, a1, a2, a3, a4);

    BOOL rv = 0;
    __try {
        _PrintDump(a0, (PCHAR)a1, a2);
        rv = Real_WriteFile(a0, a1, a2, a3, a4);
    } __finally {
        _PrintExit("WriteFile(,,,,) -> %x\n", rv);
    };
    return rv;
}

/////////////////////////////////////////////////////////////
// AttachDetours
//
PCHAR DetRealName(PCHAR psz)
{
    PCHAR pszBeg = psz;
    // Move to end of name.
    while (*psz) {
        psz++;
    }
    // Move back through A-Za-z0-9 names.
    while (psz > pszBeg &&
           ((psz[-1] >= 'A' && psz[-1] <= 'Z') ||
            (psz[-1] >= 'a' && psz[-1] <= 'z') ||
            (psz[-1] >= '0' && psz[-1] <= '9'))) {
        psz--;
    }
    return psz;
}

VOID DetAttach(PVOID *ppbReal, PVOID pbMine, PCHAR psz)
{
    LONG l = DetourAttach(ppbReal, pbMine);
    if (l != 0) {
        Syelog(SYELOG_SEVERITY_NOTICE,
               "Attach failed: `%s': error %d\n", DetRealName(psz), l);
    }
}

VOID DetDetach(PVOID *ppbReal, PVOID pbMine, PCHAR psz)
{
    LONG l = DetourDetach(ppbReal, pbMine);
    if (l != 0) {
        Syelog(SYELOG_SEVERITY_NOTICE,
               "Detach failed: `%s': error %d\n", DetRealName(psz), l);
    }
}

#define ATTACH(x)       DetAttach(&(PVOID&)Real_##x,Mine_##x,#x)
#define DETACH(x)       DetDetach(&(PVOID&)Real_##x,Mine_##x,#x)

LONG AttachDetours(VOID)
{
    DetourTransactionBegin();
    DetourUpdateThread(GetCurrentThread());

    ATTACH(BuildCommDCBA);
    ATTACH(BuildCommDCBAndTimeoutsA);
    ATTACH(BuildCommDCBAndTimeoutsW);
    ATTACH(BuildCommDCBW);
    ATTACH(ClearCommBreak);
    ATTACH(ClearCommError);
    ATTACH(CloseHandle);
    ATTACH(CreateFileA);
    ATTACH(CreateFileW);
    ATTACH(EscapeCommFunction);
    ATTACH(GetCommConfig);
    ATTACH(GetCommMask);
    ATTACH(GetCommModemStatus);
    ATTACH(GetCommProperties);
    ATTACH(GetCommState);
    ATTACH(GetCommTimeouts);
    ATTACH(GetCurrentThreadId);
    ATTACH(GetModuleFileNameW);
    ATTACH(GetOverlappedResult);
    ATTACH(PurgeComm);
    ATTACH(ReadFile);
    ATTACH(SetCommBreak);
    ATTACH(SetCommConfig);
    ATTACH(SetCommMask);
    ATTACH(SetCommState);
    ATTACH(SetCommTimeouts);
    ATTACH(SetupComm);
    ATTACH(TransmitCommChar);
    ATTACH(WaitCommEvent);
    ATTACH(WriteFile);

    return DetourTransactionCommit();
}

LONG DetachDetours(VOID)
{
    DetourTransactionBegin();
    DetourUpdateThread(GetCurrentThread());

    DETACH(BuildCommDCBA);
    DETACH(BuildCommDCBAndTimeoutsA);
    DETACH(BuildCommDCBAndTimeoutsW);
    DETACH(BuildCommDCBW);
    DETACH(ClearCommBreak);
    DETACH(ClearCommError);
    DETACH(CloseHandle);
    DETACH(CreateFileA);
    DETACH(CreateFileW);
    DETACH(EscapeCommFunction);
    DETACH(GetCommConfig);
    DETACH(GetCommMask);
    DETACH(GetCommModemStatus);
    DETACH(GetCommProperties);
    DETACH(GetCommState);
    DETACH(GetCommTimeouts);
    DETACH(GetCurrentThreadId);
    DETACH(GetModuleFileNameW);
    DETACH(GetOverlappedResult);
    DETACH(PurgeComm);
    DETACH(ReadFile);
    DETACH(SetCommBreak);
    DETACH(SetCommConfig);
    DETACH(SetCommMask);
    DETACH(SetCommState);
    DETACH(SetCommTimeouts);
    DETACH(SetupComm);
    DETACH(TransmitCommChar);
    DETACH(WaitCommEvent);
    DETACH(WriteFile);

    return DetourTransactionCommit();
}

/////////////////////////////////////////////////////////////
// Detours
//

VOID _PrintDump(HANDLE h, PCHAR pszData, INT cbData)
{
    if (pszData && cbData > 0) {
        CHAR szBuffer[256];
        PCHAR pszBuffer = szBuffer;
        INT cbBuffer = 0;
        INT nLines = 0;

        while (cbData > 0) {
            if (nLines > 20) {
                *pszBuffer++ = '.';
                *pszBuffer++ = '.';
                *pszBuffer++ = '.';
                cbBuffer += 3;
                break;
            }

            if (*pszData == '\t') {
                *pszBuffer++ = '\\';
                *pszBuffer++ = 't';
                cbBuffer += 2;
                pszData++;
                cbData--;
                continue;
            }
            if (*pszData == '\r') {
                *pszBuffer++ = '\\';
                *pszBuffer++ = 'r';
                cbBuffer += 2;
                pszData++;
                cbData--;
                continue;
            }
            else if (*pszData == '\n') {
                *pszBuffer++ = '\\';
                *pszBuffer++ = 'n';
                cbBuffer += 2;
                *pszBuffer++ = '\0';
                _Print("%p:   %hs\n", h, szBuffer);
                nLines++;
                pszBuffer = szBuffer;
                cbBuffer = 0;
                pszData++;
                cbData--;
                continue;
            }
            else if (cbBuffer >= 80) {
                *pszBuffer++ = '\0';
                _Print("%p:   %hs\n", h, szBuffer);
                nLines++;
                pszBuffer = szBuffer;
                cbBuffer = 0;
            }

            if (*pszData < ' ' || *pszData >= 127) {
                *pszBuffer++ = '\\';
                *pszBuffer++ = 'x';
                *pszBuffer++ = "0123456789ABCDEF"[(*pszData & 0xf0) >> 4];
                *pszBuffer++ = "0123456789ABCDEF"[(*pszData & 0x0f)];
                cbBuffer += 4;
            }
            else {
                *pszBuffer++ = *pszData;
            }
            cbBuffer++;
            pszData++;
            cbData--;
        }

        if (cbBuffer > 0) {
            *pszBuffer++ = '\0';
            _Print("%p:   %hs\n", h, szBuffer);
        }
    }
}

////////////////////////////////////////////////////////////// Logging System.
//
static BOOL s_bLog = 1;
static LONG s_nTlsIndent = -1;
static LONG s_nTlsThread = -1;
static LONG s_nThreadCnt = 0;

VOID _PrintEnter(const CHAR *psz, ...)
{
    DWORD dwErr = GetLastError();

    LONG nIndent = 0;
    LONG nThread = 0;
    if (s_nTlsIndent >= 0) {
        nIndent = (LONG)(LONG_PTR)TlsGetValue(s_nTlsIndent);
        TlsSetValue(s_nTlsIndent, (PVOID)(LONG_PTR)(nIndent + 1));
    }
    if (s_nTlsThread >= 0) {
        nThread = (LONG)(LONG_PTR)TlsGetValue(s_nTlsThread);
    }

    if (s_bLog && psz) {
        CHAR szBuf[1024];
        PCHAR pszBuf = szBuf;
        PCHAR pszEnd = szBuf + ARRAYSIZE(szBuf) - 1;
        LONG nLen = (nIndent > 0) ? (nIndent < 35 ? nIndent * 2 : 70) : 0;
        *pszBuf++ = (CHAR)('0' + ((nThread / 100) % 10));
        *pszBuf++ = (CHAR)('0' + ((nThread / 10) % 10));
        *pszBuf++ = (CHAR)('0' + ((nThread / 1) % 10));
        *pszBuf++ = ' ';
        while (nLen-- > 0) {
            *pszBuf++ = ' ';
        }

        va_list  args;
        va_start(args, psz);

        while ((*pszBuf++ = *psz++) != 0 && pszBuf < pszEnd) {
            // Copy characters.
        }
        *pszEnd = '\0';
        SyelogV(SYELOG_SEVERITY_INFORMATION,
                szBuf, args);

        va_end(args);
    }
    SetLastError(dwErr);
}

VOID _PrintExit(const CHAR *psz, ...)
{
    DWORD dwErr = GetLastError();

    LONG nIndent = 0;
    LONG nThread = 0;
    if (s_nTlsIndent >= 0) {
        nIndent = (LONG)(LONG_PTR)TlsGetValue(s_nTlsIndent) - 1;
        ASSERT(nIndent >= 0);
        TlsSetValue(s_nTlsIndent, (PVOID)(LONG_PTR)nIndent);
    }
    if (s_nTlsThread >= 0) {
        nThread = (LONG)(LONG_PTR)TlsGetValue(s_nTlsThread);
    }

    if (s_bLog && psz) {
        CHAR szBuf[1024];
        PCHAR pszBuf = szBuf;
        PCHAR pszEnd = szBuf + ARRAYSIZE(szBuf) - 1;
        LONG nLen = (nIndent > 0) ? (nIndent < 35 ? nIndent * 2 : 70) : 0;
        *pszBuf++ = (CHAR)('0' + ((nThread / 100) % 10));
        *pszBuf++ = (CHAR)('0' + ((nThread / 10) % 10));
        *pszBuf++ = (CHAR)('0' + ((nThread / 1) % 10));
        *pszBuf++ = ' ';
        while (nLen-- > 0) {
            *pszBuf++ = ' ';
        }

        va_list  args;
        va_start(args, psz);

        while ((*pszBuf++ = *psz++) != 0 && pszBuf < pszEnd) {
            // Copy characters.
        }
        *pszEnd = '\0';
        SyelogV(SYELOG_SEVERITY_INFORMATION,
                szBuf, args);

        va_end(args);
    }
    SetLastError(dwErr);
}

VOID _Print(const CHAR *psz, ...)
{
    DWORD dwErr = GetLastError();

    LONG nIndent = 0;
    LONG nThread = 0;
    if (s_nTlsIndent >= 0) {
        nIndent = (LONG)(LONG_PTR)TlsGetValue(s_nTlsIndent);
    }
    if (s_nTlsThread >= 0) {
        nThread = (LONG)(LONG_PTR)TlsGetValue(s_nTlsThread);
    }

    if (s_bLog && psz) {
        CHAR szBuf[1024];
        PCHAR pszBuf = szBuf;
        PCHAR pszEnd = szBuf + ARRAYSIZE(szBuf) - 1;
        LONG nLen = (nIndent > 0) ? (nIndent < 35 ? nIndent * 2 : 70) : 0;
        *pszBuf++ = (CHAR)('0' + ((nThread / 100) % 10));
        *pszBuf++ = (CHAR)('0' + ((nThread / 10) % 10));
        *pszBuf++ = (CHAR)('0' + ((nThread / 1) % 10));
        *pszBuf++ = ' ';
        while (nLen-- > 0) {
            *pszBuf++ = ' ';
        }

        va_list  args;
        va_start(args, psz);

        while ((*pszBuf++ = *psz++) != 0 && pszBuf < pszEnd) {
            // Copy characters.
        }
        *pszEnd = '\0';
        SyelogV(SYELOG_SEVERITY_INFORMATION,
                szBuf, args);

        va_end(args);
    }

    SetLastError(dwErr);
}

VOID AssertMessage(CONST PCHAR pszMsg, CONST PCHAR pszFile, ULONG nLine)
{
    Syelog(SYELOG_SEVERITY_FATAL,
           "ASSERT(%s) failed in %s, line %d.\n", pszMsg, pszFile, nLine);
}

//////////////////////////////////////////////////////////////////////////////
//
// DLL module information
//
BOOL ThreadAttach(HMODULE hDll)
{
    (void)hDll;

    if (s_nTlsIndent >= 0) {
        TlsSetValue(s_nTlsIndent, (PVOID)0);
    }
    if (s_nTlsThread >= 0) {
        LONG nThread = InterlockedIncrement(&s_nThreadCnt);
        TlsSetValue(s_nTlsThread, (PVOID)(LONG_PTR)nThread);
    }
    return TRUE;
}

BOOL ThreadDetach(HMODULE hDll)
{
    (void)hDll;

    if (s_nTlsIndent >= 0) {
        TlsSetValue(s_nTlsIndent, (PVOID)0);
    }
    if (s_nTlsThread >= 0) {
        TlsSetValue(s_nTlsThread, (PVOID)0);
    }
    return TRUE;
}

BOOL ProcessAttach(HMODULE hDll)
{
    s_bLog = FALSE;
    s_nTlsIndent = TlsAlloc();
    s_nTlsThread = TlsAlloc();

    WCHAR wzExePath[MAX_PATH];

    s_hInst = hDll;
    Real_GetModuleFileNameA(s_hInst, s_szDllPath, ARRAYSIZE(s_szDllPath));
    Real_GetModuleFileNameW(NULL, wzExePath, ARRAYSIZE(wzExePath));

    SyelogOpen("trcser" DETOURS_STRINGIFY(DETOURS_BITS), SYELOG_FACILITY_APPLICATION);
    Syelog(SYELOG_SEVERITY_INFORMATION,
           "##################################################################\n");
    Syelog(SYELOG_SEVERITY_INFORMATION,
           "### %ls\n", wzExePath);
    LONG error = AttachDetours();
    if (error != NO_ERROR) {
        Syelog(SYELOG_SEVERITY_FATAL, "### Error attaching detours: %d\n", error);
    }

    ThreadAttach(hDll);

    s_bLog = TRUE;
    return TRUE;
}

BOOL ProcessDetach(HMODULE hDll)
{
    ThreadDetach(hDll);
    s_bLog = FALSE;

    LONG error = DetachDetours();
    if (error != NO_ERROR) {
        Syelog(SYELOG_SEVERITY_FATAL, "### Error detaching detours: %d\n", error);
    }

    Syelog(SYELOG_SEVERITY_NOTICE, "### Closing.\n");
    SyelogClose(FALSE);

    if (s_nTlsIndent >= 0) {
        TlsFree(s_nTlsIndent);
    }
    if (s_nTlsThread >= 0) {
        TlsFree(s_nTlsThread);
    }
    return TRUE;
}

BOOL APIENTRY DllMain(HINSTANCE hModule, DWORD dwReason, PVOID lpReserved)
{
    (void)hModule;
    (void)lpReserved;

    if (DetourIsHelperProcess()) {
        return TRUE;
    }

    switch (dwReason) {
      case DLL_PROCESS_ATTACH:
        DetourRestoreAfterWith();
        return ProcessAttach(hModule);
      case DLL_PROCESS_DETACH:
        return ProcessDetach(hModule);
      case DLL_THREAD_ATTACH:
        return ThreadAttach(hModule);
      case DLL_THREAD_DETACH:
        return ThreadDetach(hModule);
    }
    return TRUE;
}
//
///////////////////////////////////////////////////////////////// End of File.

```

`samples/traceser/trcser.rc`:

```rc
//////////////////////////////////////////////////////////////////////////////
//
//  Version information for trcser.rc.
//
//  Microsoft Research Detours Package
//
//  Copyright (c) Microsoft Corporation.  All rights reserved.
//

#include "detver.h"

#define VER_INTERNALNAME_STR        "trcser" DETOURS_STRINGIFY(DETOURS_BITS)
#define VER_ORIGINALFILENAME_STR    "trcsrc" DETOURS_STRINGIFY(DETOURS_BITS) ".dll"
#define VER_FILEDESCRIPTION_STR     "Detours Serial Trace Module"
#define VER_COMPANYNAME_STR         "Microsoft Corporation"

#include "common.ver"

```

`samples/tracessl/Makefile`:

```
##############################################################################
##
##  Utility to trace WinSock SSL APIs.
##
##  Microsoft Research Detours Package
##
##  Copyright (c) Microsoft Corporation.  All rights reserved.
##

!include ..\common.mak

LIBS=$(LIBS) kernel32.lib ws2_32.lib secur32.lib

##############################################################################

all: dirs \
    $(BIND)\trcssl$(DETOURS_BITS).dll \
!IF $(DETOURS_SOURCE_BROWSING)==1
    $(OBJD)\trcssl$(DETOURS_BITS).bsc \
!ENDIF
    option

##############################################################################

dirs:
    @if not exist $(BIND) mkdir $(BIND) && echo.   Created $(BIND)
    @if not exist $(OBJD) mkdir $(OBJD) && echo.   Created $(OBJD)

$(OBJD)\trcssl.obj : trcssl.cpp

$(OBJD)\trcssl.res : trcssl.rc

$(BIND)\trcssl$(DETOURS_BITS).dll : $(OBJD)\trcssl.obj $(OBJD)\trcssl.res $(DEPS)
    cl /LD $(CFLAGS) /Fe$@ /Fd$(@R).pdb \
        $(OBJD)\trcssl.obj $(OBJD)\trcssl.res \
        /link $(LINKFLAGS) /subsystem:console \
        /export:DetourFinishHelperProcess,@1,NONAME \
        $(LIBS)

$(OBJD)\trcssl$(DETOURS_BITS).bsc : $(OBJD)\trcssl.obj
    bscmake /v /n /o $@ $(OBJD)\trcssl.sbr

##############################################################################

clean:
    -del *~ test.txt 2>nul
    -del $(BIND)\trcssl*.* 2>nul
    -rmdir /q /s $(OBJD) 2>nul

realclean: clean
    -rmdir /q /s $(OBJDS) 2>nul

############################################### Install non-bit-size binaries.

!IF "$(DETOURS_OPTION_PROCESSOR)" != ""

$(OPTD)\trcssl$(DETOURS_OPTION_BITS).dll:
$(OPTD)\trcssl$(DETOURS_OPTION_BITS).pdb:

$(BIND)\trcssl$(DETOURS_OPTION_BITS).dll : $(OPTD)\trcssl$(DETOURS_OPTION_BITS).dll
    @if exist $? copy /y $? $(BIND) >nul && echo $@ copied from $(DETOURS_OPTION_PROCESSOR).
$(BIND)\trcssl$(DETOURS_OPTION_BITS).pdb : $(OPTD)\trcssl$(DETOURS_OPTION_BITS).pdb
    @if exist $? copy /y $? $(BIND) >nul && echo $@ copied from $(DETOURS_OPTION_PROCESSOR).

option: \
    $(BIND)\trcssl$(DETOURS_OPTION_BITS).dll \
    $(BIND)\trcssl$(DETOURS_OPTION_BITS).pdb \

!ELSE

option:

!ENDIF

##############################################################################

test: all
    @echo -------- Logging output to test.txt ------------
    start $(BIND)\syelogd.exe /o test.txt
    $(BIND)\sleep5.exe 1
    @echo -------- Should load trcssl$(DETOURS_BITS).dll dynamically using withdll.exe ------------
    @echo.
    @echo ** NOTE NOTE NOTE NOTE NOTE NOTE NOTE NOTE NOTE NOTE NOTE **
    @echo **
    @echo ** Close the Internet Explorer window to continue test.
    @echo **
    @echo ** NOTE NOTE NOTE NOTE NOTE NOTE NOTE NOTE NOTE NOTE NOTE **
    @echo.
    $(BIND)\withdll -d:$(BIND)\trcssl$(DETOURS_BITS).dll \
        "c:\program files\Internet Explorer\iexplore.exe" "https://www.microsoft.com"
    @echo -------- Log from syelog -------------
    type test.txt

################################################################# End of File.

```

`samples/tracessl/trcssl.cpp`:

```cpp
//////////////////////////////////////////////////////////////////////////////
//
//  Detours Test Program (trcssl.cpp of trcssl.dll)
//
//  Microsoft Research Detours Package
//
//  Copyright (c) Microsoft Corporation.  All rights reserved.
//
#define _WIN32_WINNT        0x0400
#define WIN32
#define NT
#define SECURITY_WIN32
#define _WINSOCK_DEPRECATED_NO_WARNINGS

#define DBG_TRACE   0

#if _MSC_VER >= 1300
#include <winsock2.h>
#endif
#include <windows.h>
#include <security.h>
#include <stdio.h>
#include "detours.h"
#include "syelog.h"

#define PULONG_PTR          PVOID
#define PLONG_PTR           PVOID
#define ULONG_PTR           PVOID
#define ENUMRESNAMEPROCA    PVOID
#define ENUMRESNAMEPROCW    PVOID
#define ENUMRESLANGPROCA    PVOID
#define ENUMRESLANGPROCW    PVOID
#define ENUMRESTYPEPROCA    PVOID
#define ENUMRESTYPEPROCW    PVOID
#define STGOPTIONS          PVOID

//////////////////////////////////////////////////////////////////////////////
#pragma warning(disable:4127)   // Many of our asserts are constants.

#define ASSERT_ALWAYS(x)   \
    do {                                                        \
    if (!(x)) {                                                 \
            AssertMessage(#x, __FILE__, __LINE__);              \
            DebugBreak();                                       \
    }                                                           \
    } while (0)

#ifndef NDEBUG
#define ASSERT(x)           ASSERT_ALWAYS(x)
#else
#define ASSERT(x)
#endif

#define UNUSED(c)       (c) = (c)

//////////////////////////////////////////////////////////////////////////////
static HMODULE s_hInst = NULL;
static WCHAR s_wzDllPath[MAX_PATH];

VOID _PrintDump(SOCKET socket, PCHAR pszData, INT cbData);
VOID _PrintEnter(PCSTR psz, ...);
VOID _PrintExit(PCSTR psz, ...);
VOID _Print(PCSTR psz, ...);

VOID AssertMessage(CONST PCHAR pszMsg, CONST PCHAR pszFile, ULONG nLine);

//////////////////////////////////////////////////////////////////////////////
//
extern "C" {
    HANDLE (WINAPI * Real_CreateFileW)(LPCWSTR a0,
                                       DWORD a1,
                                       DWORD a2,
                                       LPSECURITY_ATTRIBUTES a3,
                                       DWORD a4,
                                       DWORD a5,
                                       HANDLE a6)
        = CreateFileW;

    BOOL (WINAPI * Real_WriteFile)(HANDLE hFile,
                                   LPCVOID lpBuffer,
                                   DWORD nNumberOfBytesToWrite,
                                   LPDWORD lpNumberOfBytesWritten,
                                   LPOVERLAPPED lpOverlapped)
        = WriteFile;

    BOOL (WINAPI * Real_FlushFileBuffers)(HANDLE hFile)
        = FlushFileBuffers;

    BOOL (WINAPI * Real_CloseHandle)(HANDLE hObject)
        = CloseHandle;

    BOOL (WINAPI * Real_WaitNamedPipeW)(LPCWSTR lpNamedPipeName, DWORD nTimeOut)
        = WaitNamedPipeW;

    BOOL (WINAPI * Real_SetNamedPipeHandleState)(HANDLE hNamedPipe,
                                                 LPDWORD lpMode,
                                                 LPDWORD lpMaxCollectionCount,
                                                 LPDWORD lpCollectDataTimeout)
        = SetNamedPipeHandleState;

    DWORD (WINAPI * Real_GetCurrentProcessId)(VOID)
        = GetCurrentProcessId;

    VOID (WINAPI * Real_GetSystemTimeAsFileTime)(LPFILETIME lpSystemTimeAsFileTime)
        = GetSystemTimeAsFileTime;

    VOID (WINAPI * Real_InitializeCriticalSection)(LPCRITICAL_SECTION lpSection)
        = InitializeCriticalSection;

    VOID (WINAPI * Real_EnterCriticalSection)(LPCRITICAL_SECTION lpSection)
        = EnterCriticalSection;

    VOID (WINAPI * Real_LeaveCriticalSection)(LPCRITICAL_SECTION lpSection)
        = LeaveCriticalSection;
}

DWORD (WINAPI * Real_GetModuleFileNameW)(HMODULE a0,
                                         LPWSTR a1,
                                         DWORD a2)
    = GetModuleFileNameW;

BOOL (WINAPI * Real_CreateProcessW)(LPCWSTR a0,
                                    LPWSTR a1,
                                    LPSECURITY_ATTRIBUTES a2,
                                    LPSECURITY_ATTRIBUTES a3,
                                    BOOL a4,
                                    DWORD a5,
                                    LPVOID a6,
                                    LPCWSTR a7,
                                    LPSTARTUPINFOW a8,
                                    LPPROCESS_INFORMATION a9)
    = CreateProcessW;

#if _MSC_VER < 1300
SOCKET (WINAPI * Real_WSAAccept)(SOCKET a0,
                                 sockaddr* a1,
                                 LPINT a2,
                                 LPCONDITIONPROC a3,
                                 DWORD a4)
    = WSAAccept;
#else
SOCKET (WINAPI * Real_WSAAccept)(SOCKET a0,
                                 sockaddr* a1,
                                 LPINT a2,
                                 LPCONDITIONPROC a3,
                                 DWORD_PTR a4)
    = WSAAccept;
#endif

INT (WINAPI * Real_WSAAddressToStringA)(LPSOCKADDR a0,
                                        DWORD a1,
                                        LPWSAPROTOCOL_INFOA a2,
                                        LPSTR a3,
                                        LPDWORD a4)
    = WSAAddressToStringA;

INT (WINAPI * Real_WSAAddressToStringW)(LPSOCKADDR a0,
                                        DWORD a1,
                                        LPWSAPROTOCOL_INFOW a2,
                                        LPWSTR a3,
                                        LPDWORD a4)
    = WSAAddressToStringW;

HANDLE (WINAPI * Real_WSAAsyncGetHostByAddr)(HWND a0,
                                             u_int a1,
                                             CONST char* a2,
                                             int a3,
                                             int a4,
                                             char* a5,
                                             int a6)
    = WSAAsyncGetHostByAddr;

HANDLE (WINAPI * Real_WSAAsyncGetHostByName)(HWND a0,
                                             u_int a1,
                                             CONST char* a2,
                                             char* a3,
                                             int a4)
    = WSAAsyncGetHostByName;

HANDLE (WINAPI * Real_WSAAsyncGetProtoByName)(HWND a0,
                                              u_int a1,
                                              CONST char* a2,
                                              char* a3,
                                              int a4)
    = WSAAsyncGetProtoByName;

HANDLE (WINAPI * Real_WSAAsyncGetProtoByNumber)(HWND a0,
                                                u_int a1,
                                                int a2,
                                                char* a3,
                                                int a4)
    = WSAAsyncGetProtoByNumber;

HANDLE (WINAPI * Real_WSAAsyncGetServByName)(HWND a0,
                                             u_int a1,
                                             CONST char* a2,
                                             CONST char* a3,
                                             char* a4,
                                             int a5)
    = WSAAsyncGetServByName;

HANDLE (WINAPI * Real_WSAAsyncGetServByPort)(HWND a0,
                                             u_int a1,
                                             int a2,
                                             CONST char* a3,
                                             char* a4,
                                             int a5)
    = WSAAsyncGetServByPort;

int (WINAPI * Real_WSACancelAsyncRequest)(HANDLE a0)
    = WSACancelAsyncRequest;

int (WINAPI * Real_WSACancelBlockingCall)(void)
    = WSACancelBlockingCall;

int (WINAPI * Real_WSACleanup)(void)
    = WSACleanup;

BOOL (WINAPI * Real_WSACloseEvent)(HANDLE a0)
    = WSACloseEvent;

int (WINAPI * Real_WSAConnect)(SOCKET a0,
                               CONST sockaddr* a1,
                               int a2,
                               LPWSABUF a3,
                               LPWSABUF a4,
                               LPQOS a5,
                               LPQOS a6)
    = WSAConnect;

HANDLE (WINAPI * Real_WSACreateEvent)(void)
    = WSACreateEvent;

int (WINAPI * Real_WSADuplicateSocketA)(SOCKET a0,
                                        DWORD a1,
                                        LPWSAPROTOCOL_INFOA a2)
    = WSADuplicateSocketA;

int (WINAPI * Real_WSADuplicateSocketW)(SOCKET a0,
                                        DWORD a1,
                                        LPWSAPROTOCOL_INFOW a2)
    = WSADuplicateSocketW;

INT (WINAPI * Real_WSAEnumNameSpaceProvidersA)(LPDWORD a0,
                                               LPWSANAMESPACE_INFOA a1)
    = WSAEnumNameSpaceProvidersA;

INT (WINAPI * Real_WSAEnumNameSpaceProvidersW)(LPDWORD a0,
                                               LPWSANAMESPACE_INFOW a1)
    = WSAEnumNameSpaceProvidersW;

int (WINAPI * Real_WSAEnumNetworkEvents)(SOCKET a0,
                                         HANDLE a1,
                                         LPWSANETWORKEVENTS a2)
    = WSAEnumNetworkEvents;

int (WINAPI * Real_WSAEnumProtocolsA)(LPINT a0,
                                      LPWSAPROTOCOL_INFOA a1,
                                      LPDWORD a2)
    = WSAEnumProtocolsA;

int (WINAPI * Real_WSAEnumProtocolsW)(LPINT a0,
                                      LPWSAPROTOCOL_INFOW a1,
                                      LPDWORD a2)
    = WSAEnumProtocolsW;

BOOL (WINAPI * Real_WSAGetOverlappedResult)(SOCKET a0,
                                            LPWSAOVERLAPPED a1,
                                            LPDWORD a2,
                                            BOOL a3,
                                            LPDWORD a4)
    = WSAGetOverlappedResult;

BOOL (WINAPI * Real_WSAIsBlocking)(void)
    = WSAIsBlocking;

SOCKET (WINAPI * Real_WSAJoinLeaf)(SOCKET a0,
                                   CONST sockaddr* a1,
                                   int a2,
                                   LPWSABUF a3,
                                   LPWSABUF a4,
                                   LPQOS a5,
                                   LPQOS a6,
                                   DWORD a7)
    = WSAJoinLeaf;

INT (WINAPI * Real_WSAProviderConfigChange)(LPHANDLE a0,
                                            LPWSAOVERLAPPED a1,
                                            LPWSAOVERLAPPED_COMPLETION_ROUTINE a2)
    = WSAProviderConfigChange;

int (WINAPI * Real_WSARecv)(SOCKET a0,
                            LPWSABUF a1,
                            DWORD a2,
                            LPDWORD a3,
                            LPDWORD a4,
                            LPWSAOVERLAPPED a5,
                            LPWSAOVERLAPPED_COMPLETION_ROUTINE a6)
    = WSARecv;

int (WINAPI * Real_WSARecvDisconnect)(SOCKET a0,
                                      LPWSABUF a1)
    = WSARecvDisconnect;

int (WINAPI * Real_WSARecvFrom)(SOCKET a0,
                                LPWSABUF a1,
                                DWORD a2,
                                LPDWORD a3,
                                LPDWORD a4,
                                sockaddr* a5,
                                LPINT a6,
                                LPWSAOVERLAPPED a7,
                                LPWSAOVERLAPPED_COMPLETION_ROUTINE a8)
    = WSARecvFrom;

BOOL (WINAPI * Real_WSAResetEvent)(HANDLE a0)
    = WSAResetEvent;

int (WINAPI * Real_WSASend)(SOCKET a0,
                            LPWSABUF a1,
                            DWORD a2,
                            LPDWORD a3,
                            DWORD a4,
                            LPWSAOVERLAPPED a5,
                            LPWSAOVERLAPPED_COMPLETION_ROUTINE a6)
    = WSASend;

int (WINAPI * Real_WSASendDisconnect)(SOCKET a0,
                                      LPWSABUF a1)
    = WSASendDisconnect;

int (WINAPI * Real_WSASendTo)(SOCKET a0,
                              LPWSABUF a1,
                              DWORD a2,
                              LPDWORD a3,
                              DWORD a4,
                              CONST sockaddr* a5,
                              int a6,
                              LPWSAOVERLAPPED a7,
                              LPWSAOVERLAPPED_COMPLETION_ROUTINE a8)
    = WSASendTo;

INT (WINAPI * Real_WSAStringToAddressA)(LPSTR a0,
                                        INT a1,
                                        LPWSAPROTOCOL_INFOA a2,
                                        LPSOCKADDR a3,
                                        LPINT a4)
    = WSAStringToAddressA;

INT (WINAPI * Real_WSAStringToAddressW)(LPWSTR a0,
                                        INT a1,
                                        LPWSAPROTOCOL_INFOW a2,
                                        LPSOCKADDR a3,
                                        LPINT a4)
    = WSAStringToAddressW;

DWORD (WINAPI * Real_WSAWaitForMultipleEvents)(DWORD a0,
                                               CONST HANDLE * a1,
                                               BOOL a2,
                                               DWORD a3,
                                               BOOL a4)
    = WSAWaitForMultipleEvents;

SOCKET (WINAPI * Real_accept)(SOCKET a0,
                              sockaddr* a1,
                              int* a2)
    = accept;

int (WINAPI * Real_closesocket)(SOCKET a0)
    = closesocket;

int (WINAPI * Real_connect)(SOCKET a0,
                            CONST sockaddr* a1,
                            int a2)
    = connect;

int (WINAPI * Real_listen)(SOCKET a0,
                           int a1)
    = listen;

int (WINAPI * Real_recv)(SOCKET a0,
                         char* a1,
                         int a2,
                         int a3)
    = recv;

int (WINAPI * Real_recvfrom)(SOCKET a0,
                             char* a1,
                             int a2,
                             int a3,
                             sockaddr* a4,
                             int* a5)
    = recvfrom;

int (WINAPI * Real_send)(SOCKET a0,
                         CONST char* a1,
                         int a2,
                         int a3)
    = send;

int (WINAPI * Real_sendto)(SOCKET a0,
                           CONST char* a1,
                           int a2,
                           int a3,
                           CONST sockaddr* a4,
                           int a5)
    = sendto;

int (WINAPI * Real_shutdown)(SOCKET a0,
                             int a1)
    = shutdown;

SECURITY_STATUS (SEC_ENTRY * Real_EncryptMessage)( PCtxtHandle         phContext,
                                                   unsigned long       fQOP,
                                                   PSecBufferDesc      pMessage,
                                                   unsigned long       MessageSeqNo)
    = EncryptMessage;

SECURITY_STATUS (SEC_ENTRY * Real_DecryptMessage)( PCtxtHandle         phContext,
                                                   PSecBufferDesc      pMessage,
                                                   unsigned long       MessageSeqNo,
                                                   unsigned long *     pfQOP)
    = DecryptMessage;

//////////////////////////////////////////////////////////////////////////////
// Detours
//
BOOL WINAPI Mine_CreateProcessW(LPCWSTR lpApplicationName,
                                LPWSTR lpCommandLine,
                                LPSECURITY_ATTRIBUTES lpProcessAttributes,
                                LPSECURITY_ATTRIBUTES lpThreadAttributes,
                                BOOL bInheritHandles,
                                DWORD dwCreationFlags,
                                LPVOID lpEnvironment,
                                LPCWSTR lpCurrentDirectory,
                                LPSTARTUPINFOW lpStartupInfo,
                                LPPROCESS_INFORMATION lpProcessInformation)
{
    _PrintEnter("CreateProcessW(%ls,%ls,%p,%p,%x,%x,%p,%ls,%p,%p)\n",
                lpApplicationName,
                lpCommandLine,
                lpProcessAttributes,
                lpThreadAttributes,
                bInheritHandles,
                dwCreationFlags,
                lpEnvironment,
                lpCurrentDirectory,
                lpStartupInfo,
                lpProcessInformation);

    BOOL rv = 0;
    __try {
        rv = Real_CreateProcessW(lpApplicationName,
                                 lpCommandLine,
                                 lpProcessAttributes,
                                 lpThreadAttributes,
                                 bInheritHandles,
                                 dwCreationFlags,
                                 lpEnvironment,
                                 lpCurrentDirectory,
                                 lpStartupInfo,
                                 lpProcessInformation);
    } __finally {
        _PrintExit("CreateProcessW(,,,,,,,,,) -> %x\n", rv);
    };
    return rv;
}

#if _MSC_VER < 1300
SOCKET WINAPI Mine_WSAAccept(SOCKET a0,
                             sockaddr* a1,
                             LPINT a2,
                             LPCONDITIONPROC a3,
                             DWORD a4)
#else
SOCKET WINAPI Mine_WSAAccept(SOCKET a0,
                             sockaddr* a1,
                             LPINT a2,
                             LPCONDITIONPROC a3,
                             DWORD_PTR a4)
#endif
{

    SOCKET rv = 0;
    __try {
        rv = Real_WSAAccept(a0, a1, a2, a3, a4);
    } __finally {
        _PrintEnter("%p: WSAAccept(,%p,%p,%p,%p) -> %p\n", a0, a1, a2, a3, a4, rv);
        _PrintExit(NULL);
    };
    return rv;
}

INT WINAPI Mine_WSAAddressToStringA(LPSOCKADDR a0,
                                    DWORD a1,
                                    LPWSAPROTOCOL_INFOA a2,
                                    LPSTR a3,
                                    LPDWORD a4)
{
    _PrintEnter("WSAAddressToStringA(%p,%x,%p,%p,%p)\n", a0, a1, a2, a3, a4);

    INT rv = 0;
    __try {
        rv = Real_WSAAddressToStringA(a0, a1, a2, a3, a4);
    } __finally {
        _PrintExit("WSAAddressToStringA(,,,,) -> %x\n", rv);
    };
    return rv;
}

INT WINAPI Mine_WSAAddressToStringW(LPSOCKADDR a0,
                                    DWORD a1,
                                    LPWSAPROTOCOL_INFOW a2,
                                    LPWSTR a3,
                                    LPDWORD a4)
{
    _PrintEnter("WSAAddressToStringW(%p,%x,%p,%p,%p)\n", a0, a1, a2, a3, a4);

    INT rv = 0;
    __try {
        rv = Real_WSAAddressToStringW(a0, a1, a2, a3, a4);
    } __finally {
        _PrintExit("WSAAddressToStringW(,,,,) -> %x\n", rv);
    };
    return rv;
}

HANDLE WINAPI Mine_WSAAsyncGetHostByAddr(HWND a0,
                                         u_int a1,
                                         char* a2,
                                         int a3,
                                         int a4,
                                         char* a5,
                                         int a6)
{
    _PrintEnter("WSAAsyncGetHostByAddr(%p,%x,%p,%x,%x,%p,%x)\n", a0, a1, a2, a3, a4, a5, a6);

    HANDLE rv = 0;
    __try {
        rv = Real_WSAAsyncGetHostByAddr(a0, a1, a2, a3, a4, a5, a6);
    } __finally {
        _PrintExit("WSAAsyncGetHostByAddr(,,,,,,) -> %p\n", rv);
    };
    return rv;
}

HANDLE WINAPI Mine_WSAAsyncGetHostByName(HWND a0,
                                         u_int a1,
                                         char* a2,
                                         char* a3,
                                         int a4)
{
    _PrintEnter("WSAAsyncGetHostByName(%p,%x,%p,%p,%x)\n", a0, a1, a2, a3, a4);

    HANDLE rv = 0;
    __try {
        rv = Real_WSAAsyncGetHostByName(a0, a1, a2, a3, a4);
    } __finally {
        _PrintExit("WSAAsyncGetHostByName(,,,,) -> %p\n", rv);
    };
    return rv;
}

HANDLE WINAPI Mine_WSAAsyncGetProtoByName(HWND a0,
                                          u_int a1,
                                          char* a2,
                                          char* a3,
                                          int a4)
{
    _PrintEnter("WSAAsyncGetProtoByName(%p,%x,%p,%p,%x)\n", a0, a1, a2, a3, a4);

    HANDLE rv = 0;
    __try {
        rv = Real_WSAAsyncGetProtoByName(a0, a1, a2, a3, a4);
    } __finally {
        _PrintExit("WSAAsyncGetProtoByName(,,,,) -> %p\n", rv);
    };
    return rv;
}

HANDLE WINAPI Mine_WSAAsyncGetProtoByNumber(HWND a0,
                                            u_int a1,
                                            int a2,
                                            char* a3,
                                            int a4)
{
    _PrintEnter("WSAAsyncGetProtoByNumber(%p,%x,%p,%p,%x)\n", a0, a1, a2, a3, a4);

    HANDLE rv = 0;
    __try {
        rv = Real_WSAAsyncGetProtoByNumber(a0, a1, a2, a3, a4);
    } __finally {
        _PrintExit("WSAAsyncGetProtoByNumber(,,,,) -> %p\n", rv);
    };
    return rv;
}

HANDLE WINAPI Mine_WSAAsyncGetServByName(HWND a0,
                                         u_int a1,
                                         char* a2,
                                         char* a3,
                                         char* a4,
                                         int a5)
{
    _PrintEnter("WSAAsyncGetServByName(%p,%x,%p,%p,%p,%x)\n", a0, a1, a2, a3, a4, a5);

    HANDLE rv = 0;
    __try {
        rv = Real_WSAAsyncGetServByName(a0, a1, a2, a3, a4, a5);
    } __finally {
        _PrintExit("WSAAsyncGetServByName(,,,,,) -> %p\n", rv);
    };
    return rv;
}

HANDLE WINAPI Mine_WSAAsyncGetServByPort(HWND a0,
                                         u_int a1,
                                         int a2,
                                         char* a3,
                                         char* a4,
                                         int a5)
{
    _PrintEnter("WSAAsyncGetServByPort(%p,%x,%x,%p,%p,%x)\n", a0, a1, a2, a3, a4, a5);

    HANDLE rv = 0;
    __try {
        rv = Real_WSAAsyncGetServByPort(a0, a1, a2, a3, a4, a5);
    } __finally {
        _PrintExit("WSAAsyncGetServByPort(,,,,,) -> %p\n", rv);
    };
    return rv;
}

int WINAPI Mine_WSACancelAsyncRequest(HANDLE a0)
{
    _PrintEnter("WSACancelAsyncRequest(%p)\n", a0);

    int rv = 0;
    __try {
        rv = Real_WSACancelAsyncRequest(a0);
    } __finally {
        _PrintExit("WSACancelAsyncRequest() -> %x\n", rv);
    };
    return rv;
}

int WINAPI Mine_WSACancelBlockingCall(void)
{
    _PrintEnter("WSACancelBlockingCall()\n");

    int rv = 0;
    __try {
        rv = Real_WSACancelBlockingCall();
    } __finally {
        _PrintExit("WSACancelBlockingCall() -> %x\n", rv);
    };
    return rv;
}

int WINAPI Mine_WSACleanup(void)
{
    _PrintEnter("WSACleanup()\n");

    int rv = 0;
    __try {
        rv = Real_WSACleanup();
    } __finally {
        _PrintExit("WSACleanup() -> %x\n", rv);
    };
    return rv;
}

BOOL WINAPI Mine_WSACloseEvent(HANDLE a0)
{
    _PrintEnter("WSACloseEvent(%p)\n", a0);

    BOOL rv = 0;
    __try {
        rv = Real_WSACloseEvent(a0);
    } __finally {
        _PrintExit("WSACloseEvent() -> %x\n", rv);
    };
    return rv;
}

int WINAPI Mine_WSAConnect(SOCKET a0,
                           sockaddr* a1,
                           int a2,
                           LPWSABUF a3,
                           LPWSABUF a4,
                           LPQOS a5,
                           LPQOS a6)
{
    int rv = 0;
    __try {
        rv = Real_WSAConnect(a0, a1, a2, a3, a4, a5, a6);
    } __finally {
        _PrintEnter("%p: WSAConnect(,%p,%x,%p,%p,%p,%p) -> %x\n",
                    a0, a1, a2, a3, a4, a5, a6, rv);
        _PrintExit(NULL);
    };
    return rv;
}

HANDLE WINAPI Mine_WSACreateEvent(void)
{
    _PrintEnter("WSACreateEvent()\n");

    HANDLE rv = 0;
    __try {
        rv = Real_WSACreateEvent();
    } __finally {
        _PrintExit("WSACreateEvent() -> %p\n", rv);
    };
    return rv;
}

int WINAPI Mine_WSADuplicateSocketA(SOCKET a0,
                                    DWORD a1,
                                    LPWSAPROTOCOL_INFOA a2)
{
    _PrintEnter("%p: WSADuplicateSocketA(,%x,%p)\n", a0, a1, a2);

    int rv = 0;
    __try {
        rv = Real_WSADuplicateSocketA(a0, a1, a2);
    } __finally {
        _PrintExit("%p: WSADuplicateSocketA(,,) -> %x\n", a0, rv);
    };
    return rv;
}

int WINAPI Mine_WSADuplicateSocketW(SOCKET a0,
                                    DWORD a1,
                                    LPWSAPROTOCOL_INFOW a2)
{
    _PrintEnter("%p: WSADuplicateSocketW(,%x,%p)\n", a0, a1, a2);

    int rv = 0;
    __try {
        rv = Real_WSADuplicateSocketW(a0, a1, a2);
    } __finally {
        _PrintExit("%p: WSADuplicateSocketW(,,) -> %x\n", a0, rv);
    };
    return rv;
}

INT WINAPI Mine_WSAEnumNameSpaceProvidersA(LPDWORD a0,
                                           LPWSANAMESPACE_INFOA a1)
{
    _PrintEnter("WSAEnumNameSpaceProvidersA(%p,%p)\n", a0, a1);

    INT rv = 0;
    __try {
        rv = Real_WSAEnumNameSpaceProvidersA(a0, a1);
    } __finally {
        _PrintExit("WSAEnumNameSpaceProvidersA(,) -> %x\n", rv);
    };
    return rv;
}

INT WINAPI Mine_WSAEnumNameSpaceProvidersW(LPDWORD a0,
                                           LPWSANAMESPACE_INFOW a1)
{
    _PrintEnter("WSAEnumNameSpaceProvidersW(%p,%p)\n", a0, a1);

    INT rv = 0;
    __try {
        rv = Real_WSAEnumNameSpaceProvidersW(a0, a1);
    } __finally {
        _PrintExit("WSAEnumNameSpaceProvidersW(,) -> %x\n", rv);
    };
    return rv;
}

int WINAPI Mine_WSAEnumNetworkEvents(SOCKET a0,
                                     HANDLE a1,
                                     LPWSANETWORKEVENTS a2)
{
    _PrintEnter("%p: WSAEnumNetworkEvents(,%p,%p)\n", a0, a1, a2);

    int rv = 0;
    __try {
        rv = Real_WSAEnumNetworkEvents(a0, a1, a2);
    } __finally {
        _PrintExit("%p: WSAEnumNetworkEvents(,,) -> %x\n", a0, rv);
    };
    return rv;
}

int WINAPI Mine_WSAEnumProtocolsA(LPINT a0,
                                  LPWSAPROTOCOL_INFOA a1,
                                  LPDWORD a2)
{
    _PrintEnter("WSAEnumProtocolsA(%p,%p,%p)\n", a0, a1, a2);

    int rv = 0;
    __try {
        rv = Real_WSAEnumProtocolsA(a0, a1, a2);
    } __finally {
        _PrintExit("WSAEnumProtocolsA(,,) -> %x\n", rv);
    };
    return rv;
}

int WINAPI Mine_WSAEnumProtocolsW(LPINT a0,
                                  LPWSAPROTOCOL_INFOW a1,
                                  LPDWORD a2)
{
    _PrintEnter("WSAEnumProtocolsW(%p,%p,%p)\n", a0, a1, a2);

    int rv = 0;
    __try {
        rv = Real_WSAEnumProtocolsW(a0, a1, a2);
    } __finally {
        _PrintExit("WSAEnumProtocolsW(,,) -> %x\n", rv);
    };
    return rv;
}

BOOL WINAPI Mine_WSAGetOverlappedResult(SOCKET a0,
                                        LPWSAOVERLAPPED a1,
                                        LPDWORD a2,
                                        BOOL a3,
                                        LPDWORD a4)
{
    _PrintEnter("%p: WSAGetOverlappedResult(,%p,%p,%x,%p)\n", a0, a1, a2, a3, a4);

    BOOL rv = 0;
    __try {
        rv = Real_WSAGetOverlappedResult(a0, a1, a2, a3, a4);
    } __finally {
        _PrintExit("%p: WSAGetOverlappedResult(,,,,) -> %x\n", a0, rv);
    };
    return rv;
}

BOOL WINAPI Mine_WSAIsBlocking(void)
{
    _PrintEnter("WSAIsBlocking()\n");

    BOOL rv = 0;
    __try {
        rv = Real_WSAIsBlocking();
    } __finally {
        _PrintExit("WSAIsBlocking() -> %x\n", rv);
    };
    return rv;
}

SOCKET WINAPI Mine_WSAJoinLeaf(SOCKET a0,
                               sockaddr* a1,
                               int a2,
                               LPWSABUF a3,
                               LPWSABUF a4,
                               LPQOS a5,
                               LPQOS a6,
                               DWORD a7)
{
    _PrintEnter("%p: WSAJoinLeaf(,%p,%x,%p,%p,%p,%p,%x)\n", a0, a1, a2, a3, a4, a5, a6, a7);

    SOCKET rv = 0;
    __try {
        rv = Real_WSAJoinLeaf(a0, a1, a2, a3, a4, a5, a6, a7);
    } __finally {
        _PrintExit("%p: WSAJoinLeaf(,,,,,,,) -> %p\n", a0, rv);
    };
    return rv;
}

INT WINAPI Mine_WSAProviderConfigChange(LPHANDLE a0,
                                        LPWSAOVERLAPPED a1,
                                        LPWSAOVERLAPPED_COMPLETION_ROUTINE a2)
{
    _PrintEnter("WSAProviderConfigChange(%p,%p,%p)\n", a0, a1, a2);

    INT rv = 0;
    __try {
        rv = Real_WSAProviderConfigChange(a0, a1, a2);
    } __finally {
        _PrintExit("WSAProviderConfigChange(,,) -> %x\n", rv);
    };
    return rv;
}

int WINAPI Mine_WSARecv(SOCKET a0,
                        LPWSABUF a1,
                        DWORD a2,
                        LPDWORD a3,
                        LPDWORD a4,
                        LPWSAOVERLAPPED a5,
                        LPWSAOVERLAPPED_COMPLETION_ROUTINE a6)
{
    int rv = -1;
    __try {
        rv = Real_WSARecv(a0, a1, a2, a3, a4, a5, a6);
    } __finally {
        if (rv == 0) {
            _PrintEnter("%p: WSARecv(,%p,%x,%p,%p,%p,%p)\n",
                        a0, a1, a2, a3, a4, a5, a6);
#if 0
            _PrintDump(a0, a1[0].buf, a1[0].len < *a3 ? a1[0].len : *a3);
#endif
            _PrintExit("%p: WSARecv(,,,,,,) -> %x\n", a0, rv);
        }
    };
    return rv;
}

int WINAPI Mine_WSARecvDisconnect(SOCKET a0,
                                  LPWSABUF a1)
{
    _PrintEnter("%p: WSARecvDisconnect(,%p)\n", a0, a1);

    int rv = 0;
    __try {
        rv = Real_WSARecvDisconnect(a0, a1);
    } __finally {
        _PrintExit("%p: WSARecvDisconnect(,) -> %x\n", a0, rv);
    };
    return rv;
}

int WINAPI Mine_WSARecvFrom(SOCKET a0,
                            LPWSABUF a1,
                            DWORD a2,
                            LPDWORD a3,
                            LPDWORD a4,
                            sockaddr* a5,
                            LPINT a6,
                            LPWSAOVERLAPPED a7,
                            LPWSAOVERLAPPED_COMPLETION_ROUTINE a8)
{
    _PrintEnter("%p: WSARecvFrom(,%p,%x,%p,%p,%p,%p,%p,%p)\n", a0, a1, a2, a3, a4, a5, a6, a7, a8);

    int rv = 0;
    __try {
        rv = Real_WSARecvFrom(a0, a1, a2, a3, a4, a5, a6, a7, a8);
    } __finally {
        _PrintExit("%p: WSARecvFrom(,,,,,,,,) -> %x\n", a0, rv);
    };
    return rv;
}

BOOL WINAPI Mine_WSAResetEvent(HANDLE a0)
{
    _PrintEnter("WSAResetEvent(%p)\n", a0);

    BOOL rv = 0;
    __try {
        rv = Real_WSAResetEvent(a0);
    } __finally {
        _PrintExit("WSAResetEvent() -> %x\n", rv);
    };
    return rv;
}

int WINAPI Mine_WSASend(SOCKET a0,
                        LPWSABUF a1,
                        DWORD a2,
                        LPDWORD a3,
                        DWORD a4,
                        LPWSAOVERLAPPED a5,
                        LPWSAOVERLAPPED_COMPLETION_ROUTINE a6)
{
    _PrintEnter("%p: WSASend(,%p,%x,%p,%x,%p,%p)\n", a0, a1, a2, a3, a4, a5, a6);

    int rv = 0;
    __try {
        rv = Real_WSASend(a0, a1, a2, a3, a4, a5, a6);
    } __finally {
        _PrintExit("%p: WSASend(,,,,,,) -> %x\n", a0, rv);
    };
    return rv;
}

int WINAPI Mine_WSASendDisconnect(SOCKET a0,
                                  LPWSABUF a1)
{
    _PrintEnter("%p: WSASendDisconnect(,%p)\n", a0, a1);

    int rv = 0;
    __try {
        rv = Real_WSASendDisconnect(a0, a1);
    } __finally {
        _PrintExit("%p: WSASendDisconnect(,) -> %x\n", a0, rv);
    };
    return rv;
}

int WINAPI Mine_WSASendTo(SOCKET a0,
                          LPWSABUF a1,
                          DWORD a2,
                          LPDWORD a3,
                          DWORD a4,
                          sockaddr* a5,
                          int a6,
                          LPWSAOVERLAPPED a7,
                          LPWSAOVERLAPPED_COMPLETION_ROUTINE a8)
{
    _PrintEnter("%p: WSASendTo(,%p,%x,%p,%x,%p,%x,%p,%p)\n", a0, a1, a2, a3, a4, a5, a6, a7, a8);

    int rv = 0;
    __try {
        rv = Real_WSASendTo(a0, a1, a2, a3, a4, a5, a6, a7, a8);
    } __finally {
        _PrintExit("%p: WSASendTo(,,,,,,,,) -> %x\n", a0, rv);
    };
    return rv;
}

INT WINAPI Mine_WSAStringToAddressA(LPSTR a0,
                                    INT a1,
                                    LPWSAPROTOCOL_INFOA a2,
                                    LPSOCKADDR a3,
                                    LPINT a4)
{
    _PrintEnter("WSAStringToAddressA(%p,%x,%p,%p,%p)\n", a0, a1, a2, a3, a4);

    INT rv = 0;
    __try {
        rv = Real_WSAStringToAddressA(a0, a1, a2, a3, a4);
    } __finally {
        _PrintExit("WSAStringToAddressA(,,,,) -> %x\n", rv);
    };
    return rv;
}

INT WINAPI Mine_WSAStringToAddressW(LPWSTR a0,
                                    INT a1,
                                    LPWSAPROTOCOL_INFOW a2,
                                    LPSOCKADDR a3,
                                    LPINT a4)
{
    _PrintEnter("WSAStringToAddressW(%p,%x,%p,%p,%p)\n", a0, a1, a2, a3, a4);

    INT rv = 0;
    __try {
        rv = Real_WSAStringToAddressW(a0, a1, a2, a3, a4);
    } __finally {
        _PrintExit("WSAStringToAddressW(,,,,) -> %x\n", rv);
    };
    return rv;
}

DWORD WINAPI Mine_WSAWaitForMultipleEvents(DWORD a0,
                                           void** a1,
                                           BOOL a2,
                                           DWORD a3,
                                           BOOL a4)
{
    _PrintEnter("WSAWaitForMultipleEvents(%x,%p,%x,%x,%x)\n", a0, a1, a2, a3, a4);

    DWORD rv = 0;
    __try {
        rv = Real_WSAWaitForMultipleEvents(a0, a1, a2, a3, a4);
    } __finally {
        _PrintExit("WSAWaitForMultipleEvents(,,,,) -> %x\n", rv);
    };
    return rv;
}

SOCKET WINAPI Mine_accept(SOCKET a0,
                          sockaddr* a1,
                          int* a2)
{
    SOCKET rv = 0;
    __try {
        rv = Real_accept(a0, a1, a2);
    } __finally {
        WCHAR wzAddress[512] = L"";
        int err = WSAGetLastError();
        if (rv != INVALID_SOCKET) {
            DWORD nAddress = ARRAYSIZE(wzAddress);
            if (Real_WSAAddressToStringW(a1, *a2, NULL, wzAddress, &nAddress) != 0) {
                wzAddress[0] = 0;
            }
        }
        WSASetLastError(err);

        if (wzAddress[0]) {
            _PrintEnter("%p: accept(,%ls,%p) -> %p\n", a0, wzAddress, a2, rv);
        }
        else {
            _PrintEnter("%p: accept(,%p,%p) -> %p\n", a0, a1, a2, rv);
        }
        _PrintExit(NULL);
    };
    return rv;
}

int WINAPI Mine_closesocket(SOCKET a0)
{
    int rv = 0;
    __try {
        rv = Real_closesocket(a0);
    } __finally {
        _PrintEnter("%p: closesocket() -> %x\n", a0, rv);
        _PrintExit(NULL);
    };
    return rv;
}

int WINAPI Mine_connect(SOCKET a0,
                        sockaddr* name,
                        int namelen)
{
    int rv = 0;
    __try {
        rv = Real_connect(a0, name, namelen);
    } __finally {
        WCHAR wzAddress[512];
        DWORD nAddress = ARRAYSIZE(wzAddress);
        int err = WSAGetLastError();
        if (Real_WSAAddressToStringW(name, namelen, NULL, wzAddress, &nAddress) == 0) {
            if (rv == SOCKET_ERROR) {
                _PrintEnter("%p: connect(,%p:%ls,%x) -> %x [%d]\n",
                            a0, name, wzAddress, namelen, rv, err);
            }
            else {
                _PrintEnter("%p: connect(,%p:%ls,%x) -> %x\n",
                            a0, name, wzAddress, namelen, rv);
            }
        }
        else {
            if (rv == SOCKET_ERROR) {
                _PrintEnter("%p: connect(,%p,%x) -> %x [%d]\n",
                            a0, name, namelen, rv, err);
            }
            else {
                _PrintEnter("%p: connect(,%p,%x) -> %x\n",
                            a0, name, namelen, rv);
            }
        }
        WSASetLastError(err);
        _PrintExit(NULL);
    };
    return rv;
}

int WINAPI Mine_listen(SOCKET a0,
                       int a1)
{
    _PrintEnter("%p: listen(,%x)\n", a0, a1);

    int rv = 0;
    __try {
        rv = Real_listen(a0, a1);
    } __finally {
        _PrintExit("%p: listen(,) -> %x\n", a0, rv);
    };
    return rv;
}

int WINAPI Mine_recv(SOCKET a0,
                     char* a1,
                     int a2,
                     int a3)
{
    _PrintEnter("%p: recv(,%p,%x,%x)\n", a0, a1, a2, a3);

    int rv = 0;
    __try {
        rv = Real_recv(a0, a1, a2, a3);
#if 0
        _PrintDump(a0, a1, rv);
#endif
    } __finally {
        _PrintExit("%p: recv(,%p,,) -> %x\n", a0, a1, rv);
    };
    return rv;
}

int WINAPI Mine_recvfrom(SOCKET a0,
                         char* a1,
                         int a2,
                         int a3,
                         sockaddr* a4,
                         int* a5)
{
    _PrintEnter("%p: recvfrom(,%p,%x,%x,%p,%p)\n", a0, a1, a2, a3, a4, a5);

    int rv = 0;
    __try {
        rv = Real_recvfrom(a0, a1, a2, a3, a4, a5);
#if 0
        _PrintDump(a0, a1, rv);
#endif
    } __finally {
        _PrintExit("%p: recvfrom(,%p,,,,) -> %x\n", a0, a1, rv);
    };
    return rv;
}

VOID _PrintDump(SOCKET socket, PCHAR pszData, INT cbData)
{
    if (pszData && cbData > 0) {
        CHAR szBuffer[256];
        PCHAR pszBuffer = szBuffer;
        INT cbBuffer = 0;
        INT nLines = 0;

        while (cbData > 0) {
#if ABBREVIATE
            if (nLines > 20) {
                *pszBuffer++ = '.';
                *pszBuffer++ = '.';
                *pszBuffer++ = '.';
                cbBuffer += 3;
                break;
            }
#endif

            if (*pszData == '\t') {
                *pszBuffer++ = '\\';
                *pszBuffer++ = 't';
                cbBuffer += 2;
                pszData++;
                cbData--;
                continue;
            }
            if (*pszData == '\r') {
                *pszBuffer++ = '\\';
                *pszBuffer++ = 'r';
                cbBuffer += 2;
                pszData++;
                cbData--;
                continue;
            }
            else if (*pszData == '\n') {
                *pszBuffer++ = '\\';
                *pszBuffer++ = 'n';
                cbBuffer += 2;
                *pszBuffer++ = '\0';
                _Print("%p:   %hs\n", socket, szBuffer);
                nLines++;
                pszBuffer = szBuffer;
                cbBuffer = 0;
                pszData++;
                cbData--;
                continue;
            }
            else if (cbBuffer >= 80) {
                *pszBuffer++ = '\0';
                _Print("%p:   %hs\n", socket, szBuffer);
                nLines++;
                pszBuffer = szBuffer;
                cbBuffer = 0;
            }

            if (*pszData < ' ' || *pszData >= 127) {
                *pszBuffer++ = '\\';
                *pszBuffer++ = 'x';
                *pszBuffer++ = "0123456789ABCDEF"[(*pszData & 0xf0) >> 4];
                *pszBuffer++ = "0123456789ABCDEF"[(*pszData & 0x0f)];
                cbBuffer += 4;
            }
            else {
                *pszBuffer++ = *pszData;
            }
            cbBuffer++;
            pszData++;
            cbData--;
        }

        if (cbBuffer > 0) {
            *pszBuffer++ = '\0';
            _Print("%p:   %hs\n", socket, szBuffer);
        }
    }
}

int WINAPI Mine_send(SOCKET a0,
                     char* a1,
                     int a2,
                     int a3)
{
    _PrintEnter("%p: send(,%p,%x,%x)\n", a0, a1, a2, a3);
#if 0
    _PrintDump(a0, a1, a2);
#endif

    int rv = 0;
    __try {
        rv = Real_send(a0, a1, a2, a3);
    } __finally {
        if (rv == SOCKET_ERROR) {
            int err = WSAGetLastError();
            _PrintExit("%p: send(,,,) -> %x (%d)\n", a0, rv, err);
        }
        else {
            _PrintExit("%p: send(,,,) -> %x\n", a0, rv);
        }
    };
    return rv;
}

int WINAPI Mine_sendto(SOCKET a0,
                       char* a1,
                       int a2,
                       int a3,
                       sockaddr* a4,
                       int a5)
{
    _PrintEnter("%p: sendto(,%s,%x,%x,%p,%x)\n", a0, a1, a2, a3, a4, a5);

    int rv = 0;
    __try {
        rv = Real_sendto(a0, a1, a2, a3, a4, a5);
    } __finally {
        _PrintExit("%p: sendto(%ls,,,,,) -> %x\n", a0, a1, rv);
    };
    return rv;
}

int WINAPI Mine_shutdown(SOCKET a0,
                         int a1)
{
    _PrintEnter("%p: shutdown(,%x)\n", a0, a1);

    int rv = 0;
    __try {
        rv = Real_shutdown(a0, a1);
    } __finally {
        _PrintExit("%p: shutdown(,) -> %x\n", a0, rv);
    };
    return rv;
}

SECURITY_STATUS SEC_ENTRY Mine_EncryptMessage( PCtxtHandle         phContext,
                                               unsigned long       fQOP,
                                               PSecBufferDesc      pMessage,
                                               unsigned long       MessageSeqNo)
{
    _PrintEnter("%p: EncryptMessage(%x,%x,%x)\n", phContext, fQOP, pMessage, MessageSeqNo);

    SECURITY_STATUS rv = 0;
    __try {
        if (pMessage != NULL) {
            for (unsigned b = 0; b < pMessage->cBuffers; b++) {
                PSecBuffer pBuffer = &pMessage->pBuffers[b];
                if ((pBuffer->BufferType & 0xfff) == 1) {
                    _Print("%p:  Type=%08x Size=%d\n", phContext,
                           pBuffer->BufferType,
                           pBuffer->cbBuffer);
                    _PrintDump((SOCKET)phContext, (PCHAR)pBuffer->pvBuffer, pBuffer->cbBuffer);
                }
            }
        }
        rv = Real_EncryptMessage(phContext, fQOP, pMessage, MessageSeqNo);
    } __finally {
        _PrintExit("%p: EncryptMessage(,) -> %x\n", phContext, rv);
    };
    return rv;
}

SECURITY_STATUS SEC_ENTRY Mine_DecryptMessage( PCtxtHandle         phContext,
                                               PSecBufferDesc      pMessage,
                                               unsigned long       MessageSeqNo,
                                               unsigned long *     pfQOP)
{
    _PrintEnter("%p: DecryptMessage(%x,%x,%x)\n", phContext, pMessage, MessageSeqNo, pfQOP);

    SECURITY_STATUS rv = 0;
    __try {
        rv = Real_DecryptMessage(phContext, pMessage, MessageSeqNo, pfQOP);
        for (unsigned b = 0; b < pMessage->cBuffers; b++) {
            PSecBuffer pBuffer = &pMessage->pBuffers[b];
            if ((pBuffer->BufferType & 0xfff) == 1) {
                _Print("%p:  Type=%08x Size=%d\n", phContext,
                       pBuffer->BufferType,
                       pBuffer->cbBuffer);
                _PrintDump((SOCKET)phContext, (PCHAR)pBuffer->pvBuffer, pBuffer->cbBuffer);
            }
        }
    } __finally {
        _PrintExit("%p: DecryptMessage(,) -> %x\n", phContext, rv);
    };
    return rv;
}

/////////////////////////////////////////////////////////////
// AttachDetours
//
PCHAR DetRealName(PCHAR psz)
{
    PCHAR pszBeg = psz;
    // Move to end of name.
    while (*psz) {
        psz++;
    }
    // Move back through A-Za-z0-9 names.
    while (psz > pszBeg &&
           ((psz[-1] >= 'A' && psz[-1] <= 'Z') ||
            (psz[-1] >= 'a' && psz[-1] <= 'z') ||
            (psz[-1] >= '0' && psz[-1] <= '9'))) {
        psz--;
    }
    return psz;
}

VOID DetAttach(PVOID *ppbReal, PVOID pbMine, PCHAR psz)
{
    LONG l = DetourAttach(ppbReal, pbMine);
    if (l != 0) {
        Syelog(SYELOG_SEVERITY_NOTICE,
               "Attach failed: `%s': error %d\n", DetRealName(psz), l);
    }
}

VOID DetDetach(PVOID *ppbReal, PVOID pbMine, PCHAR psz)
{
    LONG l = DetourDetach(ppbReal, pbMine);
    if (l != 0) {
        Syelog(SYELOG_SEVERITY_NOTICE,
               "Detach failed: `%s': error %d\n", DetRealName(psz), l);
    }
}

#define ATTACH(x)       DetAttach(&(PVOID&)Real_##x,Mine_##x,#x)
#define DETACH(x)       DetDetach(&(PVOID&)Real_##x,Mine_##x,#x)

LONG AttachDetours(VOID)
{
    DetourTransactionBegin();
    DetourUpdateThread(GetCurrentThread());

    ATTACH(CreateProcessW);
    ATTACH(DecryptMessage);
    ATTACH(EncryptMessage);
    ATTACH(WSAAccept);
    ATTACH(WSAAddressToStringA);
    ATTACH(WSAAddressToStringW);
    ATTACH(WSAAsyncGetHostByAddr);
    ATTACH(WSAAsyncGetHostByName);
    ATTACH(WSAAsyncGetProtoByName);
    ATTACH(WSAAsyncGetProtoByNumber);
    ATTACH(WSAAsyncGetServByName);
    ATTACH(WSAAsyncGetServByPort);
    ATTACH(WSACancelAsyncRequest);
    ATTACH(WSACancelBlockingCall);
    ATTACH(WSACleanup);
    ATTACH(WSACloseEvent);
    ATTACH(WSAConnect);
    ATTACH(WSACreateEvent);
    ATTACH(WSADuplicateSocketA);
    ATTACH(WSADuplicateSocketW);
    ATTACH(WSAEnumNameSpaceProvidersA);
    ATTACH(WSAEnumNameSpaceProvidersW);
    ATTACH(WSAEnumNetworkEvents);
    ATTACH(WSAEnumProtocolsA);
    ATTACH(WSAEnumProtocolsW);
    ATTACH(WSAIsBlocking);
    ATTACH(WSAJoinLeaf);
    ATTACH(WSAProviderConfigChange);
    ATTACH(WSARecv);
    ATTACH(WSARecvDisconnect);
    ATTACH(WSARecvFrom);
    ATTACH(WSAResetEvent);
    ATTACH(WSASend);
    ATTACH(WSASendDisconnect);
    ATTACH(WSASendTo);
    ATTACH(WSAStringToAddressA);
    ATTACH(WSAStringToAddressW);
    ATTACH(WSAWaitForMultipleEvents);
    ATTACH(accept);
    ATTACH(closesocket);
    ATTACH(connect);
    ATTACH(listen);
    ATTACH(recv);
    ATTACH(recvfrom);
    ATTACH(send);
    ATTACH(sendto);
    ATTACH(shutdown);

    return DetourTransactionCommit();
}

LONG DetachDetours(VOID)
{
    DetourTransactionBegin();
    DetourUpdateThread(GetCurrentThread());

    DETACH(CreateProcessW);
    DETACH(DecryptMessage);
    DETACH(EncryptMessage);
    DETACH(WSAAccept);
    DETACH(WSAAddressToStringA);
    DETACH(WSAAddressToStringW);
    DETACH(WSAAsyncGetHostByAddr);
    DETACH(WSAAsyncGetHostByName);
    DETACH(WSAAsyncGetProtoByName);
    DETACH(WSAAsyncGetProtoByNumber);
    DETACH(WSAAsyncGetServByName);
    DETACH(WSAAsyncGetServByPort);
    DETACH(WSACancelAsyncRequest);
    DETACH(WSACancelBlockingCall);
    DETACH(WSACleanup);
    DETACH(WSACloseEvent);
    DETACH(WSAConnect);
    DETACH(WSACreateEvent);
    DETACH(WSADuplicateSocketA);
    DETACH(WSADuplicateSocketW);
    DETACH(WSAEnumNameSpaceProvidersA);
    DETACH(WSAEnumNameSpaceProvidersW);
    DETACH(WSAEnumNetworkEvents);
    DETACH(WSAEnumProtocolsA);
    DETACH(WSAEnumProtocolsW);
    DETACH(WSAIsBlocking);
    DETACH(WSAJoinLeaf);
    DETACH(WSAProviderConfigChange);
    DETACH(WSARecv);
    DETACH(WSARecvDisconnect);
    DETACH(WSARecvFrom);
    DETACH(WSAResetEvent);
    DETACH(WSASend);
    DETACH(WSASendDisconnect);
    DETACH(WSASendTo);
    DETACH(WSAStringToAddressA);
    DETACH(WSAStringToAddressW);
    DETACH(WSAWaitForMultipleEvents);
    DETACH(accept);
    DETACH(closesocket);
    DETACH(connect);
    DETACH(listen);
    DETACH(recv);
    DETACH(recvfrom);
    DETACH(send);
    DETACH(sendto);
    DETACH(shutdown);

    return DetourTransactionCommit();
}

//
//////////////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////// Logging System.
//
static BOOL s_bLog = 1;
static LONG s_nTlsIndent = -1;
static LONG s_nTlsThread = -1;
static LONG s_nThreadCnt = 0;

VOID _PrintEnter(const CHAR *psz, ...)
{
    DWORD dwErr = GetLastError();

    LONG nIndent = 0;
    LONG nThread = 0;
    if (s_nTlsIndent >= 0) {
        nIndent = (LONG)(LONG_PTR)TlsGetValue(s_nTlsIndent);
        TlsSetValue(s_nTlsIndent, (PVOID)(LONG_PTR)(nIndent + 1));
    }
    if (s_nTlsThread >= 0) {
        nThread = (LONG)(LONG_PTR)TlsGetValue(s_nTlsThread);
    }

    if (s_bLog && psz) {
        CHAR szBuf[1024];
        PCHAR pszBuf = szBuf;
        PCHAR pszEnd = szBuf + ARRAYSIZE(szBuf) - 1;
        LONG nLen = (nIndent > 0) ? (nIndent < 35 ? nIndent * 2 : 70) : 0;
        *pszBuf++ = (CHAR)('0' + ((nThread / 100) % 10));
        *pszBuf++ = (CHAR)('0' + ((nThread / 10) % 10));
        *pszBuf++ = (CHAR)('0' + ((nThread / 1) % 10));
        *pszBuf++ = ' ';
        while (nLen-- > 0) {
            *pszBuf++ = ' ';
        }

        va_list  args;
        va_start(args, psz);

        while ((*pszBuf++ = *psz++) != 0 && pszBuf < pszEnd) {
            // Copy characters.
        }
        *pszEnd = '\0';
        SyelogV(SYELOG_SEVERITY_INFORMATION,
                szBuf, args);

        va_end(args);
    }
    SetLastError(dwErr);
}

VOID _PrintExit(const CHAR *psz, ...)
{
    DWORD dwErr = GetLastError();

    LONG nIndent = 0;
    LONG nThread = 0;
    if (s_nTlsIndent >= 0) {
        nIndent = (LONG)(LONG_PTR)TlsGetValue(s_nTlsIndent) - 1;
        ASSERT(nIndent >= 0);
        TlsSetValue(s_nTlsIndent, (PVOID)(LONG_PTR)nIndent);
    }
    if (s_nTlsThread >= 0) {
        nThread = (LONG)(LONG_PTR)TlsGetValue(s_nTlsThread);
    }

    if (s_bLog && psz) {
        CHAR szBuf[1024];
        PCHAR pszBuf = szBuf;
        PCHAR pszEnd = szBuf + ARRAYSIZE(szBuf) - 1;
        LONG nLen = (nIndent > 0) ? (nIndent < 35 ? nIndent * 2 : 70) : 0;
        *pszBuf++ = (CHAR)('0' + ((nThread / 100) % 10));
        *pszBuf++ = (CHAR)('0' + ((nThread / 10) % 10));
        *pszBuf++ = (CHAR)('0' + ((nThread / 1) % 10));
        *pszBuf++ = ' ';
        while (nLen-- > 0) {
            *pszBuf++ = ' ';
        }

        va_list  args;
        va_start(args, psz);

        while ((*pszBuf++ = *psz++) != 0 && pszBuf < pszEnd) {
            // Copy characters.
        }
        *pszEnd = '\0';
        SyelogV(SYELOG_SEVERITY_INFORMATION,
                szBuf, args);

        va_end(args);
    }
    SetLastError(dwErr);
}

VOID _Print(const CHAR *psz, ...)
{
    DWORD dwErr = GetLastError();

    LONG nIndent = 0;
    LONG nThread = 0;
    if (s_nTlsIndent >= 0) {
        nIndent = (LONG)(LONG_PTR)TlsGetValue(s_nTlsIndent);
    }
    if (s_nTlsThread >= 0) {
        nThread = (LONG)(LONG_PTR)TlsGetValue(s_nTlsThread);
    }

    if (s_bLog && psz) {
        CHAR szBuf[1024];
        PCHAR pszBuf = szBuf;
        PCHAR pszEnd = szBuf + ARRAYSIZE(szBuf) - 1;
        LONG nLen = (nIndent > 0) ? (nIndent < 35 ? nIndent * 2 : 70) : 0;
        *pszBuf++ = (CHAR)('0' + ((nThread / 100) % 10));
        *pszBuf++ = (CHAR)('0' + ((nThread / 10) % 10));
        *pszBuf++ = (CHAR)('0' + ((nThread / 1) % 10));
        *pszBuf++ = ' ';
        while (nLen-- > 0) {
            *pszBuf++ = ' ';
        }

        va_list  args;
        va_start(args, psz);

        while ((*pszBuf++ = *psz++) != 0 && pszBuf < pszEnd) {
            // Copy characters.
        }
        *pszEnd = '\0';
        SyelogV(SYELOG_SEVERITY_INFORMATION,
                szBuf, args);

        va_end(args);
    }

    SetLastError(dwErr);
}

VOID AssertMessage(CONST PCHAR pszMsg, CONST PCHAR pszFile, ULONG nLine)
{
    Syelog(SYELOG_SEVERITY_FATAL,
           "ASSERT(%s) failed in %s, line %d.\n", pszMsg, pszFile, nLine);
}

//////////////////////////////////////////////////////////////////////////////
//
// DLL module information
//
BOOL ThreadAttach(HMODULE hDll)
{
    (void)hDll;

    if (s_nTlsIndent >= 0) {
        TlsSetValue(s_nTlsIndent, (PVOID)0);
    }
    if (s_nTlsThread >= 0) {
        LONG nThread = InterlockedIncrement(&s_nThreadCnt);
        TlsSetValue(s_nTlsThread, (PVOID)(LONG_PTR)nThread);
    }
    return TRUE;
}

BOOL ThreadDetach(HMODULE hDll)
{
    (void)hDll;

    if (s_nTlsIndent >= 0) {
        TlsSetValue(s_nTlsIndent, (PVOID)0);
    }
    if (s_nTlsThread >= 0) {
        TlsSetValue(s_nTlsThread, (PVOID)0);
    }
    return TRUE;
}

BOOL ProcessAttach(HMODULE hDll)
{
    s_bLog = FALSE;
    s_nTlsIndent = TlsAlloc();
    s_nTlsThread = TlsAlloc();

    WCHAR wzExeName[MAX_PATH];
    s_hInst = hDll;

    Real_GetModuleFileNameW(hDll, s_wzDllPath, ARRAYSIZE(s_wzDllPath));
    Real_GetModuleFileNameW(NULL, wzExeName, ARRAYSIZE(wzExeName));

    SyelogOpen("trcssl" DETOURS_STRINGIFY(DETOURS_BITS), SYELOG_FACILITY_APPLICATION);
    Syelog(SYELOG_SEVERITY_INFORMATION,
           "##################################################################\n");
    Syelog(SYELOG_SEVERITY_INFORMATION,
           "### %ls\n", wzExeName);
    LONG error = AttachDetours();
    if (error != NO_ERROR) {
        Syelog(SYELOG_SEVERITY_FATAL, "### Error attaching detours: %d\n", error);
    }

    ThreadAttach(hDll);

    s_bLog = TRUE;
    return TRUE;
}

BOOL ProcessDetach(HMODULE hDll)
{
    ThreadDetach(hDll);
    s_bLog = FALSE;

    LONG error = DetachDetours();
    if (error != NO_ERROR) {
        Syelog(SYELOG_SEVERITY_FATAL, "### Error detaching detours: %d\n", error);
    }

    Syelog(SYELOG_SEVERITY_NOTICE, "### Closing.\n");
    SyelogClose(FALSE);

    if (s_nTlsIndent >= 0) {
        TlsFree(s_nTlsIndent);
    }
    if (s_nTlsThread >= 0) {
        TlsFree(s_nTlsThread);
    }
    return TRUE;
}

BOOL APIENTRY DllMain(HINSTANCE hModule, DWORD dwReason, PVOID lpReserved)
{
    (void)hModule;
    (void)lpReserved;

    if (DetourIsHelperProcess()) {
        return TRUE;
    }

    switch (dwReason) {
      case DLL_PROCESS_ATTACH:
        DetourRestoreAfterWith();
        return ProcessAttach(hModule);
      case DLL_PROCESS_DETACH:
        return ProcessDetach(hModule);
      case DLL_THREAD_ATTACH:
        return ThreadAttach(hModule);
      case DLL_THREAD_DETACH:
        return ThreadDetach(hModule);
    }
    return TRUE;
}
//
///////////////////////////////////////////////////////////////// End of File.

```

`samples/tracessl/trcssl.rc`:

```rc
//////////////////////////////////////////////////////////////////////////////
//
//  Version information for trcssl.rc.
//
//  Microsoft Research Detours Package
//
//  Copyright (c) Microsoft Corporation.  All rights reserved.
//

#include "detver.h"

#define VER_INTERNALNAME_STR        "trcssl" DETOURS_STRINGIFY(DETOURS_BITS)
#define VER_ORIGINALFILENAME_STR    "trcsll" DETOURS_STRINGIFY(DETOURS_BITS) ".dll"
#define VER_FILEDESCRIPTION_STR     "Detours SSL Trace Module"
#define VER_COMPANYNAME_STR         "Microsoft Corporation"

#include "common.ver"

```

`samples/tracetcp/Makefile`:

```
##############################################################################
##
##  Utility to trace WinSock TCP APIs.
##
##  Microsoft Research Detours Package
##
##  Copyright (c) Microsoft Corporation.  All rights reserved.
##

!include ..\common.mak

LIBS=$(LIBS) kernel32.lib ws2_32.lib

##############################################################################

all: dirs \
    $(BIND)\trctcp$(DETOURS_BITS).dll \
!IF $(DETOURS_SOURCE_BROWSING)==1
    $(OBJD)\trctcp$(DETOURS_BITS).bsc \
!ENDIF
    option

##############################################################################

dirs:
    @if not exist $(BIND) mkdir $(BIND) && echo.   Created $(BIND)
    @if not exist $(OBJD) mkdir $(OBJD) && echo.   Created $(OBJD)

$(OBJD)\trctcp.obj: trctcp.cpp

$(OBJD)\trctcp.res: trctcp.rc

$(BIND)\trctcp$(DETOURS_BITS).dll: $(OBJD)\trctcp.obj $(OBJD)\trctcp.res $(DEPS)
    cl /LD $(CFLAGS) /Fe$@ /Fd$(@R).pdb \
        $(OBJD)\trctcp.obj $(OBJD)\trctcp.res \
        /link $(LINKFLAGS) /subsystem:console \
        /export:DetourFinishHelperProcess,@1,NONAME \
        $(LIBS)

$(OBJD)\trctcp$(DETOURS_BITS).bsc : $(OBJD)\trctcp.obj
    bscmake /v /n /o $@ $(OBJD)\trctcp.sbr

##############################################################################

clean:
    -del *~ test.txt 2>nul
    -del $(BIND)\trctcp*.* 2>nul
    -rmdir /q /s $(OBJD) 2>nul

realclean: clean
    -rmdir /q /s $(OBJDS) 2>nul

############################################### Install non-bit-size binaries.

!IF "$(DETOURS_OPTION_PROCESSOR)" != ""

$(OPTD)\trctcp$(DETOURS_OPTION_BITS).dll:
$(OPTD)\trctcp$(DETOURS_OPTION_BITS).pdb:

$(BIND)\trctcp$(DETOURS_OPTION_BITS).dll : $(OPTD)\trctcp$(DETOURS_OPTION_BITS).dll
    @if exist $? copy /y $? $(BIND) >nul && echo $@ copied from $(DETOURS_OPTION_PROCESSOR).
$(BIND)\trctcp$(DETOURS_OPTION_BITS).pdb : $(OPTD)\trctcp$(DETOURS_OPTION_BITS).pdb
    @if exist $? copy /y $? $(BIND) >nul && echo $@ copied from $(DETOURS_OPTION_PROCESSOR).

option: \
    $(BIND)\trctcp$(DETOURS_OPTION_BITS).dll \
    $(BIND)\trctcp$(DETOURS_OPTION_BITS).pdb \

!ELSE

option:

!ENDIF

##############################################################################

test: all
    @echo -------- Logging output to test.txt ------------
    start $(BIND)\syelogd.exe /o test.txt
    $(BIND)\sleep5.exe 1
    @echo -------- Should load trctcp$(DETOURS_BITS).dll dynamically using withdll.exe ------------
    @echo.
    @echo ** NOTE NOTE NOTE NOTE NOTE NOTE NOTE NOTE NOTE NOTE NOTE **
    @echo **
    @echo ** Close the Internet Explorer window to continue test.
    @echo **
    @echo ** NOTE NOTE NOTE NOTE NOTE NOTE NOTE NOTE NOTE NOTE NOTE **
    @echo.
    $(BIND)\withdll -d:$(BIND)\trctcp$(DETOURS_BITS).dll \
        "c:\program files\Internet Explorer\iexplore.exe" "http://www.microsoft.com"
    @echo -------- Log from syelog -------------
    type test.txt

debug: all
    windbg -g -G -o $(BIND)\withdll -d:$(BIND)\trctcp$(DETOURS_BITS).dll \
        "c:\program files\Internet Explorer\iexplore.exe" "http://www.microsoft.com"

################################################################# End of File.

```

`samples/tracetcp/trctcp.cpp`:

```cpp
//////////////////////////////////////////////////////////////////////////////
//
//  Detours Test Program (trctcp.cpp of trctcp.dll)
//
//  Microsoft Research Detours Package
//
//  Copyright (c) Microsoft Corporation.  All rights reserved.
//
#define _WIN32_WINNT        0x0400
#define WIN32
#define NT
#define _WINSOCK_DEPRECATED_NO_WARNINGS

#define DBG_TRACE   0

#if _MSC_VER >= 1300
#include <winsock2.h>
#endif
#include <windows.h>
#include <stdio.h>
#include "detours.h"
#include "syelog.h"

#define PULONG_PTR          PVOID
#define PLONG_PTR           PVOID
#define ULONG_PTR           PVOID
#define ENUMRESNAMEPROCA    PVOID
#define ENUMRESNAMEPROCW    PVOID
#define ENUMRESLANGPROCA    PVOID
#define ENUMRESLANGPROCW    PVOID
#define ENUMRESTYPEPROCA    PVOID
#define ENUMRESTYPEPROCW    PVOID
#define STGOPTIONS          PVOID

//////////////////////////////////////////////////////////////////////////////
#pragma warning(disable:4127)   // Many of our asserts are constants.

#define ASSERT_ALWAYS(x)   \
    do {                                                        \
    if (!(x)) {                                                 \
            AssertMessage(#x, __FILE__, __LINE__);              \
            DebugBreak();                                       \
    }                                                           \
    } while (0)

#ifndef NDEBUG
#define ASSERT(x)           ASSERT_ALWAYS(x)
#else
#define ASSERT(x)
#endif

#define UNUSED(c)       (c) = (c)

//////////////////////////////////////////////////////////////////////////////
static HMODULE s_hInst = NULL;
static WCHAR s_wzDllPath[MAX_PATH];

VOID _PrintDump(SOCKET socket, PCHAR pszData, INT cbData);
VOID _PrintEnter(PCSTR psz, ...);
VOID _PrintExit(PCSTR psz, ...);
VOID _Print(PCSTR psz, ...);

VOID AssertMessage(CONST PCHAR pszMsg, CONST PCHAR pszFile, ULONG nLine);

//////////////////////////////////////////////////////////////////////////////
//
extern "C" {
    HANDLE (WINAPI * Real_CreateFileW)(LPCWSTR a0,
                                       DWORD a1,
                                       DWORD a2,
                                       LPSECURITY_ATTRIBUTES a3,
                                       DWORD a4,
                                       DWORD a5,
                                       HANDLE a6)
        = CreateFileW;

    BOOL (WINAPI * Real_WriteFile)(HANDLE hFile,
                                   LPCVOID lpBuffer,
                                   DWORD nNumberOfBytesToWrite,
                                   LPDWORD lpNumberOfBytesWritten,
                                   LPOVERLAPPED lpOverlapped)
        = WriteFile;

    BOOL (WINAPI * Real_FlushFileBuffers)(HANDLE hFile)
        = FlushFileBuffers;

    BOOL (WINAPI * Real_CloseHandle)(HANDLE hObject)
        = CloseHandle;

    BOOL (WINAPI * Real_WaitNamedPipeW)(LPCWSTR lpNamedPipeName, DWORD nTimeOut)
        = WaitNamedPipeW;

    BOOL (WINAPI * Real_SetNamedPipeHandleState)(HANDLE hNamedPipe,
                                                 LPDWORD lpMode,
                                                 LPDWORD lpMaxCollectionCount,
                                                 LPDWORD lpCollectDataTimeout)
        = SetNamedPipeHandleState;

    DWORD (WINAPI * Real_GetCurrentProcessId)(VOID)
        = GetCurrentProcessId;

    VOID (WINAPI * Real_GetSystemTimeAsFileTime)(LPFILETIME lpSystemTimeAsFileTime)
        = GetSystemTimeAsFileTime;

    VOID (WINAPI * Real_InitializeCriticalSection)(LPCRITICAL_SECTION lpSection)
        = InitializeCriticalSection;

    VOID (WINAPI * Real_EnterCriticalSection)(LPCRITICAL_SECTION lpSection)
        = EnterCriticalSection;

    VOID (WINAPI * Real_LeaveCriticalSection)(LPCRITICAL_SECTION lpSection)
        = LeaveCriticalSection;
}

DWORD (WINAPI * Real_GetModuleFileNameW)(HMODULE a0,
                                         LPWSTR a1,
                                         DWORD a2)
    = GetModuleFileNameW;

BOOL (WINAPI * Real_CreateProcessW)(LPCWSTR a0,
                                    LPWSTR a1,
                                    LPSECURITY_ATTRIBUTES a2,
                                    LPSECURITY_ATTRIBUTES a3,
                                    BOOL a4,
                                    DWORD a5,
                                    LPVOID a6,
                                    LPCWSTR a7,
                                    LPSTARTUPINFOW a8,
                                    LPPROCESS_INFORMATION a9)
    = CreateProcessW;

#if _MSC_VER < 1300
SOCKET (WINAPI * Real_WSAAccept)(SOCKET a0,
                                 sockaddr* a1,
                                 LPINT a2,
                                 LPCONDITIONPROC a3,
                                 DWORD a4)
    = WSAAccept;
#else
SOCKET (WINAPI * Real_WSAAccept)(SOCKET a0,
                                 sockaddr* a1,
                                 LPINT a2,
                                 LPCONDITIONPROC a3,
                                 DWORD_PTR a4)
    = WSAAccept;
#endif

INT (WINAPI * Real_WSAAddressToStringA)(LPSOCKADDR a0,
                                        DWORD a1,
                                        LPWSAPROTOCOL_INFOA a2,
                                        LPSTR a3,
                                        LPDWORD a4)
    = WSAAddressToStringA;

INT (WINAPI * Real_WSAAddressToStringW)(LPSOCKADDR a0,
                                        DWORD a1,
                                        LPWSAPROTOCOL_INFOW a2,
                                        LPWSTR a3,
                                        LPDWORD a4)
    = WSAAddressToStringW;

HANDLE (WINAPI * Real_WSAAsyncGetHostByAddr)(HWND a0,
                                             u_int a1,
                                             CONST char* a2,
                                             int a3,
                                             int a4,
                                             char* a5,
                                             int a6)
    = WSAAsyncGetHostByAddr;

HANDLE (WINAPI * Real_WSAAsyncGetHostByName)(HWND a0,
                                             u_int a1,
                                             CONST char* a2,
                                             char* a3,
                                             int a4)
    = WSAAsyncGetHostByName;

HANDLE (WINAPI * Real_WSAAsyncGetProtoByName)(HWND a0,
                                              u_int a1,
                                              CONST char* a2,
                                              char* a3,
                                              int a4)
    = WSAAsyncGetProtoByName;

HANDLE (WINAPI * Real_WSAAsyncGetProtoByNumber)(HWND a0,
                                                u_int a1,
                                                int a2,
                                                char* a3,
                                                int a4)
    = WSAAsyncGetProtoByNumber;

HANDLE (WINAPI * Real_WSAAsyncGetServByName)(HWND a0,
                                             u_int a1,
                                             CONST char* a2,
                                             CONST char* a3,
                                             char* a4,
                                             int a5)
    = WSAAsyncGetServByName;

HANDLE (WINAPI * Real_WSAAsyncGetServByPort)(HWND a0,
                                             u_int a1,
                                             int a2,
                                             CONST char* a3,
                                             char* a4,
                                             int a5)
    = WSAAsyncGetServByPort;

int (WINAPI * Real_WSACancelAsyncRequest)(HANDLE a0)
    = WSACancelAsyncRequest;

int (WINAPI * Real_WSACancelBlockingCall)(void)
    = WSACancelBlockingCall;

int (WINAPI * Real_WSACleanup)(void)
    = WSACleanup;

BOOL (WINAPI * Real_WSACloseEvent)(HANDLE a0)
    = WSACloseEvent;

int (WINAPI * Real_WSAConnect)(SOCKET a0,
                               CONST sockaddr* a1,
                               int a2,
                               LPWSABUF a3,
                               LPWSABUF a4,
                               LPQOS a5,
                               LPQOS a6)
    = WSAConnect;

HANDLE (WINAPI * Real_WSACreateEvent)(void)
    = WSACreateEvent;

int (WINAPI * Real_WSADuplicateSocketA)(SOCKET a0,
                                        DWORD a1,
                                        LPWSAPROTOCOL_INFOA a2)
    = WSADuplicateSocketA;

int (WINAPI * Real_WSADuplicateSocketW)(SOCKET a0,
                                        DWORD a1,
                                        LPWSAPROTOCOL_INFOW a2)
    = WSADuplicateSocketW;

INT (WINAPI * Real_WSAEnumNameSpaceProvidersA)(LPDWORD a0,
                                               LPWSANAMESPACE_INFOA a1)
    = WSAEnumNameSpaceProvidersA;

INT (WINAPI * Real_WSAEnumNameSpaceProvidersW)(LPDWORD a0,
                                               LPWSANAMESPACE_INFOW a1)
    = WSAEnumNameSpaceProvidersW;

int (WINAPI * Real_WSAEnumNetworkEvents)(SOCKET a0,
                                         HANDLE a1,
                                         LPWSANETWORKEVENTS a2)
    = WSAEnumNetworkEvents;

int (WINAPI * Real_WSAEnumProtocolsA)(LPINT a0,
                                      LPWSAPROTOCOL_INFOA a1,
                                      LPDWORD a2)
    = WSAEnumProtocolsA;

int (WINAPI * Real_WSAEnumProtocolsW)(LPINT a0,
                                      LPWSAPROTOCOL_INFOW a1,
                                      LPDWORD a2)
    = WSAEnumProtocolsW;

BOOL (WINAPI * Real_WSAGetOverlappedResult)(SOCKET a0,
                                            LPWSAOVERLAPPED a1,
                                            LPDWORD a2,
                                            BOOL a3,
                                            LPDWORD a4)
    = WSAGetOverlappedResult;

BOOL (WINAPI * Real_WSAIsBlocking)(void)
    = WSAIsBlocking;

SOCKET (WINAPI * Real_WSAJoinLeaf)(SOCKET a0,
                                   CONST sockaddr* a1,
                                   int a2,
                                   LPWSABUF a3,
                                   LPWSABUF a4,
                                   LPQOS a5,
                                   LPQOS a6,
                                   DWORD a7)
    = WSAJoinLeaf;

INT (WINAPI * Real_WSALookupServiceBeginA)(
                                           LPWSAQUERYSETA lpqsRestrictions,
                                           DWORD          dwControlFlags,
                                           LPHANDLE       lphLookup
                                          )
    = WSALookupServiceBeginA;

INT (WINAPI * Real_WSALookupServiceBeginW)(
                                           LPWSAQUERYSETW lpqsRestrictions,
                                           DWORD          dwControlFlags,
                                           LPHANDLE       lphLookup
                                          )
    = WSALookupServiceBeginW;

INT (WINAPI * Real_WSALookupServiceNextA)(
                                          HANDLE           hLookup,
                                          DWORD            dwControlFlags,
                                          LPDWORD       lpdwBufferLength,
                                          LPWSAQUERYSETA lpqsResults
                                         ) = WSALookupServiceNextA;

INT (WINAPI * Real_WSALookupServiceNextW)(
                                          HANDLE         hLookup,
                                          DWORD          dwControlFlags,
                                          LPDWORD        lpdwBufferLength,
                                          LPWSAQUERYSETW lpqsResults
                                         ) = WSALookupServiceNextW;

INT (WINAPI * Real_WSALookupServiceEnd)(
                                        HANDLE  hLookup
                                       ) = WSALookupServiceEnd;

INT (WINAPI * Real_WSAProviderConfigChange)(LPHANDLE a0,
                                            LPWSAOVERLAPPED a1,
                                            LPWSAOVERLAPPED_COMPLETION_ROUTINE a2)
    = WSAProviderConfigChange;

int (WINAPI * Real_WSARecv)(SOCKET a0,
                            LPWSABUF a1,
                            DWORD a2,
                            LPDWORD a3,
                            LPDWORD a4,
                            LPWSAOVERLAPPED a5,
                            LPWSAOVERLAPPED_COMPLETION_ROUTINE a6)
    = WSARecv;

int (WINAPI * Real_WSARecvDisconnect)(SOCKET a0,
                                      LPWSABUF a1)
    = WSARecvDisconnect;

int (WINAPI * Real_WSARecvFrom)(SOCKET a0,
                                LPWSABUF a1,
                                DWORD a2,
                                LPDWORD a3,
                                LPDWORD a4,
                                sockaddr* a5,
                                LPINT a6,
                                LPWSAOVERLAPPED a7,
                                LPWSAOVERLAPPED_COMPLETION_ROUTINE a8)
    = WSARecvFrom;

BOOL (WINAPI * Real_WSAResetEvent)(HANDLE a0)
    = WSAResetEvent;

int (WINAPI * Real_WSASend)(SOCKET a0,
                            LPWSABUF a1,
                            DWORD a2,
                            LPDWORD a3,
                            DWORD a4,
                            LPWSAOVERLAPPED a5,
                            LPWSAOVERLAPPED_COMPLETION_ROUTINE a6)
    = WSASend;

int (WINAPI * Real_WSASendDisconnect)(SOCKET a0,
                                      LPWSABUF a1)
    = WSASendDisconnect;

int (WINAPI * Real_WSASendTo)(SOCKET a0,
                              LPWSABUF a1,
                              DWORD a2,
                              LPDWORD a3,
                              DWORD a4,
                              CONST sockaddr* a5,
                              int a6,
                              LPWSAOVERLAPPED a7,
                              LPWSAOVERLAPPED_COMPLETION_ROUTINE a8)
    = WSASendTo;

INT (WINAPI * Real_WSAStringToAddressA)(LPSTR a0,
                                        INT a1,
                                        LPWSAPROTOCOL_INFOA a2,
                                        LPSOCKADDR a3,
                                        LPINT a4)
    = WSAStringToAddressA;

INT (WINAPI * Real_WSAStringToAddressW)(LPWSTR a0,
                                        INT a1,
                                        LPWSAPROTOCOL_INFOW a2,
                                        LPSOCKADDR a3,
                                        LPINT a4)
    = WSAStringToAddressW;

DWORD (WINAPI * Real_WSAWaitForMultipleEvents)(DWORD a0,
                                               CONST HANDLE * a1,
                                               BOOL a2,
                                               DWORD a3,
                                               BOOL a4)
    = WSAWaitForMultipleEvents;

SOCKET (WINAPI * Real_accept)(SOCKET a0,
                              sockaddr* a1,
                              int* a2)
    = accept;

int (WINAPI * Real_closesocket)(SOCKET a0)
    = closesocket;

int (WINAPI * Real_connect)(SOCKET a0,
                            CONST sockaddr* a1,
                            int a2)
    = connect;

int (WINAPI * Real_listen)(SOCKET a0,
                           int a1)
    = listen;

int (WINAPI * Real_recv)(SOCKET a0,
                         char* a1,
                         int a2,
                         int a3)
    = recv;

int (WINAPI * Real_recvfrom)(SOCKET a0,
                             char* a1,
                             int a2,
                             int a3,
                             sockaddr* a4,
                             int* a5)
    = recvfrom;

int (WINAPI * Real_send)(SOCKET a0,
                         CONST char* a1,
                         int a2,
                         int a3)
    = send;

int (WINAPI * Real_sendto)(SOCKET a0,
                           CONST char* a1,
                           int a2,
                           int a3,
                           CONST sockaddr* a4,
                           int a5)
    = sendto;

int (WINAPI * Real_shutdown)(SOCKET a0,
                             int a1)
    = shutdown;

/////////////////////////////////////////////////////////////
// Detours
//
BOOL WINAPI Mine_CreateProcessW(LPCWSTR lpApplicationName,
                                LPWSTR lpCommandLine,
                                LPSECURITY_ATTRIBUTES lpProcessAttributes,
                                LPSECURITY_ATTRIBUTES lpThreadAttributes,
                                BOOL bInheritHandles,
                                DWORD dwCreationFlags,
                                LPVOID lpEnvironment,
                                LPCWSTR lpCurrentDirectory,
                                LPSTARTUPINFOW lpStartupInfo,
                                LPPROCESS_INFORMATION lpProcessInformation)
{
    _PrintEnter("CreateProcessW(%ls,%ls,%p,%p,%x,%x,%p,%ls,%p,%p)\n",
                lpApplicationName,
                lpCommandLine,
                lpProcessAttributes,
                lpThreadAttributes,
                bInheritHandles,
                dwCreationFlags,
                lpEnvironment,
                lpCurrentDirectory,
                lpStartupInfo,
                lpProcessInformation);

    BOOL rv = 0;
    __try {
        rv = Real_CreateProcessW(lpApplicationName,
                                 lpCommandLine,
                                 lpProcessAttributes,
                                 lpThreadAttributes,
                                 bInheritHandles,
                                 dwCreationFlags,
                                 lpEnvironment,
                                 lpCurrentDirectory,
                                 lpStartupInfo,
                                 lpProcessInformation);
    } __finally {
        _PrintExit("CreateProcessW(,,,,,,,,,) -> %x\n", rv);
    };
    return rv;
}

#if _MSC_VER < 1300
SOCKET WINAPI Mine_WSAAccept(SOCKET a0,
                             sockaddr* a1,
                             LPINT a2,
                             LPCONDITIONPROC a3,
                             DWORD a4)
#else
SOCKET WINAPI Mine_WSAAccept(SOCKET a0,
                             sockaddr* a1,
                             LPINT a2,
                             LPCONDITIONPROC a3,
                             DWORD_PTR a4)
#endif
{

    SOCKET rv = 0;
    __try {
        rv = Real_WSAAccept(a0, a1, a2, a3, a4);
    } __finally {
        _PrintEnter("%p: WSAAccept(,%p,%p,%p,%p) -> %p\n", a0, a1, a2, a3, a4, rv);
        _PrintExit(NULL);
    };
    return rv;
}

INT WINAPI Mine_WSAAddressToStringA(LPSOCKADDR a0,
                                    DWORD a1,
                                    LPWSAPROTOCOL_INFOA a2,
                                    LPSTR a3,
                                    LPDWORD a4)
{
    _PrintEnter("WSAAddressToStringA(%p,%x,%p,%p,%p)\n", a0, a1, a2, a3, a4);

    INT rv = 0;
    __try {
        __try {
            sockaddr_in *in = (sockaddr_in *)a0;
            _Print("in=%d.%d.%d.%d\n",
                   in->sin_addr.S_un.S_un_b.s_b1,
                   in->sin_addr.S_un.S_un_b.s_b2,
                   in->sin_addr.S_un.S_un_b.s_b3,
                   in->sin_addr.S_un.S_un_b.s_b4);
        }
        __finally {
        }

        rv = Real_WSAAddressToStringA(a0, a1, a2, a3, a4);
    } __finally {
        _PrintExit("WSAAddressToStringA(,,,,) -> %x\n", rv);
    };
    return rv;
}

INT WINAPI Mine_WSAAddressToStringW(LPSOCKADDR a0,
                                    DWORD a1,
                                    LPWSAPROTOCOL_INFOW a2,
                                    LPWSTR a3,
                                    LPDWORD a4)
{
    _PrintEnter("WSAAddressToStringW(%p,%x,%p,%p,%p)\n", a0, a1, a2, a3, a4);

    INT rv = 0;
    __try {
        __try {
            sockaddr_in *in = (sockaddr_in *)a0;
            _Print("in=%d.%d.%d.%d\n",
                   in->sin_addr.S_un.S_un_b.s_b1,
                   in->sin_addr.S_un.S_un_b.s_b2,
                   in->sin_addr.S_un.S_un_b.s_b3,
                   in->sin_addr.S_un.S_un_b.s_b4);
        }
        __finally {
        }
        rv = Real_WSAAddressToStringW(a0, a1, a2, a3, a4);
    } __finally {
        _PrintExit("WSAAddressToStringW(,,,,) -> %x\n", rv);
    };
    return rv;
}

HANDLE WINAPI Mine_WSAAsyncGetHostByAddr(HWND a0,
                                         u_int a1,
                                         char* a2,
                                         int a3,
                                         int a4,
                                         char* a5,
                                         int a6)
{
    _PrintEnter("WSAAsyncGetHostByAddr(%p,%x,%p,%x,%x,%p,%x)\n", a0, a1, a2, a3, a4, a5, a6);

    HANDLE rv = 0;
    __try {
        rv = Real_WSAAsyncGetHostByAddr(a0, a1, a2, a3, a4, a5, a6);
    } __finally {
        _PrintExit("WSAAsyncGetHostByAddr(,,,,,,) -> %p\n", rv);
    };
    return rv;
}

HANDLE WINAPI Mine_WSAAsyncGetHostByName(HWND a0,
                                         u_int a1,
                                         char* a2,
                                         char* a3,
                                         int a4)
{
    _PrintEnter("WSAAsyncGetHostByName(%p,%x,%p,%p,%x)\n", a0, a1, a2, a3, a4);

    HANDLE rv = 0;
    __try {
        rv = Real_WSAAsyncGetHostByName(a0, a1, a2, a3, a4);
    } __finally {
        _PrintExit("WSAAsyncGetHostByName(,,,,) -> %p\n", rv);
    };
    return rv;
}

HANDLE WINAPI Mine_WSAAsyncGetProtoByName(HWND a0,
                                          u_int a1,
                                          char* a2,
                                          char* a3,
                                          int a4)
{
    _PrintEnter("WSAAsyncGetProtoByName(%p,%x,%p,%p,%x)\n", a0, a1, a2, a3, a4);

    HANDLE rv = 0;
    __try {
        rv = Real_WSAAsyncGetProtoByName(a0, a1, a2, a3, a4);
    } __finally {
        _PrintExit("WSAAsyncGetProtoByName(,,,,) -> %p\n", rv);
    };
    return rv;
}

HANDLE WINAPI Mine_WSAAsyncGetProtoByNumber(HWND a0,
                                            u_int a1,
                                            int a2,
                                            char* a3,
                                            int a4)
{
    _PrintEnter("WSAAsyncGetProtoByNumber(%p,%x,%p,%p,%x)\n", a0, a1, a2, a3, a4);

    HANDLE rv = 0;
    __try {
        rv = Real_WSAAsyncGetProtoByNumber(a0, a1, a2, a3, a4);
    } __finally {
        _PrintExit("WSAAsyncGetProtoByNumber(,,,,) -> %p\n", rv);
    };
    return rv;
}

HANDLE WINAPI Mine_WSAAsyncGetServByName(HWND a0,
                                         u_int a1,
                                         char* a2,
                                         char* a3,
                                         char* a4,
                                         int a5)
{
    _PrintEnter("WSAAsyncGetServByName(%p,%x,%p,%p,%p,%x)\n", a0, a1, a2, a3, a4, a5);

    HANDLE rv = 0;
    __try {
        rv = Real_WSAAsyncGetServByName(a0, a1, a2, a3, a4, a5);
    } __finally {
        _PrintExit("WSAAsyncGetServByName(,,,,,) -> %p\n", rv);
    };
    return rv;
}

HANDLE WINAPI Mine_WSAAsyncGetServByPort(HWND a0,
                                         u_int a1,
                                         int a2,
                                         char* a3,
                                         char* a4,
                                         int a5)
{
    _PrintEnter("WSAAsyncGetServByPort(%p,%x,%x,%p,%p,%x)\n", a0, a1, a2, a3, a4, a5);

    HANDLE rv = 0;
    __try {
        rv = Real_WSAAsyncGetServByPort(a0, a1, a2, a3, a4, a5);
    } __finally {
        _PrintExit("WSAAsyncGetServByPort(,,,,,) -> %p\n", rv);
    };
    return rv;
}

int WINAPI Mine_WSACancelAsyncRequest(HANDLE a0)
{
    _PrintEnter("WSACancelAsyncRequest(%p)\n", a0);

    int rv = 0;
    __try {
        rv = Real_WSACancelAsyncRequest(a0);
    } __finally {
        _PrintExit("WSACancelAsyncRequest() -> %x\n", rv);
    };
    return rv;
}

int WINAPI Mine_WSACancelBlockingCall(void)
{
    _PrintEnter("WSACancelBlockingCall()\n");

    int rv = 0;
    __try {
        rv = Real_WSACancelBlockingCall();
    } __finally {
        _PrintExit("WSACancelBlockingCall() -> %x\n", rv);
    };
    return rv;
}

int WINAPI Mine_WSACleanup(void)
{
    _PrintEnter("WSACleanup()\n");

    int rv = 0;
    __try {
        rv = Real_WSACleanup();
    } __finally {
        _PrintExit("WSACleanup() -> %x\n", rv);
    };
    return rv;
}

BOOL WINAPI Mine_WSACloseEvent(HANDLE a0)
{
    _PrintEnter("WSACloseEvent(%p)\n", a0);

    BOOL rv = 0;
    __try {
        rv = Real_WSACloseEvent(a0);
    } __finally {
        _PrintExit("WSACloseEvent() -> %x\n", rv);
    };
    return rv;
}

int WINAPI Mine_WSAConnect(SOCKET a0,
                           sockaddr* a1,
                           int a2,
                           LPWSABUF a3,
                           LPWSABUF a4,
                           LPQOS a5,
                           LPQOS a6)
{
    int rv = 0;
    __try {
        rv = Real_WSAConnect(a0, a1, a2, a3, a4, a5, a6);
    } __finally {
        _PrintEnter("%p: WSAConnect(,%p,%x,%p,%p,%p,%p) -> %x\n",
                    a0, a1, a2, a3, a4, a5, a6, rv);
        _PrintExit(NULL);
    };
    return rv;
}

HANDLE WINAPI Mine_WSACreateEvent(void)
{
    _PrintEnter("WSACreateEvent()\n");

    HANDLE rv = 0;
    __try {
        rv = Real_WSACreateEvent();
    } __finally {
        _PrintExit("WSACreateEvent() -> %p\n", rv);
    };
    return rv;
}

int WINAPI Mine_WSADuplicateSocketA(SOCKET a0,
                                    DWORD a1,
                                    LPWSAPROTOCOL_INFOA a2)
{
    _PrintEnter("%p: WSADuplicateSocketA(,%x,%p)\n", a0, a1, a2);

    int rv = 0;
    __try {
        rv = Real_WSADuplicateSocketA(a0, a1, a2);
    } __finally {
        _PrintExit("%p: WSADuplicateSocketA(,,) -> %x\n", a0, rv);
    };
    return rv;
}

int WINAPI Mine_WSADuplicateSocketW(SOCKET a0,
                                    DWORD a1,
                                    LPWSAPROTOCOL_INFOW a2)
{
    _PrintEnter("%p: WSADuplicateSocketW(,%x,%p)\n", a0, a1, a2);

    int rv = 0;
    __try {
        rv = Real_WSADuplicateSocketW(a0, a1, a2);
    } __finally {
        _PrintExit("%p: WSADuplicateSocketW(,,) -> %x\n", a0, rv);
    };
    return rv;
}

INT WINAPI Mine_WSAEnumNameSpaceProvidersA(LPDWORD a0,
                                           LPWSANAMESPACE_INFOA a1)
{
    _PrintEnter("WSAEnumNameSpaceProvidersA(%p,%p)\n", a0, a1);

    INT rv = 0;
    __try {
        rv = Real_WSAEnumNameSpaceProvidersA(a0, a1);
    } __finally {
        _PrintExit("WSAEnumNameSpaceProvidersA(,) -> %x\n", rv);
    };
    return rv;
}

INT WINAPI Mine_WSAEnumNameSpaceProvidersW(LPDWORD a0,
                                           LPWSANAMESPACE_INFOW a1)
{
    _PrintEnter("WSAEnumNameSpaceProvidersW(%p,%p)\n", a0, a1);

    INT rv = 0;
    __try {
        rv = Real_WSAEnumNameSpaceProvidersW(a0, a1);
    } __finally {
        _PrintExit("WSAEnumNameSpaceProvidersW(,) -> %x\n", rv);
    };
    return rv;
}

int WINAPI Mine_WSAEnumNetworkEvents(SOCKET a0,
                                     HANDLE a1,
                                     LPWSANETWORKEVENTS a2)
{
    _PrintEnter("%p: WSAEnumNetworkEvents(,%p,%p)\n", a0, a1, a2);

    int rv = 0;
    __try {
        rv = Real_WSAEnumNetworkEvents(a0, a1, a2);
    } __finally {
        _PrintExit("%p: WSAEnumNetworkEvents(,,) -> %x\n", a0, rv);
    };
    return rv;
}

int WINAPI Mine_WSAEnumProtocolsA(LPINT a0,
                                  LPWSAPROTOCOL_INFOA a1,
                                  LPDWORD a2)
{
    _PrintEnter("WSAEnumProtocolsA(%p,%p,%p)\n", a0, a1, a2);

    int rv = 0;
    __try {
        rv = Real_WSAEnumProtocolsA(a0, a1, a2);
    } __finally {
        _PrintExit("WSAEnumProtocolsA(,,) -> %x\n", rv);
    };
    return rv;
}

int WINAPI Mine_WSAEnumProtocolsW(LPINT a0,
                                  LPWSAPROTOCOL_INFOW a1,
                                  LPDWORD a2)
{
    _PrintEnter("WSAEnumProtocolsW(%p,%p,%p)\n", a0, a1, a2);

    int rv = 0;
    __try {
        rv = Real_WSAEnumProtocolsW(a0, a1, a2);
    } __finally {
        _PrintExit("WSAEnumProtocolsW(,,) -> %x\n", rv);
    };
    return rv;
}

BOOL WINAPI Mine_WSAGetOverlappedResult(SOCKET a0,
                                        LPWSAOVERLAPPED a1,
                                        LPDWORD a2,
                                        BOOL a3,
                                        LPDWORD a4)
{
    _PrintEnter("%p: WSAGetOverlappedResult(,%p,%p,%x,%p)\n", a0, a1, a2, a3, a4);

    BOOL rv = 0;
    __try {
        rv = Real_WSAGetOverlappedResult(a0, a1, a2, a3, a4);
    } __finally {
        _PrintExit("%p: WSAGetOverlappedResult(,,,,) -> %x\n", a0, rv);
    };
    return rv;
}

BOOL WINAPI Mine_WSAIsBlocking(void)
{
    _PrintEnter("WSAIsBlocking()\n");

    BOOL rv = 0;
    __try {
        rv = Real_WSAIsBlocking();
    } __finally {
        _PrintExit("WSAIsBlocking() -> %x\n", rv);
    };
    return rv;
}

SOCKET WINAPI Mine_WSAJoinLeaf(SOCKET a0,
                               sockaddr* a1,
                               int a2,
                               LPWSABUF a3,
                               LPWSABUF a4,
                               LPQOS a5,
                               LPQOS a6,
                               DWORD a7)
{
    _PrintEnter("%p: WSAJoinLeaf(,%p,%x,%p,%p,%p,%p,%x)\n", a0, a1, a2, a3, a4, a5, a6, a7);

    SOCKET rv = 0;
    __try {
        rv = Real_WSAJoinLeaf(a0, a1, a2, a3, a4, a5, a6, a7);
    } __finally {
        _PrintExit("%p: WSAJoinLeaf(,,,,,,,) -> %p\n", a0, rv);
    };
    return rv;
}

INT WINAPI Mine_WSALookupServiceBeginA(
                                       LPWSAQUERYSETA lpqsRestrictions,
                                       DWORD          dwControlFlags,
                                       LPHANDLE       lphLookup
                                      )
{
    _PrintEnter("WSALookupServiceBeginA(%p,%x,%p)\n",
                lpqsRestrictions,
                dwControlFlags,
                lphLookup);

    INT rv = 0;
    __try {
        __try {
            _Print("service: [%hs]", lpqsRestrictions->lpszServiceInstanceName);
            _Print("queries: [%hs]", lpqsRestrictions->lpszQueryString);
        }
        __finally {
        }

        rv = Real_WSALookupServiceBeginA(
                                          lpqsRestrictions,
                                          dwControlFlags,
                                          lphLookup);
    } __finally {
        _PrintExit("WSALookupServiceBeginA(,,) -> %x\n", rv);
    };
    return rv;

}

INT WINAPI Mine_WSALookupServiceBeginW(
                                       LPWSAQUERYSETW lpqsRestrictions,
                                       DWORD          dwControlFlags,
                                       LPHANDLE       lphLookup
                               )
{
    _PrintEnter("WSALookupServiceBeginW(%p,%p,%p)\n",
                lpqsRestrictions,
                dwControlFlags,
                lphLookup);
    __debugbreak();

    INT rv = 0;
    __try {
        __try {
            _Print("service: [%ls]", lpqsRestrictions->lpszServiceInstanceName);
            _Print("queries: [%ls]", lpqsRestrictions->lpszQueryString);
        }
        __finally {
        }

        rv = Real_WSALookupServiceBeginW(
                                         lpqsRestrictions,
                                         dwControlFlags,
                                         lphLookup);
    } __finally {
        _PrintExit("WSALookupServiceBeginW(,,) -> %x\n", rv);
    };
    return rv;
}

INT WINAPI Mine_WSALookupServiceNextA(
                               HANDLE           hLookup,
                               DWORD            dwControlFlags,
                               LPDWORD       lpdwBufferLength,
                               LPWSAQUERYSETA lpqsResults
                              )
{
    _PrintEnter("WSALookupServiceNextA(%p,%p,%p,%p)\n",
                hLookup,
                dwControlFlags,
                lpdwBufferLength,
                lpqsResults);

    INT rv = 0;
    __try {
        rv = Real_WSALookupServiceNextA(
                                        hLookup,
                                        dwControlFlags,
                                        lpdwBufferLength,
                                        lpqsResults);
    } __finally {
        _PrintExit("WSALookupServiceNextA(,,) -> %x\n", rv);
    };
    return rv;
}

INT WINAPI Mine_WSALookupServiceNextW(
                               HANDLE         hLookup,
                               DWORD          dwControlFlags,
                               LPDWORD        lpdwBufferLength,
                               LPWSAQUERYSETW lpqsResults
                              )
{
    _PrintEnter("WSALookupServiceNextW(%p,%p,%p,%p)\n",
                hLookup,
                dwControlFlags,
                lpdwBufferLength,
                lpqsResults);

    INT rv = 0;
    __try {
        rv = Real_WSALookupServiceNextW(
                                        hLookup,
                                        dwControlFlags,
                                        lpdwBufferLength,
                                        lpqsResults);
    } __finally {
        _PrintExit("WSALookupServiceNextW(,,) -> %x\n", rv);
    };
    return rv;
}

INT WINAPI Mine_WSALookupServiceEnd(
                                        HANDLE  hLookup
                                    )
{
    _PrintEnter("WSALookupServiceEnd(%p)\n", hLookup);

    INT rv = 0;
    __try {
        rv = Real_WSALookupServiceEnd(hLookup);
    } __finally {
        _PrintExit("WSALookupServiceEnd(,,) -> %x\n", rv);
    };
    return rv;
}

INT WINAPI Mine_WSAProviderConfigChange(LPHANDLE a0,
                                        LPWSAOVERLAPPED a1,
                                        LPWSAOVERLAPPED_COMPLETION_ROUTINE a2)
{
    _PrintEnter("WSAProviderConfigChange(%p,%p,%p)\n", a0, a1, a2);

    INT rv = 0;
    __try {
        rv = Real_WSAProviderConfigChange(a0, a1, a2);
    } __finally {
        _PrintExit("WSAProviderConfigChange(,,) -> %x\n", rv);
    };
    return rv;
}

int WINAPI Mine_WSARecv(SOCKET a0,
                        LPWSABUF a1,
                        DWORD a2,
                        LPDWORD a3,
                        LPDWORD a4,
                        LPWSAOVERLAPPED a5,
                        LPWSAOVERLAPPED_COMPLETION_ROUTINE a6)
{
    int rv = -1;
    __try {
        rv = Real_WSARecv(a0, a1, a2, a3, a4, a5, a6);
    } __finally {
        if (rv == 0) {
            _PrintEnter("%p: WSARecv(,%p,%x,%p,%p,%p,%p)\n",
                        a0, a1, a2, a3, a4, a5, a6);
            _PrintDump(a0, a1[0].buf, a1[0].len < *a3 ? a1[0].len : *a3);
            _PrintExit("%p: WSARecv(,,,,,,) -> %x\n", a0, rv);
        }
    };
    return rv;
}

int WINAPI Mine_WSARecvDisconnect(SOCKET a0,
                                  LPWSABUF a1)
{
    _PrintEnter("%p: WSARecvDisconnect(,%p)\n", a0, a1);

    int rv = 0;
    __try {
        rv = Real_WSARecvDisconnect(a0, a1);
    } __finally {
        _PrintExit("%p: WSARecvDisconnect(,) -> %x\n", a0, rv);
    };
    return rv;
}

int WINAPI Mine_WSARecvFrom(SOCKET a0,
                            LPWSABUF a1,
                            DWORD a2,
                            LPDWORD a3,
                            LPDWORD a4,
                            sockaddr* a5,
                            LPINT a6,
                            LPWSAOVERLAPPED a7,
                            LPWSAOVERLAPPED_COMPLETION_ROUTINE a8)
{
    _PrintEnter("%p: WSARecvFrom(,%p,%x,%p,%p,%p,%p,%p,%p)\n", a0, a1, a2, a3, a4, a5, a6, a7, a8);

    int rv = 0;
    __try {
        rv = Real_WSARecvFrom(a0, a1, a2, a3, a4, a5, a6, a7, a8);
    } __finally {
        _PrintExit("%p: WSARecvFrom(,,,,,,,,) -> %x\n", a0, rv);
    };
    return rv;
}

BOOL WINAPI Mine_WSAResetEvent(HANDLE a0)
{
    _PrintEnter("WSAResetEvent(%p)\n", a0);

    BOOL rv = 0;
    __try {
        rv = Real_WSAResetEvent(a0);
    } __finally {
        _PrintExit("WSAResetEvent() -> %x\n", rv);
    };
    return rv;
}

int WINAPI Mine_WSASend(SOCKET a0,
                        LPWSABUF a1,
                        DWORD a2,
                        LPDWORD a3,
                        DWORD a4,
                        LPWSAOVERLAPPED a5,
                        LPWSAOVERLAPPED_COMPLETION_ROUTINE a6)
{
    _PrintEnter("%p: WSASend(,%p,%x,%p,%x,%p,%p)\n", a0, a1, a2, a3, a4, a5, a6);

    int rv = 0;
    __try {
        rv = Real_WSASend(a0, a1, a2, a3, a4, a5, a6);
    } __finally {
        _PrintExit("%p: WSASend(,,,,,,) -> %x\n", a0, rv);
    };
    return rv;
}

int WINAPI Mine_WSASendDisconnect(SOCKET a0,
                                  LPWSABUF a1)
{
    _PrintEnter("%p: WSASendDisconnect(,%p)\n", a0, a1);

    int rv = 0;
    __try {
        rv = Real_WSASendDisconnect(a0, a1);
    } __finally {
        _PrintExit("%p: WSASendDisconnect(,) -> %x\n", a0, rv);
    };
    return rv;
}

int WINAPI Mine_WSASendTo(SOCKET a0,
                          LPWSABUF a1,
                          DWORD a2,
                          LPDWORD a3,
                          DWORD a4,
                          sockaddr* a5,
                          int a6,
                          LPWSAOVERLAPPED a7,
                          LPWSAOVERLAPPED_COMPLETION_ROUTINE a8)
{
    _PrintEnter("%p: WSASendTo(,%p,%x,%p,%x,%p,%x,%p,%p)\n", a0, a1, a2, a3, a4, a5, a6, a7, a8);

    int rv = 0;
    __try {
        rv = Real_WSASendTo(a0, a1, a2, a3, a4, a5, a6, a7, a8);
    } __finally {
        _PrintExit("%p: WSASendTo(,,,,,,,,) -> %x\n", a0, rv);
    };
    return rv;
}

INT WINAPI Mine_WSAStringToAddressA(LPSTR a0,
                                    INT a1,
                                    LPWSAPROTOCOL_INFOA a2,
                                    LPSOCKADDR a3,
                                    LPINT a4)
{
    _PrintEnter("WSAStringToAddressA(%p,%x,%p,%p,%p)\n", a0, a1, a2, a3, a4);

    INT rv = 0;
    __try {
        rv = Real_WSAStringToAddressA(a0, a1, a2, a3, a4);
    } __finally {
        _PrintExit("WSAStringToAddressA(,,,,) -> %x\n", rv);
    };
    return rv;
}

INT WINAPI Mine_WSAStringToAddressW(LPWSTR a0,
                                    INT a1,
                                    LPWSAPROTOCOL_INFOW a2,
                                    LPSOCKADDR a3,
                                    LPINT a4)
{
    _PrintEnter("WSAStringToAddressW(%p,%x,%p,%p,%p)\n", a0, a1, a2, a3, a4);

    INT rv = 0;
    __try {
        rv = Real_WSAStringToAddressW(a0, a1, a2, a3, a4);
    } __finally {
        _PrintExit("WSAStringToAddressW(,,,,) -> %x\n", rv);
    };
    return rv;
}

DWORD WINAPI Mine_WSAWaitForMultipleEvents(DWORD a0,
                                           void** a1,
                                           BOOL a2,
                                           DWORD a3,
                                           BOOL a4)
{
    _PrintEnter("WSAWaitForMultipleEvents(%x,%p,%x,%x,%x)\n", a0, a1, a2, a3, a4);

    DWORD rv = 0;
    __try {
        rv = Real_WSAWaitForMultipleEvents(a0, a1, a2, a3, a4);
    } __finally {
        _PrintExit("WSAWaitForMultipleEvents(,,,,) -> %x\n", rv);
    };
    return rv;
}

SOCKET WINAPI Mine_accept(SOCKET a0,
                          sockaddr* a1,
                          int* a2)
{
    SOCKET rv = 0;
    __try {
        rv = Real_accept(a0, a1, a2);
    } __finally {
        WCHAR wzAddress[512] = L"";
        int err = WSAGetLastError();
        if (rv != INVALID_SOCKET) {
            DWORD nAddress = ARRAYSIZE(wzAddress);
            if (Real_WSAAddressToStringW(a1, *a2, NULL, wzAddress, &nAddress) != 0) {
                wzAddress[0] = 0;
            }
        }
        WSASetLastError(err);

        if (wzAddress[0]) {
            _PrintEnter("%p: accept(,%ls,%p) -> %p\n", a0, wzAddress, a2, rv);
        }
        else {
            _PrintEnter("%p: accept(,%p,%p) -> %p\n", a0, a1, a2, rv);
        }
        _PrintExit(NULL);
    };
    return rv;
}

int WINAPI Mine_closesocket(SOCKET a0)
{
    int rv = 0;
    __try {
        rv = Real_closesocket(a0);
    } __finally {
        _PrintEnter("%p: closesocket() -> %x\n", a0, rv);
        _PrintExit(NULL);
    };
    return rv;
}

int WINAPI Mine_connect(SOCKET a0,
                        sockaddr* name,
                        int namelen)
{
    int rv = 0;
    __try {
        rv = Real_connect(a0, name, namelen);
    } __finally {
        WCHAR wzAddress[512];
        DWORD nAddress = ARRAYSIZE(wzAddress);
        int err = WSAGetLastError();
        if (Real_WSAAddressToStringW(name, namelen, NULL, wzAddress, &nAddress) == 0) {
            if (rv == SOCKET_ERROR) {
                _PrintEnter("%p: connect(,%p:%ls,%x) -> %x [%d]\n",
                            a0, name, wzAddress, namelen, rv, err);
            }
            else {
                _PrintEnter("%p: connect(,%p:%ls,%x) -> %x\n",
                            a0, name, wzAddress, namelen, rv);
            }
        }
        else {
            if (rv == SOCKET_ERROR) {
                _PrintEnter("%p: connect(,%p,%x) -> %x [%d]\n",
                            a0, name, namelen, rv, err);
            }
            else {
                _PrintEnter("%p: connect(,%p,%x) -> %x\n",
                            a0, name, namelen, rv);
            }
        }
        WSASetLastError(err);
        _PrintExit(NULL);
    };
    return rv;
}

int WINAPI Mine_listen(SOCKET a0,
                       int a1)
{
    _PrintEnter("%p: listen(,%x)\n", a0, a1);

    int rv = 0;
    __try {
        rv = Real_listen(a0, a1);
    } __finally {
        _PrintExit("%p: listen(,) -> %x\n", a0, rv);
    };
    return rv;
}

int WINAPI Mine_recv(SOCKET a0,
                     char* a1,
                     int a2,
                     int a3)
{
    _PrintEnter("%p: recv(,%p,%x,%x)\n", a0, a1, a2, a3);

    int rv = 0;
    __try {
        rv = Real_recv(a0, a1, a2, a3);
    } __finally {
        _PrintExit("%p: recv(,%s,,) -> %x\n", a0, a1, rv);
    };
    return rv;
}

int WINAPI Mine_recvfrom(SOCKET a0,
                         char* a1,
                         int a2,
                         int a3,
                         sockaddr* a4,
                         int* a5)
{
    _PrintEnter("%p: recvfrom(,%p,%x,%x,%p,%p)\n", a0, a1, a2, a3, a4, a5);

    int rv = 0;
    __try {
        rv = Real_recvfrom(a0, a1, a2, a3, a4, a5);
    } __finally {
        _PrintExit("%p: recvfrom(,%s,,,,) -> %x\n", a0, a1, rv);
    };
    return rv;
}

VOID _PrintDump(SOCKET socket, PCHAR pszData, INT cbData)
{
    if (pszData && cbData > 0) {
        CHAR szBuffer[256];
        PCHAR pszBuffer = szBuffer;
        INT cbBuffer = 0;
        INT nLines = 0;

        while (cbData > 0) {
            if (nLines > 20) {
                *pszBuffer++ = '.';
                *pszBuffer++ = '.';
                *pszBuffer++ = '.';
                cbBuffer += 3;
                break;
            }

            if (*pszData == '\t') {
                *pszBuffer++ = '\\';
                *pszBuffer++ = 't';
                cbBuffer += 2;
                pszData++;
                cbData--;
                continue;
            }
            if (*pszData == '\r') {
                *pszBuffer++ = '\\';
                *pszBuffer++ = 'r';
                cbBuffer += 2;
                pszData++;
                cbData--;
                continue;
            }
            else if (*pszData == '\n') {
                *pszBuffer++ = '\\';
                *pszBuffer++ = 'n';
                cbBuffer += 2;
                *pszBuffer++ = '\0';
                _Print("%p:   %hs\n", socket, szBuffer);
                nLines++;
                pszBuffer = szBuffer;
                cbBuffer = 0;
                pszData++;
                cbData--;
                continue;
            }
            else if (cbBuffer >= 80) {
                *pszBuffer++ = '\0';
                _Print("%p:   %hs\n", socket, szBuffer);
                nLines++;
                pszBuffer = szBuffer;
                cbBuffer = 0;
            }

            if (*pszData < ' ' || *pszData >= 127) {
                *pszBuffer++ = '\\';
                *pszBuffer++ = 'x';
                *pszBuffer++ = "0123456789ABCDEF"[(*pszData & 0xf0) >> 4];
                *pszBuffer++ = "0123456789ABCDEF"[(*pszData & 0x0f)];
                cbBuffer += 4;
            }
            else {
                *pszBuffer++ = *pszData;
            }
            cbBuffer++;
            pszData++;
            cbData--;
        }

        if (cbBuffer > 0) {
            *pszBuffer++ = '\0';
            _Print("%p:   %hs\n", socket, szBuffer);
        }
    }
}

int WINAPI Mine_send(SOCKET a0,
                     char* a1,
                     int a2,
                     int a3)
{
    _PrintEnter("%p: send(,%p,%x,%x)\n", a0, a1, a2, a3);
    _PrintDump(a0, a1, a2);

    int rv = 0;
    __try {
        rv = Real_send(a0, a1, a2, a3);
    } __finally {
        if (rv == SOCKET_ERROR) {
            int err = WSAGetLastError();
            _PrintExit("%p: send(,,,) -> %x (%d)\n", a0, rv, err);
        }
        else {
            _PrintExit("%p: send(,,,) -> %x\n", a0, rv);
        }
    };
    return rv;
}

int WINAPI Mine_sendto(SOCKET a0,
                       char* a1,
                       int a2,
                       int a3,
                       sockaddr* a4,
                       int a5)
{
    _PrintEnter("%p: sendto(,%s,%x,%x,%p,%x)\n", a0, a1, a2, a3, a4, a5);

    int rv = 0;
    __try {
        rv = Real_sendto(a0, a1, a2, a3, a4, a5);
    } __finally {
        _PrintExit("%p: sendto(%ls,,,,,) -> %x\n", a0, a1, rv);
    };
    return rv;
}

int WINAPI Mine_shutdown(SOCKET a0,
                         int a1)
{
    _PrintEnter("%p: shutdown(,%x)\n", a0, a1);

    int rv = 0;
    __try {
        rv = Real_shutdown(a0, a1);
    } __finally {
        _PrintExit("%p: shutdown(,) -> %x\n", a0, rv);
    };
    return rv;
}

/////////////////////////////////////////////////////////////
// AttachDetours
//
PCHAR DetRealName(PCHAR psz)
{
    PCHAR pszBeg = psz;
    // Move to end of name.
    while (*psz) {
        psz++;
    }
    // Move back through A-Za-z0-9 names.
    while (psz > pszBeg &&
           ((psz[-1] >= 'A' && psz[-1] <= 'Z') ||
            (psz[-1] >= 'a' && psz[-1] <= 'z') ||
            (psz[-1] >= '0' && psz[-1] <= '9'))) {
        psz--;
    }
    return psz;
}

VOID DetAttach(PVOID *ppbReal, PVOID pbMine, PCHAR psz)
{
    LONG l = DetourAttach(ppbReal, pbMine);
    if (l != 0) {
        Syelog(SYELOG_SEVERITY_NOTICE,
               "Attach failed: `%s': error %d\n", DetRealName(psz), l);
    }
}

VOID DetDetach(PVOID *ppbReal, PVOID pbMine, PCHAR psz)
{
    LONG l = DetourDetach(ppbReal, pbMine);
    if (l != 0) {
        Syelog(SYELOG_SEVERITY_NOTICE,
               "Detach failed: `%s': error %d\n", DetRealName(psz), l);
    }
}

#define ATTACH(x)       DetAttach(&(PVOID&)Real_##x,Mine_##x,#x)
#define DETACH(x)       DetDetach(&(PVOID&)Real_##x,Mine_##x,#x)

LONG AttachDetours(VOID)
{
    DetourTransactionBegin();
    DetourUpdateThread(GetCurrentThread());

    ATTACH(CreateProcessW);
    ATTACH(WSAAccept);
    ATTACH(WSAAddressToStringA);
    ATTACH(WSAAddressToStringW);
    ATTACH(WSAAsyncGetHostByAddr);
    ATTACH(WSAAsyncGetHostByName);
    ATTACH(WSAAsyncGetProtoByName);
    ATTACH(WSAAsyncGetProtoByNumber);
    ATTACH(WSAAsyncGetServByName);
    ATTACH(WSAAsyncGetServByPort);
    ATTACH(WSACancelAsyncRequest);
    ATTACH(WSACancelBlockingCall);
    ATTACH(WSACleanup);
    ATTACH(WSACloseEvent);
    ATTACH(WSAConnect);
    ATTACH(WSACreateEvent);
    ATTACH(WSADuplicateSocketA);
    ATTACH(WSADuplicateSocketW);
    ATTACH(WSAEnumNameSpaceProvidersA);
    ATTACH(WSAEnumNameSpaceProvidersW);
    ATTACH(WSAEnumNetworkEvents);
    ATTACH(WSAEnumProtocolsA);
    ATTACH(WSAEnumProtocolsW);
    ATTACH(WSAIsBlocking);
    ATTACH(WSAJoinLeaf);
    ATTACH(WSALookupServiceBeginA);
    ATTACH(WSALookupServiceBeginW);
    ATTACH(WSALookupServiceNextA);
    ATTACH(WSALookupServiceNextW);
    ATTACH(WSALookupServiceEnd);
    ATTACH(WSAProviderConfigChange);
    ATTACH(WSARecv);
    ATTACH(WSARecvDisconnect);
    ATTACH(WSARecvFrom);
    ATTACH(WSAResetEvent);
    ATTACH(WSASend);
    ATTACH(WSASendDisconnect);
    ATTACH(WSASendTo);
    ATTACH(WSAStringToAddressA);
    ATTACH(WSAStringToAddressW);
    ATTACH(WSAWaitForMultipleEvents);
    ATTACH(accept);
    ATTACH(closesocket);
    ATTACH(connect);
    ATTACH(listen);
    ATTACH(recv);
    ATTACH(recvfrom);
    ATTACH(send);
    ATTACH(sendto);
    ATTACH(shutdown);

    return DetourTransactionCommit();
}

LONG DetachDetours(VOID)
{
    DetourTransactionBegin();
    DetourUpdateThread(GetCurrentThread());

    DETACH(CreateProcessW);
    DETACH(WSAAccept);
    DETACH(WSAAddressToStringA);
    DETACH(WSAAddressToStringW);
    DETACH(WSAAsyncGetHostByAddr);
    DETACH(WSAAsyncGetHostByName);
    DETACH(WSAAsyncGetProtoByName);
    DETACH(WSAAsyncGetProtoByNumber);
    DETACH(WSAAsyncGetServByName);
    DETACH(WSAAsyncGetServByPort);
    DETACH(WSACancelAsyncRequest);
    DETACH(WSACancelBlockingCall);
    DETACH(WSACleanup);
    DETACH(WSACloseEvent);
    DETACH(WSAConnect);
    DETACH(WSACreateEvent);
    DETACH(WSADuplicateSocketA);
    DETACH(WSADuplicateSocketW);
    DETACH(WSAEnumNameSpaceProvidersA);
    DETACH(WSAEnumNameSpaceProvidersW);
    DETACH(WSAEnumNetworkEvents);
    DETACH(WSAEnumProtocolsA);
    DETACH(WSAEnumProtocolsW);
    DETACH(WSAIsBlocking);
    DETACH(WSAJoinLeaf);
    DETACH(WSALookupServiceBeginA);
    DETACH(WSALookupServiceBeginW);
    DETACH(WSALookupServiceNextA);
    DETACH(WSALookupServiceNextW);
    DETACH(WSALookupServiceEnd);
    DETACH(WSAProviderConfigChange);
    DETACH(WSARecv);
    DETACH(WSARecvDisconnect);
    DETACH(WSARecvFrom);
    DETACH(WSAResetEvent);
    DETACH(WSASend);
    DETACH(WSASendDisconnect);
    DETACH(WSASendTo);
    DETACH(WSAStringToAddressA);
    DETACH(WSAStringToAddressW);
    DETACH(WSAWaitForMultipleEvents);
    DETACH(accept);
    DETACH(closesocket);
    DETACH(connect);
    DETACH(listen);
    DETACH(recv);
    DETACH(recvfrom);
    DETACH(send);
    DETACH(sendto);
    DETACH(shutdown);

    return DetourTransactionCommit();
}

//
//////////////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////// Logging System.
//
static BOOL s_bLog = 1;
static LONG s_nTlsIndent = -1;
static LONG s_nTlsThread = -1;
static LONG s_nThreadCnt = 0;

VOID _PrintEnter(const CHAR *psz, ...)
{
    DWORD dwErr = GetLastError();

    LONG nIndent = 0;
    LONG nThread = 0;
    if (s_nTlsIndent >= 0) {
        nIndent = (LONG)(LONG_PTR)TlsGetValue(s_nTlsIndent);
        TlsSetValue(s_nTlsIndent, (PVOID)(LONG_PTR)(nIndent + 1));
    }
    if (s_nTlsThread >= 0) {
        nThread = (LONG)(LONG_PTR)TlsGetValue(s_nTlsThread);
    }

    if (s_bLog && psz) {
        CHAR szBuf[1024];
        PCHAR pszBuf = szBuf;
        PCHAR pszEnd = szBuf + ARRAYSIZE(szBuf) - 1;
        LONG nLen = (nIndent > 0) ? (nIndent < 35 ? nIndent * 2 : 70) : 0;
        *pszBuf++ = (CHAR)('0' + ((nThread / 100) % 10));
        *pszBuf++ = (CHAR)('0' + ((nThread / 10) % 10));
        *pszBuf++ = (CHAR)('0' + ((nThread / 1) % 10));
        *pszBuf++ = ' ';
        while (nLen-- > 0) {
            *pszBuf++ = ' ';
        }

        va_list  args;
        va_start(args, psz);

        while ((*pszBuf++ = *psz++) != 0 && pszBuf < pszEnd) {
            // Copy characters.
        }
        *pszEnd = '\0';
        SyelogV(SYELOG_SEVERITY_INFORMATION,
                szBuf, args);

        va_end(args);
    }
    SetLastError(dwErr);
}

VOID _PrintExit(const CHAR *psz, ...)
{
    DWORD dwErr = GetLastError();

    LONG nIndent = 0;
    LONG nThread = 0;
    if (s_nTlsIndent >= 0) {
        nIndent = (LONG)(LONG_PTR)TlsGetValue(s_nTlsIndent) - 1;
        ASSERT(nIndent >= 0);
        TlsSetValue(s_nTlsIndent, (PVOID)(LONG_PTR)nIndent);
    }
    if (s_nTlsThread >= 0) {
        nThread = (LONG)(LONG_PTR)TlsGetValue(s_nTlsThread);
    }

    if (s_bLog && psz) {
        CHAR szBuf[1024];
        PCHAR pszBuf = szBuf;
        PCHAR pszEnd = szBuf + ARRAYSIZE(szBuf) - 1;
        LONG nLen = (nIndent > 0) ? (nIndent < 35 ? nIndent * 2 : 70) : 0;
        *pszBuf++ = (CHAR)('0' + ((nThread / 100) % 10));
        *pszBuf++ = (CHAR)('0' + ((nThread / 10) % 10));
        *pszBuf++ = (CHAR)('0' + ((nThread / 1) % 10));
        *pszBuf++ = ' ';
        while (nLen-- > 0) {
            *pszBuf++ = ' ';
        }

        va_list  args;
        va_start(args, psz);

        while ((*pszBuf++ = *psz++) != 0 && pszBuf < pszEnd) {
            // Copy characters.
        }
        *pszEnd = '\0';
        SyelogV(SYELOG_SEVERITY_INFORMATION,
                szBuf, args);

        va_end(args);
    }
    SetLastError(dwErr);
}

VOID _Print(const CHAR *psz, ...)
{
    DWORD dwErr = GetLastError();

    LONG nIndent = 0;
    LONG nThread = 0;
    if (s_nTlsIndent >= 0) {
        nIndent = (LONG)(LONG_PTR)TlsGetValue(s_nTlsIndent);
    }
    if (s_nTlsThread >= 0) {
        nThread = (LONG)(LONG_PTR)TlsGetValue(s_nTlsThread);
    }

    if (s_bLog && psz) {
        CHAR szBuf[1024];
        PCHAR pszBuf = szBuf;
        PCHAR pszEnd = szBuf + ARRAYSIZE(szBuf) - 1;
        LONG nLen = (nIndent > 0) ? (nIndent < 35 ? nIndent * 2 : 70) : 0;
        *pszBuf++ = (CHAR)('0' + ((nThread / 100) % 10));
        *pszBuf++ = (CHAR)('0' + ((nThread / 10) % 10));
        *pszBuf++ = (CHAR)('0' + ((nThread / 1) % 10));
        *pszBuf++ = ' ';
        while (nLen-- > 0) {
            *pszBuf++ = ' ';
        }

        va_list  args;
        va_start(args, psz);

        while ((*pszBuf++ = *psz++) != 0 && pszBuf < pszEnd) {
            // Copy characters.
        }
        *pszEnd = '\0';
        SyelogV(SYELOG_SEVERITY_INFORMATION,
                szBuf, args);

        va_end(args);
    }

    SetLastError(dwErr);
}

VOID AssertMessage(CONST PCHAR pszMsg, CONST PCHAR pszFile, ULONG nLine)
{
    Syelog(SYELOG_SEVERITY_FATAL,
           "ASSERT(%s) failed in %s, line %d.\n", pszMsg, pszFile, nLine);
}

//////////////////////////////////////////////////////////////////////////////
//
// DLL module information
//
BOOL ThreadAttach(HMODULE hDll)
{
    (void)hDll;

    if (s_nTlsIndent >= 0) {
        TlsSetValue(s_nTlsIndent, (PVOID)0);
    }
    if (s_nTlsThread >= 0) {
        LONG nThread = InterlockedIncrement(&s_nThreadCnt);
        TlsSetValue(s_nTlsThread, (PVOID)(LONG_PTR)nThread);
    }
    return TRUE;
}

BOOL ThreadDetach(HMODULE hDll)
{
    (void)hDll;

    if (s_nTlsIndent >= 0) {
        TlsSetValue(s_nTlsIndent, (PVOID)0);
    }
    if (s_nTlsThread >= 0) {
        TlsSetValue(s_nTlsThread, (PVOID)0);
    }
    return TRUE;
}

BOOL ProcessAttach(HMODULE hDll)
{
    s_bLog = FALSE;
    s_nTlsIndent = TlsAlloc();
    s_nTlsThread = TlsAlloc();

    WCHAR wzExeName[MAX_PATH];
    s_hInst = hDll;

    Real_GetModuleFileNameW(hDll, s_wzDllPath, ARRAYSIZE(s_wzDllPath));
    Real_GetModuleFileNameW(NULL, wzExeName, ARRAYSIZE(wzExeName));

    SyelogOpen("trctcp" DETOURS_STRINGIFY(DETOURS_BITS), SYELOG_FACILITY_APPLICATION);
    Syelog(SYELOG_SEVERITY_INFORMATION,
           "##################################################################\n");
    Syelog(SYELOG_SEVERITY_INFORMATION,
           "### %ls\n", wzExeName);
    LONG error = AttachDetours();
    if (error != NO_ERROR) {
        Syelog(SYELOG_SEVERITY_FATAL, "### Error attaching detours: %d\n", error);
    }

    ThreadAttach(hDll);

    s_bLog = TRUE;
    return TRUE;
}

BOOL ProcessDetach(HMODULE hDll)
{
    ThreadDetach(hDll);
    s_bLog = FALSE;

    LONG error = DetachDetours();
    if (error != NO_ERROR) {
        Syelog(SYELOG_SEVERITY_FATAL, "### Error detaching detours: %d\n", error);
    }

    Syelog(SYELOG_SEVERITY_NOTICE, "### Closing.\n");
    SyelogClose(FALSE);

    if (s_nTlsIndent >= 0) {
        TlsFree(s_nTlsIndent);
    }
    if (s_nTlsThread >= 0) {
        TlsFree(s_nTlsThread);
    }
    return TRUE;
}

BOOL APIENTRY DllMain(HINSTANCE hModule, DWORD dwReason, PVOID lpReserved)
{
    (void)hModule;
    (void)lpReserved;

    if (DetourIsHelperProcess()) {
        return TRUE;
    }

    switch (dwReason) {
      case DLL_PROCESS_ATTACH:
        DetourRestoreAfterWith();
        printf("trctcp" DETOURS_STRINGIFY(DETOURS_BITS) ".dll: Starting.\n");
        fflush(stdout);
        return ProcessAttach(hModule);
      case DLL_PROCESS_DETACH:
        return ProcessDetach(hModule);
      case DLL_THREAD_ATTACH:
        return ThreadAttach(hModule);
      case DLL_THREAD_DETACH:
        return ThreadDetach(hModule);
    }
    return TRUE;
}
//
///////////////////////////////////////////////////////////////// End of File.

```

`samples/tracetcp/trctcp.rc`:

```rc
//////////////////////////////////////////////////////////////////////////////
//
//  Version information for trctcp.rc.
//
//  Microsoft Research Detours Package
//
//  Copyright (c) Microsoft Corporation.  All rights reserved.
//

#include "detver.h"

#define VER_INTERNALNAME_STR        "trctcp" DETOURS_STRINGIFY(DETOURS_BITS)
#define VER_ORIGINALFILENAME_STR    "trctcp" DETOURS_STRINGIFY(DETOURS_BITS) ".dll"
#define VER_FILEDESCRIPTION_STR     "Detours TCP Trace Module"
#define VER_COMPANYNAME_STR         "Microsoft Corporation"

#include "common.ver"

```

`samples/tryman/Makefile`:

```
##############################################################################
##
##  Detours Test Program
##
##  Microsoft Research Detours Package
##
##  Copyright (c) Microsoft Corporation.  All rights reserved.
##

!include ..\common.mak

BIND_X86=$(ROOT)\bin.x86
BIND_X64=$(ROOT)\bin.x64

LIBS = $(LIBS) kernel32.lib

##############################################################################

all: dirs \
    $(BIND)\tstman$(DETOURS_BITS).dll \
    $(BIND)\tryman$(DETOURS_BITS).exe \
    $(BIND)\size$(DETOURS_BITS).exe \
    \
    $(BIND)\managed-x64.exe \
    $(BIND)\managed-ia64.exe \
    $(BIND)\managed-x86.exe \
    $(BIND)\managed-any.exe \
    $(BIND)\managed-any32.exe \
    \
!IF $(DETOURS_SOURCE_BROWSING)==1
    $(OBJD)\tstman$(DETOURS_BITS).bsc \
    $(OBJD)\tryman$(DETOURS_BITS).bsc \
!ENDIF
    option

##############################################################################

dirs:
    @if not exist $(BIND) mkdir $(BIND) && echo.   Created $(BIND)
    @if not exist $(OBJD) mkdir $(OBJD) && echo.   Created $(BIND)

$(OBJD)\tstman.obj : tstman.cpp

$(OBJD)\tstman.res : tstman.rc

$(BIND)\tstman$(DETOURS_BITS).dll $(BIND)\tstman$(DETOURS_BITS).lib: \
        $(OBJD)\tstman.obj $(OBJD)\tstman.res $(DEPS)
    cl /LD $(CFLAGS) /Fe$(@R).dll /Fd$(@R).pdb \
        $(OBJD)\tstman.obj $(OBJD)\tstman.res \
        /link $(LINKFLAGS) /subsystem:console \
        /export:DetourFinishHelperProcess,@1,NONAME \
        /export:Test3264 \
        $(LIBS)

$(OBJD)\tstman$(DETOURS_BITS).bsc : tstman.obj
    bscmake /v /n /o $@ tstman.sbr

$(OBJD)\tryman.obj : tryman.cpp

$(BIND)\tryman$(DETOURS_BITS).exe : $(OBJD)\tryman.obj $(DEPS) $(BIND)\tstman$(DETOURS_BITS).lib
    cl $(CFLAGS) /Fe$@ /Fd$(@R).pdb $(OBJD)\tryman.obj \
        /link $(LINKFLAGS) $(LIBS) $(BIND)\tstman$(DETOURS_BITS).lib \
        /subsystem:console

$(OBJD)\tryman$(DETOURS_BITS).bsc : $(OBJD)\tryman.obj
    bscmake /v /n /o $@ $(OBJD)\tryman.sbr

$(OBJD)\size.obj : size.cpp

$(BIND)\size$(DETOURS_BITS).exe : $(OBJD)\size.obj $(DEPS)
    cl $(CFLAGS) /Fe$@ /Fd$(@R).pdb $(OBJD)\size.obj \
        /link $(LINKFLAGS) $(LIBS) \
        /subsystem:console /fixed:no

$(OBJD)\size$(DETOURS_BITS).bsc : $(OBJD)\size.obj
    bscmake /v /n /o $@ $(OBJD)\size.sbr

$(BIND)\key.snk:
    if not exist $(BIND)\key.snk sn -k $(BIND)\key.snk

CSCFLAGS=/nowarn:1607 /unsafe- /optimize+ /debug+ /warnaserror

$(BIND)\managed-x64.exe : $(BIND)\key.snk managed.cs
    csc /nologo $(CSCFLAGS) /platform:x64 /keyfile:$(BIND)\key.snk \
        /out:$(BIND)\managed-x64.exe managed.cs

$(BIND)\managed-ia64.exe : $(BIND)\key.snk managed.cs
    csc /nologo $(CSCFLAGS) /platform:itanium /keyfile:$(BIND)\key.snk \
        /out:$(BIND)\managed-ia64.exe managed.cs

$(BIND)\managed-x86.exe : $(BIND)\key.snk managed.cs
    csc /nologo $(CSCFLAGS) /platform:x86 /keyfile:$(BIND)\key.snk \
        /out:$(BIND)\managed-x86.exe managed.cs

$(BIND)\managed-any.exe : $(BIND)\key.snk managed.cs
    csc /nologo $(CSCFLAGS) /platform:anycpu /keyfile:$(BIND)\key.snk \
        /out:$(BIND)\managed-any.exe managed.cs

$(BIND)\managed-any32.exe : $(BIND)\key.snk managed.cs
    -csc /nologo $(CSCFLAGS) /platform:anycpu32bitpreferred /keyfile:$(BIND)\key.snk \
        /out:$(BIND)\managed-any32.exe managed.cs

##############################################################################

clean:
    -del *~ 2>nul
    -del $(BIND)\managed-*.* 2>nul
    -del $(BIND)\tstman*.* 2>nul
    -del $(BIND)\tryman*.* 2>nul
    -del $(BIND)\size*.* 2>nul
    -rmdir /q /s $(OBJD) 2>nul

realclean: clean
    -rmdir /q /s $(OBJDS) 2>nul

############################################### Install non-bit-size binaries.

!IF "$(DETOURS_OPTION_PROCESSOR)" != ""

$(OPTD)\tstman$(DETOURS_OPTION_BITS).dll:
$(OPTD)\tstman$(DETOURS_OPTION_BITS).pdb:
$(OPTD)\tryman$(DETOURS_OPTION_BITS).exe:
$(OPTD)\tryman$(DETOURS_OPTION_BITS).pdb:
$(OPTD)\size$(DETOURS_OPTION_BITS).exe:
$(OPTD)\size$(DETOURS_OPTION_BITS).pdb:

$(BIND)\tstman$(DETOURS_OPTION_BITS).dll : $(OPTD)\tstman$(DETOURS_OPTION_BITS).dll
    @if exist $? copy /y $? $(BIND) >nul >nul && echo.   $@ copied.
$(BIND)\tstman$(DETOURS_OPTION_BITS).pdb : $(OPTD)\tstman$(DETOURS_OPTION_BITS).pdb
    @if exist $? copy /y $? $(BIND) >nul >nul && echo.   $@ copied.
$(BIND)\tryman$(DETOURS_OPTION_BITS).exe : $(OPTD)\tryman$(DETOURS_OPTION_BITS).exe
    @if exist $? copy /y $? $(BIND) >nul >nul && echo.   $@ copied.
$(BIND)\tryman$(DETOURS_OPTION_BITS).pdb : $(OPTD)\tryman$(DETOURS_OPTION_BITS).pdb
    @if exist $? copy /y $? $(BIND) >nul >nul && echo.   $@ copied.
$(BIND)\size$(DETOURS_OPTION_BITS).exe : $(OPTD)\size$(DETOURS_OPTION_BITS).exe
    @if exist $? copy /y $? $(BIND) >nul >nul && echo.   $@ copied.
$(BIND)\size$(DETOURS_OPTION_BITS).pdb : $(OPTD)\size$(DETOURS_OPTION_BITS).pdb
    @if exist $? copy /y $? $(BIND) >nul >nul && echo.   $@ copied.

option: \
    $(BIND)\tstman$(DETOURS_OPTION_BITS).dll \
    $(BIND)\tstman$(DETOURS_OPTION_BITS).pdb \
    $(BIND)\tryman$(DETOURS_OPTION_BITS).exe \
    $(BIND)\tryman$(DETOURS_OPTION_BITS).pdb \
    $(BIND)\size$(DETOURS_OPTION_BITS).exe \
    $(BIND)\size$(DETOURS_OPTION_BITS).pdb \

!ELSE

option:

!ENDIF

##############################################################################

# !IF "$(DETOURS_TARGET_PROCESSOR)" == "X64"
# #!MESSAGE Building for 64-bit X64.
# DETOURS_SOURCE_BROWSING = 0
# !ELSEIF "$(DETOURS_TARGET_PROCESSOR)" == "IA64"
# #!MESSAGE Building for 64-bit IA64.
# !ELSEIF "$(DETOURS_TARGET_PROCESSOR)" == "X86"
# #!MESSAGE Building for 32-bit X86.
# !ELSE

!if "$(DETOURS_OPTION_PROCESSOR)" != ""
test: all size32 size64
!else
test: all
!endif
    @echo ---- Trying native binary w/o test ----------------------
    $(BIND)\tryman$(DETOURS_BITS).exe
    @echo.
    @echo ---- Trying native binary -------------------------------
    $(BIND)\withdll.exe -d:$(BIND)\tstman$(DETOURS_BITS).dll $(BIND)\tryman$(DETOURS_BITS).exe
    @echo.
    @echo ---- Trying anycpu managed binary -----------------------
    -$(BIND)\withdll.exe -d:$(BIND)\tstman$(DETOURS_BITS).dll $(BIND)\managed-any.exe
    @echo.
    @echo ---- Trying anycpu managed 32-bit preferrred binary -----
    -if exist $(BIND)\managed-any32.exe $(BIND)\withdll.exe -d:$(BIND)\tstman$(DETOURS_BITS).dll $(BIND)\managed-any32.exe
    @echo.
    @echo ---- Trying x86 managed binary --------------------------
    -$(BIND)\withdll.exe -d:$(BIND)\tstman$(DETOURS_BITS).dll $(BIND)\managed-x86.exe
    @echo.
    @echo ---- Trying x64 managed binary --------------------------
    -$(BIND)\withdll.exe -d:$(BIND)\tstman$(DETOURS_BITS).dll $(BIND)\managed-x64.exe
    @echo.
    @echo ---- Trying ia64 managed binary -------------------------
    -$(BIND)\withdll.exe -d:$(BIND)\tstman$(DETOURS_BITS).dll $(BIND)\managed-ia64.exe
    @echo.

testm: all
    csc managed.cs
    @echo.
    $(BIND)\withdll.exe -d:$(BIND)\tstman$(DETOURS_BITS).dll $(BIND)\managed-any.exe
    @echo.

size: all
    @echo.
    $(BIND)\withdll.exe -d:$(BIND)\tstman$(DETOURS_BITS).dll $(BIND)\size$(DETOURS_BITS).exe 10
    @echo.

size32: all
    @echo.
    $(BIND)\withdll.exe -d:$(BIND)\tstman$(DETOURS_BITS).dll $(BIND)\size32.exe 10
    @echo.

size64: all
    @echo.
    $(BIND)\withdll.exe -d:$(BIND)\tstman$(DETOURS_BITS).dll $(BIND)\size64.exe 10
    @echo.

sizedbg: all
    @echo.
    windbg -o $(BIND)\withdll.exe -d:$(BIND)\tstman$(DETOURS_BITS).dll $(BIND)\size$(DETOURS_BITS).exe 10
    @echo.

tx: all
    cd $(MAKEDIR)\..\..\src
    nmake /nologo
    cd $(MAKEDIR)\..\..\samples\withdll
    nmake /nologo
    cd $(MAKEDIR)
    rem $(BIND)\withdll.exe -d:$(BIND)\tstman$(DETOURS_BITS).dll $(BIND)\managed.exe
    windbg -g -o $(BIND)\withdll.exe -d:$(BIND)\tstman$(DETOURS_BITS).dll $(BIND)\managed-any.exe

mx: all
    cd $(MAKEDIR)\..\..\src
    nmake /nologo
    cd $(MAKEDIR)\..\..\samples\withdll
    nmake /nologo
    cd $(MAKEDIR)
    $(BIND)\withdll.exe -d:$(BIND)\tstman$(DETOURS_BITS).dll $(BIND)\tryman$(DETOURS_BITS).exe

test-managed: all
    @echo ---- Trying anycpu managed binary -----------------------
    -$(BIND)\withdll.exe -d:$(BIND)\tstman$(DETOURS_BITS).dll $(BIND)\managed-any.exe
    @echo.
    @echo ---- Trying x86 managed binary --------------------------
    -$(BIND_X86)\withdll.exe -d:$(BIND_X86)\tstman32.dll $(BIND_X86)\managed-x86.exe
    @echo.
    @echo ---- Trying anycpu managed 32-bit preferrred binary -----
    -if exist $(BIND_X86)\managed-any32.exe $(BIND_X86)\withdll.exe -d:$(BIND_X86)\tstman32.dll $(BIND_X86)\managed-any32.exe
    @echo.
    @echo ---- Trying x64 managed binary --------------------------
    -$(BIND)\withdll.exe -d:$(BIND_X64)\tstman64.dll $(BIND)\managed-x64.exe

################################################################# End of File.

```

`samples/tryman/managed.cs`:

```cs
using System;
using System.Reflection;
using System.Runtime.InteropServices;

[assembly: AssemblyProduct("Microsoft Research Detours")]
[assembly: AssemblyCompany("Microsoft Corporation")]
[assembly: AssemblyVersion("1.0.0.0")]

public class Test
{
    //    [DllImport("kernel32.dll", CharSet=CharSet.Auto, SetLastError=true)]
    //    static extern IntPtr LoadLibrary([In, MarshalAs(UnmanagedType.LPStr)] string lpFileName);

    [DllImport("kernel32", CharSet=CharSet.Auto, SetLastError=true)]
    static extern IntPtr LoadLibrary(string lpFileName);

    public static int Main()
    {
        if (IntPtr.Size == 4) {
            Console.WriteLine("  *** Managed code with 32-bit runtime ({0})",
                              Environment.Version);
        }
        else if (IntPtr.Size == 8) {
            Console.WriteLine("  *** Managed code with 64-bit runtime ({0})",
                              Environment.Version);
        }
        else {
            Console.WriteLine("  *** Managed code of unknown IntPtr.Size: {0}", IntPtr.Size);
        }

        if (IntPtr.Size == 4) {
            if (LoadLibrary("tstman32.dll") == (IntPtr)0) {
                Console.WriteLine("--------: managed code failed to load tstman32.dll");

            }
        }
        else {
            if (LoadLibrary("tstman64.dll") == (IntPtr)0) {
                Console.WriteLine("--------: managed code failed to load tstman64.dll");

            }
        }

        return 0;
    }
}



```

`samples/tryman/size.cpp`:

```cpp
//////////////////////////////////////////////////////////////////////////////
//
//  Detour Test Program (sleepold.cpp of sleepold.exe)
//
//  Microsoft Research Detours Package
//
//  Copyright (c) Microsoft Corporation.  All rights reserved.
//

#include <windows.h>
#include <stdio.h>
#include <stdlib.h>
#pragma warning(push)
#if _MSC_VER > 1400
#pragma warning(disable:6102 6103) // /analyze warnings
#endif
#include <strsafe.h>
#pragma warning(pop)
#include <detours.h>

int __cdecl main(int argc, char **argv)
{
    STARTUPINFOA si;
    PROCESS_INFORMATION pi;
    CHAR szFullExe[MAX_PATH];
    CHAR szCommand[MAX_PATH];
    PCHAR pszFileExe;
    PCHAR pszExe;

    ZeroMemory(&si, sizeof(si));
    ZeroMemory(&pi, sizeof(pi));
    si.cb = sizeof(si);


    if (argc != 2) {
        printf("size" DETOURS_STRINGIFY(DETOURS_BITS) ".exe:"
               " must take a single integer argument.\n");
        fflush(stdout);
        return 3;
    }

    int repeats = atoi(argv[1]);

    if (repeats <= 0) {
        printf("size" DETOURS_STRINGIFY(DETOURS_BITS) ".exe:"
               " End of the road, repeats=0.\n");
        fflush(stdout);
        return 0;
    }

    if ((repeats % 2) == 0) {
#ifdef DETOURS_OPTION_BITS
        pszExe = "size" DETOURS_STRINGIFY(DETOURS_OPTION_BITS) ".exe";
#else
        pszExe = "size" DETOURS_STRINGIFY(DETOURS_BITS) ".exe";
#endif
    }
    else {
        pszExe = "size" DETOURS_STRINGIFY(DETOURS_BITS) ".exe";
    }

    if (!SearchPathA(NULL, pszExe, ".exe", ARRAYSIZE(szFullExe), szFullExe, &pszFileExe)) {
        pszExe = "size" DETOURS_STRINGIFY(DETOURS_BITS) ".exe";
        SearchPathA(NULL, pszExe, ".exe", ARRAYSIZE(szFullExe), szFullExe, &pszFileExe);
    }

    StringCchPrintfA(szCommand, sizeof(szCommand), "%s %d", pszExe, repeats - 1);

    printf("size" DETOURS_STRINGIFY(DETOURS_BITS) ".exe:"
           " [%s]\n", szCommand);
    fflush(stdout);

    SetLastError(0);
    if (!CreateProcessA(szFullExe[0] ? szFullExe : NULL, szCommand,
                        NULL, NULL, TRUE, 0, NULL, NULL, &si, &pi)) {
        DWORD dwError = GetLastError();
        printf("size" DETOURS_STRINGIFY(DETOURS_BITS) ".exe:"
               " CreateProcess failed: %ld\n", dwError);
        return 1;
    }

    WaitForSingleObject(pi.hProcess, INFINITE);

    DWORD dwResult = 0;
    if (!GetExitCodeProcess(pi.hProcess, &dwResult)) {
        printf("size" DETOURS_STRINGIFY(DETOURS_BITS) ".exe:"
               " GetExitCodeProcess failed: %ld\n", GetLastError());
        return 9010;
    }

    return 0;
}
//
///////////////////////////////////////////////////////////////// End of File.

```

`samples/tryman/tryman.cpp`:

```cpp
//////////////////////////////////////////////////////////////////////////////
//
//  Detours Test Program (tryman.cpp of tryman.exe)
//
//  Microsoft Research Detours Package
//
//  Copyright (c) Microsoft Corporation.  All rights reserved.
//

#include <windows.h>

extern int WINAPI Test3264(int arg);

int __cdecl main(int argc, char ** argv)
{
    (void)argv;
    int ret = 0;

    ret = Test3264(argc);
    return ret == 0 ? ret : 0;
}
//
///////////////////////////////////////////////////////////////// End of File.

```

`samples/tryman/tstman.cpp`:

```cpp
//////////////////////////////////////////////////////////////////////////////
//
//  Detours Test Program (tstman.cpp of tstman.dll)
//
//  Microsoft Research Detours Package
//
//  Copyright (c) Microsoft Corporation.  All rights reserved.
//
//  This DLL doesn't detour any APIs, but it does enumerate the modules
//  loaded in a process and look at their size and processor target.
//

#include <stdio.h>
#include <windows.h>
#pragma warning(push)
#if _MSC_VER > 1400
#pragma warning(disable:6102 6103) // /analyze warnings
#endif
#include <strsafe.h>
#pragma warning(pop)
#include "detours.h"

static HMODULE s_hInst = NULL;
static CHAR s_szDllPath[MAX_PATH];

static int (WINAPI * TrueEntryPoint)(VOID) = NULL;
static int (WINAPI * RawEntryPoint)(VOID) = NULL;

BOOL (WINAPI * Real_CreateProcessA)(LPCSTR a0,
                                    LPSTR a1,
                                    LPSECURITY_ATTRIBUTES a2,
                                    LPSECURITY_ATTRIBUTES a3,
                                    BOOL a4,
                                    DWORD a5,
                                    LPVOID a6,
                                    LPCSTR a7,
                                    struct _STARTUPINFOA* a8,
                                    LPPROCESS_INFORMATION a9)
    = CreateProcessA;

BOOL (WINAPI * Real_CreateProcessW)(LPCWSTR a0,
                                    LPWSTR a1,
                                    LPSECURITY_ATTRIBUTES a2,
                                    LPSECURITY_ATTRIBUTES a3,
                                    BOOL a4,
                                    DWORD a5,
                                    LPVOID a6,
                                    LPCWSTR a7,
                                    struct _STARTUPINFOW* a8,
                                    LPPROCESS_INFORMATION a9)
    = CreateProcessW;


BOOL WINAPI Mine_CreateProcessA(LPCSTR lpApplicationName,
                                LPSTR lpCommandLine,
                                LPSECURITY_ATTRIBUTES lpProcessAttributes,
                                LPSECURITY_ATTRIBUTES lpThreadAttributes,
                                BOOL bInheritHandles,
                                DWORD dwCreationFlags,
                                LPVOID lpEnvironment,
                                LPCSTR lpCurrentDirectory,
                                LPSTARTUPINFOA lpStartupInfo,
                                LPPROCESS_INFORMATION lpProcessInformation)
{
    BOOL rv = 0;
    __try {
        rv = DetourCreateProcessWithDllExA(lpApplicationName,
                                           lpCommandLine,
                                           lpProcessAttributes,
                                           lpThreadAttributes,
                                           bInheritHandles,
                                           dwCreationFlags,
                                           lpEnvironment,
                                           lpCurrentDirectory,
                                           lpStartupInfo,
                                           lpProcessInformation,
                                           s_szDllPath,
                                           Real_CreateProcessA);
    } __finally {
    };
    return rv;
}

BOOL WINAPI Mine_CreateProcessW(LPCWSTR lpApplicationName,
                                LPWSTR lpCommandLine,
                                LPSECURITY_ATTRIBUTES lpProcessAttributes,
                                LPSECURITY_ATTRIBUTES lpThreadAttributes,
                                BOOL bInheritHandles,
                                DWORD dwCreationFlags,
                                LPVOID lpEnvironment,
                                LPCWSTR lpCurrentDirectory,
                                LPSTARTUPINFOW lpStartupInfo,
                                LPPROCESS_INFORMATION lpProcessInformation)
{
    BOOL rv = 0;
    __try {
        rv = DetourCreateProcessWithDllExW(lpApplicationName,
                                           lpCommandLine,
                                           lpProcessAttributes,
                                           lpThreadAttributes,
                                           bInheritHandles,
                                           dwCreationFlags,
                                           lpEnvironment,
                                           lpCurrentDirectory,
                                           lpStartupInfo,
                                           lpProcessInformation,
                                           s_szDllPath,
                                           Real_CreateProcessW);
    } __finally {
    };
    return rv;
}

void DumpModuleInfo(HMODULE hModule)
{
    PBYTE pbModule = (PBYTE)hModule;
    PIMAGE_DOS_HEADER pidh = (PIMAGE_DOS_HEADER)pbModule;
    PIMAGE_NT_HEADERS pinh = (PIMAGE_NT_HEADERS)(pbModule + pidh->e_lfanew);
    CHAR szFile[MAX_PATH] = "";

    GetModuleFileNameA(hModule, szFile, sizeof(szFile));

    CHAR szMagic[64];
    CHAR szMachine[64];
    CHAR szClr[64];

    PIMAGE_DATA_DIRECTORY pdir
        = (pinh->OptionalHeader.Magic == IMAGE_NT_OPTIONAL_HDR32_MAGIC)
        ? ((PIMAGE_NT_HEADERS32)pinh)->OptionalHeader.DataDirectory
        : ((PIMAGE_NT_HEADERS64)pinh)->OptionalHeader.DataDirectory;

    if (pdir[IMAGE_DIRECTORY_ENTRY_COM_DESCRIPTOR].VirtualAddress != 0 &&
        pdir[IMAGE_DIRECTORY_ENTRY_COM_DESCRIPTOR].Size != 0) {

        PDETOUR_CLR_HEADER pch
            = (PDETOUR_CLR_HEADER)
            (pbModule + pdir[IMAGE_DIRECTORY_ENTRY_COM_DESCRIPTOR].VirtualAddress);

        if ((pch->Flags & 0x3) == 0x0) {
            StringCchPrintfA(szClr, ARRAYSIZE(szClr), "clr   ");   // 32- or 64-bit.
        }
        else if ((pch->Flags & 0x3) == 0x1) {
            StringCchPrintfA(szClr, ARRAYSIZE(szClr), "clri  ");   // IL-Only, 32- or 64-bit.
        }
        else if ((pch->Flags & 0x3) == 0x2) {
            StringCchPrintfA(szClr, ARRAYSIZE(szClr), "clr32 ");   // must be 32-bit.
        }
        else if ((pch->Flags & 0x3) == 0x3) {
            StringCchPrintfA(szClr, ARRAYSIZE(szClr), "clr32i");   // IL-Only, must be 32-bit.
        }
    }
    else {
        StringCchPrintfA(szClr, ARRAYSIZE(szClr), "      ");
    }

    if (pinh->OptionalHeader.Magic == 0x10b) {
        StringCchPrintfA(szMagic, ARRAYSIZE(szMagic), "32");
    }
    else if (pinh->OptionalHeader.Magic == 0x20b) {
        StringCchPrintfA(szMagic, ARRAYSIZE(szMagic), "64");
    }
    else {
        StringCchPrintfA(szMagic, ARRAYSIZE(szMagic), "??");
    }

    if (pinh->FileHeader.Machine == 0x8664) {
        StringCchPrintfA(szMachine, ARRAYSIZE(szMachine), "x64", pinh->FileHeader.Machine);
    }
    else if (pinh->FileHeader.Machine == 0x014c) {
        StringCchPrintfA(szMachine, ARRAYSIZE(szMachine), "x86", pinh->FileHeader.Machine);
    }
    else if (pinh->FileHeader.Machine == 0x0200) {
        StringCchPrintfA(szMachine, ARRAYSIZE(szMachine), "i64", pinh->FileHeader.Machine);
    }
    else if (pinh->FileHeader.Machine == 0x01c0) {
        StringCchPrintfA(szMachine, ARRAYSIZE(szMachine), "arm", pinh->FileHeader.Machine);
    }
    else {
        StringCchPrintfA(szMachine, ARRAYSIZE(szMachine), "%04x", pinh->FileHeader.Machine);
        DWORD dwSize = DetourGetSizeOfPayloads(hModule);
        if (dwSize > 0) {
            StringCchPrintfA(szMachine, ARRAYSIZE(szMachine), "     ");
            StringCchPrintfA(szFile, ARRAYSIZE(szFile), "-- %d byte payload.", dwSize);
        }
    }

    printf("%16I64x: %s %s %s %s\n", (ULONG64)hModule, szMagic, szMachine, szClr, szFile);
}

void DumpMemory(PBYTE pbData, DWORD cbData)
{
    for (DWORD i = 0; i < cbData; i += 16) {
        printf("  %p:", pbData + i);
        for (DWORD j = 0; j < 16; j++) {
            if (i + j < cbData) {
                printf("%02x", pbData[i+j]);
            }
            else {
                printf("  ");
            }
        }
        printf(" ");
        for (DWORD j = 0; j < 16; j++) {
            if (i + j < cbData) {
                if ( pbData[i+j] >= ' ' && pbData[i+j] < 127) {
                    printf("%c", pbData[i+j]);
                }
                else {
                    printf(".");
                }
            }
            else {
                printf(" ");
            }
        }
        printf("\n");
    }
}

int WINAPI Test3264(int arg)
{
    return arg + 1;
}

int WINAPI TestEntryPoint(VOID)
{
#if DETOURS_64BIT
    printf("----------------: ");
#else
    printf("--------: ");
#endif

    printf("Calling EntryPoint() from detour.\n");
    fflush(stdout);

    return TrueEntryPoint();
}

BOOL WINAPI DllMain(HINSTANCE hinst, DWORD dwReason, LPVOID reserved)
{
    (void)hinst;
    (void)reserved;

    if (DetourIsHelperProcess()) {
        return TRUE;
    }

    if (dwReason == DLL_PROCESS_ATTACH) {
        DetourRestoreAfterWith();

        s_hInst = hinst;
        GetModuleFileNameA(s_hInst, s_szDllPath, ARRAYSIZE(s_szDllPath));

#if DETOURS_64BIT
        printf("----------------: ");
#else
        printf("--------: ");
#endif

        SYSTEM_INFO si;
        GetSystemInfo(&si);

        if (si.wProcessorArchitecture == 9) {
            printf("x64 Processor\n");
        }
        else if (si.wProcessorArchitecture == 0) {
            printf("x86 Processor\n");
        }
        else if (si.wProcessorArchitecture == 6) {
            printf("ia64 Processor\n");
        }
        else {
            printf("%04x Processor\n", si.wProcessorArchitecture);
        }

        HMODULE hSelf = GetModuleHandle(NULL);
        HMODULE hTest = (HMODULE)DetourGetContainingModule(DetourCodeFromPointer(Test3264, NULL));
        HMODULE hKern = (HMODULE)DetourGetContainingModule(DetourCodeFromPointer(CreateProcessW, NULL));

        DumpModuleInfo(hSelf);
        DumpModuleInfo(hTest);
        DumpModuleInfo(hKern);
        for (HINSTANCE hInst = NULL; (hInst = DetourEnumerateModules(hInst)) != NULL;) {
            if (hInst == hSelf || hInst == hTest || hInst == hKern) {
                continue;
            }

            DumpModuleInfo(hInst);
        }
        fflush(stdout);

        TrueEntryPoint = (int (WINAPI *)(VOID))DetourGetEntryPoint(NULL);
        RawEntryPoint = TrueEntryPoint;

        DetourTransactionBegin();
        DetourUpdateThread(GetCurrentThread());
        DetourAttach(&(PVOID&)TrueEntryPoint, TestEntryPoint);
        DetourAttach(&(PVOID&)Real_CreateProcessA, Mine_CreateProcessA);
        DetourAttach(&(PVOID&)Real_CreateProcessW, Mine_CreateProcessW);
        LONG error = DetourTransactionCommit();

#if DETOURS_64BIT
        printf("----------------: ");
#else
        printf("--------: ");
#endif

        if (error == NO_ERROR) {
            printf("Detoured EntryPoint().\n");
        }
        else {
            printf("Error detouring EntryPoint(): %ld (@ %p)\n", error, RawEntryPoint);
            __debugbreak();
        }
    }
    else if (dwReason == DLL_PROCESS_DETACH) {

        DetourTransactionBegin();
        DetourUpdateThread(GetCurrentThread());
        DetourDetach(&(PVOID&)TrueEntryPoint, TestEntryPoint);
        DetourDetach(&(PVOID&)Real_CreateProcessA, Mine_CreateProcessA);
        DetourDetach(&(PVOID&)Real_CreateProcessW, Mine_CreateProcessW);
        LONG error = DetourTransactionCommit();

        if (error != NO_ERROR) {
            printf("Error detach detours failed: %ld\n", error);
        }
    }

    return TRUE;
}

//
///////////////////////////////////////////////////////////////// End of File.

```

`samples/tryman/tstman.rc`:

```rc
//////////////////////////////////////////////////////////////////////////////
//
//  Version information for tstman.rc.
//
//  Microsoft Research Detours Package
//
//  Copyright (c) Microsoft Corporation.  All rights reserved.
//

#include "detver.h"

#define VER_INTERNALNAME_STR        "tstman" DETOURS_STRINGIFY(DETOURS_BITS)
#define VER_ORIGINALFILENAME_STR    "tstman" DETOURS_STRINGIFY(DETOURS_BITS) ".dll"
#define VER_FILEDESCRIPTION_STR     "Detours 32/64-bit Test Module"
#define VER_COMPANYNAME_STR         "Microsoft Corporation"

#include "common.ver"

```

`samples/withdll/Makefile`:

```
##############################################################################
##
##  Makefile for Detours Test Programs.
##
##  Microsoft Research Detours Package
##
##  Copyright (c) Microsoft Corporation.  All rights reserved.
##

!include ..\common.mak

LIBS=$(LIBS) kernel32.lib

##############################################################################

all: dirs \
    $(BIND)\withdll.exe \
!IF $(DETOURS_SOURCE_BROWSING)==1
    $(OBJD)\withdll.bsc \
!ENDIF
    option

clean:
    -del *~ 2>nul
    -del $(BIND)\withdll.* 2>nul
    -rmdir /q /s $(OBJD) 2>nul

realclean: clean
    -rmdir /q /s $(OBJDS) 2>nul

##############################################################################

dirs:
    @if not exist $(BIND) mkdir $(BIND) && echo.   Created $(BIND)
    @if not exist $(OBJD) mkdir $(OBJD) && echo.   Created $(OBJD)

$(OBJD)\withdll.obj : withdll.cpp

$(BIND)\withdll.exe : $(OBJD)\withdll.obj $(DEPS)
    cl $(CFLAGS) /Fe$@ /Fd$(@R).pdb $(OBJD)\withdll.obj \
        /link $(LINKFLAGS) $(LIBS) /subsystem:console

$(OBJD)\withdll.bsc : $(OBJD)\withdll.obj
    bscmake /v /n /o $@ $(OBJD)\withdll.sbr

############################################### Install non-bit-size binaries.

option:

##############################################################################

test: all
    $(BIND)\withdll.exe -d:$(BIND)\slept$(DETOURS_BITS).dll $(BIND)\sleepold.exe
    $(BIND)\withdll.exe -v -d:$(BIND)\slept$(DETOURS_BITS).dll $(BIND)\sleepold.exe

debug: all
    windbg  -c ".srcfix;l+s;l+t" -o \
        $(BIND)\withdll.exe -d:$(BIND)\slept$(DETOURS_BITS).dll $(BIND)\sleepold.exe

################################################################# End of File.

```

`samples/withdll/withdll.cpp`:

```cpp
//////////////////////////////////////////////////////////////////////////////
//
//  Test DetourCreateProcessWithDll function (withdll.cpp).
//
//  Microsoft Research Detours Package
//
//  Copyright (c) Microsoft Corporation.  All rights reserved.
//
#include <stdio.h>
#include <windows.h>
#include <detours.h>
#pragma warning(push)
#if _MSC_VER > 1400
#pragma warning(disable:6102 6103) // /analyze warnings
#endif
#include <strsafe.h>
#pragma warning(pop)

//////////////////////////////////////////////////////////////////////////////
//
void PrintUsage(void)
{
    printf("Usage:\n"
           "    withdll.exe [options] [command line]\n"
           "Options:\n"
           "    /d:file.dll   : Start the process with file.dll.\n"
           "    /v            : Verbose, display memory at start.\n"
           "    /?            : This help screen.\n");
}

//////////////////////////////////////////////////////////////////////////////
//
//  This code verifies that the named DLL has been configured correctly
//  to be imported into the target process.  DLLs must export a function with
//  ordinal #1 so that the import table touch-up magic works.
//
struct ExportContext
{
    BOOL    fHasOrdinal1;
    ULONG   nExports;
};

static BOOL CALLBACK ExportCallback(_In_opt_ PVOID pContext,
                                    _In_ ULONG nOrdinal,
                                    _In_opt_ LPCSTR pszSymbol,
                                    _In_opt_ PVOID pbTarget)
{
    (void)pContext;
    (void)pbTarget;
    (void)pszSymbol;

    ExportContext *pec = (ExportContext *)pContext;

    if (nOrdinal == 1) {
        pec->fHasOrdinal1 = TRUE;
    }
    pec->nExports++;

    return TRUE;
}

//////////////////////////////////////////////////////////////////////////////
//

//////////////////////////////////////////////////////////////////////////////
//

void TypeToString(DWORD Type, char *pszBuffer, size_t cBuffer)
{
    if (Type == MEM_IMAGE) {
        StringCchPrintfA(pszBuffer, cBuffer, "img");
    }
    else if (Type == MEM_MAPPED) {
        StringCchPrintfA(pszBuffer, cBuffer, "map");
    }
    else if (Type == MEM_PRIVATE) {
        StringCchPrintfA(pszBuffer, cBuffer, "pri");
    }
    else {
        StringCchPrintfA(pszBuffer, cBuffer, "%x", Type);
    }
}

void StateToString(DWORD State, char *pszBuffer, size_t cBuffer)
{
    if (State == MEM_COMMIT) {
        StringCchPrintfA(pszBuffer, cBuffer, "com");
    }
    else if (State == MEM_FREE) {
        StringCchPrintfA(pszBuffer, cBuffer, "fre");
    }
    else if (State == MEM_RESERVE) {
        StringCchPrintfA(pszBuffer, cBuffer, "res");
    }
    else {
        StringCchPrintfA(pszBuffer, cBuffer, "%x", State);
    }
}

void ProtectToString(DWORD Protect, char *pszBuffer, size_t cBuffer)
{
    if (Protect == 0) {
        StringCchPrintfA(pszBuffer, cBuffer, "");
    }
    else if (Protect == PAGE_EXECUTE) {
        StringCchPrintfA(pszBuffer, cBuffer, "--x");
    }
    else if (Protect == PAGE_EXECUTE_READ) {
        StringCchPrintfA(pszBuffer, cBuffer, "r-x");
    }
    else if (Protect == PAGE_EXECUTE_READWRITE) {
        StringCchPrintfA(pszBuffer, cBuffer, "rwx");
    }
    else if (Protect == PAGE_EXECUTE_WRITECOPY) {
        StringCchPrintfA(pszBuffer, cBuffer, "rcx");
    }
    else if (Protect == PAGE_NOACCESS) {
        StringCchPrintfA(pszBuffer, cBuffer, "---");
    }
    else if (Protect == PAGE_READONLY) {
        StringCchPrintfA(pszBuffer, cBuffer, "r--");
    }
    else if (Protect == PAGE_READWRITE) {
        StringCchPrintfA(pszBuffer, cBuffer, "rw-");
    }
    else if (Protect == PAGE_WRITECOPY) {
        StringCchPrintfA(pszBuffer, cBuffer, "rc-");
    }
    else if (Protect == (PAGE_GUARD | PAGE_EXECUTE)) {
        StringCchPrintfA(pszBuffer, cBuffer, "g--x");
    }
    else if (Protect == (PAGE_GUARD | PAGE_EXECUTE_READ)) {
        StringCchPrintfA(pszBuffer, cBuffer, "gr-x");
    }
    else if (Protect == (PAGE_GUARD | PAGE_EXECUTE_READWRITE)) {
        StringCchPrintfA(pszBuffer, cBuffer, "grwx");
    }
    else if (Protect == (PAGE_GUARD | PAGE_EXECUTE_WRITECOPY)) {
        StringCchPrintfA(pszBuffer, cBuffer, "grcx");
    }
    else if (Protect == (PAGE_GUARD | PAGE_NOACCESS)) {
        StringCchPrintfA(pszBuffer, cBuffer, "g---");
    }
    else if (Protect == (PAGE_GUARD | PAGE_READONLY)) {
        StringCchPrintfA(pszBuffer, cBuffer, "gr--");
    }
    else if (Protect == (PAGE_GUARD | PAGE_READWRITE)) {
        StringCchPrintfA(pszBuffer, cBuffer, "grw-");
    }
    else if (Protect == (PAGE_GUARD | PAGE_WRITECOPY)) {
        StringCchPrintfA(pszBuffer, cBuffer, "grc-");
    }
    else {
        StringCchPrintfA(pszBuffer, cBuffer, "%x", Protect);
    }
}

typedef union
{
    struct
    {
        DWORD Signature;
        IMAGE_FILE_HEADER FileHeader;
    } ih;

    IMAGE_NT_HEADERS32 ih32;
    IMAGE_NT_HEADERS64 ih64;
} IMAGE_NT_HEADER;

struct SECTIONS
{
    PBYTE   pbBeg;
    PBYTE   pbEnd;
    CHAR    szName[16];
} Sections[256];
DWORD SectionCount = 0;
DWORD Bitness = 0;

PCHAR FindSectionName(PBYTE pbBase, PBYTE& pbEnd)
{
    for (DWORD n = 0; n < SectionCount; n++) {
        if (Sections[n].pbBeg == pbBase) {
            pbEnd = Sections[n].pbEnd;
            return Sections[n].szName;
        }
    }
    pbEnd = NULL;
    return NULL;
}

ULONG PadToPage(ULONG Size)
{
    return (Size & 0xfff)
        ? Size + 0x1000 - (Size & 0xfff)
        : Size;
}

BOOL GetSections(HANDLE hp, PBYTE pbBase)
{
    DWORD beg = 0;
    DWORD cnt = 0;
    SIZE_T done;
    IMAGE_DOS_HEADER idh;

    if (!ReadProcessMemory(hp, pbBase, &idh, sizeof(idh), &done) || done != sizeof(idh)) {
        return FALSE;
    }

    if (idh.e_magic != IMAGE_DOS_SIGNATURE) {
        return FALSE;
    }

    IMAGE_NT_HEADER inh;
    if (!ReadProcessMemory(hp, pbBase + idh.e_lfanew, &inh, sizeof(inh), &done) || done != sizeof(inh)) {
        printf("No Read\n");
        return FALSE;
    }

    if (inh.ih.Signature != IMAGE_NT_SIGNATURE) {
        printf("No NT\n");
        return FALSE;
    }

    beg = idh.e_lfanew
        + FIELD_OFFSET( IMAGE_NT_HEADERS, OptionalHeader )
        + inh.ih.FileHeader.SizeOfOptionalHeader;
    cnt = inh.ih.FileHeader.NumberOfSections;
    Bitness = (inh.ih32.OptionalHeader.Magic == IMAGE_NT_OPTIONAL_HDR32_MAGIC) ? 32 : 64;
#if 0
    printf("%d %d count=%d\n", beg, Bitness, cnt);
#endif

    IMAGE_SECTION_HEADER ish;
    for (DWORD n = 0; n < cnt; n++) {
        if (!ReadProcessMemory(hp, pbBase + beg + n * sizeof(ish), &ish, sizeof(ish), &done) || done != sizeof(ish)) {
            printf("No Read\n");
            return FALSE;
        }
        Sections[n].pbBeg = pbBase + ish.VirtualAddress;
        Sections[n].pbEnd = pbBase + ish.VirtualAddress + PadToPage(ish.Misc.VirtualSize);
        memcpy(Sections[n].szName, ish.Name, sizeof(ish.Name));
        Sections[n].szName[sizeof(ish.Name)] = '\0';
#if 0
        printf("--- %p %s\n", Sections[n].pbBeg, Sections[n].szName);
#endif
    }
    SectionCount = cnt;

    return TRUE;
}

BOOL DumpProcess(HANDLE hp)
{
    ULONG64 base;
    ULONG64 next;

    MEMORY_BASIC_INFORMATION mbi;

    printf("  %12s %8s %8s: %3s %3s %4s %3s : %8s\n", "Address", "Offset", "Size", "Typ", "Sta", "Prot", "Ini", "Contents");
    printf("  %12s %8s %8s: %3s %3s %4s %3s : %8s\n", "------------", "--------", "--------", "---", "---", "----", "---", "-----------------");

    for (next = 0;;) {
        base = next;
        ZeroMemory(&mbi, sizeof(mbi));
        if (VirtualQueryEx(hp, (PVOID)base, &mbi, sizeof(mbi)) == 0) {
            break;
        }
        if ((mbi.RegionSize & 0xfff) == 0xfff) {
            break;
        }

        next = (ULONG64)mbi.BaseAddress + mbi.RegionSize;

        if (mbi.State == MEM_FREE) {
            continue;
        }

        CHAR szType[16];
        TypeToString(mbi.Type, szType, ARRAYSIZE(szType));
        CHAR szState[16];
        StateToString(mbi.State, szState, ARRAYSIZE(szState));
        CHAR szProtect[16];
        ProtectToString(mbi.Protect, szProtect, ARRAYSIZE(szProtect));
        CHAR szAllocProtect[16];
        ProtectToString(mbi.AllocationProtect, szAllocProtect, ARRAYSIZE(szAllocProtect));

        CHAR szFile[MAX_PATH];
        szFile[0] = '\0';
        DWORD cb = 0;
        PCHAR pszFile = szFile;

        if (base == (ULONG64)mbi.AllocationBase) {
#if 0
            cb = pfGetMappedFileName(hp, (PVOID)mbi.AllocationBase, szFile, ARRAYSIZE(szFile));
#endif
            if (GetSections(hp, (PBYTE)mbi.AllocationBase)) {
                next = base + 0x1000;
                StringCchPrintfA(szFile, ARRAYSIZE(szFile), "%d-bit PE", Bitness);
            }
        }
        if (cb > 0) {
            for (DWORD c = 0; c < cb; c++) {
                szFile[c] = (szFile[c] >= 'a' && szFile[c] <= 'z')
                    ? szFile[c] - 'a' + 'A' : szFile[c];
            }
            szFile[cb] = '\0';
        }

        if ((pszFile = strrchr(szFile, '\\')) == NULL) {
            pszFile = szFile;
        }
        else {
            pszFile++;
        }

        PBYTE pbEnd;
        PCHAR pszSect = FindSectionName((PBYTE)base, pbEnd);
        if (pszSect != NULL) {
            pszFile = pszSect;
            if (next > (ULONG64)pbEnd) {
                next = (ULONG64)pbEnd;
            }
        }

        CHAR szDesc[128];
        ZeroMemory(&szDesc, ARRAYSIZE(szDesc));
        if (base == (ULONG64)mbi.AllocationBase) {
            StringCchPrintfA(szDesc, ARRAYSIZE(szDesc), "  %12I64x %8I64x %8I64x: %3s %3s %4s %3s : %s",
                             (ULONG64)base,
                             (ULONG64)base - (ULONG64)mbi.AllocationBase,
                             (ULONG64)next - (ULONG64)base,
                             szType,
                             szState,
                             szProtect,
                             szAllocProtect,
                             pszFile);


        }
        else {
            StringCchPrintfA(szDesc, ARRAYSIZE(szDesc), "  %12s %8I64x %8I64x: %3s %3s %4s %3s : %s",
                             "-",
                             (ULONG64)base - (ULONG64)mbi.AllocationBase,
                             (ULONG64)next - (ULONG64)base,
                             szType,
                             szState,
                             szProtect,
                             szAllocProtect,
                             pszFile);
        }
        printf("%s\n", szDesc);
    }
    return TRUE;
}

//////////////////////////////////////////////////////////////////////// main.
//
int CDECL main(int argc, char **argv)
{
    BOOLEAN fNeedHelp = FALSE;
    BOOLEAN fVerbose = FALSE;
    LPCSTR rpszDllsRaw[256];
    LPCSTR rpszDllsOut[256];
    DWORD nDlls = 0;

    for (DWORD n = 0; n < ARRAYSIZE(rpszDllsRaw); n++) {
        rpszDllsRaw[n] = NULL;
        rpszDllsOut[n] = NULL;
    }

    int arg = 1;
    for (; arg < argc && (argv[arg][0] == '-' || argv[arg][0] == '/'); arg++) {

        CHAR *argn = argv[arg] + 1;
        CHAR *argp = argn;
        while (*argp && *argp != ':' && *argp != '=')
            argp++;
        if (*argp == ':' || *argp == '=')
            *argp++ = '\0';

        switch (argn[0]) {
          case 'd':                                     // Set DLL Name
          case 'D':
            if (nDlls < ARRAYSIZE(rpszDllsRaw)) {
                rpszDllsRaw[nDlls++] = argp;
            }
            else {
                printf("withdll.exe: Too many DLLs.\n");
                fNeedHelp = TRUE;
                break;
            }
            break;

          case 'v':                                     // Verbose
          case 'V':
            fVerbose = TRUE;
            break;

          case '?':                                     // Help
            fNeedHelp = TRUE;
            break;

          default:
            fNeedHelp = TRUE;
            printf("withdll.exe: Bad argument: %s\n", argv[arg]);
            break;
        }
    }

    if (arg >= argc) {
        fNeedHelp = TRUE;
    }

    if (nDlls == 0) {
        fNeedHelp = TRUE;
    }

    if (fNeedHelp) {
        PrintUsage();
        return 9001;
    }

    /////////////////////////////////////////////////////////// Validate DLLs.
    //
    for (DWORD n = 0; n < nDlls; n++) {
        CHAR szDllPath[1024];
        PCHAR pszFilePart = NULL;

        if (!GetFullPathNameA(rpszDllsRaw[n], ARRAYSIZE(szDllPath), szDllPath, &pszFilePart)) {
            printf("withdll.exe: Error: %s is not a valid path name..\n",
                   rpszDllsRaw[n]);
            return 9002;
        }

        DWORD c = (DWORD)strlen(szDllPath) + 1;
        PCHAR psz = new CHAR [c];
        StringCchCopyA(psz, c, szDllPath);
        rpszDllsOut[n] = psz;

        HMODULE hDll = LoadLibraryExA(rpszDllsOut[n], NULL, DONT_RESOLVE_DLL_REFERENCES);
        if (hDll == NULL) {
            printf("withdll.exe: Error: %s failed to load (error %ld).\n",
                   rpszDllsOut[n],
                   GetLastError());
            return 9003;
        }

        ExportContext ec;
        ec.fHasOrdinal1 = FALSE;
        ec.nExports = 0;
        DetourEnumerateExports(hDll, &ec, ExportCallback);
        FreeLibrary(hDll);

        if (!ec.fHasOrdinal1) {
            printf("withdll.exe: Error: %s does not export ordinal #1.\n",
                   rpszDllsOut[n]);
            printf("             See help entry DetourCreateProcessWithDllEx in Detours.chm.\n");
            return 9004;
        }
    }

    //////////////////////////////////////////////////////////////////////////
    STARTUPINFOA si;
    PROCESS_INFORMATION pi;
    CHAR szCommand[2048];
    CHAR szExe[1024];
    CHAR szFullExe[1024] = "\0";
    PCHAR pszFileExe = NULL;

    ZeroMemory(&si, sizeof(si));
    ZeroMemory(&pi, sizeof(pi));
    si.cb = sizeof(si);

    szCommand[0] = L'\0';

    StringCchCopyA(szExe, sizeof(szExe), argv[arg]);
    for (; arg < argc; arg++) {
        if (strchr(argv[arg], ' ') != NULL || strchr(argv[arg], '\t') != NULL) {
            StringCchCatA(szCommand, sizeof(szCommand), "\"");
            StringCchCatA(szCommand, sizeof(szCommand), argv[arg]);
            StringCchCatA(szCommand, sizeof(szCommand), "\"");
        }
        else {
            StringCchCatA(szCommand, sizeof(szCommand), argv[arg]);
        }

        if (arg + 1 < argc) {
            StringCchCatA(szCommand, sizeof(szCommand), " ");
        }
    }
    printf("withdll.exe: Starting: `%s'\n", szCommand);
    for (DWORD n = 0; n < nDlls; n++) {
        printf("withdll.exe:   with `%s'\n", rpszDllsOut[n]);
    }
    fflush(stdout);

    DWORD dwFlags = CREATE_DEFAULT_ERROR_MODE | CREATE_SUSPENDED;

    SetLastError(0);
    SearchPathA(NULL, szExe, ".exe", ARRAYSIZE(szFullExe), szFullExe, &pszFileExe);
    if (!DetourCreateProcessWithDllsA(szFullExe[0] ? szFullExe : NULL, szCommand,
                                     NULL, NULL, TRUE, dwFlags, NULL, NULL,
                                     &si, &pi, nDlls, rpszDllsOut, NULL)) {
        DWORD dwError = GetLastError();
        printf("withdll.exe: DetourCreateProcessWithDllEx failed: %ld\n", dwError);
        if (dwError == ERROR_INVALID_HANDLE) {
#if DETOURS_64BIT
            printf("withdll.exe: Can't detour a 32-bit target process from a 64-bit parent process.\n");
#else
            printf("withdll.exe: Can't detour a 64-bit target process from a 32-bit parent process.\n");
#endif
        }
        ExitProcess(9009);
    }

    if (fVerbose) {
        DumpProcess(pi.hProcess);
    }

    ResumeThread(pi.hThread);

    WaitForSingleObject(pi.hProcess, INFINITE);

    DWORD dwResult = 0;
    if (!GetExitCodeProcess(pi.hProcess, &dwResult)) {
        printf("withdll.exe: GetExitCodeProcess failed: %ld\n", GetLastError());
        return 9010;
    }

    for (DWORD n = 0; n < nDlls; n++) {
        if (rpszDllsOut[n] != NULL) {
            delete[] rpszDllsOut[n];
            rpszDllsOut[n] = NULL;
        }
    }

    return dwResult;
}
//
///////////////////////////////////////////////////////////////// End of File.

```

`src/Makefile`:

```
##############################################################################
##
##  Makefile for Detours.
##
##  Microsoft Research Detours Package, Version 4.0.1
##
##  Copyright (c) Microsoft Corporation.  All rights reserved.
##

ROOT = ..
!include "$(ROOT)\system.mak"

!IF "$(DETOURS_SOURCE_BROWSING)" == ""
DETOURS_SOURCE_BROWSING = 0
!ENDIF

#######################/#######################################################
##
CFLAGS=/nologo /W4 /WX /we4777 /we4800 /Zi /MT /Gy /Gm- /Zl /Od /DDETOUR_DEBUG=$(DETOURS_DEBUG)

!IF $(DETOURS_SOURCE_BROWSING)==1
CFLAGS=$(CFLAGS) /FR
!ELSE
CFLAGS=$(CFLAGS) /DWIN32_LEAN_AND_MEAN /D_WIN32_WINNT=0x501
!ENDIF

!IF "$(DETOURS_TARGET_PROCESSOR)" == "IA64"
CFLAGS=$(CFLAGS) /wd4163 # intrinsic rdtebex not available; using newer Windows headers with older compiler
!ENDIF

!if defined(DETOURS_WIN_7) && defined(DETOURS_CL_17_OR_NEWER)
CFLAGS=$(CFLAGS) /D_USING_V110_SDK71_
!elseif defined(DETOURS_ANALYZE)
CFLAGS=$(CFLAGS) /analyze
!endif

OBJS = \
    $(OBJD)\detours.obj     \
    $(OBJD)\modules.obj     \
    $(OBJD)\disasm.obj      \
    $(OBJD)\image.obj       \
    $(OBJD)\creatwth.obj    \
    $(OBJD)\disolx86.obj    \
    $(OBJD)\disolx64.obj    \
    $(OBJD)\disolia64.obj   \
    $(OBJD)\disolarm.obj    \
    $(OBJD)\disolarm64.obj  \

##############################################################################
##
.SUFFIXES: .cpp .h .obj

!ifdef DETOURS_ANALYZE
.cpp{$(OBJD)}.obj:
    $(CC) $(CFLAGS) /Fd$(LIBD)\detours.pdb /Fo$(OBJD)\ /c $<
!else
.cpp{$(OBJD)}.obj::
    $(CC) $(CFLAGS) /Fd$(LIBD)\detours.pdb /Fo$(OBJD)\ /c $<
!endif

##############################################################################

all: dirs \
    $(LIBD)\detours.lib \
    $(INCD)\detours.h   \
    $(INCD)\detver.h    \
!IF $(DETOURS_SOURCE_BROWSING)==1
    $(OBJD)\detours.bsc \
!endif

##############################################################################

clean:
    -del *~ 2>nul
    -del $(LIBD)\detours.pdb $(LIBD)\detours.lib 2>nul
    -rmdir /q /s $(OBJD) 2>nul

realclean: clean
    -rmdir /q /s $(OBJDS) 2>nul

##############################################################################

dirs:
    @if not exist "$(INCD)" mkdir "$(INCD)" && echo.   Created $(INCD)
    @if not exist "$(LIBD)" mkdir "$(LIBD)" && echo.   Created $(LIBD)
    @if not exist "$(BIND)" mkdir "$(BIND)" && echo.   Created $(BIND)
    @if not exist "$(OBJD)" mkdir "$(OBJD)" && echo.   Created $(OBJD)

$(OBJD)\detours.bsc : $(OBJS)
    bscmake /v /n /o $@ $(OBJS:.obj=.sbr)

$(LIBD)\detours.lib : $(OBJS)
    link /lib /out:$@ /nologo $(OBJS)

$(INCD)\detours.h : detours.h
    copy detours.h $@

$(INCD)\detver.h : detver.h
    copy detver.h $@

$(OBJD)\detours.obj : detours.cpp detours.h
$(OBJD)\modules.obj : modules.cpp detours.h
$(OBJD)\disasm.obj : disasm.cpp detours.h
$(OBJD)\image.obj : image.cpp detours.h
$(OBJD)\creatwth.obj : creatwth.cpp uimports.cpp detours.h
$(OBJD)\disolx86.obj: disasm.cpp detours.h
$(OBJD)\disolx64.obj: disasm.cpp detours.h
$(OBJD)\disolia64.obj: disasm.cpp detours.h
$(OBJD)\disolarm.obj: disasm.cpp detours.h
$(OBJD)\disolarm64.obj: disasm.cpp detours.h

test: all
    cd $(MAKEDIR)\..\samples\slept
    nmake /nologo test
    cd $(MAKEDIR)

################################################################# End of File.

```

`src/creatwth.cpp`:

```cpp
//////////////////////////////////////////////////////////////////////////////
//
//  Create a process with a DLL (creatwth.cpp of detours.lib)
//
//  Microsoft Research Detours Package, Version 4.0.1
//
//  Copyright (c) Microsoft Corporation.  All rights reserved.
//

// #define DETOUR_DEBUG 1
#define DETOURS_INTERNAL
#include "detours.h"
#include <stddef.h>

#if DETOURS_VERSION != 0x4c0c1   // 0xMAJORcMINORcPATCH
#error detours.h version mismatch
#endif

#define IMPORT_DIRECTORY OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_IMPORT]
#define BOUND_DIRECTORY OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_BOUND_IMPORT]
#define CLR_DIRECTORY OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_COM_DESCRIPTOR]
#define IAT_DIRECTORY OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_IAT]

//////////////////////////////////////////////////////////////////////////////
//
const GUID DETOUR_EXE_HELPER_GUID = { /* ea0251b9-5cde-41b5-98d0-2af4a26b0fee */
    0xea0251b9, 0x5cde, 0x41b5,
    { 0x98, 0xd0, 0x2a, 0xf4, 0xa2, 0x6b, 0x0f, 0xee }};

//////////////////////////////////////////////////////////////////////////////
//
// Enumerate through modules in the target process.
//
static PVOID LoadNtHeaderFromProcess(_In_ HANDLE hProcess,
                                     _In_ HMODULE hModule,
                                     _Out_ PIMAGE_NT_HEADERS32 pNtHeader)
{
    ZeroMemory(pNtHeader, sizeof(*pNtHeader));
    PBYTE pbModule = (PBYTE)hModule;

    if (pbModule == NULL) {
        SetLastError(ERROR_INVALID_PARAMETER);
        return NULL;
    }

    MEMORY_BASIC_INFORMATION mbi;
    ZeroMemory(&mbi, sizeof(mbi));

    if (VirtualQueryEx(hProcess, hModule, &mbi, sizeof(mbi)) == 0) {
        return NULL;
    }

    IMAGE_DOS_HEADER idh;
    if (!ReadProcessMemory(hProcess, pbModule, &idh, sizeof(idh), NULL)) {
        DETOUR_TRACE(("ReadProcessMemory(idh@%p..%p) failed: %lu\n",
                      pbModule, pbModule + sizeof(idh), GetLastError()));
        return NULL;
    }

    if (idh.e_magic != IMAGE_DOS_SIGNATURE ||
        (DWORD)idh.e_lfanew > mbi.RegionSize ||
        (DWORD)idh.e_lfanew < sizeof(idh)) {

        SetLastError(ERROR_BAD_EXE_FORMAT);
        return NULL;
    }

    if (!ReadProcessMemory(hProcess, pbModule + idh.e_lfanew,
                           pNtHeader, sizeof(*pNtHeader), NULL)) {
        DETOUR_TRACE(("ReadProcessMemory(inh@%p..%p:%p) failed: %lu\n",
                      pbModule + idh.e_lfanew,
                      pbModule + idh.e_lfanew + sizeof(*pNtHeader),
                      pbModule,
                      GetLastError()));
        return NULL;
    }

    if (pNtHeader->Signature != IMAGE_NT_SIGNATURE) {
        SetLastError(ERROR_BAD_EXE_FORMAT);
        return NULL;
    }

    return pbModule + idh.e_lfanew;
}

static HMODULE EnumerateModulesInProcess(_In_ HANDLE hProcess,
                                         _In_opt_ HMODULE hModuleLast,
                                         _Out_ PIMAGE_NT_HEADERS32 pNtHeader,
                                         _Out_opt_ PVOID *pRemoteNtHeader)
{
    ZeroMemory(pNtHeader, sizeof(*pNtHeader));
    if (pRemoteNtHeader) {
        *pRemoteNtHeader = NULL;
    }

    PBYTE pbLast = (PBYTE)hModuleLast + MM_ALLOCATION_GRANULARITY;

    MEMORY_BASIC_INFORMATION mbi;
    ZeroMemory(&mbi, sizeof(mbi));

    // Find the next memory region that contains a mapped PE image.
    //

    for (;; pbLast = (PBYTE)mbi.BaseAddress + mbi.RegionSize) {
        if (VirtualQueryEx(hProcess, (PVOID)pbLast, &mbi, sizeof(mbi)) == 0) {
            break;
        }

        // Usermode address space has such an unaligned region size always at the
        // end and only at the end.
        //
        if ((mbi.RegionSize & 0xfff) == 0xfff) {
            break;
        }
        if (((PBYTE)mbi.BaseAddress + mbi.RegionSize) < pbLast) {
            break;
        }

        // Skip uncommitted regions and guard pages.
        //
        if ((mbi.State != MEM_COMMIT) ||
            ((mbi.Protect & 0xff) == PAGE_NOACCESS) ||
            (mbi.Protect & PAGE_GUARD)) {
            continue;
        }

        PVOID remoteHeader
            = LoadNtHeaderFromProcess(hProcess, (HMODULE)pbLast, pNtHeader);
        if (remoteHeader) {
            if (pRemoteNtHeader) {
                *pRemoteNtHeader = remoteHeader;
            }

            return (HMODULE)pbLast;
        }
    }
    return NULL;
}

//////////////////////////////////////////////////////////////////////////////
//
// Find payloads in target process.
//

static PVOID FindDetourSectionInRemoteModule(_In_ HANDLE hProcess,
                                             _In_ HMODULE hModule,
                                             _In_ const IMAGE_NT_HEADERS32 *pNtHeader,
                                             _In_ PVOID pRemoteNtHeader)
{
    if (pNtHeader->FileHeader.SizeOfOptionalHeader == 0) {
        SetLastError(ERROR_EXE_MARKED_INVALID);
        return NULL;
    }

    PIMAGE_SECTION_HEADER pRemoteSectionHeaders
        = (PIMAGE_SECTION_HEADER)((PBYTE)pRemoteNtHeader
                                  + sizeof(pNtHeader->Signature)
                                  + sizeof(pNtHeader->FileHeader)
                                  + pNtHeader->FileHeader.SizeOfOptionalHeader);

    IMAGE_SECTION_HEADER header;
    for (DWORD n = 0; n < pNtHeader->FileHeader.NumberOfSections; ++n) {
        if (!ReadProcessMemory(hProcess, pRemoteSectionHeaders + n, &header, sizeof(header), NULL)) {
            DETOUR_TRACE(("ReadProcessMemory(ish@%p..%p) failed: %lu\n",
                pRemoteSectionHeaders + n,
                (PBYTE)(pRemoteSectionHeaders + n) + sizeof(header),
                GetLastError()));

            return NULL;
        }

        if (strcmp((PCHAR)header.Name, ".detour") == 0) {
            if (header.VirtualAddress == 0 ||
                header.SizeOfRawData == 0) {

                break;
            }

            SetLastError(NO_ERROR);
            return (PBYTE)hModule + header.VirtualAddress;
        }
    }

    SetLastError(ERROR_EXE_MARKED_INVALID);
    return NULL;
}

static PVOID FindPayloadInRemoteDetourSection(_In_ HANDLE hProcess,
                                               _In_ REFGUID rguid,
                                               _Out_opt_ DWORD *pcbData,
                                               _In_ PVOID pvRemoteDetoursSection)
{
    if (pcbData) {
        *pcbData = 0;
    }

    PBYTE pbData = (PBYTE)pvRemoteDetoursSection;

    DETOUR_SECTION_HEADER header;
    if (!ReadProcessMemory(hProcess, pbData, &header, sizeof(header), NULL)) {
        DETOUR_TRACE(("ReadProcessMemory(dsh@%p..%p) failed: %lu\n",
            pbData,
            pbData + sizeof(header),
            GetLastError()));
        return NULL;
    }

    if (header.cbHeaderSize < sizeof(DETOUR_SECTION_HEADER) ||
        header.nSignature != DETOUR_SECTION_HEADER_SIGNATURE) {
        SetLastError(ERROR_EXE_MARKED_INVALID);
        return NULL;
    }

    if (header.nDataOffset == 0) {
        header.nDataOffset = header.cbHeaderSize;
    }

    for (PVOID pvSection = pbData + header.nDataOffset; pvSection < pbData + header.cbDataSize;) {
        DETOUR_SECTION_RECORD section;
        if (!ReadProcessMemory(hProcess, pvSection, &section, sizeof(section), NULL)) {
            DETOUR_TRACE(("ReadProcessMemory(dsr@%p..%p) failed: %lu\n",
                pvSection,
                (PBYTE)pvSection + sizeof(section),
                GetLastError()));
            return NULL;
        }

        if (DetourAreSameGuid(section.guid, rguid)) {
            if (pcbData) {
                *pcbData = section.cbBytes - sizeof(section);
            }
            SetLastError(NO_ERROR);
            return (DETOUR_SECTION_RECORD *)pvSection + 1;
        }

        pvSection = (PBYTE)pvSection + section.cbBytes;
    }

    return NULL;
}

_Success_(return != NULL)
PVOID WINAPI DetourFindRemotePayload(_In_ HANDLE hProcess,
                                     _In_ REFGUID rguid,
                                     _Out_opt_ DWORD *pcbData)
{
    if (hProcess == NULL) {
        SetLastError(ERROR_INVALID_HANDLE);
        return NULL;
    }

    IMAGE_NT_HEADERS32 header;
    PVOID pvRemoteHeader;
    for (HMODULE hMod = NULL; (hMod = EnumerateModulesInProcess(hProcess, hMod, &header, &pvRemoteHeader)) != NULL;) {
        PVOID pvData = FindDetourSectionInRemoteModule(hProcess, hMod, &header, pvRemoteHeader);
        if (pvData != NULL) {
            pvData = FindPayloadInRemoteDetourSection(hProcess, rguid, pcbData, pvData);
            if (pvData != NULL) {
                return pvData;
            }
        }
    }

    SetLastError(ERROR_MOD_NOT_FOUND);
    return NULL;
}

//////////////////////////////////////////////////////////////////////////////
//
// Find a region of memory in which we can create a replacement import table.
//
static PBYTE FindAndAllocateNearBase(HANDLE hProcess, PBYTE pbModule, PBYTE pbBase, DWORD cbAlloc)
{
    MEMORY_BASIC_INFORMATION mbi;
    ZeroMemory(&mbi, sizeof(mbi));

    PBYTE pbLast = pbBase;
    for (;; pbLast = (PBYTE)mbi.BaseAddress + mbi.RegionSize) {

        ZeroMemory(&mbi, sizeof(mbi));
        if (VirtualQueryEx(hProcess, (PVOID)pbLast, &mbi, sizeof(mbi)) == 0) {
            if (GetLastError() == ERROR_INVALID_PARAMETER) {
                break;
            }
            DETOUR_TRACE(("VirtualQueryEx(%p) failed: %lu\n",
                          pbLast, GetLastError()));
            break;
        }
        // Usermode address space has such an unaligned region size always at the
        // end and only at the end.
        //
        if ((mbi.RegionSize & 0xfff) == 0xfff) {
            break;
        }

        // Skip anything other than a pure free region.
        //
        if (mbi.State != MEM_FREE) {
            continue;
        }

        // Use the max of mbi.BaseAddress and pbBase, in case mbi.BaseAddress < pbBase.
        PBYTE pbAddress = (PBYTE)mbi.BaseAddress > pbBase ? (PBYTE)mbi.BaseAddress : pbBase;

        // Round pbAddress up to the nearest MM allocation boundary.
        const DWORD_PTR mmGranularityMinusOne = (DWORD_PTR)(MM_ALLOCATION_GRANULARITY -1);
        pbAddress = (PBYTE)(((DWORD_PTR)pbAddress + mmGranularityMinusOne) & ~mmGranularityMinusOne);

#ifdef _WIN64
        // The offset from pbModule to any replacement import must fit into 32 bits.
        // For simplicity, we check that the offset to the last byte fits into 32 bits,
        // instead of the largest offset we'll actually use. The values are very similar.
        const size_t GB4 = ((((size_t)1) << 32) - 1);
        if ((size_t)(pbAddress + cbAlloc - 1 - pbModule) > GB4) {
            DETOUR_TRACE(("FindAndAllocateNearBase(1) failing due to distance >4GB %p\n", pbAddress));
            return NULL;
        }
#else
        UNREFERENCED_PARAMETER(pbModule);
#endif

        DETOUR_TRACE(("Free region %p..%p\n",
                      mbi.BaseAddress,
                      (PBYTE)mbi.BaseAddress + mbi.RegionSize));

        for (; pbAddress < (PBYTE)mbi.BaseAddress + mbi.RegionSize; pbAddress += MM_ALLOCATION_GRANULARITY) {
            PBYTE pbAlloc = (PBYTE)VirtualAllocEx(hProcess, pbAddress, cbAlloc,
                                                  MEM_RESERVE | MEM_COMMIT, PAGE_READWRITE);
            if (pbAlloc == NULL) {
                DETOUR_TRACE(("VirtualAllocEx(%p) failed: %lu\n", pbAddress, GetLastError()));
                continue;
            }
#ifdef _WIN64
            // The offset from pbModule to any replacement import must fit into 32 bits.
            if ((size_t)(pbAddress + cbAlloc - 1 - pbModule) > GB4) {
                DETOUR_TRACE(("FindAndAllocateNearBase(2) failing due to distance >4GB %p\n", pbAddress));
                return NULL;
            }
#endif
            DETOUR_TRACE(("[%p..%p] Allocated for import table.\n",
                          pbAlloc, pbAlloc + cbAlloc));
            return pbAlloc;
        }
    }
    return NULL;
}

static inline DWORD PadToDword(DWORD dw)
{
    return (dw + 3) & ~3u;
}

static inline DWORD PadToDwordPtr(DWORD dw)
{
    return (dw + 7) & ~7u;
}

static inline HRESULT ReplaceOptionalSizeA(_Inout_z_count_(cchDest) LPSTR pszDest,
                                           _In_ size_t cchDest,
                                           _In_z_ LPCSTR pszSize)
{
    if (cchDest == 0 || pszDest == NULL || pszSize == NULL ||
        pszSize[0] == '\0' || pszSize[1] == '\0' || pszSize[2] != '\0') {

        // can not write into empty buffer or with string other than two chars.
        return ERROR_INVALID_PARAMETER;
    }

    for (; cchDest >= 2; cchDest--, pszDest++) {
        if (pszDest[0] == '?' && pszDest[1] == '?') {
            pszDest[0] = pszSize[0];
            pszDest[1] = pszSize[1];
            break;
        }
    }

    return S_OK;
}

static BOOL RecordExeRestore(HANDLE hProcess, HMODULE hModule, DETOUR_EXE_RESTORE& der)
{
    // Save the various headers for DetourRestoreAfterWith.
    ZeroMemory(&der, sizeof(der));
    der.cb = sizeof(der);

    der.pidh = (PBYTE)hModule;
    der.cbidh = sizeof(der.idh);
    if (!ReadProcessMemory(hProcess, der.pidh, &der.idh, sizeof(der.idh), NULL)) {
        DETOUR_TRACE(("ReadProcessMemory(idh@%p..%p) failed: %lu\n",
                      der.pidh, der.pidh + der.cbidh, GetLastError()));
        return FALSE;
    }
    DETOUR_TRACE(("IDH: %p..%p\n", der.pidh, der.pidh + der.cbidh));

    // We read the NT header in two passes to get the full size.
    // First we read just the Signature and FileHeader.
    der.pinh = der.pidh + der.idh.e_lfanew;
    der.cbinh = FIELD_OFFSET(IMAGE_NT_HEADERS, OptionalHeader);
    if (!ReadProcessMemory(hProcess, der.pinh, &der.inh, der.cbinh, NULL)) {
        DETOUR_TRACE(("ReadProcessMemory(inh@%p..%p) failed: %lu\n",
                      der.pinh, der.pinh + der.cbinh, GetLastError()));
        return FALSE;
    }

    // Second we read the OptionalHeader and Section headers.
    der.cbinh = (FIELD_OFFSET(IMAGE_NT_HEADERS, OptionalHeader) +
                 der.inh.FileHeader.SizeOfOptionalHeader +
                 der.inh.FileHeader.NumberOfSections * sizeof(IMAGE_SECTION_HEADER));

    if (der.cbinh > sizeof(der.raw)) {
        return FALSE;
    }

    if (!ReadProcessMemory(hProcess, der.pinh, &der.inh, der.cbinh, NULL)) {
        DETOUR_TRACE(("ReadProcessMemory(inh@%p..%p) failed: %lu\n",
                      der.pinh, der.pinh + der.cbinh, GetLastError()));
        return FALSE;
    }
    DETOUR_TRACE(("INH: %p..%p\n", der.pinh, der.pinh + der.cbinh));

    // Third, we read the CLR header

    if (der.inh.OptionalHeader.Magic == IMAGE_NT_OPTIONAL_HDR32_MAGIC) {
        if (der.inh32.CLR_DIRECTORY.VirtualAddress != 0 &&
            der.inh32.CLR_DIRECTORY.Size != 0) {

            DETOUR_TRACE(("CLR32.VirtAddr=%08lx, CLR.Size=%lu\n",
                          der.inh32.CLR_DIRECTORY.VirtualAddress,
                          der.inh32.CLR_DIRECTORY.Size));

            der.pclr = ((PBYTE)hModule) + der.inh32.CLR_DIRECTORY.VirtualAddress;
        }
    }
    else if (der.inh.OptionalHeader.Magic == IMAGE_NT_OPTIONAL_HDR64_MAGIC) {
        if (der.inh64.CLR_DIRECTORY.VirtualAddress != 0 &&
            der.inh64.CLR_DIRECTORY.Size != 0) {

            DETOUR_TRACE(("CLR64.VirtAddr=%08lx, CLR.Size=%lu\n",
                          der.inh64.CLR_DIRECTORY.VirtualAddress,
                          der.inh64.CLR_DIRECTORY.Size));

            der.pclr = ((PBYTE)hModule) + der.inh64.CLR_DIRECTORY.VirtualAddress;
        }
    }

    if (der.pclr != 0) {
        der.cbclr = sizeof(der.clr);
        if (!ReadProcessMemory(hProcess, der.pclr, &der.clr, der.cbclr, NULL)) {
            DETOUR_TRACE(("ReadProcessMemory(clr@%p..%p) failed: %lu\n",
                          der.pclr, der.pclr + der.cbclr, GetLastError()));
            return FALSE;
        }
        DETOUR_TRACE(("CLR: %p..%p\n", der.pclr, der.pclr + der.cbclr));
    }

    return TRUE;
}

//////////////////////////////////////////////////////////////////////////////
//
#if DETOURS_32BIT
#define DWORD_XX                        DWORD32
#define IMAGE_NT_HEADERS_XX             IMAGE_NT_HEADERS32
#define IMAGE_NT_OPTIONAL_HDR_MAGIC_XX  IMAGE_NT_OPTIONAL_HDR32_MAGIC
#define IMAGE_ORDINAL_FLAG_XX           IMAGE_ORDINAL_FLAG32
#define IMAGE_THUNK_DATAXX              IMAGE_THUNK_DATA32
#define UPDATE_IMPORTS_XX               UpdateImports32
#define DETOURS_BITS_XX                 32
#include "uimports.cpp"
#undef DETOUR_EXE_RESTORE_FIELD_XX
#undef DWORD_XX
#undef IMAGE_NT_HEADERS_XX
#undef IMAGE_NT_OPTIONAL_HDR_MAGIC_XX
#undef IMAGE_ORDINAL_FLAG_XX
#undef UPDATE_IMPORTS_XX
#endif // DETOURS_32BIT

#if DETOURS_64BIT
#define DWORD_XX                        DWORD64
#define IMAGE_NT_HEADERS_XX             IMAGE_NT_HEADERS64
#define IMAGE_NT_OPTIONAL_HDR_MAGIC_XX  IMAGE_NT_OPTIONAL_HDR64_MAGIC
#define IMAGE_ORDINAL_FLAG_XX           IMAGE_ORDINAL_FLAG64
#define IMAGE_THUNK_DATAXX              IMAGE_THUNK_DATA64
#define UPDATE_IMPORTS_XX               UpdateImports64
#define DETOURS_BITS_XX                 64
#include "uimports.cpp"
#undef DETOUR_EXE_RESTORE_FIELD_XX
#undef DWORD_XX
#undef IMAGE_NT_HEADERS_XX
#undef IMAGE_NT_OPTIONAL_HDR_MAGIC_XX
#undef IMAGE_ORDINAL_FLAG_XX
#undef UPDATE_IMPORTS_XX
#endif // DETOURS_64BIT

//////////////////////////////////////////////////////////////////////////////
//
#if DETOURS_64BIT

C_ASSERT(sizeof(IMAGE_NT_HEADERS64) == sizeof(IMAGE_NT_HEADERS32) + 16);

static BOOL UpdateFrom32To64(HANDLE hProcess, HMODULE hModule, WORD machine,
                             DETOUR_EXE_RESTORE& der)
{
    IMAGE_DOS_HEADER idh;
    IMAGE_NT_HEADERS32 inh32;
    IMAGE_NT_HEADERS64 inh64;
    IMAGE_SECTION_HEADER sects[32];
    PBYTE pbModule = (PBYTE)hModule;
    DWORD n;

    ZeroMemory(&inh32, sizeof(inh32));
    ZeroMemory(&inh64, sizeof(inh64));
    ZeroMemory(sects, sizeof(sects));

    DETOUR_TRACE(("UpdateFrom32To64(%04x)\n", machine));
    //////////////////////////////////////////////////////// Read old headers.
    //
    if (!ReadProcessMemory(hProcess, pbModule, &idh, sizeof(idh), NULL)) {
        DETOUR_TRACE(("ReadProcessMemory(idh@%p..%p) failed: %lu\n",
                      pbModule, pbModule + sizeof(idh), GetLastError()));
        return FALSE;
    }
    DETOUR_TRACE(("ReadProcessMemory(idh@%p..%p)\n",
                  pbModule, pbModule + sizeof(idh)));

    PBYTE pnh = pbModule + idh.e_lfanew;
    if (!ReadProcessMemory(hProcess, pnh, &inh32, sizeof(inh32), NULL)) {
        DETOUR_TRACE(("ReadProcessMemory(inh@%p..%p) failed: %lu\n",
                      pnh, pnh + sizeof(inh32), GetLastError()));
        return FALSE;
    }
    DETOUR_TRACE(("ReadProcessMemory(inh@%p..%p)\n", pnh, pnh + sizeof(inh32)));

    if (inh32.FileHeader.NumberOfSections > (sizeof(sects)/sizeof(sects[0]))) {
        return FALSE;
    }

    PBYTE psects = pnh +
        FIELD_OFFSET(IMAGE_NT_HEADERS, OptionalHeader) +
        inh32.FileHeader.SizeOfOptionalHeader;
    ULONG cb = inh32.FileHeader.NumberOfSections * sizeof(IMAGE_SECTION_HEADER);
    if (!ReadProcessMemory(hProcess, psects, &sects, cb, NULL)) {
        DETOUR_TRACE(("ReadProcessMemory(ish@%p..%p) failed: %lu\n",
                      psects, psects + cb, GetLastError()));
        return FALSE;
    }
    DETOUR_TRACE(("ReadProcessMemory(ish@%p..%p)\n", psects, psects + cb));

    ////////////////////////////////////////////////////////// Convert header.
    //
    inh64.Signature = inh32.Signature;
    inh64.FileHeader = inh32.FileHeader;
    inh64.FileHeader.Machine = machine;
    inh64.FileHeader.SizeOfOptionalHeader = sizeof(IMAGE_OPTIONAL_HEADER64);

    inh64.OptionalHeader.Magic = IMAGE_NT_OPTIONAL_HDR64_MAGIC;
    inh64.OptionalHeader.MajorLinkerVersion = inh32.OptionalHeader.MajorLinkerVersion;
    inh64.OptionalHeader.MinorLinkerVersion = inh32.OptionalHeader.MinorLinkerVersion;
    inh64.OptionalHeader.SizeOfCode = inh32.OptionalHeader.SizeOfCode;
    inh64.OptionalHeader.SizeOfInitializedData = inh32.OptionalHeader.SizeOfInitializedData;
    inh64.OptionalHeader.SizeOfUninitializedData = inh32.OptionalHeader.SizeOfUninitializedData;
    inh64.OptionalHeader.AddressOfEntryPoint = inh32.OptionalHeader.AddressOfEntryPoint;
    inh64.OptionalHeader.BaseOfCode = inh32.OptionalHeader.BaseOfCode;
    inh64.OptionalHeader.ImageBase = inh32.OptionalHeader.ImageBase;
    inh64.OptionalHeader.SectionAlignment = inh32.OptionalHeader.SectionAlignment;
    inh64.OptionalHeader.FileAlignment = inh32.OptionalHeader.FileAlignment;
    inh64.OptionalHeader.MajorOperatingSystemVersion
        = inh32.OptionalHeader.MajorOperatingSystemVersion;
    inh64.OptionalHeader.MinorOperatingSystemVersion
        = inh32.OptionalHeader.MinorOperatingSystemVersion;
    inh64.OptionalHeader.MajorImageVersion = inh32.OptionalHeader.MajorImageVersion;
    inh64.OptionalHeader.MinorImageVersion = inh32.OptionalHeader.MinorImageVersion;
    inh64.OptionalHeader.MajorSubsystemVersion = inh32.OptionalHeader.MajorSubsystemVersion;
    inh64.OptionalHeader.MinorSubsystemVersion = inh32.OptionalHeader.MinorSubsystemVersion;
    inh64.OptionalHeader.Win32VersionValue = inh32.OptionalHeader.Win32VersionValue;
    inh64.OptionalHeader.SizeOfImage = inh32.OptionalHeader.SizeOfImage;
    inh64.OptionalHeader.SizeOfHeaders = inh32.OptionalHeader.SizeOfHeaders;
    inh64.OptionalHeader.CheckSum = inh32.OptionalHeader.CheckSum;
    inh64.OptionalHeader.Subsystem = inh32.OptionalHeader.Subsystem;
    inh64.OptionalHeader.DllCharacteristics = inh32.OptionalHeader.DllCharacteristics;
    inh64.OptionalHeader.SizeOfStackReserve = inh32.OptionalHeader.SizeOfStackReserve;
    inh64.OptionalHeader.SizeOfStackCommit = inh32.OptionalHeader.SizeOfStackCommit;
    inh64.OptionalHeader.SizeOfHeapReserve = inh32.OptionalHeader.SizeOfHeapReserve;
    inh64.OptionalHeader.SizeOfHeapCommit = inh32.OptionalHeader.SizeOfHeapCommit;
    inh64.OptionalHeader.LoaderFlags = inh32.OptionalHeader.LoaderFlags;
    inh64.OptionalHeader.NumberOfRvaAndSizes = inh32.OptionalHeader.NumberOfRvaAndSizes;
    for (n = 0; n < IMAGE_NUMBEROF_DIRECTORY_ENTRIES; n++) {
        inh64.OptionalHeader.DataDirectory[n] = inh32.OptionalHeader.DataDirectory[n];
    }

    /////////////////////////////////////////////////////// Write new headers.
    //
    DWORD dwProtect = 0;
    if (!DetourVirtualProtectSameExecuteEx(hProcess, pbModule, inh64.OptionalHeader.SizeOfHeaders,
                                           PAGE_EXECUTE_READWRITE, &dwProtect)) {
        return FALSE;
    }

    if (!WriteProcessMemory(hProcess, pnh, &inh64, sizeof(inh64), NULL)) {
        DETOUR_TRACE(("WriteProcessMemory(inh@%p..%p) failed: %lu\n",
                      pnh, pnh + sizeof(inh64), GetLastError()));
        return FALSE;
    }
    DETOUR_TRACE(("WriteProcessMemory(inh@%p..%p)\n", pnh, pnh + sizeof(inh64)));

    psects = pnh +
        FIELD_OFFSET(IMAGE_NT_HEADERS, OptionalHeader) +
        inh64.FileHeader.SizeOfOptionalHeader;
    cb = inh64.FileHeader.NumberOfSections * sizeof(IMAGE_SECTION_HEADER);
    if (!WriteProcessMemory(hProcess, psects, &sects, cb, NULL)) {
        DETOUR_TRACE(("WriteProcessMemory(ish@%p..%p) failed: %lu\n",
                      psects, psects + cb, GetLastError()));
        return FALSE;
    }
    DETOUR_TRACE(("WriteProcessMemory(ish@%p..%p)\n", psects, psects + cb));

    // Record the updated headers.
    if (!RecordExeRestore(hProcess, hModule, der)) {
        return FALSE;
    }

    // Remove the import table.
    if (der.pclr != NULL && (der.clr.Flags & COMIMAGE_FLAGS_ILONLY)) {
        inh64.IMPORT_DIRECTORY.VirtualAddress = 0;
        inh64.IMPORT_DIRECTORY.Size = 0;

        if (!WriteProcessMemory(hProcess, pnh, &inh64, sizeof(inh64), NULL)) {
            DETOUR_TRACE(("WriteProcessMemory(inh@%p..%p) failed: %lu\n",
                          pnh, pnh + sizeof(inh64), GetLastError()));
            return FALSE;
        }
    }

    DWORD dwOld = 0;
    if (!VirtualProtectEx(hProcess, pbModule, inh64.OptionalHeader.SizeOfHeaders,
                          dwProtect, &dwOld)) {
        return FALSE;
    }

    return TRUE;
}
#endif // DETOURS_64BIT

typedef BOOL(WINAPI *LPFN_ISWOW64PROCESS)(HANDLE, PBOOL);

static BOOL IsWow64ProcessHelper(HANDLE hProcess,
                                 PBOOL Wow64Process)
{
#ifdef _X86_
    if (Wow64Process == NULL) {
        return FALSE;
    }

    // IsWow64Process is not available on all supported versions of Windows.
    //
    HMODULE hKernel32 = LoadLibraryW(L"KERNEL32.DLL");
    if (hKernel32 == NULL) {
        DETOUR_TRACE(("LoadLibraryW failed: %lu\n", GetLastError()));
        return FALSE;
    }

    LPFN_ISWOW64PROCESS pfnIsWow64Process = (LPFN_ISWOW64PROCESS)GetProcAddress(
        hKernel32, "IsWow64Process");

    if (pfnIsWow64Process == NULL) {
        DETOUR_TRACE(("GetProcAddress failed: %lu\n", GetLastError()));
        return FALSE;
    }
    return pfnIsWow64Process(hProcess, Wow64Process);
#else
    return IsWow64Process(hProcess, Wow64Process);
#endif
}

//////////////////////////////////////////////////////////////////////////////
//
BOOL WINAPI DetourUpdateProcessWithDll(_In_ HANDLE hProcess,
                                       _In_reads_(nDlls) LPCSTR *rlpDlls,
                                       _In_ DWORD nDlls)
{
    // Find the next memory region that contains a mapped PE image.
    //
    BOOL bIs32BitProcess;
    BOOL bIs64BitOS = FALSE;
    HMODULE hModule = NULL;
    HMODULE hLast = NULL;

    DETOUR_TRACE(("DetourUpdateProcessWithDll(%p,dlls=%lu)\n", hProcess, nDlls));

    for (;;) {
        IMAGE_NT_HEADERS32 inh;

        if ((hLast = EnumerateModulesInProcess(hProcess, hLast, &inh, NULL)) == NULL) {
            break;
        }

        DETOUR_TRACE(("%p  machine=%04x magic=%04x\n",
                      hLast, inh.FileHeader.Machine, inh.OptionalHeader.Magic));

        if ((inh.FileHeader.Characteristics & IMAGE_FILE_DLL) == 0) {
            hModule = hLast;
            DETOUR_TRACE(("%p  Found EXE\n", hLast));
        }
    }

    if (hModule == NULL) {
        SetLastError(ERROR_INVALID_OPERATION);
        return FALSE;
    }

    // Determine if the target process is 32bit or 64bit. This is a two-stop process:
    //
    // 1. First, determine if we're running on a 64bit operating system.
    //   - If we're running 64bit code (i.e. _WIN64 is defined), this is trivially true.
    //   - If we're running 32bit code (i.e. _WIN64 is not defined), test if
    //   we're running under Wow64. If so, it implies that the operating system
    //   is 64bit.
    //
#ifdef _WIN64
    bIs64BitOS = TRUE;
#else
    if (!IsWow64ProcessHelper(GetCurrentProcess(), &bIs64BitOS)) {
        return FALSE;
    }
#endif

    // 2. With the operating system bitness known, we can now consider the target process:
    //   - If we're running on a 64bit OS, the target process is 32bit in case
    //   it is running under Wow64. Otherwise, it's 64bit, running natively
    //   (without Wow64).
    //   - If we're running on a 32bit OS, the target process must be 32bit, too.
    //
    if (bIs64BitOS) {
        if (!IsWow64ProcessHelper(hProcess, &bIs32BitProcess)) {
            return FALSE;
        }
    } else {
        bIs32BitProcess = TRUE;
    }

    DETOUR_TRACE(("    32BitProcess=%d\n", bIs32BitProcess));

    return DetourUpdateProcessWithDllEx(hProcess,
                                        hModule,
                                        bIs32BitProcess,
                                        rlpDlls,
                                        nDlls);
}

BOOL WINAPI DetourUpdateProcessWithDllEx(_In_ HANDLE hProcess,
                                         _In_ HMODULE hModule,
                                         _In_ BOOL bIs32BitProcess,
                                         _In_reads_(nDlls) LPCSTR *rlpDlls,
                                         _In_ DWORD nDlls)
{
    // Find the next memory region that contains a mapped PE image.
    //
    BOOL bIs32BitExe = FALSE;

    DETOUR_TRACE(("DetourUpdateProcessWithDllEx(%p,%p,dlls=%lu)\n", hProcess, hModule, nDlls));

    IMAGE_NT_HEADERS32 inh;

    if (hModule == NULL || !LoadNtHeaderFromProcess(hProcess, hModule, &inh)) {
        SetLastError(ERROR_INVALID_OPERATION);
        return FALSE;
    }

    if (inh.OptionalHeader.Magic == IMAGE_NT_OPTIONAL_HDR32_MAGIC
        && inh.FileHeader.Machine != 0) {

        bIs32BitExe = TRUE;
    }

    DETOUR_TRACE(("    32BitExe=%d\n", bIs32BitExe));

    if (hModule == NULL) {
        SetLastError(ERROR_INVALID_OPERATION);
        return FALSE;
    }

    // Save the various headers for DetourRestoreAfterWith.
    //
    DETOUR_EXE_RESTORE der;

    if (!RecordExeRestore(hProcess, hModule, der)) {
        return FALSE;
    }

#if defined(DETOURS_64BIT)
    // Try to convert a neutral 32-bit managed binary to a 64-bit managed binary.
    if (bIs32BitExe && !bIs32BitProcess) {
        if (!der.pclr                       // Native binary
            || (der.clr.Flags & COMIMAGE_FLAGS_ILONLY) == 0     // Or mixed-mode MSIL
            || (der.clr.Flags & COMIMAGE_FLAGS_32BITREQUIRED) != 0) {  // Or 32BIT Required MSIL

            SetLastError(ERROR_INVALID_HANDLE);
            return FALSE;
        }

        if (!UpdateFrom32To64(hProcess, hModule,
#if defined(DETOURS_X64)
                              IMAGE_FILE_MACHINE_AMD64,
#elif defined(DETOURS_IA64)
                              IMAGE_FILE_MACHINE_IA64,
#elif defined(DETOURS_ARM64)
                              IMAGE_FILE_MACHINE_ARM64,
#else
#error Must define one of DETOURS_X64 or DETOURS_IA64 or DETOURS_ARM64 on 64-bit.
#endif
                              der)) {
            return FALSE;
        }
        bIs32BitExe = FALSE;
    }
#endif // DETOURS_64BIT

    // Now decide if we can insert the detour.

#if defined(DETOURS_32BIT)
    if (bIs32BitProcess) {
        // 32-bit native or 32-bit managed process on any platform.
        if (!UpdateImports32(hProcess, hModule, rlpDlls, nDlls)) {
            return FALSE;
        }
    }
    else {
        // 64-bit native or 64-bit managed process.
        //
        // Can't detour a 64-bit process with 32-bit code.
        // Note: This happens for 32-bit PE binaries containing only
        // manage code that have been marked as 64-bit ready.
        //
        SetLastError(ERROR_INVALID_HANDLE);
        return FALSE;
    }
#elif defined(DETOURS_64BIT)
    if (bIs32BitProcess || bIs32BitExe) {
        // Can't detour a 32-bit process with 64-bit code.
        SetLastError(ERROR_INVALID_HANDLE);
        return FALSE;
    }
    else {
        // 64-bit native or 64-bit managed process on any platform.
        if (!UpdateImports64(hProcess, hModule, rlpDlls, nDlls)) {
            return FALSE;
        }
    }
#else
#pragma Must define one of DETOURS_32BIT or DETOURS_64BIT.
#endif // DETOURS_64BIT

    /////////////////////////////////////////////////// Update the CLR header.
    //
    if (der.pclr != NULL) {
        DETOUR_CLR_HEADER clr;
        CopyMemory(&clr, &der.clr, sizeof(clr));
        clr.Flags &= ~COMIMAGE_FLAGS_ILONLY;    // Clear the IL_ONLY flag.

        DWORD dwProtect;
        if (!DetourVirtualProtectSameExecuteEx(hProcess, der.pclr, sizeof(clr), PAGE_READWRITE, &dwProtect)) {
            DETOUR_TRACE(("VirtualProtectEx(clr) write failed: %lu\n", GetLastError()));
            return FALSE;
        }

        if (!WriteProcessMemory(hProcess, der.pclr, &clr, sizeof(clr), NULL)) {
            DETOUR_TRACE(("WriteProcessMemory(clr) failed: %lu\n", GetLastError()));
            return FALSE;
        }

        if (!VirtualProtectEx(hProcess, der.pclr, sizeof(clr), dwProtect, &dwProtect)) {
            DETOUR_TRACE(("VirtualProtectEx(clr) restore failed: %lu\n", GetLastError()));
            return FALSE;
        }
        DETOUR_TRACE(("CLR: %p..%p\n", der.pclr, der.pclr + der.cbclr));

#if DETOURS_64BIT
        if (der.clr.Flags & COMIMAGE_FLAGS_32BITREQUIRED) { // Is the 32BIT Required Flag set?
            // X64 never gets here because the process appears as a WOW64 process.
            // However, on IA64, it doesn't appear to be a WOW process.
            DETOUR_TRACE(("CLR Requires 32-bit\n"));
            SetLastError(ERROR_INVALID_HANDLE);
            return FALSE;
        }
#endif // DETOURS_64BIT
    }

    //////////////////////////////// Save the undo data to the target process.
    //
    if (!DetourCopyPayloadToProcess(hProcess, DETOUR_EXE_RESTORE_GUID, &der, sizeof(der))) {
        DETOUR_TRACE(("DetourCopyPayloadToProcess failed: %lu\n", GetLastError()));
        return FALSE;
    }
    return TRUE;
}

//////////////////////////////////////////////////////////////////////////////
//
BOOL WINAPI DetourCreateProcessWithDllA(_In_opt_ LPCSTR lpApplicationName,
                                        _Inout_opt_ LPSTR lpCommandLine,
                                        _In_opt_ LPSECURITY_ATTRIBUTES lpProcessAttributes,
                                        _In_opt_ LPSECURITY_ATTRIBUTES lpThreadAttributes,
                                        _In_ BOOL bInheritHandles,
                                        _In_ DWORD dwCreationFlags,
                                        _In_opt_ LPVOID lpEnvironment,
                                        _In_opt_ LPCSTR lpCurrentDirectory,
                                        _In_ LPSTARTUPINFOA lpStartupInfo,
                                        _Out_ LPPROCESS_INFORMATION lpProcessInformation,
                                        _In_ LPCSTR lpDllName,
                                        _In_opt_ PDETOUR_CREATE_PROCESS_ROUTINEA pfCreateProcessA)
{
    DWORD dwMyCreationFlags = (dwCreationFlags | CREATE_SUSPENDED);
    PROCESS_INFORMATION pi;
    BOOL fResult = FALSE;

    if (pfCreateProcessA == NULL) {
        pfCreateProcessA = CreateProcessA;
    }

    fResult = pfCreateProcessA(lpApplicationName,
                               lpCommandLine,
                               lpProcessAttributes,
                               lpThreadAttributes,
                               bInheritHandles,
                               dwMyCreationFlags,
                               lpEnvironment,
                               lpCurrentDirectory,
                               lpStartupInfo,
                               &pi);

    if (lpProcessInformation != NULL) {
        CopyMemory(lpProcessInformation, &pi, sizeof(pi));
    }

    if (!fResult) {
        return FALSE;
    }

    LPCSTR rlpDlls[2];
    DWORD nDlls = 0;
    if (lpDllName != NULL) {
        rlpDlls[nDlls++] = lpDllName;
    }

    if (!DetourUpdateProcessWithDll(pi.hProcess, rlpDlls, nDlls)) {
        TerminateProcess(pi.hProcess, ~0u);
        return FALSE;
    }

    if (!(dwCreationFlags & CREATE_SUSPENDED)) {
        ResumeThread(pi.hThread);
    }
    return TRUE;
}


BOOL WINAPI DetourCreateProcessWithDllW(_In_opt_ LPCWSTR lpApplicationName,
                                        _Inout_opt_ LPWSTR lpCommandLine,
                                        _In_opt_ LPSECURITY_ATTRIBUTES lpProcessAttributes,
                                        _In_opt_ LPSECURITY_ATTRIBUTES lpThreadAttributes,
                                        _In_ BOOL bInheritHandles,
                                        _In_ DWORD dwCreationFlags,
                                        _In_opt_ LPVOID lpEnvironment,
                                        _In_opt_ LPCWSTR lpCurrentDirectory,
                                        _In_ LPSTARTUPINFOW lpStartupInfo,
                                        _Out_ LPPROCESS_INFORMATION lpProcessInformation,
                                        _In_ LPCSTR lpDllName,
                                        _In_opt_ PDETOUR_CREATE_PROCESS_ROUTINEW pfCreateProcessW)
{
    DWORD dwMyCreationFlags = (dwCreationFlags | CREATE_SUSPENDED);
    PROCESS_INFORMATION pi;

    if (pfCreateProcessW == NULL) {
        pfCreateProcessW = CreateProcessW;
    }

    BOOL fResult = pfCreateProcessW(lpApplicationName,
                                    lpCommandLine,
                                    lpProcessAttributes,
                                    lpThreadAttributes,
                                    bInheritHandles,
                                    dwMyCreationFlags,
                                    lpEnvironment,
                                    lpCurrentDirectory,
                                    lpStartupInfo,
                                    &pi);

    if (lpProcessInformation) {
        CopyMemory(lpProcessInformation, &pi, sizeof(pi));
    }

    if (!fResult) {
        return FALSE;
    }

    LPCSTR rlpDlls[2];
    DWORD nDlls = 0;
    if (lpDllName != NULL) {
        rlpDlls[nDlls++] = lpDllName;
    }

    if (!DetourUpdateProcessWithDll(pi.hProcess, rlpDlls, nDlls)) {
        TerminateProcess(pi.hProcess, ~0u);
        return FALSE;
    }

    if (!(dwCreationFlags & CREATE_SUSPENDED)) {
        ResumeThread(pi.hThread);
    }
    return TRUE;
}

BOOL WINAPI DetourCopyPayloadToProcess(_In_ HANDLE hProcess,
                                       _In_ REFGUID rguid,
                                       _In_reads_bytes_(cbData) LPCVOID pvData,
                                       _In_ DWORD cbData)
{
    return DetourCopyPayloadToProcessEx(hProcess, rguid, pvData, cbData) != NULL;
}

_Success_(return != NULL)
PVOID WINAPI DetourCopyPayloadToProcessEx(_In_ HANDLE hProcess,
                                          _In_ REFGUID rguid,
                                          _In_reads_bytes_(cbData) LPCVOID pvData,
                                          _In_ DWORD cbData)
{
    if (hProcess == NULL) {
        SetLastError(ERROR_INVALID_HANDLE);
        return NULL;
    }

    DWORD cbTotal = (sizeof(IMAGE_DOS_HEADER) +
                     sizeof(IMAGE_NT_HEADERS) +
                     sizeof(IMAGE_SECTION_HEADER) +
                     sizeof(DETOUR_SECTION_HEADER) +
                     sizeof(DETOUR_SECTION_RECORD) +
                     cbData);

    PBYTE pbBase = (PBYTE)VirtualAllocEx(hProcess, NULL, cbTotal,
                                         MEM_COMMIT, PAGE_READWRITE);
    if (pbBase == NULL) {
        DETOUR_TRACE(("VirtualAllocEx(%lu) failed: %lu\n", cbTotal, GetLastError()));
        return NULL;
    }

    // As you can see in the following code,
    // the memory layout of the payload range "[pbBase, pbBase+cbTotal]" is a PE executable file,
    // so DetourFreePayload can use "DetourGetContainingModule(Payload pointer)" to get the above "pbBase" pointer,
    // pbBase: the memory block allocated by VirtualAllocEx will be released in DetourFreePayload by VirtualFree.

    PBYTE pbTarget = pbBase;
    IMAGE_DOS_HEADER idh;
    IMAGE_NT_HEADERS inh;
    IMAGE_SECTION_HEADER ish;
    DETOUR_SECTION_HEADER dsh;
    DETOUR_SECTION_RECORD dsr;
    SIZE_T cbWrote = 0;

    ZeroMemory(&idh, sizeof(idh));
    idh.e_magic = IMAGE_DOS_SIGNATURE;
    idh.e_lfanew = sizeof(idh);
    if (!WriteProcessMemory(hProcess, pbTarget, &idh, sizeof(idh), &cbWrote) ||
        cbWrote != sizeof(idh)) {
        DETOUR_TRACE(("WriteProcessMemory(idh) failed: %lu\n", GetLastError()));
        return NULL;
    }
    pbTarget += sizeof(idh);

    ZeroMemory(&inh, sizeof(inh));
    inh.Signature = IMAGE_NT_SIGNATURE;
    inh.FileHeader.SizeOfOptionalHeader = sizeof(inh.OptionalHeader);
    inh.FileHeader.Characteristics = IMAGE_FILE_DLL;
    inh.FileHeader.NumberOfSections = 1;
    inh.OptionalHeader.Magic = IMAGE_NT_OPTIONAL_HDR_MAGIC;
    if (!WriteProcessMemory(hProcess, pbTarget, &inh, sizeof(inh), &cbWrote) ||
        cbWrote != sizeof(inh)) {
        return NULL;
    }
    pbTarget += sizeof(inh);

    ZeroMemory(&ish, sizeof(ish));
    memcpy(ish.Name, ".detour", sizeof(ish.Name));
    ish.VirtualAddress = (DWORD)((pbTarget + sizeof(ish)) - pbBase);
    ish.SizeOfRawData = (sizeof(DETOUR_SECTION_HEADER) +
                         sizeof(DETOUR_SECTION_RECORD) +
                         cbData);
    if (!WriteProcessMemory(hProcess, pbTarget, &ish, sizeof(ish), &cbWrote) ||
        cbWrote != sizeof(ish)) {
        return NULL;
    }
    pbTarget += sizeof(ish);

    ZeroMemory(&dsh, sizeof(dsh));
    dsh.cbHeaderSize = sizeof(dsh);
    dsh.nSignature = DETOUR_SECTION_HEADER_SIGNATURE;
    dsh.nDataOffset = sizeof(DETOUR_SECTION_HEADER);
    dsh.cbDataSize = (sizeof(DETOUR_SECTION_HEADER) +
                      sizeof(DETOUR_SECTION_RECORD) +
                      cbData);
    if (!WriteProcessMemory(hProcess, pbTarget, &dsh, sizeof(dsh), &cbWrote) ||
        cbWrote != sizeof(dsh)) {
        return NULL;
    }
    pbTarget += sizeof(dsh);

    ZeroMemory(&dsr, sizeof(dsr));
    dsr.cbBytes = cbData + sizeof(DETOUR_SECTION_RECORD);
    dsr.nReserved = 0;
    dsr.guid = rguid;
    if (!WriteProcessMemory(hProcess, pbTarget, &dsr, sizeof(dsr), &cbWrote) ||
        cbWrote != sizeof(dsr)) {
        return NULL;
    }
    pbTarget += sizeof(dsr);

    if (!WriteProcessMemory(hProcess, pbTarget, pvData, cbData, &cbWrote) ||
        cbWrote != cbData) {
        return NULL;
    }

    DETOUR_TRACE(("Copied %lu byte payload into target process at %p\n",
                  cbData, pbTarget));
    
    SetLastError(NO_ERROR);
    return pbTarget;
}

static BOOL s_fSearchedForHelper = FALSE;
static PDETOUR_EXE_HELPER s_pHelper = NULL;

VOID CALLBACK DetourFinishHelperProcess(_In_ HWND,
                                        _In_ HINSTANCE,
                                        _In_ LPSTR,
                                        _In_ INT)
{
    LPCSTR * rlpDlls = NULL;
    DWORD Result = 9900;
    DWORD cOffset = 0;
    DWORD cSize = 0;
    HANDLE hProcess = NULL;

    if (s_pHelper == NULL) {
        DETOUR_TRACE(("DetourFinishHelperProcess called with s_pHelper = NULL.\n"));
        Result = 9905;
        goto Cleanup;
    }

    hProcess = OpenProcess(PROCESS_ALL_ACCESS, FALSE, s_pHelper->pid);
    if (hProcess == NULL) {
        DETOUR_TRACE(("OpenProcess(pid=%lu) failed: %lu\n",
                      s_pHelper->pid, GetLastError()));
        Result = 9901;
        goto Cleanup;
    }

    rlpDlls = new NOTHROW LPCSTR [s_pHelper->nDlls];
    cSize = s_pHelper->cb - sizeof(DETOUR_EXE_HELPER);
    for (DWORD n = 0; n < s_pHelper->nDlls; n++) {
        size_t cchDest = 0;
        HRESULT hr = StringCchLengthA(&s_pHelper->rDlls[cOffset], cSize - cOffset, &cchDest);
        if (!SUCCEEDED(hr)) {
            Result = 9902;
            goto Cleanup;
        }

        rlpDlls[n] = &s_pHelper->rDlls[cOffset];
        cOffset += (DWORD)cchDest + 1;
    }

    if (!DetourUpdateProcessWithDll(hProcess, rlpDlls, s_pHelper->nDlls)) {
        DETOUR_TRACE(("DetourUpdateProcessWithDll(pid=%lu) failed: %lu\n",
                      s_pHelper->pid, GetLastError()));
        Result = 9903;
        goto Cleanup;
    }
    Result = 0;

  Cleanup:
    if (rlpDlls != NULL) {
        delete[] rlpDlls;
        rlpDlls = NULL;
    }

    // Note: s_pHelper is allocated as part of injecting the payload in DetourCopyPayloadToProcess(..),
    // it's a fake section and not data allocated by the system PE loader.

    // Delete the payload after execution to release the memory occupied by it
    if (s_pHelper != NULL) {
        DetourFreePayload(s_pHelper);
        s_pHelper = NULL;
    }

    ExitProcess(Result);
}

BOOL WINAPI DetourIsHelperProcess(VOID)
{
    PVOID pvData;
    DWORD cbData;

    if (s_fSearchedForHelper) {
        return (s_pHelper != NULL);
    }

    s_fSearchedForHelper = TRUE;
    pvData = DetourFindPayloadEx(DETOUR_EXE_HELPER_GUID, &cbData);

    if (pvData == NULL || cbData < sizeof(DETOUR_EXE_HELPER)) {
        return FALSE;
    }

    s_pHelper = (PDETOUR_EXE_HELPER)pvData;
    if (s_pHelper->cb < sizeof(*s_pHelper)) {
        s_pHelper = NULL;
        return FALSE;
    }

    return TRUE;
}

static
BOOL WINAPI AllocExeHelper(_Out_ PDETOUR_EXE_HELPER *pHelper,
                           _In_ DWORD dwTargetPid,
                           _In_ DWORD nDlls,
                           _In_reads_(nDlls) LPCSTR *rlpDlls)
{
    PDETOUR_EXE_HELPER Helper = NULL;
    BOOL Result = FALSE;
    _Field_range_(0, cSize - 4) DWORD cOffset = 0;
    DWORD cSize = 4;

    if (pHelper == NULL) {
        goto Cleanup;
    }
    *pHelper = NULL;

    if (nDlls < 1 || nDlls > 4096) {
        SetLastError(ERROR_INVALID_PARAMETER);
        goto Cleanup;
    }

    for (DWORD n = 0; n < nDlls; n++) {
        HRESULT hr;
        size_t cchDest = 0;

        hr = StringCchLengthA(rlpDlls[n], 4096, &cchDest);
        if (!SUCCEEDED(hr)) {
            goto Cleanup;
        }

        cSize += (DWORD)cchDest + 1;
    }

    Helper = (PDETOUR_EXE_HELPER) new NOTHROW BYTE[sizeof(DETOUR_EXE_HELPER) + cSize];
    if (Helper == NULL) {
        goto Cleanup;
    }

    Helper->cb = sizeof(DETOUR_EXE_HELPER) + cSize;
    Helper->pid = dwTargetPid;
    Helper->nDlls = nDlls;

    for (DWORD n = 0; n < nDlls; n++) {
        HRESULT hr;
        size_t cchDest = 0;

        if (cOffset > 0x10000 || cSize > 0x10000 || cOffset + 2 >= cSize) {
            goto Cleanup;
        }

        if (cOffset + 2 >= cSize || cOffset + 65536 < cSize) {
            goto Cleanup;
        }

        _Analysis_assume_(cOffset + 1 < cSize);
        _Analysis_assume_(cOffset < 0x10000);
        _Analysis_assume_(cSize < 0x10000);

        PCHAR psz = &Helper->rDlls[cOffset];

        hr = StringCchCopyA(psz, cSize - cOffset, rlpDlls[n]);
        if (!SUCCEEDED(hr)) {
            goto Cleanup;
        }

// REVIEW 28020 The expression '1<=_Param_(2)& &_Param_(2)<=2147483647' is not true at this call.
// REVIEW 28313 Analysis will not proceed past this point because of annotation evaluation. The annotation expression *_Param_(3)<_Param_(2)&&*_Param_(3)<=stringLength$(_Param_(1)) cannot be true under any assumptions at this point in the program.
#pragma warning(suppress:28020 28313)
        hr = StringCchLengthA(psz, cSize - cOffset, &cchDest);
        if (!SUCCEEDED(hr)) {
            goto Cleanup;
        }

        // Replace "32." with "64." or "64." with "32."

        for (DWORD c = (DWORD)cchDest + 1; c > 3; c--) {
#if DETOURS_32BIT
            if (psz[c - 3] == '3' && psz[c - 2] == '2' && psz[c - 1] == '.') {
                psz[c - 3] = '6'; psz[c - 2] = '4';
                break;
            }
#else
            if (psz[c - 3] == '6' && psz[c - 2] == '4' && psz[c - 1] == '.') {
                psz[c - 3] = '3'; psz[c - 2] = '2';
                break;
            }
#endif
        }

        cOffset += (DWORD)cchDest + 1;
    }

    *pHelper = Helper;
    Helper = NULL;
    Result = TRUE;

  Cleanup:
    if (Helper != NULL) {
        delete[] (PBYTE)Helper;
        Helper = NULL;
    }
    return Result;
}

static
VOID WINAPI FreeExeHelper(PDETOUR_EXE_HELPER *pHelper)
{
    if (*pHelper != NULL) {
        delete[] (PBYTE)*pHelper;
        *pHelper = NULL;
    }
}

BOOL WINAPI DetourProcessViaHelperA(_In_ DWORD dwTargetPid,
                                    _In_ LPCSTR lpDllName,
                                    _In_ PDETOUR_CREATE_PROCESS_ROUTINEA pfCreateProcessA)
{
    return DetourProcessViaHelperDllsA(dwTargetPid, 1, &lpDllName, pfCreateProcessA);
}


BOOL WINAPI DetourProcessViaHelperDllsA(_In_ DWORD dwTargetPid,
                                        _In_ DWORD nDlls,
                                        _In_reads_(nDlls) LPCSTR *rlpDlls,
                                        _In_ PDETOUR_CREATE_PROCESS_ROUTINEA pfCreateProcessA)
{
    BOOL Result = FALSE;
    PROCESS_INFORMATION pi;
    STARTUPINFOA si;
    CHAR szExe[MAX_PATH];
    CHAR szCommand[MAX_PATH];
    PDETOUR_EXE_HELPER helper = NULL;
    HRESULT hr;
    DWORD nLen = GetEnvironmentVariableA("WINDIR", szExe, ARRAYSIZE(szExe));

    DETOUR_TRACE(("DetourProcessViaHelperDlls(pid=%lu,dlls=%lu)\n", dwTargetPid, nDlls));
    if (nDlls < 1 || nDlls > 4096) {
        SetLastError(ERROR_INVALID_PARAMETER);
        goto Cleanup;
    }
    if (!AllocExeHelper(&helper, dwTargetPid, nDlls, rlpDlls)) {
        goto Cleanup;
    }

    if (nLen == 0 || nLen >= ARRAYSIZE(szExe)) {
        goto Cleanup;
    }

#if DETOURS_OPTION_BITS
#if DETOURS_32BIT
    hr = StringCchCatA(szExe, ARRAYSIZE(szExe), "\\sysnative\\rundll32.exe");
#else // !DETOURS_32BIT
    hr = StringCchCatA(szExe, ARRAYSIZE(szExe), "\\syswow64\\rundll32.exe");
#endif // !DETOURS_32BIT
#else // DETOURS_OPTIONS_BITS
    hr = StringCchCatA(szExe, ARRAYSIZE(szExe), "\\system32\\rundll32.exe");
#endif // DETOURS_OPTIONS_BITS
    if (!SUCCEEDED(hr)) {
        goto Cleanup;
    }

    //for East Asia languages and so on, like Chinese, print format with "%hs" can not work fine before user call _tsetlocale(LC_ALL,_T(".ACP"));
    //so we can't use "%hs" in format string, because the dll that contain this code would inject to any process, even not call _tsetlocale(LC_ALL,_T(".ACP")) before
    hr = StringCchPrintfA(szCommand, ARRAYSIZE(szCommand),
                          "rundll32.exe \"%s\",#1", &helper->rDlls[0]);
    if (!SUCCEEDED(hr)) {
        goto Cleanup;
    }

    ZeroMemory(&pi, sizeof(pi));
    ZeroMemory(&si, sizeof(si));
    si.cb = sizeof(si);

    DETOUR_TRACE(("DetourProcessViaHelperDlls(\"%hs\", \"%hs\")\n", szExe, szCommand));
    if (pfCreateProcessA(szExe, szCommand, NULL, NULL, FALSE, CREATE_SUSPENDED,
                         NULL, NULL, &si, &pi)) {

        if (!DetourCopyPayloadToProcess(pi.hProcess,
                                        DETOUR_EXE_HELPER_GUID,
                                        helper, helper->cb)) {
            DETOUR_TRACE(("DetourCopyPayloadToProcess failed: %lu\n", GetLastError()));
            TerminateProcess(pi.hProcess, ~0u);
            CloseHandle(pi.hProcess);
            CloseHandle(pi.hThread);
            goto Cleanup;
        }

        ResumeThread(pi.hThread);
        WaitForSingleObject(pi.hProcess, INFINITE);

        DWORD dwResult = 500;
        GetExitCodeProcess(pi.hProcess, &dwResult);

        CloseHandle(pi.hProcess);
        CloseHandle(pi.hThread);

        if (dwResult != 0) {
            DETOUR_TRACE(("Rundll32.exe failed: result=%lu\n", dwResult));
            goto Cleanup;
        }
        Result = TRUE;
    }
    else {
        DETOUR_TRACE(("CreateProcess failed: %lu\n", GetLastError()));
        goto Cleanup;
    }

  Cleanup:
    FreeExeHelper(&helper);
    return Result;
}

BOOL WINAPI DetourProcessViaHelperW(_In_ DWORD dwTargetPid,
                                    _In_ LPCSTR lpDllName,
                                    _In_ PDETOUR_CREATE_PROCESS_ROUTINEW pfCreateProcessW)
{
    return DetourProcessViaHelperDllsW(dwTargetPid, 1, &lpDllName, pfCreateProcessW);
}

BOOL WINAPI DetourProcessViaHelperDllsW(_In_ DWORD dwTargetPid,
                                        _In_ DWORD nDlls,
                                        _In_reads_(nDlls) LPCSTR *rlpDlls,
                                        _In_ PDETOUR_CREATE_PROCESS_ROUTINEW pfCreateProcessW)
{
    BOOL Result = FALSE;
    PROCESS_INFORMATION pi;
    STARTUPINFOW si;
    WCHAR szExe[MAX_PATH];
    WCHAR szCommand[MAX_PATH];
    PDETOUR_EXE_HELPER helper = NULL;
    HRESULT hr;
    WCHAR szDllName[MAX_PATH];
    int cchWrittenWideChar;
    DWORD nLen = GetEnvironmentVariableW(L"WINDIR", szExe, ARRAYSIZE(szExe));

    DETOUR_TRACE(("DetourProcessViaHelperDlls(pid=%lu,dlls=%lu)\n", dwTargetPid, nDlls));
    if (nDlls < 1 || nDlls > 4096) {
        SetLastError(ERROR_INVALID_PARAMETER);
        goto Cleanup;
    }
    if (!AllocExeHelper(&helper, dwTargetPid, nDlls, rlpDlls)) {
        goto Cleanup;
    }

    if (nLen == 0 || nLen >= ARRAYSIZE(szExe)) {
        goto Cleanup;
    }

#if DETOURS_OPTION_BITS
#if DETOURS_32BIT
    hr = StringCchCatW(szExe, ARRAYSIZE(szExe), L"\\sysnative\\rundll32.exe");
#else // !DETOURS_32BIT
    hr = StringCchCatW(szExe, ARRAYSIZE(szExe), L"\\syswow64\\rundll32.exe");
#endif // !DETOURS_32BIT
#else // DETOURS_OPTIONS_BITS
    hr = StringCchCatW(szExe, ARRAYSIZE(szExe), L"\\system32\\rundll32.exe");
#endif // DETOURS_OPTIONS_BITS
    if (!SUCCEEDED(hr)) {
        goto Cleanup;
    }

    //for East Asia languages and so on, like Chinese, print format with "%hs" can not work fine before user call _tsetlocale(LC_ALL,_T(".ACP"));
    //so we can't use "%hs" in format string, because the dll that contain this code would inject to any process, even not call _tsetlocale(LC_ALL,_T(".ACP")) before
    
    cchWrittenWideChar = MultiByteToWideChar(CP_ACP, 0, &helper->rDlls[0], -1, szDllName, ARRAYSIZE(szDllName));
    if (cchWrittenWideChar >= ARRAYSIZE(szDllName) || cchWrittenWideChar <= 0) {
        goto Cleanup;
    }
    hr = StringCchPrintfW(szCommand, ARRAYSIZE(szCommand),
        L"rundll32.exe \"%s\",#1", szDllName);
    if (!SUCCEEDED(hr)) {
        goto Cleanup;
    }

    ZeroMemory(&pi, sizeof(pi));
    ZeroMemory(&si, sizeof(si));
    si.cb = sizeof(si);

    DETOUR_TRACE(("DetourProcessViaHelperDlls(\"%ls\", \"%ls\")\n", szExe, szCommand));
    if (pfCreateProcessW(szExe, szCommand, NULL, NULL, FALSE, CREATE_SUSPENDED,
                         NULL, NULL, &si, &pi)) {

        if (!DetourCopyPayloadToProcess(pi.hProcess,
                                        DETOUR_EXE_HELPER_GUID,
                                        helper, helper->cb)) {
            DETOUR_TRACE(("DetourCopyPayloadToProcess failed: %lu\n", GetLastError()));
            TerminateProcess(pi.hProcess, ~0u);
            CloseHandle(pi.hProcess);
            CloseHandle(pi.hThread);
            goto Cleanup;
        }

        ResumeThread(pi.hThread);
        WaitForSingleObject(pi.hProcess, INFINITE);

        DWORD dwResult = 500;
        GetExitCodeProcess(pi.hProcess, &dwResult);

        CloseHandle(pi.hProcess);
        CloseHandle(pi.hThread);

        if (dwResult != 0) {
            DETOUR_TRACE(("Rundll32.exe failed: result=%lu\n", dwResult));
            goto Cleanup;
        }
        Result = TRUE;
    }
    else {
        DETOUR_TRACE(("CreateProcess failed: %lu\n", GetLastError()));
        goto Cleanup;
    }

  Cleanup:
    FreeExeHelper(&helper);
    return Result;
}

BOOL WINAPI DetourCreateProcessWithDllExA(_In_opt_ LPCSTR lpApplicationName,
                                          _Inout_opt_ LPSTR lpCommandLine,
                                          _In_opt_ LPSECURITY_ATTRIBUTES lpProcessAttributes,
                                          _In_opt_ LPSECURITY_ATTRIBUTES lpThreadAttributes,
                                          _In_ BOOL bInheritHandles,
                                          _In_ DWORD dwCreationFlags,
                                          _In_opt_ LPVOID lpEnvironment,
                                          _In_opt_ LPCSTR lpCurrentDirectory,
                                          _In_ LPSTARTUPINFOA lpStartupInfo,
                                          _Out_ LPPROCESS_INFORMATION lpProcessInformation,
                                          _In_ LPCSTR lpDllName,
                                          _In_opt_ PDETOUR_CREATE_PROCESS_ROUTINEA pfCreateProcessA)
{
    if (pfCreateProcessA == NULL) {
        pfCreateProcessA = CreateProcessA;
    }

    PROCESS_INFORMATION backup;
    if (lpProcessInformation == NULL) {
        lpProcessInformation = &backup;
        ZeroMemory(&backup, sizeof(backup));
    }

    if (!pfCreateProcessA(lpApplicationName,
                          lpCommandLine,
                          lpProcessAttributes,
                          lpThreadAttributes,
                          bInheritHandles,
                          dwCreationFlags | CREATE_SUSPENDED,
                          lpEnvironment,
                          lpCurrentDirectory,
                          lpStartupInfo,
                          lpProcessInformation)) {
        return FALSE;
    }

    LPCSTR szDll = lpDllName;

    if (!DetourUpdateProcessWithDll(lpProcessInformation->hProcess, &szDll, 1) &&
        !DetourProcessViaHelperA(lpProcessInformation->dwProcessId,
                                 lpDllName,
                                 pfCreateProcessA)) {

        TerminateProcess(lpProcessInformation->hProcess, ~0u);
        CloseHandle(lpProcessInformation->hProcess);
        CloseHandle(lpProcessInformation->hThread);
        return FALSE;
    }

    if (!(dwCreationFlags & CREATE_SUSPENDED)) {
        ResumeThread(lpProcessInformation->hThread);
    }

    if (lpProcessInformation == &backup) {
        CloseHandle(lpProcessInformation->hProcess);
        CloseHandle(lpProcessInformation->hThread);
    }

    return TRUE;
}

BOOL WINAPI DetourCreateProcessWithDllExW(_In_opt_ LPCWSTR lpApplicationName,
                                          _Inout_opt_  LPWSTR lpCommandLine,
                                          _In_opt_ LPSECURITY_ATTRIBUTES lpProcessAttributes,
                                          _In_opt_ LPSECURITY_ATTRIBUTES lpThreadAttributes,
                                          _In_ BOOL bInheritHandles,
                                          _In_ DWORD dwCreationFlags,
                                          _In_opt_ LPVOID lpEnvironment,
                                          _In_opt_ LPCWSTR lpCurrentDirectory,
                                          _In_ LPSTARTUPINFOW lpStartupInfo,
                                          _Out_ LPPROCESS_INFORMATION lpProcessInformation,
                                          _In_ LPCSTR lpDllName,
                                          _In_opt_ PDETOUR_CREATE_PROCESS_ROUTINEW pfCreateProcessW)
{
    if (pfCreateProcessW == NULL) {
        pfCreateProcessW = CreateProcessW;
    }

    PROCESS_INFORMATION backup;
    if (lpProcessInformation == NULL) {
        lpProcessInformation = &backup;
        ZeroMemory(&backup, sizeof(backup));
    }

    if (!pfCreateProcessW(lpApplicationName,
                          lpCommandLine,
                          lpProcessAttributes,
                          lpThreadAttributes,
                          bInheritHandles,
                          dwCreationFlags | CREATE_SUSPENDED,
                          lpEnvironment,
                          lpCurrentDirectory,
                          lpStartupInfo,
                          lpProcessInformation)) {
        return FALSE;
    }


    LPCSTR sz = lpDllName;

    if (!DetourUpdateProcessWithDll(lpProcessInformation->hProcess, &sz, 1) &&
        !DetourProcessViaHelperW(lpProcessInformation->dwProcessId,
                                 lpDllName,
                                 pfCreateProcessW)) {

        TerminateProcess(lpProcessInformation->hProcess, ~0u);
        CloseHandle(lpProcessInformation->hProcess);
        CloseHandle(lpProcessInformation->hThread);
        return FALSE;
    }

    if (!(dwCreationFlags & CREATE_SUSPENDED)) {
        ResumeThread(lpProcessInformation->hThread);
    }

    if (lpProcessInformation == &backup) {
        CloseHandle(lpProcessInformation->hProcess);
        CloseHandle(lpProcessInformation->hThread);
    }
    return TRUE;
}

BOOL WINAPI DetourCreateProcessWithDllsA(_In_opt_ LPCSTR lpApplicationName,
                                         _Inout_opt_ LPSTR lpCommandLine,
                                         _In_opt_ LPSECURITY_ATTRIBUTES lpProcessAttributes,
                                         _In_opt_ LPSECURITY_ATTRIBUTES lpThreadAttributes,
                                         _In_ BOOL bInheritHandles,
                                         _In_ DWORD dwCreationFlags,
                                         _In_opt_ LPVOID lpEnvironment,
                                         _In_opt_ LPCSTR lpCurrentDirectory,
                                         _In_ LPSTARTUPINFOA lpStartupInfo,
                                         _Out_ LPPROCESS_INFORMATION lpProcessInformation,
                                         _In_ DWORD nDlls,
                                         _In_reads_(nDlls) LPCSTR *rlpDlls,
                                         _In_opt_ PDETOUR_CREATE_PROCESS_ROUTINEA pfCreateProcessA)
{
    if (pfCreateProcessA == NULL) {
        pfCreateProcessA = CreateProcessA;
    }

    PROCESS_INFORMATION backup;
    if (lpProcessInformation == NULL) {
        lpProcessInformation = &backup;
        ZeroMemory(&backup, sizeof(backup));
    }

    if (!pfCreateProcessA(lpApplicationName,
                          lpCommandLine,
                          lpProcessAttributes,
                          lpThreadAttributes,
                          bInheritHandles,
                          dwCreationFlags | CREATE_SUSPENDED,
                          lpEnvironment,
                          lpCurrentDirectory,
                          lpStartupInfo,
                          lpProcessInformation)) {
        return FALSE;
    }

    if (!DetourUpdateProcessWithDll(lpProcessInformation->hProcess, rlpDlls, nDlls) &&
        !DetourProcessViaHelperDllsA(lpProcessInformation->dwProcessId,
                                     nDlls,
                                     rlpDlls,
                                     pfCreateProcessA)) {

        TerminateProcess(lpProcessInformation->hProcess, ~0u);
        CloseHandle(lpProcessInformation->hProcess);
        CloseHandle(lpProcessInformation->hThread);
        return FALSE;
    }

    if (!(dwCreationFlags & CREATE_SUSPENDED)) {
        ResumeThread(lpProcessInformation->hThread);
    }

    if (lpProcessInformation == &backup) {
        CloseHandle(lpProcessInformation->hProcess);
        CloseHandle(lpProcessInformation->hThread);
    }

    return TRUE;
}

BOOL WINAPI DetourCreateProcessWithDllsW(_In_opt_ LPCWSTR lpApplicationName,
                                         _Inout_opt_ LPWSTR lpCommandLine,
                                         _In_opt_ LPSECURITY_ATTRIBUTES lpProcessAttributes,
                                         _In_opt_ LPSECURITY_ATTRIBUTES lpThreadAttributes,
                                         _In_ BOOL bInheritHandles,
                                         _In_ DWORD dwCreationFlags,
                                         _In_opt_ LPVOID lpEnvironment,
                                         _In_opt_ LPCWSTR lpCurrentDirectory,
                                         _In_ LPSTARTUPINFOW lpStartupInfo,
                                         _Out_ LPPROCESS_INFORMATION lpProcessInformation,
                                         _In_ DWORD nDlls,
                                         _In_reads_(nDlls) LPCSTR *rlpDlls,
                                         _In_opt_ PDETOUR_CREATE_PROCESS_ROUTINEW pfCreateProcessW)
{
    if (pfCreateProcessW == NULL) {
        pfCreateProcessW = CreateProcessW;
    }

    PROCESS_INFORMATION backup;
    if (lpProcessInformation == NULL) {
        lpProcessInformation = &backup;
        ZeroMemory(&backup, sizeof(backup));
    }

    if (!pfCreateProcessW(lpApplicationName,
                          lpCommandLine,
                          lpProcessAttributes,
                          lpThreadAttributes,
                          bInheritHandles,
                          dwCreationFlags | CREATE_SUSPENDED,
                          lpEnvironment,
                          lpCurrentDirectory,
                          lpStartupInfo,
                          lpProcessInformation)) {
        return FALSE;
    }


    if (!DetourUpdateProcessWithDll(lpProcessInformation->hProcess, rlpDlls, nDlls) &&
        !DetourProcessViaHelperDllsW(lpProcessInformation->dwProcessId,
                                     nDlls,
                                     rlpDlls,
                                     pfCreateProcessW)) {

        TerminateProcess(lpProcessInformation->hProcess, ~0u);
        CloseHandle(lpProcessInformation->hProcess);
        CloseHandle(lpProcessInformation->hThread);
        return FALSE;
    }

    if (!(dwCreationFlags & CREATE_SUSPENDED)) {
        ResumeThread(lpProcessInformation->hThread);
    }

    if (lpProcessInformation == &backup) {
        CloseHandle(lpProcessInformation->hProcess);
        CloseHandle(lpProcessInformation->hThread);
    }
    return TRUE;
}

//
///////////////////////////////////////////////////////////////// End of File.

```

`src/detours.cpp`:

```cpp
//////////////////////////////////////////////////////////////////////////////
//
//  Core Detours Functionality (detours.cpp of detours.lib)
//
//  Microsoft Research Detours Package, Version 4.0.1
//
//  Copyright (c) Microsoft Corporation.  All rights reserved.
//


//#define DETOUR_DEBUG 1
#define DETOURS_INTERNAL
#include "detours.h"

#if DETOURS_VERSION != 0x4c0c1   // 0xMAJORcMINORcPATCH
#error detours.h version mismatch
#endif

#define NOTHROW

//////////////////////////////////////////////////////////////////////////////
//

#ifdef _DEBUG
extern "C" IMAGE_DOS_HEADER __ImageBase;
int Detour_AssertExprWithFunctionName(int reportType, const char* filename, int linenumber, const char* FunctionName, const char* msg)
{
    int nRet = 0;
    DWORD dwLastError = GetLastError();
    CHAR szModuleNameWithFunctionName[MAX_PATH * 2];
    szModuleNameWithFunctionName[0] = 0;
    GetModuleFileNameA((HMODULE)&__ImageBase, szModuleNameWithFunctionName, ARRAYSIZE(szModuleNameWithFunctionName));
    StringCchCatNA(szModuleNameWithFunctionName, ARRAYSIZE(szModuleNameWithFunctionName), ",", ARRAYSIZE(szModuleNameWithFunctionName) - strlen(szModuleNameWithFunctionName) - 1);
    StringCchCatNA(szModuleNameWithFunctionName, ARRAYSIZE(szModuleNameWithFunctionName), FunctionName, ARRAYSIZE(szModuleNameWithFunctionName) - strlen(szModuleNameWithFunctionName) - 1);
    SetLastError(dwLastError);
    nRet = _CrtDbgReport(reportType, filename, linenumber, szModuleNameWithFunctionName, msg);
    SetLastError(dwLastError);
    return nRet;
}
#endif// _DEBUG

//////////////////////////////////////////////////////////////////////////////
//
struct _DETOUR_ALIGN
{
    BYTE    obTarget        : 3;
    BYTE    obTrampoline    : 5;
};

C_ASSERT(sizeof(_DETOUR_ALIGN) == 1);

//////////////////////////////////////////////////////////////////////////////
//
// Region reserved for system DLLs, which cannot be used for trampolines.
//
static PVOID    s_pSystemRegionLowerBound   = (PVOID)(ULONG_PTR)0x70000000;
static PVOID    s_pSystemRegionUpperBound   = (PVOID)(ULONG_PTR)0x80000000;

//////////////////////////////////////////////////////////////////////////////
//
static bool detour_is_imported(PBYTE pbCode, PBYTE pbAddress)
{
    MEMORY_BASIC_INFORMATION mbi;
    VirtualQuery((PVOID)pbCode, &mbi, sizeof(mbi));
    __try {
        PIMAGE_DOS_HEADER pDosHeader = (PIMAGE_DOS_HEADER)mbi.AllocationBase;
        if (pDosHeader->e_magic != IMAGE_DOS_SIGNATURE) {
            return false;
        }

        PIMAGE_NT_HEADERS pNtHeader = (PIMAGE_NT_HEADERS)((PBYTE)pDosHeader +
                                                          pDosHeader->e_lfanew);
        if (pNtHeader->Signature != IMAGE_NT_SIGNATURE) {
            return false;
        }

        if (pbAddress >= ((PBYTE)pDosHeader +
                          pNtHeader->OptionalHeader
                          .DataDirectory[IMAGE_DIRECTORY_ENTRY_IAT].VirtualAddress) &&
            pbAddress < ((PBYTE)pDosHeader +
                         pNtHeader->OptionalHeader
                         .DataDirectory[IMAGE_DIRECTORY_ENTRY_IAT].VirtualAddress +
                         pNtHeader->OptionalHeader
                         .DataDirectory[IMAGE_DIRECTORY_ENTRY_IAT].Size)) {
            return true;
        }
    }
#pragma prefast(suppress:28940, "A bad pointer means this probably isn't a PE header.")
    __except(GetExceptionCode() == EXCEPTION_ACCESS_VIOLATION ?
             EXCEPTION_EXECUTE_HANDLER : EXCEPTION_CONTINUE_SEARCH) {
        return false;
    }
    return false;
}

inline ULONG_PTR detour_2gb_below(ULONG_PTR address)
{
    return (address > (ULONG_PTR)0x7ff80000) ? address - 0x7ff80000 : 0x80000;
}

inline ULONG_PTR detour_2gb_above(ULONG_PTR address)
{
#if defined(DETOURS_64BIT)
    return (address < (ULONG_PTR)0xffffffff80000000) ? address + 0x7ff80000 : (ULONG_PTR)0xfffffffffff80000;
#else
    return (address < (ULONG_PTR)0x80000000) ? address + 0x7ff80000 : (ULONG_PTR)0xfff80000;
#endif
}

///////////////////////////////////////////////////////////////////////// X86.
//
#ifdef DETOURS_X86

struct _DETOUR_TRAMPOLINE
{
    BYTE            rbCode[30];     // target code + jmp to pbRemain
    BYTE            cbCode;         // size of moved target code.
    BYTE            cbCodeBreak;    // padding to make debugging easier.
    BYTE            rbRestore[22];  // original target code.
    BYTE            cbRestore;      // size of original target code.
    BYTE            cbRestoreBreak; // padding to make debugging easier.
    _DETOUR_ALIGN   rAlign[8];      // instruction alignment array.
    PBYTE           pbRemain;       // first instruction after moved code. [free list]
    PBYTE           pbDetour;       // first instruction of detour function.
};

C_ASSERT(sizeof(_DETOUR_TRAMPOLINE) == 72);

enum {
    SIZE_OF_JMP = 5
};

inline PBYTE detour_gen_jmp_immediate(PBYTE pbCode, PBYTE pbJmpVal)
{
    PBYTE pbJmpSrc = pbCode + 5;
    *pbCode++ = 0xE9;   // jmp +imm32
    *((INT32*&)pbCode)++ = (INT32)(pbJmpVal - pbJmpSrc);
    return pbCode;
}

inline PBYTE detour_gen_jmp_indirect(PBYTE pbCode, PBYTE *ppbJmpVal)
{
    *pbCode++ = 0xff;   // jmp [+imm32]
    *pbCode++ = 0x25;
    *((INT32*&)pbCode)++ = (INT32)((PBYTE)ppbJmpVal);
    return pbCode;
}

inline PBYTE detour_gen_brk(PBYTE pbCode, PBYTE pbLimit)
{
    while (pbCode < pbLimit) {
        *pbCode++ = 0xcc;   // brk;
    }
    return pbCode;
}

inline PBYTE detour_skip_jmp(PBYTE pbCode, PVOID *ppGlobals)
{
    if (pbCode == NULL) {
        return NULL;
    }
    if (ppGlobals != NULL) {
        *ppGlobals = NULL;
    }

    // First, skip over the import vector if there is one.
    if (pbCode[0] == 0xff && pbCode[1] == 0x25) {   // jmp [imm32]
        // Looks like an import alias jump, then get the code it points to.
        PBYTE pbTarget = *(UNALIGNED PBYTE *)&pbCode[2];
        if (detour_is_imported(pbCode, pbTarget)) {
            PBYTE pbNew = *(UNALIGNED PBYTE *)pbTarget;
            DETOUR_TRACE(("%p->%p: skipped over import table.\n", pbCode, pbNew));
            pbCode = pbNew;
        }
    }

    // Then, skip over a patch jump
    if (pbCode[0] == 0xeb) {   // jmp +imm8
        PBYTE pbNew = pbCode + 2 + *(CHAR *)&pbCode[1];
        DETOUR_TRACE(("%p->%p: skipped over short jump.\n", pbCode, pbNew));
        pbCode = pbNew;

        // First, skip over the import vector if there is one.
        if (pbCode[0] == 0xff && pbCode[1] == 0x25) {   // jmp [imm32]
            // Looks like an import alias jump, then get the code it points to.
            PBYTE pbTarget = *(UNALIGNED PBYTE *)&pbCode[2];
            if (detour_is_imported(pbCode, pbTarget)) {
                pbNew = *(UNALIGNED PBYTE *)pbTarget;
                DETOUR_TRACE(("%p->%p: skipped over import table.\n", pbCode, pbNew));
                pbCode = pbNew;
            }
        }
        // Finally, skip over a long jump if it is the target of the patch jump.
        else if (pbCode[0] == 0xe9) {   // jmp +imm32
            pbNew = pbCode + 5 + *(UNALIGNED INT32 *)&pbCode[1];
            DETOUR_TRACE(("%p->%p: skipped over long jump.\n", pbCode, pbNew));
            pbCode = pbNew;
        }
    }
    return pbCode;
}

inline void detour_find_jmp_bounds(PBYTE pbCode,
                                   PDETOUR_TRAMPOLINE *ppLower,
                                   PDETOUR_TRAMPOLINE *ppUpper)
{
    // We have to place trampolines within +/- 2GB of code.
    ULONG_PTR lo = detour_2gb_below((ULONG_PTR)pbCode);
    ULONG_PTR hi = detour_2gb_above((ULONG_PTR)pbCode);
    DETOUR_TRACE(("[%p..%p..%p]\n", (PVOID)lo, pbCode, (PVOID)hi));

    // And, within +/- 2GB of relative jmp targets.
    if (pbCode[0] == 0xe9) {   // jmp +imm32
        PBYTE pbNew = pbCode + 5 + *(UNALIGNED INT32 *)&pbCode[1];

        if (pbNew < pbCode) {
            hi = detour_2gb_above((ULONG_PTR)pbNew);
        }
        else {
            lo = detour_2gb_below((ULONG_PTR)pbNew);
        }
        DETOUR_TRACE(("[%p..%p..%p] +imm32\n", (PVOID)lo, pbCode, (PVOID)hi));
    }

    *ppLower = (PDETOUR_TRAMPOLINE)lo;
    *ppUpper = (PDETOUR_TRAMPOLINE)hi;
}

inline BOOL detour_does_code_end_function(PBYTE pbCode)
{
    if (pbCode[0] == 0xeb ||    // jmp +imm8
        pbCode[0] == 0xe9 ||    // jmp +imm32
        pbCode[0] == 0xe0 ||    // jmp eax
        pbCode[0] == 0xc2 ||    // ret +imm8
        pbCode[0] == 0xc3 ||    // ret
        pbCode[0] == 0xcc) {    // brk
        return TRUE;
    }
    else if (pbCode[0] == 0xf3 && pbCode[1] == 0xc3) {  // rep ret
        return TRUE;
    }
    else if (pbCode[0] == 0xff && pbCode[1] == 0x25) {  // jmp [+imm32]
        return TRUE;
    }
    else if ((pbCode[0] == 0x26 ||      // jmp es:
              pbCode[0] == 0x2e ||      // jmp cs:
              pbCode[0] == 0x36 ||      // jmp ss:
              pbCode[0] == 0x3e ||      // jmp ds:
              pbCode[0] == 0x64 ||      // jmp fs:
              pbCode[0] == 0x65) &&     // jmp gs:
             pbCode[1] == 0xff &&       // jmp [+imm32]
             pbCode[2] == 0x25) {
        return TRUE;
    }
    return FALSE;
}

inline ULONG detour_is_code_filler(PBYTE pbCode)
{
    // 1-byte through 11-byte NOPs.
    if (pbCode[0] == 0x90) {
        return 1;
    }
    if (pbCode[0] == 0x66 && pbCode[1] == 0x90) {
        return 2;
    }
    if (pbCode[0] == 0x0F && pbCode[1] == 0x1F && pbCode[2] == 0x00) {
        return 3;
    }
    if (pbCode[0] == 0x0F && pbCode[1] == 0x1F && pbCode[2] == 0x40 &&
        pbCode[3] == 0x00) {
        return 4;
    }
    if (pbCode[0] == 0x0F && pbCode[1] == 0x1F && pbCode[2] == 0x44 &&
        pbCode[3] == 0x00 && pbCode[4] == 0x00) {
        return 5;
    }
    if (pbCode[0] == 0x66 && pbCode[1] == 0x0F && pbCode[2] == 0x1F &&
        pbCode[3] == 0x44 && pbCode[4] == 0x00 && pbCode[5] == 0x00) {
        return 6;
    }
    if (pbCode[0] == 0x0F && pbCode[1] == 0x1F && pbCode[2] == 0x80 &&
        pbCode[3] == 0x00 && pbCode[4] == 0x00 && pbCode[5] == 0x00 &&
        pbCode[6] == 0x00) {
        return 7;
    }
    if (pbCode[0] == 0x0F && pbCode[1] == 0x1F && pbCode[2] == 0x84 &&
        pbCode[3] == 0x00 && pbCode[4] == 0x00 && pbCode[5] == 0x00 &&
        pbCode[6] == 0x00 && pbCode[7] == 0x00) {
        return 8;
    }
    if (pbCode[0] == 0x66 && pbCode[1] == 0x0F && pbCode[2] == 0x1F &&
        pbCode[3] == 0x84 && pbCode[4] == 0x00 && pbCode[5] == 0x00 &&
        pbCode[6] == 0x00 && pbCode[7] == 0x00 && pbCode[8] == 0x00) {
        return 9;
    }
    if (pbCode[0] == 0x66 && pbCode[1] == 0x66 && pbCode[2] == 0x0F &&
        pbCode[3] == 0x1F && pbCode[4] == 0x84 && pbCode[5] == 0x00 &&
        pbCode[6] == 0x00 && pbCode[7] == 0x00 && pbCode[8] == 0x00 &&
        pbCode[9] == 0x00) {
        return 10;
    }
    if (pbCode[0] == 0x66 && pbCode[1] == 0x66 && pbCode[2] == 0x66 &&
        pbCode[3] == 0x0F && pbCode[4] == 0x1F && pbCode[5] == 0x84 &&
        pbCode[6] == 0x00 && pbCode[7] == 0x00 && pbCode[8] == 0x00 &&
        pbCode[9] == 0x00 && pbCode[10] == 0x00) {
        return 11;
    }

    // int 3.
    if (pbCode[0] == 0xcc) {
        return 1;
    }
    return 0;
}

#endif // DETOURS_X86

///////////////////////////////////////////////////////////////////////// X64.
//
#ifdef DETOURS_X64

struct _DETOUR_TRAMPOLINE
{
    // An X64 instuction can be 15 bytes long.
    // In practice 11 seems to be the limit.
    BYTE            rbCode[30];     // target code + jmp to pbRemain.
    BYTE            cbCode;         // size of moved target code.
    BYTE            cbCodeBreak;    // padding to make debugging easier.
    BYTE            rbRestore[30];  // original target code.
    BYTE            cbRestore;      // size of original target code.
    BYTE            cbRestoreBreak; // padding to make debugging easier.
    _DETOUR_ALIGN   rAlign[8];      // instruction alignment array.
    PBYTE           pbRemain;       // first instruction after moved code. [free list]
    PBYTE           pbDetour;       // first instruction of detour function.
    BYTE            rbCodeIn[8];    // jmp [pbDetour]
};

C_ASSERT(sizeof(_DETOUR_TRAMPOLINE) == 96);

enum {
    SIZE_OF_JMP = 5
};

inline PBYTE detour_gen_jmp_immediate(PBYTE pbCode, PBYTE pbJmpVal)
{
    PBYTE pbJmpSrc = pbCode + 5;
    *pbCode++ = 0xE9;   // jmp +imm32
    *((INT32*&)pbCode)++ = (INT32)(pbJmpVal - pbJmpSrc);
    return pbCode;
}

inline PBYTE detour_gen_jmp_indirect(PBYTE pbCode, PBYTE *ppbJmpVal)
{
    PBYTE pbJmpSrc = pbCode + 6;
    *pbCode++ = 0xff;   // jmp [+imm32]
    *pbCode++ = 0x25;
    *((INT32*&)pbCode)++ = (INT32)((PBYTE)ppbJmpVal - pbJmpSrc);
    return pbCode;
}

inline PBYTE detour_gen_brk(PBYTE pbCode, PBYTE pbLimit)
{
    while (pbCode < pbLimit) {
        *pbCode++ = 0xcc;   // brk;
    }
    return pbCode;
}

inline PBYTE detour_skip_jmp(PBYTE pbCode, PVOID *ppGlobals)
{
    if (pbCode == NULL) {
        return NULL;
    }
    if (ppGlobals != NULL) {
        *ppGlobals = NULL;
    }

    // First, skip over the import vector if there is one.
    if (pbCode[0] == 0xff && pbCode[1] == 0x25) {   // jmp [+imm32]
        // Looks like an import alias jump, then get the code it points to.
        PBYTE pbTarget = pbCode + 6 + *(UNALIGNED INT32 *)&pbCode[2];
        if (detour_is_imported(pbCode, pbTarget)) {
            PBYTE pbNew = *(UNALIGNED PBYTE *)pbTarget;
            DETOUR_TRACE(("%p->%p: skipped over import table.\n", pbCode, pbNew));
            pbCode = pbNew;
        }
    }

    // Then, skip over a patch jump
    if (pbCode[0] == 0xeb) {   // jmp +imm8
        PBYTE pbNew = pbCode + 2 + *(CHAR *)&pbCode[1];
        DETOUR_TRACE(("%p->%p: skipped over short jump.\n", pbCode, pbNew));
        pbCode = pbNew;

        // First, skip over the import vector if there is one.
        if (pbCode[0] == 0xff && pbCode[1] == 0x25) {   // jmp [+imm32]
            // Looks like an import alias jump, then get the code it points to.
            PBYTE pbTarget = pbCode + 6 + *(UNALIGNED INT32 *)&pbCode[2];
            if (detour_is_imported(pbCode, pbTarget)) {
                pbNew = *(UNALIGNED PBYTE *)pbTarget;
                DETOUR_TRACE(("%p->%p: skipped over import table.\n", pbCode, pbNew));
                pbCode = pbNew;
            }
        }
        // Finally, skip over a long jump if it is the target of the patch jump.
        else if (pbCode[0] == 0xe9) {   // jmp +imm32
            pbNew = pbCode + 5 + *(UNALIGNED INT32 *)&pbCode[1];
            DETOUR_TRACE(("%p->%p: skipped over long jump.\n", pbCode, pbNew));
            pbCode = pbNew;
        }
    }
    return pbCode;
}

inline void detour_find_jmp_bounds(PBYTE pbCode,
                                   PDETOUR_TRAMPOLINE *ppLower,
                                   PDETOUR_TRAMPOLINE *ppUpper)
{
    // We have to place trampolines within +/- 2GB of code.
    ULONG_PTR lo = detour_2gb_below((ULONG_PTR)pbCode);
    ULONG_PTR hi = detour_2gb_above((ULONG_PTR)pbCode);
    DETOUR_TRACE(("[%p..%p..%p]\n", (PVOID)lo, pbCode, (PVOID)hi));

    // And, within +/- 2GB of relative jmp vectors.
    if (pbCode[0] == 0xff && pbCode[1] == 0x25) {   // jmp [+imm32]
        PBYTE pbNew = pbCode + 6 + *(UNALIGNED INT32 *)&pbCode[2];

        if (pbNew < pbCode) {
            hi = detour_2gb_above((ULONG_PTR)pbNew);
        }
        else {
            lo = detour_2gb_below((ULONG_PTR)pbNew);
        }
        DETOUR_TRACE(("[%p..%p..%p] [+imm32]\n", (PVOID)lo, pbCode, (PVOID)hi));
    }
    // And, within +/- 2GB of relative jmp targets.
    else if (pbCode[0] == 0xe9) {   // jmp +imm32
        PBYTE pbNew = pbCode + 5 + *(UNALIGNED INT32 *)&pbCode[1];

        if (pbNew < pbCode) {
            hi = detour_2gb_above((ULONG_PTR)pbNew);
        }
        else {
            lo = detour_2gb_below((ULONG_PTR)pbNew);
        }
        DETOUR_TRACE(("[%p..%p..%p] +imm32\n", (PVOID)lo, pbCode, (PVOID)hi));
    }

    *ppLower = (PDETOUR_TRAMPOLINE)lo;
    *ppUpper = (PDETOUR_TRAMPOLINE)hi;
}

inline BOOL detour_does_code_end_function(PBYTE pbCode)
{
    if (pbCode[0] == 0xeb ||    // jmp +imm8
        pbCode[0] == 0xe9 ||    // jmp +imm32
        pbCode[0] == 0xe0 ||    // jmp eax
        pbCode[0] == 0xc2 ||    // ret +imm8
        pbCode[0] == 0xc3 ||    // ret
        pbCode[0] == 0xcc) {    // brk
        return TRUE;
    }
    else if (pbCode[0] == 0xf3 && pbCode[1] == 0xc3) {  // rep ret
        return TRUE;
    }
    else if (pbCode[0] == 0xff && pbCode[1] == 0x25) {  // jmp [+imm32]
        return TRUE;
    }
    else if ((pbCode[0] == 0x26 ||      // jmp es:
              pbCode[0] == 0x2e ||      // jmp cs:
              pbCode[0] == 0x36 ||      // jmp ss:
              pbCode[0] == 0x3e ||      // jmp ds:
              pbCode[0] == 0x64 ||      // jmp fs:
              pbCode[0] == 0x65) &&     // jmp gs:
             pbCode[1] == 0xff &&       // jmp [+imm32]
             pbCode[2] == 0x25) {
        return TRUE;
    }
    return FALSE;
}

inline ULONG detour_is_code_filler(PBYTE pbCode)
{
    // 1-byte through 11-byte NOPs.
    if (pbCode[0] == 0x90) {
        return 1;
    }
    if (pbCode[0] == 0x66 && pbCode[1] == 0x90) {
        return 2;
    }
    if (pbCode[0] == 0x0F && pbCode[1] == 0x1F && pbCode[2] == 0x00) {
        return 3;
    }
    if (pbCode[0] == 0x0F && pbCode[1] == 0x1F && pbCode[2] == 0x40 &&
        pbCode[3] == 0x00) {
        return 4;
    }
    if (pbCode[0] == 0x0F && pbCode[1] == 0x1F && pbCode[2] == 0x44 &&
        pbCode[3] == 0x00 && pbCode[4] == 0x00) {
        return 5;
    }
    if (pbCode[0] == 0x66 && pbCode[1] == 0x0F && pbCode[2] == 0x1F &&
        pbCode[3] == 0x44 && pbCode[4] == 0x00 && pbCode[5] == 0x00) {
        return 6;
    }
    if (pbCode[0] == 0x0F && pbCode[1] == 0x1F && pbCode[2] == 0x80 &&
        pbCode[3] == 0x00 && pbCode[4] == 0x00 && pbCode[5] == 0x00 &&
        pbCode[6] == 0x00) {
        return 7;
    }
    if (pbCode[0] == 0x0F && pbCode[1] == 0x1F && pbCode[2] == 0x84 &&
        pbCode[3] == 0x00 && pbCode[4] == 0x00 && pbCode[5] == 0x00 &&
        pbCode[6] == 0x00 && pbCode[7] == 0x00) {
        return 8;
    }
    if (pbCode[0] == 0x66 && pbCode[1] == 0x0F && pbCode[2] == 0x1F &&
        pbCode[3] == 0x84 && pbCode[4] == 0x00 && pbCode[5] == 0x00 &&
        pbCode[6] == 0x00 && pbCode[7] == 0x00 && pbCode[8] == 0x00) {
        return 9;
    }
    if (pbCode[0] == 0x66 && pbCode[1] == 0x66 && pbCode[2] == 0x0F &&
        pbCode[3] == 0x1F && pbCode[4] == 0x84 && pbCode[5] == 0x00 &&
        pbCode[6] == 0x00 && pbCode[7] == 0x00 && pbCode[8] == 0x00 &&
        pbCode[9] == 0x00) {
        return 10;
    }
    if (pbCode[0] == 0x66 && pbCode[1] == 0x66 && pbCode[2] == 0x66 &&
        pbCode[3] == 0x0F && pbCode[4] == 0x1F && pbCode[5] == 0x84 &&
        pbCode[6] == 0x00 && pbCode[7] == 0x00 && pbCode[8] == 0x00 &&
        pbCode[9] == 0x00 && pbCode[10] == 0x00) {
        return 11;
    }

    // int 3.
    if (pbCode[0] == 0xcc) {
        return 1;
    }
    return 0;
}

#endif // DETOURS_X64

//////////////////////////////////////////////////////////////////////// IA64.
//
#ifdef DETOURS_IA64

struct _DETOUR_TRAMPOLINE
{
    // On the IA64, a trampoline is used for both incoming and outgoing calls.
    //
    // The trampoline contains the following bundles for the outgoing call:
    //      movl gp=target_gp;
    //      <relocated target bundle>
    //      brl  target_code;
    //
    // The trampoline contains the following bundles for the incoming call:
    //      alloc  r41=ar.pfs, b, 0, 8, 0
    //      mov    r40=rp
    //
    //      adds   r50=0, r39
    //      adds   r49=0, r38
    //      adds   r48=0, r37 ;;
    //
    //      adds   r47=0, r36
    //      adds   r46=0, r35
    //      adds   r45=0, r34
    //
    //      adds   r44=0, r33
    //      adds   r43=0, r32
    //      adds   r42=0, gp ;;
    //
    //      movl   gp=ffffffff`ffffffff ;;
    //
    //      brl.call.sptk.few rp=disas!TestCodes+20e0 (00000000`00404ea0) ;;
    //
    //      adds   gp=0, r42
    //      mov    rp=r40, +0 ;;
    //      mov.i  ar.pfs=r41
    //
    //      br.ret.sptk.many rp ;;
    //
    // This way, we only have to relocate a single bundle.
    //
    // The complicated incoming trampoline is required because we have to
    // create an additional stack frame so that we save and restore the gp.
    // We must do this because gp is a caller-saved register, but not saved
    // if the caller thinks the target is in the same DLL, which changes
    // when we insert a detour.
    //
    DETOUR_IA64_BUNDLE  bMovlTargetGp;  // Bundle which sets target GP
    BYTE                rbCode[sizeof(DETOUR_IA64_BUNDLE)]; // moved bundle.
    DETOUR_IA64_BUNDLE  bBrlRemainEip;  // Brl to pbRemain
    // This must be adjacent to bBranchIslands.

    // Each instruction in the moved bundle could be a IP-relative chk or branch or call.
    // Any such instructions are changed to point to a brl in bBranchIslands.
    // This must be adjacent to bBrlRemainEip -- see "pbPool".
    DETOUR_IA64_BUNDLE bBranchIslands[DETOUR_IA64_INSTRUCTIONS_PER_BUNDLE];

    // Target of brl inserted in target function
    DETOUR_IA64_BUNDLE  bAllocFrame;    // alloc frame
    DETOUR_IA64_BUNDLE  bSave37to39;    // save r37, r38, r39.
    DETOUR_IA64_BUNDLE  bSave34to36;    // save r34, r35, r36.
    DETOUR_IA64_BUNDLE  bSaveGPto33;    // save gp, r32, r33.
    DETOUR_IA64_BUNDLE  bMovlDetourGp;  // set detour GP.
    DETOUR_IA64_BUNDLE  bCallDetour;    // call detour.
    DETOUR_IA64_BUNDLE  bPopFrameGp;    // pop frame and restore gp.
    DETOUR_IA64_BUNDLE  bReturn;        // return to caller.

    PLABEL_DESCRIPTOR   pldTrampoline;

    BYTE                rbRestore[sizeof(DETOUR_IA64_BUNDLE)]; // original target bundle.
    BYTE                cbRestore;      // size of original target code.
    BYTE                cbCode;         // size of moved target code.
    _DETOUR_ALIGN       rAlign[14];     // instruction alignment array.
    PBYTE               pbRemain;       // first instruction after moved code. [free list]
    PBYTE               pbDetour;       // first instruction of detour function.
    PPLABEL_DESCRIPTOR  ppldDetour;     // [pbDetour,gpDetour]
    PPLABEL_DESCRIPTOR  ppldTarget;     // [pbTarget,gpDetour]
};

C_ASSERT(sizeof(DETOUR_IA64_BUNDLE) == 16);
C_ASSERT(sizeof(_DETOUR_TRAMPOLINE) == 256 + DETOUR_IA64_INSTRUCTIONS_PER_BUNDLE * 16);

enum {
    SIZE_OF_JMP = sizeof(DETOUR_IA64_BUNDLE)
};

inline PBYTE detour_skip_jmp(PBYTE pPointer, PVOID *ppGlobals)
{
    PBYTE pGlobals = NULL;
    PBYTE pbCode = NULL;

    if (pPointer != NULL) {
        PPLABEL_DESCRIPTOR ppld = (PPLABEL_DESCRIPTOR)pPointer;
        pbCode = (PBYTE)ppld->EntryPoint;
        pGlobals = (PBYTE)ppld->GlobalPointer;
    }
    if (ppGlobals != NULL) {
        *ppGlobals = pGlobals;
    }
    if (pbCode == NULL) {
        return NULL;
    }

    DETOUR_IA64_BUNDLE *pb = (DETOUR_IA64_BUNDLE *)pbCode;

    // IA64 Local Import Jumps look like:
    //      addl   r2=ffffffff`ffe021c0, gp ;;
    //      ld8    r2=[r2]
    //      nop.i  0 ;;
    //
    //      ld8    r3=[r2], 8 ;;
    //      ld8    gp=[r2]
    //      mov    b6=r3, +0
    //
    //      nop.m  0
    //      nop.i  0
    //      br.cond.sptk.few b6
    //

    //                     002024000200100b
    if ((pb[0].wide[0] & 0xfffffc000603ffff) == 0x002024000200100b &&
        pb[0].wide[1] == 0x0004000000203008 &&
        pb[1].wide[0] == 0x001014180420180a &&
        pb[1].wide[1] == 0x07000830c0203008 &&
        pb[2].wide[0] == 0x0000000100000010 &&
        pb[2].wide[1] == 0x0080006000000200) {

        ULONG64 offset =
            ((pb[0].wide[0] & 0x0000000001fc0000) >> 18) |  // imm7b
            ((pb[0].wide[0] & 0x000001ff00000000) >> 25) |  // imm9d
            ((pb[0].wide[0] & 0x00000000f8000000) >> 11);   // imm5c
        if (pb[0].wide[0] & 0x0000020000000000) {           // sign
            offset |= 0xffffffffffe00000;
        }
        PBYTE pbTarget = pGlobals + offset;
        DETOUR_TRACE(("%p: potential import jump, target=%p\n", pb, pbTarget));

        if (detour_is_imported(pbCode, pbTarget) && *(PBYTE*)pbTarget != NULL) {
            DETOUR_TRACE(("%p: is import jump, label=%p\n", pb, *(PBYTE *)pbTarget));

            PPLABEL_DESCRIPTOR ppld = (PPLABEL_DESCRIPTOR)*(PBYTE *)pbTarget;
            pbCode = (PBYTE)ppld->EntryPoint;
            pGlobals = (PBYTE)ppld->GlobalPointer;
            if (ppGlobals != NULL) {
                *ppGlobals = pGlobals;
            }
        }
    }
    return pbCode;
}


inline void detour_find_jmp_bounds(PBYTE pbCode,
                                   PDETOUR_TRAMPOLINE *ppLower,
                                   PDETOUR_TRAMPOLINE *ppUpper)
{
    (void)pbCode;
    *ppLower = (PDETOUR_TRAMPOLINE)(ULONG_PTR)0x0000000000080000;
    *ppUpper = (PDETOUR_TRAMPOLINE)(ULONG_PTR)0xfffffffffff80000;
}

inline BOOL detour_does_code_end_function(PBYTE pbCode)
{
    // Routine not needed on IA64.
    (void)pbCode;
    return FALSE;
}

inline ULONG detour_is_code_filler(PBYTE pbCode)
{
    // Routine not needed on IA64.
    (void)pbCode;
    return 0;
}

#endif // DETOURS_IA64

#ifdef DETOURS_ARM

struct _DETOUR_TRAMPOLINE
{
    // A Thumb-2 instruction can be 2 or 4 bytes long.
    BYTE            rbCode[62];     // target code + jmp to pbRemain
    BYTE            cbCode;         // size of moved target code.
    BYTE            cbCodeBreak;    // padding to make debugging easier.
    BYTE            rbRestore[22];  // original target code.
    BYTE            cbRestore;      // size of original target code.
    BYTE            cbRestoreBreak; // padding to make debugging easier.
    _DETOUR_ALIGN   rAlign[8];      // instruction alignment array.
    PBYTE           pbRemain;       // first instruction after moved code. [free list]
    PBYTE           pbDetour;       // first instruction of detour function.
};

C_ASSERT(sizeof(_DETOUR_TRAMPOLINE) == 104);

enum {
    SIZE_OF_JMP = 8
};

inline PBYTE align4(PBYTE pValue)
{
    return (PBYTE)(((ULONG)pValue) & ~(ULONG)3u);
}

inline ULONG fetch_thumb_opcode(PBYTE pbCode)
{
    ULONG Opcode = *(UINT16 *)&pbCode[0];
    if (Opcode >= 0xe800) {
        Opcode = (Opcode << 16) | *(UINT16 *)&pbCode[2];
    }
    return Opcode;
}

inline void write_thumb_opcode(PBYTE &pbCode, ULONG Opcode)
{
    if (Opcode >= 0x10000) {
        *((UINT16*&)pbCode)++ = Opcode >> 16;
    }
    *((UINT16*&)pbCode)++ = (UINT16)Opcode;
}

PBYTE detour_gen_jmp_immediate(PBYTE pbCode, PBYTE *ppPool, PBYTE pbJmpVal)
{
    PBYTE pbLiteral;
    if (ppPool != NULL) {
        *ppPool = *ppPool - 4;
        pbLiteral = *ppPool;
    }
    else {
        pbLiteral = align4(pbCode + 6);
    }

    *((PBYTE*&)pbLiteral) = DETOURS_PBYTE_TO_PFUNC(pbJmpVal);
    LONG delta = pbLiteral - align4(pbCode + 4);

    write_thumb_opcode(pbCode, 0xf8dff000 | delta);     // LDR PC,[PC+n]

    if (ppPool == NULL) {
        if (((ULONG)pbCode & 2) != 0) {
            write_thumb_opcode(pbCode, 0xdefe);         // BREAK
        }
        pbCode += 4;
    }
    return pbCode;
}

inline PBYTE detour_gen_brk(PBYTE pbCode, PBYTE pbLimit)
{
    while (pbCode < pbLimit) {
        write_thumb_opcode(pbCode, 0xdefe);
    }
    return pbCode;
}

inline PBYTE detour_skip_jmp(PBYTE pbCode, PVOID *ppGlobals)
{
    if (pbCode == NULL) {
        return NULL;
    }
    if (ppGlobals != NULL) {
        *ppGlobals = NULL;
    }

    // Skip over the import jump if there is one.
    pbCode = (PBYTE)DETOURS_PFUNC_TO_PBYTE(pbCode);
    ULONG Opcode = fetch_thumb_opcode(pbCode);

    if ((Opcode & 0xfbf08f00) == 0xf2400c00) {          // movw r12,#xxxx
        ULONG Opcode2 = fetch_thumb_opcode(pbCode+4);

        if ((Opcode2 & 0xfbf08f00) == 0xf2c00c00) {      // movt r12,#xxxx
            ULONG Opcode3 = fetch_thumb_opcode(pbCode+8);
            if (Opcode3 == 0xf8dcf000) {                 // ldr  pc,[r12]
                PBYTE pbTarget = (PBYTE)(((Opcode2 << 12) & 0xf7000000) |
                                         ((Opcode2 <<  1) & 0x08000000) |
                                         ((Opcode2 << 16) & 0x00ff0000) |
                                         ((Opcode  >>  4) & 0x0000f700) |
                                         ((Opcode  >> 15) & 0x00000800) |
                                         ((Opcode  >>  0) & 0x000000ff));
                if (detour_is_imported(pbCode, pbTarget)) {
                    PBYTE pbNew = *(PBYTE *)pbTarget;
                    pbNew = DETOURS_PFUNC_TO_PBYTE(pbNew);
                    DETOUR_TRACE(("%p->%p: skipped over import table.\n", pbCode, pbNew));
                    return pbNew;
                }
            }
        }
    }
    return pbCode;
}

inline void detour_find_jmp_bounds(PBYTE pbCode,
                                   PDETOUR_TRAMPOLINE *ppLower,
                                   PDETOUR_TRAMPOLINE *ppUpper)
{
    // We have to place trampolines within +/- 2GB of code.
    ULONG_PTR lo = detour_2gb_below((ULONG_PTR)pbCode);
    ULONG_PTR hi = detour_2gb_above((ULONG_PTR)pbCode);
    DETOUR_TRACE(("[%p..%p..%p]\n", (PVOID)lo, pbCode, (PVOID)hi));

    *ppLower = (PDETOUR_TRAMPOLINE)lo;
    *ppUpper = (PDETOUR_TRAMPOLINE)hi;
}


inline BOOL detour_does_code_end_function(PBYTE pbCode)
{
    ULONG Opcode = fetch_thumb_opcode(pbCode);
    if ((Opcode & 0xffffff87) == 0x4700 ||          // bx <reg>
        (Opcode & 0xf800d000) == 0xf0009000) {      // b <imm20>
        return TRUE;
    }
    if ((Opcode & 0xffff8000) == 0xe8bd8000) {      // pop {...,pc}
        __debugbreak();
        return TRUE;
    }
    if ((Opcode & 0xffffff00) == 0x0000bd00) {      // pop {...,pc}
        __debugbreak();
        return TRUE;
    }
    return FALSE;
}

inline ULONG detour_is_code_filler(PBYTE pbCode)
{
    if (pbCode[0] == 0x00 && pbCode[1] == 0xbf) { // nop.
        return 2;
    }
    if (pbCode[0] == 0x00 && pbCode[1] == 0x00) { // zero-filled padding.
        return 2;
    }
    return 0;
}

#endif // DETOURS_ARM

#ifdef DETOURS_ARM64

struct _DETOUR_TRAMPOLINE
{
    // An ARM64 instruction is 4 bytes long.
    //
    // The overwrite is always composed of 3 instructions (12 bytes) which perform an indirect jump
    // using _DETOUR_TRAMPOLINE::pbDetour as the address holding the target location.
    //
    // Copied instructions can expand.
    //
    // The scheme using MovImmediate can cause an instruction
    // to grow as much as 6 times.
    // That would be Bcc or Tbz with a large address space:
    //   4 instructions to form immediate
    //   inverted tbz/bcc
    //   br
    //
    // An expansion of 4 is not uncommon -- bl/blr and small address space:
    //   3 instructions to form immediate
    //   br or brl
    //
    // A theoretical maximum for rbCode is thefore 4*4*6 + 16 = 112 (another 16 for jmp to pbRemain).
    //
    // With literals, the maximum expansion is 5, including the literals: 4*4*5 + 16 = 96.
    //
    // The number is rounded up to 128. m_rbScratchDst should match this.
    //
    BYTE            rbCode[128];    // target code + jmp to pbRemain
    BYTE            cbCode;         // size of moved target code.
    BYTE            cbCodeBreak[3]; // padding to make debugging easier.
    BYTE            rbRestore[24];  // original target code.
    BYTE            cbRestore;      // size of original target code.
    BYTE            cbRestoreBreak[3]; // padding to make debugging easier.
    _DETOUR_ALIGN   rAlign[8];      // instruction alignment array.
    PBYTE           pbRemain;       // first instruction after moved code. [free list]
    PBYTE           pbDetour;       // first instruction of detour function.
};

C_ASSERT(sizeof(_DETOUR_TRAMPOLINE) == 184);

enum {
    SIZE_OF_JMP = 12
};

inline ULONG fetch_opcode(PBYTE pbCode)
{
    return *(ULONG *)pbCode;
}

inline void write_opcode(PBYTE &pbCode, ULONG Opcode)
{
    *(ULONG *)pbCode = Opcode;
    pbCode += 4;
}

struct ARM64_INDIRECT_JMP {
    struct {
        ULONG Rd : 5;
        ULONG immhi : 19;
        ULONG iop : 5;
        ULONG immlo : 2;
        ULONG op : 1;
    } ardp;

    struct {
        ULONG Rt : 5;
        ULONG Rn : 5;
        ULONG imm : 12;
        ULONG opc : 2;
        ULONG iop1 : 2;
        ULONG V : 1;
        ULONG iop2 : 3;
        ULONG size : 2;
    } ldr;

    ULONG br;
};

#pragma warning(push)
#pragma warning(disable:4201)

union ARM64_INDIRECT_IMM {
    struct {
        ULONG64 pad : 12;
        ULONG64 adrp_immlo : 2;
        ULONG64 adrp_immhi : 19;
    };

    LONG64 value;
};

#pragma warning(pop)

PBYTE detour_gen_jmp_indirect(BYTE *pbCode, ULONG64 *pbJmpVal)
{
    // adrp x17, [jmpval]
    // ldr x17, [x17, jmpval]
    // br x17

    struct ARM64_INDIRECT_JMP *pIndJmp;
    union ARM64_INDIRECT_IMM jmpIndAddr;

    jmpIndAddr.value = (((LONG64)pbJmpVal) & 0xFFFFFFFFFFFFF000) - 
                       (((LONG64)pbCode) & 0xFFFFFFFFFFFFF000);

    pIndJmp = (struct ARM64_INDIRECT_JMP *)pbCode;
    pbCode = (BYTE *)(pIndJmp + 1);

    pIndJmp->ardp.Rd = 17;
    pIndJmp->ardp.immhi = jmpIndAddr.adrp_immhi;
    pIndJmp->ardp.iop = 0x10;
    pIndJmp->ardp.immlo = jmpIndAddr.adrp_immlo;
    pIndJmp->ardp.op = 1;

    pIndJmp->ldr.Rt = 17;
    pIndJmp->ldr.Rn = 17;
    pIndJmp->ldr.imm = (((ULONG64)pbJmpVal) & 0xFFF) / 8;
    pIndJmp->ldr.opc = 1;
    pIndJmp->ldr.iop1 = 1;
    pIndJmp->ldr.V = 0;
    pIndJmp->ldr.iop2 = 7;
    pIndJmp->ldr.size = 3;

    pIndJmp->br = 0xD61F0220;

    return pbCode;
}

PBYTE detour_gen_jmp_immediate(PBYTE pbCode, PBYTE *ppPool, PBYTE pbJmpVal)
{
    PBYTE pbLiteral;
    if (ppPool != NULL) {
        *ppPool = *ppPool - 8;
        pbLiteral = *ppPool;
    }
    else {
        pbLiteral = pbCode + 8;
    }

    *((PBYTE*&)pbLiteral) = pbJmpVal;
    LONG delta = (LONG)(pbLiteral - pbCode);

    write_opcode(pbCode, 0x58000011 | ((delta / 4) << 5));  // LDR X17,[PC+n]
    write_opcode(pbCode, 0xd61f0000 | (17 << 5));           // BR X17

    if (ppPool == NULL) {
        pbCode += 8;
    }
    return pbCode;
}

inline PBYTE detour_gen_brk(PBYTE pbCode, PBYTE pbLimit)
{
    while (pbCode < pbLimit) {
        write_opcode(pbCode, 0xd4100000 | (0xf000 << 5));
    }
    return pbCode;
}

inline INT64 detour_sign_extend(UINT64 value, UINT bits)
{
    const UINT left = 64 - bits;
    const INT64 m1 = -1;
    const INT64 wide = (INT64)(value << left);
    const INT64 sign = (wide < 0) ? (m1 << left) : 0;
    return value | sign;
}

inline PBYTE detour_skip_jmp(PBYTE pbCode, PVOID *ppGlobals)
{
    if (pbCode == NULL) {
        return NULL;
    }
    if (ppGlobals != NULL) {
        *ppGlobals = NULL;
    }

    // Skip over the import jump if there is one.
    pbCode = (PBYTE)pbCode;
    ULONG Opcode = fetch_opcode(pbCode);

    if ((Opcode & 0x9f00001f) == 0x90000010) {           // adrp  x16, IAT
        ULONG Opcode2 = fetch_opcode(pbCode + 4);

        if ((Opcode2 & 0xffe003ff) == 0xf9400210) {      // ldr   x16, [x16, IAT]
            ULONG Opcode3 = fetch_opcode(pbCode + 8);

            if (Opcode3 == 0xd61f0200) {                 // br    x16

/* https://static.docs.arm.com/ddi0487/bb/DDI0487B_b_armv8_arm.pdf
    The ADRP instruction shifts a signed, 21-bit immediate left by 12 bits, adds it to the value of the program counter with
    the bottom 12 bits cleared to zero, and then writes the result to a general-purpose register. This permits the
    calculation of the address at a 4KB aligned memory region. In conjunction with an ADD (immediate) instruction, or
    a Load/Store instruction with a 12-bit immediate offset, this allows for the calculation of, or access to, any address
    within +/- 4GB of the current PC.

PC-rel. addressing
    This section describes the encoding of the PC-rel. addressing instruction class. The encodings in this section are
    decoded from Data Processing -- Immediate on page C4-226.
    Add/subtract (immediate)
    This section describes the encoding of the Add/subtract (immediate) instruction class. The encodings in this section
    are decoded from Data Processing -- Immediate on page C4-226.
    Decode fields
    Instruction page
    op
    0 ADR
    1 ADRP

C6.2.10 ADRP
    Form PC-relative address to 4KB page adds an immediate value that is shifted left by 12 bits, to the PC value to
    form a PC-relative address, with the bottom 12 bits masked out, and writes the result to the destination register.
    ADRP <Xd>, <label>
    imm = SignExtend(immhi:immlo:Zeros(12), 64);

    31  30 29 28 27 26 25 24 23 5    4 0
    1   immlo  1  0  0  0  0  immhi  Rd
         9             0

Rd is hardcoded as 0x10 above.
Immediate is 21 signed bits split into 2 bits and 19 bits, and is scaled by 4K.
*/
                UINT64 const pageLow2 = (Opcode >> 29) & 3;
                UINT64 const pageHigh19 = (Opcode >> 5) & ~(~0ui64 << 19);
                INT64 const page = detour_sign_extend((pageHigh19 << 2) | pageLow2, 21) << 12;

/* https://static.docs.arm.com/ddi0487/bb/DDI0487B_b_armv8_arm.pdf

    C6.2.101 LDR (immediate)
    Load Register (immediate) loads a word or doubleword from memory and writes it to a register. The address that is
    used for the load is calculated from a base register and an immediate offset.
    The Unsigned offset variant scales the immediate offset value by the size of the value accessed before adding it
    to the base register value.

Unsigned offset
64-bit variant Applies when size == 11.
    31 30 29 28  27 26 25 24  23 22  21   10   9 5   4 0
     1  x  1  1   1  0  0  1   0  1  imm12      Rn    Rt
         F             9        4              200    10

That is, two low 5 bit fields are registers, hardcoded as 0x10 and 0x10 << 5 above,
then unsigned size-unscaled (8) 12-bit offset, then opcode bits 0xF94.
*/
                UINT64 const offset = ((Opcode2 >> 10) & ~(~0ui64 << 12)) << 3;

                PBYTE const pbTarget = (PBYTE)((ULONG64)pbCode & 0xfffffffffffff000ULL) + page + offset;

                if (detour_is_imported(pbCode, pbTarget)) {
                    PBYTE pbNew = *(PBYTE *)pbTarget;
                    DETOUR_TRACE(("%p->%p: skipped over import table.\n", pbCode, pbNew));
                    return pbNew;
                }
            }
        }
    }
    return pbCode;
}

inline void detour_find_jmp_bounds(PBYTE pbCode,
                                   PDETOUR_TRAMPOLINE *ppLower,
                                   PDETOUR_TRAMPOLINE *ppUpper)
{
    // The encoding used by detour_gen_jmp_indirect actually enables a
    // displacement of +/- 4GiB. In the future, this could be changed to
    // reflect that. For now, just reuse the x86 logic which is plenty.

    ULONG_PTR lo = detour_2gb_below((ULONG_PTR)pbCode);
    ULONG_PTR hi = detour_2gb_above((ULONG_PTR)pbCode);
    DETOUR_TRACE(("[%p..%p..%p]\n", (PVOID)lo, pbCode, (PVOID)hi));

    *ppLower = (PDETOUR_TRAMPOLINE)lo;
    *ppUpper = (PDETOUR_TRAMPOLINE)hi;
}

inline BOOL detour_does_code_end_function(PBYTE pbCode)
{
    ULONG Opcode = fetch_opcode(pbCode);
    if ((Opcode & 0xfffffc1f) == 0xd65f0000 ||      // br <reg>
        (Opcode & 0xfc000000) == 0x14000000) {      // b <imm26>
        return TRUE;
    }
    return FALSE;
}

inline ULONG detour_is_code_filler(PBYTE pbCode)
{
    if (*(ULONG *)pbCode == 0xd503201f) {   // nop.
        return 4;
    }
    if (*(ULONG *)pbCode == 0x00000000) {   // zero-filled padding.
        return 4;
    }
    return 0;
}

#endif // DETOURS_ARM64

//////////////////////////////////////////////// Trampoline Memory Management.
//
struct DETOUR_REGION
{
    ULONG               dwSignature;
    DETOUR_REGION *     pNext;  // Next region in list of regions.
    DETOUR_TRAMPOLINE * pFree;  // List of free trampolines in this region.
};
typedef DETOUR_REGION * PDETOUR_REGION;

const ULONG DETOUR_REGION_SIGNATURE = 'Rrtd';
const ULONG DETOUR_REGION_SIZE = 0x10000;
const ULONG DETOUR_TRAMPOLINES_PER_REGION = (DETOUR_REGION_SIZE
                                             / sizeof(DETOUR_TRAMPOLINE)) - 1;
static PDETOUR_REGION s_pRegions = NULL;            // List of all regions.
static PDETOUR_REGION s_pRegion = NULL;             // Default region.

static DWORD detour_writable_trampoline_regions()
{
    // Mark all of the regions as writable.
    for (PDETOUR_REGION pRegion = s_pRegions; pRegion != NULL; pRegion = pRegion->pNext) {
        DWORD dwOld;
        if (!VirtualProtect(pRegion, DETOUR_REGION_SIZE, PAGE_EXECUTE_READWRITE, &dwOld)) {
            return GetLastError();
        }
    }
    return NO_ERROR;
}

static void detour_runnable_trampoline_regions()
{
    HANDLE hProcess = GetCurrentProcess();

    // Mark all of the regions as executable.
    for (PDETOUR_REGION pRegion = s_pRegions; pRegion != NULL; pRegion = pRegion->pNext) {
        DWORD dwOld;
        VirtualProtect(pRegion, DETOUR_REGION_SIZE, PAGE_EXECUTE_READ, &dwOld);
        FlushInstructionCache(hProcess, pRegion, DETOUR_REGION_SIZE);
    }
}

static PBYTE detour_alloc_round_down_to_region(PBYTE pbTry)
{
    // WinXP64 returns free areas that aren't REGION aligned to 32-bit applications.
    ULONG_PTR extra = ((ULONG_PTR)pbTry) & (DETOUR_REGION_SIZE - 1);
    if (extra != 0) {
        pbTry -= extra;
    }
    return pbTry;
}

static PBYTE detour_alloc_round_up_to_region(PBYTE pbTry)
{
    // WinXP64 returns free areas that aren't REGION aligned to 32-bit applications.
    ULONG_PTR extra = ((ULONG_PTR)pbTry) & (DETOUR_REGION_SIZE - 1);
    if (extra != 0) {
        ULONG_PTR adjust = DETOUR_REGION_SIZE - extra;
        pbTry += adjust;
    }
    return pbTry;
}

// Starting at pbLo, try to allocate a memory region, continue until pbHi.

static PVOID detour_alloc_region_from_lo(PBYTE pbLo, PBYTE pbHi)
{
    PBYTE pbTry = detour_alloc_round_up_to_region(pbLo);

    DETOUR_TRACE((" Looking for free region in %p..%p from %p:\n", pbLo, pbHi, pbTry));

    for (; pbTry < pbHi;) {
        MEMORY_BASIC_INFORMATION mbi;

        if (pbTry >= s_pSystemRegionLowerBound && pbTry <= s_pSystemRegionUpperBound) {
            // Skip region reserved for system DLLs, but preserve address space entropy.
            pbTry += 0x08000000;
            continue;
        }

        ZeroMemory(&mbi, sizeof(mbi));
        if (!VirtualQuery(pbTry, &mbi, sizeof(mbi))) {
            break;
        }

        DETOUR_TRACE(("  Try %p => %p..%p %6lx\n",
                      pbTry,
                      mbi.BaseAddress,
                      (PBYTE)mbi.BaseAddress + mbi.RegionSize - 1,
                      mbi.State));

        if (mbi.State == MEM_FREE && mbi.RegionSize >= DETOUR_REGION_SIZE) {

            PVOID pv = VirtualAlloc(pbTry,
                                    DETOUR_REGION_SIZE,
                                    MEM_COMMIT|MEM_RESERVE,
                                    PAGE_EXECUTE_READWRITE);
            if (pv != NULL) {
                return pv;
            }
            else if (GetLastError() == ERROR_DYNAMIC_CODE_BLOCKED) {
                return NULL;
            }
            pbTry += DETOUR_REGION_SIZE;
        }
        else {
            pbTry = detour_alloc_round_up_to_region((PBYTE)mbi.BaseAddress + mbi.RegionSize);
        }
    }
    return NULL;
}

// Starting at pbHi, try to allocate a memory region, continue until pbLo.

static PVOID detour_alloc_region_from_hi(PBYTE pbLo, PBYTE pbHi)
{
    PBYTE pbTry = detour_alloc_round_down_to_region(pbHi - DETOUR_REGION_SIZE);

    DETOUR_TRACE((" Looking for free region in %p..%p from %p:\n", pbLo, pbHi, pbTry));

    for (; pbTry > pbLo;) {
        MEMORY_BASIC_INFORMATION mbi;

        DETOUR_TRACE(("  Try %p\n", pbTry));
        if (pbTry >= s_pSystemRegionLowerBound && pbTry <= s_pSystemRegionUpperBound) {
            // Skip region reserved for system DLLs, but preserve address space entropy.
            pbTry -= 0x08000000;
            continue;
        }

        ZeroMemory(&mbi, sizeof(mbi));
        if (!VirtualQuery(pbTry, &mbi, sizeof(mbi))) {
            break;
        }

        DETOUR_TRACE(("  Try %p => %p..%p %6lx\n",
                      pbTry,
                      mbi.BaseAddress,
                      (PBYTE)mbi.BaseAddress + mbi.RegionSize - 1,
                      mbi.State));

        if (mbi.State == MEM_FREE && mbi.RegionSize >= DETOUR_REGION_SIZE) {

            PVOID pv = VirtualAlloc(pbTry,
                                    DETOUR_REGION_SIZE,
                                    MEM_COMMIT|MEM_RESERVE,
                                    PAGE_EXECUTE_READWRITE);
            if (pv != NULL) {
                return pv;
            }
            else if (GetLastError() == ERROR_DYNAMIC_CODE_BLOCKED) {
                return NULL;
            }
            pbTry -= DETOUR_REGION_SIZE;
        }
        else {
            pbTry = detour_alloc_round_down_to_region((PBYTE)mbi.AllocationBase
                                                      - DETOUR_REGION_SIZE);
        }
    }
    return NULL;
}

static PVOID detour_alloc_trampoline_allocate_new(PBYTE pbTarget,
                                                  PDETOUR_TRAMPOLINE pLo,
                                                  PDETOUR_TRAMPOLINE pHi)
{
    PVOID pbTry = NULL;

    // NB: We must always also start the search at an offset from pbTarget
    //     in order to maintain ASLR entropy.

#if defined(DETOURS_64BIT)
    // Try looking 1GB below or lower.
    if (pbTry == NULL && pbTarget > (PBYTE)0x40000000) {
        pbTry = detour_alloc_region_from_hi((PBYTE)pLo, pbTarget - 0x40000000);
    }
    // Try looking 1GB above or higher.
    if (pbTry == NULL && pbTarget < (PBYTE)0xffffffff40000000) {
        pbTry = detour_alloc_region_from_lo(pbTarget + 0x40000000, (PBYTE)pHi);
    }
    // Try looking 1GB below or higher.
    if (pbTry == NULL && pbTarget > (PBYTE)0x40000000) {
        pbTry = detour_alloc_region_from_lo(pbTarget - 0x40000000, pbTarget);
    }
    // Try looking 1GB above or lower.
    if (pbTry == NULL && pbTarget < (PBYTE)0xffffffff40000000) {
        pbTry = detour_alloc_region_from_hi(pbTarget, pbTarget + 0x40000000);
    }
#endif

    // Try anything below.
    if (pbTry == NULL) {
        pbTry = detour_alloc_region_from_hi((PBYTE)pLo, pbTarget);
    }
    // try anything above.
    if (pbTry == NULL) {
        pbTry = detour_alloc_region_from_lo(pbTarget, (PBYTE)pHi);
    }

    return pbTry;
}

PVOID WINAPI DetourAllocateRegionWithinJumpBounds(_In_ LPCVOID pbTarget,
                                                  _Out_ PDWORD pcbAllocatedSize)
{
    PDETOUR_TRAMPOLINE pLo;
    PDETOUR_TRAMPOLINE pHi;
    detour_find_jmp_bounds((PBYTE)pbTarget, &pLo, &pHi);

    PVOID pbNewlyAllocated =
        detour_alloc_trampoline_allocate_new((PBYTE)pbTarget, pLo, pHi);
    if (pbNewlyAllocated == NULL) {
        DETOUR_TRACE(("Couldn't find available memory region!\n"));
        *pcbAllocatedSize = 0;
        return NULL;
    }

    *pcbAllocatedSize = DETOUR_REGION_SIZE;
    return pbNewlyAllocated;
}

static PDETOUR_TRAMPOLINE detour_alloc_trampoline(PBYTE pbTarget)
{
    // We have to place trampolines within +/- 2GB of target.

    PDETOUR_TRAMPOLINE pLo;
    PDETOUR_TRAMPOLINE pHi;

    detour_find_jmp_bounds(pbTarget, &pLo, &pHi);

    PDETOUR_TRAMPOLINE pTrampoline = NULL;

    // Insure that there is a default region.
    if (s_pRegion == NULL && s_pRegions != NULL) {
        s_pRegion = s_pRegions;
    }

    // First check the default region for an valid free block.
    if (s_pRegion != NULL && s_pRegion->pFree != NULL &&
        s_pRegion->pFree >= pLo && s_pRegion->pFree <= pHi) {

      found_region:
        pTrampoline = s_pRegion->pFree;
        // do a last sanity check on region.
        if (pTrampoline < pLo || pTrampoline > pHi) {
            return NULL;
        }
        s_pRegion->pFree = (PDETOUR_TRAMPOLINE)pTrampoline->pbRemain;
        memset(pTrampoline, 0xcc, sizeof(*pTrampoline));
        return pTrampoline;
    }

    // Then check the existing regions for a valid free block.
    for (s_pRegion = s_pRegions; s_pRegion != NULL; s_pRegion = s_pRegion->pNext) {
        if (s_pRegion != NULL && s_pRegion->pFree != NULL &&
            s_pRegion->pFree >= pLo && s_pRegion->pFree <= pHi) {
            goto found_region;
        }
    }

    // We need to allocate a new region.

    // Round pbTarget down to 64KB block.
    pbTarget = pbTarget - (PtrToUlong(pbTarget) & 0xffff);

    PVOID pbNewlyAllocated =
        detour_alloc_trampoline_allocate_new(pbTarget, pLo, pHi);
    if (pbNewlyAllocated != NULL) {
        s_pRegion = (DETOUR_REGION*)pbNewlyAllocated;
        s_pRegion->dwSignature = DETOUR_REGION_SIGNATURE;
        s_pRegion->pFree = NULL;
        s_pRegion->pNext = s_pRegions;
        s_pRegions = s_pRegion;
        DETOUR_TRACE(("  Allocated region %p..%p\n\n",
                      s_pRegion, ((PBYTE)s_pRegion) + DETOUR_REGION_SIZE - 1));

        // Put everything but the first trampoline on the free list.
        PBYTE pFree = NULL;
        pTrampoline = ((PDETOUR_TRAMPOLINE)s_pRegion) + 1;
        for (int i = DETOUR_TRAMPOLINES_PER_REGION - 1; i > 1; i--) {
            pTrampoline[i].pbRemain = pFree;
            pFree = (PBYTE)&pTrampoline[i];
        }
        s_pRegion->pFree = (PDETOUR_TRAMPOLINE)pFree;
        goto found_region;
    }

    DETOUR_TRACE(("Couldn't find available memory region!\n"));
    return NULL;
}

static void detour_free_trampoline(PDETOUR_TRAMPOLINE pTrampoline)
{
    PDETOUR_REGION pRegion = (PDETOUR_REGION)
        ((ULONG_PTR)pTrampoline & ~(ULONG_PTR)0xffff);

    memset(pTrampoline, 0, sizeof(*pTrampoline));
    pTrampoline->pbRemain = (PBYTE)pRegion->pFree;
    pRegion->pFree = pTrampoline;
}

static BOOL detour_is_region_empty(PDETOUR_REGION pRegion)
{
    // Stop if the region isn't a region (this would be bad).
    if (pRegion->dwSignature != DETOUR_REGION_SIGNATURE) {
        return FALSE;
    }

    PBYTE pbRegionBeg = (PBYTE)pRegion;
    PBYTE pbRegionLim  = pbRegionBeg + DETOUR_REGION_SIZE;

    // Stop if any of the trampolines aren't free.
    PDETOUR_TRAMPOLINE pTrampoline = ((PDETOUR_TRAMPOLINE)pRegion) + 1;
    for (int i = 0; i < DETOUR_TRAMPOLINES_PER_REGION; i++) {
        if (pTrampoline[i].pbRemain != NULL &&
            (pTrampoline[i].pbRemain < pbRegionBeg ||
             pTrampoline[i].pbRemain >= pbRegionLim)) {
            return FALSE;
        }
    }

    // OK, the region is empty.
    return TRUE;
}

static void detour_free_unused_trampoline_regions()
{
    PDETOUR_REGION *ppRegionBase = &s_pRegions;
    PDETOUR_REGION pRegion = s_pRegions;

    while (pRegion != NULL) {
        if (detour_is_region_empty(pRegion)) {
            *ppRegionBase = pRegion->pNext;

            VirtualFree(pRegion, 0, MEM_RELEASE);
            s_pRegion = NULL;
        }
        else {
            ppRegionBase = &pRegion->pNext;
        }
        pRegion = *ppRegionBase;
    }
}

///////////////////////////////////////////////////////// Transaction Structs.
//
struct DetourThread
{
    DetourThread *      pNext;
    HANDLE              hThread;
};

struct DetourOperation
{
    DetourOperation *   pNext;
    BOOL                fIsRemove;
    PBYTE *             ppbPointer;
    PBYTE               pbTarget;
    PDETOUR_TRAMPOLINE  pTrampoline;
    ULONG               dwPerm;
};

static BOOL                 s_fIgnoreTooSmall       = FALSE;
static BOOL                 s_fRetainRegions        = FALSE;

static LONG                 s_nPendingThreadId      = 0; // Thread owning pending transaction.
static LONG                 s_nPendingError         = NO_ERROR;
static PVOID *              s_ppPendingError        = NULL;
static DetourThread *       s_pPendingThreads       = NULL;
static DetourOperation *    s_pPendingOperations    = NULL;

//////////////////////////////////////////////////////////////////////////////
//
PVOID WINAPI DetourCodeFromPointer(_In_ PVOID pPointer,
                                   _Out_opt_ PVOID *ppGlobals)
{
    return detour_skip_jmp((PBYTE)pPointer, ppGlobals);
}

//////////////////////////////////////////////////////////// Transaction APIs.
//
BOOL WINAPI DetourSetIgnoreTooSmall(_In_ BOOL fIgnore)
{
    BOOL fPrevious = s_fIgnoreTooSmall;
    s_fIgnoreTooSmall = fIgnore;
    return fPrevious;
}

BOOL WINAPI DetourSetRetainRegions(_In_ BOOL fRetain)
{
    BOOL fPrevious = s_fRetainRegions;
    s_fRetainRegions = fRetain;
    return fPrevious;
}

PVOID WINAPI DetourSetSystemRegionLowerBound(_In_ PVOID pSystemRegionLowerBound)
{
    PVOID pPrevious = s_pSystemRegionLowerBound;
    s_pSystemRegionLowerBound = pSystemRegionLowerBound;
    return pPrevious;
}

PVOID WINAPI DetourSetSystemRegionUpperBound(_In_ PVOID pSystemRegionUpperBound)
{
    PVOID pPrevious = s_pSystemRegionUpperBound;
    s_pSystemRegionUpperBound = pSystemRegionUpperBound;
    return pPrevious;
}

LONG WINAPI DetourTransactionBegin()
{
    // Only one transaction is allowed at a time.
_Benign_race_begin_
    if (s_nPendingThreadId != 0) {
        return ERROR_INVALID_OPERATION;
    }
_Benign_race_end_

    // Make sure only one thread can start a transaction.
    if (InterlockedCompareExchange(&s_nPendingThreadId, (LONG)GetCurrentThreadId(), 0) != 0) {
        return ERROR_INVALID_OPERATION;
    }

    s_pPendingOperations = NULL;
    s_pPendingThreads = NULL;
    s_ppPendingError = NULL;

    // Make sure the trampoline pages are writable.
    s_nPendingError = detour_writable_trampoline_regions();

    return s_nPendingError;
}

LONG WINAPI DetourTransactionAbort()
{
    if (s_nPendingThreadId != (LONG)GetCurrentThreadId()) {
        return ERROR_INVALID_OPERATION;
    }

    // Restore all of the page permissions.
    for (DetourOperation *o = s_pPendingOperations; o != NULL;) {
        // We don't care if this fails, because the code is still accessible.
        DWORD dwOld;
        VirtualProtect(o->pbTarget, o->pTrampoline->cbRestore,
                       o->dwPerm, &dwOld);

        if (!o->fIsRemove) {
            if (o->pTrampoline) {
                detour_free_trampoline(o->pTrampoline);
                o->pTrampoline = NULL;
            }
        }

        DetourOperation *n = o->pNext;
        delete o;
        o = n;
    }
    s_pPendingOperations = NULL;

    // Make sure the trampoline pages are no longer writable.
    detour_runnable_trampoline_regions();

    // Resume any suspended threads.
    for (DetourThread *t = s_pPendingThreads; t != NULL;) {
        // There is nothing we can do if this fails.
        ResumeThread(t->hThread);

        DetourThread *n = t->pNext;
        delete t;
        t = n;
    }
    s_pPendingThreads = NULL;
    s_nPendingThreadId = 0;

    return NO_ERROR;
}

LONG WINAPI DetourTransactionCommit()
{
    return DetourTransactionCommitEx(NULL);
}

static BYTE detour_align_from_trampoline(PDETOUR_TRAMPOLINE pTrampoline, BYTE obTrampoline)
{
    for (LONG n = 0; n < ARRAYSIZE(pTrampoline->rAlign); n++) {
        if (pTrampoline->rAlign[n].obTrampoline == obTrampoline) {
            return pTrampoline->rAlign[n].obTarget;
        }
    }
    return 0;
}

static LONG detour_align_from_target(PDETOUR_TRAMPOLINE pTrampoline, LONG obTarget)
{
    for (LONG n = 0; n < ARRAYSIZE(pTrampoline->rAlign); n++) {
        if (pTrampoline->rAlign[n].obTarget == obTarget) {
            return pTrampoline->rAlign[n].obTrampoline;
        }
    }
    return 0;
}

LONG WINAPI DetourTransactionCommitEx(_Out_opt_ PVOID **pppFailedPointer)
{
    if (pppFailedPointer != NULL) {
        // Used to get the last error.
        *pppFailedPointer = s_ppPendingError;
    }
    if (s_nPendingThreadId != (LONG)GetCurrentThreadId()) {
        return ERROR_INVALID_OPERATION;
    }

    // If any of the pending operations failed, then we abort the whole transaction.
    if (s_nPendingError != NO_ERROR) {
        DETOUR_BREAK();
        DetourTransactionAbort();
        return s_nPendingError;
    }

    // Common variables.
    DetourOperation *o;
    DetourThread *t;
    BOOL freed = FALSE;

    // Insert or remove each of the detours.
    for (o = s_pPendingOperations; o != NULL; o = o->pNext) {
        if (o->fIsRemove) {
            CopyMemory(o->pbTarget,
                       o->pTrampoline->rbRestore,
                       o->pTrampoline->cbRestore);
#ifdef DETOURS_IA64
            *o->ppbPointer = (PBYTE)o->pTrampoline->ppldTarget;
#endif // DETOURS_IA64

#ifdef DETOURS_X86
            *o->ppbPointer = o->pbTarget;
#endif // DETOURS_X86

#ifdef DETOURS_X64
            *o->ppbPointer = o->pbTarget;
#endif // DETOURS_X64

#ifdef DETOURS_ARM
            *o->ppbPointer = DETOURS_PBYTE_TO_PFUNC(o->pbTarget);
#endif // DETOURS_ARM

#ifdef DETOURS_ARM64
            *o->ppbPointer = o->pbTarget;
#endif // DETOURS_ARM
        }
        else {
            DETOUR_TRACE(("detours: pbTramp =%p, pbRemain=%p, pbDetour=%p, cbRestore=%u\n",
                          o->pTrampoline,
                          o->pTrampoline->pbRemain,
                          o->pTrampoline->pbDetour,
                          o->pTrampoline->cbRestore));

            DETOUR_TRACE(("detours: pbTarget=%p: "
                          "%02x %02x %02x %02x "
                          "%02x %02x %02x %02x "
                          "%02x %02x %02x %02x [before]\n",
                          o->pbTarget,
                          o->pbTarget[0], o->pbTarget[1], o->pbTarget[2], o->pbTarget[3],
                          o->pbTarget[4], o->pbTarget[5], o->pbTarget[6], o->pbTarget[7],
                          o->pbTarget[8], o->pbTarget[9], o->pbTarget[10], o->pbTarget[11]));

#ifdef DETOURS_IA64
            ((DETOUR_IA64_BUNDLE*)o->pbTarget)
                ->SetBrl((UINT64)&o->pTrampoline->bAllocFrame);
            *o->ppbPointer = (PBYTE)&o->pTrampoline->pldTrampoline;
#endif // DETOURS_IA64

#ifdef DETOURS_X64
            detour_gen_jmp_indirect(o->pTrampoline->rbCodeIn, &o->pTrampoline->pbDetour);
            PBYTE pbCode = detour_gen_jmp_immediate(o->pbTarget, o->pTrampoline->rbCodeIn);
            pbCode = detour_gen_brk(pbCode, o->pTrampoline->pbRemain);
            *o->ppbPointer = o->pTrampoline->rbCode;
            UNREFERENCED_PARAMETER(pbCode);
#endif // DETOURS_X64

#ifdef DETOURS_X86
            PBYTE pbCode = detour_gen_jmp_immediate(o->pbTarget, o->pTrampoline->pbDetour);
            pbCode = detour_gen_brk(pbCode, o->pTrampoline->pbRemain);
            *o->ppbPointer = o->pTrampoline->rbCode;
            UNREFERENCED_PARAMETER(pbCode);
#endif // DETOURS_X86

#ifdef DETOURS_ARM
            PBYTE pbCode = detour_gen_jmp_immediate(o->pbTarget, NULL, o->pTrampoline->pbDetour);
            pbCode = detour_gen_brk(pbCode, o->pTrampoline->pbRemain);
            *o->ppbPointer = DETOURS_PBYTE_TO_PFUNC(o->pTrampoline->rbCode);
            UNREFERENCED_PARAMETER(pbCode);
#endif // DETOURS_ARM

#ifdef DETOURS_ARM64
            PBYTE pbCode = detour_gen_jmp_indirect(o->pbTarget, (ULONG64*)&(o->pTrampoline->pbDetour));
            pbCode = detour_gen_brk(pbCode, o->pTrampoline->pbRemain);
            *o->ppbPointer = o->pTrampoline->rbCode;
            UNREFERENCED_PARAMETER(pbCode);
#endif // DETOURS_ARM64

            DETOUR_TRACE(("detours: pbTarget=%p: "
                          "%02x %02x %02x %02x "
                          "%02x %02x %02x %02x "
                          "%02x %02x %02x %02x [after]\n",
                          o->pbTarget,
                          o->pbTarget[0], o->pbTarget[1], o->pbTarget[2], o->pbTarget[3],
                          o->pbTarget[4], o->pbTarget[5], o->pbTarget[6], o->pbTarget[7],
                          o->pbTarget[8], o->pbTarget[9], o->pbTarget[10], o->pbTarget[11]));

            DETOUR_TRACE(("detours: pbTramp =%p: "
                          "%02x %02x %02x %02x "
                          "%02x %02x %02x %02x "
                          "%02x %02x %02x %02x\n",
                          o->pTrampoline,
                          o->pTrampoline->rbCode[0], o->pTrampoline->rbCode[1],
                          o->pTrampoline->rbCode[2], o->pTrampoline->rbCode[3],
                          o->pTrampoline->rbCode[4], o->pTrampoline->rbCode[5],
                          o->pTrampoline->rbCode[6], o->pTrampoline->rbCode[7],
                          o->pTrampoline->rbCode[8], o->pTrampoline->rbCode[9],
                          o->pTrampoline->rbCode[10], o->pTrampoline->rbCode[11]));

#ifdef DETOURS_IA64
            DETOUR_TRACE(("\n"));
            DETOUR_TRACE(("detours:  &pldTrampoline  =%p\n",
                          &o->pTrampoline->pldTrampoline));
            DETOUR_TRACE(("detours:  &bMovlTargetGp  =%p [%p]\n",
                          &o->pTrampoline->bMovlTargetGp,
                          o->pTrampoline->bMovlTargetGp.GetMovlGp()));
            DETOUR_TRACE(("detours:  &rbCode         =%p [%p]\n",
                          &o->pTrampoline->rbCode,
                          ((DETOUR_IA64_BUNDLE&)o->pTrampoline->rbCode).GetBrlTarget()));
            DETOUR_TRACE(("detours:  &bBrlRemainEip  =%p [%p]\n",
                          &o->pTrampoline->bBrlRemainEip,
                          o->pTrampoline->bBrlRemainEip.GetBrlTarget()));
            DETOUR_TRACE(("detours:  &bMovlDetourGp  =%p [%p]\n",
                          &o->pTrampoline->bMovlDetourGp,
                          o->pTrampoline->bMovlDetourGp.GetMovlGp()));
            DETOUR_TRACE(("detours:  &bBrlDetourEip  =%p [%p]\n",
                          &o->pTrampoline->bCallDetour,
                          o->pTrampoline->bCallDetour.GetBrlTarget()));
            DETOUR_TRACE(("detours:  pldDetour       =%p [%p]\n",
                          o->pTrampoline->ppldDetour->EntryPoint,
                          o->pTrampoline->ppldDetour->GlobalPointer));
            DETOUR_TRACE(("detours:  pldTarget       =%p [%p]\n",
                          o->pTrampoline->ppldTarget->EntryPoint,
                          o->pTrampoline->ppldTarget->GlobalPointer));
            DETOUR_TRACE(("detours:  pbRemain        =%p\n",
                          o->pTrampoline->pbRemain));
            DETOUR_TRACE(("detours:  pbDetour        =%p\n",
                          o->pTrampoline->pbDetour));
            DETOUR_TRACE(("\n"));
#endif // DETOURS_IA64
        }
    }

    // Update any suspended threads.
    for (t = s_pPendingThreads; t != NULL; t = t->pNext) {
        CONTEXT cxt;
        cxt.ContextFlags = CONTEXT_CONTROL;

#undef DETOURS_EIP

#ifdef DETOURS_X86
#define DETOURS_EIP         Eip
#endif // DETOURS_X86

#ifdef DETOURS_X64
#define DETOURS_EIP         Rip
#endif // DETOURS_X64

#ifdef DETOURS_IA64
#define DETOURS_EIP         StIIP
#endif // DETOURS_IA64

#ifdef DETOURS_ARM
#define DETOURS_EIP         Pc
#endif // DETOURS_ARM

#ifdef DETOURS_ARM64
#define DETOURS_EIP         Pc
#endif // DETOURS_ARM64

typedef ULONG_PTR DETOURS_EIP_TYPE;

        if (GetThreadContext(t->hThread, &cxt)) {
            for (o = s_pPendingOperations; o != NULL; o = o->pNext) {
                if (o->fIsRemove) {
                    if (cxt.DETOURS_EIP >= (DETOURS_EIP_TYPE)(ULONG_PTR)o->pTrampoline &&
                        cxt.DETOURS_EIP < (DETOURS_EIP_TYPE)((ULONG_PTR)o->pTrampoline
                                                             + sizeof(o->pTrampoline))
                       ) {

                        cxt.DETOURS_EIP = (DETOURS_EIP_TYPE)
                            ((ULONG_PTR)o->pbTarget
                             + detour_align_from_trampoline(o->pTrampoline,
                                                            (BYTE)(cxt.DETOURS_EIP
                                                                   - (DETOURS_EIP_TYPE)(ULONG_PTR)
                                                                   o->pTrampoline)));

                        SetThreadContext(t->hThread, &cxt);
                    }
                }
                else {
                    if (cxt.DETOURS_EIP >= (DETOURS_EIP_TYPE)(ULONG_PTR)o->pbTarget &&
                        cxt.DETOURS_EIP < (DETOURS_EIP_TYPE)((ULONG_PTR)o->pbTarget
                                                             + o->pTrampoline->cbRestore)
                       ) {

                        cxt.DETOURS_EIP = (DETOURS_EIP_TYPE)
                            ((ULONG_PTR)o->pTrampoline
                             + detour_align_from_target(o->pTrampoline,
                                                        (BYTE)(cxt.DETOURS_EIP
                                                               - (DETOURS_EIP_TYPE)(ULONG_PTR)
                                                               o->pbTarget)));

                        SetThreadContext(t->hThread, &cxt);
                    }
                }
            }
        }
#undef DETOURS_EIP
    }

    // Restore all of the page permissions and flush the icache.
    HANDLE hProcess = GetCurrentProcess();
    for (o = s_pPendingOperations; o != NULL;) {
        // We don't care if this fails, because the code is still accessible.
        DWORD dwOld;
        VirtualProtect(o->pbTarget, o->pTrampoline->cbRestore, o->dwPerm, &dwOld);
        FlushInstructionCache(hProcess, o->pbTarget, o->pTrampoline->cbRestore);

        if (o->fIsRemove && o->pTrampoline) {
            detour_free_trampoline(o->pTrampoline);
            o->pTrampoline = NULL;
            freed = true;
        }

        DetourOperation *n = o->pNext;
        delete o;
        o = n;
    }
    s_pPendingOperations = NULL;

    // Free any trampoline regions that are now unused.
    if (freed && !s_fRetainRegions) {
        detour_free_unused_trampoline_regions();
    }

    // Make sure the trampoline pages are no longer writable.
    detour_runnable_trampoline_regions();

    // Resume any suspended threads.
    for (t = s_pPendingThreads; t != NULL;) {
        // There is nothing we can do if this fails.
        ResumeThread(t->hThread);

        DetourThread *n = t->pNext;
        delete t;
        t = n;
    }
    s_pPendingThreads = NULL;
    s_nPendingThreadId = 0;

    if (pppFailedPointer != NULL) {
        *pppFailedPointer = s_ppPendingError;
    }

    return s_nPendingError;
}

LONG WINAPI DetourUpdateThread(_In_ HANDLE hThread)
{
    LONG error;

    // If any of the pending operations failed, then we don't need to do this.
    if (s_nPendingError != NO_ERROR) {
        return s_nPendingError;
    }

    // Silently (and safely) drop any attempt to suspend our own thread.
    if (hThread == GetCurrentThread()) {
        return NO_ERROR;
    }

    DetourThread *t = new NOTHROW DetourThread;
    if (t == NULL) {
        error = ERROR_NOT_ENOUGH_MEMORY;
      fail:
        if (t != NULL) {
            delete t;
            t = NULL;
        }
        s_nPendingError = error;
        s_ppPendingError = NULL;
        DETOUR_BREAK();
        return error;
    }

    if (SuspendThread(hThread) == (DWORD)-1) {
        error = GetLastError();
        DETOUR_BREAK();
        goto fail;
    }

    t->hThread = hThread;
    t->pNext = s_pPendingThreads;
    s_pPendingThreads = t;

    return NO_ERROR;
}

///////////////////////////////////////////////////////////// Transacted APIs.
//
LONG WINAPI DetourAttach(_Inout_ PVOID *ppPointer,
                         _In_ PVOID pDetour)
{
    return DetourAttachEx(ppPointer, pDetour, NULL, NULL, NULL);
}

LONG WINAPI DetourAttachEx(_Inout_ PVOID *ppPointer,
                           _In_ PVOID pDetour,
                           _Out_opt_ PDETOUR_TRAMPOLINE *ppRealTrampoline,
                           _Out_opt_ PVOID *ppRealTarget,
                           _Out_opt_ PVOID *ppRealDetour)
{
    LONG error = NO_ERROR;

    if (ppRealTrampoline != NULL) {
        *ppRealTrampoline = NULL;
    }
    if (ppRealTarget != NULL) {
        *ppRealTarget = NULL;
    }
    if (ppRealDetour != NULL) {
        *ppRealDetour = NULL;
    }
    if (pDetour == NULL) {
        DETOUR_TRACE(("empty detour\n"));
        return ERROR_INVALID_PARAMETER;
    }

    if (s_nPendingThreadId != (LONG)GetCurrentThreadId()) {
        DETOUR_TRACE(("transaction conflict with thread id=%ld\n", s_nPendingThreadId));
        return ERROR_INVALID_OPERATION;
    }

    // If any of the pending operations failed, then we don't need to do this.
    if (s_nPendingError != NO_ERROR) {
        DETOUR_TRACE(("pending transaction error=%ld\n", s_nPendingError));
        return s_nPendingError;
    }

    if (ppPointer == NULL) {
        DETOUR_TRACE(("ppPointer is null\n"));
        return ERROR_INVALID_HANDLE;
    }
    if (*ppPointer == NULL) {
        error = ERROR_INVALID_HANDLE;
        s_nPendingError = error;
        s_ppPendingError = ppPointer;
        DETOUR_TRACE(("*ppPointer is null (ppPointer=%p)\n", ppPointer));
        DETOUR_BREAK();
        return error;
    }

    PBYTE pbTarget = (PBYTE)*ppPointer;
    PDETOUR_TRAMPOLINE pTrampoline = NULL;
    DetourOperation *o = NULL;

#ifdef DETOURS_IA64
    PPLABEL_DESCRIPTOR ppldDetour = (PPLABEL_DESCRIPTOR)pDetour;
    PPLABEL_DESCRIPTOR ppldTarget = (PPLABEL_DESCRIPTOR)pbTarget;
    PVOID pDetourGlobals = NULL;
    PVOID pTargetGlobals = NULL;

    pDetour = (PBYTE)DetourCodeFromPointer(ppldDetour, &pDetourGlobals);
    pbTarget = (PBYTE)DetourCodeFromPointer(ppldTarget, &pTargetGlobals);
    DETOUR_TRACE(("  ppldDetour=%p, code=%p [gp=%p]\n",
                  ppldDetour, pDetour, pDetourGlobals));
    DETOUR_TRACE(("  ppldTarget=%p, code=%p [gp=%p]\n",
                  ppldTarget, pbTarget, pTargetGlobals));
#else // DETOURS_IA64
    pbTarget = (PBYTE)DetourCodeFromPointer(pbTarget, NULL);
    pDetour = DetourCodeFromPointer(pDetour, NULL);
#endif // !DETOURS_IA64

    // Don't follow a jump if its destination is the target function.
    // This happens when the detour does nothing other than call the target.
    if (pDetour == (PVOID)pbTarget) {
        if (s_fIgnoreTooSmall) {
            goto stop;
        }
        else {
            DETOUR_BREAK();
            goto fail;
        }
    }

    if (ppRealTarget != NULL) {
        *ppRealTarget = pbTarget;
    }
    if (ppRealDetour != NULL) {
        *ppRealDetour = pDetour;
    }

    o = new NOTHROW DetourOperation;
    if (o == NULL) {
        error = ERROR_NOT_ENOUGH_MEMORY;
      fail:
        s_nPendingError = error;
        DETOUR_BREAK();
      stop:
        if (pTrampoline != NULL) {
            detour_free_trampoline(pTrampoline);
            pTrampoline = NULL;
            if (ppRealTrampoline != NULL) {
                *ppRealTrampoline = NULL;
            }
        }
        if (o != NULL) {
            delete o;
            o = NULL;
        }
        if (ppRealDetour != NULL) {
            *ppRealDetour = NULL;
        }
        if (ppRealTarget != NULL) {
            *ppRealTarget = NULL;
        }
        s_ppPendingError = ppPointer;
        return error;
    }

    pTrampoline = detour_alloc_trampoline(pbTarget);
    if (pTrampoline == NULL) {
        error = ERROR_NOT_ENOUGH_MEMORY;
        DETOUR_BREAK();
        goto fail;
    }

    if (ppRealTrampoline != NULL) {
        *ppRealTrampoline = pTrampoline;
    }

    DETOUR_TRACE(("detours: pbTramp=%p, pDetour=%p\n", pTrampoline, pDetour));

    memset(pTrampoline->rAlign, 0, sizeof(pTrampoline->rAlign));

    // Determine the number of movable target instructions.
    PBYTE pbSrc = pbTarget;
    PBYTE pbTrampoline = pTrampoline->rbCode;
#ifdef DETOURS_IA64
    PBYTE pbPool = (PBYTE)(&pTrampoline->bBranchIslands + 1);
#else
    PBYTE pbPool = pbTrampoline + sizeof(pTrampoline->rbCode);
#endif
    ULONG cbTarget = 0;
    ULONG cbJump = SIZE_OF_JMP;
    ULONG nAlign = 0;

#ifdef DETOURS_ARM
    // On ARM, we need an extra instruction when the function isn't 32-bit aligned.
    // Check if the existing code is another detour (or at least a similar
    // "ldr pc, [PC+0]" jump.
    if ((ULONG)pbTarget & 2) {
        cbJump += 2;

        ULONG op = fetch_thumb_opcode(pbSrc);
        if (op == 0xbf00) {
            op = fetch_thumb_opcode(pbSrc + 2);
            if (op == 0xf8dff000) { // LDR PC,[PC]
                *((PUSHORT&)pbTrampoline)++ = *((PUSHORT&)pbSrc)++;
                *((PULONG&)pbTrampoline)++ = *((PULONG&)pbSrc)++;
                *((PULONG&)pbTrampoline)++ = *((PULONG&)pbSrc)++;
                cbTarget = (LONG)(pbSrc - pbTarget);
                // We will fall through the "while" because cbTarget is now >= cbJump.
            }
        }
    }
    else {
        ULONG op = fetch_thumb_opcode(pbSrc);
        if (op == 0xf8dff000) { // LDR PC,[PC]
            *((PULONG&)pbTrampoline)++ = *((PULONG&)pbSrc)++;
            *((PULONG&)pbTrampoline)++ = *((PULONG&)pbSrc)++;
            cbTarget = (LONG)(pbSrc - pbTarget);
            // We will fall through the "while" because cbTarget is now >= cbJump.
        }
    }
#endif

    while (cbTarget < cbJump) {
        PBYTE pbOp = pbSrc;
        LONG lExtra = 0;

        DETOUR_TRACE((" DetourCopyInstruction(%p,%p)\n",
                      pbTrampoline, pbSrc));
        pbSrc = (PBYTE)
            DetourCopyInstruction(pbTrampoline, (PVOID*)&pbPool, pbSrc, NULL, &lExtra);
        DETOUR_TRACE((" DetourCopyInstruction() = %p (%d bytes)\n",
                      pbSrc, (int)(pbSrc - pbOp)));
        pbTrampoline += (pbSrc - pbOp) + lExtra;
        cbTarget = (LONG)(pbSrc - pbTarget);
        pTrampoline->rAlign[nAlign].obTarget = cbTarget;
        pTrampoline->rAlign[nAlign].obTrampoline = pbTrampoline - pTrampoline->rbCode;
        nAlign++;

        if (nAlign >= ARRAYSIZE(pTrampoline->rAlign)) {
            break;
        }

        if (detour_does_code_end_function(pbOp)) {
            break;
        }
    }

    // Consume, but don't duplicate padding if it is needed and available.
    while (cbTarget < cbJump) {
        LONG cFiller = detour_is_code_filler(pbSrc);
        if (cFiller == 0) {
            break;
        }

        pbSrc += cFiller;
        cbTarget = (LONG)(pbSrc - pbTarget);
    }

#if DETOUR_DEBUG
    {
        DETOUR_TRACE((" detours: rAlign ["));
        LONG n = 0;
        for (n = 0; n < ARRAYSIZE(pTrampoline->rAlign); n++) {
            if (pTrampoline->rAlign[n].obTarget == 0 &&
                pTrampoline->rAlign[n].obTrampoline == 0) {
                break;
            }
            DETOUR_TRACE((" %u/%u",
                          pTrampoline->rAlign[n].obTarget,
                          pTrampoline->rAlign[n].obTrampoline
                          ));

        }
        DETOUR_TRACE((" ]\n"));
    }
#endif

    if (cbTarget < cbJump || nAlign > ARRAYSIZE(pTrampoline->rAlign)) {
        // Too few instructions.

        error = ERROR_INVALID_BLOCK;
        if (s_fIgnoreTooSmall) {
            goto stop;
        }
        else {
            DETOUR_BREAK();
            goto fail;
        }
    }

    if (pbTrampoline > pbPool) {
        __debugbreak();
    }

    pTrampoline->cbCode = (BYTE)(pbTrampoline - pTrampoline->rbCode);
    pTrampoline->cbRestore = (BYTE)cbTarget;
    CopyMemory(pTrampoline->rbRestore, pbTarget, cbTarget);

#if !defined(DETOURS_IA64)
    if (cbTarget > sizeof(pTrampoline->rbCode) - cbJump) {
        // Too many instructions.
        error = ERROR_INVALID_HANDLE;
        DETOUR_BREAK();
        goto fail;
    }
#endif // !DETOURS_IA64

    pTrampoline->pbRemain = pbTarget + cbTarget;
    pTrampoline->pbDetour = (PBYTE)pDetour;

#ifdef DETOURS_IA64
    pTrampoline->ppldDetour = ppldDetour;
    pTrampoline->ppldTarget = ppldTarget;
    pTrampoline->pldTrampoline.EntryPoint = (UINT64)&pTrampoline->bMovlTargetGp;
    pTrampoline->pldTrampoline.GlobalPointer = (UINT64)pDetourGlobals;

    ((DETOUR_IA64_BUNDLE *)pTrampoline->rbCode)->SetStop();

    pTrampoline->bMovlTargetGp.SetMovlGp((UINT64)pTargetGlobals);
    pTrampoline->bBrlRemainEip.SetBrl((UINT64)pTrampoline->pbRemain);

    // Alloc frame:      alloc r41=ar.pfs,11,0,8,0; mov r40=rp
    pTrampoline->bAllocFrame.wide[0] = 0x00000580164d480c;
    pTrampoline->bAllocFrame.wide[1] = 0x00c4000500000200;
    // save r36, r37, r38.
    pTrampoline->bSave37to39.wide[0] = 0x031021004e019001;
    pTrampoline->bSave37to39.wide[1] = 0x8401280600420098;
    // save r34,r35,r36: adds r47=0,r36; adds r46=0,r35; adds r45=0,r34
    pTrampoline->bSave34to36.wide[0] = 0x02e0210048017800;
    pTrampoline->bSave34to36.wide[1] = 0x84011005a042008c;
    // save gp,r32,r33"  adds r44=0,r33; adds r43=0,r32; adds r42=0,gp ;;
    pTrampoline->bSaveGPto33.wide[0] = 0x02b0210042016001;
    pTrampoline->bSaveGPto33.wide[1] = 0x8400080540420080;
    // set detour GP.
    pTrampoline->bMovlDetourGp.SetMovlGp((UINT64)pDetourGlobals);
    // call detour:      brl.call.sptk.few rp=detour ;;
    pTrampoline->bCallDetour.wide[0] = 0x0000000100000005;
    pTrampoline->bCallDetour.wide[1] = 0xd000001000000000;
    pTrampoline->bCallDetour.SetBrlTarget((UINT64)pDetour);
    // pop frame & gp:   adds gp=0,r42; mov rp=r40,+0;; mov.i ar.pfs=r41
    pTrampoline->bPopFrameGp.wide[0] = 0x4000210054000802;
    pTrampoline->bPopFrameGp.wide[1] = 0x00aa029000038005;
    // return to caller: br.ret.sptk.many rp ;;
    pTrampoline->bReturn.wide[0] = 0x0000000100000019;
    pTrampoline->bReturn.wide[1] = 0x0084000880000200;

    DETOUR_TRACE(("detours: &bMovlTargetGp=%p\n", &pTrampoline->bMovlTargetGp));
    DETOUR_TRACE(("detours: &bMovlDetourGp=%p\n", &pTrampoline->bMovlDetourGp));
#endif // DETOURS_IA64

    pbTrampoline = pTrampoline->rbCode + pTrampoline->cbCode;
#ifdef DETOURS_X64
    pbTrampoline = detour_gen_jmp_indirect(pbTrampoline, &pTrampoline->pbRemain);
    pbTrampoline = detour_gen_brk(pbTrampoline, pbPool);
#endif // DETOURS_X64

#ifdef DETOURS_X86
    pbTrampoline = detour_gen_jmp_immediate(pbTrampoline, pTrampoline->pbRemain);
    pbTrampoline = detour_gen_brk(pbTrampoline, pbPool);
#endif // DETOURS_X86

#ifdef DETOURS_ARM
    pbTrampoline = detour_gen_jmp_immediate(pbTrampoline, &pbPool, pTrampoline->pbRemain);
    pbTrampoline = detour_gen_brk(pbTrampoline, pbPool);
#endif // DETOURS_ARM

#ifdef DETOURS_ARM64
    pbTrampoline = detour_gen_jmp_immediate(pbTrampoline, &pbPool, pTrampoline->pbRemain);
    pbTrampoline = detour_gen_brk(pbTrampoline, pbPool);
#endif // DETOURS_ARM64

    (void)pbTrampoline;

    DWORD dwOld = 0;
    if (!VirtualProtect(pbTarget, cbTarget, PAGE_EXECUTE_READWRITE, &dwOld)) {
        error = GetLastError();
        DETOUR_BREAK();
        goto fail;
    }

    DETOUR_TRACE(("detours: pbTarget=%p: "
                  "%02x %02x %02x %02x "
                  "%02x %02x %02x %02x "
                  "%02x %02x %02x %02x\n",
                  pbTarget,
                  pbTarget[0], pbTarget[1], pbTarget[2], pbTarget[3],
                  pbTarget[4], pbTarget[5], pbTarget[6], pbTarget[7],
                  pbTarget[8], pbTarget[9], pbTarget[10], pbTarget[11]));
    DETOUR_TRACE(("detours: pbTramp =%p: "
                  "%02x %02x %02x %02x "
                  "%02x %02x %02x %02x "
                  "%02x %02x %02x %02x\n",
                  pTrampoline,
                  pTrampoline->rbCode[0], pTrampoline->rbCode[1],
                  pTrampoline->rbCode[2], pTrampoline->rbCode[3],
                  pTrampoline->rbCode[4], pTrampoline->rbCode[5],
                  pTrampoline->rbCode[6], pTrampoline->rbCode[7],
                  pTrampoline->rbCode[8], pTrampoline->rbCode[9],
                  pTrampoline->rbCode[10], pTrampoline->rbCode[11]));

    o->fIsRemove = FALSE;
    o->ppbPointer = (PBYTE*)ppPointer;
    o->pTrampoline = pTrampoline;
    o->pbTarget = pbTarget;
    o->dwPerm = dwOld;
    o->pNext = s_pPendingOperations;
    s_pPendingOperations = o;

    return NO_ERROR;
}

LONG WINAPI DetourDetach(_Inout_ PVOID *ppPointer,
                         _In_ PVOID pDetour)
{
    LONG error = NO_ERROR;

    if (s_nPendingThreadId != (LONG)GetCurrentThreadId()) {
        return ERROR_INVALID_OPERATION;
    }

    // If any of the pending operations failed, then we don't need to do this.
    if (s_nPendingError != NO_ERROR) {
        return s_nPendingError;
    }

    if (pDetour == NULL) {
        return ERROR_INVALID_PARAMETER;
    }
    if (ppPointer == NULL) {
        return ERROR_INVALID_HANDLE;
    }
    if (*ppPointer == NULL) {
        error = ERROR_INVALID_HANDLE;
        s_nPendingError = error;
        s_ppPendingError = ppPointer;
        DETOUR_BREAK();
        return error;
    }

    DetourOperation *o = new NOTHROW DetourOperation;
    if (o == NULL) {
        error = ERROR_NOT_ENOUGH_MEMORY;
      fail:
        s_nPendingError = error;
        DETOUR_BREAK();
      stop:
        if (o != NULL) {
            delete o;
            o = NULL;
        }
        s_ppPendingError = ppPointer;
        return error;
    }


#ifdef DETOURS_IA64
    PPLABEL_DESCRIPTOR ppldTrampo = (PPLABEL_DESCRIPTOR)*ppPointer;
    PPLABEL_DESCRIPTOR ppldDetour = (PPLABEL_DESCRIPTOR)pDetour;
    PVOID pDetourGlobals = NULL;
    PVOID pTrampoGlobals = NULL;

    pDetour = (PBYTE)DetourCodeFromPointer(ppldDetour, &pDetourGlobals);
    PDETOUR_TRAMPOLINE pTrampoline = (PDETOUR_TRAMPOLINE)
        DetourCodeFromPointer(ppldTrampo, &pTrampoGlobals);
    DETOUR_TRACE(("  ppldDetour=%p, code=%p [gp=%p]\n",
                  ppldDetour, pDetour, pDetourGlobals));
    DETOUR_TRACE(("  ppldTrampo=%p, code=%p [gp=%p]\n",
                  ppldTrampo, pTrampoline, pTrampoGlobals));


    DETOUR_TRACE(("\n"));
    DETOUR_TRACE(("detours:  &pldTrampoline  =%p\n",
                  &pTrampoline->pldTrampoline));
    DETOUR_TRACE(("detours:  &bMovlTargetGp  =%p [%p]\n",
                  &pTrampoline->bMovlTargetGp,
                  pTrampoline->bMovlTargetGp.GetMovlGp()));
    DETOUR_TRACE(("detours:  &rbCode         =%p [%p]\n",
                  &pTrampoline->rbCode,
                  ((DETOUR_IA64_BUNDLE&)pTrampoline->rbCode).GetBrlTarget()));
    DETOUR_TRACE(("detours:  &bBrlRemainEip  =%p [%p]\n",
                  &pTrampoline->bBrlRemainEip,
                  pTrampoline->bBrlRemainEip.GetBrlTarget()));
    DETOUR_TRACE(("detours:  &bMovlDetourGp  =%p [%p]\n",
                  &pTrampoline->bMovlDetourGp,
                  pTrampoline->bMovlDetourGp.GetMovlGp()));
    DETOUR_TRACE(("detours:  &bBrlDetourEip  =%p [%p]\n",
                  &pTrampoline->bCallDetour,
                  pTrampoline->bCallDetour.GetBrlTarget()));
    DETOUR_TRACE(("detours:  pldDetour       =%p [%p]\n",
                  pTrampoline->ppldDetour->EntryPoint,
                  pTrampoline->ppldDetour->GlobalPointer));
    DETOUR_TRACE(("detours:  pldTarget       =%p [%p]\n",
                  pTrampoline->ppldTarget->EntryPoint,
                  pTrampoline->ppldTarget->GlobalPointer));
    DETOUR_TRACE(("detours:  pbRemain        =%p\n",
                  pTrampoline->pbRemain));
    DETOUR_TRACE(("detours:  pbDetour        =%p\n",
                  pTrampoline->pbDetour));
    DETOUR_TRACE(("\n"));
#else // !DETOURS_IA64
    PDETOUR_TRAMPOLINE pTrampoline =
        (PDETOUR_TRAMPOLINE)DetourCodeFromPointer(*ppPointer, NULL);
    pDetour = DetourCodeFromPointer(pDetour, NULL);
#endif // !DETOURS_IA64

    ////////////////////////////////////// Verify that Trampoline is in place.
    //
    LONG cbTarget = pTrampoline->cbRestore;
    PBYTE pbTarget = pTrampoline->pbRemain - cbTarget;
    if (cbTarget == 0 || cbTarget > sizeof(pTrampoline->rbCode)) {
        error = ERROR_INVALID_BLOCK;
        if (s_fIgnoreTooSmall) {
            goto stop;
        }
        else {
            DETOUR_BREAK();
            goto fail;
        }
    }

    if (pTrampoline->pbDetour != pDetour) {
        error = ERROR_INVALID_BLOCK;
        if (s_fIgnoreTooSmall) {
            goto stop;
        }
        else {
            DETOUR_BREAK();
            goto fail;
        }
    }

    DWORD dwOld = 0;
    if (!VirtualProtect(pbTarget, cbTarget,
                        PAGE_EXECUTE_READWRITE, &dwOld)) {
        error = GetLastError();
        DETOUR_BREAK();
        goto fail;
    }

    o->fIsRemove = TRUE;
    o->ppbPointer = (PBYTE*)ppPointer;
    o->pTrampoline = pTrampoline;
    o->pbTarget = pbTarget;
    o->dwPerm = dwOld;
    o->pNext = s_pPendingOperations;
    s_pPendingOperations = o;

    return NO_ERROR;
}

//////////////////////////////////////////////////////////////////////////////
//
// Helpers for manipulating page protection.
//

// For reference:
//   PAGE_NOACCESS          0x01
//   PAGE_READONLY          0x02
//   PAGE_READWRITE         0x04
//   PAGE_WRITECOPY         0x08
//   PAGE_EXECUTE           0x10
//   PAGE_EXECUTE_READ      0x20
//   PAGE_EXECUTE_READWRITE 0x40
//   PAGE_EXECUTE_WRITECOPY 0x80
//   PAGE_GUARD             ...
//   PAGE_NOCACHE           ...
//   PAGE_WRITECOMBINE      ...

#define DETOUR_PAGE_EXECUTE_ALL    (PAGE_EXECUTE |              \
                                    PAGE_EXECUTE_READ |         \
                                    PAGE_EXECUTE_READWRITE |    \
                                    PAGE_EXECUTE_WRITECOPY)

#define DETOUR_PAGE_NO_EXECUTE_ALL (PAGE_NOACCESS |             \
                                    PAGE_READONLY |             \
                                    PAGE_READWRITE |            \
                                    PAGE_WRITECOPY)

#define DETOUR_PAGE_ATTRIBUTES     (~(DETOUR_PAGE_EXECUTE_ALL | DETOUR_PAGE_NO_EXECUTE_ALL))

C_ASSERT((DETOUR_PAGE_NO_EXECUTE_ALL << 4) == DETOUR_PAGE_EXECUTE_ALL);

static DWORD DetourPageProtectAdjustExecute(_In_  DWORD dwOldProtect,
                                            _In_  DWORD dwNewProtect)
//  Copy EXECUTE from dwOldProtect to dwNewProtect.
{
    bool const fOldExecute = ((dwOldProtect & DETOUR_PAGE_EXECUTE_ALL) != 0);
    bool const fNewExecute = ((dwNewProtect & DETOUR_PAGE_EXECUTE_ALL) != 0);

    if (fOldExecute && !fNewExecute) {
        dwNewProtect = ((dwNewProtect & DETOUR_PAGE_NO_EXECUTE_ALL) << 4)
            | (dwNewProtect & DETOUR_PAGE_ATTRIBUTES);
    }
    else if (!fOldExecute && fNewExecute) {
        dwNewProtect = ((dwNewProtect & DETOUR_PAGE_EXECUTE_ALL) >> 4)
            | (dwNewProtect & DETOUR_PAGE_ATTRIBUTES);
    }
    return dwNewProtect;
}

_Success_(return != FALSE)
BOOL WINAPI DetourVirtualProtectSameExecuteEx(_In_  HANDLE hProcess,
                                              _In_  PVOID pAddress,
                                              _In_  SIZE_T nSize,
                                              _In_  DWORD dwNewProtect,
                                              _Out_ PDWORD pdwOldProtect)
// Some systems do not allow executability of a page to change. This function applies
// dwNewProtect to [pAddress, nSize), but preserving the previous executability.
// This function is meant to be a drop-in replacement for some uses of VirtualProtectEx.
// When "restoring" page protection, there is no need to use this function.
{
    MEMORY_BASIC_INFORMATION mbi;

    // Query to get existing execute access.

    ZeroMemory(&mbi, sizeof(mbi));

    if (VirtualQueryEx(hProcess, pAddress, &mbi, sizeof(mbi)) == 0) {
        return FALSE;
    }
    return VirtualProtectEx(hProcess, pAddress, nSize,
                            DetourPageProtectAdjustExecute(mbi.Protect, dwNewProtect),
                            pdwOldProtect);
}

_Success_(return != FALSE)
BOOL WINAPI DetourVirtualProtectSameExecute(_In_  PVOID pAddress,
                                            _In_  SIZE_T nSize,
                                            _In_  DWORD dwNewProtect,
                                            _Out_ PDWORD pdwOldProtect)
{
    return DetourVirtualProtectSameExecuteEx(GetCurrentProcess(),
                                             pAddress, nSize, dwNewProtect, pdwOldProtect);
}

BOOL WINAPI DetourAreSameGuid(_In_ REFGUID left, _In_ REFGUID right)
{
    return
        left.Data1 == right.Data1 &&
        left.Data2 == right.Data2 &&
        left.Data3 == right.Data3 &&
        left.Data4[0] == right.Data4[0] &&
        left.Data4[1] == right.Data4[1] &&
        left.Data4[2] == right.Data4[2] &&
        left.Data4[3] == right.Data4[3] &&
        left.Data4[4] == right.Data4[4] &&
        left.Data4[5] == right.Data4[5] &&
        left.Data4[6] == right.Data4[6] &&
        left.Data4[7] == right.Data4[7];
}

//  End of File

```

`src/detours.h`:

```h
/////////////////////////////////////////////////////////////////////////////
//
//  Core Detours Functionality (detours.h of detours.lib)
//
//  Microsoft Research Detours Package, Version 4.0.1
//
//  Copyright (c) Microsoft Corporation.  All rights reserved.
//

#pragma once
#ifndef _DETOURS_H_
#define _DETOURS_H_

#define DETOURS_VERSION     0x4c0c1   // 0xMAJORcMINORcPATCH

//////////////////////////////////////////////////////////////////////////////
//

#ifdef DETOURS_INTERNAL

#define _CRT_STDIO_ARBITRARY_WIDE_SPECIFIERS 1
#define _ARM_WINAPI_PARTITION_DESKTOP_SDK_AVAILABLE 1

#pragma warning(disable:4068) // unknown pragma (suppress)

#if _MSC_VER >= 1900
#pragma warning(push)
#pragma warning(disable:4091) // empty typedef
#endif

// Suppress declspec(dllimport) for the sake of Detours
// users that provide kernel32 functionality themselves.
// This is ok in the mainstream case, it will just cost
// an extra instruction calling some functions, which
// LTCG optimizes away.
//
#define _KERNEL32_ 1
#define _USER32_ 1

#include <windows.h>
#if (_MSC_VER < 1310)
#else
#pragma warning(push)
#if _MSC_VER > 1400
#pragma warning(disable:6102 6103) // /analyze warnings
#endif
#include <strsafe.h>
#include <intsafe.h>
#pragma warning(pop)
#endif
#include <crtdbg.h>

// Allow Detours to cleanly compile with the MingW toolchain.
//
#ifdef __GNUC__
#define __try
#define __except(x) if (0)
#include <strsafe.h>
#include <intsafe.h>
#endif

// From winerror.h, as this error isn't found in some SDKs:
//
// MessageId: ERROR_DYNAMIC_CODE_BLOCKED
//
// MessageText:
//
// The operation was blocked as the process prohibits dynamic code generation.
//
#define ERROR_DYNAMIC_CODE_BLOCKED       1655L

#endif // DETOURS_INTERNAL

//////////////////////////////////////////////////////////////////////////////
//

#undef DETOURS_X64
#undef DETOURS_X86
#undef DETOURS_IA64
#undef DETOURS_ARM
#undef DETOURS_ARM64
#undef DETOURS_BITS
#undef DETOURS_32BIT
#undef DETOURS_64BIT

#if defined(_X86_)
#define DETOURS_X86
#define DETOURS_OPTION_BITS 64

#elif defined(_AMD64_)
#define DETOURS_X64
#define DETOURS_OPTION_BITS 32

#elif defined(_IA64_)
#define DETOURS_IA64
#define DETOURS_OPTION_BITS 32

#elif defined(_ARM_)
#define DETOURS_ARM

#elif defined(_ARM64_)
#define DETOURS_ARM64

#else
#error Unknown architecture (x86, amd64, ia64, arm, arm64)
#endif

#ifdef _WIN64
#undef DETOURS_32BIT
#define DETOURS_64BIT 1
#define DETOURS_BITS 64
// If all 64bit kernels can run one and only one 32bit architecture.
//#define DETOURS_OPTION_BITS 32
#else
#define DETOURS_32BIT 1
#undef DETOURS_64BIT
#define DETOURS_BITS 32
// If all 64bit kernels can run one and only one 32bit architecture.
//#define DETOURS_OPTION_BITS 32
#endif

/////////////////////////////////////////////////////////////// Helper Macros.
//
#define DETOURS_STRINGIFY_(x)    #x
#define DETOURS_STRINGIFY(x)    DETOURS_STRINGIFY_(x)

#define VER_DETOURS_BITS    DETOURS_STRINGIFY(DETOURS_BITS)

//////////////////////////////////////////////////////////////////////////////
//

#if (_MSC_VER < 1299) && !defined(__MINGW32__)
typedef LONG LONG_PTR;
typedef ULONG ULONG_PTR;
#endif

///////////////////////////////////////////////// SAL 2.0 Annotations w/o SAL.
//
//  These definitions are include so that Detours will build even if the
//  compiler doesn't have full SAL 2.0 support.
//
#ifndef DETOURS_DONT_REMOVE_SAL_20

#ifdef DETOURS_TEST_REMOVE_SAL_20
#undef _Analysis_assume_
#undef _Benign_race_begin_
#undef _Benign_race_end_
#undef _Field_range_
#undef _Field_size_
#undef _In_
#undef _In_bytecount_
#undef _In_count_
#undef __in_ecount
#undef _In_opt_
#undef _In_opt_bytecount_
#undef _In_opt_count_
#undef _In_opt_z_
#undef _In_range_
#undef _In_reads_
#undef _In_reads_bytes_
#undef _In_reads_opt_
#undef _In_reads_opt_bytes_
#undef _In_reads_or_z_
#undef _In_z_
#undef _Inout_
#undef _Inout_opt_
#undef _Inout_z_count_
#undef _Out_
#undef _Out_opt_
#undef _Out_writes_
#undef _Outptr_result_maybenull_
#undef _Readable_bytes_
#undef _Success_
#undef _Writable_bytes_
#undef _Pre_notnull_
#endif

#if defined(_Deref_out_opt_z_) && !defined(_Outptr_result_maybenull_)
#define _Outptr_result_maybenull_ _Deref_out_opt_z_
#endif

#if defined(_In_count_) && !defined(_In_reads_)
#define _In_reads_(x) _In_count_(x)
#endif

#if defined(_In_opt_count_) && !defined(_In_reads_opt_)
#define _In_reads_opt_(x) _In_opt_count_(x)
#endif

#if defined(_In_opt_bytecount_) && !defined(_In_reads_opt_bytes_)
#define _In_reads_opt_bytes_(x) _In_opt_bytecount_(x)
#endif

#if defined(_In_bytecount_) && !defined(_In_reads_bytes_)
#define _In_reads_bytes_(x) _In_bytecount_(x)
#endif

#ifndef _In_
#define _In_
#endif

#ifndef _In_bytecount_
#define _In_bytecount_(x)
#endif

#ifndef _In_count_
#define _In_count_(x)
#endif

#ifndef __in_ecount
#define __in_ecount(x)
#endif

#ifndef _In_opt_
#define _In_opt_
#endif

#ifndef _In_opt_bytecount_
#define _In_opt_bytecount_(x)
#endif

#ifndef _In_opt_count_
#define _In_opt_count_(x)
#endif

#ifndef _In_opt_z_
#define _In_opt_z_
#endif

#ifndef _In_range_
#define _In_range_(x,y)
#endif

#ifndef _In_reads_
#define _In_reads_(x)
#endif

#ifndef _In_reads_bytes_
#define _In_reads_bytes_(x)
#endif

#ifndef _In_reads_opt_
#define _In_reads_opt_(x)
#endif

#ifndef _In_reads_opt_bytes_
#define _In_reads_opt_bytes_(x)
#endif

#ifndef _In_reads_or_z_
#define _In_reads_or_z_
#endif

#ifndef _In_z_
#define _In_z_
#endif

#ifndef _Inout_
#define _Inout_
#endif

#ifndef _Inout_opt_
#define _Inout_opt_
#endif

#ifndef _Inout_z_count_
#define _Inout_z_count_(x)
#endif

#ifndef _Out_
#define _Out_
#endif

#ifndef _Out_opt_
#define _Out_opt_
#endif

#ifndef _Out_writes_
#define _Out_writes_(x)
#endif

#ifndef _Outptr_result_maybenull_
#define _Outptr_result_maybenull_
#endif

#ifndef _Writable_bytes_
#define _Writable_bytes_(x)
#endif

#ifndef _Readable_bytes_
#define _Readable_bytes_(x)
#endif

#ifndef _Success_
#define _Success_(x)
#endif

#ifndef _Pre_notnull_
#define _Pre_notnull_
#endif

#ifdef DETOURS_INTERNAL

#pragma warning(disable:4615) // unknown warning type (suppress with older compilers)

#ifndef _Benign_race_begin_
#define _Benign_race_begin_
#endif

#ifndef _Benign_race_end_
#define _Benign_race_end_
#endif

#ifndef _Field_size_
#define _Field_size_(x)
#endif

#ifndef _Field_range_
#define _Field_range_(x,y)
#endif

#ifndef _Analysis_assume_
#define _Analysis_assume_(x)
#endif

#endif // DETOURS_INTERNAL
#endif // DETOURS_DONT_REMOVE_SAL_20

//////////////////////////////////////////////////////////////////////////////
//
#ifndef GUID_DEFINED
#define GUID_DEFINED
typedef struct  _GUID
{
    DWORD Data1;
    WORD Data2;
    WORD Data3;
    BYTE Data4[ 8 ];
} GUID;

#ifdef INITGUID
#define DEFINE_GUID(name, l, w1, w2, b1, b2, b3, b4, b5, b6, b7, b8) \
        const GUID name \
                = { l, w1, w2, { b1, b2,  b3,  b4,  b5,  b6,  b7,  b8 } }
#else
#define DEFINE_GUID(name, l, w1, w2, b1, b2, b3, b4, b5, b6, b7, b8) \
    const GUID name
#endif // INITGUID
#endif // !GUID_DEFINED

#if defined(__cplusplus)
#ifndef _REFGUID_DEFINED
#define _REFGUID_DEFINED
#define REFGUID             const GUID &
#endif // !_REFGUID_DEFINED
#else // !__cplusplus
#ifndef _REFGUID_DEFINED
#define _REFGUID_DEFINED
#define REFGUID             const GUID * const
#endif // !_REFGUID_DEFINED
#endif // !__cplusplus

#ifndef ARRAYSIZE
#define ARRAYSIZE(x)    (sizeof(x)/sizeof(x[0]))
#endif

//
//////////////////////////////////////////////////////////////////////////////

#ifdef __cplusplus
extern "C" {
#endif // __cplusplus

/////////////////////////////////////////////////// Instruction Target Macros.
//
#define DETOUR_INSTRUCTION_TARGET_NONE          ((PVOID)0)
#define DETOUR_INSTRUCTION_TARGET_DYNAMIC       ((PVOID)(LONG_PTR)-1)
#define DETOUR_SECTION_HEADER_SIGNATURE         0x00727444   // "Dtr\0"

extern const GUID DETOUR_EXE_RESTORE_GUID;
extern const GUID DETOUR_EXE_HELPER_GUID;

#define DETOUR_TRAMPOLINE_SIGNATURE             0x21727444  // Dtr!
typedef struct _DETOUR_TRAMPOLINE DETOUR_TRAMPOLINE, *PDETOUR_TRAMPOLINE;

/////////////////////////////////////////////////////////// Binary Structures.
//
#pragma pack(push, 8)
typedef struct _DETOUR_SECTION_HEADER
{
    DWORD       cbHeaderSize;
    DWORD       nSignature;
    DWORD       nDataOffset;
    DWORD       cbDataSize;

    DWORD       nOriginalImportVirtualAddress;
    DWORD       nOriginalImportSize;
    DWORD       nOriginalBoundImportVirtualAddress;
    DWORD       nOriginalBoundImportSize;

    DWORD       nOriginalIatVirtualAddress;
    DWORD       nOriginalIatSize;
    DWORD       nOriginalSizeOfImage;
    DWORD       cbPrePE;

    DWORD       nOriginalClrFlags;
    DWORD       reserved1;
    DWORD       reserved2;
    DWORD       reserved3;

    // Followed by cbPrePE bytes of data.
} DETOUR_SECTION_HEADER, *PDETOUR_SECTION_HEADER;

typedef struct _DETOUR_SECTION_RECORD
{
    DWORD       cbBytes;
    DWORD       nReserved;
    GUID        guid;
} DETOUR_SECTION_RECORD, *PDETOUR_SECTION_RECORD;

typedef struct _DETOUR_CLR_HEADER
{
    // Header versioning
    ULONG                   cb;
    USHORT                  MajorRuntimeVersion;
    USHORT                  MinorRuntimeVersion;

    // Symbol table and startup information
    IMAGE_DATA_DIRECTORY    MetaData;
    ULONG                   Flags;

    // Followed by the rest of the IMAGE_COR20_HEADER
} DETOUR_CLR_HEADER, *PDETOUR_CLR_HEADER;

typedef struct _DETOUR_EXE_RESTORE
{
    DWORD               cb;
    DWORD               cbidh;
    DWORD               cbinh;
    DWORD               cbclr;

    PBYTE               pidh;
    PBYTE               pinh;
    PBYTE               pclr;

    IMAGE_DOS_HEADER    idh;
    union {
        IMAGE_NT_HEADERS    inh;        // all environments have this
#ifdef IMAGE_NT_OPTIONAL_HDR32_MAGIC    // some environments do not have this
        IMAGE_NT_HEADERS32  inh32;
#endif
#ifdef IMAGE_NT_OPTIONAL_HDR64_MAGIC    // some environments do not have this
        IMAGE_NT_HEADERS64  inh64;
#endif
#ifdef IMAGE_NT_OPTIONAL_HDR64_MAGIC    // some environments do not have this
        BYTE                raw[sizeof(IMAGE_NT_HEADERS64) +
                                sizeof(IMAGE_SECTION_HEADER) * 32];
#else
        BYTE                raw[0x108 + sizeof(IMAGE_SECTION_HEADER) * 32];
#endif
    };
    DETOUR_CLR_HEADER   clr;

} DETOUR_EXE_RESTORE, *PDETOUR_EXE_RESTORE;

#ifdef IMAGE_NT_OPTIONAL_HDR64_MAGIC
C_ASSERT(sizeof(IMAGE_NT_HEADERS64) == 0x108);
#endif

// The size can change, but assert for clarity due to the muddying #ifdefs.
#ifdef _WIN64
C_ASSERT(sizeof(DETOUR_EXE_RESTORE) == 0x688);
#else
C_ASSERT(sizeof(DETOUR_EXE_RESTORE) == 0x678);
#endif

typedef struct _DETOUR_EXE_HELPER
{
    DWORD               cb;
    DWORD               pid;
    DWORD               nDlls;
    CHAR                rDlls[4];
} DETOUR_EXE_HELPER, *PDETOUR_EXE_HELPER;

#pragma pack(pop)

#define DETOUR_SECTION_HEADER_DECLARE(cbSectionSize) \
{ \
      sizeof(DETOUR_SECTION_HEADER),\
      DETOUR_SECTION_HEADER_SIGNATURE,\
      sizeof(DETOUR_SECTION_HEADER),\
      (cbSectionSize),\
      \
      0,\
      0,\
      0,\
      0,\
      \
      0,\
      0,\
      0,\
      0,\
}

///////////////////////////////////////////////////////////// Binary Typedefs.
//
typedef BOOL (CALLBACK *PF_DETOUR_BINARY_BYWAY_CALLBACK)(
    _In_opt_ PVOID pContext,
    _In_opt_ LPCSTR pszFile,
    _Outptr_result_maybenull_ LPCSTR *ppszOutFile);

typedef BOOL (CALLBACK *PF_DETOUR_BINARY_FILE_CALLBACK)(
    _In_opt_ PVOID pContext,
    _In_ LPCSTR pszOrigFile,
    _In_ LPCSTR pszFile,
    _Outptr_result_maybenull_ LPCSTR *ppszOutFile);

typedef BOOL (CALLBACK *PF_DETOUR_BINARY_SYMBOL_CALLBACK)(
    _In_opt_ PVOID pContext,
    _In_ ULONG nOrigOrdinal,
    _In_ ULONG nOrdinal,
    _Out_ ULONG *pnOutOrdinal,
    _In_opt_ LPCSTR pszOrigSymbol,
    _In_opt_ LPCSTR pszSymbol,
    _Outptr_result_maybenull_ LPCSTR *ppszOutSymbol);

typedef BOOL (CALLBACK *PF_DETOUR_BINARY_COMMIT_CALLBACK)(
    _In_opt_ PVOID pContext);

typedef BOOL (CALLBACK *PF_DETOUR_ENUMERATE_EXPORT_CALLBACK)(_In_opt_ PVOID pContext,
                                                             _In_ ULONG nOrdinal,
                                                             _In_opt_ LPCSTR pszName,
                                                             _In_opt_ PVOID pCode);

typedef BOOL (CALLBACK *PF_DETOUR_IMPORT_FILE_CALLBACK)(_In_opt_ PVOID pContext,
                                                        _In_opt_ HMODULE hModule,
                                                        _In_opt_ LPCSTR pszFile);

typedef BOOL (CALLBACK *PF_DETOUR_IMPORT_FUNC_CALLBACK)(_In_opt_ PVOID pContext,
                                                        _In_ DWORD nOrdinal,
                                                        _In_opt_ LPCSTR pszFunc,
                                                        _In_opt_ PVOID pvFunc);

// Same as PF_DETOUR_IMPORT_FUNC_CALLBACK but extra indirection on last parameter.
typedef BOOL (CALLBACK *PF_DETOUR_IMPORT_FUNC_CALLBACK_EX)(_In_opt_ PVOID pContext,
                                                           _In_ DWORD nOrdinal,
                                                           _In_opt_ LPCSTR pszFunc,
                                                           _In_opt_ PVOID* ppvFunc);

typedef VOID * PDETOUR_BINARY;
typedef VOID * PDETOUR_LOADED_BINARY;

//////////////////////////////////////////////////////////// Transaction APIs.
//
LONG WINAPI DetourTransactionBegin(VOID);
LONG WINAPI DetourTransactionAbort(VOID);
LONG WINAPI DetourTransactionCommit(VOID);
LONG WINAPI DetourTransactionCommitEx(_Out_opt_ PVOID **pppFailedPointer);

LONG WINAPI DetourUpdateThread(_In_ HANDLE hThread);

LONG WINAPI DetourAttach(_Inout_ PVOID *ppPointer,
                         _In_ PVOID pDetour);

LONG WINAPI DetourAttachEx(_Inout_ PVOID *ppPointer,
                           _In_ PVOID pDetour,
                           _Out_opt_ PDETOUR_TRAMPOLINE *ppRealTrampoline,
                           _Out_opt_ PVOID *ppRealTarget,
                           _Out_opt_ PVOID *ppRealDetour);

LONG WINAPI DetourDetach(_Inout_ PVOID *ppPointer,
                         _In_ PVOID pDetour);

BOOL WINAPI DetourSetIgnoreTooSmall(_In_ BOOL fIgnore);
BOOL WINAPI DetourSetRetainRegions(_In_ BOOL fRetain);
PVOID WINAPI DetourSetSystemRegionLowerBound(_In_ PVOID pSystemRegionLowerBound);
PVOID WINAPI DetourSetSystemRegionUpperBound(_In_ PVOID pSystemRegionUpperBound);

////////////////////////////////////////////////////////////// Code Functions.
//
PVOID WINAPI DetourFindFunction(_In_ LPCSTR pszModule,
                                _In_ LPCSTR pszFunction);
PVOID WINAPI DetourCodeFromPointer(_In_ PVOID pPointer,
                                   _Out_opt_ PVOID *ppGlobals);
PVOID WINAPI DetourCopyInstruction(_In_opt_ PVOID pDst,
                                   _Inout_opt_ PVOID *ppDstPool,
                                   _In_ PVOID pSrc,
                                   _Out_opt_ PVOID *ppTarget,
                                   _Out_opt_ LONG *plExtra);
BOOL WINAPI DetourSetCodeModule(_In_ HMODULE hModule,
                                _In_ BOOL fLimitReferencesToModule);
PVOID WINAPI DetourAllocateRegionWithinJumpBounds(_In_ LPCVOID pbTarget,
                                                  _Out_ PDWORD pcbAllocatedSize);

///////////////////////////////////////////////////// Loaded Binary Functions.
//
HMODULE WINAPI DetourGetContainingModule(_In_ PVOID pvAddr);
HMODULE WINAPI DetourEnumerateModules(_In_opt_ HMODULE hModuleLast);
PVOID WINAPI DetourGetEntryPoint(_In_opt_ HMODULE hModule);
ULONG WINAPI DetourGetModuleSize(_In_opt_ HMODULE hModule);
BOOL WINAPI DetourEnumerateExports(_In_ HMODULE hModule,
                                   _In_opt_ PVOID pContext,
                                   _In_ PF_DETOUR_ENUMERATE_EXPORT_CALLBACK pfExport);
BOOL WINAPI DetourEnumerateImports(_In_opt_ HMODULE hModule,
                                   _In_opt_ PVOID pContext,
                                   _In_opt_ PF_DETOUR_IMPORT_FILE_CALLBACK pfImportFile,
                                   _In_opt_ PF_DETOUR_IMPORT_FUNC_CALLBACK pfImportFunc);

BOOL WINAPI DetourEnumerateImportsEx(_In_opt_ HMODULE hModule,
                                     _In_opt_ PVOID pContext,
                                     _In_opt_ PF_DETOUR_IMPORT_FILE_CALLBACK pfImportFile,
                                     _In_opt_ PF_DETOUR_IMPORT_FUNC_CALLBACK_EX pfImportFuncEx);

_Writable_bytes_(*pcbData)
_Readable_bytes_(*pcbData)
_Success_(return != NULL)
PVOID WINAPI DetourFindPayload(_In_opt_ HMODULE hModule,
                               _In_ REFGUID rguid,
                               _Out_opt_ DWORD *pcbData);

_Writable_bytes_(*pcbData)
_Readable_bytes_(*pcbData)
_Success_(return != NULL)
PVOID WINAPI DetourFindPayloadEx(_In_ REFGUID rguid,
                                 _Out_opt_ DWORD *pcbData);

DWORD WINAPI DetourGetSizeOfPayloads(_In_opt_ HMODULE hModule);

BOOL WINAPI DetourFreePayload(_In_ PVOID pvData);
///////////////////////////////////////////////// Persistent Binary Functions.
//

PDETOUR_BINARY WINAPI DetourBinaryOpen(_In_ HANDLE hFile);

_Writable_bytes_(*pcbData)
_Readable_bytes_(*pcbData)
_Success_(return != NULL)
PVOID WINAPI DetourBinaryEnumeratePayloads(_In_ PDETOUR_BINARY pBinary,
                                           _Out_opt_ GUID *pGuid,
                                           _Out_ DWORD *pcbData,
                                           _Inout_ DWORD *pnIterator);

_Writable_bytes_(*pcbData)
_Readable_bytes_(*pcbData)
_Success_(return != NULL)
PVOID WINAPI DetourBinaryFindPayload(_In_ PDETOUR_BINARY pBinary,
                                     _In_ REFGUID rguid,
                                     _Out_ DWORD *pcbData);

PVOID WINAPI DetourBinarySetPayload(_In_ PDETOUR_BINARY pBinary,
                                    _In_ REFGUID rguid,
                                    _In_reads_opt_(cbData) PVOID pData,
                                    _In_ DWORD cbData);
BOOL WINAPI DetourBinaryDeletePayload(_In_ PDETOUR_BINARY pBinary, _In_ REFGUID rguid);
BOOL WINAPI DetourBinaryPurgePayloads(_In_ PDETOUR_BINARY pBinary);
BOOL WINAPI DetourBinaryResetImports(_In_ PDETOUR_BINARY pBinary);
BOOL WINAPI DetourBinaryEditImports(_In_ PDETOUR_BINARY pBinary,
                                    _In_opt_ PVOID pContext,
                                    _In_opt_ PF_DETOUR_BINARY_BYWAY_CALLBACK pfByway,
                                    _In_opt_ PF_DETOUR_BINARY_FILE_CALLBACK pfFile,
                                    _In_opt_ PF_DETOUR_BINARY_SYMBOL_CALLBACK pfSymbol,
                                    _In_opt_ PF_DETOUR_BINARY_COMMIT_CALLBACK pfCommit);
BOOL WINAPI DetourBinaryWrite(_In_ PDETOUR_BINARY pBinary, _In_ HANDLE hFile);
BOOL WINAPI DetourBinaryClose(_In_ PDETOUR_BINARY pBinary);

/////////////////////////////////////////////////// Create Process & Load Dll.
//
_Success_(return != NULL)
PVOID WINAPI DetourFindRemotePayload(_In_ HANDLE hProcess,
                                     _In_ REFGUID rguid,
                                     _Out_opt_ DWORD *pcbData);

typedef BOOL (WINAPI *PDETOUR_CREATE_PROCESS_ROUTINEA)(
    _In_opt_ LPCSTR lpApplicationName,
    _Inout_opt_ LPSTR lpCommandLine,
    _In_opt_ LPSECURITY_ATTRIBUTES lpProcessAttributes,
    _In_opt_ LPSECURITY_ATTRIBUTES lpThreadAttributes,
    _In_ BOOL bInheritHandles,
    _In_ DWORD dwCreationFlags,
    _In_opt_ LPVOID lpEnvironment,
    _In_opt_ LPCSTR lpCurrentDirectory,
    _In_ LPSTARTUPINFOA lpStartupInfo,
    _Out_ LPPROCESS_INFORMATION lpProcessInformation);

typedef BOOL (WINAPI *PDETOUR_CREATE_PROCESS_ROUTINEW)(
    _In_opt_ LPCWSTR lpApplicationName,
    _Inout_opt_ LPWSTR lpCommandLine,
    _In_opt_ LPSECURITY_ATTRIBUTES lpProcessAttributes,
    _In_opt_ LPSECURITY_ATTRIBUTES lpThreadAttributes,
    _In_ BOOL bInheritHandles,
    _In_ DWORD dwCreationFlags,
    _In_opt_ LPVOID lpEnvironment,
    _In_opt_ LPCWSTR lpCurrentDirectory,
    _In_ LPSTARTUPINFOW lpStartupInfo,
    _Out_ LPPROCESS_INFORMATION lpProcessInformation);

BOOL WINAPI DetourCreateProcessWithDllA(_In_opt_ LPCSTR lpApplicationName,
                                        _Inout_opt_ LPSTR lpCommandLine,
                                        _In_opt_ LPSECURITY_ATTRIBUTES lpProcessAttributes,
                                        _In_opt_ LPSECURITY_ATTRIBUTES lpThreadAttributes,
                                        _In_ BOOL bInheritHandles,
                                        _In_ DWORD dwCreationFlags,
                                        _In_opt_ LPVOID lpEnvironment,
                                        _In_opt_ LPCSTR lpCurrentDirectory,
                                        _In_ LPSTARTUPINFOA lpStartupInfo,
                                        _Out_ LPPROCESS_INFORMATION lpProcessInformation,
                                        _In_ LPCSTR lpDllName,
                                        _In_opt_ PDETOUR_CREATE_PROCESS_ROUTINEA pfCreateProcessA);

BOOL WINAPI DetourCreateProcessWithDllW(_In_opt_ LPCWSTR lpApplicationName,
                                        _Inout_opt_ LPWSTR lpCommandLine,
                                        _In_opt_ LPSECURITY_ATTRIBUTES lpProcessAttributes,
                                        _In_opt_ LPSECURITY_ATTRIBUTES lpThreadAttributes,
                                        _In_ BOOL bInheritHandles,
                                        _In_ DWORD dwCreationFlags,
                                        _In_opt_ LPVOID lpEnvironment,
                                        _In_opt_ LPCWSTR lpCurrentDirectory,
                                        _In_ LPSTARTUPINFOW lpStartupInfo,
                                        _Out_ LPPROCESS_INFORMATION lpProcessInformation,
                                        _In_ LPCSTR lpDllName,
                                        _In_opt_ PDETOUR_CREATE_PROCESS_ROUTINEW pfCreateProcessW);

#ifdef UNICODE
#define DetourCreateProcessWithDll      DetourCreateProcessWithDllW
#define PDETOUR_CREATE_PROCESS_ROUTINE  PDETOUR_CREATE_PROCESS_ROUTINEW
#else
#define DetourCreateProcessWithDll      DetourCreateProcessWithDllA
#define PDETOUR_CREATE_PROCESS_ROUTINE  PDETOUR_CREATE_PROCESS_ROUTINEA
#endif // !UNICODE

BOOL WINAPI DetourCreateProcessWithDllExA(_In_opt_ LPCSTR lpApplicationName,
                                          _Inout_opt_ LPSTR lpCommandLine,
                                          _In_opt_ LPSECURITY_ATTRIBUTES lpProcessAttributes,
                                          _In_opt_ LPSECURITY_ATTRIBUTES lpThreadAttributes,
                                          _In_ BOOL bInheritHandles,
                                          _In_ DWORD dwCreationFlags,
                                          _In_opt_ LPVOID lpEnvironment,
                                          _In_opt_ LPCSTR lpCurrentDirectory,
                                          _In_ LPSTARTUPINFOA lpStartupInfo,
                                          _Out_ LPPROCESS_INFORMATION lpProcessInformation,
                                          _In_ LPCSTR lpDllName,
                                          _In_opt_ PDETOUR_CREATE_PROCESS_ROUTINEA pfCreateProcessA);

BOOL WINAPI DetourCreateProcessWithDllExW(_In_opt_ LPCWSTR lpApplicationName,
                                          _Inout_opt_  LPWSTR lpCommandLine,
                                          _In_opt_ LPSECURITY_ATTRIBUTES lpProcessAttributes,
                                          _In_opt_ LPSECURITY_ATTRIBUTES lpThreadAttributes,
                                          _In_ BOOL bInheritHandles,
                                          _In_ DWORD dwCreationFlags,
                                          _In_opt_ LPVOID lpEnvironment,
                                          _In_opt_ LPCWSTR lpCurrentDirectory,
                                          _In_ LPSTARTUPINFOW lpStartupInfo,
                                          _Out_ LPPROCESS_INFORMATION lpProcessInformation,
                                          _In_ LPCSTR lpDllName,
                                          _In_opt_ PDETOUR_CREATE_PROCESS_ROUTINEW pfCreateProcessW);

#ifdef UNICODE
#define DetourCreateProcessWithDllEx    DetourCreateProcessWithDllExW
#else
#define DetourCreateProcessWithDllEx    DetourCreateProcessWithDllExA
#endif // !UNICODE

BOOL WINAPI DetourCreateProcessWithDllsA(_In_opt_ LPCSTR lpApplicationName,
                                         _Inout_opt_ LPSTR lpCommandLine,
                                         _In_opt_ LPSECURITY_ATTRIBUTES lpProcessAttributes,
                                         _In_opt_ LPSECURITY_ATTRIBUTES lpThreadAttributes,
                                         _In_ BOOL bInheritHandles,
                                         _In_ DWORD dwCreationFlags,
                                         _In_opt_ LPVOID lpEnvironment,
                                         _In_opt_ LPCSTR lpCurrentDirectory,
                                         _In_ LPSTARTUPINFOA lpStartupInfo,
                                         _Out_ LPPROCESS_INFORMATION lpProcessInformation,
                                         _In_ DWORD nDlls,
                                         _In_reads_(nDlls) LPCSTR *rlpDlls,
                                         _In_opt_ PDETOUR_CREATE_PROCESS_ROUTINEA pfCreateProcessA);

BOOL WINAPI DetourCreateProcessWithDllsW(_In_opt_ LPCWSTR lpApplicationName,
                                         _Inout_opt_ LPWSTR lpCommandLine,
                                         _In_opt_ LPSECURITY_ATTRIBUTES lpProcessAttributes,
                                         _In_opt_ LPSECURITY_ATTRIBUTES lpThreadAttributes,
                                         _In_ BOOL bInheritHandles,
                                         _In_ DWORD dwCreationFlags,
                                         _In_opt_ LPVOID lpEnvironment,
                                         _In_opt_ LPCWSTR lpCurrentDirectory,
                                         _In_ LPSTARTUPINFOW lpStartupInfo,
                                         _Out_ LPPROCESS_INFORMATION lpProcessInformation,
                                         _In_ DWORD nDlls,
                                         _In_reads_(nDlls) LPCSTR *rlpDlls,
                                         _In_opt_ PDETOUR_CREATE_PROCESS_ROUTINEW pfCreateProcessW);

#ifdef UNICODE
#define DetourCreateProcessWithDlls     DetourCreateProcessWithDllsW
#else
#define DetourCreateProcessWithDlls     DetourCreateProcessWithDllsA
#endif // !UNICODE

BOOL WINAPI DetourProcessViaHelperA(_In_ DWORD dwTargetPid,
                                    _In_ LPCSTR lpDllName,
                                    _In_ PDETOUR_CREATE_PROCESS_ROUTINEA pfCreateProcessA);

BOOL WINAPI DetourProcessViaHelperW(_In_ DWORD dwTargetPid,
                                    _In_ LPCSTR lpDllName,
                                    _In_ PDETOUR_CREATE_PROCESS_ROUTINEW pfCreateProcessW);

#ifdef UNICODE
#define DetourProcessViaHelper          DetourProcessViaHelperW
#else
#define DetourProcessViaHelper          DetourProcessViaHelperA
#endif // !UNICODE

BOOL WINAPI DetourProcessViaHelperDllsA(_In_ DWORD dwTargetPid,
                                        _In_ DWORD nDlls,
                                        _In_reads_(nDlls) LPCSTR *rlpDlls,
                                        _In_ PDETOUR_CREATE_PROCESS_ROUTINEA pfCreateProcessA);

BOOL WINAPI DetourProcessViaHelperDllsW(_In_ DWORD dwTargetPid,
                                        _In_ DWORD nDlls,
                                        _In_reads_(nDlls) LPCSTR *rlpDlls,
                                        _In_ PDETOUR_CREATE_PROCESS_ROUTINEW pfCreateProcessW);

#ifdef UNICODE
#define DetourProcessViaHelperDlls      DetourProcessViaHelperDllsW
#else
#define DetourProcessViaHelperDlls      DetourProcessViaHelperDllsA
#endif // !UNICODE

BOOL WINAPI DetourUpdateProcessWithDll(_In_ HANDLE hProcess,
                                       _In_reads_(nDlls) LPCSTR *rlpDlls,
                                       _In_ DWORD nDlls);

BOOL WINAPI DetourUpdateProcessWithDllEx(_In_ HANDLE hProcess,
                                         _In_ HMODULE hImage,
                                         _In_ BOOL bIs32Bit,
                                         _In_reads_(nDlls) LPCSTR *rlpDlls,
                                         _In_ DWORD nDlls);

BOOL WINAPI DetourCopyPayloadToProcess(_In_ HANDLE hProcess,
                                       _In_ REFGUID rguid,
                                       _In_reads_bytes_(cbData) LPCVOID pvData,
                                       _In_ DWORD cbData);
_Success_(return != NULL)
PVOID WINAPI DetourCopyPayloadToProcessEx(_In_ HANDLE hProcess,
                                          _In_ REFGUID rguid,
                                          _In_reads_bytes_(cbData) LPCVOID pvData,
                                          _In_ DWORD cbData);

BOOL WINAPI DetourRestoreAfterWith(VOID);
BOOL WINAPI DetourRestoreAfterWithEx(_In_reads_bytes_(cbData) PVOID pvData,
                                     _In_ DWORD cbData);
BOOL WINAPI DetourIsHelperProcess(VOID);
VOID CALLBACK DetourFinishHelperProcess(_In_ HWND,
                                        _In_ HINSTANCE,
                                        _In_ LPSTR,
                                        _In_ INT);

//
//////////////////////////////////////////////////////////////////////////////
#ifdef __cplusplus
}
#endif // __cplusplus

/////////////////////////////////////////////////// Type-safe overloads for C++
//
#if __cplusplus >= 201103L || _MSVC_LANG >= 201103L
#include <type_traits>

template<typename T>
struct DetoursIsFunctionPointer : std::false_type {};

template<typename T>
struct DetoursIsFunctionPointer<T*> : std::is_function<typename std::remove_pointer<T>::type> {};

template<
    typename T,
    typename std::enable_if<DetoursIsFunctionPointer<T>::value, int>::type = 0>
LONG DetourAttach(_Inout_ T *ppPointer,
                  _In_ T pDetour) noexcept
{
    return DetourAttach(
        reinterpret_cast<void**>(ppPointer),
        reinterpret_cast<void*>(pDetour));
}

template<
    typename T,
    typename std::enable_if<DetoursIsFunctionPointer<T>::value, int>::type = 0>
LONG DetourAttachEx(_Inout_ T *ppPointer,
                    _In_ T pDetour,
                    _Out_opt_ PDETOUR_TRAMPOLINE *ppRealTrampoline,
                    _Out_opt_ T *ppRealTarget,
                    _Out_opt_ T *ppRealDetour) noexcept
{
    return DetourAttachEx(
        reinterpret_cast<void**>(ppPointer),
        reinterpret_cast<void*>(pDetour),
        ppRealTrampoline,
        reinterpret_cast<void**>(ppRealTarget),
        reinterpret_cast<void**>(ppRealDetour));
}

template<
    typename T,
    typename std::enable_if<DetoursIsFunctionPointer<T>::value, int>::type = 0>
LONG DetourDetach(_Inout_ T *ppPointer,
                  _In_ T pDetour) noexcept
{
    return DetourDetach(
        reinterpret_cast<void**>(ppPointer),
        reinterpret_cast<void*>(pDetour));
}

#endif // __cplusplus >= 201103L || _MSVC_LANG >= 201103L
//
//////////////////////////////////////////////////////////////////////////////

//////////////////////////////////////////////// Detours Internal Definitions.
//
#ifdef __cplusplus
#ifdef DETOURS_INTERNAL

#define NOTHROW
// #define NOTHROW (nothrow)

//////////////////////////////////////////////////////////////////////////////
//
#if (_MSC_VER < 1299) && !defined(__GNUC__)
#include <imagehlp.h>
typedef IMAGEHLP_MODULE IMAGEHLP_MODULE64;
typedef PIMAGEHLP_MODULE PIMAGEHLP_MODULE64;
typedef IMAGEHLP_SYMBOL SYMBOL_INFO;
typedef PIMAGEHLP_SYMBOL PSYMBOL_INFO;

static inline
LONG InterlockedCompareExchange(_Inout_ LONG *ptr, _In_ LONG nval, _In_ LONG oval)
{
    return (LONG)::InterlockedCompareExchange((PVOID*)ptr, (PVOID)nval, (PVOID)oval);
}
#else
#pragma warning(push)
#pragma warning(disable:4091) // empty typedef
#include <dbghelp.h>
#pragma warning(pop)
#endif

#ifdef IMAGEAPI // defined by DBGHELP.H
typedef LPAPI_VERSION (NTAPI *PF_ImagehlpApiVersionEx)(_In_ LPAPI_VERSION AppVersion);

typedef BOOL (NTAPI *PF_SymInitialize)(_In_ HANDLE hProcess,
                                       _In_opt_ LPCSTR UserSearchPath,
                                       _In_ BOOL fInvadeProcess);
typedef DWORD (NTAPI *PF_SymSetOptions)(_In_ DWORD SymOptions);
typedef DWORD (NTAPI *PF_SymGetOptions)(VOID);
typedef DWORD64 (NTAPI *PF_SymLoadModule64)(_In_ HANDLE hProcess,
                                            _In_opt_ HANDLE hFile,
                                            _In_opt_ LPSTR ImageName,
                                            _In_opt_ LPSTR ModuleName,
                                            _In_ DWORD64 BaseOfDll,
                                            _In_ DWORD SizeOfDll);
typedef BOOL (NTAPI *PF_SymGetModuleInfo64)(_In_ HANDLE hProcess,
                                            _In_ DWORD64 qwAddr,
                                            _Out_ PIMAGEHLP_MODULE64 ModuleInfo);
typedef BOOL (NTAPI *PF_SymFromName)(_In_ HANDLE hProcess,
                                     _In_ LPSTR Name,
                                     _Out_ PSYMBOL_INFO Symbol);

typedef struct _DETOUR_SYM_INFO
{
    HANDLE                  hProcess;
    HMODULE                 hDbgHelp;
    PF_ImagehlpApiVersionEx pfImagehlpApiVersionEx;
    PF_SymInitialize        pfSymInitialize;
    PF_SymSetOptions        pfSymSetOptions;
    PF_SymGetOptions        pfSymGetOptions;
    PF_SymLoadModule64      pfSymLoadModule64;
    PF_SymGetModuleInfo64   pfSymGetModuleInfo64;
    PF_SymFromName          pfSymFromName;
} DETOUR_SYM_INFO, *PDETOUR_SYM_INFO;

PDETOUR_SYM_INFO DetourLoadImageHlp(VOID);

#endif // IMAGEAPI

#if defined(_INC_STDIO) && !defined(_CRT_STDIO_ARBITRARY_WIDE_SPECIFIERS)
#error detours.h must be included before stdio.h (or at least define _CRT_STDIO_ARBITRARY_WIDE_SPECIFIERS earlier)
#endif
#define _CRT_STDIO_ARBITRARY_WIDE_SPECIFIERS 1

#ifdef _DEBUG

int Detour_AssertExprWithFunctionName(int reportType, const char* filename, int linenumber, const char* FunctionName, const char* msg);

#define DETOUR_ASSERT_EXPR_WITH_FUNCTION(expr, msg) \
    (void) ((expr) || \
    (1 != Detour_AssertExprWithFunctionName(_CRT_ASSERT, __FILE__, __LINE__,__FUNCTION__, msg)) || \
    (_CrtDbgBreak(), 0))

#define DETOUR_ASSERT(expr) DETOUR_ASSERT_EXPR_WITH_FUNCTION((expr), #expr)

#else// _DEBUG
#define DETOUR_ASSERT(expr)
#endif// _DEBUG

#ifndef DETOUR_TRACE
#if DETOUR_DEBUG
#define DETOUR_TRACE(x) printf x
#define DETOUR_BREAK()  __debugbreak()
#include <stdio.h>
#include <limits.h>
#else
#define DETOUR_TRACE(x)
#define DETOUR_BREAK()
#endif
#endif

#if 1 || defined(DETOURS_IA64)

//
// IA64 instructions are 41 bits, 3 per bundle, plus 5 bit bundle template => 128 bits per bundle.
//

#define DETOUR_IA64_INSTRUCTIONS_PER_BUNDLE (3)

#define DETOUR_IA64_TEMPLATE_OFFSET (0)
#define DETOUR_IA64_TEMPLATE_SIZE   (5)

#define DETOUR_IA64_INSTRUCTION_SIZE (41)
#define DETOUR_IA64_INSTRUCTION0_OFFSET (DETOUR_IA64_TEMPLATE_SIZE)
#define DETOUR_IA64_INSTRUCTION1_OFFSET (DETOUR_IA64_TEMPLATE_SIZE + DETOUR_IA64_INSTRUCTION_SIZE)
#define DETOUR_IA64_INSTRUCTION2_OFFSET (DETOUR_IA64_TEMPLATE_SIZE + DETOUR_IA64_INSTRUCTION_SIZE + DETOUR_IA64_INSTRUCTION_SIZE)

C_ASSERT(DETOUR_IA64_TEMPLATE_SIZE + DETOUR_IA64_INSTRUCTIONS_PER_BUNDLE * DETOUR_IA64_INSTRUCTION_SIZE == 128);

__declspec(align(16)) struct DETOUR_IA64_BUNDLE
{
  public:
    union
    {
        BYTE    data[16];
        UINT64  wide[2];
    };

    enum {
        A_UNIT  = 1u,
        I_UNIT  = 2u,
        M_UNIT  = 3u,
        B_UNIT  = 4u,
        F_UNIT  = 5u,
        L_UNIT  = 6u,
        X_UNIT  = 7u,
    };
    struct DETOUR_IA64_METADATA
    {
        ULONG       nTemplate       : 8;    // Instruction template.
        ULONG       nUnit0          : 4;    // Unit for slot 0
        ULONG       nUnit1          : 4;    // Unit for slot 1
        ULONG       nUnit2          : 4;    // Unit for slot 2
    };

  protected:
    static const DETOUR_IA64_METADATA s_rceCopyTable[33];

    UINT RelocateBundle(_Inout_ DETOUR_IA64_BUNDLE* pDst, _Inout_opt_ DETOUR_IA64_BUNDLE* pBundleExtra) const;

    bool RelocateInstruction(_Inout_ DETOUR_IA64_BUNDLE* pDst,
                             _In_ BYTE slot,
                             _Inout_opt_ DETOUR_IA64_BUNDLE* pBundleExtra) const;

    // 120 112 104 96 88 80 72 64 56 48 40 32 24 16  8  0
    //  f.  e.  d. c. b. a. 9. 8. 7. 6. 5. 4. 3. 2. 1. 0.

    //                                      00
    // f.e. d.c. b.a. 9.8. 7.6. 5.4. 3.2. 1.0.
    // 0000 0000 0000 0000 0000 0000 0000 001f : Template [4..0]
    // 0000 0000 0000 0000 0000 03ff ffff ffe0 : Zero [ 41..  5]
    // 0000 0000 0000 0000 0000 3c00 0000 0000 : Zero [ 45.. 42]
    // 0000 0000 0007 ffff ffff c000 0000 0000 : One  [ 82.. 46]
    // 0000 0000 0078 0000 0000 0000 0000 0000 : One  [ 86.. 83]
    // 0fff ffff ff80 0000 0000 0000 0000 0000 : Two  [123.. 87]
    // f000 0000 0000 0000 0000 0000 0000 0000 : Two  [127..124]
    BYTE    GetTemplate() const;
    // Get 4 bit opcodes.
    BYTE    GetInst0() const;
    BYTE    GetInst1() const;
    BYTE    GetInst2() const;
    BYTE    GetUnit(BYTE slot) const;
    BYTE    GetUnit0() const;
    BYTE    GetUnit1() const;
    BYTE    GetUnit2() const;
    // Get 37 bit data.
    UINT64  GetData0() const;
    UINT64  GetData1() const;
    UINT64  GetData2() const;

    // Get/set the full 41 bit instructions.
    UINT64  GetInstruction(BYTE slot) const;
    UINT64  GetInstruction0() const;
    UINT64  GetInstruction1() const;
    UINT64  GetInstruction2() const;
    void    SetInstruction(BYTE slot, UINT64 instruction);
    void    SetInstruction0(UINT64 instruction);
    void    SetInstruction1(UINT64 instruction);
    void    SetInstruction2(UINT64 instruction);

    // Get/set bitfields.
    static UINT64 GetBits(UINT64 Value, UINT64 Offset, UINT64 Count);
    static UINT64 SetBits(UINT64 Value, UINT64 Offset, UINT64 Count, UINT64 Field);

    // Get specific read-only fields.
    static UINT64 GetOpcode(UINT64 instruction); // 4bit opcode
    static UINT64 GetX(UINT64 instruction); // 1bit opcode extension
    static UINT64 GetX3(UINT64 instruction); // 3bit opcode extension
    static UINT64 GetX6(UINT64 instruction); // 6bit opcode extension

    // Get/set specific fields.
    static UINT64 GetImm7a(UINT64 instruction);
    static UINT64 SetImm7a(UINT64 instruction, UINT64 imm7a);
    static UINT64 GetImm13c(UINT64 instruction);
    static UINT64 SetImm13c(UINT64 instruction, UINT64 imm13c);
    static UINT64 GetSignBit(UINT64 instruction);
    static UINT64 SetSignBit(UINT64 instruction, UINT64 signBit);
    static UINT64 GetImm20a(UINT64 instruction);
    static UINT64 SetImm20a(UINT64 instruction, UINT64 imm20a);
    static UINT64 GetImm20b(UINT64 instruction);
    static UINT64 SetImm20b(UINT64 instruction, UINT64 imm20b);

    static UINT64 SignExtend(UINT64 Value, UINT64 Offset);

    BOOL    IsMovlGp() const;

    VOID    SetInst(BYTE Slot, BYTE nInst);
    VOID    SetInst0(BYTE nInst);
    VOID    SetInst1(BYTE nInst);
    VOID    SetInst2(BYTE nInst);
    VOID    SetData(BYTE Slot, UINT64 nData);
    VOID    SetData0(UINT64 nData);
    VOID    SetData1(UINT64 nData);
    VOID    SetData2(UINT64 nData);
    BOOL    SetNop(BYTE Slot);
    BOOL    SetNop0();
    BOOL    SetNop1();
    BOOL    SetNop2();

  public:
    BOOL    IsBrl() const;
    VOID    SetBrl();
    VOID    SetBrl(UINT64 target);
    UINT64  GetBrlTarget() const;
    VOID    SetBrlTarget(UINT64 target);
    VOID    SetBrlImm(UINT64 imm);
    UINT64  GetBrlImm() const;

    UINT64  GetMovlGp() const;
    VOID    SetMovlGp(UINT64 gp);

    VOID    SetStop();

    UINT    Copy(_Out_ DETOUR_IA64_BUNDLE *pDst, _Inout_opt_ DETOUR_IA64_BUNDLE* pBundleExtra = NULL) const;
};
#endif // DETOURS_IA64

#ifdef DETOURS_ARM

#define DETOURS_PFUNC_TO_PBYTE(p)  ((PBYTE)(((ULONG_PTR)(p)) & ~(ULONG_PTR)1))
#define DETOURS_PBYTE_TO_PFUNC(p)  ((PBYTE)(((ULONG_PTR)(p)) | (ULONG_PTR)1))

#endif // DETOURS_ARM

//////////////////////////////////////////////////////////////////////////////

#ifdef __cplusplus
extern "C" {
#endif // __cplusplus

#define DETOUR_OFFLINE_LIBRARY(x)                                       \
PVOID WINAPI DetourCopyInstruction##x(_In_opt_ PVOID pDst,              \
                                      _Inout_opt_ PVOID *ppDstPool,     \
                                      _In_ PVOID pSrc,                  \
                                      _Out_opt_ PVOID *ppTarget,        \
                                      _Out_opt_ LONG *plExtra);         \
                                                                        \
BOOL WINAPI DetourSetCodeModule##x(_In_ HMODULE hModule,                \
                                   _In_ BOOL fLimitReferencesToModule); \

DETOUR_OFFLINE_LIBRARY(X86)
DETOUR_OFFLINE_LIBRARY(X64)
DETOUR_OFFLINE_LIBRARY(ARM)
DETOUR_OFFLINE_LIBRARY(ARM64)
DETOUR_OFFLINE_LIBRARY(IA64)

#undef DETOUR_OFFLINE_LIBRARY

//////////////////////////////////////////////////////////////////////////////
//
// Helpers for manipulating page protection.
//

_Success_(return != FALSE)
BOOL WINAPI DetourVirtualProtectSameExecuteEx(_In_  HANDLE hProcess,
                                              _In_  PVOID pAddress,
                                              _In_  SIZE_T nSize,
                                              _In_  DWORD dwNewProtect,
                                              _Out_ PDWORD pdwOldProtect);

_Success_(return != FALSE)
BOOL WINAPI DetourVirtualProtectSameExecute(_In_  PVOID pAddress,
                                            _In_  SIZE_T nSize,
                                            _In_  DWORD dwNewProtect,
                                            _Out_ PDWORD pdwOldProtect);

// Detours must depend only on kernel32.lib, so we cannot use IsEqualGUID
BOOL WINAPI DetourAreSameGuid(_In_ REFGUID left, _In_ REFGUID right);
#ifdef __cplusplus
}
#endif // __cplusplus

//////////////////////////////////////////////////////////////////////////////

#define MM_ALLOCATION_GRANULARITY 0x10000

//////////////////////////////////////////////////////////////////////////////

#endif // DETOURS_INTERNAL
#endif // __cplusplus

#endif // _DETOURS_H_
//
////////////////////////////////////////////////////////////////  End of File.

```

`src/detver.h`:

```h
//////////////////////////////////////////////////////////////////////////////
//
//  Common version parameters.
//
//  Microsoft Research Detours Package, Version 4.0.1
//
//  Copyright (c) Microsoft Corporation.  All rights reserved.
//

#define _USING_V110_SDK71_ 1
#include "winver.h"
#if 0
#include <windows.h>
#include <detours.h>
#else
#ifndef DETOURS_STRINGIFY
#define DETOURS_STRINGIFY_(x)    #x
#define DETOURS_STRINGIFY(x)    DETOURS_STRINGIFY_(x)
#endif

#define VER_FILEFLAGSMASK   0x3fL
#define VER_FILEFLAGS       0x0L
#define VER_FILEOS          0x00040004L
#define VER_FILETYPE        0x00000002L
#define VER_FILESUBTYPE     0x00000000L
#endif
#define VER_DETOURS_BITS    DETOURS_STRINGIFY(DETOURS_BITS)

```

`src/disasm.cpp`:

```cpp
//////////////////////////////////////////////////////////////////////////////
//
//  Detours Disassembler (disasm.cpp of detours.lib)
//
//  Microsoft Research Detours Package, Version 4.0.1
//
//  Copyright (c) Microsoft Corporation.  All rights reserved.
//

// #define DETOUR_DEBUG 1
#define DETOURS_INTERNAL
#include "detours.h"
#include <limits.h>

#if DETOURS_VERSION != 0x4c0c1   // 0xMAJORcMINORcPATCH
#error detours.h version mismatch
#endif

#undef ASSERT
#define ASSERT(x)

//////////////////////////////////////////////////////////////////////////////
//
//  Special macros to handle the case when we are building disassembler for
//  offline processing.
//


#if defined(DETOURS_X86_OFFLINE_LIBRARY) \
 || defined(DETOURS_X64_OFFLINE_LIBRARY) \
 || defined(DETOURS_ARM_OFFLINE_LIBRARY) \
 || defined(DETOURS_ARM64_OFFLINE_LIBRARY) \
 || defined(DETOURS_IA64_OFFLINE_LIBRARY)

#undef DETOURS_X64
#undef DETOURS_X86
#undef DETOURS_IA64
#undef DETOURS_ARM
#undef DETOURS_ARM64

#if defined(DETOURS_X86_OFFLINE_LIBRARY)

#define DetourCopyInstruction   DetourCopyInstructionX86
#define DetourSetCodeModule     DetourSetCodeModuleX86
#define CDetourDis              CDetourDisX86
#define DETOURS_X86

#elif defined(DETOURS_X64_OFFLINE_LIBRARY)

#if !defined(DETOURS_64BIT)
// Fix this as/if bugs are discovered.
//#error X64 disassembler can only build for 64-bit.
#endif

#define DetourCopyInstruction   DetourCopyInstructionX64
#define DetourSetCodeModule     DetourSetCodeModuleX64
#define CDetourDis              CDetourDisX64
#define DETOURS_X64

#elif defined(DETOURS_ARM_OFFLINE_LIBRARY)

#define DetourCopyInstruction   DetourCopyInstructionARM
#define DetourSetCodeModule     DetourSetCodeModuleARM
#define CDetourDis              CDetourDisARM
#define DETOURS_ARM

#elif defined(DETOURS_ARM64_OFFLINE_LIBRARY)

#define DetourCopyInstruction   DetourCopyInstructionARM64
#define DetourSetCodeModule     DetourSetCodeModuleARM64
#define CDetourDis              CDetourDisARM64
#define DETOURS_ARM64

#elif defined(DETOURS_IA64_OFFLINE_LIBRARY)

#define DetourCopyInstruction   DetourCopyInstructionIA64
#define DetourSetCodeModule     DetourSetCodeModuleIA64
#define DETOURS_IA64

#else

#error

#endif
#endif

//////////////////////////////////////////////////////////////////////////////
//
//  Function:
//      DetourCopyInstruction(PVOID pDst,
//                            PVOID *ppDstPool
//                            PVOID pSrc,
//                            PVOID *ppTarget,
//                            LONG *plExtra)
//  Purpose:
//      Copy a single instruction from pSrc to pDst.
//
//  Arguments:
//      pDst:
//          Destination address for the instruction.  May be NULL in which
//          case DetourCopyInstruction is used to measure an instruction.
//          If not NULL then the source instruction is copied to the
//          destination instruction and any relative arguments are adjusted.
//      ppDstPool:
//          Destination address for the end of the constant pool.  The
//          constant pool works backwards toward pDst.  All memory between
//          pDst and *ppDstPool must be available for use by this function.
//          ppDstPool may be NULL if pDst is NULL.
//      pSrc:
//          Source address of the instruction.
//      ppTarget:
//          Out parameter for any target instruction address pointed to by
//          the instruction.  For example, a branch or a jump insruction has
//          a target, but a load or store instruction doesn't.  A target is
//          another instruction that may be executed as a result of this
//          instruction.  ppTarget may be NULL.
//      plExtra:
//          Out parameter for the number of extra bytes needed by the
//          instruction to reach the target.  For example, lExtra = 3 if the
//          instruction had an 8-bit relative offset, but needs a 32-bit
//          relative offset.
//
//  Returns:
//      Returns the address of the next instruction (following in the source)
//      instruction.  By subtracting pSrc from the return value, the caller
//      can determinte the size of the instruction copied.
//
//  Comments:
//      By following the pTarget, the caller can follow alternate
//      instruction streams.  However, it is not always possible to determine
//      the target based on static analysis.  For example, the destination of
//      a jump relative to a register cannot be determined from just the
//      instruction stream.  The output value, pTarget, can have any of the
//      following outputs:
//          DETOUR_INSTRUCTION_TARGET_NONE:
//              The instruction has no targets.
//          DETOUR_INSTRUCTION_TARGET_DYNAMIC:
//              The instruction has a non-deterministic (dynamic) target.
//              (i.e. the jump is to an address held in a register.)
//          Address:   The instruction has the specified target.
//
//      When copying instructions, DetourCopyInstruction insures that any
//      targets remain constant.  It does so by adjusting any IP relative
//      offsets.
//

#pragma data_seg(".detourd")
#pragma const_seg(".detourc")

//////////////////////////////////////////////////// X86 and X64 Disassembler.
//
//  Includes full support for all x86 chips prior to the Pentium III, and some newer stuff.
//
#if defined(DETOURS_X64) || defined(DETOURS_X86)

class CDetourDis
{
  public:
    CDetourDis(_Out_opt_ PBYTE *ppbTarget,
               _Out_opt_ LONG *plExtra);

    PBYTE   CopyInstruction(PBYTE pbDst, PBYTE pbSrc);
    static BOOL SanityCheckSystem();
    static BOOL SetCodeModule(PBYTE pbBeg, PBYTE pbEnd, BOOL fLimitReferencesToModule);

  public:
    struct COPYENTRY;
    typedef const COPYENTRY * REFCOPYENTRY;

    typedef PBYTE (CDetourDis::* COPYFUNC)(REFCOPYENTRY pEntry, PBYTE pbDst, PBYTE pbSrc);

    // nFlagBits flags.
    enum {
        DYNAMIC     = 0x1u,
        ADDRESS     = 0x2u,
        NOENLARGE   = 0x4u,
        RAX         = 0x8u,
    };

    // ModR/M Flags
    enum {
        SIB         = 0x10u,
        RIP         = 0x20u,
        NOTSIB      = 0x0fu,
    };

    struct COPYENTRY
    {
        // Many of these fields are often ignored. See ENTRY_DataIgnored.
        ULONG       nFixedSize      : 4;    // Fixed size of opcode
        ULONG       nFixedSize16    : 4;    // Fixed size when 16 bit operand
        ULONG       nModOffset      : 4;    // Offset to mod/rm byte (0=none)
        ULONG       nRelOffset      : 4;    // Offset to relative target.
        ULONG       nFlagBits       : 4;    // Flags for DYNAMIC, etc.
        COPYFUNC    pfCopy;                 // Function pointer.
    };

  protected:
// These macros define common uses of nFixedSize, nFixedSize16, nModOffset, nRelOffset, nFlagBits, pfCopy.
#define ENTRY_DataIgnored           0, 0, 0, 0, 0,
#define ENTRY_CopyBytes1            { 1, 1, 0, 0, 0, &CDetourDis::CopyBytes }
#ifdef DETOURS_X64
#define ENTRY_CopyBytes1Address     { 9, 5, 0, 0, ADDRESS, &CDetourDis::CopyBytes }
#else
#define ENTRY_CopyBytes1Address     { 5, 3, 0, 0, ADDRESS, &CDetourDis::CopyBytes }
#endif
#define ENTRY_CopyBytes1Dynamic     { 1, 1, 0, 0, DYNAMIC, &CDetourDis::CopyBytes }
#define ENTRY_CopyBytes2            { 2, 2, 0, 0, 0, &CDetourDis::CopyBytes }
#define ENTRY_CopyBytes2Jump        { ENTRY_DataIgnored &CDetourDis::CopyBytesJump }
#define ENTRY_CopyBytes2CantJump    { 2, 2, 0, 1, NOENLARGE, &CDetourDis::CopyBytes }
#define ENTRY_CopyBytes2Dynamic     { 2, 2, 0, 0, DYNAMIC, &CDetourDis::CopyBytes }
#define ENTRY_CopyBytes3            { 3, 3, 0, 0, 0, &CDetourDis::CopyBytes }
#define ENTRY_CopyBytes3Dynamic     { 3, 3, 0, 0, DYNAMIC, &CDetourDis::CopyBytes }
#define ENTRY_CopyBytes3Or5         { 5, 3, 0, 0, 0, &CDetourDis::CopyBytes }
#define ENTRY_CopyBytes3Or5Dynamic  { 5, 3, 0, 0, DYNAMIC, &CDetourDis::CopyBytes }// x86 only
#ifdef DETOURS_X64
#define ENTRY_CopyBytes3Or5Rax      { 5, 3, 0, 0, RAX, &CDetourDis::CopyBytes }
#define ENTRY_CopyBytes3Or5Target   { 5, 5, 0, 1, 0, &CDetourDis::CopyBytes }
#else
#define ENTRY_CopyBytes3Or5Rax      { 5, 3, 0, 0, 0, &CDetourDis::CopyBytes }
#define ENTRY_CopyBytes3Or5Target   { 5, 3, 0, 1, 0, &CDetourDis::CopyBytes }
#endif
#define ENTRY_CopyBytes4            { 4, 4, 0, 0, 0, &CDetourDis::CopyBytes }
#define ENTRY_CopyBytes5            { 5, 5, 0, 0, 0, &CDetourDis::CopyBytes }
#define ENTRY_CopyBytes5Or7Dynamic  { 7, 5, 0, 0, DYNAMIC, &CDetourDis::CopyBytes }
#define ENTRY_CopyBytes7            { 7, 7, 0, 0, 0, &CDetourDis::CopyBytes }
#define ENTRY_CopyBytes2Mod         { 2, 2, 1, 0, 0, &CDetourDis::CopyBytes }
#define ENTRY_CopyBytes2ModDynamic  { 2, 2, 1, 0, DYNAMIC, &CDetourDis::CopyBytes }
#define ENTRY_CopyBytes2Mod1        { 3, 3, 1, 0, 0, &CDetourDis::CopyBytes }
#define ENTRY_CopyBytes2ModOperand  { 6, 4, 1, 0, 0, &CDetourDis::CopyBytes }
#define ENTRY_CopyBytes3Mod         { 3, 3, 2, 0, 0, &CDetourDis::CopyBytes } // SSE3 0F 38 opcode modrm
#define ENTRY_CopyBytes3Mod1        { 4, 4, 2, 0, 0, &CDetourDis::CopyBytes } // SSE3 0F 3A opcode modrm .. imm8
#define ENTRY_CopyBytesPrefix       { ENTRY_DataIgnored &CDetourDis::CopyBytesPrefix }
#define ENTRY_CopyBytesSegment      { ENTRY_DataIgnored &CDetourDis::CopyBytesSegment }
#define ENTRY_CopyBytesRax          { ENTRY_DataIgnored &CDetourDis::CopyBytesRax }
#define ENTRY_CopyF2                { ENTRY_DataIgnored &CDetourDis::CopyF2 }
#define ENTRY_CopyF3                { ENTRY_DataIgnored &CDetourDis::CopyF3 } // 32bit x86 only
#define ENTRY_Copy0F                { ENTRY_DataIgnored &CDetourDis::Copy0F }
#define ENTRY_Copy0F78              { ENTRY_DataIgnored &CDetourDis::Copy0F78 }
#define ENTRY_Copy0F00              { ENTRY_DataIgnored &CDetourDis::Copy0F00 } // 32bit x86 only
#define ENTRY_Copy0FB8              { ENTRY_DataIgnored &CDetourDis::Copy0FB8 } // 32bit x86 only
#define ENTRY_Copy66                { ENTRY_DataIgnored &CDetourDis::Copy66 }
#define ENTRY_Copy67                { ENTRY_DataIgnored &CDetourDis::Copy67 }
#define ENTRY_CopyF6                { ENTRY_DataIgnored &CDetourDis::CopyF6 }
#define ENTRY_CopyF7                { ENTRY_DataIgnored &CDetourDis::CopyF7 }
#define ENTRY_CopyFF                { ENTRY_DataIgnored &CDetourDis::CopyFF }
#define ENTRY_CopyVex2              { ENTRY_DataIgnored &CDetourDis::CopyVex2 }
#define ENTRY_CopyVex3              { ENTRY_DataIgnored &CDetourDis::CopyVex3 }
#define ENTRY_CopyEvex              { ENTRY_DataIgnored &CDetourDis::CopyEvex } // 62, 3 byte payload, then normal with implied prefixes like vex
#define ENTRY_CopyXop               { ENTRY_DataIgnored &CDetourDis::CopyXop }   // 0x8F ... POP /0 or AMD XOP
#define ENTRY_CopyBytesXop          { 5, 5, 4, 0, 0, &CDetourDis::CopyBytes } // 0x8F xop1 xop2 opcode modrm
#define ENTRY_CopyBytesXop1         { 6, 6, 4, 0, 0, &CDetourDis::CopyBytes } // 0x8F xop1 xop2 opcode modrm ... imm8
#define ENTRY_CopyBytesXop4         { 9, 9, 4, 0, 0, &CDetourDis::CopyBytes } // 0x8F xop1 xop2 opcode modrm ... imm32
#define ENTRY_Invalid               { ENTRY_DataIgnored &CDetourDis::Invalid }

    PBYTE CopyBytes(REFCOPYENTRY pEntry, PBYTE pbDst, PBYTE pbSrc);
    PBYTE CopyBytesPrefix(REFCOPYENTRY pEntry, PBYTE pbDst, PBYTE pbSrc);
    PBYTE CopyBytesSegment(REFCOPYENTRY pEntry, PBYTE pbDst, PBYTE pbSrc);
    PBYTE CopyBytesRax(REFCOPYENTRY pEntry, PBYTE pbDst, PBYTE pbSrc);
    PBYTE CopyBytesJump(REFCOPYENTRY pEntry, PBYTE pbDst, PBYTE pbSrc);

    PBYTE Invalid(REFCOPYENTRY pEntry, PBYTE pbDst, PBYTE pbSrc);

    PBYTE AdjustTarget(PBYTE pbDst, PBYTE pbSrc, UINT cbOp,
                       UINT cbTargetOffset, UINT cbTargetSize);

  protected:
    PBYTE Copy0F(REFCOPYENTRY pEntry, PBYTE pbDst, PBYTE pbSrc);
    PBYTE Copy0F00(REFCOPYENTRY pEntry, PBYTE pbDst, PBYTE pbSrc); // x86 only sldt/0 str/1 lldt/2 ltr/3 err/4 verw/5 jmpe/6/dynamic invalid/7
    PBYTE Copy0F78(REFCOPYENTRY pEntry, PBYTE pbDst, PBYTE pbSrc); // vmread, 66/extrq/ib/ib, F2/insertq/ib/ib
    PBYTE Copy0FB8(REFCOPYENTRY pEntry, PBYTE pbDst, PBYTE pbSrc); // jmpe or F3/popcnt
    PBYTE Copy66(REFCOPYENTRY pEntry, PBYTE pbDst, PBYTE pbSrc);
    PBYTE Copy67(REFCOPYENTRY pEntry, PBYTE pbDst, PBYTE pbSrc);
    PBYTE CopyF2(REFCOPYENTRY pEntry, PBYTE pbDst, PBYTE pbSrc);
    PBYTE CopyF3(REFCOPYENTRY pEntry, PBYTE pbDst, PBYTE pbSrc); // x86 only
    PBYTE CopyF6(REFCOPYENTRY pEntry, PBYTE pbDst, PBYTE pbSrc);
    PBYTE CopyF7(REFCOPYENTRY pEntry, PBYTE pbDst, PBYTE pbSrc);
    PBYTE CopyFF(REFCOPYENTRY pEntry, PBYTE pbDst, PBYTE pbSrc);
    PBYTE CopyVex2(REFCOPYENTRY pEntry, PBYTE pbDst, PBYTE pbSrc);
    PBYTE CopyVex3(REFCOPYENTRY pEntry, PBYTE pbDst, PBYTE pbSrc);
    PBYTE CopyVexCommon(BYTE m, PBYTE pbDst, PBYTE pbSrc);
    PBYTE CopyVexEvexCommon(BYTE m, PBYTE pbDst, PBYTE pbSrc, BYTE p, BYTE fp16 = 0);
    PBYTE CopyEvex(REFCOPYENTRY pEntry, PBYTE pbDst, PBYTE pbSrc);
    PBYTE CopyXop(REFCOPYENTRY pEntry, PBYTE pbDst, PBYTE pbSrc);

  protected:
    static const COPYENTRY  s_rceCopyTable[];
    static const COPYENTRY  s_rceCopyTable0F[];
    static const BYTE       s_rbModRm[256];
    static PBYTE            s_pbModuleBeg;
    static PBYTE            s_pbModuleEnd;
    static BOOL             s_fLimitReferencesToModule;

  protected:
    BOOL                m_bOperandOverride;
    BOOL                m_bAddressOverride;
    BOOL                m_bRaxOverride; // AMD64 only
    BOOL                m_bVex;
    BOOL                m_bEvex;
    BOOL                m_bF2;
    BOOL                m_bF3; // x86 only
    BYTE                m_nSegmentOverride;

    PBYTE *             m_ppbTarget;
    LONG *              m_plExtra;

    LONG                m_lScratchExtra;
    PBYTE               m_pbScratchTarget;
    BYTE                m_rbScratchDst[64]; // matches or exceeds rbCode
};

PVOID WINAPI DetourCopyInstruction(_In_opt_ PVOID pDst,
                                   _Inout_opt_ PVOID *ppDstPool,
                                   _In_ PVOID pSrc,
                                   _Out_opt_ PVOID *ppTarget,
                                   _Out_opt_ LONG *plExtra)
{
    UNREFERENCED_PARAMETER(ppDstPool);  // x86 & x64 don't use a constant pool.

    CDetourDis oDetourDisasm((PBYTE*)ppTarget, plExtra);
    return oDetourDisasm.CopyInstruction((PBYTE)pDst, (PBYTE)pSrc);
}

/////////////////////////////////////////////////////////// Disassembler Code.
//
CDetourDis::CDetourDis(_Out_opt_ PBYTE *ppbTarget, _Out_opt_ LONG *plExtra) :
    m_bOperandOverride(FALSE),
    m_bAddressOverride(FALSE),
    m_bRaxOverride(FALSE),
    m_bF2(FALSE),
    m_bF3(FALSE),
    m_bVex(FALSE),
    m_bEvex(FALSE)
{
    m_ppbTarget = ppbTarget ? ppbTarget : &m_pbScratchTarget;
    m_plExtra = plExtra ? plExtra : &m_lScratchExtra;

    *m_ppbTarget = (PBYTE)DETOUR_INSTRUCTION_TARGET_NONE;
    *m_plExtra = 0;
}

PBYTE CDetourDis::CopyInstruction(PBYTE pbDst, PBYTE pbSrc)
{
    // Configure scratch areas if real areas are not available.
    if (NULL == pbDst) {
        pbDst = m_rbScratchDst;
    }
    if (NULL == pbSrc) {
        // We can't copy a non-existent instruction.
        SetLastError(ERROR_INVALID_DATA);
        return NULL;
    }

    // Figure out how big the instruction is, do the appropriate copy,
    // and figure out what the target of the instruction is if any.
    //
    REFCOPYENTRY pEntry = &s_rceCopyTable[pbSrc[0]];
    return (this->*pEntry->pfCopy)(pEntry, pbDst, pbSrc);
}

PBYTE CDetourDis::CopyBytes(REFCOPYENTRY pEntry, PBYTE pbDst, PBYTE pbSrc)
{
    UINT nBytesFixed;

    if (m_bVex || m_bEvex)
    {
        ASSERT(pEntry->nFlagBits == 0);
        ASSERT(pEntry->nFixedSize == pEntry->nFixedSize16);
    }

    UINT const nModOffset = pEntry->nModOffset;
    UINT const nFlagBits = pEntry->nFlagBits;
    UINT const nFixedSize = pEntry->nFixedSize;
    UINT const nFixedSize16 = pEntry->nFixedSize16;

    if (nFlagBits & ADDRESS) {
        nBytesFixed = m_bAddressOverride ? nFixedSize16 : nFixedSize;
    }
#ifdef DETOURS_X64
    // REX.W trumps 66
    else if (m_bRaxOverride) {
        nBytesFixed = nFixedSize + ((nFlagBits & RAX) ? 4 : 0);
    }
#endif
    else {
        nBytesFixed = m_bOperandOverride ? nFixedSize16 : nFixedSize;
    }

    UINT nBytes = nBytesFixed;
    UINT nRelOffset = pEntry->nRelOffset;
    UINT cbTarget = nBytes - nRelOffset;
    if (nModOffset > 0) {
        ASSERT(nRelOffset == 0);
        BYTE const bModRm = pbSrc[nModOffset];
        BYTE const bFlags = s_rbModRm[bModRm];

        nBytes += bFlags & NOTSIB;

        if (bFlags & SIB) {
            BYTE const bSib = pbSrc[nModOffset + 1];

            if ((bSib & 0x07) == 0x05) {
                if ((bModRm & 0xc0) == 0x00) {
                    nBytes += 4;
                }
                else if ((bModRm & 0xc0) == 0x40) {
                    nBytes += 1;
                }
                else if ((bModRm & 0xc0) == 0x80) {
                    nBytes += 4;
                }
            }
            cbTarget = nBytes - nRelOffset;
        }
#ifdef DETOURS_X64
        else if (bFlags & RIP) {
            nRelOffset = nModOffset + 1;
            cbTarget = 4;
        }
#endif
    }
    CopyMemory(pbDst, pbSrc, nBytes);

    if (nRelOffset) {
        *m_ppbTarget = AdjustTarget(pbDst, pbSrc, nBytes, nRelOffset, cbTarget);
#ifdef DETOURS_X64
        if (pEntry->nRelOffset == 0) {
            // This is a data target, not a code target, so we shouldn't return it.
            *m_ppbTarget = NULL;
        }
#endif
    }
    if (nFlagBits & NOENLARGE) {
        *m_plExtra = -*m_plExtra;
    }
    if (nFlagBits & DYNAMIC) {
        *m_ppbTarget = (PBYTE)DETOUR_INSTRUCTION_TARGET_DYNAMIC;
    }
    return pbSrc + nBytes;
}

PBYTE CDetourDis::CopyBytesPrefix(REFCOPYENTRY pEntry, PBYTE pbDst, PBYTE pbSrc)
{
    pbDst[0] = pbSrc[0];
    pEntry = &s_rceCopyTable[pbSrc[1]];
    return (this->*pEntry->pfCopy)(pEntry, pbDst + 1, pbSrc + 1);
}

PBYTE CDetourDis::CopyBytesSegment(REFCOPYENTRY, PBYTE pbDst, PBYTE pbSrc)
{
    m_nSegmentOverride = pbSrc[0];
    return CopyBytesPrefix(0, pbDst, pbSrc);
}

PBYTE CDetourDis::CopyBytesRax(REFCOPYENTRY, PBYTE pbDst, PBYTE pbSrc)
{ // AMD64 only
    if (pbSrc[0] & 0x8) {
        m_bRaxOverride = TRUE;
    }
    return CopyBytesPrefix(0, pbDst, pbSrc);
}

PBYTE CDetourDis::CopyBytesJump(REFCOPYENTRY pEntry, PBYTE pbDst, PBYTE pbSrc)
{
    (void)pEntry;

    PVOID pvSrcAddr = &pbSrc[1];
    PVOID pvDstAddr = NULL;
    LONG_PTR nOldOffset = (LONG_PTR)*(signed char*&)pvSrcAddr;
    LONG_PTR nNewOffset = 0;

    *m_ppbTarget = pbSrc + 2 + nOldOffset;

    if (pbSrc[0] == 0xeb) {
        pbDst[0] = 0xe9;
        pvDstAddr = &pbDst[1];
        nNewOffset = nOldOffset - ((pbDst - pbSrc) + 3);
        *(UNALIGNED LONG*&)pvDstAddr = (LONG)nNewOffset;

        *m_plExtra = 3;
        return pbSrc + 2;
    }

    ASSERT(pbSrc[0] >= 0x70 && pbSrc[0] <= 0x7f);

    pbDst[0] = 0x0f;
    pbDst[1] = 0x80 | (pbSrc[0] & 0xf);
    pvDstAddr = &pbDst[2];
    nNewOffset = nOldOffset - ((pbDst - pbSrc) + 4);
    *(UNALIGNED LONG*&)pvDstAddr = (LONG)nNewOffset;

    *m_plExtra = 4;
    return pbSrc + 2;
}

PBYTE CDetourDis::AdjustTarget(PBYTE pbDst, PBYTE pbSrc, UINT cbOp,
                               UINT cbTargetOffset, UINT cbTargetSize)
{
    PBYTE pbTarget = NULL;
#if 1 // fault injection to test test code
#if defined(DETOURS_X64)
    typedef LONGLONG T;
#else
    typedef LONG T;
#endif
    T nOldOffset;
    T nNewOffset;
    PVOID pvTargetAddr = &pbDst[cbTargetOffset];

    switch (cbTargetSize) {
      case 1:
        nOldOffset = *(signed char*&)pvTargetAddr;
        break;
      case 2:
        nOldOffset = *(UNALIGNED SHORT*&)pvTargetAddr;
        break;
      case 4:
        nOldOffset = *(UNALIGNED LONG*&)pvTargetAddr;
        break;
#if defined(DETOURS_X64)
      case 8:
        nOldOffset = *(UNALIGNED LONGLONG*&)pvTargetAddr;
        break;
#endif
      default:
        ASSERT(!"cbTargetSize is invalid.");
        nOldOffset = 0;
        break;
    }

    pbTarget = pbSrc + cbOp + nOldOffset;
    nNewOffset = nOldOffset - (T)(pbDst - pbSrc);

    switch (cbTargetSize) {
      case 1:
        *(CHAR*&)pvTargetAddr = (CHAR)nNewOffset;
        if (nNewOffset < SCHAR_MIN || nNewOffset > SCHAR_MAX) {
            *m_plExtra = sizeof(ULONG) - 1;
        }
        break;
      case 2:
        *(UNALIGNED SHORT*&)pvTargetAddr = (SHORT)nNewOffset;
        if (nNewOffset < SHRT_MIN || nNewOffset > SHRT_MAX) {
            *m_plExtra = sizeof(ULONG) - 2;
        }
        break;
      case 4:
        *(UNALIGNED LONG*&)pvTargetAddr = (LONG)nNewOffset;
        if (nNewOffset < LONG_MIN || nNewOffset > LONG_MAX) {
            *m_plExtra = sizeof(ULONG) - 4;
        }
        break;
#if defined(DETOURS_X64)
      case 8:
        *(UNALIGNED LONGLONG*&)pvTargetAddr = nNewOffset;
        break;
#endif
    }
#ifdef DETOURS_X64
    // When we are only computing size, source and dest can be
    // far apart, distance not encodable in 32bits. Ok.
    // At least still check the lower 32bits.

    if (pbDst >= m_rbScratchDst && pbDst < (sizeof(m_rbScratchDst) + m_rbScratchDst)) {
        ASSERT((((size_t)pbDst + cbOp + nNewOffset) & 0xFFFFFFFF) == (((size_t)pbTarget) & 0xFFFFFFFF));
    }
    else
#endif
    {
        ASSERT(pbDst + cbOp + nNewOffset == pbTarget);
    }
#endif
    return pbTarget;
}

PBYTE CDetourDis::Invalid(REFCOPYENTRY pEntry, PBYTE pbDst, PBYTE pbSrc)
{
    (void)pbDst;
    (void)pEntry;
    ASSERT(!"Invalid Instruction");
    return pbSrc + 1;
}

////////////////////////////////////////////////////// Individual Bytes Codes.
//
PBYTE CDetourDis::Copy0F(REFCOPYENTRY pEntry, PBYTE pbDst, PBYTE pbSrc)
{
    pbDst[0] = pbSrc[0];
    pEntry = &s_rceCopyTable0F[pbSrc[1]];
    return (this->*pEntry->pfCopy)(pEntry, pbDst + 1, pbSrc + 1);
}

PBYTE CDetourDis::Copy0F78(REFCOPYENTRY, PBYTE pbDst, PBYTE pbSrc)
{
    // vmread, 66/extrq, F2/insertq

    static const COPYENTRY vmread = /* 78 */ ENTRY_CopyBytes2Mod;
    static const COPYENTRY extrq_insertq = /* 78 */ ENTRY_CopyBytes4;

    ASSERT(!(m_bF2 && m_bOperandOverride));

    // For insertq and presumably despite documentation extrq, mode must be 11, not checked.
    // insertq/extrq/78 are followed by two immediate bytes, and given mode == 11, mod/rm byte is always one byte,
    // and the 0x78 makes 4 bytes (not counting the 66/F2/F which are accounted for elsewhere)

    REFCOPYENTRY const pEntry = ((m_bF2 || m_bOperandOverride) ? &extrq_insertq : &vmread);

    return (this->*pEntry->pfCopy)(pEntry, pbDst, pbSrc);
}

PBYTE CDetourDis::Copy0F00(REFCOPYENTRY, PBYTE pbDst, PBYTE pbSrc)
{
    // jmpe is 32bit x86 only
    // Notice that the sizes are the same either way, but jmpe is marked as "dynamic".

    static const COPYENTRY other = /* B8 */ ENTRY_CopyBytes2Mod; // sldt/0 str/1 lldt/2 ltr/3 err/4 verw/5 jmpe/6 invalid/7
    static const COPYENTRY jmpe = /* B8 */ ENTRY_CopyBytes2ModDynamic; // jmpe/6 x86-on-IA64 syscalls

    REFCOPYENTRY const pEntry = (((6 << 3) == ((7 << 3) & pbSrc[1])) ?  &jmpe : &other);
    return (this->*pEntry->pfCopy)(pEntry, pbDst, pbSrc);
}

PBYTE CDetourDis::Copy0FB8(REFCOPYENTRY, PBYTE pbDst, PBYTE pbSrc)
{
    // jmpe is 32bit x86 only

    static const COPYENTRY popcnt = /* B8 */ ENTRY_CopyBytes2Mod;
    static const COPYENTRY jmpe = /* B8 */ ENTRY_CopyBytes3Or5Dynamic; // jmpe x86-on-IA64 syscalls
    REFCOPYENTRY const pEntry = m_bF3 ? &popcnt : &jmpe;
    return (this->*pEntry->pfCopy)(pEntry, pbDst, pbSrc);
}

PBYTE CDetourDis::Copy66(REFCOPYENTRY pEntry, PBYTE pbDst, PBYTE pbSrc)
{   // Operand-size override prefix
    m_bOperandOverride = TRUE;
    return CopyBytesPrefix(pEntry, pbDst, pbSrc);
}

PBYTE CDetourDis::Copy67(REFCOPYENTRY pEntry, PBYTE pbDst, PBYTE pbSrc)
{   // Address size override prefix
    m_bAddressOverride = TRUE;
    return CopyBytesPrefix(pEntry, pbDst, pbSrc);
}

PBYTE CDetourDis::CopyF2(REFCOPYENTRY pEntry, PBYTE pbDst, PBYTE pbSrc)
{
    m_bF2 = TRUE;
    return CopyBytesPrefix(pEntry, pbDst, pbSrc);
}

PBYTE CDetourDis::CopyF3(REFCOPYENTRY pEntry, PBYTE pbDst, PBYTE pbSrc)
{ // x86 only
    m_bF3 = TRUE;
    return CopyBytesPrefix(pEntry, pbDst, pbSrc);
}

PBYTE CDetourDis::CopyF6(REFCOPYENTRY pEntry, PBYTE pbDst, PBYTE pbSrc)
{
    (void)pEntry;

    // TEST BYTE /0
    if (0x00 == (0x38 & pbSrc[1])) {    // reg(bits 543) of ModR/M == 0
        static const COPYENTRY ce = /* f6 */ ENTRY_CopyBytes2Mod1;
        return (this->*ce.pfCopy)(&ce, pbDst, pbSrc);
    }
    // DIV /6
    // IDIV /7
    // IMUL /5
    // MUL /4
    // NEG /3
    // NOT /2

    static const COPYENTRY ce = /* f6 */ ENTRY_CopyBytes2Mod;
    return (this->*ce.pfCopy)(&ce, pbDst, pbSrc);
}

PBYTE CDetourDis::CopyF7(REFCOPYENTRY pEntry, PBYTE pbDst, PBYTE pbSrc)
{
    (void)pEntry;

    // TEST WORD /0
    if (0x00 == (0x38 & pbSrc[1])) {    // reg(bits 543) of ModR/M == 0
        static const COPYENTRY ce = /* f7 */ ENTRY_CopyBytes2ModOperand;
        return (this->*ce.pfCopy)(&ce, pbDst, pbSrc);
    }

    // DIV /6
    // IDIV /7
    // IMUL /5
    // MUL /4
    // NEG /3
    // NOT /2
    static const COPYENTRY ce = /* f7 */ ENTRY_CopyBytes2Mod;
    return (this->*ce.pfCopy)(&ce, pbDst, pbSrc);
}

PBYTE CDetourDis::CopyFF(REFCOPYENTRY pEntry, PBYTE pbDst, PBYTE pbSrc)
{   // INC /0
    // DEC /1
    // CALL /2
    // CALL /3
    // JMP /4
    // JMP /5
    // PUSH /6
    // invalid/7
    (void)pEntry;

    static const COPYENTRY ce = /* ff */ ENTRY_CopyBytes2Mod;
    PBYTE pbOut = (this->*ce.pfCopy)(&ce, pbDst, pbSrc);

    BYTE const b1 = pbSrc[1];

    if (0x15 == b1 || 0x25 == b1) {         // CALL [], JMP []
#ifdef DETOURS_X64
        // All segments but FS and GS are equivalent.
        if (m_nSegmentOverride != 0x64 && m_nSegmentOverride != 0x65)
#else
        if (m_nSegmentOverride == 0 || m_nSegmentOverride == 0x2E)
#endif
        {
#ifdef DETOURS_X64
            INT32 offset = *(UNALIGNED INT32*)&pbSrc[2];
            PBYTE *ppbTarget = (PBYTE *)(pbSrc + 6 + offset);
#else
            PBYTE *ppbTarget = (PBYTE *)(SIZE_T)*(UNALIGNED ULONG*)&pbSrc[2];
#endif
            if (s_fLimitReferencesToModule &&
                (ppbTarget < (PVOID)s_pbModuleBeg || ppbTarget >= (PVOID)s_pbModuleEnd)) {

                *m_ppbTarget = (PBYTE)DETOUR_INSTRUCTION_TARGET_DYNAMIC;
            }
            else {
                // This can access violate on random bytes. Use DetourSetCodeModule.
                *m_ppbTarget = *ppbTarget;
            }
        }
        else {
            *m_ppbTarget = (PBYTE)DETOUR_INSTRUCTION_TARGET_DYNAMIC;
        }
    }
    else if (0x10 == (0x30 & b1) || // CALL /2 or /3  --> reg(bits 543) of ModR/M == 010 or 011
             0x20 == (0x30 & b1)) { // JMP /4 or /5 --> reg(bits 543) of ModR/M == 100 or 101
        *m_ppbTarget = (PBYTE)DETOUR_INSTRUCTION_TARGET_DYNAMIC;
    }
    return pbOut;
}

PBYTE CDetourDis::CopyVexEvexCommon(BYTE m, PBYTE pbDst, PBYTE pbSrc, BYTE p, BYTE fp16)
// m is first instead of last in the hopes of pbDst/pbSrc being
// passed along efficiently in the registers they were already in.
{
    static const COPYENTRY ceF38 = /* 38 */ ENTRY_CopyBytes2Mod;
    static const COPYENTRY ceF3A = /* 3A */ ENTRY_CopyBytes2Mod1;
    static const COPYENTRY ceInvalid = /* C4 */ ENTRY_Invalid;

    switch (p & 3) {
    case 0: break;
    case 1: m_bOperandOverride = TRUE; break;
    case 2: m_bF3 = TRUE; break;
    case 3: m_bF2 = TRUE; break;
    }

    REFCOPYENTRY pEntry;

    // see https://software.intel.com/content/www/us/en/develop/download/intel-avx512-fp16-architecture-specification.html
    switch (m | fp16) {
    default: return Invalid(&ceInvalid, pbDst, pbSrc);
    case 1:  pEntry = &s_rceCopyTable0F[pbSrc[0]];
             return (this->*pEntry->pfCopy)(pEntry, pbDst, pbSrc);
    case 5:  // fallthrough
    case 6:  // fallthrough
    case 2:  return CopyBytes(&ceF38, pbDst, pbSrc);
    case 3:  return CopyBytes(&ceF3A, pbDst, pbSrc);
    }
}

PBYTE CDetourDis::CopyVexCommon(BYTE m, PBYTE pbDst, PBYTE pbSrc)
// m is first instead of last in the hopes of pbDst/pbSrc being
// passed along efficiently in the registers they were already in.
{
    m_bVex = TRUE;
    BYTE const p = (BYTE)(pbSrc[-1] & 3); // p in last byte
    return CopyVexEvexCommon(m, pbDst, pbSrc, p);
}


PBYTE CDetourDis::CopyVex3(REFCOPYENTRY, PBYTE pbDst, PBYTE pbSrc)
// 3 byte VEX prefix 0xC4
{
#ifdef DETOURS_X86
    const static COPYENTRY ceLES = /* C4 */ ENTRY_CopyBytes2Mod;
    if ((pbSrc[1] & 0xC0) != 0xC0) {
        REFCOPYENTRY pEntry = &ceLES;
        return (this->*pEntry->pfCopy)(pEntry, pbDst, pbSrc);
    }
#endif
    pbDst[0] = pbSrc[0];
    pbDst[1] = pbSrc[1];
    pbDst[2] = pbSrc[2];
#ifdef DETOURS_X64
    m_bRaxOverride |= !!(pbSrc[2] & 0x80); // w in last byte, see CopyBytesRax
#else
    //
    // TODO
    //
    // Usually the VEX.W bit changes the size of a general purpose register and is ignored for 32bit.
    // Sometimes it is an opcode extension.
    // Look in the Intel manual, in the instruction-by-instruction reference, for ".W1",
    // without nearby wording saying it is ignored for 32bit.
    // For example: "VFMADD132PD/VFMADD213PD/VFMADD231PD Fused Multiply-Add of Packed Double-Precision Floating-Point Values".
    //
    // Then, go through each such case and determine if W0 vs. W1 affect the size of the instruction. Probably not.
    // Look for the same encoding but with "W1" changed to "W0".
    // Here is one such pairing:
    // VFMADD132PD/VFMADD213PD/VFMADD231PD Fused Multiply-Add of Packed Double-Precision Floating-Point Values
    //
    // VEX.DDS.128.66.0F38.W1 98 /r A V/V FMA Multiply packed double-precision floating-point values
    // from xmm0 and xmm2/mem, add to xmm1 and
    // put result in xmm0.
    // VFMADD132PD xmm0, xmm1, xmm2/m128
    //
    // VFMADD132PS/VFMADD213PS/VFMADD231PS Fused Multiply-Add of Packed Single-Precision Floating-Point Values
    // VEX.DDS.128.66.0F38.W0 98 /r A V/V FMA Multiply packed single-precision floating-point values
    // from xmm0 and xmm2/mem, add to xmm1 and put
    // result in xmm0.
    // VFMADD132PS xmm0, xmm1, xmm2/m128
    //
#endif
    return CopyVexCommon(pbSrc[1] & 0x1F, pbDst + 3, pbSrc + 3);
}

PBYTE CDetourDis::CopyVex2(REFCOPYENTRY, PBYTE pbDst, PBYTE pbSrc)
// 2 byte VEX prefix 0xC5
{
#ifdef DETOURS_X86
    const static COPYENTRY ceLDS = /* C5 */ ENTRY_CopyBytes2Mod;
    if ((pbSrc[1] & 0xC0) != 0xC0) {
        REFCOPYENTRY pEntry = &ceLDS;
        return (this->*pEntry->pfCopy)(pEntry, pbDst, pbSrc);
    }
#endif
    pbDst[0] = pbSrc[0];
    pbDst[1] = pbSrc[1];
    return CopyVexCommon(1, pbDst + 2, pbSrc + 2);
}

PBYTE CDetourDis::CopyEvex(REFCOPYENTRY, PBYTE pbDst, PBYTE pbSrc)
// 62, 3 byte payload, x86 with implied prefixes like Vex
// for 32bit, mode 0xC0 else fallback to bound /r
{
    // NOTE: Intel and Wikipedia number these differently.
    // Intel says 0-2, Wikipedia says 1-3.

    BYTE const p0 = pbSrc[1];

#ifdef DETOURS_X86
    const static COPYENTRY ceBound = /* 62 */ ENTRY_CopyBytes2Mod;
    if ((p0 & 0xC0) != 0xC0) {
        return CopyBytes(&ceBound, pbDst, pbSrc);
    }
#endif

    static const COPYENTRY ceInvalid = /* 62 */ ENTRY_Invalid;

    // This could also be handled by default in CopyVexEvexCommon
    // if 4u changed to 4|8.
    if (p0 & 8u)
        return Invalid(&ceInvalid, pbDst, pbSrc);

    BYTE const p1 = pbSrc[2];

    if ((p1 & 0x04) != 0x04)
        return Invalid(&ceInvalid, pbDst, pbSrc);

    // Copy 4 byte prefix.
    *(UNALIGNED ULONG *)pbDst = *(UNALIGNED ULONG*)pbSrc;

    m_bEvex = TRUE;

#ifdef DETOURS_X64
    m_bRaxOverride |= !!(p1 & 0x80); // w
#endif

    return CopyVexEvexCommon(p0 & 3u, pbDst + 4, pbSrc + 4, p1 & 3u, p0 & 4u);
}

PBYTE CDetourDis::CopyXop(REFCOPYENTRY, PBYTE pbDst, PBYTE pbSrc)
/* 3 byte AMD XOP prefix 0x8F
byte0: 0x8F
byte1: RXBmmmmm
byte2: WvvvvLpp
byte3: opcode
mmmmm >= 8, else pop
mmmmm only otherwise defined for 8, 9, A.
pp is like VEX but only instructions with 0 are defined
*/
{
    const static COPYENTRY cePop = /* 8F */ ENTRY_CopyBytes2Mod;
    const static COPYENTRY ceXop = /* 8F */ ENTRY_CopyBytesXop;
    const static COPYENTRY ceXop1 = /* 8F */ ENTRY_CopyBytesXop1;
    const static COPYENTRY ceXop4 = /* 8F */ ENTRY_CopyBytesXop4;

    BYTE const m = (BYTE)(pbSrc[1] & 0x1F);
    ASSERT(m <= 10);
    switch (m)
    {
    default:
        return CopyBytes(&cePop, pbDst, pbSrc);

    case 8: // modrm with 8bit immediate
        return CopyBytes(&ceXop1, pbDst, pbSrc);

    case 9: // modrm with no immediate
        return CopyBytes(&ceXop, pbDst, pbSrc);

    case 10: // modrm with 32bit immediate
        return CopyBytes(&ceXop4, pbDst, pbSrc);
    }
}

//////////////////////////////////////////////////////////////////////////////
//
PBYTE CDetourDis::s_pbModuleBeg = NULL;
PBYTE CDetourDis::s_pbModuleEnd = (PBYTE)~(ULONG_PTR)0;
BOOL CDetourDis::s_fLimitReferencesToModule = FALSE;

BOOL CDetourDis::SetCodeModule(PBYTE pbBeg, PBYTE pbEnd, BOOL fLimitReferencesToModule)
{
    if (pbEnd < pbBeg) {
        return FALSE;
    }

    s_pbModuleBeg = pbBeg;
    s_pbModuleEnd = pbEnd;
    s_fLimitReferencesToModule = fLimitReferencesToModule;

    return TRUE;
}

///////////////////////////////////////////////////////// Disassembler Tables.
//
const BYTE CDetourDis::s_rbModRm[256] = {
    0,0,0,0, SIB|1,RIP|4,0,0, 0,0,0,0, SIB|1,RIP|4,0,0, // 0x
    0,0,0,0, SIB|1,RIP|4,0,0, 0,0,0,0, SIB|1,RIP|4,0,0, // 1x
    0,0,0,0, SIB|1,RIP|4,0,0, 0,0,0,0, SIB|1,RIP|4,0,0, // 2x
    0,0,0,0, SIB|1,RIP|4,0,0, 0,0,0,0, SIB|1,RIP|4,0,0, // 3x
    1,1,1,1, 2,1,1,1, 1,1,1,1, 2,1,1,1,                 // 4x
    1,1,1,1, 2,1,1,1, 1,1,1,1, 2,1,1,1,                 // 5x
    1,1,1,1, 2,1,1,1, 1,1,1,1, 2,1,1,1,                 // 6x
    1,1,1,1, 2,1,1,1, 1,1,1,1, 2,1,1,1,                 // 7x
    4,4,4,4, 5,4,4,4, 4,4,4,4, 5,4,4,4,                 // 8x
    4,4,4,4, 5,4,4,4, 4,4,4,4, 5,4,4,4,                 // 9x
    4,4,4,4, 5,4,4,4, 4,4,4,4, 5,4,4,4,                 // Ax
    4,4,4,4, 5,4,4,4, 4,4,4,4, 5,4,4,4,                 // Bx
    0,0,0,0, 0,0,0,0, 0,0,0,0, 0,0,0,0,                 // Cx
    0,0,0,0, 0,0,0,0, 0,0,0,0, 0,0,0,0,                 // Dx
    0,0,0,0, 0,0,0,0, 0,0,0,0, 0,0,0,0,                 // Ex
    0,0,0,0, 0,0,0,0, 0,0,0,0, 0,0,0,0                  // Fx
};

const CDetourDis::COPYENTRY CDetourDis::s_rceCopyTable[] =
{
    /* 00 */ ENTRY_CopyBytes2Mod,                      // ADD /r
    /* 01 */ ENTRY_CopyBytes2Mod,                      // ADD /r
    /* 02 */ ENTRY_CopyBytes2Mod,                      // ADD /r
    /* 03 */ ENTRY_CopyBytes2Mod,                      // ADD /r
    /* 04 */ ENTRY_CopyBytes2,                         // ADD ib
    /* 05 */ ENTRY_CopyBytes3Or5,                      // ADD iw
#ifdef DETOURS_X64
    /* 06 */ ENTRY_Invalid,                            // Invalid
    /* 07 */ ENTRY_Invalid,                            // Invalid
#else
    /* 06 */ ENTRY_CopyBytes1,                         // PUSH
    /* 07 */ ENTRY_CopyBytes1,                         // POP
#endif
    /* 08 */ ENTRY_CopyBytes2Mod,                      // OR /r
    /* 09 */ ENTRY_CopyBytes2Mod,                      // OR /r
    /* 0A */ ENTRY_CopyBytes2Mod,                      // OR /r
    /* 0B */ ENTRY_CopyBytes2Mod,                      // OR /r
    /* 0C */ ENTRY_CopyBytes2,                         // OR ib
    /* 0D */ ENTRY_CopyBytes3Or5,                      // OR iw
#ifdef DETOURS_X64
    /* 0E */ ENTRY_Invalid,                            // Invalid
#else
    /* 0E */ ENTRY_CopyBytes1,                         // PUSH
#endif
    /* 0F */ ENTRY_Copy0F,                             // Extension Ops
    /* 10 */ ENTRY_CopyBytes2Mod,                      // ADC /r
    /* 11 */ ENTRY_CopyBytes2Mod,                      // ADC /r
    /* 12 */ ENTRY_CopyBytes2Mod,                      // ADC /r
    /* 13 */ ENTRY_CopyBytes2Mod,                      // ADC /r
    /* 14 */ ENTRY_CopyBytes2,                         // ADC ib
    /* 15 */ ENTRY_CopyBytes3Or5,                      // ADC id
#ifdef DETOURS_X64
    /* 16 */ ENTRY_Invalid,                            // Invalid
    /* 17 */ ENTRY_Invalid,                            // Invalid
#else
    /* 16 */ ENTRY_CopyBytes1,                         // PUSH
    /* 17 */ ENTRY_CopyBytes1,                         // POP
#endif
    /* 18 */ ENTRY_CopyBytes2Mod,                      // SBB /r
    /* 19 */ ENTRY_CopyBytes2Mod,                      // SBB /r
    /* 1A */ ENTRY_CopyBytes2Mod,                      // SBB /r
    /* 1B */ ENTRY_CopyBytes2Mod,                      // SBB /r
    /* 1C */ ENTRY_CopyBytes2,                         // SBB ib
    /* 1D */ ENTRY_CopyBytes3Or5,                      // SBB id
#ifdef DETOURS_X64
    /* 1E */ ENTRY_Invalid,                            // Invalid
    /* 1F */ ENTRY_Invalid,                            // Invalid
#else
    /* 1E */ ENTRY_CopyBytes1,                         // PUSH
    /* 1F */ ENTRY_CopyBytes1,                         // POP
#endif
    /* 20 */ ENTRY_CopyBytes2Mod,                      // AND /r
    /* 21 */ ENTRY_CopyBytes2Mod,                      // AND /r
    /* 22 */ ENTRY_CopyBytes2Mod,                      // AND /r
    /* 23 */ ENTRY_CopyBytes2Mod,                      // AND /r
    /* 24 */ ENTRY_CopyBytes2,                         // AND ib
    /* 25 */ ENTRY_CopyBytes3Or5,                      // AND id
    /* 26 */ ENTRY_CopyBytesSegment,                   // ES prefix
#ifdef DETOURS_X64
    /* 27 */ ENTRY_Invalid,                            // Invalid
#else
    /* 27 */ ENTRY_CopyBytes1,                         // DAA
#endif
    /* 28 */ ENTRY_CopyBytes2Mod,                      // SUB /r
    /* 29 */ ENTRY_CopyBytes2Mod,                      // SUB /r
    /* 2A */ ENTRY_CopyBytes2Mod,                      // SUB /r
    /* 2B */ ENTRY_CopyBytes2Mod,                      // SUB /r
    /* 2C */ ENTRY_CopyBytes2,                         // SUB ib
    /* 2D */ ENTRY_CopyBytes3Or5,                      // SUB id
    /* 2E */ ENTRY_CopyBytesSegment,                   // CS prefix
#ifdef DETOURS_X64
    /* 2F */ ENTRY_Invalid,                            // Invalid
#else
    /* 2F */ ENTRY_CopyBytes1,                         // DAS
#endif
    /* 30 */ ENTRY_CopyBytes2Mod,                      // XOR /r
    /* 31 */ ENTRY_CopyBytes2Mod,                      // XOR /r
    /* 32 */ ENTRY_CopyBytes2Mod,                      // XOR /r
    /* 33 */ ENTRY_CopyBytes2Mod,                      // XOR /r
    /* 34 */ ENTRY_CopyBytes2,                         // XOR ib
    /* 35 */ ENTRY_CopyBytes3Or5,                      // XOR id
    /* 36 */ ENTRY_CopyBytesSegment,                   // SS prefix
#ifdef DETOURS_X64
    /* 37 */ ENTRY_Invalid,                            // Invalid
#else
    /* 37 */ ENTRY_CopyBytes1,                         // AAA
#endif
    /* 38 */ ENTRY_CopyBytes2Mod,                      // CMP /r
    /* 39 */ ENTRY_CopyBytes2Mod,                      // CMP /r
    /* 3A */ ENTRY_CopyBytes2Mod,                      // CMP /r
    /* 3B */ ENTRY_CopyBytes2Mod,                      // CMP /r
    /* 3C */ ENTRY_CopyBytes2,                         // CMP ib
    /* 3D */ ENTRY_CopyBytes3Or5,                      // CMP id
    /* 3E */ ENTRY_CopyBytesSegment,                   // DS prefix
#ifdef DETOURS_X64
    /* 3F */ ENTRY_Invalid,                            // Invalid
#else
    /* 3F */ ENTRY_CopyBytes1,                         // AAS
#endif
#ifdef DETOURS_X64 // For Rax Prefix
    /* 40 */ ENTRY_CopyBytesRax,                       // Rax
    /* 41 */ ENTRY_CopyBytesRax,                       // Rax
    /* 42 */ ENTRY_CopyBytesRax,                       // Rax
    /* 43 */ ENTRY_CopyBytesRax,                       // Rax
    /* 44 */ ENTRY_CopyBytesRax,                       // Rax
    /* 45 */ ENTRY_CopyBytesRax,                       // Rax
    /* 46 */ ENTRY_CopyBytesRax,                       // Rax
    /* 47 */ ENTRY_CopyBytesRax,                       // Rax
    /* 48 */ ENTRY_CopyBytesRax,                       // Rax
    /* 49 */ ENTRY_CopyBytesRax,                       // Rax
    /* 4A */ ENTRY_CopyBytesRax,                       // Rax
    /* 4B */ ENTRY_CopyBytesRax,                       // Rax
    /* 4C */ ENTRY_CopyBytesRax,                       // Rax
    /* 4D */ ENTRY_CopyBytesRax,                       // Rax
    /* 4E */ ENTRY_CopyBytesRax,                       // Rax
    /* 4F */ ENTRY_CopyBytesRax,                       // Rax
#else
    /* 40 */ ENTRY_CopyBytes1,                         // INC
    /* 41 */ ENTRY_CopyBytes1,                         // INC
    /* 42 */ ENTRY_CopyBytes1,                         // INC
    /* 43 */ ENTRY_CopyBytes1,                         // INC
    /* 44 */ ENTRY_CopyBytes1,                         // INC
    /* 45 */ ENTRY_CopyBytes1,                         // INC
    /* 46 */ ENTRY_CopyBytes1,                         // INC
    /* 47 */ ENTRY_CopyBytes1,                         // INC
    /* 48 */ ENTRY_CopyBytes1,                         // DEC
    /* 49 */ ENTRY_CopyBytes1,                         // DEC
    /* 4A */ ENTRY_CopyBytes1,                         // DEC
    /* 4B */ ENTRY_CopyBytes1,                         // DEC
    /* 4C */ ENTRY_CopyBytes1,                         // DEC
    /* 4D */ ENTRY_CopyBytes1,                         // DEC
    /* 4E */ ENTRY_CopyBytes1,                         // DEC
    /* 4F */ ENTRY_CopyBytes1,                         // DEC
#endif
    /* 50 */ ENTRY_CopyBytes1,                         // PUSH
    /* 51 */ ENTRY_CopyBytes1,                         // PUSH
    /* 52 */ ENTRY_CopyBytes1,                         // PUSH
    /* 53 */ ENTRY_CopyBytes1,                         // PUSH
    /* 54 */ ENTRY_CopyBytes1,                         // PUSH
    /* 55 */ ENTRY_CopyBytes1,                         // PUSH
    /* 56 */ ENTRY_CopyBytes1,                         // PUSH
    /* 57 */ ENTRY_CopyBytes1,                         // PUSH
    /* 58 */ ENTRY_CopyBytes1,                         // POP
    /* 59 */ ENTRY_CopyBytes1,                         // POP
    /* 5A */ ENTRY_CopyBytes1,                         // POP
    /* 5B */ ENTRY_CopyBytes1,                         // POP
    /* 5C */ ENTRY_CopyBytes1,                         // POP
    /* 5D */ ENTRY_CopyBytes1,                         // POP
    /* 5E */ ENTRY_CopyBytes1,                         // POP
    /* 5F */ ENTRY_CopyBytes1,                         // POP
#ifdef DETOURS_X64
    /* 60 */ ENTRY_Invalid,                            // Invalid
    /* 61 */ ENTRY_Invalid,                            // Invalid
    /* 62 */ ENTRY_CopyEvex,                           // EVEX / AVX512
#else
    /* 60 */ ENTRY_CopyBytes1,                         // PUSHAD
    /* 61 */ ENTRY_CopyBytes1,                         // POPAD
    /* 62 */ ENTRY_CopyEvex,                           // BOUND /r and EVEX / AVX512
#endif
    /* 63 */ ENTRY_CopyBytes2Mod,                      // 32bit ARPL /r, 64bit MOVSXD
    /* 64 */ ENTRY_CopyBytesSegment,                   // FS prefix
    /* 65 */ ENTRY_CopyBytesSegment,                   // GS prefix
    /* 66 */ ENTRY_Copy66,                             // Operand Prefix
    /* 67 */ ENTRY_Copy67,                             // Address Prefix
    /* 68 */ ENTRY_CopyBytes3Or5,                      // PUSH
    /* 69 */ ENTRY_CopyBytes2ModOperand,               // IMUL /r iz
    /* 6A */ ENTRY_CopyBytes2,                         // PUSH
    /* 6B */ ENTRY_CopyBytes2Mod1,                     // IMUL /r ib
    /* 6C */ ENTRY_CopyBytes1,                         // INS
    /* 6D */ ENTRY_CopyBytes1,                         // INS
    /* 6E */ ENTRY_CopyBytes1,                         // OUTS/OUTSB
    /* 6F */ ENTRY_CopyBytes1,                         // OUTS/OUTSW
    /* 70 */ ENTRY_CopyBytes2Jump,                     // JO           // 0f80
    /* 71 */ ENTRY_CopyBytes2Jump,                     // JNO          // 0f81
    /* 72 */ ENTRY_CopyBytes2Jump,                     // JB/JC/JNAE   // 0f82
    /* 73 */ ENTRY_CopyBytes2Jump,                     // JAE/JNB/JNC  // 0f83
    /* 74 */ ENTRY_CopyBytes2Jump,                     // JE/JZ        // 0f84
    /* 75 */ ENTRY_CopyBytes2Jump,                     // JNE/JNZ      // 0f85
    /* 76 */ ENTRY_CopyBytes2Jump,                     // JBE/JNA      // 0f86
    /* 77 */ ENTRY_CopyBytes2Jump,                     // JA/JNBE      // 0f87
    /* 78 */ ENTRY_CopyBytes2Jump,                     // JS           // 0f88
    /* 79 */ ENTRY_CopyBytes2Jump,                     // JNS          // 0f89
    /* 7A */ ENTRY_CopyBytes2Jump,                     // JP/JPE       // 0f8a
    /* 7B */ ENTRY_CopyBytes2Jump,                     // JNP/JPO      // 0f8b
    /* 7C */ ENTRY_CopyBytes2Jump,                     // JL/JNGE      // 0f8c
    /* 7D */ ENTRY_CopyBytes2Jump,                     // JGE/JNL      // 0f8d
    /* 7E */ ENTRY_CopyBytes2Jump,                     // JLE/JNG      // 0f8e
    /* 7F */ ENTRY_CopyBytes2Jump,                     // JG/JNLE      // 0f8f
    /* 80 */ ENTRY_CopyBytes2Mod1,                     // ADD/0 OR/1 ADC/2 SBB/3 AND/4 SUB/5 XOR/6 CMP/7 byte reg, immediate byte
    /* 81 */ ENTRY_CopyBytes2ModOperand,               // ADD/0 OR/1 ADC/2 SBB/3 AND/4 SUB/5 XOR/6 CMP/7 byte reg, immediate word or dword
#ifdef DETOURS_X64
    /* 82 */ ENTRY_Invalid,                            // Invalid
#else
    /* 82 */ ENTRY_CopyBytes2Mod1,                     // MOV al,x
#endif
    /* 83 */ ENTRY_CopyBytes2Mod1,                     // ADD/0 OR/1 ADC/2 SBB/3 AND/4 SUB/5 XOR/6 CMP/7 reg, immediate byte
    /* 84 */ ENTRY_CopyBytes2Mod,                      // TEST /r
    /* 85 */ ENTRY_CopyBytes2Mod,                      // TEST /r
    /* 86 */ ENTRY_CopyBytes2Mod,                      // XCHG /r @todo
    /* 87 */ ENTRY_CopyBytes2Mod,                      // XCHG /r @todo
    /* 88 */ ENTRY_CopyBytes2Mod,                      // MOV /r
    /* 89 */ ENTRY_CopyBytes2Mod,                      // MOV /r
    /* 8A */ ENTRY_CopyBytes2Mod,                      // MOV /r
    /* 8B */ ENTRY_CopyBytes2Mod,                      // MOV /r
    /* 8C */ ENTRY_CopyBytes2Mod,                      // MOV /r
    /* 8D */ ENTRY_CopyBytes2Mod,                      // LEA /r
    /* 8E */ ENTRY_CopyBytes2Mod,                      // MOV /r
    /* 8F */ ENTRY_CopyXop,                            // POP /0 or AMD XOP
    /* 90 */ ENTRY_CopyBytes1,                         // NOP
    /* 91 */ ENTRY_CopyBytes1,                         // XCHG
    /* 92 */ ENTRY_CopyBytes1,                         // XCHG
    /* 93 */ ENTRY_CopyBytes1,                         // XCHG
    /* 94 */ ENTRY_CopyBytes1,                         // XCHG
    /* 95 */ ENTRY_CopyBytes1,                         // XCHG
    /* 96 */ ENTRY_CopyBytes1,                         // XCHG
    /* 97 */ ENTRY_CopyBytes1,                         // XCHG
    /* 98 */ ENTRY_CopyBytes1,                         // CWDE
    /* 99 */ ENTRY_CopyBytes1,                         // CDQ
#ifdef DETOURS_X64
    /* 9A */ ENTRY_Invalid,                            // Invalid
#else
    /* 9A */ ENTRY_CopyBytes5Or7Dynamic,               // CALL cp
#endif
    /* 9B */ ENTRY_CopyBytes1,                         // WAIT/FWAIT
    /* 9C */ ENTRY_CopyBytes1,                         // PUSHFD
    /* 9D */ ENTRY_CopyBytes1,                         // POPFD
    /* 9E */ ENTRY_CopyBytes1,                         // SAHF
    /* 9F */ ENTRY_CopyBytes1,                         // LAHF
    /* A0 */ ENTRY_CopyBytes1Address,                  // MOV
    /* A1 */ ENTRY_CopyBytes1Address,                  // MOV
    /* A2 */ ENTRY_CopyBytes1Address,                  // MOV
    /* A3 */ ENTRY_CopyBytes1Address,                  // MOV
    /* A4 */ ENTRY_CopyBytes1,                         // MOVS
    /* A5 */ ENTRY_CopyBytes1,                         // MOVS/MOVSD
    /* A6 */ ENTRY_CopyBytes1,                         // CMPS/CMPSB
    /* A7 */ ENTRY_CopyBytes1,                         // CMPS/CMPSW
    /* A8 */ ENTRY_CopyBytes2,                         // TEST
    /* A9 */ ENTRY_CopyBytes3Or5,                      // TEST
    /* AA */ ENTRY_CopyBytes1,                         // STOS/STOSB
    /* AB */ ENTRY_CopyBytes1,                         // STOS/STOSW
    /* AC */ ENTRY_CopyBytes1,                         // LODS/LODSB
    /* AD */ ENTRY_CopyBytes1,                         // LODS/LODSW
    /* AE */ ENTRY_CopyBytes1,                         // SCAS/SCASB
    /* AF */ ENTRY_CopyBytes1,                         // SCAS/SCASD
    /* B0 */ ENTRY_CopyBytes2,                         // MOV B0+rb
    /* B1 */ ENTRY_CopyBytes2,                         // MOV B0+rb
    /* B2 */ ENTRY_CopyBytes2,                         // MOV B0+rb
    /* B3 */ ENTRY_CopyBytes2,                         // MOV B0+rb
    /* B4 */ ENTRY_CopyBytes2,                         // MOV B0+rb
    /* B5 */ ENTRY_CopyBytes2,                         // MOV B0+rb
    /* B6 */ ENTRY_CopyBytes2,                         // MOV B0+rb
    /* B7 */ ENTRY_CopyBytes2,                         // MOV B0+rb
    /* B8 */ ENTRY_CopyBytes3Or5Rax,                   // MOV B8+rb
    /* B9 */ ENTRY_CopyBytes3Or5Rax,                   // MOV B8+rb
    /* BA */ ENTRY_CopyBytes3Or5Rax,                   // MOV B8+rb
    /* BB */ ENTRY_CopyBytes3Or5Rax,                   // MOV B8+rb
    /* BC */ ENTRY_CopyBytes3Or5Rax,                   // MOV B8+rb
    /* BD */ ENTRY_CopyBytes3Or5Rax,                   // MOV B8+rb
    /* BE */ ENTRY_CopyBytes3Or5Rax,                   // MOV B8+rb
    /* BF */ ENTRY_CopyBytes3Or5Rax,                   // MOV B8+rb
    /* C0 */ ENTRY_CopyBytes2Mod1,                     // RCL/2 ib, etc.
    /* C1 */ ENTRY_CopyBytes2Mod1,                     // RCL/2 ib, etc.
    /* C2 */ ENTRY_CopyBytes3,                         // RET
    /* C3 */ ENTRY_CopyBytes1,                         // RET
    /* C4 */ ENTRY_CopyVex3,                           // LES, VEX 3-byte opcodes.
    /* C5 */ ENTRY_CopyVex2,                           // LDS, VEX 2-byte opcodes.
    /* C6 */ ENTRY_CopyBytes2Mod1,                     // MOV
    /* C7 */ ENTRY_CopyBytes2ModOperand,               // MOV/0 XBEGIN/7
    /* C8 */ ENTRY_CopyBytes4,                         // ENTER
    /* C9 */ ENTRY_CopyBytes1,                         // LEAVE
    /* CA */ ENTRY_CopyBytes3Dynamic,                  // RET
    /* CB */ ENTRY_CopyBytes1Dynamic,                  // RET
    /* CC */ ENTRY_CopyBytes1Dynamic,                  // INT 3
    /* CD */ ENTRY_CopyBytes2Dynamic,                  // INT ib
#ifdef DETOURS_X64
    /* CE */ ENTRY_Invalid,                            // Invalid
#else
    /* CE */ ENTRY_CopyBytes1Dynamic,                  // INTO
#endif
    /* CF */ ENTRY_CopyBytes1Dynamic,                  // IRET
    /* D0 */ ENTRY_CopyBytes2Mod,                      // RCL/2, etc.
    /* D1 */ ENTRY_CopyBytes2Mod,                      // RCL/2, etc.
    /* D2 */ ENTRY_CopyBytes2Mod,                      // RCL/2, etc.
    /* D3 */ ENTRY_CopyBytes2Mod,                      // RCL/2, etc.
#ifdef DETOURS_X64
    /* D4 */ ENTRY_Invalid,                            // Invalid
    /* D5 */ ENTRY_Invalid,                            // Invalid
#else
    /* D4 */ ENTRY_CopyBytes2,                         // AAM
    /* D5 */ ENTRY_CopyBytes2,                         // AAD
#endif
    /* D6 */ ENTRY_Invalid,                            // Invalid
    /* D7 */ ENTRY_CopyBytes1,                         // XLAT/XLATB
    /* D8 */ ENTRY_CopyBytes2Mod,                      // FADD, etc.
    /* D9 */ ENTRY_CopyBytes2Mod,                      // F2XM1, etc.
    /* DA */ ENTRY_CopyBytes2Mod,                      // FLADD, etc.
    /* DB */ ENTRY_CopyBytes2Mod,                      // FCLEX, etc.
    /* DC */ ENTRY_CopyBytes2Mod,                      // FADD/0, etc.
    /* DD */ ENTRY_CopyBytes2Mod,                      // FFREE, etc.
    /* DE */ ENTRY_CopyBytes2Mod,                      // FADDP, etc.
    /* DF */ ENTRY_CopyBytes2Mod,                      // FBLD/4, etc.
    /* E0 */ ENTRY_CopyBytes2CantJump,                 // LOOPNE cb
    /* E1 */ ENTRY_CopyBytes2CantJump,                 // LOOPE cb
    /* E2 */ ENTRY_CopyBytes2CantJump,                 // LOOP cb
    /* E3 */ ENTRY_CopyBytes2CantJump,                 // JCXZ/JECXZ
    /* E4 */ ENTRY_CopyBytes2,                         // IN ib
    /* E5 */ ENTRY_CopyBytes2,                         // IN id
    /* E6 */ ENTRY_CopyBytes2,                         // OUT ib
    /* E7 */ ENTRY_CopyBytes2,                         // OUT ib
    /* E8 */ ENTRY_CopyBytes3Or5Target,                // CALL cd
    /* E9 */ ENTRY_CopyBytes3Or5Target,                // JMP cd
#ifdef DETOURS_X64
    /* EA */ ENTRY_Invalid,                            // Invalid
#else
    /* EA */ ENTRY_CopyBytes5Or7Dynamic,               // JMP cp
#endif
    /* EB */ ENTRY_CopyBytes2Jump,                     // JMP cb
    /* EC */ ENTRY_CopyBytes1,                         // IN ib
    /* ED */ ENTRY_CopyBytes1,                         // IN id
    /* EE */ ENTRY_CopyBytes1,                         // OUT
    /* EF */ ENTRY_CopyBytes1,                         // OUT
    /* F0 */ ENTRY_CopyBytesPrefix,                    // LOCK prefix
    /* F1 */ ENTRY_CopyBytes1Dynamic,                  // INT1 / ICEBP somewhat documented by AMD, not by Intel
    /* F2 */ ENTRY_CopyF2,                             // REPNE prefix
//#ifdef DETOURS_X86
    /* F3 */ ENTRY_CopyF3,                             // REPE prefix
//#else
// This does presently suffice for AMD64 but it requires tracing
// through a bunch of code to verify and seems not worth maintaining.
//  /* F3 */ ENTRY_CopyBytesPrefix,                    // REPE prefix
//#endif
    /* F4 */ ENTRY_CopyBytes1,                         // HLT
    /* F5 */ ENTRY_CopyBytes1,                         // CMC
    /* F6 */ ENTRY_CopyF6,                             // TEST/0, DIV/6
    /* F7 */ ENTRY_CopyF7,                             // TEST/0, DIV/6
    /* F8 */ ENTRY_CopyBytes1,                         // CLC
    /* F9 */ ENTRY_CopyBytes1,                         // STC
    /* FA */ ENTRY_CopyBytes1,                         // CLI
    /* FB */ ENTRY_CopyBytes1,                         // STI
    /* FC */ ENTRY_CopyBytes1,                         // CLD
    /* FD */ ENTRY_CopyBytes1,                         // STD
    /* FE */ ENTRY_CopyBytes2Mod,                      // DEC/1,INC/0
    /* FF */ ENTRY_CopyFF,                             // CALL/2
};

const CDetourDis::COPYENTRY CDetourDis::s_rceCopyTable0F[] =
{
#ifdef DETOURS_X86
    /* 00 */ ENTRY_Copy0F00,                           // sldt/0 str/1 lldt/2 ltr/3 err/4 verw/5 jmpe/6/dynamic invalid/7
#else
    /* 00 */ ENTRY_CopyBytes2Mod,                      // sldt/0 str/1 lldt/2 ltr/3 err/4 verw/5 jmpe/6/dynamic invalid/7
#endif
    /* 01 */ ENTRY_CopyBytes2Mod,                      // INVLPG/7, etc.
    /* 02 */ ENTRY_CopyBytes2Mod,                      // LAR/r
    /* 03 */ ENTRY_CopyBytes2Mod,                      // LSL/r
    /* 04 */ ENTRY_Invalid,                            // _04
    /* 05 */ ENTRY_CopyBytes1,                         // SYSCALL
    /* 06 */ ENTRY_CopyBytes1,                         // CLTS
    /* 07 */ ENTRY_CopyBytes1,                         // SYSRET
    /* 08 */ ENTRY_CopyBytes1,                         // INVD
    /* 09 */ ENTRY_CopyBytes1,                         // WBINVD
    /* 0A */ ENTRY_Invalid,                            // _0A
    /* 0B */ ENTRY_CopyBytes1,                         // UD2
    /* 0C */ ENTRY_Invalid,                            // _0C
    /* 0D */ ENTRY_CopyBytes2Mod,                      // PREFETCH
    /* 0E */ ENTRY_CopyBytes1,                         // FEMMS (3DNow -- not in Intel documentation)
    /* 0F */ ENTRY_CopyBytes2Mod1,                     // 3DNow Opcodes
    /* 10 */ ENTRY_CopyBytes2Mod,                      // MOVSS MOVUPD MOVSD
    /* 11 */ ENTRY_CopyBytes2Mod,                      // MOVSS MOVUPD MOVSD
    /* 12 */ ENTRY_CopyBytes2Mod,                      // MOVLPD
    /* 13 */ ENTRY_CopyBytes2Mod,                      // MOVLPD
    /* 14 */ ENTRY_CopyBytes2Mod,                      // UNPCKLPD
    /* 15 */ ENTRY_CopyBytes2Mod,                      // UNPCKHPD
    /* 16 */ ENTRY_CopyBytes2Mod,                      // MOVHPD
    /* 17 */ ENTRY_CopyBytes2Mod,                      // MOVHPD
    /* 18 */ ENTRY_CopyBytes2Mod,                      // PREFETCHINTA...
    /* 19 */ ENTRY_CopyBytes2Mod,                      // NOP/r multi byte nop, not documented by Intel, documented by AMD
    /* 1A */ ENTRY_CopyBytes2Mod,                      // NOP/r multi byte nop, not documented by Intel, documented by AMD
    /* 1B */ ENTRY_CopyBytes2Mod,                      // NOP/r multi byte nop, not documented by Intel, documented by AMD
    /* 1C */ ENTRY_CopyBytes2Mod,                      // NOP/r multi byte nop, not documented by Intel, documented by AMD
    /* 1D */ ENTRY_CopyBytes2Mod,                      // NOP/r multi byte nop, not documented by Intel, documented by AMD
    /* 1E */ ENTRY_CopyBytes2Mod,                      // NOP/r multi byte nop, not documented by Intel, documented by AMD
    /* 1F */ ENTRY_CopyBytes2Mod,                      // NOP/r multi byte nop
    /* 20 */ ENTRY_CopyBytes2Mod,                      // MOV/r
    /* 21 */ ENTRY_CopyBytes2Mod,                      // MOV/r
    /* 22 */ ENTRY_CopyBytes2Mod,                      // MOV/r
    /* 23 */ ENTRY_CopyBytes2Mod,                      // MOV/r
#ifdef DETOURS_X64
    /* 24 */ ENTRY_Invalid,                            // _24
#else
    /* 24 */ ENTRY_CopyBytes2Mod,                      // MOV/r,TR TR is test register on 80386 and 80486, removed in Pentium
#endif
    /* 25 */ ENTRY_Invalid,                            // _25
#ifdef DETOURS_X64
    /* 26 */ ENTRY_Invalid,                            // _26
#else
    /* 26 */ ENTRY_CopyBytes2Mod,                      // MOV TR/r TR is test register on 80386 and 80486, removed in Pentium
#endif
    /* 27 */ ENTRY_Invalid,                            // _27
    /* 28 */ ENTRY_CopyBytes2Mod,                      // MOVAPS MOVAPD
    /* 29 */ ENTRY_CopyBytes2Mod,                      // MOVAPS MOVAPD
    /* 2A */ ENTRY_CopyBytes2Mod,                      // CVPI2PS &
    /* 2B */ ENTRY_CopyBytes2Mod,                      // MOVNTPS MOVNTPD
    /* 2C */ ENTRY_CopyBytes2Mod,                      // CVTTPS2PI &
    /* 2D */ ENTRY_CopyBytes2Mod,                      // CVTPS2PI &
    /* 2E */ ENTRY_CopyBytes2Mod,                      // UCOMISS UCOMISD
    /* 2F */ ENTRY_CopyBytes2Mod,                      // COMISS COMISD
    /* 30 */ ENTRY_CopyBytes1,                         // WRMSR
    /* 31 */ ENTRY_CopyBytes1,                         // RDTSC
    /* 32 */ ENTRY_CopyBytes1,                         // RDMSR
    /* 33 */ ENTRY_CopyBytes1,                         // RDPMC
    /* 34 */ ENTRY_CopyBytes1,                         // SYSENTER
    /* 35 */ ENTRY_CopyBytes1,                         // SYSEXIT
    /* 36 */ ENTRY_Invalid,                            // _36
    /* 37 */ ENTRY_CopyBytes1,                         // GETSEC
    /* 38 */ ENTRY_CopyBytes3Mod,                      // SSE3 Opcodes
    /* 39 */ ENTRY_Invalid,                            // _39
    /* 3A */ ENTRY_CopyBytes3Mod1,                      // SSE3 Opcodes
    /* 3B */ ENTRY_Invalid,                            // _3B
    /* 3C */ ENTRY_Invalid,                            // _3C
    /* 3D */ ENTRY_Invalid,                            // _3D
    /* 3E */ ENTRY_Invalid,                            // _3E
    /* 3F */ ENTRY_Invalid,                            // _3F
    /* 40 */ ENTRY_CopyBytes2Mod,                      // CMOVO (0F 40)
    /* 41 */ ENTRY_CopyBytes2Mod,                      // CMOVNO (0F 41)
    /* 42 */ ENTRY_CopyBytes2Mod,                      // CMOVB & CMOVNE (0F 42)
    /* 43 */ ENTRY_CopyBytes2Mod,                      // CMOVAE & CMOVNB (0F 43)
    /* 44 */ ENTRY_CopyBytes2Mod,                      // CMOVE & CMOVZ (0F 44)
    /* 45 */ ENTRY_CopyBytes2Mod,                      // CMOVNE & CMOVNZ (0F 45)
    /* 46 */ ENTRY_CopyBytes2Mod,                      // CMOVBE & CMOVNA (0F 46)
    /* 47 */ ENTRY_CopyBytes2Mod,                      // CMOVA & CMOVNBE (0F 47)
    /* 48 */ ENTRY_CopyBytes2Mod,                      // CMOVS (0F 48)
    /* 49 */ ENTRY_CopyBytes2Mod,                      // CMOVNS (0F 49)
    /* 4A */ ENTRY_CopyBytes2Mod,                      // CMOVP & CMOVPE (0F 4A)
    /* 4B */ ENTRY_CopyBytes2Mod,                      // CMOVNP & CMOVPO (0F 4B)
    /* 4C */ ENTRY_CopyBytes2Mod,                      // CMOVL & CMOVNGE (0F 4C)
    /* 4D */ ENTRY_CopyBytes2Mod,                      // CMOVGE & CMOVNL (0F 4D)
    /* 4E */ ENTRY_CopyBytes2Mod,                      // CMOVLE & CMOVNG (0F 4E)
    /* 4F */ ENTRY_CopyBytes2Mod,                      // CMOVG & CMOVNLE (0F 4F)
    /* 50 */ ENTRY_CopyBytes2Mod,                      // MOVMSKPD MOVMSKPD
    /* 51 */ ENTRY_CopyBytes2Mod,                      // SQRTPS &
    /* 52 */ ENTRY_CopyBytes2Mod,                      // RSQRTTS RSQRTPS
    /* 53 */ ENTRY_CopyBytes2Mod,                      // RCPPS RCPSS
    /* 54 */ ENTRY_CopyBytes2Mod,                      // ANDPS ANDPD
    /* 55 */ ENTRY_CopyBytes2Mod,                      // ANDNPS ANDNPD
    /* 56 */ ENTRY_CopyBytes2Mod,                      // ORPS ORPD
    /* 57 */ ENTRY_CopyBytes2Mod,                      // XORPS XORPD
    /* 58 */ ENTRY_CopyBytes2Mod,                      // ADDPS &
    /* 59 */ ENTRY_CopyBytes2Mod,                      // MULPS &
    /* 5A */ ENTRY_CopyBytes2Mod,                      // CVTPS2PD &
    /* 5B */ ENTRY_CopyBytes2Mod,                      // CVTDQ2PS &
    /* 5C */ ENTRY_CopyBytes2Mod,                      // SUBPS &
    /* 5D */ ENTRY_CopyBytes2Mod,                      // MINPS &
    /* 5E */ ENTRY_CopyBytes2Mod,                      // DIVPS &
    /* 5F */ ENTRY_CopyBytes2Mod,                      // MASPS &
    /* 60 */ ENTRY_CopyBytes2Mod,                      // PUNPCKLBW/r
    /* 61 */ ENTRY_CopyBytes2Mod,                      // PUNPCKLWD/r
    /* 62 */ ENTRY_CopyBytes2Mod,                      // PUNPCKLWD/r
    /* 63 */ ENTRY_CopyBytes2Mod,                      // PACKSSWB/r
    /* 64 */ ENTRY_CopyBytes2Mod,                      // PCMPGTB/r
    /* 65 */ ENTRY_CopyBytes2Mod,                      // PCMPGTW/r
    /* 66 */ ENTRY_CopyBytes2Mod,                      // PCMPGTD/r
    /* 67 */ ENTRY_CopyBytes2Mod,                      // PACKUSWB/r
    /* 68 */ ENTRY_CopyBytes2Mod,                      // PUNPCKHBW/r
    /* 69 */ ENTRY_CopyBytes2Mod,                      // PUNPCKHWD/r
    /* 6A */ ENTRY_CopyBytes2Mod,                      // PUNPCKHDQ/r
    /* 6B */ ENTRY_CopyBytes2Mod,                      // PACKSSDW/r
    /* 6C */ ENTRY_CopyBytes2Mod,                      // PUNPCKLQDQ
    /* 6D */ ENTRY_CopyBytes2Mod,                      // PUNPCKHQDQ
    /* 6E */ ENTRY_CopyBytes2Mod,                      // MOVD/r
    /* 6F */ ENTRY_CopyBytes2Mod,                      // MOV/r
    /* 70 */ ENTRY_CopyBytes2Mod1,                     // PSHUFW/r ib
    /* 71 */ ENTRY_CopyBytes2Mod1,                     // PSLLW/6 ib,PSRAW/4 ib,PSRLW/2 ib
    /* 72 */ ENTRY_CopyBytes2Mod1,                     // PSLLD/6 ib,PSRAD/4 ib,PSRLD/2 ib
    /* 73 */ ENTRY_CopyBytes2Mod1,                     // PSLLQ/6 ib,PSRLQ/2 ib
    /* 74 */ ENTRY_CopyBytes2Mod,                      // PCMPEQB/r
    /* 75 */ ENTRY_CopyBytes2Mod,                      // PCMPEQW/r
    /* 76 */ ENTRY_CopyBytes2Mod,                      // PCMPEQD/r
    /* 77 */ ENTRY_CopyBytes1,                         // EMMS
    // extrq/insertq require mode=3 and are followed by two immediate bytes
    /* 78 */ ENTRY_Copy0F78,                           // VMREAD/r, 66/EXTRQ/r/ib/ib, F2/INSERTQ/r/ib/ib
    // extrq/insertq require mod=3, therefore ENTRY_CopyBytes2, but it ends up the same
    /* 79 */ ENTRY_CopyBytes2Mod,                      // VMWRITE/r, 66/EXTRQ/r, F2/INSERTQ/r
    /* 7A */ ENTRY_Invalid,                            // _7A
    /* 7B */ ENTRY_Invalid,                            // _7B
    /* 7C */ ENTRY_CopyBytes2Mod,                      // HADDPS
    /* 7D */ ENTRY_CopyBytes2Mod,                      // HSUBPS
    /* 7E */ ENTRY_CopyBytes2Mod,                      // MOVD/r
    /* 7F */ ENTRY_CopyBytes2Mod,                      // MOV/r
    /* 80 */ ENTRY_CopyBytes3Or5Target,                // JO
    /* 81 */ ENTRY_CopyBytes3Or5Target,                // JNO
    /* 82 */ ENTRY_CopyBytes3Or5Target,                // JB,JC,JNAE
    /* 83 */ ENTRY_CopyBytes3Or5Target,                // JAE,JNB,JNC
    /* 84 */ ENTRY_CopyBytes3Or5Target,                // JE,JZ,JZ
    /* 85 */ ENTRY_CopyBytes3Or5Target,                // JNE,JNZ
    /* 86 */ ENTRY_CopyBytes3Or5Target,                // JBE,JNA
    /* 87 */ ENTRY_CopyBytes3Or5Target,                // JA,JNBE
    /* 88 */ ENTRY_CopyBytes3Or5Target,                // JS
    /* 89 */ ENTRY_CopyBytes3Or5Target,                // JNS
    /* 8A */ ENTRY_CopyBytes3Or5Target,                // JP,JPE
    /* 8B */ ENTRY_CopyBytes3Or5Target,                // JNP,JPO
    /* 8C */ ENTRY_CopyBytes3Or5Target,                // JL,NGE
    /* 8D */ ENTRY_CopyBytes3Or5Target,                // JGE,JNL
    /* 8E */ ENTRY_CopyBytes3Or5Target,                // JLE,JNG
    /* 8F */ ENTRY_CopyBytes3Or5Target,                // JG,JNLE
    /* 90 */ ENTRY_CopyBytes2Mod,                      // CMOVO (0F 40)
    /* 91 */ ENTRY_CopyBytes2Mod,                      // CMOVNO (0F 41)
    /* 92 */ ENTRY_CopyBytes2Mod,                      // CMOVB & CMOVC & CMOVNAE (0F 42)
    /* 93 */ ENTRY_CopyBytes2Mod,                      // CMOVAE & CMOVNB & CMOVNC (0F 43)
    /* 94 */ ENTRY_CopyBytes2Mod,                      // CMOVE & CMOVZ (0F 44)
    /* 95 */ ENTRY_CopyBytes2Mod,                      // CMOVNE & CMOVNZ (0F 45)
    /* 96 */ ENTRY_CopyBytes2Mod,                      // CMOVBE & CMOVNA (0F 46)
    /* 97 */ ENTRY_CopyBytes2Mod,                      // CMOVA & CMOVNBE (0F 47)
    /* 98 */ ENTRY_CopyBytes2Mod,                      // CMOVS (0F 48)
    /* 99 */ ENTRY_CopyBytes2Mod,                      // CMOVNS (0F 49)
    /* 9A */ ENTRY_CopyBytes2Mod,                      // CMOVP & CMOVPE (0F 4A)
    /* 9B */ ENTRY_CopyBytes2Mod,                      // CMOVNP & CMOVPO (0F 4B)
    /* 9C */ ENTRY_CopyBytes2Mod,                      // CMOVL & CMOVNGE (0F 4C)
    /* 9D */ ENTRY_CopyBytes2Mod,                      // CMOVGE & CMOVNL (0F 4D)
    /* 9E */ ENTRY_CopyBytes2Mod,                      // CMOVLE & CMOVNG (0F 4E)
    /* 9F */ ENTRY_CopyBytes2Mod,                      // CMOVG & CMOVNLE (0F 4F)
    /* A0 */ ENTRY_CopyBytes1,                         // PUSH
    /* A1 */ ENTRY_CopyBytes1,                         // POP
    /* A2 */ ENTRY_CopyBytes1,                         // CPUID
    /* A3 */ ENTRY_CopyBytes2Mod,                      // BT  (0F A3)
    /* A4 */ ENTRY_CopyBytes2Mod1,                     // SHLD
    /* A5 */ ENTRY_CopyBytes2Mod,                      // SHLD
    /* A6 */ ENTRY_CopyBytes2Mod,                      // XBTS
    /* A7 */ ENTRY_CopyBytes2Mod,                      // IBTS
    /* A8 */ ENTRY_CopyBytes1,                         // PUSH
    /* A9 */ ENTRY_CopyBytes1,                         // POP
    /* AA */ ENTRY_CopyBytes1,                         // RSM
    /* AB */ ENTRY_CopyBytes2Mod,                      // BTS (0F AB)
    /* AC */ ENTRY_CopyBytes2Mod1,                     // SHRD
    /* AD */ ENTRY_CopyBytes2Mod,                      // SHRD

    // 0F AE mod76=mem mod543=0 fxsave
    // 0F AE mod76=mem mod543=1 fxrstor
    // 0F AE mod76=mem mod543=2 ldmxcsr
    // 0F AE mod76=mem mod543=3 stmxcsr
    // 0F AE mod76=mem mod543=4 xsave
    // 0F AE mod76=mem mod543=5 xrstor
    // 0F AE mod76=mem mod543=6 saveopt
    // 0F AE mod76=mem mod543=7 clflush
    // 0F AE mod76=11b mod543=5 lfence
    // 0F AE mod76=11b mod543=6 mfence
    // 0F AE mod76=11b mod543=7 sfence
    // F3 0F AE mod76=11b mod543=0 rdfsbase
    // F3 0F AE mod76=11b mod543=1 rdgsbase
    // F3 0F AE mod76=11b mod543=2 wrfsbase
    // F3 0F AE mod76=11b mod543=3 wrgsbase
    /* AE */ ENTRY_CopyBytes2Mod,                      // fxsave fxrstor ldmxcsr stmxcsr xsave xrstor saveopt clflush lfence mfence sfence rdfsbase rdgsbase wrfsbase wrgsbase
    /* AF */ ENTRY_CopyBytes2Mod,                      // IMUL (0F AF)
    /* B0 */ ENTRY_CopyBytes2Mod,                      // CMPXCHG (0F B0)
    /* B1 */ ENTRY_CopyBytes2Mod,                      // CMPXCHG (0F B1)
    /* B2 */ ENTRY_CopyBytes2Mod,                      // LSS/r
    /* B3 */ ENTRY_CopyBytes2Mod,                      // BTR (0F B3)
    /* B4 */ ENTRY_CopyBytes2Mod,                      // LFS/r
    /* B5 */ ENTRY_CopyBytes2Mod,                      // LGS/r
    /* B6 */ ENTRY_CopyBytes2Mod,                      // MOVZX/r
    /* B7 */ ENTRY_CopyBytes2Mod,                      // MOVZX/r
#ifdef DETOURS_X86
    /* B8 */ ENTRY_Copy0FB8,                           // jmpe f3/popcnt
#else
    /* B8 */ ENTRY_CopyBytes2Mod,                      // f3/popcnt
#endif
    /* B9 */ ENTRY_Invalid,                            // _B9
    /* BA */ ENTRY_CopyBytes2Mod1,                     // BT & BTC & BTR & BTS (0F BA)
    /* BB */ ENTRY_CopyBytes2Mod,                      // BTC (0F BB)
    /* BC */ ENTRY_CopyBytes2Mod,                      // BSF (0F BC)
    /* BD */ ENTRY_CopyBytes2Mod,                      // BSR (0F BD)
    /* BE */ ENTRY_CopyBytes2Mod,                      // MOVSX/r
    /* BF */ ENTRY_CopyBytes2Mod,                      // MOVSX/r
    /* C0 */ ENTRY_CopyBytes2Mod,                      // XADD/r
    /* C1 */ ENTRY_CopyBytes2Mod,                      // XADD/r
    /* C2 */ ENTRY_CopyBytes2Mod1,                     // CMPPS &
    /* C3 */ ENTRY_CopyBytes2Mod,                      // MOVNTI
    /* C4 */ ENTRY_CopyBytes2Mod1,                     // PINSRW /r ib
    /* C5 */ ENTRY_CopyBytes2Mod1,                     // PEXTRW /r ib
    /* C6 */ ENTRY_CopyBytes2Mod1,                     // SHUFPS & SHUFPD
    /* C7 */ ENTRY_CopyBytes2Mod,                      // CMPXCHG8B (0F C7)
    /* C8 */ ENTRY_CopyBytes1,                         // BSWAP 0F C8 + rd
    /* C9 */ ENTRY_CopyBytes1,                         // BSWAP 0F C8 + rd
    /* CA */ ENTRY_CopyBytes1,                         // BSWAP 0F C8 + rd
    /* CB */ ENTRY_CopyBytes1,                         // CVTPD2PI BSWAP 0F C8 + rd
    /* CC */ ENTRY_CopyBytes1,                         // BSWAP 0F C8 + rd
    /* CD */ ENTRY_CopyBytes1,                         // BSWAP 0F C8 + rd
    /* CE */ ENTRY_CopyBytes1,                         // BSWAP 0F C8 + rd
    /* CF */ ENTRY_CopyBytes1,                         // BSWAP 0F C8 + rd
    /* D0 */ ENTRY_CopyBytes2Mod,                      // ADDSUBPS (untestd)
    /* D1 */ ENTRY_CopyBytes2Mod,                      // PSRLW/r
    /* D2 */ ENTRY_CopyBytes2Mod,                      // PSRLD/r
    /* D3 */ ENTRY_CopyBytes2Mod,                      // PSRLQ/r
    /* D4 */ ENTRY_CopyBytes2Mod,                      // PADDQ
    /* D5 */ ENTRY_CopyBytes2Mod,                      // PMULLW/r
    /* D6 */ ENTRY_CopyBytes2Mod,                      // MOVDQ2Q / MOVQ2DQ
    /* D7 */ ENTRY_CopyBytes2Mod,                      // PMOVMSKB/r
    /* D8 */ ENTRY_CopyBytes2Mod,                      // PSUBUSB/r
    /* D9 */ ENTRY_CopyBytes2Mod,                      // PSUBUSW/r
    /* DA */ ENTRY_CopyBytes2Mod,                      // PMINUB/r
    /* DB */ ENTRY_CopyBytes2Mod,                      // PAND/r
    /* DC */ ENTRY_CopyBytes2Mod,                      // PADDUSB/r
    /* DD */ ENTRY_CopyBytes2Mod,                      // PADDUSW/r
    /* DE */ ENTRY_CopyBytes2Mod,                      // PMAXUB/r
    /* DF */ ENTRY_CopyBytes2Mod,                      // PANDN/r
    /* E0 */ ENTRY_CopyBytes2Mod ,                     // PAVGB
    /* E1 */ ENTRY_CopyBytes2Mod,                      // PSRAW/r
    /* E2 */ ENTRY_CopyBytes2Mod,                      // PSRAD/r
    /* E3 */ ENTRY_CopyBytes2Mod,                      // PAVGW
    /* E4 */ ENTRY_CopyBytes2Mod,                      // PMULHUW/r
    /* E5 */ ENTRY_CopyBytes2Mod,                      // PMULHW/r
    /* E6 */ ENTRY_CopyBytes2Mod,                      // CTDQ2PD &
    /* E7 */ ENTRY_CopyBytes2Mod,                      // MOVNTQ
    /* E8 */ ENTRY_CopyBytes2Mod,                      // PSUBB/r
    /* E9 */ ENTRY_CopyBytes2Mod,                      // PSUBW/r
    /* EA */ ENTRY_CopyBytes2Mod,                      // PMINSW/r
    /* EB */ ENTRY_CopyBytes2Mod,                      // POR/r
    /* EC */ ENTRY_CopyBytes2Mod,                      // PADDSB/r
    /* ED */ ENTRY_CopyBytes2Mod,                      // PADDSW/r
    /* EE */ ENTRY_CopyBytes2Mod,                      // PMAXSW /r
    /* EF */ ENTRY_CopyBytes2Mod,                      // PXOR/r
    /* F0 */ ENTRY_CopyBytes2Mod,                      // LDDQU
    /* F1 */ ENTRY_CopyBytes2Mod,                      // PSLLW/r
    /* F2 */ ENTRY_CopyBytes2Mod,                      // PSLLD/r
    /* F3 */ ENTRY_CopyBytes2Mod,                      // PSLLQ/r
    /* F4 */ ENTRY_CopyBytes2Mod,                      // PMULUDQ/r
    /* F5 */ ENTRY_CopyBytes2Mod,                      // PMADDWD/r
    /* F6 */ ENTRY_CopyBytes2Mod,                      // PSADBW/r
    /* F7 */ ENTRY_CopyBytes2Mod,                      // MASKMOVQ
    /* F8 */ ENTRY_CopyBytes2Mod,                      // PSUBB/r
    /* F9 */ ENTRY_CopyBytes2Mod,                      // PSUBW/r
    /* FA */ ENTRY_CopyBytes2Mod,                      // PSUBD/r
    /* FB */ ENTRY_CopyBytes2Mod,                      // FSUBQ/r
    /* FC */ ENTRY_CopyBytes2Mod,                      // PADDB/r
    /* FD */ ENTRY_CopyBytes2Mod,                      // PADDW/r
    /* FE */ ENTRY_CopyBytes2Mod,                      // PADDD/r
    /* FF */ ENTRY_Invalid,                            // _FF
};

BOOL CDetourDis::SanityCheckSystem()
{
    C_ASSERT(ARRAYSIZE(CDetourDis::s_rceCopyTable) == 256);
    C_ASSERT(ARRAYSIZE(CDetourDis::s_rceCopyTable0F) == 256);
    return TRUE;
}
#endif // defined(DETOURS_X64) || defined(DETOURS_X86)

/////////////////////////////////////////////////////////// IA64 Disassembler.
//
#ifdef DETOURS_IA64

#if defined(_IA64_) != defined(DETOURS_IA64_OFFLINE_LIBRARY)
// Compile DETOUR_IA64_BUNDLE for native IA64 or cross, but not both -- we get duplicates otherwise.
const DETOUR_IA64_BUNDLE::DETOUR_IA64_METADATA DETOUR_IA64_BUNDLE::s_rceCopyTable[33] =
{
    { 0x00, M_UNIT,      I_UNIT,      I_UNIT,   },
    { 0x01, M_UNIT,      I_UNIT,      I_UNIT,   },
    { 0x02, M_UNIT,      I_UNIT,      I_UNIT,   },
    { 0x03, M_UNIT,      I_UNIT,      I_UNIT,   },
    { 0x04, M_UNIT,      L_UNIT,      X_UNIT,   },
    { 0x05, M_UNIT,      L_UNIT,      X_UNIT,   },
    { 0x06, 0,           0,           0,        },
    { 0x07, 0,           0,           0,        },
    { 0x08, M_UNIT,      M_UNIT,      I_UNIT,   },
    { 0x09, M_UNIT,      M_UNIT,      I_UNIT,   },
    { 0x0a, M_UNIT,      M_UNIT,      I_UNIT,   },
    { 0x0b, M_UNIT,      M_UNIT,      I_UNIT,   },
    { 0x0c, M_UNIT,      F_UNIT,      I_UNIT,   },
    { 0x0d, M_UNIT,      F_UNIT,      I_UNIT,   },
    { 0x0e, M_UNIT,      M_UNIT,      F_UNIT,   },
    { 0x0f, M_UNIT,      M_UNIT,      F_UNIT,   },
    { 0x10, M_UNIT,      I_UNIT,      B_UNIT,   },
    { 0x11, M_UNIT,      I_UNIT,      B_UNIT,   },
    { 0x12, M_UNIT,      B_UNIT,      B_UNIT,   },
    { 0x13, M_UNIT,      B_UNIT,      B_UNIT,   },
    { 0x14, 0,           0,           0,        },
    { 0x15, 0,           0,           0,        },
    { 0x16, B_UNIT,      B_UNIT,      B_UNIT,   },
    { 0x17, B_UNIT,      B_UNIT,      B_UNIT,   },
    { 0x18, M_UNIT,      M_UNIT,      B_UNIT,   },
    { 0x19, M_UNIT,      M_UNIT,      B_UNIT,   },
    { 0x1a, 0,           0,           0,        },
    { 0x1b, 0,           0,           0,        },
    { 0x1c, M_UNIT,      F_UNIT,      B_UNIT,   },
    { 0x1d, M_UNIT,      F_UNIT,      B_UNIT,   },
    { 0x1e, 0,           0,           0,        },
    { 0x1f, 0,           0,           0,        },
    { 0x00, 0,           0,           0,        },
};

// 120 112 104 96 88 80 72 64 56 48 40 32 24 16  8  0
//  f.  e.  d. c. b. a. 9. 8. 7. 6. 5. 4. 3. 2. 1. 0.

//                                      00
// f.e. d.c. b.a. 9.8. 7.6. 5.4. 3.2. 1.0.
// 0000 0000 0000 0000 0000 0000 0000 001f : Template [4..0]
// 0000 0000 0000 0000 0000 03ff ffff ffe0 : Zero [ 41..  5]
// 0000 0000 0000 0000 0000 3c00 0000 0000 : Zero [ 45.. 42]
// 0000 0000 0007 ffff ffff c000 0000 0000 : One  [ 82.. 46]
// 0000 0000 0078 0000 0000 0000 0000 0000 : One  [ 86.. 83]
// 0fff ffff ff80 0000 0000 0000 0000 0000 : Two  [123.. 87]
// f000 0000 0000 0000 0000 0000 0000 0000 : Two  [127..124]
BYTE DETOUR_IA64_BUNDLE::GetTemplate() const
{
    return (data[0] & 0x1f);
}

BYTE DETOUR_IA64_BUNDLE::GetInst0() const
{
    return ((data[5] & 0x3c) >> 2);
}

BYTE DETOUR_IA64_BUNDLE::GetInst1() const
{
    return ((data[10] & 0x78) >> 3);
}

BYTE DETOUR_IA64_BUNDLE::GetInst2() const
{
    return ((data[15] & 0xf0) >> 4);
}

BYTE DETOUR_IA64_BUNDLE::GetUnit(BYTE slot) const
{
    switch (slot) {
    case 0: return GetUnit0();
    case 1: return GetUnit1();
    case 2: return GetUnit2();
    }
    __debugbreak();
    return 0;
}

BYTE DETOUR_IA64_BUNDLE::GetUnit0() const
{
    return s_rceCopyTable[data[0] & 0x1f].nUnit0;
}

BYTE DETOUR_IA64_BUNDLE::GetUnit1() const
{
    return s_rceCopyTable[data[0] & 0x1f].nUnit1;
}

BYTE DETOUR_IA64_BUNDLE::GetUnit2() const
{
    return s_rceCopyTable[data[0] & 0x1f].nUnit2;
}

UINT64 DETOUR_IA64_BUNDLE::GetData0() const
{
    return (((wide[0] & 0x000003ffffffffe0) >> 5));
}

UINT64 DETOUR_IA64_BUNDLE::GetData1() const
{
    return (((wide[0] & 0xffffc00000000000) >> 46) |
            ((wide[1] & 0x000000000007ffff) << 18));
}

UINT64 DETOUR_IA64_BUNDLE::GetData2() const
{
    return (((wide[1] & 0x0fffffffff800000) >> 23));
}

VOID DETOUR_IA64_BUNDLE::SetInst(BYTE slot, BYTE nInst)
{
    switch (slot)
    {
    case 0: SetInst0(nInst); return;
    case 1: SetInst1(nInst); return;
    case 2: SetInst2(nInst); return;
    }
    __debugbreak();
}

VOID DETOUR_IA64_BUNDLE::SetInst0(BYTE nInst)
{
    data[5] = (data[5] & ~0x3c) | ((nInst << 2) & 0x3c);
}

VOID DETOUR_IA64_BUNDLE::SetInst1(BYTE nInst)
{
    data[10] = (data[10] & ~0x78) | ((nInst << 3) & 0x78);
}

VOID DETOUR_IA64_BUNDLE::SetInst2(BYTE nInst)
{
    data[15] = (data[15] & ~0xf0) | ((nInst << 4) & 0xf0);
}

VOID DETOUR_IA64_BUNDLE::SetData(BYTE slot, UINT64 nData)
{
    switch (slot)
    {
    case 0: SetData0(nData); return;
    case 1: SetData1(nData); return;
    case 2: SetData2(nData); return;
    }
    __debugbreak();
}

VOID DETOUR_IA64_BUNDLE::SetData0(UINT64 nData)
{
    wide[0] = (wide[0] & ~0x000003ffffffffe0) | (( nData << 5)  & 0x000003ffffffffe0);
}

VOID DETOUR_IA64_BUNDLE::SetData1(UINT64 nData)
{
    wide[0] = (wide[0] & ~0xffffc00000000000) | ((nData << 46) & 0xffffc00000000000);
    wide[1] = (wide[1] & ~0x000000000007ffff) | ((nData >> 18) & 0x000000000007ffff);
}

VOID DETOUR_IA64_BUNDLE::SetData2(UINT64 nData)
{
    wide[1] = (wide[1] & ~0x0fffffffff800000) | ((nData << 23) & 0x0fffffffff800000);
}

UINT64 DETOUR_IA64_BUNDLE::GetInstruction(BYTE slot) const
{
    switch (slot) {
    case 0: return GetInstruction0();
    case 1: return GetInstruction1();
    case 2: return GetInstruction2();
    }
    __debugbreak();
    return 0;
}

UINT64 DETOUR_IA64_BUNDLE::GetInstruction0() const
{
    // 41 bits from wide[0], skipping the 5 bit template.
    return GetBits(wide[0], DETOUR_IA64_INSTRUCTION0_OFFSET, DETOUR_IA64_INSTRUCTION_SIZE);
}

UINT64 DETOUR_IA64_BUNDLE::GetInstruction1() const
{
    // 64-46 bits from wide[0] and the rest from wide[1].
    const UINT count0 = 64 - DETOUR_IA64_INSTRUCTION1_OFFSET;
    const UINT count1 = DETOUR_IA64_INSTRUCTION_SIZE - count0;
    return GetBits(wide[0], DETOUR_IA64_INSTRUCTION1_OFFSET, count0) | (GetBits(wide[1], 0, count1) << count0);
}

UINT64 DETOUR_IA64_BUNDLE::GetInstruction2() const
{
    // Upper 41 bits of wide[1].
    return wide[1] >> (64 - DETOUR_IA64_INSTRUCTION_SIZE);
}

void DETOUR_IA64_BUNDLE::SetInstruction(BYTE slot, UINT64 instruction)
{
    switch (slot) {
    case 0: SetInstruction0(instruction); return;
    case 1: SetInstruction1(instruction); return;
    case 2: SetInstruction2(instruction); return;
    }
    __debugbreak();
}

void DETOUR_IA64_BUNDLE::SetInstruction0(UINT64 instruction)
{
    wide[0] = SetBits(wide[0], DETOUR_IA64_INSTRUCTION0_OFFSET, DETOUR_IA64_INSTRUCTION_SIZE, instruction);
}

void DETOUR_IA64_BUNDLE::SetInstruction1(UINT64 instruction)
{
    UINT const count0 = 64 - DETOUR_IA64_INSTRUCTION1_OFFSET;
    UINT const count1 = DETOUR_IA64_INSTRUCTION_SIZE - count0;
    UINT64 const wide0 = SetBits(wide[0], DETOUR_IA64_INSTRUCTION1_OFFSET, count0, instruction);
    UINT64 const wide1 = SetBits(wide[1], 0, count1, instruction >> count0);
    wide[0] = wide0;
    wide[1] = wide1;
}

void DETOUR_IA64_BUNDLE::SetInstruction2(UINT64 instruction)
{
    // Set upper 41 bits of wide[1].
    wide[1] = SetBits(wide[1], 64 - DETOUR_IA64_INSTRUCTION_SIZE, DETOUR_IA64_INSTRUCTION_SIZE, instruction);
}

UINT64 DETOUR_IA64_BUNDLE::SignExtend(UINT64 Value, UINT64 Offset)
// This definition is from the IA64 manual.
{
    if ((Value & (((UINT64)1) << (Offset - 1))) == 0)
        return Value;
    UINT64 const new_value = Value | ((~(UINT64)0) << Offset);
    return new_value;
}

UINT64 DETOUR_IA64_BUNDLE::GetBits(UINT64 Value, UINT64 Offset, UINT64 Count)
{
    UINT64 const new_value = (Value >> Offset) & ~(~((UINT64)0) << Count);
    return new_value;
}

UINT64 DETOUR_IA64_BUNDLE::SetBits(UINT64 Value, UINT64 Offset, UINT64 Count, UINT64 Field)
{
    UINT64 const mask = (~((~(UINT64)0) << Count)) << Offset;
    UINT64 const new_value = (Value & ~mask) | ((Field << Offset) & mask);
    return new_value;
}

UINT64 DETOUR_IA64_BUNDLE::GetOpcode(UINT64 instruction)
// Get 4bit primary opcode.
{
    UINT64 const opcode = GetBits(instruction, DETOUR_IA64_INSTRUCTION_SIZE - 4, 4);
    return opcode;
}

UINT64 DETOUR_IA64_BUNDLE::GetX(UINT64 instruction)
// Get 1bit opcode extension.
{
    UINT64 const x = GetBits(instruction, 33, 1);
    return x;
}

UINT64 DETOUR_IA64_BUNDLE::GetX3(UINT64 instruction)
// Get 3bit opcode extension.
{
    UINT64 const x3 = GetBits(instruction, 33, 3);
    return x3;
}

UINT64 DETOUR_IA64_BUNDLE::GetX6(UINT64 instruction)
// Get 6bit opcode extension.
{
    UINT64 const x6 = GetBits(instruction, 27, 6);
    return x6;
}

UINT64 DETOUR_IA64_BUNDLE::GetImm7a(UINT64 instruction)
{
    UINT64 const imm7a = GetBits(instruction, 6, 7);
    return imm7a;
}

UINT64 DETOUR_IA64_BUNDLE::SetImm7a(UINT64 instruction, UINT64 imm7a)
{
    UINT64 const new_instruction = SetBits(instruction, 6, 7, imm7a);
    return new_instruction;
}

UINT64 DETOUR_IA64_BUNDLE::GetImm13c(UINT64 instruction)
{
    UINT64 const imm13c = GetBits(instruction, 20, 13);
    return imm13c;
}

UINT64 DETOUR_IA64_BUNDLE::SetImm13c(UINT64 instruction, UINT64 imm13c)
{
    UINT64 const new_instruction = SetBits(instruction, 20, 13, imm13c);
    return new_instruction;
}

UINT64 DETOUR_IA64_BUNDLE::GetSignBit(UINT64 instruction)
{
    UINT64 const signBit = GetBits(instruction, 36, 1);
    return signBit;
}

UINT64 DETOUR_IA64_BUNDLE::SetSignBit(UINT64 instruction, UINT64 signBit)
{
    UINT64 const new_instruction = SetBits(instruction, 36, 1, signBit);
    return new_instruction;
}

UINT64 DETOUR_IA64_BUNDLE::GetImm20a(UINT64 instruction)
{
    UINT64 const imm20a = GetBits(instruction, 6, 20);
    return imm20a;
}

UINT64 DETOUR_IA64_BUNDLE::SetImm20a(UINT64 instruction, UINT64 imm20a)
{
    UINT64 const new_instruction = SetBits(instruction, 6, 20, imm20a);
    return new_instruction;
}

UINT64 DETOUR_IA64_BUNDLE::GetImm20b(UINT64 instruction)
{
    UINT64 const imm20b = GetBits(instruction, 13, 20);
    return imm20b;
}

UINT64 DETOUR_IA64_BUNDLE::SetImm20b(UINT64 instruction, UINT64 imm20b)
{
    UINT64 const new_instruction = SetBits(instruction, 13, 20, imm20b);
    return new_instruction;
}

bool DETOUR_IA64_BUNDLE::RelocateInstruction(_Inout_ DETOUR_IA64_BUNDLE* pDst,
                                             _In_ BYTE slot,
                                             _Inout_opt_ DETOUR_IA64_BUNDLE* pBundleExtra) const
/*
    If pBundleExtra is provided and instruction is IP-relative,
    this function relocates instruction to target pBundleExtra,
    pBundleExtra is set to brl the original target, and return true.

    [Not used] If pBundleExtra is not provided and instruction is IP-relative, return true.

    Else return false.

    The following IP-relative forms are recognized:
        br and br.call
        chk.s.m integer and float
        chk.a.nc integer and float
        chk.a.clr integer and float
        chk.s.i
        fchkf

    Brl is handled elsewhere, because the code was previously written.

    Branch prediction hints are not relocated.
*/
{
    UINT64 const instruction = GetInstruction(slot);
    UINT64 const opcode = GetOpcode(instruction);
    size_t const dest = (size_t)pDst;
    size_t const extra = (size_t)pBundleExtra;

    switch (GetUnit(slot)) {
    case F_UNIT:
        // F14 fchkf
        if (opcode == 0 && GetX(instruction) == 0 && GetX6(instruction) == 8) {
            goto imm20a;
        }
        return false;

    case M_UNIT:
        // M20 x3 == 1 integer chk.s.m
        // M21 x3 == 3 floating point chk.s
        if (opcode == 1) {
            UINT64 const x3 = GetX3(instruction);
            if (x3 == 1 || x3 == 3) {
                goto imm13_7;
            }
        }

        // M22 x3 == 4 integer chk.a.nc
        // M22 x3 == 5 integer chk.a.clr
        // M23 x3 == 6 floating point chk.a.nc
        // M23 x3 == 7 floating point chk.a.clr
        if (opcode == 0) {
            UINT64 const x3 = GetX3(instruction);
            if (x3 == 4 || x3 == 5 || x3 == 6 || x3 == 7) {
                goto imm20b;
            }
        }
        return false;
    case I_UNIT:
        // I20
        if (opcode == 0 && GetX3(instruction) == 1) { // chk.s.i
            goto imm13_7;
        }
        return false;
    case B_UNIT:
        // B1 B2 B3
        // 4 br
        // 5 br.call
        if (opcode == 4 || opcode == 5) {
            goto imm20b;
        }
        return false;
    }
    return false;

    UINT64 imm;
    UINT64 new_instruction;

imm13_7:
    imm = SignExtend((GetSignBit(instruction) << 20) | (GetImm13c(instruction) << 7) | GetImm7a(instruction), 21) << 4;
    new_instruction = SetSignBit(SetImm13c(SetImm7a(instruction, (extra - dest) >> 4), (extra - dest) >> 11), extra < dest);
    goto set_brl;

imm20a:
    imm = SignExtend((GetSignBit(instruction) << 20) | GetImm20a(instruction), 21) << 4;
    new_instruction = SetSignBit(SetImm20a(instruction, (extra - dest) >> 4), extra < dest);
    goto set_brl;

imm20b:
    imm = SignExtend((GetSignBit(instruction) << 20) | GetImm20b(instruction), 21) << 4;
    new_instruction = SetSignBit(SetImm20b(instruction, (extra - dest) >> 4), extra < dest);
    goto set_brl;

set_brl:
    if (pBundleExtra != NULL) {
        pDst->SetInstruction(slot, new_instruction);
        pBundleExtra->SetBrl((size_t)this + imm);
    }
    return true;
}

UINT DETOUR_IA64_BUNDLE::RelocateBundle(_Inout_ DETOUR_IA64_BUNDLE* pDst,
                                        _Inout_opt_ DETOUR_IA64_BUNDLE* pBundleExtra) const
/*
    Having already copied the bundle unchanged, then relocate its instructions one at a time.
    Return how many extra bytes are required to relocate the bundle.
*/
{
    UINT nExtraBytes = 0;
    for (BYTE slot = 0; slot < DETOUR_IA64_INSTRUCTIONS_PER_BUNDLE; ++slot) {
        if (!RelocateInstruction(pDst, slot, pBundleExtra)) {
            continue;
        }
        pBundleExtra -= !!pBundleExtra;
        nExtraBytes += sizeof(DETOUR_IA64_BUNDLE);
    }
    return nExtraBytes;
}

BOOL DETOUR_IA64_BUNDLE::IsBrl() const
{
    // f.e. d.c. b.a. 9.8. 7.6. 5. 4. 3. 2. 1. 0.
    // c000 0070 0000 0000 0000 00 01 00 00 00 05 : brl.sptk.few
    // c8ff fff0 007f fff0 ffff 00 01 00 00 00 05 : brl.sptk.few
    // c000 0048 0000 0000 0001 00 00 00 00 00 05 : brl.sptk.many
    return ((wide[0] & 0x000000000000001e) == 0x0000000000000004 && // 4 or 5.
            (wide[1] & 0xe000000000000000) == 0xc000000000000000);  // c or d.
}

VOID DETOUR_IA64_BUNDLE::SetBrl()
{
    wide[0] = 0x0000000100000005;   // few
    //wide[0] = 0x0000000180000005; // many
    wide[1] = 0xc000000800000000;
}

UINT64 DETOUR_IA64_BUNDLE::GetBrlImm() const
{
    return (
            //          0x0000000000fffff0
            ((wide[1] & 0x00fffff000000000) >> 32) |    // all 20 bits of imm20b.
            //          0x000000ffff000000
            ((wide[0] & 0xffff000000000000) >> 24) |    // bottom 16 bits of imm39.
            //          0x7fffff0000000000
            ((wide[1] & 0x00000000007fffff) << 40) |    // top 23 bits of imm39.
            //          0x8000000000000000
            ((wide[1] & 0x0800000000000000) <<  4)      // single bit of i.
           );
}

VOID DETOUR_IA64_BUNDLE::SetBrlImm(UINT64 imm)
{
    wide[0] = ((wide[0] & ~0xffff000000000000) |
               //      0xffff000000000000
               ((imm & 0x000000ffff000000) << 24)       // bottom 16 bits of imm39.
              );
    wide[1] = ((wide[1] & ~0x08fffff0007fffff) |
               //      0x00fffff000000000
               ((imm & 0x0000000000fffff0) << 32) |     // all 20 bits of imm20b.
               //      0x00000000007fffff
               ((imm & 0x7fffff0000000000) >> 40) |     // top 23 bits of imm39.
               //      0x0800000000000000
               ((imm & 0x8000000000000000) >>  4)       // single bit of i.
              );
}

UINT64 DETOUR_IA64_BUNDLE::GetBrlTarget() const
{
    return (UINT64)this + GetBrlImm();
}

VOID DETOUR_IA64_BUNDLE::SetBrl(UINT64 target)
{
    UINT64 imm = target - (UINT64)this;
    SetBrl();
    SetBrlImm(imm);
}

VOID DETOUR_IA64_BUNDLE::SetBrlTarget(UINT64 target)
{
    UINT64 imm = target - (UINT64)this;
    SetBrlImm(imm);
}

BOOL DETOUR_IA64_BUNDLE::IsMovlGp() const
{
    // f.e. d.c. b.a. 9.8. 7.6. 5.4. 3.2. 1.0.
    // 6fff f7f0 207f ffff ffff c001 0000 0004
    // 6000 0000 2000 0000 0000 0001 0000 0004
    return ((wide[0] & 0x00003ffffffffffe) == 0x0000000100000004 &&
            (wide[1] & 0xf000080fff800000) == 0x6000000020000000);
}

UINT64 DETOUR_IA64_BUNDLE::GetMovlGp() const
{
    UINT64 raw = (
                  //          0x0000000000000070
                  ((wide[1] & 0x000007f000000000) >> 36) |
                  //          0x000000000000ff80
                  ((wide[1] & 0x07fc000000000000) >> 43) |
                  //          0x00000000001f0000
                  ((wide[1] & 0x0003e00000000000) >> 29) |
                  //          0x0000000000200000
                  ((wide[1] & 0x0000100000000000) >> 23) |
                  //          0x000000ffffc00000
                  ((wide[0] & 0xffffc00000000000) >> 24) |
                  //          0x7fffff0000000000
                  ((wide[1] & 0x00000000007fffff) << 40) |
                  //          0x8000000000000000
                  ((wide[1] & 0x0800000000000000) <<  4)
                 );

    return (INT64)raw;
}

VOID DETOUR_IA64_BUNDLE::SetMovlGp(UINT64 gp)
{
    UINT64 raw = (UINT64)gp;

    wide[0] = (0x0000000100000005 |
               //      0xffffc00000000000
               ((raw & 0x000000ffffc00000) << 24)
              );
    wide[1] = (
               0x6000000020000000 |
               //      0x0000070000000000
               ((raw & 0x0000000000000070) << 36) |
               //      0x07fc000000000000
               ((raw & 0x000000000000ff80) << 43) |
               //      0x0003e00000000000
               ((raw & 0x00000000001f0000) << 29) |
               //      0x0000100000000000
               ((raw & 0x0000000000200000) << 23) |
               //      0x00000000007fffff
               ((raw & 0x7fffff0000000000) >> 40) |
               //      0x0800000000000000
               ((raw & 0x8000000000000000) >>  4)
              );
}

UINT DETOUR_IA64_BUNDLE::Copy(_Out_ DETOUR_IA64_BUNDLE *pDst,
                              _Inout_opt_ DETOUR_IA64_BUNDLE* pBundleExtra) const
{
    // Copy the bytes unchanged.

#pragma warning(suppress:6001) // using uninitialized *pDst
    pDst->wide[0] = wide[0];
    pDst->wide[1] = wide[1];

    // Relocate if necessary.

    UINT nExtraBytes = RelocateBundle(pDst, pBundleExtra);

    if (GetUnit1() == L_UNIT && IsBrl()) {
        pDst->SetBrlTarget(GetBrlTarget());
    }

    return nExtraBytes;
}

BOOL DETOUR_IA64_BUNDLE::SetNop(BYTE slot)
{
    switch (GetUnit(slot)) {
      case I_UNIT:
      case M_UNIT:
      case F_UNIT:
        SetInst(slot, 0);
        SetData(slot, 0x8000000);
        return true;
      case B_UNIT:
        SetInst(slot, 2);
        SetData(slot, 0);
        return true;
    }
    DebugBreak();
    return false;
}

BOOL DETOUR_IA64_BUNDLE::SetNop0()
{
    return SetNop(0);
}

BOOL DETOUR_IA64_BUNDLE::SetNop1()
{
    return SetNop(1);
}

BOOL DETOUR_IA64_BUNDLE::SetNop2()
{
    return SetNop(2);
}

VOID DETOUR_IA64_BUNDLE::SetStop()
{
    data[0] |= 0x01;
}

#endif // DETOURS_IA64

PVOID WINAPI DetourCopyInstruction(_In_opt_ PVOID pDst,
                                   _Inout_opt_ PVOID *ppDstPool,
                                   _In_ PVOID pSrc,
                                   _Out_opt_ PVOID *ppTarget,
                                   _Out_opt_ LONG *plExtra)
{
    LONG nExtra;
    DETOUR_IA64_BUNDLE bExtra;
    DETOUR_IA64_BUNDLE *pbSrc = (DETOUR_IA64_BUNDLE *)pSrc;
    DETOUR_IA64_BUNDLE *pbDst = pDst ? (DETOUR_IA64_BUNDLE *)pDst : &bExtra;

    plExtra = plExtra ? plExtra : &nExtra;
    *plExtra = 0;

    if (ppTarget != NULL) {
        if (pbSrc->IsBrl()) {
            *ppTarget = (PVOID)pbSrc->GetBrlTarget();
        }
        else {
            *ppTarget = DETOUR_INSTRUCTION_TARGET_NONE;
        }
    }
    *plExtra = (LONG)pbSrc->Copy(pbDst, ppDstPool ? ((DETOUR_IA64_BUNDLE*)*ppDstPool) - 1 : (DETOUR_IA64_BUNDLE*)NULL);
    return pbSrc + 1;
}

#endif // DETOURS_IA64

#ifdef DETOURS_ARM

#define DETOURS_PFUNC_TO_PBYTE(p)  ((PBYTE)(((ULONG_PTR)(p)) & ~(ULONG_PTR)1))
#define DETOURS_PBYTE_TO_PFUNC(p)  ((PBYTE)(((ULONG_PTR)(p)) | (ULONG_PTR)1))

#define c_PCAdjust  4       // The PC value of an instruction is the PC address plus 4.
#define c_PC        15      // The register number for the Program Counter
#define c_LR        14      // The register number for the Link Register
#define c_SP        13      // The register number for the Stack Pointer
#define c_NOP       0xbf00  // A nop instruction
#define c_BREAK     0xdefe  // A nop instruction

class CDetourDis
{
  public:
    CDetourDis();

    PBYTE   CopyInstruction(PBYTE pDst,
                            PBYTE *ppDstPool,
                            PBYTE pSrc,
                            PBYTE *ppTarget,
                            LONG *plExtra);

  public:
    typedef BYTE (CDetourDis::* COPYFUNC)(PBYTE pbDst, PBYTE pbSrc);

    struct COPYENTRY {
        USHORT      nOpcode;
        COPYFUNC    pfCopy;
    };

    typedef const COPYENTRY * REFCOPYENTRY;

    struct Branch5
    {
        DWORD Register : 3;
        DWORD Imm5 : 5;
        DWORD Padding : 1;
        DWORD I : 1;
        DWORD OpCode : 6;
    };

    struct Branch5Target
    {
        DWORD Padding : 1;
        DWORD Imm5 : 5;
        DWORD I : 1;
        DWORD Padding2 : 25;
    };

    struct Branch8
    {
        DWORD Imm8 : 8;
        DWORD Condition : 4;
        DWORD OpCode : 4;
    };

    struct Branch8Target
    {
        DWORD Padding : 1;
        DWORD Imm8 : 8;
        DWORD Padding2 : 23;
    };

    struct Branch11
    {
        DWORD Imm11 : 11;
        DWORD OpCode : 5;
    };

    struct Branch11Target
    {
        DWORD Padding : 1;
        DWORD Imm11 : 11;
        DWORD Padding2 : 20;
    };

    struct Branch20
    {
        DWORD Imm11 : 11;
        DWORD J2 : 1;
        DWORD IT : 1;
        DWORD J1 : 1;
        DWORD Other : 2;
        DWORD Imm6 : 6;
        DWORD Condition : 4;
        DWORD Sign : 1;
        DWORD OpCode : 5;
    };

    struct Branch20Target
    {
        DWORD Padding : 1;
        DWORD Imm11 : 11;
        DWORD Imm6 : 6;
        DWORD J1 : 1;
        DWORD J2 : 1;
        DWORD Sign : 1;
        INT32 Padding2 : 11;
    };

    struct Branch24
    {
        DWORD Imm11             : 11;
        DWORD J2                : 1;
        DWORD InstructionSet    : 1;
        DWORD J1                : 1;
        DWORD Link              : 1;
        DWORD Branch            : 1;
        DWORD Imm10             : 10;
        DWORD Sign              : 1;
        DWORD OpCode            : 5;
    };

    struct Branch24Target
    {
        DWORD Padding : 1;
        DWORD Imm11 : 11;
        DWORD Imm10 : 10;
        DWORD I2 : 1;
        DWORD I1 : 1;
        DWORD Sign : 1;
        INT32 Padding2 : 7;
    };

    struct LiteralLoad8
    {
        DWORD Imm8 : 8;
        DWORD Register : 3;
        DWORD OpCode : 5;
    };

    struct LiteralLoad8Target
    {
        DWORD Padding : 2;
        DWORD Imm8 : 8;
        DWORD Padding2 : 22;
    };

    struct LiteralLoad12
    {
        DWORD Imm12 : 12;
        DWORD Register : 4;
        DWORD OpCodeSuffix : 7;
        DWORD Add : 1;
        DWORD OpCodePrefix : 8;
    };

    struct LiteralLoad12Target
    {
        DWORD Imm12 : 12;
        DWORD Padding : 20;
    };

    struct ImmediateRegisterLoad32
    {
        DWORD Imm12 : 12;
        DWORD DestinationRegister : 4;
        DWORD SourceRegister: 4;
        DWORD OpCode : 12;
    };

    struct ImmediateRegisterLoad16
    {
        DWORD DestinationRegister : 3;
        DWORD SourceRegister: 3;
        DWORD OpCode : 10;
    };

    struct TableBranch
    {
        DWORD IndexRegister : 4;
        DWORD HalfWord : 1;
        DWORD OpCodeSuffix : 11;
        DWORD BaseRegister : 4;
        DWORD OpCodePrefix : 12;
    };

    struct Shift
    {
        DWORD Imm2 : 2;
        DWORD Imm3 : 3;
    };

    struct Add32
    {
        DWORD SecondOperandRegister : 4;
        DWORD Type : 2;
        DWORD Imm2 : 2;
        DWORD DestinationRegister : 4;
        DWORD Imm3 : 3;
        DWORD Padding : 1;
        DWORD FirstOperandRegister : 4;
        DWORD SetFlags : 1;
        DWORD OpCode : 11;
    };

    struct LogicalShiftLeft32
    {
        DWORD SourceRegister : 4;
        DWORD Padding : 2;
        DWORD Imm2 : 2;
        DWORD DestinationRegister : 4;
        DWORD Imm3 : 3;
        DWORD Padding2 : 5;
        DWORD SetFlags : 1;
        DWORD OpCode : 11;
    };

    struct StoreImmediate12
    {
        DWORD Imm12 : 12;
        DWORD SourceRegister : 4;
        DWORD BaseRegister : 4;
        DWORD OpCode : 12;
    };

  protected:
    BYTE    PureCopy16(BYTE* pSource, BYTE* pDest);
    BYTE    PureCopy32(BYTE* pSource, BYTE* pDest);
    BYTE    CopyMiscellaneous16(BYTE* pSource, BYTE* pDest);
    BYTE    CopyConditionalBranchOrOther16(BYTE* pSource, BYTE* pDest);
    BYTE    CopyUnConditionalBranch16(BYTE* pSource, BYTE* pDest);
    BYTE    CopyLiteralLoad16(BYTE* pSource, BYTE* pDest);
    BYTE    CopyBranchExchangeOrDataProcessing16(BYTE* pSource, BYTE* pDest);
    BYTE    CopyBranch24(BYTE* pSource, BYTE* pDest);
    BYTE    CopyBranchOrMiscellaneous32(BYTE* pSource, BYTE* pDest);
    BYTE    CopyLiteralLoad32(BYTE* pSource, BYTE* pDest);
    BYTE    CopyLoadAndStoreSingle(BYTE* pSource, BYTE* pDest);
    BYTE    CopyLoadAndStoreMultipleAndSRS(BYTE* pSource, BYTE* pDest);
    BYTE    CopyTableBranch(BYTE* pSource, BYTE* pDest);
    BYTE    BeginCopy32(BYTE* pSource, BYTE* pDest);

    LONG    DecodeBranch5(ULONG opcode);
    USHORT  EncodeBranch5(ULONG originalOpCode, LONG delta);
    LONG    DecodeBranch8(ULONG opcode);
    USHORT  EncodeBranch8(ULONG originalOpCode, LONG delta);
    LONG    DecodeBranch11(ULONG opcode);
    USHORT  EncodeBranch11(ULONG originalOpCode, LONG delta);
    BYTE    EmitBranch11(PUSHORT& pDest, LONG relativeAddress);
    LONG    DecodeBranch20(ULONG opcode);
    ULONG   EncodeBranch20(ULONG originalOpCode, LONG delta);
    LONG    DecodeBranch24(ULONG opcode, BOOL& fLink);
    ULONG   EncodeBranch24(ULONG originalOpCode, LONG delta, BOOL fLink);
    LONG    DecodeLiteralLoad8(ULONG instruction);
    LONG    DecodeLiteralLoad12(ULONG instruction);
    BYTE    EmitLiteralLoad8(PUSHORT& pDest, BYTE targetRegister, PBYTE pLiteral);
    BYTE    EmitLiteralLoad12(PUSHORT& pDest, BYTE targetRegister, PBYTE pLiteral);
    BYTE    EmitImmediateRegisterLoad32(PUSHORT& pDest, BYTE reg);
    BYTE    EmitImmediateRegisterLoad16(PUSHORT& pDest, BYTE reg);
    BYTE    EmitLongLiteralLoad(PUSHORT& pDest, BYTE reg, PVOID pTarget);
    BYTE    EmitLongBranch(PUSHORT& pDest, PVOID pTarget);
    USHORT  CalculateExtra(BYTE sourceLength, BYTE* pDestStart, BYTE* pDestEnd);

  protected:
    ULONG GetLongInstruction(BYTE* pSource)
    {
        return (((PUSHORT)pSource)[0] << 16) | (((PUSHORT)pSource)[1]);
    }

    BYTE EmitLongInstruction(PUSHORT& pDstInst, ULONG instruction)
    {
        *pDstInst++ = (USHORT)(instruction >> 16);
        *pDstInst++ = (USHORT)instruction;
        return sizeof(ULONG);
    }

    BYTE EmitShortInstruction(PUSHORT& pDstInst, USHORT instruction)
    {
        *pDstInst++ = instruction;
        return sizeof(USHORT);
    }

    PBYTE Align4(PBYTE pValue)
    {
        return (PBYTE)(((size_t)pValue) & ~(ULONG)3u);
    }

    PBYTE CalculateTarget(PBYTE pSource, LONG delta)
    {
        return (pSource + delta + c_PCAdjust);
    }

    LONG CalculateNewDelta(PBYTE pTarget, BYTE* pDest)
    {
        return (LONG)(pTarget - (pDest + c_PCAdjust));
    }

    BYTE    EmitAdd32(PUSHORT& pDstInst, BYTE op1Reg, BYTE op2Reg, BYTE dstReg, BYTE shiftAmount)
    {
        Shift& shift = (Shift&)(shiftAmount);
        const BYTE shiftType = 0x00; // LSL
        Add32 add = { op2Reg, shiftType, shift.Imm2, dstReg, shift.Imm3,
                      0x0, op1Reg, 0x0, 0x758 };
        return EmitLongInstruction(pDstInst, (ULONG&)add);
    }

    BYTE    EmitLogicalShiftLeft32(PUSHORT& pDstInst, BYTE srcReg, BYTE dstReg, BYTE shiftAmount)
    {
        Shift& shift = (Shift&)(shiftAmount);
        LogicalShiftLeft32 shiftLeft = { srcReg, 0x00, shift.Imm2, dstReg, shift.Imm3, 0x1E,
                                         0x00, 0x752 };
        return EmitLongInstruction(pDstInst, (ULONG&)shiftLeft);
    }

    BYTE    EmitStoreImmediate12(PUSHORT& pDstInst, BYTE srcReg, BYTE baseReg, USHORT offset)
    {
        StoreImmediate12 store = { offset, srcReg, baseReg, 0xF8C };
        return EmitLongInstruction(pDstInst, (ULONG&)store);
    }

  protected:
    PBYTE   m_pbTarget;
    PBYTE   m_pbPool;
    LONG    m_lExtra;

    BYTE    m_rbScratchDst[64]; // matches or exceeds rbCode

    static const COPYENTRY s_rceCopyTable[33];
};

LONG CDetourDis::DecodeBranch5(ULONG opcode)
{
    Branch5& branch = (Branch5&)(opcode);

    Branch5Target target;
    ZeroMemory(&target, sizeof(target));
    target.Imm5 = branch.Imm5;
    target.I = branch.I;

    // Return zero-extended value
    return (LONG&)target;
}

USHORT CDetourDis::EncodeBranch5(ULONG originalOpCode, LONG delta)
{
    // Too large for a 5 bit branch (5 bit branches can be up to 7 bits due to I and the trailing 0)
    if (delta < 0 || delta > 0x7F) {
        return 0;
    }

    Branch5& branch = (Branch5&)(originalOpCode);
    Branch5Target& target = (Branch5Target&)(delta);

    branch.Imm5 = target.Imm5;
    branch.I = target.I;

    return (USHORT&)branch;
}

LONG CDetourDis::DecodeBranch8(ULONG opcode)
{
    Branch8& branch = (Branch8&)(opcode);

    Branch8Target target;
    ZeroMemory(&target, sizeof(target));
    target.Imm8 = branch.Imm8;

    // Return sign extended value
    return (((LONG&)target) << 23) >> 23;
}

USHORT CDetourDis::EncodeBranch8(ULONG originalOpCode, LONG delta)
{
    // Too large for 8 bit branch (8 bit branches can be up to 9 bits due to the trailing 0)
    if (delta < (-(int)0x100) || delta > 0xFF) {
        return 0;
    }

    Branch8& branch = (Branch8&)(originalOpCode);
    Branch8Target& target = (Branch8Target&)(delta);

    branch.Imm8 = target.Imm8;

    return (USHORT&)branch;
}

LONG CDetourDis::DecodeBranch11(ULONG opcode)
{
    Branch11& branch = (Branch11&)(opcode);

    Branch11Target target;
    ZeroMemory(&target, sizeof(target));
    target.Imm11 = branch.Imm11;

    // Return sign extended value
    return (((LONG&)target) << 20) >> 20;
}

USHORT CDetourDis::EncodeBranch11(ULONG originalOpCode, LONG delta)
{
    // Too large for an 11 bit branch (11 bit branches can be up to 12 bits due to the trailing 0)
    if (delta < (-(int)0x800) || delta > 0x7FF) {
        return 0;
    }

    Branch11& branch = (Branch11&)(originalOpCode);
    Branch11Target& target = (Branch11Target&)(delta);

    branch.Imm11 = target.Imm11;

    return (USHORT&)branch;
}

BYTE CDetourDis::EmitBranch11(PUSHORT& pDest, LONG relativeAddress)
{
    Branch11Target& target = (Branch11Target&)(relativeAddress);
    Branch11 branch11 = { target.Imm11, 0x1C };

    *pDest++ = (USHORT&)branch11;
    return sizeof(USHORT);
}

LONG CDetourDis::DecodeBranch20(ULONG opcode)
{
    Branch20& branch = (Branch20&)(opcode);

    Branch20Target target;
    ZeroMemory(&target, sizeof(target));
    target.Imm11 = branch.Imm11;
    target.Imm6 = branch.Imm6;
    target.Sign = branch.Sign;
    target.J1 = branch.J1;
    target.J2 = branch.J2;

    // Sign extend
    if (target.Sign) {
        target.Padding2 = -1;
    }

    return (LONG&)target;
}

ULONG CDetourDis::EncodeBranch20(ULONG originalOpCode, LONG delta)
{
    // Too large for 20 bit branch (20 bit branches can be up to 21 bits due to the trailing 0)
    if (delta < (-(int)0x100000) || delta > 0xFFFFF) {
        return 0;
    }

    Branch20& branch = (Branch20&)(originalOpCode);
    Branch20Target& target = (Branch20Target&)(delta);

    branch.Imm11 = target.Imm11;
    branch.Imm6 = target.Imm6;
    branch.Sign = target.Sign;
    branch.J1 = target.J1;
    branch.J2 = target.J2;

    return (ULONG&)branch;
}

LONG CDetourDis::DecodeBranch24(ULONG opcode, BOOL& fLink)
{
    Branch24& branch = (Branch24&)(opcode);

    Branch24Target target;
    ZeroMemory(&target, sizeof(target));
    target.Imm11 = branch.Imm11;
    target.Imm10 = branch.Imm10;
    target.Sign = branch.Sign;
    target.I1 = ~(branch.J1 ^ target.Sign);
    target.I2 = ~(branch.J2 ^ target.Sign);
    fLink = branch.Link;

    // Sign extend
    if (target.Sign) {
        target.Padding2 = -1;
    }

    return (LONG&)target;
}

ULONG CDetourDis::EncodeBranch24(ULONG originalOpCode, LONG delta, BOOL fLink)
{
    // Too large for 24 bit branch (24 bit branches can be up to 25 bits due to the trailing 0)
    if (delta < static_cast<int>(0xFF000000) || delta > static_cast<int>(0xFFFFFF)) {
        return 0;
    }

    Branch24& branch = (Branch24&)(originalOpCode);
    Branch24Target& target = (Branch24Target&)(delta);

    branch.Imm11 = target.Imm11;
    branch.Imm10 = target.Imm10;
    branch.Link = fLink;
    branch.Sign = target.Sign;
    branch.J1 = ~(target.I1 ^ branch.Sign);
    branch.J2 = ~(target.I2 ^ branch.Sign);

    return (ULONG&)branch;
}

LONG CDetourDis::DecodeLiteralLoad8(ULONG instruction)
{
    LiteralLoad8& load = (LiteralLoad8&)(instruction);

    LiteralLoad8Target target;
    ZeroMemory(&target, sizeof(target));
    target.Imm8 = load.Imm8;

    return (LONG&)target;
}

BYTE CDetourDis::EmitLiteralLoad8(PUSHORT& pDest, BYTE targetRegister, PBYTE pLiteral)
{
    // Note: We add 2 (which gets rounded down) because literals must be 32-bit
    //       aligned, but the ldr can be 16-bit aligned.
    LONG newDelta = CalculateNewDelta((PBYTE)pLiteral + 2, (PBYTE)pDest);
    LONG relative = ((newDelta > 0 ? newDelta : -newDelta) & 0x3FF);

    LiteralLoad8Target& target = (LiteralLoad8Target&)(relative);
    LiteralLoad8 load = { target.Imm8, targetRegister, 0x9 };

    return EmitShortInstruction(pDest, (USHORT&)load);
}

LONG CDetourDis::DecodeLiteralLoad12(ULONG instruction)
{
    LiteralLoad12& load = (LiteralLoad12&)(instruction);

    LiteralLoad12Target target;
    ZeroMemory(&target, sizeof(target));
    target.Imm12 = load.Imm12;

    return (LONG&)target;
}

BYTE CDetourDis::EmitLiteralLoad12(PUSHORT& pDest, BYTE targetRegister, PBYTE pLiteral)
{
    // Note: We add 2 (which gets rounded down) because literals must be 32-bit
    //       aligned, but the ldr can be 16-bit aligned.
    LONG newDelta = CalculateNewDelta((PBYTE)pLiteral + 2, (PBYTE)pDest);
    LONG relative = ((newDelta > 0 ? newDelta : -newDelta) & 0xFFF);

    LiteralLoad12Target& target = (LiteralLoad12Target&)(relative);
    target.Imm12 -= target.Imm12 & 3;
    LiteralLoad12 load = { target.Imm12, targetRegister, 0x5F, (DWORD)(newDelta > 0),  0xF8 };

    return EmitLongInstruction(pDest, (ULONG&)load);
}

BYTE CDetourDis::EmitImmediateRegisterLoad32(PUSHORT& pDest, BYTE reg)
{
    ImmediateRegisterLoad32 load = { 0, reg, reg, 0xF8D };
    return EmitLongInstruction(pDest, (ULONG&)load);
}

BYTE CDetourDis::EmitImmediateRegisterLoad16(PUSHORT& pDest, BYTE reg)
{
    ImmediateRegisterLoad16 load = { reg, reg, 0x680 >> 2 };
    return EmitShortInstruction(pDest, (USHORT&)load);
}

BYTE CDetourDis::EmitLongLiteralLoad(PUSHORT& pDest, BYTE targetRegister, PVOID pTarget)
{
    *--((PULONG&)m_pbPool) = (ULONG)(size_t)pTarget;

    // ldr rn, target.
    BYTE size = EmitLiteralLoad12(pDest, targetRegister, m_pbPool);

    // This only makes sense if targetRegister != PC;
    // otherwise, we would have branched with the previous instruction anyway
    if (targetRegister != c_PC) {
        // ldr rn, [rn]
        if (targetRegister <= 7) {
            size = (BYTE)(size + EmitImmediateRegisterLoad16(pDest, targetRegister));
        }
        else {
            size = (BYTE)(size + EmitImmediateRegisterLoad32(pDest, targetRegister));
        }
    }

    return size;
}

BYTE CDetourDis::EmitLongBranch(PUSHORT& pDest, PVOID pTarget)
{
    // Emit a long literal load into PC
    BYTE size = EmitLongLiteralLoad(pDest, c_PC, DETOURS_PBYTE_TO_PFUNC(pTarget));
    return size;
}

BYTE CDetourDis::PureCopy16(BYTE* pSource, BYTE* pDest)
{
    *(USHORT *)pDest = *(USHORT *)pSource;
    return sizeof(USHORT);
}

BYTE CDetourDis::PureCopy32(BYTE* pSource, BYTE* pDest)
{
    *(UNALIGNED ULONG *)pDest = *(UNALIGNED ULONG*)pSource;
    return sizeof(DWORD);
}

USHORT CDetourDis::CalculateExtra(BYTE sourceLength, BYTE* pDestStart, BYTE* pDestEnd)
{
    ULONG destinationLength = (ULONG)(pDestEnd - pDestStart);
    return static_cast<USHORT>((destinationLength > sourceLength) ? (destinationLength - sourceLength) : 0);
}

BYTE CDetourDis::CopyMiscellaneous16(BYTE* pSource, BYTE* pDest)
{
    USHORT instruction = *(PUSHORT)(pSource);

    // Compare and branch imm5 (CBZ, CBNZ)
    if ((instruction & 0x100) && !(instruction & 0x400)) { // (1011x0x1xxxxxxxx)
        LONG oldDelta = DecodeBranch5(instruction);
        PBYTE pTarget = CalculateTarget(pSource, oldDelta);
        m_pbTarget = pTarget;

        LONG newDelta = CalculateNewDelta(pTarget, pDest);
        instruction = EncodeBranch5(instruction, newDelta);

        if (instruction) {
            // Copy the 16 bit instruction over
            *(PUSHORT)(pDest) = instruction;
            return sizeof(USHORT); // The source instruction was 16 bits
        }

        // If that fails, re-encode with 'conditional branch' logic, without using the condition flags
        // For example, cbz r2,+0x56 (0x90432) becomes:
        //
        //  001df73a b92a     cbnz        r2,001df748
        //  001df73c e002     b           001df744
        //  001df73e bf00     nop
        //  001df740 0432     dc.h        0432
        //  001df742 0009     dc.h        0009
        //  001df744 f85ff008 ldr         pc,=0x90432
        //

        // Store where we will be writing our conditional branch, and move past it so we can emit a long branch
        PUSHORT pDstInst = (PUSHORT)(pDest);
        PUSHORT pConditionalBranchInstruction = pDstInst++;

        // Emit the long branch instruction
        BYTE longBranchSize = EmitLongBranch(pDstInst, pTarget);

        // Invert the CBZ/CBNZ instruction to move past our 'long branch' if the inverse comparison succeeds
        // Write the CBZ/CBNZ instruction *before* the long branch we emitted above
        // This had to be done out of order, since the size of a long branch can vary due to alignment restrictions
        instruction = EncodeBranch5(*(PUSHORT)(pSource), longBranchSize - c_PCAdjust + sizeof(USHORT));
        Branch5& branch = (Branch5&)(instruction);
        branch.OpCode = (branch.OpCode & 0x02) ? 0x2C : 0x2E; // Invert the CBZ/CBNZ comparison
        *pConditionalBranchInstruction = instruction;

        // Compute the extra space needed for the branch sequence
        m_lExtra = CalculateExtra(sizeof(USHORT), pDest, (BYTE*)(pDstInst));
        return sizeof(USHORT); // The source instruction was 16 bits
    }

    // If-Then Instruction (IT)
    if ((instruction >> 8 == 0xBF) && (instruction & 0xF)) { //(10111111xxxx(mask != 0b0000))
        // ToDo: Implement IT handler
        ASSERT(false);
        return sizeof(USHORT);
    }

    // ADD/SUB, SXTH, SXTB, UXTH, UXTB, CBZ, CBNZ, PUSH, POP, REV, REV15, REVSH, NOP, YIELD, WFE, WFI, SEV, etc.
    return PureCopy16(pSource, pDest);
}

BYTE CDetourDis::CopyConditionalBranchOrOther16(BYTE* pSource, BYTE* pDest)
{
    USHORT instruction = *(PUSHORT)(pSource);

    // Could be a conditional branch, an Undefined instruction or a Service System Call
    // Only the former needs special logic
    if ((instruction & 0xE00) != 0xE00) { // 1101(!=111x)xxxxxxxx
        LONG oldDelta = DecodeBranch8(instruction);
        PBYTE pTarget = CalculateTarget(pSource, oldDelta);
        m_pbTarget = pTarget;

        LONG newDelta = CalculateNewDelta(pTarget, pDest);
        instruction = EncodeBranch8(instruction, newDelta);
        if (instruction) {
            // Copy the 16 bit instruction over
            *(PUSHORT)(pDest) = instruction;
            return sizeof(USHORT); // The source instruction was 16 bits
        }

        // If that fails, re-encode as a sequence of branches
        // For example, bne +0x6E (0x90452) becomes:
        //
        // 001df758 d100     bne         001df75c
        // 001df75a e005     b           001df768
        // 001df75c e002     b           001df764
        // 001df75e bf00     nop
        // 001df760 0452     dc.h        0452
        // 001df762 0009     dc.h        0009
        // 001df764 f85ff008 ldr         pc,=0x90452
        //

        // First, reuse the existing conditional branch to, if successful, branch down to a 'long branch' that we will emit below
        USHORT newInstruction = EncodeBranch8(*(PUSHORT)(pSource), 0); // Due to the size of c_PCAdjust a zero-length branch moves 4 bytes forward, past the following unconditional branch
        ASSERT(newInstruction);
        PUSHORT pDstInst = (PUSHORT)(pDest);
        *pDstInst++ = newInstruction;

        // Next, prepare to insert an unconditional branch that will be hit if the condition above is not met.  This branch will branch over the following 'long branch'
        // We can't actually encode this branch yet though, because 'long branches' can vary in size
        PUSHORT pUnconditionalBranchInstruction = pDstInst++;

        // Then, emit a 'long branch' that will be hit if the original condition is met
        BYTE longBranchSize = EmitLongBranch(pDstInst, pTarget);

        // Finally, encode and emit the unconditional branch that will be used to branch past the 'long branch' if the initial condition was not met
        Branch11 branch11 = { 0x00, 0x1C };
        newInstruction = EncodeBranch11(*(DWORD*)(&branch11), longBranchSize - c_PCAdjust + sizeof(USHORT));
        ASSERT(newInstruction);
        *pUnconditionalBranchInstruction = newInstruction;

        // Compute the extra space needed for the branch sequence
        m_lExtra = CalculateExtra(sizeof(USHORT), pDest, (BYTE*)(pDstInst));
        return sizeof(USHORT); // The source instruction was 16 bits
    }

    return PureCopy16(pSource, pDest);
}

BYTE CDetourDis::CopyUnConditionalBranch16(BYTE* pSource, BYTE* pDest)
{
    ULONG instruction = *(PUSHORT)(pSource);

    LONG oldDelta = DecodeBranch11(instruction);
    PBYTE pTarget = CalculateTarget(pSource, oldDelta);
    m_pbTarget = pTarget;

    LONG newDelta = CalculateNewDelta(pTarget, pDest);
    instruction = EncodeBranch11(instruction, newDelta);
    if (instruction) {
        // Copy the 16 bit instruction over
        *(PUSHORT)(pDest) = (USHORT)instruction;
        return sizeof(USHORT); // The source instruction was 16 bits
    }

    // If that fails, re-encode as 32-bit
    PUSHORT pDstInst = (PUSHORT)(pDest);
    instruction = EncodeBranch24(0xf0009000, newDelta, FALSE);
    if (instruction) {
        // Copy both bytes of the instruction
        EmitLongInstruction(pDstInst, instruction);

        m_lExtra = sizeof(DWORD) - sizeof(USHORT); // The destination instruction was 32 bits
        return sizeof(USHORT); // The source instruction was 16 bits
    }

    // If that fails, emit as a 'long branch'
    if (!instruction) {
        // For example, b +0x7FE (00090be6) becomes:
        // 003f6d02 e001     b           003f6d08
        // 003f6d04 0be6     dc.h        0be6
        // 003f6d06 0009     dc.h        0009
        // 003f6d08 f85ff008 ldr         pc,=0x90BE6
        EmitLongBranch(pDstInst, pTarget);

        // Compute the extra space needed for the branch sequence
        m_lExtra = CalculateExtra(sizeof(USHORT), pDest, (BYTE*)(pDstInst));
        return sizeof(USHORT); // The source instruction was 16 bits
    }

    return sizeof(USHORT); // The source instruction was 16 bits
}

BYTE CDetourDis::CopyLiteralLoad16(BYTE* pSource, BYTE* pDest)
{
    PBYTE pStart = pDest;
    USHORT instruction = *(PUSHORT)(pSource);

    LONG oldDelta = DecodeLiteralLoad8(instruction);
    PBYTE pTarget = CalculateTarget(Align4(pSource), oldDelta);

    // Re-encode as a 'long literal load'
    // For example, ldr r0, [PC + 1E0] (0x905B4) becomes:
    //
    // 001df72c f85f0008 ldr         r0,=0x905B4
    // 001df730 f8d00000 ldr.w       r0,[r0]
    LiteralLoad8& load8 = (LiteralLoad8&)(instruction);
    EmitLongLiteralLoad((PUSHORT&)pDest, load8.Register, pTarget);

    m_lExtra = (LONG)(pDest - pStart - sizeof(USHORT));
    return sizeof(USHORT); // The source instruction was 16 bits
}

BYTE CDetourDis::CopyBranchExchangeOrDataProcessing16(BYTE* pSource, BYTE* pDest)
{
    ULONG instruction = *(PUSHORT)(pSource);

    // BX
    if ((instruction & 0xff80) == 0x4700) {
        // The target is stored in a register
        m_pbTarget = (PBYTE)DETOUR_INSTRUCTION_TARGET_DYNAMIC;
    }

    // AND, LSR, TST, ADD, CMP, MOV
    return PureCopy16(pSource, pDest);
}

const CDetourDis::COPYENTRY CDetourDis::s_rceCopyTable[33] =
{
    // Shift by immediate, move register
    // ToDo: Not handling moves from PC
    /* 0b00000 */ { 0x00, &CDetourDis::PureCopy16 },
    /* 0b00001 */ { 0x01, &CDetourDis::PureCopy16 },
    /* 0b00010 */ { 0x02, &CDetourDis::PureCopy16 },

    // Add/subtract register
    // Add/subtract immediate
    /* 0b00011 */ { 0x03, &CDetourDis::PureCopy16},

    // Add/subtract/compare/move immediate
    /* 0b00100 */ { 0x04, &CDetourDis::PureCopy16 },
    /* 0b00101 */ { 0x05, &CDetourDis::PureCopy16 },
    /* 0b00110 */ { 0x06, &CDetourDis::PureCopy16 },
    /* 0b00111 */ { 0x07, &CDetourDis::PureCopy16 },

    // Data-processing register
    // Special data processing
    // Branch/exchange instruction set
    /* 0b01000 */ { 0x08, &CDetourDis::CopyBranchExchangeOrDataProcessing16 },

    // Load from literal pool
    /* 0b01001 */ { 0x09, &CDetourDis::CopyLiteralLoad16 },

    // Load/store register offset
    /* 0b01010 */ { 0x0a, &CDetourDis::PureCopy16 },
    /* 0b01011 */ { 0x0b, &CDetourDis::PureCopy16 },

    //  Load/store word/byte immediate offset.
    /* 0b01100 */ { 0x0c, &CDetourDis::PureCopy16 },
    /* 0b01101 */ { 0x0d, &CDetourDis::PureCopy16 },
    /* 0b01110 */ { 0x0e, &CDetourDis::PureCopy16 },
    /* 0b01111 */ { 0x0f, &CDetourDis::PureCopy16 },

    //  Load/store halfword immediate offset.
    /* 0b10000 */ { 0x10, &CDetourDis::PureCopy16 },
    /* 0b10001 */ { 0x11, &CDetourDis::PureCopy16 },

    // Load from or store to stack
    /* 0b10010 */ { 0x12, &CDetourDis::PureCopy16 },
    /* 0b10011 */ { 0x13, &CDetourDis::PureCopy16 },

    // Add to SP or PC
    /* 0b10100 */ { 0x14, &CDetourDis::PureCopy16 },
    //   ToDo: Is ADR (T1) blitt-able?
    //     It adds a value to PC and stores the result in a register.
    //     Does this count as a 'target' for detours?
    /* 0b10101 */ { 0x15, &CDetourDis::PureCopy16 },

    // Miscellaneous
    /* 0b10110 */ { 0x16, &CDetourDis::CopyMiscellaneous16 },
    /* 0b10111 */ { 0x17, &CDetourDis::CopyMiscellaneous16 },

    // Load/store multiple
    /* 0b11000 */ { 0x18, &CDetourDis::PureCopy16 },
    /* 0b11001 */ { 0x19, &CDetourDis::PureCopy16 },
    //   ToDo: Are we sure these are all safe?
    //     LDMIA, for example, can include an 'embedded' branch.
    //     Does this count as a 'target' for detours?

    // Conditional branch
    /* 0b11010 */ { 0x1a, &CDetourDis::CopyConditionalBranchOrOther16 },

    // Conditional branch
    // Undefined instruction
    // Service (system) call
    /* 0b11011 */ { 0x1b, &CDetourDis::CopyConditionalBranchOrOther16 },

    // Unconditional branch
    /* 0b11100 */ { 0x1c, &CDetourDis::CopyUnConditionalBranch16 },

    // 32-bit instruction
    /* 0b11101 */ { 0x1d, &CDetourDis::BeginCopy32 },
    /* 0b11110 */ { 0x1e, &CDetourDis::BeginCopy32 },
    /* 0b11111 */ { 0x1f, &CDetourDis::BeginCopy32 },
    { 0, NULL }
};

BYTE CDetourDis::CopyBranch24(BYTE* pSource, BYTE* pDest)
{
    ULONG instruction = GetLongInstruction(pSource);
    BOOL fLink;
    LONG oldDelta = DecodeBranch24(instruction, fLink);
    PBYTE pTarget = CalculateTarget(pSource, oldDelta);
    m_pbTarget = pTarget;

    // Re-encode as 32-bit
    PUSHORT pDstInst = (PUSHORT)(pDest);
    LONG newDelta = CalculateNewDelta(pTarget, pDest);
    instruction = EncodeBranch24(instruction, newDelta, fLink);
    if (instruction) {
        // Copy both bytes of the instruction
        EmitLongInstruction(pDstInst, instruction);
        return sizeof(DWORD);
    }

    // If that fails, re-encode as a 'long branch'
    EmitLongBranch(pDstInst, pTarget);

    // Compute the extra space needed for the instruction
    m_lExtra = CalculateExtra(sizeof(DWORD), pDest, (BYTE*)(pDstInst));
    return sizeof(DWORD); // The source instruction was 32 bits
}

BYTE CDetourDis::CopyBranchOrMiscellaneous32(BYTE* pSource, BYTE* pDest)
{
    ULONG instruction = GetLongInstruction(pSource);
    if ((instruction & 0xf800d000) == 0xf0008000) { // B<c>.W <label>
        LONG oldDelta = DecodeBranch20(instruction);
        PBYTE pTarget = CalculateTarget(pSource, oldDelta);
        m_pbTarget = pTarget;

        // Re-encode as 32-bit
        PUSHORT pDstInst = (PUSHORT)(pDest);
        LONG newDelta = CalculateNewDelta(pTarget, pDest);
        instruction = EncodeBranch20(instruction, newDelta);
        if (instruction) {
            // Copy both bytes of the instruction
            EmitLongInstruction(pDstInst, instruction);
            return sizeof(DWORD);
        }

        // If that fails, re-encode as a sequence of branches
        // For example, bls.w +0x86 (00090480)| becomes:
        //
        // 001df788 f2408001 bls.w       001df78e
        // 001df78c e004     b           001df798
        // 001df78e e001     b           001df794
        // 001df790 0480     dc.h        0480
        // 001df792 0009     dc.h        0009
        // 001df794 f85ff008 ldr         pc,=0x90480
        //

        // First, reuse the existing conditional branch to, if successful,
        // branch down to a 'long branch' that we will emit below
        instruction = EncodeBranch20(GetLongInstruction(pSource), 2);
        // Due to the size of c_PCAdjust a two-length branch moves 6 bytes forward,
        // past the following unconditional branch
        ASSERT(instruction);
        EmitLongInstruction(pDstInst, instruction);

        // Next, prepare to insert an unconditional branch that will be hit
        // if the condition above is not met.  This branch will branch over
        // the following 'long branch'
        // We can't actually encode this branch yet though, because
        // 'long branches' can vary in size
        PUSHORT pUnconditionalBranchInstruction = pDstInst++;

        // Then, emit a 'long branch' that will be hit if the original condition is met
        BYTE longBranchSize = EmitLongBranch(pDstInst, pTarget);

        // Finally, encode and emit the unconditional branch that will be used
        // to branch past the 'long branch' if the initial condition was not met
        Branch11 branch11 = { 0x00, 0x1C };
        instruction = EncodeBranch11(*(DWORD*)(&branch11), longBranchSize - c_PCAdjust + sizeof(USHORT));
        ASSERT(instruction);
        *pUnconditionalBranchInstruction = static_cast<USHORT>(instruction);

        // Compute the extra space needed for the instruction
        m_lExtra = CalculateExtra(sizeof(DWORD), pDest, (BYTE*)(pDstInst));
        return sizeof(DWORD); // The source instruction was 32 bits
    }

    if ((instruction & 0xf800d000) == 0xf0009000) { // B.W <label>
        // B <label>  11110xxxxxxxxxxx10xxxxxxxxxxxxxx
        return CopyBranch24(pSource, pDest);
    }

    if ((instruction & 0xf800d000) == 0xf000d000) { // BL.W <label>
        // B <label>  11110xxxxxxxxxxx10xxxxxxxxxxxxxx

        PUSHORT pDstInst = (PUSHORT)(pDest);
        BOOL fLink;
        LONG oldDelta = DecodeBranch24(instruction, fLink);
        PBYTE pTarget = CalculateTarget(pSource, oldDelta);
        m_pbTarget = pTarget;

        *--((PULONG&)m_pbPool) = (ULONG)(size_t)DETOURS_PBYTE_TO_PFUNC(pTarget);

        // ldr lr, target.
        EmitLiteralLoad12(pDstInst, c_LR, m_pbPool);
        // blx lr
        EmitShortInstruction(pDstInst, 0x47f0);

        // Compute the extra space needed for the instruction
        m_lExtra = CalculateExtra(sizeof(DWORD), pDest, (BYTE*)(pDstInst));
        return sizeof(DWORD); // The source instruction was 32 bits
    }

    if ((instruction & 0xFFF0FFFF) == 0xF3C08F00) {
        // BXJ 111100111100xxxx1000111100000000
        // BXJ switches to Jazelle mode, which is not supported
        ASSERT(false);
    }

    if ((instruction & 0xFFFFFF00) == 0xF3DE8F00) {
        // SUBS PC, LR 111100111101111010001111xxxxxxxx
        m_pbTarget = (PBYTE)DETOUR_INSTRUCTION_TARGET_DYNAMIC;
    }

    // Everything else should be blitt-able
    return PureCopy32(pSource, pDest);
}

BYTE CDetourDis::CopyLiteralLoad32(BYTE* pSource, BYTE* pDest)
{
    BYTE* pStart = pDest;
    ULONG instruction = GetLongInstruction(pSource);

    LONG oldDelta = DecodeLiteralLoad12(instruction);
    PBYTE pTarget = CalculateTarget(Align4(pSource), oldDelta);

    LiteralLoad12& load = (LiteralLoad12&)(instruction);

    EmitLongLiteralLoad((PUSHORT&)pDest, load.Register, pTarget);

    m_lExtra = (LONG)(pDest - pStart - sizeof(DWORD));

    return sizeof(DWORD); // The source instruction was 32 bits
}

BYTE CDetourDis::CopyLoadAndStoreSingle(BYTE* pSource, BYTE* pDest)
{
    ULONG instruction = GetLongInstruction(pSource);

    // Note: The following masks only look at the interesting bits
    // (not the opCode prefix, since that check was performed in
    // order to get to this function)
    if (!(instruction & 0x100000)) {
        // 1111 100x xxx0 xxxxxxxxxxxxxxxxxxxx : STR, STRB, STRH, etc.
        return PureCopy32(pSource, pDest);
    }

    if ((instruction & 0xF81F0000) == 0xF81F0000) {
        // 1111100xxxx11111xxxxxxxxxxxxxxxx : PC +/- Imm12
        return CopyLiteralLoad32(pSource, pDest);
    }

    if ((instruction & 0xFE70F000) == 0xF81FF000) {
        // 1111100xx001xxxx1111xxxxxxxxxxxx : PLD, PLI
        // Convert PC-Relative PLD/PLI instructions to noops (1111100Xx00111111111xxxxxxxxxxxx)
        if ((instruction & 0xFE7FF000) == 0xF81FF000) {
            PUSHORT pDstInst = (PUSHORT)(pDest);
            *pDstInst++ = c_NOP;
            *pDstInst++ = c_NOP;
            return sizeof(DWORD);  // The source instruction was 32 bits
        }

        // All other PLD/PLI instructions are blitt-able
        return PureCopy32(pSource, pDest);
    }

    // If the load is writing to PC
    if ((instruction & 0xF950F000) == 0xF850F000) {
        m_pbTarget = (PBYTE)DETOUR_INSTRUCTION_TARGET_DYNAMIC;
    }

    // All other loads LDR (immediate), etc.
    return PureCopy32(pSource, pDest);
}

BYTE CDetourDis::CopyLoadAndStoreMultipleAndSRS(BYTE* pSource, BYTE* pDest)
{
    // Probably all blitt-able, although not positive since some of these can result in a branch (LDMIA, POP, etc.)
    return PureCopy32(pSource, pDest);
}

BYTE CDetourDis::CopyTableBranch(BYTE* pSource, BYTE* pDest)
{
    m_pbTarget = (PBYTE)DETOUR_INSTRUCTION_TARGET_DYNAMIC;
    ULONG instruction = GetLongInstruction(pSource);
    TableBranch& tableBranch = (TableBranch&)(instruction);

    // If the base register is anything other than PC, we can simply copy the instruction
    if (tableBranch.BaseRegister != c_PC) {
        return PureCopy32(pSource, pDest);
    }

    __debugbreak();

    // If the base register is PC, we need to manually perform the table lookup
    // For example, this:
    //
    //        7ef40000 e8dff002 tbb         [pc,r2]
    //
    // becomes this:
    //
    //        7ef40404 b401     push        {r0}            ; pushed as a placeholder for the target address
    //        7ef40406 e92d0005 push.w      {r0,r2}         ; scratch register and another register are pushed; there's a minimum of two registers in the list for push.w
    //        7ef40410 4820     ldr         r0,=0x7EF40004  ; load the table address from the literal pool
    //        7ef40414 eb000042 add         r0,r0,r2,lsl #1 ; add the index value to the address of the table to get the table entry; lsl only used if it's a TBH instruction
    //        7ef40418 f8d00000 ldr.w       r0,[r0]         ; dereference the table entry to get the value of the target
    //        7ef4041c ea4f0040 lsl         r0,r0,#1        ; multiply the offset by 2 (per the spec)
    //        7ef40420 eb00000f add.w       r0,r0,pc        ; Add the offset to pc to get the target address
    //        7ef40424 f8cd000c str.w       r0,[sp,#0xC]    ; store the target address on the stack (into the first push)
    //        7ef40428 e8bd0005 pop.w       {r0,r2}         ; scratch register and another register are popped; there's a minimum of two registers in the list for pop.w
    //        7ef4042c bd00     pop         {pc}            ; pop the address into pc
    //

    // Push r0 to make room for our jump address on the stack
    PUSHORT pDstInst = (PUSHORT)(pDest);
    *pDstInst++ = 0xb401;

    // Locate a scratch register
    BYTE scrReg = 0;
    while (scrReg == tableBranch.IndexRegister) {
        ++scrReg;
    }

    // Push scrReg and tableBranch.IndexRegister (push.w doesn't support pushing just 1 register)
    DWORD pushInstruction = 0xe92d0000;
    pushInstruction |= 1 << scrReg;
    pushInstruction |= 1 << tableBranch.IndexRegister;
    EmitLongInstruction(pDstInst, pushInstruction);

    // Write the target address out to the 'literal pool';
    // when the base register of a TBB/TBH is PC,
    // the branch table immediately follows the instruction
    BYTE* pTarget = CalculateTarget(pSource, 0);
    *--((PUSHORT&)m_pbPool) = (USHORT)((size_t)pTarget & 0xffff);
    *--((PUSHORT&)m_pbPool) = (USHORT)((size_t)pTarget >> 16);

    // Load the literal pool value into our scratch register (this contains the address of the branch table)
    // ldr rn, target
    EmitLiteralLoad8(pDstInst, scrReg, m_pbPool);

    // Add the index offset to the address of the branch table; the result will be the value within the table that contains the branch offset
    // We need to multiply the index by two if we are using halfword indexing
    // Will shift tableBranch.IndexRegister by 1 (multiply by 2) if using a TBH
    EmitAdd32(pDstInst, scrReg, tableBranch.IndexRegister, scrReg, tableBranch.HalfWord);

    // Dereference rn into rn, to load the value within the table
    // ldr rn, [rn]
    if (scrReg < 0x7) {
        EmitImmediateRegisterLoad16(pDstInst, scrReg);
    }
    else {
        EmitImmediateRegisterLoad32(pDstInst, scrReg);
    }

    // Multiply the offset by two to get the true offset value (as per the spec)
    EmitLogicalShiftLeft32(pDstInst, scrReg, scrReg, 1);

    // Add the offset to PC to get the target
    EmitAdd32(pDstInst, scrReg, c_PC, scrReg, 0);

    // Now write the contents of scrReg to the stack, so we can pop it into PC
    // Write the address of the branch table entry to the stack, so we can pop it into PC
    EmitStoreImmediate12(pDstInst, scrReg, c_SP, sizeof(DWORD) * 3);

    // Pop scrReg and tableBranch.IndexRegister (pop.w doesn't support popping just 1 register)
    DWORD popInstruction = 0xe8bd0000;
    popInstruction |= 1 << scrReg;
    popInstruction |= 1 << tableBranch.IndexRegister;
    EmitLongInstruction(pDstInst, popInstruction);

    // Pop PC
    *pDstInst++ = 0xbd00;

    // Compute the extra space needed for the branch sequence
    m_lExtra = CalculateExtra(sizeof(USHORT), pDest, (BYTE*)(pDstInst));
    return sizeof(DWORD);
}

BYTE CDetourDis::BeginCopy32(BYTE* pSource, BYTE* pDest)
{
    ULONG instruction = GetLongInstruction(pSource);

    // Immediate data processing instructions; ADD, SUB, MOV, MOVN, ADR, MOVT, BFC, SSAT16, etc.
    if ((instruction & 0xF8008000) == 0xF0000000) { // 11110xxxxxxxxxxx0xxxxxxxxxxxxxxx
        // Should all be blitt-able
        // ToDo: What about ADR?  Is it safe to do a straight-copy?
        // ToDo: Not handling moves to or from PC
        return PureCopy32(pSource, pDest);
    }

    // Non-Immediate data processing instructions; ADD, EOR, TST, etc.
    if ((instruction & 0xEE000000) == 0xEA000000) { // 111x101xxxxxxxxxxxxxxxxxxxxxxx
        // Should all be blitt-able
        return PureCopy32(pSource, pDest);
    }

    // Load and store single data item, memory hints
    if ((instruction & 0xFE000000) == 0xF8000000) { // 1111100xxxxxxxxxxxxxxxxxxxxxxxxx
        return CopyLoadAndStoreSingle(pSource, pDest);
    }

    // Load and store, double and exclusive, and table branch
    if ((instruction & 0xFE400000) == 0xE8400000) { // 1110100xx1xxxxxxxxxxxxxxxxxxxxxx
        // Load and store double
        if (instruction & 0x1200000) {
            // LDRD, STRD (immediate) : xxxxxxxPxxWxxxxxxxxxxxxxxxxxxxxx where PW != 0b00
            // The source register is PC
            if ((instruction & 0xF0000) == 0xF0000) {
                // ToDo: If the source register is PC, what should we do?
                ASSERT(false);
            }

            // If either target registers are PC
            if (((instruction & 0xF000) == 0xF000) ||
                ((instruction & 0xF00) == 0xF00)) {
                m_pbTarget = (PBYTE)DETOUR_INSTRUCTION_TARGET_DYNAMIC;
            }

            return PureCopy32(pSource, pDest);
        }

        // Load and store exclusive
        if (!(instruction & 0x800000)) { // LDREX, STREX : xxxxxxxx0xxxxxxxxxxxxxxxxxxxxxxx
            if ((instruction & 0xF000) == 0xF000) { // xxxxxxxxxxxx1111xxxxxxxxxxxx
                m_pbTarget = (PBYTE)DETOUR_INSTRUCTION_TARGET_DYNAMIC;
            }
            return PureCopy32(pSource, pDest);
        }

        // Table branch
        if ((instruction & 0x1000F0) == 0x100000 ||  // TBB : xxxxxxxxxxx1xxxxxxxxxxxx0000xxxx
            (instruction & 0x1000F0) == 0x100010) { // TBH : xxxxxxxxxxx1xxxxxxxxxxxx0001xxxx
            return CopyTableBranch(pSource, pDest);
        }

        // Load and store exclusive byte, halfword, doubleword (LDREXB, LDREXH, LDREXD, STREXB, STREXH, STREXD, etc.)
        return PureCopy32(pSource, pDest);
    }

    // Load and store multiple, RFE and SRS
    if ((instruction & 0xFE400000) == 0xE8000000) { // 1110100xx0xxxxxxxxxxxxxxxxxxxxxx
        // Return from exception (RFE)
        if ((instruction & 0xE9900000) == 0xE9900000 || // 1110100110x1xxxxxxxxxxxxxxxxxxxx
            (instruction & 0xE8100000) == 0xE8100000) { // 1110100000x1xxxxxxxxxxxxxxxxxxxx
            return PureCopy32(pSource, pDest);
        }

        return CopyLoadAndStoreMultipleAndSRS(pSource, pDest);
    }

    // Branches, miscellaneous control
    if ((instruction & 0xF8008000) == 0xF0008000) { // 11110xxxxxxxxxxx0xxxxxxxxxxxxxxx
        // Branches, miscellaneous control
        return CopyBranchOrMiscellaneous32(pSource, pDest);
    }

    // Coprocessor instructions
    if ((instruction & 0xEC000000) == 0xEC000000) { // 111x11xxxxxxxxxxxxxxxxxxxxxxxxxx
        return PureCopy32(pSource, pDest);
    }

    // Unhandled instruction; should never make it this far
    ASSERT(false);
    return PureCopy32(pSource, pDest);
}

/////////////////////////////////////////////////////////// Disassembler Code.
//
CDetourDis::CDetourDis() :
    m_pbTarget((PBYTE)DETOUR_INSTRUCTION_TARGET_NONE),
    m_pbPool(NULL),
    m_lExtra(0)
{
}

PBYTE CDetourDis::CopyInstruction(PBYTE pDst,
                                  PBYTE *ppDstPool,
                                  PBYTE pSrc,
                                  PBYTE *ppTarget,
                                  LONG *plExtra)
{
    if (pDst && ppDstPool && ppDstPool != NULL) {
        m_pbPool = (PBYTE)*ppDstPool;
    }
    else {
        pDst = m_rbScratchDst;
        m_pbPool = m_rbScratchDst + sizeof(m_rbScratchDst);
    }
    // Make sure the constant pool is 32-bit aligned.
    m_pbPool -= ((ULONG_PTR)m_pbPool) & 3;

    REFCOPYENTRY pEntry = &s_rceCopyTable[pSrc[1] >> 3];
    ULONG size = (this->*pEntry->pfCopy)(pSrc, pDst);

    pSrc += size;

    // If the target is needed, store our target
    if (ppTarget) {
        *ppTarget = m_pbTarget;
    }
    if (plExtra) {
        *plExtra = m_lExtra;
    }
    if (ppDstPool) {
        *ppDstPool = m_pbPool;
    }

    return pSrc;
}


PVOID WINAPI DetourCopyInstruction(_In_opt_ PVOID pDst,
                                   _Inout_opt_ PVOID *ppDstPool,
                                   _In_ PVOID pSrc,
                                   _Out_opt_ PVOID *ppTarget,
                                   _Out_opt_ LONG *plExtra)
{
    CDetourDis state;
    return (PVOID)state.CopyInstruction((PBYTE)pDst,
                                        (PBYTE*)ppDstPool,
                                        (PBYTE)pSrc,
                                        (PBYTE*)ppTarget,
                                        plExtra);
}

#endif // DETOURS_ARM

#ifdef DETOURS_ARM64

#define c_LR        30          // The register number for the Link Register
#define c_SP        31          // The register number for the Stack Pointer
#define c_NOP       0xd503201f  // A nop instruction
#define c_BREAK     (0xd4200000 | (0xf000 << 5)) // A break instruction

//
// Problematic instructions:
//
// ADR     0ll10000 hhhhhhhh hhhhhhhh hhhddddd  & 0x9f000000 == 0x10000000  (l = low, h = high, d = Rd)
// ADRP    1ll10000 hhhhhhhh hhhhhhhh hhhddddd  & 0x9f000000 == 0x90000000  (l = low, h = high, d = Rd)
//
// B.cond  01010100 iiiiiiii iiiiiiii iii0cccc  & 0xff000010 == 0x54000000  (i = delta = SignExtend(imm19:00, 64), c = cond)
//
// B       000101ii iiiiiiii iiiiiiii iiiiiiii  & 0xfc000000 == 0x14000000  (i = delta = SignExtend(imm26:00, 64))
// BL      100101ii iiiiiiii iiiiiiii iiiiiiii  & 0xfc000000 == 0x94000000  (i = delta = SignExtend(imm26:00, 64))
//
// CBNZ    z0110101 iiiiiiii iiiiiiii iiittttt  & 0x7f000000 == 0x35000000  (z = size, i = delta = SignExtend(imm19:00, 64), t = Rt)
// CBZ     z0110100 iiiiiiii iiiiiiii iiittttt  & 0x7f000000 == 0x34000000  (z = size, i = delta = SignExtend(imm19:00, 64), t = Rt)
//
// LDR Wt  00011000 iiiiiiii iiiiiiii iiittttt  & 0xff000000 == 0x18000000  (i = SignExtend(imm19:00, 64), t = Rt)
// LDR Xt  01011000 iiiiiiii iiiiiiii iiittttt  & 0xff000000 == 0x58000000  (i = SignExtend(imm19:00, 64), t = Rt)
// LDRSW   10011000 iiiiiiii iiiiiiii iiittttt  & 0xff000000 == 0x98000000  (i = SignExtend(imm19:00, 64), t = Rt)
// PRFM    11011000 iiiiiiii iiiiiiii iiittttt  & 0xff000000 == 0xd8000000  (i = SignExtend(imm19:00, 64), t = Rt)
// LDR St  00011100 iiiiiiii iiiiiiii iiittttt  & 0xff000000 == 0x1c000000  (i = SignExtend(imm19:00, 64), t = Rt)
// LDR Dt  01011100 iiiiiiii iiiiiiii iiittttt  & 0xff000000 == 0x5c000000  (i = SignExtend(imm19:00, 64), t = Rt)
// LDR Qt  10011100 iiiiiiii iiiiiiii iiittttt  & 0xff000000 == 0x9c000000  (i = SignExtend(imm19:00, 64), t = Rt)
// LDR inv 11011100 iiiiiiii iiiiiiii iiittttt  & 0xff000000 == 0xdc000000  (i = SignExtend(imm19:00, 64), t = Rt)
//
// TBNZ    z0110111 bbbbbiii iiiiiiii iiittttt  & 0x7f000000 == 0x37000000  (z = size, b = bitnum, i = SignExtend(imm14:00, 64), t = Rt)
// TBZ     z0110110 bbbbbiii iiiiiiii iiittttt  & 0x7f000000 == 0x36000000  (z = size, b = bitnum, i = SignExtend(imm14:00, 64), t = Rt)
//

class CDetourDis
{
  public:
    CDetourDis();

    PBYTE   CopyInstruction(PBYTE pDst,
                            PBYTE pSrc,
                            PBYTE *ppTarget,
                            LONG *plExtra);

  public:
    typedef BYTE (CDetourDis::* COPYFUNC)(PBYTE pbDst, PBYTE pbSrc);

    union AddImm12
    {
        DWORD Assembled;
        struct
        {
            DWORD Rd : 5;           // Destination register
            DWORD Rn : 5;           // Source register
            DWORD Imm12 : 12;       // 12-bit immediate
            DWORD Shift : 2;        // shift (must be 0 or 1)
            DWORD Opcode1 : 7;      // Must be 0010001 == 0x11
            DWORD Size : 1;         // 0 = 32-bit, 1 = 64-bit
        } s;
        static DWORD Assemble(DWORD size, DWORD rd, DWORD rn, ULONG imm, DWORD shift)
        {
            AddImm12 temp;
            temp.s.Rd = rd;
            temp.s.Rn = rn;
            temp.s.Imm12 = imm & 0xfff;
            temp.s.Shift = shift;
            temp.s.Opcode1 = 0x11;
            temp.s.Size = size;
            return temp.Assembled;
        }
        static DWORD AssembleAdd32(DWORD rd, DWORD rn, ULONG imm, DWORD shift) { return Assemble(0, rd, rn, imm, shift); }
        static DWORD AssembleAdd64(DWORD rd, DWORD rn, ULONG imm, DWORD shift) { return Assemble(1, rd, rn, imm, shift); }
    };

    union Adr19
    {
        DWORD Assembled;
        struct
        {
            DWORD Rd : 5;           // Destination register
            DWORD Imm19 : 19;       // 19-bit upper immediate
            DWORD Opcode1 : 5;      // Must be 10000 == 0x10
            DWORD Imm2 : 2;         // 2-bit lower immediate
            DWORD Type : 1;         // 0 = ADR, 1 = ADRP
        } s;
        inline LONG Imm() const { DWORD Imm = (s.Imm19 << 2) | s.Imm2; return (LONG)(Imm << 11) >> 11; }
        static DWORD Assemble(DWORD type, DWORD rd, LONG delta)
        {
            Adr19 temp;
            temp.s.Rd = rd;
            temp.s.Imm19 = (delta >> 2) & 0x7ffff;
            temp.s.Opcode1 = 0x10;
            temp.s.Imm2 = delta & 3;
            temp.s.Type = type;
            return temp.Assembled;
        }
        static DWORD AssembleAdr(DWORD rd, LONG delta) { return Assemble(0, rd, delta); }
        static DWORD AssembleAdrp(DWORD rd, LONG delta) { return Assemble(1, rd, delta); }
    };

    union Bcc19
    {
        DWORD Assembled;
        struct
        {
            DWORD Condition : 4;    // Condition
            DWORD Opcode1 : 1;      // Must be 0
            DWORD Imm19 : 19;       // 19-bit immediate
            DWORD Opcode2 : 8;      // Must be 01010100 == 0x54
        } s;
        inline LONG Imm() const { return (LONG)(s.Imm19 << 13) >> 11; }
        static DWORD AssembleBcc(DWORD condition, LONG delta)
        {
            Bcc19 temp;
            temp.s.Condition = condition;
            temp.s.Opcode1 = 0;
            temp.s.Imm19 = delta >> 2;
            temp.s.Opcode2 = 0x54;
            return temp.Assembled;
        }
    };

    union Branch26
    {
        DWORD Assembled;
        struct
        {
            DWORD Imm26 : 26;       // 26-bit immediate
            DWORD Opcode1 : 5;      // Must be 00101 == 0x5
            DWORD Link : 1;         // 0 = B, 1 = BL
        } s;
        inline LONG Imm() const { return (LONG)(s.Imm26 << 6) >> 4; }
        static DWORD Assemble(DWORD link, LONG delta)
        {
            Branch26 temp;
            temp.s.Imm26 = delta >> 2;
            temp.s.Opcode1 = 0x5;
            temp.s.Link = link;
            return temp.Assembled;
        }
        static DWORD AssembleB(LONG delta) { return Assemble(0, delta); }
        static DWORD AssembleBl(LONG delta) { return Assemble(1, delta); }
    };

    union Br
    {
        DWORD Assembled;
        struct
        {
            DWORD Opcode1 : 5;      // Must be 00000 == 0
            DWORD Rn : 5;           // Register number
            DWORD Opcode2 : 22;     // Must be 1101011000011111000000 == 0x3587c0 for Br
                                    //                                   0x358fc0 for Brl
        } s;
        static DWORD Assemble(DWORD rn, bool link)
        {
            Br temp;
            temp.s.Opcode1 = 0;
            temp.s.Rn = rn;
            temp.s.Opcode2 = 0x3587c0;
            if (link)
                temp.Assembled |= 0x00200000;
            return temp.Assembled;
        }
        static DWORD AssembleBr(DWORD rn)
        {
            return Assemble(rn, false);
        }
        static DWORD AssembleBrl(DWORD rn)
        {
            return Assemble(rn, true);
        }
    };

    union Cbz19
    {
        DWORD Assembled;
        struct
        {
            DWORD Rt : 5;           // Register to test
            DWORD Imm19 : 19;       // 19-bit immediate
            DWORD Nz : 1;           // 0 = CBZ, 1 = CBNZ
            DWORD Opcode1 : 6;      // Must be 011010 == 0x1a
            DWORD Size : 1;         // 0 = 32-bit, 1 = 64-bit
        } s;
        inline LONG Imm() const { return (LONG)(s.Imm19 << 13) >> 11; }
        static DWORD Assemble(DWORD size, DWORD nz, DWORD rt, LONG delta)
        {
            Cbz19 temp;
            temp.s.Rt = rt;
            temp.s.Imm19 = delta >> 2;
            temp.s.Nz = nz;
            temp.s.Opcode1 = 0x1a;
            temp.s.Size = size;
            return temp.Assembled;
        }
    };

    union LdrLit19
    {
        DWORD Assembled;
        struct
        {
            DWORD Rt : 5;           // Destination register
            DWORD Imm19 : 19;       // 19-bit immediate
            DWORD Opcode1 : 2;      // Must be 0
            DWORD FpNeon : 1;       // 0 = LDR Wt/LDR Xt/LDRSW/PRFM, 1 = LDR St/LDR Dt/LDR Qt
            DWORD Opcode2 : 3;      // Must be 011 = 3
            DWORD Size : 2;         // 00 = LDR Wt/LDR St, 01 = LDR Xt/LDR Dt, 10 = LDRSW/LDR Qt, 11 = PRFM/invalid
        } s;
        inline LONG Imm() const { return (LONG)(s.Imm19 << 13) >> 11; }
        static DWORD Assemble(DWORD size, DWORD fpneon, DWORD rt, LONG delta)
        {
            LdrLit19 temp;
            temp.s.Rt = rt;
            temp.s.Imm19 = delta >> 2;
            temp.s.Opcode1 = 0;
            temp.s.FpNeon = fpneon;
            temp.s.Opcode2 = 3;
            temp.s.Size = size;
            return temp.Assembled;
        }
    };

    union LdrFpNeonImm9
    {
        DWORD Assembled;
        struct
        {
            DWORD Rt : 5;           // Destination register
            DWORD Rn : 5;           // Base register
            DWORD Imm12 : 12;       // 12-bit immediate
            DWORD Opcode1 : 1;      // Must be 1 == 1
            DWORD Opc : 1;          // Part of size
            DWORD Opcode2 : 6;      // Must be 111101 == 0x3d
            DWORD Size : 2;         // Size (0=8-bit, 1=16-bit, 2=32-bit, 3=64-bit, 4=128-bit)
        } s;
        static DWORD Assemble(DWORD size, DWORD rt, DWORD rn, ULONG imm)
        {
            LdrFpNeonImm9 temp;
            temp.s.Rt = rt;
            temp.s.Rn = rn;
            temp.s.Imm12 = imm;
            temp.s.Opcode1 = 1;
            temp.s.Opc = size >> 2;
            temp.s.Opcode2 = 0x3d;
            temp.s.Size = size & 3;
            return temp.Assembled;
        }
    };

    union Mov16
    {
        DWORD Assembled;
        struct
        {
            DWORD Rd : 5;           // Destination register
            DWORD Imm16 : 16;       // Immediate
            DWORD Shift : 2;        // Shift amount (0=0, 1=16, 2=32, 3=48)
            DWORD Opcode : 6;       // Must be 100101 == 0x25
            DWORD Type : 2;         // 0 = MOVN, 1 = reserved, 2 = MOVZ, 3 = MOVK
            DWORD Size : 1;         // 0 = 32-bit, 1 = 64-bit
        } s;
        static DWORD Assemble(DWORD size, DWORD type, DWORD rd, DWORD imm, DWORD shift)
        {
            Mov16 temp;
            temp.s.Rd = rd;
            temp.s.Imm16 = imm;
            temp.s.Shift = shift;
            temp.s.Opcode = 0x25;
            temp.s.Type = type;
            temp.s.Size = size;
            return temp.Assembled;
        }
        static DWORD AssembleMovn32(DWORD rd, DWORD imm, DWORD shift) { return Assemble(0, 0, rd, imm, shift); }
        static DWORD AssembleMovn64(DWORD rd, DWORD imm, DWORD shift) { return Assemble(1, 0, rd, imm, shift); }
        static DWORD AssembleMovz32(DWORD rd, DWORD imm, DWORD shift) { return Assemble(0, 2, rd, imm, shift); }
        static DWORD AssembleMovz64(DWORD rd, DWORD imm, DWORD shift) { return Assemble(1, 2, rd, imm, shift); }
        static DWORD AssembleMovk32(DWORD rd, DWORD imm, DWORD shift) { return Assemble(0, 3, rd, imm, shift); }
        static DWORD AssembleMovk64(DWORD rd, DWORD imm, DWORD shift) { return Assemble(1, 3, rd, imm, shift); }
    };

    union Tbz14
    {
        DWORD Assembled;
        struct
        {
            DWORD Rt : 5;           // Register to test
            DWORD Imm14 : 14;       // 14-bit immediate
            DWORD Bit : 5;          // 5-bit index
            DWORD Nz : 1;           // 0 = TBZ, 1 = TBNZ
            DWORD Opcode1 : 6;      // Must be 011011 == 0x1b
            DWORD Size : 1;         // 0 = 32-bit, 1 = 64-bit
        } s;
        inline LONG Imm() const { return (LONG)(s.Imm14 << 18) >> 16; }
        static DWORD Assemble(DWORD size, DWORD nz, DWORD rt, DWORD bit, LONG delta)
        {
            Tbz14 temp;
            temp.s.Rt = rt;
            temp.s.Imm14 = delta >> 2;
            temp.s.Bit = bit;
            temp.s.Nz = nz;
            temp.s.Opcode1 = 0x1b;
            temp.s.Size = size;
            return temp.Assembled;
        }
    };


  protected:
    BYTE    PureCopy32(BYTE* pSource, BYTE* pDest);
    BYTE    EmitMovImmediate(PULONG& pDstInst, BYTE rd, UINT64 immediate);
    BYTE    CopyAdr(BYTE* pSource, BYTE* pDest, ULONG instruction);
    BYTE    CopyBcc(BYTE* pSource, BYTE* pDest, ULONG instruction);
    BYTE    CopyB(BYTE* pSource, BYTE* pDest, ULONG instruction);
    BYTE    CopyBl(BYTE* pSource, BYTE* pDest, ULONG instruction);
    BYTE    CopyB_or_Bl(BYTE* pSource, BYTE* pDest, ULONG instruction, bool link);
    BYTE    CopyCbz(BYTE* pSource, BYTE* pDest, ULONG instruction);
    BYTE    CopyTbz(BYTE* pSource, BYTE* pDest, ULONG instruction);
    BYTE    CopyLdrLiteral(BYTE* pSource, BYTE* pDest, ULONG instruction);

  protected:
    ULONG GetInstruction(BYTE* pSource)
    {
        return ((PULONG)pSource)[0];
    }

    BYTE EmitInstruction(PULONG& pDstInst, ULONG instruction)
    {
        *pDstInst++ = instruction;
        return sizeof(ULONG);
    }

  protected:
    PBYTE   m_pbTarget;
    BYTE    m_rbScratchDst[128]; // matches or exceeds rbCode
};

BYTE CDetourDis::PureCopy32(BYTE* pSource, BYTE* pDest)
{
    *(ULONG *)pDest = *(ULONG*)pSource;
    return sizeof(DWORD);
}

/////////////////////////////////////////////////////////// Disassembler Code.
//
CDetourDis::CDetourDis() :
    m_pbTarget((PBYTE)DETOUR_INSTRUCTION_TARGET_NONE)
{
}

PBYTE CDetourDis::CopyInstruction(PBYTE pDst,
                                  PBYTE pSrc,
                                  PBYTE *ppTarget,
                                  LONG *plExtra)
{
    if (pDst == NULL) {
        pDst = m_rbScratchDst;
    }

    DWORD Instruction = GetInstruction(pSrc);

    ULONG CopiedSize;
    if ((Instruction & 0x1f000000) == 0x10000000) {
        CopiedSize = CopyAdr(pSrc, pDst, Instruction);
    } else if ((Instruction & 0xff000010) == 0x54000000) {
        CopiedSize = CopyBcc(pSrc, pDst, Instruction);
    } else if ((Instruction & 0x7c000000) == 0x14000000) {
        CopiedSize = CopyB_or_Bl(pSrc, pDst, Instruction, (Instruction & 0x80000000) != 0);
    } else if ((Instruction & 0x7e000000) == 0x34000000) {
        CopiedSize = CopyCbz(pSrc, pDst, Instruction);
    } else if ((Instruction & 0x7e000000) == 0x36000000) {
        CopiedSize = CopyTbz(pSrc, pDst, Instruction);
    } else if ((Instruction & 0x3b000000) == 0x18000000) {
        CopiedSize = CopyLdrLiteral(pSrc, pDst, Instruction);
    } else {
        CopiedSize = PureCopy32(pSrc, pDst);
    }

    // If the target is needed, store our target
    if (ppTarget) {
        *ppTarget = m_pbTarget;
    }
    if (plExtra) {
        *plExtra = CopiedSize - sizeof(DWORD);
    }

    return pSrc + 4;
}

BYTE CDetourDis::EmitMovImmediate(PULONG& pDstInst, BYTE rd, UINT64 immediate)
{
    DWORD piece[4];
    piece[3] = (DWORD)((immediate >> 48) & 0xffff);
    piece[2] = (DWORD)((immediate >> 32) & 0xffff);
    piece[1] = (DWORD)((immediate >> 16) & 0xffff);
    piece[0] = (DWORD)((immediate >> 0) & 0xffff);
    int count = 0;

    // special case: MOVN with 32-bit dest
    if (piece[3] == 0 && piece[2] == 0 && piece[1] == 0xffff)
    {
        EmitInstruction(pDstInst, Mov16::AssembleMovn32(rd, piece[0] ^ 0xffff, 0));
        count++;
    }

    // MOVN/MOVZ with 64-bit dest
    else
    {
        int zero_pieces = (piece[3] == 0x0000) + (piece[2] == 0x0000) + (piece[1] == 0x0000) + (piece[0] == 0x0000);
        int ffff_pieces = (piece[3] == 0xffff) + (piece[2] == 0xffff) + (piece[1] == 0xffff) + (piece[0] == 0xffff);
        DWORD defaultPiece = (ffff_pieces > zero_pieces) ? 0xffff : 0x0000;
        bool first = true;
        for (int pieceNum = 3; pieceNum >= 0; pieceNum--)
        {
            DWORD curPiece = piece[pieceNum];
            if (curPiece != defaultPiece || (pieceNum == 0 && first))
            {
                count++;
                if (first)
                {
                    if (defaultPiece == 0xffff)
                    {
                        EmitInstruction(pDstInst, Mov16::AssembleMovn64(rd, curPiece ^ 0xffff, pieceNum));
                    }
                    else
                    {
                        EmitInstruction(pDstInst, Mov16::AssembleMovz64(rd, curPiece, pieceNum));
                    }
                    first = false;
                }
                else
                {
                    EmitInstruction(pDstInst, Mov16::AssembleMovk64(rd, curPiece, pieceNum));
                }
            }
        }
    }
    return (BYTE)(count * sizeof(DWORD));
}

BYTE CDetourDis::CopyAdr(BYTE* pSource, BYTE* pDest, ULONG instruction)
{
    Adr19& decoded = (Adr19&)(instruction);
    PULONG pDstInst = (PULONG)(pDest);

    // ADR case
    if (decoded.s.Type == 0)
    {
        BYTE* pTarget = pSource + decoded.Imm();
        LONG64 delta = pTarget - pDest;
        LONG64 deltaPage = ((ULONG_PTR)pTarget >> 12) - ((ULONG_PTR)pDest >> 12);

        // output as ADR
        if (delta >= -(1 << 20) && delta < (1 << 20))
        {
            EmitInstruction(pDstInst, Adr19::AssembleAdr(decoded.s.Rd, (LONG)delta));
        }

        // output as ADRP; ADD
        else if (deltaPage >= -(1 << 20) && (deltaPage < (1 << 20)))
        {
            EmitInstruction(pDstInst, Adr19::AssembleAdrp(decoded.s.Rd, (LONG)deltaPage));
            EmitInstruction(pDstInst, AddImm12::AssembleAdd32(decoded.s.Rd, decoded.s.Rd, ((ULONG)(ULONG_PTR)pTarget) & 0xfff, 0));
        }

        // output as immediate move
        else
        {
            EmitMovImmediate(pDstInst, decoded.s.Rd, (ULONG_PTR)pTarget);
        }
    }

    // ADRP case
    else
    {
        BYTE* pTarget = (BYTE*)((((ULONG_PTR)pSource >> 12) + decoded.Imm()) << 12);
        LONG64 deltaPage = ((ULONG_PTR)pTarget >> 12) - ((ULONG_PTR)pDest >> 12);

        // output as ADRP
        if (deltaPage >= -(1 << 20) && (deltaPage < (1 << 20)))
        {
            EmitInstruction(pDstInst, Adr19::AssembleAdrp(decoded.s.Rd, (LONG)deltaPage));
        }

        // output as immediate move
        else
        {
            EmitMovImmediate(pDstInst, decoded.s.Rd, (ULONG_PTR)pTarget);
        }
    }

    return (BYTE)((BYTE*)pDstInst - pDest);
}

BYTE CDetourDis::CopyBcc(BYTE* pSource, BYTE* pDest, ULONG instruction)
{
    Bcc19& decoded = (Bcc19&)(instruction);
    PULONG pDstInst = (PULONG)(pDest);

    BYTE* pTarget = pSource + decoded.Imm();
    m_pbTarget = pTarget;
    LONG64 delta = pTarget - pDest;
    LONG64 delta4 = pTarget - (pDest + 4);

    // output as BCC
    if (delta >= -(1 << 20) && delta < (1 << 20))
    {
        EmitInstruction(pDstInst, Bcc19::AssembleBcc(decoded.s.Condition, (LONG)delta));
    }

    // output as BCC <skip>; B
    else if (delta4 >= -(1 << 27) && (delta4 < (1 << 27)))
    {
        EmitInstruction(pDstInst, Bcc19::AssembleBcc(decoded.s.Condition ^ 1, 8));
        EmitInstruction(pDstInst, Branch26::AssembleB((LONG)delta4));
    }

    // output as MOV x17, Target; BCC <skip>; BR x17 (BIG assumption that x17 isn't being used for anything!!)
    else
    {
        EmitMovImmediate(pDstInst, 17, (ULONG_PTR)pTarget);
        EmitInstruction(pDstInst, Bcc19::AssembleBcc(decoded.s.Condition ^ 1, 8));
        EmitInstruction(pDstInst, Br::AssembleBr(17));
    }

    return (BYTE)((BYTE*)pDstInst - pDest);
}

BYTE CDetourDis::CopyB_or_Bl(BYTE* pSource, BYTE* pDest, ULONG instruction, bool link)
{
    Branch26& decoded = (Branch26&)(instruction);
    PULONG pDstInst = (PULONG)(pDest);

    BYTE* pTarget = pSource + decoded.Imm();
    m_pbTarget = pTarget;
    LONG64 delta = pTarget - pDest;

    // output as B or BRL
    if (delta >= -(1 << 27) && (delta < (1 << 27)))
    {
        EmitInstruction(pDstInst, Branch26::Assemble(link, (LONG)delta));
    }

    // output as MOV x17, Target; BR or BRL x17 (BIG assumption that x17 isn't being used for anything!!)
    else
    {
        EmitMovImmediate(pDstInst, 17, (ULONG_PTR)pTarget);
        EmitInstruction(pDstInst, Br::Assemble(17, link));
    }

    return (BYTE)((BYTE*)pDstInst - pDest);
}

BYTE CDetourDis::CopyB(BYTE* pSource, BYTE* pDest, ULONG instruction)
{
    return CopyB_or_Bl(pSource, pDest, instruction, false);
}

BYTE CDetourDis::CopyBl(BYTE* pSource, BYTE* pDest, ULONG instruction)
{
    return CopyB_or_Bl(pSource, pDest, instruction, true);
}

BYTE CDetourDis::CopyCbz(BYTE* pSource, BYTE* pDest, ULONG instruction)
{
    Cbz19& decoded = (Cbz19&)(instruction);
    PULONG pDstInst = (PULONG)(pDest);

    BYTE* pTarget = pSource + decoded.Imm();
    m_pbTarget = pTarget;
    LONG64 delta = pTarget - pDest;
    LONG64 delta4 = pTarget - (pDest + 4);

    // output as CBZ/NZ
    if (delta >= -(1 << 20) && delta < (1 << 20))
    {
        EmitInstruction(pDstInst, Cbz19::Assemble(decoded.s.Size, decoded.s.Nz, decoded.s.Rt, (LONG)delta));
    }

    // output as CBNZ/Z <skip>; B
    else if (delta4 >= -(1 << 27) && (delta4 < (1 << 27)))
    {
        EmitInstruction(pDstInst, Cbz19::Assemble(decoded.s.Size, decoded.s.Nz ^ 1, decoded.s.Rt, 8));
        EmitInstruction(pDstInst, Branch26::AssembleB((LONG)delta4));
    }

    // output as MOV x17, Target; CBNZ/Z <skip>; BR x17 (BIG assumption that x17 isn't being used for anything!!)
    else
    {
        EmitMovImmediate(pDstInst, 17, (ULONG_PTR)pTarget);
        EmitInstruction(pDstInst, Cbz19::Assemble(decoded.s.Size, decoded.s.Nz ^ 1, decoded.s.Rt, 8));
        EmitInstruction(pDstInst, Br::AssembleBr(17));
    }

    return (BYTE)((BYTE*)pDstInst - pDest);
}

BYTE CDetourDis::CopyTbz(BYTE* pSource, BYTE* pDest, ULONG instruction)
{
    Tbz14& decoded = (Tbz14&)(instruction);
    PULONG pDstInst = (PULONG)(pDest);

    BYTE* pTarget = pSource + decoded.Imm();
    m_pbTarget = pTarget;
    LONG64 delta = pTarget - pDest;
    LONG64 delta4 = pTarget - (pDest + 4);

    // output as TBZ/NZ
    if (delta >= -(1 << 13) && delta < (1 << 13))
    {
        EmitInstruction(pDstInst, Tbz14::Assemble(decoded.s.Size, decoded.s.Nz, decoded.s.Rt, decoded.s.Bit, (LONG)delta));
    }

    // output as TBNZ/Z <skip>; B
    else if (delta4 >= -(1 << 27) && (delta4 < (1 << 27)))
    {
        EmitInstruction(pDstInst, Tbz14::Assemble(decoded.s.Size, decoded.s.Nz ^ 1, decoded.s.Rt, decoded.s.Bit, 8));
        EmitInstruction(pDstInst, Branch26::AssembleB((LONG)delta4));
    }

    // output as MOV x17, Target; TBNZ/Z <skip>; BR x17 (BIG assumption that x17 isn't being used for anything!!)
    else
    {
        EmitMovImmediate(pDstInst, 17, (ULONG_PTR)pTarget);
        EmitInstruction(pDstInst, Tbz14::Assemble(decoded.s.Size, decoded.s.Nz ^ 1, decoded.s.Rt, decoded.s.Bit, 8));
        EmitInstruction(pDstInst, Br::AssembleBr(17));
    }

    return (BYTE)((BYTE*)pDstInst - pDest);
}

BYTE CDetourDis::CopyLdrLiteral(BYTE* pSource, BYTE* pDest, ULONG instruction)
{
    LdrLit19& decoded = (LdrLit19&)(instruction);
    PULONG pDstInst = (PULONG)(pDest);

    BYTE* pTarget = pSource + decoded.Imm();
    LONG64 delta = pTarget - pDest;

    // output as LDR
    if (delta >= -(1 << 21) && delta < (1 << 21))
    {
        EmitInstruction(pDstInst, LdrLit19::Assemble(decoded.s.Size, decoded.s.FpNeon, decoded.s.Rt, (LONG)delta));
    }

    // output as move immediate
    else if (decoded.s.FpNeon == 0)
    {
        UINT64 value = 0;
        switch (decoded.s.Size)
        {
            case 0: value = *(ULONG*)pTarget;       break;
            case 1: value = *(UINT64*)pTarget;   break;
            case 2: value = *(LONG*)pTarget;        break;
        }
        EmitMovImmediate(pDstInst, decoded.s.Rt, value);
    }

    // FP/NEON register: compute address in x17 and load from there (BIG assumption that x17 isn't being used for anything!!)
    else
    {
        EmitMovImmediate(pDstInst, 17, (ULONG_PTR)pTarget);
        EmitInstruction(pDstInst, LdrFpNeonImm9::Assemble(2 + decoded.s.Size, decoded.s.Rt, 17, 0));
    }

    return (BYTE)((BYTE*)pDstInst - pDest);
}


PVOID WINAPI DetourCopyInstruction(_In_opt_ PVOID pDst,
                                   _Inout_opt_ PVOID *ppDstPool,
                                   _In_ PVOID pSrc,
                                   _Out_opt_ PVOID *ppTarget,
                                   _Out_opt_ LONG *plExtra)
{
    UNREFERENCED_PARAMETER(ppDstPool);

    CDetourDis state;
    return (PVOID)state.CopyInstruction((PBYTE)pDst,
                                        (PBYTE)pSrc,
                                        (PBYTE*)ppTarget,
                                        plExtra);
}

#endif // DETOURS_ARM64

BOOL WINAPI DetourSetCodeModule(_In_ HMODULE hModule,
                                _In_ BOOL fLimitReferencesToModule)
{
#if defined(DETOURS_X64) || defined(DETOURS_X86)
    PBYTE pbBeg = NULL;
    PBYTE pbEnd = (PBYTE)~(ULONG_PTR)0;

    if (hModule != NULL) {
        ULONG cbModule = DetourGetModuleSize(hModule);

        pbBeg = (PBYTE)hModule;
        pbEnd = (PBYTE)hModule + cbModule;
    }

    return CDetourDis::SetCodeModule(pbBeg, pbEnd, fLimitReferencesToModule);
#elif defined(DETOURS_ARM) || defined(DETOURS_ARM64) || defined(DETOURS_IA64)
    (void)hModule;
    (void)fLimitReferencesToModule;
    return TRUE;
#else
#error unknown architecture (x86, x64, arm, arm64, ia64)
#endif
}

//
///////////////////////////////////////////////////////////////// End of File.

```

`src/disolarm.cpp`:

```cpp
#define DETOURS_ARM_OFFLINE_LIBRARY
#include "disasm.cpp"

```

`src/disolarm64.cpp`:

```cpp
#define DETOURS_ARM64_OFFLINE_LIBRARY
#include "disasm.cpp"

```

`src/disolia64.cpp`:

```cpp
#define DETOURS_IA64_OFFLINE_LIBRARY
#include "disasm.cpp"

```

`src/disolx64.cpp`:

```cpp
#define DETOURS_X64_OFFLINE_LIBRARY
#include "disasm.cpp"

```

`src/disolx86.cpp`:

```cpp
#define DETOURS_X86_OFFLINE_LIBRARY
#include "disasm.cpp"

```

`src/image.cpp`:

```cpp
//////////////////////////////////////////////////////////////////////////////
//
//  Image manipulation functions (image.cpp of detours.lib)
//
//  Microsoft Research Detours Package, Version 4.0.1
//
//  Copyright (c) Microsoft Corporation.  All rights reserved.
//
//  Used for for payloads, byways, and imports.
//

#if _MSC_VER < 1299
#pragma warning(disable: 4710)
#endif

// #define DETOUR_DEBUG 1
#define DETOURS_INTERNAL
#include "detours.h"

#if DETOURS_VERSION != 0x4c0c1   // 0xMAJORcMINORcPATCH
#error detours.h version mismatch
#endif

namespace Detour
{
//////////////////////////////////////////////////////////////////////////////
//
#ifndef _STRSAFE_H_INCLUDED_
_Must_inspect_result_
static inline HRESULT StringCchLengthA(
    _In_reads_or_z_(cchMax) LPCSTR psz,
    _In_
    _In_range_(1, STRSAFE_MAX_CCH) size_t cchMax,
    _Out_opt_
    _Deref_out_range_(<, cchMax)
    _Deref_out_range_(<=, _String_length_(psz))
    _Out_ size_t* pcch)
{
    HRESULT hr = S_OK;
    size_t cchMaxPrev = cchMax;

    if (cchMax > 2147483647) {
        return ERROR_INVALID_PARAMETER;
    }

    while (cchMax && (*psz != '\0')) {
        psz++;
        cchMax--;
    }

    if (cchMax == 0) {
        // the string is longer than cchMax
        hr = ERROR_INVALID_PARAMETER;
    }

    if (SUCCEEDED(hr) && pcch) {
        *pcch = cchMaxPrev - cchMax;
    }

    return hr;
}

_Must_inspect_result_
static inline HRESULT StringCchCopyA(
    _Out_writes_(cchDest) _Always_(_Post_z_) LPSTR pszDest,
    _In_ size_t cchDest,
    _In_ LPCSTR pszSrc)
{
    HRESULT hr = S_OK;

    if (cchDest == 0) {
        // can not null terminate a zero-byte dest buffer
        hr = ERROR_INVALID_PARAMETER;
    }
    else {
        while (cchDest && (*pszSrc != '\0')) {
            *pszDest++ = *pszSrc++;
            cchDest--;
        }

        if (cchDest == 0) {
            // we are going to truncate pszDest
            pszDest--;
            hr = ERROR_INVALID_PARAMETER;
        }

        *pszDest= '\0';
    }

    return hr;
}

_Must_inspect_result_
static inline HRESULT StringCchCatA(
    _Out_writes_(cchDest) _Always_(_Post_z_) LPSTR pszDest,
    _In_ size_t cchDest,
    _In_ LPCSTR pszSrc)
{
    HRESULT hr;
    size_t cchDestCurrent;

    if (cchDest > 2147483647){
        return ERROR_INVALID_PARAMETER;
    }

    hr = StringCchLengthA(pszDest, cchDest, &cchDestCurrent);

    if (SUCCEEDED(hr) && cchDestCurrent < cchDest) {
        hr = StringCchCopyA(pszDest + cchDestCurrent,
                            cchDest - cchDestCurrent,
                            pszSrc);
    }

    return hr;
}

#endif

///////////////////////////////////////////////////////////////////////////////
//
class CImageData
{
    friend class CImage;

public:
    CImageData(PBYTE pbData, DWORD cbData);
    ~CImageData();

    PBYTE                   Enumerate(GUID *pGuid, DWORD *pcbData, DWORD *pnIterator);
    PBYTE                   Find(REFGUID rguid, DWORD *pcbData);
    PBYTE                   Set(REFGUID rguid, PBYTE pbData, DWORD cbData);

    BOOL                    Delete(REFGUID rguid);
    BOOL                    Purge();

    BOOL                    IsEmpty()           { return m_cbData == 0; }
    BOOL                    IsValid();

protected:
    BOOL                    SizeTo(DWORD cbData);

protected:
    _Field_size_(m_cbAlloc)
    PBYTE                   m_pbData;
    DWORD                   m_cbData;
    DWORD                   m_cbAlloc;
};

class CImageImportName;

class CImageImportFile
{
    friend class CImage;
    friend class CImageImportName;

public:
    CImageImportFile();
    ~CImageImportFile();

public:
    CImageImportFile *      m_pNextFile;
    BOOL                    m_fByway;

    _Field_size_(m_nImportNames)
    CImageImportName *      m_pImportNames;
    DWORD                   m_nImportNames;

    DWORD                   m_rvaOriginalFirstThunk;
    DWORD                   m_rvaFirstThunk;

    DWORD                   m_nForwarderChain;
    LPCSTR                  m_pszOrig;
    LPCSTR                  m_pszName;
};

class CImageImportName
{
    friend class CImage;
    friend class CImageImportFile;

public:
    CImageImportName();
    ~CImageImportName();

public:
    WORD        m_nHint;
    ULONG       m_nOrig;
    ULONG       m_nOrdinal;
    LPCSTR      m_pszOrig;
    LPCSTR      m_pszName;
};

class CImage
{
    friend class CImageThunks;
    friend class CImageChars;
    friend class CImageImportFile;
    friend class CImageImportName;

public:
    CImage();
    ~CImage();

    static CImage *         IsValid(PDETOUR_BINARY pBinary);

public:                                                 // File Functions
    BOOL                    Read(HANDLE hFile);
    BOOL                    Write(HANDLE hFile);
    BOOL                    Close();

public:                                                 // Manipulation Functions
    PBYTE                   DataEnum(GUID *pGuid, DWORD *pcbData, DWORD *pnIterator);
    PBYTE                   DataFind(REFGUID rguid, DWORD *pcbData);
    PBYTE                   DataSet(REFGUID rguid, PBYTE pbData, DWORD cbData);
    BOOL                    DataDelete(REFGUID rguid);
    BOOL                    DataPurge();

    BOOL                    EditImports(PVOID pContext,
                                        PF_DETOUR_BINARY_BYWAY_CALLBACK pfBywayCallback,
                                        PF_DETOUR_BINARY_FILE_CALLBACK pfFileCallback,
                                        PF_DETOUR_BINARY_SYMBOL_CALLBACK pfSymbolCallback,
                                        PF_DETOUR_BINARY_COMMIT_CALLBACK pfCommitCallback);

protected:
    BOOL                    WriteFile(HANDLE hFile,
                                      LPCVOID lpBuffer,
                                      DWORD nNumberOfBytesToWrite,
                                      LPDWORD lpNumberOfBytesWritten);
    BOOL                    CopyFileData(HANDLE hFile, DWORD nOldPos, DWORD cbData);
    BOOL                    ZeroFileData(HANDLE hFile, DWORD cbData);
    BOOL                    AlignFileData(HANDLE hFile);

    BOOL                    SizeOutputBuffer(DWORD cbData);
    PBYTE                   AllocateOutput(DWORD cbData, DWORD *pnVirtAddr);

    PVOID                   RvaToVa(ULONG_PTR nRva);
    DWORD                   RvaToFileOffset(DWORD nRva);

    DWORD                   FileAlign(DWORD nAddr);
    DWORD                   SectionAlign(DWORD nAddr);

    BOOL                    CheckImportsNeeded(DWORD *pnTables,
                                               DWORD *pnThunks,
                                               DWORD *pnChars);

    CImageImportFile *      NewByway(_In_ LPCSTR pszName);

private:
    DWORD                   m_dwValidSignature;
    CImageData *            m_pImageData;               // Read & Write

    HANDLE                  m_hMap;                     // Read & Write
    PBYTE                   m_pMap;                     // Read & Write

    DWORD                   m_nNextFileAddr;            // Write
    DWORD                   m_nNextVirtAddr;            // Write

    IMAGE_DOS_HEADER        m_DosHeader;                // Read & Write
    IMAGE_NT_HEADERS        m_NtHeader;                 // Read & Write
    IMAGE_SECTION_HEADER    m_SectionHeaders[IMAGE_NUMBEROF_DIRECTORY_ENTRIES];

    DWORD                   m_nPrePE;
    DWORD                   m_cbPrePE;
    DWORD                   m_cbPostPE;

    DWORD                   m_nPeOffset;
    DWORD                   m_nSectionsOffset;
    DWORD                   m_nExtraOffset;
    DWORD                   m_nFileSize;

    DWORD                   m_nOutputVirtAddr;
    DWORD                   m_nOutputVirtSize;
    DWORD                   m_nOutputFileAddr;

    _Field_size_(m_cbOutputBuffer)
    PBYTE                   m_pbOutputBuffer;
    DWORD                   m_cbOutputBuffer;

    CImageImportFile *      m_pImportFiles;
    DWORD                   m_nImportFiles;

    BOOL                    m_fHadDetourSection;

private:
    enum {
        DETOUR_IMAGE_VALID_SIGNATURE = 0xfedcba01,      // "Dtr\0"
    };
};

//////////////////////////////////////////////////////////////////////////////
//
static BYTE s_rbDosCode[0x10] = {
    0x0E,0x1F,0xBA,0x0E,0x00,0xB4,0x09,0xCD,
    0x21,0xB8,0x01,0x4C,0xCD,0x21,'*','*'
};

static inline DWORD Max(DWORD a, DWORD b)
{
    return a > b ? a : b;
}

static inline DWORD Align(DWORD a, DWORD size)
{
    size--;
    return (a + size) & ~size;
}

static inline DWORD QuadAlign(DWORD a)
{
    return Align(a, 8);
}

static LPCSTR DuplicateString(_In_ LPCSTR pszIn)
{
    if (pszIn == NULL) {
        return NULL;
    }

    size_t cch;
    HRESULT hr = StringCchLengthA(pszIn, 8192, &cch);
    if (FAILED(hr)) {
        SetLastError(ERROR_INVALID_PARAMETER);
        return NULL;
    }

    PCHAR pszOut = new NOTHROW CHAR [cch + 1];
    if (pszOut == NULL) {
        SetLastError(ERROR_OUTOFMEMORY);
        return NULL;
    }

    hr = StringCchCopyA(pszOut, cch + 1, pszIn);
    if (FAILED(hr)) {
        delete[] pszOut;
        return NULL;
    }

    return pszOut;
}

static VOID ReleaseString(_In_opt_ LPCSTR psz)
{
    if (psz != NULL) {
        delete[] psz;
    }
}

//////////////////////////////////////////////////////////////////////////////
//
CImageImportFile::CImageImportFile()
{
    m_pNextFile = NULL;
    m_fByway = FALSE;

    m_pImportNames = NULL;
    m_nImportNames = 0;

    m_rvaOriginalFirstThunk = 0;
    m_rvaFirstThunk = 0;

    m_nForwarderChain = (UINT)0;
    m_pszName = NULL;
    m_pszOrig = NULL;
}

CImageImportFile::~CImageImportFile()
{
    if (m_pNextFile) {
        delete m_pNextFile;
        m_pNextFile = NULL;
    }
    if (m_pImportNames) {
        delete[] m_pImportNames;
        m_pImportNames = NULL;
        m_nImportNames = 0;
    }
    if (m_pszName) {
        delete[] m_pszName;
        m_pszName = NULL;
    }
    if (m_pszOrig) {
        delete[] m_pszOrig;
        m_pszOrig = NULL;
    }
}

CImageImportName::CImageImportName()
{
    m_nOrig = 0;
    m_nOrdinal = 0;
    m_nHint = 0;
    m_pszName = NULL;
    m_pszOrig = NULL;
}

CImageImportName::~CImageImportName()
{
    if (m_pszName) {
        delete[] m_pszName;
        m_pszName = NULL;
    }
    if (m_pszOrig) {
        delete[] m_pszOrig;
        m_pszOrig = NULL;
    }
}

//////////////////////////////////////////////////////////////////////////////
//
CImageData::CImageData(PBYTE pbData, DWORD cbData)
{
    m_pbData = pbData;
    m_cbData = cbData;
    m_cbAlloc = 0;
}

CImageData::~CImageData()
{
    IsValid();

    if (m_cbAlloc == 0) {
        m_pbData = NULL;
    }
    if (m_pbData) {
        delete[] m_pbData;
        m_pbData = NULL;
    }
    m_cbData = 0;
    m_cbAlloc = 0;
}

BOOL CImageData::SizeTo(DWORD cbData)
{
    IsValid();

    if (cbData <= m_cbAlloc) {
        return TRUE;
    }

    PBYTE pbNew = new NOTHROW BYTE [cbData];
    if (pbNew == NULL) {
        SetLastError(ERROR_OUTOFMEMORY);
        return FALSE;
    }

    if (m_pbData) {
        CopyMemory(pbNew, m_pbData, m_cbData);
        if (m_cbAlloc > 0) {
            delete[] m_pbData;
        }
        m_pbData = NULL;
    }
    m_pbData = pbNew;
    m_cbAlloc = cbData;

    IsValid();

    return TRUE;
}

BOOL CImageData::Purge()
{
    m_cbData = 0;

    IsValid();

    return TRUE;
}

BOOL CImageData::IsValid()
{
    if (m_pbData == NULL) {
        return TRUE;
    }

    PBYTE pbBeg = m_pbData;
    PBYTE pbEnd = m_pbData + m_cbData;

    for (PBYTE pbIter = pbBeg; pbIter < pbEnd;) {
        PDETOUR_SECTION_RECORD pRecord = (PDETOUR_SECTION_RECORD)pbIter;

        if (pRecord->cbBytes < sizeof(DETOUR_SECTION_RECORD)) {
            return FALSE;
        }
        if (pRecord->nReserved != 0) {
            return FALSE;
        }

        pbIter += pRecord->cbBytes;
    }
    return TRUE;
}

PBYTE CImageData::Enumerate(GUID *pGuid, DWORD *pcbData, DWORD *pnIterator)
{
    IsValid();

    if (pnIterator == NULL ||
        m_cbData < *pnIterator + sizeof(DETOUR_SECTION_RECORD)) {

        if (pcbData) {
            *pcbData = 0;
        }
        if (pGuid) {
            ZeroMemory(pGuid, sizeof(*pGuid));
        }
        return NULL;
    }

    PDETOUR_SECTION_RECORD pRecord = (PDETOUR_SECTION_RECORD)(m_pbData + *pnIterator);

    if (pGuid) {
        *pGuid = pRecord->guid;
    }
    if (pcbData) {
        *pcbData = pRecord->cbBytes - sizeof(DETOUR_SECTION_RECORD);
    }
    *pnIterator = (LONG)(((PBYTE)pRecord - m_pbData) + pRecord->cbBytes);

    return (PBYTE)(pRecord + 1);
}

PBYTE CImageData::Find(REFGUID rguid, DWORD *pcbData)
{
    IsValid();

    DWORD cbBytes = sizeof(DETOUR_SECTION_RECORD);
    for (DWORD nOffset = 0; nOffset < m_cbData; nOffset += cbBytes) {
        PDETOUR_SECTION_RECORD pRecord = (PDETOUR_SECTION_RECORD)(m_pbData + nOffset);

        cbBytes = pRecord->cbBytes;
        if (cbBytes > m_cbData) {
            break;
        }
        if (cbBytes < sizeof(DETOUR_SECTION_RECORD)) {
            continue;
        }

        if (DetourAreSameGuid(pRecord->guid, rguid)) {
            *pcbData = cbBytes - sizeof(DETOUR_SECTION_RECORD);
            return (PBYTE)(pRecord + 1);
        }
    }

    if (pcbData) {
        *pcbData = 0;
    }
    return NULL;
}

BOOL CImageData::Delete(REFGUID rguid)
{
    IsValid();

    PBYTE pbFound = NULL;
    DWORD cbFound = 0;

    pbFound = Find(rguid, &cbFound);
    if (pbFound == NULL) {
        SetLastError(ERROR_MOD_NOT_FOUND);
        return FALSE;
    }

    pbFound -= sizeof(DETOUR_SECTION_RECORD);
    cbFound += sizeof(DETOUR_SECTION_RECORD);

    PBYTE pbRestData = pbFound + cbFound;
    DWORD cbRestData = m_cbData - (LONG)(pbRestData - m_pbData);

    if (cbRestData) {
        MoveMemory(pbFound, pbRestData, cbRestData);
    }
    m_cbData -= cbFound;

    IsValid();
    return TRUE;
}

PBYTE CImageData::Set(REFGUID rguid, PBYTE pbData, DWORD cbData)
{
    IsValid();
    Delete(rguid);

    DWORD cbAlloc = QuadAlign(cbData);

    if (!SizeTo(m_cbData + cbAlloc + sizeof(DETOUR_SECTION_RECORD))) {
        return NULL;
    }

    PDETOUR_SECTION_RECORD pRecord = (PDETOUR_SECTION_RECORD)(m_pbData + m_cbData);
    pRecord->cbBytes = cbAlloc + sizeof(DETOUR_SECTION_RECORD);
    pRecord->nReserved = 0;
    pRecord->guid = rguid;

    PBYTE pbDest = (PBYTE)(pRecord + 1);
    if (pbData) {
        CopyMemory(pbDest, pbData, cbData);
        if (cbData < cbAlloc) {
            ZeroMemory(pbDest + cbData, cbAlloc - cbData);
        }
    }
    else {
        if (cbAlloc > 0) {
            ZeroMemory(pbDest, cbAlloc);
        }
    }

    m_cbData += cbAlloc + sizeof(DETOUR_SECTION_RECORD);

    IsValid();
    return pbDest;
}

//////////////////////////////////////////////////////////////////////////////
//
class CImageThunks
{
private:
    CImage *            m_pImage;
    PIMAGE_THUNK_DATA   m_pThunks;
    DWORD               m_nThunks;
    DWORD               m_nThunksMax;
    DWORD               m_nThunkVirtAddr;

public:
    CImageThunks(CImage *pImage, DWORD nThunksMax, DWORD *pnAddr)
    {
        m_pImage = pImage;
        m_nThunks = 0;
        m_nThunksMax = nThunksMax;
        m_pThunks = (PIMAGE_THUNK_DATA)
            m_pImage->AllocateOutput(sizeof(IMAGE_THUNK_DATA) * nThunksMax,
                                     &m_nThunkVirtAddr);
        *pnAddr = m_nThunkVirtAddr;
    }

    PIMAGE_THUNK_DATA Current(DWORD *pnVirtAddr)
    {
        if (m_nThunksMax > 1) {
            *pnVirtAddr = m_nThunkVirtAddr;
            return m_pThunks;
        }
        *pnVirtAddr = 0;
        return NULL;
    }

    PIMAGE_THUNK_DATA Allocate(ULONG_PTR nData, DWORD *pnVirtAddr)
    {
        if (m_nThunks < m_nThunksMax) {
            *pnVirtAddr = m_nThunkVirtAddr;

            m_nThunks++;
            m_nThunkVirtAddr += sizeof(IMAGE_THUNK_DATA);
            m_pThunks->u1.Ordinal = nData;
            return m_pThunks++;
        }
        *pnVirtAddr = 0;
        return NULL;
    }

    DWORD   Size()
    {
        return m_nThunksMax * sizeof(IMAGE_THUNK_DATA);
    }
};

//////////////////////////////////////////////////////////////////////////////
//
class CImageChars
{
private:
    CImage *        m_pImage;
    PCHAR           m_pChars;
    DWORD           m_nChars;
    DWORD           m_nCharsMax;
    DWORD           m_nCharVirtAddr;

public:
    CImageChars(CImage *pImage, _In_ DWORD nCharsMax, _Out_ DWORD *pnAddr)
    {
        m_pImage = pImage;
        m_nChars = 0;
        m_nCharsMax = nCharsMax;
        m_pChars = (PCHAR)m_pImage->AllocateOutput(nCharsMax, &m_nCharVirtAddr);
        *pnAddr = m_nCharVirtAddr;
    }

    LPCSTR Allocate(_In_ LPCSTR pszString, _Out_ DWORD *pnVirtAddr)
    {
        DWORD nLen = (DWORD)strlen(pszString) + 1;
        nLen += (nLen & 1);

        if (m_nChars + nLen > m_nCharsMax) {
            *pnVirtAddr = 0;
            return NULL;
        }

        *pnVirtAddr = m_nCharVirtAddr;
        HRESULT hrRet = StringCchCopyA(m_pChars, m_nCharsMax, pszString);

        if (FAILED(hrRet)) {
            return NULL;
        }

        pszString = m_pChars;

        m_pChars += nLen;
        m_nChars += nLen;
        m_nCharVirtAddr += nLen;

        return pszString;
    }

    LPCSTR Allocate(_In_ LPCSTR pszString, _In_ DWORD nHint, _Out_ DWORD *pnVirtAddr)
    {
        DWORD nLen = (DWORD)strlen(pszString) + 1 + sizeof(USHORT);
        nLen += (nLen & 1);

        if (m_nChars + nLen > m_nCharsMax) {
            *pnVirtAddr = 0;
            return NULL;
        }

        *pnVirtAddr = m_nCharVirtAddr;
        *(USHORT *)m_pChars = (USHORT)nHint;

        HRESULT hrRet = StringCchCopyA(m_pChars + sizeof(USHORT), m_nCharsMax, pszString);
        if (FAILED(hrRet)) {
            return NULL;
        }

        pszString = m_pChars + sizeof(USHORT);

        m_pChars += nLen;
        m_nChars += nLen;
        m_nCharVirtAddr += nLen;

        return pszString;
    }

    DWORD Size()
    {
        return m_nChars;
    }
};

//////////////////////////////////////////////////////////////////////////////
//
CImage * CImage::IsValid(PDETOUR_BINARY pBinary)
{
    if (pBinary) {
        CImage *pImage = (CImage *)pBinary;

        if (pImage->m_dwValidSignature == DETOUR_IMAGE_VALID_SIGNATURE) {
            return pImage;
        }
    }
    SetLastError(ERROR_INVALID_HANDLE);
    return NULL;
}

CImage::CImage()
{
    m_dwValidSignature = (DWORD)DETOUR_IMAGE_VALID_SIGNATURE;

    m_hMap = NULL;
    m_pMap = NULL;

    m_nPeOffset = 0;
    m_nSectionsOffset = 0;

    m_pbOutputBuffer = NULL;
    m_cbOutputBuffer = 0;

    m_pImageData = NULL;

    m_pImportFiles = NULL;
    m_nImportFiles = 0;

    m_fHadDetourSection = FALSE;
}

CImage::~CImage()
{
    Close();
    m_dwValidSignature = 0;
}

BOOL CImage::Close()
{
    if (m_pImportFiles) {
        delete m_pImportFiles;
        m_pImportFiles = NULL;
        m_nImportFiles = 0;
    }

    if (m_pImageData) {
        delete m_pImageData;
        m_pImageData = NULL;
    }

    if (m_pMap != NULL) {
        UnmapViewOfFile(m_pMap);
        m_pMap = NULL;
    }

    if (m_hMap) {
        CloseHandle(m_hMap);
        m_hMap = NULL;
    }

    if (m_pbOutputBuffer) {
        delete[] m_pbOutputBuffer;
        m_pbOutputBuffer = NULL;
        m_cbOutputBuffer = 0;
    }
    return TRUE;
}

//////////////////////////////////////////////////////////////////////////////
//
PBYTE CImage::DataEnum(GUID *pGuid, DWORD *pcbData, DWORD *pnIterator)
{
    if (m_pImageData == NULL) {
        return NULL;
    }
    return m_pImageData->Enumerate(pGuid, pcbData, pnIterator);
}

PBYTE CImage::DataFind(REFGUID rguid, DWORD *pcbData)
{
    if (m_pImageData == NULL) {
        return NULL;
    }
    return m_pImageData->Find(rguid, pcbData);
}

PBYTE CImage::DataSet(REFGUID rguid, PBYTE pbData, DWORD cbData)
{
    if (m_pImageData == NULL) {
        return NULL;
    }
    return m_pImageData->Set(rguid, pbData, cbData);
}

BOOL CImage::DataDelete(REFGUID rguid)
{
    if (m_pImageData == NULL) {
        return FALSE;
    }
    return m_pImageData->Delete(rguid);
}

BOOL CImage::DataPurge()
{
    if (m_pImageData == NULL) {
        return TRUE;
    }
    return m_pImageData->Purge();
}

//////////////////////////////////////////////////////////////////////////////
//
BOOL CImage::SizeOutputBuffer(DWORD cbData)
{
    if (m_cbOutputBuffer < cbData) {
        if (cbData < 1024) {//65536
            cbData = 1024;
        }
        cbData = FileAlign(cbData);

        PBYTE pOutput = new NOTHROW BYTE [cbData];
        if (pOutput == NULL) {
            SetLastError(ERROR_OUTOFMEMORY);
            return FALSE;
        }

        if (m_pbOutputBuffer) {
            CopyMemory(pOutput, m_pbOutputBuffer, m_cbOutputBuffer);

            delete[] m_pbOutputBuffer;
            m_pbOutputBuffer = NULL;
        }

        ZeroMemory(pOutput + m_cbOutputBuffer, cbData - m_cbOutputBuffer),

        m_pbOutputBuffer = pOutput;
        m_cbOutputBuffer = cbData;
    }
    return TRUE;
}

PBYTE CImage::AllocateOutput(DWORD cbData, DWORD *pnVirtAddr)
{
    cbData = QuadAlign(cbData);

    PBYTE pbData = m_pbOutputBuffer + m_nOutputVirtSize;

    *pnVirtAddr = m_nOutputVirtAddr + m_nOutputVirtSize;
    m_nOutputVirtSize += cbData;

    if (m_nOutputVirtSize > m_cbOutputBuffer) {
        SetLastError(ERROR_OUTOFMEMORY);
        return NULL;
    }

    ZeroMemory(pbData, cbData);

    return pbData;
}

//////////////////////////////////////////////////////////////////////////////
//
DWORD CImage::FileAlign(DWORD nAddr)
{
    return Align(nAddr, m_NtHeader.OptionalHeader.FileAlignment);
}

DWORD CImage::SectionAlign(DWORD nAddr)
{
    return Align(nAddr, m_NtHeader.OptionalHeader.SectionAlignment);
}

//////////////////////////////////////////////////////////////////////////////
//
PVOID CImage::RvaToVa(ULONG_PTR nRva)
{
    if (nRva == 0) {
        return NULL;
    }

    for (DWORD n = 0; n < m_NtHeader.FileHeader.NumberOfSections; n++) {
        DWORD vaStart = m_SectionHeaders[n].VirtualAddress;
        DWORD vaEnd = vaStart + m_SectionHeaders[n].SizeOfRawData;

        if (nRva >= vaStart && nRva < vaEnd) {
            return (PBYTE)m_pMap
                + m_SectionHeaders[n].PointerToRawData
                + nRva - m_SectionHeaders[n].VirtualAddress;
        }
    }
    return NULL;
}

DWORD CImage::RvaToFileOffset(DWORD nRva)
{
    DWORD n;
    for (n = 0; n < m_NtHeader.FileHeader.NumberOfSections; n++) {
        DWORD vaStart = m_SectionHeaders[n].VirtualAddress;
        DWORD vaEnd = vaStart + m_SectionHeaders[n].SizeOfRawData;

        if (nRva >= vaStart && nRva < vaEnd) {
            return m_SectionHeaders[n].PointerToRawData
                + nRva - m_SectionHeaders[n].VirtualAddress;
        }
    }
    return 0;
}

//////////////////////////////////////////////////////////////////////////////
//
BOOL CImage::WriteFile(HANDLE hFile, LPCVOID lpBuffer, DWORD nNumberOfBytesToWrite,
                       LPDWORD lpNumberOfBytesWritten)
{
    return ::WriteFile(hFile,
                       lpBuffer,
                       nNumberOfBytesToWrite,
                       lpNumberOfBytesWritten,
                       NULL);
}


BOOL CImage::CopyFileData(HANDLE hFile, DWORD nOldPos, DWORD cbData)
{
    DWORD cbDone = 0;
    return WriteFile(hFile, m_pMap + nOldPos, cbData, &cbDone);
}

BOOL CImage::ZeroFileData(HANDLE hFile, DWORD cbData)
{
    if (!SizeOutputBuffer(4096)) {
        return FALSE;
    }

    ZeroMemory(m_pbOutputBuffer, 4096);

    for (DWORD cbLeft = cbData; cbLeft > 0;) {
        DWORD cbStep = cbLeft > sizeof(m_pbOutputBuffer)
            ? sizeof(m_pbOutputBuffer) : cbLeft;
        DWORD cbDone = 0;

        if (!WriteFile(hFile, m_pbOutputBuffer, cbStep, &cbDone)) {
            return FALSE;
        }
        if (cbDone == 0) {
            break;
        }

        cbLeft -= cbDone;
    }
    return TRUE;
}

BOOL CImage::AlignFileData(HANDLE hFile)
{
    DWORD nLastFileAddr = m_nNextFileAddr;

    m_nNextFileAddr = FileAlign(m_nNextFileAddr);
    m_nNextVirtAddr = SectionAlign(m_nNextVirtAddr);

    if (hFile != INVALID_HANDLE_VALUE) {
        if (m_nNextFileAddr > nLastFileAddr) {
            if (SetFilePointer(hFile, nLastFileAddr, NULL, FILE_BEGIN) == ~0u) {
                return FALSE;
            }
            return ZeroFileData(hFile, m_nNextFileAddr - nLastFileAddr);
        }
    }
    return TRUE;
}

BOOL CImage::Read(HANDLE hFile)
{
    DWORD n;
    PBYTE pbData = NULL;
    DWORD cbData = 0;

    if (hFile == INVALID_HANDLE_VALUE) {
        SetLastError(ERROR_INVALID_HANDLE);
        return FALSE;
    }

    ///////////////////////////////////////////////////////// Create mapping.
    //
    m_nFileSize = GetFileSize(hFile, NULL);
    if (m_nFileSize == (DWORD)-1) {
        return FALSE;
    }

    m_hMap = CreateFileMappingW(hFile, NULL, PAGE_READONLY, 0, 0, NULL);
    if (m_hMap == NULL) {
        return FALSE;
    }

    m_pMap = (PBYTE)MapViewOfFileEx(m_hMap, FILE_MAP_READ, 0, 0, 0, NULL);
    if (m_pMap == NULL) {
        return FALSE;
    }

    ////////////////////////////////////////////////////// Process DOS Header.
    //
    PIMAGE_DOS_HEADER pDosHeader = (PIMAGE_DOS_HEADER)m_pMap;
    if (pDosHeader->e_magic != IMAGE_DOS_SIGNATURE) {
        SetLastError(ERROR_BAD_EXE_FORMAT);
        return FALSE;
    }
    m_nPeOffset = pDosHeader->e_lfanew;
    m_nPrePE = 0;
    m_cbPrePE = QuadAlign(pDosHeader->e_lfanew);

    if (m_nPeOffset > m_nFileSize ||
        m_nPeOffset + sizeof(m_NtHeader) > m_nFileSize) {

        SetLastError(ERROR_BAD_EXE_FORMAT);
        return FALSE;
    }

    CopyMemory(&m_DosHeader, m_pMap + m_nPrePE, sizeof(m_DosHeader));

    /////////////////////////////////////////////////////// Process PE Header.
    //
    CopyMemory(&m_NtHeader, m_pMap + m_nPeOffset, sizeof(m_NtHeader));
    if (m_NtHeader.Signature != IMAGE_NT_SIGNATURE) {
        SetLastError(ERROR_INVALID_EXE_SIGNATURE);
        return FALSE;
    }
    if (m_NtHeader.FileHeader.SizeOfOptionalHeader == 0) {
        SetLastError(ERROR_EXE_MARKED_INVALID);
        return FALSE;
    }
    m_nSectionsOffset = m_nPeOffset
        + sizeof(m_NtHeader.Signature)
        + sizeof(m_NtHeader.FileHeader)
        + m_NtHeader.FileHeader.SizeOfOptionalHeader;

    ///////////////////////////////////////////////// Process Section Headers.
    //
    if (m_NtHeader.FileHeader.NumberOfSections > ARRAYSIZE(m_SectionHeaders)) {
        SetLastError(ERROR_EXE_MARKED_INVALID);
        return FALSE;
    }
    CopyMemory(&m_SectionHeaders,
               m_pMap + m_nSectionsOffset,
               sizeof(m_SectionHeaders[0]) * m_NtHeader.FileHeader.NumberOfSections);

    /////////////////////////////////////////////////// Parse .detour Section.
    //
    DWORD rvaOriginalImageDirectory = 0;
    DWORD rvaDetourBeg = 0;
    DWORD rvaDetourEnd = 0;

    _Analysis_assume_(m_NtHeader.FileHeader.NumberOfSections <= ARRAYSIZE(m_SectionHeaders));

    for (n = 0; n < m_NtHeader.FileHeader.NumberOfSections; n++) {
        if (strcmp((PCHAR)m_SectionHeaders[n].Name, ".detour") == 0) {
            DETOUR_SECTION_HEADER dh;
            CopyMemory(&dh,
                       m_pMap + m_SectionHeaders[n].PointerToRawData,
                       sizeof(dh));

            rvaOriginalImageDirectory = dh.nOriginalImportVirtualAddress;
            if (dh.cbPrePE != 0) {
                m_nPrePE = m_SectionHeaders[n].PointerToRawData + sizeof(dh);
                m_cbPrePE = dh.cbPrePE;
            }
            rvaDetourBeg = m_SectionHeaders[n].VirtualAddress;
            rvaDetourEnd = rvaDetourBeg + m_SectionHeaders[n].SizeOfRawData;
        }
    }

    //////////////////////////////////////////////////////// Get Import Table.
    //
    DWORD rvaImageDirectory = m_NtHeader.OptionalHeader
        .DataDirectory[IMAGE_DIRECTORY_ENTRY_IMPORT].VirtualAddress;
    PIMAGE_IMPORT_DESCRIPTOR iidp
        = (PIMAGE_IMPORT_DESCRIPTOR)RvaToVa(rvaImageDirectory);
    PIMAGE_IMPORT_DESCRIPTOR oidp
        = (PIMAGE_IMPORT_DESCRIPTOR)RvaToVa(rvaOriginalImageDirectory);

    if (oidp == NULL) {
        oidp = iidp;
    }
    if (iidp == NULL || oidp == NULL) {
        SetLastError(ERROR_EXE_MARKED_INVALID);
        return FALSE;
    }

    DWORD nFiles = 0;
    for (; iidp[nFiles].OriginalFirstThunk != 0 || iidp[nFiles].FirstThunk != 0; nFiles++) {
    }

    CImageImportFile **ppLastFile = &m_pImportFiles;
    m_pImportFiles = NULL;

    for (n = 0; n < nFiles; n++, iidp++) {
        ULONG_PTR rvaName = iidp->Name;
        PCHAR pszName = (PCHAR)RvaToVa(rvaName);
        if (pszName == NULL) {
            SetLastError(ERROR_EXE_MARKED_INVALID);
            goto fail;
        }

        CImageImportFile *pImportFile = new NOTHROW CImageImportFile;
        if (pImportFile == NULL) {
            SetLastError(ERROR_OUTOFMEMORY);
            goto fail;
        }

        *ppLastFile = pImportFile;
        ppLastFile = &pImportFile->m_pNextFile;
        m_nImportFiles++;

        pImportFile->m_pszName = DuplicateString(pszName);
        if (pImportFile->m_pszName == NULL) {
            goto fail;
        }

        pImportFile->m_rvaOriginalFirstThunk = iidp->OriginalFirstThunk;
        pImportFile->m_rvaFirstThunk = iidp->FirstThunk;
        pImportFile->m_nForwarderChain = iidp->ForwarderChain;
        pImportFile->m_pImportNames = NULL;
        pImportFile->m_nImportNames = 0;
        pImportFile->m_fByway = FALSE;

        if ((ULONG)iidp->FirstThunk >= rvaDetourBeg &&
            (ULONG)iidp->FirstThunk < rvaDetourEnd) {

            pImportFile->m_pszOrig = NULL;
            pImportFile->m_fByway = TRUE;
            continue;
        }

        rvaName = oidp->Name;
        pszName = (PCHAR)RvaToVa(rvaName);
        if (pszName == NULL) {
            SetLastError(ERROR_EXE_MARKED_INVALID);
            goto fail;
        }
        pImportFile->m_pszOrig = DuplicateString(pszName);
        if (pImportFile->m_pszOrig == NULL) {
            goto fail;
        }

        DWORD rvaThunk = iidp->OriginalFirstThunk;
        if( !rvaThunk ) {
            rvaThunk = iidp->FirstThunk;
        }
        PIMAGE_THUNK_DATA pAddrThunk = (PIMAGE_THUNK_DATA)RvaToVa(rvaThunk);
        rvaThunk = oidp->OriginalFirstThunk;
        if( !rvaThunk ) {
            rvaThunk = oidp->FirstThunk;
        }
        PIMAGE_THUNK_DATA pLookThunk = (PIMAGE_THUNK_DATA)RvaToVa(rvaThunk);

        DWORD nNames = 0;
        if (pAddrThunk) {
            for (; pAddrThunk[nNames].u1.Ordinal; nNames++) {
            }
        }

        if (pAddrThunk && nNames) {
            pImportFile->m_nImportNames = nNames;
            pImportFile->m_pImportNames = new NOTHROW CImageImportName [nNames];
            if (pImportFile->m_pImportNames == NULL) {
                SetLastError(ERROR_OUTOFMEMORY);
                goto fail;
            }

            CImageImportName *pImportName = &pImportFile->m_pImportNames[0];

            for (DWORD f = 0; f < nNames; f++, pImportName++) {
                pImportName->m_nOrig = 0;
                pImportName->m_nOrdinal = 0;
                pImportName->m_nHint = 0;
                pImportName->m_pszName = NULL;
                pImportName->m_pszOrig = NULL;

                rvaName = pAddrThunk[f].u1.Ordinal;
                if (rvaName & IMAGE_ORDINAL_FLAG) {
                    pImportName->m_nOrig = (ULONG)IMAGE_ORDINAL(rvaName);
                    pImportName->m_nOrdinal = pImportName->m_nOrig;
                }
                else {
                    PIMAGE_IMPORT_BY_NAME pName
                        = (PIMAGE_IMPORT_BY_NAME)RvaToVa(rvaName);
                    if (pName) {
                        pImportName->m_nHint = pName->Hint;
                        pImportName->m_pszName = DuplicateString((PCHAR)pName->Name);
                        if (pImportName->m_pszName == NULL) {
                            goto fail;
                        }
                    }

                    rvaName = pLookThunk[f].u1.Ordinal;
                    if (rvaName & IMAGE_ORDINAL_FLAG) {
                        pImportName->m_nOrig = (ULONG)IMAGE_ORDINAL(rvaName);
                        pImportName->m_nOrdinal = (ULONG)IMAGE_ORDINAL(rvaName);
                    }
                    else {
                        pName = (PIMAGE_IMPORT_BY_NAME)RvaToVa(rvaName);
                        if (pName) {
                            pImportName->m_pszOrig
                                = DuplicateString((PCHAR)pName->Name);
                            if (pImportName->m_pszOrig == NULL) {
                                goto fail;
                            }
                        }
                    }
                }
            }
        }
        oidp++;
    }

    ////////////////////////////////////////////////////////// Parse Sections.
    //
    m_nExtraOffset = 0;
    for (n = 0; n < m_NtHeader.FileHeader.NumberOfSections; n++) {
        m_nExtraOffset = Max(m_SectionHeaders[n].PointerToRawData +
                             m_SectionHeaders[n].SizeOfRawData,
                             m_nExtraOffset);

        if (strcmp((PCHAR)m_SectionHeaders[n].Name, ".detour") == 0) {
            DETOUR_SECTION_HEADER dh;
            CopyMemory(&dh,
                       m_pMap + m_SectionHeaders[n].PointerToRawData,
                       sizeof(dh));

            if (dh.nDataOffset == 0) {
                dh.nDataOffset = dh.cbHeaderSize;
            }

            cbData = dh.cbDataSize - dh.nDataOffset;
            pbData = (m_pMap +
                      m_SectionHeaders[n].PointerToRawData +
                      dh.nDataOffset);

            m_nExtraOffset = Max(m_SectionHeaders[n].PointerToRawData +
                                 m_SectionHeaders[n].SizeOfRawData,
                                 m_nExtraOffset);

            m_NtHeader.FileHeader.NumberOfSections--;

            m_NtHeader.OptionalHeader
                .DataDirectory[IMAGE_DIRECTORY_ENTRY_IMPORT].VirtualAddress
                = dh.nOriginalImportVirtualAddress;
            m_NtHeader.OptionalHeader
                .DataDirectory[IMAGE_DIRECTORY_ENTRY_IMPORT].Size
                = dh.nOriginalImportSize;

            m_NtHeader.OptionalHeader
                .DataDirectory[IMAGE_DIRECTORY_ENTRY_BOUND_IMPORT].VirtualAddress
                = dh.nOriginalBoundImportVirtualAddress;
            m_NtHeader.OptionalHeader
                .DataDirectory[IMAGE_DIRECTORY_ENTRY_BOUND_IMPORT].Size
                = dh.nOriginalBoundImportSize;

            m_NtHeader.OptionalHeader
                .DataDirectory[IMAGE_DIRECTORY_ENTRY_IAT].VirtualAddress
                = dh.nOriginalIatVirtualAddress;
            m_NtHeader.OptionalHeader
                .DataDirectory[IMAGE_DIRECTORY_ENTRY_IAT].Size
                = dh.nOriginalIatSize;

            m_NtHeader.OptionalHeader.CheckSum = 0;
            m_NtHeader.OptionalHeader.SizeOfImage
                = dh.nOriginalSizeOfImage;

            m_fHadDetourSection = TRUE;
        }
    }

    m_pImageData = new NOTHROW CImageData(pbData, cbData);
    if (m_pImageData == NULL) {
        SetLastError(ERROR_OUTOFMEMORY);
    }
    return TRUE;

fail:
    return FALSE;
}

static inline BOOL strneq(_In_ LPCSTR pszOne, _In_ LPCSTR pszTwo)
{
    if (pszOne == pszTwo) {
        return FALSE;
    }
    if (!pszOne || !pszTwo) {
        return TRUE;
    }
    return (strcmp(pszOne, pszTwo) != 0);
}

BOOL CImage::CheckImportsNeeded(DWORD *pnTables, DWORD *pnThunks, DWORD *pnChars)
{
    DWORD nTables = 0;
    DWORD nThunks = 0;
    DWORD nChars = 0;
    BOOL fNeedDetourSection = FALSE;

    for (CImageImportFile *pImportFile = m_pImportFiles;
         pImportFile != NULL; pImportFile = pImportFile->m_pNextFile) {

        nChars += (int)strlen(pImportFile->m_pszName) + 1;
        nChars += nChars & 1;

        if (pImportFile->m_fByway) {
            fNeedDetourSection = TRUE;
            nThunks++;
        }
        else {
            if (!fNeedDetourSection &&
                strneq(pImportFile->m_pszName, pImportFile->m_pszOrig)) {

                fNeedDetourSection = TRUE;
            }
            for (DWORD n = 0; n < pImportFile->m_nImportNames; n++) {
                CImageImportName *pImportName = &pImportFile->m_pImportNames[n];

                if (!fNeedDetourSection &&
                    strneq(pImportName->m_pszName, pImportName->m_pszOrig)) {

                    fNeedDetourSection = TRUE;
                }

                if (pImportName->m_pszName) {
                    nChars += sizeof(WORD);             // Hint
                    nChars += (int)strlen(pImportName->m_pszName) + 1;
                    nChars += nChars & 1;
                }
                nThunks++;
            }
        }
        nThunks++;
        nTables++;
    }
    nTables++;

    *pnTables = nTables;
    *pnThunks = nThunks;
    *pnChars = nChars;

    return fNeedDetourSection;
}

//////////////////////////////////////////////////////////////////////////////
//
CImageImportFile * CImage::NewByway(_In_ LPCSTR pszName)
{
    CImageImportFile *pImportFile = new NOTHROW CImageImportFile;
    if (pImportFile == NULL) {
        SetLastError(ERROR_OUTOFMEMORY);
        goto fail;
    }

    pImportFile->m_pNextFile = NULL;
    pImportFile->m_fByway = TRUE;

    pImportFile->m_pszName = DuplicateString(pszName);
    if (pImportFile->m_pszName == NULL) {
        goto fail;
    }

    pImportFile->m_rvaOriginalFirstThunk = 0;
    pImportFile->m_rvaFirstThunk = 0;
    pImportFile->m_nForwarderChain = (UINT)0;
    pImportFile->m_pImportNames = NULL;
    pImportFile->m_nImportNames = 0;

    m_nImportFiles++;
    return pImportFile;

fail:
    if (pImportFile) {
        delete pImportFile;
        pImportFile = NULL;
    }
    return NULL;
}

BOOL CImage::EditImports(PVOID pContext,
                         PF_DETOUR_BINARY_BYWAY_CALLBACK pfBywayCallback,
                         PF_DETOUR_BINARY_FILE_CALLBACK pfFileCallback,
                         PF_DETOUR_BINARY_SYMBOL_CALLBACK pfSymbolCallback,
                         PF_DETOUR_BINARY_COMMIT_CALLBACK pfCommitCallback)
{
    CImageImportFile *pImportFile = NULL;
    CImageImportFile **ppLastFile = &m_pImportFiles;

    SetLastError(ERROR_CALL_NOT_IMPLEMENTED);

    while ((pImportFile = *ppLastFile) != NULL) {

        if (pfBywayCallback != NULL) {
            LPCSTR pszFile = NULL;
            if (!(*pfBywayCallback)(pContext, NULL, &pszFile)) {
                goto fail;
            }

            if (pszFile != NULL) {
                // Insert a new Byway.
                CImageImportFile *pByway = NewByway(pszFile);
                if (pByway == NULL) {
                    return FALSE;
                }

                pByway->m_pNextFile = pImportFile;
                *ppLastFile = pByway;
                ppLastFile = &pByway->m_pNextFile;
                continue;                               // Retry after Byway.
            }
        }

        if (pImportFile->m_fByway) {
            if (pfBywayCallback != NULL) {
                LPCSTR pszFile = NULL;

                if (!(*pfBywayCallback)(pContext, pImportFile->m_pszName, &pszFile)) {
                    goto fail;
                }

                if (pszFile != NULL) {
                    // Replace? Byway
                    if (pszFile != pImportFile->m_pszName) {
                        LPCSTR pszLast = pImportFile->m_pszName;
                        pImportFile->m_pszName = DuplicateString(pszFile);
                        ReleaseString(pszLast);

                        if (pImportFile->m_pszName == NULL) {
                            goto fail;
                        }
                    }
                }
                else {                                  // Delete Byway
                    *ppLastFile = pImportFile->m_pNextFile;
                    pImportFile->m_pNextFile = NULL;
                    delete pImportFile;
                    m_nImportFiles--;
                    continue;                           // Retry after delete.
                }
            }
        }
        else {
            if (pfFileCallback != NULL) {
                LPCSTR pszFile = NULL;

                if (!(*pfFileCallback)(pContext,
                                       pImportFile->m_pszOrig,
                                       pImportFile->m_pszName,
                                       &pszFile)) {
                    goto fail;
                }

                if (pszFile != NULL) {
                    if (pszFile != pImportFile->m_pszName) {
                        LPCSTR pszLast = pImportFile->m_pszName;
                        pImportFile->m_pszName = DuplicateString(pszFile);
                        ReleaseString(pszLast);

                        if (pImportFile->m_pszName == NULL) {
                            goto fail;
                        }
                    }
                }
            }

            if (pfSymbolCallback != NULL) {
                for (DWORD n = 0; n < pImportFile->m_nImportNames; n++) {
                    CImageImportName *pImportName = &pImportFile->m_pImportNames[n];

                    LPCSTR pszName = NULL;
                    ULONG nOrdinal = 0;
                    if (!(*pfSymbolCallback)(pContext,
                                             pImportName->m_nOrig,
                                             pImportName->m_nOrdinal,
                                             &nOrdinal,
                                             pImportName->m_pszOrig,
                                             pImportName->m_pszName,
                                             &pszName)) {
                        goto fail;
                    }

                    if (pszName != NULL) {
                        if (pszName != pImportName->m_pszName) {
                            pImportName->m_nOrdinal = 0;

                            LPCSTR pszLast = pImportName->m_pszName;
                            pImportName->m_pszName = DuplicateString(pszName);
                            ReleaseString(pszLast);

                            if (pImportName->m_pszName == NULL) {
                                goto fail;
                            }
                        }
                    }
                    else if (nOrdinal != 0) {
                        pImportName->m_nOrdinal = nOrdinal;

                        if (pImportName->m_pszName != NULL) {
                            delete[] pImportName->m_pszName;
                            pImportName->m_pszName = NULL;
                        }
                    }
                }
            }
        }

        ppLastFile = &pImportFile->m_pNextFile;
        pImportFile = pImportFile->m_pNextFile;
    }

    for (;;) {
        if (pfBywayCallback != NULL) {
            LPCSTR pszFile = NULL;
            if (!(*pfBywayCallback)(pContext, NULL, &pszFile)) {
                goto fail;
            }
            if (pszFile != NULL) {
                // Insert a new Byway.
                CImageImportFile *pByway = NewByway(pszFile);
                if (pByway == NULL) {
                    return FALSE;
                }

                pByway->m_pNextFile = pImportFile;
                *ppLastFile = pByway;
                ppLastFile = &pByway->m_pNextFile;
                continue;                               // Retry after Byway.
            }
        }
        break;
    }

    if (pfCommitCallback != NULL) {
        if (!(*pfCommitCallback)(pContext)) {
            goto fail;
        }
    }

    SetLastError(NO_ERROR);
    return TRUE;

  fail:
    return FALSE;
}

BOOL CImage::Write(HANDLE hFile)
{
    DWORD cbDone;

    if (hFile == INVALID_HANDLE_VALUE) {
        SetLastError(ERROR_INVALID_HANDLE);
        return FALSE;
    }

    m_nNextFileAddr = 0;
    m_nNextVirtAddr = 0;

    DWORD nTables = 0;
    DWORD nThunks = 0;
    DWORD nChars = 0;
    BOOL fNeedDetourSection = CheckImportsNeeded(&nTables, &nThunks, &nChars);

    //////////////////////////////////////////////////////////// Copy Headers.
    //
    if (SetFilePointer(hFile, 0, NULL, FILE_BEGIN) == ~0u) {
        return FALSE;
    }
    if (!CopyFileData(hFile, 0, m_NtHeader.OptionalHeader.SizeOfHeaders)) {
        return FALSE;
    }

    if (fNeedDetourSection || !m_pImageData->IsEmpty()) {
        // Replace the file's DOS header with our own.
        m_nPeOffset = sizeof(m_DosHeader) + sizeof(s_rbDosCode);
        m_nSectionsOffset = m_nPeOffset
            + sizeof(m_NtHeader.Signature)
            + sizeof(m_NtHeader.FileHeader)
            + m_NtHeader.FileHeader.SizeOfOptionalHeader;
        m_DosHeader.e_lfanew = m_nPeOffset;

        if (SetFilePointer(hFile, 0, NULL, FILE_BEGIN) == ~0u) {
            return FALSE;
        }
        if (!WriteFile(hFile, &m_DosHeader, sizeof(m_DosHeader), &cbDone)) {
            return FALSE;
        }
        if (!WriteFile(hFile, &s_rbDosCode, sizeof(s_rbDosCode), &cbDone)) {
            return FALSE;
        }
    }
    else {
        // Restore the file's original DOS header.
        if (m_nPrePE != 0) {
            m_nPeOffset = m_cbPrePE;
            m_nSectionsOffset = m_nPeOffset
                + sizeof(m_NtHeader.Signature)
                + sizeof(m_NtHeader.FileHeader)
                + m_NtHeader.FileHeader.SizeOfOptionalHeader;
            m_DosHeader.e_lfanew = m_nPeOffset;


            if (SetFilePointer(hFile, 0, NULL, FILE_BEGIN) == ~0u) {
                return FALSE;
            }
            if (!CopyFileData(hFile, m_nPrePE, m_cbPrePE)) {
                return FALSE;
            }
        }
    }

    m_nNextFileAddr = m_NtHeader.OptionalHeader.SizeOfHeaders;
    m_nNextVirtAddr = 0;
    if (!AlignFileData(hFile)) {
        return FALSE;
    }

    /////////////////////////////////////////////////////////// Copy Sections.
    //
    DWORD n = 0;
    for (; n < m_NtHeader.FileHeader.NumberOfSections; n++) {
        if (m_SectionHeaders[n].SizeOfRawData) {
            if (SetFilePointer(hFile,
                               m_SectionHeaders[n].PointerToRawData,
                               NULL, FILE_BEGIN) == ~0u) {
                return FALSE;
            }
            if (!CopyFileData(hFile,
                              m_SectionHeaders[n].PointerToRawData,
                              m_SectionHeaders[n].SizeOfRawData)) {
                return FALSE;
            }
        }
        m_nNextFileAddr = Max(m_SectionHeaders[n].PointerToRawData +
                              m_SectionHeaders[n].SizeOfRawData,
                              m_nNextFileAddr);
        // Old images have VirtualSize == 0 as a matter of course, e.g. NT 3.1.
        // In which case, use SizeOfRawData instead.
        m_nNextVirtAddr = Max(m_SectionHeaders[n].VirtualAddress +
                              (m_SectionHeaders[n].Misc.VirtualSize
                               ? m_SectionHeaders[n].Misc.VirtualSize
                               : SectionAlign(m_SectionHeaders[n].SizeOfRawData)),
                              m_nNextVirtAddr);

        m_nExtraOffset = Max(m_nNextFileAddr, m_nExtraOffset);

        if (!AlignFileData(hFile)) {
            return FALSE;
        }
    }

    if (fNeedDetourSection || !m_pImageData->IsEmpty()) {

        if (m_NtHeader.FileHeader.NumberOfSections >= ARRAYSIZE(m_SectionHeaders)) {
            SetLastError(ERROR_EXE_MARKED_INVALID);
            return FALSE;
        }

        ////////////////////////////////////////////// Insert .detour Section.
        //
        DWORD nSection = m_NtHeader.FileHeader.NumberOfSections++;
        DETOUR_SECTION_HEADER dh;

        ZeroMemory(&dh, sizeof(dh));
        ZeroMemory(&m_SectionHeaders[nSection], sizeof(m_SectionHeaders[nSection]));

        dh.cbHeaderSize = sizeof(DETOUR_SECTION_HEADER);
        dh.nSignature = DETOUR_SECTION_HEADER_SIGNATURE;

        dh.nOriginalImportVirtualAddress = m_NtHeader.OptionalHeader
            .DataDirectory[IMAGE_DIRECTORY_ENTRY_IMPORT].VirtualAddress;
        dh.nOriginalImportSize = m_NtHeader.OptionalHeader
            .DataDirectory[IMAGE_DIRECTORY_ENTRY_IMPORT].Size;

        dh.nOriginalBoundImportVirtualAddress
            = m_NtHeader.OptionalHeader
            .DataDirectory[IMAGE_DIRECTORY_ENTRY_BOUND_IMPORT].VirtualAddress;
        dh.nOriginalBoundImportSize = m_NtHeader.OptionalHeader
            .DataDirectory[IMAGE_DIRECTORY_ENTRY_BOUND_IMPORT].Size;

        dh.nOriginalIatVirtualAddress = m_NtHeader.OptionalHeader
            .DataDirectory[IMAGE_DIRECTORY_ENTRY_IAT].VirtualAddress;
        dh.nOriginalIatSize = m_NtHeader.OptionalHeader
            .DataDirectory[IMAGE_DIRECTORY_ENTRY_IAT].Size;

        dh.nOriginalSizeOfImage = m_NtHeader.OptionalHeader.SizeOfImage;

        DWORD clrAddr = m_NtHeader.OptionalHeader
            .DataDirectory[IMAGE_DIRECTORY_ENTRY_COM_DESCRIPTOR].VirtualAddress;
        DWORD clrSize = m_NtHeader.OptionalHeader
            .DataDirectory[IMAGE_DIRECTORY_ENTRY_COM_DESCRIPTOR].Size;
        if (clrAddr && clrSize) {
            PDETOUR_CLR_HEADER pHdr = (PDETOUR_CLR_HEADER)RvaToVa(clrAddr);
            if (pHdr != NULL) {
                DETOUR_CLR_HEADER hdr;
                hdr = *pHdr;

                dh.nOriginalClrFlags = hdr.Flags;
            }
        }

        HRESULT hrRet = StringCchCopyA((PCHAR)m_SectionHeaders[nSection].Name, IMAGE_SIZEOF_SHORT_NAME , ".detour");
        if (FAILED(hrRet))
            return FALSE;

        m_SectionHeaders[nSection].Characteristics
            = IMAGE_SCN_CNT_INITIALIZED_DATA | IMAGE_SCN_MEM_READ | IMAGE_SCN_MEM_WRITE;

        m_nOutputVirtAddr = m_nNextVirtAddr;
        m_nOutputVirtSize = 0;
        m_nOutputFileAddr = m_nNextFileAddr;

        dh.nDataOffset = 0;                     // pbData
        dh.cbDataSize = m_pImageData->m_cbData;
        dh.cbPrePE = m_cbPrePE;

        //////////////////////////////////////////////////////////////////////////
        //

        DWORD rvaImportTable = 0;
        DWORD rvaLookupTable = 0;
        DWORD rvaBoundTable = 0;
        DWORD rvaNameTable = 0;
        DWORD nImportTableSize = nTables * sizeof(IMAGE_IMPORT_DESCRIPTOR);

        if (!SizeOutputBuffer(QuadAlign(sizeof(dh))
                              + m_cbPrePE
                              + QuadAlign(m_pImageData->m_cbData)
                              + QuadAlign(sizeof(IMAGE_THUNK_DATA) * nThunks)
                              + QuadAlign(sizeof(IMAGE_THUNK_DATA) * nThunks)
                              + QuadAlign(nChars)
                              + QuadAlign(nImportTableSize))) {
            return FALSE;
        }

        DWORD vaHead = 0;
        PBYTE pbHead = NULL;
        DWORD vaPrePE = 0;
        PBYTE pbPrePE = NULL;
        DWORD vaData = 0;
        PBYTE pbData = NULL;

        if ((pbHead = AllocateOutput(sizeof(dh), &vaHead)) == NULL) {
            return FALSE;
        }

        if ((pbPrePE = AllocateOutput(m_cbPrePE, &vaPrePE)) == NULL) {
            return FALSE;
        }

        CImageThunks lookupTable(this, nThunks, &rvaLookupTable);
        CImageThunks boundTable(this, nThunks, &rvaBoundTable);
        CImageChars nameTable(this, nChars, &rvaNameTable);

        if ((pbData = AllocateOutput(m_pImageData->m_cbData, &vaData)) == NULL) {
            return FALSE;
        }

        dh.nDataOffset = vaData - vaHead;
        dh.cbDataSize = dh.nDataOffset + m_pImageData->m_cbData;
        CopyMemory(pbHead, &dh, sizeof(dh));
        CopyMemory(pbPrePE, m_pMap + m_nPrePE, m_cbPrePE);
        CopyMemory(pbData, m_pImageData->m_pbData, m_pImageData->m_cbData);

        PIMAGE_IMPORT_DESCRIPTOR piidDst = (PIMAGE_IMPORT_DESCRIPTOR)
            AllocateOutput(nImportTableSize, &rvaImportTable);
        if (piidDst == NULL) {
            return FALSE;
        }

        //////////////////////////////////////////////// Step Through Imports.
        //
        for (CImageImportFile *pImportFile = m_pImportFiles;
             pImportFile != NULL; pImportFile = pImportFile->m_pNextFile) {

            ZeroMemory(piidDst, sizeof(*piidDst));
            nameTable.Allocate(pImportFile->m_pszName, (DWORD *)&piidDst->Name);
            piidDst->TimeDateStamp = 0;
            piidDst->ForwarderChain = pImportFile->m_nForwarderChain;

            if (pImportFile->m_fByway) {
                ULONG rvaIgnored;

                lookupTable.Allocate(IMAGE_ORDINAL_FLAG+1,
                                     (DWORD *)&piidDst->OriginalFirstThunk);
                boundTable.Allocate(IMAGE_ORDINAL_FLAG+1,
                                    (DWORD *)&piidDst->FirstThunk);

                lookupTable.Allocate(0, &rvaIgnored);
                boundTable.Allocate(0, &rvaIgnored);
            }
            else {
                ULONG rvaIgnored;

                piidDst->FirstThunk = (ULONG)pImportFile->m_rvaFirstThunk;
                lookupTable.Current((DWORD *)&piidDst->OriginalFirstThunk);

                for (n = 0; n < pImportFile->m_nImportNames; n++) {
                    CImageImportName *pImportName = &pImportFile->m_pImportNames[n];

                    if (pImportName->m_pszName) {
                        ULONG nDstName = 0;

                        nameTable.Allocate(pImportName->m_pszName,
                                           pImportName->m_nHint,
                                           &nDstName);
                        lookupTable.Allocate(nDstName, &rvaIgnored);
                    }
                    else {
                        lookupTable.Allocate(IMAGE_ORDINAL_FLAG + pImportName->m_nOrdinal,
                                             &rvaIgnored);
                    }
                }
                lookupTable.Allocate(0, &rvaIgnored);
            }
            piidDst++;
        }
        ZeroMemory(piidDst, sizeof(*piidDst));

        //////////////////////////////////////////////////////////////////////////
        //
        m_nNextVirtAddr += m_nOutputVirtSize;
        m_nNextFileAddr += FileAlign(m_nOutputVirtSize);

        if (!AlignFileData(hFile)) {
            return FALSE;
        }

        //////////////////////////////////////////////////////////////////////////
        //
        m_SectionHeaders[nSection].VirtualAddress = m_nOutputVirtAddr;
        m_SectionHeaders[nSection].Misc.VirtualSize = m_nOutputVirtSize;
        m_SectionHeaders[nSection].PointerToRawData = m_nOutputFileAddr;
        m_SectionHeaders[nSection].SizeOfRawData = FileAlign(m_nOutputVirtSize);

        m_NtHeader.OptionalHeader
            .DataDirectory[IMAGE_DIRECTORY_ENTRY_IMPORT].VirtualAddress
            = rvaImportTable;
        m_NtHeader.OptionalHeader
            .DataDirectory[IMAGE_DIRECTORY_ENTRY_IMPORT].Size
            = nImportTableSize;

        m_NtHeader.OptionalHeader
            .DataDirectory[IMAGE_DIRECTORY_ENTRY_BOUND_IMPORT].VirtualAddress = 0;
        m_NtHeader.OptionalHeader
            .DataDirectory[IMAGE_DIRECTORY_ENTRY_BOUND_IMPORT].Size = 0;

        //////////////////////////////////////////////////////////////////////////
        //
        if (SetFilePointer(hFile, m_SectionHeaders[nSection].PointerToRawData,
                           NULL, FILE_BEGIN) == ~0u) {
            return FALSE;
        }
        if (!WriteFile(hFile, m_pbOutputBuffer, m_SectionHeaders[nSection].SizeOfRawData,
                       &cbDone)) {
            return FALSE;
        }
    }

    ///////////////////////////////////////////////////// Adjust Extra Data.
    //
    LONG nExtraAdjust = m_nNextFileAddr - m_nExtraOffset;
    for (n = 0; n < m_NtHeader.FileHeader.NumberOfSections; n++) {
        if (m_SectionHeaders[n].PointerToRawData > m_nExtraOffset) {
            m_SectionHeaders[n].PointerToRawData += nExtraAdjust;
        }
        if (m_SectionHeaders[n].PointerToRelocations > m_nExtraOffset) {
            m_SectionHeaders[n].PointerToRelocations += nExtraAdjust;
        }
        if (m_SectionHeaders[n].PointerToLinenumbers > m_nExtraOffset) {
            m_SectionHeaders[n].PointerToLinenumbers += nExtraAdjust;
        }
    }
    if (m_NtHeader.FileHeader.PointerToSymbolTable > m_nExtraOffset) {
        m_NtHeader.FileHeader.PointerToSymbolTable += nExtraAdjust;
    }

    m_NtHeader.OptionalHeader.CheckSum = 0;
    m_NtHeader.OptionalHeader.SizeOfImage = m_nNextVirtAddr;

    ////////////////////////////////////////////////// Adjust Debug Directory.
    //
    DWORD debugAddr = m_NtHeader.OptionalHeader
        .DataDirectory[IMAGE_DIRECTORY_ENTRY_DEBUG].VirtualAddress;
    DWORD debugSize = m_NtHeader.OptionalHeader
        .DataDirectory[IMAGE_DIRECTORY_ENTRY_DEBUG].Size;
    if (debugAddr && debugSize) {
        DWORD nFileOffset = RvaToFileOffset(debugAddr);
        if (SetFilePointer(hFile, nFileOffset, NULL, FILE_BEGIN) == ~0u) {
            return FALSE;
        }

        PIMAGE_DEBUG_DIRECTORY pDir = (PIMAGE_DEBUG_DIRECTORY)RvaToVa(debugAddr);
        if (pDir == NULL) {
            return FALSE;
        }

        DWORD nEntries = debugSize / sizeof(*pDir);
        for (n = 0; n < nEntries; n++) {
            IMAGE_DEBUG_DIRECTORY dir = pDir[n];

            if (dir.PointerToRawData > m_nExtraOffset) {
                dir.PointerToRawData += nExtraAdjust;
            }
            if (!WriteFile(hFile, &dir, sizeof(dir), &cbDone)) {
                return FALSE;
            }
        }
    }

    /////////////////////////////////////////////////////// Adjust CLR Header.
    //
    DWORD clrAddr = m_NtHeader.OptionalHeader
        .DataDirectory[IMAGE_DIRECTORY_ENTRY_COM_DESCRIPTOR].VirtualAddress;
    DWORD clrSize = m_NtHeader.OptionalHeader
        .DataDirectory[IMAGE_DIRECTORY_ENTRY_COM_DESCRIPTOR].Size;
    if (clrAddr && clrSize && fNeedDetourSection) {
        DWORD nFileOffset = RvaToFileOffset(clrAddr);
        if (SetFilePointer(hFile, nFileOffset, NULL, FILE_BEGIN) == ~0u) {
            return FALSE;
        }

        PDETOUR_CLR_HEADER pHdr = (PDETOUR_CLR_HEADER)RvaToVa(clrAddr);
        if (pHdr == NULL) {
            return FALSE;
        }

        DETOUR_CLR_HEADER hdr;
        hdr = *pHdr;
        hdr.Flags &= 0xfffffffe;    // Clear the IL_ONLY flag.

        if (!WriteFile(hFile, &hdr, sizeof(hdr), &cbDone)) {
            return FALSE;
        }
    }

    ///////////////////////////////////////////////// Copy Left-over Data.
    //
    if (m_nFileSize > m_nExtraOffset) {
        if (SetFilePointer(hFile, m_nNextFileAddr, NULL, FILE_BEGIN) == ~0u) {
            return FALSE;
        }
        if (!CopyFileData(hFile, m_nExtraOffset, m_nFileSize - m_nExtraOffset)) {
            return FALSE;
        }
    }


    //////////////////////////////////////////////////// Finalize Headers.
    //

    if (SetFilePointer(hFile, m_nPeOffset, NULL, FILE_BEGIN) == ~0u) {
        return FALSE;
    }
    if (!WriteFile(hFile, &m_NtHeader, sizeof(m_NtHeader), &cbDone)) {
        return FALSE;
    }

    if (SetFilePointer(hFile, m_nSectionsOffset, NULL, FILE_BEGIN) == ~0u) {
        return FALSE;
    }
    if (!WriteFile(hFile, &m_SectionHeaders,
                   sizeof(m_SectionHeaders[0])
                   * m_NtHeader.FileHeader.NumberOfSections,
                   &cbDone)) {
        return FALSE;
    }

    m_cbPostPE = SetFilePointer(hFile, 0, NULL, FILE_CURRENT);
    if (m_cbPostPE == ~0u) {
        return FALSE;
    }
    m_cbPostPE = m_NtHeader.OptionalHeader.SizeOfHeaders - m_cbPostPE;

    return TRUE;
}

};                                                      // namespace Detour

//////////////////////////////////////////////////////////////////////////////
//
PDETOUR_BINARY WINAPI DetourBinaryOpen(_In_ HANDLE hFile)
{
    Detour::CImage *pImage = new NOTHROW
        Detour::CImage;
    if (pImage == NULL) {
        SetLastError(ERROR_OUTOFMEMORY);
        return FALSE;
    }

    if (!pImage->Read(hFile)) {
        delete pImage;
        return FALSE;
    }

    return (PDETOUR_BINARY)pImage;
}

BOOL WINAPI DetourBinaryWrite(_In_ PDETOUR_BINARY pdi,
                              _In_ HANDLE hFile)
{
    Detour::CImage *pImage = Detour::CImage::IsValid(pdi);
    if (pImage == NULL) {
        return FALSE;
    }

    return pImage->Write(hFile);
}

_Writable_bytes_(*pcbData)
_Readable_bytes_(*pcbData)
_Success_(return != NULL)
PVOID WINAPI DetourBinaryEnumeratePayloads(_In_ PDETOUR_BINARY pBinary,
                                           _Out_opt_ GUID *pGuid,
                                           _Out_ DWORD *pcbData,
                                           _Inout_ DWORD *pnIterator)
{
    Detour::CImage *pImage = Detour::CImage::IsValid(pBinary);
    if (pImage == NULL) {
        return FALSE;
    }

    return pImage->DataEnum(pGuid, pcbData, pnIterator);
}

_Writable_bytes_(*pcbData)
_Readable_bytes_(*pcbData)
_Success_(return != NULL)
PVOID WINAPI DetourBinaryFindPayload(_In_ PDETOUR_BINARY pBinary,
                                     _In_ REFGUID rguid,
                                     _Out_ DWORD *pcbData)
{
    Detour::CImage *pImage = Detour::CImage::IsValid(pBinary);
    if (pImage == NULL) {
        return FALSE;
    }

    return pImage->DataFind(rguid, pcbData);
}

PVOID WINAPI DetourBinarySetPayload(_In_ PDETOUR_BINARY pBinary,
                                    _In_ REFGUID rguid,
                                    _In_reads_opt_(cbData) PVOID pvData,
                                    _In_ DWORD cbData)
{
    Detour::CImage *pImage = Detour::CImage::IsValid(pBinary);
    if (pImage == NULL) {
        return NULL;
    }

    return pImage->DataSet(rguid, (PBYTE)pvData, cbData);
}

BOOL WINAPI DetourBinaryDeletePayload(_In_ PDETOUR_BINARY pBinary,
                                      _In_ REFGUID rguid)
{
    Detour::CImage *pImage = Detour::CImage::IsValid(pBinary);
    if (pImage == NULL) {
        return FALSE;
    }

    return pImage->DataDelete(rguid);
}

BOOL WINAPI DetourBinaryPurgePayloads(_In_ PDETOUR_BINARY pBinary)
{
    Detour::CImage *pImage = Detour::CImage::IsValid(pBinary);
    if (pImage == NULL) {
        return FALSE;
    }

    return pImage->DataPurge();
}

//////////////////////////////////////////////////////////////////////////////
//
static BOOL CALLBACK ResetBywayCallback(_In_opt_ PVOID pContext,
                                        _In_opt_ LPCSTR pszFile,
                                        _Outptr_result_maybenull_ LPCSTR *ppszOutFile)
{
    UNREFERENCED_PARAMETER(pContext);
    UNREFERENCED_PARAMETER(pszFile);

    *ppszOutFile = NULL;
    return TRUE;
}

static BOOL CALLBACK ResetFileCallback(_In_opt_ PVOID pContext,
                                       _In_ LPCSTR pszOrigFile,
                                       _In_ LPCSTR pszFile,
                                       _Outptr_result_maybenull_ LPCSTR *ppszOutFile)
{
    UNREFERENCED_PARAMETER(pContext);
    UNREFERENCED_PARAMETER(pszFile);

    *ppszOutFile = pszOrigFile;
    return TRUE;
}

static BOOL CALLBACK ResetSymbolCallback(_In_opt_ PVOID pContext,
                                         _In_ ULONG nOrigOrdinal,
                                         _In_ ULONG nOrdinal,
                                         _Out_ ULONG *pnOutOrdinal,
                                         _In_opt_ LPCSTR pszOrigSymbol,
                                         _In_opt_ LPCSTR pszSymbol,
                                         _Outptr_result_maybenull_ LPCSTR *ppszOutSymbol)
{
    UNREFERENCED_PARAMETER(pContext);
    UNREFERENCED_PARAMETER(nOrdinal);
    UNREFERENCED_PARAMETER(pszSymbol);

    *pnOutOrdinal = nOrigOrdinal;
    *ppszOutSymbol = pszOrigSymbol;
    return TRUE;
}

BOOL WINAPI DetourBinaryResetImports(_In_ PDETOUR_BINARY pBinary)
{
    Detour::CImage *pImage = Detour::CImage::IsValid(pBinary);
    if (pImage == NULL) {
        return FALSE;
    }

    return pImage->EditImports(NULL,
                               ResetBywayCallback,
                               ResetFileCallback,
                               ResetSymbolCallback,
                               NULL);
}

//////////////////////////////////////////////////////////////////////////////
//
BOOL WINAPI DetourBinaryEditImports(_In_ PDETOUR_BINARY pBinary,
                                    _In_opt_ PVOID pContext,
                                    _In_opt_ PF_DETOUR_BINARY_BYWAY_CALLBACK pfByway,
                                    _In_opt_ PF_DETOUR_BINARY_FILE_CALLBACK pfFile,
                                    _In_opt_ PF_DETOUR_BINARY_SYMBOL_CALLBACK pfSymbol,
                                    _In_opt_ PF_DETOUR_BINARY_COMMIT_CALLBACK pfCommit)
{
    Detour::CImage *pImage = Detour::CImage::IsValid(pBinary);
    if (pImage == NULL) {
        return FALSE;
    }

    return pImage->EditImports(pContext,
                               pfByway,
                               pfFile,
                               pfSymbol,
                               pfCommit);
}

BOOL WINAPI DetourBinaryClose(_In_ PDETOUR_BINARY pBinary)
{
    Detour::CImage *pImage = Detour::CImage::IsValid(pBinary);
    if (pImage == NULL) {
        return FALSE;
    }

    BOOL bSuccess = pImage->Close();
    delete pImage;
    pImage = NULL;

    return bSuccess;
}

//
///////////////////////////////////////////////////////////////// End of File.

```

`src/modules.cpp`:

```cpp
//////////////////////////////////////////////////////////////////////////////
//
//  Module Enumeration Functions (modules.cpp of detours.lib)
//
//  Microsoft Research Detours Package, Version 4.0.1
//
//  Copyright (c) Microsoft Corporation.  All rights reserved.
//
//  Module enumeration functions.
//

// #define DETOUR_DEBUG 1
#define DETOURS_INTERNAL
#include "detours.h"

#if DETOURS_VERSION != 0x4c0c1   // 0xMAJORcMINORcPATCH
#error detours.h version mismatch
#endif

#define CLR_DIRECTORY OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_COM_DESCRIPTOR]
#define IAT_DIRECTORY OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_IAT]

//////////////////////////////////////////////////////////////////////////////
//
const GUID DETOUR_EXE_RESTORE_GUID = {
    0xbda26f34, 0xbc82, 0x4829,
    { 0x9e, 0x64, 0x74, 0x2c, 0x4, 0xc8, 0x4f, 0xa0 } };

//////////////////////////////////////////////////////////////////////////////
//
PDETOUR_SYM_INFO DetourLoadImageHlp(VOID)
{
    static DETOUR_SYM_INFO symInfo;
    static PDETOUR_SYM_INFO pSymInfo = NULL;
    static BOOL failed = false;

    if (failed) {
        return NULL;
    }
    if (pSymInfo != NULL) {
        return pSymInfo;
    }

    ZeroMemory(&symInfo, sizeof(symInfo));
    // Create a real handle to the process.
#if 0
    DuplicateHandle(GetCurrentProcess(),
                    GetCurrentProcess(),
                    GetCurrentProcess(),
                    &symInfo.hProcess,
                    0,
                    FALSE,
                    DUPLICATE_SAME_ACCESS);
#else
    symInfo.hProcess = GetCurrentProcess();
#endif

    symInfo.hDbgHelp = LoadLibraryExW(L"dbghelp.dll", NULL, 0);
    if (symInfo.hDbgHelp == NULL) {
      abort:
        failed = true;
        if (symInfo.hDbgHelp != NULL) {
            FreeLibrary(symInfo.hDbgHelp);
        }
        symInfo.pfImagehlpApiVersionEx = NULL;
        symInfo.pfSymInitialize = NULL;
        symInfo.pfSymSetOptions = NULL;
        symInfo.pfSymGetOptions = NULL;
        symInfo.pfSymLoadModule64 = NULL;
        symInfo.pfSymGetModuleInfo64 = NULL;
        symInfo.pfSymFromName = NULL;
        return NULL;
    }

    symInfo.pfImagehlpApiVersionEx
        = (PF_ImagehlpApiVersionEx)GetProcAddress(symInfo.hDbgHelp,
                                                  "ImagehlpApiVersionEx");
    symInfo.pfSymInitialize
        = (PF_SymInitialize)GetProcAddress(symInfo.hDbgHelp, "SymInitialize");
    symInfo.pfSymSetOptions
        = (PF_SymSetOptions)GetProcAddress(symInfo.hDbgHelp, "SymSetOptions");
    symInfo.pfSymGetOptions
        = (PF_SymGetOptions)GetProcAddress(symInfo.hDbgHelp, "SymGetOptions");
    symInfo.pfSymLoadModule64
        = (PF_SymLoadModule64)GetProcAddress(symInfo.hDbgHelp, "SymLoadModule64");
    symInfo.pfSymGetModuleInfo64
        = (PF_SymGetModuleInfo64)GetProcAddress(symInfo.hDbgHelp, "SymGetModuleInfo64");
    symInfo.pfSymFromName
        = (PF_SymFromName)GetProcAddress(symInfo.hDbgHelp, "SymFromName");

    API_VERSION av;
    ZeroMemory(&av, sizeof(av));
    av.MajorVersion = API_VERSION_NUMBER;

    if (symInfo.pfImagehlpApiVersionEx == NULL ||
        symInfo.pfSymInitialize == NULL ||
        symInfo.pfSymLoadModule64 == NULL ||
        symInfo.pfSymGetModuleInfo64 == NULL ||
        symInfo.pfSymFromName == NULL) {
        goto abort;
    }

    symInfo.pfImagehlpApiVersionEx(&av);
    if (av.MajorVersion < API_VERSION_NUMBER) {
        goto abort;
    }

    if (!symInfo.pfSymInitialize(symInfo.hProcess, NULL, FALSE)) {
        // We won't retry the initialize if it fails.
        goto abort;
    }

    if (symInfo.pfSymGetOptions != NULL && symInfo.pfSymSetOptions != NULL) {
        DWORD dw = symInfo.pfSymGetOptions();

        dw &= ~(SYMOPT_CASE_INSENSITIVE |
                SYMOPT_UNDNAME |
                SYMOPT_DEFERRED_LOADS |
                0);
        dw |= (
#if defined(SYMOPT_EXACT_SYMBOLS)
               SYMOPT_EXACT_SYMBOLS |
#endif
#if defined(SYMOPT_NO_UNQUALIFIED_LOADS)
               SYMOPT_NO_UNQUALIFIED_LOADS |
#endif
               SYMOPT_DEFERRED_LOADS |
#if defined(SYMOPT_FAIL_CRITICAL_ERRORS)
               SYMOPT_FAIL_CRITICAL_ERRORS |
#endif
#if defined(SYMOPT_INCLUDE_32BIT_MODULES)
               SYMOPT_INCLUDE_32BIT_MODULES |
#endif
               0);
        symInfo.pfSymSetOptions(dw);
    }

    pSymInfo = &symInfo;
    return pSymInfo;
}

PVOID WINAPI DetourFindFunction(_In_ LPCSTR pszModule,
                                _In_ LPCSTR pszFunction)
{
    if (pszFunction == NULL) {
        SetLastError(ERROR_INVALID_PARAMETER);
        return NULL;
    }

    /////////////////////////////////////////////// First, try GetProcAddress.
    //
#pragma prefast(suppress:28752, "We don't do the unicode conversion for LoadLibraryExA.")
    HMODULE hModule = LoadLibraryExA(pszModule, NULL, 0);
    if (hModule == NULL) {
        return NULL;
    }

    PBYTE pbCode = (PBYTE)GetProcAddress(hModule, pszFunction);
    if (pbCode) {
        return pbCode;
    }

    ////////////////////////////////////////////////////// Then try ImageHelp.
    //
    DETOUR_TRACE(("DetourFindFunction(%hs, %hs)\n", pszModule, pszFunction));
    PDETOUR_SYM_INFO pSymInfo = DetourLoadImageHlp();
    if (pSymInfo == NULL) {
        DETOUR_TRACE(("DetourLoadImageHlp failed: %lu\n",
                      GetLastError()));
        return NULL;
    }

    if (pSymInfo->pfSymLoadModule64(pSymInfo->hProcess, NULL,
                                    (PCHAR)pszModule, NULL,
                                    (DWORD64)hModule, 0) == 0) {
        if (ERROR_SUCCESS != GetLastError()) {
            DETOUR_TRACE(("SymLoadModule64(%p) failed: %lu\n",
                          pSymInfo->hProcess, GetLastError()));
            return NULL;
        }
    }

    HRESULT hrRet;
    CHAR szFullName[512];
    IMAGEHLP_MODULE64 modinfo;
    ZeroMemory(&modinfo, sizeof(modinfo));
    modinfo.SizeOfStruct = sizeof(modinfo);
    if (!pSymInfo->pfSymGetModuleInfo64(pSymInfo->hProcess, (DWORD64)hModule, &modinfo)) {
        DETOUR_TRACE(("SymGetModuleInfo64(%p, %p) failed: %lu\n",
                      pSymInfo->hProcess, hModule, GetLastError()));
        return NULL;
    }

    hrRet = StringCchCopyA(szFullName, sizeof(szFullName)/sizeof(CHAR), modinfo.ModuleName);
    if (FAILED(hrRet)) {
        DETOUR_TRACE(("StringCchCopyA failed: %08lx\n", hrRet));
        return NULL;
    }
    hrRet = StringCchCatA(szFullName, sizeof(szFullName)/sizeof(CHAR), "!");
    if (FAILED(hrRet)) {
        DETOUR_TRACE(("StringCchCatA failed: %08lx\n", hrRet));
        return NULL;
    }
    hrRet = StringCchCatA(szFullName, sizeof(szFullName)/sizeof(CHAR), pszFunction);
    if (FAILED(hrRet)) {
        DETOUR_TRACE(("StringCchCatA failed: %08lx\n", hrRet));
        return NULL;
    }

    struct CFullSymbol : SYMBOL_INFO {
        CHAR szRestOfName[512];
    } symbol;
    ZeroMemory(&symbol, sizeof(symbol));
    //symbol.ModBase = (ULONG64)hModule;
    symbol.SizeOfStruct = sizeof(SYMBOL_INFO);
#ifdef DBHLPAPI
    symbol.MaxNameLen = sizeof(symbol.szRestOfName)/sizeof(symbol.szRestOfName[0]);
#else
    symbol.MaxNameLength = sizeof(symbol.szRestOfName)/sizeof(symbol.szRestOfName[0]);
#endif

    if (!pSymInfo->pfSymFromName(pSymInfo->hProcess, szFullName, &symbol)) {
        DETOUR_TRACE(("SymFromName(%hs) failed: %lu\n", szFullName, GetLastError()));
        return NULL;
    }

#if defined(DETOURS_IA64)
    // On the IA64, we get a raw code pointer from the symbol engine
    // and have to convert it to a wrapped [code pointer, global pointer].
    //
    PPLABEL_DESCRIPTOR pldEntry = (PPLABEL_DESCRIPTOR)DetourGetEntryPoint(hModule);
    PPLABEL_DESCRIPTOR pldSymbol = new PLABEL_DESCRIPTOR;

    pldSymbol->EntryPoint = symbol.Address;
    pldSymbol->GlobalPointer = pldEntry->GlobalPointer;
    return (PBYTE)pldSymbol;
#elif defined(DETOURS_ARM)
    // On the ARM, we get a raw code pointer, which we must convert into a
    // valied Thumb2 function pointer.
    return DETOURS_PBYTE_TO_PFUNC(symbol.Address);
#else
    return (PBYTE)symbol.Address;
#endif
}

//////////////////////////////////////////////////// Module Image Functions.
//

HMODULE WINAPI DetourEnumerateModules(_In_opt_ HMODULE hModuleLast)
{
    PBYTE pbLast = (PBYTE)hModuleLast + MM_ALLOCATION_GRANULARITY;

    MEMORY_BASIC_INFORMATION mbi;
    ZeroMemory(&mbi, sizeof(mbi));

    // Find the next memory region that contains a mapped PE image.
    //
    for (;; pbLast = (PBYTE)mbi.BaseAddress + mbi.RegionSize) {
        if (VirtualQuery(pbLast, &mbi, sizeof(mbi)) <= 0) {
            break;
        }

        // Skip uncommitted regions and guard pages.
        //
        if ((mbi.State != MEM_COMMIT) ||
            ((mbi.Protect & 0xff) == PAGE_NOACCESS) ||
            (mbi.Protect & PAGE_GUARD)) {
            continue;
        }

        __try {
            PIMAGE_DOS_HEADER pDosHeader = (PIMAGE_DOS_HEADER)pbLast;
            if (pDosHeader->e_magic != IMAGE_DOS_SIGNATURE ||
                (DWORD)pDosHeader->e_lfanew > mbi.RegionSize ||
                (DWORD)pDosHeader->e_lfanew < sizeof(*pDosHeader)) {
                continue;
            }

            PIMAGE_NT_HEADERS pNtHeader = (PIMAGE_NT_HEADERS)((PBYTE)pDosHeader +
                                                              pDosHeader->e_lfanew);
            if (pNtHeader->Signature != IMAGE_NT_SIGNATURE) {
                continue;
            }

            SetLastError(NO_ERROR);
            return (HMODULE)pDosHeader;
        }
#pragma prefast(suppress:28940, "A bad pointer means this probably isn't a PE header.")
        __except(GetExceptionCode() == EXCEPTION_ACCESS_VIOLATION ?
                 EXCEPTION_EXECUTE_HANDLER : EXCEPTION_CONTINUE_SEARCH) {
            continue;
        }
    }
    return NULL;
}

PVOID WINAPI DetourGetEntryPoint(_In_opt_ HMODULE hModule)
{
    PIMAGE_DOS_HEADER pDosHeader = (PIMAGE_DOS_HEADER)hModule;
    if (hModule == NULL) {
        pDosHeader = (PIMAGE_DOS_HEADER)GetModuleHandleW(NULL);
    }

    __try {
#pragma warning(suppress:6011) // GetModuleHandleW(NULL) never returns NULL.
        if (pDosHeader->e_magic != IMAGE_DOS_SIGNATURE) {
            SetLastError(ERROR_BAD_EXE_FORMAT);
            return NULL;
        }

        PIMAGE_NT_HEADERS pNtHeader = (PIMAGE_NT_HEADERS)((PBYTE)pDosHeader +
                                                          pDosHeader->e_lfanew);
        if (pNtHeader->Signature != IMAGE_NT_SIGNATURE) {
            SetLastError(ERROR_INVALID_EXE_SIGNATURE);
            return NULL;
        }
        if (pNtHeader->FileHeader.SizeOfOptionalHeader == 0) {
            SetLastError(ERROR_EXE_MARKED_INVALID);
            return NULL;
        }

        PDETOUR_CLR_HEADER pClrHeader = NULL;
        if (pNtHeader->OptionalHeader.Magic == IMAGE_NT_OPTIONAL_HDR32_MAGIC) {
            if (((PIMAGE_NT_HEADERS32)pNtHeader)->CLR_DIRECTORY.VirtualAddress != 0 &&
                ((PIMAGE_NT_HEADERS32)pNtHeader)->CLR_DIRECTORY.Size != 0) {
                pClrHeader = (PDETOUR_CLR_HEADER)
                    (((PBYTE)pDosHeader)
                     + ((PIMAGE_NT_HEADERS32)pNtHeader)->CLR_DIRECTORY.VirtualAddress);
            }
        }
        else if (pNtHeader->OptionalHeader.Magic == IMAGE_NT_OPTIONAL_HDR64_MAGIC) {
            if (((PIMAGE_NT_HEADERS64)pNtHeader)->CLR_DIRECTORY.VirtualAddress != 0 &&
                ((PIMAGE_NT_HEADERS64)pNtHeader)->CLR_DIRECTORY.Size != 0) {
                pClrHeader = (PDETOUR_CLR_HEADER)
                    (((PBYTE)pDosHeader)
                     + ((PIMAGE_NT_HEADERS64)pNtHeader)->CLR_DIRECTORY.VirtualAddress);
            }
        }

        if (pClrHeader != NULL) {
            // For MSIL assemblies, we want to use the _Cor entry points.

            HMODULE hClr = GetModuleHandleW(L"MSCOREE.DLL");
            if (hClr == NULL) {
                return NULL;
            }

            SetLastError(NO_ERROR);
            return (PVOID)GetProcAddress(hClr, "_CorExeMain");
        }

        SetLastError(NO_ERROR);

        // Pure resource DLLs have neither an entry point nor CLR information
        // so handle them by returning NULL (LastError is NO_ERROR)
        if (pNtHeader->OptionalHeader.AddressOfEntryPoint == 0) {
            return NULL;
        }

        return ((PBYTE)pDosHeader) +
            pNtHeader->OptionalHeader.AddressOfEntryPoint;
    }
    __except(GetExceptionCode() == EXCEPTION_ACCESS_VIOLATION ?
             EXCEPTION_EXECUTE_HANDLER : EXCEPTION_CONTINUE_SEARCH) {
        SetLastError(ERROR_EXE_MARKED_INVALID);
        return NULL;
    }
}

ULONG WINAPI DetourGetModuleSize(_In_opt_ HMODULE hModule)
{
    PIMAGE_DOS_HEADER pDosHeader = (PIMAGE_DOS_HEADER)hModule;
    if (hModule == NULL) {
        pDosHeader = (PIMAGE_DOS_HEADER)GetModuleHandleW(NULL);
    }

    __try {
#pragma warning(suppress:6011) // GetModuleHandleW(NULL) never returns NULL.
        if (pDosHeader->e_magic != IMAGE_DOS_SIGNATURE) {
            SetLastError(ERROR_BAD_EXE_FORMAT);
            return NULL;
        }

        PIMAGE_NT_HEADERS pNtHeader = (PIMAGE_NT_HEADERS)((PBYTE)pDosHeader +
                                                          pDosHeader->e_lfanew);
        if (pNtHeader->Signature != IMAGE_NT_SIGNATURE) {
            SetLastError(ERROR_INVALID_EXE_SIGNATURE);
            return NULL;
        }
        if (pNtHeader->FileHeader.SizeOfOptionalHeader == 0) {
            SetLastError(ERROR_EXE_MARKED_INVALID);
            return NULL;
        }
        SetLastError(NO_ERROR);

        return (pNtHeader->OptionalHeader.SizeOfImage);
    }
    __except(GetExceptionCode() == EXCEPTION_ACCESS_VIOLATION ?
             EXCEPTION_EXECUTE_HANDLER : EXCEPTION_CONTINUE_SEARCH) {
        SetLastError(ERROR_EXE_MARKED_INVALID);
        return NULL;
    }
}

HMODULE WINAPI DetourGetContainingModule(_In_ PVOID pvAddr)
{
    MEMORY_BASIC_INFORMATION mbi;
    ZeroMemory(&mbi, sizeof(mbi));

    __try {
        if (VirtualQuery(pvAddr, &mbi, sizeof(mbi)) <= 0) {
            SetLastError(ERROR_BAD_EXE_FORMAT);
            return NULL;
        }

        // Skip uncommitted regions and guard pages.
        //
        if ((mbi.State != MEM_COMMIT) ||
            ((mbi.Protect & 0xff) == PAGE_NOACCESS) ||
            (mbi.Protect & PAGE_GUARD)) {
            SetLastError(ERROR_BAD_EXE_FORMAT);
            return NULL;
        }

        PIMAGE_DOS_HEADER pDosHeader = (PIMAGE_DOS_HEADER)mbi.AllocationBase;
        if (pDosHeader->e_magic != IMAGE_DOS_SIGNATURE) {
            SetLastError(ERROR_BAD_EXE_FORMAT);
            return NULL;
        }

        PIMAGE_NT_HEADERS pNtHeader = (PIMAGE_NT_HEADERS)((PBYTE)pDosHeader +
                                                          pDosHeader->e_lfanew);
        if (pNtHeader->Signature != IMAGE_NT_SIGNATURE) {
            SetLastError(ERROR_INVALID_EXE_SIGNATURE);
            return NULL;
        }
        if (pNtHeader->FileHeader.SizeOfOptionalHeader == 0) {
            SetLastError(ERROR_EXE_MARKED_INVALID);
            return NULL;
        }
        SetLastError(NO_ERROR);

        return (HMODULE)pDosHeader;
    }
    __except(GetExceptionCode() == EXCEPTION_ACCESS_VIOLATION ?
             EXCEPTION_EXECUTE_HANDLER : EXCEPTION_CONTINUE_SEARCH) {
        SetLastError(ERROR_INVALID_EXE_SIGNATURE);
        return NULL;
    }
}


static inline PBYTE RvaAdjust(_Pre_notnull_ PIMAGE_DOS_HEADER pDosHeader, _In_ DWORD raddr)
{
    if (raddr != NULL) {
        return ((PBYTE)pDosHeader) + raddr;
    }
    return NULL;
}

BOOL WINAPI DetourEnumerateExports(_In_ HMODULE hModule,
                                   _In_opt_ PVOID pContext,
                                   _In_ PF_DETOUR_ENUMERATE_EXPORT_CALLBACK pfExport)
{
    if (pfExport == NULL) {
        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
    }

    PIMAGE_DOS_HEADER pDosHeader = (PIMAGE_DOS_HEADER)hModule;
    if (hModule == NULL) {
        pDosHeader = (PIMAGE_DOS_HEADER)GetModuleHandleW(NULL);
    }

    __try {
#pragma warning(suppress:6011) // GetModuleHandleW(NULL) never returns NULL.
        if (pDosHeader->e_magic != IMAGE_DOS_SIGNATURE) {
            SetLastError(ERROR_BAD_EXE_FORMAT);
            return NULL;
        }

        PIMAGE_NT_HEADERS pNtHeader = (PIMAGE_NT_HEADERS)((PBYTE)pDosHeader +
                                                          pDosHeader->e_lfanew);
        if (pNtHeader->Signature != IMAGE_NT_SIGNATURE) {
            SetLastError(ERROR_INVALID_EXE_SIGNATURE);
            return FALSE;
        }
        if (pNtHeader->FileHeader.SizeOfOptionalHeader == 0) {
            SetLastError(ERROR_EXE_MARKED_INVALID);
            return FALSE;
        }

        PIMAGE_EXPORT_DIRECTORY pExportDir
            = (PIMAGE_EXPORT_DIRECTORY)
            RvaAdjust(pDosHeader,
                      pNtHeader->OptionalHeader
                      .DataDirectory[IMAGE_DIRECTORY_ENTRY_EXPORT].VirtualAddress);

        if (pExportDir == NULL) {
            SetLastError(ERROR_EXE_MARKED_INVALID);
            return FALSE;
        }

        PBYTE pExportDirEnd = (PBYTE)pExportDir + pNtHeader->OptionalHeader
            .DataDirectory[IMAGE_DIRECTORY_ENTRY_EXPORT].Size;
        PDWORD pdwFunctions = (PDWORD)RvaAdjust(pDosHeader, pExportDir->AddressOfFunctions);
        PDWORD pdwNames = (PDWORD)RvaAdjust(pDosHeader, pExportDir->AddressOfNames);
        PWORD pwOrdinals = (PWORD)RvaAdjust(pDosHeader, pExportDir->AddressOfNameOrdinals);

        for (DWORD nFunc = 0; nFunc < pExportDir->NumberOfFunctions; nFunc++) {
            PBYTE pbCode = (pdwFunctions != NULL)
                ? (PBYTE)RvaAdjust(pDosHeader, pdwFunctions[nFunc]) : NULL;
            PCHAR pszName = NULL;

            // if the pointer is in the export region, then it is a forwarder.
            if (pbCode > (PBYTE)pExportDir && pbCode < pExportDirEnd) {
                pbCode = NULL;
            }

            for (DWORD n = 0; n < pExportDir->NumberOfNames; n++) {
                if (pwOrdinals[n] == nFunc) {
                    pszName = (pdwNames != NULL)
                        ? (PCHAR)RvaAdjust(pDosHeader, pdwNames[n]) : NULL;
                    break;
                }
            }
            ULONG nOrdinal = pExportDir->Base + nFunc;

            if (!pfExport(pContext, nOrdinal, pszName, pbCode)) {
                break;
            }
        }
        SetLastError(NO_ERROR);
        return TRUE;
    }
    __except(GetExceptionCode() == EXCEPTION_ACCESS_VIOLATION ?
             EXCEPTION_EXECUTE_HANDLER : EXCEPTION_CONTINUE_SEARCH) {
        SetLastError(ERROR_EXE_MARKED_INVALID);
        return NULL;
    }
}

BOOL WINAPI DetourEnumerateImportsEx(_In_opt_ HMODULE hModule,
                                     _In_opt_ PVOID pContext,
                                     _In_opt_ PF_DETOUR_IMPORT_FILE_CALLBACK pfImportFile,
                                     _In_opt_ PF_DETOUR_IMPORT_FUNC_CALLBACK_EX pfImportFunc)
{
    PIMAGE_DOS_HEADER pDosHeader = (PIMAGE_DOS_HEADER)hModule;
    if (hModule == NULL) {
        pDosHeader = (PIMAGE_DOS_HEADER)GetModuleHandleW(NULL);
    }

    __try {
#pragma warning(suppress:6011) // GetModuleHandleW(NULL) never returns NULL.
        if (pDosHeader->e_magic != IMAGE_DOS_SIGNATURE) {
            SetLastError(ERROR_BAD_EXE_FORMAT);
            return FALSE;
        }

        PIMAGE_NT_HEADERS pNtHeader = (PIMAGE_NT_HEADERS)((PBYTE)pDosHeader +
                                                          pDosHeader->e_lfanew);
        if (pNtHeader->Signature != IMAGE_NT_SIGNATURE) {
            SetLastError(ERROR_INVALID_EXE_SIGNATURE);
            return FALSE;
        }
        if (pNtHeader->FileHeader.SizeOfOptionalHeader == 0) {
            SetLastError(ERROR_EXE_MARKED_INVALID);
            return FALSE;
        }

        PIMAGE_IMPORT_DESCRIPTOR iidp
            = (PIMAGE_IMPORT_DESCRIPTOR)
            RvaAdjust(pDosHeader,
                      pNtHeader->OptionalHeader
                      .DataDirectory[IMAGE_DIRECTORY_ENTRY_IMPORT].VirtualAddress);

        if (iidp == NULL) {
            SetLastError(ERROR_EXE_MARKED_INVALID);
            return FALSE;
        }

        for (; iidp->OriginalFirstThunk != 0; iidp++) {

            PCSTR pszName = (PCHAR)RvaAdjust(pDosHeader, iidp->Name);
            if (pszName == NULL) {
                SetLastError(ERROR_EXE_MARKED_INVALID);
                return FALSE;
            }

            PIMAGE_THUNK_DATA pThunks = (PIMAGE_THUNK_DATA)
                RvaAdjust(pDosHeader, iidp->OriginalFirstThunk);
            PVOID * pAddrs = (PVOID *)
                RvaAdjust(pDosHeader, iidp->FirstThunk);

            HMODULE hFile = DetourGetContainingModule(pAddrs[0]);

            if (pfImportFile != NULL) {
                if (!pfImportFile(pContext, hFile, pszName)) {
                    break;
                }
            }

            DWORD nNames = 0;
            if (pThunks) {
                for (; pThunks[nNames].u1.Ordinal; nNames++) {
                    DWORD nOrdinal = 0;
                    PCSTR pszFunc = NULL;

                    if (IMAGE_SNAP_BY_ORDINAL(pThunks[nNames].u1.Ordinal)) {
                        nOrdinal = (DWORD)IMAGE_ORDINAL(pThunks[nNames].u1.Ordinal);
                    }
                    else {
                        pszFunc = (PCSTR)RvaAdjust(pDosHeader,
                                                   (DWORD)pThunks[nNames].u1.AddressOfData + 2);
                    }

                    if (pfImportFunc != NULL) {
                        if (!pfImportFunc(pContext,
                                          nOrdinal,
                                          pszFunc,
                                          &pAddrs[nNames])) {
                            break;
                        }
                    }
                }
                if (pfImportFunc != NULL) {
                    pfImportFunc(pContext, 0, NULL, NULL);
                }
            }
        }
        if (pfImportFile != NULL) {
            pfImportFile(pContext, NULL, NULL);
        }
        SetLastError(NO_ERROR);
        return TRUE;
    }
    __except(GetExceptionCode() == EXCEPTION_ACCESS_VIOLATION ?
             EXCEPTION_EXECUTE_HANDLER : EXCEPTION_CONTINUE_SEARCH) {
        SetLastError(ERROR_EXE_MARKED_INVALID);
        return FALSE;
    }
}

// Context for DetourEnumerateImportsThunk, which adapts "regular" callbacks for use with "Ex".
struct _DETOUR_ENUMERATE_IMPORTS_THUNK_CONTEXT
{
    PVOID pContext;
    PF_DETOUR_IMPORT_FUNC_CALLBACK pfImportFunc;
};

// Callback for DetourEnumerateImportsEx that adapts DetourEnumerateImportsEx
// for use with a DetourEnumerateImports callback -- derefence the IAT and pass the value on.

static
BOOL
CALLBACK
DetourEnumerateImportsThunk(_In_ PVOID VoidContext,
                            _In_ DWORD nOrdinal,
                            _In_opt_ PCSTR pszFunc,
                            _In_opt_ PVOID* ppvFunc)
{
    _DETOUR_ENUMERATE_IMPORTS_THUNK_CONTEXT const * const
        pContext = (_DETOUR_ENUMERATE_IMPORTS_THUNK_CONTEXT*)VoidContext;
    return pContext->pfImportFunc(pContext->pContext, nOrdinal, pszFunc, ppvFunc ? *ppvFunc : NULL);
}

BOOL WINAPI DetourEnumerateImports(_In_opt_ HMODULE hModule,
                                   _In_opt_ PVOID pContext,
                                   _In_opt_ PF_DETOUR_IMPORT_FILE_CALLBACK pfImportFile,
                                   _In_opt_ PF_DETOUR_IMPORT_FUNC_CALLBACK pfImportFunc)
{
    if (pfImportFile == NULL || pfImportFunc == NULL) {
        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
    }

    _DETOUR_ENUMERATE_IMPORTS_THUNK_CONTEXT const context = { pContext, pfImportFunc };

    return DetourEnumerateImportsEx(hModule,
                                    (PVOID)&context,
                                    pfImportFile,
                                    &DetourEnumerateImportsThunk);
}

static PDETOUR_LOADED_BINARY WINAPI GetPayloadSectionFromModule(HMODULE hModule)
{
    PIMAGE_DOS_HEADER pDosHeader = (PIMAGE_DOS_HEADER)hModule;
    if (hModule == NULL) {
        pDosHeader = (PIMAGE_DOS_HEADER)GetModuleHandleW(NULL);
    }

    __try {
#pragma warning(suppress:6011) // GetModuleHandleW(NULL) never returns NULL.
        if (pDosHeader->e_magic != IMAGE_DOS_SIGNATURE) {
            SetLastError(ERROR_BAD_EXE_FORMAT);
            return NULL;
        }

        PIMAGE_NT_HEADERS pNtHeader = (PIMAGE_NT_HEADERS)((PBYTE)pDosHeader +
                                                          pDosHeader->e_lfanew);
        if (pNtHeader->Signature != IMAGE_NT_SIGNATURE) {
            SetLastError(ERROR_INVALID_EXE_SIGNATURE);
            return NULL;
        }
        if (pNtHeader->FileHeader.SizeOfOptionalHeader == 0) {
            SetLastError(ERROR_EXE_MARKED_INVALID);
            return NULL;
        }

        PIMAGE_SECTION_HEADER pSectionHeaders
            = (PIMAGE_SECTION_HEADER)((PBYTE)pNtHeader
                                      + sizeof(pNtHeader->Signature)
                                      + sizeof(pNtHeader->FileHeader)
                                      + pNtHeader->FileHeader.SizeOfOptionalHeader);

        for (DWORD n = 0; n < pNtHeader->FileHeader.NumberOfSections; n++) {
            if (strcmp((PCHAR)pSectionHeaders[n].Name, ".detour") == 0) {
                if (pSectionHeaders[n].VirtualAddress == 0 ||
                    pSectionHeaders[n].SizeOfRawData == 0) {

                    break;
                }

                PBYTE pbData = (PBYTE)pDosHeader + pSectionHeaders[n].VirtualAddress;
                DETOUR_SECTION_HEADER *pHeader = (DETOUR_SECTION_HEADER *)pbData;
                if (pHeader->cbHeaderSize < sizeof(DETOUR_SECTION_HEADER) ||
                    pHeader->nSignature != DETOUR_SECTION_HEADER_SIGNATURE) {

                    break;
                }

                if (pHeader->nDataOffset == 0) {
                    pHeader->nDataOffset = pHeader->cbHeaderSize;
                }
                SetLastError(NO_ERROR);
                return (PBYTE)pHeader;
            }
        }
        SetLastError(ERROR_EXE_MARKED_INVALID);
        return NULL;
    }
    __except(GetExceptionCode() == EXCEPTION_ACCESS_VIOLATION ?
             EXCEPTION_EXECUTE_HANDLER : EXCEPTION_CONTINUE_SEARCH) {
        SetLastError(ERROR_EXE_MARKED_INVALID);
        return NULL;
    }
}

DWORD WINAPI DetourGetSizeOfPayloads(_In_opt_ HMODULE hModule)
{
    PDETOUR_LOADED_BINARY pBinary = GetPayloadSectionFromModule(hModule);
    if (pBinary == NULL) {
        // Error set by GetPayloadSectionFromModule.
        return 0;
    }

    __try {
        DETOUR_SECTION_HEADER *pHeader = (DETOUR_SECTION_HEADER *)pBinary;
        if (pHeader->cbHeaderSize < sizeof(DETOUR_SECTION_HEADER) ||
            pHeader->nSignature != DETOUR_SECTION_HEADER_SIGNATURE) {

            SetLastError(ERROR_INVALID_HANDLE);
            return 0;
        }
        SetLastError(NO_ERROR);
        return pHeader->cbDataSize;
    }
    __except(GetExceptionCode() == EXCEPTION_ACCESS_VIOLATION ?
             EXCEPTION_EXECUTE_HANDLER : EXCEPTION_CONTINUE_SEARCH) {
        SetLastError(ERROR_INVALID_HANDLE);
        return 0;
    }
}

_Writable_bytes_(*pcbData)
_Readable_bytes_(*pcbData)
_Success_(return != NULL)
PVOID WINAPI DetourFindPayload(_In_opt_ HMODULE hModule,
                               _In_ REFGUID rguid,
                               _Out_opt_ DWORD *pcbData)
{
    PBYTE pbData = NULL;
    if (pcbData) {
        *pcbData = 0;
    }

    PDETOUR_LOADED_BINARY pBinary = GetPayloadSectionFromModule(hModule);
    if (pBinary == NULL) {
        // Error set by GetPayloadSectionFromModule.
        return NULL;
    }

    __try {
        DETOUR_SECTION_HEADER *pHeader = (DETOUR_SECTION_HEADER *)pBinary;
        if (pHeader->cbHeaderSize < sizeof(DETOUR_SECTION_HEADER) ||
            pHeader->nSignature != DETOUR_SECTION_HEADER_SIGNATURE) {

            SetLastError(ERROR_INVALID_EXE_SIGNATURE);
            return NULL;
        }

        PBYTE pbBeg = ((PBYTE)pHeader) + pHeader->nDataOffset;
        PBYTE pbEnd = ((PBYTE)pHeader) + pHeader->cbDataSize;

        for (pbData = pbBeg; pbData < pbEnd;) {
            DETOUR_SECTION_RECORD *pSection = (DETOUR_SECTION_RECORD *)pbData;

            if (DetourAreSameGuid(pSection->guid, rguid)) {
                if (pcbData) {
                    *pcbData = pSection->cbBytes - sizeof(*pSection);
                }
                SetLastError(NO_ERROR);
                return (PBYTE)(pSection + 1);
            }

            pbData = (PBYTE)pSection + pSection->cbBytes;
        }
        SetLastError(ERROR_INVALID_HANDLE);
        return NULL;
    }
    __except(GetExceptionCode() == EXCEPTION_ACCESS_VIOLATION ?
             EXCEPTION_EXECUTE_HANDLER : EXCEPTION_CONTINUE_SEARCH) {
        SetLastError(ERROR_INVALID_HANDLE);
        return NULL;
    }
}

_Writable_bytes_(*pcbData)
_Readable_bytes_(*pcbData)
_Success_(return != NULL)
PVOID WINAPI DetourFindPayloadEx(_In_ REFGUID rguid,
                                 _Out_opt_ DWORD *pcbData)
{
    for (HMODULE hMod = NULL; (hMod = DetourEnumerateModules(hMod)) != NULL;) {
        PVOID pvData;

        pvData = DetourFindPayload(hMod, rguid, pcbData);
        if (pvData != NULL) {
            return pvData;
        }
    }
    SetLastError(ERROR_MOD_NOT_FOUND);
    return NULL;
}

BOOL WINAPI DetourFreePayload(_In_ PVOID pvData)
{
    BOOL fSucceeded = FALSE;

    // If you have any doubts about the following code, please refer to the comments in DetourCopyPayloadToProcess.
    HMODULE hModule = DetourGetContainingModule(pvData);
    DETOUR_ASSERT(hModule != NULL);
    if (hModule != NULL) {
        fSucceeded = VirtualFree(hModule, 0, MEM_RELEASE);
        DETOUR_ASSERT(fSucceeded);
        if (fSucceeded) {
            hModule = NULL;
        }
    }

    return fSucceeded;
}

BOOL WINAPI DetourRestoreAfterWithEx(_In_reads_bytes_(cbData) PVOID pvData,
                                     _In_ DWORD cbData)
{
    PDETOUR_EXE_RESTORE pder = (PDETOUR_EXE_RESTORE)pvData;

    if (pder->cb != sizeof(*pder) || pder->cb > cbData) {
        SetLastError(ERROR_BAD_EXE_FORMAT);
        return FALSE;
    }

    DWORD dwPermIdh = ~0u;
    DWORD dwPermInh = ~0u;
    DWORD dwPermClr = ~0u;
    DWORD dwIgnore;
    BOOL fSucceeded = FALSE;
    BOOL fUpdated32To64 = FALSE;

    if (pder->pclr != NULL && pder->clr.Flags != ((PDETOUR_CLR_HEADER)pder->pclr)->Flags) {
        // If we had to promote the 32/64-bit agnostic IL to 64-bit, we can't restore
        // that.
        fUpdated32To64 = TRUE;
    }

    if (DetourVirtualProtectSameExecute(pder->pidh, pder->cbidh,
                                        PAGE_EXECUTE_READWRITE, &dwPermIdh)) {
        if (DetourVirtualProtectSameExecute(pder->pinh, pder->cbinh,
                                            PAGE_EXECUTE_READWRITE, &dwPermInh)) {

            CopyMemory(pder->pidh, &pder->idh, pder->cbidh);
            CopyMemory(pder->pinh, &pder->inh, pder->cbinh);

            if (pder->pclr != NULL && !fUpdated32To64) {
                if (DetourVirtualProtectSameExecute(pder->pclr, pder->cbclr,
                                                    PAGE_EXECUTE_READWRITE, &dwPermClr)) {
                    CopyMemory(pder->pclr, &pder->clr, pder->cbclr);
                    VirtualProtect(pder->pclr, pder->cbclr, dwPermClr, &dwIgnore);
                    fSucceeded = TRUE;
                }
            }
            else {
                fSucceeded = TRUE;
            }
            VirtualProtect(pder->pinh, pder->cbinh, dwPermInh, &dwIgnore);
        }
        VirtualProtect(pder->pidh, pder->cbidh, dwPermIdh, &dwIgnore);
    }
    // Delete the payload after successful recovery to prevent repeated restore
    if (fSucceeded) {
        DetourFreePayload(pder);
        pder = NULL;
    }
    return fSucceeded;
}

BOOL WINAPI DetourRestoreAfterWith()
{
    PVOID pvData;
    DWORD cbData;

    pvData = DetourFindPayloadEx(DETOUR_EXE_RESTORE_GUID, &cbData);

    if (pvData != NULL && cbData != 0) {
        return DetourRestoreAfterWithEx(pvData, cbData);
    }
    SetLastError(ERROR_MOD_NOT_FOUND);
    return FALSE;
}

//  End of File

```

`src/uimports.cpp`:

```cpp
//////////////////////////////////////////////////////////////////////////////
//
//  Add DLLs to a module import table (uimports.cpp of detours.lib)
//
//  Microsoft Research Detours Package, Version 4.0.1
//
//  Copyright (c) Microsoft Corporation.  All rights reserved.
//
//  Note that this file is included into creatwth.cpp one or more times
//  (once for each supported module format).
//

#if DETOURS_VERSION != 0x4c0c1   // 0xMAJORcMINORcPATCH
#error detours.h version mismatch
#endif

// UpdateImports32 aka UpdateImports64
static BOOL UPDATE_IMPORTS_XX(HANDLE hProcess,
                              HMODULE hModule,
                              __in_ecount(nDlls) LPCSTR *plpDlls,
                              DWORD nDlls)
{
    BOOL fSucceeded = FALSE;
    DWORD cbNew = 0;

    BYTE * pbNew = NULL;
    DWORD i;
    SIZE_T cbRead;
    DWORD n;

    PBYTE pbModule = (PBYTE)hModule;

    IMAGE_DOS_HEADER idh;
    ZeroMemory(&idh, sizeof(idh));
    if (!ReadProcessMemory(hProcess, pbModule, &idh, sizeof(idh), &cbRead)
        || cbRead < sizeof(idh)) {

        DETOUR_TRACE(("ReadProcessMemory(idh@%p..%p) failed: %lu\n",
                      pbModule, pbModule + sizeof(idh), GetLastError()));

      finish:
        if (pbNew != NULL) {
            delete[] pbNew;
            pbNew = NULL;
        }
        return fSucceeded;
    }

    IMAGE_NT_HEADERS_XX inh;
    ZeroMemory(&inh, sizeof(inh));

    if (!ReadProcessMemory(hProcess, pbModule + idh.e_lfanew, &inh, sizeof(inh), &cbRead)
        || cbRead < sizeof(inh)) {
        DETOUR_TRACE(("ReadProcessMemory(inh@%p..%p) failed: %lu\n",
                      pbModule + idh.e_lfanew,
                      pbModule + idh.e_lfanew + sizeof(inh),
                      GetLastError()));
        goto finish;
    }

    if (inh.OptionalHeader.Magic != IMAGE_NT_OPTIONAL_HDR_MAGIC_XX) {
        DETOUR_TRACE(("Wrong size image (%04x != %04x).\n",
                      inh.OptionalHeader.Magic, IMAGE_NT_OPTIONAL_HDR_MAGIC_XX));
        SetLastError(ERROR_INVALID_BLOCK);
        goto finish;
    }

    // Zero out the bound table so loader doesn't use it instead of our new table.
    inh.BOUND_DIRECTORY.VirtualAddress = 0;
    inh.BOUND_DIRECTORY.Size = 0;

    // Find the size of the mapped file.
    DWORD dwSec = idh.e_lfanew +
        FIELD_OFFSET(IMAGE_NT_HEADERS_XX, OptionalHeader) +
        inh.FileHeader.SizeOfOptionalHeader;

    for (i = 0; i < inh.FileHeader.NumberOfSections; i++) {
        IMAGE_SECTION_HEADER ish;
        ZeroMemory(&ish, sizeof(ish));

        if (!ReadProcessMemory(hProcess, pbModule + dwSec + sizeof(ish) * i, &ish,
                               sizeof(ish), &cbRead)
            || cbRead < sizeof(ish)) {

            DETOUR_TRACE(("ReadProcessMemory(ish@%p..%p) failed: %lu\n",
                          pbModule + dwSec + sizeof(ish) * i,
                          pbModule + dwSec + sizeof(ish) * (i + 1),
                          GetLastError()));
            goto finish;
        }

        DETOUR_TRACE(("ish[%lu] : va=%08lx sr=%lu\n", i, ish.VirtualAddress, ish.SizeOfRawData));
        
        // If the linker didn't suggest an IAT in the data directories, the
        // loader will look for the section of the import directory to be used
        // for this instead. Since we put out new IMPORT_DIRECTORY outside any
        // section boundary, the loader will not find it. So we provide one
        // explicitly to avoid the search.
        //
        if (inh.IAT_DIRECTORY.VirtualAddress == 0 &&
            inh.IMPORT_DIRECTORY.VirtualAddress >= ish.VirtualAddress &&
            inh.IMPORT_DIRECTORY.VirtualAddress < ish.VirtualAddress + ish.SizeOfRawData) {

            inh.IAT_DIRECTORY.VirtualAddress = ish.VirtualAddress;
            inh.IAT_DIRECTORY.Size = ish.SizeOfRawData;
        }
    }

    if (inh.IMPORT_DIRECTORY.VirtualAddress != 0 && inh.IMPORT_DIRECTORY.Size == 0) {

        // Don't worry about changing the PE file, 
        // because the load information of the original PE header has been saved and will be restored. 
        // The change here is just for the following code to work normally

        PIMAGE_IMPORT_DESCRIPTOR pImageImport = (PIMAGE_IMPORT_DESCRIPTOR)(pbModule + inh.IMPORT_DIRECTORY.VirtualAddress);

        do {
            IMAGE_IMPORT_DESCRIPTOR ImageImport;
            if (!ReadProcessMemory(hProcess, pImageImport, &ImageImport, sizeof(ImageImport), NULL)) {
                DETOUR_TRACE(("ReadProcessMemory failed: %lu\n", GetLastError()));
                goto finish;
            }
            inh.IMPORT_DIRECTORY.Size += sizeof(IMAGE_IMPORT_DESCRIPTOR);
            if (!ImageImport.Name) {
                break;
            }
            ++pImageImport;
        } while (TRUE);

        DWORD dwLastError = GetLastError();
        OutputDebugString(TEXT("[This PE file has an import table, but the import table size is marked as 0. This is an error.")
            TEXT("If it is not repaired, the launched program will not work properly, Detours has automatically repaired its import table size for you! ! !]\r\n"));
        if (GetLastError() != dwLastError) {
            SetLastError(dwLastError);
        }
    }

    DETOUR_TRACE(("     Imports: %p..%p\n",
                  pbModule + inh.IMPORT_DIRECTORY.VirtualAddress,
                  pbModule + inh.IMPORT_DIRECTORY.VirtualAddress +
                  inh.IMPORT_DIRECTORY.Size));

    // Calculate new import directory size.  Note that since inh is from another
    // process, inh could have been corrupted. We need to protect against
    // integer overflow in allocation calculations.
    DWORD nOldDlls = inh.IMPORT_DIRECTORY.Size / sizeof(IMAGE_IMPORT_DESCRIPTOR);
    DWORD obRem;
    if (DWordMult(sizeof(IMAGE_IMPORT_DESCRIPTOR), nDlls, &obRem) != S_OK) {
        DETOUR_TRACE(("too many new DLLs.\n"));
        goto finish;
    }
    DWORD obOld;
    if (DWordAdd(obRem, sizeof(IMAGE_IMPORT_DESCRIPTOR) * nOldDlls, &obOld) != S_OK) {
        DETOUR_TRACE(("DLL entries overflow.\n"));
        goto finish;
    }
    DWORD obTab = PadToDwordPtr(obOld);
    // Check for integer overflow.
    if (obTab < obOld) {
        DETOUR_TRACE(("DLL entries padding overflow.\n"));
        goto finish;
    }
    DWORD stSize;
    if (DWordMult(sizeof(DWORD_XX) * 4, nDlls, &stSize) != S_OK) {
        DETOUR_TRACE(("String table overflow.\n"));
        goto finish;
    }
    DWORD obDll;
    if (DWordAdd(obTab, stSize, &obDll) != S_OK) {
        DETOUR_TRACE(("Import table size overflow\n"));
        goto finish;
    }
    DWORD obStr = obDll;
    cbNew = obStr;
    for (n = 0; n < nDlls; n++) {
        if (DWordAdd(cbNew, PadToDword((DWORD)strlen(plpDlls[n]) + 1), &cbNew) != S_OK) {
            DETOUR_TRACE(("Overflow adding string table entry\n"));
            goto finish;
        }
    }
    pbNew = new BYTE [cbNew];
    if (pbNew == NULL) {
        DETOUR_TRACE(("new BYTE [cbNew] failed.\n"));
        goto finish;
    }
    ZeroMemory(pbNew, cbNew);

    PBYTE pbBase = pbModule;
    PBYTE pbNext = pbBase
        + inh.OptionalHeader.BaseOfCode
        + inh.OptionalHeader.SizeOfCode
        + inh.OptionalHeader.SizeOfInitializedData
        + inh.OptionalHeader.SizeOfUninitializedData;
    if (pbBase < pbNext) {
        pbBase = pbNext;
    }
    DETOUR_TRACE(("pbBase = %p\n", pbBase));

    PBYTE pbNewIid = FindAndAllocateNearBase(hProcess, pbModule, pbBase, cbNew);
    if (pbNewIid == NULL) {
        DETOUR_TRACE(("FindAndAllocateNearBase failed.\n"));
        goto finish;
    }

    PIMAGE_IMPORT_DESCRIPTOR piid = (PIMAGE_IMPORT_DESCRIPTOR)pbNew;
    IMAGE_THUNK_DATAXX *pt = NULL;

    DWORD obBase = (DWORD)(pbNewIid - pbModule);
    DWORD dwProtect = 0;

    if (inh.IMPORT_DIRECTORY.VirtualAddress != 0) {
        // Read the old import directory if it exists.
        DETOUR_TRACE(("IMPORT_DIRECTORY perms=%lx\n", dwProtect));

        if (!ReadProcessMemory(hProcess,
                               pbModule + inh.IMPORT_DIRECTORY.VirtualAddress,
                               &piid[nDlls],
                               nOldDlls * sizeof(IMAGE_IMPORT_DESCRIPTOR), &cbRead)
            || cbRead < nOldDlls * sizeof(IMAGE_IMPORT_DESCRIPTOR)) {

            DETOUR_TRACE(("ReadProcessMemory(imports) failed: %lu\n", GetLastError()));
            goto finish;
        }
    }

    for (n = 0; n < nDlls; n++) {
        HRESULT hrRet = StringCchCopyA((char*)pbNew + obStr, cbNew - obStr, plpDlls[n]);
        if (FAILED(hrRet)) {
            DETOUR_TRACE(("StringCchCopyA failed: %08lx\n", hrRet));
            goto finish;
        }

        // After copying the string, we patch up the size "??" bits if any.
        hrRet = ReplaceOptionalSizeA((char*)pbNew + obStr,
                                     cbNew - obStr,
                                     DETOURS_STRINGIFY(DETOURS_BITS_XX));
        if (FAILED(hrRet)) {
            DETOUR_TRACE(("ReplaceOptionalSizeA failed: %08lx\n", hrRet));
            goto finish;
        }

        DWORD nOffset = obTab + (sizeof(IMAGE_THUNK_DATAXX) * (4 * n));
        piid[n].OriginalFirstThunk = obBase + nOffset;
      
        // We need 2 thunks for the import table and 2 thunks for the IAT.
        // One for an ordinal import and one to mark the end of the list.
        pt = ((IMAGE_THUNK_DATAXX*)(pbNew + nOffset));
        pt[0].u1.Ordinal = IMAGE_ORDINAL_FLAG_XX + 1;
        pt[1].u1.Ordinal = 0;

        nOffset = obTab + (sizeof(IMAGE_THUNK_DATAXX) * ((4 * n) + 2));
        piid[n].FirstThunk = obBase + nOffset;
        pt = ((IMAGE_THUNK_DATAXX*)(pbNew + nOffset));
        pt[0].u1.Ordinal = IMAGE_ORDINAL_FLAG_XX + 1;
        pt[1].u1.Ordinal = 0;
        piid[n].TimeDateStamp = 0;
        piid[n].ForwarderChain = 0;
        piid[n].Name = obBase + obStr;

        obStr += PadToDword((DWORD)strlen(plpDlls[n]) + 1);
    }
    _Analysis_assume_(obStr <= cbNew);

#if 0
    for (i = 0; i < nDlls + nOldDlls; i++) {
        DETOUR_TRACE(("%8d. Look=%08x Time=%08x Fore=%08x Name=%08x Addr=%08x\n",
                      i,
                      piid[i].OriginalFirstThunk,
                      piid[i].TimeDateStamp,
                      piid[i].ForwarderChain,
                      piid[i].Name,
                      piid[i].FirstThunk));
        if (piid[i].OriginalFirstThunk == 0 && piid[i].FirstThunk == 0) {
            break;
        }
    }
#endif

    if (!WriteProcessMemory(hProcess, pbNewIid, pbNew, obStr, NULL)) {
        DETOUR_TRACE(("WriteProcessMemory(iid) failed: %lu\n", GetLastError()));
        goto finish;
    }

    DETOUR_TRACE(("obBaseBef = %08lx..%08lx\n",
                  inh.IMPORT_DIRECTORY.VirtualAddress,
                  inh.IMPORT_DIRECTORY.VirtualAddress + inh.IMPORT_DIRECTORY.Size));
    DETOUR_TRACE(("obBaseAft = %08lx..%08lx\n", obBase, obBase + obStr));

    // In this case the file didn't have an import directory in first place,
    // so we couldn't fix the missing IAT above. We still need to explicitly
    // provide an IAT to prevent to loader from looking for one.
    //
    if (inh.IAT_DIRECTORY.VirtualAddress == 0) {
        inh.IAT_DIRECTORY.VirtualAddress = obBase;
        inh.IAT_DIRECTORY.Size = cbNew;
    }

    inh.IMPORT_DIRECTORY.VirtualAddress = obBase;
    inh.IMPORT_DIRECTORY.Size = cbNew;

    /////////////////////// Update the NT header for the new import directory.
    //
    if (!DetourVirtualProtectSameExecuteEx(hProcess, pbModule, inh.OptionalHeader.SizeOfHeaders,
                                           PAGE_EXECUTE_READWRITE, &dwProtect)) {
        DETOUR_TRACE(("VirtualProtectEx(inh) write failed: %lu\n", GetLastError()));
        goto finish;
    }

    inh.OptionalHeader.CheckSum = 0;

    if (!WriteProcessMemory(hProcess, pbModule, &idh, sizeof(idh), NULL)) {
        DETOUR_TRACE(("WriteProcessMemory(idh) failed: %lu\n", GetLastError()));
        goto finish;
    }
    DETOUR_TRACE(("WriteProcessMemory(idh:%p..%p)\n", pbModule, pbModule + sizeof(idh)));

    if (!WriteProcessMemory(hProcess, pbModule + idh.e_lfanew, &inh, sizeof(inh), NULL)) {
        DETOUR_TRACE(("WriteProcessMemory(inh) failed: %lu\n", GetLastError()));
        goto finish;
    }
    DETOUR_TRACE(("WriteProcessMemory(inh:%p..%p)\n",
                  pbModule + idh.e_lfanew,
                  pbModule + idh.e_lfanew + sizeof(inh)));

    if (!VirtualProtectEx(hProcess, pbModule, inh.OptionalHeader.SizeOfHeaders,
                          dwProtect, &dwProtect)) {
        DETOUR_TRACE(("VirtualProtectEx(idh) restore failed: %lu\n", GetLastError()));
        goto finish;
    }

    fSucceeded = TRUE;
    goto finish;
}

```

`system.mak`:

```mak
##############################################################################
##
##  Establish build target type for Detours.
##
##  Microsoft Research Detours Package
##
##  Copyright (c) Microsoft Corporation.  All rights reserved.
##

############################################## Determine Processor Build Type.
#
# Default the detours architecture to match the compiler target that
# has been selected by the user via the VS Developer Command Prompt
# they launched.
!IF "$(DETOURS_TARGET_PROCESSOR)" == "" && "$(VSCMD_ARG_TGT_ARCH)" != ""
DETOURS_TARGET_PROCESSOR = $(VSCMD_ARG_TGT_ARCH)
!ENDIF

!IF "$(DETOURS_TARGET_PROCESSOR)" == "" && "$(PROCESSOR_ARCHITEW6432)" != ""
DETOURS_TARGET_PROCESSOR = X86
!ENDIF

!IF "$(DETOURS_TARGET_PROCESSOR)" == ""
DETOURS_TARGET_PROCESSOR = $(PROCESSOR_ARCHITECTURE)
!ENDIF

# Uppercase DETOURS_TARGET_PROCESSOR
DETOURS_TARGET_PROCESSOR=$(DETOURS_TARGET_PROCESSOR:a=A)
DETOURS_TARGET_PROCESSOR=$(DETOURS_TARGET_PROCESSOR:b=B)
DETOURS_TARGET_PROCESSOR=$(DETOURS_TARGET_PROCESSOR:c=C)
DETOURS_TARGET_PROCESSOR=$(DETOURS_TARGET_PROCESSOR:d=D)
DETOURS_TARGET_PROCESSOR=$(DETOURS_TARGET_PROCESSOR:e=E)
DETOURS_TARGET_PROCESSOR=$(DETOURS_TARGET_PROCESSOR:f=F)
DETOURS_TARGET_PROCESSOR=$(DETOURS_TARGET_PROCESSOR:g=G)
DETOURS_TARGET_PROCESSOR=$(DETOURS_TARGET_PROCESSOR:h=H)
DETOURS_TARGET_PROCESSOR=$(DETOURS_TARGET_PROCESSOR:i=I)
DETOURS_TARGET_PROCESSOR=$(DETOURS_TARGET_PROCESSOR:j=J)
DETOURS_TARGET_PROCESSOR=$(DETOURS_TARGET_PROCESSOR:k=K)
DETOURS_TARGET_PROCESSOR=$(DETOURS_TARGET_PROCESSOR:l=L)
DETOURS_TARGET_PROCESSOR=$(DETOURS_TARGET_PROCESSOR:m=M)
DETOURS_TARGET_PROCESSOR=$(DETOURS_TARGET_PROCESSOR:n=N)
DETOURS_TARGET_PROCESSOR=$(DETOURS_TARGET_PROCESSOR:o=O)
DETOURS_TARGET_PROCESSOR=$(DETOURS_TARGET_PROCESSOR:p=P)
DETOURS_TARGET_PROCESSOR=$(DETOURS_TARGET_PROCESSOR:q=Q)
DETOURS_TARGET_PROCESSOR=$(DETOURS_TARGET_PROCESSOR:r=R)
DETOURS_TARGET_PROCESSOR=$(DETOURS_TARGET_PROCESSOR:s=S)
DETOURS_TARGET_PROCESSOR=$(DETOURS_TARGET_PROCESSOR:t=T)
DETOURS_TARGET_PROCESSOR=$(DETOURS_TARGET_PROCESSOR:u=U)
DETOURS_TARGET_PROCESSOR=$(DETOURS_TARGET_PROCESSOR:v=V)
DETOURS_TARGET_PROCESSOR=$(DETOURS_TARGET_PROCESSOR:w=W)
DETOURS_TARGET_PROCESSOR=$(DETOURS_TARGET_PROCESSOR:x=X)
DETOURS_TARGET_PROCESSOR=$(DETOURS_TARGET_PROCESSOR:y=Y)
DETOURS_TARGET_PROCESSOR=$(DETOURS_TARGET_PROCESSOR:z=Z)

!IF "$(DETOURS_TARGET_PROCESSOR)" == "AMD64"
DETOURS_TARGET_PROCESSOR = X64
!ENDIF


!if "$(DETOURS_TARGET_PROCESSOR:64=)" == "$(DETOURS_TARGET_PROCESSOR)"
DETOURS_32BIT=1
DETOURS_BITS=32
!else
DETOURS_64BIT=1
DETOURS_BITS=64
!endif

########################################## Configure build based on Processor.
##
## DETOURS_OPTION_PROCESSOR: Set this macro if the processor *will* run code
##                           from another ISA (i.e. x86 on x64).
##
##      DETOURS_OPTION_BITS: Set this macro if the processor *may* have
##                           an alternative word size.
##
!IF "$(DETOURS_TARGET_PROCESSOR)" == "X64"
#!MESSAGE Building for 64-bit X64.
DETOURS_SOURCE_BROWSING = 0
DETOURS_OPTION_PROCESSOR=X86
DETOURS_OPTION_BITS=32
!ELSEIF "$(DETOURS_TARGET_PROCESSOR)" == "IA64"
#!MESSAGE Building for 64-bit IA64.
DETOURS_OPTION_PROCESSOR=X86
DETOURS_OPTION_BITS=32
!ELSEIF "$(DETOURS_TARGET_PROCESSOR)" == "X86"
#!MESSAGE Building for 32-bit X86.
DETOURS_OPTION_BITS=64
# Don't set DETOURS_OPTION_PROCESSOR for x64 because we don't *know* that
# we'll run on a 64-bit machine.
!ELSEIF "$(DETOURS_TARGET_PROCESSOR)" == "ARM"
#!MESSAGE Building for 32-bit ARM.
!ELSEIF "$(DETOURS_TARGET_PROCESSOR)" == "ARM64"
#!MESSAGE Building for 64-bit ARM.
!ELSE
!MESSAGE Note: To select the target processor architecture set either
!MESSAGE       PROCESSOR_ARCHITECTURE or DETOURS_TARGET_PROCESSOR.
!MESSAGE
!ERROR Unknown target processor: "$(DETOURS_TARGET_PROCESSOR)"
!ENDIF

##############################################################################
##
!IF "$(DETOURS_CONFIG)" == "Debug"
DETOURS_DEBUG=1
!ELSE
DETOURS_DEBUG=0
!ENDIF

INCD = $(ROOT)\include
LIBD = $(ROOT)\lib.$(DETOURS_TARGET_PROCESSOR)$(DETOURS_CONFIG)
BIND = $(ROOT)\bin.$(DETOURS_TARGET_PROCESSOR)$(DETOURS_CONFIG)
OBJD = obj.$(DETOURS_TARGET_PROCESSOR)$(DETOURS_CONFIG)
!IF "$(DETOURS_OPTION_PROCESSOR)" != ""
OPTD = $(ROOT)\bin.$(DETOURS_OPTION_PROCESSOR)$(DETOURS_CONFIG)
!ENDIF

INCDS = $(ROOT)\include

LIBDS = \
        $(ROOT)\lib.x86$(DETOURS_CONFIG) \
        $(ROOT)\lib.x64$(DETOURS_CONFIG) \
        $(ROOT)\lib.ia64$(DETOURS_CONFIG) \
        $(ROOT)\lib.arm$(DETOURS_CONFIG) \
        $(ROOT)\lib.arm64$(DETOURS_CONFIG) \

BINDS = \
        $(ROOT)\bin.x86$(DETOURS_CONFIG) \
        $(ROOT)\bin.x64$(DETOURS_CONFIG) \
        $(ROOT)\bin.ia64$(DETOURS_CONFIG) \
        $(ROOT)\bin.arm$(DETOURS_CONFIG) \
        $(ROOT)\bin.arm64$(DETOURS_CONFIG) \

OBJDS = \
        obj.x86$(DETOURS_CONFIG) \
        obj.x64$(DETOURS_CONFIG) \
        obj.ia64$(DETOURS_CONFIG) \
        obj.arm$(DETOURS_CONFIG) \
        obj.arm64$(DETOURS_CONFIG) \

##############################################################################

```

`tests/Makefile`:

```
##############################################################################
##
##  Detours Unit Tests.
##
##  Microsoft Research Detours Package
##
##  Copyright (c) Microsoft Corporation.  All rights reserved.
##

ROOT = ..
!include ..\samples\common.mak

DEPS = $(LIBD)\detours.lib
LIBS=$(LIBS) kernel32.lib rpcrt4.lib
CFLAGS=$(CFLAGS) /EHsc /DCATCH_CONFIG_NO_WINDOWS_SEH

##############################################################################

all: dirs \
    $(BIND)\unittests.exe \
    \

##############################################################################

dirs:
    @if not exist $(BIND) mkdir $(BIND) && echo.   Created $(BIND)
    @if not exist $(OBJD) mkdir $(OBJD) && echo.   Created $(OBJD)

$(OBJD)\main.obj : main.cpp
$(OBJD)\test_module_api.obj : test_module_api.cpp
$(OBJD)\test_image_api.obj : test_image_api.cpp
$(OBJD)\corruptor.obj : corruptor.cpp
$(OBJD)\process_helpers.obj : process_helpers.cpp
$(OBJD)\payload.obj : payload.cpp

$(BIND)\unittests.exe : $(OBJD)\main.obj \
                        $(OBJD)\test_module_api.obj \
                        $(OBJD)\test_image_api.obj \
                        $(OBJD)\corruptor.obj \
                        $(OBJD)\process_helpers.obj \
                        $(OBJD)\payload.obj $(DEPS)
    cl $(CFLAGS) /Fe$@ /Fd$(@R).pdb \
        $(OBJD)\main.obj \
        $(OBJD)\test_module_api.obj \
        $(OBJD)\test_image_api.obj \
        $(OBJD)\corruptor.obj \
        $(OBJD)\process_helpers.obj \
        $(OBJD)\payload.obj \
        /link $(LINKFLAGS) $(LIBS) /subsystem:console

##############################################################################

clean:
    -del *~ 2>nul
    -del $(BIND)\unittests*.* 2>nul
    -rmdir /q /s $(OBJD) 2>nul

realclean: clean
    -rmdir /q /s $(OBJDS) 2>nul

option:
##############################################################################

test: all
    @cls
    $(BIND)\unittests.exe --reporter console --success --durations yes

debug: all
    windbg -o $(BIND)\unittests.exe


################################################################# End of File.

```

`tests/catch.hpp`:

```hpp
/*
 *  Catch v2.13.0
 *  Generated: 2020-07-12 20:07:49.015950
 *  ----------------------------------------------------------
 *  This file has been merged from multiple headers. Please don't edit it directly
 *  Copyright (c) 2020 Two Blue Cubes Ltd. All rights reserved.
 *
 *  Distributed under the Boost Software License, Version 1.0. (See accompanying
 *  file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
 */
#ifndef TWOBLUECUBES_SINGLE_INCLUDE_CATCH_HPP_INCLUDED
#define TWOBLUECUBES_SINGLE_INCLUDE_CATCH_HPP_INCLUDED
// start catch.hpp


#define CATCH_VERSION_MAJOR 2
#define CATCH_VERSION_MINOR 13
#define CATCH_VERSION_PATCH 0

#ifdef __clang__
#    pragma clang system_header
#elif defined __GNUC__
#    pragma GCC system_header
#endif

// start catch_suppress_warnings.h

#ifdef __clang__
#   ifdef __ICC // icpc defines the __clang__ macro
#       pragma warning(push)
#       pragma warning(disable: 161 1682)
#   else // __ICC
#       pragma clang diagnostic push
#       pragma clang diagnostic ignored "-Wpadded"
#       pragma clang diagnostic ignored "-Wswitch-enum"
#       pragma clang diagnostic ignored "-Wcovered-switch-default"
#    endif
#elif defined __GNUC__
     // Because REQUIREs trigger GCC's -Wparentheses, and because still
     // supported version of g++ have only buggy support for _Pragmas,
     // Wparentheses have to be suppressed globally.
#    pragma GCC diagnostic ignored "-Wparentheses" // See #674 for details

#    pragma GCC diagnostic push
#    pragma GCC diagnostic ignored "-Wunused-variable"
#    pragma GCC diagnostic ignored "-Wpadded"
#endif
// end catch_suppress_warnings.h
#if defined(CATCH_CONFIG_MAIN) || defined(CATCH_CONFIG_RUNNER)
#  define CATCH_IMPL
#  define CATCH_CONFIG_ALL_PARTS
#endif

// In the impl file, we want to have access to all parts of the headers
// Can also be used to sanely support PCHs
#if defined(CATCH_CONFIG_ALL_PARTS)
#  define CATCH_CONFIG_EXTERNAL_INTERFACES
#  if defined(CATCH_CONFIG_DISABLE_MATCHERS)
#    undef CATCH_CONFIG_DISABLE_MATCHERS
#  endif
#  if !defined(CATCH_CONFIG_ENABLE_CHRONO_STRINGMAKER)
#    define CATCH_CONFIG_ENABLE_CHRONO_STRINGMAKER
#  endif
#endif

#if !defined(CATCH_CONFIG_IMPL_ONLY)
// start catch_platform.h

#ifdef __APPLE__
# include <TargetConditionals.h>
# if TARGET_OS_OSX == 1
#  define CATCH_PLATFORM_MAC
# elif TARGET_OS_IPHONE == 1
#  define CATCH_PLATFORM_IPHONE
# endif

#elif defined(linux) || defined(__linux) || defined(__linux__)
#  define CATCH_PLATFORM_LINUX

#elif defined(WIN32) || defined(__WIN32__) || defined(_WIN32) || defined(_MSC_VER) || defined(__MINGW32__)
#  define CATCH_PLATFORM_WINDOWS
#endif

// end catch_platform.h

#ifdef CATCH_IMPL
#  ifndef CLARA_CONFIG_MAIN
#    define CLARA_CONFIG_MAIN_NOT_DEFINED
#    define CLARA_CONFIG_MAIN
#  endif
#endif

// start catch_user_interfaces.h

namespace Catch {
    unsigned int rngSeed();
}

// end catch_user_interfaces.h
// start catch_tag_alias_autoregistrar.h

// start catch_common.h

// start catch_compiler_capabilities.h

// Detect a number of compiler features - by compiler
// The following features are defined:
//
// CATCH_CONFIG_COUNTER : is the __COUNTER__ macro supported?
// CATCH_CONFIG_WINDOWS_SEH : is Windows SEH supported?
// CATCH_CONFIG_POSIX_SIGNALS : are POSIX signals supported?
// CATCH_CONFIG_DISABLE_EXCEPTIONS : Are exceptions enabled?
// ****************
// Note to maintainers: if new toggles are added please document them
// in configuration.md, too
// ****************

// In general each macro has a _NO_<feature name> form
// (e.g. CATCH_CONFIG_NO_POSIX_SIGNALS) which disables the feature.
// Many features, at point of detection, define an _INTERNAL_ macro, so they
// can be combined, en-mass, with the _NO_ forms later.

#ifdef __cplusplus

#  if (__cplusplus >= 201402L) || (defined(_MSVC_LANG) && _MSVC_LANG >= 201402L)
#    define CATCH_CPP14_OR_GREATER
#  endif

#  if (__cplusplus >= 201703L) || (defined(_MSVC_LANG) && _MSVC_LANG >= 201703L)
#    define CATCH_CPP17_OR_GREATER
#  endif

#endif

#if defined(__cpp_lib_uncaught_exceptions)
#  define CATCH_INTERNAL_CONFIG_CPP17_UNCAUGHT_EXCEPTIONS
#endif

// We have to avoid both ICC and Clang, because they try to mask themselves
// as gcc, and we want only GCC in this block
#if defined(__GNUC__) && !defined(__clang__) && !defined(__ICC)
#    define CATCH_INTERNAL_START_WARNINGS_SUPPRESSION _Pragma( "GCC diagnostic push" )
#    define CATCH_INTERNAL_STOP_WARNINGS_SUPPRESSION  _Pragma( "GCC diagnostic pop" )

#    define CATCH_INTERNAL_IGNORE_BUT_WARN(...) (void)__builtin_constant_p(__VA_ARGS__)

#endif

#if defined(__clang__)

#    define CATCH_INTERNAL_START_WARNINGS_SUPPRESSION _Pragma( "clang diagnostic push" )
#    define CATCH_INTERNAL_STOP_WARNINGS_SUPPRESSION  _Pragma( "clang diagnostic pop" )

// As of this writing, IBM XL's implementation of __builtin_constant_p has a bug
// which results in calls to destructors being emitted for each temporary,
// without a matching initialization. In practice, this can result in something
// like `std::string::~string` being called on an uninitialized value.
//
// For example, this code will likely segfault under IBM XL:
// ```
// REQUIRE(std::string("12") + "34" == "1234")
// ```
//
// Therefore, `CATCH_INTERNAL_IGNORE_BUT_WARN` is not implemented.
#  if !defined(__ibmxl__)
#    define CATCH_INTERNAL_IGNORE_BUT_WARN(...) (void)__builtin_constant_p(__VA_ARGS__) /* NOLINT(cppcoreguidelines-pro-type-vararg, hicpp-vararg) */
#  endif

#    define CATCH_INTERNAL_SUPPRESS_GLOBALS_WARNINGS \
         _Pragma( "clang diagnostic ignored \"-Wexit-time-destructors\"" ) \
         _Pragma( "clang diagnostic ignored \"-Wglobal-constructors\"")

#    define CATCH_INTERNAL_SUPPRESS_PARENTHESES_WARNINGS \
         _Pragma( "clang diagnostic ignored \"-Wparentheses\"" )

#    define CATCH_INTERNAL_SUPPRESS_UNUSED_WARNINGS \
         _Pragma( "clang diagnostic ignored \"-Wunused-variable\"" )

#    define CATCH_INTERNAL_SUPPRESS_ZERO_VARIADIC_WARNINGS \
         _Pragma( "clang diagnostic ignored \"-Wgnu-zero-variadic-macro-arguments\"" )

#    define CATCH_INTERNAL_SUPPRESS_UNUSED_TEMPLATE_WARNINGS \
         _Pragma( "clang diagnostic ignored \"-Wunused-template\"" )

#endif // __clang__

////////////////////////////////////////////////////////////////////////////////
// Assume that non-Windows platforms support posix signals by default
#if !defined(CATCH_PLATFORM_WINDOWS)
    #define CATCH_INTERNAL_CONFIG_POSIX_SIGNALS
#endif

////////////////////////////////////////////////////////////////////////////////
// We know some environments not to support full POSIX signals
#if defined(__CYGWIN__) || defined(__QNX__) || defined(__EMSCRIPTEN__) || defined(__DJGPP__)
    #define CATCH_INTERNAL_CONFIG_NO_POSIX_SIGNALS
#endif

#ifdef __OS400__
#       define CATCH_INTERNAL_CONFIG_NO_POSIX_SIGNALS
#       define CATCH_CONFIG_COLOUR_NONE
#endif

////////////////////////////////////////////////////////////////////////////////
// Android somehow still does not support std::to_string
#if defined(__ANDROID__)
#    define CATCH_INTERNAL_CONFIG_NO_CPP11_TO_STRING
#    define CATCH_INTERNAL_CONFIG_ANDROID_LOGWRITE
#endif

////////////////////////////////////////////////////////////////////////////////
// Not all Windows environments support SEH properly
#if defined(__MINGW32__)
#    define CATCH_INTERNAL_CONFIG_NO_WINDOWS_SEH
#endif

////////////////////////////////////////////////////////////////////////////////
// PS4
#if defined(__ORBIS__)
#    define CATCH_INTERNAL_CONFIG_NO_NEW_CAPTURE
#endif

////////////////////////////////////////////////////////////////////////////////
// Cygwin
#ifdef __CYGWIN__

// Required for some versions of Cygwin to declare gettimeofday
// see: http://stackoverflow.com/questions/36901803/gettimeofday-not-declared-in-this-scope-cygwin
#   define _BSD_SOURCE
// some versions of cygwin (most) do not support std::to_string. Use the libstd check.
// https://gcc.gnu.org/onlinedocs/gcc-4.8.2/libstdc++/api/a01053_source.html line 2812-2813
# if !((__cplusplus >= 201103L) && defined(_GLIBCXX_USE_C99) \
           && !defined(_GLIBCXX_HAVE_BROKEN_VSWPRINTF))

#    define CATCH_INTERNAL_CONFIG_NO_CPP11_TO_STRING

# endif
#endif // __CYGWIN__

////////////////////////////////////////////////////////////////////////////////
// Visual C++
#if defined(_MSC_VER)

#  define CATCH_INTERNAL_START_WARNINGS_SUPPRESSION __pragma( warning(push) )
#  define CATCH_INTERNAL_STOP_WARNINGS_SUPPRESSION  __pragma( warning(pop) )

#  if _MSC_VER >= 1900 // Visual Studio 2015 or newer
#    define CATCH_INTERNAL_CONFIG_CPP17_UNCAUGHT_EXCEPTIONS
#  endif

// Universal Windows platform does not support SEH
// Or console colours (or console at all...)
#  if defined(WINAPI_FAMILY) && (WINAPI_FAMILY == WINAPI_FAMILY_APP)
#    define CATCH_CONFIG_COLOUR_NONE
#  else
#    define CATCH_INTERNAL_CONFIG_WINDOWS_SEH
#  endif

// MSVC traditional preprocessor needs some workaround for __VA_ARGS__
// _MSVC_TRADITIONAL == 0 means new conformant preprocessor
// _MSVC_TRADITIONAL == 1 means old traditional non-conformant preprocessor
#  if !defined(__clang__) // Handle Clang masquerading for msvc
#    if !defined(_MSVC_TRADITIONAL) || (defined(_MSVC_TRADITIONAL) && _MSVC_TRADITIONAL)
#      define CATCH_INTERNAL_CONFIG_TRADITIONAL_MSVC_PREPROCESSOR
#    endif // MSVC_TRADITIONAL
#  endif // __clang__

#endif // _MSC_VER

#if defined(_REENTRANT) || defined(_MSC_VER)
// Enable async processing, as -pthread is specified or no additional linking is required
# define CATCH_INTERNAL_CONFIG_USE_ASYNC
#endif // _MSC_VER

////////////////////////////////////////////////////////////////////////////////
// Check if we are compiled with -fno-exceptions or equivalent
#if defined(__EXCEPTIONS) || defined(__cpp_exceptions) || defined(_CPPUNWIND)
#  define CATCH_INTERNAL_CONFIG_EXCEPTIONS_ENABLED
#endif

////////////////////////////////////////////////////////////////////////////////
// DJGPP
#ifdef __DJGPP__
#  define CATCH_INTERNAL_CONFIG_NO_WCHAR
#endif // __DJGPP__

////////////////////////////////////////////////////////////////////////////////
// Embarcadero C++Build
#if defined(__BORLANDC__)
    #define CATCH_INTERNAL_CONFIG_POLYFILL_ISNAN
#endif

////////////////////////////////////////////////////////////////////////////////

// Use of __COUNTER__ is suppressed during code analysis in
// CLion/AppCode 2017.2.x and former, because __COUNTER__ is not properly
// handled by it.
// Otherwise all supported compilers support COUNTER macro,
// but user still might want to turn it off
#if ( !defined(__JETBRAINS_IDE__) || __JETBRAINS_IDE__ >= 20170300L )
    #define CATCH_INTERNAL_CONFIG_COUNTER
#endif

////////////////////////////////////////////////////////////////////////////////

// RTX is a special version of Windows that is real time.
// This means that it is detected as Windows, but does not provide
// the same set of capabilities as real Windows does.
#if defined(UNDER_RTSS) || defined(RTX64_BUILD)
    #define CATCH_INTERNAL_CONFIG_NO_WINDOWS_SEH
    #define CATCH_INTERNAL_CONFIG_NO_ASYNC
    #define CATCH_CONFIG_COLOUR_NONE
#endif

#if !defined(_GLIBCXX_USE_C99_MATH_TR1)
#define CATCH_INTERNAL_CONFIG_GLOBAL_NEXTAFTER
#endif

// Various stdlib support checks that require __has_include
#if defined(__has_include)
  // Check if string_view is available and usable
  #if __has_include(<string_view>) && defined(CATCH_CPP17_OR_GREATER)
  #    define CATCH_INTERNAL_CONFIG_CPP17_STRING_VIEW
  #endif

  // Check if optional is available and usable
  #  if __has_include(<optional>) && defined(CATCH_CPP17_OR_GREATER)
  #    define CATCH_INTERNAL_CONFIG_CPP17_OPTIONAL
  #  endif // __has_include(<optional>) && defined(CATCH_CPP17_OR_GREATER)

  // Check if byte is available and usable
  #  if __has_include(<cstddef>) && defined(CATCH_CPP17_OR_GREATER)
  #    define CATCH_INTERNAL_CONFIG_CPP17_BYTE
  #  endif // __has_include(<cstddef>) && defined(CATCH_CPP17_OR_GREATER)

  // Check if variant is available and usable
  #  if __has_include(<variant>) && defined(CATCH_CPP17_OR_GREATER)
  #    if defined(__clang__) && (__clang_major__ < 8)
         // work around clang bug with libstdc++ https://bugs.llvm.org/show_bug.cgi?id=31852
         // fix should be in clang 8, workaround in libstdc++ 8.2
  #      include <ciso646>
  #      if defined(__GLIBCXX__) && defined(_GLIBCXX_RELEASE) && (_GLIBCXX_RELEASE < 9)
  #        define CATCH_CONFIG_NO_CPP17_VARIANT
  #      else
  #        define CATCH_INTERNAL_CONFIG_CPP17_VARIANT
  #      endif // defined(__GLIBCXX__) && defined(_GLIBCXX_RELEASE) && (_GLIBCXX_RELEASE < 9)
  #    else
  #      define CATCH_INTERNAL_CONFIG_CPP17_VARIANT
  #    endif // defined(__clang__) && (__clang_major__ < 8)
  #  endif // __has_include(<variant>) && defined(CATCH_CPP17_OR_GREATER)
#endif // defined(__has_include)

#if defined(CATCH_INTERNAL_CONFIG_COUNTER) && !defined(CATCH_CONFIG_NO_COUNTER) && !defined(CATCH_CONFIG_COUNTER)
#   define CATCH_CONFIG_COUNTER
#endif
#if defined(CATCH_INTERNAL_CONFIG_WINDOWS_SEH) && !defined(CATCH_CONFIG_NO_WINDOWS_SEH) && !defined(CATCH_CONFIG_WINDOWS_SEH) && !defined(CATCH_INTERNAL_CONFIG_NO_WINDOWS_SEH)
#   define CATCH_CONFIG_WINDOWS_SEH
#endif
// This is set by default, because we assume that unix compilers are posix-signal-compatible by default.
#if defined(CATCH_INTERNAL_CONFIG_POSIX_SIGNALS) && !defined(CATCH_INTERNAL_CONFIG_NO_POSIX_SIGNALS) && !defined(CATCH_CONFIG_NO_POSIX_SIGNALS) && !defined(CATCH_CONFIG_POSIX_SIGNALS)
#   define CATCH_CONFIG_POSIX_SIGNALS
#endif
// This is set by default, because we assume that compilers with no wchar_t support are just rare exceptions.
#if !defined(CATCH_INTERNAL_CONFIG_NO_WCHAR) && !defined(CATCH_CONFIG_NO_WCHAR) && !defined(CATCH_CONFIG_WCHAR)
#   define CATCH_CONFIG_WCHAR
#endif

#if !defined(CATCH_INTERNAL_CONFIG_NO_CPP11_TO_STRING) && !defined(CATCH_CONFIG_NO_CPP11_TO_STRING) && !defined(CATCH_CONFIG_CPP11_TO_STRING)
#    define CATCH_CONFIG_CPP11_TO_STRING
#endif

#if defined(CATCH_INTERNAL_CONFIG_CPP17_OPTIONAL) && !defined(CATCH_CONFIG_NO_CPP17_OPTIONAL) && !defined(CATCH_CONFIG_CPP17_OPTIONAL)
#  define CATCH_CONFIG_CPP17_OPTIONAL
#endif

#if defined(CATCH_INTERNAL_CONFIG_CPP17_UNCAUGHT_EXCEPTIONS) && !defined(CATCH_CONFIG_NO_CPP17_UNCAUGHT_EXCEPTIONS) && !defined(CATCH_CONFIG_CPP17_UNCAUGHT_EXCEPTIONS)
#  define CATCH_CONFIG_CPP17_UNCAUGHT_EXCEPTIONS
#endif

#if defined(CATCH_INTERNAL_CONFIG_CPP17_STRING_VIEW) && !defined(CATCH_CONFIG_NO_CPP17_STRING_VIEW) && !defined(CATCH_CONFIG_CPP17_STRING_VIEW)
#  define CATCH_CONFIG_CPP17_STRING_VIEW
#endif

#if defined(CATCH_INTERNAL_CONFIG_CPP17_VARIANT) && !defined(CATCH_CONFIG_NO_CPP17_VARIANT) && !defined(CATCH_CONFIG_CPP17_VARIANT)
#  define CATCH_CONFIG_CPP17_VARIANT
#endif

#if defined(CATCH_INTERNAL_CONFIG_CPP17_BYTE) && !defined(CATCH_CONFIG_NO_CPP17_BYTE) && !defined(CATCH_CONFIG_CPP17_BYTE)
#  define CATCH_CONFIG_CPP17_BYTE
#endif

#if defined(CATCH_CONFIG_EXPERIMENTAL_REDIRECT)
#  define CATCH_INTERNAL_CONFIG_NEW_CAPTURE
#endif

#if defined(CATCH_INTERNAL_CONFIG_NEW_CAPTURE) && !defined(CATCH_INTERNAL_CONFIG_NO_NEW_CAPTURE) && !defined(CATCH_CONFIG_NO_NEW_CAPTURE) && !defined(CATCH_CONFIG_NEW_CAPTURE)
#  define CATCH_CONFIG_NEW_CAPTURE
#endif

#if !defined(CATCH_INTERNAL_CONFIG_EXCEPTIONS_ENABLED) && !defined(CATCH_CONFIG_DISABLE_EXCEPTIONS)
#  define CATCH_CONFIG_DISABLE_EXCEPTIONS
#endif

#if defined(CATCH_INTERNAL_CONFIG_POLYFILL_ISNAN) && !defined(CATCH_CONFIG_NO_POLYFILL_ISNAN) && !defined(CATCH_CONFIG_POLYFILL_ISNAN)
#  define CATCH_CONFIG_POLYFILL_ISNAN
#endif

#if defined(CATCH_INTERNAL_CONFIG_USE_ASYNC)  && !defined(CATCH_INTERNAL_CONFIG_NO_ASYNC) && !defined(CATCH_CONFIG_NO_USE_ASYNC) && !defined(CATCH_CONFIG_USE_ASYNC)
#  define CATCH_CONFIG_USE_ASYNC
#endif

#if defined(CATCH_INTERNAL_CONFIG_ANDROID_LOGWRITE) && !defined(CATCH_CONFIG_NO_ANDROID_LOGWRITE) && !defined(CATCH_CONFIG_ANDROID_LOGWRITE)
#  define CATCH_CONFIG_ANDROID_LOGWRITE
#endif

#if defined(CATCH_INTERNAL_CONFIG_GLOBAL_NEXTAFTER) && !defined(CATCH_CONFIG_NO_GLOBAL_NEXTAFTER) && !defined(CATCH_CONFIG_GLOBAL_NEXTAFTER)
#  define CATCH_CONFIG_GLOBAL_NEXTAFTER
#endif

// Even if we do not think the compiler has that warning, we still have
// to provide a macro that can be used by the code.
#if !defined(CATCH_INTERNAL_START_WARNINGS_SUPPRESSION)
#   define CATCH_INTERNAL_START_WARNINGS_SUPPRESSION
#endif
#if !defined(CATCH_INTERNAL_STOP_WARNINGS_SUPPRESSION)
#   define CATCH_INTERNAL_STOP_WARNINGS_SUPPRESSION
#endif
#if !defined(CATCH_INTERNAL_SUPPRESS_PARENTHESES_WARNINGS)
#   define CATCH_INTERNAL_SUPPRESS_PARENTHESES_WARNINGS
#endif
#if !defined(CATCH_INTERNAL_SUPPRESS_GLOBALS_WARNINGS)
#   define CATCH_INTERNAL_SUPPRESS_GLOBALS_WARNINGS
#endif
#if !defined(CATCH_INTERNAL_SUPPRESS_UNUSED_WARNINGS)
#   define CATCH_INTERNAL_SUPPRESS_UNUSED_WARNINGS
#endif
#if !defined(CATCH_INTERNAL_SUPPRESS_ZERO_VARIADIC_WARNINGS)
#   define CATCH_INTERNAL_SUPPRESS_ZERO_VARIADIC_WARNINGS
#endif

// The goal of this macro is to avoid evaluation of the arguments, but
// still have the compiler warn on problems inside...
#if !defined(CATCH_INTERNAL_IGNORE_BUT_WARN)
#   define CATCH_INTERNAL_IGNORE_BUT_WARN(...)
#endif

#if defined(__APPLE__) && defined(__apple_build_version__) && (__clang_major__ < 10)
#   undef CATCH_INTERNAL_SUPPRESS_UNUSED_TEMPLATE_WARNINGS
#elif defined(__clang__) && (__clang_major__ < 5)
#   undef CATCH_INTERNAL_SUPPRESS_UNUSED_TEMPLATE_WARNINGS
#endif

#if !defined(CATCH_INTERNAL_SUPPRESS_UNUSED_TEMPLATE_WARNINGS)
#   define CATCH_INTERNAL_SUPPRESS_UNUSED_TEMPLATE_WARNINGS
#endif

#if defined(CATCH_CONFIG_DISABLE_EXCEPTIONS)
#define CATCH_TRY if ((true))
#define CATCH_CATCH_ALL if ((false))
#define CATCH_CATCH_ANON(type) if ((false))
#else
#define CATCH_TRY try
#define CATCH_CATCH_ALL catch (...)
#define CATCH_CATCH_ANON(type) catch (type)
#endif

#if defined(CATCH_INTERNAL_CONFIG_TRADITIONAL_MSVC_PREPROCESSOR) && !defined(CATCH_CONFIG_NO_TRADITIONAL_MSVC_PREPROCESSOR) && !defined(CATCH_CONFIG_TRADITIONAL_MSVC_PREPROCESSOR)
#define CATCH_CONFIG_TRADITIONAL_MSVC_PREPROCESSOR
#endif

// end catch_compiler_capabilities.h
#define INTERNAL_CATCH_UNIQUE_NAME_LINE2( name, line ) name##line
#define INTERNAL_CATCH_UNIQUE_NAME_LINE( name, line ) INTERNAL_CATCH_UNIQUE_NAME_LINE2( name, line )
#ifdef CATCH_CONFIG_COUNTER
#  define INTERNAL_CATCH_UNIQUE_NAME( name ) INTERNAL_CATCH_UNIQUE_NAME_LINE( name, __COUNTER__ )
#else
#  define INTERNAL_CATCH_UNIQUE_NAME( name ) INTERNAL_CATCH_UNIQUE_NAME_LINE( name, __LINE__ )
#endif

#include <iosfwd>
#include <string>
#include <cstdint>

// We need a dummy global operator<< so we can bring it into Catch namespace later
struct Catch_global_namespace_dummy {};
std::ostream& operator<<(std::ostream&, Catch_global_namespace_dummy);

namespace Catch {

    struct CaseSensitive { enum Choice {
        Yes,
        No
    }; };

    class NonCopyable {
        NonCopyable( NonCopyable const& )              = delete;
        NonCopyable( NonCopyable && )                  = delete;
        NonCopyable& operator = ( NonCopyable const& ) = delete;
        NonCopyable& operator = ( NonCopyable && )     = delete;

    protected:
        NonCopyable();
        virtual ~NonCopyable();
    };

    struct SourceLineInfo {

        SourceLineInfo() = delete;
        SourceLineInfo( char const* _file, std::size_t _line ) noexcept
        :   file( _file ),
            line( _line )
        {}

        SourceLineInfo( SourceLineInfo const& other )            = default;
        SourceLineInfo& operator = ( SourceLineInfo const& )     = default;
        SourceLineInfo( SourceLineInfo&& )              noexcept = default;
        SourceLineInfo& operator = ( SourceLineInfo&& ) noexcept = default;

        bool empty() const noexcept { return file[0] == '\0'; }
        bool operator == ( SourceLineInfo const& other ) const noexcept;
        bool operator < ( SourceLineInfo const& other ) const noexcept;

        char const* file;
        std::size_t line;
    };

    std::ostream& operator << ( std::ostream& os, SourceLineInfo const& info );

    // Bring in operator<< from global namespace into Catch namespace
    // This is necessary because the overload of operator<< above makes
    // lookup stop at namespace Catch
    using ::operator<<;

    // Use this in variadic streaming macros to allow
    //    >> +StreamEndStop
    // as well as
    //    >> stuff +StreamEndStop
    struct StreamEndStop {
        std::string operator+() const;
    };
    template<typename T>
    T const& operator + ( T const& value, StreamEndStop ) {
        return value;
    }
}

#define CATCH_INTERNAL_LINEINFO \
    ::Catch::SourceLineInfo( __FILE__, static_cast<std::size_t>( __LINE__ ) )

// end catch_common.h
namespace Catch {

    struct RegistrarForTagAliases {
        RegistrarForTagAliases( char const* alias, char const* tag, SourceLineInfo const& lineInfo );
    };

} // end namespace Catch

#define CATCH_REGISTER_TAG_ALIAS( alias, spec ) \
    CATCH_INTERNAL_START_WARNINGS_SUPPRESSION \
    CATCH_INTERNAL_SUPPRESS_GLOBALS_WARNINGS \
    namespace{ Catch::RegistrarForTagAliases INTERNAL_CATCH_UNIQUE_NAME( AutoRegisterTagAlias )( alias, spec, CATCH_INTERNAL_LINEINFO ); } \
    CATCH_INTERNAL_STOP_WARNINGS_SUPPRESSION

// end catch_tag_alias_autoregistrar.h
// start catch_test_registry.h

// start catch_interfaces_testcase.h

#include <vector>

namespace Catch {

    class TestSpec;

    struct ITestInvoker {
        virtual void invoke () const = 0;
        virtual ~ITestInvoker();
    };

    class TestCase;
    struct IConfig;

    struct ITestCaseRegistry {
        virtual ~ITestCaseRegistry();
        virtual std::vector<TestCase> const& getAllTests() const = 0;
        virtual std::vector<TestCase> const& getAllTestsSorted( IConfig const& config ) const = 0;
    };

    bool isThrowSafe( TestCase const& testCase, IConfig const& config );
    bool matchTest( TestCase const& testCase, TestSpec const& testSpec, IConfig const& config );
    std::vector<TestCase> filterTests( std::vector<TestCase> const& testCases, TestSpec const& testSpec, IConfig const& config );
    std::vector<TestCase> const& getAllTestCasesSorted( IConfig const& config );

}

// end catch_interfaces_testcase.h
// start catch_stringref.h

#include <cstddef>
#include <string>
#include <iosfwd>
#include <cassert>

namespace Catch {

    /// A non-owning string class (similar to the forthcoming std::string_view)
    /// Note that, because a StringRef may be a substring of another string,
    /// it may not be null terminated.
    class StringRef {
    public:
        using size_type = std::size_t;
        using const_iterator = const char*;

    private:
        static constexpr char const* const s_empty = "";

        char const* m_start = s_empty;
        size_type m_size = 0;

    public: // construction
        constexpr StringRef() noexcept = default;

        StringRef( char const* rawChars ) noexcept;

        constexpr StringRef( char const* rawChars, size_type size ) noexcept
        :   m_start( rawChars ),
            m_size( size )
        {}

        StringRef( std::string const& stdString ) noexcept
        :   m_start( stdString.c_str() ),
            m_size( stdString.size() )
        {}

        explicit operator std::string() const {
            return std::string(m_start, m_size);
        }

    public: // operators
        auto operator == ( StringRef const& other ) const noexcept -> bool;
        auto operator != (StringRef const& other) const noexcept -> bool {
            return !(*this == other);
        }

        auto operator[] ( size_type index ) const noexcept -> char {
            assert(index < m_size);
            return m_start[index];
        }

    public: // named queries
        constexpr auto empty() const noexcept -> bool {
            return m_size == 0;
        }
        constexpr auto size() const noexcept -> size_type {
            return m_size;
        }

        // Returns the current start pointer. If the StringRef is not
        // null-terminated, throws std::domain_exception
        auto c_str() const -> char const*;

    public: // substrings and searches
        // Returns a substring of [start, start + length).
        // If start + length > size(), then the substring is [start, size()).
        // If start > size(), then the substring is empty.
        auto substr( size_type start, size_type length ) const noexcept -> StringRef;

        // Returns the current start pointer. May not be null-terminated.
        auto data() const noexcept -> char const*;

        constexpr auto isNullTerminated() const noexcept -> bool {
            return m_start[m_size] == '\0';
        }

    public: // iterators
        constexpr const_iterator begin() const { return m_start; }
        constexpr const_iterator end() const { return m_start + m_size; }
    };

    auto operator += ( std::string& lhs, StringRef const& sr ) -> std::string&;
    auto operator << ( std::ostream& os, StringRef const& sr ) -> std::ostream&;

    constexpr auto operator "" _sr( char const* rawChars, std::size_t size ) noexcept -> StringRef {
        return StringRef( rawChars, size );
    }
} // namespace Catch

constexpr auto operator "" _catch_sr( char const* rawChars, std::size_t size ) noexcept -> Catch::StringRef {
    return Catch::StringRef( rawChars, size );
}

// end catch_stringref.h
// start catch_preprocessor.hpp


#define CATCH_RECURSION_LEVEL0(...) __VA_ARGS__
#define CATCH_RECURSION_LEVEL1(...) CATCH_RECURSION_LEVEL0(CATCH_RECURSION_LEVEL0(CATCH_RECURSION_LEVEL0(__VA_ARGS__)))
#define CATCH_RECURSION_LEVEL2(...) CATCH_RECURSION_LEVEL1(CATCH_RECURSION_LEVEL1(CATCH_RECURSION_LEVEL1(__VA_ARGS__)))
#define CATCH_RECURSION_LEVEL3(...) CATCH_RECURSION_LEVEL2(CATCH_RECURSION_LEVEL2(CATCH_RECURSION_LEVEL2(__VA_ARGS__)))
#define CATCH_RECURSION_LEVEL4(...) CATCH_RECURSION_LEVEL3(CATCH_RECURSION_LEVEL3(CATCH_RECURSION_LEVEL3(__VA_ARGS__)))
#define CATCH_RECURSION_LEVEL5(...) CATCH_RECURSION_LEVEL4(CATCH_RECURSION_LEVEL4(CATCH_RECURSION_LEVEL4(__VA_ARGS__)))

#ifdef CATCH_CONFIG_TRADITIONAL_MSVC_PREPROCESSOR
#define INTERNAL_CATCH_EXPAND_VARGS(...) __VA_ARGS__
// MSVC needs more evaluations
#define CATCH_RECURSION_LEVEL6(...) CATCH_RECURSION_LEVEL5(CATCH_RECURSION_LEVEL5(CATCH_RECURSION_LEVEL5(__VA_ARGS__)))
#define CATCH_RECURSE(...)  CATCH_RECURSION_LEVEL6(CATCH_RECURSION_LEVEL6(__VA_ARGS__))
#else
#define CATCH_RECURSE(...)  CATCH_RECURSION_LEVEL5(__VA_ARGS__)
#endif

#define CATCH_REC_END(...)
#define CATCH_REC_OUT

#define CATCH_EMPTY()
#define CATCH_DEFER(id) id CATCH_EMPTY()

#define CATCH_REC_GET_END2() 0, CATCH_REC_END
#define CATCH_REC_GET_END1(...) CATCH_REC_GET_END2
#define CATCH_REC_GET_END(...) CATCH_REC_GET_END1
#define CATCH_REC_NEXT0(test, next, ...) next CATCH_REC_OUT
#define CATCH_REC_NEXT1(test, next) CATCH_DEFER ( CATCH_REC_NEXT0 ) ( test, next, 0)
#define CATCH_REC_NEXT(test, next)  CATCH_REC_NEXT1(CATCH_REC_GET_END test, next)

#define CATCH_REC_LIST0(f, x, peek, ...) , f(x) CATCH_DEFER ( CATCH_REC_NEXT(peek, CATCH_REC_LIST1) ) ( f, peek, __VA_ARGS__ )
#define CATCH_REC_LIST1(f, x, peek, ...) , f(x) CATCH_DEFER ( CATCH_REC_NEXT(peek, CATCH_REC_LIST0) ) ( f, peek, __VA_ARGS__ )
#define CATCH_REC_LIST2(f, x, peek, ...)   f(x) CATCH_DEFER ( CATCH_REC_NEXT(peek, CATCH_REC_LIST1) ) ( f, peek, __VA_ARGS__ )

#define CATCH_REC_LIST0_UD(f, userdata, x, peek, ...) , f(userdata, x) CATCH_DEFER ( CATCH_REC_NEXT(peek, CATCH_REC_LIST1_UD) ) ( f, userdata, peek, __VA_ARGS__ )
#define CATCH_REC_LIST1_UD(f, userdata, x, peek, ...) , f(userdata, x) CATCH_DEFER ( CATCH_REC_NEXT(peek, CATCH_REC_LIST0_UD) ) ( f, userdata, peek, __VA_ARGS__ )
#define CATCH_REC_LIST2_UD(f, userdata, x, peek, ...)   f(userdata, x) CATCH_DEFER ( CATCH_REC_NEXT(peek, CATCH_REC_LIST1_UD) ) ( f, userdata, peek, __VA_ARGS__ )

// Applies the function macro `f` to each of the remaining parameters, inserts commas between the results,
// and passes userdata as the first parameter to each invocation,
// e.g. CATCH_REC_LIST_UD(f, x, a, b, c) evaluates to f(x, a), f(x, b), f(x, c)
#define CATCH_REC_LIST_UD(f, userdata, ...) CATCH_RECURSE(CATCH_REC_LIST2_UD(f, userdata, __VA_ARGS__, ()()(), ()()(), ()()(), 0))

#define CATCH_REC_LIST(f, ...) CATCH_RECURSE(CATCH_REC_LIST2(f, __VA_ARGS__, ()()(), ()()(), ()()(), 0))

#define INTERNAL_CATCH_EXPAND1(param) INTERNAL_CATCH_EXPAND2(param)
#define INTERNAL_CATCH_EXPAND2(...) INTERNAL_CATCH_NO## __VA_ARGS__
#define INTERNAL_CATCH_DEF(...) INTERNAL_CATCH_DEF __VA_ARGS__
#define INTERNAL_CATCH_NOINTERNAL_CATCH_DEF
#define INTERNAL_CATCH_STRINGIZE(...) INTERNAL_CATCH_STRINGIZE2(__VA_ARGS__)
#ifndef CATCH_CONFIG_TRADITIONAL_MSVC_PREPROCESSOR
#define INTERNAL_CATCH_STRINGIZE2(...) #__VA_ARGS__
#define INTERNAL_CATCH_STRINGIZE_WITHOUT_PARENS(param) INTERNAL_CATCH_STRINGIZE(INTERNAL_CATCH_REMOVE_PARENS(param))
#else
// MSVC is adding extra space and needs another indirection to expand INTERNAL_CATCH_NOINTERNAL_CATCH_DEF
#define INTERNAL_CATCH_STRINGIZE2(...) INTERNAL_CATCH_STRINGIZE3(__VA_ARGS__)
#define INTERNAL_CATCH_STRINGIZE3(...) #__VA_ARGS__
#define INTERNAL_CATCH_STRINGIZE_WITHOUT_PARENS(param) (INTERNAL_CATCH_STRINGIZE(INTERNAL_CATCH_REMOVE_PARENS(param)) + 1)
#endif

#define INTERNAL_CATCH_MAKE_NAMESPACE2(...) ns_##__VA_ARGS__
#define INTERNAL_CATCH_MAKE_NAMESPACE(name) INTERNAL_CATCH_MAKE_NAMESPACE2(name)

#define INTERNAL_CATCH_REMOVE_PARENS(...) INTERNAL_CATCH_EXPAND1(INTERNAL_CATCH_DEF __VA_ARGS__)

#ifndef CATCH_CONFIG_TRADITIONAL_MSVC_PREPROCESSOR
#define INTERNAL_CATCH_MAKE_TYPE_LIST2(...) decltype(get_wrapper<INTERNAL_CATCH_REMOVE_PARENS_GEN(__VA_ARGS__)>())
#define INTERNAL_CATCH_MAKE_TYPE_LIST(...) INTERNAL_CATCH_MAKE_TYPE_LIST2(INTERNAL_CATCH_REMOVE_PARENS(__VA_ARGS__))
#else
#define INTERNAL_CATCH_MAKE_TYPE_LIST2(...) INTERNAL_CATCH_EXPAND_VARGS(decltype(get_wrapper<INTERNAL_CATCH_REMOVE_PARENS_GEN(__VA_ARGS__)>()))
#define INTERNAL_CATCH_MAKE_TYPE_LIST(...) INTERNAL_CATCH_EXPAND_VARGS(INTERNAL_CATCH_MAKE_TYPE_LIST2(INTERNAL_CATCH_REMOVE_PARENS(__VA_ARGS__)))
#endif

#define INTERNAL_CATCH_MAKE_TYPE_LISTS_FROM_TYPES(...)\
    CATCH_REC_LIST(INTERNAL_CATCH_MAKE_TYPE_LIST,__VA_ARGS__)

#define INTERNAL_CATCH_REMOVE_PARENS_1_ARG(_0) INTERNAL_CATCH_REMOVE_PARENS(_0)
#define INTERNAL_CATCH_REMOVE_PARENS_2_ARG(_0, _1) INTERNAL_CATCH_REMOVE_PARENS(_0), INTERNAL_CATCH_REMOVE_PARENS_1_ARG(_1)
#define INTERNAL_CATCH_REMOVE_PARENS_3_ARG(_0, _1, _2) INTERNAL_CATCH_REMOVE_PARENS(_0), INTERNAL_CATCH_REMOVE_PARENS_2_ARG(_1, _2)
#define INTERNAL_CATCH_REMOVE_PARENS_4_ARG(_0, _1, _2, _3) INTERNAL_CATCH_REMOVE_PARENS(_0), INTERNAL_CATCH_REMOVE_PARENS_3_ARG(_1, _2, _3)
#define INTERNAL_CATCH_REMOVE_PARENS_5_ARG(_0, _1, _2, _3, _4) INTERNAL_CATCH_REMOVE_PARENS(_0), INTERNAL_CATCH_REMOVE_PARENS_4_ARG(_1, _2, _3, _4)
#define INTERNAL_CATCH_REMOVE_PARENS_6_ARG(_0, _1, _2, _3, _4, _5) INTERNAL_CATCH_REMOVE_PARENS(_0), INTERNAL_CATCH_REMOVE_PARENS_5_ARG(_1, _2, _3, _4, _5)
#define INTERNAL_CATCH_REMOVE_PARENS_7_ARG(_0, _1, _2, _3, _4, _5, _6) INTERNAL_CATCH_REMOVE_PARENS(_0), INTERNAL_CATCH_REMOVE_PARENS_6_ARG(_1, _2, _3, _4, _5, _6)
#define INTERNAL_CATCH_REMOVE_PARENS_8_ARG(_0, _1, _2, _3, _4, _5, _6, _7) INTERNAL_CATCH_REMOVE_PARENS(_0), INTERNAL_CATCH_REMOVE_PARENS_7_ARG(_1, _2, _3, _4, _5, _6, _7)
#define INTERNAL_CATCH_REMOVE_PARENS_9_ARG(_0, _1, _2, _3, _4, _5, _6, _7, _8) INTERNAL_CATCH_REMOVE_PARENS(_0), INTERNAL_CATCH_REMOVE_PARENS_8_ARG(_1, _2, _3, _4, _5, _6, _7, _8)
#define INTERNAL_CATCH_REMOVE_PARENS_10_ARG(_0, _1, _2, _3, _4, _5, _6, _7, _8, _9) INTERNAL_CATCH_REMOVE_PARENS(_0), INTERNAL_CATCH_REMOVE_PARENS_9_ARG(_1, _2, _3, _4, _5, _6, _7, _8, _9)
#define INTERNAL_CATCH_REMOVE_PARENS_11_ARG(_0, _1, _2, _3, _4, _5, _6, _7, _8, _9, _10) INTERNAL_CATCH_REMOVE_PARENS(_0), INTERNAL_CATCH_REMOVE_PARENS_10_ARG(_1, _2, _3, _4, _5, _6, _7, _8, _9, _10)

#define INTERNAL_CATCH_VA_NARGS_IMPL(_0, _1, _2, _3, _4, _5, _6, _7, _8, _9, _10, N, ...) N

#define INTERNAL_CATCH_TYPE_GEN\
    template<typename...> struct TypeList {};\
    template<typename...Ts>\
    constexpr auto get_wrapper() noexcept -> TypeList<Ts...> { return {}; }\
    template<template<typename...> class...> struct TemplateTypeList{};\
    template<template<typename...> class...Cs>\
    constexpr auto get_wrapper() noexcept -> TemplateTypeList<Cs...> { return {}; }\
    template<typename...>\
    struct append;\
    template<typename...>\
    struct rewrap;\
    template<template<typename...> class, typename...>\
    struct create;\
    template<template<typename...> class, typename>\
    struct convert;\
    \
    template<typename T> \
    struct append<T> { using type = T; };\
    template< template<typename...> class L1, typename...E1, template<typename...> class L2, typename...E2, typename...Rest>\
    struct append<L1<E1...>, L2<E2...>, Rest...> { using type = typename append<L1<E1...,E2...>, Rest...>::type; };\
    template< template<typename...> class L1, typename...E1, typename...Rest>\
    struct append<L1<E1...>, TypeList<mpl_::na>, Rest...> { using type = L1<E1...>; };\
    \
    template< template<typename...> class Container, template<typename...> class List, typename...elems>\
    struct rewrap<TemplateTypeList<Container>, List<elems...>> { using type = TypeList<Container<elems...>>; };\
    template< template<typename...> class Container, template<typename...> class List, class...Elems, typename...Elements>\
    struct rewrap<TemplateTypeList<Container>, List<Elems...>, Elements...> { using type = typename append<TypeList<Container<Elems...>>, typename rewrap<TemplateTypeList<Container>, Elements...>::type>::type; };\
    \
    template<template <typename...> class Final, template< typename...> class...Containers, typename...Types>\
    struct create<Final, TemplateTypeList<Containers...>, TypeList<Types...>> { using type = typename append<Final<>, typename rewrap<TemplateTypeList<Containers>, Types...>::type...>::type; };\
    template<template <typename...> class Final, template <typename...> class List, typename...Ts>\
    struct convert<Final, List<Ts...>> { using type = typename append<Final<>,TypeList<Ts>...>::type; };

#define INTERNAL_CATCH_NTTP_1(signature, ...)\
    template<INTERNAL_CATCH_REMOVE_PARENS(signature)> struct Nttp{};\
    template<INTERNAL_CATCH_REMOVE_PARENS(signature)>\
    constexpr auto get_wrapper() noexcept -> Nttp<__VA_ARGS__> { return {}; } \
    template<template<INTERNAL_CATCH_REMOVE_PARENS(signature)> class...> struct NttpTemplateTypeList{};\
    template<template<INTERNAL_CATCH_REMOVE_PARENS(signature)> class...Cs>\
    constexpr auto get_wrapper() noexcept -> NttpTemplateTypeList<Cs...> { return {}; } \
    \
    template< template<INTERNAL_CATCH_REMOVE_PARENS(signature)> class Container, template<INTERNAL_CATCH_REMOVE_PARENS(signature)> class List, INTERNAL_CATCH_REMOVE_PARENS(signature)>\
    struct rewrap<NttpTemplateTypeList<Container>, List<__VA_ARGS__>> { using type = TypeList<Container<__VA_ARGS__>>; };\
    template< template<INTERNAL_CATCH_REMOVE_PARENS(signature)> class Container, template<INTERNAL_CATCH_REMOVE_PARENS(signature)> class List, INTERNAL_CATCH_REMOVE_PARENS(signature), typename...Elements>\
    struct rewrap<NttpTemplateTypeList<Container>, List<__VA_ARGS__>, Elements...> { using type = typename append<TypeList<Container<__VA_ARGS__>>, typename rewrap<NttpTemplateTypeList<Container>, Elements...>::type>::type; };\
    template<template <typename...> class Final, template<INTERNAL_CATCH_REMOVE_PARENS(signature)> class...Containers, typename...Types>\
    struct create<Final, NttpTemplateTypeList<Containers...>, TypeList<Types...>> { using type = typename append<Final<>, typename rewrap<NttpTemplateTypeList<Containers>, Types...>::type...>::type; };

#define INTERNAL_CATCH_DECLARE_SIG_TEST0(TestName)
#define INTERNAL_CATCH_DECLARE_SIG_TEST1(TestName, signature)\
    template<INTERNAL_CATCH_REMOVE_PARENS(signature)>\
    static void TestName()
#define INTERNAL_CATCH_DECLARE_SIG_TEST_X(TestName, signature, ...)\
    template<INTERNAL_CATCH_REMOVE_PARENS(signature)>\
    static void TestName()

#define INTERNAL_CATCH_DEFINE_SIG_TEST0(TestName)
#define INTERNAL_CATCH_DEFINE_SIG_TEST1(TestName, signature)\
    template<INTERNAL_CATCH_REMOVE_PARENS(signature)>\
    static void TestName()
#define INTERNAL_CATCH_DEFINE_SIG_TEST_X(TestName, signature,...)\
    template<INTERNAL_CATCH_REMOVE_PARENS(signature)>\
    static void TestName()

#define INTERNAL_CATCH_NTTP_REGISTER0(TestFunc, signature)\
    template<typename Type>\
    void reg_test(TypeList<Type>, Catch::NameAndTags nameAndTags)\
    {\
        Catch::AutoReg( Catch::makeTestInvoker(&TestFunc<Type>), CATCH_INTERNAL_LINEINFO, Catch::StringRef(), nameAndTags);\
    }

#define INTERNAL_CATCH_NTTP_REGISTER(TestFunc, signature, ...)\
    template<INTERNAL_CATCH_REMOVE_PARENS(signature)>\
    void reg_test(Nttp<__VA_ARGS__>, Catch::NameAndTags nameAndTags)\
    {\
        Catch::AutoReg( Catch::makeTestInvoker(&TestFunc<__VA_ARGS__>), CATCH_INTERNAL_LINEINFO, Catch::StringRef(), nameAndTags);\
    }

#define INTERNAL_CATCH_NTTP_REGISTER_METHOD0(TestName, signature, ...)\
    template<typename Type>\
    void reg_test(TypeList<Type>, Catch::StringRef className, Catch::NameAndTags nameAndTags)\
    {\
        Catch::AutoReg( Catch::makeTestInvoker(&TestName<Type>::test), CATCH_INTERNAL_LINEINFO, className, nameAndTags);\
    }

#define INTERNAL_CATCH_NTTP_REGISTER_METHOD(TestName, signature, ...)\
    template<INTERNAL_CATCH_REMOVE_PARENS(signature)>\
    void reg_test(Nttp<__VA_ARGS__>, Catch::StringRef className, Catch::NameAndTags nameAndTags)\
    {\
        Catch::AutoReg( Catch::makeTestInvoker(&TestName<__VA_ARGS__>::test), CATCH_INTERNAL_LINEINFO, className, nameAndTags);\
    }

#define INTERNAL_CATCH_DECLARE_SIG_TEST_METHOD0(TestName, ClassName)
#define INTERNAL_CATCH_DECLARE_SIG_TEST_METHOD1(TestName, ClassName, signature)\
    template<typename TestType> \
    struct TestName : INTERNAL_CATCH_REMOVE_PARENS(ClassName)<TestType> { \
        void test();\
    }

#define INTERNAL_CATCH_DECLARE_SIG_TEST_METHOD_X(TestName, ClassName, signature, ...)\
    template<INTERNAL_CATCH_REMOVE_PARENS(signature)> \
    struct TestName : INTERNAL_CATCH_REMOVE_PARENS(ClassName)<__VA_ARGS__> { \
        void test();\
    }

#define INTERNAL_CATCH_DEFINE_SIG_TEST_METHOD0(TestName)
#define INTERNAL_CATCH_DEFINE_SIG_TEST_METHOD1(TestName, signature)\
    template<typename TestType> \
    void INTERNAL_CATCH_MAKE_NAMESPACE(TestName)::TestName<TestType>::test()
#define INTERNAL_CATCH_DEFINE_SIG_TEST_METHOD_X(TestName, signature, ...)\
    template<INTERNAL_CATCH_REMOVE_PARENS(signature)> \
    void INTERNAL_CATCH_MAKE_NAMESPACE(TestName)::TestName<__VA_ARGS__>::test()

#ifndef CATCH_CONFIG_TRADITIONAL_MSVC_PREPROCESSOR
#define INTERNAL_CATCH_NTTP_0
#define INTERNAL_CATCH_NTTP_GEN(...) INTERNAL_CATCH_VA_NARGS_IMPL(__VA_ARGS__, INTERNAL_CATCH_NTTP_1(__VA_ARGS__), INTERNAL_CATCH_NTTP_1(__VA_ARGS__), INTERNAL_CATCH_NTTP_1(__VA_ARGS__), INTERNAL_CATCH_NTTP_1(__VA_ARGS__), INTERNAL_CATCH_NTTP_1(__VA_ARGS__), INTERNAL_CATCH_NTTP_1( __VA_ARGS__), INTERNAL_CATCH_NTTP_1( __VA_ARGS__), INTERNAL_CATCH_NTTP_1( __VA_ARGS__), INTERNAL_CATCH_NTTP_1( __VA_ARGS__),INTERNAL_CATCH_NTTP_1( __VA_ARGS__), INTERNAL_CATCH_NTTP_0)
#define INTERNAL_CATCH_DEFINE_SIG_TEST_METHOD(TestName, ...) INTERNAL_CATCH_VA_NARGS_IMPL( "dummy", __VA_ARGS__, INTERNAL_CATCH_DEFINE_SIG_TEST_METHOD_X,INTERNAL_CATCH_DEFINE_SIG_TEST_METHOD_X, INTERNAL_CATCH_DEFINE_SIG_TEST_METHOD_X, INTERNAL_CATCH_DEFINE_SIG_TEST_METHOD_X, INTERNAL_CATCH_DEFINE_SIG_TEST_METHOD_X, INTERNAL_CATCH_DEFINE_SIG_TEST_METHOD_X, INTERNAL_CATCH_DEFINE_SIG_TEST_METHOD_X,INTERNAL_CATCH_DEFINE_SIG_TEST_METHOD_X,INTERNAL_CATCH_DEFINE_SIG_TEST_METHOD_X, INTERNAL_CATCH_DEFINE_SIG_TEST_METHOD1, INTERNAL_CATCH_DEFINE_SIG_TEST_METHOD0)(TestName, __VA_ARGS__)
#define INTERNAL_CATCH_DECLARE_SIG_TEST_METHOD(TestName, ClassName, ...) INTERNAL_CATCH_VA_NARGS_IMPL( "dummy", __VA_ARGS__, INTERNAL_CATCH_DECLARE_SIG_TEST_METHOD_X,INTERNAL_CATCH_DECLARE_SIG_TEST_METHOD_X, INTERNAL_CATCH_DECLARE_SIG_TEST_METHOD_X, INTERNAL_CATCH_DECLARE_SIG_TEST_METHOD_X, INTERNAL_CATCH_DECLARE_SIG_TEST_METHOD_X, INTERNAL_CATCH_DECLARE_SIG_TEST_METHOD_X, INTERNAL_CATCH_DECLARE_SIG_TEST_METHOD_X,INTERNAL_CATCH_DECLARE_SIG_TEST_METHOD_X,INTERNAL_CATCH_DECLARE_SIG_TEST_METHOD_X, INTERNAL_CATCH_DECLARE_SIG_TEST_METHOD1, INTERNAL_CATCH_DECLARE_SIG_TEST_METHOD0)(TestName, ClassName, __VA_ARGS__)
#define INTERNAL_CATCH_NTTP_REG_METHOD_GEN(TestName, ...) INTERNAL_CATCH_VA_NARGS_IMPL( "dummy", __VA_ARGS__, INTERNAL_CATCH_NTTP_REGISTER_METHOD, INTERNAL_CATCH_NTTP_REGISTER_METHOD, INTERNAL_CATCH_NTTP_REGISTER_METHOD, INTERNAL_CATCH_NTTP_REGISTER_METHOD, INTERNAL_CATCH_NTTP_REGISTER_METHOD, INTERNAL_CATCH_NTTP_REGISTER_METHOD, INTERNAL_CATCH_NTTP_REGISTER_METHOD, INTERNAL_CATCH_NTTP_REGISTER_METHOD, INTERNAL_CATCH_NTTP_REGISTER_METHOD, INTERNAL_CATCH_NTTP_REGISTER_METHOD0, INTERNAL_CATCH_NTTP_REGISTER_METHOD0)(TestName, __VA_ARGS__)
#define INTERNAL_CATCH_NTTP_REG_GEN(TestFunc, ...) INTERNAL_CATCH_VA_NARGS_IMPL( "dummy", __VA_ARGS__, INTERNAL_CATCH_NTTP_REGISTER, INTERNAL_CATCH_NTTP_REGISTER, INTERNAL_CATCH_NTTP_REGISTER, INTERNAL_CATCH_NTTP_REGISTER, INTERNAL_CATCH_NTTP_REGISTER, INTERNAL_CATCH_NTTP_REGISTER, INTERNAL_CATCH_NTTP_REGISTER, INTERNAL_CATCH_NTTP_REGISTER, INTERNAL_CATCH_NTTP_REGISTER, INTERNAL_CATCH_NTTP_REGISTER0, INTERNAL_CATCH_NTTP_REGISTER0)(TestFunc, __VA_ARGS__)
#define INTERNAL_CATCH_DEFINE_SIG_TEST(TestName, ...) INTERNAL_CATCH_VA_NARGS_IMPL( "dummy", __VA_ARGS__, INTERNAL_CATCH_DEFINE_SIG_TEST_X, INTERNAL_CATCH_DEFINE_SIG_TEST_X, INTERNAL_CATCH_DEFINE_SIG_TEST_X, INTERNAL_CATCH_DEFINE_SIG_TEST_X, INTERNAL_CATCH_DEFINE_SIG_TEST_X, INTERNAL_CATCH_DEFINE_SIG_TEST_X, INTERNAL_CATCH_DEFINE_SIG_TEST_X, INTERNAL_CATCH_DEFINE_SIG_TEST_X,INTERNAL_CATCH_DEFINE_SIG_TEST_X,INTERNAL_CATCH_DEFINE_SIG_TEST1, INTERNAL_CATCH_DEFINE_SIG_TEST0)(TestName, __VA_ARGS__)
#define INTERNAL_CATCH_DECLARE_SIG_TEST(TestName, ...) INTERNAL_CATCH_VA_NARGS_IMPL( "dummy", __VA_ARGS__, INTERNAL_CATCH_DECLARE_SIG_TEST_X,INTERNAL_CATCH_DECLARE_SIG_TEST_X, INTERNAL_CATCH_DECLARE_SIG_TEST_X, INTERNAL_CATCH_DECLARE_SIG_TEST_X, INTERNAL_CATCH_DECLARE_SIG_TEST_X, INTERNAL_CATCH_DECLARE_SIG_TEST_X, INTERNAL_CATCH_DEFINE_SIG_TEST_X,INTERNAL_CATCH_DECLARE_SIG_TEST_X,INTERNAL_CATCH_DECLARE_SIG_TEST_X, INTERNAL_CATCH_DECLARE_SIG_TEST1, INTERNAL_CATCH_DECLARE_SIG_TEST0)(TestName, __VA_ARGS__)
#define INTERNAL_CATCH_REMOVE_PARENS_GEN(...) INTERNAL_CATCH_VA_NARGS_IMPL(__VA_ARGS__, INTERNAL_CATCH_REMOVE_PARENS_11_ARG,INTERNAL_CATCH_REMOVE_PARENS_10_ARG,INTERNAL_CATCH_REMOVE_PARENS_9_ARG,INTERNAL_CATCH_REMOVE_PARENS_8_ARG,INTERNAL_CATCH_REMOVE_PARENS_7_ARG,INTERNAL_CATCH_REMOVE_PARENS_6_ARG,INTERNAL_CATCH_REMOVE_PARENS_5_ARG,INTERNAL_CATCH_REMOVE_PARENS_4_ARG,INTERNAL_CATCH_REMOVE_PARENS_3_ARG,INTERNAL_CATCH_REMOVE_PARENS_2_ARG,INTERNAL_CATCH_REMOVE_PARENS_1_ARG)(__VA_ARGS__)
#else
#define INTERNAL_CATCH_NTTP_0(signature)
#define INTERNAL_CATCH_NTTP_GEN(...) INTERNAL_CATCH_EXPAND_VARGS(INTERNAL_CATCH_VA_NARGS_IMPL(__VA_ARGS__, INTERNAL_CATCH_NTTP_1, INTERNAL_CATCH_NTTP_1, INTERNAL_CATCH_NTTP_1, INTERNAL_CATCH_NTTP_1, INTERNAL_CATCH_NTTP_1, INTERNAL_CATCH_NTTP_1, INTERNAL_CATCH_NTTP_1, INTERNAL_CATCH_NTTP_1, INTERNAL_CATCH_NTTP_1,INTERNAL_CATCH_NTTP_1, INTERNAL_CATCH_NTTP_0)( __VA_ARGS__))
#define INTERNAL_CATCH_DEFINE_SIG_TEST_METHOD(TestName, ...) INTERNAL_CATCH_EXPAND_VARGS(INTERNAL_CATCH_VA_NARGS_IMPL( "dummy", __VA_ARGS__, INTERNAL_CATCH_DEFINE_SIG_TEST_METHOD_X,INTERNAL_CATCH_DEFINE_SIG_TEST_METHOD_X, INTERNAL_CATCH_DEFINE_SIG_TEST_METHOD_X, INTERNAL_CATCH_DEFINE_SIG_TEST_METHOD_X, INTERNAL_CATCH_DEFINE_SIG_TEST_METHOD_X, INTERNAL_CATCH_DEFINE_SIG_TEST_METHOD_X, INTERNAL_CATCH_DEFINE_SIG_TEST_METHOD_X,INTERNAL_CATCH_DEFINE_SIG_TEST_METHOD_X,INTERNAL_CATCH_DEFINE_SIG_TEST_METHOD_X, INTERNAL_CATCH_DEFINE_SIG_TEST_METHOD1, INTERNAL_CATCH_DEFINE_SIG_TEST_METHOD0)(TestName, __VA_ARGS__))
#define INTERNAL_CATCH_DECLARE_SIG_TEST_METHOD(TestName, ClassName, ...) INTERNAL_CATCH_EXPAND_VARGS(INTERNAL_CATCH_VA_NARGS_IMPL( "dummy", __VA_ARGS__, INTERNAL_CATCH_DECLARE_SIG_TEST_METHOD_X,INTERNAL_CATCH_DECLARE_SIG_TEST_METHOD_X, INTERNAL_CATCH_DECLARE_SIG_TEST_METHOD_X, INTERNAL_CATCH_DECLARE_SIG_TEST_METHOD_X, INTERNAL_CATCH_DECLARE_SIG_TEST_METHOD_X, INTERNAL_CATCH_DECLARE_SIG_TEST_METHOD_X, INTERNAL_CATCH_DECLARE_SIG_TEST_METHOD_X,INTERNAL_CATCH_DECLARE_SIG_TEST_METHOD_X,INTERNAL_CATCH_DECLARE_SIG_TEST_METHOD_X, INTERNAL_CATCH_DECLARE_SIG_TEST_METHOD1, INTERNAL_CATCH_DECLARE_SIG_TEST_METHOD0)(TestName, ClassName, __VA_ARGS__))
#define INTERNAL_CATCH_NTTP_REG_METHOD_GEN(TestName, ...) INTERNAL_CATCH_EXPAND_VARGS(INTERNAL_CATCH_VA_NARGS_IMPL( "dummy", __VA_ARGS__, INTERNAL_CATCH_NTTP_REGISTER_METHOD, INTERNAL_CATCH_NTTP_REGISTER_METHOD, INTERNAL_CATCH_NTTP_REGISTER_METHOD, INTERNAL_CATCH_NTTP_REGISTER_METHOD, INTERNAL_CATCH_NTTP_REGISTER_METHOD, INTERNAL_CATCH_NTTP_REGISTER_METHOD, INTERNAL_CATCH_NTTP_REGISTER_METHOD, INTERNAL_CATCH_NTTP_REGISTER_METHOD, INTERNAL_CATCH_NTTP_REGISTER_METHOD, INTERNAL_CATCH_NTTP_REGISTER_METHOD0, INTERNAL_CATCH_NTTP_REGISTER_METHOD0)(TestName, __VA_ARGS__))
#define INTERNAL_CATCH_NTTP_REG_GEN(TestFunc, ...) INTERNAL_CATCH_EXPAND_VARGS(INTERNAL_CATCH_VA_NARGS_IMPL( "dummy", __VA_ARGS__, INTERNAL_CATCH_NTTP_REGISTER, INTERNAL_CATCH_NTTP_REGISTER, INTERNAL_CATCH_NTTP_REGISTER, INTERNAL_CATCH_NTTP_REGISTER, INTERNAL_CATCH_NTTP_REGISTER, INTERNAL_CATCH_NTTP_REGISTER, INTERNAL_CATCH_NTTP_REGISTER, INTERNAL_CATCH_NTTP_REGISTER, INTERNAL_CATCH_NTTP_REGISTER, INTERNAL_CATCH_NTTP_REGISTER0, INTERNAL_CATCH_NTTP_REGISTER0)(TestFunc, __VA_ARGS__))
#define INTERNAL_CATCH_DEFINE_SIG_TEST(TestName, ...) INTERNAL_CATCH_EXPAND_VARGS(INTERNAL_CATCH_VA_NARGS_IMPL( "dummy", __VA_ARGS__, INTERNAL_CATCH_DEFINE_SIG_TEST_X, INTERNAL_CATCH_DEFINE_SIG_TEST_X, INTERNAL_CATCH_DEFINE_SIG_TEST_X, INTERNAL_CATCH_DEFINE_SIG_TEST_X, INTERNAL_CATCH_DEFINE_SIG_TEST_X, INTERNAL_CATCH_DEFINE_SIG_TEST_X, INTERNAL_CATCH_DEFINE_SIG_TEST_X, INTERNAL_CATCH_DEFINE_SIG_TEST_X,INTERNAL_CATCH_DEFINE_SIG_TEST_X,INTERNAL_CATCH_DEFINE_SIG_TEST1, INTERNAL_CATCH_DEFINE_SIG_TEST0)(TestName, __VA_ARGS__))
#define INTERNAL_CATCH_DECLARE_SIG_TEST(TestName, ...) INTERNAL_CATCH_EXPAND_VARGS(INTERNAL_CATCH_VA_NARGS_IMPL( "dummy", __VA_ARGS__, INTERNAL_CATCH_DECLARE_SIG_TEST_X,INTERNAL_CATCH_DECLARE_SIG_TEST_X, INTERNAL_CATCH_DECLARE_SIG_TEST_X, INTERNAL_CATCH_DECLARE_SIG_TEST_X, INTERNAL_CATCH_DECLARE_SIG_TEST_X, INTERNAL_CATCH_DECLARE_SIG_TEST_X, INTERNAL_CATCH_DEFINE_SIG_TEST_X,INTERNAL_CATCH_DECLARE_SIG_TEST_X,INTERNAL_CATCH_DECLARE_SIG_TEST_X, INTERNAL_CATCH_DECLARE_SIG_TEST1, INTERNAL_CATCH_DECLARE_SIG_TEST0)(TestName, __VA_ARGS__))
#define INTERNAL_CATCH_REMOVE_PARENS_GEN(...) INTERNAL_CATCH_EXPAND_VARGS(INTERNAL_CATCH_VA_NARGS_IMPL(__VA_ARGS__, INTERNAL_CATCH_REMOVE_PARENS_11_ARG,INTERNAL_CATCH_REMOVE_PARENS_10_ARG,INTERNAL_CATCH_REMOVE_PARENS_9_ARG,INTERNAL_CATCH_REMOVE_PARENS_8_ARG,INTERNAL_CATCH_REMOVE_PARENS_7_ARG,INTERNAL_CATCH_REMOVE_PARENS_6_ARG,INTERNAL_CATCH_REMOVE_PARENS_5_ARG,INTERNAL_CATCH_REMOVE_PARENS_4_ARG,INTERNAL_CATCH_REMOVE_PARENS_3_ARG,INTERNAL_CATCH_REMOVE_PARENS_2_ARG,INTERNAL_CATCH_REMOVE_PARENS_1_ARG)(__VA_ARGS__))
#endif

// end catch_preprocessor.hpp
// start catch_meta.hpp


#include <type_traits>

namespace Catch {
    template<typename T>
    struct always_false : std::false_type {};

    template <typename> struct true_given : std::true_type {};
    struct is_callable_tester {
        template <typename Fun, typename... Args>
        true_given<decltype(std::declval<Fun>()(std::declval<Args>()...))> static test(int);
        template <typename...>
        std::false_type static test(...);
    };

    template <typename T>
    struct is_callable;

    template <typename Fun, typename... Args>
    struct is_callable<Fun(Args...)> : decltype(is_callable_tester::test<Fun, Args...>(0)) {};

#if defined(__cpp_lib_is_invocable) && __cpp_lib_is_invocable >= 201703
    // std::result_of is deprecated in C++17 and removed in C++20. Hence, it is
    // replaced with std::invoke_result here.
    template <typename Func, typename... U>
    using FunctionReturnType = std::remove_reference_t<std::remove_cv_t<std::invoke_result_t<Func, U...>>>;
#else
    // Keep ::type here because we still support C++11
    template <typename Func, typename... U>
    using FunctionReturnType = typename std::remove_reference<typename std::remove_cv<typename std::result_of<Func(U...)>::type>::type>::type;
#endif

} // namespace Catch

namespace mpl_{
    struct na;
}

// end catch_meta.hpp
namespace Catch {

template<typename C>
class TestInvokerAsMethod : public ITestInvoker {
    void (C::*m_testAsMethod)();
public:
    TestInvokerAsMethod( void (C::*testAsMethod)() ) noexcept : m_testAsMethod( testAsMethod ) {}

    void invoke() const override {
        C obj;
        (obj.*m_testAsMethod)();
    }
};

auto makeTestInvoker( void(*testAsFunction)() ) noexcept -> ITestInvoker*;

template<typename C>
auto makeTestInvoker( void (C::*testAsMethod)() ) noexcept -> ITestInvoker* {
    return new(std::nothrow) TestInvokerAsMethod<C>( testAsMethod );
}

struct NameAndTags {
    NameAndTags( StringRef const& name_ = StringRef(), StringRef const& tags_ = StringRef() ) noexcept;
    StringRef name;
    StringRef tags;
};

struct AutoReg : NonCopyable {
    AutoReg( ITestInvoker* invoker, SourceLineInfo const& lineInfo, StringRef const& classOrMethod, NameAndTags const& nameAndTags ) noexcept;
    ~AutoReg();
};

} // end namespace Catch

#if defined(CATCH_CONFIG_DISABLE)
    #define INTERNAL_CATCH_TESTCASE_NO_REGISTRATION( TestName, ... ) \
        static void TestName()
    #define INTERNAL_CATCH_TESTCASE_METHOD_NO_REGISTRATION( TestName, ClassName, ... ) \
        namespace{                        \
            struct TestName : INTERNAL_CATCH_REMOVE_PARENS(ClassName) { \
                void test();              \
            };                            \
        }                                 \
        void TestName::test()
    #define INTERNAL_CATCH_TEMPLATE_TEST_CASE_NO_REGISTRATION_2( TestName, TestFunc, Name, Tags, Signature, ... )  \
        INTERNAL_CATCH_DEFINE_SIG_TEST(TestFunc, INTERNAL_CATCH_REMOVE_PARENS(Signature))
    #define INTERNAL_CATCH_TEMPLATE_TEST_CASE_METHOD_NO_REGISTRATION_2( TestNameClass, TestName, ClassName, Name, Tags, Signature, ... )    \
        namespace{                                                                                  \
            namespace INTERNAL_CATCH_MAKE_NAMESPACE(TestName) {                                      \
            INTERNAL_CATCH_DECLARE_SIG_TEST_METHOD(TestName, ClassName, INTERNAL_CATCH_REMOVE_PARENS(Signature));\
        }                                                                                           \
        }                                                                                           \
        INTERNAL_CATCH_DEFINE_SIG_TEST_METHOD(TestName, INTERNAL_CATCH_REMOVE_PARENS(Signature))

    #ifndef CATCH_CONFIG_TRADITIONAL_MSVC_PREPROCESSOR
        #define INTERNAL_CATCH_TEMPLATE_TEST_CASE_NO_REGISTRATION(Name, Tags, ...) \
            INTERNAL_CATCH_TEMPLATE_TEST_CASE_NO_REGISTRATION_2( INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_M_P_L_A_T_E____T_E_S_T____ ), INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_M_P_L_A_T_E____T_E_S_T____F_U_N_C____ ), Name, Tags, typename TestType, __VA_ARGS__ )
    #else
        #define INTERNAL_CATCH_TEMPLATE_TEST_CASE_NO_REGISTRATION(Name, Tags, ...) \
            INTERNAL_CATCH_EXPAND_VARGS( INTERNAL_CATCH_TEMPLATE_TEST_CASE_NO_REGISTRATION_2( INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_M_P_L_A_T_E____T_E_S_T____ ), INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_M_P_L_A_T_E____T_E_S_T____F_U_N_C____ ), Name, Tags, typename TestType, __VA_ARGS__ ) )
    #endif

    #ifndef CATCH_CONFIG_TRADITIONAL_MSVC_PREPROCESSOR
        #define INTERNAL_CATCH_TEMPLATE_TEST_CASE_SIG_NO_REGISTRATION(Name, Tags, Signature, ...) \
            INTERNAL_CATCH_TEMPLATE_TEST_CASE_NO_REGISTRATION_2( INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_M_P_L_A_T_E____T_E_S_T____ ), INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_M_P_L_A_T_E____T_E_S_T____F_U_N_C____ ), Name, Tags, Signature, __VA_ARGS__ )
    #else
        #define INTERNAL_CATCH_TEMPLATE_TEST_CASE_SIG_NO_REGISTRATION(Name, Tags, Signature, ...) \
            INTERNAL_CATCH_EXPAND_VARGS( INTERNAL_CATCH_TEMPLATE_TEST_CASE_NO_REGISTRATION_2( INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_M_P_L_A_T_E____T_E_S_T____ ), INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_M_P_L_A_T_E____T_E_S_T____F_U_N_C____ ), Name, Tags, Signature, __VA_ARGS__ ) )
    #endif

    #ifndef CATCH_CONFIG_TRADITIONAL_MSVC_PREPROCESSOR
        #define INTERNAL_CATCH_TEMPLATE_TEST_CASE_METHOD_NO_REGISTRATION( ClassName, Name, Tags,... ) \
            INTERNAL_CATCH_TEMPLATE_TEST_CASE_METHOD_NO_REGISTRATION_2( INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_M_P_L_A_T_E____T_E_S_T____C_L_A_S_S____ ), INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_M_P_L_A_T_E____T_E_S_T____ ) , ClassName, Name, Tags, typename T, __VA_ARGS__ )
    #else
        #define INTERNAL_CATCH_TEMPLATE_TEST_CASE_METHOD_NO_REGISTRATION( ClassName, Name, Tags,... ) \
            INTERNAL_CATCH_EXPAND_VARGS( INTERNAL_CATCH_TEMPLATE_TEST_CASE_METHOD_NO_REGISTRATION_2( INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_M_P_L_A_T_E____T_E_S_T____C_L_A_S_S____ ), INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_M_P_L_A_T_E____T_E_S_T____ ) , ClassName, Name, Tags, typename T, __VA_ARGS__ ) )
    #endif

    #ifndef CATCH_CONFIG_TRADITIONAL_MSVC_PREPROCESSOR
        #define INTERNAL_CATCH_TEMPLATE_TEST_CASE_METHOD_SIG_NO_REGISTRATION( ClassName, Name, Tags, Signature, ... ) \
            INTERNAL_CATCH_TEMPLATE_TEST_CASE_METHOD_NO_REGISTRATION_2( INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_M_P_L_A_T_E____T_E_S_T____C_L_A_S_S____ ), INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_M_P_L_A_T_E____T_E_S_T____ ) , ClassName, Name, Tags, Signature, __VA_ARGS__ )
    #else
        #define INTERNAL_CATCH_TEMPLATE_TEST_CASE_METHOD_SIG_NO_REGISTRATION( ClassName, Name, Tags, Signature, ... ) \
            INTERNAL_CATCH_EXPAND_VARGS( INTERNAL_CATCH_TEMPLATE_TEST_CASE_METHOD_NO_REGISTRATION_2( INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_M_P_L_A_T_E____T_E_S_T____C_L_A_S_S____ ), INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_M_P_L_A_T_E____T_E_S_T____ ) , ClassName, Name, Tags, Signature, __VA_ARGS__ ) )
    #endif
#endif

    ///////////////////////////////////////////////////////////////////////////////
    #define INTERNAL_CATCH_TESTCASE2( TestName, ... ) \
        static void TestName(); \
        CATCH_INTERNAL_START_WARNINGS_SUPPRESSION \
        CATCH_INTERNAL_SUPPRESS_GLOBALS_WARNINGS \
        namespace{ Catch::AutoReg INTERNAL_CATCH_UNIQUE_NAME( autoRegistrar )( Catch::makeTestInvoker( &TestName ), CATCH_INTERNAL_LINEINFO, Catch::StringRef(), Catch::NameAndTags{ __VA_ARGS__ } ); } /* NOLINT */ \
        CATCH_INTERNAL_STOP_WARNINGS_SUPPRESSION \
        static void TestName()
    #define INTERNAL_CATCH_TESTCASE( ... ) \
        INTERNAL_CATCH_TESTCASE2( INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_S_T____ ), __VA_ARGS__ )

    ///////////////////////////////////////////////////////////////////////////////
    #define INTERNAL_CATCH_METHOD_AS_TEST_CASE( QualifiedMethod, ... ) \
        CATCH_INTERNAL_START_WARNINGS_SUPPRESSION \
        CATCH_INTERNAL_SUPPRESS_GLOBALS_WARNINGS \
        namespace{ Catch::AutoReg INTERNAL_CATCH_UNIQUE_NAME( autoRegistrar )( Catch::makeTestInvoker( &QualifiedMethod ), CATCH_INTERNAL_LINEINFO, "&" #QualifiedMethod, Catch::NameAndTags{ __VA_ARGS__ } ); } /* NOLINT */ \
        CATCH_INTERNAL_STOP_WARNINGS_SUPPRESSION

    ///////////////////////////////////////////////////////////////////////////////
    #define INTERNAL_CATCH_TEST_CASE_METHOD2( TestName, ClassName, ... )\
        CATCH_INTERNAL_START_WARNINGS_SUPPRESSION \
        CATCH_INTERNAL_SUPPRESS_GLOBALS_WARNINGS \
        namespace{ \
            struct TestName : INTERNAL_CATCH_REMOVE_PARENS(ClassName) { \
                void test(); \
            }; \
            Catch::AutoReg INTERNAL_CATCH_UNIQUE_NAME( autoRegistrar ) ( Catch::makeTestInvoker( &TestName::test ), CATCH_INTERNAL_LINEINFO, #ClassName, Catch::NameAndTags{ __VA_ARGS__ } ); /* NOLINT */ \
        } \
        CATCH_INTERNAL_STOP_WARNINGS_SUPPRESSION \
        void TestName::test()
    #define INTERNAL_CATCH_TEST_CASE_METHOD( ClassName, ... ) \
        INTERNAL_CATCH_TEST_CASE_METHOD2( INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_S_T____ ), ClassName, __VA_ARGS__ )

    ///////////////////////////////////////////////////////////////////////////////
    #define INTERNAL_CATCH_REGISTER_TESTCASE( Function, ... ) \
        CATCH_INTERNAL_START_WARNINGS_SUPPRESSION \
        CATCH_INTERNAL_SUPPRESS_GLOBALS_WARNINGS \
        Catch::AutoReg INTERNAL_CATCH_UNIQUE_NAME( autoRegistrar )( Catch::makeTestInvoker( Function ), CATCH_INTERNAL_LINEINFO, Catch::StringRef(), Catch::NameAndTags{ __VA_ARGS__ } ); /* NOLINT */ \
        CATCH_INTERNAL_STOP_WARNINGS_SUPPRESSION

    ///////////////////////////////////////////////////////////////////////////////
    #define INTERNAL_CATCH_TEMPLATE_TEST_CASE_2(TestName, TestFunc, Name, Tags, Signature, ... )\
        CATCH_INTERNAL_START_WARNINGS_SUPPRESSION \
        CATCH_INTERNAL_SUPPRESS_GLOBALS_WARNINGS \
        CATCH_INTERNAL_SUPPRESS_ZERO_VARIADIC_WARNINGS \
        CATCH_INTERNAL_SUPPRESS_UNUSED_TEMPLATE_WARNINGS \
        INTERNAL_CATCH_DECLARE_SIG_TEST(TestFunc, INTERNAL_CATCH_REMOVE_PARENS(Signature));\
        namespace {\
        namespace INTERNAL_CATCH_MAKE_NAMESPACE(TestName){\
            INTERNAL_CATCH_TYPE_GEN\
            INTERNAL_CATCH_NTTP_GEN(INTERNAL_CATCH_REMOVE_PARENS(Signature))\
            INTERNAL_CATCH_NTTP_REG_GEN(TestFunc,INTERNAL_CATCH_REMOVE_PARENS(Signature))\
            template<typename...Types> \
            struct TestName{\
                TestName(){\
                    int index = 0;                                    \
                    constexpr char const* tmpl_types[] = {CATCH_REC_LIST(INTERNAL_CATCH_STRINGIZE_WITHOUT_PARENS, __VA_ARGS__)};\
                    using expander = int[];\
                    (void)expander{(reg_test(Types{}, Catch::NameAndTags{ Name " - " + std::string(tmpl_types[index]), Tags } ), index++, 0)... };/* NOLINT */ \
                }\
            };\
            static int INTERNAL_CATCH_UNIQUE_NAME( globalRegistrar ) = [](){\
            TestName<INTERNAL_CATCH_MAKE_TYPE_LISTS_FROM_TYPES(__VA_ARGS__)>();\
            return 0;\
        }();\
        }\
        }\
        CATCH_INTERNAL_STOP_WARNINGS_SUPPRESSION \
        INTERNAL_CATCH_DEFINE_SIG_TEST(TestFunc,INTERNAL_CATCH_REMOVE_PARENS(Signature))

#ifndef CATCH_CONFIG_TRADITIONAL_MSVC_PREPROCESSOR
    #define INTERNAL_CATCH_TEMPLATE_TEST_CASE(Name, Tags, ...) \
        INTERNAL_CATCH_TEMPLATE_TEST_CASE_2( INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_M_P_L_A_T_E____T_E_S_T____ ), INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_M_P_L_A_T_E____T_E_S_T____F_U_N_C____ ), Name, Tags, typename TestType, __VA_ARGS__ )
#else
    #define INTERNAL_CATCH_TEMPLATE_TEST_CASE(Name, Tags, ...) \
        INTERNAL_CATCH_EXPAND_VARGS( INTERNAL_CATCH_TEMPLATE_TEST_CASE_2( INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_M_P_L_A_T_E____T_E_S_T____ ), INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_M_P_L_A_T_E____T_E_S_T____F_U_N_C____ ), Name, Tags, typename TestType, __VA_ARGS__ ) )
#endif

#ifndef CATCH_CONFIG_TRADITIONAL_MSVC_PREPROCESSOR
    #define INTERNAL_CATCH_TEMPLATE_TEST_CASE_SIG(Name, Tags, Signature, ...) \
        INTERNAL_CATCH_TEMPLATE_TEST_CASE_2( INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_M_P_L_A_T_E____T_E_S_T____ ), INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_M_P_L_A_T_E____T_E_S_T____F_U_N_C____ ), Name, Tags, Signature, __VA_ARGS__ )
#else
    #define INTERNAL_CATCH_TEMPLATE_TEST_CASE_SIG(Name, Tags, Signature, ...) \
        INTERNAL_CATCH_EXPAND_VARGS( INTERNAL_CATCH_TEMPLATE_TEST_CASE_2( INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_M_P_L_A_T_E____T_E_S_T____ ), INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_M_P_L_A_T_E____T_E_S_T____F_U_N_C____ ), Name, Tags, Signature, __VA_ARGS__ ) )
#endif

    #define INTERNAL_CATCH_TEMPLATE_PRODUCT_TEST_CASE2(TestName, TestFuncName, Name, Tags, Signature, TmplTypes, TypesList) \
        CATCH_INTERNAL_START_WARNINGS_SUPPRESSION                      \
        CATCH_INTERNAL_SUPPRESS_GLOBALS_WARNINGS                      \
        CATCH_INTERNAL_SUPPRESS_ZERO_VARIADIC_WARNINGS                \
        CATCH_INTERNAL_SUPPRESS_UNUSED_TEMPLATE_WARNINGS              \
        template<typename TestType> static void TestFuncName();       \
        namespace {\
        namespace INTERNAL_CATCH_MAKE_NAMESPACE(TestName) {                                     \
            INTERNAL_CATCH_TYPE_GEN                                                  \
            INTERNAL_CATCH_NTTP_GEN(INTERNAL_CATCH_REMOVE_PARENS(Signature))         \
            template<typename... Types>                               \
            struct TestName {                                         \
                void reg_tests() {                                          \
                    int index = 0;                                    \
                    using expander = int[];                           \
                    constexpr char const* tmpl_types[] = {CATCH_REC_LIST(INTERNAL_CATCH_STRINGIZE_WITHOUT_PARENS, INTERNAL_CATCH_REMOVE_PARENS(TmplTypes))};\
                    constexpr char const* types_list[] = {CATCH_REC_LIST(INTERNAL_CATCH_STRINGIZE_WITHOUT_PARENS, INTERNAL_CATCH_REMOVE_PARENS(TypesList))};\
                    constexpr auto num_types = sizeof(types_list) / sizeof(types_list[0]);\
                    (void)expander{(Catch::AutoReg( Catch::makeTestInvoker( &TestFuncName<Types> ), CATCH_INTERNAL_LINEINFO, Catch::StringRef(), Catch::NameAndTags{ Name " - " + std::string(tmpl_types[index / num_types]) + "<" + std::string(types_list[index % num_types]) + ">", Tags } ), index++, 0)... };/* NOLINT */\
                }                                                     \
            };                                                        \
            static int INTERNAL_CATCH_UNIQUE_NAME( globalRegistrar ) = [](){ \
                using TestInit = typename create<TestName, decltype(get_wrapper<INTERNAL_CATCH_REMOVE_PARENS(TmplTypes)>()), TypeList<INTERNAL_CATCH_MAKE_TYPE_LISTS_FROM_TYPES(INTERNAL_CATCH_REMOVE_PARENS(TypesList))>>::type; \
                TestInit t;                                           \
                t.reg_tests();                                        \
                return 0;                                             \
            }();                                                      \
        }                                                             \
        }                                                             \
        CATCH_INTERNAL_STOP_WARNINGS_SUPPRESSION                       \
        template<typename TestType>                                   \
        static void TestFuncName()

#ifndef CATCH_CONFIG_TRADITIONAL_MSVC_PREPROCESSOR
    #define INTERNAL_CATCH_TEMPLATE_PRODUCT_TEST_CASE(Name, Tags, ...)\
        INTERNAL_CATCH_TEMPLATE_PRODUCT_TEST_CASE2(INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_M_P_L_A_T_E____T_E_S_T____ ), INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_M_P_L_A_T_E____T_E_S_T____F_U_N_C____ ), Name, Tags, typename T,__VA_ARGS__)
#else
    #define INTERNAL_CATCH_TEMPLATE_PRODUCT_TEST_CASE(Name, Tags, ...)\
        INTERNAL_CATCH_EXPAND_VARGS( INTERNAL_CATCH_TEMPLATE_PRODUCT_TEST_CASE2( INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_M_P_L_A_T_E____T_E_S_T____ ), INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_M_P_L_A_T_E____T_E_S_T____F_U_N_C____ ), Name, Tags, typename T, __VA_ARGS__ ) )
#endif

#ifndef CATCH_CONFIG_TRADITIONAL_MSVC_PREPROCESSOR
    #define INTERNAL_CATCH_TEMPLATE_PRODUCT_TEST_CASE_SIG(Name, Tags, Signature, ...)\
        INTERNAL_CATCH_TEMPLATE_PRODUCT_TEST_CASE2(INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_M_P_L_A_T_E____T_E_S_T____ ), INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_M_P_L_A_T_E____T_E_S_T____F_U_N_C____ ), Name, Tags, Signature, __VA_ARGS__)
#else
    #define INTERNAL_CATCH_TEMPLATE_PRODUCT_TEST_CASE_SIG(Name, Tags, Signature, ...)\
        INTERNAL_CATCH_EXPAND_VARGS( INTERNAL_CATCH_TEMPLATE_PRODUCT_TEST_CASE2( INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_M_P_L_A_T_E____T_E_S_T____ ), INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_M_P_L_A_T_E____T_E_S_T____F_U_N_C____ ), Name, Tags, Signature, __VA_ARGS__ ) )
#endif

    #define INTERNAL_CATCH_TEMPLATE_LIST_TEST_CASE_2(TestName, TestFunc, Name, Tags, TmplList)\
        CATCH_INTERNAL_START_WARNINGS_SUPPRESSION \
        CATCH_INTERNAL_SUPPRESS_GLOBALS_WARNINGS \
        CATCH_INTERNAL_SUPPRESS_UNUSED_TEMPLATE_WARNINGS \
        template<typename TestType> static void TestFunc();       \
        namespace {\
        namespace INTERNAL_CATCH_MAKE_NAMESPACE(TestName){\
        INTERNAL_CATCH_TYPE_GEN\
        template<typename... Types>                               \
        struct TestName {                                         \
            void reg_tests() {                                          \
                int index = 0;                                    \
                using expander = int[];                           \
                (void)expander{(Catch::AutoReg( Catch::makeTestInvoker( &TestFunc<Types> ), CATCH_INTERNAL_LINEINFO, Catch::StringRef(), Catch::NameAndTags{ Name " - " + std::string(INTERNAL_CATCH_STRINGIZE(TmplList)) + " - " + std::to_string(index), Tags } ), index++, 0)... };/* NOLINT */\
            }                                                     \
        };\
        static int INTERNAL_CATCH_UNIQUE_NAME( globalRegistrar ) = [](){ \
                using TestInit = typename convert<TestName, TmplList>::type; \
                TestInit t;                                           \
                t.reg_tests();                                        \
                return 0;                                             \
            }();                                                      \
        }}\
        CATCH_INTERNAL_STOP_WARNINGS_SUPPRESSION                       \
        template<typename TestType>                                   \
        static void TestFunc()

    #define INTERNAL_CATCH_TEMPLATE_LIST_TEST_CASE(Name, Tags, TmplList) \
        INTERNAL_CATCH_TEMPLATE_LIST_TEST_CASE_2( INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_M_P_L_A_T_E____T_E_S_T____ ), INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_M_P_L_A_T_E____T_E_S_T____F_U_N_C____ ), Name, Tags, TmplList )

    #define INTERNAL_CATCH_TEMPLATE_TEST_CASE_METHOD_2( TestNameClass, TestName, ClassName, Name, Tags, Signature, ... ) \
        CATCH_INTERNAL_START_WARNINGS_SUPPRESSION \
        CATCH_INTERNAL_SUPPRESS_GLOBALS_WARNINGS \
        CATCH_INTERNAL_SUPPRESS_ZERO_VARIADIC_WARNINGS \
        CATCH_INTERNAL_SUPPRESS_UNUSED_TEMPLATE_WARNINGS \
        namespace {\
        namespace INTERNAL_CATCH_MAKE_NAMESPACE(TestName){ \
            INTERNAL_CATCH_TYPE_GEN\
            INTERNAL_CATCH_NTTP_GEN(INTERNAL_CATCH_REMOVE_PARENS(Signature))\
            INTERNAL_CATCH_DECLARE_SIG_TEST_METHOD(TestName, ClassName, INTERNAL_CATCH_REMOVE_PARENS(Signature));\
            INTERNAL_CATCH_NTTP_REG_METHOD_GEN(TestName, INTERNAL_CATCH_REMOVE_PARENS(Signature))\
            template<typename...Types> \
            struct TestNameClass{\
                TestNameClass(){\
                    int index = 0;                                    \
                    constexpr char const* tmpl_types[] = {CATCH_REC_LIST(INTERNAL_CATCH_STRINGIZE_WITHOUT_PARENS, __VA_ARGS__)};\
                    using expander = int[];\
                    (void)expander{(reg_test(Types{}, #ClassName, Catch::NameAndTags{ Name " - " + std::string(tmpl_types[index]), Tags } ), index++, 0)... };/* NOLINT */ \
                }\
            };\
            static int INTERNAL_CATCH_UNIQUE_NAME( globalRegistrar ) = [](){\
                TestNameClass<INTERNAL_CATCH_MAKE_TYPE_LISTS_FROM_TYPES(__VA_ARGS__)>();\
                return 0;\
        }();\
        }\
        }\
        CATCH_INTERNAL_STOP_WARNINGS_SUPPRESSION \
        INTERNAL_CATCH_DEFINE_SIG_TEST_METHOD(TestName, INTERNAL_CATCH_REMOVE_PARENS(Signature))

#ifndef CATCH_CONFIG_TRADITIONAL_MSVC_PREPROCESSOR
    #define INTERNAL_CATCH_TEMPLATE_TEST_CASE_METHOD( ClassName, Name, Tags,... ) \
        INTERNAL_CATCH_TEMPLATE_TEST_CASE_METHOD_2( INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_M_P_L_A_T_E____T_E_S_T____C_L_A_S_S____ ), INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_M_P_L_A_T_E____T_E_S_T____ ) , ClassName, Name, Tags, typename T, __VA_ARGS__ )
#else
    #define INTERNAL_CATCH_TEMPLATE_TEST_CASE_METHOD( ClassName, Name, Tags,... ) \
        INTERNAL_CATCH_EXPAND_VARGS( INTERNAL_CATCH_TEMPLATE_TEST_CASE_METHOD_2( INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_M_P_L_A_T_E____T_E_S_T____C_L_A_S_S____ ), INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_M_P_L_A_T_E____T_E_S_T____ ) , ClassName, Name, Tags, typename T, __VA_ARGS__ ) )
#endif

#ifndef CATCH_CONFIG_TRADITIONAL_MSVC_PREPROCESSOR
    #define INTERNAL_CATCH_TEMPLATE_TEST_CASE_METHOD_SIG( ClassName, Name, Tags, Signature, ... ) \
        INTERNAL_CATCH_TEMPLATE_TEST_CASE_METHOD_2( INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_M_P_L_A_T_E____T_E_S_T____C_L_A_S_S____ ), INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_M_P_L_A_T_E____T_E_S_T____ ) , ClassName, Name, Tags, Signature, __VA_ARGS__ )
#else
    #define INTERNAL_CATCH_TEMPLATE_TEST_CASE_METHOD_SIG( ClassName, Name, Tags, Signature, ... ) \
        INTERNAL_CATCH_EXPAND_VARGS( INTERNAL_CATCH_TEMPLATE_TEST_CASE_METHOD_2( INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_M_P_L_A_T_E____T_E_S_T____C_L_A_S_S____ ), INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_M_P_L_A_T_E____T_E_S_T____ ) , ClassName, Name, Tags, Signature, __VA_ARGS__ ) )
#endif

    #define INTERNAL_CATCH_TEMPLATE_PRODUCT_TEST_CASE_METHOD_2(TestNameClass, TestName, ClassName, Name, Tags, Signature, TmplTypes, TypesList)\
        CATCH_INTERNAL_START_WARNINGS_SUPPRESSION \
        CATCH_INTERNAL_SUPPRESS_GLOBALS_WARNINGS \
        CATCH_INTERNAL_SUPPRESS_ZERO_VARIADIC_WARNINGS \
        CATCH_INTERNAL_SUPPRESS_UNUSED_TEMPLATE_WARNINGS \
        template<typename TestType> \
            struct TestName : INTERNAL_CATCH_REMOVE_PARENS(ClassName <TestType>) { \
                void test();\
            };\
        namespace {\
        namespace INTERNAL_CATCH_MAKE_NAMESPACE(TestNameClass) {\
            INTERNAL_CATCH_TYPE_GEN                  \
            INTERNAL_CATCH_NTTP_GEN(INTERNAL_CATCH_REMOVE_PARENS(Signature))\
            template<typename...Types>\
            struct TestNameClass{\
                void reg_tests(){\
                    int index = 0;\
                    using expander = int[];\
                    constexpr char const* tmpl_types[] = {CATCH_REC_LIST(INTERNAL_CATCH_STRINGIZE_WITHOUT_PARENS, INTERNAL_CATCH_REMOVE_PARENS(TmplTypes))};\
                    constexpr char const* types_list[] = {CATCH_REC_LIST(INTERNAL_CATCH_STRINGIZE_WITHOUT_PARENS, INTERNAL_CATCH_REMOVE_PARENS(TypesList))};\
                    constexpr auto num_types = sizeof(types_list) / sizeof(types_list[0]);\
                    (void)expander{(Catch::AutoReg( Catch::makeTestInvoker( &TestName<Types>::test ), CATCH_INTERNAL_LINEINFO, #ClassName, Catch::NameAndTags{ Name " - " + std::string(tmpl_types[index / num_types]) + "<" + std::string(types_list[index % num_types]) + ">", Tags } ), index++, 0)... };/* NOLINT */ \
                }\
            };\
            static int INTERNAL_CATCH_UNIQUE_NAME( globalRegistrar ) = [](){\
                using TestInit = typename create<TestNameClass, decltype(get_wrapper<INTERNAL_CATCH_REMOVE_PARENS(TmplTypes)>()), TypeList<INTERNAL_CATCH_MAKE_TYPE_LISTS_FROM_TYPES(INTERNAL_CATCH_REMOVE_PARENS(TypesList))>>::type;\
                TestInit t;\
                t.reg_tests();\
                return 0;\
            }(); \
        }\
        }\
        CATCH_INTERNAL_STOP_WARNINGS_SUPPRESSION \
        template<typename TestType> \
        void TestName<TestType>::test()

#ifndef CATCH_CONFIG_TRADITIONAL_MSVC_PREPROCESSOR
    #define INTERNAL_CATCH_TEMPLATE_PRODUCT_TEST_CASE_METHOD( ClassName, Name, Tags, ... )\
        INTERNAL_CATCH_TEMPLATE_PRODUCT_TEST_CASE_METHOD_2( INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_M_P_L_A_T_E____T_E_S_T____ ), INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_M_P_L_A_T_E____T_E_S_T____F_U_N_C____ ), ClassName, Name, Tags, typename T, __VA_ARGS__ )
#else
    #define INTERNAL_CATCH_TEMPLATE_PRODUCT_TEST_CASE_METHOD( ClassName, Name, Tags, ... )\
        INTERNAL_CATCH_EXPAND_VARGS( INTERNAL_CATCH_TEMPLATE_PRODUCT_TEST_CASE_METHOD_2( INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_M_P_L_A_T_E____T_E_S_T____ ), INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_M_P_L_A_T_E____T_E_S_T____F_U_N_C____ ), ClassName, Name, Tags, typename T,__VA_ARGS__ ) )
#endif

#ifndef CATCH_CONFIG_TRADITIONAL_MSVC_PREPROCESSOR
    #define INTERNAL_CATCH_TEMPLATE_PRODUCT_TEST_CASE_METHOD_SIG( ClassName, Name, Tags, Signature, ... )\
        INTERNAL_CATCH_TEMPLATE_PRODUCT_TEST_CASE_METHOD_2( INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_M_P_L_A_T_E____T_E_S_T____ ), INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_M_P_L_A_T_E____T_E_S_T____F_U_N_C____ ), ClassName, Name, Tags, Signature, __VA_ARGS__ )
#else
    #define INTERNAL_CATCH_TEMPLATE_PRODUCT_TEST_CASE_METHOD_SIG( ClassName, Name, Tags, Signature, ... )\
        INTERNAL_CATCH_EXPAND_VARGS( INTERNAL_CATCH_TEMPLATE_PRODUCT_TEST_CASE_METHOD_2( INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_M_P_L_A_T_E____T_E_S_T____ ), INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_M_P_L_A_T_E____T_E_S_T____F_U_N_C____ ), ClassName, Name, Tags, Signature,__VA_ARGS__ ) )
#endif

    #define INTERNAL_CATCH_TEMPLATE_LIST_TEST_CASE_METHOD_2( TestNameClass, TestName, ClassName, Name, Tags, TmplList) \
        CATCH_INTERNAL_START_WARNINGS_SUPPRESSION \
        CATCH_INTERNAL_SUPPRESS_GLOBALS_WARNINGS \
        CATCH_INTERNAL_SUPPRESS_UNUSED_TEMPLATE_WARNINGS \
        template<typename TestType> \
        struct TestName : INTERNAL_CATCH_REMOVE_PARENS(ClassName <TestType>) { \
            void test();\
        };\
        namespace {\
        namespace INTERNAL_CATCH_MAKE_NAMESPACE(TestName){ \
            INTERNAL_CATCH_TYPE_GEN\
            template<typename...Types>\
            struct TestNameClass{\
                void reg_tests(){\
                    int index = 0;\
                    using expander = int[];\
                    (void)expander{(Catch::AutoReg( Catch::makeTestInvoker( &TestName<Types>::test ), CATCH_INTERNAL_LINEINFO, #ClassName, Catch::NameAndTags{ Name " - " + std::string(INTERNAL_CATCH_STRINGIZE(TmplList)) + " - " + std::to_string(index), Tags } ), index++, 0)... };/* NOLINT */ \
                }\
            };\
            static int INTERNAL_CATCH_UNIQUE_NAME( globalRegistrar ) = [](){\
                using TestInit = typename convert<TestNameClass, TmplList>::type;\
                TestInit t;\
                t.reg_tests();\
                return 0;\
            }(); \
        }}\
        CATCH_INTERNAL_STOP_WARNINGS_SUPPRESSION \
        template<typename TestType> \
        void TestName<TestType>::test()

#define INTERNAL_CATCH_TEMPLATE_LIST_TEST_CASE_METHOD(ClassName, Name, Tags, TmplList) \
        INTERNAL_CATCH_TEMPLATE_LIST_TEST_CASE_METHOD_2( INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_M_P_L_A_T_E____T_E_S_T____ ), INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_M_P_L_A_T_E____T_E_S_T____F_U_N_C____ ), ClassName, Name, Tags, TmplList )

// end catch_test_registry.h
// start catch_capture.hpp

// start catch_assertionhandler.h

// start catch_assertioninfo.h

// start catch_result_type.h

namespace Catch {

    // ResultWas::OfType enum
    struct ResultWas { enum OfType {
        Unknown = -1,
        Ok = 0,
        Info = 1,
        Warning = 2,

        FailureBit = 0x10,

        ExpressionFailed = FailureBit | 1,
        ExplicitFailure = FailureBit | 2,

        Exception = 0x100 | FailureBit,

        ThrewException = Exception | 1,
        DidntThrowException = Exception | 2,

        FatalErrorCondition = 0x200 | FailureBit

    }; };

    bool isOk( ResultWas::OfType resultType );
    bool isJustInfo( int flags );

    // ResultDisposition::Flags enum
    struct ResultDisposition { enum Flags {
        Normal = 0x01,

        ContinueOnFailure = 0x02,   // Failures fail test, but execution continues
        FalseTest = 0x04,           // Prefix expression with !
        SuppressFail = 0x08         // Failures are reported but do not fail the test
    }; };

    ResultDisposition::Flags operator | ( ResultDisposition::Flags lhs, ResultDisposition::Flags rhs );

    bool shouldContinueOnFailure( int flags );
    inline bool isFalseTest( int flags ) { return ( flags & ResultDisposition::FalseTest ) != 0; }
    bool shouldSuppressFailure( int flags );

} // end namespace Catch

// end catch_result_type.h
namespace Catch {

    struct AssertionInfo
    {
        StringRef macroName;
        SourceLineInfo lineInfo;
        StringRef capturedExpression;
        ResultDisposition::Flags resultDisposition;

        // We want to delete this constructor but a compiler bug in 4.8 means
        // the struct is then treated as non-aggregate
        //AssertionInfo() = delete;
    };

} // end namespace Catch

// end catch_assertioninfo.h
// start catch_decomposer.h

// start catch_tostring.h

#include <vector>
#include <cstddef>
#include <type_traits>
#include <string>
// start catch_stream.h

#include <iosfwd>
#include <cstddef>
#include <ostream>

namespace Catch {

    std::ostream& cout();
    std::ostream& cerr();
    std::ostream& clog();

    class StringRef;

    struct IStream {
        virtual ~IStream();
        virtual std::ostream& stream() const = 0;
    };

    auto makeStream( StringRef const &filename ) -> IStream const*;

    class ReusableStringStream : NonCopyable {
        std::size_t m_index;
        std::ostream* m_oss;
    public:
        ReusableStringStream();
        ~ReusableStringStream();

        auto str() const -> std::string;

        template<typename T>
        auto operator << ( T const& value ) -> ReusableStringStream& {
            *m_oss << value;
            return *this;
        }
        auto get() -> std::ostream& { return *m_oss; }
    };
}

// end catch_stream.h
// start catch_interfaces_enum_values_registry.h

#include <vector>

namespace Catch {

    namespace Detail {
        struct EnumInfo {
            StringRef m_name;
            std::vector<std::pair<int, StringRef>> m_values;

            ~EnumInfo();

            StringRef lookup( int value ) const;
        };
    } // namespace Detail

    struct IMutableEnumValuesRegistry {
        virtual ~IMutableEnumValuesRegistry();

        virtual Detail::EnumInfo const& registerEnum( StringRef enumName, StringRef allEnums, std::vector<int> const& values ) = 0;

        template<typename E>
        Detail::EnumInfo const& registerEnum( StringRef enumName, StringRef allEnums, std::initializer_list<E> values ) {
            static_assert(sizeof(int) >= sizeof(E), "Cannot serialize enum to int");
            std::vector<int> intValues;
            intValues.reserve( values.size() );
            for( auto enumValue : values )
                intValues.push_back( static_cast<int>( enumValue ) );
            return registerEnum( enumName, allEnums, intValues );
        }
    };

} // Catch

// end catch_interfaces_enum_values_registry.h

#ifdef CATCH_CONFIG_CPP17_STRING_VIEW
#include <string_view>
#endif

#ifdef __OBJC__
// start catch_objc_arc.hpp

#import <Foundation/Foundation.h>

#ifdef __has_feature
#define CATCH_ARC_ENABLED __has_feature(objc_arc)
#else
#define CATCH_ARC_ENABLED 0
#endif

void arcSafeRelease( NSObject* obj );
id performOptionalSelector( id obj, SEL sel );

#if !CATCH_ARC_ENABLED
inline void arcSafeRelease( NSObject* obj ) {
    [obj release];
}
inline id performOptionalSelector( id obj, SEL sel ) {
    if( [obj respondsToSelector: sel] )
        return [obj performSelector: sel];
    return nil;
}
#define CATCH_UNSAFE_UNRETAINED
#define CATCH_ARC_STRONG
#else
inline void arcSafeRelease( NSObject* ){}
inline id performOptionalSelector( id obj, SEL sel ) {
#ifdef __clang__
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Warc-performSelector-leaks"
#endif
    if( [obj respondsToSelector: sel] )
        return [obj performSelector: sel];
#ifdef __clang__
#pragma clang diagnostic pop
#endif
    return nil;
}
#define CATCH_UNSAFE_UNRETAINED __unsafe_unretained
#define CATCH_ARC_STRONG __strong
#endif

// end catch_objc_arc.hpp
#endif

#ifdef _MSC_VER
#pragma warning(push)
#pragma warning(disable:4180) // We attempt to stream a function (address) by const&, which MSVC complains about but is harmless
#endif

namespace Catch {
    namespace Detail {

        extern const std::string unprintableString;

        std::string rawMemoryToString( const void *object, std::size_t size );

        template<typename T>
        std::string rawMemoryToString( const T& object ) {
          return rawMemoryToString( &object, sizeof(object) );
        }

        template<typename T>
        class IsStreamInsertable {
            template<typename Stream, typename U>
            static auto test(int)
                -> decltype(std::declval<Stream&>() << std::declval<U>(), std::true_type());

            template<typename, typename>
            static auto test(...)->std::false_type;

        public:
            static const bool value = decltype(test<std::ostream, const T&>(0))::value;
        };

        template<typename E>
        std::string convertUnknownEnumToString( E e );

        template<typename T>
        typename std::enable_if<
            !std::is_enum<T>::value && !std::is_base_of<std::exception, T>::value,
        std::string>::type convertUnstreamable( T const& ) {
            return Detail::unprintableString;
        }
        template<typename T>
        typename std::enable_if<
            !std::is_enum<T>::value && std::is_base_of<std::exception, T>::value,
         std::string>::type convertUnstreamable(T const& ex) {
            return ex.what();
        }

        template<typename T>
        typename std::enable_if<
            std::is_enum<T>::value
        , std::string>::type convertUnstreamable( T const& value ) {
            return convertUnknownEnumToString( value );
        }

#if defined(_MANAGED)
        //! Convert a CLR string to a utf8 std::string
        template<typename T>
        std::string clrReferenceToString( T^ ref ) {
            if (ref == nullptr)
                return std::string("null");
            auto bytes = System::Text::Encoding::UTF8->GetBytes(ref->ToString());
            cli::pin_ptr<System::Byte> p = &bytes[0];
            return std::string(reinterpret_cast<char const *>(p), bytes->Length);
        }
#endif

    } // namespace Detail

    // If we decide for C++14, change these to enable_if_ts
    template <typename T, typename = void>
    struct StringMaker {
        template <typename Fake = T>
        static
        typename std::enable_if<::Catch::Detail::IsStreamInsertable<Fake>::value, std::string>::type
            convert(const Fake& value) {
                ReusableStringStream rss;
                // NB: call using the function-like syntax to avoid ambiguity with
                // user-defined templated operator<< under clang.
                rss.operator<<(value);
                return rss.str();
        }

        template <typename Fake = T>
        static
        typename std::enable_if<!::Catch::Detail::IsStreamInsertable<Fake>::value, std::string>::type
            convert( const Fake& value ) {
#if !defined(CATCH_CONFIG_FALLBACK_STRINGIFIER)
            return Detail::convertUnstreamable(value);
#else
            return CATCH_CONFIG_FALLBACK_STRINGIFIER(value);
#endif
        }
    };

    namespace Detail {

        // This function dispatches all stringification requests inside of Catch.
        // Should be preferably called fully qualified, like ::Catch::Detail::stringify
        template <typename T>
        std::string stringify(const T& e) {
            return ::Catch::StringMaker<typename std::remove_cv<typename std::remove_reference<T>::type>::type>::convert(e);
        }

        template<typename E>
        std::string convertUnknownEnumToString( E e ) {
            return ::Catch::Detail::stringify(static_cast<typename std::underlying_type<E>::type>(e));
        }

#if defined(_MANAGED)
        template <typename T>
        std::string stringify( T^ e ) {
            return ::Catch::StringMaker<T^>::convert(e);
        }
#endif

    } // namespace Detail

    // Some predefined specializations

    template<>
    struct StringMaker<std::string> {
        static std::string convert(const std::string& str);
    };

#ifdef CATCH_CONFIG_CPP17_STRING_VIEW
    template<>
    struct StringMaker<std::string_view> {
        static std::string convert(std::string_view str);
    };
#endif

    template<>
    struct StringMaker<char const *> {
        static std::string convert(char const * str);
    };
    template<>
    struct StringMaker<char *> {
        static std::string convert(char * str);
    };

#ifdef CATCH_CONFIG_WCHAR
    template<>
    struct StringMaker<std::wstring> {
        static std::string convert(const std::wstring& wstr);
    };

# ifdef CATCH_CONFIG_CPP17_STRING_VIEW
    template<>
    struct StringMaker<std::wstring_view> {
        static std::string convert(std::wstring_view str);
    };
# endif

    template<>
    struct StringMaker<wchar_t const *> {
        static std::string convert(wchar_t const * str);
    };
    template<>
    struct StringMaker<wchar_t *> {
        static std::string convert(wchar_t * str);
    };
#endif

    // TBD: Should we use `strnlen` to ensure that we don't go out of the buffer,
    //      while keeping string semantics?
    template<int SZ>
    struct StringMaker<char[SZ]> {
        static std::string convert(char const* str) {
            return ::Catch::Detail::stringify(std::string{ str });
        }
    };
    template<int SZ>
    struct StringMaker<signed char[SZ]> {
        static std::string convert(signed char const* str) {
            return ::Catch::Detail::stringify(std::string{ reinterpret_cast<char const *>(str) });
        }
    };
    template<int SZ>
    struct StringMaker<unsigned char[SZ]> {
        static std::string convert(unsigned char const* str) {
            return ::Catch::Detail::stringify(std::string{ reinterpret_cast<char const *>(str) });
        }
    };

#if defined(CATCH_CONFIG_CPP17_BYTE)
    template<>
    struct StringMaker<std::byte> {
        static std::string convert(std::byte value);
    };
#endif // defined(CATCH_CONFIG_CPP17_BYTE)
    template<>
    struct StringMaker<int> {
        static std::string convert(int value);
    };
    template<>
    struct StringMaker<long> {
        static std::string convert(long value);
    };
    template<>
    struct StringMaker<long long> {
        static std::string convert(long long value);
    };
    template<>
    struct StringMaker<unsigned int> {
        static std::string convert(unsigned int value);
    };
    template<>
    struct StringMaker<unsigned long> {
        static std::string convert(unsigned long value);
    };
    template<>
    struct StringMaker<unsigned long long> {
        static std::string convert(unsigned long long value);
    };

    template<>
    struct StringMaker<bool> {
        static std::string convert(bool b);
    };

    template<>
    struct StringMaker<char> {
        static std::string convert(char c);
    };
    template<>
    struct StringMaker<signed char> {
        static std::string convert(signed char c);
    };
    template<>
    struct StringMaker<unsigned char> {
        static std::string convert(unsigned char c);
    };

    template<>
    struct StringMaker<std::nullptr_t> {
        static std::string convert(std::nullptr_t);
    };

    template<>
    struct StringMaker<float> {
        static std::string convert(float value);
        static int precision;
    };

    template<>
    struct StringMaker<double> {
        static std::string convert(double value);
        static int precision;
    };

    template <typename T>
    struct StringMaker<T*> {
        template <typename U>
        static std::string convert(U* p) {
            if (p) {
                return ::Catch::Detail::rawMemoryToString(p);
            } else {
                return "nullptr";
            }
        }
    };

    template <typename R, typename C>
    struct StringMaker<R C::*> {
        static std::string convert(R C::* p) {
            if (p) {
                return ::Catch::Detail::rawMemoryToString(p);
            } else {
                return "nullptr";
            }
        }
    };

#if defined(_MANAGED)
    template <typename T>
    struct StringMaker<T^> {
        static std::string convert( T^ ref ) {
            return ::Catch::Detail::clrReferenceToString(ref);
        }
    };
#endif

    namespace Detail {
        template<typename InputIterator>
        std::string rangeToString(InputIterator first, InputIterator last) {
            ReusableStringStream rss;
            rss << "{ ";
            if (first != last) {
                rss << ::Catch::Detail::stringify(*first);
                for (++first; first != last; ++first)
                    rss << ", " << ::Catch::Detail::stringify(*first);
            }
            rss << " }";
            return rss.str();
        }
    }

#ifdef __OBJC__
    template<>
    struct StringMaker<NSString*> {
        static std::string convert(NSString * nsstring) {
            if (!nsstring)
                return "nil";
            return std::string("@") + [nsstring UTF8String];
        }
    };
    template<>
    struct StringMaker<NSObject*> {
        static std::string convert(NSObject* nsObject) {
            return ::Catch::Detail::stringify([nsObject description]);
        }

    };
    namespace Detail {
        inline std::string stringify( NSString* nsstring ) {
            return StringMaker<NSString*>::convert( nsstring );
        }

    } // namespace Detail
#endif // __OBJC__

} // namespace Catch

//////////////////////////////////////////////////////
// Separate std-lib types stringification, so it can be selectively enabled
// This means that we do not bring in

#if defined(CATCH_CONFIG_ENABLE_ALL_STRINGMAKERS)
#  define CATCH_CONFIG_ENABLE_PAIR_STRINGMAKER
#  define CATCH_CONFIG_ENABLE_TUPLE_STRINGMAKER
#  define CATCH_CONFIG_ENABLE_VARIANT_STRINGMAKER
#  define CATCH_CONFIG_ENABLE_CHRONO_STRINGMAKER
#  define CATCH_CONFIG_ENABLE_OPTIONAL_STRINGMAKER
#endif

// Separate std::pair specialization
#if defined(CATCH_CONFIG_ENABLE_PAIR_STRINGMAKER)
#include <utility>
namespace Catch {
    template<typename T1, typename T2>
    struct StringMaker<std::pair<T1, T2> > {
        static std::string convert(const std::pair<T1, T2>& pair) {
            ReusableStringStream rss;
            rss << "{ "
                << ::Catch::Detail::stringify(pair.first)
                << ", "
                << ::Catch::Detail::stringify(pair.second)
                << " }";
            return rss.str();
        }
    };
}
#endif // CATCH_CONFIG_ENABLE_PAIR_STRINGMAKER

#if defined(CATCH_CONFIG_ENABLE_OPTIONAL_STRINGMAKER) && defined(CATCH_CONFIG_CPP17_OPTIONAL)
#include <optional>
namespace Catch {
    template<typename T>
    struct StringMaker<std::optional<T> > {
        static std::string convert(const std::optional<T>& optional) {
            ReusableStringStream rss;
            if (optional.has_value()) {
                rss << ::Catch::Detail::stringify(*optional);
            } else {
                rss << "{ }";
            }
            return rss.str();
        }
    };
}
#endif // CATCH_CONFIG_ENABLE_OPTIONAL_STRINGMAKER

// Separate std::tuple specialization
#if defined(CATCH_CONFIG_ENABLE_TUPLE_STRINGMAKER)
#include <tuple>
namespace Catch {
    namespace Detail {
        template<
            typename Tuple,
            std::size_t N = 0,
            bool = (N < std::tuple_size<Tuple>::value)
            >
            struct TupleElementPrinter {
            static void print(const Tuple& tuple, std::ostream& os) {
                os << (N ? ", " : " ")
                    << ::Catch::Detail::stringify(std::get<N>(tuple));
                TupleElementPrinter<Tuple, N + 1>::print(tuple, os);
            }
        };

        template<
            typename Tuple,
            std::size_t N
        >
            struct TupleElementPrinter<Tuple, N, false> {
            static void print(const Tuple&, std::ostream&) {}
        };

    }

    template<typename ...Types>
    struct StringMaker<std::tuple<Types...>> {
        static std::string convert(const std::tuple<Types...>& tuple) {
            ReusableStringStream rss;
            rss << '{';
            Detail::TupleElementPrinter<std::tuple<Types...>>::print(tuple, rss.get());
            rss << " }";
            return rss.str();
        }
    };
}
#endif // CATCH_CONFIG_ENABLE_TUPLE_STRINGMAKER

#if defined(CATCH_CONFIG_ENABLE_VARIANT_STRINGMAKER) && defined(CATCH_CONFIG_CPP17_VARIANT)
#include <variant>
namespace Catch {
    template<>
    struct StringMaker<std::monostate> {
        static std::string convert(const std::monostate&) {
            return "{ }";
        }
    };

    template<typename... Elements>
    struct StringMaker<std::variant<Elements...>> {
        static std::string convert(const std::variant<Elements...>& variant) {
            if (variant.valueless_by_exception()) {
                return "{valueless variant}";
            } else {
                return std::visit(
                    [](const auto& value) {
                        return ::Catch::Detail::stringify(value);
                    },
                    variant
                );
            }
        }
    };
}
#endif // CATCH_CONFIG_ENABLE_VARIANT_STRINGMAKER

namespace Catch {
    // Import begin/ end from std here
    using std::begin;
    using std::end;

    namespace detail {
        template <typename...>
        struct void_type {
            using type = void;
        };

        template <typename T, typename = void>
        struct is_range_impl : std::false_type {
        };

        template <typename T>
        struct is_range_impl<T, typename void_type<decltype(begin(std::declval<T>()))>::type> : std::true_type {
        };
    } // namespace detail

    template <typename T>
    struct is_range : detail::is_range_impl<T> {
    };

#if defined(_MANAGED) // Managed types are never ranges
    template <typename T>
    struct is_range<T^> {
        static const bool value = false;
    };
#endif

    template<typename Range>
    std::string rangeToString( Range const& range ) {
        return ::Catch::Detail::rangeToString( begin( range ), end( range ) );
    }

    // Handle vector<bool> specially
    template<typename Allocator>
    std::string rangeToString( std::vector<bool, Allocator> const& v ) {
        ReusableStringStream rss;
        rss << "{ ";
        bool first = true;
        for( bool b : v ) {
            if( first )
                first = false;
            else
                rss << ", ";
            rss << ::Catch::Detail::stringify( b );
        }
        rss << " }";
        return rss.str();
    }

    template<typename R>
    struct StringMaker<R, typename std::enable_if<is_range<R>::value && !::Catch::Detail::IsStreamInsertable<R>::value>::type> {
        static std::string convert( R const& range ) {
            return rangeToString( range );
        }
    };

    template <typename T, int SZ>
    struct StringMaker<T[SZ]> {
        static std::string convert(T const(&arr)[SZ]) {
            return rangeToString(arr);
        }
    };

} // namespace Catch

// Separate std::chrono::duration specialization
#if defined(CATCH_CONFIG_ENABLE_CHRONO_STRINGMAKER)
#include <ctime>
#include <ratio>
#include <chrono>

namespace Catch {

template <class Ratio>
struct ratio_string {
    static std::string symbol();
};

template <class Ratio>
std::string ratio_string<Ratio>::symbol() {
    Catch::ReusableStringStream rss;
    rss << '[' << Ratio::num << '/'
        << Ratio::den << ']';
    return rss.str();
}
template <>
struct ratio_string<std::atto> {
    static std::string symbol();
};
template <>
struct ratio_string<std::femto> {
    static std::string symbol();
};
template <>
struct ratio_string<std::pico> {
    static std::string symbol();
};
template <>
struct ratio_string<std::nano> {
    static std::string symbol();
};
template <>
struct ratio_string<std::micro> {
    static std::string symbol();
};
template <>
struct ratio_string<std::milli> {
    static std::string symbol();
};

    ////////////
    // std::chrono::duration specializations
    template<typename Value, typename Ratio>
    struct StringMaker<std::chrono::duration<Value, Ratio>> {
        static std::string convert(std::chrono::duration<Value, Ratio> const& duration) {
            ReusableStringStream rss;
            rss << duration.count() << ' ' << ratio_string<Ratio>::symbol() << 's';
            return rss.str();
        }
    };
    template<typename Value>
    struct StringMaker<std::chrono::duration<Value, std::ratio<1>>> {
        static std::string convert(std::chrono::duration<Value, std::ratio<1>> const& duration) {
            ReusableStringStream rss;
            rss << duration.count() << " s";
            return rss.str();
        }
    };
    template<typename Value>
    struct StringMaker<std::chrono::duration<Value, std::ratio<60>>> {
        static std::string convert(std::chrono::duration<Value, std::ratio<60>> const& duration) {
            ReusableStringStream rss;
            rss << duration.count() << " m";
            return rss.str();
        }
    };
    template<typename Value>
    struct StringMaker<std::chrono::duration<Value, std::ratio<3600>>> {
        static std::string convert(std::chrono::duration<Value, std::ratio<3600>> const& duration) {
            ReusableStringStream rss;
            rss << duration.count() << " h";
            return rss.str();
        }
    };

    ////////////
    // std::chrono::time_point specialization
    // Generic time_point cannot be specialized, only std::chrono::time_point<system_clock>
    template<typename Clock, typename Duration>
    struct StringMaker<std::chrono::time_point<Clock, Duration>> {
        static std::string convert(std::chrono::time_point<Clock, Duration> const& time_point) {
            return ::Catch::Detail::stringify(time_point.time_since_epoch()) + " since epoch";
        }
    };
    // std::chrono::time_point<system_clock> specialization
    template<typename Duration>
    struct StringMaker<std::chrono::time_point<std::chrono::system_clock, Duration>> {
        static std::string convert(std::chrono::time_point<std::chrono::system_clock, Duration> const& time_point) {
            auto converted = std::chrono::system_clock::to_time_t(time_point);

#ifdef _MSC_VER
            std::tm timeInfo = {};
            gmtime_s(&timeInfo, &converted);
#else
            std::tm* timeInfo = std::gmtime(&converted);
#endif

            auto const timeStampSize = sizeof("2017-01-16T17:06:45Z");
            char timeStamp[timeStampSize];
            const char * const fmt = "%Y-%m-%dT%H:%M:%SZ";

#ifdef _MSC_VER
            std::strftime(timeStamp, timeStampSize, fmt, &timeInfo);
#else
            std::strftime(timeStamp, timeStampSize, fmt, timeInfo);
#endif
            return std::string(timeStamp);
        }
    };
}
#endif // CATCH_CONFIG_ENABLE_CHRONO_STRINGMAKER

#define INTERNAL_CATCH_REGISTER_ENUM( enumName, ... ) \
namespace Catch { \
    template<> struct StringMaker<enumName> { \
        static std::string convert( enumName value ) { \
            static const auto& enumInfo = ::Catch::getMutableRegistryHub().getMutableEnumValuesRegistry().registerEnum( #enumName, #__VA_ARGS__, { __VA_ARGS__ } ); \
            return static_cast<std::string>(enumInfo.lookup( static_cast<int>( value ) )); \
        } \
    }; \
}

#define CATCH_REGISTER_ENUM( enumName, ... ) INTERNAL_CATCH_REGISTER_ENUM( enumName, __VA_ARGS__ )

#ifdef _MSC_VER
#pragma warning(pop)
#endif

// end catch_tostring.h
#include <iosfwd>

#ifdef _MSC_VER
#pragma warning(push)
#pragma warning(disable:4389) // '==' : signed/unsigned mismatch
#pragma warning(disable:4018) // more "signed/unsigned mismatch"
#pragma warning(disable:4312) // Converting int to T* using reinterpret_cast (issue on x64 platform)
#pragma warning(disable:4180) // qualifier applied to function type has no meaning
#pragma warning(disable:4800) // Forcing result to true or false
#endif

namespace Catch {

    struct ITransientExpression {
        auto isBinaryExpression() const -> bool { return m_isBinaryExpression; }
        auto getResult() const -> bool { return m_result; }
        virtual void streamReconstructedExpression( std::ostream &os ) const = 0;

        ITransientExpression( bool isBinaryExpression, bool result )
        :   m_isBinaryExpression( isBinaryExpression ),
            m_result( result )
        {}

        // We don't actually need a virtual destructor, but many static analysers
        // complain if it's not here :-(
        virtual ~ITransientExpression();

        bool m_isBinaryExpression;
        bool m_result;

    };

    void formatReconstructedExpression( std::ostream &os, std::string const& lhs, StringRef op, std::string const& rhs );

    template<typename LhsT, typename RhsT>
    class BinaryExpr  : public ITransientExpression {
        LhsT m_lhs;
        StringRef m_op;
        RhsT m_rhs;

        void streamReconstructedExpression( std::ostream &os ) const override {
            formatReconstructedExpression
                    ( os, Catch::Detail::stringify( m_lhs ), m_op, Catch::Detail::stringify( m_rhs ) );
        }

    public:
        BinaryExpr( bool comparisonResult, LhsT lhs, StringRef op, RhsT rhs )
        :   ITransientExpression{ true, comparisonResult },
            m_lhs( lhs ),
            m_op( op ),
            m_rhs( rhs )
        {}

        template<typename T>
        auto operator && ( T ) const -> BinaryExpr<LhsT, RhsT const&> const {
            static_assert(always_false<T>::value,
            "chained comparisons are not supported inside assertions, "
            "wrap the expression inside parentheses, or decompose it");
        }

        template<typename T>
        auto operator || ( T ) const -> BinaryExpr<LhsT, RhsT const&> const {
            static_assert(always_false<T>::value,
            "chained comparisons are not supported inside assertions, "
            "wrap the expression inside parentheses, or decompose it");
        }

        template<typename T>
        auto operator == ( T ) const -> BinaryExpr<LhsT, RhsT const&> const {
            static_assert(always_false<T>::value,
            "chained comparisons are not supported inside assertions, "
            "wrap the expression inside parentheses, or decompose it");
        }

        template<typename T>
        auto operator != ( T ) const -> BinaryExpr<LhsT, RhsT const&> const {
            static_assert(always_false<T>::value,
            "chained comparisons are not supported inside assertions, "
            "wrap the expression inside parentheses, or decompose it");
        }

        template<typename T>
        auto operator > ( T ) const -> BinaryExpr<LhsT, RhsT const&> const {
            static_assert(always_false<T>::value,
            "chained comparisons are not supported inside assertions, "
            "wrap the expression inside parentheses, or decompose it");
        }

        template<typename T>
        auto operator < ( T ) const -> BinaryExpr<LhsT, RhsT const&> const {
            static_assert(always_false<T>::value,
            "chained comparisons are not supported inside assertions, "
            "wrap the expression inside parentheses, or decompose it");
        }

        template<typename T>
        auto operator >= ( T ) const -> BinaryExpr<LhsT, RhsT const&> const {
            static_assert(always_false<T>::value,
            "chained comparisons are not supported inside assertions, "
            "wrap the expression inside parentheses, or decompose it");
        }

        template<typename T>
        auto operator <= ( T ) const -> BinaryExpr<LhsT, RhsT const&> const {
            static_assert(always_false<T>::value,
            "chained comparisons are not supported inside assertions, "
            "wrap the expression inside parentheses, or decompose it");
        }
    };

    template<typename LhsT>
    class UnaryExpr : public ITransientExpression {
        LhsT m_lhs;

        void streamReconstructedExpression( std::ostream &os ) const override {
            os << Catch::Detail::stringify( m_lhs );
        }

    public:
        explicit UnaryExpr( LhsT lhs )
        :   ITransientExpression{ false, static_cast<bool>(lhs) },
            m_lhs( lhs )
        {}
    };

    // Specialised comparison functions to handle equality comparisons between ints and pointers (NULL deduces as an int)
    template<typename LhsT, typename RhsT>
    auto compareEqual( LhsT const& lhs, RhsT const& rhs ) -> bool { return static_cast<bool>(lhs == rhs); }
    template<typename T>
    auto compareEqual( T* const& lhs, int rhs ) -> bool { return lhs == reinterpret_cast<void const*>( rhs ); }
    template<typename T>
    auto compareEqual( T* const& lhs, long rhs ) -> bool { return lhs == reinterpret_cast<void const*>( rhs ); }
    template<typename T>
    auto compareEqual( int lhs, T* const& rhs ) -> bool { return reinterpret_cast<void const*>( lhs ) == rhs; }
    template<typename T>
    auto compareEqual( long lhs, T* const& rhs ) -> bool { return reinterpret_cast<void const*>( lhs ) == rhs; }

    template<typename LhsT, typename RhsT>
    auto compareNotEqual( LhsT const& lhs, RhsT&& rhs ) -> bool { return static_cast<bool>(lhs != rhs); }
    template<typename T>
    auto compareNotEqual( T* const& lhs, int rhs ) -> bool { return lhs != reinterpret_cast<void const*>( rhs ); }
    template<typename T>
    auto compareNotEqual( T* const& lhs, long rhs ) -> bool { return lhs != reinterpret_cast<void const*>( rhs ); }
    template<typename T>
    auto compareNotEqual( int lhs, T* const& rhs ) -> bool { return reinterpret_cast<void const*>( lhs ) != rhs; }
    template<typename T>
    auto compareNotEqual( long lhs, T* const& rhs ) -> bool { return reinterpret_cast<void const*>( lhs ) != rhs; }

    template<typename LhsT>
    class ExprLhs {
        LhsT m_lhs;
    public:
        explicit ExprLhs( LhsT lhs ) : m_lhs( lhs ) {}

        template<typename RhsT>
        auto operator == ( RhsT const& rhs ) -> BinaryExpr<LhsT, RhsT const&> const {
            return { compareEqual( m_lhs, rhs ), m_lhs, "==", rhs };
        }
        auto operator == ( bool rhs ) -> BinaryExpr<LhsT, bool> const {
            return { m_lhs == rhs, m_lhs, "==", rhs };
        }

        template<typename RhsT>
        auto operator != ( RhsT const& rhs ) -> BinaryExpr<LhsT, RhsT const&> const {
            return { compareNotEqual( m_lhs, rhs ), m_lhs, "!=", rhs };
        }
        auto operator != ( bool rhs ) -> BinaryExpr<LhsT, bool> const {
            return { m_lhs != rhs, m_lhs, "!=", rhs };
        }

        template<typename RhsT>
        auto operator > ( RhsT const& rhs ) -> BinaryExpr<LhsT, RhsT const&> const {
            return { static_cast<bool>(m_lhs > rhs), m_lhs, ">", rhs };
        }
        template<typename RhsT>
        auto operator < ( RhsT const& rhs ) -> BinaryExpr<LhsT, RhsT const&> const {
            return { static_cast<bool>(m_lhs < rhs), m_lhs, "<", rhs };
        }
        template<typename RhsT>
        auto operator >= ( RhsT const& rhs ) -> BinaryExpr<LhsT, RhsT const&> const {
            return { static_cast<bool>(m_lhs >= rhs), m_lhs, ">=", rhs };
        }
        template<typename RhsT>
        auto operator <= ( RhsT const& rhs ) -> BinaryExpr<LhsT, RhsT const&> const {
            return { static_cast<bool>(m_lhs <= rhs), m_lhs, "<=", rhs };
        }
        template <typename RhsT>
        auto operator | (RhsT const& rhs) -> BinaryExpr<LhsT, RhsT const&> const {
            return { static_cast<bool>(m_lhs | rhs), m_lhs, "|", rhs };
        }
        template <typename RhsT>
        auto operator & (RhsT const& rhs) -> BinaryExpr<LhsT, RhsT const&> const {
            return { static_cast<bool>(m_lhs & rhs), m_lhs, "&", rhs };
        }
        template <typename RhsT>
        auto operator ^ (RhsT const& rhs) -> BinaryExpr<LhsT, RhsT const&> const {
            return { static_cast<bool>(m_lhs ^ rhs), m_lhs, "^", rhs };
        }

        template<typename RhsT>
        auto operator && ( RhsT const& ) -> BinaryExpr<LhsT, RhsT const&> const {
            static_assert(always_false<RhsT>::value,
            "operator&& is not supported inside assertions, "
            "wrap the expression inside parentheses, or decompose it");
        }

        template<typename RhsT>
        auto operator || ( RhsT const& ) -> BinaryExpr<LhsT, RhsT const&> const {
            static_assert(always_false<RhsT>::value,
            "operator|| is not supported inside assertions, "
            "wrap the expression inside parentheses, or decompose it");
        }

        auto makeUnaryExpr() const -> UnaryExpr<LhsT> {
            return UnaryExpr<LhsT>{ m_lhs };
        }
    };

    void handleExpression( ITransientExpression const& expr );

    template<typename T>
    void handleExpression( ExprLhs<T> const& expr ) {
        handleExpression( expr.makeUnaryExpr() );
    }

    struct Decomposer {
        template<typename T>
        auto operator <= ( T const& lhs ) -> ExprLhs<T const&> {
            return ExprLhs<T const&>{ lhs };
        }

        auto operator <=( bool value ) -> ExprLhs<bool> {
            return ExprLhs<bool>{ value };
        }
    };

} // end namespace Catch

#ifdef _MSC_VER
#pragma warning(pop)
#endif

// end catch_decomposer.h
// start catch_interfaces_capture.h

#include <string>
#include <chrono>

namespace Catch {

    class AssertionResult;
    struct AssertionInfo;
    struct SectionInfo;
    struct SectionEndInfo;
    struct MessageInfo;
    struct MessageBuilder;
    struct Counts;
    struct AssertionReaction;
    struct SourceLineInfo;

    struct ITransientExpression;
    struct IGeneratorTracker;

#if defined(CATCH_CONFIG_ENABLE_BENCHMARKING)
    struct BenchmarkInfo;
    template <typename Duration = std::chrono::duration<double, std::nano>>
    struct BenchmarkStats;
#endif // CATCH_CONFIG_ENABLE_BENCHMARKING

    struct IResultCapture {

        virtual ~IResultCapture();

        virtual bool sectionStarted(    SectionInfo const& sectionInfo,
                                        Counts& assertions ) = 0;
        virtual void sectionEnded( SectionEndInfo const& endInfo ) = 0;
        virtual void sectionEndedEarly( SectionEndInfo const& endInfo ) = 0;

        virtual auto acquireGeneratorTracker( StringRef generatorName, SourceLineInfo const& lineInfo ) -> IGeneratorTracker& = 0;

#if defined(CATCH_CONFIG_ENABLE_BENCHMARKING)
        virtual void benchmarkPreparing( std::string const& name ) = 0;
        virtual void benchmarkStarting( BenchmarkInfo const& info ) = 0;
        virtual void benchmarkEnded( BenchmarkStats<> const& stats ) = 0;
        virtual void benchmarkFailed( std::string const& error ) = 0;
#endif // CATCH_CONFIG_ENABLE_BENCHMARKING

        virtual void pushScopedMessage( MessageInfo const& message ) = 0;
        virtual void popScopedMessage( MessageInfo const& message ) = 0;

        virtual void emplaceUnscopedMessage( MessageBuilder const& builder ) = 0;

        virtual void handleFatalErrorCondition( StringRef message ) = 0;

        virtual void handleExpr
                (   AssertionInfo const& info,
                    ITransientExpression const& expr,
                    AssertionReaction& reaction ) = 0;
        virtual void handleMessage
                (   AssertionInfo const& info,
                    ResultWas::OfType resultType,
                    StringRef const& message,
                    AssertionReaction& reaction ) = 0;
        virtual void handleUnexpectedExceptionNotThrown
                (   AssertionInfo const& info,
                    AssertionReaction& reaction ) = 0;
        virtual void handleUnexpectedInflightException
                (   AssertionInfo const& info,
                    std::string const& message,
                    AssertionReaction& reaction ) = 0;
        virtual void handleIncomplete
                (   AssertionInfo const& info ) = 0;
        virtual void handleNonExpr
                (   AssertionInfo const &info,
                    ResultWas::OfType resultType,
                    AssertionReaction &reaction ) = 0;

        virtual bool lastAssertionPassed() = 0;
        virtual void assertionPassed() = 0;

        // Deprecated, do not use:
        virtual std::string getCurrentTestName() const = 0;
        virtual const AssertionResult* getLastResult() const = 0;
        virtual void exceptionEarlyReported() = 0;
    };

    IResultCapture& getResultCapture();
}

// end catch_interfaces_capture.h
namespace Catch {

    struct TestFailureException{};
    struct AssertionResultData;
    struct IResultCapture;
    class RunContext;

    class LazyExpression {
        friend class AssertionHandler;
        friend struct AssertionStats;
        friend class RunContext;

        ITransientExpression const* m_transientExpression = nullptr;
        bool m_isNegated;
    public:
        LazyExpression( bool isNegated );
        LazyExpression( LazyExpression const& other );
        LazyExpression& operator = ( LazyExpression const& ) = delete;

        explicit operator bool() const;

        friend auto operator << ( std::ostream& os, LazyExpression const& lazyExpr ) -> std::ostream&;
    };

    struct AssertionReaction {
        bool shouldDebugBreak = false;
        bool shouldThrow = false;
    };

    class AssertionHandler {
        AssertionInfo m_assertionInfo;
        AssertionReaction m_reaction;
        bool m_completed = false;
        IResultCapture& m_resultCapture;

    public:
        AssertionHandler
            (   StringRef const& macroName,
                SourceLineInfo const& lineInfo,
                StringRef capturedExpression,
                ResultDisposition::Flags resultDisposition );
        ~AssertionHandler() {
            if ( !m_completed ) {
                m_resultCapture.handleIncomplete( m_assertionInfo );
            }
        }

        template<typename T>
        void handleExpr( ExprLhs<T> const& expr ) {
            handleExpr( expr.makeUnaryExpr() );
        }
        void handleExpr( ITransientExpression const& expr );

        void handleMessage(ResultWas::OfType resultType, StringRef const& message);

        void handleExceptionThrownAsExpected();
        void handleUnexpectedExceptionNotThrown();
        void handleExceptionNotThrownAsExpected();
        void handleThrowingCallSkipped();
        void handleUnexpectedInflightException();

        void complete();
        void setCompleted();

        // query
        auto allowThrows() const -> bool;
    };

    void handleExceptionMatchExpr( AssertionHandler& handler, std::string const& str, StringRef const& matcherString );

} // namespace Catch

// end catch_assertionhandler.h
// start catch_message.h

#include <string>
#include <vector>

namespace Catch {

    struct MessageInfo {
        MessageInfo(    StringRef const& _macroName,
                        SourceLineInfo const& _lineInfo,
                        ResultWas::OfType _type );

        StringRef macroName;
        std::string message;
        SourceLineInfo lineInfo;
        ResultWas::OfType type;
        unsigned int sequence;

        bool operator == ( MessageInfo const& other ) const;
        bool operator < ( MessageInfo const& other ) const;
    private:
        static unsigned int globalCount;
    };

    struct MessageStream {

        template<typename T>
        MessageStream& operator << ( T const& value ) {
            m_stream << value;
            return *this;
        }

        ReusableStringStream m_stream;
    };

    struct MessageBuilder : MessageStream {
        MessageBuilder( StringRef const& macroName,
                        SourceLineInfo const& lineInfo,
                        ResultWas::OfType type );

        template<typename T>
        MessageBuilder& operator << ( T const& value ) {
            m_stream << value;
            return *this;
        }

        MessageInfo m_info;
    };

    class ScopedMessage {
    public:
        explicit ScopedMessage( MessageBuilder const& builder );
        ScopedMessage( ScopedMessage& duplicate ) = delete;
        ScopedMessage( ScopedMessage&& old );
        ~ScopedMessage();

        MessageInfo m_info;
        bool m_moved;
    };

    class Capturer {
        std::vector<MessageInfo> m_messages;
        IResultCapture& m_resultCapture = getResultCapture();
        size_t m_captured = 0;
    public:
        Capturer( StringRef macroName, SourceLineInfo const& lineInfo, ResultWas::OfType resultType, StringRef names );
        ~Capturer();

        void captureValue( size_t index, std::string const& value );

        template<typename T>
        void captureValues( size_t index, T const& value ) {
            captureValue( index, Catch::Detail::stringify( value ) );
        }

        template<typename T, typename... Ts>
        void captureValues( size_t index, T const& value, Ts const&... values ) {
            captureValue( index, Catch::Detail::stringify(value) );
            captureValues( index+1, values... );
        }
    };

} // end namespace Catch

// end catch_message.h
#if !defined(CATCH_CONFIG_DISABLE)

#if !defined(CATCH_CONFIG_DISABLE_STRINGIFICATION)
  #define CATCH_INTERNAL_STRINGIFY(...) #__VA_ARGS__
#else
  #define CATCH_INTERNAL_STRINGIFY(...) "Disabled by CATCH_CONFIG_DISABLE_STRINGIFICATION"
#endif

#if defined(CATCH_CONFIG_FAST_COMPILE) || defined(CATCH_CONFIG_DISABLE_EXCEPTIONS)

///////////////////////////////////////////////////////////////////////////////
// Another way to speed-up compilation is to omit local try-catch for REQUIRE*
// macros.
#define INTERNAL_CATCH_TRY
#define INTERNAL_CATCH_CATCH( capturer )

#else // CATCH_CONFIG_FAST_COMPILE

#define INTERNAL_CATCH_TRY try
#define INTERNAL_CATCH_CATCH( handler ) catch(...) { handler.handleUnexpectedInflightException(); }

#endif

#define INTERNAL_CATCH_REACT( handler ) handler.complete();

///////////////////////////////////////////////////////////////////////////////
#define INTERNAL_CATCH_TEST( macroName, resultDisposition, ... ) \
    do { \
        CATCH_INTERNAL_IGNORE_BUT_WARN(__VA_ARGS__); \
        Catch::AssertionHandler catchAssertionHandler( macroName##_catch_sr, CATCH_INTERNAL_LINEINFO, CATCH_INTERNAL_STRINGIFY(__VA_ARGS__), resultDisposition ); \
        INTERNAL_CATCH_TRY { \
            CATCH_INTERNAL_START_WARNINGS_SUPPRESSION \
            CATCH_INTERNAL_SUPPRESS_PARENTHESES_WARNINGS \
            catchAssertionHandler.handleExpr( Catch::Decomposer() <= __VA_ARGS__ ); \
            CATCH_INTERNAL_STOP_WARNINGS_SUPPRESSION \
        } INTERNAL_CATCH_CATCH( catchAssertionHandler ) \
        INTERNAL_CATCH_REACT( catchAssertionHandler ) \
    } while( (void)0, (false) && static_cast<bool>( !!(__VA_ARGS__) ) )

///////////////////////////////////////////////////////////////////////////////
#define INTERNAL_CATCH_IF( macroName, resultDisposition, ... ) \
    INTERNAL_CATCH_TEST( macroName, resultDisposition, __VA_ARGS__ ); \
    if( Catch::getResultCapture().lastAssertionPassed() )

///////////////////////////////////////////////////////////////////////////////
#define INTERNAL_CATCH_ELSE( macroName, resultDisposition, ... ) \
    INTERNAL_CATCH_TEST( macroName, resultDisposition, __VA_ARGS__ ); \
    if( !Catch::getResultCapture().lastAssertionPassed() )

///////////////////////////////////////////////////////////////////////////////
#define INTERNAL_CATCH_NO_THROW( macroName, resultDisposition, ... ) \
    do { \
        Catch::AssertionHandler catchAssertionHandler( macroName##_catch_sr, CATCH_INTERNAL_LINEINFO, CATCH_INTERNAL_STRINGIFY(__VA_ARGS__), resultDisposition ); \
        try { \
            static_cast<void>(__VA_ARGS__); \
            catchAssertionHandler.handleExceptionNotThrownAsExpected(); \
        } \
        catch( ... ) { \
            catchAssertionHandler.handleUnexpectedInflightException(); \
        } \
        INTERNAL_CATCH_REACT( catchAssertionHandler ) \
    } while( false )

///////////////////////////////////////////////////////////////////////////////
#define INTERNAL_CATCH_THROWS( macroName, resultDisposition, ... ) \
    do { \
        Catch::AssertionHandler catchAssertionHandler( macroName##_catch_sr, CATCH_INTERNAL_LINEINFO, CATCH_INTERNAL_STRINGIFY(__VA_ARGS__), resultDisposition); \
        if( catchAssertionHandler.allowThrows() ) \
            try { \
                static_cast<void>(__VA_ARGS__); \
                catchAssertionHandler.handleUnexpectedExceptionNotThrown(); \
            } \
            catch( ... ) { \
                catchAssertionHandler.handleExceptionThrownAsExpected(); \
            } \
        else \
            catchAssertionHandler.handleThrowingCallSkipped(); \
        INTERNAL_CATCH_REACT( catchAssertionHandler ) \
    } while( false )

///////////////////////////////////////////////////////////////////////////////
#define INTERNAL_CATCH_THROWS_AS( macroName, exceptionType, resultDisposition, expr ) \
    do { \
        Catch::AssertionHandler catchAssertionHandler( macroName##_catch_sr, CATCH_INTERNAL_LINEINFO, CATCH_INTERNAL_STRINGIFY(expr) ", " CATCH_INTERNAL_STRINGIFY(exceptionType), resultDisposition ); \
        if( catchAssertionHandler.allowThrows() ) \
            try { \
                static_cast<void>(expr); \
                catchAssertionHandler.handleUnexpectedExceptionNotThrown(); \
            } \
            catch( exceptionType const& ) { \
                catchAssertionHandler.handleExceptionThrownAsExpected(); \
            } \
            catch( ... ) { \
                catchAssertionHandler.handleUnexpectedInflightException(); \
            } \
        else \
            catchAssertionHandler.handleThrowingCallSkipped(); \
        INTERNAL_CATCH_REACT( catchAssertionHandler ) \
    } while( false )

///////////////////////////////////////////////////////////////////////////////
#define INTERNAL_CATCH_MSG( macroName, messageType, resultDisposition, ... ) \
    do { \
        Catch::AssertionHandler catchAssertionHandler( macroName##_catch_sr, CATCH_INTERNAL_LINEINFO, Catch::StringRef(), resultDisposition ); \
        catchAssertionHandler.handleMessage( messageType, ( Catch::MessageStream() << __VA_ARGS__ + ::Catch::StreamEndStop() ).m_stream.str() ); \
        INTERNAL_CATCH_REACT( catchAssertionHandler ) \
    } while( false )

///////////////////////////////////////////////////////////////////////////////
#define INTERNAL_CATCH_CAPTURE( varName, macroName, ... ) \
    auto varName = Catch::Capturer( macroName, CATCH_INTERNAL_LINEINFO, Catch::ResultWas::Info, #__VA_ARGS__ ); \
    varName.captureValues( 0, __VA_ARGS__ )

///////////////////////////////////////////////////////////////////////////////
#define INTERNAL_CATCH_INFO( macroName, log ) \
    Catch::ScopedMessage INTERNAL_CATCH_UNIQUE_NAME( scopedMessage )( Catch::MessageBuilder( macroName##_catch_sr, CATCH_INTERNAL_LINEINFO, Catch::ResultWas::Info ) << log );

///////////////////////////////////////////////////////////////////////////////
#define INTERNAL_CATCH_UNSCOPED_INFO( macroName, log ) \
    Catch::getResultCapture().emplaceUnscopedMessage( Catch::MessageBuilder( macroName##_catch_sr, CATCH_INTERNAL_LINEINFO, Catch::ResultWas::Info ) << log )

///////////////////////////////////////////////////////////////////////////////
// Although this is matcher-based, it can be used with just a string
#define INTERNAL_CATCH_THROWS_STR_MATCHES( macroName, resultDisposition, matcher, ... ) \
    do { \
        Catch::AssertionHandler catchAssertionHandler( macroName##_catch_sr, CATCH_INTERNAL_LINEINFO, CATCH_INTERNAL_STRINGIFY(__VA_ARGS__) ", " CATCH_INTERNAL_STRINGIFY(matcher), resultDisposition ); \
        if( catchAssertionHandler.allowThrows() ) \
            try { \
                static_cast<void>(__VA_ARGS__); \
                catchAssertionHandler.handleUnexpectedExceptionNotThrown(); \
            } \
            catch( ... ) { \
                Catch::handleExceptionMatchExpr( catchAssertionHandler, matcher, #matcher##_catch_sr ); \
            } \
        else \
            catchAssertionHandler.handleThrowingCallSkipped(); \
        INTERNAL_CATCH_REACT( catchAssertionHandler ) \
    } while( false )

#endif // CATCH_CONFIG_DISABLE

// end catch_capture.hpp
// start catch_section.h

// start catch_section_info.h

// start catch_totals.h

#include <cstddef>

namespace Catch {

    struct Counts {
        Counts operator - ( Counts const& other ) const;
        Counts& operator += ( Counts const& other );

        std::size_t total() const;
        bool allPassed() const;
        bool allOk() const;

        std::size_t passed = 0;
        std::size_t failed = 0;
        std::size_t failedButOk = 0;
    };

    struct Totals {

        Totals operator - ( Totals const& other ) const;
        Totals& operator += ( Totals const& other );

        Totals delta( Totals const& prevTotals ) const;

        int error = 0;
        Counts assertions;
        Counts testCases;
    };
}

// end catch_totals.h
#include <string>

namespace Catch {

    struct SectionInfo {
        SectionInfo
            (   SourceLineInfo const& _lineInfo,
                std::string const& _name );

        // Deprecated
        SectionInfo
            (   SourceLineInfo const& _lineInfo,
                std::string const& _name,
                std::string const& ) : SectionInfo( _lineInfo, _name ) {}

        std::string name;
        std::string description; // !Deprecated: this will always be empty
        SourceLineInfo lineInfo;
    };

    struct SectionEndInfo {
        SectionInfo sectionInfo;
        Counts prevAssertions;
        double durationInSeconds;
    };

} // end namespace Catch

// end catch_section_info.h
// start catch_timer.h

#include <cstdint>

namespace Catch {

    auto getCurrentNanosecondsSinceEpoch() -> uint64_t;
    auto getEstimatedClockResolution() -> uint64_t;

    class Timer {
        uint64_t m_nanoseconds = 0;
    public:
        void start();
        auto getElapsedNanoseconds() const -> uint64_t;
        auto getElapsedMicroseconds() const -> uint64_t;
        auto getElapsedMilliseconds() const -> unsigned int;
        auto getElapsedSeconds() const -> double;
    };

} // namespace Catch

// end catch_timer.h
#include <string>

namespace Catch {

    class Section : NonCopyable {
    public:
        Section( SectionInfo const& info );
        ~Section();

        // This indicates whether the section should be executed or not
        explicit operator bool() const;

    private:
        SectionInfo m_info;

        std::string m_name;
        Counts m_assertions;
        bool m_sectionIncluded;
        Timer m_timer;
    };

} // end namespace Catch

#define INTERNAL_CATCH_SECTION( ... ) \
    CATCH_INTERNAL_START_WARNINGS_SUPPRESSION \
    CATCH_INTERNAL_SUPPRESS_UNUSED_WARNINGS \
    if( Catch::Section const& INTERNAL_CATCH_UNIQUE_NAME( catch_internal_Section ) = Catch::SectionInfo( CATCH_INTERNAL_LINEINFO, __VA_ARGS__ ) ) \
    CATCH_INTERNAL_STOP_WARNINGS_SUPPRESSION

#define INTERNAL_CATCH_DYNAMIC_SECTION( ... ) \
    CATCH_INTERNAL_START_WARNINGS_SUPPRESSION \
    CATCH_INTERNAL_SUPPRESS_UNUSED_WARNINGS \
    if( Catch::Section const& INTERNAL_CATCH_UNIQUE_NAME( catch_internal_Section ) = Catch::SectionInfo( CATCH_INTERNAL_LINEINFO, (Catch::ReusableStringStream() << __VA_ARGS__).str() ) ) \
    CATCH_INTERNAL_STOP_WARNINGS_SUPPRESSION

// end catch_section.h
// start catch_interfaces_exception.h

// start catch_interfaces_registry_hub.h

#include <string>
#include <memory>

namespace Catch {

    class TestCase;
    struct ITestCaseRegistry;
    struct IExceptionTranslatorRegistry;
    struct IExceptionTranslator;
    struct IReporterRegistry;
    struct IReporterFactory;
    struct ITagAliasRegistry;
    struct IMutableEnumValuesRegistry;

    class StartupExceptionRegistry;

    using IReporterFactoryPtr = std::shared_ptr<IReporterFactory>;

    struct IRegistryHub {
        virtual ~IRegistryHub();

        virtual IReporterRegistry const& getReporterRegistry() const = 0;
        virtual ITestCaseRegistry const& getTestCaseRegistry() const = 0;
        virtual ITagAliasRegistry const& getTagAliasRegistry() const = 0;
        virtual IExceptionTranslatorRegistry const& getExceptionTranslatorRegistry() const = 0;

        virtual StartupExceptionRegistry const& getStartupExceptionRegistry() const = 0;
    };

    struct IMutableRegistryHub {
        virtual ~IMutableRegistryHub();
        virtual void registerReporter( std::string const& name, IReporterFactoryPtr const& factory ) = 0;
        virtual void registerListener( IReporterFactoryPtr const& factory ) = 0;
        virtual void registerTest( TestCase const& testInfo ) = 0;
        virtual void registerTranslator( const IExceptionTranslator* translator ) = 0;
        virtual void registerTagAlias( std::string const& alias, std::string const& tag, SourceLineInfo const& lineInfo ) = 0;
        virtual void registerStartupException() noexcept = 0;
        virtual IMutableEnumValuesRegistry& getMutableEnumValuesRegistry() = 0;
    };

    IRegistryHub const& getRegistryHub();
    IMutableRegistryHub& getMutableRegistryHub();
    void cleanUp();
    std::string translateActiveException();

}

// end catch_interfaces_registry_hub.h
#if defined(CATCH_CONFIG_DISABLE)
    #define INTERNAL_CATCH_TRANSLATE_EXCEPTION_NO_REG( translatorName, signature) \
        static std::string translatorName( signature )
#endif

#include <exception>
#include <string>
#include <vector>

namespace Catch {
    using exceptionTranslateFunction = std::string(*)();

    struct IExceptionTranslator;
    using ExceptionTranslators = std::vector<std::unique_ptr<IExceptionTranslator const>>;

    struct IExceptionTranslator {
        virtual ~IExceptionTranslator();
        virtual std::string translate( ExceptionTranslators::const_iterator it, ExceptionTranslators::const_iterator itEnd ) const = 0;
    };

    struct IExceptionTranslatorRegistry {
        virtual ~IExceptionTranslatorRegistry();

        virtual std::string translateActiveException() const = 0;
    };

    class ExceptionTranslatorRegistrar {
        template<typename T>
        class ExceptionTranslator : public IExceptionTranslator {
        public:

            ExceptionTranslator( std::string(*translateFunction)( T& ) )
            : m_translateFunction( translateFunction )
            {}

            std::string translate( ExceptionTranslators::const_iterator it, ExceptionTranslators::const_iterator itEnd ) const override {
#if defined(CATCH_CONFIG_DISABLE_EXCEPTIONS)
                return "";
#else
                try {
                    if( it == itEnd )
                        std::rethrow_exception(std::current_exception());
                    else
                        return (*it)->translate( it+1, itEnd );
                }
                catch( T& ex ) {
                    return m_translateFunction( ex );
                }
#endif
            }

        protected:
            std::string(*m_translateFunction)( T& );
        };

    public:
        template<typename T>
        ExceptionTranslatorRegistrar( std::string(*translateFunction)( T& ) ) {
            getMutableRegistryHub().registerTranslator
                ( new ExceptionTranslator<T>( translateFunction ) );
        }
    };
}

///////////////////////////////////////////////////////////////////////////////
#define INTERNAL_CATCH_TRANSLATE_EXCEPTION2( translatorName, signature ) \
    static std::string translatorName( signature ); \
    CATCH_INTERNAL_START_WARNINGS_SUPPRESSION \
    CATCH_INTERNAL_SUPPRESS_GLOBALS_WARNINGS \
    namespace{ Catch::ExceptionTranslatorRegistrar INTERNAL_CATCH_UNIQUE_NAME( catch_internal_ExceptionRegistrar )( &translatorName ); } \
    CATCH_INTERNAL_STOP_WARNINGS_SUPPRESSION \
    static std::string translatorName( signature )

#define INTERNAL_CATCH_TRANSLATE_EXCEPTION( signature ) INTERNAL_CATCH_TRANSLATE_EXCEPTION2( INTERNAL_CATCH_UNIQUE_NAME( catch_internal_ExceptionTranslator ), signature )

// end catch_interfaces_exception.h
// start catch_approx.h

#include <type_traits>

namespace Catch {
namespace Detail {

    class Approx {
    private:
        bool equalityComparisonImpl(double other) const;
        // Validates the new margin (margin >= 0)
        // out-of-line to avoid including stdexcept in the header
        void setMargin(double margin);
        // Validates the new epsilon (0 < epsilon < 1)
        // out-of-line to avoid including stdexcept in the header
        void setEpsilon(double epsilon);

    public:
        explicit Approx ( double value );

        static Approx custom();

        Approx operator-() const;

        template <typename T, typename = typename std::enable_if<std::is_constructible<double, T>::value>::type>
        Approx operator()( T const& value ) {
            Approx approx( static_cast<double>(value) );
            approx.m_epsilon = m_epsilon;
            approx.m_margin = m_margin;
            approx.m_scale = m_scale;
            return approx;
        }

        template <typename T, typename = typename std::enable_if<std::is_constructible<double, T>::value>::type>
        explicit Approx( T const& value ): Approx(static_cast<double>(value))
        {}

        template <typename T, typename = typename std::enable_if<std::is_constructible<double, T>::value>::type>
        friend bool operator == ( const T& lhs, Approx const& rhs ) {
            auto lhs_v = static_cast<double>(lhs);
            return rhs.equalityComparisonImpl(lhs_v);
        }

        template <typename T, typename = typename std::enable_if<std::is_constructible<double, T>::value>::type>
        friend bool operator == ( Approx const& lhs, const T& rhs ) {
            return operator==( rhs, lhs );
        }

        template <typename T, typename = typename std::enable_if<std::is_constructible<double, T>::value>::type>
        friend bool operator != ( T const& lhs, Approx const& rhs ) {
            return !operator==( lhs, rhs );
        }

        template <typename T, typename = typename std::enable_if<std::is_constructible<double, T>::value>::type>
        friend bool operator != ( Approx const& lhs, T const& rhs ) {
            return !operator==( rhs, lhs );
        }

        template <typename T, typename = typename std::enable_if<std::is_constructible<double, T>::value>::type>
        friend bool operator <= ( T const& lhs, Approx const& rhs ) {
            return static_cast<double>(lhs) < rhs.m_value || lhs == rhs;
        }

        template <typename T, typename = typename std::enable_if<std::is_constructible<double, T>::value>::type>
        friend bool operator <= ( Approx const& lhs, T const& rhs ) {
            return lhs.m_value < static_cast<double>(rhs) || lhs == rhs;
        }

        template <typename T, typename = typename std::enable_if<std::is_constructible<double, T>::value>::type>
        friend bool operator >= ( T const& lhs, Approx const& rhs ) {
            return static_cast<double>(lhs) > rhs.m_value || lhs == rhs;
        }

        template <typename T, typename = typename std::enable_if<std::is_constructible<double, T>::value>::type>
        friend bool operator >= ( Approx const& lhs, T const& rhs ) {
            return lhs.m_value > static_cast<double>(rhs) || lhs == rhs;
        }

        template <typename T, typename = typename std::enable_if<std::is_constructible<double, T>::value>::type>
        Approx& epsilon( T const& newEpsilon ) {
            double epsilonAsDouble = static_cast<double>(newEpsilon);
            setEpsilon(epsilonAsDouble);
            return *this;
        }

        template <typename T, typename = typename std::enable_if<std::is_constructible<double, T>::value>::type>
        Approx& margin( T const& newMargin ) {
            double marginAsDouble = static_cast<double>(newMargin);
            setMargin(marginAsDouble);
            return *this;
        }

        template <typename T, typename = typename std::enable_if<std::is_constructible<double, T>::value>::type>
        Approx& scale( T const& newScale ) {
            m_scale = static_cast<double>(newScale);
            return *this;
        }

        std::string toString() const;

    private:
        double m_epsilon;
        double m_margin;
        double m_scale;
        double m_value;
    };
} // end namespace Detail

namespace literals {
    Detail::Approx operator "" _a(long double val);
    Detail::Approx operator "" _a(unsigned long long val);
} // end namespace literals

template<>
struct StringMaker<Catch::Detail::Approx> {
    static std::string convert(Catch::Detail::Approx const& value);
};

} // end namespace Catch

// end catch_approx.h
// start catch_string_manip.h

#include <string>
#include <iosfwd>
#include <vector>

namespace Catch {

    bool startsWith( std::string const& s, std::string const& prefix );
    bool startsWith( std::string const& s, char prefix );
    bool endsWith( std::string const& s, std::string const& suffix );
    bool endsWith( std::string const& s, char suffix );
    bool contains( std::string const& s, std::string const& infix );
    void toLowerInPlace( std::string& s );
    std::string toLower( std::string const& s );
    //! Returns a new string without whitespace at the start/end
    std::string trim( std::string const& str );
    //! Returns a substring of the original ref without whitespace. Beware lifetimes!
    StringRef trim(StringRef ref);

    // !!! Be aware, returns refs into original string - make sure original string outlives them
    std::vector<StringRef> splitStringRef( StringRef str, char delimiter );
    bool replaceInPlace( std::string& str, std::string const& replaceThis, std::string const& withThis );

    struct pluralise {
        pluralise( std::size_t count, std::string const& label );

        friend std::ostream& operator << ( std::ostream& os, pluralise const& pluraliser );

        std::size_t m_count;
        std::string m_label;
    };
}

// end catch_string_manip.h
#ifndef CATCH_CONFIG_DISABLE_MATCHERS
// start catch_capture_matchers.h

// start catch_matchers.h

#include <string>
#include <vector>

namespace Catch {
namespace Matchers {
    namespace Impl {

        template<typename ArgT> struct MatchAllOf;
        template<typename ArgT> struct MatchAnyOf;
        template<typename ArgT> struct MatchNotOf;

        class MatcherUntypedBase {
        public:
            MatcherUntypedBase() = default;
            MatcherUntypedBase ( MatcherUntypedBase const& ) = default;
            MatcherUntypedBase& operator = ( MatcherUntypedBase const& ) = delete;
            std::string toString() const;

        protected:
            virtual ~MatcherUntypedBase();
            virtual std::string describe() const = 0;
            mutable std::string m_cachedToString;
        };

#ifdef __clang__
#    pragma clang diagnostic push
#    pragma clang diagnostic ignored "-Wnon-virtual-dtor"
#endif

        template<typename ObjectT>
        struct MatcherMethod {
            virtual bool match( ObjectT const& arg ) const = 0;
        };

#if defined(__OBJC__)
        // Hack to fix Catch GH issue #1661. Could use id for generic Object support.
        // use of const for Object pointers is very uncommon and under ARC it causes some kind of signature mismatch that breaks compilation
        template<>
        struct MatcherMethod<NSString*> {
            virtual bool match( NSString* arg ) const = 0;
        };
#endif

#ifdef __clang__
#    pragma clang diagnostic pop
#endif

        template<typename T>
        struct MatcherBase : MatcherUntypedBase, MatcherMethod<T> {

            MatchAllOf<T> operator && ( MatcherBase const& other ) const;
            MatchAnyOf<T> operator || ( MatcherBase const& other ) const;
            MatchNotOf<T> operator ! () const;
        };

        template<typename ArgT>
        struct MatchAllOf : MatcherBase<ArgT> {
            bool match( ArgT const& arg ) const override {
                for( auto matcher : m_matchers ) {
                    if (!matcher->match(arg))
                        return false;
                }
                return true;
            }
            std::string describe() const override {
                std::string description;
                description.reserve( 4 + m_matchers.size()*32 );
                description += "( ";
                bool first = true;
                for( auto matcher : m_matchers ) {
                    if( first )
                        first = false;
                    else
                        description += " and ";
                    description += matcher->toString();
                }
                description += " )";
                return description;
            }

            MatchAllOf<ArgT> operator && ( MatcherBase<ArgT> const& other ) {
                auto copy(*this);
                copy.m_matchers.push_back( &other );
                return copy;
            }

            std::vector<MatcherBase<ArgT> const*> m_matchers;
        };
        template<typename ArgT>
        struct MatchAnyOf : MatcherBase<ArgT> {

            bool match( ArgT const& arg ) const override {
                for( auto matcher : m_matchers ) {
                    if (matcher->match(arg))
                        return true;
                }
                return false;
            }
            std::string describe() const override {
                std::string description;
                description.reserve( 4 + m_matchers.size()*32 );
                description += "( ";
                bool first = true;
                for( auto matcher : m_matchers ) {
                    if( first )
                        first = false;
                    else
                        description += " or ";
                    description += matcher->toString();
                }
                description += " )";
                return description;
            }

            MatchAnyOf<ArgT> operator || ( MatcherBase<ArgT> const& other ) {
                auto copy(*this);
                copy.m_matchers.push_back( &other );
                return copy;
            }

            std::vector<MatcherBase<ArgT> const*> m_matchers;
        };

        template<typename ArgT>
        struct MatchNotOf : MatcherBase<ArgT> {

            MatchNotOf( MatcherBase<ArgT> const& underlyingMatcher ) : m_underlyingMatcher( underlyingMatcher ) {}

            bool match( ArgT const& arg ) const override {
                return !m_underlyingMatcher.match( arg );
            }

            std::string describe() const override {
                return "not " + m_underlyingMatcher.toString();
            }
            MatcherBase<ArgT> const& m_underlyingMatcher;
        };

        template<typename T>
        MatchAllOf<T> MatcherBase<T>::operator && ( MatcherBase const& other ) const {
            return MatchAllOf<T>() && *this && other;
        }
        template<typename T>
        MatchAnyOf<T> MatcherBase<T>::operator || ( MatcherBase const& other ) const {
            return MatchAnyOf<T>() || *this || other;
        }
        template<typename T>
        MatchNotOf<T> MatcherBase<T>::operator ! () const {
            return MatchNotOf<T>( *this );
        }

    } // namespace Impl

} // namespace Matchers

using namespace Matchers;
using Matchers::Impl::MatcherBase;

} // namespace Catch

// end catch_matchers.h
// start catch_matchers_exception.hpp

namespace Catch {
namespace Matchers {
namespace Exception {

class ExceptionMessageMatcher : public MatcherBase<std::exception> {
    std::string m_message;
public:

    ExceptionMessageMatcher(std::string const& message):
        m_message(message)
    {}

    bool match(std::exception const& ex) const override;

    std::string describe() const override;
};

} // namespace Exception

Exception::ExceptionMessageMatcher Message(std::string const& message);

} // namespace Matchers
} // namespace Catch

// end catch_matchers_exception.hpp
// start catch_matchers_floating.h

namespace Catch {
namespace Matchers {

    namespace Floating {

        enum class FloatingPointKind : uint8_t;

        struct WithinAbsMatcher : MatcherBase<double> {
            WithinAbsMatcher(double target, double margin);
            bool match(double const& matchee) const override;
            std::string describe() const override;
        private:
            double m_target;
            double m_margin;
        };

        struct WithinUlpsMatcher : MatcherBase<double> {
            WithinUlpsMatcher(double target, uint64_t ulps, FloatingPointKind baseType);
            bool match(double const& matchee) const override;
            std::string describe() const override;
        private:
            double m_target;
            uint64_t m_ulps;
            FloatingPointKind m_type;
        };

        // Given IEEE-754 format for floats and doubles, we can assume
        // that float -> double promotion is lossless. Given this, we can
        // assume that if we do the standard relative comparison of
        // |lhs - rhs| <= epsilon * max(fabs(lhs), fabs(rhs)), then we get
        // the same result if we do this for floats, as if we do this for
        // doubles that were promoted from floats.
        struct WithinRelMatcher : MatcherBase<double> {
            WithinRelMatcher(double target, double epsilon);
            bool match(double const& matchee) const override;
            std::string describe() const override;
        private:
            double m_target;
            double m_epsilon;
        };

    } // namespace Floating

    // The following functions create the actual matcher objects.
    // This allows the types to be inferred
    Floating::WithinUlpsMatcher WithinULP(double target, uint64_t maxUlpDiff);
    Floating::WithinUlpsMatcher WithinULP(float target, uint64_t maxUlpDiff);
    Floating::WithinAbsMatcher WithinAbs(double target, double margin);
    Floating::WithinRelMatcher WithinRel(double target, double eps);
    // defaults epsilon to 100*numeric_limits<double>::epsilon()
    Floating::WithinRelMatcher WithinRel(double target);
    Floating::WithinRelMatcher WithinRel(float target, float eps);
    // defaults epsilon to 100*numeric_limits<float>::epsilon()
    Floating::WithinRelMatcher WithinRel(float target);

} // namespace Matchers
} // namespace Catch

// end catch_matchers_floating.h
// start catch_matchers_generic.hpp

#include <functional>
#include <string>

namespace Catch {
namespace Matchers {
namespace Generic {

namespace Detail {
    std::string finalizeDescription(const std::string& desc);
}

template <typename T>
class PredicateMatcher : public MatcherBase<T> {
    std::function<bool(T const&)> m_predicate;
    std::string m_description;
public:

    PredicateMatcher(std::function<bool(T const&)> const& elem, std::string const& descr)
        :m_predicate(std::move(elem)),
        m_description(Detail::finalizeDescription(descr))
    {}

    bool match( T const& item ) const override {
        return m_predicate(item);
    }

    std::string describe() const override {
        return m_description;
    }
};

} // namespace Generic

    // The following functions create the actual matcher objects.
    // The user has to explicitly specify type to the function, because
    // inferring std::function<bool(T const&)> is hard (but possible) and
    // requires a lot of TMP.
    template<typename T>
    Generic::PredicateMatcher<T> Predicate(std::function<bool(T const&)> const& predicate, std::string const& description = "") {
        return Generic::PredicateMatcher<T>(predicate, description);
    }

} // namespace Matchers
} // namespace Catch

// end catch_matchers_generic.hpp
// start catch_matchers_string.h

#include <string>

namespace Catch {
namespace Matchers {

    namespace StdString {

        struct CasedString
        {
            CasedString( std::string const& str, CaseSensitive::Choice caseSensitivity );
            std::string adjustString( std::string const& str ) const;
            std::string caseSensitivitySuffix() const;

            CaseSensitive::Choice m_caseSensitivity;
            std::string m_str;
        };

        struct StringMatcherBase : MatcherBase<std::string> {
            StringMatcherBase( std::string const& operation, CasedString const& comparator );
            std::string describe() const override;

            CasedString m_comparator;
            std::string m_operation;
        };

        struct EqualsMatcher : StringMatcherBase {
            EqualsMatcher( CasedString const& comparator );
            bool match( std::string const& source ) const override;
        };
        struct ContainsMatcher : StringMatcherBase {
            ContainsMatcher( CasedString const& comparator );
            bool match( std::string const& source ) const override;
        };
        struct StartsWithMatcher : StringMatcherBase {
            StartsWithMatcher( CasedString const& comparator );
            bool match( std::string const& source ) const override;
        };
        struct EndsWithMatcher : StringMatcherBase {
            EndsWithMatcher( CasedString const& comparator );
            bool match( std::string const& source ) const override;
        };

        struct RegexMatcher : MatcherBase<std::string> {
            RegexMatcher( std::string regex, CaseSensitive::Choice caseSensitivity );
            bool match( std::string const& matchee ) const override;
            std::string describe() const override;

        private:
            std::string m_regex;
            CaseSensitive::Choice m_caseSensitivity;
        };

    } // namespace StdString

    // The following functions create the actual matcher objects.
    // This allows the types to be inferred

    StdString::EqualsMatcher Equals( std::string const& str, CaseSensitive::Choice caseSensitivity = CaseSensitive::Yes );
    StdString::ContainsMatcher Contains( std::string const& str, CaseSensitive::Choice caseSensitivity = CaseSensitive::Yes );
    StdString::EndsWithMatcher EndsWith( std::string const& str, CaseSensitive::Choice caseSensitivity = CaseSensitive::Yes );
    StdString::StartsWithMatcher StartsWith( std::string const& str, CaseSensitive::Choice caseSensitivity = CaseSensitive::Yes );
    StdString::RegexMatcher Matches( std::string const& regex, CaseSensitive::Choice caseSensitivity = CaseSensitive::Yes );

} // namespace Matchers
} // namespace Catch

// end catch_matchers_string.h
// start catch_matchers_vector.h

#include <algorithm>

namespace Catch {
namespace Matchers {

    namespace Vector {
        template<typename T, typename Alloc>
        struct ContainsElementMatcher : MatcherBase<std::vector<T, Alloc>> {

            ContainsElementMatcher(T const &comparator) : m_comparator( comparator) {}

            bool match(std::vector<T, Alloc> const &v) const override {
                for (auto const& el : v) {
                    if (el == m_comparator) {
                        return true;
                    }
                }
                return false;
            }

            std::string describe() const override {
                return "Contains: " + ::Catch::Detail::stringify( m_comparator );
            }

            T const& m_comparator;
        };

        template<typename T, typename AllocComp, typename AllocMatch>
        struct ContainsMatcher : MatcherBase<std::vector<T, AllocMatch>> {

            ContainsMatcher(std::vector<T, AllocComp> const &comparator) : m_comparator( comparator ) {}

            bool match(std::vector<T, AllocMatch> const &v) const override {
                // !TBD: see note in EqualsMatcher
                if (m_comparator.size() > v.size())
                    return false;
                for (auto const& comparator : m_comparator) {
                    auto present = false;
                    for (const auto& el : v) {
                        if (el == comparator) {
                            present = true;
                            break;
                        }
                    }
                    if (!present) {
                        return false;
                    }
                }
                return true;
            }
            std::string describe() const override {
                return "Contains: " + ::Catch::Detail::stringify( m_comparator );
            }

            std::vector<T, AllocComp> const& m_comparator;
        };

        template<typename T, typename AllocComp, typename AllocMatch>
        struct EqualsMatcher : MatcherBase<std::vector<T, AllocMatch>> {

            EqualsMatcher(std::vector<T, AllocComp> const &comparator) : m_comparator( comparator ) {}

            bool match(std::vector<T, AllocMatch> const &v) const override {
                // !TBD: This currently works if all elements can be compared using !=
                // - a more general approach would be via a compare template that defaults
                // to using !=. but could be specialised for, e.g. std::vector<T, Alloc> etc
                // - then just call that directly
                if (m_comparator.size() != v.size())
                    return false;
                for (std::size_t i = 0; i < v.size(); ++i)
                    if (m_comparator[i] != v[i])
                        return false;
                return true;
            }
            std::string describe() const override {
                return "Equals: " + ::Catch::Detail::stringify( m_comparator );
            }
            std::vector<T, AllocComp> const& m_comparator;
        };

        template<typename T, typename AllocComp, typename AllocMatch>
        struct ApproxMatcher : MatcherBase<std::vector<T, AllocMatch>> {

            ApproxMatcher(std::vector<T, AllocComp> const& comparator) : m_comparator( comparator ) {}

            bool match(std::vector<T, AllocMatch> const &v) const override {
                if (m_comparator.size() != v.size())
                    return false;
                for (std::size_t i = 0; i < v.size(); ++i)
                    if (m_comparator[i] != approx(v[i]))
                        return false;
                return true;
            }
            std::string describe() const override {
                return "is approx: " + ::Catch::Detail::stringify( m_comparator );
            }
            template <typename = typename std::enable_if<std::is_constructible<double, T>::value>::type>
            ApproxMatcher& epsilon( T const& newEpsilon ) {
                approx.epsilon(newEpsilon);
                return *this;
            }
            template <typename = typename std::enable_if<std::is_constructible<double, T>::value>::type>
            ApproxMatcher& margin( T const& newMargin ) {
                approx.margin(newMargin);
                return *this;
            }
            template <typename = typename std::enable_if<std::is_constructible<double, T>::value>::type>
            ApproxMatcher& scale( T const& newScale ) {
                approx.scale(newScale);
                return *this;
            }

            std::vector<T, AllocComp> const& m_comparator;
            mutable Catch::Detail::Approx approx = Catch::Detail::Approx::custom();
        };

        template<typename T, typename AllocComp, typename AllocMatch>
        struct UnorderedEqualsMatcher : MatcherBase<std::vector<T, AllocMatch>> {
            UnorderedEqualsMatcher(std::vector<T, AllocComp> const& target) : m_target(target) {}
            bool match(std::vector<T, AllocMatch> const& vec) const override {
                if (m_target.size() != vec.size()) {
                    return false;
                }
                return std::is_permutation(m_target.begin(), m_target.end(), vec.begin());
            }

            std::string describe() const override {
                return "UnorderedEquals: " + ::Catch::Detail::stringify(m_target);
            }
        private:
            std::vector<T, AllocComp> const& m_target;
        };

    } // namespace Vector

    // The following functions create the actual matcher objects.
    // This allows the types to be inferred

    template<typename T, typename AllocComp = std::allocator<T>, typename AllocMatch = AllocComp>
    Vector::ContainsMatcher<T, AllocComp, AllocMatch> Contains( std::vector<T, AllocComp> const& comparator ) {
        return Vector::ContainsMatcher<T, AllocComp, AllocMatch>( comparator );
    }

    template<typename T, typename Alloc = std::allocator<T>>
    Vector::ContainsElementMatcher<T, Alloc> VectorContains( T const& comparator ) {
        return Vector::ContainsElementMatcher<T, Alloc>( comparator );
    }

    template<typename T, typename AllocComp = std::allocator<T>, typename AllocMatch = AllocComp>
    Vector::EqualsMatcher<T, AllocComp, AllocMatch> Equals( std::vector<T, AllocComp> const& comparator ) {
        return Vector::EqualsMatcher<T, AllocComp, AllocMatch>( comparator );
    }

    template<typename T, typename AllocComp = std::allocator<T>, typename AllocMatch = AllocComp>
    Vector::ApproxMatcher<T, AllocComp, AllocMatch> Approx( std::vector<T, AllocComp> const& comparator ) {
        return Vector::ApproxMatcher<T, AllocComp, AllocMatch>( comparator );
    }

    template<typename T, typename AllocComp = std::allocator<T>, typename AllocMatch = AllocComp>
    Vector::UnorderedEqualsMatcher<T, AllocComp, AllocMatch> UnorderedEquals(std::vector<T, AllocComp> const& target) {
        return Vector::UnorderedEqualsMatcher<T, AllocComp, AllocMatch>( target );
    }

} // namespace Matchers
} // namespace Catch

// end catch_matchers_vector.h
namespace Catch {

    template<typename ArgT, typename MatcherT>
    class MatchExpr : public ITransientExpression {
        ArgT const& m_arg;
        MatcherT m_matcher;
        StringRef m_matcherString;
    public:
        MatchExpr( ArgT const& arg, MatcherT const& matcher, StringRef const& matcherString )
        :   ITransientExpression{ true, matcher.match( arg ) },
            m_arg( arg ),
            m_matcher( matcher ),
            m_matcherString( matcherString )
        {}

        void streamReconstructedExpression( std::ostream &os ) const override {
            auto matcherAsString = m_matcher.toString();
            os << Catch::Detail::stringify( m_arg ) << ' ';
            if( matcherAsString == Detail::unprintableString )
                os << m_matcherString;
            else
                os << matcherAsString;
        }
    };

    using StringMatcher = Matchers::Impl::MatcherBase<std::string>;

    void handleExceptionMatchExpr( AssertionHandler& handler, StringMatcher const& matcher, StringRef const& matcherString  );

    template<typename ArgT, typename MatcherT>
    auto makeMatchExpr( ArgT const& arg, MatcherT const& matcher, StringRef const& matcherString  ) -> MatchExpr<ArgT, MatcherT> {
        return MatchExpr<ArgT, MatcherT>( arg, matcher, matcherString );
    }

} // namespace Catch

///////////////////////////////////////////////////////////////////////////////
#define INTERNAL_CHECK_THAT( macroName, matcher, resultDisposition, arg ) \
    do { \
        Catch::AssertionHandler catchAssertionHandler( macroName##_catch_sr, CATCH_INTERNAL_LINEINFO, CATCH_INTERNAL_STRINGIFY(arg) ", " CATCH_INTERNAL_STRINGIFY(matcher), resultDisposition ); \
        INTERNAL_CATCH_TRY { \
            catchAssertionHandler.handleExpr( Catch::makeMatchExpr( arg, matcher, #matcher##_catch_sr ) ); \
        } INTERNAL_CATCH_CATCH( catchAssertionHandler ) \
        INTERNAL_CATCH_REACT( catchAssertionHandler ) \
    } while( false )

///////////////////////////////////////////////////////////////////////////////
#define INTERNAL_CATCH_THROWS_MATCHES( macroName, exceptionType, resultDisposition, matcher, ... ) \
    do { \
        Catch::AssertionHandler catchAssertionHandler( macroName##_catch_sr, CATCH_INTERNAL_LINEINFO, CATCH_INTERNAL_STRINGIFY(__VA_ARGS__) ", " CATCH_INTERNAL_STRINGIFY(exceptionType) ", " CATCH_INTERNAL_STRINGIFY(matcher), resultDisposition ); \
        if( catchAssertionHandler.allowThrows() ) \
            try { \
                static_cast<void>(__VA_ARGS__ ); \
                catchAssertionHandler.handleUnexpectedExceptionNotThrown(); \
            } \
            catch( exceptionType const& ex ) { \
                catchAssertionHandler.handleExpr( Catch::makeMatchExpr( ex, matcher, #matcher##_catch_sr ) ); \
            } \
            catch( ... ) { \
                catchAssertionHandler.handleUnexpectedInflightException(); \
            } \
        else \
            catchAssertionHandler.handleThrowingCallSkipped(); \
        INTERNAL_CATCH_REACT( catchAssertionHandler ) \
    } while( false )

// end catch_capture_matchers.h
#endif
// start catch_generators.hpp

// start catch_interfaces_generatortracker.h


#include <memory>

namespace Catch {

    namespace Generators {
        class GeneratorUntypedBase {
        public:
            GeneratorUntypedBase() = default;
            virtual ~GeneratorUntypedBase();
            // Attempts to move the generator to the next element
             //
             // Returns true iff the move succeeded (and a valid element
             // can be retrieved).
            virtual bool next() = 0;
        };
        using GeneratorBasePtr = std::unique_ptr<GeneratorUntypedBase>;

    } // namespace Generators

    struct IGeneratorTracker {
        virtual ~IGeneratorTracker();
        virtual auto hasGenerator() const -> bool = 0;
        virtual auto getGenerator() const -> Generators::GeneratorBasePtr const& = 0;
        virtual void setGenerator( Generators::GeneratorBasePtr&& generator ) = 0;
    };

} // namespace Catch

// end catch_interfaces_generatortracker.h
// start catch_enforce.h

#include <exception>

namespace Catch {
#if !defined(CATCH_CONFIG_DISABLE_EXCEPTIONS)
    template <typename Ex>
    [[noreturn]]
    void throw_exception(Ex const& e) {
        throw e;
    }
#else // ^^ Exceptions are enabled //  Exceptions are disabled vv
    [[noreturn]]
    void throw_exception(std::exception const& e);
#endif

    [[noreturn]]
    void throw_logic_error(std::string const& msg);
    [[noreturn]]
    void throw_domain_error(std::string const& msg);
    [[noreturn]]
    void throw_runtime_error(std::string const& msg);

} // namespace Catch;

#define CATCH_MAKE_MSG(...) \
    (Catch::ReusableStringStream() << __VA_ARGS__).str()

#define CATCH_INTERNAL_ERROR(...) \
    Catch::throw_logic_error(CATCH_MAKE_MSG( CATCH_INTERNAL_LINEINFO << ": Internal Catch2 error: " << __VA_ARGS__))

#define CATCH_ERROR(...) \
    Catch::throw_domain_error(CATCH_MAKE_MSG( __VA_ARGS__ ))

#define CATCH_RUNTIME_ERROR(...) \
    Catch::throw_runtime_error(CATCH_MAKE_MSG( __VA_ARGS__ ))

#define CATCH_ENFORCE( condition, ... ) \
    do{ if( !(condition) ) CATCH_ERROR( __VA_ARGS__ ); } while(false)

// end catch_enforce.h
#include <memory>
#include <vector>
#include <cassert>

#include <utility>
#include <exception>

namespace Catch {

class GeneratorException : public std::exception {
    const char* const m_msg = "";

public:
    GeneratorException(const char* msg):
        m_msg(msg)
    {}

    const char* what() const noexcept override final;
};

namespace Generators {

    // !TBD move this into its own location?
    namespace pf{
        template<typename T, typename... Args>
        std::unique_ptr<T> make_unique( Args&&... args ) {
            return std::unique_ptr<T>(new T(std::forward<Args>(args)...));
        }
    }

    template<typename T>
    struct IGenerator : GeneratorUntypedBase {
        virtual ~IGenerator() = default;

        // Returns the current element of the generator
        //
        // \Precondition The generator is either freshly constructed,
        // or the last call to `next()` returned true
        virtual T const& get() const = 0;
        using type = T;
    };

    template<typename T>
    class SingleValueGenerator final : public IGenerator<T> {
        T m_value;
    public:
        SingleValueGenerator(T&& value) : m_value(std::move(value)) {}

        T const& get() const override {
            return m_value;
        }
        bool next() override {
            return false;
        }
    };

    template<typename T>
    class FixedValuesGenerator final : public IGenerator<T> {
        static_assert(!std::is_same<T, bool>::value,
            "FixedValuesGenerator does not support bools because of std::vector<bool>"
            "specialization, use SingleValue Generator instead.");
        std::vector<T> m_values;
        size_t m_idx = 0;
    public:
        FixedValuesGenerator( std::initializer_list<T> values ) : m_values( values ) {}

        T const& get() const override {
            return m_values[m_idx];
        }
        bool next() override {
            ++m_idx;
            return m_idx < m_values.size();
        }
    };

    template <typename T>
    class GeneratorWrapper final {
        std::unique_ptr<IGenerator<T>> m_generator;
    public:
        GeneratorWrapper(std::unique_ptr<IGenerator<T>> generator):
            m_generator(std::move(generator))
        {}
        T const& get() const {
            return m_generator->get();
        }
        bool next() {
            return m_generator->next();
        }
    };

    template <typename T>
    GeneratorWrapper<T> value(T&& value) {
        return GeneratorWrapper<T>(pf::make_unique<SingleValueGenerator<T>>(std::forward<T>(value)));
    }
    template <typename T>
    GeneratorWrapper<T> values(std::initializer_list<T> values) {
        return GeneratorWrapper<T>(pf::make_unique<FixedValuesGenerator<T>>(values));
    }

    template<typename T>
    class Generators : public IGenerator<T> {
        std::vector<GeneratorWrapper<T>> m_generators;
        size_t m_current = 0;

        void populate(GeneratorWrapper<T>&& generator) {
            m_generators.emplace_back(std::move(generator));
        }
        void populate(T&& val) {
            m_generators.emplace_back(value(std::forward<T>(val)));
        }
        template<typename U>
        void populate(U&& val) {
            populate(T(std::forward<U>(val)));
        }
        template<typename U, typename... Gs>
        void populate(U&& valueOrGenerator, Gs &&... moreGenerators) {
            populate(std::forward<U>(valueOrGenerator));
            populate(std::forward<Gs>(moreGenerators)...);
        }

    public:
        template <typename... Gs>
        Generators(Gs &&... moreGenerators) {
            m_generators.reserve(sizeof...(Gs));
            populate(std::forward<Gs>(moreGenerators)...);
        }

        T const& get() const override {
            return m_generators[m_current].get();
        }

        bool next() override {
            if (m_current >= m_generators.size()) {
                return false;
            }
            const bool current_status = m_generators[m_current].next();
            if (!current_status) {
                ++m_current;
            }
            return m_current < m_generators.size();
        }
    };

    template<typename... Ts>
    GeneratorWrapper<std::tuple<Ts...>> table( std::initializer_list<std::tuple<typename std::decay<Ts>::type...>> tuples ) {
        return values<std::tuple<Ts...>>( tuples );
    }

    // Tag type to signal that a generator sequence should convert arguments to a specific type
    template <typename T>
    struct as {};

    template<typename T, typename... Gs>
    auto makeGenerators( GeneratorWrapper<T>&& generator, Gs &&... moreGenerators ) -> Generators<T> {
        return Generators<T>(std::move(generator), std::forward<Gs>(moreGenerators)...);
    }
    template<typename T>
    auto makeGenerators( GeneratorWrapper<T>&& generator ) -> Generators<T> {
        return Generators<T>(std::move(generator));
    }
    template<typename T, typename... Gs>
    auto makeGenerators( T&& val, Gs &&... moreGenerators ) -> Generators<T> {
        return makeGenerators( value( std::forward<T>( val ) ), std::forward<Gs>( moreGenerators )... );
    }
    template<typename T, typename U, typename... Gs>
    auto makeGenerators( as<T>, U&& val, Gs &&... moreGenerators ) -> Generators<T> {
        return makeGenerators( value( T( std::forward<U>( val ) ) ), std::forward<Gs>( moreGenerators )... );
    }

    auto acquireGeneratorTracker( StringRef generatorName, SourceLineInfo const& lineInfo ) -> IGeneratorTracker&;

    template<typename L>
    // Note: The type after -> is weird, because VS2015 cannot parse
    //       the expression used in the typedef inside, when it is in
    //       return type. Yeah.
    auto generate( StringRef generatorName, SourceLineInfo const& lineInfo, L const& generatorExpression ) -> decltype(std::declval<decltype(generatorExpression())>().get()) {
        using UnderlyingType = typename decltype(generatorExpression())::type;

        IGeneratorTracker& tracker = acquireGeneratorTracker( generatorName, lineInfo );
        if (!tracker.hasGenerator()) {
            tracker.setGenerator(pf::make_unique<Generators<UnderlyingType>>(generatorExpression()));
        }

        auto const& generator = static_cast<IGenerator<UnderlyingType> const&>( *tracker.getGenerator() );
        return generator.get();
    }

} // namespace Generators
} // namespace Catch

#define GENERATE( ... ) \
    Catch::Generators::generate( INTERNAL_CATCH_STRINGIZE(INTERNAL_CATCH_UNIQUE_NAME(generator)), \
                                 CATCH_INTERNAL_LINEINFO, \
                                 [ ]{ using namespace Catch::Generators; return makeGenerators( __VA_ARGS__ ); } ) //NOLINT(google-build-using-namespace)
#define GENERATE_COPY( ... ) \
    Catch::Generators::generate( INTERNAL_CATCH_STRINGIZE(INTERNAL_CATCH_UNIQUE_NAME(generator)), \
                                 CATCH_INTERNAL_LINEINFO, \
                                 [=]{ using namespace Catch::Generators; return makeGenerators( __VA_ARGS__ ); } ) //NOLINT(google-build-using-namespace)
#define GENERATE_REF( ... ) \
    Catch::Generators::generate( INTERNAL_CATCH_STRINGIZE(INTERNAL_CATCH_UNIQUE_NAME(generator)), \
                                 CATCH_INTERNAL_LINEINFO, \
                                 [&]{ using namespace Catch::Generators; return makeGenerators( __VA_ARGS__ ); } ) //NOLINT(google-build-using-namespace)

// end catch_generators.hpp
// start catch_generators_generic.hpp

namespace Catch {
namespace Generators {

    template <typename T>
    class TakeGenerator : public IGenerator<T> {
        GeneratorWrapper<T> m_generator;
        size_t m_returned = 0;
        size_t m_target;
    public:
        TakeGenerator(size_t target, GeneratorWrapper<T>&& generator):
            m_generator(std::move(generator)),
            m_target(target)
        {
            assert(target != 0 && "Empty generators are not allowed");
        }
        T const& get() const override {
            return m_generator.get();
        }
        bool next() override {
            ++m_returned;
            if (m_returned >= m_target) {
                return false;
            }

            const auto success = m_generator.next();
            // If the underlying generator does not contain enough values
            // then we cut short as well
            if (!success) {
                m_returned = m_target;
            }
            return success;
        }
    };

    template <typename T>
    GeneratorWrapper<T> take(size_t target, GeneratorWrapper<T>&& generator) {
        return GeneratorWrapper<T>(pf::make_unique<TakeGenerator<T>>(target, std::move(generator)));
    }

    template <typename T, typename Predicate>
    class FilterGenerator : public IGenerator<T> {
        GeneratorWrapper<T> m_generator;
        Predicate m_predicate;
    public:
        template <typename P = Predicate>
        FilterGenerator(P&& pred, GeneratorWrapper<T>&& generator):
            m_generator(std::move(generator)),
            m_predicate(std::forward<P>(pred))
        {
            if (!m_predicate(m_generator.get())) {
                // It might happen that there are no values that pass the
                // filter. In that case we throw an exception.
                auto has_initial_value = next();
                if (!has_initial_value) {
                    Catch::throw_exception(GeneratorException("No valid value found in filtered generator"));
                }
            }
        }

        T const& get() const override {
            return m_generator.get();
        }

        bool next() override {
            bool success = m_generator.next();
            if (!success) {
                return false;
            }
            while (!m_predicate(m_generator.get()) && (success = m_generator.next()) == true);
            return success;
        }
    };

    template <typename T, typename Predicate>
    GeneratorWrapper<T> filter(Predicate&& pred, GeneratorWrapper<T>&& generator) {
        return GeneratorWrapper<T>(std::unique_ptr<IGenerator<T>>(pf::make_unique<FilterGenerator<T, Predicate>>(std::forward<Predicate>(pred), std::move(generator))));
    }

    template <typename T>
    class RepeatGenerator : public IGenerator<T> {
        static_assert(!std::is_same<T, bool>::value,
            "RepeatGenerator currently does not support bools"
            "because of std::vector<bool> specialization");
        GeneratorWrapper<T> m_generator;
        mutable std::vector<T> m_returned;
        size_t m_target_repeats;
        size_t m_current_repeat = 0;
        size_t m_repeat_index = 0;
    public:
        RepeatGenerator(size_t repeats, GeneratorWrapper<T>&& generator):
            m_generator(std::move(generator)),
            m_target_repeats(repeats)
        {
            assert(m_target_repeats > 0 && "Repeat generator must repeat at least once");
        }

        T const& get() const override {
            if (m_current_repeat == 0) {
                m_returned.push_back(m_generator.get());
                return m_returned.back();
            }
            return m_returned[m_repeat_index];
        }

        bool next() override {
            // There are 2 basic cases:
            // 1) We are still reading the generator
            // 2) We are reading our own cache

            // In the first case, we need to poke the underlying generator.
            // If it happily moves, we are left in that state, otherwise it is time to start reading from our cache
            if (m_current_repeat == 0) {
                const auto success = m_generator.next();
                if (!success) {
                    ++m_current_repeat;
                }
                return m_current_repeat < m_target_repeats;
            }

            // In the second case, we need to move indices forward and check that we haven't run up against the end
            ++m_repeat_index;
            if (m_repeat_index == m_returned.size()) {
                m_repeat_index = 0;
                ++m_current_repeat;
            }
            return m_current_repeat < m_target_repeats;
        }
    };

    template <typename T>
    GeneratorWrapper<T> repeat(size_t repeats, GeneratorWrapper<T>&& generator) {
        return GeneratorWrapper<T>(pf::make_unique<RepeatGenerator<T>>(repeats, std::move(generator)));
    }

    template <typename T, typename U, typename Func>
    class MapGenerator : public IGenerator<T> {
        // TBD: provide static assert for mapping function, for friendly error message
        GeneratorWrapper<U> m_generator;
        Func m_function;
        // To avoid returning dangling reference, we have to save the values
        T m_cache;
    public:
        template <typename F2 = Func>
        MapGenerator(F2&& function, GeneratorWrapper<U>&& generator) :
            m_generator(std::move(generator)),
            m_function(std::forward<F2>(function)),
            m_cache(m_function(m_generator.get()))
        {}

        T const& get() const override {
            return m_cache;
        }
        bool next() override {
            const auto success = m_generator.next();
            if (success) {
                m_cache = m_function(m_generator.get());
            }
            return success;
        }
    };

    template <typename Func, typename U, typename T = FunctionReturnType<Func, U>>
    GeneratorWrapper<T> map(Func&& function, GeneratorWrapper<U>&& generator) {
        return GeneratorWrapper<T>(
            pf::make_unique<MapGenerator<T, U, Func>>(std::forward<Func>(function), std::move(generator))
        );
    }

    template <typename T, typename U, typename Func>
    GeneratorWrapper<T> map(Func&& function, GeneratorWrapper<U>&& generator) {
        return GeneratorWrapper<T>(
            pf::make_unique<MapGenerator<T, U, Func>>(std::forward<Func>(function), std::move(generator))
        );
    }

    template <typename T>
    class ChunkGenerator final : public IGenerator<std::vector<T>> {
        std::vector<T> m_chunk;
        size_t m_chunk_size;
        GeneratorWrapper<T> m_generator;
        bool m_used_up = false;
    public:
        ChunkGenerator(size_t size, GeneratorWrapper<T> generator) :
            m_chunk_size(size), m_generator(std::move(generator))
        {
            m_chunk.reserve(m_chunk_size);
            if (m_chunk_size != 0) {
                m_chunk.push_back(m_generator.get());
                for (size_t i = 1; i < m_chunk_size; ++i) {
                    if (!m_generator.next()) {
                        Catch::throw_exception(GeneratorException("Not enough values to initialize the first chunk"));
                    }
                    m_chunk.push_back(m_generator.get());
                }
            }
        }
        std::vector<T> const& get() const override {
            return m_chunk;
        }
        bool next() override {
            m_chunk.clear();
            for (size_t idx = 0; idx < m_chunk_size; ++idx) {
                if (!m_generator.next()) {
                    return false;
                }
                m_chunk.push_back(m_generator.get());
            }
            return true;
        }
    };

    template <typename T>
    GeneratorWrapper<std::vector<T>> chunk(size_t size, GeneratorWrapper<T>&& generator) {
        return GeneratorWrapper<std::vector<T>>(
            pf::make_unique<ChunkGenerator<T>>(size, std::move(generator))
        );
    }

} // namespace Generators
} // namespace Catch

// end catch_generators_generic.hpp
// start catch_generators_specific.hpp

// start catch_context.h

#include <memory>

namespace Catch {

    struct IResultCapture;
    struct IRunner;
    struct IConfig;
    struct IMutableContext;

    using IConfigPtr = std::shared_ptr<IConfig const>;

    struct IContext
    {
        virtual ~IContext();

        virtual IResultCapture* getResultCapture() = 0;
        virtual IRunner* getRunner() = 0;
        virtual IConfigPtr const& getConfig() const = 0;
    };

    struct IMutableContext : IContext
    {
        virtual ~IMutableContext();
        virtual void setResultCapture( IResultCapture* resultCapture ) = 0;
        virtual void setRunner( IRunner* runner ) = 0;
        virtual void setConfig( IConfigPtr const& config ) = 0;

    private:
        static IMutableContext *currentContext;
        friend IMutableContext& getCurrentMutableContext();
        friend void cleanUpContext();
        static void createContext();
    };

    inline IMutableContext& getCurrentMutableContext()
    {
        if( !IMutableContext::currentContext )
            IMutableContext::createContext();
        // NOLINTNEXTLINE(clang-analyzer-core.uninitialized.UndefReturn)
        return *IMutableContext::currentContext;
    }

    inline IContext& getCurrentContext()
    {
        return getCurrentMutableContext();
    }

    void cleanUpContext();

    class SimplePcg32;
    SimplePcg32& rng();
}

// end catch_context.h
// start catch_interfaces_config.h

// start catch_option.hpp

namespace Catch {

    // An optional type
    template<typename T>
    class Option {
    public:
        Option() : nullableValue( nullptr ) {}
        Option( T const& _value )
        : nullableValue( new( storage ) T( _value ) )
        {}
        Option( Option const& _other )
        : nullableValue( _other ? new( storage ) T( *_other ) : nullptr )
        {}

        ~Option() {
            reset();
        }

        Option& operator= ( Option const& _other ) {
            if( &_other != this ) {
                reset();
                if( _other )
                    nullableValue = new( storage ) T( *_other );
            }
            return *this;
        }
        Option& operator = ( T const& _value ) {
            reset();
            nullableValue = new( storage ) T( _value );
            return *this;
        }

        void reset() {
            if( nullableValue )
                nullableValue->~T();
            nullableValue = nullptr;
        }

        T& operator*() { return *nullableValue; }
        T const& operator*() const { return *nullableValue; }
        T* operator->() { return nullableValue; }
        const T* operator->() const { return nullableValue; }

        T valueOr( T const& defaultValue ) const {
            return nullableValue ? *nullableValue : defaultValue;
        }

        bool some() const { return nullableValue != nullptr; }
        bool none() const { return nullableValue == nullptr; }

        bool operator !() const { return nullableValue == nullptr; }
        explicit operator bool() const {
            return some();
        }

    private:
        T *nullableValue;
        alignas(alignof(T)) char storage[sizeof(T)];
    };

} // end namespace Catch

// end catch_option.hpp
#include <chrono>
#include <iosfwd>
#include <string>
#include <vector>
#include <memory>

namespace Catch {

    enum class Verbosity {
        Quiet = 0,
        Normal,
        High
    };

    struct WarnAbout { enum What {
        Nothing = 0x00,
        NoAssertions = 0x01,
        NoTests = 0x02
    }; };

    struct ShowDurations { enum OrNot {
        DefaultForReporter,
        Always,
        Never
    }; };
    struct RunTests { enum InWhatOrder {
        InDeclarationOrder,
        InLexicographicalOrder,
        InRandomOrder
    }; };
    struct UseColour { enum YesOrNo {
        Auto,
        Yes,
        No
    }; };
    struct WaitForKeypress { enum When {
        Never,
        BeforeStart = 1,
        BeforeExit = 2,
        BeforeStartAndExit = BeforeStart | BeforeExit
    }; };

    class TestSpec;

    struct IConfig : NonCopyable {

        virtual ~IConfig();

        virtual bool allowThrows() const = 0;
        virtual std::ostream& stream() const = 0;
        virtual std::string name() const = 0;
        virtual bool includeSuccessfulResults() const = 0;
        virtual bool shouldDebugBreak() const = 0;
        virtual bool warnAboutMissingAssertions() const = 0;
        virtual bool warnAboutNoTests() const = 0;
        virtual int abortAfter() const = 0;
        virtual bool showInvisibles() const = 0;
        virtual ShowDurations::OrNot showDurations() const = 0;
        virtual double minDuration() const = 0;
        virtual TestSpec const& testSpec() const = 0;
        virtual bool hasTestFilters() const = 0;
        virtual std::vector<std::string> const& getTestsOrTags() const = 0;
        virtual RunTests::InWhatOrder runOrder() const = 0;
        virtual unsigned int rngSeed() const = 0;
        virtual UseColour::YesOrNo useColour() const = 0;
        virtual std::vector<std::string> const& getSectionsToRun() const = 0;
        virtual Verbosity verbosity() const = 0;

        virtual bool benchmarkNoAnalysis() const = 0;
        virtual int benchmarkSamples() const = 0;
        virtual double benchmarkConfidenceInterval() const = 0;
        virtual unsigned int benchmarkResamples() const = 0;
        virtual std::chrono::milliseconds benchmarkWarmupTime() const = 0;
    };

    using IConfigPtr = std::shared_ptr<IConfig const>;
}

// end catch_interfaces_config.h
// start catch_random_number_generator.h

#include <cstdint>

namespace Catch {

    // This is a simple implementation of C++11 Uniform Random Number
    // Generator. It does not provide all operators, because Catch2
    // does not use it, but it should behave as expected inside stdlib's
    // distributions.
    // The implementation is based on the PCG family (http://pcg-random.org)
    class SimplePcg32 {
        using state_type = std::uint64_t;
    public:
        using result_type = std::uint32_t;
        static constexpr result_type (min)() {
            return 0;
        }
        static constexpr result_type (max)() {
            return static_cast<result_type>(-1);
        }

        // Provide some default initial state for the default constructor
        SimplePcg32():SimplePcg32(0xed743cc4U) {}

        explicit SimplePcg32(result_type seed_);

        void seed(result_type seed_);
        void discard(uint64_t skip);

        result_type operator()();

    private:
        friend bool operator==(SimplePcg32 const& lhs, SimplePcg32 const& rhs);
        friend bool operator!=(SimplePcg32 const& lhs, SimplePcg32 const& rhs);

        // In theory we also need operator<< and operator>>
        // In practice we do not use them, so we will skip them for now

        std::uint64_t m_state;
        // This part of the state determines which "stream" of the numbers
        // is chosen -- we take it as a constant for Catch2, so we only
        // need to deal with seeding the main state.
        // Picked by reading 8 bytes from `/dev/random` :-)
        static const std::uint64_t s_inc = (0x13ed0cc53f939476ULL << 1ULL) | 1ULL;
    };

} // end namespace Catch

// end catch_random_number_generator.h
#include <random>

namespace Catch {
namespace Generators {

template <typename Float>
class RandomFloatingGenerator final : public IGenerator<Float> {
    Catch::SimplePcg32& m_rng;
    std::uniform_real_distribution<Float> m_dist;
    Float m_current_number;
public:

    RandomFloatingGenerator(Float a, Float b):
        m_rng(rng()),
        m_dist(a, b) {
        static_cast<void>(next());
    }

    Float const& get() const override {
        return m_current_number;
    }
    bool next() override {
        m_current_number = m_dist(m_rng);
        return true;
    }
};

template <typename Integer>
class RandomIntegerGenerator final : public IGenerator<Integer> {
    Catch::SimplePcg32& m_rng;
    std::uniform_int_distribution<Integer> m_dist;
    Integer m_current_number;
public:

    RandomIntegerGenerator(Integer a, Integer b):
        m_rng(rng()),
        m_dist(a, b) {
        static_cast<void>(next());
    }

    Integer const& get() const override {
        return m_current_number;
    }
    bool next() override {
        m_current_number = m_dist(m_rng);
        return true;
    }
};

// TODO: Ideally this would be also constrained against the various char types,
//       but I don't expect users to run into that in practice.
template <typename T>
typename std::enable_if<std::is_integral<T>::value && !std::is_same<T, bool>::value,
GeneratorWrapper<T>>::type
random(T a, T b) {
    return GeneratorWrapper<T>(
        pf::make_unique<RandomIntegerGenerator<T>>(a, b)
    );
}

template <typename T>
typename std::enable_if<std::is_floating_point<T>::value,
GeneratorWrapper<T>>::type
random(T a, T b) {
    return GeneratorWrapper<T>(
        pf::make_unique<RandomFloatingGenerator<T>>(a, b)
    );
}

template <typename T>
class RangeGenerator final : public IGenerator<T> {
    T m_current;
    T m_end;
    T m_step;
    bool m_positive;

public:
    RangeGenerator(T const& start, T const& end, T const& step):
        m_current(start),
        m_end(end),
        m_step(step),
        m_positive(m_step > T(0))
    {
        assert(m_current != m_end && "Range start and end cannot be equal");
        assert(m_step != T(0) && "Step size cannot be zero");
        assert(((m_positive && m_current <= m_end) || (!m_positive && m_current >= m_end)) && "Step moves away from end");
    }

    RangeGenerator(T const& start, T const& end):
        RangeGenerator(start, end, (start < end) ? T(1) : T(-1))
    {}

    T const& get() const override {
        return m_current;
    }

    bool next() override {
        m_current += m_step;
        return (m_positive) ? (m_current < m_end) : (m_current > m_end);
    }
};

template <typename T>
GeneratorWrapper<T> range(T const& start, T const& end, T const& step) {
    static_assert(std::is_arithmetic<T>::value && !std::is_same<T, bool>::value, "Type must be numeric");
    return GeneratorWrapper<T>(pf::make_unique<RangeGenerator<T>>(start, end, step));
}

template <typename T>
GeneratorWrapper<T> range(T const& start, T const& end) {
    static_assert(std::is_integral<T>::value && !std::is_same<T, bool>::value, "Type must be an integer");
    return GeneratorWrapper<T>(pf::make_unique<RangeGenerator<T>>(start, end));
}

template <typename T>
class IteratorGenerator final : public IGenerator<T> {
    static_assert(!std::is_same<T, bool>::value,
        "IteratorGenerator currently does not support bools"
        "because of std::vector<bool> specialization");

    std::vector<T> m_elems;
    size_t m_current = 0;
public:
    template <typename InputIterator, typename InputSentinel>
    IteratorGenerator(InputIterator first, InputSentinel last):m_elems(first, last) {
        if (m_elems.empty()) {
            Catch::throw_exception(GeneratorException("IteratorGenerator received no valid values"));
        }
    }

    T const& get() const override {
        return m_elems[m_current];
    }

    bool next() override {
        ++m_current;
        return m_current != m_elems.size();
    }
};

template <typename InputIterator,
          typename InputSentinel,
          typename ResultType = typename std::iterator_traits<InputIterator>::value_type>
GeneratorWrapper<ResultType> from_range(InputIterator from, InputSentinel to) {
    return GeneratorWrapper<ResultType>(pf::make_unique<IteratorGenerator<ResultType>>(from, to));
}

template <typename Container,
          typename ResultType = typename Container::value_type>
GeneratorWrapper<ResultType> from_range(Container const& cnt) {
    return GeneratorWrapper<ResultType>(pf::make_unique<IteratorGenerator<ResultType>>(cnt.begin(), cnt.end()));
}

} // namespace Generators
} // namespace Catch

// end catch_generators_specific.hpp

// These files are included here so the single_include script doesn't put them
// in the conditionally compiled sections
// start catch_test_case_info.h

#include <string>
#include <vector>
#include <memory>

#ifdef __clang__
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wpadded"
#endif

namespace Catch {

    struct ITestInvoker;

    struct TestCaseInfo {
        enum SpecialProperties{
            None = 0,
            IsHidden = 1 << 1,
            ShouldFail = 1 << 2,
            MayFail = 1 << 3,
            Throws = 1 << 4,
            NonPortable = 1 << 5,
            Benchmark = 1 << 6
        };

        TestCaseInfo(   std::string const& _name,
                        std::string const& _className,
                        std::string const& _description,
                        std::vector<std::string> const& _tags,
                        SourceLineInfo const& _lineInfo );

        friend void setTags( TestCaseInfo& testCaseInfo, std::vector<std::string> tags );

        bool isHidden() const;
        bool throws() const;
        bool okToFail() const;
        bool expectedToFail() const;

        std::string tagsAsString() const;

        std::string name;
        std::string className;
        std::string description;
        std::vector<std::string> tags;
        std::vector<std::string> lcaseTags;
        SourceLineInfo lineInfo;
        SpecialProperties properties;
    };

    class TestCase : public TestCaseInfo {
    public:

        TestCase( ITestInvoker* testCase, TestCaseInfo&& info );

        TestCase withName( std::string const& _newName ) const;

        void invoke() const;

        TestCaseInfo const& getTestCaseInfo() const;

        bool operator == ( TestCase const& other ) const;
        bool operator < ( TestCase const& other ) const;

    private:
        std::shared_ptr<ITestInvoker> test;
    };

    TestCase makeTestCase(  ITestInvoker* testCase,
                            std::string const& className,
                            NameAndTags const& nameAndTags,
                            SourceLineInfo const& lineInfo );
}

#ifdef __clang__
#pragma clang diagnostic pop
#endif

// end catch_test_case_info.h
// start catch_interfaces_runner.h

namespace Catch {

    struct IRunner {
        virtual ~IRunner();
        virtual bool aborting() const = 0;
    };
}

// end catch_interfaces_runner.h

#ifdef __OBJC__
// start catch_objc.hpp

#import <objc/runtime.h>

#include <string>

// NB. Any general catch headers included here must be included
// in catch.hpp first to make sure they are included by the single
// header for non obj-usage

///////////////////////////////////////////////////////////////////////////////
// This protocol is really only here for (self) documenting purposes, since
// all its methods are optional.
@protocol OcFixture

@optional

-(void) setUp;
-(void) tearDown;

@end

namespace Catch {

    class OcMethod : public ITestInvoker {

    public:
        OcMethod( Class cls, SEL sel ) : m_cls( cls ), m_sel( sel ) {}

        virtual void invoke() const {
            id obj = [[m_cls alloc] init];

            performOptionalSelector( obj, @selector(setUp)  );
            performOptionalSelector( obj, m_sel );
            performOptionalSelector( obj, @selector(tearDown)  );

            arcSafeRelease( obj );
        }
    private:
        virtual ~OcMethod() {}

        Class m_cls;
        SEL m_sel;
    };

    namespace Detail{

        inline std::string getAnnotation(   Class cls,
                                            std::string const& annotationName,
                                            std::string const& testCaseName ) {
            NSString* selStr = [[NSString alloc] initWithFormat:@"Catch_%s_%s", annotationName.c_str(), testCaseName.c_str()];
            SEL sel = NSSelectorFromString( selStr );
            arcSafeRelease( selStr );
            id value = performOptionalSelector( cls, sel );
            if( value )
                return [(NSString*)value UTF8String];
            return "";
        }
    }

    inline std::size_t registerTestMethods() {
        std::size_t noTestMethods = 0;
        int noClasses = objc_getClassList( nullptr, 0 );

        Class* classes = (CATCH_UNSAFE_UNRETAINED Class *)malloc( sizeof(Class) * noClasses);
        objc_getClassList( classes, noClasses );

        for( int c = 0; c < noClasses; c++ ) {
            Class cls = classes[c];
            {
                u_int count;
                Method* methods = class_copyMethodList( cls, &count );
                for( u_int m = 0; m < count ; m++ ) {
                    SEL selector = method_getName(methods[m]);
                    std::string methodName = sel_getName(selector);
                    if( startsWith( methodName, "Catch_TestCase_" ) ) {
                        std::string testCaseName = methodName.substr( 15 );
                        std::string name = Detail::getAnnotation( cls, "Name", testCaseName );
                        std::string desc = Detail::getAnnotation( cls, "Description", testCaseName );
                        const char* className = class_getName( cls );

                        getMutableRegistryHub().registerTest( makeTestCase( new OcMethod( cls, selector ), className, NameAndTags( name.c_str(), desc.c_str() ), SourceLineInfo("",0) ) );
                        noTestMethods++;
                    }
                }
                free(methods);
            }
        }
        return noTestMethods;
    }

#if !defined(CATCH_CONFIG_DISABLE_MATCHERS)

    namespace Matchers {
        namespace Impl {
        namespace NSStringMatchers {

            struct StringHolder : MatcherBase<NSString*>{
                StringHolder( NSString* substr ) : m_substr( [substr copy] ){}
                StringHolder( StringHolder const& other ) : m_substr( [other.m_substr copy] ){}
                StringHolder() {
                    arcSafeRelease( m_substr );
                }

                bool match( NSString* str ) const override {
                    return false;
                }

                NSString* CATCH_ARC_STRONG m_substr;
            };

            struct Equals : StringHolder {
                Equals( NSString* substr ) : StringHolder( substr ){}

                bool match( NSString* str ) const override {
                    return  (str != nil || m_substr == nil ) &&
                            [str isEqualToString:m_substr];
                }

                std::string describe() const override {
                    return "equals string: " + Catch::Detail::stringify( m_substr );
                }
            };

            struct Contains : StringHolder {
                Contains( NSString* substr ) : StringHolder( substr ){}

                bool match( NSString* str ) const override {
                    return  (str != nil || m_substr == nil ) &&
                            [str rangeOfString:m_substr].location != NSNotFound;
                }

                std::string describe() const override {
                    return "contains string: " + Catch::Detail::stringify( m_substr );
                }
            };

            struct StartsWith : StringHolder {
                StartsWith( NSString* substr ) : StringHolder( substr ){}

                bool match( NSString* str ) const override {
                    return  (str != nil || m_substr == nil ) &&
                            [str rangeOfString:m_substr].location == 0;
                }

                std::string describe() const override {
                    return "starts with: " + Catch::Detail::stringify( m_substr );
                }
            };
            struct EndsWith : StringHolder {
                EndsWith( NSString* substr ) : StringHolder( substr ){}

                bool match( NSString* str ) const override {
                    return  (str != nil || m_substr == nil ) &&
                            [str rangeOfString:m_substr].location == [str length] - [m_substr length];
                }

                std::string describe() const override {
                    return "ends with: " + Catch::Detail::stringify( m_substr );
                }
            };

        } // namespace NSStringMatchers
        } // namespace Impl

        inline Impl::NSStringMatchers::Equals
            Equals( NSString* substr ){ return Impl::NSStringMatchers::Equals( substr ); }

        inline Impl::NSStringMatchers::Contains
            Contains( NSString* substr ){ return Impl::NSStringMatchers::Contains( substr ); }

        inline Impl::NSStringMatchers::StartsWith
            StartsWith( NSString* substr ){ return Impl::NSStringMatchers::StartsWith( substr ); }

        inline Impl::NSStringMatchers::EndsWith
            EndsWith( NSString* substr ){ return Impl::NSStringMatchers::EndsWith( substr ); }

    } // namespace Matchers

    using namespace Matchers;

#endif // CATCH_CONFIG_DISABLE_MATCHERS

} // namespace Catch

///////////////////////////////////////////////////////////////////////////////
#define OC_MAKE_UNIQUE_NAME( root, uniqueSuffix ) root##uniqueSuffix
#define OC_TEST_CASE2( name, desc, uniqueSuffix ) \
+(NSString*) OC_MAKE_UNIQUE_NAME( Catch_Name_test_, uniqueSuffix ) \
{ \
return @ name; \
} \
+(NSString*) OC_MAKE_UNIQUE_NAME( Catch_Description_test_, uniqueSuffix ) \
{ \
return @ desc; \
} \
-(void) OC_MAKE_UNIQUE_NAME( Catch_TestCase_test_, uniqueSuffix )

#define OC_TEST_CASE( name, desc ) OC_TEST_CASE2( name, desc, __LINE__ )

// end catch_objc.hpp
#endif

// Benchmarking needs the externally-facing parts of reporters to work
#if defined(CATCH_CONFIG_EXTERNAL_INTERFACES) || defined(CATCH_CONFIG_ENABLE_BENCHMARKING)
// start catch_external_interfaces.h

// start catch_reporter_bases.hpp

// start catch_interfaces_reporter.h

// start catch_config.hpp

// start catch_test_spec_parser.h

#ifdef __clang__
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wpadded"
#endif

// start catch_test_spec.h

#ifdef __clang__
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wpadded"
#endif

// start catch_wildcard_pattern.h

namespace Catch
{
    class WildcardPattern {
        enum WildcardPosition {
            NoWildcard = 0,
            WildcardAtStart = 1,
            WildcardAtEnd = 2,
            WildcardAtBothEnds = WildcardAtStart | WildcardAtEnd
        };

    public:

        WildcardPattern( std::string const& pattern, CaseSensitive::Choice caseSensitivity );
        virtual ~WildcardPattern() = default;
        virtual bool matches( std::string const& str ) const;

    private:
        std::string normaliseString( std::string const& str ) const;
        CaseSensitive::Choice m_caseSensitivity;
        WildcardPosition m_wildcard = NoWildcard;
        std::string m_pattern;
    };
}

// end catch_wildcard_pattern.h
#include <string>
#include <vector>
#include <memory>

namespace Catch {

    struct IConfig;

    class TestSpec {
        class Pattern {
        public:
            explicit Pattern( std::string const& name );
            virtual ~Pattern();
            virtual bool matches( TestCaseInfo const& testCase ) const = 0;
            std::string const& name() const;
        private:
            std::string const m_name;
        };
        using PatternPtr = std::shared_ptr<Pattern>;

        class NamePattern : public Pattern {
        public:
            explicit NamePattern( std::string const& name, std::string const& filterString );
            bool matches( TestCaseInfo const& testCase ) const override;
        private:
            WildcardPattern m_wildcardPattern;
        };

        class TagPattern : public Pattern {
        public:
            explicit TagPattern( std::string const& tag, std::string const& filterString );
            bool matches( TestCaseInfo const& testCase ) const override;
        private:
            std::string m_tag;
        };

        class ExcludedPattern : public Pattern {
        public:
            explicit ExcludedPattern( PatternPtr const& underlyingPattern );
            bool matches( TestCaseInfo const& testCase ) const override;
        private:
            PatternPtr m_underlyingPattern;
        };

        struct Filter {
            std::vector<PatternPtr> m_patterns;

            bool matches( TestCaseInfo const& testCase ) const;
            std::string name() const;
        };

    public:
        struct FilterMatch {
            std::string name;
            std::vector<TestCase const*> tests;
        };
        using Matches = std::vector<FilterMatch>;
        using vectorStrings = std::vector<std::string>;

        bool hasFilters() const;
        bool matches( TestCaseInfo const& testCase ) const;
        Matches matchesByFilter( std::vector<TestCase> const& testCases, IConfig const& config ) const;
        const vectorStrings & getInvalidArgs() const;

    private:
        std::vector<Filter> m_filters;
        std::vector<std::string> m_invalidArgs;
        friend class TestSpecParser;
    };
}

#ifdef __clang__
#pragma clang diagnostic pop
#endif

// end catch_test_spec.h
// start catch_interfaces_tag_alias_registry.h

#include <string>

namespace Catch {

    struct TagAlias;

    struct ITagAliasRegistry {
        virtual ~ITagAliasRegistry();
        // Nullptr if not present
        virtual TagAlias const* find( std::string const& alias ) const = 0;
        virtual std::string expandAliases( std::string const& unexpandedTestSpec ) const = 0;

        static ITagAliasRegistry const& get();
    };

} // end namespace Catch

// end catch_interfaces_tag_alias_registry.h
namespace Catch {

    class TestSpecParser {
        enum Mode{ None, Name, QuotedName, Tag, EscapedName };
        Mode m_mode = None;
        Mode lastMode = None;
        bool m_exclusion = false;
        std::size_t m_pos = 0;
        std::size_t m_realPatternPos = 0;
        std::string m_arg;
        std::string m_substring;
        std::string m_patternName;
        std::vector<std::size_t> m_escapeChars;
        TestSpec::Filter m_currentFilter;
        TestSpec m_testSpec;
        ITagAliasRegistry const* m_tagAliases = nullptr;

    public:
        TestSpecParser( ITagAliasRegistry const& tagAliases );

        TestSpecParser& parse( std::string const& arg );
        TestSpec testSpec();

    private:
        bool visitChar( char c );
        void startNewMode( Mode mode );
        bool processNoneChar( char c );
        void processNameChar( char c );
        bool processOtherChar( char c );
        void endMode();
        void escape();
        bool isControlChar( char c ) const;
        void saveLastMode();
        void revertBackToLastMode();
        void addFilter();
        bool separate();

        // Handles common preprocessing of the pattern for name/tag patterns
        std::string preprocessPattern();
        // Adds the current pattern as a test name
        void addNamePattern();
        // Adds the current pattern as a tag
        void addTagPattern();

        inline void addCharToPattern(char c) {
            m_substring += c;
            m_patternName += c;
            m_realPatternPos++;
        }

    };
    TestSpec parseTestSpec( std::string const& arg );

} // namespace Catch

#ifdef __clang__
#pragma clang diagnostic pop
#endif

// end catch_test_spec_parser.h
// Libstdc++ doesn't like incomplete classes for unique_ptr

#include <memory>
#include <vector>
#include <string>

#ifndef CATCH_CONFIG_CONSOLE_WIDTH
#define CATCH_CONFIG_CONSOLE_WIDTH 80
#endif

namespace Catch {

    struct IStream;

    struct ConfigData {
        bool listTests = false;
        bool listTags = false;
        bool listReporters = false;
        bool listTestNamesOnly = false;

        bool showSuccessfulTests = false;
        bool shouldDebugBreak = false;
        bool noThrow = false;
        bool showHelp = false;
        bool showInvisibles = false;
        bool filenamesAsTags = false;
        bool libIdentify = false;

        int abortAfter = -1;
        unsigned int rngSeed = 0;

        bool benchmarkNoAnalysis = false;
        unsigned int benchmarkSamples = 100;
        double benchmarkConfidenceInterval = 0.95;
        unsigned int benchmarkResamples = 100000;
        std::chrono::milliseconds::rep benchmarkWarmupTime = 100;

        Verbosity verbosity = Verbosity::Normal;
        WarnAbout::What warnings = WarnAbout::Nothing;
        ShowDurations::OrNot showDurations = ShowDurations::DefaultForReporter;
        double minDuration = -1;
        RunTests::InWhatOrder runOrder = RunTests::InDeclarationOrder;
        UseColour::YesOrNo useColour = UseColour::Auto;
        WaitForKeypress::When waitForKeypress = WaitForKeypress::Never;

        std::string outputFilename;
        std::string name;
        std::string processName;
#ifndef CATCH_CONFIG_DEFAULT_REPORTER
#define CATCH_CONFIG_DEFAULT_REPORTER "console"
#endif
        std::string reporterName = CATCH_CONFIG_DEFAULT_REPORTER;
#undef CATCH_CONFIG_DEFAULT_REPORTER

        std::vector<std::string> testsOrTags;
        std::vector<std::string> sectionsToRun;
    };

    class Config : public IConfig {
    public:

        Config() = default;
        Config( ConfigData const& data );
        virtual ~Config() = default;

        std::string const& getFilename() const;

        bool listTests() const;
        bool listTestNamesOnly() const;
        bool listTags() const;
        bool listReporters() const;

        std::string getProcessName() const;
        std::string const& getReporterName() const;

        std::vector<std::string> const& getTestsOrTags() const override;
        std::vector<std::string> const& getSectionsToRun() const override;

        TestSpec const& testSpec() const override;
        bool hasTestFilters() const override;

        bool showHelp() const;

        // IConfig interface
        bool allowThrows() const override;
        std::ostream& stream() const override;
        std::string name() const override;
        bool includeSuccessfulResults() const override;
        bool warnAboutMissingAssertions() const override;
        bool warnAboutNoTests() const override;
        ShowDurations::OrNot showDurations() const override;
        double minDuration() const override;
        RunTests::InWhatOrder runOrder() const override;
        unsigned int rngSeed() const override;
        UseColour::YesOrNo useColour() const override;
        bool shouldDebugBreak() const override;
        int abortAfter() const override;
        bool showInvisibles() const override;
        Verbosity verbosity() const override;
        bool benchmarkNoAnalysis() const override;
        int benchmarkSamples() const override;
        double benchmarkConfidenceInterval() const override;
        unsigned int benchmarkResamples() const override;
        std::chrono::milliseconds benchmarkWarmupTime() const override;

    private:

        IStream const* openStream();
        ConfigData m_data;

        std::unique_ptr<IStream const> m_stream;
        TestSpec m_testSpec;
        bool m_hasTestFilters = false;
    };

} // end namespace Catch

// end catch_config.hpp
// start catch_assertionresult.h

#include <string>

namespace Catch {

    struct AssertionResultData
    {
        AssertionResultData() = delete;

        AssertionResultData( ResultWas::OfType _resultType, LazyExpression const& _lazyExpression );

        std::string message;
        mutable std::string reconstructedExpression;
        LazyExpression lazyExpression;
        ResultWas::OfType resultType;

        std::string reconstructExpression() const;
    };

    class AssertionResult {
    public:
        AssertionResult() = delete;
        AssertionResult( AssertionInfo const& info, AssertionResultData const& data );

        bool isOk() const;
        bool succeeded() const;
        ResultWas::OfType getResultType() const;
        bool hasExpression() const;
        bool hasMessage() const;
        std::string getExpression() const;
        std::string getExpressionInMacro() const;
        bool hasExpandedExpression() const;
        std::string getExpandedExpression() const;
        std::string getMessage() const;
        SourceLineInfo getSourceInfo() const;
        StringRef getTestMacroName() const;

    //protected:
        AssertionInfo m_info;
        AssertionResultData m_resultData;
    };

} // end namespace Catch

// end catch_assertionresult.h
#if defined(CATCH_CONFIG_ENABLE_BENCHMARKING)
// start catch_estimate.hpp

 // Statistics estimates


namespace Catch {
    namespace Benchmark {
        template <typename Duration>
        struct Estimate {
            Duration point;
            Duration lower_bound;
            Duration upper_bound;
            double confidence_interval;

            template <typename Duration2>
            operator Estimate<Duration2>() const {
                return { point, lower_bound, upper_bound, confidence_interval };
            }
        };
    } // namespace Benchmark
} // namespace Catch

// end catch_estimate.hpp
// start catch_outlier_classification.hpp

// Outlier information

namespace Catch {
    namespace Benchmark {
        struct OutlierClassification {
            int samples_seen = 0;
            int low_severe = 0;     // more than 3 times IQR below Q1
            int low_mild = 0;       // 1.5 to 3 times IQR below Q1
            int high_mild = 0;      // 1.5 to 3 times IQR above Q3
            int high_severe = 0;    // more than 3 times IQR above Q3

            int total() const {
                return low_severe + low_mild + high_mild + high_severe;
            }
        };
    } // namespace Benchmark
} // namespace Catch

// end catch_outlier_classification.hpp
#endif // CATCH_CONFIG_ENABLE_BENCHMARKING

#include <string>
#include <iosfwd>
#include <map>
#include <set>
#include <memory>
#include <algorithm>

namespace Catch {

    struct ReporterConfig {
        explicit ReporterConfig( IConfigPtr const& _fullConfig );

        ReporterConfig( IConfigPtr const& _fullConfig, std::ostream& _stream );

        std::ostream& stream() const;
        IConfigPtr fullConfig() const;

    private:
        std::ostream* m_stream;
        IConfigPtr m_fullConfig;
    };

    struct ReporterPreferences {
        bool shouldRedirectStdOut = false;
        bool shouldReportAllAssertions = false;
    };

    template<typename T>
    struct LazyStat : Option<T> {
        LazyStat& operator=( T const& _value ) {
            Option<T>::operator=( _value );
            used = false;
            return *this;
        }
        void reset() {
            Option<T>::reset();
            used = false;
        }
        bool used = false;
    };

    struct TestRunInfo {
        TestRunInfo( std::string const& _name );
        std::string name;
    };
    struct GroupInfo {
        GroupInfo(  std::string const& _name,
                    std::size_t _groupIndex,
                    std::size_t _groupsCount );

        std::string name;
        std::size_t groupIndex;
        std::size_t groupsCounts;
    };

    struct AssertionStats {
        AssertionStats( AssertionResult const& _assertionResult,
                        std::vector<MessageInfo> const& _infoMessages,
                        Totals const& _totals );

        AssertionStats( AssertionStats const& )              = default;
        AssertionStats( AssertionStats && )                  = default;
        AssertionStats& operator = ( AssertionStats const& ) = delete;
        AssertionStats& operator = ( AssertionStats && )     = delete;
        virtual ~AssertionStats();

        AssertionResult assertionResult;
        std::vector<MessageInfo> infoMessages;
        Totals totals;
    };

    struct SectionStats {
        SectionStats(   SectionInfo const& _sectionInfo,
                        Counts const& _assertions,
                        double _durationInSeconds,
                        bool _missingAssertions );
        SectionStats( SectionStats const& )              = default;
        SectionStats( SectionStats && )                  = default;
        SectionStats& operator = ( SectionStats const& ) = default;
        SectionStats& operator = ( SectionStats && )     = default;
        virtual ~SectionStats();

        SectionInfo sectionInfo;
        Counts assertions;
        double durationInSeconds;
        bool missingAssertions;
    };

    struct TestCaseStats {
        TestCaseStats(  TestCaseInfo const& _testInfo,
                        Totals const& _totals,
                        std::string const& _stdOut,
                        std::string const& _stdErr,
                        bool _aborting );

        TestCaseStats( TestCaseStats const& )              = default;
        TestCaseStats( TestCaseStats && )                  = default;
        TestCaseStats& operator = ( TestCaseStats const& ) = default;
        TestCaseStats& operator = ( TestCaseStats && )     = default;
        virtual ~TestCaseStats();

        TestCaseInfo testInfo;
        Totals totals;
        std::string stdOut;
        std::string stdErr;
        bool aborting;
    };

    struct TestGroupStats {
        TestGroupStats( GroupInfo const& _groupInfo,
                        Totals const& _totals,
                        bool _aborting );
        TestGroupStats( GroupInfo const& _groupInfo );

        TestGroupStats( TestGroupStats const& )              = default;
        TestGroupStats( TestGroupStats && )                  = default;
        TestGroupStats& operator = ( TestGroupStats const& ) = default;
        TestGroupStats& operator = ( TestGroupStats && )     = default;
        virtual ~TestGroupStats();

        GroupInfo groupInfo;
        Totals totals;
        bool aborting;
    };

    struct TestRunStats {
        TestRunStats(   TestRunInfo const& _runInfo,
                        Totals const& _totals,
                        bool _aborting );

        TestRunStats( TestRunStats const& )              = default;
        TestRunStats( TestRunStats && )                  = default;
        TestRunStats& operator = ( TestRunStats const& ) = default;
        TestRunStats& operator = ( TestRunStats && )     = default;
        virtual ~TestRunStats();

        TestRunInfo runInfo;
        Totals totals;
        bool aborting;
    };

#if defined(CATCH_CONFIG_ENABLE_BENCHMARKING)
    struct BenchmarkInfo {
        std::string name;
        double estimatedDuration;
        int iterations;
        int samples;
        unsigned int resamples;
        double clockResolution;
        double clockCost;
    };

    template <class Duration>
    struct BenchmarkStats {
        BenchmarkInfo info;

        std::vector<Duration> samples;
        Benchmark::Estimate<Duration> mean;
        Benchmark::Estimate<Duration> standardDeviation;
        Benchmark::OutlierClassification outliers;
        double outlierVariance;

        template <typename Duration2>
        operator BenchmarkStats<Duration2>() const {
            std::vector<Duration2> samples2;
            samples2.reserve(samples.size());
            std::transform(samples.begin(), samples.end(), std::back_inserter(samples2), [](Duration d) { return Duration2(d); });
            return {
                info,
                std::move(samples2),
                mean,
                standardDeviation,
                outliers,
                outlierVariance,
            };
        }
    };
#endif // CATCH_CONFIG_ENABLE_BENCHMARKING

    struct IStreamingReporter {
        virtual ~IStreamingReporter() = default;

        // Implementing class must also provide the following static methods:
        // static std::string getDescription();
        // static std::set<Verbosity> getSupportedVerbosities()

        virtual ReporterPreferences getPreferences() const = 0;

        virtual void noMatchingTestCases( std::string const& spec ) = 0;

        virtual void reportInvalidArguments(std::string const&) {}

        virtual void testRunStarting( TestRunInfo const& testRunInfo ) = 0;
        virtual void testGroupStarting( GroupInfo const& groupInfo ) = 0;

        virtual void testCaseStarting( TestCaseInfo const& testInfo ) = 0;
        virtual void sectionStarting( SectionInfo const& sectionInfo ) = 0;

#if defined(CATCH_CONFIG_ENABLE_BENCHMARKING)
        virtual void benchmarkPreparing( std::string const& ) {}
        virtual void benchmarkStarting( BenchmarkInfo const& ) {}
        virtual void benchmarkEnded( BenchmarkStats<> const& ) {}
        virtual void benchmarkFailed( std::string const& ) {}
#endif // CATCH_CONFIG_ENABLE_BENCHMARKING

        virtual void assertionStarting( AssertionInfo const& assertionInfo ) = 0;

        // The return value indicates if the messages buffer should be cleared:
        virtual bool assertionEnded( AssertionStats const& assertionStats ) = 0;

        virtual void sectionEnded( SectionStats const& sectionStats ) = 0;
        virtual void testCaseEnded( TestCaseStats const& testCaseStats ) = 0;
        virtual void testGroupEnded( TestGroupStats const& testGroupStats ) = 0;
        virtual void testRunEnded( TestRunStats const& testRunStats ) = 0;

        virtual void skipTest( TestCaseInfo const& testInfo ) = 0;

        // Default empty implementation provided
        virtual void fatalErrorEncountered( StringRef name );

        virtual bool isMulti() const;
    };
    using IStreamingReporterPtr = std::unique_ptr<IStreamingReporter>;

    struct IReporterFactory {
        virtual ~IReporterFactory();
        virtual IStreamingReporterPtr create( ReporterConfig const& config ) const = 0;
        virtual std::string getDescription() const = 0;
    };
    using IReporterFactoryPtr = std::shared_ptr<IReporterFactory>;

    struct IReporterRegistry {
        using FactoryMap = std::map<std::string, IReporterFactoryPtr>;
        using Listeners = std::vector<IReporterFactoryPtr>;

        virtual ~IReporterRegistry();
        virtual IStreamingReporterPtr create( std::string const& name, IConfigPtr const& config ) const = 0;
        virtual FactoryMap const& getFactories() const = 0;
        virtual Listeners const& getListeners() const = 0;
    };

} // end namespace Catch

// end catch_interfaces_reporter.h
#include <algorithm>
#include <cstring>
#include <cfloat>
#include <cstdio>
#include <cassert>
#include <memory>
#include <ostream>

namespace Catch {
    void prepareExpandedExpression(AssertionResult& result);

    // Returns double formatted as %.3f (format expected on output)
    std::string getFormattedDuration( double duration );

    //! Should the reporter show
    bool shouldShowDuration( IConfig const& config, double duration );

    std::string serializeFilters( std::vector<std::string> const& container );

    template<typename DerivedT>
    struct StreamingReporterBase : IStreamingReporter {

        StreamingReporterBase( ReporterConfig const& _config )
        :   m_config( _config.fullConfig() ),
            stream( _config.stream() )
        {
            m_reporterPrefs.shouldRedirectStdOut = false;
            if( !DerivedT::getSupportedVerbosities().count( m_config->verbosity() ) )
                CATCH_ERROR( "Verbosity level not supported by this reporter" );
        }

        ReporterPreferences getPreferences() const override {
            return m_reporterPrefs;
        }

        static std::set<Verbosity> getSupportedVerbosities() {
            return { Verbosity::Normal };
        }

        ~StreamingReporterBase() override = default;

        void noMatchingTestCases(std::string const&) override {}

        void reportInvalidArguments(std::string const&) override {}

        void testRunStarting(TestRunInfo const& _testRunInfo) override {
            currentTestRunInfo = _testRunInfo;
        }

        void testGroupStarting(GroupInfo const& _groupInfo) override {
            currentGroupInfo = _groupInfo;
        }

        void testCaseStarting(TestCaseInfo const& _testInfo) override  {
            currentTestCaseInfo = _testInfo;
        }
        void sectionStarting(SectionInfo const& _sectionInfo) override {
            m_sectionStack.push_back(_sectionInfo);
        }

        void sectionEnded(SectionStats const& /* _sectionStats */) override {
            m_sectionStack.pop_back();
        }
        void testCaseEnded(TestCaseStats const& /* _testCaseStats */) override {
            currentTestCaseInfo.reset();
        }
        void testGroupEnded(TestGroupStats const& /* _testGroupStats */) override {
            currentGroupInfo.reset();
        }
        void testRunEnded(TestRunStats const& /* _testRunStats */) override {
            currentTestCaseInfo.reset();
            currentGroupInfo.reset();
            currentTestRunInfo.reset();
        }

        void skipTest(TestCaseInfo const&) override {
            // Don't do anything with this by default.
            // It can optionally be overridden in the derived class.
        }

        IConfigPtr m_config;
        std::ostream& stream;

        LazyStat<TestRunInfo> currentTestRunInfo;
        LazyStat<GroupInfo> currentGroupInfo;
        LazyStat<TestCaseInfo> currentTestCaseInfo;

        std::vector<SectionInfo> m_sectionStack;
        ReporterPreferences m_reporterPrefs;
    };

    template<typename DerivedT>
    struct CumulativeReporterBase : IStreamingReporter {
        template<typename T, typename ChildNodeT>
        struct Node {
            explicit Node( T const& _value ) : value( _value ) {}
            virtual ~Node() {}

            using ChildNodes = std::vector<std::shared_ptr<ChildNodeT>>;
            T value;
            ChildNodes children;
        };
        struct SectionNode {
            explicit SectionNode(SectionStats const& _stats) : stats(_stats) {}
            virtual ~SectionNode() = default;

            bool operator == (SectionNode const& other) const {
                return stats.sectionInfo.lineInfo == other.stats.sectionInfo.lineInfo;
            }
            bool operator == (std::shared_ptr<SectionNode> const& other) const {
                return operator==(*other);
            }

            SectionStats stats;
            using ChildSections = std::vector<std::shared_ptr<SectionNode>>;
            using Assertions = std::vector<AssertionStats>;
            ChildSections childSections;
            Assertions assertions;
            std::string stdOut;
            std::string stdErr;
        };

        struct BySectionInfo {
            BySectionInfo( SectionInfo const& other ) : m_other( other ) {}
            BySectionInfo( BySectionInfo const& other ) : m_other( other.m_other ) {}
            bool operator() (std::shared_ptr<SectionNode> const& node) const {
                return ((node->stats.sectionInfo.name == m_other.name) &&
                        (node->stats.sectionInfo.lineInfo == m_other.lineInfo));
            }
            void operator=(BySectionInfo const&) = delete;

        private:
            SectionInfo const& m_other;
        };

        using TestCaseNode = Node<TestCaseStats, SectionNode>;
        using TestGroupNode = Node<TestGroupStats, TestCaseNode>;
        using TestRunNode = Node<TestRunStats, TestGroupNode>;

        CumulativeReporterBase( ReporterConfig const& _config )
        :   m_config( _config.fullConfig() ),
            stream( _config.stream() )
        {
            m_reporterPrefs.shouldRedirectStdOut = false;
            if( !DerivedT::getSupportedVerbosities().count( m_config->verbosity() ) )
                CATCH_ERROR( "Verbosity level not supported by this reporter" );
        }
        ~CumulativeReporterBase() override = default;

        ReporterPreferences getPreferences() const override {
            return m_reporterPrefs;
        }

        static std::set<Verbosity> getSupportedVerbosities() {
            return { Verbosity::Normal };
        }

        void testRunStarting( TestRunInfo const& ) override {}
        void testGroupStarting( GroupInfo const& ) override {}

        void testCaseStarting( TestCaseInfo const& ) override {}

        void sectionStarting( SectionInfo const& sectionInfo ) override {
            SectionStats incompleteStats( sectionInfo, Counts(), 0, false );
            std::shared_ptr<SectionNode> node;
            if( m_sectionStack.empty() ) {
                if( !m_rootSection )
                    m_rootSection = std::make_shared<SectionNode>( incompleteStats );
                node = m_rootSection;
            }
            else {
                SectionNode& parentNode = *m_sectionStack.back();
                auto it =
                    std::find_if(   parentNode.childSections.begin(),
                                    parentNode.childSections.end(),
                                    BySectionInfo( sectionInfo ) );
                if( it == parentNode.childSections.end() ) {
                    node = std::make_shared<SectionNode>( incompleteStats );
                    parentNode.childSections.push_back( node );
                }
                else
                    node = *it;
            }
            m_sectionStack.push_back( node );
            m_deepestSection = std::move(node);
        }

        void assertionStarting(AssertionInfo const&) override {}

        bool assertionEnded(AssertionStats const& assertionStats) override {
            assert(!m_sectionStack.empty());
            // AssertionResult holds a pointer to a temporary DecomposedExpression,
            // which getExpandedExpression() calls to build the expression string.
            // Our section stack copy of the assertionResult will likely outlive the
            // temporary, so it must be expanded or discarded now to avoid calling
            // a destroyed object later.
            prepareExpandedExpression(const_cast<AssertionResult&>( assertionStats.assertionResult ) );
            SectionNode& sectionNode = *m_sectionStack.back();
            sectionNode.assertions.push_back(assertionStats);
            return true;
        }
        void sectionEnded(SectionStats const& sectionStats) override {
            assert(!m_sectionStack.empty());
            SectionNode& node = *m_sectionStack.back();
            node.stats = sectionStats;
            m_sectionStack.pop_back();
        }
        void testCaseEnded(TestCaseStats const& testCaseStats) override {
            auto node = std::make_shared<TestCaseNode>(testCaseStats);
            assert(m_sectionStack.size() == 0);
            node->children.push_back(m_rootSection);
            m_testCases.push_back(node);
            m_rootSection.reset();

            assert(m_deepestSection);
            m_deepestSection->stdOut = testCaseStats.stdOut;
            m_deepestSection->stdErr = testCaseStats.stdErr;
        }
        void testGroupEnded(TestGroupStats const& testGroupStats) override {
            auto node = std::make_shared<TestGroupNode>(testGroupStats);
            node->children.swap(m_testCases);
            m_testGroups.push_back(node);
        }
        void testRunEnded(TestRunStats const& testRunStats) override {
            auto node = std::make_shared<TestRunNode>(testRunStats);
            node->children.swap(m_testGroups);
            m_testRuns.push_back(node);
            testRunEndedCumulative();
        }
        virtual void testRunEndedCumulative() = 0;

        void skipTest(TestCaseInfo const&) override {}

        IConfigPtr m_config;
        std::ostream& stream;
        std::vector<AssertionStats> m_assertions;
        std::vector<std::vector<std::shared_ptr<SectionNode>>> m_sections;
        std::vector<std::shared_ptr<TestCaseNode>> m_testCases;
        std::vector<std::shared_ptr<TestGroupNode>> m_testGroups;

        std::vector<std::shared_ptr<TestRunNode>> m_testRuns;

        std::shared_ptr<SectionNode> m_rootSection;
        std::shared_ptr<SectionNode> m_deepestSection;
        std::vector<std::shared_ptr<SectionNode>> m_sectionStack;
        ReporterPreferences m_reporterPrefs;
    };

    template<char C>
    char const* getLineOfChars() {
        static char line[CATCH_CONFIG_CONSOLE_WIDTH] = {0};
        if( !*line ) {
            std::memset( line, C, CATCH_CONFIG_CONSOLE_WIDTH-1 );
            line[CATCH_CONFIG_CONSOLE_WIDTH-1] = 0;
        }
        return line;
    }

    struct TestEventListenerBase : StreamingReporterBase<TestEventListenerBase> {
        TestEventListenerBase( ReporterConfig const& _config );

        static std::set<Verbosity> getSupportedVerbosities();

        void assertionStarting(AssertionInfo const&) override;
        bool assertionEnded(AssertionStats const&) override;
    };

} // end namespace Catch

// end catch_reporter_bases.hpp
// start catch_console_colour.h

namespace Catch {

    struct Colour {
        enum Code {
            None = 0,

            White,
            Red,
            Green,
            Blue,
            Cyan,
            Yellow,
            Grey,

            Bright = 0x10,

            BrightRed = Bright | Red,
            BrightGreen = Bright | Green,
            LightGrey = Bright | Grey,
            BrightWhite = Bright | White,
            BrightYellow = Bright | Yellow,

            // By intention
            FileName = LightGrey,
            Warning = BrightYellow,
            ResultError = BrightRed,
            ResultSuccess = BrightGreen,
            ResultExpectedFailure = Warning,

            Error = BrightRed,
            Success = Green,

            OriginalExpression = Cyan,
            ReconstructedExpression = BrightYellow,

            SecondaryText = LightGrey,
            Headers = White
        };

        // Use constructed object for RAII guard
        Colour( Code _colourCode );
        Colour( Colour&& other ) noexcept;
        Colour& operator=( Colour&& other ) noexcept;
        ~Colour();

        // Use static method for one-shot changes
        static void use( Code _colourCode );

    private:
        bool m_moved = false;
    };

    std::ostream& operator << ( std::ostream& os, Colour const& );

} // end namespace Catch

// end catch_console_colour.h
// start catch_reporter_registrars.hpp


namespace Catch {

    template<typename T>
    class ReporterRegistrar {

        class ReporterFactory : public IReporterFactory {

            IStreamingReporterPtr create( ReporterConfig const& config ) const override {
                return std::unique_ptr<T>( new T( config ) );
            }

            std::string getDescription() const override {
                return T::getDescription();
            }
        };

    public:

        explicit ReporterRegistrar( std::string const& name ) {
            getMutableRegistryHub().registerReporter( name, std::make_shared<ReporterFactory>() );
        }
    };

    template<typename T>
    class ListenerRegistrar {

        class ListenerFactory : public IReporterFactory {

            IStreamingReporterPtr create( ReporterConfig const& config ) const override {
                return std::unique_ptr<T>( new T( config ) );
            }
            std::string getDescription() const override {
                return std::string();
            }
        };

    public:

        ListenerRegistrar() {
            getMutableRegistryHub().registerListener( std::make_shared<ListenerFactory>() );
        }
    };
}

#if !defined(CATCH_CONFIG_DISABLE)

#define CATCH_REGISTER_REPORTER( name, reporterType ) \
    CATCH_INTERNAL_START_WARNINGS_SUPPRESSION         \
    CATCH_INTERNAL_SUPPRESS_GLOBALS_WARNINGS          \
    namespace{ Catch::ReporterRegistrar<reporterType> catch_internal_RegistrarFor##reporterType( name ); } \
    CATCH_INTERNAL_STOP_WARNINGS_SUPPRESSION

#define CATCH_REGISTER_LISTENER( listenerType ) \
    CATCH_INTERNAL_START_WARNINGS_SUPPRESSION   \
    CATCH_INTERNAL_SUPPRESS_GLOBALS_WARNINGS    \
    namespace{ Catch::ListenerRegistrar<listenerType> catch_internal_RegistrarFor##listenerType; } \
    CATCH_INTERNAL_STOP_WARNINGS_SUPPRESSION
#else // CATCH_CONFIG_DISABLE

#define CATCH_REGISTER_REPORTER(name, reporterType)
#define CATCH_REGISTER_LISTENER(listenerType)

#endif // CATCH_CONFIG_DISABLE

// end catch_reporter_registrars.hpp
// Allow users to base their work off existing reporters
// start catch_reporter_compact.h

namespace Catch {

    struct CompactReporter : StreamingReporterBase<CompactReporter> {

        using StreamingReporterBase::StreamingReporterBase;

        ~CompactReporter() override;

        static std::string getDescription();

        void noMatchingTestCases(std::string const& spec) override;

        void assertionStarting(AssertionInfo const&) override;

        bool assertionEnded(AssertionStats const& _assertionStats) override;

        void sectionEnded(SectionStats const& _sectionStats) override;

        void testRunEnded(TestRunStats const& _testRunStats) override;

    };

} // end namespace Catch

// end catch_reporter_compact.h
// start catch_reporter_console.h

#if defined(_MSC_VER)
#pragma warning(push)
#pragma warning(disable:4061) // Not all labels are EXPLICITLY handled in switch
                              // Note that 4062 (not all labels are handled
                              // and default is missing) is enabled
#endif

namespace Catch {
    // Fwd decls
    struct SummaryColumn;
    class TablePrinter;

    struct ConsoleReporter : StreamingReporterBase<ConsoleReporter> {
        std::unique_ptr<TablePrinter> m_tablePrinter;

        ConsoleReporter(ReporterConfig const& config);
        ~ConsoleReporter() override;
        static std::string getDescription();

        void noMatchingTestCases(std::string const& spec) override;

        void reportInvalidArguments(std::string const&arg) override;

        void assertionStarting(AssertionInfo const&) override;

        bool assertionEnded(AssertionStats const& _assertionStats) override;

        void sectionStarting(SectionInfo const& _sectionInfo) override;
        void sectionEnded(SectionStats const& _sectionStats) override;

#if defined(CATCH_CONFIG_ENABLE_BENCHMARKING)
        void benchmarkPreparing(std::string const& name) override;
        void benchmarkStarting(BenchmarkInfo const& info) override;
        void benchmarkEnded(BenchmarkStats<> const& stats) override;
        void benchmarkFailed(std::string const& error) override;
#endif // CATCH_CONFIG_ENABLE_BENCHMARKING

        void testCaseEnded(TestCaseStats const& _testCaseStats) override;
        void testGroupEnded(TestGroupStats const& _testGroupStats) override;
        void testRunEnded(TestRunStats const& _testRunStats) override;
        void testRunStarting(TestRunInfo const& _testRunInfo) override;
    private:

        void lazyPrint();

        void lazyPrintWithoutClosingBenchmarkTable();
        void lazyPrintRunInfo();
        void lazyPrintGroupInfo();
        void printTestCaseAndSectionHeader();

        void printClosedHeader(std::string const& _name);
        void printOpenHeader(std::string const& _name);

        // if string has a : in first line will set indent to follow it on
        // subsequent lines
        void printHeaderString(std::string const& _string, std::size_t indent = 0);

        void printTotals(Totals const& totals);
        void printSummaryRow(std::string const& label, std::vector<SummaryColumn> const& cols, std::size_t row);

        void printTotalsDivider(Totals const& totals);
        void printSummaryDivider();
        void printTestFilters();

    private:
        bool m_headerPrinted = false;
    };

} // end namespace Catch

#if defined(_MSC_VER)
#pragma warning(pop)
#endif

// end catch_reporter_console.h
// start catch_reporter_junit.h

// start catch_xmlwriter.h

#include <vector>

namespace Catch {
    enum class XmlFormatting {
        None = 0x00,
        Indent = 0x01,
        Newline = 0x02,
    };

    XmlFormatting operator | (XmlFormatting lhs, XmlFormatting rhs);
    XmlFormatting operator & (XmlFormatting lhs, XmlFormatting rhs);

    class XmlEncode {
    public:
        enum ForWhat { ForTextNodes, ForAttributes };

        XmlEncode( std::string const& str, ForWhat forWhat = ForTextNodes );

        void encodeTo( std::ostream& os ) const;

        friend std::ostream& operator << ( std::ostream& os, XmlEncode const& xmlEncode );

    private:
        std::string m_str;
        ForWhat m_forWhat;
    };

    class XmlWriter {
    public:

        class ScopedElement {
        public:
            ScopedElement( XmlWriter* writer, XmlFormatting fmt );

            ScopedElement( ScopedElement&& other ) noexcept;
            ScopedElement& operator=( ScopedElement&& other ) noexcept;

            ~ScopedElement();

            ScopedElement& writeText( std::string const& text, XmlFormatting fmt = XmlFormatting::Newline | XmlFormatting::Indent );

            template<typename T>
            ScopedElement& writeAttribute( std::string const& name, T const& attribute ) {
                m_writer->writeAttribute( name, attribute );
                return *this;
            }

        private:
            mutable XmlWriter* m_writer = nullptr;
            XmlFormatting m_fmt;
        };

        XmlWriter( std::ostream& os = Catch::cout() );
        ~XmlWriter();

        XmlWriter( XmlWriter const& ) = delete;
        XmlWriter& operator=( XmlWriter const& ) = delete;

        XmlWriter& startElement( std::string const& name, XmlFormatting fmt = XmlFormatting::Newline | XmlFormatting::Indent);

        ScopedElement scopedElement( std::string const& name, XmlFormatting fmt = XmlFormatting::Newline | XmlFormatting::Indent);

        XmlWriter& endElement(XmlFormatting fmt = XmlFormatting::Newline | XmlFormatting::Indent);

        XmlWriter& writeAttribute( std::string const& name, std::string const& attribute );

        XmlWriter& writeAttribute( std::string const& name, bool attribute );

        template<typename T>
        XmlWriter& writeAttribute( std::string const& name, T const& attribute ) {
            ReusableStringStream rss;
            rss << attribute;
            return writeAttribute( name, rss.str() );
        }

        XmlWriter& writeText( std::string const& text, XmlFormatting fmt = XmlFormatting::Newline | XmlFormatting::Indent);

        XmlWriter& writeComment(std::string const& text, XmlFormatting fmt = XmlFormatting::Newline | XmlFormatting::Indent);

        void writeStylesheetRef( std::string const& url );

        XmlWriter& writeBlankLine();

        void ensureTagClosed();

    private:

        void applyFormatting(XmlFormatting fmt);

        void writeDeclaration();

        void newlineIfNecessary();

        bool m_tagIsOpen = false;
        bool m_needsNewline = false;
        std::vector<std::string> m_tags;
        std::string m_indent;
        std::ostream& m_os;
    };

}

// end catch_xmlwriter.h
namespace Catch {

    class JunitReporter : public CumulativeReporterBase<JunitReporter> {
    public:
        JunitReporter(ReporterConfig const& _config);

        ~JunitReporter() override;

        static std::string getDescription();

        void noMatchingTestCases(std::string const& /*spec*/) override;

        void testRunStarting(TestRunInfo const& runInfo) override;

        void testGroupStarting(GroupInfo const& groupInfo) override;

        void testCaseStarting(TestCaseInfo const& testCaseInfo) override;
        bool assertionEnded(AssertionStats const& assertionStats) override;

        void testCaseEnded(TestCaseStats const& testCaseStats) override;

        void testGroupEnded(TestGroupStats const& testGroupStats) override;

        void testRunEndedCumulative() override;

        void writeGroup(TestGroupNode const& groupNode, double suiteTime);

        void writeTestCase(TestCaseNode const& testCaseNode);

        void writeSection(std::string const& className,
                          std::string const& rootName,
                          SectionNode const& sectionNode);

        void writeAssertions(SectionNode const& sectionNode);
        void writeAssertion(AssertionStats const& stats);

        XmlWriter xml;
        Timer suiteTimer;
        std::string stdOutForSuite;
        std::string stdErrForSuite;
        unsigned int unexpectedExceptions = 0;
        bool m_okToFail = false;
    };

} // end namespace Catch

// end catch_reporter_junit.h
// start catch_reporter_xml.h

namespace Catch {
    class XmlReporter : public StreamingReporterBase<XmlReporter> {
    public:
        XmlReporter(ReporterConfig const& _config);

        ~XmlReporter() override;

        static std::string getDescription();

        virtual std::string getStylesheetRef() const;

        void writeSourceInfo(SourceLineInfo const& sourceInfo);

    public: // StreamingReporterBase

        void noMatchingTestCases(std::string const& s) override;

        void testRunStarting(TestRunInfo const& testInfo) override;

        void testGroupStarting(GroupInfo const& groupInfo) override;

        void testCaseStarting(TestCaseInfo const& testInfo) override;

        void sectionStarting(SectionInfo const& sectionInfo) override;

        void assertionStarting(AssertionInfo const&) override;

        bool assertionEnded(AssertionStats const& assertionStats) override;

        void sectionEnded(SectionStats const& sectionStats) override;

        void testCaseEnded(TestCaseStats const& testCaseStats) override;

        void testGroupEnded(TestGroupStats const& testGroupStats) override;

        void testRunEnded(TestRunStats const& testRunStats) override;

#if defined(CATCH_CONFIG_ENABLE_BENCHMARKING)
        void benchmarkPreparing(std::string const& name) override;
        void benchmarkStarting(BenchmarkInfo const&) override;
        void benchmarkEnded(BenchmarkStats<> const&) override;
        void benchmarkFailed(std::string const&) override;
#endif // CATCH_CONFIG_ENABLE_BENCHMARKING

    private:
        Timer m_testCaseTimer;
        XmlWriter m_xml;
        int m_sectionDepth = 0;
    };

} // end namespace Catch

// end catch_reporter_xml.h

// end catch_external_interfaces.h
#endif

#if defined(CATCH_CONFIG_ENABLE_BENCHMARKING)
// start catch_benchmarking_all.hpp

// A proxy header that includes all of the benchmarking headers to allow
// concise include of the benchmarking features. You should prefer the
// individual includes in standard use.

// start catch_benchmark.hpp

 // Benchmark

// start catch_chronometer.hpp

// User-facing chronometer


// start catch_clock.hpp

// Clocks


#include <chrono>
#include <ratio>

namespace Catch {
    namespace Benchmark {
        template <typename Clock>
        using ClockDuration = typename Clock::duration;
        template <typename Clock>
        using FloatDuration = std::chrono::duration<double, typename Clock::period>;

        template <typename Clock>
        using TimePoint = typename Clock::time_point;

        using default_clock = std::chrono::steady_clock;

        template <typename Clock>
        struct now {
            TimePoint<Clock> operator()() const {
                return Clock::now();
            }
        };

        using fp_seconds = std::chrono::duration<double, std::ratio<1>>;
    } // namespace Benchmark
} // namespace Catch

// end catch_clock.hpp
// start catch_optimizer.hpp

 // Hinting the optimizer


#if defined(_MSC_VER)
#   include <atomic> // atomic_thread_fence
#endif

namespace Catch {
    namespace Benchmark {
#if defined(__GNUC__) || defined(__clang__)
        template <typename T>
        inline void keep_memory(T* p) {
            asm volatile("" : : "g"(p) : "memory");
        }
        inline void keep_memory() {
            asm volatile("" : : : "memory");
        }

        namespace Detail {
            inline void optimizer_barrier() { keep_memory(); }
        } // namespace Detail
#elif defined(_MSC_VER)

#pragma optimize("", off)
        template <typename T>
        inline void keep_memory(T* p) {
            // thanks @milleniumbug
            *reinterpret_cast<char volatile*>(p) = *reinterpret_cast<char const volatile*>(p);
        }
        // TODO equivalent keep_memory()
#pragma optimize("", on)

        namespace Detail {
            inline void optimizer_barrier() {
                std::atomic_thread_fence(std::memory_order_seq_cst);
            }
        } // namespace Detail

#endif

        template <typename T>
        inline void deoptimize_value(T&& x) {
            keep_memory(&x);
        }

        template <typename Fn, typename... Args>
        inline auto invoke_deoptimized(Fn&& fn, Args&&... args) -> typename std::enable_if<!std::is_same<void, decltype(fn(args...))>::value>::type {
            deoptimize_value(std::forward<Fn>(fn) (std::forward<Args...>(args...)));
        }

        template <typename Fn, typename... Args>
        inline auto invoke_deoptimized(Fn&& fn, Args&&... args) -> typename std::enable_if<std::is_same<void, decltype(fn(args...))>::value>::type {
            std::forward<Fn>(fn) (std::forward<Args...>(args...));
        }
    } // namespace Benchmark
} // namespace Catch

// end catch_optimizer.hpp
// start catch_complete_invoke.hpp

// Invoke with a special case for void


#include <type_traits>
#include <utility>

namespace Catch {
    namespace Benchmark {
        namespace Detail {
            template <typename T>
            struct CompleteType { using type = T; };
            template <>
            struct CompleteType<void> { struct type {}; };

            template <typename T>
            using CompleteType_t = typename CompleteType<T>::type;

            template <typename Result>
            struct CompleteInvoker {
                template <typename Fun, typename... Args>
                static Result invoke(Fun&& fun, Args&&... args) {
                    return std::forward<Fun>(fun)(std::forward<Args>(args)...);
                }
            };
            template <>
            struct CompleteInvoker<void> {
                template <typename Fun, typename... Args>
                static CompleteType_t<void> invoke(Fun&& fun, Args&&... args) {
                    std::forward<Fun>(fun)(std::forward<Args>(args)...);
                    return {};
                }
            };

            // invoke and not return void :(
            template <typename Fun, typename... Args>
            CompleteType_t<FunctionReturnType<Fun, Args...>> complete_invoke(Fun&& fun, Args&&... args) {
                return CompleteInvoker<FunctionReturnType<Fun, Args...>>::invoke(std::forward<Fun>(fun), std::forward<Args>(args)...);
            }

            const std::string benchmarkErrorMsg = "a benchmark failed to run successfully";
        } // namespace Detail

        template <typename Fun>
        Detail::CompleteType_t<FunctionReturnType<Fun>> user_code(Fun&& fun) {
            CATCH_TRY{
                return Detail::complete_invoke(std::forward<Fun>(fun));
            } CATCH_CATCH_ALL{
                getResultCapture().benchmarkFailed(translateActiveException());
                CATCH_RUNTIME_ERROR(Detail::benchmarkErrorMsg);
            }
        }
    } // namespace Benchmark
} // namespace Catch

// end catch_complete_invoke.hpp
namespace Catch {
    namespace Benchmark {
        namespace Detail {
            struct ChronometerConcept {
                virtual void start() = 0;
                virtual void finish() = 0;
                virtual ~ChronometerConcept() = default;
            };
            template <typename Clock>
            struct ChronometerModel final : public ChronometerConcept {
                void start() override { started = Clock::now(); }
                void finish() override { finished = Clock::now(); }

                ClockDuration<Clock> elapsed() const { return finished - started; }

                TimePoint<Clock> started;
                TimePoint<Clock> finished;
            };
        } // namespace Detail

        struct Chronometer {
        public:
            template <typename Fun>
            void measure(Fun&& fun) { measure(std::forward<Fun>(fun), is_callable<Fun(int)>()); }

            int runs() const { return k; }

            Chronometer(Detail::ChronometerConcept& meter, int k)
                : impl(&meter)
                , k(k) {}

        private:
            template <typename Fun>
            void measure(Fun&& fun, std::false_type) {
                measure([&fun](int) { return fun(); }, std::true_type());
            }

            template <typename Fun>
            void measure(Fun&& fun, std::true_type) {
                Detail::optimizer_barrier();
                impl->start();
                for (int i = 0; i < k; ++i) invoke_deoptimized(fun, i);
                impl->finish();
                Detail::optimizer_barrier();
            }

            Detail::ChronometerConcept* impl;
            int k;
        };
    } // namespace Benchmark
} // namespace Catch

// end catch_chronometer.hpp
// start catch_environment.hpp

// Environment information


namespace Catch {
    namespace Benchmark {
        template <typename Duration>
        struct EnvironmentEstimate {
            Duration mean;
            OutlierClassification outliers;

            template <typename Duration2>
            operator EnvironmentEstimate<Duration2>() const {
                return { mean, outliers };
            }
        };
        template <typename Clock>
        struct Environment {
            using clock_type = Clock;
            EnvironmentEstimate<FloatDuration<Clock>> clock_resolution;
            EnvironmentEstimate<FloatDuration<Clock>> clock_cost;
        };
    } // namespace Benchmark
} // namespace Catch

// end catch_environment.hpp
// start catch_execution_plan.hpp

 // Execution plan


// start catch_benchmark_function.hpp

 // Dumb std::function implementation for consistent call overhead


#include <cassert>
#include <type_traits>
#include <utility>
#include <memory>

namespace Catch {
    namespace Benchmark {
        namespace Detail {
            template <typename T>
            using Decay = typename std::decay<T>::type;
            template <typename T, typename U>
            struct is_related
                : std::is_same<Decay<T>, Decay<U>> {};

            /// We need to reinvent std::function because every piece of code that might add overhead
            /// in a measurement context needs to have consistent performance characteristics so that we
            /// can account for it in the measurement.
            /// Implementations of std::function with optimizations that aren't always applicable, like
            /// small buffer optimizations, are not uncommon.
            /// This is effectively an implementation of std::function without any such optimizations;
            /// it may be slow, but it is consistently slow.
            struct BenchmarkFunction {
            private:
                struct callable {
                    virtual void call(Chronometer meter) const = 0;
                    virtual callable* clone() const = 0;
                    virtual ~callable() = default;
                };
                template <typename Fun>
                struct model : public callable {
                    model(Fun&& fun) : fun(std::move(fun)) {}
                    model(Fun const& fun) : fun(fun) {}

                    model<Fun>* clone() const override { return new model<Fun>(*this); }

                    void call(Chronometer meter) const override {
                        call(meter, is_callable<Fun(Chronometer)>());
                    }
                    void call(Chronometer meter, std::true_type) const {
                        fun(meter);
                    }
                    void call(Chronometer meter, std::false_type) const {
                        meter.measure(fun);
                    }

                    Fun fun;
                };

                struct do_nothing { void operator()() const {} };

                template <typename T>
                BenchmarkFunction(model<T>* c) : f(c) {}

            public:
                BenchmarkFunction()
                    : f(new model<do_nothing>{ {} }) {}

                template <typename Fun,
                    typename std::enable_if<!is_related<Fun, BenchmarkFunction>::value, int>::type = 0>
                    BenchmarkFunction(Fun&& fun)
                    : f(new model<typename std::decay<Fun>::type>(std::forward<Fun>(fun))) {}

                BenchmarkFunction(BenchmarkFunction&& that)
                    : f(std::move(that.f)) {}

                BenchmarkFunction(BenchmarkFunction const& that)
                    : f(that.f->clone()) {}

                BenchmarkFunction& operator=(BenchmarkFunction&& that) {
                    f = std::move(that.f);
                    return *this;
                }

                BenchmarkFunction& operator=(BenchmarkFunction const& that) {
                    f.reset(that.f->clone());
                    return *this;
                }

                void operator()(Chronometer meter) const { f->call(meter); }

            private:
                std::unique_ptr<callable> f;
            };
        } // namespace Detail
    } // namespace Benchmark
} // namespace Catch

// end catch_benchmark_function.hpp
// start catch_repeat.hpp

// repeat algorithm


#include <type_traits>
#include <utility>

namespace Catch {
    namespace Benchmark {
        namespace Detail {
            template <typename Fun>
            struct repeater {
                void operator()(int k) const {
                    for (int i = 0; i < k; ++i) {
                        fun();
                    }
                }
                Fun fun;
            };
            template <typename Fun>
            repeater<typename std::decay<Fun>::type> repeat(Fun&& fun) {
                return { std::forward<Fun>(fun) };
            }
        } // namespace Detail
    } // namespace Benchmark
} // namespace Catch

// end catch_repeat.hpp
// start catch_run_for_at_least.hpp

// Run a function for a minimum amount of time


// start catch_measure.hpp

// Measure


// start catch_timing.hpp

// Timing


#include <tuple>
#include <type_traits>

namespace Catch {
    namespace Benchmark {
        template <typename Duration, typename Result>
        struct Timing {
            Duration elapsed;
            Result result;
            int iterations;
        };
        template <typename Clock, typename Func, typename... Args>
        using TimingOf = Timing<ClockDuration<Clock>, Detail::CompleteType_t<FunctionReturnType<Func, Args...>>>;
    } // namespace Benchmark
} // namespace Catch

// end catch_timing.hpp
#include <utility>

namespace Catch {
    namespace Benchmark {
        namespace Detail {
            template <typename Clock, typename Fun, typename... Args>
            TimingOf<Clock, Fun, Args...> measure(Fun&& fun, Args&&... args) {
                auto start = Clock::now();
                auto&& r = Detail::complete_invoke(fun, std::forward<Args>(args)...);
                auto end = Clock::now();
                auto delta = end - start;
                return { delta, std::forward<decltype(r)>(r), 1 };
            }
        } // namespace Detail
    } // namespace Benchmark
} // namespace Catch

// end catch_measure.hpp
#include <utility>
#include <type_traits>

namespace Catch {
    namespace Benchmark {
        namespace Detail {
            template <typename Clock, typename Fun>
            TimingOf<Clock, Fun, int> measure_one(Fun&& fun, int iters, std::false_type) {
                return Detail::measure<Clock>(fun, iters);
            }
            template <typename Clock, typename Fun>
            TimingOf<Clock, Fun, Chronometer> measure_one(Fun&& fun, int iters, std::true_type) {
                Detail::ChronometerModel<Clock> meter;
                auto&& result = Detail::complete_invoke(fun, Chronometer(meter, iters));

                return { meter.elapsed(), std::move(result), iters };
            }

            template <typename Clock, typename Fun>
            using run_for_at_least_argument_t = typename std::conditional<is_callable<Fun(Chronometer)>::value, Chronometer, int>::type;

            struct optimized_away_error : std::exception {
                const char* what() const noexcept override {
                    return "could not measure benchmark, maybe it was optimized away";
                }
            };

            template <typename Clock, typename Fun>
            TimingOf<Clock, Fun, run_for_at_least_argument_t<Clock, Fun>> run_for_at_least(ClockDuration<Clock> how_long, int seed, Fun&& fun) {
                auto iters = seed;
                while (iters < (1 << 30)) {
                    auto&& Timing = measure_one<Clock>(fun, iters, is_callable<Fun(Chronometer)>());

                    if (Timing.elapsed >= how_long) {
                        return { Timing.elapsed, std::move(Timing.result), iters };
                    }
                    iters *= 2;
                }
                throw optimized_away_error{};
            }
        } // namespace Detail
    } // namespace Benchmark
} // namespace Catch

// end catch_run_for_at_least.hpp
#include <algorithm>

namespace Catch {
    namespace Benchmark {
        template <typename Duration>
        struct ExecutionPlan {
            int iterations_per_sample;
            Duration estimated_duration;
            Detail::BenchmarkFunction benchmark;
            Duration warmup_time;
            int warmup_iterations;

            template <typename Duration2>
            operator ExecutionPlan<Duration2>() const {
                return { iterations_per_sample, estimated_duration, benchmark, warmup_time, warmup_iterations };
            }

            template <typename Clock>
            std::vector<FloatDuration<Clock>> run(const IConfig &cfg, Environment<FloatDuration<Clock>> env) const {
                // warmup a bit
                Detail::run_for_at_least<Clock>(std::chrono::duration_cast<ClockDuration<Clock>>(warmup_time), warmup_iterations, Detail::repeat(now<Clock>{}));

                std::vector<FloatDuration<Clock>> times;
                times.reserve(cfg.benchmarkSamples());
                std::generate_n(std::back_inserter(times), cfg.benchmarkSamples(), [this, env] {
                    Detail::ChronometerModel<Clock> model;
                    this->benchmark(Chronometer(model, iterations_per_sample));
                    auto sample_time = model.elapsed() - env.clock_cost.mean;
                    if (sample_time < FloatDuration<Clock>::zero()) sample_time = FloatDuration<Clock>::zero();
                    return sample_time / iterations_per_sample;
                });
                return times;
            }
        };
    } // namespace Benchmark
} // namespace Catch

// end catch_execution_plan.hpp
// start catch_estimate_clock.hpp

 // Environment measurement


// start catch_stats.hpp

// Statistical analysis tools


#include <algorithm>
#include <functional>
#include <vector>
#include <iterator>
#include <numeric>
#include <tuple>
#include <cmath>
#include <utility>
#include <cstddef>
#include <random>

namespace Catch {
    namespace Benchmark {
        namespace Detail {
            using sample = std::vector<double>;

            double weighted_average_quantile(int k, int q, std::vector<double>::iterator first, std::vector<double>::iterator last);

            template <typename Iterator>
            OutlierClassification classify_outliers(Iterator first, Iterator last) {
                std::vector<double> copy(first, last);

                auto q1 = weighted_average_quantile(1, 4, copy.begin(), copy.end());
                auto q3 = weighted_average_quantile(3, 4, copy.begin(), copy.end());
                auto iqr = q3 - q1;
                auto los = q1 - (iqr * 3.);
                auto lom = q1 - (iqr * 1.5);
                auto him = q3 + (iqr * 1.5);
                auto his = q3 + (iqr * 3.);

                OutlierClassification o;
                for (; first != last; ++first) {
                    auto&& t = *first;
                    if (t < los) ++o.low_severe;
                    else if (t < lom) ++o.low_mild;
                    else if (t > his) ++o.high_severe;
                    else if (t > him) ++o.high_mild;
                    ++o.samples_seen;
                }
                return o;
            }

            template <typename Iterator>
            double mean(Iterator first, Iterator last) {
                auto count = last - first;
                double sum = std::accumulate(first, last, 0.);
                return sum / count;
            }

            template <typename URng, typename Iterator, typename Estimator>
            sample resample(URng& rng, int resamples, Iterator first, Iterator last, Estimator& estimator) {
                auto n = last - first;
                std::uniform_int_distribution<decltype(n)> dist(0, n - 1);

                sample out;
                out.reserve(resamples);
                std::generate_n(std::back_inserter(out), resamples, [n, first, &estimator, &dist, &rng] {
                    std::vector<double> resampled;
                    resampled.reserve(n);
                    std::generate_n(std::back_inserter(resampled), n, [first, &dist, &rng] { return first[dist(rng)]; });
                    return estimator(resampled.begin(), resampled.end());
                });
                std::sort(out.begin(), out.end());
                return out;
            }

            template <typename Estimator, typename Iterator>
            sample jackknife(Estimator&& estimator, Iterator first, Iterator last) {
                auto n = last - first;
                auto second = std::next(first);
                sample results;
                results.reserve(n);

                for (auto it = first; it != last; ++it) {
                    std::iter_swap(it, first);
                    results.push_back(estimator(second, last));
                }

                return results;
            }

            inline double normal_cdf(double x) {
                return std::erfc(-x / std::sqrt(2.0)) / 2.0;
            }

            double erfc_inv(double x);

            double normal_quantile(double p);

            template <typename Iterator, typename Estimator>
            Estimate<double> bootstrap(double confidence_level, Iterator first, Iterator last, sample const& resample, Estimator&& estimator) {
                auto n_samples = last - first;

                double point = estimator(first, last);
                // Degenerate case with a single sample
                if (n_samples == 1) return { point, point, point, confidence_level };

                sample jack = jackknife(estimator, first, last);
                double jack_mean = mean(jack.begin(), jack.end());
                double sum_squares, sum_cubes;
                std::tie(sum_squares, sum_cubes) = std::accumulate(jack.begin(), jack.end(), std::make_pair(0., 0.), [jack_mean](std::pair<double, double> sqcb, double x) -> std::pair<double, double> {
                    auto d = jack_mean - x;
                    auto d2 = d * d;
                    auto d3 = d2 * d;
                    return { sqcb.first + d2, sqcb.second + d3 };
                });

                double accel = sum_cubes / (6 * std::pow(sum_squares, 1.5));
                int n = static_cast<int>(resample.size());
                double prob_n = std::count_if(resample.begin(), resample.end(), [point](double x) { return x < point; }) / (double)n;
                // degenerate case with uniform samples
                if (prob_n == 0) return { point, point, point, confidence_level };

                double bias = normal_quantile(prob_n);
                double z1 = normal_quantile((1. - confidence_level) / 2.);

                auto cumn = [n](double x) -> int {
                    return std::lround(normal_cdf(x) * n); };
                auto a = [bias, accel](double b) { return bias + b / (1. - accel * b); };
                double b1 = bias + z1;
                double b2 = bias - z1;
                double a1 = a(b1);
                double a2 = a(b2);
                auto lo = std::max(cumn(a1), 0);
                auto hi = std::min(cumn(a2), n - 1);

                return { point, resample[lo], resample[hi], confidence_level };
            }

            double outlier_variance(Estimate<double> mean, Estimate<double> stddev, int n);

            struct bootstrap_analysis {
                Estimate<double> mean;
                Estimate<double> standard_deviation;
                double outlier_variance;
            };

            bootstrap_analysis analyse_samples(double confidence_level, int n_resamples, std::vector<double>::iterator first, std::vector<double>::iterator last);
        } // namespace Detail
    } // namespace Benchmark
} // namespace Catch

// end catch_stats.hpp
#include <algorithm>
#include <iterator>
#include <tuple>
#include <vector>
#include <cmath>

namespace Catch {
    namespace Benchmark {
        namespace Detail {
            template <typename Clock>
            std::vector<double> resolution(int k) {
                std::vector<TimePoint<Clock>> times;
                times.reserve(k + 1);
                std::generate_n(std::back_inserter(times), k + 1, now<Clock>{});

                std::vector<double> deltas;
                deltas.reserve(k);
                std::transform(std::next(times.begin()), times.end(), times.begin(),
                    std::back_inserter(deltas),
                    [](TimePoint<Clock> a, TimePoint<Clock> b) { return static_cast<double>((a - b).count()); });

                return deltas;
            }

            const auto warmup_iterations = 10000;
            const auto warmup_time = std::chrono::milliseconds(100);
            const auto minimum_ticks = 1000;
            const auto warmup_seed = 10000;
            const auto clock_resolution_estimation_time = std::chrono::milliseconds(500);
            const auto clock_cost_estimation_time_limit = std::chrono::seconds(1);
            const auto clock_cost_estimation_tick_limit = 100000;
            const auto clock_cost_estimation_time = std::chrono::milliseconds(10);
            const auto clock_cost_estimation_iterations = 10000;

            template <typename Clock>
            int warmup() {
                return run_for_at_least<Clock>(std::chrono::duration_cast<ClockDuration<Clock>>(warmup_time), warmup_seed, &resolution<Clock>)
                    .iterations;
            }
            template <typename Clock>
            EnvironmentEstimate<FloatDuration<Clock>> estimate_clock_resolution(int iterations) {
                auto r = run_for_at_least<Clock>(std::chrono::duration_cast<ClockDuration<Clock>>(clock_resolution_estimation_time), iterations, &resolution<Clock>)
                    .result;
                return {
                    FloatDuration<Clock>(mean(r.begin(), r.end())),
                    classify_outliers(r.begin(), r.end()),
                };
            }
            template <typename Clock>
            EnvironmentEstimate<FloatDuration<Clock>> estimate_clock_cost(FloatDuration<Clock> resolution) {
                auto time_limit = std::min(resolution * clock_cost_estimation_tick_limit, FloatDuration<Clock>(clock_cost_estimation_time_limit));
                auto time_clock = [](int k) {
                    return Detail::measure<Clock>([k] {
                        for (int i = 0; i < k; ++i) {
                            volatile auto ignored = Clock::now();
                            (void)ignored;
                        }
                    }).elapsed;
                };
                time_clock(1);
                int iters = clock_cost_estimation_iterations;
                auto&& r = run_for_at_least<Clock>(std::chrono::duration_cast<ClockDuration<Clock>>(clock_cost_estimation_time), iters, time_clock);
                std::vector<double> times;
                int nsamples = static_cast<int>(std::ceil(time_limit / r.elapsed));
                times.reserve(nsamples);
                std::generate_n(std::back_inserter(times), nsamples, [time_clock, &r] {
                    return static_cast<double>((time_clock(r.iterations) / r.iterations).count());
                });
                return {
                    FloatDuration<Clock>(mean(times.begin(), times.end())),
                    classify_outliers(times.begin(), times.end()),
                };
            }

            template <typename Clock>
            Environment<FloatDuration<Clock>> measure_environment() {
                static Environment<FloatDuration<Clock>>* env = nullptr;
                if (env) {
                    return *env;
                }

                auto iters = Detail::warmup<Clock>();
                auto resolution = Detail::estimate_clock_resolution<Clock>(iters);
                auto cost = Detail::estimate_clock_cost<Clock>(resolution.mean);

                env = new Environment<FloatDuration<Clock>>{ resolution, cost };
                return *env;
            }
        } // namespace Detail
    } // namespace Benchmark
} // namespace Catch

// end catch_estimate_clock.hpp
// start catch_analyse.hpp

 // Run and analyse one benchmark


// start catch_sample_analysis.hpp

// Benchmark results


#include <algorithm>
#include <vector>
#include <string>
#include <iterator>

namespace Catch {
    namespace Benchmark {
        template <typename Duration>
        struct SampleAnalysis {
            std::vector<Duration> samples;
            Estimate<Duration> mean;
            Estimate<Duration> standard_deviation;
            OutlierClassification outliers;
            double outlier_variance;

            template <typename Duration2>
            operator SampleAnalysis<Duration2>() const {
                std::vector<Duration2> samples2;
                samples2.reserve(samples.size());
                std::transform(samples.begin(), samples.end(), std::back_inserter(samples2), [](Duration d) { return Duration2(d); });
                return {
                    std::move(samples2),
                    mean,
                    standard_deviation,
                    outliers,
                    outlier_variance,
                };
            }
        };
    } // namespace Benchmark
} // namespace Catch

// end catch_sample_analysis.hpp
#include <algorithm>
#include <iterator>
#include <vector>

namespace Catch {
    namespace Benchmark {
        namespace Detail {
            template <typename Duration, typename Iterator>
            SampleAnalysis<Duration> analyse(const IConfig &cfg, Environment<Duration>, Iterator first, Iterator last) {
                if (!cfg.benchmarkNoAnalysis()) {
                    std::vector<double> samples;
                    samples.reserve(last - first);
                    std::transform(first, last, std::back_inserter(samples), [](Duration d) { return d.count(); });

                    auto analysis = Catch::Benchmark::Detail::analyse_samples(cfg.benchmarkConfidenceInterval(), cfg.benchmarkResamples(), samples.begin(), samples.end());
                    auto outliers = Catch::Benchmark::Detail::classify_outliers(samples.begin(), samples.end());

                    auto wrap_estimate = [](Estimate<double> e) {
                        return Estimate<Duration> {
                            Duration(e.point),
                                Duration(e.lower_bound),
                                Duration(e.upper_bound),
                                e.confidence_interval,
                        };
                    };
                    std::vector<Duration> samples2;
                    samples2.reserve(samples.size());
                    std::transform(samples.begin(), samples.end(), std::back_inserter(samples2), [](double d) { return Duration(d); });
                    return {
                        std::move(samples2),
                        wrap_estimate(analysis.mean),
                        wrap_estimate(analysis.standard_deviation),
                        outliers,
                        analysis.outlier_variance,
                    };
                } else {
                    std::vector<Duration> samples;
                    samples.reserve(last - first);

                    Duration mean = Duration(0);
                    int i = 0;
                    for (auto it = first; it < last; ++it, ++i) {
                        samples.push_back(Duration(*it));
                        mean += Duration(*it);
                    }
                    mean /= i;

                    return {
                        std::move(samples),
                        Estimate<Duration>{mean, mean, mean, 0.0},
                        Estimate<Duration>{Duration(0), Duration(0), Duration(0), 0.0},
                        OutlierClassification{},
                        0.0
                    };
                }
            }
        } // namespace Detail
    } // namespace Benchmark
} // namespace Catch

// end catch_analyse.hpp
#include <algorithm>
#include <functional>
#include <string>
#include <vector>
#include <cmath>

namespace Catch {
    namespace Benchmark {
        struct Benchmark {
            Benchmark(std::string &&name)
                : name(std::move(name)) {}

            template <class FUN>
            Benchmark(std::string &&name, FUN &&func)
                : fun(std::move(func)), name(std::move(name)) {}

            template <typename Clock>
            ExecutionPlan<FloatDuration<Clock>> prepare(const IConfig &cfg, Environment<FloatDuration<Clock>> env) const {
                auto min_time = env.clock_resolution.mean * Detail::minimum_ticks;
                auto run_time = std::max(min_time, std::chrono::duration_cast<decltype(min_time)>(cfg.benchmarkWarmupTime()));
                auto&& test = Detail::run_for_at_least<Clock>(std::chrono::duration_cast<ClockDuration<Clock>>(run_time), 1, fun);
                int new_iters = static_cast<int>(std::ceil(min_time * test.iterations / test.elapsed));
                return { new_iters, test.elapsed / test.iterations * new_iters * cfg.benchmarkSamples(), fun, std::chrono::duration_cast<FloatDuration<Clock>>(cfg.benchmarkWarmupTime()), Detail::warmup_iterations };
            }

            template <typename Clock = default_clock>
            void run() {
                IConfigPtr cfg = getCurrentContext().getConfig();

                auto env = Detail::measure_environment<Clock>();

                getResultCapture().benchmarkPreparing(name);
                CATCH_TRY{
                    auto plan = user_code([&] {
                        return prepare<Clock>(*cfg, env);
                    });

                    BenchmarkInfo info {
                        name,
                        plan.estimated_duration.count(),
                        plan.iterations_per_sample,
                        cfg->benchmarkSamples(),
                        cfg->benchmarkResamples(),
                        env.clock_resolution.mean.count(),
                        env.clock_cost.mean.count()
                    };

                    getResultCapture().benchmarkStarting(info);

                    auto samples = user_code([&] {
                        return plan.template run<Clock>(*cfg, env);
                    });

                    auto analysis = Detail::analyse(*cfg, env, samples.begin(), samples.end());
                    BenchmarkStats<FloatDuration<Clock>> stats{ info, analysis.samples, analysis.mean, analysis.standard_deviation, analysis.outliers, analysis.outlier_variance };
                    getResultCapture().benchmarkEnded(stats);

                } CATCH_CATCH_ALL{
                    if (translateActiveException() != Detail::benchmarkErrorMsg) // benchmark errors have been reported, otherwise rethrow.
                        std::rethrow_exception(std::current_exception());
                }
            }

            // sets lambda to be used in fun *and* executes benchmark!
            template <typename Fun,
                typename std::enable_if<!Detail::is_related<Fun, Benchmark>::value, int>::type = 0>
                Benchmark & operator=(Fun func) {
                fun = Detail::BenchmarkFunction(func);
                run();
                return *this;
            }

            explicit operator bool() {
                return true;
            }

        private:
            Detail::BenchmarkFunction fun;
            std::string name;
        };
    }
} // namespace Catch

#define INTERNAL_CATCH_GET_1_ARG(arg1, arg2, ...) arg1
#define INTERNAL_CATCH_GET_2_ARG(arg1, arg2, ...) arg2

#define INTERNAL_CATCH_BENCHMARK(BenchmarkName, name, benchmarkIndex)\
    if( Catch::Benchmark::Benchmark BenchmarkName{name} ) \
        BenchmarkName = [&](int benchmarkIndex)

#define INTERNAL_CATCH_BENCHMARK_ADVANCED(BenchmarkName, name)\
    if( Catch::Benchmark::Benchmark BenchmarkName{name} ) \
        BenchmarkName = [&]

// end catch_benchmark.hpp
// start catch_constructor.hpp

// Constructor and destructor helpers


#include <type_traits>

namespace Catch {
    namespace Benchmark {
        namespace Detail {
            template <typename T, bool Destruct>
            struct ObjectStorage
            {
                using TStorage = typename std::aligned_storage<sizeof(T), std::alignment_of<T>::value>::type;

                ObjectStorage() : data() {}

                ObjectStorage(const ObjectStorage& other)
                {
                    new(&data) T(other.stored_object());
                }

                ObjectStorage(ObjectStorage&& other)
                {
                    new(&data) T(std::move(other.stored_object()));
                }

                ~ObjectStorage() { destruct_on_exit<T>(); }

                template <typename... Args>
                void construct(Args&&... args)
                {
                    new (&data) T(std::forward<Args>(args)...);
                }

                template <bool AllowManualDestruction = !Destruct>
                typename std::enable_if<AllowManualDestruction>::type destruct()
                {
                    stored_object().~T();
                }

            private:
                // If this is a constructor benchmark, destruct the underlying object
                template <typename U>
                void destruct_on_exit(typename std::enable_if<Destruct, U>::type* = 0) { destruct<true>(); }
                // Otherwise, don't
                template <typename U>
                void destruct_on_exit(typename std::enable_if<!Destruct, U>::type* = 0) { }

                T& stored_object() {
                    return *static_cast<T*>(static_cast<void*>(&data));
                }

                T const& stored_object() const {
                    return *static_cast<T*>(static_cast<void*>(&data));
                }

                TStorage data;
            };
        }

        template <typename T>
        using storage_for = Detail::ObjectStorage<T, true>;

        template <typename T>
        using destructable_object = Detail::ObjectStorage<T, false>;
    }
}

// end catch_constructor.hpp
// end catch_benchmarking_all.hpp
#endif

#endif // ! CATCH_CONFIG_IMPL_ONLY

#ifdef CATCH_IMPL
// start catch_impl.hpp

#ifdef __clang__
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wweak-vtables"
#endif

// Keep these here for external reporters
// start catch_test_case_tracker.h

#include <string>
#include <vector>
#include <memory>

namespace Catch {
namespace TestCaseTracking {

    struct NameAndLocation {
        std::string name;
        SourceLineInfo location;

        NameAndLocation( std::string const& _name, SourceLineInfo const& _location );
        friend bool operator==(NameAndLocation const& lhs, NameAndLocation const& rhs) {
            return lhs.name == rhs.name
                && lhs.location == rhs.location;
        }
    };

    class ITracker;

    using ITrackerPtr = std::shared_ptr<ITracker>;

    class  ITracker {
        NameAndLocation m_nameAndLocation;

    public:
        ITracker(NameAndLocation const& nameAndLoc) :
            m_nameAndLocation(nameAndLoc)
        {}

        // static queries
        NameAndLocation const& nameAndLocation() const {
            return m_nameAndLocation;
        }

        virtual ~ITracker();

        // dynamic queries
        virtual bool isComplete() const = 0; // Successfully completed or failed
        virtual bool isSuccessfullyCompleted() const = 0;
        virtual bool isOpen() const = 0; // Started but not complete
        virtual bool hasChildren() const = 0;
        virtual bool hasStarted() const = 0;

        virtual ITracker& parent() = 0;

        // actions
        virtual void close() = 0; // Successfully complete
        virtual void fail() = 0;
        virtual void markAsNeedingAnotherRun() = 0;

        virtual void addChild( ITrackerPtr const& child ) = 0;
        virtual ITrackerPtr findChild( NameAndLocation const& nameAndLocation ) = 0;
        virtual void openChild() = 0;

        // Debug/ checking
        virtual bool isSectionTracker() const = 0;
        virtual bool isGeneratorTracker() const = 0;
    };

    class TrackerContext {

        enum RunState {
            NotStarted,
            Executing,
            CompletedCycle
        };

        ITrackerPtr m_rootTracker;
        ITracker* m_currentTracker = nullptr;
        RunState m_runState = NotStarted;

    public:

        ITracker& startRun();
        void endRun();

        void startCycle();
        void completeCycle();

        bool completedCycle() const;
        ITracker& currentTracker();
        void setCurrentTracker( ITracker* tracker );
    };

    class TrackerBase : public ITracker {
    protected:
        enum CycleState {
            NotStarted,
            Executing,
            ExecutingChildren,
            NeedsAnotherRun,
            CompletedSuccessfully,
            Failed
        };

        using Children = std::vector<ITrackerPtr>;
        TrackerContext& m_ctx;
        ITracker* m_parent;
        Children m_children;
        CycleState m_runState = NotStarted;

    public:
        TrackerBase( NameAndLocation const& nameAndLocation, TrackerContext& ctx, ITracker* parent );

        bool isComplete() const override;
        bool isSuccessfullyCompleted() const override;
        bool isOpen() const override;
        bool hasChildren() const override;
        bool hasStarted() const override {
            return m_runState != NotStarted;
        }

        void addChild( ITrackerPtr const& child ) override;

        ITrackerPtr findChild( NameAndLocation const& nameAndLocation ) override;
        ITracker& parent() override;

        void openChild() override;

        bool isSectionTracker() const override;
        bool isGeneratorTracker() const override;

        void open();

        void close() override;
        void fail() override;
        void markAsNeedingAnotherRun() override;

    private:
        void moveToParent();
        void moveToThis();
    };

    class SectionTracker : public TrackerBase {
        std::vector<std::string> m_filters;
        std::string m_trimmed_name;
    public:
        SectionTracker( NameAndLocation const& nameAndLocation, TrackerContext& ctx, ITracker* parent );

        bool isSectionTracker() const override;

        bool isComplete() const override;

        static SectionTracker& acquire( TrackerContext& ctx, NameAndLocation const& nameAndLocation );

        void tryOpen();

        void addInitialFilters( std::vector<std::string> const& filters );
        void addNextFilters( std::vector<std::string> const& filters );
    };

} // namespace TestCaseTracking

using TestCaseTracking::ITracker;
using TestCaseTracking::TrackerContext;
using TestCaseTracking::SectionTracker;

} // namespace Catch

// end catch_test_case_tracker.h

// start catch_leak_detector.h

namespace Catch {

    struct LeakDetector {
        LeakDetector();
        ~LeakDetector();
    };

}
// end catch_leak_detector.h
// Cpp files will be included in the single-header file here
// start catch_stats.cpp

// Statistical analysis tools

#if defined(CATCH_CONFIG_ENABLE_BENCHMARKING)

#include <cassert>
#include <random>

#if defined(CATCH_CONFIG_USE_ASYNC)
#include <future>
#endif

namespace {
    double erf_inv(double x) {
        // Code accompanying the article "Approximating the erfinv function" in GPU Computing Gems, Volume 2
        double w, p;

        w = -log((1.0 - x) * (1.0 + x));

        if (w < 6.250000) {
            w = w - 3.125000;
            p = -3.6444120640178196996e-21;
            p = -1.685059138182016589e-19 + p * w;
            p = 1.2858480715256400167e-18 + p * w;
            p = 1.115787767802518096e-17 + p * w;
            p = -1.333171662854620906e-16 + p * w;
            p = 2.0972767875968561637e-17 + p * w;
            p = 6.6376381343583238325e-15 + p * w;
            p = -4.0545662729752068639e-14 + p * w;
            p = -8.1519341976054721522e-14 + p * w;
            p = 2.6335093153082322977e-12 + p * w;
            p = -1.2975133253453532498e-11 + p * w;
            p = -5.4154120542946279317e-11 + p * w;
            p = 1.051212273321532285e-09 + p * w;
            p = -4.1126339803469836976e-09 + p * w;
            p = -2.9070369957882005086e-08 + p * w;
            p = 4.2347877827932403518e-07 + p * w;
            p = -1.3654692000834678645e-06 + p * w;
            p = -1.3882523362786468719e-05 + p * w;
            p = 0.0001867342080340571352 + p * w;
            p = -0.00074070253416626697512 + p * w;
            p = -0.0060336708714301490533 + p * w;
            p = 0.24015818242558961693 + p * w;
            p = 1.6536545626831027356 + p * w;
        } else if (w < 16.000000) {
            w = sqrt(w) - 3.250000;
            p = 2.2137376921775787049e-09;
            p = 9.0756561938885390979e-08 + p * w;
            p = -2.7517406297064545428e-07 + p * w;
            p = 1.8239629214389227755e-08 + p * w;
            p = 1.5027403968909827627e-06 + p * w;
            p = -4.013867526981545969e-06 + p * w;
            p = 2.9234449089955446044e-06 + p * w;
            p = 1.2475304481671778723e-05 + p * w;
            p = -4.7318229009055733981e-05 + p * w;
            p = 6.8284851459573175448e-05 + p * w;
            p = 2.4031110387097893999e-05 + p * w;
            p = -0.0003550375203628474796 + p * w;
            p = 0.00095328937973738049703 + p * w;
            p = -0.0016882755560235047313 + p * w;
            p = 0.0024914420961078508066 + p * w;
            p = -0.0037512085075692412107 + p * w;
            p = 0.005370914553590063617 + p * w;
            p = 1.0052589676941592334 + p * w;
            p = 3.0838856104922207635 + p * w;
        } else {
            w = sqrt(w) - 5.000000;
            p = -2.7109920616438573243e-11;
            p = -2.5556418169965252055e-10 + p * w;
            p = 1.5076572693500548083e-09 + p * w;
            p = -3.7894654401267369937e-09 + p * w;
            p = 7.6157012080783393804e-09 + p * w;
            p = -1.4960026627149240478e-08 + p * w;
            p = 2.9147953450901080826e-08 + p * w;
            p = -6.7711997758452339498e-08 + p * w;
            p = 2.2900482228026654717e-07 + p * w;
            p = -9.9298272942317002539e-07 + p * w;
            p = 4.5260625972231537039e-06 + p * w;
            p = -1.9681778105531670567e-05 + p * w;
            p = 7.5995277030017761139e-05 + p * w;
            p = -0.00021503011930044477347 + p * w;
            p = -0.00013871931833623122026 + p * w;
            p = 1.0103004648645343977 + p * w;
            p = 4.8499064014085844221 + p * w;
        }
        return p * x;
    }

    double standard_deviation(std::vector<double>::iterator first, std::vector<double>::iterator last) {
        auto m = Catch::Benchmark::Detail::mean(first, last);
        double variance = std::accumulate(first, last, 0., [m](double a, double b) {
            double diff = b - m;
            return a + diff * diff;
            }) / (last - first);
            return std::sqrt(variance);
    }

}

namespace Catch {
    namespace Benchmark {
        namespace Detail {

            double weighted_average_quantile(int k, int q, std::vector<double>::iterator first, std::vector<double>::iterator last) {
                auto count = last - first;
                double idx = (count - 1) * k / static_cast<double>(q);
                int j = static_cast<int>(idx);
                double g = idx - j;
                std::nth_element(first, first + j, last);
                auto xj = first[j];
                if (g == 0) return xj;

                auto xj1 = *std::min_element(first + (j + 1), last);
                return xj + g * (xj1 - xj);
            }

            double erfc_inv(double x) {
                return erf_inv(1.0 - x);
            }

            double normal_quantile(double p) {
                static const double ROOT_TWO = std::sqrt(2.0);

                double result = 0.0;
                assert(p >= 0 && p <= 1);
                if (p < 0 || p > 1) {
                    return result;
                }

                result = -erfc_inv(2.0 * p);
                // result *= normal distribution standard deviation (1.0) * sqrt(2)
                result *= /*sd * */ ROOT_TWO;
                // result += normal disttribution mean (0)
                return result;
            }

            double outlier_variance(Estimate<double> mean, Estimate<double> stddev, int n) {
                double sb = stddev.point;
                double mn = mean.point / n;
                double mg_min = mn / 2.;
                double sg = std::min(mg_min / 4., sb / std::sqrt(n));
                double sg2 = sg * sg;
                double sb2 = sb * sb;

                auto c_max = [n, mn, sb2, sg2](double x) -> double {
                    double k = mn - x;
                    double d = k * k;
                    double nd = n * d;
                    double k0 = -n * nd;
                    double k1 = sb2 - n * sg2 + nd;
                    double det = k1 * k1 - 4 * sg2 * k0;
                    return (int)(-2. * k0 / (k1 + std::sqrt(det)));
                };

                auto var_out = [n, sb2, sg2](double c) {
                    double nc = n - c;
                    return (nc / n) * (sb2 - nc * sg2);
                };

                return std::min(var_out(1), var_out(std::min(c_max(0.), c_max(mg_min)))) / sb2;
            }

            bootstrap_analysis analyse_samples(double confidence_level, int n_resamples, std::vector<double>::iterator first, std::vector<double>::iterator last) {
                CATCH_INTERNAL_START_WARNINGS_SUPPRESSION
                CATCH_INTERNAL_SUPPRESS_GLOBALS_WARNINGS
                static std::random_device entropy;
                CATCH_INTERNAL_STOP_WARNINGS_SUPPRESSION

                auto n = static_cast<int>(last - first); // seriously, one can't use integral types without hell in C++

                auto mean = &Detail::mean<std::vector<double>::iterator>;
                auto stddev = &standard_deviation;

#if defined(CATCH_CONFIG_USE_ASYNC)
                auto Estimate = [=](double(*f)(std::vector<double>::iterator, std::vector<double>::iterator)) {
                    auto seed = entropy();
                    return std::async(std::launch::async, [=] {
                        std::mt19937 rng(seed);
                        auto resampled = resample(rng, n_resamples, first, last, f);
                        return bootstrap(confidence_level, first, last, resampled, f);
                    });
                };

                auto mean_future = Estimate(mean);
                auto stddev_future = Estimate(stddev);

                auto mean_estimate = mean_future.get();
                auto stddev_estimate = stddev_future.get();
#else
                auto Estimate = [=](double(*f)(std::vector<double>::iterator, std::vector<double>::iterator)) {
                    auto seed = entropy();
                    std::mt19937 rng(seed);
                    auto resampled = resample(rng, n_resamples, first, last, f);
                    return bootstrap(confidence_level, first, last, resampled, f);
                };

                auto mean_estimate = Estimate(mean);
                auto stddev_estimate = Estimate(stddev);
#endif // CATCH_USE_ASYNC

                double outlier_variance = Detail::outlier_variance(mean_estimate, stddev_estimate, n);

                return { mean_estimate, stddev_estimate, outlier_variance };
            }
        } // namespace Detail
    } // namespace Benchmark
} // namespace Catch

#endif // CATCH_CONFIG_ENABLE_BENCHMARKING
// end catch_stats.cpp
// start catch_approx.cpp

#include <cmath>
#include <limits>

namespace {

// Performs equivalent check of std::fabs(lhs - rhs) <= margin
// But without the subtraction to allow for INFINITY in comparison
bool marginComparison(double lhs, double rhs, double margin) {
    return (lhs + margin >= rhs) && (rhs + margin >= lhs);
}

}

namespace Catch {
namespace Detail {

    Approx::Approx ( double value )
    :   m_epsilon( std::numeric_limits<float>::epsilon()*100 ),
        m_margin( 0.0 ),
        m_scale( 0.0 ),
        m_value( value )
    {}

    Approx Approx::custom() {
        return Approx( 0 );
    }

    Approx Approx::operator-() const {
        auto temp(*this);
        temp.m_value = -temp.m_value;
        return temp;
    }

    std::string Approx::toString() const {
        ReusableStringStream rss;
        rss << "Approx( " << ::Catch::Detail::stringify( m_value ) << " )";
        return rss.str();
    }

    bool Approx::equalityComparisonImpl(const double other) const {
        // First try with fixed margin, then compute margin based on epsilon, scale and Approx's value
        // Thanks to Richard Harris for his help refining the scaled margin value
        return marginComparison(m_value, other, m_margin)
            || marginComparison(m_value, other, m_epsilon * (m_scale + std::fabs(std::isinf(m_value)? 0 : m_value)));
    }

    void Approx::setMargin(double newMargin) {
        CATCH_ENFORCE(newMargin >= 0,
            "Invalid Approx::margin: " << newMargin << '.'
            << " Approx::Margin has to be non-negative.");
        m_margin = newMargin;
    }

    void Approx::setEpsilon(double newEpsilon) {
        CATCH_ENFORCE(newEpsilon >= 0 && newEpsilon <= 1.0,
            "Invalid Approx::epsilon: " << newEpsilon << '.'
            << " Approx::epsilon has to be in [0, 1]");
        m_epsilon = newEpsilon;
    }

} // end namespace Detail

namespace literals {
    Detail::Approx operator "" _a(long double val) {
        return Detail::Approx(val);
    }
    Detail::Approx operator "" _a(unsigned long long val) {
        return Detail::Approx(val);
    }
} // end namespace literals

std::string StringMaker<Catch::Detail::Approx>::convert(Catch::Detail::Approx const& value) {
    return value.toString();
}

} // end namespace Catch
// end catch_approx.cpp
// start catch_assertionhandler.cpp

// start catch_debugger.h

namespace Catch {
    bool isDebuggerActive();
}

#ifdef CATCH_PLATFORM_MAC

    #if defined(__i386__) || defined(__x86_64__)
        #define CATCH_TRAP() __asm__("int $3\n" : : ) /* NOLINT */
    #elif defined(__aarch64__)
        #define CATCH_TRAP()  __asm__(".inst 0xd4200000")
    #endif

#elif defined(CATCH_PLATFORM_IPHONE)

    // use inline assembler
    #if defined(__i386__) || defined(__x86_64__)
        #define CATCH_TRAP()  __asm__("int $3")
    #elif defined(__aarch64__)
        #define CATCH_TRAP()  __asm__(".inst 0xd4200000")
    #elif defined(__arm__) && !defined(__thumb__)
        #define CATCH_TRAP()  __asm__(".inst 0xe7f001f0")
    #elif defined(__arm__) &&  defined(__thumb__)
        #define CATCH_TRAP()  __asm__(".inst 0xde01")
    #endif

#elif defined(CATCH_PLATFORM_LINUX)
    // If we can use inline assembler, do it because this allows us to break
    // directly at the location of the failing check instead of breaking inside
    // raise() called from it, i.e. one stack frame below.
    #if defined(__GNUC__) && (defined(__i386) || defined(__x86_64))
        #define CATCH_TRAP() asm volatile ("int $3") /* NOLINT */
    #else // Fall back to the generic way.
        #include <signal.h>

        #define CATCH_TRAP() raise(SIGTRAP)
    #endif
#elif defined(_MSC_VER)
    #define CATCH_TRAP() __debugbreak()
#elif defined(__MINGW32__)
    extern "C" __declspec(dllimport) void __stdcall DebugBreak();
    #define CATCH_TRAP() DebugBreak()
#endif

#ifndef CATCH_BREAK_INTO_DEBUGGER
    #ifdef CATCH_TRAP
        #define CATCH_BREAK_INTO_DEBUGGER() []{ if( Catch::isDebuggerActive() ) { CATCH_TRAP(); } }()
    #else
        #define CATCH_BREAK_INTO_DEBUGGER() []{}()
    #endif
#endif

// end catch_debugger.h
// start catch_run_context.h

// start catch_fatal_condition.h

// start catch_windows_h_proxy.h


#if defined(CATCH_PLATFORM_WINDOWS)

#if !defined(NOMINMAX) && !defined(CATCH_CONFIG_NO_NOMINMAX)
#  define CATCH_DEFINED_NOMINMAX
#  define NOMINMAX
#endif
#if !defined(WIN32_LEAN_AND_MEAN) && !defined(CATCH_CONFIG_NO_WIN32_LEAN_AND_MEAN)
#  define CATCH_DEFINED_WIN32_LEAN_AND_MEAN
#  define WIN32_LEAN_AND_MEAN
#endif

#ifdef __AFXDLL
#include <AfxWin.h>
#else
#include <windows.h>
#endif

#ifdef CATCH_DEFINED_NOMINMAX
#  undef NOMINMAX
#endif
#ifdef CATCH_DEFINED_WIN32_LEAN_AND_MEAN
#  undef WIN32_LEAN_AND_MEAN
#endif

#endif // defined(CATCH_PLATFORM_WINDOWS)

// end catch_windows_h_proxy.h
#if defined( CATCH_CONFIG_WINDOWS_SEH )

namespace Catch {

    struct FatalConditionHandler {

        static LONG CALLBACK handleVectoredException(PEXCEPTION_POINTERS ExceptionInfo);
        FatalConditionHandler();
        static void reset();
        ~FatalConditionHandler();

    private:
        static bool isSet;
        static ULONG guaranteeSize;
        static PVOID exceptionHandlerHandle;
    };

} // namespace Catch

#elif defined ( CATCH_CONFIG_POSIX_SIGNALS )

#include <signal.h>

namespace Catch {

    struct FatalConditionHandler {

        static bool isSet;
        static struct sigaction oldSigActions[];
        static stack_t oldSigStack;
        static char altStackMem[];

        static void handleSignal( int sig );

        FatalConditionHandler();
        ~FatalConditionHandler();
        static void reset();
    };

} // namespace Catch

#else

namespace Catch {
    struct FatalConditionHandler {
        void reset();
    };
}

#endif

// end catch_fatal_condition.h
#include <string>

namespace Catch {

    struct IMutableContext;

    ///////////////////////////////////////////////////////////////////////////

    class RunContext : public IResultCapture, public IRunner {

    public:
        RunContext( RunContext const& ) = delete;
        RunContext& operator =( RunContext const& ) = delete;

        explicit RunContext( IConfigPtr const& _config, IStreamingReporterPtr&& reporter );

        ~RunContext() override;

        void testGroupStarting( std::string const& testSpec, std::size_t groupIndex, std::size_t groupsCount );
        void testGroupEnded( std::string const& testSpec, Totals const& totals, std::size_t groupIndex, std::size_t groupsCount );

        Totals runTest(TestCase const& testCase);

        IConfigPtr config() const;
        IStreamingReporter& reporter() const;

    public: // IResultCapture

        // Assertion handlers
        void handleExpr
                (   AssertionInfo const& info,
                    ITransientExpression const& expr,
                    AssertionReaction& reaction ) override;
        void handleMessage
                (   AssertionInfo const& info,
                    ResultWas::OfType resultType,
                    StringRef const& message,
                    AssertionReaction& reaction ) override;
        void handleUnexpectedExceptionNotThrown
                (   AssertionInfo const& info,
                    AssertionReaction& reaction ) override;
        void handleUnexpectedInflightException
                (   AssertionInfo const& info,
                    std::string const& message,
                    AssertionReaction& reaction ) override;
        void handleIncomplete
                (   AssertionInfo const& info ) override;
        void handleNonExpr
                (   AssertionInfo const &info,
                    ResultWas::OfType resultType,
                    AssertionReaction &reaction ) override;

        bool sectionStarted( SectionInfo const& sectionInfo, Counts& assertions ) override;

        void sectionEnded( SectionEndInfo const& endInfo ) override;
        void sectionEndedEarly( SectionEndInfo const& endInfo ) override;

        auto acquireGeneratorTracker( StringRef generatorName, SourceLineInfo const& lineInfo ) -> IGeneratorTracker& override;

#if defined(CATCH_CONFIG_ENABLE_BENCHMARKING)
        void benchmarkPreparing( std::string const& name ) override;
        void benchmarkStarting( BenchmarkInfo const& info ) override;
        void benchmarkEnded( BenchmarkStats<> const& stats ) override;
        void benchmarkFailed( std::string const& error ) override;
#endif // CATCH_CONFIG_ENABLE_BENCHMARKING

        void pushScopedMessage( MessageInfo const& message ) override;
        void popScopedMessage( MessageInfo const& message ) override;

        void emplaceUnscopedMessage( MessageBuilder const& builder ) override;

        std::string getCurrentTestName() const override;

        const AssertionResult* getLastResult() const override;

        void exceptionEarlyReported() override;

        void handleFatalErrorCondition( StringRef message ) override;

        bool lastAssertionPassed() override;

        void assertionPassed() override;

    public:
        // !TBD We need to do this another way!
        bool aborting() const final;

    private:

        void runCurrentTest( std::string& redirectedCout, std::string& redirectedCerr );
        void invokeActiveTestCase();

        void resetAssertionInfo();
        bool testForMissingAssertions( Counts& assertions );

        void assertionEnded( AssertionResult const& result );
        void reportExpr
                (   AssertionInfo const &info,
                    ResultWas::OfType resultType,
                    ITransientExpression const *expr,
                    bool negated );

        void populateReaction( AssertionReaction& reaction );

    private:

        void handleUnfinishedSections();

        TestRunInfo m_runInfo;
        IMutableContext& m_context;
        TestCase const* m_activeTestCase = nullptr;
        ITracker* m_testCaseTracker = nullptr;
        Option<AssertionResult> m_lastResult;

        IConfigPtr m_config;
        Totals m_totals;
        IStreamingReporterPtr m_reporter;
        std::vector<MessageInfo> m_messages;
        std::vector<ScopedMessage> m_messageScopes; /* Keeps owners of so-called unscoped messages. */
        AssertionInfo m_lastAssertionInfo;
        std::vector<SectionEndInfo> m_unfinishedSections;
        std::vector<ITracker*> m_activeSections;
        TrackerContext m_trackerContext;
        bool m_lastAssertionPassed = false;
        bool m_shouldReportUnexpected = true;
        bool m_includeSuccessfulResults;
    };

    void seedRng(IConfig const& config);
    unsigned int rngSeed();
} // end namespace Catch

// end catch_run_context.h
namespace Catch {

    namespace {
        auto operator <<( std::ostream& os, ITransientExpression const& expr ) -> std::ostream& {
            expr.streamReconstructedExpression( os );
            return os;
        }
    }

    LazyExpression::LazyExpression( bool isNegated )
    :   m_isNegated( isNegated )
    {}

    LazyExpression::LazyExpression( LazyExpression const& other ) : m_isNegated( other.m_isNegated ) {}

    LazyExpression::operator bool() const {
        return m_transientExpression != nullptr;
    }

    auto operator << ( std::ostream& os, LazyExpression const& lazyExpr ) -> std::ostream& {
        if( lazyExpr.m_isNegated )
            os << "!";

        if( lazyExpr ) {
            if( lazyExpr.m_isNegated && lazyExpr.m_transientExpression->isBinaryExpression() )
                os << "(" << *lazyExpr.m_transientExpression << ")";
            else
                os << *lazyExpr.m_transientExpression;
        }
        else {
            os << "{** error - unchecked empty expression requested **}";
        }
        return os;
    }

    AssertionHandler::AssertionHandler
        (   StringRef const& macroName,
            SourceLineInfo const& lineInfo,
            StringRef capturedExpression,
            ResultDisposition::Flags resultDisposition )
    :   m_assertionInfo{ macroName, lineInfo, capturedExpression, resultDisposition },
        m_resultCapture( getResultCapture() )
    {}

    void AssertionHandler::handleExpr( ITransientExpression const& expr ) {
        m_resultCapture.handleExpr( m_assertionInfo, expr, m_reaction );
    }
    void AssertionHandler::handleMessage(ResultWas::OfType resultType, StringRef const& message) {
        m_resultCapture.handleMessage( m_assertionInfo, resultType, message, m_reaction );
    }

    auto AssertionHandler::allowThrows() const -> bool {
        return getCurrentContext().getConfig()->allowThrows();
    }

    void AssertionHandler::complete() {
        setCompleted();
        if( m_reaction.shouldDebugBreak ) {

            // If you find your debugger stopping you here then go one level up on the
            // call-stack for the code that caused it (typically a failed assertion)

            // (To go back to the test and change execution, jump over the throw, next)
            CATCH_BREAK_INTO_DEBUGGER();
        }
        if (m_reaction.shouldThrow) {
#if !defined(CATCH_CONFIG_DISABLE_EXCEPTIONS)
            throw Catch::TestFailureException();
#else
            CATCH_ERROR( "Test failure requires aborting test!" );
#endif
        }
    }
    void AssertionHandler::setCompleted() {
        m_completed = true;
    }

    void AssertionHandler::handleUnexpectedInflightException() {
        m_resultCapture.handleUnexpectedInflightException( m_assertionInfo, Catch::translateActiveException(), m_reaction );
    }

    void AssertionHandler::handleExceptionThrownAsExpected() {
        m_resultCapture.handleNonExpr(m_assertionInfo, ResultWas::Ok, m_reaction);
    }
    void AssertionHandler::handleExceptionNotThrownAsExpected() {
        m_resultCapture.handleNonExpr(m_assertionInfo, ResultWas::Ok, m_reaction);
    }

    void AssertionHandler::handleUnexpectedExceptionNotThrown() {
        m_resultCapture.handleUnexpectedExceptionNotThrown( m_assertionInfo, m_reaction );
    }

    void AssertionHandler::handleThrowingCallSkipped() {
        m_resultCapture.handleNonExpr(m_assertionInfo, ResultWas::Ok, m_reaction);
    }

    // This is the overload that takes a string and infers the Equals matcher from it
    // The more general overload, that takes any string matcher, is in catch_capture_matchers.cpp
    void handleExceptionMatchExpr( AssertionHandler& handler, std::string const& str, StringRef const& matcherString  ) {
        handleExceptionMatchExpr( handler, Matchers::Equals( str ), matcherString );
    }

} // namespace Catch
// end catch_assertionhandler.cpp
// start catch_assertionresult.cpp

namespace Catch {
    AssertionResultData::AssertionResultData(ResultWas::OfType _resultType, LazyExpression const & _lazyExpression):
        lazyExpression(_lazyExpression),
        resultType(_resultType) {}

    std::string AssertionResultData::reconstructExpression() const {

        if( reconstructedExpression.empty() ) {
            if( lazyExpression ) {
                ReusableStringStream rss;
                rss << lazyExpression;
                reconstructedExpression = rss.str();
            }
        }
        return reconstructedExpression;
    }

    AssertionResult::AssertionResult( AssertionInfo const& info, AssertionResultData const& data )
    :   m_info( info ),
        m_resultData( data )
    {}

    // Result was a success
    bool AssertionResult::succeeded() const {
        return Catch::isOk( m_resultData.resultType );
    }

    // Result was a success, or failure is suppressed
    bool AssertionResult::isOk() const {
        return Catch::isOk( m_resultData.resultType ) || shouldSuppressFailure( m_info.resultDisposition );
    }

    ResultWas::OfType AssertionResult::getResultType() const {
        return m_resultData.resultType;
    }

    bool AssertionResult::hasExpression() const {
        return !m_info.capturedExpression.empty();
    }

    bool AssertionResult::hasMessage() const {
        return !m_resultData.message.empty();
    }

    std::string AssertionResult::getExpression() const {
        // Possibly overallocating by 3 characters should be basically free
        std::string expr; expr.reserve(m_info.capturedExpression.size() + 3);
        if (isFalseTest(m_info.resultDisposition)) {
            expr += "!(";
        }
        expr += m_info.capturedExpression;
        if (isFalseTest(m_info.resultDisposition)) {
            expr += ')';
        }
        return expr;
    }

    std::string AssertionResult::getExpressionInMacro() const {
        std::string expr;
        if( m_info.macroName.empty() )
            expr = static_cast<std::string>(m_info.capturedExpression);
        else {
            expr.reserve( m_info.macroName.size() + m_info.capturedExpression.size() + 4 );
            expr += m_info.macroName;
            expr += "( ";
            expr += m_info.capturedExpression;
            expr += " )";
        }
        return expr;
    }

    bool AssertionResult::hasExpandedExpression() const {
        return hasExpression() && getExpandedExpression() != getExpression();
    }

    std::string AssertionResult::getExpandedExpression() const {
        std::string expr = m_resultData.reconstructExpression();
        return expr.empty()
                ? getExpression()
                : expr;
    }

    std::string AssertionResult::getMessage() const {
        return m_resultData.message;
    }
    SourceLineInfo AssertionResult::getSourceInfo() const {
        return m_info.lineInfo;
    }

    StringRef AssertionResult::getTestMacroName() const {
        return m_info.macroName;
    }

} // end namespace Catch
// end catch_assertionresult.cpp
// start catch_capture_matchers.cpp

namespace Catch {

    using StringMatcher = Matchers::Impl::MatcherBase<std::string>;

    // This is the general overload that takes a any string matcher
    // There is another overload, in catch_assertionhandler.h/.cpp, that only takes a string and infers
    // the Equals matcher (so the header does not mention matchers)
    void handleExceptionMatchExpr( AssertionHandler& handler, StringMatcher const& matcher, StringRef const& matcherString  ) {
        std::string exceptionMessage = Catch::translateActiveException();
        MatchExpr<std::string, StringMatcher const&> expr( exceptionMessage, matcher, matcherString );
        handler.handleExpr( expr );
    }

} // namespace Catch
// end catch_capture_matchers.cpp
// start catch_commandline.cpp

// start catch_commandline.h

// start catch_clara.h

// Use Catch's value for console width (store Clara's off to the side, if present)
#ifdef CLARA_CONFIG_CONSOLE_WIDTH
#define CATCH_TEMP_CLARA_CONFIG_CONSOLE_WIDTH CATCH_CLARA_TEXTFLOW_CONFIG_CONSOLE_WIDTH
#undef CATCH_CLARA_TEXTFLOW_CONFIG_CONSOLE_WIDTH
#endif
#define CATCH_CLARA_TEXTFLOW_CONFIG_CONSOLE_WIDTH CATCH_CONFIG_CONSOLE_WIDTH-1

#ifdef __clang__
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wweak-vtables"
#pragma clang diagnostic ignored "-Wexit-time-destructors"
#pragma clang diagnostic ignored "-Wshadow"
#endif

// start clara.hpp
// Copyright 2017 Two Blue Cubes Ltd. All rights reserved.
//
// Distributed under the Boost Software License, Version 1.0. (See accompanying
// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
//
// See https://github.com/philsquared/Clara for more details

// Clara v1.1.5


#ifndef CATCH_CLARA_CONFIG_CONSOLE_WIDTH
#define CATCH_CLARA_CONFIG_CONSOLE_WIDTH 80
#endif

#ifndef CATCH_CLARA_TEXTFLOW_CONFIG_CONSOLE_WIDTH
#define CATCH_CLARA_TEXTFLOW_CONFIG_CONSOLE_WIDTH CATCH_CLARA_CONFIG_CONSOLE_WIDTH
#endif

#ifndef CLARA_CONFIG_OPTIONAL_TYPE
#ifdef __has_include
#if __has_include(<optional>) && __cplusplus >= 201703L
#include <optional>
#define CLARA_CONFIG_OPTIONAL_TYPE std::optional
#endif
#endif
#endif

// ----------- #included from clara_textflow.hpp -----------

// TextFlowCpp
//
// A single-header library for wrapping and laying out basic text, by Phil Nash
//
// Distributed under the Boost Software License, Version 1.0. (See accompanying
// file LICENSE.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
//
// This project is hosted at https://github.com/philsquared/textflowcpp


#include <cassert>
#include <ostream>
#include <sstream>
#include <vector>

#ifndef CATCH_CLARA_TEXTFLOW_CONFIG_CONSOLE_WIDTH
#define CATCH_CLARA_TEXTFLOW_CONFIG_CONSOLE_WIDTH 80
#endif

namespace Catch {
namespace clara {
namespace TextFlow {

inline auto isWhitespace(char c) -> bool {
	static std::string chars = " \t\n\r";
	return chars.find(c) != std::string::npos;
}
inline auto isBreakableBefore(char c) -> bool {
	static std::string chars = "[({<|";
	return chars.find(c) != std::string::npos;
}
inline auto isBreakableAfter(char c) -> bool {
	static std::string chars = "])}>.,:;*+-=&/\\";
	return chars.find(c) != std::string::npos;
}

class Columns;

class Column {
	std::vector<std::string> m_strings;
	size_t m_width = CATCH_CLARA_TEXTFLOW_CONFIG_CONSOLE_WIDTH;
	size_t m_indent = 0;
	size_t m_initialIndent = std::string::npos;

public:
	class iterator {
		friend Column;

		Column const& m_column;
		size_t m_stringIndex = 0;
		size_t m_pos = 0;

		size_t m_len = 0;
		size_t m_end = 0;
		bool m_suffix = false;

		iterator(Column const& column, size_t stringIndex)
			: m_column(column),
			m_stringIndex(stringIndex) {}

		auto line() const -> std::string const& { return m_column.m_strings[m_stringIndex]; }

		auto isBoundary(size_t at) const -> bool {
			assert(at > 0);
			assert(at <= line().size());

			return at == line().size() ||
				(isWhitespace(line()[at]) && !isWhitespace(line()[at - 1])) ||
				isBreakableBefore(line()[at]) ||
				isBreakableAfter(line()[at - 1]);
		}

		void calcLength() {
			assert(m_stringIndex < m_column.m_strings.size());

			m_suffix = false;
			auto width = m_column.m_width - indent();
			m_end = m_pos;
			if (line()[m_pos] == '\n') {
				++m_end;
			}
			while (m_end < line().size() && line()[m_end] != '\n')
				++m_end;

			if (m_end < m_pos + width) {
				m_len = m_end - m_pos;
			} else {
				size_t len = width;
				while (len > 0 && !isBoundary(m_pos + len))
					--len;
				while (len > 0 && isWhitespace(line()[m_pos + len - 1]))
					--len;

				if (len > 0) {
					m_len = len;
				} else {
					m_suffix = true;
					m_len = width - 1;
				}
			}
		}

		auto indent() const -> size_t {
			auto initial = m_pos == 0 && m_stringIndex == 0 ? m_column.m_initialIndent : std::string::npos;
			return initial == std::string::npos ? m_column.m_indent : initial;
		}

		auto addIndentAndSuffix(std::string const &plain) const -> std::string {
			return std::string(indent(), ' ') + (m_suffix ? plain + "-" : plain);
		}

	public:
		using difference_type = std::ptrdiff_t;
		using value_type = std::string;
		using pointer = value_type * ;
		using reference = value_type & ;
		using iterator_category = std::forward_iterator_tag;

		explicit iterator(Column const& column) : m_column(column) {
			assert(m_column.m_width > m_column.m_indent);
			assert(m_column.m_initialIndent == std::string::npos || m_column.m_width > m_column.m_initialIndent);
			calcLength();
			if (m_len == 0)
				m_stringIndex++; // Empty string
		}

		auto operator *() const -> std::string {
			assert(m_stringIndex < m_column.m_strings.size());
			assert(m_pos <= m_end);
			return addIndentAndSuffix(line().substr(m_pos, m_len));
		}

		auto operator ++() -> iterator& {
			m_pos += m_len;
			if (m_pos < line().size() && line()[m_pos] == '\n')
				m_pos += 1;
			else
				while (m_pos < line().size() && isWhitespace(line()[m_pos]))
					++m_pos;

			if (m_pos == line().size()) {
				m_pos = 0;
				++m_stringIndex;
			}
			if (m_stringIndex < m_column.m_strings.size())
				calcLength();
			return *this;
		}
		auto operator ++(int) -> iterator {
			iterator prev(*this);
			operator++();
			return prev;
		}

		auto operator ==(iterator const& other) const -> bool {
			return
				m_pos == other.m_pos &&
				m_stringIndex == other.m_stringIndex &&
				&m_column == &other.m_column;
		}
		auto operator !=(iterator const& other) const -> bool {
			return !operator==(other);
		}
	};
	using const_iterator = iterator;

	explicit Column(std::string const& text) { m_strings.push_back(text); }

	auto width(size_t newWidth) -> Column& {
		assert(newWidth > 0);
		m_width = newWidth;
		return *this;
	}
	auto indent(size_t newIndent) -> Column& {
		m_indent = newIndent;
		return *this;
	}
	auto initialIndent(size_t newIndent) -> Column& {
		m_initialIndent = newIndent;
		return *this;
	}

	auto width() const -> size_t { return m_width; }
	auto begin() const -> iterator { return iterator(*this); }
	auto end() const -> iterator { return { *this, m_strings.size() }; }

	inline friend std::ostream& operator << (std::ostream& os, Column const& col) {
		bool first = true;
		for (auto line : col) {
			if (first)
				first = false;
			else
				os << "\n";
			os << line;
		}
		return os;
	}

	auto operator + (Column const& other)->Columns;

	auto toString() const -> std::string {
		std::ostringstream oss;
		oss << *this;
		return oss.str();
	}
};

class Spacer : public Column {

public:
	explicit Spacer(size_t spaceWidth) : Column("") {
		width(spaceWidth);
	}
};

class Columns {
	std::vector<Column> m_columns;

public:

	class iterator {
		friend Columns;
		struct EndTag {};

		std::vector<Column> const& m_columns;
		std::vector<Column::iterator> m_iterators;
		size_t m_activeIterators;

		iterator(Columns const& columns, EndTag)
			: m_columns(columns.m_columns),
			m_activeIterators(0) {
			m_iterators.reserve(m_columns.size());

			for (auto const& col : m_columns)
				m_iterators.push_back(col.end());
		}

	public:
		using difference_type = std::ptrdiff_t;
		using value_type = std::string;
		using pointer = value_type * ;
		using reference = value_type & ;
		using iterator_category = std::forward_iterator_tag;

		explicit iterator(Columns const& columns)
			: m_columns(columns.m_columns),
			m_activeIterators(m_columns.size()) {
			m_iterators.reserve(m_columns.size());

			for (auto const& col : m_columns)
				m_iterators.push_back(col.begin());
		}

		auto operator ==(iterator const& other) const -> bool {
			return m_iterators == other.m_iterators;
		}
		auto operator !=(iterator const& other) const -> bool {
			return m_iterators != other.m_iterators;
		}
		auto operator *() const -> std::string {
			std::string row, padding;

			for (size_t i = 0; i < m_columns.size(); ++i) {
				auto width = m_columns[i].width();
				if (m_iterators[i] != m_columns[i].end()) {
					std::string col = *m_iterators[i];
					row += padding + col;
					if (col.size() < width)
						padding = std::string(width - col.size(), ' ');
					else
						padding = "";
				} else {
					padding += std::string(width, ' ');
				}
			}
			return row;
		}
		auto operator ++() -> iterator& {
			for (size_t i = 0; i < m_columns.size(); ++i) {
				if (m_iterators[i] != m_columns[i].end())
					++m_iterators[i];
			}
			return *this;
		}
		auto operator ++(int) -> iterator {
			iterator prev(*this);
			operator++();
			return prev;
		}
	};
	using const_iterator = iterator;

	auto begin() const -> iterator { return iterator(*this); }
	auto end() const -> iterator { return { *this, iterator::EndTag() }; }

	auto operator += (Column const& col) -> Columns& {
		m_columns.push_back(col);
		return *this;
	}
	auto operator + (Column const& col) -> Columns {
		Columns combined = *this;
		combined += col;
		return combined;
	}

	inline friend std::ostream& operator << (std::ostream& os, Columns const& cols) {

		bool first = true;
		for (auto line : cols) {
			if (first)
				first = false;
			else
				os << "\n";
			os << line;
		}
		return os;
	}

	auto toString() const -> std::string {
		std::ostringstream oss;
		oss << *this;
		return oss.str();
	}
};

inline auto Column::operator + (Column const& other) -> Columns {
	Columns cols;
	cols += *this;
	cols += other;
	return cols;
}
}

}
}

// ----------- end of #include from clara_textflow.hpp -----------
// ........... back in clara.hpp

#include <cctype>
#include <string>
#include <memory>
#include <set>
#include <algorithm>

#if !defined(CATCH_PLATFORM_WINDOWS) && ( defined(WIN32) || defined(__WIN32__) || defined(_WIN32) || defined(_MSC_VER) )
#define CATCH_PLATFORM_WINDOWS
#endif

namespace Catch { namespace clara {
namespace detail {

    // Traits for extracting arg and return type of lambdas (for single argument lambdas)
    template<typename L>
    struct UnaryLambdaTraits : UnaryLambdaTraits<decltype( &L::operator() )> {};

    template<typename ClassT, typename ReturnT, typename... Args>
    struct UnaryLambdaTraits<ReturnT( ClassT::* )( Args... ) const> {
        static const bool isValid = false;
    };

    template<typename ClassT, typename ReturnT, typename ArgT>
    struct UnaryLambdaTraits<ReturnT( ClassT::* )( ArgT ) const> {
        static const bool isValid = true;
        using ArgType = typename std::remove_const<typename std::remove_reference<ArgT>::type>::type;
        using ReturnType = ReturnT;
    };

    class TokenStream;

    // Transport for raw args (copied from main args, or supplied via init list for testing)
    class Args {
        friend TokenStream;
        std::string m_exeName;
        std::vector<std::string> m_args;

    public:
        Args( int argc, char const* const* argv )
            : m_exeName(argv[0]),
              m_args(argv + 1, argv + argc) {}

        Args( std::initializer_list<std::string> args )
        :   m_exeName( *args.begin() ),
            m_args( args.begin()+1, args.end() )
        {}

        auto exeName() const -> std::string {
            return m_exeName;
        }
    };

    // Wraps a token coming from a token stream. These may not directly correspond to strings as a single string
    // may encode an option + its argument if the : or = form is used
    enum class TokenType {
        Option, Argument
    };
    struct Token {
        TokenType type;
        std::string token;
    };

    inline auto isOptPrefix( char c ) -> bool {
        return c == '-'
#ifdef CATCH_PLATFORM_WINDOWS
            || c == '/'
#endif
        ;
    }

    // Abstracts iterators into args as a stream of tokens, with option arguments uniformly handled
    class TokenStream {
        using Iterator = std::vector<std::string>::const_iterator;
        Iterator it;
        Iterator itEnd;
        std::vector<Token> m_tokenBuffer;

        void loadBuffer() {
            m_tokenBuffer.resize( 0 );

            // Skip any empty strings
            while( it != itEnd && it->empty() )
                ++it;

            if( it != itEnd ) {
                auto const &next = *it;
                if( isOptPrefix( next[0] ) ) {
                    auto delimiterPos = next.find_first_of( " :=" );
                    if( delimiterPos != std::string::npos ) {
                        m_tokenBuffer.push_back( { TokenType::Option, next.substr( 0, delimiterPos ) } );
                        m_tokenBuffer.push_back( { TokenType::Argument, next.substr( delimiterPos + 1 ) } );
                    } else {
                        if( next[1] != '-' && next.size() > 2 ) {
                            std::string opt = "- ";
                            for( size_t i = 1; i < next.size(); ++i ) {
                                opt[1] = next[i];
                                m_tokenBuffer.push_back( { TokenType::Option, opt } );
                            }
                        } else {
                            m_tokenBuffer.push_back( { TokenType::Option, next } );
                        }
                    }
                } else {
                    m_tokenBuffer.push_back( { TokenType::Argument, next } );
                }
            }
        }

    public:
        explicit TokenStream( Args const &args ) : TokenStream( args.m_args.begin(), args.m_args.end() ) {}

        TokenStream( Iterator it, Iterator itEnd ) : it( it ), itEnd( itEnd ) {
            loadBuffer();
        }

        explicit operator bool() const {
            return !m_tokenBuffer.empty() || it != itEnd;
        }

        auto count() const -> size_t { return m_tokenBuffer.size() + (itEnd - it); }

        auto operator*() const -> Token {
            assert( !m_tokenBuffer.empty() );
            return m_tokenBuffer.front();
        }

        auto operator->() const -> Token const * {
            assert( !m_tokenBuffer.empty() );
            return &m_tokenBuffer.front();
        }

        auto operator++() -> TokenStream & {
            if( m_tokenBuffer.size() >= 2 ) {
                m_tokenBuffer.erase( m_tokenBuffer.begin() );
            } else {
                if( it != itEnd )
                    ++it;
                loadBuffer();
            }
            return *this;
        }
    };

    class ResultBase {
    public:
        enum Type {
            Ok, LogicError, RuntimeError
        };

    protected:
        ResultBase( Type type ) : m_type( type ) {}
        virtual ~ResultBase() = default;

        virtual void enforceOk() const = 0;

        Type m_type;
    };

    template<typename T>
    class ResultValueBase : public ResultBase {
    public:
        auto value() const -> T const & {
            enforceOk();
            return m_value;
        }

    protected:
        ResultValueBase( Type type ) : ResultBase( type ) {}

        ResultValueBase( ResultValueBase const &other ) : ResultBase( other ) {
            if( m_type == ResultBase::Ok )
                new( &m_value ) T( other.m_value );
        }

        ResultValueBase( Type, T const &value ) : ResultBase( Ok ) {
            new( &m_value ) T( value );
        }

        auto operator=( ResultValueBase const &other ) -> ResultValueBase & {
            if( m_type == ResultBase::Ok )
                m_value.~T();
            ResultBase::operator=(other);
            if( m_type == ResultBase::Ok )
                new( &m_value ) T( other.m_value );
            return *this;
        }

        ~ResultValueBase() override {
            if( m_type == Ok )
                m_value.~T();
        }

        union {
            T m_value;
        };
    };

    template<>
    class ResultValueBase<void> : public ResultBase {
    protected:
        using ResultBase::ResultBase;
    };

    template<typename T = void>
    class BasicResult : public ResultValueBase<T> {
    public:
        template<typename U>
        explicit BasicResult( BasicResult<U> const &other )
        :   ResultValueBase<T>( other.type() ),
            m_errorMessage( other.errorMessage() )
        {
            assert( type() != ResultBase::Ok );
        }

        template<typename U>
        static auto ok( U const &value ) -> BasicResult { return { ResultBase::Ok, value }; }
        static auto ok() -> BasicResult { return { ResultBase::Ok }; }
        static auto logicError( std::string const &message ) -> BasicResult { return { ResultBase::LogicError, message }; }
        static auto runtimeError( std::string const &message ) -> BasicResult { return { ResultBase::RuntimeError, message }; }

        explicit operator bool() const { return m_type == ResultBase::Ok; }
        auto type() const -> ResultBase::Type { return m_type; }
        auto errorMessage() const -> std::string { return m_errorMessage; }

    protected:
        void enforceOk() const override {

            // Errors shouldn't reach this point, but if they do
            // the actual error message will be in m_errorMessage
            assert( m_type != ResultBase::LogicError );
            assert( m_type != ResultBase::RuntimeError );
            if( m_type != ResultBase::Ok )
                std::abort();
        }

        std::string m_errorMessage; // Only populated if resultType is an error

        BasicResult( ResultBase::Type type, std::string const &message )
        :   ResultValueBase<T>(type),
            m_errorMessage(message)
        {
            assert( m_type != ResultBase::Ok );
        }

        using ResultValueBase<T>::ResultValueBase;
        using ResultBase::m_type;
    };

    enum class ParseResultType {
        Matched, NoMatch, ShortCircuitAll, ShortCircuitSame
    };

    class ParseState {
    public:

        ParseState( ParseResultType type, TokenStream const &remainingTokens )
        : m_type(type),
          m_remainingTokens( remainingTokens )
        {}

        auto type() const -> ParseResultType { return m_type; }
        auto remainingTokens() const -> TokenStream { return m_remainingTokens; }

    private:
        ParseResultType m_type;
        TokenStream m_remainingTokens;
    };

    using Result = BasicResult<void>;
    using ParserResult = BasicResult<ParseResultType>;
    using InternalParseResult = BasicResult<ParseState>;

    struct HelpColumns {
        std::string left;
        std::string right;
    };

    template<typename T>
    inline auto convertInto( std::string const &source, T& target ) -> ParserResult {
        std::stringstream ss;
        ss << source;
        ss >> target;
        if( ss.fail() )
            return ParserResult::runtimeError( "Unable to convert '" + source + "' to destination type" );
        else
            return ParserResult::ok( ParseResultType::Matched );
    }
    inline auto convertInto( std::string const &source, std::string& target ) -> ParserResult {
        target = source;
        return ParserResult::ok( ParseResultType::Matched );
    }
    inline auto convertInto( std::string const &source, bool &target ) -> ParserResult {
        std::string srcLC = source;
        std::transform( srcLC.begin(), srcLC.end(), srcLC.begin(), []( unsigned char c ) { return static_cast<char>( std::tolower(c) ); } );
        if (srcLC == "y" || srcLC == "1" || srcLC == "true" || srcLC == "yes" || srcLC == "on")
            target = true;
        else if (srcLC == "n" || srcLC == "0" || srcLC == "false" || srcLC == "no" || srcLC == "off")
            target = false;
        else
            return ParserResult::runtimeError( "Expected a boolean value but did not recognise: '" + source + "'" );
        return ParserResult::ok( ParseResultType::Matched );
    }
#ifdef CLARA_CONFIG_OPTIONAL_TYPE
    template<typename T>
    inline auto convertInto( std::string const &source, CLARA_CONFIG_OPTIONAL_TYPE<T>& target ) -> ParserResult {
        T temp;
        auto result = convertInto( source, temp );
        if( result )
            target = std::move(temp);
        return result;
    }
#endif // CLARA_CONFIG_OPTIONAL_TYPE

    struct NonCopyable {
        NonCopyable() = default;
        NonCopyable( NonCopyable const & ) = delete;
        NonCopyable( NonCopyable && ) = delete;
        NonCopyable &operator=( NonCopyable const & ) = delete;
        NonCopyable &operator=( NonCopyable && ) = delete;
    };

    struct BoundRef : NonCopyable {
        virtual ~BoundRef() = default;
        virtual auto isContainer() const -> bool { return false; }
        virtual auto isFlag() const -> bool { return false; }
    };
    struct BoundValueRefBase : BoundRef {
        virtual auto setValue( std::string const &arg ) -> ParserResult = 0;
    };
    struct BoundFlagRefBase : BoundRef {
        virtual auto setFlag( bool flag ) -> ParserResult = 0;
        virtual auto isFlag() const -> bool { return true; }
    };

    template<typename T>
    struct BoundValueRef : BoundValueRefBase {
        T &m_ref;

        explicit BoundValueRef( T &ref ) : m_ref( ref ) {}

        auto setValue( std::string const &arg ) -> ParserResult override {
            return convertInto( arg, m_ref );
        }
    };

    template<typename T>
    struct BoundValueRef<std::vector<T>> : BoundValueRefBase {
        std::vector<T> &m_ref;

        explicit BoundValueRef( std::vector<T> &ref ) : m_ref( ref ) {}

        auto isContainer() const -> bool override { return true; }

        auto setValue( std::string const &arg ) -> ParserResult override {
            T temp;
            auto result = convertInto( arg, temp );
            if( result )
                m_ref.push_back( temp );
            return result;
        }
    };

    struct BoundFlagRef : BoundFlagRefBase {
        bool &m_ref;

        explicit BoundFlagRef( bool &ref ) : m_ref( ref ) {}

        auto setFlag( bool flag ) -> ParserResult override {
            m_ref = flag;
            return ParserResult::ok( ParseResultType::Matched );
        }
    };

    template<typename ReturnType>
    struct LambdaInvoker {
        static_assert( std::is_same<ReturnType, ParserResult>::value, "Lambda must return void or clara::ParserResult" );

        template<typename L, typename ArgType>
        static auto invoke( L const &lambda, ArgType const &arg ) -> ParserResult {
            return lambda( arg );
        }
    };

    template<>
    struct LambdaInvoker<void> {
        template<typename L, typename ArgType>
        static auto invoke( L const &lambda, ArgType const &arg ) -> ParserResult {
            lambda( arg );
            return ParserResult::ok( ParseResultType::Matched );
        }
    };

    template<typename ArgType, typename L>
    inline auto invokeLambda( L const &lambda, std::string const &arg ) -> ParserResult {
        ArgType temp{};
        auto result = convertInto( arg, temp );
        return !result
           ? result
           : LambdaInvoker<typename UnaryLambdaTraits<L>::ReturnType>::invoke( lambda, temp );
    }

    template<typename L>
    struct BoundLambda : BoundValueRefBase {
        L m_lambda;

        static_assert( UnaryLambdaTraits<L>::isValid, "Supplied lambda must take exactly one argument" );
        explicit BoundLambda( L const &lambda ) : m_lambda( lambda ) {}

        auto setValue( std::string const &arg ) -> ParserResult override {
            return invokeLambda<typename UnaryLambdaTraits<L>::ArgType>( m_lambda, arg );
        }
    };

    template<typename L>
    struct BoundFlagLambda : BoundFlagRefBase {
        L m_lambda;

        static_assert( UnaryLambdaTraits<L>::isValid, "Supplied lambda must take exactly one argument" );
        static_assert( std::is_same<typename UnaryLambdaTraits<L>::ArgType, bool>::value, "flags must be boolean" );

        explicit BoundFlagLambda( L const &lambda ) : m_lambda( lambda ) {}

        auto setFlag( bool flag ) -> ParserResult override {
            return LambdaInvoker<typename UnaryLambdaTraits<L>::ReturnType>::invoke( m_lambda, flag );
        }
    };

    enum class Optionality { Optional, Required };

    struct Parser;

    class ParserBase {
    public:
        virtual ~ParserBase() = default;
        virtual auto validate() const -> Result { return Result::ok(); }
        virtual auto parse( std::string const& exeName, TokenStream const &tokens) const -> InternalParseResult  = 0;
        virtual auto cardinality() const -> size_t { return 1; }

        auto parse( Args const &args ) const -> InternalParseResult {
            return parse( args.exeName(), TokenStream( args ) );
        }
    };

    template<typename DerivedT>
    class ComposableParserImpl : public ParserBase {
    public:
        template<typename T>
        auto operator|( T const &other ) const -> Parser;

		template<typename T>
        auto operator+( T const &other ) const -> Parser;
    };

    // Common code and state for Args and Opts
    template<typename DerivedT>
    class ParserRefImpl : public ComposableParserImpl<DerivedT> {
    protected:
        Optionality m_optionality = Optionality::Optional;
        std::shared_ptr<BoundRef> m_ref;
        std::string m_hint;
        std::string m_description;

        explicit ParserRefImpl( std::shared_ptr<BoundRef> const &ref ) : m_ref( ref ) {}

    public:
        template<typename T>
        ParserRefImpl( T &ref, std::string const &hint )
        :   m_ref( std::make_shared<BoundValueRef<T>>( ref ) ),
            m_hint( hint )
        {}

        template<typename LambdaT>
        ParserRefImpl( LambdaT const &ref, std::string const &hint )
        :   m_ref( std::make_shared<BoundLambda<LambdaT>>( ref ) ),
            m_hint(hint)
        {}

        auto operator()( std::string const &description ) -> DerivedT & {
            m_description = description;
            return static_cast<DerivedT &>( *this );
        }

        auto optional() -> DerivedT & {
            m_optionality = Optionality::Optional;
            return static_cast<DerivedT &>( *this );
        };

        auto required() -> DerivedT & {
            m_optionality = Optionality::Required;
            return static_cast<DerivedT &>( *this );
        };

        auto isOptional() const -> bool {
            return m_optionality == Optionality::Optional;
        }

        auto cardinality() const -> size_t override {
            if( m_ref->isContainer() )
                return 0;
            else
                return 1;
        }

        auto hint() const -> std::string { return m_hint; }
    };

    class ExeName : public ComposableParserImpl<ExeName> {
        std::shared_ptr<std::string> m_name;
        std::shared_ptr<BoundValueRefBase> m_ref;

        template<typename LambdaT>
        static auto makeRef(LambdaT const &lambda) -> std::shared_ptr<BoundValueRefBase> {
            return std::make_shared<BoundLambda<LambdaT>>( lambda) ;
        }

    public:
        ExeName() : m_name( std::make_shared<std::string>( "<executable>" ) ) {}

        explicit ExeName( std::string &ref ) : ExeName() {
            m_ref = std::make_shared<BoundValueRef<std::string>>( ref );
        }

        template<typename LambdaT>
        explicit ExeName( LambdaT const& lambda ) : ExeName() {
            m_ref = std::make_shared<BoundLambda<LambdaT>>( lambda );
        }

        // The exe name is not parsed out of the normal tokens, but is handled specially
        auto parse( std::string const&, TokenStream const &tokens ) const -> InternalParseResult override {
            return InternalParseResult::ok( ParseState( ParseResultType::NoMatch, tokens ) );
        }

        auto name() const -> std::string { return *m_name; }
        auto set( std::string const& newName ) -> ParserResult {

            auto lastSlash = newName.find_last_of( "\\/" );
            auto filename = ( lastSlash == std::string::npos )
                    ? newName
                    : newName.substr( lastSlash+1 );

            *m_name = filename;
            if( m_ref )
                return m_ref->setValue( filename );
            else
                return ParserResult::ok( ParseResultType::Matched );
        }
    };

    class Arg : public ParserRefImpl<Arg> {
    public:
        using ParserRefImpl::ParserRefImpl;

        auto parse( std::string const &, TokenStream const &tokens ) const -> InternalParseResult override {
            auto validationResult = validate();
            if( !validationResult )
                return InternalParseResult( validationResult );

            auto remainingTokens = tokens;
            auto const &token = *remainingTokens;
            if( token.type != TokenType::Argument )
                return InternalParseResult::ok( ParseState( ParseResultType::NoMatch, remainingTokens ) );

            assert( !m_ref->isFlag() );
            auto valueRef = static_cast<detail::BoundValueRefBase*>( m_ref.get() );

            auto result = valueRef->setValue( remainingTokens->token );
            if( !result )
                return InternalParseResult( result );
            else
                return InternalParseResult::ok( ParseState( ParseResultType::Matched, ++remainingTokens ) );
        }
    };

    inline auto normaliseOpt( std::string const &optName ) -> std::string {
#ifdef CATCH_PLATFORM_WINDOWS
        if( optName[0] == '/' )
            return "-" + optName.substr( 1 );
        else
#endif
            return optName;
    }

    class Opt : public ParserRefImpl<Opt> {
    protected:
        std::vector<std::string> m_optNames;

    public:
        template<typename LambdaT>
        explicit Opt( LambdaT const &ref ) : ParserRefImpl( std::make_shared<BoundFlagLambda<LambdaT>>( ref ) ) {}

        explicit Opt( bool &ref ) : ParserRefImpl( std::make_shared<BoundFlagRef>( ref ) ) {}

        template<typename LambdaT>
        Opt( LambdaT const &ref, std::string const &hint ) : ParserRefImpl( ref, hint ) {}

        template<typename T>
        Opt( T &ref, std::string const &hint ) : ParserRefImpl( ref, hint ) {}

        auto operator[]( std::string const &optName ) -> Opt & {
            m_optNames.push_back( optName );
            return *this;
        }

        auto getHelpColumns() const -> std::vector<HelpColumns> {
            std::ostringstream oss;
            bool first = true;
            for( auto const &opt : m_optNames ) {
                if (first)
                    first = false;
                else
                    oss << ", ";
                oss << opt;
            }
            if( !m_hint.empty() )
                oss << " <" << m_hint << ">";
            return { { oss.str(), m_description } };
        }

        auto isMatch( std::string const &optToken ) const -> bool {
            auto normalisedToken = normaliseOpt( optToken );
            for( auto const &name : m_optNames ) {
                if( normaliseOpt( name ) == normalisedToken )
                    return true;
            }
            return false;
        }

        using ParserBase::parse;

        auto parse( std::string const&, TokenStream const &tokens ) const -> InternalParseResult override {
            auto validationResult = validate();
            if( !validationResult )
                return InternalParseResult( validationResult );

            auto remainingTokens = tokens;
            if( remainingTokens && remainingTokens->type == TokenType::Option ) {
                auto const &token = *remainingTokens;
                if( isMatch(token.token ) ) {
                    if( m_ref->isFlag() ) {
                        auto flagRef = static_cast<detail::BoundFlagRefBase*>( m_ref.get() );
                        auto result = flagRef->setFlag( true );
                        if( !result )
                            return InternalParseResult( result );
                        if( result.value() == ParseResultType::ShortCircuitAll )
                            return InternalParseResult::ok( ParseState( result.value(), remainingTokens ) );
                    } else {
                        auto valueRef = static_cast<detail::BoundValueRefBase*>( m_ref.get() );
                        ++remainingTokens;
                        if( !remainingTokens )
                            return InternalParseResult::runtimeError( "Expected argument following " + token.token );
                        auto const &argToken = *remainingTokens;
                        if( argToken.type != TokenType::Argument )
                            return InternalParseResult::runtimeError( "Expected argument following " + token.token );
                        auto result = valueRef->setValue( argToken.token );
                        if( !result )
                            return InternalParseResult( result );
                        if( result.value() == ParseResultType::ShortCircuitAll )
                            return InternalParseResult::ok( ParseState( result.value(), remainingTokens ) );
                    }
                    return InternalParseResult::ok( ParseState( ParseResultType::Matched, ++remainingTokens ) );
                }
            }
            return InternalParseResult::ok( ParseState( ParseResultType::NoMatch, remainingTokens ) );
        }

        auto validate() const -> Result override {
            if( m_optNames.empty() )
                return Result::logicError( "No options supplied to Opt" );
            for( auto const &name : m_optNames ) {
                if( name.empty() )
                    return Result::logicError( "Option name cannot be empty" );
#ifdef CATCH_PLATFORM_WINDOWS
                if( name[0] != '-' && name[0] != '/' )
                    return Result::logicError( "Option name must begin with '-' or '/'" );
#else
                if( name[0] != '-' )
                    return Result::logicError( "Option name must begin with '-'" );
#endif
            }
            return ParserRefImpl::validate();
        }
    };

    struct Help : Opt {
        Help( bool &showHelpFlag )
        :   Opt([&]( bool flag ) {
                showHelpFlag = flag;
                return ParserResult::ok( ParseResultType::ShortCircuitAll );
            })
        {
            static_cast<Opt &>( *this )
                    ("display usage information")
                    ["-?"]["-h"]["--help"]
                    .optional();
        }
    };

    struct Parser : ParserBase {

        mutable ExeName m_exeName;
        std::vector<Opt> m_options;
        std::vector<Arg> m_args;

        auto operator|=( ExeName const &exeName ) -> Parser & {
            m_exeName = exeName;
            return *this;
        }

        auto operator|=( Arg const &arg ) -> Parser & {
            m_args.push_back(arg);
            return *this;
        }

        auto operator|=( Opt const &opt ) -> Parser & {
            m_options.push_back(opt);
            return *this;
        }

        auto operator|=( Parser const &other ) -> Parser & {
            m_options.insert(m_options.end(), other.m_options.begin(), other.m_options.end());
            m_args.insert(m_args.end(), other.m_args.begin(), other.m_args.end());
            return *this;
        }

        template<typename T>
        auto operator|( T const &other ) const -> Parser {
            return Parser( *this ) |= other;
        }

        // Forward deprecated interface with '+' instead of '|'
        template<typename T>
        auto operator+=( T const &other ) -> Parser & { return operator|=( other ); }
        template<typename T>
        auto operator+( T const &other ) const -> Parser { return operator|( other ); }

        auto getHelpColumns() const -> std::vector<HelpColumns> {
            std::vector<HelpColumns> cols;
            for (auto const &o : m_options) {
                auto childCols = o.getHelpColumns();
                cols.insert( cols.end(), childCols.begin(), childCols.end() );
            }
            return cols;
        }

        void writeToStream( std::ostream &os ) const {
            if (!m_exeName.name().empty()) {
                os << "usage:\n" << "  " << m_exeName.name() << " ";
                bool required = true, first = true;
                for( auto const &arg : m_args ) {
                    if (first)
                        first = false;
                    else
                        os << " ";
                    if( arg.isOptional() && required ) {
                        os << "[";
                        required = false;
                    }
                    os << "<" << arg.hint() << ">";
                    if( arg.cardinality() == 0 )
                        os << " ... ";
                }
                if( !required )
                    os << "]";
                if( !m_options.empty() )
                    os << " options";
                os << "\n\nwhere options are:" << std::endl;
            }

            auto rows = getHelpColumns();
            size_t consoleWidth = CATCH_CLARA_CONFIG_CONSOLE_WIDTH;
            size_t optWidth = 0;
            for( auto const &cols : rows )
                optWidth = (std::max)(optWidth, cols.left.size() + 2);

            optWidth = (std::min)(optWidth, consoleWidth/2);

            for( auto const &cols : rows ) {
                auto row =
                        TextFlow::Column( cols.left ).width( optWidth ).indent( 2 ) +
                        TextFlow::Spacer(4) +
                        TextFlow::Column( cols.right ).width( consoleWidth - 7 - optWidth );
                os << row << std::endl;
            }
        }

        friend auto operator<<( std::ostream &os, Parser const &parser ) -> std::ostream& {
            parser.writeToStream( os );
            return os;
        }

        auto validate() const -> Result override {
            for( auto const &opt : m_options ) {
                auto result = opt.validate();
                if( !result )
                    return result;
            }
            for( auto const &arg : m_args ) {
                auto result = arg.validate();
                if( !result )
                    return result;
            }
            return Result::ok();
        }

        using ParserBase::parse;

        auto parse( std::string const& exeName, TokenStream const &tokens ) const -> InternalParseResult override {

            struct ParserInfo {
                ParserBase const* parser = nullptr;
                size_t count = 0;
            };
            const size_t totalParsers = m_options.size() + m_args.size();
            assert( totalParsers < 512 );
            // ParserInfo parseInfos[totalParsers]; // <-- this is what we really want to do
            ParserInfo parseInfos[512];

            {
                size_t i = 0;
                for (auto const &opt : m_options) parseInfos[i++].parser = &opt;
                for (auto const &arg : m_args) parseInfos[i++].parser = &arg;
            }

            m_exeName.set( exeName );

            auto result = InternalParseResult::ok( ParseState( ParseResultType::NoMatch, tokens ) );
            while( result.value().remainingTokens() ) {
                bool tokenParsed = false;

                for( size_t i = 0; i < totalParsers; ++i ) {
                    auto&  parseInfo = parseInfos[i];
                    if( parseInfo.parser->cardinality() == 0 || parseInfo.count < parseInfo.parser->cardinality() ) {
                        result = parseInfo.parser->parse(exeName, result.value().remainingTokens());
                        if (!result)
                            return result;
                        if (result.value().type() != ParseResultType::NoMatch) {
                            tokenParsed = true;
                            ++parseInfo.count;
                            break;
                        }
                    }
                }

                if( result.value().type() == ParseResultType::ShortCircuitAll )
                    return result;
                if( !tokenParsed )
                    return InternalParseResult::runtimeError( "Unrecognised token: " + result.value().remainingTokens()->token );
            }
            // !TBD Check missing required options
            return result;
        }
    };

    template<typename DerivedT>
    template<typename T>
    auto ComposableParserImpl<DerivedT>::operator|( T const &other ) const -> Parser {
        return Parser() | static_cast<DerivedT const &>( *this ) | other;
    }
} // namespace detail

// A Combined parser
using detail::Parser;

// A parser for options
using detail::Opt;

// A parser for arguments
using detail::Arg;

// Wrapper for argc, argv from main()
using detail::Args;

// Specifies the name of the executable
using detail::ExeName;

// Convenience wrapper for option parser that specifies the help option
using detail::Help;

// enum of result types from a parse
using detail::ParseResultType;

// Result type for parser operation
using detail::ParserResult;

}} // namespace Catch::clara

// end clara.hpp
#ifdef __clang__
#pragma clang diagnostic pop
#endif

// Restore Clara's value for console width, if present
#ifdef CATCH_TEMP_CLARA_CONFIG_CONSOLE_WIDTH
#define CATCH_CLARA_TEXTFLOW_CONFIG_CONSOLE_WIDTH CATCH_TEMP_CLARA_CONFIG_CONSOLE_WIDTH
#undef CATCH_TEMP_CLARA_CONFIG_CONSOLE_WIDTH
#endif

// end catch_clara.h
namespace Catch {

    clara::Parser makeCommandLineParser( ConfigData& config );

} // end namespace Catch

// end catch_commandline.h
#include <fstream>
#include <ctime>

namespace Catch {

    clara::Parser makeCommandLineParser( ConfigData& config ) {

        using namespace clara;

        auto const setWarning = [&]( std::string const& warning ) {
                auto warningSet = [&]() {
                    if( warning == "NoAssertions" )
                        return WarnAbout::NoAssertions;

                    if ( warning == "NoTests" )
                        return WarnAbout::NoTests;

                    return WarnAbout::Nothing;
                }();

                if (warningSet == WarnAbout::Nothing)
                    return ParserResult::runtimeError( "Unrecognised warning: '" + warning + "'" );
                config.warnings = static_cast<WarnAbout::What>( config.warnings | warningSet );
                return ParserResult::ok( ParseResultType::Matched );
            };
        auto const loadTestNamesFromFile = [&]( std::string const& filename ) {
                std::ifstream f( filename.c_str() );
                if( !f.is_open() )
                    return ParserResult::runtimeError( "Unable to load input file: '" + filename + "'" );

                std::string line;
                while( std::getline( f, line ) ) {
                    line = trim(line);
                    if( !line.empty() && !startsWith( line, '#' ) ) {
                        if( !startsWith( line, '"' ) )
                            line = '"' + line + '"';
                        config.testsOrTags.push_back( line );
                        config.testsOrTags.emplace_back( "," );
                    }
                }
                //Remove comma in the end
                if(!config.testsOrTags.empty())
                    config.testsOrTags.erase( config.testsOrTags.end()-1 );

                return ParserResult::ok( ParseResultType::Matched );
            };
        auto const setTestOrder = [&]( std::string const& order ) {
                if( startsWith( "declared", order ) )
                    config.runOrder = RunTests::InDeclarationOrder;
                else if( startsWith( "lexical", order ) )
                    config.runOrder = RunTests::InLexicographicalOrder;
                else if( startsWith( "random", order ) )
                    config.runOrder = RunTests::InRandomOrder;
                else
                    return clara::ParserResult::runtimeError( "Unrecognised ordering: '" + order + "'" );
                return ParserResult::ok( ParseResultType::Matched );
            };
        auto const setRngSeed = [&]( std::string const& seed ) {
                if( seed != "time" )
                    return clara::detail::convertInto( seed, config.rngSeed );
                config.rngSeed = static_cast<unsigned int>( std::time(nullptr) );
                return ParserResult::ok( ParseResultType::Matched );
            };
        auto const setColourUsage = [&]( std::string const& useColour ) {
                    auto mode = toLower( useColour );

                    if( mode == "yes" )
                        config.useColour = UseColour::Yes;
                    else if( mode == "no" )
                        config.useColour = UseColour::No;
                    else if( mode == "auto" )
                        config.useColour = UseColour::Auto;
                    else
                        return ParserResult::runtimeError( "colour mode must be one of: auto, yes or no. '" + useColour + "' not recognised" );
                return ParserResult::ok( ParseResultType::Matched );
            };
        auto const setWaitForKeypress = [&]( std::string const& keypress ) {
                auto keypressLc = toLower( keypress );
                if (keypressLc == "never")
                    config.waitForKeypress = WaitForKeypress::Never;
                else if( keypressLc == "start" )
                    config.waitForKeypress = WaitForKeypress::BeforeStart;
                else if( keypressLc == "exit" )
                    config.waitForKeypress = WaitForKeypress::BeforeExit;
                else if( keypressLc == "both" )
                    config.waitForKeypress = WaitForKeypress::BeforeStartAndExit;
                else
                    return ParserResult::runtimeError( "keypress argument must be one of: never, start, exit or both. '" + keypress + "' not recognised" );
            return ParserResult::ok( ParseResultType::Matched );
            };
        auto const setVerbosity = [&]( std::string const& verbosity ) {
            auto lcVerbosity = toLower( verbosity );
            if( lcVerbosity == "quiet" )
                config.verbosity = Verbosity::Quiet;
            else if( lcVerbosity == "normal" )
                config.verbosity = Verbosity::Normal;
            else if( lcVerbosity == "high" )
                config.verbosity = Verbosity::High;
            else
                return ParserResult::runtimeError( "Unrecognised verbosity, '" + verbosity + "'" );
            return ParserResult::ok( ParseResultType::Matched );
        };
        auto const setReporter = [&]( std::string const& reporter ) {
            IReporterRegistry::FactoryMap const& factories = getRegistryHub().getReporterRegistry().getFactories();

            auto lcReporter = toLower( reporter );
            auto result = factories.find( lcReporter );

            if( factories.end() != result )
                config.reporterName = lcReporter;
            else
                return ParserResult::runtimeError( "Unrecognized reporter, '" + reporter + "'. Check available with --list-reporters" );
            return ParserResult::ok( ParseResultType::Matched );
        };

        auto cli
            = ExeName( config.processName )
            | Help( config.showHelp )
            | Opt( config.listTests )
                ["-l"]["--list-tests"]
                ( "list all/matching test cases" )
            | Opt( config.listTags )
                ["-t"]["--list-tags"]
                ( "list all/matching tags" )
            | Opt( config.showSuccessfulTests )
                ["-s"]["--success"]
                ( "include successful tests in output" )
            | Opt( config.shouldDebugBreak )
                ["-b"]["--break"]
                ( "break into debugger on failure" )
            | Opt( config.noThrow )
                ["-e"]["--nothrow"]
                ( "skip exception tests" )
            | Opt( config.showInvisibles )
                ["-i"]["--invisibles"]
                ( "show invisibles (tabs, newlines)" )
            | Opt( config.outputFilename, "filename" )
                ["-o"]["--out"]
                ( "output filename" )
            | Opt( setReporter, "name" )
                ["-r"]["--reporter"]
                ( "reporter to use (defaults to console)" )
            | Opt( config.name, "name" )
                ["-n"]["--name"]
                ( "suite name" )
            | Opt( [&]( bool ){ config.abortAfter = 1; } )
                ["-a"]["--abort"]
                ( "abort at first failure" )
            | Opt( [&]( int x ){ config.abortAfter = x; }, "no. failures" )
                ["-x"]["--abortx"]
                ( "abort after x failures" )
            | Opt( setWarning, "warning name" )
                ["-w"]["--warn"]
                ( "enable warnings" )
            | Opt( [&]( bool flag ) { config.showDurations = flag ? ShowDurations::Always : ShowDurations::Never; }, "yes|no" )
                ["-d"]["--durations"]
                ( "show test durations" )
            | Opt( config.minDuration, "seconds" )
                ["-D"]["--min-duration"]
                ( "show test durations for tests taking at least the given number of seconds" )
            | Opt( loadTestNamesFromFile, "filename" )
                ["-f"]["--input-file"]
                ( "load test names to run from a file" )
            | Opt( config.filenamesAsTags )
                ["-#"]["--filenames-as-tags"]
                ( "adds a tag for the filename" )
            | Opt( config.sectionsToRun, "section name" )
                ["-c"]["--section"]
                ( "specify section to run" )
            | Opt( setVerbosity, "quiet|normal|high" )
                ["-v"]["--verbosity"]
                ( "set output verbosity" )
            | Opt( config.listTestNamesOnly )
                ["--list-test-names-only"]
                ( "list all/matching test cases names only" )
            | Opt( config.listReporters )
                ["--list-reporters"]
                ( "list all reporters" )
            | Opt( setTestOrder, "decl|lex|rand" )
                ["--order"]
                ( "test case order (defaults to decl)" )
            | Opt( setRngSeed, "'time'|number" )
                ["--rng-seed"]
                ( "set a specific seed for random numbers" )
            | Opt( setColourUsage, "yes|no" )
                ["--use-colour"]
                ( "should output be colourised" )
            | Opt( config.libIdentify )
                ["--libidentify"]
                ( "report name and version according to libidentify standard" )
            | Opt( setWaitForKeypress, "never|start|exit|both" )
                ["--wait-for-keypress"]
                ( "waits for a keypress before exiting" )
            | Opt( config.benchmarkSamples, "samples" )
                ["--benchmark-samples"]
                ( "number of samples to collect (default: 100)" )
            | Opt( config.benchmarkResamples, "resamples" )
                ["--benchmark-resamples"]
                ( "number of resamples for the bootstrap (default: 100000)" )
            | Opt( config.benchmarkConfidenceInterval, "confidence interval" )
                ["--benchmark-confidence-interval"]
                ( "confidence interval for the bootstrap (between 0 and 1, default: 0.95)" )
            | Opt( config.benchmarkNoAnalysis )
                ["--benchmark-no-analysis"]
                ( "perform only measurements; do not perform any analysis" )
            | Opt( config.benchmarkWarmupTime, "benchmarkWarmupTime" )
                ["--benchmark-warmup-time"]
                ( "amount of time in milliseconds spent on warming up each test (default: 100)" )
            | Arg( config.testsOrTags, "test name|pattern|tags" )
                ( "which test or tests to use" );

        return cli;
    }

} // end namespace Catch
// end catch_commandline.cpp
// start catch_common.cpp

#include <cstring>
#include <ostream>

namespace Catch {

    bool SourceLineInfo::operator == ( SourceLineInfo const& other ) const noexcept {
        return line == other.line && (file == other.file || std::strcmp(file, other.file) == 0);
    }
    bool SourceLineInfo::operator < ( SourceLineInfo const& other ) const noexcept {
        // We can assume that the same file will usually have the same pointer.
        // Thus, if the pointers are the same, there is no point in calling the strcmp
        return line < other.line || ( line == other.line && file != other.file && (std::strcmp(file, other.file) < 0));
    }

    std::ostream& operator << ( std::ostream& os, SourceLineInfo const& info ) {
#ifndef __GNUG__
        os << info.file << '(' << info.line << ')';
#else
        os << info.file << ':' << info.line;
#endif
        return os;
    }

    std::string StreamEndStop::operator+() const {
        return std::string();
    }

    NonCopyable::NonCopyable() = default;
    NonCopyable::~NonCopyable() = default;

}
// end catch_common.cpp
// start catch_config.cpp

namespace Catch {

    Config::Config( ConfigData const& data )
    :   m_data( data ),
        m_stream( openStream() )
    {
        // We need to trim filter specs to avoid trouble with superfluous
        // whitespace (esp. important for bdd macros, as those are manually
        // aligned with whitespace).

        for (auto& elem : m_data.testsOrTags) {
            elem = trim(elem);
        }
        for (auto& elem : m_data.sectionsToRun) {
            elem = trim(elem);
        }

        TestSpecParser parser(ITagAliasRegistry::get());
        if (!m_data.testsOrTags.empty()) {
            m_hasTestFilters = true;
            for (auto const& testOrTags : m_data.testsOrTags) {
                parser.parse(testOrTags);
            }
        }
        m_testSpec = parser.testSpec();
    }

    std::string const& Config::getFilename() const {
        return m_data.outputFilename ;
    }

    bool Config::listTests() const          { return m_data.listTests; }
    bool Config::listTestNamesOnly() const  { return m_data.listTestNamesOnly; }
    bool Config::listTags() const           { return m_data.listTags; }
    bool Config::listReporters() const      { return m_data.listReporters; }

    std::string Config::getProcessName() const { return m_data.processName; }
    std::string const& Config::getReporterName() const { return m_data.reporterName; }

    std::vector<std::string> const& Config::getTestsOrTags() const { return m_data.testsOrTags; }
    std::vector<std::string> const& Config::getSectionsToRun() const { return m_data.sectionsToRun; }

    TestSpec const& Config::testSpec() const { return m_testSpec; }
    bool Config::hasTestFilters() const { return m_hasTestFilters; }

    bool Config::showHelp() const { return m_data.showHelp; }

    // IConfig interface
    bool Config::allowThrows() const                   { return !m_data.noThrow; }
    std::ostream& Config::stream() const               { return m_stream->stream(); }
    std::string Config::name() const                   { return m_data.name.empty() ? m_data.processName : m_data.name; }
    bool Config::includeSuccessfulResults() const      { return m_data.showSuccessfulTests; }
    bool Config::warnAboutMissingAssertions() const    { return !!(m_data.warnings & WarnAbout::NoAssertions); }
    bool Config::warnAboutNoTests() const              { return !!(m_data.warnings & WarnAbout::NoTests); }
    ShowDurations::OrNot Config::showDurations() const { return m_data.showDurations; }
    double Config::minDuration() const                 { return m_data.minDuration; }
    RunTests::InWhatOrder Config::runOrder() const     { return m_data.runOrder; }
    unsigned int Config::rngSeed() const               { return m_data.rngSeed; }
    UseColour::YesOrNo Config::useColour() const       { return m_data.useColour; }
    bool Config::shouldDebugBreak() const              { return m_data.shouldDebugBreak; }
    int Config::abortAfter() const                     { return m_data.abortAfter; }
    bool Config::showInvisibles() const                { return m_data.showInvisibles; }
    Verbosity Config::verbosity() const                { return m_data.verbosity; }

    bool Config::benchmarkNoAnalysis() const                      { return m_data.benchmarkNoAnalysis; }
    int Config::benchmarkSamples() const                          { return m_data.benchmarkSamples; }
    double Config::benchmarkConfidenceInterval() const            { return m_data.benchmarkConfidenceInterval; }
    unsigned int Config::benchmarkResamples() const               { return m_data.benchmarkResamples; }
    std::chrono::milliseconds Config::benchmarkWarmupTime() const { return std::chrono::milliseconds(m_data.benchmarkWarmupTime); }

    IStream const* Config::openStream() {
        return Catch::makeStream(m_data.outputFilename);
    }

} // end namespace Catch
// end catch_config.cpp
// start catch_console_colour.cpp

#if defined(__clang__)
#    pragma clang diagnostic push
#    pragma clang diagnostic ignored "-Wexit-time-destructors"
#endif

// start catch_errno_guard.h

namespace Catch {

    class ErrnoGuard {
    public:
        ErrnoGuard();
        ~ErrnoGuard();
    private:
        int m_oldErrno;
    };

}

// end catch_errno_guard.h
#include <sstream>

namespace Catch {
    namespace {

        struct IColourImpl {
            virtual ~IColourImpl() = default;
            virtual void use( Colour::Code _colourCode ) = 0;
        };

        struct NoColourImpl : IColourImpl {
            void use( Colour::Code ) override {}

            static IColourImpl* instance() {
                static NoColourImpl s_instance;
                return &s_instance;
            }
        };

    } // anon namespace
} // namespace Catch

#if !defined( CATCH_CONFIG_COLOUR_NONE ) && !defined( CATCH_CONFIG_COLOUR_WINDOWS ) && !defined( CATCH_CONFIG_COLOUR_ANSI )
#   ifdef CATCH_PLATFORM_WINDOWS
#       define CATCH_CONFIG_COLOUR_WINDOWS
#   else
#       define CATCH_CONFIG_COLOUR_ANSI
#   endif
#endif

#if defined ( CATCH_CONFIG_COLOUR_WINDOWS ) /////////////////////////////////////////

namespace Catch {
namespace {

    class Win32ColourImpl : public IColourImpl {
    public:
        Win32ColourImpl() : stdoutHandle( GetStdHandle(STD_OUTPUT_HANDLE) )
        {
            CONSOLE_SCREEN_BUFFER_INFO csbiInfo;
            GetConsoleScreenBufferInfo( stdoutHandle, &csbiInfo );
            originalForegroundAttributes = csbiInfo.wAttributes & ~( BACKGROUND_GREEN | BACKGROUND_RED | BACKGROUND_BLUE | BACKGROUND_INTENSITY );
            originalBackgroundAttributes = csbiInfo.wAttributes & ~( FOREGROUND_GREEN | FOREGROUND_RED | FOREGROUND_BLUE | FOREGROUND_INTENSITY );
        }

        void use( Colour::Code _colourCode ) override {
            switch( _colourCode ) {
                case Colour::None:      return setTextAttribute( originalForegroundAttributes );
                case Colour::White:     return setTextAttribute( FOREGROUND_GREEN | FOREGROUND_RED | FOREGROUND_BLUE );
                case Colour::Red:       return setTextAttribute( FOREGROUND_RED );
                case Colour::Green:     return setTextAttribute( FOREGROUND_GREEN );
                case Colour::Blue:      return setTextAttribute( FOREGROUND_BLUE );
                case Colour::Cyan:      return setTextAttribute( FOREGROUND_BLUE | FOREGROUND_GREEN );
                case Colour::Yellow:    return setTextAttribute( FOREGROUND_RED | FOREGROUND_GREEN );
                case Colour::Grey:      return setTextAttribute( 0 );

                case Colour::LightGrey:     return setTextAttribute( FOREGROUND_INTENSITY );
                case Colour::BrightRed:     return setTextAttribute( FOREGROUND_INTENSITY | FOREGROUND_RED );
                case Colour::BrightGreen:   return setTextAttribute( FOREGROUND_INTENSITY | FOREGROUND_GREEN );
                case Colour::BrightWhite:   return setTextAttribute( FOREGROUND_INTENSITY | FOREGROUND_GREEN | FOREGROUND_RED | FOREGROUND_BLUE );
                case Colour::BrightYellow:  return setTextAttribute( FOREGROUND_INTENSITY | FOREGROUND_RED | FOREGROUND_GREEN );

                case Colour::Bright: CATCH_INTERNAL_ERROR( "not a colour" );

                default:
                    CATCH_ERROR( "Unknown colour requested" );
            }
        }

    private:
        void setTextAttribute( WORD _textAttribute ) {
            SetConsoleTextAttribute( stdoutHandle, _textAttribute | originalBackgroundAttributes );
        }
        HANDLE stdoutHandle;
        WORD originalForegroundAttributes;
        WORD originalBackgroundAttributes;
    };

    IColourImpl* platformColourInstance() {
        static Win32ColourImpl s_instance;

        IConfigPtr config = getCurrentContext().getConfig();
        UseColour::YesOrNo colourMode = config
            ? config->useColour()
            : UseColour::Auto;
        if( colourMode == UseColour::Auto )
            colourMode = UseColour::Yes;
        return colourMode == UseColour::Yes
            ? &s_instance
            : NoColourImpl::instance();
    }

} // end anon namespace
} // end namespace Catch

#elif defined( CATCH_CONFIG_COLOUR_ANSI ) //////////////////////////////////////

#include <unistd.h>

namespace Catch {
namespace {

    // use POSIX/ ANSI console terminal codes
    // Thanks to Adam Strzelecki for original contribution
    // (http://github.com/nanoant)
    // https://github.com/philsquared/Catch/pull/131
    class PosixColourImpl : public IColourImpl {
    public:
        void use( Colour::Code _colourCode ) override {
            switch( _colourCode ) {
                case Colour::None:
                case Colour::White:     return setColour( "[0m" );
                case Colour::Red:       return setColour( "[0;31m" );
                case Colour::Green:     return setColour( "[0;32m" );
                case Colour::Blue:      return setColour( "[0;34m" );
                case Colour::Cyan:      return setColour( "[0;36m" );
                case Colour::Yellow:    return setColour( "[0;33m" );
                case Colour::Grey:      return setColour( "[1;30m" );

                case Colour::LightGrey:     return setColour( "[0;37m" );
                case Colour::BrightRed:     return setColour( "[1;31m" );
                case Colour::BrightGreen:   return setColour( "[1;32m" );
                case Colour::BrightWhite:   return setColour( "[1;37m" );
                case Colour::BrightYellow:  return setColour( "[1;33m" );

                case Colour::Bright: CATCH_INTERNAL_ERROR( "not a colour" );
                default: CATCH_INTERNAL_ERROR( "Unknown colour requested" );
            }
        }
        static IColourImpl* instance() {
            static PosixColourImpl s_instance;
            return &s_instance;
        }

    private:
        void setColour( const char* _escapeCode ) {
            getCurrentContext().getConfig()->stream()
                << '\033' << _escapeCode;
        }
    };

    bool useColourOnPlatform() {
        return
#if defined(CATCH_PLATFORM_MAC) || defined(CATCH_PLATFORM_IPHONE)
            !isDebuggerActive() &&
#endif
#if !(defined(__DJGPP__) && defined(__STRICT_ANSI__))
            isatty(STDOUT_FILENO)
#else
            false
#endif
            ;
    }
    IColourImpl* platformColourInstance() {
        ErrnoGuard guard;
        IConfigPtr config = getCurrentContext().getConfig();
        UseColour::YesOrNo colourMode = config
            ? config->useColour()
            : UseColour::Auto;
        if( colourMode == UseColour::Auto )
            colourMode = useColourOnPlatform()
                ? UseColour::Yes
                : UseColour::No;
        return colourMode == UseColour::Yes
            ? PosixColourImpl::instance()
            : NoColourImpl::instance();
    }

} // end anon namespace
} // end namespace Catch

#else  // not Windows or ANSI ///////////////////////////////////////////////

namespace Catch {

    static IColourImpl* platformColourInstance() { return NoColourImpl::instance(); }

} // end namespace Catch

#endif // Windows/ ANSI/ None

namespace Catch {

    Colour::Colour( Code _colourCode ) { use( _colourCode ); }
    Colour::Colour( Colour&& other ) noexcept {
        m_moved = other.m_moved;
        other.m_moved = true;
    }
    Colour& Colour::operator=( Colour&& other ) noexcept {
        m_moved = other.m_moved;
        other.m_moved  = true;
        return *this;
    }

    Colour::~Colour(){ if( !m_moved ) use( None ); }

    void Colour::use( Code _colourCode ) {
        static IColourImpl* impl = platformColourInstance();
        // Strictly speaking, this cannot possibly happen.
        // However, under some conditions it does happen (see #1626),
        // and this change is small enough that we can let practicality
        // triumph over purity in this case.
        if (impl != nullptr) {
            impl->use( _colourCode );
        }
    }

    std::ostream& operator << ( std::ostream& os, Colour const& ) {
        return os;
    }

} // end namespace Catch

#if defined(__clang__)
#    pragma clang diagnostic pop
#endif

// end catch_console_colour.cpp
// start catch_context.cpp

namespace Catch {

    class Context : public IMutableContext, NonCopyable {

    public: // IContext
        IResultCapture* getResultCapture() override {
            return m_resultCapture;
        }
        IRunner* getRunner() override {
            return m_runner;
        }

        IConfigPtr const& getConfig() const override {
            return m_config;
        }

        ~Context() override;

    public: // IMutableContext
        void setResultCapture( IResultCapture* resultCapture ) override {
            m_resultCapture = resultCapture;
        }
        void setRunner( IRunner* runner ) override {
            m_runner = runner;
        }
        void setConfig( IConfigPtr const& config ) override {
            m_config = config;
        }

        friend IMutableContext& getCurrentMutableContext();

    private:
        IConfigPtr m_config;
        IRunner* m_runner = nullptr;
        IResultCapture* m_resultCapture = nullptr;
    };

    IMutableContext *IMutableContext::currentContext = nullptr;

    void IMutableContext::createContext()
    {
        currentContext = new Context();
    }

    void cleanUpContext() {
        delete IMutableContext::currentContext;
        IMutableContext::currentContext = nullptr;
    }
    IContext::~IContext() = default;
    IMutableContext::~IMutableContext() = default;
    Context::~Context() = default;

    SimplePcg32& rng() {
        static SimplePcg32 s_rng;
        return s_rng;
    }

}
// end catch_context.cpp
// start catch_debug_console.cpp

// start catch_debug_console.h

#include <string>

namespace Catch {
    void writeToDebugConsole( std::string const& text );
}

// end catch_debug_console.h
#if defined(CATCH_CONFIG_ANDROID_LOGWRITE)
#include <android/log.h>

    namespace Catch {
        void writeToDebugConsole( std::string const& text ) {
            __android_log_write( ANDROID_LOG_DEBUG, "Catch", text.c_str() );
        }
    }

#elif defined(CATCH_PLATFORM_WINDOWS)

    namespace Catch {
        void writeToDebugConsole( std::string const& text ) {
            ::OutputDebugStringA( text.c_str() );
        }
    }

#else

    namespace Catch {
        void writeToDebugConsole( std::string const& text ) {
            // !TBD: Need a version for Mac/ XCode and other IDEs
            Catch::cout() << text;
        }
    }

#endif // Platform
// end catch_debug_console.cpp
// start catch_debugger.cpp

#if defined(CATCH_PLATFORM_MAC) || defined(CATCH_PLATFORM_IPHONE)

#  include <cassert>
#  include <sys/types.h>
#  include <unistd.h>
#  include <cstddef>
#  include <ostream>

#ifdef __apple_build_version__
    // These headers will only compile with AppleClang (XCode)
    // For other compilers (Clang, GCC, ... ) we need to exclude them
#  include <sys/sysctl.h>
#endif

    namespace Catch {
        #ifdef __apple_build_version__
        // The following function is taken directly from the following technical note:
        // https://developer.apple.com/library/archive/qa/qa1361/_index.html

        // Returns true if the current process is being debugged (either
        // running under the debugger or has a debugger attached post facto).
        bool isDebuggerActive(){
            int                 mib[4];
            struct kinfo_proc   info;
            std::size_t         size;

            // Initialize the flags so that, if sysctl fails for some bizarre
            // reason, we get a predictable result.

            info.kp_proc.p_flag = 0;

            // Initialize mib, which tells sysctl the info we want, in this case
            // we're looking for information about a specific process ID.

            mib[0] = CTL_KERN;
            mib[1] = KERN_PROC;
            mib[2] = KERN_PROC_PID;
            mib[3] = getpid();

            // Call sysctl.

            size = sizeof(info);
            if( sysctl(mib, sizeof(mib) / sizeof(*mib), &info, &size, nullptr, 0) != 0 ) {
                Catch::cerr() << "\n** Call to sysctl failed - unable to determine if debugger is active **\n" << std::endl;
                return false;
            }

            // We're being debugged if the P_TRACED flag is set.

            return ( (info.kp_proc.p_flag & P_TRACED) != 0 );
        }
        #else
        bool isDebuggerActive() {
            // We need to find another way to determine this for non-appleclang compilers on macOS
            return false;
        }
        #endif
    } // namespace Catch

#elif defined(CATCH_PLATFORM_LINUX)
    #include <fstream>
    #include <string>

    namespace Catch{
        // The standard POSIX way of detecting a debugger is to attempt to
        // ptrace() the process, but this needs to be done from a child and not
        // this process itself to still allow attaching to this process later
        // if wanted, so is rather heavy. Under Linux we have the PID of the
        // "debugger" (which doesn't need to be gdb, of course, it could also
        // be strace, for example) in /proc/$PID/status, so just get it from
        // there instead.
        bool isDebuggerActive(){
            // Libstdc++ has a bug, where std::ifstream sets errno to 0
            // This way our users can properly assert over errno values
            ErrnoGuard guard;
            std::ifstream in("/proc/self/status");
            for( std::string line; std::getline(in, line); ) {
                static const int PREFIX_LEN = 11;
                if( line.compare(0, PREFIX_LEN, "TracerPid:\t") == 0 ) {
                    // We're traced if the PID is not 0 and no other PID starts
                    // with 0 digit, so it's enough to check for just a single
                    // character.
                    return line.length() > PREFIX_LEN && line[PREFIX_LEN] != '0';
                }
            }

            return false;
        }
    } // namespace Catch
#elif defined(_MSC_VER)
    extern "C" __declspec(dllimport) int __stdcall IsDebuggerPresent();
    namespace Catch {
        bool isDebuggerActive() {
            return IsDebuggerPresent() != 0;
        }
    }
#elif defined(__MINGW32__)
    extern "C" __declspec(dllimport) int __stdcall IsDebuggerPresent();
    namespace Catch {
        bool isDebuggerActive() {
            return IsDebuggerPresent() != 0;
        }
    }
#else
    namespace Catch {
       bool isDebuggerActive() { return false; }
    }
#endif // Platform
// end catch_debugger.cpp
// start catch_decomposer.cpp

namespace Catch {

    ITransientExpression::~ITransientExpression() = default;

    void formatReconstructedExpression( std::ostream &os, std::string const& lhs, StringRef op, std::string const& rhs ) {
        if( lhs.size() + rhs.size() < 40 &&
                lhs.find('\n') == std::string::npos &&
                rhs.find('\n') == std::string::npos )
            os << lhs << " " << op << " " << rhs;
        else
            os << lhs << "\n" << op << "\n" << rhs;
    }
}
// end catch_decomposer.cpp
// start catch_enforce.cpp

#include <stdexcept>

namespace Catch {
#if defined(CATCH_CONFIG_DISABLE_EXCEPTIONS) && !defined(CATCH_CONFIG_DISABLE_EXCEPTIONS_CUSTOM_HANDLER)
    [[noreturn]]
    void throw_exception(std::exception const& e) {
        Catch::cerr() << "Catch will terminate because it needed to throw an exception.\n"
                      << "The message was: " << e.what() << '\n';
        std::terminate();
    }
#endif

    [[noreturn]]
    void throw_logic_error(std::string const& msg) {
        throw_exception(std::logic_error(msg));
    }

    [[noreturn]]
    void throw_domain_error(std::string const& msg) {
        throw_exception(std::domain_error(msg));
    }

    [[noreturn]]
    void throw_runtime_error(std::string const& msg) {
        throw_exception(std::runtime_error(msg));
    }

} // namespace Catch;
// end catch_enforce.cpp
// start catch_enum_values_registry.cpp
// start catch_enum_values_registry.h

#include <vector>
#include <memory>

namespace Catch {

    namespace Detail {

        std::unique_ptr<EnumInfo> makeEnumInfo( StringRef enumName, StringRef allValueNames, std::vector<int> const& values );

        class EnumValuesRegistry : public IMutableEnumValuesRegistry {

            std::vector<std::unique_ptr<EnumInfo>> m_enumInfos;

            EnumInfo const& registerEnum( StringRef enumName, StringRef allEnums, std::vector<int> const& values) override;
        };

        std::vector<StringRef> parseEnums( StringRef enums );

    } // Detail

} // Catch

// end catch_enum_values_registry.h

#include <map>
#include <cassert>

namespace Catch {

    IMutableEnumValuesRegistry::~IMutableEnumValuesRegistry() {}

    namespace Detail {

        namespace {
            // Extracts the actual name part of an enum instance
            // In other words, it returns the Blue part of Bikeshed::Colour::Blue
            StringRef extractInstanceName(StringRef enumInstance) {
                // Find last occurence of ":"
                size_t name_start = enumInstance.size();
                while (name_start > 0 && enumInstance[name_start - 1] != ':') {
                    --name_start;
                }
                return enumInstance.substr(name_start, enumInstance.size() - name_start);
            }
        }

        std::vector<StringRef> parseEnums( StringRef enums ) {
            auto enumValues = splitStringRef( enums, ',' );
            std::vector<StringRef> parsed;
            parsed.reserve( enumValues.size() );
            for( auto const& enumValue : enumValues ) {
                parsed.push_back(trim(extractInstanceName(enumValue)));
            }
            return parsed;
        }

        EnumInfo::~EnumInfo() {}

        StringRef EnumInfo::lookup( int value ) const {
            for( auto const& valueToName : m_values ) {
                if( valueToName.first == value )
                    return valueToName.second;
            }
            return "{** unexpected enum value **}"_sr;
        }

        std::unique_ptr<EnumInfo> makeEnumInfo( StringRef enumName, StringRef allValueNames, std::vector<int> const& values ) {
            std::unique_ptr<EnumInfo> enumInfo( new EnumInfo );
            enumInfo->m_name = enumName;
            enumInfo->m_values.reserve( values.size() );

            const auto valueNames = Catch::Detail::parseEnums( allValueNames );
            assert( valueNames.size() == values.size() );
            std::size_t i = 0;
            for( auto value : values )
                enumInfo->m_values.emplace_back(value, valueNames[i++]);

            return enumInfo;
        }

        EnumInfo const& EnumValuesRegistry::registerEnum( StringRef enumName, StringRef allValueNames, std::vector<int> const& values ) {
            m_enumInfos.push_back(makeEnumInfo(enumName, allValueNames, values));
            return *m_enumInfos.back();
        }

    } // Detail
} // Catch

// end catch_enum_values_registry.cpp
// start catch_errno_guard.cpp

#include <cerrno>

namespace Catch {
        ErrnoGuard::ErrnoGuard():m_oldErrno(errno){}
        ErrnoGuard::~ErrnoGuard() { errno = m_oldErrno; }
}
// end catch_errno_guard.cpp
// start catch_exception_translator_registry.cpp

// start catch_exception_translator_registry.h

#include <vector>
#include <string>
#include <memory>

namespace Catch {

    class ExceptionTranslatorRegistry : public IExceptionTranslatorRegistry {
    public:
        ~ExceptionTranslatorRegistry();
        virtual void registerTranslator( const IExceptionTranslator* translator );
        std::string translateActiveException() const override;
        std::string tryTranslators() const;

    private:
        std::vector<std::unique_ptr<IExceptionTranslator const>> m_translators;
    };
}

// end catch_exception_translator_registry.h
#ifdef __OBJC__
#import "Foundation/Foundation.h"
#endif

namespace Catch {

    ExceptionTranslatorRegistry::~ExceptionTranslatorRegistry() {
    }

    void ExceptionTranslatorRegistry::registerTranslator( const IExceptionTranslator* translator ) {
        m_translators.push_back( std::unique_ptr<const IExceptionTranslator>( translator ) );
    }

#if !defined(CATCH_CONFIG_DISABLE_EXCEPTIONS)
    std::string ExceptionTranslatorRegistry::translateActiveException() const {
        try {
#ifdef __OBJC__
            // In Objective-C try objective-c exceptions first
            @try {
                return tryTranslators();
            }
            @catch (NSException *exception) {
                return Catch::Detail::stringify( [exception description] );
            }
#else
            // Compiling a mixed mode project with MSVC means that CLR
            // exceptions will be caught in (...) as well. However, these
            // do not fill-in std::current_exception and thus lead to crash
            // when attempting rethrow.
            // /EHa switch also causes structured exceptions to be caught
            // here, but they fill-in current_exception properly, so
            // at worst the output should be a little weird, instead of
            // causing a crash.
            if (std::current_exception() == nullptr) {
                return "Non C++ exception. Possibly a CLR exception.";
            }
            return tryTranslators();
#endif
        }
        catch( TestFailureException& ) {
            std::rethrow_exception(std::current_exception());
        }
        catch( std::exception& ex ) {
            return ex.what();
        }
        catch( std::string& msg ) {
            return msg;
        }
        catch( const char* msg ) {
            return msg;
        }
        catch(...) {
            return "Unknown exception";
        }
    }

    std::string ExceptionTranslatorRegistry::tryTranslators() const {
        if (m_translators.empty()) {
            std::rethrow_exception(std::current_exception());
        } else {
            return m_translators[0]->translate(m_translators.begin() + 1, m_translators.end());
        }
    }

#else // ^^ Exceptions are enabled // Exceptions are disabled vv
    std::string ExceptionTranslatorRegistry::translateActiveException() const {
        CATCH_INTERNAL_ERROR("Attempted to translate active exception under CATCH_CONFIG_DISABLE_EXCEPTIONS!");
    }

    std::string ExceptionTranslatorRegistry::tryTranslators() const {
        CATCH_INTERNAL_ERROR("Attempted to use exception translators under CATCH_CONFIG_DISABLE_EXCEPTIONS!");
    }
#endif

}
// end catch_exception_translator_registry.cpp
// start catch_fatal_condition.cpp

#if defined(__GNUC__)
#    pragma GCC diagnostic push
#    pragma GCC diagnostic ignored "-Wmissing-field-initializers"
#endif

#if defined( CATCH_CONFIG_WINDOWS_SEH ) || defined( CATCH_CONFIG_POSIX_SIGNALS )

namespace {
    // Report the error condition
    void reportFatal( char const * const message ) {
        Catch::getCurrentContext().getResultCapture()->handleFatalErrorCondition( message );
    }
}

#endif // signals/SEH handling

#if defined( CATCH_CONFIG_WINDOWS_SEH )

namespace Catch {
    struct SignalDefs { DWORD id; const char* name; };

    // There is no 1-1 mapping between signals and windows exceptions.
    // Windows can easily distinguish between SO and SigSegV,
    // but SigInt, SigTerm, etc are handled differently.
    static SignalDefs signalDefs[] = {
        { static_cast<DWORD>(EXCEPTION_ILLEGAL_INSTRUCTION),  "SIGILL - Illegal instruction signal" },
        { static_cast<DWORD>(EXCEPTION_STACK_OVERFLOW), "SIGSEGV - Stack overflow" },
        { static_cast<DWORD>(EXCEPTION_ACCESS_VIOLATION), "SIGSEGV - Segmentation violation signal" },
        { static_cast<DWORD>(EXCEPTION_INT_DIVIDE_BY_ZERO), "Divide by zero error" },
    };

    LONG CALLBACK FatalConditionHandler::handleVectoredException(PEXCEPTION_POINTERS ExceptionInfo) {
        for (auto const& def : signalDefs) {
            if (ExceptionInfo->ExceptionRecord->ExceptionCode == def.id) {
                reportFatal(def.name);
            }
        }
        // If its not an exception we care about, pass it along.
        // This stops us from eating debugger breaks etc.
        return EXCEPTION_CONTINUE_SEARCH;
    }

    FatalConditionHandler::FatalConditionHandler() {
        isSet = true;
        // 32k seems enough for Catch to handle stack overflow,
        // but the value was found experimentally, so there is no strong guarantee
        guaranteeSize = 32 * 1024;
        exceptionHandlerHandle = nullptr;
        // Register as first handler in current chain
        exceptionHandlerHandle = AddVectoredExceptionHandler(1, handleVectoredException);
        // Pass in guarantee size to be filled
        SetThreadStackGuarantee(&guaranteeSize);
    }

    void FatalConditionHandler::reset() {
        if (isSet) {
            RemoveVectoredExceptionHandler(exceptionHandlerHandle);
            SetThreadStackGuarantee(&guaranteeSize);
            exceptionHandlerHandle = nullptr;
            isSet = false;
        }
    }

    FatalConditionHandler::~FatalConditionHandler() {
        reset();
    }

bool FatalConditionHandler::isSet = false;
ULONG FatalConditionHandler::guaranteeSize = 0;
PVOID FatalConditionHandler::exceptionHandlerHandle = nullptr;

} // namespace Catch

#elif defined( CATCH_CONFIG_POSIX_SIGNALS )

namespace Catch {

    struct SignalDefs {
        int id;
        const char* name;
    };

    // 32kb for the alternate stack seems to be sufficient. However, this value
    // is experimentally determined, so that's not guaranteed.
    static constexpr std::size_t sigStackSize = 32768 >= MINSIGSTKSZ ? 32768 : MINSIGSTKSZ;

    static SignalDefs signalDefs[] = {
        { SIGINT,  "SIGINT - Terminal interrupt signal" },
        { SIGILL,  "SIGILL - Illegal instruction signal" },
        { SIGFPE,  "SIGFPE - Floating point error signal" },
        { SIGSEGV, "SIGSEGV - Segmentation violation signal" },
        { SIGTERM, "SIGTERM - Termination request signal" },
        { SIGABRT, "SIGABRT - Abort (abnormal termination) signal" }
    };

    void FatalConditionHandler::handleSignal( int sig ) {
        char const * name = "<unknown signal>";
        for (auto const& def : signalDefs) {
            if (sig == def.id) {
                name = def.name;
                break;
            }
        }
        reset();
        reportFatal(name);
        raise( sig );
    }

    FatalConditionHandler::FatalConditionHandler() {
        isSet = true;
        stack_t sigStack;
        sigStack.ss_sp = altStackMem;
        sigStack.ss_size = sigStackSize;
        sigStack.ss_flags = 0;
        sigaltstack(&sigStack, &oldSigStack);
        struct sigaction sa = { };

        sa.sa_handler = handleSignal;
        sa.sa_flags = SA_ONSTACK;
        for (std::size_t i = 0; i < sizeof(signalDefs)/sizeof(SignalDefs); ++i) {
            sigaction(signalDefs[i].id, &sa, &oldSigActions[i]);
        }
    }

    FatalConditionHandler::~FatalConditionHandler() {
        reset();
    }

    void FatalConditionHandler::reset() {
        if( isSet ) {
            // Set signals back to previous values -- hopefully nobody overwrote them in the meantime
            for( std::size_t i = 0; i < sizeof(signalDefs)/sizeof(SignalDefs); ++i ) {
                sigaction(signalDefs[i].id, &oldSigActions[i], nullptr);
            }
            // Return the old stack
            sigaltstack(&oldSigStack, nullptr);
            isSet = false;
        }
    }

    bool FatalConditionHandler::isSet = false;
    struct sigaction FatalConditionHandler::oldSigActions[sizeof(signalDefs)/sizeof(SignalDefs)] = {};
    stack_t FatalConditionHandler::oldSigStack = {};
    char FatalConditionHandler::altStackMem[sigStackSize] = {};

} // namespace Catch

#else

namespace Catch {
    void FatalConditionHandler::reset() {}
}

#endif // signals/SEH handling

#if defined(__GNUC__)
#    pragma GCC diagnostic pop
#endif
// end catch_fatal_condition.cpp
// start catch_generators.cpp

#include <limits>
#include <set>

namespace Catch {

IGeneratorTracker::~IGeneratorTracker() {}

const char* GeneratorException::what() const noexcept {
    return m_msg;
}

namespace Generators {

    GeneratorUntypedBase::~GeneratorUntypedBase() {}

    auto acquireGeneratorTracker( StringRef generatorName, SourceLineInfo const& lineInfo ) -> IGeneratorTracker& {
        return getResultCapture().acquireGeneratorTracker( generatorName, lineInfo );
    }

} // namespace Generators
} // namespace Catch
// end catch_generators.cpp
// start catch_interfaces_capture.cpp

namespace Catch {
    IResultCapture::~IResultCapture() = default;
}
// end catch_interfaces_capture.cpp
// start catch_interfaces_config.cpp

namespace Catch {
    IConfig::~IConfig() = default;
}
// end catch_interfaces_config.cpp
// start catch_interfaces_exception.cpp

namespace Catch {
    IExceptionTranslator::~IExceptionTranslator() = default;
    IExceptionTranslatorRegistry::~IExceptionTranslatorRegistry() = default;
}
// end catch_interfaces_exception.cpp
// start catch_interfaces_registry_hub.cpp

namespace Catch {
    IRegistryHub::~IRegistryHub() = default;
    IMutableRegistryHub::~IMutableRegistryHub() = default;
}
// end catch_interfaces_registry_hub.cpp
// start catch_interfaces_reporter.cpp

// start catch_reporter_listening.h

namespace Catch {

    class ListeningReporter : public IStreamingReporter {
        using Reporters = std::vector<IStreamingReporterPtr>;
        Reporters m_listeners;
        IStreamingReporterPtr m_reporter = nullptr;
        ReporterPreferences m_preferences;

    public:
        ListeningReporter();

        void addListener( IStreamingReporterPtr&& listener );
        void addReporter( IStreamingReporterPtr&& reporter );

    public: // IStreamingReporter

        ReporterPreferences getPreferences() const override;

        void noMatchingTestCases( std::string const& spec ) override;

        void reportInvalidArguments(std::string const&arg) override;

        static std::set<Verbosity> getSupportedVerbosities();

#if defined(CATCH_CONFIG_ENABLE_BENCHMARKING)
        void benchmarkPreparing(std::string const& name) override;
        void benchmarkStarting( BenchmarkInfo const& benchmarkInfo ) override;
        void benchmarkEnded( BenchmarkStats<> const& benchmarkStats ) override;
        void benchmarkFailed(std::string const&) override;
#endif // CATCH_CONFIG_ENABLE_BENCHMARKING

        void testRunStarting( TestRunInfo const& testRunInfo ) override;
        void testGroupStarting( GroupInfo const& groupInfo ) override;
        void testCaseStarting( TestCaseInfo const& testInfo ) override;
        void sectionStarting( SectionInfo const& sectionInfo ) override;
        void assertionStarting( AssertionInfo const& assertionInfo ) override;

        // The return value indicates if the messages buffer should be cleared:
        bool assertionEnded( AssertionStats const& assertionStats ) override;
        void sectionEnded( SectionStats const& sectionStats ) override;
        void testCaseEnded( TestCaseStats const& testCaseStats ) override;
        void testGroupEnded( TestGroupStats const& testGroupStats ) override;
        void testRunEnded( TestRunStats const& testRunStats ) override;

        void skipTest( TestCaseInfo const& testInfo ) override;
        bool isMulti() const override;

    };

} // end namespace Catch

// end catch_reporter_listening.h
namespace Catch {

    ReporterConfig::ReporterConfig( IConfigPtr const& _fullConfig )
    :   m_stream( &_fullConfig->stream() ), m_fullConfig( _fullConfig ) {}

    ReporterConfig::ReporterConfig( IConfigPtr const& _fullConfig, std::ostream& _stream )
    :   m_stream( &_stream ), m_fullConfig( _fullConfig ) {}

    std::ostream& ReporterConfig::stream() const { return *m_stream; }
    IConfigPtr ReporterConfig::fullConfig() const { return m_fullConfig; }

    TestRunInfo::TestRunInfo( std::string const& _name ) : name( _name ) {}

    GroupInfo::GroupInfo(  std::string const& _name,
                           std::size_t _groupIndex,
                           std::size_t _groupsCount )
    :   name( _name ),
        groupIndex( _groupIndex ),
        groupsCounts( _groupsCount )
    {}

     AssertionStats::AssertionStats( AssertionResult const& _assertionResult,
                                     std::vector<MessageInfo> const& _infoMessages,
                                     Totals const& _totals )
    :   assertionResult( _assertionResult ),
        infoMessages( _infoMessages ),
        totals( _totals )
    {
        assertionResult.m_resultData.lazyExpression.m_transientExpression = _assertionResult.m_resultData.lazyExpression.m_transientExpression;

        if( assertionResult.hasMessage() ) {
            // Copy message into messages list.
            // !TBD This should have been done earlier, somewhere
            MessageBuilder builder( assertionResult.getTestMacroName(), assertionResult.getSourceInfo(), assertionResult.getResultType() );
            builder << assertionResult.getMessage();
            builder.m_info.message = builder.m_stream.str();

            infoMessages.push_back( builder.m_info );
        }
    }

     AssertionStats::~AssertionStats() = default;

    SectionStats::SectionStats(  SectionInfo const& _sectionInfo,
                                 Counts const& _assertions,
                                 double _durationInSeconds,
                                 bool _missingAssertions )
    :   sectionInfo( _sectionInfo ),
        assertions( _assertions ),
        durationInSeconds( _durationInSeconds ),
        missingAssertions( _missingAssertions )
    {}

    SectionStats::~SectionStats() = default;

    TestCaseStats::TestCaseStats(  TestCaseInfo const& _testInfo,
                                   Totals const& _totals,
                                   std::string const& _stdOut,
                                   std::string const& _stdErr,
                                   bool _aborting )
    : testInfo( _testInfo ),
        totals( _totals ),
        stdOut( _stdOut ),
        stdErr( _stdErr ),
        aborting( _aborting )
    {}

    TestCaseStats::~TestCaseStats() = default;

    TestGroupStats::TestGroupStats( GroupInfo const& _groupInfo,
                                    Totals const& _totals,
                                    bool _aborting )
    :   groupInfo( _groupInfo ),
        totals( _totals ),
        aborting( _aborting )
    {}

    TestGroupStats::TestGroupStats( GroupInfo const& _groupInfo )
    :   groupInfo( _groupInfo ),
        aborting( false )
    {}

    TestGroupStats::~TestGroupStats() = default;

    TestRunStats::TestRunStats(   TestRunInfo const& _runInfo,
                    Totals const& _totals,
                    bool _aborting )
    :   runInfo( _runInfo ),
        totals( _totals ),
        aborting( _aborting )
    {}

    TestRunStats::~TestRunStats() = default;

    void IStreamingReporter::fatalErrorEncountered( StringRef ) {}
    bool IStreamingReporter::isMulti() const { return false; }

    IReporterFactory::~IReporterFactory() = default;
    IReporterRegistry::~IReporterRegistry() = default;

} // end namespace Catch
// end catch_interfaces_reporter.cpp
// start catch_interfaces_runner.cpp

namespace Catch {
    IRunner::~IRunner() = default;
}
// end catch_interfaces_runner.cpp
// start catch_interfaces_testcase.cpp

namespace Catch {
    ITestInvoker::~ITestInvoker() = default;
    ITestCaseRegistry::~ITestCaseRegistry() = default;
}
// end catch_interfaces_testcase.cpp
// start catch_leak_detector.cpp

#ifdef CATCH_CONFIG_WINDOWS_CRTDBG
#include <crtdbg.h>

namespace Catch {

    LeakDetector::LeakDetector() {
        int flag = _CrtSetDbgFlag(_CRTDBG_REPORT_FLAG);
        flag |= _CRTDBG_LEAK_CHECK_DF;
        flag |= _CRTDBG_ALLOC_MEM_DF;
        _CrtSetDbgFlag(flag);
        _CrtSetReportMode(_CRT_WARN, _CRTDBG_MODE_FILE | _CRTDBG_MODE_DEBUG);
        _CrtSetReportFile(_CRT_WARN, _CRTDBG_FILE_STDERR);
        // Change this to leaking allocation's number to break there
        _CrtSetBreakAlloc(-1);
    }
}

#else

    Catch::LeakDetector::LeakDetector() {}

#endif

Catch::LeakDetector::~LeakDetector() {
    Catch::cleanUp();
}
// end catch_leak_detector.cpp
// start catch_list.cpp

// start catch_list.h

#include <set>

namespace Catch {

    std::size_t listTests( Config const& config );

    std::size_t listTestsNamesOnly( Config const& config );

    struct TagInfo {
        void add( std::string const& spelling );
        std::string all() const;

        std::set<std::string> spellings;
        std::size_t count = 0;
    };

    std::size_t listTags( Config const& config );

    std::size_t listReporters();

    Option<std::size_t> list( std::shared_ptr<Config> const& config );

} // end namespace Catch

// end catch_list.h
// start catch_text.h

namespace Catch {
    using namespace clara::TextFlow;
}

// end catch_text.h
#include <limits>
#include <algorithm>
#include <iomanip>

namespace Catch {

    std::size_t listTests( Config const& config ) {
        TestSpec const& testSpec = config.testSpec();
        if( config.hasTestFilters() )
            Catch::cout() << "Matching test cases:\n";
        else {
            Catch::cout() << "All available test cases:\n";
        }

        auto matchedTestCases = filterTests( getAllTestCasesSorted( config ), testSpec, config );
        for( auto const& testCaseInfo : matchedTestCases ) {
            Colour::Code colour = testCaseInfo.isHidden()
                ? Colour::SecondaryText
                : Colour::None;
            Colour colourGuard( colour );

            Catch::cout() << Column( testCaseInfo.name ).initialIndent( 2 ).indent( 4 ) << "\n";
            if( config.verbosity() >= Verbosity::High ) {
                Catch::cout() << Column( Catch::Detail::stringify( testCaseInfo.lineInfo ) ).indent(4) << std::endl;
                std::string description = testCaseInfo.description;
                if( description.empty() )
                    description = "(NO DESCRIPTION)";
                Catch::cout() << Column( description ).indent(4) << std::endl;
            }
            if( !testCaseInfo.tags.empty() )
                Catch::cout() << Column( testCaseInfo.tagsAsString() ).indent( 6 ) << "\n";
        }

        if( !config.hasTestFilters() )
            Catch::cout() << pluralise( matchedTestCases.size(), "test case" ) << '\n' << std::endl;
        else
            Catch::cout() << pluralise( matchedTestCases.size(), "matching test case" ) << '\n' << std::endl;
        return matchedTestCases.size();
    }

    std::size_t listTestsNamesOnly( Config const& config ) {
        TestSpec const& testSpec = config.testSpec();
        std::size_t matchedTests = 0;
        std::vector<TestCase> matchedTestCases = filterTests( getAllTestCasesSorted( config ), testSpec, config );
        for( auto const& testCaseInfo : matchedTestCases ) {
            matchedTests++;
            if( startsWith( testCaseInfo.name, '#' ) )
               Catch::cout() << '"' << testCaseInfo.name << '"';
            else
               Catch::cout() << testCaseInfo.name;
            if ( config.verbosity() >= Verbosity::High )
                Catch::cout() << "\t@" << testCaseInfo.lineInfo;
            Catch::cout() << std::endl;
        }
        return matchedTests;
    }

    void TagInfo::add( std::string const& spelling ) {
        ++count;
        spellings.insert( spelling );
    }

    std::string TagInfo::all() const {
        size_t size = 0;
        for (auto const& spelling : spellings) {
            // Add 2 for the brackes
            size += spelling.size() + 2;
        }

        std::string out; out.reserve(size);
        for (auto const& spelling : spellings) {
            out += '[';
            out += spelling;
            out += ']';
        }
        return out;
    }

    std::size_t listTags( Config const& config ) {
        TestSpec const& testSpec = config.testSpec();
        if( config.hasTestFilters() )
            Catch::cout() << "Tags for matching test cases:\n";
        else {
            Catch::cout() << "All available tags:\n";
        }

        std::map<std::string, TagInfo> tagCounts;

        std::vector<TestCase> matchedTestCases = filterTests( getAllTestCasesSorted( config ), testSpec, config );
        for( auto const& testCase : matchedTestCases ) {
            for( auto const& tagName : testCase.getTestCaseInfo().tags ) {
                std::string lcaseTagName = toLower( tagName );
                auto countIt = tagCounts.find( lcaseTagName );
                if( countIt == tagCounts.end() )
                    countIt = tagCounts.insert( std::make_pair( lcaseTagName, TagInfo() ) ).first;
                countIt->second.add( tagName );
            }
        }

        for( auto const& tagCount : tagCounts ) {
            ReusableStringStream rss;
            rss << "  " << std::setw(2) << tagCount.second.count << "  ";
            auto str = rss.str();
            auto wrapper = Column( tagCount.second.all() )
                                                    .initialIndent( 0 )
                                                    .indent( str.size() )
                                                    .width( CATCH_CONFIG_CONSOLE_WIDTH-10 );
            Catch::cout() << str << wrapper << '\n';
        }
        Catch::cout() << pluralise( tagCounts.size(), "tag" ) << '\n' << std::endl;
        return tagCounts.size();
    }

    std::size_t listReporters() {
        Catch::cout() << "Available reporters:\n";
        IReporterRegistry::FactoryMap const& factories = getRegistryHub().getReporterRegistry().getFactories();
        std::size_t maxNameLen = 0;
        for( auto const& factoryKvp : factories )
            maxNameLen = (std::max)( maxNameLen, factoryKvp.first.size() );

        for( auto const& factoryKvp : factories ) {
            Catch::cout()
                    << Column( factoryKvp.first + ":" )
                            .indent(2)
                            .width( 5+maxNameLen )
                    +  Column( factoryKvp.second->getDescription() )
                            .initialIndent(0)
                            .indent(2)
                            .width( CATCH_CONFIG_CONSOLE_WIDTH - maxNameLen-8 )
                    << "\n";
        }
        Catch::cout() << std::endl;
        return factories.size();
    }

    Option<std::size_t> list( std::shared_ptr<Config> const& config ) {
        Option<std::size_t> listedCount;
        getCurrentMutableContext().setConfig( config );
        if( config->listTests() )
            listedCount = listedCount.valueOr(0) + listTests( *config );
        if( config->listTestNamesOnly() )
            listedCount = listedCount.valueOr(0) + listTestsNamesOnly( *config );
        if( config->listTags() )
            listedCount = listedCount.valueOr(0) + listTags( *config );
        if( config->listReporters() )
            listedCount = listedCount.valueOr(0) + listReporters();
        return listedCount;
    }

} // end namespace Catch
// end catch_list.cpp
// start catch_matchers.cpp

namespace Catch {
namespace Matchers {
    namespace Impl {

        std::string MatcherUntypedBase::toString() const {
            if( m_cachedToString.empty() )
                m_cachedToString = describe();
            return m_cachedToString;
        }

        MatcherUntypedBase::~MatcherUntypedBase() = default;

    } // namespace Impl
} // namespace Matchers

using namespace Matchers;
using Matchers::Impl::MatcherBase;

} // namespace Catch
// end catch_matchers.cpp
// start catch_matchers_exception.cpp

namespace Catch {
namespace Matchers {
namespace Exception {

bool ExceptionMessageMatcher::match(std::exception const& ex) const {
    return ex.what() == m_message;
}

std::string ExceptionMessageMatcher::describe() const {
    return "exception message matches \"" + m_message + "\"";
}

}
Exception::ExceptionMessageMatcher Message(std::string const& message) {
    return Exception::ExceptionMessageMatcher(message);
}

// namespace Exception
} // namespace Matchers
} // namespace Catch
// end catch_matchers_exception.cpp
// start catch_matchers_floating.cpp

// start catch_polyfills.hpp

namespace Catch {
    bool isnan(float f);
    bool isnan(double d);
}

// end catch_polyfills.hpp
// start catch_to_string.hpp

#include <string>

namespace Catch {
    template <typename T>
    std::string to_string(T const& t) {
#if defined(CATCH_CONFIG_CPP11_TO_STRING)
        return std::to_string(t);
#else
        ReusableStringStream rss;
        rss << t;
        return rss.str();
#endif
    }
} // end namespace Catch

// end catch_to_string.hpp
#include <algorithm>
#include <cmath>
#include <cstdlib>
#include <cstdint>
#include <cstring>
#include <sstream>
#include <type_traits>
#include <iomanip>
#include <limits>

namespace Catch {
namespace {

    int32_t convert(float f) {
        static_assert(sizeof(float) == sizeof(int32_t), "Important ULP matcher assumption violated");
        int32_t i;
        std::memcpy(&i, &f, sizeof(f));
        return i;
    }

    int64_t convert(double d) {
        static_assert(sizeof(double) == sizeof(int64_t), "Important ULP matcher assumption violated");
        int64_t i;
        std::memcpy(&i, &d, sizeof(d));
        return i;
    }

    template <typename FP>
    bool almostEqualUlps(FP lhs, FP rhs, uint64_t maxUlpDiff) {
        // Comparison with NaN should always be false.
        // This way we can rule it out before getting into the ugly details
        if (Catch::isnan(lhs) || Catch::isnan(rhs)) {
            return false;
        }

        auto lc = convert(lhs);
        auto rc = convert(rhs);

        if ((lc < 0) != (rc < 0)) {
            // Potentially we can have +0 and -0
            return lhs == rhs;
        }

        auto ulpDiff = std::abs(lc - rc);
        return static_cast<uint64_t>(ulpDiff) <= maxUlpDiff;
    }

#if defined(CATCH_CONFIG_GLOBAL_NEXTAFTER)

    float nextafter(float x, float y) {
        return ::nextafterf(x, y);
    }

    double nextafter(double x, double y) {
        return ::nextafter(x, y);
    }

#endif // ^^^ CATCH_CONFIG_GLOBAL_NEXTAFTER ^^^

template <typename FP>
FP step(FP start, FP direction, uint64_t steps) {
    for (uint64_t i = 0; i < steps; ++i) {
#if defined(CATCH_CONFIG_GLOBAL_NEXTAFTER)
        start = Catch::nextafter(start, direction);
#else
        start = std::nextafter(start, direction);
#endif
    }
    return start;
}

// Performs equivalent check of std::fabs(lhs - rhs) <= margin
// But without the subtraction to allow for INFINITY in comparison
bool marginComparison(double lhs, double rhs, double margin) {
    return (lhs + margin >= rhs) && (rhs + margin >= lhs);
}

template <typename FloatingPoint>
void write(std::ostream& out, FloatingPoint num) {
    out << std::scientific
        << std::setprecision(std::numeric_limits<FloatingPoint>::max_digits10 - 1)
        << num;
}

} // end anonymous namespace

namespace Matchers {
namespace Floating {

    enum class FloatingPointKind : uint8_t {
        Float,
        Double
    };

    WithinAbsMatcher::WithinAbsMatcher(double target, double margin)
        :m_target{ target }, m_margin{ margin } {
        CATCH_ENFORCE(margin >= 0, "Invalid margin: " << margin << '.'
            << " Margin has to be non-negative.");
    }

    // Performs equivalent check of std::fabs(lhs - rhs) <= margin
    // But without the subtraction to allow for INFINITY in comparison
    bool WithinAbsMatcher::match(double const& matchee) const {
        return (matchee + m_margin >= m_target) && (m_target + m_margin >= matchee);
    }

    std::string WithinAbsMatcher::describe() const {
        return "is within " + ::Catch::Detail::stringify(m_margin) + " of " + ::Catch::Detail::stringify(m_target);
    }

    WithinUlpsMatcher::WithinUlpsMatcher(double target, uint64_t ulps, FloatingPointKind baseType)
        :m_target{ target }, m_ulps{ ulps }, m_type{ baseType } {
        CATCH_ENFORCE(m_type == FloatingPointKind::Double
                   || m_ulps < (std::numeric_limits<uint32_t>::max)(),
            "Provided ULP is impossibly large for a float comparison.");
    }

#if defined(__clang__)
#pragma clang diagnostic push
// Clang <3.5 reports on the default branch in the switch below
#pragma clang diagnostic ignored "-Wunreachable-code"
#endif

    bool WithinUlpsMatcher::match(double const& matchee) const {
        switch (m_type) {
        case FloatingPointKind::Float:
            return almostEqualUlps<float>(static_cast<float>(matchee), static_cast<float>(m_target), m_ulps);
        case FloatingPointKind::Double:
            return almostEqualUlps<double>(matchee, m_target, m_ulps);
        default:
            CATCH_INTERNAL_ERROR( "Unknown FloatingPointKind value" );
        }
    }

#if defined(__clang__)
#pragma clang diagnostic pop
#endif

    std::string WithinUlpsMatcher::describe() const {
        std::stringstream ret;

        ret << "is within " << m_ulps << " ULPs of ";

        if (m_type == FloatingPointKind::Float) {
            write(ret, static_cast<float>(m_target));
            ret << 'f';
        } else {
            write(ret, m_target);
        }

        ret << " ([";
        if (m_type == FloatingPointKind::Double) {
            write(ret, step(m_target, static_cast<double>(-INFINITY), m_ulps));
            ret << ", ";
            write(ret, step(m_target, static_cast<double>( INFINITY), m_ulps));
        } else {
            // We have to cast INFINITY to float because of MinGW, see #1782
            write(ret, step(static_cast<float>(m_target), static_cast<float>(-INFINITY), m_ulps));
            ret << ", ";
            write(ret, step(static_cast<float>(m_target), static_cast<float>( INFINITY), m_ulps));
        }
        ret << "])";

        return ret.str();
    }

    WithinRelMatcher::WithinRelMatcher(double target, double epsilon):
        m_target(target),
        m_epsilon(epsilon){
        CATCH_ENFORCE(m_epsilon >= 0., "Relative comparison with epsilon <  0 does not make sense.");
        CATCH_ENFORCE(m_epsilon  < 1., "Relative comparison with epsilon >= 1 does not make sense.");
    }

    bool WithinRelMatcher::match(double const& matchee) const {
        const auto relMargin = m_epsilon * (std::max)(std::fabs(matchee), std::fabs(m_target));
        return marginComparison(matchee, m_target,
                                std::isinf(relMargin)? 0 : relMargin);
    }

    std::string WithinRelMatcher::describe() const {
        Catch::ReusableStringStream sstr;
        sstr << "and " << m_target << " are within " << m_epsilon * 100. << "% of each other";
        return sstr.str();
    }

}// namespace Floating

Floating::WithinUlpsMatcher WithinULP(double target, uint64_t maxUlpDiff) {
    return Floating::WithinUlpsMatcher(target, maxUlpDiff, Floating::FloatingPointKind::Double);
}

Floating::WithinUlpsMatcher WithinULP(float target, uint64_t maxUlpDiff) {
    return Floating::WithinUlpsMatcher(target, maxUlpDiff, Floating::FloatingPointKind::Float);
}

Floating::WithinAbsMatcher WithinAbs(double target, double margin) {
    return Floating::WithinAbsMatcher(target, margin);
}

Floating::WithinRelMatcher WithinRel(double target, double eps) {
    return Floating::WithinRelMatcher(target, eps);
}

Floating::WithinRelMatcher WithinRel(double target) {
    return Floating::WithinRelMatcher(target, std::numeric_limits<double>::epsilon() * 100);
}

Floating::WithinRelMatcher WithinRel(float target, float eps) {
    return Floating::WithinRelMatcher(target, eps);
}

Floating::WithinRelMatcher WithinRel(float target) {
    return Floating::WithinRelMatcher(target, std::numeric_limits<float>::epsilon() * 100);
}

} // namespace Matchers
} // namespace Catch

// end catch_matchers_floating.cpp
// start catch_matchers_generic.cpp

std::string Catch::Matchers::Generic::Detail::finalizeDescription(const std::string& desc) {
    if (desc.empty()) {
        return "matches undescribed predicate";
    } else {
        return "matches predicate: \"" + desc + '"';
    }
}
// end catch_matchers_generic.cpp
// start catch_matchers_string.cpp

#include <regex>

namespace Catch {
namespace Matchers {

    namespace StdString {

        CasedString::CasedString( std::string const& str, CaseSensitive::Choice caseSensitivity )
        :   m_caseSensitivity( caseSensitivity ),
            m_str( adjustString( str ) )
        {}
        std::string CasedString::adjustString( std::string const& str ) const {
            return m_caseSensitivity == CaseSensitive::No
                   ? toLower( str )
                   : str;
        }
        std::string CasedString::caseSensitivitySuffix() const {
            return m_caseSensitivity == CaseSensitive::No
                   ? " (case insensitive)"
                   : std::string();
        }

        StringMatcherBase::StringMatcherBase( std::string const& operation, CasedString const& comparator )
        : m_comparator( comparator ),
          m_operation( operation ) {
        }

        std::string StringMatcherBase::describe() const {
            std::string description;
            description.reserve(5 + m_operation.size() + m_comparator.m_str.size() +
                                        m_comparator.caseSensitivitySuffix().size());
            description += m_operation;
            description += ": \"";
            description += m_comparator.m_str;
            description += "\"";
            description += m_comparator.caseSensitivitySuffix();
            return description;
        }

        EqualsMatcher::EqualsMatcher( CasedString const& comparator ) : StringMatcherBase( "equals", comparator ) {}

        bool EqualsMatcher::match( std::string const& source ) const {
            return m_comparator.adjustString( source ) == m_comparator.m_str;
        }

        ContainsMatcher::ContainsMatcher( CasedString const& comparator ) : StringMatcherBase( "contains", comparator ) {}

        bool ContainsMatcher::match( std::string const& source ) const {
            return contains( m_comparator.adjustString( source ), m_comparator.m_str );
        }

        StartsWithMatcher::StartsWithMatcher( CasedString const& comparator ) : StringMatcherBase( "starts with", comparator ) {}

        bool StartsWithMatcher::match( std::string const& source ) const {
            return startsWith( m_comparator.adjustString( source ), m_comparator.m_str );
        }

        EndsWithMatcher::EndsWithMatcher( CasedString const& comparator ) : StringMatcherBase( "ends with", comparator ) {}

        bool EndsWithMatcher::match( std::string const& source ) const {
            return endsWith( m_comparator.adjustString( source ), m_comparator.m_str );
        }

        RegexMatcher::RegexMatcher(std::string regex, CaseSensitive::Choice caseSensitivity): m_regex(std::move(regex)), m_caseSensitivity(caseSensitivity) {}

        bool RegexMatcher::match(std::string const& matchee) const {
            auto flags = std::regex::ECMAScript; // ECMAScript is the default syntax option anyway
            if (m_caseSensitivity == CaseSensitive::Choice::No) {
                flags |= std::regex::icase;
            }
            auto reg = std::regex(m_regex, flags);
            return std::regex_match(matchee, reg);
        }

        std::string RegexMatcher::describe() const {
            return "matches " + ::Catch::Detail::stringify(m_regex) + ((m_caseSensitivity == CaseSensitive::Choice::Yes)? " case sensitively" : " case insensitively");
        }

    } // namespace StdString

    StdString::EqualsMatcher Equals( std::string const& str, CaseSensitive::Choice caseSensitivity ) {
        return StdString::EqualsMatcher( StdString::CasedString( str, caseSensitivity) );
    }
    StdString::ContainsMatcher Contains( std::string const& str, CaseSensitive::Choice caseSensitivity ) {
        return StdString::ContainsMatcher( StdString::CasedString( str, caseSensitivity) );
    }
    StdString::EndsWithMatcher EndsWith( std::string const& str, CaseSensitive::Choice caseSensitivity ) {
        return StdString::EndsWithMatcher( StdString::CasedString( str, caseSensitivity) );
    }
    StdString::StartsWithMatcher StartsWith( std::string const& str, CaseSensitive::Choice caseSensitivity ) {
        return StdString::StartsWithMatcher( StdString::CasedString( str, caseSensitivity) );
    }

    StdString::RegexMatcher Matches(std::string const& regex, CaseSensitive::Choice caseSensitivity) {
        return StdString::RegexMatcher(regex, caseSensitivity);
    }

} // namespace Matchers
} // namespace Catch
// end catch_matchers_string.cpp
// start catch_message.cpp

// start catch_uncaught_exceptions.h

namespace Catch {
    bool uncaught_exceptions();
} // end namespace Catch

// end catch_uncaught_exceptions.h
#include <cassert>
#include <stack>

namespace Catch {

    MessageInfo::MessageInfo(   StringRef const& _macroName,
                                SourceLineInfo const& _lineInfo,
                                ResultWas::OfType _type )
    :   macroName( _macroName ),
        lineInfo( _lineInfo ),
        type( _type ),
        sequence( ++globalCount )
    {}

    bool MessageInfo::operator==( MessageInfo const& other ) const {
        return sequence == other.sequence;
    }

    bool MessageInfo::operator<( MessageInfo const& other ) const {
        return sequence < other.sequence;
    }

    // This may need protecting if threading support is added
    unsigned int MessageInfo::globalCount = 0;

    ////////////////////////////////////////////////////////////////////////////

    Catch::MessageBuilder::MessageBuilder( StringRef const& macroName,
                                           SourceLineInfo const& lineInfo,
                                           ResultWas::OfType type )
        :m_info(macroName, lineInfo, type) {}

    ////////////////////////////////////////////////////////////////////////////

    ScopedMessage::ScopedMessage( MessageBuilder const& builder )
    : m_info( builder.m_info ), m_moved()
    {
        m_info.message = builder.m_stream.str();
        getResultCapture().pushScopedMessage( m_info );
    }

    ScopedMessage::ScopedMessage( ScopedMessage&& old )
    : m_info( old.m_info ), m_moved()
    {
        old.m_moved = true;
    }

    ScopedMessage::~ScopedMessage() {
        if ( !uncaught_exceptions() && !m_moved ){
            getResultCapture().popScopedMessage(m_info);
        }
    }

    Capturer::Capturer( StringRef macroName, SourceLineInfo const& lineInfo, ResultWas::OfType resultType, StringRef names ) {
        auto trimmed = [&] (size_t start, size_t end) {
            while (names[start] == ',' || isspace(static_cast<unsigned char>(names[start]))) {
                ++start;
            }
            while (names[end] == ',' || isspace(static_cast<unsigned char>(names[end]))) {
                --end;
            }
            return names.substr(start, end - start + 1);
        };
        auto skipq = [&] (size_t start, char quote) {
            for (auto i = start + 1; i < names.size() ; ++i) {
                if (names[i] == quote)
                    return i;
                if (names[i] == '\\')
                    ++i;
            }
            CATCH_INTERNAL_ERROR("CAPTURE parsing encountered unmatched quote");
        };

        size_t start = 0;
        std::stack<char> openings;
        for (size_t pos = 0; pos < names.size(); ++pos) {
            char c = names[pos];
            switch (c) {
            case '[':
            case '{':
            case '(':
            // It is basically impossible to disambiguate between
            // comparison and start of template args in this context
//            case '<':
                openings.push(c);
                break;
            case ']':
            case '}':
            case ')':
//           case '>':
                openings.pop();
                break;
            case '"':
            case '\'':
                pos = skipq(pos, c);
                break;
            case ',':
                if (start != pos && openings.empty()) {
                    m_messages.emplace_back(macroName, lineInfo, resultType);
                    m_messages.back().message = static_cast<std::string>(trimmed(start, pos));
                    m_messages.back().message += " := ";
                    start = pos;
                }
            }
        }
        assert(openings.empty() && "Mismatched openings");
        m_messages.emplace_back(macroName, lineInfo, resultType);
        m_messages.back().message = static_cast<std::string>(trimmed(start, names.size() - 1));
        m_messages.back().message += " := ";
    }
    Capturer::~Capturer() {
        if ( !uncaught_exceptions() ){
            assert( m_captured == m_messages.size() );
            for( size_t i = 0; i < m_captured; ++i  )
                m_resultCapture.popScopedMessage( m_messages[i] );
        }
    }

    void Capturer::captureValue( size_t index, std::string const& value ) {
        assert( index < m_messages.size() );
        m_messages[index].message += value;
        m_resultCapture.pushScopedMessage( m_messages[index] );
        m_captured++;
    }

} // end namespace Catch
// end catch_message.cpp
// start catch_output_redirect.cpp

// start catch_output_redirect.h
#ifndef TWOBLUECUBES_CATCH_OUTPUT_REDIRECT_H
#define TWOBLUECUBES_CATCH_OUTPUT_REDIRECT_H

#include <cstdio>
#include <iosfwd>
#include <string>

namespace Catch {

    class RedirectedStream {
        std::ostream& m_originalStream;
        std::ostream& m_redirectionStream;
        std::streambuf* m_prevBuf;

    public:
        RedirectedStream( std::ostream& originalStream, std::ostream& redirectionStream );
        ~RedirectedStream();
    };

    class RedirectedStdOut {
        ReusableStringStream m_rss;
        RedirectedStream m_cout;
    public:
        RedirectedStdOut();
        auto str() const -> std::string;
    };

    // StdErr has two constituent streams in C++, std::cerr and std::clog
    // This means that we need to redirect 2 streams into 1 to keep proper
    // order of writes
    class RedirectedStdErr {
        ReusableStringStream m_rss;
        RedirectedStream m_cerr;
        RedirectedStream m_clog;
    public:
        RedirectedStdErr();
        auto str() const -> std::string;
    };

    class RedirectedStreams {
    public:
        RedirectedStreams(RedirectedStreams const&) = delete;
        RedirectedStreams& operator=(RedirectedStreams const&) = delete;
        RedirectedStreams(RedirectedStreams&&) = delete;
        RedirectedStreams& operator=(RedirectedStreams&&) = delete;

        RedirectedStreams(std::string& redirectedCout, std::string& redirectedCerr);
        ~RedirectedStreams();
    private:
        std::string& m_redirectedCout;
        std::string& m_redirectedCerr;
        RedirectedStdOut m_redirectedStdOut;
        RedirectedStdErr m_redirectedStdErr;
    };

#if defined(CATCH_CONFIG_NEW_CAPTURE)

    // Windows's implementation of std::tmpfile is terrible (it tries
    // to create a file inside system folder, thus requiring elevated
    // privileges for the binary), so we have to use tmpnam(_s) and
    // create the file ourselves there.
    class TempFile {
    public:
        TempFile(TempFile const&) = delete;
        TempFile& operator=(TempFile const&) = delete;
        TempFile(TempFile&&) = delete;
        TempFile& operator=(TempFile&&) = delete;

        TempFile();
        ~TempFile();

        std::FILE* getFile();
        std::string getContents();

    private:
        std::FILE* m_file = nullptr;
    #if defined(_MSC_VER)
        char m_buffer[L_tmpnam] = { 0 };
    #endif
    };

    class OutputRedirect {
    public:
        OutputRedirect(OutputRedirect const&) = delete;
        OutputRedirect& operator=(OutputRedirect const&) = delete;
        OutputRedirect(OutputRedirect&&) = delete;
        OutputRedirect& operator=(OutputRedirect&&) = delete;

        OutputRedirect(std::string& stdout_dest, std::string& stderr_dest);
        ~OutputRedirect();

    private:
        int m_originalStdout = -1;
        int m_originalStderr = -1;
        TempFile m_stdoutFile;
        TempFile m_stderrFile;
        std::string& m_stdoutDest;
        std::string& m_stderrDest;
    };

#endif

} // end namespace Catch

#endif // TWOBLUECUBES_CATCH_OUTPUT_REDIRECT_H
// end catch_output_redirect.h
#include <cstdio>
#include <cstring>
#include <fstream>
#include <sstream>
#include <stdexcept>

#if defined(CATCH_CONFIG_NEW_CAPTURE)
    #if defined(_MSC_VER)
    #include <io.h>      //_dup and _dup2
    #define dup _dup
    #define dup2 _dup2
    #define fileno _fileno
    #else
    #include <unistd.h>  // dup and dup2
    #endif
#endif

namespace Catch {

    RedirectedStream::RedirectedStream( std::ostream& originalStream, std::ostream& redirectionStream )
    :   m_originalStream( originalStream ),
        m_redirectionStream( redirectionStream ),
        m_prevBuf( m_originalStream.rdbuf() )
    {
        m_originalStream.rdbuf( m_redirectionStream.rdbuf() );
    }

    RedirectedStream::~RedirectedStream() {
        m_originalStream.rdbuf( m_prevBuf );
    }

    RedirectedStdOut::RedirectedStdOut() : m_cout( Catch::cout(), m_rss.get() ) {}
    auto RedirectedStdOut::str() const -> std::string { return m_rss.str(); }

    RedirectedStdErr::RedirectedStdErr()
    :   m_cerr( Catch::cerr(), m_rss.get() ),
        m_clog( Catch::clog(), m_rss.get() )
    {}
    auto RedirectedStdErr::str() const -> std::string { return m_rss.str(); }

    RedirectedStreams::RedirectedStreams(std::string& redirectedCout, std::string& redirectedCerr)
    :   m_redirectedCout(redirectedCout),
        m_redirectedCerr(redirectedCerr)
    {}

    RedirectedStreams::~RedirectedStreams() {
        m_redirectedCout += m_redirectedStdOut.str();
        m_redirectedCerr += m_redirectedStdErr.str();
    }

#if defined(CATCH_CONFIG_NEW_CAPTURE)

#if defined(_MSC_VER)
    TempFile::TempFile() {
        if (tmpnam_s(m_buffer)) {
            CATCH_RUNTIME_ERROR("Could not get a temp filename");
        }
        if (fopen_s(&m_file, m_buffer, "w")) {
            char buffer[100];
            if (strerror_s(buffer, errno)) {
                CATCH_RUNTIME_ERROR("Could not translate errno to a string");
            }
            CATCH_RUNTIME_ERROR("Could not open the temp file: '" << m_buffer << "' because: " << buffer);
        }
    }
#else
    TempFile::TempFile() {
        m_file = std::tmpfile();
        if (!m_file) {
            CATCH_RUNTIME_ERROR("Could not create a temp file.");
        }
    }

#endif

    TempFile::~TempFile() {
         // TBD: What to do about errors here?
         std::fclose(m_file);
         // We manually create the file on Windows only, on Linux
         // it will be autodeleted
#if defined(_MSC_VER)
         std::remove(m_buffer);
#endif
    }

    FILE* TempFile::getFile() {
        return m_file;
    }

    std::string TempFile::getContents() {
        std::stringstream sstr;
        char buffer[100] = {};
        std::rewind(m_file);
        while (std::fgets(buffer, sizeof(buffer), m_file)) {
            sstr << buffer;
        }
        return sstr.str();
    }

    OutputRedirect::OutputRedirect(std::string& stdout_dest, std::string& stderr_dest) :
        m_originalStdout(dup(1)),
        m_originalStderr(dup(2)),
        m_stdoutDest(stdout_dest),
        m_stderrDest(stderr_dest) {
        dup2(fileno(m_stdoutFile.getFile()), 1);
        dup2(fileno(m_stderrFile.getFile()), 2);
    }

    OutputRedirect::~OutputRedirect() {
        Catch::cout() << std::flush;
        fflush(stdout);
        // Since we support overriding these streams, we flush cerr
        // even though std::cerr is unbuffered
        Catch::cerr() << std::flush;
        Catch::clog() << std::flush;
        fflush(stderr);

        dup2(m_originalStdout, 1);
        dup2(m_originalStderr, 2);

        m_stdoutDest += m_stdoutFile.getContents();
        m_stderrDest += m_stderrFile.getContents();
    }

#endif // CATCH_CONFIG_NEW_CAPTURE

} // namespace Catch

#if defined(CATCH_CONFIG_NEW_CAPTURE)
    #if defined(_MSC_VER)
    #undef dup
    #undef dup2
    #undef fileno
    #endif
#endif
// end catch_output_redirect.cpp
// start catch_polyfills.cpp

#include <cmath>

namespace Catch {

#if !defined(CATCH_CONFIG_POLYFILL_ISNAN)
    bool isnan(float f) {
        return std::isnan(f);
    }
    bool isnan(double d) {
        return std::isnan(d);
    }
#else
    // For now we only use this for embarcadero
    bool isnan(float f) {
        return std::_isnan(f);
    }
    bool isnan(double d) {
        return std::_isnan(d);
    }
#endif

} // end namespace Catch
// end catch_polyfills.cpp
// start catch_random_number_generator.cpp

namespace Catch {

namespace {

#if defined(_MSC_VER)
#pragma warning(push)
#pragma warning(disable:4146) // we negate uint32 during the rotate
#endif
        // Safe rotr implementation thanks to John Regehr
        uint32_t rotate_right(uint32_t val, uint32_t count) {
            const uint32_t mask = 31;
            count &= mask;
            return (val >> count) | (val << (-count & mask));
        }

#if defined(_MSC_VER)
#pragma warning(pop)
#endif

}

    SimplePcg32::SimplePcg32(result_type seed_) {
        seed(seed_);
    }

    void SimplePcg32::seed(result_type seed_) {
        m_state = 0;
        (*this)();
        m_state += seed_;
        (*this)();
    }

    void SimplePcg32::discard(uint64_t skip) {
        // We could implement this to run in O(log n) steps, but this
        // should suffice for our use case.
        for (uint64_t s = 0; s < skip; ++s) {
            static_cast<void>((*this)());
        }
    }

    SimplePcg32::result_type SimplePcg32::operator()() {
        // prepare the output value
        const uint32_t xorshifted = static_cast<uint32_t>(((m_state >> 18u) ^ m_state) >> 27u);
        const auto output = rotate_right(xorshifted, m_state >> 59u);

        // advance state
        m_state = m_state * 6364136223846793005ULL + s_inc;

        return output;
    }

    bool operator==(SimplePcg32 const& lhs, SimplePcg32 const& rhs) {
        return lhs.m_state == rhs.m_state;
    }

    bool operator!=(SimplePcg32 const& lhs, SimplePcg32 const& rhs) {
        return lhs.m_state != rhs.m_state;
    }
}
// end catch_random_number_generator.cpp
// start catch_registry_hub.cpp

// start catch_test_case_registry_impl.h

#include <vector>
#include <set>
#include <algorithm>
#include <ios>

namespace Catch {

    class TestCase;
    struct IConfig;

    std::vector<TestCase> sortTests( IConfig const& config, std::vector<TestCase> const& unsortedTestCases );

    bool isThrowSafe( TestCase const& testCase, IConfig const& config );
    bool matchTest( TestCase const& testCase, TestSpec const& testSpec, IConfig const& config );

    void enforceNoDuplicateTestCases( std::vector<TestCase> const& functions );

    std::vector<TestCase> filterTests( std::vector<TestCase> const& testCases, TestSpec const& testSpec, IConfig const& config );
    std::vector<TestCase> const& getAllTestCasesSorted( IConfig const& config );

    class TestRegistry : public ITestCaseRegistry {
    public:
        virtual ~TestRegistry() = default;

        virtual void registerTest( TestCase const& testCase );

        std::vector<TestCase> const& getAllTests() const override;
        std::vector<TestCase> const& getAllTestsSorted( IConfig const& config ) const override;

    private:
        std::vector<TestCase> m_functions;
        mutable RunTests::InWhatOrder m_currentSortOrder = RunTests::InDeclarationOrder;
        mutable std::vector<TestCase> m_sortedFunctions;
        std::size_t m_unnamedCount = 0;
        std::ios_base::Init m_ostreamInit; // Forces cout/ cerr to be initialised
    };

    ///////////////////////////////////////////////////////////////////////////

    class TestInvokerAsFunction : public ITestInvoker {
        void(*m_testAsFunction)();
    public:
        TestInvokerAsFunction( void(*testAsFunction)() ) noexcept;

        void invoke() const override;
    };

    std::string extractClassName( StringRef const& classOrQualifiedMethodName );

    ///////////////////////////////////////////////////////////////////////////

} // end namespace Catch

// end catch_test_case_registry_impl.h
// start catch_reporter_registry.h

#include <map>

namespace Catch {

    class ReporterRegistry : public IReporterRegistry {

    public:

        ~ReporterRegistry() override;

        IStreamingReporterPtr create( std::string const& name, IConfigPtr const& config ) const override;

        void registerReporter( std::string const& name, IReporterFactoryPtr const& factory );
        void registerListener( IReporterFactoryPtr const& factory );

        FactoryMap const& getFactories() const override;
        Listeners const& getListeners() const override;

    private:
        FactoryMap m_factories;
        Listeners m_listeners;
    };
}

// end catch_reporter_registry.h
// start catch_tag_alias_registry.h

// start catch_tag_alias.h

#include <string>

namespace Catch {

    struct TagAlias {
        TagAlias(std::string const& _tag, SourceLineInfo _lineInfo);

        std::string tag;
        SourceLineInfo lineInfo;
    };

} // end namespace Catch

// end catch_tag_alias.h
#include <map>

namespace Catch {

    class TagAliasRegistry : public ITagAliasRegistry {
    public:
        ~TagAliasRegistry() override;
        TagAlias const* find( std::string const& alias ) const override;
        std::string expandAliases( std::string const& unexpandedTestSpec ) const override;
        void add( std::string const& alias, std::string const& tag, SourceLineInfo const& lineInfo );

    private:
        std::map<std::string, TagAlias> m_registry;
    };

} // end namespace Catch

// end catch_tag_alias_registry.h
// start catch_startup_exception_registry.h

#include <vector>
#include <exception>

namespace Catch {

    class StartupExceptionRegistry {
#if !defined(CATCH_CONFIG_DISABLE_EXCEPTIONS)
    public:
        void add(std::exception_ptr const& exception) noexcept;
        std::vector<std::exception_ptr> const& getExceptions() const noexcept;
    private:
        std::vector<std::exception_ptr> m_exceptions;
#endif
    };

} // end namespace Catch

// end catch_startup_exception_registry.h
// start catch_singletons.hpp

namespace Catch {

    struct ISingleton {
        virtual ~ISingleton();
    };

    void addSingleton( ISingleton* singleton );
    void cleanupSingletons();

    template<typename SingletonImplT, typename InterfaceT = SingletonImplT, typename MutableInterfaceT = InterfaceT>
    class Singleton : SingletonImplT, public ISingleton {

        static auto getInternal() -> Singleton* {
            static Singleton* s_instance = nullptr;
            if( !s_instance ) {
                s_instance = new Singleton;
                addSingleton( s_instance );
            }
            return s_instance;
        }

    public:
        static auto get() -> InterfaceT const& {
            return *getInternal();
        }
        static auto getMutable() -> MutableInterfaceT& {
            return *getInternal();
        }
    };

} // namespace Catch

// end catch_singletons.hpp
namespace Catch {

    namespace {

        class RegistryHub : public IRegistryHub, public IMutableRegistryHub,
                            private NonCopyable {

        public: // IRegistryHub
            RegistryHub() = default;
            IReporterRegistry const& getReporterRegistry() const override {
                return m_reporterRegistry;
            }
            ITestCaseRegistry const& getTestCaseRegistry() const override {
                return m_testCaseRegistry;
            }
            IExceptionTranslatorRegistry const& getExceptionTranslatorRegistry() const override {
                return m_exceptionTranslatorRegistry;
            }
            ITagAliasRegistry const& getTagAliasRegistry() const override {
                return m_tagAliasRegistry;
            }
            StartupExceptionRegistry const& getStartupExceptionRegistry() const override {
                return m_exceptionRegistry;
            }

        public: // IMutableRegistryHub
            void registerReporter( std::string const& name, IReporterFactoryPtr const& factory ) override {
                m_reporterRegistry.registerReporter( name, factory );
            }
            void registerListener( IReporterFactoryPtr const& factory ) override {
                m_reporterRegistry.registerListener( factory );
            }
            void registerTest( TestCase const& testInfo ) override {
                m_testCaseRegistry.registerTest( testInfo );
            }
            void registerTranslator( const IExceptionTranslator* translator ) override {
                m_exceptionTranslatorRegistry.registerTranslator( translator );
            }
            void registerTagAlias( std::string const& alias, std::string const& tag, SourceLineInfo const& lineInfo ) override {
                m_tagAliasRegistry.add( alias, tag, lineInfo );
            }
            void registerStartupException() noexcept override {
#if !defined(CATCH_CONFIG_DISABLE_EXCEPTIONS)
                m_exceptionRegistry.add(std::current_exception());
#else
                CATCH_INTERNAL_ERROR("Attempted to register active exception under CATCH_CONFIG_DISABLE_EXCEPTIONS!");
#endif
            }
            IMutableEnumValuesRegistry& getMutableEnumValuesRegistry() override {
                return m_enumValuesRegistry;
            }

        private:
            TestRegistry m_testCaseRegistry;
            ReporterRegistry m_reporterRegistry;
            ExceptionTranslatorRegistry m_exceptionTranslatorRegistry;
            TagAliasRegistry m_tagAliasRegistry;
            StartupExceptionRegistry m_exceptionRegistry;
            Detail::EnumValuesRegistry m_enumValuesRegistry;
        };
    }

    using RegistryHubSingleton = Singleton<RegistryHub, IRegistryHub, IMutableRegistryHub>;

    IRegistryHub const& getRegistryHub() {
        return RegistryHubSingleton::get();
    }
    IMutableRegistryHub& getMutableRegistryHub() {
        return RegistryHubSingleton::getMutable();
    }
    void cleanUp() {
        cleanupSingletons();
        cleanUpContext();
    }
    std::string translateActiveException() {
        return getRegistryHub().getExceptionTranslatorRegistry().translateActiveException();
    }

} // end namespace Catch
// end catch_registry_hub.cpp
// start catch_reporter_registry.cpp

namespace Catch {

    ReporterRegistry::~ReporterRegistry() = default;

    IStreamingReporterPtr ReporterRegistry::create( std::string const& name, IConfigPtr const& config ) const {
        auto it =  m_factories.find( name );
        if( it == m_factories.end() )
            return nullptr;
        return it->second->create( ReporterConfig( config ) );
    }

    void ReporterRegistry::registerReporter( std::string const& name, IReporterFactoryPtr const& factory ) {
        m_factories.emplace(name, factory);
    }
    void ReporterRegistry::registerListener( IReporterFactoryPtr const& factory ) {
        m_listeners.push_back( factory );
    }

    IReporterRegistry::FactoryMap const& ReporterRegistry::getFactories() const {
        return m_factories;
    }
    IReporterRegistry::Listeners const& ReporterRegistry::getListeners() const {
        return m_listeners;
    }

}
// end catch_reporter_registry.cpp
// start catch_result_type.cpp

namespace Catch {

    bool isOk( ResultWas::OfType resultType ) {
        return ( resultType & ResultWas::FailureBit ) == 0;
    }
    bool isJustInfo( int flags ) {
        return flags == ResultWas::Info;
    }

    ResultDisposition::Flags operator | ( ResultDisposition::Flags lhs, ResultDisposition::Flags rhs ) {
        return static_cast<ResultDisposition::Flags>( static_cast<int>( lhs ) | static_cast<int>( rhs ) );
    }

    bool shouldContinueOnFailure( int flags )    { return ( flags & ResultDisposition::ContinueOnFailure ) != 0; }
    bool shouldSuppressFailure( int flags )      { return ( flags & ResultDisposition::SuppressFail ) != 0; }

} // end namespace Catch
// end catch_result_type.cpp
// start catch_run_context.cpp

#include <cassert>
#include <algorithm>
#include <sstream>

namespace Catch {

    namespace Generators {
        struct GeneratorTracker : TestCaseTracking::TrackerBase, IGeneratorTracker {
            GeneratorBasePtr m_generator;

            GeneratorTracker( TestCaseTracking::NameAndLocation const& nameAndLocation, TrackerContext& ctx, ITracker* parent )
            :   TrackerBase( nameAndLocation, ctx, parent )
            {}
            ~GeneratorTracker();

            static GeneratorTracker& acquire( TrackerContext& ctx, TestCaseTracking::NameAndLocation const& nameAndLocation ) {
                std::shared_ptr<GeneratorTracker> tracker;

                ITracker& currentTracker = ctx.currentTracker();
                // Under specific circumstances, the generator we want
                // to acquire is also the current tracker. If this is
                // the case, we have to avoid looking through current
                // tracker's children, and instead return the current
                // tracker.
                // A case where this check is important is e.g.
                //     for (int i = 0; i < 5; ++i) {
                //         int n = GENERATE(1, 2);
                //     }
                //
                // without it, the code above creates 5 nested generators.
                if (currentTracker.nameAndLocation() == nameAndLocation) {
                    auto thisTracker = currentTracker.parent().findChild(nameAndLocation);
                    assert(thisTracker);
                    assert(thisTracker->isGeneratorTracker());
                    tracker = std::static_pointer_cast<GeneratorTracker>(thisTracker);
                } else if ( TestCaseTracking::ITrackerPtr childTracker = currentTracker.findChild( nameAndLocation ) ) {
                    assert( childTracker );
                    assert( childTracker->isGeneratorTracker() );
                    tracker = std::static_pointer_cast<GeneratorTracker>( childTracker );
                } else {
                    tracker = std::make_shared<GeneratorTracker>( nameAndLocation, ctx, &currentTracker );
                    currentTracker.addChild( tracker );
                }

                if( !tracker->isComplete() ) {
                    tracker->open();
                }

                return *tracker;
            }

            // TrackerBase interface
            bool isGeneratorTracker() const override { return true; }
            auto hasGenerator() const -> bool override {
                return !!m_generator;
            }
            void close() override {
                TrackerBase::close();
                // If a generator has a child (it is followed by a section)
                // and none of its children have started, then we must wait
                // until later to start consuming its values.
                // This catches cases where `GENERATE` is placed between two
                // `SECTION`s.
                // **The check for m_children.empty cannot be removed**.
                // doing so would break `GENERATE` _not_ followed by `SECTION`s.
                const bool should_wait_for_child =
                    !m_children.empty() &&
                    std::find_if( m_children.begin(),
                                  m_children.end(),
                                  []( TestCaseTracking::ITrackerPtr tracker ) {
                                      return tracker->hasStarted();
                                  } ) == m_children.end();

                // This check is a bit tricky, because m_generator->next()
                // has a side-effect, where it consumes generator's current
                // value, but we do not want to invoke the side-effect if
                // this generator is still waiting for any child to start.
                if ( should_wait_for_child ||
                     ( m_runState == CompletedSuccessfully &&
                       m_generator->next() ) ) {
                    m_children.clear();
                    m_runState = Executing;
                }
            }

            // IGeneratorTracker interface
            auto getGenerator() const -> GeneratorBasePtr const& override {
                return m_generator;
            }
            void setGenerator( GeneratorBasePtr&& generator ) override {
                m_generator = std::move( generator );
            }
        };
        GeneratorTracker::~GeneratorTracker() {}
    }

    RunContext::RunContext(IConfigPtr const& _config, IStreamingReporterPtr&& reporter)
    :   m_runInfo(_config->name()),
        m_context(getCurrentMutableContext()),
        m_config(_config),
        m_reporter(std::move(reporter)),
        m_lastAssertionInfo{ StringRef(), SourceLineInfo("",0), StringRef(), ResultDisposition::Normal },
        m_includeSuccessfulResults( m_config->includeSuccessfulResults() || m_reporter->getPreferences().shouldReportAllAssertions )
    {
        m_context.setRunner(this);
        m_context.setConfig(m_config);
        m_context.setResultCapture(this);
        m_reporter->testRunStarting(m_runInfo);
    }

    RunContext::~RunContext() {
        m_reporter->testRunEnded(TestRunStats(m_runInfo, m_totals, aborting()));
    }

    void RunContext::testGroupStarting(std::string const& testSpec, std::size_t groupIndex, std::size_t groupsCount) {
        m_reporter->testGroupStarting(GroupInfo(testSpec, groupIndex, groupsCount));
    }

    void RunContext::testGroupEnded(std::string const& testSpec, Totals const& totals, std::size_t groupIndex, std::size_t groupsCount) {
        m_reporter->testGroupEnded(TestGroupStats(GroupInfo(testSpec, groupIndex, groupsCount), totals, aborting()));
    }

    Totals RunContext::runTest(TestCase const& testCase) {
        Totals prevTotals = m_totals;

        std::string redirectedCout;
        std::string redirectedCerr;

        auto const& testInfo = testCase.getTestCaseInfo();

        m_reporter->testCaseStarting(testInfo);

        m_activeTestCase = &testCase;

        ITracker& rootTracker = m_trackerContext.startRun();
        assert(rootTracker.isSectionTracker());
        static_cast<SectionTracker&>(rootTracker).addInitialFilters(m_config->getSectionsToRun());
        do {
            m_trackerContext.startCycle();
            m_testCaseTracker = &SectionTracker::acquire(m_trackerContext, TestCaseTracking::NameAndLocation(testInfo.name, testInfo.lineInfo));
            runCurrentTest(redirectedCout, redirectedCerr);
        } while (!m_testCaseTracker->isSuccessfullyCompleted() && !aborting());

        Totals deltaTotals = m_totals.delta(prevTotals);
        if (testInfo.expectedToFail() && deltaTotals.testCases.passed > 0) {
            deltaTotals.assertions.failed++;
            deltaTotals.testCases.passed--;
            deltaTotals.testCases.failed++;
        }
        m_totals.testCases += deltaTotals.testCases;
        m_reporter->testCaseEnded(TestCaseStats(testInfo,
                                  deltaTotals,
                                  redirectedCout,
                                  redirectedCerr,
                                  aborting()));

        m_activeTestCase = nullptr;
        m_testCaseTracker = nullptr;

        return deltaTotals;
    }

    IConfigPtr RunContext::config() const {
        return m_config;
    }

    IStreamingReporter& RunContext::reporter() const {
        return *m_reporter;
    }

    void RunContext::assertionEnded(AssertionResult const & result) {
        if (result.getResultType() == ResultWas::Ok) {
            m_totals.assertions.passed++;
            m_lastAssertionPassed = true;
        } else if (!result.isOk()) {
            m_lastAssertionPassed = false;
            if( m_activeTestCase->getTestCaseInfo().okToFail() )
                m_totals.assertions.failedButOk++;
            else
                m_totals.assertions.failed++;
        }
        else {
            m_lastAssertionPassed = true;
        }

        // We have no use for the return value (whether messages should be cleared), because messages were made scoped
        // and should be let to clear themselves out.
        static_cast<void>(m_reporter->assertionEnded(AssertionStats(result, m_messages, m_totals)));

        if (result.getResultType() != ResultWas::Warning)
            m_messageScopes.clear();

        // Reset working state
        resetAssertionInfo();
        m_lastResult = result;
    }
    void RunContext::resetAssertionInfo() {
        m_lastAssertionInfo.macroName = StringRef();
        m_lastAssertionInfo.capturedExpression = "{Unknown expression after the reported line}"_sr;
    }

    bool RunContext::sectionStarted(SectionInfo const & sectionInfo, Counts & assertions) {
        ITracker& sectionTracker = SectionTracker::acquire(m_trackerContext, TestCaseTracking::NameAndLocation(sectionInfo.name, sectionInfo.lineInfo));
        if (!sectionTracker.isOpen())
            return false;
        m_activeSections.push_back(&sectionTracker);

        m_lastAssertionInfo.lineInfo = sectionInfo.lineInfo;

        m_reporter->sectionStarting(sectionInfo);

        assertions = m_totals.assertions;

        return true;
    }
    auto RunContext::acquireGeneratorTracker( StringRef generatorName, SourceLineInfo const& lineInfo ) -> IGeneratorTracker& {
        using namespace Generators;
        GeneratorTracker& tracker = GeneratorTracker::acquire(m_trackerContext,
                                                              TestCaseTracking::NameAndLocation( static_cast<std::string>(generatorName), lineInfo ) );
        m_lastAssertionInfo.lineInfo = lineInfo;
        return tracker;
    }

    bool RunContext::testForMissingAssertions(Counts& assertions) {
        if (assertions.total() != 0)
            return false;
        if (!m_config->warnAboutMissingAssertions())
            return false;
        if (m_trackerContext.currentTracker().hasChildren())
            return false;
        m_totals.assertions.failed++;
        assertions.failed++;
        return true;
    }

    void RunContext::sectionEnded(SectionEndInfo const & endInfo) {
        Counts assertions = m_totals.assertions - endInfo.prevAssertions;
        bool missingAssertions = testForMissingAssertions(assertions);

        if (!m_activeSections.empty()) {
            m_activeSections.back()->close();
            m_activeSections.pop_back();
        }

        m_reporter->sectionEnded(SectionStats(endInfo.sectionInfo, assertions, endInfo.durationInSeconds, missingAssertions));
        m_messages.clear();
        m_messageScopes.clear();
    }

    void RunContext::sectionEndedEarly(SectionEndInfo const & endInfo) {
        if (m_unfinishedSections.empty())
            m_activeSections.back()->fail();
        else
            m_activeSections.back()->close();
        m_activeSections.pop_back();

        m_unfinishedSections.push_back(endInfo);
    }

#if defined(CATCH_CONFIG_ENABLE_BENCHMARKING)
    void RunContext::benchmarkPreparing(std::string const& name) {
        m_reporter->benchmarkPreparing(name);
    }
    void RunContext::benchmarkStarting( BenchmarkInfo const& info ) {
        m_reporter->benchmarkStarting( info );
    }
    void RunContext::benchmarkEnded( BenchmarkStats<> const& stats ) {
        m_reporter->benchmarkEnded( stats );
    }
    void RunContext::benchmarkFailed(std::string const & error) {
        m_reporter->benchmarkFailed(error);
    }
#endif // CATCH_CONFIG_ENABLE_BENCHMARKING

    void RunContext::pushScopedMessage(MessageInfo const & message) {
        m_messages.push_back(message);
    }

    void RunContext::popScopedMessage(MessageInfo const & message) {
        m_messages.erase(std::remove(m_messages.begin(), m_messages.end(), message), m_messages.end());
    }

    void RunContext::emplaceUnscopedMessage( MessageBuilder const& builder ) {
        m_messageScopes.emplace_back( builder );
    }

    std::string RunContext::getCurrentTestName() const {
        return m_activeTestCase
            ? m_activeTestCase->getTestCaseInfo().name
            : std::string();
    }

    const AssertionResult * RunContext::getLastResult() const {
        return &(*m_lastResult);
    }

    void RunContext::exceptionEarlyReported() {
        m_shouldReportUnexpected = false;
    }

    void RunContext::handleFatalErrorCondition( StringRef message ) {
        // First notify reporter that bad things happened
        m_reporter->fatalErrorEncountered(message);

        // Don't rebuild the result -- the stringification itself can cause more fatal errors
        // Instead, fake a result data.
        AssertionResultData tempResult( ResultWas::FatalErrorCondition, { false } );
        tempResult.message = static_cast<std::string>(message);
        AssertionResult result(m_lastAssertionInfo, tempResult);

        assertionEnded(result);

        handleUnfinishedSections();

        // Recreate section for test case (as we will lose the one that was in scope)
        auto const& testCaseInfo = m_activeTestCase->getTestCaseInfo();
        SectionInfo testCaseSection(testCaseInfo.lineInfo, testCaseInfo.name);

        Counts assertions;
        assertions.failed = 1;
        SectionStats testCaseSectionStats(testCaseSection, assertions, 0, false);
        m_reporter->sectionEnded(testCaseSectionStats);

        auto const& testInfo = m_activeTestCase->getTestCaseInfo();

        Totals deltaTotals;
        deltaTotals.testCases.failed = 1;
        deltaTotals.assertions.failed = 1;
        m_reporter->testCaseEnded(TestCaseStats(testInfo,
                                  deltaTotals,
                                  std::string(),
                                  std::string(),
                                  false));
        m_totals.testCases.failed++;
        testGroupEnded(std::string(), m_totals, 1, 1);
        m_reporter->testRunEnded(TestRunStats(m_runInfo, m_totals, false));
    }

    bool RunContext::lastAssertionPassed() {
         return m_lastAssertionPassed;
    }

    void RunContext::assertionPassed() {
        m_lastAssertionPassed = true;
        ++m_totals.assertions.passed;
        resetAssertionInfo();
        m_messageScopes.clear();
    }

    bool RunContext::aborting() const {
        return m_totals.assertions.failed >= static_cast<std::size_t>(m_config->abortAfter());
    }

    void RunContext::runCurrentTest(std::string & redirectedCout, std::string & redirectedCerr) {
        auto const& testCaseInfo = m_activeTestCase->getTestCaseInfo();
        SectionInfo testCaseSection(testCaseInfo.lineInfo, testCaseInfo.name);
        m_reporter->sectionStarting(testCaseSection);
        Counts prevAssertions = m_totals.assertions;
        double duration = 0;
        m_shouldReportUnexpected = true;
        m_lastAssertionInfo = { "TEST_CASE"_sr, testCaseInfo.lineInfo, StringRef(), ResultDisposition::Normal };

        seedRng(*m_config);

        Timer timer;
        CATCH_TRY {
            if (m_reporter->getPreferences().shouldRedirectStdOut) {
#if !defined(CATCH_CONFIG_EXPERIMENTAL_REDIRECT)
                RedirectedStreams redirectedStreams(redirectedCout, redirectedCerr);

                timer.start();
                invokeActiveTestCase();
#else
                OutputRedirect r(redirectedCout, redirectedCerr);
                timer.start();
                invokeActiveTestCase();
#endif
            } else {
                timer.start();
                invokeActiveTestCase();
            }
            duration = timer.getElapsedSeconds();
        } CATCH_CATCH_ANON (TestFailureException&) {
            // This just means the test was aborted due to failure
        } CATCH_CATCH_ALL {
            // Under CATCH_CONFIG_FAST_COMPILE, unexpected exceptions under REQUIRE assertions
            // are reported without translation at the point of origin.
            if( m_shouldReportUnexpected ) {
                AssertionReaction dummyReaction;
                handleUnexpectedInflightException( m_lastAssertionInfo, translateActiveException(), dummyReaction );
            }
        }
        Counts assertions = m_totals.assertions - prevAssertions;
        bool missingAssertions = testForMissingAssertions(assertions);

        m_testCaseTracker->close();
        handleUnfinishedSections();
        m_messages.clear();
        m_messageScopes.clear();

        SectionStats testCaseSectionStats(testCaseSection, assertions, duration, missingAssertions);
        m_reporter->sectionEnded(testCaseSectionStats);
    }

    void RunContext::invokeActiveTestCase() {
        FatalConditionHandler fatalConditionHandler; // Handle signals
        m_activeTestCase->invoke();
        fatalConditionHandler.reset();
    }

    void RunContext::handleUnfinishedSections() {
        // If sections ended prematurely due to an exception we stored their
        // infos here so we can tear them down outside the unwind process.
        for (auto it = m_unfinishedSections.rbegin(),
             itEnd = m_unfinishedSections.rend();
             it != itEnd;
             ++it)
            sectionEnded(*it);
        m_unfinishedSections.clear();
    }

    void RunContext::handleExpr(
        AssertionInfo const& info,
        ITransientExpression const& expr,
        AssertionReaction& reaction
    ) {
        m_reporter->assertionStarting( info );

        bool negated = isFalseTest( info.resultDisposition );
        bool result = expr.getResult() != negated;

        if( result ) {
            if (!m_includeSuccessfulResults) {
                assertionPassed();
            }
            else {
                reportExpr(info, ResultWas::Ok, &expr, negated);
            }
        }
        else {
            reportExpr(info, ResultWas::ExpressionFailed, &expr, negated );
            populateReaction( reaction );
        }
    }
    void RunContext::reportExpr(
            AssertionInfo const &info,
            ResultWas::OfType resultType,
            ITransientExpression const *expr,
            bool negated ) {

        m_lastAssertionInfo = info;
        AssertionResultData data( resultType, LazyExpression( negated ) );

        AssertionResult assertionResult{ info, data };
        assertionResult.m_resultData.lazyExpression.m_transientExpression = expr;

        assertionEnded( assertionResult );
    }

    void RunContext::handleMessage(
            AssertionInfo const& info,
            ResultWas::OfType resultType,
            StringRef const& message,
            AssertionReaction& reaction
    ) {
        m_reporter->assertionStarting( info );

        m_lastAssertionInfo = info;

        AssertionResultData data( resultType, LazyExpression( false ) );
        data.message = static_cast<std::string>(message);
        AssertionResult assertionResult{ m_lastAssertionInfo, data };
        assertionEnded( assertionResult );
        if( !assertionResult.isOk() )
            populateReaction( reaction );
    }
    void RunContext::handleUnexpectedExceptionNotThrown(
            AssertionInfo const& info,
            AssertionReaction& reaction
    ) {
        handleNonExpr(info, Catch::ResultWas::DidntThrowException, reaction);
    }

    void RunContext::handleUnexpectedInflightException(
            AssertionInfo const& info,
            std::string const& message,
            AssertionReaction& reaction
    ) {
        m_lastAssertionInfo = info;

        AssertionResultData data( ResultWas::ThrewException, LazyExpression( false ) );
        data.message = message;
        AssertionResult assertionResult{ info, data };
        assertionEnded( assertionResult );
        populateReaction( reaction );
    }

    void RunContext::populateReaction( AssertionReaction& reaction ) {
        reaction.shouldDebugBreak = m_config->shouldDebugBreak();
        reaction.shouldThrow = aborting() || (m_lastAssertionInfo.resultDisposition & ResultDisposition::Normal);
    }

    void RunContext::handleIncomplete(
            AssertionInfo const& info
    ) {
        m_lastAssertionInfo = info;

        AssertionResultData data( ResultWas::ThrewException, LazyExpression( false ) );
        data.message = "Exception translation was disabled by CATCH_CONFIG_FAST_COMPILE";
        AssertionResult assertionResult{ info, data };
        assertionEnded( assertionResult );
    }
    void RunContext::handleNonExpr(
            AssertionInfo const &info,
            ResultWas::OfType resultType,
            AssertionReaction &reaction
    ) {
        m_lastAssertionInfo = info;

        AssertionResultData data( resultType, LazyExpression( false ) );
        AssertionResult assertionResult{ info, data };
        assertionEnded( assertionResult );

        if( !assertionResult.isOk() )
            populateReaction( reaction );
    }

    IResultCapture& getResultCapture() {
        if (auto* capture = getCurrentContext().getResultCapture())
            return *capture;
        else
            CATCH_INTERNAL_ERROR("No result capture instance");
    }

    void seedRng(IConfig const& config) {
        if (config.rngSeed() != 0) {
            std::srand(config.rngSeed());
            rng().seed(config.rngSeed());
        }
    }

    unsigned int rngSeed() {
        return getCurrentContext().getConfig()->rngSeed();
    }

}
// end catch_run_context.cpp
// start catch_section.cpp

namespace Catch {

    Section::Section( SectionInfo const& info )
    :   m_info( info ),
        m_sectionIncluded( getResultCapture().sectionStarted( m_info, m_assertions ) )
    {
        m_timer.start();
    }

    Section::~Section() {
        if( m_sectionIncluded ) {
            SectionEndInfo endInfo{ m_info, m_assertions, m_timer.getElapsedSeconds() };
            if( uncaught_exceptions() )
                getResultCapture().sectionEndedEarly( endInfo );
            else
                getResultCapture().sectionEnded( endInfo );
        }
    }

    // This indicates whether the section should be executed or not
    Section::operator bool() const {
        return m_sectionIncluded;
    }

} // end namespace Catch
// end catch_section.cpp
// start catch_section_info.cpp

namespace Catch {

    SectionInfo::SectionInfo
        (   SourceLineInfo const& _lineInfo,
            std::string const& _name )
    :   name( _name ),
        lineInfo( _lineInfo )
    {}

} // end namespace Catch
// end catch_section_info.cpp
// start catch_session.cpp

// start catch_session.h

#include <memory>

namespace Catch {

    class Session : NonCopyable {
    public:

        Session();
        ~Session() override;

        void showHelp() const;
        void libIdentify();

        int applyCommandLine( int argc, char const * const * argv );
    #if defined(CATCH_CONFIG_WCHAR) && defined(_WIN32) && defined(UNICODE)
        int applyCommandLine( int argc, wchar_t const * const * argv );
    #endif

        void useConfigData( ConfigData const& configData );

        template<typename CharT>
        int run(int argc, CharT const * const argv[]) {
            if (m_startupExceptions)
                return 1;
            int returnCode = applyCommandLine(argc, argv);
            if (returnCode == 0)
                returnCode = run();
            return returnCode;
        }

        int run();

        clara::Parser const& cli() const;
        void cli( clara::Parser const& newParser );
        ConfigData& configData();
        Config& config();
    private:
        int runInternal();

        clara::Parser m_cli;
        ConfigData m_configData;
        std::shared_ptr<Config> m_config;
        bool m_startupExceptions = false;
    };

} // end namespace Catch

// end catch_session.h
// start catch_version.h

#include <iosfwd>

namespace Catch {

    // Versioning information
    struct Version {
        Version( Version const& ) = delete;
        Version& operator=( Version const& ) = delete;
        Version(    unsigned int _majorVersion,
                    unsigned int _minorVersion,
                    unsigned int _patchNumber,
                    char const * const _branchName,
                    unsigned int _buildNumber );

        unsigned int const majorVersion;
        unsigned int const minorVersion;
        unsigned int const patchNumber;

        // buildNumber is only used if branchName is not null
        char const * const branchName;
        unsigned int const buildNumber;

        friend std::ostream& operator << ( std::ostream& os, Version const& version );
    };

    Version const& libraryVersion();
}

// end catch_version.h
#include <cstdlib>
#include <iomanip>
#include <set>
#include <iterator>

namespace Catch {

    namespace {
        const int MaxExitCode = 255;

        IStreamingReporterPtr createReporter(std::string const& reporterName, IConfigPtr const& config) {
            auto reporter = Catch::getRegistryHub().getReporterRegistry().create(reporterName, config);
            CATCH_ENFORCE(reporter, "No reporter registered with name: '" << reporterName << "'");

            return reporter;
        }

        IStreamingReporterPtr makeReporter(std::shared_ptr<Config> const& config) {
            if (Catch::getRegistryHub().getReporterRegistry().getListeners().empty()) {
                return createReporter(config->getReporterName(), config);
            }

            // On older platforms, returning std::unique_ptr<ListeningReporter>
            // when the return type is std::unique_ptr<IStreamingReporter>
            // doesn't compile without a std::move call. However, this causes
            // a warning on newer platforms. Thus, we have to work around
            // it a bit and downcast the pointer manually.
            auto ret = std::unique_ptr<IStreamingReporter>(new ListeningReporter);
            auto& multi = static_cast<ListeningReporter&>(*ret);
            auto const& listeners = Catch::getRegistryHub().getReporterRegistry().getListeners();
            for (auto const& listener : listeners) {
                multi.addListener(listener->create(Catch::ReporterConfig(config)));
            }
            multi.addReporter(createReporter(config->getReporterName(), config));
            return ret;
        }

        class TestGroup {
        public:
            explicit TestGroup(std::shared_ptr<Config> const& config)
            : m_config{config}
            , m_context{config, makeReporter(config)}
            {
                auto const& allTestCases = getAllTestCasesSorted(*m_config);
                m_matches = m_config->testSpec().matchesByFilter(allTestCases, *m_config);
                auto const& invalidArgs = m_config->testSpec().getInvalidArgs();

                if (m_matches.empty() && invalidArgs.empty()) {
                    for (auto const& test : allTestCases)
                        if (!test.isHidden())
                            m_tests.emplace(&test);
                } else {
                    for (auto const& match : m_matches)
                        m_tests.insert(match.tests.begin(), match.tests.end());
                }
            }

            Totals execute() {
                auto const& invalidArgs = m_config->testSpec().getInvalidArgs();
                Totals totals;
                m_context.testGroupStarting(m_config->name(), 1, 1);
                for (auto const& testCase : m_tests) {
                    if (!m_context.aborting())
                        totals += m_context.runTest(*testCase);
                    else
                        m_context.reporter().skipTest(*testCase);
                }

                for (auto const& match : m_matches) {
                    if (match.tests.empty()) {
                        m_context.reporter().noMatchingTestCases(match.name);
                        totals.error = -1;
                    }
                }

                if (!invalidArgs.empty()) {
                    for (auto const& invalidArg: invalidArgs)
                         m_context.reporter().reportInvalidArguments(invalidArg);
                }

                m_context.testGroupEnded(m_config->name(), totals, 1, 1);
                return totals;
            }

        private:
            using Tests = std::set<TestCase const*>;

            std::shared_ptr<Config> m_config;
            RunContext m_context;
            Tests m_tests;
            TestSpec::Matches m_matches;
        };

        void applyFilenamesAsTags(Catch::IConfig const& config) {
            auto& tests = const_cast<std::vector<TestCase>&>(getAllTestCasesSorted(config));
            for (auto& testCase : tests) {
                auto tags = testCase.tags;

                std::string filename = testCase.lineInfo.file;
                auto lastSlash = filename.find_last_of("\\/");
                if (lastSlash != std::string::npos) {
                    filename.erase(0, lastSlash);
                    filename[0] = '#';
                }

                auto lastDot = filename.find_last_of('.');
                if (lastDot != std::string::npos) {
                    filename.erase(lastDot);
                }

                tags.push_back(std::move(filename));
                setTags(testCase, tags);
            }
        }

    } // anon namespace

    Session::Session() {
        static bool alreadyInstantiated = false;
        if( alreadyInstantiated ) {
            CATCH_TRY { CATCH_INTERNAL_ERROR( "Only one instance of Catch::Session can ever be used" ); }
            CATCH_CATCH_ALL { getMutableRegistryHub().registerStartupException(); }
        }

        // There cannot be exceptions at startup in no-exception mode.
#if !defined(CATCH_CONFIG_DISABLE_EXCEPTIONS)
        const auto& exceptions = getRegistryHub().getStartupExceptionRegistry().getExceptions();
        if ( !exceptions.empty() ) {
            config();
            getCurrentMutableContext().setConfig(m_config);

            m_startupExceptions = true;
            Colour colourGuard( Colour::Red );
            Catch::cerr() << "Errors occurred during startup!" << '\n';
            // iterate over all exceptions and notify user
            for ( const auto& ex_ptr : exceptions ) {
                try {
                    std::rethrow_exception(ex_ptr);
                } catch ( std::exception const& ex ) {
                    Catch::cerr() << Column( ex.what() ).indent(2) << '\n';
                }
            }
        }
#endif

        alreadyInstantiated = true;
        m_cli = makeCommandLineParser( m_configData );
    }
    Session::~Session() {
        Catch::cleanUp();
    }

    void Session::showHelp() const {
        Catch::cout()
                << "\nCatch v" << libraryVersion() << "\n"
                << m_cli << std::endl
                << "For more detailed usage please see the project docs\n" << std::endl;
    }
    void Session::libIdentify() {
        Catch::cout()
                << std::left << std::setw(16) << "description: " << "A Catch2 test executable\n"
                << std::left << std::setw(16) << "category: " << "testframework\n"
                << std::left << std::setw(16) << "framework: " << "Catch Test\n"
                << std::left << std::setw(16) << "version: " << libraryVersion() << std::endl;
    }

    int Session::applyCommandLine( int argc, char const * const * argv ) {
        if( m_startupExceptions )
            return 1;

        auto result = m_cli.parse( clara::Args( argc, argv ) );
        if( !result ) {
            config();
            getCurrentMutableContext().setConfig(m_config);
            Catch::cerr()
                << Colour( Colour::Red )
                << "\nError(s) in input:\n"
                << Column( result.errorMessage() ).indent( 2 )
                << "\n\n";
            Catch::cerr() << "Run with -? for usage\n" << std::endl;
            return MaxExitCode;
        }

        if( m_configData.showHelp )
            showHelp();
        if( m_configData.libIdentify )
            libIdentify();
        m_config.reset();
        return 0;
    }

#if defined(CATCH_CONFIG_WCHAR) && defined(_WIN32) && defined(UNICODE)
    int Session::applyCommandLine( int argc, wchar_t const * const * argv ) {

        char **utf8Argv = new char *[ argc ];

        for ( int i = 0; i < argc; ++i ) {
            int bufSize = WideCharToMultiByte( CP_UTF8, 0, argv[i], -1, nullptr, 0, nullptr, nullptr );

            utf8Argv[ i ] = new char[ bufSize ];

            WideCharToMultiByte( CP_UTF8, 0, argv[i], -1, utf8Argv[i], bufSize, nullptr, nullptr );
        }

        int returnCode = applyCommandLine( argc, utf8Argv );

        for ( int i = 0; i < argc; ++i )
            delete [] utf8Argv[ i ];

        delete [] utf8Argv;

        return returnCode;
    }
#endif

    void Session::useConfigData( ConfigData const& configData ) {
        m_configData = configData;
        m_config.reset();
    }

    int Session::run() {
        if( ( m_configData.waitForKeypress & WaitForKeypress::BeforeStart ) != 0 ) {
            Catch::cout() << "...waiting for enter/ return before starting" << std::endl;
            static_cast<void>(std::getchar());
        }
        int exitCode = runInternal();
        if( ( m_configData.waitForKeypress & WaitForKeypress::BeforeExit ) != 0 ) {
            Catch::cout() << "...waiting for enter/ return before exiting, with code: " << exitCode << std::endl;
            static_cast<void>(std::getchar());
        }
        return exitCode;
    }

    clara::Parser const& Session::cli() const {
        return m_cli;
    }
    void Session::cli( clara::Parser const& newParser ) {
        m_cli = newParser;
    }
    ConfigData& Session::configData() {
        return m_configData;
    }
    Config& Session::config() {
        if( !m_config )
            m_config = std::make_shared<Config>( m_configData );
        return *m_config;
    }

    int Session::runInternal() {
        if( m_startupExceptions )
            return 1;

        if (m_configData.showHelp || m_configData.libIdentify) {
            return 0;
        }

        CATCH_TRY {
            config(); // Force config to be constructed

            seedRng( *m_config );

            if( m_configData.filenamesAsTags )
                applyFilenamesAsTags( *m_config );

            // Handle list request
            if( Option<std::size_t> listed = list( m_config ) )
                return static_cast<int>( *listed );

            TestGroup tests { m_config };
            auto const totals = tests.execute();

            if( m_config->warnAboutNoTests() && totals.error == -1 )
                return 2;

            // Note that on unices only the lower 8 bits are usually used, clamping
            // the return value to 255 prevents false negative when some multiple
            // of 256 tests has failed
            return (std::min) (MaxExitCode, (std::max) (totals.error, static_cast<int>(totals.assertions.failed)));
        }
#if !defined(CATCH_CONFIG_DISABLE_EXCEPTIONS)
        catch( std::exception& ex ) {
            Catch::cerr() << ex.what() << std::endl;
            return MaxExitCode;
        }
#endif
    }

} // end namespace Catch
// end catch_session.cpp
// start catch_singletons.cpp

#include <vector>

namespace Catch {

    namespace {
        static auto getSingletons() -> std::vector<ISingleton*>*& {
            static std::vector<ISingleton*>* g_singletons = nullptr;
            if( !g_singletons )
                g_singletons = new std::vector<ISingleton*>();
            return g_singletons;
        }
    }

    ISingleton::~ISingleton() {}

    void addSingleton(ISingleton* singleton ) {
        getSingletons()->push_back( singleton );
    }
    void cleanupSingletons() {
        auto& singletons = getSingletons();
        for( auto singleton : *singletons )
            delete singleton;
        delete singletons;
        singletons = nullptr;
    }

} // namespace Catch
// end catch_singletons.cpp
// start catch_startup_exception_registry.cpp

#if !defined(CATCH_CONFIG_DISABLE_EXCEPTIONS)
namespace Catch {
void StartupExceptionRegistry::add( std::exception_ptr const& exception ) noexcept {
        CATCH_TRY {
            m_exceptions.push_back(exception);
        } CATCH_CATCH_ALL {
            // If we run out of memory during start-up there's really not a lot more we can do about it
            std::terminate();
        }
    }

    std::vector<std::exception_ptr> const& StartupExceptionRegistry::getExceptions() const noexcept {
        return m_exceptions;
    }

} // end namespace Catch
#endif
// end catch_startup_exception_registry.cpp
// start catch_stream.cpp

#include <cstdio>
#include <iostream>
#include <fstream>
#include <sstream>
#include <vector>
#include <memory>

namespace Catch {

    Catch::IStream::~IStream() = default;

    namespace Detail { namespace {
        template<typename WriterF, std::size_t bufferSize=256>
        class StreamBufImpl : public std::streambuf {
            char data[bufferSize];
            WriterF m_writer;

        public:
            StreamBufImpl() {
                setp( data, data + sizeof(data) );
            }

            ~StreamBufImpl() noexcept {
                StreamBufImpl::sync();
            }

        private:
            int overflow( int c ) override {
                sync();

                if( c != EOF ) {
                    if( pbase() == epptr() )
                        m_writer( std::string( 1, static_cast<char>( c ) ) );
                    else
                        sputc( static_cast<char>( c ) );
                }
                return 0;
            }

            int sync() override {
                if( pbase() != pptr() ) {
                    m_writer( std::string( pbase(), static_cast<std::string::size_type>( pptr() - pbase() ) ) );
                    setp( pbase(), epptr() );
                }
                return 0;
            }
        };

        ///////////////////////////////////////////////////////////////////////////

        struct OutputDebugWriter {

            void operator()( std::string const&str ) {
                writeToDebugConsole( str );
            }
        };

        ///////////////////////////////////////////////////////////////////////////

        class FileStream : public IStream {
            mutable std::ofstream m_ofs;
        public:
            FileStream( StringRef filename ) {
                m_ofs.open( filename.c_str() );
                CATCH_ENFORCE( !m_ofs.fail(), "Unable to open file: '" << filename << "'" );
            }
            ~FileStream() override = default;
        public: // IStream
            std::ostream& stream() const override {
                return m_ofs;
            }
        };

        ///////////////////////////////////////////////////////////////////////////

        class CoutStream : public IStream {
            mutable std::ostream m_os;
        public:
            // Store the streambuf from cout up-front because
            // cout may get redirected when running tests
            CoutStream() : m_os( Catch::cout().rdbuf() ) {}
            ~CoutStream() override = default;

        public: // IStream
            std::ostream& stream() const override { return m_os; }
        };

        ///////////////////////////////////////////////////////////////////////////

        class DebugOutStream : public IStream {
            std::unique_ptr<StreamBufImpl<OutputDebugWriter>> m_streamBuf;
            mutable std::ostream m_os;
        public:
            DebugOutStream()
            :   m_streamBuf( new StreamBufImpl<OutputDebugWriter>() ),
                m_os( m_streamBuf.get() )
            {}

            ~DebugOutStream() override = default;

        public: // IStream
            std::ostream& stream() const override { return m_os; }
        };

    }} // namespace anon::detail

    ///////////////////////////////////////////////////////////////////////////

    auto makeStream( StringRef const &filename ) -> IStream const* {
        if( filename.empty() )
            return new Detail::CoutStream();
        else if( filename[0] == '%' ) {
            if( filename == "%debug" )
                return new Detail::DebugOutStream();
            else
                CATCH_ERROR( "Unrecognised stream: '" << filename << "'" );
        }
        else
            return new Detail::FileStream( filename );
    }

    // This class encapsulates the idea of a pool of ostringstreams that can be reused.
    struct StringStreams {
        std::vector<std::unique_ptr<std::ostringstream>> m_streams;
        std::vector<std::size_t> m_unused;
        std::ostringstream m_referenceStream; // Used for copy state/ flags from

        auto add() -> std::size_t {
            if( m_unused.empty() ) {
                m_streams.push_back( std::unique_ptr<std::ostringstream>( new std::ostringstream ) );
                return m_streams.size()-1;
            }
            else {
                auto index = m_unused.back();
                m_unused.pop_back();
                return index;
            }
        }

        void release( std::size_t index ) {
            m_streams[index]->copyfmt( m_referenceStream ); // Restore initial flags and other state
            m_unused.push_back(index);
        }
    };

    ReusableStringStream::ReusableStringStream()
    :   m_index( Singleton<StringStreams>::getMutable().add() ),
        m_oss( Singleton<StringStreams>::getMutable().m_streams[m_index].get() )
    {}

    ReusableStringStream::~ReusableStringStream() {
        static_cast<std::ostringstream*>( m_oss )->str("");
        m_oss->clear();
        Singleton<StringStreams>::getMutable().release( m_index );
    }

    auto ReusableStringStream::str() const -> std::string {
        return static_cast<std::ostringstream*>( m_oss )->str();
    }

    ///////////////////////////////////////////////////////////////////////////

#ifndef CATCH_CONFIG_NOSTDOUT // If you #define this you must implement these functions
    std::ostream& cout() { return std::cout; }
    std::ostream& cerr() { return std::cerr; }
    std::ostream& clog() { return std::clog; }
#endif
}
// end catch_stream.cpp
// start catch_string_manip.cpp

#include <algorithm>
#include <ostream>
#include <cstring>
#include <cctype>
#include <vector>

namespace Catch {

    namespace {
        char toLowerCh(char c) {
            return static_cast<char>( std::tolower( static_cast<unsigned char>(c) ) );
        }
    }

    bool startsWith( std::string const& s, std::string const& prefix ) {
        return s.size() >= prefix.size() && std::equal(prefix.begin(), prefix.end(), s.begin());
    }
    bool startsWith( std::string const& s, char prefix ) {
        return !s.empty() && s[0] == prefix;
    }
    bool endsWith( std::string const& s, std::string const& suffix ) {
        return s.size() >= suffix.size() && std::equal(suffix.rbegin(), suffix.rend(), s.rbegin());
    }
    bool endsWith( std::string const& s, char suffix ) {
        return !s.empty() && s[s.size()-1] == suffix;
    }
    bool contains( std::string const& s, std::string const& infix ) {
        return s.find( infix ) != std::string::npos;
    }
    void toLowerInPlace( std::string& s ) {
        std::transform( s.begin(), s.end(), s.begin(), toLowerCh );
    }
    std::string toLower( std::string const& s ) {
        std::string lc = s;
        toLowerInPlace( lc );
        return lc;
    }
    std::string trim( std::string const& str ) {
        static char const* whitespaceChars = "\n\r\t ";
        std::string::size_type start = str.find_first_not_of( whitespaceChars );
        std::string::size_type end = str.find_last_not_of( whitespaceChars );

        return start != std::string::npos ? str.substr( start, 1+end-start ) : std::string();
    }

    StringRef trim(StringRef ref) {
        const auto is_ws = [](char c) {
            return c == ' ' || c == '\t' || c == '\n' || c == '\r';
        };
        size_t real_begin = 0;
        while (real_begin < ref.size() && is_ws(ref[real_begin])) { ++real_begin; }
        size_t real_end = ref.size();
        while (real_end > real_begin && is_ws(ref[real_end - 1])) { --real_end; }

        return ref.substr(real_begin, real_end - real_begin);
    }

    bool replaceInPlace( std::string& str, std::string const& replaceThis, std::string const& withThis ) {
        bool replaced = false;
        std::size_t i = str.find( replaceThis );
        while( i != std::string::npos ) {
            replaced = true;
            str = str.substr( 0, i ) + withThis + str.substr( i+replaceThis.size() );
            if( i < str.size()-withThis.size() )
                i = str.find( replaceThis, i+withThis.size() );
            else
                i = std::string::npos;
        }
        return replaced;
    }

    std::vector<StringRef> splitStringRef( StringRef str, char delimiter ) {
        std::vector<StringRef> subStrings;
        std::size_t start = 0;
        for(std::size_t pos = 0; pos < str.size(); ++pos ) {
            if( str[pos] == delimiter ) {
                if( pos - start > 1 )
                    subStrings.push_back( str.substr( start, pos-start ) );
                start = pos+1;
            }
        }
        if( start < str.size() )
            subStrings.push_back( str.substr( start, str.size()-start ) );
        return subStrings;
    }

    pluralise::pluralise( std::size_t count, std::string const& label )
    :   m_count( count ),
        m_label( label )
    {}

    std::ostream& operator << ( std::ostream& os, pluralise const& pluraliser ) {
        os << pluraliser.m_count << ' ' << pluraliser.m_label;
        if( pluraliser.m_count != 1 )
            os << 's';
        return os;
    }

}
// end catch_string_manip.cpp
// start catch_stringref.cpp

#include <algorithm>
#include <ostream>
#include <cstring>
#include <cstdint>

namespace Catch {
    StringRef::StringRef( char const* rawChars ) noexcept
    : StringRef( rawChars, static_cast<StringRef::size_type>(std::strlen(rawChars) ) )
    {}

    auto StringRef::c_str() const -> char const* {
        CATCH_ENFORCE(isNullTerminated(), "Called StringRef::c_str() on a non-null-terminated instance");
        return m_start;
    }
    auto StringRef::data() const noexcept -> char const* {
        return m_start;
    }

    auto StringRef::substr( size_type start, size_type size ) const noexcept -> StringRef {
        if (start < m_size) {
            return StringRef(m_start + start, (std::min)(m_size - start, size));
        } else {
            return StringRef();
        }
    }
    auto StringRef::operator == ( StringRef const& other ) const noexcept -> bool {
        return m_size == other.m_size
            && (std::memcmp( m_start, other.m_start, m_size ) == 0);
    }

    auto operator << ( std::ostream& os, StringRef const& str ) -> std::ostream& {
        return os.write(str.data(), str.size());
    }

    auto operator+=( std::string& lhs, StringRef const& rhs ) -> std::string& {
        lhs.append(rhs.data(), rhs.size());
        return lhs;
    }

} // namespace Catch
// end catch_stringref.cpp
// start catch_tag_alias.cpp

namespace Catch {
    TagAlias::TagAlias(std::string const & _tag, SourceLineInfo _lineInfo): tag(_tag), lineInfo(_lineInfo) {}
}
// end catch_tag_alias.cpp
// start catch_tag_alias_autoregistrar.cpp

namespace Catch {

    RegistrarForTagAliases::RegistrarForTagAliases(char const* alias, char const* tag, SourceLineInfo const& lineInfo) {
        CATCH_TRY {
            getMutableRegistryHub().registerTagAlias(alias, tag, lineInfo);
        } CATCH_CATCH_ALL {
            // Do not throw when constructing global objects, instead register the exception to be processed later
            getMutableRegistryHub().registerStartupException();
        }
    }

}
// end catch_tag_alias_autoregistrar.cpp
// start catch_tag_alias_registry.cpp

#include <sstream>

namespace Catch {

    TagAliasRegistry::~TagAliasRegistry() {}

    TagAlias const* TagAliasRegistry::find( std::string const& alias ) const {
        auto it = m_registry.find( alias );
        if( it != m_registry.end() )
            return &(it->second);
        else
            return nullptr;
    }

    std::string TagAliasRegistry::expandAliases( std::string const& unexpandedTestSpec ) const {
        std::string expandedTestSpec = unexpandedTestSpec;
        for( auto const& registryKvp : m_registry ) {
            std::size_t pos = expandedTestSpec.find( registryKvp.first );
            if( pos != std::string::npos ) {
                expandedTestSpec =  expandedTestSpec.substr( 0, pos ) +
                                    registryKvp.second.tag +
                                    expandedTestSpec.substr( pos + registryKvp.first.size() );
            }
        }
        return expandedTestSpec;
    }

    void TagAliasRegistry::add( std::string const& alias, std::string const& tag, SourceLineInfo const& lineInfo ) {
        CATCH_ENFORCE( startsWith(alias, "[@") && endsWith(alias, ']'),
                      "error: tag alias, '" << alias << "' is not of the form [@alias name].\n" << lineInfo );

        CATCH_ENFORCE( m_registry.insert(std::make_pair(alias, TagAlias(tag, lineInfo))).second,
                      "error: tag alias, '" << alias << "' already registered.\n"
                      << "\tFirst seen at: " << find(alias)->lineInfo << "\n"
                      << "\tRedefined at: " << lineInfo );
    }

    ITagAliasRegistry::~ITagAliasRegistry() {}

    ITagAliasRegistry const& ITagAliasRegistry::get() {
        return getRegistryHub().getTagAliasRegistry();
    }

} // end namespace Catch
// end catch_tag_alias_registry.cpp
// start catch_test_case_info.cpp

#include <cctype>
#include <exception>
#include <algorithm>
#include <sstream>

namespace Catch {

    namespace {
        TestCaseInfo::SpecialProperties parseSpecialTag( std::string const& tag ) {
            if( startsWith( tag, '.' ) ||
                tag == "!hide" )
                return TestCaseInfo::IsHidden;
            else if( tag == "!throws" )
                return TestCaseInfo::Throws;
            else if( tag == "!shouldfail" )
                return TestCaseInfo::ShouldFail;
            else if( tag == "!mayfail" )
                return TestCaseInfo::MayFail;
            else if( tag == "!nonportable" )
                return TestCaseInfo::NonPortable;
            else if( tag == "!benchmark" )
                return static_cast<TestCaseInfo::SpecialProperties>( TestCaseInfo::Benchmark | TestCaseInfo::IsHidden );
            else
                return TestCaseInfo::None;
        }
        bool isReservedTag( std::string const& tag ) {
            return parseSpecialTag( tag ) == TestCaseInfo::None && tag.size() > 0 && !std::isalnum( static_cast<unsigned char>(tag[0]) );
        }
        void enforceNotReservedTag( std::string const& tag, SourceLineInfo const& _lineInfo ) {
            CATCH_ENFORCE( !isReservedTag(tag),
                          "Tag name: [" << tag << "] is not allowed.\n"
                          << "Tag names starting with non alphanumeric characters are reserved\n"
                          << _lineInfo );
        }
    }

    TestCase makeTestCase(  ITestInvoker* _testCase,
                            std::string const& _className,
                            NameAndTags const& nameAndTags,
                            SourceLineInfo const& _lineInfo )
    {
        bool isHidden = false;

        // Parse out tags
        std::vector<std::string> tags;
        std::string desc, tag;
        bool inTag = false;
        for (char c : nameAndTags.tags) {
            if( !inTag ) {
                if( c == '[' )
                    inTag = true;
                else
                    desc += c;
            }
            else {
                if( c == ']' ) {
                    TestCaseInfo::SpecialProperties prop = parseSpecialTag( tag );
                    if( ( prop & TestCaseInfo::IsHidden ) != 0 )
                        isHidden = true;
                    else if( prop == TestCaseInfo::None )
                        enforceNotReservedTag( tag, _lineInfo );

                    // Merged hide tags like `[.approvals]` should be added as
                    // `[.][approvals]`. The `[.]` is added at later point, so
                    // we only strip the prefix
                    if (startsWith(tag, '.') && tag.size() > 1) {
                        tag.erase(0, 1);
                    }
                    tags.push_back( tag );
                    tag.clear();
                    inTag = false;
                }
                else
                    tag += c;
            }
        }
        if( isHidden ) {
            // Add all "hidden" tags to make them behave identically
            tags.insert( tags.end(), { ".", "!hide" } );
        }

        TestCaseInfo info( static_cast<std::string>(nameAndTags.name), _className, desc, tags, _lineInfo );
        return TestCase( _testCase, std::move(info) );
    }

    void setTags( TestCaseInfo& testCaseInfo, std::vector<std::string> tags ) {
        std::sort(begin(tags), end(tags));
        tags.erase(std::unique(begin(tags), end(tags)), end(tags));
        testCaseInfo.lcaseTags.clear();

        for( auto const& tag : tags ) {
            std::string lcaseTag = toLower( tag );
            testCaseInfo.properties = static_cast<TestCaseInfo::SpecialProperties>( testCaseInfo.properties | parseSpecialTag( lcaseTag ) );
            testCaseInfo.lcaseTags.push_back( lcaseTag );
        }
        testCaseInfo.tags = std::move(tags);
    }

    TestCaseInfo::TestCaseInfo( std::string const& _name,
                                std::string const& _className,
                                std::string const& _description,
                                std::vector<std::string> const& _tags,
                                SourceLineInfo const& _lineInfo )
    :   name( _name ),
        className( _className ),
        description( _description ),
        lineInfo( _lineInfo ),
        properties( None )
    {
        setTags( *this, _tags );
    }

    bool TestCaseInfo::isHidden() const {
        return ( properties & IsHidden ) != 0;
    }
    bool TestCaseInfo::throws() const {
        return ( properties & Throws ) != 0;
    }
    bool TestCaseInfo::okToFail() const {
        return ( properties & (ShouldFail | MayFail ) ) != 0;
    }
    bool TestCaseInfo::expectedToFail() const {
        return ( properties & (ShouldFail ) ) != 0;
    }

    std::string TestCaseInfo::tagsAsString() const {
        std::string ret;
        // '[' and ']' per tag
        std::size_t full_size = 2 * tags.size();
        for (const auto& tag : tags) {
            full_size += tag.size();
        }
        ret.reserve(full_size);
        for (const auto& tag : tags) {
            ret.push_back('[');
            ret.append(tag);
            ret.push_back(']');
        }

        return ret;
    }

    TestCase::TestCase( ITestInvoker* testCase, TestCaseInfo&& info ) : TestCaseInfo( std::move(info) ), test( testCase ) {}

    TestCase TestCase::withName( std::string const& _newName ) const {
        TestCase other( *this );
        other.name = _newName;
        return other;
    }

    void TestCase::invoke() const {
        test->invoke();
    }

    bool TestCase::operator == ( TestCase const& other ) const {
        return  test.get() == other.test.get() &&
                name == other.name &&
                className == other.className;
    }

    bool TestCase::operator < ( TestCase const& other ) const {
        return name < other.name;
    }

    TestCaseInfo const& TestCase::getTestCaseInfo() const
    {
        return *this;
    }

} // end namespace Catch
// end catch_test_case_info.cpp
// start catch_test_case_registry_impl.cpp

#include <algorithm>
#include <sstream>

namespace Catch {

    namespace {
        struct TestHasher {
            explicit TestHasher(Catch::SimplePcg32& rng) {
                basis = rng();
                basis <<= 32;
                basis |= rng();
            }

            uint64_t basis;

            uint64_t operator()(TestCase const& t) const {
                // Modified FNV-1a hash
                static constexpr uint64_t prime = 1099511628211;
                uint64_t hash = basis;
                for (const char c : t.name) {
                    hash ^= c;
                    hash *= prime;
                }
                return hash;
            }
        };
    } // end unnamed namespace

    std::vector<TestCase> sortTests( IConfig const& config, std::vector<TestCase> const& unsortedTestCases ) {
        switch( config.runOrder() ) {
            case RunTests::InDeclarationOrder:
                // already in declaration order
                break;

            case RunTests::InLexicographicalOrder: {
                std::vector<TestCase> sorted = unsortedTestCases;
                std::sort( sorted.begin(), sorted.end() );
                return sorted;
            }

            case RunTests::InRandomOrder: {
                seedRng( config );
                TestHasher h( rng() );

                using hashedTest = std::pair<uint64_t, TestCase const*>;
                std::vector<hashedTest> indexed_tests;
                indexed_tests.reserve( unsortedTestCases.size() );

                for (auto const& testCase : unsortedTestCases) {
                    indexed_tests.emplace_back(h(testCase), &testCase);
                }

                std::sort(indexed_tests.begin(), indexed_tests.end(),
                          [](hashedTest const& lhs, hashedTest const& rhs) {
                          if (lhs.first == rhs.first) {
                              return lhs.second->name < rhs.second->name;
                          }
                          return lhs.first < rhs.first;
                });

                std::vector<TestCase> sorted;
                sorted.reserve( indexed_tests.size() );

                for (auto const& hashed : indexed_tests) {
                    sorted.emplace_back(*hashed.second);
                }

                return sorted;
            }
        }
        return unsortedTestCases;
    }

    bool isThrowSafe( TestCase const& testCase, IConfig const& config ) {
        return !testCase.throws() || config.allowThrows();
    }

    bool matchTest( TestCase const& testCase, TestSpec const& testSpec, IConfig const& config ) {
        return testSpec.matches( testCase ) && isThrowSafe( testCase, config );
    }

    void enforceNoDuplicateTestCases( std::vector<TestCase> const& functions ) {
        std::set<TestCase> seenFunctions;
        for( auto const& function : functions ) {
            auto prev = seenFunctions.insert( function );
            CATCH_ENFORCE( prev.second,
                    "error: TEST_CASE( \"" << function.name << "\" ) already defined.\n"
                    << "\tFirst seen at " << prev.first->getTestCaseInfo().lineInfo << "\n"
                    << "\tRedefined at " << function.getTestCaseInfo().lineInfo );
        }
    }

    std::vector<TestCase> filterTests( std::vector<TestCase> const& testCases, TestSpec const& testSpec, IConfig const& config ) {
        std::vector<TestCase> filtered;
        filtered.reserve( testCases.size() );
        for (auto const& testCase : testCases) {
            if ((!testSpec.hasFilters() && !testCase.isHidden()) ||
                (testSpec.hasFilters() && matchTest(testCase, testSpec, config))) {
                filtered.push_back(testCase);
            }
        }
        return filtered;
    }
    std::vector<TestCase> const& getAllTestCasesSorted( IConfig const& config ) {
        return getRegistryHub().getTestCaseRegistry().getAllTestsSorted( config );
    }

    void TestRegistry::registerTest( TestCase const& testCase ) {
        std::string name = testCase.getTestCaseInfo().name;
        if( name.empty() ) {
            ReusableStringStream rss;
            rss << "Anonymous test case " << ++m_unnamedCount;
            return registerTest( testCase.withName( rss.str() ) );
        }
        m_functions.push_back( testCase );
    }

    std::vector<TestCase> const& TestRegistry::getAllTests() const {
        return m_functions;
    }
    std::vector<TestCase> const& TestRegistry::getAllTestsSorted( IConfig const& config ) const {
        if( m_sortedFunctions.empty() )
            enforceNoDuplicateTestCases( m_functions );

        if(  m_currentSortOrder != config.runOrder() || m_sortedFunctions.empty() ) {
            m_sortedFunctions = sortTests( config, m_functions );
            m_currentSortOrder = config.runOrder();
        }
        return m_sortedFunctions;
    }

    ///////////////////////////////////////////////////////////////////////////
    TestInvokerAsFunction::TestInvokerAsFunction( void(*testAsFunction)() ) noexcept : m_testAsFunction( testAsFunction ) {}

    void TestInvokerAsFunction::invoke() const {
        m_testAsFunction();
    }

    std::string extractClassName( StringRef const& classOrQualifiedMethodName ) {
        std::string className(classOrQualifiedMethodName);
        if( startsWith( className, '&' ) )
        {
            std::size_t lastColons = className.rfind( "::" );
            std::size_t penultimateColons = className.rfind( "::", lastColons-1 );
            if( penultimateColons == std::string::npos )
                penultimateColons = 1;
            className = className.substr( penultimateColons, lastColons-penultimateColons );
        }
        return className;
    }

} // end namespace Catch
// end catch_test_case_registry_impl.cpp
// start catch_test_case_tracker.cpp

#include <algorithm>
#include <cassert>
#include <stdexcept>
#include <memory>
#include <sstream>

#if defined(__clang__)
#    pragma clang diagnostic push
#    pragma clang diagnostic ignored "-Wexit-time-destructors"
#endif

namespace Catch {
namespace TestCaseTracking {

    NameAndLocation::NameAndLocation( std::string const& _name, SourceLineInfo const& _location )
    :   name( _name ),
        location( _location )
    {}

    ITracker::~ITracker() = default;

    ITracker& TrackerContext::startRun() {
        m_rootTracker = std::make_shared<SectionTracker>( NameAndLocation( "{root}", CATCH_INTERNAL_LINEINFO ), *this, nullptr );
        m_currentTracker = nullptr;
        m_runState = Executing;
        return *m_rootTracker;
    }

    void TrackerContext::endRun() {
        m_rootTracker.reset();
        m_currentTracker = nullptr;
        m_runState = NotStarted;
    }

    void TrackerContext::startCycle() {
        m_currentTracker = m_rootTracker.get();
        m_runState = Executing;
    }
    void TrackerContext::completeCycle() {
        m_runState = CompletedCycle;
    }

    bool TrackerContext::completedCycle() const {
        return m_runState == CompletedCycle;
    }
    ITracker& TrackerContext::currentTracker() {
        return *m_currentTracker;
    }
    void TrackerContext::setCurrentTracker( ITracker* tracker ) {
        m_currentTracker = tracker;
    }

    TrackerBase::TrackerBase( NameAndLocation const& nameAndLocation, TrackerContext& ctx, ITracker* parent ):
        ITracker(nameAndLocation),
        m_ctx( ctx ),
        m_parent( parent )
    {}

    bool TrackerBase::isComplete() const {
        return m_runState == CompletedSuccessfully || m_runState == Failed;
    }
    bool TrackerBase::isSuccessfullyCompleted() const {
        return m_runState == CompletedSuccessfully;
    }
    bool TrackerBase::isOpen() const {
        return m_runState != NotStarted && !isComplete();
    }
    bool TrackerBase::hasChildren() const {
        return !m_children.empty();
    }

    void TrackerBase::addChild( ITrackerPtr const& child ) {
        m_children.push_back( child );
    }

    ITrackerPtr TrackerBase::findChild( NameAndLocation const& nameAndLocation ) {
        auto it = std::find_if( m_children.begin(), m_children.end(),
            [&nameAndLocation]( ITrackerPtr const& tracker ){
                return
                    tracker->nameAndLocation().location == nameAndLocation.location &&
                    tracker->nameAndLocation().name == nameAndLocation.name;
            } );
        return( it != m_children.end() )
            ? *it
            : nullptr;
    }
    ITracker& TrackerBase::parent() {
        assert( m_parent ); // Should always be non-null except for root
        return *m_parent;
    }

    void TrackerBase::openChild() {
        if( m_runState != ExecutingChildren ) {
            m_runState = ExecutingChildren;
            if( m_parent )
                m_parent->openChild();
        }
    }

    bool TrackerBase::isSectionTracker() const { return false; }
    bool TrackerBase::isGeneratorTracker() const { return false; }

    void TrackerBase::open() {
        m_runState = Executing;
        moveToThis();
        if( m_parent )
            m_parent->openChild();
    }

    void TrackerBase::close() {

        // Close any still open children (e.g. generators)
        while( &m_ctx.currentTracker() != this )
            m_ctx.currentTracker().close();

        switch( m_runState ) {
            case NeedsAnotherRun:
                break;

            case Executing:
                m_runState = CompletedSuccessfully;
                break;
            case ExecutingChildren:
                if( std::all_of(m_children.begin(), m_children.end(), [](ITrackerPtr const& t){ return t->isComplete(); }) )
                    m_runState = CompletedSuccessfully;
                break;

            case NotStarted:
            case CompletedSuccessfully:
            case Failed:
                CATCH_INTERNAL_ERROR( "Illogical state: " << m_runState );

            default:
                CATCH_INTERNAL_ERROR( "Unknown state: " << m_runState );
        }
        moveToParent();
        m_ctx.completeCycle();
    }
    void TrackerBase::fail() {
        m_runState = Failed;
        if( m_parent )
            m_parent->markAsNeedingAnotherRun();
        moveToParent();
        m_ctx.completeCycle();
    }
    void TrackerBase::markAsNeedingAnotherRun() {
        m_runState = NeedsAnotherRun;
    }

    void TrackerBase::moveToParent() {
        assert( m_parent );
        m_ctx.setCurrentTracker( m_parent );
    }
    void TrackerBase::moveToThis() {
        m_ctx.setCurrentTracker( this );
    }

    SectionTracker::SectionTracker( NameAndLocation const& nameAndLocation, TrackerContext& ctx, ITracker* parent )
    :   TrackerBase( nameAndLocation, ctx, parent ),
        m_trimmed_name(trim(nameAndLocation.name))
    {
        if( parent ) {
            while( !parent->isSectionTracker() )
                parent = &parent->parent();

            SectionTracker& parentSection = static_cast<SectionTracker&>( *parent );
            addNextFilters( parentSection.m_filters );
        }
    }

    bool SectionTracker::isComplete() const {
        bool complete = true;

        if (m_filters.empty()
            || m_filters[0] == ""
            || std::find(m_filters.begin(), m_filters.end(), m_trimmed_name) != m_filters.end()) {
            complete = TrackerBase::isComplete();
        }
        return complete;
    }

    bool SectionTracker::isSectionTracker() const { return true; }

    SectionTracker& SectionTracker::acquire( TrackerContext& ctx, NameAndLocation const& nameAndLocation ) {
        std::shared_ptr<SectionTracker> section;

        ITracker& currentTracker = ctx.currentTracker();
        if( ITrackerPtr childTracker = currentTracker.findChild( nameAndLocation ) ) {
            assert( childTracker );
            assert( childTracker->isSectionTracker() );
            section = std::static_pointer_cast<SectionTracker>( childTracker );
        }
        else {
            section = std::make_shared<SectionTracker>( nameAndLocation, ctx, &currentTracker );
            currentTracker.addChild( section );
        }
        if( !ctx.completedCycle() )
            section->tryOpen();
        return *section;
    }

    void SectionTracker::tryOpen() {
        if( !isComplete() )
            open();
    }

    void SectionTracker::addInitialFilters( std::vector<std::string> const& filters ) {
        if( !filters.empty() ) {
            m_filters.reserve( m_filters.size() + filters.size() + 2 );
            m_filters.emplace_back(""); // Root - should never be consulted
            m_filters.emplace_back(""); // Test Case - not a section filter
            m_filters.insert( m_filters.end(), filters.begin(), filters.end() );
        }
    }
    void SectionTracker::addNextFilters( std::vector<std::string> const& filters ) {
        if( filters.size() > 1 )
            m_filters.insert( m_filters.end(), filters.begin()+1, filters.end() );
    }

} // namespace TestCaseTracking

using TestCaseTracking::ITracker;
using TestCaseTracking::TrackerContext;
using TestCaseTracking::SectionTracker;

} // namespace Catch

#if defined(__clang__)
#    pragma clang diagnostic pop
#endif
// end catch_test_case_tracker.cpp
// start catch_test_registry.cpp

namespace Catch {

    auto makeTestInvoker( void(*testAsFunction)() ) noexcept -> ITestInvoker* {
        return new(std::nothrow) TestInvokerAsFunction( testAsFunction );
    }

    NameAndTags::NameAndTags( StringRef const& name_ , StringRef const& tags_ ) noexcept : name( name_ ), tags( tags_ ) {}

    AutoReg::AutoReg( ITestInvoker* invoker, SourceLineInfo const& lineInfo, StringRef const& classOrMethod, NameAndTags const& nameAndTags ) noexcept {
        CATCH_TRY {
            getMutableRegistryHub()
                    .registerTest(
                        makeTestCase(
                            invoker,
                            extractClassName( classOrMethod ),
                            nameAndTags,
                            lineInfo));
        } CATCH_CATCH_ALL {
            // Do not throw when constructing global objects, instead register the exception to be processed later
            getMutableRegistryHub().registerStartupException();
        }
    }

    AutoReg::~AutoReg() = default;
}
// end catch_test_registry.cpp
// start catch_test_spec.cpp

#include <algorithm>
#include <string>
#include <vector>
#include <memory>

namespace Catch {

    TestSpec::Pattern::Pattern( std::string const& name )
    : m_name( name )
    {}

    TestSpec::Pattern::~Pattern() = default;

    std::string const& TestSpec::Pattern::name() const {
        return m_name;
    }

    TestSpec::NamePattern::NamePattern( std::string const& name, std::string const& filterString )
    : Pattern( filterString )
    , m_wildcardPattern( toLower( name ), CaseSensitive::No )
    {}

    bool TestSpec::NamePattern::matches( TestCaseInfo const& testCase ) const {
        return m_wildcardPattern.matches( testCase.name );
    }

    TestSpec::TagPattern::TagPattern( std::string const& tag, std::string const& filterString )
    : Pattern( filterString )
    , m_tag( toLower( tag ) )
    {}

    bool TestSpec::TagPattern::matches( TestCaseInfo const& testCase ) const {
        return std::find(begin(testCase.lcaseTags),
                         end(testCase.lcaseTags),
                         m_tag) != end(testCase.lcaseTags);
    }

    TestSpec::ExcludedPattern::ExcludedPattern( PatternPtr const& underlyingPattern )
    : Pattern( underlyingPattern->name() )
    , m_underlyingPattern( underlyingPattern )
    {}

    bool TestSpec::ExcludedPattern::matches( TestCaseInfo const& testCase ) const {
        return !m_underlyingPattern->matches( testCase );
    }

    bool TestSpec::Filter::matches( TestCaseInfo const& testCase ) const {
        return std::all_of( m_patterns.begin(), m_patterns.end(), [&]( PatternPtr const& p ){ return p->matches( testCase ); } );
    }

    std::string TestSpec::Filter::name() const {
        std::string name;
        for( auto const& p : m_patterns )
            name += p->name();
        return name;
    }

    bool TestSpec::hasFilters() const {
        return !m_filters.empty();
    }

    bool TestSpec::matches( TestCaseInfo const& testCase ) const {
        return std::any_of( m_filters.begin(), m_filters.end(), [&]( Filter const& f ){ return f.matches( testCase ); } );
    }

    TestSpec::Matches TestSpec::matchesByFilter( std::vector<TestCase> const& testCases, IConfig const& config ) const
    {
        Matches matches( m_filters.size() );
        std::transform( m_filters.begin(), m_filters.end(), matches.begin(), [&]( Filter const& filter ){
            std::vector<TestCase const*> currentMatches;
            for( auto const& test : testCases )
                if( isThrowSafe( test, config ) && filter.matches( test ) )
                    currentMatches.emplace_back( &test );
            return FilterMatch{ filter.name(), currentMatches };
        } );
        return matches;
    }

    const TestSpec::vectorStrings& TestSpec::getInvalidArgs() const{
        return  (m_invalidArgs);
    }

}
// end catch_test_spec.cpp
// start catch_test_spec_parser.cpp

namespace Catch {

    TestSpecParser::TestSpecParser( ITagAliasRegistry const& tagAliases ) : m_tagAliases( &tagAliases ) {}

    TestSpecParser& TestSpecParser::parse( std::string const& arg ) {
        m_mode = None;
        m_exclusion = false;
        m_arg = m_tagAliases->expandAliases( arg );
        m_escapeChars.clear();
        m_substring.reserve(m_arg.size());
        m_patternName.reserve(m_arg.size());
        m_realPatternPos = 0;

        for( m_pos = 0; m_pos < m_arg.size(); ++m_pos )
          //if visitChar fails
           if( !visitChar( m_arg[m_pos] ) ){
               m_testSpec.m_invalidArgs.push_back(arg);
               break;
           }
        endMode();
        return *this;
    }
    TestSpec TestSpecParser::testSpec() {
        addFilter();
        return m_testSpec;
    }
    bool TestSpecParser::visitChar( char c ) {
        if( (m_mode != EscapedName) && (c == '\\') ) {
            escape();
            addCharToPattern(c);
            return true;
        }else if((m_mode != EscapedName) && (c == ',') )  {
            return separate();
        }

        switch( m_mode ) {
        case None:
            if( processNoneChar( c ) )
                return true;
            break;
        case Name:
            processNameChar( c );
            break;
        case EscapedName:
            endMode();
            addCharToPattern(c);
            return true;
        default:
        case Tag:
        case QuotedName:
            if( processOtherChar( c ) )
                return true;
            break;
        }

        m_substring += c;
        if( !isControlChar( c ) ) {
            m_patternName += c;
            m_realPatternPos++;
        }
        return true;
    }
    // Two of the processing methods return true to signal the caller to return
    // without adding the given character to the current pattern strings
    bool TestSpecParser::processNoneChar( char c ) {
        switch( c ) {
        case ' ':
            return true;
        case '~':
            m_exclusion = true;
            return false;
        case '[':
            startNewMode( Tag );
            return false;
        case '"':
            startNewMode( QuotedName );
            return false;
        default:
            startNewMode( Name );
            return false;
        }
    }
    void TestSpecParser::processNameChar( char c ) {
        if( c == '[' ) {
            if( m_substring == "exclude:" )
                m_exclusion = true;
            else
                endMode();
            startNewMode( Tag );
        }
    }
    bool TestSpecParser::processOtherChar( char c ) {
        if( !isControlChar( c ) )
            return false;
        m_substring += c;
        endMode();
        return true;
    }
    void TestSpecParser::startNewMode( Mode mode ) {
        m_mode = mode;
    }
    void TestSpecParser::endMode() {
        switch( m_mode ) {
        case Name:
        case QuotedName:
            return addNamePattern();
        case Tag:
            return addTagPattern();
        case EscapedName:
            revertBackToLastMode();
            return;
        case None:
        default:
            return startNewMode( None );
        }
    }
    void TestSpecParser::escape() {
        saveLastMode();
        m_mode = EscapedName;
        m_escapeChars.push_back(m_realPatternPos);
    }
    bool TestSpecParser::isControlChar( char c ) const {
        switch( m_mode ) {
            default:
                return false;
            case None:
                return c == '~';
            case Name:
                return c == '[';
            case EscapedName:
                return true;
            case QuotedName:
                return c == '"';
            case Tag:
                return c == '[' || c == ']';
        }
    }

    void TestSpecParser::addFilter() {
        if( !m_currentFilter.m_patterns.empty() ) {
            m_testSpec.m_filters.push_back( m_currentFilter );
            m_currentFilter = TestSpec::Filter();
        }
    }

    void TestSpecParser::saveLastMode() {
      lastMode = m_mode;
    }

    void TestSpecParser::revertBackToLastMode() {
      m_mode = lastMode;
    }

    bool TestSpecParser::separate() {
      if( (m_mode==QuotedName) || (m_mode==Tag) ){
         //invalid argument, signal failure to previous scope.
         m_mode = None;
         m_pos = m_arg.size();
         m_substring.clear();
         m_patternName.clear();
         m_realPatternPos = 0;
         return false;
      }
      endMode();
      addFilter();
      return true; //success
    }

    std::string TestSpecParser::preprocessPattern() {
        std::string token = m_patternName;
        for (std::size_t i = 0; i < m_escapeChars.size(); ++i)
            token = token.substr(0, m_escapeChars[i] - i) + token.substr(m_escapeChars[i] - i + 1);
        m_escapeChars.clear();
        if (startsWith(token, "exclude:")) {
            m_exclusion = true;
            token = token.substr(8);
        }

        m_patternName.clear();
        m_realPatternPos = 0;

        return token;
    }

    void TestSpecParser::addNamePattern() {
        auto token = preprocessPattern();

        if (!token.empty()) {
            TestSpec::PatternPtr pattern = std::make_shared<TestSpec::NamePattern>(token, m_substring);
            if (m_exclusion)
                pattern = std::make_shared<TestSpec::ExcludedPattern>(pattern);
            m_currentFilter.m_patterns.push_back(pattern);
        }
        m_substring.clear();
        m_exclusion = false;
        m_mode = None;
    }

    void TestSpecParser::addTagPattern() {
        auto token = preprocessPattern();

        if (!token.empty()) {
            // If the tag pattern is the "hide and tag" shorthand (e.g. [.foo])
            // we have to create a separate hide tag and shorten the real one
            if (token.size() > 1 && token[0] == '.') {
                token.erase(token.begin());
                TestSpec::PatternPtr pattern = std::make_shared<TestSpec::TagPattern>(".", m_substring);
                if (m_exclusion) {
                    pattern = std::make_shared<TestSpec::ExcludedPattern>(pattern);
                }
                m_currentFilter.m_patterns.push_back(pattern);
            }

            TestSpec::PatternPtr pattern = std::make_shared<TestSpec::TagPattern>(token, m_substring);

            if (m_exclusion) {
                pattern = std::make_shared<TestSpec::ExcludedPattern>(pattern);
            }
            m_currentFilter.m_patterns.push_back(pattern);
        }
        m_substring.clear();
        m_exclusion = false;
        m_mode = None;
    }

    TestSpec parseTestSpec( std::string const& arg ) {
        return TestSpecParser( ITagAliasRegistry::get() ).parse( arg ).testSpec();
    }

} // namespace Catch
// end catch_test_spec_parser.cpp
// start catch_timer.cpp

#include <chrono>

static const uint64_t nanosecondsInSecond = 1000000000;

namespace Catch {

    auto getCurrentNanosecondsSinceEpoch() -> uint64_t {
        return std::chrono::duration_cast<std::chrono::nanoseconds>( std::chrono::high_resolution_clock::now().time_since_epoch() ).count();
    }

    namespace {
        auto estimateClockResolution() -> uint64_t {
            uint64_t sum = 0;
            static const uint64_t iterations = 1000000;

            auto startTime = getCurrentNanosecondsSinceEpoch();

            for( std::size_t i = 0; i < iterations; ++i ) {

                uint64_t ticks;
                uint64_t baseTicks = getCurrentNanosecondsSinceEpoch();
                do {
                    ticks = getCurrentNanosecondsSinceEpoch();
                } while( ticks == baseTicks );

                auto delta = ticks - baseTicks;
                sum += delta;

                // If we have been calibrating for over 3 seconds -- the clock
                // is terrible and we should move on.
                // TBD: How to signal that the measured resolution is probably wrong?
                if (ticks > startTime + 3 * nanosecondsInSecond) {
                    return sum / ( i + 1u );
                }
            }

            // We're just taking the mean, here. To do better we could take the std. dev and exclude outliers
            // - and potentially do more iterations if there's a high variance.
            return sum/iterations;
        }
    }
    auto getEstimatedClockResolution() -> uint64_t {
        static auto s_resolution = estimateClockResolution();
        return s_resolution;
    }

    void Timer::start() {
       m_nanoseconds = getCurrentNanosecondsSinceEpoch();
    }
    auto Timer::getElapsedNanoseconds() const -> uint64_t {
        return getCurrentNanosecondsSinceEpoch() - m_nanoseconds;
    }
    auto Timer::getElapsedMicroseconds() const -> uint64_t {
        return getElapsedNanoseconds()/1000;
    }
    auto Timer::getElapsedMilliseconds() const -> unsigned int {
        return static_cast<unsigned int>(getElapsedMicroseconds()/1000);
    }
    auto Timer::getElapsedSeconds() const -> double {
        return getElapsedMicroseconds()/1000000.0;
    }

} // namespace Catch
// end catch_timer.cpp
// start catch_tostring.cpp

#if defined(__clang__)
#    pragma clang diagnostic push
#    pragma clang diagnostic ignored "-Wexit-time-destructors"
#    pragma clang diagnostic ignored "-Wglobal-constructors"
#endif

// Enable specific decls locally
#if !defined(CATCH_CONFIG_ENABLE_CHRONO_STRINGMAKER)
#define CATCH_CONFIG_ENABLE_CHRONO_STRINGMAKER
#endif

#include <cmath>
#include <iomanip>

namespace Catch {

namespace Detail {

    const std::string unprintableString = "{?}";

    namespace {
        const int hexThreshold = 255;

        struct Endianness {
            enum Arch { Big, Little };

            static Arch which() {
                int one = 1;
                // If the lowest byte we read is non-zero, we can assume
                // that little endian format is used.
                auto value = *reinterpret_cast<char*>(&one);
                return value ? Little : Big;
            }
        };
    }

    std::string rawMemoryToString( const void *object, std::size_t size ) {
        // Reverse order for little endian architectures
        int i = 0, end = static_cast<int>( size ), inc = 1;
        if( Endianness::which() == Endianness::Little ) {
            i = end-1;
            end = inc = -1;
        }

        unsigned char const *bytes = static_cast<unsigned char const *>(object);
        ReusableStringStream rss;
        rss << "0x" << std::setfill('0') << std::hex;
        for( ; i != end; i += inc )
             rss << std::setw(2) << static_cast<unsigned>(bytes[i]);
       return rss.str();
    }
}

template<typename T>
std::string fpToString( T value, int precision ) {
    if (Catch::isnan(value)) {
        return "nan";
    }

    ReusableStringStream rss;
    rss << std::setprecision( precision )
        << std::fixed
        << value;
    std::string d = rss.str();
    std::size_t i = d.find_last_not_of( '0' );
    if( i != std::string::npos && i != d.size()-1 ) {
        if( d[i] == '.' )
            i++;
        d = d.substr( 0, i+1 );
    }
    return d;
}

//// ======================================================= ////
//
//   Out-of-line defs for full specialization of StringMaker
//
//// ======================================================= ////

std::string StringMaker<std::string>::convert(const std::string& str) {
    if (!getCurrentContext().getConfig()->showInvisibles()) {
        return '"' + str + '"';
    }

    std::string s("\"");
    for (char c : str) {
        switch (c) {
        case '\n':
            s.append("\\n");
            break;
        case '\t':
            s.append("\\t");
            break;
        default:
            s.push_back(c);
            break;
        }
    }
    s.append("\"");
    return s;
}

#ifdef CATCH_CONFIG_CPP17_STRING_VIEW
std::string StringMaker<std::string_view>::convert(std::string_view str) {
    return ::Catch::Detail::stringify(std::string{ str });
}
#endif

std::string StringMaker<char const*>::convert(char const* str) {
    if (str) {
        return ::Catch::Detail::stringify(std::string{ str });
    } else {
        return{ "{null string}" };
    }
}
std::string StringMaker<char*>::convert(char* str) {
    if (str) {
        return ::Catch::Detail::stringify(std::string{ str });
    } else {
        return{ "{null string}" };
    }
}

#ifdef CATCH_CONFIG_WCHAR
std::string StringMaker<std::wstring>::convert(const std::wstring& wstr) {
    std::string s;
    s.reserve(wstr.size());
    for (auto c : wstr) {
        s += (c <= 0xff) ? static_cast<char>(c) : '?';
    }
    return ::Catch::Detail::stringify(s);
}

# ifdef CATCH_CONFIG_CPP17_STRING_VIEW
std::string StringMaker<std::wstring_view>::convert(std::wstring_view str) {
    return StringMaker<std::wstring>::convert(std::wstring(str));
}
# endif

std::string StringMaker<wchar_t const*>::convert(wchar_t const * str) {
    if (str) {
        return ::Catch::Detail::stringify(std::wstring{ str });
    } else {
        return{ "{null string}" };
    }
}
std::string StringMaker<wchar_t *>::convert(wchar_t * str) {
    if (str) {
        return ::Catch::Detail::stringify(std::wstring{ str });
    } else {
        return{ "{null string}" };
    }
}
#endif

#if defined(CATCH_CONFIG_CPP17_BYTE)
#include <cstddef>
std::string StringMaker<std::byte>::convert(std::byte value) {
    return ::Catch::Detail::stringify(std::to_integer<unsigned long long>(value));
}
#endif // defined(CATCH_CONFIG_CPP17_BYTE)

std::string StringMaker<int>::convert(int value) {
    return ::Catch::Detail::stringify(static_cast<long long>(value));
}
std::string StringMaker<long>::convert(long value) {
    return ::Catch::Detail::stringify(static_cast<long long>(value));
}
std::string StringMaker<long long>::convert(long long value) {
    ReusableStringStream rss;
    rss << value;
    if (value > Detail::hexThreshold) {
        rss << " (0x" << std::hex << value << ')';
    }
    return rss.str();
}

std::string StringMaker<unsigned int>::convert(unsigned int value) {
    return ::Catch::Detail::stringify(static_cast<unsigned long long>(value));
}
std::string StringMaker<unsigned long>::convert(unsigned long value) {
    return ::Catch::Detail::stringify(static_cast<unsigned long long>(value));
}
std::string StringMaker<unsigned long long>::convert(unsigned long long value) {
    ReusableStringStream rss;
    rss << value;
    if (value > Detail::hexThreshold) {
        rss << " (0x" << std::hex << value << ')';
    }
    return rss.str();
}

std::string StringMaker<bool>::convert(bool b) {
    return b ? "true" : "false";
}

std::string StringMaker<signed char>::convert(signed char value) {
    if (value == '\r') {
        return "'\\r'";
    } else if (value == '\f') {
        return "'\\f'";
    } else if (value == '\n') {
        return "'\\n'";
    } else if (value == '\t') {
        return "'\\t'";
    } else if ('\0' <= value && value < ' ') {
        return ::Catch::Detail::stringify(static_cast<unsigned int>(value));
    } else {
        char chstr[] = "' '";
        chstr[1] = value;
        return chstr;
    }
}
std::string StringMaker<char>::convert(char c) {
    return ::Catch::Detail::stringify(static_cast<signed char>(c));
}
std::string StringMaker<unsigned char>::convert(unsigned char c) {
    return ::Catch::Detail::stringify(static_cast<char>(c));
}

std::string StringMaker<std::nullptr_t>::convert(std::nullptr_t) {
    return "nullptr";
}

int StringMaker<float>::precision = 5;

std::string StringMaker<float>::convert(float value) {
    return fpToString(value, precision) + 'f';
}

int StringMaker<double>::precision = 10;

std::string StringMaker<double>::convert(double value) {
    return fpToString(value, precision);
}

std::string ratio_string<std::atto>::symbol() { return "a"; }
std::string ratio_string<std::femto>::symbol() { return "f"; }
std::string ratio_string<std::pico>::symbol() { return "p"; }
std::string ratio_string<std::nano>::symbol() { return "n"; }
std::string ratio_string<std::micro>::symbol() { return "u"; }
std::string ratio_string<std::milli>::symbol() { return "m"; }

} // end namespace Catch

#if defined(__clang__)
#    pragma clang diagnostic pop
#endif

// end catch_tostring.cpp
// start catch_totals.cpp

namespace Catch {

    Counts Counts::operator - ( Counts const& other ) const {
        Counts diff;
        diff.passed = passed - other.passed;
        diff.failed = failed - other.failed;
        diff.failedButOk = failedButOk - other.failedButOk;
        return diff;
    }

    Counts& Counts::operator += ( Counts const& other ) {
        passed += other.passed;
        failed += other.failed;
        failedButOk += other.failedButOk;
        return *this;
    }

    std::size_t Counts::total() const {
        return passed + failed + failedButOk;
    }
    bool Counts::allPassed() const {
        return failed == 0 && failedButOk == 0;
    }
    bool Counts::allOk() const {
        return failed == 0;
    }

    Totals Totals::operator - ( Totals const& other ) const {
        Totals diff;
        diff.assertions = assertions - other.assertions;
        diff.testCases = testCases - other.testCases;
        return diff;
    }

    Totals& Totals::operator += ( Totals const& other ) {
        assertions += other.assertions;
        testCases += other.testCases;
        return *this;
    }

    Totals Totals::delta( Totals const& prevTotals ) const {
        Totals diff = *this - prevTotals;
        if( diff.assertions.failed > 0 )
            ++diff.testCases.failed;
        else if( diff.assertions.failedButOk > 0 )
            ++diff.testCases.failedButOk;
        else
            ++diff.testCases.passed;
        return diff;
    }

}
// end catch_totals.cpp
// start catch_uncaught_exceptions.cpp

#include <exception>

namespace Catch {
    bool uncaught_exceptions() {
#if defined(CATCH_CONFIG_DISABLE_EXCEPTIONS)
        return false;
#elif defined(CATCH_CONFIG_CPP17_UNCAUGHT_EXCEPTIONS)
        return std::uncaught_exceptions() > 0;
#else
        return std::uncaught_exception();
#endif
  }
} // end namespace Catch
// end catch_uncaught_exceptions.cpp
// start catch_version.cpp

#include <ostream>

namespace Catch {

    Version::Version
        (   unsigned int _majorVersion,
            unsigned int _minorVersion,
            unsigned int _patchNumber,
            char const * const _branchName,
            unsigned int _buildNumber )
    :   majorVersion( _majorVersion ),
        minorVersion( _minorVersion ),
        patchNumber( _patchNumber ),
        branchName( _branchName ),
        buildNumber( _buildNumber )
    {}

    std::ostream& operator << ( std::ostream& os, Version const& version ) {
        os  << version.majorVersion << '.'
            << version.minorVersion << '.'
            << version.patchNumber;
        // branchName is never null -> 0th char is \0 if it is empty
        if (version.branchName[0]) {
            os << '-' << version.branchName
               << '.' << version.buildNumber;
        }
        return os;
    }

    Version const& libraryVersion() {
        static Version version( 2, 13, 0, "", 0 );
        return version;
    }

}
// end catch_version.cpp
// start catch_wildcard_pattern.cpp

namespace Catch {

    WildcardPattern::WildcardPattern( std::string const& pattern,
                                      CaseSensitive::Choice caseSensitivity )
    :   m_caseSensitivity( caseSensitivity ),
        m_pattern( normaliseString( pattern ) )
    {
        if( startsWith( m_pattern, '*' ) ) {
            m_pattern = m_pattern.substr( 1 );
            m_wildcard = WildcardAtStart;
        }
        if( endsWith( m_pattern, '*' ) ) {
            m_pattern = m_pattern.substr( 0, m_pattern.size()-1 );
            m_wildcard = static_cast<WildcardPosition>( m_wildcard | WildcardAtEnd );
        }
    }

    bool WildcardPattern::matches( std::string const& str ) const {
        switch( m_wildcard ) {
            case NoWildcard:
                return m_pattern == normaliseString( str );
            case WildcardAtStart:
                return endsWith( normaliseString( str ), m_pattern );
            case WildcardAtEnd:
                return startsWith( normaliseString( str ), m_pattern );
            case WildcardAtBothEnds:
                return contains( normaliseString( str ), m_pattern );
            default:
                CATCH_INTERNAL_ERROR( "Unknown enum" );
        }
    }

    std::string WildcardPattern::normaliseString( std::string const& str ) const {
        return trim( m_caseSensitivity == CaseSensitive::No ? toLower( str ) : str );
    }
}
// end catch_wildcard_pattern.cpp
// start catch_xmlwriter.cpp

#include <iomanip>
#include <type_traits>

namespace Catch {

namespace {

    size_t trailingBytes(unsigned char c) {
        if ((c & 0xE0) == 0xC0) {
            return 2;
        }
        if ((c & 0xF0) == 0xE0) {
            return 3;
        }
        if ((c & 0xF8) == 0xF0) {
            return 4;
        }
        CATCH_INTERNAL_ERROR("Invalid multibyte utf-8 start byte encountered");
    }

    uint32_t headerValue(unsigned char c) {
        if ((c & 0xE0) == 0xC0) {
            return c & 0x1F;
        }
        if ((c & 0xF0) == 0xE0) {
            return c & 0x0F;
        }
        if ((c & 0xF8) == 0xF0) {
            return c & 0x07;
        }
        CATCH_INTERNAL_ERROR("Invalid multibyte utf-8 start byte encountered");
    }

    void hexEscapeChar(std::ostream& os, unsigned char c) {
        std::ios_base::fmtflags f(os.flags());
        os << "\\x"
            << std::uppercase << std::hex << std::setfill('0') << std::setw(2)
            << static_cast<int>(c);
        os.flags(f);
    }

    bool shouldNewline(XmlFormatting fmt) {
        return !!(static_cast<std::underlying_type<XmlFormatting>::type>(fmt & XmlFormatting::Newline));
    }

    bool shouldIndent(XmlFormatting fmt) {
        return !!(static_cast<std::underlying_type<XmlFormatting>::type>(fmt & XmlFormatting::Indent));
    }

} // anonymous namespace

    XmlFormatting operator | (XmlFormatting lhs, XmlFormatting rhs) {
        return static_cast<XmlFormatting>(
            static_cast<std::underlying_type<XmlFormatting>::type>(lhs) |
            static_cast<std::underlying_type<XmlFormatting>::type>(rhs)
        );
    }

    XmlFormatting operator & (XmlFormatting lhs, XmlFormatting rhs) {
        return static_cast<XmlFormatting>(
            static_cast<std::underlying_type<XmlFormatting>::type>(lhs) &
            static_cast<std::underlying_type<XmlFormatting>::type>(rhs)
        );
    }

    XmlEncode::XmlEncode( std::string const& str, ForWhat forWhat )
    :   m_str( str ),
        m_forWhat( forWhat )
    {}

    void XmlEncode::encodeTo( std::ostream& os ) const {
        // Apostrophe escaping not necessary if we always use " to write attributes
        // (see: http://www.w3.org/TR/xml/#syntax)

        for( std::size_t idx = 0; idx < m_str.size(); ++ idx ) {
            unsigned char c = m_str[idx];
            switch (c) {
            case '<':   os << "&lt;"; break;
            case '&':   os << "&amp;"; break;

            case '>':
                // See: http://www.w3.org/TR/xml/#syntax
                if (idx > 2 && m_str[idx - 1] == ']' && m_str[idx - 2] == ']')
                    os << "&gt;";
                else
                    os << c;
                break;

            case '\"':
                if (m_forWhat == ForAttributes)
                    os << "&quot;";
                else
                    os << c;
                break;

            default:
                // Check for control characters and invalid utf-8

                // Escape control characters in standard ascii
                // see http://stackoverflow.com/questions/404107/why-are-control-characters-illegal-in-xml-1-0
                if (c < 0x09 || (c > 0x0D && c < 0x20) || c == 0x7F) {
                    hexEscapeChar(os, c);
                    break;
                }

                // Plain ASCII: Write it to stream
                if (c < 0x7F) {
                    os << c;
                    break;
                }

                // UTF-8 territory
                // Check if the encoding is valid and if it is not, hex escape bytes.
                // Important: We do not check the exact decoded values for validity, only the encoding format
                // First check that this bytes is a valid lead byte:
                // This means that it is not encoded as 1111 1XXX
                // Or as 10XX XXXX
                if (c <  0xC0 ||
                    c >= 0xF8) {
                    hexEscapeChar(os, c);
                    break;
                }

                auto encBytes = trailingBytes(c);
                // Are there enough bytes left to avoid accessing out-of-bounds memory?
                if (idx + encBytes - 1 >= m_str.size()) {
                    hexEscapeChar(os, c);
                    break;
                }
                // The header is valid, check data
                // The next encBytes bytes must together be a valid utf-8
                // This means: bitpattern 10XX XXXX and the extracted value is sane (ish)
                bool valid = true;
                uint32_t value = headerValue(c);
                for (std::size_t n = 1; n < encBytes; ++n) {
                    unsigned char nc = m_str[idx + n];
                    valid &= ((nc & 0xC0) == 0x80);
                    value = (value << 6) | (nc & 0x3F);
                }

                if (
                    // Wrong bit pattern of following bytes
                    (!valid) ||
                    // Overlong encodings
                    (value < 0x80) ||
                    (0x80 <= value && value < 0x800   && encBytes > 2) ||
                    (0x800 < value && value < 0x10000 && encBytes > 3) ||
                    // Encoded value out of range
                    (value >= 0x110000)
                    ) {
                    hexEscapeChar(os, c);
                    break;
                }

                // If we got here, this is in fact a valid(ish) utf-8 sequence
                for (std::size_t n = 0; n < encBytes; ++n) {
                    os << m_str[idx + n];
                }
                idx += encBytes - 1;
                break;
            }
        }
    }

    std::ostream& operator << ( std::ostream& os, XmlEncode const& xmlEncode ) {
        xmlEncode.encodeTo( os );
        return os;
    }

    XmlWriter::ScopedElement::ScopedElement( XmlWriter* writer, XmlFormatting fmt )
    :   m_writer( writer ),
        m_fmt(fmt)
    {}

    XmlWriter::ScopedElement::ScopedElement( ScopedElement&& other ) noexcept
    :   m_writer( other.m_writer ),
        m_fmt(other.m_fmt)
    {
        other.m_writer = nullptr;
        other.m_fmt = XmlFormatting::None;
    }
    XmlWriter::ScopedElement& XmlWriter::ScopedElement::operator=( ScopedElement&& other ) noexcept {
        if ( m_writer ) {
            m_writer->endElement();
        }
        m_writer = other.m_writer;
        other.m_writer = nullptr;
        m_fmt = other.m_fmt;
        other.m_fmt = XmlFormatting::None;
        return *this;
    }

    XmlWriter::ScopedElement::~ScopedElement() {
        if (m_writer) {
            m_writer->endElement(m_fmt);
        }
    }

    XmlWriter::ScopedElement& XmlWriter::ScopedElement::writeText( std::string const& text, XmlFormatting fmt ) {
        m_writer->writeText( text, fmt );
        return *this;
    }

    XmlWriter::XmlWriter( std::ostream& os ) : m_os( os )
    {
        writeDeclaration();
    }

    XmlWriter::~XmlWriter() {
        while (!m_tags.empty()) {
            endElement();
        }
        newlineIfNecessary();
    }

    XmlWriter& XmlWriter::startElement( std::string const& name, XmlFormatting fmt ) {
        ensureTagClosed();
        newlineIfNecessary();
        if (shouldIndent(fmt)) {
            m_os << m_indent;
            m_indent += "  ";
        }
        m_os << '<' << name;
        m_tags.push_back( name );
        m_tagIsOpen = true;
        applyFormatting(fmt);
        return *this;
    }

    XmlWriter::ScopedElement XmlWriter::scopedElement( std::string const& name, XmlFormatting fmt ) {
        ScopedElement scoped( this, fmt );
        startElement( name, fmt );
        return scoped;
    }

    XmlWriter& XmlWriter::endElement(XmlFormatting fmt) {
        m_indent = m_indent.substr(0, m_indent.size() - 2);

        if( m_tagIsOpen ) {
            m_os << "/>";
            m_tagIsOpen = false;
        } else {
            newlineIfNecessary();
            if (shouldIndent(fmt)) {
                m_os << m_indent;
            }
            m_os << "</" << m_tags.back() << ">";
        }
        m_os << std::flush;
        applyFormatting(fmt);
        m_tags.pop_back();
        return *this;
    }

    XmlWriter& XmlWriter::writeAttribute( std::string const& name, std::string const& attribute ) {
        if( !name.empty() && !attribute.empty() )
            m_os << ' ' << name << "=\"" << XmlEncode( attribute, XmlEncode::ForAttributes ) << '"';
        return *this;
    }

    XmlWriter& XmlWriter::writeAttribute( std::string const& name, bool attribute ) {
        m_os << ' ' << name << "=\"" << ( attribute ? "true" : "false" ) << '"';
        return *this;
    }

    XmlWriter& XmlWriter::writeText( std::string const& text, XmlFormatting fmt) {
        if( !text.empty() ){
            bool tagWasOpen = m_tagIsOpen;
            ensureTagClosed();
            if (tagWasOpen && shouldIndent(fmt)) {
                m_os << m_indent;
            }
            m_os << XmlEncode( text );
            applyFormatting(fmt);
        }
        return *this;
    }

    XmlWriter& XmlWriter::writeComment( std::string const& text, XmlFormatting fmt) {
        ensureTagClosed();
        if (shouldIndent(fmt)) {
            m_os << m_indent;
        }
        m_os << "<!--" << text << "-->";
        applyFormatting(fmt);
        return *this;
    }

    void XmlWriter::writeStylesheetRef( std::string const& url ) {
        m_os << "<?xml-stylesheet type=\"text/xsl\" href=\"" << url << "\"?>\n";
    }

    XmlWriter& XmlWriter::writeBlankLine() {
        ensureTagClosed();
        m_os << '\n';
        return *this;
    }

    void XmlWriter::ensureTagClosed() {
        if( m_tagIsOpen ) {
            m_os << '>' << std::flush;
            newlineIfNecessary();
            m_tagIsOpen = false;
        }
    }

    void XmlWriter::applyFormatting(XmlFormatting fmt) {
        m_needsNewline = shouldNewline(fmt);
    }

    void XmlWriter::writeDeclaration() {
        m_os << "<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n";
    }

    void XmlWriter::newlineIfNecessary() {
        if( m_needsNewline ) {
            m_os << std::endl;
            m_needsNewline = false;
        }
    }
}
// end catch_xmlwriter.cpp
// start catch_reporter_bases.cpp

#include <cstring>
#include <cfloat>
#include <cstdio>
#include <cassert>
#include <memory>

namespace Catch {
    void prepareExpandedExpression(AssertionResult& result) {
        result.getExpandedExpression();
    }

    // Because formatting using c++ streams is stateful, drop down to C is required
    // Alternatively we could use stringstream, but its performance is... not good.
    std::string getFormattedDuration( double duration ) {
        // Max exponent + 1 is required to represent the whole part
        // + 1 for decimal point
        // + 3 for the 3 decimal places
        // + 1 for null terminator
        const std::size_t maxDoubleSize = DBL_MAX_10_EXP + 1 + 1 + 3 + 1;
        char buffer[maxDoubleSize];

        // Save previous errno, to prevent sprintf from overwriting it
        ErrnoGuard guard;
#ifdef _MSC_VER
        sprintf_s(buffer, "%.3f", duration);
#else
        std::sprintf(buffer, "%.3f", duration);
#endif
        return std::string(buffer);
    }

    bool shouldShowDuration( IConfig const& config, double duration ) {
        if ( config.showDurations() == ShowDurations::Always ) {
            return true;
        }
        if ( config.showDurations() == ShowDurations::Never ) {
            return false;
        }
        const double min = config.minDuration();
        return min >= 0 && duration >= min;
    }

    std::string serializeFilters( std::vector<std::string> const& container ) {
        ReusableStringStream oss;
        bool first = true;
        for (auto&& filter : container)
        {
            if (!first)
                oss << ' ';
            else
                first = false;

            oss << filter;
        }
        return oss.str();
    }

    TestEventListenerBase::TestEventListenerBase(ReporterConfig const & _config)
        :StreamingReporterBase(_config) {}

    std::set<Verbosity> TestEventListenerBase::getSupportedVerbosities() {
        return { Verbosity::Quiet, Verbosity::Normal, Verbosity::High };
    }

    void TestEventListenerBase::assertionStarting(AssertionInfo const &) {}

    bool TestEventListenerBase::assertionEnded(AssertionStats const &) {
        return false;
    }

} // end namespace Catch
// end catch_reporter_bases.cpp
// start catch_reporter_compact.cpp

namespace {

#ifdef CATCH_PLATFORM_MAC
    const char* failedString() { return "FAILED"; }
    const char* passedString() { return "PASSED"; }
#else
    const char* failedString() { return "failed"; }
    const char* passedString() { return "passed"; }
#endif

    // Colour::LightGrey
    Catch::Colour::Code dimColour() { return Catch::Colour::FileName; }

    std::string bothOrAll( std::size_t count ) {
        return count == 1 ? std::string() :
               count == 2 ? "both " : "all " ;
    }

} // anon namespace

namespace Catch {
namespace {
// Colour, message variants:
// - white: No tests ran.
// -   red: Failed [both/all] N test cases, failed [both/all] M assertions.
// - white: Passed [both/all] N test cases (no assertions).
// -   red: Failed N tests cases, failed M assertions.
// - green: Passed [both/all] N tests cases with M assertions.
void printTotals(std::ostream& out, const Totals& totals) {
    if (totals.testCases.total() == 0) {
        out << "No tests ran.";
    } else if (totals.testCases.failed == totals.testCases.total()) {
        Colour colour(Colour::ResultError);
        const std::string qualify_assertions_failed =
            totals.assertions.failed == totals.assertions.total() ?
            bothOrAll(totals.assertions.failed) : std::string();
        out <<
            "Failed " << bothOrAll(totals.testCases.failed)
            << pluralise(totals.testCases.failed, "test case") << ", "
            "failed " << qualify_assertions_failed <<
            pluralise(totals.assertions.failed, "assertion") << '.';
    } else if (totals.assertions.total() == 0) {
        out <<
            "Passed " << bothOrAll(totals.testCases.total())
            << pluralise(totals.testCases.total(), "test case")
            << " (no assertions).";
    } else if (totals.assertions.failed) {
        Colour colour(Colour::ResultError);
        out <<
            "Failed " << pluralise(totals.testCases.failed, "test case") << ", "
            "failed " << pluralise(totals.assertions.failed, "assertion") << '.';
    } else {
        Colour colour(Colour::ResultSuccess);
        out <<
            "Passed " << bothOrAll(totals.testCases.passed)
            << pluralise(totals.testCases.passed, "test case") <<
            " with " << pluralise(totals.assertions.passed, "assertion") << '.';
    }
}

// Implementation of CompactReporter formatting
class AssertionPrinter {
public:
    AssertionPrinter& operator= (AssertionPrinter const&) = delete;
    AssertionPrinter(AssertionPrinter const&) = delete;
    AssertionPrinter(std::ostream& _stream, AssertionStats const& _stats, bool _printInfoMessages)
        : stream(_stream)
        , result(_stats.assertionResult)
        , messages(_stats.infoMessages)
        , itMessage(_stats.infoMessages.begin())
        , printInfoMessages(_printInfoMessages) {}

    void print() {
        printSourceInfo();

        itMessage = messages.begin();

        switch (result.getResultType()) {
        case ResultWas::Ok:
            printResultType(Colour::ResultSuccess, passedString());
            printOriginalExpression();
            printReconstructedExpression();
            if (!result.hasExpression())
                printRemainingMessages(Colour::None);
            else
                printRemainingMessages();
            break;
        case ResultWas::ExpressionFailed:
            if (result.isOk())
                printResultType(Colour::ResultSuccess, failedString() + std::string(" - but was ok"));
            else
                printResultType(Colour::Error, failedString());
            printOriginalExpression();
            printReconstructedExpression();
            printRemainingMessages();
            break;
        case ResultWas::ThrewException:
            printResultType(Colour::Error, failedString());
            printIssue("unexpected exception with message:");
            printMessage();
            printExpressionWas();
            printRemainingMessages();
            break;
        case ResultWas::FatalErrorCondition:
            printResultType(Colour::Error, failedString());
            printIssue("fatal error condition with message:");
            printMessage();
            printExpressionWas();
            printRemainingMessages();
            break;
        case ResultWas::DidntThrowException:
            printResultType(Colour::Error, failedString());
            printIssue("expected exception, got none");
            printExpressionWas();
            printRemainingMessages();
            break;
        case ResultWas::Info:
            printResultType(Colour::None, "info");
            printMessage();
            printRemainingMessages();
            break;
        case ResultWas::Warning:
            printResultType(Colour::None, "warning");
            printMessage();
            printRemainingMessages();
            break;
        case ResultWas::ExplicitFailure:
            printResultType(Colour::Error, failedString());
            printIssue("explicitly");
            printRemainingMessages(Colour::None);
            break;
            // These cases are here to prevent compiler warnings
        case ResultWas::Unknown:
        case ResultWas::FailureBit:
        case ResultWas::Exception:
            printResultType(Colour::Error, "** internal error **");
            break;
        }
    }

private:
    void printSourceInfo() const {
        Colour colourGuard(Colour::FileName);
        stream << result.getSourceInfo() << ':';
    }

    void printResultType(Colour::Code colour, std::string const& passOrFail) const {
        if (!passOrFail.empty()) {
            {
                Colour colourGuard(colour);
                stream << ' ' << passOrFail;
            }
            stream << ':';
        }
    }

    void printIssue(std::string const& issue) const {
        stream << ' ' << issue;
    }

    void printExpressionWas() {
        if (result.hasExpression()) {
            stream << ';';
            {
                Colour colour(dimColour());
                stream << " expression was:";
            }
            printOriginalExpression();
        }
    }

    void printOriginalExpression() const {
        if (result.hasExpression()) {
            stream << ' ' << result.getExpression();
        }
    }

    void printReconstructedExpression() const {
        if (result.hasExpandedExpression()) {
            {
                Colour colour(dimColour());
                stream << " for: ";
            }
            stream << result.getExpandedExpression();
        }
    }

    void printMessage() {
        if (itMessage != messages.end()) {
            stream << " '" << itMessage->message << '\'';
            ++itMessage;
        }
    }

    void printRemainingMessages(Colour::Code colour = dimColour()) {
        if (itMessage == messages.end())
            return;

        const auto itEnd = messages.cend();
        const auto N = static_cast<std::size_t>(std::distance(itMessage, itEnd));

        {
            Colour colourGuard(colour);
            stream << " with " << pluralise(N, "message") << ':';
        }

        while (itMessage != itEnd) {
            // If this assertion is a warning ignore any INFO messages
            if (printInfoMessages || itMessage->type != ResultWas::Info) {
                printMessage();
                if (itMessage != itEnd) {
                    Colour colourGuard(dimColour());
                    stream << " and";
                }
                continue;
            }
            ++itMessage;
        }
    }

private:
    std::ostream& stream;
    AssertionResult const& result;
    std::vector<MessageInfo> messages;
    std::vector<MessageInfo>::const_iterator itMessage;
    bool printInfoMessages;
};

} // anon namespace

        std::string CompactReporter::getDescription() {
            return "Reports test results on a single line, suitable for IDEs";
        }

        void CompactReporter::noMatchingTestCases( std::string const& spec ) {
            stream << "No test cases matched '" << spec << '\'' << std::endl;
        }

        void CompactReporter::assertionStarting( AssertionInfo const& ) {}

        bool CompactReporter::assertionEnded( AssertionStats const& _assertionStats ) {
            AssertionResult const& result = _assertionStats.assertionResult;

            bool printInfoMessages = true;

            // Drop out if result was successful and we're not printing those
            if( !m_config->includeSuccessfulResults() && result.isOk() ) {
                if( result.getResultType() != ResultWas::Warning )
                    return false;
                printInfoMessages = false;
            }

            AssertionPrinter printer( stream, _assertionStats, printInfoMessages );
            printer.print();

            stream << std::endl;
            return true;
        }

        void CompactReporter::sectionEnded(SectionStats const& _sectionStats) {
            double dur = _sectionStats.durationInSeconds;
            if ( shouldShowDuration( *m_config, dur ) ) {
                stream << getFormattedDuration( dur ) << " s: " << _sectionStats.sectionInfo.name << std::endl;
            }
        }

        void CompactReporter::testRunEnded( TestRunStats const& _testRunStats ) {
            printTotals( stream, _testRunStats.totals );
            stream << '\n' << std::endl;
            StreamingReporterBase::testRunEnded( _testRunStats );
        }

        CompactReporter::~CompactReporter() {}

    CATCH_REGISTER_REPORTER( "compact", CompactReporter )

} // end namespace Catch
// end catch_reporter_compact.cpp
// start catch_reporter_console.cpp

#include <cfloat>
#include <cstdio>

#if defined(_MSC_VER)
#pragma warning(push)
#pragma warning(disable:4061) // Not all labels are EXPLICITLY handled in switch
 // Note that 4062 (not all labels are handled and default is missing) is enabled
#endif

#if defined(__clang__)
#  pragma clang diagnostic push
// For simplicity, benchmarking-only helpers are always enabled
#  pragma clang diagnostic ignored "-Wunused-function"
#endif

namespace Catch {

namespace {

// Formatter impl for ConsoleReporter
class ConsoleAssertionPrinter {
public:
    ConsoleAssertionPrinter& operator= (ConsoleAssertionPrinter const&) = delete;
    ConsoleAssertionPrinter(ConsoleAssertionPrinter const&) = delete;
    ConsoleAssertionPrinter(std::ostream& _stream, AssertionStats const& _stats, bool _printInfoMessages)
        : stream(_stream),
        stats(_stats),
        result(_stats.assertionResult),
        colour(Colour::None),
        message(result.getMessage()),
        messages(_stats.infoMessages),
        printInfoMessages(_printInfoMessages) {
        switch (result.getResultType()) {
        case ResultWas::Ok:
            colour = Colour::Success;
            passOrFail = "PASSED";
            //if( result.hasMessage() )
            if (_stats.infoMessages.size() == 1)
                messageLabel = "with message";
            if (_stats.infoMessages.size() > 1)
                messageLabel = "with messages";
            break;
        case ResultWas::ExpressionFailed:
            if (result.isOk()) {
                colour = Colour::Success;
                passOrFail = "FAILED - but was ok";
            } else {
                colour = Colour::Error;
                passOrFail = "FAILED";
            }
            if (_stats.infoMessages.size() == 1)
                messageLabel = "with message";
            if (_stats.infoMessages.size() > 1)
                messageLabel = "with messages";
            break;
        case ResultWas::ThrewException:
            colour = Colour::Error;
            passOrFail = "FAILED";
            messageLabel = "due to unexpected exception with ";
            if (_stats.infoMessages.size() == 1)
                messageLabel += "message";
            if (_stats.infoMessages.size() > 1)
                messageLabel += "messages";
            break;
        case ResultWas::FatalErrorCondition:
            colour = Colour::Error;
            passOrFail = "FAILED";
            messageLabel = "due to a fatal error condition";
            break;
        case ResultWas::DidntThrowException:
            colour = Colour::Error;
            passOrFail = "FAILED";
            messageLabel = "because no exception was thrown where one was expected";
            break;
        case ResultWas::Info:
            messageLabel = "info";
            break;
        case ResultWas::Warning:
            messageLabel = "warning";
            break;
        case ResultWas::ExplicitFailure:
            passOrFail = "FAILED";
            colour = Colour::Error;
            if (_stats.infoMessages.size() == 1)
                messageLabel = "explicitly with message";
            if (_stats.infoMessages.size() > 1)
                messageLabel = "explicitly with messages";
            break;
            // These cases are here to prevent compiler warnings
        case ResultWas::Unknown:
        case ResultWas::FailureBit:
        case ResultWas::Exception:
            passOrFail = "** internal error **";
            colour = Colour::Error;
            break;
        }
    }

    void print() const {
        printSourceInfo();
        if (stats.totals.assertions.total() > 0) {
            printResultType();
            printOriginalExpression();
            printReconstructedExpression();
        } else {
            stream << '\n';
        }
        printMessage();
    }

private:
    void printResultType() const {
        if (!passOrFail.empty()) {
            Colour colourGuard(colour);
            stream << passOrFail << ":\n";
        }
    }
    void printOriginalExpression() const {
        if (result.hasExpression()) {
            Colour colourGuard(Colour::OriginalExpression);
            stream << "  ";
            stream << result.getExpressionInMacro();
            stream << '\n';
        }
    }
    void printReconstructedExpression() const {
        if (result.hasExpandedExpression()) {
            stream << "with expansion:\n";
            Colour colourGuard(Colour::ReconstructedExpression);
            stream << Column(result.getExpandedExpression()).indent(2) << '\n';
        }
    }
    void printMessage() const {
        if (!messageLabel.empty())
            stream << messageLabel << ':' << '\n';
        for (auto const& msg : messages) {
            // If this assertion is a warning ignore any INFO messages
            if (printInfoMessages || msg.type != ResultWas::Info)
                stream << Column(msg.message).indent(2) << '\n';
        }
    }
    void printSourceInfo() const {
        Colour colourGuard(Colour::FileName);
        stream << result.getSourceInfo() << ": ";
    }

    std::ostream& stream;
    AssertionStats const& stats;
    AssertionResult const& result;
    Colour::Code colour;
    std::string passOrFail;
    std::string messageLabel;
    std::string message;
    std::vector<MessageInfo> messages;
    bool printInfoMessages;
};

std::size_t makeRatio(std::size_t number, std::size_t total) {
    std::size_t ratio = total > 0 ? CATCH_CONFIG_CONSOLE_WIDTH * number / total : 0;
    return (ratio == 0 && number > 0) ? 1 : ratio;
}

std::size_t& findMax(std::size_t& i, std::size_t& j, std::size_t& k) {
    if (i > j && i > k)
        return i;
    else if (j > k)
        return j;
    else
        return k;
}

struct ColumnInfo {
    enum Justification { Left, Right };
    std::string name;
    int width;
    Justification justification;
};
struct ColumnBreak {};
struct RowBreak {};

class Duration {
    enum class Unit {
        Auto,
        Nanoseconds,
        Microseconds,
        Milliseconds,
        Seconds,
        Minutes
    };
    static const uint64_t s_nanosecondsInAMicrosecond = 1000;
    static const uint64_t s_nanosecondsInAMillisecond = 1000 * s_nanosecondsInAMicrosecond;
    static const uint64_t s_nanosecondsInASecond = 1000 * s_nanosecondsInAMillisecond;
    static const uint64_t s_nanosecondsInAMinute = 60 * s_nanosecondsInASecond;

    double m_inNanoseconds;
    Unit m_units;

public:
    explicit Duration(double inNanoseconds, Unit units = Unit::Auto)
        : m_inNanoseconds(inNanoseconds),
        m_units(units) {
        if (m_units == Unit::Auto) {
            if (m_inNanoseconds < s_nanosecondsInAMicrosecond)
                m_units = Unit::Nanoseconds;
            else if (m_inNanoseconds < s_nanosecondsInAMillisecond)
                m_units = Unit::Microseconds;
            else if (m_inNanoseconds < s_nanosecondsInASecond)
                m_units = Unit::Milliseconds;
            else if (m_inNanoseconds < s_nanosecondsInAMinute)
                m_units = Unit::Seconds;
            else
                m_units = Unit::Minutes;
        }

    }

    auto value() const -> double {
        switch (m_units) {
        case Unit::Microseconds:
            return m_inNanoseconds / static_cast<double>(s_nanosecondsInAMicrosecond);
        case Unit::Milliseconds:
            return m_inNanoseconds / static_cast<double>(s_nanosecondsInAMillisecond);
        case Unit::Seconds:
            return m_inNanoseconds / static_cast<double>(s_nanosecondsInASecond);
        case Unit::Minutes:
            return m_inNanoseconds / static_cast<double>(s_nanosecondsInAMinute);
        default:
            return m_inNanoseconds;
        }
    }
    auto unitsAsString() const -> std::string {
        switch (m_units) {
        case Unit::Nanoseconds:
            return "ns";
        case Unit::Microseconds:
            return "us";
        case Unit::Milliseconds:
            return "ms";
        case Unit::Seconds:
            return "s";
        case Unit::Minutes:
            return "m";
        default:
            return "** internal error **";
        }

    }
    friend auto operator << (std::ostream& os, Duration const& duration) -> std::ostream& {
        return os << duration.value() << ' ' << duration.unitsAsString();
    }
};
} // end anon namespace

class TablePrinter {
    std::ostream& m_os;
    std::vector<ColumnInfo> m_columnInfos;
    std::ostringstream m_oss;
    int m_currentColumn = -1;
    bool m_isOpen = false;

public:
    TablePrinter( std::ostream& os, std::vector<ColumnInfo> columnInfos )
    :   m_os( os ),
        m_columnInfos( std::move( columnInfos ) ) {}

    auto columnInfos() const -> std::vector<ColumnInfo> const& {
        return m_columnInfos;
    }

    void open() {
        if (!m_isOpen) {
            m_isOpen = true;
            *this << RowBreak();

			Columns headerCols;
			Spacer spacer(2);
			for (auto const& info : m_columnInfos) {
				headerCols += Column(info.name).width(static_cast<std::size_t>(info.width - 2));
				headerCols += spacer;
			}
			m_os << headerCols << '\n';

            m_os << Catch::getLineOfChars<'-'>() << '\n';
        }
    }
    void close() {
        if (m_isOpen) {
            *this << RowBreak();
            m_os << std::endl;
            m_isOpen = false;
        }
    }

    template<typename T>
    friend TablePrinter& operator << (TablePrinter& tp, T const& value) {
        tp.m_oss << value;
        return tp;
    }

    friend TablePrinter& operator << (TablePrinter& tp, ColumnBreak) {
        auto colStr = tp.m_oss.str();
        const auto strSize = colStr.size();
        tp.m_oss.str("");
        tp.open();
        if (tp.m_currentColumn == static_cast<int>(tp.m_columnInfos.size() - 1)) {
            tp.m_currentColumn = -1;
            tp.m_os << '\n';
        }
        tp.m_currentColumn++;

        auto colInfo = tp.m_columnInfos[tp.m_currentColumn];
        auto padding = (strSize + 1 < static_cast<std::size_t>(colInfo.width))
            ? std::string(colInfo.width - (strSize + 1), ' ')
            : std::string();
        if (colInfo.justification == ColumnInfo::Left)
            tp.m_os << colStr << padding << ' ';
        else
            tp.m_os << padding << colStr << ' ';
        return tp;
    }

    friend TablePrinter& operator << (TablePrinter& tp, RowBreak) {
        if (tp.m_currentColumn > 0) {
            tp.m_os << '\n';
            tp.m_currentColumn = -1;
        }
        return tp;
    }
};

ConsoleReporter::ConsoleReporter(ReporterConfig const& config)
    : StreamingReporterBase(config),
    m_tablePrinter(new TablePrinter(config.stream(),
        [&config]() -> std::vector<ColumnInfo> {
        if (config.fullConfig()->benchmarkNoAnalysis())
        {
            return{
                { "benchmark name", CATCH_CONFIG_CONSOLE_WIDTH - 43, ColumnInfo::Left },
                { "     samples", 14, ColumnInfo::Right },
                { "  iterations", 14, ColumnInfo::Right },
                { "        mean", 14, ColumnInfo::Right }
            };
        }
        else
        {
            return{
                { "benchmark name", CATCH_CONFIG_CONSOLE_WIDTH - 43, ColumnInfo::Left },
                { "samples      mean       std dev", 14, ColumnInfo::Right },
                { "iterations   low mean   low std dev", 14, ColumnInfo::Right },
                { "estimated    high mean  high std dev", 14, ColumnInfo::Right }
            };
        }
    }())) {}
ConsoleReporter::~ConsoleReporter() = default;

std::string ConsoleReporter::getDescription() {
    return "Reports test results as plain lines of text";
}

void ConsoleReporter::noMatchingTestCases(std::string const& spec) {
    stream << "No test cases matched '" << spec << '\'' << std::endl;
}

void ConsoleReporter::reportInvalidArguments(std::string const&arg){
    stream << "Invalid Filter: " << arg << std::endl;
}

void ConsoleReporter::assertionStarting(AssertionInfo const&) {}

bool ConsoleReporter::assertionEnded(AssertionStats const& _assertionStats) {
    AssertionResult const& result = _assertionStats.assertionResult;

    bool includeResults = m_config->includeSuccessfulResults() || !result.isOk();

    // Drop out if result was successful but we're not printing them.
    if (!includeResults && result.getResultType() != ResultWas::Warning)
        return false;

    lazyPrint();

    ConsoleAssertionPrinter printer(stream, _assertionStats, includeResults);
    printer.print();
    stream << std::endl;
    return true;
}

void ConsoleReporter::sectionStarting(SectionInfo const& _sectionInfo) {
    m_tablePrinter->close();
    m_headerPrinted = false;
    StreamingReporterBase::sectionStarting(_sectionInfo);
}
void ConsoleReporter::sectionEnded(SectionStats const& _sectionStats) {
    m_tablePrinter->close();
    if (_sectionStats.missingAssertions) {
        lazyPrint();
        Colour colour(Colour::ResultError);
        if (m_sectionStack.size() > 1)
            stream << "\nNo assertions in section";
        else
            stream << "\nNo assertions in test case";
        stream << " '" << _sectionStats.sectionInfo.name << "'\n" << std::endl;
    }
    double dur = _sectionStats.durationInSeconds;
    if (shouldShowDuration(*m_config, dur)) {
        stream << getFormattedDuration(dur) << " s: " << _sectionStats.sectionInfo.name << std::endl;
    }
    if (m_headerPrinted) {
        m_headerPrinted = false;
    }
    StreamingReporterBase::sectionEnded(_sectionStats);
}

#if defined(CATCH_CONFIG_ENABLE_BENCHMARKING)
void ConsoleReporter::benchmarkPreparing(std::string const& name) {
	lazyPrintWithoutClosingBenchmarkTable();

	auto nameCol = Column(name).width(static_cast<std::size_t>(m_tablePrinter->columnInfos()[0].width - 2));

	bool firstLine = true;
	for (auto line : nameCol) {
		if (!firstLine)
			(*m_tablePrinter) << ColumnBreak() << ColumnBreak() << ColumnBreak();
		else
			firstLine = false;

		(*m_tablePrinter) << line << ColumnBreak();
	}
}

void ConsoleReporter::benchmarkStarting(BenchmarkInfo const& info) {
    (*m_tablePrinter) << info.samples << ColumnBreak()
        << info.iterations << ColumnBreak();
    if (!m_config->benchmarkNoAnalysis())
        (*m_tablePrinter) << Duration(info.estimatedDuration) << ColumnBreak();
}
void ConsoleReporter::benchmarkEnded(BenchmarkStats<> const& stats) {
    if (m_config->benchmarkNoAnalysis())
    {
        (*m_tablePrinter) << Duration(stats.mean.point.count()) << ColumnBreak();
    }
    else
    {
        (*m_tablePrinter) << ColumnBreak()
            << Duration(stats.mean.point.count()) << ColumnBreak()
            << Duration(stats.mean.lower_bound.count()) << ColumnBreak()
            << Duration(stats.mean.upper_bound.count()) << ColumnBreak() << ColumnBreak()
            << Duration(stats.standardDeviation.point.count()) << ColumnBreak()
            << Duration(stats.standardDeviation.lower_bound.count()) << ColumnBreak()
            << Duration(stats.standardDeviation.upper_bound.count()) << ColumnBreak() << ColumnBreak() << ColumnBreak() << ColumnBreak() << ColumnBreak();
    }
}

void ConsoleReporter::benchmarkFailed(std::string const& error) {
	Colour colour(Colour::Red);
    (*m_tablePrinter)
        << "Benchmark failed (" << error << ')'
        << ColumnBreak() << RowBreak();
}
#endif // CATCH_CONFIG_ENABLE_BENCHMARKING

void ConsoleReporter::testCaseEnded(TestCaseStats const& _testCaseStats) {
    m_tablePrinter->close();
    StreamingReporterBase::testCaseEnded(_testCaseStats);
    m_headerPrinted = false;
}
void ConsoleReporter::testGroupEnded(TestGroupStats const& _testGroupStats) {
    if (currentGroupInfo.used) {
        printSummaryDivider();
        stream << "Summary for group '" << _testGroupStats.groupInfo.name << "':\n";
        printTotals(_testGroupStats.totals);
        stream << '\n' << std::endl;
    }
    StreamingReporterBase::testGroupEnded(_testGroupStats);
}
void ConsoleReporter::testRunEnded(TestRunStats const& _testRunStats) {
    printTotalsDivider(_testRunStats.totals);
    printTotals(_testRunStats.totals);
    stream << std::endl;
    StreamingReporterBase::testRunEnded(_testRunStats);
}
void ConsoleReporter::testRunStarting(TestRunInfo const& _testInfo) {
    StreamingReporterBase::testRunStarting(_testInfo);
    printTestFilters();
}

void ConsoleReporter::lazyPrint() {

    m_tablePrinter->close();
    lazyPrintWithoutClosingBenchmarkTable();
}

void ConsoleReporter::lazyPrintWithoutClosingBenchmarkTable() {

    if (!currentTestRunInfo.used)
        lazyPrintRunInfo();
    if (!currentGroupInfo.used)
        lazyPrintGroupInfo();

    if (!m_headerPrinted) {
        printTestCaseAndSectionHeader();
        m_headerPrinted = true;
    }
}
void ConsoleReporter::lazyPrintRunInfo() {
    stream << '\n' << getLineOfChars<'~'>() << '\n';
    Colour colour(Colour::SecondaryText);
    stream << currentTestRunInfo->name
        << " is a Catch v" << libraryVersion() << " host application.\n"
        << "Run with -? for options\n\n";

    if (m_config->rngSeed() != 0)
        stream << "Randomness seeded to: " << m_config->rngSeed() << "\n\n";

    currentTestRunInfo.used = true;
}
void ConsoleReporter::lazyPrintGroupInfo() {
    if (!currentGroupInfo->name.empty() && currentGroupInfo->groupsCounts > 1) {
        printClosedHeader("Group: " + currentGroupInfo->name);
        currentGroupInfo.used = true;
    }
}
void ConsoleReporter::printTestCaseAndSectionHeader() {
    assert(!m_sectionStack.empty());
    printOpenHeader(currentTestCaseInfo->name);

    if (m_sectionStack.size() > 1) {
        Colour colourGuard(Colour::Headers);

        auto
            it = m_sectionStack.begin() + 1, // Skip first section (test case)
            itEnd = m_sectionStack.end();
        for (; it != itEnd; ++it)
            printHeaderString(it->name, 2);
    }

    SourceLineInfo lineInfo = m_sectionStack.back().lineInfo;

    stream << getLineOfChars<'-'>() << '\n';
    Colour colourGuard(Colour::FileName);
    stream << lineInfo << '\n';
    stream << getLineOfChars<'.'>() << '\n' << std::endl;
}

void ConsoleReporter::printClosedHeader(std::string const& _name) {
    printOpenHeader(_name);
    stream << getLineOfChars<'.'>() << '\n';
}
void ConsoleReporter::printOpenHeader(std::string const& _name) {
    stream << getLineOfChars<'-'>() << '\n';
    {
        Colour colourGuard(Colour::Headers);
        printHeaderString(_name);
    }
}

// if string has a : in first line will set indent to follow it on
// subsequent lines
void ConsoleReporter::printHeaderString(std::string const& _string, std::size_t indent) {
    std::size_t i = _string.find(": ");
    if (i != std::string::npos)
        i += 2;
    else
        i = 0;
    stream << Column(_string).indent(indent + i).initialIndent(indent) << '\n';
}

struct SummaryColumn {

    SummaryColumn( std::string _label, Colour::Code _colour )
    :   label( std::move( _label ) ),
        colour( _colour ) {}
    SummaryColumn addRow( std::size_t count ) {
        ReusableStringStream rss;
        rss << count;
        std::string row = rss.str();
        for (auto& oldRow : rows) {
            while (oldRow.size() < row.size())
                oldRow = ' ' + oldRow;
            while (oldRow.size() > row.size())
                row = ' ' + row;
        }
        rows.push_back(row);
        return *this;
    }

    std::string label;
    Colour::Code colour;
    std::vector<std::string> rows;

};

void ConsoleReporter::printTotals( Totals const& totals ) {
    if (totals.testCases.total() == 0) {
        stream << Colour(Colour::Warning) << "No tests ran\n";
    } else if (totals.assertions.total() > 0 && totals.testCases.allPassed()) {
        stream << Colour(Colour::ResultSuccess) << "All tests passed";
        stream << " ("
            << pluralise(totals.assertions.passed, "assertion") << " in "
            << pluralise(totals.testCases.passed, "test case") << ')'
            << '\n';
    } else {

        std::vector<SummaryColumn> columns;
        columns.push_back(SummaryColumn("", Colour::None)
                          .addRow(totals.testCases.total())
                          .addRow(totals.assertions.total()));
        columns.push_back(SummaryColumn("passed", Colour::Success)
                          .addRow(totals.testCases.passed)
                          .addRow(totals.assertions.passed));
        columns.push_back(SummaryColumn("failed", Colour::ResultError)
                          .addRow(totals.testCases.failed)
                          .addRow(totals.assertions.failed));
        columns.push_back(SummaryColumn("failed as expected", Colour::ResultExpectedFailure)
                          .addRow(totals.testCases.failedButOk)
                          .addRow(totals.assertions.failedButOk));

        printSummaryRow("test cases", columns, 0);
        printSummaryRow("assertions", columns, 1);
    }
}
void ConsoleReporter::printSummaryRow(std::string const& label, std::vector<SummaryColumn> const& cols, std::size_t row) {
    for (auto col : cols) {
        std::string value = col.rows[row];
        if (col.label.empty()) {
            stream << label << ": ";
            if (value != "0")
                stream << value;
            else
                stream << Colour(Colour::Warning) << "- none -";
        } else if (value != "0") {
            stream << Colour(Colour::LightGrey) << " | ";
            stream << Colour(col.colour)
                << value << ' ' << col.label;
        }
    }
    stream << '\n';
}

void ConsoleReporter::printTotalsDivider(Totals const& totals) {
    if (totals.testCases.total() > 0) {
        std::size_t failedRatio = makeRatio(totals.testCases.failed, totals.testCases.total());
        std::size_t failedButOkRatio = makeRatio(totals.testCases.failedButOk, totals.testCases.total());
        std::size_t passedRatio = makeRatio(totals.testCases.passed, totals.testCases.total());
        while (failedRatio + failedButOkRatio + passedRatio < CATCH_CONFIG_CONSOLE_WIDTH - 1)
            findMax(failedRatio, failedButOkRatio, passedRatio)++;
        while (failedRatio + failedButOkRatio + passedRatio > CATCH_CONFIG_CONSOLE_WIDTH - 1)
            findMax(failedRatio, failedButOkRatio, passedRatio)--;

        stream << Colour(Colour::Error) << std::string(failedRatio, '=');
        stream << Colour(Colour::ResultExpectedFailure) << std::string(failedButOkRatio, '=');
        if (totals.testCases.allPassed())
            stream << Colour(Colour::ResultSuccess) << std::string(passedRatio, '=');
        else
            stream << Colour(Colour::Success) << std::string(passedRatio, '=');
    } else {
        stream << Colour(Colour::Warning) << std::string(CATCH_CONFIG_CONSOLE_WIDTH - 1, '=');
    }
    stream << '\n';
}
void ConsoleReporter::printSummaryDivider() {
    stream << getLineOfChars<'-'>() << '\n';
}

void ConsoleReporter::printTestFilters() {
    if (m_config->testSpec().hasFilters()) {
        Colour guard(Colour::BrightYellow);
        stream << "Filters: " << serializeFilters(m_config->getTestsOrTags()) << '\n';
    }
}

CATCH_REGISTER_REPORTER("console", ConsoleReporter)

} // end namespace Catch

#if defined(_MSC_VER)
#pragma warning(pop)
#endif

#if defined(__clang__)
#  pragma clang diagnostic pop
#endif
// end catch_reporter_console.cpp
// start catch_reporter_junit.cpp

#include <cassert>
#include <sstream>
#include <ctime>
#include <algorithm>

namespace Catch {

    namespace {
        std::string getCurrentTimestamp() {
            // Beware, this is not reentrant because of backward compatibility issues
            // Also, UTC only, again because of backward compatibility (%z is C++11)
            time_t rawtime;
            std::time(&rawtime);
            auto const timeStampSize = sizeof("2017-01-16T17:06:45Z");

#ifdef _MSC_VER
            std::tm timeInfo = {};
            gmtime_s(&timeInfo, &rawtime);
#else
            std::tm* timeInfo;
            timeInfo = std::gmtime(&rawtime);
#endif

            char timeStamp[timeStampSize];
            const char * const fmt = "%Y-%m-%dT%H:%M:%SZ";

#ifdef _MSC_VER
            std::strftime(timeStamp, timeStampSize, fmt, &timeInfo);
#else
            std::strftime(timeStamp, timeStampSize, fmt, timeInfo);
#endif
            return std::string(timeStamp);
        }

        std::string fileNameTag(const std::vector<std::string> &tags) {
            auto it = std::find_if(begin(tags),
                                   end(tags),
                                   [] (std::string const& tag) {return tag.front() == '#'; });
            if (it != tags.end())
                return it->substr(1);
            return std::string();
        }
    } // anonymous namespace

    JunitReporter::JunitReporter( ReporterConfig const& _config )
        :   CumulativeReporterBase( _config ),
            xml( _config.stream() )
        {
            m_reporterPrefs.shouldRedirectStdOut = true;
            m_reporterPrefs.shouldReportAllAssertions = true;
        }

    JunitReporter::~JunitReporter() {}

    std::string JunitReporter::getDescription() {
        return "Reports test results in an XML format that looks like Ant's junitreport target";
    }

    void JunitReporter::noMatchingTestCases( std::string const& /*spec*/ ) {}

    void JunitReporter::testRunStarting( TestRunInfo const& runInfo )  {
        CumulativeReporterBase::testRunStarting( runInfo );
        xml.startElement( "testsuites" );
    }

    void JunitReporter::testGroupStarting( GroupInfo const& groupInfo ) {
        suiteTimer.start();
        stdOutForSuite.clear();
        stdErrForSuite.clear();
        unexpectedExceptions = 0;
        CumulativeReporterBase::testGroupStarting( groupInfo );
    }

    void JunitReporter::testCaseStarting( TestCaseInfo const& testCaseInfo ) {
        m_okToFail = testCaseInfo.okToFail();
    }

    bool JunitReporter::assertionEnded( AssertionStats const& assertionStats ) {
        if( assertionStats.assertionResult.getResultType() == ResultWas::ThrewException && !m_okToFail )
            unexpectedExceptions++;
        return CumulativeReporterBase::assertionEnded( assertionStats );
    }

    void JunitReporter::testCaseEnded( TestCaseStats const& testCaseStats ) {
        stdOutForSuite += testCaseStats.stdOut;
        stdErrForSuite += testCaseStats.stdErr;
        CumulativeReporterBase::testCaseEnded( testCaseStats );
    }

    void JunitReporter::testGroupEnded( TestGroupStats const& testGroupStats ) {
        double suiteTime = suiteTimer.getElapsedSeconds();
        CumulativeReporterBase::testGroupEnded( testGroupStats );
        writeGroup( *m_testGroups.back(), suiteTime );
    }

    void JunitReporter::testRunEndedCumulative() {
        xml.endElement();
    }

    void JunitReporter::writeGroup( TestGroupNode const& groupNode, double suiteTime ) {
        XmlWriter::ScopedElement e = xml.scopedElement( "testsuite" );

        TestGroupStats const& stats = groupNode.value;
        xml.writeAttribute( "name", stats.groupInfo.name );
        xml.writeAttribute( "errors", unexpectedExceptions );
        xml.writeAttribute( "failures", stats.totals.assertions.failed-unexpectedExceptions );
        xml.writeAttribute( "tests", stats.totals.assertions.total() );
        xml.writeAttribute( "hostname", "tbd" ); // !TBD
        if( m_config->showDurations() == ShowDurations::Never )
            xml.writeAttribute( "time", "" );
        else
            xml.writeAttribute( "time", suiteTime );
        xml.writeAttribute( "timestamp", getCurrentTimestamp() );

        // Write properties if there are any
        if (m_config->hasTestFilters() || m_config->rngSeed() != 0) {
            auto properties = xml.scopedElement("properties");
            if (m_config->hasTestFilters()) {
                xml.scopedElement("property")
                    .writeAttribute("name", "filters")
                    .writeAttribute("value", serializeFilters(m_config->getTestsOrTags()));
            }
            if (m_config->rngSeed() != 0) {
                xml.scopedElement("property")
                    .writeAttribute("name", "random-seed")
                    .writeAttribute("value", m_config->rngSeed());
            }
        }

        // Write test cases
        for( auto const& child : groupNode.children )
            writeTestCase( *child );

        xml.scopedElement( "system-out" ).writeText( trim( stdOutForSuite ), XmlFormatting::Newline );
        xml.scopedElement( "system-err" ).writeText( trim( stdErrForSuite ), XmlFormatting::Newline );
    }

    void JunitReporter::writeTestCase( TestCaseNode const& testCaseNode ) {
        TestCaseStats const& stats = testCaseNode.value;

        // All test cases have exactly one section - which represents the
        // test case itself. That section may have 0-n nested sections
        assert( testCaseNode.children.size() == 1 );
        SectionNode const& rootSection = *testCaseNode.children.front();

        std::string className = stats.testInfo.className;

        if( className.empty() ) {
            className = fileNameTag(stats.testInfo.tags);
            if ( className.empty() )
                className = "global";
        }

        if ( !m_config->name().empty() )
            className = m_config->name() + "." + className;

        writeSection( className, "", rootSection );
    }

    void JunitReporter::writeSection(  std::string const& className,
                        std::string const& rootName,
                        SectionNode const& sectionNode ) {
        std::string name = trim( sectionNode.stats.sectionInfo.name );
        if( !rootName.empty() )
            name = rootName + '/' + name;

        if( !sectionNode.assertions.empty() ||
            !sectionNode.stdOut.empty() ||
            !sectionNode.stdErr.empty() ) {
            XmlWriter::ScopedElement e = xml.scopedElement( "testcase" );
            if( className.empty() ) {
                xml.writeAttribute( "classname", name );
                xml.writeAttribute( "name", "root" );
            }
            else {
                xml.writeAttribute( "classname", className );
                xml.writeAttribute( "name", name );
            }
            xml.writeAttribute( "time", ::Catch::Detail::stringify( sectionNode.stats.durationInSeconds ) );
            // This is not ideal, but it should be enough to mimic gtest's
            // junit output.
            // Ideally the JUnit reporter would also handle `skipTest`
            // events and write those out appropriately.
            xml.writeAttribute( "status", "run" );

            writeAssertions( sectionNode );

            if( !sectionNode.stdOut.empty() )
                xml.scopedElement( "system-out" ).writeText( trim( sectionNode.stdOut ), XmlFormatting::Newline );
            if( !sectionNode.stdErr.empty() )
                xml.scopedElement( "system-err" ).writeText( trim( sectionNode.stdErr ), XmlFormatting::Newline );
        }
        for( auto const& childNode : sectionNode.childSections )
            if( className.empty() )
                writeSection( name, "", *childNode );
            else
                writeSection( className, name, *childNode );
    }

    void JunitReporter::writeAssertions( SectionNode const& sectionNode ) {
        for( auto const& assertion : sectionNode.assertions )
            writeAssertion( assertion );
    }

    void JunitReporter::writeAssertion( AssertionStats const& stats ) {
        AssertionResult const& result = stats.assertionResult;
        if( !result.isOk() ) {
            std::string elementName;
            switch( result.getResultType() ) {
                case ResultWas::ThrewException:
                case ResultWas::FatalErrorCondition:
                    elementName = "error";
                    break;
                case ResultWas::ExplicitFailure:
                case ResultWas::ExpressionFailed:
                case ResultWas::DidntThrowException:
                    elementName = "failure";
                    break;

                // We should never see these here:
                case ResultWas::Info:
                case ResultWas::Warning:
                case ResultWas::Ok:
                case ResultWas::Unknown:
                case ResultWas::FailureBit:
                case ResultWas::Exception:
                    elementName = "internalError";
                    break;
            }

            XmlWriter::ScopedElement e = xml.scopedElement( elementName );

            xml.writeAttribute( "message", result.getExpression() );
            xml.writeAttribute( "type", result.getTestMacroName() );

            ReusableStringStream rss;
            if (stats.totals.assertions.total() > 0) {
                rss << "FAILED" << ":\n";
                if (result.hasExpression()) {
                    rss << "  ";
                    rss << result.getExpressionInMacro();
                    rss << '\n';
                }
                if (result.hasExpandedExpression()) {
                    rss << "with expansion:\n";
                    rss << Column(result.getExpandedExpression()).indent(2) << '\n';
                }
            } else {
                rss << '\n';
            }

            if( !result.getMessage().empty() )
                rss << result.getMessage() << '\n';
            for( auto const& msg : stats.infoMessages )
                if( msg.type == ResultWas::Info )
                    rss << msg.message << '\n';

            rss << "at " << result.getSourceInfo();
            xml.writeText( rss.str(), XmlFormatting::Newline );
        }
    }

    CATCH_REGISTER_REPORTER( "junit", JunitReporter )

} // end namespace Catch
// end catch_reporter_junit.cpp
// start catch_reporter_listening.cpp

#include <cassert>

namespace Catch {

    ListeningReporter::ListeningReporter() {
        // We will assume that listeners will always want all assertions
        m_preferences.shouldReportAllAssertions = true;
    }

    void ListeningReporter::addListener( IStreamingReporterPtr&& listener ) {
        m_listeners.push_back( std::move( listener ) );
    }

    void ListeningReporter::addReporter(IStreamingReporterPtr&& reporter) {
        assert(!m_reporter && "Listening reporter can wrap only 1 real reporter");
        m_reporter = std::move( reporter );
        m_preferences.shouldRedirectStdOut = m_reporter->getPreferences().shouldRedirectStdOut;
    }

    ReporterPreferences ListeningReporter::getPreferences() const {
        return m_preferences;
    }

    std::set<Verbosity> ListeningReporter::getSupportedVerbosities() {
        return std::set<Verbosity>{ };
    }

    void ListeningReporter::noMatchingTestCases( std::string const& spec ) {
        for ( auto const& listener : m_listeners ) {
            listener->noMatchingTestCases( spec );
        }
        m_reporter->noMatchingTestCases( spec );
    }

    void ListeningReporter::reportInvalidArguments(std::string const&arg){
        for ( auto const& listener : m_listeners ) {
            listener->reportInvalidArguments( arg );
        }
        m_reporter->reportInvalidArguments( arg );
    }

#if defined(CATCH_CONFIG_ENABLE_BENCHMARKING)
    void ListeningReporter::benchmarkPreparing( std::string const& name ) {
		for (auto const& listener : m_listeners) {
			listener->benchmarkPreparing(name);
		}
		m_reporter->benchmarkPreparing(name);
	}
    void ListeningReporter::benchmarkStarting( BenchmarkInfo const& benchmarkInfo ) {
        for ( auto const& listener : m_listeners ) {
            listener->benchmarkStarting( benchmarkInfo );
        }
        m_reporter->benchmarkStarting( benchmarkInfo );
    }
    void ListeningReporter::benchmarkEnded( BenchmarkStats<> const& benchmarkStats ) {
        for ( auto const& listener : m_listeners ) {
            listener->benchmarkEnded( benchmarkStats );
        }
        m_reporter->benchmarkEnded( benchmarkStats );
    }

	void ListeningReporter::benchmarkFailed( std::string const& error ) {
		for (auto const& listener : m_listeners) {
			listener->benchmarkFailed(error);
		}
		m_reporter->benchmarkFailed(error);
	}
#endif // CATCH_CONFIG_ENABLE_BENCHMARKING

    void ListeningReporter::testRunStarting( TestRunInfo const& testRunInfo ) {
        for ( auto const& listener : m_listeners ) {
            listener->testRunStarting( testRunInfo );
        }
        m_reporter->testRunStarting( testRunInfo );
    }

    void ListeningReporter::testGroupStarting( GroupInfo const& groupInfo ) {
        for ( auto const& listener : m_listeners ) {
            listener->testGroupStarting( groupInfo );
        }
        m_reporter->testGroupStarting( groupInfo );
    }

    void ListeningReporter::testCaseStarting( TestCaseInfo const& testInfo ) {
        for ( auto const& listener : m_listeners ) {
            listener->testCaseStarting( testInfo );
        }
        m_reporter->testCaseStarting( testInfo );
    }

    void ListeningReporter::sectionStarting( SectionInfo const& sectionInfo ) {
        for ( auto const& listener : m_listeners ) {
            listener->sectionStarting( sectionInfo );
        }
        m_reporter->sectionStarting( sectionInfo );
    }

    void ListeningReporter::assertionStarting( AssertionInfo const& assertionInfo ) {
        for ( auto const& listener : m_listeners ) {
            listener->assertionStarting( assertionInfo );
        }
        m_reporter->assertionStarting( assertionInfo );
    }

    // The return value indicates if the messages buffer should be cleared:
    bool ListeningReporter::assertionEnded( AssertionStats const& assertionStats ) {
        for( auto const& listener : m_listeners ) {
            static_cast<void>( listener->assertionEnded( assertionStats ) );
        }
        return m_reporter->assertionEnded( assertionStats );
    }

    void ListeningReporter::sectionEnded( SectionStats const& sectionStats ) {
        for ( auto const& listener : m_listeners ) {
            listener->sectionEnded( sectionStats );
        }
        m_reporter->sectionEnded( sectionStats );
    }

    void ListeningReporter::testCaseEnded( TestCaseStats const& testCaseStats ) {
        for ( auto const& listener : m_listeners ) {
            listener->testCaseEnded( testCaseStats );
        }
        m_reporter->testCaseEnded( testCaseStats );
    }

    void ListeningReporter::testGroupEnded( TestGroupStats const& testGroupStats ) {
        for ( auto const& listener : m_listeners ) {
            listener->testGroupEnded( testGroupStats );
        }
        m_reporter->testGroupEnded( testGroupStats );
    }

    void ListeningReporter::testRunEnded( TestRunStats const& testRunStats ) {
        for ( auto const& listener : m_listeners ) {
            listener->testRunEnded( testRunStats );
        }
        m_reporter->testRunEnded( testRunStats );
    }

    void ListeningReporter::skipTest( TestCaseInfo const& testInfo ) {
        for ( auto const& listener : m_listeners ) {
            listener->skipTest( testInfo );
        }
        m_reporter->skipTest( testInfo );
    }

    bool ListeningReporter::isMulti() const {
        return true;
    }

} // end namespace Catch
// end catch_reporter_listening.cpp
// start catch_reporter_xml.cpp

#if defined(_MSC_VER)
#pragma warning(push)
#pragma warning(disable:4061) // Not all labels are EXPLICITLY handled in switch
                              // Note that 4062 (not all labels are handled
                              // and default is missing) is enabled
#endif

namespace Catch {
    XmlReporter::XmlReporter( ReporterConfig const& _config )
    :   StreamingReporterBase( _config ),
        m_xml(_config.stream())
    {
        m_reporterPrefs.shouldRedirectStdOut = true;
        m_reporterPrefs.shouldReportAllAssertions = true;
    }

    XmlReporter::~XmlReporter() = default;

    std::string XmlReporter::getDescription() {
        return "Reports test results as an XML document";
    }

    std::string XmlReporter::getStylesheetRef() const {
        return std::string();
    }

    void XmlReporter::writeSourceInfo( SourceLineInfo const& sourceInfo ) {
        m_xml
            .writeAttribute( "filename", sourceInfo.file )
            .writeAttribute( "line", sourceInfo.line );
    }

    void XmlReporter::noMatchingTestCases( std::string const& s ) {
        StreamingReporterBase::noMatchingTestCases( s );
    }

    void XmlReporter::testRunStarting( TestRunInfo const& testInfo ) {
        StreamingReporterBase::testRunStarting( testInfo );
        std::string stylesheetRef = getStylesheetRef();
        if( !stylesheetRef.empty() )
            m_xml.writeStylesheetRef( stylesheetRef );
        m_xml.startElement( "Catch" );
        if( !m_config->name().empty() )
            m_xml.writeAttribute( "name", m_config->name() );
        if (m_config->testSpec().hasFilters())
            m_xml.writeAttribute( "filters", serializeFilters( m_config->getTestsOrTags() ) );
        if( m_config->rngSeed() != 0 )
            m_xml.scopedElement( "Randomness" )
                .writeAttribute( "seed", m_config->rngSeed() );
    }

    void XmlReporter::testGroupStarting( GroupInfo const& groupInfo ) {
        StreamingReporterBase::testGroupStarting( groupInfo );
        m_xml.startElement( "Group" )
            .writeAttribute( "name", groupInfo.name );
    }

    void XmlReporter::testCaseStarting( TestCaseInfo const& testInfo ) {
        StreamingReporterBase::testCaseStarting(testInfo);
        m_xml.startElement( "TestCase" )
            .writeAttribute( "name", trim( testInfo.name ) )
            .writeAttribute( "description", testInfo.description )
            .writeAttribute( "tags", testInfo.tagsAsString() );

        writeSourceInfo( testInfo.lineInfo );

        if ( m_config->showDurations() == ShowDurations::Always )
            m_testCaseTimer.start();
        m_xml.ensureTagClosed();
    }

    void XmlReporter::sectionStarting( SectionInfo const& sectionInfo ) {
        StreamingReporterBase::sectionStarting( sectionInfo );
        if( m_sectionDepth++ > 0 ) {
            m_xml.startElement( "Section" )
                .writeAttribute( "name", trim( sectionInfo.name ) );
            writeSourceInfo( sectionInfo.lineInfo );
            m_xml.ensureTagClosed();
        }
    }

    void XmlReporter::assertionStarting( AssertionInfo const& ) { }

    bool XmlReporter::assertionEnded( AssertionStats const& assertionStats ) {

        AssertionResult const& result = assertionStats.assertionResult;

        bool includeResults = m_config->includeSuccessfulResults() || !result.isOk();

        if( includeResults || result.getResultType() == ResultWas::Warning ) {
            // Print any info messages in <Info> tags.
            for( auto const& msg : assertionStats.infoMessages ) {
                if( msg.type == ResultWas::Info && includeResults ) {
                    m_xml.scopedElement( "Info" )
                            .writeText( msg.message );
                } else if ( msg.type == ResultWas::Warning ) {
                    m_xml.scopedElement( "Warning" )
                            .writeText( msg.message );
                }
            }
        }

        // Drop out if result was successful but we're not printing them.
        if( !includeResults && result.getResultType() != ResultWas::Warning )
            return true;

        // Print the expression if there is one.
        if( result.hasExpression() ) {
            m_xml.startElement( "Expression" )
                .writeAttribute( "success", result.succeeded() )
                .writeAttribute( "type", result.getTestMacroName() );

            writeSourceInfo( result.getSourceInfo() );

            m_xml.scopedElement( "Original" )
                .writeText( result.getExpression() );
            m_xml.scopedElement( "Expanded" )
                .writeText( result.getExpandedExpression() );
        }

        // And... Print a result applicable to each result type.
        switch( result.getResultType() ) {
            case ResultWas::ThrewException:
                m_xml.startElement( "Exception" );
                writeSourceInfo( result.getSourceInfo() );
                m_xml.writeText( result.getMessage() );
                m_xml.endElement();
                break;
            case ResultWas::FatalErrorCondition:
                m_xml.startElement( "FatalErrorCondition" );
                writeSourceInfo( result.getSourceInfo() );
                m_xml.writeText( result.getMessage() );
                m_xml.endElement();
                break;
            case ResultWas::Info:
                m_xml.scopedElement( "Info" )
                    .writeText( result.getMessage() );
                break;
            case ResultWas::Warning:
                // Warning will already have been written
                break;
            case ResultWas::ExplicitFailure:
                m_xml.startElement( "Failure" );
                writeSourceInfo( result.getSourceInfo() );
                m_xml.writeText( result.getMessage() );
                m_xml.endElement();
                break;
            default:
                break;
        }

        if( result.hasExpression() )
            m_xml.endElement();

        return true;
    }

    void XmlReporter::sectionEnded( SectionStats const& sectionStats ) {
        StreamingReporterBase::sectionEnded( sectionStats );
        if( --m_sectionDepth > 0 ) {
            XmlWriter::ScopedElement e = m_xml.scopedElement( "OverallResults" );
            e.writeAttribute( "successes", sectionStats.assertions.passed );
            e.writeAttribute( "failures", sectionStats.assertions.failed );
            e.writeAttribute( "expectedFailures", sectionStats.assertions.failedButOk );

            if ( m_config->showDurations() == ShowDurations::Always )
                e.writeAttribute( "durationInSeconds", sectionStats.durationInSeconds );

            m_xml.endElement();
        }
    }

    void XmlReporter::testCaseEnded( TestCaseStats const& testCaseStats ) {
        StreamingReporterBase::testCaseEnded( testCaseStats );
        XmlWriter::ScopedElement e = m_xml.scopedElement( "OverallResult" );
        e.writeAttribute( "success", testCaseStats.totals.assertions.allOk() );

        if ( m_config->showDurations() == ShowDurations::Always )
            e.writeAttribute( "durationInSeconds", m_testCaseTimer.getElapsedSeconds() );

        if( !testCaseStats.stdOut.empty() )
            m_xml.scopedElement( "StdOut" ).writeText( trim( testCaseStats.stdOut ), XmlFormatting::Newline );
        if( !testCaseStats.stdErr.empty() )
            m_xml.scopedElement( "StdErr" ).writeText( trim( testCaseStats.stdErr ), XmlFormatting::Newline );

        m_xml.endElement();
    }

    void XmlReporter::testGroupEnded( TestGroupStats const& testGroupStats ) {
        StreamingReporterBase::testGroupEnded( testGroupStats );
        // TODO: Check testGroupStats.aborting and act accordingly.
        m_xml.scopedElement( "OverallResults" )
            .writeAttribute( "successes", testGroupStats.totals.assertions.passed )
            .writeAttribute( "failures", testGroupStats.totals.assertions.failed )
            .writeAttribute( "expectedFailures", testGroupStats.totals.assertions.failedButOk );
        m_xml.scopedElement( "OverallResultsCases")
            .writeAttribute( "successes", testGroupStats.totals.testCases.passed )
            .writeAttribute( "failures", testGroupStats.totals.testCases.failed )
            .writeAttribute( "expectedFailures", testGroupStats.totals.testCases.failedButOk );
        m_xml.endElement();
    }

    void XmlReporter::testRunEnded( TestRunStats const& testRunStats ) {
        StreamingReporterBase::testRunEnded( testRunStats );
        m_xml.scopedElement( "OverallResults" )
            .writeAttribute( "successes", testRunStats.totals.assertions.passed )
            .writeAttribute( "failures", testRunStats.totals.assertions.failed )
            .writeAttribute( "expectedFailures", testRunStats.totals.assertions.failedButOk );
        m_xml.scopedElement( "OverallResultsCases")
            .writeAttribute( "successes", testRunStats.totals.testCases.passed )
            .writeAttribute( "failures", testRunStats.totals.testCases.failed )
            .writeAttribute( "expectedFailures", testRunStats.totals.testCases.failedButOk );
        m_xml.endElement();
    }

#if defined(CATCH_CONFIG_ENABLE_BENCHMARKING)
    void XmlReporter::benchmarkPreparing(std::string const& name) {
        m_xml.startElement("BenchmarkResults")
            .writeAttribute("name", name);
    }

    void XmlReporter::benchmarkStarting(BenchmarkInfo const &info) {
        m_xml.writeAttribute("samples", info.samples)
            .writeAttribute("resamples", info.resamples)
            .writeAttribute("iterations", info.iterations)
            .writeAttribute("clockResolution", info.clockResolution)
            .writeAttribute("estimatedDuration", info.estimatedDuration)
            .writeComment("All values in nano seconds");
    }

    void XmlReporter::benchmarkEnded(BenchmarkStats<> const& benchmarkStats) {
        m_xml.startElement("mean")
            .writeAttribute("value", benchmarkStats.mean.point.count())
            .writeAttribute("lowerBound", benchmarkStats.mean.lower_bound.count())
            .writeAttribute("upperBound", benchmarkStats.mean.upper_bound.count())
            .writeAttribute("ci", benchmarkStats.mean.confidence_interval);
        m_xml.endElement();
        m_xml.startElement("standardDeviation")
            .writeAttribute("value", benchmarkStats.standardDeviation.point.count())
            .writeAttribute("lowerBound", benchmarkStats.standardDeviation.lower_bound.count())
            .writeAttribute("upperBound", benchmarkStats.standardDeviation.upper_bound.count())
            .writeAttribute("ci", benchmarkStats.standardDeviation.confidence_interval);
        m_xml.endElement();
        m_xml.startElement("outliers")
            .writeAttribute("variance", benchmarkStats.outlierVariance)
            .writeAttribute("lowMild", benchmarkStats.outliers.low_mild)
            .writeAttribute("lowSevere", benchmarkStats.outliers.low_severe)
            .writeAttribute("highMild", benchmarkStats.outliers.high_mild)
            .writeAttribute("highSevere", benchmarkStats.outliers.high_severe);
        m_xml.endElement();
        m_xml.endElement();
    }

    void XmlReporter::benchmarkFailed(std::string const &error) {
        m_xml.scopedElement("failed").
            writeAttribute("message", error);
        m_xml.endElement();
    }
#endif // CATCH_CONFIG_ENABLE_BENCHMARKING

    CATCH_REGISTER_REPORTER( "xml", XmlReporter )

} // end namespace Catch

#if defined(_MSC_VER)
#pragma warning(pop)
#endif
// end catch_reporter_xml.cpp

namespace Catch {
    LeakDetector leakDetector;
}

#ifdef __clang__
#pragma clang diagnostic pop
#endif

// end catch_impl.hpp
#endif

#ifdef CATCH_CONFIG_MAIN
// start catch_default_main.hpp

#ifndef __OBJC__

#if defined(CATCH_CONFIG_WCHAR) && defined(CATCH_PLATFORM_WINDOWS) && defined(_UNICODE) && !defined(DO_NOT_USE_WMAIN)
// Standard C/C++ Win32 Unicode wmain entry point
extern "C" int wmain (int argc, wchar_t * argv[], wchar_t * []) {
#else
// Standard C/C++ main entry point
int main (int argc, char * argv[]) {
#endif

    return Catch::Session().run( argc, argv );
}

#else // __OBJC__

// Objective-C entry point
int main (int argc, char * const argv[]) {
#if !CATCH_ARC_ENABLED
    NSAutoreleasePool * pool = [[NSAutoreleasePool alloc] init];
#endif

    Catch::registerTestMethods();
    int result = Catch::Session().run( argc, (char**)argv );

#if !CATCH_ARC_ENABLED
    [pool drain];
#endif

    return result;
}

#endif // __OBJC__

// end catch_default_main.hpp
#endif

#if !defined(CATCH_CONFIG_IMPL_ONLY)

#ifdef CLARA_CONFIG_MAIN_NOT_DEFINED
#  undef CLARA_CONFIG_MAIN
#endif

#if !defined(CATCH_CONFIG_DISABLE)
//////
// If this config identifier is defined then all CATCH macros are prefixed with CATCH_
#ifdef CATCH_CONFIG_PREFIX_ALL

#define CATCH_REQUIRE( ... ) INTERNAL_CATCH_TEST( "CATCH_REQUIRE", Catch::ResultDisposition::Normal, __VA_ARGS__ )
#define CATCH_REQUIRE_FALSE( ... ) INTERNAL_CATCH_TEST( "CATCH_REQUIRE_FALSE", Catch::ResultDisposition::Normal | Catch::ResultDisposition::FalseTest, __VA_ARGS__ )

#define CATCH_REQUIRE_THROWS( ... ) INTERNAL_CATCH_THROWS( "CATCH_REQUIRE_THROWS", Catch::ResultDisposition::Normal, __VA_ARGS__ )
#define CATCH_REQUIRE_THROWS_AS( expr, exceptionType ) INTERNAL_CATCH_THROWS_AS( "CATCH_REQUIRE_THROWS_AS", exceptionType, Catch::ResultDisposition::Normal, expr )
#define CATCH_REQUIRE_THROWS_WITH( expr, matcher ) INTERNAL_CATCH_THROWS_STR_MATCHES( "CATCH_REQUIRE_THROWS_WITH", Catch::ResultDisposition::Normal, matcher, expr )
#if !defined(CATCH_CONFIG_DISABLE_MATCHERS)
#define CATCH_REQUIRE_THROWS_MATCHES( expr, exceptionType, matcher ) INTERNAL_CATCH_THROWS_MATCHES( "CATCH_REQUIRE_THROWS_MATCHES", exceptionType, Catch::ResultDisposition::Normal, matcher, expr )
#endif// CATCH_CONFIG_DISABLE_MATCHERS
#define CATCH_REQUIRE_NOTHROW( ... ) INTERNAL_CATCH_NO_THROW( "CATCH_REQUIRE_NOTHROW", Catch::ResultDisposition::Normal, __VA_ARGS__ )

#define CATCH_CHECK( ... ) INTERNAL_CATCH_TEST( "CATCH_CHECK", Catch::ResultDisposition::ContinueOnFailure, __VA_ARGS__ )
#define CATCH_CHECK_FALSE( ... ) INTERNAL_CATCH_TEST( "CATCH_CHECK_FALSE", Catch::ResultDisposition::ContinueOnFailure | Catch::ResultDisposition::FalseTest, __VA_ARGS__ )
#define CATCH_CHECKED_IF( ... ) INTERNAL_CATCH_IF( "CATCH_CHECKED_IF", Catch::ResultDisposition::ContinueOnFailure, __VA_ARGS__ )
#define CATCH_CHECKED_ELSE( ... ) INTERNAL_CATCH_ELSE( "CATCH_CHECKED_ELSE", Catch::ResultDisposition::ContinueOnFailure, __VA_ARGS__ )
#define CATCH_CHECK_NOFAIL( ... ) INTERNAL_CATCH_TEST( "CATCH_CHECK_NOFAIL", Catch::ResultDisposition::ContinueOnFailure | Catch::ResultDisposition::SuppressFail, __VA_ARGS__ )

#define CATCH_CHECK_THROWS( ... )  INTERNAL_CATCH_THROWS( "CATCH_CHECK_THROWS", Catch::ResultDisposition::ContinueOnFailure, __VA_ARGS__ )
#define CATCH_CHECK_THROWS_AS( expr, exceptionType ) INTERNAL_CATCH_THROWS_AS( "CATCH_CHECK_THROWS_AS", exceptionType, Catch::ResultDisposition::ContinueOnFailure, expr )
#define CATCH_CHECK_THROWS_WITH( expr, matcher ) INTERNAL_CATCH_THROWS_STR_MATCHES( "CATCH_CHECK_THROWS_WITH", Catch::ResultDisposition::ContinueOnFailure, matcher, expr )
#if !defined(CATCH_CONFIG_DISABLE_MATCHERS)
#define CATCH_CHECK_THROWS_MATCHES( expr, exceptionType, matcher ) INTERNAL_CATCH_THROWS_MATCHES( "CATCH_CHECK_THROWS_MATCHES", exceptionType, Catch::ResultDisposition::ContinueOnFailure, matcher, expr )
#endif // CATCH_CONFIG_DISABLE_MATCHERS
#define CATCH_CHECK_NOTHROW( ... ) INTERNAL_CATCH_NO_THROW( "CATCH_CHECK_NOTHROW", Catch::ResultDisposition::ContinueOnFailure, __VA_ARGS__ )

#if !defined(CATCH_CONFIG_DISABLE_MATCHERS)
#define CATCH_CHECK_THAT( arg, matcher ) INTERNAL_CHECK_THAT( "CATCH_CHECK_THAT", matcher, Catch::ResultDisposition::ContinueOnFailure, arg )

#define CATCH_REQUIRE_THAT( arg, matcher ) INTERNAL_CHECK_THAT( "CATCH_REQUIRE_THAT", matcher, Catch::ResultDisposition::Normal, arg )
#endif // CATCH_CONFIG_DISABLE_MATCHERS

#define CATCH_INFO( msg ) INTERNAL_CATCH_INFO( "CATCH_INFO", msg )
#define CATCH_UNSCOPED_INFO( msg ) INTERNAL_CATCH_UNSCOPED_INFO( "CATCH_UNSCOPED_INFO", msg )
#define CATCH_WARN( msg ) INTERNAL_CATCH_MSG( "CATCH_WARN", Catch::ResultWas::Warning, Catch::ResultDisposition::ContinueOnFailure, msg )
#define CATCH_CAPTURE( ... ) INTERNAL_CATCH_CAPTURE( INTERNAL_CATCH_UNIQUE_NAME(capturer), "CATCH_CAPTURE",__VA_ARGS__ )

#define CATCH_TEST_CASE( ... ) INTERNAL_CATCH_TESTCASE( __VA_ARGS__ )
#define CATCH_TEST_CASE_METHOD( className, ... ) INTERNAL_CATCH_TEST_CASE_METHOD( className, __VA_ARGS__ )
#define CATCH_METHOD_AS_TEST_CASE( method, ... ) INTERNAL_CATCH_METHOD_AS_TEST_CASE( method, __VA_ARGS__ )
#define CATCH_REGISTER_TEST_CASE( Function, ... ) INTERNAL_CATCH_REGISTER_TESTCASE( Function, __VA_ARGS__ )
#define CATCH_SECTION( ... ) INTERNAL_CATCH_SECTION( __VA_ARGS__ )
#define CATCH_DYNAMIC_SECTION( ... ) INTERNAL_CATCH_DYNAMIC_SECTION( __VA_ARGS__ )
#define CATCH_FAIL( ... ) INTERNAL_CATCH_MSG( "CATCH_FAIL", Catch::ResultWas::ExplicitFailure, Catch::ResultDisposition::Normal, __VA_ARGS__ )
#define CATCH_FAIL_CHECK( ... ) INTERNAL_CATCH_MSG( "CATCH_FAIL_CHECK", Catch::ResultWas::ExplicitFailure, Catch::ResultDisposition::ContinueOnFailure, __VA_ARGS__ )
#define CATCH_SUCCEED( ... ) INTERNAL_CATCH_MSG( "CATCH_SUCCEED", Catch::ResultWas::Ok, Catch::ResultDisposition::ContinueOnFailure, __VA_ARGS__ )

#define CATCH_ANON_TEST_CASE() INTERNAL_CATCH_TESTCASE()

#ifndef CATCH_CONFIG_TRADITIONAL_MSVC_PREPROCESSOR
#define CATCH_TEMPLATE_TEST_CASE( ... ) INTERNAL_CATCH_TEMPLATE_TEST_CASE( __VA_ARGS__ )
#define CATCH_TEMPLATE_TEST_CASE_SIG( ... ) INTERNAL_CATCH_TEMPLATE_TEST_CASE_SIG( __VA_ARGS__ )
#define CATCH_TEMPLATE_TEST_CASE_METHOD( className, ... ) INTERNAL_CATCH_TEMPLATE_TEST_CASE_METHOD( className, __VA_ARGS__ )
#define CATCH_TEMPLATE_TEST_CASE_METHOD_SIG( className, ... ) INTERNAL_CATCH_TEMPLATE_TEST_CASE_METHOD_SIG( className, __VA_ARGS__ )
#define CATCH_TEMPLATE_PRODUCT_TEST_CASE( ... ) INTERNAL_CATCH_TEMPLATE_PRODUCT_TEST_CASE( __VA_ARGS__ )
#define CATCH_TEMPLATE_PRODUCT_TEST_CASE_SIG( ... ) INTERNAL_CATCH_TEMPLATE_PRODUCT_TEST_CASE_SIG( __VA_ARGS__ )
#define CATCH_TEMPLATE_PRODUCT_TEST_CASE_METHOD( className, ... ) INTERNAL_CATCH_TEMPLATE_PRODUCT_TEST_CASE_METHOD( className, __VA_ARGS__ )
#define CATCH_TEMPLATE_PRODUCT_TEST_CASE_METHOD_SIG( className, ... ) INTERNAL_CATCH_TEMPLATE_PRODUCT_TEST_CASE_METHOD_SIG( className, __VA_ARGS__ )
#else
#define CATCH_TEMPLATE_TEST_CASE( ... ) INTERNAL_CATCH_EXPAND_VARGS( INTERNAL_CATCH_TEMPLATE_TEST_CASE( __VA_ARGS__ ) )
#define CATCH_TEMPLATE_TEST_CASE_SIG( ... ) INTERNAL_CATCH_EXPAND_VARGS( INTERNAL_CATCH_TEMPLATE_TEST_CASE_SIG( __VA_ARGS__ ) )
#define CATCH_TEMPLATE_TEST_CASE_METHOD( className, ... ) INTERNAL_CATCH_EXPAND_VARGS( INTERNAL_CATCH_TEMPLATE_TEST_CASE_METHOD( className, __VA_ARGS__ ) )
#define CATCH_TEMPLATE_TEST_CASE_METHOD_SIG( className, ... ) INTERNAL_CATCH_EXPAND_VARGS( INTERNAL_CATCH_TEMPLATE_TEST_CASE_METHOD_SIG( className, __VA_ARGS__ ) )
#define CATCH_TEMPLATE_PRODUCT_TEST_CASE( ... ) INTERNAL_CATCH_EXPAND_VARGS( INTERNAL_CATCH_TEMPLATE_PRODUCT_TEST_CASE( __VA_ARGS__ ) )
#define CATCH_TEMPLATE_PRODUCT_TEST_CASE_SIG( ... ) INTERNAL_CATCH_EXPAND_VARGS( INTERNAL_CATCH_TEMPLATE_PRODUCT_TEST_CASE_SIG( __VA_ARGS__ ) )
#define CATCH_TEMPLATE_PRODUCT_TEST_CASE_METHOD( className, ... ) INTERNAL_CATCH_EXPAND_VARGS( INTERNAL_CATCH_TEMPLATE_PRODUCT_TEST_CASE_METHOD( className, __VA_ARGS__ ) )
#define CATCH_TEMPLATE_PRODUCT_TEST_CASE_METHOD_SIG( className, ... ) INTERNAL_CATCH_EXPAND_VARGS( INTERNAL_CATCH_TEMPLATE_PRODUCT_TEST_CASE_METHOD_SIG( className, __VA_ARGS__ ) )
#endif

#if !defined(CATCH_CONFIG_RUNTIME_STATIC_REQUIRE)
#define CATCH_STATIC_REQUIRE( ... )       static_assert(   __VA_ARGS__ ,      #__VA_ARGS__ );     CATCH_SUCCEED( #__VA_ARGS__ )
#define CATCH_STATIC_REQUIRE_FALSE( ... ) static_assert( !(__VA_ARGS__), "!(" #__VA_ARGS__ ")" ); CATCH_SUCCEED( #__VA_ARGS__ )
#else
#define CATCH_STATIC_REQUIRE( ... )       CATCH_REQUIRE( __VA_ARGS__ )
#define CATCH_STATIC_REQUIRE_FALSE( ... ) CATCH_REQUIRE_FALSE( __VA_ARGS__ )
#endif

// "BDD-style" convenience wrappers
#define CATCH_SCENARIO( ... ) CATCH_TEST_CASE( "Scenario: " __VA_ARGS__ )
#define CATCH_SCENARIO_METHOD( className, ... ) INTERNAL_CATCH_TEST_CASE_METHOD( className, "Scenario: " __VA_ARGS__ )
#define CATCH_GIVEN( desc )     INTERNAL_CATCH_DYNAMIC_SECTION( "    Given: " << desc )
#define CATCH_AND_GIVEN( desc ) INTERNAL_CATCH_DYNAMIC_SECTION( "And given: " << desc )
#define CATCH_WHEN( desc )      INTERNAL_CATCH_DYNAMIC_SECTION( "     When: " << desc )
#define CATCH_AND_WHEN( desc )  INTERNAL_CATCH_DYNAMIC_SECTION( " And when: " << desc )
#define CATCH_THEN( desc )      INTERNAL_CATCH_DYNAMIC_SECTION( "     Then: " << desc )
#define CATCH_AND_THEN( desc )  INTERNAL_CATCH_DYNAMIC_SECTION( "      And: " << desc )

#if defined(CATCH_CONFIG_ENABLE_BENCHMARKING)
#define CATCH_BENCHMARK(...) \
    INTERNAL_CATCH_BENCHMARK(INTERNAL_CATCH_UNIQUE_NAME(____C_A_T_C_H____B_E_N_C_H____), INTERNAL_CATCH_GET_1_ARG(__VA_ARGS__,,), INTERNAL_CATCH_GET_2_ARG(__VA_ARGS__,,))
#define CATCH_BENCHMARK_ADVANCED(name) \
    INTERNAL_CATCH_BENCHMARK_ADVANCED(INTERNAL_CATCH_UNIQUE_NAME(____C_A_T_C_H____B_E_N_C_H____), name)
#endif // CATCH_CONFIG_ENABLE_BENCHMARKING

// If CATCH_CONFIG_PREFIX_ALL is not defined then the CATCH_ prefix is not required
#else

#define REQUIRE( ... ) INTERNAL_CATCH_TEST( "REQUIRE", Catch::ResultDisposition::Normal, __VA_ARGS__  )
#define REQUIRE_FALSE( ... ) INTERNAL_CATCH_TEST( "REQUIRE_FALSE", Catch::ResultDisposition::Normal | Catch::ResultDisposition::FalseTest, __VA_ARGS__ )

#define REQUIRE_THROWS( ... ) INTERNAL_CATCH_THROWS( "REQUIRE_THROWS", Catch::ResultDisposition::Normal, __VA_ARGS__ )
#define REQUIRE_THROWS_AS( expr, exceptionType ) INTERNAL_CATCH_THROWS_AS( "REQUIRE_THROWS_AS", exceptionType, Catch::ResultDisposition::Normal, expr )
#define REQUIRE_THROWS_WITH( expr, matcher ) INTERNAL_CATCH_THROWS_STR_MATCHES( "REQUIRE_THROWS_WITH", Catch::ResultDisposition::Normal, matcher, expr )
#if !defined(CATCH_CONFIG_DISABLE_MATCHERS)
#define REQUIRE_THROWS_MATCHES( expr, exceptionType, matcher ) INTERNAL_CATCH_THROWS_MATCHES( "REQUIRE_THROWS_MATCHES", exceptionType, Catch::ResultDisposition::Normal, matcher, expr )
#endif // CATCH_CONFIG_DISABLE_MATCHERS
#define REQUIRE_NOTHROW( ... ) INTERNAL_CATCH_NO_THROW( "REQUIRE_NOTHROW", Catch::ResultDisposition::Normal, __VA_ARGS__ )

#define CHECK( ... ) INTERNAL_CATCH_TEST( "CHECK", Catch::ResultDisposition::ContinueOnFailure, __VA_ARGS__ )
#define CHECK_FALSE( ... ) INTERNAL_CATCH_TEST( "CHECK_FALSE", Catch::ResultDisposition::ContinueOnFailure | Catch::ResultDisposition::FalseTest, __VA_ARGS__ )
#define CHECKED_IF( ... ) INTERNAL_CATCH_IF( "CHECKED_IF", Catch::ResultDisposition::ContinueOnFailure, __VA_ARGS__ )
#define CHECKED_ELSE( ... ) INTERNAL_CATCH_ELSE( "CHECKED_ELSE", Catch::ResultDisposition::ContinueOnFailure, __VA_ARGS__ )
#define CHECK_NOFAIL( ... ) INTERNAL_CATCH_TEST( "CHECK_NOFAIL", Catch::ResultDisposition::ContinueOnFailure | Catch::ResultDisposition::SuppressFail, __VA_ARGS__ )

#define CHECK_THROWS( ... )  INTERNAL_CATCH_THROWS( "CHECK_THROWS", Catch::ResultDisposition::ContinueOnFailure, __VA_ARGS__ )
#define CHECK_THROWS_AS( expr, exceptionType ) INTERNAL_CATCH_THROWS_AS( "CHECK_THROWS_AS", exceptionType, Catch::ResultDisposition::ContinueOnFailure, expr )
#define CHECK_THROWS_WITH( expr, matcher ) INTERNAL_CATCH_THROWS_STR_MATCHES( "CHECK_THROWS_WITH", Catch::ResultDisposition::ContinueOnFailure, matcher, expr )
#if !defined(CATCH_CONFIG_DISABLE_MATCHERS)
#define CHECK_THROWS_MATCHES( expr, exceptionType, matcher ) INTERNAL_CATCH_THROWS_MATCHES( "CHECK_THROWS_MATCHES", exceptionType, Catch::ResultDisposition::ContinueOnFailure, matcher, expr )
#endif // CATCH_CONFIG_DISABLE_MATCHERS
#define CHECK_NOTHROW( ... ) INTERNAL_CATCH_NO_THROW( "CHECK_NOTHROW", Catch::ResultDisposition::ContinueOnFailure, __VA_ARGS__ )

#if !defined(CATCH_CONFIG_DISABLE_MATCHERS)
#define CHECK_THAT( arg, matcher ) INTERNAL_CHECK_THAT( "CHECK_THAT", matcher, Catch::ResultDisposition::ContinueOnFailure, arg )

#define REQUIRE_THAT( arg, matcher ) INTERNAL_CHECK_THAT( "REQUIRE_THAT", matcher, Catch::ResultDisposition::Normal, arg )
#endif // CATCH_CONFIG_DISABLE_MATCHERS

#define INFO( msg ) INTERNAL_CATCH_INFO( "INFO", msg )
#define UNSCOPED_INFO( msg ) INTERNAL_CATCH_UNSCOPED_INFO( "UNSCOPED_INFO", msg )
#define WARN( msg ) INTERNAL_CATCH_MSG( "WARN", Catch::ResultWas::Warning, Catch::ResultDisposition::ContinueOnFailure, msg )
#define CAPTURE( ... ) INTERNAL_CATCH_CAPTURE( INTERNAL_CATCH_UNIQUE_NAME(capturer), "CAPTURE",__VA_ARGS__ )

#define TEST_CASE( ... ) INTERNAL_CATCH_TESTCASE( __VA_ARGS__ )
#define TEST_CASE_METHOD( className, ... ) INTERNAL_CATCH_TEST_CASE_METHOD( className, __VA_ARGS__ )
#define METHOD_AS_TEST_CASE( method, ... ) INTERNAL_CATCH_METHOD_AS_TEST_CASE( method, __VA_ARGS__ )
#define REGISTER_TEST_CASE( Function, ... ) INTERNAL_CATCH_REGISTER_TESTCASE( Function, __VA_ARGS__ )
#define SECTION( ... ) INTERNAL_CATCH_SECTION( __VA_ARGS__ )
#define DYNAMIC_SECTION( ... ) INTERNAL_CATCH_DYNAMIC_SECTION( __VA_ARGS__ )
#define FAIL( ... ) INTERNAL_CATCH_MSG( "FAIL", Catch::ResultWas::ExplicitFailure, Catch::ResultDisposition::Normal, __VA_ARGS__ )
#define FAIL_CHECK( ... ) INTERNAL_CATCH_MSG( "FAIL_CHECK", Catch::ResultWas::ExplicitFailure, Catch::ResultDisposition::ContinueOnFailure, __VA_ARGS__ )
#define SUCCEED( ... ) INTERNAL_CATCH_MSG( "SUCCEED", Catch::ResultWas::Ok, Catch::ResultDisposition::ContinueOnFailure, __VA_ARGS__ )
#define ANON_TEST_CASE() INTERNAL_CATCH_TESTCASE()

#ifndef CATCH_CONFIG_TRADITIONAL_MSVC_PREPROCESSOR
#define TEMPLATE_TEST_CASE( ... ) INTERNAL_CATCH_TEMPLATE_TEST_CASE( __VA_ARGS__ )
#define TEMPLATE_TEST_CASE_SIG( ... ) INTERNAL_CATCH_TEMPLATE_TEST_CASE_SIG( __VA_ARGS__ )
#define TEMPLATE_TEST_CASE_METHOD( className, ... ) INTERNAL_CATCH_TEMPLATE_TEST_CASE_METHOD( className, __VA_ARGS__ )
#define TEMPLATE_TEST_CASE_METHOD_SIG( className, ... ) INTERNAL_CATCH_TEMPLATE_TEST_CASE_METHOD_SIG( className, __VA_ARGS__ )
#define TEMPLATE_PRODUCT_TEST_CASE( ... ) INTERNAL_CATCH_TEMPLATE_PRODUCT_TEST_CASE( __VA_ARGS__ )
#define TEMPLATE_PRODUCT_TEST_CASE_SIG( ... ) INTERNAL_CATCH_TEMPLATE_PRODUCT_TEST_CASE_SIG( __VA_ARGS__ )
#define TEMPLATE_PRODUCT_TEST_CASE_METHOD( className, ... ) INTERNAL_CATCH_TEMPLATE_PRODUCT_TEST_CASE_METHOD( className, __VA_ARGS__ )
#define TEMPLATE_PRODUCT_TEST_CASE_METHOD_SIG( className, ... ) INTERNAL_CATCH_TEMPLATE_PRODUCT_TEST_CASE_METHOD_SIG( className, __VA_ARGS__ )
#define TEMPLATE_LIST_TEST_CASE( ... ) INTERNAL_CATCH_TEMPLATE_LIST_TEST_CASE(__VA_ARGS__)
#define TEMPLATE_LIST_TEST_CASE_METHOD( className, ... ) INTERNAL_CATCH_TEMPLATE_LIST_TEST_CASE_METHOD( className, __VA_ARGS__ )
#else
#define TEMPLATE_TEST_CASE( ... ) INTERNAL_CATCH_EXPAND_VARGS( INTERNAL_CATCH_TEMPLATE_TEST_CASE( __VA_ARGS__ ) )
#define TEMPLATE_TEST_CASE_SIG( ... ) INTERNAL_CATCH_EXPAND_VARGS( INTERNAL_CATCH_TEMPLATE_TEST_CASE_SIG( __VA_ARGS__ ) )
#define TEMPLATE_TEST_CASE_METHOD( className, ... ) INTERNAL_CATCH_EXPAND_VARGS( INTERNAL_CATCH_TEMPLATE_TEST_CASE_METHOD( className, __VA_ARGS__ ) )
#define TEMPLATE_TEST_CASE_METHOD_SIG( className, ... ) INTERNAL_CATCH_EXPAND_VARGS( INTERNAL_CATCH_TEMPLATE_TEST_CASE_METHOD_SIG( className, __VA_ARGS__ ) )
#define TEMPLATE_PRODUCT_TEST_CASE( ... ) INTERNAL_CATCH_EXPAND_VARGS( INTERNAL_CATCH_TEMPLATE_PRODUCT_TEST_CASE( __VA_ARGS__ ) )
#define TEMPLATE_PRODUCT_TEST_CASE_SIG( ... ) INTERNAL_CATCH_EXPAND_VARGS( INTERNAL_CATCH_TEMPLATE_PRODUCT_TEST_CASE_SIG( __VA_ARGS__ ) )
#define TEMPLATE_PRODUCT_TEST_CASE_METHOD( className, ... ) INTERNAL_CATCH_EXPAND_VARGS( INTERNAL_CATCH_TEMPLATE_PRODUCT_TEST_CASE_METHOD( className, __VA_ARGS__ ) )
#define TEMPLATE_PRODUCT_TEST_CASE_METHOD_SIG( className, ... ) INTERNAL_CATCH_EXPAND_VARGS( INTERNAL_CATCH_TEMPLATE_PRODUCT_TEST_CASE_METHOD_SIG( className, __VA_ARGS__ ) )
#define TEMPLATE_LIST_TEST_CASE( ... ) INTERNAL_CATCH_EXPAND_VARGS( INTERNAL_CATCH_TEMPLATE_LIST_TEST_CASE( __VA_ARGS__ ) )
#define TEMPLATE_LIST_TEST_CASE_METHOD( className, ... ) INTERNAL_CATCH_EXPAND_VARGS( INTERNAL_CATCH_TEMPLATE_LIST_TEST_CASE_METHOD( className, __VA_ARGS__ ) )
#endif

#if !defined(CATCH_CONFIG_RUNTIME_STATIC_REQUIRE)
#define STATIC_REQUIRE( ... )       static_assert(   __VA_ARGS__,  #__VA_ARGS__ ); SUCCEED( #__VA_ARGS__ )
#define STATIC_REQUIRE_FALSE( ... ) static_assert( !(__VA_ARGS__), "!(" #__VA_ARGS__ ")" ); SUCCEED( "!(" #__VA_ARGS__ ")" )
#else
#define STATIC_REQUIRE( ... )       REQUIRE( __VA_ARGS__ )
#define STATIC_REQUIRE_FALSE( ... ) REQUIRE_FALSE( __VA_ARGS__ )
#endif

#endif

#define CATCH_TRANSLATE_EXCEPTION( signature ) INTERNAL_CATCH_TRANSLATE_EXCEPTION( signature )

// "BDD-style" convenience wrappers
#define SCENARIO( ... ) TEST_CASE( "Scenario: " __VA_ARGS__ )
#define SCENARIO_METHOD( className, ... ) INTERNAL_CATCH_TEST_CASE_METHOD( className, "Scenario: " __VA_ARGS__ )

#define GIVEN( desc )     INTERNAL_CATCH_DYNAMIC_SECTION( "    Given: " << desc )
#define AND_GIVEN( desc ) INTERNAL_CATCH_DYNAMIC_SECTION( "And given: " << desc )
#define WHEN( desc )      INTERNAL_CATCH_DYNAMIC_SECTION( "     When: " << desc )
#define AND_WHEN( desc )  INTERNAL_CATCH_DYNAMIC_SECTION( " And when: " << desc )
#define THEN( desc )      INTERNAL_CATCH_DYNAMIC_SECTION( "     Then: " << desc )
#define AND_THEN( desc )  INTERNAL_CATCH_DYNAMIC_SECTION( "      And: " << desc )

#if defined(CATCH_CONFIG_ENABLE_BENCHMARKING)
#define BENCHMARK(...) \
    INTERNAL_CATCH_BENCHMARK(INTERNAL_CATCH_UNIQUE_NAME(____C_A_T_C_H____B_E_N_C_H____), INTERNAL_CATCH_GET_1_ARG(__VA_ARGS__,,), INTERNAL_CATCH_GET_2_ARG(__VA_ARGS__,,))
#define BENCHMARK_ADVANCED(name) \
    INTERNAL_CATCH_BENCHMARK_ADVANCED(INTERNAL_CATCH_UNIQUE_NAME(____C_A_T_C_H____B_E_N_C_H____), name)
#endif // CATCH_CONFIG_ENABLE_BENCHMARKING

using Catch::Detail::Approx;

#else // CATCH_CONFIG_DISABLE

//////
// If this config identifier is defined then all CATCH macros are prefixed with CATCH_
#ifdef CATCH_CONFIG_PREFIX_ALL

#define CATCH_REQUIRE( ... )        (void)(0)
#define CATCH_REQUIRE_FALSE( ... )  (void)(0)

#define CATCH_REQUIRE_THROWS( ... ) (void)(0)
#define CATCH_REQUIRE_THROWS_AS( expr, exceptionType ) (void)(0)
#define CATCH_REQUIRE_THROWS_WITH( expr, matcher )     (void)(0)
#if !defined(CATCH_CONFIG_DISABLE_MATCHERS)
#define CATCH_REQUIRE_THROWS_MATCHES( expr, exceptionType, matcher ) (void)(0)
#endif// CATCH_CONFIG_DISABLE_MATCHERS
#define CATCH_REQUIRE_NOTHROW( ... ) (void)(0)

#define CATCH_CHECK( ... )         (void)(0)
#define CATCH_CHECK_FALSE( ... )   (void)(0)
#define CATCH_CHECKED_IF( ... )    if (__VA_ARGS__)
#define CATCH_CHECKED_ELSE( ... )  if (!(__VA_ARGS__))
#define CATCH_CHECK_NOFAIL( ... )  (void)(0)

#define CATCH_CHECK_THROWS( ... )  (void)(0)
#define CATCH_CHECK_THROWS_AS( expr, exceptionType ) (void)(0)
#define CATCH_CHECK_THROWS_WITH( expr, matcher )     (void)(0)
#if !defined(CATCH_CONFIG_DISABLE_MATCHERS)
#define CATCH_CHECK_THROWS_MATCHES( expr, exceptionType, matcher ) (void)(0)
#endif // CATCH_CONFIG_DISABLE_MATCHERS
#define CATCH_CHECK_NOTHROW( ... ) (void)(0)

#if !defined(CATCH_CONFIG_DISABLE_MATCHERS)
#define CATCH_CHECK_THAT( arg, matcher )   (void)(0)

#define CATCH_REQUIRE_THAT( arg, matcher ) (void)(0)
#endif // CATCH_CONFIG_DISABLE_MATCHERS

#define CATCH_INFO( msg )          (void)(0)
#define CATCH_UNSCOPED_INFO( msg ) (void)(0)
#define CATCH_WARN( msg )          (void)(0)
#define CATCH_CAPTURE( msg )       (void)(0)

#define CATCH_TEST_CASE( ... ) INTERNAL_CATCH_TESTCASE_NO_REGISTRATION(INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_S_T____ ))
#define CATCH_TEST_CASE_METHOD( className, ... ) INTERNAL_CATCH_TESTCASE_NO_REGISTRATION(INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_S_T____ ))
#define CATCH_METHOD_AS_TEST_CASE( method, ... )
#define CATCH_REGISTER_TEST_CASE( Function, ... ) (void)(0)
#define CATCH_SECTION( ... )
#define CATCH_DYNAMIC_SECTION( ... )
#define CATCH_FAIL( ... ) (void)(0)
#define CATCH_FAIL_CHECK( ... ) (void)(0)
#define CATCH_SUCCEED( ... ) (void)(0)

#define CATCH_ANON_TEST_CASE() INTERNAL_CATCH_TESTCASE_NO_REGISTRATION(INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_S_T____ ))

#ifndef CATCH_CONFIG_TRADITIONAL_MSVC_PREPROCESSOR
#define CATCH_TEMPLATE_TEST_CASE( ... ) INTERNAL_CATCH_TEMPLATE_TEST_CASE_NO_REGISTRATION(__VA_ARGS__)
#define CATCH_TEMPLATE_TEST_CASE_SIG( ... ) INTERNAL_CATCH_TEMPLATE_TEST_CASE_SIG_NO_REGISTRATION(__VA_ARGS__)
#define CATCH_TEMPLATE_TEST_CASE_METHOD( className, ... ) INTERNAL_CATCH_TEMPLATE_TEST_CASE_METHOD_NO_REGISTRATION(className, __VA_ARGS__)
#define CATCH_TEMPLATE_TEST_CASE_METHOD_SIG( className, ... ) INTERNAL_CATCH_TEMPLATE_TEST_CASE_METHOD_SIG_NO_REGISTRATION(className, __VA_ARGS__ )
#define CATCH_TEMPLATE_PRODUCT_TEST_CASE( ... ) CATCH_TEMPLATE_TEST_CASE( __VA_ARGS__ )
#define CATCH_TEMPLATE_PRODUCT_TEST_CASE_SIG( ... ) CATCH_TEMPLATE_TEST_CASE( __VA_ARGS__ )
#define CATCH_TEMPLATE_PRODUCT_TEST_CASE_METHOD( className, ... ) CATCH_TEMPLATE_TEST_CASE_METHOD( className, __VA_ARGS__ )
#define CATCH_TEMPLATE_PRODUCT_TEST_CASE_METHOD_SIG( className, ... ) CATCH_TEMPLATE_TEST_CASE_METHOD( className, __VA_ARGS__ )
#else
#define CATCH_TEMPLATE_TEST_CASE( ... ) INTERNAL_CATCH_EXPAND_VARGS( INTERNAL_CATCH_TEMPLATE_TEST_CASE_NO_REGISTRATION(__VA_ARGS__) )
#define CATCH_TEMPLATE_TEST_CASE_SIG( ... ) INTERNAL_CATCH_EXPAND_VARGS( INTERNAL_CATCH_TEMPLATE_TEST_CASE_SIG_NO_REGISTRATION(__VA_ARGS__) )
#define CATCH_TEMPLATE_TEST_CASE_METHOD( className, ... ) INTERNAL_CATCH_EXPAND_VARGS( INTERNAL_CATCH_TEMPLATE_TEST_CASE_METHOD_NO_REGISTRATION(className, __VA_ARGS__ ) )
#define CATCH_TEMPLATE_TEST_CASE_METHOD_SIG( className, ... ) INTERNAL_CATCH_EXPAND_VARGS( INTERNAL_CATCH_TEMPLATE_TEST_CASE_METHOD_SIG_NO_REGISTRATION(className, __VA_ARGS__ ) )
#define CATCH_TEMPLATE_PRODUCT_TEST_CASE( ... ) CATCH_TEMPLATE_TEST_CASE( __VA_ARGS__ )
#define CATCH_TEMPLATE_PRODUCT_TEST_CASE_SIG( ... ) CATCH_TEMPLATE_TEST_CASE( __VA_ARGS__ )
#define CATCH_TEMPLATE_PRODUCT_TEST_CASE_METHOD( className, ... ) CATCH_TEMPLATE_TEST_CASE_METHOD( className, __VA_ARGS__ )
#define CATCH_TEMPLATE_PRODUCT_TEST_CASE_METHOD_SIG( className, ... ) CATCH_TEMPLATE_TEST_CASE_METHOD( className, __VA_ARGS__ )
#endif

// "BDD-style" convenience wrappers
#define CATCH_SCENARIO( ... ) INTERNAL_CATCH_TESTCASE_NO_REGISTRATION(INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_S_T____ ))
#define CATCH_SCENARIO_METHOD( className, ... ) INTERNAL_CATCH_TESTCASE_METHOD_NO_REGISTRATION(INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_S_T____ ), className )
#define CATCH_GIVEN( desc )
#define CATCH_AND_GIVEN( desc )
#define CATCH_WHEN( desc )
#define CATCH_AND_WHEN( desc )
#define CATCH_THEN( desc )
#define CATCH_AND_THEN( desc )

#define CATCH_STATIC_REQUIRE( ... )       (void)(0)
#define CATCH_STATIC_REQUIRE_FALSE( ... ) (void)(0)

// If CATCH_CONFIG_PREFIX_ALL is not defined then the CATCH_ prefix is not required
#else

#define REQUIRE( ... )       (void)(0)
#define REQUIRE_FALSE( ... ) (void)(0)

#define REQUIRE_THROWS( ... ) (void)(0)
#define REQUIRE_THROWS_AS( expr, exceptionType ) (void)(0)
#define REQUIRE_THROWS_WITH( expr, matcher ) (void)(0)
#if !defined(CATCH_CONFIG_DISABLE_MATCHERS)
#define REQUIRE_THROWS_MATCHES( expr, exceptionType, matcher ) (void)(0)
#endif // CATCH_CONFIG_DISABLE_MATCHERS
#define REQUIRE_NOTHROW( ... ) (void)(0)

#define CHECK( ... ) (void)(0)
#define CHECK_FALSE( ... ) (void)(0)
#define CHECKED_IF( ... ) if (__VA_ARGS__)
#define CHECKED_ELSE( ... ) if (!(__VA_ARGS__))
#define CHECK_NOFAIL( ... ) (void)(0)

#define CHECK_THROWS( ... )  (void)(0)
#define CHECK_THROWS_AS( expr, exceptionType ) (void)(0)
#define CHECK_THROWS_WITH( expr, matcher ) (void)(0)
#if !defined(CATCH_CONFIG_DISABLE_MATCHERS)
#define CHECK_THROWS_MATCHES( expr, exceptionType, matcher ) (void)(0)
#endif // CATCH_CONFIG_DISABLE_MATCHERS
#define CHECK_NOTHROW( ... ) (void)(0)

#if !defined(CATCH_CONFIG_DISABLE_MATCHERS)
#define CHECK_THAT( arg, matcher ) (void)(0)

#define REQUIRE_THAT( arg, matcher ) (void)(0)
#endif // CATCH_CONFIG_DISABLE_MATCHERS

#define INFO( msg ) (void)(0)
#define UNSCOPED_INFO( msg ) (void)(0)
#define WARN( msg ) (void)(0)
#define CAPTURE( msg ) (void)(0)

#define TEST_CASE( ... )  INTERNAL_CATCH_TESTCASE_NO_REGISTRATION(INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_S_T____ ))
#define TEST_CASE_METHOD( className, ... ) INTERNAL_CATCH_TESTCASE_NO_REGISTRATION(INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_S_T____ ))
#define METHOD_AS_TEST_CASE( method, ... )
#define REGISTER_TEST_CASE( Function, ... ) (void)(0)
#define SECTION( ... )
#define DYNAMIC_SECTION( ... )
#define FAIL( ... ) (void)(0)
#define FAIL_CHECK( ... ) (void)(0)
#define SUCCEED( ... ) (void)(0)
#define ANON_TEST_CASE() INTERNAL_CATCH_TESTCASE_NO_REGISTRATION(INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_S_T____ ))

#ifndef CATCH_CONFIG_TRADITIONAL_MSVC_PREPROCESSOR
#define TEMPLATE_TEST_CASE( ... ) INTERNAL_CATCH_TEMPLATE_TEST_CASE_NO_REGISTRATION(__VA_ARGS__)
#define TEMPLATE_TEST_CASE_SIG( ... ) INTERNAL_CATCH_TEMPLATE_TEST_CASE_SIG_NO_REGISTRATION(__VA_ARGS__)
#define TEMPLATE_TEST_CASE_METHOD( className, ... ) INTERNAL_CATCH_TEMPLATE_TEST_CASE_METHOD_NO_REGISTRATION(className, __VA_ARGS__)
#define TEMPLATE_TEST_CASE_METHOD_SIG( className, ... ) INTERNAL_CATCH_TEMPLATE_TEST_CASE_METHOD_SIG_NO_REGISTRATION(className, __VA_ARGS__ )
#define TEMPLATE_PRODUCT_TEST_CASE( ... ) TEMPLATE_TEST_CASE( __VA_ARGS__ )
#define TEMPLATE_PRODUCT_TEST_CASE_SIG( ... ) TEMPLATE_TEST_CASE( __VA_ARGS__ )
#define TEMPLATE_PRODUCT_TEST_CASE_METHOD( className, ... ) TEMPLATE_TEST_CASE_METHOD( className, __VA_ARGS__ )
#define TEMPLATE_PRODUCT_TEST_CASE_METHOD_SIG( className, ... ) TEMPLATE_TEST_CASE_METHOD( className, __VA_ARGS__ )
#else
#define TEMPLATE_TEST_CASE( ... ) INTERNAL_CATCH_EXPAND_VARGS( INTERNAL_CATCH_TEMPLATE_TEST_CASE_NO_REGISTRATION(__VA_ARGS__) )
#define TEMPLATE_TEST_CASE_SIG( ... ) INTERNAL_CATCH_EXPAND_VARGS( INTERNAL_CATCH_TEMPLATE_TEST_CASE_SIG_NO_REGISTRATION(__VA_ARGS__) )
#define TEMPLATE_TEST_CASE_METHOD( className, ... ) INTERNAL_CATCH_EXPAND_VARGS( INTERNAL_CATCH_TEMPLATE_TEST_CASE_METHOD_NO_REGISTRATION(className, __VA_ARGS__ ) )
#define TEMPLATE_TEST_CASE_METHOD_SIG( className, ... ) INTERNAL_CATCH_EXPAND_VARGS( INTERNAL_CATCH_TEMPLATE_TEST_CASE_METHOD_SIG_NO_REGISTRATION(className, __VA_ARGS__ ) )
#define TEMPLATE_PRODUCT_TEST_CASE( ... ) TEMPLATE_TEST_CASE( __VA_ARGS__ )
#define TEMPLATE_PRODUCT_TEST_CASE_SIG( ... ) TEMPLATE_TEST_CASE( __VA_ARGS__ )
#define TEMPLATE_PRODUCT_TEST_CASE_METHOD( className, ... ) TEMPLATE_TEST_CASE_METHOD( className, __VA_ARGS__ )
#define TEMPLATE_PRODUCT_TEST_CASE_METHOD_SIG( className, ... ) TEMPLATE_TEST_CASE_METHOD( className, __VA_ARGS__ )
#endif

#define STATIC_REQUIRE( ... )       (void)(0)
#define STATIC_REQUIRE_FALSE( ... ) (void)(0)

#endif

#define CATCH_TRANSLATE_EXCEPTION( signature ) INTERNAL_CATCH_TRANSLATE_EXCEPTION_NO_REG( INTERNAL_CATCH_UNIQUE_NAME( catch_internal_ExceptionTranslator ), signature )

// "BDD-style" convenience wrappers
#define SCENARIO( ... ) INTERNAL_CATCH_TESTCASE_NO_REGISTRATION(INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_S_T____ ) )
#define SCENARIO_METHOD( className, ... ) INTERNAL_CATCH_TESTCASE_METHOD_NO_REGISTRATION(INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_S_T____ ), className )

#define GIVEN( desc )
#define AND_GIVEN( desc )
#define WHEN( desc )
#define AND_WHEN( desc )
#define THEN( desc )
#define AND_THEN( desc )

using Catch::Detail::Approx;

#endif

#endif // ! CATCH_CONFIG_IMPL_ONLY

// start catch_reenable_warnings.h


#ifdef __clang__
#    ifdef __ICC // icpc defines the __clang__ macro
#        pragma warning(pop)
#    else
#        pragma clang diagnostic pop
#    endif
#elif defined __GNUC__
#    pragma GCC diagnostic pop
#endif

// end catch_reenable_warnings.h
// end catch.hpp
#endif // TWOBLUECUBES_SINGLE_INCLUDE_CATCH_HPP_INCLUDED


```

`tests/corruptor.cpp`:

```cpp
//////////////////////////////////////////////////////////////////////////////
//
//  Unit Test Image Corruptor (corruptor.cpp of unittests.exe)
//
//  Microsoft Research Detours Package
//
//  Copyright (c) Microsoft Corporation.  All rights reserved.
//
#include "windows.h"
#include "corruptor.h"

ImageCorruptor::ImageCorruptor(PIMAGE_DOS_HEADER Header)
{
    m_TargetDosHeader = Header;
    m_OriginalDosHeader = *Header;
    m_OriginalDosProtection = 0;
    m_TargetNtHeaders = (PIMAGE_NT_HEADERS)((PBYTE)Header + Header->e_lfanew);
    m_OriginalNtHeaders = *m_TargetNtHeaders;
    m_OriginalNtProtection = 0;

    VirtualProtect(
            m_TargetDosHeader,
            sizeof(*m_TargetDosHeader),
            PAGE_READWRITE,
            &m_OriginalDosProtection);

    VirtualProtect(
            m_TargetNtHeaders,
            sizeof(*m_TargetNtHeaders),
            PAGE_READWRITE,
            &m_OriginalNtProtection);
}

ImageCorruptor::~ImageCorruptor()
{
    // Restore original header contents.
    //
    *m_TargetDosHeader = m_OriginalDosHeader;
    *m_TargetNtHeaders = m_OriginalNtHeaders;

    // Restore original protection of DOS header.
    //
    DWORD OldProtection {};
    VirtualProtect(
            m_TargetDosHeader,
            sizeof(*m_TargetDosHeader),
            m_OriginalDosProtection,
            &OldProtection);

    // Restore original protection of NT headers.
    //
    VirtualProtect(
            m_TargetNtHeaders,
            sizeof(*m_TargetNtHeaders),
            m_OriginalNtProtection,
            &OldProtection);
}

void ImageCorruptor::ModifyDosMagic(WORD Value)
{
    m_TargetDosHeader->e_magic = Value;
}

void ImageCorruptor::ModifyNtSignature(ULONG Value)
{
    m_TargetNtHeaders->Signature = Value;
}

```

`tests/corruptor.h`:

```h
//////////////////////////////////////////////////////
//
//  Unit Test Image Corruptor (corruptor.h of unittests.exe)
//
//  Microsoft Research Detours Package
//
//  Copyright (c) Microsoft Corporation.  All rights reserved.
//
#pragma once

class ImageCorruptor final
{
public:

    ImageCorruptor(PIMAGE_DOS_HEADER Header);

    ~ImageCorruptor();

    void ModifyDosMagic(WORD Value);

    void ModifyNtSignature(ULONG Value);

private:
    // Pointer to the target image header to corrupt.
    //
    PIMAGE_DOS_HEADER m_TargetDosHeader;

    // Cached copy of the DOS header, to restore state with.
    //
    IMAGE_DOS_HEADER m_OriginalDosHeader;

    // The original protection of the DOS header.
    //
    DWORD m_OriginalDosProtection;

    // Pointer to the target NT image header to corrupt.
    //
    PIMAGE_NT_HEADERS m_TargetNtHeaders;

    // Cached copy of the NT headers, to restore state with.
    //
    IMAGE_NT_HEADERS m_OriginalNtHeaders;

    // The original protection of the NT headers.
    //
    DWORD m_OriginalNtProtection;
};

```

`tests/main.cpp`:

```cpp
//////////////////////////////////////////////////////////////////////////////
//
//  Unit Test Main (main.cpp of unittests.exe)
//
//  Microsoft Research Detours Package
//
//  Copyright (c) Microsoft Corporation.  All rights reserved.
//
#define CATCH_CONFIG_MAIN
#include "catch.hpp"

```

`tests/payload.cpp`:

```cpp
//////////////////////////////////////////////////////////////////////////////
//
//  Test Payload for Detours Module API tests (payload.cpp of unittests.exe)
//
//  Microsoft Research Detours Package
//
//  Copyright (c) Microsoft Corporation.  All rights reserved.
//
#include "payload.h"

// Define a detours payload for testing.
//
#pragma data_seg(".detour")

static CPrivateStuff private_stuff = {
    DETOUR_SECTION_HEADER_DECLARE(sizeof(CPrivateStuff)),
    {
        (sizeof(CPrivateStuff) - sizeof(DETOUR_SECTION_HEADER)),
        0,
        TEST_PAYLOAD_GUID
    },
    "Testing Payload 123"
};

#pragma data_seg()

```

`tests/payload.h`:

```h
//////////////////////////////////////////////////////////////////////////////
//
//  Test Payload for Detours Module API tests (payload.h of unittests.exe)
//
//  Microsoft Research Detours Package
//
//  Copyright (c) Microsoft Corporation.  All rights reserved.
//
#pragma once
#include <cstddef>
#include "windows.h"
#include "detours.h"

// {85ECA590-6E6A-40FC-BA75-451D96A2A746}
static constexpr GUID TEST_PAYLOAD_GUID = 
{ 0x85eca590, 0x6e6a, 0x40fc, { 0xba, 0x75, 0x45, 0x1d, 0x96, 0xa2, 0xa7, 0x46 } };

static constexpr std::size_t TEST_PAYLOAD_SIZE = 32;

struct CPrivateStuff
{
    DETOUR_SECTION_HEADER   header;
    DETOUR_SECTION_RECORD   record;
    CHAR                    szMessage[TEST_PAYLOAD_SIZE];
};

```

`tests/process_helpers.cpp`:

```cpp
//////////////////////////////////////////////////////////////////////////////
//
//  Process Test Helpers (process_helpers.cpp of unittests.exe)
//
//  Microsoft Research Detours Package
//
//  Copyright (c) Microsoft Corporation.  All rights reserved.
//
#include "windows.h"
#include "process_helpers.h"

HRESULT GetProcessFileName(HANDLE process, std::wstring& filename)
{
    filename.resize(MAX_PATH);

    DWORD size = static_cast<DWORD>(filename.size()) + 1;
    if (QueryFullProcessImageNameW(process, 0, &filename[0], &size))
    {
        filename.resize(size);
        return S_OK;
    }
    else
    {
        return HRESULT_FROM_WIN32(GetLastError());
    }
}

HRESULT CreateSuspendedCopy(TerminateOnScopeExit& wrapper)
{
    std::wstring location;
    const auto hr = GetProcessFileName(GetCurrentProcess(), location);
    if (FAILED(hr))
    {
        return hr;
    }

    STARTUPINFOW si = { sizeof(si) };
    if (!CreateProcessW(location.c_str(), nullptr, nullptr, nullptr, false, CREATE_SUSPENDED, nullptr, nullptr, &si, &wrapper.information))
    {
        return HRESULT_FROM_WIN32(GetLastError());
    }

    return S_OK;
}
```

`tests/process_helpers.h`:

```h
//////////////////////////////////////////////////////
//
//  Process Test Helpers (process_helpers.h of unittests.exe)
//
//  Microsoft Research Detours Package
//
//  Copyright (c) Microsoft Corporation.  All rights reserved.
//
#pragma once
#include <string>
#include <utility>

struct TerminateOnScopeExit
{
    PROCESS_INFORMATION information;

    TerminateOnScopeExit(const TerminateOnScopeExit&) = delete;
    TerminateOnScopeExit& operator=(const TerminateOnScopeExit&) = delete;

    ~TerminateOnScopeExit()
    {
        if (information.hThread)
        {
            TerminateThread(information.hThread, 0);
            CloseHandle(information.hThread);
        }

        if (information.hProcess)
        {
            TerminateProcess(information.hProcess, 0);
            CloseHandle(information.hProcess);
        }
    }
};

HRESULT GetProcessFileName(HANDLE process, std::wstring& filename);
HRESULT CreateSuspendedCopy(TerminateOnScopeExit& wrapper);

```

`tests/test_image_api.cpp`:

```cpp
//////////////////////////////////////////////////////////////////////////////
//
//  Unit Tests for Detours Image API (test_image_api.cpp of unittests.exe)
//
//  Microsoft Research Detours Package
//
//  Copyright (c) Microsoft Corporation.  All rights reserved.
//
#include "catch.hpp"
#include "windows.h"
#include "detours.h"

TEST_CASE("DetourBinaryOpen", "[image]")
{
    SECTION("Passing INVALID_HANDLE, results in error")
    {
        auto binary = DetourBinaryOpen(INVALID_HANDLE_VALUE);
        REQUIRE( GetLastError() == ERROR_INVALID_HANDLE );
        REQUIRE( binary == nullptr );
    }
}

```

`tests/test_module_api.cpp`:

```cpp
//////////////////////////////////////////////////////////////////////////////
//
//  Unit Tests for Detours Module API (test_module_api.cpp of unittests.exe)
//
//  Microsoft Research Detours Package
//
//  Copyright (c) Microsoft Corporation.  All rights reserved.
//
#include "catch.hpp"
#include "windows.h"

#define DETOURS_INTERNAL

#include "detours.h"
#include "corruptor.h"
#include "payload.h"
#include "process_helpers.h"

// Expose the image base of the current module for test assertions.
//
extern "C" IMAGE_DOS_HEADER __ImageBase;

// Expose default module entry point for test assertions.
//
extern "C" int mainCRTStartup();

// Dummy function pointer used for tests.
//
void NoopFunction() { }

TEST_CASE("DetourLoadImageHlp", "[module]")
{
    SECTION("Passing own function, results in own HMODULE")
    {
        auto info = DetourLoadImageHlp();

        REQUIRE( info != nullptr );
        REQUIRE( info->hDbgHelp != NULL);
        REQUIRE( info->pfImagehlpApiVersionEx != nullptr );
        REQUIRE( info->pfSymInitialize != nullptr );
        REQUIRE( info->pfSymSetOptions != nullptr );
        REQUIRE( info->pfSymGetOptions != nullptr );
        REQUIRE( info->pfSymLoadModule64 != nullptr );
        REQUIRE( info->pfSymGetModuleInfo64 != nullptr );
        REQUIRE( info->pfSymFromName != nullptr );
    }
}

TEST_CASE("DetourFindFunction", "[module]")
{
    SECTION("Passing nullptr for all parameters, results in nullptr")
    {
        SetLastError(NO_ERROR);

        auto func = DetourFindFunction(nullptr, nullptr);

        REQUIRE( GetLastError() == ERROR_INVALID_PARAMETER );
        REQUIRE( func == nullptr );
    }

    SECTION("Passing nullptr for function, results in nullptr")
    {
        SetLastError(NO_ERROR);

        auto func = DetourFindFunction("ntdll.dll", nullptr);

        REQUIRE( GetLastError() == ERROR_INVALID_PARAMETER );
        REQUIRE( func == nullptr );
    }

    SECTION("Passing nullptr for module, results in nullptr")
    {
        SetLastError(NO_ERROR);

        auto func = DetourFindFunction(nullptr, "FunctionThatDoesntExist");

        REQUIRE( GetLastError() == ERROR_INVALID_PARAMETER );
        REQUIRE( func == nullptr );
    }

    SECTION("Finding ntdll export is successful")
    {
        SetLastError(NO_ERROR);

        auto func = DetourFindFunction("ntdll.dll", "NtDeviceIoControlFile");

        REQUIRE( GetLastError() == NO_ERROR );
        REQUIRE( func != nullptr );
    }
}

TEST_CASE("DetourGetContainingModule", "[module]")
{
    SECTION("Passing nullptr, results in nullptr")
    {
        SetLastError(NO_ERROR);

        auto mod = DetourGetContainingModule(nullptr);

        REQUIRE( GetLastError() == ERROR_BAD_EXE_FORMAT );
        REQUIRE( mod == nullptr );
    }

    SECTION("Passing GetCommandLineW, results in kernel32 HMODULE")
    {
        SetLastError(ERROR_INVALID_HANDLE);

        auto mod = DetourGetContainingModule(GetCommandLineW);

        REQUIRE( GetLastError() == NO_ERROR );
        REQUIRE( mod == LoadLibraryW(L"kernel32.dll") );
    }

    SECTION("Passing own function, results in own HMODULE")
    {
        SetLastError(ERROR_INVALID_HANDLE);

        auto mod = DetourGetContainingModule(NoopFunction);

        REQUIRE( GetLastError() == NO_ERROR );
        REQUIRE( mod == reinterpret_cast<HMODULE>(&__ImageBase) );
    }
}

TEST_CASE("DetourGetEntyPoint", "[module]")
{
    SECTION("Passing nullptr, results in CRT entrypoint")
    {
        SetLastError(ERROR_INVALID_HANDLE);

        auto entry = DetourGetEntryPoint(nullptr);

        REQUIRE( GetLastError() == NO_ERROR );
        REQUIRE( entry == mainCRTStartup );
    }

    SECTION("Passing nullptr, equals executing image")
    {
        REQUIRE( DetourGetEntryPoint(nullptr) ==
                 DetourGetEntryPoint(reinterpret_cast<HMODULE>(&__ImageBase)) );
    }

    SECTION("Passing ImageBase, results in CRT main")
    {
        SetLastError(ERROR_INVALID_HANDLE);

        auto entry = DetourGetEntryPoint(reinterpret_cast<HMODULE>(&__ImageBase));

        REQUIRE( GetLastError() == NO_ERROR );
        REQUIRE( entry == mainCRTStartup );
    }

    SECTION("Corrupt image DOS header magic, results in bad exe format error")
    {
        ImageCorruptor corruptor(&__ImageBase);
        corruptor.ModifyDosMagic(0xDEAD);

        SetLastError(NO_ERROR);

        auto entry = DetourGetEntryPoint(reinterpret_cast<HMODULE>(&__ImageBase));

        REQUIRE( GetLastError() == ERROR_BAD_EXE_FORMAT );
        REQUIRE( entry == nullptr );
    }

    SECTION("Corrupt image NT header signature, results in invalid signature error")
    {
        ImageCorruptor corruptor(&__ImageBase);
        corruptor.ModifyNtSignature(0xDEADBEEF);

        SetLastError(NO_ERROR);

        auto entry = DetourGetEntryPoint(reinterpret_cast<HMODULE>(&__ImageBase));

        REQUIRE( GetLastError() == ERROR_INVALID_EXE_SIGNATURE );
        REQUIRE( entry == nullptr );
    }
}

TEST_CASE("DetourGetModuleSize", "[module]")
{
    SECTION("Passing nullptr, results in current module size")
    {
        SetLastError(ERROR_INVALID_HANDLE);

        auto size = DetourGetModuleSize(nullptr);

        REQUIRE( GetLastError() == NO_ERROR );
        REQUIRE( size > 0 );
    }

    SECTION("Passing stack, results in error")
    {
        SetLastError(NO_ERROR);

        int value;
        auto size = DetourGetModuleSize(reinterpret_cast<HMODULE>(&value));

        REQUIRE( GetLastError() == ERROR_BAD_EXE_FORMAT);
        REQUIRE( size == 0 );
    }

    SECTION("Passing nullptr, equals executing image")
    {
        REQUIRE( DetourGetModuleSize(nullptr) ==
                 DetourGetModuleSize(reinterpret_cast<HMODULE>(&__ImageBase)) );
    }

    SECTION("Corrupt image DOS header magic, results in bad exe format error")
    {
        ImageCorruptor corruptor(&__ImageBase);
        corruptor.ModifyDosMagic(0xDEAD);

        SetLastError(NO_ERROR);

        auto size = DetourGetModuleSize(reinterpret_cast<HMODULE>(&__ImageBase));

        REQUIRE( GetLastError() == ERROR_BAD_EXE_FORMAT );
        REQUIRE( size == 0 );
    }

    SECTION("Corrupt image NT header signature, results in invalid signature error")
    {
        ImageCorruptor corruptor(&__ImageBase);
        corruptor.ModifyNtSignature(0xDEADBEEF);

        SetLastError(NO_ERROR);

        auto size = DetourGetModuleSize(reinterpret_cast<HMODULE>(&__ImageBase));
        REQUIRE( GetLastError() == ERROR_INVALID_EXE_SIGNATURE );
        REQUIRE( size == 0 );
    }
}

TEST_CASE("DetourEnumerateModules", "[module]")
{
    SECTION("Passing nullptr, results in current module being returned")
    {
        SetLastError(ERROR_INVALID_HANDLE);

        auto mod = DetourEnumerateModules(nullptr);

        REQUIRE( GetLastError() == NO_ERROR );
        REQUIRE( mod != NULL );
    }

    SECTION("Passing stack, results in module")
    {
        SetLastError(NO_ERROR);

        int value;
        auto mod = DetourEnumerateModules(reinterpret_cast<HMODULE>(&value));

        REQUIRE( GetLastError() == NO_ERROR );
        REQUIRE( mod != NULL );
    }
}

// Export test function, only used for test assertions.
//
__declspec(dllexport) void TestFunctionExport() { }

// Context object passed to DetourEnumerateExport(..)
//
struct EnumerateExportsTestContext
{
    // Number of exports 
    //
    int ExportCount { 0 };

    // If the 'TestFunctionExport' export exists in the module.
    //
    bool ExportFound { false };
};

// Callback for each modue enumerated with DetourEnumerateExport(..)
//
BOOL CALLBACK ExportCallback(
    _In_opt_ PVOID pContext,
    _In_ ULONG nOrdinal,
    _In_opt_ LPCSTR pszSymbol,
    _In_opt_ PVOID pbTarget)
{
    (void)pContext;
    (void)pbTarget;
    (void)nOrdinal;

    EnumerateExportsTestContext* context =
        reinterpret_cast<EnumerateExportsTestContext*>(pContext);

    context->ExportCount++;

    context->ExportFound |= Catch::contains(pszSymbol, "TestFunctionExport");

    return TRUE;
}

TEST_CASE("DetourEnumerateExports", "[module]")
{
    SECTION("Passing nullptr all, results in failure.")
    {
        SetLastError(NO_ERROR);

        auto success = DetourEnumerateExports(nullptr, nullptr, nullptr);

        REQUIRE( GetLastError() == ERROR_INVALID_PARAMETER );
        REQUIRE_FALSE( success );
    }

    SECTION("Passing nullptr for just the module, resolves export in current modulee.")
    {
        SetLastError(ERROR_INVALID_HANDLE);

        EnumerateExportsTestContext context {};
        auto success = DetourEnumerateExports(nullptr, &context, ExportCallback);

        REQUIRE( GetLastError() == NO_ERROR );
        REQUIRE( success );
        REQUIRE( context.ExportCount == 1 );
        REQUIRE( context.ExportFound );
    }

    SECTION("Passing current module, resolves export correctly.")
    {
        SetLastError(ERROR_INVALID_HANDLE);

        EnumerateExportsTestContext context {};
        auto mod = reinterpret_cast<HMODULE>(&__ImageBase);
        auto success = DetourEnumerateExports(mod, &context, ExportCallback);

        REQUIRE( GetLastError() == NO_ERROR );
        REQUIRE( success );

        REQUIRE( context.ExportCount == 1 );
        REQUIRE( context.ExportFound );
    }

    SECTION("Passing stack, results in error")
    {
        SetLastError(NO_ERROR);

        int value;
        auto mod = reinterpret_cast<HMODULE>(&value);

        EnumerateExportsTestContext context {};
        auto success = DetourEnumerateExports(mod, &context, ExportCallback);

        REQUIRE( GetLastError() == ERROR_BAD_EXE_FORMAT);
        REQUIRE_FALSE( success );
    }

    SECTION("Corrupt image DOS header magic, results in bad exe format error")
    {
        ImageCorruptor corruptor(&__ImageBase);
        corruptor.ModifyDosMagic(0xDEAD);

        SetLastError(NO_ERROR);

        EnumerateExportsTestContext context {};
        auto mod = reinterpret_cast<HMODULE>(&__ImageBase);
        auto success = DetourEnumerateExports(mod, &context, ExportCallback);

        REQUIRE( GetLastError() == ERROR_BAD_EXE_FORMAT );
        REQUIRE_FALSE( success );
    }

    SECTION("Corrupt image NT header signature, results in invalid signature error")
    {
        ImageCorruptor corruptor(&__ImageBase);
        corruptor.ModifyNtSignature(0xDEADBEEF);

        SetLastError(NO_ERROR);

        EnumerateExportsTestContext context {};
        auto mod = reinterpret_cast<HMODULE>(&__ImageBase);
        auto success = DetourEnumerateExports(mod, &context, ExportCallback);

        REQUIRE( GetLastError() == ERROR_INVALID_EXE_SIGNATURE );
        REQUIRE_FALSE( success );
    }
}

// Context object passed to DetourEnumerateimportsExport(..)
//
struct EnumerateImportsTestContext
{
    // Number of imports
    //
    int ImportCount { 0 };

    // If the 'TestFunctionExport' export exists in the module.
    //
    bool ImportModuleFound { false };

    // Number of imports
    //
    int ImportFuncCount { 0 };

    // If the 'TestFunctionExport' export exists in the module.
    //
    bool ImportFuncFound { false };
};

// Callback for each module enumerated with DetourEnumerateImports(..)
//
BOOL WINAPI ImportFileCallback(PVOID pContext, HMODULE, PCSTR pszFile)
{
    EnumerateImportsTestContext* context =
        reinterpret_cast<EnumerateImportsTestContext*>(pContext);

    context->ImportCount++;
    context->ImportModuleFound |= Catch::contains(pszFile, "ntdll");

    return TRUE;
}

// Callback for each function enumerated with DetourEnumerateImports(..)
//
BOOL WINAPI ImportFuncCallback(_In_opt_ PVOID pContext,
                               _In_ DWORD nOrdinal,
                               _In_opt_ LPCSTR pszFunc,
                               _In_opt_ PVOID pvFunc)
{
    UNREFERENCED_PARAMETER(nOrdinal);
    UNREFERENCED_PARAMETER(pszFunc);
    UNREFERENCED_PARAMETER(pvFunc);

    EnumerateImportsTestContext* context =
        reinterpret_cast<EnumerateImportsTestContext*>(pContext);

    context->ImportFuncCount++;
 
    return TRUE;
}

TEST_CASE("DetourEnumerateImports", "[module]")
{
    SECTION("Passing nullptr all, results in invalid parameter.")
    {
        SetLastError(NO_ERROR);

        auto success = DetourEnumerateImports(nullptr, nullptr, nullptr, nullptr);

        REQUIRE( GetLastError() == ERROR_INVALID_PARAMETER );
        REQUIRE_FALSE( success );
    }

    SECTION("Passing nullptr for module callback, results in invalid parameter.")
    {
        SetLastError(NO_ERROR);

        EnumerateImportsTestContext context {};
        auto success = DetourEnumerateImports(nullptr, &context, ImportFileCallback, nullptr);

        REQUIRE( GetLastError() == ERROR_INVALID_PARAMETER );
        REQUIRE_FALSE( success );
        REQUIRE( context.ImportCount == 0 );
        REQUIRE_FALSE( context.ImportModuleFound );
    }

    SECTION("Passing nullptr for function callback, resolves in invalid parameter.")
    {
        SetLastError(ERROR_INVALID_HANDLE);

        EnumerateImportsTestContext context {};
        auto success = DetourEnumerateImports(nullptr, &context, nullptr, ImportFuncCallback);

        REQUIRE( GetLastError() == ERROR_INVALID_PARAMETER );
        REQUIRE_FALSE( success );

        REQUIRE( context.ImportFuncCount == 0 );
        REQUIRE_FALSE( context.ImportFuncFound );
    }
}

TEST_CASE("DetourGetSizeOfPayloads", "[module]")
{
    SECTION("Passing nullptr for module, is successful.")
    {
        SetLastError(ERROR_INVALID_HANDLE);

        auto size = DetourGetSizeOfPayloads(nullptr);

        REQUIRE( GetLastError() == NO_ERROR );
        REQUIRE( size == sizeof(CPrivateStuff) );
    }

    SECTION("Passing nullptr is the same as current module.")
    {
        SetLastError(ERROR_INVALID_HANDLE);

        auto mod = reinterpret_cast<HMODULE>(&__ImageBase);

        auto nullSize = DetourGetSizeOfPayloads(nullptr);
        auto modSize = DetourGetSizeOfPayloads(mod);

        REQUIRE( modSize == nullSize );
    }

    SECTION("Passing a module with no payload, results in exe marked invalid.")
    {
        auto mod = GetModuleHandleW(L"ntdll.dll");

        SetLastError(NO_ERROR);

        auto size = DetourGetSizeOfPayloads(mod);

        REQUIRE( GetLastError() == ERROR_EXE_MARKED_INVALID );
        REQUIRE( size == 0 );
    }

    SECTION("Passing stack, results in error")
    {
        SetLastError(NO_ERROR);

        int value;
        auto mod = reinterpret_cast<HMODULE>(&value);

        auto size = DetourGetSizeOfPayloads(mod);

        REQUIRE( GetLastError() == ERROR_BAD_EXE_FORMAT );
        REQUIRE( size == 0 );
    }

    SECTION("Corrupt image DOS header magic, results in bad exe format error")
    {
        ImageCorruptor corruptor(&__ImageBase);
        corruptor.ModifyDosMagic(0xDEAD);

        SetLastError(NO_ERROR);

        auto mod = reinterpret_cast<HMODULE>(&__ImageBase);
        auto size = DetourGetSizeOfPayloads(mod);

        REQUIRE( GetLastError() == ERROR_BAD_EXE_FORMAT );
        REQUIRE( size == 0 );
    }

    SECTION("Corrupt image NT header signature, results in invalid signature error")
    {
        ImageCorruptor corruptor(&__ImageBase);
        corruptor.ModifyNtSignature(0xDEADBEEF);

        SetLastError(NO_ERROR);

        auto mod = reinterpret_cast<HMODULE>(&__ImageBase);
        auto size = DetourGetSizeOfPayloads(mod);

        REQUIRE( GetLastError() == ERROR_INVALID_EXE_SIGNATURE );
        REQUIRE( size == 0 );
    }
}

TEST_CASE("DetourFindPayload", "[module]")
{
    SECTION("Passing empty guid, fails.")
    {
        SetLastError(NO_ERROR);

        HMODULE module {};
        GUID guid {};
        DWORD data {};

        auto payload = DetourFindPayload(module, guid, &data);

        REQUIRE( payload == nullptr );
        REQUIRE( data == 0 );
        REQUIRE( GetLastError() == ERROR_INVALID_HANDLE );
    }

    SECTION("Passing nullptr for module with correct GUID, is successful.")
    {
        SetLastError(ERROR_INVALID_HANDLE);

        HMODULE module {};
        DWORD data {};

        auto payload = DetourFindPayload(module, TEST_PAYLOAD_GUID, &data);

        REQUIRE( GetLastError() == NO_ERROR );
        REQUIRE( payload != nullptr );
        REQUIRE( data == TEST_PAYLOAD_SIZE );

        char* szPayloadMessage = reinterpret_cast<char*>(payload);
        REQUIRE_THAT( szPayloadMessage, Catch::Matchers::Contains("123") );
    }
}

TEST_CASE("DetourFindPayloadEx", "[module]")
{
    SECTION("Passing empty guid, fails.")
    {
        SetLastError(NO_ERROR);

        GUID guid {};
        DWORD data {};
        auto payload = DetourFindPayloadEx(guid, &data);

        REQUIRE( payload == nullptr );
        REQUIRE( data == 0 );

        // This returns different values on different versions of windows.
        //
        REQUIRE( (GetLastError() == ERROR_MOD_NOT_FOUND || GetLastError() == ERROR_INVALID_HANDLE) );
    }

    SECTION("Finding module with correct GUID, is successful.")
    {
        SetLastError(ERROR_INVALID_HANDLE);

        DWORD data {};
        auto payload = DetourFindPayloadEx(TEST_PAYLOAD_GUID, &data);

        REQUIRE( GetLastError() == NO_ERROR );
        REQUIRE( payload != nullptr );
        REQUIRE( data == TEST_PAYLOAD_SIZE );

        char* szPayloadMessage = reinterpret_cast<char*>(payload);
        REQUIRE_THAT( szPayloadMessage, Catch::Matchers::Contains("123") );
    }
}

TEST_CASE("DetourCopyPayloadToProcessEx", "[module]")
{
    // {44FA1CE0-1DA5-4AFC-946E-F96890C38673}
    static constexpr GUID guid = { 0x44fa1ce0, 0x1da5, 0x4afc, { 0x94, 0x6e, 0xf9, 0x68, 0x90, 0xc3, 0x86, 0x73 } };
    static constexpr std::uint32_t data = 0xDEADBEEF;

    SECTION("Passing NULL process handle, results in error")
    {
        const auto ptr = DetourCopyPayloadToProcessEx(NULL, guid, &data, sizeof(data));
        REQUIRE(GetLastError() == ERROR_INVALID_HANDLE);
        REQUIRE(ptr == nullptr);
    }

    SECTION("Writing to own process, results in valid pointer")
    {
        const auto ptr = reinterpret_cast<std::uint32_t*>(DetourCopyPayloadToProcessEx(GetCurrentProcess(), guid, &data, sizeof(data)));
        REQUIRE(GetLastError() == NO_ERROR);
        REQUIRE(*ptr == data);
    }

    SECTION("Writing to different process, can be read with ReadProcessMemory")
    {
        // create a suspended copy of ourself to do things with.
        TerminateOnScopeExit process{};
        REQUIRE(SUCCEEDED(CreateSuspendedCopy(process)));

        const auto ptr = DetourCopyPayloadToProcessEx(process.information.hProcess, guid, &data, sizeof(data));
        REQUIRE(GetLastError() == NO_ERROR);
        REQUIRE(ptr != nullptr);

        std::uint32_t retrieved_data{};
        REQUIRE(ReadProcessMemory(process.information.hProcess, ptr, &retrieved_data, sizeof(retrieved_data), nullptr));
        REQUIRE(retrieved_data == data);
    }
}

TEST_CASE("DetourFindRemotePayload", "[module]")
{
    SECTION("Passing NULL process handle, results in error")
    {
        const auto ptr = DetourFindRemotePayload(NULL, TEST_PAYLOAD_GUID, nullptr);
        REQUIRE(GetLastError() == ERROR_INVALID_HANDLE);
        REQUIRE(ptr == nullptr);
    }

    SECTION("Finding null GUID from own process, results in error")
    {
        const GUID guid{};

        const auto ptr = DetourFindRemotePayload(GetCurrentProcess(), guid, nullptr);
        REQUIRE(GetLastError() == ERROR_MOD_NOT_FOUND);
        REQUIRE(ptr == nullptr);
    }

    SECTION("Finding null GUID from different process, results in error")
    {
        // create a suspended copy of ourself to do things with.
        TerminateOnScopeExit process{};
        REQUIRE(SUCCEEDED(CreateSuspendedCopy(process)));

        const GUID guid{};
        const auto ptr = DetourFindRemotePayload(process.information.hProcess, guid, nullptr);
        REQUIRE(GetLastError() == ERROR_MOD_NOT_FOUND);
        REQUIRE(ptr == nullptr);
    }

    SECTION("Finding valid GUID from own process, results in valid pointer")
    {
        DWORD size = 0;
        const auto ptr = reinterpret_cast<std::uint32_t*>(DetourFindRemotePayload(GetCurrentProcess(), TEST_PAYLOAD_GUID, &size));
        REQUIRE(GetLastError() == NO_ERROR);
        REQUIRE(ptr != nullptr);
        REQUIRE(size == TEST_PAYLOAD_SIZE);

        char* szPayloadMessage = reinterpret_cast<char*>(ptr);
        REQUIRE_THAT(szPayloadMessage, Catch::Matchers::Contains("123"));
    }

    SECTION("Finding valid GUID from different process, can be read with ReadProcessMemory")
    {
        // create a suspended copy of ourself to do things with.
        TerminateOnScopeExit process{};
        REQUIRE(SUCCEEDED(CreateSuspendedCopy(process)));

        DWORD size = 0;
        const auto ptr = DetourFindRemotePayload(process.information.hProcess, TEST_PAYLOAD_GUID, &size);
        REQUIRE(GetLastError() == NO_ERROR);
        REQUIRE(ptr != nullptr);
        REQUIRE(size == TEST_PAYLOAD_SIZE);

        SIZE_T bytesRead = 0;
        char szPayloadMessage[TEST_PAYLOAD_SIZE];
        REQUIRE(ReadProcessMemory(process.information.hProcess, ptr, &szPayloadMessage, TEST_PAYLOAD_SIZE, &bytesRead));
        REQUIRE(bytesRead == TEST_PAYLOAD_SIZE);
        REQUIRE_THAT(szPayloadMessage, Catch::Matchers::Contains("123"));
    }
}

TEST_CASE("DetourRestoreAfterWith", "[module]")
{
    // TODO: Needs to be written.
}

TEST_CASE("DetourRestoreAfterWithEx", "[module]")
{
    // TODO: Needs to be written.
}



```

`vc/Detours.sln`:

```sln

Microsoft Visual Studio Solution File, Format Version 12.00
# Visual Studio Version 16
VisualStudioVersion = 16.0.29519.181
MinimumVisualStudioVersion = 10.0.40219.1
Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "Detours", "Detours.vcxproj", "{37489709-8054-4903-9C49-A79846049FC9}"
EndProject
Global
	GlobalSection(SolutionConfigurationPlatforms) = preSolution
		DebugMDd|ARM = DebugMDd|ARM
		DebugMDd|ARM64 = DebugMDd|ARM64
		DebugMDd|x64 = DebugMDd|x64
		DebugMDd|x86 = DebugMDd|x86
		ReleaseMD|ARM = ReleaseMD|ARM
		ReleaseMD|ARM64 = ReleaseMD|ARM64
		ReleaseMD|x64 = ReleaseMD|x64
		ReleaseMD|x86 = ReleaseMD|x86
	EndGlobalSection
	GlobalSection(ProjectConfigurationPlatforms) = postSolution
		{37489709-8054-4903-9C49-A79846049FC9}.DebugMDd|ARM.ActiveCfg = DebugMDd|ARM
		{37489709-8054-4903-9C49-A79846049FC9}.DebugMDd|ARM.Build.0 = DebugMDd|ARM
		{37489709-8054-4903-9C49-A79846049FC9}.DebugMDd|ARM64.ActiveCfg = DebugMDd|ARM64
		{37489709-8054-4903-9C49-A79846049FC9}.DebugMDd|ARM64.Build.0 = DebugMDd|ARM64
		{37489709-8054-4903-9C49-A79846049FC9}.DebugMDd|x64.ActiveCfg = DebugMDd|x64
		{37489709-8054-4903-9C49-A79846049FC9}.DebugMDd|x64.Build.0 = DebugMDd|x64
		{37489709-8054-4903-9C49-A79846049FC9}.DebugMDd|x86.ActiveCfg = DebugMDd|Win32
		{37489709-8054-4903-9C49-A79846049FC9}.DebugMDd|x86.Build.0 = DebugMDd|Win32
		{37489709-8054-4903-9C49-A79846049FC9}.ReleaseMD|ARM.ActiveCfg = ReleaseMD|ARM
		{37489709-8054-4903-9C49-A79846049FC9}.ReleaseMD|ARM.Build.0 = ReleaseMD|ARM
		{37489709-8054-4903-9C49-A79846049FC9}.ReleaseMD|ARM64.ActiveCfg = ReleaseMD|ARM64
		{37489709-8054-4903-9C49-A79846049FC9}.ReleaseMD|ARM64.Build.0 = ReleaseMD|ARM64
		{37489709-8054-4903-9C49-A79846049FC9}.ReleaseMD|x64.ActiveCfg = ReleaseMD|x64
		{37489709-8054-4903-9C49-A79846049FC9}.ReleaseMD|x64.Build.0 = ReleaseMD|x64
		{37489709-8054-4903-9C49-A79846049FC9}.ReleaseMD|x86.ActiveCfg = ReleaseMD|Win32
		{37489709-8054-4903-9C49-A79846049FC9}.ReleaseMD|x86.Build.0 = ReleaseMD|Win32
	EndGlobalSection
	GlobalSection(SolutionProperties) = preSolution
		HideSolutionNode = FALSE
	EndGlobalSection
	GlobalSection(ExtensibilityGlobals) = postSolution
		SolutionGuid = {1E71C644-7F30-4025-B1DF-6A4F07A2EDB3}
	EndGlobalSection
EndGlobal

```

`vc/Detours.vcxproj`:

```vcxproj
<?xml version="1.0" encoding="utf-8"?>
<Project DefaultTargets="Build" ToolsVersion="15.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup Label="ProjectConfigurations">
    <ProjectConfiguration Include="DebugMDd|ARM">
      <Configuration>DebugMDd</Configuration>
      <Platform>ARM</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="DebugMDd|ARM64">
      <Configuration>DebugMDd</Configuration>
      <Platform>ARM64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="DebugMDd|Win32">
      <Configuration>DebugMDd</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="ReleaseMD|ARM">
      <Configuration>ReleaseMD</Configuration>
      <Platform>ARM</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="ReleaseMD|ARM64">
      <Configuration>ReleaseMD</Configuration>
      <Platform>ARM64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="ReleaseMD|Win32">
      <Configuration>ReleaseMD</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="DebugMDd|x64">
      <Configuration>DebugMDd</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="ReleaseMD|x64">
      <Configuration>ReleaseMD</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
  </ItemGroup>
  <PropertyGroup Label="Globals">
    <VCProjectVersion>15.0</VCProjectVersion>
    <ProjectGuid>{37489709-8054-4903-9C49-A79846049FC9}</ProjectGuid>
    <Keyword>Win32Proj</Keyword>
    <RootNamespace>Detours</RootNamespace>
    <WindowsTargetPlatformVersion>10.0</WindowsTargetPlatformVersion>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='DebugMDd|Win32'" Label="Configuration">
    <ConfigurationType>Makefile</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v142</PlatformToolset>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='ReleaseMD|Win32'" Label="Configuration">
    <ConfigurationType>Makefile</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v142</PlatformToolset>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='DebugMDd|x64'" Label="Configuration">
    <ConfigurationType>Makefile</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v142</PlatformToolset>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='DebugMDd|ARM'" Label="Configuration">
    <ConfigurationType>Makefile</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v142</PlatformToolset>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='DebugMDd|ARM64'" Label="Configuration">
    <ConfigurationType>Makefile</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v142</PlatformToolset>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='ReleaseMD|x64'" Label="Configuration">
    <ConfigurationType>Makefile</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v142</PlatformToolset>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='ReleaseMD|ARM'" Label="Configuration">
    <ConfigurationType>Makefile</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v142</PlatformToolset>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='ReleaseMD|ARM64'" Label="Configuration">
    <ConfigurationType>Makefile</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v142</PlatformToolset>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
  <ImportGroup Label="ExtensionSettings">
  </ImportGroup>
  <ImportGroup Label="Shared">
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='DebugMDd|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='ReleaseMD|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='DebugMDd|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='DebugMDd|ARM'" Label="PropertySheets">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='DebugMDd|ARM64'" Label="PropertySheets">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='ReleaseMD|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='ReleaseMD|ARM'" Label="PropertySheets">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='ReleaseMD|ARM64'" Label="PropertySheets">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='DebugMDd|x64'">
    <NMakeBuildCommandLine>SET DETOURS_TARGET_PROCESSOR=$(PlatformTarget)
cd ..
nmake</NMakeBuildCommandLine>
    <NMakeReBuildCommandLine>SET DETOURS_TARGET_PROCESSOR=$(PlatformTarget)
cd ..
nmake clean
nmake</NMakeReBuildCommandLine>
    <NMakeCleanCommandLine>SET DETOURS_TARGET_PROCESSOR=$(PlatformTarget)
cd ..
nmake clean</NMakeCleanCommandLine>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='DebugMDd|ARM'">
    <NMakeBuildCommandLine>SET DETOURS_TARGET_PROCESSOR=$(PlatformTarget)
cd ..
nmake</NMakeBuildCommandLine>
    <NMakeReBuildCommandLine>SET DETOURS_TARGET_PROCESSOR=$(PlatformTarget)
cd ..
nmake clean
nmake</NMakeReBuildCommandLine>
    <NMakeCleanCommandLine>SET DETOURS_TARGET_PROCESSOR=$(PlatformTarget)
cd ..
nmake clean</NMakeCleanCommandLine>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='DebugMDd|ARM64'">
    <NMakeBuildCommandLine>SET DETOURS_TARGET_PROCESSOR=$(PlatformTarget)
cd ..
nmake</NMakeBuildCommandLine>
    <NMakeReBuildCommandLine>SET DETOURS_TARGET_PROCESSOR=$(PlatformTarget)
cd ..
nmake clean
nmake</NMakeReBuildCommandLine>
    <NMakeCleanCommandLine>SET DETOURS_TARGET_PROCESSOR=$(PlatformTarget)
cd ..
nmake clean</NMakeCleanCommandLine>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='ReleaseMD|x64'">
    <NMakeBuildCommandLine>SET DETOURS_TARGET_PROCESSOR=$(PlatformTarget)
cd ..
nmake</NMakeBuildCommandLine>
    <NMakeReBuildCommandLine>SET DETOURS_TARGET_PROCESSOR=$(PlatformTarget)
cd ..
nmake clean
nmake</NMakeReBuildCommandLine>
    <NMakeCleanCommandLine>SET DETOURS_TARGET_PROCESSOR=$(PlatformTarget)
cd ..
nmake clean</NMakeCleanCommandLine>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='ReleaseMD|ARM'">
    <NMakeBuildCommandLine>SET DETOURS_TARGET_PROCESSOR=$(PlatformTarget)
cd ..
nmake</NMakeBuildCommandLine>
    <NMakeReBuildCommandLine>SET DETOURS_TARGET_PROCESSOR=$(PlatformTarget)
cd ..
nmake clean
nmake</NMakeReBuildCommandLine>
    <NMakeCleanCommandLine>SET DETOURS_TARGET_PROCESSOR=$(PlatformTarget)
cd ..
nmake clean</NMakeCleanCommandLine>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='DebugMDd|Win32'">
    <NMakeBuildCommandLine>SET DETOURS_TARGET_PROCESSOR=$(PlatformTarget)
cd ..
nmake</NMakeBuildCommandLine>
    <NMakeReBuildCommandLine>SET DETOURS_TARGET_PROCESSOR=$(PlatformTarget)
cd ..
nmake clean
nmake</NMakeReBuildCommandLine>
    <NMakeCleanCommandLine>SET DETOURS_TARGET_PROCESSOR=$(PlatformTarget)
cd ..
nmake clean</NMakeCleanCommandLine>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='ReleaseMD|Win32'">
    <NMakeBuildCommandLine>SET DETOURS_TARGET_PROCESSOR=$(PlatformTarget)
cd ..
nmake</NMakeBuildCommandLine>
    <NMakeReBuildCommandLine>SET DETOURS_TARGET_PROCESSOR=$(PlatformTarget)
cd ..
nmake clean
nmake</NMakeReBuildCommandLine>
    <NMakeCleanCommandLine>SET DETOURS_TARGET_PROCESSOR=$(PlatformTarget)
cd ..
nmake clean</NMakeCleanCommandLine>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='ReleaseMD|ARM64'">
    <NMakeBuildCommandLine>SET DETOURS_TARGET_PROCESSOR=$(PlatformTarget)
cd ..
nmake</NMakeBuildCommandLine>
    <NMakeReBuildCommandLine>SET DETOURS_TARGET_PROCESSOR=$(PlatformTarget)
cd ..
nmake clean
nmake</NMakeReBuildCommandLine>
    <NMakeCleanCommandLine>SET DETOURS_TARGET_PROCESSOR=$(PlatformTarget)
cd ..
nmake clean</NMakeCleanCommandLine>
  </PropertyGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='DebugMDd|Win32'">
    <ClCompile>
      <WarningLevel>Level4</WarningLevel>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>WIN32;_DEBUG;_LIB;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <TreatWarningAsError>true</TreatWarningAsError>
      <ConformanceMode>true</ConformanceMode>
      <DebugInformationFormat>ProgramDatabase</DebugInformationFormat>
      <ProgramDataBaseFileName>$(OutputPath)$(TargetName).pdb</ProgramDataBaseFileName>
    </ClCompile>
    <Link>
      <SubSystem>Windows</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
    </Link>
    <PostBuildEvent />
    <PreBuildEvent>
      <Command>SET DETOURS_TARGET_PROCESSOR=$(PlatformTarget)
cd ..
nmake</Command>
    </PreBuildEvent>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='DebugMDd|x64'">
    <ClCompile>
      <WarningLevel>Level4</WarningLevel>
      <Optimization>Disabled</Optimization>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>_DEBUG;_LIB;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <TreatWarningAsError>true</TreatWarningAsError>
      <ConformanceMode>true</ConformanceMode>
      <DebugInformationFormat>ProgramDatabase</DebugInformationFormat>
      <PrecompiledHeaderFile />
      <PrecompiledHeaderOutputFile />
      <ProgramDataBaseFileName>$(OutputPath)$(TargetName).pdb</ProgramDataBaseFileName>
    </ClCompile>
    <Link>
      <SubSystem>Windows</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
    </Link>
    <PostBuildEvent />
    <PreBuildEvent>
      <Command>SET DETOURS_TARGET_PROCESSOR=$(PlatformTarget)
cd ..
nmake</Command>
    </PreBuildEvent>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='DebugMDd|ARM'">
    <ClCompile>
      <WarningLevel>Level4</WarningLevel>
      <Optimization>Disabled</Optimization>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>_DEBUG;_LIB;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <TreatWarningAsError>true</TreatWarningAsError>
      <ConformanceMode>true</ConformanceMode>
      <DebugInformationFormat>ProgramDatabase</DebugInformationFormat>
      <PrecompiledHeaderFile>
      </PrecompiledHeaderFile>
      <PrecompiledHeaderOutputFile>
      </PrecompiledHeaderOutputFile>
      <ProgramDataBaseFileName>$(OutputPath)$(TargetName).pdb</ProgramDataBaseFileName>
    </ClCompile>
    <Link>
      <SubSystem>Windows</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
    </Link>
    <PostBuildEvent />
    <PreBuildEvent>
      <Command>SET DETOURS_TARGET_PROCESSOR=$(PlatformTarget)
cd ..
nmake</Command>
    </PreBuildEvent>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='DebugMDd|ARM64'">
    <ClCompile>
      <WarningLevel>Level4</WarningLevel>
      <Optimization>Disabled</Optimization>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>_DEBUG;_LIB;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <TreatWarningAsError>true</TreatWarningAsError>
      <ConformanceMode>true</ConformanceMode>
      <DebugInformationFormat>ProgramDatabase</DebugInformationFormat>
      <PrecompiledHeaderFile>
      </PrecompiledHeaderFile>
      <PrecompiledHeaderOutputFile>
      </PrecompiledHeaderOutputFile>
      <ProgramDataBaseFileName>$(OutputPath)$(TargetName).pdb</ProgramDataBaseFileName>
    </ClCompile>
    <Link>
      <SubSystem>Windows</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
    </Link>
    <PostBuildEvent />
    <PreBuildEvent>
      <Command>SET DETOURS_TARGET_PROCESSOR=$(PlatformTarget)
cd ..
nmake</Command>
    </PreBuildEvent>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='ReleaseMD|Win32'">
    <ClCompile>
      <WarningLevel>Level4</WarningLevel>
      <Optimization>MaxSpeed</Optimization>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>WIN32;NDEBUG;_LIB;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <TreatWarningAsError>true</TreatWarningAsError>
      <ConformanceMode>true</ConformanceMode>
      <ProgramDataBaseFileName>$(OutputPath)$(TargetName).pdb</ProgramDataBaseFileName>
    </ClCompile>
    <Link>
      <SubSystem>Windows</SubSystem>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <GenerateDebugInformation>true</GenerateDebugInformation>
    </Link>
    <PostBuildEvent />
    <PreBuildEvent>
      <Command>SET DETOURS_TARGET_PROCESSOR=$(PlatformTarget)
cd ..
nmake</Command>
    </PreBuildEvent>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='ReleaseMD|x64'">
    <ClCompile>
      <WarningLevel>Level4</WarningLevel>
      <Optimization>MaxSpeed</Optimization>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>NDEBUG;_LIB;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <TreatWarningAsError>true</TreatWarningAsError>
      <ConformanceMode>true</ConformanceMode>
      <PrecompiledHeaderFile />
      <PrecompiledHeaderOutputFile />
      <ProgramDataBaseFileName>$(OutputPath)$(TargetName).pdb</ProgramDataBaseFileName>
    </ClCompile>
    <Link>
      <SubSystem>Windows</SubSystem>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <GenerateDebugInformation>true</GenerateDebugInformation>
    </Link>
    <PostBuildEvent />
    <PreBuildEvent>
      <Command>SET DETOURS_TARGET_PROCESSOR=$(PlatformTarget)
cd ..
nmake</Command>
    </PreBuildEvent>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='ReleaseMD|ARM'">
    <ClCompile>
      <WarningLevel>Level4</WarningLevel>
      <Optimization>MaxSpeed</Optimization>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>NDEBUG;_LIB;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <TreatWarningAsError>true</TreatWarningAsError>
      <ConformanceMode>true</ConformanceMode>
      <PrecompiledHeaderFile>
      </PrecompiledHeaderFile>
      <PrecompiledHeaderOutputFile>
      </PrecompiledHeaderOutputFile>
      <ProgramDataBaseFileName>$(OutputPath)$(TargetName).pdb</ProgramDataBaseFileName>
    </ClCompile>
    <Link>
      <SubSystem>Windows</SubSystem>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <GenerateDebugInformation>true</GenerateDebugInformation>
    </Link>
    <PostBuildEvent />
    <PreBuildEvent>
      <Command>SET DETOURS_TARGET_PROCESSOR=$(PlatformTarget)
cd ..
nmake</Command>
    </PreBuildEvent>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='ReleaseMD|ARM64'">
    <ClCompile>
      <WarningLevel>Level4</WarningLevel>
      <Optimization>MaxSpeed</Optimization>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>NDEBUG;_LIB;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <TreatWarningAsError>true</TreatWarningAsError>
      <ConformanceMode>true</ConformanceMode>
      <PrecompiledHeaderFile>
      </PrecompiledHeaderFile>
      <PrecompiledHeaderOutputFile>
      </PrecompiledHeaderOutputFile>
      <ProgramDataBaseFileName>$(OutputPath)$(TargetName).pdb</ProgramDataBaseFileName>
    </ClCompile>
    <Link>
      <SubSystem>Windows</SubSystem>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <GenerateDebugInformation>true</GenerateDebugInformation>
    </Link>
    <PostBuildEvent />
    <PreBuildEvent>
      <Command>SET DETOURS_TARGET_PROCESSOR=$(PlatformTarget)
cd ..
nmake</Command>
    </PreBuildEvent>
  </ItemDefinitionGroup>
  <ItemGroup>
    <ClCompile Include="..\samples\comeasy\comeasy.cpp" />
    <ClCompile Include="..\samples\comeasy\wrotei.cpp" />
    <ClCompile Include="..\samples\commem\commem.cpp" />
    <ClCompile Include="..\samples\cping\cping.cpp" />
    <ClCompile Include="..\samples\disas\disas.cpp" />
    <ClCompile Include="..\samples\disas\unk.cpp" />
    <ClCompile Include="..\samples\disas\x86.cpp" />
    <ClCompile Include="..\samples\dtest\dtarge.cpp" />
    <ClCompile Include="..\samples\dtest\dtest.cpp" />
    <ClCompile Include="..\samples\dumpe\dumpe.cpp" />
    <ClCompile Include="..\samples\dumpi\dumpi.cpp" />
    <ClCompile Include="..\samples\dynamic_alloc\main.cpp" />
    <ClCompile Include="..\samples\echo\echofx.cpp" />
    <ClCompile Include="..\samples\echo\echonul.cpp" />
    <ClCompile Include="..\samples\echo\main.cpp" />
    <ClCompile Include="..\samples\einst\edll1x.cpp" />
    <ClCompile Include="..\samples\einst\edll2x.cpp" />
    <ClCompile Include="..\samples\einst\edll3x.cpp" />
    <ClCompile Include="..\samples\einst\einst.cpp" />
    <ClCompile Include="..\samples\excep\excep.cpp" />
    <ClCompile Include="..\samples\excep\firstexc.cpp" />
    <ClCompile Include="..\samples\findfunc\extend.cpp" />
    <ClCompile Include="..\samples\findfunc\findfunc.cpp" />
    <ClCompile Include="..\samples\findfunc\symtest.cpp" />
    <ClCompile Include="..\samples\findfunc\target.cpp" />
    <ClCompile Include="..\samples\impmunge\impmunge.cpp" />
    <ClCompile Include="..\samples\member\member.cpp" />
    <ClCompile Include="..\samples\opengl\ogldet.cpp" />
    <ClCompile Include="..\samples\opengl\testogl.cpp" />
    <ClCompile Include="..\samples\region\region.cpp" />
    <ClCompile Include="..\samples\setdll\setdll.cpp" />
    <ClCompile Include="..\samples\simple\simple.cpp" />
    <ClCompile Include="..\samples\simple\sleep5.cpp" />
    <ClCompile Include="..\samples\simple_safe\simple_safe.cpp" />
    <ClCompile Include="..\samples\simple_safe\sleep5.cpp" />
    <ClCompile Include="..\samples\slept\dslept.cpp" />
    <ClCompile Include="..\samples\slept\sleepbed.cpp" />
    <ClCompile Include="..\samples\slept\sleepnew.cpp" />
    <ClCompile Include="..\samples\slept\sleepold.cpp" />
    <ClCompile Include="..\samples\slept\slept.cpp" />
    <ClCompile Include="..\samples\slept\verify.cpp" />
    <ClCompile Include="..\samples\syelog\sltest.cpp" />
    <ClCompile Include="..\samples\syelog\sltestp.cpp" />
    <ClCompile Include="..\samples\syelog\syelog.cpp" />
    <ClCompile Include="..\samples\syelog\syelogd.cpp" />
    <ClCompile Include="..\samples\talloc\talloc.cpp" />
    <ClCompile Include="..\samples\talloc\tdll1x.cpp" />
    <ClCompile Include="..\samples\talloc\tdll2x.cpp" />
    <ClCompile Include="..\samples\talloc\tdll3x.cpp" />
    <ClCompile Include="..\samples\talloc\tdll4x.cpp" />
    <ClCompile Include="..\samples\talloc\tdll5x.cpp" />
    <ClCompile Include="..\samples\talloc\tdll6x.cpp" />
    <ClCompile Include="..\samples\talloc\tdll7x.cpp" />
    <ClCompile Include="..\samples\talloc\tdll8x.cpp" />
    <ClCompile Include="..\samples\talloc\tdll9x.cpp" />
    <ClCompile Include="..\samples\traceapi\testapi.cpp" />
    <ClCompile Include="..\samples\traceapi\trcapi.cpp" />
    <ClCompile Include="..\samples\traceapi\_win32.cpp" />
    <ClCompile Include="..\samples\tracebld\tracebld.cpp" />
    <ClCompile Include="..\samples\tracebld\trcbld.cpp" />
    <ClCompile Include="..\samples\tracelnk\trclnk.cpp" />
    <ClCompile Include="..\samples\tracemem\trcmem.cpp" />
    <ClCompile Include="..\samples\tracereg\trcreg.cpp" />
    <ClCompile Include="..\samples\traceser\trcser.cpp" />
    <ClCompile Include="..\samples\tracessl\trcssl.cpp" />
    <ClCompile Include="..\samples\tracetcp\trctcp.cpp" />
    <ClCompile Include="..\samples\tryman\size.cpp" />
    <ClCompile Include="..\samples\tryman\tryman.cpp" />
    <ClCompile Include="..\samples\tryman\tstman.cpp" />
    <ClCompile Include="..\samples\withdll\withdll.cpp" />
    <ClCompile Include="..\src\creatwth.cpp" />
    <ClCompile Include="..\src\detours.cpp" />
    <ClCompile Include="..\src\disasm.cpp" />
    <ClCompile Include="..\src\disolarm.cpp" />
    <ClCompile Include="..\src\disolarm64.cpp" />
    <ClCompile Include="..\src\disolia64.cpp" />
    <ClCompile Include="..\src\disolx64.cpp" />
    <ClCompile Include="..\src\disolx86.cpp" />
    <ClCompile Include="..\src\image.cpp" />
    <ClCompile Include="..\src\modules.cpp" />
    <ClCompile Include="..\src\uimports.cpp">
      <ExcludedFromBuild>true</ExcludedFromBuild>
    </ClCompile>
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="..\samples\dtest\dtarge.h" />
    <ClInclude Include="..\samples\excep\firstexc.h" />
    <ClInclude Include="..\samples\findfunc\target.h" />
    <ClInclude Include="..\samples\slept\slept.h" />
    <ClInclude Include="..\samples\syelog\syelog.h" />
    <ClInclude Include="..\samples\tracebld\tracebld.h" />
    <ClInclude Include="..\src\detours.h" />
    <ClInclude Include="..\src\detver.h" />
  </ItemGroup>
  <ItemGroup>
    <None Include="..\.gitignore" />
    <None Include="..\LICENSE.md" />
    <None Include="..\Makefile" />
    <None Include="..\README.md" />
    <None Include="..\samples\comeasy\Makefile" />
    <None Include="..\samples\commem\Makefile" />
    <None Include="..\samples\common.mak" />
    <None Include="..\samples\cping\cping.dat" />
    <None Include="..\samples\cping\Makefile" />
    <None Include="..\samples\disas\arm.asm" />
    <None Include="..\samples\disas\ia64.asm" />
    <None Include="..\samples\disas\Makefile" />
    <None Include="..\samples\disas\x64.asm" />
    <None Include="..\samples\dtest\Makefile" />
    <None Include="..\samples\dumpe\Makefile" />
    <None Include="..\samples\dumpi\Makefile" />
    <None Include="..\samples\dynamic_alloc\Makefile" />
    <None Include="..\samples\dynamic_alloc\x64.asm" />
    <None Include="..\samples\dynamic_alloc\x86.asm" />
    <None Include="..\samples\echo\Makefile" />
    <None Include="..\samples\einst\Makefile" />
    <None Include="..\samples\excep\Makefile" />
    <None Include="..\samples\findfunc\Makefile" />
    <None Include="..\samples\impmunge\Makefile" />
    <None Include="..\samples\Makefile" />
    <None Include="..\samples\member\Makefile" />
    <None Include="..\samples\opengl\Makefile" />
    <None Include="..\samples\region\Makefile" />
    <None Include="..\samples\setdll\Makefile" />
    <None Include="..\samples\simple\Makefile" />
    <None Include="..\samples\simple_safe\Makefile" />
    <None Include="..\samples\slept\Makefile" />
    <None Include="..\samples\syelog\Makefile" />
    <None Include="..\samples\talloc\Makefile" />
    <None Include="..\samples\traceapi\Makefile" />
    <None Include="..\samples\tracebld\Makefile" />
    <None Include="..\samples\tracelnk\Makefile" />
    <None Include="..\samples\tracemem\Makefile" />
    <None Include="..\samples\tracereg\Makefile" />
    <None Include="..\samples\traceser\Makefile" />
    <None Include="..\samples\tracessl\Makefile" />
    <None Include="..\samples\tracetcp\Makefile" />
    <None Include="..\samples\tryman\Makefile" />
    <None Include="..\samples\tryman\managed.cs" />
    <None Include="..\samples\withdll\Makefile" />
    <None Include="..\system.mak" />
  </ItemGroup>
  <ItemGroup>
    <Text Include="..\CREDITS.md" />
    <Text Include="..\samples\cping\ReadMe.Txt" />
    <Text Include="..\samples\dtest\NORMAL_IA64.TXT" />
    <Text Include="..\samples\dtest\NORMAL_X64.TXT" />
    <Text Include="..\samples\dtest\NORMAL_X86.TXT" />
    <Text Include="..\samples\README.TXT" />
    <Text Include="..\samples\slept\NORMAL_IA64.TXT" />
    <Text Include="..\samples\slept\NORMAL_X64.TXT" />
    <Text Include="..\samples\slept\NORMAL_X86.TXT" />
    <Text Include="..\samples\talloc\NORMAL_IA64.TXT" />
    <Text Include="..\samples\talloc\NORMAL_X64.TXT" />
  </ItemGroup>
  <ItemGroup>
    <ResourceCompile Include="..\samples\comeasy\wrotei.rc" />
    <ResourceCompile Include="..\samples\dtest\dtarge.rc" />
    <ResourceCompile Include="..\samples\echo\echofx.rc" />
    <ResourceCompile Include="..\samples\findfunc\extend.rc" />
    <ResourceCompile Include="..\samples\findfunc\target.rc" />
    <ResourceCompile Include="..\samples\opengl\ogldet.rc" />
    <ResourceCompile Include="..\samples\simple\simple.rc" />
    <ResourceCompile Include="..\samples\simple_safe\simple_safe.rc" />
    <ResourceCompile Include="..\samples\slept\dslept.rc" />
    <ResourceCompile Include="..\samples\slept\slept.rc" />
    <ResourceCompile Include="..\samples\traceapi\trcapi.rc" />
    <ResourceCompile Include="..\samples\tracebld\trcbld.rc" />
    <ResourceCompile Include="..\samples\tracelnk\trclnk.rc" />
    <ResourceCompile Include="..\samples\tracemem\trcmem.rc" />
    <ResourceCompile Include="..\samples\tracereg\trcreg.rc" />
    <ResourceCompile Include="..\samples\traceser\trcser.rc" />
    <ResourceCompile Include="..\samples\tracessl\trcssl.rc" />
    <ResourceCompile Include="..\samples\tracetcp\trctcp.rc" />
    <ResourceCompile Include="..\samples\tryman\tstman.rc" />
  </ItemGroup>
  <ItemGroup>
    <Midl Include="..\samples\cping\iping.idl" />
  </ItemGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
  <ImportGroup Label="ExtensionTargets">
  </ImportGroup>
</Project>

```

`vc/Detours.vcxproj.filters`:

```filters
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup>
    <Filter Include="samples">
      <UniqueIdentifier>{4DE3849F-647A-48FF-8873-256D44DFF3CA}</UniqueIdentifier>
    </Filter>
    <Filter Include="samples\comeasy">
      <UniqueIdentifier>{6215A674-4251-4F64-AA56-6F80297E5F8B}</UniqueIdentifier>
    </Filter>
    <Filter Include="samples\commem">
      <UniqueIdentifier>{B581B77F-AE4D-43BC-8C4F-EDE0E61EFFD3}</UniqueIdentifier>
    </Filter>
    <Filter Include="samples\cping">
      <UniqueIdentifier>{BF2ACC0E-890D-4BD0-B532-6228AF011E3E}</UniqueIdentifier>
    </Filter>
    <Filter Include="samples\disas">
      <UniqueIdentifier>{32F50667-320C-4799-B7DA-D1878C358D64}</UniqueIdentifier>
    </Filter>
    <Filter Include="samples\dtest">
      <UniqueIdentifier>{314C251E-4D8E-4837-9C36-4741399ED2A1}</UniqueIdentifier>
    </Filter>
    <Filter Include="samples\dumpe">
      <UniqueIdentifier>{53C9A890-D5AB-4FD1-B898-6107C0E676E7}</UniqueIdentifier>
    </Filter>
    <Filter Include="samples\dumpi">
      <UniqueIdentifier>{17467834-9161-4FB2-BBEF-E3233CBBC818}</UniqueIdentifier>
    </Filter>
    <Filter Include="samples\dynamic_alloc">
      <UniqueIdentifier>{5A3371DC-E827-47CC-901A-F3D91162EFB2}</UniqueIdentifier>
    </Filter>
    <Filter Include="samples\echo">
      <UniqueIdentifier>{A2B9B912-8C03-400F-B271-51EEB4CE6843}</UniqueIdentifier>
    </Filter>
    <Filter Include="samples\einst">
      <UniqueIdentifier>{571B99A3-B6D5-4838-B189-4A038B104B2A}</UniqueIdentifier>
    </Filter>
    <Filter Include="samples\excep">
      <UniqueIdentifier>{F1740406-C1BB-49C7-A602-9DDACBD4ABCA}</UniqueIdentifier>
    </Filter>
    <Filter Include="samples\findfunc">
      <UniqueIdentifier>{58CCECE5-A38B-4C56-8E3F-3E0722393F56}</UniqueIdentifier>
    </Filter>
    <Filter Include="samples\impmunge">
      <UniqueIdentifier>{B3E06AC8-3F78-43C8-B7AC-84546475F960}</UniqueIdentifier>
    </Filter>
    <Filter Include="samples\member">
      <UniqueIdentifier>{CD32F55E-60C5-4ED6-ACCC-4B43E6AC195D}</UniqueIdentifier>
    </Filter>
    <Filter Include="samples\opengl">
      <UniqueIdentifier>{1ABFBA92-4E60-481A-9007-8150D95E072F}</UniqueIdentifier>
    </Filter>
    <Filter Include="samples\region">
      <UniqueIdentifier>{0929821A-9C85-4D74-B969-865D6DA40D2A}</UniqueIdentifier>
    </Filter>
    <Filter Include="samples\setdll">
      <UniqueIdentifier>{9017F1FA-4DCB-44D1-854D-2F14358791F5}</UniqueIdentifier>
    </Filter>
    <Filter Include="samples\simple">
      <UniqueIdentifier>{D9D7E0B0-4E14-473F-AE28-B4A5AF4EB427}</UniqueIdentifier>
    </Filter>
    <Filter Include="samples\simple_safe">
      <UniqueIdentifier>{1F157B88-D9DA-41E3-9B18-FC5600777FB1}</UniqueIdentifier>
    </Filter>
    <Filter Include="samples\slept">
      <UniqueIdentifier>{88EFC740-5E28-484E-97FC-E7BBA6D36454}</UniqueIdentifier>
    </Filter>
    <Filter Include="samples\syelog">
      <UniqueIdentifier>{EA900A65-64CA-417B-8DE7-4174C9CB1E5A}</UniqueIdentifier>
    </Filter>
    <Filter Include="samples\talloc">
      <UniqueIdentifier>{7A1582F0-0A25-4A0E-B7E5-14F6E332BDFA}</UniqueIdentifier>
    </Filter>
    <Filter Include="samples\traceapi">
      <UniqueIdentifier>{B99E03FF-320A-4D13-BFB8-674E102E306D}</UniqueIdentifier>
    </Filter>
    <Filter Include="samples\tracebld">
      <UniqueIdentifier>{6169E241-5297-4B63-8D32-407D592EF103}</UniqueIdentifier>
    </Filter>
    <Filter Include="samples\tracelnk">
      <UniqueIdentifier>{EFD841EC-A8B1-4CD6-AC2D-0D286669BA3B}</UniqueIdentifier>
    </Filter>
    <Filter Include="samples\tracemem">
      <UniqueIdentifier>{14F0CAFF-0470-4D28-9083-3FD5656E7B27}</UniqueIdentifier>
    </Filter>
    <Filter Include="samples\tracereg">
      <UniqueIdentifier>{A3CE1454-F707-4A29-B389-2E762651CDD7}</UniqueIdentifier>
    </Filter>
    <Filter Include="samples\traceser">
      <UniqueIdentifier>{D3299D5A-9CE3-45E6-9784-4166606BA70B}</UniqueIdentifier>
    </Filter>
    <Filter Include="samples\tracessl">
      <UniqueIdentifier>{6E1471A7-7B40-4528-8210-64CFC4663258}</UniqueIdentifier>
    </Filter>
    <Filter Include="samples\tracetcp">
      <UniqueIdentifier>{62236214-1B41-4765-9D9D-1E313B4E5AB7}</UniqueIdentifier>
    </Filter>
    <Filter Include="samples\tryman">
      <UniqueIdentifier>{24AC6634-A8C9-430B-8D95-45DEB57070C9}</UniqueIdentifier>
    </Filter>
    <Filter Include="samples\withdll">
      <UniqueIdentifier>{077E7134-5AA3-4151-8313-88106FCBDAB3}</UniqueIdentifier>
    </Filter>
    <Filter Include="src">
      <UniqueIdentifier>{E980771B-0BA5-4B01-947A-B99D33E31E89}</UniqueIdentifier>
    </Filter>
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="..\src\uimports.cpp">
      <Filter>src</Filter>
    </ClCompile>
    <ClCompile Include="..\src\creatwth.cpp">
      <Filter>src</Filter>
    </ClCompile>
    <ClCompile Include="..\src\detours.cpp">
      <Filter>src</Filter>
    </ClCompile>
    <ClCompile Include="..\src\disasm.cpp">
      <Filter>src</Filter>
    </ClCompile>
    <ClCompile Include="..\src\disolarm.cpp">
      <Filter>src</Filter>
    </ClCompile>
    <ClCompile Include="..\src\disolarm64.cpp">
      <Filter>src</Filter>
    </ClCompile>
    <ClCompile Include="..\src\disolia64.cpp">
      <Filter>src</Filter>
    </ClCompile>
    <ClCompile Include="..\src\disolx64.cpp">
      <Filter>src</Filter>
    </ClCompile>
    <ClCompile Include="..\src\disolx86.cpp">
      <Filter>src</Filter>
    </ClCompile>
    <ClCompile Include="..\src\image.cpp">
      <Filter>src</Filter>
    </ClCompile>
    <ClCompile Include="..\src\modules.cpp">
      <Filter>src</Filter>
    </ClCompile>
    <ClCompile Include="..\samples\tryman\size.cpp">
      <Filter>samples\tryman</Filter>
    </ClCompile>
    <ClCompile Include="..\samples\tracebld\tracebld.cpp">
      <Filter>samples\tracebld</Filter>
    </ClCompile>
    <ClCompile Include="..\samples\tracebld\trcbld.cpp">
      <Filter>samples\tracebld</Filter>
    </ClCompile>
    <ClCompile Include="..\samples\tracelnk\trclnk.cpp">
      <Filter>samples\tracelnk</Filter>
    </ClCompile>
    <ClCompile Include="..\samples\tracemem\trcmem.cpp">
      <Filter>samples\tracemem</Filter>
    </ClCompile>
    <ClCompile Include="..\samples\tracereg\trcreg.cpp">
      <Filter>samples\tracereg</Filter>
    </ClCompile>
    <ClCompile Include="..\samples\traceser\trcser.cpp">
      <Filter>samples\traceser</Filter>
    </ClCompile>
    <ClCompile Include="..\samples\tracessl\trcssl.cpp">
      <Filter>samples\tracessl</Filter>
    </ClCompile>
    <ClCompile Include="..\samples\tracetcp\trctcp.cpp">
      <Filter>samples\tracetcp</Filter>
    </ClCompile>
    <ClCompile Include="..\samples\tryman\tryman.cpp">
      <Filter>samples\tryman</Filter>
    </ClCompile>
    <ClCompile Include="..\samples\tryman\tstman.cpp">
      <Filter>samples\tryman</Filter>
    </ClCompile>
    <ClCompile Include="..\samples\withdll\withdll.cpp">
      <Filter>samples\withdll</Filter>
    </ClCompile>
    <ClCompile Include="..\samples\traceapi\_win32.cpp">
      <Filter>samples\traceapi</Filter>
    </ClCompile>
    <ClCompile Include="..\samples\slept\dslept.cpp">
      <Filter>samples\slept</Filter>
    </ClCompile>
    <ClCompile Include="..\samples\simple\simple.cpp">
      <Filter>samples\simple</Filter>
    </ClCompile>
    <ClCompile Include="..\samples\simple\sleep5.cpp">
      <Filter>samples\simple</Filter>
    </ClCompile>
    <ClCompile Include="..\samples\simple_safe\simple_safe.cpp">
      <Filter>samples\simple_safe</Filter>
    </ClCompile>
    <ClCompile Include="..\samples\simple_safe\sleep5.cpp">
      <Filter>samples\simple_safe</Filter>
    </ClCompile>
    <ClCompile Include="..\samples\slept\sleepbed.cpp">
      <Filter>samples\slept</Filter>
    </ClCompile>
    <ClCompile Include="..\samples\slept\sleepnew.cpp">
      <Filter>samples\slept</Filter>
    </ClCompile>
    <ClCompile Include="..\samples\slept\sleepold.cpp">
      <Filter>samples\slept</Filter>
    </ClCompile>
    <ClCompile Include="..\samples\slept\slept.cpp">
      <Filter>samples\slept</Filter>
    </ClCompile>
    <ClCompile Include="..\samples\syelog\sltest.cpp">
      <Filter>samples\syelog</Filter>
    </ClCompile>
    <ClCompile Include="..\samples\syelog\sltestp.cpp">
      <Filter>samples\syelog</Filter>
    </ClCompile>
    <ClCompile Include="..\samples\syelog\syelog.cpp">
      <Filter>samples\syelog</Filter>
    </ClCompile>
    <ClCompile Include="..\samples\syelog\syelogd.cpp">
      <Filter>samples\syelog</Filter>
    </ClCompile>
    <ClCompile Include="..\samples\talloc\talloc.cpp">
      <Filter>samples\talloc</Filter>
    </ClCompile>
    <ClCompile Include="..\samples\talloc\tdll1x.cpp">
      <Filter>samples\talloc</Filter>
    </ClCompile>
    <ClCompile Include="..\samples\talloc\tdll2x.cpp">
      <Filter>samples\talloc</Filter>
    </ClCompile>
    <ClCompile Include="..\samples\talloc\tdll3x.cpp">
      <Filter>samples\talloc</Filter>
    </ClCompile>
    <ClCompile Include="..\samples\talloc\tdll4x.cpp">
      <Filter>samples\talloc</Filter>
    </ClCompile>
    <ClCompile Include="..\samples\talloc\tdll5x.cpp">
      <Filter>samples\talloc</Filter>
    </ClCompile>
    <ClCompile Include="..\samples\talloc\tdll6x.cpp">
      <Filter>samples\talloc</Filter>
    </ClCompile>
    <ClCompile Include="..\samples\talloc\tdll7x.cpp">
      <Filter>samples\talloc</Filter>
    </ClCompile>
    <ClCompile Include="..\samples\talloc\tdll8x.cpp">
      <Filter>samples\talloc</Filter>
    </ClCompile>
    <ClCompile Include="..\samples\talloc\tdll9x.cpp">
      <Filter>samples\talloc</Filter>
    </ClCompile>
    <ClCompile Include="..\samples\traceapi\testapi.cpp">
      <Filter>samples\traceapi</Filter>
    </ClCompile>
    <ClCompile Include="..\samples\traceapi\trcapi.cpp">
      <Filter>samples\traceapi</Filter>
    </ClCompile>
    <ClCompile Include="..\samples\slept\verify.cpp">
      <Filter>samples\slept</Filter>
    </ClCompile>
    <ClCompile Include="..\samples\dtest\dtarge.cpp">
      <Filter>samples\dtest</Filter>
    </ClCompile>
    <ClCompile Include="..\samples\dtest\dtest.cpp">
      <Filter>samples\dtest</Filter>
    </ClCompile>
    <ClCompile Include="..\samples\dumpe\dumpe.cpp">
      <Filter>samples\dumpe</Filter>
    </ClCompile>
    <ClCompile Include="..\samples\dumpi\dumpi.cpp">
      <Filter>samples\dumpi</Filter>
    </ClCompile>
    <ClCompile Include="..\samples\echo\echofx.cpp">
      <Filter>samples\echo</Filter>
    </ClCompile>
    <ClCompile Include="..\samples\echo\echonul.cpp">
      <Filter>samples\echo</Filter>
    </ClCompile>
    <ClCompile Include="..\samples\einst\edll1x.cpp">
      <Filter>samples\einst</Filter>
    </ClCompile>
    <ClCompile Include="..\samples\einst\edll2x.cpp">
      <Filter>samples\einst</Filter>
    </ClCompile>
    <ClCompile Include="..\samples\einst\edll3x.cpp">
      <Filter>samples\einst</Filter>
    </ClCompile>
    <ClCompile Include="..\samples\einst\einst.cpp">
      <Filter>samples\einst</Filter>
    </ClCompile>
    <ClCompile Include="..\samples\excep\excep.cpp">
      <Filter>samples\excep</Filter>
    </ClCompile>
    <ClCompile Include="..\samples\findfunc\extend.cpp">
      <Filter>samples\findfunc</Filter>
    </ClCompile>
    <ClCompile Include="..\samples\findfunc\findfunc.cpp">
      <Filter>samples\findfunc</Filter>
    </ClCompile>
    <ClCompile Include="..\samples\excep\firstexc.cpp">
      <Filter>samples\excep</Filter>
    </ClCompile>
    <ClCompile Include="..\samples\impmunge\impmunge.cpp">
      <Filter>samples\impmunge</Filter>
    </ClCompile>
    <ClCompile Include="..\samples\dynamic_alloc\main.cpp">
      <Filter>samples\dynamic_alloc</Filter>
    </ClCompile>
    <ClCompile Include="..\samples\echo\main.cpp">
      <Filter>samples\echo</Filter>
    </ClCompile>
    <ClCompile Include="..\samples\member\member.cpp">
      <Filter>samples\member</Filter>
    </ClCompile>
    <ClCompile Include="..\samples\opengl\ogldet.cpp">
      <Filter>samples\opengl</Filter>
    </ClCompile>
    <ClCompile Include="..\samples\region\region.cpp">
      <Filter>samples\region</Filter>
    </ClCompile>
    <ClCompile Include="..\samples\setdll\setdll.cpp">
      <Filter>samples\setdll</Filter>
    </ClCompile>
    <ClCompile Include="..\samples\findfunc\symtest.cpp">
      <Filter>samples\findfunc</Filter>
    </ClCompile>
    <ClCompile Include="..\samples\findfunc\target.cpp">
      <Filter>samples\findfunc</Filter>
    </ClCompile>
    <ClCompile Include="..\samples\opengl\testogl.cpp">
      <Filter>samples\opengl</Filter>
    </ClCompile>
    <ClCompile Include="..\samples\comeasy\comeasy.cpp">
      <Filter>samples\comeasy</Filter>
    </ClCompile>
    <ClCompile Include="..\samples\commem\commem.cpp">
      <Filter>samples\commem</Filter>
    </ClCompile>
    <ClCompile Include="..\samples\cping\cping.cpp">
      <Filter>samples\cping</Filter>
    </ClCompile>
    <ClCompile Include="..\samples\disas\disas.cpp">
      <Filter>samples\disas</Filter>
    </ClCompile>
    <ClCompile Include="..\samples\disas\unk.cpp">
      <Filter>samples\disas</Filter>
    </ClCompile>
    <ClCompile Include="..\samples\comeasy\wrotei.cpp">
      <Filter>samples\comeasy</Filter>
    </ClCompile>
    <ClCompile Include="..\samples\disas\x86.cpp">
      <Filter>samples\disas</Filter>
    </ClCompile>
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="..\src\detours.h">
      <Filter>src</Filter>
    </ClInclude>
    <ClInclude Include="..\src\detver.h">
      <Filter>src</Filter>
    </ClInclude>
    <ClInclude Include="..\samples\tracebld\tracebld.h">
      <Filter>samples\tracebld</Filter>
    </ClInclude>
    <ClInclude Include="..\samples\slept\slept.h">
      <Filter>samples\slept</Filter>
    </ClInclude>
    <ClInclude Include="..\samples\syelog\syelog.h">
      <Filter>samples\syelog</Filter>
    </ClInclude>
    <ClInclude Include="..\samples\dtest\dtarge.h">
      <Filter>samples\dtest</Filter>
    </ClInclude>
    <ClInclude Include="..\samples\excep\firstexc.h">
      <Filter>samples\excep</Filter>
    </ClInclude>
    <ClInclude Include="..\samples\findfunc\target.h">
      <Filter>samples\findfunc</Filter>
    </ClInclude>
  </ItemGroup>
  <ItemGroup>
    <None Include="..\samples\tracebld\Makefile">
      <Filter>samples\tracebld</Filter>
    </None>
    <None Include="..\samples\tracelnk\Makefile">
      <Filter>samples\tracelnk</Filter>
    </None>
    <None Include="..\samples\tracemem\Makefile">
      <Filter>samples\tracemem</Filter>
    </None>
    <None Include="..\samples\tracereg\Makefile">
      <Filter>samples\tracereg</Filter>
    </None>
    <None Include="..\samples\traceser\Makefile">
      <Filter>samples\traceser</Filter>
    </None>
    <None Include="..\samples\tracessl\Makefile">
      <Filter>samples\tracessl</Filter>
    </None>
    <None Include="..\samples\tracetcp\Makefile">
      <Filter>samples\tracetcp</Filter>
    </None>
    <None Include="..\samples\tryman\Makefile">
      <Filter>samples\tryman</Filter>
    </None>
    <None Include="..\samples\withdll\Makefile">
      <Filter>samples\withdll</Filter>
    </None>
    <None Include="..\samples\tryman\managed.cs">
      <Filter>samples\tryman</Filter>
    </None>
    <None Include="..\samples\simple\Makefile">
      <Filter>samples\simple</Filter>
    </None>
    <None Include="..\samples\simple_safe\Makefile">
      <Filter>samples\simple_safe</Filter>
    </None>
    <None Include="..\samples\slept\Makefile">
      <Filter>samples\slept</Filter>
    </None>
    <None Include="..\samples\syelog\Makefile">
      <Filter>samples\syelog</Filter>
    </None>
    <None Include="..\samples\talloc\Makefile">
      <Filter>samples\talloc</Filter>
    </None>
    <None Include="..\samples\traceapi\Makefile">
      <Filter>samples\traceapi</Filter>
    </None>
    <None Include="..\samples\dumpe\Makefile">
      <Filter>samples\dumpe</Filter>
    </None>
    <None Include="..\samples\dumpi\Makefile">
      <Filter>samples\dumpi</Filter>
    </None>
    <None Include="..\samples\dynamic_alloc\Makefile">
      <Filter>samples\dynamic_alloc</Filter>
    </None>
    <None Include="..\samples\echo\Makefile">
      <Filter>samples\echo</Filter>
    </None>
    <None Include="..\samples\einst\Makefile">
      <Filter>samples\einst</Filter>
    </None>
    <None Include="..\samples\excep\Makefile">
      <Filter>samples\excep</Filter>
    </None>
    <None Include="..\samples\findfunc\Makefile">
      <Filter>samples\findfunc</Filter>
    </None>
    <None Include="..\samples\impmunge\Makefile">
      <Filter>samples\impmunge</Filter>
    </None>
    <None Include="..\samples\member\Makefile">
      <Filter>samples\member</Filter>
    </None>
    <None Include="..\samples\opengl\Makefile">
      <Filter>samples\opengl</Filter>
    </None>
    <None Include="..\samples\region\Makefile">
      <Filter>samples\region</Filter>
    </None>
    <None Include="..\samples\setdll\Makefile">
      <Filter>samples\setdll</Filter>
    </None>
    <None Include="..\samples\dynamic_alloc\x64.asm">
      <Filter>samples\dynamic_alloc</Filter>
    </None>
    <None Include="..\samples\dynamic_alloc\x86.asm">
      <Filter>samples\dynamic_alloc</Filter>
    </None>
    <None Include="..\samples\disas\arm.asm">
      <Filter>samples\disas</Filter>
    </None>
    <None Include="..\samples\common.mak">
      <Filter>samples</Filter>
    </None>
    <None Include="..\samples\cping\cping.dat">
      <Filter>samples\cping</Filter>
    </None>
    <None Include="..\samples\disas\ia64.asm">
      <Filter>samples\disas</Filter>
    </None>
    <None Include="..\samples\comeasy\Makefile">
      <Filter>samples\comeasy</Filter>
    </None>
    <None Include="..\samples\commem\Makefile">
      <Filter>samples\commem</Filter>
    </None>
    <None Include="..\samples\cping\Makefile">
      <Filter>samples\cping</Filter>
    </None>
    <None Include="..\samples\disas\Makefile">
      <Filter>samples\disas</Filter>
    </None>
    <None Include="..\samples\dtest\Makefile">
      <Filter>samples\dtest</Filter>
    </None>
    <None Include="..\samples\Makefile">
      <Filter>samples</Filter>
    </None>
    <None Include="..\samples\disas\x64.asm">
      <Filter>samples\disas</Filter>
    </None>
    <None Include="..\.gitignore" />
    <None Include="..\LICENSE.md" />
    <None Include="..\Makefile" />
    <None Include="..\README.md" />
    <None Include="..\system.mak" />
  </ItemGroup>
  <ItemGroup>
    <Text Include="..\samples\slept\NORMAL_IA64.TXT">
      <Filter>samples\slept</Filter>
    </Text>
    <Text Include="..\samples\talloc\NORMAL_IA64.TXT">
      <Filter>samples\talloc</Filter>
    </Text>
    <Text Include="..\samples\slept\NORMAL_X64.TXT">
      <Filter>samples\slept</Filter>
    </Text>
    <Text Include="..\samples\talloc\NORMAL_X64.TXT">
      <Filter>samples\talloc</Filter>
    </Text>
    <Text Include="..\samples\slept\NORMAL_X86.TXT">
      <Filter>samples\slept</Filter>
    </Text>
    <Text Include="..\samples\dtest\NORMAL_IA64.TXT">
      <Filter>samples\dtest</Filter>
    </Text>
    <Text Include="..\samples\dtest\NORMAL_X64.TXT">
      <Filter>samples\dtest</Filter>
    </Text>
    <Text Include="..\samples\dtest\NORMAL_X86.TXT">
      <Filter>samples\dtest</Filter>
    </Text>
    <Text Include="..\samples\cping\ReadMe.Txt">
      <Filter>samples\cping</Filter>
    </Text>
    <Text Include="..\samples\README.TXT">
      <Filter>samples</Filter>
    </Text>
    <Text Include="..\CREDITS.md" />
  </ItemGroup>
  <ItemGroup>
    <ResourceCompile Include="..\samples\traceapi\trcapi.rc">
      <Filter>samples\traceapi</Filter>
    </ResourceCompile>
    <ResourceCompile Include="..\samples\tracebld\trcbld.rc">
      <Filter>samples\tracebld</Filter>
    </ResourceCompile>
    <ResourceCompile Include="..\samples\tracelnk\trclnk.rc">
      <Filter>samples\tracelnk</Filter>
    </ResourceCompile>
    <ResourceCompile Include="..\samples\tracemem\trcmem.rc">
      <Filter>samples\tracemem</Filter>
    </ResourceCompile>
    <ResourceCompile Include="..\samples\tracereg\trcreg.rc">
      <Filter>samples\tracereg</Filter>
    </ResourceCompile>
    <ResourceCompile Include="..\samples\traceser\trcser.rc">
      <Filter>samples\traceser</Filter>
    </ResourceCompile>
    <ResourceCompile Include="..\samples\tracessl\trcssl.rc">
      <Filter>samples\tracessl</Filter>
    </ResourceCompile>
    <ResourceCompile Include="..\samples\tracetcp\trctcp.rc">
      <Filter>samples\tracetcp</Filter>
    </ResourceCompile>
    <ResourceCompile Include="..\samples\tryman\tstman.rc">
      <Filter>samples\tryman</Filter>
    </ResourceCompile>
    <ResourceCompile Include="..\samples\slept\dslept.rc">
      <Filter>samples\slept</Filter>
    </ResourceCompile>
    <ResourceCompile Include="..\samples\simple\simple.rc">
      <Filter>samples\simple</Filter>
    </ResourceCompile>
    <ResourceCompile Include="..\samples\simple_safe\simple_safe.rc">
      <Filter>samples\simple_safe</Filter>
    </ResourceCompile>
    <ResourceCompile Include="..\samples\slept\slept.rc">
      <Filter>samples\slept</Filter>
    </ResourceCompile>
    <ResourceCompile Include="..\samples\dtest\dtarge.rc">
      <Filter>samples\dtest</Filter>
    </ResourceCompile>
    <ResourceCompile Include="..\samples\echo\echofx.rc">
      <Filter>samples\echo</Filter>
    </ResourceCompile>
    <ResourceCompile Include="..\samples\findfunc\extend.rc">
      <Filter>samples\findfunc</Filter>
    </ResourceCompile>
    <ResourceCompile Include="..\samples\opengl\ogldet.rc">
      <Filter>samples\opengl</Filter>
    </ResourceCompile>
    <ResourceCompile Include="..\samples\findfunc\target.rc">
      <Filter>samples\findfunc</Filter>
    </ResourceCompile>
    <ResourceCompile Include="..\samples\comeasy\wrotei.rc">
      <Filter>samples\comeasy</Filter>
    </ResourceCompile>
  </ItemGroup>
  <ItemGroup>
    <Midl Include="..\samples\cping\iping.idl">
      <Filter>samples\cping</Filter>
    </Midl>
  </ItemGroup>
</Project>

```