Project Path: arc_gmh5225_KSOCKET_reecbsbp

Source Tree:

```txt
arc_gmh5225_KSOCKET_reecbsbp
├── KSOCKET.sln
├── LICENSE.txt
├── README.md
├── img
│   └── windbg.png
└── src
    └── ksocket
        ├── berkeley.c
        ├── berkeley.h
        ├── ksocket.c
        ├── ksocket.h
        ├── ksocket.inf
        ├── ksocket.vcxproj
        ├── ksocket.vcxproj.filters
        └── main.c

```

`KSOCKET.sln`:

```sln

Microsoft Visual Studio Solution File, Format Version 12.00
# Visual Studio 15
VisualStudioVersion = 15.0.27703.2000
MinimumVisualStudioVersion = 10.0.40219.1
Project("{2150E333-8FDC-42A3-9474-1A3956D46DE8}") = "Solution Items", "Solution Items", "{01B84E09-7D4F-4415-95AD-C9291497D28C}"
	ProjectSection(SolutionItems) = preProject
		.editorconfig = .editorconfig
	EndProjectSection
EndProject
Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "ksocket", "src\ksocket\ksocket.vcxproj", "{46A74761-6CFA-41AF-A536-47F08E2C7B48}"
EndProject
Global
	GlobalSection(SolutionConfigurationPlatforms) = preSolution
		Debug|x64 = Debug|x64
		Debug|x86 = Debug|x86
		Release|x64 = Release|x64
		Release|x86 = Release|x86
	EndGlobalSection
	GlobalSection(ProjectConfigurationPlatforms) = postSolution
		{46A74761-6CFA-41AF-A536-47F08E2C7B48}.Debug|x64.ActiveCfg = Debug|x64
		{46A74761-6CFA-41AF-A536-47F08E2C7B48}.Debug|x64.Build.0 = Debug|x64
		{46A74761-6CFA-41AF-A536-47F08E2C7B48}.Debug|x86.ActiveCfg = Debug|Win32
		{46A74761-6CFA-41AF-A536-47F08E2C7B48}.Debug|x86.Build.0 = Debug|Win32
		{46A74761-6CFA-41AF-A536-47F08E2C7B48}.Release|x64.ActiveCfg = Release|x64
		{46A74761-6CFA-41AF-A536-47F08E2C7B48}.Release|x64.Build.0 = Release|x64
		{46A74761-6CFA-41AF-A536-47F08E2C7B48}.Release|x86.ActiveCfg = Release|Win32
		{46A74761-6CFA-41AF-A536-47F08E2C7B48}.Release|x86.Build.0 = Release|Win32
	EndGlobalSection
	GlobalSection(SolutionProperties) = preSolution
		HideSolutionNode = FALSE
	EndGlobalSection
	GlobalSection(ExtensibilityGlobals) = postSolution
		SolutionGuid = {B2F42D07-8CF5-40C5-924F-6EAB82D9ABF0}
	EndGlobalSection
EndGlobal

```

`LICENSE.txt`:

```txt
The MIT License (MIT)

Copyright (c) 2019 Petr Benes

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.

```

`README.md`:

```md
# KSOCKET

**KSOCKET** provides a very basic example on how to make a network connections
in the Windows Driver by using WSK.

### Why?

In my opinion there aren't too much examples on WSK on the Internet.  This is
quite understandable, as generally dealing with networking in the kernel-mode
isn't a very good idea.  However, sometimes, you're just too interested _**how it can be done**_.

### What does it do?

It makes a HTTP GET request to the `httpbin.org/uuid` and prints the response
to the debugger.  Then, it creates a TCP server listening on port 9095 and waits
for a client.  When the client connects, it waits for a single message, prints
it to the debugger and then responds with `Hello from WSK!` and closes both
client and server sockets.

The output in the debugger might look like this:

![windbg](img/windbg.png)

### Implementation

Because everyone is familiar with the **Berkeley socket API**, I've ported
a very small subset of it - enough to make a basic TCP/UDP client/server:

```c
int getaddrinfo(const char* node, const char* service, const struct addrinfo* hints, struct addrinfo** res);
void freeaddrinfo(struct addrinfo *res);

int socket_connection(int domain, int type, int protocol);
int socket_listen(int domain, int type, int protocol);
int socket_datagram(int domain, int type, int protocol);
int connect(int sockfd, const struct sockaddr* addr, socklen_t addrlen);
int listen(int sockfd, int backlog);
int bind(int sockfd, const struct sockaddr *addr, socklen_t addrlen);
int accept(int sockfd, struct sockaddr *addr, socklen_t *addrlen);
int send(int sockfd, const void* buf, size_t len, int flags);
int sendto(int sockfd, const void *buf, size_t len, int flags, const struct sockaddr *dest_addr, socklen_t addrlen);
int recv(int sockfd, void* buf, size_t len, int flags);
int recvfrom(int sockfd, void *buf, size_t len, int flags, struct sockaddr *src_addr, socklen_t *addrlen);
int closesocket(int sockfd);
```

You can probably see the biggest difference between this API and the original Berkeley
socket API - instead of a single `socket()` function, there are `socket_connection()`,
`socket_listen()` and `socket_datagram()` functions.  This is because in WSK, you
have to specify type of the socket **when** the socket object is created.  Although
it would probably be possible with some workarounds to make just single `socket()` function,
for simplicity of the implementation I've decided to split it too.

> **NOTE:** This project is purely experimental and its goal is to show basic
> usage of the WSK. There aren't many error checks and it is not recommended
> for production use.

### License

This software is open-source under the MIT license. See the LICENSE.txt file in this repository.

Dependencies are licensed by their own licenses.

If you find this project interesting, you can buy me a coffee

```
  BTC 3GwZMNGvLCZMi7mjL8K6iyj6qGbhkVMNMF
  LTC MQn5YC7bZd4KSsaj8snSg4TetmdKDkeCYk
```

[wsk-msdn]: <https://docs.microsoft.com/en-us/windows-hardware/drivers/network/introduction-to-winsock-kernel>
[wsk-http]: <https://github.com/reinhardvz/afdmjhk/blob/master/WSK/Samples/wsksample/wsksample.c>
[wsk-echosrv]: <https://github.com/Microsoft/Windows-driver-samples/tree/master/network/wsk/echosrv>

```

`src/ksocket/berkeley.c`:

```c
#include "berkeley.h"
#include "ksocket.h"

//////////////////////////////////////////////////////////////////////////
// Definitions.
//////////////////////////////////////////////////////////////////////////

#define MEMORY_TAG            ' bsK'
#define SOCKETFD_MAX          128
#define TO_SOCKETFD(index)    ((index % SOCKETFD_MAX)  + 1)
#define FROM_SOCKETFD(sockfd) ((sockfd)                - 1)

//////////////////////////////////////////////////////////////////////////
// Function prototypes.
//////////////////////////////////////////////////////////////////////////

NTSTATUS
NTAPI
KspUtilAddrInfoToAddrInfoEx(
  _In_ PADDRINFOA AddrInfo,
  _Out_ PADDRINFOEXW* AddrInfoEx
  );

NTSTATUS
NTAPI
KspUtilAddrInfoExToAddrInfo(
  _In_ PADDRINFOEXW AddrInfoEx,
  _Out_ PADDRINFOA* AddrInfo
  );

VOID
NTAPI
KspUtilFreeAddrInfo(
  _In_ PADDRINFOA AddrInfo
  );

VOID
NTAPI
KspUtilFreeAddrInfoEx(
  _In_ PADDRINFOEXW AddrInfo
  );

//////////////////////////////////////////////////////////////////////////
// Variables.
//////////////////////////////////////////////////////////////////////////

//
// !!!!!!!!!!!!!!!!!!!!!!!!!!!!! NOTE !!!!!!!!!!!!!!!!!!!!!!!!!!!!!
// !!!!!!!!!!!!!!!!!!!!!!!!!!!!! NOTE !!!!!!!!!!!!!!!!!!!!!!!!!!!!!
// !!!!!!!!!!!!!!!!!!!!!!!!!!!!! NOTE !!!!!!!!!!!!!!!!!!!!!!!!!!!!!
//
// This is complete bollocks and ideally it should be replaced with
// something like RTL_AVL_TABLE.
//
// !!!!!!!!!!!!!!!!!!!!!!!!!!!!! NOTE !!!!!!!!!!!!!!!!!!!!!!!!!!!!!
// !!!!!!!!!!!!!!!!!!!!!!!!!!!!! NOTE !!!!!!!!!!!!!!!!!!!!!!!!!!!!!
// !!!!!!!!!!!!!!!!!!!!!!!!!!!!! NOTE !!!!!!!!!!!!!!!!!!!!!!!!!!!!!
//

PKSOCKET KsArray[SOCKETFD_MAX] = { 0 };
ULONG    KsIndex = 0;

//////////////////////////////////////////////////////////////////////////
// Private functions.
//////////////////////////////////////////////////////////////////////////

NTSTATUS
NTAPI
KspUtilAddrInfoToAddrInfoEx(
  _In_ PADDRINFOA AddrInfo,
  _Out_ PADDRINFOEXW* AddrInfoEx
  )
{
  NTSTATUS Status;

  //
  // Convert NULL input into NULL output.
  //

  if (AddrInfo == NULL)
  {
    *AddrInfoEx = NULL;
    return STATUS_SUCCESS;
  }

  //
  // Allocate memory for the output structure.
  //

  PADDRINFOEXW Result = ExAllocatePoolWithTag(PagedPool, sizeof(ADDRINFOEXW), MEMORY_TAG);

  if (Result == NULL)
  {
    Status = STATUS_INSUFFICIENT_RESOURCES;
    goto Error1;
  }

  //
  // Copy numeric values.
  //

  RtlZeroMemory(Result, sizeof(ADDRINFOEXW));
  Result->ai_flags    = AddrInfo->ai_flags;
  Result->ai_family   = AddrInfo->ai_family;
  Result->ai_socktype = AddrInfo->ai_socktype;
  Result->ai_protocol = AddrInfo->ai_protocol;
  Result->ai_addrlen  = AddrInfo->ai_addrlen;

  //
  // Copy canonical name.
  //

  ANSI_STRING CanonicalNameAnsi;
  UNICODE_STRING CanonicalNameUnicode;

  if (AddrInfo->ai_canonname)
  {
    RtlInitAnsiString(&CanonicalNameAnsi, AddrInfo->ai_canonname);

    Status = RtlAnsiStringToUnicodeString(&CanonicalNameUnicode, &CanonicalNameAnsi, TRUE);

    if (!NT_SUCCESS(Status))
    {
      goto Error2;
    }

    Result->ai_canonname = CanonicalNameUnicode.Buffer;
  }

  //
  // Copy address.
  //

  Result->ai_addr = AddrInfo->ai_addr;

  //
  // Copy the next structure (recursively).
  //

  PADDRINFOEXW NextAddrInfo;
  Status = KspUtilAddrInfoToAddrInfoEx(AddrInfo->ai_next, &NextAddrInfo);

  if (!NT_SUCCESS(Status))
  {
    goto Error3;
  }

  Result->ai_next = NextAddrInfo;

  //
  // All done!
  //

  *AddrInfoEx = Result;

  return Status;

Error3:
  RtlFreeAnsiString(&CanonicalNameAnsi);

Error2:
  ExFreePoolWithTag(Result, MEMORY_TAG);

Error1:
  return Status;
}

NTSTATUS
NTAPI
KspUtilAddrInfoExToAddrInfo(
  _In_ PADDRINFOEXW AddrInfoEx,
  _Out_ PADDRINFOA* AddrInfo
  )
{
  NTSTATUS Status;

  //
  // Convert NULL input into NULL output.
  //

  if (AddrInfoEx == NULL)
  {
    *AddrInfo = NULL;
    return STATUS_SUCCESS;
  }

  //
  // Allocate memory for the output structure.
  //

  PADDRINFOA Result = ExAllocatePoolWithTag(PagedPool, sizeof(ADDRINFOA), MEMORY_TAG);

  if (Result == NULL)
  {
    Status = STATUS_INSUFFICIENT_RESOURCES;
    goto Error1;
  }

  //
  // Copy numeric values.
  //

  RtlZeroMemory(Result, sizeof(ADDRINFOA));
  Result->ai_flags    = AddrInfoEx->ai_flags;
  Result->ai_family   = AddrInfoEx->ai_family;
  Result->ai_socktype = AddrInfoEx->ai_socktype;
  Result->ai_protocol = AddrInfoEx->ai_protocol;
  Result->ai_addrlen  = AddrInfoEx->ai_addrlen;

  //
  // Copy canonical name.
  //

  UNICODE_STRING CanonicalNameUnicode;
  ANSI_STRING CanonicalNameAnsi;

  if (AddrInfoEx->ai_canonname)
  {
    RtlInitUnicodeString(&CanonicalNameUnicode, AddrInfoEx->ai_canonname);
    Status = RtlUnicodeStringToAnsiString(&CanonicalNameAnsi, &CanonicalNameUnicode, TRUE);

    if (!NT_SUCCESS(Status))
    {
      goto Error2;
    }

    Result->ai_canonname = CanonicalNameAnsi.Buffer;
  }

  //
  // Copy address.
  //

  Result->ai_addr = AddrInfoEx->ai_addr;

  //
  // Copy the next structure (recursively).
  //

  PADDRINFOA NextAddrInfo;
  Status = KspUtilAddrInfoExToAddrInfo(AddrInfoEx->ai_next, &NextAddrInfo);

  if (!NT_SUCCESS(Status))
  {
    goto Error3;
  }

  Result->ai_next = NextAddrInfo;

  //
  // All done!
  //

  *AddrInfo = Result;

  return Status;

Error3:
  RtlFreeAnsiString(&CanonicalNameAnsi);

Error2:
  ExFreePoolWithTag(Result, MEMORY_TAG);

Error1:
  return Status;
}

VOID
NTAPI
KspUtilFreeAddrInfo(
  _In_ PADDRINFOA AddrInfo
  )
{
  //
  // Free all structures recursively.
  //

  if (AddrInfo->ai_next)
  {
    KspUtilFreeAddrInfo(AddrInfo->ai_next);
  }

  //
  // Free the canonical name buffer.
  //

  if (AddrInfo->ai_canonname)
  {
    ANSI_STRING CanonicalName;
    RtlInitAnsiString(&CanonicalName, AddrInfo->ai_canonname);
    RtlFreeAnsiString(&CanonicalName);
  }

  //
  // Finally, free the structure itself.
  //

  ExFreePoolWithTag(AddrInfo, MEMORY_TAG);
}

VOID
NTAPI
KspUtilFreeAddrInfoEx(
  _In_ PADDRINFOEXW AddrInfo
  )
{
  //
  // Free all structures recursively.
  //

  if (AddrInfo->ai_next)
  {
    KspUtilFreeAddrInfoEx(AddrInfo->ai_next);
  }

  //
  // Free the canonical name buffer.
  //

  if (AddrInfo->ai_canonname)
  {
    UNICODE_STRING CanonicalName;
    RtlInitUnicodeString(&CanonicalName, AddrInfo->ai_canonname);
    RtlFreeUnicodeString(&CanonicalName);
  }

  //
  // Finally, free the structure itself.
  //

  ExFreePoolWithTag(AddrInfo, MEMORY_TAG);
}

//////////////////////////////////////////////////////////////////////////
// Public functions.
//////////////////////////////////////////////////////////////////////////

uint32_t htonl(uint32_t hostlong)
{
  return RtlUlongByteSwap(hostlong);
}

uint16_t htons(uint16_t hostshort)
{
  return RtlUshortByteSwap(hostshort);
}

uint32_t ntohl(uint32_t netlong)
{
  return RtlUlongByteSwap(netlong);
}

uint16_t ntohs(uint16_t netshort)
{
  return RtlUshortByteSwap(netshort);
}

int getaddrinfo(const char* node, const char* service, const struct addrinfo* hints, struct addrinfo** res)
{
  NTSTATUS Status;

  //
  // Convert node name to the UNICODE_STRING (if present).
  //

  ANSI_STRING NodeNameAnsi;
  UNICODE_STRING NodeNameUnicode;
  PUNICODE_STRING NodeName = NULL;

  if (node)
  {
    RtlInitAnsiString(&NodeNameAnsi, node);
    Status = RtlAnsiStringToUnicodeString(&NodeNameUnicode, &NodeNameAnsi, TRUE);

    if (!NT_SUCCESS(Status))
    {
      goto Error1;
    }

    NodeName = &NodeNameUnicode;
  }

  //
  // Convert service name to the UNICODE_STRING (if present).
  //

  ANSI_STRING ServiceNameAnsi;
  UNICODE_STRING ServiceNameUnicode;
  PUNICODE_STRING ServiceName = NULL;

  if (service)
  {
    RtlInitAnsiString(&ServiceNameAnsi, service);
    Status = RtlAnsiStringToUnicodeString(&ServiceNameUnicode, &ServiceNameAnsi, TRUE);

    if (!NT_SUCCESS(Status))
    {
      goto Error2;
    }

    ServiceName = &ServiceNameUnicode;
  }

  //
  // Convert "struct addrinfo" to the "ADDRINFOEXW".
  //

  PADDRINFOEXW Hints;
  Status = KspUtilAddrInfoToAddrInfoEx((PADDRINFOA)hints, &Hints);

  if (!NT_SUCCESS(Status))
  {
    goto Error3;
  }

  //
  // All data is prepared, call the underlying API.
  //

  PADDRINFOEXW Result;
  Status = KsGetAddrInfo(NodeName, ServiceName, Hints, &Result);

  //
  // Free the memory of the converted "Hints".
  //

  KspUtilFreeAddrInfoEx(Hints);

  if (!NT_SUCCESS(Status))
  {
    goto Error3;
  }

  //
  // Convert the result "ADDRINFOEXW" to the "struct addrinfo".
  //

  Status = KspUtilAddrInfoExToAddrInfo(Result, res);

  //
  // Free the original result.
  //

  KsFreeAddrInfo(Result);

  if (!NT_SUCCESS(Status))
  {
    goto Error3;
  }

  return STATUS_SUCCESS;

Error3:
  RtlFreeUnicodeString(&ServiceNameUnicode);

Error2:
  RtlFreeUnicodeString(&NodeNameUnicode);

Error1:
  return Status;
}

void freeaddrinfo(struct addrinfo *res)
{
  //
  // Call our implementation.
  //

  KspUtilFreeAddrInfo(res);
}

int socket_connection(int domain, int type, int protocol)
{
  NTSTATUS Status;
  PKSOCKET Socket;

  Status = KsCreateConnectionSocket(
    &Socket,
    (ADDRESS_FAMILY)domain,
    (USHORT)type,
    (ULONG)protocol
    );

  if (NT_SUCCESS(Status))
  {
    int sockfd = TO_SOCKETFD(KsIndex++);

    KsArray[FROM_SOCKETFD(sockfd)] = Socket;

    return sockfd;
  }

  return -1;
}

int socket_listen(int domain, int type, int protocol)
{
  NTSTATUS Status;
  PKSOCKET Socket;

  //
  // WskSocket() returns STATUS_PROTOCOL_UNREACHABLE (0xC000023E)
  // when Protocol == 0, so coerce this value to IPPROTO_TCP here.
  //

  Status = KsCreateListenSocket(
    &Socket,
    (ADDRESS_FAMILY)domain,
    (USHORT)type,
    protocol ? (ULONG)protocol : IPPROTO_TCP
    );

  if (NT_SUCCESS(Status))
  {
    int sockfd = TO_SOCKETFD(KsIndex++);

    KsArray[FROM_SOCKETFD(sockfd)] = Socket;

    return sockfd;
  }

  return -1;
}

int socket_datagram(int domain, int type, int protocol)
{
  NTSTATUS Status;
  PKSOCKET Socket;

  Status = KsCreateDatagramSocket(
    &Socket,
    (ADDRESS_FAMILY)domain,
    (USHORT)type,
    (ULONG)protocol
    );

  if (NT_SUCCESS(Status))
  {
    int sockfd = TO_SOCKETFD(KsIndex++);

    KsArray[FROM_SOCKETFD(sockfd)] = Socket;

    return sockfd;
  }

  return -1;
}

int connect(int sockfd, const struct sockaddr* addr, socklen_t addrlen)
{
  UNREFERENCED_PARAMETER(addrlen);

  NTSTATUS Status;
  PKSOCKET Socket = KsArray[FROM_SOCKETFD(sockfd)];

  Status = KsConnect(Socket, (PSOCKADDR)addr);

  return NT_SUCCESS(Status)
    ? 0
    : -1;
}

int listen(int sockfd, int backlog)
{
  UNREFERENCED_PARAMETER(sockfd);
  UNREFERENCED_PARAMETER(backlog);
  return 0;
}

int bind(int sockfd, const struct sockaddr *addr, socklen_t addrlen)
{
  UNREFERENCED_PARAMETER(addrlen);

  NTSTATUS Status;
  PKSOCKET Socket = KsArray[FROM_SOCKETFD(sockfd)];

  Status = KsBind(Socket, (PSOCKADDR)addr);

  return NT_SUCCESS(Status)
    ? 0
    : -1;
}

int accept(int sockfd, struct sockaddr *addr, socklen_t *addrlen)
{
  NTSTATUS Status;
  PKSOCKET Socket = KsArray[FROM_SOCKETFD(sockfd)];

  PKSOCKET NewSocket;
  Status = KsAccept(Socket, &NewSocket, NULL, (PSOCKADDR)addr);
  *addrlen = sizeof(SOCKADDR);

  if (NT_SUCCESS(Status))
  {
    int newsockfd = TO_SOCKETFD(KsIndex++);

    KsArray[FROM_SOCKETFD(newsockfd)] = NewSocket;

    return newsockfd;
  }

  return -1;
}

int send(int sockfd, const void* buf, size_t len, int flags)
{
  NTSTATUS Status;
  PKSOCKET Socket = KsArray[FROM_SOCKETFD(sockfd)];

  ULONG Length = (ULONG)len;
  Status = KsSend(Socket, (PVOID)buf, &Length, (ULONG)flags);

  return NT_SUCCESS(Status)
    ? (int)Length
    : -1;
}

int sendto(int sockfd, const void *buf, size_t len, int flags, const struct sockaddr *dest_addr, socklen_t addrlen)
{
  UNREFERENCED_PARAMETER(addrlen);

  NTSTATUS Status;
  PKSOCKET Socket = KsArray[FROM_SOCKETFD(sockfd)];

  ULONG Length = (ULONG)len;
  Status = KsSendTo(Socket, (PVOID)buf, &Length, (ULONG)flags, (PSOCKADDR)dest_addr);

  return NT_SUCCESS(Status)
    ? (int)Length
    : -1;
}

int recv(int sockfd, void* buf, size_t len, int flags)
{
  NTSTATUS Status;
  PKSOCKET Socket = KsArray[FROM_SOCKETFD(sockfd)];

  ULONG Length = (ULONG)len;
  Status = KsRecv(Socket, (PVOID)buf, &Length, (ULONG)flags);

  return NT_SUCCESS(Status)
    ? (int)Length
    : -1;
}

int recvfrom(int sockfd, void *buf, size_t len, int flags, struct sockaddr *src_addr, socklen_t *addrlen)
{
  UNREFERENCED_PARAMETER(addrlen);

  NTSTATUS Status;
  PKSOCKET Socket = KsArray[FROM_SOCKETFD(sockfd)];

  ULONG Length = (ULONG)len;
  Status = KsSendTo(Socket, (PVOID)buf, &Length, (ULONG)flags, (PSOCKADDR)src_addr);
  *addrlen = sizeof(SOCKADDR);

  return NT_SUCCESS(Status)
    ? (int)Length
    : -1;
}

int closesocket(int sockfd)
{
  NTSTATUS Status;
  PKSOCKET Socket = KsArray[FROM_SOCKETFD(sockfd)];

  Status = KsCloseSocket(Socket);

  KsArray[FROM_SOCKETFD(sockfd)] = NULL;

  return NT_SUCCESS(Status)
    ? 0
    : -1;
}

```

`src/ksocket/berkeley.h`:

```h
#pragma once
#include <ntddk.h>
#include <wsk.h>
#include <stdint.h>

#ifdef __cplusplus
extern "C" {
#endif

typedef int       socklen_t;
typedef intptr_t  ssize_t;

uint32_t htonl(uint32_t hostlong);
uint16_t htons(uint16_t hostshort);
uint32_t ntohl(uint32_t netlong);
uint16_t ntohs(uint16_t netshort);

int getaddrinfo(const char* node, const char* service, const struct addrinfo* hints, struct addrinfo** res);
void freeaddrinfo(struct addrinfo *res);

int socket_connection(int domain, int type, int protocol);
int socket_listen(int domain, int type, int protocol);
int socket_datagram(int domain, int type, int protocol);
int connect(int sockfd, const struct sockaddr* addr, socklen_t addrlen);
int listen(int sockfd, int backlog);
int bind(int sockfd, const struct sockaddr *addr, socklen_t addrlen);
int accept(int sockfd, struct sockaddr *addr, socklen_t *addrlen);
int send(int sockfd, const void* buf, size_t len, int flags);
int sendto(int sockfd, const void *buf, size_t len, int flags, const struct sockaddr *dest_addr, socklen_t addrlen);
int recv(int sockfd, void* buf, size_t len, int flags);
int recvfrom(int sockfd, void *buf, size_t len, int flags, struct sockaddr *src_addr, socklen_t *addrlen);
int closesocket(int sockfd);

#define socket  socket_connection

#ifdef __cplusplus
}
#endif

```

`src/ksocket/ksocket.c`:

```c
#include "ksocket.h"

//////////////////////////////////////////////////////////////////////////
// Definitions.
//////////////////////////////////////////////////////////////////////////

#define MEMORY_TAG            '  sK'

//////////////////////////////////////////////////////////////////////////
// Structures.
//////////////////////////////////////////////////////////////////////////

typedef struct _KSOCKET_ASYNC_CONTEXT
{
  KEVENT CompletionEvent;
  PIRP Irp;
} KSOCKET_ASYNC_CONTEXT, *PKSOCKET_ASYNC_CONTEXT;

typedef struct _KSOCKET
{
  PWSK_SOCKET	WskSocket;

  union
  {
    PVOID WskDispatch;

    PWSK_PROVIDER_CONNECTION_DISPATCH WskConnectionDispatch;
    PWSK_PROVIDER_LISTEN_DISPATCH WskListenDispatch;
    PWSK_PROVIDER_DATAGRAM_DISPATCH WskDatagramDispatch;
#if (NTDDI_VERSION >= NTDDI_WIN10_RS2)
    PWSK_PROVIDER_STREAM_DISPATCH WskStreamDispatch;
#endif
  };

  KSOCKET_ASYNC_CONTEXT AsyncContext;
} KSOCKET, *PKSOCKET;

//////////////////////////////////////////////////////////////////////////
// Variables.
//////////////////////////////////////////////////////////////////////////

WSK_REGISTRATION     WskRegistration;
WSK_PROVIDER_NPI     WskProvider;
WSK_CLIENT_DISPATCH  WskDispatch = { MAKE_WSK_VERSION(1,0), 0, NULL };

//////////////////////////////////////////////////////////////////////////
// Function prototypes.
//////////////////////////////////////////////////////////////////////////

NTSTATUS
NTAPI
KspAsyncContextAllocate(
  _Out_ PKSOCKET_ASYNC_CONTEXT AsyncContext
  );

VOID
NTAPI
KspAsyncContextFree(
  _In_ PKSOCKET_ASYNC_CONTEXT AsyncContext
  );

VOID
NTAPI
KspAsyncContextReset(
  _In_ PKSOCKET_ASYNC_CONTEXT AsyncContext
  );

NTSTATUS
NTAPI
KspAsyncContextCompletionRoutine(
  _In_ PDEVICE_OBJECT	DeviceObject,
  _In_ PIRP Irp,
  _In_ PKEVENT CompletionEvent
  );

NTSTATUS
NTAPI
KspAsyncContextWaitForCompletion(
  _In_ PKSOCKET_ASYNC_CONTEXT AsyncContext,
  _Inout_ PNTSTATUS Status
  );

//////////////////////////////////////////////////////////////////////////
// Private functions.
//////////////////////////////////////////////////////////////////////////

NTSTATUS
NTAPI
KspAsyncContextAllocate(
  _Out_ PKSOCKET_ASYNC_CONTEXT AsyncContext
  )
{
  //
  // Initialize the completion event.
  //

  KeInitializeEvent(
    &AsyncContext->CompletionEvent,
    SynchronizationEvent,
    FALSE
    );

  //
  // Initialize the IRP.
  //

  AsyncContext->Irp = IoAllocateIrp(1, FALSE);

  if (AsyncContext->Irp == NULL)
  {
    return STATUS_INSUFFICIENT_RESOURCES;
  }

  //
  // KspAsyncContextCompletionRoutine will set
  // the CompletionEvent.
  //

  IoSetCompletionRoutine(
    AsyncContext->Irp,
    &KspAsyncContextCompletionRoutine,
    &AsyncContext->CompletionEvent,
    TRUE,
    TRUE,
    TRUE
    );

  return STATUS_SUCCESS;
}

VOID
NTAPI
KspAsyncContextFree(
  _In_ PKSOCKET_ASYNC_CONTEXT AsyncContext
  )
{
  //
  // Free the IRP.
  //

  IoFreeIrp(AsyncContext->Irp);
}

VOID
NTAPI
KspAsyncContextReset(
  _In_ PKSOCKET_ASYNC_CONTEXT AsyncContext
  )
{
  //
  // If the WSK application allocated the IRP, or is reusing an IRP
  // that it previously allocated, then it must set an IoCompletion
  // routine for the IRP before calling a WSK function.  In this
  // situation, the WSK application must specify TRUE for the
  // InvokeOnSuccess, InvokeOnError, and InvokeOnCancel parameters that
  // are passed to the IoSetCompletionRoutine function to ensure that
  // the IoCompletion routine is always called. Furthermore, the IoCompletion
  // routine that is set for the IRP must always return
  // STATUS_MORE_PROCESSING_REQUIRED to terminate the completion processing
  // of the IRP.  If the WSK application is done using the IRP after the
  // IoCompletion routine has been called, then it should call the IoFreeIrp
  // function to free the IRP before returning from the IoCompletion routine.
  // If the WSK application does not free the IRP then it can reuse the IRP
  // for a call to another WSK function.
  //
  // (ref: https://docs.microsoft.com/en-us/windows-hardware/drivers/network/using-irps-with-winsock-kernel-functions)
  //

  //
  // Reset the completion event.
  //

  KeResetEvent(&AsyncContext->CompletionEvent);

  //
  // Reuse the IRP.
  //

  IoReuseIrp(AsyncContext->Irp, STATUS_UNSUCCESSFUL);

  IoSetCompletionRoutine(
    AsyncContext->Irp,
    &KspAsyncContextCompletionRoutine,
    &AsyncContext->CompletionEvent,
    TRUE,
    TRUE,
    TRUE
    );
}

NTSTATUS
NTAPI
KspAsyncContextCompletionRoutine(
  _In_ PDEVICE_OBJECT	DeviceObject,
  _In_ PIRP Irp,
  _In_ PKEVENT CompletionEvent
  )
{
  UNREFERENCED_PARAMETER(DeviceObject);
  UNREFERENCED_PARAMETER(Irp);

  KeSetEvent(CompletionEvent, IO_NO_INCREMENT, FALSE);
  return STATUS_MORE_PROCESSING_REQUIRED;
}

NTSTATUS
NTAPI
KspAsyncContextWaitForCompletion(
  _In_ PKSOCKET_ASYNC_CONTEXT AsyncContext,
  _Inout_ PNTSTATUS Status
  )
{
  if (*Status == STATUS_PENDING)
  {
    KeWaitForSingleObject(
      &AsyncContext->CompletionEvent,
      Executive,
      KernelMode,
      FALSE,
      NULL
      );

    *Status = AsyncContext->Irp->IoStatus.Status;
  }

  return *Status;
}

//////////////////////////////////////////////////////////////////////////
// Public functions.
//////////////////////////////////////////////////////////////////////////

NTSTATUS
NTAPI
KsInitialize(
  VOID
  )
{
  NTSTATUS Status;

  //
  // Register as a WSK client.
  //

  WSK_CLIENT_NPI WskClient;
  WskClient.ClientContext = NULL;
  WskClient.Dispatch      = &WskDispatch;

  Status = WskRegister(&WskClient, &WskRegistration);

  if (!NT_SUCCESS(Status))
  {
    return Status;
  }

  //
  // Capture the provider NPI.
  //

  return WskCaptureProviderNPI(
    &WskRegistration,
    WSK_INFINITE_WAIT,
    &WskProvider
    );
}

VOID
NTAPI
KsDestroy(
  VOID
  )
{
  //
  // Release the provider NPI instance.
  //

  WskReleaseProviderNPI(&WskRegistration);

  //
  // Deregister as a WSK client.
  //

  WskDeregister(&WskRegistration);
}

NTSTATUS
NTAPI
KsGetAddrInfo(
  _In_ PUNICODE_STRING NodeName,
  _In_ PUNICODE_STRING ServiceName,
  _In_ PADDRINFOEXW Hints,
  _Out_ PADDRINFOEXW* Result
  )
{
  NTSTATUS Status;

  //
  // Allocate async context.
  //

  KSOCKET_ASYNC_CONTEXT AsyncContext;
  Status = KspAsyncContextAllocate(&AsyncContext);

  if (!NT_SUCCESS(Status))
  {
    return Status;
  }

  //
  // Call the WSK API.
  //

  Status = WskProvider.Dispatch->WskGetAddressInfo(
    WskProvider.Client,         // Client
    NodeName,                   // NodeName
    ServiceName,                // ServiceName
    0,                          // NameSpace
    NULL,                       // Provider
    Hints,                      // Hints
    Result,                     // Result
    NULL,                       // OwningProcess
    NULL,                       // OwningThread
    AsyncContext.Irp            // Irp
    );

  KspAsyncContextWaitForCompletion(&AsyncContext, &Status);

  //
  // Free the async context.
  //

  KspAsyncContextFree(&AsyncContext);

  return Status;
}

VOID
NTAPI
KsFreeAddrInfo(
  _In_ PADDRINFOEXW AddrInfo
  )
{
  WskProvider.Dispatch->WskFreeAddressInfo(
    WskProvider.Client,         // Client
    AddrInfo                    // AddrInfo
    );
}

NTSTATUS
NTAPI
KsCreateSocket(
  _Out_ PKSOCKET* Socket,
  _In_ ADDRESS_FAMILY AddressFamily,
  _In_ USHORT SocketType,
  _In_ ULONG Protocol,
  _In_ ULONG Flags
  )
{
  NTSTATUS Status;

  //
  // Allocate memory for the socket structure.
  //

  PKSOCKET NewSocket = ExAllocatePoolWithTag(PagedPool, sizeof(KSOCKET), MEMORY_TAG);

  if (!NewSocket)
  {
    return STATUS_INSUFFICIENT_RESOURCES;
  }

  //
  // Allocate async context for the socket.
  //

  Status = KspAsyncContextAllocate(&NewSocket->AsyncContext);

  if (!NT_SUCCESS(Status))
  {
    return Status;
  }

  //
  // Create the WSK socket.
  //

  Status = WskProvider.Dispatch->WskSocket(
    WskProvider.Client,         // Client
    AddressFamily,              // AddressFamily
    SocketType,                 // SocketType
    Protocol,                   // Protocol
    Flags,                      // Flags
    NULL,                       // SocketContext
    NULL,                       // Dispatch
    NULL,                       // OwningProcess
    NULL,                       // OwningThread
    NULL,                       // SecurityDescriptor
    NewSocket->AsyncContext.Irp // Irp
    );

  KspAsyncContextWaitForCompletion(&NewSocket->AsyncContext, &Status);

  //
  // Save the socket instance and the socket dispatch table.
  //

  if (NT_SUCCESS(Status))
  {
    NewSocket->WskSocket = (PWSK_SOCKET)NewSocket->AsyncContext.Irp->IoStatus.Information;
    NewSocket->WskDispatch = (PVOID)NewSocket->WskSocket->Dispatch;

    *Socket = NewSocket;
  }

  return Status;
}

NTSTATUS
NTAPI
KsCreateConnectionSocket(
  _Out_ PKSOCKET* Socket,
  _In_ ADDRESS_FAMILY AddressFamily,
  _In_ USHORT SocketType,
  _In_ ULONG Protocol
  )
{
  return KsCreateSocket(Socket, AddressFamily, SocketType, Protocol, WSK_FLAG_CONNECTION_SOCKET);
}

NTSTATUS
NTAPI
KsCreateListenSocket(
  _Out_ PKSOCKET* Socket,
  _In_ ADDRESS_FAMILY AddressFamily,
  _In_ USHORT SocketType,
  _In_ ULONG Protocol
  )
{
  return KsCreateSocket(Socket, AddressFamily, SocketType, Protocol, WSK_FLAG_LISTEN_SOCKET);
}

NTSTATUS
NTAPI
KsCreateDatagramSocket(
  _Out_ PKSOCKET* Socket,
  _In_ ADDRESS_FAMILY AddressFamily,
  _In_ USHORT SocketType,
  _In_ ULONG Protocol
  )
{
  return KsCreateSocket(Socket, AddressFamily, SocketType, Protocol, WSK_FLAG_DATAGRAM_SOCKET);
}

NTSTATUS
NTAPI
KsCloseSocket(
  _In_ PKSOCKET Socket
  )
{
  NTSTATUS Status;

  //
  // Reset the async context.
  //

  KspAsyncContextReset(&Socket->AsyncContext);

  //
  // Close the WSK socket.
  //

  Status = Socket->WskConnectionDispatch->WskCloseSocket(
    Socket->WskSocket,
    Socket->AsyncContext.Irp
    );

  KspAsyncContextWaitForCompletion(&Socket->AsyncContext, &Status);

  //
  // Free the async context.
  //

  KspAsyncContextFree(&Socket->AsyncContext);

  //
  // Free memory for the socket structure.
  //

  ExFreePoolWithTag(Socket, MEMORY_TAG);

  return Status;
}

NTSTATUS
NTAPI
KsBind(
  _In_ PKSOCKET Socket,
  _In_ PSOCKADDR LocalAddress
  )
{
  NTSTATUS Status;

  //
  // Reset the async context.
  //

  KspAsyncContextReset(&Socket->AsyncContext);

  //
  // Bind the socket.
  //

  Status = Socket->WskListenDispatch->WskBind(
    Socket->WskSocket,          // Socket
    LocalAddress,               // LocalAddress
    0,                          // Flags (reserved)
    Socket->AsyncContext.Irp    // Irp
    );

  KspAsyncContextWaitForCompletion(&Socket->AsyncContext, &Status);

  return Status;
}

NTSTATUS
NTAPI
KsAccept(
  _In_ PKSOCKET Socket,
  _Out_ PKSOCKET* NewSocket,
  _Out_opt_ PSOCKADDR LocalAddress,
  _Out_opt_ PSOCKADDR RemoteAddress
  )
{
  NTSTATUS Status;

  //
  // Reset the async context.
  //

  KspAsyncContextReset(&Socket->AsyncContext);

  //
  // Accept the connection.
  //

  Status = Socket->WskListenDispatch->WskAccept(
    Socket->WskSocket,          // ListenSocket
    0,                          // Flags
    NULL,                       // AcceptSocketContext
    NULL,                       // AcceptSocketDispatch
    LocalAddress,               // LocalAddress
    RemoteAddress,              // RemoteAddress
    Socket->AsyncContext.Irp    // Irp
    );

  KspAsyncContextWaitForCompletion(&Socket->AsyncContext, &Status);

  //
  // Save the socket instance and the socket dispatch table.
  //

  if (NT_SUCCESS(Status))
  {
    PKSOCKET KNewSocket = ExAllocatePoolWithTag(PagedPool, sizeof(KSOCKET), MEMORY_TAG);

    if (!KNewSocket)
    {
      return STATUS_INSUFFICIENT_RESOURCES;
    }

    KNewSocket->WskSocket = (PWSK_SOCKET)Socket->AsyncContext.Irp->IoStatus.Information;
    KNewSocket->WskDispatch = (PVOID)KNewSocket->WskSocket->Dispatch;
    KspAsyncContextAllocate(&KNewSocket->AsyncContext);

    *NewSocket = KNewSocket;
  }

  return Status;
}

NTSTATUS
NTAPI
KsConnect(
  _In_ PKSOCKET Socket,
  _In_ PSOCKADDR RemoteAddress
  )
{
  NTSTATUS Status;

  //
  // Reset the async context.
  //

  KspAsyncContextReset(&Socket->AsyncContext);

  //
  // Bind the socket to the local address.
  //

  SOCKADDR_IN LocalAddress;
  LocalAddress.sin_family       = AF_INET;
  LocalAddress.sin_addr.s_addr  = INADDR_ANY;
  LocalAddress.sin_port         = 0;

  Status = Socket->WskConnectionDispatch->WskBind(
    Socket->WskSocket,          // Socket
    (PSOCKADDR)&LocalAddress,   // LocalAddress
    0,                          // Flags (reserved)
    Socket->AsyncContext.Irp    // Irp
    );

  KspAsyncContextWaitForCompletion(&Socket->AsyncContext, &Status);

  if (!NT_SUCCESS(Status))
  {
    return Status;
  }

  //
  // Reset the async context (again).
  //

  KspAsyncContextReset(&Socket->AsyncContext);

  //
  // Connect to the remote host.
  //
  // N.B.: Instead of calling WskSocket(), WskBind() and WskConnect(),
  // it is possible to just call WskSocketConnect().
  //

  Status = Socket->WskConnectionDispatch->WskConnect(
    Socket->WskSocket,          // Socket
    RemoteAddress,              // RemoteAddress
    0,                          // Flags (reserved)
    Socket->AsyncContext.Irp    // Irp
    );

  KspAsyncContextWaitForCompletion(&Socket->AsyncContext, &Status);

  return Status;
}

NTSTATUS
NTAPI
KsSendRecv(
  _In_ PKSOCKET Socket,
  _In_ PVOID Buffer,
  _Inout_ PULONG Length,
  _In_ ULONG Flags,
  _In_ BOOLEAN Send
  )
{
  NTSTATUS Status;

  //
  // Wrap the buffer into the "WSK buffer".
  //

  WSK_BUF WskBuffer;
  WskBuffer.Offset  = 0;
  WskBuffer.Length  = *Length;
  WskBuffer.Mdl     = IoAllocateMdl(Buffer, (ULONG)WskBuffer.Length, FALSE, FALSE, NULL);

  __try
  {
    MmProbeAndLockPages(WskBuffer.Mdl, KernelMode, IoWriteAccess);
  }
  __except (EXCEPTION_EXECUTE_HANDLER)
  {
    Status = STATUS_ACCESS_VIOLATION;
    goto Error;
  }

  //
  // Reset the async context.
  //

  KspAsyncContextReset(&Socket->AsyncContext);

  //
  // Send / receive the data.
  //

  if (Send)
  {
    Status = Socket->WskConnectionDispatch->WskSend(
      Socket->WskSocket,        // Socket
      &WskBuffer,               // Buffer
      Flags,                    // Flags
      Socket->AsyncContext.Irp  // Irp
      );
  }
  else
  {
    Status = Socket->WskConnectionDispatch->WskReceive(
      Socket->WskSocket,        // Socket
      &WskBuffer,               // Buffer
      Flags,                    // Flags
      Socket->AsyncContext.Irp  // Irp
      );
  }

  KspAsyncContextWaitForCompletion(&Socket->AsyncContext, &Status);

  //
  // Set the number of bytes sent / received.
  //

  if (NT_SUCCESS(Status))
  {
    *Length = (ULONG)Socket->AsyncContext.Irp->IoStatus.Information;
  }

  //
  // Free the MDL.
  //

  MmUnlockPages(WskBuffer.Mdl);

Error:
  IoFreeMdl(WskBuffer.Mdl);
  return Status;
}

NTSTATUS
NTAPI
KsSendRecvUdp(
  _In_ PKSOCKET Socket,
  _In_ PVOID Buffer,
  _Inout_ PULONG Length,
  _In_ ULONG Flags,
  _In_ PSOCKADDR RemoteAddress,
  _In_ BOOLEAN Send
  )
{
  NTSTATUS Status;

  //
  // Wrap the buffer into the "WSK buffer".
  //

  WSK_BUF WskBuffer;
  WskBuffer.Offset  = 0;
  WskBuffer.Length  = *Length;
  WskBuffer.Mdl     = IoAllocateMdl(Buffer, (ULONG)WskBuffer.Length, FALSE, FALSE, NULL);

  __try
  {
    MmProbeAndLockPages(WskBuffer.Mdl, KernelMode, IoWriteAccess);
  }
  __except (EXCEPTION_EXECUTE_HANDLER)
  {
    Status = STATUS_ACCESS_VIOLATION;
    goto Error;
  }

  //
  // Reset the async context.
  //

  KspAsyncContextReset(&Socket->AsyncContext);

  //
  // Send / receive the data.
  //

  if (Send)
  {
    Status = Socket->WskDatagramDispatch->WskSendTo(
      Socket->WskSocket,        // Socket
      &WskBuffer,               // Buffer
      Flags,                    // Flags (reserved)
      RemoteAddress,            // RemoteAddress
      0,                        // ControlInfoLength
      NULL,                     // ControlInfo
      Socket->AsyncContext.Irp  // Irp
      );
  }
  else
  {
    //
    // Use #pragma prefast (suppress: ...), because SAL annotation is wrong
    // for this function.
    //
    // From MSDN:
    //   ControlLength
    //   ControlInfo
    //
    //   ... This pointer is optional and can be NULL.  If the ControlInfoLength
    //   parameter is NULL, the ControlInfo parameter should be NULL.
    //

#pragma prefast (                                                                           \
    suppress:__WARNING_INVALID_PARAM_VALUE_1,                                               \
    "If the ControlInfoLength parameter is NULL, the ControlInfo parameter should be NULL." \
    )

    Status = Socket->WskDatagramDispatch->WskReceiveFrom(
      Socket->WskSocket,        // Socket
      &WskBuffer,               // Buffer
      Flags,                    // Flags (reserved)
      RemoteAddress,            // RemoteAddress
      NULL,                     // ControlInfoLength
      NULL,                     // ControlInfo
      NULL,                     // ControlFlags
      Socket->AsyncContext.Irp  // Irp
      );
  }

  KspAsyncContextWaitForCompletion(&Socket->AsyncContext, &Status);

  //
  // Set the number of bytes sent / received.
  //

  if (NT_SUCCESS(Status))
  {
    *Length = (ULONG)Socket->AsyncContext.Irp->IoStatus.Information;
  }

  //
  // Free the MDL.
  //

  MmUnlockPages(WskBuffer.Mdl);

Error:
  IoFreeMdl(WskBuffer.Mdl);
  return Status;
}

NTSTATUS
NTAPI
KsSend(
  _In_ PKSOCKET Socket,
  _In_ PVOID Buffer,
  _Inout_ PULONG Length,
  _In_ ULONG Flags
  )
{
  return KsSendRecv(Socket, Buffer, Length, Flags, TRUE);
}

NTSTATUS
NTAPI
KsRecv(
  _In_ PKSOCKET Socket,
  _In_ PVOID Buffer,
  _Inout_ PULONG Length,
  _In_ ULONG Flags
  )
{
  return KsSendRecv(Socket, Buffer, Length, Flags, FALSE);
}

NTSTATUS
NTAPI
KsSendTo(
  _In_ PKSOCKET Socket,
  _In_ PVOID Buffer,
  _Inout_ PULONG Length,
  _In_ ULONG Flags,
  _In_ PSOCKADDR RemoteAddress
  )
{
  return KsSendRecvUdp(Socket, Buffer, Length, Flags, RemoteAddress, TRUE);
}

NTSTATUS
NTAPI
KsRecvFrom(
  _In_ PKSOCKET Socket,
  _In_ PVOID Buffer,
  _Inout_ PULONG Length,
  _In_ ULONG Flags,
  _In_ PSOCKADDR RemoteAddress
  )
{
  return KsSendRecvUdp(Socket, Buffer, Length, Flags, RemoteAddress, FALSE);
}

```

`src/ksocket/ksocket.h`:

```h
#pragma once
#include <ntddk.h>
#include <wsk.h>

#ifdef __cplusplus
extern "C" {
#endif

typedef struct _KSOCKET KSOCKET, *PKSOCKET;

NTSTATUS
NTAPI
KsInitialize(
  VOID
  );

VOID
NTAPI
KsDestroy(
  VOID
  );

NTSTATUS
NTAPI
KsGetAddrInfo(
  _In_ PUNICODE_STRING NodeName,
  _In_ PUNICODE_STRING ServiceName,
  _In_ PADDRINFOEXW Hints,
  _Out_ PADDRINFOEXW* Result
  );

VOID
NTAPI
KsFreeAddrInfo(
  _In_ PADDRINFOEXW AddrInfo
  );

NTSTATUS
NTAPI
KsCreateSocket(
  _Out_ PKSOCKET* Socket,
  _In_ ADDRESS_FAMILY AddressFamily,
  _In_ USHORT SocketType,
  _In_ ULONG Protocol,
  _In_ ULONG Flags
  );

NTSTATUS
NTAPI
KsCreateConnectionSocket(
  _Out_ PKSOCKET* Socket,
  _In_ ADDRESS_FAMILY AddressFamily,
  _In_ USHORT SocketType,
  _In_ ULONG Protocol
  );

NTSTATUS
NTAPI
KsCreateListenSocket(
  _Out_ PKSOCKET* Socket,
  _In_ ADDRESS_FAMILY AddressFamily,
  _In_ USHORT SocketType,
  _In_ ULONG Protocol
  );

NTSTATUS
NTAPI
KsCreateDatagramSocket(
  _Out_ PKSOCKET* Socket,
  _In_ ADDRESS_FAMILY AddressFamily,
  _In_ USHORT SocketType,
  _In_ ULONG Protocol
  );

NTSTATUS
NTAPI
KsCloseSocket(
  _In_ PKSOCKET Socket
  );

NTSTATUS
NTAPI
KsBind(
  _In_ PKSOCKET Socket,
  _In_ PSOCKADDR LocalAddress
  );

NTSTATUS
NTAPI
KsAccept(
  _In_ PKSOCKET Socket,
  _Out_ PKSOCKET* NewSocket,
  _Out_opt_ PSOCKADDR LocalAddress,
  _Out_opt_ PSOCKADDR RemoteAddress
  );

NTSTATUS
NTAPI
KsConnect(
  _In_ PKSOCKET Socket,
  _In_ PSOCKADDR RemoteAddress
  );

NTSTATUS
NTAPI
KsSendRecv(
  _In_ PKSOCKET Socket,
  _In_ PVOID Buffer,
  _Inout_ PULONG Length,
  _In_ ULONG Flags,
  _In_ BOOLEAN Send
  );

NTSTATUS
NTAPI
KsSendRecvUdp(
  _In_ PKSOCKET Socket,
  _In_ PVOID Buffer,
  _Inout_ PULONG Length,
  _In_ ULONG Flags,
  _In_ PSOCKADDR RemoteAddress,
  _In_ BOOLEAN Send
  );

NTSTATUS
NTAPI
KsSend(
  _In_ PKSOCKET Socket,
  _In_ PVOID Buffer,
  _Inout_ PULONG Length,
  _In_ ULONG Flags
  );

NTSTATUS
NTAPI
KsRecv(
  _In_ PKSOCKET Socket,
  _In_ PVOID Buffer,
  _Inout_ PULONG Length,
  _In_ ULONG Flags
  );

NTSTATUS
NTAPI
KsSendTo(
  _In_ PKSOCKET Socket,
  _In_ PVOID Buffer,
  _Inout_ PULONG Length,
  _In_ ULONG Flags,
  _In_ PSOCKADDR RemoteAddress
  );

NTSTATUS
NTAPI
KsRecvFrom(
  _In_ PKSOCKET Socket,
  _In_ PVOID Buffer,
  _Inout_ PULONG Length,
  _In_ ULONG Flags,
  _In_ PSOCKADDR RemoteAddress
  );

#ifdef __cplusplus
}
#endif

```

`src/ksocket/ksocket.inf`:

```inf
;
; ksocket.inf
;

[Version]
Signature="$WINDOWS NT$"
Class=Sample ; TODO: edit Class
ClassGuid={78A1C341-4539-11d3-B88D-00C04FAD5171} ; TODO: edit ClassGuid
Provider=%ManufacturerName%
CatalogFile=ksocket.cat
DriverVer= ; TODO: set DriverVer in stampinf property pages

[DestinationDirs]
DefaultDestDir = 12
ksocket_Device_CoInstaller_CopyFiles = 11

; ================= Class section =====================

[ClassInstall32]
Addreg=SampleClassReg

[SampleClassReg]
HKR,,,0,%ClassName%
HKR,,Icon,,-5

[SourceDisksNames]
1 = %DiskName%,,,""

[SourceDisksFiles]
ksocket.sys  = 1,,
WdfCoInstaller$KMDFCOINSTALLERVERSION$.dll=1 ; make sure the number matches with SourceDisksNames

;*****************************************
; Install Section
;*****************************************

[Manufacturer]
%ManufacturerName%=Standard,NT$ARCH$

[Standard.NT$ARCH$]
%ksocket.DeviceDesc%=ksocket_Device, Root\ksocket ; TODO: edit hw-id

[ksocket_Device.NT]
CopyFiles=Drivers_Dir

[Drivers_Dir]
ksocket.sys

;-------------- Service installation
[ksocket_Device.NT.Services]
AddService = ksocket,%SPSVCINST_ASSOCSERVICE%, ksocket_Service_Inst

; -------------- ksocket driver install sections
[ksocket_Service_Inst]
DisplayName    = %ksocket.SVCDESC%
ServiceType    = 1               ; SERVICE_KERNEL_DRIVER
StartType      = 3               ; SERVICE_DEMAND_START
ErrorControl   = 1               ; SERVICE_ERROR_NORMAL
ServiceBinary  = %12%\ksocket.sys

;
;--- ksocket_Device Coinstaller installation ------
;

[Strings]
SPSVCINST_ASSOCSERVICE= 0x00000002
ManufacturerName="<Your manufacturer name>" ;TODO: Replace with your manufacturer name
ClassName="Samples" ; TODO: edit ClassName
DiskName = "ksocket Installation Disk"
ksocket.DeviceDesc = "ksocket Device"
ksocket.SVCDESC = "ksocket Service"

```

`src/ksocket/ksocket.vcxproj`:

```vcxproj
<?xml version="1.0" encoding="utf-8"?>
<Project DefaultTargets="Build" ToolsVersion="12.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <!-- ProjectConfigurations -->
  <ItemGroup Label="ProjectConfigurations">
    <ProjectConfiguration Include="Debug|Win32">
      <Configuration>Debug</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|Win32">
      <Configuration>Release</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug|x64">
      <Configuration>Debug</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|x64">
      <Configuration>Release</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
  </ItemGroup>
  <!-- Common settings -->
  <PropertyGroup Label="Globals">
    <RootNamespace>ksocket</RootNamespace>
    <ProjectGuid>{46A74761-6CFA-41AF-A536-47F08E2C7B48}</ProjectGuid>
    <TemplateGuid>{1bc93793-694f-48fe-9372-81e2b05556fd}</TemplateGuid>
    <TargetFrameworkVersion>v4.5</TargetFrameworkVersion>
    <MinimumVisualStudioVersion>12.0</MinimumVisualStudioVersion>
    <Configuration>Debug</Configuration>
    <Platform Condition="'$(Platform)' == ''">Win32</Platform>
    <WindowsTargetPlatformVersion>$(LatestTargetPlatformVersion)</WindowsTargetPlatformVersion>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
  <PropertyGroup Label="Configuration">
    <TargetVersion>Windows7</TargetVersion>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>WDM</DriverType>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
  <ImportGroup Label="ExtensionSettings" />
  <ImportGroup Label="PropertySheets">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <PropertyGroup>
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
    <IncludePath>$(ProjectDir);$(VC_IncludePath);$(IncludePath);$(KMDF_INC_PATH)$(KMDF_VER_PATH)</IncludePath>
    <OutDir>$(SolutionDir)bin\$(PlatformShortName)\$(Configuration)\</OutDir>
    <IntDir>$(SolutionDir)bin\obj\$(PlatformShortName)\$(Configuration)\$(ProjectName)\</IntDir>
    <EnableInf2cat>false</EnableInf2cat>
    <Inf2CatUseLocalTime>true</Inf2CatUseLocalTime>
  </PropertyGroup>
  <ItemDefinitionGroup>
    <ClCompile>
      <DisableSpecificWarnings>4201;4748;%(DisableSpecificWarnings)</DisableSpecificWarnings>
      <!--                     4201;4603;4627;4986;4987;4996;%(DisableSpecificWarnings) -->
      <LanguageStandard>stdcpplatest</LanguageStandard>
      <ObjectFileName>$(IntDir)%(RelativeDir)%(Filename)%(Extension).obj</ObjectFileName>
      <MultiProcessorCompilation>true</MultiProcessorCompilation>
      <SupportJustMyCode>false</SupportJustMyCode>
    </ClCompile>
    <Link>
      <GenerateDebugInformation>DebugFull</GenerateDebugInformation>
      <AdditionalLibraryDirectories Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">netio.lib</AdditionalLibraryDirectories>
      <AdditionalLibraryDirectories Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
      </AdditionalLibraryDirectories>
      <AdditionalDependencies Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">netio.lib;%(AdditionalDependencies);$(KernelBufferOverflowLib);$(DDK_LIB_PATH)ntoskrnl.lib;$(DDK_LIB_PATH)hal.lib;$(DDK_LIB_PATH)wmilib.lib</AdditionalDependencies>
      <AdditionalDependencies Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">netio.lib;%(AdditionalDependencies);$(KernelBufferOverflowLib);$(DDK_LIB_PATH)ntoskrnl.lib;$(DDK_LIB_PATH)hal.lib;$(DDK_LIB_PATH)wmilib.lib</AdditionalDependencies>
    </Link>
  </ItemDefinitionGroup>
  <!-- Debug -->
  <PropertyGroup Condition="'$(Configuration)'=='Debug'" Label="Configuration">
    <UseDebugLibraries>true</UseDebugLibraries>
  </PropertyGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)'=='Debug'">
  </ItemDefinitionGroup>
  <!-- Release -->
  <PropertyGroup Condition="'$(Configuration)'=='Release'" Label="Configuration">
    <UseDebugLibraries>false</UseDebugLibraries>
  </PropertyGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)'=='Release'">
    <ClCompile>
      <InlineFunctionExpansion>AnySuitable</InlineFunctionExpansion>
      <WholeProgramOptimization>true</WholeProgramOptimization>
    </ClCompile>
    <Link>
      <LinkTimeCodeGeneration>UseLinkTimeCodeGeneration</LinkTimeCodeGeneration>
      <AdditionalLibraryDirectories Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">netio.lib</AdditionalLibraryDirectories>
      <AdditionalLibraryDirectories Condition="'$(Configuration)|$(Platform)'=='Release|x64'">netio.lib</AdditionalLibraryDirectories>
      <AdditionalDependencies Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">netio.lib;%(AdditionalDependencies);$(KernelBufferOverflowLib);$(DDK_LIB_PATH)ntoskrnl.lib;$(DDK_LIB_PATH)hal.lib;$(DDK_LIB_PATH)wmilib.lib</AdditionalDependencies>
      <AdditionalDependencies Condition="'$(Configuration)|$(Platform)'=='Release|x64'">netio.lib;%(AdditionalDependencies);$(KernelBufferOverflowLib);$(DDK_LIB_PATH)ntoskrnl.lib;$(DDK_LIB_PATH)hal.lib;$(DDK_LIB_PATH)wmilib.lib</AdditionalDependencies>
    </Link>
  </ItemDefinitionGroup>
  <!-- Targets -->
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
  <!-- Items -->
  <ItemGroup>
    <Inf Include="ksocket.inf">
      <ExcludedFromBuild Condition="'$(Configuration)'=='Debug'">true</ExcludedFromBuild>
    </Inf>
  </ItemGroup>
  <ItemGroup>
    <FilesToPackage Include="$(TargetPath)" />
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="berkeley.c" />
    <ClCompile Include="main.c" />
    <ClCompile Include="ksocket.c" />
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="berkeley.h" />
    <ClInclude Include="ksocket.h" />
  </ItemGroup>
</Project>
```

`src/ksocket/ksocket.vcxproj.filters`:

```filters
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup>
    <Filter Include="Source Files">
      <UniqueIdentifier>{4FC737F1-C7A5-4376-A066-2A32D752A2FF}</UniqueIdentifier>
      <Extensions>cpp;c;cc;cxx;def;odl;idl;hpj;bat;asm;asmx</Extensions>
    </Filter>
    <Filter Include="Header Files">
      <UniqueIdentifier>{93995380-89BD-4b04-88EB-625FBE52EBFB}</UniqueIdentifier>
      <Extensions>h;hpp;hxx;hm;inl;inc;xsd</Extensions>
    </Filter>
    <Filter Include="Resource Files">
      <UniqueIdentifier>{67DA6AB6-F800-4c08-8B7A-83BB121AAD01}</UniqueIdentifier>
      <Extensions>rc;ico;cur;bmp;dlg;rc2;rct;bin;rgs;gif;jpg;jpeg;jpe;resx;tiff;tif;png;wav;mfcribbon-ms</Extensions>
    </Filter>
    <Filter Include="Driver Files">
      <UniqueIdentifier>{8E41214B-6785-4CFE-B992-037D68949A14}</UniqueIdentifier>
      <Extensions>inf;inv;inx;mof;mc;</Extensions>
    </Filter>
  </ItemGroup>
  <ItemGroup>
    <Inf Include="ksocket.inf">
      <Filter>Driver Files</Filter>
    </Inf>
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="main.c">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="berkeley.c">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="ksocket.c">
      <Filter>Source Files</Filter>
    </ClCompile>
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="berkeley.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="ksocket.h">
      <Filter>Header Files</Filter>
    </ClInclude>
  </ItemGroup>
</Project>
```

`src/ksocket/main.c`:

```c
#include "ksocket.h"
#include "berkeley.h"

#define DebuggerPrint(...) DbgPrintEx(DPFLTR_IHVDRIVER_ID, DPFLTR_ERROR_LEVEL, __VA_ARGS__);

NTSTATUS
NTAPI
DriverEntry(
  _In_ PDRIVER_OBJECT DriverObject,
  _In_ PUNICODE_STRING RegistryPath
  )
{
  UNREFERENCED_PARAMETER(DriverObject);
  UNREFERENCED_PARAMETER(RegistryPath);

  NTSTATUS Status;

  //
  // Initialize KSOCKET.
  //

  Status = KsInitialize();

  if (!NT_SUCCESS(Status))
  {
    return Status;
  }

  //
  // Client.
  // Perform HTTP request to http://httpbin.org/uuid
  //

  {
    int result;

    char send_buffer[] =
      "GET /uuid HTTP/1.1\r\n"
      "Host: httpbin.org\r\n"
      "Connection: close\r\n"
      "\r\n";

    char recv_buffer[1024] = { 0 };

    struct addrinfo hints = { 0 };
    hints.ai_flags |= AI_CANONNAME;
    hints.ai_family = AF_UNSPEC;
    hints.ai_socktype = SOCK_STREAM;

    struct addrinfo *res;
    result = getaddrinfo("httpbin.org", "80", &hints, &res);

    int sockfd;
    sockfd = socket_connection(AF_INET, SOCK_STREAM, IPPROTO_TCP);
    result = connect(sockfd, res->ai_addr, (int)res->ai_addrlen);
    result = send(sockfd, send_buffer, sizeof(send_buffer), 0);
    result = recv(sockfd, recv_buffer, sizeof(recv_buffer), 0);
    recv_buffer[sizeof(recv_buffer) - 1] = '\0';

    DebuggerPrint("TCP client:\n%s\n", recv_buffer);

    closesocket(sockfd);
  }

  //
  // TCP server.
  // Listen on port 9095, wait for some message,
  // then send our buffer and close connection.
  //
  // Try:
  // > nc 127.0.0.1 9095 [enter]
  // > HELLO FROM USERMODE! [enter]
  // > Hello from WSK! [expected response]
  //

  {
    int result;

    char send_buffer[] = "Hello from WSK!";
    char recv_buffer[1024] = { 0 };

    int server_sockfd = socket_listen(AF_INET, SOCK_STREAM, 0);

    struct sockaddr_in addr;
    addr.sin_family = AF_INET;
    addr.sin_addr.s_addr = INADDR_ANY;
    addr.sin_port = htons(9095);

    result = bind(server_sockfd, (struct sockaddr*)&addr, sizeof(addr));
    result = listen(server_sockfd, 1);

    socklen_t addrlen = sizeof(addr);
    int client_sockfd = accept(server_sockfd, (struct sockaddr*)&addr, &addrlen);

    result = recv(client_sockfd, recv_buffer, sizeof(recv_buffer) - 1, 0);
    recv_buffer[sizeof(recv_buffer) - 1] = '\0';

    DebuggerPrint("TCP server:\n%s\n", recv_buffer);

    result = send(client_sockfd, send_buffer, sizeof(send_buffer), 0);

    closesocket(client_sockfd);
    closesocket(server_sockfd);
  }

  //
  // Destroy KSOCKET.
  //

  KsDestroy();

  //
  // Unload the driver immediately.
  //

  return STATUS_UNSUCCESSFUL;
}

```