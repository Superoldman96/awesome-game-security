Project Path: arc_gmh5225_RisohEditor_2xp2_jzq

Source Tree:

```txt
arc_gmh5225_RisohEditor_2xp2_jzq
├── CMakeLists.txt
├── EGA
├── EGA-samples
│   ├── Censorship.ega
│   ├── DeleteNonEnglish.ega
│   ├── NeutralToEnglish.ega
│   ├── RES_clone_by_lang.ega
│   ├── RES_delete.ega
│   ├── RES_select.ega
│   ├── RES_set_binary.ega
│   ├── RES_set_text.ega
│   ├── RES_str_get.ega
│   └── RES_str_set.ega
├── FUNDING.yml
├── HISTORY-ID.txt
├── HISTORY-ITA.txt
├── HISTORY-JPN.txt
├── HISTORY-KOR.txt
├── HISTORY-PTB.txt
├── HISTORY.txt
├── HYOJUNKA.md
├── HYOJUNKA.txt
├── HowToBuild.md
├── LICENSE.txt
├── Languages
│   └── Korean.isl
├── LineNumEdit
├── MyWndCtrl
│   ├── CMakeLists.txt
│   ├── MWindowBase.hpp
│   └── MyWndCtrl.cpp
├── README-ID.txt
├── README-ITA.txt
├── README-JPN.txt
├── README-KOR.txt
├── README-PTB.txt
├── README-TR.txt
├── README.md
├── README.txt
├── Standardize.md
├── TRANSLATORS.txt
├── WonSetThreadUILanguage
├── build.cmd
├── data
│   ├── Constants.txt
│   ├── bin
│   │   ├── dfmsc.exe
│   │   ├── libgcc_s_dw2-1.dll
│   │   ├── libwinpthread-1.dll
│   │   ├── mcpp.exe
│   │   ├── midlwrap.bat
│   │   ├── olebow.exe
│   │   ├── upx.exe
│   │   └── windres.exe
│   └── lib
│       └── gcc
│           └── i686-w64-mingw32
│               └── 10.2.0
│                   └── include
│                       ├── afxres.h
│                       ├── commctrl.h
│                       ├── dlgs.h
│                       ├── windef.h
│                       ├── windows.h
│                       ├── winnt.h
│                       ├── winresrc.h
│                       ├── winuser.h
│                       └── winver.h
├── installer.iss
├── mcdx
│   ├── CMakeLists.txt
│   ├── FindIconv.cmake
│   ├── MESSAGETABLEDX.md
│   ├── README.txt
│   ├── getoptwin.c
│   ├── getoptwin.h
│   └── mcdx.cpp
├── re-icon.png
├── src
│   ├── AccelRes.cpp
│   ├── AccelRes.hpp
│   ├── CMakeLists.txt
│   ├── Common.hpp
│   ├── ConstantsDB.hpp
│   ├── DialogRes.cpp
│   ├── DialogRes.hpp
│   ├── DlgInit.h
│   ├── DlgInitRes.cpp
│   ├── DlgInitRes.hpp
│   ├── IconRes.cpp
│   ├── IconRes.hpp
│   ├── MAddBitmapDlg.hpp
│   ├── MAddCtrlDlg.hpp
│   ├── MAddCursorDlg.hpp
│   ├── MAddIconDlg.hpp
│   ├── MAddResDlg.hpp
│   ├── MAddResIDDlg.hpp
│   ├── MAdviceResHDlg.hpp
│   ├── MBitmapDx.hpp
│   ├── MBmpView.hpp
│   ├── MByteStream.hpp
│   ├── MByteStreamEx.hpp
│   ├── MChooseLangDlg.hpp
│   ├── MCloneInNewLangDlg.hpp
│   ├── MCloneInNewNameDlg.hpp
│   ├── MComboBox.hpp
│   ├── MComboBoxAutoComplete.hpp
│   ├── MConfigDlg.hpp
│   ├── MConstantDlg.hpp
│   ├── MCopyToMultiLangDlg.hpp
│   ├── MCtrlDataDlg.hpp
│   ├── MCtrlPropDlg.hpp
│   ├── MDfmSettingsDlg.hpp
│   ├── MDialogFontSubstDlg.hpp
│   ├── MDlgInitDlg.hpp
│   ├── MDlgPropDlg.hpp
│   ├── MDropdownArrow.hpp
│   ├── MEditAccelDlg.hpp
│   ├── MEditCtrl.hpp
│   ├── MEditMenuDlg.hpp
│   ├── MEditToolbarDlg.hpp
│   ├── MEgaDlg.hpp
│   ├── MEncodingDlg.hpp
│   ├── MExportOptionsDlg.hpp
│   ├── MFile.hpp
│   ├── MFontsDlg.hpp
│   ├── MHyperLinkCtrl.hpp
│   ├── MIDListDlg.hpp
│   ├── MIdAssocDlg.hpp
│   ├── MIdOrString.hpp
│   ├── MIndexLabels.hpp
│   ├── MItemSearchDlg.hpp
│   ├── MLangAutoComplete.hpp
│   ├── MLangsDlg.hpp
│   ├── MMacrosDlg.hpp
│   ├── MMessagesDlg.hpp
│   ├── MModifyAssocDlg.hpp
│   ├── MModifyResIDDlg.hpp
│   ├── MOleHost.cpp
│   ├── MOleHost.hpp
│   ├── MPathsDlg.hpp
│   ├── MPointSizeRect.hpp
│   ├── MProcessMaker.hpp
│   ├── MRadWindow.hpp
│   ├── MRegKey.hpp
│   ├── MRegKeyPortable.hpp
│   ├── MReplaceBinDlg.hpp
│   ├── MReplaceBitmapDlg.hpp
│   ├── MReplaceCursorDlg.hpp
│   ├── MReplaceIconDlg.hpp
│   ├── MResizable.hpp
│   ├── MRubberBand.hpp
│   ├── MSaveOptionsDlg.hpp
│   ├── MScrollBar.hpp
│   ├── MSplitterWnd.hpp
│   ├── MString.hpp
│   ├── MStringListDlg.hpp
│   ├── MStringsDlg.hpp
│   ├── MTabCtrl.hpp
│   ├── MTestDialog.hpp
│   ├── MTestMenuDlg.hpp
│   ├── MTestParentWnd.hpp
│   ├── MTextToText.hpp
│   ├── MToolBarCtrl.hpp
│   ├── MVersionInfoDlg.hpp
│   ├── MWaitCursor.hpp
│   ├── MWindowBase.hpp
│   ├── MacroParser.hpp
│   ├── MenuRes.cpp
│   ├── MenuRes.hpp
│   ├── MessageRes.hpp
│   ├── PackedDIB.cpp
│   ├── PackedDIB.hpp
│   ├── Res.cpp
│   ├── Res.hpp
│   ├── ResHeader.hpp
│   ├── ResToText.cpp
│   ├── ResToText.hpp
│   ├── RisohEditor.cpp
│   ├── RisohEditor.hpp
│   ├── RisohEditor_res.rc
│   ├── RisohSettings.hpp
│   ├── StringRes.cpp
│   ├── StringRes.hpp
│   ├── Toolbar.h
│   ├── ToolbarRes.cpp
│   ├── ToolbarRes.hpp
│   ├── UTF16_validator.h
│   ├── UTF8_validator.h
│   ├── VersionRes.cpp
│   ├── VersionRes.hpp
│   ├── lang
│   │   ├── de_DE.rc
│   │   ├── en_US.rc
│   │   ├── fi_FI.rc
│   │   ├── fr_FR.rc
│   │   ├── id_ID.rc
│   │   ├── it_IT.rc
│   │   ├── ja_JP.rc
│   │   ├── ko_KR.rc
│   │   ├── pl_PL.rc
│   │   ├── pt_BR.rc
│   │   ├── ru_RU.rc
│   │   ├── zh_CN.rc
│   │   └── zh_TW.rc
│   ├── pstdbool.h
│   ├── pstdint.h
│   ├── res
│   │   ├── 1028_RISOHTEMPLATE_4.bin
│   │   ├── 1028_RISOHTEMPLATE_5.bin
│   │   ├── 1031_RISOHTEMPLATE_4.bin
│   │   ├── 1031_RISOHTEMPLATE_5.bin
│   │   ├── 1033_RISOHTEMPLATE_4.bin
│   │   ├── 1033_RISOHTEMPLATE_5.bin
│   │   ├── 1035_RISOHTEMPLATE_4.bin
│   │   ├── 1035_RISOHTEMPLATE_5.bin
│   │   ├── 1036_RISOHTEMPLATE_4.bin
│   │   ├── 1036_RISOHTEMPLATE_5.bin
│   │   ├── 1040_RISOHTEMPLATE_4.bin
│   │   ├── 1040_RISOHTEMPLATE_5.bin
│   │   ├── 1041_RISOHTEMPLATE_4.bin
│   │   ├── 1041_RISOHTEMPLATE_5.bin
│   │   ├── 1042_RISOHTEMPLATE_4.bin
│   │   ├── 1042_RISOHTEMPLATE_5.bin
│   │   ├── 1045_RISOHTEMPLATE_4.bin
│   │   ├── 1045_RISOHTEMPLATE_5.bin
│   │   ├── 1046_RISOHTEMPLATE_4.bin
│   │   ├── 1046_RISOHTEMPLATE_5.bin
│   │   ├── 1049_RISOHTEMPLATE_4.bin
│   │   ├── 1049_RISOHTEMPLATE_5.bin
│   │   ├── 1057_RISOHTEMPLATE_4.bin
│   │   ├── 1057_RISOHTEMPLATE_5.bin
│   │   ├── 2052_RISOHTEMPLATE_4.bin
│   │   ├── 2052_RISOHTEMPLATE_5.bin
│   │   ├── 999_105.bin
│   │   ├── AniCursor_103.ani
│   │   ├── Avi_100.avi
│   │   ├── Bitmap_100.bmp
│   │   ├── Bitmap_101.bmp
│   │   ├── Bitmap_102.bmp
│   │   ├── Cursor_101.cur
│   │   ├── Cursor_102.cur
│   │   ├── Emf_100.emf
│   │   ├── Gif_100.gif
│   │   ├── Icon_100.ico
│   │   ├── Icon_101.ico
│   │   ├── Icon_102.ico
│   │   ├── Icon_103.ico
│   │   ├── Icon_104.ico
│   │   ├── Icon_105.ico
│   │   ├── Icon_106.ico
│   │   ├── Icon_107.ico
│   │   ├── Icon_108.ico
│   │   ├── Icon_109.ico
│   │   ├── Icon_110.ico
│   │   ├── Manifest_1.manifest
│   │   ├── Png_100.png
│   │   ├── RCData_100.bin
│   │   ├── RCData_106.bin
│   │   ├── RCData_107.bin
│   │   ├── RISOHTEMPLATE_11.bin
│   │   ├── RISOHTEMPLATE_16.bin
│   │   ├── RISOHTEMPLATE_23.bin
│   │   ├── RISOHTEMPLATE_24.bin
│   │   ├── RISOHTEMPLATE_241.bin
│   │   ├── RISOHTEMPLATE_6.bin
│   │   ├── RISOHTEMPLATE_9.bin
│   │   ├── RISOHTEMPLATE_RISOHTEMPLATE.bin
│   │   └── Wave_100.wav
│   ├── resource.h
│   ├── svg
│   │   ├── RisohEditor.svg
│   │   ├── arrow.svg
│   │   ├── canceledit.svg
│   │   ├── change.svg
│   │   ├── clone.svg
│   │   ├── collapse.svg
│   │   ├── expand.svg
│   │   ├── extract.svg
│   │   ├── guiedit.svg
│   │   ├── guiedit2.svg
│   │   ├── import.svg
│   │   ├── minus.svg
│   │   ├── new.svg
│   │   ├── open.svg
│   │   ├── plus.svg
│   │   ├── recompile.svg
│   │   ├── save.svg
│   │   ├── test.svg
│   │   └── tools.svg
│   ├── wondef.h
│   └── wonnt.h
├── tests
│   ├── CMakeLists.txt
│   ├── ResTest
│   │   ├── CMakeLists.txt
│   │   ├── ResTest.cpp
│   │   ├── ResTest.exe.manifest
│   │   ├── ResTest_res.rc
│   │   ├── dummy.bmp
│   │   ├── dummy.ico
│   │   ├── emf.emf
│   │   ├── html.html
│   │   ├── resource.h
│   │   └── smily.ico
│   ├── ResTest2
│   │   ├── CMakeLists.txt
│   │   ├── ResTest2.cpp
│   │   ├── ResTest2_res.rc
│   │   └── resource.h
│   ├── ToolbarTest
│   │   ├── CMakeLists.txt
│   │   ├── ToolbarTest.cpp
│   │   ├── ToolbarTest_res.rc
│   │   ├── lang
│   │   │   └── en_US.rc
│   │   ├── res
│   │   │   └── Bitmap_100.bmp
│   │   └── resource.h
│   └── cmdline
│       ├── CMakeLists.txt
│       ├── LICENSE.txt
│       └── cmdline.cpp
└── win32-samples
    ├── DialogBox
    │   ├── CMakeLists.txt
    │   ├── DialogBox.cpp
    │   ├── DialogBox_res.rc
    │   ├── lang
    │   │   └── en_US.rc
    │   └── resource.h
    ├── MainWnd
    │   ├── CMakeLists.txt
    │   ├── MainWnd.cpp
    │   ├── MainWnd_res.rc
    │   ├── lang
    │   │   └── en_US.rc
    │   ├── res
    │   │   └── Icon_100.ico
    │   └── resource.h
    └── ToolbarTest
        ├── CMakeLists.txt
        ├── ToolbarTest.cpp
        ├── ToolbarTest_res.rc
        ├── lang
        │   └── en_US.rc
        ├── res
        │   └── Bitmap_100.bmp
        └── resource.h

```

`CMakeLists.txt`:

```txt
# CMakeLists.txt --- CMake project settings
#    ex) cmake -G "Visual Studio 9 2008" .
#    ex) cmake -DCMAKE_BUILD_TYPE=Release -G "MSYS Makefiles" .
##############################################################################

# CMake minimum version
cmake_minimum_required(VERSION 2.9)

# use new policy
cmake_policy(SET CMP0054 NEW)
cmake_policy(SET CMP0003 NEW)

# project name and languages
project(RisohEditor CXX RC)

# check build type
if (NOT CMAKE_BUILD_TYPE)
    message(STATUS "No build type selected, default to Debug")
    set(CMAKE_BUILD_TYPE "Debug")
endif()

# make uppercase string of build type
string(TOUPPER "${CMAKE_BUILD_TYPE}" uppercase_CMAKE_BUILD_TYPE)

# check build type again
if (NOT uppercase_CMAKE_BUILD_TYPE MATCHES "^(DEBUG|RELEASE|RELWITHDEBINFO|MINSIZEREL)$")
    message(FATAL_ERROR "Invalid value for CMAKE_BUILD_TYPE: ${CMAKE_BUILD_TYPE}")
endif()

# set output directory (build/)
set(CMAKE_ARCHIVE_OUTPUT_DIRECTORY ${CMAKE_BINARY_DIR}/build)
set(CMAKE_RUNTIME_OUTPUT_DIRECTORY ${CMAKE_BINARY_DIR}/build)
set(CMAKE_LIBRARY_OUTPUT_DIRECTORY ${CMAKE_BINARY_DIR}/build)

# Win32 or not?
if (NOT WIN32)
    message(FATAL_ERROR "You must use a Win32 compiler")
endif()

# statically link
if (WIN32)
    if (CMAKE_CXX_COMPILER_ID STREQUAL "Clang")
        # using Clang
        set(CMAKE_C_FLAGS "-static -W -Wno-missing-field-initializers")
        set(CMAKE_CXX_FLAGS "-static -W -Wno-missing-field-initializers")
    elseif (CMAKE_CXX_COMPILER_ID STREQUAL "GNU")
        # using GCC
        set(CMAKE_C_FLAGS "-static -W -Wno-missing-field-initializers")
        set(CMAKE_CXX_FLAGS "-static -W -Wno-missing-field-initializers")
    elseif (MSVC)
        # replace "/MD" with "/MT" (building without runtime DLLs)
        set(CompilerFlags
            CMAKE_C_FLAGS
            CMAKE_C_FLAGS_DEBUG
            CMAKE_C_FLAGS_RELEASE
            CMAKE_C_FLAGS_MINSIZEREL
            CMAKE_C_FLAGS_RELWITHDEBINFO
            CMAKE_CXX_FLAGS
            CMAKE_CXX_FLAGS_DEBUG
            CMAKE_CXX_FLAGS_RELEASE
            CMAKE_CXX_FLAGS_MINSIZEREL
            CMAKE_CXX_FLAGS_RELWITHDEBINFO)
        foreach(CompilerFlags ${CompilerFlags})
            string(REPLACE "/MD" "/MT" ${CompilerFlags} "${${CompilerFlags}}")
        endforeach()
    endif()
endif()

##############################################################################

include_directories(WonSetThreadUILanguage)

add_definitions(-DMZC4_HANDLE_MAP=1 -DUSE_GLOBALS=1)
add_definitions(-D_CRT_SECURE_NO_WARNINGS -D_CRT_NON_CONFORMING_WCSTOK -D_SCL_SECURE_NO_WARNINGS)

include_directories(EGA)
add_subdirectory(EGA)

include_directories(LineNumEdit)
add_subdirectory(LineNumEdit)

add_subdirectory(src)
add_subdirectory(tests)
add_subdirectory(mcdx)
add_subdirectory(MyWndCtrl)

##############################################################################

```

`EGA-samples/Censorship.ega`:

```ega
@ Censorship.ega
=(ForbiddenWords, { "開く", "編集", "酒" });
=(res, RES_search());
foreach(item, res, (
    =(bin, RES_get_binary([](item, 0), [](item, 1), [](item, 2))),
    foreach(text, ForbiddenWords, (
        if(or(!=(find(bin, text), -(1)), !=(find(bin, u16fromu8(text)), -(1))), (
            println(cat(
                "Forbidden Word '",
                text,
                "' found in { ",
                str([](item, 0)), ", ",
                str([](item, 1)), ", ",
                str([](item, 2)),
                " }."
            ))
        ))
    ))
));

```

`EGA-samples/DeleteNonEnglish.ega`:

```ega
@ Delete non-Neutral (0) and non-English (1033) resources.
=(res, RES_search());
foreach(item, res, (
    =(type, [](item, 0)),
    =(name, [](item, 1)),
    =(lang, [](item, 2)),
    if(&&(!=(lang, 0), !=(lang, 1033)), (
        RES_delete(type, name, lang)
    ))
));

```

`EGA-samples/NeutralToEnglish.ega`:

```ega
@ Clone all Neutral (0) resources to English (1033) resources.
RES_clone_by_lang(0, 0, 0, 1033);

@ Erase all Neutral (0) resources.
RES_delete(0, 0, 0);

```

`EGA-samples/RES_clone_by_lang.ega`:

```ega
@ Clone English (1033) resources as Japanese (1041) resources.
RES_clone_by_lang(0, 0, 1033, 1041);

```

`EGA-samples/RES_delete.ega`:

```ega
@ Delete Japanese (1041) resources all.
RES_delete(0, 0, 1041);

```

`EGA-samples/RES_select.ega`:

```ega
@ Search and select the resource item that contains Japanese text "開く".

=(res, RES_search());
=(text, u16fromu8("開く"));
foreach(item, res, (
    =(bin, RES_get_binary([](item, 0), [](item, 1), [](item, 2))),
    if(!=(find(bin, text), -(1)), (
        RES_select([](item, 0), [](item, 1), [](item, 2)),
        break()
    ))
));

```

`EGA-samples/RES_set_binary.ega`:

```ega
@ Add an Japanese (1041) RT_HTML (23) resource of name 1.
RES_set_binary(23, 1, 1041,
    binary(
        "<html><head>", 10,
        "<title>This is a test</title>", 10,
        "</head>", 10,
        "<body>", 10,
        "This is a test.", 10,
        "</body></html>", 10
    )
);

@ Select it.
RES_select(23, 1, 1041);

```

`EGA-samples/RES_set_text.ega`:

```ega
@ Set resource item of type 4 (RT_MENU), name 2, and language 1041 (Japanese) with text
println(RES_set_text(4, 2, 1041, "2 MENU { POPUP ""&File"" { MENUITEM ""E&xit\tAlt+F4"", 100 } }"));

@ Get resource item of type 4 (RT_MENU), name 2, and language 1041 (Japanese)
print(RES_get_text(4, 2, 1041));

```

`EGA-samples/RES_str_get.ega`:

```ega
@ Get the strings of an Japanese (1041) RT_STRING string table.
println(RES_str_get(1041));

@ Get the string 100 of an Japanese (1041) RT_STRING string table.
println(RES_str_get(1041, 100));

```

`EGA-samples/RES_str_set.ega`:

```ega
@ Set the strings of an Japanese (1041) RT_STRING string table.
RES_str_set(1041, {
	{ 100, "おはようございます" },
	{ 999, "さよなら" },
});

@ Set the string 100 to an Japanese (1041) RT_STRING string table.
RES_str_set(1041, 100, "こんにちは!");

```

`FUNDING.yml`:

```yml
# These are supported funding model platforms

github: [katahiromz] # Replace with up to 4 GitHub Sponsors-enabled usernames e.g., [user1, user2]
patreon: # Replace with a single Patreon username
open_collective: # Replace with a single Open Collective username
ko_fi: # Replace with a single Ko-fi username
tidelift: # Replace with a single Tidelift platform-name/package-name e.g., npm/babel
community_bridge: # Replace with a single Community Bridge project-name e.g., cloud-foundry
liberapay: # Replace with a single Liberapay username
issuehunt: # Replace with a single IssueHunt username
otechie: # Replace with a single Otechie username
custom: # Replace with up to 4 custom sponsorship URLs e.g., ['link1', 'link2']

```

`HISTORY-ID.txt`:

```txt
## SEJARAH

- v.0.6 (31-08-2017)
    - Rilisan pertama.
- v.5.0.8 (2018-09-12)
    - Peningkatan ikon bilah alat.
    - Perbaikan jenis file pada ekstraksi.
    - Tulis belati ke file sumber untuk membantu deteksi UTF-8.
    - Perbaikan ikon tampilan pohon.
    - Pemisahan templat sumber daya RT_DIALOG dan RT_MENU dalam bahasa.
- v.5.0.9 (27-09-2018)
    - Peningkatan keluaran resource.h.
    - Peningkatan ikon file treeview.
    - Meningkatkan impor.
- v.5.1.0 (2018-10-08)
    - Peningkatan dialog "Entri String" (multiline).
    - Perbaikan perilaku Ctrl+A.
    - Periksa kunci file saat menyimpan file.
    - Jadikan ID sumber daya peka huruf besar-kecil.
    - Dukungan pengkodean item sumber daya.
    - Perbaikan penghentian abnormal pada dialog "Bahasa".
- v.5.1.1 (2018-11-08)
    - Terima spasi di kotak teks keterangan.
    - Terima ruang di kotak teks bahasa.
- v.5.1.2 (2018-12-08)
    - Terima ruang di kotak teks nama kelas jendela.
    - Terima literal string C di kotak teks nama kelas jendela.
    - Peningkatan sistem templat.
    - Aktifkan templat manifes.
    - Perbaikan pembaruan bilah alat UI.
    - Menampilkan jenis ID "Daftar ID Sumber Daya" dengan benar.
    - Mengurutkan bahasa dengan benar saat keluar.
- v.5.1.3 (2019-01-01)
    - Perbaikan "Daftar ID Sumber Daya".
- v.5.1.4 (13-01-2019)
    - Tambahkan penginstal bahasa Inggris.
    - Tambahkan penginstal Italia.
    - Tambahkan terjemahan Italia.
    - Tambahkan beberapa penginstal bahasa.
- v.5.1.5 (27-01-2019)
    - Jangan gunakan gaya diperpanjang WS_EX_MDICHILD.
    - Mendukung ReactOS.
- v.5.1.6 (24-02-2019)
    - Peningkatan terjemahan bahasa Italia.
    - Penyesuaian GUI.
    - Perbaikan "Kloning Dalam Bahasa Baru".
- v.5.1.7 (20-03-2019)
    - Tambahkan gaya PBS_MARQUEE dan PBS_SMOOTHREVERSE.
    - Perbaikan proses kesalahan kompilasi.
- v.5.1.8 (2019-05-14)
    - Tambahkan cek kompilasi ulang setelah kloning.
    - Perbaikan pilihan setelah kloning.
    - Benar gagal pada kesalahan kompilasi tabel string dan tabel pesan.
- v.5.1.9 (2019-07-14)
    - Input/output sumber UTF-16 yang didukung.
- v.5.2.0 (26-07-2019)
    - Perlakukan nilai `DIALOG STYLE` dengan benar (`WS_CAPTION` adalah nilai default dari `DIALOG STYLE`).
    - Memperbaiki bug yang aplikasi tiba-tiba menghapus file saat membuka file EXE terkompresi tanpa memperluas.
- v.5.2.1 (04-08-2019)
    - "Bahasa Inggris (Amerika Serikat)" akan dipilih jika Anda memasukkan `"En"` untuk nama bahasa.
    - Tambahkan fitur "Permintaan Konstan".
    - Perbaikan "Tutup Semua".
    - `WS_POPUPWINDOW | WS_BORDER` harus `WS_POPUPWINDOW | WS_CAPTION`.
    - dukungan `RT_FONT`.
    - Dialog "Tambah Sumber Daya" yang ditingkatkan.
- v.5.2.2 (2019-08-14)
    - Perbarui terjemahan Italia.
    - Mendukung tipe sumber daya XML, XSLT, SCHEMA dan REGISTRY.
    - Peningkatan interpretasi ketika bahasa `RT_ICON`/`RT_CURSOR` dan `RT_GROUP_ICON`/`RT_GROUP_CURSOR` tidak cocok.
    - Peningkatan interpretasi saat ketidakcocokan bahasa `RT_DLGINIT` dan `RT_DIALOG`.
- v.5.2.3 (2019-09-14)
    - Perbaikan `AUTORADIOBUTTON` `GAYA`.
    - v.5.2.4 (2019-09-15)
    - Dukungan XP.
- v.5.2.5 (2019-09-19)
    - Memperbaiki bug `WS_CHILDWINDOW` di kotak daftar gaya dialog.
    - Mengubah nama file rilis (`RisohEditor-XXXexe` dan `RisohEditor-XXXzip`).
    - Menambahkan `TRANSLATORS.txt`.
    - Membuat kontrol yang ditarik pemilik terlihat.
- v.5.2.6 (23-09-2019)
    - Peningkatan dialog Bahasa.
    - Tambahkan terjemahan Rusia.
    - Tampilkan pesan kesalahan jika lokasi yang dipasang memiliki karakter spasi.
    - Tambahkan opsi `--use-temp-file` dalam menjalankan `windres` untuk memperbaiki masalah `popen`.
- v.5.2.7 (20-10-2019)
    - Dialog Bahasa yang ditingkatkan lagi.
    - Perbaikan posisi tanda item dialog.
- v.5.2.8 (2020-01-30)
    - Perbaikan terjemahan bahasa Rusia.
    - Mampu menampilkan kontrol yang tidak terdefinisi.
    - Menambahkan opsi "Gunakan BEGIN/END".
    - Memperbaiki bug yang DLL tidak dapat disimpan sebagai nama lain.
- v.5.2.9 (2020-02-01)
    - Dukungan XP untuk 5.2.8 dilupakan. Sekarang diaktifkan.
    - Memperbaiki pemrosesan penyimpanan file.
    - Mampu menyimpan file EXE/DLL tanpa executable milik pengguna.
    - Memperbaiki cara membuat cadangan.
- v.5.3.0 (2020-02-06)
    - Menambahkan `ES_AUTOHSCROLL` ke beberapa kotak teks.
    - Memperbaiki kesalahan logis saat menimpa file.
- v.5.3.1 (23-02-2020)
    - Perbaikan dan Peningkatan pembacaan/penampilan sumber daya menu.
    - Peningkatan penanganan `IDC_STATIC`.
    - Jendela "Daftar ID Sumber Daya" yang ditingkatkan.
- v.5.3.2 (2020-03-02)
    - Dapat menyimpan dengan `Ctrl+S` tanpa menanyakan lokasi.
    - Jadikan opsi "Output RC files as UTF-16" non-volatile.
    - Bawa jendela "Daftar ID Sumber Daya" ke atas.
- v.5.3.3 (2020-03-03)
    - Mengurangi ukuran file dari 9MB menjadi 3MB.
- v.5.3.4 (2020-03-19)
    - Mengubah perilaku tombol penyimpanan bilah alat.
    - Memperkenalkan otomatisasi dengan menggunakan bahasa pemrograman EGA.
    - Menambahkan konfirmasi untuk menyimpan perubahan file.
- v.5.3.5 (26-03-2020)
    - Peningkatan terjemahan bahasa Italia.
    - Perbaikan konfirmasi simpan yang tidak perlu.
- v.5.3.6 (15-04-2020)
    - Loop tak terbatas dihindari dengan mengubah variabel loop menjadi 32-bit.
    - Dukungan data Delphi DFM.
    - Menu konteks yang ditingkatkan.
- v.5.3.7 (28-04-2020)
    - Bendera perubahan file yang diperbarui saat file jatuh.
    - Memperbaiki nama file saat mengekstraksi.
    - EGA yang diperkuat.
    - Peningkatan terjemahan bahasa Rusia.
- v.5.3.8 (22-05-2020)
    - Menambahkan item "Buka Manual EGA" ke menu "Otomasi".
    - Mengontrol bendera perubahan file dengan ketat.
- v.5.3.9 (2020-06-01)
    - Menambahkan fitur "mengganti-dialog-font".
    - Memindahkan beberapa item menu ke menu "Edit".
    - Menambahkan nilai-nol-periksa nama sumber daya dan jenis sumber daya.
    - Menambahkan gaya `DS_CENTER` ke dialog sumber daya sampel.
    - Mengaktifkan tombol fungsi F1, F3, F5 dan F6.
    - Menambahkan versi Portable.
    - Fitur pencarian yang ditingkatkan.
- v.5.4.0 (2020-06-13)
    - Memperbaiki output `RT_ACCELERATOR` (unsigned 16-bit).
    - Menghapus opsi "Simpan ke folder res".
    - Memperbaiki kerusakan saat mengedit GUI.
    - Fitur ekstraksi yang diperkuat.
    - Memperbaiki fitur mengganti-dialog-font.
    - Menggunakan jalur lengkap untuk bilah judul.
    - Menambahkan panah bahasa drop-down.
    - Memperbaiki dialog "Permintaan Konstan".
    - Memperbaiki dialog "Encoding of Resource Item".
    - Dialog "Asosiasi ID" yang ditingkatkan.
    - Peningkatan dialog "Makro yang Ditentukan Sebelumnya".
    - Dialog "Konfigurasi" yang ditingkatkan.
    - Memperbaiki dialog "Cari".
    - Pesan status yang ditingkatkan.
    - Peningkatan penanganan bendera yang dimodifikasi.
- v.5.4.1 (14-06-2020)
    - Memperbaiki bug yang gagal disimpan oleh penimpaan kedua.
    - Memperbaiki teks bilah judul.
    - Memperbaiki pesan bilah status.
    - Menambahkan terjemahan bahasa Jerman.
    - Menambahkan terjemahan bahasa Prancis.
- v.5.4.2 (2020-06-18)
    - Menambahkan kontrol tab untuk memilih "Editor Kode" atau "Penampil Hex".
    - Peningkatan terjemahan Jerman dan Prancis.
    - Memperbaiki panah drop-down bahasa.
    - Memperbaiki pemrosesan pengkodean Unicode.
    - Peningkatan ekspor dan ekstraksi.
    - Dialog EGA yang ditingkatkan.
- v.5.4.3 (2020-07-03)
    - Peningkatan nama file ekstraksi.
    - Mengurutkan item treeview setelah mengubah nama/bahasa sumber daya.
    - Ekstraksi ikon/kursor yang ditingkatkan.
    - Peningkatan kode baris baru dari teks yang disandikan.
    - Memperbaiki dialog "Tambah Sumber Daya".
    - Membuat HTML/Manifest dapat diimpor.
    - Menambahkan fitur pemeriksaan pembaruan di menu "Bantuan".
    - Memperbaiki judul kotak pesan.
    - Santai batas karakter dan mendukung data besar.
    - Atur ulang checksum ke nol saat menyimpan file.
- v.5.4.4 (2020-07-09)
    - Membersihkan isi file sebelum menggunakannya.
    - Mendukung data Delphi DFM internasional.
    - Memasukkan item menu "Delphi DFM Settings" ke dalam menu "Edit".
    - Atur ulang checksum dengan benar ke nol saat menyimpan file.
    - Memperbaiki bug di mana kontrol digeser sebesar 1 piksel.
    - Menambahkan beberapa menunggu saat menyimpan file, untuk pemeriksa virus.
    - Menambahkan tautan "Panduan untuk RisohEditor" ke menu "Bantuan".
- v.5.4.5 (2020-08-03)
    - Menambahkan terjemahan bahasa Indonesia.
    - Menambahkan pelengkapan otomatis untuk kotak kombo bahasa.
- v.5.4.6 (2020-10-03)
    - Cache yang dihapus dalam pemeriksaan versi.
    - Memperbaiki posisi dialog uji.
    - Memperbaiki bug yang `RT_DLGINIT` menghilang tanpa izin.
- v.5.4.7 (2020-10-18)
    - Downgrade Inno Setup ke 5.6.1 untuk dukungan XP.
    - Dukungan awal kelas jendela ActiveX "AtlAxWin140" pada dialog pengujian.
- v.5.4.8 (2020-11-12)
    - Menambahkan terjemahan bahasa Finlandia.
    - Menambahkan asosiasi file *.rc dan *.res.
    - Dukungan awal dari kontrol OLE.
    - Menghapus MOleCtrl dan menambahkan MOleHost.
    - Data REGINST yang didukung.
- v.5.4.9 (21-01-2021)
    - Segarkan Daftar ID setelah mengganti nama item treeview.
- v.5.5.0 (26-01-2021)
    - Tambahkan terjemahan Korea.
- v.5.5.1 (2021-02-02)
    - Windres yang ditingkatkan menjadi 2.36.
    - Item menu BITMAP atau OWNERDRAW dapat dikompilasi.
- v.5.5.2 (27-02-2021)
    - Memperbaiki Ctrl+A pada kotak teks Win2k3.
    - Menambahkan program tlb2idl untuk memproses jenis sumber daya TYPELIB.
    - Pratinjau TYPELIB yang didukung.
    - Menambahkan terjemahan bahasa Polandia.
    - Nonaktifkan fitur "Bungkus pernyataan manifes" sebagai default.
- v.5.5.3 (30-03-2021)
    - Upgrade windres.exe ke 2.36.1.
    - Menggunakan nama jalur pendek untuk menelurkan subproses mcpp.exe dan windres.exe.
- v.5.5.4 (2021-04-13)
    - Perbaikan mengimpor ikon Vista.
- v.5.5.5 (23-04-2021)
    - Program tlb2idl yang dihapus.
    - Menambahkan program OleBow untuk memproses jenis sumber daya TYPELIB.
    - Mengkompilasi TYPELIB jika kompiler MIDL tersedia.
- v.5.5.6 (29-04-2021)
    - Membuat file *.rc dapat diimpor.
    - Memperbaiki tampilan panah bahasa TreeView.
- v.5.5.7 (2021-06-12)
    - Menambahkan nomor baris.
- v.5.5.8 (2021-06-15)
    - Menandai garis saat terjadi kesalahan.
    - Memperbaiki Ctrl+A.
    - Diperbarui mcpp.exe dan dfmsc.exe.
- v.5.5.9 (16-06-2021)
    - Memperbaiki pemuatan resource.h makro.
- v.5.6.0 (2021-06-19)
    - Jangan kompres dfmsc.exe (untuk keamanan).
    - Didukung baris perintah.
    - Menambahkan fungsi RES_load dan RES_save ke bahasa EGA.
- v.5.6.1 (2021-07-01)
    - Memperbaiki nilai pengembalian proses.
    - Penanganan tabel pesan yang ditingkatkan.
    - Jangan ubah huruf besar-kecil nama saat mengganti namanya di TreeView.
- v.5.6.2 (2021-08-15)
    - Lebar dialog "Simpan Opsi" dan "Opsi Ekspor" yang diperbesar.
    - Menambahkan solusi untuk menambahkan tabel pesan pada mode yang kompatibel dengan Microsoft.
- v.5.6.3 (2021-12-12)
    - Menambahkan sampel win32.
    - Menambahkan "Pilihan Bahasa UI".
- v.5.6.4 (2021-12-16)
    - Meminta kompilasi sebelum membuka edit GUI.
- v.5.6.5 (2021-12-18)
    - Tombol BS_OWNERDRAW adalah PUSHBUTTON.
    - Menambahkan fitur "Salin ke beberapa bahasa".
    - Memperbaiki bug jendela RAD (Kritis).
- v.5.6.6 (25-12-2021)
    - Mengklik dua kali jendela RAD akan membuka properti kontrol/dialog.
    - Peningkatan dukungan kursor ANI.
- v.5.6.7 (13-01-2022)
    - Menambahkan terjemahan Portugis.
    - Dukungan WinXP lagi (jangan gunakan GetThreadUILanguage() di XP).
- v.5.6.8 (2022-01-17)
    - Mengubah fokus awal IDD_CTRLPROP.
    - Memperbaiki beberapa info versi.
- v.5.6.9 (2022-03-09)
    - Membagi teks sejarah.
    - Berganti nama menjadi README.
    - Menambahkan WS_CLIPCHILDREN untuk jendela RAD untuk mengurangi kedipan.
- v.5.7.0 (2022-03-18)
    - Memperbaiki kompilasi ulang dalam pengelolaan ID sumber daya.
- v.5.7.1 (28-03-2022)
    - Dialog info versi yang ditingkatkan.
    - Didukung ke metode berkedip karena tampilan kontrol yang salah.
    - Mengingat fokus jendela utama.
- v.5.7.2 (2022-06-07)
    - Didukung sumber daya TOOLBAR.
- v.5.7.3 (2023-04-01)
    - Peningkatan kinerja kecil.
    - Peningkatan "Salin ke beberapa bahasa".
    - Memperbaiki FILESUBTYPE dari VERSIONINFO.
    - Membuat "~" akhiran cadangan daripada "-lama".
    - Mengganti nama "Mengganti Font Dialog..." sebagai "Pengganti font dialog..."
- v.5.7.4 (2023-04-02)
    - Menambahkan nomor versi ke IDS_NOTICE.
    - Konsol EGA yang ditingkatkan.
    - Memperbaiki penginstal yang setengah rusak.
- v.5.7.5 (2023-05-08)
    - Peningkatan dialog IDD_DLGPROP, IDD_CTRLPROP, IDD_ADDCTRL.
    - Menambahkan penginstal Korea.
    - Memperbaiki pemisah MENUEX.
- v.5.7.6 (2023-06-02)
    - Localized the Help menu.
    - Added RES_str_get and RES_str_set functions to EGA.
- v.5.7.7 (2023-06-05)
    - Commonized IDD_ADDDLGINIT and IDD_MODIFYDLGINIT.
    - Changed the design of RES_str_get and RES_str_set.
    - Added RES_get_text and RES_set_text functions to EGA.
- v.5.7.8 (2023-10-06)
    - Improved Portuguese (Brazilian) translation.
    - Relaxed font selection requirements.
    - Added Traditional Chinese translation.
- v.5.7.9 (2023-11-14)
    - Added EGA sample DeleteNonEnglish.ega.
    - Fixed IDS_THEREISUPDATE translation.

```

`HISTORY-ITA.txt`:

```txt
/////////////////////////////////////////////////////
// CRONOLOGIA VERSIONI PROGRAMMA

- v.0.6 (31.08.2017)
    - Prima versione.
- v.5.0.8 (12.09.2018)
    - Migliorate icone della barra strumenti.
    - Corretti tipi di file durante l'estrazione.
    - Scrittura riferimento sorgente per facilitare il rilevamento UTF-8.
    - Corrette icone vista struttura.
    - Divisi modelli risorse RT_DIALOG e RT_MENU nelle varie lingue.
- v.5.0.9 (27.09.2018)
    - Migliorato output di resource.h.
    - Migliorata icona del file vista struttura.
    - Migliorata l'importazione.
- v.5.1.0 (08.10.2018)
    - Migliorate finestre di dialogo "Inserimento stringa" (multi-linea).
    - Corretto comportamento Ctrl + A.
    - Controllo blocco dei file durante il salvataggio di un file.
    - Correzione ID risorsa sensibili al maiuscolo/minuscolo.
    - Supporto codifica degli elementi delle risorse.
    - Corretta chiusura anomala nella finestra di dialogo "Lingue".
- v.5.1.1 (08.11.2018)
    - Accetta spazio nella casella di testo della didascalia.
    - Accetta spazio nella casella di testo della lingua.
- v.5.1.2 (08.12.2018)
    - Accetta lo spazio nella casella di testo del nome della classe della finestra.
    - Accetta il valore stringa letterale C nella casella di testo Nome classe finestra.
    - Migliorato sistema modelli.
    - Abilitato modello manifest.
    - Corretto aggiornamento dell'interfaccia utente della barra strumenti.
    - Visualizza correttamente i tipi di ID in "Elenco ID risorsa".
    - Ordina correttamente le lingue in output.
- v.5.1.3 (01.01.2019)
    - Corretto "Elenco ID risorsa".
- v.5.1.4 (13.01.2019)
    - Aggiunto programma di installazione inglese.
    - Aggiunto programma di installazione italiano.
    - Aggiunta traduzione italiana.
    - Aggiunto alcuni programma installazione diverse lingue.
- v.5.1.5 (27.01.2019)
    - Non usa lo stile esteso WS_EX_MDICHILD.
    - Aggiunto supporto ReactOS.
- v.5.1.6 (24.02.2019)
    - Migliorata traduzione italiana.
    - Modificata la GUI.
    - Correzione "Clona in una nuova lingua".
- v.5.1.7 (20.03.2019)
    - Aggiunti gli stili PBS_MARQUEE e PBS_SMOOTHREVERSE.
    - Corretto l'errore del processo di compilazione.
- v.5.1.8 (14.05.2019)
    - Aggiunto il controllo della ricompilazione al momento della clonazione.
    - Corretta la selezione dopo la clonazione.
    - Corretta situazione in caso di errore di compilazione della tabella delle stringhe e della tabella dei messaggi.
- v.5.1.9 (14.07.2019)
    - Supporto UTF-16 per in/out sorgenti.
- v.5.2.0 (26.07.2019)
    - Corretta gestione valori DIALOG STYLE (WS_CAPTION è del valore predefinito di DIALOG STYLE).
    - Risolto un bug per cui l'applicazione cancellava inaspettatamente il file quando apriva un file EXE compresso senza espanderlo.
- v.5.2.1 (04.08.2019)
    - Viene selezionato "Inglese (Stati Uniti)" se si immette "En" per il nome della lingua.
    - Aggiunta funzione "Ricerca costante".
    - Corretta funzione "Comprimi tutto".
    - WS_POPUPWINDOW | WS_BORDER deve essere WS_POPUPWINDOW | WS_CAPTION.
    - Supporto RT_FONT.
    - Migliorata finestra di dialogo "Aggiungi risorsa".
- v.5.2.2 (14.08.2019)
    - Aggiornata la traduzione italiana.
    - Supporto tipi di risorse XML, XSLT, SCHEMA e REGISTRY.
    - Migliorata interpretazione in caso di mancata corrispondenza della lingua di RT_ICON / RT_CURSOR e RT_GROUP_ICON / RT_GROUP_CURSOR.
    - Migliorata interpretazione in caso di mancata corrispondenza della lingua di RT_DLGINIT e RT_DIALOG.
- v.5.2.3 (14.09.2019)
    - Corretti STILE AUTORADIOBUTTON.
- v.5.2.4 (15.09.2019)
    - Aggiunto supporto XP.
- v.5.2.5 (19.09.2019)
    - Risolto un bug WS_CHILDWINDOW nella casella di riepilogo dello stile della finestra di dialogo.
    - Modificato il nome file del programma/versione (in RisohEditor-X.X.X.exe e RisohEditor-X.X.X.zip).
    - Aggiunto TRANSLATORS.txt.
    - Resi visibili i controlli disegnati dal proprietario.
- v.5.2.6 (23.09.2019)
    - Migliorata finestra di dialogo selezione lingua.
    - Aggiunta la traduzione in russo.
    - Visualizzazione messaggio di errore se il percorso di installazione contiene degli spazi.
    - Aggiunta opzione --use-temp-file nel richiamo di windres per risolvere il problema open.
- v.5.2.7 (20.10.2019)
    - Nuovo miglioramento finestra di dialogo selezione lingue.
    - Corrette posizioni dei segni degli elementi della finestra di dialogo.
- v.5.2.8 (30.01.2020)
    - Abilitata visualizzazione controlli indefiniti.
    - Aggiunta opzione "Usa BEGIN / END".
    - Risolto un bug per cui la DLL non poteva essere salvata con un altro nome.
- v.5.2.9 (01.02.2020)
    - Non era stato attivato il supporto per XP. Ora è attivo.
    - Corretta elaborazione salvataggio file.
    - Ora è possibile salvare file EXE/DLL senza proprietà utente dell'eseguibile.
    - Corretto come effettuare backup.
- v.5.3.0 (06.02.2020)
    - Aggiunto ES_AUTOHSCROLL in alcuni riquadri testo.
    - Corretto l'errore logico di sovrascrittura file.
- v.5.3.1 (23.02.2020)
    - Corretta e migliorata lettura/visualizzazione menu.
    - Migliorata gestione IDC_STATIC.
    - Migliorata finestra "Elenco ID risorse".
- v.5.3.2 (02.03.2020)
    - Abilitato salvataggio con 'Ctrl+S' senza richiesta del percorso.
    - Resa non volatile l'opzione "Destinazione file RC come UTF-16".
    - Portata in primo piano finestra "Elenco ID risorse".
- v.5.3.3 (03.03.2020)
    - Ridotta dimensione del file da 9 MB a 3MB.
- v.5.3.4 (19.03.2020)
    - Modificato nella barra strumenti il comportamento del pulsante 'Salva'.
    - Introdotta automazione usando il linguaggio programmazione EGA.
    - Aggiunta conferma salvataggio in caso di modifiche del file.
- v.5.3.5 (26.03.2020)
    - Migliorata traduzione lingua italiana.
    - Correzione modulo salvataggio configurazione.
- v.5.3.6 (15.04.2020)
    - Corretto problema loop infinito mediante modifica della variabile loop a 32bit.
    - Supporto dati Delphi DFM.
    - Migliorato menu contestuale.
- v.5.3.7 (28.04.2020)
    - Aggiornata flag modifica file quando si trascina un file.
    - Migliorata gestione nome file durante estrazione.
    - Rafforzato EGA.
    - Migliorata traduzione lingua russa.
- v.5.3.8 (22.05.2020)
    - Aggiunto elemento "Apri manuale EGA" nel menu "Automazione"
    - Controllo rigoroso flag modifica file.
- v.5.3.9 (01.06.2020)
    - Aggiunta funzione "sostituisci-font-finestra".
    - Spostati alcuni funzioni nel menu "Modifica".
    - Aggiunto controllo valore-zero del nome risorsa e tipo risorsa.
    - Aggiunto stile DS_CENTER al modello finestra dialogo.
    - Abilitati tasti funzione F1, F3, F5 e F6.
    - Aggiunta versione portatile.
    - Potenziata funzione ricerca.
- v.5.4.0 (13.06.2020)
    - Corretto output RT_ACCELERATOR` (16bit non firmato).
    - Rimossa opzione "salva nella cartella res".
    - Corretto problema crash uso modifica GUI.
    - Potenziata funzione estrazione risorse.
    - Corretto problema sostituzione-font-finestra.
    - Nella barra del titolo viene ora visualizzato il percorso completo del file in modifica.
    - Aggiunto menu scelta lingua risorsa.
    - Corretto problema "Ricerca costante".
    - Corretto problema finestra "Codifica elemento risorsa".
    - Migliorata finestra "Associazione ID".
    - Migliorata finestra "Macro predefinite".
    - Migliorata finestra "Configurazione".
    - Corretto problema testo finestra "Trova".
    - Migliorati messaggi di stato (narra inferiore sinistra).
    - Migliorata gestione flag.
- v.5.4.1 (14.06.2020)
    - Corretto problema fallimento seconda scrittura nel salvataggio file.
    - Coretto problema testo barra titolo.
    - Corretto problema messaggio barra di stato.
    - Aggiunta traduzione tedesca.
    - Aggiunta traduzione francese.
- v.5.4.2 (18.06.2020)
    -  Aggiunte schede controllo "Editor codice" e "Visualizzatore HEX".
    -  Migliorate traduzioni tedesca e francese.
    -  Corretto problema freccia finestra drop-down lingua.
    -  Corretto problema elaborazione codifica Unicode.
    -  Migliorate funzionalità importazione ed estrazione.
    -  Migliorata finestra di dialogo EGA.
- v.5.4.3 (03.07.2020)
    -  Miglioramento nome file di estrazione.
    -  Ordinati gli elementi vista struttura cambio di nome / lingua della risorsa.
    -  Miglioramento estrazione icona / cursore.
    -  Migliorati codici nuova riga del testo codificato.
    -  Corretto problema finestra "Aggiungi risorsa".
    -  Reso HTML/Manifest importabile.
    -  Aggiunta funzione di controllo degli aggiornamenti nel menu "?".
    -  Corretto titolo finestra messaggio.
    -  Modificato il limite di caratteri e supportati dati di grandi dimensioni.
    -  Ripristinato checksum a zero durante il salvataggio del file.
- v.5.4.4 (09.07.2020)
    - Aggiunto svuotamento del contenuto del file prima di usarlo.
    - Aggiunto supporto Dati internazionali DFM Delphi.
    - Inserita voce di menu "Impostazioni DFM Delphi" nel menu "Modifica".
    - Corretta impostazione checksum a zero durante il salvataggio del file.
    - Corretto problema per cui un controllo è spostato di 1 pixel.
    - Aggiunte alcuni cicli di attesa nel salvataggio del file, utili per il controllo antivirus.
    - Aggiunto un collegamento "Guida a RisohEditor" nel menu "?" (Aiuto).
- v.5.4.5 (03.08.2020)
    - Aggiunta traduzione indonesiana.
    - Aggiunto completamento automatico per riquadri combo lingua.
- v.5.4.6 (03.10.2020)
    - Eliminata cache nel controllo versione.
    - Corretta posizione finestra anteprima Test.
    - Corretto bug per cui RT_DLGINIT senza permesso scompariva.
- v.5.4.7 (18.10.2020)
    - Downgrade installer (Inno Setup 5.6.1) per includere supporto XP.
    - Supporto iniziale classe finestra ActiveX "AtlAxWin140" nella finestra Test.
- v.5.4.8 (12.11.2020)
    - Aggiunta traduzione Finlandese.
    - Aggiunta associazione file *.rc e *.res.
    - Supporto iniziale controlli OLE.
    - Eliminato MOleCtrl e aggiunto MOleHost.
    - Supporto dati REGINST.
- v.5.4.9 (21.01.2021)
    - Aggiornamento ID List dopo aver rinominato l'elemento treeview.
- v.5.5.0 (26.01.2021)
    - Aggiunta la traduzione in coreano.
- v.5.5.1 (02.02.2021)
    - Windres aggiornato alla versione 2.36.
    - Le voci menu BITMAP e OWNERDRAW ora possono essere compilate.
- v.5.5.2 (27.02.2021)
    - Corretto problema Ctrl+A nei riquadri testo in Windows 2003.
    - Aggiunti programmi TIB2IDL al processo tipo risorsa TYPELIB.
    - Aggiunto supporto visualizzazione anteprima TYPELIB.
    - Aggiunta traduzione polacca.
    - Disabilitata funzione come predefinita "A capo automatico istruzioni manifest".
- v.5.5.3 (30.03.2021)
    - Aggiornato windres.exe alla versione 2.36.1.
    - Usato nome percorso corto al sub processo spawn di mcpp.exe e windres.exe.
- v.5.5.4 (13.04.2021)
    - Correzione icone Windows Vista.
- v.5.5.5 (23.04.2021)
    - Eliminato programma tlb2idl.
    - Aggiunto programma OleBow per elaborare tipi di risorse TYPELIB.
    - Compilazione TYPELIB se disponibile il compilatore MIDL.
- v.5.5.6 (29.04.2021)
    - Abilitata importazione file *.rc.
    - Risolto problema visualizzazione freccia lingue di TreeView.
- v.5.5.7 (12.06.2021)
    - Aggiunta numeri di linea.
- v.5.5.8 (15.06.2021)
    - Evidenzia le linee in caso di errore.
    - Corretto Ctrl+A.
    - Aggiornati mcpp.exe e dfmsc.exe.
- v.5.5.9 (16.06.2021)
    - Corretto caricamento macro resource.h.
- v.5.6.0 (19.06.2021)
    - on comprime dfmsc.exe (per questioni di sicurezza).
    - Supporto linea di comando.
    - Aggiunte funzioni RES_load e RES_save a linguaggio EGA.
- v.5.6.1 (01.07.2021)
    - Corretto il valore di ritorno del processo.
    - Migliorata gestione della tabella messaggi.
    - Non modifica il caso del nome quando lo si rinomina in VistaStruttura.
- v.5.6.2 (15.08.2021)
    - Aumentata larghezza delle finestre di dialogo "Opzioni salvataggio" ed "Opzioni esportazione".
    - Aggiunta una soluzione alternativa per aggiungere tabelle di messaggi in modalità compatibile con Microsoft.
- v.5.6.3 (12.12.2021)
    - Aggiunti campioni di win32.
    - Aggiunto "Selezione lingua interfaccia utente".
- v.5.6.4 (16.12.2021)
    - Richiesta di compilazione prima di aprire la modifica della GUI.
- v.5.6.5 (18.12.2021)
    - Un pulsante BS_OWNERDRAW è un PULSANTE.
    - Aggiunta la funzione "Copia in più lingue".
    - Risolto il bug della finestra RAD (critica).
- v.5.6.6 (25.12.2021)
    - Facendo doppio clic sulla finestra RAD si aprono le proprietà del controllo/dialogo.
    - Migliorato il supporto del cursore ANI.
- v.5.6.7 (13.01.2022)
    - Aggiunta la traduzione in portoghese.
    - Nuovo supporto per WinXP (non usare GetThreadUILanguage() in XP).
- v.5.6.8 (17.01.2022)
    - Modificato lo stato attivo iniziale di IDD_CTRLPROP.
    - Risolte alcune informazioni sulla versione.
- v.5.6.9 (09.03.2022)
    - Diviso il testo della cronologia.
    - File Leggimi rinominati.
    - Aggiunto WS_CLIPCHILDREN per la finestra RAD per ridurre lo sfarfallio.
- v.5.7.0 (18.03.2022)
    - Corretta ricompilazione nella gestione degli ID delle risorse.
- v.5.7.1 (28.03.2022)
    - Finestra informazioni versione migliorata.
    - Correzione metodo di sfarfallio a causa di visualizzazione di controllo sbagliato.
    - Memorizzazione focus finestra principale.
- v.5.7.2 (07.06.2022)
    - Supportate risorse BARRA STRUMENTI.
- v.5.7.3 (01.04.2022)
    - Miglioramenti minori delle prestazioni.
    - Miglioramento "Copia in più lingue".
    - Corretto FILESUBTYPE di VERSIONINFO.
    - Modificato il suffisso del backup da  "-old" a "~".
    - Rinominata "Sostituzione font finestra..." in "Sostituzione font finestra..."
- v.5.7.4 (02.04.2023)
    - Aggiunti numeri di versione a IDS_NOTICE.
    - Console EGA migliorata.
    - Risolto problema programma di installazione danneggiato.
- v.5.7.5 (08.05.2023)
    - Migliorato IDD_DLGPROP, IDD_CTRLPROP, IDD_ADDCTRL dialogs.
    - Aggiunto programma di installazione coreano.
    - Corretto problema separatore MENUEX.
- v.5.7.6 (02.06.2023)
    - Localizzato il menu Aiuto.
    - Aggiunte le funzioni RES_str_get e RES_str_set a EGA.
- v.5.7.7 (05.06.2023)
    - IDD_ADDDLGINIT e IDD_MODIFYDLGINIT comuni.
    - Modificato il design di RES_str_get e RES_str_set.
    - Aggiunte le funzioni RES_get_text e RES_set_text a EGA.
- v.5.7.8 (06.10.2023)
    - Revisione traduzione portoghese (brasiliano).
    - Requisiti rilassati selezione font.
    - Aggiunta traduzione Cinese tradizionale.
- v.5.7.9 (14.11.2023)
    - Aggiunto esempio EGA DeleteNonEnglish.ega.
    - Corretta traduzione IDS_THEREISUPDATE.

```

`HISTORY-JPN.txt`:

```txt
## 更新履歴

- v.0.6 (2017-08-31)
    - 初公開。
- v.0.7 (2017-09-03)
    - メモリーリークの解消。
    - 「ダイアログの編集」ウィンドウの位置の記憶。
    - Ctrl+Aでテキストすべて選択が可能に。
    - テキストの検索と置換をサポート。
    - マクロ パーサーの構文解析を修正。
    - 「ヘルプ」メニューからREADME/READMEJP.txtを開けるように。
    - 「ダイアログの編集」で背景に点々を表示できるように。
    - "cpp.exe"を7.1.0にバージョンアップ。
    - "windres.exe"を2.28にバージョンアップ。
    - ウィンドウクラスライブラリの読み込みのサポート。
- v.0.8 (2017-09-10)
    - DLLファイル「gdiplus.dll」を使用。
    - GIF/PNG/JPEG/TIFF/AVI/WMF/EMFのサポート。
    - アイコン情報の表示を修正。
    - ダイアログ情報を修正。
    - ダイアログリソースを消したとき、「ダイアログの編集」を消すようにした。
- v.0.9 (2017-09-16)
    - インストーラを追加。
    - ツールバーを豪華に。
    - ウィンドウの最大化状態を復元できるようにした。
    - IDの解釈を修正した。
    - ヘルプIDのプレフェックスを「HELPID_」から「HID_」に変えた。
- v.1.0 (2017-09-25)
    - 多数のUIの改良。
    - コンパイルが必要かどうかの確認を厳密にした。
    - 重い処理のとき、砂時計を表示するようにした。
    - 不正なデータに強くなった。
    - 読み込み時のエラー表示を必ずするようにした。
    - マニフェストを修正した。
    - ダイアログのリソースの出力を修正した。
    - BS_PUSHBOXスタイルをサポート。
    - バージョン情報ダイアログを中央に寄せた。
- v.1.1 (2017-11-18)
    - ダイアログリソースをコンパイルしたときに、必要ならダイアログを再表示するようにした。
    - メニューの文字列の扱いを修正した。
    - ダイアログのサイズの調整を柔軟にした。
    - グリッドで位置合わせできるようにした。
    - ダイアログの背景の点々を微調整した。
- v.1.2 (2017-11-21) ver.1.3
    - 文字列編集を修正した。
- v.1.4 (2017-11-22)
    - 文字列IDがマイナスになるバグを修正した。
    - ヘルプIDが32ビット整数を扱えなかったのを修正した。
    - アイコンまたはカーソルリソースの削除の際の不具合を修正した。
    - "resource.h"の読み込みの処理を修正した。
    - ソースビューに横スクロールバーを追加。
- v.1.5 (2017-11-22)
    - 保存できないバグを修正。
- v.1.7 (2017-12-27)
    - 最小化されたときのウィンドウの位置とサイズを記録しないようにした。
    - この問題が起きた場合は、レジストリキー「HKEY_CURRENT_USER\Software\Katayama Hirofumi MZ\RisohEditor」を削除すれば復旧できます。
- v.1.8 (2017-12-28)
    - 中国語対応。保存の際の不具合を修正。
- v.1.9 (2017-12-29)
    - 保存の際の不具合を修正。
- v.2.0 (2018-01-02)
    - ダイアログのサイズ変更がうまくできなかったのを修正。
    - インデックスを変更したときに、ダイアログのサイズが勝手に変わったのを修正。
- v.2.1 (2018-01-06)
    - ダイアログのサイズ変更の際の計算が間違っていたのを修正。
    - 画面分割の境界線の位置を一時的に保存するようにした。
- v.2.2 (2018-01-16)
    - スタイルがゼロのとき、空文字列ではなくゼロを出力するようにした。
    - ツールバーとページャーコントロールとグループボックスの表示を改善した。
    - IPアドレスコントロールのサポート。
    - 小文字のクラス名をコンパイルしたときに、なぜか大文字になるのを修正。
    - コントロールのダイアログにコントロールのツールバーを追加。
- v.2.3 (2018-01-20)
    - ハンドルマップ採用により、IPアドレスコントロールの表示が改善した。
    - コントロールのIDの規定値を-1にする。
- v.2.4 (2018-01-23)
    - リソース項目を「別の名前で複製」「別の言語で複製」が可能に。
- v.2.5 (2018-01-26)
    - アイコン・カーソルの読み込みにおいて、不正なデータに対して強くなった。
    - 「リソースIDの追加」ダイアログに「自動」ボタンを追加。
    - ツリービューの表示を改良。ツリービューの順序を並び替える。
    - いくつかのダイアログでIDの解釈が間違っていたのを修正。
    - 「リソースIDの変更」ダイアログで変更後にIDの一覧を更新するようにした。
    - 上書きインストール対応のために、バージョン番号をショートカットファイルから削除した。
    - 「項目検索」をサポート。項目をまたいだ検索ができる。
- v.2.6 (2018-02-03)
    - Windows XP/2003を正式にサポート。
    - バージョン情報を改良。
    - "cpp.exe"を7.2.0にバージョンアップ。
    - "windres.exe"を2.29.1にバージョンアップ。
    - 「リソースIDの追加」ダイアログを改良。
    - 「resource.h」ファイルを更新する機能を追加。
    - ライセンスを開く機能を追加。
    - フォントコンボボックスで縦書きのフォントを取り除く。
    - ダイアログのメニューをサポート。
    - ツリービューのデバッグ用の機能追加（Ctrl+Shift+L）。
    - 「項目検索」の文字列テーブル検索を改良。
    - リソースIDに関して複数のダイアログの改良。
- v.2.7 (2018-02-04)
    - 「ダイアログの編集」ウィンドウにアイコン追加。
    - 「別の名前でコピー」ダイアログの改良と動作の修正。
    - 「resource.h の再読み込み」が正常に機能していなかったのを修正。
    - 「リソースIDの一覧」のコンテキストメニューに「再読み込み」を追加。
    - 不正なファイルパスをチェックするようにした。
    - 「別の名前でコピー」ダイアログを「別の名前で複製」にした。
    - 「別の言語でコピー」ダイアログを「別の言語で複製」にした。
    - 「別の言語で複製」ダイアログを改良した。
    - RESファイルの読み込みを修正。
    - RCファイルの読み込みをサポート。
    - ドラッグ＆ドロップでresource.hが読み込めるようにした。
- v.2.8 (2018-02-06)
    - .res読み込みの際に、resource.hを再読み込みするようにした。
    - クラス付きまたは子ウィンドウのダイアログをテストできないようにした。
    - ビットマップ読み込みの品質を改良。
    - コントロールID以外のリソースの名前がマイナスにならないようにした。
    - "IMAGE"という種類のリソースをサポート（中身は多分PNG）。
    - 画像表示においてマウスホイールをサポート。
    - 無効なウィンドウ位置を修正するようにした。
    - スタティックコントロールのアイコンとビットマップをサポート。
    - 「バージョン情報」ダイアログを改良した。
- v.2.9 (2018-02-08)
    - UPXによるEXEファイルの展開・圧縮をサポート。
    - 保存の際の不具合を修正。
- v.3.0 (2018-02-13)
    - 読み込みの際の不具合を修正。
    - メッセージテーブルをサポート。
    - メッセージコンパイラー「mcdx」を追加。
    - 「リソースの追加」ダイアログの名前の処理の修正。
    - ツリービューの選択変更中に砂時計カーソルを表示するようにした。
    - cpp.exeを7.3.0にバージョンアップ。
    - windres.exeを2.30にバージョンアップ。
    - 「文字列エントリーの追加」ダイアログの初期化を忘れていたのを修正。
    - 「リソースの追加」ダイアログの入力条件を緩和。
- v.3.1 (2018-02-14)
    - いくつかのダイアログをサイズ変更可能に。
    - リソースを追加できなかったバグを修正。
    - 「ダイアログの編集」の再描画を高速化。
    - ソースビューにLANGUAGE文を表示。
    - エラー表示を改善。
    - メッセージテーブル周辺の不具合を修正。
- v.3.2 (2018-02-22)
    - mcdxをLinuxに移植。
    - ヘルプIDの解析が間違っていたのを修正。
- v.3.3 (2018-02-25)
    - 「ダイアログの編集」のコントロールの上下関係をきっちりと。
    - 「ダイアログの編集」でドラッグ選択が可能に。
    - 「ダイアログの編集」の右クリックメニューに「再描画」を追加。
    - いくつかのダイアログに入力補完機能を付けた。
    - ComboBoxEx32.DEFAULT.STYLEを修正。
    - IDジャンプを実装。
- v.3.4 (2018-02-26)
    - 「アクセスキーの編集」ダイアログを大きく。
    - 「リソースIDの一覧」を改良。
    - 「リソースIDの一覧」のダブルクリックでIDジャンプするようにした。
    - ツリービューでF2を押すと、名前や言語を簡単に変更できるようになった。
    - 整数の解析の不具合を修正。
    - 「表示」メニューに「最新の情報に更新」を追加。
    - 文字列形式の名前で、コンパイルすると不一致で失敗する不具合を修正。
    - その他、文字列形式の名前に関する不具合を修正。
    - ソース表示の行を折り返すようにするなど、ソース表示を改良。
- v.3.5 (2018-02-27)
    - 梱包作業を一部自動化。
    - 「ダイアログ編集に点々を表示する」設定が反映されていなかったのを修正。
    - ツリービューが更新されたときに、ツリービューの位置を正しく復元するようにした。
    - ラバーバンドの当たり判定がおかしかったのを修正した。
    - 「ダイアログの編集」でCtrl+Aを押すと、全部選択するようにした。
    - 「ダイアログの編集」でCtrl+Dを押すと、インデックスを表示するようにした。
    - RC形式でのエクスポートを実装。
    - 整数の解釈を少し改良した。
- v.3.6 (2018-02-28)
    - フォント設定が可能に。
    - グループボックスの当たり判定を修正。
    - 設定の「IDマクロを使用しない」が正しく更新されていなかったのを修正。
- v.3.7 (2018-03-08)
    - 「定義済みマクロ」の設定が可能に。
    - PATHの設定が可能に。
    - ダイアログのコントロールデータをサポート。
    - リストビューに項目を追加したときの動作を改良した。
    - 「windef.h」を追加。
    - 「文字列テーブル」と「メッセージテーブル」のダイアログに右クリックメニューを追加。
    - ダイアログ編集の複数選択のプロパティを正しく解釈していなかったのを修正。
    - 「編集」メニューを改良。
    - 「リソースの追加」ダイアログでオプションかどうかを表示するようにした。
    - エラーがあるのにエラーメッセージが表示されなかったのを修正。
- v.3.8 (2018-03-12)
    - <strsafe.h>の使用により、より安全性が向上した。
    - 「リソースIDの一覧」において、10進数と16進数が選べるようになった。
    - mcdxのLANGUAGE文の解析を修正。
    - LANGUAGE文の出力を修正。
    - XPのサポートを外す。
    - 「リソースIDの追加」の「自動」ボタンについて、コマンドIDの生成方法を修正。
    - 「ダイアログの編集」において、項目のコピー＆貼り付けが可能に。
    - x64でのビルドをサポート。
    - 中国語を改良。
    - コントロール データが長すぎる場合をチェック。
- v.3.9 (2018-03-18)
    - IDのプレフィックスを標準化。
    - エクスポートを修正・標準化。
    - エクスポート方法を選べるようにエクスポート オプションを追加。
    - "resource.h"の更新を使いやすく修正。
- v.4.0 (2018-03-20)
    - バックアップをもっと安全に。
    - バックアップを5世代までに制限。
    - 非標準のリソースIDの解釈を改善。
    - 「Standardize.md」と「MESSAGETABLEDX.md」と「HYOJUNKA.txt」を追加。
    - いくつかのコントロールのデフォルトのウィンドウスタイルを修正。
    - 文字列マクロを一部サポート。
    - 文字列IDの扱いを修正。
    - 「リソースIDの一覧」にコンボボックスを付けて改良。
    - エクスポートを高速化。
    - 「次のID」の値を修正。
    - リストビューにツールチップを追加。
    - 「文字列テーブルの編集」を修正。
    - キャプションを覚えるようになった。
    - 未知のデータ形式に対する対応。
    - 「テキストファイルを開く」を修正。
    - 「リソースIDの追加」の改良。
    - 「言語の一覧」を追加。
    - ツールバーを隠せるようになった。
- v.4.1 (2018-03-21)
    - メニューとアクセスキーの編集で、正しくコマンドIDが読み込まれるようになった。
    - 「リソースの追加」ダイアログを修正。
    - 「リソースIDの一覧」ウィンドウに「値をコピー」メニュー項目を追加。
    - 「リソースIDの一覧」で選択なしの場合のいくつかのアクションを無効に。
    - 「リソースIDの一覧」のコンボボックスを改良。
    - 「メニュー リソースの編集」を改良。
    - 「アクセスキーの編集」を改良。
    - コンテキストメニューの位置を修正。
    - 「PATHの設定」ダイアログを改良。
    - 「定義済みマクロの一覧」ダイアログを修正・改良。
    - 「文字列テーブル」と「メッセージテーブル」ダイアログを修正・改良。
    - メッセージIDを32ビットに修正。
    - いくつかのダイアログに「すべて削除」ボタンを追加。
    - 「設定」ダイアログを増強。
    - 「バージョン情報」のアイコンを修正。
    - CONTROL文/ICON文の解釈を改良。
- v.4.2 (2018-03-22)
    - 「リソースIDの一覧」の「再読み込み」に不具合があったのを修正。
    - 「resource.h」の更新方法を修正。
    - 32ビットのリソーエディタから64ビットのモジュールの読み込みをサポート。
    - 子ダイアログのテストをサポート。
    - 「resource.h」が未更新のときに、#undef/#defineでマクロを定義して、コンパイル可能にする。
    - ダイアログリソースとメニューリソースの出力を修正。
    - IDC_STATICの使用を切り替えられるようにした。
    - ヘッダーファイル「afxres.h」を追加。
    - IDC_STATICについて助言を改良した。
    - ビジュアルスタイルに対応。
    - SysLinkとSplitButtonコントロールに対応。
- v.4.3 (2018-03-25)
    - XPサポート。
- v.4.4 (2018-04-19)
    - 英語の改良など。
    - スピンコントロールをGUIに追加。
    - OLEコントロールを一部サポート。
    - ウィンドウクラスライブラリの扱いを修正。
- v.4.5 (2018-04-26)
    - マニフェストの設定が間違っていたので修正。
    - テキストボックスの数値を右揃えに。
    - MOleCtrlの代わりにデフォルトでAtlAxWin*を使うように変更。
    - OLEコントロールのサポートを改善。
    - RT_DLGINITを一部サポート。
    - コンボボックスとリストボックスの既定のスタイルが間違っていたのを修正。
    - コントロールのダイアログを修正・改良。
- v.4.6 (2018-06-05)
    - ダイアログのフォントと寸法に関する間違い（特にDS_SHELLFONT）を修正。
- v.4.7 (2018-06-07)
    - Ctrl+Pでエクスポートできるようにした。
    - DS_SETFONTスタイルを解除または追加したときの処理を追加。
    - RISOHTEMPLATEというリソースデータでリソースのテンプレートを実現。
    - ツリービューを「すべて展開」する機能と「すべて折りたたむ」機能を追加。
- v.4.8 (2018-06-08)
    - DS_SETFONT, DS_FIXEDSYS, DS_SHELLFONTスタイル周りの不具合を修正。
- v.4.9 (2018-06-15)
    - ツリービューとリソース項目の管理方法を刷新した。
    - 不正な言語を指定したときの処理を修正。
    - 「名前を付けて保存」からRCファイルを保存できるようにした。
    - 「追加」ダイアログを改良。
    - 「名前を付けて保存」のファイルの種類を覚えるようにした。
    - 「編集」メニューと「検索」メニューを改良。
    - 英語や文字列の一部やen_USを受け入れるなど、言語名の解釈がスマートになった。
- v.4.9.5 (2018-06-18)
    - コンパイルした際に上書き確認が出ていたのを修正。
    - 項目検索の際の不具合を修正。
    - 読み込みを高速化。
    - resource.hの構文解析を修正。
    - 一部、リソースが抽出できなかったのを修正。
    - コンパイルの処理を修正。
    - コンパイル後、リソースの種類を確認するようにした。
    - Ctrl+Aが効いていなかったのを修正。
- v.4.9.6 (2018-06-19)
    - プレーンテキストのリソースをコンパイルできなかったのを修正。
    - RT_DLGINITの名前のラベルを修正。
    - RT_DLGINITの出力が間違っていたのを修正。
    - RT_DLGINITが正しく更新されなかったのを修正。
    - RT_DIALOGを消したら、対応するRT_DLGINITも消すようにした。
    - 「行の折り返し」設定を追加。
    - RT_DIALOGとRT_DLGINITの連携を修正。
    - 「ダイアログの編集」のコントロールの選択状態に合わせて、ソースにマークが付くようになった。
- v.4.9.7 (2018-06-21)
    - ソースのマークは、編集済みのときは表示されないようにした。
    - ソースのコントロールの行をダブルクリックすると、そのコントロールを選択するようにした。
    - 可能ならば、ツリービューにエクスプローラのビジュアルスタイルを適用。
    - 「DLGINITの編集」ダイアログを修正、より柔軟にした。
    - 「DLGINITの編集」と「メニューの編集」と「アクセスキーの編集」のリストが逆順だったのを修正。
    - UPXで展開ができなかったのを修正。
    - UPXで展開したファイルを保存できなかったのを修正。
    - 「ファイル」メニューに「名前を付けて圧縮保存」を追加。
- v.4.9.8 (2018-06-22)
    - WinXPで起動できなかったのを修正。
    - 「resource.h」をアンロードしたときに、マクロが数値にならなかったのを修正。
    - 「名前を付けて圧縮保存」を改良。
    - 言語の扱いをさらに改良。
    - 「言語の一覧」ダイアログを修正。
    - ツールバーを刷新。
- v.5.0.0 (2018-06-24)
    - 「ダイアログの編集」においてコントロールの位置とサイズの変更を高速化。
    - 名前/言語の変更においてチェックを厳格に。
    - 言語の解釈をさらに改良。
    - ツールバーアイコンを改良。
    - 「ヘルプ」メニューでまとめサイトへジャンプできるようにした。
- v.5.0.1 (2018-07-06)
    - リソース抽出時の拡張子を修正した。
- v.5.0.2 (2018-07-20)
    - プロセス待ち時間を20秒まで延長。
    - ダイアログのコントロールを削除したときの不具合を修正。
- v.5.0.3 (2018-08-14)
    - リソースの削除のバグ修正。
- v.5.0.4 (2018-08-18)
    - 「新規作成」コマンドで「ダイアログの編集」が残っていたのを修正。
- v.5.0.5 (2018-08-29)
    - 言語名指定「English」で英語が選択されるようにした。
    - 「言語別にファイルを分ける」が正しく動作されるようにした。
- v.5.0.6 (2018-08-30)
    - バックアップの設定が可能に。
    - エクスポートまたは保存のときに、リソース項目を並べ替えるようにした。
    - 冗長なコメントを出力できるようにした。
- v.5.0.7 (2018-09-05)
    - 主要ではない言語のサポートを修正。
    - コメントの出力を改善。
    - 自分で自分自身のリソースを置き換え。
    - マニフェスト文を #ifndef MSVC ... #endif で包むオプションを追加。
    - バージョン情報の出力を改良。
    - Visual Studioとの互換性を示すため、メッセージテーブルを削除。
    - インストーラを改良。
    - ツールバーアイコンの改良。
    - EXE保存のときのバックアップの設定が可能に。
    - 終了するとき、コンパイルの確認をしないようにした。
- v.5.0.8 (2018-09-12)
    - さらなるツールバーアイコンの改良。
    - 抽出のファイルの種類の修正。
    - ソースにダガー(U+2020)を書き込んでUTF-8の検出を助けるようにする。
    - ツリービューのアイコンを修正。
    - 日本語のダイアログとメニューのテンプレートを分ける。
- v.5.0.9 (2018-09-27)
    - resource.hの出力を改良。
    - ツリービューのアイコンをさらに改良。
    - インポートを改良。
- v.5.1.0 (2018-10-08)
    - 文字列エントリーのダイアログを改良(複数行)。
    - Ctrl+Aの動作を修正。
    - ファイルがロックされているか確認するようにした。
    - リソースIDの大文字小文字を区別するようにした。
    - リソース項目ごとにエンコーディングを設定できるようにした。
    - 「言語の一覧」で異常終了する不具合を修正。
    - まとめサイトのURLを更新（ https://katahiromz.web.fc2.com/re/matome/ ）。
- v.5.1.1 (2018-11-08)
    - キャプションテキストボックスが空白を受け入れるようにした。
    - 言語テキストボックスが空白を受け入れるようにした。
- v.5.1.2 (2018-12-08)
    - クラステキストボックスが空白を受け入れるようにした。
    - クラステキストボックスでC文字列リテラルを受け付けるようにした。
    - テンプレートシステムを改良。
    - マニフェストのテンプレートを有効にした。
    - ツールバーのUI更新を修正。
    - 「リソースIDの一覧」の「IDの種類」を正しく表示するようにした。
    - 出力のときに言語名をソートするようにした。
- v.5.1.3 (2019-01-01)
    - 「リソースIDの一覧」の修正。
- v.5.1.4 (2019-01-13)
    - 英語のインストーラを追加。
    - イタリア語のインストーラを追加。
    - イタリア語の翻訳を追加。
    - いくつかの言語のインストーラを追加。
- v.5.1.5 (2019-01-27)
    - WS_EX_MDICHILD拡張スタイルを使わないようにした。
    - ReactOSをサポート。
- v.5.1.6 (2019-02-24)
    - イタリア語の改良。
    - GUIの調整。
    - 「別の言語で複製」を修正。
- v.5.1.7 (2019-03-20)
    - PBS_MARQUEEとPBS_SMOOTHREVERSEスタイルを追加。
    - コンパイルエラーの処理を修正。
- v.5.1.8 (2019-05-14)
    - 「別の名前で複製」と「別の言語で複製」で再コンパイルのチェックを追加。
    - 「別の名前で複製」と「別の言語で複製」で複製後の選択を修正。
    - 文字列テーブルとメッセージテーブルのコンパイルエラーでちゃんと失敗。
- v.5.1.9 (2019-07-14)
    - UTF-16ソースの入出力をサポート。
- v.5.2.0 (2019-07-26)
    - DIALOG STYLE を正しく扱う (WS_CAPTION はDIALOG STYLEのデフォルト値)。
    - 圧縮されたEXEファイルを開くときに、展開せずに開いたときにファイルが消えてしまうバグを修正。
    - まとめサイトのURLを更新。
- v.5.2.1 (2019-08-04)
    - 言語名に "En" と入力すると「英語 (アメリカ合衆国)」が選択されるように。
    - 定数の問い合わせ機能を追加。
    - 「すべて折りたたむ」を修正。
    - WS_POPUPWINDOW | WS_BORDER は、WS_POPUPWINDOW | WS_CAPTION でなければならない。
    - RT_FONT のサポート。
    - 「リソースの追加」ダイアログを改良。
- v.5.2.2 (2019-08-14)
    - イタリア語翻訳を更新。
    - XML、XSLT、SCHEMA、そしてREGISTRYリソースタイプのサポート。
    - RT_ICON/RT_CURSOR と RT_GROUP_ICON/RT_GROUP_CURSOR の言語不一致のときの解釈を改良。
    - RT_DLGINIT とRT_DIALOG の言語不一致のときの解釈を改良。
- v.5.2.3 (2019-09-14)
    - AUTORADIOBUTTON STYLE を修正。
- v.5.2.4 (2019-09-15)
    - XP サポート。
- v.5.2.5 (2019-09-19)
    - ダイアログ スタイル リストボックスにおいて WS_CHILDWINDOW のバグを修正。
    - リリースファイル名を変更 (RisohEditor-X.X.X.exe と RisohEditor-X.X.X.zip)。
    - 翻訳者リスト (TRANSLATORS.txt) を追加。
    - オーナードローコントロールを見えるようにした。
- v.5.2.6 (2019-09-23)
    - 「言語の一覧」ダイアログを改良。
    - ロシア語の翻訳を追加。
    - インストール位置にスペース文字があればエラーメッセージを表示する。
    - popen問題を修正するため、windresを呼び出すときに「--use-temp-file」オプションを追加。
- v.5.2.7 (2019-10-20)
    - 「言語の一覧」ダイアログを再び改良。
    - ダイアログ項目のマークの位置を修正。
- v.5.2.8 (2020-01-30)
    - ロシア語リソースを修正。
    - 未定義のコントロールを表示可能に。
    - BEGIN/ENDを使うオプションを追加。
    - DLLを別名で保存できなかった不具合を修正。
- v.5.2.9 (2020-02-01)
    - 5.2.8のXPサポートは忘れた。今、有効に。
    - ファイル保存の処理を修正。
    - ユーザー所有の実行可能ファイルがなくてもEXE/DLLファイルを保存可能に。
    - バックアップ方法を修正。
- v.5.3.0 (2020-02-06)
    - いくつかのテキストボックスにES_AUTOHSCROLLを追加。
    - 上書き保存するときの論理エラーを修正。
- v.5.3.1 (2020-02-23)
    - メニューリソースの読み込みと表示を修正・改良。
    - IDC_STATIC の扱いを改良。
    - 「リソースIDの一覧」ウィンドウを改良。
- v.5.3.2 (2020-03-02)
    - 場所を聞かずにCtrl+Sで保存できる。
    - 「RC ファイルを UTF-16 で出力する」オプションを不揮発性にする。
    - 「リソースIDの一覧」ウィンドウを常に手前に。
- v.5.3.3 (2020-03-03)
    - 9MBから3MBへファイルサイズを削減。
- v.5.3.4 (2020-03-19)
    - ツールバーの保存ボタンの動作を変更。
    - プログラム言語EGAを使った自動化を導入。
    - ファイル変更を保存するか確認を追加した。
- v.5.3.5 (2020-03-26)
    - イタリア語翻訳を改良。
    - 不必要な保存確認を修正。
- v.5.3.6 (2020-04-15)
    - ループ変数を32ビットに変更し、無限ループを回避した。
    - Delphi DFM データのサポート。
    - コンテキストメニューを改良。
- v.5.3.7 (2020-04-28)
    - ファイルドロップ時のファイル変更フラグを更新。
    - 抽出時のファイル名を改良。
    - EGA を強化。
    - ロシア語翻訳を改良。
- v.5.3.8 (2020-05-22)
    - 「自動化」メニューに「EGA マニュアルを開く」項目を追加。
    - ファイル変更フラグを厳密に制御。
- v.5.3.9 (2020-06-01)
    - 「ダイアログ フォントの置き換え」機能を追加。
    - いくつかのメニュー項目を「編集」メニューへ移動。
    - リソース名・リソースの種類のゼロ値のチェックを追加。
    - サンプル リソース ダイアログに DS_CENTER スタイルを追加。
    - ファンクションキーの F1/F3/F5/F6 を有効にした。
    - ポータブル版を追加。
    - 検索機能を改良。
- v.5.4.0 (2020-06-13)
    - RT_ACCELERATOR の出力を修正（16ビット符号なし）。
    - 「ファイルをresフォルダにまとめる」オプションを廃止。
    - GUI編集時のクラッシュを修正。
    - 抽出機能を強化。
    - フォントの置き換え機能の修正。
    - フルパスをタイトルバーに使用。
    - ドロップダウンの言語矢印を追加。
    - 「定数の問い合わせ」ダイアログを修正。
    - 「リソース項目のエンコーディング」ダイアログを修正。
    - 「ID の関連付け」ダイアログを改良。
    - 「定義済みマクロの一覧」ダイアログを改良。
    - 「設定」ダイアログを改良。
    - 「検索」ダイアログを修正。
    - 状態メッセージを改良。
    - 変更フラグの扱いを改良。
- v.5.4.1 (2020-06-14)
    - 二回目の上書き保存で失敗する不具合を修正した。
    - タイトルバーテキストを修正。
    - ステータスバーメッセージを修正。
    - ドイツ語翻訳を追加。
    - フランス語翻訳を追加。
- v.5.4.2 (2020-06-18)
    - コードエディタか16進ビュアを選べるタブコントロールを追加。
    - ドイツ語とフランス語の翻訳を改良。
    - 言語ドロップダウンの矢印を修正。
    - Unicodeエンコーディングの処理を修正。
    - エクスポートと抽出を改良。
    - EGAダイアログを改良。
- v.5.4.3 (2020-07-03)
    - 抽出ファイル名を改良。
    - 名前／言語を変えたとき、ツリービューの項目をソートする。
    - アイコン／カーソルの抽出を改良。
    - テキストの改行コードを改良。
    - 「リソースの追加」ダイアログを修正。
    - HTML/マニフェストをインポート可能に。
    - 「ヘルプ」メニューに更新チェック機能を追加。
    - メッセージボックスのタイトルを修正。
    - 文字数制限を緩和し、大きなデータをサポートした。
    - ファイル保存の際にチェックサムをゼロにリセット。
- v.5.4.4 (2020-07-09)
    - 使用する前にファイルの中身をフラッシュした。
    - 国際的な Delphi の DFM データをサポート。
    - 「Delphi DFM の設定」メニュー項目を「編集」メニューに追加。
    - ファイル保存の際にチェックサムを正しくゼロにリセット。
    - コントロールが1ピクセルずれるバグを修正。
    - ウイルスチェッカーのためにファイル保存時の待機を追加。
- v.5.4.5 (2020-08-03)
    - インドネシア語の翻訳を追加。
    - 言語コンボボックスに自動補完を追加。
- v.5.4.6 (2020-10-03)
    - バージョンチェックにおいてキャッシュを消した。
    - テストダイアログの位置を修正。
    - RT_DLGINITが勝手に消えるバグを修正。
- v.5.4.7 (2020-10-18)
    - XPサポートのため、Inno Setupを5.6.1にダウングレード。
    - テストダイアログでActiveXウィンドウクラス「AtlAxWin140」の初期サポート。
- v.5.4.8 (2020-11-12)
    - フィンランド語の翻訳を追加。
    - *.rc と *.res ファイルの関連付けを追加。
    - OLEコントロールの初期サポート。
    - MOleCtrl を削除し MOleHost を追加。
    - REGINST データをサポート。
- v.5.4.9 (2021-01-21)
    - ツリービュー項目の名前の変更時にIDリストの表示を更新。
- v.5.5.0 (2021-01-26)
    - 韓国語翻訳を追加。
- v.5.5.1 (2021-02-02)
    - windresを2.36にアップグレード。
    - BITMAP または OWNERDRAW のメニュー項目をコンパイルできます。
- v.5.5.2 (2021-02-27)
    - Win2k3のテキストボックスでCtrl+Aを修正。
    - TYPELIB リソースタイプを処理するために tlb2idl プログラムを追加。
    - TYPELIB の閲覧をサポート。
    - ポーランド語の翻訳を追加。
    - 「マニフェスト文を囲む」機能を既定で無効化。
- v.5.5.3 (2021-03-30)
    - windres.exeを2.36.1にアップグレード。
    - mcpp.exe と windres.exe のサブプロセスを作成するのに短いパス名を使用。
- v.5.5.4 (2021-04-13)
    - Vistaアイコンの読み込みを修正。
- v.5.5.5 (2021-04-23)
    - tlb2idl プログラムを削除。
    - TYPELIB リソースタイプを処理するために OleBow プログラムを追加。
    - MIDLコンパイラが利用可能ならばTYPELIBをコンパイルすること。
- v.5.5.6 (2021-04-29)
    - *.rcファイルをインポート可能に。
    - ツリービューの言語矢印を修正。
- v.5.5.7 (2021-06-12)
    - 行番号を付けた。
- v.5.5.8 (2021-06-15)
    - エラーが発生したときに行をマーク。
    - Ctrl+A を修正。
    - mcpp.exe と dfmsc.exe を更新。
- v.5.5.9 (2021-06-16)
    - resource.hのマクロ読み込みを修正。
- v.5.6.0 (2021-06-19)
    - dfmsc.exe を圧縮しない(安全のため)。
    - コマンドラインをサポート。
    - RES_loadとRES_save関数をEGA言語に追加。
- v.5.6.1 (2021-07-01)
    - プロセスの戻り値を修正。
    - メッセージテーブルの扱いを改善。
    - ツリービューの名前変更で大文字にしない。
- v.5.6.2 (2021-08-15)
    - 「保存オプション」と「エクスポート オプション」ダイアログの幅を広げた。
    - マイクロソフト互換モードでメッセージテーブルを追加するための回避策を追加。
- v.5.6.3 (2021-12-12)
    - win32-samplesを追加。
    - 「UI Lanuage Select」を追加。
- v.5.6.4 (2021-12-16)
    - GUI編集を開く前にコンパイルを尋ねる。
- v.5.6.5 (2021-12-18)
    - BS_OWNERDRAW ボタンはプッシュボタン。
    - 「複数の言語へ複製」機能を追加。
    - RADウィンドウの不具合を修正（致命的）。
- v.5.6.6 (2021-12-25)
    - RADウィンドウをダブルクリックするとコントロール／ダイアログのプロパティを開く。
    - ANIカーソルのサポートを改良。
- v.5.6.7 (2022-01-13)
    - ポルトガル語翻訳を追加。
    - WinXP サポートをもう一度（XP で GetThreadUILanguage() を使わないこと）。
- v.5.6.8 (2022-01-17)
    - IDD_CTRLPROP の初期フォーカスを変更。
    - いくつかのバージョン情報を修正。
- v.5.6.9 (2022-03-09)
    - ヒストリーテキストを分離。
    - READMEファイルを改名。
    - ちらつきを減らすためにRADウィンドウにWS_CLIPCHILDRENを追加。
- v.5.7.0 (2022-03-18)
    - リソースIDの管理において再コンパイルを修正。
- v.5.7.1 (2022-03-28)
    - バージョン情報ダイアログを改良。
    - コントロールの表示が悪いので、ちらつきのある方法に戻る。
    - メインウィンドウのフォーカスを記憶。
- v.5.7.2 (2022-06-07)
    - ツールバーリソースをサポート。
- v.5.7.3 (2023-04-01)
    - 小さな性能の改良。
    - 「複数の言語へ複製」を改良。
    - VERSIONINFO の FILESUBTYPE を修正。
    - 「-old」ではなく「~」をバックアップサフィックスにする。
    - 「ダイアログフォントの置き換え...」を「ダイアログフォント代替...」に改名。
- v.5.7.4 (2023-04-02)
    - バージョン番号をIDS_NOTICEに追加。
    - EGAコンソールを改良。
    - 半分壊れたインストーラを修正。
- v.5.7.5 (2023-05-08)
    - IDD_DLGPROP、IDD_CTRLPROP、IDD_ADDCTRLダイアログを改良。
    - 韓国語インストーラを追加。
    - MENUEXの区分線を修正。
- v.5.7.6 (2023-06-02)
    - ヘルプメニューをローカライズ。
    - EGA に RES_str_get と RES_str_set 関数を追加。
- v.5.7.7 (2023-06-05)
    - IDD_ADDDLGINIT と IDD_MODIFYDLGINIT を共通化。
    - RES_str_get と RES_str_set の設計を変更。
    - RES_get_text と RES_set_text 関数をEGAに追加。
- v.5.7.8 (2023-10-06)
    - ポルトガル語（ブラジル）の翻訳を改良。
    - フォント選択条件を緩和。
    - 繁体字中国語を追加。
- v.5.7.9 (2023-11-14)
    - Added EGA sample DeleteNonEnglish.ega.
    - Fixed IDS_THEREISUPDATE translation.

```

`HISTORY-KOR.txt`:

```txt
/////////////////////////////////////////////////////
// 업데이트 내역

- v.0.6 (2017-08-31)
    - 첫번째 출시입니다.
- v.5.0.8 (2018-09-12)
    - 도구 모음 아이콘이 개선되었습니다.
    - 추출시 파일 유형이 수정되었습니다.
    - UTF-8 감지에 도움이 되도록 소스 파일에 dagger를 작성합니다.
    - 트리뷰 아이콘이 수정되었습니다.
    - RT_DIALOG 및 RT_MENU 리소스 템플릿을 언어로 분할합니다.
- v.5.0.9 (2018-09-27)
    - resource.h 출력이 개선되었습니다.
    - 트리뷰 파일 아이콘이 개선되었습니다.
    - 가져오기가 개선되었습니다.
- v.5.1.0 (2018-10-08)
    - "문자열 항목" 대화상자 (여러줄)가 개선되었습니다.
    - Ctrl+A 동작이 수정되었습니다.
    - 파일 저장시 파일 잠금을 확인합니다.
    - 리소스 ID는 대소문자를 구분합니다.
    - 리소스 항목의 인코딩을 지원합니다.
    - "언어" 대화상자에서 비정상 종료가 수정되었습니다.
- v.5.1.1 (2018-11-08)
    - 캡션 텍스트 상자에 공백을 허용합니다.
    - 언어 텍스트 상자에 공백을 허용합니다.
- v.5.1.2 (2018-12-08)
    - 창 클래스 이름 텍스트 상자에 공백을 허용합니다.
    - 창 클래스 이름 텍스트 상자에 C 문자열 리터럴을 허용합니다.
    - 템플릿 시스템이 개선되었습니다.
    - 매니페스트 템플릿을 활성화했습니다.
    - 도구 모음 UI 업데이트가 수정되었습니다.
    - "리소스 ID 목록"의 ID 유형을 올바르게 표시합니다.
    - 출력시 언어를 올바르게 정렬합니다.
- v.5.1.3 (2019-01-01)
    - "리소스 ID 목록"이 수정되었습니다.
- v.5.1.4 (2019-01-13)
    - 영어 설치 프로그램을 추가했습니다.
    - 이탈리아어 설치 프로그램을 추가했습니다.
    - 이탈리아어 번역을 추가했습니다.
    - 일부 언어 설치 프로그램을 추가했습니다.
- v.5.1.5 (2019-01-27)
    - WS_EX_MDICHILD 확장 스타일을 사용하지 않습니다.
    - ReactOS를 지원합니다.
- v.5.1.6 (2019-02-24)
    - 이탈리아어 번역이 개선되었습니다.
    - GUI 조정입니다.
    - "새 언어로 복제"가 수정되었습니다.
- v.5.1.7 (2019-03-20)
    - PBS_MARQUEE 및 PBS_SMOOTHREVERSE 스타일을 추가했습니다.
    - 컴파일 오류 프로세스가 수정되었습니다.
- v.5.1.8 (2019-05-14)
    - 복제시 재컴파일 검사를 추가합니다.
    - 복제 후 선택 사항이 수정되었습니다.
    - 문자열 테이블 및 메시지 테이블의 컴파일 오류시 올바르게 실패합니다.
- v.5.1.9 (2019-07-14)
    - 지원되는 UTF-16 소스 입력/출력입니다.
- v.5.2.0 (2019-07-26)
    - DIALOG STYLE 값을 올바르게 처리합니다 (WS_CAPTION은 DIALOG STYLE의 기본값 임).
    - 확장하지 않고 압축된 EXE 파일을 열 때 응용 프로그램이 예기치 않게 파일을 삭제하는 버그가 수정되었습니다.
- v.5.2.1 (2019-08-04)
    - 언어 이름에 "En"을 입력하면 "영어 (미국)"가 선택됩니다.
    - "쿼리 상수" 기능을 추가했습니다.
    - "모두 축소"가 수정되었습니다.
    - WS_POPUPWINDOW | WS_BORDER는 WS_POPUPWINDOW | WS_CAPTION여야 합니다.
    - RT_FONT 지원합니다.
    - "리소스 추가" 대화 상자가 개선되었습니다.
- v.5.2.2 (2019-08-14)
    - 이탈리아어 번역이 업데이트되었습니다.
    - XML, XSLT, SCHEMA 및 REGISTRY 리소스 유형을 지원합니다.
    - RT_ICON/RT_CURSOR 및 RT_GROUP_ICON/RT_GROUP_CURSOR의 언어 불일치시 해석이 개선되었습니다.
    - RT_DLGINIT 및 RT_DIALOG의 언어 불일치시 해석이 개선되었습니다.
- v.5.2.3 (2019-09-14)
    - AUTORADIOBUTTON STYLE이 수정되었습니다.
- v.5.2.4 (2019-09-15)
    - XP를 지원합니다.
- v.5.2.5 (2019-09-19)
    - 대화 상자 스타일 목록 상자의 WS_CHILDWINDOW 버그가 수정되었습니다.
    - 릴리스 파일 이름 (RisohEditor-X.X.X.exe 및 RisohEditor-X.X.X.zip)이 변경되었습니다.
    - TRANSLATORS.txt가 추가되었습니다.
    - 소유자가 그린 제어를 볼 수 있게 만들었습니다.
- v.5.2.6 (2019-09-23)
    - 언어 대화 상자가 개선되었습니다.
    - 러시아어 번역을 추가했습니다.
    - 설치된 위치에 공백 문자가 있는 경우 오류 메시지를 표시합니다.
    - popen 문제를 해결하기 위해 windres 호출에 --use-temp-file 옵션을 추가했습니다.
- v.5.2.7 (2019-10-20)
    - 언어 대화 상자가 다시 개선되었습니다.
    - 대화 항목 표시의 위치가 수정되었습니다.
- v.5.2.8 (2020-01-30)
    - 러시아어 번역을 수정합니다.
    - 정의되지 않은 컨트롤을 표시할 수 있습니다.
    - "BEGIN/END 사용" 옵션이 추가되었습니다.
    - DLL을 다른 이름으로 저장할 수 없는 버그가 수정되었습니다.
- v.5.2.9 (2020-02-01)
    - 5.2.8의 XP 지원은 잊혀집니다. 이제 활성화되었습니다.
    - 파일 저장 처리가 수정되었습니다.
    - 사용자 소유의 실행 파일없이 EXE/DLL 파일을 저장할 수 있습니다.
    - 백업 방법이 수정되었습니다.
- v.5.3.0 (2020-02-06)
    - 일부 텍스트 상자에 ES_AUTOHSCROLL을 추가했습니다.
    - 파일 덮어쓰기시 논리적 오류가 수정되었습니다.
- v.5.3.1 (2020-02-23)
    - 메뉴 리소스 읽기/표시가 수정되고 개선되었습니다.
    - IDC_STATIC 처리 기능이 개선되었습니다.
    - "리소스 ID 목록" 창이 개선되었습니다.
- v.5.3.2 (2020-03-02)
    - 위치 조회없이 Ctrl+S로 저장할 수 있습니다.
    - "RC 파일을 UTF-16으로 출력" 옵션을 비휘발성으로 설정했습니다.
    - "리소스 ID의 목록" 창을 맨 위로 가져옵니다.
- v.5.3.3 (2020-03-03)
    - 파일 크기를 9MB에서 3MB로 줄였습니다.
- v.5.3.4 (2020-03-19)
    - 도구모음 저장 버튼 동작이 변경되었습니다.
    - 프로그래밍 언어 EGA를 사용하여 자동화를 도입했습니다.
    - 파일 변경 사항 저장 확인을 추가했습니다.
- v.5.3.5 (2020-03-26)
    - 이탈리아어 번역이 개선되었습니다.
    - 불필요한 저장 확인이 수정되었습니다.
- v.5.3.6 (2020-04-15)
    - 루프 변수를 32비트로 변경하면 무한 루프를 피할 수 있습니다.
    - Delphi DFM 데이터를 지원합니다.
    - 상황에 맞는 메뉴가 개선되었습니다.
- v.5.3.7 (2020-04-28)
    - 파일 끌기시 파일 변경 플래그가 업데이트되었습니다.
    - 압축 해제시 파일 이름이 개선되었습니다.
    - EGA가 강화되었습니다.
    - 러시아어 번역이 개선되었습니다.
- v.5.3.8 (2020-05-22)
    - "자동화" 메뉴에 "EGA 수동 열기" 항목이 추가되었습니다.
    - 파일 변경 플래그를 엄격하게 제어했습니다.
- v.5.3.9 (2020-06-01)
    - "대화 대화 글꼴 바꾸기" 기능이 추가되었습니다.
    - 일부 메뉴 항목을 "편집" 메뉴로 이동했습니다.
    - 리소스 이름 및 리소스 유형에 대한 0값 검사를 추가했습니다.
    - 샘플 리소스 대화 상자에 DS_CENTER 스타일을 추가했습니다.
    - F1, F3, F5 및 F6 기능 키를 활성화했습니다.
    - 휴대용 버전이 추가되었습니다.
    - 검색 기능이 개선되었습니다.
- v.5.4.0 (2020-06-13)
    - RT_ACCELERATOR 출력 (부호없는 16비트)이 수정되었습니다.
    - "res 폴더에 저장" 옵션이 제거되었습니다.
    - GUI 편집시 충돌이 수정되었습니다.
    - 추출 기능이 강화되었습니다.
    - replace-dialog-font 기능이 수정되었습니다.
    - 제목 표시줄에 전체 경로를 사용했습니다.
    - 드롭 다운 언어 화살표가 추가되었습니다.
    - "쿼리 상수" 대화상자가 수정되었습니다.
    - "리소스 항목 인코딩" 대화상자가 수정되었습니다.
    - "ID 연결" 대화상자가 개선되었습니다.
    - "미리 정의된 매크로" 대화상자가 개선되었습니다.
    - "구성" 대화상자가 개선되었습니다.
    - "검색"대화상자가 수정되었습니다.
    - 상태 메시지가 개선되었습니다.
    - 플래그 처리가 개선되었습니다.
- v.5.4.1 (2020-06-14)
    - 두 번째 덮어쓰기 저장이 실패하는 버그가 수정되었습니다.
    - 제목 표시줄 텍스트가 수정되었습니다.
    - 상태 표시줄 메시지가 수정되었습니다.
    - 독일어 번역이 추가되었습니다.
    - 프랑스어 번역이 추가되었습니다.
- v.5.4.2 (2020-06-18)
    - "코드 편집기" 또는 "Hex 뷰어"를 선택할 수 있는 탭 컨트롤이 추가되었습니다.
    - 독일어 및 프랑스어 번역이 개선되었습니다.
    - 언어 드롭 다운 화살표가 수정되었습니다.
    - 유니코드 인코딩 처리가 수정되었습니다.
    - 내보내기 및 추출 기능이 개선되었습니다.
    - EGA 대화상자가 개선되었습니다.
- v.5.4.3 (2020-07-03)
    - 추출 파일 이름이 개선되었습니다.
    - 리소스 이름/언어 변경시 트리뷰 항목을 정렬합니다.
    - 아이콘/커서 추출이 개선되었습니다.
    - 인코딩된 텍스트의 개행 코드가 개선되었습니다.
    - "리소스 추가" 대화 상자가 수정되었습니다.
    - HTML/Manifest를 가져올 수 있게 되었습니다.
    - "도움말" 메뉴에 업데이트 확인 기능이 추가되었습니다.
    - 메시지 상자 제목이 수정되었습니다.
    - 글자 수 제한을 완화하고 대용량 데이터를 지원합니다
    - 파일을 저장할 때 체크섬을 0으로 재설정합니다.
- v.5.4.4 (2020-07-09)
    - 사용하기 전에 파일 내용을 비웁니다.
    - 국제 Delphi DFM 데이터를 지원합니다.
    - "Delphi DFM 설정" 메뉴 항목을 "편집" 메뉴에 삽입했습니다.
    - 파일을 저장할 때 체크섬을 0으로 올바르게 재설정합니다.
    - 컨트롤이 1픽셀 씩 이동하는 버그가 수정되었습니다.
    - 바이러스 검사를 위해 파일 저장시 대기 시간이 추가되었습니다.
    - "도움말" 메뉴에 "RisohEditor 안내서" 링크를 추가했습니다.
- v.5.4.5 (2020-08-03)
    - 인도네시아어 번역이 추가되었습니다.
    - 언어 콤보 상자에 자동 완성 기능이 추가되었습니다.
- v.5.4.6 (2020-10-03)
    - 버전 확인에서 캐시를 삭제했습니다.
    - 테스트 대화 상자 위치가 수정되었습니다.
    - RT_DLGINIT가 허가없이 사라지는 버그가 수정되었습니다.
- v.5.4.7 (2020-10-18)
    - XP 지원을 위해 Inno Setup을 5.6.1로 다운그레이드했습니다.
    - 테스트 대화 상자에서 ActiveX 창 클래스 "AtlAxWin140"을 초기 지원합니다.
- v.5.4.8 (2020-11-12)
    - 핀란드어 번역이 추가되었습니다.
    - *.rc 및 *.res 파일 연결이 추가되었습니다.
    - OLE 컨트롤의 초기 지원합니다.
    - MOleCtrl을 삭제하고 MOleHost를 추가했습니다.
    - REGINST 데이터를 지원합니다.
- v.5.4.9 (2021-01-21)
    - 트리뷰 항목의 이름을 바꿀 때 ID 목록을 새로 고칩니다.
- v.5.5.0 (2021-01-26)
    - 한국어 번역이 추가되었습니다.
- v.5.5.1 (2021-02-02)
    - windres를 2.36으로 업그레이드했습니다.
    - BITMAP 또는 OWNERDRAW의 메뉴 항목을 컴파일할 수 있습니다.
- v.5.5.2 (2021-02-27)
    - Win2k3의 텍스트 상자에서 Ctrl+A를 수정했습니다.
    - TYPELIB 리소스 유형을 처리하기 위해 tlb2idl 프로그램을 추가했습니다.
    - TYPELIB 미리보기가 지원됩니다.
    - 폴란드어 번역이 추가되었습니다.
    - 기본적으로 "menifest 문 줄바꿈" 기능을 사용할 수 없습니다.
- v.5.5.3 (2021-03-30)
    - windres.exe가 2.36.1로 업그레이드되었습니다.
    - 짧은 경로명을 사용하여 mcpp.exe 및 windres.exe의 하위 프로세스를 생성합니다.
- v.5.5.4 (2021-04-13)
    - Vista 가져오기 아이콘을 수정합니다.
- v.5.5.5 (2021-04-23)
    - tlb2idl 프로그램을 삭제했습니다.
    - TYPEELIB 리소스 유형을 처리할 OleBow 프로그램을 추가했습니다.
    - MIDL 컴파일러를 사용할 수 있는 경우 TYPEELIB를 컴파일합니다.
- v.5.5.6 (2021-04-29)
    - *.rc 파일을 가져올 수 있게 했습니다.
    - 고정 트리뷰 언어 화살표가 표시됩니다.
- v.5.5.7 (2021-06-12)
    - 줄 번호를 추가합니다.
- v.5.5.8 (2021-06-15)
    - 오류 발생시 라인을 표시합니다.
    - Ctrl+A가 수정되었습니다.
    - mcpp.exe 및 dfmsc.exe가 업데이트되었습니다.
- v.5.5.9 (2021-06-16)
    - resource.h 매크로가 수정되었습니다.
- v.5.6.0 (2021-06-19)
    - dfmsc.exe (보안을 위해)를 압축하지 않습니다.
    - 명령줄이 지원됩니다.
    - EGA 언어에 RES_load 및 RES_save 기능이 추가되었습니다.
- v.5.6.1 (2021-07-01)
    - 프로세스의 반환 값이 수정되었습니다.
    - 메시지 테이블 처리가 개선되었습니다.
    - TreeView에서 이름을 변경할 때 대소문자를 변경하지 마십시오.
- v.5.6.2 (2021-08-15)
    - 저장 옵션 및 "내보내기 옵션" 대화 상자의 너비가 확대되었습니다.
    - Microsoft 호환 모드에서 메시지 테이블을 추가하는 해결 방법이 추가되었습니다.
- v.5.6.3 (2021-12-12)
    - win32-samples가 추가되었습니다.
    - "UI 언어 선택"이 추가되었습니다.
- v.5.6.4 (2021-12-16)
    - GUI 편집을 열기 전에 컴파일을 요청합니다.
- v.5.6.5 (2021-12-18)
    - BS_OWNERDRAW 버튼은 PUSHBUTTON입니다.
    - "다국어로 복사" 기능이 추가되었습니다.
    - RAD 창의 버그를 수정했습니다 (긴급).
- v.5.6.6 (2021-12-25)
    - RAD 창을 두 번 클릭하면 컨트롤/대화상자 속성이 열립니다.
    - ANI 커서 지원이 향상되었습니다.
- v.5.6.7 (2022-01-13)
    - 포르투갈어 번역이 추가되었습니다.
    - WinXP를 다시 지원합니다 (XP에서 GetThreadUILanguage()를 사용하지 않음).
- v.5.6.8 (2022-01-17)
    - IDD_CTRLPROP의 초기 포커스가 변경되었습니다.
    - 일부 버전 정보를 수정했습니다.
- v.5.6.9 (2022-03-09)
    - 이력 텍스트를 분할했습니다.
    - README의 이름이 변경되었습니다.
    - 깜박임을 줄이기 위해 RAD 창용 WS_CLIPCHILEND가 추가되었습니다.
- v.5.7.0 (2022-03-18)
    - 리소스 ID 관리에서 수정된 재컴파일입니다.
- v.5.7.1 (2022-03-28)
    - 버전 정보 대화상자가 개선되었습니다.
    - 잘못된 컨트롤 디스플레이로 인해 깜박임 방법을 사용합니다.
    - 메인 창 초점을 기억했습니다.
- v.5.7.2 (2022-06-07)
    - 지원되는 도구 모음 리소스입니다.
- v.5.7.3 (2023-04-01)
    - 약간의 성능 향상입니다.
    - "다국어로 복사" 기능이 향상되었습니다.
    - VERSIONINFO의 고정 FILESUBTYPE입니다.
    - "-old"가 아닌 "~" 백업 접미사를 만들었습니다.
    - 이름이 "대화 상자 글꼴 바꾸기..." "Dialog 글꼴 대체...""
- v.5.7.4 (2023-04-02)
    - IDS_NOTICE에 버전 번호가 추가되었습니다.
    - 개선된 EGA 콘솔입니다.
    - 고장난 설치 프로그램을 수정했습니다.
- v.5.7.5 (2023-05-08)
    - IDD_DLGPROP, IDD_CTRLPROP, IDD_ADDCTRL 대화 상자가 개선되었습니다.
    - 한국어 설치 프로그램이 추가되었습니다.
    - 고정된 MEENEX 구분 기호입니다.
- v.5.7.6 (2023-06-02)
    - 도움말 메뉴를 현지화했습니다.
    - EGA에 RES_str_get 및 RES_str_set 함수를 추가했습니다.
- v.5.7.7 (2023-06-05)
    - 공통화된 IDD_ADDLGINIT 및 IDD_MODIFYDLGINIT.
    - RES_str_get 및 RES_str_set의 설계를 변경했습니다.
    - EGA에 RES_get_text 및 RES_set_text 함수를 추가했습니다.
- v.5.7.8 (2023-10-06)
    - 포르투갈어(브라질) 번역이 개선되었습니다.
    - 글꼴 선택 요구사항이 완화되었습니다.
    - 중국어 번체 번역이 추가되었습니다.
- v.5.7.9 (2023-11-14)
    - EGA 샘플 DeleteNonEnglish.ega를 추가했습니다.
    - IDS_THEREISUPDATE 번역을 수정했습니다.

```

`HISTORY-PTB.txt`:

```txt
## HISTÓRICO

- v.0.6 (2017-08-31)
    - Primeiro versão.
- v.5.0.8 (2018-09-12)
    - Melhorias nos ícones da barra de ferramentas.
    - Correção no tipo de arquivo ao extrair.
    - Grava punhal no arquivo de origem para ajudar na detecção UTF-8.
    - Correção nos ícones da visualização em árvore.
    - Divide os modelos de recursos RT_DIALOG e RT_MENU em idiomas.
- v.5.0.9 (2018-09-27)
    - Melhoria na saída de resource.h.
    - Melhoria no ícone do arquivo de visualização em árvore.
    - Melhorias na importação.
- v.5.1.0 (2018-10-08)
    - Melhorias nas caixas de diálogo "Entrada de string" (multilinha).
    - Correção no comportamento de Ctrl+A.
    - Verifica o bloqueio do arquivo ao salvar um arquivo.
    - Torna os IDs de recursos sensíveis a maiúsculas e minúsculas.
    - Suporte a codificação de itens de recursos.
    - Correção no encerramento anormal da caixa de diálogo de "Idiomas".
- v.5.1.1 (2018-11-08)
    - Aceita espaço na caixa de texto da legenda.
    - Aceita espaço na caixa de texto de idioma.
- v.5.1.2 (2018-12-08)
    - Aceita espaço na caixa de texto do nome da classe da janela.
    - Aceita o literal de string C na caixa de texto do nome da classe da janela.
    - Melhorias nos modelos do sistema.
    - Ativado modelo de manifesto.
    - Corrigida a atualização da interface do usuário da barra de ferramentas.
    - Exibir corretamente os tipos de ID da "Lista de IDs de Recursos".
    - Classificar corretamente os idiomas na saída.
- v.5.1.3 (2019-01-01)
    - Correção na "Lista de IDs de Recursos".
- v.5.1.4 (2019-01-13)
    - Adicionou instalador em Inglês.
    - Adicionou instalador em Italiano.
    - Adicionou tradução Italiana.
    - Adicionou alguns idiomas do instalador.
- v.5.1.5 (2019-01-27)
    - Não use o estilo estendido WS_EX_MDICHILD.
    - Suporte ao ReactOS.
- v.5.1.6 (2019-02-24)
    - Melhorias na tradução Italiana.
    - Ajuste de GUI.
    - Correção em "Clonar Para Um Novo Idioma".
- v.5.1.7 (2019-03-20)
    - Adicionou estilos PBS_MARQUEE e PBS_SMOOTHREVERSE.
    - Corrigido o processo de erro de compilação.
- v.5.1.8 (2019-05-14)
    - Adicionada verificação de recompilação após a clonagem.
    - Corrigida a seleção após a clonagem.
    - Falha corretamente após erro de compilação da tabela de strings e da tabela de mensagens.
- v.5.1.9 (2019-07-14)
    - Entrada/saída de fonte UTF-16 suportada.
- v.5.2.0 (2019-07-26)
    - Tratar corretamente os valores de `DIALOG STYLE` (`WS_CAPTION` é o valor padrão de `DIALOG STYLE`).
    - Corrigido um bug em que o aplicativo exclui inesperadamente o arquivo ao abrir um arquivo EXE compactado sem expandir.
- v.5.2.1 (2019-08-04)
    - "Inglês (Estados Unidos)" será selecionado se você inserir `"En"` para o nome do idioma.
    - Adicionou o recurso "Consultar Constante".
    - Corrigido "Recolher Todos".
    - `WS_POPUPWINDOW | WS_BORDER` deve ser `WS_POPUPWINDOW | WS_CAPTION`.
    - Suporte `RT_FONT`.
    - Melhorias na caixa de diálogo "Adicionar Recurso".
- v.5.2.2 (2019-08-14)
    - Atualizou a tradução Italiana.
    - Suporte a tipos de recursos XML, XSLT, SCHEMA e REGISTRY.
    - Interpretação aprimorada quando o idioma é incompatível com `RT_ICON`/`RT_CURSOR` e `RT_GROUP_ICON`/`RT_GROUP_CURSOR`.
    - Interpretação aprimorada quando há incompatibilidade de idioma de `RT_DLGINIT` e `RT_DIALOG`.
- v.5.2.3 (2019-09-14)
    - Corrigido `AUTORADIOBUTTON` `STYLE`.
- v.5.2.4 (2019-09-15)
    - Suporte ao XP.
- v.5.2.5 (2019-09-19)
    - Corrigido um bug `WS_CHILDWINDOW` na caixa de listagem de estilo de diálogo.
    - Alterou o nome do arquivo da versão (`RisohEditor-X.X.X.exe` e `RisohEditor-X.X.X.zip`).
    - Adicionou `TRANSLATORS.txt`.
    - Tornou os controles desenhados pelo proprietário visíveis.
- v.5.2.6 (2019-09-23)
    - Melhorias no diálogo de Idiomas.
    - Adicionou a tradução Russa.
    - Mostra mensagem de erro se o local instalado tiver caracteres de espaço.
    - Adicionou a opção `--use-temp-file` ao invocar `windres` para corrigir o problema `popen`.
- v.5.2.7 (2019-10-20)
    - Melhorias no diálogo de Idiomas novamente.
    - Corrigida as posições das marcações de item de diálogo.
- v.5.2.8 (2020-01-30)
    - Corrigida tradução Russa.
    - Capacidade de exibir controles indefinidos.
    - Adicionou a opção "Usar BEGIN/END".
    - Corrigido um bug em que a DLL não podia ser salva com outro nome.
- v.5.2.9 (2020-02-01)
    - O suporte ao XP de 5.2.8 foi esquecido. Agora ativado.
    - Corrigido o processamento ao salvar um arquivo.
    - Capacidade de salvar arquivos EXE/DLL sem executável de propriedade do usuário.
    - Correção como fazer backup.
- v.5.3.0 (2020-02-06)
    - Adicionou `ES_AUTOHSCROLL` a algumas caixas de texto.
    - Corrigido o erro lógico ao substituir o arquivo.
- v.5.3.1 (2020-02-23)
    - Corrigir e melhorar a leitura/exibição dos recursos do menu.
    - Melhorias no manuseio `IDC_STATIC`.
    - Melhorias na janela "Lista de IDs de Recursos".
- v.5.3.2 (2020-03-02)
    - Capacidade de salvar com `Ctrl+S` sem consultar o local.
    - Tornou a opção de saída de "Arquivos RC como UTF-16" não volátil.
    - Trouxe a janela "Lista de IDs de Recursos" para sempre visível.
- v.5.3.3 (2020-03-03)
    - Tamanho do arquivo reduzido de 9MB para 3MB.
- v.5.3.4 (2020-03-19)
    - Alterado o comportamento do botão salvar na barra de ferramentas.
    - Introdução da automação usando a linguagem de programação EGA.
    - Adicionou confirmação ao salvar alterações no arquivo.
- v.5.3.5 (2020-03-26)
    - Melhorias na tradução Italiana.
    - Correção na confirmação de salvamento desnecessária.
- v.5.3.6 (2020-04-15)
    - O loop infinito é evitado alterando as variáveis ​​do loop para 32-bits.
    - Suporte a dados DFM do Delphi.
    - Melhorias no menu de contexto.
- v.5.3.7 (2020-04-28)
    - Atualizou sinalizador de alteração de arquivo quando o arquivo é arrastado.
    - Melhorias no nome do arquivo ao extrair.
    - EGA reforçado.
    - Melhorias na tradução Russa.
- v.5.3.8 (2020-05-22)
    - Adicionado o item "Abrir Manual do EGA" no menu "Automação".
    - Controlou estritamente o sinalizador de alteração de arquivo.
- v.5.3.9 (2020-06-01)
    - Adicionado o recurso "Substituir Fontes de Diálogo".
    - Alguns itens do menu foram movidos para o menu "Editar".
    - Verificação de valor zero adicionado ao nome e tipo de recurso.
    - Adicionado o estilo `DS_CENTER` à caixa de diálogo de recurso de modelo.
    - Teclas de função F1, F3, F5 e F6 habilitadas.
    - Adicionou a versão portátil.
    - Melhorias no recurso de pesquisa.
- v.5.4.0 (2020-06-13)
    - Corrigida a saída `RT_ACCELERATOR` (16-bit não assinada).
    - Removida a opção "Armazenar na pasta res".
    - Corrigida a falha na edição da GUI.
    - Função de extração reforçada.
    - Corrigido recurso de substituição de fontes de diálogo.
    - Usar o caminho completo para a barra de título.
    - Adicionou seta de idioma suspensa.
    - Corrigida caixa de diálogo "Consultar Constante".
    - Corrigida a caixa de diálogo "Codificação do Item de Recurso".
    - Corrigida caixa de diálogo "Associação de ID".
    - Corrigida caixa de diálogo "Macros Predefinidas".
    - Corrigida caixa de diálogo "Configuração".
    - Corrigida caixa de diálogo "Pesquisar".
    - Corrigida mensagem de status.
    - Corrigida a manipulação de sinalizador modificado.
- v.5.4.1 (2020-06-14)
    - Corrigido o bug que falha no segundo salvamento e substituição.
    - Corrigido texto da barra de título.
    - Corrigida a mensagem da barra de status.
    - Adicionou a tradução em Alemão.
    - Adicionou a tradução Francesa.
- v.5.4.2 (2020-06-18)
    - Adicionado controle da aba para escolher "Editor de Código" ou "Visualizador Hex".
    - Traduções aprimoradas de alemão e francês.
    - Corrigida a seta suspensa de idioma.
    - Corrigido o processamento de codificação Unicode.
    - Melhorias na exportação e extração.
    - Melhorias na caixa de diálogo do EGA.
- v.5.4.3 (2020-07-03)
    - Melhorias no nome do arquivo de extração.
    - Classificar os itens de visualização em árvore após a alteração do nome/idioma do recurso.
    - Melhorias na extração de ícone/cursor.
    - Melhorias nos códigos de nova linha de texto codificado.
    - Corrigida caixa de diálogo "Adicionar Recurso".
    - Tornou HTML/Manifest importável.
    - Adicionou o recurso de verificação de atualização no menu "Ajuda".
    - Corrigido o título da caixa de mensagem.
    - Relaxou o limite de caracteres e deu suporte a dados grandes.
    - Redefiniu a soma de verificação para zero ao salvar arquivo.
- v.5.4.4 (2020-07-09)
    - Conteúdo do arquivo liberado antes de usá-lo.
    - Suporte a dados DFM do Delphi internacionais.
    - Item do menu "Configurações DFM do Delphi" inserido no menu "Editar".
    - Redefiniu corretamente a soma de verificação para zero ao salvar arquivo.
    - Corrigido um bug em que um controle é deslocado em 1 pixel.
    - Adicionado algumas esperas ao salvar arquivos, para verificação de vírus.
    - Adicionou o link "Guia do RisohEditor" no menu "Ajuda".
- v.5.4.5 (2020-08-03)
    - Adicionou a tradução Indonésia.
    - Adicionou preenchimento automático para caixas de idiomas.
- v.5.4.6 (2020-10-03)
    - Excluir cache na verificação da versão.
    - Corrigido posição da caixa de diálogo e teste.
    - Corrigido um bug que `RT_DLGINIT` desaparece sem permissão.
- v.5.4.7 (2020-10-18)
    - Downgrade do Inno Setup 5.6.1 para suporte o XP.
    - Suporte inicial da classe de janela ActiveX "AtlAxWin140" na caixa de diálogo de teste.
- v.5.4.8 (2020-11-12)
    - Adicionou a tradução Finlandesa.
    - Adicionada associação de arquivos *.rc e *.res.
    - Suporte inicial de controles OLE.
    - Excluído MOleCtrl e adicionou MOleHost.
    - Suporte a dados REGINST.
- v.5.4.9 (2021-01-21)
    - Atualizou a Lista de IDs ao renomear o item de visualização em árvore.
- v.5.5.0 (2021-01-26)
    - Adicionou a tradução Coreana.
- v.5.5.1 (2021-02-02)
    - Atualizou windres para 2.36.
    - Os itens de menu BITMAP ou OWNERDRAW podem ser compilados.
- v.5.5.2 (2021-02-27)
    - Corrigido Ctrl+A nas caixas de texto do Win2k3.
    - Adicionados programas tlb2idl para processar o tipo de recurso TYPELIB.
    - Suporte a pré-visualização TYPELIB.
    - Adicionada tradução Polonesa.
    - Desativado o recurso "Agrupar as instruções do manifesto" como padrão.
- v.5.5.3 (2021-03-30)
    - Windres.exe atualizado para 2.36.1.
    - Nome de caminho curto usado para gerar subprocessos de mcpp.exe e windres.exe.
- v.5.5.4 (2021-04-13)
    - Correção na importação de ícones do Vista.
- v.5.5.5 (2021-04-23)
    - Programas tlb2idl excluídos.
    - Adicionado o programa OleBow para processar o tipo de recurso TYPELIB.
    - Compilando TYPELIB se o compilador MIDL estiver disponível.
- v.5.5.6 (2021-04-29)
    - Tornou os arquivos *.rc importáveis.
    - Corrigida a exibição da seta de idiomas na visualização em árvore.
- v.5.5.7 (2021-06-12)
    - Adicionou números de linha.
- v.5.5.8 (2021-06-15)
    - Marca a linha ao ocorrer um erro.
    - Corrigido Ctrl+A.
    - Atualizou mcpp.exe e dfmsc.exe.
- v.5.5.9 (2021-06-16)
    - Correção do carregamento de macros resource.h.
- v.5.6.0 (2021-06-19)
    - Não comprimir dfmsc.exe (por segurança).
    - Suporte a linha de comando.
    - Adicionou as funções RES_load e RES_save à linguagem EGA.
- v.5.6.1 (2021-07-01)
    - Corrigido o valor de retorno do processo.
    - Melhorias no manuseio da tabela de mensagens.
    - Não alterar nome para maiúscula/minúscula ao renomear na visualização em árvore.
- v.5.6.2 (2021-08-15)
    - Largura ampliada das caixas de diálogo "Opções de Salvar" e "Opções de Exportar".
    - Adicionou solução alternativa para adicionar tabelas de mensagens no modo compatível com Microsoft.
- v.5.6.3 (2021-12-12)
    - Adicionou exemplos win32.
    - Adicionado "UI Language Select".
- v.5.6.4 (2021-12-16)
    - Pedindo para compilar antes de abrir a edição da GUI.
- v.5.6.5 (2021-12-18)
    - Um botão BS_OWNERDRAW é um PUSHBUTTON.
    - Adicionado o recurso "Copiar para vários idiomas".
    - Corrigido o bug da janela do RAD (Crítico).
- v.5.6.6 (2021-12-25)
    - Clicar duas vezes na janela RAD abre as propriedades de controle/diálogo.
    - Melhorias no suporte de cursor ANI.
- v.5.6.7 (2022-01-13)
    - Adicionou a tradução em Português.
    - Suporte WinXP novamente (não use GetThreadUILanguage() no XP).
- v.5.6.8 (2022-01-17)
    - Alterou o foco inicial de IDD_CTRLPROP.
    - Corrigida algumas informações da versão.
- v.5.6.9 (2022-03-09)
    - Dividiu o texto do histórico.
    - READMEs renomeado.
    - Adicionado WS_CLIPCHILDREN para a janela RAD para reduzir a cintilação.
- v.5.7.0 (2022-03-18)
    - Correção na recompilação no gerenciamento de IDs de recursos.
- v.5.7.1 (2022-03-28)
    - Melhorias na caixa de diálogo de informações da versão.
    - Voltou para um método de cintilação devido à exibição de controle errado.
    - Lembrar foco da janela principal.
- v.5.7.2 (2022-06-07)
    - Recursos suportados da BARRA DE FERRAMENTAS.
- v.5.7.3 (2023-04-01)
    - Pequenas melhorias de desempenho.
    - Melhorias em "Copiar Para Vários Idiomas".
    - Corrigido FILESUBTYPE de VERSIONINFO.
    - Tornou "~" o sufixo de backup em vez de "-old".
    - Renomeado "Substituindo Fontes de diálogo..." como "Substituir Fontes de Diálogo..."
- v.5.7.4 (2023-04-02)
    - Adicionou números de versão a IDS_NOTICE.
    - Melhorias no console do EGA.
    - Corrigido instalador meio quebrado.
- v.5.7.5 (2023-05-08)
    - Melhorias nos diálogos IDD_DLGPROP, IDD_CTRLPROP, IDD_ADDCTRL.
    - Adicionou instalador Coreano.
    - Corrigido o separador MENUEX.
- v.5.7.6 (2023-06-02)
    - Tradução do menu Ajuda.
    - Adicionou as funções RES_str_get e RES_str_set ao EGA.
- v.5.7.7 (2023-06-05)
    - Comunizado IDD_ADDDLGINIT e IDD_MODIFYDLGINIT.
    - Alterou o design de RES_str_get e RES_str_set.
    - Adicionou as funções RES_get_text e RES_set_text ao EGA.
- v.5.7.8 (2023-10-06)
    - Melhorias na tradução Português do Brasil.
    - Relaxed font selection requirements.
    - Added Traditional Chinese translation.
- v.5.7.9 (2023-11-14)
    - Added EGA sample DeleteNonEnglish.ega.
    - Fixed IDS_THEREISUPDATE translation.

```

`HISTORY.txt`:

```txt
## HISTORY

- v.0.6 (2017-08-31)
    - First release.
- v.5.0.8 (2018-09-12)
    - Improve tool bar icons.
    - Fix the file types on extraction.
    - Write dagger to source file to help UTF-8 detection.
    - Fix the treeview icons.
    - Split the RT_DIALOG and RT_MENU resource templates in languages.
- v.5.0.9 (2018-09-27)
    - Improve resource.h output.
    - Improve treeview file icon.
    - Improve importing.
- v.5.1.0 (2018-10-08)
    - Improve "String Entry" dialogs (multiline).
    - Fix Ctrl+A behaviour.
    - Check file lock on saving a file.
    - Make resource IDs case sensitive.
    - Support encoding of resource items.
    - Fix the abnormal termination at "Languages" dialog.
- v.5.1.1 (2018-11-08)
    - Accept space in the caption text box.
    - Accept space in the language text box.
- v.5.1.2 (2018-12-08)
    - Accept space in the window class name text box.
    - Accept C string literal in the window class name text box.
    - Improve template system.
    - Enable manifest template.
    - Fix toolbar UI update.
    - Correctly display ID types of "List of Resource IDs".
    - Correctly sort the languages upon output.
- v.5.1.3 (2019-01-01)
    - Fix "List of Resource IDs".
- v.5.1.4 (2019-01-13)
    - Add English installer.
    - Add Italian installer.
    - Add Italian translation.
    - Add some language installer.
- v.5.1.5 (2019-01-27)
    - Don't use WS_EX_MDICHILD extended style.
    - Support ReactOS.
- v.5.1.6 (2019-02-24)
    - Improve Italian translation.
    - GUI adjustment.
    - Fix "Clone In New Language".
- v.5.1.7 (2019-03-20)
    - Add PBS_MARQUEE and PBS_SMOOTHREVERSE styles.
    - Fix the process of compilation error.
- v.5.1.8 (2019-05-14)
    - Add check of recompilation upon cloning.
    - Fix the selection after cloning.
    - Correctly fail upon compilation error of string table and message table.
- v.5.1.9 (2019-07-14)
    - Supported UTF-16 source input/output.
- v.5.2.0 (2019-07-26)
    - Correctly treat `DIALOG STYLE` values (`WS_CAPTION` is default value of `DIALOG STYLE`).
    - Fixed a bug that the application unexpectedly deletes the file when it opened a compressed EXE file without expanding.
- v.5.2.1 (2019-08-04)
    - "English (United States)" will be selected if you entered `"En"` for language name.
    - Add "Query Constant" feature.
    - Fix "Collapse All".
    - `WS_POPUPWINDOW | WS_BORDER` must be `WS_POPUPWINDOW | WS_CAPTION`.
    - `RT_FONT` support.
    - Improved "Add Resource" dialog.
- v.5.2.2 (2019-08-14)
    - Update Italian translation.
    - Support XML, XSLT, SCHEMA and REGISTRY resource types.
    - Improved interpretation when language mismatch of `RT_ICON`/`RT_CURSOR` and `RT_GROUP_ICON`/`RT_GROUP_CURSOR`.
    - Improved interpretation when language mismatch of `RT_DLGINIT` and `RT_DIALOG`.
- v.5.2.3 (2019-09-14)
    - Fix `AUTORADIOBUTTON` `STYLE`.
- v.5.2.4 (2019-09-15)
    - XP support.
- v.5.2.5 (2019-09-19)
    - Fixed a `WS_CHILDWINDOW` bug in dialog style listbox.
    - Changed the release filename (`RisohEditor-X.X.X.exe` and `RisohEditor-X.X.X.zip`).
    - Added `TRANSLATORS.txt`.
    - Made owner-drawn controls visible.
- v.5.2.6 (2019-09-23)
    - Improve Languages dialog.
    - Add Russian translation.
    - Show error message if the installed location has space characters.
    - Add `--use-temp-file` option in invoking `windres` to fix the `popen` problem.
- v.5.2.7 (2019-10-20)
    - Improved Languages dialog again.
    - Fix the positions of the dialog item marks.
- v.5.2.8 (2020-01-30)
    - Fix Russian translation.
    - Able to display undefined controls.
    - Added "Use BEGIN/END" option.
    - Fixed a bug that DLL could not be saved as another name.
- v.5.2.9 (2020-02-01)
    - XP support of 5.2.8 is forgotten. Now enabled.
    - Fixed processing of file saving.
    - Able to save EXE/DLL files without user-owned executable.
    - Fixed how to backup.
- v.5.3.0 (2020-02-06)
    - Added `ES_AUTOHSCROLL` to some textboxes.
    - Fixed the logical error upon overwriting file.
- v.5.3.1 (2020-02-23)
    - Fix and improve menu resource reading/displaying.
    - Improved `IDC_STATIC` handling.
    - Improved "List of Resource IDs" window.
- v.5.3.2 (2020-03-02)
    - Able to save with `Ctrl+S` without querying the location.
    - Made the "Output RC files as UTF-16" option non-volatile.
    - Bring "List of Resource IDs" window to top.
- v.5.3.3 (2020-03-03)
    - Reduced file size from 9MB to 3MB.
- v.5.3.4 (2020-03-19)
    - Changed toolbar save button behavior.
    - Introduced automation by using programming language EGA.
    - Added confirmation of saving changes of file.
- v.5.3.5 (2020-03-26)
    - Improve Italian translation.
    - Fix needless save confirmation.
- v.5.3.6 (2020-04-15)
    - The infinite loop is avoided by changing the loop variables to 32-bits.
    - Delphi DFM data support.
    - Improved context menu.
- v.5.3.7 (2020-04-28)
    - Updated file change flag when file drop.
    - Improved the filename when extracting.
    - Strengthened EGA.
    - Improved Russian translation.
- v.5.3.8 (2020-05-22)
    - Added "Open EGA Manual" item to "Automation" menu.
    - Strictly controlled the file change flag.
- v.5.3.9 (2020-06-01)
    - Added "replacing-dialog-fonts" feature.
    - Moved some menu items to "Edit" menu.
    - Added value-zero-check of resource name and resource type.
    - Added `DS_CENTER` style to the sample resource dialog.
    - Enabled F1, F3, F5 and F6 function keys.
    - Added Portable version.
    - Improved search feature.
- v.5.4.0 (2020-06-13)
    - Fixed `RT_ACCELERATOR` output (unsigned 16-bit).
    - Removed "Store into res folder" option.
    - Fixed crash upon GUI edit.
    - Strengthened extraction feature.
    - Fixed replacing-dialog-font feature.
    - Used the full path for title bar.
    - Added drop-down language arrow.
    - Fixed "Query Constant" dialog.
    - Fixed "Encoding of Resource Item" dialog.
    - Improved "ID Association" dialog.
    - Improved "Predefined Macros" dialog.
    - Improved "Configuration" dialog.
    - Fixed "Search" dialog.
    - Improved status message.
    - Improved modified flag handling.
- v.5.4.1 (2020-06-14)
    - Fixed the bug that the second overwrite save fails.
    - Fixed title bar text.
    - Fixed status bar message.
    - Added German translation.
    - Added French translation.
- v.5.4.2 (2020-06-18)
    - Added tab control to choose "Code Editor" or "Hex Viewer".
    - Improved German and French translations.
    - Fixed language drop-down arrow.
    - Fixed Unicode encoding processing.
    - Improved exporting and extracting.
    - Improved EGA dialog.
- v.5.4.3 (2020-07-03)
    - Improved extraction filename.
    - Sorted the treeview items upon change of resource name/language.
    - Improved icon/cursor extraction.
    - Improved newline codes of encoded text.
    - Fixed "Add Resource" dialog.
    - Made HTML/Manifest importable.
    - Added update check feature in "Help" menu.
    - Fixed title of message box.
    - Relaxed the character limit and supported large data.
    - Reset checksum to zero when saving file.
- v.5.4.4 (2020-07-09)
    - Flushed file contents before using it.
    - Supported international Delphi DFM data.
    - Inserted "Delphi DFM Settings" menu item into "Edit" menu.
    - Correctly reset checksum to zero when saving file.
    - Fixed a bug in which a control is shifted by 1 pixel.
    - Added some waits upon file saving, for virus checker.
    - Added "A Guide to RisohEditor" link to "Help" menu.
- v.5.4.5 (2020-08-03)
    - Added Indonesian translation.
    - Added auto complete for language combo boxes.
- v.5.4.6 (2020-10-03)
    - Deleted cache in version check.
    - Fixed test dialog position.
    - Fixed a bug that `RT_DLGINIT` disappears without permission.
- v.5.4.7 (2020-10-18)
    - Downgraded Inno Setup to 5.6.1 for XP support.
    - Initial support of ActiveX window class "AtlAxWin140" on test dialog.
- v.5.4.8 (2020-11-12)
    - Added Finnish translation.
    - Added *.rc and *.res file association.
    - Initial support of OLE controls.
    - Deleted MOleCtrl and added MOleHost.
    - Supported REGINST data.
- v.5.4.9 (2021-01-21)
    - Refresh ID List upon renaming treeview item.
- v.5.5.0 (2021-01-26)
    - Add Korean translation.
- v.5.5.1 (2021-02-02)
    - Upgraded windres to 2.36.
    - The menu items of BITMAP or OWNERDRAW can be compiled.
- v.5.5.2 (2021-02-27)
    - Fixed Ctrl+A on textboxes of Win2k3.
    - Added tlb2idl programs to process TYPELIB resource type.
    - Supported TYPELIB preview.
    - Added Polish translation.
    - Disabled "Wrap the manifest statements" feature as default.
- v.5.5.3 (2021-03-30)
    - Upgraded windres.exe to 2.36.1.
    - Used short pathname to spawn subprocesses of mcpp.exe and windres.exe.
- v.5.5.4 (2021-04-13)
    - Fix importing Vista icons.
- v.5.5.5 (2021-04-23)
    - Deleted tlb2idl programs.
    - Added OleBow program to process TYPELIB resource type.
    - Compiling TYPELIB if MIDL compiler is available.
- v.5.5.6 (2021-04-29)
    - Made *.rc files importable.
    - Fixed TreeView languages arrow display.
- v.5.5.7 (2021-06-12)
    - Added line numbers.
- v.5.5.8 (2021-06-15)
    - Marks line upon happening error.
    - Fixed Ctrl+A.
    - Updated mcpp.exe and dfmsc.exe.
- v.5.5.9 (2021-06-16)
    - Fixed loading resource.h macros.
- v.5.6.0 (2021-06-19)
    - Don't compress dfmsc.exe (for security).
    - Supported command line.
    - Added RES_load and RES_save functions to EGA language.
- v.5.6.1 (2021-07-01)
    - Fixed the return value of process.
    - Improved message table handling.
    - Don't change the case of name when renaming it in TreeView.
- v.5.6.2 (2021-08-15)
    - Enlarged width of "Save Options" and "Export Options" dialogs.
    - Added workaround to add message tables on Microsoft compatible mode.
- v.5.6.3 (2021-12-12)
    - Added win32-samples.
    - Added "UI Lanuage Select".
- v.5.6.4 (2021-12-16)
    - Asking for compiling before opening GUI edit.
- v.5.6.5 (2021-12-18)
    - A BS_OWNERDRAW button is a PUSHBUTTON.
    - Added "Copy to multiple languages" feature.
    - Fixed the bug of the RAD window (Critical).
- v.5.6.6 (2021-12-25)
    - Double-clicking the RAD window opens the control/dialog properties.
    - Improved ANI cursor support.
- v.5.6.7 (2022-01-13)
    - Added Portuguese translation.
    - WinXP support again (don't use GetThreadUILanguage() in XP).
- v.5.6.8 (2022-01-17)
    - Changed the initial focus of IDD_CTRLPROP.
    - Fixed some version info.
- v.5.6.9 (2022-03-09)
    - Splited the history text.
    - Renamed READMEs.
    - Added WS_CLIPCHILDREN for RAD window to reduce flickering.
- v.5.7.0 (2022-03-18)
    - Fixed recompilation in management of resource IDs.
- v.5.7.1 (2022-03-28)
    - Improved version info dialog.
    - Backed to a flickering method due to wrong control display.
    - Remembered main window focus.
- v.5.7.2 (2022-06-07)
    - Supported TOOLBAR resources.
- v.5.7.3 (2023-04-01)
    - Minor performance improvements.
    - Improved "Copy to multiple languages".
    - Fixed FILESUBTYPE of VERSIONINFO.
    - Made "~" the backup suffix rather than "-old".
    - Renamed "Replacing Dialog Fonts..." as "Dialog font substitutes..."
- v.5.7.4 (2023-04-02)
    - Added version numbers to IDS_NOTICE.
    - Improved EGA console.
    - Fixed half-broken installer.
- v.5.7.5 (2023-05-08)
    - Improved IDD_DLGPROP, IDD_CTRLPROP, IDD_ADDCTRL dialogs.
    - Added Korean installer.
    - Fixed MENUEX separator.
- v.5.7.6 (2023-06-02)
    - Localized the Help menu.
    - Added RES_str_get and RES_str_set functions to EGA.
- v.5.7.7 (2023-06-05)
    - Commonized IDD_ADDDLGINIT and IDD_MODIFYDLGINIT.
    - Changed the design of RES_str_get and RES_str_set.
    - Added RES_get_text and RES_set_text functions to EGA.
- v.5.7.8 (2023-10-06)
    - Improved Portuguese (Brazilian) translation.
    - Relaxed font selection requirements.
    - Added Traditional Chinese translation.
- v.5.7.9 (2023-11-14)
    - Added EGA sample DeleteNonEnglish.ega.
    - Fixed IDS_THEREISUPDATE translation.

```

`HYOJUNKA.md`:

```md
# Win32リソースの標準化

(UTF-8, Japanese)

新しいリソーエディタのリソース情報は、以下のガイドラインに従うべきです。
古いリソーエディタのデータを使っているなら、以下のガイドラインを適用する必要があります。

## 定義

- 「リソースID」とは、Win32リソースデータに使われるIDです。
- 「IDプレフィックス」とは、リソースIDのプレフィックス (prefix) です。
- 「エンティティ リソース」とは、RT_ICON、RT_CURSOR、RT_STRING、RT_MANIFEST、RT_VERSION、そしてRT_MESSAGETABLE以外のリソースデータです。
- エンティティ リソースの「リソース名」とは、16ビット整数値か、ワイド文字列か、16ビット整数値のマクロです。
- RT_ICONタイプのリソースデータは、RT_GROUP_ICON タイプのリソースデータによって参照されます。
- RT_CURSORタイプのリソースデータは、RT_GROUP_CURSOR タイプのリソースデータによって参照されます。
- RT_STRINGまたはRT_MESSAGETABLEリソースは、複数のリソースIDを含むことができます。
- RT_MANIFESTまたはRT_VERSIONのリソースIDは特別な意味を持ちます。
- 「ユーザーリソース」とは、ユーザーのプロジェクトが直接提供し、かつ、他のプロジェクトやフレームワークによって提供されない、Win32リソースデータです。
- 「ユーザーID」とは、ユーザーのプロジェクトが直接提供し、かつ、他のプロジェクトやフレームワークによって提供されないリソースIDです。
- 「アイコンID」とは、RT_GROUP_ICON タイプのリソースIDです。
- 「カーソルID」とは、RT_GROUP_CURSOR タイプのリソースIDです。
- 「文字列ID」とは、文字列テーブルの中の1個の文字列データのIDです。
- 「メッセージID」とは、メッセージテーブルの中の1個のメッセージデータのIDです。

## ガイドライン

Visual C++互換性のために、ファイル「resource.h」の中身は、次のようなC++コメントで始まるべきです。

```c
//{{NO_DEPENDENCIES}}
// Microsoft Visual C++ Compatible
// TheProject.rc
```

ここで、「TheProject.rc」は、この「resource.h」に対する実際のリソースファイル名で置き換えなければなりません。

ファイル「resource.h」は、インクルードガードを使うべきではありません。

ファイル「resource.h」の中で、文字列マクロを使わないで下さい。文字列値のリソースIDを使わないで下さい。

もし、rcファイルがシステムヘッダーの#includeを有するなら、そのインクルードは、次のように包まれるべきです：

```c
#define APSTUDIO_HIDDEN_SYMBOLS
#include <windows.h>
#include <commctrl.h>
#undef APSTUDIO_HIDDEN_SYMBOLS
```

ファイル「resource.h」の中身は、次のようなテキストで終わるべきです：

```c
#ifdef APSTUDIO_INVOKED
    #ifndef APSTUDIO_READONLY_SYMBOLS
        #define _APS_NO_MFC                 1
        #define _APS_NEXT_RESOURCE_VALUE    1000
        #define _APS_NEXT_COMMAND_VALUE     220
        #define _APS_NEXT_CONTROL_VALUE     1002
        #define _APS_NEXT_SYMED_VALUE       300
    #endif
#endif
```

ここに、_APS_NO_MFC マクロの値は1であるべきです。
ここに、_APS_NEXT_RESOURCE_VALUE マクロの値は、すべてのユーザー エンティティ リソースの最大整数値 + 1でなければなりません。
ここに、_APS_NEXT_COMMAND_VALUE マクロの値は、すべてのユーザー コマンド IDの最大整数値 + 1でなければなりません。
ここに、_APS_NEXT_CONTROL_VALUE マクロの値は、すべてのユーザー コントロールIDの最大整数値 + 1でなければなりません。
ここに、_APS_NEXT_SYMED_VALUE マクロの値は無視するべきです。

## IDプレフィックス

「resource.h」で定義されるユーザーIDプレフィックスは次の表に従うべきです：

| IDタイプ               | IDプレフィックス |
|------------------------|------------------|
| String ID              | IDS_             |
| Message ID             | MSGID_           |
| Command ID             | ID_              |
| Command ID (Old Type)  | IDM_             |
| Control ID             | IDC_             |
| Cursor ID              | IDC_             |
| Icon ID                | IDI_             |
| Dialog ID              | IDD_             |
| Bitmap ID              | IDB_             |
| その他のエンティティID | IDR_             |
| Window ID              | IDW_             |
| Help ID                | HID_             |

「IDP_」プレフィックスは使わないで下さい。

## 値と範囲

「resource.h」で定義されるユーザーIDは、次の表の範囲であるべきです。

| IDタイプ               | 束縛範囲      | 好ましい範囲  |
|------------------------|---------------|---------------|
| String ID              | 1～0x7FFF     | 100～0x7FFF   |
| Message ID             | 0～0xFFFFFFFF | 1～0x7FFFFFFF |
| Command ID             | 1～0x7FFF     | 100～0x7FFF   |
| Command ID (Old Type)  | 1～0x7FFF     | 100～0x7FFF   |
| Control ID             | 8～0xDFFF     | 1000～0x7FFF  |
| Cursor ID              | 1～0x7FFF     | 100～999      |
| Icon ID                | 1～0x7FFF     | 100～999      |
| Dialog ID              | 1～0x7FFF     | 100～0x7FFF   |
| Bitmap ID              | 1～0x7FFF     | 100～0x7FFF   |
| その他のエンティティID | 1～0x7FFF     | 100～0x7FFF   |
| Window ID              | 1～0x7FFF     | 1～0x7FFF     |
| Help ID                | 0～0xFFFFFFFF | 1～0x7FFFFFFF |

同じIDプレフィックスの２つの異なるリソースIDは、互いに違う値を持つべきです。
「IDC_」のリソースIDは、コントロールIDか、カーソルIDです。
もし、我々がIDの好ましい範囲に従えば、コントロールIDとカーソルIDは衝突しません。

## TEXTINCLUDE

Visual C++ 互換性のために、リソースファイルは、以下のような3個のTEXTINCLUDEデータを有しなければなりません：

```rc
#ifdef APSTUDIO_INVOKED

1 TEXTINCLUDE
BEGIN
    "resource.h\0"
END

2 TEXTINCLUDE 
BEGIN
    "#define APSTUDIO_HIDDEN_SYMBOLS\r\n"
    "#include <windows.h>\r\n"
    "#include <commctrl.h>\r\n"
    "#undef APSTUDIO_HIDDEN_SYMBOLS\r\n"
    "\0"
END

3 TEXTINCLUDE 
BEGIN
    "\r\n"
    "\0"
END

#endif    // APSTUDIO_INVOKED
```

## コメント

「resource.h」ファイルのリソースファイルは、CコメントよりもC++コメントを使うべきです。

## 参照

[https://msdn.microsoft.com/en-us/library/t2zechd4.aspx](https://msdn.microsoft.com/en-us/library/t2zechd4.aspx)

```

`HYOJUNKA.txt`:

```txt

【Win32リソースの標準化】

(UTF-8, Japanese)

新しいリソーエディタのリソース情報は、以下のガイドラインに従うべきです。
古いリソーエディタのデータを使っているなら、以下のガイドラインを適用する
必要があります。


■定義

　・「リソースID」とは、Win32リソースデータに使われるIDです。
　・「IDプレフィックス」とは、リソースIDのプレフィックス (prefix) です。
　・「エンティティ リソース」とは、RT_ICON、RT_CURSOR、RT_STRING、RT_MANIFEST、RT_VERSION、そしてRT_MESSAGETABLE以外のリソースデータです。
　・エンティティ リソースの「リソース名」とは、16ビット整数値か、ワイド文字列か、16ビット整数値のマクロです。
　・RT_ICONタイプのリソースデータは、RT_GROUP_ICON タイプのリソースデータによって参照されます。
　・RT_CURSORタイプのリソースデータは、RT_GROUP_CURSOR タイプのリソースデータによって参照されます。
　・RT_STRINGまたはRT_MESSAGETABLEリソースは、複数のリソースIDを含むことができます。
　・RT_MANIFESTまたはRT_VERSIONのリソースIDは特別な意味を持ちます。
　・「ユーザーリソース」とは、ユーザーのプロジェクトが直接提供し、かつ、他のプロジェクトやフレームワークによって提供されない、Win32リソースデータです。
　・「ユーザーID」とは、ユーザーのプロジェクトが直接提供し、かつ、他のプロジェクトやフレームワークによって提供されないリソースIDです。
　・「アイコンID」とは、RT_GROUP_ICON タイプのリソースIDです。
　・「カーソルID」とは、RT_GROUP_CURSOR タイプのリソースIDです。
　・「文字列ID」とは、文字列テーブルの中の1個の文字列データのIDです。
　・「メッセージID」とは、メッセージテーブルの中の1個のメッセージデータのIDです。


■ガイドライン

Visual C++互換性のために、ファイル「resource.h」の中身は、次のようなC+
+コメントで始まるべきです。

//{{NO_DEPENDENCIES}}
// Microsoft Visual C++ Compatible
// TheProject.rc

ここで、「TheProject.rc」は、この「resource.h」に対する実際の
リソースファイル名で置き換えなければなりません。

ファイル「resource.h」は、インクルードガードを使うべきではありません。

ファイル「resource.h」の中で、文字列マクロを使わないで下さい。
文字列値のリソースIDを使わないで下さい。

もし、rcファイルがシステムヘッダーの#includeを有するなら、その
インクルードは、次のように包まれるべきです：

#define APSTUDIO_HIDDEN_SYMBOLS
#include <windows.h>
#include <commctrl.h>
#undef APSTUDIO_HIDDEN_SYMBOLS

ファイル「resource.h」の中身は、次のようなテキストで終わるべきです：

#ifdef APSTUDIO_INVOKED
    #ifndef APSTUDIO_READONLY_SYMBOLS
        #define _APS_NO_MFC                 1
        #define _APS_NEXT_RESOURCE_VALUE    1000
        #define _APS_NEXT_COMMAND_VALUE     220
        #define _APS_NEXT_CONTROL_VALUE     1002
        #define _APS_NEXT_SYMED_VALUE       300
    #endif
#endif

ここに、_APS_NO_MFC マクロの値は1であるべきです。
ここに、_APS_NEXT_RESOURCE_VALUE マクロの値は、すべてのユーザー 
エンティティ リソースの最大整数値 + 1でなければなりません。
ここに、_APS_NEXT_COMMAND_VALUE マクロの値は、すべてのユーザー 
コマンド IDの最大整数値 + 1でなければなりません。
ここに、_APS_NEXT_CONTROL_VALUE マクロの値は、すべてのユーザー 
コントロールIDの最大整数値 + 1でなければなりません。
ここに、_APS_NEXT_SYMED_VALUE マクロの値は無視するべきです。


■IDプレフィックス

「resource.h」で定義されるユーザーIDプレフィックスは次の表に従うべき
です：

+----------------------------------+------------------------+
|             IDタイプ             |    IDプレフィックス    |
+----------------------------------+------------------------+
|            String ID             |          IDS_          |
+----------------------------------+------------------------+
|            Message ID            |         MSGID_         |
+----------------------------------+------------------------+
|            Command ID            |          ID_           |
+----------------------------------+------------------------+
|      Command ID (Old Type)       |          IDM_          |
+----------------------------------+------------------------+
|            Control ID            |          IDC_          |
+----------------------------------+------------------------+
|            Cursor ID             |          IDC_          |
+----------------------------------+------------------------+
|             Icon ID              |          IDI_          |
+----------------------------------+------------------------+
|            Dialog ID             |          IDD_          |
+----------------------------------+------------------------+
|            Bitmap ID             |          IDB_          |
+----------------------------------+------------------------+
|      その他のエンティティID      |          IDR_          |
+----------------------------------+------------------------+
|            Window ID             |          IDW_          |
+----------------------------------+------------------------+
|             Help ID              |          HID_          |
+----------------------------------+------------------------+

「IDP_」プレフィックスは使わないで下さい。


■値と範囲

「resource.h」で定義されるユーザーIDは、次の表の範囲であるべきです。

+----------------------------------+---------------------+---------------------+
|             IDタイプ             |      束縛範囲       |    好ましい範囲     |
+----------------------------------+---------------------+---------------------+
|            String ID             |      1～0x7FFF      |     100～0x7FFF     |
+----------------------------------+---------------------+---------------------+
|            Message ID            |    0～0xFFFFFFFF    |    1～0x7FFFFFFF    |
+----------------------------------+---------------------+---------------------+
|            Command ID            |      1～0x7FFF      |     100～0x7FFF     |
+----------------------------------+---------------------+---------------------+
|      Command ID (Old Type)       |      1～0x7FFF      |     100～0x7FFF     |
+----------------------------------+---------------------+---------------------+
|            Control ID            |      8～0xDFFF      |    1000～0x7FFF     |
+----------------------------------+---------------------+---------------------+
|            Cursor ID             |      1～0x7FFF      |      100～999       |
+----------------------------------+---------------------+---------------------+
|             Icon ID              |      1～0x7FFF      |      100～999       |
+----------------------------------+---------------------+---------------------+
|            Dialog ID             |      1～0x7FFF      |     100～0x7FFF     |
+----------------------------------+---------------------+---------------------+
|            Bitmap ID             |      1～0x7FFF      |     100～0x7FFF     |
+----------------------------------+---------------------+---------------------+
|      その他のエンティティID      |      1～0x7FFF      |     100～0x7FFF     |
+----------------------------------+---------------------+---------------------+
|            Window ID             |      1～0x7FFF      |      1～0x7FFF      |
+----------------------------------+---------------------+---------------------+
|             Help ID              |    0～0xFFFFFFFF    |    1～0x7FFFFFFF    |
+----------------------------------+---------------------+---------------------+

同じIDプレフィックスの２つの異なるリソースIDは、互いに違う値を持つべき
です。
「IDC_」のリソースIDは、コントロールIDか、カーソルIDです。
もし、我々がIDの好ましい範囲に従えば、コントロールIDとカーソルIDは
衝突しません。


■TEXTINCLUDE

Visual C++ 互換性のために、リソースファイルは、以下のような3個の
TEXTINCLUDEデータを有しなければなりません：

#ifdef APSTUDIO_INVOKED

1 TEXTINCLUDE
BEGIN
    "resource.h\0"
END

2 TEXTINCLUDE 
BEGIN
    "#define APSTUDIO_HIDDEN_SYMBOLS\r\n"
    "#include <windows.h>\r\n"
    "#include <commctrl.h>\r\n"
    "#undef APSTUDIO_HIDDEN_SYMBOLS\r\n"
    "\0"
END

3 TEXTINCLUDE 
BEGIN
    "\r\n"
    "\0"
END

#endif    // APSTUDIO_INVOKED


■コメント

「resource.h」ファイルのリソースファイルは、CコメントよりもC++コメント
を使うべきです。


■参照

https://msdn.microsoft.com/en-us/library/t2zechd4.aspx

```

`HowToBuild.md`:

```md
# How to build RisohEditor

## Requirements

- Visual Studio 2017 or 2019
- MSYS2
- CMake
- Inno Setup 5.6.1 (u)

ATL support is for Visual C++ only.

## Pre-task

- Load `src/RisohEditor_res.rc` by RisohEditor and save it as UTF-16 if you are using Visual Studio.

## Build task

- Open Visual Studio Command Prompt or MSYS2 and go to `RisohEditor` directory by `cd` command.
- Execute a `cmake` command line using CMake.
    - Please specify `-G "(generator)"`. To get the generator list, please specify `-G` only.
    - If ATL support is needed, then add `-DATL_SUPPORT=ON`.
    - If you want XP support, use `v141_xp` toolset (`-T v141_xp`).
    - `-A Win32` might be needed if your VS uses `x64` as default.
- Build it by using the solution file, Makefile or Ninja.
- Copy the contents of `build/Debug` or `build/Release` into `build/`.

## Making an installer

- Open `installer.iss` with Inno Setup.
- Build it.

```

`LICENSE.txt`:

```txt
RisohEditor is a resource editor for Win32 development,
created by Katayama Hirofumi MZ (katahiromz). RisohEditor
is released under the terms of GNU GENERAL PUBLIC LICENSE
Version 3, 29 June 2007. The source code of RisohEditor is
available at https://github.com/katahiromz/RisohEditor .

RisohEditor --- Another Win32 resource editor
Copyright (C) 2017-2021 Katayama Hirofumi MZ <katayama.hirofumi.mz@gmail.com>.
Copyright (C) 2019-2020 Linhong Xiang <lhxy24@163.com>.
Copyright (C) 2019-2020 Dmitry Y <erodim@mail.ru>.
Copyright (C) 2019-2020 Roberto Boriotti <roberto.boriotti@libero.it>.
Copyright (C) 2020 Mas Ahmad Muhammad <m.charly81@gmail.com>.
Copyright (C) 2020 Veikko Muurikainen <veikko.muurikainen@kolumbus.fi>
Copyright (C) 2021 VenusGirl <venusgirl@outlook.com>
Copyright (C) 2021 Piotr Hetnarowicz <piotrhwz@gmail.com>

All rights reserved.
---------------------------------------------------
RisohEditor contains the "windres" program. The "windres"
program is a part of GNU Binutils, that is released under
the terms of GNU GENERAL PUBLIC LICENSE Version 3, 29 June
2007. The source code of windres is available
at http://sourceware.org/binutils/ .

GNU windres (GNU Binutils) 2.36.1
Copyright (C) 2021 Free Software Foundation, Inc.
This program is free software; you may redistribute it under the terms of
the GNU General Public License version 3 or (at your option) any later version.
This program has absolutely no warranty.
---------------------------------------------------
RisohEditor contains the "mcpp" program.
The source code of mcpp is available at https://github.com/katahiromz/mcpp .
mcpp is licensed under its special terms as below:

/*-
 * Copyright (c) 1998, 2002-2008 Kiyoshi Matsui <kmatsui@t3.rim.or.jp>
 * All rights reserved.
 *
 * This software including the files in this directory is provided under
 * the following license.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */

---------------------------------------------------
RisohEditor contains the "dfmsc" program.
The source code of dfmsc is available at https://github.com/katahiromz/dfmsc .
dfmsc is licensed under the MIT License.
---------------------------------------------------
RisohEditor contains the "OleBow" programs.
The source code of OleBow is available at https://github.com/katahiromz/OleBow .
OleBow is licensed under the MIT License.
---------------------------------------------------
                    GNU GENERAL PUBLIC LICENSE
                       Version 3, 29 June 2007

 Copyright (C) 2007 Free Software Foundation, Inc. <http://fsf.org/>
 Everyone is permitted to copy and distribute verbatim copies
 of this license document, but changing it is not allowed.

                            Preamble

  The GNU General Public License is a free, copyleft license for
software and other kinds of works.

  The licenses for most software and other practical works are designed
to take away your freedom to share and change the works.  By contrast,
the GNU General Public License is intended to guarantee your freedom to
share and change all versions of a program--to make sure it remains free
software for all its users.  We, the Free Software Foundation, use the
GNU General Public License for most of our software; it applies also to
any other work released this way by its authors.  You can apply it to
your programs, too.

  When we speak of free software, we are referring to freedom, not
price.  Our General Public Licenses are designed to make sure that you
have the freedom to distribute copies of free software (and charge for
them if you wish), that you receive source code or can get it if you
want it, that you can change the software or use pieces of it in new
free programs, and that you know you can do these things.

  To protect your rights, we need to prevent others from denying you
these rights or asking you to surrender the rights.  Therefore, you have
certain responsibilities if you distribute copies of the software, or if
you modify it: responsibilities to respect the freedom of others.

  For example, if you distribute copies of such a program, whether
gratis or for a fee, you must pass on to the recipients the same
freedoms that you received.  You must make sure that they, too, receive
or can get the source code.  And you must show them these terms so they
know their rights.

  Developers that use the GNU GPL protect your rights with two steps:
(1) assert copyright on the software, and (2) offer you this License
giving you legal permission to copy, distribute and/or modify it.

  For the developers' and authors' protection, the GPL clearly explains
that there is no warranty for this free software.  For both users' and
authors' sake, the GPL requires that modified versions be marked as
changed, so that their problems will not be attributed erroneously to
authors of previous versions.

  Some devices are designed to deny users access to install or run
modified versions of the software inside them, although the manufacturer
can do so.  This is fundamentally incompatible with the aim of
protecting users' freedom to change the software.  The systematic
pattern of such abuse occurs in the area of products for individuals to
use, which is precisely where it is most unacceptable.  Therefore, we
have designed this version of the GPL to prohibit the practice for those
products.  If such problems arise substantially in other domains, we
stand ready to extend this provision to those domains in future versions
of the GPL, as needed to protect the freedom of users.

  Finally, every program is threatened constantly by software patents.
States should not allow patents to restrict development and use of
software on general-purpose computers, but in those that do, we wish to
avoid the special danger that patents applied to a free program could
make it effectively proprietary.  To prevent this, the GPL assures that
patents cannot be used to render the program non-free.

  The precise terms and conditions for copying, distribution and
modification follow.

                       TERMS AND CONDITIONS

  0. Definitions.

  "This License" refers to version 3 of the GNU General Public License.

  "Copyright" also means copyright-like laws that apply to other kinds of
works, such as semiconductor masks.

  "The Program" refers to any copyrightable work licensed under this
License.  Each licensee is addressed as "you".  "Licensees" and
"recipients" may be individuals or organizations.

  To "modify" a work means to copy from or adapt all or part of the work
in a fashion requiring copyright permission, other than the making of an
exact copy.  The resulting work is called a "modified version" of the
earlier work or a work "based on" the earlier work.

  A "covered work" means either the unmodified Program or a work based
on the Program.

  To "propagate" a work means to do anything with it that, without
permission, would make you directly or secondarily liable for
infringement under applicable copyright law, except executing it on a
computer or modifying a private copy.  Propagation includes copying,
distribution (with or without modification), making available to the
public, and in some countries other activities as well.

  To "convey" a work means any kind of propagation that enables other
parties to make or receive copies.  Mere interaction with a user through
a computer network, with no transfer of a copy, is not conveying.

  An interactive user interface displays "Appropriate Legal Notices"
to the extent that it includes a convenient and prominently visible
feature that (1) displays an appropriate copyright notice, and (2)
tells the user that there is no warranty for the work (except to the
extent that warranties are provided), that licensees may convey the
work under this License, and how to view a copy of this License.  If
the interface presents a list of user commands or options, such as a
menu, a prominent item in the list meets this criterion.

  1. Source Code.

  The "source code" for a work means the preferred form of the work
for making modifications to it.  "Object code" means any non-source
form of a work.

  A "Standard Interface" means an interface that either is an official
standard defined by a recognized standards body, or, in the case of
interfaces specified for a particular programming language, one that
is widely used among developers working in that language.

  The "System Libraries" of an executable work include anything, other
than the work as a whole, that (a) is included in the normal form of
packaging a Major Component, but which is not part of that Major
Component, and (b) serves only to enable use of the work with that
Major Component, or to implement a Standard Interface for which an
implementation is available to the public in source code form.  A
"Major Component", in this context, means a major essential component
(kernel, window system, and so on) of the specific operating system
(if any) on which the executable work runs, or a compiler used to
produce the work, or an object code interpreter used to run it.

  The "Corresponding Source" for a work in object code form means all
the source code needed to generate, install, and (for an executable
work) run the object code and to modify the work, including scripts to
control those activities.  However, it does not include the work's
System Libraries, or general-purpose tools or generally available free
programs which are used unmodified in performing those activities but
which are not part of the work.  For example, Corresponding Source
includes interface definition files associated with source files for
the work, and the source code for shared libraries and dynamically
linked subprograms that the work is specifically designed to require,
such as by intimate data communication or control flow between those
subprograms and other parts of the work.

  The Corresponding Source need not include anything that users
can regenerate automatically from other parts of the Corresponding
Source.

  The Corresponding Source for a work in source code form is that
same work.

  2. Basic Permissions.

  All rights granted under this License are granted for the term of
copyright on the Program, and are irrevocable provided the stated
conditions are met.  This License explicitly affirms your unlimited
permission to run the unmodified Program.  The output from running a
covered work is covered by this License only if the output, given its
content, constitutes a covered work.  This License acknowledges your
rights of fair use or other equivalent, as provided by copyright law.

  You may make, run and propagate covered works that you do not
convey, without conditions so long as your license otherwise remains
in force.  You may convey covered works to others for the sole purpose
of having them make modifications exclusively for you, or provide you
with facilities for running those works, provided that you comply with
the terms of this License in conveying all material for which you do
not control copyright.  Those thus making or running the covered works
for you must do so exclusively on your behalf, under your direction
and control, on terms that prohibit them from making any copies of
your copyrighted material outside their relationship with you.

  Conveying under any other circumstances is permitted solely under
the conditions stated below.  Sublicensing is not allowed; section 10
makes it unnecessary.

  3. Protecting Users' Legal Rights From Anti-Circumvention Law.

  No covered work shall be deemed part of an effective technological
measure under any applicable law fulfilling obligations under article
11 of the WIPO copyright treaty adopted on 20 December 1996, or
similar laws prohibiting or restricting circumvention of such
measures.

  When you convey a covered work, you waive any legal power to forbid
circumvention of technological measures to the extent such circumvention
is effected by exercising rights under this License with respect to
the covered work, and you disclaim any intention to limit operation or
modification of the work as a means of enforcing, against the work's
users, your or third parties' legal rights to forbid circumvention of
technological measures.

  4. Conveying Verbatim Copies.

  You may convey verbatim copies of the Program's source code as you
receive it, in any medium, provided that you conspicuously and
appropriately publish on each copy an appropriate copyright notice;
keep intact all notices stating that this License and any
non-permissive terms added in accord with section 7 apply to the code;
keep intact all notices of the absence of any warranty; and give all
recipients a copy of this License along with the Program.

  You may charge any price or no price for each copy that you convey,
and you may offer support or warranty protection for a fee.

  5. Conveying Modified Source Versions.

  You may convey a work based on the Program, or the modifications to
produce it from the Program, in the form of source code under the
terms of section 4, provided that you also meet all of these conditions:

    a) The work must carry prominent notices stating that you modified
    it, and giving a relevant date.

    b) The work must carry prominent notices stating that it is
    released under this License and any conditions added under section
    7.  This requirement modifies the requirement in section 4 to
    "keep intact all notices".

    c) You must license the entire work, as a whole, under this
    License to anyone who comes into possession of a copy.  This
    License will therefore apply, along with any applicable section 7
    additional terms, to the whole of the work, and all its parts,
    regardless of how they are packaged.  This License gives no
    permission to license the work in any other way, but it does not
    invalidate such permission if you have separately received it.

    d) If the work has interactive user interfaces, each must display
    Appropriate Legal Notices; however, if the Program has interactive
    interfaces that do not display Appropriate Legal Notices, your
    work need not make them do so.

  A compilation of a covered work with other separate and independent
works, which are not by their nature extensions of the covered work,
and which are not combined with it such as to form a larger program,
in or on a volume of a storage or distribution medium, is called an
"aggregate" if the compilation and its resulting copyright are not
used to limit the access or legal rights of the compilation's users
beyond what the individual works permit.  Inclusion of a covered work
in an aggregate does not cause this License to apply to the other
parts of the aggregate.

  6. Conveying Non-Source Forms.

  You may convey a covered work in object code form under the terms
of sections 4 and 5, provided that you also convey the
machine-readable Corresponding Source under the terms of this License,
in one of these ways:

    a) Convey the object code in, or embodied in, a physical product
    (including a physical distribution medium), accompanied by the
    Corresponding Source fixed on a durable physical medium
    customarily used for software interchange.

    b) Convey the object code in, or embodied in, a physical product
    (including a physical distribution medium), accompanied by a
    written offer, valid for at least three years and valid for as
    long as you offer spare parts or customer support for that product
    model, to give anyone who possesses the object code either (1) a
    copy of the Corresponding Source for all the software in the
    product that is covered by this License, on a durable physical
    medium customarily used for software interchange, for a price no
    more than your reasonable cost of physically performing this
    conveying of source, or (2) access to copy the
    Corresponding Source from a network server at no charge.

    c) Convey individual copies of the object code with a copy of the
    written offer to provide the Corresponding Source.  This
    alternative is allowed only occasionally and noncommercially, and
    only if you received the object code with such an offer, in accord
    with subsection 6b.

    d) Convey the object code by offering access from a designated
    place (gratis or for a charge), and offer equivalent access to the
    Corresponding Source in the same way through the same place at no
    further charge.  You need not require recipients to copy the
    Corresponding Source along with the object code.  If the place to
    copy the object code is a network server, the Corresponding Source
    may be on a different server (operated by you or a third party)
    that supports equivalent copying facilities, provided you maintain
    clear directions next to the object code saying where to find the
    Corresponding Source.  Regardless of what server hosts the
    Corresponding Source, you remain obligated to ensure that it is
    available for as long as needed to satisfy these requirements.

    e) Convey the object code using peer-to-peer transmission, provided
    you inform other peers where the object code and Corresponding
    Source of the work are being offered to the general public at no
    charge under subsection 6d.

  A separable portion of the object code, whose source code is excluded
from the Corresponding Source as a System Library, need not be
included in conveying the object code work.

  A "User Product" is either (1) a "consumer product", which means any
tangible personal property which is normally used for personal, family,
or household purposes, or (2) anything designed or sold for incorporation
into a dwelling.  In determining whether a product is a consumer product,
doubtful cases shall be resolved in favor of coverage.  For a particular
product received by a particular user, "normally used" refers to a
typical or common use of that class of product, regardless of the status
of the particular user or of the way in which the particular user
actually uses, or expects or is expected to use, the product.  A product
is a consumer product regardless of whether the product has substantial
commercial, industrial or non-consumer uses, unless such uses represent
the only significant mode of use of the product.

  "Installation Information" for a User Product means any methods,
procedures, authorization keys, or other information required to install
and execute modified versions of a covered work in that User Product from
a modified version of its Corresponding Source.  The information must
suffice to ensure that the continued functioning of the modified object
code is in no case prevented or interfered with solely because
modification has been made.

  If you convey an object code work under this section in, or with, or
specifically for use in, a User Product, and the conveying occurs as
part of a transaction in which the right of possession and use of the
User Product is transferred to the recipient in perpetuity or for a
fixed term (regardless of how the transaction is characterized), the
Corresponding Source conveyed under this section must be accompanied
by the Installation Information.  But this requirement does not apply
if neither you nor any third party retains the ability to install
modified object code on the User Product (for example, the work has
been installed in ROM).

  The requirement to provide Installation Information does not include a
requirement to continue to provide support service, warranty, or updates
for a work that has been modified or installed by the recipient, or for
the User Product in which it has been modified or installed.  Access to a
network may be denied when the modification itself materially and
adversely affects the operation of the network or violates the rules and
protocols for communication across the network.

  Corresponding Source conveyed, and Installation Information provided,
in accord with this section must be in a format that is publicly
documented (and with an implementation available to the public in
source code form), and must require no special password or key for
unpacking, reading or copying.

  7. Additional Terms.

  "Additional permissions" are terms that supplement the terms of this
License by making exceptions from one or more of its conditions.
Additional permissions that are applicable to the entire Program shall
be treated as though they were included in this License, to the extent
that they are valid under applicable law.  If additional permissions
apply only to part of the Program, that part may be used separately
under those permissions, but the entire Program remains governed by
this License without regard to the additional permissions.

  When you convey a copy of a covered work, you may at your option
remove any additional permissions from that copy, or from any part of
it.  (Additional permissions may be written to require their own
removal in certain cases when you modify the work.)  You may place
additional permissions on material, added by you to a covered work,
for which you have or can give appropriate copyright permission.

  Notwithstanding any other provision of this License, for material you
add to a covered work, you may (if authorized by the copyright holders of
that material) supplement the terms of this License with terms:

    a) Disclaiming warranty or limiting liability differently from the
    terms of sections 15 and 16 of this License; or

    b) Requiring preservation of specified reasonable legal notices or
    author attributions in that material or in the Appropriate Legal
    Notices displayed by works containing it; or

    c) Prohibiting misrepresentation of the origin of that material, or
    requiring that modified versions of such material be marked in
    reasonable ways as different from the original version; or

    d) Limiting the use for publicity purposes of names of licensors or
    authors of the material; or

    e) Declining to grant rights under trademark law for use of some
    trade names, trademarks, or service marks; or

    f) Requiring indemnification of licensors and authors of that
    material by anyone who conveys the material (or modified versions of
    it) with contractual assumptions of liability to the recipient, for
    any liability that these contractual assumptions directly impose on
    those licensors and authors.

  All other non-permissive additional terms are considered "further
restrictions" within the meaning of section 10.  If the Program as you
received it, or any part of it, contains a notice stating that it is
governed by this License along with a term that is a further
restriction, you may remove that term.  If a license document contains
a further restriction but permits relicensing or conveying under this
License, you may add to a covered work material governed by the terms
of that license document, provided that the further restriction does
not survive such relicensing or conveying.

  If you add terms to a covered work in accord with this section, you
must place, in the relevant source files, a statement of the
additional terms that apply to those files, or a notice indicating
where to find the applicable terms.

  Additional terms, permissive or non-permissive, may be stated in the
form of a separately written license, or stated as exceptions;
the above requirements apply either way.

  8. Termination.

  You may not propagate or modify a covered work except as expressly
provided under this License.  Any attempt otherwise to propagate or
modify it is void, and will automatically terminate your rights under
this License (including any patent licenses granted under the third
paragraph of section 11).

  However, if you cease all violation of this License, then your
license from a particular copyright holder is reinstated (a)
provisionally, unless and until the copyright holder explicitly and
finally terminates your license, and (b) permanently, if the copyright
holder fails to notify you of the violation by some reasonable means
prior to 60 days after the cessation.

  Moreover, your license from a particular copyright holder is
reinstated permanently if the copyright holder notifies you of the
violation by some reasonable means, this is the first time you have
received notice of violation of this License (for any work) from that
copyright holder, and you cure the violation prior to 30 days after
your receipt of the notice.

  Termination of your rights under this section does not terminate the
licenses of parties who have received copies or rights from you under
this License.  If your rights have been terminated and not permanently
reinstated, you do not qualify to receive new licenses for the same
material under section 10.

  9. Acceptance Not Required for Having Copies.

  You are not required to accept this License in order to receive or
run a copy of the Program.  Ancillary propagation of a covered work
occurring solely as a consequence of using peer-to-peer transmission
to receive a copy likewise does not require acceptance.  However,
nothing other than this License grants you permission to propagate or
modify any covered work.  These actions infringe copyright if you do
not accept this License.  Therefore, by modifying or propagating a
covered work, you indicate your acceptance of this License to do so.

  10. Automatic Licensing of Downstream Recipients.

  Each time you convey a covered work, the recipient automatically
receives a license from the original licensors, to run, modify and
propagate that work, subject to this License.  You are not responsible
for enforcing compliance by third parties with this License.

  An "entity transaction" is a transaction transferring control of an
organization, or substantially all assets of one, or subdividing an
organization, or merging organizations.  If propagation of a covered
work results from an entity transaction, each party to that
transaction who receives a copy of the work also receives whatever
licenses to the work the party's predecessor in interest had or could
give under the previous paragraph, plus a right to possession of the
Corresponding Source of the work from the predecessor in interest, if
the predecessor has it or can get it with reasonable efforts.

  You may not impose any further restrictions on the exercise of the
rights granted or affirmed under this License.  For example, you may
not impose a license fee, royalty, or other charge for exercise of
rights granted under this License, and you may not initiate litigation
(including a cross-claim or counterclaim in a lawsuit) alleging that
any patent claim is infringed by making, using, selling, offering for
sale, or importing the Program or any portion of it.

  11. Patents.

  A "contributor" is a copyright holder who authorizes use under this
License of the Program or a work on which the Program is based.  The
work thus licensed is called the contributor's "contributor version".

  A contributor's "essential patent claims" are all patent claims
owned or controlled by the contributor, whether already acquired or
hereafter acquired, that would be infringed by some manner, permitted
by this License, of making, using, or selling its contributor version,
but do not include claims that would be infringed only as a
consequence of further modification of the contributor version.  For
purposes of this definition, "control" includes the right to grant
patent sublicenses in a manner consistent with the requirements of
this License.

  Each contributor grants you a non-exclusive, worldwide, royalty-free
patent license under the contributor's essential patent claims, to
make, use, sell, offer for sale, import and otherwise run, modify and
propagate the contents of its contributor version.

  In the following three paragraphs, a "patent license" is any express
agreement or commitment, however denominated, not to enforce a patent
(such as an express permission to practice a patent or covenant not to
sue for patent infringement).  To "grant" such a patent license to a
party means to make such an agreement or commitment not to enforce a
patent against the party.

  If you convey a covered work, knowingly relying on a patent license,
and the Corresponding Source of the work is not available for anyone
to copy, free of charge and under the terms of this License, through a
publicly available network server or other readily accessible means,
then you must either (1) cause the Corresponding Source to be so
available, or (2) arrange to deprive yourself of the benefit of the
patent license for this particular work, or (3) arrange, in a manner
consistent with the requirements of this License, to extend the patent
license to downstream recipients.  "Knowingly relying" means you have
actual knowledge that, but for the patent license, your conveying the
covered work in a country, or your recipient's use of the covered work
in a country, would infringe one or more identifiable patents in that
country that you have reason to believe are valid.

  If, pursuant to or in connection with a single transaction or
arrangement, you convey, or propagate by procuring conveyance of, a
covered work, and grant a patent license to some of the parties
receiving the covered work authorizing them to use, propagate, modify
or convey a specific copy of the covered work, then the patent license
you grant is automatically extended to all recipients of the covered
work and works based on it.

  A patent license is "discriminatory" if it does not include within
the scope of its coverage, prohibits the exercise of, or is
conditioned on the non-exercise of one or more of the rights that are
specifically granted under this License.  You may not convey a covered
work if you are a party to an arrangement with a third party that is
in the business of distributing software, under which you make payment
to the third party based on the extent of your activity of conveying
the work, and under which the third party grants, to any of the
parties who would receive the covered work from you, a discriminatory
patent license (a) in connection with copies of the covered work
conveyed by you (or copies made from those copies), or (b) primarily
for and in connection with specific products or compilations that
contain the covered work, unless you entered into that arrangement,
or that patent license was granted, prior to 28 March 2007.

  Nothing in this License shall be construed as excluding or limiting
any implied license or other defenses to infringement that may
otherwise be available to you under applicable patent law.

  12. No Surrender of Others' Freedom.

  If conditions are imposed on you (whether by court order, agreement or
otherwise) that contradict the conditions of this License, they do not
excuse you from the conditions of this License.  If you cannot convey a
covered work so as to satisfy simultaneously your obligations under this
License and any other pertinent obligations, then as a consequence you may
not convey it at all.  For example, if you agree to terms that obligate you
to collect a royalty for further conveying from those to whom you convey
the Program, the only way you could satisfy both those terms and this
License would be to refrain entirely from conveying the Program.

  13. Use with the GNU Affero General Public License.

  Notwithstanding any other provision of this License, you have
permission to link or combine any covered work with a work licensed
under version 3 of the GNU Affero General Public License into a single
combined work, and to convey the resulting work.  The terms of this
License will continue to apply to the part which is the covered work,
but the special requirements of the GNU Affero General Public License,
section 13, concerning interaction through a network will apply to the
combination as such.

  14. Revised Versions of this License.

  The Free Software Foundation may publish revised and/or new versions of
the GNU General Public License from time to time.  Such new versions will
be similar in spirit to the present version, but may differ in detail to
address new problems or concerns.

  Each version is given a distinguishing version number.  If the
Program specifies that a certain numbered version of the GNU General
Public License "or any later version" applies to it, you have the
option of following the terms and conditions either of that numbered
version or of any later version published by the Free Software
Foundation.  If the Program does not specify a version number of the
GNU General Public License, you may choose any version ever published
by the Free Software Foundation.

  If the Program specifies that a proxy can decide which future
versions of the GNU General Public License can be used, that proxy's
public statement of acceptance of a version permanently authorizes you
to choose that version for the Program.

  Later license versions may give you additional or different
permissions.  However, no additional obligations are imposed on any
author or copyright holder as a result of your choosing to follow a
later version.

  15. Disclaimer of Warranty.

  THERE IS NO WARRANTY FOR THE PROGRAM, TO THE EXTENT PERMITTED BY
APPLICABLE LAW.  EXCEPT WHEN OTHERWISE STATED IN WRITING THE COPYRIGHT
HOLDERS AND/OR OTHER PARTIES PROVIDE THE PROGRAM "AS IS" WITHOUT WARRANTY
OF ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING, BUT NOT LIMITED TO,
THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
PURPOSE.  THE ENTIRE RISK AS TO THE QUALITY AND PERFORMANCE OF THE PROGRAM
IS WITH YOU.  SHOULD THE PROGRAM PROVE DEFECTIVE, YOU ASSUME THE COST OF
ALL NECESSARY SERVICING, REPAIR OR CORRECTION.

  16. Limitation of Liability.

  IN NO EVENT UNLESS REQUIRED BY APPLICABLE LAW OR AGREED TO IN WRITING
WILL ANY COPYRIGHT HOLDER, OR ANY OTHER PARTY WHO MODIFIES AND/OR CONVEYS
THE PROGRAM AS PERMITTED ABOVE, BE LIABLE TO YOU FOR DAMAGES, INCLUDING ANY
GENERAL, SPECIAL, INCIDENTAL OR CONSEQUENTIAL DAMAGES ARISING OUT OF THE
USE OR INABILITY TO USE THE PROGRAM (INCLUDING BUT NOT LIMITED TO LOSS OF
DATA OR DATA BEING RENDERED INACCURATE OR LOSSES SUSTAINED BY YOU OR THIRD
PARTIES OR A FAILURE OF THE PROGRAM TO OPERATE WITH ANY OTHER PROGRAMS),
EVEN IF SUCH HOLDER OR OTHER PARTY HAS BEEN ADVISED OF THE POSSIBILITY OF
SUCH DAMAGES.

  17. Interpretation of Sections 15 and 16.

  If the disclaimer of warranty and limitation of liability provided
above cannot be given local legal effect according to their terms,
reviewing courts shall apply local law that most closely approximates
an absolute waiver of all civil liability in connection with the
Program, unless a warranty or assumption of liability accompanies a
copy of the Program in return for a fee.

                     END OF TERMS AND CONDITIONS

            How to Apply These Terms to Your New Programs

  If you develop a new program, and you want it to be of the greatest
possible use to the public, the best way to achieve this is to make it
free software which everyone can redistribute and change under these terms.

  To do so, attach the following notices to the program.  It is safest
to attach them to the start of each source file to most effectively
state the exclusion of warranty; and each file should have at least
the "copyright" line and a pointer to where the full notice is found.

    <one line to give the program's name and a brief idea of what it does.>
    Copyright (C) <year>  <name of author>

    This program is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with this program.  If not, see <http://www.gnu.org/licenses/>.

Also add information on how to contact you by electronic and paper mail.

  If the program does terminal interaction, make it output a short
notice like this when it starts in an interactive mode:

    <program>  Copyright (C) <year>  <name of author>
    This program comes with ABSOLUTELY NO WARRANTY; for details type `show w'.
    This is free software, and you are welcome to redistribute it
    under certain conditions; type `show c' for details.

The hypothetical commands `show w' and `show c' should show the appropriate
parts of the General Public License.  Of course, your program's commands
might be different; for a GUI interface, you would use an "about box".

  You should also get your employer (if you work as a programmer) or school,
if any, to sign a "copyright disclaimer" for the program, if necessary.
For more information on this, and how to apply and follow the GNU GPL, see
<http://www.gnu.org/licenses/>.

  The GNU General Public License does not permit incorporating your program
into proprietary programs.  If your program is a subroutine library, you
may consider it more useful to permit linking proprietary applications with
the library.  If this is what you want to do, use the GNU Lesser General
Public License instead of this License.  But first, please read
<http://www.gnu.org/philosophy/why-not-lgpl.html>.
---------------------------------------------------

```

`Languages/Korean.isl`:

```isl
; *** Inno Setup version 5.5.3+ Korean messages ***
; ▒ Translator: VenusGirl (venusgirl@outlook.com)

; 이 파일의 사용자 제공 번역을 다운로드하려면 다음으로 이동하십시오:
;   https://jrsoftware.org/files/istrans/

; 참고: 이 텍스트를 번역할 때는 InnoSetup 메시지에
; 마침표가 자동으로 추가되므로 아직 없는 메시지의 끝에
; 마침표(.)를 추가하지 마십시오 (마침표를 추가하면
; 두 개의 마침표가 표시됩니다).

[LangOptions]
; 다음 세 항목은 매우 중요합니다. 도움말 파일의
; '[LangOptions] 섹션' 항목을 읽고 이해하십시오.
LanguageName=<D55C><AD6D><C5B4>
LanguageID=$0412
LanguageCodePage=65001
; 번역할 언어가 특수 글꼴 또는 크기를 필요로 하는 경우
; 다음 항목 중 하나를 주석 해제하고 적절하게 변경하십시오.
DialogFontName=
;DialogFontSize=8
;WelcomeFontName=Verdana
;WelcomeFontSize=12
;TitleFontName=Arial
;TitleFontSize=29
;CopyrightFontName=Arial
;CopyrightFontSize=8

[Messages]

; *** Application titles
SetupAppTitle=설치
SetupWindowTitle=%1 설치
UninstallAppTitle=제거
UninstallAppFullTitle=%1 제거

; *** Misc. common
InformationTitle=정보
ConfirmTitle=확인
ErrorTitle=오류

; *** SetupLdr messages
SetupLdrStartupMessage=%1을(를) 설치합니다, 계속하시겠습니까?
LdrCannotCreateTemp=임시 파일을 만들 수 없습니다. 설치가 중단되었습니다.
LdrCannotExecTemp=임시 디렉터리에서 파일을 실행할 수 없습니다. 설치가 중단되었습니다.

; *** Startup error messages
LastErrorMessage=%1.%n%n오류 %2: %3
SetupFileMissing=%1 파일이 설치 디렉터리에 없습니다. 문제를 해결하거나 프로그램의 새 사본을 구하십시오.
SetupFileCorrupt=설치 파일이 손상되었습니다. 프로그램의 새 사본을 구하십시오.
SetupFileCorruptOrWrongVer=설치 파일이 손상되었거나 이 버전의 설치 프로그램과 호환되지 않습니다. 문제를 해결하거나 프로그램의 새 복사본을 구하십시오.
InvalidParameter=명령줄에 잘못된 매개변수가 전달되었습니다:%n%n%1
SetupAlreadyRunning=설치가 이미 실행 중입니다.
WindowsVersionNotSupported=이 프로그램은 컴퓨터에서 실행 중인 Windows 버전을 지원하지 않습니다.
WindowsServicePackRequired=이 프로그램을 사용하려면 %1 서비스 팩 %2 이상이 필요합니다.
NotOnThisPlatform=이 프로그램은 %1에서 실행되지 않습니다.
OnlyOnThisPlatform=이 프로그램은 %1에서 실행되어야 합니다.
OnlyOnTheseArchitectures=이 프로그램은 다음 프로세서 아키텍처용으로 설계된 Windows 버전에만 설치할 수 있습니다:%n%n%1
MissingWOW64APIs=귀하의 Windows는 64비트 설치에 필요한 기능이 포함되어 있지 않습니다, 이 문제를 해결하려면 sp%1을(를) 설치하시기 바랍니다.
WinVersionTooLowError=이 프로그램에는 %1 버전 %2 이상이 필요합니다.
WinVersionTooHighError=%1 버전 %2 이상에 이 프로그램을 설치할 수 없습니다.
AdminPrivilegesRequired=이 프로그램을 설치할 때 관리자로 로그인해야 합니다.
PowerUserPrivilegesRequired=이 프로그램을 설치할 때 관리자 또는 Power Users 그룹의 구성원으로 로그인해야 합니다.
SetupAppRunningError=설치에서 %1이(가) 현재 실행 중임을 감지했습니다.%n%n지금 모든 인스턴스를 닫은 다음 확인을 클릭하여 계속하거나 취소를 클릭하여 종료하십시오.
UninstallAppRunningError=제거에서 %1이(가) 현재 실행 중임을 감지했습니다.%n%n지금 모든 인스턴스를 닫은 다음 확인을 클릭하여 계속하거나 취소를 클릭하여 종료하십시오.

; *** Misc. errors
ErrorCreatingDir=설치 프로그램에서 "%1" 디렉터리를 만들지 못했습니다.
ErrorTooManyFilesInDir="%1" 디렉터리에 파일이 너무 많아서 파일을 만들 수 없습니다

; *** Setup common messages
ExitSetupTitle=설치 종료
ExitSetupMessage=설치가 완료되지 않았습니다. 지금 종료하면 프로그램이 설치되지 않습니다.%n%n설치를 다시 실행하여 설치를 완료할 수 있습니다.%n%n설치를 종료하시겠습니까?
AboutSetupMenuItem=설치 정보(&A)...
AboutSetupTitle=설치 정보
AboutSetupMessage=%1 버전 %2%n%3%n%n%1 홈 페이지:%n%4
AboutSetupNote=
TranslatorNote=

; *** Buttons
ButtonBack=< 뒤로(&B)
ButtonNext=다음(&N) >
ButtonInstall=설치(&I)
ButtonOK=확인
ButtonCancel=취소
ButtonYes=예(&Y)
ButtonYesToAll=모두 예(&A)
ButtonNo=아니오(&N)
ButtonNoToAll=모두 아니오(&O)
ButtonFinish=종료(&F)
ButtonBrowse=찾아보기(&B)...
ButtonWizardBrowse=찾아보기(&R)...
ButtonNewFolder=새 폴더 만들기(&M)

; *** "Select Language" dialog messages
SelectLanguageTitle=설치 언어 선택
SelectLanguageLabel=설치 중에 사용할 언어를 선택하십시오.

; *** Common wizard text
ClickNext=다음을 클릭하여 계속하거나 취소를 클릭하여 설치를 종료합니다.
BeveledLabel=
BrowseDialogTitle=폴더 찾아보기
BrowseDialogLabel=아래 목록에서 폴더를 선택한 후 확인을 클릭하십시오.
NewFolderName=새 폴더

; *** "Welcome" wizard page
WelcomeLabel1=[name] 설치 마법사에 오신 것을 환영합니다
WelcomeLabel2=컴퓨터에 [name/ver]가 설치됩니다.%n%n계속하기 전에 다른 모든 응용 프로그램을 닫는 것이 좋습니다.

; *** "Password" wizard page
WizardPassword=암호
PasswordLabel1=이 설치는 암호로 보호됩니다.
PasswordLabel3=암호를 입력한 후 다음을 클릭하여 계속하십시오. 암호는 대소문자를 구분합니다.
PasswordEditLabel=암호(&P):
IncorrectPassword=입력한 암호가 올바르지 않습니다. 다시 시도하십시오.

; *** "License Agreement" wizard page
WizardLicense=사용권 계약
LicenseLabel=계속하기 전에 다음 중요한 정보를 읽어보십시오.
LicenseLabel3=다음 사용권 계약을 읽어보십시오. 설치를 계속하기 전에 이 계약 조건에 동의해야 합니다.
LicenseAccepted=동의합니다(&A)
LicenseNotAccepted=동의하지 않습니다(&D)

; *** "Information" wizard pages
WizardInfoBefore=정보
InfoBeforeLabel=계속하기 전에 다음 중요한 정보를 읽어보십시오.
InfoBeforeClickLabel=설치를 계속할 준비가 되었으면 다음을 클릭합니다.
WizardInfoAfter=정보
InfoAfterLabel=계속하기 전에 다음 중요한 정보를 읽어보십시오.
InfoAfterClickLabel=설치를 계속할 준비가 되었으면 다음을 클릭합니다.

; *** "User Information" wizard page
WizardUserInfo=사용자 정보
UserInfoDesc=사용자 정보를 입력하십시오.
UserInfoName=사용자 이름(&U):
UserInfoOrg=조직(&O):
UserInfoSerial=일련 번호:(&S):
UserInfoNameRequired=이름을 입력해야 합니다.

; *** "Select Destination Location" wizard page
WizardSelectDir=대상 위치 선택
SelectDirDesc=[name]을(를) 어디에 설치하시겠습니까?
SelectDirLabel3=다음 폴더에 [name]을(를) 설치합니다.
SelectDirBrowseLabel=계속하려면 '다음'을 클릭하십시오.다른 폴더를 선택하려면 "찾아보기"를 클릭하십시오.
DiskSpaceMBLabel=이 프로그램은 최소 [mb] MB의 디스크 여유 공간이 필요합니다.
CannotInstallToNetworkDrive=네트워크 드라이브에 설치할 수 없습니다.
CannotInstallToUNCPath=UNC 경로에 설치할 수 없습니다.
InvalidPath=드라이브 문자를 포함한 전체 경로를 입력해야 합니다. 예:%n%nC:\APP%n%n 또는 UNC 경로 형식:%n%n\\server\share
InvalidDrive=선택한 드라이브 또는 UNC 공유가 존재하지 않거나 액세스할 수 없습니다, 다른 경로를 선택하십시오.
DiskSpaceWarningTitle=디스크 공간이 부족합니다
DiskSpaceWarning=설치할 수 있는 공간이% 1 KB 이상 있어야 합니다. 선택한 드라이브는% 2 KB만 사용할 수 있습니다. %n%n 계속하시겠습니까?
DirNameTooLong=폴더 이름 또는 경로가 너무 깁니다.
InvalidDirName=폴더 이름이 유효하지 않습니다.
BadDirName32=폴더 이름은 다음 문자를 포함할 수 없습니다:%n%n%1
DirExistsTitle=폴더가 존재합니다
DirExists=폴더 %n%n%1%n%n이(가) 이미 존재합니다, 그래도 해당 폴더에 설치하시겠습니까?
DirDoesntExistTitle=폴더가 존재하지 않습니다
DirDoesntExist=폴더 %n%n%1%n%n이(가) 존재하지 않습니다, 폴더를 만드시겠습니까?

; *** "Select Components" wizard page
WizardSelectComponents=구성 요소 선택
SelectComponentsDesc=어떤 구성 요소를 설치해야 합니까?
SelectComponentsLabel2=설치할 구성 요소를 선택하고 설치하지 않을 구성 요소를 지웁니다. 계속할 준비가 되면 다음을 클릭합니다.
FullInstallation=모두 설치
; 가능하면 'Compact'를 'Minimal'로 번역하지 마십시오 (귀하의 언어로 '최소'를 의미합니다).
CompactInstallation=최소 설치
CustomInstallation=사용자 지정 설치
NoUninstallWarningTitle=구성 요소가 존재합니다
NoUninstallWarning=다음 구성 요소가 컴퓨터에 이미 설치되어 있습니다: %n%n%1%n%n이러한 구성 요소를 선택해도 제거되지 않습니다.%n%n계속하시겠습니까?
ComponentSize1=%1 KB
ComponentSize2=%1 MB
ComponentsDiskSpaceMBLabel=현재 선택은 최소 [mb] MB의 디스크 여유 공간이 필요합니다.

; *** "Select Additional Tasks" wizard page
WizardSelectTasks=추가 작업 선택
SelectTasksDesc=어떤 추가 작업을 수행해야 합니까?
SelectTasksLabel2=[name]을(를) 설치하는 동안 수행할 추가 작업을 선택하고 다음을 클릭합니다.

; *** "Select Start Menu Folder" wizard page
WizardSelectProgramGroup=시작 메뉴 폴더 선택
SelectStartMenuFolderDesc=프로그램의 바로가기를 어디에 설치하시겠습니까?
SelectStartMenuFolderLabel3=설치는 다음 시작 메뉴 폴더에 프로그램 바로가기를 만듭니다.
SelectStartMenuFolderBrowseLabel=계속하려면 다음을 클릭합니다. 다른 폴더를 선택하려면 찾아보기를 클릭합니다.
MustEnterGroupName=폴더 이름을 입력하십시오.
GroupNameTooLong=폴더 이름 또는 경로가 너무 깁니다.
InvalidGroupName=폴더 이름이 유효하지 않습니다.
BadGroupName=폴더 이름은 다음 문자를 포함할 수 없습니다:%n%n%1
NoProgramGroupCheck2=시작 메뉴 폴더를 만들지 않음(&D)

; *** "Ready to Install" wizard page
WizardReady=설치 준비 완료
ReadyLabel1=[name]을(를) 컴퓨터에 설치할 준비가 되었습니다.
ReadyLabel2a=설치를 클릭하여 설치를 계속하거나 설정을 검토하거나 변경하려면 뒤로를 클릭합니다.
ReadyLabel2b=설치를 클릭하여 설치를 계속합니다.
ReadyMemoUserInfo=사용자 정보:
ReadyMemoDir=대상 위치:
ReadyMemoType=설치 유형:
ReadyMemoComponents=선택한 구성 요소:
ReadyMemoGroup=시작 메뉴 폴더:
ReadyMemoTasks=추가 작업:

; *** "Preparing to Install" wizard page
WizardPreparing=설치 준비 중
PreparingDesc=컴퓨터에 [name] 설치를 준비하는 중입니다.
PreviousInstallNotCompleted=이전 프로그램의 설치/제거가 완료되지 않았습니다. 설치를 완료하려면 컴퓨터를 다시 시작해야 합니다.%n%n컴퓨터를 재시작한 후 설치를 다시 실행하여 [name] 설치를 완료하십시오.
CannotContinue=설치를 계속할 수 없습니다. 종료하려면 취소를 클릭하십시오.
ApplicationsFound=다음 응용 프로그램에서 설치 프로그램에서 업데이트해야 하는 파일을 사용하고 있습니다. 이러한 응용 프로그램을 자동으로 닫도록 허용하는 것이 좋습니다.
ApplicationsFound2=다음 응용 프로그램에서 설치 프로그램에서 업데이트해야 하는 파일을 사용하고 있습니다. 이러한 응용 프로그램을 자동으로 닫도록 허용하는 것이 좋습니다. 설치가 완료되면 응용 프로그램을 다시 시작하려고 시도합니다.
CloseApplications=응용 프로그램 자동 닫기(&A)
DontCloseApplications=응용 프로그램을 닫지 않음(&D)
ErrorCloseApplications=모든 응용 프로그램을 자동으로 닫지 못했습니다. 계속하기 전에 설치 프로그램에서 업데이트해야 하는 파일을 사용하여 모든 응용 프로그램을 닫는 것이 좋습니다.

; *** "Installing" wizard page
WizardInstalling=설치 중
InstallingLabel=컴퓨터에 [name]을(를) 설치하는 동안 잠시 기다려 주십시오.

; *** "Setup Completed" wizard page
FinishedHeadingLabel=[name] 설치 마법사 완료
FinishedLabelNoIcons=컴퓨터에 [name] 설치를 완료했습니다.
FinishedLabel=컴퓨터에 [name] 설치를 완료했습니다. 설치된 바로가기를 선택하여 응용 프로그램을 시작할 수 있습니다.
ClickFinish=설치를 종료하려면 마침을 클릭하십시오.
FinishedRestartLabel=[name] 설치를 완료하려면 컴퓨터를 다시 시작해야 합니다. 지금 다시 시작하시겠습니까?
FinishedRestartMessage=[name] 설치를 완료하려면 컴퓨터를 다시 시작해야 합니다.%n%n지금 다시 시작하시겠습니까?
ShowReadmeCheck=예, README 파일을 보고 싶습니다.
YesRadio=예, 지금 컴퓨터를 다시 시작합니다(&Y)
NoRadio=아니오, 나중에 컴퓨터를 다시 시작하겠습니다(&N)
; 예를 들어 'Run MyProg.exe'로 사용됩니다'
RunEntryExec=%1 실행
; 예를 들어 'Readme.txt 보기'로 사용됩니다'
RunEntryShellExec=%1 보기

; *** "Setup Needs the Next Disk" stuff
ChangeDiskTitle=설치에 다음 디스크가 필요합니다
SelectDiskLabel2=디스크 %1을(를) 삽입하고 확인을 클릭하십시오.%n%n이 디스크의 파일을 아래에 표시된 폴더 이외의 폴더에서 찾을 수 있으면 올바른 경로를 입력하거나 찾아보기를 클릭하십시오.
PathLabel=경로(&P):
FileNotInDir2="%1" 파일을 "%2"에서 찾을 수 없습니다. 올바른 디스크를 넣거나 다른 폴더를 선택하십시오.
SelectDirectoryLabel=다음 디스크의 위치를 지정하십시오.

; *** Installation phase messages
SetupAborted=설치가 완료되지 않았습니다.%n%n문제를 해결한 후 설치를 다시 실행하십시오.
EntryAbortRetryIgnore=다시 시도하려면 "재시도"를, 무시하고 계속하려면 "무시"를, 설치를 취소하려면 "취소"를 클릭하십시오.

; *** Installation status messages
StatusClosingApplications=응용 프로그램을 닫는 중...
StatusCreateDirs=디렉터리를 만드는 중...
StatusExtractFiles=파일을 추출하는 중...
StatusCreateIcons=바로가기를 만드는 중...
StatusCreateIniEntries=INI 항목을 만드는 중...
StatusCreateRegistryEntries=레지스트리 항목을 만드는 중...
StatusRegisterFiles=파일을 등록하는 중...
StatusSavingUninstall=제거 정보를 저장하는 중...
StatusRunProgram=설치를 완료하는 중...
StatusRestartingApplications=응용 프로그램을 다시 시작하는 중...
StatusRollback=변경 내용을 롤백하는 중...

; *** Misc. errors
ErrorInternal2=내부 오류: %1
ErrorFunctionFailedNoCode=%1 실패
ErrorFunctionFailed=%1 실패; 코드 %2
ErrorFunctionFailedWithMessage=%1 실패, 코드: %2.%n%3
ErrorExecutingProgram=파일 실행 오류:%n%1

; *** Registry errors
ErrorRegOpenKey=레지스트리 키 열기 오류:%n%1\%2
ErrorRegCreateKey=레지스트리 키 생성 오류:%n%1\%2
ErrorRegWriteKey=레지스트리 키 쓰기 오류:%n%1\%2

; *** INI errors
ErrorIniEntry="%1" 파일에 INI 항목 만들기 오류입니다.

; *** File copying errors
FileAbortRetryIgnore=다시 실행하려면 '다시 시도', 이 파일을 건너뛰고 계속하려면 '무시'(권장하지 않음), 설치를 중단하려면 '중단'을 클릭합니다.
FileAbortRetryIgnore2=다시 실행하려면 '다시 시도', 이 파일을 건너뛰고 계속하려면 '무시'(권장하지 않음), 설치를 중단하려면 '중단'을 클릭합니다.
SourceIsCorrupted=원본 파일이 손상되었습니다
SourceDoesntExist=원본 파일 "%1"이(가) 없습니다
ExistingFileReadOnly=기존 파일은 읽기 전용입니다.%n%n읽기 전용 속성을 제거하고 다시 시도하려면 "재시도"를, 이 파일을 건너뛰려면 "무시"를, 설치를 취소하려면 "취소"를 클릭하십시오.
ErrorReadingExistingDest=기존 파일을 읽는 동안 오류 발생:
FileExists=파일이 이미 존재합니다.%n%n파일을 덮어쓰시겠습니까?
ExistingFileNewer=기존 파일이 설치하려고 하는 파일보다 새 파일입니다, 기존 파일을 유지하시기 바랍니다.%n%n기존 파일을 유지하시겠습니까?
ErrorChangingAttr=기존 파일의 속성을 변경하는 동안 오류 발생:
ErrorCreatingTemp=대상 디렉터리에 파일을 만드는 동안 오류 발생:
ErrorReadingSource=원본 파일을 읽는 동안 오류 발생:
ErrorCopying=파일을 복사하는 동안 오류 발생:
ErrorReplacingExistingFile=기존 파일을 교체하는 동안 오류 발생:
ErrorRestartReplace=RestartReplace 실패:
ErrorRenamingTemp=대상 디렉터리 내의 파일 이름을 바꾸는 동안 오류 발생:
ErrorRegisterServer=DLL/OCX를 등록할 수 없습니다: %1
ErrorRegSvr32Failed=종료 코드 %1로 인해 RegSvr32가 실패했습니다
ErrorRegisterTypeLib=유형 라이브러리를 등록할 수 없습니다: %1

; *** Post-installation errors
ErrorOpeningReadme=README 파일을 여는 동안 오류가 발생했습니다.
ErrorRestartingComputer=컴퓨터를 다시 시작하지 못했습니다. 이 작업을 수동으로 수행하십시오.

; *** Uninstaller messages
UninstallNotFound="%1" 파일이 없습니다. 제거할 수 없습니다.
UninstallOpenError="%1" 파일을 열 수 없습니다. 제거할 수 없습니다
UninstallUnsupportedVer="%1" 제거 로그 파일이 현재 버전의 제거 프로그램에서 인식할 수 없는 형식입니다. 제거할 수 없습니다
UninstallUnknownEntry=제거 로그에 알 수 없는 항목 (%1)이 있습니다
ConfirmUninstall=%1 및 해당 구성 요소를 모두 제거하시겠습니까?
UninstallOnlyOnWin64=이 설치는 64비트 Windows에서만 제거할 수 있습니다.
OnlyAdminCanUninstall=이 설치는 관리자 권한이 있는 사용자만 제거할 수 있습니다.
UninstallStatusLabel=%1이(가) 컴퓨터에서 제거되는 동안 기다려 주십시오.
UninstalledAll=%1이(가) 컴퓨터에서 성공적으로 제거되었습니다.
UninstalledMost=%1 제거가 완료되었습니다.%n%n일부 요소를 제거할 수 없습니다. 수동으로 제거할 수 있습니다.
UninstalledAndNeedsRestart=%1 제거를 완료하려면 컴퓨터를 다시 시작해야 합니다.%n%n지금 다시 시작하시겠습니까?
UninstallDataCorrupted="%1" 파일이 손상되었습니다. 제거할 수 없습니다.

; *** Uninstallation phase messages
ConfirmDeleteSharedFileTitle=공유 파일을 제거하시겠습니까?
ConfirmDeleteSharedFile2=시스템에 다음 공유 파일을 사용하는 프로그램이 없다고 표시됩니다.이 공유 파일을 삭제하시겠습니까?%n%n 이 파일을 사용하는 프로그램이 있으면 삭제 후 프로그램이 제대로 실행되지 않을 수 있습니다.확실하지 않으면 '아니오'를 선택하십시오.이 파일을 남기는 것은 시스템에 아무런 해를 끼치지 않습니다.
SharedFileNameLabel=파일 이름:
SharedFileLocationLabel=위치:
WizardUninstalling=제거 상태
StatusUninstalling=%1을(를) 제거하는 중...

; *** Shutdown block reasons
ShutdownBlockReasonInstallingApp=%1을(를) 설치하는 중입니다.
ShutdownBlockReasonUninstallingApp=%1을(를) 제거하는 중입니다.

; 아래의 사용자 지정 메시지는 설치 자체에서 사용하지 않지만 
; 스크립트에서 사용하면 해당 메시지를 번역할 수 있습니다.

[CustomMessages]

NameAndVersion=%1 버전 %2
AdditionalIcons=바로가기 추가:
CreateDesktopIcon=바탕화면에 바로가기 만들기(&D)
CreateQuickLaunchIcon=빠른 실행 아이콘 만들기(&Q)
ProgramOnTheWeb=%1 웹페이지
UninstallProgram=%1 제거
LaunchProgram=%1 실행
AssocFileExtension=%1을 %2 파일 확장자에 연결
AssocingFileExtension=%1을 %2 파일 확장자와 연결하는 중...
AutoStartProgramGroupDescription=시작:
AutoStartProgram=%1 자동 시작
AddonHostProgramNotFound=%1을(를) 선택한 폴더에서 찾을 수 없습니다.%n%n계속하시겠습니까?
```

`MyWndCtrl/CMakeLists.txt`:

```txt
# CMakeLists.txt --- CMake project settings
#    ex) cmake -G "Visual Studio 9 2008"
#    ex) cmake -DCMAKE_BUILD_TYPE=Release -G "MSYS Makefiles"
##############################################################################

# CMake minimum version
cmake_minimum_required(VERSION 2.9)

# use new policy
cmake_policy(SET CMP0054 NEW)

# check build type
if (NOT CMAKE_BUILD_TYPE)
    message(STATUS "No build type selected, default to Debug")
    set(CMAKE_BUILD_TYPE "Debug")
endif()

# make uppercase string of build type
string(TOUPPER "${CMAKE_BUILD_TYPE}" uppercase_CMAKE_BUILD_TYPE)

# check build type again
if (NOT uppercase_CMAKE_BUILD_TYPE MATCHES "^(DEBUG|RELEASE|RELWITHDEBINFO|MINSIZEREL)$")
    message(FATAL_ERROR "Invalid value for CMAKE_BUILD_TYPE: ${CMAKE_BUILD_TYPE}")
endif()

# set output directory (build/)
set(CMAKE_BINARY_DIR ${CMAKE_SOURCE_DIR}/build)
set(EXECUTABLE_OUTPUT_PATH ${CMAKE_BINARY_DIR})
set(LIBRARY_OUTPUT_PATH ${CMAKE_BINARY_DIR})

# enable Win32 resource
enable_language(RC)

if (CMAKE_CXX_COMPILER_ID STREQUAL "Clang")
    # using Clang
    set(CMAKE_C_FLAGS "-static")
    set(CMAKE_CXX_FLAGS "-static")
elseif (CMAKE_CXX_COMPILER_ID STREQUAL "GNU")
    # using GCC
    set(CMAKE_C_FLAGS "-static -static-libgcc -static-libstdc++")
    set(CMAKE_CXX_FLAGS "-static -static-libgcc -static-libstdc++")
elseif (CMAKE_CXX_COMPILER_ID STREQUAL "MSVC")
    # replace "/MD" with "/MT" (building without runtime DLLs)
    set(CompilerFlags
        CMAKE_C_FLAGS
        CMAKE_C_FLAGS_DEBUG
        CMAKE_C_FLAGS_RELEASE
        CMAKE_C_FLAGS_RELWITHDEBINFO
        CMAKE_CXX_FLAGS
        CMAKE_CXX_FLAGS_DEBUG
        CMAKE_CXX_FLAGS_RELEASE
        CMAKE_CXX_FLAGS_RELWITHDEBINFO)
    foreach(CompilerFlags ${CompilerFlags})
        string(REPLACE "/MD" "/MT" ${CompilerFlags} "${${CompilerFlags}}")
    endforeach()
endif()

##############################################################################

# MyWndCtrl.dll
add_library(MyWndCtrl SHARED MyWndCtrl.cpp)
set_target_properties (MyWndCtrl PROPERTIES PREFIX "")

##############################################################################

```

`MyWndCtrl/MWindowBase.hpp`:

```hpp
// MWindowBase.hpp --- MZC4 window base and dialog base         -*- C++ -*-
// This file is part of MZC4.  See file "ReadMe.txt" and "License.txt".
//////////////////////////////////////////////////////////////////////////////

#ifndef MZC4_MWINDOWBASE_HPP_
#define MZC4_MWINDOWBASE_HPP_    70     /* Version 70 */

class MWindowBase;
class MDialogBase;

//////////////////////////////////////////////////////////////////////////////

#if _MSC_VER > 1000
    #pragma once        // For speed!
#endif

#ifndef STRICT
    #define STRICT  1   // We must do strictly! Good bye to old style!
#endif

#if defined(_MSC_VER) && !defined(NDEBUG) && !defined(_CRTDBG_MAP_ALLOC)
    // for detecting memory leak (MSVC only)
    #define _CRTDBG_MAP_ALLOC
    #include <crtdbg.h>
#endif

#if __STDC_VERSION__ >= 199901L && !defined(C99)
    #define C99             1
#endif
#if __cplusplus >= 201103L && !defined(CXX11)
    #define CXX11           1
#endif

//#define MZC4_FAT_AND_RICH   1
//#define MZC4_HANDLE_MAP     1

//////////////////////////////////////////////////////////////////////////////
// headers

// Win32API headers
#ifndef _INC_WINDOWS
    #include <windows.h>    // Win32API
#endif
#ifndef _INC_WINDOWSX
    #include <windowsx.h>   // Win32API Macro APIs
#endif
#ifndef _INC_COMMCTRL
    #include <commctrl.h>   // common controls
#endif
#ifndef _INC_COMMDLG
    #include <commdlg.h>    // common dialogs
#endif
#ifndef _INC_TCHAR
    #include <tchar.h>      // generic text mappings
#endif

#include <dlgs.h>           // dialog control IDs

#ifndef NO_STRSAFE
    #include <strsafe.h>    // StringCch* or StringCb*
#endif

// standard C/C++ library
#include <cassert>          // assert
#include <cstring>          // C string library

#include <map>              // std::map

//////////////////////////////////////////////////////////////////////////////

#ifndef _countof
    #define _countof(array)     (sizeof(array) / sizeof(array[0]))
#endif

// MString
#ifndef MString
    #include <string>       // std::string and std::wstring
    typedef std::string     MStringA;
    typedef std::wstring    MStringW;
    #ifdef UNICODE
        #define MString     MStringW
    #else
        #define MString     MStringA
    #endif
#endif

// NOTE: Old Digital Mars C/C++ Compiler doesn't define INT_PTR type likely.
#ifdef __DMC__
    #ifndef INT_PTR
        #ifdef _WIN64
            #define INT_PTR     LPARAM
        #else
            #define INT_PTR     BOOL
        #endif
    #endif
#endif

//////////////////////////////////////////////////////////////////////////////
// public functions

#ifndef MZCAPI
    #define MZCAPI      WINAPI
#endif

#ifndef MZCAPIV
    #define MZCAPIV     WINAPIV
#endif

VOID MZCAPIV DebugPrintDx(const char *format, ...);
VOID MZCAPIV DebugPrintDx(const WCHAR *format, ...);
RECT MZCAPI GetVirtualScreenRectDx();
VOID MZCAPI RepositionPointDx(LPPOINT ppt, SIZE siz, LPCRECT prc);
RECT MZCAPI WorkAreaFromWindowDx(HWND hwnd);
SIZE MZCAPI SizeFromRectDx(LPCRECT prc);
LPTSTR MZCAPI LoadStringDx(INT nID);
LPTSTR MZCAPIV LoadStringPrintfDx(INT nID, ...);
LPTSTR MZCAPI LoadStringVPrintfDx(INT nID, va_list va);
LPCTSTR MZCAPI GetStringDx(INT nStringID);
LPCTSTR MZCAPI GetStringDx(LPCTSTR psz);
BOOL MZCAPI GetWindowPosDx(HWND hwnd, POINT *ppt = NULL, SIZE *psiz = NULL);
BOOL MZCAPI GetWindowPosDx(HWND hwnd, RECT *prc);
BOOL MZCAPI SetWindowPosDx(HWND hwnd, LPPOINT ppt = NULL, LPSIZE psiz = NULL,
    HWND hwndInsertAfter = NULL,
    UINT uFlags = SWP_NOACTIVATE | SWP_NOOWNERZORDER);
BOOL MZCAPI SetWindowPosDx(HWND hwnd, const RECT *prc);
LPSTR MZCAPI MakeFilterDx(LPSTR psz);
LPWSTR MZCAPI MakeFilterDx(LPWSTR psz);
HBITMAP MZCAPI Create24BppBitmapDx(INT width, INT height);
void MZCAPI FillBitmapDx(HBITMAP hbm, HBRUSH hbr);
void MZCAPI PremultiplyDx(HBITMAP hbm32bpp);
BOOL MZCAPI CopyTextDx(HWND hwnd, const MString& text);
void MZCAPI
PopupMenuDx(HWND hwnd, HWND hContext, UINT nMenuID, INT iSubMenu, INT x, INT y);

//////////////////////////////////////////////////////////////////////////////
// Messaging

// LRESULT OnMessage(HWND hwnd, WPARAM wParam, LPARAM lParam);
#define HANDLE_MESSAGE(hwnd, uMsg, OnMessage) \
    case (uMsg): return (OnMessage)((hwnd), (wParam), (lParam))

// LRESULT OnMessageEx(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam);
#define HANDLE_MESSAGE_EX(hwnd, uMsg, OnMessageEx) \
    case (uMsg): return (OnMessageEx)((hwnd), (uMsg), (wParam), (lParam))

#define DO_MSG(WM_, fn) \
    case (WM_): return HANDLE_##WM_(hwnd, (wParam), (lParam), (fn))
#define DO_MESSAGE(uMsg, OnMessage) \
    HANDLE_MESSAGE(hwnd, uMsg, OnMessage)
#define DO_MESSAGE_EX(uMsg, OnMessageEx) \
    HANDLE_MESSAGE_EX(hwnd, uMsg, OnMessage)

//////////////////////////////////////////////////////////////////////////////

class MWindowBase
{
protected:
    DWORD           m_dwWindowBaseMagic;
    MSG             m_msg;
public:
    HWND            m_hwnd;
    WNDPROC         m_fnOldProc;
    MWindowBase *   m_pwndSub;
    bool            m_bDynamicCreated;

    MWindowBase() :
        m_dwWindowBaseMagic(0xFEEDFEED), m_hwnd(NULL), m_fnOldProc(NULL),
        m_pwndSub(NULL), m_bDynamicCreated(false)
    {
    }

    MWindowBase(HWND hwnd) :
        m_dwWindowBaseMagic(0xFEEDFEED), m_hwnd(hwnd), m_fnOldProc(NULL),
        m_pwndSub(NULL), m_bDynamicCreated(false)
    {
    }

    virtual ~MWindowBase()
    {
    }

    operator HWND() const
    {
        return Handle();
    }
    bool operator!() const
    {
        return Handle() == NULL;
    }
    HWND Handle() const
    {
        return (this ? m_hwnd : NULL);
    }

#ifdef MZC4_HANDLE_MAP
    typedef std::map<HWND, void *> handle_map_type;
    static handle_map_type& GetHandleMap()
    {
        static handle_map_type s_map;
        return s_map;
    }
    static MWindowBase *GetUserData(HWND hwnd)
    {
        handle_map_type::iterator it = GetHandleMap().find(hwnd);
        if (it == GetHandleMap().end())
            return NULL;
        return reinterpret_cast<MWindowBase *>(it->second);
    }
    static void SetUserData(HWND hwnd, void *ptr)
    {
        if (ptr)
        {
            GetHandleMap()[hwnd] = ptr;
        }
        else
        {
            GetHandleMap().erase(hwnd);
        }
    }
#else
    static MWindowBase *GetUserData(HWND hwnd)
    {
        return reinterpret_cast<MWindowBase *>(GetWindowLongPtr(hwnd, GWLP_USERDATA));
    }
    static void SetUserData(HWND hwnd, void *ptr)
    {
        SetWindowLongPtr(hwnd, GWLP_USERDATA, (LONG_PTR)ptr);
    }
#endif
    virtual void PostNcDestroy()
    {
        SetUserData(m_hwnd, NULL);
        m_hwnd = NULL;
        if (m_bDynamicCreated)
        {
            delete this;
        }
    }

    MWindowBase *GetUserData() const
    {
        return GetUserData(m_hwnd);
    }

    LRESULT CALLBACK
    CallWindowProcDx(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
    {
        return ::CallWindowProc(m_fnOldProc, hwnd, uMsg, wParam, lParam);
    }

    virtual LRESULT MZCAPI
    DefaultProcDx(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
    {
        if (m_pwndSub)
        {
            assert(this != m_pwndSub);
            return m_pwndSub->WindowProcDx(hwnd, uMsg, wParam, lParam);
        }
        if (m_fnOldProc)
        {
            return ::CallWindowProc(m_fnOldProc, hwnd, uMsg, wParam, lParam);
        }
        return ::DefWindowProc(hwnd, uMsg, wParam, lParam);
    }

    LRESULT MZCAPI DefaultProcDx()
    {
        return DefaultProcDx(m_msg.hwnd, m_msg.message, m_msg.wParam, m_msg.lParam);
    }

    VOID SaveMessageDx(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam);

    virtual LRESULT CALLBACK
    WindowProcDx(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
    {
        return DefaultProcDx(hwnd, uMsg, wParam, lParam);
    }

    static LRESULT CALLBACK
    WindowProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam);

    virtual LPCTSTR GetWndClassNameDx() const
    {
        return TEXT("katahiromz's MWindowBase Class");
    }

    virtual VOID ModifyWndClassDx(WNDCLASSEX& wcx)
    {
    }

    BOOL RegisterClassDx();

    BOOL CreateWindowDx(HWND hwndParent, LPCTSTR pszText,
                        DWORD Style = WS_OVERLAPPEDWINDOW, DWORD ExStyle = 0,
                        INT x = CW_USEDEFAULT, INT y = CW_USEDEFAULT,
                        INT cx = CW_USEDEFAULT, INT cy = CW_USEDEFAULT,
                        HMENU hMenu = NULL);
    BOOL CreateAsChildDx(HWND hwndParent, LPCTSTR pszText,
                         DWORD Style = WS_CHILD | WS_VISIBLE,
                         DWORD ExStyle = 0, INT nCtrlID = -1,
                         INT x = CW_USEDEFAULT, INT y = CW_USEDEFAULT,
                         INT cx = CW_USEDEFAULT, INT cy = CW_USEDEFAULT);

    BOOL Attach(HWND hwnd)
    {
        MWindowBase *pwndSub = GetUserData(hwnd);
        m_hwnd = hwnd;
        SetUserData(m_hwnd, this);
        m_pwndSub = pwndSub;
        return m_hwnd != NULL;
    }

    HWND Detach()
    {
        HWND hwnd = m_hwnd;
        SetUserData(hwnd, m_pwndSub);
        m_hwnd = NULL;
        m_pwndSub = NULL;
        return hwnd;
    }

    virtual void PostSubclassDx(HWND hwnd)
    {
    }

    BOOL SubclassDx(HWND hwnd)
    {
        Attach(hwnd);
        if (!m_pwndSub)
        {
            m_fnOldProc = SubclassWindow(hwnd, MWindowBase::WindowProc);
        }
        PostSubclassDx(hwnd);
        return m_pwndSub || m_fnOldProc;
    }

    VOID UnsubclassDx()
    {
        SubclassWindow(m_hwnd, m_fnOldProc);
        SetUserData(m_hwnd, m_pwndSub);
        m_fnOldProc = NULL;
    }

    BOOL SubclassChildDx(MWindowBase& child, UINT nItemID)
    {
        assert(::IsWindow(m_hwnd));
        return child.SubclassDx(::GetDlgItem(m_hwnd, nItemID));
    }

    INT MsgBoxDx(LPCTSTR pszString, LPCTSTR pszTitle,
                 UINT uType = MB_ICONINFORMATION);

    INT MsgBoxDx(UINT nStringID, UINT nTitleID, UINT uType)
    {
        return MsgBoxDx(MAKEINTRESOURCE(nStringID), MAKEINTRESOURCE(nTitleID), uType);
    }

    INT MsgBoxDx(UINT nStringID, LPCTSTR pszTitle, UINT uType)
    {
        return MsgBoxDx(MAKEINTRESOURCE(nStringID), pszTitle, uType);
    }

    INT MsgBoxDx(UINT nStringID, UINT uType)
    {
        return MsgBoxDx(MAKEINTRESOURCE(nStringID), NULL, uType);
    }

    INT MsgBoxDx(LPCTSTR pszString, UINT uType)
    {
        return MsgBoxDx(pszString, NULL, uType);
    }

    INT ErrorBoxDx(UINT nStringID, UINT uType = MB_ICONERROR)
    {
        return MsgBoxDx(MAKEINTRESOURCE(nStringID), TEXT("ERROR"), uType);
    }
    INT ErrorBoxDx(LPCTSTR pszString, UINT uType = MB_ICONERROR)
    {
        return MsgBoxDx(pszString, TEXT("ERROR"), uType);
    }

    VOID CenterWindowDx() const
    {
        CenterWindowDx(m_hwnd);
    }

    static INT GetWindowTextLength(HWND hwnd)
    {
        assert(::IsWindow(hwnd));
        return ::GetWindowTextLength(hwnd);
    }
    INT GetWindowTextLength() const
    {
        assert(::IsWindow(Handle()));
        return ::GetWindowTextLength(Handle());
    }

    static MString GetWindowText(HWND hwnd);
    static INT GetWindowText(HWND hwnd, LPTSTR pszText, INT cchMax)
    {
        assert(::IsWindow(hwnd));
        return ::GetWindowText(hwnd, pszText, cchMax);
    }
    MString GetWindowText() const
    {
        return GetWindowText(m_hwnd);
    }

    static UINT GetDlgItemText(HWND hwnd, INT nCtrlID, LPTSTR psz, INT cchMax)
    {
        assert(::IsWindow(hwnd));
        return ::GetDlgItemText(hwnd, nCtrlID, psz, cchMax);
    }
    static MString GetDlgItemText(HWND hwnd, INT nCtrlID)
    {
        assert(::IsWindow(hwnd));
        return GetWindowText(::GetDlgItem(hwnd, nCtrlID));
    }
    MString GetDlgItemText(INT nCtrlID) const
    {
        return GetWindowText(::GetDlgItem(m_hwnd, nCtrlID));
    }

    static BOOL SetWindowText(HWND hwnd, LPCTSTR pszText = NULL)
    {
        assert(::IsWindow(hwnd));
        return ::SetWindowText(hwnd, pszText);
    }
    BOOL SetWindowText(LPCTSTR pszText = NULL)
    {
        return SetWindowText(Handle(), pszText);
    }

    static VOID CenterWindowDx(HWND hwnd);

    static BOOL MZCAPI GetWindowPosDx(HWND hwnd, POINT *ppt = NULL, SIZE *psiz = NULL);
    static BOOL MZCAPI GetWindowPosDx(HWND hwnd, RECT *prc);

    BOOL MZCAPI GetWindowPosDx(POINT *ppt = NULL, SIZE *psiz = NULL);
    BOOL MZCAPI GetWindowPosDx(RECT *prc);

    static BOOL SetWindowPosDx(HWND hwnd,
                               LPPOINT ppt = NULL, LPSIZE psiz = NULL,
                               HWND hwndInsertAfter = NULL,
                               UINT uFlags = SWP_NOACTIVATE | SWP_NOOWNERZORDER);
    static BOOL SetWindowPosDx(HWND hwnd, const RECT *prc);

    BOOL SetWindowPosDx(LPPOINT ppt = NULL, LPSIZE psiz = NULL,
                        HWND hwndInsertAfter = NULL,
                        UINT uFlags = SWP_NOACTIVATE | SWP_NOOWNERZORDER);
    BOOL SetWindowPosDx(const RECT *prc);

    static HWND GetAncestorDx(HWND hTarget);
    HWND GetAncestorDx() const
    {
        return GetAncestorDx(m_hwnd);
    }

    HICON LoadIconDx(INT id)
    {
        return LoadIcon(GetModuleHandle(NULL), MAKEINTRESOURCE(id));
    }

    HICON LoadSmallIconDx(UINT id)
    {
        INT cxSmall = GetSystemMetrics(SM_CXSMICON);
        INT cySmall = GetSystemMetrics(SM_CYSMICON);
        return HICON(LoadImage(GetModuleHandle(NULL), 
                               MAKEINTRESOURCE(id),
                               IMAGE_ICON, cxSmall, cySmall, 0));
    }

    HFONT GetFontDx() const
    {
        assert(::IsWindow(m_hwnd));
        return GetWindowFont(m_hwnd);
    }
    void SetFontDx(HFONT hFont, BOOL bRedraw = TRUE)
    {
        assert(::IsWindow(m_hwnd));
        SetWindowFont(m_hwnd, hFont, bRedraw);
    }
    DWORD GetStyleDx() const
    {
        assert(::IsWindow(m_hwnd));
        return GetWindowStyle(m_hwnd);
    }
    DWORD SetStyleDx(DWORD dwNewStyle)
    {
        assert(::IsWindow(m_hwnd));
        return SetWindowLong(m_hwnd, GWL_STYLE, dwNewStyle);
    }
    void ModifyStyleDx(DWORD dwRemove, DWORD dwAdd)
    {
        assert(::IsWindow(m_hwnd));
        DWORD style = GetStyleDx();
        style &= ~dwRemove;
        style |= dwAdd;
        SetStyleDx(style);
    }
    DWORD GetExStyleDx() const
    {
        assert(::IsWindow(m_hwnd));
        return GetWindowExStyle(m_hwnd);
    }
    DWORD SetExStyleDx(DWORD dwNewExStyle)
    {
        assert(::IsWindow(m_hwnd));
        return SetWindowLong(m_hwnd, GWL_EXSTYLE, dwNewExStyle);
    }
    void ModifyExStyleDx(DWORD dwRemove, DWORD dwAdd)
    {
        assert(::IsWindow(m_hwnd));
        DWORD exstyle = GetExStyleDx();
        exstyle &= ~dwRemove;
        exstyle |= dwAdd;
        SetExStyleDx(exstyle);
    }

    HWND GetChildDx(HWND hwndChild) const
    {
        return hwndChild;
    }
    HWND GetChildDx(UINT id) const
    {
        return ::GetDlgItem(m_hwnd, id);
    }
    UINT GetCtrlIDDx(HWND hwndChild) const
    {
        return ::GetDlgCtrlID(hwndChild);
    }
    UINT GetCtrlIDDx(UINT nChildID) const
    {
        return nChildID;
    }

    LRESULT SendMessageDx(UINT uMsg, WPARAM wParam = 0, LPARAM lParam = 0) const
    {
        assert(::IsWindow(m_hwnd));
        return ::SendMessage(m_hwnd, uMsg, wParam, lParam);
    }
    BOOL PostMessageDx(UINT uMsg, WPARAM wParam = 0, LPARAM lParam = 0) const
    {
        assert(::IsWindow(m_hwnd));
        return ::PostMessage(m_hwnd, uMsg, wParam, lParam);
    }

    static HHOOK HookCenterMsgBoxDx(BOOL bHook);

private:
    static inline LRESULT CALLBACK
    _msgBoxCbtProcDx(INT nCode, WPARAM wParam, LPARAM lParam);

#ifdef MZC4_FAT_AND_RICH
public:
    #include "MWindowBaseRichMethods.hpp"
#endif

public:
    // for DECLARE_DYNAMIC/IMPLEMENT_DYNAMIC
    typedef MWindowBase *(*FNCREATEINSTANCEDX)();
    typedef std::map<MString, FNCREATEINSTANCEDX> class_to_create_map_t;

    static class_to_create_map_t& ClassToCreateMap()
    {
        static class_to_create_map_t s_class_to_create_map;
        return s_class_to_create_map;
    }
};

//////////////////////////////////////////////////////////////////////////////
// DECLARE_DYNAMIC/IMPLEMENT_DYNAMIC

#define DECLARE_DYNAMIC(class_name) \
    static MWindowBase *CreateInstanceDx();

#define IMPLEMENT_DYNAMIC(class_name) \
    /*static*/ MWindowBase *class_name::CreateInstanceDx() \
    { \
        return new class_name(); \
    } \
    struct class_name##AutoDynamicRegister \
    { \
        class_name##AutoDynamicRegister() \
        { \
            MWindowBase::ClassToCreateMap()[TEXT(#class_name)] = &class_name::CreateInstanceDx; \
        } \
    } class_name##AutoDynamicRegister##__LINE__;

#define IMPLEMENT_DYNAMIC2(class_name, wndclass_name) \
    /*static*/ MWindowBase *class_name::CreateInstanceDx() \
    { \
        return new class_name(); \
    } \
    struct class_name##AutoDynamicRegister \
    { \
        class_name##AutoDynamicRegister() \
        { \
            MWindowBase::ClassToCreateMap()[TEXT(#wndclass_name)] = &class_name::CreateInstanceDx; \
        } \
    } class_name##AutoDynamicRegister##__LINE__;

//////////////////////////////////////////////////////////////////////////////

class MDialogBase : public MWindowBase
{
public:
    BOOL    m_bModal;
    HWND    m_hwndOwner;
    LPCTSTR m_pDialogName;

    MDialogBase() : m_bModal(FALSE), m_hwndOwner(NULL), m_pDialogName(NULL)
    {
    }

    MDialogBase(HWND hwndOwner)
        : m_bModal(FALSE), m_hwndOwner(hwndOwner), m_pDialogName(NULL)
    {
    }

    MDialogBase(HWND hwndOwner, INT nDialogID)
        : m_bModal(FALSE), m_hwndOwner(hwndOwner),
          m_pDialogName(MAKEINTRESOURCE(nDialogID))
    {
    }

    MDialogBase(HWND hwndOwner, LPCTSTR pDialogName)
        : m_bModal(FALSE), m_hwndOwner(hwndOwner),
          m_pDialogName(pDialogName)
    {
    }

    MDialogBase(INT nDialogID)
        : m_bModal(FALSE), m_hwndOwner(NULL),
          m_pDialogName(MAKEINTRESOURCE(nDialogID))
    {
    }

    virtual LPCTSTR GetWndClassNameDx() const
    {
        return TEXT("#32770");
    }

    virtual LRESULT MZCAPI
    DefaultProcDx(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
    {
        return 0;
    }

    LRESULT MZCAPI DefaultProcDx()
    {
        return DefaultProcDx(m_msg.hwnd, m_msg.message, m_msg.wParam, m_msg.lParam);
    }

    virtual INT_PTR CALLBACK
    DialogProcDx(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
    {
        return 0;
    }

    static INT_PTR CALLBACK
    DialogProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam);

    static MDialogBase *GetUserData(HWND hwnd)
    {
        return (MDialogBase *)GetWindowLongPtr(hwnd, DWLP_USER);
    }
    static VOID SetUserData(HWND hwnd, VOID *ptr)
    {
        SetWindowLongPtr(hwnd, DWLP_USER, (LONG_PTR)ptr);
    }

    BOOL CreateDialogDx(HWND hwndOwner, INT nDialogID);
    BOOL CreateDialogDx(HWND hwndOwner, LPCTSTR pDialogName);
    INT_PTR DialogBoxDx(HWND hwndOwner, INT nDialogID);
    INT_PTR DialogBoxDx(HWND hwndOwner, LPCTSTR pDialogName);
    BOOL CreateDialogIndirectDx(HWND hwndOwner, const VOID *ptr);
    INT_PTR DialogBoxIndirectDx(HWND hwndOwner, const VOID *ptr);

    BOOL CreateDialogDx(HWND hwndOwner)
    {
        return CreateDialogDx(hwndOwner, m_pDialogName);
    }

    INT_PTR DialogBoxDx(HWND hwndOwner)
    {
        return DialogBoxDx(hwndOwner, m_pDialogName);
    }

    DWORD GetDefID() const
    {
        return (DWORD)SendMessageDx(DM_GETDEFID);
    }
    BOOL SetDefID(UINT nID)
    {
        return (BOOL)SendMessageDx(DM_SETDEFID, (WPARAM)nID);
    }

    BOOL EndDialog(INT_PTR nResult)
    {
        assert(::IsWindow(Handle()));
        return ::EndDialog(Handle(), nResult);
    }
    static BOOL EndDialog(HWND hwnd, INT_PTR nResult)
    {
        assert(::IsWindow(hwnd));
        return ::EndDialog(hwnd, nResult);
    }

    VOID NextDlgCtrl() const
    {
        PostMessageDx(WM_NEXTDLGCTL, FALSE);
    }
    VOID PrevDlgCtrl() const
    {
        PostMessageDx(WM_NEXTDLGCTL, TRUE);
    }
    VOID GotoDlgCtrl(HWND hwndCtrl)
    {
        PostMessageDx(WM_NEXTDLGCTL, (WPARAM)hwndCtrl, 1);
    }

    BOOL MapDialogRect(LPRECT prc) const
    {
        assert(IsWindow(Handle()));
        return ::MapDialogRect(Handle(), prc);
    }
    static BOOL MapDialogRect(HWND hwnd, LPRECT prc)
    {
        assert(IsWindow(hwnd));
        return ::MapDialogRect(hwnd, prc);
    }

    BOOL IsDialogMessage(LPMSG pMsg)
    {
        return ::IsDialogMessage(Handle(), pMsg);
    }

    BOOL Attach(HWND hwnd)
    {
        m_hwnd = hwnd;
        SetUserData(m_hwnd, this);
        return m_hwnd != NULL;
    }

    HWND Detach()
    {
        HWND hwnd = m_hwnd;
        SetUserData(hwnd, NULL);
        m_hwnd = NULL;
        return hwnd;
    }
};

//////////////////////////////////////////////////////////////////////////////
// public inline functions

inline VOID MZCAPIV DebugPrintDx(const char *format, ...)
{
    #ifndef NDEBUG
        char szBuff[512];
        va_list va;
        va_start(va, format);
#ifdef NO_STRSAFE
        wsprintfA(szBuff, format, va);
#else
        StringCchVPrintfA(szBuff, _countof(szBuff), format, va);
#endif
        va_end(va);
        OutputDebugStringA(szBuff);
    #endif
}

inline VOID MZCAPIV DebugPrintDx(const WCHAR *format, ...)
{
    #ifndef NDEBUG
        WCHAR szBuff[512];
        va_list va;
        va_start(va, format);
#ifdef NO_STRSAFE
        wsprintfW(szBuff, format, va);
#else
        StringCchVPrintfW(szBuff, _countof(szBuff), format, va);
#endif
        va_end(va);
        OutputDebugStringW(szBuff);
    #endif
}

inline RECT MZCAPI GetVirtualScreenRectDx()
{
    RECT rc;
#ifndef SM_XVIRTUALSCREEN
    #define SM_XVIRTUALSCREEN   76
    #define SM_YVIRTUALSCREEN   77
    #define SM_CXVIRTUALSCREEN  78
    #define SM_CYVIRTUALSCREEN  79
#endif
    INT x = ::GetSystemMetrics(SM_XVIRTUALSCREEN);
    INT y = ::GetSystemMetrics(SM_YVIRTUALSCREEN);
    INT cx = ::GetSystemMetrics(SM_CXVIRTUALSCREEN);
    INT cy = ::GetSystemMetrics(SM_CYVIRTUALSCREEN);
    if (cx == 0)
        cx = ::GetSystemMetrics(SM_CXSCREEN);
    if (cy == 0)
        cy = ::GetSystemMetrics(SM_CYSCREEN);
    SetRect(&rc, x, y, x + cx, y + cy);
    return rc;
}

inline VOID MZCAPI RepositionPointDx(LPPOINT ppt, SIZE siz, LPCRECT prc)
{
    if (ppt->x + siz.cx > prc->right)
        ppt->x = prc->right - siz.cx;
    if (ppt->y + siz.cy > prc->bottom)
        ppt->y = prc->bottom - siz.cy;
    if (ppt->x < prc->left)
        ppt->x = prc->left;
    if (ppt->y < prc->top)
        ppt->y = prc->top;
}

inline RECT MZCAPI WorkAreaFromWindowDx(HWND hwnd)
{
#if (WINVER >= 0x0500)
    MONITORINFO mi;
    mi.cbSize = sizeof(mi);
    HMONITOR hMonitor = MonitorFromWindow(hwnd, MONITOR_DEFAULTTONEAREST);
    if (GetMonitorInfo(hMonitor, &mi))
    {
        return mi.rcWork;
    }
#endif
    RECT rc;
    ::SystemParametersInfo(SPI_GETWORKAREA, 0, &rc, 0);
    return rc;
}

inline SIZE MZCAPI SizeFromRectDx(LPCRECT prc)
{
    SIZE siz;
    siz.cx = prc->right - prc->left;
    siz.cy = prc->bottom - prc->top;
    return siz;
}

inline LPTSTR MZCAPI LoadStringDx(INT nID)
{
    static UINT s_index = 0;
    const UINT cchBuffMax = 1024;
    static TCHAR s_sz[4][cchBuffMax];

    TCHAR *pszBuff = s_sz[s_index];
    s_index = (s_index + 1) % _countof(s_sz);
    pszBuff[0] = 0;
    if (!::LoadString(NULL, nID, pszBuff, cchBuffMax))
        assert(0);
    return pszBuff;
}

inline LPTSTR MZCAPI LoadStringVPrintfDx(INT nID, va_list va)
{
    static UINT s_index = 0;
    const UINT cchBuffMax = 1024;
    static TCHAR s_sz[4][cchBuffMax];

    TCHAR *pszBuff = s_sz[s_index];
    s_index = (s_index + 1) % _countof(s_sz);
    pszBuff[0] = 0;
#ifdef NO_STRSAFE
    wvsprintf(pszBuff, LoadStringDx(nID), va);
#else
    StringCchVPrintf(pszBuff, cchBuffMax, LoadStringDx(nID), va);
#endif
    return pszBuff;
}

inline LPTSTR MZCAPIV LoadStringPrintfDx(INT nID, ...)
{
    va_list va;
    va_start(va, nID);
    LPTSTR psz = LoadStringVPrintfDx(nID, va);
    va_end(va);
    return psz;
}

inline LPCTSTR MZCAPI GetStringDx(LPCTSTR psz)
{
    if (psz == NULL)
        return NULL;
    if (IS_INTRESOURCE(psz))
        return LoadStringDx(LOWORD(psz));
    return psz;
}

inline LPCTSTR MZCAPI GetStringDx(INT nStringID)
{
    return LoadStringDx(nStringID);
}

inline BOOL MZCAPI
GetWindowPosDx(HWND hwnd, POINT *ppt/* = NULL*/, SIZE *psiz/* = NULL*/)
{
    RECT rc;
    if (!GetWindowRect(hwnd, &rc))
        return FALSE;

    if (ppt)
    {
        ppt->x = rc.left;
        ppt->y = rc.top;
        if (GetWindowStyle(hwnd) & WS_CHILD)
        {
            MapWindowPoints(NULL, GetParent(hwnd), ppt, 1);
        }
    }
    if (psiz)
    {
        psiz->cx = rc.right - rc.left;
        psiz->cy = rc.bottom - rc.top;
    }
    return TRUE;
}

inline BOOL MZCAPI GetWindowPosDx(HWND hwnd, RECT *prc)
{
    POINT pt;
    SIZE siz;
    if (!GetWindowPosDx(hwnd, &pt, &siz))
        return FALSE;
    prc->left = pt.x;
    prc->top = pt.y;
    prc->right = pt.x + siz.cx;
    prc->bottom = pt.x + siz.cy;
    return TRUE;
}

inline BOOL MZCAPI
SetWindowPosDx(HWND hwnd, LPPOINT ppt/* = NULL*/, LPSIZE psiz/* = NULL*/,
    HWND hwndInsertAfter/* = NULL*/,
    UINT uFlags/* = SWP_NOACTIVATE | SWP_NOOWNERZORDER*/)
{
    if (hwndInsertAfter == NULL)
    {
        uFlags |= SWP_NOZORDER;
    }

    INT x = 0, y = 0;
    if (ppt == NULL)
    {
        uFlags |= SWP_NOMOVE;
    }
    else
    {
        x = ppt->x;
        y = ppt->y;
    }

    INT cx = 0, cy = 0;
    if (psiz == NULL)
    {
        uFlags |= SWP_NOSIZE;
    }
    else
    {
        cx = psiz->cx;
        cy = psiz->cy;
    }

    return ::SetWindowPos(hwnd, hwndInsertAfter, x, y, cx, cy, uFlags);
}

inline BOOL MZCAPI
SetWindowPosDx(HWND hwnd, const RECT *prc)
{
    assert(prc);
    POINT pt;
    SIZE siz;
    pt.x = prc->left;
    pt.y = prc->top;
    siz.cx = prc->right - prc->left;
    siz.cy = prc->bottom - prc->top;
    return ::SetWindowPosDx(hwnd, &pt, &siz);
}

inline LPSTR MZCAPI MakeFilterDx(LPSTR psz)
{
    for (LPSTR pch = psz; *pch; ++pch)
    {
        if (*pch == '|')
            *pch = 0;
    }
    return psz;
}

inline LPWSTR MZCAPI MakeFilterDx(LPWSTR psz)
{
    for (LPWSTR pch = psz; *pch; ++pch)
    {
        if (*pch == L'|')
            *pch = 0;
    }
    return psz;
}

inline HBITMAP MZCAPI Create24BppBitmapDx(INT width, INT height)
{
    BITMAPINFO bi;
    ZeroMemory(&bi, sizeof(bi));
    bi.bmiHeader.biSize = sizeof(BITMAPINFOHEADER);
    bi.bmiHeader.biWidth = width;
    bi.bmiHeader.biHeight = height;
    bi.bmiHeader.biPlanes = 1;
    bi.bmiHeader.biBitCount = 24;
    bi.bmiHeader.biCompression = BI_RGB;
    HDC hDC = CreateCompatibleDC(NULL);
    LPVOID pvBits;
    HBITMAP hbm = CreateDIBSection(hDC, &bi, DIB_RGB_COLORS,
                                   &pvBits, NULL, 0);
    DeleteDC(hDC);
    return hbm;
}

inline void MZCAPI FillBitmapDx(HBITMAP hbm, HBRUSH hbr)
{
    BITMAP bm;
    if (!GetObject(hbm, sizeof(bm), &bm))
        return;

    HDC hDC = CreateCompatibleDC(NULL);
    {
        HGDIOBJ hbmOld = SelectObject(hDC, hbm);
        {
            RECT rc;
            SetRect(&rc, 0, 0, bm.bmWidth, bm.bmHeight);
            FillRect(hDC, &rc, hbr);
            DeleteObject(hbr);
        }
        SelectObject(hDC, hbmOld);
    }
    DeleteDC(hDC);
}

inline void MZCAPI
PremultiplyDx(HBITMAP hbm32bpp)
{
    BITMAP bm;
    DWORD cdw;
    LPBYTE pb;
    BYTE alpha;
    GetObject(hbm32bpp, sizeof(bm), &bm);
    if (bm.bmBitsPixel == 32)
    {
        cdw = bm.bmWidth * bm.bmHeight;
        pb = (LPBYTE) bm.bmBits;
        while (cdw--)
        {
            alpha = pb[3];
            pb[0] = (BYTE) ((DWORD) pb[0] * alpha / 255);
            pb[1] = (BYTE) ((DWORD) pb[1] * alpha / 255);
            pb[2] = (BYTE) ((DWORD) pb[2] * alpha / 255);
            pb += 4;
        }
    }
}

inline BOOL MZCAPI CopyTextDx(HWND hwnd, const MString& text)
{
#ifdef UNICODE
    UINT CF_ = CF_UNICODETEXT;
#else
    UINT CF_ = CF_TEXT;
#endif
    DWORD size = DWORD((text.size() + 1) * sizeof(TCHAR));
    LPTSTR psz = (LPTSTR)GlobalAllocPtr(GMEM_SHARE | GMEM_MOVEABLE, size);
    if (psz)
    {
        HGLOBAL hGlobal = GlobalPtrHandle(psz);
        CopyMemory(psz, text.c_str(), size);
        GlobalUnlockPtr(psz);

        if (OpenClipboard(hwnd))
        {
            EmptyClipboard();
            SetClipboardData(CF_, hGlobal);
            return CloseClipboard();
        }
    }
    return FALSE;
}

inline void MZCAPI
PopupMenuDx(HWND hwnd, HWND hContext, UINT nMenuID, INT iSubMenu, INT x, INT y)
{
    HMENU hMenu = LoadMenu(GetModuleHandle(NULL), MAKEINTRESOURCE(nMenuID));
    HMENU hSubMenu = GetSubMenu(hMenu, iSubMenu);

    if (x == 0xFFFF && y == 0xFFFF)
    {
        RECT rc;
        GetWindowRect(hContext, &rc);
        x = rc.left;
        y = rc.top;
    }

    SetForegroundWindow(hwnd);
    TrackPopupMenu(hSubMenu, TPM_LEFTALIGN | TPM_RIGHTBUTTON,
        x, y, 0, hwnd, NULL);
    PostMessage(hwnd, WM_NULL, 0, 0);
    DestroyMenu(hMenu);
}

//////////////////////////////////////////////////////////////////////////////

inline VOID
MWindowBase::SaveMessageDx(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    m_msg.hwnd = hwnd;
    m_msg.message = uMsg;
    m_msg.wParam = wParam;
    m_msg.lParam = lParam;
    m_msg.time = GetMessageTime();
    LONG nPos = GetMessagePos();
    m_msg.pt.x = GET_X_LPARAM(nPos);
    m_msg.pt.y = GET_Y_LPARAM(nPos);
}

inline /*static*/ LRESULT CALLBACK
MWindowBase::WindowProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
 {
    MWindowBase *base;
    if (uMsg == WM_CREATE)
    {
        TCHAR szClass[128];
        GetClassName(hwnd, szClass, _countof(szClass));

        LPCREATESTRUCT pcs = (LPCREATESTRUCT)lParam;
        if (pcs->lpCreateParams &&
            !IsBadReadPtr(pcs->lpCreateParams, sizeof(MWindowBase)) &&
            ((MWindowBase*)(pcs->lpCreateParams))->m_dwWindowBaseMagic == 0xFEEDFEED)
        {
            base = reinterpret_cast<MWindowBase *>(pcs->lpCreateParams);
            base->m_hwnd = hwnd;
        }
        else
        {
            // for DECLARE_DYNAMIC/IMPLEMENT_DYNAMIC
            class_to_create_map_t::const_iterator it;
            it = MWindowBase::ClassToCreateMap().find(szClass);
            if (it == MWindowBase::ClassToCreateMap().end())
            {
                assert(0);
                return 0;
            }

            base = (*it->second)();
            base->m_bDynamicCreated = true;
            base->Attach(hwnd);
        }
    }
    else
    {
        base = GetUserData(hwnd);
    }

    LRESULT ret = 0;
    if (base)
    {
#ifndef NDEBUG
        TCHAR szClass[128];
        GetClassName(hwnd, szClass, _countof(szClass));
#endif
        base->SaveMessageDx(hwnd, uMsg, wParam, lParam);
        ret = base->WindowProcDx(hwnd, uMsg, wParam, lParam);

        if (uMsg == WM_NCDESTROY)
        {
            base->PostNcDestroy();
        }
    }
    else
    {
        ret = ::DefWindowProc(hwnd, uMsg, wParam, lParam);
    }

    return ret;
}

inline BOOL MWindowBase::RegisterClassDx()
{
    HMODULE hMod = ::GetModuleHandle(NULL);

    WNDCLASSEX wcx;
    LPCTSTR pszClass = GetWndClassNameDx();
    if (::GetClassInfoEx(NULL, pszClass, &wcx) ||
        ::GetClassInfoEx(hMod, pszClass, &wcx))
    {
        return TRUE;
    }

    ZeroMemory(&wcx, sizeof(wcx));
    wcx.cbSize = sizeof(wcx);
    wcx.style = CS_HREDRAW | CS_VREDRAW | CS_DBLCLKS;
    wcx.lpfnWndProc = MWindowBase::WindowProc;
    wcx.hInstance = hMod;
    wcx.hIcon = ::LoadIcon(NULL, IDI_APPLICATION);
    wcx.hCursor = ::LoadCursor(NULL, IDC_ARROW);
    wcx.hbrBackground = ::GetSysColorBrush(COLOR_3DFACE);
    wcx.lpszMenuName = NULL;
    wcx.lpszClassName = pszClass;
    wcx.hIconSm = ::LoadIcon(NULL, IDI_APPLICATION);

    ModifyWndClassDx(wcx);

    return ::RegisterClassEx(&wcx);
}

inline BOOL MWindowBase::CreateWindowDx(
    HWND hwndParent, LPCTSTR pszText,
    DWORD Style/* = WS_OVERLAPPEDWINDOW*/, DWORD ExStyle/* = 0*/,
    INT x/* = CW_USEDEFAULT*/, INT y/* = CW_USEDEFAULT*/,
    INT cx/* = CW_USEDEFAULT*/, INT cy/* = CW_USEDEFAULT*/,
    HMENU hMenu/* = NULL*/)
{
    if (!RegisterClassDx())
        return FALSE;

    HWND hwnd = ::CreateWindowEx(ExStyle, GetWndClassNameDx(),
        GetStringDx(pszText), Style, x, y, cx, cy, hwndParent,
        hMenu, GetModuleHandle(NULL), this);
    return Attach(hwnd);
}

inline BOOL
MWindowBase::CreateAsChildDx(
    HWND hwndParent, LPCTSTR pszText,
    DWORD Style/* = WS_CHILD | WS_VISIBLE*/,
    DWORD ExStyle/* = 0*/, INT nCtrlID/* = -1*/,
    INT x/* = CW_USEDEFAULT*/, INT y/* = CW_USEDEFAULT*/,
    INT cx/* = CW_USEDEFAULT*/, INT cy/* = CW_USEDEFAULT*/)
{
    Style |= WS_CHILD;
    return CreateWindowDx(hwndParent, pszText, Style, ExStyle,
        x, y, cx, cy, (HMENU)(INT_PTR)nCtrlID);
}

inline INT
MWindowBase::MsgBoxDx(LPCTSTR pszString, LPCTSTR pszTitle,
                      UINT uType/* = MB_ICONINFORMATION*/)
{
    MString Title;
    if (pszTitle == NULL)
    {
#ifdef IDS_APPNAME
        Title = LoadStringDx(IDS_APPNAME);
#else
        if (m_hwnd)
        {
            Title = GetWindowText(GetAncestorDx());
            size_t i = Title.find(TEXT(" - "));
            if (i != MString::npos)
            {
                Title = Title.substr(i + 3);
            }
        }
        else
        {
            Title = TEXT("ERROR");
        }
#endif
    }
    else
    {
        Title = GetStringDx(pszTitle);
    }

    MWindowBase::HookCenterMsgBoxDx(TRUE);
    INT nID = ::MessageBox(m_hwnd, GetStringDx(pszString),
                           Title.c_str(), uType);
    MWindowBase::HookCenterMsgBoxDx(FALSE);

    return nID;
}

inline /*static*/ MString MWindowBase::GetWindowText(HWND hwnd)
{
    INT cch = ::GetWindowTextLength(hwnd);
    MString ret;
    ret.resize(cch);
    if (!::GetWindowText(hwnd, &ret[0], cch + 1))
        ret.clear();
    return ret;
}

inline /*static*/ VOID MWindowBase::CenterWindowDx(HWND hwnd)
{
    assert(IsWindow(hwnd));

    BOOL bChild = !!(GetWindowStyle(hwnd) & WS_CHILD);

    HWND hwndParent;
    if (bChild)
        hwndParent = ::GetParent(hwnd);
    else
        hwndParent = ::GetWindow(hwnd, GW_OWNER);

    RECT rcWorkArea = WorkAreaFromWindowDx(hwnd);

    RECT rcParent;
    if (hwndParent)
        ::GetWindowRect(hwndParent, &rcParent);
    else
        rcParent = rcWorkArea;

    SIZE sizParent = SizeFromRectDx(&rcParent);

    RECT rc;
    ::GetWindowRect(hwnd, &rc);
    SIZE siz = SizeFromRectDx(&rc);

    POINT pt;
    pt.x = rcParent.left + (sizParent.cx - siz.cx) / 2;
    pt.y = rcParent.top + (sizParent.cy - siz.cy) / 2;

    if (bChild && hwndParent)
    {
        ::GetClientRect(hwndParent, &rcParent);
        ::MapWindowPoints(hwndParent, NULL, (LPPOINT)&rcParent, 2);
        RepositionPointDx(&pt, siz, &rcParent);

        ::ScreenToClient(hwndParent, &pt);
    }
    else
    {
        RepositionPointDx(&pt, siz, &rcWorkArea);
    }

    ::SetWindowPos(hwnd, NULL, pt.x, pt.y, 0, 0,
                   SWP_NOSIZE | SWP_NOZORDER | SWP_NOACTIVATE);
}

inline /*static*/ BOOL MZCAPI
MWindowBase::GetWindowPosDx(HWND hwnd, POINT *ppt/* = NULL*/, SIZE *psiz/* = NULL*/)
{
    assert(IsWindow(hwnd));
    return ::GetWindowPosDx(hwnd, ppt, psiz);
}

inline BOOL MZCAPI
MWindowBase::GetWindowPosDx(POINT *ppt/* = NULL*/, SIZE *psiz/* = NULL*/)
{
    assert(IsWindow(m_hwnd));
    return ::GetWindowPosDx(m_hwnd, ppt, psiz);
}

inline /*static*/ BOOL MZCAPI MWindowBase::GetWindowPosDx(HWND hwnd, RECT *prc)
{
    assert(IsWindow(hwnd));
    return ::GetWindowPosDx(hwnd, prc);
}

inline BOOL MZCAPI MWindowBase::GetWindowPosDx(RECT *prc)
{
    assert(IsWindow(m_hwnd));
    return ::GetWindowPosDx(m_hwnd, prc);
}

inline /*static*/ BOOL
MWindowBase::SetWindowPosDx(
    HWND hwnd, LPPOINT ppt/* = NULL*/, LPSIZE psiz/* = NULL*/,
    HWND hwndInsertAfter/* = NULL*/,
    UINT uFlags/* = SWP_NOACTIVATE | SWP_NOOWNERZORDER*/)
{
    assert(IsWindow(hwnd));
    return ::SetWindowPosDx(hwnd, ppt, psiz, hwndInsertAfter, uFlags);
}

inline /*static*/ BOOL MWindowBase::SetWindowPosDx(HWND hwnd, const RECT *prc)
{
    assert(IsWindow(hwnd));
    return ::SetWindowPosDx(hwnd, prc);
}

inline BOOL
MWindowBase::SetWindowPosDx(
    LPPOINT ppt/* = NULL*/, LPSIZE psiz/* = NULL*/,
    HWND hwndInsertAfter/* = NULL*/,
    UINT uFlags/* = SWP_NOACTIVATE | SWP_NOOWNERZORDER*/)
{
    assert(IsWindow(m_hwnd));
    return ::SetWindowPosDx(m_hwnd, ppt, psiz, hwndInsertAfter, uFlags);
}

inline BOOL MWindowBase::SetWindowPosDx(const RECT *prc)
{
    assert(IsWindow(m_hwnd));
    return ::SetWindowPosDx(m_hwnd, prc);
}

inline /*static*/ HWND MWindowBase::GetAncestorDx(HWND hTarget)
{
    HWND hwndParent;
    for (;;)
    {
        hwndParent = ::GetParent(hTarget);
        if (hwndParent == NULL)
        {
            hwndParent = ::GetWindow(hTarget, GW_OWNER);
            if (hwndParent == NULL)
            {
                break;
            }
        }
        hTarget = hwndParent;
    }
    return hTarget;
}

/*static*/ inline LRESULT CALLBACK
MWindowBase::_msgBoxCbtProcDx(INT nCode, WPARAM wParam, LPARAM lParam)
{
#ifndef MZC_NO_CENTER_MSGBOX
    if (nCode == HCBT_ACTIVATE)
    {
        HWND hwnd = (HWND)wParam;
        TCHAR szClassName[16];
        ::GetClassName(hwnd, szClassName, _countof(szClassName));
        if (lstrcmpi(szClassName, TEXT("#32770")) == 0)
        {
            CenterWindowDx(hwnd);
        }
    }
#endif  // ndef MZC_NO_CENTER_MSGBOX

    return 0;   // allow the operation
}

inline /*static*/ HHOOK MWindowBase::HookCenterMsgBoxDx(BOOL bHook)
{
#ifdef MZC_NO_CENTER_MSGBOX
    return NULL;
#else   // ndef MZC_NO_CENTER_MSGBOX
    static HHOOK s_hHook = NULL;
    if (bHook)
    {
        if (s_hHook == NULL)
        {
            DWORD dwThreadID = GetCurrentThreadId();
            s_hHook = ::SetWindowsHookEx(WH_CBT, _msgBoxCbtProcDx, NULL, dwThreadID);
        }
    }
    else
    {
        if (s_hHook)
        {
            if (::UnhookWindowsHookEx(s_hHook))
            {
                s_hHook = NULL;
            }
        }
    }
    return s_hHook;
#endif  // ndef MZC_NO_CENTER_MSGBOX
}

//////////////////////////////////////////////////////////////////////////////

inline /*static*/ INT_PTR CALLBACK
MDialogBase::DialogProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    MDialogBase *base;
    if (uMsg == WM_INITDIALOG)
    {
        assert(lParam);
        base = (MDialogBase *)lParam;
        base->Attach(hwnd);
    }
    else
    {
        base = GetUserData(hwnd);
    }

    INT_PTR ret = 0;
    if (base)
    {
        base->SaveMessageDx(hwnd, uMsg, wParam, lParam);
        ret = base->DialogProcDx(hwnd, uMsg, wParam, lParam);
        if (uMsg == WM_NCDESTROY)
        {
            base->PostNcDestroy();
        }
    }

    return ret;
}

inline BOOL MDialogBase::CreateDialogDx(HWND hwndOwner, INT nDialogID)
{
    return CreateDialogDx(hwndOwner, MAKEINTRESOURCE(nDialogID));
}

inline INT_PTR MDialogBase::DialogBoxDx(HWND hwndOwner, INT nDialogID)
{
    return DialogBoxDx(hwndOwner, MAKEINTRESOURCE(nDialogID));
}

inline BOOL
MDialogBase::CreateDialogIndirectDx(HWND hwndOwner, const VOID *ptr)
{
    if (hwndOwner)
    {
        m_hwndOwner = hwndOwner;
    }
    m_bModal = FALSE;
    HWND hwnd = ::CreateDialogIndirectParam(::GetModuleHandle(NULL),
        reinterpret_cast<const DLGTEMPLATE *>(ptr),
        m_hwndOwner, MDialogBase::DialogProc,
        reinterpret_cast<LPARAM>(this));
    if (hwnd == NULL)
    {
        Detach();
    }
    return hwnd != NULL;
}

inline INT_PTR
MDialogBase::DialogBoxIndirectDx(HWND hwndOwner, const VOID *ptr)
{
    if (hwndOwner)
    {
        m_hwndOwner = hwndOwner;
    }
    m_bModal = TRUE;
    INT_PTR nID = ::DialogBoxIndirectParam(::GetModuleHandle(NULL),
                                           (const DLGTEMPLATE *)ptr,
                                           m_hwndOwner,
                                           MDialogBase::DialogProc,
                                           reinterpret_cast<LPARAM>(this));
    return nID;
}

inline BOOL
MDialogBase::CreateDialogDx(HWND hwndOwner, LPCTSTR pDialogName)
{
    if (hwndOwner)
    {
        m_hwndOwner = hwndOwner;
    }
    m_bModal = FALSE;
    HWND hwnd = ::CreateDialogParam(::GetModuleHandle(NULL), pDialogName,
                                    m_hwndOwner, MDialogBase::DialogProc,
                                    reinterpret_cast<LPARAM>(this));
    if (hwnd == NULL)
    {
        Detach();
    }
    return hwnd != NULL;
}

inline INT_PTR
MDialogBase::DialogBoxDx(HWND hwndOwner, LPCTSTR pDialogName)
{
    if (hwndOwner)
    {
        m_hwndOwner = hwndOwner;
    }
    m_bModal = TRUE;
    INT_PTR nID = ::DialogBoxParam(::GetModuleHandle(NULL),
        pDialogName, m_hwndOwner, MDialogBase::DialogProc, (LPARAM)this);
    return nID;
}

//////////////////////////////////////////////////////////////////////////////

#endif  // ndef MZC4_MWINDOWBASE_HPP_

```

`MyWndCtrl/MyWndCtrl.cpp`:

```cpp
// MyWndCtrl --- private window class
//////////////////////////////////////////////////////////////////////////////

#define NO_STRSAFE
#include "MWindowBase.hpp"

//////////////////////////////////////////////////////////////////////////////

class MyWndCtrl : public MWindowBase
{
public:
    DECLARE_DYNAMIC(MyWndCtrl)

    MyWndCtrl()
    {
    }

    virtual ~MyWndCtrl()
    {
    }

    static BOOL RegisterDx()
    {
        MyWndCtrl ctrl;
        return ctrl.RegisterClassDx();
    }

    virtual LPCTSTR GetWndClassNameDx() const
    {
        return TEXT("MyWndCtrl");
    }

    static HBRUSH& GetBackBrush()
    {
        static HBRUSH s_hbrBack = ::CreateSolidBrush(RGB(255, 0, 0));
        return s_hbrBack;
    }

    virtual VOID ModifyWndClassDx(WNDCLASSEX& wcx)
    {
        wcx.hbrBackground = GetBackBrush();
        wcx.hCursor = LoadCursor(NULL, IDC_CROSS);
    }

    BOOL OnCreate(HWND hwnd, LPCREATESTRUCT lpCreateStruct)
    {
        return TRUE;
    }

    void OnPaint(HWND hwnd)
    {
        PAINTSTRUCT ps;
        if (HDC hDC = BeginPaint(hwnd, &ps))
        {
            SelectObject(hDC, GetStockObject(WHITE_BRUSH));
            SelectObject(hDC, GetStockObject(BLACK_PEN));
            RECT rc;
            GetClientRect(hwnd, &rc);
            Ellipse(hDC, rc.left, rc.top, rc.right, rc.bottom);
            EndPaint(hwnd, &ps);
        }
    }

    virtual LRESULT CALLBACK
    WindowProcDx(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
    {
        switch (uMsg)
        {
        HANDLE_MSG(hwnd, WM_CREATE, OnCreate);
        HANDLE_MSG(hwnd, WM_PAINT, OnPaint);
        default:
            return DefaultProcDx();
        }
    }

protected:
    HBRUSH m_hbrBack;
};

IMPLEMENT_DYNAMIC(MyWndCtrl)

//////////////////////////////////////////////////////////////////////////////

BOOL WINAPI
DllMain(HINSTANCE hinstDLL, DWORD fdwReason, LPVOID lpvReserved)
{
    switch (fdwReason)
    {
    case DLL_PROCESS_ATTACH:
        MyWndCtrl::RegisterDx();
        break;
    case DLL_PROCESS_DETACH:
        DeleteObject(MyWndCtrl::GetBackBrush());
        MyWndCtrl::GetBackBrush() = NULL;
        break;
    }
    return TRUE;
}

//////////////////////////////////////////////////////////////////////////////

```

`README-ID.txt`:

```txt
(Indonesian)
/////////////////////////////////////////////////////
RisohEditor oleh katahiromz
/////////////////////////////////////////////////////

RisohEditor adalah pengedit sumber daya gratis untuk pengembangan win32.
Ini bisa mengedit/ekstrak/klon/hapus data sumber daya dalam
berkas RC/RES/EXE/DLL.

Pengunduhan binary: https://katahiromz.web.fc2.com/re/en

Bekerja pada Windows XP/2003/Vista/7/8.1/10 dan ReactOS.

Lihat "LICENSE.txt" untuk rincian hak cipta dan
lisensi persetujuan.

/////////////////////////////////////////////////////

Pertanyaan 1. Apa itu "Risoh"?

     Jawaban. Dalam Bahasa Jepang, "Risoh" berarti "ideal".

Pertanyaan 2. Apa itu edt1, edt2, cmb1?

     Jawaban. Semua itu adalah makro ID kontrol standar yang disebut dalam <dlgs.h>.

Pertanyaan 3. Apa itu mcdx?

     Jawaban. itu adalah pesan spesial pada penyusun yang saya buat.
              Lihat mcdx/MESSAGETABLEDX.md untuk rincian.

Pertanyaan 4. Mengapa saya mendapat karakter acak ketika menyusun dengan Visual Studio?

     Jawaban. Penyusun Sumber daya pada MSVC memiliki bug dalam menangani
              berkas sumber daya UTF-8.

              Gunakan UTF-16 (tetapi, UTF-16 tidak didukung dalam GNU windres).

Pertanyaan 5. Apa perbedaan dari versi "no installer" dan portabel?

     Jawaban. Versi portabel tidak menggunakan registri, tetapi mengunakan berkas "*.ini".

Pertanyaan 6. Apakah berkas 64-bit didukung?

    Jawaban. Ya, pada Windows 64-bit. Bagaimanapun layar emulasi WoW64 mencegah
             pemuatan dari "C:\Program Files" atau "C:\Windows\system32".
             Kamu harus menyalin berkas 64-bit di tempat lain sebelum memuatnya.

/////////////////////////////////////////////////////////////////////
Katayama Hirofumi MZ (katahiromz) [A.N.T.]
Laman web (Inggris): https://katahiromz.web.fc2.com/re/en
Laman web (Cina):    https://katahiromz.web.fc2.com/re/ch
Laman web (Jepang):  https://katahiromz.web.fc2.com/re/ja
Laman web (Italia):  https://katahiromz.web.fc2.com/re/it
Laman web (Rusia):   https://katahiromz.web.fc2.com/re/ru
Email                katayama.hirofumi.mz@gmail.com
/////////////////////////////////////////////////////////////////////

```

`README-ITA.txt`:

```txt
(italiano)
/////////////////////////////////////////////////////
RisohEditor di katahiromz
/////////////////////////////////////////////////////

RisohEditor è un editor di risorse gratuito per Windows, 
creato da Katayama Hirofumi MZ.

Link download: https://katahiromz.web.fc2.com/re/en

Funziona con Windows XP/2003/Vista/7/8.1/10 e ReactOS.

Per la standardizzazione degli ID risorse vedi file "Standardize.md".

per dettagli sul copyright e sull'accordo di licenza vedi il 
file "LICENSE.txt".

/////////////////////////////////////////////////////

Domanda 1. Che cos'è "Risoh"?

    Risposta. La parola "Risoh" significa "ideale" in Giapponese.

Domanda 2. Che cosa sono edt1, edt2, cmb1?

    Risposta. Sono gli ID delle macro di controllo definite in <dlgs.h>.

Domanda 3. Che cos'è mcdx?

    Risposta. È uno speciale compilatore messaggio che ho realizzato.
              Per i dettagli vedi mcdx/MESSAGETABLEDX.md.

Domanda 4. Perché ottengo caratteri confusi quando compilo con Visual Studio?

    Risposta. Il compilatore di risorse di MSVC ha un problema nel trattamento 
              dei file risorse codificati in UTF-8.

              Usa UTF-16 (ma UTF-16 non è supportato in windres di GNU).

Domanda 5. Qual è la differenza tra nessuna versione di installazione e portatile?

    Risposta. La versione portatile non utilizza il registro ma un file ini.

Domanda 6. I file a 64 bit sono supportati?

    Risposta. Sì in Windows a 64 bit. Tuttavia, il livello di emulazione WoW64 impedisce
              il caricamento da "C:\Program Files" o "C:\Windows\system32".
              Devi copiare il file a 64 bit in un altro posto prima di caricarlo.

/////////////////////////////////////////////////////////////////////
// Katayama Hirofumi MZ (katahiromz) [A.N.T.]
// Sito web (inglese):    https://katahiromz.web.fc2.com/re/en
// Sito web (cinese):     https://katahiromz.web.fc2.com/re/ch
// Sito web (giapponese): https://katahiromz.web.fc2.com/re/ja
// Sito web (italiano):   https://katahiromz.web.fc2.com/re/it
// Sito web (russo):      https://katahiromz.web.fc2.com/re/ru
// Sito web (portoghese): https://katahiromz.web.fc2.com/re/pt
// Email:                 katayama.hirofumi.mz@gmail.com
/////////////////////////////////////////////////////////////////////

```

`README-JPN.txt`:

```txt
(Japanese, UTF-8)
/////////////////////////////////////////////////////
リソーエディタ by 片山博文MZ
/////////////////////////////////////////////////////

[概要]
    リソーエディタ (RisohEditor) は、片山博文MZによる
    Win32開発用のフリーのリソースエディタです。

    RC/RES/EXE/DLLファイル中のリソースデータを読み書きできます。
    UTF-16 リソースファイルもサポートしています。

    ダウンロード: https://katahiromz.web.fc2.com/re/ja

    Windows XP/2003/Vista/7/8.1/10とReactOSで動作します。

    著作権・使用条件等については、添付のファイル「LICENSE.txt」を
    ご覧下さい。
[よくある質問]
    質問 1. Risohって何ですか？

      答え：日本語の「理想」です。

    質問 2. edt1, edt2, cmb1って何ですか？

      答え：<dlgs.h>で定義済みの標準のコントロールIDです。

    質問 3. mcdxって何？

      答え：私が作った特殊なメッセージコンパイラです。
            詳しくは mcdx/MESSAGETABLEDX.md をご覧下さい。

    質問 4. なぜVisual Studioでコンパイルすると、文字化けするの？

      答え：MSVC のリソースコンパイラはUTF-8リソースファイルの扱いに
            不具合があるからです。

            UTF-16 をお使い下さい（だがGNU windresはUTF-16をサポートしてない）。

    質問 5. インストーラなしとポータブル版の違いは何？

      答え：ポータブル版はレジストリを使わず、iniファイルを使います。

    質問 6. 64ビットのファイルはサポートされていますか？

      答え：64ビットのWindowsでは「はい」です. しかしWoW64 エミュレーション
            レイヤーは "C:\Program Files" や "C:\Windows\system32" からの読み込みを
            邪魔します。読み込みの前に別の場所にコピーする必要があります。

/////////////////////////////////////////////////////
// 片山博文MZ (katahiromz) [A.N.T.]
// ホームページ http://katahiromz.web.fc2.com
// 掲示板       http://katahiromz.bbs.fc2.com
// メール       katayama.hirofumi.mz@gmail.com
/////////////////////////////////////////////////////

```

`README-KOR.txt`:

```txt
(한국어)
/////////////////////////////////////////////////////
katahiromz가 개발한 RisohEditor
/////////////////////////////////////////////////////

RisohEditor는 Win32 개발을 위한 무료 리소스 편집기입니다.
RC/RES/EXE/DLL 파일의 리소스 데이터를 편집/추출/복제/삭제
할 수 있습니다.

바이너리 다운로드: https://katahiromz.web.fc2.com/re/ko/

Windows XP/2003/Vista/7/8.1/10 및 ReactOS에서 작동합니다.

저작권 및 라이센스 계약에 대한 자세한 내용은 
"LICENSE.txt"를 참조하십시오.

/////////////////////////////////////////////////////

질문 1. "Risoh"가 무엇입니까?

    대답. "Risoh"라는 단어는 일본어로 "이상적인"을 의미합니다.

질문 2. edt1, edt2, cmb1은 무엇입니까?

    대답. 이들은 <dlgs.h>에 정의된 표준 제어 ID 매크로입니다.

질문 3. mcdx란 무엇입니까?

    대답. 제가 만든 특별한 메시지 컴파일러입니다.
            자세한 내용은 mcdx/MESSAGETABLEDX.md를 참조하십시오.

질문 4. Visual Studio로 컴파일할 때 잘못된 문자가 표시되는 이유는 무엇입니까?

    대답. MSVC의 리소스 컴파일러는 UTF-8 리소스 파일을 처리하는데 
            버그가 있습니다.

            UTF-16을 사용합니다 (그러나 UTF-16은 GNU windres에서 지원되지 않습니다).

질문 5. 설치 프로그램 없음과 휴대용 버전의 차이점은 무엇입니까?

    대답. 휴대용 버전은 레지스트리를 사용하지 않고 ini 파일을 사용합니다.

질문 6. 64비트 파일이 지원됩니까?

    대답. 예. 64비트 Windows에서는 가능합니다. 그러나 WoW64 에뮬레이션 레이어는 
           "C:\Program Files" 또는 C:\Windows\system32"에서 로드되는 것을 방지합니다.
            로드하기 전에 64비트 파일을 다른 위치에 복사해야 합니다.

/////////////////////////////////////////////////////////////////////
Katayama Hirofumi MZ (katahiromz) [A.N.T.]
Webpage (Korean):   https://katahiromz.web.fc2.com/re/ko
Webpage (English):  https://katahiromz.web.fc2.com/re/en
Webpage (Chinese):  https://katahiromz.web.fc2.com/re/ch
Webpage (Japanese): https://katahiromz.web.fc2.com/re/ja
Webpage (Italian):  https://katahiromz.web.fc2.com/re/it
Webpage (Russian):  https://katahiromz.web.fc2.com/re/ru
Email               katayama.hirofumi.mz@gmail.com
/////////////////////////////////////////////////////////////////////

```

`README-PTB.txt`:

```txt
(Português)
/////////////////////////////////////////////////////
RisohEditor por katahiromz
/////////////////////////////////////////////////////

RisohEditor é um editor de recursos gratuito para desenvolvimento Win32.
Ele pode editar/extrair/clonar/excluir os dados do recurso em
Arquivos RC/RES/EXE/DLL.

Baixar binário: https://katahiromz.web.fc2.com/re/en

Funciona no Windows XP/2003/Vista/7/8.1/10 e ReactOS.

Consulte "LICENSE.txt" para obter detalhes sobre direitos autorais e
contrato de licença.

/////////////////////////////////////////////////////

Pergunta 1. O que é "Risoh"?

  Resposta. A palavra "Risoh" significa "ideal" em Japonês.

Pergunta 2. O que são edt1, edt2, cmb1?

  Resposta. Essas são macros de ID de controle padrão definidas em <dlgs.h>.

Pergunta 3. O que é mcdx?

  Resposta. É um compilador de mensagens especial que fiz.
            Consulte mcdx/MESSAGETABLEDX.md para obter detalhes.

Pergunta 4. Por que recebi caracteres distorcidos ao compilar com o Visual Studio?

  Resposta. O compilador de recursos do MSVC tem um bug no tratamento de
            Arquivos de recursos UTF-8.

            Use UTF-16 (mas UTF-16 não é suportado em GNU windres).

Pergunta 5. Qual é a diferença entre instalador e versão portátil?

  Resposta. A versão portátil não usa registro, mas um arquivo ini.

Pergunta 6. Os arquivos de 64 bits são suportados?

  Resposta. Sim no Windows 64 bits. No entanto, a camada de emulação WoW64 impede o 
            carregamento disso "C:\Program Files" ou "C:\Windows\system32".
            Você precisa copiar o arquivo de 64 bits para outro local antes de carregar.

/////////////////////////////////////////////////////////////////////
Katayama Hirofumi MZ (katahiromz) [A.N.T.]
Página Web (Inglês):    https://katahiromz.web.fc2.com/re/en
Página Web (Chinês):    https://katahiromz.web.fc2.com/re/ch
Página Web (Japonês):   https://katahiromz.web.fc2.com/re/ja
Página Web (Italiano):  https://katahiromz.web.fc2.com/re/it
Página Web (Russo):     https://katahiromz.web.fc2.com/re/ru
Página Web (Português): https://katahiromz.web.fc2.com/re/pt
Email                   katayama.hirofumi.mz@gmail.com
/////////////////////////////////////////////////////////////////////

```

`README-TR.txt`:

```txt
(Türkçe)
/////////////////////////////////////////////////////
katahiromz RisohEditor' ü gururla sunar
/////////////////////////////////////////////////////

RisohEditor Win32 geliştirme yapmanızı sağlayan ücretsiz kaynak(resource) editörüdür.

RC/RES/EXE/DLL dosyalarındaki kaynak(resource) verisini 
düzenleyebilir/çıkarabilir/klonlayabilir/silebilir.

Çalıştırılabilir dosyayı buradan indirebilirsiniz: https://katahiromz.web.fc2.com/re/en

Windows XP/2003/Vista/7/8.1/10 ve ReactOS de çalışır.

Telif hakları(copyrights) ve lisans anlaşmasının detayları için 
"LICENSE.txt" dosyasına bakın.

/////////////////////////////////////////////////////

Soru 1. "Risoh" ne demek?

    Cevap. "Risoh" kelimesi japoncada "ideal" anlamına gelmektedir.
	
Soru 2. edt1, edt2 ve cmb1 nedir?

    Cevap. Bunlar <dlgs.h> dosyasında tanımlanmış standart kontrol ID makrolarıdır.

Soru 3. mcdx nedir?

    Cevap. O benim yapmış olduğum özel mesaj derleyicisdir.
	   Detaylar için mcdx/MESSAGETABLEDX.md dosyasına bakınız.

Soru 4. Visual studio ile derlediğim zaman neden anlamsız karakterler görüyorum/alıyorum?

    Cevap.  MSVC' nin kaynak(resource) derleyicisinin UTF-8 içeren 
 	    kaynak(resource) dosyalarını işleme konusunda bir hatası var. 

            UTF-16 kullanın (fakat UTF-16 GNU windres tarafından desteklenmez).

Soru 5. Kurulumsuz(no installer) ve taşınabilir(portable) versiyon arasındaki fark nedir?

    Cevap. Taşınabilir(portable) versiyon kayıt defterini(registry)' i kullanmaz 
	onun yerine bir ini dosyasını kullanır.

Soru 6. 64-bit dosyaları destekliyor mu?

    Cevap. 64-bit destekleyen Windows sürümünde destekler. Ancak Wow64 emülasyon katmanı
           "C:\Program Files" veya "C:\Windows\system32" dizinlerinden dosya yüklenmesini engelliyor
           bu yüzden 64-bit dosyayınızı yüklemeden önce başka bir dizine kopyalamanız gerekiyor. 
 
/////////////////////////////////////////////////////////////////////
Katayama Hirofumi MZ (katahiromz) [A.N.T.]
Web sitesi (İngilizce): https://katahiromz.web.fc2.com/re/en
Web sitesi (Çince):     https://katahiromz.web.fc2.com/re/ch
Web sitesi (Japonca):   https://katahiromz.web.fc2.com/re/ja
Web sitesi (İtalyanca): https://katahiromz.web.fc2.com/re/it
Web sitesi (Rusça):     https://katahiromz.web.fc2.com/re/ru
Email                   katayama.hirofumi.mz@gmail.com
/////////////////////////////////////////////////////////////////////

```

`README.md`:

```md
![CMake](https://github.com/katahiromz/RisohEditor/workflows/CMake/badge.svg)

# ![](re-icon.png "") RisohEditor by katahiromz

RisohEditor is a free resource editor for Win32 development, created by Katayama Hirofumi MZ.

It can read/write resource data in RC/RES/EXE/DLL files. UTF-16 resource files are also supported.

- Web page (English): https://katahiromz.web.fc2.com/re/en
- Web page (Chinese): https://katahiromz.web.fc2.com/re/ch
- Web page (Italian): https://katahiromz.web.fc2.com/re/it
- Web page (Japanese): https://katahiromz.web.fc2.com/re/ja
- Web page (Korean): https://katahiromz.web.fc2.com/re/ko
- Web page (Russian): https://katahiromz.web.fc2.com/re/ru
- Web page (Portuguese): https://katahiromz.web.fc2.com/re/pt

## Supported Platforms

It works on Windows XP/2003/Vista/7/8.1/10 and ReactOS.

## License Agreement

See [LICENSE.txt](https://github.com/katahiromz/RisohEditor/blob/master/LICENSE.txt) for details of copyrights and license agreement.

## Standardization

See "Standardize.md" for our standardization of resource IDs.

## FAQ

### Question 1. What is "Risoh"?

The word "risoh" means "ideal" in Japanese.

### Question 2. What are edt1, edt2, cmb1?

Those are standard control ID macros defined in `<dlgs.h>`.

### Question 3. What is mcdx?

It's a special message compiler I made. See [mcdx/MESSAGETABLEDX.md](https://github.com/katahiromz/RisohEditor/blob/master/mcdx/MESSAGETABLEDX.md) for details.

### Question 4. Why did I get garbled characters when compiling with Visual Studio?

The resource compiler of MSVC has a bug in treatment of UTF-8 resource files.

Use UTF-16 (but UTF-16 is not supported in GNU windres).

### Question 5. What is the difference between no installer and portable version?

The portable version doesn't use registry but an ini file.

### Question 6. Are the 64-bit files supported?

Yes on 64-bit Windows. However WoW64 emulation layer prevents it
loading from `"C:\Program Files"` or `"C:\Windows\system32"`.
You have to copy the 64-bit file into another place before loading.

## Contact Us

katayama.hirofumi.mz@gmail.com

```

`README.txt`:

```txt
(English)
/////////////////////////////////////////////////////
RisohEditor by katahiromz
/////////////////////////////////////////////////////

RisohEditor is a free resource editor for Win32 development.
It can edit/extract/clone/delete the resource data in
RC/RES/EXE/DLL files.

Download binary: https://katahiromz.web.fc2.com/re/en

It works on Windows XP/2003/Vista/7/8.1/10 and ReactOS.

See "LICENSE.txt" for details of copyrights and 
license agreement.

/////////////////////////////////////////////////////

Question 1. What is "Risoh"?

    Answer. The word "Risoh" means "ideal" in Japanese.

Question 2. What are edt1, edt2, cmb1?

    Answer. Those are standard control ID macros defined in <dlgs.h>.

Question 3. What is mcdx?

    Answer. It's a special message compiler I made.
            See mcdx/MESSAGETABLEDX.md for details.

Question 4. Why did I get garbled characters when compiling with Visual Studio?

    Answer. The resource compiler of MSVC has a bug in treatment of
            UTF-8 resource files.

            Use UTF-16 (but UTF-16 is not supported in GNU windres).

Question 5. What is the difference between no installer and portable version?

    Answer. The portable version doesn't use registry but an ini file.

Question 6. Are the 64-bit files supported?

    Answer. Yes on 64-bit Windows. However WoW64 emulation layer prevents it
            loading from "C:\Program Files" or "C:\Windows\system32".
            You have to copy the 64-bit file into another place before loading.

/////////////////////////////////////////////////////////////////////
Katayama Hirofumi MZ (katahiromz) [A.N.T.]
Webpage (English):    https://katahiromz.web.fc2.com/re/en
Webpage (Chinese):    https://katahiromz.web.fc2.com/re/ch
Webpage (Japanese):   https://katahiromz.web.fc2.com/re/ja
Webpage (Italian):    https://katahiromz.web.fc2.com/re/it
Webpage (Russian):    https://katahiromz.web.fc2.com/re/ru
Webpage (Portuguese): https://katahiromz.web.fc2.com/re/pt
Email                 katayama.hirofumi.mz@gmail.com
/////////////////////////////////////////////////////////////////////

```

`Standardize.md`:

```md
# Standardize Win32 Resource

New RisohEditor resource information should follow the following guidelines.
If you are using old RisohEditor resource data, then you have to apply the following guidelines.

## DEFINITIONS

- A "resource ID" is the ID, that is used for Win32 resource data.
- An "ID prefix" is the prefix of the resource ID.
- An "entity resource" is a resource data except RT_ICON, RT_CURSOR, RT_STRING, RT_MANIFEST, RT_VERSION and RT_MESSAGETABLE.
- A "resource name" of an entity resource is either a 16-bit integer value, a wide string, or a macro of 16-bit integer value.
- The resource data of RT_ICON type is referred by the resource data of RT_GROUP_ICON type.
- The resource data of RT_CURSOR type is referred by the resource data of RT_GROUP_CURSOR type.
- The RT_STRING or RT_MESSAGETABLE resource can have multiple resource IDs.
- The resource ID of RT_MANIFEST or RT_VERSION has special meanings.
- The "user resource" is a Win32 resource data that the user's project directly provides, and that is not provided by another project or framework.
- The "user ID" is the resource ID that the user's project directly provides, and that is not provided by another project or framework.
- The "icon ID" is the resource ID of RT_GROUP_ICON type.
- The "cursor ID" is the resource ID of RT_GROUP_CURSOR type.
- The "string ID" is the ID of one string data in the string table.
- The "message ID" is the ID of one message data in the message table.

## GUIDELINES

For Visual C++ compatibility, the contents of file "resource.h" should begin with the C++ comments as follows:

```c
//{{NO_DEPENDENCIES}}
// Microsoft Visual C++ Compatible
// TheProject.rc
```

Here, "TheProject.rc" must be replaced with the actual resource file name for this "resource.h".

File "resource.h" should not use include guard.

In "resource.h", please don't define string macros.
Please don't use resource IDs of string value.

If the rc file has #include's of the system headers, then the includes should be wrapped as follows:

```c
#define APSTUDIO_HIDDEN_SYMBOLS
#include <windows.h>
#include <commctrl.h>
#undef APSTUDIO_HIDDEN_SYMBOLS
```

The contents of file "resource.h" should end with the text like:

```c
#ifdef APSTUDIO_INVOKED
    #ifndef APSTUDIO_READONLY_SYMBOLS
        #define _APS_NO_MFC                 1
        #define _APS_NEXT_RESOURCE_VALUE    1000
        #define _APS_NEXT_COMMAND_VALUE     220
        #define _APS_NEXT_CONTROL_VALUE     1002
        #define _APS_NEXT_SYMED_VALUE       300
    #endif
#endif
```

Here, the value of _APS_NO_MFC macro should be one.
Here, the value of _APS_NEXT_RESOURCE_VALUE macro must be the maximum integer value + 1 of all the user entity resources.
Here, the value of _APS_NEXT_COMMAND_VALUE macro must be the maximum integer value + 1 of all the user command IDs.
Here, the value of _APS_NEXT_CONTROL_VALUE macro must be the maximum integer value + 1 of all the user control IDs.
Here, we should ignore the value of _APS_NEXT_SYMED_VALUE macro.

## ID PREFIXES

The user ID prefixes defined in file "resource.h" should apply the following table:

| ID Type                  | ID Prefix |
|--------------------------|-----------|
| String ID                | IDS_      |
| Message ID               | MSGID_    |
| Command ID               | ID_       |
| Command ID (Old Type)    | IDM_      |
| Control ID               | IDC_      |
| Cursor ID                | IDC_      |
| Icon ID                  | IDI_      |
| Dialog ID                | IDD_      |
| Bitmap ID                | IDB_      |
| Other Entity Resource ID | IDR_      |
| Window ID                | IDW_      |
| Help ID                  | HID_      |

Don't use the "IDP_" prefix.

## VALUES AND RANGES

The user ID defined in file "resource.h" should be inside of the following ranges:

| ID Type                  | Bounded Range    | Preferable Range |
|--------------------------|------------------|------------------|
| String ID                | 1 to 0x7FFF      | 100 to 0x7FFF    |
| Message ID               | 0 to 0xFFFFFFFF  | 1 to 0x7FFFFFFF  |
| Command ID               | 1 to 0x7FFF      | 100 to 0x7FFF    |
| Command ID (Old Type)    | 1 to 0x7FFF      | 100 to 0x7FFF    |
| Control ID               | 8 to 0xDFFF      | 1000 to 0x7FFF   |
| Cursor ID                | 1 to 0x7FFF      | 100 to 999       |
| Icon ID                  | 1 to 0x7FFF      | 100 to 999       |
| Dialog ID                | 1 to 0x7FFF      | 100 to 0x7FFF    |
| Bitmap ID                | 1 to 0x7FFF      | 100 to 0x7FFF    |
| Other Entity Resource ID | 1 to 0x7FFF      | 100 to 0x7FFF    |
| Window ID                | 1 to 0x7FFF      | 1 to 0x7FFF      |
| Help ID                  | 0 to 0xFFFFFFFF  | 1 to 0x7FFFFFFF  |

Two different resource IDs of the same ID prefix should have a different value from each other.
The resource ID of ID prefix "IDC_" is either a control ID or a cursor ID.
If we follow the preferable ranges of IDs, then control IDs and a cursor IDs don't collide.

## TEXTINCLUDE

For Visual C++ compatibility, the resource file should have three TEXTINCLUDE data as follows:

```rc
#ifdef APSTUDIO_INVOKED

1 TEXTINCLUDE
BEGIN
    "resource.h\0"
END

2 TEXTINCLUDE 
BEGIN
    "#define APSTUDIO_HIDDEN_SYMBOLS\r\n"
    "#include <windows.h>\r\n"
    "#include <commctrl.h>\r\n"
    "#undef APSTUDIO_HIDDEN_SYMBOLS\r\n"
    "\0"
END

3 TEXTINCLUDE 
BEGIN
    "\r\n"
    "\0"
END

#endif    // APSTUDIO_INVOKED
```

## COMMENTS

The resource file and "resource.h" file should use C++ comments rather than C comments.

## SEE ALSO

[https://msdn.microsoft.com/en-us/library/t2zechd4.aspx](https://msdn.microsoft.com/en-us/library/t2zechd4.aspx)

```

`TRANSLATORS.txt`:

```txt
(UTF-8)

# Translators

The translators of RisohEditor are listed below:

 * English:
    - Katayama Hirofumi MZ <katayama.hirofumi.mz@gmail.com>
 * Korean:
    ✧₊⁎˓VᴇɴᴜsGɪʀʟ 비너스걸❤˒⁎⁺˳✧༚ <venusgirl@outlook.com>
 * Finnish:
    - Veikko Muurikainen <veikko.muurikainen@kolumbus.fi>
 * Indonesian:
    - Mas Ahmad Muhammad <m.charly81@gmail.com>
 * Italian:
    - R.B. <bovirus@gmail.com>
 * Japanese:
    - Katayama Hirofumi MZ <katayama.hirofumi.mz@gmail.com>
 * Polish:
    - Piotr Hetnarowicz <piotrhwz@gmail.com>
 * Portuguese:
    - JNylson <nylsinho_ba@hotmail.com>
 * Russian:
    - Dmitry Yerokhin <erodim@mail.ru>
 * Simplified Chinese:
    - 林鸿湘 (Linhong Xiang) <lhxy24@163.com>
 * Traditional Chinese:
    - 嚕拉 <xyz321763@gmail.com>

# How to translate?

At first, copy and rename "src/lang/en_US.rc" (for example "ru_RU.rc" for Russian).
Open "ru_RU.rc" with a text editor that supports "UTF-8 encoding without BOM".

You have to replace the following line:

    LANGUAGE LANG_ENGLISH, SUBLANG_DEFAULT

with:

    LANGUAGE LANG_RUSSIAN, SUBLANG_DEFAULT

And then translate all the string literals in "ru_RU.rc".

Finally, open "src/RisohEditor_res.rc" with the text editor,
and insert the following line at "Languages" section of that file:

    #include "lang/ru_RU.rc"

Then you can open "src/RisohEditor_res.rc" with RisohEditor.
You can check the dialog resources by it.

If you did translate everything, then please send me your translation
(ru_RU.rc) to katayama.hirofumi.mz@gmail.com .

```

`build.cmd`:

```cmd
git submodule update --init --recursive
cmake .
cmake --build .

```

`data/Constants.txt`:

```txt
[CLASS.STYLE]
CS_VREDRAW, 0x0001
CS_HREDRAW, 0x0002
CS_DBLCLKS, 0x0008
CS_OWNDC, 0x0020
CS_CLASSDC, 0x0040
CS_PARENTDC, 0x0080
CS_NOCLOSE, 0x0200
CS_SAVEBITS, 0x0800
CS_BYTEALIGNCLIENT, 0x1000
CS_BYTEALIGNWINDOW, 0x2000
CS_GLOBALCLASS, 0x4000
CS_IME, 0x00010000
CS_DROPSHADOW, 0x00020000

[RESOURCE]
RT_CURSOR, 1
RT_BITMAP, 2
RT_ICON, 3
RT_MENU, 4
RT_DIALOG, 5
RT_STRING, 6
RT_FONTDIR, 7
RT_FONT, 8
RT_ACCELERATOR, 9
RT_RCDATA, 10
RT_MESSAGETABLE, 11
RT_GROUP_CURSOR, 12
RT_GROUP_ICON, 14
RT_VERSION, 16
RT_DLGINCLUDE, 17
RT_PLUGPLAY, 19
RT_VXD, 20
RT_ANICURSOR, 21
RT_ANIICON, 22
RT_HTML, 23
RT_MANIFEST, 24
RT_DLGINIT, 240
RT_TOOLBAR, 241

[RESOURCE.ID.TYPE]
Unknown.ID, 0
Cursor.ID, 1
Bitmap.ID, 2
Menu.ID, 3
Dialog.ID, 4
String.ID, 5
Accel.ID, 6
Icon.ID, 7
AniCursor.ID, 8
AniIcon.ID, 9
Html.ID, 10
Help.ID, 11
Command.ID, 12
Control.ID, 13
Resource.ID, 14
Message.ID, 15
Window.ID, 16
New.Command.ID, 17
Prompt.ID, 18
RCData.ID, 19

[NON.ENTITY.RESOURCE.TYPE]
RT_CURSOR, 0
RT_ICON, 0
RT_STRING, 0
RT_MESSAGETABLE, 0
RT_VERSION, 0
RT_MANIFEST, 0

[RESOURCE.ID.PREFIX]
, 0
IDC_, 1
IDB_, 2
IDR_, 3
IDD_, 4
IDS_, 5
IDR_, 6
IDI_, 7
IDR_, 8
IDR_, 9
IDR_, 10
HID_, 11
IDM_, 12
IDC_, 13
IDR_, 14
MSGID_, 15
IDW_, 16
ID_, 17
IDP_, 18
IDR_, 19

[LANGUAGES]
ALB, 1052
ARG, 11274
AUS, 3081
AUT, 3079
BEL, 2067
BGR, 1026
BHR, 15361
BLR, 1059
BLZ, 10249
BRA, 1046
CAN, 4105
CHE, 2064
CHL, 13322
CHN, 2052
COL, 9226
CRI, 5130
CZE, 1029
DEU, 1031
DMA, 7178
DNK, 1030
DZA, 5121
ECU, 12298
EGY, 3073
ENG, 1033
ESP, 1034
EST, 1061
FIN, 1035
FRA, 1036
GBR, 2057
GRC, 1032
GTM, 4106
HKG, 3076
HND, 18442
HRV, 1050
HUN, 1038
IDN, 1057
IRL, 6153
IRQ, 2049
ISL, 1039
ITA, 1040
JAM, 8201
JPN, 1041
KOR, 1042
KWT, 13313
LBN, 12289
LBY, 4097
LIE, 5127
LTU, 1063
LVA, 1062
MAR, 6145
MDA, 2072
MEX, 2058
MKD, 1071
MLT, 1082
MYS, 1086
NIC, 19466
NLD, 1043
NOR, 1044
NZL, 5129
OMN, 8193
PAK, 1056
PAN, 6154
PER, 10250
POL, 1045
PRI, 20490
PRK, 1042
PRT, 2070
PRY, 15370
QAT, 16385
ROU, 1048
RUS, 1049
SAU, 1025
SGP, 4100
SLV, 17418
SRB, 3098
SVK, 1051
SVN, 1060
SWE, 1053
THA, 1054
TUN, 7169
TUR, 1055
TWN, 1028
UKR, 1058
URY, 14346
USA, 1033
VNM, 1066
YEM, 9217
af, 1078
ar_AE, 14337
ar_BH, 15361
ar_DZ, 5121
ar_EG, 3073
ar_IQ, 2049
ar_JO, 11265
ar_KW, 13313
ar_LB, 12289
ar_LY, 4097
ar_MA, 6145
ar_OM, 8193
ar_QA, 16385
ar_SA, 1025
ar_SY, 10241
ar_TN, 7169
ar_YE, 9217
be, 1059
bg, 1026
bg_BG, 1026
ca, 1027
cs, 1029
cs_CZ, 1029
da, 1030
da_DK, 1030
de, 1031
de_AT, 3079
de_CH, 2055
de_DE, 1031
de_LI, 5127
de_LU, 4103
el, 1032
el_GR, 1032
en_AU, 3081
en_BZ, 10249
en_CA, 4105
en_GB, 2057
en_IE, 6153
en_JM, 8201
en_NZ, 5129
en_TT, 11273
en_US, 1033
en_ZA, 7177
es, 1034
es_AR, 11274
es_BO, 16394
es_CL, 13322
es_CO, 9226
es_CR, 5130
es_DO, 7178
es_EC, 12298
es_ES, 3082
es_GT, 4106
es_HN, 18442
es_MX, 2058
es_NI, 19466
es_PA, 6154
es_PE, 10250
es_PR, 20490
es_PY, 15370
es_SV, 17418
es_UY, 14346
es_VE, 8202
et, 1061
et_EE, 1061
eu, 1069
fa, 1065
fi, 1035
fi_FI, 1035
fo, 1080
fr, 1036
fr_BE, 2060
fr_CA, 3084
fr_CH, 4108
fr_FR, 1036
fr_LU, 5132
gd, 1084
he, 1037
he_IL, 1037
hi, 1081
hr, 1050
hr_HR, 1050
hu, 1038
hu_HU, 1038
id, 1057
id_ID, 1057
in, 1057
is, 1039
it, 1040
it_CH, 2064
it_IT, 1040
ja, 1041
ja_JP, 1041
ji, 1085
ko, 1042
ko_KR, 1042
lt, 1063
lt_LT, 1063
lv, 1062
lv_LV, 1062
mk, 1071
ms, 1086
mt, 1082
nb_NO, 1044
nl, 1043
nl_BE, 2067
nl_NL, 1043
no, 1044
pl, 1045
pl_PL, 1045
pt, 2070
pt_BR, 1046
pt_PT, 2070
rm, 1047
ro, 1048
ro_MO, 2072
ro_RO, 1048
ru, 1049
ru_MO, 2073
ru_RU, 1049
sb, 1070
sk, 1051
sk_SK, 1051
sl, 1060
sl_SI, 1060
sq, 1052
sr, 3098
sv, 1053
sv_FI, 2077
sv_SE, 1053
sx, 1072
th, 1054
th_TH, 1054
tn, 1074
tr, 1055
tr_TR, 1055
ts, 1073
uk, 1058
uk_UA, 1058
ur, 1056
vi, 1066
xh, 1076
zh_CN, 2052
zh_HK, 3076
zh_SG, 4100
zh_TW, 1028
zu, 1077

[RESOURCE.STRING.TYPE]
WAVE, 0
PNG, 0
IMAGE, 0
GIF, 0
JPEG, 0
TIFF, 0
AVI, 0
EMF, 0
ENHMETAFILE, 0
WMF, 0
RISOHTEMPLATE, 0
TYPELIB, 0

[STYLE]
WS_OVERLAPPED, 0x00000000
WS_POPUP, 0x80000000
WS_CHILD, 0x40000000
WS_MINIMIZE, 0x20000000
WS_VISIBLE, 0x10000000
WS_DISABLED, 0x08000000
WS_CLIPSIBLINGS, 0x04000000
WS_CLIPCHILDREN, 0x02000000
WS_MAXIMIZE, 0x01000000
WS_CAPTION, 0x00C00000
WS_BORDER, 0x00800000
WS_DLGFRAME, 0x00400000
WS_VSCROLL, 0x00200000
WS_HSCROLL, 0x00100000
WS_SYSMENU, 0x00080000
WS_THICKFRAME, 0x00040000
WS_GROUP, 0x00020000
WS_TABSTOP, 0x00010000
WS_SIZEBOX, WS_THICKFRAME
WS_CHILDWINDOW, WS_CHILD
WS_MINIMIZEBOX, 0x00020000
WS_MAXIMIZEBOX, 0x00010000
WS_POPUPWINDOW, WS_POPUP | WS_BORDER | WS_SYSMENU
WS_OVERLAPPEDWINDOW, WS_OVERLAPPED | WS_CAPTION | WS_SYSMENU | WS_THICKFRAME | WS_MINIMIZEBOX | WS_MAXIMIZEBOX
WS_TILEDWINDOW, WS_OVERLAPPEDWINDOW

[PARENT.STYLE]
WS_OVERLAPPED, 0x00000000
WS_POPUP, 0x80000000
WS_CHILD, 0x40000000
WS_MINIMIZE, 0x20000000
WS_VISIBLE, 0x10000000
WS_DISABLED, 0x08000000
WS_CLIPSIBLINGS, 0x04000000
WS_CLIPCHILDREN, 0x02000000
WS_MAXIMIZE, 0x01000000
WS_CAPTION, 0x00C00000
WS_BORDER, 0x00800000
WS_DLGFRAME, 0x00400000
WS_VSCROLL, 0x00200000
WS_HSCROLL, 0x00100000
WS_SYSMENU, 0x00080000
WS_THICKFRAME, 0x00040000
WS_MINIMIZEBOX, 0x00020000
WS_MAXIMIZEBOX, 0x00010000
WS_TILED, WS_OVERLAPPED
WS_ICONIC, WS_MINIMIZE
WS_SIZEBOX, WS_THICKFRAME
WS_POPUPWINDOW | WS_CAPTION, WS_POPUP | WS_CAPTION | WS_SYSMENU
WS_POPUPWINDOW, WS_POPUP | WS_BORDER | WS_SYSMENU
WS_CHILDWINDOW, WS_CHILD
WS_OVERLAPPEDWINDOW, WS_OVERLAPPED | WS_CAPTION | WS_SYSMENU | WS_THICKFRAME | WS_MINIMIZEBOX | WS_MAXIMIZEBOX
WS_TILEDWINDOW, WS_OVERLAPPEDWINDOW
WS_GROUP, 0x00020000
WS_TABSTOP, 0x00010000

[EXSTYLE]
WS_EX_DLGMODALFRAME, 0x00000001
WS_EX_NOPARENTNOTIFY, 0x00000004
WS_EX_TOPMOST, 0x00000008
WS_EX_ACCEPTFILES, 0x00000010
WS_EX_TRANSPARENT, 0x00000020
WS_EX_MDICHILD, 0x00000040
WS_EX_TOOLWINDOW, 0x00000080
WS_EX_WINDOWEDGE, 0x00000100
WS_EX_CLIENTEDGE, 0x00000200
WS_EX_CONTEXTHELP, 0x00000400
WS_EX_RIGHT, 0x00001000, 0x00001000
WS_EX_LEFT, 0x00000000, 0x00001000
WS_EX_RTLREADING, 0x00002000, 0x00002000
WS_EX_LTRREADING, 0x00000000, 0x00002000
WS_EX_LEFTSCROLLBAR, 0x00004000, 0x00004000
WS_EX_RIGHTSCROLLBAR, 0x00000000, 0x00004000
WS_EX_CONTROLPARENT, 0x00010000
WS_EX_STATICEDGE, 0x00020000
WS_EX_APPWINDOW, 0x00040000
WS_EX_LAYERED, 0x00080000
WS_EX_NOINHERITLAYOUT, 0x00100000
WS_EX_NOREDIRECTIONBITMAP, 0x00200000
WS_EX_LAYOUTRTL, 0x00400000
WS_EX_COMPOSITED, 0x02000000
WS_EX_NOACTIVATE, 0x08000000
WS_EX_OVERLAPPEDWINDOW, WS_EX_WINDOWEDGE | WS_EX_CLIENTEDGE
WS_EX_PALETTEWINDOW, WS_EX_WINDOWEDGE | WS_EX_TOOLWINDOW | WS_EX_TOPMOST

[DIALOG]
DS_ABSALIGN, 0x01
DS_SYSMODAL, 0x02
DS_LOCALEDIT, 0x20
DS_SETFONT, 0x40
DS_MODALFRAME, 0x80
DS_NOIDLEMSG, 0x100
DS_SETFOREGROUND, 0x200
DS_3DLOOK, 0x0004
DS_FIXEDSYS, 0x0008
DS_NOFAILCREATE, 0x0010
DS_CONTROL, 0x0400
DS_CENTER, 0x0800
DS_CENTERMOUSE, 0x1000
DS_CONTEXTHELP, 0x2000
DS_USEPIXELS, 0x8000
DS_SHELLFONT, DS_SETFONT | DS_FIXEDSYS

[BUTTON]
BS_PUSHBUTTON, 0x00000000, 0x0000000F
BS_DEFPUSHBUTTON, 0x00000001, 0x0000000F
BS_CHECKBOX, 0x00000002, 0x0000000F
BS_AUTOCHECKBOX, 0x00000003, 0x0000000F
BS_RADIOBUTTON, 0x00000004, 0x0000000F
BS_3STATE, 0x00000005, 0x0000000F
BS_AUTO3STATE, 0x00000006, 0x0000000F
BS_GROUPBOX, 0x00000007, 0x0000000F
BS_USERBUTTON, 0x00000008, 0x0000000F
BS_AUTORADIOBUTTON, 0x00000009, 0x0000000F
BS_PUSHBOX, 0x0000000A, 0x0000000F
BS_OWNERDRAW, 0x0000000B, 0x0000000F
BS_SPLITBUTTON, 0x0000000C, 0x0000000F
BS_DEFSPLITBUTTON, 0x0000000D, 0x0000000F
BS_COMMANDLINK, 0x0000000E, 0x0000000F
BS_DEFCOMMANDLINK, 0x0000000F, 0x0000000F
BS_LEFTTEXT, 0x00000020
BS_ICON, 0x00000040
BS_BITMAP, 0x00000080
BS_LEFT, 0x00000100
BS_RIGHT, 0x00000200
BS_CENTER, 0x00000300
BS_TOP, 0x00000400
BS_BOTTOM, 0x00000800
BS_VCENTER, 0x00000C00
BS_PUSHLIKE, 0x00001000
BS_MULTILINE, 0x00002000
BS_NOTIFY, 0x00004000
BS_FLAT, 0x00008000
BS_RIGHTBUTTON, BS_LEFTTEXT

[COMBOBOX]
CBS_SIMPLE, 0x0001, 0x0003
CBS_DROPDOWN, 0x0002, 0x0003
CBS_DROPDOWNLIST, 0x0003, 0x0003
CBS_OWNERDRAWFIXED, 0x0010, 0x0030
CBS_OWNERDRAWVARIABLE, 0x0020, 0x0030
CBS_AUTOHSCROLL, 0x0040
CBS_OEMCONVERT, 0x0080
CBS_SORT, 0x0100
CBS_HASSTRINGS, 0x0200
CBS_NOINTEGRALHEIGHT, 0x0400
CBS_DISABLENOSCROLL, 0x0800
CBS_UPPERCASE, 0x2000
CBS_LOWERCASE, 0x4000

[ComboBoxEx32]
CBS_SIMPLE, 0x0001, 0x0003
CBS_DROPDOWN, 0x0002, 0x0003
CBS_DROPDOWNLIST, 0x0003, 0x0003
CBS_OWNERDRAWFIXED, 0x0010, 0x0030
CBS_OWNERDRAWVARIABLE, 0x0020, 0x0030
CBS_AUTOHSCROLL, 0x0040
CBS_OEMCONVERT, 0x0080
CBS_SORT, 0x0100
CBS_HASSTRINGS, 0x0200
CBS_NOINTEGRALHEIGHT, 0x0400
CBS_DISABLENOSCROLL, 0x0800
CBS_UPPERCASE, 0x2000
CBS_LOWERCASE, 0x4000

[EDIT]
ES_LEFT, 0x0000, 0x0003
ES_CENTER, 0x0001, 0x0003
ES_RIGHT, 0x0002, 0x0003
ES_MULTILINE, 0x0004
ES_UPPERCASE, 0x0008, 0x0018
ES_LOWERCASE, 0x0010, 0x0018
ES_PASSWORD, 0x0020
ES_AUTOVSCROLL, 0x0040
ES_AUTOHSCROLL, 0x0080
ES_NOHIDESEL, 0x0100
ES_OEMCONVERT, 0x0400
ES_READONLY, 0x0800
ES_WANTRETURN, 0x1000
ES_NUMBER, 0x2000

[LISTBOX]
LBS_NOTIFY, 0x0001
LBS_SORT, 0x0002
LBS_NOREDRAW, 0x0004
LBS_MULTIPLESEL, 0x0008
LBS_OWNERDRAWFIXED, 0x0010, 0x0030
LBS_OWNERDRAWVARIABLE, 0x0020, 0x0030
LBS_HASSTRINGS, 0x0040
LBS_USETABSTOPS, 0x0080
LBS_NOINTEGRALHEIGHT, 0x0100
LBS_MULTICOLUMN, 0x0200
LBS_WANTKEYBOARDINPUT, 0x0400
LBS_EXTENDEDSEL, 0x0800
LBS_DISABLENOSCROLL, 0x1000
LBS_NODATA, 0x2000
LBS_NOSEL, 0x4000
LBS_COMBOBOX, 0x8000
LBS_STANDARD, LBS_NOTIFY | LBS_SORT | WS_VSCROLL | WS_BORDER

[SCROLLBAR]
SBS_HORZ, 0x0000, 0x0001
SBS_VERT, 0x0001, 0x0001
SBS_TOPALIGN, 0x0002
SBS_LEFTALIGN, 0x0002
SBS_BOTTOMALIGN, 0x0004
SBS_RIGHTALIGN, 0x0004
SBS_SIZEBOXTOPLEFTALIGN, 0x0002, 0x0006
SBS_SIZEBOXBOTTOMRIGHTALIGN, 0x0004, 0x0006
SBS_SIZEBOX, 0x0008
SBS_SIZEGRIP, 0x0010

[STATIC]
SS_LEFT, 0x00000000, 0x0000001F
SS_CENTER, 0x00000001, 0x0000001F
SS_RIGHT, 0x00000002, 0x0000001F
SS_ICON, 0x00000003, 0x0000001F
SS_BLACKRECT, 0x00000004, 0x0000001F
SS_GRAYRECT, 0x00000005, 0x0000001F
SS_WHITERECT, 0x00000006, 0x0000001F
SS_BLACKFRAME, 0x00000007, 0x0000001F
SS_GRAYFRAME, 0x00000008, 0x0000001F
SS_WHITEFRAME, 0x00000009, 0x0000001F
SS_USERITEM, 0x0000000A, 0x0000001F
SS_SIMPLE, 0x0000000B, 0x0000001F
SS_LEFTNOWORDWRAP, 0x0000000C, 0x0000001F
SS_OWNERDRAW, 0x0000000D, 0x0000001F
SS_BITMAP, 0x0000000E, 0x0000001F
SS_ENHMETAFILE, 0x0000000F, 0x0000001F
SS_ETCHEDHORZ, 0x00000010, 0x0000001F
SS_ETCHEDVERT, 0x00000011, 0x0000001F
SS_ETCHEDFRAME, 0x00000012, 0x0000001F
SS_REALSIZECONTROL, 0x00000040
SS_NOPREFIX, 0x00000080
SS_NOTIFY, 0x00000100
SS_CENTERIMAGE, 0x00000200
SS_RIGHTJUST, 0x00000400
SS_REALSIZEIMAGE, 0x00000800
SS_SUNKEN, 0x00001000
SS_EDITCONTROL, 0x00002000
SS_ENDELLIPSIS, 0x00004000
SS_PATHELLIPSIS, 0x00008000
SS_WORDELLIPSIS, 0x0000C000
SS_ELLIPSISMASK, 0x0000C000

[SysHeader32]
HDS_HORZ, 0x0
HDS_BUTTONS, 0x2
HDS_HOTTRACK, 0x4
HDS_HIDDEN, 0x8
HDS_DRAGDROP, 0x40
HDS_FULLDRAG, 0x80
HDS_FILTERBAR, 0x100
HDS_FLAT, 0x200
HDS_CHECKBOXES, 0x400
HDS_NOSIZING, 0x800
HDS_OVERFLOW, 0x1000

[ToolbarWindow32]
CCS_TOP, 0x1, 0x3
CCS_NOMOVEY, 0x2, 0x3
CCS_BOTTOM, 0x3, 0x3
CCS_NORESIZE, 0x4
CCS_NOPARENTALIGN, 0x8
CCS_ADJUSTABLE, 0x20
CCS_NODIVIDER, 0x40
CCS_VERT, 0x80
CCS_LEFT, CCS_VERT | CCS_TOP, 0x83
CCS_RIGHT, CCS_VERT | CCS_BOTTOM, 0x83
CCS_NOMOVEX, CCS_VERT | CCS_NOMOVEY, 0x83
TBSTYLE_TOOLTIPS, 0x0100
TBSTYLE_WRAPABLE, 0x0200
TBSTYLE_ALTDRAG, 0x0400
TBSTYLE_FLAT, 0x0800
TBSTYLE_LIST, 0x1000
TBSTYLE_CUSTOMERASE, 0x2000
TBSTYLE_REGISTERDROP, 0x4000
TBSTYLE_TRANSPARENT, 0x8000

[ReBarWindow32]
CCS_TOP, 0x1, 0x3
CCS_NOMOVEY, 0x2, 0x3
CCS_BOTTOM, 0x3, 0x3
CCS_NORESIZE, 0x4
CCS_NOPARENTALIGN, 0x8
CCS_ADJUSTABLE, 0x20
CCS_NODIVIDER, 0x40
CCS_VERT, 0x80
CCS_LEFT, CCS_VERT | CCS_TOP, 0x83
CCS_RIGHT, CCS_VERT | CCS_BOTTOM, 0x83
CCS_NOMOVEX, CCS_VERT | CCS_NOMOVEY, 0x83
RBS_TOOLTIPS, 0x100
RBS_VARHEIGHT, 0x200
RBS_BANDBORDERS, 0x400
RBS_FIXEDORDER, 0x800
RBS_REGISTERDROP, 0x1000
RBS_AUTOSIZE, 0x2000
RBS_VERTICALGRIPPER, 0x4000
RBS_DBLCLKTOGGLE, 0x8000

[msctls_statusbar32]
CCS_TOP, 0x1, 0x3
CCS_NOMOVEY, 0x2, 0x3
CCS_BOTTOM, 0x3, 0x3
CCS_NORESIZE, 0x4
CCS_NOPARENTALIGN, 0x8
CCS_ADJUSTABLE, 0x20
CCS_NODIVIDER, 0x40
CCS_VERT, 0x80
CCS_LEFT, CCS_VERT | CCS_TOP, 0x83
CCS_RIGHT, CCS_VERT | CCS_BOTTOM, 0x83
CCS_NOMOVEX, CCS_VERT | CCS_NOMOVEY, 0x83
SBARS_SIZEGRIP, 0x100
SBARS_TOOLTIPS, 0x800

[tooltips_class32]
TTS_ALWAYSTIP, 0x1
TTS_NOPREFIX, 0x2
TTS_NOANIMATE, 0x10
TTS_NOFADE, 0x20
TTS_BALLOON, 0x40
TTS_CLOSE, 0x80
TTS_USEVISUALSTYLE, 0x100

[msctls_trackbar32]
TBS_AUTOTICKS, 0x1
TBS_VERT, 0x2, 0x2
TBS_HORZ, 0x0, 0x2
TBS_TOP, 0x4, 0xC
TBS_BOTTOM, 0x0, 0xC
TBS_LEFT, 0x4, 0xC
TBS_RIGHT, 0x0, 0xC
TBS_BOTH, 0x8, 0xC
TBS_NOTICKS, 0x10
TBS_ENABLESELRANGE, 0x20
TBS_FIXEDLENGTH, 0x40
TBS_NOTHUMB, 0x80
TBS_TOOLTIPS, 0x100
TBS_REVERSED, 0x200
TBS_DOWNISLEFT, 0x400
TBS_NOTIFYBEFOREMOVE, 0x800
TBS_TRANSPARENTBKGND, 0x1000

[commctrl_DragListMsg]
DL_CURSORSET, 0, 3
DL_STOPCURSOR, 1, 3
DL_COPYCURSOR, 2, 3
DL_MOVECURSOR, 3, 3

[msctls_updown32]
UDS_WRAP, 0x1
UDS_SETBUDDYINT, 0x2
UDS_ALIGNRIGHT, 0x4
UDS_ALIGNLEFT, 0x8
UDS_AUTOBUDDY, 0x10
UDS_ARROWKEYS, 0x20
UDS_HORZ, 0x40
UDS_NOTHOUSANDS, 0x80
UDS_HOTTRACK, 0x100

[msctls_progress32]
PBS_SMOOTH, 0x1
PBS_VERTICAL, 0x4
PBS_MARQUEE, 0x8
PBS_SMOOTHREVERSE, 0x10

[msctls_hotkey32]

[SysListView32]
LVS_ICON, 0x0, 0x3
LVS_REPORT, 0x1, 0x3
LVS_SMALLICON, 0x2, 0x3
LVS_LIST, 0x3, 0x3
LVS_SINGLESEL, 0x4
LVS_SHOWSELALWAYS, 0x8
LVS_SORTASCENDING, 0x10
LVS_SORTDESCENDING, 0x20
LVS_SHAREIMAGELISTS, 0x40
LVS_NOLABELWRAP, 0x80
LVS_AUTOARRANGE, 0x100
LVS_EDITLABELS, 0x200
LVS_OWNERDATA, 0x1000
LVS_NOSCROLL, 0x2000
LVS_ALIGNTOP, 0x0, 0x800
LVS_ALIGNLEFT, 0x800, 0x800
LVS_OWNERDRAWFIXED, 0x400
LVS_NOCOLUMNHEADER, 0x4000
LVS_NOSORTHEADER, 0x8000

[SysTreeView32]
TVS_HASBUTTONS, 0x1
TVS_HASLINES, 0x2
TVS_LINESATROOT, 0x4
TVS_EDITLABELS, 0x8
TVS_DISABLEDRAGDROP, 0x10
TVS_SHOWSELALWAYS, 0x20
TVS_RTLREADING, 0x40
TVS_NOTOOLTIPS, 0x80
TVS_CHECKBOXES, 0x100
TVS_TRACKSELECT, 0x200
TVS_SINGLEEXPAND, 0x400
TVS_INFOTIP, 0x800
TVS_FULLROWSELECT, 0x1000
TVS_NOSCROLL, 0x2000
TVS_NONEVENHEIGHT, 0x4000
TVS_NOHSCROLL, 0x8000

[SysTabControl32]
TCS_SCROLLOPPOSITE, 0x1
TCS_BOTTOM, 0x2
TCS_RIGHT, 0x2
TCS_MULTISELECT, 0x4
TCS_FLATBUTTONS, 0x8
TCS_FORCEICONLEFT, 0x10
TCS_FORCELABELLEFT, 0x20
TCS_HOTTRACK, 0x40
TCS_VERTICAL, 0x80
TCS_TABS, 0x0
TCS_BUTTONS, 0x100
TCS_SINGLELINE, 0x0
TCS_MULTILINE, 0x200
TCS_RIGHTJUSTIFY, 0x0
TCS_FIXEDWIDTH, 0x400
TCS_RAGGEDRIGHT, 0x800
TCS_FOCUSONBUTTONDOWN, 0x1000
TCS_OWNERDRAWFIXED, 0x2000
TCS_TOOLTIPS, 0x4000
TCS_FOCUSNEVER, 0x8000

[SysAnimate32]
ACS_CENTER, 0x1
ACS_TRANSPARENT, 0x2
ACS_AUTOPLAY, 0x4
ACS_TIMER, 0x8

[SysMonthCal32]
MCS_DAYSTATE, 0x1
MCS_MULTISELECT, 0x2
MCS_WEEKNUMBERS, 0x4
MCS_NOTODAYCIRCLE, 0x8
MCS_NOTODAY, 0x10
MCS_NOTRAILINGDATES, 0x40
MCS_SHORTDAYSOFWEEK, 0x80
MCS_NOSELCHANGEONNAV, 0x100

[SysDateTimePick32]
DTS_UPDOWN, 0x1
DTS_SHOWNONE, 0x2
DTS_SHORTDATEFORMAT, 0x0
DTS_LONGDATEFORMAT, 0x4
DTS_SHORTDATECENTURYFORMAT, 0xc
DTS_TIMEFORMAT, 0x9
DTS_APPCANPARSE, 0x10
DTS_RIGHTALIGN, 0x20

[SysIPAddress32]

[SysLink]
LWS_TRANSPARENT, 0x1
LWS_IGNORERETURN, 0x2
LWS_NOPREFIX, 0x4
LWS_USEVISUALSTYLE, 0x8
LWS_USECUSTOMTEXT, 0x10
LWS_RIGHT, 0x20

[SysPager]
PGS_VERT, 0x0
PGS_HORZ, 0x1
PGS_AUTOSCROLL, 0x2
PGS_DRAGNDROP, 0x4

[NativeFontCtl]
NFS_EDIT, 0x1
NFS_STATIC, 0x2
NFS_LISTCOMBO, 0x4
NFS_BUTTON, 0x8
NFS_ALL, 0x10
NFS_USEFONTASSOC, 0x20

[AtlAxWin]

[CTRLID]
IDOK, 1
IDCANCEL, 2
IDABORT, 3
IDRETRY, 4
IDIGNORE, 5
IDYES, 6
IDNO, 7
IDCLOSE, 8
IDHELP, 9
IDTRYAGAIN, 10
IDCONTINUE, 11
psh1, 0x0400
psh2, 0x0401
psh3, 0x0402
psh4, 0x0403
psh5, 0x0404
psh6, 0x0405
psh7, 0x0406
psh8, 0x0407
psh9, 0x0408
psh10, 0x0409
psh11, 0x040a
psh12, 0x040b
psh13, 0x040c
psh14, 0x040d
psh15, 0x040e
pshHelp, psh15
psh16, 0x040f
chx1, 0x0410
chx2, 0x0411
chx3, 0x0412
chx4, 0x0413
chx5, 0x0414
chx6, 0x0415
chx7, 0x0416
chx8, 0x0417
chx9, 0x0418
chx10, 0x0419
chx11, 0x041a
chx12, 0x041b
chx13, 0x041c
chx14, 0x041d
chx15, 0x041e
chx16, 0x041f
rad1, 0x0420
rad2, 0x0421
rad3, 0x0422
rad4, 0x0423
rad5, 0x0424
rad6, 0x0425
rad7, 0x0426
rad8, 0x0427
rad9, 0x0428
rad10, 0x0429
rad11, 0x042a
rad12, 0x042b
rad13, 0x042c
rad14, 0x042d
rad15, 0x042e
rad16, 0x042f
grp1, 0x0430
grp2, 0x0431
grp3, 0x0432
grp4, 0x0433
frm1, 0x0434
frm2, 0x0435
frm3, 0x0436
frm4, 0x0437
rct1, 0x0438
rct2, 0x0439
rct3, 0x043a
rct4, 0x043b
ico1, 0x043c
ico2, 0x043d
ico3, 0x043e
ico4, 0x043f
stc1, 0x0440
stc2, 0x0441
stc3, 0x0442
stc4, 0x0443
stc5, 0x0444
stc6, 0x0445
stc7, 0x0446
stc8, 0x0447
stc9, 0x0448
stc10, 0x0449
stc11, 0x044a
stc12, 0x044b
stc13, 0x044c
stc14, 0x044d
stc15, 0x044e
stc16, 0x044f
stc17, 0x0450
stc18, 0x0451
stc19, 0x0452
stc20, 0x0453
stc21, 0x0454
stc22, 0x0455
stc23, 0x0456
stc24, 0x0457
stc25, 0x0458
stc26, 0x0459
stc27, 0x045a
stc28, 0x045b
stc29, 0x045c
stc30, 0x045d
stc31, 0x045e
stc32, 0x045f
lst1, 0x0460
lst2, 0x0461
lst3, 0x0462
lst4, 0x0463
lst5, 0x0464
lst6, 0x0465
lst7, 0x0466
lst8, 0x0467
lst9, 0x0468
lst10, 0x0469
lst11, 0x046a
lst12, 0x046b
lst13, 0x046c
lst14, 0x046d
lst15, 0x046e
lst16, 0x046f
cmb1, 0x0470
cmb2, 0x0471
cmb3, 0x0472
cmb4, 0x0473
cmb5, 0x0474
cmb6, 0x0475
cmb7, 0x0476
cmb8, 0x0477
cmb9, 0x0478
cmb10, 0x0479
cmb11, 0x047a
cmb12, 0x047b
cmb13, 0x047c
cmb14, 0x047d
cmb15, 0x047e
cmb16, 0x047f
edt1, 0x0480
edt2, 0x0481
edt3, 0x0482
edt4, 0x0483
edt5, 0x0484
edt6, 0x0485
edt7, 0x0486
edt8, 0x0487
edt9, 0x0488
edt10, 0x0489
edt11, 0x048a
edt12, 0x048b
edt13, 0x048c
edt14, 0x048d
edt15, 0x048e
edt16, 0x048f
scr1, 0x0490
scr2, 0x0491
scr3, 0x0492
scr4, 0x0493
scr5, 0x0494
scr6, 0x0495
scr7, 0x0496
scr8, 0x0497
ctl1, 0x04A0

[FontWeight]
FW_DONTCARE, 0
FW_THIN, 100
FW_EXTRALIGHT, 200
FW_LIGHT, 300
FW_NORMAL, 400
FW_MEDIUM, 500
FW_SEMIBOLD, 600
FW_BOLD, 700
FW_EXTRABOLD, 800
FW_HEAVY, 900
FW_ULTRALIGHT, FW_EXTRALIGHT
FW_REGULAR, FW_NORMAL
FW_DEMIBOLD, FW_SEMIBOLD
FW_ULTRABOLD, FW_EXTRABOLD
FW_BLACK, FW_HEAVY

[FontItalic]
FALSE, 0
TRUE, 1

[FontCharSet]
ANSI_CHARSET, 0
DEFAULT_CHARSET, 1
SYMBOL_CHARSET, 2
SHIFTJIS_CHARSET, 128
HANGEUL_CHARSET, 129
HANGUL_CHARSET, 129
GB2312_CHARSET, 134
CHINESEBIG5_CHARSET, 136
OEM_CHARSET, 255
JOHAB_CHARSET, 130
HEBREW_CHARSET, 177
ARABIC_CHARSET, 178
GREEK_CHARSET, 161
TURKISH_CHARSET, 162
VIETNAMESE_CHARSET, 163
THAI_CHARSET, 222
EASTEUROPE_CHARSET, 238
RUSSIAN_CHARSET, 204
MAC_CHARSET, 77
BALTIC_CHARSET, 186

[MFT_]
MFT_STRING, 0x00000000
MFT_BITMAP, 0x00000004
MFT_MENUBARBREAK, 0x00000020
MFT_MENUBREAK, 0x00000040
MFT_OWNERDRAW, 0x00000100
MFT_RADIOCHECK, 0x00000200
MFT_SEPARATOR, 0x00000800
MFT_RIGHTORDER, 0x00002000
MFT_RIGHTJUSTIFY, 0x00004000

[MFS_]
MFS_GRAYED, 0x00000003
MFS_DISABLED, 0x00000003
MFS_CHECKED, 0x00000008
MFS_HILITE, 0x00000080
MFS_ENABLED, 0x00000000
MFS_UNCHECKED, 0x00000000
MFS_UNHILITE, 0x00000000
MFS_DEFAULT, 0x00001000

[VIRTUALKEYS]
"A", 0x41
"B", 0x42
"C", 0x43
"D", 0x44
"E", 0x45
"F", 0x46
"G", 0x47
"H", 0x48
"I", 0x49
"J", 0x4A
"K", 0x4B
"L", 0x4C
"M", 0x4D
"N", 0x4E
"O", 0x4F
"P", 0x50
"Q", 0x51
"R", 0x52
"S", 0x53
"T", 0x54
"U", 0x55
"V", 0x56
"W", 0x57
"X", 0x58
"Y", 0x59
"Z", 0x5A
"0", 0x30
"1", 0x31
"2", 0x32
"3", 0x33
"4", 0x34
"5", 0x35
"6", 0x36
"7", 0x37
"8", 0x38
"9", 0x39
VK_LBUTTON, 0x01
VK_RBUTTON, 0x02
VK_CANCEL, 0x03
VK_MBUTTON, 0x04
VK_XBUTTON1, 0x05
VK_XBUTTON2, 0x06
VK_BACK, 0x08
VK_TAB, 0x09
VK_CLEAR, 0x0C
VK_RETURN, 0x0D
VK_SHIFT, 0x10
VK_CONTROL, 0x11
VK_MENU, 0x12
VK_PAUSE, 0x13
VK_CAPITAL, 0x14
VK_KANA, 0x15
VK_HANGEUL, 0x15
VK_HANGUL, 0x15
VK_JUNJA, 0x17
VK_FINAL, 0x18
VK_HANJA, 0x19
VK_KANJI, 0x19
VK_ESCAPE, 0x1B
VK_CONVERT, 0x1C
VK_NONCONVERT, 0x1D
VK_ACCEPT, 0x1E
VK_MODECHANGE, 0x1F
VK_SPACE, 0x20
VK_PRIOR, 0x21
VK_NEXT, 0x22
VK_END, 0x23
VK_HOME, 0x24
VK_LEFT, 0x25
VK_UP, 0x26
VK_RIGHT, 0x27
VK_DOWN, 0x28
VK_SELECT, 0x29
VK_PRINT, 0x2A
VK_EXECUTE, 0x2B
VK_SNAPSHOT, 0x2C
VK_INSERT, 0x2D
VK_DELETE, 0x2E
VK_HELP, 0x2F
VK_LWIN, 0x5B
VK_RWIN, 0x5C
VK_APPS, 0x5D
VK_SLEEP, 0x5F
VK_NUMPAD0, 0x60
VK_NUMPAD1, 0x61
VK_NUMPAD2, 0x62
VK_NUMPAD3, 0x63
VK_NUMPAD4, 0x64
VK_NUMPAD5, 0x65
VK_NUMPAD6, 0x66
VK_NUMPAD7, 0x67
VK_NUMPAD8, 0x68
VK_NUMPAD9, 0x69
VK_MULTIPLY, 0x6A
VK_ADD, 0x6B
VK_SEPARATOR, 0x6C
VK_SUBTRACT, 0x6D
VK_DECIMAL, 0x6E
VK_DIVIDE, 0x6F
VK_F1, 0x70
VK_F2, 0x71
VK_F3, 0x72
VK_F4, 0x73
VK_F5, 0x74
VK_F6, 0x75
VK_F7, 0x76
VK_F8, 0x77
VK_F9, 0x78
VK_F10, 0x79
VK_F11, 0x7A
VK_F12, 0x7B
VK_F13, 0x7C
VK_F14, 0x7D
VK_F15, 0x7E
VK_F16, 0x7F
VK_F17, 0x80
VK_F18, 0x81
VK_F19, 0x82
VK_F20, 0x83
VK_F21, 0x84
VK_F22, 0x85
VK_F23, 0x86
VK_F24, 0x87
VK_NUMLOCK, 0x90
VK_SCROLL, 0x91
VK_OEM_NEC_EQUAL, 0x92
VK_OEM_FJ_JISHO, 0x92
VK_OEM_FJ_MASSHOU, 0x93
VK_OEM_FJ_TOUROKU, 0x94
VK_OEM_FJ_LOYA, 0x95
VK_OEM_FJ_ROYA, 0x96
VK_LSHIFT, 0xA0
VK_RSHIFT, 0xA1
VK_LCONTROL, 0xA2
VK_RCONTROL, 0xA3
VK_LMENU, 0xA4
VK_RMENU, 0xA5
VK_BROWSER_BACK, 0xA6
VK_BROWSER_FORWARD, 0xA7
VK_BROWSER_REFRESH, 0xA8
VK_BROWSER_STOP, 0xA9
VK_BROWSER_SEARCH, 0xAA
VK_BROWSER_FAVORITES, 0xAB
VK_BROWSER_HOME, 0xAC
VK_VOLUME_MUTE, 0xAD
VK_VOLUME_DOWN, 0xAE
VK_VOLUME_UP, 0xAF
VK_MEDIA_NEXT_TRACK, 0xB0
VK_MEDIA_PREV_TRACK, 0xB1
VK_MEDIA_STOP, 0xB2
VK_MEDIA_PLAY_PAUSE, 0xB3
VK_LAUNCH_MAIL, 0xB4
VK_LAUNCH_MEDIA_SELECT, 0xB5
VK_LAUNCH_APP1, 0xB6
VK_LAUNCH_APP2, 0xB7
VK_OEM_1, 0xBA
VK_OEM_PLUS, 0xBB
VK_OEM_COMMA, 0xBC
VK_OEM_MINUS, 0xBD
VK_OEM_PERIOD, 0xBE
VK_OEM_2, 0xBF
VK_OEM_3, 0xC0
VK_OEM_4, 0xDB
VK_OEM_5, 0xDC
VK_OEM_6, 0xDD
VK_OEM_7, 0xDE
VK_OEM_8, 0xDF
VK_OEM_AX, 0xE1
VK_OEM_102, 0xE2
VK_ICO_HELP, 0xE3
VK_ICO_00, 0xE4
VK_PROCESSKEY, 0xE5
VK_ICO_CLEAR, 0xE6
VK_PACKET, 0xE7
VK_OEM_RESET, 0xE9
VK_OEM_JUMP, 0xEA
VK_OEM_PA1, 0xEB
VK_OEM_PA2, 0xEC
VK_OEM_PA3, 0xED
VK_OEM_WSCTRL, 0xEE
VK_OEM_CUSEL, 0xEF
VK_OEM_ATTN, 0xF0
VK_OEM_FINISH, 0xF1
VK_OEM_COPY, 0xF2
VK_OEM_AUTO, 0xF3
VK_OEM_ENLW, 0xF4
VK_OEM_BACKTAB, 0xF5
VK_ATTN, 0xF6
VK_CRSEL, 0xF7
VK_EXSEL, 0xF8
VK_EREOF, 0xF9
VK_PLAY, 0xFA
VK_ZOOM, 0xFB
VK_NONAME, 0xFC
VK_PA1, 0xFD
VK_OEM_CLEAR, 0xFE

[CONTROL.CLASSES]
BUTTON, 1
COMBOBOX, 1
EDIT, 1
LISTBOX, 1
SCROLLBAR, 1
STATIC, 1
ComboBoxEx32, 2
NativeFontCtl, 2
ReBarWindow32, 2
SysAnimate32, 2
SysDateTimePick32, 2
SysHeader32, 2
SysIPAddress32, 2
SysLink, 2
SysListView32, 2
SysMonthCal32, 2
SysPager, 2
SysTabControl32, 2
SysTreeView32, 2
ToolbarWindow32, 2
msctls_hotkey32, 2
msctls_progress32, 2
msctls_statusbar32, 2
msctls_trackbar32, 2
msctls_updown32, 2
tooltips_class32, 2
AtlAxWin, 2
AtlAxWin71, 2
AtlAxWin80, 2
AtlAxWin90, 2
AtlAxWin100, 2
AtlAxWin110, 2
AtlAxWin140, 2
AUTO3STATE, 3
AUTOCHECKBOX, 3
AUTORADIOBUTTON, 3
CHECKBOX, 3
CTEXT, 3
DEFPUSHBUTTON, 3
EDITTEXT, 3
GROUPBOX, 3
ICON, 3
LTEXT, 3
PUSHBUTTON, 3
RADIOBUTTON, 3
RTEXT, 3
STATE3, 3
MEMO, 4
SplitButton, 4
BITMAP, 4
RICHEDIT, 4

[AUTO3STATE.SUPERCLASS]
BUTTON, 0

[AUTOCHECKBOX.SUPERCLASS]
BUTTON, 0

[AUTORADIOBUTTON.SUPERCLASS]
BUTTON, 0

[CHECKBOX.SUPERCLASS]
BUTTON, 0

[CTEXT.SUPERCLASS]
STATIC, 0

[DEFPUSHBUTTON.SUPERCLASS]
BUTTON, 0

[EDITTEXT.SUPERCLASS]
EDIT, 0

[GROUPBOX.SUPERCLASS]
BUTTON, 0

[ICON.SUPERCLASS]
STATIC, 0

[LTEXT.SUPERCLASS]
STATIC, 0

[PUSHBUTTON.SUPERCLASS]
BUTTON, 0

[RADIOBUTTON.SUPERCLASS]
BUTTON, 0

[RTEXT.SUPERCLASS]
STATIC, 0

[STATE3.SUPERCLASS]
BUTTON, 0

[MEMO.SUPERCLASS]
EDIT, 0

[SplitButton.SUPERCLASS]
BUTTON, 0

[BITMAP.SUPERCLASS]
STATIC, 0

[RICHEDIT.SUPERCLASS]
RichEdit20A, 0

[CONTROL.DEFAULT.STYLE]
STYLE, 0x50000000

[ComboBoxEx32.DEFAULT.STYLE]
STYLE, 0x50210242

[AUTO3STATE.DEFAULT.STYLE]
STYLE, 0x50010006

[AUTOCHECKBOX.DEFAULT.STYLE]
STYLE, 0x50010003

[AUTORADIOBUTTON.DEFAULT.STYLE]
STYLE, 0x50010009

[CHECKBOX.DEFAULT.STYLE]
STYLE, 0x50010002

[COMBOBOX.DEFAULT.STYLE]
STYLE, 0x50210242

[CTEXT.DEFAULT.STYLE]
STYLE, 0x50020001

[DEFPUSHBUTTON.DEFAULT.STYLE]
STYLE, 0x50010001

[EDIT.DEFAULT.STYLE]
STYLE, 0x50810000

[EDITTEXT.DEFAULT.STYLE]
STYLE, 0x50810000

[GROUPBOX.DEFAULT.STYLE]
STYLE, 0x50000007

[ICON.DEFAULT.STYLE]
STYLE, 0x50000003

[LISTBOX.DEFAULT.STYLE]
STYLE, 0x50A10141

[LTEXT.DEFAULT.STYLE]
STYLE, 0x50020000

[MEMO.DEFAULT.STYLE]
STYLE, 0x50B10004

[SplitButton.DEFAULT.STYLE]
STYLE, 0x5001000c

[BITMAP.DEFAULT.STYLE]
STYLE, 0x5002000E

[RichEdit20A.DEFAULT.STYLE]
STYLE, 0x50B110C4

[BUTTON.DEFAULT.STYLE]
STYLE, 0x50010000

[PUSHBUTTON.DEFAULT.STYLE]
STYLE, 0x50010000

[RADIOBUTTON.DEFAULT.STYLE]
STYLE, 0x50010004

[RICHEDIT.DEFAULT.STYLE]
STYLE, 0x50B10004

[RTEXT.DEFAULT.STYLE]
STYLE, 0x50020002

[SCROLLBAR.DEFAULT.STYLE]
STYLE, 0x50000000

[STATE3.DEFAULT.STYLE]
STYLE, 0x50010005

[STATIC.DEFAULT.STYLE]
STYLE, 0x50020000

[SysIPAddress32.DEFAULT.STYLE]
STYLE, 0x50010000

[AtlAxWin.DEFAULT.STYLE]
STYLE, 0x50010000
[AtlAxWin71.DEFAULT.STYLE]
STYLE, 0x50010000
[AtlAxWin80.DEFAULT.STYLE]
STYLE, 0x50010000
[AtlAxWin90.DEFAULT.STYLE]
STYLE, 0x50010000
[AtlAxWin100.DEFAULT.STYLE]
STYLE, 0x50010000
[AtlAxWin110.DEFAULT.STYLE]
STYLE, 0x50010000
[AtlAxWin140.DEFAULT.STYLE]
STYLE, 0x50010000

[SysLink.DEFAULT.STYLE]
STYLE, 0x50000000

[SysListView32.DEFAULT.STYLE]
STYLE, 0x50800000

[SysTreeView32.DEFAULT.STYLE]
STYLE, 0x50810000

[msctls_trackbar32.DEFAULT.STYLE]
STYLE, 0x50010000

[msctls_progress32.DEFAULT.STYLE]
STYLE, 0x50000000

[SysMonthCal32.DEFAULT.STYLE]
STYLE, 0x50000000

[msctls_updown32.DEFAULT.STYLE]
STYLE, 0x50000000

[msctls_statusbar32.DEFAULT.STYLE]
STYLE, 0x50000100

[SysAnimate32.DEFAULT.STYLE]
STYLE, 0x50000000

[SysDateTimePick32.DEFAULT.STYLE]
STYLE, 0x50000000

[msctls_hotkey32.DEFAULT.STYLE]
STYLE, 0x50000000

[SysTabControl32.DEFAULT.STYLE]
STYLE, 0x50000800

[BUTTON.SUBCLASSES]
AUTO3STATE, 0
AUTOCHECKBOX, 1
AUTORADIOBUTTON, 2
CHECKBOX, 3
DEFPUSHBUTTON, 4
GROUPBOX, 5
PUSHBOX, 6
PUSHBUTTON, 7
RADIOBUTTON, 8
STATE3, 9
SplitButton, 10

[STATIC.SUBCLASSES]
LTEXT, 0
CTEXT, 1
RTEXT, 2
ICON, 3
BITMAP, 4

[EDIT.SUBCLASSES]
EDITTEXT, 0
MEMO, 1

[CONTROL.SIZE]
WIDTH, 60
HEIGHT, 60

[BUTTON.SIZE]
WIDTH, 60
HEIGHT, 14

[EDIT.SIZE]
WIDTH, 60
HEIGHT, 14

[ICON.SIZE]
WIDTH, 20
HEIGHT, 20

[SCROLLBAR.SIZE]
WIDTH, 30
HEIGHT, 14

[STATIC.SIZE]
WIDTH, 32
HEIGHT, 32

[LTEXT.SIZE]
WIDTH, 60
HEIGHT, 14

[CTEXT.SIZE]
WIDTH, 60
HEIGHT, 14

[RTEXT.SIZE]
WIDTH, 60
HEIGHT, 14

[msctls_trackbar32.SIZE]
WIDTH, 60
HEIGHT, 18

[msctls_progress32.SIZE]
WIDTH, 60
HEIGHT, 12

[SysMonthCal32.SIZE]
WIDTH, 130
HEIGHT, 100

[msctls_updown32.SIZE]
WIDTH, 12
HEIGHT, 20

[GROUPBOX.SIZE]
WIDTH, 60
HEIGHT, 60

[MEMO.SIZE]
WIDTH, 60
HEIGHT, 60

[BITMAP.SIZE]
WIDTH, 60
HEIGHT, 60

[COMBOBOX.SIZE]
WIDTH, 60
HEIGHT, 60

[LISTBOX.SIZE]
WIDTH, 60
HEIGHT, 60

[msctls_statusbar32.SIZE]
WIDTH, 60
HEIGHT, 12

[SysIPAddress32.SIZE]
WIDTH, 60
HEIGHT, 14

[AtlAxWin.SIZE]
WIDTH, 60
HEIGHT, 60
[AtlAxWin71.SIZE]
WIDTH, 60
HEIGHT, 60
[AtlAxWin80.SIZE]
WIDTH, 60
HEIGHT, 60
[AtlAxWin90.SIZE]
WIDTH, 60
HEIGHT, 60
[AtlAxWin100.SIZE]
WIDTH, 60
HEIGHT, 60
[AtlAxWin110.SIZE]
WIDTH, 60
HEIGHT, 60
[AtlAxWin140.SIZE]
WIDTH, 60
HEIGHT, 60

[SysLink.SIZE]
WIDTH, 64
HEIGHT, 64

[SysListView32.SIZE]
WIDTH, 60
HEIGHT, 60

[SysDateTimePick32.SIZE]
WIDTH, 80
HEIGHT, 14

[msctls_hotkey32.SIZE]
WIDTH, 60
HEIGHT, 14

[SysAnimate32.SIZE]
WIDTH, 60
HEIGHT, 60

[SysTabControl32.SIZE]
WIDTH, 60
HEIGHT, 60

[CONTROLS.ICONS]
PUSHBUTTON, 0
AUTOCHECKBOX, 1
AUTORADIOBUTTON, 2
COMBOBOX, 3
LISTBOX, 4
STATIC, 5
EDIT, 6
GROUPBOX, 7
ICON, 8
MEMO, 9
SysListView32, 10
SysTreeView32, 11
msctls_progress32, 12
msctls_updown32, 13
SysLink, 14
SplitButton, 15
AtlAxWin140, 16
SCROLLBAR, 17

[CONTROLS.OLE.CONTROL]
INDEX, 16

```

`data/bin/midlwrap.bat`:

```bat
@rem midlwrap.bat --- Execute MIDL Compiler
@rem %1 --- Visual Studio's vcvarsall.bat
@rem %2 --- x86 or amd64
@rem %3 --- the input file (*.idl)
@rem %4 --- tht output file (*.tlb)
@echo off
call %1 %2
midl /nologo /no_warn %3 /tlb %4
exit

```

`data/lib/gcc/i686-w64-mingw32/10.2.0/include/afxres.h`:

```h
#ifndef _AFXRES_H
#define _AFXRES_H

#ifdef __cplusplus
extern "C" {
#endif

#ifndef _INC_WINDOWS
    #include <windows.h>
#endif

#ifndef IDC_STATIC
    #define IDC_STATIC (-1)
#endif

#ifdef __cplusplus
} /* exterm "C" */
#endif

#endif  /* ndef _AFXRES_H */

```

`data/lib/gcc/i686-w64-mingw32/10.2.0/include/commctrl.h`:

```h
#ifndef _INC_COMMCTRL
#define _INC_COMMCTRL

#define HDS_HORZ 0x0
#define HDS_BUTTONS 0x2
#define HDS_HOTTRACK 0x4
#define HDS_HIDDEN 0x8
#define HDS_DRAGDROP 0x40
#define HDS_FULLDRAG 0x80
#define HDS_FILTERBAR 0x100
#define HDS_FLAT 0x200
#if NTDDI_VERSION >= 0x06000000
#define HDS_CHECKBOXES 0x400
#define HDS_NOSIZING 0x800
#define HDS_OVERFLOW 0x1000
#endif

#define TBSTYLE_BUTTON 0x0
#define TBSTYLE_SEP 0x1
#define TBSTYLE_CHECK 0x2
#define TBSTYLE_GROUP 0x4
#define TBSTYLE_CHECKGROUP (TBSTYLE_GROUP | TBSTYLE_CHECK)
#define TBSTYLE_DROPDOWN 0x8
#define TBSTYLE_AUTOSIZE 0x10
#define TBSTYLE_NOPREFIX 0x20
#define TBSTYLE_TOOLTIPS 0x100
#define TBSTYLE_WRAPABLE 0x200
#define TBSTYLE_ALTDRAG 0x400
#define TBSTYLE_FLAT 0x800
#define TBSTYLE_LIST 0x1000
#define TBSTYLE_CUSTOMERASE 0x2000
#define TBSTYLE_REGISTERDROP 0x4000
#define TBSTYLE_TRANSPARENT 0x8000

#define BTNS_BUTTON TBSTYLE_BUTTON
#define BTNS_SEP TBSTYLE_SEP
#define BTNS_CHECK TBSTYLE_CHECK
#define BTNS_GROUP TBSTYLE_GROUP
#define BTNS_CHECKGROUP TBSTYLE_CHECKGROUP
#define BTNS_DROPDOWN TBSTYLE_DROPDOWN
#define BTNS_AUTOSIZE TBSTYLE_AUTOSIZE
#define BTNS_NOPREFIX TBSTYLE_NOPREFIX
#define BTNS_SHOWTEXT 0x40
#define BTNS_WHOLEDROPDOWN 0x80

#define RBS_TOOLTIPS 0x100
#define RBS_VARHEIGHT 0x200
#define RBS_BANDBORDERS 0x400
#define RBS_FIXEDORDER 0x800
#define RBS_REGISTERDROP 0x1000
#define RBS_AUTOSIZE 0x2000
#define RBS_VERTICALGRIPPER 0x4000
#define RBS_DBLCLKTOGGLE 0x8000

#define TTS_ALWAYSTIP 0x1
#define TTS_NOPREFIX 0x2
#define TTS_NOANIMATE 0x10
#define TTS_NOFADE 0x20
#define TTS_BALLOON 0x40
#define TTS_CLOSE 0x80
#if NTDDI_VERSION >= 0x06000000
#define TTS_USEVISUALSTYLE 0x100
#endif

#define SBARS_SIZEGRIP 0x100
#define SBARS_TOOLTIPS 0x800

#define SBT_TOOLTIPS 0x800

#define TBS_AUTOTICKS 0x1
#define TBS_VERT 0x2
#define TBS_HORZ 0x0
#define TBS_TOP 0x4
#define TBS_BOTTOM 0x0
#define TBS_LEFT 0x4
#define TBS_RIGHT 0x0
#define TBS_BOTH 0x8
#define TBS_NOTICKS 0x10
#define TBS_ENABLESELRANGE 0x20
#define TBS_FIXEDLENGTH 0x40
#define TBS_NOTHUMB 0x80
#define TBS_TOOLTIPS 0x100
#define TBS_REVERSED 0x200
#define TBS_DOWNISLEFT 0x400
#if _WIN32_IE >= 0x0600
#define TBS_NOTIFYBEFOREMOVE 0x800
#endif
#if NTDDI_VERSION >= 0x06000000
#define TBS_TRANSPARENTBKGND 0x1000
#endif

#define UDS_WRAP 0x1
#define UDS_SETBUDDYINT 0x2
#define UDS_ALIGNRIGHT 0x4
#define UDS_ALIGNLEFT 0x8
#define UDS_AUTOBUDDY 0x10
#define UDS_ARROWKEYS 0x20
#define UDS_HORZ 0x0040
#define UDS_NOTHOUSANDS 0x80
#define UDS_HOTTRACK 0x100

#define PBS_SMOOTH 0x1
#define PBS_VERTICAL 0x4
#define PBS_MARQUEE 0x8
#if NTDDI_VERSION >= 0x06000000
#define PBS_SMOOTHREVERSE 0x10
#endif

#define CCS_TOP 0x1L
#define CCS_NOMOVEY 0x2L
#define CCS_BOTTOM 0x3L
#define CCS_NORESIZE 0x4L
#define CCS_NOPARENTALIGN 0x8L
#define CCS_ADJUSTABLE 0x20L
#define CCS_NODIVIDER 0x40L
#define CCS_VERT 0x80L
#define CCS_LEFT (CCS_VERT | CCS_TOP)
#define CCS_RIGHT (CCS_VERT | CCS_BOTTOM)
#define CCS_NOMOVEX (CCS_VERT | CCS_NOMOVEY)

#define LWS_TRANSPARENT 0x1
#define LWS_IGNORERETURN 0x2
#if NTDDI_VERSION >= 0x06000000
#define LWS_NOPREFIX 0x4
#define LWS_USEVISUALSTYLE 0x8
#define LWS_USECUSTOMTEXT 0x10
#define LWS_RIGHT 0x20
#endif

#define LVS_ICON 0x0
#define LVS_REPORT 0x1
#define LVS_SMALLICON 0x2
#define LVS_LIST 0x3
#define LVS_TYPEMASK 0x3
#define LVS_SINGLESEL 0x4
#define LVS_SHOWSELALWAYS 0x8
#define LVS_SORTASCENDING 0x10
#define LVS_SORTDESCENDING 0x20
#define LVS_SHAREIMAGELISTS 0x40
#define LVS_NOLABELWRAP 0x80
#define LVS_AUTOARRANGE 0x100
#define LVS_EDITLABELS 0x200
#define LVS_OWNERDATA 0x1000
#define LVS_NOSCROLL 0x2000

#define LVS_TYPESTYLEMASK 0xfc00

#define LVS_ALIGNTOP 0x0
#define LVS_ALIGNLEFT 0x800
#define LVS_ALIGNMASK 0xc00

#define LVS_OWNERDRAWFIXED 0x400
#define LVS_NOCOLUMNHEADER 0x4000
#define LVS_NOSORTHEADER 0x8000

#define TVS_HASBUTTONS 0x1
#define TVS_HASLINES 0x2
#define TVS_LINESATROOT 0x4
#define TVS_EDITLABELS 0x8
#define TVS_DISABLEDRAGDROP 0x10
#define TVS_SHOWSELALWAYS 0x20
#define TVS_RTLREADING 0x40
#define TVS_NOTOOLTIPS 0x80
#define TVS_CHECKBOXES 0x100
#define TVS_TRACKSELECT 0x200
#define TVS_SINGLEEXPAND 0x400
#define TVS_INFOTIP 0x800
#define TVS_FULLROWSELECT 0x1000
#define TVS_NOSCROLL 0x2000
#define TVS_NONEVENHEIGHT 0x4000
#define TVS_NOHSCROLL 0x8000

#define TVS_EX_NOSINGLECOLLAPSE 0x1
#if NTDDI_VERSION >= 0x06000000
#define TVS_EX_MULTISELECT 0x2
#define TVS_EX_DOUBLEBUFFER 0x4
#define TVS_EX_NOINDENTSTATE 0x8
#define TVS_EX_RICHTOOLTIP 0x10
#define TVS_EX_AUTOHSCROLL 0x20
#define TVS_EX_FADEINOUTEXPANDOS 0x40
#define TVS_EX_PARTIALCHECKBOXES 0x80
#define TVS_EX_EXCLUSIONCHECKBOXES 0x100
#define TVS_EX_DIMMEDCHECKBOXES 0x200
#define TVS_EX_DRAWIMAGEASYNC 0x400
#endif

#define TCS_SCROLLOPPOSITE 0x1
#define TCS_BOTTOM 0x2
#define TCS_RIGHT 0x2
#define TCS_MULTISELECT 0x4
#define TCS_FLATBUTTONS 0x8
#define TCS_FORCEICONLEFT 0x10
#define TCS_FORCELABELLEFT 0x20
#define TCS_HOTTRACK 0x40
#define TCS_VERTICAL 0x80
#define TCS_TABS 0x0
#define TCS_BUTTONS 0x100
#define TCS_SINGLELINE 0x0
#define TCS_MULTILINE 0x200
#define TCS_RIGHTJUSTIFY 0x0
#define TCS_FIXEDWIDTH 0x400
#define TCS_RAGGEDRIGHT 0x800
#define TCS_FOCUSONBUTTONDOWN 0x1000
#define TCS_OWNERDRAWFIXED 0x2000
#define TCS_TOOLTIPS 0x4000
#define TCS_FOCUSNEVER 0x8000

#define ACS_CENTER 0x1
#define ACS_TRANSPARENT 0x2
#define ACS_AUTOPLAY 0x4
#define ACS_TIMER 0x8

#define MCS_DAYSTATE 0x1
#define MCS_MULTISELECT 0x2
#define MCS_WEEKNUMBERS 0x4
#define MCS_NOTODAYCIRCLE 0x8
#define MCS_NOTODAY 0x10
#if NTDDI_VERSION >= 0x06000000
#define MCS_NOTRAILINGDATES 0x40
#define MCS_SHORTDAYSOFWEEK 0x80
#define MCS_NOSELCHANGEONNAV 0x100
#endif

#define DTS_UPDOWN 0x1
#define DTS_SHOWNONE 0x2
#define DTS_SHORTDATEFORMAT 0x0
#define DTS_LONGDATEFORMAT 0x4
#define DTS_SHORTDATECENTURYFORMAT 0xc
#define DTS_TIMEFORMAT 0x9
#define DTS_APPCANPARSE 0x10
#define DTS_RIGHTALIGN 0x20

#define PGS_VERT 0x0
#define PGS_HORZ 0x1
#define PGS_AUTOSCROLL 0x2
#define PGS_DRAGNDROP 0x4

#define NFS_EDIT 0x1
#define NFS_STATIC 0x2
#define NFS_LISTCOMBO 0x4
#define NFS_BUTTON 0x8
#define NFS_ALL 0x10
#define NFS_USEFONTASSOC 0x20

#define BS_SPLITBUTTON 0xcL
#define BS_DEFSPLITBUTTON 0xdL
#define BS_COMMANDLINK 0xeL
#define BS_DEFCOMMANDLINK 0xfL

#define BCSIF_GLYPH 0x1
#define BCSIF_IMAGE 0x2
#define BCSIF_STYLE 0x4
#define BCSIF_SIZE 0x8

#define BCSS_NOSPLIT 0x1
#define BCSS_STRETCH 0x2
#define BCSS_ALIGNLEFT 0x4
#define BCSS_IMAGE 0x8

#endif  /* ndef _INC_COMMCTRL */

```

`data/lib/gcc/i686-w64-mingw32/10.2.0/include/dlgs.h`:

```h
#ifndef _DLGSH_INCLUDED_
#define _DLGSH_INCLUDED_

#define ctlFirst 0x0400
#define ctlLast 0x04ff

#define psh1 0x0400
#define psh2 0x0401
#define psh3 0x0402
#define psh4 0x0403
#define psh5 0x0404
#define psh6 0x0405
#define psh7 0x0406
#define psh8 0x0407
#define psh9 0x0408
#define psh10 0x0409
#define psh11 0x040a
#define psh12 0x040b
#define psh13 0x040c
#define psh14 0x040d
#define psh15 0x040e
#define pshHelp psh15
#define psh16 0x040f

#define chx1 0x0410
#define chx2 0x0411
#define chx3 0x0412
#define chx4 0x0413
#define chx5 0x0414
#define chx6 0x0415
#define chx7 0x0416
#define chx8 0x0417
#define chx9 0x0418
#define chx10 0x0419
#define chx11 0x041a
#define chx12 0x041b
#define chx13 0x041c
#define chx14 0x041d
#define chx15 0x041e
#define chx16 0x041f

#define rad1 0x0420
#define rad2 0x0421
#define rad3 0x0422
#define rad4 0x0423
#define rad5 0x0424
#define rad6 0x0425
#define rad7 0x0426
#define rad8 0x0427
#define rad9 0x0428
#define rad10 0x0429
#define rad11 0x042a
#define rad12 0x042b
#define rad13 0x042c
#define rad14 0x042d
#define rad15 0x042e
#define rad16 0x042f

#define grp1 0x0430
#define grp2 0x0431
#define grp3 0x0432
#define grp4 0x0433
#define frm1 0x0434
#define frm2 0x0435
#define frm3 0x0436
#define frm4 0x0437
#define rct1 0x0438
#define rct2 0x0439
#define rct3 0x043a
#define rct4 0x043b
#define ico1 0x043c
#define ico2 0x043d
#define ico3 0x043e
#define ico4 0x043f

#define stc1 0x0440
#define stc2 0x0441
#define stc3 0x0442
#define stc4 0x0443
#define stc5 0x0444
#define stc6 0x0445
#define stc7 0x0446
#define stc8 0x0447
#define stc9 0x0448
#define stc10 0x0449
#define stc11 0x044a
#define stc12 0x044b
#define stc13 0x044c
#define stc14 0x044d
#define stc15 0x044e
#define stc16 0x044f
#define stc17 0x0450
#define stc18 0x0451
#define stc19 0x0452
#define stc20 0x0453
#define stc21 0x0454
#define stc22 0x0455
#define stc23 0x0456
#define stc24 0x0457
#define stc25 0x0458
#define stc26 0x0459
#define stc27 0x045a
#define stc28 0x045b
#define stc29 0x045c
#define stc30 0x045d
#define stc31 0x045e
#define stc32 0x045f

#define lst1 0x0460
#define lst2 0x0461
#define lst3 0x0462
#define lst4 0x0463
#define lst5 0x0464
#define lst6 0x0465
#define lst7 0x0466
#define lst8 0x0467
#define lst9 0x0468
#define lst10 0x0469
#define lst11 0x046a
#define lst12 0x046b
#define lst13 0x046c
#define lst14 0x046d
#define lst15 0x046e
#define lst16 0x046f

#define cmb1 0x0470
#define cmb2 0x0471
#define cmb3 0x0472
#define cmb4 0x0473
#define cmb5 0x0474
#define cmb6 0x0475
#define cmb7 0x0476
#define cmb8 0x0477
#define cmb9 0x0478
#define cmb10 0x0479
#define cmb11 0x047a
#define cmb12 0x047b
#define cmb13 0x047c
#define cmb14 0x047d
#define cmb15 0x047e
#define cmb16 0x047f

#define edt1 0x0480
#define edt2 0x0481
#define edt3 0x0482
#define edt4 0x0483
#define edt5 0x0484
#define edt6 0x0485
#define edt7 0x0486
#define edt8 0x0487
#define edt9 0x0488
#define edt10 0x0489
#define edt11 0x048a
#define edt12 0x048b
#define edt13 0x048c
#define edt14 0x048d
#define edt15 0x048e
#define edt16 0x048f

#define scr1 0x0490
#define scr2 0x0491
#define scr3 0x0492
#define scr4 0x0493
#define scr5 0x0494
#define scr6 0x0495
#define scr7 0x0496
#define scr8 0x0497

#define ctl1 0x04A0

#define FILEOPENORD 1536
#define MULTIFILEOPENORD 1537
#define PRINTDLGORD 1538
#define PRNSETUPDLGORD 1539
#define FINDDLGORD 1540
#define REPLACEDLGORD 1541
#define FONTDLGORD 1542
#define FORMATDLGORD31 1543
#define FORMATDLGORD30 1544
#define RUNDLGORD 1545

#define PAGESETUPDLGORD 1546
#define NEWFILEOPENORD 1547
#define PRINTDLGEXORD 1549
#define PAGESETUPDLGORDMOTIF 1550
#define COLORMGMTDLGORD 1551
#define NEWFILEOPENV2ORD 1552

#endif

```

`data/lib/gcc/i686-w64-mingw32/10.2.0/include/windef.h`:

```h
#ifndef _WINDEF_
#define _WINDEF_

#include "winnt.h"

#endif  /* ndef _WINDEF_ */

```

`data/lib/gcc/i686-w64-mingw32/10.2.0/include/windows.h`:

```h
#include <winresrc.h>

```

`data/lib/gcc/i686-w64-mingw32/10.2.0/include/winnt.h`:

```h
#ifndef _WINNT_
#define _WINNT_

#define LANG_NEUTRAL 0x00
#define LANG_INVARIANT 0x7f

#define LANG_AFRIKAANS 0x36
#define LANG_ALBANIAN 0x1c
#define LANG_ALSATIAN 0x84
#define LANG_AMHARIC 0x5e
#define LANG_ARABIC 0x01
#define LANG_ARMENIAN 0x2b
#define LANG_ASSAMESE 0x4d
#define LANG_AZERI 0x2c
#define LANG_AZERBAIJANI 0x2c
#define LANG_BANGLA 0x45
#define LANG_BASHKIR 0x6d
#define LANG_BASQUE 0x2d
#define LANG_BELARUSIAN 0x23
#define LANG_BENGALI 0x45
#define LANG_BRETON 0x7e
#define LANG_BOSNIAN 0x1a
#define LANG_BOSNIAN_NEUTRAL 0x781a
#define LANG_BULGARIAN 0x02
#define LANG_CATALAN 0x03
#define LANG_CENTRAL_KURDISH 0x92
#define LANG_CHEROKEE 0x5c
#define LANG_CHINESE 0x04
#define LANG_CHINESE_SIMPLIFIED 0x04
#define LANG_CHINESE_TRADITIONAL 0x7c04
#define LANG_CORSICAN 0x83
#define LANG_CROATIAN 0x1a
#define LANG_CZECH 0x05
#define LANG_DANISH 0x06
#define LANG_DARI 0x8c
#define LANG_DIVEHI 0x65
#define LANG_DUTCH 0x13
#define LANG_ENGLISH 0x09
#define LANG_ESTONIAN 0x25
#define LANG_FAEROESE 0x38
#define LANG_FARSI 0x29
#define LANG_FILIPINO 0x64
#define LANG_FINNISH 0x0b
#define LANG_FRENCH 0x0c
#define LANG_FRISIAN 0x62
#define LANG_FULAH 0x67
#define LANG_GALICIAN 0x56
#define LANG_GEORGIAN 0x37
#define LANG_GERMAN 0x07
#define LANG_GREEK 0x08
#define LANG_GREENLANDIC 0x6f
#define LANG_GUJARATI 0x47
#define LANG_HAUSA 0x68
#define LANG_HEBREW 0x0d
#define LANG_HINDI 0x39
#define LANG_HUNGARIAN 0x0e
#define LANG_ICELANDIC 0x0f
#define LANG_IGBO 0x70
#define LANG_INDONESIAN 0x21
#define LANG_INUKTITUT 0x5d
#define LANG_IRISH 0x3c
#define LANG_ITALIAN 0x10
#define LANG_JAPANESE 0x11
#define LANG_KANNADA 0x4b
#define LANG_KASHMIRI 0x60
#define LANG_KAZAK 0x3f
#define LANG_KHMER 0x53
#define LANG_KICHE 0x86
#define LANG_KINYARWANDA 0x87
#define LANG_KONKANI 0x57
#define LANG_KOREAN 0x12
#define LANG_KYRGYZ 0x40
#define LANG_LAO 0x54
#define LANG_LATVIAN 0x26
#define LANG_LITHUANIAN 0x27
#define LANG_LOWER_SORBIAN 0x2e
#define LANG_LUXEMBOURGISH 0x6e
#define LANG_MACEDONIAN 0x2f
#define LANG_MALAY 0x3e
#define LANG_MALAYALAM 0x4c
#define LANG_MALTESE 0x3a
#define LANG_MANIPURI 0x58
#define LANG_MAORI 0x81
#define LANG_MAPUDUNGUN 0x7a
#define LANG_MARATHI 0x4e
#define LANG_MOHAWK 0x7c
#define LANG_MONGOLIAN 0x50
#define LANG_NEPALI 0x61
#define LANG_NORWEGIAN 0x14
#define LANG_OCCITAN 0x82
#define LANG_ODIA 0x48
#define LANG_ORIYA 0x48
#define LANG_PASHTO 0x63
#define LANG_PERSIAN 0x29
#define LANG_POLISH 0x15
#define LANG_PORTUGUESE 0x16
#define LANG_PULAR 0x67
#define LANG_PUNJABI 0x46
#define LANG_QUECHUA 0x6b
#define LANG_ROMANIAN 0x18
#define LANG_ROMANSH 0x17
#define LANG_RUSSIAN 0x19
#define LANG_SAKHA 0x85
#define LANG_SAMI 0x3b
#define LANG_SANSKRIT 0x4f
#define LANG_SCOTTISH_GAELIC 0x91
#define LANG_SERBIAN 0x1a
#define LANG_SERBIAN_NEUTRAL 0x7c1a
#define LANG_SINDHI 0x59
#define LANG_SINHALESE 0x5b
#define LANG_SLOVAK 0x1b
#define LANG_SLOVENIAN 0x24
#define LANG_SOTHO 0x6c
#define LANG_SPANISH 0x0a
#define LANG_SWAHILI 0x41
#define LANG_SWEDISH 0x1d
#define LANG_SYRIAC 0x5a
#define LANG_TAJIK 0x28
#define LANG_TAMAZIGHT 0x5f
#define LANG_TAMIL 0x49
#define LANG_TATAR 0x44
#define LANG_TELUGU 0x4a
#define LANG_THAI 0x1e
#define LANG_TIBETAN 0x51
#define LANG_TIGRIGNA 0x73
#define LANG_TIGRINYA 0x73
#define LANG_TSWANA 0x32
#define LANG_TURKISH 0x1f
#define LANG_TURKMEN 0x42
#define LANG_UIGHUR 0x80
#define LANG_UKRAINIAN 0x22
#define LANG_UPPER_SORBIAN 0x2e
#define LANG_URDU 0x20
#define LANG_UZBEK 0x43
#define LANG_VALENCIAN 0x03
#define LANG_VIETNAMESE 0x2a
#define LANG_WELSH 0x52
#define LANG_WOLOF 0x88
#define LANG_XHOSA 0x34
#define LANG_YAKUT 0x85
#define LANG_YI 0x78
#define LANG_YORUBA 0x6a
#define LANG_ZULU 0x35

#define SUBLANG_NEUTRAL 0x00
#define SUBLANG_DEFAULT 0x01
#define SUBLANG_SYS_DEFAULT 0x02
#define SUBLANG_CUSTOM_DEFAULT 0x03
#define SUBLANG_CUSTOM_UNSPECIFIED 0x04
#define SUBLANG_UI_CUSTOM_DEFAULT 0x05

#define SUBLANG_AFRIKAANS_SOUTH_AFRICA 0x01
#define SUBLANG_ALBANIAN_ALBANIA 0x01
#define SUBLANG_ALSATIAN_FRANCE 0x01
#define SUBLANG_AMHARIC_ETHIOPIA 0x01
#define SUBLANG_ARABIC_SAUDI_ARABIA 0x01
#define SUBLANG_ARABIC_IRAQ 0x02
#define SUBLANG_ARABIC_EGYPT 0x03
#define SUBLANG_ARABIC_LIBYA 0x04
#define SUBLANG_ARABIC_ALGERIA 0x05
#define SUBLANG_ARABIC_MOROCCO 0x06
#define SUBLANG_ARABIC_TUNISIA 0x07
#define SUBLANG_ARABIC_OMAN 0x08
#define SUBLANG_ARABIC_YEMEN 0x09
#define SUBLANG_ARABIC_SYRIA 0x0a
#define SUBLANG_ARABIC_JORDAN 0x0b
#define SUBLANG_ARABIC_LEBANON 0x0c
#define SUBLANG_ARABIC_KUWAIT 0x0d
#define SUBLANG_ARABIC_UAE 0x0e
#define SUBLANG_ARABIC_BAHRAIN 0x0f
#define SUBLANG_ARABIC_QATAR 0x10
#define SUBLANG_ARMENIAN_ARMENIA 0x01
#define SUBLANG_ASSAMESE_INDIA 0x01
#define SUBLANG_AZERI_LATIN 0x01
#define SUBLANG_AZERI_CYRILLIC 0x02
#define SUBLANG_AZERBAIJANI_AZERBAIJAN_LATIN 0x01
#define SUBLANG_AZERBAIJANI_AZERBAIJAN_CYRILLIC 0x02
#define SUBLANG_BANGLA_INDIA 0x01
#define SUBLANG_BANGLA_BANGLADESH 0x02
#define SUBLANG_BASHKIR_RUSSIA 0x01
#define SUBLANG_BASQUE_BASQUE 0x01
#define SUBLANG_BELARUSIAN_BELARUS 0x01
#define SUBLANG_BENGALI_INDIA 0x01
#define SUBLANG_BENGALI_BANGLADESH 0x02
#define SUBLANG_BOSNIAN_BOSNIA_HERZEGOVINA_LATIN  0x05
#define SUBLANG_BOSNIAN_BOSNIA_HERZEGOVINA_CYRILLIC 0x08
#define SUBLANG_BRETON_FRANCE 0x01
#define SUBLANG_BULGARIAN_BULGARIA 0x01
#define SUBLANG_CATALAN_CATALAN 0x01
#define SUBLANG_CENTRAL_KURDISH_IRAQ 0x01
#define SUBLANG_CHEROKEE_CHEROKEE 0x01
#define SUBLANG_CHINESE_TRADITIONAL 0x01
#define SUBLANG_CHINESE_SIMPLIFIED 0x02
#define SUBLANG_CHINESE_HONGKONG 0x03
#define SUBLANG_CHINESE_SINGAPORE 0x04
#define SUBLANG_CHINESE_MACAU 0x05
#define SUBLANG_CORSICAN_FRANCE 0x01
#define SUBLANG_CZECH_CZECH_REPUBLIC 0x01
#define SUBLANG_CROATIAN_CROATIA 0x01
#define SUBLANG_CROATIAN_BOSNIA_HERZEGOVINA_LATIN 0x04
#define SUBLANG_DANISH_DENMARK 0x01
#define SUBLANG_DARI_AFGHANISTAN 0x01
#define SUBLANG_DIVEHI_MALDIVES 0x01
#define SUBLANG_DUTCH 0x01
#define SUBLANG_DUTCH_BELGIAN 0x02
#define SUBLANG_ENGLISH_US 0x01
#define SUBLANG_ENGLISH_UK 0x02
#define SUBLANG_ENGLISH_AUS 0x03
#define SUBLANG_ENGLISH_CAN 0x04
#define SUBLANG_ENGLISH_NZ 0x05
#define SUBLANG_ENGLISH_IRELAND 0x06
#define SUBLANG_ENGLISH_EIRE 0x06
#define SUBLANG_ENGLISH_SOUTH_AFRICA 0x07
#define SUBLANG_ENGLISH_JAMAICA 0x08
#define SUBLANG_ENGLISH_CARIBBEAN 0x09
#define SUBLANG_ENGLISH_BELIZE 0x0a
#define SUBLANG_ENGLISH_TRINIDAD 0x0b
#define SUBLANG_ENGLISH_ZIMBABWE 0x0c
#define SUBLANG_ENGLISH_PHILIPPINES 0x0d
#define SUBLANG_ENGLISH_INDIA 0x10
#define SUBLANG_ENGLISH_MALAYSIA 0x11
#define SUBLANG_ENGLISH_SINGAPORE 0x12
#define SUBLANG_ESTONIAN_ESTONIA 0x01
#define SUBLANG_FAEROESE_FAROE_ISLANDS 0x01
#define SUBLANG_FILIPINO_PHILIPPINES 0x01
#define SUBLANG_FINNISH_FINLAND 0x01
#define SUBLANG_FRENCH 0x01
#define SUBLANG_FRENCH_BELGIAN 0x02
#define SUBLANG_FRENCH_CANADIAN 0x03
#define SUBLANG_FRENCH_SWISS 0x04
#define SUBLANG_FRENCH_LUXEMBOURG 0x05
#define SUBLANG_FRENCH_MONACO 0x06
#define SUBLANG_FRISIAN_NETHERLANDS 0x01
#define SUBLANG_FULAH_SENEGAL 0x02
#define SUBLANG_GALICIAN_GALICIAN 0x01
#define SUBLANG_GEORGIAN_GEORGIA 0x01
#define SUBLANG_GERMAN 0x01
#define SUBLANG_GERMAN_SWISS 0x02
#define SUBLANG_GERMAN_AUSTRIAN 0x03
#define SUBLANG_GERMAN_LUXEMBOURG 0x04
#define SUBLANG_GERMAN_LIECHTENSTEIN 0x05
#define SUBLANG_GREEK_GREECE 0x01
#define SUBLANG_GREENLANDIC_GREENLAND 0x01
#define SUBLANG_GUJARATI_INDIA 0x01
#define SUBLANG_HAUSA_NIGERIA_LATIN 0x01
#define SUBLANG_HAUSA_NIGERIA SUBLANG_HAUSA_NIGERIA_LATIN
#define SUBLANG_HAWAIIAN_US 0x01
#define SUBLANG_HEBREW_ISRAEL 0x01
#define SUBLANG_HINDI_INDIA 0x01
#define SUBLANG_HUNGARIAN_HUNGARY 0x01
#define SUBLANG_ICELANDIC_ICELAND 0x01
#define SUBLANG_IGBO_NIGERIA 0x01
#define SUBLANG_INDONESIAN_INDONESIA 0x01
#define SUBLANG_INUKTITUT_CANADA 0x01
#define SUBLANG_INUKTITUT_CANADA_LATIN 0x02
#define SUBLANG_IRISH_IRELAND 0x02
#define SUBLANG_ITALIAN 0x01
#define SUBLANG_ITALIAN_SWISS 0x02
#define SUBLANG_JAPANESE_JAPAN 0x01
#define SUBLANG_KANNADA_INDIA 0x01
#define SUBLANG_KASHMIRI_INDIA 0x02
#define SUBLANG_KASHMIRI_SASIA 0x02
#define SUBLANG_KAZAK_KAZAKHSTAN 0x01
#define SUBLANG_KHMER_CAMBODIA 0x01
#define SUBLANG_KICHE_GUATEMALA 0x01
#define SUBLANG_KINYARWANDA_RWANDA 0x01
#define SUBLANG_KONKANI_INDIA 0x01
#define SUBLANG_KOREAN 0x01
#define SUBLANG_KYRGYZ_KYRGYZSTAN 0x01
#define SUBLANG_LAO_LAO 0x01
#define SUBLANG_LAO_LAO_PDR SUBLANG_LAO_LAO
#define SUBLANG_LATVIAN_LATVIA 0x01
#if (WINVER >= 0x0600)
#define SUBLANG_LITHUANIAN_LITHUANIA 0x01
#endif
#define SUBLANG_LITHUANIAN 0x01
#define SUBLANG_LOWER_SORBIAN_GERMANY 0x02
#define SUBLANG_LUXEMBOURGISH_LUXEMBOURG 0x01
#define SUBLANG_MACEDONIAN_MACEDONIA 0x01
#define SUBLANG_MALAY_MALAYSIA 0x01
#define SUBLANG_MALAY_BRUNEI_DARUSSALAM 0x02
#define SUBLANG_MALAYALAM_INDIA 0x01
#define SUBLANG_MALTESE_MALTA 0x01
#define SUBLANG_MAORI_NEW_ZEALAND 0x01
#define SUBLANG_MAPUDUNGUN_CHILE 0x01
#define SUBLANG_MARATHI_INDIA 0x01
#define SUBLANG_MOHAWK_MOHAWK 0x01
#define SUBLANG_MONGOLIAN_CYRILLIC_MONGOLIA 0x01
#define SUBLANG_MONGOLIAN_PRC 0x02
#define SUBLANG_NEPALI_NEPAL 0x01
#define SUBLANG_NEPALI_INDIA 0x02
#define SUBLANG_NORWEGIAN_BOKMAL 0x01
#define SUBLANG_NORWEGIAN_NYNORSK 0x02
#define SUBLANG_OCCITAN_FRANCE 0x01
#define SUBLANG_ORIYA_INDIA 0x01
#define SUBLANG_PASHTO_AFGHANISTAN 0x01
#define SUBLANG_PERSIAN_IRAN 0x01
#define SUBLANG_POLISH_POLAND 0x01
#define SUBLANG_PORTUGUESE_BRAZILIAN 0x01
#if (WINVER >= 0x0600)
#define SUBLANG_PORTUGUESE_PORTUGAL 0x02
#endif
#define SUBLANG_PORTUGUESE 0x02
#define SUBLANG_PULAR_SENEGAL 0x02
#define SUBLANG_PUNJABI_INDIA 0x01
#define SUBLANG_PUNJABI_PAKISTAN 0x02
#define SUBLANG_QUECHUA_BOLIVIA 0x01
#define SUBLANG_QUECHUA_ECUADOR 0x02
#define SUBLANG_QUECHUA_PERU 0x03
#define SUBLANG_ROMANIAN_ROMANIA 0x01
#define SUBLANG_ROMANSH_SWITZERLAND 0x01
#define SUBLANG_RUSSIAN_RUSSIA 0x01
#define SUBLANG_SAKHA_RUSSIA 0x01
#define SUBLANG_SAMI_NORTHERN_NORWAY 0x01
#define SUBLANG_SAMI_NORTHERN_SWEDEN 0x02
#define SUBLANG_SAMI_NORTHERN_FINLAND 0x03
#define SUBLANG_SAMI_LULE_NORWAY 0x04
#define SUBLANG_SAMI_LULE_SWEDEN 0x05
#define SUBLANG_SAMI_SOUTHERN_NORWAY 0x06
#define SUBLANG_SAMI_SOUTHERN_SWEDEN 0x07
#define SUBLANG_SAMI_SKOLT_FINLAND 0x08
#define SUBLANG_SAMI_INARI_FINLAND 0x09
#define SUBLANG_SANSKRIT_INDIA 0x01
#define SUBLANG_SCOTTISH_GAELIC 0x01
#define SUBLANG_SERBIAN_LATIN 0x02
#define SUBLANG_SERBIAN_CYRILLIC 0x03
#define SUBLANG_SERBIAN_BOSNIA_HERZEGOVINA_LATIN  0x06
#define SUBLANG_SERBIAN_BOSNIA_HERZEGOVINA_CYRILLIC 0x07
#define SUBLANG_SERBIAN_MONTENEGRO_LATIN 0x0b
#define SUBLANG_SERBIAN_MONTENEGRO_CYRILLIC 0x0c
#define SUBLANG_SERBIAN_SERBIA_LATIN 0x09
#define SUBLANG_SERBIAN_SERBIA_CYRILLIC 0x0a
#define SUBLANG_SINDHI_INDIA 0x01
#define SUBLANG_SINDHI_AFGHANISTAN 0x02
#define SUBLANG_SINDHI_PAKISTAN 0x02
#define SUBLANG_SINHALESE_SRI_LANKA 0x01
#define SUBLANG_SOTHO_NORTHERN_SOUTH_AFRICA 0x01
#define SUBLANG_SLOVAK_SLOVAKIA 0x01
#define SUBLANG_SLOVENIAN_SLOVENIA 0x01
#define SUBLANG_SPANISH 0x01
#define SUBLANG_SPANISH_MEXICAN 0x02
#define SUBLANG_SPANISH_MODERN 0x03
#define SUBLANG_SPANISH_GUATEMALA 0x04
#define SUBLANG_SPANISH_COSTA_RICA 0x05
#define SUBLANG_SPANISH_PANAMA 0x06
#define SUBLANG_SPANISH_DOMINICAN_REPUBLIC 0x07
#define SUBLANG_SPANISH_VENEZUELA 0x08
#define SUBLANG_SPANISH_COLOMBIA 0x09
#define SUBLANG_SPANISH_PERU 0x0a
#define SUBLANG_SPANISH_ARGENTINA 0x0b
#define SUBLANG_SPANISH_ECUADOR 0x0c
#define SUBLANG_SPANISH_CHILE 0x0d
#define SUBLANG_SPANISH_URUGUAY 0x0e
#define SUBLANG_SPANISH_PARAGUAY 0x0f
#define SUBLANG_SPANISH_BOLIVIA 0x10
#define SUBLANG_SPANISH_EL_SALVADOR 0x11
#define SUBLANG_SPANISH_HONDURAS 0x12
#define SUBLANG_SPANISH_NICARAGUA 0x13
#define SUBLANG_SPANISH_PUERTO_RICO 0x14
#define SUBLANG_SPANISH_US 0x15
#define SUBLANG_SWAHILI_KENYA 0x01
#if (WINVER >= 0x0600)
#define SUBLANG_SWEDISH_SWEDEN 0x01
#endif
#define SUBLANG_SWEDISH 0x01
#define SUBLANG_SWEDISH_FINLAND 0x02
#define SUBLANG_SYRIAC 0x01
#define SUBLANG_SYRIAC_SYRIA SUBLANG_SYRIAC
#define SUBLANG_TAJIK_TAJIKISTAN 0x01
#define SUBLANG_TAMAZIGHT_ALGERIA_LATIN 0x02
#define SUBLANG_TAMAZIGHT_MOROCCO_TIFINAGH 0x04
#define SUBLANG_TAMIL_INDIA 0x01
#define SUBLANG_TAMIL_SRI_LANKA 0x02
#define SUBLANG_TATAR_RUSSIA 0x01
#define SUBLANG_TELUGU_INDIA 0x01
#define SUBLANG_THAI_THAILAND 0x01
#define SUBLANG_TIBETAN_PRC 0x01
#define SUBLANG_TIBETAN_BHUTAN 0x02
#define SUBLANG_TIGRIGNA_ERITREA 0x02
#define SUBLANG_TIGRINYA_ERITREA 0x02
#define SUBLANG_TIGRINYA_ETHIOPIA 0x01
#define SUBLANG_TSWANA_BOTSWANA 0x02
#define SUBLANG_TSWANA_SOUTH_AFRICA 0x01
#define SUBLANG_TURKISH_TURKEY 0x01
#define SUBLANG_TURKMEN_TURKMENISTAN 0x01
#define SUBLANG_UIGHUR_PRC 0x01
#define SUBLANG_UKRAINIAN_UKRAINE 0x01
#define SUBLANG_UPPER_SORBIAN_GERMANY 0x01
#define SUBLANG_URDU_PAKISTAN 0x01
#define SUBLANG_URDU_INDIA 0x02
#define SUBLANG_UZBEK_LATIN 0x01
#define SUBLANG_UZBEK_CYRILLIC 0x02
#define SUBLANG_VALENCIAN_VALENCIA 0x02
#define SUBLANG_VIETNAMESE_VIETNAM 0x01
#define SUBLANG_WELSH_UNITED_KINGDOM 0x01
#define SUBLANG_WOLOF_SENEGAL 0x01
#define SUBLANG_YORUBA_NIGERIA 0x01
#define SUBLANG_XHOSA_SOUTH_AFRICA 0x01
#define SUBLANG_YAKUT_RUSSIA 0x01
#define SUBLANG_YI_PRC 0x01
#define SUBLANG_ZULU_SOUTH_AFRICA 0x01

#define SORT_DEFAULT 0x0

#define SORT_JAPANESE_XJIS 0x0
#define SORT_JAPANESE_UNICODE 0x1

#define SORT_CHINESE_BIG5 0x0
#define SORT_CHINESE_PRCP 0x0
#define SORT_CHINESE_UNICODE 0x1
#define SORT_CHINESE_PRC 0x2
#define SORT_CHINESE_BOPOMOFO 0x3

#define SORT_KOREAN_KSC 0x0
#define SORT_KOREAN_UNICODE 0x1

#define SORT_GERMAN_PHONE_BOOK 0x1

#define SORT_HUNGARIAN_DEFAULT 0x0
#define SORT_HUNGARIAN_TECHNICAL 0x1

#define SORT_GEORGIAN_TRADITIONAL 0x0
#define SORT_GEORGIAN_MODERN 0x1

#endif  /* ndef _WINNT_ */

```

`data/lib/gcc/i686-w64-mingw32/10.2.0/include/winresrc.h`:

```h
#ifndef _WINRESRC_
#define _WINRESRC_

#ifndef WINVER
#define WINVER 0x0502
#endif

#ifndef _WIN32_IE
#define _WIN32_IE 0x0501
#endif

#ifndef _WIN32_WINDOWS
#define _WIN32_WINDOWS 0x0502
#endif

#ifndef _WIN32_WINNT
#define _WIN32_WINNT 0x0502
#endif

#include <winuser.h>
#include <commctrl.h>
//#include <dde.h>
#include <winnt.h>
#include <dlgs.h>
#include <winver.h>
#endif

```

`data/lib/gcc/i686-w64-mingw32/10.2.0/include/winuser.h`:

```h
#ifndef _WINUSER_
#define _WINUSER_

#define RT_MANIFEST 24
#define CREATEPROCESS_MANIFEST_RESOURCE_ID 1
#define ISOLATIONAWARE_MANIFEST_RESOURCE_ID 2
#define ISOLATIONAWARE_NOSTATICIMPORT_MANIFEST_RESOURCE_ID 3
#define MINIMUM_RESERVED_MANIFEST_RESOURCE_ID 1
#define MAXIMUM_RESERVED_MANIFEST_RESOURCE_ID 16

#define SW_HIDE 0
#define SW_SHOWNORMAL 1
#define SW_NORMAL 1
#define SW_SHOWMINIMIZED 2
#define SW_SHOWMAXIMIZED 3
#define SW_MAXIMIZE 3
#define SW_SHOWNOACTIVATE 4
#define SW_SHOW 5
#define SW_MINIMIZE 6
#define SW_SHOWMINNOACTIVE 7
#define SW_SHOWNA 8
#define SW_RESTORE 9
#define SW_SHOWDEFAULT 10
#define SW_FORCEMINIMIZE 11
#define SW_MAX 11

#define HIDE_WINDOW 0
#define SHOW_OPENWINDOW 1
#define SHOW_ICONWINDOW 2
#define SHOW_FULLSCREEN 3
#define SHOW_OPENNOACTIVATE 4

#define SW_PARENTCLOSING 1
#define SW_OTHERZOOM 2
#define SW_PARENTOPENING 3
#define SW_OTHERUNZOOM 4

#define VK_LBUTTON 0x01
#define VK_RBUTTON 0x02
#define VK_CANCEL 0x03
#define VK_MBUTTON 0x04
#define VK_XBUTTON1 0x05
#define VK_XBUTTON2 0x06
#define VK_BACK 0x08
#define VK_TAB 0x09
#define VK_CLEAR 0x0C
#define VK_RETURN 0x0D

#define VK_SHIFT 0x10
#define VK_CONTROL 0x11
#define VK_MENU 0x12
#define VK_PAUSE 0x13
#define VK_CAPITAL 0x14

#define VK_KANA 0x15
#define VK_HANGEUL 0x15
#define VK_HANGUL 0x15
#define VK_JUNJA 0x17
#define VK_FINAL 0x18
#define VK_HANJA 0x19
#define VK_KANJI 0x19

#define VK_ESCAPE 0x1B

#define VK_CONVERT 0x1C
#define VK_NONCONVERT 0x1D
#define VK_ACCEPT 0x1E
#define VK_MODECHANGE 0x1F

#define VK_SPACE 0x20
#define VK_PRIOR 0x21
#define VK_NEXT 0x22
#define VK_END 0x23
#define VK_HOME 0x24
#define VK_LEFT 0x25
#define VK_UP 0x26
#define VK_RIGHT 0x27
#define VK_DOWN 0x28
#define VK_SELECT 0x29
#define VK_PRINT 0x2A
#define VK_EXECUTE 0x2B
#define VK_SNAPSHOT 0x2C
#define VK_INSERT 0x2D
#define VK_DELETE 0x2E
#define VK_HELP 0x2F

#define VK_LWIN 0x5B
#define VK_RWIN 0x5C
#define VK_APPS 0x5D

#define VK_SLEEP 0x5F

#define VK_NUMPAD0 0x60
#define VK_NUMPAD1 0x61
#define VK_NUMPAD2 0x62
#define VK_NUMPAD3 0x63
#define VK_NUMPAD4 0x64
#define VK_NUMPAD5 0x65
#define VK_NUMPAD6 0x66
#define VK_NUMPAD7 0x67
#define VK_NUMPAD8 0x68
#define VK_NUMPAD9 0x69
#define VK_MULTIPLY 0x6A
#define VK_ADD 0x6B
#define VK_SEPARATOR 0x6C
#define VK_SUBTRACT 0x6D
#define VK_DECIMAL 0x6E
#define VK_DIVIDE 0x6F
#define VK_F1 0x70
#define VK_F2 0x71
#define VK_F3 0x72
#define VK_F4 0x73
#define VK_F5 0x74
#define VK_F6 0x75
#define VK_F7 0x76
#define VK_F8 0x77
#define VK_F9 0x78
#define VK_F10 0x79
#define VK_F11 0x7A
#define VK_F12 0x7B
#define VK_F13 0x7C
#define VK_F14 0x7D
#define VK_F15 0x7E
#define VK_F16 0x7F
#define VK_F17 0x80
#define VK_F18 0x81
#define VK_F19 0x82
#define VK_F20 0x83
#define VK_F21 0x84
#define VK_F22 0x85
#define VK_F23 0x86
#define VK_F24 0x87

#define VK_NUMLOCK 0x90
#define VK_SCROLL 0x91

#define VK_OEM_NEC_EQUAL 0x92

#define VK_OEM_FJ_JISHO 0x92
#define VK_OEM_FJ_MASSHOU 0x93
#define VK_OEM_FJ_TOUROKU 0x94
#define VK_OEM_FJ_LOYA 0x95
#define VK_OEM_FJ_ROYA 0x96

#define VK_LSHIFT 0xA0
#define VK_RSHIFT 0xA1
#define VK_LCONTROL 0xA2
#define VK_RCONTROL 0xA3
#define VK_LMENU 0xA4
#define VK_RMENU 0xA5

#define VK_BROWSER_BACK 0xA6
#define VK_BROWSER_FORWARD 0xA7
#define VK_BROWSER_REFRESH 0xA8
#define VK_BROWSER_STOP 0xA9
#define VK_BROWSER_SEARCH 0xAA
#define VK_BROWSER_FAVORITES 0xAB
#define VK_BROWSER_HOME 0xAC

#define VK_VOLUME_MUTE 0xAD
#define VK_VOLUME_DOWN 0xAE
#define VK_VOLUME_UP 0xAF
#define VK_MEDIA_NEXT_TRACK 0xB0
#define VK_MEDIA_PREV_TRACK 0xB1
#define VK_MEDIA_STOP 0xB2
#define VK_MEDIA_PLAY_PAUSE 0xB3
#define VK_LAUNCH_MAIL 0xB4
#define VK_LAUNCH_MEDIA_SELECT 0xB5
#define VK_LAUNCH_APP1 0xB6
#define VK_LAUNCH_APP2 0xB7

#define VK_OEM_1 0xBA
#define VK_OEM_PLUS 0xBB
#define VK_OEM_COMMA 0xBC
#define VK_OEM_MINUS 0xBD
#define VK_OEM_PERIOD 0xBE
#define VK_OEM_2 0xBF
#define VK_OEM_3 0xC0

#define VK_OEM_4 0xDB
#define VK_OEM_5 0xDC
#define VK_OEM_6 0xDD
#define VK_OEM_7 0xDE
#define VK_OEM_8 0xDF

#define VK_OEM_AX 0xE1
#define VK_OEM_102 0xE2
#define VK_ICO_HELP 0xE3
#define VK_ICO_00 0xE4
#define VK_PROCESSKEY 0xE5
#define VK_ICO_CLEAR 0xE6

#define VK_PACKET 0xE7

#define VK_OEM_RESET 0xE9
#define VK_OEM_JUMP 0xEA
#define VK_OEM_PA1 0xEB
#define VK_OEM_PA2 0xEC
#define VK_OEM_PA3 0xED
#define VK_OEM_WSCTRL 0xEE
#define VK_OEM_CUSEL 0xEF
#define VK_OEM_ATTN 0xF0
#define VK_OEM_FINISH 0xF1
#define VK_OEM_COPY 0xF2
#define VK_OEM_AUTO 0xF3
#define VK_OEM_ENLW 0xF4
#define VK_OEM_BACKTAB 0xF5

#define VK_ATTN 0xF6
#define VK_CRSEL 0xF7
#define VK_EXSEL 0xF8
#define VK_EREOF 0xF9
#define VK_PLAY 0xFA
#define VK_ZOOM 0xFB
#define VK_NONAME 0xFC
#define VK_PA1 0xFD
#define VK_OEM_CLEAR 0xFE

#define WM_NULL 0x0000
#define WM_CREATE 0x0001
#define WM_DESTROY 0x0002
#define WM_MOVE 0x0003
#define WM_SIZE 0x0005

#define WM_ACTIVATE 0x0006

#define WA_INACTIVE 0
#define WA_ACTIVE 1
#define WA_CLICKACTIVE 2

#define WM_SETFOCUS 0x0007
#define WM_KILLFOCUS 0x0008
#define WM_ENABLE 0x000A
#define WM_SETREDRAW 0x000B
#define WM_SETTEXT 0x000C
#define WM_GETTEXT 0x000D
#define WM_GETTEXTLENGTH 0x000E
#define WM_PAINT 0x000F
#define WM_CLOSE 0x0010
#ifndef _WIN32_WCE
#define WM_QUERYENDSESSION 0x0011
#define WM_QUERYOPEN 0x0013
#define WM_ENDSESSION 0x0016
#endif
#define WM_QUIT 0x0012
#define WM_ERASEBKGND 0x0014
#define WM_SYSCOLORCHANGE 0x0015
#define WM_SHOWWINDOW 0x0018
#define WM_WININICHANGE 0x001A
#define WM_SETTINGCHANGE WM_WININICHANGE

#define WM_DEVMODECHANGE 0x001B
#define WM_ACTIVATEAPP 0x001C
#define WM_FONTCHANGE 0x001D
#define WM_TIMECHANGE 0x001E
#define WM_CANCELMODE 0x001F
#define WM_SETCURSOR 0x0020
#define WM_MOUSEACTIVATE 0x0021
#define WM_CHILDACTIVATE 0x0022
#define WM_QUEUESYNC 0x0023

#define WM_GETMINMAXINFO 0x0024
#define WM_PAINTICON 0x0026
#define WM_ICONERASEBKGND 0x0027
#define WM_NEXTDLGCTL 0x0028
#define WM_SPOOLERSTATUS 0x002A
#define WM_DRAWITEM 0x002B
#define WM_MEASUREITEM 0x002C
#define WM_DELETEITEM 0x002D
#define WM_VKEYTOITEM 0x002E
#define WM_CHARTOITEM 0x002F
#define WM_SETFONT 0x0030
#define WM_GETFONT 0x0031
#define WM_SETHOTKEY 0x0032
#define WM_GETHOTKEY 0x0033
#define WM_QUERYDRAGICON 0x0037
#define WM_COMPAREITEM 0x0039
#ifndef _WIN32_WCE
#define WM_GETOBJECT 0x003D
#endif
#define WM_COMPACTING 0x0041
#define WM_COMMNOTIFY 0x0044
#define WM_WINDOWPOSCHANGING 0x0046
#define WM_WINDOWPOSCHANGED 0x0047

#define WM_POWER 0x0048

#define PWR_OK 1
#define PWR_FAIL (-1)
#define PWR_SUSPENDREQUEST 1
#define PWR_SUSPENDRESUME 2
#define PWR_CRITICALRESUME 3

#define WM_COPYDATA 0x004A
#define WM_CANCELJOURNAL 0x004B

#define WM_NOTIFY 0x004E
#define WM_INPUTLANGCHANGEREQUEST 0x0050
#define WM_INPUTLANGCHANGE 0x0051
#define WM_TCARD 0x0052
#define WM_HELP 0x0053
#define WM_USERCHANGED 0x0054
#define WM_NOTIFYFORMAT 0x0055

#define NFR_ANSI 1
#define NFR_UNICODE 2
#define NF_QUERY 3
#define NF_REQUERY 4

#define WM_CONTEXTMENU 0x007B
#define WM_STYLECHANGING 0x007C
#define WM_STYLECHANGED 0x007D
#define WM_DISPLAYCHANGE 0x007E
#define WM_GETICON 0x007F
#define WM_SETICON 0x0080

#define WM_NCCREATE 0x0081
#define WM_NCDESTROY 0x0082
#define WM_NCCALCSIZE 0x0083
#define WM_NCHITTEST 0x0084
#define WM_NCPAINT 0x0085
#define WM_NCACTIVATE 0x0086
#define WM_GETDLGCODE 0x0087
#ifndef _WIN32_WCE
#define WM_SYNCPAINT 0x0088
#endif
#define WM_NCMOUSEMOVE 0x00A0
#define WM_NCLBUTTONDOWN 0x00A1
#define WM_NCLBUTTONUP 0x00A2
#define WM_NCLBUTTONDBLCLK 0x00A3
#define WM_NCRBUTTONDOWN 0x00A4
#define WM_NCRBUTTONUP 0x00A5
#define WM_NCRBUTTONDBLCLK 0x00A6
#define WM_NCMBUTTONDOWN 0x00A7
#define WM_NCMBUTTONUP 0x00A8
#define WM_NCMBUTTONDBLCLK 0x00A9

#define WM_NCXBUTTONDOWN 0x00AB
#define WM_NCXBUTTONUP 0x00AC
#define WM_NCXBUTTONDBLCLK 0x00AD
#define WM_INPUT 0x00FF
#define WM_KEYFIRST 0x0100
#define WM_KEYDOWN 0x0100
#define WM_KEYUP 0x0101
#define WM_CHAR 0x0102
#define WM_DEADCHAR 0x0103
#define WM_SYSKEYDOWN 0x0104
#define WM_SYSKEYUP 0x0105
#define WM_SYSCHAR 0x0106
#define WM_SYSDEADCHAR 0x0107
#define WM_UNICHAR 0x0109
#define WM_KEYLAST 0x0109
#define UNICODE_NOCHAR 0xFFFF

#define WM_IME_STARTCOMPOSITION 0x010D
#define WM_IME_ENDCOMPOSITION 0x010E
#define WM_IME_COMPOSITION 0x010F
#define WM_IME_KEYLAST 0x010F
#define WM_INITDIALOG 0x0110
#define WM_COMMAND 0x0111
#define WM_SYSCOMMAND 0x0112
#define WM_TIMER 0x0113
#define WM_HSCROLL 0x0114
#define WM_VSCROLL 0x0115
#define WM_INITMENU 0x0116
#define WM_INITMENUPOPUP 0x0117
#define WM_MENUSELECT 0x011F
#define WM_MENUCHAR 0x0120
#define WM_ENTERIDLE 0x0121
#ifndef _WIN32_WCE
#define WM_MENURBUTTONUP 0x0122
#define WM_MENUDRAG 0x0123
#define WM_MENUGETOBJECT 0x0124
#define WM_UNINITMENUPOPUP 0x0125
#define WM_MENUCOMMAND 0x0126

#ifndef _WIN32_WCE
#define WM_CHANGEUISTATE 0x0127
#define WM_UPDATEUISTATE 0x0128
#define WM_QUERYUISTATE 0x0129

#define UIS_SET 1
#define UIS_CLEAR 2
#define UIS_INITIALIZE 3

#define UISF_HIDEFOCUS 0x1
#define UISF_HIDEACCEL 0x2
#define UISF_ACTIVE 0x4
#endif
#endif

#define WM_CTLCOLORMSGBOX 0x0132
#define WM_CTLCOLOREDIT 0x0133
#define WM_CTLCOLORLISTBOX 0x0134
#define WM_CTLCOLORBTN 0x0135
#define WM_CTLCOLORDLG 0x0136
#define WM_CTLCOLORSCROLLBAR 0x0137
#define WM_CTLCOLORSTATIC 0x0138
#define MN_GETHMENU 0x01E1

#define WM_MOUSEFIRST 0x0200
#define WM_MOUSEMOVE 0x0200
#define WM_LBUTTONDOWN 0x0201
#define WM_LBUTTONUP 0x0202
#define WM_LBUTTONDBLCLK 0x0203
#define WM_RBUTTONDOWN 0x0204
#define WM_RBUTTONUP 0x0205
#define WM_RBUTTONDBLCLK 0x0206
#define WM_MBUTTONDOWN 0x0207
#define WM_MBUTTONUP 0x0208
#define WM_MBUTTONDBLCLK 0x0209
#define WM_MOUSEWHEEL 0x020A
#define WM_XBUTTONDOWN 0x020B
#define WM_XBUTTONUP 0x020C
#define WM_XBUTTONDBLCLK 0x020D
#define WM_MOUSELAST 0x020D
#define WHEEL_DELTA 120
#define GET_WHEEL_DELTA_WPARAM(wParam) ((short)HIWORD(wParam))

#define WHEEL_PAGESCROLL (UINT_MAX)

#define GET_KEYSTATE_WPARAM(wParam) (LOWORD(wParam))
#define GET_NCHITTEST_WPARAM(wParam) ((short)LOWORD(wParam))
#define GET_XBUTTON_WPARAM(wParam) (HIWORD(wParam))

#define XBUTTON1 0x0001
#define XBUTTON2 0x0002

#define WM_PARENTNOTIFY 0x0210
#define WM_ENTERMENULOOP 0x0211
#define WM_EXITMENULOOP 0x0212

#define WM_NEXTMENU 0x0213
#define WM_SIZING 0x0214
#define WM_CAPTURECHANGED 0x0215
#define WM_MOVING 0x0216
#define WM_POWERBROADCAST 0x0218
#define WM_DEVICECHANGE 0x0219
#define WM_MDICREATE 0x0220
#define WM_MDIDESTROY 0x0221
#define WM_MDIACTIVATE 0x0222
#define WM_MDIRESTORE 0x0223
#define WM_MDINEXT 0x0224
#define WM_MDIMAXIMIZE 0x0225
#define WM_MDITILE 0x0226
#define WM_MDICASCADE 0x0227
#define WM_MDIICONARRANGE 0x0228
#define WM_MDIGETACTIVE 0x0229

#define WM_MDISETMENU 0x0230
#define WM_ENTERSIZEMOVE 0x0231
#define WM_EXITSIZEMOVE 0x0232
#define WM_DROPFILES 0x0233
#define WM_MDIREFRESHMENU 0x0234

#define WM_IME_SETCONTEXT 0x0281
#define WM_IME_NOTIFY 0x0282
#define WM_IME_CONTROL 0x0283
#define WM_IME_COMPOSITIONFULL 0x0284
#define WM_IME_SELECT 0x0285
#define WM_IME_CHAR 0x0286
#define WM_IME_REQUEST 0x0288
#define WM_IME_KEYDOWN 0x0290
#define WM_IME_KEYUP 0x0291

#define WM_MOUSEHOVER 0x02A1
#define WM_MOUSELEAVE 0x02A3
#define WM_NCMOUSEHOVER 0x02A0
#define WM_NCMOUSELEAVE 0x02A2

#define WM_WTSSESSION_CHANGE 0x02B1

#define WM_TABLET_FIRST 0x02c0
#define WM_TABLET_LAST 0x02df
#define WM_CUT 0x0300
#define WM_COPY 0x0301
#define WM_PASTE 0x0302
#define WM_CLEAR 0x0303
#define WM_UNDO 0x0304
#define WM_RENDERFORMAT 0x0305
#define WM_RENDERALLFORMATS 0x0306
#define WM_DESTROYCLIPBOARD 0x0307
#define WM_DRAWCLIPBOARD 0x0308
#define WM_PAINTCLIPBOARD 0x0309
#define WM_VSCROLLCLIPBOARD 0x030A
#define WM_SIZECLIPBOARD 0x030B
#define WM_ASKCBFORMATNAME 0x030C
#define WM_CHANGECBCHAIN 0x030D
#define WM_HSCROLLCLIPBOARD 0x030E
#define WM_QUERYNEWPALETTE 0x030F
#define WM_PALETTEISCHANGING 0x0310
#define WM_PALETTECHANGED 0x0311
#define WM_HOTKEY 0x0312

#define WM_PRINT 0x0317
#define WM_PRINTCLIENT 0x0318

#define WM_APPCOMMAND 0x0319
#define WM_THEMECHANGED 0x031A
#define WM_HANDHELDFIRST 0x0358
#define WM_HANDHELDLAST 0x035F
#define WM_AFXFIRST 0x0360
#define WM_AFXLAST 0x037F
#define WM_PENWINFIRST 0x0380
#define WM_PENWINLAST 0x038F
#define WM_APP 0x8000
#define WM_USER 0x0400

#define WMSZ_LEFT 1
#define WMSZ_RIGHT 2
#define WMSZ_TOP 3
#define WMSZ_TOPLEFT 4
#define WMSZ_TOPRIGHT 5
#define WMSZ_BOTTOM 6
#define WMSZ_BOTTOMLEFT 7
#define WMSZ_BOTTOMRIGHT 8

#ifndef NONCMESSAGES

#define HTERROR (-2)
#define HTTRANSPARENT (-1)
#define HTNOWHERE 0
#define HTCLIENT 1
#define HTCAPTION 2
#define HTSYSMENU 3
#define HTGROWBOX 4
#define HTSIZE HTGROWBOX
#define HTMENU 5
#define HTHSCROLL 6
#define HTVSCROLL 7
#define HTMINBUTTON 8
#define HTMAXBUTTON 9
#define HTLEFT 10
#define HTRIGHT 11
#define HTTOP 12
#define HTTOPLEFT 13
#define HTTOPRIGHT 14
#define HTBOTTOM 15
#define HTBOTTOMLEFT 16
#define HTBOTTOMRIGHT 17
#define HTBORDER 18
#define HTREDUCE HTMINBUTTON
#define HTZOOM HTMAXBUTTON
#define HTSIZEFIRST HTLEFT
#define HTSIZELAST HTBOTTOMRIGHT
#define HTOBJECT 19
#define HTCLOSE 20
#define HTHELP 21

#define SMTO_NORMAL 0x0000
#define SMTO_BLOCK 0x0001
#define SMTO_ABORTIFHUNG 0x0002
#define SMTO_NOTIMEOUTIFNOTHUNG 0x0008
#endif

#define MA_ACTIVATE 1
#define MA_ACTIVATEANDEAT 2
#define MA_NOACTIVATE 3
#define MA_NOACTIVATEANDEAT 4

#define ICON_SMALL 0
#define ICON_BIG 1
#define ICON_SMALL2 2
#define SIZE_RESTORED 0
#define SIZE_MINIMIZED 1
#define SIZE_MAXIMIZED 2
#define SIZE_MAXSHOW 3
#define SIZE_MAXHIDE 4

#define SIZENORMAL SIZE_RESTORED
#define SIZEICONIC SIZE_MINIMIZED
#define SIZEFULLSCREEN SIZE_MAXIMIZED
#define SIZEZOOMSHOW SIZE_MAXSHOW
#define SIZEZOOMHIDE SIZE_MAXHIDE

#define WVR_ALIGNTOP 0x0010
#define WVR_ALIGNLEFT 0x0020
#define WVR_ALIGNBOTTOM 0x0040
#define WVR_ALIGNRIGHT 0x0080
#define WVR_HREDRAW 0x0100
#define WVR_VREDRAW 0x0200
#define WVR_REDRAW (WVR_HREDRAW | WVR_VREDRAW)
#define WVR_VALIDRECTS 0x0400

#ifndef NOKEYSTATES

#define MK_LBUTTON 0x0001
#define MK_RBUTTON 0x0002
#define MK_SHIFT 0x0004
#define MK_CONTROL 0x0008
#define MK_MBUTTON 0x0010
#define MK_XBUTTON1 0x0020
#define MK_XBUTTON2 0x0040
#endif

#ifndef NOTRACKMOUSEEVENT
#define TME_HOVER 0x00000001
#define TME_LEAVE 0x00000002
#define TME_NONCLIENT 0x00000010
#define TME_QUERY 0x40000000
#define TME_CANCEL 0x80000000

#define HOVER_DEFAULT 0xFFFFFFFF
#endif

#define WS_OVERLAPPED 0x00000000L
#define WS_POPUP 0x80000000L
#define WS_CHILD 0x40000000L
#define WS_MINIMIZE 0x20000000L
#define WS_VISIBLE 0x10000000L
#define WS_DISABLED 0x08000000L
#define WS_CLIPSIBLINGS 0x04000000L
#define WS_CLIPCHILDREN 0x02000000L
#define WS_MAXIMIZE 0x01000000L
#define WS_CAPTION 0x00C00000L
#define WS_BORDER 0x00800000L
#define WS_DLGFRAME 0x00400000L
#define WS_VSCROLL 0x00200000L
#define WS_HSCROLL 0x00100000L
#define WS_SYSMENU 0x00080000L
#define WS_THICKFRAME 0x00040000L
#define WS_GROUP 0x00020000L
#define WS_TABSTOP 0x00010000L

#define WS_MINIMIZEBOX 0x00020000L
#define WS_MAXIMIZEBOX 0x00010000L

#define WS_TILED WS_OVERLAPPED
#define WS_ICONIC WS_MINIMIZE
#define WS_SIZEBOX WS_THICKFRAME
#define WS_TILEDWINDOW WS_OVERLAPPEDWINDOW

#define WS_OVERLAPPEDWINDOW (WS_OVERLAPPED | WS_CAPTION | WS_SYSMENU | WS_THICKFRAME | WS_MINIMIZEBOX | WS_MAXIMIZEBOX)

#define WS_POPUPWINDOW (WS_POPUP | WS_BORDER | WS_SYSMENU)

#define WS_CHILDWINDOW (WS_CHILD)

#define WS_EX_DLGMODALFRAME 0x00000001L
#define WS_EX_NOPARENTNOTIFY 0x00000004L
#define WS_EX_TOPMOST 0x00000008L
#define WS_EX_ACCEPTFILES 0x00000010L
#define WS_EX_TRANSPARENT 0x00000020L
#define WS_EX_MDICHILD 0x00000040L
#define WS_EX_TOOLWINDOW 0x00000080L
#define WS_EX_WINDOWEDGE 0x00000100L
#define WS_EX_CLIENTEDGE 0x00000200L
#define WS_EX_CONTEXTHELP 0x00000400L
#define WS_EX_RIGHT 0x00001000L
#define WS_EX_LEFT 0x00000000L
#define WS_EX_RTLREADING 0x00002000L
#define WS_EX_LTRREADING 0x00000000L
#define WS_EX_LEFTSCROLLBAR 0x00004000L
#define WS_EX_RIGHTSCROLLBAR 0x00000000L

#define WS_EX_CONTROLPARENT 0x00010000L
#define WS_EX_STATICEDGE 0x00020000L
#define WS_EX_APPWINDOW 0x00040000L

#define WS_EX_OVERLAPPEDWINDOW (WS_EX_WINDOWEDGE | WS_EX_CLIENTEDGE)
#define WS_EX_PALETTEWINDOW (WS_EX_WINDOWEDGE | WS_EX_TOOLWINDOW | WS_EX_TOPMOST)
#define WS_EX_LAYERED 0x00080000
#define WS_EX_NOINHERITLAYOUT 0x00100000L
#define WS_EX_LAYOUTRTL 0x00400000L
#define WS_EX_COMPOSITED 0x02000000L
#define WS_EX_NOACTIVATE 0x08000000L

#define CS_VREDRAW 0x0001
#define CS_HREDRAW 0x0002
#define CS_DBLCLKS 0x0008
#define CS_OWNDC 0x0020
#define CS_CLASSDC 0x0040
#define CS_PARENTDC 0x0080
#define CS_NOCLOSE 0x0200
#define CS_SAVEBITS 0x0800
#define CS_BYTEALIGNCLIENT 0x1000
#define CS_BYTEALIGNWINDOW 0x2000
#define CS_GLOBALCLASS 0x4000
#define CS_IME 0x00010000
#define CS_DROPSHADOW 0x00020000

#define CF_TEXT 1
#define CF_BITMAP 2
#define CF_METAFILEPICT 3
#define CF_SYLK 4
#define CF_DIF 5
#define CF_TIFF 6
#define CF_OEMTEXT 7
#define CF_DIB 8
#define CF_PALETTE 9
#define CF_PENDATA 10
#define CF_RIFF 11
#define CF_WAVE 12
#define CF_UNICODETEXT 13
#define CF_ENHMETAFILE 14
#define CF_HDROP 15
#define CF_LOCALE 16
#define CF_DIBV5 17

#define CF_MAX 18

#define CF_OWNERDISPLAY 0x0080
#define CF_DSPTEXT 0x0081
#define CF_DSPBITMAP 0x0082
#define CF_DSPMETAFILEPICT 0x0083
#define CF_DSPENHMETAFILE 0x008E

#define CF_PRIVATEFIRST 0x0200
#define CF_PRIVATELAST 0x02FF

#define CF_GDIOBJFIRST 0x0300
#define CF_GDIOBJLAST 0x03FF

#define MF_INSERT 0x00000000L
#define MF_CHANGE 0x00000080L
#define MF_APPEND 0x00000100L
#define MF_DELETE 0x00000200L
#define MF_REMOVE 0x00001000L

#define MF_BYCOMMAND 0x00000000L
#define MF_BYPOSITION 0x00000400L

#define MF_SEPARATOR 0x00000800L

#define MF_ENABLED 0x00000000L
#define MF_GRAYED 0x00000001L
#define MF_DISABLED 0x00000002L

#define MF_UNCHECKED 0x00000000L
#define MF_CHECKED 0x00000008L
#define MF_USECHECKBITMAPS 0x00000200L

#define MF_STRING 0x00000000L
#define MF_BITMAP 0x00000004L
#define MF_OWNERDRAW 0x00000100L

#define MF_POPUP 0x00000010L
#define MF_MENUBARBREAK 0x00000020L
#define MF_MENUBREAK 0x00000040L

#define MF_UNHILITE 0x00000000L
#define MF_HILITE 0x00000080L

#define MF_DEFAULT 0x00001000L
#define MF_SYSMENU 0x00002000L
#define MF_HELP 0x00004000L
#define MF_RIGHTJUSTIFY 0x00004000L
#define MF_MOUSESELECT 0x00008000L
#define MF_END 0x00000080L
#define MFT_STRING MF_STRING
#define MFT_BITMAP MF_BITMAP
#define MFT_MENUBARBREAK MF_MENUBARBREAK
#define MFT_MENUBREAK MF_MENUBREAK
#define MFT_OWNERDRAW MF_OWNERDRAW
#define MFT_RADIOCHECK 0x00000200L
#define MFT_SEPARATOR MF_SEPARATOR
#define MFT_RIGHTORDER 0x00002000L
#define MFT_RIGHTJUSTIFY MF_RIGHTJUSTIFY

#define MFS_GRAYED 0x00000003L
#define MFS_DISABLED MFS_GRAYED
#define MFS_CHECKED MF_CHECKED
#define MFS_HILITE MF_HILITE
#define MFS_ENABLED MF_ENABLED
#define MFS_UNCHECKED MF_UNCHECKED
#define MFS_UNHILITE MF_UNHILITE
#define MFS_DEFAULT MF_DEFAULT

#define MF_END 0x00000080L

#define SC_SIZE 0xF000
#define SC_MOVE 0xF010
#define SC_MINIMIZE 0xF020
#define SC_MAXIMIZE 0xF030
#define SC_NEXTWINDOW 0xF040
#define SC_PREVWINDOW 0xF050
#define SC_CLOSE 0xF060
#define SC_VSCROLL 0xF070
#define SC_HSCROLL 0xF080
#define SC_MOUSEMENU 0xF090
#define SC_KEYMENU 0xF100
#define SC_ARRANGE 0xF110
#define SC_RESTORE 0xF120
#define SC_TASKLIST 0xF130
#define SC_SCREENSAVE 0xF140
#define SC_HOTKEY 0xF150
#define SC_DEFAULT 0xF160
#define SC_MONITORPOWER 0xF170
#define SC_CONTEXTHELP 0xF180
#define SC_SEPARATOR 0xF00F

#define SC_ICON SC_MINIMIZE
#define SC_ZOOM SC_MAXIMIZE

#define OBM_CLOSE 32754
#define OBM_UPARROW 32753
#define OBM_DNARROW 32752
#define OBM_RGARROW 32751
#define OBM_LFARROW 32750
#define OBM_REDUCE 32749
#define OBM_ZOOM 32748
#define OBM_RESTORE 32747
#define OBM_REDUCED 32746
#define OBM_ZOOMD 32745
#define OBM_RESTORED 32744
#define OBM_UPARROWD 32743
#define OBM_DNARROWD 32742
#define OBM_RGARROWD 32741
#define OBM_LFARROWD 32740
#define OBM_MNARROW 32739
#define OBM_COMBO 32738
#define OBM_UPARROWI 32737
#define OBM_DNARROWI 32736
#define OBM_RGARROWI 32735
#define OBM_LFARROWI 32734

#define OBM_OLD_CLOSE 32767
#define OBM_SIZE 32766
#define OBM_OLD_UPARROW 32765
#define OBM_OLD_DNARROW 32764
#define OBM_OLD_RGARROW 32763
#define OBM_OLD_LFARROW 32762
#define OBM_BTSIZE 32761
#define OBM_CHECK 32760
#define OBM_CHECKBOXES 32759
#define OBM_BTNCORNERS 32758
#define OBM_OLD_REDUCE 32757
#define OBM_OLD_ZOOM 32756
#define OBM_OLD_RESTORE 32755

#define OCR_NORMAL 32512
#define OCR_IBEAM 32513
#define OCR_WAIT 32514
#define OCR_CROSS 32515
#define OCR_UP 32516
#define OCR_SIZE 32640
#define OCR_ICON 32641
#define OCR_SIZENWSE 32642
#define OCR_SIZENESW 32643
#define OCR_SIZEWE 32644
#define OCR_SIZENS 32645
#define OCR_SIZEALL 32646
#define OCR_ICOCUR 32647
#define OCR_NO 32648
#define OCR_HAND 32649
#define OCR_APPSTARTING 32650

#define OIC_SAMPLE 32512
#define OIC_HAND 32513
#define OIC_QUES 32514
#define OIC_BANG 32515
#define OIC_NOTE 32516
#define OIC_WINLOGO 32517
#define OIC_WARNING OIC_BANG
#define OIC_ERROR OIC_HAND
#define OIC_INFORMATION OIC_NOTE

#ifdef RC_INVOKED
#define IDI_APPLICATION 32512
#define IDI_HAND 32513
#define IDI_QUESTION 32514
#define IDI_EXCLAMATION 32515
#define IDI_ASTERISK 32516
#define IDI_WINLOGO 32517
#else
#define IDI_APPLICATION MAKEINTRESOURCE(32512)
#define IDI_HAND MAKEINTRESOURCE(32513)
#define IDI_QUESTION MAKEINTRESOURCE(32514)
#define IDI_EXCLAMATION MAKEINTRESOURCE(32515)
#define IDI_ASTERISK MAKEINTRESOURCE(32516)
#define IDI_WINLOGO MAKEINTRESOURCE(32517)
#endif

#define IDI_WARNING IDI_EXCLAMATION
#define IDI_ERROR IDI_HAND
#define IDI_INFORMATION IDI_ASTERISK

#define IDOK 1
#define IDCANCEL 2
#define IDABORT 3
#define IDRETRY 4
#define IDIGNORE 5
#define IDYES 6
#define IDNO 7
#define IDCLOSE 8
#define IDHELP 9

#define IDTRYAGAIN 10
#define IDCONTINUE 11

#ifndef IDTIMEOUT
#define IDTIMEOUT 32000
#endif

#define ES_LEFT 0x0000L
#define ES_CENTER 0x0001L
#define ES_RIGHT 0x0002L
#define ES_MULTILINE 0x0004L
#define ES_UPPERCASE 0x0008L
#define ES_LOWERCASE 0x0010L
#define ES_PASSWORD 0x0020L
#define ES_AUTOVSCROLL 0x0040L
#define ES_AUTOHSCROLL 0x0080L
#define ES_NOHIDESEL 0x0100L
#define ES_OEMCONVERT 0x0400L
#define ES_READONLY 0x0800L
#define ES_WANTRETURN 0x1000L
#define ES_NUMBER 0x2000L

#define EM_GETSEL 0x00B0
#define EM_SETSEL 0x00B1
#define EM_GETRECT 0x00B2
#define EM_SETRECT 0x00B3
#define EM_SETRECTNP 0x00B4
#define EM_SCROLL 0x00B5
#define EM_LINESCROLL 0x00B6
#define EM_SCROLLCARET 0x00B7
#define EM_GETMODIFY 0x00B8
#define EM_SETMODIFY 0x00B9
#define EM_GETLINECOUNT 0x00BA
#define EM_LINEINDEX 0x00BB
#define EM_SETHANDLE 0x00BC
#define EM_GETHANDLE 0x00BD
#define EM_GETTHUMB 0x00BE
#define EM_LINELENGTH 0x00C1
#define EM_REPLACESEL 0x00C2
#define EM_GETLINE 0x00C4
#define EM_LIMITTEXT 0x00C5
#define EM_CANUNDO 0x00C6
#define EM_UNDO 0x00C7
#define EM_FMTLINES 0x00C8
#define EM_LINEFROMCHAR 0x00C9
#define EM_SETTABSTOPS 0x00CB
#define EM_SETPASSWORDCHAR 0x00CC
#define EM_EMPTYUNDOBUFFER 0x00CD
#define EM_GETFIRSTVISIBLELINE 0x00CE
#define EM_SETREADONLY 0x00CF
#define EM_SETWORDBREAKPROC 0x00D0
#define EM_GETWORDBREAKPROC 0x00D1
#define EM_GETPASSWORDCHAR 0x00D2
#define EM_SETMARGINS 0x00D3
#define EM_GETMARGINS 0x00D4
#define EM_SETLIMITTEXT EM_LIMITTEXT
#define EM_GETLIMITTEXT 0x00D5
#define EM_POSFROMCHAR 0x00D6
#define EM_CHARFROMPOS 0x00D7
#define EM_SETIMESTATUS 0x00D8
#define EM_GETIMESTATUS 0x00D9

#define BS_PUSHBUTTON 0x00000000L
#define BS_DEFPUSHBUTTON 0x00000001L
#define BS_CHECKBOX 0x00000002L
#define BS_AUTOCHECKBOX 0x00000003L
#define BS_RADIOBUTTON 0x00000004L
#define BS_3STATE 0x00000005L
#define BS_AUTO3STATE 0x00000006L
#define BS_GROUPBOX 0x00000007L
#define BS_USERBUTTON 0x00000008L
#define BS_AUTORADIOBUTTON 0x00000009L
#define BS_PUSHBOX 0x0000000AL
#define BS_OWNERDRAW 0x0000000BL
#define BS_TYPEMASK 0x0000000FL
#define BS_LEFTTEXT 0x00000020L
#define BS_TEXT 0x00000000L
#define BS_ICON 0x00000040L
#define BS_BITMAP 0x00000080L
#define BS_LEFT 0x00000100L
#define BS_RIGHT 0x00000200L
#define BS_CENTER 0x00000300L
#define BS_TOP 0x00000400L
#define BS_BOTTOM 0x00000800L
#define BS_VCENTER 0x00000C00L
#define BS_PUSHLIKE 0x00001000L
#define BS_MULTILINE 0x00002000L
#define BS_NOTIFY 0x00004000L
#define BS_FLAT 0x00008000L
#define BS_RIGHTBUTTON BS_LEFTTEXT

#define BN_CLICKED 0
#define BN_PAINT 1
#define BN_HILITE 2
#define BN_UNHILITE 3
#define BN_DISABLE 4
#define BN_DOUBLECLICKED 5
#define BN_PUSHED BN_HILITE
#define BN_UNPUSHED BN_UNHILITE
#define BN_DBLCLK BN_DOUBLECLICKED
#define BN_SETFOCUS 6
#define BN_KILLFOCUS 7

#define BM_GETCHECK 0x00F0
#define BM_SETCHECK 0x00F1
#define BM_GETSTATE 0x00F2
#define BM_SETSTATE 0x00F3
#define BM_SETSTYLE 0x00F4
#define BM_CLICK 0x00F5
#define BM_GETIMAGE 0x00F6
#define BM_SETIMAGE 0x00F7

#define BST_UNCHECKED 0x0000
#define BST_CHECKED 0x0001
#define BST_INDETERMINATE 0x0002
#define BST_PUSHED 0x0004
#define BST_FOCUS 0x0008

#define SS_LEFT 0x00000000L
#define SS_CENTER 0x00000001L
#define SS_RIGHT 0x00000002L
#define SS_ICON 0x00000003L
#define SS_BLACKRECT 0x00000004L
#define SS_GRAYRECT 0x00000005L
#define SS_WHITERECT 0x00000006L
#define SS_BLACKFRAME 0x00000007L
#define SS_GRAYFRAME 0x00000008L
#define SS_WHITEFRAME 0x00000009L
#define SS_USERITEM 0x0000000AL
#define SS_SIMPLE 0x0000000BL
#define SS_LEFTNOWORDWRAP 0x0000000CL
#define SS_OWNERDRAW 0x0000000DL
#define SS_BITMAP 0x0000000EL
#define SS_ENHMETAFILE 0x0000000FL
#define SS_ETCHEDHORZ 0x00000010L
#define SS_ETCHEDVERT 0x00000011L
#define SS_ETCHEDFRAME 0x00000012L
#define SS_TYPEMASK 0x0000001FL
#define SS_REALSIZECONTROL 0x00000040L
#define SS_NOPREFIX 0x00000080L
#define SS_NOTIFY 0x00000100L
#define SS_CENTERIMAGE 0x00000200L
#define SS_RIGHTJUST 0x00000400L
#define SS_REALSIZEIMAGE 0x00000800L
#define SS_SUNKEN 0x00001000L
#define SS_EDITCONTROL 0x00002000L
#define SS_ENDELLIPSIS 0x00004000L
#define SS_PATHELLIPSIS 0x00008000L
#define SS_WORDELLIPSIS 0x0000C000L
#define SS_ELLIPSISMASK 0x0000C000L

#define DS_ABSALIGN 0x01L
#define DS_SYSMODAL 0x02L
#define DS_LOCALEDIT 0x20L
#define DS_SETFONT 0x40L
#define DS_MODALFRAME 0x80L
#define DS_NOIDLEMSG 0x100L
#define DS_SETFOREGROUND 0x200L

#define DS_3DLOOK 0x0004L
#define DS_FIXEDSYS 0x0008L
#define DS_NOFAILCREATE 0x0010L
#define DS_CONTROL 0x0400L
#define DS_CENTER 0x0800L
#define DS_CENTERMOUSE 0x1000L
#define DS_CONTEXTHELP 0x2000L

#define DS_SHELLFONT (DS_SETFONT | DS_FIXEDSYS)

#if(_WIN32_WCE >= 0x0500)
#define DS_USEPIXELS 0x8000L
#endif

#define LBS_NOTIFY 0x0001L
#define LBS_SORT 0x0002L
#define LBS_NOREDRAW 0x0004L
#define LBS_MULTIPLESEL 0x0008L
#define LBS_OWNERDRAWFIXED 0x0010L
#define LBS_OWNERDRAWVARIABLE 0x0020L
#define LBS_HASSTRINGS 0x0040L
#define LBS_USETABSTOPS 0x0080L
#define LBS_NOINTEGRALHEIGHT 0x0100L
#define LBS_MULTICOLUMN 0x0200L
#define LBS_WANTKEYBOARDINPUT 0x0400L
#define LBS_EXTENDEDSEL 0x0800L
#define LBS_DISABLENOSCROLL 0x1000L
#define LBS_NODATA 0x2000L
#define LBS_NOSEL 0x4000L
#define LBS_COMBOBOX 0x8000L

#define LBS_STANDARD (LBS_NOTIFY | LBS_SORT | WS_VSCROLL | WS_BORDER)

#define CBS_SIMPLE 0x0001L
#define CBS_DROPDOWN 0x0002L
#define CBS_DROPDOWNLIST 0x0003L
#define CBS_OWNERDRAWFIXED 0x0010L
#define CBS_OWNERDRAWVARIABLE 0x0020L
#define CBS_AUTOHSCROLL 0x0040L
#define CBS_OEMCONVERT 0x0080L
#define CBS_SORT 0x0100L
#define CBS_HASSTRINGS 0x0200L
#define CBS_NOINTEGRALHEIGHT 0x0400L
#define CBS_DISABLENOSCROLL 0x0800L
#define CBS_UPPERCASE 0x2000L
#define CBS_LOWERCASE 0x4000L

#define SBS_HORZ 0x0000L
#define SBS_VERT 0x0001L
#define SBS_TOPALIGN 0x0002L
#define SBS_LEFTALIGN 0x0002L
#define SBS_BOTTOMALIGN 0x0004L
#define SBS_RIGHTALIGN 0x0004L
#define SBS_SIZEBOXTOPLEFTALIGN 0x0002L
#define SBS_SIZEBOXBOTTOMRIGHTALIGN 0x0004L
#define SBS_SIZEBOX 0x0008L
#define SBS_SIZEGRIP 0x0010L

#define HELP_CONTEXT 0x0001L
#define HELP_QUIT 0x0002L
#define HELP_INDEX 0x0003L
#define HELP_CONTENTS 0x0003L
#define HELP_HELPONHELP 0x0004L
#define HELP_SETINDEX 0x0005L
#define HELP_SETCONTENTS 0x0005L
#define HELP_CONTEXTPOPUP 0x0008L
#define HELP_FORCEFILE 0x0009L
#define HELP_KEY 0x0101L
#define HELP_COMMAND 0x0102L
#define HELP_PARTIALKEY 0x0105L
#define HELP_MULTIKEY 0x0201L
#define HELP_SETWINPOS 0x0203L
#define HELP_CONTEXTMENU 0x000a
#define HELP_FINDER 0x000b
#define HELP_WM_HELP 0x000c
#define HELP_SETPOPUP_POS 0x000d

#define HELP_TCARD 0x8000
#define HELP_TCARD_DATA 0x0010
#define HELP_TCARD_OTHER_CALLER 0x0011

#define IDH_NO_HELP 28440
#define IDH_MISSING_CONTEXT 28441
#define IDH_GENERIC_HELP_BUTTON 28442
#define IDH_OK 28443
#define IDH_CANCEL 28444
#define IDH_HELP 28445

#endif  /* ndef _WINUSER_ */

```

`data/lib/gcc/i686-w64-mingw32/10.2.0/include/winver.h`:

```h
#ifndef VER_H
#define VER_H

#define VS_FILE_INFO RT_VERSION
#define VS_VERSION_INFO 1
#define VS_USER_DEFINED 100

#define VS_FFI_SIGNATURE 0xFEEF04BD
#define VS_FFI_STRUCVERSION 0x00010000
#define VS_FFI_FILEFLAGSMASK 0x0000003F

#define VS_FF_DEBUG 0x00000001
#define VS_FF_PRERELEASE 0x00000002
#define VS_FF_PATCHED 0x00000004
#define VS_FF_PRIVATEBUILD 0x00000008
#define VS_FF_INFOINFERRED 0x00000010
#define VS_FF_SPECIALBUILD 0x00000020

#define VOS_UNKNOWN 0x00000000
#define VOS_DOS 0x00010000
#define VOS_OS216 0x00020000
#define VOS_OS232 0x00030000
#define VOS_NT 0x00040000
#define VOS_WINCE 0x00050000

#define VOS__BASE 0x00000000
#define VOS__WINDOWS16 0x00000001
#define VOS__PM16 0x00000002
#define VOS__PM32 0x00000003
#define VOS__WINDOWS32 0x00000004

#define VOS_DOS_WINDOWS16 0x00010001
#define VOS_DOS_WINDOWS32 0x00010004
#define VOS_OS216_PM16 0x00020002
#define VOS_OS232_PM32 0x00030003
#define VOS_NT_WINDOWS32 0x00040004

#define VFT_UNKNOWN 0x00000000
#define VFT_APP 0x00000001
#define VFT_DLL 0x00000002
#define VFT_DRV 0x00000003
#define VFT_FONT 0x00000004
#define VFT_VXD 0x00000005
#define VFT_STATIC_LIB 0x00000007

#define VFT2_UNKNOWN 0x00000000
#define VFT2_DRV_PRINTER 0x00000001
#define VFT2_DRV_KEYBOARD 0x00000002
#define VFT2_DRV_LANGUAGE 0x00000003
#define VFT2_DRV_DISPLAY 0x00000004
#define VFT2_DRV_MOUSE 0x00000005
#define VFT2_DRV_NETWORK 0x00000006
#define VFT2_DRV_SYSTEM 0x00000007
#define VFT2_DRV_INSTALLABLE 0x00000008
#define VFT2_DRV_SOUND 0x00000009
#define VFT2_DRV_COMM 0x0000000A
#define VFT2_DRV_INPUTMETHOD 0x0000000B
#define VFT2_DRV_VERSIONED_PRINTER 0x0000000C

#define VFT2_FONT_RASTER 0x00000001
#define VFT2_FONT_VECTOR 0x00000002
#define VFT2_FONT_TRUETYPE 0x00000003

#define VFFF_ISSHAREDFILE 0x0001

#define VFF_CURNEDEST 0x0001
#define VFF_FILEINUSE 0x0002
#define VFF_BUFFTOOSMALL 0x0004

#define VIFF_FORCEINSTALL 0x0001
#define VIFF_DONTDELETEOLD 0x0002

#define VIF_TEMPFILE 0x00000001
#define VIF_MISMATCH 0x00000002
#define VIF_SRCOLD 0x00000004

#define VIF_DIFFLANG 0x00000008
#define VIF_DIFFCODEPG 0x00000010
#define VIF_DIFFTYPE 0x00000020

#define VIF_WRITEPROT 0x00000040
#define VIF_FILEINUSE 0x00000080
#define VIF_OUTOFSPACE 0x00000100
#define VIF_ACCESSVIOLATION 0x00000200
#define VIF_SHARINGVIOLATION 0x00000400
#define VIF_CANNOTCREATE 0x00000800
#define VIF_CANNOTDELETE 0x00001000
#define VIF_CANNOTRENAME 0x00002000
#define VIF_CANNOTDELETECUR 0x00004000
#define VIF_OUTOFMEMORY 0x00008000

#define VIF_CANNOTREADSRC 0x00010000
#define VIF_CANNOTREADDST 0x00020000

#define VIF_BUFFTOOSMALL 0x00040000
#define VIF_CANNOTLOADLZ32 0x00080000
#define VIF_CANNOTLOADCABINET 0x00100000

#endif

```

`installer.iss`:

```iss
; Script generated by the Inno Setup Script Wizard.
; SEE THE DOCUMENTATION FOR DETAILS ON CREATING INNO SETUP SCRIPT FILES!
; !!! This file must be UTF-8 with BOM !!!

[Setup]
; NOTE: The value of AppId uniquely identifies this application.
; Do not use the same AppId value in installers for other applications.
; (To generate a new GUID, click Tools | Generate GUID inside the IDE.)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; TODO: Update the version numbers
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

#define MyAppName        "RisohEditor"
#define MyAppVersion     "5.7.9"
#define MyAppCompanyName "Katayama Hirofumi MZ"
#define MyAppCopyright   "(C) 2017-2023 Katayama Hirofumi MZ."
#define MyAppURL         "http://katahiromz.web.fc2.com/"
#define MyAppDescription "Resource Editor (32bit)"

AppId={{AF7494D1-406F-4D04-A8FE-8F9DAB97F611}
AppName={#MyAppName}
AppVersion={#MyAppVersion}
AppVerName={#MyAppName} {#MyAppVersion}
AppPublisher={#MyAppCompanyName}
AppPublisherURL={#MyAppURL}
AppSupportURL={#MyAppURL}
AppUpdatesURL={#MyAppURL}
DefaultDirName={pf}\{#MyAppName}
DefaultGroupName={#MyAppName}
DisableDirPage=no
AllowNoIcons=yes
LicenseFile=LICENSE.txt
OutputDir=.
OutputBaseFilename={#MyAppName}-{#MyAppVersion}-installer
SetupIconFile=src\res\Icon_100.ico
Compression=lzma
SolidCompression=yes
UninstallDisplayIcon={app}\{#MyAppName}.exe
UsePreviousAppDir=yes
VersionInfoCompany={#MyAppCompanyName}
VersionInfoCopyright={#MyAppCopyright}
VersionInfoDescription={#MyAppDescription}
VersionInfoProductName={#MyAppName}
VersionInfoProductTextVersion={#MyAppVersion}
VersionInfoProductVersion={#MyAppVersion}
VersionInfoVersion={#MyAppVersion}

[Languages]
Name: "brazilianportuguese"; MessagesFile:  "compiler:Languages\BrazilianPortuguese.isl"
Name: "catalan"; MessagesFile:  "compiler:Languages\Catalan.isl"
Name: "corsican"; MessagesFile:  "compiler:Languages\Corsican.isl"
Name: "czech"; MessagesFile:  "compiler:Languages\Czech.isl"
Name: "danish"; MessagesFile:  "compiler:Languages\Danish.isl"
Name: "dutch"; MessagesFile:  "compiler:Languages\Dutch.isl"
Name: "english"; MessagesFile:  "compiler:Default.isl"
Name: "finnish"; MessagesFile:  "compiler:Languages\Finnish.isl"
Name: "french"; MessagesFile:  "compiler:Languages\French.isl"
Name: "german"; MessagesFile:  "compiler:Languages\German.isl"
Name: "greek"; MessagesFile:  "compiler:Languages\Greek.isl"
Name: "hebrew"; MessagesFile:  "compiler:Languages\Hebrew.isl"
Name: "hungarian"; MessagesFile:  "compiler:Languages\Hungarian.isl"
Name: "italian"; MessagesFile:  "compiler:Languages\Italian.isl"
Name: "korean"; MessagesFile: ".\Languages\Korean.isl"
Name: "japanese"; MessagesFile: "compiler:Languages\Japanese.isl"
Name: "norwegian"; MessagesFile: "compiler:Languages\Norwegian.isl"
Name: "polish"; MessagesFile: "compiler:Languages\Polish.isl"
Name: "portuguese"; MessagesFile: "compiler:Languages\Portuguese.isl"
Name: "russian"; MessagesFile: "compiler:Languages\Russian.isl"
Name: "scottishgaelic"; MessagesFile: "compiler:Languages\ScottishGaelic.isl"
Name: "serbiancyrillic"; MessagesFile: "compiler:Languages\SerbianCyrillic.isl"
Name: "serbianlatin"; MessagesFile: "compiler:Languages\SerbianLatin.isl"
Name: "slovenian"; MessagesFile: "compiler:Languages\Slovenian.isl"
Name: "spanish"; MessagesFile: "compiler:Languages\Spanish.isl"
Name: "turkish"; MessagesFile: "compiler:Languages\Turkish.isl"
Name: "ukrainian"; MessagesFile: "compiler:Languages\Ukrainian.isl"

[Tasks]
Name: "desktopicon"; Description: "{cm:CreateDesktopIcon}"; GroupDescription: "{cm:AdditionalIcons}"
Name: "rc_association"; Description: "{cm:AssociateRcFiles}"
Name: "res_association"; Description: "{cm:AssociateResFiles}"

[Files]
Source: "README.txt"; DestDir: "{app}"; Flags: ignoreversion
Source: "README-ID.txt"; DestDir: "{app}"; Flags: ignoreversion
Source: "README-ITA.txt"; DestDir: "{app}"; Flags: ignoreversion
Source: "README-JPN.txt"; DestDir: "{app}"; Flags: ignoreversion
Source: "README-KOR.txt"; DestDir: "{app}"; Flags: ignoreversion
Source: "README-TR.txt"; DestDir: "{app}"; Flags: ignoreversion
Source: "README-PTB.txt"; DestDir: "{app}"; Flags: ignoreversion
Source: "LICENSE.txt"; DestDir: "{app}"; Flags: ignoreversion
Source: "HISTORY.txt"; DestDir: "{app}"; Flags: ignoreversion
Source: "HISTORY-ID.txt"; DestDir: "{app}"; Flags: ignoreversion
Source: "HISTORY-ITA.txt"; DestDir: "{app}"; Flags: ignoreversion
Source: "HISTORY-JPN.txt"; DestDir: "{app}"; Flags: ignoreversion
Source: "HISTORY-KOR.txt"; DestDir: "{app}"; Flags: ignoreversion
Source: "HISTORY-PTB.txt"; DestDir: "{app}"; Flags: ignoreversion
Source: "Standardize.md"; DestDir: "{app}"; Flags: ignoreversion
Source: "HYOJUNKA.txt"; DestDir: "{app}"; Flags: ignoreversion
Source: "TRANSLATORS.txt"; DestDir: "{app}"; Flags: ignoreversion
Source: "mcdx\MESSAGETABLEDX.md"; DestDir: "{app}"; Flags: ignoreversion
Source: "build\RisohEditor.exe"; DestDir: "{app}"; Flags: ignoreversion
Source: "src\resource.h"; DestDir: "{app}"; Flags: ignoreversion
Source: "data\Constants.txt"; DestDir: "{app}\data"; Flags: ignoreversion
Source: "build\mcdx.exe"; DestDir: "{app}\data\bin"; Flags: ignoreversion
Source: "src\MOleHost.hpp"; DestDir: "{app}\OLE"; Flags: ignoreversion
Source: "src\MOleHost.cpp"; DestDir: "{app}\OLE"; Flags: ignoreversion
Source: "src\MWindowBase.hpp"; DestDir: "{app}\OLE"; Flags: ignoreversion
Source: "src\DlgInit.h"; DestDir: "{app}\DlgInit"; Flags: ignoreversion
Source: "src\Toolbar.h"; DestDir: "{app}\Toolbar"; Flags: ignoreversion
Source: "MyWndCtrl\MWindowBase.hpp"; DestDir: "{app}\MyWndCtrl"; Flags: ignoreversion
Source: "MyWndCtrl\MyWndCtrl.cpp"; DestDir: "{app}\MyWndCtrl"; Flags: ignoreversion
Source: "MyWndCtrl\CMakeLists.txt"; DestDir: "{app}\MyWndCtrl"; Flags: ignoreversion
Source: "build\MyWndCtrl.dll"; DestDir: "{app}\MyWndCtrl"; Flags: ignoreversion
Source: "data\bin\libgcc_s_dw2-1.dll"; DestDir: "{app}\data\bin"; Flags: ignoreversion
Source: "data\bin\libwinpthread-1.dll"; DestDir: "{app}\data\bin"; Flags: ignoreversion
Source: "data\bin\windres.exe"; DestDir: "{app}\data\bin"; Flags: ignoreversion
Source: "data\bin\upx.exe"; DestDir: "{app}\data\bin"; Flags: ignoreversion
Source: "data\bin\mcpp.exe"; DestDir: "{app}\data\bin"; Flags: ignoreversion
Source: "data\bin\dfmsc.exe"; DestDir: "{app}\data\bin"; Flags: ignoreversion
Source: "data\bin\olebow.exe"; DestDir: "{app}\data\bin"; Flags: ignoreversion
Source: "data\bin\midlwrap.bat"; DestDir: "{app}\data\bin"; Flags: ignoreversion
Source: "EGA\EGA-Manual.pdf"; DestDir: "{app}\EGA"; Flags: ignoreversion
Source: "EGA\samples\fact.ega"; DestDir: "{app}\EGA"; Flags: ignoreversion
Source: "EGA\samples\plus.ega"; DestDir: "{app}\EGA"; Flags: ignoreversion
Source: "EGA\samples\break.ega"; DestDir: "{app}\EGA"; Flags: ignoreversion
Source: "EGA-samples\Censorship.ega"; DestDir: "{app}\EGA"; Flags: ignoreversion
Source: "EGA-samples\DeleteNonEnglish.ega"; DestDir: "{app}\EGA"; Flags: ignoreversion
Source: "EGA-samples\NeutralToEnglish.ega"; DestDir: "{app}\EGA"; Flags: ignoreversion
Source: "EGA-samples\RES_clone_by_lang.ega"; DestDir: "{app}\EGA"; Flags: ignoreversion
Source: "EGA-samples\RES_delete.ega"; DestDir: "{app}\EGA"; Flags: ignoreversion
Source: "EGA-samples\RES_select.ega"; DestDir: "{app}\EGA"; Flags: ignoreversion
Source: "EGA-samples\RES_set_binary.ega"; DestDir: "{app}\EGA"; Flags: ignoreversion
Source: "EGA-samples\RES_set_text.ega"; DestDir: "{app}\EGA"; Flags: ignoreversion
Source: "EGA-samples\RES_str_get.ega"; DestDir: "{app}\EGA"; Flags: ignoreversion
Source: "EGA-samples\RES_str_set.ega"; DestDir: "{app}\EGA"; Flags: ignoreversion
Source: "data\lib\gcc\i686-w64-mingw32\10.2.0\include\commctrl.h"; DestDir: "{app}\data\lib\gcc\i686-w64-mingw32\10.2.0\include"; Flags: ignoreversion
Source: "data\lib\gcc\i686-w64-mingw32\10.2.0\include\dlgs.h"; DestDir: "{app}\data\lib\gcc\i686-w64-mingw32\10.2.0\include"; Flags: ignoreversion
Source: "data\lib\gcc\i686-w64-mingw32\10.2.0\include\windef.h"; DestDir: "{app}\data\lib\gcc\i686-w64-mingw32\10.2.0\include"; Flags: ignoreversion
Source: "data\lib\gcc\i686-w64-mingw32\10.2.0\include\windows.h"; DestDir: "{app}\data\lib\gcc\i686-w64-mingw32\10.2.0\include"; Flags: ignoreversion
Source: "data\lib\gcc\i686-w64-mingw32\10.2.0\include\winnt.h"; DestDir: "{app}\data\lib\gcc\i686-w64-mingw32\10.2.0\include"; Flags: ignoreversion
Source: "data\lib\gcc\i686-w64-mingw32\10.2.0\include\winresrc.h"; DestDir: "{app}\data\lib\gcc\i686-w64-mingw32\10.2.0\include"; Flags: ignoreversion
Source: "data\lib\gcc\i686-w64-mingw32\10.2.0\include\winuser.h"; DestDir: "{app}\data\lib\gcc\i686-w64-mingw32\10.2.0\include"; Flags: ignoreversion
Source: "data\lib\gcc\i686-w64-mingw32\10.2.0\include\winver.h"; DestDir: "{app}\data\lib\gcc\i686-w64-mingw32\10.2.0\include"; Flags: ignoreversion
Source: "data\lib\gcc\i686-w64-mingw32\10.2.0\include\afxres.h"; DestDir: "{app}\data\lib\gcc\i686-w64-mingw32\10.2.0\include"; Flags: ignoreversion
Source: "win32-samples\DialogBox\.gitignore"; DestDir: "{app}\win32-samples\DialogBox"; Flags: ignoreversion
Source: "win32-samples\DialogBox\CMakeLists.txt"; DestDir: "{app}\win32-samples\DialogBox"; Flags: ignoreversion
Source: "win32-samples\DialogBox\DialogBox.cpp"; DestDir: "{app}\win32-samples\DialogBox"; Flags: ignoreversion
Source: "win32-samples\DialogBox\DialogBox_res.rc"; DestDir: "{app}\win32-samples\DialogBox"; Flags: ignoreversion
Source: "win32-samples\DialogBox\resource.h"; DestDir: "{app}\win32-samples\DialogBox"; Flags: ignoreversion
Source: "win32-samples\DialogBox\lang\en_US.rc"; DestDir: "{app}\win32-samples\DialogBox\lang"; Flags: ignoreversion
Source: "win32-samples\MainWnd\.gitignore"; DestDir: "{app}\win32-samples\MainWnd"; Flags: ignoreversion
Source: "win32-samples\MainWnd\CMakeLists.txt"; DestDir: "{app}\win32-samples\MainWnd"; Flags: ignoreversion
Source: "win32-samples\MainWnd\MainWnd.cpp"; DestDir: "{app}\win32-samples\MainWnd"; Flags: ignoreversion
Source: "win32-samples\MainWnd\MainWnd_res.rc"; DestDir: "{app}\win32-samples\MainWnd"; Flags: ignoreversion
Source: "win32-samples\MainWnd\resource.h"; DestDir: "{app}\win32-samples\MainWnd"; Flags: ignoreversion
Source: "win32-samples\MainWnd\lang\en_US.rc"; DestDir: "{app}\win32-samples\MainWnd\lang"; Flags: ignoreversion
Source: "win32-samples\MainWnd\res\Icon_100.ico"; DestDir: "{app}\win32-samples\MainWnd\res"; Flags: ignoreversion
Source: "win32-samples\ToolbarTest\CMakeLists.txt"; DestDir: "{app}\win32-samples\ToolbarTest"; Flags: ignoreversion
Source: "win32-samples\ToolbarTest\ToolbarTest.cpp"; DestDir: "{app}\win32-samples\ToolbarTest"; Flags: ignoreversion
Source: "win32-samples\ToolbarTest\ToolbarTest_res.rc"; DestDir: "{app}\win32-samples\ToolbarTest"; Flags: ignoreversion
Source: "win32-samples\ToolbarTest\lang\en_US.rc"; DestDir: "{app}\win32-samples\ToolbarTest\lang"; Flags: ignoreversion
Source: "win32-samples\ToolbarTest\res\Bitmap_100.bmp"; DestDir: "{app}\win32-samples\ToolbarTest\res"; Flags: ignoreversion
Source: "win32-samples\ToolbarTest\resource.h"; DestDir: "{app}\win32-samples\ToolbarTest"; Flags: ignoreversion
; NOTE: Don't use "Flags: ignoreversion" on any shared system files

[Icons]
Name: "{group}\RisohEditor"; Filename: "{app}\RisohEditor.exe"
Name: "{group}\{cm:ReadmeEnglish}"; Filename: "{app}\README.txt"
Name: "{group}\{cm:ReadmeJapanese}"; Filename: "{app}\READMEJP.txt"
Name: "{group}\{cm:LicenseEnglish}"; Filename: "{app}\LICENSE.txt"
Name: "{group}\{cm:ProgramOnTheWeb,RisohEditor}"; Filename: "http://katahiromz.web.fc2.com"
Name: "{group}\{cm:UninstallProgram,RisohEditor}"; Filename: "{uninstallexe}"
Name: "{commondesktop}\RisohEditor"; Filename: "{app}\RisohEditor.exe"; Tasks: desktopicon

[Run]
Filename: "{app}\RisohEditor.exe"; Description: "{cm:LaunchProgram,RisohEditor}"; Flags: nowait postinstall skipifsilent

[Registry]
Root: HKCU; Subkey: "Software\Katayama Hirofumi MZ\RisohEditor"; Flags: deletekey uninsdeletekey
; .rc
Root: HKCR; Subkey: ".rc"; ValueType: string; ValueName: ""; ValueData: "RisohEditor.ResourceFile"; Flags: uninsdeletevalue; Tasks: "rc_association"
Root: HKCR; Subkey: "RisohEditor.ResourceFile"; ValueType: string; ValueName: ""; ValueData: "RisohEditor Resource File"; Flags: uninsdeletekey; Tasks: "rc_association"
Root: HKCR; Subkey: "RisohEditor.ResourceFile\DefaultIcon"; ValueType: string; ValueName: ""; ValueData: "{app}\RisohEditor.exe,0"; Tasks: "rc_association"
Root: HKCR; Subkey: "RisohEditor.ResourceFile\shell\open\command"; ValueType: string; ValueName: ""; ValueData: """{app}\RisohEditor.exe"" ""%1"""; Tasks: "rc_association"
; .res
Root: HKCR; Subkey: ".res"; ValueType: string; ValueName: ""; ValueData: "RisohEditor.BinaryResourceFile"; Flags: uninsdeletevalue; Tasks: "res_association"
Root: HKCR; Subkey: "RisohEditor.BinaryResourceFile"; ValueType: string; ValueName: ""; ValueData: "RisohEditor Binary Resource File"; Flags: uninsdeletekey; Tasks: "res_association"
Root: HKCR; Subkey: "RisohEditor.BinaryResourceFile\DefaultIcon"; ValueType: string; ValueName: ""; ValueData: "{app}\RisohEditor.exe,0"; Tasks: "res_association"
Root: HKCR; Subkey: "RisohEditor.BinaryResourceFile\shell\open\command"; ValueType: string; ValueName: ""; ValueData: """{app}\RisohEditor.exe"" ""%1"""; Tasks: "res_association"

[CustomMessages]
brazilianportuguese.ReadmeEnglish=ReadMe (inglês)
brazilianportuguese.ReadmeJapanese=ReadMe (japonês)
brazilianportuguese.LicenseEnglish=Licença
brazilianportuguese.AssociateRcFiles=Associar arquivos *.rc
brazilianportuguese.AssociateResFiles=Associar arquivos *.res
catalan.ReadmeEnglish=ReadMe (English)
catalan.ReadmeJapanese=ReadMe (Japanese)
catalan.LicenseEnglish=License
catalan.AssociateRcFiles=Associate *.rc files
catalan.AssociateResFiles=Associate *.res files
corsican.ReadmeEnglish=ReadMe (English)
corsican.ReadmeJapanese=ReadMe (Japanese)
corsican.LicenseEnglish=License
corsican.AssociateRcFiles=Associate *.rc files
corsican.AssociateResFiles=Associate *.res files
czech.ReadmeEnglish=ReadMe (anglicky)
czech.ReadmeJapanese=ReadMe (japonština)
czech.LicenseEnglish=Licence
czech.AssociateRcFiles=Přidružit soubory *.rc
czech.AssociateResFiles=Přiřadit soubory *.res
danish.ReadmeEnglish=ReadMe (engelsk)
danish.ReadmeJapanese=ReadMe (japansk)
danish.LicenseEnglish=Licens
danish.AssociateRcFiles=Associerede *.rc-filer
danish.AssociateResFiles=Tilknyttede *.res-filer
dutch.ReadmeEnglish=ReadMe (Engels)
dutch.ReadmeJapanese=ReadMe (Japans)
dutch.LicenseEnglish=Licentie
dutch.AssociateRcFiles=Koppel *.rc-bestanden
dutch.AssociateResFiles=Koppel *.res-bestanden
english.ReadmeEnglish=ReadMe (English)
english.ReadmeJapanese=ReadMe (Japanese)
english.LicenseEnglish=License
english.AssociateRcFiles=Associate *.rc files
english.AssociateResFiles=Associate *.res files
finnish.ReadmeEnglish=ReadMe (englanti)
finnish.ReadmeJapanese=ReadMe (Japans)
finnish.LicenseEnglish=Lisenssi
finnish.AssociateRcFiles=Liitä *.rc-tiedostot
finnish.AssociateResFiles=Liitä *.res-tiedostot
french.ReadmeEnglish=ReadMe (anglais)
french.ReadmeJapanese=ReadMe (japonais)
french.LicenseEnglish=Licence
french.AssociateRcFiles=Associer des fichiers *.rc
french.AssociateResFiles=Associer des fichiers *.res
german.ReadmeEnglish=ReadMe (Englisch)
german.ReadmeJapanese=ReadMe (Japanisch)
german.LicenseEnglish=Lizenz
german.AssociateRcFiles=Verknüpfen Sie *.rc-Dateien
german.AssociateResFiles=Verknüpfen Sie *.res-Dateien
greek.ReadmeEnglish=ReadMe (Αγγλικά)
greek.ReadmeJapanese=ReadMe (Ιαπωνικά)
greek.LicenseEnglish=Αδεια
greek.AssociateRcFiles=Συσχετίστε αρχεία *.rc
greek.AssociateResFiles=Συσχετίστε αρχεία *.res
hebrew.ReadmeEnglish=ReadMe (אנגלית)
hebrew.ReadmeJapanese=ReadMe (יפנית)
hebrew.LicenseEnglish=רישיון
hebrew.AssociateRcFiles=לשייך קבצי *.rc
hebrew.AssociateResFiles=שיוך קבצי *.res
hungarian.ReadmeEnglish=ReadMe (angol)
hungarian.ReadmeJapanese=ReadMe (japán)
hungarian.LicenseEnglish=Engedély
hungarian.AssociateRcFiles=*.rc fájlok társítása
hungarian.AssociateResFiles=*.res fájlok társítása
italian.ReadmeEnglish=Leggimi (Inglese)
italian.ReadmeJapanese=Leggimi (Giapponese)
italian.LicenseEnglish=Licenza (Inglese)
italian.AssociateRcFiles=Associa file *.rc
italian.AssociateResFiles=Associa file *.res
korean.ReadmeEnglish=ReadMe (영어)
korean.ReadmeJapanese=ReadMe (일본어)
korean.LicenseEnglish=License (영어)
korean.AssociateRcFiles=*.rc 파일 연결
korean.AssociateResFiles=*.res 파일 연결
japanese.ReadmeEnglish=ReadMe (英語)
japanese.ReadmeJapanese=読んでね (日本語)
japanese.LicenseEnglish=ライセンス (英語)
japanese.AssociateRcFiles=*.rc ファイルを関連付ける
japanese.AssociateResFiles=*.res ファイルを関連付ける
norwegian.ReadmeEnglish=ReadMe (engelsk)
norwegian.ReadmeJapanese=ReadMe (japansk)
norwegian.LicenseEnglish=Tillatelse
norwegian.AssociateRcFiles=Tilknytt *.rc-filer
norwegian.AssociateResFiles=Tilknytt *.res-filer
polish.ReadmeEnglish=ReadMe (angielski)
polish.ReadmeJapanese=ReadMe (japoński)
polish.LicenseEnglish=Licencja
polish.AssociateRcFiles=Skojarz pliki *.rc
polish.AssociateResFiles=Skojarz pliki *.res
portuguese.ReadmeEnglish=ReadMe (inglês)
portuguese.ReadmeJapanese=ReadMe (japonês)
portuguese.LicenseEnglish=Licença
portuguese.AssociateRcFiles=Associar arquivos *.rc
portuguese.AssociateResFiles=Associar arquivos *.res
russian.ReadmeEnglish=ReadMe (английский)
russian.ReadmeJapanese=ReadMe (японский)
russian.LicenseEnglish=Лицензия
russian.AssociateRcFiles=Связать с файлами *.rc
russian.AssociateResFiles=Связать с файлами *.res
scottishgaelic.ReadmeEnglish=ReadMe (English)
scottishgaelic.ReadmeJapanese=ReadMe (Japanese)
scottishgaelic.LicenseEnglish=License
scottishgaelic.AssociateRcFiles=Associate *.rc files
scottishgaelic.AssociateResFiles=Associate *.res files
serbiancyrillic.ReadmeEnglish=ReadMe (English)
serbiancyrillic.ReadmeJapanese=ReadMe (Japanese)
serbiancyrillic.LicenseEnglish=License
serbiancyrillic.AssociateRcFiles=Associate *.rc files
serbiancyrillic.AssociateResFiles=Associate *.res files
serbianlatin.ReadmeEnglish=ReadMe (English)
serbianlatin.ReadmeJapanese=ReadMe (Japanese)
serbianlatin.LicenseEnglish=License
serbianlatin.AssociateRcFiles=Associate *.rc files
serbianlatin.AssociateResFiles=Associate *.res files
slovenian.ReadmeEnglish=ReadMe (English)
slovenian.ReadmeJapanese=ReadMe (Japanese)
slovenian.LicenseEnglish=License
slovenian.AssociateRcFiles=Associate *.rc files
slovenian.AssociateResFiles=Associate *.res files
spanish.ReadmeEnglish=ReadMe (inglés)
spanish.ReadmeJapanese=Léame (japonés)
spanish.LicenseEnglish=Licencia
spanish.AssociateRcFiles=Asociar archivos *.rc
spanish.AssociateResFiles=Asociar archivos *.res
turkish.ReadmeEnglish=ReadMe (İngilizce)
turkish.ReadmeJapanese=ReadMe (Japonca)
turkish.LicenseEnglish=Lisans
turkish.AssociateRcFiles=*.rc dosyalarını ilişkilendirin
turkish.AssociateResFiles=*.res dosyalarını ilişkilendirin
ukrainian.ReadmeEnglish=ReadMe (англійська)
ukrainian.ReadmeJapanese=ReadMe (японська)
ukrainian.LicenseEnglish=Ліцензія
ukrainian.AssociateRcFiles=Пов’язати *.rc файли
ukrainian.AssociateResFiles=Приєднати *.res файли

```

`mcdx/CMakeLists.txt`:

```txt
# CMakeLists.txt --- CMake project settings
#    ex) cmake -G "Visual Studio 9 2008" .
#    ex) cmake -DCMAKE_BUILD_TYPE=Release -G "MSYS Makefiles" .
##############################################################################

# CMake minimum version
cmake_minimum_required(VERSION 2.9)

# Enable C/C++
ENABLE_LANGUAGE(C)
ENABLE_LANGUAGE(CXX)

# support C++11
macro(use_cxx11)
  if (CMAKE_VERSION VERSION_LESS "3.1")
    if (CMAKE_CXX_COMPILER_ID STREQUAL "GNU")
      set(CMAKE_CXX_FLAGS "${CMAKE_CXX_FLAGS} -std=c++11")
    endif()
  else()
    set (CMAKE_CXX_STANDARD 11)
  endif()
endmacro(use_cxx11)

if (NOT WIN32)
    use_cxx11()
endif()

# include directories
include_directories(../src)

# executable
add_executable(mcdx mcdx.cpp getoptwin.c)

# do statically link
if (WIN32)
    set_target_properties(mcdx PROPERTIES LINK_SEARCH_START_STATIC 1)
    set_target_properties(mcdx PROPERTIES LINK_SEARCH_END_STATIC 1)
endif()

option(USE_WONAPI "Use Wonders API" OFF)
option(USE_ICONV "Use Iconv" OFF)

if(USE_WONAPI)
    set(USE_ICONV ON)
    target_compile_definitions(mcdx PRIVATE -DWONVER)
elseif(NOT WIN32)
    set(USE_ICONV ON)
endif()

if(USE_ICONV)
    list(APPEND CMAKE_MODULE_PATH "${CMAKE_CURRENT_SOURCE_DIR}")
    find_package(Iconv REQUIRED)
    target_include_directories(mcdx PRIVATE ${ICONV_INCLUDE_DIRS})
    target_link_libraries(mcdx ${ICONV_LIBRARIES})
endif()

```

`mcdx/FindIconv.cmake`:

```cmake
# - Try to find Iconv
# Once done this will define
#
#  ICONV_FOUND - system has Iconv
#  ICONV_INCLUDE_DIR - the Iconv include directory
#  ICONV_LIBRARIES - Link these to use Iconv
#  ICONV_SECOND_ARGUMENT_IS_CONST - the second argument for iconv() is const
#
include(CheckCXXSourceCompiles)

IF (ICONV_INCLUDE_DIR AND ICONV_LIBRARIES)
  # Already in cache, be silent
  SET(ICONV_FIND_QUIETLY TRUE)
ENDIF (ICONV_INCLUDE_DIR AND ICONV_LIBRARIES)

FIND_PATH(ICONV_INCLUDE_DIR iconv.h)

FIND_LIBRARY(ICONV_LIBRARIES NAMES iconv libiconv libiconv-2 c)

IF(ICONV_INCLUDE_DIR AND ICONV_LIBRARIES)
   SET(ICONV_FOUND TRUE)
ENDIF(ICONV_INCLUDE_DIR AND ICONV_LIBRARIES)

set(CMAKE_REQUIRED_INCLUDES ${ICONV_INCLUDE_DIR})
set(CMAKE_REQUIRED_LIBRARIES ${ICONV_LIBRARIES})
IF(ICONV_FOUND)
  check_cxx_source_compiles("
  #include <iconv.h>
  int main(){
    iconv_t conv = 0;
    const char* in = 0;
    size_t ilen = 0;
    char* out = 0;
    size_t olen = 0;
    iconv(conv, &in, &ilen, &out, &olen);
    return 0;
  }
" ICONV_SECOND_ARGUMENT_IS_CONST )
ENDIF(ICONV_FOUND)
set(CMAKE_REQUIRED_INCLUDES)
set(CMAKE_REQUIRED_LIBRARIES)

IF(ICONV_FOUND)
  IF(NOT ICONV_FIND_QUIETLY)
    MESSAGE(STATUS "Found Iconv: ${ICONV_LIBRARIES}")
  ENDIF(NOT ICONV_FIND_QUIETLY)
ELSE(ICONV_FOUND)
  IF(Iconv_FIND_REQUIRED)
    MESSAGE(FATAL_ERROR "Could not find Iconv")
  ENDIF(Iconv_FIND_REQUIRED)
ENDIF(ICONV_FOUND)

MARK_AS_ADVANCED(
  ICONV_INCLUDE_DIR
  ICONV_LIBRARIES
  ICONV_SECOND_ARGUMENT_IS_CONST
)

```

`mcdx/MESSAGETABLEDX.md`:

```md
MESSAGETABLEDX Resource
=======================

The `MESSAGETABLEDX` resource is a dirty extension of Win32 `MESSAGETABLE` resource.
It can be compiled by the [mcdx](https://github.com/katahiromz/RisohEditor/tree/master/mcdx) program, created by Katayama Hirofumi MZ.
The compiled binary data is compatible to Win32 `MESSAGETABLE` resource.


Syntax
------

```rc
#ifdef APSTUDIO_INVOKED
    #error Ap Studio cannot edit this message table.
#endif
#ifdef MCDX_INVOKED
MESSAGETABLEDX
{
    message-statement
    ...
}
#endif
```

`MESSAGETABLEDX` contains one or more `message-statement`'s.


message-statement
-----------------

A `message-statement` is a statement to specify a resource message and has the following syntax:

```rc
message-id, "text"
```

A `message-id` is a 32-bit C integer literal or an integral C constant expression.


Why do we use MESSAGETABLEDX resources?
---------------------------------------

Win32 `MESSAGETABLE` resource has complicated syntax.
Our `MESSAGETABLEDX` resource is simple.
You can embed the `MESSAGETABLEDX` resources in your resource file (.rc).
To build the resource file with the `MESSAGETABLEDX` resources,
please see [RisohEditor's CMakeList.txt file](https://github.com/katahiromz/RisohEditor/blob/master/src/CMakeLists.txt).

The mcdx program is executable on both of Windows and Linux.


See Also
--------

[mcdx](https://github.com/katahiromz/RisohEditor/tree/master/mcdx)

```

`mcdx/README.txt`:

```txt
This is a message compiler named "mcdx".

```

`mcdx/getoptwin.c`:

```c
/*
 * getoptwin.c
 *
 * THIS SOFTWARE IS NOT COPYRIGHTED
 *
 * This source code is offered for use in the public domain. You may
 * use, modify or distribute it freely.
 *
 * This code is distributed in the hope that it will be useful but
 * WITHOUT ANY WARRANTY. ALL WARRANTIES, EXPRESS OR IMPLIED ARE HEREBY
 * DISCLAIMED. This includes but is not limited to warranties of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
 */
#if !defined(__GNUC__) && !defined(HAVE_GETOPT_H)

#include <stdio.h>
#include <stdlib.h>
#include <stdarg.h>
#include <malloc.h>
#include "getoptwin.h"

/*
 * Old Microsft C has no inline but __inline.
 */
#if defined(_MSC_VER)
    #define inline __inline
#endif

/*
 * Old Borland C has no inline but __inline.
 */
#if defined(__BORLANDC__) && (__BORLANDC__ <= 0x0551)
    #define inline __inline
#endif

/* Identify how to get the calling program name, for use in messages...
 */
#ifdef __CYGWIN__
/*
 * CYGWIN uses this DLL reference...
 */
# define PROGNAME  __progname
extern char __declspec(dllimport) *__progname;
#else
/*
 * ...while elsewhere, we simply use the first argument passed.
 */
# define PROGNAME  *argv
#endif

/* Initialise the public variables. */

int optind = 1;                         /* index for first non-option arg     */
int opterr = 1;                         /* enable built-in error messages     */

char *optarg = NULL;                    /* pointer to current option argument */

#define char  char                      /* argument type selector */

#define getopt_switchar         '-'     /* option prefix character in argv    */
#define getopt_pluschar         '+'     /* prefix for POSIX mode in optstring */
#define getopt_takes_argument   ':'     /* marker for optarg in optstring     */
#define getopt_arg_assign       '='     /* longopt argument field separator   */
#define getopt_unknown          '?'     /* return code for unmatched option   */
#define getopt_ordered           1      /* return code for ordered non-option */

#define getopt_all_done         -1      /* return code to indicate completion */

enum
{ /* All `getopt' API functions are implemented via calls to the
   * common static function `getopt_parse()'; these `mode' selectors
   * determine the behaviour of `getopt_parse()', to deliver the
   * appropriate result in each case.
   */
  getopt_mode_standard = 0,     /* getopt()           */
  getopt_mode_long,             /* getopt_long()      */
  getopt_mode_long_only         /* getopt_long_only() */
};

enum
{ /* When attempting to match a command line argument to a long form option,
   * these indicate the status of the match.
   */
  getopt_no_match = 0,          /* no successful match                       */
  getopt_abbreviated_match,     /* argument is an abbreviation for an option */
  getopt_exact_match            /* argument matches the full option name     */
};

int optopt = getopt_unknown;    /* return value for option being evaluated   */

/* Some BSD applications expect to be able to reinitialise `getopt' parsing
 * by setting a global variable called `optreset'.  We provide an obfuscated
 * API, which allows applications to emulate this brain damage; however, any
 * use of this is non-portable, and is strongly discouraged.
 */
#define optreset  __mingw_optreset
int optreset = 0;

static inline
int getopt_missing_arg( const char *optstring )
{
  /* Helper function to determine the appropriate return value,
   * for the case where a required option argument is missing.
   */
  if( (*optstring == getopt_pluschar) || (*optstring == getopt_switchar) )
    ++optstring;
  return (*optstring == getopt_takes_argument)
    ? getopt_takes_argument
    : getopt_unknown;
}

/* `complain' macro facilitates the generation of simple built-in
 * error messages, displayed on various fault conditions, provided
 * `opterr' is non-zero.
 */
#define complain( MSG, ARG )  if( opterr ) \
  fprintf( stderr, "%s: "MSG"\n", PROGNAME, ARG )

static inline
int getopt_argerror( int mode, char *fmt, char *prog, struct option *opt, int retval )
{
  /* Helper function, to generate more complex built-in error
   * messages, for invalid arguments to long form options ...
   */
  if( opterr )
  {
    /* ... but, displayed only if `opterr' is non-zero.
     */
    char flag[] = "--";
    if( mode != getopt_mode_long )
      /*
       * only display one hyphen, for implicit long form options,
       * improperly resolved by `getopt_long_only()'.
       */
      flag[1] = 0;
    /*
     * always preface the program name ...
     */
    fprintf( stderr, "%s: ", prog );
    /*
     * to the appropriate, option specific message.
     */
    fprintf( stderr, fmt, flag, opt->name );
  }
  /* Whether displaying the message, or not, always set `optopt'
   * to identify the faulty option ...
   */
  optopt = opt->val;
  /*
   * and return the `invalid option' indicator.
   */
  return retval;
}

/* `getopt_conventions' establish behavioural options, to control
 * the operation of `getopt_parse()', e.g. to select between POSIX
 * and GNU style argument parsing behaviour.
 */
#define getopt_set_conventions  0x1000
#define getopt_posixly_correct  0x0010

static inline
int getopt_conventions( int flags )
{
  static int conventions = 0;

  if( (conventions == 0) && ((flags & getopt_set_conventions) == 0) )
  {
    /* default conventions have not yet been established;
     * initialise them now!
     */
    conventions = getopt_set_conventions;
    if( (flags == getopt_pluschar) || (getenv( "POSIXLY_CORRECT" ) != NULL) )
      conventions |= getopt_posixly_correct;
  }

  else if( flags & getopt_set_conventions )
    /*
     * default conventions may have already been established,
     * but this is a specific request to augment them.
     */
    conventions |= flags;

  /* in any event, return the currently established conventions.
   */
  return conventions;
}

static inline
int is_switchar( char flag )
{
  /* A simple helper function, used to identify the switch character
   * introducing an optional command line argument.
   */
  return flag == getopt_switchar;
}

static inline
const char *getopt_match( char lookup, const char *opt_string )
{
  /* Helper function, used to identify short form options.
   */
  if( (*opt_string == getopt_pluschar) || (*opt_string == getopt_switchar) )
    ++opt_string;
  if( *opt_string == getopt_takes_argument )
    ++opt_string;
  do if( lookup == *opt_string ) return opt_string;
     while( *++opt_string );
  return NULL;
}

static inline
int getopt_match_long( const char *nextchar, const char *optname )
{
  /* Helper function, used to identify potential matches for
   * long form options.
   */
  char matchchar;
  while( (matchchar = *nextchar++) && (matchchar == *optname) )
    /*
     * skip over initial substring which DOES match.
     */
    ++optname;

  if( matchchar )
  {
    /* did NOT match the entire argument to an initial substring
     * of a defined option name ...
     */
    if( matchchar != getopt_arg_assign )
      /*
       * ... and didn't stop at an `=' internal field separator,
       * so this is NOT a possible match.
       */
      return getopt_no_match;

    /* DID stop at an `=' internal field separator,
     * so this IS a possible match, and what follows is an
     * argument to the possibly matched option.
     */
    optarg = (char *)(nextchar);
  }
  return *optname
    /*
     * if we DIDN'T match the ENTIRE text of the option name,
     * then it's a possible abbreviated match ...
     */
    ? getopt_abbreviated_match
    /*
     * but if we DID match the entire option name,
     * then it's a DEFINITE EXACT match.
     */
    : getopt_exact_match;
}

static inline
int getopt_resolved( int mode, int argc, char *const *argv, int *argind,
struct option *opt, int index, int *retindex, const char *optstring )
{
  /* Helper function to establish appropriate return conditions,
   * on resolution of a long form option.
   */
  if( retindex != NULL )
    *retindex = index;

  /* On return, `optind' should normally refer to the argument, if any,
   * which follows the current one; it is convenient to set this, before
   * checking for the presence of any `optarg'.
   */
  optind = *argind + 1;

  if( optarg && (opt[index].has_arg == no_argument) )
    /*
     * it is an error for the user to specify an option specific argument
     * with an option which doesn't expect one!
     */
    return getopt_argerror( mode, "option `%s%s' doesn't accept an argument\n",
        PROGNAME, opt + index, getopt_unknown );

  else if( (optarg == NULL) && (opt[index].has_arg == required_argument) )
  {
    /* similarly, it is an error if no argument is specified
     * with an option which requires one ...
     */
    if( optind < argc )
      /*
       * ... except that the requirement may be satisfied from
       * the following command line argument, if any ...
       */
      optarg = argv[*argind = optind++];

    else
      /* so fail this case, only if no such argument exists!
       */
      return getopt_argerror( mode, "option `%s%s' requires an argument\n",
          PROGNAME, opt + index, getopt_missing_arg( optstring ) );
  }

  /* when the caller has provided a return buffer ...
   */
  if( opt[index].flag != NULL )
  {
    /* ... then we place the proper return value there,
     * and return a status code of zero ...
     */
    *(opt[index].flag) = opt[index].val;
    return 0;
  }
  /* ... otherwise, the return value becomes the status code.
   */
  return opt[index].val;
}

static inline
int getopt_verify( const char *nextchar, const char *optstring )
{
  /* Helper function, called by getopt_parse() when invoked
   * by getopt_long_only(), to verify when an unmatched or an
   * ambiguously matched long form option string is valid as
   * a short form option specification.
   */
  if( ! (nextchar && *nextchar && optstring && *optstring) )
    /*
     * There are no characters to be matched, or there are no
     * valid short form option characters to which they can be
     * matched, so this can never be valid.
     */
    return 0;

  while( *nextchar )
  {
    /* For each command line character in turn ...
     */
    const char *test;
    if( (test = getopt_match( *nextchar++, optstring )) == NULL )
      /*
       * ... there is no short form option to match the current
       * candidate, so the entire argument fails.
       */
      return 0;

    if( test[1] == getopt_takes_argument )
      /*
       * The current candidate is valid, and it matches an option
       * which takes an argument, so this command line argument is
       * a valid short form option specification; accept it.
       */
      return 1;
  }
  /* If we get to here, then every character in the command line
   * argument was valid as a short form option; accept it.
   */
  return 1;
}

static
#define getopt_std_args int argc, char *const argv[], const char *optstring
int getopt_parse( int mode, getopt_std_args, ... )
{
  /* Common core implementation for ALL `getopt' functions.
   */
  static int argind = 0;
  static int optbase = 0;
  static const char *nextchar = NULL;
  static int optmark = 0;

  if( (optreset |= (optind < 1)) || (optind < optbase) )
  {
    /* POSIX does not prescribe any definitive mechanism for restarting
     * a `getopt' scan, but some applications may require such capability.
     * We will support it, by allowing the caller to adjust the value of
     * `optind' downwards, (nominally setting it to zero).  Since POSIX
     * wants `optind' to have an initial value of one, but we want all
     * of our internal place holders to be initialised to zero, when we
     * are called for the first time, we will handle such a reset by
     * adjusting all of the internal place holders to one less than
     * the adjusted `optind' value, (but never to less than zero).
     */
    if( optreset )
    {
      /* User has explicitly requested reinitialisation...
       * We need to reset `optind' to it's normal initial value of 1,
       * to avoid a potential infinitely recursive loop; by doing this
       * up front, we also ensure that the remaining place holders
       * will be correctly reinitialised to no less than zero.
       */
      optind = 1;

      /* We also need to clear the `optreset' request...
       */
      optreset = 0;
    }

    /* Now, we may safely reinitialise the internal place holders, to
     * one less than `optind', without fear of making them negative.
     */
    optmark = optbase = argind = optind - 1;
    nextchar = NULL;
  }

  /* From a POSIX perspective, the following is `undefined behaviour';
   * we implement it thus, for compatibility with GNU and BSD getopt.
   */
  else if( optind > (argind + 1) )
  {
    /* Some applications expect to be able to manipulate `optind',
     * causing `getopt' to skip over one or more elements of `argv';
     * POSIX doesn't require us to support this brain-damaged concept;
     * (indeed, POSIX defines no particular behaviour, in the event of
     *  such usage, so it must be considered a bug for an application
     *  to rely on any particular outcome); nonetheless, Mac-OS-X and
     * BSD actually provide *documented* support for this capability,
     * so we ensure that our internal place holders keep track of
     * external `optind' increments; (`argind' must lag by one).
     */
    argind = optind - 1;

    /* When `optind' is misused, in this fashion, we also abandon any
     * residual text in the argument we had been parsing; this is done
     * without any further processing of such abandoned text, assuming
     * that the caller is equipped to handle it appropriately.
     */
    nextchar = NULL;
  }

  if( nextchar && *nextchar )
  {
    /* we are parsing a standard, or short format, option argument ...
     */
    const char *optchar;
    if( (optchar = getopt_match( optopt = *nextchar++, optstring )) != NULL )
    {
      /* we have identified it as valid ...
       */
      if( optchar[1] == getopt_takes_argument )
      {
        /* and determined that it requires an associated argument ...
         */
        if( ! *(optarg = (char *)(nextchar)) )
        {
          /* the argument is NOT attached ...
           */
          if( optchar[2] == getopt_takes_argument )
            /*
             * but this GNU extension marks it as optional,
             * so we don't provide one on this occasion.
             */
            optarg = NULL;

          /* otherwise this option takes a mandatory argument,
           * so, provided there is one available ...
           */
          else if( (argc - argind) > 1 )
            /*
             * we take the following command line argument,
             * as the appropriate option argument.
             */
            optarg = argv[++argind];

          /* but if no further argument is available,
           * then there is nothing we can do, except for
           * issuing the requisite diagnostic message.
           */
          else
          {
            complain( "option requires an argument -- %c", optopt );
            return getopt_missing_arg( optstring );
          }
        }
        optind = argind + 1;
        nextchar = NULL;
      }
      else
        optarg = NULL;
      optind = (nextchar && *nextchar) ? argind : argind + 1;
      return optopt;
    }
    /* if we didn't find a valid match for the specified option character,
     * then we fall through to here, so take appropriate diagnostic action.
     */
    if( mode == getopt_mode_long_only )
    {
      complain( "unrecognised option `-%s'", --nextchar );
      nextchar = NULL;
      optopt = 0;
    }
    else
      complain( "invalid option -- %c", optopt );
    optind = (nextchar && *nextchar) ? argind : argind + 1;
    return getopt_unknown;
  }

  if( optmark > optbase )
  {
    /* This can happen, in GNU parsing mode ONLY, when we have
     * skipped over non-option arguments, and found a subsequent
     * option argument; in this case we permute the arguments.
     */
    int index;
    /*
     * `optspan' specifies the number of contiguous arguments
     * which are spanned by the current option, and so must be
     * moved together during permutation.
     */
    int optspan = argind - optmark + 1;
    /*
     * we use `this_arg' to store these temporarily.
     */
    char **this_arg = (char **)alloca(optspan * sizeof(char *));
    /*
     * we cannot manipulate `argv' directly, since the `getopt'
     * API prototypes it as `read-only'; this cast to `arglist'
     * allows us to work around that restriction.
     */
    char **arglist = (char **)(argv);

    /* save temporary copies of the arguments which are associated
     * with the current option ...
     */
    for( index = 0; index < optspan; ++index )
      this_arg[index] = arglist[optmark + index];

    /* move all preceding non-option arguments to the right,
     * overwriting these saved arguments, while making space
     * to replace them in their permuted location.
     */
    for( --optmark; optmark >= optbase; --optmark )
      arglist[optmark + optspan] = arglist[optmark];

    /* restore the temporarily saved option arguments to
     * their permuted location.
     */
    for( index = 0; index < optspan; ++index )
      arglist[optbase + index] = this_arg[index];

    /* adjust `optbase', to account for the relocated option.
     */
    optbase += optspan;
  }

  else
    /* no permutation occurred ...
     * simply adjust `optbase' for all options parsed so far.
     */
    optbase = argind + 1;

  /* enter main parsing loop ...
   */
  while( argc > ++argind )
  {
    /* inspect each argument in turn, identifying possible options ...
     */
    if( is_switchar( *(nextchar = argv[optmark = argind]) ) && *++nextchar )
    {
      /* we've found a candidate option argument ... */

      if( is_switchar( *nextchar ) )
      {
        /* it's a double hyphen argument ... */

        const char *refchar = nextchar;
        if( *++refchar )
        {
          /* and it looks like a long format option ...
           * `getopt_long' mode must be active to accept it as such,
           * `getopt_long_only' also qualifies, but we must downgrade
           * it to force explicit handling as a long format option.
           */
          if( mode >= getopt_mode_long )
          {
            nextchar = refchar;
            mode = getopt_mode_long;
          }
        }
        else
        {
          /* this is an explicit `--' end of options marker, so wrap up now!
           */
          if( optmark > optbase )
          {
            /* permuting the argument list as necessary ...
             * (note use of `this_arg' and `arglist', as above).
             */
            char *this_arg = argv[optmark];
            char **arglist = (char **)(argv);

            /* move all preceding non-option arguments to the right ...
             */
            do arglist[optmark] = arglist[optmark - 1];
               while( optmark-- > optbase );

            /* reinstate the `--' marker, in its permuted location.
             */
            arglist[optbase] = this_arg;
          }
          /* ... before finally bumping `optbase' past the `--' marker,
           * and returning the `all done' completion indicator.
           */
          optind = ++optbase;
          return getopt_all_done;
        }
      }
      else if( mode < getopt_mode_long_only )
      {
        /* it's not an explicit long option, and `getopt_long_only' isn't active,
         * so we must explicitly try to match it as a short option.
         */
        mode = getopt_mode_standard;
      }

      if( mode >= getopt_mode_long )
      {
        /* the current argument is a long form option, (either explicitly,
         * introduced by a double hyphen, or implicitly because we were called
         * by `getopt_long_only'); this is where we parse it.
         */
        int lookup;
        int matched = -1;
        struct option *longopts;
        int *optindex;

        /* we need to fetch the `extra' function arguments, which are
         * specified for the `getopt_long' APIs.
         */
        va_list refptr;
        va_start( refptr, optstring );
        longopts = va_arg( refptr, struct option * );
        optindex = va_arg( refptr, int * );
        va_end( refptr );

        /* ensuring that `optarg' does not inherit any junk, from parsing
         * preceding arguments ...
         */
        optarg = NULL;
        for( lookup = 0; longopts && longopts[lookup].name; ++lookup )
        {
          /* scan the list of defined long form options ...
           */
          switch( getopt_match_long( nextchar, longopts[lookup].name ) )
          {
            /* looking for possible matches for the current argument.
             */
            case getopt_exact_match:
              /*
               * when an exact match is found,
               * return it immediately, setting `nextchar' to NULL,
               * to ensure we don't mistakenly try to match any
               * subsequent characters as short form options.
               */
              nextchar = NULL;
              return getopt_resolved( mode, argc, argv, &argind,
                  longopts, lookup, optindex, optstring );

            case getopt_abbreviated_match:
              /*
               * but, for a partial (initial substring) match ...
               */
              if( matched >= 0 )
              {
                /* if this is not the first, then we have an ambiguity ...
                 */
                if( (mode == getopt_mode_long_only)
                  /*
                   * However, in the case of getopt_long_only(), if
                   * the entire ambiguously matched string represents
                   * a valid short option specification, then we may
                   * proceed to interpret it as such.
                   */
                &&  getopt_verify( nextchar, optstring )  )
                  return getopt_parse( mode, argc, argv, optstring );

                /* If we get to here, then the ambiguously matched
                 * partial long option isn't valid for short option
                 * evaluation; reset parser context to resume with
                 * the following command line argument, diagnose
                 * ambiguity, and bail out.
                 */
                optopt = 0;
                nextchar = NULL;
                optind = argind + 1;
                complain( "option `%s' is ambiguous", argv[argind] );
                return getopt_unknown;
              }
              /* otherwise just note that we've found a possible match ...
               */
              matched = lookup;
          }
        }
        if( matched >= 0 )
        {
          /* if we get to here, then we found exactly one partial match,
           * so return it, as for an exact match.
           */
          nextchar = NULL;
          return getopt_resolved( mode, argc, argv, &argind,
              longopts, matched, optindex, optstring );
        }
        /* if here, then we had what SHOULD have been a long form option,
         * but it is unmatched ...
         */
        if( (mode < getopt_mode_long_only)
          /*
           * ... although paradoxically, `mode == getopt_mode_long_only'
           * allows us to still try to match it as a short form option.
           */
        ||  (getopt_verify( nextchar, optstring ) == 0)  )
        {
          /* When it cannot be matched, reset the parsing context to
           * resume from the next argument, diagnose the failed match,
           * and bail out.
           */
          optopt = 0;
          nextchar = NULL;
          optind = argind + 1;
          complain( "unrecognised option `%s'", argv[argind] );
          return getopt_unknown;
        }
      }
      /* fall through to handle standard short form options...
       * when the option argument format is neither explictly identified
       * as long, nor implicitly matched as such, and the argument isn't
       * just a bare hyphen, (which isn't an option), then we make one
       * recursive call to explicitly interpret it as short format.
       */
      if( *nextchar )
        return getopt_parse( mode, argc, argv, optstring );
    }
    /* if we get to here, then we've parsed a non-option argument ...
     * in GNU compatibility mode, we step over it, so we can permute
     * any subsequent option arguments, but ...
     */
    if( *optstring == getopt_switchar )
    {
      /* if `optstring' begins with a `-' character, this special
       * GNU specific behaviour requires us to return the non-option
       * arguments in strict order, as pseudo-arguments to a special
       * option, with return value defined as `getopt_ordered'.
       */
      nextchar = NULL;
      optind = argind + 1;
      optarg = argv[argind];
      return getopt_ordered;
    }
    if( getopt_conventions( *optstring ) & getopt_posixly_correct )
      /*
       * otherwise ...
       * for POSIXLY_CORRECT behaviour, or if `optstring' begins with
       * a `+' character, then we break out of the parsing loop, so that
       * the scan ends at the current argument, with no permutation.
       */
      break;
  }
  /* fall through when all arguments have been evaluated,
   */
  optind = optbase;
  return getopt_all_done;
}

/* All three public API entry points are trivially defined,
 * in terms of the internal `getopt_parse' function.
 */
int getopt( getopt_std_args )
{
  return getopt_parse( getopt_mode_standard, argc, argv, optstring );
}

int getopt_long( getopt_std_args, const struct option *opts, int *index )
{
  return getopt_parse( getopt_mode_long, argc, argv, optstring, opts, index );
}

int getopt_long_only( getopt_std_args, const struct option *opts, int *index )
{
  return getopt_parse( getopt_mode_long_only, argc, argv, optstring, opts, index );
}

#ifdef __weak_alias
/*
 * These Microsnot style uglified aliases are provided for compatibility
 * with the previous MinGW implementation of the getopt API.
 */
__weak_alias( getopt, _getopt )
__weak_alias( getopt_long, _getopt_long )
__weak_alias( getopt_long_only, _getopt_long_only )
#endif

#endif  /* !defined(__GNUC__) && !defined(HAVE_GETOPT_H) */

```

`mcdx/getoptwin.h`:

```h
/*
 * getoptwin.h
 *
 * THIS SOFTWARE IS NOT COPYRIGHTED
 *
 * This source code is offered for use in the public domain. You may
 * use, modify or distribute it freely.
 *
 * This code is distributed in the hope that it will be useful but
 * WITHOUT ANY WARRANTY. ALL WARRANTIES, EXPRESS OR IMPLIED ARE HEREBY
 * DISCLAIMED. This includes but is not limited to warranties of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
 */
#ifndef GETOPTWIN_H

#if defined(__GNUC__) || defined(HAVE_GETOPT_H)
    #include <getopt.h>
#else   /* !(defined(__GNUC__) || defined(HAVE_GETOPT_H)) */

#ifdef __cplusplus
extern "C" {
#endif

extern int optind;              /* index of first non-option in argv      */
extern int optopt;              /* single option character, as parsed     */
extern int opterr;              /* flag to enable built-in diagnostics... */
                                /* (user may set to zero, to suppress)    */

extern char *optarg;            /* pointer to argument of current option  */

int getopt(int, char * const [], const char *);

struct option           /* specification for a long form option...      */
{
    const char *name;           /* option name, without leading hyphens */
    int         has_arg;        /* does it take an argument?            */
    int        *flag;           /* where to save its status, or NULL    */
    int         val;            /* its associated status value          */
};

enum                    /* permitted values for its "has_arg" field...  */
{
    no_argument = 0,            /* option never takes an argument       */
    required_argument,          /* option always requires an argument   */
    optional_argument           /* option may take an argument          */
};

int getopt_long(int, char * const [], const char *, const struct option *, int *);
int getopt_long_only(int, char * const [], const char *, const struct option *, int *);

#ifdef __cplusplus
} /* extern "C" */
#endif

#endif  /* !(defined(__GNUC__) || defined(HAVE_GETOPT_H)) */
#endif  /* ndef GETOPTWIN_H */

```

`mcdx/mcdx.cpp`:

```cpp
// mcdx.hpp --- Message Compiler by katahiromz
//////////////////////////////////////////////////////////////////////////////
// RisohEditor --- Another free Win32 resource editor
// Copyright (C) 2017-2018 Katayama Hirofumi MZ <katayama.hirofumi.mz@gmail.com>
// 
// This program is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
// 
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
// 
// You should have received a copy of the GNU General Public License
// along with this program.  If not, see <http://www.gnu.org/licenses/>.
//////////////////////////////////////////////////////////////////////////////

#define NO_CONSTANTS_DB
#define NO_STRSAFE

#if defined(_WIN32) && !defined(WONVER)
    #include "MProcessMaker.hpp"
#endif
#include "MString.hpp"
#include "MacroParser.hpp"
#include "MessageRes.hpp"

#include "ResHeader.hpp"
#include "getoptwin.h"
#include <cctype>
#include <sys/types.h>
#include <sys/stat.h>

#ifndef RT_MESSAGETABLE
    #define RT_MESSAGETABLE     MAKEINTRESOURCE(11)
#endif

////////////////////////////////////////////////////////////////////////////

#ifndef _countof
    #define _countof(array)     (sizeof(array) / sizeof(array[0]))
#endif

enum EXITCODE
{
    EXITCODE_SUCCESS = 0,
    EXITCODE_INVALID_ARGUMENT,
    EXITCODE_FAIL_TO_PREPROCESS,
    EXITCODE_SYNTAX_ERROR,
    EXITCODE_CANNOT_OPEN,
    EXITCODE_CANNOT_WRITE,
    EXITCODE_INVALID_DATA,
    EXITCODE_NOT_FOUND_CPP,
    EXITCODE_NOT_FOUND_WINDRES,
    EXITCODE_NOT_SUPPORTED_YET,
    EXITCODE_CANT_MAKE_TEMP
};

////////////////////////////////////////////////////////////////////////////

void show_help(void)
{
    printf("mcdx --- Message Compiler Dirty Extension by katahiromz\n");
    printf("Copyright (C) 2018 Katayama Hirofumi MZ. License: GPLv3.\n");
    printf("\n");
    printf("Usage: mcdx [option(s)] [input-file] [output-file]\n");
    printf("Options:\n");
    printf("  -i --input=<file>            Name input file\n");
    printf("  -o --output=<file>           Name output file\n");
    printf("  -J --input-format=<format>   Specify input format\n");
    printf("  -O --output-format=<format>  Specify output format\n");
    printf("  -I --include-dir=<dir>       Include directory when preprocessing rc file\n");
    printf("  -D --define=<sym>[=<val>]    Define SYM when preprocessing rc file\n");
    printf("  -U --undefine <sym>          Undefine SYM when preprocessing rc file\n");
    printf("  -c --codepage=<codepage>     Specify default codepage\n");
    printf("  -l --language=<val>          Set language when reading rc file\n");
    printf("  --preprocessor=<path>        Set preprocessor path\n");
    printf("  --windres=<path>             Set windres path\n");
    printf("FORMAT is one of rc, res, bin or coff, and is deduced from the file name\n");
    printf("Report bugs to <katayama.hirofumi.mz@gmail.com>\n");
}

void show_version(void)
{
    printf("mcdx ver.0.8.2\n");
    printf("Copyright (C) 2018 Katayama Hirofumi MZ <katayama.hirofumi.mz@gmail.com>.\n");
    printf("This program is free software; you may redistribute it under the terms of\n");
    printf("the GNU General Public License version 3 or (at your option) any later version.\n");
    printf("This program has absolutely no warranty.\n");
}

////////////////////////////////////////////////////////////////////////////
// file_exists and tmpfilenam

inline bool file_exists(const char *file)
{
    struct stat st;
    return stat(file, &st) == 0;
}

struct DeleteTempFiles
{
    std::vector<std::string> m_files;
    DeleteTempFiles()
    {
    }
    void push_back(const std::string& file)
    {
        m_files.push_back(file);
    }
    ~DeleteTempFiles()
    {
        for (size_t i = 0; i < m_files.size(); ++i)
        {
            _unlink(m_files[i].c_str());
        }
        m_files.clear();
    }
};
DeleteTempFiles g_delete_temp_files;

FILE *tmpfilenam(char *pathname)
{
    FILE *fp;
    int i, k;
    const int retry_count = 64;
    char tmp[MAX_PATH], name[16], file[MAX_PATH];
    char *ptr = getenv("TMP");

    if (!ptr)
        ptr = getenv("TEMP");

    if (ptr)
    {
        strcpy(tmp, ptr);
        mstr_trim_right(tmp, "/\\");
    }
    else
    {
        strcpy(tmp, ".");
    }

    k = 0;
    do
    {
        do
        {
            for (i = 0; i < 8; ++i)
            {
                name[i] = (char)('A' + rand() % ('Z' - 'A' + 1));
            }
            name[i++] = '.';
            name[i++] = 't';
            name[i++] = 'm';
            name[i++] = 'p';
            name[i] = 0;

            strcpy(file, tmp);
            #ifdef _WIN32
                strcat(file, "\\");
            #else
                strcat(file, "/");
            #endif
            strcat(file, name);
            ++k;
        } while (file_exists(file) && k < retry_count);

        fp = fopen(file, "w+b");
    } while (fp == NULL && k < retry_count);

    if (fp)
    {
        g_delete_temp_files.push_back(file);
        strcpy(pathname, file);
    }
    else
    {
        pathname[0] = 0;
    }

    return fp;
}

////////////////////////////////////////////////////////////////////////////

const char *g_cpp = "mcpp";
const char *g_windres = "windres";

char *g_input_file = NULL;
char *g_output_file = NULL;
const char *g_inp_format = NULL;
const char *g_out_format = NULL;

std::vector<MStringA> g_include_directories;
std::vector<MStringA> g_definitions;
std::vector<MStringA> g_undefinitions;

std::string g_strFile = "(anonymous)";
int g_nLineNo = 0;

LANGID g_langid = 0;
uint16_t g_wCodePage = CP_UTF8;
int g_value = 0;

typedef std::map<LANGID, MessageRes> msg_tables_type;
msg_tables_type g_msg_tables;

char g_lang_english[] = "LANG=en_US";

int syntax_error(void)
{
    fprintf(stderr, "%s (%d): ERROR: Syntax error\n", g_strFile.c_str(), g_nLineNo);
    assert(0);
    return EXITCODE_SYNTAX_ERROR;
}

const char *g_progname = "mcdx";

bool do_directive_line(char*& ptr)
{
    // # line "file"
    char *ptr1 = ptr;
    while (mchr_is_digit(*ptr))
    {
        ++ptr;
    }
    char *ptr2 = ptr;
    ptr = mstr_skip_space(ptr);
    char *ptr3 = ptr;
    while (*ptr)
    {
        ++ptr;
    }
    *ptr2 = 0;

    g_nLineNo = strtol(ptr1, NULL, 0) - 1;

    std::string file = ptr3;
    mstr_unquote(file);
    g_strFile = file;

    return true;
}

int do_mode_1(char*& ptr, int& nMode, bool& do_retry)
{
    ptr = mstr_skip_space(ptr);
    if (*ptr == '{')
    {
        nMode = 2;
        ++ptr;
    }
    else if (*ptr == '}')
    {
        return syntax_error();
    }
    else if (memcmp(ptr, "BEGIN", 5) == 0 &&
             (ptr[5] == 0 || mchr_is_space(ptr[5])))
    {
        nMode = 2;
        ptr += 5;
    }
    ptr = mstr_skip_space(ptr);
    if (nMode != 2)
    {
        if (*ptr && !mchr_is_digit(*ptr))
        {
            return syntax_error();
        }
    }
    return EXITCODE_SUCCESS;
}

int do_mode_2(char*& ptr, int& nMode, bool& do_retry)
{
    ptr = mstr_skip_space(ptr);
    if (*ptr == '{')
    {
        return syntax_error();
    }
    else if (*ptr == '}')
    {
        ++ptr;
        nMode = 0;
        do_retry = true;
        return EXITCODE_SUCCESS;
    }
    else if (memcmp(ptr, "END", 3) == 0 &&
             (ptr[3] == 0 || mchr_is_space(ptr[3])))
    {
        ptr += 3;
        nMode = 0;
        do_retry = true;
        return EXITCODE_SUCCESS;
    }
    if (*ptr)
    {
        // get number string
        char *ptr0 = ptr;
        while (*ptr && *ptr != ',' && *ptr != '\"')
        {
            ++ptr;
        }
        char *ptr1 = ptr;
        MStringA str(ptr0, ptr1);

        // parse
        using namespace MacroParser;
        StringScanner scanner(str);
        TokenStream stream(scanner);
        stream.read_tokens();
        Parser parser(stream);
        if (parser.parse())
        {
            if (!eval_int(parser.ast(), g_value))
            {
                return syntax_error();
            }
        }
        else
        {
            return syntax_error();
        }

        if (*ptr == ',')
        {
            ++ptr;
            nMode = 3;
            do_retry = true;
            return EXITCODE_SUCCESS;
        }
        else if (*ptr == '\"')
        {
            nMode = 3;
            do_retry = true;
            return EXITCODE_SUCCESS;
        }
        else if (*ptr == 0)
        {
            nMode = 3;
        }
        else
        {
            return syntax_error();
        }
    }

    return EXITCODE_SUCCESS;
}

int do_mode_3(char*& ptr, int& nMode, bool& do_retry)
{
    ptr = mstr_skip_space(ptr);
    if (*ptr == ',')
    {
        ++ptr;
    }
    ptr = mstr_skip_space(ptr);
    if (*ptr == '"')
    {
        MStringA str = ptr;
        mstr_unquote(str);

        MStringW wstr(MAnsiToWide(g_wCodePage, str.c_str()).c_str());
        g_msg_tables[g_langid].m_map[(DWORD)g_value] = wstr;

        const char *ptr0 = ptr;
        guts_quote(str, ptr0);
        ptr = const_cast<char *>(ptr0);

        nMode = 2;
        do_retry = true;
        return EXITCODE_SUCCESS;
    }

    if (*ptr != 0)
    {
        return syntax_error();
    }

    return EXITCODE_SUCCESS;
}

int do_directive(char*& ptr)
{
    ++ptr;
    ptr = mstr_skip_space(ptr);
    if (mchr_is_digit(*ptr))
    {
        do_directive_line(ptr);
    }
    else if (memcmp(ptr, "pragma", 6) == 0)
    {
        // #pragma
        ptr += 6;
        ptr = mstr_skip_space(ptr);
        char *ptr2 = ptr;
        if (memcmp(ptr, "pack", 4) == 0)
        {
            // #pragma pack...
        }
        else if (memcmp(ptr, "code_page", 9) == 0)
        {
            ptr += 9;
            ptr = mstr_skip_space(ptr);
            if (*ptr == '(')
            {
                ++ptr;
                ptr = mstr_skip_space(ptr);
                // #pragma code_page(...)
                uint16_t wCodePage = 0;
                if (mchr_is_digit(*ptr))
                {
                    wCodePage = uint16_t(strtol(ptr, NULL, 0));
                }
                while (mchr_is_alnum(*ptr))
                {
                    ++ptr;
                }
                ptr = mstr_skip_space(ptr);
                if (*ptr == ')')
                {
                    ++ptr;
                    g_wCodePage = wCodePage;
                }
                else
                {
                    fprintf(stderr, "%s (%d): WARNING: Invalid pragma: %s\n", g_strFile.c_str(), g_nLineNo, ptr2);
                }
            }
            else
            {
                fprintf(stderr, "%s (%d): WARNING: Invalid pragma: %s\n", g_strFile.c_str(), g_nLineNo, ptr2);
            }
        }
        else
        {
            fprintf(stderr, "%s (%d): WARNING: Unknown pragma: %s\n", g_strFile.c_str(), g_nLineNo, ptr2);
        }
    }

    return EXITCODE_SUCCESS;
}

int eat_output(const std::string& output)
{
    g_msg_tables.clear();

    std::vector<std::string> lines;
    mstr_split(lines, output, "\n");

    for (size_t i = 0; i < lines.size(); ++i)
    {
        mstr_trim(lines[i]);
    }

    // parse lines
    int nMode = 0;
    uint8_t bPrimLang = 0, bSubLang = 0;
    for (size_t i = 0; i < lines.size(); ++i, ++g_nLineNo)
    {
        std::string& line = lines[i];
        if (line.empty())
            continue;
        char *ptr = &line[0];
        if (*ptr == '#')
        {
            if (int ret = do_directive(ptr))
                return ret;

            continue;
        }
        else if (memcmp("LANGUAGE", ptr, 8) == 0 &&
            (ptr[8] == 0 || mchr_is_space(ptr[8])))
        {
            // LANGUAGE (primary), (sublang)
            ptr += 8;
            nMode = -1;
        }
retry:
        if (nMode == -1 && *ptr)    // after LANGUAGE
        {
            ptr = mstr_skip_space(ptr);
            if (mchr_is_digit(*ptr))
            {
                nMode = -2;
            }
        }
        if (nMode == -2 && *ptr)    // expect PRIMARYLANGID
        {
            ptr = mstr_skip_space(ptr);
            char *ptr0 = ptr;
            while (mchr_is_alnum(*ptr))
            {
                ++ptr;
            }
            if (mchr_is_digit(*ptr0))
            {
                bPrimLang = (uint8_t)strtoul(ptr0, NULL, 0);
                nMode = -3;
            }
            else if (*ptr)
            {
                return syntax_error();
            }
        }
        if (nMode == -3 && *ptr)    // expect comma
        {
            ptr = mstr_skip_space(ptr);
            if (*ptr == ',')
            {
                ++ptr;
                nMode = -4;
            }
        }
        if (nMode == -4 && *ptr)    // expect SUBLANGID
        {
            ptr = mstr_skip_space(ptr);
            if (mchr_is_digit(*ptr))
            {
                bSubLang = (uint8_t)strtoul(ptr, NULL, 0);
                g_langid = MAKELANGID(bPrimLang, bSubLang);
                nMode = 0;
            }
            else if (*ptr)
            {
                return syntax_error();
            }
        }
        if (nMode == 0 && *ptr) // out of MESSAGETABLEDX { ... }
        {
            ptr = mstr_skip_space(ptr);
            if (memcmp("MESSAGETABLEDX", ptr, 14) == 0 &&
                (mchr_is_space(ptr[14]) || ptr[14] == 0 || ptr[14] == '{'))  // }
            {
                nMode = 1;
                ptr += 14;
                ptr = mstr_skip_space(ptr);
            }
        }
        if (nMode == 1 && *ptr) // after MESSAGETABLEDX
        {
            bool do_retry = false;
            if (int ret = do_mode_1(ptr, nMode, do_retry))
                return ret;
            if (do_retry)
                goto retry;
        }
        if (nMode == 2 && *ptr) // in MESSAGETABLEDX { ... }
        {
            bool do_retry = false;
            if (int ret = do_mode_2(ptr, nMode, do_retry))
                return ret;
            if (do_retry)
                goto retry;
        }
        if (nMode == 3 && *ptr)
        {
            bool do_retry = false;
            if (int ret = do_mode_3(ptr, nMode, do_retry))
                return ret;
            if (do_retry)
                goto retry;
        }
    }
    if (nMode != 0)
    {
        return syntax_error();
    }

    return EXITCODE_SUCCESS;
}

int save_rc(const char *output_file)
{
    FILE *fp;
    if (output_file)
    {
        fp = fopen(output_file, "wb");
        if (!fp)
        {
            fprintf(stderr, "ERROR: Unable to open output file.\n");
            return EXITCODE_CANNOT_OPEN;
        }
    }
    else
    {
        fp = stdout;
    }

    fprintf(fp, "#pragma code_page(65001) /* UTF-8 */\r\n\r\n");

    msg_tables_type::iterator it, end = g_msg_tables.end();
    for (it = g_msg_tables.begin(); it != end; ++it)
    {
        fprintf(fp, "#ifdef MCDX_INVOKED\r\n");
        fprintf(fp, "LANGUAGE 0x%02X, 0x%02X\r\n",
                PRIMARYLANGID(it->first), SUBLANGID(it->first));

        MStringW wstr = it->second.Dump();
        MStringA str = MWideToAnsi(CP_UTF8, wstr.c_str()).c_str();

        fputs(str.c_str(), fp);
        fprintf(fp, "#endif\r\n\r\n");
    }

    if (output_file)
        fclose(fp);

    if (ferror(fp))
    {
        if (output_file)
            _unlink(output_file);
        fprintf(stderr, "ERROR: Unable to write output file.\n");
        return EXITCODE_CANNOT_OPEN;
    }

    return EXITCODE_SUCCESS;
}

int save_res(const char *output_file)
{
    MByteStreamEx bs;
    ResHeader header;
    if (!header.WriteTo(bs))
        return EXITCODE_INVALID_DATA;

    msg_tables_type::iterator it, end = g_msg_tables.end();
    for (it = g_msg_tables.begin(); it != end; ++it)
    {
        MByteStreamEx stream;
        it->second.SaveToStream(stream);

        header.DataSize = DWORD(stream.size());
        header.HeaderSize = header.GetHeaderSize(RT_MESSAGETABLE, 1);
        if (header.HeaderSize == 0 || header.HeaderSize >= 0x10000)
            return FALSE;

        header.type = RT_MESSAGETABLE;
        header.name = 1;
        header.DataVersion = 0;
        header.MemoryFlags = MEMORYFLAG_DISCARDABLE | MEMORYFLAG_PURE |
                             MEMORYFLAG_MOVEABLE;
        header.LanguageId = it->first;
        header.Version = 0;
        header.Characteristics = 0;

        if (!header.WriteTo(bs))
            return FALSE;

        if (!bs.WriteData(&stream[0], stream.size()))
            return FALSE;

        bs.WriteDwordAlignment();
    }

    FILE *fp;
    if (output_file)
    {
        fp = fopen(output_file, "wb");
        if (!fp)
        {
            fprintf(stderr, "ERROR: Unable to open output file.\n");
            return EXITCODE_CANNOT_OPEN;
        }
    }
    else
    {
        fp = stdout;
    }

    fwrite(&bs[0], bs.size(), 1, fp);

    if (output_file)
        fclose(fp);

    if (ferror(fp))
    {
        if (output_file)
            _unlink(output_file);
        fprintf(stderr, "ERROR: Unable to write output file.\n");
        return EXITCODE_CANNOT_OPEN;
    }

    return EXITCODE_SUCCESS;
}

int save_coff(const char *output_file)
{
    char temp_file[MAX_PATH];

    if (FILE *fp = tmpfilenam(temp_file))
    {
        fclose(fp);
    }
    else
    {
        fprintf(stderr, "ERROR: Unable to create temporary file.\n");
        return EXITCODE_CANT_MAKE_TEMP;
    }
    
    if (int ret = save_res(temp_file))
    {
        return ret;
    }

    MStringA command_line;
    command_line += g_windres;
    command_line += " \"";
    command_line += temp_file;
    if (output_file)
    {
        command_line += "\" \"";
        command_line += output_file;
        command_line += "\"";
    }
    else
    {
        command_line += "\" -O coff";
    }

    // create a process
#if defined(_WIN32) && !defined(WONVER)
    MProcessMaker maker;
    maker.SetShowWindow(SW_HIDE);
    maker.SetCreationFlags(CREATE_NEW_CONSOLE);
    MFile hInputWrite, hOutputRead;
    SetEnvironmentVariableA("LANG", "en_US");
    if (maker.PrepareForRedirect(&hInputWrite, &hOutputRead) &&
        maker.CreateProcessDx(NULL, command_line.c_str()))
    {
        std::string output;
        maker.ReadAll(output, hOutputRead);

        if (maker.GetExitCode() == 0)
        {
            return EXITCODE_SUCCESS;
        }
        else if (output.find(": no resources") != std::string::npos)
        {
            output.clear();
            return EXITCODE_SUCCESS;
        }

        fputs(output.c_str(), stderr);
    }
#else
    putenv(g_lang_english);
    if (FILE *fp = popen(command_line.c_str(), "r"))
    {
        std::string output;

        char buf[256];
        for (;;)
        {
            size_t count = fread(buf, 1, _countof(buf), fp);
            if (!count)
                break;
            output.append(buf, count);
        }
        if (pclose(fp) == 0)
        {
            return EXITCODE_SUCCESS;
        }
        else if (output.find(": no resources") != std::string::npos)
        {
            output.clear();
            return EXITCODE_SUCCESS;
        }

        fputs(output.c_str(), stderr);
    }
#endif

    fprintf(stderr, "ERROR: Failed to create process\n");
    return EXITCODE_FAIL_TO_PREPROCESS;
}

int save_bin(const char *output_file)
{
    MessageRes msg_res = g_msg_tables.begin()->second;

    MByteStreamEx stream;
    msg_res.SaveToStream(stream);

    FILE *fp;
    if (output_file)
    {
        fp = fopen(output_file, "wb");
        if (!fp)
        {
            fprintf(stderr, "ERROR: Unable to open output file.\n");
            return EXITCODE_CANNOT_OPEN;
        }
    }
    else
    {
        fp = stdout;
    }

    fwrite(&stream[0], stream.size(), 1, fp);

    if (output_file)
        fclose(fp);

    if (ferror(fp))
    {
        if (output_file)
            _unlink(output_file);
        fprintf(stderr, "ERROR: Unable to write output file.\n");
        return EXITCODE_CANNOT_OPEN;
    }

    return EXITCODE_SUCCESS;
}

bool IsUTF16File(const char *input_file)
{
    if (FILE *fp = fopen(input_file, "rb"))
    {
        char ab[2];
        if (fread(ab, 1, 2, fp) == 2)
        {
            if (memcmp(ab, "\xFF\xFE", 2) == 0)
            {
                fclose(fp);
                return true;
            }
            if (ab[0] && !ab[1])
            {
                fclose(fp);
                return true;
            }
        }
        fclose(fp);
    }
    return false;
}

int load_rc(const char *input_file)
{
    // definitions minus undefinitions
    for (size_t i = 0; i < g_undefinitions.size(); ++i)
    {
        for (size_t k = 0; k < g_definitions.size(); ++k)
        {
            if (g_definitions[k].find(g_undefinitions[i]) == 0)
            {
                size_t len = g_undefinitions[i].size();
                if (g_definitions[k].c_str()[len] == 0 ||
                    g_definitions[k].c_str()[len] == L'=')
                {
                    g_definitions.erase(g_definitions.begin() + k);
                    --k;
                }
            }
        }
    }

    // build up command line
    MString command_line;
    command_line += g_cpp;
    command_line += ' ';
    for (size_t i = 0; i < g_definitions.size(); ++i)
    {
        command_line += " -D";
        command_line += g_definitions[i];
    }
    for (size_t i = 0; i < g_include_directories.size(); ++i)
    {
        command_line += " -I\"";
        command_line += g_include_directories[i];
        command_line += "\"";
    }
    command_line += " \"";
    command_line += input_file;
    command_line += "\"";

    g_strFile = input_file;
    g_nLineNo = 1;

    // create a process
#if defined(_WIN32) && !defined(WONVER)
    MProcessMaker maker;
    maker.SetShowWindow(SW_HIDE);
    maker.SetCreationFlags(CREATE_NEW_CONSOLE);
    MFile hInputWrite, hOutputRead;
    if (maker.PrepareForRedirect(&hInputWrite, &hOutputRead) &&
        maker.CreateProcessDx(NULL, command_line.c_str()))
    {
        std::string output;
        maker.ReadAll(output, hOutputRead);

        if (maker.GetExitCode() == 0)
        {
            // eat the output
            if (int ret = eat_output(output))
                return ret;

            return EXITCODE_SUCCESS;
        }

        fputs(output.c_str(), stderr);
    }
#else
    putenv(g_lang_english);
    if (FILE *fp = popen(command_line.c_str(), "r"))
    {
        std::string output;

        char buf[256];
        for (;;)
        {
            size_t count = fread(buf, 1, _countof(buf), fp);
            if (!count)
                break;
            output.append(buf, count);
        }
        if (pclose(fp) == 0)
        {
            // eat the output
            if (int ret = eat_output(output))
                return ret;

            return EXITCODE_SUCCESS;
        }

        fputs(output.c_str(), stderr);
    }
#endif

    fprintf(stderr, "ERROR: Failed to preprocess\n");
    return EXITCODE_FAIL_TO_PREPROCESS;
}

int load_bin(const char *input_file)
{
    FILE *fp = fopen(input_file, "rb");
    if (!fp)
    {
        fprintf(stderr, "ERROR: Unable to open input file.\n");
        return EXITCODE_CANNOT_OPEN;
    }

    std::string contents;
    char buf[256];
    for (;;)
    {
        size_t len = fread(buf, 1, 256, fp);
        if (!len)
            break;
        contents.append(buf, len);
    }
    fclose(fp);

    MByteStreamEx stream(&contents[0], contents.size());
    if (!g_msg_tables[g_langid].LoadFromStream(stream, 1))
    {
        fprintf(stderr, "ERROR: Invalid data.\n");
        return EXITCODE_INVALID_DATA;
    }

    return EXITCODE_SUCCESS;
}

int load_res(const char *input_file)
{
    FILE *fp = fopen(input_file, "rb");
    if (!fp)
    {
        fprintf(stderr, "ERROR: Unable to open input file.\n");
        return EXITCODE_CANNOT_OPEN;
    }

    std::string contents;
    char buf[256];
    for (;;)
    {
        size_t len = fread(buf, 1, 256, fp);
        if (!len)
            break;
        contents.append(buf, len);
    }
    fclose(fp);

    MByteStreamEx stream(&contents[0], contents.size());
    ResHeader header;
    while (header.ReadFrom(stream))
    {
        if (header.DataSize == 0)
        {
            stream.ReadDwordAlignment();
            continue;
        }

        if (header.DataSize > stream.remainder())
        {
            fprintf(stderr, "ERROR: Data is broken, invalid, or not supported.\n");
            return EXITCODE_INVALID_DATA;
        }

        MByteStreamEx bs(header.DataSize);
        if (!stream.ReadData(&bs[0], header.DataSize))
        {
            break;
        }
        if (!g_msg_tables[header.LanguageId].LoadFromStream(bs, 1))
        {
            fprintf(stderr, "ERROR: Data is broken, invalid, or not supported.\n");
            return EXITCODE_INVALID_DATA;
        }

        stream.ReadDwordAlignment();
    }

    return EXITCODE_SUCCESS;
}

int just_do_it(void)
{
    if (strcmp(g_inp_format, "rc") == 0)
    {
        if (int ret = load_rc(g_input_file))
            return ret;
    }
    else if (strcmp(g_inp_format, "res") == 0)
    {
        if (int ret = load_res(g_input_file))
            return ret;
    }
    else if (strcmp(g_inp_format, "bin") == 0)
    {
        if (int ret = load_bin(g_input_file))
            return ret;
    }
    else if (strcmp(g_inp_format, "coff") == 0)
    {
        fprintf(stderr, "ERROR: COFF input format is not supported yet.\n");
        return EXITCODE_NOT_SUPPORTED_YET;
    }
    else
    {
        fprintf(stderr, "ERROR: invalid input format\n");
        return EXITCODE_INVALID_ARGUMENT;
    }

    if (strcmp(g_out_format, "rc") == 0)
    {
        return save_rc(g_output_file);
    }
    else if (strcmp(g_out_format, "res") == 0)
    {
        return save_res(g_output_file);
    }
    else if (strcmp(g_out_format, "bin") == 0)
    {
        return save_bin(g_output_file);
    }
    else if (strcmp(g_out_format, "coff") == 0)
    {
        return save_coff(g_output_file);
    }
    else
    {
        fprintf(stderr, "ERROR: invalid output format\n");
        return EXITCODE_INVALID_ARGUMENT;
    }
}

const char *get_format(const char *file_path)
{
    const char *pch = mstrrchr(file_path, '.');
    if (pch == NULL)
    {
        return "rc";
    }
    else if (strcmp(pch, ".rc") == 0)
    {
        return "rc";
    }
    else if (strcmp(pch, ".res") == 0)
    {
        return "res";
    }
    else if (strcmp(pch, ".bin") == 0)
    {
        return "bin";
    }
    else if (strcmp(pch, ".o") == 0 ||
             strcmp(pch, ".obj") == 0 ||
             strcmp(pch, ".coff") == 0)
    {
        return "coff";
    }
    else
    {
        return "rc";
    }
}

//////////////////////////////////////////////////////////////////////////////

int main(int argc, char **argv)
{
    static const struct option long_options[] =
    {
        {"help",            required_argument, NULL, 'h' },
        {"version",         no_argument,       NULL, 'V' },
        {"input",           required_argument, NULL, 'i' },
        {"output",          required_argument, NULL, 'o' },
        {"input-format",    required_argument, NULL, 'J' },
        {"output-format",   required_argument, NULL, 'O' },
        {"include-dir",     required_argument, NULL, 'I' },
        {"define",          required_argument, NULL, 'D' },
        {"undefine",        required_argument, NULL, 'U' },
        {"codepage",        required_argument, NULL, 'c' },
        {"language",        required_argument, NULL, 'l' },
        {"preprocessor",    required_argument, NULL, 'p' },
        {"windres",         required_argument, NULL, 'w' },
        {0,                 0,                 NULL, 0   }
    };

#ifdef __CYGWIN__
    extern char __declspec(dllimport) *__progname;
    g_progname = __progname;
#else
    g_progname = argv[0];
#endif

    g_definitions.push_back("RC_INVOKED");
    g_definitions.push_back("MCDX_INVOKED");

    // parse command line
    while (1)
    {
        int option_index = 0;
        int c = getopt_long(argc, argv, "hVi:o:J:O:I:D:U:c:l:",
                            long_options, &option_index);
        if (c == -1)
            break;

        switch (c) {
        case 'h':
            show_help();
            return EXITCODE_SUCCESS;
        case 'V':
            show_version();
            return EXITCODE_SUCCESS;
        case 'i':
            if (g_input_file)
            {
                fprintf(stderr, "ERROR: Too many input files\n");
                return EXITCODE_INVALID_ARGUMENT;
            }
            else
            {
                g_input_file = optarg;
            }
            break;
        case 'o':
            if (g_output_file)
            {
                fprintf(stderr, "ERROR: Too many output files\n");
                return EXITCODE_INVALID_ARGUMENT;
            }
            else
            {
                g_output_file = optarg;
            }
            break;
        case 'J':
            g_inp_format = optarg;
            break;
        case 'O':
            g_out_format = optarg;
            break;
        case 'I':
            g_include_directories.push_back(optarg);
            break;
        case 'D':
            g_definitions.push_back(optarg);
            break;
        case 'U':
            g_undefinitions.push_back(optarg);
            break;
        case 'c':
            g_wCodePage = (uint16_t)strtol(optarg, NULL, 0);
            break;
        case 'l':
            {
                uint16_t w = (uint16_t)strtol(optarg, NULL, 0);
                uint8_t bPrim = LOBYTE(w);
                uint8_t bSub = HIBYTE(w);
                g_langid = MAKELANGID(bPrim, bSub);
            }
            break;
        case 'p':
            g_cpp = optarg;
            break;
        case 'w':
            g_windres = optarg;
            break;
        default:
            assert(0);
            break;
        }
    }

    if (optind < argc)
    {
        while (optind < argc)
        {
            if (g_input_file == NULL)
            {
                g_input_file = argv[optind++];
            }
            else if (g_output_file == NULL)
            {
                g_output_file = argv[optind++];
            }
            else
            {
                fprintf(stderr, "ERROR: Too many arguments\n");
                return EXITCODE_INVALID_ARGUMENT;
            }
        }
    }

    if (g_input_file == NULL)
    {
        static TCHAR s_szTempFile[MAX_PATH] = TEXT("");
        FILE *fp = tmpfilenam(s_szTempFile);
        if (fp == NULL)
        {
            fprintf(stderr, "ERROR: Unable to create temporary file\n");
            return EXITCODE_CANT_MAKE_TEMP;
        }

        char buf[512];
        while (fgets(buf, _countof(buf), stdin) != NULL)
        {
            fputs(buf, fp);
        }
        fclose(fp);

        g_input_file = s_szTempFile;
    }

    if (g_inp_format == NULL)
    {
        g_inp_format = get_format(g_input_file);
    }

    if (g_out_format == NULL)
    {
        if (g_output_file)
        {
            g_out_format = get_format(g_output_file);
        }
        else
        {
            g_out_format = "rc";
        }
    }

    int ret = just_do_it();
    return ret;
}

//////////////////////////////////////////////////////////////////////////////

```

`src/AccelRes.cpp`:

```cpp
// AccelRes.cpp --- Accelerator-Table Resource
//////////////////////////////////////////////////////////////////////////////
// RisohEditor --- Another free Win32 resource editor
// Copyright (C) 2017-2018 Katayama Hirofumi MZ <katayama.hirofumi.mz@gmail.com>
// 
// This program is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
// 
// This program is distributed in the hope that it will be useful, 
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
// 
// You should have received a copy of the GNU General Public License
// along with this program.  If not, see <http://www.gnu.org/licenses/>.
//////////////////////////////////////////////////////////////////////////////

#include "AccelRes.hpp"
#include "ConstantsDB.hpp"

bool AccelRes::LoadFromStream(const MByteStreamEx& stream)
{
    m_entries.clear();
    if (stream.size() < sizeof(entry_type))
        return false;

    entry_type entry;
    size_t i, count = stream.size() / sizeof(entry_type);
    for (i = 0; i < count; ++i)
    {
        if (!stream.ReadRaw(entry))
            return false;

        m_entries.push_back(entry);

        if (entry.fFlags & 0x80)
            break;
    }

    return true;
}

void AccelRes::Update()
{
    size_t i, count = m_entries.size();
    for (i = 0; i < count; ++i)
    {
        entry_type& entry = m_entries[i];

        if (i + 1 == count)
            entry.fFlags |= 0x80;
        else
            entry.fFlags &= ~0x80;
    }
}

std::vector<BYTE> AccelRes::data() const
{
    size_t size = m_entries.size() * sizeof(entry_type);
    const BYTE *pb = (const BYTE *)&m_entries[0];
    return std::vector<BYTE>(pb, pb + size);
}

MStringW AccelRes::Dump(const MIdOrString &id_or_str) const
{
    MStringW ret;

    if (id_or_str.m_id == 0)
    {
        ret += id_or_str.str();
    }
    else
    {
        ret += g_db.GetNameOfResID(IDTYPE_ACCEL, id_or_str.m_id);
    }
    ret += L" ";
    ret += L"ACCELERATORS\r\n";
    if (g_settings.bUseBeginEnd)
        ret += L"BEGIN\r\n";
    else
        ret += L"{\r\n";

    for (auto& entry : m_entries)
    {
        bool VIRTKEY = !!(entry.fFlags & FVIRTKEY);
        bool NOINVERT = !!(entry.fFlags & FNOINVERT);
        bool SHIFT = !!(entry.fFlags & FSHIFT);
        bool CONTROL = !!(entry.fFlags & FCONTROL);
        bool ALT = !!(entry.fFlags & FALT);

        ret += L"    ";
        if (VIRTKEY)
        {
            ret += g_db.GetName(L"VIRTUALKEYS", entry.wAscii);
        }
        else
        {
            std::string str;
            str += (char)entry.wAscii;
            ret += MAnsiToWide(CP_ACP, mstr_quote(str));
        }
        ret += L", ";
        if (0)
        {
            ret += mstr_dec_word(entry.wId);
        }
        else
        {
            ret += g_db.GetNameOfResID(IDTYPE_COMMAND, IDTYPE_NEWCOMMAND,
                                       entry.wId, true);
        }

        if (NOINVERT)
            ret += L", NOINVERT";
        if (ALT)
            ret += L", ALT";
        if (CONTROL)
            ret += L", CONTROL";
        if (SHIFT)
            ret += L", SHIFT";

        if (VIRTKEY)
            ret += L", VIRTKEY";
        else
            ret += L", ASCII";

        ret += L"\r\n";
    }

    if (g_settings.bUseBeginEnd)
        ret += L"END\r\n";
    else
        ret += L"}\r\n";
    return ret;
}

```

`src/AccelRes.hpp`:

```hpp
// AccelRes.hpp --- Accelerator-Table Resource
//////////////////////////////////////////////////////////////////////////////
// RisohEditor --- Another free Win32 resource editor
// Copyright (C) 2017-2018 Katayama Hirofumi MZ <katayama.hirofumi.mz@gmail.com>
// 
// This program is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
// 
// This program is distributed in the hope that it will be useful, 
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
// 
// You should have received a copy of the GNU General Public License
// along with this program.  If not, see <http://www.gnu.org/licenses/>.
//////////////////////////////////////////////////////////////////////////////

#pragma once

#ifndef _INC_WINDOWS
    #include <windows.h>
#endif
#include <cassert>
#include <vector>

#include "MByteStreamEx.hpp"
#include "MString.hpp"

//////////////////////////////////////////////////////////////////////////////

struct ACCEL_ENTRY
{
    WCHAR sz0[128];
    WCHAR sz1[16];
    WCHAR sz2[128];
};

struct AccelTableEntry
{
    WORD   fFlags;
    WORD   wAscii;
    WORD   wId;
    WORD   padding;
};

//////////////////////////////////////////////////////////////////////////////

class AccelRes
{
public:
    typedef AccelTableEntry             entry_type;
    typedef std::vector<entry_type>     entries_type;
    AccelRes() = default;

    bool LoadFromStream(const MByteStreamEx& stream);
    MStringW Dump(const MIdOrString &id_or_str) const;
    void Update();

    std::vector<BYTE> data() const;

    entries_type& entries()
    {
        return m_entries;
    }
    const entries_type& entries() const
    {
        return m_entries;
    }

protected:
    entries_type    m_entries;
};

//////////////////////////////////////////////////////////////////////////////

inline MStringW GetKeyFlags(WORD fFlags)
{
    MStringW str;

    if (fFlags & FVIRTKEY)
        str += L"V ";

    if (fFlags & FNOINVERT)
        str += L"N ";

    if (fFlags & FCONTROL)
        str += L"C ";

    if (fFlags & FSHIFT)
        str += L"S ";

    if (fFlags & FALT)
        str += L"A ";

    return str;
}

inline void SetKeyFlags(WORD& fFlags, const MStringW& str)
{
    fFlags = 0;
    if (str.find(L'V') != MStringW::npos)
        fFlags |= FVIRTKEY;
    if (str.find(L'N') != MStringW::npos)
        fFlags |= FNOINVERT;
    if (str.find(L'C') != MStringW::npos)
        fFlags |= FCONTROL;
    if (str.find(L'S') != MStringW::npos)
        fFlags |= FSHIFT;
    if (str.find(L'A') != MStringW::npos)
        fFlags |= FALT;
}

```

`src/CMakeLists.txt`:

```txt
# libRisohEditor.a
add_library(libRisohEditor STATIC
    AccelRes.cpp
    DialogRes.cpp
    DlgInitRes.cpp
    IconRes.cpp
    MenuRes.cpp
    MOleHost.cpp
    PackedDIB.cpp
    Res.cpp
    ResToText.cpp
    StringRes.cpp
    ToolbarRes.cpp
    VersionRes.cpp)
set_target_properties(libRisohEditor PROPERTIES PREFIX "")

# RisohEditor.exe
add_executable(RisohEditor WIN32
    RisohEditor.cpp
    RisohEditor_res.rc
    res/Manifest_1.manifest)
target_link_libraries(RisohEditor
    LineNumEdit_static libRisohEditor
    libega gdi32 comctl32 msimg32 winmm gdiplus vfw32 wininet
    oledlg msimg32 advapi32 shlwapi version urlmon)
target_compile_definitions(RisohEditor PRIVATE -DUNICODE -D_UNICODE)

# RisohEditorPortable.exe
add_executable(RisohEditorPortable WIN32
    RisohEditor.cpp
    RisohEditor_res.rc
    res/Manifest_1.manifest)
target_link_libraries(RisohEditorPortable
    LineNumEdit_static libRisohEditor
    libega gdi32 comctl32 msimg32 winmm gdiplus vfw32 wininet
    oledlg msimg32 advapi32 shlwapi version urlmon)
target_compile_definitions(RisohEditorPortable PRIVATE -DPORTABLE -DUNICODE -D_UNICODE)

option(ATL_SUPPORT "Add ATL support" OFF)

if (MSVC)
    set(DOTRES ".res") # resource object extension
    # ATL Support
    if (ATL_SUPPORT)
        add_definitions(-DATL_SUPPORT)
    endif()
    # No auto manifest
    set(CMAKE_EXE_LINKER_FLAGS    "${CMAKE_EXE_LINKER_FLAGS} /MANIFEST:NO")
    set(CMAKE_MODULE_LINKER_FLAGS "${CMAKE_MODULE_LINKER_FLAGS} /MANIFEST:NO")
    set(CMAKE_SHARED_LINKER_FLAGS "${CMAKE_SHARED_LINKER_FLAGS} /MANIFEST:NO")
else()
    set(DOTRES ".o") # resource object extension
    list(APPEND CMAKE_CXX_LINK_FLAGS -municode) # Unicode support
endif()

# use Unicode
add_definitions(-DUNICODE=1 -D_UNICODE=1)

## messagetables.res or messagetables.o
#add_custom_target(messagetables ALL
#    mcdx ${CMAKE_CURRENT_SOURCE_DIR}/RisohEditor_res.rc --preprocessor=${CMAKE_SOURCE_DIR}\\data\\bin\\cpp.exe ${LANG_DEFS} ${CMAKE_RUNTIME_OUTPUT_DIRECTORY}/${CMAKE_CFG_INTDIR}/messagetables${DOTRES}
#    DEPENDS mcdx ${CMAKE_CURRENT_SOURCE_DIR}/RisohEditor_res.rc
#    BYPRODUCTS ${CMAKE_RUNTIME_OUTPUT_DIRECTORY}/${CMAKE_CFG_INTDIR}/messagetables${DOTRES}
#    COMMENT "mcdx ${CMAKE_CURRENT_SOURCE_DIR}/RisohEditor_res.rc --preprocessor=${CMAKE_SOURCE_DIR}\\data\\bin\\cpp.exe ${CMAKE_RUNTIME_OUTPUT_DIRECTORY}/${CMAKE_CFG_INTDIR}/messagetables${DOTRES}"
#    VERBATIM)
#add_dependencies(RisohEditor messagetables)
#add_dependencies(messagetables mcdx)
#set_target_properties(RisohEditor PROPERTIES LINK_FLAGS ${CMAKE_RUNTIME_OUTPUT_DIRECTORY}/${CMAKE_CFG_INTDIR}/messagetables${DOTRES})

# do statically link
set_target_properties(RisohEditor PROPERTIES LINK_SEARCH_START_STATIC 1)
set_target_properties(RisohEditor PROPERTIES LINK_SEARCH_END_STATIC 1)

```

`src/Common.hpp`:

```hpp
#pragma once

BOOL CheckCommand(MString strCommand);
BOOL CheckCommand(MString& strCommand);
BOOL CheckLangComboBox(HWND hCmb3, WORD& lang);
BOOL CheckLangComboBox(HWND hCmb3, WORD& lang, BOOL bUILanguage);
BOOL CheckNameComboBox(HWND hCmb2, MIdOrString& name);
BOOL CheckTypeComboBox(HWND hCmb1, MIdOrString& type);
BOOL Cmb1_CheckKey(HWND hwnd, HWND hCmb1, BOOL bVirtKey, std::wstring& str);
BOOL Edt1_CheckFile(HWND hEdt1, std::wstring& file);
BOOL InitLangListBox(HWND hwnd);
BOOL IsThereWndClass(const WCHAR *pszName);
BYTE GetCharSetFromComboBox(HWND hCmb);
DWORD AnalyseStyleDiff(DWORD dwValue, ConstantsDB::TableType& table, std::vector<BYTE>& old_sel, std::vector<BYTE>& new_sel);
MString GetAssoc(const MString& name);
MString GetLanguageStatement(WORD langid, BOOL bOldStyle);
MStringW GetRisohTemplate(const MIdOrString& type, WORD wLang);
MStringW TextFromLang(WORD lang);
WORD LangFromText(LPWSTR pszLang);
std::vector<INT> GetPrefixIndexes(const MString& prefix);
std::wstring GetKeyID(UINT wId);
void Cmb1_InitVirtualKeys(HWND hCmb1);
void GetStyleSelect(HWND hLst, std::vector<BYTE>& sel);
void GetStyleSelect(std::vector<BYTE>& sel, const ConstantsDB::TableType& table, DWORD dwValue);
void InitCaptionComboBox(HWND hCmb, LPCTSTR pszCaption);
void InitCharSetComboBox(HWND hCmb, BYTE CharSet);
void InitClassComboBox(HWND hCmb, LPCTSTR pszClass);
void InitComboBoxPlaceholder(HWND hCmb, UINT nStringID);
void InitConstantComboBox(HWND hCmb);
void InitCtrlIDComboBox(HWND hCmb);
void InitFontComboBox(HWND hCmb);
void InitLangComboBox(HWND hCmb3, LANGID langid);
void InitLangComboBox(HWND hCmb3, LANGID langid, BOOL bUILanguage);
void InitLangListView(HWND hLst1, LPCTSTR pszText);
void InitMessageComboBox(HWND hCmb, const MString& strString);
void InitResNameComboBox(HWND hCmb, const MIdOrString& id, IDTYPE_ nIDTYPE_);
void InitResNameComboBox(HWND hCmb, const MIdOrString& id, INT nIDTYPE_1, INT nIDTYPE_2);
void InitResTypeComboBox(HWND hCmb1, const MIdOrString& type);
void InitStringComboBox(HWND hCmb, const MString& strString);
void InitStyleListBox(HWND hLst, ConstantsDB::TableType& table);
void InitWndClassComboBox(HWND hCmb, LPCTSTR pszWndClass);
void ReplaceFullWithHalf(LPWSTR pszText);
void ReplaceFullWithHalf(MStringW& strText);

```

`src/ConstantsDB.hpp`:

```hpp
// ConstantsDB.hpp --- Constants Database
//////////////////////////////////////////////////////////////////////////////
// RisohEditor --- Another free Win32 resource editor
// Copyright (C) 2017-2020 Katayama Hirofumi MZ <katayama.hirofumi.mz@gmail.com>
// 
// This program is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
// 
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
// 
// You should have received a copy of the GNU General Public License
// along with this program.  If not, see <http://www.gnu.org/licenses/>.
//////////////////////////////////////////////////////////////////////////////

#pragma once

#include <string>
#include <vector>
#include <map>
#include <cctype>
#include <cstdio>
#include <iostream>

#include "MString.hpp"
#include "MIdOrString.hpp"
#include "RisohSettings.hpp"

//////////////////////////////////////////////////////////////////////////////

enum IDTYPE_
{
    IDTYPE_UNKNOWN      = 0,  // Unknown.ID
    IDTYPE_CURSOR       = 1,  // Cursor.ID
    IDTYPE_BITMAP       = 2,  // Bitmap.ID
    IDTYPE_MENU         = 3,  // Menu.ID
    IDTYPE_DIALOG       = 4,  // Dialog.ID
    IDTYPE_STRING       = 5,  // String.ID
    IDTYPE_ACCEL        = 6,  // Accel.ID
    IDTYPE_ICON         = 7,  // Icon.ID
    IDTYPE_ANICURSOR    = 8,  // AniCursor.ID
    IDTYPE_ANIICON      = 9,  // AniIcon.ID
    IDTYPE_HTML         = 10, // Html.ID
    IDTYPE_HELP         = 11, // Help.ID
    IDTYPE_COMMAND      = 12, // Command.ID
    IDTYPE_CONTROL      = 13, // Control.ID
    IDTYPE_RESOURCE     = 14, // Resource.ID
    IDTYPE_MESSAGE      = 15, // Message.ID
    IDTYPE_WINDOW       = 16, // Window.ID
    IDTYPE_NEWCOMMAND   = 17, // New.Command.ID
    IDTYPE_PROMPT       = 18, // Prompt.ID
    IDTYPE_RCDATA       = 19  // RCData.ID
};

class ConstantsDB
{
public:
    typedef std::wstring StringType;
    typedef StringType NameType;
    typedef StringType CategoryType;
    typedef DWORD ValueType;
    typedef std::vector<ValueType> ValuesType;

    struct EntryType
    {
        NameType    name;
        ValueType   value;
        ValueType   mask;
        bool        selected;

        EntryType(NameType name_, ValueType value_)
            : name(name_), value(value_), mask(value_), selected(false)
        {
        }
        EntryType(NameType name_, ValueType value_, ValueType mask_)
            : name(name_), value(value_), mask(mask_), selected(false)
        {
        }
    };
    typedef std::vector<EntryType> TableType;
    typedef std::map<CategoryType, TableType> MapType;
    MapType m_map;

    bool IsEntityIDType(IDTYPE_ nIDTYPE_) const
    {
        switch (nIDTYPE_)
        {
        case IDTYPE_CURSOR:
        case IDTYPE_BITMAP:
        case IDTYPE_MENU:
        case IDTYPE_DIALOG:
        case IDTYPE_ACCEL:
        case IDTYPE_ICON:
        case IDTYPE_ANICURSOR:
        case IDTYPE_ANIICON:
        case IDTYPE_HTML:
        case IDTYPE_RESOURCE:
        case IDTYPE_RCDATA:
            return true;
        default:
            return false;
        }
    }

    IDTYPE_ IDTypeFromResType(const MIdOrString& type) const
    {
        if (type == RT_CURSOR)
        {
            return IDTYPE_UNKNOWN;
        }
        if (type == RT_BITMAP)
        {
            return IDTYPE_BITMAP;
        }
        if (type == RT_ICON)
        {
            return IDTYPE_UNKNOWN;
        }
        if (type == RT_MENU)
        {
            return IDTYPE_MENU;
        }
        if (type == RT_DIALOG)
        {
            return IDTYPE_DIALOG;
        }
        if (type == RT_STRING)
        {
            return IDTYPE_STRING;
        }
        if (type == RT_ACCELERATOR)
        {
            return IDTYPE_ACCEL;
        }
        if (type == RT_GROUP_CURSOR)
        {
            return IDTYPE_CURSOR;
        }
        if (type == RT_GROUP_ICON)
        {
            return IDTYPE_ICON;
        }
        if (type == RT_VERSION)
        {
            return IDTYPE_UNKNOWN;
        }
        if (type == RT_DLGINCLUDE)
        {
            return IDTYPE_UNKNOWN;
        }
        if (type == RT_ANICURSOR)
        {
            return IDTYPE_ANICURSOR;
        }
        if (type == RT_ANIICON)
        {
            return IDTYPE_ANIICON;
        }
        if (type == RT_HTML)
        {
            return IDTYPE_HTML;
        }
        if (type == RT_MANIFEST)
        {
            return IDTYPE_UNKNOWN;
        }
        if (type == RT_MESSAGETABLE)
        {
            return IDTYPE_MESSAGE;
        }
        if (type == RT_RCDATA)
        {
            return IDTYPE_RCDATA;
        }
        return IDTYPE_RESOURCE;
    }

    ConstantsDB() = default;

    TableType GetTable(CategoryType category) const
    {
        ::CharUpperW(&category[0]);

        MapType::const_iterator it = m_map.find(category);
        if (it == m_map.end())
            return TableType();

        TableType table = it->second;
        return table;
    }

    TableType GetTableByPrefix(CategoryType category, NameType prefix) const
    {
        ::CharUpperW(&category[0]);

        TableType table1;
        MapType::const_iterator found = m_map.find(category);
        if (found == m_map.end())
            return table1;

        const TableType& table2 = found->second;
        TableType::const_iterator it, end = table2.end();
        for (it = table2.begin(); it != end; ++it)
        {
            if (it->name.find(prefix) == 0)
            {
                table1.push_back(*it);
            }
        }
        return table1;
    }

    TableType GetWholeTable() const
    {
        TableType table;
        for (auto& pair : m_map)
        {
            if (pair.first.find(L'.') != StringType::npos)
                continue;

            table.insert(table.end(), pair.second.begin(), pair.second.end());
        }
        return table;
    }

    BOOL GetValueOfName(const NameType& name, ValueType& value) const
    {
        TableType table = GetWholeTable();
        for (const auto& table_entry : table)
        {
            if (table_entry.name == name)
            {
                value = table_entry.value;
                return TRUE;
            }
        }
        return FALSE;
    }

    ValueType GetResIDValue(const NameType& name) const
    {
        ValueType value = GetValue(L"RESOURCE.ID", name);
        if (!value)
        {
            value = GetValue(L"CTRLID", name);
        }
        return value;
    }
    ValueType GetCtrlIDValue(const NameType& name) const
    {
        if (name == L"IDC_STATIC")
            return -1;
        return GetValue(L"CTRLID", name);
    }

    bool HasCtrlID(const NameType& name) const
    {
        if (name == L"IDC_STATIC")
            return true;

        TableType table = GetTable(L"CTRLID");
        for (auto& table_entry : table)
        {
            if (table_entry.name == name)
                return true;
        }
        return false;
    }
    bool HasResID(const NameType& name) const
    {
        TableType table = GetTable(L"RESOURCE.ID");
        for (auto& table_entry : table)
        {
            if (table_entry.name == name)
                return true;
        }
        table = GetTable(L"CTRLID");
        for (auto& table_entry : table)
        {
            if (table_entry.name == name)
                return true;
        }
        return false;
    }

    StringType GetNameOfResID(IDTYPE_ nIDTYPE_, ValueType value, bool unsign = false) const
    {
        if (g_settings.bHideID)
        {
            switch (nIDTYPE_)
            {
            case IDTYPE_CONTROL:
            case IDTYPE_COMMAND:
            case IDTYPE_NEWCOMMAND:
                if (unsign)
                    return mstr_dec_word((WORD)value);
                else
                    return mstr_dec_short((SHORT)value);
            case IDTYPE_MESSAGE:
                return mstr_hex(value);
            default:
                return mstr_dec_word((WORD)value);
            }
        }

        if (nIDTYPE_ == IDTYPE_COMMAND || nIDTYPE_ == IDTYPE_NEWCOMMAND)
        {
            return GetCtrlOrCmdName(value, unsign);
        }

        TableType table = GetTable(L"RESOURCE.ID.PREFIX");
        if (nIDTYPE_ < 0 || nIDTYPE_ >= INT(table.size()))
        {
            return mstr_dec_word((WORD)value);
        }

        StringType prefix = table[nIDTYPE_].name;
        if (prefix.empty())
        {
            if (nIDTYPE_ == IDTYPE_CONTROL)
                return mstr_dec_short((SHORT)value);
            else if (nIDTYPE_ == IDTYPE_MESSAGE)
                return mstr_hex(value);
            else
                return mstr_dec_word((WORD)value);
        }

        table = GetTableByPrefix(L"RESOURCE.ID", prefix);
        auto end = table.end();
        for (auto it = table.begin(); it != end; ++it)
        {
            if (it->value == value)
                return it->name;
        }

        if (nIDTYPE_ == IDTYPE_CONTROL)
        {
            if (value == (ValueType)-1 || value == 0xFFFF)
            {
                if (g_settings.bUseIDC_STATIC && !g_settings.bHideID)
                    return L"IDC_STATIC";
                return L"-1";
            }

            return GetCtrlOrCmdName(value);
        }

        if (nIDTYPE_ != IDTYPE_RESOURCE && IsEntityIDType(nIDTYPE_))
        {
            return GetNameOfResID(IDTYPE_RESOURCE, value);
        }

        if (nIDTYPE_ == IDTYPE_HELP)
        {
            return mstr_dec_dword(value);
        }

        if (nIDTYPE_ == IDTYPE_MESSAGE)
        {
            return mstr_hex(value);
        }

        return mstr_dec_word(WORD(value));
    }

    StringType GetNameOfIDTypeValue(IDTYPE_ nIDTYPE_, ValueType value) const
    {
        TableType table = GetTable(L"RESOURCE.ID.PREFIX");
        StringType prefix = table[nIDTYPE_].name;

        table = GetTableByPrefix(L"RESOURCE.ID", prefix);
        {
            auto end = table.end();
            for (auto it = table.begin(); it != end; ++it)
            {
                if (it->value == value)
                    return it->name;
            }
        }
        return L"";
    }

    StringType GetCtrlOrCmdName(ValueType value, bool unsign = false) const
    {
        if (value == 0xFFFF || value == (ValueType)-1)
        {
            if (g_settings.bUseIDC_STATIC && !g_settings.bHideID)
                return L"IDC_STATIC";
            else
                return L"-1";
        }
        StringType str;
        str = GetNameOfIDTypeValue(IDTYPE_COMMAND, value);
        if (str.size())
            return str;
        str = GetNameOfIDTypeValue(IDTYPE_NEWCOMMAND, value);
        if (str.size())
            return str;
        str = GetNameOfIDTypeValue(IDTYPE_CONTROL, value);
        if (str.size())
            return str;
        str = DumpValue(L"CTRLID", value);
        if (str.empty() || str[0] == L'-' || mchr_is_digit(str[0]))
        {
            if (unsign)
                return mstr_dec_word((WORD)value);
            else
                return mstr_dec_short((SHORT)value);
        }
        return str;
    }

    StringType GetNameOfResID(IDTYPE_ nIDTYPE_1, IDTYPE_ nIDTYPE_2, ValueType value, bool unsign = false) const
    {
        StringType ret = GetNameOfResID(nIDTYPE_1, value, unsign);
        if (mchr_is_digit(ret[0]) || ret[0] == L'-')
            ret = GetNameOfResID(nIDTYPE_2, value, unsign);
        return ret;
    }

    NameType GetName(const CategoryType& category, ValueType value) const
    {
        const TableType& table = GetTable(category);
        TableType::const_iterator it, end = table.end();
        for (it = table.begin(); it != end; ++it)
        {
            if (it->value == value)
                return it->name;
        }
        return NameType();
    }

    NameType GetLangName(ValueType value) const
    {
        const TableType& table = GetTable(L"Languages");
        TableType::const_iterator it, end = table.end();
        for (it = table.begin(); it != end; ++it)
        {
            if (it->name.size() != 5 || it->name[2] != L'_')
                continue;
            if (it->value == value)
                return it->name;
        }
        return mstr_dec_short((SHORT)value);
    }

    ValueType GetValue(const CategoryType& category, const NameType& name) const
    {
        const TableType& table = GetTable(category);
        TableType::const_iterator it, end = table.end();
        for (it = table.begin(); it != end; ++it)
        {
            if (it->name == name)
                return it->value;
        }
        return (ValueType)mstr_parse_int(name.c_str());
    }

    ValueType GetValueI(const CategoryType& category, const NameType& name) const
    {
        const TableType& table = GetTable(category);
        TableType::const_iterator it, end = table.end();
        for (it = table.begin(); it != end; ++it)
        {
            if (lstrcmpiW(it->name.c_str(), name.c_str()) == 0)
                return it->value;
        }
        return (ValueType)mstr_parse_int(name.c_str());
    }

    ValuesType GetValues(const CategoryType& category, const NameType& name) const
    {
        ValuesType ret;
        const TableType& table = GetTable(category);
        TableType::const_iterator it, end = table.end();
        for (it = table.begin(); it != end; ++it)
        {
            if (it->name == name)
            {
                ret.push_back(it->value);
            }
        }
        return ret;
    }

    bool LoadFromFile(LPCWSTR FileName)
    {
        using namespace std;
        m_map.clear();

        FILE *fp = _wfopen(FileName, L"rb");
        if (fp == NULL)
            return false;

        CategoryType category;
        char buf[MAX_PATH];
        while (fgets(buf, MAX_PATH, fp))
        {
            MStringW line;
            line = MAnsiToWide(CP_ACP, buf);

            mstr_replace_all(line, L" |", L"|");
            mstr_replace_all(line, L"| ", L"|");

            mstr_trim(line);
            if (line.empty())
                continue;

            // "[category]"
            if (line[0] == L'[')
            {
                if (line[line.size() - 1] == L']')
                {
                    category = line.substr(1, line.size() - 2);
                    ::CharUpperW(&category[0]);
                    m_map[category];
                }
                continue;
            }

            // "[name], value, mask"
            static const wchar_t *s_delim = L" ,\r\n";
            WCHAR *pch0, *pch1, *pch2;
            pch0 = &line[0];
            if (*pch0 == L',')
            {
                pch0 = &line[0];
                *pch0 = 0;
                pch1 = wcstok(pch0 + 1, s_delim);
            }
            else
            {
                pch0 = wcstok(&line[0], s_delim);
                if (pch0 == NULL)
                    continue;
                pch1 = wcstok(NULL, s_delim);
            }
            if (pch1 == NULL)
                continue;
            pch2 = wcstok(NULL, s_delim);

            NameType name = pch0;
            mstr_trim(name);
            //if (name.empty())
            //    continue;

            StringType value_str = pch1;
            mstr_trim(value_str);
            if (value_str.empty())
                continue;

            StringType mask_str;
            if (pch2 == NULL)
            {
                mask_str = value_str;
            }
            else
            {
                mask_str = pch2;
            }
            mstr_trim(mask_str);

            ValueType value;
            if (iswdigit(value_str[0]))
            {
                value = mstr_parse_int(value_str.c_str(), false);
            }
            else
            {
                value = ParseBitField(category, value_str);
            }

            ValueType mask;
            if (iswdigit(mask_str[0]))
            {
                mask = mstr_parse_int(mask_str.c_str(), false);
            }
            else
            {
                mask = ParseBitField(category, mask_str);
            }

            mstr_replace_all(name, L"|", L" | ");

            EntryType entry(name, value, mask);
            m_map[category].push_back(entry);
        }

        fclose(fp);
        return true;
    }

    StringType DumpBitField(const CategoryType& cat1, ValueType& value,
                            ValueType default_value = 0) const
    {
        StringType ret, str1, str3;

        ValueType def = default_value;
        default_value &= ~value;
        value &= ~def;

        str1 = _dumpBitField(cat1, value);

        if (!str1.empty())
        {
            ret = std::move(str1);
        }
        else
        {
            ret = L"0";
        }

        if (value)
        {
            if (!ret.empty() && ret != L"0")
                ret += L" | ";

            ret += mstr_hex(value);
        }

        if (default_value)
        {
            str3 = _dumpBitField(cat1, default_value, true);
            if (ret == L"0")
                ret.clear();
            else if (!ret.empty() && !str3.empty())
                ret += L" | ";
            ret += str3;
        }

        return ret;
    }

    StringType DumpBitFieldOrZero(const CategoryType& cat1, ValueType& value,
                                  ValueType default_value = 0) const
    {
        StringType ret = DumpBitField(cat1, value, default_value);
        if (ret.empty())
            ret = L"0";
        return ret;
    }

    StringType DumpBitField(const CategoryType& cat1, const CategoryType& cat2,
                            ValueType& value, ValueType default_value = 0) const
    {
        StringType ret, str1, str2, str3, str4;

        ValueType def = default_value;
        default_value &= ~value;
        value &= ~def;

        str1 = _dumpBitField(cat1, value);
        if (!cat2.empty())
            str2 = _dumpBitField(cat2, value);

        if (!str1.empty() && str1 != L"0")
        {
            if (!str2.empty() && str2 != L"0")
                ret = str1 + L" | " + str2;
            else
                ret = std::move(str1);
        }
        else
        {
            if (!str2.empty() && str2 != L"0")
                ret = std::move(str2);
            else
                ret = L"0";
        }

        if (value)
        {
            if (!ret.empty())
                ret += L" | ";

            ret += mstr_hex(value);
        }

        if (default_value)
        {
            str3 = _dumpBitField(cat1, default_value, true);
            if (!cat2.empty())
                str4 = _dumpBitField(cat2, default_value, true);
            if (ret == L"0")
                ret.clear();
            else if (!ret.empty() && !str3.empty())
                ret += L" | ";
            ret += str3;
            if (!ret.empty() && !str4.empty())
                ret += L" | ";
            ret += str4;
        }

        return ret;
    }

    StringType DumpBitFieldOrZero(const CategoryType& cat1, const CategoryType& cat2,
                                  ValueType& value, ValueType default_value = 0) const
    {
        StringType ret = DumpBitField(cat1, cat2, value, default_value);
        if (ret.empty())
            ret = L"0";
        return ret;
    }

    StringType DumpValue(CategoryType category, ValueType value) const
    {
        ::CharUpperW(&category[0]);

        MapType::const_iterator found = m_map.find(category);
        if (found != m_map.end())
        {
            const TableType& table = found->second;
            TableType::const_iterator it, end = table.end();
            for (it = table.begin(); it != end; ++it)
            {
                if (value == it->value)
                {
                    return it->name;
                }
            }
        }

        return mstr_dec(value);
    }

    ValueType
    ParseBitField(CategoryType category, const StringType& str,
                  ValueType default_value = 0) const
    {
        ::CharUpperW(&category[0]);

        std::vector<StringType> values;
        mstr_split(values, str, L" \t\r\n|+");

        ValueType value = default_value;
        auto end = values.end();
        for (auto it = values.begin(); it != end; ++it)
        {
            mstr_trim(*it);
            if ((*it).empty())
                continue;

            if (iswdigit((*it)[0]))
            {
                value |= mstr_parse_int(it->c_str(), false);
            }
            else
            {
                if ((*it).find(L"NOT ") != StringType::npos)
                {
                    (*it) = (*it).substr(4);
                    mstr_trim(*it);
                    value &= ~GetValue(category, *it);
                }
                else
                {
                    value |= GetValue(category, *it);
                }
            }
        }

        return value;
    }

protected:
    StringType _dumpBitField(CategoryType category, ValueType& value,
                             bool bNot = false) const
    {
        StringType ret;

        ::CharUpperW(&category[0]);

        MapType::const_iterator found = m_map.find(category);
        if (found == m_map.end())
            return ret;

        const TableType& table = found->second;
        for (;;)
        {
            ValueType max_value = 0;
            TableType::const_iterator max_it = table.end();
            TableType::const_iterator it, end = table.end();
            for (it = table.begin(); it != end; ++it)
            {
                if (it->value == 0)
                    continue;

                if ((value & it->mask) == it->value)
                {
                    if (it->value > max_value)
                    {
                        max_value = it->value;
                        max_it = it;
                    }
                }
            }

            if (max_it == end)
                break;  // not found

            if (!ret.empty())
                ret += L" | ";
            if (bNot)
            {
                ret += L"NOT ";
            }

            ret += max_it->name;
            value &= ~max_it->value;
        }

        return ret;
    }
};

#ifdef USE_GLOBALS
    extern ConstantsDB g_db;
#else
    inline ConstantsDB& DB_GetMaster(void)
    {
        static ConstantsDB s_db;
        return s_db;
    }
    #define g_db DB_GetMaster()
#endif

```

`src/DialogRes.cpp`:

```cpp
// DialogRes.cpp --- Dialog Resources
//////////////////////////////////////////////////////////////////////////////
// RisohEditor --- Another free Win32 resource editor
// Copyright (C) 2017-2018 Katayama Hirofumi MZ <katayama.hirofumi.mz@gmail.com>
// 
// This program is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
// 
// This program is distributed in the hope that it will be useful, 
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
// 
// You should have received a copy of the GNU General Public License
// along with this program.  If not, see <http://www.gnu.org/licenses/>.
//////////////////////////////////////////////////////////////////////////////

#include "DialogRes.hpp"
#include "ConstantsDB.hpp"
#include "RisohSettings.hpp"
#include <shlwapi.h>
#include <unordered_set>

bool PredefClassToID(MStringW name, WORD& w)
{
    w = 0;
    CharUpperW(&name[0]);
    if (name == L"BUTTON")
        w = 0x0080;
    else if (name == L"EDIT")
        w = 0x0081;
    else if (name == L"STATIC")
        w = 0x0082;
    else if (name == L"LISTBOX")
        w = 0x0083;
    else if (name == L"SCROLLBAR")
        w = 0x0084;
    else if (name == L"COMBOBOX")
        w = 0x0085;
    return w != 0;
}

bool IDToPredefClass(WORD w, MStringW& name)
{
    switch (w)
    {
    case 0x0080:
        name = L"BUTTON";
        return true;
    case 0x0081:
        name = L"EDIT";
        return true;
    case 0x0082:
        name = L"STATIC";
        return true;
    case 0x0083:
        name = L"LISTBOX";
        return true;
    case 0x0084:
        name = L"SCROLLBAR";
        return true;
    case 0x0085:
        name = L"COMBOBOX";
        return true;
    }
    return false;
}

void FixClassName(MStringW& cls)
{
    ConstantsDB::TableType table = g_db.GetTable(L"CONTROL.CLASSES");
    for (auto& table_entry : table)
    {
        if (lstrcmpiW(table_entry.name.c_str(), cls.c_str()) == 0)
        {
            cls = table_entry.name;
            break;
        }
    }
}

//////////////////////////////////////////////////////////////////////////////

DialogItem::DialogItem()
{
    m_help_id = 0;
    m_style = 0;
    m_ex_style = 0;
    m_pt.x = 0;
    m_pt.y = 0;
    m_siz.cx = 0;
    m_siz.cy = 0;
    m_id = 0;
}

bool DialogItem::LoadFromStream(const MByteStreamEx& stream, bool extended)
{
    if (extended)
        return LoadFromStreamEx(stream);

    stream.ReadDwordAlignment();

    DLGITEMTEMPLATE item;
    if (!stream.ReadRaw(item))
        return false;

    m_help_id = 0;
    m_style = item.style;
    m_ex_style = item.dwExtendedStyle;
    m_pt.x = item.x;
    m_pt.y = item.y;
    m_siz.cx = item.cx;
    m_siz.cy = item.cy;
    m_id = item.id;

    if (!stream.ReadString(m_class) ||
        !stream.ReadString(m_title))
    {
        return false;
    }

    BYTE b;
    if (!stream.ReadByte(b))
        return false;

    if (b)
    {
        m_extra.resize(b);
        if (!stream.ReadData(&m_extra[0], b))
            return false;
    }

    return true;
}

bool DialogItem::LoadFromStreamEx(const MByteStreamEx& stream)
{
    stream.ReadDwordAlignment();

    DLGITEMTEMPLATEEXHEAD item;
    if (!stream.ReadRaw(item))
    {
        return false;
    }

    m_help_id = item.helpID;
    m_style = item.style;
    m_ex_style = item.exStyle;
    m_pt.x = item.x;
    m_pt.y = item.y;
    m_siz.cx = item.cx;
    m_siz.cy = item.cy;
    m_id = item.id;

    stream.ReadDwordAlignment();

    if (!stream.ReadString(m_class) || !stream.ReadString(m_title))
    {
        return false;
    }

    WORD extraCount;
    if (!stream.ReadWord(extraCount))
        return false;

    if (extraCount)
    {
        m_extra.resize(extraCount);
        if (!stream.ReadData(&m_extra[0], extraCount))
            return false;
    }

    return true;
}

bool DialogItem::SaveToStream(MByteStreamEx& stream, bool extended) const
{
    if (extended)
    {
        return SaveToStreamEx(stream);
    }

    stream.WriteDwordAlignment();

    DLGITEMTEMPLATE item;
    item.style = m_style;
    item.dwExtendedStyle = m_ex_style;
    item.x = (SHORT)m_pt.x;
    item.y = (SHORT)m_pt.y;
    item.cx = (SHORT)m_siz.cx;
    item.cy = (SHORT)m_siz.cy;
    item.id = m_id;
    if (!stream.WriteData(&item, sizeof(item)))
        return false;

    WORD w;
    if (!IS_INTRESOURCE(m_class.ptr()) && 
        PredefClassToID(m_class.ptr(), w))
    {
        if (!stream.WriteString(MAKEINTRESOURCEW(w)))
            return false;
    }
    else
    {
        if (!stream.WriteString(m_class.ptr()))
            return false;
    }

    if (!stream.WriteString(m_title.ptr()))
        return false;

    BYTE b = BYTE(m_extra.size());
    if (!stream.WriteRaw(b))
        return false;

    if (b)
    {
        stream.WriteDwordAlignment();
        if (!stream.WriteData(&m_extra[0], b))
            return false;
    }

    return true;
}

bool DialogItem::SaveToStreamEx(MByteStreamEx& stream) const
{
    stream.WriteDwordAlignment();

    DLGITEMTEMPLATEEXHEAD ItemEx;
    ItemEx.helpID = m_help_id;
    ItemEx.exStyle = m_ex_style;
    ItemEx.style = m_style;
    ItemEx.x = (short)m_pt.x;
    ItemEx.y = (short)m_pt.y;
    ItemEx.cx = (short)m_siz.cx;
    ItemEx.cy = (short)m_siz.cy;
    ItemEx.id = m_id;
    if (!stream.WriteRaw(ItemEx))
        return false;

    stream.WriteDwordAlignment();

    WORD w;
    if (!IS_INTRESOURCE(m_class.ptr()) && 
        PredefClassToID(m_class.ptr(), w))
    {
        if (!stream.WriteString(MAKEINTRESOURCEW(w)))
            return false;
    }
    else
    {
        if (!stream.WriteString(m_class.ptr()))
            return false;
    }

    if (!stream.WriteString(m_title.ptr()) ||
        !stream.WriteWord(WORD(m_extra.size())))
    {
        return false;
    }

    if (m_extra.size() > 0)
    {
        WORD ExtraSize = WORD(m_extra.size());
        if (!stream.WriteData(&m_extra[0], ExtraSize))
            return false;
    }

    return true;
}

MStringW DialogItem::Dump(bool bAlwaysControl) const
{
    MStringW cls;

    if (m_class.is_int())
    {
        if (!IDToPredefClass(m_class.m_id, cls))
            cls = mstr_dec_short(m_class.m_id);
    }
    else
    {
        cls = m_class.str();
    }

    if (!bAlwaysControl)
    {
        if (lstrcmpiW(cls.c_str(), L"BUTTON") == 0)
        {
#ifndef BS_TYPEMASK
#define BS_TYPEMASK     0x0000000F
#endif
            if ((m_style & BS_TYPEMASK) == BS_AUTO3STATE)
                return _do_AUTO3STATE();
            if ((m_style & BS_TYPEMASK) == BS_AUTOCHECKBOX)
                return _do_AUTOCHECKBOX();
            if ((m_style & BS_TYPEMASK) == BS_AUTORADIOBUTTON)
                return _do_AUTORADIOBUTTON();
            if ((m_style & BS_TYPEMASK) == BS_CHECKBOX)
                return _do_CHECKBOX();
            if ((m_style & BS_TYPEMASK) == BS_DEFPUSHBUTTON)
                return _do_DEFPUSHBUTTON();
            if ((m_style & BS_TYPEMASK) == BS_GROUPBOX)
                return _do_GROUPBOX();
            if ((m_style & BS_TYPEMASK) == BS_PUSHBUTTON || (m_style & BS_TYPEMASK) == BS_OWNERDRAW)
                return _do_PUSHBUTTON();
            if ((m_style & BS_TYPEMASK) == BS_PUSHBOX ||
                (m_style & BS_TYPEMASK) == 0xC)
            {
                return _do_PUSHBOX();
            }
            if ((m_style & BS_TYPEMASK) == BS_RADIOBUTTON)
                return _do_RADIOBUTTON();
            if ((m_style & BS_TYPEMASK) == BS_3STATE)
                return _do_STATE3();
        }
        if (lstrcmpiW(cls.c_str(), L"STATIC") == 0)
        {
            if ((m_style & SS_TYPEMASK) == SS_LEFT)
                return _do_LTEXT();
            if ((m_style & SS_TYPEMASK) == SS_CENTER)
                return _do_CTEXT();
            if ((m_style & SS_TYPEMASK) == SS_RIGHT)
                return _do_RTEXT();
            if ((m_style & SS_TYPEMASK) == SS_ICON)
                return _do_ICON();
        }
        if (m_title.empty())
        {
            if (lstrcmpiW(cls.c_str(), L"EDIT") == 0)
                return _do_EDITTEXT();
            if (lstrcmpiW(cls.c_str(), L"COMBOBOX") == 0)
                return _do_COMBOBOX();
            if (lstrcmpiW(cls.c_str(), L"LISTBOX") == 0)
                return _do_LISTBOX();
            if (lstrcmpiW(cls.c_str(), L"SCROLLBAR") == 0)
                return _do_SCROLLBAR();
        }
    }
    return DumpControl(cls);
}

MStringW DialogItem::DumpControl(MStringW& cls) const
{
    MStringW ret;

    ret += L"CONTROL ";

    if (IsStaticIcon())
    {
        ret += g_db.GetNameOfResID(IDTYPE_ICON, m_title.m_id);
    }
    else
    {
        ret += m_title.quoted_wstr();
    }

    ret += L", ";
    ret += g_db.GetNameOfResID(IDTYPE_CONTROL, m_id);
    ret += L", ";
    if (m_class.is_int())
    {
        if (IDToPredefClass(m_class.m_id, cls))
            ret += mstr_quote(cls);
        else
            ret += mstr_dec_short(m_class.m_id);
    }
    else
    {
        cls = m_class.str();
        FixClassName(cls);
        ret += mstr_quote(cls);
    }

    ret += L", ";
    {
        DWORD value = m_style;
        DWORD def_value = WS_CHILD | WS_VISIBLE;
        ret += g_db.DumpBitFieldOrZero(cls.c_str(), L"STYLE", value, def_value);
    }

    ret += L", ";
    ret += mstr_dec_short((SHORT)m_pt.x);
    ret += L", ";
    ret += mstr_dec_short((SHORT)m_pt.y);
    ret += L", ";
    ret += mstr_dec_short((SHORT)m_siz.cx);
    ret += L", ";
    ret += mstr_dec_short((SHORT)m_siz.cy);
    if (m_ex_style || m_help_id)
    {
        ret += L", ";
        DWORD value = m_ex_style;
        ret += g_db.DumpBitFieldOrZero(L"EXSTYLE", L"", value);
    }
    if (m_help_id)
    {
        ret += L", ";
        ret += g_db.GetNameOfResID(IDTYPE_HELP, m_help_id);
    }
    if (m_extra.size() && m_extra.size() % 2 == 0)
    {
        size_t count = m_extra.size() / sizeof(WORD);
        const WORD *pw = (const WORD *)&m_extra[0];
        if (g_settings.bUseBeginEnd)
            ret += L"\r\n    BEGIN\r\n";
        else
            ret += L"\r\n    {\r\n        ";
        ret += mstr_hex_word(pw[0]);
        for (size_t i = 1; i < count; ++i)
        {
            ret += L", ";
            ret += mstr_hex_word(pw[i]);
        }
        ret += L"\r\n    }";
    }

    return ret;
}

MStringW
DialogItem::_do_CONTROL(bool bNeedsText, 
                       const MStringW& ctrl, 
                       const MStringW& cls, 
                       DWORD DefStyle) const
{
    MStringW ret;
    ret += ctrl;
    ret += L" ";

    if (!m_title.empty() || bNeedsText)
    {
        if (IsStaticIcon())
        {
            ret += g_db.GetNameOfResID(IDTYPE_ICON, m_title.m_id);
        }
        else
        {
            ret += m_title.quoted_wstr();
        }
        ret += L", ";
    }

    ret += g_db.GetNameOfResID(IDTYPE_CONTROL, m_id);
    ret += L", ";
    ret += mstr_dec_short((SHORT)m_pt.x);
    ret += L", ";
    ret += mstr_dec_short((SHORT)m_pt.y);
    // NOTE: Don't omit cx and cy! Visual Studio 2017 won't accept omission.
    //if (!IsStaticIcon() || m_siz.cx || m_siz.cy || m_style != DefStyle || m_ex_style || m_help_id)
    {
        ret += L", ";
        ret += mstr_dec_short((SHORT)m_siz.cx);
        ret += L", ";
        ret += mstr_dec_short((SHORT)m_siz.cy);
    }
    if (m_style != DefStyle || m_ex_style || m_help_id)
    {
        ret += L", ";
        DWORD value = m_style;
        if (ctrl == L"PUSHBOX" && (value & BS_TYPEMASK) == 0xC)
        {
            value &= ~BS_TYPEMASK;
            value |= BS_PUSHBOX;
        }
        // NOTE: RC won't add WS_TABSTOP. Microsoft document said a lie.
        std::wstring str = g_db.DumpBitFieldOrZero(cls.c_str(), L"STYLE", value, DefStyle);
        ret += str;
        if (ctrl == L"AUTORADIOBUTTON" && str.find(L"WS_TABSTOP") == std::wstring::npos)
        {
            if (m_style & WS_TABSTOP)
                ret += L" | WS_TABSTOP";
            else
                ret += L" | NOT WS_TABSTOP";
        }
    }
    else
    {
        // NOTE: RC won't add WS_TABSTOP. Microsoft document said a lie.
        if (ctrl == L"AUTORADIOBUTTON")
        {
            if (m_style & WS_TABSTOP)
                ret += L", WS_TABSTOP";
            else
                ret += L", NOT WS_TABSTOP";
        }
    }
    if (m_ex_style || m_help_id)
    {
        ret += L", ";
        DWORD value = m_ex_style;
        ret += g_db.DumpBitFieldOrZero(L"EXSTYLE", L"", value);
    }
    if (m_help_id)
    {
        ret += L", ";
        ret += g_db.GetNameOfResID(IDTYPE_HELP, m_help_id);
    }
    if (m_extra.size() && m_extra.size() % 2 == 0)
    {
        size_t count = m_extra.size() / sizeof(WORD);
        const WORD *pw = (const WORD *)&m_extra[0];
        if (g_settings.bUseBeginEnd)
            ret += L"\r\n    BEGIN\r\n";
        else
            ret += L"\r\n    {\r\n        ";
        ret += mstr_hex_word(pw[0]);
        for (size_t i = 1; i < count; ++i)
        {
            ret += L", ";
            ret += mstr_hex_word(pw[i]);
        }
        ret += L"\r\n    }";
    }
    return ret;
}

BOOL DialogItem::IsClassRegd(const WCHAR *name) const
{
    HMODULE hMod = ::GetModuleHandle(NULL);

    WNDCLASSEXW wcx;
    if (::GetClassInfoExW(NULL, name, &wcx) ||
        ::GetClassInfoExW(hMod, name, &wcx))
    {
        return TRUE;
    }
    return FALSE;
}

void DialogItem::FixupForRad(bool bRevert)
{
    if (bRevert)
    {
        m_style = m_old_style;
        m_ex_style = m_old_ex_style;
        m_siz = m_sizOld;
        m_class = m_old_class;
        m_title = m_old_title;
    }
    else
    {
        m_old_style = m_style;
        m_old_ex_style = m_ex_style;

        m_style &= ~WS_DISABLED;
        m_style |= WS_CHILD | WS_VISIBLE;

        m_ex_style &= ~(WS_EX_ACCEPTFILES | WS_EX_LAYERED | WS_EX_TRANSPARENT |
                        WS_EX_TOPMOST);
        m_ex_style |= WS_EX_NOACTIVATE;
        m_sizOld = m_siz;
        m_old_class = m_class;
        m_old_title = m_title;

        if (m_siz.cx == 0 && m_siz.cy == 0)
        {
            m_siz.cx = 20;
            m_siz.cy = 20;
        }
        if (StrCmpNIW(m_class.c_str(), TEXT("AtlAxWin"), 8) == 0)
        {
            m_class = L"STATIC";
            m_style |= WS_BORDER;
        }
        else if (m_class.c_str()[0] == L'{')
        {
#if 1
            m_title = m_class.c_str();
            m_class = L"MOleSite";
            m_style |= WS_BORDER;
#else
            m_title = m_class.c_str();
            m_class = L"STATIC";
            m_style |= WS_BORDER;
#endif
        }
        else if (m_class.is_str() && !IsClassRegd(m_class.c_str()))
        {
            m_class = L"STATIC";
            m_style &= ~SS_TYPEMASK;
            m_style |= SS_GRAYRECT;
        }
        if (m_class.m_id == 0x0080 ||
            lstrcmpiW(m_class.str().c_str(), L"BUTTON") == 0)
        {
            if ((m_style & BS_TYPEMASK) == BS_OWNERDRAW)
            {
                m_style &= ~BS_TYPEMASK;
                m_style |= BS_PUSHBUTTON;
            }
        }
        if (m_class.m_id == 0x0082 ||
            lstrcmpiW(m_class.str().c_str(), L"STATIC") == 0)
        {
            if ((m_style & SS_TYPEMASK) == SS_OWNERDRAW)
            {
                m_style &= ~SS_TYPEMASK;
                m_style |= SS_LEFT;
            }
        }
        if (m_class.m_id == 0x0083 ||
            lstrcmpiW(m_class.str().c_str(), L"LISTBOX") == 0)
        {
            if (m_style & (LBS_OWNERDRAWFIXED | LBS_OWNERDRAWVARIABLE))
            {
                m_style &= ~(LBS_OWNERDRAWFIXED | LBS_OWNERDRAWVARIABLE);
            }
        }
        if (m_class.m_id == 0x0085 ||
            lstrcmpiW(m_class.str().c_str(), L"COMBOBOX") == 0 ||
            lstrcmpiW(m_class.str().c_str(), WC_COMBOBOXEX) == 0)
        {
            if (m_style & (CBS_OWNERDRAWFIXED | CBS_OWNERDRAWVARIABLE))
            {
                m_style &= ~(CBS_OWNERDRAWFIXED | CBS_OWNERDRAWVARIABLE);
            }
        }
    }
}

void DialogItem::FixupForTest(bool bRevert)
{
    if (bRevert)
    {
        m_class = m_old_class;
        m_style = m_old_style;
        m_title = m_old_title;
    }
    else
    {
        m_old_style = m_style;
        m_old_class = m_class;
        m_old_title = m_title;
#ifndef ATL_SUPPORT
        if (StrCmpNIW(m_class.c_str(), TEXT("AtlAxWin"), 8) == 0)
        {
            m_class = L"STATIC";
            m_style |= WS_BORDER;
        }
#endif
        if (m_class.c_str()[0] == L'{')
        {
#if 1
            m_title = m_class.c_str();
            m_class = L"MOleSite";
            m_style |= WS_BORDER;
#else
            m_title = m_class.c_str();
            m_class = L"STATIC";
            m_style |= WS_BORDER;
#endif
        }
    }
}

//////////////////////////////////////////////////////////////////////////////

void DialogRes::ReplaceFont()
{
    m_replaced_type_face = m_type_face;
    auto& face = m_replaced_type_face;

    if (face.str() == g_settings.strFontReplaceFrom1)
        face = g_settings.strFontReplaceTo1.c_str();
    else if (face.str() == g_settings.strFontReplaceFrom2)
        face = g_settings.strFontReplaceTo2.c_str();
    else if (face.str() == g_settings.strFontReplaceFrom3)
        face = g_settings.strFontReplaceTo3.c_str();
}

DialogRes::DialogRes()
{
    m_version = 0;
    m_signature = 0;
    m_help_id = 0;
    m_style = 0;
    m_ex_style = 0;
    m_cItems = 0;
    m_pt.x = 0;
    m_pt.y = 0;
    m_siz.cx = 0;
    m_siz.cy = 0;
    m_point_size = 0;
    m_weight = FW_NORMAL;
    m_italic = false;
    m_charset = DEFAULT_CHARSET;
    m_lang = 0;
}

bool DialogRes::LoadFromStream(const MByteStreamEx& stream)
{
    if (stream.size() < sizeof(WORD) * 2)
        return false;

    if (*(WORD *)stream.ptr(0) == 1 &&
        *(WORD *)stream.ptr(2) == 0xFFFF)
    {
        // extended dialog
        if (_headerFromStreamEx(stream))
        {
            for (UINT i = 0; i < m_cItems; ++i)
            {
                DialogItem item;
                if (!item.LoadFromStreamEx(stream))
                    return false;
                m_items.push_back(item);
            }
            return true;
        }
    }
    else
    {
        // normal dialog
        if (_headerFromStream(stream))
        {
            for (UINT i = 0; i < m_cItems; ++i)
            {
                DialogItem item;
                if (!item.LoadFromStream(stream))
                    return false;
                m_items.push_back(item);
            }
            return true;
        }
    }
    return false;
}

bool DialogRes::SaveToStream(MByteStreamEx& stream) const
{
    if (IsExtended())
    {
        if (_headerToStreamEx(stream))
        {
            size_t i, count = m_items.size();
            for (i = 0; i < count; ++i)
            {
                if (!m_items[i].SaveToStreamEx(stream))
                    return false;
            }
            stream.WriteByte(0);
            return true;
        }
    }
    else
    {
        if (_headerToStream(stream))
        {
            size_t i, count = m_items.size();
            for (i = 0; i < count; ++i)
            {
                if (!m_items[i].SaveToStream(stream))
                    return false;
            }
            stream.WriteByte(0);
            return true;
        }
    }
    return false;
}

INT DialogRes::GetDlgItem(WORD id) const
{
    for (size_t k = 0; k < size(); ++k)
    {
        if ((*this)[k].m_id == id)
            return INT(k);
    }
    return -1;
}

bool DialogRes::LoadDlgInitData(const MByteStreamEx::data_type& data)
{
    MByteStreamEx stream(data);
    DlgInitRes dlginit;
    if (dlginit.LoadFromStream(stream))
    {
        for (auto& item : m_items)
        {
            item.m_str_list.clear();
        }

        for (size_t i = 0; i < dlginit.size(); ++i)
        {
            INT iItem = GetDlgItem(dlginit[i].wCtrl);
            if (iItem != -1 && iItem < INT(m_items.size()))
            {
                m_items[iItem].m_str_list.push_back(dlginit[i].strText);
            }
        }
        return true;
    }
    return false;
}

bool DialogRes::SaveDlgInitData(MByteStreamEx::data_type& data) const
{
    std::unordered_set<WORD> ids;
    for (auto& item : m_items)
    {
        ids.insert(item.m_id);
    }

    DlgInitRes dlginit;
    for (auto& id : ids)
    {
        INT iItem = GetDlgItem(id);
        if (iItem != -1 && iItem < INT(m_items.size()))
        {
            auto& item = m_items[iItem];
            for (auto& str : item.m_str_list)
            {
                if (item.IsListBox())
                {
                    DlgInitEntry entry(id, LB_ADDSTRING, str);
                    dlginit.push_back(entry);
                }
                else if (item.IsStdComboBox())
                {
                    DlgInitEntry entry(id, CB_ADDSTRING, str);
                    dlginit.push_back(entry);
                }
                else if (item.IsExtComboBox())
                {
                    DlgInitEntry entry(id, CBEM_INSERTITEM, str);
                    dlginit.push_back(entry);
                }
            }
        }
    }

    data = dlginit.data();
    return !dlginit.empty();
}

MStringW DialogRes::Dump(const MIdOrString& id_or_str, bool bAlwaysControl)
{
    MStringW ret;

    if (id_or_str.is_str())
    {
        ret += id_or_str.str();
    }
    else
    {
        ret += g_db.GetNameOfResID(IDTYPE_DIALOG, id_or_str.m_id);
    }

    if (IsExtended())
    {
        ret += L" DIALOGEX ";
    }
    else
    {
        ret += L" DIALOG ";
    }

    // NOTE: windres can't read negative x and y. It must be unsigned.
    ret += mstr_dec_word((WORD)m_pt.x);
    ret += L", ";
    ret += mstr_dec_word((WORD)m_pt.y);
    ret += L", ";

    ret += mstr_dec_short((SHORT)m_siz.cx);
    ret += L", ";
    ret += mstr_dec_short((SHORT)m_siz.cy);
    if (IsExtended() && m_help_id)
    {
        ret += L", ";
        ret += g_db.GetNameOfResID(IDTYPE_HELP, m_help_id);
    }
    ret += L"\r\n";

    if (!m_title.empty())
    {
        ret += L"CAPTION ";
        ret += m_title.quoted_wstr();
        ret += L"\r\n";
    }
    if (!m_class.empty())
    {
        ret += L"CLASS ";
        ret += m_class.quoted_wstr();
        ret += L"\r\n";
    }
    if (IsExtended() && !m_menu.empty())
    {
        ret += L"MENU ";
        ret += m_menu.str();
        ret += L"\r\n";
    }

    {
        DWORD value = m_style;
        if ((value & DS_SHELLFONT) == DS_SHELLFONT)
            ;
        else if ((value & DS_SHELLFONT) == DS_FIXEDSYS)
            ;
        else if ((value & DS_SHELLFONT) == DS_SETFONT)
            value &= ~DS_SETFONT;

        MStringW str;
        if ((value & WS_CAPTION) == WS_CAPTION)
        {
            str = g_db.DumpBitField(L"DIALOG", L"PARENT.STYLE", value);
        }
        else if ((value & WS_CAPTION) == WS_BORDER)
        {
            str = g_db.DumpBitField(L"DIALOG", L"PARENT.STYLE", value, WS_DLGFRAME);
        }
        else if ((value & WS_CAPTION) == WS_DLGFRAME)
        {
            str = g_db.DumpBitField(L"DIALOG", L"PARENT.STYLE", value, WS_BORDER);
        }
        else
        {
            str = g_db.DumpBitField(L"DIALOG", L"PARENT.STYLE", value, WS_CAPTION);
        }
        if (value)
        {
            if (!str.empty())
                str += L" | ";

            str = mstr_hex(value);
        }
        else
        {
            if (str.empty())
                str += L"0";
        }
        ret += L"STYLE ";
        ret += str;
        ret += L"\r\n";
    }

    if (m_ex_style)
    {
        DWORD value = m_ex_style;
        MStringW str = g_db.DumpBitField(L"EXSTYLE", L"", value);
        if (value)
        {
            if (!str.empty())
                str += L" | ";

            str = mstr_hex(value);
        }
        else
        {
            if (str.empty())
                str += L"0";
        }
        ret += L"EXSTYLE ";
        ret += str;
        ret += L"\r\n";
    }

    if (m_style & DS_SETFONT)
    {
        ret += L"FONT ";
        ret += mstr_dec_short(m_point_size);
        ret += L", ";
        ret += m_type_face.quoted_wstr();
        if (IsExtended())
        {
            ret += L", ";
            ret += mstr_dec_short(m_weight);
            ret += L", ";
            ret += mstr_dec_short(!!m_italic);
            ret += L", ";
            ret += mstr_dec_short(m_charset);
        }
        ret += L"\r\n";
    }

    if (g_settings.bUseBeginEnd)
        ret += L"BEGIN\r\n";
    else
        ret += L"{\r\n";

    for (UINT i = 0; i < m_cItems; ++i)
    {
        ret += L"    ";
        ret += m_items[i].Dump(!!g_settings.bAlwaysControl);
        ret += L"\r\n";
    }

    if (g_settings.bUseBeginEnd)
        ret += L"END\r\n";
    else
        ret += L"}\r\n";

    return ret;
}

void DialogRes::FixupForRad(bool bRevert)
{
    if (bRevert)
    {
        m_style = m_old_style;
        m_ex_style = m_old_ex_style;
        m_menu = m_old_menu;
        m_class = m_old_class;
        m_type_face = m_old_type_face;
    }
    else
    {
        m_old_style = m_style;
        m_old_ex_style = m_ex_style;
        m_old_menu = m_menu;
        m_old_class = m_class;

        m_style &= ~(WS_POPUP | DS_SYSMODAL | WS_DISABLED);
        m_style |= WS_VISIBLE | WS_CHILD | DS_NOIDLEMSG;

        // We don't know the non-flickering methods... Sorry...
        //m_style |= WS_CLIPCHILDREN | WS_CLIPSIBLINGS;

        m_ex_style &= ~(WS_EX_ACCEPTFILES | WS_EX_TOPMOST |
                     WS_EX_LAYERED | WS_EX_TRANSPARENT);
        m_ex_style |= WS_EX_NOACTIVATE;

        m_menu.clear();
        m_class.clear();

        m_old_type_face = m_type_face;
        m_type_face = m_replaced_type_face;
    }

    for (auto& item : m_items)
    {
        item.FixupForRad(bRevert);
    }
}

void DialogRes::FixupForTest(bool bRevert)
{
    for (auto& item : m_items)
    {
        item.FixupForTest(bRevert);
    }
}

LONG DialogRes::GetCharDimensions(HDC hdc, LONG *height) const
{
    SIZE sz;
    TEXTMETRICW tm;

    static const WCHAR alphabet[] =
        L"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ";

    if (!GetTextMetricsW(hdc, &tm))
        return 0;

    if (!GetTextExtentPointW(hdc, alphabet, 52, &sz))
        return 0;

    if (height)
        *height = tm.tmHeight;

    return (sz.cx / 26 + 1) / 2;
}

INT DialogRes::GetBaseUnits(INT& y) const
{
    INT xBaseUnit, yBaseUnit;
    INT Units = GetDialogBaseUnits();
    xBaseUnit = LOWORD(Units);
    yBaseUnit = HIWORD(Units);

    HDC hDC = CreateCompatibleDC(NULL);
    HFONT hFont = NULL;
    switch (m_style & DS_SHELLFONT)
    {
    case DS_SETFONT:
        if (m_point_size == 0x7FFF)
        {
            NONCLIENTMETRICSW ncm;
            ncm.cbSize = sizeof(ncm);
            if (SystemParametersInfoW(SPI_GETNONCLIENTMETRICS, sizeof(ncm), &ncm, 0))
            {
                hFont = CreateFontIndirectW(&ncm.lfMessageFont);
            }
        }
        else
        {
            int pixels = MulDiv(m_point_size, GetDeviceCaps(hDC, LOGPIXELSY), 72);

            LOGFONTW lf;
            ZeroMemory(&lf, sizeof(lf));
            lf.lfHeight = -pixels;
            lf.lfWeight = m_weight;
            lf.lfItalic = m_italic;
            lf.lfCharSet = DEFAULT_CHARSET;
            if (m_replaced_type_face.empty())
                lf.lfFaceName[0] = 0;
            else
                StringCchCopyW(lf.lfFaceName, _countof(lf.lfFaceName), m_replaced_type_face.c_str());

            hFont = CreateFontIndirectW(&lf);
        }
        break;
    case DS_SHELLFONT:
        if (m_point_size == 0x7FFF)
        {
            NONCLIENTMETRICSW ncm;
            ncm.cbSize = sizeof(ncm);
            if (SystemParametersInfoW(SPI_GETNONCLIENTMETRICS, sizeof(ncm), &ncm, 0))
            {
                hFont = CreateFontIndirectW(&ncm.lfMessageFont);
            }
        }
        else
        {
            // check existence of "MS Shell Dlg 2"
            INT ret = TRUE;
            ret = EnumFontFamilies(hDC, L"MS Shell Dlg 2", (FONTENUMPROC)EnumFontFamProc, 0);

            LOGFONTW lf;
            ZeroMemory(&lf, sizeof(lf));
            int pixels = MulDiv(m_point_size, GetDeviceCaps(hDC, LOGPIXELSY), 72);
            lf.lfHeight = -pixels;
            lf.lfWeight = m_weight;
            lf.lfItalic = m_italic;
            lf.lfCharSet = DEFAULT_CHARSET;

            if (!ret && lstrcmpiW(m_replaced_type_face.c_str(), L"MS Shell Dlg") == 0)
                StringCchCopyW(lf.lfFaceName, _countof(lf.lfFaceName), L"MS Shell Dlg 2");
            else
                StringCchCopyW(lf.lfFaceName, _countof(lf.lfFaceName), m_replaced_type_face.c_str());

            hFont = CreateFontIndirectW(&lf);
        }
        break;
    case DS_FIXEDSYS:
        hFont = HFONT(GetStockObject(SYSTEM_FIXED_FONT));
        break;
    default:
        hFont = HFONT(GetStockObject(SYSTEM_FONT));
        break;
    }

    if (hFont)
    {
        SIZE charSize;
        HGDIOBJ hOldFont = SelectObject(hDC, hFont);
        charSize.cx = GetCharDimensions(hDC, &charSize.cy);
        SelectObject(hDC, hOldFont);
        DeleteObject(hFont);

        if (charSize.cx)
        {
            xBaseUnit = charSize.cx;
            yBaseUnit = charSize.cy;
        }
    }
    DeleteDC(hDC);

    y = yBaseUnit;
    return xBaseUnit;
}

INT DialogRes::GetHeadLines() const
{
    INT ret = 0;

    ++ret;  // "LANGUAGE ..."
    ++ret;  // ""
    ++ret;  // "... DIALOG ..."
    if (!m_title.empty())
    {
        ++ret;  // "CAPTION ..."
    }
    if (!m_class.empty())
    {
        ++ret;  // "CLASS ..."
    }
    if (IsExtended() && !m_menu.empty())
    {
        ++ret;  // "MENU ..."
    }
    ++ret;  // "STYLE ..."
    if (m_ex_style)
    {
        ++ret;  // "EXSTYLE ..."
    }
    if (m_style & DS_SETFONT)
    {
        ++ret;  // "FONT ..."
    }
    ++ret;  // "{"
    return ret;
}

bool DialogRes::_headerFromStream(const MByteStreamEx& stream)
{
    stream.ReadDwordAlignment();

    DLGTEMPLATE tmp;
    if (!stream.ReadRaw(tmp))
        return false;

    m_version = 0;
    m_signature = 0;
    m_help_id = 0;
    m_style = tmp.style;
    m_ex_style = tmp.dwExtendedStyle;
    m_cItems = tmp.cdit;
    m_pt.x = tmp.x;
    m_pt.y = tmp.y;
    m_siz.cx = tmp.cx;
    m_siz.cy = tmp.cy;

    if (!stream.ReadString(m_menu) ||
        !stream.ReadString(m_class) || 
        !stream.ReadString(m_title))
    {
        return false;
    }

    m_point_size = 0;
    m_weight = FW_NORMAL;
    m_italic = 0;
    m_type_face.clear();
    m_items.clear();

    if (m_style & DS_SETFONT)
    {
        if (!stream.ReadWord(m_point_size) ||
            !stream.ReadString(m_type_face))
        {
            return false;
        }
        ReplaceFont();
    }

    return true;
}

bool DialogRes::_headerFromStreamEx(const MByteStreamEx& stream)
{
    stream.ReadDwordAlignment();

    DLGTEMPLATEEXHEAD TemplateEx;
    if (!stream.ReadRaw(TemplateEx))
        return false;

    if (TemplateEx.dlgVer != 1 || TemplateEx.signature != 0xFFFF)
        return false;

    m_version = TemplateEx.dlgVer;
    m_signature = TemplateEx.signature;
    m_help_id = TemplateEx.helpID;
    m_style = TemplateEx.style;
    m_ex_style = TemplateEx.exStyle;
    m_cItems = TemplateEx.cDlgItems;
    m_pt.x = TemplateEx.x;
    m_pt.y = TemplateEx.y;
    m_siz.cx = TemplateEx.cx;
    m_siz.cy = TemplateEx.cy;

    if (!stream.ReadString(m_menu) ||
        !stream.ReadString(m_class) ||
        !stream.ReadString(m_title))
    {
        return false;
    }

    m_point_size = 0;
    m_weight = FW_NORMAL;
    m_italic = FALSE;
    m_charset = DEFAULT_CHARSET;
    m_type_face.clear();
    m_items.clear();

    if (TemplateEx.style & DS_SETFONT)
    {
        if (!stream.ReadWord(m_point_size) ||
            !stream.ReadWord(m_weight) || 
            !stream.ReadByte(m_italic) ||
            !stream.ReadByte(m_charset) ||
            !stream.ReadString(m_type_face))
        {
            return false;
        }
        ReplaceFont();
    }

    return true;
}

bool DialogRes::_headerToStream(MByteStreamEx& stream) const
{
    stream.WriteDwordAlignment();

    DLGTEMPLATE tmp;

    tmp.style = m_style;
    tmp.dwExtendedStyle = m_ex_style;
    tmp.cdit = m_cItems;
    tmp.x = (SHORT)m_pt.x;
    tmp.y = (SHORT)m_pt.y;
    tmp.cx = (SHORT)m_siz.cx;
    tmp.cy = (SHORT)m_siz.cy;
    if (!stream.WriteRaw(tmp) ||
        !stream.WriteString(m_menu.ptr()) ||
        !stream.WriteString(m_class.ptr()) ||
        !stream.WriteString(m_title.ptr()))
    {
        return false;
    }

    if (tmp.style & DS_SETFONT)
    {
        if (!stream.WriteWord(m_point_size) ||
            !stream.WriteString(m_type_face.ptr()))
        {
            return false;
        }
    }

    return true;
}

bool DialogRes::_headerToStreamEx(MByteStreamEx& stream) const
{
    stream.WriteDwordAlignment();

    DLGTEMPLATEEXHEAD TemplateEx;
    TemplateEx.dlgVer = 1;
    TemplateEx.signature = 0xFFFF;
    TemplateEx.helpID = m_help_id;
    TemplateEx.exStyle = m_ex_style;
    TemplateEx.style = m_style;
    TemplateEx.cDlgItems = m_cItems;
    TemplateEx.x = (short)m_pt.x;
    TemplateEx.y = (short)m_pt.y;
    TemplateEx.cx = (short)m_siz.cx;
    TemplateEx.cy = (short)m_siz.cy;
    if (!stream.WriteRaw(TemplateEx) ||
        !stream.WriteString(m_menu.ptr()) ||
        !stream.WriteString(m_class.ptr()) ||
        !stream.WriteString(m_title.ptr()))
    {
        return false;
    }

    if (TemplateEx.style & DS_SETFONT)
    {
        if (!stream.WriteWord(m_point_size) ||
            !stream.WriteWord(m_weight) ||
            !stream.WriteByte(m_italic) ||
            !stream.WriteByte(m_charset) ||
            !stream.WriteString(m_type_face.ptr()))
        {
            return false;
        }
    }
    return true;
}

//////////////////////////////////////////////////////////////////////////////

DialogItemClipboard::DialogItemClipboard(DialogRes& dialog_res)
    : m_dialog_res(dialog_res), 
    m_uCF_DIALOGITEMS(::RegisterClipboardFormat(TEXT("RisohEditor_DialogItem_ClipboardData")))
{
}

bool DialogItemClipboard::Copy(HWND hwndRad, const DialogItems& items)
{
    MByteStreamEx stream;

    for (size_t i = 0; i < items.size(); ++i)
    {
        items[i].SaveToStream(stream, m_dialog_res.IsExtended());
    }

    if (HGLOBAL hGlobal = GlobalAlloc(GHND | GMEM_SHARE, DWORD(stream.size())))
    {
        if (LPVOID pv = GlobalLock(hGlobal))
        {
            CopyMemory(pv, &stream[0], stream.size());
            GlobalUnlock(hGlobal);

            if (OpenClipboard(hwndRad))
            {
                EmptyClipboard();
                SetClipboardData(m_uCF_DIALOGITEMS, hGlobal);
                return !!CloseClipboard();
            }
        }
        GlobalFree(hGlobal);
    }
    return false;
}

bool DialogItemClipboard::Paste(HWND hwndRad, DialogItems& items) const
{
    items.clear();

    if (!IsAvailable())
        return false;

    if (!OpenClipboard(hwndRad))
        return false;

    bool bOK = false;
    if (HGLOBAL hGlobal = GetClipboardData(m_uCF_DIALOGITEMS))
    {
        SIZE_T siz = GlobalSize(hGlobal);
        if (LPVOID pv = GlobalLock(hGlobal))
        {
            MByteStreamEx stream(siz);
            CopyMemory(&stream[0], pv, siz);

            DialogItem item;
            while (item.LoadFromStream(stream, m_dialog_res.IsExtended()))
            {
                items.push_back(item);
            }
            GlobalUnlock(hGlobal);

            if (items.size())
            {
                bOK = true;
            }
        }
    }
    CloseClipboard();
    return bOK;
}

```

`src/DialogRes.hpp`:

```hpp
// DialogRes.hpp --- Dialog Resources
//////////////////////////////////////////////////////////////////////////////
// RisohEditor --- Another free Win32 resource editor
// Copyright (C) 2017-2018 Katayama Hirofumi MZ <katayama.hirofumi.mz@gmail.com>
// 
// This program is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
// 
// This program is distributed in the hope that it will be useful, 
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
// 
// You should have received a copy of the GNU General Public License
// along with this program.  If not, see <http://www.gnu.org/licenses/>.
//////////////////////////////////////////////////////////////////////////////

#pragma once
#ifndef _INC_WINDOWS
    #include <windows.h>
#endif
#include <vector>
#include "MByteStreamEx.hpp"
#include "DlgInitRes.hpp"

#ifndef BS_PUSHBOX
    #define BS_PUSHBOX  0x0000000A
#endif

//////////////////////////////////////////////////////////////////////////////

#include <pshpack2.h>

// the header of RT_DIALOG (DIALOGEX)
typedef struct DLGTEMPLATEEXHEAD
{
    WORD    dlgVer;
    WORD    signature;
    DWORD   helpID;
    DWORD   exStyle;
    DWORD   style;
    WORD    cDlgItems;
    short   x;
    short   y;
    short   cx;
    short   cy;
} DLGTEMPLATEEXHEAD, *PDLGTEMPLATEEXHEAD, *LPDLGTEMPLATEEXHEAD;

// the header of RT_DIALOG (DIALOGEX) item
typedef struct DLGITEMTEMPLATEEXHEAD
{
    DWORD   helpID;
    DWORD   exStyle;
    DWORD   style;
    short   x;
    short   y;
    short   cx;
    short   cy;
    WORD    id;
} DLGITEMTEMPLATEEXHEAD, *PDLGITEMTEMPLATEEXHEAD, *LPDLGITEMTEMPLATEEXHEAD;

#include <poppack.h>

//////////////////////////////////////////////////////////////////////////////

bool PredefClassToID(MStringW name, WORD& w);
bool IDToPredefClass(WORD w, MStringW& name);
void FixClassName(MStringW& cls);

//////////////////////////////////////////////////////////////////////////////

struct DialogItem
{
    DWORD                   m_help_id;
    DWORD                   m_style;
    DWORD                   m_ex_style;
    POINT                   m_pt;
    SIZE                    m_siz;
    WORD                    m_id;
    MIdOrString             m_class;
    MIdOrString             m_title;
    std::vector<BYTE>       m_extra;
    DWORD                   m_old_style, m_old_ex_style;
    MIdOrString             m_old_title;
    SIZE                    m_sizOld;
    MIdOrString             m_old_class;
    std::vector<MStringA>   m_str_list;

    DialogItem();

    bool LoadFromStream(const MByteStreamEx& stream, bool extended = false);
    bool LoadFromStreamEx(const MByteStreamEx& stream);

    bool SaveToStream(MByteStreamEx& stream, bool extended = false) const;
    bool SaveToStreamEx(MByteStreamEx& stream) const;
    MStringW Dump(bool bAlwaysControl = false) const;

    bool IsStdComboBox() const
    {
        if (lstrcmpiW(m_class.m_str.c_str(), L"COMBOBOX") == 0)
            return true;
        return (m_class.m_id == 0x0085);
    }
    bool IsListBox() const
    {
        if (lstrcmpiW(m_class.m_str.c_str(), L"LISTBOX") == 0)
            return true;
        return (m_class.m_id == 0x0083);
    }
    bool IsButton() const
    {
        if (lstrcmpiW(m_class.m_str.c_str(), L"BUTTON") == 0)
            return true;
        return (m_class.m_id == 0x0080);
    }
    bool IsGroupBox() const
    {
        if (!IsButton())
            return false;
        return (m_style & BS_TYPEMASK) == BS_GROUPBOX;
    }
    bool IsExtComboBox() const
    {
        return (lstrcmpiW(m_class.m_str.c_str(), L"ComboBoxEx32") == 0);
    }
    bool IsStaticIcon() const
    {
        if (m_title.is_int() &&
            (m_class.m_id == 0x0082 ||
             lstrcmpiW(m_class.m_str.c_str(), L"STATIC") == 0) &&
            (m_style & SS_TYPEMASK) == SS_ICON)
        {
            return true;
        }
        return false;
    }

    MStringW DumpControl(MStringW& cls) const;

    MStringW _do_CONTROL(bool bNeedsText, 
                         const MStringW& ctrl, 
                         const MStringW& cls, 
                         DWORD DefStyle) const;

    MStringW _do_BUTTON(const MStringW& ctrl, DWORD DefStyle) const
    {
        return _do_CONTROL(true, ctrl, L"BUTTON", DefStyle);
    }

    MStringW _do_TEXT(const MStringW& ctrl, DWORD DefStyle) const
    {
        return _do_CONTROL(true, ctrl, L"STATIC", DefStyle);
    }

    MStringW _do_AUTO3STATE() const
    {
        return _do_BUTTON(L"AUTO3STATE", (BS_AUTO3STATE | WS_TABSTOP | WS_CHILD | WS_VISIBLE));
    }
    MStringW _do_AUTOCHECKBOX() const
    {
        return _do_BUTTON(L"AUTOCHECKBOX", (BS_AUTOCHECKBOX | WS_TABSTOP | WS_CHILD | WS_VISIBLE));
    }
    MStringW _do_AUTORADIOBUTTON() const
    {
        // NOTE: RC won't add WS_TABSTOP. Microsoft document said a lie.
        return _do_BUTTON(L"AUTORADIOBUTTON", (BS_AUTORADIOBUTTON | /*WS_TABSTOP |*/ WS_CHILD | WS_VISIBLE));
    }
    MStringW _do_CHECKBOX() const
    {
        return _do_BUTTON(L"CHECKBOX", (BS_CHECKBOX | WS_TABSTOP | WS_CHILD | WS_VISIBLE));
    }
    MStringW _do_DEFPUSHBUTTON() const
    {
        return _do_BUTTON(L"DEFPUSHBUTTON", (BS_DEFPUSHBUTTON | WS_TABSTOP | WS_CHILD | WS_VISIBLE));
    }
    MStringW _do_GROUPBOX() const
    {
        return _do_BUTTON(L"GROUPBOX", (BS_GROUPBOX | WS_CHILD | WS_VISIBLE));
    }
    MStringW _do_PUSHBUTTON() const
    {
        return _do_BUTTON(L"PUSHBUTTON", (BS_PUSHBUTTON | WS_TABSTOP | WS_CHILD | WS_VISIBLE));
    }
    MStringW _do_PUSHBOX() const
    {
        return _do_BUTTON(L"PUSHBOX", (BS_PUSHBOX | WS_TABSTOP | WS_CHILD | WS_VISIBLE));
    }
    MStringW _do_RADIOBUTTON() const
    {
        return _do_BUTTON(L"RADIOBUTTON", (BS_RADIOBUTTON | WS_TABSTOP | WS_CHILD | WS_VISIBLE));
    }
    MStringW _do_STATE3() const
    {
        return _do_BUTTON(L"STATE3", (BS_3STATE | WS_TABSTOP | WS_CHILD | WS_VISIBLE));
    }
    MStringW _do_LTEXT() const
    {
        return _do_TEXT(L"LTEXT", (SS_LEFT | WS_GROUP | WS_CHILD | WS_VISIBLE));
    }
    MStringW _do_CTEXT() const
    {
        return _do_TEXT(L"CTEXT", (SS_CENTER | WS_GROUP | WS_CHILD | WS_VISIBLE));
    }
    MStringW _do_RTEXT() const
    {
        return _do_TEXT(L"RTEXT", (SS_RIGHT | WS_GROUP | WS_CHILD | WS_VISIBLE));
    }
    MStringW _do_EDITTEXT() const
    {
        assert(m_title.empty());
        return _do_CONTROL(false, L"EDITTEXT", L"EDIT", 
                           ES_LEFT | WS_BORDER | WS_TABSTOP | WS_CHILD | WS_VISIBLE);
    }
    MStringW _do_COMBOBOX() const
    {
        assert(m_title.empty());
        return _do_CONTROL(false, L"COMBOBOX", L"COMBOBOX", WS_CHILD | WS_VISIBLE);
    }
    MStringW _do_ICON() const
    {
        return _do_CONTROL(true, L"ICON", L"STATIC", SS_ICON | WS_CHILD | WS_VISIBLE);
    }
    MStringW _do_LISTBOX() const
    {
        assert(m_title.empty());
        return _do_CONTROL(false, L"LISTBOX", L"LISTBOX", 
                           LBS_NOTIFY | WS_BORDER | WS_CHILD | WS_VISIBLE);
    }
    MStringW _do_SCROLLBAR() const
    {
        assert(m_title.empty());
        return _do_CONTROL(false, L"SCROLLBAR", L"SCROLLBAR", SBS_HORZ | WS_CHILD | WS_VISIBLE);
    }

    BOOL IsClassRegd(const WCHAR *name) const;

    void FixupForRad(bool bRevert = false);
    void FixupForTest(bool bRevert = false);
};
typedef std::vector<DialogItem> DialogItems;

//////////////////////////////////////////////////////////////////////////////

struct DialogRes
{
    WORD                        m_version;
    WORD                        m_signature;
    DWORD                       m_help_id;
    DWORD                       m_style;
    DWORD                       m_ex_style;
    WORD                        m_cItems;
    POINT                       m_pt;
    SIZE                        m_siz;
    MIdOrString                 m_menu;
    MIdOrString                 m_class;
    MIdOrString                 m_title;
    short                       m_point_size;
    short                       m_weight;
    BYTE                        m_italic;
    BYTE                        m_charset;
    DialogItems                 m_items;
    MIdOrString                 m_name;
    LANGID                      m_lang;
protected:
    DWORD                       m_old_style, m_old_ex_style;
    MIdOrString                 m_old_menu;
    MIdOrString                 m_old_class;
    MIdOrString                 m_type_face;
    MIdOrString                 m_replaced_type_face;
    MIdOrString                 m_old_type_face;
    void ReplaceFont();

public:
    void type_face(const MIdOrString& type_face)
    {
        m_type_face = type_face;
        ReplaceFont();
    }
    const MIdOrString& type_face() const
    {
        return m_type_face;
    }

    DialogRes();

    DialogItem& operator[](size_t i)
    {
        assert(i < size());
        return m_items[i];
    }
    const DialogItem& operator[](size_t i) const
    {
        assert(i < size());
        return m_items[i];
    }
    size_t size() const
    {
        return m_items.size();
    }

    bool IsExtended() const
    {
        return m_signature == 0xFFFF;
    }

    bool LoadFromStream(const MByteStreamEx& stream);
    bool SaveToStream(MByteStreamEx& stream) const;

    INT GetDlgItem(WORD id) const;

    bool LoadDlgInitData(const MByteStreamEx::data_type& data);
    bool SaveDlgInitData(MByteStreamEx::data_type& data) const;

    std::vector<BYTE> data() const
    {
        MByteStreamEx stream;
        SaveToStream(stream);
        return stream.data();
    }

    MStringW Dump(const MIdOrString& id_or_str, bool bAlwaysControl = false);

    void FixupForRad(bool bRevert = false);
    void FixupForTest(bool bRevert = false);

    LONG GetCharDimensions(HDC hdc, LONG *height) const;

    static INT CALLBACK
    EnumFontFamProc(ENUMLOGFONT *pelf, NEWTEXTMETRIC *pntm, INT nFontType, LPARAM lParam)
    {
        if (lstrcmpi(pelf->elfLogFont.lfFaceName, TEXT("MS Shell Dlg 2")) == 0)
            return FALSE;
        return TRUE;
    }

    INT GetBaseUnits(INT& y) const;
    INT GetHeadLines() const;
    BOOL HasActiveX() const
    {
        for (auto& item : m_items)
        {
            if (StrCmpNIW(item.m_class.c_str(), L"AtlAxWin", 8) == 0)
                return TRUE;
            if (item.m_class.c_str()[0] == L'{')
                return TRUE;
        }
        return FALSE;
    }

protected:
    bool _headerFromStream(const MByteStreamEx& stream);
    bool _headerFromStreamEx(const MByteStreamEx& stream);
    bool _headerToStream(MByteStreamEx& stream) const;
    bool _headerToStreamEx(MByteStreamEx& stream) const;
};

//////////////////////////////////////////////////////////////////////////////

class DialogItemClipboard
{
public:
    DialogRes& m_dialog_res;
    UINT m_uCF_DIALOGITEMS;

    DialogItemClipboard(DialogRes& dialog_res);

    bool IsAvailable() const
    {
        return !!IsClipboardFormatAvailable(m_uCF_DIALOGITEMS);
    }

    bool Copy(HWND hwndRad, const DialogItems& items);
    bool Paste(HWND hwndRad, DialogItems& items) const;
};

```

`src/DlgInit.h`:

```h
// DlgInit.h --- dialog initialization by RT_DLGINIT            -*- C++ -*-
// This file is part of MZC4.  See file "ReadMe.txt" and "License.txt".
//////////////////////////////////////////////////////////////////////////////

#ifndef MZC4_DLGINIT_H_
#define MZC4_DLGINIT_H_     9   /* Version 9 */

// RT_DLGINIT
// BOOL ExecuteDlgInitDx(HWND hwnd, HMODULE module, const TCHAR *res_name);

//////////////////////////////////////////////////////////////////////////////

#include "MWindowBase.hpp"
#include "MString.hpp"

#ifndef RT_DLGINIT
    #define RT_DLGINIT  MAKEINTRESOURCE(240)
#endif

// Win16 messages
#define WIN16_LB_ADDSTRING  0x0401
#define WIN16_CB_ADDSTRING  0x0403
#define AFX_CB_ADDSTRING    0x1234

//////////////////////////////////////////////////////////////////////////////

inline const UNALIGNED WORD *
ExecuteDlgInitEntryDx(HWND hwnd, const UNALIGNED WORD *pw, SIZE_T& cbData)
{
    DWORD cb = 4 * sizeof(WORD);
    if (cbData <= cb)
        return NULL;
    cbData -= cb;

    // get data
    WORD ctrl = *pw++;
    WORD msg = *pw++;
    WORD w0 = *pw++;
    WORD w1 = *pw++;
    DWORD dwLen = MAKELONG(w0, w1);

    cb = dwLen;
    if (cbData <= cb)
        return NULL;
    cbData -= cb;

    // convert Win16 messages
    switch (msg)
    {
    case AFX_CB_ADDSTRING: msg = CBEM_INSERTITEM; break;
    case WIN16_LB_ADDSTRING: msg = LB_ADDSTRING; break;
    case WIN16_CB_ADDSTRING: msg = CB_ADDSTRING; break;
    }

    // NOTE: We don't support OCC.
    assert(msg == LB_ADDSTRING || msg == CB_ADDSTRING ||
           msg == CBEM_INSERTITEM);

#ifndef NDEBUG
    const BYTE *pb = reinterpret_cast<const BYTE *>(pw);
    assert(pb[dwLen - 1] == 0);
#endif

    // send the message
    if (msg == CBEM_INSERTITEM)
    {
        MString text = MAnsiToText(CP_ACP, LPSTR(pw)).c_str();

        COMBOBOXEXITEM item;
        item.mask = CBEIF_TEXT;
        item.iItem = -1;
        item.pszText = &text[0];

        if (::SendDlgItemMessageA(hwnd, ctrl, msg, 0, LPARAM(&item)) == -1)
            return NULL;
    }
    else if (msg == LB_ADDSTRING || msg == CB_ADDSTRING)
    {
        if (::SendDlgItemMessageA(hwnd, ctrl, msg, 0, LPARAM(pw)) == -1)
            return NULL;
    }

    // go to next entry
    return reinterpret_cast<const UNALIGNED WORD *>(
        reinterpret_cast<const BYTE *>(pw) + dwLen);
}

inline BOOL
ExecuteDlgInitDataDx(HWND hwnd, const void *pData, SIZE_T& cbData)
{
#ifndef NDEBUG
    DWORD i = 0;
#endif
    const UNALIGNED WORD *pw;
    pw = reinterpret_cast<const UNALIGNED WORD *>(pData);
    while (pw && *pw)
    {
        pw = ExecuteDlgInitEntryDx(hwnd, pw, cbData);
#ifndef NDEBUG
        ++i;
#endif
    }

    // NOTE: We don't send WM_INITIALUPDATE messages.
    return pw != NULL;
}

//////////////////////////////////////////////////////////////////////////////

inline BOOL
ExecuteDlgInitDx(HWND hwnd, HMODULE module, const TCHAR *res_name)
{
    BOOL bSuccess = FALSE;
    HGLOBAL hGlobal = NULL;
    void *pData = NULL;
    SIZE_T cbData = 0;

    // load from resource
    if (HRSRC hRsrc = FindResource(module, res_name, RT_DLGINIT))
    {
        hGlobal = LoadResource(module, hRsrc);
        cbData = SizeofResource(module, hRsrc);
        pData = LockResource(hGlobal);
    }

    // execute
    if (pData && cbData)
    {
        bSuccess = ExecuteDlgInitDataDx(hwnd, pData, cbData);
    }

    // clean up
    UnlockResource(hGlobal);
    FreeResource(hGlobal);

    return bSuccess;
}

//////////////////////////////////////////////////////////////////////////////

#endif  // ndef MZC4_DLGINIT_H_

```

`src/DlgInitRes.cpp`:

```cpp
// DlgInitRes.cpp --- DLGINIT Resource
//////////////////////////////////////////////////////////////////////////////
// RisohEditor --- Another free Win32 resource editor
// Copyright (C) 2017-2018 Katayama Hirofumi MZ <katayama.hirofumi.mz@gmail.com>
// 
// This program is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
// 
// This program is distributed in the hope that it will be useful, 
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
// 
// You should have received a copy of the GNU General Public License
// along with this program.  If not, see <http://www.gnu.org/licenses/>.
//////////////////////////////////////////////////////////////////////////////

#include "DlgInitRes.hpp"
#include "ConstantsDB.hpp"

bool DlgInitRes::LoadFromStream(const MByteStreamEx& stream)
{
    m_entries.clear();

    WORD wCtrl;
    while (stream.ReadWord(wCtrl) && wCtrl)
    {
        DlgInitEntry entry;
        entry.wCtrl = wCtrl;
       
        int32_t dwLen;
        if (!stream.ReadWord(entry.wMsg) || !stream.ReadDword(dwLen))
            return false;

        assert(dwLen);
        if (dwLen)
        {
            entry.strText.resize(dwLen - 1);
            if (!stream.ReadData(&entry.strText[0], dwLen))
                return false;
        }

        m_entries.push_back(entry);
    }

    return true;
}

bool DlgInitRes::SaveToStream(MByteStreamEx& stream) const
{
    for (auto& entry : m_entries)
    {
        DWORD dwLen = DWORD(entry.strText.size() + 1);
        if (!stream.WriteWord(entry.wCtrl) ||
            !stream.WriteWord(entry.wMsg) ||
            !stream.WriteDword(dwLen) ||
            !stream.WriteData(entry.strText.c_str(), dwLen))
        {
            return false;
        }
    }

    return stream.WriteWord(0);
}

MStringW DlgInitRes::Dump(const MIdOrString& id_or_str) const
{
    MStringW ret;

    if (id_or_str.is_str())
    {
        ret += id_or_str.str();
    }
    else
    {
        ret += g_db.GetNameOfResID(IDTYPE_DIALOG, id_or_str.m_id);
    }

    ret += L" 240\r\n";
    if (g_settings.bUseBeginEnd)
        ret += L"BEGIN\r\n";
    else
        ret += L"{\r\n";

    if (m_entries.size() == 0)
    {
        ret += L"    0\r\n";
        if (g_settings.bUseBeginEnd)
            ret += L"END\r\n";
        else
            ret += L"}\r\n";
        return ret;
    }

    for (auto& entry : m_entries)
    {
        ret += L"    ";
        ret += g_db.GetCtrlOrCmdName(entry.wCtrl);
        ret += L", ";

// Win16 messages
#define WIN16_LB_ADDSTRING  0x0401
#define WIN16_CB_ADDSTRING  0x0403
#define AFX_CB_ADDSTRING    0x1234

        switch (entry.wMsg)
        {
        case WIN16_LB_ADDSTRING:
        case LB_ADDSTRING:
            ret += mstr_hex_word(LB_ADDSTRING);
            break;
        case WIN16_CB_ADDSTRING:
        case CB_ADDSTRING:
            ret += mstr_hex_word(CB_ADDSTRING);
            break;
        case AFX_CB_ADDSTRING:
        case CBEM_INSERTITEM:
            ret += mstr_hex_word(CBEM_INSERTITEM);
            break;
        default:
            ret += mstr_hex_word(entry.wMsg);
        }

        ret += L", ";
        ret += mstr_hex_word(WORD(entry.strText.size() + 1));
        ret += L", 0";

        auto pw = reinterpret_cast<const UNALIGNED WORD *>(entry.strText.c_str());
        size_t len = (entry.strText.size() + 1) / 2;
        for (size_t k = 0; k < len; ++k)
        {
            ret += L", ";
            ret += mstr_hex_word(pw[k]);
        }
        if (entry.strText.size() % 2 == 0)
        {
            ret += L", \"\\000\"";
        }
        ret += L", ";

        ret += L"\r\n";
    }

    ret += L"    0\r\n";
    if (g_settings.bUseBeginEnd)
        ret += L"END\r\n";
    else
        ret += L"}\r\n";

    return ret;
}

std::vector<BYTE> DlgInitRes::data() const
{
    MByteStreamEx stream;
    SaveToStream(stream);
    return stream.data();
}

```

`src/DlgInitRes.hpp`:

```hpp
// DlgInitRes.hpp --- DLGINIT Resource
//////////////////////////////////////////////////////////////////////////////
// RisohEditor --- Another free Win32 resource editor
// Copyright (C) 2017-2018 Katayama Hirofumi MZ <katayama.hirofumi.mz@gmail.com>
// 
// This program is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
// 
// This program is distributed in the hope that it will be useful, 
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
// 
// You should have received a copy of the GNU General Public License
// along with this program.  If not, see <http://www.gnu.org/licenses/>.
//////////////////////////////////////////////////////////////////////////////

#pragma once

#ifndef _INC_WINDOWS
    #include <windows.h>
#endif
#include <cassert>
#include <vector>

#include "MByteStreamEx.hpp"
#include "MString.hpp"
#include "DlgInit.h"

//////////////////////////////////////////////////////////////////////////////

struct DLGINIT_ENTRY
{
    WCHAR sz0[64];
    WCHAR sz1[64];
    WCHAR sz2[256];
};

struct DlgInitEntry
{
    WORD        wCtrl;
    WORD        wMsg;
    MStringA    strText;

    DlgInitEntry() = default;
    
    DlgInitEntry(WORD ctrl, WORD msg, const MStringA& str)
        : wCtrl(ctrl), wMsg(msg), strText(str)
    {
    }
};

//////////////////////////////////////////////////////////////////////////////

class DlgInitRes
{
public:
    typedef DlgInitEntry                entry_type;
    typedef std::vector<entry_type>     entries_type;

protected:
    entries_type    m_entries;

public:
    DlgInitRes() = default;

    bool LoadFromStream(const MByteStreamEx& stream);
    bool SaveToStream(MByteStreamEx& stream) const;
    MStringW Dump(const MIdOrString& id_or_str) const;

    entries_type& entries()
    {
        return m_entries;
    }
    const entries_type& entries() const
    {
        return m_entries;
    }

    bool empty() const
    {
        return size() == 0;
    }
    size_t size() const
    {
        return m_entries.size();
    }
    entry_type& operator[](size_t i)
    {
        return m_entries[i];
    }
    const entry_type& operator[](size_t i) const
    {
        return m_entries[i];
    }
    void push_back(const DlgInitEntry& entry)
    {
        m_entries.push_back(entry);
    }
    void clear()
    {
        m_entries.clear();
    }

    std::vector<BYTE> data() const;
};

```

`src/IconRes.cpp`:

```cpp
// IconRes.cpp --- Icon Resources
//////////////////////////////////////////////////////////////////////////////
// RisohEditor --- Another free Win32 resource editor
// Copyright (C) 2017-2018 Katayama Hirofumi MZ <katayama.hirofumi.mz@gmail.com>
// 
// This program is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
// 
// This program is distributed in the hope that it will be useful, 
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
// 
// You should have received a copy of the GNU General Public License
// along with this program.  If not, see <http://www.gnu.org/licenses/>.
//////////////////////////////////////////////////////////////////////////////

#include "IconRes.hpp"

bool IconFile::LoadFromStream(const MByteStreamEx& stream)
{
    DWORD size = sizeof(ICONDIR);
    if (stream.size() < size)
        return false;

    memcpy(&m_dir, stream.ptr(), size);
    if (!IsIconDirOK())
        return false;

    stream.pos(size);
    size = m_dir.idCount * sizeof(EntryType);
    if (stream.remainder() < size)
        return false;

    m_entries.resize(m_dir.idCount);
    memcpy(&m_entries[0], stream.ptr(stream.pos()), size);
    m_images.resize(m_dir.idCount);

    for (int i = 0; i < m_dir.idCount; i++)
    {
        stream.pos(m_entries[i].dwImageOffset);
        if (stream.remainder() < m_entries[i].dwBytesInRes)
        {
            return false;
        }

        LPBYTE pb = (LPBYTE)stream.ptr(stream.pos());
        m_images[i].assign(&pb[0], &pb[m_entries[i].dwBytesInRes]);
    }
    return true;
}

bool IconFile::SaveToStream(MByteStreamEx& stream)
{
    stream.clear();
    if (!IsIconDirOK())
        return false;

    DWORD offset = sizeof(ICONDIR);
    const DWORD SizeOfEntries = GetImageCount() * sizeof(EntryType);
    offset += SizeOfEntries;

    const DWORD nCount = GetImageCount();
    for (DWORD i = 0; i < nCount; ++i)
    {
        m_entries[i].dwImageOffset = offset;
        offset += m_entries[i].dwBytesInRes;
    }

    if (!stream.WriteRaw(m_dir) ||
        !stream.WriteData(&m_entries[0], SizeOfEntries))
    {
        return false;
    }

    for (DWORD i = 0; i < nCount; ++i)
    {
        if (!stream.WriteData(GetImagePtr(i), GetImageSize(i)))
            return false;
    }

    return true;
}

#include <intrin.h> // for _byteswap_ulong

IconFile::DataType
IconFile::GetIconGroup(int nBaseID) const
{
    DataType group(SizeOfIconGroup());

    memcpy(&group[0], &m_dir, sizeof(ICONDIR));

    int offset = sizeof(ICONDIR);
    for (int i = 0; i < GetImageCount(); i++)
    {
        if (GetImageSize(i) > 25 &&
            memcmp(GetImagePtr(i), "\x89PNG", 4) == 0)
        {
            ResourceEntryType grpEntry;
            grpEntry.bWidth = (BYTE)_byteswap_ulong(*(uint32_t*)&GetImagePtr(i)[16]);
            grpEntry.bHeight = (BYTE)_byteswap_ulong(*(uint32_t*)&GetImagePtr(i)[20]);
            grpEntry.bColorCount = 0;
            grpEntry.bReserved = 0;
            grpEntry.wPlanes = 1;
            uint8_t bit_depth = *(uint8_t*)&GetImagePtr(i)[24];
            uint8_t color_type = *(uint8_t*)&GetImagePtr(i)[25];
            if (color_type & 4)
                grpEntry.wBitCount = 32;
            else if (color_type & 2)
                grpEntry.wBitCount = 24;
            else
                grpEntry.wBitCount = bit_depth;
            grpEntry.dwBytesInRes = m_entries[i].dwBytesInRes;
            grpEntry.nID = WORD(nBaseID + i);
            memcpy(&group[offset], &grpEntry, sizeof(grpEntry));
            offset += sizeof(grpEntry);
            continue;
        }

        BITMAPCOREHEADER    bmch;
        BITMAPINFOHEADER    bmih;

        memcpy(&bmch, GetImagePtr(i), sizeof(bmch));
        bool bCoreOnly = (bmch.bcSize == sizeof(bmch));
        if (!bCoreOnly)
        {
            memcpy(&bmih, GetImagePtr(i), sizeof(bmih));
        }

        ResourceEntryType  grpEntry;
        grpEntry.bWidth             = m_entries[i].bWidth;
        grpEntry.bHeight            = m_entries[i].bHeight;
        grpEntry.bColorCount        = m_entries[i].bColorCount;
        grpEntry.bReserved          = m_entries[i].bReserved;

        if (bCoreOnly)
        {
            if (grpEntry.bWidth == 0)
                grpEntry.bWidth     = (BYTE)bmch.bcWidth;
            if (grpEntry.bHeight == 0)
                grpEntry.bHeight    = (BYTE)bmch.bcHeight;

            grpEntry.wPlanes        = bmch.bcPlanes;
            grpEntry.wBitCount      = bmch.bcBitCount;
        }
        else
        {
            if (grpEntry.bWidth == 0)
                grpEntry.bWidth     = (BYTE)bmih.biWidth;
            if (grpEntry.bHeight == 0)
                grpEntry.bHeight    = (BYTE)bmih.biHeight;

            grpEntry.wPlanes        = bmih.biPlanes;
            grpEntry.wBitCount      = bmih.biBitCount;
        }

        grpEntry.dwBytesInRes       = m_entries[i].dwBytesInRes;
        grpEntry.nID                = WORD(nBaseID + i);

        memcpy(&group[offset], &grpEntry, sizeof(grpEntry));
        offset += sizeof(grpEntry);
    }

    return group;
}

//////////////////////////////////////////////////////////////////////////////

bool CursorFile::LoadFromStream(const MByteStreamEx& stream)
{
    DWORD size = sizeof(ICONDIR);
    if (stream.size() < size)
        return false;

    memcpy(&m_dir, stream.ptr(), size);
    if (!IsIconDirOK())
        return false;

    stream.pos(size);
    size = m_dir.idCount * sizeof(EntryType);
    if (stream.remainder() < size)
        return false;

    m_entries.resize(m_dir.idCount);
    memcpy(&m_entries[0], stream.ptr(stream.pos()), size);
    m_images.resize(m_dir.idCount);

    for (int i = 0; i < m_dir.idCount; i++)
    {
        stream.pos(m_entries[i].dwImageOffset);
        if (stream.remainder() < m_entries[i].dwBytesInRes)
        {
            return false;
        }

        LOCALHEADER local;
        local.xHotSpot = m_entries[i].xHotSpot;
        local.yHotSpot = m_entries[i].yHotSpot;
        LPBYTE pb = (LPBYTE)stream.ptr(stream.pos());

        MByteStreamEx bs;
        if (!bs.WriteRaw(local))
            return false;
        if (!bs.WriteData(pb, m_entries[i].dwBytesInRes))
            return false;

        m_entries[i].dwBytesInRes += sizeof(local);
        m_images[i] = bs.data();
    }
    return true;
}

bool CursorFile::SaveToStream(MByteStreamEx& stream)
{
    stream.clear();
    if (!IsIconDirOK())
        return false;

    DWORD offset = sizeof(ICONDIR);
    const DWORD SizeOfEntries = GetImageCount() * sizeof(EntryType);
    offset += SizeOfEntries;

    const DWORD nCount = GetImageCount();
    for (DWORD i = 0; i < nCount; ++i)
    {
        m_entries[i].dwImageOffset = offset;
        offset += m_entries[i].dwBytesInRes;
    }

    if (!stream.WriteRaw(m_dir) ||
        !stream.WriteData(&m_entries[0], SizeOfEntries))
    {
        return false;
    }

    for (DWORD i = 0; i < nCount; ++i)
    {
        LPBYTE pb = GetImagePtr(i) + sizeof(LOCALHEADER);
        DWORD size = GetImageSize(i) - sizeof(LOCALHEADER);
        if (!stream.WriteData(pb, size))
            return false;
    }

    return true;
}

CursorFile::DataType
CursorFile::GetCursorGroup(int nBaseID) const
{
    DataType group(SizeOfCursorGroup());

    memcpy(&group[0], &m_dir, sizeof(ICONDIR));

    int offset = sizeof(ICONDIR);
    for (int i = 0; i < GetImageCount(); i++)
    {
        BITMAPCOREHEADER    bmch;
        BITMAPINFOHEADER    bmih;
        LOCALHEADER         local;

        const BYTE *pb = GetImagePtr(i);
        memcpy(&local, pb, sizeof(local));
        memcpy(&bmch, pb + sizeof(local), sizeof(bmch));

        bool bCoreOnly = (bmch.bcSize == sizeof(bmch));
        if (!bCoreOnly)
        {
            memcpy(&bmih, pb + sizeof(local), sizeof(bmih));
        }

        ResourceEntryType  grpEntry;
        grpEntry.wWidth             = m_entries[i].bWidth;
        grpEntry.wHeight            = m_entries[i].bHeight;

        if (bCoreOnly)
        {
            if (grpEntry.wWidth == 0)
                grpEntry.wWidth     = (WORD)bmch.bcWidth;
            if (grpEntry.wHeight == 0)
                grpEntry.wHeight    = (WORD)bmch.bcHeight;

            grpEntry.wPlanes        = bmch.bcPlanes;
            grpEntry.wBitCount      = bmch.bcBitCount;
        }
        else
        {
            if (grpEntry.wWidth == 0)
                grpEntry.wWidth     = (WORD)bmih.biWidth;
            if (grpEntry.wHeight == 0)
                grpEntry.wHeight    = (WORD)bmih.biHeight;

            grpEntry.wPlanes        = bmih.biPlanes;
            grpEntry.wBitCount      = bmih.biBitCount;
        }

        grpEntry.wHeight           *= 2;
        grpEntry.dwBytesInRes       = m_entries[i].dwBytesInRes;
        grpEntry.nID                = WORD(nBaseID + i);

        memcpy(&group[offset], &grpEntry, sizeof(grpEntry));
        offset += sizeof(grpEntry);
    }

    return group;
}

```

`src/IconRes.hpp`:

```hpp
// IconRes.hpp --- Icon Resources
//////////////////////////////////////////////////////////////////////////////
// RisohEditor --- Another free Win32 resource editor
// Copyright (C) 2017-2018 Katayama Hirofumi MZ <katayama.hirofumi.mz@gmail.com>
// 
// This program is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
// 
// This program is distributed in the hope that it will be useful, 
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
// 
// You should have received a copy of the GNU General Public License
// along with this program.  If not, see <http://www.gnu.org/licenses/>.
//////////////////////////////////////////////////////////////////////////////

#pragma once

#ifndef _INC_WINDOWS
    #include <windows.h>
#endif
#include <cassert>
#include "MByteStreamEx.hpp"

//////////////////////////////////////////////////////////////////////////////

// the common header of RT_CURSOR, RT_ICON, icon/cursor files
typedef struct ICONDIR
{
    WORD           idReserved;  // Reserved (must be 0)
    WORD           idType;      // RES_ICON or RES_CURSOR
    WORD           idCount;     // How many images?
} ICONDIR, *LPICONDIR;

// the header of RT_CURSOR
typedef struct LOCALHEADER {
    WORD xHotSpot;
    WORD yHotSpot;
} LOCALHEADER;

// the entry of icon/cursor files (after ICONDIR)
typedef struct ICONDIRENTRY
{
    BYTE        bWidth;         // Width, in pixels, of the image
    BYTE        bHeight;        // Height, in pixels, of the image
    BYTE        bColorCount;    // Number of colors in image (0 if >= 8bpp)
    BYTE        bReserved;      // Reserved (must be 0)
    union
    {
        WORD    xHotSpot;       // Hot Spot X
        WORD    wPlanes;        // Color Planes
    };
    union
    {
        WORD    yHotSpot;       // Hot Spot Y
        WORD    wBitCount;      // Bits per pixel
    };
    DWORD       dwBytesInRes;   // How many bytes in this resource?
    DWORD       dwImageOffset;  // Where in the file is this image?
} ICONDIRENTRY, *LPICONDIRENTRY;

// the entry of group icon resource (RT_GROUP_ICON)
#include <pshpack2.h>
typedef struct GRPICONDIRENTRY
{
    BYTE   bWidth;              // Width, in pixels, of the image
    BYTE   bHeight;             // Height, in pixels, of the image
    BYTE   bColorCount;         // Number of colors in image (0 if >=8bpp)
    BYTE   bReserved;           // Reserved
    WORD   wPlanes;             // Color Planes
    WORD   wBitCount;           // Bits per pixel
    DWORD  dwBytesInRes;        // how many bytes in this resource?
    WORD   nID;                 // the ID
} GRPICONDIRENTRY, *LPGRPICONDIRENTRY;
#include <poppack.h>

// the entry of group cursor resource (RT_GROUP_CURSOR)
#include <pshpack2.h>
typedef struct GRPCURSORDIRENTRY
{
    WORD    wWidth;             // Width, in pixels, of the image
    WORD    wHeight;            // Height, in pixels, of the image
    WORD    wPlanes;            // Must be 1
    WORD    wBitCount;          // Bits per pixel
    DWORD   dwBytesInRes;       // how many bytes in this resource?
    WORD    nID;                // the ID
} GRPCURSORDIRENTRY, *LPGRPCURSORDIRENTRY;
#include <poppack.h>

//////////////////////////////////////////////////////////////////////////////

class IconFile
{
public:
    typedef ICONDIRENTRY            EntryType;
    typedef std::vector<EntryType>  EntryListType;
    typedef std::vector<BYTE>       DataType;
    typedef std::vector<DataType>   DataListType;
    typedef GRPICONDIRENTRY         ResourceEntryType;

    IconFile()
    {
        memset(&m_dir, 0, sizeof(m_dir));
    }

    void clear()
    {
        memset(&m_dir, 0, sizeof(m_dir));
        m_entries.clear();
        m_images.clear();
    }

    bool IsIconDirOK() const
    {
        return m_dir.idReserved == 0 && m_dir.idType == RES_ICON &&
               m_dir.idCount > 0;
    }

    WORD type() const
    {
        return m_dir.idType;
    }

    int SizeOfIconGroup() const
    {
        return sizeof(ICONDIR) + sizeof(ResourceEntryType) * GetImageCount();
    }

    WORD GetImageCount() const
    {
        return m_dir.idCount;
    }

    DataType& GetImage(int index)
    {
        assert(0 <= index && index < GetImageCount());
        return m_images[index];
    }
    const DataType& GetImage(int index) const
    {
        assert(0 <= index && index < GetImageCount());
        return m_images[index];
    }

    BYTE *GetImagePtr(int index)
    {
        return &(GetImage(index)[0]);
    }
    const BYTE *GetImagePtr(int index) const
    {
        return &(GetImage(index)[0]);
    }

    DWORD GetImageSize(int index) const
    {
        return DWORD(m_images[index].size());
    }

    bool LoadFromStream(const MByteStreamEx& stream);

    bool LoadFromFile(LPCTSTR pszFileName)
    {
        MByteStreamEx stream;
        if (!stream.LoadFromFile(pszFileName))
            return false;

        return LoadFromStream(stream);
    }

    bool SaveToStream(MByteStreamEx& stream);

    bool SaveToFile(LPCTSTR pszFileName)
    {
        MByteStreamEx stream;
        if (!SaveToStream(stream))
            return false;
        return stream.SaveToFile(pszFileName);
    }

    DataType GetIconGroup(int nBaseID) const;

protected:
    ICONDIR                     m_dir;
    EntryListType               m_entries;
    DataListType                m_images;
}; // class IconFile

//////////////////////////////////////////////////////////////////////////////

class CursorFile
{
public:
    typedef ICONDIRENTRY            EntryType;
    typedef std::vector<EntryType>  EntryListType;
    typedef std::vector<BYTE>       DataType;
    typedef std::vector<DataType>   DataListType;
    typedef GRPCURSORDIRENTRY       ResourceEntryType;

    CursorFile()
    {
        memset(&m_dir, 0, sizeof(m_dir));
    }

    void clear()
    {
        memset(&m_dir, 0, sizeof(m_dir));
        m_entries.clear();
        m_images.clear();
    }

    bool IsIconDirOK() const
    {
        return m_dir.idReserved == 0 && m_dir.idType == RES_CURSOR &&
               m_dir.idCount > 0;
    }

    WORD type() const
    {
        return m_dir.idType;
    }

    int SizeOfCursorGroup() const
    {
        return sizeof(ICONDIR) + sizeof(ResourceEntryType) * GetImageCount();
    }

    WORD GetImageCount() const
    {
        return m_dir.idCount;
    }

    DataType& GetImage(int index)
    {
        assert(0 <= index && index < GetImageCount());
        return m_images[index];
    }
    const DataType& GetImage(int index) const
    {
        assert(0 <= index && index < GetImageCount());
        return m_images[index];
    }

    BYTE *GetImagePtr(int index)
    {
        return &(GetImage(index)[0]);
    }
    const BYTE *GetImagePtr(int index) const
    {
        return &(GetImage(index)[0]);
    }

    DWORD GetImageSize(int index) const
    {
        return DWORD(m_images[index].size());
    }

    bool LoadFromStream(const MByteStreamEx& stream);

    bool LoadFromFile(LPCTSTR pszFileName)
    {
        MByteStreamEx stream;
        if (!stream.LoadFromFile(pszFileName))
            return false;

        return LoadFromStream(stream);
    }

    bool SaveToStream(MByteStreamEx& stream);

    bool SaveToFile(LPCTSTR pszFileName)
    {
        MByteStreamEx stream;
        if (!SaveToStream(stream))
            return false;
        return stream.SaveToFile(pszFileName);
    }

    DataType GetCursorGroup(int nBaseID) const;

protected:
    ICONDIR                     m_dir;
    EntryListType               m_entries;
    DataListType                m_images;
}; // class CursorFile

```

`src/MAddBitmapDlg.hpp`:

```hpp
// MAddBitmapDlg.hpp --- "Add Bitmap" Dialog
//////////////////////////////////////////////////////////////////////////////
// RisohEditor --- Another free Win32 resource editor
// Copyright (C) 2017-2018 Katayama Hirofumi MZ <katayama.hirofumi.mz@gmail.com>
// 
// This program is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
// 
// This program is distributed in the hope that it will be useful, 
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
// 
// You should have received a copy of the GNU General Public License
// along with this program.  If not, see <http://www.gnu.org/licenses/>.
//////////////////////////////////////////////////////////////////////////////

#pragma once

#include "resource.h"
#include "MWindowBase.hpp"
#include "ConstantsDB.hpp"
#include "Res.hpp"
#include "MComboBoxAutoComplete.hpp"
#include "MLangAutoComplete.hpp"
#include "Common.hpp"

//////////////////////////////////////////////////////////////////////////////

class MAddBitmapDlg : public MDialogBase
{
public:
    LPCWSTR m_file;
    MIdOrString m_type;
    MIdOrString m_name;
    WORD m_lang;
    MComboBoxAutoComplete m_cmb2;
    MComboBoxAutoComplete m_cmb3;
    MLangAutoComplete *m_pAutoComplete;

    MAddBitmapDlg()
        : MDialogBase(IDD_ADDBITMAP)
        , m_file(NULL)
        , m_pAutoComplete(new MLangAutoComplete())
    {
        m_cmb3.m_bAcceptSpace = TRUE;
        m_pAutoComplete->AddRef();
    }

    ~MAddBitmapDlg()
    {
        m_pAutoComplete->unbind();
        m_pAutoComplete->Release();
        m_pAutoComplete = NULL;
    }

    BOOL OnInitDialog(HWND hwnd, HWND hwndFocus, LPARAM lParam)
    {
        SetDlgItemTextW(hwnd, edt1, m_file);

        DragAcceptFiles(hwnd, TRUE);

        // for Names
        HWND hCmb2 = GetDlgItem(hwnd, cmb2);
        InitResNameComboBox(hCmb2, L"", IDTYPE_BITMAP);
        SetWindowText(hCmb2, L"");
        SubclassChildDx(m_cmb2, cmb2);

        // for Langs
        HWND hCmb3 = GetDlgItem(hwnd, cmb3);
        InitLangComboBox(hCmb3, GetThreadUILanguage());
        SubclassChildDx(m_cmb3, cmb3);

        CenterWindowDx();

        if (m_file)
        {
            SetFocus(hCmb2);
            return FALSE;
        }

        // auto complete
        COMBOBOXINFO info = { sizeof(info) };
        GetComboBoxInfo(m_cmb3, &info);
        HWND hwndEdit = info.hwndItem;
        m_pAutoComplete->bind(hwndEdit);

        return TRUE;
    }

    void OnPsh1(HWND hwnd)
    {
        MString strFile = GetDlgItemText(edt1);
        mstr_trim(strFile);

        WCHAR szFile[MAX_PATH];
        lstrcpynW(szFile, strFile.c_str(), _countof(szFile));

        OPENFILENAMEW ofn;
        ZeroMemory(&ofn, sizeof(ofn));
        ofn.lStructSize = OPENFILENAME_SIZE_VERSION_400W;
        ofn.hwndOwner = hwnd;
        ofn.lpstrFilter = MakeFilterDx(LoadStringDx(IDS_BMPFILTER));
        ofn.lpstrFile = szFile;
        ofn.nMaxFile = _countof(szFile);
        ofn.lpstrTitle = LoadStringDx(IDS_ADDBMP);
        ofn.Flags = OFN_ENABLESIZING | OFN_EXPLORER | OFN_FILEMUSTEXIST |
            OFN_HIDEREADONLY | OFN_PATHMUSTEXIST;
        ofn.lpstrDefExt = L"bmp";
        if (GetOpenFileNameW(&ofn))
        {
            SetDlgItemTextW(hwnd, edt1, szFile);
        }
    }

    void OnOK(HWND hwnd)
    {
        MIdOrString type = RT_BITMAP;

        MIdOrString name;
        HWND hCmb2 = GetDlgItem(hwnd, cmb2);
        if (!CheckNameComboBox(hCmb2, name))
            return;

        HWND hCmb3 = GetDlgItem(hwnd, cmb3);
        WORD lang;
        if (!CheckLangComboBox(hCmb3, lang))
            return;

        if (auto entry = g_res.find(ET_LANG, RT_BITMAP, name, lang))
        {
            INT id = MsgBoxDx(IDS_EXISTSOVERWRITE, MB_ICONINFORMATION | MB_YESNOCANCEL);
            switch (id)
            {
            case IDYES:
                g_res.delete_entry(entry);
                break;
            case IDNO:
            case IDCANCEL:
                return;
            }
        }

        std::wstring file;
        HWND hEdt1 = GetDlgItem(hwnd, edt1);
        if (!Edt1_CheckFile(hEdt1, file))
        {
            Edit_SetSel(hEdt1, 0, -1);  // select all
            SetFocus(hEdt1);    // set focus
            ErrorBoxDx(IDS_FILENOTFOUND);
            return;
        }

        if (!g_res.add_bitmap(name, lang, file))
        {
            ErrorBoxDx(IDS_CANTADDBMP);
            return;
        }

        m_type = type;
        m_name = name;
        m_lang = lang;

        EndDialog(IDOK);
    }

    void OnPsh2(HWND hwnd)
    {
        SendMessage(GetParent(hwnd), WM_COMMAND, ID_IDLIST, 0);
    }

    void OnCommand(HWND hwnd, int id, HWND hwndCtl, UINT codeNotify)
    {
        switch (id)
        {
        case IDOK:
            OnOK(hwnd);
            break;
        case IDCANCEL:
            EndDialog(IDCANCEL);
            break;
        case psh1:
            OnPsh1(hwnd);
            break;
        case psh2:
            OnPsh2(hwnd);
            break;
        case cmb2:
            if (codeNotify == CBN_EDITCHANGE)
            {
                m_cmb2.OnEditChange();
            }
            break;
        case cmb3:
            if (codeNotify == CBN_EDITCHANGE)
            {
                m_cmb3.OnEditChange();
            }
            break;
        }
    }

    void OnDropFiles(HWND hwnd, HDROP hdrop)
    {
        WCHAR file[MAX_PATH];
        DragQueryFileW(hdrop, 0, file, _countof(file));
        SetDlgItemTextW(hwnd, edt1, file);
    }

    virtual INT_PTR CALLBACK
    DialogProcDx(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
    {
        switch (uMsg)
        {
            HANDLE_MSG(hwnd, WM_INITDIALOG, OnInitDialog);
            HANDLE_MSG(hwnd, WM_DROPFILES, OnDropFiles);
            HANDLE_MSG(hwnd, WM_COMMAND, OnCommand);
        }
        return DefaultProcDx();
    }
};

```

`src/MAddCtrlDlg.hpp`:

```hpp
// MAddCtrlDlg.hpp --- "Add Control" Dialog
//////////////////////////////////////////////////////////////////////////////
// RisohEditor --- Another free Win32 resource editor
// Copyright (C) 2017-2018 Katayama Hirofumi MZ <katayama.hirofumi.mz@gmail.com>
// 
// This program is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
// 
// This program is distributed in the hope that it will be useful, 
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
// 
// You should have received a copy of the GNU General Public License
// along with this program.  If not, see <http://www.gnu.org/licenses/>.
//////////////////////////////////////////////////////////////////////////////

#pragma once

#include "resource.h"
#include "DialogRes.hpp"
#include "MString.hpp"
#include "MToolBarCtrl.hpp"
#include "MComboBoxAutoComplete.hpp"
#include "MCtrlDataDlg.hpp"
#include "MStringListDlg.hpp"
#include "Common.hpp"
#include <oledlg.h>

class MAddCtrlDlg;

//////////////////////////////////////////////////////////////////////////////

class MAddCtrlDlg : public MDialogBase
{
public:
    DialogRes&      m_dialog_res;
    BOOL            m_bUpdating;
    DWORD           m_dwStyle;
    DWORD           m_dwExStyle;
    POINT           m_pt;
    ConstantsDB::TableType  m_style_table;
    ConstantsDB::TableType  m_exstyle_table;
    std::vector<BYTE>       m_style_selection;
    std::vector<BYTE>       m_exstyle_selection;
    MToolBarCtrl            m_hTB;
    HIMAGELIST              m_himlControls;
    std::vector<std::wstring> m_vecControls;
    MComboBoxAutoComplete m_cmb1;
    MComboBoxAutoComplete m_cmb2;
    MComboBoxAutoComplete m_cmb3;
    MComboBoxAutoComplete m_cmb4;
    MComboBoxAutoComplete m_cmb5;
    std::vector<BYTE> m_data;
    std::vector<MStringA> m_str_list;

    MAddCtrlDlg(DialogRes& dialog_res, POINT pt)
        : MDialogBase(IDD_ADDCTRL), m_dialog_res(dialog_res), 
          m_bUpdating(FALSE), m_pt(pt)
    {
        m_himlControls = NULL;
        m_cmb2.m_bAcceptSpace = TRUE;
        m_cmb4.m_bAcceptSpace = TRUE;
    }

    ~MAddCtrlDlg()
    {
        if (m_himlControls)
        {
            ImageList_Destroy(m_himlControls);
            m_himlControls = NULL;
        }
    }

    void InitTables(LPCTSTR pszClass)
    {
        ConstantsDB::TableType table;

        m_style_table.clear();
        if (pszClass && pszClass[0])
        {
            table = g_db.GetTable(pszClass);
            if (table.size())
            {
                m_style_table.insert(m_style_table.end(), 
                    table.begin(), table.end());
            }
        }
        table = g_db.GetTable(TEXT("STYLE"));
        if (table.size())
        {
            m_style_table.insert(m_style_table.end(), 
                table.begin(), table.end());
        }
        m_style_selection.resize(m_style_table.size());

        m_exstyle_table.clear();
        table = g_db.GetTable(TEXT("EXSTYLE"));
        if (table.size())
        {
            m_exstyle_table.insert(m_exstyle_table.end(), 
                table.begin(), table.end());
        }
        m_exstyle_selection.resize(m_exstyle_table.size());
    }

    void ApplySelection(HWND hLst, std::vector<BYTE>& sel)
    {
        m_bUpdating = TRUE;
        INT iTop = ListBox_GetTopIndex(hLst);
        for (size_t i = 0; i < sel.size(); ++i)
        {
            ListBox_SetSel(hLst, sel[i], (DWORD)i);
        }
        ListBox_SetTopIndex(hLst, iTop);
        m_bUpdating = FALSE;
    }

    void ApplySelection(HWND hLst, ConstantsDB::TableType& table, 
                        std::vector<BYTE>& sel, DWORD dwValue)
    {
        m_bUpdating = TRUE;
        INT iTop = ListBox_GetTopIndex(hLst);
        for (size_t i = 0; i < table.size(); ++i)
        {
            sel[i] = ((dwValue & table[i].mask) == table[i].value);
            ListBox_SetSel(hLst, sel[i], (DWORD)i);
        }
        ListBox_SetTopIndex(hLst, iTop);
        m_bUpdating = FALSE;
    }

    void InitToolBar()
    {
        std::vector<TBBUTTON> buttons;

        ConstantsDB::TableType table = g_db.GetTable(TEXT("CONTROLS.ICONS"));
        size_t count = table.size();
        UINT nCount = UINT(count);

        m_vecControls.clear();
        if (m_himlControls)
        {
            ImageList_Destroy(m_himlControls);
            m_himlControls = NULL;
        }
        m_himlControls = ImageList_LoadBitmap(
            GetModuleHandle(NULL), MAKEINTRESOURCE(IDB_CONTROLS), 
            16, 0, RGB(255, 0, 255));
        m_hTB.SetImageList(m_himlControls);

        buttons.resize(nCount);
        for (UINT i = 0; i < nCount; ++i)
        {
            buttons[i].iBitmap = i;
            buttons[i].idCommand = i + 1000;
            buttons[i].fsState = TBSTATE_ENABLED;
            buttons[i].fsStyle = TBSTYLE_BUTTON;
            buttons[i].iString = 0;
            m_vecControls.push_back(table[i].name);
        }
        m_hTB.AddButtons(nCount, &buttons[0]);
    }

    BOOL OnInitDialog(HWND hwnd, HWND hwndFocus, LPARAM lParam)
    {
        SubclassChildDx(m_hTB, ctl1);
        InitToolBar();

        SetDlgItemInt(hwnd, edt1, m_pt.x, FALSE);
        SetDlgItemInt(hwnd, edt2, m_pt.y, FALSE);

        INT cx = g_db.GetValue(TEXT("CONTROL.SIZE"), TEXT("WIDTH"));
        INT cy = g_db.GetValue(TEXT("CONTROL.SIZE"), TEXT("HEIGHT"));
        SetDlgItemInt(hwnd, edt3, cx, FALSE);
        SetDlgItemInt(hwnd, edt4, cy, FALSE);

        HWND hCmb1 = GetDlgItem(hwnd, cmb1);
        InitClassComboBox(hCmb1, TEXT(""));
        SubclassChildDx(m_cmb1, cmb1);
        EnableWindow(GetDlgItem(hwnd, psh3), FALSE);

        HWND hCmb2 = GetDlgItem(hwnd, cmb2);
        InitCaptionComboBox(hCmb2, TEXT(""));
        SubclassChildDx(m_cmb2, cmb2);

        HWND hCmb3 = GetDlgItem(hwnd, cmb3);
        InitCtrlIDComboBox(hCmb3);
        if (g_settings.bUseIDC_STATIC)
            SetDlgItemText(hwnd, cmb3, TEXT("IDC_STATIC"));
        else
            SetDlgItemText(hwnd, cmb3, TEXT("-1"));
        SubclassChildDx(m_cmb3, cmb3);

        HWND hCmb4 = GetDlgItem(hwnd, cmb4);
        InitWndClassComboBox(hCmb4, TEXT(""));
        SubclassChildDx(m_cmb4, cmb4);

        HWND hCmb5 = GetDlgItem(hwnd, cmb5);
        InitResNameComboBox(hCmb5, WORD(0), IDTYPE_HELP);
        SetDlgItemInt(hwnd, cmb5, 0, FALSE);
        SubclassChildDx(m_cmb5, cmb5);

        InitTables(NULL);

        TCHAR szText[64];

        HWND hLst1 = GetDlgItem(hwnd, lst1);
        m_dwStyle = WS_VISIBLE | WS_CHILD;
        GetStyleSelect(m_style_selection, m_style_table, m_dwStyle);
        InitStyleListBox(hLst1, m_style_table);
        ApplySelection(hLst1, m_style_table, m_style_selection, m_dwStyle);

        m_bUpdating = TRUE;
        StringCchPrintf(szText, _countof(szText), TEXT("%08lX"), m_dwStyle);
        SetDlgItemText(hwnd, edt6, szText);
        SendDlgItemMessage(hwnd, edt6, EM_SETLIMITTEXT, 8, 0);
        m_bUpdating = FALSE;

        HWND hLst2 = GetDlgItem(hwnd, lst2);
        m_dwExStyle = 0;
        GetStyleSelect(m_exstyle_selection, m_exstyle_table, m_dwExStyle);
        InitStyleListBox(hLst2, m_exstyle_table);
        ApplySelection(hLst2, m_exstyle_table, m_exstyle_selection, m_dwExStyle);

        m_bUpdating = TRUE;
        StringCchPrintf(szText, _countof(szText), TEXT("%08lX"), m_dwExStyle);
        SetDlgItemText(hwnd, edt7, szText);
        SendDlgItemMessage(hwnd, edt7, EM_SETLIMITTEXT, 8, 0);
        m_bUpdating = FALSE;

        if (!m_dialog_res.IsExtended())
            EnableWindow(GetDlgItem(hwnd, psh1), FALSE);

        SendDlgItemMessage(hwnd, scr1, UDM_SETRANGE, 0, MAKELPARAM(9999, -9999));
        SendDlgItemMessage(hwnd, scr2, UDM_SETRANGE, 0, MAKELPARAM(9999, -9999));
        SendDlgItemMessage(hwnd, scr3, UDM_SETRANGE, 0, MAKELPARAM(9999, -9999));
        SendDlgItemMessage(hwnd, scr4, UDM_SETRANGE, 0, MAKELPARAM(9999, -9999));

        CenterWindowDx();
        return TRUE;
    }

    void OnOK(HWND hwnd)
    {
        MString strCaption = GetDlgItemText(cmb2);
        g_settings.AddCaption(strCaption.c_str());
        if (strCaption[0] == TEXT('"'))
        {
            mstr_unquote(strCaption);
        }

        INT x = GetDlgItemInt(hwnd, edt1, NULL, TRUE);
        INT y = GetDlgItemInt(hwnd, edt2, NULL, TRUE);
        INT cx = GetDlgItemInt(hwnd, edt3, NULL, TRUE);
        INT cy = GetDlgItemInt(hwnd, edt4, NULL, TRUE);
        MString strID = GetDlgItemText(cmb3);
        mstr_trim(strID);
        WORD id;
        if ((TEXT('0') <= strID[0] && strID[0] <= TEXT('9')) ||
            strID[0] == TEXT('-') || strID[0] == TEXT('+'))
        {
            id = (WORD)mstr_parse_int(strID.c_str());
        }
        else if (g_db.HasResID(strID))
        {
            id = (WORD)g_db.GetResIDValue(strID);
        }
        else if (g_db.HasCtrlID(strID))
        {
            id = (WORD)g_db.GetCtrlIDValue(strID);
        }
        else
        {
            HWND hCmb3 = GetDlgItem(hwnd, cmb3);
            ComboBox_SetEditSel(hCmb3, 0, -1);
            SetFocus(hCmb3);
            ErrorBoxDx(IDS_NOSUCHID);
            return;
        }

        MString strClass = GetDlgItemText(cmb4);
        mstr_trim(strClass);
        if (strClass[0] == TEXT('"'))
        {
            mstr_unquote(strClass);
        }
        if (!IsThereWndClass(strClass.c_str()))
        {
            SetFocus(GetDlgItem(hwnd, cmb4));
            MsgBoxDx(LoadStringDx(IDS_ENTERCLASS), MB_ICONERROR);
            return;
        }

        MString strHelp = GetDlgItemText(cmb5);
        ReplaceFullWithHalf(strHelp);
        mstr_trim(strHelp);
        DWORD help;
        if (g_db.HasResID(strHelp))
        {
            help = g_db.GetResIDValue(strHelp);
        }
        else
        {
            help = mstr_parse_int(strHelp.c_str(), false);
        }

        MString strStyle = GetDlgItemText(edt6);
        ReplaceFullWithHalf(strStyle);
        mstr_trim(strStyle);
        DWORD style = mstr_parse_int(strStyle.c_str(), false, 16);

        MString strExStyle = GetDlgItemText(edt7);
        mstr_trim(strExStyle);
        DWORD exstyle = mstr_parse_int(strExStyle.c_str(), false, 16);

        DialogItem item;
        item.m_help_id = help;
        item.m_style = style;
        item.m_ex_style = exstyle;
        item.m_pt.x = x;
        item.m_pt.y = y;
        item.m_siz.cx = cx;
        item.m_siz.cy = cy;
        item.m_id = id;
        item.m_class = strClass.c_str();
        item.m_title = strCaption.c_str();
        item.m_extra = m_data;
        item.m_str_list = m_str_list;

        if (lstrcmpiW(strClass.c_str(), L"STATIC") == 0)
        {
            if ((style & SS_TYPEMASK) == SS_ICON ||
                (style & SS_TYPEMASK) == SS_BITMAP)
            {
                if (mchr_is_digit(strCaption[0]))
                {
                    LONG n = mstr_parse_int(strCaption.c_str());
                    item.m_title = WORD(n);
                }
            }
        }

        m_dialog_res.m_cItems++;
        m_dialog_res.m_items.push_back(item);

        EndDialog(IDOK);
    }

    void OnLst1(HWND hwnd)
    {
        if (m_bUpdating)
            return;

        HWND hLst1 = GetDlgItem(hwnd, lst1);

        std::vector<BYTE> old_style_selection = m_style_selection;
        GetStyleSelect(hLst1, m_style_selection);

        m_dwStyle = AnalyseStyleDiff(m_dwStyle, m_style_table, 
                                     old_style_selection, m_style_selection);
        ApplySelection(hLst1, m_style_table, m_style_selection, m_dwStyle);

        m_bUpdating = TRUE;
        TCHAR szText[32];
        StringCchPrintf(szText, _countof(szText), TEXT("%08lX"), m_dwStyle);
        SetDlgItemText(hwnd, edt6, szText);
        m_bUpdating = FALSE;
    }

    void OnLst2(HWND hwnd)
    {
        if (m_bUpdating)
            return;

        HWND hLst2 = GetDlgItem(hwnd, lst2);

        std::vector<BYTE> old_exstyle_selection = m_exstyle_selection;
        GetStyleSelect(hLst2, m_exstyle_selection);

        m_dwExStyle = AnalyseStyleDiff(m_dwExStyle, m_exstyle_table, 
                                       old_exstyle_selection, m_exstyle_selection);
        ApplySelection(hLst2, m_exstyle_table, m_exstyle_selection, m_dwExStyle);

        m_bUpdating = TRUE;
        TCHAR szText[32];
        StringCchPrintf(szText, _countof(szText), TEXT("%08lX"), m_dwExStyle);
        SetDlgItemText(hwnd, edt7, szText);
        m_bUpdating = FALSE;
    }

    void OnEdt6(HWND hwnd)
    {
        if (m_bUpdating)
            return;

        MString text = GetDlgItemText(hwnd, edt6);
        mstr_trim(text);
        DWORD dwStyle = mstr_parse_int(text.c_str(), false, 16);

        GetStyleSelect(m_style_selection, m_style_table, dwStyle);

        HWND hLst1 = GetDlgItem(hwnd, lst1);
        m_dwStyle = dwStyle;
        ApplySelection(hLst1, m_style_table, m_style_selection, dwStyle);
    }

    void OnEdt7(HWND hwnd)
    {
        if (m_bUpdating)
            return;

        MString text = GetDlgItemText(hwnd, edt7);
        mstr_trim(text);
        DWORD dwExStyle = mstr_parse_int(text.c_str(), false, 16);

        GetStyleSelect(m_exstyle_selection, m_exstyle_table, dwExStyle);

        HWND hLst2 = GetDlgItem(hwnd, lst2);
        m_dwExStyle = dwExStyle;
        ApplySelection(hLst2, m_exstyle_table, m_exstyle_selection, dwExStyle);
    }

    void UpdateClass(HWND hwnd, HWND hLst1, const MString& strClass)
    {
        DWORD dwType = g_db.GetValue(TEXT("CONTROL.CLASSES"), strClass);
        if (dwType == 0)
            return;

        MString strSuper;
        if (dwType >= 3)
        {
            ConstantsDB::TableType table;
            table = g_db.GetTable(strClass + TEXT(".SUPERCLASS"));
            if (table.size())
            {
                strSuper = table[0].name;
            }
        }

        if (strSuper.size())
            InitTables(strSuper.c_str());
        else
            InitTables(strClass.c_str());

        MString str = strClass + TEXT(".DEFAULT.STYLE");
        m_dwStyle = g_db.GetValue(str, TEXT("STYLE"));

        GetStyleSelect(m_style_selection, m_style_table, m_dwStyle);
        InitStyleListBox(hLst1, m_style_table);
        ApplySelection(hLst1, m_style_table, m_style_selection, m_dwStyle);

        m_bUpdating = TRUE;
        TCHAR szText[32];
        StringCchPrintf(szText, _countof(szText), TEXT("%08lX"), m_dwStyle);
        SetDlgItemText(hwnd, edt6, szText);
        m_bUpdating = FALSE;

        ListBox_SetTopIndex(hLst1, 0);

        INT cx, cy;
        cx = g_db.GetValue(strClass + TEXT(".SIZE"), TEXT("WIDTH"));
        cy = g_db.GetValue(strClass + TEXT(".SIZE"), TEXT("HEIGHT"));
        if (cx == 0 && cy == 0)
        {
            cx = g_db.GetValue(strSuper + TEXT(".SIZE"), TEXT("WIDTH"));
            cy = g_db.GetValue(strSuper + TEXT(".SIZE"), TEXT("HEIGHT"));
        }
        if (cx == 0 && cy == 0)
        {
            cx = g_db.GetValue(TEXT("CONTROL.SIZE"), TEXT("WIDTH"));
            cy = g_db.GetValue(TEXT("CONTROL.SIZE"), TEXT("HEIGHT"));
        }
        if (lstrcmpi(strClass.c_str(), TEXT("COMBOBOX")) == 0 ||
            lstrcmpi(strSuper.c_str(), TEXT("COMBOBOX")) == 0 ||
            lstrcmpi(strClass.c_str(), WC_COMBOBOXEX) == 0 ||
            lstrcmpi(strSuper.c_str(), WC_COMBOBOXEX) == 0)
        {
            cy = g_settings.nComboHeight;
        }
        SetDlgItemInt(hwnd, edt3, cx, FALSE);
        SetDlgItemInt(hwnd, edt4, cy, FALSE);

        if (strSuper.size())
            SetDlgItemText(hwnd, cmb4, strSuper.c_str());
        else
            SetDlgItemText(hwnd, cmb4, strClass.c_str());

        if (strClass == L"COMBOBOX" || strClass == L"LISTBOX" ||
            strClass == L"ComboBoxEx32")
        {
            EnableWindow(GetDlgItem(hwnd, psh3), TRUE);
        }
        else
        {
            EnableWindow(GetDlgItem(hwnd, psh3), FALSE);
        }
    }

    void OnPsh1(HWND hwnd)
    {
        MCtrlDataDlg dialog(m_data);
        dialog.DialogBoxDx(hwnd);
    }

    void OnPsh2(HWND hwnd)
    {
        OLEUIINSERTOBJECT insert_object;
        TCHAR szFile[MAX_PATH] = { 0 };

        ZeroMemory(&insert_object, sizeof(insert_object));
        insert_object.cbStruct = sizeof(insert_object);
        insert_object.dwFlags = IOF_DISABLEDISPLAYASICON | IOF_SELECTCREATENEW | IOF_DISABLELINK;
        insert_object.hWndOwner = hwnd;
        insert_object.lpszCaption = LoadStringDx(IDS_CHOOSE_OLE_CLSID);
        insert_object.iid = IID_IOleObject;
        insert_object.lpszFile = szFile;
        insert_object.cchFile = _countof(szFile);

        UINT uResult = OleUIInsertObject(&insert_object);
        if (uResult == OLEUI_OK)
        {
            LPOLESTR pszCLSID = NULL;
            if (S_OK == StringFromCLSID(insert_object.clsid, &pszCLSID))
            {
                SetDlgItemTextW(hwnd, cmb2, NULL);
                SetDlgItemTextW(hwnd, cmb4, pszCLSID);
                CoTaskMemFree(pszCLSID);
            }
        }
    }

    void OnPsh3(HWND hwnd)
    {
        MStringListDlg dialog(m_str_list);
        if (dialog.DialogBoxDx(hwnd) == IDOK)
        {
            ;
        }
    }

    void OnCommand(HWND hwnd, int id, HWND hwndCtl, UINT codeNotify)
    {
        HWND hLst1 = GetDlgItem(hwnd, lst1);
        HWND hCmb1 = GetDlgItem(hwnd, cmb1);
        HWND hCmb4 = GetDlgItem(hwnd, cmb4);
        TCHAR szText[64];
        switch (id)
        {
        case IDOK:
            OnOK(hwnd);
            break;
        case IDCANCEL:
            EndDialog(IDCANCEL);
            break;
        case cmb1:
            if (codeNotify == CBN_SELCHANGE)
            {
                INT nIndex = ComboBox_GetCurSel(hCmb1);
                ComboBox_GetLBText(hCmb1, nIndex, szText);
                MString text = szText;
                mstr_trim(text);
                UpdateClass(hwnd, hLst1, text);
            }
            else if (codeNotify == CBN_EDITCHANGE)
            {
                DWORD dwPos;
                m_cmb1.OnEditChange(dwPos);
                {
                    MString text = GetDlgItemText(hwnd, cmb1);
                    mstr_trim(text);
                    InitTables(text.c_str());
                    UpdateClass(hwnd, hLst1, text);
                }
                m_cmb1.SetEditSel(LOWORD(dwPos), -1);
            }
            break;
        case cmb2:
            if (codeNotify == CBN_EDITCHANGE)
            {
                m_cmb2.OnEditChange();
            }
            break;
        case cmb3:
            if (codeNotify == CBN_EDITCHANGE)
            {
                m_cmb3.OnEditChange();
            }
            break;
        case cmb4:
            if (codeNotify == CBN_SELCHANGE)
            {
                INT nIndex = ComboBox_GetCurSel(hCmb4);
                ComboBox_GetLBText(hCmb4, nIndex, szText);
                MString text = szText;
                mstr_trim(text);
                UpdateClass(hwnd, hLst1, text);
            }
            else if (codeNotify == CBN_EDITCHANGE)
            {
                DWORD dwPos;
                m_cmb4.OnEditChange(dwPos);
                {
                    MString text = GetDlgItemText(hwnd, cmb4);
                    mstr_trim(text);
                    InitTables(text.c_str());
                    UpdateClass(hwnd, hLst1, text);
                }
                m_cmb4.SetEditSel(LOWORD(dwPos), -1);
            }
            break;
        case cmb5:
            if (codeNotify == CBN_EDITCHANGE)
            {
                m_cmb5.OnEditChange();
            }
            break;
        case lst1:
            if (codeNotify == LBN_SELCHANGE)
            {
                OnLst1(hwnd);
            }
            break;
        case lst2:
            if (codeNotify == LBN_SELCHANGE)
            {
                OnLst2(hwnd);
            }
            break;
        case edt6:
            if (codeNotify == EN_CHANGE)
            {
                OnEdt6(hwnd);
            }
            break;
        case edt7:
            if (codeNotify == EN_CHANGE)
            {
                OnEdt7(hwnd);
            }
            break;
        case psh1:
            OnPsh1(hwnd);
            break;
        case psh2:
            OnPsh2(hwnd);
            break;
        case psh3:
            OnPsh3(hwnd);
            break;
        default:
            if (size_t(id - 1000) < m_vecControls.size())
            {
                MString text;
                UINT nID = UINT(id - 1000);
                if (nID == g_db.GetValue(TEXT("CONTROLS.OLE.CONTROL"), TEXT("INDEX")))
                {
                    // OLE controls
                    text = g_settings.strAtlAxWin;
                    SetDlgItemTextW(hwnd, cmb4, text.c_str());
                }
                else
                {
                    text = m_vecControls[nID];
                    SetDlgItemTextW(hwnd, cmb1, text.c_str());
                }
                mstr_trim(text);
                InitTables(text.c_str());
                UpdateClass(hwnd, hLst1, text);
            }
            break;
        }
    }

    LRESULT OnNotify(HWND hwnd, int idFrom, LPNMHDR pnmhdr)
    {
        if (pnmhdr->code == TTN_NEEDTEXT)
        {
            TOOLTIPTEXT *ttt = (TOOLTIPTEXT *)pnmhdr;
            UINT nID = UINT(pnmhdr->idFrom - 1000);
            if (size_t(nID) < m_vecControls.size())
            {
                MString text;
                if (nID == g_db.GetValue(TEXT("CONTROLS.OLE.CONTROL"), TEXT("INDEX")))
                {
                    // OLE controls
                    text = g_settings.strAtlAxWin;
                }
                else
                {
                    text = m_vecControls[nID];
                }
                StringCchCopyW(ttt->szText, _countof(ttt->szText), text.c_str());
            }
        }
        return 0;
    }

    virtual INT_PTR CALLBACK
    DialogProcDx(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
    {
        switch (uMsg)
        {
            HANDLE_MSG(hwnd, WM_INITDIALOG, OnInitDialog);
            HANDLE_MSG(hwnd, WM_COMMAND, OnCommand);
            HANDLE_MSG(hwnd, WM_NOTIFY, OnNotify);
        }
        return DefaultProcDx();
    }
};

```

`src/MAddCursorDlg.hpp`:

```hpp
// MAddCursorDlg.hpp --- "Add Cursor" Dialog
//////////////////////////////////////////////////////////////////////////////
// RisohEditor --- Another free Win32 resource editor
// Copyright (C) 2017-2018 Katayama Hirofumi MZ <katayama.hirofumi.mz@gmail.com>
// 
// This program is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
// 
// This program is distributed in the hope that it will be useful, 
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
// 
// You should have received a copy of the GNU General Public License
// along with this program.  If not, see <http://www.gnu.org/licenses/>.
//////////////////////////////////////////////////////////////////////////////

#pragma once

#include "resource.h"
#include "MWindowBase.hpp"
#include "ConstantsDB.hpp"
#include "Res.hpp"
#include "MComboBoxAutoComplete.hpp"
#include "MLangAutoComplete.hpp"
#include "Common.hpp"

//////////////////////////////////////////////////////////////////////////////

class MAddCursorDlg : public MDialogBase
{
public:
    LPCWSTR   m_file;
    HCURSOR   m_hCursor;
    MIdOrString m_type;
    MIdOrString m_name;
    WORD m_lang;
    MComboBoxAutoComplete m_cmb2;
    MComboBoxAutoComplete m_cmb3;
    MLangAutoComplete *m_pAutoComplete;

    MAddCursorDlg()
        : MDialogBase(IDD_ADDCURSOR)
        , m_file(NULL)
        , m_pAutoComplete(new MLangAutoComplete())
    {
        m_pAutoComplete->AddRef();
        m_hCursor = NULL;
        m_cmb3.m_bAcceptSpace = TRUE;
    }

    ~MAddCursorDlg()
    {
        m_pAutoComplete->unbind();
        m_pAutoComplete->Release();
        m_pAutoComplete = NULL;
        DestroyCursor(m_hCursor);
    }

    BOOL OnInitDialog(HWND hwnd, HWND hwndFocus, LPARAM lParam)
    {
        SetDlgItemTextW(hwnd, edt1, m_file);
        if (m_hCursor)
            DestroyCursor(m_hCursor);
        m_hCursor = LoadCursorFromFile(m_file);
        SendDlgItemMessage(hwnd, ico1, STM_SETIMAGE, IMAGE_CURSOR, LPARAM(m_hCursor));

        DragAcceptFiles(hwnd, TRUE);

        // for Names
        HWND hCmb2 = GetDlgItem(hwnd, cmb2);
        InitResNameComboBox(hCmb2, L"", IDTYPE_CURSOR);
        SetWindowText(hCmb2, L"");
        SubclassChildDx(m_cmb2, cmb2);

        // for Langs
        HWND hCmb3 = GetDlgItem(hwnd, cmb3);
        InitLangComboBox(hCmb3, GetThreadUILanguage());
        SubclassChildDx(m_cmb3, cmb3);

        // auto complete
        COMBOBOXINFO info = { sizeof(info) };
        GetComboBoxInfo(m_cmb3, &info);
        HWND hwndEdit = info.hwndItem;
        m_pAutoComplete->bind(hwndEdit);

        CenterWindowDx();

        if (m_file)
        {
            SetFocus(hCmb2);
            return FALSE;
        }
        return TRUE;
    }

    void OnOK(HWND hwnd)
    {
        MIdOrString type = RT_GROUP_CURSOR;

        MIdOrString name;
        HWND hCmb2 = GetDlgItem(hwnd, cmb2);
        if (!CheckNameComboBox(hCmb2, name))
            return;

        HWND hCmb3 = GetDlgItem(hwnd, cmb3);
        WORD lang;
        if (!CheckLangComboBox(hCmb3, lang))
            return;

        std::wstring file;
        HWND hEdt1 = GetDlgItem(hwnd, edt1);
        if (!Edt1_CheckFile(hEdt1, file))
        {
            Edit_SetSel(hEdt1, 0, -1);  // select all
            SetFocus(hEdt1);    // set focus
            ErrorBoxDx(IDS_FILENOTFOUND);
            return;
        }

        BOOL bAni = FALSE;
        size_t ich = file.find(L'.');
        if (ich != std::wstring::npos && lstrcmpiW(&file[ich], L".ani") == 0)
            bAni = TRUE;

        if (auto entry = g_res.find(ET_LANG, (bAni ? RT_ANICURSOR : RT_GROUP_CURSOR), name, lang))
        {
            INT id = MsgBoxDx(IDS_EXISTSOVERWRITE, MB_ICONINFORMATION | MB_YESNOCANCEL);
            switch (id)
            {
            case IDYES:
                g_res.delete_entry(entry);
                break;
            case IDNO:
            case IDCANCEL:
                return;
            }
        }

        if (!bAni)
        {
            MByteStream bs;
            if (bs.LoadFromFile(file.c_str()) && bs.size() >= 4)
            {
                if (memcmp(bs.ptr(), "RIFF", 4) == 0)
                    bAni = TRUE;
            }
        }

        if (bAni)
        {
            type = RT_ANICURSOR;
            MByteStream bs;
            if (!bs.LoadFromFile(file.c_str()) ||
                !g_res.add_lang_entry(type, name, lang, bs.data()))
            {
                ErrorBoxDx(IDS_CANNOTADDCUR);
                return;
            }
        }
        else
        {
            if (!g_res.add_group_cursor(name, lang, file))
            {
                ErrorBoxDx(IDS_CANNOTADDCUR);
                return;
            }
        }

        m_type = type;
        m_name = name;
        m_lang = lang;

        EndDialog(IDOK);
    }

    void OnPsh1(HWND hwnd)
    {
        MStringW strFile = GetDlgItemText(edt1);
        mstr_trim(strFile);

        WCHAR szFile[MAX_PATH];
        lstrcpynW(szFile, strFile.c_str(), _countof(szFile));

        OPENFILENAMEW ofn;
        ZeroMemory(&ofn, sizeof(ofn));
        ofn.lStructSize = OPENFILENAME_SIZE_VERSION_400W;
        ofn.hwndOwner = hwnd;
        ofn.lpstrFilter = MakeFilterDx(LoadStringDx(IDS_CURFILTER));
        ofn.lpstrFile = szFile;
        ofn.nMaxFile = _countof(szFile);
        ofn.lpstrTitle = LoadStringDx(IDS_ADDCUR);
        ofn.Flags = OFN_ENABLESIZING | OFN_EXPLORER | OFN_FILEMUSTEXIST |
            OFN_HIDEREADONLY | OFN_PATHMUSTEXIST;
        ofn.lpstrDefExt = L"cur";
        if (GetOpenFileNameW(&ofn))
        {
            SetDlgItemTextW(hwnd, edt1, szFile);
            if (m_hCursor)
                DestroyCursor(m_hCursor);
            m_hCursor = LoadCursorFromFile(szFile);
            SendDlgItemMessage(hwnd, ico1, STM_SETIMAGE, IMAGE_CURSOR, LPARAM(m_hCursor));
        }
    }

    void OnCommand(HWND hwnd, int id, HWND hwndCtl, UINT codeNotify)
    {
        switch (id)
        {
        case IDOK:
            OnOK(hwnd);
            break;
        case IDCANCEL:
            EndDialog(IDCANCEL);
            break;
        case psh1:
            OnPsh1(hwnd);
            break;
        case psh2:
            OnPsh2(hwnd);
            break;
        case cmb2:
            if (codeNotify == CBN_EDITCHANGE)
            {
                m_cmb2.OnEditChange();
            }
            break;
        case cmb3:
            if (codeNotify == CBN_EDITCHANGE)
            {
                m_cmb3.OnEditChange();
            }
            break;
        }
    }

    void OnPsh2(HWND hwnd)
    {
        SendMessage(GetParent(hwnd), WM_COMMAND, ID_IDLIST, 0);
    }

    void OnDropFiles(HWND hwnd, HDROP hdrop)
    {
        WCHAR file[MAX_PATH];
        DragQueryFileW(hdrop, 0, file, _countof(file));
        SetDlgItemTextW(hwnd, edt1, file);

        if (m_hCursor)
            DestroyCursor(m_hCursor);
        m_hCursor = LoadCursorFromFile(file);
        SendDlgItemMessage(hwnd, ico1, STM_SETIMAGE, IMAGE_CURSOR, LPARAM(m_hCursor));
    }

    virtual INT_PTR CALLBACK
    DialogProcDx(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
    {
        switch (uMsg)
        {
            HANDLE_MSG(hwnd, WM_INITDIALOG, OnInitDialog);
            HANDLE_MSG(hwnd, WM_DROPFILES, OnDropFiles);
            HANDLE_MSG(hwnd, WM_COMMAND, OnCommand);
        }
        return 0;
    }
};

```

`src/MAddIconDlg.hpp`:

```hpp
// MAddIconDlg.hpp --- "Add Icon" Dialog
//////////////////////////////////////////////////////////////////////////////
// RisohEditor --- Another free Win32 resource editor
// Copyright (C) 2017-2018 Katayama Hirofumi MZ <katayama.hirofumi.mz@gmail.com>
// 
// This program is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
// 
// This program is distributed in the hope that it will be useful, 
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
// 
// You should have received a copy of the GNU General Public License
// along with this program.  If not, see <http://www.gnu.org/licenses/>.
//////////////////////////////////////////////////////////////////////////////

#pragma once

#include "resource.h"
#include "MWindowBase.hpp"
#include "ConstantsDB.hpp"
#include "Res.hpp"
#include "MComboBoxAutoComplete.hpp"
#include "MLangAutoComplete.hpp"
#include "Common.hpp"

//////////////////////////////////////////////////////////////////////////////

class MAddIconDlg : public MDialogBase
{
public:
    LPCWSTR m_file;
    HICON   m_hIcon;
    MIdOrString m_type;
    MIdOrString m_name;
    WORD m_lang;
    MComboBoxAutoComplete m_cmb2;
    MComboBoxAutoComplete m_cmb3;
    MLangAutoComplete *m_pAutoComplete;

    MAddIconDlg()
        : MDialogBase(IDD_ADDICON)
        , m_file(NULL)
        , m_hIcon(NULL)
        , m_pAutoComplete(new MLangAutoComplete())
    {
        m_pAutoComplete->AddRef();
        m_cmb3.m_bAcceptSpace = TRUE;
    }

    ~MAddIconDlg()
    {
        m_pAutoComplete->unbind();
        m_pAutoComplete->Release();
        m_pAutoComplete = NULL;
        DestroyIcon(m_hIcon);
    }

    BOOL OnInitDialog(HWND hwnd, HWND hwndFocus, LPARAM lParam)
    {
        SetDlgItemTextW(hwnd, edt1, m_file);
        if (m_hIcon)
            DestroyIcon(m_hIcon);
        m_hIcon = ExtractIcon(GetModuleHandle(NULL), m_file, 0);
        Static_SetIcon(GetDlgItem(hwnd, ico1), m_hIcon);

        DragAcceptFiles(hwnd, TRUE);

        // for Names
        HWND hCmb2 = GetDlgItem(hwnd, cmb2);
        InitResNameComboBox(hCmb2, L"", IDTYPE_ICON);
        SetWindowText(hCmb2, L"");
        SubclassChildDx(m_cmb2, cmb2);

        // for Langs
        HWND hCmb3 = GetDlgItem(hwnd, cmb3);
        InitLangComboBox(hCmb3, GetThreadUILanguage());
        SubclassChildDx(m_cmb3, cmb3);

        CenterWindowDx();

        // auto complete
        COMBOBOXINFO info = { sizeof(info) };
        GetComboBoxInfo(m_cmb3, &info);
        HWND hwndEdit = info.hwndItem;
        m_pAutoComplete->bind(hwndEdit);

        if (m_file)
        {
            SetFocus(hCmb2);
            return FALSE;
        }
        return TRUE;
    }

    virtual INT_PTR CALLBACK
    DialogProcDx(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
    {
        switch (uMsg)
        {
            HANDLE_MSG(hwnd, WM_INITDIALOG, OnInitDialog);
            HANDLE_MSG(hwnd, WM_DROPFILES, OnDropFiles);
            HANDLE_MSG(hwnd, WM_COMMAND, OnCommand);
        }
        return DefaultProcDx();
    }

    void OnOK(HWND hwnd)
    {
        MIdOrString type = RT_GROUP_ICON;

        MIdOrString name;
        HWND hCmb2 = GetDlgItem(hwnd, cmb2);
        if (!CheckNameComboBox(hCmb2, name))
            return;

        HWND hCmb3 = GetDlgItem(hwnd, cmb3);
        WORD lang;
        if (!CheckLangComboBox(hCmb3, lang))
            return;

        std::wstring file;
        HWND hEdt1 = GetDlgItem(hwnd, edt1);
        if (!Edt1_CheckFile(hEdt1, file))
        {
            Edit_SetSel(hEdt1, 0, -1);  // select all
            SetFocus(hEdt1);    // set focus
            ErrorBoxDx(IDS_FILENOTFOUND);
            return;
        }

        if (auto entry = g_res.find(ET_LANG, RT_GROUP_ICON, name, lang))
        {
            INT id = MsgBoxDx(IDS_EXISTSOVERWRITE, MB_ICONINFORMATION | MB_YESNOCANCEL);
            switch (id)
            {
            case IDYES:
                g_res.delete_entry(entry);
                break;
            case IDNO:
            case IDCANCEL:
                return;
            }
        }

        if (!g_res.add_group_icon(name, lang, file))
        {
            ErrorBoxDx(IDS_CANNOTADDICON);
            return;
        }

        m_type = type;
        m_name = name;
        m_lang = lang;

        EndDialog(IDOK);
    }

    void OnPsh1(HWND hwnd)
    {
        MStringW strFile = GetDlgItemText(edt1);
        mstr_trim(strFile);

        WCHAR szFile[MAX_PATH];
        lstrcpynW(szFile, strFile.c_str(), _countof(szFile));

        OPENFILENAMEW ofn;
        ZeroMemory(&ofn, sizeof(ofn));
        ofn.lStructSize = OPENFILENAME_SIZE_VERSION_400W;
        ofn.hwndOwner = hwnd;
        ofn.lpstrFilter = MakeFilterDx(LoadStringDx(IDS_ICOFILTER));
        ofn.lpstrFile = szFile;
        ofn.nMaxFile = _countof(szFile);
        ofn.lpstrTitle = LoadStringDx(IDS_ADDICON);
        ofn.Flags = OFN_ENABLESIZING | OFN_EXPLORER | OFN_FILEMUSTEXIST |
            OFN_HIDEREADONLY | OFN_PATHMUSTEXIST;
        ofn.lpstrDefExt = L"ico";
        if (GetOpenFileNameW(&ofn))
        {
            SetDlgItemTextW(hwnd, edt1, szFile);
            if (m_hIcon)
                DestroyIcon(m_hIcon);
            m_hIcon = ExtractIcon(GetModuleHandle(NULL), szFile, 0);
            Static_SetIcon(GetDlgItem(hwnd, ico1), m_hIcon);
        }
    }

    void OnPsh2(HWND hwnd)
    {
        SendMessage(GetParent(hwnd), WM_COMMAND, ID_IDLIST, 0);
    }

    void OnCommand(HWND hwnd, int id, HWND hwndCtl, UINT codeNotify)
    {
        switch (id)
        {
        case IDOK:
            OnOK(hwnd);
            break;
        case IDCANCEL:
            EndDialog(IDCANCEL);
            break;
        case psh1:
            OnPsh1(hwnd);
            break;
        case psh2:
            OnPsh2(hwnd);
            break;
        case cmb2:
            if (codeNotify == CBN_EDITCHANGE)
            {
                m_cmb2.OnEditChange();
            }
            break;
        case cmb3:
            if (codeNotify == CBN_EDITCHANGE)
            {
                m_cmb3.OnEditChange();
            }
            break;
        }
    }

    void OnDropFiles(HWND hwnd, HDROP hdrop)
    {
        WCHAR file[MAX_PATH];
        DragQueryFileW(hdrop, 0, file, _countof(file));
        SetDlgItemTextW(hwnd, edt1, file);

        if (m_hIcon)
            DestroyIcon(m_hIcon);
        m_hIcon = ExtractIcon(GetModuleHandle(NULL), file, 0);
        Static_SetIcon(GetDlgItem(hwnd, ico1), m_hIcon);
    }
};

```

`src/MAddResDlg.hpp`:

```hpp
// MAddResDlg.hpp --- "Add Resource" Dialog
//////////////////////////////////////////////////////////////////////////////
// RisohEditor --- Another free Win32 resource editor
// Copyright (C) 2017-2018 Katayama Hirofumi MZ <katayama.hirofumi.mz@gmail.com>
// 
// This program is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
// 
// This program is distributed in the hope that it will be useful, 
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
// 
// You should have received a copy of the GNU General Public License
// along with this program.  If not, see <http://www.gnu.org/licenses/>.
//////////////////////////////////////////////////////////////////////////////

#pragma once

#include "resource.h"
#include "MWindowBase.hpp"
#include "ConstantsDB.hpp"
#include "Res.hpp"
#include "MComboBoxAutoComplete.hpp"
#include "DlgInit.h"
#include "MLangAutoComplete.hpp"
#include "Common.hpp"

//////////////////////////////////////////////////////////////////////////////

class MAddResDlg : public MDialogBase
{
public:
    MIdOrString m_type;
    MIdOrString m_name;
    WORD m_lang;
    MStringW m_strTemplate;
    LPCTSTR m_file;
    MStringW m_strText;
    MComboBoxAutoComplete m_cmb1;
    MComboBoxAutoComplete m_cmb2;
    MComboBoxAutoComplete m_cmb3;
    MLangAutoComplete *m_pAutoComplete;

    MAddResDlg()
        : MDialogBase(IDD_ADDRES)
        , m_type(0xFFFF)
        , m_file(NULL)
        , m_pAutoComplete(new MLangAutoComplete())
    {
        m_pAutoComplete->AddRef();
        m_cmb3.m_bAcceptSpace = TRUE;
    }

    ~MAddResDlg()
    {
        m_pAutoComplete->unbind();
        m_pAutoComplete->Release();
        m_pAutoComplete = NULL;
    }

    BOOL OnInitDialog(HWND hwnd, HWND hwndFocus, LPARAM lParam)
    {
        // accept file dropping
        DragAcceptFiles(hwnd, TRUE);

        // for Types
        HWND hCmb1 = GetDlgItem(hwnd, cmb1);
        InitResTypeComboBox(hCmb1, m_type);

        // enable input complete
        SubclassChildDx(m_cmb1, cmb1);
        SubclassChildDx(m_cmb2, cmb2);

        InitComboBoxPlaceholder(m_cmb2, IDS_INTEGERORIDENTIFIER);

        // set 1 to the name if it's a RT_VERSION
        if (m_type == RT_VERSION)
        {
            SetDlgItemInt(hwnd, cmb2, 1, FALSE);
        }

        // for Langs
        HWND hCmb3 = GetDlgItem(hwnd, cmb3);
        InitLangComboBox(hCmb3, GetThreadUILanguage());
        SubclassChildDx(m_cmb3, cmb3);

        // for file
        if (m_file)
        {
            SetDlgItemTextW(hwnd, edt1, m_file);
        }

        // do centering the dialog
        CenterWindowDx();

        // move focus to help the user input
        if (m_type == 0xFFFF)
        {
            SetFocus(GetDlgItem(hwnd, cmb1));
        }
        else
        {
            SetFocus(GetDlgItem(hwnd, cmb2));
        }

        // select the type
        OnCmb1(hwnd);

        // auto complete
        COMBOBOXINFO info = { sizeof(info) };
        GetComboBoxInfo(m_cmb3, &info);
        HWND hwndEdit = info.hwndItem;
        m_pAutoComplete->bind(hwndEdit);

        return FALSE;
    }

    bool HasSample(const MIdOrString& type, WORD wLang) const
    {
        return !GetRisohTemplate(type, wLang).empty();
    }

    void OnOK(HWND hwnd)
    {
        MIdOrString type;

        // cmb1 --> (iType, type)
        auto table = g_db.GetTable(L"RESOURCE");
        INT iType = ComboBox_GetCurSel(m_cmb1);
        if (iType != CB_ERR && iType < INT(table.size()))
        {
            type = WORD(table[iType].value);
        }
        else
        {
            if (!CheckTypeComboBox(m_cmb1, type))
            {
                return;
            }
        }

        if (type == RT_STRING)
        {
            // edt1 --> sz (trimmed)
            WCHAR sz[16];
            GetDlgItemTextW(hwnd, edt1, sz, _countof(sz));
            mstr_trim(sz);

            // clear the name if sz is empty
            if (sz[0] == 0)
                SetDlgItemTextW(hwnd, cmb2, NULL);
        }
        if (type == RT_MESSAGETABLE)
        {
            // edt1 --> sz (trimmed)
            WCHAR sz[16];
            GetDlgItemTextW(hwnd, edt1, sz, _countof(sz));
            mstr_trim(sz);

            // clear the name if sz is empty
            if (sz[0] == 0)
                SetDlgItemTextW(hwnd, cmb2, NULL);
        }

        // if RT_VERSION, the name is one
        if (type == RT_VERSION)
        {
            SetDlgItemTextW(hwnd, cmb2, L"1");
        }

        // check the name combobox cmb2
        HWND hCmb2 = GetDlgItem(hwnd, cmb2);
        MIdOrString name;
        if (!Res_HasNoName(type) && !CheckNameComboBox(hCmb2, name))
            return;     // failure

        // check the language combobox cmb3
        HWND hCmb3 = GetDlgItem(hwnd, cmb3);
        WORD lang;
        if (!CheckLangComboBox(hCmb3, lang))
            return;     // failure

        // get the file path from edt1
        std::wstring file;
        HWND hEdt1 = GetDlgItem(hwnd, edt1);

        // if there is no sample for the type, check if the file path exists
        if (!Edt1_CheckFile(hEdt1, file) && !HasSample(type, lang))
        {
            Edit_SetSel(hEdt1, 0, -1);  // select all
            SetFocus(hEdt1);    // set focus
            ErrorBoxDx(IDS_FILENOTFOUND);
            return;     // failure
        }

        // find the language entry by type, name, lang
        if (g_res.find(ET_LANG, type, name, lang))
        {
            // query overwriting
            INT id = MsgBoxDx(IDS_EXISTSOVERWRITE, MB_ICONINFORMATION | MB_YESNOCANCEL);
            switch (id)
            {
            case IDYES:
                // delete the overlapped entries
                g_res.search_and_delete(ET_LANG, type, name, lang);
                break;

            case IDNO:
            case IDCANCEL:
                return;     // cancelled
            }
        }

        bool bTemplateToAdd = false;
        bool bAdded = false;

        // if there is sample and no file was specified, then
        if (file.empty() && HasSample(type, lang))
        {
            bTemplateToAdd = true;     // assume OK

            if (Res_HasNoName(type))
            {
                // if this type has no name, clear the related entries
                g_res.search_and_delete(ET_NAME, type, (WORD)0, lang);
            }

            if (HasSample(type, lang))
            {
                // if the type has sample, then store the template text
                m_strText = GetRisohTemplate(type, lang);
            }
            else
            {
                // otherwise it's not OK
                bTemplateToAdd = false;
            }

            // set one to the name if it's RT_STRING or RT_MESSAGETABLE
            if (type == RT_STRING || type == RT_MESSAGETABLE)
            {
                name = 1;   // it will be fixed later
            }

            if (bTemplateToAdd)    // it's OK
            {
                // add an empty entry (data will be set later)
                g_res.add_lang_entry(type, name, lang);
                bAdded = true;

                // store the results
                m_type = type;
                m_name = name;
                m_lang = lang;
                m_strTemplate = m_strText;  // the template text
            }
        }

        // try to load the file if not OK
        MByteStreamEx bs;
        if (!bTemplateToAdd && !bs.LoadFromFile(file.c_str()))
        {
            // error
            ErrorBoxDx(IDS_CANNOTADDRES);
            return;
        }

        // if not added yet, then
        if (!bAdded)
        {
            // add the data from the file
            g_res.add_lang_entry(type, name, lang, bs.data());

            // store the results
            m_type = type;
            m_name = name;
            m_lang = lang;
            m_strTemplate.clear();  // no template text
        }

        // finish the dialog
        EndDialog(IDOK);
    }

    void OnPsh1(HWND hwnd)  // "browse"
    {
        // get the text (trimmed)
        MStringW strFile = GetDlgItemText(edt1);
        mstr_trim(strFile);

        // strFile --> szFile
        WCHAR szFile[MAX_PATH];
        StringCchCopyW(szFile, _countof(szFile), strFile.c_str());

        // initialize OPENFILENAME structure
        OPENFILENAMEW ofn;
        ZeroMemory(&ofn, sizeof(ofn));
        ofn.lStructSize = OPENFILENAME_SIZE_VERSION_400W;
        ofn.hwndOwner = hwnd;
        ofn.lpstrFilter = MakeFilterDx(LoadStringDx(IDS_ALLFILES));
        ofn.lpstrFile = szFile;
        ofn.nMaxFile = _countof(szFile);
        ofn.lpstrTitle = LoadStringDx(IDS_ADDRES);
        ofn.Flags = OFN_ENABLESIZING | OFN_EXPLORER | OFN_FILEMUSTEXIST |
                    OFN_HIDEREADONLY | OFN_PATHMUSTEXIST;
        ofn.lpstrDefExt = L"bin";   // the default extension
        if (GetOpenFileNameW(&ofn)) // "OK" button was pressed
        {
            // set the file path
            SetDlgItemTextW(hwnd, edt1, szFile);
        }
    }

    void OnPsh2(HWND hwnd)
    {
        // show the ID list window
        SendMessage(GetParent(hwnd), WM_COMMAND, ID_IDLIST, 0);
    }

    void OnCmb1(HWND hwnd)
    {
        // get the text of combobox cmb1
        TCHAR szText[256];
        INT iItem = ComboBox_GetCurSel(m_cmb1);
        if (iItem == CB_ERR)
        {
            ComboBox_GetText(m_cmb1, szText, ARRAYSIZE(szText));
        }
        else
        {
            ComboBox_GetLBText(m_cmb1, iItem, szText);
        }

        // szText --> strIDType (trimmed)
        MString strIDType = szText;
        mstr_trim(strIDType);

        // cut off the text from " (" to end
        size_t k = strIDType.find(L" (");
        if (k != MString::npos)
        {
            strIDType = strIDType.substr(0, k);
        }

        // the resource type (RT_*) --> (type, iType)
        MIdOrString type;
        WORD nRT_ = (WORD)g_db.GetValue(L"RESOURCE", strIDType);
        INT iType = g_db.IDTypeFromResType(nRT_);
        if (nRT_ != 0)
        {
            type = nRT_;
            if (iType == IDTYPE_UNKNOWN)
            {
                iType = IDTYPE_RESOURCE;
            }
        }
        else if (iType != IDTYPE_UNKNOWN && nRT_ != 0)
        {
            type = nRT_;
        }
        else
        {
            type.m_str = std::move(strIDType);
        }

        if (HasSample(type, m_lang))
        {
            // if there is a sample for this type, the file path is optional
            SetDlgItemText(hwnd, stc2, LoadStringDx(IDS_OPTIONAL));
        }
        else
        {
            // the file path is non-optional
            SetDlgItemText(hwnd, stc2, NULL);
        }

        if (type == RT_STRING || type == RT_MESSAGETABLE || type == RT_VERSION)
        {
            // the name is optional if RT_STRING, RT_MESSAGETABLE or RT_VERSION
            SetDlgItemText(hwnd, stc1, LoadStringDx(IDS_OPTIONAL));
            InitComboBoxPlaceholder(m_cmb2, IDS_NOTEXT);
        }
        else
        {
            // otherwise the name is non-optional
            SetDlgItemText(hwnd, stc1, NULL);
            InitComboBoxPlaceholder(m_cmb2, IDS_INTEGERORIDENTIFIER);
        }

        // iType (IDTYPE_*) --> prefix
        MString prefix = g_db.GetName(L"RESOURCE.ID.PREFIX", iType);
        if (prefix.empty())
            return;

        // prefix --> m_cmb2
        ComboBox_ResetContent(m_cmb2);
        if (type != RT_STRING && type != RT_MESSAGETABLE)
        {
            auto table = g_db.GetTableByPrefix(L"RESOURCE.ID", prefix);
            for (auto& table_entry : table)
            {
                ComboBox_AddString(m_cmb2, table_entry.name.c_str());
            }
        }
    }

    void OnCommand(HWND hwnd, int id, HWND hwndCtl, UINT codeNotify)
    {
        switch (id)
        {
        case IDOK:
            OnOK(hwnd);
            break;

        case IDCANCEL:
            // cancel the dialog
            EndDialog(IDCANCEL);
            break;

        case psh1:      // browse
            OnPsh1(hwnd);
            break;

        case psh2:      // show the resource ID list
            OnPsh2(hwnd);
            break;

        case cmb1:
            if (codeNotify == CBN_SELCHANGE)
            {
                // selection of cmb1 was changed
                OnCmb1(hwnd);
            }
            else if (codeNotify == CBN_EDITCHANGE)
            {
                // the text of cmb1 was changed
                m_cmb1.OnEditChange();  // input completion
                OnCmb1(hwnd);
            }
            break;

        case cmb2:
            if (codeNotify == CBN_EDITCHANGE)
            {
                m_cmb2.OnEditChange();  // input completion
            }
            break;

        case cmb3:
            if (codeNotify == CBN_EDITCHANGE)
            {
                m_cmb3.OnEditChange();  // input completion
            }
            break;
        }
    }

    void OnDropFiles(HWND hwnd, HDROP hdrop)
    {
        // file(s) has dropped
        WCHAR file[MAX_PATH];
        DragQueryFileW(hdrop, 0, file, _countof(file));
        SetDlgItemTextW(hwnd, edt1, file);
    }

    virtual INT_PTR CALLBACK
    DialogProcDx(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
    {
        switch (uMsg)
        {
            HANDLE_MSG(hwnd, WM_INITDIALOG, OnInitDialog);
            HANDLE_MSG(hwnd, WM_DROPFILES, OnDropFiles);
            HANDLE_MSG(hwnd, WM_COMMAND, OnCommand);
        }
        return DefaultProcDx();
    }
};

```

`src/MAddResIDDlg.hpp`:

```hpp
// MAddResIDDlg.hpp --- "Add Resource ID" Dialog
//////////////////////////////////////////////////////////////////////////////
// RisohEditor --- Another free Win32 resource editor
// Copyright (C) 2017-2018 Katayama Hirofumi MZ <katayama.hirofumi.mz@gmail.com>
// 
// This program is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
// 
// This program is distributed in the hope that it will be useful, 
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
// 
// You should have received a copy of the GNU General Public License
// along with this program.  If not, see <http://www.gnu.org/licenses/>.
//////////////////////////////////////////////////////////////////////////////

#pragma once

#include "resource.h"
#include "MWindowBase.hpp"
#include "ConstantsDB.hpp"
#include "Res.hpp"
#include "RisohSettings.hpp"
#include "Common.hpp"

//////////////////////////////////////////////////////////////////////////////

class MAddResIDDlg : public MDialogBase
{
public:
    MString m_str1;
    MString m_str2;
    BOOL m_bChanging;

    MAddResIDDlg() : MDialogBase(IDD_ADDRESID)
    {
        m_bChanging = FALSE;
    }

    BOOL OnInitDialog(HWND hwnd, HWND hwndFocus, LPARAM lParam)
    {
        ConstantsDB::TableType table;
        table = g_db.GetTable(L"RESOURCE.ID.TYPE");

        const INT IDTYPE_default = IDTYPE_COMMAND;

        INT i = 0;
        for (auto& table_entry : table)
        {
            INT k = (INT)SendDlgItemMessage(hwnd, cmb1, CB_ADDSTRING, 0, (LPARAM)table_entry.name.c_str());
            if (k == IDTYPE_default)
            {
                m_bChanging = TRUE;
                SendDlgItemMessage(hwnd, cmb1, CB_SETCURSEL, k, 0);
                m_bChanging = FALSE;
            }
            ++i;
        }

        table = g_db.GetTable(L"RESOURCE.ID.PREFIX");
        m_bChanging = TRUE;
        SetDlgItemTextW(hwnd, edt1, table[IDTYPE_default].name.c_str());
        m_bChanging = FALSE;

        SendDlgItemMessage(hwnd, scr1, UDM_SETRANGE, 0,
                           MAKELPARAM((WORD)SHRT_MAX, (WORD)SHRT_MIN));

        CenterWindowDx();
        return TRUE;
    }

    void OnOK(HWND hwnd)
    {
        MString str1 = GetDlgItemText(hwnd, edt1);
        ReplaceFullWithHalf(str1);
        mstr_trim(str1);
        if (str1.empty())
        {
            HWND hEdt1 = GetDlgItem(hwnd, edt1);
            Edit_SetSel(hEdt1, 0, -1);
            SetFocus(hEdt1);
            ErrorBoxDx(IDS_ENTERTEXT);
            return;
        }
        m_str1 = str1;

        MString str2 = GetDlgItemText(hwnd, edt2);
        ReplaceFullWithHalf(str2);
        mstr_trim(str2);
        if (str2.empty())
        {
            HWND hEdt2 = GetDlgItem(hwnd, edt2);
            Edit_SetSel(hEdt2, 0, -1);
            SetFocus(hEdt2);
            ErrorBoxDx(IDS_ENTERINT);
            return;
        }
        m_str2 = std::move(str2);

        MStringA str1a = MTextToAnsi(CP_ACP, str1).c_str();
        if (g_settings.id_map.find(str1a) != g_settings.id_map.end())
        {
            HWND hEdt1 = GetDlgItem(hwnd, edt1);
            Edit_SetSel(hEdt1, 0, -1);
            SetFocus(hEdt1);
            ErrorBoxDx(IDS_ALREADYEXISTS);
            return;
        }

        EndDialog(IDOK);
    }

    void OnCommand(HWND hwnd, int id, HWND hwndCtl, UINT codeNotify)
    {
        switch (id)
        {
        case IDOK:
            OnOK(hwnd);
            break;
        case IDCANCEL:
            EndDialog(IDCANCEL);
            break;
        case edt1:
            if (codeNotify == EN_CHANGE && !m_bChanging)
            {
                MString name = GetDlgItemText(hwnd, edt1);
                mstr_trim(name);

                MString prefix = name.substr(0, name.find(L'_') + 1);

                std::vector<INT> indexes;
                indexes = GetPrefixIndexes(prefix);
                if (indexes.empty() || indexes.size() >= 2)
                {
                    m_bChanging = TRUE;
                    SendDlgItemMessage(hwnd, cmb1, CB_SETCURSEL, -1, 0);
                    m_bChanging = FALSE;
                    break;
                }

                ConstantsDB::TableType table;
                table = g_db.GetTable(L"RESOURCE.ID.PREFIX");

                m_bChanging = TRUE;
                SendDlgItemMessage(hwnd, cmb1, CB_SETCURSEL, indexes[0], 0);
                m_bChanging = FALSE;
            }
            break;
        case cmb1:
            if (codeNotify == CBN_SELCHANGE && !m_bChanging)
            {
                HWND hCmb1 = GetDlgItem(hwnd, cmb1);
                INT k = INT(SendMessage(hCmb1, CB_GETCURSEL, 0, 0));
                if (k != -1)
                {
                    ConstantsDB::TableType table;
                    table = g_db.GetTable(L"RESOURCE.ID.PREFIX");

                    m_bChanging = TRUE;
                    SetDlgItemText(hwnd, edt1, table[k].name.c_str());
                    m_bChanging = FALSE;
                }
            }
            break;
        case psh1:
            {
                SetDlgItemTextW(hwnd, edt2, NULL);

                MString name = GetDlgItemText(hwnd, edt1);
                mstr_trim(name);

                MString prefix = name.substr(0, name.find(L'_') + 1);
                if (prefix.size())
                {
                    ConstantsDB::TableType table;
                    table = g_db.GetTableByPrefix(L"RESOURCE.ID", prefix);

                    UINT nMax = 0;
                    for (auto& table_entry : table)
                    {
                        if (table_entry.name == L"IDC_STATIC")
                            continue;
                        if (nMax < table_entry.value)
                            nMax = table_entry.value;
                    }

                    INT nIDTYPE_ = IDTYPE_UNKNOWN;
                    for (auto& pair : g_settings.assoc_map)
                    {
                        if (pair.second == prefix)
                        {
                            nIDTYPE_ = INT(g_db.GetValue(L"RESOURCE.ID.TYPE", pair.first));
                            break;
                        }
                    }

                    INT nNextID = nMax + 1;

                    switch (nIDTYPE_)
                    {
                    case IDTYPE_UNKNOWN:
                    case IDTYPE_MESSAGE:
                    case IDTYPE_WINDOW:
                        break;
                    default:
                        if (nNextID < 100)
                            nNextID = 100;
                        break;
                    }

                    SetDlgItemInt(hwnd, edt2, nNextID, TRUE);
                }
            }
            break;
        }
    }

    virtual INT_PTR CALLBACK
    DialogProcDx(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
    {
        switch (uMsg)
        {
            HANDLE_MSG(hwnd, WM_INITDIALOG, OnInitDialog);
            HANDLE_MSG(hwnd, WM_COMMAND, OnCommand);
        }
        return DefaultProcDx();
    }
};

```

`src/MAdviceResHDlg.hpp`:

```hpp
// MAdviceResHDlg.hpp --- "Advice about Resource ID" Dialog
//////////////////////////////////////////////////////////////////////////////
// RisohEditor --- Another free Win32 resource editor
// Copyright (C) 2017-2018 Katayama Hirofumi MZ <katayama.hirofumi.mz@gmail.com>
// 
// This program is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
// 
// This program is distributed in the hope that it will be useful, 
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
// 
// You should have received a copy of the GNU General Public License
// along with this program.  If not, see <http://www.gnu.org/licenses/>.
//////////////////////////////////////////////////////////////////////////////

#pragma once

#include "resource.h"
#include "MWindowBase.hpp"
#include "ConstantsDB.hpp"
#include "Res.hpp"
#include "RisohSettings.hpp"

//////////////////////////////////////////////////////////////////////////////

class MAdviceResHDlg : public MDialogBase
{
public:
    MString m_str;

    MAdviceResHDlg(const MString& str) :
        MDialogBase(IDD_ADVICERESH),  m_str(str)
    {
    }

    BOOL OnInitDialog(HWND hwnd, HWND hwndFocus, LPARAM lParam)
    {
        SetDlgItemText(hwnd, edt1, m_str.c_str());

        CenterWindowDx();

        SetFocus(GetDlgItem(hwnd, IDOK));
        return FALSE;
    }

    void OnOK(HWND hwnd)
    {
        EndDialog(IDOK);
    }

    void OnPsh1(HWND hwnd)
    {
        m_str.clear();
        g_settings.added_ids.clear();
        g_settings.removed_ids.clear();
        SetDlgItemText(hwnd, edt1, NULL);
    }

    void OnCommand(HWND hwnd, int id, HWND hwndCtl, UINT codeNotify)
    {
        switch (id)
        {
        case IDOK:
            OnOK(hwnd);
            break;
        case IDCANCEL:
            EndDialog(IDCANCEL);
            break;
        case psh1:
            OnPsh1(hwnd);
            break;
        }
    }

    virtual INT_PTR CALLBACK
    DialogProcDx(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
    {
        switch (uMsg)
        {
            HANDLE_MSG(hwnd, WM_INITDIALOG, OnInitDialog);
            HANDLE_MSG(hwnd, WM_COMMAND, OnCommand);
        }
        return DefaultProcDx();
    }
};

```

`src/MBitmapDx.hpp`:

```hpp
// MBitmapDx.hpp --- GDI+ Bitmap wrapper                        -*- C++ -*-
// This file is part of MZC4.  See file "ReadMe.txt" and "License.txt".
//////////////////////////////////////////////////////////////////////////////

#pragma once

#include <initguid.h>
#ifndef _INC_WINDOWS
    #include <windows.h>
#endif
#include <vector>
#include <gdiplus.h>

#include "PackedDIB.hpp"

class MBitmapDx;

//////////////////////////////////////////////////////////////////////////////

class MBitmapDx
{
public:
    MBitmapDx();
    ~MBitmapDx();

    Gdiplus::Bitmap *GetBitmap() const;
    BOOL SetBitmap(Gdiplus::Bitmap *pBitmap);
    BOOL CreateFromMemory(const void *pvData, DWORD dwSize);

    COLORREF GetBackColor() const;
    void SetBackColor(COLORREF rgbBack);

    UINT GetFrameIndex() const;
    void SetFrameIndex(UINT nIndex);

    UINT GetFrameCount() const;
    UINT GetLoopIndex() const;
    UINT GetLoopCount() const;
    DWORD GetFrameDelay(UINT nFrameIndex) const;

    HBITMAP GetHBITMAP(LONG& cx, LONG& cy);
    HBITMAP GetHBITMAP32(LONG& cx, LONG& cy);

    void Destroy();
    void FreeBitmap();
    void FreeDelayPropertyItem();
    BOOL Step(DWORD& dwDelay);

    UINT GetWidth();
    UINT GetHeight();

protected:
    Gdiplus::Bitmap        *m_pBitmap;
    COLORREF                m_rgbBack;
    UINT                    m_nFrameIndex;
    UINT                    m_nFrameCount;
    UINT                    m_nLoopIndex;
    UINT                    m_nLoopCount;
    Gdiplus::PropertyItem  *m_pDelayItem;
    HGLOBAL                 m_hGlobal;

    BOOL CreateInternal();

private:
    // NOTE: MBitmapDx should not be copyed.
    MBitmapDx(const MBitmapDx&);
    MBitmapDx& operator=(const MBitmapDx&);
};

//////////////////////////////////////////////////////////////////////////////

inline MBitmapDx::MBitmapDx()
{
    m_pBitmap = NULL;
    m_rgbBack = RGB(255, 255, 255);
    m_nFrameIndex = 0;
    m_nFrameCount = 0;
    m_pDelayItem = NULL;
    m_nLoopIndex = 0;
    m_nLoopCount = (UINT)-1;
    m_hGlobal = NULL;
}

inline MBitmapDx::~MBitmapDx()
{
    Destroy();
}

inline void MBitmapDx::FreeBitmap()
{
    if (m_pBitmap)
    {
        delete m_pBitmap;
        m_pBitmap = NULL;
    }
}

inline void MBitmapDx::FreeDelayPropertyItem()
{
    if (m_pDelayItem)
    {
        std::free(m_pDelayItem);
        m_pDelayItem = NULL;
    }
}

inline void MBitmapDx::Destroy()
{
    m_nFrameIndex = 0;
    m_nFrameCount = 0;
    m_nLoopIndex = 0;
    m_nLoopCount = (UINT)-1;

    FreeBitmap();
    FreeDelayPropertyItem();

    if (m_hGlobal)
    {
        GlobalFree(m_hGlobal);
        m_hGlobal = NULL;
    }
}

inline Gdiplus::Bitmap *MBitmapDx::GetBitmap() const
{
    return m_pBitmap;
}

inline COLORREF MBitmapDx::GetBackColor() const
{
    return m_rgbBack;
}

inline void MBitmapDx::SetBackColor(COLORREF rgbBack)
{
    m_rgbBack = rgbBack;
}

inline BOOL MBitmapDx::CreateInternal()
{
    using namespace Gdiplus;
    UINT nDimCount = m_pBitmap->GetFrameDimensionsCount();

    if (nDimCount)
    {
        std::vector<GUID> dims(nDimCount);
        m_pBitmap->GetFrameDimensionsList(&dims[0], nDimCount);
        m_nFrameCount = m_pBitmap->GetFrameCount(&dims[0]);
    }

    UINT cbItem;

    FreeDelayPropertyItem();
    cbItem = m_pBitmap->GetPropertyItemSize(PropertyTagFrameDelay);
    if (cbItem)
    {
        m_pDelayItem = (PropertyItem *)std::malloc(cbItem);
        m_pBitmap->GetPropertyItem(PropertyTagFrameDelay, cbItem, m_pDelayItem);
    }
    else
    {
        m_pDelayItem = NULL;
    }

    m_nLoopIndex = 0;
    m_nLoopCount = (UINT)-1;
    cbItem = m_pBitmap->GetPropertyItemSize(PropertyTagLoopCount);
    if (cbItem)
    {
        PropertyItem *pItem = (PropertyItem *)std::malloc(cbItem);
        if (pItem)
        {
            if (m_pBitmap->GetPropertyItem(PropertyTagLoopCount, cbItem, pItem) == Ok)
            {
                m_nLoopCount = *(WORD *)pItem->value;
            }
            std::free(pItem);
        }
    }

    return TRUE;
}

inline BOOL MBitmapDx::SetBitmap(Gdiplus::Bitmap *pBitmap)
{
    Destroy();

    m_pBitmap = pBitmap;
    return m_pBitmap && CreateInternal();
}

inline BOOL MBitmapDx::CreateFromMemory(const void *pvData, DWORD dwSize)
{
    Destroy();

    Gdiplus::Bitmap *pBitmap = NULL;

    m_hGlobal = GlobalAlloc(GMEM_MOVEABLE, dwSize);
    if (m_hGlobal)
    {
        LPVOID pv = GlobalLock(m_hGlobal);
        if (pv)
        {
            CopyMemory(pv, pvData, dwSize);
            GlobalUnlock(m_hGlobal);
        }

        IStream *pStream = NULL;
        if (CreateStreamOnHGlobal(m_hGlobal, FALSE, &pStream) == S_OK)
        {
            pBitmap = Gdiplus::Bitmap::FromStream(pStream);
            pStream->Release();
        }
    }

    m_pBitmap = pBitmap;
    return m_pBitmap && CreateInternal();
}

inline DWORD MBitmapDx::GetFrameDelay(UINT nFrameIndex) const
{
    if (nFrameIndex < m_nFrameCount && m_pDelayItem)
    {
        return ((DWORD *)m_pDelayItem->value)[m_nFrameIndex] * 10;
    }
    return 0;
}

inline void MBitmapDx::SetFrameIndex(UINT nFrameIndex)
{
    if (nFrameIndex < m_nFrameCount)
    {
        GUID guid = Gdiplus::FrameDimensionTime;
        if (Gdiplus::Ok != m_pBitmap->SelectActiveFrame(&guid, nFrameIndex))
        {
            guid = Gdiplus::FrameDimensionPage;
            m_pBitmap->SelectActiveFrame(&guid, nFrameIndex);
        }
    }
    m_nFrameIndex = nFrameIndex;
}

inline HBITMAP MBitmapDx::GetHBITMAP(LONG& cx, LONG& cy)
{
    cx = (LONG)m_pBitmap->GetWidth();
    cy = (LONG)m_pBitmap->GetHeight();

    BITMAPINFO bmi;
    ZeroMemory(&bmi, sizeof(bmi));
    bmi.bmiHeader.biSize = sizeof(BITMAPINFOHEADER);
    bmi.bmiHeader.biWidth = cx;
    bmi.bmiHeader.biHeight = cy;
    bmi.bmiHeader.biPlanes = 1;
    bmi.bmiHeader.biBitCount = 24;
    LPVOID pvBits;
    HBITMAP hbm = CreateDIBSection(NULL, &bmi, DIB_RGB_COLORS, &pvBits, 
                                   NULL, 0);
    if (hbm == NULL)
        return NULL;

    HDC hDC = CreateCompatibleDC(NULL);
    HGDIOBJ hbmOld = SelectObject(hDC, hbm);
    {
        RECT rc = { 0, 0, cx, cy };

        HBRUSH hbr = CreateSolidBrush(m_rgbBack);
        FillRect(hDC, &rc, hbr);
        DeleteObject(hbr);

        Gdiplus::Graphics g(hDC);
        g.DrawImage(m_pBitmap, 0, 0, (INT)cx, (INT)cy);
    }
    SelectObject(hDC, hbmOld);
    DeleteDC(hDC);

    return hbm;
}

inline HBITMAP MBitmapDx::GetHBITMAP32(LONG& cx, LONG& cy)
{
    using namespace Gdiplus;
    if (!(m_pBitmap->GetPixelFormat() & PixelFormatAlpha))
    {
        return GetHBITMAP(cx, cy);
    }

    cx = m_pBitmap->GetWidth();
    cy = m_pBitmap->GetHeight();

    BITMAPINFO bmi;
    ZeroMemory(&bmi, sizeof(bmi));
    bmi.bmiHeader.biSize = sizeof(BITMAPINFOHEADER);
    bmi.bmiHeader.biWidth = cx;
    bmi.bmiHeader.biHeight = -cy;
    bmi.bmiHeader.biPlanes = 1;
    bmi.bmiHeader.biBitCount = 32;
    LPVOID pvBits;
    HBITMAP hbm;
    hbm = CreateDIBSection(NULL, &bmi, DIB_RGB_COLORS, &pvBits, NULL, 0);
    if (hbm == NULL)
        return NULL;

    for (LONG y = 0; y < cy; ++y)
    {
        for (LONG x = 0; x < cx; ++x)
        {
            Color color;
            m_pBitmap->GetPixel(x, y, &color);
            BYTE a = color.GetA();
            BYTE r = color.GetR();
            BYTE g = color.GetG();
            BYTE b = color.GetB();
            ((LPBYTE)pvBits)[(x + y * cx) * 4 + 0] = b;
            ((LPBYTE)pvBits)[(x + y * cx) * 4 + 1] = g;
            ((LPBYTE)pvBits)[(x + y * cx) * 4 + 2] = r;
            ((LPBYTE)pvBits)[(x + y * cx) * 4 + 3] = a;
        }
    }

    return hbm;
}

inline UINT MBitmapDx::GetLoopIndex() const
{
    return m_nLoopIndex;
}

inline UINT MBitmapDx::GetLoopCount() const
{
    return m_nLoopCount;
}

inline UINT MBitmapDx::GetFrameIndex() const
{
    return m_nFrameIndex;
}

inline UINT MBitmapDx::GetFrameCount() const
{
    return m_nFrameCount;
}

inline BOOL MBitmapDx::Step(DWORD& dwDelay)
{
    dwDelay = INFINITE;
    if (m_nLoopCount == (UINT)-1)
        return FALSE;

    if (m_nFrameIndex + 1 < m_nFrameCount)
    {
        dwDelay = GetFrameDelay(m_nFrameIndex);
        SetFrameIndex(m_nFrameIndex);
        ++m_nFrameIndex;
        return TRUE;
    }

    if (m_nLoopCount == 0 || m_nLoopIndex < m_nLoopCount)
    {
        dwDelay = GetFrameDelay(m_nFrameIndex);
        SetFrameIndex(m_nFrameIndex);
        m_nFrameIndex = 0;
        ++m_nLoopIndex;
        return TRUE;
    }

    return FALSE;
}

inline UINT MBitmapDx::GetWidth()
{
    if (m_pBitmap)
    {
        return m_pBitmap->GetWidth();
    }
    return 0;
}

inline UINT MBitmapDx::GetHeight()
{
    if (m_pBitmap)
    {
        return m_pBitmap->GetHeight();
    }
    return 0;
}

```

`src/MBmpView.hpp`:

```hpp
// MBmpView.hpp --- Bitmap Viewer
//////////////////////////////////////////////////////////////////////////////
// RisohEditor --- Another free Win32 resource editor
// Copyright (C) 2017-2018 Katayama Hirofumi MZ <katayama.hirofumi.mz@gmail.com>
// 
// This program is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
// 
// This program is distributed in the hope that it will be useful, 
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
// 
// You should have received a copy of the GNU General Public License
// along with this program.  If not, see <http://www.gnu.org/licenses/>.
//////////////////////////////////////////////////////////////////////////////

#pragma once

#include "resource.h"
#include "MWindowBase.hpp"
#include "ConstantsDB.hpp"
#include "Res.hpp"
#include "MBitmapDx.hpp"
#ifndef _INC_VFW
    #include <vfw.h>
#endif

class MBmpView;

//////////////////////////////////////////////////////////////////////////////

class MMciSubclassed : public MWindowBase
{
public:
    virtual LRESULT CALLBACK
    WindowProcDx(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
    {
        switch (uMsg)
        {
        case WM_ERASEBKGND:
            return (LRESULT)GetStockBrush(LTGRAY_BRUSH);
        }
        return DefaultProcDx();
    }
};

class MBmpView : public MWindowBase
{
public:
    BITMAP      m_bm;
    HBITMAP     m_hBitmap;
    HICON       m_hIcon;
    HWND        m_hStatic;
    HWND        m_hPlayButton;
    MBitmapDx   m_bitmap;
    HWND        m_mci_window;
    MMciSubclassed  m_mci;
    TCHAR       m_szTempFile[MAX_PATH];
    enum { TIMER_ID = 999 };

    MBmpView()
    {
        ZeroMemory(&m_bm, sizeof(m_bm));
        m_szTempFile[0] = 0;
    }

    ~MBmpView()
    {
        DeleteTempFile();
        DestroyView();
    }

    BOOL OnCreate(HWND hwnd, LPCREATESTRUCT lpCreateStruct)
    {
        DWORD style = WS_CHILD | WS_BORDER | MCIWNDF_NOMENU | MCIWNDF_NOPLAYBAR |
                      MCIWNDF_NOAUTOSIZEWINDOW | MCIWNDF_NOAUTOSIZEMOVIE |
                      MCIWNDF_NOTIFYALL;
        m_mci_window = MCIWndCreate(hwnd, GetModuleHandle(NULL), style, NULL);
        if (m_mci_window == NULL)
            return FALSE;

        m_mci.SubclassDx(m_mci_window);

        style = WS_CHILD | SS_ICON | SS_REALSIZEIMAGE;
        m_hStatic = CreateWindowEx(0, TEXT("STATIC"), NULL, 
            style, 0, 0, 32, 32, hwnd, (HMENU)1, GetModuleHandle(NULL), NULL);
        if (m_hStatic == NULL)
            return FALSE;

        style = WS_CHILD | BS_PUSHBUTTON | BS_CENTER | BS_ICON;
        m_hPlayButton = CreateWindowEx(0, TEXT("BUTTON"), TEXT("Play"), 
            style, 0, 0, 64, 65, hwnd, (HMENU)2, GetModuleHandle(NULL), NULL);
        if (m_hPlayButton == NULL)
            return FALSE;

        HICON hIcon = LoadIcon(GetModuleHandle(NULL), MAKEINTRESOURCE(IDI_PLAY));
        SendMessage(m_hPlayButton, BM_SETIMAGE, IMAGE_ICON, (LPARAM)hIcon);
        SetWindowFont(m_hPlayButton, GetStockFont(DEFAULT_GUI_FONT), TRUE);
        return TRUE;
    }

    void OnDestroy(HWND hwnd)
    {
        DestroyView();

        DestroyWindow(m_mci_window);
        m_mci_window = NULL;

        DestroyWindow(m_hStatic);
        m_hStatic = NULL;

        DestroyWindow(m_hPlayButton);
        m_hPlayButton = NULL;
    }

    virtual LPCTSTR GetWndClassNameDx() const
    {
        return TEXT("RisohEditor MBmpView Class");
    }

    virtual void ModifyWndClassDx(WNDCLASSEX& wcx)
    {
        wcx.hIcon = NULL;
        wcx.hCursor = LoadCursor(NULL, IDC_CROSS);
        wcx.hbrBackground = GetStockBrush(LTGRAY_BRUSH);
        wcx.lpszMenuName = NULL;
    }

    void SetBitmap(HBITMAP hbm)
    {
        DestroyView();
        m_hBitmap = hbm;
        ShowWindow(m_hStatic, SW_HIDE);
        ShowWindow(m_hPlayButton, SW_HIDE);
        ShowWindow(m_mci_window, SW_HIDE);
        UpdateScrollInfo(m_hwnd);
        DeleteTempFile();
    }

    void SetIcon(HICON hIcon, BOOL bIcon)
    {
        DestroyView();
        m_hIcon = hIcon;
        SendMessage(m_hStatic, STM_SETIMAGE, (bIcon ? IMAGE_ICON : IMAGE_CURSOR), (LPARAM)hIcon);
        ShowWindow(m_hStatic, SW_SHOWNOACTIVATE);
        ShowWindow(m_hPlayButton, SW_HIDE);
        ShowWindow(m_mci_window, SW_HIDE);
        UpdateScrollInfo(m_hwnd);
        DeleteTempFile();
    }

    void SetImage(const void *ptr, DWORD size)
    {
        DestroyView();
        ShowWindow(m_hStatic, SW_HIDE);
        ShowWindow(m_hPlayButton, SW_HIDE);
        ShowWindow(m_mci_window, SW_HIDE);
        if (m_bitmap.CreateFromMemory(ptr, size))
        {
            LONG cx, cy;
            m_hBitmap = m_bitmap.GetHBITMAP(cx, cy);
            UpdateScrollInfo(m_hwnd);
            SetTimer(m_hwnd, TIMER_ID, 0, NULL);
        }
        DeleteTempFile();
    }

    void SetMedia(const void *ptr, DWORD size)
    {
        DestroyView();
        ShowWindow(m_hStatic, SW_HIDE);
        ShowWindow(m_hPlayButton, SW_HIDE);
        ShowWindow(m_mci_window, SW_HIDE);
        DeleteTempFile();

        TCHAR szTempPath[MAX_PATH];
        GetTempPath(MAX_PATH, szTempPath);
        GetTempFileName(szTempPath, TEXT("avi"), 0, m_szTempFile);
        ShowScrollBar(m_hwnd, SB_BOTH, FALSE);

        MByteStreamEx stream;
        stream.WriteData(ptr, size);
        if (stream.SaveToFile(m_szTempFile))
        {
            ShowWindow(m_mci_window, SW_SHOWNOACTIVATE);
            MCIWndOpen(m_mci_window, m_szTempFile, 0);
            MCIWndPlay(m_mci_window);
        }
    }

    void SetPlay()
    {
        DestroyView();
        ShowWindow(m_hStatic, SW_HIDE);
        ShowWindow(m_hPlayButton, SW_SHOWNOACTIVATE);
        ShowWindow(m_mci_window, SW_HIDE);
        DeleteTempFile();
    }

    void DeleteTempFile()
    {
        if (m_szTempFile[0])
        {
            if (DeleteFile(m_szTempFile) ||
                GetFileAttributes(m_szTempFile) == 0xFFFFFFFF)
            {
                m_szTempFile[0] = 0;
            }
        }
    }

    void DestroyView()
    {
        KillTimer(m_hwnd, TIMER_ID);
        ShowWindow(m_mci_window, SW_HIDE);
        MCIWndStop(m_mci_window);
        MCIWndClose(m_mci_window);
        if (m_hBitmap)
        {
            DeleteObject(m_hBitmap);
            m_hBitmap = NULL;
        }
        if (m_hIcon)
        {
            DestroyIcon(m_hIcon);
            m_hIcon = NULL;
        }
        m_bitmap.SetBitmap(NULL);
    }

    BOOL CreateDx(HWND hwndParent, INT CtrlID = 4, BOOL bVisible = FALSE)
    {
        DWORD dwStyle = WS_CHILD | WS_HSCROLL | WS_VSCROLL;
        if (bVisible)
            dwStyle |= WS_VISIBLE;
        DWORD dwExStyle = WS_EX_CLIENTEDGE;
        return CreateAsChildDx(hwndParent, NULL, dwStyle, dwExStyle, CtrlID);
    }

    void OnPaint(HWND hwnd)
    {
        PAINTSTRUCT ps;
        HDC hDC = BeginPaint(hwnd, &ps);
        if (hDC == NULL)
            return;

        HDC hMemDC = CreateCompatibleDC(NULL);
        {
            SelectObject(hMemDC, m_hBitmap);
            INT dx = GetScrollPos(hwnd, SB_HORZ);
            INT dy = GetScrollPos(hwnd, SB_VERT);
            BitBlt(hDC, -dx, -dy, m_bm.bmWidth, m_bm.bmHeight, hMemDC, 0, 0, SRCCOPY);
        }
        DeleteDC(hMemDC);
        EndPaint(hwnd, &ps);
    }

    BOOL OnEraseBkgnd(HWND hwnd, HDC hdc)
    {
        RECT rc;
        GetClientRect(hwnd, &rc);
        FillRect(hdc, &rc, GetStockBrush(COLOR_BACKGROUND));
        return TRUE;
    }

    void OnHScroll(HWND hwnd, HWND hwndCtl, UINT code, int pos)
    {
        RECT rc;
        GetClientRect(hwnd, &rc);

        SCROLLINFO info;
        ZeroMemory(&info, sizeof(info));
        info.cbSize = sizeof(info);
        info.fMask = SIF_POS | SIF_PAGE | SIF_DISABLENOSCROLL;
        info.nPage = rc.right - rc.left;
        switch (code)
        {
        case SB_THUMBPOSITION:
        case SB_THUMBTRACK:
            info.nPos = pos;
            break;
        case SB_TOP:
            info.nPos = 0;
            break;
        case SB_BOTTOM:
            info.nPos = m_bm.bmHeight;
            break;
        case SB_ENDSCROLL:
            return;
        case SB_LINEDOWN:
            info.nPos = GetScrollPos(hwnd, SB_HORZ) + 10;
            break;
        case SB_LINEUP:
            info.nPos = GetScrollPos(hwnd, SB_HORZ) - 10;
            break;
        case SB_PAGEDOWN:
            info.nPos = GetScrollPos(hwnd, SB_HORZ) + info.nPage;
            break;
        case SB_PAGEUP:
            info.nPos = GetScrollPos(hwnd, SB_HORZ) - info.nPage;
            break;
        }
        SetScrollInfo(hwnd, SB_HORZ, &info, TRUE);
        InvalidateRect(hwnd, NULL, TRUE);
    }

    void OnVScroll(HWND hwnd, HWND hwndCtl, UINT code, int pos)
    {
        RECT rc;
        GetClientRect(hwnd, &rc);

        SCROLLINFO info;
        ZeroMemory(&info, sizeof(info));
        info.cbSize = sizeof(info);
        info.fMask = SIF_POS | SIF_PAGE | SIF_DISABLENOSCROLL;
        info.nPage = rc.bottom - rc.top;
        switch (code)
        {
        case SB_THUMBPOSITION:
        case SB_THUMBTRACK:
            info.nPos = pos;
            break;
        case SB_TOP:
            info.nPos = 0;
            break;
        case SB_BOTTOM:
            info.nPos = m_bm.bmHeight;
            break;
        case SB_ENDSCROLL:
            return;
        case SB_LINEDOWN:
            info.nPos = GetScrollPos(hwnd, SB_VERT) + 10;
            break;
        case SB_LINEUP:
            info.nPos = GetScrollPos(hwnd, SB_VERT) - 10;
            break;
        case SB_PAGEDOWN:
            info.nPos = GetScrollPos(hwnd, SB_VERT) + info.nPage;
            break;
        case SB_PAGEUP:
            info.nPos = GetScrollPos(hwnd, SB_VERT) - info.nPage;
            break;
        }
        SetScrollInfo(hwnd, SB_VERT, &info, TRUE);
        InvalidateRect(hwnd, NULL, TRUE);
    }

    void UpdateScrollInfo(HWND hwnd, SIZE siz)
    {
        RECT rc;
        GetClientRect(hwnd, &rc);

        SCROLLINFO info;

        ZeroMemory(&info, sizeof(info));
        info.cbSize = sizeof(info);
        info.fMask = SIF_ALL | SIF_DISABLENOSCROLL;
        info.nMin = 0;
        info.nMax = siz.cx;
        info.nPage = rc.right - rc.left;
        info.nPos = 0;
        SetScrollInfo(hwnd, SB_HORZ, &info, TRUE);
        ShowScrollBar(hwnd, SB_HORZ, TRUE);

        ZeroMemory(&info, sizeof(info));
        info.cbSize = sizeof(info);
        info.fMask = SIF_ALL | SIF_DISABLENOSCROLL;
        info.nMin = 0;
        info.nMax = siz.cy;
        info.nPage = rc.bottom - rc.top;
        info.nPos = 0;
        SetScrollInfo(hwnd, SB_VERT, &info, TRUE);
        ShowScrollBar(hwnd, SB_VERT, TRUE);

        InvalidateRect(hwnd, NULL, TRUE);
    }

    void UpdateScrollInfo(HWND hwnd)
    {
        if (!GetObjectW(m_hBitmap, sizeof(m_bm), &m_bm))
            return;

        SIZE siz = { m_bm.bmWidth, m_bm.bmHeight };
        UpdateScrollInfo(hwnd, siz);
    }

    void OnCommand(HWND hwnd, int id, HWND hwndCtl, UINT codeNotify)
    {
        switch (id)
        {
        case 999:
            UpdateScrollInfo(hwnd);
            break;
        case 1:
            break;
        case 2:
            if (codeNotify == BN_CLICKED)
            {
                PostMessage(GetParent(hwnd), WM_COMMAND, ID_PLAY, 0);
            }
            break;
        }
    }

    void OnSize(HWND hwnd, UINT state, int cx, int cy)
    {
        UpdateScrollInfo(hwnd);
        MoveWindow(m_mci_window, 0, 0, cx, cy, TRUE);
        FORWARD_WM_SIZE(hwnd, state, cx, cy, DefWindowProcW);
    }

    void OnTimer(HWND hwnd, UINT id)
    {
        KillTimer(hwnd, id);
        if (id != TIMER_ID)
            return;

        DWORD dwDelay;
        if (m_bitmap.Step(dwDelay))
        {
            LONG cx, cy;
            if (m_hBitmap)
            {
                DeleteObject(m_hBitmap);
            }
            m_hBitmap = m_bitmap.GetHBITMAP(cx, cy);
            InvalidateRect(hwnd, NULL, FALSE);
            SetTimer(hwnd, TIMER_ID, dwDelay, NULL);
        }
    }

    void OnMouseWheel(HWND hwnd, int xPos, int yPos, int zDelta, UINT fwKeys)
    {
        if (fwKeys & MK_SHIFT)
        {
            if (zDelta < 0)
            {
                for (INT i = 0; i < -zDelta; i += WHEEL_DELTA)
                    FORWARD_WM_HSCROLL(hwnd, NULL, SB_LINEDOWN, 0, SendMessage);
            }
            else
            {
                for (INT i = 0; i < zDelta; i += WHEEL_DELTA)
                    FORWARD_WM_HSCROLL(hwnd, NULL, SB_LINEUP, 0, SendMessage);
            }
        }
        else
        {
            if (zDelta < 0)
            {
                for (INT i = 0; i < -zDelta; i += WHEEL_DELTA)
                    FORWARD_WM_VSCROLL(hwnd, NULL, SB_LINEDOWN, 0, SendMessage);
            }
            else
            {
                for (INT i = 0; i < zDelta; i += WHEEL_DELTA)
                    FORWARD_WM_VSCROLL(hwnd, NULL, SB_LINEUP, 0, SendMessage);
            }
        }
    }

    virtual LRESULT CALLBACK
    WindowProcDx(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
    {
        switch (uMsg)
        {
            HANDLE_MSG(hwnd, WM_CREATE, OnCreate);
            HANDLE_MSG(hwnd, WM_ERASEBKGND, OnEraseBkgnd);
            HANDLE_MSG(hwnd, WM_PAINT, OnPaint);
            HANDLE_MSG(hwnd, WM_HSCROLL, OnHScroll);
            HANDLE_MSG(hwnd, WM_VSCROLL, OnVScroll);
            HANDLE_MSG(hwnd, WM_COMMAND, OnCommand);
            HANDLE_MSG(hwnd, WM_SIZE, OnSize);
            HANDLE_MSG(hwnd, WM_TIMER, OnTimer);
            HANDLE_MSG(hwnd, WM_DESTROY, OnDestroy);
            HANDLE_MSG(hwnd, WM_MOUSEWHEEL, OnMouseWheel);
        default:
            if (uMsg == MCIWNDM_NOTIFYMODE)
            {
                if (lParam == MCI_MODE_STOP)
                {
                    MCIWndPlayFrom(m_mci_window, 0);
                    break;
                }
            }
            return DefaultProcDx();
        }
        return 0;
    }
};

```

`src/MByteStream.hpp`:

```hpp
// MByteStream.hpp -- MZC4 byte stream                          -*- C++ -*-
// This file is part of MZC4.  See file "ReadMe.txt" and "License.txt".
////////////////////////////////////////////////////////////////////////////

#ifndef MZC4_MBYTESTREAM_HPP_
#define MZC4_MBYTESTREAM_HPP_       9       /* Version 9 */

class MByteStream;

//////////////////////////////////////////////////////////////////////////////

#if defined(_WIN32) && !defined(WONVER)
    #ifndef _INC_WINDOWS
        #include <windows.h>
    #endif
#else
    #include "wondef.h"         // Wonders API
    #define _unlink     unlink
#endif

#if __cplusplus >= 201103L          /* C++11 */
    #include <cstdint>
#else
    #include "pstdint.h"
#endif

#ifndef _WIN32
    #include <unistd.h>     // for unlink
#endif

#include "MString.hpp"

#include <cstdlib>          // C standard library
#include <cstdio>           // C standard I/O
#include <cstring>          // C string
#include <cassert>          // assert
#include <vector>           // for std::vector
#include <string>           // for std::string and std::wstring

//////////////////////////////////////////////////////////////////////////////

class MByteStream
{
public:
    typedef std::vector<uint8_t> data_type;
    typedef std::size_t size_type;

    MByteStream() : m_pos(0)
    {
    }

    MByteStream(size_t size) : m_pos(0)
    {
        m_data.resize(size);
    }

    MByteStream(const data_type& data) : m_pos(0), m_data(data)
    {
    }

    MByteStream(const void *ptr, size_t size) :
        m_pos(0), m_data((const uint8_t *)ptr, (const uint8_t *)ptr + size)
    {
    }

    virtual ~MByteStream()
    {
    }

    void assign(const void *ptr, size_t size)
    {
        m_data.assign((const uint8_t *)ptr, (const uint8_t *)ptr + size);
    }
    void assign(const void *ptr1, const void *ptr2)
    {
        m_data.assign((const uint8_t *)ptr1, (const uint8_t *)ptr2);
    }
    void assign(const data_type& data)
    {
        m_pos = 0;
        m_data = data;
    }

    void clear()
    {
        m_pos = 0;
        m_data.clear();
    }

    data_type& data()
    {
        return m_data;
    }

    const data_type& data() const
    {
        return m_data;
    }

    void *ptr(size_t index = 0, size_t data_size = 1)
    {
        if (index + data_size <= m_data.size())
            return &m_data[index];
        return NULL;
    }
    const void *ptr(size_t index = 0, size_t data_size = 1) const
    {
        if (index + data_size <= m_data.size())
            return &m_data[index];
        return NULL;
    }

    template <typename T_DATA>
    T_DATA *pointer(size_t index = 0)
    {
        return reinterpret_cast<T_DATA *>(ptr(index, sizeof(T_DATA)));
    }
    template <typename T_DATA>
    const T_DATA *pointer(size_t index = 0) const
    {
        return reinterpret_cast<const T_DATA *>(ptr(index, sizeof(T_DATA)));
    }

    size_t size() const
    {
        return m_data.size();
    }

    size_t remainder() const
    {
        if (m_pos <= size())
            return size() - m_pos;
        return 0;
    }

    size_t pos() const
    {
        return m_pos;
    }
    void pos(size_t pos_) const
    {
        m_pos = pos_;
    }

    bool seek(int16_t delta) const
    {
        if (delta > 0)
        {
            if (m_pos + delta <= size())
            {
                m_pos += delta;
                return true;
            }
        }
        else if (delta < 0)
        {
            if (int32_t(m_pos) + delta >= 0)
            {
                m_pos += delta;
                return true;
            }
        }
        return false;
    }

    template <typename T>
    bool WriteRaw(const T& data)
    {
        return WriteData(&data, sizeof(T));
    }

    bool WriteData(const void *data, size_t nSize)
    {
        if (data && nSize)
        {
            size_t old_size = size();
            m_data.resize(old_size + nSize);
            memcpy(&m_data[old_size], data, nSize);
        }
        return true;
    }

    bool WriteByte(uint8_t value)
    {
        uint8_t b = value;
        return WriteData(&b, sizeof(b));
    }

    bool WriteWord(uint16_t value)
    {
        uint16_t w = value;
        return WriteData(&w, sizeof(w));
    }

    void WriteWordAlignment()
    {
        if (m_data.size() & 1)
            m_data.resize(m_data.size() + 1);
    }

    bool WriteDword(uint32_t value)
    {
        uint32_t dw = value;
        return WriteData(&dw, sizeof(dw));
    }

    void WriteDwordAlignment()
    {
        size_t n = (m_data.size() & 3);
        if (n)
        {
            m_data.resize(m_data.size() + (4 - n));
        }
    }

    template <typename T>
    bool ReadRaw(T& value) const
    {
        return ReadData(&value, sizeof(T));
    }

    bool ReadData(void *data, size_t nSize) const
    {
        if (m_pos + nSize <= size())
        {
            if (nSize)
            {
                memcpy(data, &m_data[m_pos], nSize);
                m_pos += nSize;
            }
            return true;
        }
        return false;
    }

    bool ReadByte(uint8_t& b) const
    {
        return ReadData(&b, sizeof(b));
    }

    bool ReadByte(char& b) const
    {
        return ReadData(&b, sizeof(b));
    }

    bool ReadWord(uint16_t& w) const
    {
        return ReadData(&w, sizeof(w));
    }

    bool ReadWord(int16_t& w) const
    {
        return ReadData(&w, sizeof(w));
    }

    bool ReadDword(uint32_t& dw) const
    {
        return ReadData(&dw, sizeof(dw));
    }

    bool ReadDword(int32_t& n) const
    {
        return ReadData(&n, sizeof(n));
    }

    bool PeekWord(uint16_t& w) const
    {
        size_t nSize = sizeof(uint16_t);
        if (m_pos + nSize <= size())
        {
            memcpy(&w, &m_data[m_pos], nSize);
            return true;
        }
        return false;
    }

    bool PeekByte(uint8_t& b) const
    {
        size_t nSize = sizeof(uint8_t);
        if (m_pos + nSize <= size())
        {
            memcpy(&b, &m_data[m_pos], nSize);
            return true;
        }
        return false;
    }

    void ReadWordAlignment() const
    {
        if (m_pos & 1)
            ++m_pos;
    }

    void ReadDwordAlignment() const
    {
        size_t mod = (m_pos & 3);
        if (mod)
            m_pos += 4 - mod;
    }

    bool LoadFromFile(const TCHAR *FileName)
    {
        m_pos = 0;
        m_data.clear();

        FILE *fp;
#ifdef UNICODE
        fp = _wfopen(FileName, L"rb");
#else
        fp = fopen(FileName, "rb");
#endif
        if (!fp)
            return false;

        bool ok = true;
        uint8_t buf[512];
        for (;;)
        {
            size_t size = fread(buf, 1, 512, fp);
            if (size == 0)
            {
                if (ferror(fp))
                    ok = false;
                break;
            }

            m_data.insert(m_data.end(), &buf[0], &buf[size]);
        }

        fclose(fp);

        return ok;
    }

    bool SaveToFile(const TCHAR *FileName) const
    {
        FILE *fp;
#ifdef UNICODE
        fp = _wfopen(FileName, L"wb");
#else
        fp = fopen(FileName, "wb");
#endif
        if (!fp)
            return false;

        size_t n = fwrite(&m_data[0], m_data.size(), 1, fp);
        fclose(fp);

        if (!n)
        {
#ifdef UNICODE
            _wremove(FileName);
#else
            _unlink(FileName);
#endif
        }

        return n != 0;
    }

    uint8_t& operator[](size_t index)
    {
        return m_data[index];
    }
    const uint8_t& operator[](size_t index) const
    {
        return m_data[index];
    }

    bool ReadSz(MStringA& str) const
    {
        str.clear();
        uint8_t b;
        while (ReadByte(b))
        {
            if (b == 0)
                return true;
            str += b;
        }
        return false;
    }
    bool WriteSz(const MStringA& str)
    {
        return WriteData(&str[0], (str.size() + 1) * sizeof(char));
    }

    bool ReadSz(MStringW& str) const
    {
        str.clear();
        uint16_t w;
        while (ReadWord(w))
        {
            if (w == 0)
                return true;
            str += (WCHAR)w;
        }
        return false;
    }
    bool WriteSz(const MStringW& str)
    {
        return WriteData(&str[0], (str.size() + 1) * sizeof(WCHAR));
    }

protected:
    mutable size_type   m_pos;
    data_type           m_data;
};

//////////////////////////////////////////////////////////////////////////////

#endif  // ndef MZC4_MBYTESTREAM_HPP_

```

`src/MByteStreamEx.hpp`:

```hpp
// MByteStream.hpp -- MZC4 byte stream                          -*- C++ -*-
// This file is part of MZC4.  See file "ReadMe.txt" and "License.txt".
////////////////////////////////////////////////////////////////////////////

#ifndef MZC4_MBYTESTREAMEX_HPP_
#define MZC4_MBYTESTREAMEX_HPP_     3       /* Version 3 */

class MByteStreamEx;

////////////////////////////////////////////////////////////////////////////

#include "MByteStream.hpp"
#include "MIdOrString.hpp"

////////////////////////////////////////////////////////////////////////////

class MByteStreamEx : public MByteStream
{
public:
    MByteStreamEx()
    {
    }

    MByteStreamEx(size_t size) : MByteStream(size)
    {
        m_data.resize(size);
    }

    MByteStreamEx(const data_type& data) : MByteStream(data)
    {
    }

    MByteStreamEx(const void *ptr, size_t size) : MByteStream(ptr, size)
    {
    }

    BOOL ReadID(MIdOrString& id_or_str) const
    {
        WORD w;
        if (!PeekWord(w))
            return FALSE;

        if (w == 0xFFFF)
        {
            ReadWord(w);
            if (ReadWord(w))
            {
                id_or_str = w;
                return TRUE;
            }
            return FALSE;
        }

        id_or_str.m_id = 0;
        return ReadSz(id_or_str.m_str);
    }

    BOOL WriteID(const MIdOrString& id_or_str)
    {
        if (id_or_str.is_str())
        {
            return WriteSz(id_or_str.m_str);
        }
        return WriteWord(0xFFFF) && WriteWord(id_or_str.m_id);
    }

    BOOL ReadString(MIdOrString& id_or_str) const
    {
        WORD w;
        if (!PeekWord(w))
            return FALSE;

        if (w == 0)
        {
            ReadWord(w);
            id_or_str.clear();
            return TRUE;
        }

        if (w == 0xFFFF)
        {
            WORD w;
            if (!ReadWord(w) || !ReadWord(w))
                return FALSE;
            id_or_str = w;
            return TRUE;
        }

        id_or_str.m_id = 0;
        return ReadSz(id_or_str.m_str);
    }

    BOOL WriteString(const WCHAR *psz)
    {
        if (psz == NULL)
        {
            return WriteWord(0);
        }
        if (IS_INTRESOURCE(psz))
        {
            WORD aw[2];
            aw[0] = 0xFFFF;
            aw[1] = LOWORD(psz);
            return WriteRaw(aw);
        }
        return WriteData(psz, (mstrlen(psz) + 1) * sizeof(WCHAR));
    }
};

////////////////////////////////////////////////////////////////////////////

#endif  // ndef MZC4_MBYTESTREAMEX_HPP_

```

`src/MChooseLangDlg.hpp`:

```hpp
// MChooseLangDlg.hpp --- "Choose UI Language" Dialog
//////////////////////////////////////////////////////////////////////////////
// RisohEditor --- Another free Win32 resource editor
// Copyright (C) 2017-2018 Katayama Hirofumi MZ <katayama.hirofumi.mz@gmail.com>
// 
// This program is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
// 
// This program is distributed in the hope that it will be useful, 
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
// 
// You should have received a copy of the GNU General Public License
// along with this program.  If not, see <http://www.gnu.org/licenses/>.
//////////////////////////////////////////////////////////////////////////////

#pragma once

#include "resource.h"
#include "MWindowBase.hpp"
#include "MString.hpp"
#include "ConstantsDB.hpp"
#include "MComboBoxAutoComplete.hpp"
#include "MLangAutoComplete.hpp"
#include "Common.hpp"

class MChooseLangDlg;

//////////////////////////////////////////////////////////////////////////////

class MChooseLangDlg : public MDialogBase
{
public:
    LANGID m_langid;
    MComboBoxAutoComplete m_cmb3;
    MLangAutoComplete *m_pAutoComplete;

    MChooseLangDlg()
        : MDialogBase(IDD_UILANG)
        , m_pAutoComplete(new MLangAutoComplete(TRUE))
    {
        m_cmb3.m_bAcceptSpace = TRUE;
        m_pAutoComplete->AddRef();
    }

    ~MChooseLangDlg()
    {
        m_pAutoComplete->unbind();
        m_pAutoComplete->Release();
        m_pAutoComplete = NULL;
    }

    BOOL OnInitDialog(HWND hwnd, HWND hwndFocus, LPARAM lParam)
    {
        // for Langs
        HWND hCmb3 = GetDlgItem(hwnd, cmb3);
        InitLangComboBox(hCmb3, GetThreadUILanguage(), TRUE);
        SubclassChildDx(m_cmb3, cmb3);

        // auto complete
        COMBOBOXINFO info = { sizeof(info) };
        GetComboBoxInfo(m_cmb3, &info);
        HWND hwndEdit = info.hwndItem;
        m_pAutoComplete->bind(hwndEdit);

        CenterWindowDx();
        return TRUE;
    }

    void OnOK(HWND hwnd)
    {
        HWND hCmb3 = GetDlgItem(hwnd, cmb3);
        WORD lang;
        if (!CheckLangComboBox(hCmb3, lang, TRUE))
            return;

        m_langid = lang;
        EndDialog(IDOK);
    }

    void OnCommand(HWND hwnd, int id, HWND hwndCtl, UINT codeNotify)
    {
        switch (id)
        {
        case IDOK:
            OnOK(hwnd);
            break;
        case psh1:
            m_langid = GetUserDefaultLangID();
            EndDialog(IDOK);
            break;
        case IDCANCEL:
            EndDialog(IDCANCEL);
            break;
        case cmb3:
            if (codeNotify == CBN_EDITCHANGE)
            {
                m_cmb3.OnEditChange();
            }
            break;
        }
    }

    virtual INT_PTR CALLBACK
    DialogProcDx(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
    {
        switch (uMsg)
        {
            HANDLE_MSG(hwnd, WM_INITDIALOG, OnInitDialog);
            HANDLE_MSG(hwnd, WM_COMMAND, OnCommand);
        }
        return DefaultProcDx();
    }
};

```

`src/MCloneInNewLangDlg.hpp`:

```hpp
// MCloneInNewLangDlg.hpp --- "Clone In New Language" Dialog
//////////////////////////////////////////////////////////////////////////////
// RisohEditor --- Another free Win32 resource editor
// Copyright (C) 2017-2018 Katayama Hirofumi MZ <katayama.hirofumi.mz@gmail.com>
// 
// This program is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
// 
// This program is distributed in the hope that it will be useful, 
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
// 
// You should have received a copy of the GNU General Public License
// along with this program.  If not, see <http://www.gnu.org/licenses/>.
//////////////////////////////////////////////////////////////////////////////

#pragma once

#include "resource.h"
#include "MWindowBase.hpp"
#include "ConstantsDB.hpp"
#include "Res.hpp"
#include "MComboBoxAutoComplete.hpp"
#include "Common.hpp"

//////////////////////////////////////////////////////////////////////////////

class MCloneInNewLangDlg : public MDialogBase
{
public:
    EntryBase *m_entry;
    MIdOrString m_type;
    MIdOrString m_name;
    WORD m_lang;
    MComboBoxAutoComplete m_cmb3;

    MCloneInNewLangDlg(EntryBase* entry)
        : MDialogBase(IDD_CLONEINNEWLANG), m_entry(entry),
          m_type(entry->m_type), m_name(entry->m_name), m_lang(entry->m_lang)
    {
        m_cmb3.m_bAcceptSpace = TRUE;
    }

    virtual INT_PTR CALLBACK
    DialogProcDx(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
    {
        switch (uMsg)
        {
            HANDLE_MSG(hwnd, WM_INITDIALOG, OnInitDialog);
            HANDLE_MSG(hwnd, WM_COMMAND, OnCommand);
        }
        return DefaultProcDx(hwnd, uMsg, wParam, lParam);
    }

    BOOL OnInitDialog(HWND hwnd, HWND hwndFocus, LPARAM lParam)
    {
        // for Types
        HWND hCmb1 = GetDlgItem(hwnd, cmb1);
        InitResTypeComboBox(hCmb1, m_type);

        // for Names
        auto nIDTYPE_ = g_db.IDTypeFromResType(m_type);
        HWND hCmb2 = GetDlgItem(hwnd, cmb2);
        InitResNameComboBox(hCmb2, m_name, nIDTYPE_);

        // for Langs
        HWND hCmb3 = GetDlgItem(hwnd, cmb3);
        InitLangComboBox(hCmb3, m_lang);
        SubclassChildDx(m_cmb3, cmb3);

        CenterWindowDx();
        return TRUE;
    }

    void OnOK(HWND hwnd)
    {
        MIdOrString type;
        HWND hCmb1 = GetDlgItem(hwnd, cmb1);
        const ConstantsDB::TableType& table = g_db.GetTable(L"RESOURCE");
        INT iType = ComboBox_GetCurSel(hCmb1);
        if (iType != CB_ERR && iType < INT(table.size()))
        {
            type = WORD(table[iType].value);
        }
        else
        {
            if (!CheckTypeComboBox(hCmb1, type))
                return;
        }

        HWND hCmb3 = GetDlgItem(hwnd, cmb3);
        WORD lang;
        if (!CheckLangComboBox(hCmb3, lang))
            return;

        if (lang == m_lang)
        {
            ErrorBoxDx(IDS_SAMELANG);
            return;
        }

        if (g_res.find(ET_LANG, m_type, m_name, lang))
        {
            if (MsgBoxDx(IDS_EXISTSOVERWRITE, MB_ICONINFORMATION | MB_YESNOCANCEL) != IDYES)
            {
                return;
            }
        }

        m_lang = lang;

        EndDialog(IDOK);
    }

    void OnCommand(HWND hwnd, int id, HWND hwndCtl, UINT codeNotify)
    {
        switch (id)
        {
        case IDOK:
            OnOK(hwnd);
            break;
        case IDCANCEL:
            EndDialog(IDCANCEL);
            break;
        case cmb3:
            if (codeNotify == CBN_EDITCHANGE)
            {
                m_cmb3.OnEditChange();
            }
            break;
        }
    }
};

```

`src/MCloneInNewNameDlg.hpp`:

```hpp
// MCloneInNewNameDlg.hpp --- "Clone In New Name" Dialog
//////////////////////////////////////////////////////////////////////////////
// RisohEditor --- Another free Win32 resource editor
// Copyright (C) 2017-2018 Katayama Hirofumi MZ <katayama.hirofumi.mz@gmail.com>
// 
// This program is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
// 
// This program is distributed in the hope that it will be useful, 
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
// 
// You should have received a copy of the GNU General Public License
// along with this program.  If not, see <http://www.gnu.org/licenses/>.
//////////////////////////////////////////////////////////////////////////////

#pragma once

#include "resource.h"
#include "MWindowBase.hpp"
#include "ConstantsDB.hpp"
#include "Res.hpp"
#include "MComboBoxAutoComplete.hpp"
#include "Common.hpp"

//////////////////////////////////////////////////////////////////////////////

class MCloneInNewNameDlg : public MDialogBase
{
public:
    EntryBase *m_entry;
    MIdOrString m_type;
    MIdOrString m_name;
    WORD m_lang;
    MComboBoxAutoComplete m_cmb2;

    MCloneInNewNameDlg(EntryBase *entry)
        : MDialogBase(IDD_CLONEINNEWNAME), m_entry(entry), 
          m_type(entry->m_type), m_name(entry->m_name), m_lang(entry->m_lang)
    {
    }

    virtual INT_PTR CALLBACK
    DialogProcDx(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
    {
        switch (uMsg)
        {
            HANDLE_MSG(hwnd, WM_INITDIALOG, OnInitDialog);
            HANDLE_MSG(hwnd, WM_COMMAND, OnCommand);
        }
        return DefaultProcDx(hwnd, uMsg, wParam, lParam);
    }

    BOOL OnInitDialog(HWND hwnd, HWND hwndFocus, LPARAM lParam)
    {
        // for Types
        HWND hCmb1 = GetDlgItem(hwnd, cmb1);
        InitResTypeComboBox(hCmb1, m_type);

        // for Names
        IDTYPE_ nIDTYPE_ = g_db.IDTypeFromResType(m_type);
        HWND hCmb2 = GetDlgItem(hwnd, cmb2);
        InitResNameComboBox(hCmb2, m_name, nIDTYPE_);
        SubclassChildDx(m_cmb2, cmb2);

        CenterWindowDx();
        return TRUE;
    }

    void OnOK(HWND hwnd)
    {
        MIdOrString type;
        HWND hCmb1 = GetDlgItem(hwnd, cmb1);
        const ConstantsDB::TableType& table = g_db.GetTable(L"RESOURCE");
        INT iType = ComboBox_GetCurSel(hCmb1);
        if (iType != CB_ERR && iType < INT(table.size()))
        {
            type = WORD(table[iType].value);
        }
        else
        {
            if (!CheckTypeComboBox(hCmb1, type))
                return;
        }

        // for Names
        HWND hCmb2 = GetDlgItem(hwnd, cmb2);
        MIdOrString name;
        if (!CheckNameComboBox(hCmb2, name))
            return;

        if (m_name == name)
        {
            ErrorBoxDx(IDS_SAMENAME);
            return;
        }

        if (g_res.find(ET_NAME, m_type, name, m_lang))
        {
            if (MsgBoxDx(IDS_EXISTSOVERWRITE, MB_ICONINFORMATION | MB_YESNOCANCEL) != IDYES)
            {
                return;
            }
        }

        m_name = name;

        EndDialog(IDOK);
    }

    void OnCommand(HWND hwnd, int id, HWND hwndCtl, UINT codeNotify)
    {
        switch (id)
        {
        case IDOK:
            OnOK(hwnd);
            break;
        case IDCANCEL:
            EndDialog(IDCANCEL);
            break;
        case psh1:
            OnPsh1(hwnd);
            break;
        case cmb2:
            if (codeNotify == CBN_EDITCHANGE)
            {
                m_cmb2.OnEditChange();
            }
            break;
        }
    }

    void OnPsh1(HWND hwnd)
    {
        SendMessage(GetParent(hwnd), WM_COMMAND, ID_IDLIST, 0);
    }
};

```

`src/MComboBox.hpp`:

```hpp
// MComboBox.hpp -- Win32API combo box wrapper                  -*- C++ -*-
// This file is part of MZC4.  See file "ReadMe.txt" and "License.txt".
////////////////////////////////////////////////////////////////////////////

#ifndef MZC4_MCOMBOBOX_HPP_
#define MZC4_MCOMBOBOX_HPP_     2   /* Version 2 */

class MComboBox;

////////////////////////////////////////////////////////////////////////////

#include "MWindowBase.hpp"

class MComboBox : public MWindowBase
{
public:
    MComboBox();

    virtual LPCTSTR GetWndClassNameDx() const;

    INT GetCount() const;
    INT GetCurSel() const;
    INT SetCurSel(INT nSelect);
    LCID GetLocale() const;
    LCID SetLocale(LCID nNewLocale);

    INT  GetTopIndex() const;
    INT  SetTopIndex(INT nIndex);
    INT  InitStorage(INT nItems, UINT nBytes);
    VOID SetHorizontalExtent(UINT nExtent);
    UINT GetHorizontalExtent() const;

    INT  SetDroppedWidth(UINT nWidth);
    INT  GetDroppedWidth() const;

    DWORD GetEditSel() const;
    BOOL  LimitText(INT nMaxChars);
    BOOL  SetEditSel(INT nStartChar, INT nEndChar);
    VOID SelectAll();
    VOID SelectNone();

    DWORD GetItemData(INT nIndex) const;
    INT   SetItemData(INT nIndex, DWORD dwItemData);
    LPVOID GetItemDataPtr(INT nIndex) const;
    INT    SetItemDataPtr(INT nIndex, LPVOID pData);

    INT  GetLBText(INT nIndex, LPTSTR lpszText) const;
    BOOL GetLBText(INT nIndex, MString& rString) const;
    INT  GetLBTextLen(INT nIndex) const;

    INT GetItemHeight(INT nIndex) const;
    INT SetItemHeight(INT nIndex, UINT cyItemHeight);

    INT FindString(INT nStartAfter, LPCTSTR lpszString) const;
    INT FindStringExact(INT nIndexStart, LPCTSTR lpszFind) const;
    INT SelectString(INT nStartAfter, LPCTSTR lpszString);

    BOOL GetExtendedUI() const;
    INT  SetExtendedUI(BOOL bExtended = TRUE);

    VOID GetDroppedControlRect(LPRECT lprect) const;
    BOOL GetDroppedState() const;

    VOID ShowDropDown(BOOL bShowIt = TRUE);

    INT  AddString(LPCTSTR lpszString);
    INT  DeleteString(UINT nIndex);
    INT  InsertString(INT nIndex, LPCTSTR lpszString);
    VOID ResetContent();
    INT  Dir(UINT attr, LPCTSTR lpszWildCard);

    VOID Clear();
    VOID Copy();
    VOID Cut();
    VOID Paste();
};

////////////////////////////////////////////////////////////////////////////

inline MComboBox::MComboBox()
{
}

inline /*virtual*/ LPCTSTR MComboBox::GetWndClassNameDx() const
{
    return TEXT("COMBOBOX");
}

inline INT MComboBox::GetCount() const
{
    return (INT)SendMessageDx(CB_GETCOUNT);
}

inline INT MComboBox::GetCurSel() const
{
    return (INT)SendMessageDx(CB_GETCURSEL);
}

inline INT MComboBox::SetCurSel(INT nSelect)
{
    return (INT)SendMessageDx(CB_SETCURSEL, (WPARAM)nSelect);
}

inline LCID MComboBox::GetLocale() const
{
    return (LCID)SendMessageDx(CB_GETLOCALE);
}

inline LCID MComboBox::SetLocale(LCID nNewLocale)
{
    return (LCID)SendMessageDx(CB_SETLOCALE, nNewLocale);
}

inline INT MComboBox::GetTopIndex() const
{
    return (INT)SendMessageDx(CB_GETTOPINDEX);
}

inline INT MComboBox::SetTopIndex(INT nIndex)
{
    return (INT)SendMessageDx(CB_SETTOPINDEX, (WPARAM)nIndex);
}

inline INT MComboBox::InitStorage(INT nItems, UINT nBytes)
{
    return (INT)SendMessageDx(CB_INITSTORAGE, (WPARAM)nItems, (LPARAM)nBytes);
}

inline VOID MComboBox::SetHorizontalExtent(UINT nExtent)
{
    SendMessageDx(CB_SETHORIZONTALEXTENT, nExtent);
}

inline UINT MComboBox::GetHorizontalExtent() const
{
    return (UINT)SendMessageDx(CB_GETHORIZONTALEXTENT);
}

inline INT MComboBox::SetDroppedWidth(UINT nWidth)
{
    return (INT)SendMessageDx(CB_SETDROPPEDWIDTH, nWidth);
}

inline INT MComboBox::GetDroppedWidth() const
{
    return (INT)SendMessageDx(CB_GETDROPPEDWIDTH);
}

inline DWORD MComboBox::GetEditSel() const
{
    return (DWORD)SendMessageDx(CB_GETEDITSEL);
}

inline BOOL MComboBox::LimitText(INT nMaxChars)
{
    return (BOOL)SendMessageDx(CB_LIMITTEXT, (WPARAM)nMaxChars);
}

inline BOOL MComboBox::SetEditSel(INT nStartChar, INT nEndChar)
{
    return (BOOL)SendMessageDx(CB_SETEDITSEL, 0, 
                                MAKELPARAM(nStartChar, nEndChar));
}

inline VOID MComboBox::SelectAll()
{
    SetEditSel(0, -1);
}

inline VOID MComboBox::SelectNone()
{
    SetEditSel(-1, -1);
}

inline DWORD MComboBox::GetItemData(INT nIndex) const
{
    return (DWORD)SendMessageDx(CB_GETITEMDATA, (WPARAM)nIndex);
}

inline INT MComboBox::SetItemData(INT nIndex, DWORD dwItemData)
{
    return (INT)SendMessageDx(CB_SETITEMDATA, (WPARAM)nIndex, (LPARAM)dwItemData);
}

inline LPVOID MComboBox::GetItemDataPtr(INT nIndex) const
{
    return (LPVOID)SendMessageDx(CB_GETITEMDATA, (WPARAM)nIndex);
}

inline INT MComboBox::SetItemDataPtr(INT nIndex, LPVOID pData)
{
    return (INT)SendMessageDx(CB_SETITEMDATA, (WPARAM)nIndex, (LPARAM)pData);
}

inline INT MComboBox::GetLBText(INT nIndex, LPTSTR lpszText) const
{
    return (INT)SendMessageDx(CB_GETLBTEXT, (WPARAM)nIndex, (LPARAM)lpszText);
}

inline INT MComboBox::GetLBTextLen(INT nIndex) const
{
    return (INT)SendMessageDx(CB_GETLBTEXTLEN, (WPARAM)nIndex);
}

inline INT MComboBox::SetItemHeight(INT nIndex, UINT cyItemHeight)
{
    return (INT)SendMessageDx(CB_SETITEMHEIGHT, (WPARAM)nIndex, (LPARAM)cyItemHeight);
}

inline INT MComboBox::GetItemHeight(INT nIndex) const
{
    return (INT)SendMessageDx(CB_GETITEMHEIGHT, (WPARAM)nIndex);
}

inline INT MComboBox::FindStringExact(
    INT nIndexStart, LPCTSTR lpszFind) const
{
    return (INT)SendMessageDx(CB_FINDSTRINGEXACT, (WPARAM)nIndexStart, (LPARAM)lpszFind);
}

inline INT MComboBox::SetExtendedUI(BOOL bExtended/* = TRUE*/)
{
    return (INT)SendMessageDx(CB_SETEXTENDEDUI, (WPARAM)bExtended);
}

inline BOOL MComboBox::GetExtendedUI() const
{
    return (BOOL)SendMessageDx(CB_GETEXTENDEDUI);
}

inline VOID MComboBox::GetDroppedControlRect(LPRECT lprect) const
{
    SendMessageDx(CB_GETDROPPEDCONTROLRECT, 0, (LPARAM)lprect);
}

inline BOOL MComboBox::GetDroppedState() const
{
    return (BOOL)SendMessageDx(CB_GETDROPPEDSTATE);
}

inline VOID MComboBox::ShowDropDown(BOOL bShowIt/* = TRUE*/)
{
    SendMessageDx(CB_SHOWDROPDOWN, (WPARAM)bShowIt);
}

inline INT MComboBox::AddString(LPCTSTR lpszString)
{
    return (INT)SendMessageDx(CB_ADDSTRING, 0, (LPARAM)lpszString);
}

inline INT MComboBox::DeleteString(UINT nIndex)
{
    return (INT)SendMessageDx(CB_DELETESTRING, (WPARAM)nIndex);
}

inline INT MComboBox::InsertString(INT nIndex, LPCTSTR lpszString)
{
    return (INT)SendMessageDx(CB_INSERTSTRING, (WPARAM)nIndex, (LPARAM)lpszString);
}

inline VOID MComboBox::ResetContent()
{
    SendMessageDx(CB_RESETCONTENT);
}

inline INT MComboBox::Dir(UINT attr, LPCTSTR lpszWildCard)
{
    return (INT)SendMessageDx(CB_DIR, (WPARAM)attr, (LPARAM)lpszWildCard);
}

inline INT MComboBox::FindString(INT nStartAfter, LPCTSTR lpszString) const
{
    return (INT)SendMessageDx(CB_FINDSTRING, (WPARAM)nStartAfter, (LPARAM)lpszString);
}

inline INT MComboBox::SelectString(INT nStartAfter, LPCTSTR lpszString)
{
    return (INT)SendMessageDx(CB_SELECTSTRING, (WPARAM)nStartAfter, (LPARAM)lpszString);
}

inline VOID MComboBox::Clear()
{
    SendMessageDx(WM_CLEAR);
}

inline VOID MComboBox::Copy()
{
    SendMessageDx(WM_COPY);
}

inline VOID MComboBox::Cut()
{
    SendMessageDx(WM_CUT);
}

inline VOID MComboBox::Paste()
{
    SendMessageDx(WM_PASTE);
}

inline BOOL MComboBox::GetLBText(INT nIndex, MString& rString) const
{
    rString.clear();

    INT cch = GetLBTextLen(nIndex);
    if (cch == CB_ERR)
        return FALSE;

    rString.resize(cch);
    cch = GetLBText(nIndex, &rString[0]);
    if (cch == CB_ERR)
        rString.clear();
    return cch != CB_ERR;
}

////////////////////////////////////////////////////////////////////////////

#endif  // ndef MZC4_MCOMBOBOX_HPP_

```

`src/MComboBoxAutoComplete.hpp`:

```hpp
// MComboBoxAutoComplete.hpp -- Win32API autocomplete combo box -*- C++ -*-
// This file is part of MZC4.  See file "ReadMe.txt" and "License.txt".
////////////////////////////////////////////////////////////////////////////

#ifndef MZC4_MCOMBOBOXAUTOCOMP_HPP_
#define MZC4_MCOMBOBOXAUTOCOMP_HPP_     1   /* Version 1 */

class MComboBoxAutoComplete;

#include "MEditCtrl.hpp"
#include "MComboBox.hpp"

////////////////////////////////////////////////////////////////////////////

class MComboBoxEditAutoComplete : public MEditCtrl
{
public:
    MComboBoxEditAutoComplete() : m_bAutoComplete(FALSE)
    {
    }

    void OnKey(HWND hwnd, UINT vk, BOOL fDown, int cRepeat, UINT flags)
    {
        if (vk == VK_DELETE || vk == VK_BACK)
            m_bAutoComplete = FALSE;
        else
            m_bAutoComplete = TRUE;

        if (fDown)
        {
            FORWARD_WM_KEYDOWN(hwnd, vk, cRepeat, flags, DefaultProcDx);
        }
        else
        {
            FORWARD_WM_KEYUP(hwnd, vk, cRepeat, flags, DefaultProcDx);
        }
    }

    virtual LRESULT CALLBACK
    WindowProcDx(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
    {
        switch (uMsg)
        {
            HANDLE_MSG(hwnd, WM_KEYDOWN, OnKey);
            HANDLE_MSG(hwnd, WM_KEYUP, OnKey);
        }
        return DefaultProcDx();
    }

public:
    BOOL m_bAutoComplete;
};

class MComboBoxAutoComplete : public MComboBox
{
public:
    BOOL m_bAcceptSpace;

    MComboBoxAutoComplete() : m_bAcceptSpace(FALSE)
    {
    }

    virtual void PostSubclassDx(HWND hwnd)
    {
        HWND hEdit = FindWindowEx(hwnd, NULL, TEXT("EDIT"), NULL);
        m_edit.SubclassDx(hEdit);
    }

    void OnEditChange()
    {
        DWORD dwPos;
        OnEditChange(dwPos);
    }

    void OnEditChange(DWORD& dwPos)
    {
        if (!m_edit.m_bAutoComplete)
        {
            return;
        }

        MString strInput = GetWindowText();

        dwPos = GetEditSel();
        MString strRight = strInput.substr(HIWORD(dwPos));

        if (!m_bAcceptSpace)
            mstr_trim(strRight);

        if (!strRight.empty())
            return;

        if (!m_bAcceptSpace)
            mstr_trim(strInput);

        MString strInputUpper = strInput;
        CharUpperW(&strInputUpper[0]);

        INT iItem = FindString(-1, strInput.c_str());
        if (iItem == CB_ERR)
            return;

        TCHAR szText[128];
        GetLBText(iItem, szText);
        MString strCandidate = szText;

        INT nCount = GetCount();
        for (INT i = iItem + 1; i < nCount; ++i)
        {
            GetLBText(i, szText);
            MString strText = szText;
            CharUpperW(&strText[0]);
            if (strText.find(strInputUpper) == 0)
            {
                return;
            }
        }

        m_edit.m_bAutoComplete = FALSE;
        SetWindowText(strCandidate.c_str());
        SetEditSel(INT(strInput.size()), INT(strCandidate.size()));
        dwPos = MAKELONG(INT(strInput.size()), INT(strCandidate.size()));
    }

public:
    MComboBoxEditAutoComplete m_edit;
};

////////////////////////////////////////////////////////////////////////////

#endif  // ndef MZC4_MCOMBOBOXAUTOCOMP_HPP_

```

`src/MConfigDlg.hpp`:

```hpp
// MConfigDlg.hpp --- "Configuration" Dialog
//////////////////////////////////////////////////////////////////////////////
// RisohEditor --- Another free Win32 resource editor
// Copyright (C) 2017-2018 Katayama Hirofumi MZ <katayama.hirofumi.mz@gmail.com>
// 
// This program is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
// 
// This program is distributed in the hope that it will be useful, 
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
// 
// You should have received a copy of the GNU General Public License
// along with this program.  If not, see <http://www.gnu.org/licenses/>.
//////////////////////////////////////////////////////////////////////////////

#pragma once

#include "resource.h"
#include "MWindowBase.hpp"
#include "RisohSettings.hpp"
#include "ConstantsDB.hpp"
#include "MMacrosDlg.hpp"
#include "MPathsDlg.hpp"
#include "MFontsDlg.hpp"

//////////////////////////////////////////////////////////////////////////////

class MConfigDlg : public MDialogBase
{
public:
    MConfigDlg() : MDialogBase(IDD_CONFIG)
    {
    }

    void Reload(HWND hwnd)
    {
        CheckDlgButton(hwnd, chx1, g_settings.bShowFullPath ? BST_CHECKED : BST_UNCHECKED);
        CheckDlgButton(hwnd, chx2, g_settings.bHideID ? BST_CHECKED : BST_UNCHECKED);
        CheckDlgButton(hwnd, chx3, g_settings.bResumeWindowPos ? BST_CHECKED : BST_UNCHECKED);
        CheckDlgButton(hwnd, chx4, g_settings.bAutoLoadNearbyResH ? BST_CHECKED : BST_UNCHECKED);
        CheckDlgButton(hwnd, chx5, g_settings.bAutoShowIDList ? BST_CHECKED : BST_UNCHECKED);
        CheckDlgButton(hwnd, chx6, g_settings.bShowDotsOnDialog ? BST_CHECKED : BST_UNCHECKED);
        SetDlgItemInt(hwnd, edt1, g_settings.nComboHeight, FALSE);
        CheckDlgButton(hwnd, chx7, g_settings.bAskUpdateResH ? BST_CHECKED : BST_UNCHECKED);
        CheckDlgButton(hwnd, chx8, g_settings.bCompressByUPX ? BST_CHECKED : BST_UNCHECKED);
        CheckDlgButton(hwnd, chx9, g_settings.bWordWrap ? BST_CHECKED : BST_UNCHECKED);
        SetDlgItemText(hwnd, cmb1, g_settings.strAtlAxWin.c_str());

        CheckDlgButton(hwnd, chx10, g_settings.bBackup ? BST_CHECKED : BST_UNCHECKED);
        SendDlgItemMessageW(hwnd, cmb2, CB_ADDSTRING, 0, (LPARAM)L"-old");
        SendDlgItemMessageW(hwnd, cmb2, CB_ADDSTRING, 0, (LPARAM)L"-bak");
        SendDlgItemMessageW(hwnd, cmb2, CB_ADDSTRING, 0, (LPARAM)L"~");
        SetDlgItemTextW(hwnd, cmb2, g_settings.strBackupSuffix.c_str());
    }

    void Cmb1_AddString(HWND hwnd, LPCWSTR text)
    {
        if ((INT)SendDlgItemMessage(hwnd, cmb1, CB_FINDSTRINGEXACT, -1, (LPARAM)text) == CB_ERR)
        {
            SendDlgItemMessage(hwnd, cmb1, CB_ADDSTRING, 0, (LPARAM)text);
        }
    }

    BOOL OnInitDialog(HWND hwnd, HWND hwndFocus, LPARAM lParam)
    {
        SendDlgItemMessage(hwnd, scr1, UDM_SETRANGE, 0, MAKELPARAM(9999, -9999));
        Cmb1_AddString(hwnd, TEXT("AtlAxWin"));
        Cmb1_AddString(hwnd, TEXT("AtlAxWin71"));
        Cmb1_AddString(hwnd, TEXT("AtlAxWin80"));
        Cmb1_AddString(hwnd, TEXT("AtlAxWin90"));
        Cmb1_AddString(hwnd, TEXT("AtlAxWin100"));
        Cmb1_AddString(hwnd, TEXT("AtlAxWin110"));
#ifdef ATL_SUPPORT
        Cmb1_AddString(hwnd, TEXT(ATLAXWIN_CLASS));
#endif

        Reload(hwnd);
        CenterWindowDx();
        return TRUE;
    }

    void OnOK(HWND hwnd)
    {
        BOOL bTranslated = FALSE;
        INT nHeight = GetDlgItemInt(hwnd, edt1, &bTranslated, FALSE);
        if (!bTranslated)
        {
            HWND hEdt1 = GetDlgItem(hwnd, edt1);
            Edit_SetSel(hEdt1, 0, -1);
            SetFocus(hEdt1);
            ErrorBoxDx(IDS_ENTERINT);
            return;
        }
        g_settings.nComboHeight = nHeight;

        g_settings.bShowFullPath = (IsDlgButtonChecked(hwnd, chx1) == BST_CHECKED);
        g_settings.bHideID = (IsDlgButtonChecked(hwnd, chx2) == BST_CHECKED);
        g_settings.bResumeWindowPos = (IsDlgButtonChecked(hwnd, chx3) == BST_CHECKED);
        g_settings.bAutoLoadNearbyResH = (IsDlgButtonChecked(hwnd, chx4) == BST_CHECKED);
        g_settings.bAutoShowIDList = (IsDlgButtonChecked(hwnd, chx5) == BST_CHECKED);
        g_settings.bShowDotsOnDialog = (IsDlgButtonChecked(hwnd, chx6) == BST_CHECKED);
        g_settings.bAskUpdateResH = (IsDlgButtonChecked(hwnd, chx7) == BST_CHECKED);
        g_settings.bCompressByUPX = (IsDlgButtonChecked(hwnd, chx8) == BST_CHECKED);
        g_settings.bWordWrap = (IsDlgButtonChecked(hwnd, chx9) == BST_CHECKED);

        WCHAR szText[64];
        GetDlgItemTextW(hwnd, cmb1, szText, _countof(szText));
        mstr_trim(szText);
        g_settings.strAtlAxWin = szText;

        g_settings.bBackup = (IsDlgButtonChecked(hwnd, chx10) == BST_CHECKED);

        GetDlgItemTextW(hwnd, cmb2, szText, _countof(szText));
        mstr_trim(szText);
        g_settings.strBackupSuffix = szText;

        if (szText[0] == 0)
            g_settings.bBackup = FALSE;

        EndDialog(IDOK);
    }

    void OnPsh1(HWND hwnd)
    {
        MMacrosDlg dialog;
        dialog.DialogBoxDx(hwnd);
    }

    void OnPsh2(HWND hwnd)
    {
        MPathsDlg dialog;
        dialog.DialogBoxDx(hwnd);
    }

    void OnPsh3(HWND hwnd)
    {
        SendMessage(GetParent(hwnd), WM_COMMAND, ID_SETDEFAULTS, 0);
        Reload(hwnd);
        EndDialog(hwnd, IDOK);
    }

    void OnPsh4(HWND hwnd)
    {
        MFontsDlg dialog;
        dialog.DialogBoxDx(hwnd);
    }

    void OnCommand(HWND hwnd, int id, HWND hwndCtl, UINT codeNotify)
    {
        switch (id)
        {
        case IDOK:
            OnOK(hwnd);
            break;
        case IDCANCEL:
            EndDialog(hwnd, IDCANCEL);
            break;
        case psh1:
            OnPsh1(hwnd);
            break;
        case psh2:
            OnPsh2(hwnd);
            break;
        case psh3:
            OnPsh3(hwnd);
            break;
        case psh4:
            OnPsh4(hwnd);
            break;
        }
    }

    virtual INT_PTR CALLBACK
    DialogProcDx(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
    {
        switch (uMsg)
        {
            DO_MSG(WM_INITDIALOG, OnInitDialog);
            DO_MSG(WM_COMMAND, OnCommand);
        }
        return DefaultProcDx();
    }
};

```

`src/MConstantDlg.hpp`:

```hpp
// MConstantDlg.hpp --- "Query Constant" Dialog
//////////////////////////////////////////////////////////////////////////////
// RisohEditor --- Another free Win32 resource editor
// Copyright (C) 2017-2018 Katayama Hirofumi MZ <katayama.hirofumi.mz@gmail.com>
// 
// This program is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
// 
// This program is distributed in the hope that it will be useful, 
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
// 
// You should have received a copy of the GNU General Public License
// along with this program.  If not, see <http://www.gnu.org/licenses/>.
//////////////////////////////////////////////////////////////////////////////

#pragma once

#include "resource.h"
#include "MWindowBase.hpp"
#include "MString.hpp"
#include "RisohSettings.hpp"
#include "MComboBoxAutoComplete.hpp"
#include "ConstantsDB.hpp"
#include "Common.hpp"

class MConstantDlg;

//////////////////////////////////////////////////////////////////////////////

class MConstantDlg : public MDialogBase
{
public:
    MComboBoxAutoComplete m_cmb1;

    MConstantDlg() : MDialogBase(IDD_CONSTANT)
    {
    }

    virtual ~MConstantDlg()
    {
    }

    BOOL OnInitDialog(HWND hwnd, HWND hwndFocus, LPARAM lParam)
    {
        HWND hCmb1 = GetDlgItem(hwnd, cmb1);
        InitConstantComboBox(hCmb1);
        SubclassChildDx(m_cmb1, cmb1);

        CenterWindowDx();
        return TRUE;
    }

    void OnCommand(HWND hwnd, int id, HWND hwndCtl, UINT codeNotify)
    {
        switch (id)
        {
        case IDOK:
        case IDCANCEL:
            EndDialog(id);
            break;
        case cmb1:
            if (codeNotify == CBN_EDITCHANGE)
            {
                m_cmb1.OnEditChange();
            }
            {
                MStringW name;
                if (codeNotify == CBN_SELCHANGE)
                {
                    INT iItem = (INT)SendMessageW(m_cmb1, CB_GETCURSEL, 0, 0);
                    WCHAR szText[128];
                    SendMessageW(m_cmb1, CB_GETLBTEXT, iItem, (LPARAM)szText);
                    name = szText;
                }
                else
                {
                    name = GetDlgItemText(hwnd, cmb1);
                }
                mstr_trim(name);

                ConstantsDB::ValueType value;
                BOOL bOK = g_db.GetValueOfName(name, value);
                if (!bOK)
                {
                    for (auto& pair : g_settings.id_map)
                    {
                        MAnsiToWide wide(CP_ACP, pair.first.c_str());

                        if (name == wide.c_str())
                        {
                            value = strtol(pair.second.c_str(), NULL, 0);
                            bOK = TRUE;
                            break;
                        }
                    }
                }
                if (bOK)
                {
                    SetDlgItemInt(hwnd, edt2, value, FALSE);

                    WCHAR szText[64];
                    StringCbPrintfW(szText, sizeof(szText), L"0x%08lX", value);
                    SetDlgItemText(hwnd, edt3, szText);
                }
                else
                {
                    SetDlgItemTextW(hwnd, edt2, L"");
                    SetDlgItemText(hwnd, edt3, L"");
                }
            }
            break;
        }
    }

    virtual INT_PTR CALLBACK
    DialogProcDx(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
    {
        switch (uMsg)
        {
            HANDLE_MSG(hwnd, WM_INITDIALOG, OnInitDialog);
            HANDLE_MSG(hwnd, WM_COMMAND, OnCommand);
        }
        return 0;
    }
};

```

`src/MCopyToMultiLangDlg.hpp`:

```hpp
// MCopyToMultiLangDlg.hpp --- "Copy to multiple languages" Dialog
//////////////////////////////////////////////////////////////////////////////
// RisohEditor --- Another free Win32 resource editor
// Copyright (C) 2017-2018 Katayama Hirofumi MZ <katayama.hirofumi.mz@gmail.com>
// 
// This program is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
// 
// This program is distributed in the hope that it will be useful, 
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
// 
// You should have received a copy of the GNU General Public License
// along with this program.  If not, see <http://www.gnu.org/licenses/>.
//////////////////////////////////////////////////////////////////////////////

#pragma once

#include "resource.h"
#include "MWindowBase.hpp"
#include "ConstantsDB.hpp"
#include "Res.hpp"
#include "MComboBoxAutoComplete.hpp"
#include "MLangAutoComplete.hpp"
#include "Common.hpp"

//////////////////////////////////////////////////////////////////////////////

class MCopyToMultiLangDlg : public MDialogBase
{
public:
    EntryBase *m_entry;
    MIdOrString m_type;
    MIdOrString m_name;
    WORD m_lang;
    MComboBoxAutoComplete m_cmb3;
    std::vector<LANGID> m_langs;
    MLangAutoComplete *m_pAutoComplete;

    MCopyToMultiLangDlg(EntryBase* entry)
        : MDialogBase(IDD_COPYTOMULTILANG), m_entry(entry),
          m_type(entry->m_type), m_name(entry->m_name), m_lang(entry->m_lang),
          m_pAutoComplete(new MLangAutoComplete())
    {
        m_cmb3.m_bAcceptSpace = TRUE;
        m_pAutoComplete->AddRef();
    }

    ~MCopyToMultiLangDlg()
    {
        m_pAutoComplete->unbind();
        m_pAutoComplete->Release();
        m_pAutoComplete = NULL;
    }

    virtual INT_PTR CALLBACK
    DialogProcDx(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
    {
        switch (uMsg)
        {
            HANDLE_MSG(hwnd, WM_INITDIALOG, OnInitDialog);
            HANDLE_MSG(hwnd, WM_COMMAND, OnCommand);
            HANDLE_MSG(hwnd, WM_VKEYTOITEM, OnVKeyToItem);
        }
        return DefaultProcDx(hwnd, uMsg, wParam, lParam);
    }

    int OnVKeyToItem(HWND hwnd, UINT vk, HWND hwndListbox, int iCaret)
    {
        if (vk == VK_DELETE)
        {
            OnDelete(hwnd);
        }
        return SetDlgMsgResult(hwnd, WM_VKEYTOITEM, -1);
    }

    BOOL OnInitDialog(HWND hwnd, HWND hwndFocus, LPARAM lParam)
    {
        // for Langs
        HWND hCmb3 = GetDlgItem(hwnd, cmb3);
        InitLangComboBox(hCmb3, BAD_LANG);
        SubclassChildDx(m_cmb3, cmb3);

        // auto complete
        COMBOBOXINFO info = { sizeof(info) };
        GetComboBoxInfo(m_cmb3, &info);
        HWND hwndEdit = info.hwndItem;
        m_pAutoComplete->bind(hwndEdit);

        CenterWindowDx();
        return TRUE;
    }

    void OnOK(HWND hwnd)
    {
        HWND hLst1 = GetDlgItem(hwnd, lst1);

        m_langs.clear();

        INT nCount = ListBox_GetCount(hLst1);
        if (nCount == 0)
        {
            MsgBoxDx(IDS_NOSELECTION, MB_ICONERROR);
            return;
        }

        WCHAR szText[MAX_PATH];
        for (INT iItem = 0; iItem < nCount; ++iItem)
        {
            ListBox_GetText(hLst1, iItem, szText);
            WORD wLang = LangFromText(szText);
            m_langs.push_back(wLang);
        }

        BOOL bOverwrite = FALSE;
        for (auto lang : m_langs)
        {
            if (!bOverwrite && g_res.find(ET_LANG, m_type, m_name, lang))
            {
                if (MsgBoxDx(IDS_EXISTSOVERWRITE, MB_ICONINFORMATION | MB_YESNOCANCEL) != IDYES)
                {
                    return;
                }
                bOverwrite = TRUE;
            }
        }

        EndDialog(IDOK);
    }

    void OnAddItem(HWND hwnd)
    {
        WCHAR szText[MAX_PATH];
        HWND hCmb3 = GetDlgItem(hwnd, cmb3);
        INT iItem = ComboBox_GetCurSel(hCmb3);
        if (iItem == CB_ERR)
            GetDlgItemTextW(hwnd, cmb3, szText, _countof(szText));
        else
            ComboBox_GetLBText(hCmb3, iItem, szText);

        std::wstring str = szText;
        mstr_trim(str);
        if (str.empty())
        {
            MsgBoxDx(IDS_INVALIDLANG, MB_ICONERROR);
            return;
        }

        StringCchCopyW(szText, _countof(szText), str.c_str());
        WORD wLang = LangFromText(szText);
        if (wLang != BAD_LANG)
        {
            HWND hLst1 = GetDlgItem(hwnd, lst1);
            str = TextFromLang(wLang);
            INT iItem = ListBox_FindStringExact(hLst1, -1, str.c_str());
            if (iItem == LB_ERR)
            {
                iItem = ListBox_AddString(hLst1, str.c_str());
            }
            ListBox_SelItemRange(hLst1, TRUE, iItem, iItem);
            SetDlgItemTextW(hwnd, cmb3, NULL);
        }
        else
        {
            MsgBoxDx(IDS_INVALIDLANG, MB_ICONERROR);
        }
    }

    void OnDelete(HWND hwnd)
    {
        HWND hLst1 = GetDlgItem(hwnd, lst1);

        INT iItem = ListBox_GetCurSel(hLst1);
        if (iItem == LB_ERR)
            return;

        ListBox_DeleteString(hLst1, iItem);

        INT nCount = ListBox_GetCount(hLst1);
        if (iItem == nCount)
            --iItem;

        ListBox_SetCurSel(hLst1, iItem);
    }

    void OnCommand(HWND hwnd, int id, HWND hwndCtl, UINT codeNotify)
    {
        switch (id)
        {
        case IDOK:
            OnOK(hwnd);
            break;
        case IDCANCEL:
            EndDialog(IDCANCEL);
            break;
        case psh1:
            OnAddItem(hwnd);
            break;
        case cmb3:
            if (codeNotify == CBN_EDITCHANGE)
            {
                m_cmb3.OnEditChange();
            }
            break;
        }
    }
};

```

`src/MCtrlDataDlg.hpp`:

```hpp
// MCtrlDataDlg.hpp --- "Edit Control Data" Dialog
//////////////////////////////////////////////////////////////////////////////
// RisohEditor --- Another free Win32 resource editor
// Copyright (C) 2017-2018 Katayama Hirofumi MZ <katayama.hirofumi.mz@gmail.com>
// 
// This program is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
// 
// This program is distributed in the hope that it will be useful, 
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
// 
// You should have received a copy of the GNU General Public License
// along with this program.  If not, see <http://www.gnu.org/licenses/>.
//////////////////////////////////////////////////////////////////////////////

#pragma once

#include "resource.h"
#include "MWindowBase.hpp"
#include "MFile.hpp"

//////////////////////////////////////////////////////////////////////////////

class MCtrlDataDlg : public MDialogBase
{
public:
    std::vector<BYTE>& m_data;

    MCtrlDataDlg(std::vector<BYTE>& data)
        : MDialogBase(IDD_CTRLDATA), m_data(data)
    {
    }

    BOOL OnInitDialog(HWND hwnd, HWND hwndFocus, LPARAM lParam)
    {
        DragAcceptFiles(hwnd, TRUE);

        UpdateData(hwnd);

        CenterWindowDx();
        return TRUE;
    }

    void OnOK(HWND hwnd)
    {
        MString str = GetDlgItemText(edt1);

        std::vector<MString> vec;
        mstr_split(vec, str, TEXT(" \t\n\r\f\v, "));

        if (vec.size() > 0x10000 / sizeof(WORD))
        {
            ErrorBoxDx(IDS_DATATOOLONG);
            return;
        }

        std::vector<WORD> words;
        for (size_t i = 0; i < vec.size(); ++i)
        {
            mstr_trim(vec[i]);
            if (vec[i].empty())
                continue;

            words.push_back(mstr_parse_int(vec[i].c_str(), true));
        }

        m_data.clear();
        if (words.size())
        {
            BYTE *pb0 = (BYTE *)&words[0];
            BYTE *pb1 = (BYTE *)(&words[0] + words.size());
            m_data.assign(pb0, pb1);
        }

        EndDialog(IDOK);
    }

    void UpdateData(HWND hwnd)
    {
        MString str;
        if (m_data.size() >= 2)
        {
            auto pw = (const WORD *)&m_data[0];
            for (size_t i = 0; i < m_data.size() / 2; ++i)
            {
                str += mstr_hex_word(*pw++);
                str += L" ";
            }
        }
        SetDlgItemTextW(hwnd, edt1, str.c_str());
    }

    void OnCommand(HWND hwnd, int id, HWND hwndCtl, UINT codeNotify)
    {
        switch (id)
        {
        case IDOK:
            OnOK(hwnd);
            break;
        case IDCANCEL:
            EndDialog(IDCANCEL);
            break;
        }
    }

    void OnDropFiles(HWND hwnd, HDROP hdrop)
    {
        WCHAR szFile[MAX_PATH];
        DragQueryFileW(hdrop, 0, szFile, _countof(szFile));

        std::string str;

        MFile file(szFile);

        if (!file)
            return;

        CHAR buf[512];
        DWORD cbRead;
        while (file.ReadFile(buf, 512, &cbRead) && cbRead)
        {
            str.append(buf, cbRead);
        }
        file.CloseHandle();

        m_data.clear();
        if (str.size() >= 2)
        {
            BYTE *pb0 = (BYTE *)&str[0];
            BYTE *pb1 = (BYTE *)(&str[0] + str.size() / 2 * 2);
            m_data.assign(pb0, pb1);
        }

        UpdateData(hwnd);
    }

    virtual INT_PTR CALLBACK
    DialogProcDx(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
    {
        switch (uMsg)
        {
            HANDLE_MSG(hwnd, WM_INITDIALOG, OnInitDialog);
            HANDLE_MSG(hwnd, WM_DROPFILES, OnDropFiles);
            HANDLE_MSG(hwnd, WM_COMMAND, OnCommand);
        }
        return DefaultProcDx();
    }
};

```

`src/MCtrlPropDlg.hpp`:

```hpp
// MCtrlPropDlg.hpp --- "Properties for Control" Dialog
//////////////////////////////////////////////////////////////////////////////
// RisohEditor --- Another free Win32 resource editor
// Copyright (C) 2017-2018 Katayama Hirofumi MZ <katayama.hirofumi.mz@gmail.com>
// 
// This program is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
// 
// This program is distributed in the hope that it will be useful, 
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
// 
// You should have received a copy of the GNU General Public License
// along with this program.  If not, see <http://www.gnu.org/licenses/>.
//////////////////////////////////////////////////////////////////////////////

#pragma once

#include "resource.h"
#include "MToolBarCtrl.hpp"
#include "RisohSettings.hpp"
#include "ConstantsDB.hpp"
#include "MComboBoxAutoComplete.hpp"
#include "MCtrlDataDlg.hpp"
#include "MStringListDlg.hpp"
#include "DialogRes.hpp"
#include "MString.hpp"
#include "Common.hpp"

#include <unordered_set>     // for std::unordered_set
#include <oledlg.h>

//////////////////////////////////////////////////////////////////////////////

class MCtrlPropDlg : public MDialogBase
{
public:
    enum Flags
    {
        F_NONE = 0, 
        F_HELP = 0x0001, 
        F_STYLE = 0x0002, 
        F_EXSTYLE = 0x0004, 
        F_X = 0x0008, 
        F_Y = 0x0010, 
        F_CX = 0x0020, 
        F_CY = 0x0040, 
        F_ID = 0x0080, 
        F_CLASS = 0x0100, 
        F_TITLE = 0x0200, 
        F_EXTRA = 0x0400, 
        F_SLIST = 0x0800, 
        F_ALL = 0x0FFF
    };
    DialogRes&          m_dialog_res;
    BOOL                m_bUpdating;
    std::unordered_set<INT>       m_indeces;
    DWORD               m_flags;
    DWORD               m_dwStyle;
    DWORD               m_dwExStyle;
    DialogItem          m_item;
    ConstantsDB::TableType  m_style_table;
    ConstantsDB::TableType  m_exstyle_table;
    std::vector<BYTE>       m_style_selection;
    std::vector<BYTE>       m_exstyle_selection;
    MToolBarCtrl            m_hTB;
    HIMAGELIST              m_himlControls;
    std::vector<std::wstring> m_vecControls;
    MComboBoxAutoComplete m_cmb1;
    MComboBoxAutoComplete m_cmb2;
    MComboBoxAutoComplete m_cmb3;
    MComboBoxAutoComplete m_cmb4;
    MComboBoxAutoComplete m_cmb5;

    MCtrlPropDlg(DialogRes& dialog_res, const std::unordered_set<INT>& indeces)
        : MDialogBase(IDD_CTRLPROP), m_dialog_res(dialog_res), 
          m_bUpdating(FALSE), m_indeces(indeces)
    {
        m_himlControls = NULL;
        m_cmb2.m_bAcceptSpace = TRUE;
        m_cmb4.m_bAcceptSpace = TRUE;
    }

    ~MCtrlPropDlg()
    {
        if (m_himlControls)
        {
            ImageList_Destroy(m_himlControls);
            m_himlControls = NULL;
        }
    }

    void GetInfo()
    {
        if (m_indeces.empty())
            return;

        m_flags = F_ALL;
        auto end = m_indeces.end();
        auto it = m_indeces.begin();
        {
            DialogItem& item = m_dialog_res[*it];
            m_item = item;
        }
        for (++it; it != end; ++it)
        {
            DialogItem& item = m_dialog_res[*it];
            if (m_item.m_help_id != item.m_help_id)
                m_flags &= ~F_HELP;
            if (m_item.m_style != item.m_style)
                m_flags &= ~F_STYLE;
            if (m_item.m_ex_style != item.m_ex_style)
                m_flags &= ~F_EXSTYLE;
            if (m_item.m_pt.x != item.m_pt.x)
                m_flags &= ~F_X;
            if (m_item.m_pt.y != item.m_pt.y)
                m_flags &= ~F_Y;
            if (m_item.m_siz.cx != item.m_siz.cx)
                m_flags &= ~F_CX;
            if (m_item.m_siz.cy != item.m_siz.cy)
                m_flags &= ~F_CY;
            if (m_item.m_id != item.m_id)
                m_flags &= ~F_ID;
            if (m_item.m_class != item.m_class)
                m_flags &= ~F_CLASS;
            if (m_item.m_title != item.m_title)
                m_flags &= ~F_TITLE;
        }

        if (m_flags & F_CLASS)
        {
            if (m_item.m_class.is_int())
            {
                std::wstring cls;
                if (IDToPredefClass(m_item.m_class.m_id, cls))
                    m_item.m_class = cls.c_str();
            }
        }
    }

    DWORD GetItemAndFlags(DialogItem& item)
    {
        DWORD flags = m_flags;

        MString strCaption = GetDlgItemText(cmb2);
        if (!strCaption.empty())
            flags |= F_TITLE;
        g_settings.AddCaption(strCaption.c_str());
        if (strCaption[0] == TEXT('"'))
            mstr_unquote(strCaption);
        item.m_title = strCaption.c_str();

        MString strX = GetDlgItemText(edt1);
        mstr_trim(strX);
        if (!strX.empty())
            flags |= F_X;
        item.m_pt.x = mstr_parse_int(strX.c_str());

        MString strY = GetDlgItemText(edt2);
        mstr_trim(strY);
        if (!strY.empty())
            flags |= F_Y;
        item.m_pt.y = mstr_parse_int(strY.c_str());

        MString strCX = GetDlgItemText(edt3);
        mstr_trim(strCX);
        if (!strCX.empty())
            flags |= F_CX;
        item.m_siz.cx = mstr_parse_int(strCX.c_str());

        MString strCY = GetDlgItemText(edt4);
        mstr_trim(strCY);
        if (!strCY.empty())
            flags |= F_CY;
        item.m_siz.cy = mstr_parse_int(strCY.c_str());

        MString strID = GetDlgItemText(cmb3);
        mstr_trim(strID);
        UINT id = 0;
        if ((TEXT('0') <= strID[0] && strID[0] <= TEXT('9')) ||
            strID[0] == TEXT('-') || strID[0] == TEXT('+'))
        {
            id = mstr_parse_int(strID.c_str());
            flags |= F_ID;
        }
        else if (g_db.HasCtrlID(strID))
        {
            id = g_db.GetCtrlIDValue(strID);
            flags |= F_ID;
        }
        else if (g_db.HasResID(strID))
        {
            id = g_db.GetResIDValue(strID);
            flags |= F_ID;
        }
        else if (!strID.empty() && m_indeces.size() <= 1)
        {
            HWND hCmb3 = GetDlgItem(m_hwnd, cmb3);
            ComboBox_SetEditSel(hCmb3, 0, -1);
            SetFocus(hCmb3);
            ErrorBoxDx(IDS_NOSUCHID);
            return 0xFFFFFFFF;
        }
        if (flags & F_ID)
            item.m_id = (WORD)id;
        else
            item.m_id = 0;

        MString strClass = GetDlgItemText(cmb4);
        mstr_trim(strClass);
        if (strClass[0] == TEXT('"'))
        {
            mstr_unquote(strClass);
        }
        if (!strClass.empty())
            flags |= F_CLASS;
        item.m_class = strClass.c_str();

        MString strHelp = GetDlgItemText(cmb5);
        ReplaceFullWithHalf(strHelp);
        mstr_trim(strHelp);
        if (!strHelp.empty())
            flags |= F_HELP;
        if (g_db.HasResID(strHelp))
        {
            item.m_help_id = g_db.GetResIDValue(strHelp);
        }
        else
        {
            item.m_help_id = mstr_parse_int(strHelp.c_str());
        }

        MString strStyle = GetDlgItemText(edt6);
        ReplaceFullWithHalf(strStyle);
        mstr_trim(strStyle);
        if (!strStyle.empty())
            flags |= F_STYLE;
        item.m_style = mstr_parse_int(strStyle.c_str(), false, 16);

        MString strExStyle = GetDlgItemText(edt7);
        mstr_trim(strExStyle);
        if (!strExStyle.empty())
            flags |= F_EXSTYLE;
        item.m_ex_style = mstr_parse_int(strExStyle.c_str(), false, 16);

        flags |= F_EXTRA;

        if (!item.m_str_list.empty())
            flags |= F_SLIST;

        return flags;
    }

    BOOL SetInfo(DWORD flags)
    {
        if (m_indeces.empty())
            return TRUE;

        for (auto& index : m_indeces)
        {
            DialogItem& item = m_dialog_res[index];
            if ((m_flags & F_HELP) || (flags & F_HELP))
                item.m_help_id = m_item.m_help_id;
            if ((m_flags & F_STYLE) || (flags & F_STYLE))
                item.m_style = m_item.m_style;
            if ((m_flags & F_EXSTYLE) || (flags & F_EXSTYLE))
                item.m_ex_style = m_item.m_ex_style;
            if ((m_flags & F_X) || (flags & F_X))
                item.m_pt.x = m_item.m_pt.x;
            if ((m_flags & F_Y) || (flags & F_Y))
                item.m_pt.y = m_item.m_pt.y;
            if ((m_flags & F_CX) || (flags & F_CX))
                item.m_siz.cx = m_item.m_siz.cx;
            if ((m_flags & F_CY) || (flags & F_CY))
                item.m_siz.cy = m_item.m_siz.cy;
            if ((m_flags & F_ID) || (flags & F_ID))
                item.m_id = m_item.m_id;
            if ((m_flags & F_CLASS) || (flags & F_CLASS))
            {
                item.m_class = m_item.m_class;
                if (!IsThereWndClass(item.m_class.c_str()))
                {
                    HWND hCmb4 = GetDlgItem(m_hwnd, cmb4);
                    ComboBox_SetEditSel(hCmb4, 0, -1);
                    SetFocus(hCmb4);
                    ErrorBoxDx(IDS_ENTERCLASS);
                    return FALSE;
                }
            }
            if ((m_flags & F_TITLE) || (flags & F_TITLE))
            {
                item.m_title = m_item.m_title;
            }
            if ((m_flags & F_EXTRA) || (flags & F_EXTRA))
            {
                item.m_extra = m_item.m_extra;
            }
            if ((m_flags & F_SLIST) || (flags & F_SLIST))
            {
                if (m_item.IsStdComboBox() || m_item.IsListBox() || m_item.IsExtComboBox())
                {
                    item.m_str_list = m_item.m_str_list;
                }
                else
                {
                    item.m_str_list.clear();
                }
            }
            if (lstrcmpiW(item.m_class.c_str(), L"STATIC") == 0)
            {
                DWORD style = item.m_style;
                if ((style & SS_TYPEMASK) == SS_ICON ||
                    (style & SS_TYPEMASK) == SS_BITMAP)
                {
                    if (mchr_is_digit(item.m_title.str()[0]))
                    {
                        LONG n = mstr_parse_int(item.m_title.c_str());
                        item.m_title = WORD(n);
                    }
                }
            }
        }

        return TRUE;
    }

    void InitTables(LPCTSTR pszClass)
    {
        m_style_table.clear();
        if (pszClass && pszClass[0])
        {
            auto table = g_db.GetTable(pszClass);
            if (table.size())
            {
                m_style_table.insert(m_style_table.end(), 
                    table.begin(), table.end());
            }
        }
        auto table = g_db.GetTable(TEXT("STYLE"));
        if (table.size())
        {
            m_style_table.insert(m_style_table.end(), 
                table.begin(), table.end());
        }
        m_style_selection.resize(m_style_table.size());

        m_exstyle_table.clear();
        table = g_db.GetTable(TEXT("EXSTYLE"));
        if (table.size())
        {
            m_exstyle_table.insert(m_exstyle_table.end(), 
                table.begin(), table.end());
        }
        m_exstyle_selection.resize(m_exstyle_table.size());
    }

    void ApplySelection(HWND hLst, std::vector<BYTE>& sel)
    {
        m_bUpdating = TRUE;
        INT iTop = ListBox_GetTopIndex(hLst);
        for (size_t i = 0; i < sel.size(); ++i)
        {
            ListBox_SetSel(hLst, sel[i], (DWORD)i);
        }
        ListBox_SetTopIndex(hLst, iTop);
        m_bUpdating = FALSE;
    }

    void ApplySelection(HWND hLst, ConstantsDB::TableType& table, 
                        std::vector<BYTE>& sel, DWORD dwValue)
    {
        m_bUpdating = TRUE;
        INT iTop = ListBox_GetTopIndex(hLst);
        for (size_t i = 0; i < table.size(); ++i)
        {
            sel[i] = ((dwValue & table[i].mask) == table[i].value);
            ListBox_SetSel(hLst, sel[i], (DWORD)i);
        }
        ListBox_SetTopIndex(hLst, iTop);
        m_bUpdating = FALSE;
    }

    void InitToolBar()
    {
        std::vector<TBBUTTON> buttons;

        ConstantsDB::TableType table = g_db.GetTable(TEXT("CONTROLS.ICONS"));
        size_t count = table.size();
        UINT nCount = UINT(count);

        m_vecControls.clear();
        if (m_himlControls)
        {
            ImageList_Destroy(m_himlControls);
            m_himlControls = NULL;
        }
        m_himlControls = ImageList_LoadBitmap(
            GetModuleHandle(NULL), MAKEINTRESOURCE(IDB_CONTROLS), 
            16, 0, RGB(255, 0, 255));
        m_hTB.SetImageList(m_himlControls);

        buttons.resize(nCount);
        for (UINT i = 0; i < nCount; ++i)
        {
            buttons[i].iBitmap = i;
            buttons[i].idCommand = i + 1000;
            buttons[i].fsState = TBSTATE_ENABLED;
            buttons[i].fsStyle = TBSTYLE_BUTTON;
            buttons[i].iString = 0;
            m_vecControls.push_back(table[i].name);
        }
        m_hTB.AddButtons(nCount, &buttons[0]);
    }

    BOOL OnInitDialog(HWND hwnd, HWND hwndFocus, LPARAM lParam)
    {
        SubclassChildDx(m_hTB, ctl1);
        InitToolBar();

        HWND hCmb1 = GetDlgItem(hwnd, cmb1);
        InitClassComboBox(hCmb1, TEXT(""));
        SubclassChildDx(m_cmb1, cmb1);

        HWND hCmb2 = GetDlgItem(hwnd, cmb2);
        InitCaptionComboBox(hCmb2, TEXT(""));
        SubclassChildDx(m_cmb2, cmb2);

        HWND hCmb3 = GetDlgItem(hwnd, cmb3);
        InitCtrlIDComboBox(hCmb3);
        SubclassChildDx(m_cmb3, cmb3);

        HWND hCmb5 = GetDlgItem(hwnd, cmb5);
        InitResNameComboBox(hCmb5, WORD(0), IDTYPE_HELP);
        SubclassChildDx(m_cmb5, cmb5);

        GetInfo();

        if (m_flags & F_CLASS)
        {
            InitTables(m_item.m_class.c_str());
        }
        else
        {
            InitTables(NULL);
        }

        HWND hCmb4 = GetDlgItem(hwnd, cmb4);
        InitWndClassComboBox(hCmb4, m_item.m_class.c_str());
        SubclassChildDx(m_cmb4, cmb4);

        TCHAR szText[64];

        HWND hLst1 = GetDlgItem(hwnd, lst1);
        if (m_flags & F_STYLE)
            m_dwStyle = m_item.m_style;
        else
            m_dwStyle = 0;
        GetStyleSelect(m_style_selection, m_style_table, m_dwStyle);
        InitStyleListBox(hLst1, m_style_table);
        ApplySelection(hLst1, m_style_table, m_style_selection, m_dwStyle);

        if (m_flags & F_STYLE)
        {
            m_bUpdating = TRUE;
            StringCchPrintf(szText, _countof(szText), TEXT("%08lX"), m_dwStyle);
            SetDlgItemText(hwnd, edt6, szText);
            SendDlgItemMessage(hwnd, edt6, EM_SETLIMITTEXT, 8, 0);
            m_bUpdating = FALSE;
        }

        HWND hLst2 = GetDlgItem(hwnd, lst2);
        if (m_flags & F_EXSTYLE)
            m_dwExStyle = m_item.m_ex_style;
        else
            m_dwExStyle = 0;
        GetStyleSelect(m_exstyle_selection, m_exstyle_table, m_dwExStyle);
        InitStyleListBox(hLst2, m_exstyle_table);
        ApplySelection(hLst2, m_exstyle_table, m_exstyle_selection, m_dwExStyle);

        if (m_flags & F_EXSTYLE)
        {
            m_bUpdating = TRUE;
            StringCchPrintf(szText, _countof(szText), TEXT("%08lX"), m_dwExStyle);
            SetDlgItemText(hwnd, edt7, szText);
            SendDlgItemMessage(hwnd, edt7, EM_SETLIMITTEXT, 8, 0);
            m_bUpdating = FALSE;
        }

        if (m_flags & F_HELP)
        {
            MStringW name = g_db.GetNameOfResID(IDTYPE_HELP, m_item.m_help_id);
            SetDlgItemTextW(hwnd, cmb5, name.c_str());
        }
        if (m_flags & F_X)
        {
            SetDlgItemInt(hwnd, edt1, m_item.m_pt.x, TRUE);
        }
        if (m_flags & F_Y)
        {
            SetDlgItemInt(hwnd, edt2, m_item.m_pt.y, TRUE);
        }
        if (m_flags & F_CX)
        {
            SetDlgItemInt(hwnd, edt3, m_item.m_siz.cx, TRUE);
        }
        if (m_flags & F_CY)
        {
            SetDlgItemInt(hwnd, edt4, m_item.m_siz.cy, TRUE);
        }
        if (m_flags & F_ID)
        {
            MStringW name = g_db.GetNameOfResID(IDTYPE_CONTROL, m_item.m_id);
            SetDlgItemTextW(hwnd, cmb3, name.c_str());
        }
        if (m_flags & F_CLASS)
        {
            SetDlgItemText(hwnd, cmb4, m_item.m_class.c_str());
        }
        if (m_flags & F_TITLE)
        {
            MString strCaption;
            if (!m_item.m_title.empty())
            {
                if (m_item.m_title.is_int())
                    strCaption = m_item.m_title.c_str();
                else
                    strCaption = m_item.m_title.quoted_wstr();
            }
            SetDlgItemText(hwnd, cmb2, strCaption.c_str());
        }

        if (!m_dialog_res.IsExtended())
            EnableWindow(GetDlgItem(hwnd, psh1), FALSE);

        SendDlgItemMessage(hwnd, scr1, UDM_SETRANGE, 0, MAKELPARAM(9999, -9999));
        SendDlgItemMessage(hwnd, scr2, UDM_SETRANGE, 0, MAKELPARAM(9999, -9999));
        SendDlgItemMessage(hwnd, scr3, UDM_SETRANGE, 0, MAKELPARAM(9999, -9999));
        SendDlgItemMessage(hwnd, scr4, UDM_SETRANGE, 0, MAKELPARAM(9999, -9999));

        if (!(m_flags & F_X))
        {
            SetDlgItemTextW(hwnd, edt1, NULL);
        }
        if (!(m_flags & F_Y))
        {
            SetDlgItemTextW(hwnd, edt2, NULL);
        }
        if (!(m_flags & F_CX))
        {
            SetDlgItemTextW(hwnd, edt3, NULL);
        }
        if (!(m_flags & F_CY))
        {
            SetDlgItemTextW(hwnd, edt4, NULL);
        }
        if (!m_item.IsStdComboBox() && !m_item.IsListBox() && !m_item.IsExtComboBox())
        {
            EnableWindow(GetDlgItem(hwnd, psh3), FALSE);
        }

        CenterWindowDx();
        SetFocus(hCmb2);
        return FALSE;
    }

    void OnOK(HWND hwnd)
    {
        DWORD flags = GetItemAndFlags(m_item);
        if (flags == 0xFFFFFFFF)
        {
            return;
        }
        if (flags & F_CLASS)
        {
            MString strClass = GetDlgItemText(cmb4);
            mstr_trim(strClass);
            if (strClass[0] == TEXT('"'))
            {
                mstr_unquote(strClass);
            }
            if (strClass.empty())
            {
                SetFocus(GetDlgItem(hwnd, cmb4));
                MsgBoxDx(LoadStringDx(IDS_ENTERCLASS), MB_ICONERROR);
                return;
            }
        }

        if (!SetInfo(flags))
            return;

        EndDialog(IDOK);
    }

    void OnLst1(HWND hwnd)
    {
        if (m_bUpdating)
            return;

        HWND hLst1 = GetDlgItem(hwnd, lst1);

        std::vector<BYTE> old_style_selection = m_style_selection;
        GetStyleSelect(hLst1, m_style_selection);

        m_dwStyle = AnalyseStyleDiff(m_dwStyle, m_style_table, 
                                     old_style_selection, m_style_selection);
        ApplySelection(hLst1, m_style_table, m_style_selection, m_dwStyle);

        m_bUpdating = TRUE;
        TCHAR szText[32];
        StringCchPrintf(szText, _countof(szText), TEXT("%08lX"), m_dwStyle);
        SetDlgItemText(hwnd, edt6, szText);
        m_bUpdating = FALSE;
    }

    void OnLst2(HWND hwnd)
    {
        if (m_bUpdating)
            return;

        HWND hLst2 = GetDlgItem(hwnd, lst2);

        std::vector<BYTE> old_exstyle_selection = m_exstyle_selection;
        GetStyleSelect(hLst2, m_exstyle_selection);

        m_dwExStyle = AnalyseStyleDiff(m_dwExStyle, m_exstyle_table, 
                                       old_exstyle_selection, m_exstyle_selection);
        ApplySelection(hLst2, m_exstyle_table, m_exstyle_selection, m_dwExStyle);

        m_bUpdating = TRUE;
        TCHAR szText[32];
        StringCchPrintf(szText, _countof(szText), TEXT("%08lX"), m_dwExStyle);
        SetDlgItemText(hwnd, edt7, szText);
        m_bUpdating = FALSE;
    }

    void OnEdt6(HWND hwnd)
    {
        if (m_bUpdating)
            return;

        MString text = GetDlgItemText(hwnd, edt6);
        mstr_trim(text);
        DWORD dwStyle = mstr_parse_int(text.c_str(), false, 16);

        GetStyleSelect(m_style_selection, m_style_table, dwStyle);

        HWND hLst1 = GetDlgItem(hwnd, lst1);
        m_dwStyle = dwStyle;
        ApplySelection(hLst1, m_style_table, m_style_selection, dwStyle);
    }

    void OnEdt7(HWND hwnd)
    {
        if (m_bUpdating)
            return;

        MString text = GetDlgItemText(hwnd, edt7);
        mstr_trim(text);
        DWORD dwExStyle = mstr_parse_int(text.c_str(), false, 16);

        GetStyleSelect(m_exstyle_selection, m_exstyle_table, dwExStyle);

        HWND hLst2 = GetDlgItem(hwnd, lst2);
        m_dwExStyle = dwExStyle;
        ApplySelection(hLst2, m_exstyle_table, m_exstyle_selection, dwExStyle);
    }

    void UpdateClass(HWND hwnd, HWND hLst1, const MString& strClass)
    {
        MString strSuper;
        DWORD dwType = g_db.GetValue(TEXT("CONTROL.CLASSES"), strClass);
        if (dwType >= 3)
        {
            ConstantsDB::TableType table;
            table = g_db.GetTable(strClass + TEXT(".SUPERCLASS"));
            if (table.size())
            {
                strSuper = table[0].name;
            }
        }

        if (strSuper.size())
            InitTables(strSuper.c_str());
        else
            InitTables(strClass.c_str());

        MString str = strClass + TEXT(".DEFAULT.STYLE");
        m_dwStyle = g_db.GetValue(str, TEXT("STYLE"));

        GetStyleSelect(m_style_selection, m_style_table, m_dwStyle);
        InitStyleListBox(hLst1, m_style_table);
        ApplySelection(hLst1, m_style_table, m_style_selection, m_dwStyle);

        m_bUpdating = TRUE;
        TCHAR szText[32];
        StringCchPrintf(szText, _countof(szText), TEXT("%08lX"), m_dwStyle);
        SetDlgItemText(hwnd, edt6, szText);
        m_bUpdating = FALSE;

        ListBox_SetTopIndex(hLst1, 0);

        if (strSuper.size())
            SetDlgItemText(hwnd, cmb4, strSuper.c_str());
        else
            SetDlgItemText(hwnd, cmb4, strClass.c_str());

        m_item.m_class = strClass.c_str();
        if (m_item.IsStdComboBox() || m_item.IsListBox() ||
            m_item.IsExtComboBox())
        {
            EnableWindow(GetDlgItem(hwnd, psh3), TRUE);
        }
        else
        {
            EnableWindow(GetDlgItem(hwnd, psh3), FALSE);
        }
    }

    void OnPsh1(HWND hwnd)
    {
        MCtrlDataDlg dialog(m_item.m_extra);
        dialog.DialogBoxDx(hwnd);
    }

    void OnPsh2(HWND hwnd)
    {
        OLEUIINSERTOBJECT insert_object;
        TCHAR szFile[MAX_PATH] = { 0 };

        ZeroMemory(&insert_object, sizeof(insert_object));
        insert_object.cbStruct = sizeof(insert_object);
        insert_object.dwFlags = IOF_DISABLEDISPLAYASICON | IOF_SELECTCREATENEW | IOF_DISABLELINK;
        insert_object.hWndOwner = hwnd;
        insert_object.lpszCaption = LoadStringDx(IDS_CHOOSE_OLE_CLSID);
        insert_object.iid = IID_IOleObject;
        insert_object.lpszFile = szFile;
        insert_object.cchFile = _countof(szFile);

        UINT uResult = OleUIInsertObject(&insert_object);
        if (uResult == OLEUI_OK)
        {
            LPOLESTR pszCLSID = NULL;
            if (S_OK == StringFromCLSID(insert_object.clsid, &pszCLSID))
            {
                SetDlgItemTextW(hwnd, cmb2, NULL);
                SetDlgItemTextW(hwnd, cmb4, pszCLSID);
                CoTaskMemFree(pszCLSID);
            }
        }
    }

    void OnPsh3(HWND hwnd)
    {
        MStringListDlg dialog(m_item.m_str_list);
        if (dialog.DialogBoxDx(hwnd) == IDOK)
        {
            m_flags |= F_SLIST;
        }
    }

    void OnCommand(HWND hwnd, int id, HWND hwndCtl, UINT codeNotify)
    {
        HWND hLst1 = GetDlgItem(hwnd, lst1);
        HWND hCmb1 = GetDlgItem(hwnd, cmb1);
        HWND hCmb4 = GetDlgItem(hwnd, cmb4);
        TCHAR szText[64];
        switch (id)
        {
        case IDOK:
            OnOK(hwnd);
            break;
        case IDCANCEL:
            EndDialog(IDCANCEL);
            break;
        case cmb1:
            if (codeNotify == CBN_SELCHANGE)
            {
                INT nIndex = ComboBox_GetCurSel(hCmb1);
                ComboBox_GetLBText(hCmb1, nIndex, szText);
                MString text = szText;
                mstr_trim(text);
                UpdateClass(hwnd, hLst1, text);
            }
            else if (codeNotify == CBN_EDITCHANGE)
            {
                DWORD dwPos;
                m_cmb1.OnEditChange(dwPos);
                {
                    MString text = GetDlgItemText(hwnd, cmb1);
                    mstr_trim(text);
                    InitTables(text.c_str());
                    UpdateClass(hwnd, hLst1, text);
                }
                m_cmb1.SetEditSel(LOWORD(dwPos), -1);
            }
            break;
        case cmb2:
            if (codeNotify == CBN_EDITCHANGE)
            {
                m_cmb2.OnEditChange();
            }
            break;
        case cmb3:
            if (codeNotify == CBN_EDITCHANGE)
            {
                m_cmb3.OnEditChange();
            }
            break;
        case cmb4:
            if (codeNotify == CBN_SELCHANGE)
            {
                INT nIndex = ComboBox_GetCurSel(hCmb4);
                ComboBox_GetLBText(hCmb4, nIndex, szText);
                MString text = szText;
                mstr_trim(text);
                UpdateClass(hwnd, hLst1, text);
            }
            else if (codeNotify == CBN_EDITCHANGE)
            {
                DWORD dwPos;
                m_cmb4.OnEditChange(dwPos);
                {
                    MString text = GetDlgItemText(hwnd, cmb4);
                    mstr_trim(text);
                    InitTables(text.c_str());
                    UpdateClass(hwnd, hLst1, text);
                }
                m_cmb4.SetEditSel(LOWORD(dwPos), -1);
            }
            break;
        case cmb5:
            if (codeNotify == CBN_EDITCHANGE)
            {
                m_cmb5.OnEditChange();
            }
            break;
        case lst1:
            if (codeNotify == LBN_SELCHANGE)
            {
                OnLst1(hwnd);
            }
            break;
        case lst2:
            if (codeNotify == LBN_SELCHANGE)
            {
                OnLst2(hwnd);
            }
            break;
        case edt6:
            if (codeNotify == EN_CHANGE)
            {
                OnEdt6(hwnd);
            }
            break;
        case edt7:
            if (codeNotify == EN_CHANGE)
            {
                OnEdt7(hwnd);
            }
            break;
        case psh1:
            OnPsh1(hwnd);
            break;
        case psh2:
            OnPsh2(hwnd);
            break;
        case psh3:
            OnPsh3(hwnd);
            break;
        default:
            if (size_t(id - 1000) < m_vecControls.size())
            {
                MString text;
                UINT nID = UINT(id - 1000);
                if (nID == g_db.GetValue(TEXT("CONTROLS.OLE.CONTROL"), TEXT("INDEX")))
                {
                    // OLE controls
                    text = g_settings.strAtlAxWin;
                    SetDlgItemTextW(hwnd, cmb4, text.c_str());
                }
                else
                {
                    text = m_vecControls[nID];
                    SetDlgItemTextW(hwnd, cmb1, text.c_str());
                }
                mstr_trim(text);
                InitTables(text.c_str());
                UpdateClass(hwnd, hLst1, text);
            }
            break;
        }
    }

    LRESULT OnNotify(HWND hwnd, int idFrom, LPNMHDR pnmhdr)
    {
        if (pnmhdr->code == TTN_NEEDTEXT)
        {
            TOOLTIPTEXT *ttt = (TOOLTIPTEXT *)pnmhdr;
            UINT nID = UINT(pnmhdr->idFrom - 1000);
            if (size_t(nID) < m_vecControls.size())
            {
                MString text;
                if (nID == g_db.GetValue(TEXT("CONTROLS.OLE.CONTROL"), TEXT("INDEX")))
                {
                    // OLE controls
                    text = g_settings.strAtlAxWin;
                }
                else
                {
                    text = m_vecControls[nID];
                }
                StringCchCopyW(ttt->szText, _countof(ttt->szText), text.c_str());
            }
        }
        return 0;
    }

    virtual INT_PTR CALLBACK
    DialogProcDx(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
    {
        switch (uMsg)
        {
            HANDLE_MSG(hwnd, WM_INITDIALOG, OnInitDialog);
            HANDLE_MSG(hwnd, WM_COMMAND, OnCommand);
            HANDLE_MSG(hwnd, WM_NOTIFY, OnNotify);
        }
        return DefaultProcDx();
    }
};

```

`src/MDfmSettingsDlg.hpp`:

```hpp
// MDfmSettingsDlg.hpp --- "Delphi DFM settings" Dialog
//////////////////////////////////////////////////////////////////////////////
// RisohEditor --- Another free Win32 resource editor
// Copyright (C) 2017-2018 Katayama Hirofumi MZ <katayama.hirofumi.mz@gmail.com>
// 
// This program is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
// 
// This program is distributed in the hope that it will be useful, 
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
// 
// You should have received a copy of the GNU General Public License
// along with this program.  If not, see <http://www.gnu.org/licenses/>.
//////////////////////////////////////////////////////////////////////////////

#pragma once

#include "resource.h"
#include "MWindowBase.hpp"
#include "RisohSettings.hpp"

//////////////////////////////////////////////////////////////////////////////

class MDfmSettingsDlg : public MDialogBase
{
public:
    INT m_nCodePage;
    BOOL m_bComments;
    BOOL m_bNoUnicode;

    MDfmSettingsDlg() : MDialogBase(IDD_DFMSETTINGS)
    {
        m_nCodePage = g_settings.nDfmCodePage;
        m_bComments = g_settings.bDfmRawTextComments;
        m_bNoUnicode = g_settings.bDfmNoUnicode;
    }

    BOOL OnInitDialog(HWND hwnd, HWND hwndFocus, LPARAM lParam)
    {
        HWND hCmb1 = GetDlgItem(hwnd, cmb1);
        ComboBox_AddString(hCmb1, TEXT("0"));
        ComboBox_AddString(hCmb1, LoadStringDx(IDS_CODEPAGE1252));
        ComboBox_AddString(hCmb1, LoadStringDx(IDS_CODEPAGE1250));
        ComboBox_AddString(hCmb1, LoadStringDx(IDS_CODEPAGE1251));
        ComboBox_AddString(hCmb1, LoadStringDx(IDS_CODEPAGE1253));
        ComboBox_AddString(hCmb1, LoadStringDx(IDS_CODEPAGE1254));
        ComboBox_AddString(hCmb1, LoadStringDx(IDS_CODEPAGE1255));
        ComboBox_AddString(hCmb1, LoadStringDx(IDS_CODEPAGE1256));
        ComboBox_AddString(hCmb1, LoadStringDx(IDS_CODEPAGE1257));
        ComboBox_AddString(hCmb1, LoadStringDx(IDS_CODEPAGE874));
        ComboBox_AddString(hCmb1, LoadStringDx(IDS_CODEPAGE932));
        ComboBox_AddString(hCmb1, LoadStringDx(IDS_CODEPAGE936));
        ComboBox_AddString(hCmb1, LoadStringDx(IDS_CODEPAGE949));
        ComboBox_AddString(hCmb1, LoadStringDx(IDS_CODEPAGE950));
        ComboBox_AddString(hCmb1, LoadStringDx(IDS_CODEPAGE65001));

        TCHAR szText[32];
        StringCbPrintf(szText, sizeof(szText), TEXT("%u"), m_nCodePage);
        ComboBox_SetText(hCmb1, szText);

        if (m_bComments)
            CheckDlgButton(hwnd, chx1, BST_CHECKED);
        else
            CheckDlgButton(hwnd, chx1, BST_UNCHECKED);

        if (m_bNoUnicode)
            CheckDlgButton(hwnd, chx2, BST_CHECKED);
        else
            CheckDlgButton(hwnd, chx2, BST_UNCHECKED);

        CenterWindowDx();

        return TRUE;
    }

    void OnOK(HWND hwnd)
    {
        HWND hCmb1 = GetDlgItem(hwnd, cmb1);

        TCHAR szText[32];
        INT iItem = ComboBox_GetCurSel(hCmb1);
        if (iItem == CB_ERR)
        {
            ComboBox_GetText(hCmb1, szText, 32);
        }
        else
        {
            ComboBox_GetLBText(hCmb1, iItem, szText);
        }
        m_nCodePage = _tcstoul(szText, NULL, 0);

        if (IsDlgButtonChecked(hwnd, chx1) == BST_CHECKED)
            m_bComments = TRUE;
        else
            m_bComments = FALSE;

        if (IsDlgButtonChecked(hwnd, chx2) == BST_CHECKED)
            m_bNoUnicode = TRUE;
        else
            m_bNoUnicode = FALSE;

        EndDialog(IDOK);
    }

    void OnCommand(HWND hwnd, int id, HWND hwndCtl, UINT codeNotify)
    {
        switch (id)
        {
        case IDOK:
            OnOK(hwnd);
            break;
        case IDCANCEL:
            EndDialog(IDCANCEL);
            break;
        }
    }

    virtual INT_PTR CALLBACK
    DialogProcDx(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
    {
        switch (uMsg)
        {
            HANDLE_MSG(hwnd, WM_INITDIALOG, OnInitDialog);
            HANDLE_MSG(hwnd, WM_COMMAND, OnCommand);
        }
        return DefaultProcDx();
    }
};

```

`src/MDialogFontSubstDlg.hpp`:

```hpp
// MDialogFontSubstDlg --- "Replacing Dialog Fonts" Dialog
//////////////////////////////////////////////////////////////////////////////
// RisohEditor --- Another free Win32 resource editor
// Copyright (C) 2020 Katayama Hirofumi MZ <katayama.hirofumi.mz@gmail.com>
// 
// This program is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
// 
// This program is distributed in the hope that it will be useful, 
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
// 
// You should have received a copy of the GNU General Public License
// along with this program.  If not, see <http://www.gnu.org/licenses/>.
//////////////////////////////////////////////////////////////////////////////

#pragma once

#include "MWindowBase.hpp"
#include "RisohSettings.hpp"
#include "MComboBoxAutoComplete.hpp"
#include "Common.hpp"

//////////////////////////////////////////////////////////////////////////////

class MDialogFontSubstDlg : public MDialogBase
{
public:
    MComboBoxAutoComplete m_cmb1;
    MComboBoxAutoComplete m_cmb2;
    MComboBoxAutoComplete m_cmb3;
    MComboBoxAutoComplete m_cmb4;
    MComboBoxAutoComplete m_cmb5;
    MComboBoxAutoComplete m_cmb6;

    MDialogFontSubstDlg() : MDialogBase(IDD_FONTSUBST)
    {
    }

    BOOL OnInitDialog(HWND hwnd, HWND hwndFocus, LPARAM lParam)
    {
        InitFontComboBox(GetDlgItem(hwnd, cmb1));
        InitFontComboBox(GetDlgItem(hwnd, cmb2));
        InitFontComboBox(GetDlgItem(hwnd, cmb3));
        InitFontComboBox(GetDlgItem(hwnd, cmb4));
        InitFontComboBox(GetDlgItem(hwnd, cmb5));
        InitFontComboBox(GetDlgItem(hwnd, cmb6));

        SetDlgItemTextW(hwnd, cmb1, g_settings.strFontReplaceFrom1.c_str());
        SetDlgItemTextW(hwnd, cmb2, g_settings.strFontReplaceTo1.c_str());
        SetDlgItemTextW(hwnd, cmb3, g_settings.strFontReplaceFrom2.c_str());
        SetDlgItemTextW(hwnd, cmb4, g_settings.strFontReplaceTo2.c_str());
        SetDlgItemTextW(hwnd, cmb5, g_settings.strFontReplaceFrom3.c_str());
        SetDlgItemTextW(hwnd, cmb6, g_settings.strFontReplaceTo3.c_str());

        SubclassChildDx(m_cmb1, cmb1);
        SubclassChildDx(m_cmb2, cmb2);
        SubclassChildDx(m_cmb3, cmb3);
        SubclassChildDx(m_cmb4, cmb4);
        SubclassChildDx(m_cmb5, cmb5);
        SubclassChildDx(m_cmb6, cmb6);

        CenterWindowDx();
        return TRUE;
    }

    BOOL OnOK(HWND hwnd)
    {
        g_settings.strFontReplaceFrom1 = GetDlgItemText(cmb1);
        g_settings.strFontReplaceTo1 = GetDlgItemText(cmb2);
        g_settings.strFontReplaceFrom2 = GetDlgItemText(cmb3);
        g_settings.strFontReplaceTo2 = GetDlgItemText(cmb4);
        g_settings.strFontReplaceFrom3 = GetDlgItemText(cmb5);
        g_settings.strFontReplaceTo3 = GetDlgItemText(cmb6);
        return TRUE;
    }

    void OnReset(HWND hwnd)
    {
        SetDlgItemTextW(hwnd, cmb1, L"MS Shell Dlg");
        SetDlgItemTextW(hwnd, cmb2, L"MS Shell Dlg");
        SetDlgItemTextW(hwnd, cmb3, L"MS Shell Dlg 2");
        SetDlgItemTextW(hwnd, cmb4, L"MS Shell Dlg 2");
        SetDlgItemTextW(hwnd, cmb5, L"");
        SetDlgItemTextW(hwnd, cmb6, L"");
    }

    void OnCommand(HWND hwnd, int id, HWND hwndCtl, UINT codeNotify)
    {
        switch (id)
        {
        case IDOK:
            if (OnOK(hwnd))
            {
                EndDialog(hwnd, id);
            }
            break;

        case IDCANCEL:
            EndDialog(hwnd, id);
            break;

        case psh1:
            OnReset(hwnd);
            break;

        case cmb1:
            if (codeNotify == CBN_EDITCHANGE)
            {
                m_cmb1.OnEditChange();
            }
            break;

        case cmb2:
            if (codeNotify == CBN_EDITCHANGE)
            {
                m_cmb2.OnEditChange();
            }
            break;

        case cmb3:
            if (codeNotify == CBN_EDITCHANGE)
            {
                m_cmb3.OnEditChange();
            }
            break;

        case cmb4:
            if (codeNotify == CBN_EDITCHANGE)
            {
                m_cmb4.OnEditChange();
            }
            break;

        case cmb5:
            if (codeNotify == CBN_EDITCHANGE)
            {
                m_cmb5.OnEditChange();
            }
            break;

        case cmb6:
            if (codeNotify == CBN_EDITCHANGE)
            {
                m_cmb6.OnEditChange();
            }
            break;
        }
    }

    virtual INT_PTR CALLBACK
    DialogProcDx(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
    {
        switch (uMsg)
        {
            HANDLE_MSG(hwnd, WM_INITDIALOG, OnInitDialog);
            HANDLE_MSG(hwnd, WM_COMMAND, OnCommand);
        }
        return DefaultProcDx();
    }
};

```

`src/MDlgInitDlg.hpp`:

```hpp
// MDlgInitDlg.hpp --- Dialogs for edit of DLGINIT
//////////////////////////////////////////////////////////////////////////////
// RisohEditor --- Another free Win32 resource editor
// Copyright (C) 2017-2018 Katayama Hirofumi MZ <katayama.hirofumi.mz@gmail.com>
// 
// This program is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
// 
// This program is distributed in the hope that it will be useful, 
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
// 
// You should have received a copy of the GNU General Public License
// along with this program.  If not, see <http://www.gnu.org/licenses/>.
//////////////////////////////////////////////////////////////////////////////

#pragma once

#include "resource.h"
#include "MWindowBase.hpp"
#include "RisohSettings.hpp"
#include "ConstantsDB.hpp"
#include "MResizable.hpp"
#include "MComboBoxAutoComplete.hpp"
#include "MString.hpp"
#include "DlgInitRes.hpp"
#include "DlgInit.h"

class MAddDlgInitDlg;
class MModifyDlgInitDlg;
class MDlgInitDlg;

//////////////////////////////////////////////////////////////////////////////

class MAddDlgInitDlg : public MDialogBase
{
public:
    DLGINIT_ENTRY& m_entry;
    MComboBoxAutoComplete m_cmb1;
    MComboBoxAutoComplete m_cmb2;

    MAddDlgInitDlg(DLGINIT_ENTRY& entry) :
        MDialogBase(IDD_ADDDLGINIT), m_entry(entry)
    {
    }

    BOOL OnInitDialog(HWND hwnd, HWND hwndFocus, LPARAM lParam)
    {
        HWND hCmb1 = GetDlgItem(hwnd, cmb1);
        InitCtrlIDComboBox(hCmb1);
        SubclassChildDx(m_cmb1, cmb1);

        SubclassChildDx(m_cmb2, cmb2);

        ExecuteDlgInitDx(hwnd, GetModuleHandle(NULL), MAKEINTRESOURCE(IDD_ADDDLGINIT));

        CenterWindowDx();
        return TRUE;
    }

    void OnOK(HWND hwnd)
    {
        GetWindowTextW(m_cmb1, m_entry.sz0, _countof(m_entry.sz0));
        GetWindowTextW(m_cmb2, m_entry.sz1, _countof(m_entry.sz1));
        GetDlgItemTextW(hwnd, edt1, m_entry.sz2, _countof(m_entry.sz2));
        ReplaceFullWithHalf(m_entry.sz0);
        ReplaceFullWithHalf(m_entry.sz1);
        mstr_trim(m_entry.sz0);
        mstr_trim(m_entry.sz1);
        mstr_trim(m_entry.sz2);
        if (m_entry.sz2[0] == L'"')
            mstr_unquote(m_entry.sz2);

        if (!g_db.HasResID(m_entry.sz0))
        {
            BOOL bTranslated = FALSE;
            INT nValue = GetDlgItemInt(hwnd, cmb1, &bTranslated, TRUE);
            if (!bTranslated)
            {
                if (mchr_is_digit(m_entry.sz0[0]) || 
                    m_entry.sz0[0] == L'-' || m_entry.sz0[0] == L'+')
                {
                    nValue = mstr_parse_int(m_entry.sz0);
                    SetDlgItemInt(hwnd, cmb1, nValue, TRUE);
                }
                else
                {
                    m_cmb1.SetEditSel(0, -1);
                    SetFocus(m_cmb1);
                    ErrorBoxDx(IDS_NOSUCHID);
                    return;
                }
            }
            SetDlgItemInt(hwnd, cmb1, nValue, TRUE);
            auto text = GetDlgItemText(hwnd, cmb1);
            StringCchCopy(m_entry.sz0, _countof(m_entry.sz0), text.c_str());
        }

        if (lstrcmpW(m_entry.sz1, L"LB_ADDSTRING") != 0 &&
            lstrcmpW(m_entry.sz1, L"CB_ADDSTRING") != 0 &&
            lstrcmpW(m_entry.sz1, L"CBEM_INSERTITEM") != 0)
        {
            BOOL bTranslated = FALSE;
            INT nValue = GetDlgItemInt(hwnd, cmb2, &bTranslated, TRUE);
            if (!bTranslated)
            {
                if (mchr_is_digit(m_entry.sz1[0]) || 
                    m_entry.sz1[0] == L'-' || m_entry.sz1[0] == L'+')
                {
                    nValue = mstr_parse_int(m_entry.sz1);
                }
                else
                {
                    m_cmb2.SetEditSel(0, -1);
                    SetFocus(m_cmb2);
                    ErrorBoxDx(IDS_DATAISINVALID);
                    return;
                }
            }
            auto text = mstr_hex_word(nValue);
            SetDlgItemText(hwnd, cmb2, text.c_str());
            StringCchCopy(m_entry.sz1, _countof(m_entry.sz1), text.c_str());
        }

        EndDialog(IDOK);
    }

    void OnCommand(HWND hwnd, int id, HWND hwndCtl, UINT codeNotify)
    {
        switch (id)
        {
        case IDOK:
            OnOK(hwnd);
            break;
        case IDCANCEL:
            EndDialog(IDCANCEL);
            break;
        case cmb1:
            if (codeNotify == CBN_EDITCHANGE)
            {
                m_cmb1.OnEditChange();
            }
            break;
        case cmb2:
            if (codeNotify == CBN_EDITCHANGE)
            {
                m_cmb2.OnEditChange();
            }
            break;
        }
    }

    virtual INT_PTR CALLBACK
    DialogProcDx(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
    {
        switch (uMsg)
        {
            HANDLE_MSG(hwnd, WM_INITDIALOG, OnInitDialog);
            HANDLE_MSG(hwnd, WM_COMMAND, OnCommand);
        }
        return DefaultProcDx();
    }
};

//////////////////////////////////////////////////////////////////////////////

class MModifyDlgInitDlg : public MDialogBase
{
public:
    DLGINIT_ENTRY& m_entry;
    MComboBoxAutoComplete m_cmb1;
    MComboBoxAutoComplete m_cmb2;

    MModifyDlgInitDlg(DLGINIT_ENTRY& entry) :
        MDialogBase(IDD_MODIFYDLGINIT), m_entry(entry)
    {
    }

    BOOL OnInitDialog(HWND hwnd, HWND hwndFocus, LPARAM lParam)
    {
        HWND hCmb1 = GetDlgItem(hwnd, cmb1);
        InitCtrlIDComboBox(hCmb1);
        SetDlgItemTextW(hwnd, cmb1, m_entry.sz0);
        SubclassChildDx(m_cmb1, cmb1);

        SubclassChildDx(m_cmb2, cmb2);
        SetDlgItemTextW(hwnd, cmb2, m_entry.sz1);

        SetDlgItemTextW(hwnd, edt1, m_entry.sz2);

        ExecuteDlgInitDx(hwnd, GetModuleHandle(NULL), MAKEINTRESOURCE(IDD_MODIFYDLGINIT));

        CenterWindowDx();
        return TRUE;
    }

    void OnOK(HWND hwnd)
    {
        GetWindowTextW(m_cmb1, m_entry.sz0, _countof(m_entry.sz0));
        GetWindowTextW(m_cmb2, m_entry.sz1, _countof(m_entry.sz1));
        GetDlgItemTextW(hwnd, edt1, m_entry.sz2, _countof(m_entry.sz2));
        ReplaceFullWithHalf(m_entry.sz0);
        ReplaceFullWithHalf(m_entry.sz1);
        mstr_trim(m_entry.sz0);
        mstr_trim(m_entry.sz1);
        mstr_trim(m_entry.sz2);
        if (m_entry.sz2[0] == L'"')
            mstr_unquote(m_entry.sz2);

        if (!g_db.HasResID(m_entry.sz0))
        {
            BOOL bTranslated = FALSE;
            INT nValue = GetDlgItemInt(hwnd, cmb1, &bTranslated, TRUE);
            if (!bTranslated)
            {
                if (mchr_is_digit(m_entry.sz0[0]) || 
                    m_entry.sz0[0] == L'-' || m_entry.sz0[0] == L'+')
                {
                    nValue = mstr_parse_int(m_entry.sz0);
                }
                else
                {
                    m_cmb1.SetEditSel(0, -1);
                    SetFocus(m_cmb1);
                    ErrorBoxDx(IDS_NOSUCHID);
                    return;
                }
            }
            SetDlgItemInt(hwnd, cmb1, nValue, TRUE);
            auto text = GetDlgItemText(hwnd, cmb1);
            StringCchCopy(m_entry.sz0, _countof(m_entry.sz0), text.c_str());
        }

        if (lstrcmpW(m_entry.sz1, L"LB_ADDSTRING") != 0 &&
            lstrcmpW(m_entry.sz1, L"CB_ADDSTRING") != 0 &&
            lstrcmpW(m_entry.sz1, L"CBEM_INSERTITEM") != 0)
        {
            BOOL bTranslated = FALSE;
            INT nValue = GetDlgItemInt(hwnd, cmb2, &bTranslated, TRUE);
            if (!bTranslated)
            {
                if (mchr_is_digit(m_entry.sz1[0]) ||
                    m_entry.sz1[0] == L'-' || m_entry.sz1[0] == L'+')
                {
                    nValue = mstr_parse_int(m_entry.sz1);
                }
                else
                {
                    m_cmb2.SetEditSel(0, -1);
                    SetFocus(m_cmb2);
                    ErrorBoxDx(IDS_DATAISINVALID);
                    return;
                }
            }
            auto text = mstr_hex_word(nValue);
            SetDlgItemText(hwnd, cmb2, text.c_str());
            StringCchCopy(m_entry.sz1, _countof(m_entry.sz1), text.c_str());
        }

        EndDialog(IDOK);
    }

    void OnCommand(HWND hwnd, int id, HWND hwndCtl, UINT codeNotify)
    {
        switch (id)
        {
        case IDOK:
            OnOK(hwnd);
            break;
        case IDCANCEL:
            EndDialog(IDCANCEL);
            break;
        case cmb1:
            if (codeNotify == CBN_EDITCHANGE)
            {
                m_cmb1.OnEditChange();
            }
            break;
        case cmb2:
            if (codeNotify == CBN_EDITCHANGE)
            {
                m_cmb2.OnEditChange();
            }
            break;
        }
    }

    virtual INT_PTR CALLBACK
    DialogProcDx(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
    {
        switch (uMsg)
        {
            HANDLE_MSG(hwnd, WM_INITDIALOG, OnInitDialog);
            HANDLE_MSG(hwnd, WM_COMMAND, OnCommand);
        }
        return DefaultProcDx();
    }
};

//////////////////////////////////////////////////////////////////////////////

class MDlgInitDlg : public MDialogBase
{
public:
    DlgInitRes& m_dlginit_res;
    MResizable m_resizable;
    HICON m_hIcon;
    HICON m_hIconSm;
    HWND m_hLst1;

    MDlgInitDlg(DlgInitRes& dlginit_res)
        : MDialogBase(IDD_DLGINITEDIT), m_dlginit_res(dlginit_res)
    {
        m_hIcon = LoadIconDx(IDI_SMILY);
        m_hIconSm = LoadSmallIconDx(IDI_SMILY);
        m_hLst1 = NULL;
    }

    ~MDlgInitDlg()
    {
        DestroyIcon(m_hIcon);
        DestroyIcon(m_hIconSm);
    }

    void OnUp(HWND hwnd)
    {
        INT iItem = ListView_GetNextItem(m_hLst1, -1, LVNI_ALL | LVNI_SELECTED);
        if (iItem == 0)
            return;

        DLGINIT_ENTRY die0, die1;
        ListView_GetItemText(m_hLst1, iItem - 1, 0, die0.sz0, _countof(die0.sz0));
        ListView_GetItemText(m_hLst1, iItem - 1, 1, die0.sz1, _countof(die0.sz1));
        ListView_GetItemText(m_hLst1, iItem - 1, 2, die0.sz2, _countof(die0.sz2));
        ListView_GetItemText(m_hLst1, iItem, 0, die1.sz0, _countof(die1.sz0));
        ListView_GetItemText(m_hLst1, iItem, 1, die1.sz1, _countof(die1.sz1));
        ListView_GetItemText(m_hLst1, iItem, 2, die1.sz2, _countof(die1.sz2));

        ListView_SetItemText(m_hLst1, iItem - 1, 0, die1.sz0);
        ListView_SetItemText(m_hLst1, iItem - 1, 1, die1.sz1);
        ListView_SetItemText(m_hLst1, iItem - 1, 2, die1.sz2);
        ListView_SetItemText(m_hLst1, iItem, 0, die0.sz0);
        ListView_SetItemText(m_hLst1, iItem, 1, die0.sz1);
        ListView_SetItemText(m_hLst1, iItem, 2, die0.sz2);

        UINT state = LVIS_SELECTED | LVIS_FOCUSED;
        ListView_SetItemState(m_hLst1, iItem - 1, state, state);
    }

    void OnDown(HWND hwnd)
    {
        INT iItem = ListView_GetNextItem(m_hLst1, -1, LVNI_ALL | LVNI_SELECTED);
        if (iItem + 1 == ListView_GetItemCount(m_hLst1))
            return;

        DLGINIT_ENTRY die0, die1;
        ListView_GetItemText(m_hLst1, iItem, 0, die0.sz0, _countof(die0.sz0));
        ListView_GetItemText(m_hLst1, iItem, 1, die0.sz1, _countof(die0.sz1));
        ListView_GetItemText(m_hLst1, iItem, 2, die0.sz2, _countof(die0.sz2));
        ListView_GetItemText(m_hLst1, iItem + 1, 0, die1.sz0, _countof(die1.sz0));
        ListView_GetItemText(m_hLst1, iItem + 1, 1, die1.sz1, _countof(die1.sz1));
        ListView_GetItemText(m_hLst1, iItem + 1, 2, die1.sz2, _countof(die1.sz2));

        ListView_SetItemText(m_hLst1, iItem, 0, die1.sz0);
        ListView_SetItemText(m_hLst1, iItem, 1, die1.sz1);
        ListView_SetItemText(m_hLst1, iItem, 2, die1.sz2);
        ListView_SetItemText(m_hLst1, iItem + 1, 0, die0.sz0);
        ListView_SetItemText(m_hLst1, iItem + 1, 1, die0.sz1);
        ListView_SetItemText(m_hLst1, iItem + 1, 2, die0.sz2);

        UINT state = LVIS_SELECTED | LVIS_FOCUSED;
        ListView_SetItemState(m_hLst1, iItem + 1, state, state);
    }

    void OnDelete(HWND hwnd)
    {
        INT iItem = ListView_GetNextItem(m_hLst1, -1, LVNI_ALL | LVNI_SELECTED);
        if (iItem >= 0)
        {
            ListView_DeleteItem(m_hLst1, iItem);
        }
    }

    void OnDeleteAll(HWND hwnd)
    {
        ListView_DeleteAllItems(m_hLst1);
    }

    void OnAdd(HWND hwnd)
    {
        DLGINIT_ENTRY entry;

        MAddDlgInitDlg dialog(entry);
        if (IDOK != dialog.DialogBoxDx(hwnd))
        {
            return;
        }

        INT iItem = ListView_GetItemCount(m_hLst1);

        LV_ITEM item;

        ZeroMemory(&item, sizeof(item));
        item.iItem = iItem;
        item.mask = LVIF_TEXT;
        item.iSubItem = 0;
        item.pszText = entry.sz0;
        ListView_InsertItem(m_hLst1, &item);

        ZeroMemory(&item, sizeof(item));
        item.iItem = iItem;
        item.mask = LVIF_TEXT;
        item.iSubItem = 1;
        item.pszText = entry.sz1;
        ListView_SetItem(m_hLst1, &item);

        MString str2 = mstr_quote(entry.sz2);

        ZeroMemory(&item, sizeof(item));
        item.iItem = iItem;
        item.mask = LVIF_TEXT;
        item.iSubItem = 2;
        item.pszText = &str2[0];
        ListView_SetItem(m_hLst1, &item);

        UINT state = LVIS_SELECTED | LVIS_FOCUSED;
        ListView_SetItemState(m_hLst1, iItem, state, state);
        ListView_EnsureVisible(m_hLst1, iItem, FALSE);
    }

    void OnModify(HWND hwnd)
    {
        INT iItem = ListView_GetNextItem(m_hLst1, -1, LVNI_ALL | LVNI_SELECTED);
        if (iItem < 0)
        {
            return;
        }

        DLGINIT_ENTRY die;
        ListView_GetItemText(m_hLst1, iItem, 0, die.sz0, _countof(die.sz0));
        ListView_GetItemText(m_hLst1, iItem, 1, die.sz1, _countof(die.sz1));
        ListView_GetItemText(m_hLst1, iItem, 2, die.sz2, _countof(die.sz2));
        if (die.sz2[0] == L'"')
            mstr_unquote(die.sz2);

        MModifyDlgInitDlg dialog(die);
        if (IDOK == dialog.DialogBoxDx(hwnd))
        {
            MString str2 = mstr_quote(die.sz2);
            ListView_SetItemText(m_hLst1, iItem, 0, die.sz0);
            ListView_SetItemText(m_hLst1, iItem, 1, die.sz1);
            ListView_SetItemText(m_hLst1, iItem, 2, &str2[0]);
        }
    }

    void OnOK(HWND hwnd)
    {
        INT i, nCount = ListView_GetItemCount(m_hLst1);

        m_dlginit_res.entries().clear();
        for (i = 0; i < nCount; ++i)
        {
            DLGINIT_ENTRY die;
            ListView_GetItemText(m_hLst1, i, 0, die.sz0, _countof(die.sz0));
            ListView_GetItemText(m_hLst1, i, 1, die.sz1, _countof(die.sz1));
            ListView_GetItemText(m_hLst1, i, 2, die.sz2, _countof(die.sz2));
            if (die.sz2[0] == L'"')
                mstr_unquote(die.sz2);

            DlgInitEntry entry;
            entry.wCtrl = WORD(g_db.GetResIDValue(die.sz0));

            if (lstrcmpiW(die.sz1, L"LB_ADDSTRING") == 0)
            {
                entry.wMsg = LB_ADDSTRING;
            }
            else if (lstrcmpiW(die.sz1, L"CB_ADDSTRING") == 0)
            {
                entry.wMsg = CB_ADDSTRING;
            }
            else if (lstrcmpiW(die.sz1, L"CBEM_INSERTITEM") == 0)
            {
                entry.wMsg = CBEM_INSERTITEM;
            }
            else
            {
                entry.wMsg = mstr_parse_int(die.sz1);
            }

            entry.strText = MTextToAnsi(CP_ACP, die.sz2).c_str();

            m_dlginit_res.entries().push_back(entry);
        }

        EndDialog(IDOK);
    }

    void OnCommand(HWND hwnd, int id, HWND hwndCtl, UINT codeNotify)
    {
        switch (id)
        {
        case psh1:
            OnAdd(hwnd);
            break;
        case psh2:
            OnModify(hwnd);
            break;
        case psh3:
            OnDelete(hwnd);
            break;
        case psh4:
            OnUp(hwnd);
            break;
        case psh5:
            OnDown(hwnd);
            break;
        case psh6:
            OnDeleteAll(hwnd);
            break;
        case IDOK:
            OnOK(hwnd);
            break;
        case IDCANCEL:
            EndDialog(IDCANCEL);
            break;
        }
    }

    void OnItemChanged(HWND hwnd)
    {
        INT iItem = ListView_GetNextItem(m_hLst1, -1, LVNI_ALL | LVNI_SELECTED);
        BOOL bSelected = (iItem != -1);
        EnableWindow(GetDlgItem(hwnd, psh2), bSelected);
        EnableWindow(GetDlgItem(hwnd, psh3), bSelected);
        EnableWindow(GetDlgItem(hwnd, psh4), bSelected);
        EnableWindow(GetDlgItem(hwnd, psh5), bSelected);
    }

    void OnInitMenuPopup(HWND hwnd, HMENU hMenu, UINT item, BOOL fSystemMenu)
    {
        INT iItem = ListView_GetNextItem(m_hLst1, -1, LVNI_ALL | LVNI_SELECTED);
        BOOL bSelected = (iItem != -1);
        EnableMenuItem(hMenu, psh2, bSelected ? MF_ENABLED : MF_GRAYED);
        EnableMenuItem(hMenu, psh3, bSelected ? MF_ENABLED : MF_GRAYED);
        EnableMenuItem(hMenu, psh4, bSelected ? MF_ENABLED : MF_GRAYED);
        EnableMenuItem(hMenu, psh5, bSelected ? MF_ENABLED : MF_GRAYED);
    }

    LRESULT OnNotify(HWND hwnd, int idFrom, NMHDR *pnmhdr)
    {
        if (idFrom == lst1)
        {
            if (pnmhdr->code == LVN_KEYDOWN)
            {
                LV_KEYDOWN *KeyDown = (LV_KEYDOWN *)pnmhdr;
                if (KeyDown->wVKey == VK_DELETE)
                {
                    OnDelete(hwnd);
                    return 0;
                }
            }
            if (pnmhdr->code == NM_DBLCLK)
            {
                OnModify(hwnd);
                return 0;
            }
            if (pnmhdr->code == LVN_GETINFOTIP)
            {
                NMLVGETINFOTIP *pGetInfoTip = (NMLVGETINFOTIP *)pnmhdr;
                INT iItem = pGetInfoTip->iItem;
                INT iSubItem = pGetInfoTip->iSubItem;
                TCHAR szText[128];
                ListView_GetItemText(m_hLst1, iItem, iSubItem, szText, _countof(szText));
                StringCchCopy(pGetInfoTip->pszText, pGetInfoTip->cchTextMax, szText);
            }
            if (pnmhdr->code == LVN_ITEMCHANGED)
            {
                //NM_LISTVIEW *pListView = (NM_LISTVIEW *)pnmhdr;
                OnItemChanged(hwnd);
            }
        }
        return 0;
    }

    virtual INT_PTR CALLBACK
    DialogProcDx(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
    {
        switch (uMsg)
        {
            HANDLE_MSG(hwnd, WM_INITDIALOG, OnInitDialog);
            HANDLE_MSG(hwnd, WM_COMMAND, OnCommand);
            HANDLE_MSG(hwnd, WM_NOTIFY, OnNotify);
            HANDLE_MSG(hwnd, WM_SIZE, OnSize);
            HANDLE_MSG(hwnd, WM_CONTEXTMENU, OnContextMenu);
            HANDLE_MSG(hwnd, WM_INITMENUPOPUP, OnInitMenuPopup);
        }
        return DefaultProcDx();
    }

    void OnSize(HWND hwnd, UINT state, int cx, int cy)
    {
        m_resizable.OnSize();
    }

    BOOL OnInitDialog(HWND hwnd, HWND hwndFocus, LPARAM lParam)
    {
        m_hLst1 = GetDlgItem(hwnd, lst1);
        ListView_SetExtendedListViewStyle(m_hLst1, LVS_EX_FULLROWSELECT | LVS_EX_INFOTIP);

        LV_COLUMN column;
        ZeroMemory(&column, sizeof(column));

        column.mask = LVCF_FMT | LVCF_SUBITEM | LVCF_TEXT | LVCF_WIDTH;
        column.fmt = LVCFMT_LEFT;
        column.cx = 130;
        column.pszText = LoadStringDx(IDS_CONTROL);
        column.iSubItem = 0;
        ListView_InsertColumn(m_hLst1, 0, &column);

        column.mask = LVCF_FMT | LVCF_SUBITEM | LVCF_TEXT | LVCF_WIDTH;
        column.fmt = LVCFMT_LEFT;
        column.cx = 125;
        column.pszText = LoadStringDx(IDS_MESSAGE);
        column.iSubItem = 1;
        ListView_InsertColumn(m_hLst1, 1, &column);

        column.mask = LVCF_FMT | LVCF_SUBITEM | LVCF_TEXT | LVCF_WIDTH;
        column.fmt = LVCFMT_LEFT;
        column.cx = 200;
        column.pszText = LoadStringDx(IDS_STRING);
        column.iSubItem = 2;
        ListView_InsertColumn(m_hLst1, 2, &column);

        typedef DlgInitRes::entries_type entries_type;
        const entries_type& entries = m_dlginit_res.entries();

        INT i = 0;
        for (auto& entry : entries)
        {
            MString str;

            str = g_db.GetCtrlOrCmdName(entry.wCtrl);

            LV_ITEM item;
            ZeroMemory(&item, sizeof(item));
            item.iItem = i;
            item.mask = LVIF_TEXT;
            item.iSubItem = 0;
            item.pszText = &str[0];
            ListView_InsertItem(m_hLst1, &item);

            switch (entry.wMsg)
            {
            case WIN16_LB_ADDSTRING:
            case LB_ADDSTRING:
                str = L"LB_ADDSTRING";
                break;
            case WIN16_CB_ADDSTRING:
            case CB_ADDSTRING:
                str = L"CB_ADDSTRING";
                break;
            case AFX_CB_ADDSTRING:
            case CBEM_INSERTITEM:
                str = L"CBEM_INSERTITEM";
                break;
            default:
                str = mstr_hex_word(entry.wMsg);
                break;
            }

            ZeroMemory(&item, sizeof(item));
            item.iItem = i;
            item.mask = LVIF_TEXT;
            item.iSubItem = 1;
            item.pszText = &str[0];
            ListView_SetItem(m_hLst1, &item);

            str = MAnsiToText(CP_ACP, entry.strText).c_str();
            str = mstr_quote(str);

            ZeroMemory(&item, sizeof(item));
            item.iItem = i;
            item.mask = LVIF_TEXT;
            item.iSubItem = 2;
            item.pszText = &str[0];
            ListView_SetItem(m_hLst1, &item);

            ++i;
        }

        UINT state = LVIS_SELECTED | LVIS_FOCUSED;
        ListView_SetItemState(m_hLst1, 0, state, state);
        SetFocus(m_hLst1);

        m_resizable.OnParentCreate(hwnd);

        m_resizable.SetLayoutAnchor(lst1, mzcLA_TOP_LEFT, mzcLA_BOTTOM_RIGHT);
        m_resizable.SetLayoutAnchor(psh1, mzcLA_TOP_RIGHT);
        m_resizable.SetLayoutAnchor(psh2, mzcLA_TOP_RIGHT);
        m_resizable.SetLayoutAnchor(psh3, mzcLA_TOP_RIGHT);
        m_resizable.SetLayoutAnchor(psh4, mzcLA_TOP_RIGHT);
        m_resizable.SetLayoutAnchor(psh5, mzcLA_TOP_RIGHT);
        m_resizable.SetLayoutAnchor(psh6, mzcLA_BOTTOM_LEFT);
        m_resizable.SetLayoutAnchor(IDOK, mzcLA_BOTTOM_RIGHT);
        m_resizable.SetLayoutAnchor(IDCANCEL, mzcLA_BOTTOM_RIGHT);

        SendMessageDx(WM_SETICON, ICON_BIG, (LPARAM)m_hIcon);
        SendMessageDx(WM_SETICON, ICON_SMALL, (LPARAM)m_hIconSm);

        CenterWindowDx();
        return TRUE;
    }

    void OnContextMenu(HWND hwnd, HWND hwndContext, UINT xPos, UINT yPos)
    {
        if (hwndContext == m_hLst1)
        {
            PopupMenuDx(hwnd, m_hLst1, IDR_POPUPMENUS, 7, xPos, yPos);
        }
    }
};

```

`src/MDlgPropDlg.hpp`:

```hpp
// MDlgPropDlg.hpp --- "Properties for Dialog" Dialog
//////////////////////////////////////////////////////////////////////////////
// RisohEditor --- Another free Win32 resource editor
// Copyright (C) 2017-2018 Katayama Hirofumi MZ <katayama.hirofumi.mz@gmail.com>
// 
// This program is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
// 
// This program is distributed in the hope that it will be useful, 
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
// 
// You should have received a copy of the GNU General Public License
// along with this program.  If not, see <http://www.gnu.org/licenses/>.
//////////////////////////////////////////////////////////////////////////////

#pragma once

#include "resource.h"
#include "MWindowBase.hpp"
#include "RisohSettings.hpp"
#include "ConstantsDB.hpp"
#include "MComboBoxAutoComplete.hpp"
#include "DialogRes.hpp"
#include "Common.hpp"

class MDlgPropDlg;

//////////////////////////////////////////////////////////////////////////////

class MDlgPropDlg : public MDialogBase
{
public:
    DialogRes&      m_dialog_res;
    BOOL            m_bUpdating;
    DWORD           m_dwStyle;
    DWORD           m_dwExStyle;
    ConstantsDB::TableType  m_style_table;
    ConstantsDB::TableType  m_exstyle_table;
    std::vector<BYTE>       m_style_selection;
    std::vector<BYTE>       m_exstyle_selection;
    MComboBoxAutoComplete m_cmb1;
    MComboBoxAutoComplete m_cmb3;
    MComboBoxAutoComplete m_cmb6;

    MDlgPropDlg(DialogRes& dialog_res) :
        MDialogBase(IDD_DLGPROP), m_dialog_res(dialog_res), m_bUpdating(FALSE)
    {
        m_cmb1.m_bAcceptSpace = TRUE;
    }

    void InitTables(LPCTSTR pszClass)
    {
        ConstantsDB::TableType table;

        m_style_table.clear();
        if (pszClass && pszClass[0])
        {
            table = g_db.GetTable(pszClass);
            for (auto& item : table)
            {
                if (item.name.find(L'|') != std::wstring::npos)
                    continue;
                m_style_table.push_back(item);
            }
        }
        table = g_db.GetTable(TEXT("PARENT.STYLE"));
        for (auto& item : table)
        {
            if (item.name.find(L'|') != std::wstring::npos)
                continue;
            m_style_table.push_back(item);
        }
        m_style_selection.resize(m_style_table.size());

        m_exstyle_table.clear();
        table = g_db.GetTable(TEXT("EXSTYLE"));
        if (table.size())
        {
            m_exstyle_table.insert(m_exstyle_table.end(), 
                table.begin(), table.end());
        }
        m_exstyle_selection.resize(m_exstyle_table.size());
    }

    void InitMenuComboBox(HWND hCmb)
    {
        ComboBox_ResetContent(hCmb);

        auto table = g_db.GetTable(L"RESOURCE.ID.PREFIX");
        MStringW prefix = table[IDTYPE_MENU].name;

        table = g_db.GetTable(L"RESOURCE.ID");
        for (auto& table_entry : table)
        {
            if (table_entry.name.find(prefix) == 0)
            {
                ComboBox_AddString(hCmb, table_entry.name.c_str());
            }
        }
    }

    void ApplySelection(HWND hLst, std::vector<BYTE>& sel)
    {
        m_bUpdating = TRUE;
        INT iTop = ListBox_GetTopIndex(hLst);
        for (size_t i = 0; i < sel.size(); ++i)
        {
            ListBox_SetSel(hLst, sel[i], (DWORD)i);
        }
        ListBox_SetTopIndex(hLst, iTop);
        m_bUpdating = FALSE;
    }

    void ApplySelection(HWND hLst, ConstantsDB::TableType& table, 
                        std::vector<BYTE>& sel, DWORD dwValue)
    {
        m_bUpdating = TRUE;
        INT iTop = ListBox_GetTopIndex(hLst);
        for (size_t i = 0; i < table.size(); ++i)
        {
            sel[i] = ((dwValue & table[i].mask) == table[i].value);
            ListBox_SetSel(hLst, sel[i], (DWORD)i);
        }
        ListBox_SetTopIndex(hLst, iTop);
        m_bUpdating = FALSE;
    }

    BOOL OnInitDialog(HWND hwnd, HWND hwndFocus, LPARAM lParam)
    {
        MString strCaption = m_dialog_res.m_title.c_str();
        if (strCaption.size())
        {
            strCaption = mstr_quote(strCaption);
        }

        SubclassChildDx(m_cmb1, cmb1);
        InitCaptionComboBox(m_cmb1, strCaption.c_str());
        SendDlgItemMessage(hwnd, cmb1, CB_LIMITTEXT, 64, 0);

        if (m_dialog_res.IsExtended())
        {
            CheckDlgButton(hwnd, chx1, BST_CHECKED);
            EnableWindow(GetDlgItem(hwnd, cmb3), TRUE);
            EnableWindow(GetDlgItem(hwnd, cmb6), TRUE);
            EnableWindow(GetDlgItem(hwnd, chx2), TRUE);
            EnableWindow(GetDlgItem(hwnd, chx3), TRUE);
            EnableWindow(GetDlgItem(hwnd, cmb5), TRUE);
        }
        else
        {
            CheckDlgButton(hwnd, chx1, BST_UNCHECKED);
            EnableWindow(GetDlgItem(hwnd, cmb3), FALSE);
            EnableWindow(GetDlgItem(hwnd, cmb6), FALSE);
            EnableWindow(GetDlgItem(hwnd, chx2), FALSE);
            EnableWindow(GetDlgItem(hwnd, chx3), FALSE);
            EnableWindow(GetDlgItem(hwnd, cmb5), FALSE);
        }

        HWND hCmb4 = GetDlgItem(hwnd, cmb4);
        InitFontComboBox(hCmb4);

        HWND hCmb5 = GetDlgItem(hwnd, cmb5);
        InitCharSetComboBox(hCmb5, m_dialog_res.m_charset);

        HWND hCmb6 = GetDlgItem(hwnd, cmb6);
        InitMenuComboBox(hCmb6);

        if (m_dialog_res.m_weight >= FW_BOLD)
            CheckDlgButton(hwnd, chx2, BST_CHECKED);
        if (m_dialog_res.m_italic)
            CheckDlgButton(hwnd, chx3, BST_CHECKED);

        SetDlgItemInt(hwnd, edt1, m_dialog_res.m_pt.x, TRUE);
        SetDlgItemInt(hwnd, edt2, m_dialog_res.m_pt.y, TRUE);
        SetDlgItemInt(hwnd, edt3, m_dialog_res.m_siz.cx, TRUE);
        SetDlgItemInt(hwnd, edt4, m_dialog_res.m_siz.cy, TRUE);
        SendDlgItemMessage(hwnd, edt1, EM_SETLIMITTEXT, 12, 0);
        SendDlgItemMessage(hwnd, edt2, EM_SETLIMITTEXT, 12, 0);
        SendDlgItemMessage(hwnd, edt3, EM_SETLIMITTEXT, 12, 0);
        SendDlgItemMessage(hwnd, edt4, EM_SETLIMITTEXT, 12, 0);

        SetDlgItemTextW(hwnd, cmb2, m_dialog_res.m_class.c_str_or_empty());
        SendDlgItemMessage(hwnd, cmb2, CB_LIMITTEXT, 64, 0);

        MStringW strHelp = g_db.GetNameOfResID(IDTYPE_HELP, m_dialog_res.m_help_id);
        SetDlgItemText(hwnd, cmb3, strHelp.c_str());
        InitResNameComboBox(GetDlgItem(hwnd, cmb3), L"", IDTYPE_HELP);
        SubclassChildDx(m_cmb3, cmb3);
        SendDlgItemMessage(hwnd, cmb3, CB_LIMITTEXT, 64, 0);

        SetDlgItemTextW(hwnd, cmb4, m_dialog_res.type_face().c_str_or_empty());
        SendDlgItemMessage(hwnd, cmb4, CB_LIMITTEXT, LF_FULLFACESIZE - 1, 0);

        SetDlgItemInt(hwnd, edt5, m_dialog_res.m_point_size, TRUE);
        SendDlgItemMessage(hwnd, edt5, EM_SETLIMITTEXT, 12, 0);

        MString strMenu;
        if (m_dialog_res.m_menu.empty())
            ;
        else if (m_dialog_res.m_menu.is_int())
            strMenu = g_db.GetNameOfResID(IDTYPE_MENU, m_dialog_res.m_menu.m_id);
        else
            strMenu = m_dialog_res.m_menu.str();
        SetDlgItemTextW(hwnd, cmb6, strMenu.c_str());
        SendDlgItemMessage(hwnd, cmb6, CB_LIMITTEXT, 64, 0);
        SubclassChildDx(m_cmb6, cmb6);

        InitTables(TEXT("DIALOG"));

        WCHAR Buf[32];

        m_dwStyle = m_dialog_res.m_style;
        HWND hLst1 = GetDlgItem(hwnd, lst1);
        GetStyleSelect(m_style_selection, m_style_table, m_dwStyle);
        InitStyleListBox(hLst1, m_style_table);
        ApplySelection(hLst1, m_style_table, m_style_selection, m_dwStyle);

        m_bUpdating = TRUE;
        StringCchPrintfW(Buf, _countof(Buf), L"%08X", m_dwStyle);
        SetDlgItemTextW(hwnd, edt6, Buf);
        SendDlgItemMessage(hwnd, edt6, EM_SETLIMITTEXT, 8, 0);
        m_bUpdating = FALSE;

        m_dwExStyle = m_dialog_res.m_ex_style;
        HWND hLst2 = GetDlgItem(hwnd, lst2);
        GetStyleSelect(m_exstyle_selection, m_exstyle_table, m_dwExStyle);
        InitStyleListBox(hLst2, m_exstyle_table);
        ApplySelection(hLst2, m_exstyle_table, m_exstyle_selection, m_dwExStyle);

        m_bUpdating = TRUE;
        StringCchPrintfW(Buf, _countof(Buf), L"%08X", m_dwExStyle);
        SetDlgItemTextW(hwnd, edt7, Buf);
        SendDlgItemMessage(hwnd, edt7, EM_SETLIMITTEXT, 8, 0);
        m_bUpdating = FALSE;

        SendDlgItemMessage(hwnd, scr1, UDM_SETRANGE, 0, MAKELPARAM(9999, -9999));
        SendDlgItemMessage(hwnd, scr2, UDM_SETRANGE, 0, MAKELPARAM(9999, -9999));
        SendDlgItemMessage(hwnd, scr3, UDM_SETRANGE, 0, MAKELPARAM(9999, -9999));
        SendDlgItemMessage(hwnd, scr4, UDM_SETRANGE, 0, MAKELPARAM(9999, -9999));

        CenterWindowDx();
        return TRUE;
    }

    INT PointSizeFromStockFont(MString& strFont, INT nObject)
    {
        HFONT hFont = HFONT(GetStockObject(nObject));

        LOGFONT lf;
        GetObject(hFont, sizeof(lf), &lf);

        strFont = lf.lfFaceName;

        HDC hDC = CreateCompatibleDC(NULL);
        SelectObject(hDC, hFont);

        // lf.lfHeight --> nFontSize
        INT nFontSize;
        if (lf.lfHeight < 0)
        {
            lf.lfHeight = -lf.lfHeight;
        }
        else
        {
            TEXTMETRIC tm;
            GetTextMetrics(hDC, &tm);
            lf.lfHeight -= tm.tmInternalLeading;
        }
        nFontSize = MulDiv(lf.lfHeight, 72, GetDeviceCaps(hDC, LOGPIXELSY));

        DeleteDC(hDC);

        return nFontSize;
    }

    void OnOK(HWND hwnd)
    {
        BOOL bExtended = (::IsDlgButtonChecked(hwnd, chx1) == BST_CHECKED);
        BOOL bBold = (::IsDlgButtonChecked(hwnd, chx2) == BST_CHECKED);
        BOOL bItalic = (::IsDlgButtonChecked(hwnd, chx3) == BST_CHECKED);

        MString strCaption = GetDlgItemText(cmb1);
        g_settings.AddCaption(strCaption.c_str());
        if (strCaption[0] == TEXT('"'))
        {
            mstr_unquote(strCaption);
        }

        INT x = ::GetDlgItemInt(hwnd, edt1, NULL, TRUE);
        INT y = ::GetDlgItemInt(hwnd, edt2, NULL, TRUE);
        INT cx = ::GetDlgItemInt(hwnd, edt3, NULL, TRUE);
        INT cy = ::GetDlgItemInt(hwnd, edt4, NULL, TRUE);

        MString strClass = GetDlgItemText(cmb2);
        mstr_trim(strClass);
        if (strClass[0] == TEXT('"'))
        {
            mstr_unquote(strClass);
        }

        MString strHelp = GetDlgItemText(cmb3);
        ReplaceFullWithHalf(strHelp);
        mstr_trim(strHelp);
        DWORD help;
        if (g_db.HasResID(strHelp))
        {
            help = g_db.GetResIDValue(strHelp);
        }
        else
        {
            help = mstr_parse_int(strHelp.c_str());
        }

        INT nFontSize = GetDlgItemInt(hwnd, edt5, NULL, TRUE);

        MString strMenu = GetDlgItemText(cmb6);
        mstr_trim(strMenu);
        MIdOrString menu(strMenu.c_str());
        if (menu.is_str() && g_db.HasResID(menu.c_str()))
        {
            menu = (WORD)g_db.GetResIDValue(menu.c_str());
        }

        MString strStyle = GetDlgItemText(edt6);
        ReplaceFullWithHalf(strStyle);
        mstr_trim(strStyle);
        DWORD style = mstr_parse_int(strStyle.c_str(), false, 16);

        MString strExStyle = GetDlgItemText(edt7);
        mstr_trim(strExStyle);
        DWORD exstyle = mstr_parse_int(strExStyle.c_str(), false, 16);

        MString strFont = GetDlgItemText(cmb4);
        mstr_trim(strFont);

        if (strFont.empty())
            style &= ~DS_SETFONT;

        if ((style & DS_SHELLFONT) == DS_FIXEDSYS)
        {
            strFont.clear();
            nFontSize = 0;
        }

        if (bExtended)
        {
            m_dialog_res.m_version = 1;
            m_dialog_res.m_signature = 0xFFFF;
        }
        else
        {
            m_dialog_res.m_version = 0;
            m_dialog_res.m_signature = 0;
        }

        m_dialog_res.m_help_id = help;
        m_dialog_res.m_style = style;
        m_dialog_res.m_ex_style = exstyle;
        m_dialog_res.m_pt.x = x;
        m_dialog_res.m_pt.y = y;
        m_dialog_res.m_siz.cx = cx;
        m_dialog_res.m_siz.cy = cy;
        m_dialog_res.m_menu = menu;
        m_dialog_res.m_class = strClass.c_str();
        m_dialog_res.m_title = strCaption.c_str();
        m_dialog_res.m_point_size = (short)nFontSize;
        m_dialog_res.m_weight = FW_NORMAL;
        m_dialog_res.m_italic = FALSE;
        m_dialog_res.m_charset = DEFAULT_CHARSET;
        m_dialog_res.type_face(strFont.c_str());

        m_dialog_res.m_weight = (bBold ? FW_BOLD : FW_DONTCARE);
        m_dialog_res.m_italic = (bItalic ? TRUE : FALSE);

        HWND hCmb5 = GetDlgItem(hwnd, cmb5);
        m_dialog_res.m_charset = GetCharSetFromComboBox(hCmb5);

        EndDialog(IDOK);
    }

    void OnLst1(HWND hwnd)
    {
        if (m_bUpdating)
            return;

        HWND hLst1 = GetDlgItem(hwnd, lst1);

        std::vector<BYTE> old_style_selection = m_style_selection;
        GetStyleSelect(hLst1, m_style_selection);

        DWORD dwOldStyle = m_dwStyle;
        m_dwStyle = AnalyseStyleDiff(m_dwStyle, m_style_table, 
                                     old_style_selection, m_style_selection);
        ApplySelection(hLst1, m_style_table, m_style_selection, m_dwStyle);

        m_bUpdating = TRUE;
        TCHAR szText[32];
        StringCchPrintf(szText, _countof(szText), TEXT("%08lX"), m_dwStyle);
        SetDlgItemText(hwnd, edt6, szText);
        if ((dwOldStyle & DS_SETFONT) && !(m_dwStyle & DS_SETFONT))
        {
            SetDlgItemTextW(hwnd, cmb4, NULL);
            SetDlgItemInt(hwnd, edt5, 0, FALSE);
        }
        if (!(dwOldStyle & DS_SETFONT) && (m_dwStyle & DS_SETFONT))
        {
            if ((m_dwStyle & DS_SHELLFONT) == DS_SHELLFONT)
            {
                SetDlgItemTextW(hwnd, cmb4, L"MS Shell Dlg");
            }
            else
            {
                HDC hDC = CreateCompatibleDC(NULL);
                HFONT hFont = HFONT(GetStockObject(DEFAULT_GUI_FONT));
                SelectObject(hDC, hFont);

                LOGFONTW lf;
                GetObjectW(hFont, sizeof(lf), &lf);
                if (lf.lfHeight < 0)
                {
                    lf.lfHeight = -lf.lfHeight;
                }
                else
                {
                    TEXTMETRIC tm;
                    GetTextMetrics(hDC, &tm);
                    lf.lfHeight -= tm.tmInternalLeading;
                }
                INT nFontSize = MulDiv(lf.lfHeight, 72, GetDeviceCaps(hDC, LOGPIXELSY));
                DeleteDC(hDC);

                SetDlgItemTextW(hwnd, cmb4, lf.lfFaceName);
                SetDlgItemInt(hwnd, edt5, nFontSize, FALSE);
            }
        }
        m_bUpdating = FALSE;
    }

    void OnLst2(HWND hwnd)
    {
        if (m_bUpdating)
            return;

        HWND hLst2 = GetDlgItem(hwnd, lst2);

        std::vector<BYTE> old_exstyle_selection = m_exstyle_selection;
        GetStyleSelect(hLst2, m_exstyle_selection);

        m_dwExStyle = AnalyseStyleDiff(m_dwExStyle, m_exstyle_table, 
                                       old_exstyle_selection, m_exstyle_selection);
        ApplySelection(hLst2, m_exstyle_table, m_exstyle_selection, m_dwExStyle);

        m_bUpdating = TRUE;
        TCHAR szText[32];
        StringCchPrintf(szText, _countof(szText), TEXT("%08lX"), m_dwExStyle);
        SetDlgItemText(hwnd, edt7, szText);
        m_bUpdating = FALSE;
    }

    void OnEdt6(HWND hwnd)
    {
        if (m_bUpdating)
            return;

        MString text = GetDlgItemText(hwnd, edt6);
        mstr_trim(text);
        DWORD dwStyle = mstr_parse_int(text.c_str(), false, 16);

        GetStyleSelect(m_style_selection, m_style_table, dwStyle);

        HWND hLst1 = GetDlgItem(hwnd, lst1);
        m_dwStyle = dwStyle;
        ApplySelection(hLst1, m_style_table, m_style_selection, dwStyle);
    }

    void OnEdt7(HWND hwnd)
    {
        if (m_bUpdating)
            return;

        MString text = GetDlgItemText(hwnd, edt7);
        mstr_trim(text);
        DWORD dwExStyle = mstr_parse_int(text.c_str(), false, 16);

        GetStyleSelect(m_exstyle_selection, m_exstyle_table, dwExStyle);

        HWND hLst2 = GetDlgItem(hwnd, lst2);
        m_dwExStyle = dwExStyle;
        ApplySelection(hLst2, m_exstyle_table, m_exstyle_selection, dwExStyle);
    }

    void OnCommand(HWND hwnd, int id, HWND hwndCtl, UINT codeNotify)
    {
        switch (id)
        {
        case IDOK:
            OnOK(hwnd);
            break;
        case IDCANCEL:
            EndDialog(IDCANCEL);
            break;
        case lst1:
            if (codeNotify == LBN_SELCHANGE)
            {
                OnLst1(hwnd);
            }
            break;
        case lst2:
            if (codeNotify == LBN_SELCHANGE)
            {
                OnLst2(hwnd);
            }
            break;
        case edt6:
            if (codeNotify == EN_CHANGE)
            {
                OnEdt6(hwnd);
            }
            break;
        case edt7:
            if (codeNotify == EN_CHANGE)
            {
                OnEdt7(hwnd);
            }
            break;
        case chx1:
            if (::IsDlgButtonChecked(hwnd, chx1) == BST_CHECKED)
            {
                EnableWindow(GetDlgItem(hwnd, cmb3), TRUE);
                EnableWindow(GetDlgItem(hwnd, cmb6), TRUE);
                EnableWindow(GetDlgItem(hwnd, chx2), TRUE);
                EnableWindow(GetDlgItem(hwnd, chx3), TRUE);
                EnableWindow(GetDlgItem(hwnd, cmb5), TRUE);
            }
            else
            {
                EnableWindow(GetDlgItem(hwnd, cmb3), FALSE);
                EnableWindow(GetDlgItem(hwnd, cmb6), FALSE);
                EnableWindow(GetDlgItem(hwnd, chx2), FALSE);
                EnableWindow(GetDlgItem(hwnd, chx3), FALSE);
                EnableWindow(GetDlgItem(hwnd, cmb5), FALSE);
            }
            break;
        case cmb3:
            if (codeNotify == CBN_EDITCHANGE)
            {
                m_cmb3.OnEditChange();
            }
            break;
        case cmb6:
            if (codeNotify == CBN_EDITCHANGE)
            {
                m_cmb6.OnEditChange();
            }
            break;
        }
    }

    virtual INT_PTR CALLBACK
    DialogProcDx(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
    {
        switch (uMsg)
        {
            HANDLE_MSG(hwnd, WM_INITDIALOG, OnInitDialog);
            HANDLE_MSG(hwnd, WM_COMMAND, OnCommand);
        }
        return DefaultProcDx();
    }
};

```

`src/MDropdownArrow.hpp`:

```hpp
// MDropdownArrow.hpp --- Language drop-down list and arrow
//////////////////////////////////////////////////////////////////////////////
// RisohEditor --- Another free Win32 resource editor
// Copyright (C) 2020 Katayama Hirofumi MZ <katayama.hirofumi.mz@gmail.com>
// 
// This program is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
// 
// This program is distributed in the hope that it will be useful, 
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
// 
// You should have received a copy of the GNU General Public License
// along with this program.  If not, see <http://www.gnu.org/licenses/>.
//////////////////////////////////////////////////////////////////////////////

#pragma once

#include "resource.h"
#include "MWindowBase.hpp"
#include "Common.hpp"

#define MYWM_SETITEMRECT (WM_USER + 100)
#define MYWM_COMPLEMENT (WM_USER + 112)
#define MYWM_CLOSELIST (WM_USER + 103)

class MDropdownListDlg : public MDialogBase
{
public:
    HWND m_lst1;
    HWND m_arrow;

    MDropdownListDlg() : MDialogBase(IDD_DROPDOWNPOPUP)
    {
    }

    BOOL OnInitDialog(HWND hwnd, HWND hwndFocus, LPARAM lParam)
    {
        ShowWindow(hwnd, SW_HIDE);
        m_lst1 = GetDlgItem(hwnd, lst1);
        InitList(hwnd);
        return TRUE;
    }

    void InitList(HWND hwnd)
    {
        InitLangListBox(m_lst1);

        INT nCount = (INT)SendMessageW(m_lst1, LB_GETCOUNT, 0, 0);

        RECT rc;
        SendMessageW(m_lst1, LB_GETITEMRECT, 0, (LPARAM)&rc);
        LONG cy = rc.bottom - rc.top;

        if (nCount > 10)
            nCount = 10;

        GetClientRect(hwnd, &rc);
        rc.bottom = rc.top + nCount * cy;
        DWORD style = GetWindowStyle(hwnd);
        DWORD exstyle = GetWindowExStyle(hwnd);
        AdjustWindowRectEx(&rc, style, FALSE, exstyle);

        style = GetWindowStyle(m_lst1);
        exstyle = GetWindowExStyle(m_lst1);
        AdjustWindowRectEx(&rc, style, FALSE, exstyle);

        MoveWindow(hwnd, rc.left, rc.top, rc.right - rc.left, rc.bottom - rc.top, TRUE);

        SetTimer(hwnd, 999, 250, NULL);
    }

    void OnCommand(HWND hwnd, int id, HWND hwndCtl, UINT codeNotify)
    {
        switch (id)
        {
        case lst1:
            if (codeNotify == LBN_DBLCLK)
            {
                PostMessage(m_arrow, MYWM_COMPLEMENT, VK_RETURN, 0);
            }
            break;
        }
    }

    void OnSize(HWND hwnd, UINT state, int cx, int cy)
    {
        MoveWindow(GetDlgItem(hwnd, lst1), 0, 0, cx, cy, TRUE);
    }

    void OnTimer(HWND hwnd, UINT id)
    {
        HWND hwndOwner = GetWindow(hwnd, GW_OWNER);
        HWND hwndFocus = GetFocus();
        if (m_arrow != hwndFocus && hwnd != hwndFocus &&
            hwndOwner != hwndFocus && m_lst1 != hwndFocus)
        {
            KillTimer(hwnd, 999);
            PostMessage(m_arrow, MYWM_CLOSELIST, 0, 0);
        }
    }

    int OnVKeyToItem(HWND hwnd, UINT vk, HWND hwndListbox, int iCaret)
    {
        switch (vk)
        {
        case VK_DOWN:
        case VK_UP:
        case VK_PRIOR:
        case VK_NEXT:
        case VK_HOME:
        case VK_END:
            return -1;
        case VK_RETURN:
            PostMessage(m_arrow, MYWM_COMPLEMENT, VK_RETURN, 0);
            return -2;
        }
        return 0;
    }

    virtual INT_PTR CALLBACK
    DialogProcDx(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
    {
        switch (uMsg)
        {
        HANDLE_MSG(hwnd, WM_INITDIALOG, OnInitDialog);
        HANDLE_MSG(hwnd, WM_COMMAND, OnCommand);
        HANDLE_MSG(hwnd, WM_SIZE, OnSize);
        HANDLE_MSG(hwnd, WM_TIMER, OnTimer);
        HANDLE_MSG(hwnd, WM_VKEYTOITEM, OnVKeyToItem);
        default:
            return DefaultProcDx();
        }
    }
};

class MDropdownArrow : public MWindowBase
{
public:
    BOOL m_bDown;
    RECT m_rcItem;
    MDropdownListDlg m_dialog;
    HWND m_hwndMain;

    MDropdownArrow()
    {
    }

    virtual LPCTSTR GetWndClassNameDx() const
    {
        return TEXT("MZC4 Dropdown Arrow");
    }

    BOOL DoComplement(HWND hwnd, WPARAM wParam)
    {
        INT nIndex = (INT)SendMessage(m_dialog.m_lst1, LB_GETCURSEL, 0, 0);
        switch (wParam)
        {
        case VK_RETURN:
            PostMessageW(m_hwndMain, MYWM_COMPLEMENT, nIndex, 0);
            ShowDropDownList(hwnd, FALSE);
            return TRUE;
        case VK_ESCAPE:
            ShowDropDownList(hwnd, FALSE);
            return TRUE;
        }
        return FALSE;
    }

    virtual LRESULT CALLBACK
    WindowProcDx(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
    {
        switch (uMsg)
        {
        HANDLE_MSG(hwnd, WM_CREATE, OnCreate);
        HANDLE_MSG(hwnd, WM_PAINT, OnPaint);
        HANDLE_MSG(hwnd, WM_LBUTTONDOWN, OnLButtonDown);
        HANDLE_MSG(hwnd, WM_LBUTTONDBLCLK, OnLButtonDown);
        case MYWM_SETITEMRECT:
            OnSetItemRect(hwnd, (LPRECT)lParam);
            break;
        case MYWM_COMPLEMENT:
            DoComplement(hwnd, wParam);
            break;
        case MYWM_CLOSELIST:
            ShowDropDownList(hwnd, FALSE);
            break;
        default:
            return DefaultProcDx();
        }
        return 0;
    }

    void ShowDropDownList(HWND hwnd, BOOL bShow)
    {
        if (IsWindow(m_dialog))
        {
            DestroyWindow(m_dialog);
        }

        if (bShow)
        {
            assert(IsWindow(hwnd));
            m_dialog.CreateDialogDx(hwnd);
            m_dialog.m_arrow = hwnd;

            RECT rc;
            GetWindowRect(m_dialog, &rc);
            LONG cy = rc.bottom - rc.top;

            RECT rcItem = m_rcItem;
            MapWindowRect(GetParent(hwnd), NULL, &rcItem);

            POINT pt = { rcItem.left, rcItem.bottom };
            HMONITOR hMonitor = MonitorFromPoint(pt, MONITOR_DEFAULTTONEAREST);

            MONITORINFO mi = { sizeof(mi) };
            GetMonitorInfo(hMonitor, &mi);
            RECT& rcWork = mi.rcWork;

            LONG y;
            if (pt.y + cy < rcWork.bottom)
                y = pt.y;
            else
                y = rcItem.top - cy;

            SetWindowPos(m_dialog, NULL, rcItem.left, y, 0, 0,
                SWP_NOACTIVATE | SWP_NOSIZE | SWP_NOZORDER | SWP_NOOWNERZORDER | SWP_SHOWWINDOW);
        }

        m_bDown = bShow;

        if (hwnd)
            InvalidateRect(hwnd, NULL, TRUE);
    }

    SIZE GetArrowSize(LPCRECT prc) const
    {
        SIZE ret;
        ret.cx = prc->bottom - prc->top;
        ret.cy = prc->bottom - prc->top;
        return ret;
    }

protected:
    BOOL OnCreate(HWND hwnd, LPCREATESTRUCT lpCreateStruct)
    {
        m_bDown = FALSE;
        m_hwndMain = NULL;
        return TRUE;
    }

    void OnSetItemRect(HWND hwnd, LPCRECT prc)
    {
        m_rcItem = *prc;
        SIZE siz = GetArrowSize(prc);
        SetWindowPos(hwnd, NULL, 0, 0, siz.cx, siz.cy,
            SWP_NOMOVE | SWP_NOACTIVATE | SWP_NOOWNERZORDER | SWP_NOZORDER);
    }

    void OnPaint(HWND hwnd)
    {
        RECT rc;
        GetClientRect(hwnd, &rc);

        PAINTSTRUCT ps;
        if (HDC hdc = BeginPaint(hwnd, &ps))
        {
            if (m_bDown)
                DrawFrameControl(hdc, &rc, DFC_SCROLL, DFCS_SCROLLCOMBOBOX | DFCS_PUSHED);
            else
                DrawFrameControl(hdc, &rc, DFC_SCROLL, DFCS_SCROLLCOMBOBOX);

            EndPaint(hwnd, &ps);
        }
    }

    void OnLButtonDown(HWND hwnd, BOOL fDoubleClick, int x, int y, UINT keyFlags)
    {
        m_bDown = !m_bDown;
        InvalidateRect(hwnd, NULL, TRUE);

        SetFocus(GetParent(hwnd));
        ShowDropDownList(hwnd, m_bDown);
    }
};

```

`src/MEditAccelDlg.hpp`:

```hpp
// MEditAccelDlg.hpp --- Dialogs for edit of Accelerator Table
//////////////////////////////////////////////////////////////////////////////
// RisohEditor --- Another free Win32 resource editor
// Copyright (C) 2017-2018 Katayama Hirofumi MZ <katayama.hirofumi.mz@gmail.com>
// 
// This program is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
// 
// This program is distributed in the hope that it will be useful, 
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
// 
// You should have received a copy of the GNU General Public License
// along with this program.  If not, see <http://www.gnu.org/licenses/>.
//////////////////////////////////////////////////////////////////////////////

#pragma once

#include "resource.h"
#include "MWindowBase.hpp"
#include "RisohSettings.hpp"
#include "ConstantsDB.hpp"
#include "MResizable.hpp"
#include "MComboBoxAutoComplete.hpp"
#include "AccelRes.hpp"
#include "Common.hpp"

class MAddKeyDlg;
class MModifyKeyDlg;
class MEditAccelDlg;

//////////////////////////////////////////////////////////////////////////////

class MAddKeyDlg : public MDialogBase
{
public:
    ACCEL_ENTRY& m_entry;
    MComboBoxAutoComplete m_cmb1;
    MComboBoxAutoComplete m_cmb2;

    MAddKeyDlg(ACCEL_ENTRY& entry) :
        MDialogBase(IDD_ADDKEY), m_entry(entry)
    {
    }

    BOOL OnInitDialog(HWND hwnd, HWND hwndFocus, LPARAM lParam)
    {
        CheckDlgButton(hwnd, chx1, BST_CHECKED);

        HWND hCmb1 = GetDlgItem(hwnd, cmb1);
        Cmb1_InitVirtualKeys(hCmb1);
        SubclassChildDx(m_cmb1, cmb1);

        HWND hCmb2 = GetDlgItem(hwnd, cmb2);
        InitCtrlIDComboBox(hCmb2);
        SetDlgItemText(hwnd, cmb2, L"");
        SubclassChildDx(m_cmb2, cmb2);

        CenterWindowDx();
        return TRUE;
    }

    void OnOK(HWND hwnd)
    {
        HWND hCmb1 = GetDlgItem(hwnd, cmb1);
        GetWindowTextW(hCmb1, m_entry.sz0, _countof(m_entry.sz0));

        std::wstring str = m_entry.sz0;
        BOOL bVirtKey = IsDlgButtonChecked(hwnd, chx1) == BST_CHECKED;
        if (!Cmb1_CheckKey(hwnd, hCmb1, bVirtKey, str))
        {
            ErrorBoxDx(IDS_INVALIDKEY);
            return;
        }
        lstrcpynW(m_entry.sz0, str.c_str(), _countof(m_entry.sz0));

        WORD wFlags = 0;
        if (IsDlgButtonChecked(hwnd, chx1) == BST_CHECKED)
            wFlags |= FVIRTKEY;
        if (IsDlgButtonChecked(hwnd, chx2) == BST_CHECKED)
            wFlags |= FNOINVERT;
        if (IsDlgButtonChecked(hwnd, chx3) == BST_CHECKED)
            wFlags |= FCONTROL;
        if (IsDlgButtonChecked(hwnd, chx4) == BST_CHECKED)
            wFlags |= FSHIFT;
        if (IsDlgButtonChecked(hwnd, chx5) == BST_CHECKED)
            wFlags |= FALT;

        str = GetKeyFlags(wFlags);
        lstrcpynW(m_entry.sz1, str.c_str(), _countof(m_entry.sz1));

        GetDlgItemTextW(hwnd, cmb2, m_entry.sz2, _countof(m_entry.sz2));
        ReplaceFullWithHalf(m_entry.sz2);
        mstr_trim(m_entry.sz2);
        if (!CheckCommand(m_entry.sz2))
        {
            ErrorBoxDx(IDS_NOSUCHID);
            return;
        }

        EndDialog(IDOK);
    }

    void OnPsh1(HWND hwnd)
    {
        SendMessage(GetParent(GetParent(hwnd)), WM_COMMAND, ID_IDLIST, 0);
    }

    void OnCommand(HWND hwnd, int id, HWND hwndCtl, UINT codeNotify)
    {
        switch (id)
        {
        case IDOK:
            OnOK(hwnd);
            break;
        case IDCANCEL:
            EndDialog(IDCANCEL);
            break;
        case psh1:
            OnPsh1(hwnd);
            break;
        case cmb1:
            if (codeNotify == CBN_EDITCHANGE)
            {
                m_cmb1.OnEditChange();
            }
            break;
        case cmb2:
            if (codeNotify == CBN_EDITCHANGE)
            {
                m_cmb2.OnEditChange();
            }
            break;
        }
    }

    virtual INT_PTR CALLBACK
    DialogProcDx(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
    {
        switch (uMsg)
        {
            HANDLE_MSG(hwnd, WM_INITDIALOG, OnInitDialog);
            HANDLE_MSG(hwnd, WM_COMMAND, OnCommand);
        }
        return DefaultProcDx();
    }
};

//////////////////////////////////////////////////////////////////////////////

class MModifyKeyDlg : public MDialogBase
{
public:
    ACCEL_ENTRY& m_entry;
    MComboBoxAutoComplete m_cmb1;
    MComboBoxAutoComplete m_cmb2;

    MModifyKeyDlg(ACCEL_ENTRY& entry) :
        MDialogBase(IDD_MODIFYKEY), m_entry(entry)
    {
    }

    BOOL OnInitDialog(HWND hwnd, HWND hwndFocus, LPARAM lParam)
    {
        HWND hCmb2 = GetDlgItem(hwnd, cmb2);
        InitCtrlIDComboBox(hCmb2);
        SubclassChildDx(m_cmb2, cmb2);
        SetDlgItemTextW(hwnd, cmb2, m_entry.sz2);

        HWND hCmb1 = GetDlgItem(hwnd, cmb1);
        Cmb1_InitVirtualKeys(hCmb1);
        SetDlgItemTextW(hwnd, cmb1, m_entry.sz0);
        SubclassChildDx(m_cmb1, cmb1);

        WORD wFlags;
        SetKeyFlags(wFlags, m_entry.sz1);
        if (wFlags & FVIRTKEY)
            CheckDlgButton(hwnd, chx1, BST_CHECKED);
        if (wFlags & FNOINVERT)
            CheckDlgButton(hwnd, chx2, BST_CHECKED);
        if (wFlags & FCONTROL)
            CheckDlgButton(hwnd, chx3, BST_CHECKED);
        if (wFlags & FSHIFT)
            CheckDlgButton(hwnd, chx4, BST_CHECKED);
        if (wFlags & FALT)
            CheckDlgButton(hwnd, chx5, BST_CHECKED);

        if (wFlags & FVIRTKEY)
        {
            HWND hCmb1 = GetDlgItem(hwnd, cmb1);
            Cmb1_InitVirtualKeys(hCmb1);

            INT i = ComboBox_FindStringExact(hCmb1, -1, m_entry.sz0);
            if (i != CB_ERR)
            {
                ComboBox_SetCurSel(hCmb1, i);
            }
        }

        CenterWindowDx();
        return TRUE;
    }

    void OnOK(HWND hwnd)
    {
        HWND hCmb1 = GetDlgItem(hwnd, cmb1);
        GetWindowTextW(hCmb1, m_entry.sz0, _countof(m_entry.sz0));

        std::wstring str = m_entry.sz0;
        BOOL bVirtKey = IsDlgButtonChecked(hwnd, chx1) == BST_CHECKED;
        if (!Cmb1_CheckKey(hwnd, hCmb1, bVirtKey, str))
        {
            ErrorBoxDx(IDS_INVALIDKEY);
            return;
        }
        lstrcpynW(m_entry.sz0, str.c_str(), _countof(m_entry.sz0));

        WORD wFlags = 0;
        if (IsDlgButtonChecked(hwnd, chx1) == BST_CHECKED)
            wFlags |= FVIRTKEY;
        if (IsDlgButtonChecked(hwnd, chx2) == BST_CHECKED)
            wFlags |= FNOINVERT;
        if (IsDlgButtonChecked(hwnd, chx3) == BST_CHECKED)
            wFlags |= FCONTROL;
        if (IsDlgButtonChecked(hwnd, chx4) == BST_CHECKED)
            wFlags |= FSHIFT;
        if (IsDlgButtonChecked(hwnd, chx5) == BST_CHECKED)
            wFlags |= FALT;

        str = GetKeyFlags(wFlags);
        lstrcpynW(m_entry.sz1, str.c_str(), _countof(m_entry.sz1));

        GetDlgItemTextW(hwnd, cmb2, m_entry.sz2, _countof(m_entry.sz2));
        ReplaceFullWithHalf(m_entry.sz2);
        mstr_trim(m_entry.sz2);
        if (!CheckCommand(m_entry.sz2))
        {
            ErrorBoxDx(IDS_NOSUCHID);
            return;
        }

        EndDialog(IDOK);
    }

    void OnCommand(HWND hwnd, int id, HWND hwndCtl, UINT codeNotify)
    {
        switch (id)
        {
        case chx1:
            if (IsDlgButtonChecked(hwnd, chx1) == BST_CHECKED)
            {
                Cmb1_InitVirtualKeys(GetDlgItem(hwnd, cmb1));
            }
            else
            {
                SetDlgItemTextW(hwnd, cmb1, NULL);
            }
            break;
        case IDOK:
            OnOK(hwnd);
            break;
        case IDCANCEL:
            EndDialog(IDCANCEL);
            break;
        case psh1:
            OnPsh1(hwnd);
            break;
        case cmb1:
            if (codeNotify == CBN_EDITCHANGE)
            {
                m_cmb1.OnEditChange();
            }
            break;
        case cmb2:
            if (codeNotify == CBN_EDITCHANGE)
            {
                m_cmb2.OnEditChange();
            }
            break;
        }
    }

    void OnPsh1(HWND hwnd)
    {
        SendMessage(GetParent(GetParent(hwnd)), WM_COMMAND, ID_IDLIST, 0);
    }

    virtual INT_PTR CALLBACK
    DialogProcDx(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
    {
        switch (uMsg)
        {
            HANDLE_MSG(hwnd, WM_INITDIALOG, OnInitDialog);
            HANDLE_MSG(hwnd, WM_COMMAND, OnCommand);
        }
        return DefaultProcDx();
    }
};

//////////////////////////////////////////////////////////////////////////////

class MEditAccelDlg : public MDialogBase
{
public:
    AccelRes& m_accel_res;
    MResizable m_resizable;
    HICON m_hIcon;
    HICON m_hIconSm;
    HWND m_hLst1;

    MEditAccelDlg(AccelRes& accel_res)
        : MDialogBase(IDD_EDITACCEL), m_accel_res(accel_res)
    {
        m_hIcon = LoadIconDx(IDI_SMILY);
        m_hIconSm = LoadSmallIconDx(IDI_SMILY);
        m_hLst1 = NULL;
    }

    ~MEditAccelDlg()
    {
        DestroyIcon(m_hIcon);
        DestroyIcon(m_hIconSm);
    }

    void OnUp(HWND hwnd)
    {
        INT iItem = ListView_GetNextItem(m_hLst1, -1, LVNI_ALL | LVNI_SELECTED);
        if (iItem == 0)
            return;

        ACCEL_ENTRY ae0, ae1;
        ListView_GetItemText(m_hLst1, iItem - 1, 0, ae0.sz0, _countof(ae0.sz0));
        ListView_GetItemText(m_hLst1, iItem - 1, 1, ae0.sz1, _countof(ae0.sz1));
        ListView_GetItemText(m_hLst1, iItem - 1, 2, ae0.sz2, _countof(ae0.sz2));
        ListView_GetItemText(m_hLst1, iItem, 0, ae1.sz0, _countof(ae1.sz0));
        ListView_GetItemText(m_hLst1, iItem, 1, ae1.sz1, _countof(ae1.sz1));
        ListView_GetItemText(m_hLst1, iItem, 2, ae1.sz2, _countof(ae1.sz2));

        ListView_SetItemText(m_hLst1, iItem - 1, 0, ae1.sz0);
        ListView_SetItemText(m_hLst1, iItem - 1, 1, ae1.sz1);
        ListView_SetItemText(m_hLst1, iItem - 1, 2, ae1.sz2);
        ListView_SetItemText(m_hLst1, iItem, 0, ae0.sz0);
        ListView_SetItemText(m_hLst1, iItem, 1, ae0.sz1);
        ListView_SetItemText(m_hLst1, iItem, 2, ae0.sz2);

        UINT state = LVIS_SELECTED | LVIS_FOCUSED;
        ListView_SetItemState(m_hLst1, iItem - 1, state, state);
    }

    void OnDown(HWND hwnd)
    {
        INT iItem = ListView_GetNextItem(m_hLst1, -1, LVNI_ALL | LVNI_SELECTED);
        if (iItem + 1 == ListView_GetItemCount(m_hLst1))
            return;

        ACCEL_ENTRY ae0, ae1;
        ListView_GetItemText(m_hLst1, iItem, 0, ae0.sz0, _countof(ae0.sz0));
        ListView_GetItemText(m_hLst1, iItem, 1, ae0.sz1, _countof(ae0.sz1));
        ListView_GetItemText(m_hLst1, iItem, 2, ae0.sz2, _countof(ae0.sz2));
        ListView_GetItemText(m_hLst1, iItem + 1, 0, ae1.sz0, _countof(ae1.sz0));
        ListView_GetItemText(m_hLst1, iItem + 1, 1, ae1.sz1, _countof(ae1.sz1));
        ListView_GetItemText(m_hLst1, iItem + 1, 2, ae1.sz2, _countof(ae1.sz2));

        ListView_SetItemText(m_hLst1, iItem, 0, ae1.sz0);
        ListView_SetItemText(m_hLst1, iItem, 1, ae1.sz1);
        ListView_SetItemText(m_hLst1, iItem, 2, ae1.sz2);
        ListView_SetItemText(m_hLst1, iItem + 1, 0, ae0.sz0);
        ListView_SetItemText(m_hLst1, iItem + 1, 1, ae0.sz1);
        ListView_SetItemText(m_hLst1, iItem + 1, 2, ae0.sz2);

        UINT state = LVIS_SELECTED | LVIS_FOCUSED;
        ListView_SetItemState(m_hLst1, iItem + 1, state, state);
    }

    void OnDelete(HWND hwnd)
    {
        INT iItem = ListView_GetNextItem(m_hLst1, -1, LVNI_ALL | LVNI_SELECTED);
        if (iItem >= 0)
        {
            ListView_DeleteItem(m_hLst1, iItem);
        }
    }

    void OnDeleteAll(HWND hwnd)
    {
        ListView_DeleteAllItems(m_hLst1);
    }

    void OnAdd(HWND hwnd)
    {
        ACCEL_ENTRY entry;

        MAddKeyDlg dialog(entry);
        if (IDOK != dialog.DialogBoxDx(hwnd))
        {
            return;
        }

        INT iItem = ListView_GetItemCount(m_hLst1);

        LV_ITEM item;

        ZeroMemory(&item, sizeof(item));
        item.iItem = iItem;
        item.mask = LVIF_TEXT;
        item.iSubItem = 0;
        item.pszText = entry.sz0;
        ListView_InsertItem(m_hLst1, &item);

        ZeroMemory(&item, sizeof(item));
        item.iItem = iItem;
        item.mask = LVIF_TEXT;
        item.iSubItem = 1;
        item.pszText = entry.sz1;
        ListView_SetItem(m_hLst1, &item);

        ZeroMemory(&item, sizeof(item));
        item.iItem = iItem;
        item.mask = LVIF_TEXT;
        item.iSubItem = 2;
        item.pszText = entry.sz2;
        ListView_SetItem(m_hLst1, &item);

        UINT state = LVIS_SELECTED | LVIS_FOCUSED;
        ListView_SetItemState(m_hLst1, iItem, state, state);
        ListView_EnsureVisible(m_hLst1, iItem, FALSE);
    }

    void OnModify(HWND hwnd)
    {
        INT iItem = ListView_GetNextItem(m_hLst1, -1, LVNI_ALL | LVNI_SELECTED);
        if (iItem < 0)
        {
            return;
        }

        ACCEL_ENTRY a_entry;
        ListView_GetItemText(m_hLst1, iItem, 0, a_entry.sz0, _countof(a_entry.sz0));
        ListView_GetItemText(m_hLst1, iItem, 1, a_entry.sz1, _countof(a_entry.sz1));
        ListView_GetItemText(m_hLst1, iItem, 2, a_entry.sz2, _countof(a_entry.sz2));

        MModifyKeyDlg dialog(a_entry);
        if (IDOK == dialog.DialogBoxDx(hwnd))
        {
            ListView_SetItemText(m_hLst1, iItem, 0, a_entry.sz0);
            ListView_SetItemText(m_hLst1, iItem, 1, a_entry.sz1);
            ListView_SetItemText(m_hLst1, iItem, 2, a_entry.sz2);
        }
    }

    void OnOK(HWND hwnd)
    {
        INT i, nCount = ListView_GetItemCount(m_hLst1);

        if (nCount == 0)
        {
            ErrorBoxDx(IDS_DATAISEMPTY);
            return;
        }

        m_accel_res.entries().clear();
        for (i = 0; i < nCount; ++i)
        {
            ACCEL_ENTRY a_entry;
            ListView_GetItemText(m_hLst1, i, 0, a_entry.sz0, _countof(a_entry.sz0));
            ListView_GetItemText(m_hLst1, i, 1, a_entry.sz1, _countof(a_entry.sz1));
            ListView_GetItemText(m_hLst1, i, 2, a_entry.sz2, _countof(a_entry.sz2));

            WORD wFlags;
            SetKeyFlags(wFlags, a_entry.sz1);

            AccelTableEntry entry;
            entry.fFlags = wFlags;
            if (wFlags & FVIRTKEY)
            {
                entry.wAscii = (WORD)g_db.GetValue(L"VIRTUALKEYS", a_entry.sz0);
            }
            else
            {
                std::wstring str, str2 = a_entry.sz0;
                LPCWSTR pch = str2.c_str();
                if (guts_quote(str, pch))
                {
                    entry.wAscii = str[0];
                }
                else
                {
                    entry.wAscii = (WORD)mstr_parse_int(a_entry.sz0);
                }
            }
            entry.wId = (WORD)g_db.GetResIDValue(a_entry.sz2);

            m_accel_res.entries().push_back(entry);
        }

        EndDialog(IDOK);
    }

    void OnCommand(HWND hwnd, int id, HWND hwndCtl, UINT codeNotify)
    {
        switch (id)
        {
        case psh1:
            OnAdd(hwnd);
            break;
        case psh2:
            OnModify(hwnd);
            break;
        case psh3:
            OnDelete(hwnd);
            break;
        case psh4:
            OnUp(hwnd);
            break;
        case psh5:
            OnDown(hwnd);
            break;
        case psh6:
            OnDeleteAll(hwnd);
            break;
        case IDOK:
            OnOK(hwnd);
            break;
        case IDCANCEL:
            EndDialog(IDCANCEL);
            break;
        }
    }

    void OnItemChanged(HWND hwnd)
    {
        INT iItem = ListView_GetNextItem(m_hLst1, -1, LVNI_ALL | LVNI_SELECTED);
        BOOL bSelected = (iItem != -1);
        EnableWindow(GetDlgItem(hwnd, psh2), bSelected);
        EnableWindow(GetDlgItem(hwnd, psh3), bSelected);
        EnableWindow(GetDlgItem(hwnd, psh4), bSelected);
        EnableWindow(GetDlgItem(hwnd, psh5), bSelected);
    }

    void OnInitMenuPopup(HWND hwnd, HMENU hMenu, UINT item, BOOL fSystemMenu)
    {
        INT iItem = ListView_GetNextItem(m_hLst1, -1, LVNI_ALL | LVNI_SELECTED);
        BOOL bSelected = (iItem != -1);
        EnableMenuItem(hMenu, psh2, bSelected ? MF_ENABLED : MF_GRAYED);
        EnableMenuItem(hMenu, psh3, bSelected ? MF_ENABLED : MF_GRAYED);
        EnableMenuItem(hMenu, psh4, bSelected ? MF_ENABLED : MF_GRAYED);
        EnableMenuItem(hMenu, psh5, bSelected ? MF_ENABLED : MF_GRAYED);
    }

    LRESULT OnNotify(HWND hwnd, int idFrom, NMHDR *pnmhdr)
    {
        if (idFrom == lst1)
        {
            if (pnmhdr->code == LVN_KEYDOWN)
            {
                LV_KEYDOWN *KeyDown = (LV_KEYDOWN *)pnmhdr;
                if (KeyDown->wVKey == VK_DELETE)
                {
                    OnDelete(hwnd);
                    return 0;
                }
            }
            if (pnmhdr->code == NM_DBLCLK)
            {
                OnModify(hwnd);
                return 0;
            }
            if (pnmhdr->code == LVN_GETINFOTIP)
            {
                NMLVGETINFOTIP *pGetInfoTip = (NMLVGETINFOTIP *)pnmhdr;
                INT iItem = pGetInfoTip->iItem;
                INT iSubItem = pGetInfoTip->iSubItem;
                TCHAR szText[128];
                ListView_GetItemText(m_hLst1, iItem, iSubItem, szText, _countof(szText));
                StringCchCopy(pGetInfoTip->pszText, pGetInfoTip->cchTextMax, szText);
            }
            if (pnmhdr->code == LVN_ITEMCHANGED)
            {
                //NM_LISTVIEW *pListView = (NM_LISTVIEW *)pnmhdr;
                OnItemChanged(hwnd);
            }
        }
        return 0;
    }

    virtual INT_PTR CALLBACK
    DialogProcDx(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
    {
        switch (uMsg)
        {
            HANDLE_MSG(hwnd, WM_INITDIALOG, OnInitDialog);
            HANDLE_MSG(hwnd, WM_COMMAND, OnCommand);
            HANDLE_MSG(hwnd, WM_NOTIFY, OnNotify);
            HANDLE_MSG(hwnd, WM_SIZE, OnSize);
            HANDLE_MSG(hwnd, WM_CONTEXTMENU, OnContextMenu);
            HANDLE_MSG(hwnd, WM_INITMENUPOPUP, OnInitMenuPopup);
        }
        return DefaultProcDx();
    }

    void OnSize(HWND hwnd, UINT state, int cx, int cy)
    {
        m_resizable.OnSize();
    }

    BOOL OnInitDialog(HWND hwnd, HWND hwndFocus, LPARAM lParam)
    {
        m_hLst1 = GetDlgItem(hwnd, lst1);
        ListView_SetExtendedListViewStyle(m_hLst1, LVS_EX_FULLROWSELECT | LVS_EX_INFOTIP);

        LV_COLUMN column;
        ZeroMemory(&column, sizeof(column));

        column.mask = LVCF_FMT | LVCF_SUBITEM | LVCF_TEXT | LVCF_WIDTH;
        column.fmt = LVCFMT_LEFT;
        column.cx = 105;
        column.pszText = LoadStringDx(IDS_KEY);
        column.iSubItem = 0;
        ListView_InsertColumn(m_hLst1, 0, &column);

        column.mask = LVCF_FMT | LVCF_SUBITEM | LVCF_TEXT | LVCF_WIDTH;
        column.fmt = LVCFMT_LEFT;
        column.cx = 75;
        column.pszText = LoadStringDx(IDS_FLAGS);
        column.iSubItem = 1;
        ListView_InsertColumn(m_hLst1, 1, &column);

        column.mask = LVCF_FMT | LVCF_SUBITEM | LVCF_TEXT | LVCF_WIDTH;
        column.fmt = LVCFMT_LEFT;
        column.cx = 185;
        column.pszText = LoadStringDx(IDS_COMMANDID);
        column.iSubItem = 2;
        ListView_InsertColumn(m_hLst1, 2, &column);

        typedef AccelRes::entries_type entries_type;
        const entries_type& entries = m_accel_res.entries();

        INT i = 0;
        for (auto& entry : entries)
        {
            std::wstring str;
            if (entry.fFlags & FVIRTKEY)
            {
                str = g_db.GetName(L"VIRTUALKEYS", entry.wAscii);
            }
            else
            {
                str += (WCHAR)entry.wAscii;
                str = mstr_quote(str);
            }

            LV_ITEM item;
            ZeroMemory(&item, sizeof(item));
            item.iItem = i;
            item.mask = LVIF_TEXT;
            item.iSubItem = 0;
            item.pszText = &str[0];
            ListView_InsertItem(m_hLst1, &item);

            str = GetKeyFlags(entry.fFlags);

            ZeroMemory(&item, sizeof(item));
            item.iItem = i;
            item.mask = LVIF_TEXT;
            item.iSubItem = 1;
            item.pszText = &str[0];
            ListView_SetItem(m_hLst1, &item);

            str = GetKeyID(entry.wId);

            ZeroMemory(&item, sizeof(item));
            item.iItem = i;
            item.mask = LVIF_TEXT;
            item.iSubItem = 2;
            item.pszText = &str[0];
            ListView_SetItem(m_hLst1, &item);

            ++i;
        }

        UINT state = LVIS_SELECTED | LVIS_FOCUSED;
        ListView_SetItemState(m_hLst1, 0, state, state);
        SetFocus(m_hLst1);

        m_resizable.OnParentCreate(hwnd);

        m_resizable.SetLayoutAnchor(lst1, mzcLA_TOP_LEFT, mzcLA_BOTTOM_RIGHT);
        m_resizable.SetLayoutAnchor(psh1, mzcLA_TOP_RIGHT);
        m_resizable.SetLayoutAnchor(psh2, mzcLA_TOP_RIGHT);
        m_resizable.SetLayoutAnchor(psh3, mzcLA_TOP_RIGHT);
        m_resizable.SetLayoutAnchor(psh4, mzcLA_TOP_RIGHT);
        m_resizable.SetLayoutAnchor(psh5, mzcLA_TOP_RIGHT);
        m_resizable.SetLayoutAnchor(psh6, mzcLA_BOTTOM_LEFT);
        m_resizable.SetLayoutAnchor(IDOK, mzcLA_BOTTOM_RIGHT);
        m_resizable.SetLayoutAnchor(IDCANCEL, mzcLA_BOTTOM_RIGHT);

        SendMessageDx(WM_SETICON, ICON_BIG, (LPARAM)m_hIcon);
        SendMessageDx(WM_SETICON, ICON_SMALL, (LPARAM)m_hIconSm);

        CenterWindowDx();
        return TRUE;
    }

    void OnContextMenu(HWND hwnd, HWND hwndContext, UINT xPos, UINT yPos)
    {
        if (hwndContext == m_hLst1)
        {
            PopupMenuDx(hwnd, m_hLst1, IDR_POPUPMENUS, 7, xPos, yPos);
        }
    }
};

```

`src/MEditCtrl.hpp`:

```hpp
// MEditCtrl.hpp -- Win32API edit control wrapper               -*- C++ -*-
// This file is part of MZC4.  See file "ReadMe.txt" and "License.txt".
////////////////////////////////////////////////////////////////////////////

#ifndef MZC4_MEDITCTRL_HPP_
#define MZC4_MEDITCTRL_HPP_     4   /* Version 4 */

class MEditCtrl;

////////////////////////////////////////////////////////////////////////////

#include "MWindowBase.hpp"

class MEditCtrl : public MWindowBase
{
public:
    MEditCtrl();

    virtual LPCTSTR GetWndClassNameDx() const;

    BOOL CanUndo() const;
    INT GetLineCount() const;

    BOOL GetModify() const;
    VOID SetModify(BOOL bModified = TRUE);

    BOOL IsEmpty() const;

    HLOCAL GetHandle() const;
    VOID SetHandle(HLOCAL hBuffer);

    DWORD GetMargins() const;
    VOID SetMargins(UINT nLeft, UINT nRight);

    UINT GetLimitText() const;
    VOID SetLimitText(UINT nMax);

    POINT PosFromChar(UINT nChar) const;
    INT CharFromPos(POINT pt) const;

    VOID EmptyUndoBuffer();
    BOOL FmtLines(BOOL bAddEOL);

    VOID LimitText(INT nChars = 0);
    INT  LineFromChar(INT nIndex = -1) const;
    INT  LineIndex(INT nLine = -1) const;
    INT  LineLength(INT nLine = -1) const;
    INT  GetLine(INT nIndex, LPTSTR lpszBuffer, INT nMaxLength) const;
    VOID LineScroll(INT nLines, INT nChars = 0);

    TCHAR GetPasswordChar() const;
    VOID  SetPasswordChar(TCHAR ch);

    VOID GetRect(LPRECT prc) const;
    VOID SetRect(LPCRECT prc);
    VOID SetRectNP(LPCRECT prc);

    DWORD GetSel() const;
    VOID  GetSel(INT& nStartChar, INT& nEndChar) const;
    VOID  SetSel(DWORD dwSelection, BOOL bNoScroll = FALSE);
    VOID  SetSel(INT nStartChar, INT nEndChar, BOOL bNoScroll = FALSE);
    VOID  ReplaceSel(LPCTSTR lpszNewText, BOOL bCanUndo = FALSE);
    VOID  SelectAll(BOOL bNoScroll = FALSE);
    VOID  SelectNone(BOOL bNoScroll = FALSE);

    BOOL SetTabStops(INT nTabStops, LPINT rgTabStops);
    VOID SetTabStops();
    BOOL SetTabStops(const INT& cxEachStop);

    BOOL Undo();
    VOID Clear();
    VOID Copy();
    VOID Cut();
    VOID Paste();

    BOOL SetReadOnly(BOOL bReadOnly = TRUE);
    INT GetFirstVisibleLine() const;

    static void SetCtrlAHookDx(BOOL bHook);
    static BOOL DoMsgCtrlA(MSG *pMsg);

protected:
    static HHOOK& OldHookProc();
    static LRESULT CALLBACK
    CtrlAMsgProcDx(INT nCode, WPARAM wParam, LPARAM lParam);
};

////////////////////////////////////////////////////////////////////////////

inline MEditCtrl::MEditCtrl()
{
}

inline /*virtual*/ LPCTSTR MEditCtrl::GetWndClassNameDx() const
{
    return TEXT("EDIT");
}

inline BOOL MEditCtrl::CanUndo() const
{
    return (BOOL)SendMessageDx(EM_CANUNDO);
}

inline INT MEditCtrl::GetLineCount() const
{
    return (INT)SendMessageDx(EM_GETLINECOUNT);
}

inline BOOL MEditCtrl::GetModify() const
{
    return (BOOL)SendMessageDx(EM_GETMODIFY);
}

inline VOID MEditCtrl::SetModify(BOOL bModified/* = TRUE*/)
{
    SendMessageDx(EM_SETMODIFY, (WPARAM)bModified);
}

inline BOOL MEditCtrl::IsEmpty() const
{
    return ::GetWindowTextLength(m_hwnd) == 0;
}

inline VOID MEditCtrl::GetRect(LPRECT prc) const
{
    SendMessageDx(EM_GETRECT, 0, (LPARAM)prc);
}

inline DWORD MEditCtrl::GetSel() const
{
    return (DWORD)SendMessageDx(EM_GETSEL);
}

inline VOID MEditCtrl::GetSel(INT& nStartChar, INT& nEndChar) const
{
    SendMessageDx(EM_GETSEL, (WPARAM)&nStartChar, (LPARAM)&nEndChar);
}

inline HLOCAL MEditCtrl::GetHandle() const
{
    return (HLOCAL)SendMessageDx(EM_GETHANDLE);
}

inline VOID MEditCtrl::SetHandle(HLOCAL hBuffer)
{
    SendMessageDx(EM_SETHANDLE, (WPARAM)hBuffer, 0);
}

inline VOID MEditCtrl::SetMargins(UINT nLeft, UINT nRight)
{
    SendMessageDx(EM_SETMARGINS, 
        EC_LEFTMARGIN | EC_RIGHTMARGIN | EC_USEFONTINFO, 
        MAKELPARAM(nLeft, nRight));
}

inline DWORD MEditCtrl::GetMargins() const
{
    return (DWORD)SendMessageDx(EM_GETMARGINS);
}

inline VOID MEditCtrl::SetLimitText(UINT nMax)
{
    SendMessageDx(EM_SETLIMITTEXT, nMax);
}

inline UINT MEditCtrl::GetLimitText() const
{
    return (UINT)SendMessageDx(EM_GETLIMITTEXT);
}

inline POINT MEditCtrl::PosFromChar(UINT nChar) const
{
    POINT pt;
    SendMessageDx(EM_POSFROMCHAR, (WPARAM)&pt, (LPARAM)nChar);
    return pt;
}

inline INT MEditCtrl::CharFromPos(POINT pt) const
{
    return (INT)SendMessageDx(EM_CHARFROMPOS, 0, MAKELPARAM(pt.x, pt.y));
}

inline INT MEditCtrl::GetLine(
    INT nIndex, LPTSTR lpszBuffer, INT nMaxLength) const
{
    assert(2 <= nMaxLength && nMaxLength <= 0xFFFF);
    *reinterpret_cast<WORD *>(lpszBuffer) = (WORD) nMaxLength;
    return (INT)SendMessageDx(EM_GETLINE, (WPARAM)nIndex, (LPARAM)lpszBuffer);
}

inline VOID MEditCtrl::EmptyUndoBuffer()
{
    SendMessageDx(EM_EMPTYUNDOBUFFER, 0, 0);
}

inline BOOL MEditCtrl::FmtLines(BOOL bAddEOL)
{
    return (BOOL)SendMessageDx(EM_FMTLINES, (WPARAM)bAddEOL);
}

inline VOID MEditCtrl::LimitText(INT nChars/* = 0*/)
{
    SendMessageDx(EM_LIMITTEXT, (WPARAM)nChars);
}

inline INT MEditCtrl::LineFromChar(INT nIndex/* = -1*/) const
{
    return (INT)SendMessageDx(EM_LINEFROMCHAR, (WPARAM)nIndex);
}

inline INT MEditCtrl::LineIndex(INT nLine/* = -1*/) const
{
    return (INT)SendMessageDx(EM_LINEINDEX, (WPARAM)nLine);
}

inline INT MEditCtrl::LineLength(INT nLine/* = -1*/) const
{
    return (INT)SendMessageDx(EM_LINELENGTH, (WPARAM)nLine);
}

inline VOID MEditCtrl::LineScroll(INT nLines, INT nChars/* = 0*/)
{
    SendMessageDx(EM_LINESCROLL, (WPARAM)nChars, (LPARAM)nLines);
}

inline VOID MEditCtrl::ReplaceSel(
    LPCTSTR lpszNewText, BOOL bCanUndo/* = FALSE*/)
{
    SendMessageDx(EM_REPLACESEL, (WPARAM)bCanUndo, (LPARAM)lpszNewText);
}

inline VOID MEditCtrl::SelectAll(BOOL bNoScroll/* = FALSE*/)
{
    SetSel(0, -1, bNoScroll);
}

inline VOID MEditCtrl::SelectNone(BOOL bNoScroll/* = FALSE*/)
{
    SetSel(-1, -1, bNoScroll);
}

inline VOID MEditCtrl::SetPasswordChar(TCHAR ch)
{
    SendMessageDx(EM_SETPASSWORDCHAR, (WPARAM)ch);
}

inline VOID MEditCtrl::SetRect(LPCRECT prc)
{
    SendMessageDx(EM_SETRECT, 0, (LPARAM)prc);
}

inline VOID MEditCtrl::SetRectNP(LPCRECT prc)
{
    SendMessageDx(EM_SETRECTNP, 0, (LPARAM)prc);
}

inline VOID MEditCtrl::SetSel(
    DWORD dwSelection, BOOL bNoScroll/* = FALSE*/)
{
    SetSel((INT) LOWORD(dwSelection), (INT) HIWORD(dwSelection), bNoScroll);
}

inline VOID MEditCtrl::SetSel(
    INT nStartChar, INT nEndChar, BOOL bNoScroll/* = FALSE*/)
{
    SendMessageDx(EM_SETSEL, (WPARAM)nStartChar, (LPARAM)nEndChar);
    if (!bNoScroll)
        SendMessageDx(EM_SCROLLCARET);
}

inline BOOL MEditCtrl::SetTabStops(INT nTabStops, LPINT rgTabStops)
{
    return (BOOL)SendMessageDx(EM_SETTABSTOPS, (WPARAM)nTabStops, (LPARAM)rgTabStops);
}

inline VOID MEditCtrl::SetTabStops()
{
    SendMessageDx(EM_SETTABSTOPS);
}

inline BOOL MEditCtrl::SetTabStops(const INT& cxEachStop)
{
    return (BOOL)SendMessageDx(EM_SETTABSTOPS, 1, (LPARAM)&cxEachStop);
}

inline BOOL MEditCtrl::Undo()
{
    return (BOOL)SendMessageDx(EM_UNDO);
}

inline VOID MEditCtrl::Clear()
{
    SendMessageDx(WM_CLEAR, 0, 0);
}

inline VOID MEditCtrl::Copy()
{
    SendMessageDx(WM_COPY, 0, 0);
}

inline VOID MEditCtrl::Cut()
{
    SendMessageDx(WM_CUT, 0, 0);
}

inline VOID MEditCtrl::Paste()
{
    SendMessageDx(WM_PASTE, 0, 0);
}

inline BOOL MEditCtrl::SetReadOnly(BOOL bReadOnly/* = TRUE*/)
{
    return (BOOL)SendMessageDx(EM_SETREADONLY, (WPARAM)bReadOnly);
}

inline INT MEditCtrl::GetFirstVisibleLine() const
{
    return (INT)SendMessageDx(EM_GETFIRSTVISIBLELINE);
}

inline TCHAR MEditCtrl::GetPasswordChar() const
{
    return (TCHAR)SendMessageDx(EM_GETPASSWORDCHAR);
}

inline /*static*/ HHOOK& MEditCtrl::OldHookProc()
{
    static HHOOK s_hHook = NULL;
    return s_hHook;
}

inline /*static*/ LRESULT CALLBACK
MEditCtrl::CtrlAMsgProcDx(INT nCode, WPARAM wParam, LPARAM lParam)
{
    if (nCode < 0)
        return ::CallNextHookEx(OldHookProc(), nCode, wParam, lParam);

    MSG *pMsg = (MSG *)lParam;
    TCHAR szClassName[8];
    HWND hWnd;
    if (pMsg->message == WM_KEYDOWN)
    {
        if ((INT) pMsg->wParam == 'A' &&
            GetAsyncKeyState(VK_CONTROL) < 0 &&
            GetAsyncKeyState(VK_SHIFT) >= 0 &&
            GetAsyncKeyState(VK_MENU) >= 0)
        {
            // Ctrl+A is pressed
            hWnd = ::GetFocus();
            if (hWnd != NULL)
            {
                GetClassName(hWnd, szClassName, _countof(szClassName));
                if (lstrcmpi(szClassName, TEXT("EDIT")) == 0)
                {
                    SendMessage(hWnd, EM_SETSEL, 0, -1);
                    return 1;
                }
            }
        }
    }
    return ::CallNextHookEx(OldHookProc(), nCode, wParam, lParam);
}

inline /*static*/ void MEditCtrl::SetCtrlAHookDx(BOOL bHook)
{
    if (bHook)
    {
        assert(OldHookProc() == NULL);
        OldHookProc() = ::SetWindowsHookEx(
            WH_MSGFILTER, MEditCtrl::CtrlAMsgProcDx, NULL, 
            GetCurrentThreadId());
    }
    else
    {
        assert(OldHookProc() != NULL);
        UnhookWindowsHookEx(OldHookProc());
        OldHookProc() = NULL;
    }
}

inline /*static*/ BOOL MEditCtrl::DoMsgCtrlA(MSG *pMsg)
{
    WCHAR szClass[8] = L"";
    GetClassNameW(pMsg->hwnd, szClass, _countof(szClass));

    if (lstrcmpiW(szClass, L"EDIT") == 0)
    {
        if (pMsg->message == WM_KEYDOWN)
        {
            if (pMsg->wParam == 'A' &&
                GetAsyncKeyState(VK_CONTROL) < 0 &&
                GetAsyncKeyState(VK_SHIFT) >= 0 &&
                GetAsyncKeyState(VK_MENU) >= 0)
            {
                PeekMessage(pMsg, pMsg->hwnd, WM_KEYDOWN, WM_KEYDOWN, PM_REMOVE);
                PostMessage(pMsg->hwnd, EM_SETSEL, 0, -1);
                return TRUE;
            }
        }
    }

    return FALSE;
}

////////////////////////////////////////////////////////////////////////////

#endif  // ndef MZC4_MEDITCTRL_HPP_

```

`src/MEditMenuDlg.hpp`:

```hpp
// MEditMenuDlg.hpp --- Dialogs for edit of Menus
//////////////////////////////////////////////////////////////////////////////
// RisohEditor --- Another free Win32 resource editor
// Copyright (C) 2017-2018 Katayama Hirofumi MZ <katayama.hirofumi.mz@gmail.com>
// 
// This program is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
// 
// This program is distributed in the hope that it will be useful, 
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
// 
// You should have received a copy of the GNU General Public License
// along with this program.  If not, see <http://www.gnu.org/licenses/>.
//////////////////////////////////////////////////////////////////////////////

#pragma once

#include "resource.h"
#include "MWindowBase.hpp"
#include "RisohSettings.hpp"
#include "ConstantsDB.hpp"
#include "MComboBoxAutoComplete.hpp"
#include "MenuRes.hpp"
#include "Common.hpp"

class MAddMItemDlg;
class MModifyMItemDlg;
class MEditMenuDlg;

//////////////////////////////////////////////////////////////////////////////

class MAddMItemDlg : public MDialogBase
{
public:
    MENU_ENTRY& m_entry;
    MComboBoxAutoComplete m_cmb2;
    MComboBoxAutoComplete m_cmb3;

    MAddMItemDlg(MENU_ENTRY& entry)
        : MDialogBase(IDD_ADDMITEM), m_entry(entry)
    {
    }

    BOOL OnInitDialog(HWND hwnd, HWND hwndFocus, LPARAM lParam)
    {
        InitCtrlIDComboBox(GetDlgItem(hwnd, cmb2));
        SubclassChildDx(m_cmb2, cmb2);
        SetDlgItemText(hwnd, cmb2, L"0");

        InitResNameComboBox(GetDlgItem(hwnd, cmb3), MIdOrString(L""), IDTYPE_HELP);
        SetDlgItemInt(hwnd, cmb3, 0, TRUE);
        SubclassChildDx(m_cmb3, cmb3);

        CenterWindowDx();
        return TRUE;
    }

    void OnOK(HWND hwnd)
    {
        GetDlgItemTextW(hwnd, cmb1, m_entry.szCaption, _countof(m_entry.szCaption));
        if (m_entry.szCaption[0] == L'"')
        {
            mstr_unquote(m_entry.szCaption);
        }

        GetDlgItemTextW(hwnd, cmb2, m_entry.szCommandID, _countof(m_entry.szCommandID));
        ReplaceFullWithHalf(m_entry.szCommandID);
        mstr_trim(m_entry.szCommandID);
        if (!CheckCommand(m_entry.szCommandID))
        {
            ErrorBoxDx(IDS_NOSUCHID);
            return;
        }

        DWORD dwType = 0, dwState = 0;
        if (IsDlgButtonChecked(hwnd, chx1) == BST_CHECKED)
            dwState |= MFS_GRAYED;
        if (IsDlgButtonChecked(hwnd, chx3) == BST_CHECKED)
            dwType |= MFT_BITMAP;
        if (IsDlgButtonChecked(hwnd, chx4) == BST_CHECKED)
            dwType |= MFT_OWNERDRAW;
        if (IsDlgButtonChecked(hwnd, chx5) == BST_CHECKED)
            dwState |= MFS_CHECKED;
        if (IsDlgButtonChecked(hwnd, chx6) == BST_CHECKED)
            dwType |= MFT_SEPARATOR;
        if (IsDlgButtonChecked(hwnd, chx7) == BST_CHECKED)
            dwType |= MFT_MENUBARBREAK;
        if (IsDlgButtonChecked(hwnd, chx8) == BST_CHECKED)
            dwType |= MFT_MENUBREAK;
        if (IsDlgButtonChecked(hwnd, chx9) == BST_CHECKED)
            dwState |= MFS_DEFAULT;
        if (IsDlgButtonChecked(hwnd, chx10) == BST_CHECKED)
            dwState |= MFS_HILITE;
        if (IsDlgButtonChecked(hwnd, chx11) == BST_CHECKED)
            dwType |= MFT_RADIOCHECK;
        if (IsDlgButtonChecked(hwnd, chx12) == BST_CHECKED)
            dwType |= MFT_RIGHTORDER;
        if (IsDlgButtonChecked(hwnd, chx13) == BST_CHECKED)
            dwType |= MFT_RIGHTJUSTIFY;

        std::wstring str = GetMenuTypeAndState(dwType, dwState);
        if (m_entry.szCaption[0] == 0 ||
            lstrcmpiW(m_entry.szCaption, LoadStringDx(IDS_SEPARATOR)) == 0)
        {
            m_entry.szCaption[0] = 0;
            dwType |= MFT_SEPARATOR;
            str = GetMenuTypeAndState(dwType, dwState);
        }
        lstrcpynW(m_entry.szFlags, str.c_str(), _countof(m_entry.szFlags));

        GetDlgItemTextW(hwnd, cmb3, m_entry.szHelpID, _countof(m_entry.szHelpID));
        ReplaceFullWithHalf(m_entry.szHelpID);
        mstr_trim(m_entry.szHelpID);

        DWORD help = g_db.GetResIDValue(m_entry.szHelpID);
        MString strHelp = g_db.GetNameOfResID(IDTYPE_HELP, help);
        ReplaceFullWithHalf(strHelp);
        lstrcpynW(m_entry.szHelpID, strHelp.c_str(), _countof(m_entry.szHelpID));

        EndDialog(IDOK);
    }

    void OnCommand(HWND hwnd, int id, HWND hwndCtl, UINT codeNotify)
    {
        switch (id)
        {
        case IDOK:
            OnOK(hwnd);
            break;
        case IDCANCEL:
            EndDialog(IDCANCEL);
            break;
        case chx6:
            if (IsDlgButtonChecked(hwnd, chx6) == BST_CHECKED)
            {
                SetDlgItemTextW(hwnd, cmb1, NULL);
                SetDlgItemInt(hwnd, cmb2, 0, FALSE);
                SetDlgItemInt(hwnd, edt1, 0, FALSE);
            }
            break;
        case psh1:
            OnPsh1(hwnd);
            break;
        case cmb2:
            if (codeNotify == CBN_EDITCHANGE)
            {
                m_cmb2.OnEditChange();
            }
            break;
        case cmb3:
            if (codeNotify == CBN_EDITCHANGE)
            {
                m_cmb3.OnEditChange();
            }
            break;
        }
    }

    void OnPsh1(HWND hwnd)
    {
        SendMessage(GetParent(GetParent(hwnd)), WM_COMMAND, ID_IDLIST, 0);
    }

    virtual INT_PTR CALLBACK
    DialogProcDx(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
    {
        switch (uMsg)
        {
            HANDLE_MSG(hwnd, WM_INITDIALOG, OnInitDialog);
            HANDLE_MSG(hwnd, WM_COMMAND, OnCommand);
        }
        return DefaultProcDx();
    }
};

//////////////////////////////////////////////////////////////////////////////

class MModifyMItemDlg : public MDialogBase
{
public:
    MENU_ENTRY& m_entry;
    MComboBoxAutoComplete m_cmb2;
    MComboBoxAutoComplete m_cmb3;

    MModifyMItemDlg(MENU_ENTRY& entry)
        : MDialogBase(IDD_MODIFYMITEM), m_entry(entry)
    {
    }

    BOOL OnInitDialog(HWND hwnd, HWND hwndFocus, LPARAM lParam)
    {
        SetDlgItemTextW(hwnd, cmb1, mstr_quote(m_entry.szCaption).c_str()); //

        InitCtrlIDComboBox(GetDlgItem(hwnd, cmb2));
        SetDlgItemText(hwnd, cmb2, m_entry.szCommandID);
        SubclassChildDx(m_cmb2, cmb2);

        MIdOrString help_id(m_entry.szHelpID);
        InitResNameComboBox(GetDlgItem(hwnd, cmb3), help_id, IDTYPE_HELP);
        SubclassChildDx(m_cmb3, cmb3);

        DWORD dwType, dwState;
        dwType = dwState = 0;
        SetMenuTypeAndState(dwType, dwState, m_entry.szFlags);

        if (lstrcmpiW(m_entry.szCaption, LoadStringDx(IDS_SEPARATOR)) == 0 ||
            m_entry.szCaption[0] == 0 || (dwType & MFT_SEPARATOR))
        {
            dwType |= MFT_SEPARATOR;
            SetDlgItemTextW(hwnd, cmb1, NULL);
        }

        if ((dwState & MFS_GRAYED) == MFS_GRAYED)
            CheckDlgButton(hwnd, chx1, BST_CHECKED);
        if ((dwType & MFT_BITMAP) == MFT_BITMAP)
            CheckDlgButton(hwnd, chx3, BST_CHECKED);
        if ((dwType & MFT_OWNERDRAW) == MFT_OWNERDRAW)
            CheckDlgButton(hwnd, chx4, BST_CHECKED);
        if ((dwState & MFS_CHECKED) == MFS_CHECKED)
            CheckDlgButton(hwnd, chx5, BST_CHECKED);
        if ((dwType & MFT_SEPARATOR) == MFT_SEPARATOR)
            CheckDlgButton(hwnd, chx6, BST_CHECKED);
        if ((dwType & MFT_MENUBARBREAK) == MFT_MENUBARBREAK)
            CheckDlgButton(hwnd, chx7, BST_CHECKED);
        if ((dwType & MFT_MENUBREAK) == MFT_MENUBREAK)
            CheckDlgButton(hwnd, chx8, BST_CHECKED);
        if ((dwState & MFS_DEFAULT) == MFS_DEFAULT)
            CheckDlgButton(hwnd, chx9, BST_CHECKED);
        if ((dwState & MFS_HILITE) == MFS_HILITE)
            CheckDlgButton(hwnd, chx10, BST_CHECKED);
        if ((dwType & MFT_RADIOCHECK) == MFT_RADIOCHECK)
            CheckDlgButton(hwnd, chx11, BST_CHECKED);
        if ((dwType & MFT_RIGHTORDER) == MFT_RIGHTORDER)
            CheckDlgButton(hwnd, chx12, BST_CHECKED);
        if ((dwType & MFT_RIGHTJUSTIFY) == MFT_RIGHTJUSTIFY)
            CheckDlgButton(hwnd, chx13, BST_CHECKED);

        CenterWindowDx();
        return TRUE;
    }

    void OnOK(HWND hwnd)
    {
        GetDlgItemTextW(hwnd, cmb1, m_entry.szCaption, _countof(m_entry.szCaption));
        if (m_entry.szCaption[0] == L'"')
        {
            mstr_unquote(m_entry.szCaption);
        }

        GetDlgItemTextW(hwnd, cmb2, m_entry.szCommandID, _countof(m_entry.szCommandID));
        ReplaceFullWithHalf(m_entry.szCommandID);
        mstr_trim(m_entry.szCommandID);
        if (!CheckCommand(m_entry.szCommandID))
        {
            ErrorBoxDx(IDS_NOSUCHID);
            return;
        }

        DWORD dwType = 0, dwState = 0;
        if (IsDlgButtonChecked(hwnd, chx1) == BST_CHECKED)
            dwState |= MFS_GRAYED;
        if (IsDlgButtonChecked(hwnd, chx3) == BST_CHECKED)
            dwType |= MFT_BITMAP;
        if (IsDlgButtonChecked(hwnd, chx4) == BST_CHECKED)
            dwType |= MFT_OWNERDRAW;
        if (IsDlgButtonChecked(hwnd, chx5) == BST_CHECKED)
            dwState |= MFS_CHECKED;
        if (IsDlgButtonChecked(hwnd, chx6) == BST_CHECKED)
            dwType |= MFT_SEPARATOR;
        if (IsDlgButtonChecked(hwnd, chx7) == BST_CHECKED)
            dwType |= MFT_MENUBARBREAK;
        if (IsDlgButtonChecked(hwnd, chx8) == BST_CHECKED)
            dwType |= MFT_MENUBREAK;
        if (IsDlgButtonChecked(hwnd, chx9) == BST_CHECKED)
            dwState |= MFS_DEFAULT;
        if (IsDlgButtonChecked(hwnd, chx10) == BST_CHECKED)
            dwState |= MFS_HILITE;
        if (IsDlgButtonChecked(hwnd, chx11) == BST_CHECKED)
            dwType |= MFT_RADIOCHECK;
        if (IsDlgButtonChecked(hwnd, chx12) == BST_CHECKED)
            dwType |= MFT_RIGHTORDER;
        if (IsDlgButtonChecked(hwnd, chx13) == BST_CHECKED)
            dwType |= MFT_RIGHTJUSTIFY;

        if (lstrcmpiW(m_entry.szCaption, LoadStringDx(IDS_SEPARATOR)) == 0 ||
            m_entry.szCaption[0] == 0 || (dwType & MFT_SEPARATOR))
        {
            m_entry.szCaption[0] = 0;
            dwType |= MFT_SEPARATOR;
        }

        std::wstring str = GetMenuTypeAndState(dwType, dwState);
        lstrcpynW(m_entry.szFlags, str.c_str(), _countof(m_entry.szFlags));

        GetDlgItemTextW(hwnd, cmb3, m_entry.szHelpID, _countof(m_entry.szHelpID));
        DWORD help = g_db.GetResIDValue(m_entry.szHelpID);
        MString strHelp = g_db.GetNameOfResID(IDTYPE_HELP, help);
        lstrcpynW(m_entry.szHelpID, strHelp.c_str(), _countof(m_entry.szHelpID));

        EndDialog(IDOK);
    }

    void OnCommand(HWND hwnd, int id, HWND hwndCtl, UINT codeNotify)
    {
        switch (id)
        {
        case IDOK:
            OnOK(hwnd);
            break;
        case IDCANCEL:
            EndDialog(IDCANCEL);
            break;
        case chx6:
            if (IsDlgButtonChecked(hwnd, chx6) == BST_CHECKED)
            {
                SetDlgItemTextW(hwnd, cmb1, NULL);
                SetDlgItemInt(hwnd, cmb2, 0, FALSE);
                SetDlgItemInt(hwnd, cmb3, 0, FALSE);
            }
            break;
        case psh1:
            OnPsh1(hwnd);
            break;
        case cmb2:
            if (codeNotify == CBN_EDITCHANGE)
            {
                m_cmb2.OnEditChange();
            }
            break;
        case cmb3:
            if (codeNotify == CBN_EDITCHANGE)
            {
                m_cmb3.OnEditChange();
            }
            break;
        }
    }

    void OnPsh1(HWND hwnd)
    {
        SendMessage(GetParent(GetParent(hwnd)), WM_COMMAND, ID_IDLIST, 0);
    }

    virtual INT_PTR CALLBACK
    DialogProcDx(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
    {
        switch (uMsg)
        {
            HANDLE_MSG(hwnd, WM_INITDIALOG, OnInitDialog);
            HANDLE_MSG(hwnd, WM_COMMAND, OnCommand);
        }
        return DefaultProcDx();
    }
};

//////////////////////////////////////////////////////////////////////////////

class MEditMenuDlg : public MDialogBase
{
public:
    MenuRes& m_menu_res;
    MResizable m_resizable;
    HICON m_hIcon;
    HICON m_hIconSm;
    HWND m_hLst1;

    MEditMenuDlg(MenuRes& menu_res)
        : MDialogBase(IDD_EDITMENU), m_menu_res(menu_res)
    {
        m_hIcon = LoadIconDx(IDI_SMILY);
        m_hIconSm = LoadSmallIconDx(IDI_SMILY);
        m_hLst1 = NULL;
    }

    ~MEditMenuDlg()
    {
        DestroyIcon(m_hIcon);
        DestroyIcon(m_hIconSm);
    }

    BOOL OnInitDialog(HWND hwnd, HWND hwndFocus, LPARAM lParam)
    {
        if (m_menu_res.IsExtended())
            CheckDlgButton(hwnd, chx1, BST_CHECKED);

        m_hLst1 = GetDlgItem(hwnd, lst1);
        ListView_SetExtendedListViewStyle(m_hLst1, LVS_EX_FULLROWSELECT | LVS_EX_INFOTIP);

        LV_COLUMN column;
        ZeroMemory(&column, sizeof(column));

        column.mask = LVCF_FMT | LVCF_SUBITEM | LVCF_TEXT | LVCF_WIDTH;
        column.fmt = LVCFMT_LEFT;
        column.cx = 225;
        column.pszText = LoadStringDx(IDS_CAPTION);
        column.iSubItem = 0;
        ListView_InsertColumn(m_hLst1, 0, &column);

        column.mask = LVCF_FMT | LVCF_SUBITEM | LVCF_TEXT | LVCF_WIDTH;
        column.fmt = LVCFMT_LEFT;
        column.cx = 95;
        column.pszText = LoadStringDx(IDS_FLAGS);
        column.iSubItem = 1;
        ListView_InsertColumn(m_hLst1, 1, &column);

        column.mask = LVCF_FMT | LVCF_SUBITEM | LVCF_TEXT | LVCF_WIDTH;
        column.fmt = LVCFMT_LEFT;
        column.cx = 150;
        column.pszText = LoadStringDx(IDS_COMMANDID);
        column.iSubItem = 2;
        ListView_InsertColumn(m_hLst1, 2, &column);

        column.mask = LVCF_FMT | LVCF_SUBITEM | LVCF_TEXT | LVCF_WIDTH;
        column.fmt = LVCFMT_LEFT;
        column.cx = 180;
        column.pszText = LoadStringDx(IDS_HELPID);
        column.iSubItem = 3;
        ListView_InsertColumn(m_hLst1, 3, &column);

        INT i = 0;
        std::wstring str;
        LV_ITEM item;
        if (m_menu_res.IsExtended())
        {
            typedef MenuRes::ExMenuItemsType exitems_type;
            exitems_type& exitems = m_menu_res.exitems();
            for (auto& element : exitems)
            {
                str = mstr_repeat(LoadStringDx(IDS_INDENT), element.wDepth);
                if (element.text.empty() && element.menuId == 0)
                {
                    str += LoadStringDx(IDS_SEPARATOR);
                    element.dwType |= MFT_SEPARATOR;
                }
                else
                {
                    str += mstr_quote(element.text);
                }

                ZeroMemory(&item, sizeof(item));
                item.iItem = i;
                item.mask = LVIF_TEXT;
                item.iSubItem = 0;
                item.pszText = &str[0];
                ListView_InsertItem(m_hLst1, &item);

                str = GetMenuTypeAndState(element.dwType, element.dwState);

                ZeroMemory(&item, sizeof(item));
                item.iItem = i;
                item.mask = LVIF_TEXT;
                item.iSubItem = 1;
                item.pszText = &str[0];
                ListView_SetItem(m_hLst1, &item);

                str = g_db.GetNameOfResID(IDTYPE_COMMAND, IDTYPE_NEWCOMMAND, element.menuId, true);

                ZeroMemory(&item, sizeof(item));
                item.iItem = i;
                item.mask = LVIF_TEXT;
                item.iSubItem = 2;
                item.pszText = &str[0];
                ListView_SetItem(m_hLst1, &item);

                str = g_db.GetNameOfResID(IDTYPE_HELP, element.dwHelpId);

                ZeroMemory(&item, sizeof(item));
                item.iItem = i;
                item.mask = LVIF_TEXT;
                item.iSubItem = 3;
                item.pszText = &str[0];
                ListView_SetItem(m_hLst1, &item);

                ++i;
            }
        }
        else
        {
            typedef MenuRes::MenuItemsType items_type;
            items_type& items = m_menu_res.items();
            for (auto& element : items)
            {
                str = mstr_repeat(LoadStringDx(IDS_INDENT), element.wDepth);
                if (element.text.empty() && element.wMenuID == 0)
                {
                    str += LoadStringDx(IDS_SEPARATOR);
                }
                else
                {
                    str += mstr_quote(element.text);
                }

                ZeroMemory(&item, sizeof(item));
                item.iItem = i;
                item.mask = LVIF_TEXT;
                item.iSubItem = 0;
                item.pszText = &str[0];
                ListView_InsertItem(m_hLst1, &item);

                str = GetMenuFlags(element.fItemFlags);
                if (element.text.empty() && element.wMenuID == 0)
                    str += L"S ";

                ZeroMemory(&item, sizeof(item));
                item.iItem = i;
                item.mask = LVIF_TEXT;
                item.iSubItem = 1;
                item.pszText = &str[0];
                ListView_SetItem(m_hLst1, &item);

                str = g_db.GetNameOfResID(IDTYPE_COMMAND, IDTYPE_NEWCOMMAND, element.wMenuID, true);

                ZeroMemory(&item, sizeof(item));
                item.iItem = i;
                item.mask = LVIF_TEXT;
                item.iSubItem = 2;
                item.pszText = &str[0];
                ListView_SetItem(m_hLst1, &item);

                str = TEXT("0");

                ZeroMemory(&item, sizeof(item));
                item.iItem = i;
                item.mask = LVIF_TEXT;
                item.iSubItem = 3;
                item.pszText = &str[0];
                ListView_SetItem(m_hLst1, &item);

                ++i;
            }
        }

        UINT state = LVIS_SELECTED | LVIS_FOCUSED;
        ListView_SetItemState(m_hLst1, 0, state, state);
        SetFocus(m_hLst1);

        m_resizable.OnParentCreate(hwnd);

        m_resizable.SetLayoutAnchor(lst1, mzcLA_TOP_LEFT, mzcLA_BOTTOM_RIGHT);
        m_resizable.SetLayoutAnchor(psh1, mzcLA_TOP_RIGHT);
        m_resizable.SetLayoutAnchor(psh2, mzcLA_TOP_RIGHT);
        m_resizable.SetLayoutAnchor(psh3, mzcLA_TOP_RIGHT);
        m_resizable.SetLayoutAnchor(chx1, mzcLA_TOP_RIGHT);
        m_resizable.SetLayoutAnchor(psh4, mzcLA_BOTTOM_LEFT);
        m_resizable.SetLayoutAnchor(psh5, mzcLA_BOTTOM_LEFT);
        m_resizable.SetLayoutAnchor(psh6, mzcLA_BOTTOM_LEFT);
        m_resizable.SetLayoutAnchor(psh7, mzcLA_BOTTOM_LEFT);
        m_resizable.SetLayoutAnchor(IDOK, mzcLA_BOTTOM_RIGHT);
        m_resizable.SetLayoutAnchor(IDCANCEL, mzcLA_BOTTOM_RIGHT);

        SendMessageDx(WM_SETICON, ICON_BIG, (LPARAM)m_hIcon);
        SendMessageDx(WM_SETICON, ICON_SMALL, (LPARAM)m_hIconSm);

        CenterWindowDx();
        return TRUE;
    }

    void OnAdd(HWND hwnd)
    {
        MENU_ENTRY m_entry;
        ZeroMemory(&m_entry, sizeof(m_entry));
        MAddMItemDlg dialog(m_entry);
        INT nID = (INT)dialog.DialogBoxDx(hwnd);
        if (IDOK != nID)
        {
            return;
        }

        INT iItem = ListView_GetItemCount(m_hLst1);

        MStringW str, strIndent = LoadStringDx(IDS_INDENT);
        str = mstr_quote(m_entry.szCaption);
        if (str.empty() || wcsstr(m_entry.szFlags, L"S ") != NULL)
            str = LoadStringDx(IDS_SEPARATOR);
        str = mstr_repeat(strIndent, m_entry.wDepth) + str;

        LV_ITEM item;

        ZeroMemory(&item, sizeof(item));
        item.iItem = iItem;
        item.mask = LVIF_TEXT;
        item.iSubItem = 0;
        item.pszText = &str[0];
        ListView_InsertItem(m_hLst1, &item);

        ZeroMemory(&item, sizeof(item));
        item.iItem = iItem;
        item.mask = LVIF_TEXT;
        item.iSubItem = 1;
        item.pszText = m_entry.szFlags;
        ListView_SetItem(m_hLst1, &item);

        ZeroMemory(&item, sizeof(item));
        item.iItem = iItem;
        item.mask = LVIF_TEXT;
        item.iSubItem = 2;
        item.pszText = m_entry.szCommandID;
        ListView_SetItem(m_hLst1, &item);

        ZeroMemory(&item, sizeof(item));
        item.iItem = iItem;
        item.mask = LVIF_TEXT;
        item.iSubItem = 3;
        item.pszText = m_entry.szHelpID;
        ListView_SetItem(m_hLst1, &item);

        UINT state = LVIS_SELECTED | LVIS_FOCUSED;
        ListView_SetItemState(m_hLst1, iItem, state, state);
        ListView_EnsureVisible(m_hLst1, iItem, FALSE);
    }

    BOOL GetEntry(HWND hwnd, MENU_ENTRY& entry, INT iItem)
    {
        WCHAR szCaption[256];
        ListView_GetItemText(m_hLst1, iItem, 0, szCaption, _countof(szCaption));

        entry.wDepth = 0;
        MStringW str = szCaption, strIndent = LoadStringDx(IDS_INDENT);
        while (str.find(strIndent) == 0)
        {
            str = str.substr(strIndent.size());
            ++entry.wDepth;
        }
        if (str[0] == L'"')
        {
            mstr_unquote(str);
        }
        if (str.empty() || str == LoadStringDx(IDS_SEPARATOR))
        {
            str.clear();
        }

        lstrcpynW(entry.szCaption, str.c_str(), _countof(entry.szCaption));

        ListView_GetItemText(m_hLst1, iItem, 1, entry.szFlags, _countof(entry.szFlags));
        ListView_GetItemText(m_hLst1, iItem, 2, entry.szCommandID, _countof(entry.szCommandID));
        ListView_GetItemText(m_hLst1, iItem, 3, entry.szHelpID, _countof(entry.szHelpID));
        return TRUE;
    }

    BOOL SetEntry(HWND hwnd, MENU_ENTRY& entry, INT iItem)
    {
        MStringW str, strIndent = LoadStringDx(IDS_INDENT);
        str = mstr_repeat(strIndent, entry.wDepth);

        if (entry.szCaption[0] == 0 || wcsstr(entry.szFlags, L"S ") != NULL)
            str += LoadStringDx(IDS_SEPARATOR);
        else
            str += mstr_quote(entry.szCaption);

        ListView_SetItemText(m_hLst1, iItem, 0, &str[0]);
        ListView_SetItemText(m_hLst1, iItem, 1, entry.szFlags);
        ListView_SetItemText(m_hLst1, iItem, 2, entry.szCommandID);
        ListView_SetItemText(m_hLst1, iItem, 3, entry.szHelpID);
        return TRUE;
    }

    void OnModify(HWND hwnd)
    {
        INT iItem = ListView_GetNextItem(m_hLst1, -1, LVNI_ALL | LVNI_SELECTED);
        if (iItem < 0)
        {
            return;
        }

        MENU_ENTRY m_entry;
        GetEntry(hwnd, m_entry, iItem);

        MModifyMItemDlg dialog(m_entry);
        INT nID = (INT)dialog.DialogBoxDx(hwnd);
        if (IDOK == nID)
        {
            SetEntry(hwnd, m_entry, iItem);
        }
    }

    void OnDelete(HWND hwnd)
    {
        INT iItem = ListView_GetNextItem(m_hLst1, -1, LVNI_ALL | LVNI_SELECTED);
        if (iItem >= 0)
        {
            ListView_DeleteItem(m_hLst1, iItem);
            if (ListView_GetItemCount(m_hLst1) == iItem)
                --iItem;
            UINT state = LVIS_SELECTED | LVIS_FOCUSED;
            ListView_SetItemState(m_hLst1, iItem, state, state);
        }
    }

    void OnUp(HWND hwnd)
    {
        INT iItem = ListView_GetNextItem(m_hLst1, -1, LVNI_ALL | LVNI_SELECTED);
        if (iItem <= 0)
            return;

        MENU_ENTRY entry0, entry1;

        GetEntry(hwnd, entry0, iItem - 1);
        GetEntry(hwnd, entry1, iItem);

        SetEntry(hwnd, entry1, iItem - 1);
        SetEntry(hwnd, entry0, iItem);

        UINT state = LVIS_SELECTED | LVIS_FOCUSED;
        ListView_SetItemState(m_hLst1, iItem - 1, state, state);
    }

    void OnDown(HWND hwnd)
    {
        INT iItem = ListView_GetNextItem(m_hLst1, -1, LVNI_ALL | LVNI_SELECTED);
        if (iItem < 0)
            return;

        INT nCount = ListView_GetItemCount(m_hLst1);
        if (iItem + 1 >= nCount)
            return;

        MENU_ENTRY entry0, entry1;

        GetEntry(hwnd, entry0, iItem);
        GetEntry(hwnd, entry1, iItem + 1);

        SetEntry(hwnd, entry1, iItem);
        SetEntry(hwnd, entry0, iItem + 1);

        UINT state = LVIS_SELECTED | LVIS_FOCUSED;
        ListView_SetItemState(m_hLst1, iItem + 1, state, state);
    }

    void OnLeft(HWND hwnd)
    {
        INT iItem = ListView_GetNextItem(m_hLst1, -1, LVNI_ALL | LVNI_SELECTED);
        if (iItem < 0)
            return;

        WCHAR szCaption[128];
        ListView_GetItemText(m_hLst1, iItem, 0, szCaption, _countof(szCaption));

        std::wstring strIndent = LoadStringDx(IDS_INDENT);

        std::wstring str = szCaption;
        if (str.find(strIndent) == 0)
        {
            str = str.substr(strIndent.size());
        }

        ListView_SetItemText(m_hLst1, iItem, 0, &str[0]);
    }

    void OnRight(HWND hwnd)
    {
        INT iItem = ListView_GetNextItem(m_hLst1, -1, LVNI_ALL | LVNI_SELECTED);
        if (iItem < 0)
            return;

        if (iItem == 0)
            return;

        WCHAR CaptionUp[128];
        ListView_GetItemText(m_hLst1, iItem - 1, 0, CaptionUp, _countof(CaptionUp));
        WCHAR szCaption[128];
        ListView_GetItemText(m_hLst1, iItem, 0, szCaption, _countof(szCaption));

        MStringW strIndent = LoadStringDx(IDS_INDENT);
        size_t depth_up = mstr_repeat_count(CaptionUp, strIndent);
        size_t depth = mstr_repeat_count(szCaption, strIndent);

        if (depth_up < depth)
            return;

        std::wstring str = strIndent + szCaption;
        ListView_SetItemText(m_hLst1, iItem, 0, &str[0]);
    }

    void OnOK(HWND hwnd)
    {
        MENU_ENTRY entry;
        INT iItem, nCount = ListView_GetItemCount(m_hLst1);

        if (nCount == 0)
        {
            ErrorBoxDx(IDS_DATAISEMPTY);
            return;
        }

        BOOL Extended = (IsDlgButtonChecked(hwnd, chx1) == BST_CHECKED);
        if (Extended)
        {
            m_menu_res.header().wVersion = 1;
            m_menu_res.header().wOffset = 4;
            m_menu_res.header().dwHelpId = 0;
            m_menu_res.exitems().clear();
            for (iItem = 0; iItem < nCount; ++iItem)
            {
                GetEntry(hwnd, entry, iItem);

                MenuRes::ExMenuItem exitem;

                SetMenuTypeAndState(exitem.dwType, exitem.dwState, entry.szFlags);
                exitem.menuId = g_db.GetResIDValue(entry.szCommandID);
                exitem.bResInfo = 0;
                exitem.text = entry.szCaption;
                exitem.dwHelpId = g_db.GetResIDValue(entry.szHelpID);
                exitem.wDepth = entry.wDepth;

                m_menu_res.exitems().push_back(exitem);
            }
        }
        else
        {
            m_menu_res.header().wVersion = 0;
            m_menu_res.header().wOffset = 4;
            m_menu_res.header().dwHelpId = 0;
            m_menu_res.items().clear();
            for (iItem = 0; iItem < nCount; ++iItem)
            {
                GetEntry(hwnd, entry, iItem);

                MenuRes::MenuItem item;

                SetMenuFlags(item.fItemFlags, entry.szFlags);
                item.wMenuID = (WORD)g_db.GetResIDValue(entry.szCommandID);
                item.wDepth = entry.wDepth;
                item.text = entry.szCaption;

                m_menu_res.items().push_back(item);
            }
        }

        EndDialog(IDOK);
    }

    void OnCommand(HWND hwnd, int id, HWND hwndCtl, UINT codeNotify)
    {
        switch (id)
        {
        case psh1:
            OnAdd(hwnd);
            break;
        case psh2:
            OnModify(hwnd);
            break;
        case psh3:
            OnDelete(hwnd);
            break;
        case psh4:
            OnUp(hwnd);
            break;
        case psh5:
            OnDown(hwnd);
            break;
        case psh6:
            OnLeft(hwnd);
            break;
        case psh7:
            OnRight(hwnd);
            break;
        case IDOK:
            OnOK(hwnd);
            break;
        case IDCANCEL:
            EndDialog(IDCANCEL);
            break;
        }
    }

    void OnItemChanged(HWND hwnd)
    {
        INT iItem = ListView_GetNextItem(m_hLst1, -1, LVNI_ALL | LVNI_SELECTED);
        BOOL bSelected = (iItem != -1);
        EnableWindow(GetDlgItem(hwnd, psh2), bSelected);
        EnableWindow(GetDlgItem(hwnd, psh3), bSelected);
        EnableWindow(GetDlgItem(hwnd, psh4), bSelected);
        EnableWindow(GetDlgItem(hwnd, psh5), bSelected);
        EnableWindow(GetDlgItem(hwnd, psh6), bSelected);
        EnableWindow(GetDlgItem(hwnd, psh7), bSelected);
    }

    void OnInitMenuPopup(HWND hwnd, HMENU hMenu, UINT item, BOOL fSystemMenu)
    {
        INT iItem = ListView_GetNextItem(m_hLst1, -1, LVNI_ALL | LVNI_SELECTED);
        BOOL bSelected = (iItem != -1);
        EnableMenuItem(hMenu, psh2, bSelected ? MF_ENABLED : MF_GRAYED);
        EnableMenuItem(hMenu, psh3, bSelected ? MF_ENABLED : MF_GRAYED);
        EnableMenuItem(hMenu, psh4, bSelected ? MF_ENABLED : MF_GRAYED);
        EnableMenuItem(hMenu, psh5, bSelected ? MF_ENABLED : MF_GRAYED);
        EnableMenuItem(hMenu, psh6, bSelected ? MF_ENABLED : MF_GRAYED);
        EnableMenuItem(hMenu, psh7, bSelected ? MF_ENABLED : MF_GRAYED);
    }

    LRESULT OnNotify(HWND hwnd, int idFrom, NMHDR *pnmhdr)
    {
        if (idFrom == lst1)
        {
            if (pnmhdr->code == LVN_KEYDOWN)
            {
                LV_KEYDOWN *KeyDown = (LV_KEYDOWN *)pnmhdr;
                if (KeyDown->wVKey == VK_DELETE)
                {
                    OnDelete(hwnd);
                    return 0;
                }
            }
            if (pnmhdr->code == NM_DBLCLK)
            {
                OnModify(hwnd);
                return 0;
            }
            if (pnmhdr->code == LVN_GETINFOTIP)
            {
                NMLVGETINFOTIP *pGetInfoTip = (NMLVGETINFOTIP *)pnmhdr;
                INT iItem = pGetInfoTip->iItem;
                INT iSubItem = pGetInfoTip->iSubItem;
                TCHAR szText[128];
                ListView_GetItemText(m_hLst1, iItem, iSubItem, szText, _countof(szText));
                StringCchCopy(pGetInfoTip->pszText, pGetInfoTip->cchTextMax, szText);
            }
            if (pnmhdr->code == LVN_ITEMCHANGED)
            {
                //NM_LISTVIEW *pListView = (NM_LISTVIEW *)pnmhdr;
                OnItemChanged(hwnd);
            }
        }
        return 0;
    }

    virtual INT_PTR CALLBACK
    DialogProcDx(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
    {
        switch (uMsg)
        {
            HANDLE_MSG(hwnd, WM_INITDIALOG, OnInitDialog);
            HANDLE_MSG(hwnd, WM_COMMAND, OnCommand);
            HANDLE_MSG(hwnd, WM_NOTIFY, OnNotify);
            HANDLE_MSG(hwnd, WM_SIZE, OnSize);
            HANDLE_MSG(hwnd, WM_CONTEXTMENU, OnContextMenu);
            HANDLE_MSG(hwnd, WM_INITMENUPOPUP, OnInitMenuPopup);
        }
        return DefaultProcDx();
    }

    void OnSize(HWND hwnd, UINT state, int cx, int cy)
    {
        m_resizable.OnSize();
    }

    void OnContextMenu(HWND hwnd, HWND hwndContext, UINT xPos, UINT yPos)
    {
        if (hwndContext == m_hLst1)
        {
            PopupMenuDx(hwnd, m_hLst1, IDR_POPUPMENUS, 6, xPos, yPos);
        }
    }
};

```

`src/MEditToolbarDlg.hpp`:

```hpp
// MEditToolbarDlg.hpp --- Dialogs for edit of TOOLBAR resource
//////////////////////////////////////////////////////////////////////////////
// RisohEditor --- Another free Win32 resource editor
// Copyright (C) 2022 Katayama Hirofumi MZ <katayama.hirofumi.mz@gmail.com>
// 
// This program is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
// 
// This program is distributed in the hope that it will be useful, 
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
// 
// You should have received a copy of the GNU General Public License
// along with this program.  If not, see <http://www.gnu.org/licenses/>.
//////////////////////////////////////////////////////////////////////////////

#pragma once

#include "resource.h"
#include "MWindowBase.hpp"
#include "RisohSettings.hpp"
#include "ConstantsDB.hpp"
#include "MComboBoxAutoComplete.hpp"
#include "ToolbarRes.hpp"
#include "Common.hpp"

class MModifyTBBtnDlg;
class MEditToolbarDlg;

//////////////////////////////////////////////////////////////////////////////

class MModifyTBBtnDlg : public MDialogBase
{
public:
    std::wstring m_str;
    MComboBoxAutoComplete m_cmb1;

    MModifyTBBtnDlg(INT id, const std::wstring& str = L"") : MDialogBase(id), m_str(str)
    {
    }

    BOOL OnInitDialog(HWND hwnd, HWND hwndFocus, LPARAM lParam)
    {
        InitCtrlIDComboBox(GetDlgItem(hwnd, cmb1));
        SubclassChildDx(m_cmb1, cmb1);

        SendDlgItemMessageW(hwnd, cmb1, CB_SETCURSEL, -1, 0);
        if (m_str[0] == L'-')
        {
            CheckDlgButton(hwnd, chx1, BST_CHECKED);
            SetDlgItemTextW(hwnd, cmb1, L"");
        }
        else
        {
            SetDlgItemTextW(hwnd, cmb1, m_str.c_str());
        }

        CenterWindowDx();
        return TRUE;
    }

    void OnOK(HWND hwnd)
    {
        WCHAR szText[MAX_PATH];
        GetDlgItemTextW(hwnd, cmb1, szText, _countof(szText));
        ReplaceFullWithHalf(szText);
        mstr_trim(szText);

        if (szText[0] == L'-')
            szText[0] = 0;

        if (szText[0] && !CheckCommand(szText))
        {
            ErrorBoxDx(IDS_NOSUCHID);
            return;
        }

        if (IsDlgButtonChecked(hwnd, chx1) == BST_CHECKED)
            szText[0] = 0;

        m_str = szText;
        EndDialog(IDOK);
    }

    BOOL m_bUpdating = FALSE;

    void OnChx1(HWND hwnd)
    {
        if (m_bUpdating)
            return;

        if (IsDlgButtonChecked(hwnd, chx1) == BST_CHECKED)
        {
            m_bUpdating = TRUE;
            SendDlgItemMessageW(hwnd, cmb1, CB_SETCURSEL, -1, 0);
            SetDlgItemTextW(hwnd, cmb1, NULL);
            m_bUpdating = FALSE;
        }
    }

    void OnCmb1(HWND hwnd)
    {
        if (m_bUpdating)
            return;

        INT iItem = ComboBox_GetCurSel(m_cmb1);
        if (iItem != CB_ERR)
            return;

        WCHAR sz1[MAX_PATH];
        sz1[0] = 0;
        ::GetDlgItemTextW(hwnd, cmb1, sz1, _countof(sz1));
        ReplaceFullWithHalf(sz1);
        mstr_trim(sz1);

        if (sz1[0])
        {
            m_bUpdating = TRUE;
            if (sz1[0] == L'-')
                CheckDlgButton(hwnd, chx1, BST_CHECKED);
            else
                CheckDlgButton(hwnd, chx1, BST_UNCHECKED);
            m_bUpdating = FALSE;
        }
    }

    void OnCommand(HWND hwnd, int id, HWND hwndCtl, UINT codeNotify)
    {
        switch (id)
        {
        case IDOK:
            OnOK(hwnd);
            break;
        case IDCANCEL:
            EndDialog(IDCANCEL);
            break;
        case chx1:
            OnChx1(hwnd);
            break;
        case cmb1:
            if (codeNotify == CBN_EDITCHANGE)
            {
                m_cmb1.OnEditChange();
            }
            OnCmb1(hwnd);
            break;
        }
    }

    virtual INT_PTR CALLBACK
    DialogProcDx(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
    {
        switch (uMsg)
        {
            HANDLE_MSG(hwnd, WM_INITDIALOG, OnInitDialog);
            HANDLE_MSG(hwnd, WM_COMMAND, OnCommand);
        }
        return DefaultProcDx();
    }
};

class MEditToolbarDlg : public MDialogBase
{
public:
    ToolbarRes& m_toolbar_res;
    HICON m_hIcon;
    HICON m_hIconSm;
    HWND m_hLst1;

    MEditToolbarDlg(ToolbarRes& toolbar_res)
        : MDialogBase(IDD_TOOLBARRES), m_toolbar_res(toolbar_res)
    {
        m_hIcon = LoadIconDx(IDI_SMILY);
        m_hIconSm = LoadSmallIconDx(IDI_SMILY);
        m_hLst1 = NULL;
    }

    ~MEditToolbarDlg()
    {
        DestroyIcon(m_hIcon);
        DestroyIcon(m_hIconSm);
    }

    BOOL OnInitDialog(HWND hwnd, HWND hwndFocus, LPARAM lParam)
    {
        SetDlgItemInt(hwnd, edt1, m_toolbar_res.width(), FALSE);
        SetDlgItemInt(hwnd, edt2, m_toolbar_res.height(), FALSE);

        SendDlgItemMessage(hwnd, scr1, UDM_SETRANGE, 0, MAKELPARAM((WORD)SHRT_MAX, 3));
        SendDlgItemMessage(hwnd, scr2, UDM_SETRANGE, 0, MAKELPARAM((WORD)SHRT_MAX, 3));

        m_hLst1 = GetDlgItem(hwnd, lst1);
        for (size_t i = 0; i < m_toolbar_res.size(); ++i)
        {
            DWORD id = m_toolbar_res[i];
            if (id != 0)
            {
                std::wstring str = g_db.GetNameOfResID(IDTYPE_COMMAND, IDTYPE_NEWCOMMAND, id, true);
                SendMessageW(m_hLst1, LB_ADDSTRING, 0, (LPARAM)str.c_str());
            }
            else
            {
                SendMessageW(m_hLst1, LB_ADDSTRING, 0, (LPARAM)L"---");
            }
        }
        SendMessageW(m_hLst1, LB_SETCURSEL, 0, 0);

        SendMessageW(m_hLst1, LB_SETITEMHEIGHT, 0, GetItemHeight(hwnd));

        SendMessageDx(WM_SETICON, ICON_BIG, (LPARAM)m_hIcon);
        SendMessageDx(WM_SETICON, ICON_SMALL, (LPARAM)m_hIconSm);

        CenterWindowDx();
        return TRUE;
    }

    INT GetItemHeight(HWND hwnd)
    {
        HFONT hFont = GetStockFont(DEFAULT_GUI_FONT);

        TEXTMETRIC tm;
        HDC hDC = CreateCompatibleDC(NULL);
        SelectObject(hDC, hFont);
        GetTextMetrics(hDC, &tm);
        DeleteDC(hDC);

        return tm.tmHeight * 2;
    }

    void OnAdd(HWND hwnd)
    {
        MModifyTBBtnDlg dialog(IDD_ADDTBBTN, L"");
        if (dialog.DialogBoxDx(hwnd) == IDOK)
        {
            auto& str = dialog.m_str;
            if (str.empty() || str[0] == L'-')
                str = L"---";
            INT iItem = (INT)SendMessageW(m_hLst1, LB_INSERTSTRING, -1, (LPARAM)str.c_str());
            SendMessageW(m_hLst1, LB_SETCURSEL, iItem, 0);
        }
    }

    void OnModify(HWND hwnd)
    {
        INT iItem = (INT)SendMessageW(m_hLst1, LB_GETCURSEL, 0, 0);
        if (iItem < 0)
            return;

        WCHAR sz1[MAX_PATH];
        sz1[0] = 0;
        SendMessageW(m_hLst1, LB_GETTEXT, iItem, (LPARAM)sz1);

        MModifyTBBtnDlg dialog(IDD_MODIFYTBBTN, sz1);
        if (dialog.DialogBoxDx(hwnd) == IDOK)
        {
            auto& str = dialog.m_str;
            if (str.empty() || str[0] == L'-')
                str = L"---";
            SendMessageW(m_hLst1, LB_DELETESTRING, iItem, 0);
            SendMessageW(m_hLst1, LB_INSERTSTRING, iItem, (LPARAM)str.c_str());
            SendMessageW(m_hLst1, LB_SETCURSEL, iItem, 0);
        }
    }

    void OnDelete(HWND hwnd)
    {
        INT iItem = (INT)SendMessageW(m_hLst1, LB_GETCURSEL, 0, 0);
        if (iItem >= 0)
        {
            SendMessageW(m_hLst1, LB_DELETESTRING, iItem, 0);
            INT nCount = (INT)SendMessageW(m_hLst1, LB_GETCOUNT, 0, 0);
            if (nCount == iItem)
                SendMessageW(m_hLst1, LB_SETCURSEL, iItem - 1, 0);
            else
                SendMessageW(m_hLst1, LB_SETCURSEL, iItem, 0);
        }
    }

    void OnUp(HWND hwnd)
    {
        INT iItem = (INT)SendMessageW(m_hLst1, LB_GETCURSEL, 0, 0);
        if (iItem > 0)
        {
            WCHAR sz1[MAX_PATH], sz2[MAX_PATH];
            sz1[0] = sz2[0] = 0;
            SendMessageW(m_hLst1, LB_GETTEXT, iItem - 1, (LPARAM)sz1);
            SendMessageW(m_hLst1, LB_GETTEXT, iItem, (LPARAM)sz2);
            SendMessageW(m_hLst1, LB_DELETESTRING, iItem - 1, 0);
            SendMessageW(m_hLst1, LB_DELETESTRING, iItem - 1, 0);
            SendMessageW(m_hLst1, LB_INSERTSTRING, iItem - 1, (LPARAM)sz1);
            SendMessageW(m_hLst1, LB_INSERTSTRING, iItem - 1, (LPARAM)sz2);
            SendMessageW(m_hLst1, LB_SETCURSEL, iItem - 1, 0);
        }
    }

    void OnDown(HWND hwnd)
    {
        INT iItem = (INT)SendMessageW(m_hLst1, LB_GETCURSEL, 0, 0);
        INT cItems = (INT)SendMessageW(m_hLst1, LB_GETCOUNT, 0, 0);
        if (iItem + 1 < cItems)
        {
            WCHAR sz1[MAX_PATH], sz2[MAX_PATH];
            sz1[0] = sz2[0] = 0;
            SendMessageW(m_hLst1, LB_GETTEXT, iItem, (LPARAM)sz1);
            SendMessageW(m_hLst1, LB_GETTEXT, iItem + 1, (LPARAM)sz2);
            SendMessageW(m_hLst1, LB_DELETESTRING, iItem, 0);
            SendMessageW(m_hLst1, LB_DELETESTRING, iItem, 0);
            SendMessageW(m_hLst1, LB_INSERTSTRING, iItem, (LPARAM)sz1);
            SendMessageW(m_hLst1, LB_INSERTSTRING, iItem, (LPARAM)sz2);
            SendMessageW(m_hLst1, LB_SETCURSEL, iItem + 1, 0);
        }
    }

    void OnOK(HWND hwnd)
    {
        INT nCount = (INT)SendMessageW(m_hLst1, LB_GETCOUNT, 0, 0);

        m_toolbar_res.clear();

        BOOL bTranslated;

        INT cx = GetDlgItemInt(hwnd, edt1, &bTranslated, FALSE);
        if (!bTranslated)
        {
            SetFocus(GetDlgItem(hwnd, edt1));
            SendDlgItemMessageW(hwnd, edt1, EM_SETSEL, 0, -1);
            ErrorBoxDx(IDS_ENTERINT);
            return;
        }
        INT cy = GetDlgItemInt(hwnd, edt2, &bTranslated, FALSE);
        if (!bTranslated)
        {
            SetFocus(GetDlgItem(hwnd, edt2));
            SendDlgItemMessageW(hwnd, edt2, EM_SETSEL, 0, -1);
            ErrorBoxDx(IDS_ENTERINT);
            return;
        }
        m_toolbar_res.width(cx);
        m_toolbar_res.height(cy);

        for (INT iItem = 0; iItem < nCount; ++iItem)
        {
            WCHAR sz1[MAX_PATH];
            sz1[0] = 0;
            SendMessageW(m_hLst1, LB_GETTEXT, iItem, (LPARAM)sz1);

            if (!sz1[0] || sz1[0] == L'-')
            {
                m_toolbar_res.push_back(0);
            }
            else
            {
                INT id = (INT)g_db.GetResIDValue(sz1);
                m_toolbar_res.push_back(id);
            }
        }

        EndDialog(IDOK);
    }

    void OnLst1DoubleClick(HWND hwnd)
    {
        OnModify(hwnd);
    }

    void OnCommand(HWND hwnd, int id, HWND hwndCtl, UINT codeNotify)
    {
        switch (id)
        {
        case psh1:
            OnAdd(hwnd);
            break;
        case psh2:
            OnModify(hwnd);
            break;
        case psh3:
            OnDelete(hwnd);
            break;
        case psh4:
            OnUp(hwnd);
            break;
        case psh5:
            OnDown(hwnd);
            break;
        case IDOK:
            OnOK(hwnd);
            break;
        case IDCANCEL:
            EndDialog(IDCANCEL);
            break;
        case lst1:
            switch (codeNotify)
            {
            case LBN_DBLCLK:
                OnLst1DoubleClick(hwnd);
                break;
            }
            break;
        }
    }

    void OnDrawItem(HWND hwnd, const DRAWITEMSTRUCT * lpDrawItem)
    {
        HDC hDC = lpDrawItem->hDC;
        RECT rcItem = lpDrawItem->rcItem;
        INT iItem = lpDrawItem->itemID;

        WCHAR sz1[MAX_PATH];
        sz1[0] = 0;
        SendMessageW(m_hLst1, LB_GETTEXT, iItem, (LPARAM)sz1);

        if (lpDrawItem->itemState & ODS_SELECTED)
        {
            FillRect(hDC, &rcItem, GetSysColorBrush(COLOR_HIGHLIGHT));
            SetTextColor(hDC, GetSysColor(COLOR_HIGHLIGHTTEXT));
        }
        else
        {
            FillRect(hDC, &rcItem, GetSysColorBrush(COLOR_WINDOW));
            SetTextColor(hDC, GetSysColor(COLOR_WINDOWTEXT));
        }

        SelectObject(hDC, GetStockObject(DEFAULT_GUI_FONT));
        SetBkMode(hDC, TRANSPARENT);

        InflateRect(&rcItem, -4, -4);
        UINT uFormat = DT_SINGLELINE | DT_LEFT | DT_VCENTER | DT_NOPREFIX;
        DrawText(hDC, sz1, -1, &rcItem, uFormat);
        InflateRect(&rcItem, 4, 4);

        if (lpDrawItem->itemState & ODS_FOCUS)
        {
            InflateRect(&rcItem, -1, -1);
            DrawFocusRect(hDC, &rcItem);
        }
    }

    int OnVkeyToItem(HWND hwnd, UINT vk, HWND hwndListbox, int iCaret)
    {
        if (vk == VK_DELETE)
        {
            OnDelete(hwnd);
        }
        return SetDlgMsgResult(hwnd, WM_VKEYTOITEM, -1);
    }

    virtual INT_PTR CALLBACK
    DialogProcDx(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
    {
        switch (uMsg)
        {
            HANDLE_MSG(hwnd, WM_INITDIALOG, OnInitDialog);
            HANDLE_MSG(hwnd, WM_COMMAND, OnCommand);
            HANDLE_MSG(hwnd, WM_DRAWITEM, OnDrawItem);
            HANDLE_MSG(hwnd, WM_VKEYTOITEM, OnVkeyToItem);
        }
        return DefaultProcDx();
    }
};

```

`src/MEgaDlg.hpp`:

```hpp
// MEgaDlg.hpp --- Programming Language EGA dialog
//////////////////////////////////////////////////////////////////////////////
// RisohEditor --- Another free Win32 resource editor
// Copyright (C) 2020 Katayama Hirofumi MZ <katayama.hirofumi.mz@gmail.com>
// 
// This program is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
// 
// This program is distributed in the hope that it will be useful, 
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
// 
// You should have received a copy of the GNU General Public License
// along with this program.  If not, see <http://www.gnu.org/licenses/>.
//////////////////////////////////////////////////////////////////////////////

#pragma once

#include "resource.h"
#include "MResizable.hpp"
#include "RisohSettings.hpp"
#include "../EGA/ega.hpp"

using namespace EGA;

class MEgaDlg;
static HWND s_hwndEga = NULL;
static BOOL s_bEnter = FALSE;

static bool EGA_dialog_input(char *buf, size_t buflen)
{
    while (!s_bEnter || !::IsWindowVisible(s_hwndEga))
    {
        Sleep(100);
    }
    s_bEnter = FALSE;

    WCHAR szTextW[260];
    GetDlgItemTextW(s_hwndEga, edt2, szTextW, ARRAYSIZE(szTextW));

    char szTextA[260];
    WideCharToMultiByte(CP_UTF8, 0, szTextW, -1, szTextA, ARRAYSIZE(szTextA), NULL, NULL);

    StringCchCopyA(buf, buflen, szTextA);
    SetDlgItemTextA(s_hwndEga, edt2, NULL);

    if (lstrcmpA(szTextA, "exit") == 0 || lstrcmpA(szTextA, "exit;") == 0)
        PostMessageW(s_hwndEga, WM_COMMAND, IDCANCEL, 0);

    mstr_trim(szTextW);

    return true;
}

static void EGA_dialog_print(const char *fmt, va_list va)
{
    if (!IsWindow(s_hwndEga))
        return;

    std::string str;
    str.resize(512);
    while (StringCbVPrintfA(&str[0], str.size(), fmt, va) == STRSAFE_E_INSUFFICIENT_BUFFER)
    {
        str.resize(str.size() * 2);
    }
    str.resize(lstrlenA(str.c_str()));

    mstr_replace_all(str, "\n", "\r\n");

    MAnsiToWide wide(CP_UTF8, str.c_str());

    INT cch = GetWindowTextLengthW(GetDlgItem(s_hwndEga, edt1));
    SendDlgItemMessageW(s_hwndEga, edt1, EM_SETSEL, cch, cch);
    SendDlgItemMessageW(s_hwndEga, edt1, EM_REPLACESEL, FALSE, (LPARAM)wide.c_str());
    SendDlgItemMessageW(s_hwndEga, edt1, EM_SCROLLCARET, 0, 0);
}

static inline DWORD WINAPI EgaThreadFunc(LPVOID args)
{
    EGA_interactive(NULL, true);
    return 0;
}

void EGA_extension(void);

//////////////////////////////////////////////////////////////////////////////

class MEgaDlg : public MDialogBase
{
public:
    std::wstring m_filename;

    DECLARE_DYNAMIC(MEgaDlg)

    MEgaDlg() : MDialogBase(IDD_EGA)
    {
        m_hIcon = LoadIconDx(IDI_SMILY);
        m_hIconSm = LoadSmallIconDx(IDI_SMILY);

        EGA_init();
        EGA_set_input_fn(EGA_dialog_input);
        EGA_set_print_fn(EGA_dialog_print);
        EGA_extension();
    }

    virtual ~MEgaDlg()
    {
        EGA_uninit();
        DeleteObject(m_hFont);

        DestroyIcon(m_hIcon);
        DestroyIcon(m_hIconSm);
    }

    void Run(LPCWSTR filename)
    {
        char szFileName[MAX_PATH];
        if (filename && filename[0])
        {
            WideCharToMultiByte(CP_ACP, 0, filename, -1, szFileName, _countof(szFileName), NULL, NULL);
            s_bEnter = TRUE;
            EGA_file_input(szFileName);
        }
    }

    BOOL OnInitDialog(HWND hwnd, HWND hwndFocus, LPARAM lParam)
    {
        s_hwndEga = hwnd;
        m_resizable.OnParentCreate(hwnd);

        m_resizable.SetLayoutAnchor(grp1, mzcLA_TOP_LEFT, mzcLA_BOTTOM_RIGHT);
        m_resizable.SetLayoutAnchor(edt1, mzcLA_TOP_LEFT, mzcLA_BOTTOM_RIGHT);
        m_resizable.SetLayoutAnchor(stc1, mzcLA_BOTTOM_LEFT);
        m_resizable.SetLayoutAnchor(edt2, mzcLA_BOTTOM_LEFT, mzcLA_BOTTOM_RIGHT);
        m_resizable.SetLayoutAnchor(IDOK, mzcLA_BOTTOM_RIGHT);
        SendMessageDx(WM_SETICON, ICON_BIG, (LPARAM)m_hIcon);
        SendMessageDx(WM_SETICON, ICON_SMALL, (LPARAM)m_hIconSm);

        LOGFONTW lf;
        ZeroMemory(&lf, sizeof(lf));
        lf.lfHeight = -12;
        lf.lfCharSet = DEFAULT_CHARSET;
        lf.lfPitchAndFamily = FIXED_PITCH | FF_MODERN;
        m_hFont = CreateFontIndirectW(&lf);
        SendDlgItemMessageW(hwnd, edt1, WM_SETFONT, (WPARAM)m_hFont, TRUE);

        HANDLE hThread = ::CreateThread(NULL, 0, EgaThreadFunc, NULL, 0, NULL);
        ::CloseHandle(hThread);

        if (g_settings.nEgaX != CW_USEDEFAULT && g_settings.nEgaWidth != CW_USEDEFAULT)
        {
            SetWindowPos(hwnd, NULL,
                g_settings.nEgaX, g_settings.nEgaY,
                g_settings.nEgaWidth, g_settings.nEgaHeight,
                SWP_NOACTIVATE | SWP_NOOWNERZORDER | SWP_NOZORDER);
        }
        else if (g_settings.nEgaX != CW_USEDEFAULT)
        {
            SetWindowPos(hwnd, NULL,
                g_settings.nEgaX, g_settings.nEgaY,
                g_settings.nEgaWidth, g_settings.nEgaHeight,
                SWP_NOSIZE | SWP_NOACTIVATE | SWP_NOOWNERZORDER | SWP_NOZORDER);
        }
        else if (g_settings.nEgaWidth != CW_USEDEFAULT)
        {
            SetWindowPos(hwnd, NULL,
                g_settings.nEgaX, g_settings.nEgaY,
                g_settings.nEgaWidth, g_settings.nEgaHeight,
                SWP_NOMOVE | SWP_NOACTIVATE | SWP_NOOWNERZORDER | SWP_NOZORDER);
        }
        else
        {
            CenterWindowDx();
        }
        return TRUE;
    }

    void OnOK(HWND hwnd)
    {
        s_bEnter = TRUE;
    }

    void OnPsh1(HWND hwnd)
    {
    }

    void OnCommand(HWND hwnd, int id, HWND hwndCtl, UINT codeNotify)
    {
        switch (id)
        {
        case IDOK:
            OnOK(hwnd);
            break;
        case IDCANCEL:
            s_bEnter = FALSE;
            ::ShowWindow(hwnd, SW_HIDE);
            break;
        case psh1:
            OnPsh1(hwnd);
            break;
        }
    }

    HBRUSH OnCtlColor(HWND hwnd, HDC hdc, HWND hwndChild, int type)
    {
        UINT id;
        switch (type)
        {
        case CTLCOLOR_EDIT:
        case CTLCOLOR_STATIC:
        case CTLCOLOR_BTN:
            id = GetDlgCtrlID(hwndChild);
            switch (id)
            {
            case edt1:
            case edt2:
                SetTextColor(hdc, RGB(0, 255, 0));
                SetBkColor(hdc, RGB(0, 0, 0));
                return GetStockBrush(BLACK_BRUSH);
            }
        }
        return (HBRUSH)(COLOR_3DFACE + 1);
    }

    void OnMove(HWND hwnd, int x, int y)
    {
        if (IsWindowVisible(hwnd) && !IsMinimized(hwnd) && !IsMaximized(hwnd))
        {
            RECT rc;
            GetWindowRect(hwnd, &rc);
            g_settings.nEgaX = rc.left;
            g_settings.nEgaY = rc.top;
        }
    }

    void OnSize(HWND hwnd, UINT state, int cx, int cy)
    {
        m_resizable.OnSize();

        if (IsWindowVisible(hwnd) && !IsMinimized(hwnd) && !IsMaximized(hwnd))
        {
            RECT rc;
            GetWindowRect(hwnd, &rc);
            g_settings.nEgaWidth = rc.right - rc.left;
            g_settings.nEgaHeight = rc.bottom - rc.top;
        }
    }

    virtual INT_PTR CALLBACK
    DialogProcDx(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
    {
        switch (uMsg)
        {
        HANDLE_MSG(hwnd, WM_INITDIALOG, OnInitDialog);
        HANDLE_MSG(hwnd, WM_COMMAND, OnCommand);
        HANDLE_MSG(hwnd, WM_CTLCOLOREDIT, OnCtlColor);
        HANDLE_MSG(hwnd, WM_CTLCOLORSTATIC, OnCtlColor);
        HANDLE_MSG(hwnd, WM_MOVE, OnMove);
        HANDLE_MSG(hwnd, WM_SIZE, OnSize);
        default:
            return DefaultProcDx();
        }
    }

protected:
    HFONT m_hFont;
    HICON m_hIcon;
    HICON m_hIconSm;
    MResizable m_resizable;
};

```

`src/MEncodingDlg.hpp`:

```hpp
// MEncodingDlg.hpp --- "Encoding" Dialog
//////////////////////////////////////////////////////////////////////////////
// RisohEditor --- Another free Win32 resource editor
// Copyright (C) 2017-2018 Katayama Hirofumi MZ <katayama.hirofumi.mz@gmail.com>
// 
// This program is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
// 
// This program is distributed in the hope that it will be useful, 
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
// 
// You should have received a copy of the GNU General Public License
// along with this program.  If not, see <http://www.gnu.org/licenses/>.
//////////////////////////////////////////////////////////////////////////////

#pragma once

#include "resource.h"
#include "MWindowBase.hpp"
#include "RisohSettings.hpp"
#include "ConstantsDB.hpp"
#include "Res.hpp"
#include "MResizable.hpp"
#include "MComboBoxAutoComplete.hpp"

class MAddEncDlg;
class MModifyEncDlg;
class MEncodingDlg;

//////////////////////////////////////////////////////////////////////////////

inline MString txt2enc(const MString& txt)
{
    if (txt == LoadStringDx(IDS_ANSI))
        return L"ansi";
    if (txt == LoadStringDx(IDS_WIDE))
        return L"wide";
    if (txt == LoadStringDx(IDS_UTF8))
        return L"utf8";
    if (txt == LoadStringDx(IDS_UTF8N))
        return L"utf8n";
    if (txt == LoadStringDx(IDS_SJIS))
        return L"sjis";
    return L"";
}

inline MString enc2txt(const MString& enc)
{
    if (enc == L"ansi")
        return LoadStringDx(IDS_ANSI);
    if (enc == L"wide")
        return LoadStringDx(IDS_WIDE);
    if (enc == L"utf8")
        return LoadStringDx(IDS_UTF8);
    if (enc == L"utf8n")
        return LoadStringDx(IDS_UTF8N);
    if (enc == L"sjis")
        return LoadStringDx(IDS_SJIS);
    return L"";
}

inline MIdOrString get_type_from_text(MString str)
{
    mstr_trim(str);

    MIdOrString type;
    auto k = str.find(L" (");   // )
    if (k != MStringW::npos)
    {
        int num = mstr_parse_int(&str[k + 2]);
        type = (WORD)num;
    }
    else if (str.size() && mchr_is_digit(str[0]))
    {
        int num = mstr_parse_int(&str[0]);
        type = (WORD)num;
    }
    else
    {
        type.m_str = std::move(str);
    }
    return type;
}

// get the resource type label
inline MStringW get_type_label(MIdOrString& type)
{
    if (!type.m_id)
        return type.m_str;    // string name type

    // it was integer name type

    MStringW label = g_db.GetName(L"RESOURCE", type.m_id);
    if (label.empty())  // unable to get the label
        return mstr_dec_word(type.m_id);  // returns the numeric text

    // got the label
    if (!mchr_is_digit(label[0]))   // first character is not digit
    {
        // add a parenthesis pair and numeric text
        label += L" (";
        label += mstr_dec_word(type.m_id);
        label += L")";
    }

    return label;
}

//////////////////////////////////////////////////////////////////////////////

void InitResTypeComboBox(HWND hCmb1, const MIdOrString& type);

class MAddEncDlg : public MDialogBase
{
public:
    MIdOrString m_type;
    MString m_enc;
    MComboBoxAutoComplete m_cmb1;

    MAddEncDlg() : MDialogBase(IDD_ADDENC)
    {
    }

    BOOL OnInitDialog(HWND hwnd, HWND hwndFocus, LPARAM lParam)
    {
        SubclassChildDx(m_cmb1, cmb1);

        HWND hCmb1 = GetDlgItem(hwnd, cmb1);
        InitResTypeComboBox(hCmb1, MIdOrString());

        HWND hCmb2 = GetDlgItem(hwnd, cmb2);
        ComboBox_AddString(hCmb2, LoadStringDx(IDS_ANSI));
        ComboBox_AddString(hCmb2, LoadStringDx(IDS_WIDE));
        INT k = ComboBox_AddString(hCmb2, LoadStringDx(IDS_UTF8));
        ComboBox_AddString(hCmb2, LoadStringDx(IDS_UTF8N));
        ComboBox_AddString(hCmb2, LoadStringDx(IDS_SJIS));
        //ComboBox_AddString(hCmb2, LoadStringDx(IDS_BINARY));

        ComboBox_SetCurSel(hCmb2, k);

        return TRUE;
    }

    void OnOK(HWND hwnd)
    {
        MString text = GetDlgItemText(hwnd, cmb1);
        m_type = get_type_from_text(text);
        if (m_type.empty())
        {
            ErrorBoxDx(IDS_INVALIDRESTYPE);
            return;
        }

        text = GetDlgItemText(hwnd, cmb2);
        m_enc = txt2enc(text);
        if (m_enc.empty())
        {
            return;
        }

        EndDialog(IDOK);
    }

    void OnCommand(HWND hwnd, int id, HWND hwndCtl, UINT codeNotify)
    {
        switch (id)
        {
        case IDOK:
            OnOK(hwnd);
            break;
        case IDCANCEL:
            EndDialog(IDCANCEL);
            break;
        case cmb1:
            if (codeNotify == CBN_EDITCHANGE)
            {
                m_cmb1.OnEditChange();  // input completion
            }
            break;
        }
    }

    virtual INT_PTR CALLBACK
    DialogProcDx(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
    {
        switch (uMsg)
        {
        HANDLE_MSG(hwnd, WM_INITDIALOG, OnInitDialog);
        HANDLE_MSG(hwnd, WM_COMMAND, OnCommand);
        default:
            return DefaultProcDx();
        }
    }
};

//////////////////////////////////////////////////////////////////////////////

class MModifyEncDlg : public MDialogBase
{
public:
    MIdOrString m_type;
    MString m_enc;
    MComboBoxAutoComplete m_cmb1;

    MModifyEncDlg(const MIdOrString& type, MString enc) :
        MDialogBase(IDD_MODIFYENC),
        m_type(type),
        m_enc(enc)
    {
    }

    BOOL OnInitDialog(HWND hwnd, HWND hwndFocus, LPARAM lParam)
    {
        SubclassChildDx(m_cmb1, cmb1);

        HWND hCmb1 = GetDlgItem(hwnd, cmb1);
        InitResTypeComboBox(hCmb1, m_type);
        EnableWindow(hCmb1, FALSE);

        HWND hCmb2 = GetDlgItem(hwnd, cmb2);
        ComboBox_AddString(hCmb2, LoadStringDx(IDS_ANSI));
        ComboBox_AddString(hCmb2, LoadStringDx(IDS_WIDE));
        ComboBox_AddString(hCmb2, LoadStringDx(IDS_UTF8));
        ComboBox_AddString(hCmb2, LoadStringDx(IDS_UTF8N));
        ComboBox_AddString(hCmb2, LoadStringDx(IDS_SJIS));
        //ComboBox_AddString(hCmb2, LoadStringDx(IDS_BINARY));

        MString txt = enc2txt(m_enc);
        int k = ComboBox_FindStringExact(hCmb2, -1, txt.c_str());
        ComboBox_SetCurSel(hCmb2, k);

        return TRUE;
    }

    void OnOK(HWND hwnd)
    {
        MString text = GetDlgItemText(hwnd, cmb1);
        m_type = get_type_from_text(text);
        if (m_type.empty())
        {
            ErrorBoxDx(IDS_INVALIDRESTYPE);
            return;
        }

        text = GetDlgItemText(hwnd, cmb2);
        m_enc = txt2enc(text);
        if (m_enc.empty())
        {
            return;
        }

        EndDialog(IDOK);
    }

    void OnCommand(HWND hwnd, int id, HWND hwndCtl, UINT codeNotify)
    {
        switch (id)
        {
        case IDOK:
            OnOK(hwnd);
            break;
        case IDCANCEL:
            EndDialog(IDCANCEL);
            break;
        case cmb1:
            if (codeNotify == CBN_EDITCHANGE)
            {
                m_cmb1.OnEditChange();  // input completion
            }
            break;
        }
    }

    virtual INT_PTR CALLBACK
    DialogProcDx(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
    {
        switch (uMsg)
        {
        HANDLE_MSG(hwnd, WM_INITDIALOG, OnInitDialog);
        HANDLE_MSG(hwnd, WM_COMMAND, OnCommand);
        default:
            return DefaultProcDx();
        }
    }
};

//////////////////////////////////////////////////////////////////////////////

class MEncodingDlg : public MDialogBase
{
public:
    MResizable m_resizable;
    HWND m_hLst1;
    HICON m_hIcon;
    HICON m_hIconSm;

    MEncodingDlg() : MDialogBase(IDD_ENCODING)
    {
        m_hIcon = LoadIconDx(IDI_SMILY);
        m_hIconSm = LoadSmallIconDx(IDI_SMILY);
    }

    ~MEncodingDlg()
    {
        DestroyIcon(m_hIcon);
        DestroyIcon(m_hIconSm);
    }

    void InitLst1()
    {
        ListView_DeleteAllItems(m_hLst1);

        const auto& map = g_settings.encoding_map;

        INT i = 0;
        for (auto& pair : map)
        {
            if (pair.second.empty())
                continue;

            MStringW str = pair.first;
            MIdOrString type = get_type_from_text(str);
            str = get_type_label(type);

            LV_ITEM item;
            ZeroMemory(&item, sizeof(item));
            item.iItem = i;
            item.mask = LVIF_TEXT;
            item.iSubItem = 0;
            item.pszText = &str[0];
            ListView_InsertItem(m_hLst1, &item);

            str = enc2txt(pair.second);

            ZeroMemory(&item, sizeof(item));
            item.iItem = i;
            item.mask = LVIF_TEXT;
            item.iSubItem = 1;
            item.pszText = &str[0];
            ListView_SetItem(m_hLst1, &item);

            ++i;
        }
    }

    BOOL OnInitDialog(HWND hwnd, HWND hwndFocus, LPARAM lParam)
    {
        SendMessageDx(WM_SETICON, ICON_BIG, (LPARAM)m_hIcon);
        SendMessageDx(WM_SETICON, ICON_SMALL, (LPARAM)m_hIconSm);

        m_hLst1 = GetDlgItem(hwnd, lst1);
        ListView_SetExtendedListViewStyle(m_hLst1, LVS_EX_FULLROWSELECT | LVS_EX_INFOTIP);

        LV_COLUMN column;
        ZeroMemory(&column, sizeof(column));

        column.mask = LVCF_FMT | LVCF_SUBITEM | LVCF_TEXT | LVCF_WIDTH;
        column.fmt = LVCFMT_LEFT;
        column.cx = 140;
        column.pszText = LoadStringDx(IDS_RESTYPE);
        column.iSubItem = 0;
        ListView_InsertColumn(m_hLst1, 0, &column);

        column.mask = LVCF_FMT | LVCF_SUBITEM | LVCF_TEXT | LVCF_WIDTH;
        column.fmt = LVCFMT_LEFT;
        column.cx = 200;
        column.pszText = LoadStringDx(IDS_ENCODING);
        column.iSubItem = 1;
        ListView_InsertColumn(m_hLst1, 1, &column);

        InitLst1();

        UINT state = LVIS_SELECTED | LVIS_FOCUSED;
        ListView_SetItemState(m_hLst1, 0, state, state);
        SetFocus(m_hLst1);

        OnItemChanged(hwnd);

        CenterWindowDx();
        return TRUE;
    }

    void OnReset(HWND hwnd)
    {
        g_settings.ResetEncoding();
        InitLst1();
    }

    void OnOK(HWND hwnd)
    {
        INT iItem, nCount = ListView_GetItemCount(m_hLst1);
        if (nCount == 0)
        {
            return;
        }

        auto& map = g_settings.encoding_map;
        map.clear();

        WCHAR szText1[64], szText2[64];
        for (iItem = 0; iItem < nCount; ++iItem)
        {
            ListView_GetItemText(m_hLst1, iItem, 0, szText1, _countof(szText1));
            mstr_trim(szText1);

            ListView_GetItemText(m_hLst1, iItem, 1, szText2, _countof(szText2));
            mstr_trim(szText2);

            MIdOrString type = get_type_from_text(szText1);
            MString enc = txt2enc(szText2);

            map.insert(std::make_pair(type.str(), enc));
        }

        EndDialog(IDOK);
    }

    void OnContextMenu(HWND hwnd, HWND hwndContext, UINT xPos, UINT yPos)
    {
        if (hwndContext == m_hLst1)
        {
            PopupMenuDx(hwnd, m_hLst1, IDR_POPUPMENUS, 8, xPos, yPos);
        }
    }

    void OnDelete(HWND hwnd)
    {
        INT iItem = ListView_GetNextItem(m_hLst1, -1, LVNI_ALL | LVNI_SELECTED);
        if (iItem >= 0)
        {
            ListView_DeleteItem(m_hLst1, iItem);
        }
    }

    void OnAdd(HWND hwnd)
    {
        MAddEncDlg dialog;
        if (IDOK != dialog.DialogBoxDx(hwnd))
            return;

        MString text1 = get_type_label(dialog.m_type);
        MString text2 = enc2txt(dialog.m_enc);

        INT iItem;

        LV_FINDINFO find;
        WCHAR sz[128];
        StringCchCopyW(sz, _countof(sz), text1.c_str());
        ZeroMemory(&find, sizeof(find));
        find.flags = LVFI_STRING;
        find.psz = sz;
        iItem = ListView_FindItem(m_hLst1, -1, &find);
        if (iItem != -1)
        {
            ListView_DeleteItem(m_hLst1, iItem);
        }

        LV_ITEM item;
        iItem = ListView_GetItemCount(m_hLst1);

        ZeroMemory(&item, sizeof(item));
        item.iItem = iItem;
        item.mask = LVIF_TEXT;
        item.iSubItem = 0;
        item.pszText = &text1[0];
        ListView_InsertItem(m_hLst1, &item);

        ZeroMemory(&item, sizeof(item));
        item.iItem = iItem;
        item.mask = LVIF_TEXT;
        item.iSubItem = 1;
        item.pszText = &text2[0];
        ListView_SetItem(m_hLst1, &item);

        UINT state = LVIS_SELECTED | LVIS_FOCUSED;
        ListView_SetItemState(m_hLst1, iItem, state, state);
        ListView_EnsureVisible(m_hLst1, iItem, FALSE);
    }

    void OnModify(HWND hwnd)
    {
        INT iItem = ListView_GetNextItem(m_hLst1, -1, LVNI_ALL | LVNI_SELECTED);
        if (iItem == -1)
            return;

        WCHAR szText1[64], szText2[64];

        ListView_GetItemText(m_hLst1, iItem, 0, szText1, _countof(szText1));
        mstr_trim(szText1);

        ListView_GetItemText(m_hLst1, iItem, 1, szText2, _countof(szText2));
        mstr_trim(szText2);

        MModifyEncDlg dialog(get_type_from_text(szText1), txt2enc(szText2));
        if (IDOK != dialog.DialogBoxDx(hwnd))
            return;

        MString text2 = enc2txt(dialog.m_enc);

        LV_ITEM item;
        ZeroMemory(&item, sizeof(item));
        item.iItem = iItem;
        item.mask = LVIF_TEXT;
        item.iSubItem = 1;
        item.pszText = &text2[0];
        ListView_SetItem(m_hLst1, &item);

        UINT state = LVIS_SELECTED | LVIS_FOCUSED;
        ListView_SetItemState(m_hLst1, iItem, state, state);
        ListView_EnsureVisible(m_hLst1, iItem, FALSE);
    }

    void OnCommand(HWND hwnd, int id, HWND hwndCtl, UINT codeNotify)
    {
        switch (id)
        {
        case IDOK:
            OnOK(hwnd);
            break;
        case IDCANCEL:
            EndDialog(IDCANCEL);
            break;
        case psh1:
        case ID_ADD:
            OnAdd(hwnd);
            OnItemChanged(hwnd);
            break;
        case psh2:
        case ID_MODIFY:
            OnModify(hwnd);
            break;
        case psh3:
        case ID_DELETE:
            OnDelete(hwnd);
            OnItemChanged(hwnd);
            break;
        case psh5:
            OnReset(hwnd);
            break;
        }
    }

    LRESULT OnNotify(HWND hwnd, int idFrom, NMHDR *pnmhdr)
    {
        if (idFrom == lst1)
        {
            if (pnmhdr->code == LVN_KEYDOWN)
            {
                LV_KEYDOWN *KeyDown = (LV_KEYDOWN *)pnmhdr;
                if (KeyDown->wVKey == VK_DELETE)
                {
                    OnDelete(hwnd);
                    return 0;
                }
            }
            if (pnmhdr->code == NM_DBLCLK)
            {
                OnModify(hwnd);
                return 0;
            }
            if (pnmhdr->code == LVN_ITEMCHANGED)
            {
                //NM_LISTVIEW *pListView = (NM_LISTVIEW *)pnmhdr;
                OnItemChanged(hwnd);
            }
        }
        return 0;
    }

    void OnItemChanged(HWND hwnd)
    {
        INT iItem = ListView_GetNextItem(m_hLst1, -1, LVNI_ALL | LVNI_SELECTED);
        BOOL bSelected = (iItem != -1);
        EnableWindow(GetDlgItem(hwnd, psh2), bSelected);
        EnableWindow(GetDlgItem(hwnd, psh3), bSelected);
    }

    void OnInitMenuPopup(HWND hwnd, HMENU hMenu, UINT item, BOOL fSystemMenu)
    {
        INT iItem = ListView_GetNextItem(m_hLst1, -1, LVNI_ALL | LVNI_SELECTED);
        if (iItem >= 0)
        {
            EnableMenuItem(hMenu, ID_MODIFY, MF_BYCOMMAND | MF_ENABLED);
            EnableMenuItem(hMenu, ID_DELETE, MF_BYCOMMAND | MF_ENABLED);
        }
        else
        {
            EnableMenuItem(hMenu, ID_MODIFY, MF_BYCOMMAND | MF_GRAYED);
            EnableMenuItem(hMenu, ID_DELETE, MF_BYCOMMAND | MF_GRAYED);
        }
    }

    virtual INT_PTR CALLBACK
    DialogProcDx(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
    {
        switch (uMsg)
        {
            HANDLE_MSG(hwnd, WM_INITDIALOG, OnInitDialog);
            HANDLE_MSG(hwnd, WM_COMMAND, OnCommand);
            HANDLE_MSG(hwnd, WM_NOTIFY, OnNotify);
            HANDLE_MSG(hwnd, WM_CONTEXTMENU, OnContextMenu);
            HANDLE_MSG(hwnd, WM_INITMENUPOPUP, OnInitMenuPopup);
        }
        return DefaultProcDx();
    }
};

```

`src/MExportOptionsDlg.hpp`:

```hpp
// MExportOptionsDlg.hpp --- "Export Options" Dialog
//////////////////////////////////////////////////////////////////////////////
// RisohEditor --- Another free Win32 resource editor
// Copyright (C) 2017-2018 Katayama Hirofumi MZ <katayama.hirofumi.mz@gmail.com>
// 
// This program is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
// 
// This program is distributed in the hope that it will be useful, 
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
// 
// You should have received a copy of the GNU General Public License
// along with this program.  If not, see <http://www.gnu.org/licenses/>.
//////////////////////////////////////////////////////////////////////////////

#pragma once

#include "resource.h"
#include "MWindowBase.hpp"
#include "RisohSettings.hpp"

//////////////////////////////////////////////////////////////////////////////

class MExportOptionsDlg : public MDialogBase
{
public:
    MExportOptionsDlg() : MDialogBase(IDD_EXP_OPTIONS)
    {
    }

    void Reload(HWND hwnd)
    {
        CheckDlgButton(hwnd, chx1, g_settings.bSepFilesByLang ? BST_CHECKED : BST_UNCHECKED);
        CheckDlgButton(hwnd, chx2, g_settings.bUseBeginEnd ? BST_CHECKED : BST_UNCHECKED);
        CheckDlgButton(hwnd, chx3, g_settings.bSelectableByMacro ? BST_CHECKED : BST_UNCHECKED);
        CheckDlgButton(hwnd, chx4, g_settings.bBackup ? BST_CHECKED : BST_UNCHECKED);
        CheckDlgButton(hwnd, chx5, g_settings.bRedundantComments ? BST_CHECKED : BST_UNCHECKED);
        CheckDlgButton(hwnd, chx6, g_settings.bWrapManifest ? BST_CHECKED : BST_UNCHECKED);
        CheckDlgButton(hwnd, chx7, g_settings.bRCFileUTF16 ? BST_CHECKED : BST_UNCHECKED);
        CheckDlgButton(hwnd, chx8, g_settings.bUseMSMSGTABLE ? BST_CHECKED : BST_UNCHECKED);

        SendDlgItemMessageW(hwnd, cmb1, CB_ADDSTRING, 0, (LPARAM)L"-old");
        SendDlgItemMessageW(hwnd, cmb1, CB_ADDSTRING, 0, (LPARAM)L"-bak");
        SendDlgItemMessageW(hwnd, cmb1, CB_ADDSTRING, 0, (LPARAM)L"~");
        SetDlgItemTextW(hwnd, cmb1, g_settings.strBackupSuffix.c_str());
    }

    BOOL OnInitDialog(HWND hwnd, HWND hwndFocus, LPARAM lParam)
    {
        Reload(hwnd);

        CenterWindowDx();
        return TRUE;
    }

    void OnOK(HWND hwnd)
    {
        g_settings.bSepFilesByLang = (IsDlgButtonChecked(hwnd, chx1) == BST_CHECKED);
        g_settings.bUseBeginEnd = (IsDlgButtonChecked(hwnd, chx2) == BST_CHECKED);
        g_settings.bSelectableByMacro = (IsDlgButtonChecked(hwnd, chx3) == BST_CHECKED);
        g_settings.bBackup = (IsDlgButtonChecked(hwnd, chx4) == BST_CHECKED);
        g_settings.bRedundantComments = (IsDlgButtonChecked(hwnd, chx5) == BST_CHECKED);
        g_settings.bWrapManifest = (IsDlgButtonChecked(hwnd, chx6) == BST_CHECKED);
        g_settings.bRCFileUTF16 = (IsDlgButtonChecked(hwnd, chx7) == BST_CHECKED);
        g_settings.bUseMSMSGTABLE = (IsDlgButtonChecked(hwnd, chx8) == BST_CHECKED);

        WCHAR szText[32];
        GetDlgItemTextW(hwnd, cmb1, szText, _countof(szText));
        mstr_trim(szText);
        g_settings.strBackupSuffix = szText;

        if (szText[0] == 0)
            g_settings.bBackup = FALSE;

        EndDialog(IDOK);
    }

    void OnCommand(HWND hwnd, int id, HWND hwndCtl, UINT codeNotify)
    {
        switch (id)
        {
        case IDOK:
            OnOK(hwnd);
            break;
        case IDCANCEL:
            EndDialog(hwnd, IDCANCEL);
            break;
        }
    }

    virtual INT_PTR CALLBACK
    DialogProcDx(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
    {
        switch (uMsg)
        {
            DO_MSG(WM_INITDIALOG, OnInitDialog);
            DO_MSG(WM_COMMAND, OnCommand);
        }
        return DefaultProcDx();
    }
};

```

`src/MFile.hpp`:

```hpp
// MFile.hpp -- Win32API file or pipe wrapper                  -*- C++ -*-
// This file is part of MZC4.  See file "ReadMe.txt" and "License.txt".
////////////////////////////////////////////////////////////////////////////

#ifndef MZC4_MFILE_HPP_
#define MZC4_MFILE_HPP_     16      /* Version 16 */

#ifndef _INC_WINDOWS
    #include <windows.h>
#endif
#include <tchar.h>
#include <string>
#include <cassert>
#ifndef NO_STRSAFE
    #include <strsafe.h>
#endif

class MFile;

////////////////////////////////////////////////////////////////////////////

// MString
#ifndef MString
    #include <string>       // std::string and std::wstring
    typedef std::string     MStringA;
    typedef std::wstring    MStringW;
    #ifdef UNICODE
        #define MString     MStringW
    #else
        #define MString     MStringA
    #endif
#endif

#ifndef LOLONG
    #define LOLONG(dwl) static_cast<DWORD>(dwl)
#endif
#ifndef HILONG
    #define HILONG(dwl) static_cast<DWORD>(((dwl) >> 32) & 0xFFFFFFFF)
#endif
#ifndef MAKELONGLONG
    #define MAKELONGLONG(lo,hi) \
        (static_cast<DWORD>(lo) | \
            (static_cast<DWORDLONG>(static_cast<DWORD>(hi)) << 32))
#endif

inline LPWSTR
GetTempFileNameDx(LPCWSTR pszPrefix3Chars)
{
    static WCHAR TempFile[MAX_PATH];
    WCHAR szPath[MAX_PATH];
    GetTempPathW(_countof(szPath), szPath);
    GetTempFileNameW(szPath, L"KRE", 0, TempFile);
    return TempFile;
}

////////////////////////////////////////////////////////////////////////////

class MFile
{
public:
    HANDLE m_hFile;

public:
    MFile();
    MFile(HANDLE hFile);
    MFile(const MFile& file);
    MFile& operator=(HANDLE hFile);
    MFile& operator=(const MFile& file);
    MFile(LPCTSTR pszFileName, BOOL bOutput = FALSE,
          DWORD dwFILE_SHARE_ = FILE_SHARE_READ);
    virtual ~MFile();

    operator HANDLE() const;
    PHANDLE operator&();

    bool operator!() const;
    bool operator==(HANDLE hFile) const;
    bool operator!=(HANDLE hFile) const;
    bool operator==(const MFile& file) const;
    bool operator!=(const MFile& file) const;

    BOOL Attach(HANDLE hFile);
    HANDLE Detach();
    HANDLE Handle() const;
    BOOL CloseHandle();

    BOOL DuplicateHandle(PHANDLE phFile, BOOL bInherit);
    BOOL DuplicateHandle(PHANDLE phFile, BOOL bInherit,
                         DWORD dwDesiredAccess);
    DWORD WaitForSingleObject(DWORD dwTimeout = INFINITE);

    BOOL PeekNamedPipe(LPVOID pBuffer = NULL, DWORD cbBuffer = 0,
                       LPDWORD pcbRead = NULL, LPDWORD pcbAvail = NULL,
                       LPDWORD pBytesLeft = NULL);
    BOOL ReadFile(LPVOID pBuffer, DWORD cbToRead, LPDWORD pcbRead,
                  LPOVERLAPPED pOverlapped = NULL);
    BOOL WriteFile(LPCVOID pBuffer, DWORD cbToWrite, LPDWORD pcbWritten,
                   LPOVERLAPPED pOverlapped = NULL);
    BOOL WriteSzA(LPCSTR psz, LPDWORD pcbWritten,
                  LPOVERLAPPED pOverlapped = NULL);
    BOOL WriteSzW(LPCWSTR psz, LPDWORD pcbWritten,
                  LPOVERLAPPED pOverlapped = NULL);
    BOOL WriteSz(LPCTSTR psz, LPDWORD pcbWritten,
                 LPOVERLAPPED pOverlapped = NULL);

    BOOL         WriteBinary(LPCVOID pv, DWORD cb);
    BOOL         WriteSzA(LPCSTR psz);
    BOOL         WriteSzW(LPCWSTR psz);
    BOOL         WriteSz(LPCTSTR psz);
    BOOL __cdecl WriteFormatA(LPCSTR pszFormat, ...);
    BOOL __cdecl WriteFormatW(LPCWSTR pszFormat, ...);
    BOOL __cdecl WriteFormat(LPCTSTR pszFormat, ...);

    BOOL GetStdHandle(DWORD dwSTD_);
    BOOL GetStdIn();
    BOOL GetStdOut();
    BOOL GetStdErr();
    BOOL SetStdHandle(DWORD dwSTD_) const;
    BOOL SetStdIn() const;
    BOOL SetStdOut() const;
    BOOL SetStdErr() const;

    BOOL OpenFileForInput(LPCTSTR pszFileName,
                          DWORD dwFILE_SHARE_ = FILE_SHARE_READ);
    BOOL OpenFileForOutput(LPCTSTR pszFileName,
                           DWORD dwFILE_SHARE_ = FILE_SHARE_READ);
    BOOL OpenFileForRandom(LPCTSTR pszFileName,
                           DWORD dwFILE_SHARE_ = FILE_SHARE_READ);
    BOOL OpenFileForAppend(LPCTSTR pszFileName,
                           DWORD dwFILE_SHARE_ = FILE_SHARE_READ);

    BOOL CreateFile(LPCTSTR pszFileName, DWORD dwDesiredAccess,
                    DWORD dwShareMode, LPSECURITY_ATTRIBUTES pSA,
                    DWORD dwCreationDistribution,
                    DWORD dwFlagsAndAttributes = FILE_ATTRIBUTE_NORMAL,
                    HANDLE hTemplateFile = NULL);
    DWORD GetFileSize(LPDWORD pdwHighPart = NULL) const;
    DWORDLONG GetFileSize64() const;
    BOOL SetEndOfFile();
    DWORD SetFilePointer(LONG nDeltaLow, PLONG pnDeltaHigh = NULL,
                         DWORD dwOrigin = FILE_BEGIN);
    VOID SeekToBegin();
    DWORD SeekToEnd();
    BOOL FlushFileBuffers();
    BOOL GetFileTime(LPFILETIME pftCreate = NULL,
                     LPFILETIME pftLastAccess = NULL,
                     LPFILETIME pftLastWrite = NULL) const;

    BOOL GetFileInformationByHandle(LPBY_HANDLE_FILE_INFORMATION info);
    DWORD GetFileType() const;

    BOOL LockFile(DWORD dwFileOffsetLow, DWORD dwFileOffsetHigh,
                  DWORD dwNumberOfBytesToLockLow,
                  DWORD dwNumberOfBytesToLockHigh);
    BOOL LockFile(DWORDLONG dwlFileOffset, DWORDLONG dwlNumberOfBytesToLock);

    BOOL LockFileEx(DWORD dwFlags, DWORD dwReserved,
                    DWORD dwNumberOfBytesToLockLow,
                    DWORD dwNumberOfBytesToLockHigh,
                    LPOVERLAPPED lpOverlapped);
    BOOL LockFileEx(DWORD dwFlags, DWORD dwReserved,
                    DWORDLONG dwlNumberOfBytesToLock,
                    LPOVERLAPPED lpOverlapped);

    BOOL UnlockFile(DWORD dwFileOffsetLow, DWORD dwFileOffsetHigh,
                    DWORD dwNumberOfBytesToUnlockLow,
                    DWORD dwNumberOfBytesToUnlockHigh);
    BOOL UnlockFile(DWORDLONG dwFileOffset, DWORDLONG dwNumberOfBytesToUnlock);

    BOOL UnlockFileEx(DWORD dwReserved, DWORD dwNumberOfBytesToUnlockLow,
                      DWORD dwNumberOfBytesToUnlockHigh,
                      LPOVERLAPPED lpOverlapped);
    BOOL UnlockFileEx(DWORD dwReserved, DWORDLONG dwlNumberOfBytesToUnlock,
                      LPOVERLAPPED lpOverlapped);

    BOOL ReadFileEx(LPVOID pBuffer, DWORD cbToRead, LPOVERLAPPED pOverlapped,
                    LPOVERLAPPED_COMPLETION_ROUTINE lpCompletionRoutine);
    BOOL WriteFileEx(LPCVOID pBuffer, DWORD cbToWrite, LPOVERLAPPED pOverlapped,
                     LPOVERLAPPED_COMPLETION_ROUTINE lpCompletionRoutine);

    BOOL ReadAll(MStringA& data);
    BOOL ReadAll(MStringA& data, DWORD dwTimeout);

    static HANDLE CloneHandleDx(HANDLE hFile);
};

////////////////////////////////////////////////////////////////////////////

inline MFile::MFile() : m_hFile(INVALID_HANDLE_VALUE)
{
}

inline MFile::MFile(HANDLE hFile) : m_hFile(hFile)
{
}

inline MFile::MFile(const MFile& file)
    : m_hFile(CloneHandleDx(file.m_hFile))
{
}

inline MFile& MFile::operator=(const MFile& file)
{
    if (Handle() != file.m_hFile)
    {
        HANDLE hFile = CloneHandleDx(file.m_hFile);
        Attach(hFile);
    }
    return *this;
}

inline MFile::MFile(LPCTSTR pszFileName, BOOL bOutput/* = FALSE*/,
                        DWORD dwFILE_SHARE_/* = FILE_SHARE_READ*/)
    : m_hFile(INVALID_HANDLE_VALUE)
{
    if (bOutput)
        OpenFileForOutput(pszFileName, dwFILE_SHARE_);
    else
        OpenFileForInput(pszFileName, dwFILE_SHARE_);
}

inline /*virtual*/ MFile::~MFile()
{
    CloseHandle();
}

inline HANDLE MFile::Handle() const
{
    if (this == NULL)
        return INVALID_HANDLE_VALUE;
    if (m_hFile == NULL)
        return INVALID_HANDLE_VALUE;
    return m_hFile;
}

inline MFile::operator HANDLE() const
{
    return Handle();
}

inline PHANDLE MFile::operator&()
{
    return &m_hFile;
}

inline bool MFile::operator!() const
{
    HANDLE hFile = Handle();
    return hFile == INVALID_HANDLE_VALUE || hFile == NULL;
}

inline bool MFile::operator==(HANDLE hFile) const
{
    return Handle() == hFile;
}

inline bool MFile::operator!=(HANDLE hFile) const
{
    return Handle() != hFile;
}

inline bool MFile::operator==(const MFile& file) const
{
    return Handle() == file.Handle();
}

inline bool MFile::operator!=(const MFile& file) const
{
    return Handle() != file.Handle();
}

inline BOOL MFile::OpenFileForInput(
    LPCTSTR pszFileName, DWORD dwFILE_SHARE_/* = FILE_SHARE_READ*/)
{
    return MFile::CreateFile(pszFileName, GENERIC_READ,
        dwFILE_SHARE_, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);
}

inline BOOL MFile::OpenFileForOutput(
    LPCTSTR pszFileName, DWORD dwFILE_SHARE_/* = FILE_SHARE_READ*/)
{
    return MFile::CreateFile(pszFileName, GENERIC_WRITE,
        dwFILE_SHARE_, NULL, CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);
}

inline BOOL MFile::OpenFileForRandom(
    LPCTSTR pszFileName, DWORD dwFILE_SHARE_/* = FILE_SHARE_READ*/)
{
    return MFile::CreateFile(pszFileName,
        GENERIC_READ | GENERIC_WRITE, dwFILE_SHARE_, NULL, OPEN_ALWAYS,
        FILE_ATTRIBUTE_NORMAL | FILE_FLAG_RANDOM_ACCESS, NULL);
}

inline DWORD MFile::WaitForSingleObject(
    DWORD dwTimeout/* = INFINITE*/)
{
    assert(m_hFile != NULL && m_hFile != INVALID_HANDLE_VALUE);
    return ::WaitForSingleObject(m_hFile, dwTimeout);
}

inline MFile& MFile::operator=(HANDLE hFile)
{
#ifndef NDEBUG
    BY_HANDLE_FILE_INFORMATION info;
    assert(hFile == INVALID_HANDLE_VALUE ||
        ::GetFileInformationByHandle(hFile, &info));
#endif
    if (Handle() != hFile)
    {
        Attach(hFile);
    }
    return *this;
}

inline BOOL MFile::Attach(HANDLE hFile)
{
    CloseHandle();
    assert(hFile != NULL && hFile != INVALID_HANDLE_VALUE);
    assert(m_hFile == NULL || m_hFile == INVALID_HANDLE_VALUE);
#ifndef NDEBUG
    BY_HANDLE_FILE_INFORMATION info;
    assert(::GetFileInformationByHandle(hFile, &info));
#endif
    m_hFile = hFile;
    return m_hFile != NULL && m_hFile != INVALID_HANDLE_VALUE;
}

inline HANDLE MFile::Detach()
{
    HANDLE hFile = m_hFile;
    m_hFile = NULL;
    return hFile;
}

inline BOOL MFile::CloseHandle()
{
    if (Handle() != NULL && Handle() != INVALID_HANDLE_VALUE)
    {
        BOOL bOK = ::CloseHandle(Detach());
        return bOK;
    }
    return FALSE;
}

inline BOOL MFile::PeekNamedPipe(
    LPVOID pBuffer/* = NULL*/,
    DWORD cbBuffer/* = 0*/,
    LPDWORD pcbRead/* = NULL*/,
    LPDWORD pcbAvail/* = NULL*/,
    LPDWORD pBytesLeft/* = NULL*/)
{
    assert(m_hFile != NULL && m_hFile != INVALID_HANDLE_VALUE);
    return ::PeekNamedPipe(m_hFile, pBuffer, cbBuffer,
        pcbRead, pcbAvail, pBytesLeft);
}

inline BOOL MFile::ReadFile(LPVOID pBuffer, DWORD cbToRead,
    LPDWORD pcbRead, LPOVERLAPPED pOverlapped/* = NULL*/)
{
    assert(m_hFile != NULL && m_hFile != INVALID_HANDLE_VALUE);
    return ::ReadFile(m_hFile, pBuffer, cbToRead, pcbRead, pOverlapped);
}

inline BOOL MFile::WriteFile(LPCVOID pBuffer, DWORD cbToWrite,
    LPDWORD pcbWritten, LPOVERLAPPED pOverlapped/* = NULL*/)
{
    assert(m_hFile != NULL && m_hFile != INVALID_HANDLE_VALUE);
    return ::WriteFile(
        m_hFile, pBuffer, cbToWrite, pcbWritten, pOverlapped);
}

inline BOOL MFile::WriteSzA(LPCSTR psz,
    LPDWORD pcbWritten, LPOVERLAPPED pOverlapped/* = NULL*/)
{
    using namespace std;
    SIZE_T size = strlen(psz) * sizeof(CHAR);
    return WriteFile(psz, (DWORD)size, pcbWritten, pOverlapped);
}

inline BOOL MFile::WriteSzW(LPCWSTR psz,
    LPDWORD pcbWritten, LPOVERLAPPED pOverlapped/* = NULL*/)
{
    using namespace std;
    SIZE_T size = wcslen(psz) * sizeof(WCHAR);
    return WriteFile(psz, (DWORD)size, pcbWritten, pOverlapped);
}

inline BOOL MFile::WriteSz(LPCTSTR psz,
    LPDWORD pcbWritten, LPOVERLAPPED pOverlapped/* = NULL*/)
{
    return WriteFile(psz, (DWORD)(lstrlen(psz) * sizeof(TCHAR)), pcbWritten, pOverlapped);
}

inline BOOL MFile::CreateFile(LPCTSTR pszFileName,
    DWORD dwDesiredAccess, DWORD dwShareMode,
    LPSECURITY_ATTRIBUTES pSA, DWORD dwCreationDistribution,
    DWORD dwFlagsAndAttributes/* = FILE_ATTRIBUTE_NORMAL*/,
    HANDLE hTemplateFile/* = NULL*/)
{
    return Attach(::CreateFile(pszFileName, dwDesiredAccess, dwShareMode,
                  pSA, dwCreationDistribution, dwFlagsAndAttributes, hTemplateFile));
}

inline DWORD MFile::SetFilePointer(
    LONG nDeltaLow,
    PLONG pnDeltaHigh/* = NULL*/,
    DWORD dwOrigin/* = FILE_BEGIN*/)
{
    assert(m_hFile != NULL && m_hFile != INVALID_HANDLE_VALUE);
    return ::SetFilePointer(m_hFile, nDeltaLow, pnDeltaHigh, dwOrigin);
}

inline DWORD MFile::SeekToEnd()
{
    assert(m_hFile != NULL && m_hFile != INVALID_HANDLE_VALUE);
    return SetFilePointer(0, NULL, FILE_END);
}

inline VOID MFile::SeekToBegin()
{
    assert(m_hFile != NULL && m_hFile != INVALID_HANDLE_VALUE);
    SetFilePointer(0, NULL, FILE_BEGIN);
}

inline DWORD MFile::GetFileSize(LPDWORD pdwHighPart/* = NULL*/) const
{
    assert(m_hFile != NULL && m_hFile != INVALID_HANDLE_VALUE);
    return ::GetFileSize(m_hFile, pdwHighPart);
}

inline DWORDLONG MFile::GetFileSize64() const
{
    assert(m_hFile != NULL && m_hFile != INVALID_HANDLE_VALUE);
    DWORD dwLow, dwHigh;
    dwLow = ::GetFileSize(m_hFile, &dwHigh);
    if (dwLow == 0xFFFFFFFF && ::GetLastError() != NO_ERROR)
        return 0;
    else
        return MAKELONGLONG(dwLow, dwHigh);
}

inline BOOL MFile::SetEndOfFile()
{
    assert(m_hFile != NULL && m_hFile != INVALID_HANDLE_VALUE);
    return ::SetEndOfFile(m_hFile);
}

inline BOOL MFile::FlushFileBuffers()
{
    assert(m_hFile != NULL && m_hFile != INVALID_HANDLE_VALUE);
    return ::FlushFileBuffers(m_hFile);
}

inline BOOL MFile::WriteSzA(LPCSTR psz)
{
    assert(psz);
    INT cb = lstrlenA(psz);
    return WriteBinary(psz, (DWORD) cb);
}

inline BOOL MFile::WriteSzW(LPCWSTR psz)
{
    assert(psz);
    INT cb = lstrlenW(psz) * sizeof(WCHAR);
    return WriteBinary(psz, (DWORD) cb);
}

inline BOOL MFile::WriteSz(LPCTSTR psz)
{
    assert(psz);
    INT cb = lstrlen(psz) * sizeof(TCHAR);
    return WriteBinary(psz, (DWORD) cb);
}

inline BOOL MFile::GetFileTime(
    LPFILETIME pftCreate/* = NULL*/,
    LPFILETIME pftLastAccess/* = NULL*/,
    LPFILETIME pftLastWrite/* = NULL*/) const
{
    assert(m_hFile != NULL && m_hFile != INVALID_HANDLE_VALUE);
    return ::GetFileTime(m_hFile, pftCreate, pftLastAccess, pftLastWrite);
}

inline DWORD MFile::GetFileType() const
{
    assert(m_hFile != NULL && m_hFile != INVALID_HANDLE_VALUE);
    return ::GetFileType(m_hFile);
}

inline BOOL MFile::GetFileInformationByHandle(LPBY_HANDLE_FILE_INFORMATION info)
{
    assert(m_hFile != NULL && m_hFile != INVALID_HANDLE_VALUE);
    return ::GetFileInformationByHandle(m_hFile, info);
}

inline BOOL MFile::LockFile(DWORD dwFileOffsetLow, DWORD dwFileOffsetHigh,
    DWORD dwNumberOfBytesToLockLow, DWORD dwNumberOfBytesToLockHigh)
{
    assert(m_hFile != NULL && m_hFile != INVALID_HANDLE_VALUE);
    return ::LockFile(m_hFile, dwFileOffsetLow, dwFileOffsetHigh,
        dwNumberOfBytesToLockLow, dwNumberOfBytesToLockHigh);
}

inline BOOL MFile::LockFile(DWORDLONG dwlFileOffset, DWORDLONG dwlNumberOfBytesToLock)
{
    return MFile::LockFile(LOLONG(dwlFileOffset), HILONG(dwlFileOffset),
        LOLONG(dwlNumberOfBytesToLock), HILONG(dwlNumberOfBytesToLock));
}

inline BOOL MFile::LockFileEx(DWORD dwFlags, DWORD dwReserved,
    DWORD dwNumberOfBytesToLockLow, DWORD dwNumberOfBytesToLockHigh,
    LPOVERLAPPED lpOverlapped)
{
    assert(m_hFile != NULL && m_hFile != INVALID_HANDLE_VALUE);
    return ::LockFileEx(m_hFile, dwFlags, dwReserved,
        dwNumberOfBytesToLockLow, dwNumberOfBytesToLockHigh, lpOverlapped);
}

inline BOOL MFile::LockFileEx(DWORD dwFlags, DWORD dwReserved,
    DWORDLONG dwlNumberOfBytesToLock, LPOVERLAPPED lpOverlapped)
{
    return MFile::LockFileEx(dwFlags, dwReserved,
        LOLONG(dwlNumberOfBytesToLock), HILONG(dwlNumberOfBytesToLock),
        lpOverlapped);
}

inline BOOL MFile::UnlockFile(DWORD dwFileOffsetLow, DWORD dwFileOffsetHigh,
    DWORD dwNumberOfBytesToUnlockLow, DWORD dwNumberOfBytesToUnlockHigh)
{
    assert(m_hFile != NULL && m_hFile != INVALID_HANDLE_VALUE);
    return ::UnlockFile(m_hFile, dwFileOffsetLow, dwFileOffsetHigh,
        dwNumberOfBytesToUnlockLow, dwNumberOfBytesToUnlockHigh);
}

inline BOOL MFile::UnlockFile(DWORDLONG dwFileOffset, DWORDLONG dwNumberOfBytesToUnlock)
{
    return MFile::UnlockFile(LOLONG(dwFileOffset), HILONG(dwFileOffset),
        LOLONG(dwNumberOfBytesToUnlock), HILONG(dwNumberOfBytesToUnlock));
}

inline BOOL MFile::UnlockFileEx(DWORD dwReserved, DWORD dwNumberOfBytesToUnlockLow,
    DWORD dwNumberOfBytesToUnlockHigh, LPOVERLAPPED lpOverlapped)
{
    assert(m_hFile != NULL && m_hFile != INVALID_HANDLE_VALUE);
    return ::UnlockFileEx(m_hFile, dwReserved, dwNumberOfBytesToUnlockLow,
        dwNumberOfBytesToUnlockHigh, lpOverlapped);
}

inline BOOL MFile::UnlockFileEx(DWORD dwReserved, DWORDLONG dwlNumberOfBytesToUnlock,
    LPOVERLAPPED lpOverlapped)
{
    return MFile::UnlockFileEx(dwReserved, LOLONG(dwlNumberOfBytesToUnlock),
        HILONG(dwlNumberOfBytesToUnlock), lpOverlapped);
}

inline BOOL MFile::ReadFileEx(LPVOID pBuffer, DWORD cbToRead, 
    LPOVERLAPPED pOverlapped, LPOVERLAPPED_COMPLETION_ROUTINE lpCompletionRoutine)
{
    assert(m_hFile != NULL && m_hFile != INVALID_HANDLE_VALUE);
    return ::ReadFileEx(m_hFile, pBuffer, cbToRead, pOverlapped, lpCompletionRoutine);
}

inline BOOL MFile::WriteFileEx(LPCVOID pBuffer, DWORD cbToWrite, 
    LPOVERLAPPED pOverlapped, LPOVERLAPPED_COMPLETION_ROUTINE lpCompletionRoutine)
{
    assert(m_hFile != NULL && m_hFile != INVALID_HANDLE_VALUE);
    return ::WriteFileEx(m_hFile, pBuffer, cbToWrite, pOverlapped, lpCompletionRoutine);
}


inline BOOL MFile::GetStdHandle(DWORD dwSTD_)
{
    return Attach(::GetStdHandle(dwSTD_));
}

inline BOOL MFile::GetStdIn()
{
    return Attach(::GetStdHandle(STD_INPUT_HANDLE));
}

inline BOOL MFile::GetStdOut()
{
    return Attach(::GetStdHandle(STD_OUTPUT_HANDLE));
}

inline BOOL MFile::GetStdErr()
{
    return Attach(::GetStdHandle(STD_ERROR_HANDLE));
}

inline BOOL MFile::SetStdHandle(DWORD dwSTD_) const
{
    return ::SetStdHandle(dwSTD_, m_hFile);
}

inline BOOL MFile::SetStdIn() const
{
    return ::SetStdHandle(STD_INPUT_HANDLE, m_hFile);
}

inline BOOL MFile::SetStdOut() const
{
    return ::SetStdHandle(STD_OUTPUT_HANDLE, m_hFile);
}

inline BOOL MFile::SetStdErr() const
{
    return ::SetStdHandle(STD_ERROR_HANDLE, m_hFile);
}

////////////////////////////////////////////////////////////////////////////

inline BOOL MFile::DuplicateHandle(PHANDLE phFile, BOOL bInherit)
{
    assert(m_hFile != NULL && m_hFile != INVALID_HANDLE_VALUE);
    HANDLE hProcess = ::GetCurrentProcess();
    return ::DuplicateHandle(hProcess, m_hFile, hProcess, phFile, 0,
        bInherit, DUPLICATE_SAME_ACCESS);
}

inline BOOL MFile::DuplicateHandle(
    PHANDLE phFile, BOOL bInherit, DWORD dwDesiredAccess)
{
    assert(m_hFile != NULL && m_hFile != INVALID_HANDLE_VALUE);
    HANDLE hProcess = ::GetCurrentProcess();
    return ::DuplicateHandle(hProcess, m_hFile, hProcess, phFile,
        dwDesiredAccess, bInherit, 0);
}

inline BOOL __cdecl MFile::WriteFormatA(LPCSTR pszFormat, ...)
{
    assert(pszFormat);
    assert(strlen(pszFormat) < 1024);
    va_list argList;
    CHAR sz[1024];
    va_start(argList, pszFormat);
#ifndef NO_STRSAFE
    StringCchVPrintfA(sz, _countof(sz), pszFormat, argList);
#else
    wvsprintfA(sz, pszFormat, argList);
#endif
    BOOL b = WriteSzA(sz);
    va_end(argList);
    return b;
}

inline BOOL __cdecl MFile::WriteFormatW(LPCWSTR pszFormat, ...)
{
    assert(pszFormat);
    assert(wcslen(pszFormat) < 1024);
    va_list argList;
    WCHAR sz[1024];
    va_start(argList, pszFormat);
#ifndef NO_STRSAFE
    StringCchVPrintfW(sz, _countof(sz), pszFormat, argList);
#else
    wvsprintfW(sz, pszFormat, argList);
#endif
    BOOL b = WriteSzW(sz);
    va_end(argList);
    return b;
}

inline BOOL __cdecl MFile::WriteFormat(LPCTSTR pszFormat, ...)
{
    assert(pszFormat);
    assert(lstrlen(pszFormat) < 1024);
    va_list argList;
    TCHAR sz[1024];
    va_start(argList, pszFormat);
#ifndef NO_STRSAFE
    StringCchVPrintf(sz, _countof(sz), pszFormat, argList);
#else
    wvsprintf(sz, pszFormat, argList);
#endif
    BOOL b = WriteSz(sz);
    va_end(argList);
    return b;
}

inline BOOL MFile::OpenFileForAppend(
    LPCTSTR pszFileName, DWORD dwFILE_SHARE_/* = FILE_SHARE_READ*/)
{
    assert(pszFileName);
    BOOL bExisted = (::GetFileAttributes(pszFileName) != 0xFFFFFFFF);
    if (!MFile::CreateFile(pszFileName, GENERIC_READ | GENERIC_WRITE,
        dwFILE_SHARE_, NULL, OPEN_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL))
        return FALSE;
    if (SetFilePointer(0, NULL, FILE_END) == 0xFFFFFFFF)
    {
        assert(false);
        CloseHandle();
        if (!bExisted)
            ::DeleteFile(pszFileName);
        return FALSE;
    }
    return TRUE;
}

inline BOOL MFile::WriteBinary(LPCVOID pv, DWORD cb)
{
    assert(pv || cb == 0);
    const BYTE *pb = reinterpret_cast<const BYTE *>(pv);
    DWORD cbWritten;
    while (cb != 0)
    {
        if (WriteFile(pb, cb, &cbWritten))
        {
            cb -= cbWritten;
            pb += cbWritten;
        }
        else
            break;
    }
    return (cb == 0);
}

inline BOOL MFile::ReadAll(MStringA& data)
{
    DWORD cbRead;
    CHAR szBuf[1024];

    while (ReadFile(szBuf, sizeof(szBuf), &cbRead) && cbRead)
    {
        data.append(szBuf, cbRead);
    }

    return TRUE;
}

inline BOOL MFile::ReadAll(MStringA& data, DWORD dwTimeout)
{
    DWORD cbRead, dwTick = GetTickCount();
    CHAR szBuf[1024];

    while (ReadFile(szBuf, sizeof(szBuf), &cbRead) && cbRead)
    {
        if (GetTickCount() - dwTick >= dwTimeout)
            return FALSE;

        data.append(szBuf, cbRead);
    }

    return TRUE;
}

inline /*static*/ HANDLE MFile::CloneHandleDx(HANDLE hFile)
{
    if (hFile == INVALID_HANDLE_VALUE || hFile == NULL)
        return INVALID_HANDLE_VALUE;

    HANDLE hProcess = ::GetCurrentProcess();
    HANDLE hDup = INVALID_HANDLE_VALUE;
    ::DuplicateHandle(hProcess, hFile, hProcess, &hDup, 0,
                      FALSE, DUPLICATE_SAME_ACCESS);
    return hDup;
}

////////////////////////////////////////////////////////////////////////////

#endif  // ndef MZC4_MFILE_HPP_

```

`src/MFontsDlg.hpp`:

```hpp
// MFontsDlg.hpp --- font settings dialog
//////////////////////////////////////////////////////////////////////////////
// RisohEditor --- Another free Win32 resource editor
// Copyright (C) 2017-2018 Katayama Hirofumi MZ <katayama.hirofumi.mz@gmail.com>
// 
// This program is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
// 
// This program is distributed in the hope that it will be useful, 
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
// 
// You should have received a copy of the GNU General Public License
// along with this program.  If not, see <http://www.gnu.org/licenses/>.
//////////////////////////////////////////////////////////////////////////////

#pragma once

#include "resource.h"
#include "MHyperLinkCtrl.hpp"
#include "MString.hpp"
#include <commdlg.h>

class MFontsDlg;

//////////////////////////////////////////////////////////////////////////////

class MFontsDlg : public MDialogBase
{
public:
    HFONT m_hSrcFont;
    HFONT m_hBinFont;

    MFontsDlg() : MDialogBase(IDD_FONTS), m_hSrcFont(NULL), m_hBinFont(NULL)
    {
    }

    virtual ~MFontsDlg()
    {
        DestroySrcFont();
        DestroyBinFont();
    }

    HFONT DetachSrcFont()
    {
        HFONT hFont = m_hSrcFont;
        m_hSrcFont = NULL;
        return hFont;
    }
    HFONT DetachBinFont()
    {
        HFONT hFont = m_hBinFont;
        m_hBinFont = NULL;
        return hFont;
    }

    void DestroySrcFont()
    {
        if (m_hSrcFont)
        {
            DeleteObject(m_hSrcFont);
            m_hSrcFont = NULL;
        }
    }
    void DestroyBinFont()
    {
        if (m_hBinFont)
        {
            DeleteObject(m_hBinFont);
            m_hBinFont = NULL;
        }
    }

    BOOL OnInitDialog(HWND hwnd, HWND hwndFocus, LPARAM lParam)
    {
        MString str;

        str = g_settings.strSrcFont;
        str += L", ";
        str += mstr_dec_short(g_settings.nSrcFontSize);
        str += L"pt";
        SetDlgItemText(hwnd, edt1, str.c_str());
        m_hSrcFont = CreateMyFont(g_settings.strSrcFont.c_str(), g_settings.nSrcFontSize);
        SetWindowFont(GetDlgItem(hwnd, stc1), m_hSrcFont, TRUE);

        str = g_settings.strBinFont;
        str += L", ";
        str += mstr_dec_short(g_settings.nBinFontSize);
        str += L"pt";
        SetDlgItemText(hwnd, edt2, str.c_str());
        m_hBinFont = CreateMyFont(g_settings.strBinFont.c_str(), g_settings.nBinFontSize);
        SetWindowFont(GetDlgItem(hwnd, stc2), m_hBinFont, TRUE);

        CenterWindowDx();
        return TRUE;
    }

    void OnOK(HWND hwnd)
    {
        WCHAR szText1[128], szText2[128];

        GetDlgItemText(hwnd, edt1, szText1, _countof(szText1));
        GetDlgItemText(hwnd, edt2, szText2, _countof(szText2));

        MString str1 = szText1;
        MString str2 = szText2;
        mstr_trim(str1);
        mstr_trim(str2);

        size_t k1 = str1.find(L", ");
        size_t k2 = str2.find(L", ");
        if (k1 == MString::npos || k2 == MString::npos)
        {
            return;
        }

        g_settings.strSrcFont = str1.substr(0, k1);
        g_settings.nSrcFontSize = mstr_parse_int(str1.substr(k1 + 2).c_str());
        DestroySrcFont();
        m_hSrcFont = CreateMyFont(g_settings.strSrcFont.c_str(), g_settings.nSrcFontSize);

        g_settings.strBinFont = str2.substr(0, k2);
        g_settings.nBinFontSize = mstr_parse_int(str2.substr(k2 + 2).c_str());
        DestroyBinFont();
        m_hBinFont = CreateMyFont(g_settings.strBinFont.c_str(), g_settings.nBinFontSize);

        EndDialog(IDOK);
    }

    HFONT CreateMyFont(const TCHAR *pszName, INT nPointSize)
    {
        HFONT hFont = NULL;
        LOGFONT lf;
        ZeroMemory(&lf, sizeof(lf));
        if (HDC hDC = CreateCompatibleDC(NULL))
        {
            lf.lfHeight = -MulDiv(nPointSize, GetDeviceCaps(hDC, LOGPIXELSY), 72);
            StringCchCopy(lf.lfFaceName, _countof(lf.lfFaceName), pszName);
            hFont = CreateFontIndirect(&lf);
            DeleteDC(hDC);
        }
        return hFont;
    }

    void OnPsh1(HWND hwnd)
    {
        WCHAR szText1[128];
        GetDlgItemText(hwnd, edt1, szText1, _countof(szText1));
        MString str1 = szText1;
        mstr_trim(str1);
        size_t k1 = str1.find(L", ");

        LOGFONT lf;
        ZeroMemory(&lf, sizeof(lf));

        if (k1 != MString::npos)
        {
            StringCchCopy(lf.lfFaceName, _countof(lf.lfFaceName), str1.substr(0, k1).c_str());
            INT nPointSize = mstr_parse_int(str1.substr(k1 + 2).c_str());

            HDC hDC = CreateCompatibleDC(NULL);
            lf.lfHeight = -MulDiv(nPointSize, GetDeviceCaps(hDC, LOGPIXELSY), 72);
            DeleteDC(hDC);
        }

        CHOOSEFONT cf;
        ZeroMemory(&cf, sizeof(cf));
        cf.lStructSize = sizeof(cf);
        cf.hwndOwner = hwnd;
        cf.lpLogFont = &lf;
        cf.Flags = CF_INITTOLOGFONTSTRUCT | CF_NOSCRIPTSEL | CF_NOVERTFONTS | CF_SCREENFONTS;
        if (ChooseFont(&cf))
        {
            INT nPointSize = (cf.iPointSize + 5) / 10;

            str1 = lf.lfFaceName;
            str1 += L", ";
            str1 += mstr_dec_short(nPointSize);
            str1 += L"pt";
            SetDlgItemText(hwnd, edt1, str1.c_str());

            DestroySrcFont();
            m_hSrcFont = CreateMyFont(lf.lfFaceName, nPointSize);

            SetWindowFont(GetDlgItem(hwnd, stc1), m_hSrcFont, TRUE);
        }
    }

    void OnPsh2(HWND hwnd)
    {
        WCHAR szText2[128];
        GetDlgItemText(hwnd, edt2, szText2, _countof(szText2));
        MString str2 = szText2;
        mstr_trim(str2);
        size_t k2 = str2.find(L", ");

        LOGFONT lf;
        ZeroMemory(&lf, sizeof(lf));

        if (k2 != MString::npos)
        {
            StringCchCopy(lf.lfFaceName, _countof(lf.lfFaceName), str2.substr(0, k2).c_str());
            INT nPointSize = mstr_parse_int(str2.substr(k2 + 2).c_str());

            HDC hDC = CreateCompatibleDC(NULL);
            lf.lfHeight = -MulDiv(nPointSize, GetDeviceCaps(hDC, LOGPIXELSY), 72);
            DeleteDC(hDC);
        }

        CHOOSEFONT cf;
        ZeroMemory(&cf, sizeof(cf));
        cf.lStructSize = sizeof(cf);
        cf.hwndOwner = hwnd;
        cf.lpLogFont = &lf;
        cf.Flags = CF_INITTOLOGFONTSTRUCT | CF_NOSCRIPTSEL | CF_NOVERTFONTS | CF_SCREENFONTS;
        if (ChooseFont(&cf))
        {
            INT nPointSize = (cf.iPointSize + 5) / 10;

            str2 = lf.lfFaceName;
            str2 += L", ";
            str2 += mstr_dec_short(nPointSize);
            str2 += L"pt";
            SetDlgItemText(hwnd, edt2, str2.c_str());

            DestroyBinFont();
            m_hBinFont = CreateMyFont(lf.lfFaceName, nPointSize);

            SetWindowFont(GetDlgItem(hwnd, stc2), m_hBinFont, TRUE);
        }
    }

    void OnCommand(HWND hwnd, int id, HWND hwndCtl, UINT codeNotify)
    {
        switch (id)
        {
        case IDOK:
            OnOK(hwnd);
            break;
        case IDCANCEL:
            EndDialog(IDCANCEL);
            break;
        case psh1:
            OnPsh1(hwnd);
            break;
        case psh2:
            OnPsh2(hwnd);
            break;
        }
    }

    virtual INT_PTR CALLBACK
    DialogProcDx(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
    {
        switch (uMsg)
        {
        HANDLE_MSG(hwnd, WM_INITDIALOG, OnInitDialog);
        HANDLE_MSG(hwnd, WM_COMMAND, OnCommand);
        default:
            return DefaultProcDx();
        }
    }

protected:
    MHyperLinkCtrl m_hyperlink;
};

```

`src/MHyperLinkCtrl.hpp`:

```hpp
// MHyperLinkCtrl.hpp --- hyper link control
// This file is part of MZC4.  See file "ReadMe.txt" and "License.txt".
//////////////////////////////////////////////////////////////////////////////

#ifndef MZC4_MHYPERLINKCTRL_HPP_
#define MZC4_MHYPERLINKCTRL_HPP_        4   /* Version 4 */

#include "MWindowBase.hpp"

class MHyperLinkCtrl;

//////////////////////////////////////////////////////////////////////////////

class MHyperLinkCtrl : public MWindowBase
{
public:
    MHyperLinkCtrl() :
        m_bGotFocus(FALSE), 
        m_hHandCursor(LoadCursor(NULL, IDC_HAND))
    {
    }

    virtual ~MHyperLinkCtrl()
    {
        DestroyCursor(m_hHandCursor);
    }

    virtual void OnJump(HWND hwnd)
    {
        WPARAM wParam = MAKEWPARAM(GetDlgCtrlID(hwnd), STN_CLICKED);
        LPARAM lParam = (LPARAM)hwnd;
        SendMessage(GetParent(hwnd), WM_COMMAND, wParam, lParam);
    }

    void OnPaint(HWND hwnd)
    {
        ModifyStyleDx(0, SS_NOTIFY | WS_TABSTOP);

        TCHAR szClass[64];
        GetClassName(hwnd, szClass, 64);
        assert(lstrcmpi(szClass, TEXT("STATIC")) == 0);

        PAINTSTRUCT ps;
        if (HDC hDC = BeginPaint(hwnd, &ps))
        {
            HFONT hDefaultFont = (HFONT)SendMessageDx(WM_GETFONT, 0, 0);

            LOGFONT lf;
            GetObject(hDefaultFont, sizeof(lf), &lf);
            lf.lfUnderline = TRUE;

            HFONT hFont = CreateFontIndirect(&lf);
            if (hFont)
            {
                HGDIOBJ hFontOld = SelectObject(hDC, hFont);

                RECT rcWindow, rcClient;
                GetWindowRect(hwnd, &rcWindow);
                GetClientRect(hwnd, &rcClient);

                POINT pt;
                GetCursorPos(&pt);

                if (m_bGotFocus || PtInRect(&rcWindow, pt))
                {
                    SetTextColor(hDC, RGB(255, 0, 0));
                    SetBkColor(hDC, RGB(255, 255, 0));
                }
                else
                {
                    SetTextColor(hDC, RGB(0, 0, 255));
                    SetBkColor(hDC, GetSysColor(COLOR_3DFACE));
                }
                SetBkMode(hDC, OPAQUE);

                FillRect(hDC, &rcClient, (HBRUSH)(COLOR_3DFACE + 1));

                UINT uFormat = DT_NOPREFIX;
                DWORD style = GetStyleDx();
                if (style & SS_CENTER)
                    uFormat |= DT_CENTER;
                if (style & SS_RIGHT)
                    uFormat |= DT_RIGHT;
                if (style & SS_CENTERIMAGE)
                    uFormat |= DT_VCENTER | DT_SINGLELINE;

                MString text = GetWindowText();
                DrawText(hDC, text.c_str(), int(text.size()), &rcClient, uFormat);

                if (m_bGotFocus)
                {
                    InflateRect(&rcClient, -1, -1);
                    DrawFocusRect(hDC, &rcClient);
                }

                SelectObject(hDC, hFontOld);
                DeleteObject(hFont);
            }

            EndPaint(hwnd, &ps);
        }
    }

    void OnMouseMove(HWND hwnd, int x, int y, UINT keyFlags)
    {
        InvalidateRect(hwnd, NULL, TRUE);
        SetTimer(hwnd, 999, 100, NULL);
        SetCursor(m_hHandCursor);
    }

    void OnTimer(HWND hwnd, UINT id)
    {
        RECT rc;
        GetWindowRect(hwnd, &rc);

        POINT pt;
        GetCursorPos(&pt);

        if (!PtInRect(&rc, pt))
        {
            InvalidateRect(hwnd, NULL, TRUE);
            KillTimer(hwnd, 999);
            SetCursor(LoadCursor(NULL, IDC_ARROW));
        }
    }

    void OnSetFocus(HWND hwnd, HWND hwndOldFocus)
    {
        m_bGotFocus = TRUE;
        InvalidateRect(hwnd, NULL, TRUE);
    }

    void OnKillFocus(HWND hwnd, HWND hwndNewFocus)
    {
        m_bGotFocus = FALSE;
        InvalidateRect(hwnd, NULL, TRUE);
    }

    void OnKey(HWND hwnd, UINT vk, BOOL fDown, int cRepeat, UINT flags)
    {
        if (vk == VK_SPACE)
        {
            OnJump(hwnd);
        }
    }

    void OnLButtonUp(HWND hwnd, int x, int y, UINT keyFlags)
    {
        OnJump(hwnd);
    }

    virtual LRESULT CALLBACK
    WindowProcDx(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
    {
        switch (uMsg)
        {
        HANDLE_MSG(hwnd, WM_PAINT, OnPaint);
        HANDLE_MSG(hwnd, WM_MOUSEMOVE, OnMouseMove);
        HANDLE_MSG(hwnd, WM_TIMER, OnTimer);
        HANDLE_MSG(hwnd, WM_SETFOCUS, OnSetFocus);
        HANDLE_MSG(hwnd, WM_KILLFOCUS, OnKillFocus);
        HANDLE_MSG(hwnd, WM_KEYDOWN, OnKey);
        HANDLE_MSG(hwnd, WM_LBUTTONUP, OnLButtonUp);
        default:
            return DefaultProcDx();
        }
    }

protected:
    BOOL m_bGotFocus;
    HCURSOR m_hHandCursor;
};

//////////////////////////////////////////////////////////////////////////////

#endif  // ndef MZC4_MHYPERLINKCTRL_HPP_

```

`src/MIDListDlg.hpp`:

```hpp
// MIDListDlg.hpp --- "ID List" Dialog
//////////////////////////////////////////////////////////////////////////////
// RisohEditor --- Another free Win32 resource editor
// Copyright (C) 2017-2018 Katayama Hirofumi MZ <katayama.hirofumi.mz@gmail.com>
// 
// This program is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
// 
// This program is distributed in the hope that it will be useful, 
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
// 
// You should have received a copy of the GNU General Public License
// along with this program.  If not, see <http://www.gnu.org/licenses/>.
//////////////////////////////////////////////////////////////////////////////

#pragma once

#include "resource.h"
#include "MWindowBase.hpp"
#include "MTextToText.hpp"
#include "MIdOrString.hpp"
#include "MAddResIDDlg.hpp"
#include "MModifyResIDDlg.hpp"
#include "MResizable.hpp"
#include "Common.hpp"

class MSubclassedListView;
class MIDListDlg;

#define MYWM_IDJUMPBANG (WM_USER + 238)

//////////////////////////////////////////////////////////////////////////////

// Let the listview subclassed to get Enter key
class MSubclassedListView : public MWindowBase
{
public:
    virtual LRESULT CALLBACK
    WindowProcDx(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
    {
        if (uMsg == WM_GETDLGCODE)
        {
            LPMSG pMsg = (LPMSG)lParam;
            if (pMsg && pMsg->message == WM_KEYDOWN && pMsg->wParam == VK_RETURN)
            {
                INT iItem = ListView_GetNextItem(m_hwnd, -1, LVNI_ALL | LVNI_SELECTED);
                TCHAR szText[128];
                ListView_GetItemText(m_hwnd, iItem, 2, szText, _countof(szText));
                if (szText[0] != TEXT('L') && szText[0] != TEXT('"'))
                {
                    SendMessage(GetParent(hwnd), WM_COMMAND, ID_MODIFYRESID, (LPARAM)hwnd);
                }
            }
        }
        return DefaultProcDx();
    }
};

class MIDListDlg : public MDialogBase
{
public:
    typedef std::map<MString, MString>      assoc_map_type;
    typedef std::map<MStringA, MStringA>    id_map_type;
    HWND m_hMainWnd;
    LPWSTR m_pszResH;
    INT m_nBase;
    HWND m_hCmb1;
    HWND m_hLst1;
    BOOL m_bChanging;
    HICON m_hIconDiamond;
    MSubclassedListView m_lv;
    MResizable m_resizable;

    MIDListDlg()
        : MDialogBase(IDD_IDLIST), m_hMainWnd(NULL), m_pszResH(NULL),
          m_nBase(10), m_hLst1(NULL), m_bChanging(FALSE)
    {
        m_hIconDiamond = LoadSmallIconDx(IDI_DIAMOND);
    }

    ~MIDListDlg()
    {
        DestroyIcon(m_hIconDiamond);
    }

    static int CALLBACK
    CompareFunc(LPARAM lParam1, LPARAM lParam2, LPARAM lParamSort)
    {
        MIDListDlg *this_ = (MIDListDlg *)lParamSort;
        HWND m_hLst1 = this_->m_hLst1;

        LV_FINDINFO find;

        ZeroMemory(&find, sizeof(find));
        find.flags = LVFI_PARAM;
        find.lParam = lParam1;
        INT i1 = ListView_FindItem(m_hLst1, -1, &find);

        ZeroMemory(&find, sizeof(find));
        find.flags = LVFI_PARAM;
        find.lParam = lParam2;
        INT i2 = ListView_FindItem(m_hLst1, -1, &find);

        TCHAR sz1[64], sz2[64];
        if (i1 != -1 && i2 != -1)
        {
            ListView_GetItemText(m_hLst1, i1, 1, sz1, _countof(sz1));
            ListView_GetItemText(m_hLst1, i2, 1, sz2, _countof(sz2));
            int cmp = lstrcmp(sz1, sz2);
            if (cmp != 0)
                return cmp;

            ListView_GetItemText(m_hLst1, i1, 2, sz1, _countof(sz1));
            ListView_GetItemText(m_hLst1, i2, 2, sz2, _countof(sz2));
            MIdOrString id1(sz1);
            MIdOrString id2(sz2);
            if (id1 < id2)
                return -1;
            if (id1 > id2)
                return 1;

            ListView_GetItemText(m_hLst1, i1, 0, sz1, _countof(sz1));
            ListView_GetItemText(m_hLst1, i2, 0, sz2, _countof(sz2));
            cmp = lstrcmp(sz1, sz2);
            if (cmp != 0)
                return cmp;
        }
        return 0;
    }

    void OnCmb1(HWND hwnd)
    {
        INT iItem = ComboBox_GetCurSel(m_hCmb1);
        TCHAR szText[256];
        ComboBox_GetLBText(m_hCmb1, iItem, szText);
        SetItems(szText);
    }

    void SetItem(LPCTSTR pszIDType, const MStringA& first, const MStringA& second, const EntryBase *entry = NULL)
    {
        if (entry && entry->m_et == ET_LANG)
        {
            if (entry->m_type == RT_ICON || entry->m_type == RT_CURSOR ||
                entry->m_type == RT_STRING || entry->m_type == RT_MESSAGETABLE)
            {
                // ignore
                return;
            }
        }

        LV_ITEM item;

        MString text1 = MAnsiToText(CP_ACP, first.c_str()).c_str();
        MString text2 = GetAssoc(text1);
        MString text3 = MAnsiToText(CP_ACP, second.c_str()).c_str();
        if (text2.empty() || text2 == L"Resource.ID" || text2 == L"Unknown.ID")
        {
            if (entry)
            {
                auto nIDTYPE_ = g_db.IDTypeFromResType(entry->m_type);
                if (nIDTYPE_ != IDTYPE_UNKNOWN)
                {
                    text2 = g_db.GetName(L"RESOURCE.ID.TYPE", nIDTYPE_);
                }
                else
                {
                    if (entry->m_type.is_int())
                    {
                        text2 = g_db.GetName(L"RESOURCE", entry->m_type.m_id);
                        if (text2.empty())
                        {
                            if (m_nBase == 10)
                                text2 = mstr_dec(entry->m_type.m_id);
                            else if (m_nBase == 16)
                                text2 = mstr_hex(entry->m_type.m_id);
                            else
                                assert(0);
                        }
                    }
                    else
                    {
                        text2 = entry->m_type.c_str();
                    }
                }
            }
        }
        if (text2.empty())
            text2 = L"Unknown.ID";
        if (text2 == L"Resource.ID")
            return;

        if (pszIDType && text2.find(pszIDType) == MString::npos &&
            lstrcmp(pszIDType, LoadStringDx(IDS_ALL)) != 0)
        {
            return;
        }

        INT iItem = ListView_GetItemCount(m_hLst1);

        for (INT i = 0; i < iItem; ++i)
        {
            WCHAR szText[64];
            ZeroMemory(&item, sizeof(item));
            item.iItem = i;
            item.iSubItem = 0;
            item.mask = LVIF_TEXT;
            item.pszText = szText;
            item.cchTextMax = _countof(szText);
            ListView_GetItem(m_hLst1, &item);

            if (lstrcmpW(item.pszText, text1.c_str()) != 0)
                continue;

            item.iSubItem = 1;
            ListView_GetItem(m_hLst1, &item);
            if (wcsstr(item.pszText, text2.c_str()) == NULL)
                continue;

            item.iSubItem = 2;
            ListView_GetItem(m_hLst1, &item);
            if (lstrcmpW(item.pszText, text3.c_str()) != 0)
                continue;

            return; // there is the same item
        }

        ZeroMemory(&item, sizeof(item));
        item.iItem = iItem;
        item.mask = LVIF_TEXT | LVIF_PARAM;
        item.iSubItem = 0;
        item.pszText = &text1[0];
        item.lParam = iItem;
        ListView_InsertItem(m_hLst1, &item);

        ZeroMemory(&item, sizeof(item));
        item.iItem = iItem;
        item.mask = LVIF_TEXT;
        item.iSubItem = 1;
        item.pszText = &text2[0];
        ListView_SetItem(m_hLst1, &item);

        if (text3[0] != TEXT('"') && text3[0] != TEXT('L'))
        {
            int value = mstr_parse_int(text3.c_str(), true);

            TCHAR szText[32];
            if (m_nBase == 10)
                StringCchPrintf(szText, _countof(szText), TEXT("%d"), value);
            else if (m_nBase == 16)
                StringCchPrintf(szText, _countof(szText), TEXT("0x%X"), value);
            else
                assert(0);

            text3 = szText;
        }

        ZeroMemory(&item, sizeof(item));
        item.iItem = iItem;
        item.mask = LVIF_TEXT;
        item.iSubItem = 2;
        item.pszText = &text3[0];
        ListView_SetItem(m_hLst1, &item);
    }

    MStringW GetItemText(INT i)
    {
        MStringW ret;

        WCHAR szText[64];
        LV_ITEM item;
        ZeroMemory(&item, sizeof(item));
        item.iItem = i;
        item.iSubItem = 0;
        item.mask = LVIF_TEXT;
        item.pszText = szText;
        item.cchTextMax = _countof(szText);
        ListView_GetItem(m_hLst1, &item);

        ret = item.pszText;
        ret += L"\x7F";

        item.iSubItem = 1;
        ListView_GetItem(m_hLst1, &item);

        ret += item.pszText;
        ret += L"\x7F";

        item.iSubItem = 2;
        ListView_GetItem(m_hLst1, &item);

        ret += item.pszText;
        return ret;
    }

    void MakeUnique()
    {
        WCHAR szText[128];
        INT k = ComboBox_GetCurSel(m_hCmb1);
        ComboBox_GetLBText(m_hCmb1, k, szText);
        MStringW strText = szText;

        BOOL bAll = (strText == LoadStringDx(IDS_ALL));

        INT iItem = ListView_GetItemCount(m_hLst1);
        for (INT i = 0; i < iItem; ++i)
        {
            MStringW str = GetItemText(i);
            std::vector<MStringW> vec;
            mstr_split(vec, str, L"\x7F");
            str = vec[1];
            if (!bAll)
            {
                str = strText;
            }
            else
            {
                mstr_split(vec, str, L"/");
                std::sort(vec.begin(), vec.end());
                vec.erase(std::unique(vec.begin(), vec.end()), vec.end());
                str = mstr_join(vec, L"/");
            }

            LV_ITEM item;
            ZeroMemory(&item, sizeof(item));
            item.mask = LVIF_TEXT;
            item.iItem = i;
            item.iSubItem = 1;
            item.pszText = &str[0];
            ListView_SetItem(m_hLst1, &item);
        }
        iItem = ListView_GetItemCount(m_hLst1);
        for (INT i = 0; i < iItem - 1; ++i)
        {
            MStringW str0 = GetItemText(i);
            MStringW str1 = GetItemText(i + 1);
            if (str0 == str1)
            {
                ListView_DeleteItem(m_hLst1, i);
                --i;
                --iItem;
            }
        }

        INT i = ComboBox_FindStringExact(m_hCmb1, -1, L"Resource.ID");
        if (i != CB_ERR)
            ComboBox_DeleteString(m_hCmb1, i);
    }

    void SetItems(LPCTSTR pszIDType = NULL)
    {
        ListView_DeleteAllItems(m_hLst1);

        if (!g_settings.bHideID)
        {
            for (auto& pair : g_settings.id_map)
            {
                SetItem(pszIDType, pair.first, pair.second);
            }
        }

        EntrySet found;
        g_res.search(found, ET_LANG);

        for (auto entry : found)
        {
            auto nIDTYPE_ = g_db.IDTypeFromResType(entry->m_type);
            if (entry->m_name.m_id)
            {
                auto strName = g_db.GetNameOfIDTypeValue(nIDTYPE_, entry->m_name.m_id);
                if (strName.empty() || g_settings.bHideID)
                {
                    if (m_nBase == 10)
                        strName = mstr_dec(entry->m_name.m_id);
                    else if (m_nBase == 16)
                        strName = mstr_hex(entry->m_name.m_id);
                    else
                        assert(0);
                }

                auto strValue = mstr_dec(entry->m_name.m_id);
                if (m_nBase == 16)
                    strValue = mstr_hex(entry->m_name.m_id);

                MWideToAnsi strNameA(CP_ACP, strName);
                MWideToAnsi strValueA(CP_ACP, strValue);
                SetItem(pszIDType, strNameA.c_str(), strValueA.c_str(), entry);
            }
            else
            {
                MWideToAnsi strNameA(CP_ACP, entry->m_name.quoted_wstr());
                SetItem(pszIDType, strNameA.c_str(), strNameA.c_str(), entry);
            }
        }

        ListView_SortItems(m_hLst1, CompareFunc, (LPARAM)this);

        if (pszIDType == NULL && !m_bChanging)
        {
            m_bChanging = TRUE;
            if (pszIDType == NULL)
            {
                ComboBox_ResetContent(m_hCmb1);
                ComboBox_AddString(m_hCmb1, LoadStringDx(IDS_ALL));
                INT i, nCount = ListView_GetItemCount(m_hLst1);
                for (i = 0; i < nCount; ++i)
                {
                    TCHAR szText[256];
                    ListView_GetItemText(m_hLst1, i, 1, szText, _countof(szText));
                    std::vector<MString> types;
                    mstr_split(types, szText, TEXT("/"));
                    for (size_t k = 0; k < types.size(); ++k)
                    {
                        INT ret = ComboBox_FindStringExact(m_hCmb1, -1, types[k].c_str());
                        if (ret == CB_ERR)
                        {
                            if (!types[k].empty())
                                ComboBox_AddString(m_hCmb1, types[k].c_str());
                        }
                    }
                }
            }
            if (pszIDType == NULL)
                ComboBox_SelectString(m_hCmb1, -1, LoadStringDx(IDS_ALL));
            m_bChanging = FALSE;
        }

        MakeUnique();
    }

    void OnMeasureItem(HWND hwnd, MEASUREITEMSTRUCT * lpMeasureItem)
    {
        RECT rc;
        SetRect(&rc, 0, 0, 200, 15);
        MapDialogRect(hwnd, &rc);

        lpMeasureItem->itemHeight = rc.bottom - rc.top;

        GetClientRect(hwnd, &rc);
        lpMeasureItem->itemWidth = rc.right - rc.left;
    }

    void OnDrawItem(HWND hwnd, const DRAWITEMSTRUCT * lpDrawItem)
    {
        const INT CX_ICON_SMALL = 16;
        const INT CY_ICON_SMALL = 16;

        RECT rc = lpDrawItem->rcItem;

        SetBkColor(lpDrawItem->hDC, GetSysColor(COLOR_WINDOW));
        FillRect(lpDrawItem->hDC, &rc, (HBRUSH)(COLOR_WINDOW + 1));
        SetTextColor(lpDrawItem->hDC, GetSysColor(COLOR_WINDOWTEXT));

        INT x = 0;
        INT y = ((rc.top + rc.bottom) - CY_ICON_SMALL) / 2 - 1;
        if (lpDrawItem->itemState & ODS_COMBOBOXEDIT)
        {
            x += 3;
        }
        DrawIconEx(lpDrawItem->hDC, x, y, m_hIconDiamond, CX_ICON_SMALL, CY_ICON_SMALL, 0, NULL, DI_NORMAL);

        rc.left += CX_ICON_SMALL;

        SetBkMode(lpDrawItem->hDC, OPAQUE);
        if (lpDrawItem->itemState & ODS_SELECTED)
        {
            SetBkColor(lpDrawItem->hDC, GetSysColor(COLOR_HIGHLIGHT));
            FillRect(lpDrawItem->hDC, &rc, (HBRUSH)(COLOR_HIGHLIGHT + 1));
            SetTextColor(lpDrawItem->hDC, GetSysColor(COLOR_HIGHLIGHTTEXT));
        }

        TCHAR szText[128];
        ComboBox_GetLBText(lpDrawItem->hwndItem, lpDrawItem->itemID, szText);

        InflateRect(&rc, -2, -2);
        DrawText(lpDrawItem->hDC, szText, -1, &rc, 
            DT_SINGLELINE | DT_LEFT | DT_VCENTER | DT_NOPREFIX);
        InflateRect(&rc, 2, 2);

        if (lpDrawItem->itemState & ODS_FOCUS)
        {
            DrawFocusRect(lpDrawItem->hDC, &rc);
        }
    }

    int OnCompareItem(HWND hwnd, const COMPAREITEMSTRUCT * lpCompareItem)
    {
        TCHAR szText1[128], szText2[128];
        ComboBox_GetLBText(lpCompareItem->hwndItem, lpCompareItem->itemID1, szText1);
        ComboBox_GetLBText(lpCompareItem->hwndItem, lpCompareItem->itemID2, szText2);
        return lstrcmpi(szText1, szText2);
    }

    BOOL OnInitDialog(HWND hwnd, HWND hwndFocus, LPARAM lParam)
    {
        m_hCmb1 = GetDlgItem(hwnd, cmb1);
        m_hLst1 = GetDlgItem(hwnd, lst1);

        m_resizable.OnParentCreate(hwnd);

        m_resizable.SetLayoutAnchor(cmb1, mzcLA_TOP_LEFT, mzcLA_TOP_RIGHT);
        m_resizable.SetLayoutAnchor(lst1, mzcLA_TOP_LEFT, mzcLA_BOTTOM_RIGHT);

        ListView_SetExtendedListViewStyle(m_hLst1, LVS_EX_FULLROWSELECT | LVS_EX_INFOTIP);
        m_lv.SubclassDx(m_hLst1);

        LV_COLUMN column;
        ZeroMemory(&column, sizeof(column));

        column.mask = LVCF_FMT | LVCF_SUBITEM | LVCF_TEXT | LVCF_WIDTH;
        column.fmt = LVCFMT_LEFT;
        column.cx = 160;
        column.pszText = LoadStringDx(IDS_NAME);
        column.iSubItem = 0;
        ListView_InsertColumn(m_hLst1, 0, &column);

        column.mask = LVCF_FMT | LVCF_SUBITEM | LVCF_TEXT | LVCF_WIDTH;
        column.fmt = LVCFMT_LEFT;
        column.cx = 120;
        column.pszText = LoadStringDx(IDS_IDTYPE);
        column.iSubItem = 1;
        ListView_InsertColumn(m_hLst1, 1, &column);

        column.mask = LVCF_FMT | LVCF_SUBITEM | LVCF_TEXT | LVCF_WIDTH;
        column.fmt = LVCFMT_LEFT;
        column.cx = 80;
        column.pszText = LoadStringDx(IDS_VALUE);
        column.iSubItem = 2;
        ListView_InsertColumn(m_hLst1, 2, &column);

        if (g_settings.bResumeWindowPos)
        {
            if (g_settings.nIDListLeft != CW_USEDEFAULT)
            {
                POINT pt = { g_settings.nIDListLeft, g_settings.nIDListTop };
                SetWindowPosDx(&pt);
            }
            if (g_settings.nIDListWidth != CW_USEDEFAULT)
            {
                SIZE siz = { g_settings.nIDListWidth, g_settings.nIDListHeight };
                SetWindowPosDx(NULL, &siz);
            }
        }

        SetItems();

        return TRUE;
    }

    void UpdateResHIfAsk()
    {
        if (g_settings.bAskUpdateResH)
            PostMessage(m_hMainWnd, WM_COMMAND, ID_UPDATERESHBANG, 0);
    }

    void OnCommand(HWND hwnd, int id, HWND hwndCtl, UINT codeNotify)
    {
        INT iItem;
        TCHAR szText[64];
        MString str1, str2;
        switch (id)
        {
        case cmb1:
            if (codeNotify == CBN_SELCHANGE && !m_bChanging)
            {
                m_bChanging = TRUE;
                OnCmb1(hwnd);
                m_bChanging = FALSE;
            }
            break;
        case IDCANCEL:
            DestroyWindow(hwnd);
            break;
        case ID_ADDRESID:
            {
                MAddResIDDlg dialog;
                if (dialog.DialogBoxDx(hwnd) == IDOK)
                {
                    ConstantsDB::TableType& table = g_db.m_map[L"RESOURCE.ID"];
                    INT value = mstr_parse_int(dialog.m_str2.c_str());
                    ConstantsDB::EntryType entry(dialog.m_str1, value);
                    table.push_back(entry);

                    MStringA stra1 = MTextToAnsi(CP_ACP, dialog.m_str1).c_str();
                    MStringA stra2 = MTextToAnsi(CP_ACP, dialog.m_str2).c_str();
                    g_settings.id_map.insert(std::make_pair(stra1, stra2));

                    g_settings.added_ids.insert(std::make_pair(stra1, stra2));
                    g_settings.removed_ids.erase(stra1);

                    SetItems();
                    SendMessage(m_hMainWnd, WM_COMMAND, ID_UPDATEID, 0);

                    UpdateResHIfAsk();
                }
            }
            break;
        case ID_MODIFYRESID:
            iItem = ListView_GetNextItem(m_hLst1, -1, LVNI_ALL | LVNI_SELECTED);
            if (iItem == -1)
                break;
            ListView_GetItemText(m_hLst1, iItem, 0, szText, _countof(szText));
            str1 = szText;
            ListView_GetItemText(m_hLst1, iItem, 2, szText, _countof(szText));
            str2 = szText;
            if (szText[0] != TEXT('L') && szText[0] != TEXT('"'))
            {
                MModifyResIDDlg dialog(str1, str2);
                if (dialog.DialogBoxDx(hwnd) == IDOK)
                {
                    ConstantsDB::TableType& table = g_db.m_map[L"RESOURCE.ID"];
                    auto end = table.end();
                    for (auto it = table.begin(); it != end; ++it)
                    {
                        if (it->name == str1)
                        {
                            table.erase(it);
                            break;
                        }
                    }
                    INT value = mstr_parse_int(dialog.m_str2.c_str());
                    ConstantsDB::EntryType entry(dialog.m_str1, value);
                    table.push_back(entry);

                    MStringA stra1old = MTextToAnsi(CP_ACP, str1).c_str();
                    MStringA stra2old = MTextToAnsi(CP_ACP, str2).c_str();
                    MStringA stra1 = MTextToAnsi(CP_ACP, dialog.m_str1).c_str();
                    MStringA stra2 = MTextToAnsi(CP_ACP, dialog.m_str2).c_str();
                    g_settings.id_map.erase(stra1old);
                    g_settings.id_map.insert(std::make_pair(stra1, stra2));
                    g_settings.added_ids.erase(stra1old);
                    g_settings.added_ids.insert(std::make_pair(stra1, stra2));
                    g_settings.removed_ids.erase(stra1old);
                    g_settings.removed_ids.insert(std::make_pair(stra1old, stra2old));

                    ListView_SetItemText(m_hLst1, iItem, 0, &str1[0]);
                    MString assoc = GetAssoc(str1);
                    ListView_SetItemText(m_hLst1, iItem, 1, &assoc[0]);
                    ListView_SetItemText(m_hLst1, iItem, 2, &str2[0]);

                    SetItems();

                    SendMessage(m_hMainWnd, WM_COMMAND, ID_UPDATEID, 0);
                    UpdateResHIfAsk();
                }
            }
            break;
        case ID_DELETERESID:
            for (;;)
            {
                iItem = ListView_GetNextItem(m_hLst1, -1, LVNI_ALL | LVNI_SELECTED);
                if (iItem == -1)
                    break;

                ListView_GetItemText(m_hLst1, iItem, 0, szText, _countof(szText));
                MString str1 = szText;
                MStringA astr1 = MTextToAnsi(CP_ACP, szText).c_str();
                ListView_GetItemText(m_hLst1, iItem, 2, szText, _countof(szText));

                ConstantsDB::TableType& table = g_db.m_map[L"RESOURCE.ID"];
                auto end = table.end();
                for (auto it = table.begin(); it != end; ++it)
                {
                    if (it->name == str1)
                    {
                        table.erase(it);
                        break;
                    }
                }

                g_settings.id_map.erase(astr1);
                if (!g_settings.added_ids.erase(astr1))
                {
                    MStringA astr2 = MTextToAnsi(CP_ACP, szText).c_str();
                    g_settings.removed_ids.insert(std::make_pair(astr1, astr2));
                }

                ListView_DeleteItem(m_hLst1, iItem);
            }
            SendMessage(m_hMainWnd, WM_COMMAND, ID_UPDATEID, 0);
            UpdateResHIfAsk();
            break;
        case ID_COPYRESIDNAME:
            {
                iItem = ListView_GetNextItem(m_hLst1, -1, LVNI_ALL | LVNI_SELECTED);
                if (iItem == -1)
                    break;
                ListView_GetItemText(m_hLst1, iItem, 0, szText, _countof(szText));
                CopyTextDx(hwnd, szText);
            }
            break;
        case ID_COPYRESIDVALUE:
            {
                iItem = ListView_GetNextItem(m_hLst1, -1, LVNI_ALL | LVNI_SELECTED);
                if (iItem == -1)
                    break;
                ListView_GetItemText(m_hLst1, iItem, 2, szText, _countof(szText));
                MString text = szText;
                CopyTextDx(hwnd, text);
            }
            break;
        case ID_COPYIDDEF:
            {
                iItem = ListView_GetNextItem(m_hLst1, -1, LVNI_ALL | LVNI_SELECTED);
                if (iItem == -1)
                    break;
                ListView_GetItemText(m_hLst1, iItem, 0, szText, _countof(szText));
                MString text1 = szText;
                ListView_GetItemText(m_hLst1, iItem, 2, szText, _countof(szText));
                MString text2 = szText;
                MString text = TEXT("#define ");
                text += text1;
                text += TEXT(" ");
                text += text2;
                text += TEXT("\r\n");
                CopyTextDx(hwnd, text);
            }
            break;
        case ID_LOADRESH:
            PostMessage(m_hMainWnd, WM_COMMAND, ID_LOADRESHBANG, 0);
            break;
        case ID_IDJUMP:
            OnIdJump(hwnd);
            break;
        case ID_BASE10:
            {
                m_nBase = 10;
                ComboBox_GetText(m_hCmb1, szText, _countof(szText));
                SetItems(szText);
            }
            break;
        case ID_BASE16:
            {
                m_nBase = 16;
                ComboBox_GetText(m_hCmb1, szText, _countof(szText));
                SetItems(szText);
            }
            break;
        case ID_IDJUMP00:
            OnIdJump(hwnd, 0);
            break;
        case ID_IDJUMP01:
            OnIdJump(hwnd, 1);
            break;
        case ID_IDJUMP02:
            OnIdJump(hwnd, 2);
            break;
        case ID_IDJUMP03:
            OnIdJump(hwnd, 3);
            break;
        case ID_IDJUMP04:
            OnIdJump(hwnd, 4);
            break;
        case ID_IDJUMP05:
            OnIdJump(hwnd, 5);
            break;
        case ID_IDJUMP06:
            OnIdJump(hwnd, 6);
            break;
        case ID_IDJUMP07:
            OnIdJump(hwnd, 7);
            break;
        case ID_IDJUMP08:
            OnIdJump(hwnd, 8);
            break;
        case ID_IDJUMP09:
            OnIdJump(hwnd, 9);
            break;
        }
    }

    void OnIdJump(HWND hwnd, INT nIndex = -1)
    {
        INT iItem = ListView_GetNextItem(m_hLst1, -1, LVNI_ALL | LVNI_SELECTED);
        if (iItem == -1)
            return;

        TCHAR szText[128];
        ListView_GetItemText(m_hLst1, iItem, 1, szText, _countof(szText));
        MString str = szText;
        if (str.find(TEXT('/')) == MString::npos || nIndex == 0)
        {
            PostMessage(m_hMainWnd, MYWM_IDJUMPBANG, iItem, 0);
            return;
        }

        std::vector<MString> vecItems;
        mstr_split(vecItems, str, TEXT("/"));

        if (nIndex == -1)
        {
            HMENU hMenu = CreatePopupMenu();
            const size_t max_count = 10;
            for (size_t i = 0; i < vecItems.size() && i < max_count; ++i)
            {
                INT k = ID_IDJUMP00 + INT(i);
                InsertMenu(hMenu, 0xFFFFFFFF, MF_BYPOSITION | MF_STRING | MF_ENABLED, 
                    k, vecItems[i].c_str());
            }

            // get the cursor position
            POINT pt;
            GetCursorPos(&pt);

            // See: https://msdn.microsoft.com/en-us/library/windows/desktop/ms648002.aspx
            SetForegroundWindow(hwnd);

            TrackPopupMenu(hMenu, TPM_LEFTALIGN | TPM_RIGHTBUTTON, 
                pt.x, pt.y, 0, hwnd, NULL);

            // See: https://msdn.microsoft.com/en-us/library/windows/desktop/ms648002.aspx
            PostMessage(hwnd, WM_NULL, 0, 0);

            // destroy the menu
            DestroyMenu(hMenu);
        }
        else
        {
            PostMessage(m_hMainWnd, MYWM_IDJUMPBANG, iItem, nIndex);
        }
    }

    virtual INT_PTR CALLBACK
    DialogProcDx(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
    {
        switch (uMsg)
        {
        HANDLE_MSG(hwnd, WM_INITDIALOG, OnInitDialog);
        HANDLE_MSG(hwnd, WM_COMMAND, OnCommand);
        HANDLE_MSG(hwnd, WM_MOVE, OnMove);
        HANDLE_MSG(hwnd, WM_SIZE, OnSize);
        HANDLE_MSG(hwnd, WM_CONTEXTMENU, OnContextMenu);
        HANDLE_MSG(hwnd, WM_NOTIFY, OnNotify);
        HANDLE_MSG(hwnd, WM_INITMENUPOPUP, OnInitMenuPopup);
        HANDLE_MSG(hwnd, WM_MEASUREITEM, OnMeasureItem);
        HANDLE_MSG(hwnd, WM_DRAWITEM, OnDrawItem);
        HANDLE_MSG(hwnd, WM_COMPAREITEM, OnCompareItem);
        default:
            return DefaultProcDx();
        }
    }

    void OnInitMenuPopup(HWND hwnd, HMENU hMenu, UINT item, BOOL fSystemMenu)
    {
        if (m_nBase == 10)
        {
            CheckMenuRadioItem(hMenu, ID_BASE10, ID_BASE16, 
                ID_BASE10, MF_BYCOMMAND);
        }
        else if (m_nBase == 16)
        {
            CheckMenuRadioItem(hMenu, ID_BASE10, ID_BASE16, 
                ID_BASE16, MF_BYCOMMAND);
        }
        INT iItem = ListView_GetNextItem(m_hLst1, -1, LVNI_ALL | LVNI_SELECTED);

        TCHAR szText[128];
        ListView_GetItemText(m_hLst1, iItem, 2, szText, _countof(szText));
        if (iItem == -1 || szText[0] == TEXT('L') || szText[0] == TEXT('"'))
        {
            EnableMenuItem(hMenu, ID_MODIFYRESID, MF_GRAYED);
            EnableMenuItem(hMenu, ID_COPYRESIDNAME, MF_GRAYED);
            EnableMenuItem(hMenu, ID_COPYRESIDVALUE, MF_GRAYED);
            EnableMenuItem(hMenu, ID_COPYIDDEF, MF_GRAYED);
            EnableMenuItem(hMenu, ID_DELETERESID, MF_GRAYED);
        }
        else
        {
            ListView_GetItemText(m_hLst1, iItem, 0, szText, _countof(szText));
            if (mchr_is_digit(szText[0]) || szText[0] == L'-' ||
                lstrcmpW(szText, L"IDC_STATIC") == 0)
            {
                EnableMenuItem(hMenu, ID_MODIFYRESID, MF_GRAYED);
                EnableMenuItem(hMenu, ID_COPYRESIDNAME, MF_ENABLED);
                EnableMenuItem(hMenu, ID_COPYRESIDVALUE, MF_ENABLED);
                EnableMenuItem(hMenu, ID_COPYIDDEF, MF_ENABLED);
                EnableMenuItem(hMenu, ID_DELETERESID, MF_GRAYED);
            }
            else
            {
                EnableMenuItem(hMenu, ID_MODIFYRESID, MF_ENABLED);
                EnableMenuItem(hMenu, ID_COPYRESIDNAME, MF_ENABLED);
                EnableMenuItem(hMenu, ID_COPYRESIDVALUE, MF_ENABLED);
                EnableMenuItem(hMenu, ID_COPYIDDEF, MF_ENABLED);
                EnableMenuItem(hMenu, ID_DELETERESID, MF_ENABLED);
            }
        }
    }

    void OnMove(HWND hwnd, int x, int y)
    {
        assert(m_hwnd);

        if (!IsZoomed(hwnd) && !IsIconic(hwnd))
        {
            RECT rc;
            GetWindowRect(hwnd, &rc);
            g_settings.nIDListLeft = rc.left;
            g_settings.nIDListTop = rc.top;
        }
    }

    void OnSize(HWND hwnd, UINT state, int cx, int cy)
    {
        assert(m_hwnd);

        if (!IsZoomed(hwnd) && !IsIconic(hwnd))
        {
            RECT rc;
            GetWindowRect(hwnd, &rc);
            g_settings.nIDListWidth = rc.right - rc.left;
            g_settings.nIDListHeight = rc.bottom - rc.top;
        }

        m_resizable.OnSize();
    }

    void OnContextMenu(HWND hwnd, HWND hwndContext, UINT xPos, UINT yPos)
    {
        if (hwndContext == m_hLst1)
        {
            PopupMenuDx(hwnd, m_hLst1, IDR_POPUPMENUS, 3, xPos, yPos);
        }
    }

    LRESULT OnNotify(HWND hwnd, int idFrom, LPNMHDR pnmhdr)
    {
        if (idFrom == lst1)
        {
            if (pnmhdr->code == NM_DBLCLK)
            {
                PostMessageDx(WM_COMMAND, ID_IDJUMP);
                return 1;
            }
            if (pnmhdr->code == LVN_KEYDOWN)
            {
                LV_KEYDOWN *down = (LV_KEYDOWN *)pnmhdr;
                if (down->wVKey == VK_DELETE)
                {
                    PostMessageDx(WM_COMMAND, ID_DELETERESID);
                    return 1;
                }
                if (down->wVKey == 'C' && GetKeyState(VK_CONTROL) < 0)
                {
                    PostMessageDx(WM_COMMAND, ID_COPYIDDEF);
                    return 1;
                }
            }
            if (pnmhdr->code == LVN_GETINFOTIP)
            {
                NMLVGETINFOTIP *pGetInfoTip = (NMLVGETINFOTIP *)pnmhdr;
                INT iItem = pGetInfoTip->iItem;
                INT iSubItem = pGetInfoTip->iSubItem;
                TCHAR szText[128];
                ListView_GetItemText(m_hLst1, iItem, iSubItem, szText, _countof(szText));
                StringCchCopy(pGetInfoTip->pszText, pGetInfoTip->cchTextMax, szText);
                return 1;
            }
        }
        return 0;
    }
};

```

`src/MIdAssocDlg.hpp`:

```hpp
// MIdAssocDlg.hpp --- "ID Association" Dialog
//////////////////////////////////////////////////////////////////////////////
// RisohEditor --- Another free Win32 resource editor
// Copyright (C) 2017-2018 Katayama Hirofumi MZ <katayama.hirofumi.mz@gmail.com>
// 
// This program is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
// 
// This program is distributed in the hope that it will be useful, 
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
// 
// You should have received a copy of the GNU General Public License
// along with this program.  If not, see <http://www.gnu.org/licenses/>.
//////////////////////////////////////////////////////////////////////////////

#pragma once

#include "MWindowBase.hpp"
#include "MModifyAssocDlg.hpp"
#include "RisohSettings.hpp"

//////////////////////////////////////////////////////////////////////////////

class MIdAssocDlg : public MDialogBase
{
public:
    typedef std::map<MString, MString> map_type;
    HWND m_hLst1;

    MIdAssocDlg() : MDialogBase(IDD_IDASSOC)
    {
    }

    void Lst1_Init(HWND hLst1)
    {
        ListView_DeleteAllItems(hLst1);

        LV_ITEM item;

        INT iItem = 0;
        for (auto& pair : g_settings.assoc_map)
        {
            ZeroMemory(&item, sizeof(item));
            item.iItem = iItem;
            item.mask = LVIF_TEXT;
            item.iSubItem = 0;
            item.pszText = const_cast<LPTSTR>(pair.first.c_str());
            ListView_InsertItem(m_hLst1, &item);

            ZeroMemory(&item, sizeof(item));
            item.iItem = iItem;
            item.mask = LVIF_TEXT;
            item.iSubItem = 1;
            item.pszText = const_cast<LPTSTR>(pair.second.c_str());
            ListView_SetItem(m_hLst1, &item);

            ++iItem;
        }

        UINT state = LVIS_SELECTED | LVIS_FOCUSED;
        ListView_SetItemState(m_hLst1, 0, state, state);
    }

    BOOL OnInitDialog(HWND hwnd, HWND hwndFocus, LPARAM lParam)
    {
        m_hLst1 = GetDlgItem(hwnd, lst1);
        ListView_SetExtendedListViewStyle(m_hLst1, LVS_EX_FULLROWSELECT);

        LV_COLUMN column;
        ZeroMemory(&column, sizeof(column));

        column.mask = LVCF_FMT | LVCF_SUBITEM | LVCF_TEXT | LVCF_WIDTH;
        column.fmt = LVCFMT_LEFT;
        column.cx = 155;
        column.pszText = LoadStringDx(IDS_IDTYPE);
        column.iSubItem = 0;
        ListView_InsertColumn(m_hLst1, 0, &column);

        column.mask = LVCF_FMT | LVCF_SUBITEM | LVCF_TEXT | LVCF_WIDTH;
        column.fmt = LVCFMT_LEFT;
        column.cx = 150;
        column.pszText = LoadStringDx(IDS_IDPREFIX);
        column.iSubItem = 1;
        ListView_InsertColumn(m_hLst1, 1, &column);

        Lst1_Init(m_hLst1);

        CenterWindowDx();
        return TRUE;
    }

    void OnPsh2(HWND hwnd)
    {
        g_settings.ResetAssoc();
        Lst1_Init(m_hLst1);
    }

    void OnPsh1(HWND hwnd)
    {
        INT iItem = ListView_GetNextItem(m_hLst1, -1, LVNI_ALL | LVNI_SELECTED);
        if (iItem == -1)
            return;

        TCHAR szText[64];
        MString str1, str2;

        ListView_GetItemText(m_hLst1, iItem, 0, szText, _countof(szText));
        str1 = szText;

        ListView_GetItemText(m_hLst1, iItem, 1, szText, _countof(szText));
        str2 = szText;

        MModifyAssocDlg dialog(str1, str2);
        if (dialog.DialogBoxDx(hwnd) == IDOK)
        {
            ListView_SetItemText(m_hLst1, iItem, 1, const_cast<LPTSTR>(str2.c_str()));
        }
    }

    void OnOK(HWND hwnd)
    {
        TCHAR szText[64];
        MString str1, str2;

        INT iItem, nCount = ListView_GetItemCount(m_hLst1);
        for (iItem = 0; iItem < nCount; ++iItem)
        {
            ListView_GetItemText(m_hLst1, iItem, 0, szText, _countof(szText));
            str1 = szText;

            ListView_GetItemText(m_hLst1, iItem, 1, szText, _countof(szText));
            str2 = szText;

            g_settings.assoc_map[str1] = str2;
        }

        EndDialog(IDOK);
    }

    void OnCommand(HWND hwnd, int id, HWND hwndCtl, UINT codeNotify)
    {
        switch (id)
        {
        case IDOK:
            OnOK(hwnd);
            break;
        case IDCANCEL:
            EndDialog(IDCANCEL);
            break;
        case psh1:
            OnPsh1(hwnd);
            break;
        case psh2:
            OnPsh2(hwnd);
            break;
        case ID_MODIFYASSOC:
            OnPsh1(hwnd);
            break;
        }
    }

    void OnItemChanged(HWND hwnd)
    {
        INT iItem = ListView_GetNextItem(m_hLst1, -1, LVNI_ALL | LVNI_SELECTED);
        if (iItem == -1)
        {
            EnableWindow(GetDlgItem(hwnd, psh1), FALSE);
        }
        else
        {
            EnableWindow(GetDlgItem(hwnd, psh1), TRUE);
        }
    }

    LRESULT OnNotify(HWND hwnd, int idFrom, LPNMHDR pnmhdr)
    {
        if (pnmhdr->idFrom == lst1)
        {
            switch (pnmhdr->code)
            {
            case NM_DBLCLK:
                OnPsh1(hwnd);
                return 1;

            case LVN_ITEMCHANGED:
                OnItemChanged(hwnd);
                break;
            }
        }
        return 0;
    }

    void OnContextMenu(HWND hwnd, HWND hwndContext, UINT xPos, UINT yPos)
    {
        if (hwndContext == m_hLst1)
        {
            PopupMenuDx(hwnd, m_hLst1, IDR_POPUPMENUS, 2, xPos, yPos);
        }
    }

    virtual INT_PTR CALLBACK
    DialogProcDx(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
    {
        switch (uMsg)
        {
        HANDLE_MSG(hwnd, WM_INITDIALOG, OnInitDialog);
        HANDLE_MSG(hwnd, WM_COMMAND, OnCommand);
        HANDLE_MSG(hwnd, WM_CONTEXTMENU, OnContextMenu);
        HANDLE_MSG(hwnd, WM_NOTIFY, OnNotify);
        default:
            return DefaultProcDx();
        }
    }
};

```

`src/MIdOrString.hpp`:

```hpp
// MIdOrString.hpp --- ID and String
//////////////////////////////////////////////////////////////////////////////
// RisohEditor --- Another free Win32 resource editor
// Copyright (C) 2017-2018 Katayama Hirofumi MZ <katayama.hirofumi.mz@gmail.com>
// 
// This program is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
// 
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
// 
// You should have received a copy of the GNU General Public License
// along with this program.  If not, see <http://www.gnu.org/licenses/>.
//////////////////////////////////////////////////////////////////////////////

#ifndef MIDORSTRING_HPP_
#define MIDORSTRING_HPP_

#include "MString.hpp"

#ifndef IS_INTRESOURCE
    #define IS_INTRESOURCE(_r) (((ULONG_PTR)(_r) >> 16) == 0)
#endif

#ifndef MAKEINTRESOURCEA
    #define MAKEINTRESOURCEA(i) (char *)((ULONG_PTR)((WORD)(i)))
    #define MAKEINTRESOURCEW(i) (WCHAR *)((ULONG_PTR)((WORD)(i)))
    #ifdef UNICODE
        #define MAKEINTRESOURCE  MAKEINTRESOURCEW
    #else
        #define MAKEINTRESOURCE  MAKEINTRESOURCEA
    #endif
#endif

#ifndef _countof
    #define _countof(array)     (sizeof(array) / sizeof(array[0]))
#endif

//////////////////////////////////////////////////////////////////////////////

struct MIdOrString;

MString mstr_dec_short(SHORT value);
MString mstr_dec_word(WORD value);
MString mstr_dec_dword(DWORD value);
MString mstr_dec(int value);
MString mstr_hex(int value);
MString mstr_hex_word(WORD value);
bool mstr_unquote(std::string& str);
bool mstr_unquote(MStringW& str);
template <size_t siz>
bool mstr_unquote(char (&str)[siz]);
template <size_t siz>
bool mstr_unquote(WCHAR (&str)[siz]);
bool guts_escape(std::string& str, const char*& pch);
bool guts_escape(MStringW& str, const WCHAR*& pch);
bool guts_quote(std::string& str, const char*& pch);
bool guts_quote(MStringW& str, const WCHAR*& pch);

template <typename T_CHAR>
size_t
mstr_repeat_count(const std::basic_string<T_CHAR>& str1, const std::basic_string<T_CHAR>& str2);

//////////////////////////////////////////////////////////////////////////////

struct MIdOrString
{
    WORD m_id;
    MString m_str;

    MIdOrString() : m_id(0)
    {
    }

    MIdOrString(WORD ID) : m_id(ID)
    {
    }

    MIdOrString(const TCHAR *str)
    {
        if (IS_INTRESOURCE(str))
        {
            m_id = LOWORD(str);
        }
        else if ((L'0' <= str[0] && str[0] <= L'9') ||
                 str[0] == L'-' || str[0] == L'+')
        {
            m_id = (WORD)mstr_parse_int(str);
        }
        else
        {
            m_id = 0;
            m_str = str;
        }
    }

    const TCHAR *ptr() const
    {
        if (m_id)
            return MAKEINTRESOURCE(m_id);
        return m_str.c_str();
    }

    bool is_zero() const
    {
        return m_id == 0 && m_str.empty();
    }

    bool is_null() const
    {
        return is_zero();
    }

    bool empty() const
    {
        return is_zero();
    }

    bool is_str() const
    {
        return (!m_id && !m_str.empty());
    }

    bool is_int() const
    {
        return !is_str();
    }

    void clear()
    {
        m_id = 0;
        m_str.clear();
    }

    MIdOrString& operator=(WORD ID)
    {
        m_id = ID;
        m_str.clear();
        return *this;
    }

    MIdOrString& operator=(const TCHAR *str)
    {
        if (IS_INTRESOURCE(str))
        {
            m_id = LOWORD(str);
            m_str.clear();
        }
        else
        {
            m_id = 0;
            m_str = str;
        }
        return *this;
    }

    bool operator==(const MIdOrString& id_or_str) const
    {
        if (id_or_str.m_id != 0)
        {
            if (m_id != 0)
                return id_or_str.m_id == m_id;
        }
        else
        {
            if (m_id == 0)
                return m_str == id_or_str.m_str;
        }
        return false;
    }
    bool operator<(const MIdOrString& id_or_str) const
    {
        if (id_or_str.m_id != 0)
        {
            if (m_id != 0)
                return m_id < id_or_str.m_id;
            return false;
        }
        else
        {
            if (m_id == 0)
                return m_str < id_or_str.m_str;
            return true;
        }
    }
    bool operator>(const MIdOrString& id_or_str) const
    {
        return !(*this < id_or_str) && !(*this == id_or_str);
    }

    bool operator==(const TCHAR *psz) const
    {
        if (IS_INTRESOURCE(psz))
        {
            if (m_id != 0)
                return LOWORD(psz) == m_id;
        }
        else
        {
            if (m_id == 0)
                return m_str == psz;
        }
        return false;
    }
    bool operator==(const MStringW& str) const
    {
        return *this == str.c_str();
    }
    bool operator==(WORD w) const
    {
        return m_id == w;
    }

    bool operator!=(const MIdOrString& id_or_str) const
    {
        return !(*this == id_or_str);
    }
    bool operator!=(const WCHAR *psz) const
    {
        return !(*this == psz);
    }
    bool operator!=(const MStringW& str) const
    {
        return !(*this == str);
    }
    bool operator!=(WORD w) const
    {
        return m_id != w;
    }

    MString str(bool unsign = false) const
    {
        if (m_id == 0)
        {
            if (m_str.size())
            {
                return m_str;
            }
        }
        if (unsign)
            return mstr_dec_word(m_id);
        else
            return mstr_dec_short(m_id);
    }

    MString str_or_empty() const
    {
        if (m_id == 0)
        {
            if (m_str.size())
            {
                return m_str;
            }
            else
            {
                return TEXT("");
            }
        }
        else
        {
            return mstr_dec_short(m_id);
        }
    }

    const TCHAR *c_str() const
    {
        static MString s_str[15];
        static int s_rotate = 0;
        s_rotate = (s_rotate + 1) % _countof(s_str);
        s_str[s_rotate] = str();
        return s_str[s_rotate].c_str();
    }

    const TCHAR *c_str_or_empty() const
    {
        static MString s_str[15];
        static int s_rotate = 0;
        s_rotate = (s_rotate + 1) % _countof(s_str);
        s_str[s_rotate] = str_or_empty();
        return s_str[s_rotate].c_str();
    }

    MString quoted_wstr() const
    {
        MString ret;
        if (m_id == 0)
        {
            if (m_str.size())
            {
                ret += TEXT("\"");
                ret += mstr_escape(m_str);
                ret += TEXT("\"");
            }
            else
            {
                ret += TEXT("\"\"");
            }
        }
        else
        {
            ret = mstr_dec_short(m_id);
        }
        return ret;
    }
};

inline bool guts_escape(std::string& str, const char*& pch)
{
    using namespace std;
    switch (*pch)
    {
    case '\\': str += '\\'; ++pch; break;
    case '"': str += '\"'; ++pch; break;
    case 'a': str += '\a'; ++pch; break;
    case 'b': str += '\b'; ++pch; break;
    case 'f': str += '\f'; ++pch; break;
    case 'n': str += '\n'; ++pch; break;
    case 'r': str += '\r'; ++pch; break;
    case 't': str += '\t'; ++pch; break;
    case 'v': str += '\v'; ++pch; break;
    case 'x':
        {
            ++pch;
            std::string strNum;
            if (isxdigit(*pch))
            {
                strNum += *pch;
                ++pch;
                if (isxdigit(*pch))
                {
                    strNum += *pch;
                    ++pch;
                }
            }
            str += mstr_parse_int(strNum.c_str(), false, 16);
        }
        break;
    case '0': case '1': case '2': case '3':
    case '4': case '5': case '6': case '7':
        {
            std::string strNum;
            if ('0' <= *pch && *pch <= '7')
            {
                strNum += *pch;
                ++pch;
                if ('0' <= *pch && *pch <= '7')
                {
                    strNum += *pch;
                    ++pch;
                    if ('0' <= *pch && *pch <= '7')
                    {
                        strNum += *pch;
                        ++pch;
                    }
                }
            }
            str += (char)mstr_parse_int(strNum.c_str(), false, 8);
        }
        break;
    default:
        str += *pch;
        ++pch;
        return false;
    }
    return true;
}

inline bool guts_escape(MStringW& str, const WCHAR*& pch)
{
    using namespace std;
    switch (*pch)
    {
    case L'\\': str += L'\\'; ++pch; break;
    case L'"': str += L'\"'; ++pch; break;
    case L'a': str += L'\a'; ++pch; break;
    case L'b': str += L'\b'; ++pch; break;
    case L'f': str += L'\f'; ++pch; break;
    case L'n': str += L'\n'; ++pch; break;
    case L'r': str += L'\r'; ++pch; break;
    case L't': str += L'\t'; ++pch; break;
    case L'v': str += L'\v'; ++pch; break;
    case L'x':
        {
            ++pch;
            MStringW strNum;
            if (mchr_is_xdigit(*pch))
            {
                strNum += *pch;
                ++pch;
                if (mchr_is_xdigit(*pch))
                {
                    strNum += *pch;
                    ++pch;
                }
            }
            str += (WCHAR)mstr_parse_int(strNum.c_str(), false, 16);
        }
        break;
    case L'0': case L'1': case L'2': case L'3':
    case L'4': case L'5': case L'6': case L'7':
        {
            MStringW strNum;
            if (L'0' <= *pch && *pch <= L'7')
            {
                strNum += *pch;
                ++pch;
                if (L'0' <= *pch && *pch <= L'7')
                {
                    strNum += *pch;
                    ++pch;
                    if (L'0' <= *pch && *pch <= L'7')
                    {
                        strNum += *pch;
                        ++pch;
                    }
                }
            }
            str += (WCHAR)mstr_parse_int(strNum.c_str(), false, 8);
        }
        break;
    case 'u':
        {
            ++pch;
            MStringW strNum;
            if (mchr_is_xdigit(*pch))
            {
                strNum += *pch;
                ++pch;
                if (mchr_is_xdigit(*pch))
                {
                    strNum += *pch;
                    ++pch;
                    if (mchr_is_xdigit(*pch))
                    {
                        strNum += *pch;
                        ++pch;
                        if (mchr_is_xdigit(*pch))
                        {
                            strNum += *pch;
                            ++pch;
                        }
                    }
                }
            }
            str += (WCHAR)mstr_parse_int(strNum.c_str(), false, 16);
        }
        break;
    default:
        str += *pch;
        ++pch;
        return false;
    }
    return true;
}

inline bool guts_quote(std::string& str, const char*& pch)
{
    using namespace std;
    str.clear();

    pch = mstr_skip_space(pch);
    if (*pch != L'\"')
        return false;

    for (++pch; *pch; ++pch)
    {
        if (*pch == L'\\')
        {
            ++pch;
            guts_escape(str, pch);
            --pch;
        }
        else if (*pch == L'\"')
        {
            ++pch;
            if (*pch == L'\"')
            {
                str += L'\"';
            }
            else
            {
                break;
            }
        }
        else
        {
            str += *pch;
        }
    }

    return true;
}

inline bool guts_quote(MStringW& str, const WCHAR*& pch)
{
    using namespace std;
    str.clear();

    pch = mstr_skip_space(pch);
    if (*pch != L'\"')
        return false;

    for (++pch; *pch; ++pch)
    {
        if (*pch == L'\\')
        {
            ++pch;
            guts_escape(str, pch);
            --pch;
        }
        else if (*pch == L'\"')
        {
            ++pch;
            if (*pch == L'\"')
            {
                str += L'\"';
            }
            else
            {
                break;
            }
        }
        else
        {
            str += *pch;
        }
    }

    return true;
}

inline MString mstr_dec_short(SHORT value)
{
    MString ret;
    mstr_to_dec(ret, (short)value);
    return ret;
}

inline MString mstr_dec_word(WORD value)
{
    MString ret;
    mstr_to_dec(ret, value);
    return ret;
}

inline MString mstr_dec_dword(DWORD value)
{
    MString ret;
    mstr_to_dec(ret, value);
    return ret;
}

inline MString mstr_dec(int value)
{
    MString ret;
    mstr_to_dec(ret, value);
    return ret;
}

inline MString mstr_hex(int value)
{
    MString ret, str;
    if (value == 0)
    {
        ret = TEXT("0");
    }
    else
    {
        ret += TEXT("0x");
        mstr_to_hex(str, value);
        ret += str;
    }
    return ret;
}

inline MString mstr_hex_word(WORD value)
{
    MString ret, str;
    ret += TEXT("0x");
    mstr_to_hex(str, value);
    if (str.size() < 4)
    {
        ret += MString(4 - str.size(), TEXT('0'));
    }
    ret += str;
    return ret;
}

inline bool mstr_unquote(std::string& str)
{
    std::string str2 = str;
    const char *pch = str2.c_str();
    return guts_quote(str, pch);
}

inline bool mstr_unquote(MStringW& str)
{
    MStringW str2 = str;
    const WCHAR *pch = str2.c_str();
    return guts_quote(str, pch);
}

template <size_t siz>
inline bool mstr_unquote(char (&str)[siz])
{
    std::string s = str;
    bool ret = mstr_unquote(s);
    mstrcpy(str, s.c_str());
    return ret;
}

template <size_t siz>
inline bool mstr_unquote(WCHAR (&str)[siz])
{
    MStringW s = str;
    bool ret = mstr_unquote(s);
    mstrcpy(str, s.c_str());
    return ret;
}

template <typename T_CHAR>
inline size_t
mstr_repeat_count(const std::basic_string<T_CHAR>& str1, const std::basic_string<T_CHAR>& str2)
{
    size_t count = 0;
    for (size_t i = 0; i < str1.size(); i += str2.size())
    {
        if (str1.find(str2, i) != i)
            break;

        ++count;
    }
    return count;
}

template <typename T_CHAR>
inline size_t
mstr_repeat_count(const T_CHAR *str1, const std::basic_string<T_CHAR>& str2)
{
    std::basic_string<T_CHAR> s1(str1);
    return mstr_repeat_count(s1, str2);
}

template <typename T_CHAR>
inline size_t
mstr_repeat_count(const std::basic_string<T_CHAR>& str1, const T_CHAR *str2)
{
    std::basic_string<T_CHAR> s2(str2);
    return mstr_repeat_count(str1, s2);
}

//////////////////////////////////////////////////////////////////////////////

#endif  // ndef MIDORSTRING_HPP_

//////////////////////////////////////////////////////////////////////////////

```

`src/MIndexLabels.hpp`:

```hpp
// MIndexLabels.hpp --- Index Labels
//////////////////////////////////////////////////////////////////////////////
// RisohEditor --- Another free Win32 resource editor
// Copyright (C) 2017-2018 Katayama Hirofumi MZ <katayama.hirofumi.mz@gmail.com>
// 
// This program is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
// 
// This program is distributed in the hope that it will be useful, 
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
// 
// You should have received a copy of the GNU General Public License
// along with this program.  If not, see <http://www.gnu.org/licenses/>.
//////////////////////////////////////////////////////////////////////////////

#pragma once

#include "MWindowBase.hpp"
#include <map>

//////////////////////////////////////////////////////////////////////////////

class MIndexLabels : public MWindowBase
{
public:
    typedef std::map<INT, HWND> map_type;
    map_type m_map;
    HWND m_hwndOwner;
    HFONT m_hFont;

    MIndexLabels()
    {
        m_hwndOwner = NULL;
        m_hFont = NULL;
    }

    virtual ~MIndexLabels()
    {
        DeleteObject(m_hFont);
    }

    void Destroy()
    {
        if (m_hwnd)
        {
            DestroyWindow(m_hwnd);
        }
    }

    BOOL ReCreate(HWND hwndOwner, map_type& map)
    {
        m_hwndOwner = hwndOwner;
        m_map = map;

        Destroy();

        if (!CreateWindowDx(hwndOwner, NULL, WS_CHILD | WS_VISIBLE | WS_DISABLED, 
            WS_EX_TOPMOST | WS_EX_NOACTIVATE | WS_EX_TOOLWINDOW | WS_EX_TRANSPARENT))
        {
            return FALSE;
        }

        RECT rc;
        GetClientRect(hwndOwner, &rc);
        MoveWindow(m_hwnd, rc.left, rc.top, rc.right - rc.left, rc.bottom - rc.top, TRUE);

        return TRUE;
    }

    void OnPaint(HWND hwnd)
    {
        PAINTSTRUCT ps;
        HDC hDC = BeginPaint(hwnd, &ps);
        if (hDC)
        {
            SetTextColor(hDC, RGB(255, 255, 255));
            SetBkMode(hDC, OPAQUE);
            SetBkColor(hDC, RGB(0, 0, 255));

            HGDIOBJ hFontOld = SelectObject(hDC, m_hFont);
            for (auto& pair : m_map)
            {
                RECT rc;
                GetWindowRect(pair.second, &rc);
                MapWindowRect(NULL, m_hwndOwner, &rc);

                TCHAR szText[32];
                StringCchPrintf(szText, _countof(szText), TEXT("%d"), pair.first);
                TextOut(hDC, rc.left, rc.top, szText, lstrlen(szText));
            }
            SelectObject(hDC, hFontOld);

            EndPaint(hwnd, &ps);
        }
    }

    UINT OnNCHitTest(HWND hwnd, int x, int y)
    {
        return HTTRANSPARENT;
    }

    virtual LRESULT CALLBACK
    WindowProcDx(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
    {
        switch (uMsg)
        {
            HANDLE_MSG(hwnd, WM_PAINT, OnPaint);
            HANDLE_MSG(hwnd, WM_NCCALCSIZE, OnNCCalcSize);
            HANDLE_MSG(hwnd, WM_NCHITTEST, OnNCHitTest);
        default:
            return DefaultProcDx();
        }
    }

    virtual LPCTSTR GetWndClassNameDx() const
    {
        return TEXT("katahiromz's Index Labels Class");
    }

    virtual void ModifyWndClassDx(WNDCLASSEX& wcx)
    {
        wcx.hIcon = NULL;
        wcx.hbrBackground = GetStockBrush(NULL_BRUSH);
        wcx.hIconSm = NULL;
    }

    UINT OnNCCalcSize(HWND hwnd, BOOL fCalcValidRects, NCCALCSIZE_PARAMS *lpcsp)
    {
        return 0;
    }
};

```

`src/MItemSearchDlg.hpp`:

```hpp
// MItemSearchDlg.hpp --- RisohEditor "Item Search" dialog
//////////////////////////////////////////////////////////////////////////////
// RisohEditor --- Another free Win32 resource editor
// Copyright (C) 2017-2018 Katayama Hirofumi MZ <katayama.hirofumi.mz@gmail.com>
// 
// This program is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
// 
// This program is distributed in the hope that it will be useful, 
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
// 
// You should have received a copy of the GNU General Public License
// along with this program.  If not, see <http://www.gnu.org/licenses/>.
//////////////////////////////////////////////////////////////////////////////

#pragma once

#include "resource.h"
#include "MWindowBase.hpp"
#include "RisohSettings.hpp"

#include "ResToText.hpp"
#include "Res.hpp"
#include <unordered_set>     // for std::unordered_set

struct ITEM_SEARCH;
class MItemSearchDlg;

#define MYWM_ITEMSEARCH (WM_USER + 113)

//////////////////////////////////////////////////////////////////////////////

struct ITEM_SEARCH
{
    ResToText   res2text;
    BOOL        bIgnoreCases;
    BOOL        bDownward;
    BOOL        bRunning;
    BOOL        bCancelled;
    MString     strText;
    EntryBase  *pCurrent;
    EntryBase  *pFound;
    ITEM_SEARCH()
    {
        bIgnoreCases = TRUE;
        bDownward = TRUE;
        bRunning = FALSE;
        bCancelled = FALSE;
        pCurrent = NULL;
        pFound = NULL;
    }
};

class MItemSearchDlg : public MDialogBase
{
public:
    ITEM_SEARCH& m_search;
    HICON m_hIcon;
    HICON m_hIconSm;

    MItemSearchDlg(ITEM_SEARCH& search)
        : MDialogBase(IDD_ITEMSEARCH), m_search(search),
          m_hIcon(LoadIconDx(IDI_FIND)), m_hIconSm(LoadSmallIconDx(IDI_FIND))
    {
    }

    virtual ~MItemSearchDlg()
    {
        DestroyIcon(m_hIcon);
        DestroyIcon(m_hIconSm);
    }

    typedef std::unordered_set<MItemSearchDlg *> dialogs_type;

    static dialogs_type& Dialogs()
    {
        static dialogs_type s_dialogs;
        return s_dialogs;
    }

    virtual void PostNcDestroy()
    {
        Dialogs().erase(this);
        MDialogBase::PostNcDestroy();
        delete this;
    }

    void Done()
    {
        m_search.bRunning = FALSE;
        EnableWindow(GetDlgItem(m_hwnd, IDOK), TRUE);
    }

    BOOL OnInitDialog(HWND hwnd, HWND hwndFocus, LPARAM lParam)
    {
        Dialogs().insert(this);

        SetDlgItemText(hwnd, edt1, m_search.strText.c_str());

        if (m_search.bDownward)
            CheckRadioButton(hwnd, rad1, rad2, rad2);
        else
            CheckRadioButton(hwnd, rad1, rad2, rad1);

        SendMessageDx(WM_SETICON, ICON_BIG, (LPARAM)m_hIcon);
        SendMessageDx(WM_SETICON, ICON_SMALL, (LPARAM)m_hIconSm);

        if (!m_search.bIgnoreCases)
            CheckDlgButton(hwnd, chx1, BST_CHECKED);

        CenterWindowDx();
        return TRUE;
    }

    void OnOK(HWND hwnd)
    {
        if (m_search.bRunning)
            return;

        m_search.strText = GetDlgItemText(edt1);
        if (m_search.strText.empty())
            return;

        m_search.bIgnoreCases = IsDlgButtonChecked(hwnd, chx1) == BST_UNCHECKED;
        m_search.bDownward = IsDlgButtonChecked(hwnd, rad2) == BST_CHECKED;
        m_search.bRunning = TRUE;
        EnableWindow(GetDlgItem(hwnd, IDOK), FALSE);
        SendMessage(GetParent(hwnd), MYWM_ITEMSEARCH, 0, (LPARAM)this);
    }

    void OnCommand(HWND hwnd, int id, HWND hwndCtl, UINT codeNotify)
    {
        switch (id)
        {
        case IDOK:
            OnOK(hwnd);
            break;
        case IDCANCEL:
            if (!m_search.bRunning)
            {
                PostMessageDx(WM_COMMAND, 999);
            }
            else if (!m_search.bCancelled)
            {
                m_search.bRunning = FALSE;
                m_search.bCancelled = TRUE;
            }
            break;
        case 999:
            DestroyWindow(hwnd);
            break;
        }
    }

    virtual INT_PTR CALLBACK
    DialogProcDx(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
    {
        switch (uMsg)
        {
            HANDLE_MSG(hwnd, WM_INITDIALOG, OnInitDialog);
            HANDLE_MSG(hwnd, WM_COMMAND, OnCommand);
        }
        return 0;
    }
};

```

`src/MLangAutoComplete.hpp`:

```hpp
#pragma once

#include <shldisp.h>
#include <shlguid.h>

class MLangAutoComplete : public IEnumString
{
public:
    MLangAutoComplete(BOOL bUILanguage = FALSE);

    virtual ~MLangAutoComplete()
    {
        unbind();
    }

    void push_back(const std::wstring& text)
    {
        auto it = std::find(m_list.begin(), m_list.end(), text);
        if (it == m_list.end())
            m_list.push_back(text);
    }
    void erase(const std::wstring& text)
    {
        auto it = std::find(m_list.begin(), m_list.end(), text);
        if (it != m_list.end())
            m_list.erase(it);
    }
    size_t size() const
    {
        return m_list.size();
    }
    bool empty() const
    {
        return size() == 0;
    }

    bool bind(HWND hwndEdit)
    {
        assert(::IsWindow(hwndEdit));

        if (m_fBound && m_pAC)
            return false;

        ::CoCreateInstance(CLSID_AutoComplete, NULL, CLSCTX_INPROC_SERVER, IID_PPV_ARGS(&m_pAC));
        if (m_pAC)
        {
            IAutoComplete2 *pAC2 = NULL;
            m_pAC->QueryInterface(IID_PPV_ARGS(&pAC2));
            if (pAC2)
            {
                pAC2->SetOptions(ACO_AUTOSUGGEST | ACO_UPDOWNKEYDROPSLIST);
                pAC2->Release();
            }

            m_pAC->Init(hwndEdit, this, NULL, NULL);
            m_fBound = TRUE;
            return true;
        }

        assert(0);
        return false;
    }
    void unbind()
    {
        if (!m_fBound)
            return;

        if (m_pAC)
        {
            m_pAC->Release();
            m_pAC = NULL;
            m_fBound = FALSE;
        }
    }

    // IUnknown interface
    STDMETHODIMP_(ULONG) AddRef()
    {
        return ++m_nRefCount;
    }
    STDMETHODIMP_(ULONG) Release()
    {
        ULONG nCount = --m_nRefCount;
        if (nCount == 0)
            delete this;
        return nCount;
    }
    STDMETHODIMP QueryInterface(REFIID riid, void** ppvObject)
    {
        if (ppvObject == NULL)
            return E_POINTER;

        *ppvObject = NULL;

        IUnknown *punk = NULL;
        if (riid == IID_IUnknown)
            punk = static_cast<IUnknown *>(this);
        else if (riid == IID_IEnumString)
            punk = static_cast<IEnumString *>(this);

        if (punk == NULL)
            return E_NOINTERFACE;

        punk->AddRef();
        *ppvObject = punk;
        return S_OK;
    }

    // IEnumString interface
    STDMETHODIMP Next(ULONG celt, LPOLESTR* rgelt, ULONG* pceltFetched)
    {
        HRESULT hr = S_FALSE;
        if (!celt)
            celt = 1;

        ULONG i;
        for (i = 0; i < celt; i++)
        {
            if (m_nCurrentElement == m_list.size())
                break;

            size_t cb = (m_list[m_nCurrentElement].size() + 1) * sizeof(WCHAR);
            rgelt[i] = reinterpret_cast<LPWSTR>(::CoTaskMemAlloc(cb));
            memcpy(rgelt[i], m_list[m_nCurrentElement].c_str(), cb);

            if (pceltFetched)
                *pceltFetched++;

            m_nCurrentElement++;
        }

        if (i == celt)
            hr = S_OK;

        return hr;
    }
    STDMETHODIMP Skip(ULONG celt)
    {
        m_nCurrentElement += celt;
        if (m_nCurrentElement > m_list.size())
            m_nCurrentElement = 0;
        return S_OK;
    }
    STDMETHODIMP Reset(void)
    {
        m_nCurrentElement = 0;
        return S_OK;
    }
    STDMETHODIMP Clone(IEnumString** ppenum)
    {
        if (!ppenum)
            return E_POINTER;
        
        MLangAutoComplete *cloned = new MLangAutoComplete();

        cloned->AddRef();
        cloned->m_list = m_list;
        *ppenum = cloned;

        return S_OK;
    }

protected:
    IAutoComplete *m_pAC;
    std::vector<std::wstring> m_list;
    ULONG m_nCurrentElement;
    ULONG m_nRefCount;
    BOOL m_fBound;
};

class MLangAutoCompleteEdit : public MEditCtrl
{
public:
    HWND m_hwndTV;
    BOOL m_bHooked;
    BOOL m_bAdjustSize;

    MLangAutoCompleteEdit()
        : m_hwndTV(NULL)
        , m_bHooked(FALSE)
        , m_bAdjustSize(FALSE)
    {
    }

    void hook(HWND hwndEdit, HWND hwndTV = NULL)
    {
        if (!m_bHooked)
        {
            SubclassDx(hwndEdit);
            m_hwndTV = hwndTV;
            m_bHooked = TRUE;
            SetTimer(hwndEdit, 99999, 100, NULL);
        }
    }

    void unhook()
    {
        KillTimer(m_hwnd, 99999);
        if (m_bHooked)
        {
            UnsubclassDx();
        }
        m_bHooked = FALSE;
        m_hwndTV = NULL;
    }

    void AdjustSize()
    {
        if (!m_bHooked || !m_bAdjustSize)
            return;

        RECT rc, rcTV;
        GetWindowRect(m_hwnd, &rc);
        MapWindowRect(NULL, m_hwndTV, &rc);
        GetClientRect(m_hwndTV, &rcTV);

        INT cx = rcTV.right - rc.left;
        INT cy = rc.bottom - rc.top;

        if (HWND hwndDropdown = FindWindowW(L"Auto-Suggest Dropdown", NULL))
        {
            GetWindowRect(hwndDropdown, &rc);
            cy = rc.bottom - rc.top;
            MoveWindow(hwndDropdown, rc.left, rc.top, cx, cy, TRUE);
        }
    }

protected:
    virtual LRESULT CALLBACK
    WindowProcDx(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
    {
        LRESULT ret = 0;
        switch (uMsg)
        {
        case WM_TIMER:
            if (wParam == 99999)
            {
                AdjustSize();
                break;
            }
            ret = DefaultProcDx(hwnd, uMsg, wParam, lParam);
            break;
        default:
            ret = DefaultProcDx(hwnd, uMsg, wParam, lParam);
        }
        return ret;
    }
};

```

`src/MLangsDlg.hpp`:

```hpp
// MLangsDlg.hpp --- "Languages" Dialog
//////////////////////////////////////////////////////////////////////////////
// RisohEditor --- Another free Win32 resource editor
// Copyright (C) 2017-2018 Katayama Hirofumi MZ <katayama.hirofumi.mz@gmail.com>
// 
// This program is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
// 
// This program is distributed in the hope that it will be useful, 
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
// 
// You should have received a copy of the GNU General Public License
// along with this program.  If not, see <http://www.gnu.org/licenses/>.
//////////////////////////////////////////////////////////////////////////////

#pragma once

#include "MWindowBase.hpp"
#include "MResizable.hpp"
#include "RisohSettings.hpp"
#include "Common.hpp"

//////////////////////////////////////////////////////////////////////////////

class MLangsDlg : public MDialogBase
{
public:
    HWND m_hLst1;
    MResizable m_resizable;
    HICON m_hIcon;
    HICON m_hIconSm;

    MLangsDlg() : MDialogBase(IDD_LANGS)
    {
        m_hIcon = LoadIconDx(IDI_SMILY);
        m_hIconSm = LoadSmallIconDx(IDI_SMILY);
    }

    ~MLangsDlg()
    {
        DestroyIcon(m_hIcon);
        DestroyIcon(m_hIconSm);
    }

    void Lst1_Init(HWND hLst1)
    {
        InitLangListView(hLst1, NULL);
    }

    BOOL OnInitDialog(HWND hwnd, HWND hwndFocus, LPARAM lParam)
    {
        m_resizable.OnParentCreate(hwnd);

        m_resizable.SetLayoutAnchor(lst1, mzcLA_TOP_LEFT, mzcLA_BOTTOM_RIGHT);
        m_resizable.SetLayoutAnchor(stc1, mzcLA_BOTTOM_LEFT);
        m_resizable.SetLayoutAnchor(cmb1, mzcLA_BOTTOM_LEFT, mzcLA_BOTTOM_RIGHT);
        m_resizable.SetLayoutAnchor(IDOK, mzcLA_BOTTOM_RIGHT);
        m_resizable.SetLayoutAnchor(edt1, mzcLA_BOTTOM_LEFT, mzcLA_BOTTOM_RIGHT);

        SendMessageDx(WM_SETICON, ICON_BIG, (LPARAM)m_hIcon);
        SendMessageDx(WM_SETICON, ICON_SMALL, (LPARAM)m_hIconSm);

        m_hLst1 = GetDlgItem(hwnd, lst1);
        ListView_SetExtendedListViewStyle(m_hLst1, LVS_EX_FULLROWSELECT);

        LV_COLUMN column;
        ZeroMemory(&column, sizeof(column));

        column.mask = LVCF_FMT | LVCF_SUBITEM | LVCF_TEXT | LVCF_WIDTH;
        column.fmt = LVCFMT_LEFT;
        column.cx = 180;
        column.pszText = LoadStringDx(IDS_LANGUAGE);
        column.iSubItem = 0;
        ListView_InsertColumn(m_hLst1, 0, &column);

        column.mask = LVCF_FMT | LVCF_SUBITEM | LVCF_TEXT | LVCF_WIDTH;
        column.fmt = LVCFMT_RIGHT;
        column.cx = 110;
        column.pszText = LoadStringDx(IDS_INTVALUE);
        column.iSubItem = 1;
        ListView_InsertColumn(m_hLst1, 1, &column);

        Lst1_Init(m_hLst1);

        CenterWindowDx();
        return TRUE;
    }

    void OnOK(HWND hwnd)
    {
        OnCopy(hwnd);
        EndDialog(IDOK);
    }

    void OnCmb1(HWND hwnd)
    {
        HWND hCmb1 = GetDlgItem(hwnd, cmb1);
        MString strText = GetWindowText(hCmb1);

        InitLangListView(m_hLst1, strText.c_str());
    }

    void OnLst1(HWND hwnd)
    {
        INT iItem = ListView_GetNextItem(m_hLst1, -1, LVNI_ALL | LVNI_SELECTED);
        if (iItem < 0)
            return;

        TCHAR szText[32];
        ListView_GetItemText(m_hLst1, iItem, 1, szText, _countof(szText));

        LANGID langid = _wtoi(szText);
        MString strStatement = GetLanguageStatement(langid, TRUE);

        SetDlgItemText(hwnd, edt1, strStatement.c_str());
    }

    void OnCommand(HWND hwnd, int id, HWND hwndCtl, UINT codeNotify)
    {
        switch (id)
        {
        case IDOK:
            OnOK(hwnd);
            break;
        case IDCANCEL:
            EndDialog(IDCANCEL);
            break;
        case ID_COPY:
            OnCopy(hwnd);
            break;
        case cmb1:
            if (codeNotify == CBN_EDITCHANGE)
            {
                OnCmb1(hwnd);
            }
            break;
        }
    }

    void OnCopy(HWND hwnd)
    {
        INT iItem = ListView_GetNextItem(m_hLst1, -1, LVNI_ALL | LVNI_SELECTED);
        if (iItem < 0)
            return;

        TCHAR szText[32];
        ListView_GetItemText(m_hLst1, iItem, 1, szText, _countof(szText));

        INT cch = lstrlen(szText) + 1;
        DWORD cb = sizeof(WCHAR) * cch;

        if (HGLOBAL hGlobal = GlobalAlloc(GHND | GMEM_SHARE, cb))
        {
            if (LPVOID pv = GlobalLock(hGlobal))
            {
                CopyMemory(pv, szText, cb);
                GlobalUnlock(hGlobal);

                if (OpenClipboard(m_hLst1))
                {
                    EmptyClipboard();
                    SetClipboardData(CF_UNICODETEXT, hGlobal);
                    CloseClipboard();
                    return;
                }
            }
            GlobalFree(hGlobal);
        }
    }

    LRESULT OnNotify(HWND hwnd, int idFrom, LPNMHDR pnmhdr)
    {
        if (pnmhdr->idFrom == lst1)
        {
            switch (pnmhdr->code)
            {
            case NM_DBLCLK:
                OnCopy(hwnd);
                return 1;
            case LVN_ITEMCHANGED:
                if (NM_LISTVIEW *pListView = (NM_LISTVIEW *)pnmhdr)
                {
                    if ((pListView->uChanged & LVIF_STATE) &&
                        (pListView->uNewState & LVIS_SELECTED))
                    {
                        OnLst1(hwnd);
                    }
                }
                break;
            }
        }
        return 0;
    }

    void OnContextMenu(HWND hwnd, HWND hwndContext, UINT xPos, UINT yPos)
    {
        if (hwndContext == m_hLst1)
        {
            PopupMenuDx(hwnd, m_hLst1, IDR_POPUPMENUS, 5, xPos, yPos);
        }
    }

    void OnSize(HWND hwnd, UINT state, int cx, int cy)
    {
        m_resizable.OnSize();
    }

    virtual INT_PTR CALLBACK
    DialogProcDx(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
    {
        switch (uMsg)
        {
        HANDLE_MSG(hwnd, WM_INITDIALOG, OnInitDialog);
        HANDLE_MSG(hwnd, WM_COMMAND, OnCommand);
        HANDLE_MSG(hwnd, WM_CONTEXTMENU, OnContextMenu);
        HANDLE_MSG(hwnd, WM_NOTIFY, OnNotify);
        HANDLE_MSG(hwnd, WM_SIZE, OnSize);
        default:
            return DefaultProcDx();
        }
    }
};

```

`src/MMacrosDlg.hpp`:

```hpp
// MMacrosDlg.hpp --- Dialogs for Predefined Macros
//////////////////////////////////////////////////////////////////////////////
// RisohEditor --- Another free Win32 resource editor
// Copyright (C) 2017-2018 Katayama Hirofumi MZ <katayama.hirofumi.mz@gmail.com>
// 
// This program is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
// 
// This program is distributed in the hope that it will be useful, 
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
// 
// You should have received a copy of the GNU General Public License
// along with this program.  If not, see <http://www.gnu.org/licenses/>.
//////////////////////////////////////////////////////////////////////////////

#pragma once

#include "resource.h"
#include "MWindowBase.hpp"
#include "RisohSettings.hpp"
#include "MResizable.hpp"
#include "MComboBoxAutoComplete.hpp"

struct MACRO_ENTRY;
class MAddMacroDlg;
class MEditMacroDlg;
class MMacrosDlg;

//////////////////////////////////////////////////////////////////////////////

struct MACRO_ENTRY
{
    TCHAR szKey[128];
    TCHAR szValue[256];
};

//////////////////////////////////////////////////////////////////////////////

class MAddMacroDlg : public MDialogBase
{
public:
    macro_map_type& m_map;
    MACRO_ENTRY& m_entry;
    MComboBoxAutoComplete m_cmb1;
    MComboBoxAutoComplete m_cmb2;

    MAddMacroDlg(macro_map_type& map, MACRO_ENTRY& entry) :
        MDialogBase(IDD_ADDMACRO), m_map(map), m_entry(entry)
    {
    }

    BOOL OnInitDialog(HWND hwnd, HWND hwndFocus, LPARAM lParam)
    {
        CheckDlgButton(hwnd, chx1, BST_CHECKED);

        SubclassChildDx(m_cmb1, cmb1);
        SubclassChildDx(m_cmb2, cmb2);

        CenterWindowDx();
        return TRUE;
    }

    void OnOK(HWND hwnd)
    {
        HWND hCmb1 = GetDlgItem(hwnd, cmb1);
        HWND hCmb2 = GetDlgItem(hwnd, cmb2);

        MACRO_ENTRY entry;

        GetWindowText(hCmb1, entry.szKey, _countof(entry.szKey));
        GetWindowText(hCmb2, entry.szValue, _countof(entry.szValue));

        mstr_trim(entry.szKey);
        mstr_trim(entry.szValue);

        if (entry.szKey[0] == 0)
        {
            ComboBox_SetEditSel(hCmb1, 0, -1);
            SetFocus(hCmb1);
            ErrorBoxDx(IDS_EMPTYSTR);
            return;
        }

        if (m_map.find(entry.szKey) != m_map.end())
        {
            ComboBox_SetEditSel(hCmb1, 0, -1);
            SetFocus(hCmb1);
            ErrorBoxDx(IDS_ALREADYEXISTS);
            return;
        }

        m_entry = entry;

        EndDialog(IDOK);
    }

    void OnCommand(HWND hwnd, int id, HWND hwndCtl, UINT codeNotify)
    {
        switch (id)
        {
        case IDOK:
            OnOK(hwnd);
            break;
        case IDCANCEL:
            EndDialog(IDCANCEL);
            break;
        case cmb1:
            if (codeNotify == CBN_EDITCHANGE)
            {
                m_cmb1.OnEditChange();
            }
            break;
        case cmb2:
            if (codeNotify == CBN_EDITCHANGE)
            {
                m_cmb2.OnEditChange();
            }
            break;
        }
    }

    virtual INT_PTR CALLBACK
    DialogProcDx(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
    {
        switch (uMsg)
        {
            HANDLE_MSG(hwnd, WM_INITDIALOG, OnInitDialog);
            HANDLE_MSG(hwnd, WM_COMMAND, OnCommand);
        }
        return DefaultProcDx();
    }
};

//////////////////////////////////////////////////////////////////////////////

class MEditMacroDlg : public MDialogBase
{
public:
    MACRO_ENTRY& m_entry;
    MComboBoxAutoComplete m_cmb1;
    MComboBoxAutoComplete m_cmb2;

    MEditMacroDlg(MACRO_ENTRY& entry) :
        MDialogBase(IDD_EDITMACRO), m_entry(entry)
    {
    }

    BOOL OnInitDialog(HWND hwnd, HWND hwndFocus, LPARAM lParam)
    {
        CheckDlgButton(hwnd, chx1, BST_CHECKED);
        SubclassChildDx(m_cmb1, cmb1);
        SubclassChildDx(m_cmb2, cmb2);

        SetWindowText(m_cmb1, m_entry.szKey);
        SetWindowText(m_cmb2, m_entry.szValue);

        CenterWindowDx();
        return TRUE;
    }

    void OnOK(HWND hwnd)
    {
        HWND hCmb1 = GetDlgItem(hwnd, cmb1);
        HWND hCmb2 = GetDlgItem(hwnd, cmb2);

        MACRO_ENTRY entry;

        GetWindowText(hCmb1, entry.szKey, _countof(entry.szKey));
        GetWindowText(hCmb2, entry.szValue, _countof(entry.szValue));

        mstr_trim(entry.szKey);
        mstr_trim(entry.szValue);

        if (entry.szKey[0] == 0)
        {
            ComboBox_SetEditSel(hCmb1, 0, -1);
            SetFocus(hCmb1);
            ErrorBoxDx(IDS_EMPTYSTR);
            return;
        }

        m_entry = entry;

        EndDialog(IDOK);
    }

    void OnCommand(HWND hwnd, int id, HWND hwndCtl, UINT codeNotify)
    {
        switch (id)
        {
        case IDOK:
            OnOK(hwnd);
            break;
        case IDCANCEL:
            EndDialog(IDCANCEL);
            break;
        case cmb1:
            if (codeNotify == CBN_EDITCHANGE)
            {
                m_cmb1.OnEditChange();
            }
            break;
        case cmb2:
            if (codeNotify == CBN_EDITCHANGE)
            {
                m_cmb2.OnEditChange();
            }
            break;
        }
    }

    virtual INT_PTR CALLBACK
    DialogProcDx(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
    {
        switch (uMsg)
        {
            HANDLE_MSG(hwnd, WM_INITDIALOG, OnInitDialog);
            HANDLE_MSG(hwnd, WM_COMMAND, OnCommand);
        }
        return DefaultProcDx();
    }
};

//////////////////////////////////////////////////////////////////////////////

class MMacrosDlg : public MDialogBase
{
public:
    macro_map_type m_map;
    MResizable m_resizable;
    HWND m_hLst1;
    HICON m_hIcon;
    HICON m_hIconSm;
    MString m_strTemp;

    MMacrosDlg()
        : MDialogBase(IDD_MACROS), 
          m_map(g_settings.macros)
    {
        m_hIcon = LoadIconDx(IDI_SMILY);
        m_hIconSm = LoadSmallIconDx(IDI_SMILY);
    }

    ~MMacrosDlg()
    {
        DestroyIcon(m_hIcon);
        DestroyIcon(m_hIconSm);
    }

    void OnDelete(HWND hwnd)
    {
        INT iItem = ListView_GetNextItem(m_hLst1, -1, LVNI_ALL | LVNI_SELECTED);
        if (iItem < 0)
            return;

        ListView_DeleteItem(m_hLst1, iItem);

        MACRO_ENTRY entry;
        ListView_GetItemText(m_hLst1, iItem, 0, entry.szKey, _countof(entry.szKey));

        m_map.erase(entry.szKey);
    }

    void OnAdd(HWND hwnd)
    {
        MACRO_ENTRY entry;
        MAddMacroDlg dialog(m_map, entry);
        if (dialog.DialogBoxDx(hwnd) == IDOK)
        {
            m_map[dialog.m_entry.szKey] = dialog.m_entry.szValue;

            INT iItem = ListView_GetItemCount(m_hLst1);
            LV_ITEM item;

            ZeroMemory(&item, sizeof(item));
            item.iItem = iItem;
            item.mask = LVIF_TEXT;
            item.iSubItem = 0;
            item.pszText = entry.szKey;
            ListView_InsertItem(m_hLst1, &item);

            ZeroMemory(&item, sizeof(item));
            item.iItem = iItem;
            item.mask = LVIF_TEXT;
            item.iSubItem = 1;
            item.pszText = entry.szValue;
            ListView_SetItem(m_hLst1, &item);

            UINT state = LVIS_SELECTED | LVIS_FOCUSED;
            ListView_SetItemState(m_hLst1, iItem, state, state);
            ListView_EnsureVisible(m_hLst1, iItem, FALSE);
        }
    }

    void OnModify(HWND hwnd)
    {
        INT iItem = ListView_GetNextItem(m_hLst1, -1, LVNI_ALL | LVNI_SELECTED);
        if (iItem < 0)
        {
            return;
        }

        MACRO_ENTRY entry;
        ListView_GetItemText(m_hLst1, iItem, 0, entry.szKey, _countof(entry.szKey));
        ListView_GetItemText(m_hLst1, iItem, 1, entry.szValue, _countof(entry.szValue));

        mstr_trim(entry.szKey);
        mstr_trim(entry.szValue);

        MEditMacroDlg dialog(entry);
        if (dialog.DialogBoxDx(hwnd) == IDOK)
        {
            m_map[dialog.m_entry.szKey] = dialog.m_entry.szValue;

            LV_ITEM item;

            ZeroMemory(&item, sizeof(item));
            item.iItem = iItem;
            item.mask = LVIF_TEXT;
            item.iSubItem = 0;
            item.pszText = entry.szKey;
            ListView_SetItem(m_hLst1, &item);

            ZeroMemory(&item, sizeof(item));
            item.iItem = iItem;
            item.mask = LVIF_TEXT;
            item.iSubItem = 1;
            item.pszText = entry.szValue;
            ListView_SetItem(m_hLst1, &item);
        }
    }

    void OnOK(HWND hwnd)
    {
        INT nCount = ListView_GetItemCount(m_hLst1);

        MACRO_ENTRY entry;

        m_map.clear();
        for (INT i = 0; i < nCount; ++i)
        {
            ListView_GetItemText(m_hLst1, i, 0, entry.szKey, _countof(entry.szKey));
            ListView_GetItemText(m_hLst1, i, 1, entry.szValue, _countof(entry.szValue));
            m_map[entry.szKey] = entry.szValue;
        }

        EndDialog(IDOK);
    }

    void OnContextMenu(HWND hwnd, HWND hwndContext, UINT xPos, UINT yPos)
    {
        if (hwndContext == m_hLst1)
        {
            PopupMenuDx(hwnd, m_hLst1, IDR_POPUPMENUS, 4, xPos, yPos);
        }
    }

    void OnCommand(HWND hwnd, int id, HWND hwndCtl, UINT codeNotify)
    {
        switch (id)
        {
        case psh1:
        case ID_ADD:
            OnAdd(hwnd);
            break;
        case psh2:
        case ID_MODIFY:
            OnModify(hwnd);
            break;
        case psh3:
        case ID_DELETE:
            OnDelete(hwnd);
            break;
        case ID_RENAME:
            OnRename(hwnd);
            break;
        case IDOK:
            if (codeNotify == 0 || codeNotify == BN_CLICKED)
                OnOK(hwnd);
            break;
        case IDCANCEL:
            if (codeNotify == 0 || codeNotify == BN_CLICKED)
                EndDialog(IDCANCEL);
            break;
        case psh6:
            if (codeNotify == 0 || codeNotify == BN_CLICKED)
            {
                EndDialog(psh6);
            }
            break;
        case psh7:
            m_map.clear();
            ListView_DeleteAllItems(m_hLst1);
            OnItemChanged(hwnd);
            break;
        }
    }

    void OnRename(HWND hwnd)
    {
        INT iItem = ListView_GetNextItem(m_hLst1, -1, LVNI_ALL | LVNI_SELECTED);
        if (iItem < 0)
        {
            return;
        }

        ListView_EditLabel(m_hLst1, iItem);
    }

    LRESULT OnNotify(HWND hwnd, int idFrom, NMHDR *pnmhdr)
    {
        if (idFrom == lst1)
        {
            if (pnmhdr->code == LVN_KEYDOWN)
            {
                LV_KEYDOWN *KeyDown = (LV_KEYDOWN *)pnmhdr;
                if (KeyDown->wVKey == VK_DELETE)
                {
                    OnDelete(hwnd);
                    return 0;
                }
                if (KeyDown->wVKey == VK_F2)
                {
                    OnRename(hwnd);
                    return 0;
                }
            }
            if (pnmhdr->code == NM_DBLCLK)
            {
                OnModify(hwnd);
                return 0;
            }
            if (pnmhdr->code == LVN_BEGINLABELEDIT)
            {
                INT iItem = ListView_GetNextItem(m_hLst1, -1, LVNI_ALL | LVNI_SELECTED);
                if (iItem == -1)
                    return TRUE;
                LV_DISPINFO *pInfo = (LV_DISPINFO *)pnmhdr;
                pInfo->item.iItem = iItem;
                if (pInfo->item.pszText)
                    m_strTemp = pInfo->item.pszText;
                else
                    m_strTemp.clear();
                return 0;
            }
            if (pnmhdr->code == LVN_ENDLABELEDIT)
            {
                INT iItem = ListView_GetNextItem(m_hLst1, -1, LVNI_ALL | LVNI_SELECTED);
                if (iItem < 0)
                    return TRUE;

                LV_DISPINFO *pInfo = (LV_DISPINFO *)pnmhdr;

                if (pInfo->item.pszText == NULL)
                    return TRUE;

                auto it = m_map.find(pInfo->item.pszText);
                if (it != m_map.end())
                {
                    return TRUE;
                }

                MString strValue = m_map[m_strTemp];
                m_map.erase(m_strTemp);
                m_map[pInfo->item.pszText] = std::move(strValue);

                LV_ITEM item;
                ZeroMemory(&item, sizeof(item));
                item.iItem = iItem;
                item.mask = LVIF_TEXT;
                item.iSubItem = 0;
                item.pszText = pInfo->item.pszText;
                ListView_SetItem(m_hLst1, &item);
            }
            if (pnmhdr->code == LVN_GETINFOTIP)
            {
                NMLVGETINFOTIP *pGetInfoTip = (NMLVGETINFOTIP *)pnmhdr;
                INT iItem = pGetInfoTip->iItem;
                INT iSubItem = pGetInfoTip->iSubItem;
                TCHAR szText[128];
                ListView_GetItemText(m_hLst1, iItem, iSubItem, szText, _countof(szText));
                StringCchCopy(pGetInfoTip->pszText, pGetInfoTip->cchTextMax, szText);
            }
            if (pnmhdr->code == LVN_ITEMCHANGED)
            {
                //NM_LISTVIEW *pListView = (NM_LISTVIEW *)pnmhdr;
                OnItemChanged(hwnd);
            }
        }
        return 0;
    }

    void OnInitMenuPopup(HWND hwnd, HMENU hMenu, UINT item, BOOL fSystemMenu)
    {
        INT iItem = ListView_GetNextItem(m_hLst1, -1, LVNI_ALL | LVNI_SELECTED);
        if (iItem >= 0)
        {
            EnableMenuItem(hMenu, ID_MODIFY, MF_BYCOMMAND | MF_ENABLED);
            EnableMenuItem(hMenu, ID_DELETE, MF_BYCOMMAND | MF_ENABLED);
            EnableMenuItem(hMenu, ID_RENAME, MF_BYCOMMAND | MF_ENABLED);
        }
        else
        {
            EnableMenuItem(hMenu, ID_MODIFY, MF_BYCOMMAND | MF_GRAYED);
            EnableMenuItem(hMenu, ID_DELETE, MF_BYCOMMAND | MF_GRAYED);
            EnableMenuItem(hMenu, ID_RENAME, MF_BYCOMMAND | MF_GRAYED);
        }
    }

    void OnItemChanged(HWND hwnd)
    {
        INT iItem = ListView_GetNextItem(m_hLst1, -1, LVNI_ALL | LVNI_SELECTED);
        BOOL bSelected = (iItem != -1);
        EnableWindow(GetDlgItem(hwnd, psh2), bSelected);
        EnableWindow(GetDlgItem(hwnd, psh3), bSelected);
    }

    virtual INT_PTR CALLBACK
    DialogProcDx(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
    {
        switch (uMsg)
        {
            HANDLE_MSG(hwnd, WM_INITDIALOG, OnInitDialog);
            HANDLE_MSG(hwnd, WM_COMMAND, OnCommand);
            HANDLE_MSG(hwnd, WM_NOTIFY, OnNotify);
            HANDLE_MSG(hwnd, WM_SIZE, OnSize);
            HANDLE_MSG(hwnd, WM_CONTEXTMENU, OnContextMenu);
            HANDLE_MSG(hwnd, WM_INITMENUPOPUP, OnInitMenuPopup);
        }
        return DefaultProcDx();
    }

    void OnSize(HWND hwnd, UINT state, int cx, int cy)
    {
        m_resizable.OnSize();
    }

    BOOL OnInitDialog(HWND hwnd, HWND hwndFocus, LPARAM lParam)
    {
        m_hLst1 = GetDlgItem(hwnd, lst1);
        ListView_SetExtendedListViewStyle(m_hLst1, LVS_EX_FULLROWSELECT | LVS_EX_INFOTIP);

        LV_COLUMN column;
        ZeroMemory(&column, sizeof(column));

        column.mask = LVCF_FMT | LVCF_SUBITEM | LVCF_TEXT | LVCF_WIDTH;
        column.fmt = LVCFMT_LEFT;
        column.cx = 150;
        column.pszText = LoadStringDx(IDS_MACRONAME);
        column.iSubItem = 0;
        ListView_InsertColumn(m_hLst1, 0, &column);

        column.mask = LVCF_FMT | LVCF_SUBITEM | LVCF_TEXT | LVCF_WIDTH;
        column.fmt = LVCFMT_LEFT;
        column.cx = 300;
        column.pszText = LoadStringDx(IDS_MACROVALUE);
        column.iSubItem = 1;
        ListView_InsertColumn(m_hLst1, 1, &column);

        LV_ITEM item;
        INT iItem = 0;

        for (auto& pair : m_map)
        {
            ZeroMemory(&item, sizeof(item));
            item.iItem = iItem;
            item.mask = LVIF_TEXT;
            item.iSubItem = 0;
            item.pszText = const_cast<LPTSTR>(pair.first.c_str());
            ListView_InsertItem(m_hLst1, &item);

            ZeroMemory(&item, sizeof(item));
            item.iItem = iItem;
            item.mask = LVIF_TEXT;
            item.iSubItem = 1;
            item.pszText = const_cast<LPTSTR>(pair.second.c_str());
            ListView_SetItem(m_hLst1, &item);

            ++iItem;
        }

        m_resizable.OnParentCreate(hwnd);

        m_resizable.SetLayoutAnchor(lst1, mzcLA_TOP_LEFT, mzcLA_BOTTOM_RIGHT);
        m_resizable.SetLayoutAnchor(psh1, mzcLA_TOP_RIGHT);
        m_resizable.SetLayoutAnchor(psh2, mzcLA_TOP_RIGHT);
        m_resizable.SetLayoutAnchor(psh3, mzcLA_TOP_RIGHT);
        m_resizable.SetLayoutAnchor(psh4, mzcLA_TOP_RIGHT);
        m_resizable.SetLayoutAnchor(psh5, mzcLA_TOP_RIGHT);
        m_resizable.SetLayoutAnchor(psh7, mzcLA_TOP_RIGHT);
        m_resizable.SetLayoutAnchor(IDOK, mzcLA_BOTTOM_RIGHT);
        m_resizable.SetLayoutAnchor(IDCANCEL, mzcLA_BOTTOM_RIGHT);
        m_resizable.SetLayoutAnchor(psh6, mzcLA_BOTTOM_LEFT);

        SendMessageDx(WM_SETICON, ICON_BIG, (LPARAM)m_hIcon);
        SendMessageDx(WM_SETICON, ICON_SMALL, (LPARAM)m_hIconSm);

        UINT state = LVIS_SELECTED | LVIS_FOCUSED;
        ListView_SetItemState(m_hLst1, 0, state, state);
        ListView_EnsureVisible(m_hLst1, 0, FALSE);

        SetFocus(m_hLst1);

        CenterWindowDx();
        return TRUE;
    }
};

```

`src/MMessagesDlg.hpp`:

```hpp
// MMessagesDlg.hpp --- "String Table" Dialog
//////////////////////////////////////////////////////////////////////////////
// RisohEditor --- Another free Win32 resource editor
// Copyright (C) 2017-2018 Katayama Hirofumi MZ <katayama.hirofumi.mz@gmail.com>
// 
// This program is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
// 
// This program is distributed in the hope that it will be useful, 
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
// 
// You should have received a copy of the GNU General Public License
// along with this program.  If not, see <http://www.gnu.org/licenses/>.
//////////////////////////////////////////////////////////////////////////////

#pragma once

#include "resource.h"
#include "MWindowBase.hpp"
#include "RisohSettings.hpp"
#include "ConstantsDB.hpp"
#include "Res.hpp"
#include "MResizable.hpp"
#include "MComboBoxAutoComplete.hpp"
#include "MessageRes.hpp"
#include "Common.hpp"

class MAddMsgDlg;
class MModifyMsgDlg;
class MMessagesDlg;

BOOL MsgDlg_GetEntry(HWND hwnd, MESSAGE_ENTRY& entry);
void MsgDlg_SetEntry(HWND hwnd, MESSAGE_ENTRY& entry);

//////////////////////////////////////////////////////////////////////////////

class MAddMsgDlg : public MDialogBase
{
public:
    MESSAGE_ENTRY& m_entry;
    MessageRes& m_msg_res;
    MComboBoxAutoComplete m_cmb1;

    MAddMsgDlg(MESSAGE_ENTRY& entry, MessageRes& msg_res)
        : MDialogBase(IDD_ADDMSG), m_entry(entry), m_msg_res(msg_res)
    {
        m_cmb1.m_bAcceptSpace = TRUE;
    }

    BOOL OnInitDialog(HWND hwnd, HWND hwndFocus, LPARAM lParam)
    {
        HWND hCmb1 = GetDlgItem(hwnd, cmb1);
        InitMessageComboBox(hCmb1, L"");
        SubclassChildDx(m_cmb1, cmb1);

        CenterWindowDx();
        return TRUE;
    }

    void OnOK(HWND hwnd)
    {
        HWND hCmb1 = GetDlgItem(hwnd, cmb1);
        if (!MsgDlg_GetEntry(hwnd, m_entry))
        {
            ComboBox_SetEditSel(hCmb1, 0, -1);
            SetFocus(hCmb1);
            ErrorBoxDx(IDS_NOSUCHID);
            return;
        }
        INT value;
        if (g_db.HasResID(m_entry.MessageID))
        {
            value = g_db.GetResIDValue(m_entry.MessageID);
        }
        else
        {
            value = mstr_parse_int(m_entry.MessageID);
        }
        if (m_msg_res.map().find(value) != m_msg_res.map().end())
        {
            ComboBox_SetEditSel(hCmb1, 0, -1);
            SetFocus(hCmb1);
            ErrorBoxDx(IDS_ALREADYEXISTS);
            return;
        }

        EndDialog(IDOK);
    }

    void OnCommand(HWND hwnd, int id, HWND hwndCtl, UINT codeNotify)
    {
        switch (id)
        {
        case IDOK:
            OnOK(hwnd);
            break;
        case IDCANCEL:
            EndDialog(IDCANCEL);
            break;
        case psh1:
            OnPsh1(hwnd);
            break;
        case cmb1:
            if (codeNotify == CBN_EDITCHANGE)
            {
                m_cmb1.OnEditChange();
            }
            break;
        }
    }

    void OnPsh1(HWND hwnd)
    {
        SendMessage(GetParent(GetParent(hwnd)), WM_COMMAND, ID_IDLIST, 0);
    }

    virtual INT_PTR CALLBACK
    DialogProcDx(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
    {
        switch (uMsg)
        {
            HANDLE_MSG(hwnd, WM_INITDIALOG, OnInitDialog);
            HANDLE_MSG(hwnd, WM_COMMAND, OnCommand);
        }
        return 0;
    }
};

//////////////////////////////////////////////////////////////////////////////

class MModifyMsgDlg : public MDialogBase
{
public:
    MESSAGE_ENTRY& m_entry;
    MessageRes& m_msg_res;
    MComboBoxAutoComplete m_cmb1;

    MModifyMsgDlg(MESSAGE_ENTRY& entry, MessageRes& msg_res)
        : MDialogBase(IDD_MODIFYMSG), m_entry(entry), m_msg_res(msg_res)
    {
        m_cmb1.m_bAcceptSpace = TRUE;
    }

    BOOL OnInitDialog(HWND hwnd, HWND hwndFocus, LPARAM lParam)
    {
        HWND hCmb1 = GetDlgItem(hwnd, cmb1);
        InitMessageComboBox(hCmb1, L"");
        SubclassChildDx(m_cmb1, cmb1);

        MsgDlg_SetEntry(hwnd, m_entry);
        CenterWindowDx();
        return TRUE;
    }

    void OnOK(HWND hwnd)
    {
        if (!MsgDlg_GetEntry(hwnd, m_entry))
        {
            ErrorBoxDx(IDS_NOSUCHID);
            return;
        }
        EndDialog(IDOK);
    }

    void OnCommand(HWND hwnd, int id, HWND hwndCtl, UINT codeNotify)
    {
        switch (id)
        {
        case IDOK:
            OnOK(hwnd);
            break;
        case IDCANCEL:
            EndDialog(IDCANCEL);
            break;
        case psh1:
            OnPsh1(hwnd);
            break;
        case cmb1:
            if (codeNotify == CBN_EDITCHANGE)
            {
                m_cmb1.OnEditChange();
            }
            break;
        }
    }

    void OnPsh1(HWND hwnd)
    {
        SendMessage(GetParent(GetParent(hwnd)), WM_COMMAND, ID_IDLIST, 0);
    }

    virtual INT_PTR CALLBACK
    DialogProcDx(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
    {
        switch (uMsg)
        {
            HANDLE_MSG(hwnd, WM_INITDIALOG, OnInitDialog);
            HANDLE_MSG(hwnd, WM_COMMAND, OnCommand);
        }
        return DefaultProcDx();
    }
};

//////////////////////////////////////////////////////////////////////////////

class MMessagesDlg : public MDialogBase
{
public:
    MessageRes m_msg_res;
    MResizable m_resizable;
    HICON m_hIcon;
    HICON m_hIconSm;
    HWND m_hLst1;

    MMessagesDlg(MessageRes& msg_res)
        : MDialogBase(IDD_MESSAGES), m_msg_res(msg_res)
    {
        m_hIcon = LoadIconDx(IDI_SMILY);
        m_hIconSm = LoadSmallIconDx(IDI_SMILY);
    }

    ~MMessagesDlg()
    {
        DestroyIcon(m_hIcon);
        DestroyIcon(m_hIconSm);
    }

    void InitCtl1(HWND hLst1)
    {
        ListView_DeleteAllItems(m_hLst1);

        typedef MessageRes::map_type map_type;
        const map_type& map = m_msg_res.map();

        INT i = 0;
        for (auto& pair : map)
        {
            if (pair.second.empty())
                continue;

            MStringW str = g_db.GetNameOfResID(IDTYPE_MESSAGE, pair.first);

            LV_ITEM item;
            ZeroMemory(&item, sizeof(item));
            item.iItem = i;
            item.mask = LVIF_TEXT;
            item.iSubItem = 0;
            item.pszText = &str[0];
            ListView_InsertItem(m_hLst1, &item);

            str = mstr_quote(pair.second);

            ZeroMemory(&item, sizeof(item));
            item.iItem = i;
            item.mask = LVIF_TEXT;
            item.iSubItem = 1;
            item.pszText = &str[0];
            ListView_SetItem(m_hLst1, &item);

            ++i;
        }
    }

    BOOL OnInitDialog(HWND hwnd, HWND hwndFocus, LPARAM lParam)
    {
        m_hLst1 = GetDlgItem(hwnd, lst1);
        ListView_SetExtendedListViewStyle(m_hLst1, LVS_EX_FULLROWSELECT | LVS_EX_INFOTIP);

        LV_COLUMN column;
        ZeroMemory(&column, sizeof(column));

        column.mask = LVCF_FMT | LVCF_SUBITEM | LVCF_TEXT | LVCF_WIDTH;
        column.fmt = LVCFMT_LEFT;
        column.cx = 140;
        column.pszText = LoadStringDx(IDS_MESSAGEID);
        column.iSubItem = 0;
        ListView_InsertColumn(m_hLst1, 0, &column);

        column.mask = LVCF_FMT | LVCF_SUBITEM | LVCF_TEXT | LVCF_WIDTH;
        column.fmt = LVCFMT_LEFT;
        column.cx = 500;
        column.pszText = LoadStringDx(IDS_MESSAGEVALUE);
        column.iSubItem = 1;
        ListView_InsertColumn(m_hLst1, 1, &column);

        InitCtl1(m_hLst1);

        UINT state = LVIS_SELECTED | LVIS_FOCUSED;
        ListView_SetItemState(m_hLst1, 0, state, state);
        SetFocus(m_hLst1);

        m_resizable.OnParentCreate(hwnd);

        m_resizable.SetLayoutAnchor(lst1, mzcLA_TOP_LEFT, mzcLA_BOTTOM_RIGHT);
        m_resizable.SetLayoutAnchor(psh1, mzcLA_TOP_RIGHT);
        m_resizable.SetLayoutAnchor(psh2, mzcLA_TOP_RIGHT);
        m_resizable.SetLayoutAnchor(psh3, mzcLA_TOP_RIGHT);
        m_resizable.SetLayoutAnchor(psh4, mzcLA_BOTTOM_LEFT);
        m_resizable.SetLayoutAnchor(IDOK, mzcLA_BOTTOM_RIGHT);
        m_resizable.SetLayoutAnchor(IDCANCEL, mzcLA_BOTTOM_RIGHT);

        SendMessageDx(WM_SETICON, ICON_BIG, (LPARAM)m_hIcon);
        SendMessageDx(WM_SETICON, ICON_SMALL, (LPARAM)m_hIconSm);

        CenterWindowDx();
        return TRUE;
    }

    void OnAdd(HWND hwnd)
    {
        MESSAGE_ENTRY me;
        ZeroMemory(&me, sizeof(me));
        MAddMsgDlg dialog(me, m_msg_res);
        if (dialog.DialogBoxDx(hwnd) != IDOK)
        {
            return;
        }

        INT iItem;

        LV_FINDINFO find;
        TCHAR sz[128];
        StringCchCopy(sz, _countof(sz), me.MessageID);
        ZeroMemory(&find, sizeof(find));
        find.flags = LVFI_STRING;
        find.psz = sz;
        iItem = ListView_FindItem(m_hLst1, -1, &find);
        if (iItem != -1)
        {
            ListView_DeleteItem(m_hLst1, iItem);
        }

        LV_ITEM item;
        iItem = ListView_GetItemCount(m_hLst1);

        ZeroMemory(&item, sizeof(item));
        item.iItem = iItem;
        item.mask = LVIF_TEXT;
        item.iSubItem = 0;
        item.pszText = me.MessageID;
        ListView_InsertItem(m_hLst1, &item);

        std::wstring str = me.MessageValue;
        str = mstr_quote(str);

        ZeroMemory(&item, sizeof(item));
        item.iItem = iItem;
        item.mask = LVIF_TEXT;
        item.iSubItem = 1;
        item.pszText = &str[0];
        ListView_SetItem(m_hLst1, &item);

        UINT state = LVIS_SELECTED | LVIS_FOCUSED;
        ListView_SetItemState(m_hLst1, iItem, state, state);
        ListView_EnsureVisible(m_hLst1, iItem, FALSE);

        ULONG dwValue = g_db.GetResIDValue(me.MessageID);
        m_msg_res.m_map[dwValue] = me.MessageValue;
    }

    void GetEntry(HWND hwnd, INT iItem, MESSAGE_ENTRY& entry)
    {
        ListView_GetItemText(m_hLst1, iItem, 0, entry.MessageID, _countof(entry.MessageID));
        mstr_trim(entry.MessageID);

        ListView_GetItemText(m_hLst1, iItem, 1, entry.MessageValue, _countof(entry.MessageValue));
        mstr_trim(entry.MessageValue);
        if (entry.MessageValue[0] == L'"')
        {
            mstr_unquote(entry.MessageValue);
        }
    }

    void OnDelete(HWND hwnd)
    {
        INT iItem = ListView_GetNextItem(m_hLst1, -1, LVNI_ALL | LVNI_SELECTED);
        if (iItem >= 0)
        {
            MESSAGE_ENTRY me;
            GetEntry(hwnd, iItem, me);

            ULONG dwValue = g_db.GetResIDValue(me.MessageID);
            m_msg_res.m_map.erase(dwValue);

            ListView_DeleteItem(m_hLst1, iItem);
        }
    }

    void OnDeleteAll(HWND hwnd)
    {
        m_msg_res.m_map.clear();
        ListView_DeleteAllItems(m_hLst1);
    }

    void OnModify(HWND hwnd)
    {
        INT iItem = ListView_GetNextItem(m_hLst1, -1, LVNI_ALL | LVNI_SELECTED);
        if (iItem < 0)
        {
            return;
        }

        MESSAGE_ENTRY me;
        GetEntry(hwnd, iItem, me);

        MModifyMsgDlg dialog(me, m_msg_res);
        if (IDOK == dialog.DialogBoxDx(hwnd))
        {
            MString str = mstr_quote(me.MessageValue);
            ListView_SetItemText(m_hLst1, iItem, 1, &str[0]);

            ULONG dwValue = g_db.GetResIDValue(me.MessageID);
            m_msg_res.m_map[dwValue] = std::move(str);
        }
    }

    void OnOK(HWND hwnd)
    {
        INT iItem, nCount = ListView_GetItemCount(m_hLst1);
        if (nCount == 0)
        {
            ErrorBoxDx(IDS_DATAISEMPTY);
            return;
        }

        m_msg_res.map().clear();

        MESSAGE_ENTRY me;
        for (iItem = 0; iItem < nCount; ++iItem)
        {
            GetEntry(hwnd, iItem, me);

            DWORD dwID = g_db.GetResIDValue(me.MessageID);
            std::wstring str = me.MessageValue;

            m_msg_res.map().insert(std::make_pair(dwID, str));
        }

        EndDialog(IDOK);
    }

    void OnContextMenu(HWND hwnd, HWND hwndContext, UINT xPos, UINT yPos)
    {
        if (hwndContext == m_hLst1)
        {
            PopupMenuDx(hwnd, m_hLst1, IDR_POPUPMENUS, 4, xPos, yPos);
        }
    }

    void OnCommand(HWND hwnd, int id, HWND hwndCtl, UINT codeNotify)
    {
        switch (id)
        {
        case psh1:
        case ID_ADD:
            OnAdd(hwnd);
            break;
        case psh2:
        case ID_MODIFY:
            OnModify(hwnd);
            break;
        case psh3:
        case ID_DELETE:
            OnDelete(hwnd);
            break;
        case psh4:
            OnDeleteAll(hwnd);
            break;
        case IDOK:
            OnOK(hwnd);
            break;
        case IDCANCEL:
            EndDialog(IDCANCEL);
            break;
        }
    }

    LRESULT OnNotify(HWND hwnd, int idFrom, NMHDR *pnmhdr)
    {
        if (idFrom == lst1)
        {
            if (pnmhdr->code == LVN_KEYDOWN)
            {
                LV_KEYDOWN *KeyDown = (LV_KEYDOWN *)pnmhdr;
                if (KeyDown->wVKey == VK_DELETE)
                {
                    OnDelete(hwnd);
                    return 0;
                }
            }
            if (pnmhdr->code == NM_DBLCLK)
            {
                OnModify(hwnd);
                return 0;
            }
            if (pnmhdr->code == LVN_GETINFOTIP)
            {
                NMLVGETINFOTIP *pGetInfoTip = (NMLVGETINFOTIP *)pnmhdr;
                INT iItem = pGetInfoTip->iItem;
                INT iSubItem = pGetInfoTip->iSubItem;
                TCHAR szText[128];
                ListView_GetItemText(m_hLst1, iItem, iSubItem, szText, _countof(szText));
                StringCchCopy(pGetInfoTip->pszText, pGetInfoTip->cchTextMax, szText);
            }
            if (pnmhdr->code == LVN_ITEMCHANGED)
            {
                //NM_LISTVIEW *pListView = (NM_LISTVIEW *)pnmhdr;
                OnItemChanged(hwnd);
            }
        }
        return 0;
    }

    void OnSize(HWND hwnd, UINT state, int cx, int cy)
    {
        m_resizable.OnSize();
    }

    void OnInitMenuPopup(HWND hwnd, HMENU hMenu, UINT item, BOOL fSystemMenu)
    {
        INT iItem = ListView_GetNextItem(m_hLst1, -1, LVNI_ALL | LVNI_SELECTED);
        if (iItem >= 0)
        {
            EnableMenuItem(hMenu, ID_MODIFY, MF_BYCOMMAND | MF_ENABLED);
            EnableMenuItem(hMenu, ID_DELETE, MF_BYCOMMAND | MF_ENABLED);
        }
        else
        {
            EnableMenuItem(hMenu, ID_MODIFY, MF_BYCOMMAND | MF_GRAYED);
            EnableMenuItem(hMenu, ID_DELETE, MF_BYCOMMAND | MF_GRAYED);
        }
        EnableMenuItem(hMenu, ID_RENAME, MF_BYCOMMAND | MF_GRAYED);
    }

    void OnItemChanged(HWND hwnd)
    {
        INT iItem = ListView_GetNextItem(m_hLst1, -1, LVNI_ALL | LVNI_SELECTED);
        BOOL bSelected = (iItem != -1);
        EnableWindow(GetDlgItem(hwnd, psh2), bSelected);
        EnableWindow(GetDlgItem(hwnd, psh3), bSelected);
    }

    virtual INT_PTR CALLBACK
    DialogProcDx(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
    {
        switch (uMsg)
        {
            HANDLE_MSG(hwnd, WM_INITDIALOG, OnInitDialog);
            HANDLE_MSG(hwnd, WM_COMMAND, OnCommand);
            HANDLE_MSG(hwnd, WM_NOTIFY, OnNotify);
            HANDLE_MSG(hwnd, WM_SIZE, OnSize);
            HANDLE_MSG(hwnd, WM_CONTEXTMENU, OnContextMenu);
            HANDLE_MSG(hwnd, WM_INITMENUPOPUP, OnInitMenuPopup);
        }
        return DefaultProcDx();
    }
};

```

`src/MModifyAssocDlg.hpp`:

```hpp
// MModifyAssocDlg.hpp --- "Modify Association" Dialog
//////////////////////////////////////////////////////////////////////////////
// RisohEditor --- Another free Win32 resource editor
// Copyright (C) 2017-2018 Katayama Hirofumi MZ <katayama.hirofumi.mz@gmail.com>
// 
// This program is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
// 
// This program is distributed in the hope that it will be useful, 
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
// 
// You should have received a copy of the GNU General Public License
// along with this program.  If not, see <http://www.gnu.org/licenses/>.
//////////////////////////////////////////////////////////////////////////////

#pragma once

#include "MWindowBase.hpp"
#include "MString.hpp"

//////////////////////////////////////////////////////////////////////////////

class MModifyAssocDlg : public MDialogBase
{
public:
    MString& m_text1;
    MString& m_text2;

    MModifyAssocDlg(MString& text1, MString& text2)
        : MDialogBase(IDD_MODIFYASSOC), m_text1(text1), m_text2(text2)
    {
    }

    BOOL OnInitDialog(HWND hwnd, HWND hwndFocus, LPARAM lParam)
    {
        SetDlgItemText(hwnd, edt1, m_text1.c_str());
        SetDlgItemText(hwnd, edt2, m_text2.c_str());
        CenterWindowDx();
        return TRUE;
    }

    void OnOK(HWND hwnd)
    {
        MString str = GetDlgItemText(edt2);
        mstr_trim(str);

        if (str.empty())
        {
            HWND hEdt2 = GetDlgItem(hwnd, edt2);
            Edit_SetSel(hEdt2, 0, -1);
            SetFocus(hEdt2);
            ErrorBoxDx(IDS_EMPTYSTR);
            return;
        }

        m_text2 = str;
        EndDialog(IDOK);
    }

    void OnCommand(HWND hwnd, int id, HWND hwndCtl, UINT codeNotify)
    {
        switch (id)
        {
        case IDOK:
            OnOK(hwnd);
            break;
        case IDCANCEL:
            EndDialog(IDCANCEL);
            break;
        }
    }

    virtual INT_PTR CALLBACK
    DialogProcDx(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
    {
        switch (uMsg)
        {
        HANDLE_MSG(hwnd, WM_INITDIALOG, OnInitDialog);
        HANDLE_MSG(hwnd, WM_COMMAND, OnCommand);
        default:
            return DefaultProcDx();
        }
    }
};

```

`src/MModifyResIDDlg.hpp`:

```hpp
// MModifyResIDDlg.hpp --- "Modify Resource ID" Dialog
//////////////////////////////////////////////////////////////////////////////
// RisohEditor --- Another free Win32 resource editor
// Copyright (C) 2017-2018 Katayama Hirofumi MZ <katayama.hirofumi.mz@gmail.com>
// 
// This program is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
// 
// This program is distributed in the hope that it will be useful, 
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
// 
// You should have received a copy of the GNU General Public License
// along with this program.  If not, see <http://www.gnu.org/licenses/>.
//////////////////////////////////////////////////////////////////////////////

#pragma once

#include "resource.h"
#include "MWindowBase.hpp"
#include "RisohSettings.hpp"
#include "ConstantsDB.hpp"
#include "Res.hpp"
#include "Common.hpp"

//////////////////////////////////////////////////////////////////////////////

class MModifyResIDDlg : public MDialogBase
{
public:
    MString m_str1;
    MString m_str2;

    MModifyResIDDlg(MString str1, MString str2)
        : MDialogBase(IDD_MODIFYRESID), m_str1(str1), m_str2(str2)
    {
    }

    BOOL OnInitDialog(HWND hwnd, HWND hwndFocus, LPARAM lParam)
    {
        SetDlgItemText(hwnd, edt1, m_str1.c_str());

        int value = mstr_parse_int(m_str2.c_str(), true);
        SetDlgItemInt(hwnd, edt3, value, TRUE);

        SendDlgItemMessage(hwnd, scr1, UDM_SETRANGE, 0,
                           MAKELPARAM((WORD)SHRT_MAX, (WORD)SHRT_MIN));

        CenterWindowDx();
        return TRUE;
    }

    void OnOK(HWND hwnd)
    {
        MString str1 = GetDlgItemText(hwnd, edt1);
        ReplaceFullWithHalf(str1);
        mstr_trim(str1);
        if (str1.empty())
        {
            HWND hEdt1 = GetDlgItem(hwnd, edt1);
            Edit_SetSel(hEdt1, 0, -1);
            SetFocus(hEdt1);
            ErrorBoxDx(IDS_ENTERTEXT);
            return;
        }
        m_str1 = std::move(str1);

        MString str2 = GetDlgItemText(hwnd, edt1);
        mstr_trim(str2);
        if (str2.empty())
        {
            HWND hEdt1 = GetDlgItem(hwnd, edt1);
            Edit_SetSel(hEdt1, 0, -1);
            SetFocus(hEdt1);
            ErrorBoxDx(IDS_ENTERID);
            return;
        }

        MString str3 = GetDlgItemText(hwnd, edt3);
        ReplaceFullWithHalf(str3);
        mstr_trim(str3);
        if (str3.empty())
        {
            HWND hEdt3 = GetDlgItem(hwnd, edt3);
            Edit_SetSel(hEdt3, 0, -1);
            SetFocus(hEdt3);
            ErrorBoxDx(IDS_ENTERTEXT);
            return;
        }
        m_str2 = std::move(str3);

        EndDialog(IDOK);
    }

    void OnCommand(HWND hwnd, int id, HWND hwndCtl, UINT codeNotify)
    {
        switch (id)
        {
        case IDOK:
            OnOK(hwnd);
            break;
        case IDCANCEL:
            EndDialog(IDCANCEL);
            break;
        case edt1:
            if (codeNotify == EN_CHANGE)
            {
                MString text = GetDlgItemText(hwnd, edt1);

                ConstantsDB::TableType table;
                table = g_db.GetTable(L"RESOURCE.ID.PREFIX");

                INT i = 0;
                for (auto& table_entry : table)
                {
                    if (text.find(table_entry.name) == 0)
                    {
                        text = g_db.GetName(L"RESOURCE.ID.TYPE", i);
                        SetDlgItemText(hwnd, edt2, text.c_str());
                        i = -1;
                        break;
                    }
                    ++i;
                }
                if (i != -1)
                {
                    SetDlgItemText(hwnd, edt2, NULL);
                }
            }
            break;
        }
    }

    virtual INT_PTR CALLBACK
    DialogProcDx(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
    {
        switch (uMsg)
        {
            HANDLE_MSG(hwnd, WM_INITDIALOG, OnInitDialog);
            HANDLE_MSG(hwnd, WM_COMMAND, OnCommand);
        }
        return DefaultProcDx();
    }
};

```

`src/MOleHost.cpp`:

```cpp
#include "MWindowBase.hpp"
#include "MOleHost.hpp"
#include <oledlg.h>

#define ID_VERBMIN 10000
#define ID_VERBMAX 10031

static const CLSID CLSID_SampleFile =
    {0x9f05f2d2, 0x9ec3, 0x53ac, {0xc6, 0xff, 0x20, 0x7e, 0x3f, 0x8a, 0x97, 0xff}};

static MOleHost *s_pHost = NULL;

MOleHost *DoGetActiveOleHost(void)
{
    assert(s_pHost != NULL);
    return s_pHost;
}

void DoSetActiveOleHost(MOleHost *pHost)
{
    s_pHost = pHost;
}

IMPLEMENT_DYNAMIC(MOleSite)

//////////////////////////////////////////////////////////////////////////////
// MOleSite

MOleSite::MOleSite()
    : m_pNext(NULL)
    , m_cRef(1)
    , m_dwConnection(0)
    , m_bEnableMenu(FALSE)
    , m_pOleObject(NULL)
    , m_pStorage(NULL)
    , m_pHost(NULL)
{
    ::SetRectEmpty(&m_rc);
}

MOleSite::~MOleSite()
{
    DoDestroy();
}

BOOL MOleSite::OnCreate(HWND hwnd, LPCREATESTRUCT lpCreateStruct)
{
    WCHAR szText[40];
    GetWindowTextW(hwnd, szText, _countof(szText));

    CLSID clsid;
    if (szText[0] != L'{' || ::CLSIDFromString(szText, &clsid) != S_OK)
        return FALSE;

    m_pHost = DoGetActiveOleHost();
    if (m_pHost == NULL)
        return FALSE;

    return m_pHost->DoInsertObject(this, clsid);
}

void MOleSite::DoDestroy()
{
    if (m_pOleObject)
    {
        DoCloseObject();
        m_pOleObject->Release();
        m_pOleObject = NULL;
    }

    if (m_pStorage)
    {
        m_pStorage->Release();
        m_pStorage = NULL;
    }
}

void MOleSite::OnDestroy(HWND hwnd)
{
    DoDestroy();
}

void MOleSite::DoEnableMenu(BOOL bEnable)
{
    m_bEnableMenu = bEnable;
}

void MOleSite::OnLButtonDown(HWND hwnd, BOOL fDoubleClick, int x, int y, UINT keyFlags)
{
    if (fDoubleClick)
    {
        if (m_bEnableMenu)
            DoRunObject(OLEIVERB_PRIMARY);
    }
}

void MOleSite::OnRButtonDown(HWND hwnd, BOOL fDoubleClick, int x, int y, UINT keyFlags)
{
    if (!m_bEnableMenu)
        return;

    HMENU hMenu = CreatePopupMenu(), hmenuTmp;
    ::OleUIAddVerbMenu(m_pOleObject, NULL, hMenu, 0, ID_VERBMIN, ID_VERBMAX, FALSE, 0, &hmenuTmp);

    POINT pt = { x, y };
    ::ClientToScreen(hwnd, &pt);

    SetForegroundWindow(hwnd);
    INT nCmd = TrackPopupMenu(hMenu, TPM_RETURNCMD, pt.x, pt.y, 0, hwnd, NULL);
    DestroyMenu(hMenu);
    PostMessageW(hwnd, WM_NULL, 0, 0);

    PostMessageW(hwnd, WM_COMMAND, nCmd, 0);
}

void MOleSite::OnCommand(HWND hwnd, int id, HWND hwndCtl, UINT codeNotify)
{
    if (!m_bEnableMenu)
        return;

    if (ID_VERBMIN <= id && id <= ID_VERBMAX)
        DoRunObject(id);
}

void MOleSite::OnMove(HWND hwnd, int x, int y)
{
    RECT rc;
    ::GetClientRect(hwnd, &rc);
    m_rc = rc;

    if (!m_pOleObject)
        return;

    IOleInPlaceObject *pipo = NULL;
    m_pOleObject->QueryInterface(IID_IOleInPlaceObject, (void **)&pipo);
    if (pipo)
    {
        pipo->SetObjectRects(&m_rc, &m_rc);
        pipo->Release();
    }

    DoUpdateRect();
}

void MOleSite::OnSize(HWND hwnd, UINT state, int cx, int cy)
{
    RECT rc;
    ::GetClientRect(hwnd, &rc);
    m_rc = rc;

    if (!m_pOleObject)
        return;

    IOleInPlaceObject *pipo = NULL;
    m_pOleObject->QueryInterface(IID_IOleInPlaceObject, (void **)&pipo);
    if (pipo)
    {
        pipo->SetObjectRects(&m_rc, &m_rc);
        pipo->Release();
    }

    SIZEL sizel = { rc.right - rc.left, rc.bottom - rc.top };
    DoDPtoHIMETRIC(&sizel);
    m_pOleObject->SetExtent(DVASPECT_CONTENT, &sizel);
}

void MOleSite::OnPaint(HWND hwnd)
{
    PAINTSTRUCT ps;
    if (HDC hdc = ::BeginPaint(hwnd, &ps))
    {
        ::OleDraw(m_pOleObject, DVASPECT_CONTENT, hdc, &m_rc);
        ::EndPaint(hwnd, &ps);
    }
}

STDMETHODIMP MOleSite::QueryInterface(REFIID riid, void **ppvObject)
{
    *ppvObject = NULL;

    if (riid == IID_IUnknown || riid == IID_IOleClientSite)
        *ppvObject = static_cast<IOleClientSite *>(this);
    else if (riid == IID_IAdviseSink)
        *ppvObject = static_cast<IAdviseSink *>(this);
    else
        return E_NOINTERFACE;

    AddRef();
    return S_OK;
}

STDMETHODIMP_(ULONG) MOleSite::AddRef()
{
    return InterlockedIncrement(&m_cRef);
}

STDMETHODIMP_(ULONG) MOleSite::Release()
{
    if (InterlockedDecrement(&m_cRef) == 0)
    {
        delete this;
        return 0;
    }
    return m_cRef;
}

STDMETHODIMP MOleSite::SaveObject()
{
    DoSave();
    DoUpdateRect();
    InvalidateRect(GetParent(m_hwnd), NULL, TRUE);
    return S_OK;
}

STDMETHODIMP MOleSite::GetMoniker(DWORD dwAssign, DWORD dwWhichMoniker, IMoniker **ppmk)
{
    return E_NOTIMPL;
}

STDMETHODIMP MOleSite::GetContainer(IOleContainer **ppContainer)
{
    *ppContainer = NULL;
    return E_NOINTERFACE;
}

STDMETHODIMP MOleSite::ShowObject()
{
    return S_OK;
}

STDMETHODIMP MOleSite::OnShowWindow(BOOL fShow)
{
    return S_OK;
}

STDMETHODIMP MOleSite::RequestNewObjectLayout()
{
    return E_NOTIMPL;
}

STDMETHODIMP_(void) MOleSite::OnDataChange(FORMATETC *pFormatetc, STGMEDIUM *pStgmed)
{
}

STDMETHODIMP_(void) MOleSite::OnViewChange(DWORD dwAspect, LONG lindex)
{
    InvalidateRect(GetParent(m_hwnd), NULL, TRUE);
}

STDMETHODIMP_(void) MOleSite::OnRename(IMoniker *pmk)
{
}

STDMETHODIMP_(void) MOleSite::OnSave()
{
}

STDMETHODIMP_(void) MOleSite::OnClose()
{
}

void MOleSite::DoInit(MOleHost *pHost, IOleObject *pOleObject, IStorage *pStorage,
                      LPCWSTR lpszObjectName)
{
    m_pHost = pHost;
    m_pStorage = pStorage;
    m_pOleObject = pOleObject;
    m_pOleObject->SetClientSite(static_cast<IOleClientSite *>(this));
    m_pOleObject->SetHostNames(L"RisohEditor", lpszObjectName);

    OnSize(m_hwnd, SIZE_RESTORED, 0, 0);
}

void MOleSite::DoSave()
{
    IPersistStorage *pPersistStorage = NULL;
    m_pOleObject->QueryInterface(IID_IPersistStorage, (void **)&pPersistStorage);
    if (pPersistStorage)
    {
        ::OleSave(pPersistStorage, m_pStorage, TRUE);

        pPersistStorage->SaveCompleted(NULL);
        pPersistStorage->Release();
    }
}

void MOleSite::DoRunObject(LONG nVerb)
{
    m_pOleObject->Advise(static_cast<IAdviseSink *>(this), &m_dwConnection);

    IViewObject *pViewObject = NULL;
    m_pOleObject->QueryInterface(IID_IViewObject, (void **)&pViewObject);
    if (pViewObject)
    {
        pViewObject->SetAdvise(DVASPECT_CONTENT, 0, static_cast<IAdviseSink *>(this));
        pViewObject->Release();
    }

    m_pOleObject->DoVerb(nVerb, NULL, static_cast<IOleClientSite *>(this), 0, m_hwnd, &m_rc);
}

void MOleSite::DoCloseObject()
{
    if (m_pOleObject && ::OleIsRunning(m_pOleObject))
    {
        IOleInPlaceObject *pipo = NULL;
        m_pOleObject->QueryInterface(IID_IOleInPlaceObject, (void **)&pipo);
        if (pipo)
        {
            pipo->UIDeactivate();
            pipo->InPlaceDeactivate();
            pipo->Release();
        }

        m_pOleObject->Close(OLECLOSE_NOSAVE);
        m_pOleObject->Unadvise(m_dwConnection);
        m_pOleObject->SetClientSite(NULL);
    }
}

void MOleSite::DoUpdateRect()
{
    SIZEL sizel;
    m_pOleObject->GetExtent(DVASPECT_CONTENT, &sizel);

    DoHIMETRICtoDP(&sizel);
    m_rc.right = m_rc.left + sizel.cx;
    m_rc.bottom = m_rc.top + sizel.cy;
}

void MOleSite::DoDPtoHIMETRIC(LPSIZEL lpSizel)
{
    const INT HIMETRIC_INCH = 2540;

    HDC hdc = GetDC(NULL);
    lpSizel->cx = lpSizel->cx * HIMETRIC_INCH / GetDeviceCaps(hdc, LOGPIXELSX);
    lpSizel->cy = lpSizel->cy * HIMETRIC_INCH / GetDeviceCaps(hdc, LOGPIXELSY);
    ReleaseDC(NULL, hdc);
}

void MOleSite::DoHIMETRICtoDP(LPSIZEL lpSizel)
{
    const INT HIMETRIC_INCH = 2540;

    HDC hdc = GetDC(NULL);
    lpSizel->cx = lpSizel->cx * GetDeviceCaps(hdc, LOGPIXELSX) / HIMETRIC_INCH;
    lpSizel->cy = lpSizel->cy * GetDeviceCaps(hdc, LOGPIXELSY) / HIMETRIC_INCH;
    ReleaseDC(NULL, hdc);
}

//////////////////////////////////////////////////////////////////////////////
// MOleHost

MOleHost::MOleHost()
    : m_cObjects(0)
    , m_pRootStorage(NULL)
    , m_pStream(NULL)
    , m_pSite(NULL)
{
    DoCreateRootStorage(NULL);
}

MOleHost::~MOleHost()
{
    DoDestroy();
}

BOOL MOleHost::DoCreateRootStorage(LPCWSTR lpszFileName)
{
    static const WCHAR szStreamName[] = L"stream";
    if (lpszFileName == NULL)
    {
        StgCreateDocfile(NULL, STGM_READWRITE | STGM_TRANSACTED, 0, &m_pRootStorage);
        if (m_pRootStorage == NULL)
            return FALSE;

        WriteClassStg(m_pRootStorage, CLSID_SampleFile);

        m_pRootStorage->CreateStream(szStreamName, STGM_READWRITE | STGM_SHARE_EXCLUSIVE, 0, 0, &m_pStream);
        if (m_pStream == NULL)
            return FALSE;

        return TRUE;
    }

    IStorage *pStorage = NULL;
    StgOpenStorage(lpszFileName, NULL, STGM_READWRITE | STGM_TRANSACTED, NULL, 0, &pStorage);
    if (pStorage == NULL)
        return FALSE;

    CLSID clsid;
    ReadClassStg(pStorage, &clsid);
    if (!IsEqualCLSID(clsid, CLSID_SampleFile))
    {
        pStorage->Release();
        return FALSE;
    }

    IStream *pStream = NULL;
    pStorage->OpenStream(szStreamName, NULL, STGM_READWRITE | STGM_SHARE_EXCLUSIVE, 0, &pStream);
    if (pStream == NULL)
    {
        pStorage->Release();
        return FALSE;
    }

    DoDestroy();

    m_pRootStorage = pStorage;
    m_pStream = pStream;

    return TRUE;
}

BOOL MOleHost::DoInsertObject(MOleSite *pSite, REFCLSID clsid)
{
    WCHAR szName[MAX_PATH];
    StringCbPrintfW(szName, sizeof(szName), L"Object %d", m_cObjects + 1);

    IStorage *pStorage = NULL;
    m_pRootStorage->CreateStorage(szName, STGM_READWRITE | STGM_SHARE_EXCLUSIVE, 0, 0, &pStorage);
    if (pStorage == NULL)
        return FALSE;

    IOleObject *pOleObject = NULL;
    HRESULT hr = ::OleCreate(clsid, IID_IOleObject, OLERENDER_DRAW, NULL, NULL,
                             pStorage, (void **)&pOleObject);
    if (FAILED(hr))
    {
        pStorage->Release();
        return FALSE;
    }

    m_cObjects++;
    pSite->DoInit(this, pOleObject, pStorage, szName);

    if (m_pSite)
        pSite->m_pNext = m_pSite;
    m_pSite = pSite;

    return TRUE;
}

void MOleHost::DoEnableMenu(BOOL bEnable)
{
    MOleSite *pSite = m_pSite;
    while (pSite)
    {
        pSite->DoEnableMenu(bEnable);
        pSite = pSite->m_pNext;
    }
}

void MOleHost::DoDestroy()
{
    if (m_pStream)
    {
        m_pStream->Release();
        m_pStream = NULL;
    }
    if (m_pRootStorage)
    {
        m_pRootStorage->Release();
        m_pRootStorage = NULL;
    }
}

```

`src/MOleHost.hpp`:

```hpp
#pragma once

class MOleSite;
class MOleHost;

class MOleSite : public MWindowBase, public IOleClientSite, public IAdviseSink
{
public:
    MOleSite *m_pNext;

    DECLARE_DYNAMIC(MOleSite)

    // NOTE: Please call MOleSite::RegisterDx before use.
    static BOOL RegisterDx()
    {
        MOleSite oc;
        return oc.RegisterClassDx();
    }

    // MWindowBase interface
    virtual LPCTSTR GetWndClassNameDx() const
    {
        return TEXT("MOleSite");
    }
    virtual void ModifyWndClassDx(WNDCLASSEX& wcx)
    {
        wcx.hbrBackground = NULL;
    }

    // IUnknown interface
    STDMETHODIMP QueryInterface(REFIID riid, void **ppvObject) override;
    STDMETHODIMP_(ULONG) AddRef() override;
    STDMETHODIMP_(ULONG) Release() override;

    // IOleClientSite interface
    STDMETHODIMP SaveObject() override;
    STDMETHODIMP GetMoniker(DWORD dwAssign, DWORD dwWhichMoniker, IMoniker **ppmk) override;
    STDMETHODIMP GetContainer(IOleContainer **ppContainer) override;
    STDMETHODIMP ShowObject() override;
    STDMETHODIMP OnShowWindow(BOOL fShow) override;
    STDMETHODIMP RequestNewObjectLayout() override;

    // IAdviseSink interface
    STDMETHODIMP_(void) OnDataChange(FORMATETC *pFormatetc, STGMEDIUM *pStgmed) override;
    STDMETHODIMP_(void) OnViewChange(DWORD dwAspect, LONG lindex) override;
    STDMETHODIMP_(void) OnRename(IMoniker *pmk) override;
    STDMETHODIMP_(void) OnSave() override;
    STDMETHODIMP_(void) OnClose() override;

    MOleSite();
    ~MOleSite();
    void DoInit(MOleHost *pHost, IOleObject *pOleObject, IStorage *pStorage,
                LPCWSTR lpszObjectName);
    void DoRunObject(LONG nVerb);
    void DoCloseObject();
    void DoUpdateRect();
    void DoEnableMenu(BOOL bEnable);

protected:
    LONG        m_cRef;
    DWORD       m_dwConnection;
    BOOL        m_bEnableMenu;
    IOleObject *m_pOleObject;
    IStorage   *m_pStorage;
    MOleHost   *m_pHost;
    RECT        m_rc;

    void DoDestroy();
    void DoSave();
    void DoHIMETRICtoDP(LPSIZEL lpSizel);
    void DoDPtoHIMETRIC(LPSIZEL lpSizel);

    BOOL OnCreate(HWND hwnd, LPCREATESTRUCT lpCreateStruct);
    void OnMove(HWND hwnd, int x, int y);
    void OnSize(HWND hwnd, UINT state, int cx, int cy);
    void OnPaint(HWND hwnd);
    void OnLButtonDown(HWND hwnd, BOOL fDoubleClick, int x, int y, UINT keyFlags);
    void OnRButtonDown(HWND hwnd, BOOL fDoubleClick, int x, int y, UINT keyFlags);
    void OnCommand(HWND hwnd, int id, HWND hwndCtl, UINT codeNotify);
    void OnDestroy(HWND hwnd);

    virtual LRESULT CALLBACK
    WindowProcDx(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
    {
        switch (uMsg)
        {
        HANDLE_MSG(hwnd, WM_CREATE, OnCreate);
        HANDLE_MSG(hwnd, WM_MOVE, OnMove);
        HANDLE_MSG(hwnd, WM_SIZE, OnSize);
        HANDLE_MSG(hwnd, WM_PAINT, OnPaint);
        HANDLE_MSG(hwnd, WM_LBUTTONDBLCLK, OnLButtonDown);
        HANDLE_MSG(hwnd, WM_RBUTTONDOWN, OnRButtonDown);
        HANDLE_MSG(hwnd, WM_COMMAND, OnCommand);
        HANDLE_MSG(hwnd, WM_DESTROY, OnDestroy);
        default:
            return DefaultProcDx(hwnd, uMsg, wParam, lParam);
        }
    }
};

class MOleHost
{
public:
    MOleHost();
    ~MOleHost();

    BOOL DoInsertObject(MOleSite *pSite, REFCLSID clsid);
    void DoEnableMenu(BOOL bEnable);

protected:
    INT       m_cObjects;
    IStorage *m_pRootStorage;
    IStream  *m_pStream;
    MOleSite *m_pSite; /* linked list */

    BOOL DoCreateRootStorage(LPCWSTR lpszFileName = NULL);
    void DoDestroy();
};

MOleHost *DoGetActiveOleHost(void);
void DoSetActiveOleHost(MOleHost *pHost);

```

`src/MPathsDlg.hpp`:

```hpp
// MPathsDlg.hpp --- Dialogs for Paths
//////////////////////////////////////////////////////////////////////////////
// RisohEditor --- Another free Win32 resource editor
// Copyright (C) 2017-2018 Katayama Hirofumi MZ <katayama.hirofumi.mz@gmail.com>
// 
// This program is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
// 
// This program is distributed in the hope that it will be useful, 
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
// 
// You should have received a copy of the GNU General Public License
// along with this program.  If not, see <http://www.gnu.org/licenses/>.
//////////////////////////////////////////////////////////////////////////////

#pragma once

#include "resource.h"
#include "MWindowBase.hpp"
#include "RisohSettings.hpp"
#include "MResizable.hpp"

class MPathsDlg;

//////////////////////////////////////////////////////////////////////////////

class MPathsDlg : public MDialogBase
{
public:
    HWND m_hLst1;
    MResizable m_resizable;
    HICON m_hIcon;
    HICON m_hIconSm;
    std::vector<MString> m_list;

    MPathsDlg() : MDialogBase(IDD_PATHS)
    {
        m_hIcon = LoadIconDx(IDI_SMILY);
        m_hIconSm = LoadSmallIconDx(IDI_SMILY);
    }

    ~MPathsDlg()
    {
        DestroyIcon(m_hIcon);
        DestroyIcon(m_hIconSm);
    }

    void OnDelete(HWND hwnd)
    {
        INT iItem = ListBox_GetCurSel(m_hLst1);
        if (iItem < 0)
            return;

        ListBox_DeleteString(m_hLst1, iItem);
        OnSelChange(hwnd);
    }

    void OnAdd(HWND hwnd)
    {
        TCHAR szPath[MAX_PATH];
        BROWSEINFO bi;

        ZeroMemory(&bi, sizeof(bi));
        bi.hwndOwner = hwnd;
        bi.lpszTitle = LoadStringDx(IDS_ADDINCLUDE);
        bi.ulFlags = BIF_RETURNONLYFSDIRS;
        if (LPITEMIDLIST pidl = SHBrowseForFolder(&bi))
        {
            SHGetPathFromIDList(pidl, szPath);
            INT iItem = ListBox_AddString(m_hLst1, szPath);
            CoTaskMemFree(pidl);

            if (iItem != LB_ERR)
            {
                ListBox_SetCurSel(m_hLst1, iItem);
                OnSelChange(hwnd);
            }
        }
    }

    static INT CALLBACK
    BrowseCallbackProc(HWND hwnd, UINT uMsg, LPARAM lParam, LPARAM lpData)
    {
        if (uMsg == BFFM_INITIALIZED)
        {
            SendMessage(hwnd, BFFM_SETSELECTION, TRUE, (LPARAM)lpData);
        }
        return 0;
    }

    BOOL SetItemText(HWND hLst1, INT iItem, LPCTSTR psz)
    {
        ListBox_DeleteString(hLst1, iItem);
        ListBox_InsertString(hLst1, iItem, psz);
        return TRUE;
    }

    void OnModify(HWND hwnd)
    {
        TCHAR szPath[MAX_PATH];
        BROWSEINFO bi;

        INT iItem = ListBox_GetCurSel(m_hLst1);
        if (iItem == LB_ERR)
            return;

        ListBox_GetText(m_hLst1, iItem, szPath);

        ZeroMemory(&bi, sizeof(bi));
        bi.hwndOwner = hwnd;
        bi.pidlRoot = NULL;
        bi.lpszTitle = LoadStringDx(IDS_EDITINCLUDE);
        bi.ulFlags = BIF_RETURNONLYFSDIRS;
        bi.lpfn = BrowseCallbackProc;
        bi.lParam = (LPARAM)szPath;
        if (LPITEMIDLIST pidl = SHBrowseForFolder(&bi))
        {
            SHGetPathFromIDList(pidl, szPath);
            SetItemText(m_hLst1, iItem, szPath);
            CoTaskMemFree(pidl);
        }
    }

    void OnOK(HWND hwnd)
    {
        TCHAR szText[MAX_PATH];

        m_list.clear();
        INT i, nCount = ListBox_GetCount(m_hLst1);
        for (i = 0; i < nCount; ++i)
        {
            ListBox_GetText(m_hLst1, i, szText);
            mstr_trim(szText);
            m_list.push_back(szText);
        }

        GetDlgItemText(hwnd, cmb1, szText, _countof(szText));
        MString strWindResExe = szText;
        mstr_trim(strWindResExe);

        GetDlgItemText(hwnd, cmb2, szText, _countof(szText));
        MString strCppExe = szText;
        mstr_trim(strCppExe);

        if (strWindResExe.size() &&
            GetFileAttributes(strWindResExe.c_str()) == 0xFFFFFFFF)
        {
            HWND hCmb1 = GetDlgItem(hwnd, cmb1);
            ComboBox_SetEditSel(hCmb1, 0, -1);
            SetFocus(hCmb1);
            ErrorBoxDx(IDS_INVALIDPATH);
            return;
        }

        if (strCppExe.size() &&
            GetFileAttributes(strCppExe.c_str()) == 0xFFFFFFFF)
        {
            HWND hCmb2 = GetDlgItem(hwnd, cmb2);
            ComboBox_SetEditSel(hCmb2, 0, -1);
            SetFocus(hCmb2);
            ErrorBoxDx(IDS_INVALIDPATH);
            return;
        }

        g_settings.includes = m_list;
        g_settings.strWindResExe = std::move(strWindResExe);
        g_settings.strCppExe = std::move(strCppExe);

        EndDialog(IDOK);
    }

    void OnContextMenu(HWND hwnd, HWND hwndContext, UINT xPos, UINT yPos)
    {
        if (hwndContext == m_hLst1)
        {
            PopupMenuDx(hwnd, m_hLst1, IDR_POPUPMENUS, 7, xPos, yPos);
        }
    }

    void OnPsh4(HWND hwnd)
    {
        INT iItem = ListBox_GetCurSel(m_hLst1);
        if (iItem == LB_ERR)
            return;

        TCHAR szPath1[MAX_PATH], szPath2[MAX_PATH];
        ListBox_GetText(m_hLst1, iItem - 1, szPath1);
        ListBox_GetText(m_hLst1, iItem, szPath2);

        SetItemText(m_hLst1, iItem - 1, szPath2);
        SetItemText(m_hLst1, iItem, szPath1);

        ListBox_SetCurSel(m_hLst1, iItem - 1);
        OnSelChange(hwnd);
    }

    void OnPsh5(HWND hwnd)
    {
        INT iItem = ListBox_GetCurSel(m_hLst1);
        if (iItem < 0)
            return;

        INT nCount = ListBox_GetCount(m_hLst1);
        if (iItem + 1 >= nCount)
            return;

        TCHAR szPath1[MAX_PATH], szPath2[MAX_PATH];
        ListBox_GetText(m_hLst1, iItem, szPath1);
        ListBox_GetText(m_hLst1, iItem + 1, szPath2);

        SetItemText(m_hLst1, iItem, szPath2);
        SetItemText(m_hLst1, iItem + 1, szPath1);

        ListBox_SetCurSel(m_hLst1, iItem + 1);
        OnSelChange(hwnd);
    }

    void OnPsh6(HWND hwnd)
    {
        ListBox_ResetContent(m_hLst1);
        OnSelChange(hwnd);
    }

    void OnPsh7(HWND hwnd)
    {
        WCHAR file[MAX_PATH];
        GetDlgItemText(hwnd, cmb1, file, _countof(file));
        mstr_trim(file);

        OPENFILENAMEW ofn;
        ZeroMemory(&ofn, sizeof(ofn));
        ofn.lStructSize = OPENFILENAME_SIZE_VERSION_400W;
        ofn.hwndOwner = hwnd;
        ofn.lpstrFilter = MakeFilterDx(LoadStringDx(IDS_WINDRESEXE));
        ofn.lpstrFile = file;
        ofn.nMaxFile = _countof(file);
        ofn.lpstrTitle = LoadStringDx(IDS_LOADWCLIB);
        ofn.Flags = OFN_ENABLESIZING | OFN_EXPLORER | OFN_FILEMUSTEXIST |
            OFN_HIDEREADONLY | OFN_PATHMUSTEXIST;
        ofn.lpstrDefExt = L"exe";
        if (GetOpenFileNameW(&ofn))
        {
            SetDlgItemText(hwnd, cmb1, file);
            OnSelChange(hwnd);
        }
    }

    void OnPsh8(HWND hwnd)
    {
        WCHAR file[MAX_PATH];
        GetDlgItemText(hwnd, cmb2, file, _countof(file));
        mstr_trim(file);

        OPENFILENAMEW ofn;
        ZeroMemory(&ofn, sizeof(ofn));
        ofn.lStructSize = OPENFILENAME_SIZE_VERSION_400W;
        ofn.hwndOwner = hwnd;
        ofn.lpstrFilter = MakeFilterDx(LoadStringDx(IDS_CPPEXE));
        ofn.lpstrFile = file;
        ofn.nMaxFile = _countof(file);
        ofn.lpstrTitle = LoadStringDx(IDS_LOADWCLIB);
        ofn.Flags = OFN_ENABLESIZING | OFN_EXPLORER | OFN_FILEMUSTEXIST |
            OFN_HIDEREADONLY | OFN_PATHMUSTEXIST;
        ofn.lpstrDefExt = L"exe";
        if (GetOpenFileNameW(&ofn))
        {
            SetDlgItemText(hwnd, cmb2, file);
            OnSelChange(hwnd);
        }
    }

    void OnPsh9(HWND hwnd)
    {
        ListBox_ResetContent(m_hLst1);
        SetDlgItemText(hwnd, cmb1, NULL);
        SetDlgItemText(hwnd, cmb2, NULL);
        OnSelChange(hwnd);
    }

    void OnCommand(HWND hwnd, int id, HWND hwndCtl, UINT codeNotify)
    {
        switch (id)
        {
        case psh1:
        case ID_ADD:
            OnAdd(hwnd);
            break;
        case psh2:
        case ID_MODIFY:
            OnModify(hwnd);
            break;
        case psh3:
        case ID_DELETE:
            OnDelete(hwnd);
            break;
        case IDOK:
            if (codeNotify == 0 || codeNotify == BN_CLICKED)
                OnOK(hwnd);
            break;
        case IDCANCEL:
            if (codeNotify == 0 || codeNotify == BN_CLICKED)
                EndDialog(IDCANCEL);
            break;
        case psh4:
            if (codeNotify == 0 || codeNotify == BN_CLICKED)
                OnPsh4(hwnd);
            break;
        case psh5:
            if (codeNotify == 0 || codeNotify == BN_CLICKED)
                OnPsh5(hwnd);
            break;
        case psh6:
            if (codeNotify == 0 || codeNotify == BN_CLICKED)
                OnPsh6(hwnd);
            break;
        case psh7:
            if (codeNotify == 0 || codeNotify == BN_CLICKED)
                OnPsh7(hwnd);
            break;
        case psh8:
            if (codeNotify == 0 || codeNotify == BN_CLICKED)
                OnPsh8(hwnd);
            break;
        case psh9:
            if (codeNotify == 0 || codeNotify == BN_CLICKED)
                OnPsh9(hwnd);
            break;
        case lst1:
            if (codeNotify == LBN_SELCHANGE)
            {
                OnSelChange(hwnd);
            }
            break;
        }
    }

    void OnInitMenuPopup(HWND hwnd, HMENU hMenu, UINT item, BOOL fSystemMenu)
    {
        INT iItem = ListBox_GetCurSel(m_hLst1);
        if (iItem >= 0)
        {
            EnableMenuItem(hMenu, psh2, MF_BYCOMMAND | MF_ENABLED);
            EnableMenuItem(hMenu, psh3, MF_BYCOMMAND | MF_ENABLED);
            EnableMenuItem(hMenu, psh4, MF_BYCOMMAND | MF_ENABLED);
            EnableMenuItem(hMenu, psh5, MF_BYCOMMAND | MF_ENABLED);
        }
        else
        {
            EnableMenuItem(hMenu, psh2, MF_BYCOMMAND | MF_GRAYED);
            EnableMenuItem(hMenu, psh3, MF_BYCOMMAND | MF_GRAYED);
            EnableMenuItem(hMenu, psh4, MF_BYCOMMAND | MF_GRAYED);
            EnableMenuItem(hMenu, psh5, MF_BYCOMMAND | MF_GRAYED);
        }
    }

    void OnSelChange(HWND hwnd)
    {
        INT iItem = ListBox_GetCurSel(m_hLst1);
        BOOL bSelected = (iItem != -1);
        EnableWindow(GetDlgItem(hwnd, psh2), bSelected);
        EnableWindow(GetDlgItem(hwnd, psh3), bSelected);
        EnableWindow(GetDlgItem(hwnd, psh4), bSelected);
        EnableWindow(GetDlgItem(hwnd, psh5), bSelected);
    }

    virtual INT_PTR CALLBACK
    DialogProcDx(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
    {
        switch (uMsg)
        {
            HANDLE_MSG(hwnd, WM_INITDIALOG, OnInitDialog);
            HANDLE_MSG(hwnd, WM_COMMAND, OnCommand);
            HANDLE_MSG(hwnd, WM_NOTIFY, OnNotify);
            HANDLE_MSG(hwnd, WM_SIZE, OnSize);
            HANDLE_MSG(hwnd, WM_CONTEXTMENU, OnContextMenu);
            HANDLE_MSG(hwnd, WM_INITMENUPOPUP, OnInitMenuPopup);
        }
        return DefaultProcDx();
    }

    LRESULT OnNotify(HWND hwnd, int idFrom, NMHDR *pnmhdr)
    {
        if (idFrom == lst1)
        {
            if (pnmhdr->code == LVN_KEYDOWN)
            {
                LV_KEYDOWN *KeyDown = (LV_KEYDOWN *)pnmhdr;
                if (KeyDown->wVKey == VK_DELETE)
                {
                    OnDelete(hwnd);
                    return 0;
                }
            }
            if (pnmhdr->code == NM_DBLCLK)
            {
                OnModify(hwnd);
                return 0;
            }
        }
        return 0;
    }

    void OnSize(HWND hwnd, UINT state, int cx, int cy)
    {
        m_resizable.OnSize();
    }

    BOOL OnInitDialog(HWND hwnd, HWND hwndFocus, LPARAM lParam)
    {
        m_hLst1 = GetDlgItem(hwnd, lst1);

        m_list.clear();

        DWORD dwNumIncludes = DWORD(g_settings.includes.size());
        for (DWORD i = 0; i < dwNumIncludes; ++i)
        {
            m_list.push_back(g_settings.includes[i]);
            ListBox_AddString(m_hLst1, g_settings.includes[i].c_str());
        }

        SetDlgItemText(hwnd, cmb1, g_settings.strWindResExe.c_str());
        SetDlgItemText(hwnd, cmb2, g_settings.strCppExe.c_str());

        m_resizable.OnParentCreate(hwnd);

        m_resizable.SetLayoutAnchor(lst1, mzcLA_TOP_LEFT, mzcLA_BOTTOM_RIGHT);
        m_resizable.SetLayoutAnchor(psh1, mzcLA_TOP_RIGHT);
        m_resizable.SetLayoutAnchor(psh2, mzcLA_TOP_RIGHT);
        m_resizable.SetLayoutAnchor(psh3, mzcLA_TOP_RIGHT);
        m_resizable.SetLayoutAnchor(psh4, mzcLA_TOP_RIGHT);
        m_resizable.SetLayoutAnchor(psh5, mzcLA_TOP_RIGHT);
        m_resizable.SetLayoutAnchor(psh6, mzcLA_BOTTOM_LEFT);
        m_resizable.SetLayoutAnchor(stc1, mzcLA_BOTTOM_LEFT);
        m_resizable.SetLayoutAnchor(stc2, mzcLA_BOTTOM_LEFT);
        m_resizable.SetLayoutAnchor(cmb1, mzcLA_BOTTOM_LEFT, mzcLA_BOTTOM_RIGHT);
        m_resizable.SetLayoutAnchor(cmb2, mzcLA_BOTTOM_LEFT, mzcLA_BOTTOM_RIGHT);
        m_resizable.SetLayoutAnchor(psh7, mzcLA_BOTTOM_RIGHT);
        m_resizable.SetLayoutAnchor(psh8, mzcLA_BOTTOM_RIGHT);
        m_resizable.SetLayoutAnchor(IDOK, mzcLA_BOTTOM_RIGHT);
        m_resizable.SetLayoutAnchor(IDCANCEL, mzcLA_BOTTOM_RIGHT);
        m_resizable.SetLayoutAnchor(psh9, mzcLA_BOTTOM_LEFT);

        SendMessageDx(WM_SETICON, ICON_BIG, (LPARAM)m_hIcon);
        SendMessageDx(WM_SETICON, ICON_SMALL, (LPARAM)m_hIconSm);

        SetFocus(m_hLst1);

        OnSelChange(hwnd);

        CenterWindowDx();
        return TRUE;
    }
};

```

`src/MPointSizeRect.hpp`:

```hpp
// MPointSizeRect.hpp -- Win32API point, size and rectangle     -*- C++ -*-
// This file is part of MZC4.  See file "ReadMe.txt" and "License.txt".
////////////////////////////////////////////////////////////////////////////

#ifndef MZC4_MPOINTSIZERECT_HPP_
#define MZC4_MPOINTSIZERECT_HPP_    4   /* Version 4 */

class MPoint;
class MSize;
class MRect;
//VOID NormalizeRectDx(LPRECT prc);

////////////////////////////////////////////////////////////////////////////

#ifndef _INC_WINDOWS
    #include <windows.h>    // Win32API
#endif
#ifndef _INC_WINDOWSX
    #include <windowsx.h>   // macro API
#endif
#include <cassert>          // assert

////////////////////////////////////////////////////////////////////////////

inline VOID GetScreenRectDx(LPRECT prc)
{
#ifndef SM_XVIRTUALSCREEN
    #define SM_XVIRTUALSCREEN   76
    #define SM_YVIRTUALSCREEN   77
    #define SM_CXVIRTUALSCREEN  78
    #define SM_CYVIRTUALSCREEN  79
#endif
    INT x = GetSystemMetrics(SM_XVIRTUALSCREEN);
    INT y = GetSystemMetrics(SM_YVIRTUALSCREEN);
    INT cx = GetSystemMetrics(SM_CXVIRTUALSCREEN);
    INT cy = GetSystemMetrics(SM_CYVIRTUALSCREEN);
    if (cx)
    {
        SetRect(prc, x, y, x + cx, y + cy);
    }
    else
    {
        cx = GetSystemMetrics(SM_CXSCREEN);
        cy = GetSystemMetrics(SM_CYSCREEN);
        SetRect(prc, 0, 0, cx, cy);
    }
}

////////////////////////////////////////////////////////////////////////////

class MPoint : public POINT
{
public:
    MPoint();
    MPoint(INT x_, INT y_);
    MPoint(POINT pt);
    MPoint(SIZE siz);
    MPoint(DWORD dwPoint);
    VOID    Offset(INT dx, INT dy);
    VOID    Offset(POINT pt);
    VOID    Offset(SIZE siz);
    operator LPPOINT();
    operator const POINT *() const;
    BOOL    operator==(POINT pt) const;
    BOOL    operator!=(POINT pt) const;
    VOID    operator+=(SIZE siz);
    VOID    operator-=(SIZE siz);
    VOID    operator+=(POINT pt);
    VOID    operator-=(POINT pt);
    VOID    SetPoint(INT x_, INT y_);
    MPoint  operator+(SIZE siz) const;
    MPoint  operator-(SIZE siz) const;
    MPoint  operator-() const;
    MPoint  operator+(POINT pt) const;
    MSize   operator-(POINT pt) const;
    MRect   operator+(LPCRECT prc) const;
    MRect   operator-(LPCRECT prc) const;
};

////////////////////////////////////////////////////////////////////////////

class MSize : public SIZE
{
public:
    MSize();
    MSize(INT cx_, INT cy_);
    MSize(SIZE siz);
    MSize(POINT pt);
    MSize(DWORD dwSize);
    operator LPSIZE();
    operator const SIZE *() const;
    BOOL    operator==(SIZE siz) const;
    BOOL    operator!=(SIZE siz) const;
    VOID    operator+=(SIZE siz);
    VOID    operator-=(SIZE siz);
    VOID    SetSize(INT cx_, INT cy_);
    MSize   operator+(SIZE siz) const;
    MSize   operator-(SIZE siz) const;
    MSize   operator-() const;
    MPoint  operator+(POINT pt) const;
    MPoint  operator-(POINT pt) const;
    MRect   operator+(LPCRECT prc) const;
    MRect   operator-(LPCRECT prc) const;
};

////////////////////////////////////////////////////////////////////////////

class MRect : public RECT
{
public:
    MRect();
    MRect(INT l, INT t, INT r, INT b);
    MRect(const RECT& rcSrc);
    MRect(LPCRECT lpSrcRect);
    MRect(POINT pt, SIZE siz);
    MRect(POINT topLeft, POINT bottomRight);
    operator LPRECT();
    operator LPCRECT() const;

    INT   Width() const;
    INT   Height() const;
    MSize Size() const;

    MPoint&       TopLeft();
    const MPoint& TopLeft() const;
    MPoint&       BottomRight();
    const MPoint& BottomRight() const;
    MPoint        CenterPoint() const;

    BOOL IsRectEmpty() const;
    BOOL IsRectNull() const;
    BOOL PtInRect(POINT pt) const;
    VOID SetRect(INT x1, INT y1, INT x2, INT y2);
    VOID SetRect(POINT topLeft, POINT bottomRight);
    VOID SetRectEmpty();
    VOID CopyRect(LPCRECT lpSrcRect);
    BOOL EqualRect(LPCRECT prc) const;
    VOID InflateRect(INT x, INT y);
    VOID InflateRect(SIZE siz);
    VOID InflateRect(LPCRECT prc);
    VOID InflateRect(INT l, INT t, INT r, INT b);
    VOID DeflateRect(INT x, INT y);
    VOID DeflateRect(SIZE siz);
    VOID DeflateRect(LPCRECT prc);
    VOID DeflateRect(INT l, INT t, INT r, INT b);
    VOID OffsetRect(INT x, INT y);
    VOID OffsetRect(SIZE siz);
    VOID OffsetRect(POINT pt);
    VOID NormalizeRect();
    VOID MoveToX(INT x);
    VOID MoveToY(INT y);
    VOID MoveToXY(INT x, INT y);
    VOID MoveToXY(POINT pt);
    BOOL IntersectRect(LPCRECT prc1, LPCRECT prc2);
    BOOL UnionRect(LPCRECT prc1, LPCRECT prc2);
    BOOL SubtractRect(LPCRECT prcSrc1, LPCRECT prcSrc2);

    VOID operator=(const RECT& rcSrc);
    BOOL operator==(const RECT& rc) const;
    BOOL operator!=(const RECT& rc) const;
    VOID operator+=(POINT pt);
    VOID operator+=(SIZE siz);
    VOID operator+=(LPCRECT prc);
    VOID operator-=(POINT pt);
    VOID operator-=(SIZE siz);
    VOID operator-=(LPCRECT prc);
    VOID operator&=(const RECT& rc);
    VOID operator|=(const RECT& rc);
    MRect operator+(POINT pt) const;
    MRect operator-(POINT pt) const;
    MRect operator+(LPCRECT prc) const;
    MRect operator+(SIZE siz) const;
    MRect operator-(SIZE siz) const;
    MRect operator-(LPCRECT prc) const;
    MRect operator&(const RECT& rc2) const;
    MRect operator|(const RECT& rc2) const;
    MRect MulDiv(INT nMultiplier, INT nDivisor) const;
};

VOID NormalizeRectDx(LPRECT prc);

////////////////////////////////////////////////////////////////////////////

inline MPoint::MPoint()
    { x = y = 0; }

inline MPoint::MPoint(INT x_, INT y_)
    { x = x_; y = y_; }

inline MPoint::MPoint(POINT pt)
    { *reinterpret_cast<POINT *>(this) = pt; }

inline MPoint::MPoint(SIZE siz)
    { *reinterpret_cast<SIZE *>(this) = siz; }

inline MPoint::MPoint(DWORD dwPoint)
    { x = GET_X_LPARAM(dwPoint); y = GET_Y_LPARAM(dwPoint); }

inline VOID MPoint::Offset(INT dx, INT dy)
    { x += dx; y += dy; }

inline VOID MPoint::Offset(POINT pt)
    { x += pt.x; y += pt.y; }

inline VOID MPoint::Offset(SIZE siz)
    { x += siz.cx; y += siz.cy; }

inline MPoint::operator LPPOINT()
    { return reinterpret_cast<LPPOINT>(this); }

inline MPoint::operator const POINT *() const
    { return reinterpret_cast<const POINT *>(this); }

inline BOOL MPoint::operator==(POINT pt) const
    { return (x == pt.x && y == pt.y); }

inline BOOL MPoint::operator!=(POINT pt) const
    { return (x != pt.x || y != pt.y); }

inline VOID MPoint::operator+=(SIZE siz)
    { x += siz.cx; y += siz.cy; }

inline VOID MPoint::operator-=(SIZE siz)
    { x -= siz.cx; y -= siz.cy; }

inline VOID MPoint::operator+=(POINT pt)
    { x += pt.x; y += pt.y; }

inline VOID MPoint::operator-=(POINT pt)
    { x -= pt.x; y -= pt.y; }

inline VOID MPoint::SetPoint(INT x_, INT y_)
    { x = x_; y = y_; }

inline MPoint MPoint::operator+(SIZE siz) const
    { return MPoint(x + siz.cx, y + siz.cy); }

inline MPoint MPoint::operator-(SIZE siz) const
    { return MPoint(x - siz.cx, y - siz.cy); }

inline MPoint MPoint::operator-() const
    { return MPoint(-x, -y); }

inline MPoint MPoint::operator+(POINT pt) const
    { return MPoint(x + pt.x, y + pt.y); }

inline MSize MPoint::operator-(POINT pt) const
    { return MSize(x - pt.x, y - pt.y); }

inline MRect MPoint::operator+(LPCRECT prc) const
    { return MRect(prc) + *this; }

inline MRect MPoint::operator-(LPCRECT prc) const
    { return MRect(prc) - *this; }

////////////////////////////////////////////////////////////////////////////

inline MSize::MSize()
    { cx = cy = 0; }

inline MSize::MSize(INT cx_, INT cy_)
    { cx = cx_; cy = cy_; }

inline MSize::MSize(SIZE siz)
    { *reinterpret_cast<SIZE *>(this) = siz; }

inline MSize::MSize(POINT pt)
    { *reinterpret_cast<POINT *>(this) = pt; }

inline MSize::MSize(DWORD dwSize)
    { cx = GET_X_LPARAM(dwSize); cy = GET_Y_LPARAM(dwSize); }

inline MSize::operator LPSIZE()
    { return reinterpret_cast<LPSIZE>(this); }

inline MSize::operator const SIZE *() const
    { return reinterpret_cast<const SIZE *>(this); }

inline BOOL MSize::operator==(SIZE siz) const
    { return (cx == siz.cx && cy == siz.cy); }

inline BOOL MSize::operator!=(SIZE siz) const
    { return (cx != siz.cx || cy != siz.cy); }

inline VOID MSize::operator+=(SIZE siz)
    { cx += siz.cx; cy += siz.cy; }

inline VOID MSize::operator-=(SIZE siz)
    { cx -= siz.cx; cy -= siz.cy; }

inline VOID MSize::SetSize(INT cx_, INT cy_)
    { cx = cx_; cy = cy_; }

inline MSize MSize::operator+(SIZE siz) const
    { return MSize(cx + siz.cx, cy + siz.cy); }

inline MSize MSize::operator-(SIZE siz) const
    { return MSize(cx - siz.cx, cy - siz.cy); }

inline MSize MSize::operator-() const
    { return MSize(-cx, -cy); }

inline MPoint MSize::operator+(POINT pt) const
    { return MPoint(cx + pt.x, cy + pt.y); }

inline MPoint MSize::operator-(POINT pt) const
    { return MPoint(cx - pt.x, cy - pt.y); }

inline MRect MSize::operator+(LPCRECT prc) const
    { return MRect(prc) + *this; }

inline MRect MSize::operator-(LPCRECT prc) const
    { return MRect(prc) - *this; }

template <class Number>
inline MSize operator*(SIZE s, Number n)
    { return MSize((INT)(s.cx * n), (INT)(s.cy * n)); }

template <class Number>
inline VOID operator*=(SIZE & s, Number n)
    { s = s * n; }

template <class Number>
inline MSize operator/(SIZE s, Number n) 
    { return MSize((INT)(s.cx / n), (INT)(s.cy / n)); }

template <class Number>
inline VOID operator/=(SIZE & s, Number n)
    { s = s / n; }

////////////////////////////////////////////////////////////////////////////

inline MRect::MRect()
    { left = top = right = bottom = 0; }

inline MRect::MRect(INT l, INT t, INT r, INT b)
    { left = l; top = t; right = r; bottom = b; }

inline MRect::MRect(const RECT& rcSrc)
    { ::CopyRect(this, &rcSrc); }

inline MRect::MRect(LPCRECT lpSrcRect)
    { ::CopyRect(this, lpSrcRect); }

inline MRect::MRect(POINT pt, SIZE siz)
{
    right = (left = pt.x) + siz.cx;
    bottom = (top = pt.y) + siz.cy;
}

inline MRect::MRect(POINT topLeft, POINT bottomRight)
{
    left = topLeft.x;
    top = topLeft.y;
    right = bottomRight.x;
    bottom = bottomRight.y;
}

inline VOID MRect::InflateRect(LPCRECT prc)
{
    left -= prc->left;
    top -= prc->top;
    right += prc->right;
    bottom += prc->bottom;
}

inline VOID MRect::InflateRect(INT l, INT t, INT r, INT b)
{
    left -= l;
    top -= t;
    right += r;
    bottom += b;
}

inline VOID MRect::DeflateRect(LPCRECT prc)
{
    left += prc->left;
    top += prc->top;
    right -= prc->right;
    bottom -= prc->bottom;
}

inline VOID MRect::DeflateRect(INT l, INT t, INT r, INT b)
{
    left += l;
    top += t;
    right -= r;
    bottom -= b;
}

inline VOID MRect::NormalizeRect()
{
    INT nTemp;
    if (left > right)
    {
        nTemp = left;
        left = right;
        right = nTemp;
    }
    if (top > bottom)
    {
        nTemp = top;
        top = bottom;
        bottom = nTemp;
    }
}

inline MRect MRect::operator+(POINT pt) const
{
    MRect rc(*this);
    ::OffsetRect(&rc, pt.x, pt.y);
    return rc;
}

inline MRect MRect::operator-(POINT pt) const
{
    MRect rc(*this);
    ::OffsetRect(&rc, -pt.x, -pt.y);
    return rc;
}

inline MRect MRect::operator+(LPCRECT prc) const
{
    MRect rc(this);
    rc.InflateRect(prc);
    return rc;
}

inline MRect MRect::operator+(SIZE siz) const
{
    MRect rc(*this);
    ::OffsetRect(&rc, siz.cx, siz.cy);
    return rc;
}

inline MRect MRect::operator-(SIZE siz) const
{
    MRect rc(*this);
    ::OffsetRect(&rc, -siz.cx, -siz.cy);
    return rc;
}

inline MRect MRect::operator-(LPCRECT prc) const
{
    MRect rc(this);
    rc.DeflateRect(prc);
    return rc;
}

inline MRect MRect::operator&(const RECT& rc2) const
{
    MRect rc;
    ::IntersectRect(&rc, this, &rc2);
    return rc;
}

inline MRect MRect::operator|(const RECT& rc2) const
{
    MRect rc;
    ::UnionRect(&rc, this, &rc2);
    return rc;
}

inline MRect MRect::MulDiv(INT nMultiplier, INT nDivisor) const
{
    return MRect(
        ::MulDiv(left, nMultiplier, nDivisor), 
        ::MulDiv(top, nMultiplier, nDivisor), 
        ::MulDiv(right, nMultiplier, nDivisor), 
        ::MulDiv(bottom, nMultiplier, nDivisor));
}

inline INT MRect::Width() const
    { return right - left; }

inline INT MRect::Height() const
    { return bottom - top; }

inline MSize MRect::Size() const
    { return MSize(right - left, bottom - top); }

inline MPoint& MRect::TopLeft()
    { return *((MPoint*) this); }

inline MPoint& MRect::BottomRight()
    { return *((MPoint*) this + 1); }

inline const MPoint& MRect::TopLeft() const
    { return *((MPoint*) this); }

inline const MPoint& MRect::BottomRight() const
    { return *((MPoint*) this + 1); }

inline MPoint MRect::CenterPoint() const
    { return MPoint((left + right) / 2, (top + bottom) / 2); }

inline MRect::operator LPRECT()
    { return this; }

inline MRect::operator LPCRECT() const
    { return this; }

inline BOOL MRect::IsRectEmpty() const
    { return ::IsRectEmpty(this); }

inline BOOL MRect::IsRectNull() const
    { return (left == 0 && right == 0 && top == 0 && bottom == 0); }

inline BOOL MRect::PtInRect(POINT pt) const
    { return ::PtInRect(this, pt); }

inline VOID MRect::SetRect(INT x1, INT y1, INT x2, INT y2)
    { ::SetRect(this, x1, y1, x2, y2); }

inline VOID MRect::SetRect(POINT topLeft, POINT bottomRight)
{
    ::SetRect(this, topLeft.x, topLeft.y, bottomRight.x, bottomRight.y);
}

inline VOID MRect::SetRectEmpty()
    { ::SetRectEmpty(this); }

inline VOID MRect::CopyRect(LPCRECT lpSrcRect)
    { ::CopyRect(this, lpSrcRect); }

inline BOOL MRect::EqualRect(LPCRECT prc) const
    { return ::EqualRect(this, prc); }

inline VOID MRect::InflateRect(INT x, INT y)
    { ::InflateRect(this, x, y); }

inline VOID MRect::InflateRect(SIZE siz)
    { ::InflateRect(this, siz.cx, siz.cy); }

inline VOID MRect::DeflateRect(INT x, INT y)
    { ::InflateRect(this, -x, -y); }

inline VOID MRect::DeflateRect(SIZE siz)
    { ::InflateRect(this, -siz.cx, -siz.cy); }

inline VOID MRect::OffsetRect(INT x, INT y)
    { ::OffsetRect(this, x, y); }

inline VOID MRect::OffsetRect(SIZE siz)
    { ::OffsetRect(this, siz.cx, siz.cy); }

inline VOID MRect::OffsetRect(POINT pt)
    { ::OffsetRect(this, pt.x, pt.y); }

inline VOID MRect::MoveToX(INT x)
    { right = Width() + x; left = x; }

inline VOID MRect::MoveToY(INT y)
    { bottom = Height() + y; top = y; }

inline VOID MRect::MoveToXY(INT x, INT y)
    { MoveToX(x); MoveToY(y); }

inline VOID MRect::MoveToXY(POINT pt)
    { MoveToX(pt.x); MoveToY(pt.y); }

inline BOOL MRect::IntersectRect(LPCRECT prc1, LPCRECT prc2)
    { return ::IntersectRect(this, prc1, prc2); }

inline BOOL MRect::UnionRect(LPCRECT prc1, LPCRECT prc2)
    { return ::UnionRect(this, prc1, prc2); }

inline BOOL MRect::SubtractRect(LPCRECT prcSrc1, LPCRECT prcSrc2)
    { return ::SubtractRect(this, prcSrc1, prcSrc2); }

inline VOID MRect::operator=(const RECT& rcSrc)
    { ::CopyRect(this, &rcSrc); }

inline BOOL MRect::operator==(const RECT& rc) const
    { return ::EqualRect(this, &rc); }

inline BOOL MRect::operator!=(const RECT& rc) const
    { return !::EqualRect(this, &rc); }

inline VOID MRect::operator+=(POINT pt)
    { ::OffsetRect(this, pt.x, pt.y); }

inline VOID MRect::operator+=(SIZE siz)
    { ::OffsetRect(this, siz.cx, siz.cy); }

inline VOID MRect::operator+=(LPCRECT prc)
    { InflateRect(prc); }

inline VOID MRect::operator-=(POINT pt)
    { ::OffsetRect(this, -pt.x, -pt.y); }

inline VOID MRect::operator-=(SIZE siz)
    { ::OffsetRect(this, -siz.cx, -siz.cy); }

inline VOID MRect::operator-=(LPCRECT prc)
    { DeflateRect(prc); }

inline VOID MRect::operator&=(const RECT& rc)
    { ::IntersectRect(this, this, &rc); }

inline VOID MRect::operator|=(const RECT& rc)
    { ::UnionRect(this, this, &rc); }

inline VOID NormalizeRectDx(LPRECT prc)
{
    INT nTemp;
    if (prc->left > prc->right)
    {
        nTemp = prc->left;
        prc->left = prc->right;
        prc->right = nTemp;
    }
    if (prc->top > prc->bottom)
    {
        nTemp = prc->top;
        prc->top = prc->bottom;
        prc->bottom = nTemp;
    }
}

////////////////////////////////////////////////////////////////////////////

#endif  // ndef MZC4_MPOINTSIZERECT_HPP_

```

`src/MProcessMaker.hpp`:

```hpp
// MProcessMaker.hpp -- Win32API process maker                  -*- C++ -*-
// This file is part of MZC4.  See file "ReadMe.txt" and "License.txt".
////////////////////////////////////////////////////////////////////////////

#ifndef MZC4_MPROCESSMAKER_HPP_
#define MZC4_MPROCESSMAKER_HPP_     14   /* Version 14 */

#include "MFile.hpp"
#include <tchar.h>
#include <string>
#include <cstring>

////////////////////////////////////////////////////////////////////////////

class MProcessMaker
{
public:
    MProcessMaker();
    MProcessMaker(LPCTSTR pszAppName, LPCTSTR pszCommandLine = NULL,
                  LPCTSTR pszzEnvironment = NULL, BOOL bInherit = TRUE,
                  LPSECURITY_ATTRIBUTES lpProcessAttributes = NULL,
                  LPSECURITY_ATTRIBUTES lpThreadAttributes = NULL);
    virtual ~MProcessMaker();

    bool operator!() const;
    operator HANDLE() const;
    HANDLE Handle() const;

    HANDLE  GetProcessHandle() const;
    HANDLE  GetThreadHandle() const;
    DWORD   GetExitCode() const;

    // set attributes for child process
    void SetShowWindow(INT nCmdShow = SW_HIDE);
    void SetCreationFlags(DWORD dwFlags = CREATE_NEW_CONSOLE);
    void SetCurrentDirectory(LPCTSTR pszCurDir);
    void SetDesktop(LPTSTR lpDesktop);
    void SetTitle(LPTSTR lpTitle);
    void SetPosition(DWORD dwX, DWORD dwY);
    void SetSize(DWORD dwXSize, DWORD dwYSize);
    void SetCountChars(DWORD dwXCountChars, DWORD dwYCountChars);
    void SetFillAttirbutes(DWORD dwFillAttribute);

    void SetStdInput(HANDLE hStdIn);
    void SetStdOutput(HANDLE hStdOut);
    void SetStdError(HANDLE hStdErr);

    BOOL PrepareForRedirect(PHANDLE phInputWrite, PHANDLE phOutputRead);
    BOOL PrepareForRedirect(PHANDLE phInputWrite, PHANDLE phOutputRead,
                            PHANDLE phErrorRead);

    BOOL CreateProcessDx(LPCTSTR pszAppName, LPCTSTR pszCommandLine = NULL,
                         LPCTSTR pszzEnvironment = NULL, BOOL bInherit = TRUE,
                         LPSECURITY_ATTRIBUTES lpProcessAttributes = NULL,
                         LPSECURITY_ATTRIBUTES lpThreadAttributes = NULL);
    BOOL CreateProcessAsUserDx(HANDLE hToken, LPCTSTR pszAppName,
                               LPCTSTR pszCommandLine = NULL,
                               LPCTSTR pszzEnvironment = NULL,
                               BOOL bInherit = TRUE,
                               LPSECURITY_ATTRIBUTES lpProcessAttributes = NULL,
                               LPSECURITY_ATTRIBUTES lpThreadAttributes = NULL);
    DWORD WaitForSingleObject(DWORD dwTimeout = INFINITE);
    DWORD WaitForSingleObjectEx(DWORD dwTimeout = INFINITE,
                                BOOL bAlertable = TRUE);
    BOOL TerminateProcess(UINT uExitCode);
    BOOL IsRunning() const;

    void CloseProcessHandle();
    void CloseThreadHandle();
    void CloseStdInput();
    void CloseStdOutput();
    void CloseStdError();

    void CloseAll();

          PROCESS_INFORMATION& ProcessInfo();
    const PROCESS_INFORMATION& ProcessInfo() const;
          STARTUPINFO& StartupInfo();
    const STARTUPINFO& StartupInfo() const;

    BOOL ReadAll(std::string& strOutput, MFile& hOutputRead);
    BOOL ReadAll(std::string& strOutput, MFile& hOutputRead, DWORD dwTimeout);

protected:
    PROCESS_INFORMATION     m_pi;
    STARTUPINFO             m_si;
    DWORD                   m_dwCreationFlags;
    LPCTSTR                 m_pszCurDir;

    void Init();

private:
    // NOTE: MProcessMaker is not copyable.
    MProcessMaker(const MProcessMaker&);
    MProcessMaker& operator=(const MProcessMaker&);
};

////////////////////////////////////////////////////////////////////////////

inline MProcessMaker::MProcessMaker()
{
    Init();
}

inline /*virtual*/ MProcessMaker::~MProcessMaker()
{
    CloseAll();
}

inline MProcessMaker::operator HANDLE() const
{
    return Handle();
}

inline HANDLE MProcessMaker::Handle() const
{
    return (this ? m_pi.hProcess : NULL);
}

inline BOOL MProcessMaker::TerminateProcess(UINT uExitCode)
{
    return ::TerminateProcess(m_pi.hProcess, uExitCode);
}

inline void MProcessMaker::SetStdInput(HANDLE hStdIn)
{
    m_si.hStdInput = hStdIn;
    if (hStdIn)
        m_si.dwFlags |= STARTF_USESTDHANDLES;
}

inline void MProcessMaker::SetStdOutput(HANDLE hStdOut)
{
    m_si.hStdOutput = hStdOut;
    if (hStdOut)
        m_si.dwFlags |= STARTF_USESTDHANDLES;
}

inline void MProcessMaker::SetStdError(HANDLE hStdErr)
{
    m_si.hStdError = hStdErr;
    if (hStdErr)
        m_si.dwFlags |= STARTF_USESTDHANDLES;
}

inline void MProcessMaker::SetShowWindow(INT nCmdShow/* = SW_HIDE*/)
{
    m_si.wShowWindow = static_cast<WORD>(nCmdShow);
    m_si.dwFlags |= STARTF_USESHOWWINDOW;
}

inline void MProcessMaker::SetCreationFlags(
    DWORD dwFlags/* = CREATE_NEW_CONSOLE*/)
{
    m_dwCreationFlags = dwFlags;
}

inline void MProcessMaker::SetCurrentDirectory(LPCTSTR pszCurDir)
{
    m_pszCurDir = pszCurDir;
}

inline void MProcessMaker::SetDesktop(LPTSTR lpDesktop)
{
    m_si.lpDesktop = lpDesktop;
}

inline void MProcessMaker::SetTitle(LPTSTR lpTitle)
{
    m_si.lpTitle = lpTitle;
}

inline void MProcessMaker::SetPosition(DWORD dwX, DWORD dwY)
{
    m_si.dwX = dwX;
    m_si.dwY = dwY;
    m_si.dwFlags |= STARTF_USEPOSITION;
}

inline void MProcessMaker::SetSize(DWORD dwXSize, DWORD dwYSize)
{
    m_si.dwXSize = dwXSize;
    m_si.dwYSize = dwYSize;
    m_si.dwFlags |= STARTF_USESIZE;
}

inline void MProcessMaker::SetCountChars(
    DWORD dwXCountChars, DWORD dwYCountChars)
{
    m_si.dwXCountChars = dwXCountChars;
    m_si.dwYCountChars = dwYCountChars;
    m_si.dwFlags |= STARTF_USECOUNTCHARS;
}

inline void MProcessMaker::SetFillAttirbutes(DWORD dwFillAttribute)
{
    m_si.dwFillAttribute = dwFillAttribute;
    m_si.dwFlags |= STARTF_USEFILLATTRIBUTE;
}

inline HANDLE MProcessMaker::GetProcessHandle() const
{
    return (this ? m_pi.hProcess : NULL);
}

inline HANDLE MProcessMaker::GetThreadHandle() const
{
    return (this ? m_pi.hThread : NULL);
}

inline DWORD MProcessMaker::GetExitCode() const
{
    assert(m_pi.hProcess);
    DWORD dwExitCode;
    ::GetExitCodeProcess(m_pi.hProcess, &dwExitCode);
    return dwExitCode;
}

inline DWORD MProcessMaker::WaitForSingleObject(DWORD dwTimeout/* = INFINITE*/)
{
    assert(m_pi.hProcess);
    return ::WaitForSingleObject(m_pi.hProcess, dwTimeout);
}

inline DWORD MProcessMaker::WaitForSingleObjectEx(
    DWORD dwTimeout/* = INFINITE*/, BOOL bAlertable/* = TRUE*/)
{
    assert(m_pi.hProcess);
    return ::WaitForSingleObjectEx(m_pi.hProcess, dwTimeout, bAlertable);
}

inline BOOL MProcessMaker::IsRunning() const
{
    DWORD dwWait = ::WaitForSingleObject(m_pi.hProcess, 0);
    return dwWait == WAIT_TIMEOUT;
}

inline bool MProcessMaker::operator!() const
{
    return Handle() == NULL;
}

inline PROCESS_INFORMATION& MProcessMaker::ProcessInfo()
{
    return m_pi;
}

inline STARTUPINFO& MProcessMaker::StartupInfo()
{
    return m_si;
}

inline const PROCESS_INFORMATION& MProcessMaker::ProcessInfo() const
{
    return m_pi;
}

inline const STARTUPINFO& MProcessMaker::StartupInfo() const
{
    return m_si;
}

inline void MProcessMaker::CloseProcessHandle()
{
    if (m_pi.hProcess != NULL)
    {
        ::CloseHandle(m_pi.hProcess);
        m_pi.hProcess = NULL;
    }
}

inline void MProcessMaker::CloseThreadHandle()
{
    if (m_pi.hThread != NULL)
    {
        ::CloseHandle(m_pi.hThread);
        m_pi.hThread = NULL;
    }
}

inline void MProcessMaker::CloseStdInput()
{
    HANDLE hStdInput = ::GetStdHandle(STD_INPUT_HANDLE);
    if (m_si.hStdInput != hStdInput)
    {
        ::CloseHandle(m_si.hStdInput);
        m_si.hStdInput = hStdInput;
    }
}

inline void MProcessMaker::CloseStdOutput()
{
    HANDLE hStdOutput = ::GetStdHandle(STD_OUTPUT_HANDLE);
    if (m_si.hStdOutput != hStdOutput)
    {
        ::CloseHandle(m_si.hStdOutput);
        m_si.hStdOutput = hStdOutput;
    }
}

inline void MProcessMaker::CloseStdError()
{
    HANDLE hStdError = ::GetStdHandle(STD_ERROR_HANDLE);
    if (m_si.hStdError != hStdError)
    {
        ::CloseHandle(m_si.hStdError);
        m_si.hStdError = hStdError;
    }
}

inline void MProcessMaker::CloseAll()
{
    CloseProcessHandle();
    CloseThreadHandle();
    CloseStdInput();
    CloseStdOutput();
    CloseStdError();
}

inline BOOL MProcessMaker::PrepareForRedirect(
    PHANDLE phInputWrite, PHANDLE phOutputRead)
{
    return PrepareForRedirect(phInputWrite, phOutputRead, phOutputRead);
}

////////////////////////////////////////////////////////////////////////////

inline void MProcessMaker::Init()
{
    ZeroMemory(&m_si, sizeof(m_si));
    m_si.cb = sizeof(STARTUPINFO);

    ZeroMemory(&m_pi, sizeof(m_pi));
    m_dwCreationFlags = 0;
    m_pszCurDir = NULL;
    m_si.hStdInput = ::GetStdHandle(STD_INPUT_HANDLE);
    m_si.hStdOutput = ::GetStdHandle(STD_OUTPUT_HANDLE);
    m_si.hStdError = ::GetStdHandle(STD_ERROR_HANDLE);
}

inline MProcessMaker::MProcessMaker(
    LPCTSTR pszAppName, LPCTSTR pszCommandLine/* = NULL*/,
    LPCTSTR pszzEnvironment/* = NULL*/, BOOL bInherit/* = TRUE*/,
    LPSECURITY_ATTRIBUTES lpProcessAttributes/* = NULL*/,
    LPSECURITY_ATTRIBUTES lpThreadAttributes/* = NULL*/)
{
    Init();
    CreateProcessDx(pszAppName, pszCommandLine, pszzEnvironment,
        bInherit, lpProcessAttributes, lpThreadAttributes);
}

inline BOOL MProcessMaker::CreateProcessDx(
    LPCTSTR pszAppName, LPCTSTR pszCommandLine/* = NULL*/,
    LPCTSTR pszzEnvironment/* = NULL*/, BOOL bInherit/* = TRUE*/,
    LPSECURITY_ATTRIBUTES lpProcessAttributes/* = NULL*/,
    LPSECURITY_ATTRIBUTES lpThreadAttributes/* = NULL*/)
{
    using namespace std;
    BOOL b;
    LPTSTR pszCmdLine = _tcsdup(pszCommandLine);
    LPCVOID pcEnv = reinterpret_cast<LPCVOID>(pszzEnvironment);
    LPVOID pEnv = const_cast<LPVOID>(pcEnv);
    DWORD dwCreationFlags = m_dwCreationFlags;
    if (pszCmdLine)
    {
        #ifdef UNICODE
            if (pEnv)
                dwCreationFlags |= CREATE_UNICODE_ENVIRONMENT;
            b = ::CreateProcess(pszAppName, pszCmdLine, 
                lpProcessAttributes, lpThreadAttributes,
                bInherit, dwCreationFlags, pEnv, m_pszCurDir, &m_si, &m_pi);
        #else
            b = ::CreateProcess(pszAppName, pszCmdLine, 
                lpProcessAttributes, lpThreadAttributes,
                bInherit, dwCreationFlags, pEnv,
                m_pszCurDir, &m_si, &m_pi);
        #endif
        free(pszCmdLine);
    }
    else
    {
        #ifdef UNICODE
            if (pEnv)
                dwCreationFlags |= CREATE_UNICODE_ENVIRONMENT;
            b = ::CreateProcess(pszAppName, NULL,
                lpProcessAttributes, lpThreadAttributes,
                bInherit, dwCreationFlags,
                pEnv, m_pszCurDir, &m_si, &m_pi);
        #else
            b = ::CreateProcess(pszAppName, NULL,
                lpProcessAttributes, lpThreadAttributes,
                bInherit, dwCreationFlags, pEnv,
                m_pszCurDir, &m_si, &m_pi);
        #endif
    }
    return b;
}

inline BOOL MProcessMaker::CreateProcessAsUserDx(
    HANDLE hToken, LPCTSTR pszAppName, LPCTSTR pszCommandLine/* = NULL*/,
    LPCTSTR pszzEnvironment/* = NULL*/, BOOL bInherit/* = TRUE*/,
    LPSECURITY_ATTRIBUTES lpProcessAttributes/* = NULL*/,
    LPSECURITY_ATTRIBUTES lpThreadAttributes/* = NULL*/)
{
    using namespace std;
    BOOL b;
    LPTSTR pszCmdLine = _tcsdup(pszCommandLine);
    LPCVOID pcEnv = reinterpret_cast<LPCVOID>(pszzEnvironment);
    LPVOID pEnv = const_cast<LPVOID>(pcEnv);
    DWORD dwCreationFlags = m_dwCreationFlags;
    if (pszCmdLine)
    {
        LPTSTR pszCmdLine = const_cast<LPTSTR>(pszCommandLine);
        #ifdef UNICODE
            if (pEnv)
                dwCreationFlags |= CREATE_UNICODE_ENVIRONMENT;
            b = ::CreateProcessAsUser(hToken, pszAppName, pszCmdLine,
                lpProcessAttributes, lpThreadAttributes,
                bInherit, dwCreationFlags, pEnv, m_pszCurDir, &m_si, &m_pi);
        #else
            b = ::CreateProcessAsUser(hToken, pszAppName, pszCmdLine,
                lpProcessAttributes, lpThreadAttributes,
                bInherit, dwCreationFlags, pEnv, m_pszCurDir, &m_si, &m_pi);
        #endif
        free(pszCmdLine);
    }
    else
    {
        #ifdef UNICODE
            if (pEnv)
                dwCreationFlags |= CREATE_UNICODE_ENVIRONMENT;
            b = ::CreateProcessAsUser(hToken, pszAppName, NULL, 
                lpProcessAttributes, lpThreadAttributes,
                bInherit, dwCreationFlags, pEnv, m_pszCurDir, &m_si, &m_pi);
        #else
            b = ::CreateProcessAsUser(hToken, pszAppName, NULL, 
                lpProcessAttributes, lpThreadAttributes,
                bInherit, dwCreationFlags, pEnv, m_pszCurDir, &m_si, &m_pi);
        #endif
    }
    return b;
}

inline BOOL MProcessMaker::PrepareForRedirect(
    PHANDLE phInputWrite, PHANDLE phOutputRead, PHANDLE phErrorRead)
{
    SECURITY_ATTRIBUTES sa;
    sa.nLength = sizeof(sa);
    sa.lpSecurityDescriptor = NULL;
    sa.bInheritHandle = TRUE;

    MFile hInputRead, hInputWriteTmp;
    MFile hOutputReadTmp, hOutputWrite;
    MFile hErrorReadTmp, hErrorWrite;

    if (phInputWrite)
    {
        if (::CreatePipe(&hInputRead, &hInputWriteTmp, &sa, 0))
        {
            if (!hInputWriteTmp.DuplicateHandle(phInputWrite, FALSE))
                return FALSE;
            hInputWriteTmp.CloseHandle();
        }
        else
            return FALSE;
    }

    if (phOutputRead)
    {
        if (::CreatePipe(&hOutputReadTmp, &hOutputWrite, &sa, 0))
        {
            if (!hOutputReadTmp.DuplicateHandle(phOutputRead, FALSE))
                return FALSE;
            hOutputReadTmp.CloseHandle();
        }
        else
            return FALSE;
    }

    if (phOutputRead && phOutputRead == phErrorRead)
    {
        if (!hOutputWrite.DuplicateHandle(&hErrorWrite, TRUE))
            return FALSE;
    }
    else if (phErrorRead)
    {
        if (::CreatePipe(&hErrorReadTmp, &hErrorWrite, &sa, 0))
        {
            if (!hErrorReadTmp.DuplicateHandle(phErrorRead, FALSE))
                return FALSE;
            hErrorReadTmp.CloseHandle();
        }
        else
            return FALSE;
    }

    if (phInputWrite != NULL)
        SetStdInput(hInputRead.Detach());
    if (phOutputRead != NULL)
        SetStdOutput(hOutputWrite.Detach());
    if (phErrorRead != NULL)
        SetStdError(hErrorWrite.Detach());

    return TRUE;
}

inline BOOL
MProcessMaker::ReadAll(std::string& strOutput, MFile& hOutputRead)
{
    strOutput.clear();

    DWORD cbAvail, cbRead;
    CHAR szBuf[1024];
    while (hOutputRead.PeekNamedPipe(NULL, 0, NULL, &cbAvail))
    {
        if (cbAvail == 0)
        {
            if (!IsRunning())
                return TRUE;

            continue;
        }

        if (cbAvail > sizeof(szBuf))
            cbAvail = sizeof(szBuf);
        else if (cbAvail == 0)
            continue;

        if (hOutputRead.ReadFile(szBuf, cbAvail, &cbRead))
        {
            if (cbRead == 0)
                continue;

            strOutput.append(szBuf, cbRead);
        }
    }

    return FALSE;
}

inline BOOL
MProcessMaker::ReadAll(std::string& strOutput, MFile& hOutputRead, DWORD dwTimeout)
{
    DWORD dwTick = GetTickCount();

    DWORD cbAvail, cbRead;
    CHAR szBuf[1024];
    while (hOutputRead.PeekNamedPipe(NULL, 0, NULL, &cbAvail))
    {
        if (GetTickCount() - dwTick >= dwTimeout)
            break;

        if (cbAvail == 0)
        {
            if (!IsRunning())
                return TRUE;

            continue;
        }

        if (cbAvail > sizeof(szBuf))
            cbAvail = sizeof(szBuf);
        else if (cbAvail == 0)
            continue;

        if (hOutputRead.ReadFile(szBuf, cbAvail, &cbRead))
        {
            if (cbRead == 0)
                continue;

            strOutput.append(szBuf, cbRead);
        }
    }

    return FALSE;
}

////////////////////////////////////////////////////////////////////////////

#endif  // ndef MZC4_MPROCESSMAKER_HPP_

```

`src/MRadWindow.hpp`:

```hpp
// MRadWindow.hpp --- RADical development window
//////////////////////////////////////////////////////////////////////////////
// RisohEditor --- Another free Win32 resource editor
// Copyright (C) 2017-2018 Katayama Hirofumi MZ <katayama.hirofumi.mz@gmail.com>
// 
// This program is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
// 
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
// 
// You should have received a copy of the GNU General Public License
// along with this program.  If not, see <http://www.gnu.org/licenses/>.
//////////////////////////////////////////////////////////////////////////////

#pragma once

#include "resource.h"
#include "MWindowBase.hpp"
#include "MRubberBand.hpp"
#include "MIndexLabels.hpp"
#include "MAddCtrlDlg.hpp"
#include "MDlgPropDlg.hpp"
#include "MCtrlPropDlg.hpp"
#include "DialogRes.hpp"
#include "PackedDIB.hpp"
#include "Res.hpp"
#include "IconRes.hpp"
#include <map>
#include <unordered_set>     // for std::unordered_set
#include <climits>
#include "MOleHost.hpp"

class MRadCtrl;
class MRadDialog;
class MRadWindow;

//////////////////////////////////////////////////////////////////////////////
// constants

// user-defined window messages
#define MYWM_CTRLMOVE           (WM_USER + 100)     // control was moved
#define MYWM_CTRLSIZE           (WM_USER + 101)     // control was resized
#ifndef MYWM_SELCHANGE
    #define MYWM_SELCHANGE      (WM_USER + 102)     // selection was changed
#endif
#define MYWM_DLGSIZE            (WM_USER + 103)     // dialog was resized
#define MYWM_DELETESEL          (WM_USER + 104)     // selection was deleted
#define MYWM_MOVESIZEREPORT     (WM_USER + 105)     // report moving/resizing
#define MYWM_CLEARSTATUS        (WM_USER + 106)     // clear status
#define MYWM_COMPILECHECK       (WM_USER + 107)     // compilation check
#define MYWM_REOPENRAD          (WM_USER + 108)     // reopen the RADical window
#define MYWM_GETUNITS           (WM_USER + 109)     // get the dialog base units
#define MYWM_UPDATEDLGRES       (WM_USER + 110)     // update the dialog res
#define MYWM_REDRAW             (WM_USER + 111)     // redraw MRadDialog
#define MYWM_RADDBLCLICK       (WM_USER + 115)     // Double-clicked on control

#define GRID_SIZE   5   // grid size

//////////////////////////////////////////////////////////////////////////////
// MRadCtrl --- the RADical controls
// NOTE: An MRadCtrl is a dialog control, subclassed by MRadDialog.

class MRadCtrl : public MWindowBase
{
public:
    DWORD           m_dwMagic;          // magic number to verify the instance
    BOOL            m_bTopCtrl;         // is it a top control?
    HWND            m_hwndRubberBand;   // the rubber band window
    BOOL            m_bMoving;          // is it moving?
    BOOL            m_bSizing;          // is it resizing?
    BOOL            m_bLocking;         // is it locked?
    INT             m_nIndex;           // the control index
    POINT           m_pt;               // the position
    INT             m_nImageType;       // the image type

    // constructor
    MRadCtrl() : m_dwMagic(0xDEADFACE), m_bTopCtrl(FALSE), m_hwndRubberBand(NULL),
                 m_bMoving(FALSE), m_bSizing(FALSE), m_bLocking(FALSE), m_nIndex(-1)
    {
        m_pt.x = m_pt.y = -1;
        m_nImageType = 0;
    }

    // the default icon
    static HICON& Icon()
    {
        static HICON s_hIcon = LoadIcon(GetModuleHandle(NULL), MAKEINTRESOURCE(IDI_ICO));
        return s_hIcon;
    }

    // the default bitmap
    static HBITMAP& Bitmap()
    {
        static HBITMAP s_hbm = LoadBitmap(GetModuleHandle(NULL),
                                          MAKEINTRESOURCE(IDB_BMP));
        return s_hbm;
    }

    // is the window a group box?
    static BOOL IsGroupBox(HWND hCtrl)
    {
        WCHAR szClass[8];
        GetClassNameW(hCtrl, szClass, _countof(szClass));
        if (lstrcmpiW(szClass, L"BUTTON") == 0)
        {
            return (GetWindowStyle(hCtrl) & BS_TYPEMASK) == BS_GROUPBOX;
        }
        return FALSE;
    }

    // call me after subclassing
    void PostSubclass()
    {
        SIZE siz = { 0, 0 };
        TCHAR szClass[16];
        GetWindowPosDx(m_hwnd, NULL, &siz);
        GetClassName(m_hwnd, szClass, _countof(szClass));
        if (lstrcmpi(szClass, TEXT("STATIC")) == 0)
        {
            // static control
            DWORD style = GetWindowStyle(m_hwnd);
            if ((style & SS_TYPEMASK) == SS_ICON)
            {
                m_nImageType = 1;   // icon
                HICON hIcon = Icon();
                SendMessage(m_hwnd, STM_SETIMAGE, IMAGE_ICON, (LPARAM)hIcon);
                SetWindowPosDx(m_hwnd, NULL, &siz);
            }
            else if ((style & SS_TYPEMASK) == SS_BITMAP)
            {
                m_nImageType = 2;   // bitmap
                HBITMAP hbm = Bitmap();
                SendMessage(m_hwnd, STM_SETIMAGE, IMAGE_BITMAP, (LPARAM)hbm);
                SetWindowPosDx(m_hwnd, NULL, &siz);
            }
            return;
        }
    }

    // the targets (the selected window handles)
    typedef std::unordered_set<HWND> set_type;
    static set_type& GetTargets()
    {
        static set_type s_set;
        return s_set;
    }

    // the last selection (the selected window handle)
    static HWND& GetLastSel()
    {
        static HWND s_hwnd = NULL;
        return s_hwnd;
    }

    // get the target control indexes
    static std::unordered_set<INT> GetTargetIndeces()
    {
        set_type targets = MRadCtrl::GetTargets();

        std::unordered_set<INT> indeces;
        for (auto target : targets)
        {
            auto pCtrl = MRadCtrl::GetRadCtrl(target);
            indeces.insert(pCtrl->m_nIndex);
        }
        return indeces;
    }

    // the index-to-control mapping
    typedef std::map<INT, HWND> map_type;
    static map_type& IndexToCtrlMap()
    {
        static map_type s_map;
        return s_map;
    }

    // get the rubber band that is associated to the MRadCtrl
    MRubberBand *GetRubberBand()
    {
        MWindowBase *base = GetUserData(m_hwndRubberBand);
        if (base)
        {
            return static_cast<MRubberBand *>(base);
        }
        return NULL;
    }

    // get the MRadCtrl from a window handle
    static MRadCtrl *GetRadCtrl(HWND hwnd)
    {
        MWindowBase *base = GetUserData(hwnd);
        if (base)
        {
            auto pCtrl = static_cast<MRadCtrl *>(base);
            if (pCtrl->m_dwMagic == 0xDEADFACE)
                return pCtrl;
        }
        return NULL;
    }

    // is the user dragging on the dialog face
    static BOOL& GetRangeSelect(void)
    {
        static BOOL s_bRangeSelect = FALSE;
        return s_bRangeSelect;
    }

    // deselect the selection
    static BOOL DeselectSelection()
    {
        BOOL bFound = FALSE;    // not found yet

        for (auto target : GetTargets())
        {
            MRadCtrl *pCtrl = GetRadCtrl(target);
            if (pCtrl)
            {
                bFound = TRUE;  // found

                // destroy the rubber band of the control
                DestroyWindow(pCtrl->m_hwndRubberBand);
                pCtrl->m_hwndRubberBand = NULL;
            }
        }

        // clear the target set
        GetTargets().clear();

        // clear the last selection
        GetLastSel() = NULL;

        return bFound;  // found or not
    }

    static LRESULT DoSendMessage(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
    {
        return ::SendMessage(hwnd, uMsg, wParam, lParam);
    }

    // delete the selection
    static void DeleteSelection()
    {
        if (GetTargets().empty())
            return;

        // send MYWM_DELETESEL message to the parent of the target
        auto it = GetTargets().begin();
        DoSendMessage(GetParent(*it), MYWM_DELETESEL, 0, 0);
    }

    // deselect this control
    void Deselect()
    {
        // delete the rubber band of this control
        MRubberBand *band = GetRubberBand();
        if (band)
            DestroyWindow(*band);
        m_hwndRubberBand = NULL;

        // remove the control from targets
        GetTargets().erase(m_hwnd);

        // clear the last selection
        GetLastSel() = NULL;
    }

    // is it selected?
    BOOL IsSelected() const
    {
        return IsWindow(m_hwndRubberBand);
    }

    // select the control
    static void Select(HWND hwnd)
    {
        // get the RADical control instance
        auto pCtrl = GetRadCtrl(hwnd);
        if (pCtrl == NULL)
            return;

        // create the rubber band for the control
        auto band = new MRubberBand;
        band->CreateDx(GetParent(hwnd), hwnd, TRUE);
        pCtrl->m_hwndRubberBand = *band;

        // if not group box
        if (!MRadCtrl::IsGroupBox(hwnd))
        {
            // go to bottom! (for better hittest & drawing)
            SetWindowPosDx(hwnd, NULL, NULL, HWND_BOTTOM);

            // NOTE: The index top control is drawed on background. The index bottom control is drawed on foreground.
        }

        // add the handle to the targets
        GetTargets().insert(hwnd);

        // set the handle to the last selection
        GetLastSel() = hwnd;
    }

    static void SelectByIndex(INT nIndex)
    {
        auto it = IndexToCtrlMap().find(nIndex);
        if (it != IndexToCtrlMap().end())
        {
            HWND hwndCtrl = it->second;
            assert(MRadCtrl::GetRadCtrl(hwndCtrl));
            if (auto pCtrl = MRadCtrl::GetRadCtrl(hwndCtrl))
            {
                assert(pCtrl->m_nIndex == nIndex);
            }
            Select(it->second);
        }
    }

    // move the selected RADical controls
    static void MoveSelection(HWND hwnd, INT dx, INT dy)
    {
        // for each target
        for (auto target : GetTargets())
        {
            if (hwnd == target)
                continue;   // care the others only

            if (auto pCtrl = GetRadCtrl(target))    // RADical control?
            {
                // get the window rectangle relative to the parent
                RECT rc;
                GetWindowRect(*pCtrl, &rc);
                MapWindowRect(NULL, ::GetParent(*pCtrl), &rc);

                // move the offset by dx and dy
                OffsetRect(&rc, dx, dy);

                // move it
                pCtrl->m_bMoving = TRUE;
                pCtrl->SetWindowPosDx((LPPOINT)&rc);
                pCtrl->m_bMoving = FALSE;
            }
        }

        PostMessage(GetParent(hwnd), MYWM_REDRAW, 0, 0);
    }

    // resize the selected RADical controls
    static void ResizeSelection(HWND hwnd, INT cx, INT cy)
    {
        // for each target
        for (auto target : GetTargets())
        {
            if (hwnd == target)
                continue;   // care the others only

            // is it a resizing RADical control?
            auto pCtrl = GetRadCtrl(target);
            if (pCtrl && !pCtrl->m_bSizing)
            {
                // resize it
                pCtrl->m_bSizing = TRUE;
                SIZE siz = { cx , cy };
                pCtrl->SetWindowPosDx(NULL, &siz);
                pCtrl->m_bSizing = FALSE;

                // also move the rubber band
                if (auto band = pCtrl->GetRubberBand())
                {
                    band->FitToTarget();
                }
            }
        }

        PostMessage(GetParent(hwnd), MYWM_REDRAW, 0, 0);
    }

    // range selection
    struct RANGE_SELECT
    {
        RECT rc;
        BOOL bCtrlDown;
    };

    // callback function for DoRangeSelect
    static BOOL CALLBACK
    RangeSelectProc(HWND hwnd, LPARAM lParam)
    {
        auto prs = (RANGE_SELECT *)lParam;
        RECT *prc = &prs->rc;
        RECT rc;

        // is it a RADical control?
        if (auto pCtrl = GetRadCtrl(hwnd))
        {
            // is it a top control?
            if (!pCtrl->m_bTopCtrl)
                return TRUE;    // continue

            // get the window rectangle of the control
            GetWindowRect(*pCtrl, &rc);

            // the control in range?
            if (prc->left <= rc.left && prc->top <= rc.top &&
                rc.right <= prc->right && rc.bottom <= prc->bottom)
            {
                // is [Ctrl] key down?
                if (prs->bCtrlDown)
                {
                    // is the control selected?
                    if (pCtrl->IsSelected())
                    {
                        // deselect
                        pCtrl->Deselect();
                    }
                    else
                    {
                        // select
                        MRadCtrl::Select(*pCtrl);
                    }
                }
                else
                {
                    // is the control not selected?
                    if (!pCtrl->IsSelected())
                    {
                        // select
                        MRadCtrl::Select(*pCtrl);
                    }
                }
            }
        }

        return TRUE;    // continue
    }

    // do range selection
    static void DoRangeSelect(HWND hwndParent, const RECT *prc, BOOL bCtrlDown)
    {
        RANGE_SELECT rs;
        rs.rc = *prc;
        rs.bCtrlDown = bCtrlDown;
        ::EnumChildWindows(hwndParent, RangeSelectProc, (LPARAM)&rs);
    }

    // the window procedure of MRadCtrl
    virtual LRESULT CALLBACK
    WindowProcDx(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
    {
        switch (uMsg)
        {
            HANDLE_MSG(hwnd, WM_NCHITTEST, OnNCHitTest);
            HANDLE_MSG(hwnd, WM_KEYDOWN, OnKey);
            HANDLE_MSG(hwnd, WM_NCLBUTTONDOWN, OnNCLButtonDown);
            HANDLE_MSG(hwnd, WM_NCLBUTTONDBLCLK, OnNCLButtonDown);
            HANDLE_MSG(hwnd, WM_NCMOUSEMOVE, OnNCMouseMove);
            HANDLE_MSG(hwnd, WM_NCLBUTTONUP, OnNCLButtonUp);
            HANDLE_MSG(hwnd, WM_MOVE, OnMove);
            HANDLE_MSG(hwnd, WM_SIZE, OnSize);
            HANDLE_MSG(hwnd, WM_LBUTTONDBLCLK, OnLButtonDown);
            HANDLE_MSG(hwnd, WM_LBUTTONDOWN, OnLButtonDown);
            HANDLE_MSG(hwnd, WM_LBUTTONUP, OnLButtonUp);
            HANDLE_MSG(hwnd, WM_MOUSEMOVE, OnMouseMove);
            HANDLE_MSG(hwnd, WM_NCRBUTTONDOWN, OnNCRButtonDown);
            HANDLE_MSG(hwnd, WM_NCRBUTTONDBLCLK, OnNCRButtonDown);
            HANDLE_MSG(hwnd, WM_NCRBUTTONUP, OnNCRButtonUp);
            HANDLE_MSG(hwnd, WM_ERASEBKGND, OnEraseBkgnd);
            HANDLE_MESSAGE(hwnd, MYWM_REDRAW, OnRedraw);
            case WM_MOVING: case WM_SIZING:
                return 0;
        }
        return DefaultProcDx(hwnd, uMsg, wParam, lParam);
    }

    // MRadCtrl MYWM_REDRAW
    LRESULT OnRedraw(HWND hwnd, WPARAM wParam, LPARAM lParam)
    {
        PostMessage(GetParent(hwnd), MYWM_REDRAW, 0, 0);
        return 0;
    }

    // MRadCtrl WM_ERASEBKGND
    BOOL OnEraseBkgnd(HWND hwnd, HDC hdc)
    {
        // get the window class name of MRadCtrl
        WCHAR szClass[64];
        GetClassNameW(hwnd, szClass, 64);

        // special rendering for specific classes
        if (lstrcmpiW(szClass, TOOLBARCLASSNAMEW) == 0 ||
            lstrcmpiW(szClass, REBARCLASSNAMEW) == 0 ||
            lstrcmpiW(szClass, WC_PAGESCROLLERW) == 0)
        {
            RECT rc;
            GetClientRect(hwnd, &rc);
            FillRect(hdc, &rc, (HBRUSH)(COLOR_3DFACE + 1));
            return TRUE;
        }

        // otherwise default processing
        return (BOOL)DefaultProcDx();
    }

    // MRadCtrl WM_NCRBUTTONDOWN/WM_NCRBUTTONDBLCLK
    void OnNCRButtonDown(HWND hwnd, BOOL fDoubleClick, int x, int y, UINT codeHitTest)
    {
        if (fDoubleClick)
            return;

        // emulate clicking to select the control
        OnNCLButtonDown(hwnd, FALSE, x, y, codeHitTest);
        OnNCLButtonUp(hwnd, x, y, codeHitTest);

        // send WM_NCRBUTTONDOWN to the parent
        DoSendMessage(GetParent(hwnd), WM_NCRBUTTONDOWN, (WPARAM)hwnd, MAKELPARAM(x, y));
    }

    // MRadCtrl WM_NCRBUTTONUP
    void OnNCRButtonUp(HWND hwnd, int x, int y, UINT codeHitTest)
    {
        // eat
    }

    // MRadCtrl WM_LBUTTONDOWN/WM_LBUTTONDBLCLK
    void OnLButtonDown(HWND hwnd, BOOL fDoubleClick, int x, int y, UINT keyFlags)
    {
        // eat
    }

    // MRadCtrl WM_LBUTTONUP
    void OnLButtonUp(HWND hwnd, int x, int y, UINT keyFlags)
    {
        // eat
    }

    // MRadCtrl WM_MOUSEMOVE
    void OnMouseMove(HWND hwnd, int x, int y, UINT keyFlags)
    {
        // eat
    }

    // MRadCtrl WM_MOVE
    void OnMove(HWND hwnd, int x, int y)
    {
        if (!m_bTopCtrl)
        {
            // if not a top control, do default processing
            DefaultProcDx(hwnd, WM_MOVE, 0, MAKELPARAM(x, y));
            return;
        }

        // if not locked
        if (!m_bLocking)
        {
            if (!m_bMoving)
            {
                // move the selected controls by the difference of positions
                POINT pt;
                GetCursorPos(&pt);
                MoveSelection(hwnd, pt.x - m_pt.x, pt.y - m_pt.y);
                m_pt = pt;  // remember the position
            }

            // move the rubber band
            if (auto band = GetRubberBand())
            {
                band->FitToTarget();
            }

            // redraw
            RECT rc;
            GetClientRect(hwnd, &rc);
            InvalidateRect(hwnd, &rc, TRUE);

            // send MYWM_CTRLMOVE to the parent
            DoSendMessage(GetParent(hwnd), MYWM_CTRLMOVE, (WPARAM)hwnd, 0);
        }
    }

    // MRadCtrl WM_SIZE
    void OnSize(HWND hwnd, UINT state, int cx, int cy)
    {
        // default processing
        DefaultProcDx(hwnd, WM_SIZE, state, MAKELPARAM(cx, cy));

        if (!m_bTopCtrl)
            return;     // not a top control

        // is it not locked
        if (!m_bLocking)
        {
            // resize if necessary
            if (!m_bSizing)
                ResizeSelection(hwnd, cx, cy);

            // send MYWM_CTRLSIZE to the parent
            DoSendMessage(GetParent(hwnd), MYWM_CTRLSIZE, (WPARAM)hwnd, 0);

            // redraw
            InvalidateRect(hwnd, NULL, TRUE);
        }
    }

    // MRadCtrl WM_KEYDOWN/WM_KEYUP
    void OnKey(HWND hwnd, UINT vk, BOOL fDown, int cRepeat, UINT flags)
    {
        if (fDown)
        {
            // send WM_KEYDOWN to the parent
            FORWARD_WM_KEYDOWN(GetParent(hwnd), vk, cRepeat, flags, DoSendMessage);
        }
    }

    // MRadCtrl WM_NCLBUTTONDOWN/WM_NCLBUTTONDBLCLK
    void OnNCLButtonDown(HWND hwnd, BOOL fDoubleClick, int x, int y, UINT codeHitTest)
    {
        if (hwnd != m_hwnd)
            return;     // invalid

        // update the position
        GetCursorPos(&m_pt);

        if (fDoubleClick)
        {
            // send MYWM_RADDBLCLICK to the parent
            DoSendMessage(GetParent(hwnd), MYWM_RADDBLCLICK, 0, (LPARAM)hwnd);
            return;
        }

        // ignore if not on the caption
        if (codeHitTest != HTCAPTION)
            return;

        if (GetKeyState(VK_CONTROL) < 0)    // [Ctrl] key is down
        {
            if (m_hwndRubberBand)
            {
                // deselect this control
                Deselect();
                return;     // finish
            }
        }
        else if (GetKeyState(VK_SHIFT) < 0)     // [Shift] key is down
        {
            if (m_hwndRubberBand)
            {
                return;     // finish
            }
        }
        else
        {
            if (!m_hwndRubberBand)
            {
                // deselect the selected controls
                DeselectSelection();
            }
        }

        // if no rubber band that is associated to this control
        if (m_hwndRubberBand == NULL)
        {
            // select this control
            Select(hwnd);
        }

        // enable dragging by emulating the title bar dragging
        DefWindowProc(hwnd, WM_NCLBUTTONDOWN, HTCAPTION, MAKELPARAM(x, y));

        // if not group box
        if (!IsGroupBox(hwnd) && IsWindow(hwnd))
        {
            // go to bottom (for better hittest & drawing)
            SetWindowPosDx(hwnd, NULL, NULL, HWND_BOTTOM);

            // NOTE: The index top control is drawed on background. The index bottom control is drawed on foreground.
        }
    }

    // MRadCtrl WM_NCMOUSEMOVE
    void OnNCMouseMove(HWND hwnd, int x, int y, UINT codeHitTest)
    {
        // default processing
        DefWindowProc(hwnd, WM_NCMOUSEMOVE, codeHitTest, MAKELPARAM(x, y));
    }

    // MRadCtrl WM_NCLBUTTONUP
    void OnNCLButtonUp(HWND hwnd, int x, int y, UINT codeHitTest)
    {
        // finish moving
        m_bMoving = FALSE;

        // clear the position
        m_pt.x = -1;
        m_pt.y = -1;

        // default processing
        DefWindowProc(hwnd, WM_NCLBUTTONUP, codeHitTest, MAKELPARAM(x, y));
    }

    struct MYHITTEST
    {
        HWND hParent;
        HWND hCandidate;
        HWND hLast;
        HWND hGroupBox;
        POINT pt;
    };

    // the helper function for hittest
    static BOOL CALLBACK EnumHitTestChildProc(HWND hwnd, LPARAM lParam)
    {
        // NOTE: EnumChildWindows scans not only children but descendants.

        auto pmht = (MYHITTEST *)lParam;

        // get the window rectangle
        RECT rc;
        GetWindowRect(hwnd, &rc);

        // the point in the rectangle?
        if (!PtInRect(&rc, pmht->pt))
            return TRUE;    // if not, ignore

        // the control has a rubber band?
        if (auto pBand = MRubberBand::GetRubberBand(hwnd))
        {
            // the rubber band's target is the control?
            auto pCtrl = MRadCtrl::GetRadCtrl(pBand->m_hwndTarget);
            if (pCtrl && pCtrl->m_bTopCtrl)
            {
                // clear the candidate
                pmht->hCandidate = NULL;

                // if the window is sgroupbox
                if (IsGroupBox(*pCtrl))
                {
                    // set to hGroupBox
                    pmht->hGroupBox = *pCtrl;
                }
                else
                {
                    // otherwise, set to the last target
                    pmht->hLast = pBand->m_hwndTarget;
                }
            }
        }
        else if (auto pCtrl = MRadCtrl::GetRadCtrl(hwnd))   // is it a RADical control?
        {
            if (pCtrl->m_bTopCtrl)  // a top control
            {
                // set to the last target
                pmht->hLast = hwnd;

                // is it not group box?
                if (!IsGroupBox(hwnd))
                {
                    // it's a candidate
                    pmht->hCandidate = hwnd;
                }
            }
        }

        return TRUE;    // continue
    }

    // MRadCtrl WM_NCHITTEST
    UINT OnNCHitTest(HWND hwnd, int x, int y)
    {
        if (m_bTopCtrl)     // a top control?
        {
            // get the window rectangle
            RECT rc;
            GetWindowRect(hwnd, &rc);

            // if the position is out of rectangle, ignore it
            POINT pt = { x, y };
            if (!PtInRect(&rc, pt))
                return HTTRANSPARENT;

            // it has a rubber band?
            if (m_hwndRubberBand)
            {
                // get the window rectangle of the rubber band
                RECT rcBand;
                GetWindowRect(m_hwndRubberBand, &rcBand);

                // create the region object
                HRGN hRgn = CreateRectRgn(0, 0, 0, 0);
                GetWindowRgn(m_hwndRubberBand, hRgn);
                OffsetRgn(hRgn, rcBand.left, rcBand.top);

                if (PtInRegion(hRgn, x, y))     // if in the region
                {
                    // delete the region object
                    DeleteObject(hRgn);

                    return HTTRANSPARENT;   // ignore
                }

                // delete the region object
                DeleteObject(hRgn);
            }

            // initialize a MYHITTEST
            MYHITTEST mht;
            mht.hParent = GetParent(hwnd);
            mht.hCandidate = NULL;
            mht.hLast = NULL;
            mht.hGroupBox = NULL;
            mht.pt = pt;

            // try to hittest
            EnumChildWindows(mht.hParent, EnumHitTestChildProc, (LPARAM)&mht);

            //if (GetAsyncKeyState(VK_RBUTTON) < 0)
            //    DebugBreak();

            if (mht.hCandidate == hwnd && hwnd != mht.hGroupBox)
            {
                // there is a candidate and it is not group box
                return HTCAPTION;   // emulate caption hittest
            }

            if (!mht.hCandidate && mht.hLast == hwnd)
            {
                // there is no candidate, but last one is this control
                return HTCAPTION;   // emulate caption hittest
            }

            if (mht.hCandidate == hwnd)
            {
                // there is candidate
                return HTCAPTION;   // emulate caption hittest
            }
        }

        // ignore
        return HTTRANSPARENT;
    }

    // called in WM_NCDESTROY
    virtual void PostNcDestroy()
    {
        if (m_bTopCtrl)
        {
            DebugPrintDx("MRadCtrl::PostNcDestroy: %p\n", m_hwnd);
        }
        MWindowBase::PostNcDestroy();

        // delete the MRadCtrl instance
        delete this;
    }

    void DoTest()
    {
        WCHAR szText[256];
        MStringW str = GetWindowTextW();
        StringCchPrintfW(szText, _countof(szText),
            L"MRadCtrl:%p, m_hwnd:%p, m_dwMagic:0x%08X, m_bTopCtrl:%d, m_nIndex:%d, "
            L"str:%s, IndexToCtrlMap()[m_nIndex]: %p",
            this, m_hwnd, m_dwMagic, m_bTopCtrl, m_nIndex,
            str.c_str(), IndexToCtrlMap()[m_nIndex]
        );

        MessageBoxW(NULL, szText, L"MRadCtrl::DoTest()", MB_ICONINFORMATION);
    }
};

//////////////////////////////////////////////////////////////////////////////
// MRadDialog --- RADical dialog

class MRadDialog : public MDialogBase
{
public:
    BOOL            m_index_visible;        // indeces are visible
    POINT           m_ptClicked;            // the clicked position
    POINT           m_ptDragging;           // the dragging position
    MIndexLabels    m_labels;               // the labels
    BOOL            m_bMovingSizing;        // the lock of moving and/or resizing
    INT             m_xDialogBaseUnit;      // the X dialog base unit
    INT             m_yDialogBaseUnit;      // the Y dialog base unit
    HBRUSH          m_hbrBack;              // the background brush

    // contructor
    MRadDialog() : m_index_visible(FALSE), m_bMovingSizing(FALSE)
    {
        // get the dialog base units
        m_xDialogBaseUnit = LOWORD(GetDialogBaseUnits());
        m_yDialogBaseUnit = HIWORD(GetDialogBaseUnits());

        // reset the clicked position
        m_ptClicked.x = m_ptClicked.y = -1;

        // create the label font
        HFONT hFont = GetStockFont(DEFAULT_GUI_FONT);
        LOGFONT lf;
        GetObject(hFont, sizeof(lf), &lf);
        lf.lfHeight = 14;
        hFont = ::CreateFontIndirect(&lf);
        m_labels.m_hFont = hFont;

        // create the background brush
        m_hbrBack = NULL;
        ReCreateBackBrush();
    }

    ~MRadDialog()
    {
        // delete the brush
        DeleteObject(m_hbrBack);
    }

    // the target types to get
    enum TARGET_TYPE
    {
        TARGET_NEXT,        // get the next target
        TARGET_PREV,        // get the previous target
        TARGET_FIRST,       // get the first target
        TARGET_LAST         // get the last target
    };

    // the structure to get the target control
    struct GET_TARGET
    {
        TARGET_TYPE target;
        HWND hwndTarget;
        INT m_nIndex;
        INT m_nCurrentIndex;
    };

    // EnumChildWindows' callback function to get the target
    static BOOL CALLBACK GetTargetProc(HWND hwnd, LPARAM lParam)
    {
        auto get_target = (GET_TARGET *)lParam;
        if (auto pCtrl = MRadCtrl::GetRadCtrl(hwnd))
        {
            if (pCtrl->m_dwMagic != 0xDEADFACE)
                return TRUE;    // invalid

            if (!pCtrl->m_bTopCtrl)
                return TRUE;    // not a top control?

            // get the target and the index
            switch (get_target->target)
            {
            case TARGET_PREV:
                if (get_target->m_nCurrentIndex > pCtrl->m_nIndex &&
                    pCtrl->m_nIndex > get_target->m_nIndex)
                {
                    get_target->m_nIndex = pCtrl->m_nIndex;
                    get_target->hwndTarget = pCtrl->m_hwnd;
                }
                break;

            case TARGET_NEXT:
                if (get_target->m_nCurrentIndex < pCtrl->m_nIndex &&
                    pCtrl->m_nIndex < get_target->m_nIndex)
                {
                    get_target->m_nIndex = pCtrl->m_nIndex;
                    get_target->hwndTarget = pCtrl->m_hwnd;
                }
                break;

            case TARGET_FIRST:
                if (pCtrl->m_nIndex < get_target->m_nIndex)
                {
                    get_target->m_nIndex = pCtrl->m_nIndex;
                    get_target->hwndTarget = pCtrl->m_hwnd;
                }
                break;

            case TARGET_LAST:
                if (pCtrl->m_nIndex > get_target->m_nIndex)
                {
                    get_target->m_nIndex = pCtrl->m_nIndex;
                    get_target->hwndTarget = pCtrl->m_hwnd;
                }
                break;
            }
        }

        return TRUE;    // continue
    }

    HWND GetNextCtrl(HWND hwndCtrl) const
    {
        if (auto pCtrl = MRadCtrl::GetRadCtrl(hwndCtrl))
        {
            GET_TARGET get_target;
            get_target.target = TARGET_NEXT;
            get_target.hwndTarget = NULL;
            get_target.m_nIndex = 0x7FFFFFFF;
            get_target.m_nCurrentIndex = pCtrl->m_nIndex;
            EnumChildWindows(GetParent(hwndCtrl), GetTargetProc, (LPARAM)&get_target);
            return get_target.hwndTarget;
        }
        return NULL;
    }

    HWND GetPrevCtrl(HWND hwndCtrl) const
    {
        if (auto pCtrl = MRadCtrl::GetRadCtrl(hwndCtrl))
        {
            GET_TARGET get_target;
            get_target.target = TARGET_PREV;
            get_target.hwndTarget = NULL;
            get_target.m_nIndex = -1;
            get_target.m_nCurrentIndex = pCtrl->m_nIndex;
            EnumChildWindows(GetParent(hwndCtrl), GetTargetProc, (LPARAM)&get_target);
            return get_target.hwndTarget;
        }
        return NULL;
    }

    static HWND GetFirstCtrl(HWND hwndParent)
    {
        GET_TARGET get_target;
        get_target.target = TARGET_FIRST;
        get_target.hwndTarget = NULL;
        get_target.m_nIndex = 0x7FFFFFFF;
        EnumChildWindows(hwndParent, GetTargetProc, (LPARAM)&get_target);
        return get_target.hwndTarget;
    }

    static HWND GetLastCtrl(HWND hwndParent)
    {
        GET_TARGET get_target;
        get_target.target = TARGET_LAST;
        get_target.hwndTarget = NULL;
        get_target.m_nIndex = -1;
        EnumChildWindows(hwndParent, GetTargetProc, (LPARAM)&get_target);
        return get_target.hwndTarget;
    }

    // the dialog procedure of MRadDialog
    virtual INT_PTR CALLBACK
    DialogProcDx(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
    {
        switch (uMsg)
        {
            HANDLE_MSG(hwnd, WM_INITDIALOG, OnInitDialog);
            HANDLE_MSG(hwnd, WM_LBUTTONDOWN, OnLButtonDown);
            HANDLE_MSG(hwnd, WM_LBUTTONDBLCLK, OnLButtonDown);
            HANDLE_MSG(hwnd, WM_RBUTTONDOWN, OnRButtonDown);
            HANDLE_MSG(hwnd, WM_RBUTTONDBLCLK, OnRButtonDown);
            HANDLE_MESSAGE(hwnd, MYWM_SELCHANGE, OnSelChange);
            HANDLE_MESSAGE(hwnd, MYWM_REDRAW, OnRedraw);
        }
        return 0;
    }

    LRESULT DoSendMessage(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
    {
        return ::SendMessage(hwnd, uMsg, wParam, lParam);
    }

    // MRadDialog WM_RBUTTONDOWN
    void OnRButtonDown(HWND hwnd, BOOL fDoubleClick, int x, int y, UINT keyFlags)
    {
        // clicked on the MRadDialog

        // if [Shift] and/or [Ctrl] was pressed, then ignore
        if (::GetKeyState(VK_SHIFT) < 0 || ::GetKeyState(VK_CONTROL) < 0)
            return;

        // update the clicked position
        m_ptClicked.x = x;
        m_ptClicked.y = y;

        // deselect the controls
        MRadCtrl::DeselectSelection();

        // notify MYWM_SELCHANGE to the parent
        DoSendMessage(GetParent(hwnd), MYWM_SELCHANGE, 0, 0);
    }

    // MRadDialog MYWM_REDRAW
    LRESULT OnRedraw(HWND hwnd, WPARAM wParam, LPARAM lParam)
    {
        InvalidateRect(hwnd, NULL, TRUE);
        return 0;
    }

    // MRadDialog MYWM_SELCHANGE
    LRESULT OnSelChange(HWND hwnd, WPARAM wParam, LPARAM lParam)
    {
        // notify MYWM_SELCHANGE to the parent
        DoSendMessage(GetParent(hwnd), MYWM_SELCHANGE, wParam, lParam);
        return 0;
    }

    // get the normalized rectangle from two points
    void NormalizeRect(RECT *prc, POINT pt0, POINT pt1)
    {
        if (pt0.x < pt1.x)
        {
            prc->left = pt0.x;
            prc->right = pt1.x;
        }
        else
        {
            prc->left = pt1.x;
            prc->right = pt0.x;
        }

        if (pt0.y < pt1.y)
        {
            prc->top = pt0.y;
            prc->bottom = pt1.y;
        }
        else
        {
            prc->top = pt1.y;
            prc->bottom = pt0.y;
        }
    }

    // draw the dragging rectangle
    void DrawDragSelect(HWND hwnd)
    {
        if (HDC hDC = GetDC(hwnd))
        {
            RECT rc;
            NormalizeRect(&rc, m_ptClicked, m_ptDragging);

            DrawFocusRect(hDC, &rc);

            ReleaseDC(hwnd, hDC);
        }
    }

    // MRadDialog WM_LBUTTONDOWN/WM_LBUTTONDBLCLK
    void OnLButtonDown(HWND hwnd, BOOL fDoubleClick, int x, int y, UINT keyFlags)
    {
        // update the clicked position
        m_ptClicked.x = x;
        m_ptClicked.y = y;

        // if not [Shift] nor [Ctrl] pressed
        if (::GetKeyState(VK_SHIFT) >= 0 && ::GetKeyState(VK_CONTROL) >= 0)
        {
            if (fDoubleClick)
            {
                // send MYWM_RADDBLCLICK to the parent
                DoSendMessage(GetParent(hwnd), MYWM_RADDBLCLICK, 0, (LPARAM)NULL);
                return;
            }
            else
            {
                // deselect the controls
                MRadCtrl::DeselectSelection();
            }
        }

        // if not range selection
        if (!MRadCtrl::GetRangeSelect())
        {
            // update the dragging position
            m_ptDragging = m_ptClicked;

            // draw the dragging selection
            DrawDragSelect(hwnd);

            // enable the range selection
            MRadCtrl::GetRangeSelect() = TRUE;

            // start mouse capturing
            SetCapture(hwnd);
        }

        // notify MYWM_SELCHANGE to the parent
        DoSendMessage(GetParent(hwnd), MYWM_SELCHANGE, 0, 0);
    }

    // MRadDialog WM_MOUSEMOVE
    void OnMouseMove(HWND hwnd, int x, int y, UINT keyFlags)
    {
        if (MRadCtrl::GetRangeSelect())     // in range selection
        {
            // erase the previous dragging selection
            DrawDragSelect(hwnd);

            // update the dragging position
            m_ptDragging.x = x;
            m_ptDragging.y = y;

            // draw the new dragging selection
            DrawDragSelect(hwnd);
        }
    }

    // MRadDialog WM_CAPTURECHANGED
    void OnCaptureChanged(HWND hwnd)
    {
        if (MRadCtrl::GetRangeSelect())     // in range selection
        {
            // erase the previous dragging selection
            DrawDragSelect(hwnd);

            // disable range selection
            MRadCtrl::GetRangeSelect() = FALSE;
        }
    }

    // MRadDialog WM_LBUTTONUP
    void OnLButtonUp(HWND hwnd, int x, int y, UINT keyFlags)
    {
        if (MRadCtrl::GetRangeSelect())     // in range selection
        {
            // get the rectangle from two points
            RECT rc;
            NormalizeRect(&rc, m_ptClicked, m_ptDragging);

            // convert it to the screen coordinates
            MapWindowRect(hwnd, NULL, &rc);

            // if [Shift] and [Ctrl] keys are not pressed
            if (GetAsyncKeyState(VK_SHIFT) >= 0 &&
                GetAsyncKeyState(VK_CONTROL) >= 0)
            {
                // deselect the controls
                MRadCtrl::DeselectSelection();
            }

            // release the capture
            ReleaseCapture();

            // disable range selection
            MRadCtrl::GetRangeSelect() = FALSE;

            // is [Ctrl] key down?
            BOOL bCtrlDown = GetAsyncKeyState(VK_CONTROL) < 0;

            // update the selection status of the controls
            MRadCtrl::DoRangeSelect(hwnd, &rc, bCtrlDown);
        }

        // notify MYWM_SELCHANGE to the parent
        DoSendMessage(GetParent(hwnd), MYWM_SELCHANGE, 0, 0);
    }

    // MRadDialog WM_ERASEBKGND
    BOOL OnEraseBkgnd(HWND hwnd, HDC hdc)
    {
        // create the background brush if necessary
        if (m_hbrBack == NULL)
            ReCreateBackBrush();

        // get the client rectangle
        RECT rc;
        GetClientRect(hwnd, &rc);

        // fill the rectangle by the brush
        FillRect(hdc, &rc, m_hbrBack);

        return TRUE;    // processed
    }

    // the window procedure of MRadDialog
    virtual LRESULT CALLBACK
    WindowProcDx(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
    {
        switch (uMsg)
        {
            HANDLE_MSG(hwnd, WM_NCLBUTTONDBLCLK, OnNCLButtonDown);
            HANDLE_MSG(hwnd, WM_NCLBUTTONDOWN, OnNCLButtonDown);
            HANDLE_MSG(hwnd, WM_NCLBUTTONUP, OnNCLButtonUp);
            HANDLE_MSG(hwnd, WM_NCRBUTTONDBLCLK, OnNCRButtonDown);
            HANDLE_MSG(hwnd, WM_NCRBUTTONDOWN, OnNCRButtonDown);
            HANDLE_MSG(hwnd, WM_NCRBUTTONUP, OnNCRButtonUp);
            HANDLE_MSG(hwnd, WM_NCMOUSEMOVE, OnNCMouseMove);
            HANDLE_MSG(hwnd, WM_MOUSEMOVE, OnMouseMove);
            HANDLE_MSG(hwnd, WM_LBUTTONUP, OnLButtonUp);
            HANDLE_MSG(hwnd, WM_KEYDOWN, OnKey);
            HANDLE_MSG(hwnd, WM_SIZE, OnSize);
            HANDLE_MSG(hwnd, WM_SYSCOLORCHANGE, OnSysColorChange);
            HANDLE_MSG(hwnd, WM_ERASEBKGND, OnEraseBkgnd);
            HANDLE_MESSAGE(hwnd, MYWM_CTRLMOVE, OnCtrlMove);
            HANDLE_MESSAGE(hwnd, MYWM_CTRLSIZE, OnCtrlSize);
            HANDLE_MESSAGE(hwnd, MYWM_DELETESEL, OnDeleteSel);
            HANDLE_MESSAGE(hwnd, MYWM_RADDBLCLICK, OnRadDblClick);
            case WM_CAPTURECHANGED:
                OnCaptureChanged(hwnd);
                break;
        }
        return CallWindowProcDx(hwnd, uMsg, wParam, lParam);
    }

    // MRadDialog MYWM_RADDBLCLICK
    LRESULT OnRadDblClick(HWND hwnd, WPARAM wParam, LPARAM lParam)
    {
        // send MYWM_RADDBLCLICK to the parent
        DoSendMessage(GetParent(hwnd), MYWM_RADDBLCLICK, wParam, lParam);
        return 0;
    }

    // MRadDialog WM_SIZE
    void OnSize(HWND hwnd, UINT state, int cx, int cy)
    {
        // moving or resizing?
        if (m_bMovingSizing)
            return;     // ignore

        // send MYWM_DLGSIZE to the parent
        DoSendMessage(GetParent(hwnd), MYWM_DLGSIZE, 0, 0);
    }

    // MRadDialog MYWM_DELETESEL
    LRESULT OnDeleteSel(HWND hwnd, WPARAM wParam, LPARAM lParam)
    {
        // send MYWM_DELETESEL to the parent
        DoSendMessage(GetParent(hwnd), MYWM_DELETESEL, wParam, lParam);
        return 0;
    }

    // MRadDialog MYWM_CTRLMOVE
    LRESULT OnCtrlMove(HWND hwnd, WPARAM wParam, LPARAM lParam)
    {
        // send MYWM_CTRLMOVE to the parent
        DoSendMessage(GetParent(hwnd), MYWM_CTRLMOVE, wParam, lParam);
        return 0;
    }

    // MRadDialog MYWM_CTRLSIZE
    LRESULT OnCtrlSize(HWND hwnd, WPARAM wParam, LPARAM lParam)
    {
        // send MYWM_CTRLSIZE to the parent
        DoSendMessage(GetParent(hwnd), MYWM_CTRLSIZE, wParam, lParam);
        return 0;
    }

    // MRadDialog WM_NCLBUTTONDOWN/WM_NCLBUTTONDBLCLK
    void OnNCLButtonDown(HWND hwnd, BOOL fDoubleClick, int x, int y, UINT codeHitTest)
    {
        // eat
    }

    // MRadDialog WM_NCLBUTTONUP
    void OnNCLButtonUp(HWND hwnd, int x, int y, UINT codeHitTest)
    {
        // eat
    }

    // MRadDialog WM_NCRBUTTONDOWN/WM_NCRBUTTONDBLCLK
    void OnNCRButtonDown(HWND hwnd, BOOL fDoubleClick, int x, int y, UINT codeHitTest)
    {
        if (fDoubleClick)
            return;

        // update the clicked position
        m_ptClicked.x = x;
        m_ptClicked.y = y;
        // into screen coordinates
        ScreenToClient(hwnd, &m_ptClicked);

        // send WM_CONTEXTMENU to the parent
        FORWARD_WM_CONTEXTMENU(GetParent(hwnd), hwnd, x, y, DoSendMessage);
    }

    // MRadDialog WM_NCRBUTTONUP
    void OnNCRButtonUp(HWND hwnd, int x, int y, UINT codeHitTest)
    {
        // eat
    }

    // MRadDialog WM_NCMOUSEMOVE
    void OnNCMouseMove(HWND hwnd, int x, int y, UINT codeHitTest)
    {
        // eat
    }

    // MRadDialog WM_KEYDOWN/WM_KEYUP
    void OnKey(HWND hwnd, UINT vk, BOOL fDown, int cRepeat, UINT flags)
    {
        if (fDown)
        {
            // send it to the parent
            FORWARD_WM_KEYDOWN(GetParent(hwnd), vk, cRepeat, flags, DoSendMessage);
        }
    }

    // NOTE: We have to do subclassing all the children controls and their descendants
    //       to modify the hittesting.

    // do subclassing a control and its descendants
    void DoSubclass(HWND hCtrl, INT nIndex)
    {
        // make it an MRadCtrl
        MRadCtrl *pCtrl = new MRadCtrl();
        pCtrl->SubclassDx(hCtrl);
        pCtrl->m_bTopCtrl = (nIndex != -1);
        pCtrl->m_nIndex = nIndex;

        if (nIndex != -1)   // a top control?
        {
            // update the index-to-control mapping
            MRadCtrl::IndexToCtrlMap()[nIndex] = hCtrl;
        }

        pCtrl->PostSubclass();

#ifndef NDEBUG
        MString text = GetWindowText(hCtrl);
        DebugPrintDx(TEXT("MRadCtrl::DoSubclass: %p, %d, '%s'\n"), hCtrl, nIndex, text.c_str());
#endif

        // do subclassing its children
        DoSubclassChildren(hCtrl);
    }

    // do subclassing the children
    void DoSubclassChildren(HWND hwnd, BOOL bTop = FALSE)
    {
        HWND hCtrl = GetTopWindow(hwnd);
        if (bTop)   // a top control?
        {
            INT nIndex = 0;
            while (hCtrl)
            {
                // do subclassing
                DoSubclass(hCtrl, nIndex);

                // increment the index
                ++nIndex;

                // get the next control
                hCtrl = GetWindow(hCtrl, GW_HWNDNEXT);
            }
        }
        else    // not a top control
        {
            while (hCtrl)
            {
                // subclass the non-top control
                DoSubclass(hCtrl, -1);

                // get the next
                hCtrl = GetWindow(hCtrl, GW_HWNDNEXT);
            }
        }
    }

    // create the background brush
    BOOL ReCreateBackBrush()
    {
        // delete the previous
        if (m_hbrBack)
        {
            DeleteObject(m_hbrBack);
            m_hbrBack = NULL;
        }

        // 3D face collor
        COLORREF rgb = GetSysColor(COLOR_3DFACE);

        // calculate another color
        DWORD dwTotal = GetRValue(rgb) + GetGValue(rgb) + GetBValue(rgb);
        rgb = (dwTotal < 255) ? RGB(255, 255, 255) : RGB(0, 0, 0);

        // an 8x8-pixel rectangle
        RECT rc8x8 = { 0, 0, 8, 8 };

        // create an 8x8 bitmap
        HBITMAP hbm8x8 = Create24BppBitmapDx(8, 8);
        if (HDC hDC = CreateCompatibleDC(NULL))
        {
            HGDIOBJ hbmOld = SelectObject(hDC, hbm8x8);
            {
                FillRect(hDC, &rc8x8, (HBRUSH)(COLOR_3DFACE + 1));
                if (g_settings.bShowDotsOnDialog)
                {
                    for (int y = 0; y < 8; y += 4)
                    {
                        for (int x = 0; x < 8; x += 4)
                        {
                            SetPixelV(hDC, x, y, rgb);
                        }
                    }
                }
            }
            SelectObject(hDC, hbmOld);
            DeleteDC(hDC);
        }

        // create a packed DIB
        std::vector<BYTE> data;
        PackedDIB_CreateFromHandle(data, hbm8x8);
        DeleteObject(hbm8x8);

        // create the brush
        m_hbrBack = CreateDIBPatternBrushPt(&data[0], DIB_RGB_COLORS);
        return m_hbrBack != NULL;
    }

    // MRadDialog WM_SYSCOLORCHANGE
    void OnSysColorChange(HWND hwnd)
    {
        // recreate the back brush
        ReCreateBackBrush();

        // redraw
        InvalidateRect(hwnd, NULL, TRUE);
    }

    // MRadDialog WM_INITDIALOG
    BOOL OnInitDialog(HWND hwnd, HWND hwndFocus, LPARAM lParam)
    {
        // update the background brush
        OnSysColorChange(hwnd);

        // initialize
        MRadCtrl::GetTargets().clear();
        MRadCtrl::GetLastSel() = NULL;
        MRadCtrl::IndexToCtrlMap().clear();

        // move this dialog
        POINT pt = { 0, 0 };
        SetWindowPosDx(hwnd, &pt);

        // do subclassing the children of this dialog
        DoSubclassChildren(hwnd, TRUE);

        // if indeces are visible
        if (m_index_visible)
            ShowHideLabels(TRUE);   // show the labels

        // do subclassing this dialog
        SubclassDx(hwnd);

        return FALSE;
    }

    // show/hide the labels
    void ShowHideLabels(BOOL bShow = TRUE)
    {
        m_index_visible = bShow;
        if (bShow)
            m_labels.ReCreate(m_hwnd, MRadCtrl::IndexToCtrlMap());
        else
            m_labels.Destroy();
    }
};

//////////////////////////////////////////////////////////////////////////////
// MRadWindow --- the RADical window
// NOTE: An MRadWindow contains an MRadDialog.

class MRadWindow : public MWindowBase
{
public:
    INT             m_xDialogBaseUnit;      // the X dialog base unit
    INT             m_yDialogBaseUnit;      // the Y dialog base unit
    MRadDialog      m_rad_dialog;           // the MRadDialog instance
    DialogRes       m_dialog_res;           // the dialog resource
    HICON           m_hIcon;                // the icon
    HICON           m_hIconSm;              // the small icon
    MTitleToBitmap  m_title_to_bitmap;      // a title-to-bitmap mapping
    MTitleToIcon    m_title_to_icon;        // a title-to-icon mapping
    DialogItemClipboard m_clipboard;        // a clipboard manager
    MOleHost *m_pOleHost;

    // constructor
    MRadWindow() : m_xDialogBaseUnit(0), m_yDialogBaseUnit(0),
        m_hIcon(NULL), m_hIconSm(NULL), m_clipboard(m_dialog_res),
        m_pOleHost(NULL)
    {
    }

    // create the mappings
    void create_maps(WORD lang)
    {
        // for all the dialog items
        for (size_t i = 0; i < m_dialog_res.size(); ++i)
        {
            auto& item = m_dialog_res[i];
            // is it a STATIC control?
            if (item.m_class == 0x0082 ||
                lstrcmpiW(item.m_class.c_str(), L"STATIC") == 0)
            {
                if ((item.m_style & SS_TYPEMASK) == SS_ICON)
                {
                    // icon
                    g_res.do_icon(m_title_to_icon, item, lang);
                }
                else if ((item.m_style & SS_TYPEMASK) == SS_BITMAP)
                {
                    // bitmap
                    g_res.do_bitmap(m_title_to_bitmap, item, lang);
                }
            }
        }
    }

    // clear the mappings
    void clear_maps()
    {
        for (auto& pair : m_title_to_bitmap)
        {
            DeleteObject(pair.second);
        }
        m_title_to_bitmap.clear();

        for (auto& pair : m_title_to_icon)
        {
            DestroyIcon(pair.second);
        }
        m_title_to_icon.clear();
    }

    // destructor
    ~MRadWindow()
    {
        // delete the icons
        if (m_hIcon)
        {
            DestroyIcon(m_hIcon);
            m_hIcon = NULL;
        }
        if (m_hIconSm)
        {
            DestroyIcon(m_hIconSm);
            m_hIconSm = NULL;
        }

        // clear the mappings
        clear_maps();
    }

    VOID DestroyWindow()
    {
        ::DestroyWindow(m_hwnd);
    }

    // create an MRadWindow window
    BOOL CreateDx(HWND hwndParent)
    {
        // lock the moving/resizing
        BOOL bMovingSizing = m_rad_dialog.m_bMovingSizing;
        m_rad_dialog.m_bMovingSizing = TRUE;

        // create the window
        DWORD style = WS_OVERLAPPED | WS_CAPTION | WS_SYSMENU | WS_THICKFRAME;
        if (CreateWindowDx(hwndParent, MAKEINTRESOURCE(IDS_RADWINDOW), style))
        {
            // show it
            ShowWindow(m_hwnd, SW_SHOWNORMAL);
            UpdateWindow(m_hwnd);

            // resume the moving/resizing flag
            m_rad_dialog.m_bMovingSizing = bMovingSizing;

            return TRUE;    // success
        }

        // resume the moving/resizing flag
        m_rad_dialog.m_bMovingSizing = bMovingSizing;

        return FALSE;   // failure
    }

    // convert the coordinates
    void ClientToDialog(POINT *ppt)
    {
        GetBaseUnits(m_xDialogBaseUnit, m_yDialogBaseUnit);
        ppt->x = MulDiv(ppt->x, 4, m_xDialogBaseUnit);
        ppt->y = MulDiv(ppt->y, 8, m_yDialogBaseUnit);
    }

    // convert the coordinates
    void ClientToDialog(SIZE *psiz)
    {
        GetBaseUnits(m_xDialogBaseUnit, m_yDialogBaseUnit);
        psiz->cx = MulDiv(psiz->cx, 4, m_xDialogBaseUnit);
        psiz->cy = MulDiv(psiz->cy, 8, m_yDialogBaseUnit);
    }

    // convert the coordinates
    void ClientToDialog(RECT *prc)
    {
        GetBaseUnits(m_xDialogBaseUnit, m_yDialogBaseUnit);
        prc->left = MulDiv(prc->left, 4, m_xDialogBaseUnit);
        prc->right = MulDiv(prc->right, 4, m_xDialogBaseUnit);
        prc->top = MulDiv(prc->top, 8, m_yDialogBaseUnit);
        prc->bottom = MulDiv(prc->bottom, 8, m_yDialogBaseUnit);
    }

    // convert the coordinates
    void DialogToClient(POINT *ppt)
    {
        GetBaseUnits(m_xDialogBaseUnit, m_yDialogBaseUnit);
        ppt->x = (ppt->x * m_xDialogBaseUnit + 2) / 4;
        ppt->y = (ppt->y * m_yDialogBaseUnit + 4) / 8;
    }

    // convert the coordinates
    void DialogToClient(SIZE *psiz)
    {
        GetBaseUnits(m_xDialogBaseUnit, m_yDialogBaseUnit);
        psiz->cx = (psiz->cx * m_xDialogBaseUnit + 2) / 4;
        psiz->cy = (psiz->cy * m_yDialogBaseUnit + 4) / 8;
    }

    // convert the coordinates
    void DialogToClient(RECT *prc)
    {
        GetBaseUnits(m_xDialogBaseUnit, m_yDialogBaseUnit);
        prc->left = (prc->left * m_xDialogBaseUnit + 2) / 4;
        prc->right = (prc->right * m_xDialogBaseUnit + 2) / 4;
        prc->top = (prc->top * m_yDialogBaseUnit + 4) / 8;
        prc->bottom = (prc->bottom * m_yDialogBaseUnit + 4) / 8;
    }

    static HWND GetPrimaryControl(HWND hwnd, HWND hwndDialog)
    {
        for (;;)
        {
            if (GetParent(hwnd) == NULL || GetParent(hwnd) == hwndDialog)
                return hwnd;

            hwnd = GetParent(hwnd);
        }
    }

    // adjust MRadWindow's position and size to MRadDialog's client area
    void FitToRadDialog()
    {
        // get the window rectangle
        RECT rc;
        GetWindowRect(m_rad_dialog, &rc);
        SIZE siz = SizeFromRectDx(&rc);

        // adjust the rectangle
        SetRect(&rc, 0, 0, siz.cx, siz.cy);
        DWORD style = GetWindowLong(m_hwnd, GWL_STYLE);
        DWORD exstyle = GetWindowLong(m_hwnd, GWL_EXSTYLE);
        AdjustWindowRectEx(&rc, style, FALSE, exstyle);

        // resize the MRadWindow
        siz = SizeFromRectDx(&rc);
        SetWindowPosDx(NULL, &siz);
    }

    // the window class name
    virtual LPCTSTR GetWndClassNameDx() const
    {
        return TEXT("katahiromz's MRadWindow Class");
    }

    virtual void ModifyWndClassDx(WNDCLASSEX& wcx)
    {
        // no class icon
        wcx.hIcon = NULL;
        wcx.hIconSm = NULL;

        // dark gray background
        wcx.hbrBackground = GetStockBrush(DKGRAY_BRUSH);
    }

    LRESULT DoSendMessage(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
    {
        return ::SendMessage(hwnd, uMsg, wParam, lParam);
    }

    // recreate the MRadDialog window
    BOOL ReCreateRadDialog(HWND hwnd, INT nSelectStartIndex = -1)
    {
        assert(IsWindow(hwnd));

        // lock moving/resizing
        BOOL bMovingSizingOld = m_rad_dialog.m_bMovingSizing;
        m_rad_dialog.m_bMovingSizing = TRUE;

        // destroy MRadDialog window if any
        if (m_rad_dialog)
        {
            ::DestroyWindow(m_rad_dialog);
        }

        if (m_pOleHost)
        {
            delete m_pOleHost;
            m_pOleHost = NULL;
        }

        m_pOleHost = new MOleHost();
        DoSetActiveOleHost(m_pOleHost);

        // get the resource data
        m_dialog_res.FixupForRad(false);
        std::vector<BYTE> data = m_dialog_res.data();
#if 0
        MFile file(TEXT("modified.bin"), TRUE);
        DWORD cbWritten;
        file.WriteFile(&data[0], (DWORD)data.size(), &cbWritten);
#endif
        m_dialog_res.FixupForRad(true);

        // create the MRadDialog window from data
        if (!m_rad_dialog.CreateDialogIndirectDx(hwnd, &data[0]))
        {
            m_rad_dialog.m_bMovingSizing = bMovingSizingOld;
            return FALSE;
        }
        assert(IsWindow(m_rad_dialog));

        // adjust the MRadWindow's size to MRadDialog
        FitToRadDialog();

        // unlock
        m_rad_dialog.m_bMovingSizing = bMovingSizingOld;

        // show the dialog
        ShowWindow(m_rad_dialog, SW_SHOWNOACTIVATE);
        UpdateWindow(m_rad_dialog);

        // make it foreground
        SetForegroundWindow(hwnd);

        // update the mappings
        update_maps();

        // select the RADical control of the specified index
        if (nSelectStartIndex != -1)
        {
            HWND hwndNext = MRadDialog::GetFirstCtrl(hwnd);
            while (hwndNext)
            {
                if (auto pCtrl = MRadCtrl::GetRadCtrl(hwndNext))
                {
                    if (pCtrl->m_nIndex >= nSelectStartIndex)
                        MRadCtrl::Select(hwndNext);
                }
                hwndNext = m_rad_dialog.GetNextCtrl(hwndNext);
            }
        }

        // notify MYWM_SELCHANGE to the parent
        DoSendMessage(GetParent(hwnd), MYWM_SELCHANGE, 0, 0);

        return TRUE;
    }

    // update the mappings
    void update_maps()
    {
        GetBaseUnits(m_xDialogBaseUnit, m_yDialogBaseUnit);

        // for all the RADical controls
        for (HWND hCtrl = GetTopWindow(m_rad_dialog);
             hCtrl;
             hCtrl = GetNextWindow(hCtrl, GW_HWNDNEXT))
        {
            // is it a RADical control?
            if (auto pCtrl = MRadCtrl::GetRadCtrl(hCtrl))
            {
                // get the size
                SIZE siz = { 0, 0 };
                GetWindowPosDx(hCtrl, NULL, &siz);

                if (pCtrl->m_nImageType == 1)
                {
                    // icon
                    MIdOrString title = m_dialog_res[pCtrl->m_nIndex].m_title;
                    if (HICON hIcon = m_title_to_icon[title])
                    {
                        DoSendMessage(hCtrl, STM_SETIMAGE, IMAGE_ICON, (LPARAM)hIcon);
                        DWORD style = GetWindowStyle(hCtrl);
                        if (style & SS_REALSIZEIMAGE)
                        {
                            ICONINFO info;
                            GetIconInfo(hIcon, &info);
                            BITMAP bm;
                            GetObject(info.hbmColor, sizeof(BITMAP), &bm);
                            siz.cx = bm.bmWidth;
                            siz.cy = bm.bmHeight;
                        }
                        else if (style & SS_REALSIZECONTROL)
                        {
                            siz.cx = m_dialog_res[pCtrl->m_nIndex].m_siz.cx * m_xDialogBaseUnit / 4;
                            siz.cy = m_dialog_res[pCtrl->m_nIndex].m_siz.cy * m_yDialogBaseUnit / 8;
                        }
                        if (siz.cx <= 8)
                            siz.cx = 8;
                        if (siz.cy <= 8)
                            siz.cy = 8;

                        // resize
                        SetWindowPosDx(hCtrl, NULL, &siz);
                    }
                }
                if (pCtrl->m_nImageType == 2)
                {
                    // bitmap
                    MIdOrString title = m_dialog_res[pCtrl->m_nIndex].m_title;
                    if (HBITMAP hbm = m_title_to_bitmap[title])
                    {
                        DoSendMessage(hCtrl, STM_SETIMAGE, IMAGE_BITMAP, (LPARAM)hbm);
                        DWORD style = GetWindowStyle(hCtrl);
                        if (style & SS_REALSIZECONTROL)
                        {
                            siz.cx = m_dialog_res[pCtrl->m_nIndex].m_siz.cx * m_xDialogBaseUnit / 4;
                            siz.cy = m_dialog_res[pCtrl->m_nIndex].m_siz.cy * m_yDialogBaseUnit / 8;
                        }
                        else
                        {
                            BITMAP bm;
                            GetObject(hbm, sizeof(BITMAP), &bm);
                            siz.cx = bm.bmWidth;
                            siz.cy = bm.bmHeight;
                        }
                        if (siz.cx <= 8)
                            siz.cx = 8;
                        if (siz.cy <= 8)
                            siz.cy = 8;

                        // resize
                        SetWindowPosDx(hCtrl, NULL, &siz);
                    }
                }
            }
        }
    }

    // MRadWindow WM_CREATE
    BOOL OnCreate(HWND hwnd, LPCREATESTRUCT lpCreateStruct)
    {
        // create the icons
        m_hIcon = LoadIconDx(IDI_SMILY);
        m_hIconSm = LoadSmallIconDx(IDI_SMILY);

        // set the icons
        DoSendMessage(hwnd, WM_SETICON, ICON_BIG, (LPARAM)m_hIcon);
        DoSendMessage(hwnd, WM_SETICON, ICON_SMALL, (LPARAM)m_hIconSm);

        // resume the window position if necessary
        if (g_settings.bResumeWindowPos)
        {
            if (g_settings.nRadLeft != CW_USEDEFAULT)
            {
                POINT pt = { g_settings.nRadLeft, g_settings.nRadTop };
                SetWindowPosDx(&pt);
            }
            else
            {
                CenterWindowDx(hwnd);
            }
        }
        else
        {
            CenterWindowDx(hwnd);
        }

        // create the RADical dialog (MRadDialog)
        return ReCreateRadDialog(hwnd);
    }

    // MRadWindow WM_DESTROY
    void OnDestroy(HWND hwnd)
    {
        if (m_pOleHost)
        {
            delete m_pOleHost;
            m_pOleHost = NULL;
        }

        // send ID_DESTROYRAD to the owner
        HWND hwndOwner = GetWindow(hwnd, GW_OWNER);
        DoSendMessage(hwndOwner, WM_COMMAND, ID_DESTROYRAD, 0);

        // notify selection change to the owner
        MRadCtrl::GetTargetIndeces().clear();
        DoSendMessage(hwndOwner, MYWM_SELCHANGE, 0, 0);

        // destroy the icons
        if (m_hIcon)
        {
            DestroyIcon(m_hIcon);
            m_hIcon = NULL;
        }
        if (m_hIconSm)
        {
            DestroyIcon(m_hIconSm);
            m_hIconSm = NULL;
        }
    }

    // the window procedure of MRadWindow
    virtual LRESULT CALLBACK
    WindowProcDx(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
    {
        switch (uMsg)
        {
            DO_MSG(WM_CREATE, OnCreate);
            DO_MSG(WM_MOVE, OnMove);
            DO_MSG(WM_SIZE, OnSize);
            DO_MSG(WM_DESTROY, OnDestroy);
            DO_MSG(WM_CONTEXTMENU, OnContextMenu);
            DO_MSG(WM_KEYDOWN, OnKey);
            DO_MSG(WM_COMMAND, OnCommand);
            DO_MESSAGE(MYWM_CTRLMOVE, OnCtrlMove);
            DO_MESSAGE(MYWM_CTRLSIZE, OnCtrlSize);
            DO_MESSAGE(MYWM_DLGSIZE, OnDlgSize);
            DO_MESSAGE(MYWM_DELETESEL, OnDeleteSel);
            DO_MESSAGE(MYWM_SELCHANGE, OnSelChange);
            DO_MESSAGE(MYWM_GETUNITS, OnGetUnits);
            DO_MESSAGE(MYWM_RADDBLCLICK, OnRadDblClick);
            DO_MSG(WM_INITMENUPOPUP, OnInitMenuPopup);
            DO_MSG(WM_ACTIVATE, OnActivate);
            DO_MSG(WM_SYSCOLORCHANGE, OnSysColorChange);
        }
        return DefaultProcDx();
    }

    // MRadWindow WM_SYSCOLORCHANGE
    void OnSysColorChange(HWND hwnd)
    {
        m_rad_dialog.SendMessageDx(WM_SYSCOLORCHANGE);
    }

    // MRadWindow MYWM_RADDBLCLICK
    LRESULT OnRadDblClick(HWND hwnd, WPARAM wParam, LPARAM lParam)
    {
        HWND hwndOwner = GetWindow(hwnd, GW_OWNER);
        DoSendMessage(hwndOwner, MYWM_RADDBLCLICK, wParam, lParam);
        return 0;
    }

    // MRadWindow MYWM_GETUNITS
    LRESULT OnGetUnits(HWND hwnd, WPARAM wParam, LPARAM lParam)
    {
        // store the dialog base units
        GetBaseUnits(m_xDialogBaseUnit, m_yDialogBaseUnit);
        return 0;
    }

    // MRadWindow WM_ACTIVATE
    void OnActivate(HWND hwnd, UINT state, HWND hwndActDeact, BOOL fMinimized)
    {
        if (state == WA_ACTIVE || state == WA_CLICKACTIVE)
        {
            // check whether compilation requires or not
            HWND hwndOwner = GetWindow(hwnd, GW_OWNER);
            if (!DoSendMessage(hwndOwner, MYWM_COMPILECHECK, (WPARAM)hwnd, 0))
            {
                return;
            }
        }

        // default processing
        FORWARD_WM_ACTIVATE(hwnd, state, hwndActDeact, fMinimized, DefWindowProc);
    }

    // MRadWindow MYWM_SELCHANGE
    LRESULT OnSelChange(HWND hwnd, WPARAM wParam, LPARAM lParam)
    {
        // get the owner window
        HWND hwndOwner = GetWindow(hwnd, GW_OWNER);

        // is there the last selection?
        HWND hwndSel = MRadCtrl::GetLastSel();
        if (hwndSel == NULL)    // no
        {
            // report the selection change to the owner window
            DoSendMessage(hwndOwner, MYWM_SELCHANGE, 0, 0);
        
            // clear the status
            DoSendMessage(hwndOwner, MYWM_CLEARSTATUS, 0, 0);

            return 0;
        }

        // get the MRadCtrl pointer
        auto pCtrl = MRadCtrl::GetRadCtrl(hwndSel);
        if (pCtrl == NULL)
        {
            // report the selection change to the owner window
            DoSendMessage(hwndOwner, MYWM_SELCHANGE, 0, 0);

            // clear the status
            DoSendMessage(hwndOwner, MYWM_CLEARSTATUS, 0, 0);
            return 0;
        }

        // check the index
        if (size_t(pCtrl->m_nIndex) < m_dialog_res.m_items.size())
        {
            // report the position and size of the index
            DialogItem& item = m_dialog_res[pCtrl->m_nIndex];
            DoSendMessage(hwndOwner, MYWM_MOVESIZEREPORT, 
                MAKEWPARAM(item.m_pt.x, item.m_pt.y),
                MAKELPARAM(item.m_siz.cx, item.m_siz.cy));
        }

        // report the selection change to the owner window
        DoSendMessage(hwndOwner, MYWM_SELCHANGE, 0, 0);
        return 0;
    }

    // MRadWindow WM_INITMENUPOPUP
    void OnInitMenuPopup(HWND hwnd, HMENU hMenu, UINT item, BOOL fSystemMenu)
    {
        auto set = MRadCtrl::GetTargets();
        if (set.empty())
        {
            EnableMenuItem(hMenu, ID_DELCTRL, MF_GRAYED);
            EnableMenuItem(hMenu, ID_CTRLPROP, MF_GRAYED);
            EnableMenuItem(hMenu, ID_TOPALIGN, MF_GRAYED);
            EnableMenuItem(hMenu, ID_BOTTOMALIGN, MF_GRAYED);
            EnableMenuItem(hMenu, ID_LEFTALIGN, MF_GRAYED);
            EnableMenuItem(hMenu, ID_RIGHTALIGN, MF_GRAYED);
            EnableMenuItem(hMenu, ID_FITTOGRID, MF_GRAYED);
            EnableMenuItem(hMenu, ID_CUT, MF_GRAYED);
            EnableMenuItem(hMenu, ID_COPY, MF_GRAYED);
        }
        else if (set.size() == 1)
        {
            EnableMenuItem(hMenu, ID_DELCTRL, MF_ENABLED);
            EnableMenuItem(hMenu, ID_CTRLPROP, MF_ENABLED);
            EnableMenuItem(hMenu, ID_TOPALIGN, MF_GRAYED);
            EnableMenuItem(hMenu, ID_BOTTOMALIGN, MF_GRAYED);
            EnableMenuItem(hMenu, ID_LEFTALIGN, MF_GRAYED);
            EnableMenuItem(hMenu, ID_RIGHTALIGN, MF_GRAYED);
            EnableMenuItem(hMenu, ID_FITTOGRID, MF_ENABLED);
            EnableMenuItem(hMenu, ID_CUT, MF_ENABLED);
            EnableMenuItem(hMenu, ID_COPY, MF_ENABLED);
        }
        else
        {
            EnableMenuItem(hMenu, ID_DELCTRL, MF_ENABLED);
            EnableMenuItem(hMenu, ID_CTRLPROP, MF_ENABLED);
            EnableMenuItem(hMenu, ID_TOPALIGN, MF_ENABLED);
            EnableMenuItem(hMenu, ID_BOTTOMALIGN, MF_ENABLED);
            EnableMenuItem(hMenu, ID_LEFTALIGN, MF_ENABLED);
            EnableMenuItem(hMenu, ID_RIGHTALIGN, MF_ENABLED);
            EnableMenuItem(hMenu, ID_FITTOGRID, MF_ENABLED);
            EnableMenuItem(hMenu, ID_CUT, MF_ENABLED);
            EnableMenuItem(hMenu, ID_COPY, MF_ENABLED);
        }

        if (CanIndexTop())
        {
            EnableMenuItem(hMenu, ID_CTRLINDEXTOP, MF_ENABLED);
        }
        else
        {
            EnableMenuItem(hMenu, ID_CTRLINDEXTOP, MF_GRAYED);
        }

        if (CanIndexBottom())
        {
            EnableMenuItem(hMenu, ID_CTRLINDEXBOTTOM, MF_ENABLED);
        }
        else
        {
            EnableMenuItem(hMenu, ID_CTRLINDEXBOTTOM, MF_GRAYED);
        }

        if (CanIndexMinus())
        {
            EnableMenuItem(hMenu, ID_CTRLINDEXMINUS, MF_ENABLED);
        }
        else
        {
            EnableMenuItem(hMenu, ID_CTRLINDEXMINUS, MF_GRAYED);
        }

        if (CanIndexPlus())
        {
            EnableMenuItem(hMenu, ID_CTRLINDEXPLUS, MF_ENABLED);
        }
        else
        {
            EnableMenuItem(hMenu, ID_CTRLINDEXPLUS, MF_GRAYED);
        }

        if (m_clipboard.IsAvailable())
        {
            EnableMenuItem(hMenu, ID_PASTE, MF_ENABLED);
        }
        else
        {
            EnableMenuItem(hMenu, ID_PASTE, MF_GRAYED);
        }
    }

    // MRadWindow MYWM_DELETESEL
    LRESULT OnDeleteSel(HWND hwnd, WPARAM wParam, LPARAM lParam)
    {
        // delete the selected dialog items from m_dialog_res
        auto indeces = MRadCtrl::GetTargetIndeces();
        for (size_t i = m_dialog_res.size(); i > 0;)
        {
            --i;
            if (indeces.find(INT(i)) != indeces.end())
            {
                m_dialog_res.m_items.erase(m_dialog_res.m_items.begin() + i);
                --m_dialog_res.m_cItems;
            }
        }

        // recreate the MRadDialog
        ReCreateRadDialog(hwnd);

        // update the resource
        UpdateRes();

        return 0;
    }

    // MRadWindow MYWM_CTRLMOVE
    LRESULT OnCtrlMove(HWND hwnd, WPARAM wParam, LPARAM lParam)
    {
        HWND hwndCtrl = (HWND)wParam;

        auto pCtrl = MRadCtrl::GetRadCtrl(hwndCtrl);
        if (pCtrl == NULL)
            return 0;   // invalid

        // check the index
        if (pCtrl->m_nIndex < 0 || m_dialog_res.m_cItems <= pCtrl->m_nIndex)
            return 0;   // invalid

        DebugPrintDx("OnCtrlMove: %d\n", pCtrl->m_nIndex);

        // get the rectangle of the control in dialog coordinates
        RECT rc;
        GetWindowRect(*pCtrl, &rc);
        MapWindowRect(NULL, m_rad_dialog, &rc);
        ClientToDialog(&rc);

        // update DialogItem position
        DialogItem& item = m_dialog_res[pCtrl->m_nIndex];
        item.m_pt.x = rc.left;
        item.m_pt.y = rc.top;

        // update resource
        UpdateRes();

        // notify the position/size change to the owner
        HWND hwndOwner = GetWindow(hwnd, GW_OWNER);
        DoSendMessage(hwndOwner, MYWM_MOVESIZEREPORT,
            MAKEWPARAM(item.m_pt.x, item.m_pt.y),
            MAKELPARAM(item.m_siz.cx, item.m_siz.cy));

        // redraw
        PostMessage(m_rad_dialog, MYWM_REDRAW, 0, 0);

        return 0;
    }

    // MRadWindow MYWM_CTRLSIZE
    LRESULT OnCtrlSize(HWND hwnd, WPARAM wParam, LPARAM lParam)
    {
        HWND hwndCtrl = (HWND)wParam;
        auto pCtrl = MRadCtrl::GetRadCtrl(hwndCtrl);
        if (pCtrl == NULL)
            return 0;   // invalid

        // check the index
        if (pCtrl->m_nIndex < 0 || m_dialog_res.m_cItems <= pCtrl->m_nIndex)
            return 0;   // invalid

        DebugPrintDx("OnCtrlSize: %d\n", pCtrl->m_nIndex);

        // get the rectangle of the control in dialog coordinates
        RECT rc;
        GetWindowRect(*pCtrl, &rc);
        MapWindowRect(NULL, m_rad_dialog, &rc);
        ClientToDialog(&rc);

        // update DialogItem size
        DialogItem& item = m_dialog_res[pCtrl->m_nIndex];
        item.m_siz.cx = rc.right - rc.left;
        item.m_siz.cy = rc.bottom - rc.top;

        // if it was combobox, then apply the settings
        TCHAR szClass[64];
        GetClassName(hwndCtrl, szClass, _countof(szClass));
        if (lstrcmpi(szClass, TEXT("COMBOBOX")) == 0 ||
            lstrcmpi(szClass, WC_COMBOBOXEX) == 0)
        {
            item.m_siz.cy = g_settings.nComboHeight;
        }

        // update the resource
        UpdateRes();

        // notify the position/size change to the owner
        HWND hwndOwner = GetWindow(hwnd, GW_OWNER);
        DoSendMessage(hwndOwner, MYWM_MOVESIZEREPORT,
            MAKEWPARAM(item.m_pt.x, item.m_pt.y),
            MAKELPARAM(item.m_siz.cx, item.m_siz.cy));

        // redraw
        PostMessage(m_rad_dialog, MYWM_REDRAW, 0, 0);

        return 0;
    }

    // update the resource
    void UpdateRes()
    {
        // notify the update of dialog resource to the owner window
        HWND hwndOwner = ::GetWindow(m_hwnd, GW_OWNER);
        DoSendMessage(hwndOwner, MYWM_UPDATEDLGRES, 0, 0);

        // redraw the labels
        m_rad_dialog.ShowHideLabels(m_rad_dialog.m_index_visible);
    }

    // MRadWindow MYWM_DLGSIZE
    LRESULT OnDlgSize(HWND hwnd, WPARAM wParam, LPARAM lParam)
    {
        // get the rectangle of the dialog in dialog coordinates
        RECT rc;
        GetWindowRect(m_rad_dialog, &rc);
        ClientToDialog(&rc);

        // update m_dialog_res
        m_dialog_res.m_siz.cx = rc.right - rc.left;
        m_dialog_res.m_siz.cy = rc.bottom - rc.top;
        UpdateRes();

        // notify the position/size change to the owner
        HWND hwndOwner = GetWindow(hwnd, GW_OWNER);
        DoSendMessage(hwndOwner, MYWM_MOVESIZEREPORT,
            MAKEWPARAM(rc.left, rc.top),
            MAKELPARAM(rc.right - rc.left, rc.bottom - rc.top));

        return 0;
    }

    // called from MMainWnd WM_COMMAND ID_ADDCTRL
    void OnAddCtrl(HWND hwnd)
    {
        // get the client area
        RECT rc;
        GetClientRect(hwnd, &rc);

        // use the clicked position
        POINT pt = m_rad_dialog.m_ptClicked;

        // adjust the position
        if (pt.x < 0 || pt.y < 0)
            pt.x = pt.y = 0;
        if (rc.right - 30 < pt.x)
            pt.x = rc.right - 30;
        if (rc.bottom - 30 < pt.y)
            pt.y = rc.bottom - 30;

        ClientToDialog(&pt);

        // show the dialog
        MAddCtrlDlg dialog(m_dialog_res, pt);
        if (dialog.DialogBoxDx(hwnd) == IDOK)
        {
            // add an RT_DLGINIT entry if necesssary
            MByteStreamEx::data_type data;
            if (m_dialog_res.SaveDlgInitData(data))
            {
                if (!data.empty())
                {
                    g_res.add_lang_entry(RT_DLGINIT, m_dialog_res.m_name, m_dialog_res.m_lang, data);
                }
            }

            // refresh
            OnRefresh(hwnd);
        }
    }

    // called from MMainWnd WM_COMMAND ID_CTRLPROP
    void OnCtrlProp(HWND hwnd)
    {
        // show the dialog
        MCtrlPropDlg dialog(m_dialog_res, MRadCtrl::GetTargetIndeces());
        if (dialog.DialogBoxDx(hwnd) == IDOK)
        {
            auto type = RT_DLGINIT;
            auto name = m_dialog_res.m_name;
            auto lang = m_dialog_res.m_lang;

            // add or delete an RT_DLGINIT entry if necesssary
            MByteStreamEx::data_type data;
            if (m_dialog_res.SaveDlgInitData(data))
            {
                if (data.empty())
                {
                    g_res.search_and_delete(ET_LANG, type, name, lang);
                }
                else
                {
                    g_res.add_lang_entry(type, name, lang, data);
                }
            }
            else
            {
                g_res.search_and_delete(ET_LANG, type, name, lang);
            }

            // refresh
            OnRefresh(hwnd);
        }
    }

    // called from MMainWnd WM_COMMAND ID_DLGPROP
    void OnDlgProp(HWND hwnd)
    {
        // show the dialog
        MDlgPropDlg dialog(m_dialog_res);
        if (dialog.DialogBoxDx(hwnd) == IDOK)
        {
            // refresh
            OnRefresh(hwnd);
        }
    }

    // refresh
    void OnRefresh(HWND hwnd)
    {
        // recreate MRadDialog
        ReCreateRadDialog(hwnd);

        // update the resource
        UpdateRes();
    }

    // show/hide the indeces
    void OnShowHideIndex(HWND hwnd)
    {
        m_rad_dialog.m_index_visible = !m_rad_dialog.m_index_visible;
        m_rad_dialog.ShowHideLabels(m_rad_dialog.m_index_visible);
    }

    // get the selected dialog items
    BOOL GetSelectedItems(DialogItems& items)
    {
        auto indeces = MRadCtrl::GetTargetIndeces();
        auto end = indeces.end();
        for (auto it = indeces.begin(); it != end; ++it)
        {
            DialogItem& item = m_dialog_res[*it];
            items.push_back(item);
        }
        return !items.empty();
    }

    // MRadWindow WM_COMMAND
    void OnCommand(HWND hwnd, int id, HWND hwndCtl, UINT codeNotify)
    {
        DialogItems items;
        static INT s_nShift = 0;

        switch (id)
        {
        case ID_CUT:
            if (GetSelectedItems(items))
            {
                m_clipboard.Copy(hwnd, items);
                MRadCtrl::DeleteSelection();
                s_nShift = 0;
            }
            return;

        case ID_COPY:
            if (GetSelectedItems(items))
            {
                m_clipboard.Copy(hwnd, items);
                s_nShift = 0;
            }
            return;

        case ID_PASTE:
            if (m_clipboard.Paste(hwnd, items))
            {
                s_nShift += 5;
                for (size_t i = 0; i < items.size(); ++i)
                {
                    items[i].m_pt.x += s_nShift;
                    items[i].m_pt.y += s_nShift;
                }

                for (size_t i = 0; i < items.size(); ++i)
                {
                    m_dialog_res.m_cItems++;
                    m_dialog_res.m_items.push_back(items[i]);
                }

                OnRefresh(hwnd);
            }
            return;
        }

        // notify WM_COMMAND to the owner window
        HWND hwndOwner = ::GetWindow(m_hwnd, GW_OWNER);
        FORWARD_WM_COMMAND(hwndOwner, id, hwndCtl, codeNotify, DoSendMessage);
    }

    // called from MMainWnd WM_COMMAND ID_TOPALIGN
    void OnTopAlign(HWND hwnd)
    {
        auto set = MRadCtrl::GetTargets();
        if (set.size() < 2)
            return;     

        RECT rc;

        // the highest Y coordinate --> nUp
        INT nUp = INT_MAX;
        auto end = set.end();
        for (auto it = set.begin(); it != end; ++it)
        {
            GetWindowRect(*it, &rc);
            MapWindowRect(NULL, m_rad_dialog, &rc);
            if (rc.top < nUp)
                nUp = rc.top;
        }

        // move the selected controls to the highest Y coordinate
        for (auto it = set.begin(); it != end; ++it)
        {
            // get the coordinates of the control
            auto pCtrl = MRadCtrl::GetRadCtrl(*it);
            GetWindowRect(*it, &rc);
            MapWindowRect(NULL, m_rad_dialog, &rc);

            // move it
            pCtrl->m_bMoving = TRUE;
            SetWindowPos(*it, NULL, rc.left, nUp, 0, 0,
                SWP_NOSIZE | SWP_NOACTIVATE | SWP_NOZORDER);
            pCtrl->m_bMoving = FALSE;
        }
    }

    // called from MMainWnd WM_COMMAND ID_BOTTOMALIGN
    void OnBottomAlign(HWND hwnd)
    {
        auto set = MRadCtrl::GetTargets();
        if (set.size() < 2)
            return;

        RECT rc;

        // the lowest Y coordinate --> nDown
        INT nDown = INT_MIN;
        auto end = set.end();
        for (auto it = set.begin(); it != end; ++it)
        {
            GetWindowRect(*it, &rc);
            MapWindowRect(NULL, m_rad_dialog, &rc);
            if (nDown < rc.bottom)
                nDown = rc.bottom;
        }

        // move the selected controls to the lowest Y coordinate
        for (auto it = set.begin(); it != end; ++it)
        {
            // get the coordinates of the control
            MRadCtrl *pCtrl = MRadCtrl::GetRadCtrl(*it);
            GetWindowRect(*it, &rc);
            MapWindowRect(NULL, m_rad_dialog, &rc);

            // the height
            INT cy = rc.bottom - rc.top;

            // move it
            pCtrl->m_bMoving = TRUE;
            SetWindowPos(*it, NULL, rc.left, nDown - cy, 0, 0,
                         SWP_NOSIZE | SWP_NOACTIVATE | SWP_NOZORDER);
            pCtrl->m_bMoving = FALSE;
        }
    }

    // called from MMainWnd WM_COMMAND ID_LEFTALIGN
    void OnLeftAlign(HWND hwnd)
    {
        auto set = MRadCtrl::GetTargets();
        if (set.size() < 2)
            return;

        RECT rc;

        // the leftest X coordinate --> nLeft
        INT nLeft = INT_MAX;
        auto end = set.end();
        for (auto it = set.begin(); it != end; ++it)
        {
            GetWindowRect(*it, &rc);
            MapWindowRect(NULL, m_rad_dialog, &rc);
            if (rc.left < nLeft)
                nLeft = rc.left;
        }

        // move the selected controls to the leftest coordinate
        for (auto it = set.begin(); it != end; ++it)
        {
            // get the coordinates of the control
            MRadCtrl *pCtrl = MRadCtrl::GetRadCtrl(*it);
            GetWindowRect(*it, &rc);
            MapWindowRect(NULL, m_rad_dialog, &rc);

            // move it
            pCtrl->m_bMoving = TRUE;
            SetWindowPos(*it, NULL, nLeft, rc.top, 0, 0,
                SWP_NOSIZE | SWP_NOACTIVATE | SWP_NOZORDER);
            pCtrl->m_bMoving = FALSE;
        }
    }

    // called from MMainWnd WM_COMMAND ID_RIGHTALIGN
    void OnRightAlign(HWND hwnd)
    {
        MRadCtrl::set_type set = MRadCtrl::GetTargets();
        if (set.size() < 2)
            return;

        RECT rc;

        // the rightest X coordinate --> nRight
        INT nRight = INT_MIN;
        auto end = set.end();
        for (auto it = set.begin(); it != end; ++it)
        {
            GetWindowRect(*it, &rc);
            MapWindowRect(NULL, m_rad_dialog, &rc);
            if (nRight < rc.right)
                nRight = rc.right;
        }

        for (auto it = set.begin(); it != end; ++it)
        {
            // get the coordinates of the control
            MRadCtrl *pCtrl = MRadCtrl::GetRadCtrl(*it);
            GetWindowRect(*it, &rc);
            MapWindowRect(NULL, m_rad_dialog, &rc);

            // the width
            INT cx = rc.right - rc.left;

            // move it
            pCtrl->m_bMoving = TRUE;
            SetWindowPos(*it, NULL, nRight - cx, rc.top, 0, 0,
                SWP_NOSIZE | SWP_NOACTIVATE | SWP_NOZORDER);
            pCtrl->m_bMoving = FALSE;
        }
    }

    // able to make it top index?
    BOOL CanIndexTop() const
    {
        auto indeces = MRadCtrl::GetTargetIndeces();
        if (indeces.empty())
            return FALSE;   // no

        INT iUnselected = -1;
        for (UINT i = 0; i < m_dialog_res.m_cItems; ++i)
        {
            if (indeces.find(i) != indeces.end())
            {
                if (iUnselected != -1)
                    return TRUE;    // yes
            }
            else
            {
                iUnselected = i;
            }
        }

        return FALSE;   // no
    }

    // make it top index
    void IndexTop(HWND hwnd)
    {
        auto indeces = MRadCtrl::GetTargetIndeces();
        if (indeces.empty())
            return;

        // move the dialog items
        DialogItems items1, items2;
        for (UINT i = 0; i < m_dialog_res.m_cItems; ++i)
        {
            if (indeces.find(i) == indeces.end())
            {
                items1.push_back(m_dialog_res[i]);
            }
            else
            {
                items2.push_back(m_dialog_res[i]);
            }
        }
        m_dialog_res.m_items = std::move(items1);
        m_dialog_res.m_items.insert(m_dialog_res.m_items.begin(), items2.begin(), items2.end());

        // refresh
        OnRefresh(hwnd);
    }

    // able to make it bottom index?
    BOOL CanIndexBottom() const
    {
        auto indeces = MRadCtrl::GetTargetIndeces();
        if (indeces.empty())
            return FALSE;

        // find two items to swap
        INT iUnselected = -1;
        for (INT i = m_dialog_res.m_cItems - 1; i >= 0; --i)
        {
            if (indeces.find(i) != indeces.end())
            {
                if (iUnselected != -1)
                    return TRUE;
            }
            else
            {
                iUnselected = i;
            }
        }

        return FALSE;
    }

    // make it bottom index
    void IndexBottom(HWND hwnd)
    {
        auto indeces = MRadCtrl::GetTargetIndeces();
        if (indeces.empty())
            return;

        // move the dialog items
        DialogItems items1, items2;
        for (UINT i = 0; i < m_dialog_res.m_cItems; ++i)
        {
            if (indeces.find(i) == indeces.end())
            {
                items1.push_back(m_dialog_res[i]);
            }
            else
            {
                items2.push_back(m_dialog_res[i]);
            }
        }

        // swap
        m_dialog_res.m_items = std::move(items1);
        m_dialog_res.m_items.insert(m_dialog_res.m_items.end(), items2.begin(), items2.end());

        // refresh
        OnRefresh(hwnd);
    }

    // able to decrement the control index?
    BOOL CanIndexMinus() const
    {
        auto indeces = MRadCtrl::GetTargetIndeces();
        if (indeces.empty() || indeces.count(0) > 0)
            return FALSE;

        return TRUE;
    }

    // decrement the control index
    void IndexMinus(HWND hwnd)
    {
        auto indeces = MRadCtrl::GetTargetIndeces();
        if (indeces.empty())
            return;

        // move the dialog items
        for (INT i = 0; i < m_dialog_res.m_cItems - 1; ++i)
        {
            if (indeces.find(i + 1) != indeces.end())
            {
                std::swap(m_dialog_res[i], m_dialog_res[i + 1]);
            }
        }

        // refresh
        OnRefresh(hwnd);
    }

    // able to increment the control index?
    BOOL CanIndexPlus() const
    {
        auto indeces = MRadCtrl::GetTargetIndeces();
        if (indeces.empty() || indeces.count(m_dialog_res.m_cItems - 1) > 0)
            return FALSE;

        return TRUE;
    }

    // increment the control index
    void IndexPlus(HWND hwnd)
    {
        auto indeces = MRadCtrl::GetTargetIndeces();
        if (indeces.empty())
            return;

        // move the dialog items
        for (UINT i = m_dialog_res.m_cItems - 1; i > 0; --i)
        {
            if (indeces.find(i - 1) != indeces.end())
            {
                std::swap(m_dialog_res[i], m_dialog_res[i - 1]);
            }
        }

        // refresh
        OnRefresh(hwnd);
    }

    // MRadWindow WM_KEYDOWN/WM_KEYUP
    void OnKey(HWND hwnd, UINT vk, BOOL fDown, int cRepeat, UINT flags)
    {
        RECT rc;
        if (!fDown)
            return;     // ignore WM_KEYUP

        // get the target
        HWND hwndTarget = MRadCtrl::GetLastSel();
        if (hwndTarget == NULL && !MRadCtrl::GetTargets().empty())
        {
            hwndTarget = *MRadCtrl::GetTargets().begin();
        }

        // get the target control
        auto pCtrl = MRadCtrl::GetRadCtrl(hwndTarget);

        // for each case of virtual key
        switch (vk)
        {
        case VK_TAB:
            if (GetKeyState(VK_SHIFT) < 0)
            {
                // Shift+Tab
                HWND hwndNext = NULL;
                if (!hwndTarget)
                {
                    hwndNext = MRadDialog::GetLastCtrl(hwnd);
                }
                else
                {
                    hwndNext = m_rad_dialog.GetPrevCtrl(hwndTarget);
                }
                if (!hwndNext)
                {
                    hwndNext = MRadDialog::GetLastCtrl(hwnd);
                }
                MRadCtrl::DeselectSelection();
                MRadCtrl::Select(hwndNext);
            }
            else
            {
                // Tab
                HWND hwndNext = NULL;
                if (!hwndTarget)
                {
                    hwndNext = MRadDialog::GetFirstCtrl(hwnd);
                }
                else
                {
                    hwndNext = m_rad_dialog.GetNextCtrl(hwndTarget);
                }
                if (!hwndNext)
                {
                    hwndNext = MRadDialog::GetFirstCtrl(hwnd);
                }
                MRadCtrl::DeselectSelection();
                MRadCtrl::Select(hwndNext);
            }
            break;

        case VK_UP:
            if (pCtrl == NULL)
            {
                return;
            }
            if (GetKeyState(VK_SHIFT) < 0)
            {
                // Shift+Up
                GetWindowRect(*pCtrl, &rc);
                MapWindowRect(NULL, m_rad_dialog, &rc);
                SIZE siz = SizeFromRectDx(&rc);
                siz.cy -= 1;
                MRadCtrl::ResizeSelection(NULL, siz.cx, siz.cy);
            }
            else
            {
                // Up
                MRadCtrl::MoveSelection(NULL, 0, -1);
            }
            break;

        case VK_DOWN:
            if (pCtrl == NULL)
            {
                return;
            }
            if (GetKeyState(VK_SHIFT) < 0)
            {
                // Shift+Down
                GetWindowRect(*pCtrl, &rc);
                MapWindowRect(NULL, m_rad_dialog, &rc);
                SIZE siz = SizeFromRectDx(&rc);
                siz.cy += 1;
                MRadCtrl::ResizeSelection(NULL, siz.cx, siz.cy);
            }
            else
            {
                // Down
                MRadCtrl::MoveSelection(NULL, 0, +1);
            }
            break;

        case VK_LEFT:
            if (pCtrl == NULL)
            {
                return;
            }
            if (GetKeyState(VK_SHIFT) < 0)
            {
                // Shift+Left
                GetWindowRect(*pCtrl, &rc);
                MapWindowRect(NULL, m_rad_dialog, &rc);
                SIZE siz = SizeFromRectDx(&rc);
                siz.cx -= 1;
                MRadCtrl::ResizeSelection(NULL, siz.cx, siz.cy);
            }
            else
            {
                // Left
                MRadCtrl::MoveSelection(NULL, -1, 0);
            }
            break;

        case VK_RIGHT:
            if (pCtrl == NULL)
            {
                return;
            }
            if (GetKeyState(VK_SHIFT) < 0)
            {
                // Shift+Right
                GetWindowRect(*pCtrl, &rc);
                MapWindowRect(NULL, m_rad_dialog, &rc);
                SIZE siz = SizeFromRectDx(&rc);
                siz.cx += 1;
                MRadCtrl::ResizeSelection(NULL, siz.cx, siz.cy);
            }
            else
            {
                // Right
                MRadCtrl::MoveSelection(NULL, +1, 0);
            }
            break;

        case VK_DELETE: // Del
            MRadCtrl::DeleteSelection();
            break;

        case 'A':
            if (GetAsyncKeyState(VK_CONTROL) < 0)
            {
                // Ctrl+A
                SelectAll(hwnd);
            }
            break;

        case 'C':
            if (GetAsyncKeyState(VK_CONTROL) < 0)
            {
                // Ctrl+C
                SendMessageDx(WM_COMMAND, ID_COPY);
            }
            break;

        case 'D':
            if (GetAsyncKeyState(VK_CONTROL) < 0)
            {
                // Ctrl+D
                SendMessageDx(WM_COMMAND, ID_SHOWHIDEINDEX);
            }
            break;

        case 'V':
            if (GetAsyncKeyState(VK_CONTROL) < 0)
            {
                // Ctrl+V
                SendMessageDx(WM_COMMAND, ID_PASTE);
            }
            break;

        case 'X':
            if (GetAsyncKeyState(VK_CONTROL) < 0)
            {
                // Ctrl+X
                SendMessageDx(WM_COMMAND, ID_CUT);
            }
            break;

        case 'L':
            pCtrl->DoTest();
            break;

        default:
            return;
        }
    }

    // select all the RADical controls
    void SelectAll(HWND hwnd)
    {
        MRadCtrl::DeselectSelection();

        // select all
        for (HWND hwndNext = MRadDialog::GetFirstCtrl(hwnd);
             hwndNext;
             hwndNext = m_rad_dialog.GetNextCtrl(hwndNext))
        {
            MRadCtrl::Select(hwndNext);
        }
    }

    // MRadWindow WM_CONTEXTMENU
    void OnContextMenu(HWND hwnd, HWND hwndContext, UINT xPos, UINT yPos)
    {
        // show the popup menu
        PopupMenuDx(hwnd, hwndContext, IDR_POPUPMENUS, 1, xPos, yPos);
    }

    // get the dialog base units
    BOOL GetBaseUnits(INT& xDialogBaseUnit, INT& yDialogBaseUnit)
    {
        // use m_dialog_res.GetBaseUnits
        m_xDialogBaseUnit = m_dialog_res.GetBaseUnits(m_yDialogBaseUnit);
        if (m_xDialogBaseUnit == 0)
        {
            return FALSE;
        }

        // update
        xDialogBaseUnit = m_xDialogBaseUnit;
        yDialogBaseUnit = m_yDialogBaseUnit;
        m_rad_dialog.m_xDialogBaseUnit = m_xDialogBaseUnit;
        m_rad_dialog.m_yDialogBaseUnit = m_yDialogBaseUnit;

        return TRUE;
    }

    // MRadWindow WM_MOVE
    void OnMove(HWND hwnd, int x, int y)
    {
        RECT rc;
        GetWindowRect(hwnd, &rc);

        // remember the position
        g_settings.nRadLeft = rc.left;
        g_settings.nRadTop = rc.top;
    }

    // MRadWindow WM_SIZE
    void OnSize(HWND hwnd, UINT state, int cx, int cy)
    {
        if (m_rad_dialog.m_bMovingSizing)
            return;     // in locking

        // get the client rectangle of MRadWindow
        RECT rc;
        GetClientRect(m_hwnd, &rc);
        SIZE siz = SizeFromRectDx(&rc);

        // resize m_rad_dialog
        m_rad_dialog.m_bMovingSizing = TRUE;
        MoveWindow(m_rad_dialog, 0, 0, siz.cx, siz.cy, TRUE);
        m_rad_dialog.m_bMovingSizing = FALSE;

        // get the client rectangle of MRadDialog
        GetClientRect(m_rad_dialog, &rc);
        siz = SizeFromRectDx(&rc);

        // Change m_dialog_res.m_siz
        ClientToDialog(&siz);
        m_dialog_res.m_siz = siz;

        // update the resource
        UpdateRes();
    }

    // fit the coordinates to the grid
    void FitToGrid(POINT *ppt)
    {
        ppt->x = (ppt->x + GRID_SIZE / 2) / GRID_SIZE * GRID_SIZE;
        ppt->y = (ppt->y + GRID_SIZE / 2) / GRID_SIZE * GRID_SIZE;
    }
    void FitToGrid(SIZE *psiz)
    {
        psiz->cx = (psiz->cx + GRID_SIZE / 2) / GRID_SIZE * GRID_SIZE;
        psiz->cy = (psiz->cy + GRID_SIZE / 2) / GRID_SIZE * GRID_SIZE;
    }
    void FitToGrid(RECT *prc)
    {
        prc->left = (prc->left + GRID_SIZE / 2) / GRID_SIZE * GRID_SIZE;
        prc->top = (prc->top + GRID_SIZE / 2) / GRID_SIZE * GRID_SIZE;
        prc->right = (prc->right + GRID_SIZE / 2) / GRID_SIZE * GRID_SIZE;
        prc->bottom = (prc->bottom + GRID_SIZE / 2) / GRID_SIZE * GRID_SIZE;
    }

    void OnFitToGrid(HWND hwnd)
    {
        for (auto& target : MRadCtrl::GetTargets())
        {
            // ignore if target was m_rad_dialog
            if (target == m_rad_dialog)
                continue;

            // get the target control
            auto pCtrl = MRadCtrl::GetRadCtrl(target);
            if (pCtrl == NULL)
                continue;

            // check the index
            if (pCtrl->m_nIndex < 0 || m_dialog_res.m_cItems <= pCtrl->m_nIndex)
                continue;

            // get the dialog item
            DialogItem& item = m_dialog_res[pCtrl->m_nIndex];
            FitToGrid(&item.m_pt);
            FitToGrid(&item.m_siz);

            // get the position and size in client coordinates
            POINT pt = item.m_pt;
            SIZE siz = item.m_siz;
            DebugPrintDx("PTSIZ: %d, %d, %d, %d\n", pt.x, pt.y, siz.cx, siz.cy);
            DialogToClient(&pt);
            DialogToClient(&siz);

            // move and resize the control
            pCtrl->m_bLocking = TRUE;
            pCtrl->SetWindowPosDx(&pt, &siz);
            auto pBand = pCtrl->GetRubberBand();
            if (pBand)
            {
                pBand->FitToTarget();
            }
            pCtrl->m_bLocking = FALSE;

            // report moving/resizing to the owner window
            HWND hwndOwner = GetWindow(hwnd, GW_OWNER);
            DoSendMessage(hwndOwner, MYWM_MOVESIZEREPORT,
                MAKEWPARAM(item.m_pt.x, item.m_pt.y),
                MAKELPARAM(item.m_siz.cx, item.m_siz.cy));
        }

        // update the resource
        UpdateRes();
    }
};

```

`src/MRegKey.hpp`:

```hpp
// MRegKey.hpp -- Win32API registry key manipulator             -*- C++ -*-
// This file is part of MZC4.  See file "ReadMe.txt" and "License.txt".
////////////////////////////////////////////////////////////////////////////

#ifndef MZC4_MREGKEY_HPP_
#define MZC4_MREGKEY_HPP_       10   /* Version 10 */

#ifndef HKCR
    #define HKCR    HKEY_CLASSES_ROOT
    #define HKCU    HKEY_CURRENT_USER
    #define HKLM    HKEY_LOCAL_MACHINE
    #define HKU     HKEY_USERS
    #define HKPD    HKEY_PERFORMANCE_DATA
    #define HKCC    HKEY_CURRENT_CONFIG
    #define HKDD    HKEY_DYN_DATA
#endif

class MRegKey;

////////////////////////////////////////////////////////////////////////////

#ifndef _INC_WINDOWS
    #include <windows.h>    // Win32API
#endif
#include <cassert>          // assert
#include <new>              // std::nothrow

////////////////////////////////////////////////////////////////////////////

// NOTE: RegDeleteTreeDx deletes all value entries if pszSubKey == NULL.
// NOTE: RegDeleteTreeDx cannot delete opening keys.
LONG RegDeleteTreeDx(HKEY hKey, LPCTSTR pszSubKey/* = NULL*/);

////////////////////////////////////////////////////////////////////////////

class MRegKey
{
public:
    MRegKey();
    MRegKey(HKEY hKey);
    MRegKey(MRegKey& key);
    MRegKey(HKEY hBaseKey, LPCTSTR pszSubKey, BOOL bCreate = FALSE);
    virtual ~MRegKey();

    operator HKEY() const;
    bool operator!() const;
    bool operator==(HKEY hKey) const;
    bool operator!=(HKEY hKey) const;
    MRegKey& operator=(HKEY hKey);
    MRegKey& operator=(MRegKey& key);

    BOOL Attach(HKEY hKey);
    HKEY Detach();
    HKEY Handle() const;

    LONG RegCreateKeyEx(HKEY hBaseKey, LPCTSTR pszSubKey, DWORD dwReserved = 0,
                        LPTSTR lpClass = NULL, DWORD dwOptions = 0,
                        REGSAM samDesired = KEY_ALL_ACCESS,
                        LPSECURITY_ATTRIBUTES lpsa = NULL,
                        LPDWORD lpdwDisposition = NULL);
    LONG RegOpenKeyEx(HKEY hBaseKey, LPCTSTR pszSubKey, DWORD dwOptions = 0,
                      REGSAM samDesired = KEY_READ);

    LONG RegConnectRegistry(LPCTSTR lpMachineName, HKEY hBaseKey);

    LONG RegCloseKey();

    LONG RegQueryValueEx(LPCTSTR pszValueName = NULL,
                         LPDWORD lpReserved = NULL, LPDWORD lpType = NULL,
                         LPBYTE lpData = NULL, LPDWORD lpcbData = NULL);

    LONG QueryBinary(LPCTSTR pszValueName, LPVOID pvValue, DWORD cb);
    LONG QueryDword(LPCTSTR pszValueName, DWORD& dw);
    LONG QueryDwordLE(LPCTSTR pszValueName, DWORD& dw);
    LONG QueryDwordBE(LPCTSTR pszValueName, DWORD& dw);
    LONG QuerySz(LPCTSTR pszValueName, LPTSTR pszValue, DWORD cchValue);
    LONG QueryExpandSz(LPCTSTR pszValueName, LPTSTR pszValue, DWORD cchValue);
    LONG QueryMultiSz(LPCTSTR pszValueName, LPTSTR pszzValues, DWORD cchValues);
    template <typename T_CONTAINER>
    LONG QueryMultiSz(LPCTSTR pszValueName, T_CONTAINER& container);
    template <typename T_STRUCT>
    LONG QueryStruct(LPCTSTR pszValueName, T_STRUCT& data);

    template <typename T_STRING>
    LONG QuerySz(LPCTSTR pszValueName, T_STRING& strValue);
    template <typename T_STRING>
    LONG QueryExpandSz(LPCTSTR pszValueName, T_STRING& strValue);

    LONG RegSetValueEx(LPCTSTR pszValueName, DWORD dwReserved,
        DWORD dwType, CONST BYTE *lpData, DWORD cbData);

    LONG SetBinary(LPCTSTR pszValueName, LPCVOID pvValue, DWORD cb);
    LONG SetDword(LPCTSTR pszValueName, DWORD dw);
    LONG SetDwordLE(LPCTSTR pszValueName, DWORD dw);
    LONG SetDwordBE(LPCTSTR pszValueName, DWORD dw);
    LONG SetSz(LPCTSTR pszValueName, LPCTSTR pszValue, DWORD cchValue);
    LONG SetSz(LPCTSTR pszValueName, LPCTSTR pszValue);
    LONG SetExpandSz(LPCTSTR pszValueName, LPCTSTR pszValue, DWORD cchValue);
    LONG SetExpandSz(LPCTSTR pszValueName, LPCTSTR pszValue);
    LONG SetMultiSz(LPCTSTR pszValueName, LPCTSTR pszzValues);
    LONG SetMultiSz(LPCTSTR pszValueName, LPCTSTR pszzValues, DWORD cchValues);
    template <typename T_CONTAINER>
    LONG SetMultiSz(LPCTSTR pszValueName, const T_CONTAINER& container);
    template <typename T_STRUCT>
    LONG SetStruct(LPCTSTR pszValueName, const T_STRUCT& data);

    LONG RegDeleteValue(LPCTSTR pszValueName);
    LONG RegDeleteTreeDx(LPCTSTR pszSubKey);
    LONG RegEnumKeyEx(DWORD dwIndex, LPTSTR lpName, LPDWORD lpcchName,
                      LPDWORD lpReserved = NULL, LPTSTR lpClass = NULL,
                      LPDWORD lpcchClass = NULL,
                      PFILETIME lpftLastWriteTime = NULL);
    LONG RegEnumValue(DWORD dwIndex, LPTSTR lpName, LPDWORD lpcchName,
                      LPDWORD lpReserved = NULL, LPDWORD lpType = NULL,
                      LPBYTE lpData = NULL, LPDWORD lpcbData = NULL);

    LONG RegFlushKey();
    LONG RegGetKeySecurity(SECURITY_INFORMATION si,
                           PSECURITY_DESCRIPTOR pSD, LPDWORD pcbSD);

    LONG RegNotifyChangeKeyValue(BOOL bWatchSubTree = TRUE,
        DWORD dwFilter = REG_LEGAL_CHANGE_FILTER,
        HANDLE hEvent = NULL, BOOL bAsyncronous = FALSE);

    LONG RegQueryInfoKey(LPTSTR lpClass = NULL,
        LPDWORD lpcchClass = NULL,
        LPDWORD lpReserved = NULL,
        LPDWORD lpcSubKeys = NULL,
        LPDWORD lpcchMaxSubKeyLen = NULL,
        LPDWORD lpcchMaxClassLen = NULL,
        LPDWORD lpcValues = NULL,
        LPDWORD lpcchMaxValueNameLen = NULL,
        LPDWORD lpcbMaxValueLen = NULL,
        LPDWORD lpcbSecurityDescriptor = NULL,
        PFILETIME lpftLastWriteTime = NULL);

    LONG RegQueryMultipleValues(PVALENT val_list, DWORD num_vals,
                                LPTSTR lpValueBuf, LPDWORD lpdwTotsize);
    LONG RegSetKeySecurity(SECURITY_INFORMATION si, PSECURITY_DESCRIPTOR psd);
    
    static LONG RegLoadKey(HKEY hKey, LPCTSTR pszSubKey, LPCTSTR pszFile);
    static LONG RegUnLoadKey(HKEY hKey, LPCTSTR pszSubKey);
    static LONG RegSaveKey(HKEY hKey, LPCTSTR pszFile,
                           LPSECURITY_ATTRIBUTES lpsa = NULL);
    static LONG RegRestoreKey(HKEY hKey, LPCTSTR pszFile, DWORD dwFlags);
    static LONG RegReplaceKey(HKEY hKey, LPCTSTR pszSubKey,
                              LPCTSTR pszNewFile, LPCTSTR pszOldFile);
    static LONG RegDeleteTreeDx(HKEY hKey, LPCTSTR pszSubKey);
    static size_t MultiSzSizeDx(LPCTSTR pszz);

    static HKEY CloneHandleDx(HKEY hKey);

protected:
    HKEY m_hKey;
};

////////////////////////////////////////////////////////////////////////////

template <typename T_STRUCT>
inline LONG MRegKey::QueryStruct(LPCTSTR pszValueName, T_STRUCT& data)
{
    assert(m_hKey);
    DWORD cbData = static_cast<DWORD>(sizeof(data));
    LONG result = ::RegQueryValueEx(m_hKey, pszValueName, NULL, NULL,
        reinterpret_cast<LPBYTE>(&data), &cbData);
    if (result == ERROR_SUCCESS && cbData != sizeof(data))
        result = ERROR_INVALID_DATA;
    return result;
}

template <typename T_STRUCT>
inline LONG MRegKey::SetStruct(LPCTSTR pszValueName, const T_STRUCT& data)
{
    assert(m_hKey);
    const DWORD cbData = static_cast<DWORD>(sizeof(data));
    return ::RegSetValueEx(m_hKey, pszValueName, 0, REG_BINARY,
        reinterpret_cast<const BYTE *>(&data), cbData);
}

template <typename T_CONTAINER>
LONG MRegKey::QueryMultiSz(LPCTSTR pszValueName, T_CONTAINER& container)
{
    container.clear();

    LONG result;
    #ifndef NDEBUG
        DWORD dwType;
        result = RegQueryValueEx(pszValueName, NULL, &dwType, NULL, NULL);
        assert(result == ERROR_SUCCESS);
        assert(dwType == REG_MULTI_SZ);
    #endif

    DWORD cbData;
    result = RegQueryValueEx(pszValueName, NULL, NULL, NULL, &cbData);
    if (result != ERROR_SUCCESS)
        return result;

    const DWORD cch = static_cast<DWORD>(cbData / sizeof(TCHAR) + 1);
    LPTSTR pszz = new(std::nothrow) TCHAR[cch];
    if (pszz)
    {
        result = QueryMultiSz(pszValueName, pszz, cch);
        if (result == ERROR_SUCCESS)
        {
            for (LPTSTR pch = pszz; *pch; pch += lstrlen(pch) + 1)
            {
                #if (__cplusplus >= 201103L)
                    container.emplace_back(pch);
                #else
                    container.push_back(pch);
                #endif
            }
        }
        delete[] pszz;
    }
    else
        result = ERROR_OUTOFMEMORY;

    return result;
}

template <typename T_CONTAINER>
inline LONG MRegKey::SetMultiSz(
    LPCTSTR pszValueName, const T_CONTAINER& container)
{
    typename T_CONTAINER::value_type         str;
    typename T_CONTAINER::const_iterator     it, end;

    it = container.begin();
    end = container.end();
    if (it != end)
    {
        for (; it != end; ++it)
        {
            str += *it;
            str += TEXT('\0');
        }
    }
    else
    {
        str += TEXT('\0');
    }

    const DWORD cchValues = static_cast<DWORD>(str.size() + 1);
    return SetMultiSz(pszValueName, str.c_str(), cchValues);
}

template <typename T_STRING>
LONG MRegKey::QuerySz(LPCTSTR pszValueName, T_STRING& strValue)
{
    LONG result;
    strValue.clear();

    #ifndef NDEBUG
        DWORD dwType;
        result = RegQueryValueEx(pszValueName, NULL, &dwType, NULL, NULL);
        assert(result == ERROR_SUCCESS);
        assert(dwType == REG_SZ);
    #endif

    DWORD cbData;
    result = RegQueryValueEx(pszValueName, NULL, NULL, NULL, &cbData);
    if (result != ERROR_SUCCESS)
        return result;

    LPTSTR psz = new(std::nothrow) TCHAR[cbData / sizeof(TCHAR) + 1];
    assert(psz);
    if (psz)
    {
        result = RegQueryValueEx(pszValueName, NULL, NULL,
                                 reinterpret_cast<LPBYTE>(psz), &cbData);
        if (result == ERROR_SUCCESS)
        {
            strValue = psz;
        }
        delete[] psz;
    }
    return result;
}

template <typename T_STRING>
LONG MRegKey::QueryExpandSz(LPCTSTR pszValueName, T_STRING& strValue)
{
    LONG result;
    strValue.clear();

    #ifndef NDEBUG
        DWORD dwType;
        result = RegQueryValueEx(pszValueName, NULL, &dwType, NULL, NULL);
        assert(result == ERROR_SUCCESS);
        assert(dwType == REG_EXPAND_SZ);
    #endif

    DWORD cbData;
    result = RegQueryValueEx(pszValueName, NULL, NULL, NULL, &cbData);
    if (result != ERROR_SUCCESS)
        return result;

    LPTSTR psz = new(std::nothrow) TCHAR[cbData / sizeof(TCHAR) + 1];
    assert(psz);
    if (psz)
    {
        result = RegQueryValueEx(pszValueName, NULL, NULL,
                                 reinterpret_cast<LPBYTE>(psz), &cbData);
        if (result == ERROR_SUCCESS)
        {
            strValue = psz;
        }
        delete[] psz;
    }
    return result;
}

inline MRegKey::MRegKey() : m_hKey(NULL)
{
}

inline MRegKey::MRegKey(HKEY hKey) : m_hKey(hKey)
{
}

inline MRegKey::MRegKey(
    HKEY hBaseKey, LPCTSTR pszSubKey,
    BOOL bCreate/* = FALSE*/) : m_hKey(NULL)
{
    if (bCreate)
        RegCreateKeyEx(hBaseKey, pszSubKey);
    else
        RegOpenKeyEx(hBaseKey, pszSubKey);
}

inline MRegKey::MRegKey(MRegKey& key) : m_hKey(CloneHandleDx(key))
{
}

inline /*virtual*/ MRegKey::~MRegKey()
{
    RegCloseKey();
}

inline HKEY MRegKey::Handle() const
{
    return m_hKey;
}

inline MRegKey::operator HKEY() const
{
    return Handle();
}

inline bool MRegKey::operator!() const
{
    return Handle() == NULL;
}

inline bool MRegKey::operator==(HKEY hKey) const
{
    return Handle() == hKey;
}

inline bool MRegKey::operator!=(HKEY hKey) const
{
    return Handle() != hKey;
}

inline MRegKey& MRegKey::operator=(HKEY hKey)
{
    if (Handle() != hKey)
    {
        Attach(hKey);
    }
    return *this;
}

inline MRegKey& MRegKey::operator=(MRegKey& key)
{
    if (Handle() != key.m_hKey)
    {
        HKEY hKey = CloneHandleDx(key);
        Attach(hKey);
    }
    return *this;
}

inline BOOL MRegKey::Attach(HKEY hKey)
{
    RegCloseKey();
    m_hKey = hKey;
    return m_hKey != NULL;
}

inline HKEY MRegKey::Detach()
{
    HKEY hKey = m_hKey;
    m_hKey = NULL;
    return hKey;
}

inline LONG MRegKey::RegCreateKeyEx(HKEY hBaseKey, LPCTSTR pszSubKey,
    DWORD dwReserved/* = 0*/, LPTSTR lpClass/* = NULL*/,
    DWORD dwOptions/* = 0*/, REGSAM samDesired/* = KEY_ALL_ACCESS*/,
    LPSECURITY_ATTRIBUTES lpsa/* = NULL*/,
    LPDWORD lpdwDisposition/* = NULL*/)
{
    assert(m_hKey == NULL);
    return ::RegCreateKeyEx(hBaseKey, pszSubKey, 0,
        lpClass, dwOptions, samDesired, lpsa, &m_hKey, lpdwDisposition);
}

inline LONG MRegKey::RegOpenKeyEx(HKEY hBaseKey, LPCTSTR pszSubKey,
    DWORD dwOptions/* = 0*/, REGSAM samDesired/* = KEY_READ*/)
{
    assert(m_hKey == NULL);
    return ::RegOpenKeyEx(hBaseKey, pszSubKey, dwOptions, samDesired,
                          &m_hKey);
}

inline LONG
MRegKey::RegConnectRegistry(LPCTSTR lpMachineName, HKEY hBaseKey)
{
    assert(m_hKey == NULL);
    return ::RegConnectRegistry(lpMachineName, hBaseKey, &m_hKey);
}

inline LONG MRegKey::RegCloseKey()
{
    if (Handle())
    {
        LONG result = ::RegCloseKey(Detach());
        return result;
    }
    return ERROR_INVALID_HANDLE;
}

inline LONG MRegKey::RegQueryValueEx(LPCTSTR pszValueName/* = NULL*/,
    LPDWORD lpReserved/* = NULL*/, LPDWORD lpType/* = NULL*/,
    LPBYTE lpData/* = NULL*/, LPDWORD lpcbData/* = NULL*/)
{
    assert(m_hKey);
    return ::RegQueryValueEx(m_hKey, pszValueName, lpReserved,
        lpType, lpData, lpcbData);
}


inline LONG MRegKey::QueryBinary(
    LPCTSTR pszValueName, LPVOID pvValue, DWORD cb)
{
    #ifndef NDEBUG
        DWORD dwType;
        LONG result = RegQueryValueEx(pszValueName, NULL, &dwType,
                                      NULL, NULL);
        assert(result == ERROR_SUCCESS);
        assert(dwType == REG_BINARY);
    #endif
    DWORD cbData = cb;
    return RegQueryValueEx(pszValueName, NULL, NULL,
                           reinterpret_cast<LPBYTE>(pvValue),
                           &cbData);
}

inline LONG MRegKey::QueryDword(LPCTSTR pszValueName, DWORD& dw)
{
    #ifndef NDEBUG
        DWORD dwType;
        LONG result = RegQueryValueEx(pszValueName, NULL, &dwType,
                                      NULL, NULL);
        assert(result == ERROR_SUCCESS);
        assert(dwType == REG_DWORD);
    #endif
    DWORD cbData = sizeof(DWORD);
    return RegQueryValueEx(pszValueName, NULL, NULL,
                           reinterpret_cast<LPBYTE>(&dw), &cbData);
}

inline LONG MRegKey::QueryDwordLE(LPCTSTR pszValueName, DWORD& dw)
{
    #ifndef NDEBUG
        DWORD dwType;
        LONG result = RegQueryValueEx(pszValueName, NULL, &dwType,
                                      NULL, NULL);
        assert(result == ERROR_SUCCESS);
        assert(dwType == REG_DWORD_LITTLE_ENDIAN);
    #endif
    DWORD cbData = sizeof(DWORD);
    return RegQueryValueEx(pszValueName, NULL, NULL,
                           reinterpret_cast<LPBYTE>(&dw), &cbData);
}

inline LONG MRegKey::QueryDwordBE(LPCTSTR pszValueName, DWORD& dw)
{
    #ifndef NDEBUG
        DWORD dwType;
        LONG result = RegQueryValueEx(pszValueName, NULL, &dwType,
                                      NULL, NULL);
        assert(result == ERROR_SUCCESS);
        assert(dwType == REG_DWORD_BIG_ENDIAN);
    #endif
    DWORD cbData = sizeof(DWORD);
    return RegQueryValueEx(pszValueName, NULL, NULL,
                           reinterpret_cast<LPBYTE>(&dw), &cbData);
}

inline LONG
MRegKey::QuerySz(LPCTSTR pszValueName, LPTSTR pszValue, DWORD cchValue)
{
    #ifndef NDEBUG
        DWORD dwType;
        LONG result = RegQueryValueEx(pszValueName, NULL, &dwType,
                                      NULL, NULL);
        assert(result == ERROR_SUCCESS);
        assert(dwType == REG_SZ);
    #endif
    DWORD cbData = cchValue * sizeof(TCHAR);
    return RegQueryValueEx(pszValueName, NULL, NULL,
                           reinterpret_cast<LPBYTE>(pszValue), &cbData);
}

inline LONG MRegKey::QueryExpandSz(
    LPCTSTR pszValueName, LPTSTR pszValue, DWORD cchValue)
{
#ifndef NDEBUG
    DWORD dwType;
    LONG result = RegQueryValueEx(pszValueName, NULL, &dwType, NULL, NULL);
    assert(result == ERROR_SUCCESS);
    assert(dwType == REG_EXPAND_SZ);
#endif
    DWORD cbData = cchValue * sizeof(TCHAR);
    return RegQueryValueEx(pszValueName, NULL, NULL,
                           reinterpret_cast<LPBYTE>(pszValue), &cbData);
}

inline LONG MRegKey::QueryMultiSz(
    LPCTSTR pszValueName, LPTSTR pszzValues, DWORD cchValues)
{
#ifndef NDEBUG
    DWORD dwType;
    LONG result = RegQueryValueEx(pszValueName, NULL, &dwType, NULL, NULL);
    assert(result == ERROR_SUCCESS);
    assert(dwType == REG_MULTI_SZ);
#endif
    DWORD cbData = sizeof(TCHAR) * cchValues;
    return RegQueryValueEx(pszValueName, NULL, NULL,
                           reinterpret_cast<LPBYTE>(pszzValues), &cbData);
}

inline LONG MRegKey::RegSetValueEx(LPCTSTR pszValueName, DWORD dwReserved,
    DWORD dwType, CONST BYTE *lpData, DWORD cbData)
{
    assert(m_hKey);
    return ::RegSetValueEx(m_hKey, pszValueName, 0, dwType,
        lpData, cbData);
}

inline LONG MRegKey::SetBinary(LPCTSTR pszValueName, LPCVOID pvValue, DWORD cb)
{
    return RegSetValueEx(pszValueName, 0, REG_BINARY,
        reinterpret_cast<const BYTE *>(pvValue), cb);
}

inline LONG MRegKey::SetDword(LPCTSTR pszValueName, DWORD dw)
{
    DWORD dwValue = dw;
    return RegSetValueEx(pszValueName, 0, REG_DWORD,
        reinterpret_cast<const BYTE *>(&dwValue), sizeof(DWORD));
}

inline LONG MRegKey::SetDwordLE(LPCTSTR pszValueName, DWORD dw)
{
    DWORD dwValue = dw;
    return RegSetValueEx(pszValueName, 0, REG_DWORD_LITTLE_ENDIAN,
        reinterpret_cast<const BYTE *>(&dwValue), sizeof(DWORD));
}

inline LONG MRegKey::SetDwordBE(LPCTSTR pszValueName, DWORD dw)
{
    DWORD dwValue = dw;
    return RegSetValueEx(pszValueName, 0, REG_DWORD_BIG_ENDIAN,
        reinterpret_cast<const BYTE *>(&dwValue), sizeof(DWORD));
}

inline LONG
MRegKey::SetSz(LPCTSTR pszValueName, LPCTSTR pszValue, DWORD cchValue)
{
    return RegSetValueEx(pszValueName, 0, REG_SZ,
        reinterpret_cast<const BYTE *>(pszValue), cchValue * sizeof(TCHAR));
}

inline LONG
MRegKey::SetExpandSz(LPCTSTR pszValueName, LPCTSTR pszValue, DWORD cchValue)
{
    return RegSetValueEx(pszValueName, 0, REG_EXPAND_SZ,
        reinterpret_cast<const BYTE *>(pszValue), cchValue * sizeof(TCHAR));
}

inline LONG
MRegKey::SetMultiSz(LPCTSTR pszValueName, LPCTSTR pszzValues)
{
    return RegSetValueEx(pszValueName, 0, REG_MULTI_SZ,
        reinterpret_cast<const BYTE *>(pszzValues),
        DWORD(MRegKey::MultiSzSizeDx(pszzValues)));
}

inline LONG
MRegKey::SetMultiSz(LPCTSTR pszValueName, LPCTSTR pszzValues, DWORD cchValues)
{
    DWORD cb = static_cast<DWORD>(sizeof(TCHAR) * cchValues);
    return RegSetValueEx(pszValueName, 0, REG_MULTI_SZ,
        reinterpret_cast<const BYTE *>(pszzValues), cb);
}

inline LONG MRegKey::RegDeleteValue(LPCTSTR pszValueName)
{
    assert(m_hKey);
    return ::RegDeleteValue(m_hKey, pszValueName);
}

inline LONG MRegKey::RegEnumKeyEx(DWORD dwIndex, LPTSTR lpName,
    LPDWORD lpcchName, LPDWORD lpReserved/* = NULL*/,
    LPTSTR lpClass/* = NULL*/, LPDWORD lpcchClass/* = NULL*/,
    PFILETIME lpftLastWriteTime/* = NULL*/)
{
    assert(m_hKey);
    return ::RegEnumKeyEx(m_hKey, dwIndex, lpName, lpcchName,
        lpReserved, lpClass, lpcchClass, lpftLastWriteTime);
}

inline LONG MRegKey::RegEnumValue(DWORD dwIndex, LPTSTR lpName,
    LPDWORD lpcchName, LPDWORD lpReserved/* = NULL*/, LPDWORD lpType/* = NULL*/,
    LPBYTE lpData/* = NULL*/, LPDWORD lpcbData/* = NULL*/)
{
    assert(m_hKey);
    return ::RegEnumValue(m_hKey, dwIndex, lpName, lpcchName, lpReserved,
        lpType, lpData, lpcbData);
}

inline LONG MRegKey::RegFlushKey()
{
    assert(m_hKey);
    return ::RegFlushKey(m_hKey);
}

inline LONG MRegKey::RegGetKeySecurity(SECURITY_INFORMATION si,
    PSECURITY_DESCRIPTOR pSD, LPDWORD pcbSD)
{
    assert(m_hKey);
    return ::RegGetKeySecurity(m_hKey, si, pSD, pcbSD);
}

inline LONG MRegKey::RegNotifyChangeKeyValue(BOOL bWatchSubTree/* = TRUE*/,
    DWORD dwFilter/* = REG_LEGAL_CHANGE_FILTER*/,
    HANDLE hEvent/* = NULL*/, BOOL bAsyncronous/* = FALSE*/)
{
    assert(m_hKey);
    return ::RegNotifyChangeKeyValue(m_hKey, bWatchSubTree, dwFilter,
        hEvent, bAsyncronous);
}

inline LONG MRegKey::RegQueryInfoKey(LPTSTR lpClass/* = NULL*/,
    LPDWORD lpcchClass/* = NULL*/,
    LPDWORD lpReserved/* = NULL*/,
    LPDWORD lpcSubKeys/* = NULL*/,
    LPDWORD lpcchMaxSubKeyLen/* = NULL*/,
    LPDWORD lpcchMaxClassLen/* = NULL*/,
    LPDWORD lpcValues/* = NULL*/,
    LPDWORD lpcchMaxValueNameLen/* = NULL*/,
    LPDWORD lpcbMaxValueLen/* = NULL*/,
    LPDWORD lpcbSecurityDescriptor/* = NULL*/,
    PFILETIME lpftLastWriteTime/* = NULL*/)
{
    assert(m_hKey);
    return ::RegQueryInfoKey(m_hKey, lpClass, lpcchClass,
        lpReserved, lpcSubKeys, lpcchMaxSubKeyLen, lpcchMaxClassLen,
        lpcValues, lpcchMaxValueNameLen, lpcbMaxValueLen,
        lpcbSecurityDescriptor, lpftLastWriteTime);
}

inline LONG MRegKey::RegQueryMultipleValues(PVALENT val_list, DWORD num_vals,
                            LPTSTR lpValueBuf, LPDWORD lpdwTotsize)
{
    assert(m_hKey);
    return ::RegQueryMultipleValues(
        m_hKey, val_list, num_vals, lpValueBuf, lpdwTotsize);
}

inline LONG
MRegKey::RegSetKeySecurity(SECURITY_INFORMATION si, PSECURITY_DESCRIPTOR psd)
{
    assert(m_hKey);
    return ::RegSetKeySecurity(m_hKey, si, psd);
}

inline /*static*/ LONG
MRegKey::RegLoadKey(HKEY hKey, LPCTSTR pszSubKey, LPCTSTR pszFile)
{
    assert(pszSubKey);
    assert(pszFile);
    return ::RegLoadKey(hKey, pszSubKey, pszFile);
}

inline /*static*/ LONG MRegKey::RegUnLoadKey(HKEY hKey, LPCTSTR pszSubKey)
{
    assert(pszSubKey);
    return ::RegUnLoadKey(hKey, pszSubKey);
}

inline /*static*/ LONG
MRegKey::RegSaveKey(HKEY hKey, LPCTSTR pszFile,
                    LPSECURITY_ATTRIBUTES lpsa/* = NULL*/)
{
    assert(pszFile);
    return ::RegSaveKey(hKey, pszFile, lpsa);
}

inline /*static*/
LONG MRegKey::RegRestoreKey(HKEY hKey, LPCTSTR pszFile, DWORD dwFlags)
{
    assert(pszFile);
    return ::RegRestoreKey(hKey, pszFile, dwFlags);
}

inline /*static*/ LONG MRegKey::RegReplaceKey(
    HKEY hKey, LPCTSTR pszSubKey, LPCTSTR pszNewFile, LPCTSTR pszOldFile)
{
    assert(pszNewFile);
    assert(pszOldFile);
    return ::RegReplaceKey(hKey, pszSubKey, pszNewFile, pszOldFile);
}

inline /*static*/ LONG MRegKey::RegDeleteTreeDx(HKEY hKey, LPCTSTR pszSubKey)
{
    return ::RegDeleteTreeDx(hKey, pszSubKey);
}

inline LONG MRegKey::SetSz(LPCTSTR pszValueName, LPCTSTR pszValue)
{
    return SetSz(pszValueName, pszValue, lstrlen(pszValue) + 1);
}

inline LONG MRegKey::SetExpandSz(LPCTSTR pszValueName, LPCTSTR pszValue)
{
    return SetExpandSz(pszValueName, pszValue, lstrlen(pszValue) + 1);
}

inline LONG MRegKey::RegDeleteTreeDx(LPCTSTR pszSubKey)
{
    assert(m_hKey);
    return RegDeleteTreeDx(m_hKey, pszSubKey);
}

inline LONG RegDeleteTreeDx(HKEY hKey, LPCTSTR pszSubKey/* = NULL*/)
{
    LONG ret;
    DWORD cchSubKeyMax, cchValueMax;
    DWORD cchMax, cch;
    TCHAR szNameBuf[MAX_PATH], *pszName = szNameBuf;
    HKEY hSubKey = hKey;

    if (pszSubKey != NULL)
    {
        ret = ::RegOpenKeyEx(hKey, pszSubKey, 0, KEY_READ, &hSubKey);
        if (ret)
            return ret;
    }

    ret = ::RegQueryInfoKey(hSubKey, NULL, NULL, NULL, NULL,
        &cchSubKeyMax, NULL, NULL, &cchValueMax, NULL, NULL, NULL);
    if (ret)
        goto cleanup;

    cchSubKeyMax++;
    cchValueMax++;
    if (cchSubKeyMax < cchValueMax)
        cchMax = cchValueMax;
    else
        cchMax = cchSubKeyMax;
    if (cchMax > sizeof(szNameBuf) / sizeof(TCHAR))
    {
        pszName = new(std::nothrow) TCHAR[cchMax * sizeof(TCHAR)];
        if (pszName == NULL)
            goto cleanup;
    }

    for(;;)
    {
        cch = cchMax;
        if (::RegEnumKeyEx(hSubKey, 0, pszName, &cch, NULL,
                           NULL, NULL, NULL))
        {
            break;
        }

        ret = RegDeleteTreeDx(hSubKey, pszName);
        if (ret)
            goto cleanup;
    }

    if (pszSubKey != NULL)
    {
        ret = ::RegDeleteKey(hKey, pszSubKey);
    }
    else
    {
        // NOTE: if pszSubKey was NULL, then delete value entries.
        for (;;)
        {
            cch = cchMax;
            if (::RegEnumValue(hKey, 0, pszName, &cch,
                               NULL, NULL, NULL, NULL))
            {
                break;
            }

            ret = ::RegDeleteValue(hKey, pszName);
            if (ret)
                goto cleanup;
        }
    }

cleanup:
    if (pszSubKey != NULL)
        ::RegCloseKey(hSubKey);
    if (pszName != szNameBuf)
        delete[] pszName;
    return ret;
}

inline /*static*/ size_t MRegKey::MultiSzSizeDx(LPCTSTR pszz)
{
    size_t siz = 0;
    if (*pszz)
    {
        do
        {
            size_t len = lstrlen(pszz);
            siz += len + 1;
            pszz += len + 1;
        }
        while (*pszz);
    }
    else
    {
        ++siz;
    }
    ++siz;
    siz *= sizeof(TCHAR);
    return siz;
}

inline /*static*/ HKEY MRegKey::CloneHandleDx(HKEY hKey)
{
    if (hKey == NULL)
        return NULL;

    HANDLE hProcess = ::GetCurrentProcess();
    HANDLE hDup = NULL;
    ::DuplicateHandle(hProcess, hKey, hProcess, &hDup, 0,
                      FALSE, DUPLICATE_SAME_ACCESS);
    return reinterpret_cast<HKEY>(hDup);
}

////////////////////////////////////////////////////////////////////////////

#endif  // ndef MZC4_MREGKEY_HPP_

```

`src/MRegKeyPortable.hpp`:

```hpp
// MRegKeyPortablePortable.hpp -- *.ini file manipulator        -*- C++ -*-
// This file is part of MZC4.  See file "ReadMe.txt" and "License.txt".
////////////////////////////////////////////////////////////////////////////

#ifndef MZC4_MREGKEYPORTABLE_HPP_
#define MZC4_MREGKEYPORTABLE_HPP_       8   /* Version 8 */

#ifndef HKCR
    #define HKCR    HKEY_CLASSES_ROOT
    #define HKCU    HKEY_CURRENT_USER
    #define HKLM    HKEY_LOCAL_MACHINE
    #define HKU     HKEY_USERS
    #define HKPD    HKEY_PERFORMANCE_DATA
    #define HKCC    HKEY_CURRENT_CONFIG
    #define HKDD    HKEY_DYN_DATA
#endif

class MRegKeyPortable;

////////////////////////////////////////////////////////////////////////////

#ifndef _INC_WINDOWS
    #include <windows.h>    // Win32API
#endif
#include <shlwapi.h>
#include <cassert>          // assert
#include <new>              // std::nothrow
#include <string>           // std::wstring

#ifdef UNICODE
    typedef std::wstring tstring;
#else
    typedef std::string tstring;
#endif

////////////////////////////////////////////////////////////////////////////

class MRegKeyPortable
{
public:
    MRegKeyPortable(LPCWSTR pszAppName, LPCWSTR pszIniFileName = NULL);
    virtual ~MRegKeyPortable();

    LONG RegCloseKey();

    LONG RegQueryValueEx(LPCTSTR pszValueName = NULL, 
                         LPDWORD lpReserved = NULL, LPDWORD lpType = NULL, 
                         LPBYTE lpData = NULL, LPDWORD lpcbData = NULL);

    LONG QueryBinary(LPCTSTR pszValueName, LPVOID pvValue, DWORD cb);
    LONG QueryDword(LPCTSTR pszValueName, DWORD& dw);
    LONG QueryDwordLE(LPCTSTR pszValueName, DWORD& dw);
    LONG QueryDwordBE(LPCTSTR pszValueName, DWORD& dw);
    LONG QuerySz(LPCTSTR pszValueName, LPTSTR pszValue, DWORD cchValue);
    LONG QueryExpandSz(LPCTSTR pszValueName, LPTSTR pszValue, DWORD cchValue);
    LONG QueryMultiSz(LPCTSTR pszValueName, LPTSTR pszzValues, DWORD cchValues);
    template <typename T_CONTAINER>
    LONG QueryMultiSz(LPCTSTR pszValueName, T_CONTAINER& container);
    template <typename T_STRUCT>
    LONG QueryStruct(LPCTSTR pszValueName, T_STRUCT& data);

    template <typename T_STRING>
    LONG QuerySz(LPCTSTR pszValueName, T_STRING& strValue);
    template <typename T_STRING>
    LONG QueryExpandSz(LPCTSTR pszValueName, T_STRING& strValue);

    LONG RegSetValueEx(LPCTSTR pszValueName, DWORD dwReserved, 
        DWORD dwType, CONST BYTE *lpData, DWORD cbData);

    LONG SetBinary(LPCTSTR pszValueName, LPCVOID pvValue, DWORD cb);
    LONG SetDword(LPCTSTR pszValueName, DWORD dw);
    LONG SetDwordLE(LPCTSTR pszValueName, DWORD dw);
    LONG SetDwordBE(LPCTSTR pszValueName, DWORD dw);
    LONG SetSz(LPCTSTR pszValueName, LPCTSTR pszValue, DWORD cchValue);
    LONG SetSz(LPCTSTR pszValueName, LPCTSTR pszValue);
    LONG SetExpandSz(LPCTSTR pszValueName, LPCTSTR pszValue, DWORD cchValue);
    LONG SetExpandSz(LPCTSTR pszValueName, LPCTSTR pszValue);
    LONG SetMultiSz(LPCTSTR pszValueName, LPCTSTR pszzValues);
    LONG SetMultiSz(LPCTSTR pszValueName, LPCTSTR pszzValues, DWORD cchValues);
    template <typename T_CONTAINER>
    LONG SetMultiSz(LPCTSTR pszValueName, const T_CONTAINER& container);
    template <typename T_STRUCT>
    LONG SetStruct(LPCTSTR pszValueName, const T_STRUCT& data);

    LONG RegDeleteValue(LPCTSTR pszValueName);
    LONG RegFlushKey();

    static DWORD MultiSzSizeDx(LPCTSTR pszz);

protected:
    tstring m_strIniFileName;
    tstring m_strAppName;
};

////////////////////////////////////////////////////////////////////////////

inline
MRegKeyPortable::MRegKeyPortable(LPCWSTR pszAppName, LPCWSTR pszIniFileName)
    : m_strAppName(pszAppName)
{
    if (pszIniFileName)
    {
        m_strIniFileName = pszIniFileName;
    }
    else
    {
        TCHAR szPath[MAX_PATH];
        GetModuleFileName(NULL, szPath, ARRAYSIZE(szPath));
        LPTSTR pchDotExt = PathFindExtension(szPath);
        if (pchDotExt)
            *pchDotExt = 0;
        m_strIniFileName = szPath;
        m_strIniFileName += TEXT(".ini");
    }
}

template <typename T_STRUCT>
inline LONG MRegKeyPortable::QueryStruct(LPCTSTR pszValueName, T_STRUCT& data)
{
    DWORD cbData = sizeof(data);
    return MRegKeyPortable::RegQueryValueEx(pszValueName, NULL, NULL, (LPBYTE)&data, &cbData);
}

template <typename T_STRUCT>
inline LONG MRegKeyPortable::SetStruct(LPCTSTR pszValueName, const T_STRUCT& data)
{
    return MRegKeyPortable::RegSetValueEx(pszValueName, 0, REG_BINARY,
                                          (CONST BYTE *)&data, sizeof(data));
}

template <typename T_STRING>
LONG MRegKeyPortable::QuerySz(LPCTSTR pszValueName, T_STRING& strValue)
{
    LONG result;
    strValue.clear();

    DWORD cbData;
    result = RegQueryValueEx(pszValueName, NULL, NULL, NULL, &cbData);
    if (result != ERROR_SUCCESS)
        return result;

    LPTSTR psz = new(std::nothrow) TCHAR[cbData / sizeof(TCHAR) + 1];
    assert(psz);
    if (psz)
    {
        result = RegQueryValueEx(pszValueName, NULL, NULL, 
                                 reinterpret_cast<LPBYTE>(psz), &cbData);
        if (result != ERROR_SUCCESS)
        {
            strValue = psz;
        }
        delete[] psz;
    }
    return result;
}

template <typename T_STRING>
LONG MRegKeyPortable::QueryExpandSz(LPCTSTR pszValueName, T_STRING& strValue)
{
    LONG result;
    strValue.clear();

    DWORD cbData;
    result = RegQueryValueEx(pszValueName, NULL, NULL, NULL, &cbData);
    if (result != ERROR_SUCCESS)
        return result;

    LPTSTR psz = new(std::nothrow) TCHAR[cbData / sizeof(TCHAR) + 1];
    assert(psz);
    if (psz)
    {
        result = RegQueryValueEx(pszValueName, NULL, NULL, 
                                 reinterpret_cast<LPBYTE>(psz), &cbData);
        if (result != ERROR_SUCCESS)
        {
            strValue = psz;
        }
        delete[] psz;
    }
    return result;
}

inline /*virtual*/ MRegKeyPortable::~MRegKeyPortable()
{
    RegCloseKey();
}

inline LONG MRegKeyPortable::RegCloseKey()
{
    return MRegKeyPortable::RegFlushKey();
}

inline LONG MRegKeyPortable::RegQueryValueEx(LPCTSTR pszValueName/* = NULL*/, 
    LPDWORD lpReserved/* = NULL*/, LPDWORD lpType/* = NULL*/, 
    LPBYTE lpData/* = NULL*/, LPDWORD lpcbData/* = NULL*/)
{
    if (pszValueName == NULL)
        pszValueName = TEXT(".DEFAULT");

    static TCHAR s_szText[1024];
    char sz[3];
    BOOL bOK;
    bOK = GetPrivateProfileString(m_strAppName.c_str(), pszValueName, TEXT(""),
                                  s_szText, ARRAYSIZE(s_szText), m_strIniFileName.c_str());
    if (!bOK || s_szText[0] == 0)
        return ERROR_ACCESS_DENIED;

    StrTrim(s_szText, TEXT(" \t\r\n"));

    DWORD cchText = lstrlen(s_szText);
    DWORD cbValue = (cchText - 2) / 2;

    if (lpcbData)
    {
        if (*lpcbData < cbValue)
        {
            *lpcbData = cbValue;
            return ERROR_MORE_DATA;
        }
        *lpcbData = cbValue;
    }

    if (s_szText[2 * cbValue] != TEXT(':'))
        return ERROR_ACCESS_DENIED;

    if (lpType)
    {
        sz[0] = (char)s_szText[2 * cbValue + 1];
        sz[1] = 0;
        *lpType = strtol(sz, NULL, 16);
    }

    if (lpData == NULL)
    {
        return ERROR_SUCCESS;
    }

    for (DWORD i = 0; i < cbValue; ++i)
    {
        sz[0] = (char)s_szText[2 * i + 0];
        sz[1] = (char)s_szText[2 * i + 1];
        sz[2] = 0;
        lpData[i] = (BYTE)strtol(sz, NULL, 16);
    }

    return ERROR_SUCCESS;
}

inline LONG MRegKeyPortable::QueryBinary(
    LPCTSTR pszValueName, LPVOID pvValue, DWORD cb)
{
    DWORD cbData = cb;
    return RegQueryValueEx(pszValueName, NULL, NULL, 
                           reinterpret_cast<LPBYTE>(pvValue), 
                           &cbData);
}

inline LONG MRegKeyPortable::QueryDword(LPCTSTR pszValueName, DWORD& dw)
{
    DWORD cbData = sizeof(DWORD);
    return RegQueryValueEx(pszValueName, NULL, NULL, 
                           reinterpret_cast<LPBYTE>(&dw), &cbData);
}

inline LONG MRegKeyPortable::QueryDwordLE(LPCTSTR pszValueName, DWORD& dw)
{
    DWORD cbData = sizeof(DWORD);
    return RegQueryValueEx(pszValueName, NULL, NULL, 
                           reinterpret_cast<LPBYTE>(&dw), &cbData);
}

inline LONG MRegKeyPortable::QueryDwordBE(LPCTSTR pszValueName, DWORD& dw)
{
    DWORD cbData = sizeof(DWORD);
    return RegQueryValueEx(pszValueName, NULL, NULL, 
                           reinterpret_cast<LPBYTE>(&dw), &cbData);
}

inline LONG
MRegKeyPortable::QuerySz(LPCTSTR pszValueName, LPTSTR pszValue, DWORD cchValue)
{
    DWORD cbData = cchValue * sizeof(TCHAR);
    return RegQueryValueEx(pszValueName, NULL, NULL, 
                           reinterpret_cast<LPBYTE>(pszValue), &cbData);
}

inline LONG MRegKeyPortable::QueryExpandSz(
    LPCTSTR pszValueName, LPTSTR pszValue, DWORD cchValue)
{
    DWORD cbData = cchValue * sizeof(TCHAR);
    return RegQueryValueEx(pszValueName, NULL, NULL, 
                           reinterpret_cast<LPBYTE>(pszValue), &cbData);
}

inline LONG MRegKeyPortable::RegSetValueEx(LPCTSTR pszValueName, DWORD dwReserved, 
    DWORD dwType, CONST BYTE *lpData, DWORD cbData)
{
    static TCHAR s_szText[1024];
    static const TCHAR s_szHex[] = TEXT("0123456789ABCDEF");

    if (pszValueName == NULL)
        pszValueName = TEXT(".DEFAULT");

    if (cbData * 2 + 3 > ARRAYSIZE(s_szText))
        return ERROR_ACCESS_DENIED;

    DWORD i;
    for (i = 0; i < cbData; ++i)
    {
        s_szText[2 * i + 0] = s_szHex[(lpData[i] >> 4) & 0x0F];
        s_szText[2 * i + 1] = s_szHex[lpData[i] & 0x0F];
    }
    s_szText[2 * i + 0] = TEXT(':');
    s_szText[2 * i + 1] = s_szHex[dwType & 0xF];
    s_szText[2 * i + 2] = 0;

    BOOL bOK = WritePrivateProfileString(m_strAppName.c_str(), pszValueName, s_szText,
                                         m_strIniFileName.c_str());
    return bOK ? ERROR_SUCCESS : ERROR_ACCESS_DENIED;
}

inline LONG MRegKeyPortable::SetBinary(LPCTSTR pszValueName, LPCVOID pvValue, DWORD cb)
{
    return RegSetValueEx(pszValueName, 0, REG_BINARY, 
        reinterpret_cast<const BYTE *>(pvValue), cb);
}

inline LONG MRegKeyPortable::SetDword(LPCTSTR pszValueName, DWORD dw)
{
    DWORD dwValue = dw;
    return RegSetValueEx(pszValueName, 0, REG_DWORD, 
        reinterpret_cast<const BYTE *>(&dwValue), sizeof(DWORD));
}

inline LONG MRegKeyPortable::SetDwordLE(LPCTSTR pszValueName, DWORD dw)
{
    DWORD dwValue = dw;
    return RegSetValueEx(pszValueName, 0, REG_DWORD_LITTLE_ENDIAN, 
        reinterpret_cast<const BYTE *>(&dwValue), sizeof(DWORD));
}

inline LONG MRegKeyPortable::SetDwordBE(LPCTSTR pszValueName, DWORD dw)
{
    DWORD dwValue = dw;
    return RegSetValueEx(pszValueName, 0, REG_DWORD_BIG_ENDIAN, 
        reinterpret_cast<const BYTE *>(&dwValue), sizeof(DWORD));
}

inline LONG
MRegKeyPortable::SetSz(LPCTSTR pszValueName, LPCTSTR pszValue, DWORD cchValue)
{
    return RegSetValueEx(pszValueName, 0, REG_SZ, 
        reinterpret_cast<const BYTE *>(pszValue), cchValue * sizeof(TCHAR));
}

inline LONG
MRegKeyPortable::SetExpandSz(LPCTSTR pszValueName, LPCTSTR pszValue, DWORD cchValue)
{
    return RegSetValueEx(pszValueName, 0, REG_EXPAND_SZ, 
        reinterpret_cast<const BYTE *>(pszValue), cchValue * sizeof(TCHAR));
}

inline LONG MRegKeyPortable::RegDeleteValue(LPCTSTR pszValueName)
{
    BOOL bOK = WritePrivateProfileString(m_strAppName.c_str(), pszValueName, NULL,
                                         m_strIniFileName.c_str());
    return (bOK ? ERROR_SUCCESS : ERROR_ACCESS_DENIED);
}

inline LONG MRegKeyPortable::RegFlushKey()
{
    ::WritePrivateProfileString(NULL, NULL, NULL, m_strIniFileName.c_str());
    return ERROR_SUCCESS;
}

inline LONG MRegKeyPortable::SetSz(LPCTSTR pszValueName, LPCTSTR pszValue)
{
    return SetSz(pszValueName, pszValue, lstrlen(pszValue) + 1);
}

inline LONG MRegKeyPortable::SetExpandSz(LPCTSTR pszValueName, LPCTSTR pszValue)
{
    return SetExpandSz(pszValueName, pszValue, lstrlen(pszValue) + 1);
}

template <typename T_CONTAINER>
LONG MRegKeyPortable::QueryMultiSz(LPCTSTR pszValueName, T_CONTAINER& container)
{
    container.clear();

    LONG result;
    DWORD cbData;
    result = RegQueryValueEx(pszValueName, NULL, NULL, NULL, &cbData);
    if (result != ERROR_SUCCESS)
        return result;

    const DWORD cch = static_cast<DWORD>(cbData / sizeof(TCHAR) + 1);
    LPTSTR pszz = new(std::nothrow) TCHAR[cch];
    if (pszz)
    {
        result = QueryMultiSz(pszValueName, pszz, cch);
        if (result == ERROR_SUCCESS)
        {
            for (LPTSTR pch = pszz; *pch; pch += lstrlen(pch) + 1)
            {
                #if (__cplusplus >= 201103L)
                    container.emplace_back(pch);
                #else
                    container.push_back(pch);
                #endif
            }
        }
        delete[] pszz;
    }
    else
        result = ERROR_OUTOFMEMORY;

    return result;
}

template <typename T_CONTAINER>
inline LONG MRegKeyPortable::SetMultiSz(
    LPCTSTR pszValueName, const T_CONTAINER& container)
{
    typename T_CONTAINER::value_type         str;
    typename T_CONTAINER::const_iterator     it, end;

    it = container.begin();
    end = container.end();
    if (it != end)
    {
        for (; it != end; ++it)
        {
            str += *it;
            str += TEXT('\0');
        }
    }
    else
    {
        str += TEXT('\0');
    }

    const DWORD cchValues = static_cast<DWORD>(str.size() + 1);
    return SetMultiSz(pszValueName, str.c_str(), cchValues);
}

inline LONG MRegKeyPortable::QueryMultiSz(
    LPCTSTR pszValueName, LPTSTR pszzValues, DWORD cchValues)
{
    DWORD cbData = sizeof(TCHAR) * cchValues;
    return RegQueryValueEx(pszValueName, NULL, NULL, 
                           reinterpret_cast<LPBYTE>(pszzValues), &cbData);
}

inline LONG
MRegKeyPortable::SetMultiSz(LPCTSTR pszValueName, LPCTSTR pszzValues)
{
    return RegSetValueEx(pszValueName, 0, REG_MULTI_SZ, 
        reinterpret_cast<const BYTE *>(pszzValues), 
        MRegKeyPortable::MultiSzSizeDx(pszzValues));
}

inline LONG
MRegKeyPortable::SetMultiSz(LPCTSTR pszValueName, LPCTSTR pszzValues, DWORD cchValues)
{
    DWORD cb = static_cast<DWORD>(sizeof(TCHAR) * cchValues);
    return RegSetValueEx(pszValueName, 0, REG_MULTI_SZ, 
        reinterpret_cast<const BYTE *>(pszzValues), cb);
}

inline /*static*/ DWORD MRegKeyPortable::MultiSzSizeDx(LPCTSTR pszz)
{
    DWORD siz = 0;
    if (*pszz)
    {
        do
        {
            INT len = lstrlen(pszz);
            siz += len + 1;
            pszz += len + 1;
        }
        while (*pszz);
    }
    else
    {
        ++siz;
    }
    ++siz;
    siz *= static_cast<DWORD>(sizeof(TCHAR));
    return siz;
}

////////////////////////////////////////////////////////////////////////////

#endif  // ndef MZC4_MREGKEYPORTABLE_HPP_

```

`src/MReplaceBinDlg.hpp`:

```hpp
// MReplaceBinDlg.hpp --- "Replace Binary" Dialog
//////////////////////////////////////////////////////////////////////////////
// RisohEditor --- Another free Win32 resource editor
// Copyright (C) 2017-2018 Katayama Hirofumi MZ <katayama.hirofumi.mz@gmail.com>
// 
// This program is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
// 
// This program is distributed in the hope that it will be useful, 
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
// 
// You should have received a copy of the GNU General Public License
// along with this program.  If not, see <http://www.gnu.org/licenses/>.
//////////////////////////////////////////////////////////////////////////////

#pragma once

#include "resource.h"
#include "MWindowBase.hpp"
#include "RisohSettings.hpp"
#include "ConstantsDB.hpp"
#include "Res.hpp"
#include "Common.hpp"

//////////////////////////////////////////////////////////////////////////////

class MReplaceBinDlg : public MDialogBase
{
public:
    EntryBase *m_entry;
    MIdOrString m_type;
    MIdOrString m_name;
    WORD m_lang;

    MReplaceBinDlg(EntryBase *entry)
        : MDialogBase(IDD_REPLACERES), m_entry(entry),
          m_type(entry->m_type), m_name(entry->m_name), m_lang(entry->m_lang)
    {
    }

    virtual INT_PTR CALLBACK
    DialogProcDx(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
    {
        switch (uMsg)
        {
            HANDLE_MSG(hwnd, WM_INITDIALOG, OnInitDialog);
            HANDLE_MSG(hwnd, WM_DROPFILES, OnDropFiles);
            HANDLE_MSG(hwnd, WM_COMMAND, OnCommand);
        }
        return DefaultProcDx(hwnd, uMsg, wParam, lParam);
    }

    BOOL OnInitDialog(HWND hwnd, HWND hwndFocus, LPARAM lParam)
    {
        DragAcceptFiles(hwnd, TRUE);

        // for Types
        HWND hCmb1 = GetDlgItem(hwnd, cmb1);
        EnableWindow(hCmb1, FALSE);

        InitResTypeComboBox(hCmb1, m_type);

        // for Names
        HWND hCmb2 = GetDlgItem(hwnd, cmb2);
        InitResNameComboBox(hCmb2, m_entry->m_name, IDTYPE_RESOURCE);

        // for Langs
        HWND hCmb3 = GetDlgItem(hwnd, cmb3);
        InitLangComboBox(hCmb3, m_entry->m_lang);

        CenterWindowDx();
        return TRUE;
    }

    void OnPsh1(HWND hwnd)
    {
        MStringW strFile = GetDlgItemText(edt1);
        mstr_trim(strFile);

        WCHAR szFile[MAX_PATH];
        lstrcpyn(szFile, strFile.c_str(), _countof(szFile));

        OPENFILENAMEW ofn;
        ZeroMemory(&ofn, sizeof(ofn));
        ofn.lStructSize = OPENFILENAME_SIZE_VERSION_400W;
        ofn.hwndOwner = hwnd;
        ofn.lpstrFilter = MakeFilterDx(LoadStringDx(IDS_ALLFILES));
        ofn.lpstrFile = szFile;
        ofn.nMaxFile = _countof(szFile);
        ofn.lpstrTitle = LoadStringDx(IDS_REPLACERES);
        ofn.Flags = OFN_ENABLESIZING | OFN_EXPLORER | OFN_FILEMUSTEXIST |
            OFN_HIDEREADONLY | OFN_PATHMUSTEXIST;
        ofn.lpstrDefExt = L"bin";
        if (GetOpenFileNameW(&ofn))
        {
            SetDlgItemTextW(hwnd, edt1, szFile);
        }
    }

    void OnOK(HWND hwnd)
    {
        const ConstantsDB::TableType& table = g_db.GetTable(L"RESOURCE");

        MIdOrString type;
        HWND hCmb1 = GetDlgItem(hwnd, cmb1);
        INT iType = ComboBox_GetCurSel(hCmb1);
        if (iType != CB_ERR && iType < INT(table.size()))
        {
            type = WORD(table[iType].value);
        }
        else
        {
            if (!CheckTypeComboBox(hCmb1, type))
                return;
        }

        HWND hCmb2 = GetDlgItem(hwnd, cmb2);
        MIdOrString name;
        if (!CheckNameComboBox(hCmb2, name))
            return;

        HWND hCmb3 = GetDlgItem(hwnd, cmb3);
        WORD lang;
        if (!CheckLangComboBox(hCmb3, lang))
            return;

        std::wstring file;
        HWND hEdt1 = GetDlgItem(hwnd, edt1);
        if (!Edt1_CheckFile(hEdt1, file))
        {
            Edit_SetSel(hEdt1, 0, -1);  // select all
            SetFocus(hEdt1);    // set focus
            ErrorBoxDx(IDS_FILENOTFOUND);
            return;
        }

        MByteStreamEx bs;
        if (!bs.LoadFromFile(file.c_str()))
        {
            ErrorBoxDx(IDS_CANNOTREPLACE);
            return;
        }

        g_res.add_lang_entry(type, name, lang, bs.data());

        m_type = type;
        m_name = name;
        m_lang = lang;

        EndDialog(IDOK);
    }

    void OnCommand(HWND hwnd, int id, HWND hwndCtl, UINT codeNotify)
    {
        switch (id)
        {
        case IDOK:
            OnOK(hwnd);
            break;
        case IDCANCEL:
            EndDialog(IDCANCEL);
            break;
        case psh1:
            OnPsh1(hwnd);
            break;
        }
    }

    void OnDropFiles(HWND hwnd, HDROP hdrop)
    {
        WCHAR file[MAX_PATH];
        DragQueryFileW(hdrop, 0, file, _countof(file));
        SetDlgItemTextW(hwnd, edt1, file);
    }
};

```

`src/MReplaceBitmapDlg.hpp`:

```hpp
// MReplaceBitmapDlg.hpp --- "Replace Bitmap" Dialog
//////////////////////////////////////////////////////////////////////////////
// RisohEditor --- Another free Win32 resource editor
// Copyright (C) 2017-2018 Katayama Hirofumi MZ <katayama.hirofumi.mz@gmail.com>
// 
// This program is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
// 
// This program is distributed in the hope that it will be useful, 
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
// 
// You should have received a copy of the GNU General Public License
// along with this program.  If not, see <http://www.gnu.org/licenses/>.
//////////////////////////////////////////////////////////////////////////////

#pragma once

#include "resource.h"
#include "MWindowBase.hpp"
#include "RisohSettings.hpp"
#include "ConstantsDB.hpp"
#include "Res.hpp"
#include "Common.hpp"

//////////////////////////////////////////////////////////////////////////////

class MReplaceBitmapDlg : public MDialogBase
{
public:
    EntryBase& m_entry;
    MIdOrString m_type;
    MIdOrString m_name;
    WORD m_lang;

    MReplaceBitmapDlg(EntryBase& entry)
        : MDialogBase(IDD_REPLACEBMP), m_entry(entry),
          m_type(entry.m_type), m_name(entry.m_name), m_lang(entry.m_lang)
    {
    }

    BOOL OnInitDialog(HWND hwnd, HWND hwndFocus, LPARAM lParam)
    {
        DragAcceptFiles(hwnd, TRUE);

        // for Names
        HWND hCmb2 = GetDlgItem(hwnd, cmb2);
        InitResNameComboBox(hCmb2, m_entry.m_name, IDTYPE_BITMAP);

        // for Langs
        HWND hCmb3 = GetDlgItem(hwnd, cmb3);
        InitLangComboBox(hCmb3, m_entry.m_lang);

        CenterWindowDx();
        return TRUE;
    }

    void OnOK(HWND hwnd)
    {
        MIdOrString type = RT_BITMAP;

        MIdOrString name;
        HWND hCmb2 = GetDlgItem(hwnd, cmb2);
        if (!CheckNameComboBox(hCmb2, name))
            return;

        HWND hCmb3 = GetDlgItem(hwnd, cmb3);
        WORD lang;
        if (!CheckLangComboBox(hCmb3, lang))
            return;

        std::wstring file;
        HWND hEdt1 = GetDlgItem(hwnd, edt1);
        if (!Edt1_CheckFile(hEdt1, file))
        {
            Edit_SetSel(hEdt1, 0, -1);  // select all
            SetFocus(hEdt1);    // set focus
            ErrorBoxDx(IDS_FILENOTFOUND);
            return;
        }

        if (!g_res.add_bitmap(name, lang, file))
        {
            ErrorBoxDx(IDS_CANTREPLACEBMP);
            return;
        }

        m_type = type;
        m_name = name;
        m_lang = lang;

        EndDialog(IDOK);
    }

    void OnPsh1(HWND hwnd)
    {
        MStringW strFile = GetDlgItemText(edt1);
        mstr_trim(strFile);

        WCHAR szFile[MAX_PATH];
        lstrcpynW(szFile, strFile.c_str(), _countof(szFile));

        OPENFILENAMEW ofn;
        ZeroMemory(&ofn, sizeof(ofn));
        ofn.lStructSize = OPENFILENAME_SIZE_VERSION_400W;
        ofn.hwndOwner = hwnd;
        ofn.lpstrFilter = MakeFilterDx(LoadStringDx(IDS_BMPFILTER));
        ofn.lpstrFile = szFile;
        ofn.nMaxFile = _countof(szFile);
        ofn.lpstrTitle = LoadStringDx(IDS_REPLACEBMP);
        ofn.Flags = OFN_ENABLESIZING | OFN_EXPLORER | OFN_FILEMUSTEXIST |
            OFN_HIDEREADONLY | OFN_PATHMUSTEXIST;
        ofn.lpstrDefExt = L"bmp";
        if (GetOpenFileNameW(&ofn))
        {
            SetDlgItemTextW(hwnd, edt1, szFile);
        }
    }

    void OnCommand(HWND hwnd, int id, HWND hwndCtl, UINT codeNotify)
    {
        switch (id)
        {
        case IDOK:
            OnOK(hwnd);
            break;
        case IDCANCEL:
            EndDialog(IDCANCEL);
            break;
        case psh1:
            OnPsh1(hwnd);
            break;
        }
    }

    void OnDropFiles(HWND hwnd, HDROP hdrop)
    {
        WCHAR file[MAX_PATH];
        DragQueryFileW(hdrop, 0, file, _countof(file));
        SetDlgItemTextW(hwnd, edt1, file);
    }

    virtual INT_PTR CALLBACK
    DialogProcDx(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
    {
        switch (uMsg)
        {
            HANDLE_MSG(hwnd, WM_INITDIALOG, OnInitDialog);
            HANDLE_MSG(hwnd, WM_DROPFILES, OnDropFiles);
            HANDLE_MSG(hwnd, WM_COMMAND, OnCommand);
        }
        return 0;
    }
};

```

`src/MReplaceCursorDlg.hpp`:

```hpp
// MReplaceCursorDlg.hpp --- "Replace Cursor" Dialog
//////////////////////////////////////////////////////////////////////////////
// RisohEditor --- Another free Win32 resource editor
// Copyright (C) 2017-2018 Katayama Hirofumi MZ <katayama.hirofumi.mz@gmail.com>
// 
// This program is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
// 
// This program is distributed in the hope that it will be useful, 
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
// 
// You should have received a copy of the GNU General Public License
// along with this program.  If not, see <http://www.gnu.org/licenses/>.
//////////////////////////////////////////////////////////////////////////////

#pragma once

#include "resource.h"
#include "MWindowBase.hpp"
#include "RisohSettings.hpp"
#include "ConstantsDB.hpp"
#include "Res.hpp"
#include "Common.hpp"

//////////////////////////////////////////////////////////////////////////////

class MReplaceCursorDlg : public MDialogBase
{
protected:
    HCURSOR   m_hCursor;
public:
    EntryBase *m_entry;
    MIdOrString m_type;
    MIdOrString m_name;
    WORD m_lang;

    MReplaceCursorDlg(EntryBase *entry) :
        MDialogBase(IDD_REPLACECUR), m_entry(entry),
          m_type(entry->m_type), m_name(entry->m_name), m_lang(entry->m_lang)
    {
        m_hCursor = NULL;
    }

    ~MReplaceCursorDlg()
    {
        DestroyCursor(m_hCursor);
    }

    BOOL OnInitDialog(HWND hwnd, HWND hwndFocus, LPARAM lParam)
    {
        DragAcceptFiles(hwnd, TRUE);

        // for name
        HWND hCmb2 = GetDlgItem(hwnd, cmb2);
        InitResNameComboBox(hCmb2, m_entry->m_name, IDTYPE_CURSOR);

        // for Langs
        HWND hCmb3 = GetDlgItem(hwnd, cmb3);
        InitLangComboBox(hCmb3, m_entry->m_lang);

        CenterWindowDx();
        return TRUE;
    }

    void OnOK(HWND hwnd)
    {
        MIdOrString type = m_entry->m_type;

        MIdOrString name;
        HWND hCmb2 = GetDlgItem(hwnd, cmb2);
        if (!CheckNameComboBox(hCmb2, name))
            return;

        HWND hCmb3 = GetDlgItem(hwnd, cmb3);
        WORD lang;
        if (!CheckLangComboBox(hCmb3, lang))
            return;

        std::wstring file;
        HWND hEdt1 = GetDlgItem(hwnd, edt1);
        if (!Edt1_CheckFile(hEdt1, file))
        {
            Edit_SetSel(hEdt1, 0, -1);  // select all
            SetFocus(hEdt1);    // set focus
            ErrorBoxDx(IDS_FILENOTFOUND);
            return;
        }

        BOOL bAni = FALSE;
        size_t ich = file.find(L'.');
        if (ich != std::wstring::npos && lstrcmpiW(&file[ich], L".ani") == 0)
            bAni = TRUE;

        if (bAni)   // animation cursor (*.ani)
        {
            MByteStream bs;
            if (!bs.LoadFromFile(file.c_str()) ||
                !g_res.add_lang_entry(RT_ANICURSOR, name, lang, bs.data()))
            {
                ErrorBoxDx(IDS_CANTREPLACECUR);
                return;
            }
        }
        else    // normal cursor (*.cur)
        {
            if (auto entry = g_res.find(ET_LANG, m_type, m_name, m_lang))
                g_res.delete_entry(entry);

            if (!g_res.add_group_cursor(name, lang, file))
            {
                ErrorBoxDx(IDS_CANTREPLACECUR);
                return;
            }
        }

        m_type = type;
        m_name = name;
        m_lang = lang;

        EndDialog(IDOK);
    }

    void OnPsh1(HWND hwnd)
    {
        MStringW strFile = GetDlgItemText(edt1);
        mstr_trim(strFile);

        WCHAR szFile[MAX_PATH];
        lstrcpynW(szFile, strFile.c_str(), _countof(szFile));

        OPENFILENAMEW ofn;
        ZeroMemory(&ofn, sizeof(ofn));
        ofn.lStructSize = OPENFILENAME_SIZE_VERSION_400W;
        ofn.hwndOwner = hwnd;
        ofn.lpstrFilter = MakeFilterDx(LoadStringDx(IDS_CURFILTER));
        ofn.lpstrFile = szFile;
        ofn.nMaxFile = _countof(szFile);
        ofn.lpstrTitle = LoadStringDx(IDS_REPLACECUR);
        ofn.Flags = OFN_ENABLESIZING | OFN_EXPLORER | OFN_FILEMUSTEXIST |
            OFN_HIDEREADONLY | OFN_PATHMUSTEXIST;
        if (m_entry->m_type == RT_ANICURSOR)
        {
            ofn.nFilterIndex = 2;
            ofn.lpstrDefExt = L"ani";
        }
        else
        {
            ofn.nFilterIndex = 1;
            ofn.lpstrDefExt = L"cur";
        }
        if (GetOpenFileNameW(&ofn))
        {
            SetDlgItemTextW(hwnd, edt1, szFile);
            if (m_hCursor)
                DestroyCursor(m_hCursor);
            m_hCursor = LoadCursorFromFile(szFile);
            SendDlgItemMessage(hwnd, ico1, STM_SETIMAGE, IMAGE_CURSOR, LPARAM(m_hCursor));
        }
    }

    void OnCommand(HWND hwnd, int id, HWND hwndCtl, UINT codeNotify)
    {
        switch (id)
        {
        case IDOK:
            OnOK(hwnd);
            break;
        case IDCANCEL:
            EndDialog(IDCANCEL);
            break;
        case psh1:
            OnPsh1(hwnd);
            break;
        }
    }

    void OnDropFiles(HWND hwnd, HDROP hdrop)
    {
        WCHAR file[MAX_PATH];
        DragQueryFileW(hdrop, 0, file, _countof(file));
        SetDlgItemTextW(hwnd, edt1, file);

        if (m_hCursor)
            DestroyCursor(m_hCursor);
        m_hCursor = LoadCursorFromFile(file);
        SendDlgItemMessage(hwnd, ico1, STM_SETIMAGE, IMAGE_CURSOR, LPARAM(m_hCursor));
        DragFinish(hdrop);
    }

    virtual INT_PTR CALLBACK
    DialogProcDx(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
    {
        switch (uMsg)
        {
            HANDLE_MSG(hwnd, WM_INITDIALOG, OnInitDialog);
            HANDLE_MSG(hwnd, WM_DROPFILES, OnDropFiles);
            HANDLE_MSG(hwnd, WM_COMMAND, OnCommand);
        }
        return 0;
    }
};

```

`src/MReplaceIconDlg.hpp`:

```hpp
// MReplaceIconDlg.hpp --- "Replace Icon" Dialog
//////////////////////////////////////////////////////////////////////////////
// RisohEditor --- Another free Win32 resource editor
// Copyright (C) 2017-2018 Katayama Hirofumi MZ <katayama.hirofumi.mz@gmail.com>
// 
// This program is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
// 
// This program is distributed in the hope that it will be useful, 
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
// 
// You should have received a copy of the GNU General Public License
// along with this program.  If not, see <http://www.gnu.org/licenses/>.
//////////////////////////////////////////////////////////////////////////////

#pragma once

#include "resource.h"
#include "MWindowBase.hpp"
#include "RisohSettings.hpp"
#include "ConstantsDB.hpp"
#include "Res.hpp"
#include "Common.hpp"

//////////////////////////////////////////////////////////////////////////////

class MReplaceIconDlg : public MDialogBase
{
protected:
    HICON   m_hIcon;
public:
    EntryBase *m_entry;
    MIdOrString m_type;
    MIdOrString m_name;
    WORD m_lang;

    MReplaceIconDlg(EntryBase *entry)
        : MDialogBase(IDD_REPLACEICON), m_entry(entry),
          m_type(entry->m_type), m_name(entry->m_name), m_lang(entry->m_lang)
    {
        m_hIcon = NULL;
    }

    ~MReplaceIconDlg()
    {
        DestroyIcon(m_hIcon);
    }

    BOOL OnInitDialog(HWND hwnd, HWND hwndFocus, LPARAM lParam)
    {
        DragAcceptFiles(hwnd, TRUE);

        // for name
        HWND hCmb2 = GetDlgItem(hwnd, cmb2);
        InitResNameComboBox(hCmb2, m_entry->m_name, IDTYPE_ICON);

        // for Langs
        HWND hCmb3 = GetDlgItem(hwnd, cmb3);
        InitLangComboBox(hCmb3, m_entry->m_lang);

        CenterWindowDx();
        return TRUE;
    }

    void OnOK(HWND hwnd)
    {
        MIdOrString type = m_entry->m_type;

        MIdOrString name;
        HWND hCmb2 = GetDlgItem(hwnd, cmb2);
        if (!CheckNameComboBox(hCmb2, name))
            return;

        HWND hCmb3 = GetDlgItem(hwnd, cmb3);
        WORD lang;
        if (!CheckLangComboBox(hCmb3, lang))
            return;

        std::wstring file;
        HWND hEdt1 = GetDlgItem(hwnd, edt1);
        if (!Edt1_CheckFile(hEdt1, file))
        {
            Edit_SetSel(hEdt1, 0, -1);  // select all
            SetFocus(hEdt1);    // set focus
            ErrorBoxDx(IDS_FILENOTFOUND);
            return;
        }

        BOOL bAni = FALSE;
        size_t ich = file.find(L'.');
        if (ich != std::wstring::npos && lstrcmpiW(&file[ich], L".ani") == 0)
            bAni = TRUE;

        if (bAni)       // animation icon (*.ani)
        {
            MByteStream bs;
            if (!bs.LoadFromFile(file.c_str()) ||
                !g_res.add_lang_entry(RT_ANIICON, name, lang, bs.data()))
            {
                ErrorBoxDx(IDS_CANTREPLACEICO);
                return;
            }
        }
        else            // normal icon (*.ico)
        {
            if (auto entry = g_res.find(ET_LANG, m_type, m_name, m_lang))
                g_res.delete_entry(entry);

            if (!g_res.add_group_icon(name, lang, file))
            {
                ErrorBoxDx(IDS_CANTREPLACEICO);
                return;
            }
        }

        m_type = type;
        m_name = name;
        m_lang = lang;

        EndDialog(IDOK);
    }

    void OnPsh1(HWND hwnd)
    {
        MStringW strFile = GetDlgItemText(edt1);
        mstr_trim(strFile);

        WCHAR szFile[MAX_PATH];
        lstrcpynW(szFile, strFile.c_str(), _countof(szFile));

        OPENFILENAMEW ofn;
        ZeroMemory(&ofn, sizeof(ofn));
        ofn.lStructSize = OPENFILENAME_SIZE_VERSION_400W;
        ofn.hwndOwner = hwnd;
        ofn.lpstrFilter = MakeFilterDx(LoadStringDx(IDS_ICOFILTER));
        ofn.lpstrFile = szFile;
        ofn.nMaxFile = _countof(szFile);
        ofn.lpstrTitle = LoadStringDx(IDS_REPLACEICO);
        ofn.Flags = OFN_ENABLESIZING | OFN_EXPLORER | OFN_FILEMUSTEXIST |
            OFN_HIDEREADONLY | OFN_PATHMUSTEXIST;
        if (m_entry->m_type == RT_ANIICON)
        {
            ofn.nFilterIndex = 2;
            ofn.lpstrDefExt = L"ani";
        }
        else
        {
            ofn.nFilterIndex = 1;
            ofn.lpstrDefExt = L"ico";
        }
        if (GetOpenFileNameW(&ofn))
        {
            SetDlgItemTextW(hwnd, edt1, szFile);
            if (m_hIcon)
                DestroyIcon(m_hIcon);
            m_hIcon = ExtractIcon(GetModuleHandle(NULL), szFile, 0);
            Static_SetIcon(GetDlgItem(hwnd, ico1), m_hIcon);
        }
    }

    void OnCommand(HWND hwnd, int id, HWND hwndCtl, UINT codeNotify)
    {
        switch (id)
        {
        case IDOK:
            OnOK(hwnd);
            break;
        case IDCANCEL:
            EndDialog(IDCANCEL);
            break;
        case psh1:
            OnPsh1(hwnd);
            break;
        }
    }

    void OnDropFiles(HWND hwnd, HDROP hdrop)
    {
        WCHAR file[MAX_PATH];
        DragQueryFileW(hdrop, 0, file, _countof(file));
        SetDlgItemTextW(hwnd, edt1, file);

        if (m_hIcon)
            DestroyIcon(m_hIcon);
        m_hIcon = ExtractIcon(GetModuleHandle(NULL), file, 0);
        Static_SetIcon(GetDlgItem(hwnd, ico1), m_hIcon);
    }

    virtual INT_PTR CALLBACK
    DialogProcDx(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
    {
        switch (uMsg)
        {
            HANDLE_MSG(hwnd, WM_INITDIALOG, OnInitDialog);
            HANDLE_MSG(hwnd, WM_DROPFILES, OnDropFiles);
            HANDLE_MSG(hwnd, WM_COMMAND, OnCommand);
        }
        return DefaultProcDx();
    }
};

```

`src/MResizable.hpp`:

```hpp
// MResizable.hpp -- Win32 dynamic layout resizable window/dialog -*- C++ -*-
// This file is part of MZC4.  See file "ReadMe.txt" and "License.txt".
////////////////////////////////////////////////////////////////////////////

#ifndef MZC4_MRESIZABLE_HPP_
#define MZC4_MRESIZABLE_HPP_        4   /* Version 4 */

struct MCtrlLayout;
class MResizable;

////////////////////////////////////////////////////////////////////////////

#include "MPointSizeRect.hpp"

////////////////////////////////////////////////////////////////////////////
// layout anchors for MResizable::SetLayoutAnchor

#define mzcLA_NO_ANCHOR        MSize(-1, -1)    // don't resize
#define mzcLA_TOP_LEFT         MSize(0, 0)      // upper left
#define mzcLA_TOP_CENTER       MSize(50, 0)     // upper center
#define mzcLA_TOP_RIGHT        MSize(100, 0)    // upper right
#define mzcLA_MIDDLE_LEFT      MSize(0, 50)     // middle left
#define mzcLA_MIDDLE_CENTER    MSize(50, 50)    // middle center
#define mzcLA_MIDDLE_RIGHT     MSize(100, 50)   // middle right
#define mzcLA_BOTTOM_LEFT      MSize(0, 100)    // lower left
#define mzcLA_BOTTOM_CENTER    MSize(50, 100)   // lower center
#define mzcLA_BOTTOM_RIGHT     MSize(100, 100)  // lower right

////////////////////////////////////////////////////////////////////////////
// MResizable

#include "MScrollBar.hpp"   // for MSizeGrip
#include <vector>           // for std::vector

class MResizable
{
protected:
    struct MCtrlLayout
    {
        HWND m_hwndCtrl;
        MSize m_sizLA_1, m_sizMargin1, m_sizLA_2, m_sizMargin2;

        MCtrlLayout() = default;

        MCtrlLayout(HWND hwndCtrl, SIZE sizLA_1, SIZE sizMargin1, 
            SIZE sizLA_2, SIZE sizMargin2) : m_hwndCtrl(hwndCtrl), 
            m_sizLA_1(sizLA_1), m_sizMargin1(sizMargin1), 
            m_sizLA_2(sizLA_2), m_sizMargin2(sizMargin2)
        {
        }
    };
public:
    typedef MCtrlLayout                 layout_type;
    typedef std::vector<MCtrlLayout>    layouts_type;

    MResizable();
    virtual ~MResizable();

    // NOTE: Please call OnParentCreate after parent's WM_CREATE or WM_INITDIALOG.
    VOID OnParentCreate(HWND hwnd, BOOL bEnableResize = TRUE, 
                        BOOL bShowSizeGrip = TRUE);

    // NOTE: Please call OnSize on parent's WM_SIZE.
    VOID OnSize(const RECT *prcClient = NULL);

    // NOTE: Please call SetLayoutAnchor after OnParentCreate.
    // NOTE: sizLA_1 is upper left anchor, sizLA_2 is lower right anchor.
    VOID SetLayoutAnchor(HWND hwndCtrl, 
                         MSize sizLA_1, MSize sizLA_2 = mzcLA_NO_ANCHOR);
    VOID SetLayoutAnchor(UINT nCtrlID, 
                         MSize sizLA_1, MSize sizLA_2 = mzcLA_NO_ANCHOR);

          layout_type *CtrlLayout(HWND hwndCtrl);
          layout_type *CtrlLayout(UINT nCtrlID);
    const layout_type *CtrlLayout(HWND hwndCtrl) const;
    const layout_type *CtrlLayout(UINT nCtrlID) const;

    BOOL IsResizeEnabled() const;
    VOID EnableResize(BOOL bEnableResize, BOOL bShowSizeGrip = TRUE);
    VOID ClearLayouts();

protected:
    HWND            m_hwndParent;
    BOOL            m_bResizeEnabled;
    MSizeGrip       m_size_grip;
    layouts_type    m_layouts;

    VOID ShowSizeGrip(BOOL bShow = TRUE);
    VOID ModifyParentStyle(BOOL bEnableResize);
    VOID MoveSizeGrip();
    VOID ArrangeLayout(const RECT *prc);

private:
    // NOTE: MResizable is not copyable
    MResizable(const MResizable& rsz);
    MResizable& operator=(const MResizable& rsz);
};

////////////////////////////////////////////////////////////////////////////

inline MResizable::MResizable()
    : m_hwndParent(NULL), m_bResizeEnabled(FALSE)
{
}

inline /*virtual*/ MResizable::~MResizable()
{
}

inline VOID MResizable::ClearLayouts()
{
    m_layouts.clear();
}

inline VOID MResizable::SetLayoutAnchor(
    UINT nCtrlID, MSize sizLA_1, MSize sizLA_2/* = mzcLA_NO_ANCHOR*/)
{
    assert(m_hwndParent);
    assert(::IsWindow(m_hwndParent));
    assert(sizLA_1 != mzcLA_NO_ANCHOR);
    MResizable::SetLayoutAnchor(
        GetDlgItem(m_hwndParent, nCtrlID), sizLA_1, sizLA_2);
}

inline VOID MResizable::OnSize(const RECT *prcClient/* = NULL*/)
{
    assert(m_hwndParent);
    assert(::IsWindow(m_hwndParent));

    ArrangeLayout(prcClient);
    MoveSizeGrip();
}

inline BOOL MResizable::IsResizeEnabled() const
{
    return m_bResizeEnabled;
}

inline VOID MResizable::ShowSizeGrip(BOOL bShow/* = TRUE*/)
{
    assert(m_hwndParent);
    assert(::IsWindow(m_hwndParent));

    if (bShow)
    {
        // size grip aleady exists?
        if (!m_size_grip)
        {
            // create size grip
            MRect ClientRect;
            GetClientRect(m_hwndParent, &ClientRect);
            INT cx = ::GetSystemMetrics(SM_CXVSCROLL);
            INT cy = ::GetSystemMetrics(SM_CYHSCROLL);
            m_size_grip.CreateWindowDx(m_hwndParent, NULL, 
                WS_CHILD | WS_CLIPSIBLINGS | SBS_SIZEGRIP, 0, 
                ClientRect.right - cx, ClientRect.bottom - cy, 
                cx, cy, reinterpret_cast<HMENU>(123456789));
        }

        MoveSizeGrip();
        ShowWindow(m_size_grip, SW_SHOWNOACTIVATE);
    }
    else
    {
        if (::IsWindow(m_size_grip))
            ShowWindow(m_size_grip, SW_HIDE);
    }
}

inline VOID MResizable::MoveSizeGrip()
{
    assert(m_hwndParent);
    assert(::IsWindow(m_hwndParent));

    if (m_size_grip)
    {
        // move it
        MRect ClientRect;
        GetClientRect(m_hwndParent, &ClientRect);
        INT cx = ::GetSystemMetrics(SM_CXVSCROLL);
        INT cy = ::GetSystemMetrics(SM_CYHSCROLL);
        SetWindowPos(m_size_grip, NULL, 
            ClientRect.right - cx, ClientRect.bottom - cy, 
            cx, cy, SWP_NOACTIVATE | SWP_NOOWNERZORDER | SWP_NOZORDER);
    }
}

inline VOID MResizable::ModifyParentStyle(BOOL bEnableResize)
{
    // style
    DWORD style = ::GetWindowLong(m_hwndParent, GWL_STYLE);
    if (bEnableResize)
    {
        style &= ~DS_MODALFRAME;
        style |= WS_THICKFRAME | WS_MAXIMIZEBOX;
        SetWindowLong(m_hwndParent, GWL_STYLE, style);
    }
    else
    {
        style &= ~(WS_THICKFRAME | WS_MAXIMIZEBOX);
        style |= DS_MODALFRAME;
        SetWindowLong(m_hwndParent, GWL_STYLE, style);
    }
    // ex.style
    style = ::GetWindowLong(m_hwndParent, GWL_EXSTYLE);
    if (bEnableResize)
    {
        style &= ~WS_EX_DLGMODALFRAME;
        style |= 0;
        SetWindowLong(m_hwndParent, GWL_EXSTYLE, style);
    }
    else
    {
        style &= ~0;
        style |= WS_EX_DLGMODALFRAME;
        SetWindowLong(m_hwndParent, GWL_EXSTYLE, style);
    }
    if (bEnableResize)
    {
        GetSystemMenu(m_hwndParent, TRUE);
    }
    else
    {
        HMENU hSysMenu;
        hSysMenu = ::GetSystemMenu(m_hwndParent, FALSE);
        RemoveMenu(hSysMenu, SC_MAXIMIZE, MF_BYCOMMAND);
        RemoveMenu(hSysMenu, SC_SIZE, MF_BYCOMMAND);
        RemoveMenu(hSysMenu, SC_RESTORE, MF_BYCOMMAND);
    }
    RedrawWindow(m_hwndParent, NULL, NULL, 
                   RDW_FRAME | RDW_INVALIDATE | RDW_ERASENOW);
    InvalidateRect(m_hwndParent, NULL, TRUE);
}

inline VOID
MResizable::EnableResize(BOOL bEnableResize, BOOL bShowSizeGrip/* = TRUE*/)
{
    ShowSizeGrip(bEnableResize && bShowSizeGrip);
    ModifyParentStyle(bEnableResize);
    m_bResizeEnabled = bEnableResize;
}

inline VOID MResizable::OnParentCreate(HWND hwndParent, BOOL bEnableResize, 
                                       BOOL bShowSizeGrip/* = TRUE*/)
{
    assert(hwndParent);
    assert(::IsWindow(hwndParent));

    m_hwndParent = hwndParent;

    ClearLayouts();

    // NOTE: The parent window must have initially WS_THICKFRAME style.
    assert(::GetWindowLong(hwndParent, GWL_STYLE) & WS_THICKFRAME);

    EnableResize(bEnableResize, bShowSizeGrip);
}

inline VOID MResizable::ArrangeLayout(const RECT *prc)
{
    assert(m_hwndParent);
    assert(::IsWindow(m_hwndParent));

    MRect ClientRect;
    if (prc)
    {
        ClientRect = *prc;
    }
    else
    {
        GetClientRect(m_hwndParent, &ClientRect);
    }

    const UINT count = UINT(m_layouts.size());
    if (count == 0)
        return;

    HDWP hDwp = ::BeginDeferWindowPos(count);
    if (hDwp == NULL)
        return;

    const UINT uFlags = SWP_NOZORDER | SWP_NOACTIVATE | SWP_NOREPOSITION;
    for (UINT i = 0; i < count; ++i)
    {
        const layout_type& layout = m_layouts[i];
        HWND hwndCtrl = layout.m_hwndCtrl;
        if (!::IsWindow(hwndCtrl))
            continue;

        MRect ChildRect, NewRect;

        GetWindowRect(hwndCtrl, &ChildRect);
        MapWindowPoints(NULL, m_hwndParent, 
                          reinterpret_cast<LPPOINT>(&ChildRect), 2);

        NewRect.left = layout.m_sizMargin1.cx +
                       ClientRect.Width() * layout.m_sizLA_1.cx / 100;
        NewRect.top = layout.m_sizMargin1.cy +
                      ClientRect.Height() * layout.m_sizLA_1.cy / 100;
        NewRect.right = layout.m_sizMargin2.cx +
                        ClientRect.Width() * layout.m_sizLA_2.cx / 100;
        NewRect.bottom = layout.m_sizMargin2.cy +
                         ClientRect.Height() * layout.m_sizLA_2.cy / 100;

        if (NewRect != ChildRect)
        {
            hDwp = ::DeferWindowPos(hDwp, hwndCtrl, NULL, 
                NewRect.left, NewRect.top, 
                NewRect.Width(), NewRect.Height(), uFlags);
        }

        InvalidateRect(hwndCtrl, NULL, TRUE);
    }

    EndDeferWindowPos(hDwp);
}

inline VOID MResizable::SetLayoutAnchor(
    HWND hwndCtrl, MSize sizLA_1, MSize sizLA_2/* = mzcLA_NO_ANCHOR*/)
{
    assert(m_hwndParent);
    assert(::IsWindow(m_hwndParent));
    assert(sizLA_1 != mzcLA_NO_ANCHOR);

    MRect ClientRect, ChildRect;
    GetClientRect(m_hwndParent, &ClientRect);
    GetWindowRect(hwndCtrl, &ChildRect);
    MapWindowPoints(NULL, m_hwndParent, 
                    reinterpret_cast<LPPOINT>(&ChildRect), 2);

    if (sizLA_2 == mzcLA_NO_ANCHOR)
        sizLA_2 = sizLA_1;

    MSize sizMargin1, sizMargin2;
    sizMargin1.cx = ChildRect.left - ClientRect.Width() * sizLA_1.cx / 100;
    sizMargin1.cy = ChildRect.top - ClientRect.Height() * sizLA_1.cy / 100;
    sizMargin2.cx = ChildRect.right - ClientRect.Width() * sizLA_2.cx / 100;
    sizMargin2.cy = ChildRect.bottom - ClientRect.Height() * sizLA_2.cy / 100;

    // search hwndCtrl
    layout_type *pLayout = CtrlLayout(hwndCtrl);
    if (pLayout)
        return;

    // if not found
    layout_type layout(hwndCtrl, sizLA_1, sizMargin1, sizLA_2, sizMargin2);
    m_layouts.push_back(layout);
}

inline MResizable::layout_type *MResizable::CtrlLayout(HWND hwndCtrl)
{
    const UINT count = UINT(m_layouts.size());
    for (UINT i = 0; i < count; ++i)
    {
        if (m_layouts[i].m_hwndCtrl == hwndCtrl)
            return &m_layouts[i];
    }
    return NULL;
}

inline MResizable::layout_type *MResizable::CtrlLayout(UINT nCtrlID)
{
    HWND hwndCtrl = ::GetDlgItem(m_hwndParent, nCtrlID);
    const UINT count = UINT(m_layouts.size());
    for (UINT i = 0; i < count; ++i)
    {
        if (m_layouts[i].m_hwndCtrl == hwndCtrl)
            return &m_layouts[i];
    }
    return NULL;
}

inline const MResizable::layout_type *MResizable::CtrlLayout(HWND hwndCtrl) const
{
    const UINT count = UINT(m_layouts.size());
    for (UINT i = 0; i < count; ++i)
    {
        if (m_layouts[i].m_hwndCtrl == hwndCtrl)
            return &m_layouts[i];
    }
    return NULL;
}

inline const MResizable::layout_type *MResizable::CtrlLayout(UINT nCtrlID) const
{
    HWND hwndCtrl = ::GetDlgItem(m_hwndParent, nCtrlID);
    const UINT count = UINT(m_layouts.size());
    for (UINT i = 0; i < count; ++i)
    {
        if (m_layouts[i].m_hwndCtrl == hwndCtrl)
            return &m_layouts[i];
    }
    return NULL;
}

////////////////////////////////////////////////////////////////////////////

#endif  // ndef MZC4_MRESIZABLE_HPP_

```

`src/MRubberBand.hpp`:

```hpp
// MRubberBand.hpp -- Rubber Band for Win32
//////////////////////////////////////////////////////////////////////////////
// RisohEditor --- Another free Win32 resource editor
// Copyright (C) 2017-2018 Katayama Hirofumi MZ <katayama.hirofumi.mz@gmail.com>
// 
// This program is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
// 
// This program is distributed in the hope that it will be useful, 
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
// 
// You should have received a copy of the GNU General Public License
// along with this program.  If not, see <http://www.gnu.org/licenses/>.
//////////////////////////////////////////////////////////////////////////////

#ifndef MZC4_RUBBER_BAND_HPP_
#define MZC4_RUBBER_BAND_HPP_       5   // Version 5

class MRubberBand;

#include "MWindowBase.hpp"

//////////////////////////////////////////////////////////////////////////////

#ifndef MYWM_SELCHANGE
    #define MYWM_SELCHANGE      (WM_USER + 102)
#endif

class MRubberBand : public MWindowBase
{
public:
    DWORD m_dwMagic;                // for sanity check
    HRGN m_hRgn;                    // the window region
    HWND m_hwndTarget;              // the target
    enum { m_nGripSize = 3 };       // the grip size

    // constructor
    MRubberBand() : m_dwMagic(0x20110311), m_hRgn(NULL), m_hwndTarget(NULL)
    {
    }

    // get the associated rubber band from a window
    static MRubberBand* GetRubberBand(HWND hwnd)
    {
        auto base = GetUserData(hwnd);
        if (base)
        {
            auto pBand = static_cast<MRubberBand *>(base);
            if (pBand->m_dwMagic == 0x20110311)
                return pBand;
        }
        return NULL;
    }

    // create
    BOOL CreateDx(HWND hwndParent, HWND hwndTarget, BOOL bVisible = FALSE, 
                  INT x = 0, INT y = 0, INT cx = 0, INT cy = 0)
    {
        m_hwndTarget = hwndTarget;

        // create as a child
        DWORD style = (bVisible ? WS_VISIBLE : 0) | WS_CHILD | WS_THICKFRAME;
        DWORD exstyle = WS_EX_TOOLWINDOW | WS_EX_TOPMOST;
        BOOL bOK = CreateAsChildDx(hwndParent, NULL, style, exstyle, -1, 
                                   x, y, cx, cy);
        if (bOK)
        {
            // fit to the target
            FitToTarget();

            // send MYWM_SELCHANGE to the parent
            PostMessage(hwndParent, MYWM_SELCHANGE, 0, 0);
        }

        return bOK;
    }

    // get the target
    HWND GetTarget() const
    {
        return m_hwndTarget;
    }

    // called after WM_NCDESTROY
    virtual void PostNcDestroy()
    {
        MWindowBase::PostNcDestroy();
        delete this;
    }

    // the window procedure of MRubberBand
    virtual LRESULT CALLBACK
    WindowProcDx(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
    {
        switch (uMsg)
        {
            HANDLE_MSG(hwnd, WM_MOVE, OnMove);
            HANDLE_MSG(hwnd, WM_SIZE, OnSize);
            HANDLE_MSG(hwnd, WM_NCCALCSIZE, OnNCCalcSize);
            HANDLE_MSG(hwnd, WM_NCPAINT, OnNCPaint);
            HANDLE_MSG(hwnd, WM_PAINT, OnPaint);
            HANDLE_MSG(hwnd, WM_DESTROY, OnDestroy);
            HANDLE_MSG(hwnd, WM_NCHITTEST, OnNCHitTest);
            HANDLE_MSG(hwnd, WM_SETCURSOR, OnSetCursor);
        default:
            return DefaultProcDx(hwnd, uMsg, wParam, lParam);
        }
    }

    // get the ideal client rectangle
    void GetIdealClientRect(LPRECT prc)
    {
        GetClientRect(m_hwnd, prc);
        InflateRect(prc, -2 * m_nGripSize, -2 * m_nGripSize);
    }

    // adjust the target to this rubber band
    void FitToBand()
    {
        if (m_hwndTarget == NULL)
            return;     // no target

        // get the ideal rectangle in the parent coordinates
        RECT rc;
        GetIdealClientRect(&rc);
        MapWindowRect(m_hwnd, GetParent(m_hwndTarget), &rc);

        // move it
        SetWindowPos(m_hwndTarget, NULL, 
            rc.left, rc.top, rc.right - rc.left, rc.bottom - rc.top, 
            SWP_NOACTIVATE | SWP_NOZORDER | SWP_NOCOPYBITS);

        // redraw
        InvalidateRect(m_hwnd, NULL, TRUE);
    }

    // adjust the rubber band's posision and size for the target
    void FitToTarget()
    {
        if (m_hwndTarget == NULL)
            return;     // not target

        // get the target rectangle in the parent coordinates
        RECT rc;
        GetWindowRect(m_hwndTarget, &rc);
        MapWindowRect(NULL, GetParent(m_hwnd), &rc);

        // expand the rectangle by the m_nGripSize
        InflateRect(&rc, 2 * m_nGripSize, 2 * m_nGripSize);

        // move it
        SetWindowPos(m_hwnd, NULL, 
            rc.left, rc.top, rc.right - rc.left, rc.bottom - rc.top, 
            SWP_NOACTIVATE | SWP_NOZORDER | SWP_NOCOPYBITS);

        // redraw
        InvalidateRect(m_hwnd, NULL, TRUE);
    }

    // MRubberBand WM_DESTROY
    void OnDestroy(HWND hwnd)
    {
        // notity MYWM_SELCHANGE to the parent
        PostMessage(GetParent(hwnd), MYWM_SELCHANGE, 0, 0);

        // delete the region
        DeleteObject(m_hRgn);
        m_hRgn = NULL;

        // reset m_hwndTarget
        m_hwndTarget = NULL;
    }

    // get the rectangle
    void GetRect(HWND hwnd, LPRECT prc)
    {
        GetWindowRect(hwnd, prc);

        // NOTE: The coordinates of the window region are relative to the upper left corner of the window rectangle.
        OffsetRect(prc, -prc->left, -prc->top);
        assert(prc->left == 0 && prc->top == 0);
    }

    // set the region
    void SetRgn(HRGN hRgn, BOOL bClient = TRUE)
    {
        DeleteObject(m_hRgn);
        SetWindowRgn(m_hwnd, hRgn, TRUE);
        m_hRgn = hRgn;
    }

    // MRubberBand WM_NCPAINT
    void OnNCPaint(HWND hwnd, HRGN hrgn)
    {
        // get the rectangle
        RECT rc;
        GetRect(hwnd, &rc);

        // get the window DC
        if (HDC hDC = GetWindowDC(hwnd))
        {
            HPEN hPenOld = SelectPen(hDC, GetStockPen(BLACK_PEN));
            HBRUSH hbrOld = SelectBrush(hDC, GetStockBrush(WHITE_BRUSH));
            {
                // draw
                GetRgnOrDrawOrHitTest(hwnd, hDC, NULL);
            }
            SelectBrush(hDC, hbrOld);
            SelectPen(hDC, hPenOld);

            // release the window DC
            ReleaseDC(hwnd, hDC);
        }
    }

    // MRubberBand WM_PAINT
    void OnPaint(HWND hwnd)
    {
        // no client drawing
        PAINTSTRUCT ps;
        BeginPaint(hwnd, &ps);
        EndPaint(hwnd, &ps);
    }

    // MRubberBand WM_NCHITTEST
    UINT OnNCHitTest(HWND hwnd, int x, int y)
    {
        RECT rc;
        GetWindowRect(hwnd, &rc);
        x -= rc.left;
        y -= rc.top;

        // do hittest
        POINT pt = { x, y };
        HRGN hRgn = GetRgnOrDrawOrHitTest(hwnd, NULL, &pt);
        return (UINT)(UINT_PTR)hRgn;
    }

    // MRubberBand WM_SETCURSOR
    BOOL OnSetCursor(HWND hwnd, HWND hwndCursor, UINT codeHitTest, UINT msg)
    {
        switch (codeHitTest)
        {
        case HTTOPLEFT:         SetCursor(LoadCursor(NULL, IDC_SIZENWSE)); break;
        case HTLEFT:            SetCursor(LoadCursor(NULL, IDC_SIZEWE)); break;
        case HTBOTTOMLEFT:      SetCursor(LoadCursor(NULL, IDC_SIZENESW)); break;
        case HTTOP:             SetCursor(LoadCursor(NULL, IDC_SIZENS)); break;
        case HTBOTTOM:          SetCursor(LoadCursor(NULL, IDC_SIZENS)); break;
        case HTTOPRIGHT:        SetCursor(LoadCursor(NULL, IDC_SIZENESW)); break;
        case HTRIGHT:           SetCursor(LoadCursor(NULL, IDC_SIZEWE)); break;
        case HTBOTTOMRIGHT:     SetCursor(LoadCursor(NULL, IDC_SIZENWSE)); break;
        default:                SetCursor(LoadCursor(NULL, IDC_ARROW)); break;
        }
        return TRUE;
    }

    // MRubberBand WM_MOVE
    void OnMove(HWND hwnd, int x, int y)
    {
        HRGN hRgn;

        if (m_hwnd && m_hwndTarget)
        {
            // adjust the target to the band
            FitToBand();
        }

        // create and set the region
        hRgn = GetRgnOrDrawOrHitTest(hwnd);
        SetRgn(hRgn, TRUE);
    }

    // MRubberBand WM_SIZE
    void OnSize(HWND hwnd, UINT state, int cx, int cy)
    {
        // adjust the target to the band
        if (m_hwndTarget)
        {
            FitToBand();
        }

        // create and set the region
        HRGN hRgn = GetRgnOrDrawOrHitTest(hwnd);
        SetRgn(hRgn);

        // redraw
        InvalidateRect(hwnd, NULL, TRUE);
    }

    // get region, draw, or do hittest
    HRGN GetRgnOrDrawOrHitTest(HWND hwnd, HDC hDC = NULL, LPPOINT ppt = NULL)
    {
        RECT rc;
        GetRect(hwnd, &rc);

        // the size
        INT cx = rc.right - rc.left;
        INT cy = rc.bottom - rc.top;

        INT ax[] = { m_nGripSize, cx / 2, cx - m_nGripSize };
        INT ay[] = { m_nGripSize, cy / 2, cy - m_nGripSize };
        INT ahits[] =
        {
            HTTOPLEFT,    HTTOP,    HTTOPRIGHT, 
            HTLEFT,                 HTRIGHT, 
            HTBOTTOMLEFT, HTBOTTOM, HTBOTTOMRIGHT
        };

        // if hDC == NULL && ppt == NULL, then create the region
        HRGN hRgn = NULL;
        if (hDC == NULL && ppt == NULL)
            hRgn = CreateRectRgn(0, 0, 0, 0);

        for (INT k = 0, n = 0; k < 3; ++k)
        {
            for (INT i = 0; i < 3; ++i)
            {
                if (i == 1 && k == 1)
                    continue;

                if (hDC)
                {
                    // draw if hDC is non-null
                    Rectangle(hDC, 
                        ax[i] - m_nGripSize, ay[k] - m_nGripSize, 
                        ax[i] + m_nGripSize, ay[k] + m_nGripSize);
                }
                else if (ppt)
                {
                    // do hittest if ppt is non-null
                    RECT rect;
                    SetRect(&rect, 
                        ax[i] - m_nGripSize, ay[k] - m_nGripSize, 
                        ax[i] + m_nGripSize, ay[k] + m_nGripSize);
                    if (PtInRect(&rect, *ppt))
                    {
                        return (HRGN)(INT_PTR)ahits[n];
                    }
                }
                else
                {
                    // otherwise update the region
                    HRGN hRgn2 = CreateRectRgn(
                        ax[i] - m_nGripSize, ay[k] - m_nGripSize, 
                        ax[i] + m_nGripSize, ay[k] + m_nGripSize);
                    UnionRgn(hRgn, hRgn, hRgn2);
                    DeleteObject(hRgn2);
                }
                ++n;
            }
        }

        // return the hittest value if ppt is non-null
        if (ppt)
        {
            return (HRGN)(INT_PTR)HTCAPTION;
        }

        return hRgn;
    }

    // the window class name of MRubberBand
    virtual LPCTSTR GetWndClassNameDx() const
    {
        return TEXT("katahiromz's Rubber Band Class");
    }

    virtual void ModifyWndClassDx(WNDCLASSEX& wcx)
    {
        // no class icon
        wcx.hIcon = NULL;
        wcx.hIconSm = NULL;

        // no background brush
        wcx.hbrBackground = GetStockBrush(NULL_BRUSH);
    }

    // MRubberBand WM_NCCALCSIZE
    UINT OnNCCalcSize(HWND hwnd, BOOL fCalcValidRects, NCCALCSIZE_PARAMS *lpcsp)
    {
        // no non-client area
        return WVR_VALIDRECTS | WVR_REDRAW;
    }
};

//////////////////////////////////////////////////////////////////////////////

#endif  // ndef MZC4_RUBBER_BAND_HPP_

```

`src/MSaveOptionsDlg.hpp`:

```hpp
// MSaveOptionsDlg.hpp --- "Save Options" Dialog
//////////////////////////////////////////////////////////////////////////////
// RisohEditor --- Another free Win32 resource editor
// Copyright (C) 2017-2018 Katayama Hirofumi MZ <katayama.hirofumi.mz@gmail.com>
// 
// This program is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
// 
// This program is distributed in the hope that it will be useful, 
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
// 
// You should have received a copy of the GNU General Public License
// along with this program.  If not, see <http://www.gnu.org/licenses/>.
//////////////////////////////////////////////////////////////////////////////

#pragma once

#include "resource.h"
#include "MWindowBase.hpp"
#include "RisohSettings.hpp"

//////////////////////////////////////////////////////////////////////////////

class MSaveOptionsDlg : public MDialogBase
{
public:
    MSaveOptionsDlg() : MDialogBase(IDD_SAVE_OPTIONS)
    {
    }

    void Reload(HWND hwnd)
    {
        CheckDlgButton(hwnd, chx1, g_settings.bSepFilesByLang ? BST_CHECKED : BST_UNCHECKED);
        CheckDlgButton(hwnd, chx2, g_settings.bUseBeginEnd ? BST_CHECKED : BST_UNCHECKED);
        CheckDlgButton(hwnd, chx3, g_settings.bSelectableByMacro ? BST_CHECKED : BST_UNCHECKED);
        CheckDlgButton(hwnd, chx4, g_settings.bBackup ? BST_CHECKED : BST_UNCHECKED);
        CheckDlgButton(hwnd, chx5, g_settings.bRedundantComments ? BST_CHECKED : BST_UNCHECKED);
        CheckDlgButton(hwnd, chx6, g_settings.bWrapManifest ? BST_CHECKED : BST_UNCHECKED);
        CheckDlgButton(hwnd, chx7, g_settings.bRCFileUTF16 ? BST_CHECKED : BST_UNCHECKED);
        CheckDlgButton(hwnd, chx8, g_settings.bUseMSMSGTABLE ? BST_CHECKED : BST_UNCHECKED);

        SendDlgItemMessageW(hwnd, cmb1, CB_ADDSTRING, 0, (LPARAM)L"-old");
        SendDlgItemMessageW(hwnd, cmb1, CB_ADDSTRING, 0, (LPARAM)L"-bak");
        SendDlgItemMessageW(hwnd, cmb1, CB_ADDSTRING, 0, (LPARAM)L"~");
        SetDlgItemTextW(hwnd, cmb1, g_settings.strBackupSuffix.c_str());
    }

    BOOL OnInitDialog(HWND hwnd, HWND hwndFocus, LPARAM lParam)
    {
        Reload(hwnd);

        CenterWindowDx();
        return TRUE;
    }

    void OnOK(HWND hwnd)
    {
        g_settings.bSepFilesByLang = (IsDlgButtonChecked(hwnd, chx1) == BST_CHECKED);
        g_settings.bUseBeginEnd = (IsDlgButtonChecked(hwnd, chx2) == BST_CHECKED);
        g_settings.bSelectableByMacro = (IsDlgButtonChecked(hwnd, chx3) == BST_CHECKED);
        g_settings.bBackup = (IsDlgButtonChecked(hwnd, chx4) == BST_CHECKED);
        g_settings.bRedundantComments = (IsDlgButtonChecked(hwnd, chx5) == BST_CHECKED);
        g_settings.bWrapManifest = (IsDlgButtonChecked(hwnd, chx6) == BST_CHECKED);
        g_settings.bRCFileUTF16 = (IsDlgButtonChecked(hwnd, chx7) == BST_CHECKED);
        g_settings.bUseMSMSGTABLE = (IsDlgButtonChecked(hwnd, chx8) == BST_CHECKED);

        WCHAR szText[32];
        GetDlgItemTextW(hwnd, cmb1, szText, _countof(szText));
        mstr_trim(szText);
        g_settings.strBackupSuffix = szText;

        if (szText[0] == 0)
            g_settings.bBackup = FALSE;

        EndDialog(IDOK);
    }

    void OnCommand(HWND hwnd, int id, HWND hwndCtl, UINT codeNotify)
    {
        switch (id)
        {
        case IDOK:
            OnOK(hwnd);
            break;
        case IDCANCEL:
            EndDialog(hwnd, IDCANCEL);
            break;
        }
    }

    virtual INT_PTR CALLBACK
    DialogProcDx(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
    {
        switch (uMsg)
        {
            DO_MSG(WM_INITDIALOG, OnInitDialog);
            DO_MSG(WM_COMMAND, OnCommand);
        }
        return DefaultProcDx();
    }
};

```

`src/MScrollBar.hpp`:

```hpp
// MScrollBar.hpp -- Win32API scroll bar wrapper -*- C++ -*-
// This file is part of MZC4.  See file "ReadMe.txt" and "License.txt".
////////////////////////////////////////////////////////////////////////////

#ifndef MZC4_MSCROLLBAR_HPP_
#define MZC4_MSCROLLBAR_HPP_        2   /* Version 2 */

class MScrollBar;
//class MSizeGrip;

////////////////////////////////////////////////////////////////////////////

#include "MWindowBase.hpp"

#define MSCROLLBAR_HSCROLL_STYLE \
    (WS_CHILD | WS_VISIBLE | SBS_HORZ)
#define MSCROLLBAR_VSCROLL_STYLE \
    (WS_CHILD | WS_VISIBLE | SBS_VERT)

class MScrollBar : public MWindowBase
{
public:
    MScrollBar();

    virtual LPCTSTR GetWndClassNameDx() const;

    INT GetScrollPos() const;
    INT SetScrollPos(INT nPos, BOOL bRedraw = TRUE);

    VOID GetScrollRange(LPINT lpMinPos, LPINT lpMaxPos) const;
    VOID SetScrollRange(INT nMinPos, INT nMaxPos, BOOL bRedraw = TRUE);

    VOID ShowScrollBar(BOOL bShow = TRUE);

    BOOL EnableScrollBar(UINT nArrowFlags = ESB_ENABLE_BOTH);

    BOOL GetScrollInfo(LPSCROLLINFO lpScrollInfo, UINT nSIF_mask = SIF_ALL);
    BOOL SetScrollInfo(LPSCROLLINFO lpScrollInfo, BOOL bRedraw = TRUE);

    INT GetScrollLimit();

    static INT GetHScrollWidth();
    static INT GetHScrollHeight();
    static INT GetVScrollWidth();
    static INT GetVScrollHeight();
    static INT GetHThumbWidth();
    static INT GetVThumbHeight();
};
typedef MScrollBar MSizeGrip;

UINT GetMouseScrollLinesDx(VOID);

////////////////////////////////////////////////////////////////////////////

inline MScrollBar::MScrollBar()
{
}

inline /*virtual*/ LPCTSTR MScrollBar::GetWndClassNameDx() const
{
    return TEXT("SCROLLBAR");
}

inline INT MScrollBar::GetScrollPos() const
{
    return ::GetScrollPos(m_hwnd, SB_CTL);
}

inline INT MScrollBar::SetScrollPos(INT nPos, BOOL bRedraw/* = TRUE*/)
{
    return ::SetScrollPos(m_hwnd, SB_CTL, nPos, bRedraw);
}

inline VOID MScrollBar::GetScrollRange(
    LPINT lpMinPos, LPINT lpMaxPos) const
{
    ::GetScrollRange(m_hwnd, SB_CTL, lpMinPos, lpMaxPos);
}

inline VOID MScrollBar::SetScrollRange(
    INT nMinPos, INT nMaxPos, BOOL bRedraw/* = TRUE*/)
{
    ::SetScrollRange(m_hwnd, SB_CTL, nMinPos, nMaxPos, bRedraw);
}

inline VOID MScrollBar::ShowScrollBar(BOOL bShow/* = TRUE*/)
{
    ::ShowScrollBar(m_hwnd, SB_CTL, bShow);
}

inline BOOL MScrollBar::EnableScrollBar(
    UINT nArrowFlags/* = ESB_ENABLE_BOTH*/)
{
    return ::EnableScrollBar(m_hwnd, SB_CTL, nArrowFlags);
}

inline BOOL MScrollBar::SetScrollInfo(
    LPSCROLLINFO lpScrollInfo, BOOL bRedraw/* = TRUE*/)
{
    return ::SetScrollInfo(m_hwnd, SB_CTL, lpScrollInfo, bRedraw);
}

inline BOOL MScrollBar::GetScrollInfo(
    LPSCROLLINFO lpScrollInfo, UINT nSIF_mask/* = SIF_ALL*/)
{
    lpScrollInfo->fMask = nSIF_mask;
    return ::GetScrollInfo(m_hwnd, SB_CTL, lpScrollInfo);
}

inline INT MScrollBar::GetScrollLimit()
{
    INT nMin, nMax;
    ::GetScrollRange(m_hwnd, SB_CTL, &nMin, &nMax);

    SCROLLINFO info;
    info.cbSize = sizeof(SCROLLINFO);
    info.fMask = SIF_PAGE;
    if(::GetScrollInfo(m_hwnd, SB_CTL, &info))
        nMax -= ((info.nPage - 1) > 0) ? (info.nPage - 1) : 0;
    return nMax;
}

inline /*static*/ INT MScrollBar::GetHThumbWidth()
{
    return ::GetSystemMetrics(SM_CXHTHUMB);
}

inline /*static*/ INT MScrollBar::GetVThumbHeight()
{
    return ::GetSystemMetrics(SM_CYVTHUMB);
}

inline /*static*/ INT MScrollBar::GetHScrollWidth()
{
    return ::GetSystemMetrics(SM_CXHSCROLL);
}

inline /*static*/ INT MScrollBar::GetHScrollHeight()
{
    return ::GetSystemMetrics(SM_CYHSCROLL);
}

inline /*static*/ INT MScrollBar::GetVScrollWidth()
{
    return ::GetSystemMetrics(SM_CXVSCROLL);
}

inline /*static*/ INT MScrollBar::GetVScrollHeight()
{
    return ::GetSystemMetrics(SM_CYVSCROLL);
}

inline UINT GetMouseScrollLinesDx(VOID)
{
    static BOOL s_bGot = FALSE;
    static UINT s_uCachedScrollLines;

    if (s_bGot)
        return s_uCachedScrollLines;

#if (_WIN32_WINNT >= 0x0400) || (_WIN32_WINDOWS > 0x0400)
    s_bGot = ::SystemParametersInfo(SPI_GETWHEELSCROLLLINES, 0, 
        &s_uCachedScrollLines, 0);
    if (s_bGot)
        return s_uCachedScrollLines;
#endif  // (_WIN32_WINNT >= 0x0400) || (_WIN32_WINDOWS > 0x0400)

    s_bGot = TRUE;
    HWND hwMouseWheel = ::FindWindow(TEXT("MouseZ"), TEXT("Magellan MSWHEEL"));
    UINT uMsg = ::RegisterWindowMessage(TEXT("MSH_SCROLL_LINES_MSG"));
    if (hwMouseWheel != NULL && uMsg != 0)
    {
        s_uCachedScrollLines = (UINT)::SendMessage(hwMouseWheel, uMsg, 0, 0);
        return s_uCachedScrollLines;
    }

    s_uCachedScrollLines = 3; // reasonable default
    HKEY hKey;
    if (::RegOpenKeyEx(HKEY_CURRENT_USER,  TEXT("Control Panel\\Desktop"), 
                       0, KEY_QUERY_VALUE, &hKey) == ERROR_SUCCESS)
    {
        TCHAR szData[128];
        DWORD dwKeyDataType;
        DWORD dwDataBufSize = sizeof(szData);

        if (::RegQueryValueEx(hKey, TEXT("WheelScrollLines"), NULL, 
            &dwKeyDataType, (LPBYTE)&szData, &dwDataBufSize) == ERROR_SUCCESS)
        {
            s_uCachedScrollLines = (UINT) _ttoi(szData);
        }
        RegCloseKey(hKey);
    }

    return s_uCachedScrollLines;
}

////////////////////////////////////////////////////////////////////////////

#endif  // ndef MZC4_MSCROLLBAR_HPP_

```

`src/MSplitterWnd.hpp`:

```hpp
// MSplitterWnd.hpp --- MZC4 splitter window                    -*- C++ -*-
// This file is part of MZC4.  See file "ReadMe.txt" and "License.txt".
//////////////////////////////////////////////////////////////////////////////

#ifndef MZC4_MSPLITTERWND_HPP_
#define MZC4_MSPLITTERWND_HPP_      9   /* Version 9 */

class MSplitterWnd;

//////////////////////////////////////////////////////////////////////////////

#include "MWindowBase.hpp"
#include <vector>

// The styles of MSplitterWnd
#define SWS_HORZ            0
#define SWS_VERT            1
#define SWS_LEFTALIGN       0
#define SWS_TOPALIGN        0
#define SWS_RIGHTALIGN      2
#define SWS_BOTTOMALIGN     2

class MSplitterWnd : public MWindowBase
{
public:
    enum { m_cxyBorder = 4, m_cxyMin = 8 };
    enum { NOTIFY_CHANGED = 0x2934 };

    MSplitterWnd() : m_iDraggingBorder(-1), m_nPaneCount(0)
    {
        m_vecPanes.resize(1);
    }

    BOOL CreateDx(HWND hwndParent, INT nPaneCount = 2, 
                  DWORD dwStyle = WS_CHILD | WS_VISIBLE | SWS_HORZ | SWS_LEFTALIGN, 
                  DWORD dwExStyle = 0)
    {
        RECT rc;
        GetClientRect(hwndParent, &rc);

        if (!CreateWindowDx(hwndParent, NULL, dwStyle, dwExStyle, 
                            rc.left, rc.top, 
                            rc.right - rc.left, rc.bottom - rc.top))
        {
            return FALSE;
        }

        SetPaneCount(nPaneCount);
        PostMessageDx(WM_SIZE);
        return TRUE;
    }

    BOOL IsHorizontal() const
    {
        return !IsVertical();
    }
    BOOL IsVertical() const
    {
        return (GetStyleDx() & SWS_VERT) == SWS_VERT;
    }
    BOOL IsRightBottomAlign() const
    {
        return (GetStyleDx() & SWS_RIGHTALIGN) == SWS_RIGHTALIGN;
    }

    INT GetPaneCount() const
    {
        return m_nPaneCount;
    }
    VOID SetPaneCount(INT nCount)
    {
        m_vecPanes.resize(nCount + 1);
        m_nPaneCount = nCount;
        SplitEqually();
    }

    HWND GetPane(INT nIndex) const
    {
        assert(0 <= nIndex && nIndex < m_nPaneCount);
        return m_vecPanes[nIndex].hwndPane;
    }
    VOID SetPane(INT nIndex, HWND hwndPane)
    {
        if (m_nPaneCount == 0)
            return;

        assert(0 <= nIndex && nIndex < m_nPaneCount);
        m_vecPanes[nIndex].hwndPane = hwndPane;
    }

    INT GetPanePos(INT nIndex) const
    {
        assert(0 <= nIndex && nIndex <= m_nPaneCount);
        return m_vecPanes[nIndex].xyPos;
    }
    VOID SetPanePos(INT nIndex, INT nPos, BOOL bBounded = TRUE)
    {
        if (m_nPaneCount == 0)
            return;

        assert(0 <= nIndex && nIndex <= m_nPaneCount);
        if (nIndex == 0)
            return;

        if (bBounded)
        {
            if (nIndex < m_nPaneCount)
            {
                const PANEINFO& info = m_vecPanes[nIndex];
                const PANEINFO& next_info = m_vecPanes[nIndex + 1];
                if (next_info.xyPos < nPos + info.cxyMin)
                    nPos = next_info.xyPos - info.cxyMin;
            }

            const PANEINFO& prev_info = m_vecPanes[nIndex - 1];
            if (nPos < prev_info.xyPos + prev_info.cxyMin)
                nPos = prev_info.xyPos + prev_info.cxyMin;
        }

        m_vecPanes[nIndex].xyPos = nPos;
    }

    INT GetPaneExtent(INT nIndex) const
    {
        assert(0 <= nIndex && nIndex < m_nPaneCount);
        return m_vecPanes[nIndex + 1].xyPos - m_vecPanes[nIndex].xyPos;
    }

    VOID SetPaneExtent(INT nIndex, INT cxy, BOOL bUpdate = TRUE)
    {
        if (m_nPaneCount == 0)
            return;

        assert(0 <= nIndex && nIndex < m_nPaneCount);
        if (nIndex == m_nPaneCount - 1)
        {
            SetPanePos(nIndex, m_vecPanes[m_nPaneCount].xyPos - cxy);
        }
        else
        {
            SetPanePos(nIndex + 1, m_vecPanes[nIndex].xyPos + cxy);
        }
        UpdatePanes();
    }

    VOID SetPaneMinExtent(INT nIndex, INT cxyMin = MSplitterWnd::m_cxyMin)
    {
        if (m_nPaneCount == 0)
            return;

        assert(0 <= nIndex && nIndex < m_nPaneCount);
        m_vecPanes[nIndex].cxyMin = cxyMin;
    }

    INT GetTotalMinExtent() const
    {
        INT cxy = 0;
        for (INT i = 0; i < m_nPaneCount; ++i)
        {
            cxy += m_vecPanes[i].cxyMin;
        }
        return cxy;
    }

    VOID GetPaneRect(INT nIndex, RECT *prc) const
    {
        assert(0 <= nIndex && nIndex < m_nPaneCount);
        GetClientRect(m_hwnd, prc);
        if (IsVertical())
        {
            prc->top = m_vecPanes[nIndex].xyPos;
            prc->bottom = m_vecPanes[nIndex + 1].xyPos;
            if (nIndex < m_nPaneCount - 1)
                prc->bottom -= m_cxyBorder;
        }
        else
        {
            prc->left = m_vecPanes[nIndex].xyPos;
            prc->right = m_vecPanes[nIndex + 1].xyPos;
            if (nIndex < m_nPaneCount - 1)
                prc->right -= m_cxyBorder;
        }
    }

    INT HitTestBorder(POINT ptClient) const
    {
        RECT rcClient;
        GetClientRect(m_hwnd, &rcClient);
        if (!::PtInRect(&rcClient, ptClient))
            return -1;

        INT xy = (IsVertical() ? ptClient.y : ptClient.x);
        for (INT i = 1; i < m_nPaneCount; ++i)
        {
            INT xyPos = m_vecPanes[i].xyPos;
            if (xyPos - m_cxyBorder <= xy && xy <= xyPos)
            {
                return i;
            }
        }
        return -1;
    }

    void SplitEqually()
    {
        if (m_nPaneCount == 0)
            return;

        RECT rc;
        GetClientRect(m_hwnd, &rc);

        INT cxy = (IsVertical() ? rc.bottom : rc.right);
        INT xy = 0, cxyPane = cxy / m_nPaneCount;
        for (INT i = 0; i < m_nPaneCount; ++i)
        {
            m_vecPanes[i].xyPos = xy;
            xy += cxyPane;
        }
        m_vecPanes[m_nPaneCount].xyPos = cxy;
        PostMessageDx(WM_SIZE);
    }

    void UpdatePanes()
    {
        RECT rc;
        HDWP hDWP = BeginDeferWindowPos(m_nPaneCount);
        for (INT i = 0; i < m_nPaneCount; ++i)
        {
            const PANEINFO *pInfo = &m_vecPanes[i];
            HWND hwndPane = pInfo->hwndPane;
            if (hwndPane == NULL)
                continue;

            GetPaneRect(i, &rc);
            hDWP = DeferWindowPos(hDWP, hwndPane, NULL, 
                rc.left, rc.top, rc.right - rc.left, rc.bottom - rc.top, 
                SWP_NOZORDER | SWP_NOACTIVATE);
        }
        EndDeferWindowPos(hDWP);

        UINT nID = GetDlgCtrlID(m_hwnd);
        NMHDR notify = { m_hwnd, nID, NOTIFY_CHANGED };
        FORWARD_WM_NOTIFY(GetParent(m_hwnd), nID, &notify, SendMessage);
    }

    virtual LRESULT CALLBACK
    WindowProcDx(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
    {
        switch (uMsg)
        {
        HANDLE_MSG(hwnd, WM_SIZE, OnSize);
        HANDLE_MSG(hwnd, WM_LBUTTONDOWN, OnLButtonDown);
        HANDLE_MSG(hwnd, WM_LBUTTONDBLCLK, OnLButtonDown);
        HANDLE_MSG(hwnd, WM_LBUTTONUP, OnLButtonUp);
        HANDLE_MSG(hwnd, WM_MOUSEMOVE, OnMouseMove);
        HANDLE_MSG(hwnd, WM_SETCURSOR, OnSetCursor);
        HANDLE_MSG(hwnd, WM_COMMAND, OnCommand);
        HANDLE_MSG(hwnd, WM_NOTIFY, OnNotify);
        HANDLE_MSG(hwnd, WM_CONTEXTMENU, OnContextMenu);
        HANDLE_MSG(hwnd, WM_SYSCOLORCHANGE, OnSysColorChange);
        case WM_CAPTURECHANGED:
            m_iDraggingBorder = -1;
            return 0;
        default:
            return DefaultProcDx();
        }
    }

    void OnSysColorChange(HWND hwnd)
    {
        for (size_t i = 0; i < m_vecPanes.size(); ++i)
        {
            SendMessage(m_vecPanes[i].hwndPane, WM_SYSCOLORCHANGE, 0, 0);
        }
    }

    virtual LPCTSTR GetWndClassNameDx() const
    {
        return TEXT("MZC4 MSplitterWnd Class");
    }

    virtual VOID ModifyWndClassDx(WNDCLASSEX& wcx)
    {
    }

    void OnCommand(HWND hwnd, int id, HWND hwndCtl, UINT codeNotify)
    {
        FORWARD_WM_COMMAND(GetParent(hwnd), id, hwndCtl, codeNotify, PostMessage);
    }

    LRESULT OnNotify(HWND hwnd, int idFrom, LPNMHDR pnmhdr)
    {
        return FORWARD_WM_NOTIFY(GetParent(hwnd), idFrom, pnmhdr, SendMessage);
    }

    void OnContextMenu(HWND hwnd, HWND hwndContext, UINT xPos, UINT yPos)
    {
        FORWARD_WM_CONTEXTMENU(GetParent(hwnd), hwndContext, xPos, yPos, SendMessage);
    }

    static HCURSOR& CursorNS()
    {
        static HCURSOR s_hcurNS = ::LoadCursor(NULL, IDC_SIZENS);
        return s_hcurNS;
    }
    static HCURSOR& CursorWE()
    {
        static HCURSOR s_hcurWE = ::LoadCursor(NULL, IDC_SIZEWE);
        return s_hcurWE;
    }

protected:
    struct PANEINFO
    {
        HWND    hwndPane;
        INT     xyPos;
        INT     cxyMin;

        PANEINFO()
        {
            hwndPane = NULL;
            xyPos = 0;
            cxyMin = m_cxyMin;
        }
    };
    INT                     m_iDraggingBorder;
    INT                     m_nPaneCount;
    std::vector<PANEINFO>   m_vecPanes;

    void OnLButtonDown(HWND hwnd, BOOL fDoubleClick, int x, int y, UINT keyFlags)
    {
        if (fDoubleClick)
            return;

        POINT pt = { x, y };
        INT iBorder = HitTestBorder(pt);
        if (iBorder < 0)
            return;

        SetCapture(hwnd);
        m_iDraggingBorder = iBorder;

        if (IsVertical())
            SetCursor(CursorNS());
        else
            SetCursor(CursorWE());
    }

    void OnLButtonUp(HWND hwnd, int x, int y, UINT keyFlags)
    {
        if (m_iDraggingBorder == -1)
            return;

        SetPanePos(m_iDraggingBorder, (IsVertical() ? y : x) + m_cxyBorder / 2);
        UpdatePanes();

        m_iDraggingBorder = -1;
        ReleaseCapture();
    }

    void OnMouseMove(HWND hwnd, int x, int y, UINT keyFlags)
    {
        if (m_iDraggingBorder == -1)
            return;

        SetPanePos(m_iDraggingBorder, (IsVertical() ? y : x) + m_cxyBorder / 2);
        UpdatePanes();
    }

    void OnSize(HWND hwnd, UINT state, int cx, int cy)
    {
        if (m_nPaneCount == 0)
            return;

        RECT rc;
        GetClientRect(hwnd, &rc);
        INT cxy = (IsVertical() ? rc.bottom : rc.right);
        Resize(cxy);
    }

    void Resize(INT cxy)
    {
        if (IsRightBottomAlign())
        {
            INT dxy = cxy - m_vecPanes[m_nPaneCount].xyPos;
            for (INT i = 1; i < m_nPaneCount; ++i)
            {
                SetPanePos(i, m_vecPanes[i].xyPos + dxy, FALSE);
            }
        }

        SetPanePos(m_nPaneCount, cxy, FALSE);
        UpdatePanes();
    }

    BOOL OnSetCursor(HWND hwnd, HWND hwndCursor, UINT codeHitTest, UINT msg)
    {
        POINT pt;
        GetCursorPos(&pt);
        ScreenToClient(hwnd, &pt);

        if (HitTestBorder(pt) == -1)
        {
            SetCursor(::LoadCursor(NULL, IDC_ARROW));
            return TRUE;
        }

        if (IsVertical())
            SetCursor(CursorNS());
        else
            SetCursor(CursorWE());
        return TRUE;
    }
};

//////////////////////////////////////////////////////////////////////////////

#endif  // ndef MZC4_MSPLITTERWND_HPP_

```

`src/MString.hpp`:

```hpp
// MString.hpp -- MZC4 string class                             -*- C++ -*-
// This file is part of MZC4.  See file "ReadMe.txt" and "License.txt".
////////////////////////////////////////////////////////////////////////////

#ifndef MZC4_MSTRING_HPP_
#define MZC4_MSTRING_HPP_       19  /* Version 19 */

// class MString;
// class MStringA;
// class MStringW;
// mstr_... functions
// mbin_... functions

////////////////////////////////////////////////////////////////////////////

#if __cplusplus >= 201103L          /* C++11 */
    #include <cstdint>
#else
    #include "pstdint.h"
#endif

#include <algorithm>    // for std::reverse
#include <cstring>      // for std::memcmp

// WCHAR
#ifndef __WCHAR_DEFINED
    #define __WCHAR_DEFINED
    #ifdef _WIN32
        typedef wchar_t WCHAR;
    #else
        #if __cplusplus >= 201103L
            typedef char16_t WCHAR;
        #else
            typedef uint16_t WCHAR;
        #endif
    #endif
#endif

// MString
#ifndef MString
    #include <string>       // for std::basic_string, std::string, ...
    typedef std::string MStringA;
    #if defined(_WIN32) && !defined(WONVER)
        #include <tchar.h>      // Windows generic text mapping
        #ifdef _MBCS
            #include <mbstring.h>   // for _mbsrchr
        #endif
        typedef std::wstring MStringW;
    #else
        typedef std::basic_string<WCHAR> MStringW;
    #endif
    #ifdef UNICODE
        #define MString     MStringW
    #else
        #define MString     MStringA
    #endif
#endif

// WIDE
#ifndef WIDE
    #ifdef _WIN32
        #define WIDE(sz) L##sz
    #else
        #define WIDE(sz) u##sz
    #endif
#endif

// TEXT
#ifndef TEXT
    #ifdef UNICODE
        #define TEXT(sz)   WIDE(sz)
    #else
        #define TEXT(sz)   sz
    #endif
#endif

////////////////////////////////////////////////////////////////////////////
// C string

template <typename T_CHAR>
inline size_t mstrlen(const T_CHAR *str);

template <typename T_CHAR, size_t siz>
T_CHAR *mstrcpy(T_CHAR (&dest)[siz], const T_CHAR *src);

template <typename T_CHAR, size_t siz>
T_CHAR *mstrcpyn(T_CHAR (&dest)[siz], const T_CHAR *src, size_t maxbuf);

template <typename T_CHAR>
T_CHAR *mstrrchr(T_CHAR *str, T_CHAR ch);
template <typename T_CHAR>
const T_CHAR *mstrrchr(const T_CHAR *str, T_CHAR ch);

////////////////////////////////////////////////////////////////////////////

enum MTextEncoding
{
    MTENC_UNKNOWN = 0,
    MTENC_ASCII,
    MTENC_ANSI,
    MTENC_UNICODE_LE,
    MTENC_UNICODE_BE,
    MTENC_UTF8,
    MTENC_UNICODE = MTENC_UNICODE_LE,
};

enum MTextNewLineType
{
    MNEWLINE_UNKNOWN,
    MNEWLINE_NOCHANGE,
    MNEWLINE_CRLF,
    MNEWLINE_LF,
    MNEWLINE_CR
};

struct MTextType
{
    MTextEncoding       nEncoding;
    MTextNewLineType    nNewLine;
    bool                bHasBOM;
};

////////////////////////////////////////////////////////////////////////////
// string

template <typename T_CHAR>
std::basic_string<T_CHAR> mchr_to_hex(T_CHAR ch);

template <typename T_CHAR>
bool mchr_is_digit(T_CHAR ch);

template <typename T_CHAR>
bool mchr_is_xdigit(T_CHAR ch);

template <typename T_CHAR>
bool mchr_is_upper(T_CHAR ch);
template <typename T_CHAR>
bool mchr_is_lower(T_CHAR ch);

template <typename T_CHAR>
bool mchr_is_alpha(T_CHAR ch);

template <typename T_CHAR>
bool mchr_is_alnum(T_CHAR ch);

template <typename T_CHAR>
bool mchr_is_space(T_CHAR ch);

template <typename T_CHAR>
int mstr_parse_int(const T_CHAR *str, bool is_signed = true, int base = 0);

template <typename T_CHAR>
void mstr_to_hex(std::basic_string<T_CHAR>& str, unsigned int value);
template <typename T_CHAR>
void mstr_to_hex(std::basic_string<T_CHAR>& str, unsigned int value);

template <typename T_CHAR>
void mstr_to_dec(std::basic_string<T_CHAR>& str, int value, bool is_signed = true);

template <typename T_CHAR>
bool mstr_is_text_ascii(const T_CHAR *str, size_t len);

template <typename T_CHAR>
bool mstr_is_text_ascii(const std::basic_string<T_CHAR>& str);

bool mstr_is_text_utf8(const char *str, size_t len);
bool mstr_is_text_utf8(const std::string& str);

bool mstr_is_text_unicode(const void *ptr, size_t len);

template <typename T_CHAR>
void mstr_trim(std::basic_string<T_CHAR>& str, const T_CHAR *spaces);
template <typename T_CHAR, size_t siz>
void mstr_trim(T_CHAR (&str)[siz], const T_CHAR *spaces);

template <typename T_CHAR>
void mstr_trim_left(std::basic_string<T_CHAR>& str, const T_CHAR *spaces);
template <typename T_CHAR, size_t siz>
void mstr_trim_left(T_CHAR (&str)[siz], const T_CHAR *spaces);

template <typename T_CHAR>
void mstr_trim_right(std::basic_string<T_CHAR>& str, const T_CHAR *spaces);
template <typename T_CHAR, size_t siz>
void mstr_trim_right(T_CHAR (&str)[siz], const T_CHAR *spaces);

template <typename T_CHAR>
T_CHAR *mstr_skip_space(T_CHAR *pch, const T_CHAR *spaces);

template <typename T_CHAR>
const T_CHAR *mstr_skip_space(const T_CHAR *pch, const T_CHAR *spaces);

inline char *mstr_skip_space(char *pch)
{
    return mstr_skip_space(pch, " \t\n\r\f\v");
}
inline const char *mstr_skip_space(const char *pch)
{
    return mstr_skip_space(pch, " \t\n\r\f\v");
}
inline WCHAR *mstr_skip_space(WCHAR *pch)
{
    return mstr_skip_space(pch, WIDE(" \t\n\r\f\v"));
}
inline const WCHAR *mstr_skip_space(const WCHAR *pch)
{
    return mstr_skip_space(pch, WIDE(" \t\n\r\f\v"));
}

template <typename T_CHAR>
std::basic_string<T_CHAR>
mstr_repeat(const std::basic_string<T_CHAR>& str, size_t count);
template <typename T_CHAR>
std::basic_string<T_CHAR>
mstr_repeat(const T_CHAR *str, size_t count);

template <typename T_CHAR>
std::basic_string<T_CHAR>
mstr_escape(const std::basic_string<T_CHAR>& str);

template <typename T_STR>
bool mstr_replace_all(T_STR& str, const T_STR& from, const T_STR& to);
template <typename T_STR>
bool mstr_replace_all(T_STR& str,
                      const typename T_STR::value_type *from,
                      const typename T_STR::value_type *to);

template <typename T_CHAR>
std::basic_string<T_CHAR>
mstr_quote(const std::basic_string<T_CHAR>& str);

template <typename T_CHAR>
std::basic_string<T_CHAR>
mstr_quote(const T_CHAR *str);

template <typename T_STR_CONTAINER>
void mstr_split(T_STR_CONTAINER& container,
                const typename T_STR_CONTAINER::value_type& str,
                const typename T_STR_CONTAINER::value_type& chars);

template <typename T_STR_CONTAINER>
typename T_STR_CONTAINER::value_type
mstr_join(const T_STR_CONTAINER& container,
          const typename T_STR_CONTAINER::value_type& sep);

////////////////////////////////////////////////////////////////////////////
// binary

void mbin_swap_endian(void *ptr, size_t len);
void mbin_swap_endian(std::string& bin);

MStringW
mstr_from_bin(const void *bin, size_t len, MTextType *pType = NULL);
MStringW
mstr_from_bin(const std::string& bin, MTextType *pType = NULL);

std::string mbin_from_str(const MStringW& str, const MTextType& type);

////////////////////////////////////////////////////////////////////////////

#include "MTextToText.hpp"

////////////////////////////////////////////////////////////////////////////

template <typename T_CHAR>
inline size_t mstrlen(const T_CHAR *str)
{
    return std::char_traits<T_CHAR>::length(str);
}

template <typename T_CHAR, size_t siz>
inline T_CHAR *mstrcpy(T_CHAR (&dest)[siz], const T_CHAR *src)
{
    std::char_traits<T_CHAR>::copy(dest, src, mstrlen(src) + 1);
    return dest;
}

template <typename T_CHAR, size_t siz>
inline T_CHAR *mstrcpyn(T_CHAR (&dest)[siz], const T_CHAR *src, size_t maxbuf)
{
    size_t len = mstrlen(src) + 1;
    if (len >= maxbuf)
        len = maxbuf;
    std::char_traits<T_CHAR>::copy(dest, src, len);
    if (maxbuf)
        dest[maxbuf - 1] = 0;
    return dest;
}

template <typename T_CHAR>
inline T_CHAR *mstrrchr(T_CHAR *str, T_CHAR ch)
{
#if defined(_WIN32) && defined(_MBCS)
    if (sizeof(T_CHAR) == 1)
    {
        return (T_CHAR *)(_mbsrchr((BYTE *)str, ch));
    }
#endif
    T_CHAR *ptr = NULL;
    while (*str)
    {
        if (*str == ch)
            ptr = str;
        ++str;
    }
    return ptr;
}

template <typename T_CHAR>
inline const T_CHAR *mstrrchr(const T_CHAR *str, T_CHAR ch)
{
#if defined(_WIN32) && defined(_MBCS)
    if (sizeof(T_CHAR) == 1)
    {
        return (const T_CHAR *)(_mbsrchr((const BYTE *)str, ch));
    }
#endif
    const T_CHAR *ptr = NULL;
    while (*str)
    {
        if (*str == ch)
            ptr = str;
        ++str;
    }
    return ptr;
}

////////////////////////////////////////////////////////////////////////////

template <typename T_CHAR>
inline std::basic_string<T_CHAR>
mchr_to_hex(T_CHAR value)
{
    std::basic_string<T_CHAR> ret;
    if (sizeof(T_CHAR) == 1)
        mstr_to_hex(ret, (value & 0xFF));
    else if (sizeof(T_CHAR) == 2)
        mstr_to_hex(ret, (value & 0xFFFF));
    else if (sizeof(T_CHAR) == 4)
        mstr_to_hex(ret, (value & 0xFFFFFFFF));
    return ret;
}

template <typename T_CHAR>
inline bool mchr_is_digit(T_CHAR ch)
{
    return (T_CHAR('0') <= ch && ch <= T_CHAR('9'));
}

template <typename T_CHAR>
inline bool mchr_is_xdigit(T_CHAR ch)
{
    if (T_CHAR('0') <= ch && ch <= T_CHAR('9'))
        return true;
    if (T_CHAR('A') <= ch && ch <= T_CHAR('F'))
        return true;
    if (T_CHAR('a') <= ch && ch <= T_CHAR('f'))
        return true;
    return false;
}

template <typename T_CHAR>
inline bool mchr_is_upper(T_CHAR ch)
{
    return (T_CHAR('A') <= ch && ch <= T_CHAR('Z'));
}

template <typename T_CHAR>
inline bool mchr_is_lower(T_CHAR ch)
{
    return (T_CHAR('a') <= ch && ch <= T_CHAR('z'));
}

template <typename T_CHAR>
inline bool mchr_is_alpha(T_CHAR ch)
{
    return mchr_is_upper(ch) || mchr_is_lower(ch);
}

template <typename T_CHAR>
inline bool mchr_is_alnum(T_CHAR ch)
{
    return mchr_is_alpha(ch) || mchr_is_digit(ch);
}

template <typename T_CHAR>
inline bool mchr_is_space(T_CHAR ch)
{
    return (ch == T_CHAR(' ') || ch == T_CHAR('\t') ||
            ch == T_CHAR('\n') || ch == T_CHAR('\r') ||
            ch == T_CHAR('\f') || ch == T_CHAR('\v'));
}

template <typename T_CHAR>
inline int mstr_parse_int(const T_CHAR *str, bool is_signed, int base)
{
    str = mstr_skip_space(str);

    if (*str == T_CHAR('+'))
        ++str;

    bool minus = false;
    if (is_signed && *str == T_CHAR('-'))
    {
        minus = true;
        ++str;
    }

    if (str[0] == T_CHAR('0'))
    {
        if (str[1] == T_CHAR('x') || str[1] == T_CHAR('X'))
        {
            if (base == 0)
            {
                base = 16;
            }
            str += 2;
        }
        else
        {
            if (base == 0)
            {
                base = 8;
            }
            ++str;
        }
    }

    if (base == 0)
    {
        base = 10;
    }
    assert(base == 10 || base == 8 || base == 16);

    int num;
    for (num = 0; *str; ++str)
    {
        if (base == 8)
        {
            if (T_CHAR('0') <= *str && *str <= T_CHAR('7'))
            {
                num *= base;
                num += *str - T_CHAR('0');
                continue;
            }
        }
        else if (base == 16)
        {
            if (T_CHAR('0') <= *str && *str <= T_CHAR('9'))
            {
                num *= base;
                num += *str - T_CHAR('0');
                continue;
            }
            else if (T_CHAR('A') <= *str && *str <= T_CHAR('F'))
            {
                num *= base;
                num += *str - T_CHAR('A') + 10;
                continue;
            }
            else if (T_CHAR('a') <= *str && *str <= T_CHAR('f'))
            {
                num *= base;
                num += *str - T_CHAR('a') + 10;
                continue;
            }
        }
        else if (base == 10)
        {
            if (T_CHAR('0') <= *str && *str <= T_CHAR('9'))
            {
                num *= base;
                num += *str - T_CHAR('0');
                continue;
            }
        }
        break;
    }

    return (minus ? -num : num);
}

template <typename T_CHAR>
inline void
mstr_to_hex(std::basic_string<T_CHAR>& str, unsigned int value)
{
    static const char hex[] = "0123456789ABCDEF";
    str.clear();
    while (value)
    {
        str += T_CHAR(hex[value & 0xF]);
        value >>= 4;
    }
    std::reverse(str.begin(), str.end());
    if (str.empty())
        str += T_CHAR('0');
}

template <typename T_CHAR>
inline void
mstr_to_dec(std::basic_string<T_CHAR>& str, int value, bool is_signed)
{
    static const char dec[] = "0123456789";
    str.clear();
    bool is_minus = false;
    if (is_signed && value < 0)
    {
        is_minus = true;
        value = -value;
    }
    size_t i = 0;
    unsigned int uvalue = value;
    while (uvalue)
    {
        str += T_CHAR(dec[uvalue % 10]);
        uvalue /= 10;
        ++i;
    }
    if (is_minus)
        str += T_CHAR('-');
    std::reverse(str.begin(), str.end());
    if (str.empty())
        str += T_CHAR('0');
}

template <typename T_CHAR>
inline bool mstr_is_text_ascii(const T_CHAR *str, size_t len)
{
    if (!len)
        return true;

    while (len-- > 0)
    {
        if (*str < 0 || *str > 0x7F)
            return false;
        ++str;
    }
    return true;
}

template <typename T_CHAR>
inline bool mstr_is_text_ascii(const std::basic_string<T_CHAR>& str)
{
    return mstr_is_text_ascii(&str[0], str.size());
}

inline bool mstr_is_text_utf8(const std::string& str)
{
    return mstr_is_text_utf8(&str[0], str.size());
}

#if defined(_WIN32) && !defined(WONVER)
    inline bool mstr_is_text_unicode(const void *ptr, size_t len)
    {
        if (len == 0)
            return true;

        return !!::IsTextUnicode(ptr, int(len), NULL);
    }
#else
    #include "UTF16_validator.h"
    inline bool mstr_is_text_unicode(const void *ptr, size_t len)
    {
        if (len == 0)
            return true;

        return UTF16_validate(ptr, len);
    }
#endif

template <typename T_CHAR>
inline void mstr_trim(std::basic_string<T_CHAR>& str, const T_CHAR *spaces)
{
    typedef std::basic_string<T_CHAR> string_type;
    size_t i = str.find_first_not_of(spaces);
    size_t j = str.find_last_not_of(spaces);
    if ((i == string_type::npos) || (j == string_type::npos))
    {
        str.clear();
    }
    else
    {
        str = str.substr(i, j - i + 1);
    }
}

template <typename T_CHAR, size_t siz>
inline void mstr_trim(T_CHAR (&str)[siz], const T_CHAR *spaces)
{
    typedef std::basic_string<T_CHAR> string_type;
    string_type s = str;
    mstr_trim(s, spaces);
    mstrcpy(str, s.c_str());
}

template <typename T_CHAR>
inline void mstr_trim_left(std::basic_string<T_CHAR>& str, const T_CHAR *spaces)
{
    typedef std::basic_string<T_CHAR> string_type;
    size_t i = str.find_first_not_of(spaces);
    if (i == string_type::npos)
    {
        str.clear();
    }
    else
    {
        str = str.substr(i);
    }
}

template <typename T_CHAR, size_t siz>
inline void mstr_trim_left(T_CHAR (&str)[siz], const T_CHAR *spaces)
{
    typedef std::basic_string<T_CHAR> string_type;
    string_type s = str;
    mstr_trim_left(s, spaces);
    mstrcpy(str, s.c_str());
}

template <typename T_CHAR>
inline void mstr_trim_right(std::basic_string<T_CHAR>& str, const T_CHAR *spaces)
{
    typedef std::basic_string<T_CHAR> string_type;
    size_t j = str.find_last_not_of(spaces);
    if (j == string_type::npos)
    {
        str.clear();
    }
    else
    {
        str = str.substr(0, j + 1);
    }
}

template <typename T_CHAR, size_t siz>
inline void mstr_trim_right(T_CHAR (&str)[siz], const T_CHAR *spaces)
{
    typedef std::basic_string<T_CHAR> string_type;
    string_type s = str;
    mstr_trim_right(s, spaces);
    mstrcpy(str, s.c_str());
}

template <typename T_CHAR>
inline std::basic_string<T_CHAR>
mstr_repeat(const std::basic_string<T_CHAR>& str, size_t count)
{
    std::basic_string<T_CHAR> ret;
    while (count-- > 0)
    {
        ret += str;
    }
    return ret;
}

template <typename T_CHAR>
inline std::basic_string<T_CHAR>
mstr_repeat(const T_CHAR *str, size_t count)
{
    return mstr_repeat(std::basic_string<T_CHAR>(str), count);
}

template <typename T_CHAR>
inline std::basic_string<T_CHAR>
mstr_escape(const std::basic_string<T_CHAR>& str)
{
    std::basic_string<T_CHAR> ret;

    for (size_t i = 0; i < str.size(); ++i)
    {
        T_CHAR ch = str[i];
        switch (ch)
        {
        case T_CHAR('\"'): ret += T_CHAR('\"'); ret += T_CHAR('\"'); break;
        case T_CHAR('\\'): ret += T_CHAR('\\'); ret += T_CHAR('\\'); break;
        case T_CHAR('\0'): ret += T_CHAR('\\'); ret += T_CHAR('0'); break;
        case T_CHAR('\a'): ret += T_CHAR('\\'); ret += T_CHAR('a'); break;
        case T_CHAR('\b'): ret += T_CHAR('\\'); ret += T_CHAR('b'); break;
        case T_CHAR('\f'): ret += T_CHAR('\\'); ret += T_CHAR('f'); break;
        case T_CHAR('\n'): ret += T_CHAR('\\'); ret += T_CHAR('n'); break;
        case T_CHAR('\r'): ret += T_CHAR('\\'); ret += T_CHAR('r'); break;
        case T_CHAR('\t'): ret += T_CHAR('\\'); ret += T_CHAR('t'); break;
        case T_CHAR('\v'): ret += T_CHAR('\\'); ret += T_CHAR('v'); break;
        default:
            if (ch < 0x20)
            {
                ret += T_CHAR('\\');
                ret += T_CHAR('x');
                ret += mchr_to_hex(ch);
            }
            else
            {
                ret += ch;
            }
        }
    }

    return ret;
}

template <typename T_STR>
inline bool
mstr_replace_all(T_STR& str, const T_STR& from, const T_STR& to)
{
    bool ret = false;
    size_t i = 0;
    for (;;) {
        i = str.find(from, i);
        if (i == T_STR::npos)
            break;
        ret = true;
        str.replace(i, from.size(), to);
        i += to.size();
    }
    return ret;
}
template <typename T_STR>
inline bool
mstr_replace_all(T_STR& str,
                 const typename T_STR::value_type *from,
                 const typename T_STR::value_type *to)
{
    return mstr_replace_all(str, T_STR(from), T_STR(to));
}

inline void
mbin_swap_endian(void *ptr, size_t len)
{
    char *pb = (char *)ptr;
    len /= 2;
    while (--len)
    {
        char b = pb[0];
        pb[0] = pb[1];
        pb[1] = b;
        ++pb;
        ++pb;
    }
}

inline void mbin_swap_endian(std::string& bin)
{
    mbin_swap_endian(&bin[0], bin.size());
}

inline MStringW
mstr_from_bin(const void *bin, size_t len, MTextType *pType/* = NULL*/)
{
    MStringW ret;

    if (bin == NULL || len == 0)
    {
        // empty
        if (pType)
        {
            pType->nNewLine = MNEWLINE_CRLF;
            pType->nEncoding = MTENC_ASCII;
        }
        return ret;
    }

    if (len >= 2 && std::memcmp(bin, "\xFF\xFE", 2) == 0)
    {
        // UTF-16 LE
        if (pType)
        {
            pType->nEncoding = MTENC_UNICODE_LE;
            pType->bHasBOM = true;
        }
        ret.assign((const WCHAR *)bin, len / sizeof(WCHAR));
    }
    else if (len >= 2 && std::memcmp(bin, "\xFE\xFF", 2) == 0)
    {
        // UTF-16 BE
        if (pType)
        {
            pType->nEncoding = MTENC_UNICODE_BE;
            pType->bHasBOM = true;
        }
        ret.assign((const WCHAR *)bin, len / sizeof(WCHAR));
        mbin_swap_endian(&ret[0], len);
    }
    else
    {
        const char *pch = (const char *)bin;
        if (len >= 3 && std::memcmp(bin, "\xEF\xBB\xBF", 3) == 0)
        {
            // UTF-8
            if (pType)
            {
                pType->nEncoding = MTENC_UTF8;
                pType->bHasBOM = true;
            }
            std::string str(&pch[3], len - 3);
            ret = MAnsiToWide(CP_UTF8, str);
        }
        else if (mstr_is_text_ascii((const char *)bin, len))
        {
            // ASCII
            if (pType)
            {
                pType->nEncoding = MTENC_ASCII;
                pType->bHasBOM = false;
            }
            std::string str(pch, len);
            ret = MAnsiToWide(CP_ACP, str);
        }
        else if (mstr_is_text_utf8((const char *)bin, len))
        {
            // UTF-8
            if (pType)
            {
                pType->nEncoding = MTENC_UTF8;
                pType->bHasBOM = false;
            }
            ret = MAnsiToWide(CP_UTF8, pch, int(len));
        }
        else if (mstr_is_text_unicode(bin, int(len)))
        {
            // UTF-16 LE
            if (pType)
            {
                pType->nEncoding = MTENC_UNICODE_LE;
                pType->bHasBOM = false;
            }
            ret.assign((const WCHAR *)bin, len / sizeof(WCHAR));
        }
        else
        {
            // ANSI
            if (pType)
            {
                pType->nEncoding = MTENC_ANSI;
                pType->bHasBOM = false;
            }
            std::string str(pch, len);
            ret = MAnsiToWide(CP_ACP, str);
        }
    }

    if (!pType || pType->nNewLine != MNEWLINE_NOCHANGE)
    {
        if (pType)
        {
            pType->nNewLine = MNEWLINE_UNKNOWN;
        }
        if (mstr_replace_all(ret, WIDE("\r\n"), WIDE("\n")))
        {
            if (pType)
            {
                pType->nNewLine = MNEWLINE_CRLF;
            }
        }
        if (mstr_replace_all(ret, WIDE("\r"), WIDE("\n")))
        {
            if (pType && pType->nNewLine != MNEWLINE_CRLF)
            {
                pType->nNewLine = MNEWLINE_CR;
            }
        }
        if (mstr_replace_all(ret, WIDE("\n"), WIDE("\r\n")))
        {
            if (pType && pType->nNewLine != MNEWLINE_CRLF)
            {
                pType->nNewLine = MNEWLINE_LF;
            }
        }
    }

    return ret;
}

inline MStringW
mstr_from_bin(const std::string& bin, MTextType *pType/* = NULL*/)
{
    return mstr_from_bin(&bin[0], bin.size(), pType);
}

inline std::string
mbin_from_str(const MStringW& str, const MTextType& type)
{
    std::string ret;
    MStringW str2 = str;

    switch (type.nNewLine)
    {
    case MNEWLINE_UNKNOWN:
    case MNEWLINE_NOCHANGE:
        break;
    case MNEWLINE_CRLF:
        mstr_replace_all(str2, WIDE("\r\n"), WIDE("\n"));
        mstr_replace_all(str2, WIDE("\r"), WIDE("\r\n"));
        mstr_replace_all(str2, WIDE("\n"), WIDE("\r\n"));
        break;
    case MNEWLINE_LF:
        mstr_replace_all(str2, WIDE("\r\n"), WIDE("\n"));
        mstr_replace_all(str2, WIDE("\r"), WIDE("\n"));
        break;
    case MNEWLINE_CR:
        mstr_replace_all(str2, WIDE("\r\n"), WIDE("\r"));
        mstr_replace_all(str2, WIDE("\n"), WIDE("\r"));
        break;
    }

    switch (type.nEncoding)
    {
    case MTENC_UNKNOWN:
    case MTENC_ASCII:
    case MTENC_ANSI:
    default:
        ret += MWideToAnsi(CP_ACP, str2);
        break;
    case MTENC_UNICODE_LE:
        if (type.bHasBOM)
        {
            ret += "\xFF\xFE";
        }
        ret.append((const char *)str2.c_str(), str2.size() * sizeof(WCHAR));
        break;
    case MTENC_UNICODE_BE:
        if (type.bHasBOM)
        {
            ret += "\xFF\xFE";
        }
        ret.append((const char *)str2.c_str(), str2.size() * sizeof(WCHAR));
        mbin_swap_endian(ret);
        break;
    case MTENC_UTF8:
        if (type.bHasBOM)
        {
            ret += "\xEF\xBB\xBF";
        }
        ret += MWideToAnsi(CP_UTF8, str2);
        break;
    }

    return ret;
}

template <typename T_CHAR>
inline std::basic_string<T_CHAR>
mstr_quote(const std::basic_string<T_CHAR>& str)
{
    std::basic_string<T_CHAR> ret;
    ret += T_CHAR('\"');
    ret += mstr_escape(str);
    ret += T_CHAR('\"');
    return ret;
}

template <typename T_CHAR>
inline std::basic_string<T_CHAR>
mstr_quote(const T_CHAR *str)
{
    std::basic_string<T_CHAR> ret = str;
    return mstr_quote(ret);
}

template <typename T_STR_CONTAINER>
inline void
mstr_split(T_STR_CONTAINER& container,
           const typename T_STR_CONTAINER::value_type& str,
           const typename T_STR_CONTAINER::value_type& chars)
{
    container.clear();
    size_t i = 0, k = str.find_first_of(chars);
    while (k != T_STR_CONTAINER::value_type::npos)
    {
        container.push_back(str.substr(i, k - i));
        i = k + 1;
        k = str.find_first_of(chars, i);
    }
    container.push_back(str.substr(i));
}

template <typename T_STR_CONTAINER>
inline typename T_STR_CONTAINER::value_type
mstr_join(const T_STR_CONTAINER& container,
          const typename T_STR_CONTAINER::value_type& sep)
{
    typename T_STR_CONTAINER::value_type result;
    typename T_STR_CONTAINER::const_iterator it, end;
    it = container.begin();
    end = container.end();
    if (it != end)
    {
        result = *it;
        for (++it; it != end; ++it)
        {
            result += sep;
            result += *it;
        }
    }
    return result;
}

template <typename T_CHAR>
inline T_CHAR *
mstr_skip_space(T_CHAR *pch, const T_CHAR *spaces)
{
    const T_CHAR *ptr;
    while (*pch)
    {
        for (ptr = spaces; *ptr; ++ptr)
        {
            if (*ptr == *pch)
            {
                ptr = NULL;
                break;
            }
        }
        if (ptr)
            return pch;

        ++pch;
    }
    return pch;
}

template <typename T_CHAR>
inline const T_CHAR *
mstr_skip_space(const T_CHAR *pch, const T_CHAR *spaces)
{
    const T_CHAR *ptr;
    while (*pch)
    {
        for (ptr = spaces; *ptr; ++ptr)
        {
            if (*ptr == *pch)
            {
                ptr = NULL;
                break;
            }
        }
        if (ptr)
            return pch;

        ++pch;
    }
    return pch;
}

////////////////////////////////////////////////////////////////////////////

inline void mstr_trim(MStringA& str)
{
    mstr_trim(str, " \t\n\r\f\v");
}
inline void mstr_trim(MStringW& str)
{
    mstr_trim(str, WIDE(" \t\n\r\f\v"));
}
template <size_t siz>
inline void mstr_trim(char (&str)[siz])
{
    mstr_trim(str, " \t\n\r\f\v");
}
template <size_t siz>
inline void mstr_trim(WCHAR (&str)[siz])
{
    mstr_trim(str, WIDE(" \t\n\r\f\v"));
}

inline void mstr_trim_left(MStringA& str)
{
    mstr_trim_left(str, " \t\n\r\f\v");
}
inline void mstr_trim_left(MStringW& str)
{
    mstr_trim_left(str, WIDE(" \t\n\r\f\v"));
}
template <size_t siz>
inline void mstr_trim_left(char (&str)[siz])
{
    mstr_trim_left(str, " \t\n\r\f\v");
}
template <size_t siz>
inline void mstr_trim_left(WCHAR (&str)[siz])
{
    mstr_trim_left(str, WIDE(" \t\n\r\f\v"));
}

inline void mstr_trim_right(MStringA& str)
{
    mstr_trim_right(str, " \t\n\r\f\v");
}
inline void mstr_trim_right(MStringW& str)
{
    mstr_trim_right(str, WIDE(" \t\n\r\f\v"));
}
template <size_t siz>
inline void mstr_trim_right(char (&str)[siz])
{
    mstr_trim_right(str, " \t\n\r\f\v");
}
template <size_t siz>
inline void mstr_trim_right(WCHAR (&str)[siz])
{
    mstr_trim_right(str, WIDE(" \t\n\r\f\v"));
}

////////////////////////////////////////////////////////////////////////////
// UTF-8 checking

#if defined(_WIN32) && !defined(WONVER)
    inline bool mstr_is_text_utf8(const char *str, size_t len)
    {
        if (len == 0)
            return true;

        len = ::MultiByteToWideChar(CP_UTF8, MB_ERR_INVALID_CHARS, str, int(len), NULL, 0);
        return len != 0;
    }
#else
    #include "UTF8_validator.h"
    inline bool mstr_is_text_utf8(const char *str, size_t len)
    {
        if (len == 0)
            return true;

        return UTF8_validate(str, len);
    }
#endif

////////////////////////////////////////////////////////////////////////////

#endif  // ndef MZC4_MSTRING_HPP_

```

`src/MStringListDlg.hpp`:

```hpp
// MStringListDlg.hpp
//////////////////////////////////////////////////////////////////////////////
// RisohEditor --- Another free Win32 resource editor
// Copyright (C) 2017-2018 Katayama Hirofumi MZ <katayama.hirofumi.mz@gmail.com>
// 
// This program is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
// 
// This program is distributed in the hope that it will be useful, 
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
// 
// You should have received a copy of the GNU General Public License
// along with this program.  If not, see <http://www.gnu.org/licenses/>.
//////////////////////////////////////////////////////////////////////////////

#pragma once

#include "MWindowBase.hpp"
#include "MString.hpp"
#include "DlgInitRes.hpp"

//////////////////////////////////////////////////////////////////////////////

class MStringListDlg : public MDialogBase
{
public:
    std::vector<MStringA>& m_str_list;

    MStringListDlg(std::vector<MStringA>& str_list) :
        MDialogBase(IDD_STRINGLIST), m_str_list(str_list)
    {
    }

    virtual ~MStringListDlg()
    {
    }

    BOOL OnInitDialog(HWND hwnd, HWND hwndFocus, LPARAM lParam)
    {
        MStringA text = mstr_join(m_str_list, "\r\n");
        SetDlgItemTextA(hwnd, edt1, text.c_str());

        MString str = LoadStringDx(IDS_DLGINIT1);
        str += LoadStringDx(IDS_DLGINIT2);
        str += LoadStringDx(IDS_DLGINIT3);
        SetDlgItemText(hwnd, stc1, str.c_str());

        return TRUE;
    }

    void OnOK(HWND hwnd)
    {
        MString str = GetDlgItemText(hwnd, edt1);
        mstr_trim(str);

        if (str.empty())
        {
            m_str_list.clear();
            EndDialog(IDOK);
            return;
        }

        MStringA strA = MTextToAnsi(CP_ACP, str.c_str()).c_str();
        mstr_trim(strA);

        std::vector<MStringA> lines;
        mstr_replace_all(strA, "\r", "");
        mstr_split(lines, strA, "\n");
        m_str_list = lines;

        EndDialog(IDOK);
    }

    void OnCommand(HWND hwnd, int id, HWND hwndCtl, UINT codeNotify)
    {
        switch (id)
        {
        case IDOK:
            OnOK(hwnd);
            break;
        case IDCANCEL:
            EndDialog(IDCANCEL);
            break;
        }
    }

    virtual INT_PTR CALLBACK
    DialogProcDx(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
    {
        switch (uMsg)
        {
        HANDLE_MSG(hwnd, WM_INITDIALOG, OnInitDialog);
        HANDLE_MSG(hwnd, WM_COMMAND, OnCommand);
        default:
            return DefaultProcDx();
        }
    }
};

```

`src/MStringsDlg.hpp`:

```hpp
// MStringsDlg.hpp --- "String Table" Dialog
//////////////////////////////////////////////////////////////////////////////
// RisohEditor --- Another free Win32 resource editor
// Copyright (C) 2017-2018 Katayama Hirofumi MZ <katayama.hirofumi.mz@gmail.com>
// 
// This program is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
// 
// This program is distributed in the hope that it will be useful, 
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
// 
// You should have received a copy of the GNU General Public License
// along with this program.  If not, see <http://www.gnu.org/licenses/>.
//////////////////////////////////////////////////////////////////////////////

#pragma once

#include "resource.h"
#include "MWindowBase.hpp"
#include "RisohSettings.hpp"
#include "ConstantsDB.hpp"
#include "Res.hpp"
#include "MResizable.hpp"
#include "MComboBoxAutoComplete.hpp"
#include "StringRes.hpp"
#include "Common.hpp"

class MAddStrDlg;
class MModifyStrDlg;
class MStringsDlg;

BOOL StrDlg_GetEntry(HWND hwnd, STRING_ENTRY& entry);
void StrDlg_SetEntry(HWND hwnd, STRING_ENTRY& entry);

//////////////////////////////////////////////////////////////////////////////

class MAddStrDlg : public MDialogBase
{
public:
    STRING_ENTRY& m_entry;
    StringRes& m_str_res;
    MComboBoxAutoComplete m_cmb1;
    MResizable m_resizable;
    HICON m_hIcon;
    HICON m_hIconSm;

    MAddStrDlg(STRING_ENTRY& entry, StringRes& str_res)
        : MDialogBase(IDD_ADDSTR), m_entry(entry), m_str_res(str_res)
    {
        m_hIcon = LoadIconDx(IDI_SMILY);
        m_hIconSm = LoadSmallIconDx(IDI_SMILY);
        m_cmb1.m_bAcceptSpace = TRUE;
    }

    virtual ~MAddStrDlg()
    {
        DestroyIcon(m_hIcon);
        DestroyIcon(m_hIconSm);
    }

    BOOL OnInitDialog(HWND hwnd, HWND hwndFocus, LPARAM lParam)
    {
        SendMessageDx(WM_SETICON, ICON_BIG, (LPARAM)m_hIcon);
        SendMessageDx(WM_SETICON, ICON_SMALL, (LPARAM)m_hIconSm);

        HWND hCmb1 = GetDlgItem(hwnd, cmb1);
        InitStringComboBox(hCmb1, L"");
        SubclassChildDx(m_cmb1, cmb1);

        m_resizable.OnParentCreate(hwnd);

        m_resizable.SetLayoutAnchor(cmb1, mzcLA_TOP_LEFT, mzcLA_TOP_RIGHT);
        m_resizable.SetLayoutAnchor(psh1, mzcLA_TOP_RIGHT);
        m_resizable.SetLayoutAnchor(edt1, mzcLA_TOP_LEFT, mzcLA_BOTTOM_RIGHT);
        m_resizable.SetLayoutAnchor(chx1, mzcLA_BOTTOM_LEFT);
        m_resizable.SetLayoutAnchor(IDOK, mzcLA_BOTTOM_RIGHT);
        m_resizable.SetLayoutAnchor(IDCANCEL, mzcLA_BOTTOM_RIGHT);

        CenterWindowDx();
        return TRUE;
    }

    void OnOK(HWND hwnd)
    {
        HWND hCmb1 = GetDlgItem(hwnd, cmb1);
        if (!StrDlg_GetEntry(hwnd, m_entry))
        {
            ComboBox_SetEditSel(hCmb1, 0, -1);
            SetFocus(hCmb1);
            ErrorBoxDx(IDS_NOSUCHID);
            return;
        }
        if (::IsDlgButtonChecked(hwnd, chx1) == BST_CHECKED)
        {
            MStringW str = m_entry.StringValue;
            mstr_replace_all(str, L"\r\n", L"\n");
            StringCchCopy(m_entry.StringValue, _countof(m_entry.StringValue), str.c_str());
        }
        INT value;
        if (g_db.HasResID(m_entry.StringID))
        {
            value = g_db.GetResIDValue(m_entry.StringID);
        }
        else
        {
            value = mstr_parse_int(m_entry.StringID);
        }
        if (m_str_res.map().find((WORD)value) != m_str_res.map().end())
        {
            ComboBox_SetEditSel(hCmb1, 0, -1);
            SetFocus(hCmb1);
            ErrorBoxDx(IDS_ALREADYEXISTS);
            return;
        }

        EndDialog(IDOK);
    }

    void OnCommand(HWND hwnd, int id, HWND hwndCtl, UINT codeNotify)
    {
        switch (id)
        {
        case IDOK:
            OnOK(hwnd);
            break;
        case IDCANCEL:
            EndDialog(IDCANCEL);
            break;
        case psh1:
            OnPsh1(hwnd);
            break;
        case cmb1:
            if (codeNotify == CBN_EDITCHANGE)
            {
                m_cmb1.OnEditChange();
            }
            break;
        }
    }

    void OnPsh1(HWND hwnd)
    {
        SendMessage(GetParent(GetParent(hwnd)), WM_COMMAND, ID_IDLIST, 0);
    }

    void OnSize(HWND hwnd, UINT state, int cx, int cy)
    {
        m_resizable.OnSize();
    }

    virtual INT_PTR CALLBACK
    DialogProcDx(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
    {
        switch (uMsg)
        {
            HANDLE_MSG(hwnd, WM_INITDIALOG, OnInitDialog);
            HANDLE_MSG(hwnd, WM_COMMAND, OnCommand);
            HANDLE_MSG(hwnd, WM_SIZE, OnSize);
        }
        return 0;
    }
};

//////////////////////////////////////////////////////////////////////////////

class MModifyStrDlg : public MDialogBase
{
public:
    STRING_ENTRY& m_entry;
    StringRes& m_str_res;
    MResizable m_resizable;
    HICON m_hIcon;
    HICON m_hIconSm;
    MComboBoxAutoComplete m_cmb1;

    MModifyStrDlg(STRING_ENTRY& entry, StringRes& str_res)
        : MDialogBase(IDD_MODIFYSTR), m_entry(entry), m_str_res(str_res)
    {
        m_hIcon = LoadIconDx(IDI_SMILY);
        m_hIconSm = LoadSmallIconDx(IDI_SMILY);
        m_cmb1.m_bAcceptSpace = TRUE;
    }

    virtual ~MModifyStrDlg()
    {
        DestroyIcon(m_hIcon);
        DestroyIcon(m_hIconSm);
    }

    BOOL OnInitDialog(HWND hwnd, HWND hwndFocus, LPARAM lParam)
    {
        SendMessageDx(WM_SETICON, ICON_BIG, (LPARAM)m_hIcon);
        SendMessageDx(WM_SETICON, ICON_SMALL, (LPARAM)m_hIconSm);

        HWND hCmb1 = GetDlgItem(hwnd, cmb1);
        InitStringComboBox(hCmb1, L"");

        StrDlg_SetEntry(hwnd, m_entry);

        m_resizable.OnParentCreate(hwnd);

        m_resizable.SetLayoutAnchor(cmb1, mzcLA_TOP_LEFT, mzcLA_TOP_RIGHT);
        m_resizable.SetLayoutAnchor(psh1, mzcLA_TOP_RIGHT);
        m_resizable.SetLayoutAnchor(edt1, mzcLA_TOP_LEFT, mzcLA_BOTTOM_RIGHT);
        m_resizable.SetLayoutAnchor(chx1, mzcLA_BOTTOM_LEFT);
        m_resizable.SetLayoutAnchor(IDOK, mzcLA_BOTTOM_RIGHT);
        m_resizable.SetLayoutAnchor(IDCANCEL, mzcLA_BOTTOM_RIGHT);

        CenterWindowDx();
        return TRUE;
    }

    void OnOK(HWND hwnd)
    {
        if (!StrDlg_GetEntry(hwnd, m_entry))
        {
            ErrorBoxDx(IDS_NOSUCHID);
            return;
        }
        if (::IsDlgButtonChecked(hwnd, chx1) == BST_CHECKED)
        {
            MStringW str = m_entry.StringValue;
            mstr_replace_all(str, L"\r\n", L"\n");
            StringCchCopy(m_entry.StringValue, _countof(m_entry.StringValue), str.c_str());
        }
        EndDialog(IDOK);
    }

    void OnPsh1(HWND hwnd)
    {
        SendMessage(GetParent(GetParent(hwnd)), WM_COMMAND, ID_IDLIST, 0);
    }

    void OnCommand(HWND hwnd, int id, HWND hwndCtl, UINT codeNotify)
    {
        switch (id)
        {
        case IDOK:
            OnOK(hwnd);
            break;
        case IDCANCEL:
            EndDialog(IDCANCEL);
            break;
        case psh1:
            OnPsh1(hwnd);
            break;
        case cmb1:
            if (codeNotify == CBN_EDITCHANGE)
            {
                m_cmb1.OnEditChange();
            }
            break;
        }
    }

    void OnSize(HWND hwnd, UINT state, int cx, int cy)
    {
        m_resizable.OnSize();
    }

    virtual INT_PTR CALLBACK
    DialogProcDx(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
    {
        switch (uMsg)
        {
            HANDLE_MSG(hwnd, WM_INITDIALOG, OnInitDialog);
            HANDLE_MSG(hwnd, WM_COMMAND, OnCommand);
            HANDLE_MSG(hwnd, WM_SIZE, OnSize);
        }
        return DefaultProcDx();
    }
};

//////////////////////////////////////////////////////////////////////////////

class MStringsDlg : public MDialogBase
{
public:
    StringRes m_str_res;
    MResizable m_resizable;
    HWND m_hLst1;
    HICON m_hIcon;
    HICON m_hIconSm;

    MStringsDlg(StringRes& str_res)
        : MDialogBase(IDD_STRINGS), m_str_res(str_res)
    {
        m_hIcon = LoadIconDx(IDI_SMILY);
        m_hIconSm = LoadSmallIconDx(IDI_SMILY);
    }

    ~MStringsDlg()
    {
        DestroyIcon(m_hIcon);
        DestroyIcon(m_hIconSm);
    }

    void InitCtl1()
    {
        ListView_DeleteAllItems(m_hLst1);

        typedef StringRes::map_type map_type;
        const map_type& map = m_str_res.map();

        INT i = 0;
        for (auto& pair : map)
        {
            if (pair.second.empty())
                continue;

            MStringW str = g_db.GetNameOfResID(IDTYPE_STRING, IDTYPE_PROMPT, pair.first);

            LV_ITEM item;
            ZeroMemory(&item, sizeof(item));
            item.iItem = i;
            item.mask = LVIF_TEXT;
            item.iSubItem = 0;
            item.pszText = &str[0];
            ListView_InsertItem(m_hLst1, &item);

            str = mstr_quote(pair.second);

            ZeroMemory(&item, sizeof(item));
            item.iItem = i;
            item.mask = LVIF_TEXT;
            item.iSubItem = 1;
            item.pszText = &str[0];
            ListView_SetItem(m_hLst1, &item);

            ++i;
        }
    }

    BOOL OnInitDialog(HWND hwnd, HWND hwndFocus, LPARAM lParam)
    {
        m_hLst1 = GetDlgItem(hwnd, lst1);
        ListView_SetExtendedListViewStyle(m_hLst1, LVS_EX_FULLROWSELECT | LVS_EX_INFOTIP);

        LV_COLUMN column;
        ZeroMemory(&column, sizeof(column));

        column.mask = LVCF_FMT | LVCF_SUBITEM | LVCF_TEXT | LVCF_WIDTH;
        column.fmt = LVCFMT_LEFT;
        column.cx = 140;
        column.pszText = LoadStringDx(IDS_STRINGID);
        column.iSubItem = 0;
        ListView_InsertColumn(m_hLst1, 0, &column);

        column.mask = LVCF_FMT | LVCF_SUBITEM | LVCF_TEXT | LVCF_WIDTH;
        column.fmt = LVCFMT_LEFT;
        column.cx = 500;
        column.pszText = LoadStringDx(IDS_STRINGVALUE);
        column.iSubItem = 1;
        ListView_InsertColumn(m_hLst1, 1, &column);

        InitCtl1();

        UINT state = LVIS_SELECTED | LVIS_FOCUSED;
        ListView_SetItemState(m_hLst1, 0, state, state);
        SetFocus(m_hLst1);

        m_resizable.OnParentCreate(hwnd);

        m_resizable.SetLayoutAnchor(lst1, mzcLA_TOP_LEFT, mzcLA_BOTTOM_RIGHT);
        m_resizable.SetLayoutAnchor(psh1, mzcLA_TOP_RIGHT);
        m_resizable.SetLayoutAnchor(psh2, mzcLA_TOP_RIGHT);
        m_resizable.SetLayoutAnchor(psh3, mzcLA_TOP_RIGHT);
        m_resizable.SetLayoutAnchor(psh4, mzcLA_BOTTOM_LEFT);
        m_resizable.SetLayoutAnchor(IDOK, mzcLA_BOTTOM_RIGHT);
        m_resizable.SetLayoutAnchor(IDCANCEL, mzcLA_BOTTOM_RIGHT);

        SendMessageDx(WM_SETICON, ICON_BIG, (LPARAM)m_hIcon);
        SendMessageDx(WM_SETICON, ICON_SMALL, (LPARAM)m_hIconSm);

        CenterWindowDx();
        return TRUE;
    }

    void OnAdd(HWND hwnd)
    {
        STRING_ENTRY s_entry;
        ZeroMemory(&s_entry, sizeof(s_entry));
        MAddStrDlg dialog(s_entry, m_str_res);
        if (dialog.DialogBoxDx(hwnd) != IDOK)
        {
            return;
        }

        INT iItem;

        LV_FINDINFO find;
        TCHAR sz[128];
        StringCchCopy(sz, _countof(sz), s_entry.StringID);
        ZeroMemory(&find, sizeof(find));
        find.flags = LVFI_STRING;
        find.psz = sz;
        iItem = ListView_FindItem(m_hLst1, -1, &find);
        if (iItem != -1)
        {
            ListView_DeleteItem(m_hLst1, iItem);
        }

        LV_ITEM item;
        iItem = ListView_GetItemCount(m_hLst1);

        ZeroMemory(&item, sizeof(item));
        item.iItem = iItem;
        item.mask = LVIF_TEXT;
        item.iSubItem = 0;
        item.pszText = s_entry.StringID;
        ListView_InsertItem(m_hLst1, &item);

        std::wstring str = s_entry.StringValue;
        str = mstr_quote(str);

        ZeroMemory(&item, sizeof(item));
        item.iItem = iItem;
        item.mask = LVIF_TEXT;
        item.iSubItem = 1;
        item.pszText = &str[0];
        ListView_SetItem(m_hLst1, &item);

        WORD wID = (WORD)g_db.GetResIDValue(s_entry.StringID);
        m_str_res.m_map[wID] = s_entry.StringValue;

        UINT state = LVIS_SELECTED | LVIS_FOCUSED;
        ListView_SetItemState(m_hLst1, iItem, state, state);
        ListView_EnsureVisible(m_hLst1, iItem, FALSE);
    }

    void GetEntry(HWND hwnd, INT iItem, STRING_ENTRY& entry)
    {
        ListView_GetItemText(m_hLst1, iItem, 0, entry.StringID, _countof(entry.StringID));
        mstr_trim(entry.StringID);

        ListView_GetItemText(m_hLst1, iItem, 1, entry.StringValue, _countof(entry.StringValue));
        mstr_trim(entry.StringValue);
        if (entry.StringValue[0] == L'"')
        {
            mstr_unquote(entry.StringValue);
        }
    }

    void OnDelete(HWND hwnd)
    {
        INT iItem = ListView_GetNextItem(m_hLst1, -1, LVNI_ALL | LVNI_SELECTED);
        if (iItem >= 0)
        {
            STRING_ENTRY s_entry;
            GetEntry(hwnd, iItem, s_entry);

            WORD wID = (WORD)g_db.GetResIDValue(s_entry.StringID);
            m_str_res.m_map.erase(wID);

            ListView_DeleteItem(m_hLst1, iItem);
        }
    }

    void OnDeleteAll(HWND hwnd)
    {
        m_str_res.m_map.clear();
        ListView_DeleteAllItems(m_hLst1);
    }

    void OnModify(HWND hwnd)
    {
        INT iItem = ListView_GetNextItem(m_hLst1, -1, LVNI_ALL | LVNI_SELECTED);
        if (iItem < 0)
        {
            return;
        }

        STRING_ENTRY s_entry;
        GetEntry(hwnd, iItem, s_entry);

        MModifyStrDlg dialog(s_entry, m_str_res);
        if (IDOK == dialog.DialogBoxDx(hwnd))
        {
            WORD wID = (WORD)g_db.GetResIDValue(s_entry.StringID);
            m_str_res.m_map[wID] = s_entry.StringValue;

            MString str = mstr_quote(s_entry.StringValue);
            ListView_SetItemText(m_hLst1, iItem, 1, &str[0]);
        }
    }

    void OnOK(HWND hwnd)
    {
        INT iItem, nCount = ListView_GetItemCount(m_hLst1);
        if (nCount == 0)
        {
            ErrorBoxDx(IDS_DATAISEMPTY);
            return;
        }

        m_str_res.map().clear();

        STRING_ENTRY s_entry;
        for (iItem = 0; iItem < nCount; ++iItem)
        {
            GetEntry(hwnd, iItem, s_entry);

            WORD wID = (WORD)g_db.GetResIDValue(s_entry.StringID);
            std::wstring str = s_entry.StringValue;

            m_str_res.map().insert(std::make_pair(wID, str));
        }

        EndDialog(IDOK);
    }

    void OnContextMenu(HWND hwnd, HWND hwndContext, UINT xPos, UINT yPos)
    {
        if (hwndContext == m_hLst1)
        {
            PopupMenuDx(hwnd, m_hLst1, IDR_POPUPMENUS, 4, xPos, yPos);
        }
    }

    void OnCommand(HWND hwnd, int id, HWND hwndCtl, UINT codeNotify)
    {
        switch (id)
        {
        case psh1:
        case ID_ADD:
            OnAdd(hwnd);
            break;
        case psh2:
        case ID_MODIFY:
            OnModify(hwnd);
            break;
        case psh3:
        case ID_DELETE:
            OnDelete(hwnd);
            break;
        case psh4:
            OnDeleteAll(hwnd);
            break;
        case IDOK:
            OnOK(hwnd);
            break;
        case IDCANCEL:
            EndDialog(IDCANCEL);
            break;
        }
    }

    LRESULT OnNotify(HWND hwnd, int idFrom, NMHDR *pnmhdr)
    {
        if (idFrom == lst1)
        {
            if (pnmhdr->code == LVN_KEYDOWN)
            {
                LV_KEYDOWN *KeyDown = (LV_KEYDOWN *)pnmhdr;
                if (KeyDown->wVKey == VK_DELETE)
                {
                    OnDelete(hwnd);
                    return 0;
                }
            }
            if (pnmhdr->code == NM_DBLCLK)
            {
                OnModify(hwnd);
                return 0;
            }
            if (pnmhdr->code == LVN_GETINFOTIP)
            {
                NMLVGETINFOTIP *pGetInfoTip = (NMLVGETINFOTIP *)pnmhdr;
                INT iItem = pGetInfoTip->iItem;
                INT iSubItem = pGetInfoTip->iSubItem;
                TCHAR szText[128];
                ListView_GetItemText(m_hLst1, iItem, iSubItem, szText, _countof(szText));
                StringCchCopy(pGetInfoTip->pszText, pGetInfoTip->cchTextMax, szText);
                return 1;
            }
            if (pnmhdr->code == LVN_ITEMCHANGED)
            {
                //NM_LISTVIEW *pListView = (NM_LISTVIEW *)pnmhdr;
                OnItemChanged(hwnd);
            }
        }
        return 0;
    }

    void OnSize(HWND hwnd, UINT state, int cx, int cy)
    {
        m_resizable.OnSize();
    }

    void OnItemChanged(HWND hwnd)
    {
        INT iItem = ListView_GetNextItem(m_hLst1, -1, LVNI_ALL | LVNI_SELECTED);
        BOOL bSelected = (iItem != -1);
        EnableWindow(GetDlgItem(hwnd, psh2), bSelected);
        EnableWindow(GetDlgItem(hwnd, psh3), bSelected);
    }

    void OnInitMenuPopup(HWND hwnd, HMENU hMenu, UINT item, BOOL fSystemMenu)
    {
        INT iItem = ListView_GetNextItem(m_hLst1, -1, LVNI_ALL | LVNI_SELECTED);
        if (iItem >= 0)
        {
            EnableMenuItem(hMenu, ID_MODIFY, MF_BYCOMMAND | MF_ENABLED);
            EnableMenuItem(hMenu, ID_DELETE, MF_BYCOMMAND | MF_ENABLED);
        }
        else
        {
            EnableMenuItem(hMenu, ID_MODIFY, MF_BYCOMMAND | MF_GRAYED);
            EnableMenuItem(hMenu, ID_DELETE, MF_BYCOMMAND | MF_GRAYED);
        }
        EnableMenuItem(hMenu, ID_RENAME, MF_BYCOMMAND | MF_GRAYED);
    }

    virtual INT_PTR CALLBACK
    DialogProcDx(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
    {
        switch (uMsg)
        {
            HANDLE_MSG(hwnd, WM_INITDIALOG, OnInitDialog);
            HANDLE_MSG(hwnd, WM_COMMAND, OnCommand);
            HANDLE_MSG(hwnd, WM_NOTIFY, OnNotify);
            HANDLE_MSG(hwnd, WM_SIZE, OnSize);
            HANDLE_MSG(hwnd, WM_CONTEXTMENU, OnContextMenu);
            HANDLE_MSG(hwnd, WM_INITMENUPOPUP, OnInitMenuPopup);
        }
        return DefaultProcDx();
    }
};

```

`src/MTabCtrl.hpp`:

```hpp
// MTabCtrl.hpp -- Win32API tab control wrapper                 -*- C++ -*-
// This file is part of MZC4.  See file "ReadMe.txt" and "License.txt".
////////////////////////////////////////////////////////////////////////////

#ifndef MZC4_MTABCTRL_HPP_
#define MZC4_MTABCTRL_HPP_      4   /* Version 4 */

class MTabCtrl;

////////////////////////////////////////////////////////////////////////////

#include "MWindowBase.hpp"

class MTabCtrl : public MWindowBase
{
public:
    MTabCtrl();
    virtual LPCTSTR GetWndClassNameDx() const;

    HIMAGELIST GetImageList() const;
    HIMAGELIST SetImageList(HIMAGELIST hImageList);
    INT GetItemCount() const;

    BOOL GetItem(INT iItem, TCITEM* pTabCtrlItem) const;
    BOOL SetItem(INT iItem, TCITEM* pTabCtrlItem);

    BOOL SetItemExtra(INT nBytes);
    BOOL GetItemRect(INT iItem, LPRECT prc) const;

    INT GetCurSel() const;
    INT SetCurSel(INT iItem);

    SIZE SetItemSize(SIZE size);
    VOID SetPadding(SIZE size);
    INT GetRowCount() const;

    HWND GetToolTips() const;
    VOID SetToolTips(HWND hwndToolTips);

    INT GetCurFocus() const;
    VOID SetCurFocus(INT iItem);

    #if (_WIN32_IE >= 0x0300)
        INT SetMinTabWidth(INT cx);
    #endif  // (_WIN32_IE >= 0x0300)

    #if (_WIN32_IE >= 0x0400)
        DWORD GetExtendedStyle();
        DWORD SetExtendedStyle(DWORD dwNewStyle, DWORD dwExMask = 0);
        BOOL HighlightItem(INT nIndex, BOOL fHighlight = TRUE);
    #endif  // (_WIN32_IE >= 0x0400)

    INT InsertItem(INT iItem, TCITEM* pTabCtrlItem);
    INT InsertItem(INT iItem, LPCTSTR lpszItem);
    INT InsertItem(INT iItem, LPCTSTR lpszItem, INT iImage);
    INT InsertItem(UINT nMask, INT iItem, LPCTSTR lpszItem,
                   INT iImage, LPARAM lParam);
    BOOL DeleteItem(INT iItem);
    BOOL DeleteAllItems();
    VOID AdjustRect(BOOL bLarger, LPRECT prc);
    VOID RemoveImage(INT iImage);
    INT HitTest(TCHITTESTINFO* pHitTestInfo) const;

    #if (_WIN32_IE >= 0x0300)
        VOID DeselectAll(BOOL fExcludeFocus);
    #endif  // (_WIN32_IE >= 0x0300)
};

////////////////////////////////////////////////////////////////////////////

inline MTabCtrl::MTabCtrl()
{
}

inline /*virtual*/ LPCTSTR MTabCtrl::GetWndClassNameDx() const
{
    return WC_TABCONTROL;
}

inline HIMAGELIST MTabCtrl::GetImageList() const
{
    return (HIMAGELIST)SendMessageDx(TCM_GETIMAGELIST);
}

inline HIMAGELIST MTabCtrl::SetImageList(HIMAGELIST hImageList)
{
    return (HIMAGELIST)SendMessageDx(TCM_SETIMAGELIST, 0, (LPARAM)hImageList);
}

inline INT MTabCtrl::GetItemCount() const
{
    return (INT)SendMessageDx(TCM_GETITEMCOUNT);
}

inline BOOL MTabCtrl::GetItem(INT iItem, TCITEM* pTabCtrlItem) const
{
    return (BOOL)SendMessageDx(TCM_GETITEM, (WPARAM)iItem, (LPARAM)pTabCtrlItem);
}

inline BOOL MTabCtrl::SetItem(INT iItem, TCITEM* pTabCtrlItem)
{
    return (BOOL)SendMessageDx(TCM_SETITEM, (WPARAM)iItem, (LPARAM)pTabCtrlItem);
}

inline BOOL MTabCtrl::SetItemExtra(INT nBytes)
{
    assert(GetItemCount() == 0);
    return (BOOL)SendMessageDx(TCM_SETITEMEXTRA, (WPARAM)nBytes);
}

inline BOOL MTabCtrl::GetItemRect(INT iItem, LPRECT prc) const
{
    return (BOOL)SendMessageDx(TCM_GETITEMRECT, (WPARAM)iItem, (LPARAM)prc);
}

inline INT MTabCtrl::GetCurSel() const
{
    return (INT)SendMessageDx(TCM_GETCURSEL);
}

inline INT MTabCtrl::SetCurSel(INT iItem)
{
    return (INT)SendMessageDx(TCM_SETCURSEL, (WPARAM)iItem);
}

inline SIZE MTabCtrl::SetItemSize(SIZE size)
{
    DWORD dwSize = (DWORD)SendMessageDx(TCM_SETITEMSIZE, 0, MAKELPARAM(size.cx, size.cy));
    SIZE ret = { GET_X_LPARAM(dwSize), GET_Y_LPARAM(dwSize) };
    return ret;
}

inline VOID MTabCtrl::SetPadding(SIZE size)
{
    SendMessageDx(TCM_SETPADDING, 0, MAKELPARAM(size.cx, size.cy));
}

inline INT MTabCtrl::GetRowCount() const
{
    return (INT)SendMessageDx(TCM_GETROWCOUNT);
}

inline HWND MTabCtrl::GetToolTips() const
{
    return (HWND)SendMessageDx(TCM_GETTOOLTIPS);
}

inline VOID MTabCtrl::SetToolTips(HWND hwndToolTips)
{
    SendMessageDx(TCM_SETTOOLTIPS, (WPARAM)hwndToolTips);
}

inline INT MTabCtrl::GetCurFocus() const
{
    return (INT)SendMessageDx(TCM_GETCURFOCUS);
}

inline VOID MTabCtrl::SetCurFocus(INT iItem)
{
    SendMessageDx(TCM_SETCURFOCUS, (WPARAM)iItem);
}

#if (_WIN32_IE >= 0x0300)
    inline INT MTabCtrl::SetMinTabWidth(INT cx)
    {
        return (INT)SendMessageDx(TCM_SETMINTABWIDTH, 0, cx);
    }
#endif  // (_WIN32_IE >= 0x0300)

#if (_WIN32_IE >= 0x0400)
    inline DWORD MTabCtrl::GetExtendedStyle()
    {
        return (DWORD)SendMessageDx(TCM_GETEXTENDEDSTYLE);
    }

    inline DWORD MTabCtrl::SetExtendedStyle(
        DWORD dwNewStyle, DWORD dwExMask/* = 0*/)
    {
        return (DWORD)SendMessageDx(TCM_SETEXTENDEDSTYLE, (WPARAM)dwExMask, (LPARAM)dwNewStyle);
    }

    inline BOOL MTabCtrl::HighlightItem(
        INT nIndex, BOOL fHighlight/* = TRUE*/)
    {
        return (BOOL)SendMessageDx(TCM_HIGHLIGHTITEM, (WPARAM)nIndex, MAKELPARAM(fHighlight, 0));
    }
#endif  // (_WIN32_IE >= 0x0400)

inline INT MTabCtrl::InsertItem(INT iItem, TCITEM* pTabCtrlItem)
{
    return (INT)SendMessageDx(TCM_INSERTITEM, (WPARAM)iItem, (LPARAM)pTabCtrlItem);
}

inline INT MTabCtrl::InsertItem(INT iItem, LPCTSTR lpszItem)
{
    return InsertItem(TCIF_TEXT, iItem, lpszItem, 0, 0);
}

inline INT MTabCtrl::InsertItem(INT iItem, LPCTSTR lpszItem, INT iImage)
{
    return InsertItem(TCIF_TEXT | TCIF_IMAGE, iItem, lpszItem, iImage, 0);
}

inline INT MTabCtrl::InsertItem(UINT nMask, INT iItem,
    LPCTSTR lpszItem, INT iImage, LPARAM lParam)
{
    TCITEM tci;
    ZeroMemory(&tci, sizeof(tci));
    tci.mask = nMask;
    tci.pszText = (LPTSTR) lpszItem;
    tci.iImage = iImage;
    tci.lParam = lParam;
    return (INT)SendMessageDx(TCM_INSERTITEM, (WPARAM)iItem, (LPARAM)&tci);
}

inline BOOL MTabCtrl::DeleteItem(INT iItem)
{
    return (BOOL)SendMessageDx(TCM_DELETEITEM, (WPARAM)iItem);
}

inline BOOL MTabCtrl::DeleteAllItems()
{
    return (BOOL)SendMessageDx(TCM_DELETEALLITEMS);
}

inline VOID MTabCtrl::AdjustRect(BOOL bLarger, LPRECT prc)
{
    SendMessageDx(TCM_ADJUSTRECT, (WPARAM)bLarger, (LPARAM)prc);
}

inline VOID MTabCtrl::RemoveImage(INT iImage)
{
    SendMessageDx(TCM_REMOVEIMAGE, (WPARAM)iImage);
}

inline INT MTabCtrl::HitTest(TCHITTESTINFO* pHitTestInfo) const
{
    return (INT)SendMessageDx(TCM_HITTEST, 0, (LPARAM)pHitTestInfo);
}

#if (_WIN32_IE >= 0x0300)
    inline VOID MTabCtrl::DeselectAll(BOOL fExcludeFocus)
    {
        SendMessageDx(TCM_DESELECTALL, (WPARAM)fExcludeFocus);
    }
#endif  // (_WIN32_IE >= 0x0300)

////////////////////////////////////////////////////////////////////////////

#endif  // ndef MZC4_MTABCTRL_HPP_

```

`src/MTestDialog.hpp`:

```hpp
// MTestDialog --- Test Dialog
//////////////////////////////////////////////////////////////////////////////
// RisohEditor --- Another free Win32 resource editor
// Copyright (C) 2017-2018 Katayama Hirofumi MZ <katayama.hirofumi.mz@gmail.com>
// 
// This program is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
// 
// This program is distributed in the hope that it will be useful, 
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
// 
// You should have received a copy of the GNU General Public License
// along with this program.  If not, see <http://www.gnu.org/licenses/>.
//////////////////////////////////////////////////////////////////////////////

#pragma once

#include "MWindowBase.hpp"
#include "MenuRes.hpp"
#include "DialogRes.hpp"
#include "DlgInit.h"
#include "Res.hpp"
#include <map>
#include "MOleHost.hpp"

//////////////////////////////////////////////////////////////////////////////

#ifdef ATL_SUPPORT
template <class StringType, class Helper, typename Helper::ReturnType(WINAPI* pFunc)(HINSTANCE, LPCDLGTEMPLATE, HWND, DLGPROC, LPARAM)>
typename Helper::ReturnType AtlAxDialogCreateIndirectT(
    HINSTANCE hInstance,
    const VOID *pTemplate,
    HWND hWndParent,
    DLGPROC lpDialogProc,
    LPARAM dwInitParam)
{
    AtlAxWinInit();
    typename Helper::ReturnType nRet = Helper::GetInvalidValue();

    DLGTEMPLATE* pDlg = (DLGTEMPLATE*)pTemplate;
    if (pDlg != NULL)
    {
        LPDLGTEMPLATE lpDialogTemplate;
        lpDialogTemplate = _DialogSplitHelper::SplitDialogTemplate(pDlg, NULL);
        nRet = (*pFunc)(hInstance, lpDialogTemplate, hWndParent, lpDialogProc, dwInitParam);
        if ((lpDialogTemplate != pDlg) && (lpDialogTemplate != NULL))
            GlobalFree(GlobalHandle(lpDialogTemplate));
    }
    return nRet;
}
#endif

class MTestDialog : public MDialogBase
{
public:
    DialogRes& m_dialog_res;
    MIdOrString m_menu;
    WORD m_lang;
    HMENU m_hMenu;
    std::vector<BYTE> m_dlginit_data;
    MTitleToBitmap  m_title_to_bitmap;
    MTitleToIcon    m_title_to_icon;
    INT             m_xDialogBaseUnit;
    INT             m_yDialogBaseUnit;
    MOleHost *m_pOleHost;

    MTestDialog(DialogRes& dialog_res, MIdOrString menu, WORD lang, const std::vector<BYTE>& dlginit_data)
        : m_dialog_res(dialog_res), m_menu(menu), 
          m_lang(lang), m_hMenu(NULL), m_dlginit_data(dlginit_data),
          m_pOleHost(NULL)
    {
        m_xDialogBaseUnit = LOWORD(GetDialogBaseUnits());
        m_yDialogBaseUnit = HIWORD(GetDialogBaseUnits());
    }

    BOOL GetBaseUnits(INT& xDialogBaseUnit, INT& yDialogBaseUnit)
    {
        m_xDialogBaseUnit = m_dialog_res.GetBaseUnits(m_yDialogBaseUnit);
        if (m_xDialogBaseUnit == 0)
        {
            return FALSE;
        }

        xDialogBaseUnit = m_xDialogBaseUnit;
        yDialogBaseUnit = m_yDialogBaseUnit;

        return TRUE;
    }

    virtual ~MTestDialog()
    {
        if (m_hMenu)
        {
            DestroyMenu(m_hMenu);
            m_hMenu = NULL;
        }
        clear_maps();
    }

    void clear_maps()
    {
        for (auto& pair : m_title_to_bitmap)
        {
            DeleteObject(pair.second);
        }
        m_title_to_bitmap.clear();

        for (auto& pair : m_title_to_icon)
        {
            DestroyIcon(pair.second);
        }
        m_title_to_icon.clear();
    }

    void create_maps(WORD lang)
    {
        for (size_t i = 0; i < m_dialog_res.size(); ++i)
        {
            DialogItem& item = m_dialog_res[i];
            if (item.m_class == 0x0082 ||
                lstrcmpiW(item.m_class.c_str(), L"STATIC") == 0)
            {
                // static
                if ((item.m_style & SS_TYPEMASK) == SS_ICON)
                {
                    g_res.do_icon(m_title_to_icon, item, lang);
                }
                else if ((item.m_style & SS_TYPEMASK) == SS_BITMAP)
                {
                    g_res.do_bitmap(m_title_to_bitmap, item, lang);
                }
            }
        }
    }

    BOOL OnInitDialog(HWND hwnd, HWND hwndFocus, LPARAM lParam)
    {
        if (m_pOleHost)
            m_pOleHost->DoEnableMenu(TRUE);

        if (m_hMenu)
        {
            SetMenu(hwnd, NULL);
            DestroyMenu(m_hMenu);
            m_hMenu = NULL;
        }
        if (!m_menu.empty())
        {
            if (auto entry = g_res.find(ET_LANG, RT_MENU, m_menu, m_lang))
            {
                m_hMenu = LoadMenuIndirect(&(*entry)[0]);
                SetMenu(hwnd, m_hMenu);

                INT cyMenu = GetSystemMetrics(SM_CYMENU);
                RECT rc;
                GetWindowRect(hwnd, &rc);
                rc.bottom += cyMenu;
                SIZE siz = SizeFromRectDx(&rc);
                SetWindowPosDx(NULL, &siz);
            }
        }

        create_maps(0xFFFF);

        GetBaseUnits(m_xDialogBaseUnit, m_yDialogBaseUnit);

        INT i = 0;
        for (HWND hCtrl = GetTopWindow(hwnd);
             hCtrl; hCtrl = GetNextWindow(hCtrl, GW_HWNDNEXT))
        {
            DWORD style = GetWindowStyle(hCtrl);
            SIZE siz = { 0, 0 };
            GetWindowPosDx(hCtrl, NULL, &siz);

            WCHAR szClass[32];
            GetClassNameW(hCtrl, szClass, 32);
            if (lstrcmpiW(szClass, L"STATIC") == 0)
            {
                MIdOrString title = m_dialog_res[i].m_title;
                if ((style & SS_TYPEMASK) == SS_ICON)
                {
                    HICON hIcon = m_title_to_icon[title];
                    SendMessage(hCtrl, STM_SETIMAGE, IMAGE_ICON, (LPARAM)hIcon);
                    if (style & SS_REALSIZEIMAGE)
                    {
                        ICONINFO info;
                        GetIconInfo(hIcon, &info);
                        BITMAP bm;
                        GetObject(info.hbmColor, sizeof(BITMAP), &bm);
                        siz.cx = bm.bmWidth;
                        siz.cy = bm.bmHeight;
                    }
                    else if (style & SS_REALSIZECONTROL)
                    {
                        siz.cx = m_dialog_res[i].m_siz.cx * m_xDialogBaseUnit / 4;
                        siz.cy = m_dialog_res[i].m_siz.cy * m_yDialogBaseUnit / 8;
                    }
                    SetWindowPosDx(hCtrl, NULL, &siz);
                }
                else if ((style & SS_TYPEMASK) == SS_BITMAP)
                {
                    HBITMAP hbm = m_title_to_bitmap[title];
                    SendMessage(hCtrl, STM_SETIMAGE, IMAGE_BITMAP, (LPARAM)hbm);
                    if (style & SS_REALSIZECONTROL)
                    {
                        siz.cx = m_dialog_res[i].m_siz.cx * m_xDialogBaseUnit / 4;
                        siz.cy = m_dialog_res[i].m_siz.cy * m_yDialogBaseUnit / 8;
                    }
                    else
                    {
                        BITMAP bm;
                        GetObject(hbm, sizeof(BITMAP), &bm);
                        siz.cx = bm.bmWidth;
                        siz.cy = bm.bmHeight;
                    }
                    SetWindowPosDx(hCtrl, NULL, &siz);
                }
            }

            ++i;
        }

        if (m_bModal)
            CenterWindowDx();

        if (m_dlginit_data.size())
        {
            SIZE_T siz = m_dlginit_data.size();
            ExecuteDlgInitDataDx(hwnd, &m_dlginit_data[0], siz);
        }
        return TRUE;
    }

    void Destroy(HWND hwnd)
    {
        PostMessage(GetParent(hwnd), WM_COMMAND, ID_CHILDDESTROYED, 0);
        if (m_bModal)
            EndDialog(IDOK);
        else
            DestroyWindow(*this);

        if (m_pOleHost)
        {
            delete m_pOleHost;
            m_pOleHost = NULL;
        }
    }

    virtual INT_PTR CALLBACK
    DialogProcDx(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
    {
        DWORD dwStyle;
        switch (uMsg)
        {
            HANDLE_MSG(hwnd, WM_INITDIALOG, OnInitDialog);
        case WM_LBUTTONDOWN:
            dwStyle = GetWindowStyle(hwnd);
            if (!(dwStyle & WS_SYSMENU))
            {
                Destroy(hwnd);
            }
            break;
        case WM_LBUTTONDBLCLK:
            Destroy(hwnd);
            break;
        case WM_COMMAND:
            switch (LOWORD(wParam))
            {
            case IDOK: case IDCANCEL:
                Destroy(hwnd);
                break;
            }
            break;
        }
        return DefaultProcDx();
    }

    INT_PTR DialogBoxIndirectDx(HWND hwndOwner, const VOID* ptr)
    {
        if (hwndOwner)
        {
            m_hwndOwner = hwndOwner;
        }

        if (m_pOleHost)
        {
            delete m_pOleHost;
            m_pOleHost = NULL;
        }
        m_pOleHost = new MOleHost();
        DoSetActiveOleHost(m_pOleHost);

        m_bModal = TRUE;
#ifdef ATL_SUPPORT
        INT_PTR nID = AtlAxDialogCreateIndirectT<LPCWSTR, _AtlDialogBoxIndirectParamHelper, ::DialogBoxIndirectParamW>(
            ::GetModuleHandle(NULL), ptr, m_hwndOwner, MDialogBase::DialogProc, reinterpret_cast<LPARAM>(this));
#else
        INT_PTR nID = ::DialogBoxIndirectParam(::GetModuleHandle(NULL),
            (const DLGTEMPLATE*)ptr,
            m_hwndOwner,
            MDialogBase::DialogProc,
            reinterpret_cast<LPARAM>(this));
#endif
        if (m_pOleHost)
        {
            delete m_pOleHost;
            m_pOleHost = NULL;
        }
        return nID;
    }

    inline BOOL CreateDialogIndirectDx(HWND hwndOwner, const VOID *ptr)
    {
        if (hwndOwner)
        {
            m_hwndOwner = hwndOwner;
        }

        if (m_pOleHost)
        {
            delete m_pOleHost;
            m_pOleHost = NULL;
        }
        m_pOleHost = new MOleHost();
        DoSetActiveOleHost(m_pOleHost);

        m_bModal = FALSE;
#ifdef ATL_SUPPORT
        HWND hwnd;
        hwnd = AtlAxDialogCreateIndirectT<LPCWSTR, _AtlCreateDialogIndirectParamHelper, ::CreateDialogIndirectParamW>(
            ::GetModuleHandle(NULL), ptr, m_hwndOwner, MDialogBase::DialogProc, reinterpret_cast<LPARAM>(this));
#else
        HWND hwnd = ::CreateDialogIndirectParam(::GetModuleHandle(NULL), 
            reinterpret_cast<const DLGTEMPLATE *>(ptr), 
            m_hwndOwner, MDialogBase::DialogProc, 
            reinterpret_cast<LPARAM>(this));
#endif
        if (hwnd == NULL)
        {
            Detach();
        }
        return hwnd != NULL;
    }
};

```

`src/MTestMenuDlg.hpp`:

```hpp
// MTestMenuDlg.hpp --- "Test Menu" Dialog
//////////////////////////////////////////////////////////////////////////////
// RisohEditor --- Another free Win32 resource editor
// Copyright (C) 2017-2018 Katayama Hirofumi MZ <katayama.hirofumi.mz@gmail.com>
// 
// This program is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
// 
// This program is distributed in the hope that it will be useful, 
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
// 
// You should have received a copy of the GNU General Public License
// along with this program.  If not, see <http://www.gnu.org/licenses/>.
//////////////////////////////////////////////////////////////////////////////

#pragma once

#include "MWindowBase.hpp"

//////////////////////////////////////////////////////////////////////////////

class MTestMenuDlg : public MDialogBase
{
public:
    HMENU m_hMenu;

    MTestMenuDlg(HMENU hMenu) : m_hMenu(hMenu)
    {
    }

    BOOL OnInitDialog(HWND hwnd, HWND hwndFocus, LPARAM lParam)
    {
        SetMenu(hwnd, m_hMenu);
        CenterWindowDx();
        return TRUE;
    }

    void OnCommand(HWND hwnd, int id, HWND hwndCtl, UINT codeNotify)
    {
        switch (id)
        {
        case IDOK: case IDCANCEL:
            EndDialog(id);
            break;
        }
    }

    virtual INT_PTR CALLBACK
    DialogProcDx(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
    {
        switch (uMsg)
        {
            HANDLE_MSG(hwnd, WM_INITDIALOG, OnInitDialog);
            HANDLE_MSG(hwnd, WM_COMMAND, OnCommand);
        }
        return DefaultProcDx();
    }
};

```

`src/MTestParentWnd.hpp`:

```hpp
// MTestParentWnd.hpp --- Test Parent Window
//////////////////////////////////////////////////////////////////////////////
// RisohEditor --- Another free Win32 resource editor
// Copyright (C) 2017-2018 Katayama Hirofumi MZ <katayama.hirofumi.mz@gmail.com>
// 
// This program is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
// 
// This program is distributed in the hope that it will be useful, 
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
// 
// You should have received a copy of the GNU General Public License
// along with this program.  If not, see <http://www.gnu.org/licenses/>.
//////////////////////////////////////////////////////////////////////////////

#pragma once

#include "MTestDialog.hpp"
#include "MByteStreamEx.hpp"

//////////////////////////////////////////////////////////////////////////////

class MTestParentWnd : public MWindowBase
{
public:
    MTestDialog m_test_dialog;
    MByteStreamEx m_stream;
    HICON m_hIcon;
    HICON m_hIconSm;

    MTestParentWnd(DialogRes& dialog_res, 
                   MIdOrString menu, WORD lang, const MByteStreamEx& stream, 
                   const std::vector<BYTE>& dlginit_data)
        : m_test_dialog(dialog_res, menu, lang, dlginit_data), m_stream(stream)
    {
        m_hIcon = LoadIconDx(IDI_SMILY);
        m_hIconSm = LoadSmallIconDx(IDI_SMILY);
    }

    virtual ~MTestParentWnd()
    {
        DestroyIcon(m_hIcon);
        DestroyIcon(m_hIconSm);
    }

    virtual void PostNcDestroy()
    {
        delete this;
    }

    virtual LPCTSTR GetWndClassNameDx() const
    {
        return TEXT("MZC4 MTestParentWnd Class");
    }

    virtual VOID ModifyWndClassDx(WNDCLASSEX& wcx)
    {
    }

    BOOL OnCreate(HWND hwnd, LPCREATESTRUCT lpCreateStruct)
    {
        m_test_dialog.CreateDialogIndirectDx(hwnd, m_stream.ptr());

        RECT rc;
        GetWindowRect(m_test_dialog, &rc);
        AdjustWindowRectEx(&rc, GetWindowStyle(hwnd), FALSE, GetWindowExStyle(hwnd));
        POINT pt = { 0, 0 };
        SIZE siz = SizeFromRectDx(&rc);
        SetWindowPosDx(&pt, &siz);
        m_test_dialog.SetWindowPosDx(&pt);

        ShowWindow(m_test_dialog, SW_SHOWNORMAL);
        UpdateWindow(m_test_dialog);

        SendMessage(hwnd, WM_SETICON, ICON_BIG, (LPARAM)m_hIcon);
        SendMessage(hwnd, WM_SETICON, ICON_SMALL, (LPARAM)m_hIconSm);

        CenterWindowDx();

        return TRUE;
    }

    void OnCommand(HWND hwnd, int id, HWND hwndCtl, UINT codeNotify)
    {
        if (id == ID_CHILDDESTROYED)
        {
            DestroyWindow(hwnd);
        }
    }

    virtual LRESULT CALLBACK
    WindowProcDx(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
    {
        switch (uMsg)
        {
        HANDLE_MSG(hwnd, WM_CREATE, OnCreate);
        HANDLE_MSG(hwnd, WM_COMMAND, OnCommand);
        default:
            return DefaultProcDx();
        }
        return 0;
    }
};

```

`src/MTextToText.hpp`:

```hpp
// MTextToText.hpp -- text encoding conversion                  -*- C++ -*-
// This file is part of MZC4.  See file "ReadMe.txt" and "License.txt".
////////////////////////////////////////////////////////////////////////////

#ifndef MZC4_MTEXTTOTEXT_HPP_
#define MZC4_MTEXTTOTEXT_HPP_       6       /* Version 6 */

class MAnsiToWide;
class MWideToAnsi;

////////////////////////////////////////////////////////////////////////////

#include "MString.hpp"

#include <cassert>

////////////////////////////////////////////////////////////////////////////

class MAnsiToWide
{
public:
    MAnsiToWide()
    {
    }
    MAnsiToWide(int codepage, const char *str)
    {
        do_it(codepage, str, mstrlen(str));
    }
    MAnsiToWide(int codepage, const char *str, size_t count)
    {
        do_it(codepage, str, count);
    }
    MAnsiToWide(int codepage, const MStringA& str)
    {
        do_it(codepage, str.c_str(), str.size());
    }
    MAnsiToWide(int codepage, const MAnsiToWide& str) : m_str(str.m_str) { }

    MAnsiToWide& operator=(const MAnsiToWide& str)
    {
        m_str = str.m_str;
        return *this;
    }

    bool empty() const
    {
        return m_str.empty();
    }

    size_t size() const
    {
        return m_str.size();
    }

    WCHAR *data()
    {
        return &m_str[0];
    }

    const WCHAR *c_str() const
    {
        return m_str.c_str();
    }

    operator const WCHAR *() const
    {
        return c_str();
    }

    const MStringW& str() const
    {
        return m_str;
    }

    MStringW& str()
    {
        return m_str;
    }

protected:
    MStringW m_str;
    void do_it(int codepage, const char *str, size_t count);
};

////////////////////////////////////////////////////////////////////////////

class MWideToAnsi
{
public:
    MWideToAnsi()
    {
    }
    MWideToAnsi(int codepage, const WCHAR *str)
    {
        do_it(codepage, str, mstrlen(str));
    }
    MWideToAnsi(int codepage, const WCHAR *str, size_t count)
    {
        do_it(codepage, str, count);
    }
    MWideToAnsi(int codepage, const MStringW& str)
    {
        do_it(codepage, str.c_str(), str.size());
    }
    MWideToAnsi(int codepage, const MWideToAnsi& str) : m_str(str.m_str) { }

    MWideToAnsi& operator=(const MWideToAnsi& str)
    {
        m_str = str.m_str;
        return *this;
    }

    bool empty() const
    {
        return m_str.empty();
    }

    size_t size() const
    {
        return m_str.size();
    }

    char *data()
    {
        return &m_str[0];
    }

    const char *c_str() const
    {
        return m_str.c_str();
    }

    operator const char *() const
    {
        return c_str();
    }

    const MStringA& str() const
    {
        return m_str;
    }

    MStringA& str()
    {
        return m_str;
    }

protected:
    MStringA m_str;
    void do_it(int codepage, const WCHAR *str, size_t count);
};

////////////////////////////////////////////////////////////////////////////

#define MAnsiToAnsi(cp,ansi)   MStringA(ansi)
#define MWideToWide(cp,wide)   MStringW(wide)

#ifdef UNICODE
    #define MAnsiToText MAnsiToWide
    #define MTextToAnsi MWideToAnsi
    #define MWideToText MWideToWide
    #define MTextToWide MWideToWide
    #define MTextToText MWideToWide
#else
    #define MAnsiToText MAnsiToAnsi
    #define MTextToAnsi MAnsiToAnsi
    #define MWideToText MWideToAnsi
    #define MTextToWide MAnsiToWide
    #define MTextToText MAnsiToAnsi
#endif

////////////////////////////////////////////////////////////////////////////

#if defined(_WIN32) && !defined(WONVER)
    inline void
    MAnsiToWide::do_it(int codepage, const char *str, size_t count)
    {
        int len = int(count);
        int cch = ::MultiByteToWideChar(codepage, 0, str, len, NULL, 0);
        m_str.resize(cch);
        if (!::MultiByteToWideChar(codepage, 0, str, len, &m_str[0], cch + 1))
        {
            m_str.clear();
        }
    }

    inline void
    MWideToAnsi::do_it(int codepage, const WCHAR *str, size_t count)
    {
        int len = int(count);
        int cch = ::WideCharToMultiByte(codepage, 0, str, len, NULL, 0, NULL, NULL);
        m_str.resize(cch);
        if (!::WideCharToMultiByte(codepage, 0, str, len, &m_str[0], cch + 1,
                                   NULL, NULL))
        {
            m_str.clear();
        }
    }
#else
    #include <iconv.h>

    #ifndef WonGetACP
        #define WonGetACP()     1252
    #endif
    #ifndef WonGetOEMCP
        #define WonGetOEMCP()   437
    #endif

    #ifndef CP_ACP
        #define CP_ACP          WonGetACP()
    #endif
    #ifndef CP_OEMCP
        #define CP_OEMCP        WonGetOEMCP()
    #endif
    #ifndef CP_UTF8
        #define CP_UTF8         65001   // UTF-8
    #endif

    namespace text2text
    {
        inline const char *get_wide_encoding(void)
        {
            switch (sizeof(WCHAR))
            {
            case 1:
                return "UTF-8";
            case 2:
                return "UCS-2LE";
            case 4:
                return "UCS-4LE";
            default:
                assert(0);
                return NULL;
            }
        }

        inline std::string encoding_from_cp(int codepage)
        {
            if (codepage == CP_ACP)
                codepage = WonGetACP();
            else if (codepage == CP_OEMCP)
                codepage = WonGetOEMCP();

            std::string ret;
            switch (codepage)
            {
            case CP_UTF8:
                ret = "UTF-8";
                break;
            case 932:
                ret = "SHIFT_JIS";
                break;
            case 1252:
                ret = "ISO-8859-1";
                break;
            default:
                mstr_to_dec(ret, codepage, false);
                ret = "CP" + ret;
            }
            return ret;
        }
    }

    inline void
    MAnsiToWide::do_it(int codepage, const char *str, size_t count)
    {
        m_str.clear();
        if (*str == 0)
            return;

        iconv_t ic = iconv_open(text2text::get_wide_encoding(),
                                text2text::encoding_from_cp(codepage).c_str());
        if ((iconv_t)-1 == ic)
            return;

        size_t ansi_len = count * sizeof(char);
        #ifdef ICONV_SECOND_ARGUMENT_IS_CONST
            const char *ansi_ptr  = str;
        #else
            char *ansi_ptr  = const_cast<char *>(str);
        #endif

        size_t buf_len = (count + 1) * sizeof(WCHAR);
        if (char *buf = (char *)malloc(buf_len))
        {
            size_t wide_len = buf_len;
            char *wide_ptr = buf;
            if (buf && (size_t)-1 != iconv(ic, &ansi_ptr, &ansi_len, &wide_ptr, &wide_len))
            {
                wide_len = buf_len - wide_len;
                m_str.assign(reinterpret_cast<WCHAR *>(buf), wide_len / sizeof(WCHAR));
            }
            free(buf);
        }

        iconv_close(ic);
    }

    inline void
    MWideToAnsi::do_it(int codepage, const WCHAR *str, size_t count)
    {
        m_str.clear();
        if (*str == 0)
            return;

        iconv_t ic = iconv_open(text2text::encoding_from_cp(codepage).c_str(),
                                text2text::get_wide_encoding());
        if ((iconv_t)-1 == ic)
            return;

        size_t wide_len = count * sizeof(WCHAR);
        #ifdef ICONV_SECOND_ARGUMENT_IS_CONST
            const char *wide_ptr  = reinterpret_cast<const char *>(str);
        #else
            char *wide_ptr  = reinterpret_cast<char *>(const_cast<WCHAR *>(str));
        #endif

        size_t buf_len = (count + 1) * 3;
        if (char *buf = (char *)malloc(buf_len))
        {
            size_t ansi_len = buf_len;
            char *ansi_ptr = buf;
            if (buf && (size_t)-1 != iconv(ic, &wide_ptr, &wide_len, &ansi_ptr, &ansi_len))
            {
                ansi_len = buf_len - ansi_len;
                m_str.assign(buf, ansi_len / sizeof(char));
            }
            free(buf);
        }

        iconv_close(ic);
    }
#endif

////////////////////////////////////////////////////////////////////////////

#endif  // ndef MZC4_MTEXTTOTEXT_HPP_

```

`src/MToolBarCtrl.hpp`:

```hpp
// MToolBarCtrl.hpp -- Win32API tool bar control wrapper        -*- C++ -*-
// This file is part of MZC4.  See file "ReadMe.txt" and "License.txt".
////////////////////////////////////////////////////////////////////////////

#ifndef MZC4_MTOOLBARCTRL_HPP_
#define MZC4_MTOOLBARCTRL_HPP_      5   /* Version 5 */

class MToolBarCtrl;

////////////////////////////////////////////////////////////////////////////

#include "MWindowBase.hpp"

class MToolBarCtrl : public MWindowBase
{
public:
    MToolBarCtrl();
    virtual LPCTSTR GetWndClassNameDx() const;

    virtual HWND SetParent(HWND hWndNewParent);

    BOOL IsButtonEnabled(INT nButtonID) const;
    BOOL IsButtonChecked(INT nButtonID) const;
    BOOL IsButtonPressed(INT nButtonID) const;
    BOOL IsButtonHidden(INT nButtonID) const;
    BOOL IsButtonIndeterminate(INT nButtonID) const;
    #if (_WIN32_IE >= 0x0400)
        BOOL IsButtonHighlighted(INT nButtonID) const;
    #endif  // (_WIN32_IE >= 0x0400)

    INT GetState(INT nButtonID) const;
    BOOL SetState(INT nButtonID, UINT nTBSTATE_flags);

    BOOL GetButton(INT nIndex, LPTBBUTTON lpButton) const;
    BOOL SetButton(INT nIndex, CONST TBBUTTON *lpButton);
    INT GetButtonCount() const;
    BOOL GetItemRect(INT nIndex, LPRECT prc) const;
    VOID SetButtonStructSize(INT nSize);

    #if (_WIN32_IE >= 0x0300)
        BOOL GetRect(INT nButtonID, LPRECT prc) const;

        SIZE GetButtonSize() const;
    #endif  // (_WIN32_IE >= 0x0300)

    BOOL SetButtonSize(SIZE size);

    BOOL SetBitmapSize(SIZE size);

    HWND GetToolTips() const;
    VOID SetToolTips(HWND hwndTT);

    INT GetRows() const;
    VOID SetRows(INT nRows, BOOL bLarger, LPRECT prc);
    BOOL SetCmdID(INT nIndex, UINT nCommandID);
    UINT GetBitmapFlags() const;

    #if (_WIN32_IE >= 0x0300)
        INT GetTextRows() const;

        DWORD GetStyle() const;
        VOID SetStyle(DWORD dwStyle);

        BOOL SetButtonWidth(INT cxMin, INT cxMax);

        HIMAGELIST GetImageList(INT nIndex = 0) const;
        HIMAGELIST SetImageList(HIMAGELIST hImageList, INT nIndex = 0);

        HIMAGELIST GetDisabledImageList(INT nIndex = 0) const;
        HIMAGELIST SetDisabledImageList(HIMAGELIST hImageList, INT nIndex = 0);

        HIMAGELIST GetHotImageList(INT nIndex = 0) const;
        HIMAGELIST SetHotImageList(HIMAGELIST hImageList, INT nIndex = 0);

        BOOL SetIndent(INT iIndent);
        BOOL SetMaxTextRows(INT iMaxRows);
    #endif  // (_WIN32_IE >= 0x0300)

    #if (_WIN32_IE >= 0x400)
        BOOL GetButtonInfo(INT nButtonID, TBBUTTONINFO* ptbbi) const;
        BOOL SetButtonInfo(INT nButtonID, TBBUTTONINFO* ptbbi);

        DWORD SetDrawTextFlags(DWORD dwMask, DWORD dwDTFlags);

        BOOL GetAnchorHighlight() const;
        BOOL SetAnchorHighlight(BOOL bEnable = TRUE);

        INT GetHotItem() const;
        INT SetHotItem(INT nIndex);

        VOID GetInsertMark(TBINSERTMARK* ptbim) const;
        VOID SetInsertMark(TBINSERTMARK* ptbim);
        BOOL InsertMarkHitTest(LPPOINT ppt, LPTBINSERTMARK ptbim) const;
        COLORREF GetInsertMarkColor() const;
        COLORREF SetInsertMarkColor(COLORREF clrNew);

        BOOL GetMaxSize(LPSIZE pSize) const;

        DWORD GetExtendedStyle() const;
        DWORD SetExtendedStyle(DWORD dwExStyle);
    #endif  // (_WIN32_IE >= 0x400)

    BOOL EnableButton(INT nButtonID, BOOL bEnable = TRUE);
    BOOL CheckButton(INT nButtonID, BOOL bCheck = TRUE);
    BOOL PressButton(INT nButtonID, BOOL bPress = TRUE);
    BOOL HideButton(INT nButtonID, BOOL bHide = TRUE);
    BOOL Indeterminate(INT nButtonID, BOOL bIndeterminate = TRUE);
    INT AddBitmap(INT nNumButtons, UINT nBitmapID);
    INT AddBitmap(INT nNumButtons, HBITMAP hBitmap);
    BOOL AddButtons(INT nNumButtons, LPTBBUTTON lpButtons);
    BOOL InsertButton(INT nIndex, CONST TBBUTTON *lpButton);
    BOOL DeleteButton(INT nIndex);
    UINT CommandToIndex(UINT nCommandID) const;
    VOID SaveState(HKEY hKeyRoot, LPCTSTR lpszSubKey, 
        LPCTSTR lpszValueName);
    VOID RestoreState(HKEY hKeyRoot, LPCTSTR lpszSubKey, 
        LPCTSTR lpszValueName);

    #if (_WIN32_IE >= 0x0300)
        VOID LoadImages(INT iBitmapID, HINSTANCE hinst = ::GetModuleHandle(NULL));
    #endif  // (_WIN32_IE >= 0x0300)

    #if (_WIN32_IE >= 0x0400)
        BOOL MapAccelerator(TCHAR chAccel, UINT* pIDBtn);
        BOOL MarkButton(INT nButtonID, BOOL fHighlight = TRUE);
        BOOL MoveButton(UINT nOldPos, UINT nNewPos);
        INT HitTest(LPPOINT ppt) const;
    #endif  // (_WIN32_IE >= 0x0400)

    VOID Customize();
    INT AddString(UINT nStringID);
    INT AddStrings(LPCTSTR pszzStrings);
    VOID AutoSize();
};

////////////////////////////////////////////////////////////////////////////

inline MToolBarCtrl::MToolBarCtrl()
{
}

inline /*virtual*/ LPCTSTR MToolBarCtrl::GetWndClassNameDx() const
{
    return TOOLBARCLASSNAME;
}

inline /*virtual*/ HWND MToolBarCtrl::SetParent(HWND hWndNewParent)
{
    HWND hwndOldParent = ::GetParent(m_hwnd);
    SendMessageDx(TB_SETPARENT, (WPARAM)hWndNewParent);
    return hwndOldParent;
}

inline BOOL MToolBarCtrl::IsButtonEnabled(INT nButtonID) const
{
    return (BOOL)SendMessageDx(TB_ISBUTTONENABLED, (WPARAM)nButtonID);
}

inline BOOL MToolBarCtrl::IsButtonChecked(INT nButtonID) const
{
    return (BOOL)SendMessageDx(TB_ISBUTTONCHECKED, (WPARAM)nButtonID);
}

inline BOOL MToolBarCtrl::IsButtonPressed(INT nButtonID) const
{
    return (BOOL)SendMessageDx(TB_ISBUTTONPRESSED, (WPARAM)nButtonID);
}

inline BOOL MToolBarCtrl::IsButtonHidden(INT nButtonID) const
{
    return (BOOL)SendMessageDx(TB_ISBUTTONHIDDEN, (WPARAM)nButtonID);
}

inline BOOL MToolBarCtrl::IsButtonIndeterminate(INT nButtonID) const
{
    return (BOOL)SendMessageDx(TB_ISBUTTONINDETERMINATE, (WPARAM)nButtonID);
}
#if (_WIN32_IE >= 0x0400)

    inline BOOL MToolBarCtrl::IsButtonHighlighted(INT nButtonID) const
    {
        return (BOOL)SendMessageDx(TB_ISBUTTONHIGHLIGHTED, (WPARAM)nButtonID);
    }
#endif  // (_WIN32_IE >= 0x0400)

inline INT MToolBarCtrl::GetState(INT nButtonID) const
{
    return (INT)SendMessageDx(TB_GETSTATE, (WPARAM)nButtonID);
}

inline BOOL MToolBarCtrl::SetState(INT nButtonID, UINT nTBSTATE_flags)
{
    return (BOOL)SendMessageDx(TB_SETSTATE, (WPARAM)nButtonID, MAKELPARAM(nTBSTATE_flags, 0));
}

inline BOOL MToolBarCtrl::GetButton(INT nIndex, LPTBBUTTON lpButton) const
{
    return (BOOL)SendMessageDx(TB_GETBUTTON, (WPARAM)nIndex, (LPARAM)lpButton);
}

inline BOOL MToolBarCtrl::SetButton(INT nIndex, CONST TBBUTTON *lpButton)
{
    return DeleteButton(nIndex) && InsertButton(nIndex, lpButton);
}

inline INT MToolBarCtrl::GetButtonCount() const
{
    return (INT)SendMessageDx(TB_BUTTONCOUNT);
}

inline BOOL MToolBarCtrl::GetItemRect(INT nIndex, LPRECT prc) const
{
    return (BOOL)SendMessageDx(TB_GETITEMRECT, (WPARAM)nIndex, (LPARAM)prc);
}

inline VOID MToolBarCtrl::SetButtonStructSize(INT nSize)
{
    SendMessageDx(TB_BUTTONSTRUCTSIZE, (WPARAM)nSize);
}

#if (_WIN32_IE >= 0x0300)
    inline BOOL MToolBarCtrl::GetRect(INT nButtonID, LPRECT prc) const
    {
        return (BOOL)SendMessageDx(TB_GETRECT, (WPARAM)nButtonID, (LPARAM)prc);
    }

    inline SIZE MToolBarCtrl::GetButtonSize() const
    {
        SIZE siz;
        DWORD dw = (DWORD)SendMessageDx(TB_GETBUTTONSIZE);
        siz.cx = (SHORT)LOWORD(dw);
        siz.cy = (SHORT)HIWORD(dw);
        return siz;
    }
#endif  // (_WIN32_IE >= 0x0300)

inline BOOL MToolBarCtrl::SetButtonSize(SIZE size)
{
    return (BOOL)SendMessageDx(TB_SETBUTTONSIZE, 0, MAKELPARAM(size.cx, size.cy));
}

inline BOOL MToolBarCtrl::SetBitmapSize(SIZE size)
{
    return (BOOL)SendMessageDx(TB_SETBITMAPSIZE, 0, MAKELPARAM(size.cx, size.cy));
}

inline HWND MToolBarCtrl::GetToolTips() const
{
    return (HWND)SendMessageDx(TB_GETTOOLTIPS);
}

inline VOID MToolBarCtrl::SetToolTips(HWND hwndTT)
{
    SendMessageDx(TB_SETTOOLTIPS, (WPARAM)hwndTT);
}

inline INT MToolBarCtrl::GetRows() const
{
    return (INT)SendMessageDx(TB_GETROWS);
}

inline VOID MToolBarCtrl::SetRows(INT nRows, BOOL bLarger, LPRECT prc)
{
    SendMessageDx(TB_SETROWS, MAKEWPARAM(nRows, bLarger), (LPARAM)prc);
}

inline BOOL MToolBarCtrl::SetCmdID(INT nIndex, UINT nCommandID)
{
    return (BOOL)SendMessageDx(TB_SETCMDID, (WPARAM)nIndex, (LPARAM)nCommandID);
}

inline UINT MToolBarCtrl::GetBitmapFlags() const
{
    return (DWORD)SendMessageDx(TB_GETBITMAPFLAGS);
}

#if (_WIN32_IE >= 0x0300)
    inline INT MToolBarCtrl::GetTextRows() const
    {
        return (INT)SendMessageDx(TB_GETTEXTROWS);
    }

    inline DWORD MToolBarCtrl::GetStyle() const
    {
        return (DWORD)SendMessageDx(TB_GETSTYLE);
    }

    inline VOID MToolBarCtrl::SetStyle(DWORD dwStyle)
    {
        SendMessageDx(TB_SETSTYLE, 0, (LPARAM)dwStyle);
    }

    inline BOOL MToolBarCtrl::SetButtonWidth(INT cxMin, INT cxMax)
    {
        return (BOOL)SendMessageDx(TB_SETBUTTONWIDTH, 0, MAKELPARAM(cxMin, cxMax));
    }

    inline HIMAGELIST
    MToolBarCtrl::GetImageList(INT nIndex/* = 0*/) const
    {
        return (HIMAGELIST)SendMessageDx(TB_GETIMAGELIST, (WPARAM)nIndex);
    }

    inline HIMAGELIST
    MToolBarCtrl::SetImageList(HIMAGELIST hImageList, INT nIndex/* = 0*/)
    {
        return (HIMAGELIST)SendMessageDx(TB_SETIMAGELIST, (WPARAM)nIndex, (LPARAM)hImageList);
    }

    inline HIMAGELIST MToolBarCtrl::GetDisabledImageList(
        INT nIndex/* = 0*/) const
    {
        return (HIMAGELIST)SendMessageDx(TB_GETDISABLEDIMAGELIST, (WPARAM)nIndex);
    }

    inline HIMAGELIST MToolBarCtrl::SetDisabledImageList(
        HIMAGELIST hImageList, INT nIndex/* = 0*/)
    {
        return (HIMAGELIST)SendMessageDx(TB_SETDISABLEDIMAGELIST, (WPARAM)nIndex, (LPARAM)hImageList);
    }

    inline HIMAGELIST
    MToolBarCtrl::GetHotImageList(INT nIndex/* = 0*/) const
    {
        return (HIMAGELIST)SendMessageDx(TB_GETHOTIMAGELIST, (WPARAM)nIndex);
    }

    inline HIMAGELIST
    MToolBarCtrl::SetHotImageList(HIMAGELIST hImageList, INT nIndex/* = 0*/)
    {
        return (HIMAGELIST)SendMessageDx(TB_SETHOTIMAGELIST, (WPARAM)nIndex, (LPARAM)hImageList);
    }

    inline BOOL MToolBarCtrl::SetIndent(INT iIndent)
    {
        return (BOOL)SendMessageDx(TB_SETINDENT, (WPARAM)iIndent);
    }

    inline BOOL MToolBarCtrl::SetMaxTextRows(INT iMaxRows)
    {
        return (BOOL)SendMessageDx(TB_SETMAXTEXTROWS, (WPARAM)iMaxRows);
    }
#endif  // (_WIN32_IE >= 0x0300)

#if (_WIN32_IE >= 0x400)
    inline BOOL MToolBarCtrl::GetButtonInfo(
        INT nButtonID, TBBUTTONINFO* ptbbi) const
    {
        return (INT)SendMessageDx(TB_GETBUTTONINFO, (WPARAM)nButtonID, (LPARAM)ptbbi);
    }

    inline BOOL MToolBarCtrl::SetButtonInfo(
        INT nButtonID, TBBUTTONINFO* ptbbi)
    {
        return (BOOL)SendMessageDx(TB_SETBUTTONINFO, (WPARAM)nButtonID, (LPARAM)ptbbi);
    }

    inline DWORD MToolBarCtrl::SetDrawTextFlags(
        DWORD dwMask, DWORD dwDTFlags)
    {
        return (DWORD)SendMessageDx(TB_SETDRAWTEXTFLAGS, (WPARAM)dwMask, (LPARAM)dwDTFlags);
    }

    inline BOOL MToolBarCtrl::GetAnchorHighlight() const
    {
        return (BOOL)SendMessageDx(TB_GETANCHORHIGHLIGHT);
    }

    inline BOOL MToolBarCtrl::SetAnchorHighlight(
        BOOL bEnable/* = TRUE*/)
    {
        return (BOOL)SendMessageDx(TB_SETANCHORHIGHLIGHT, (WPARAM)bEnable);
    }

    inline INT MToolBarCtrl::GetHotItem() const
    {
        return (INT)SendMessageDx(TB_GETHOTITEM);
    }

    inline INT MToolBarCtrl::SetHotItem(INT nIndex)
    {
        return (INT)SendMessageDx(TB_SETHOTITEM, (WPARAM)nIndex);
    }

    inline VOID MToolBarCtrl::GetInsertMark(TBINSERTMARK* ptbim) const
    {
        SendMessageDx(TB_GETINSERTMARK, 0, (LPARAM)ptbim);
    }

    inline VOID MToolBarCtrl::SetInsertMark(TBINSERTMARK* ptbim)
    {
        SendMessageDx(TB_SETINSERTMARK, 0, (LPARAM)ptbim);
    }

    inline BOOL MToolBarCtrl::InsertMarkHitTest(
        LPPOINT ppt, LPTBINSERTMARK ptbim) const
    {
        return (BOOL)SendMessageDx(TB_INSERTMARKHITTEST, (WPARAM)ppt, (LPARAM)ptbim);
    }

    inline BOOL MToolBarCtrl::GetMaxSize(LPSIZE pSize) const
    {
        return (BOOL)SendMessageDx(TB_GETMAXSIZE, 0, (LPARAM)pSize);
    }

    inline DWORD MToolBarCtrl::GetExtendedStyle() const
    {
        return (DWORD)SendMessageDx(TB_GETEXTENDEDSTYLE);
    }

    inline DWORD MToolBarCtrl::SetExtendedStyle(DWORD dwExStyle)
    {
        return (DWORD)SendMessageDx(TB_SETEXTENDEDSTYLE, 0, (LPARAM)dwExStyle);
    }

    inline COLORREF MToolBarCtrl::GetInsertMarkColor() const
    {
        return (COLORREF)SendMessageDx(TB_GETINSERTMARKCOLOR);
    }

    inline COLORREF MToolBarCtrl::SetInsertMarkColor(COLORREF clrNew)
    {
        return (COLORREF)SendMessageDx(TB_SETINSERTMARKCOLOR, 0, (LPARAM)clrNew);
    }
#endif  // (_WIN32_IE >= 0x400)

inline BOOL MToolBarCtrl::EnableButton(
    INT nButtonID, BOOL bEnable/* = TRUE*/)
{
    return (BOOL)SendMessageDx(TB_ENABLEBUTTON, (WPARAM)nButtonID, MAKELPARAM(bEnable, 0));
}

inline BOOL MToolBarCtrl::CheckButton(
    INT nButtonID, BOOL bCheck/* = TRUE*/)
{
    return (BOOL)SendMessageDx(TB_CHECKBUTTON, (WPARAM)nButtonID, MAKELPARAM(bCheck, 0));
}

inline BOOL MToolBarCtrl::PressButton(
    INT nButtonID, BOOL bPress/* = TRUE*/)
{
    return (BOOL)SendMessageDx(TB_PRESSBUTTON, (WPARAM)nButtonID, MAKELPARAM(bPress, 0));
}

inline BOOL MToolBarCtrl::HideButton(INT nButtonID, BOOL bHide/* = TRUE*/)
{
    return (BOOL)SendMessageDx(TB_HIDEBUTTON, (WPARAM)nButtonID, MAKELPARAM(bHide, 0));
}

inline BOOL MToolBarCtrl::Indeterminate(
    INT nButtonID, BOOL bIndeterminate/* = TRUE*/)
{
    return (BOOL)SendMessageDx(TB_INDETERMINATE, (WPARAM)nButtonID, MAKELPARAM(bIndeterminate, 0));
}

inline INT MToolBarCtrl::AddBitmap(INT nNumButtons, UINT nBitmapID)
{
    TBADDBITMAP tbab;
    ZeroMemory(&tbab, sizeof(tbab));
    tbab.hInst = ::GetModuleHandle(NULL);
    tbab.nID = nBitmapID;
    return (INT)SendMessageDx(TB_ADDBITMAP, (WPARAM)nNumButtons, (LPARAM)&tbab);
}

inline INT MToolBarCtrl::AddBitmap(INT nNumButtons, HBITMAP hBitmap)
{
    TBADDBITMAP tbab;
    ZeroMemory(&tbab, sizeof(tbab));
    tbab.hInst = NULL;
    tbab.nID = (UINT_PTR) hBitmap;
    return (INT)SendMessageDx(TB_ADDBITMAP, (WPARAM)nNumButtons, (LPARAM)&tbab);
}

inline BOOL MToolBarCtrl::AddButtons(
    INT nNumButtons, LPTBBUTTON lpButtons)
{
    return (BOOL)SendMessageDx(TB_ADDBUTTONS, (WPARAM)nNumButtons, (LPARAM)lpButtons);
}

inline BOOL MToolBarCtrl::InsertButton(
    INT nIndex, CONST TBBUTTON *lpButton)
{
    return (BOOL)SendMessageDx(TB_INSERTBUTTON, (WPARAM)nIndex, (LPARAM)lpButton);
}

inline BOOL MToolBarCtrl::DeleteButton(INT nIndex)
{
    return (BOOL)SendMessageDx(TB_DELETEBUTTON, (WPARAM)nIndex);
}

inline UINT MToolBarCtrl::CommandToIndex(UINT nCommandID) const
{
    return (UINT)SendMessageDx(TB_COMMANDTOINDEX, nCommandID);
}

inline VOID MToolBarCtrl::SaveState(
    HKEY hKeyRoot, LPCTSTR lpszSubKey, LPCTSTR lpszValueName)
{
    TBSAVEPARAMS tbs;
    ZeroMemory(&tbs, sizeof(tbs));
    tbs.hkr = hKeyRoot;
    tbs.pszSubKey = lpszSubKey;
    tbs.pszValueName = lpszValueName;
    SendMessageDx(TB_SAVERESTORE, (WPARAM)TRUE, (LPARAM)&tbs);
}

inline VOID MToolBarCtrl::RestoreState(
    HKEY hKeyRoot, LPCTSTR lpszSubKey, LPCTSTR lpszValueName)
{
    TBSAVEPARAMS tbs;
    ZeroMemory(&tbs, sizeof(tbs));
    tbs.hkr = hKeyRoot;
    tbs.pszSubKey = lpszSubKey;
    tbs.pszValueName = lpszValueName;
    SendMessageDx(TB_SAVERESTORE, (WPARAM)FALSE, (LPARAM)&tbs);
}

#if (_WIN32_IE >= 0x0300)
    inline VOID MToolBarCtrl::LoadImages(
        INT iBitmapID, HINSTANCE hinst/* = ::GetModuleHandle(NULL)*/)
    {
        SendMessageDx(TB_LOADIMAGES, (WPARAM)iBitmapID, (LPARAM)hinst);
    }
#endif  // (_WIN32_IE >= 0x0300)

#if (_WIN32_IE >= 0x0400)
    inline BOOL MToolBarCtrl::MapAccelerator(TCHAR chAccel, UINT* pIDBtn)
    {
        return (BOOL)SendMessageDx(TB_MAPACCELERATOR, (WPARAM)chAccel, (LPARAM)&pIDBtn);
    }

    inline BOOL MToolBarCtrl::MarkButton(
        INT nButtonID, BOOL fHighlight/* = TRUE*/)
    {
        return (BOOL)SendMessageDx(TB_MARKBUTTON, (WPARAM)nButtonID, MAKELPARAM(fHighlight, 0));
    }

    inline BOOL MToolBarCtrl::MoveButton(UINT nOldPos, UINT nNewPos)
    {
        return (BOOL)SendMessageDx(TB_MOVEBUTTON, (WPARAM)nOldPos, (LPARAM)nNewPos);
    }

    inline INT MToolBarCtrl::HitTest(LPPOINT ppt) const
    {
        return (INT)SendMessageDx(TB_HITTEST, 0, (LPARAM)ppt);
    }
#endif  // (_WIN32_IE >= 0x0400)

inline VOID MToolBarCtrl::Customize()
{
    SendMessageDx(TB_CUSTOMIZE);
}

inline INT MToolBarCtrl::AddString(UINT nStringID)
{
    return (INT)SendMessageDx(TB_ADDSTRING, (WPARAM)::GetModuleHandle(NULL), (LPARAM)nStringID);
}

inline INT MToolBarCtrl::AddStrings(LPCTSTR pszzStrings)
{
    return (INT)SendMessageDx(TB_ADDSTRING, 0, (LPARAM)pszzStrings);
}

inline VOID MToolBarCtrl::AutoSize()
{
    SendMessageDx(TB_AUTOSIZE);
}

////////////////////////////////////////////////////////////////////////////

#endif  // ndef MZC4_MTOOLBARCTRL_HPP_

```

`src/MVersionInfoDlg.hpp`:

```hpp
// MVersionInfoDlg.hpp --- version information dialog
//////////////////////////////////////////////////////////////////////////////
// RisohEditor --- Another free Win32 resource editor
// Copyright (C) 2017-2018 Katayama Hirofumi MZ <katayama.hirofumi.mz@gmail.com>
// 
// This program is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
// 
// This program is distributed in the hope that it will be useful, 
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
// 
// You should have received a copy of the GNU General Public License
// along with this program.  If not, see <http://www.gnu.org/licenses/>.
//////////////////////////////////////////////////////////////////////////////

#pragma once

#include "resource.h"
#include "DialogRes.hpp"
#include "MString.hpp"
#include "MToolBarCtrl.hpp"
#include "MHyperLinkCtrl.hpp"

class MVersionInfoDlg;

//////////////////////////////////////////////////////////////////////////////

class MVersionInfoDlg : public MDialogBase
{
public:
    MVersionInfoDlg() : MDialogBase(IDD_VERSIONINFO)
    {
    }

    virtual ~MVersionInfoDlg()
    {
    }

    BOOL OnInitDialog(HWND hwnd, HWND hwndFocus, LPARAM lParam)
    {
        SetDlgItemText(hwnd, stc1, LoadStringDx(IDS_VERSIONINFO));
        SetDlgItemText(hwnd, edt1, LoadStringDx(IDS_TRANSLATORS));
        SubclassChildDx(m_hyperlink, stc2);
        CenterWindowDx();
        return TRUE;
    }

    void OnStc2(HWND hwnd)
    {
        MString url = GetDlgItemText(stc2);
        ShellExecute(hwnd, NULL, url.c_str(), NULL, NULL, SW_SHOWNORMAL);
    }

    void OnCommand(HWND hwnd, int id, HWND hwndCtl, UINT codeNotify)
    {
        switch (id)
        {
        case IDOK:
            EndDialog(IDOK);
            break;
        case IDCANCEL:
            EndDialog(IDCANCEL);
            break;
        case stc2:
            if (codeNotify == STN_CLICKED)
            {
                OnStc2(hwnd);
                break;
            }
        }
    }

    virtual INT_PTR CALLBACK
    DialogProcDx(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
    {
        switch (uMsg)
        {
        HANDLE_MSG(hwnd, WM_INITDIALOG, OnInitDialog);
        HANDLE_MSG(hwnd, WM_COMMAND, OnCommand);
        default:
            return DefaultProcDx();
        }
    }

protected:
    MHyperLinkCtrl m_hyperlink;
};

```

`src/MWaitCursor.hpp`:

```hpp
// MWaitCursor.hpp --- Win32API wait cursor manager             -*- C++ -*-
// This file is part of MZC4.  See file "ReadMe.txt" and "License.txt".
//////////////////////////////////////////////////////////////////////////////

#ifndef MZC4_MWAITCURSOR_HPP_
#define MZC4_MWAITCURSOR_HPP_       2   /* Version 2 */

class MWaitCursor;

////////////////////////////////////////////////////////////////////////////

#ifndef _INC_WINDOWS
    #include <windows.h>    // Win32API
#endif
#include <cassert>          // assert

////////////////////////////////////////////////////////////////////////////

class MWaitCursor
{
public:
    MWaitCursor();
    virtual ~MWaitCursor();
    VOID Restore();

public:
    static VOID DoWaitCursor(INT nCode);
};

////////////////////////////////////////////////////////////////////////////

inline VOID MWaitCursor::DoWaitCursor(INT nCode)
{
    static LONG     s_nCount = 0;
    static HCURSOR  s_hcurRestore = NULL;

    assert(nCode == 0 || nCode == 1 || nCode == -1);

    switch (nCode)
    {
    case -1:
        InterlockedDecrement(&s_nCount);
        break;

    case 1:
        InterlockedIncrement(&s_nCount);
        break;
    }

    if (s_nCount > 0)
    {
        HCURSOR hcurPrev = ::SetCursor(::LoadCursor(NULL, IDC_WAIT));
        if (nCode > 0 && s_nCount == 1)
            s_hcurRestore = hcurPrev;
    }
    else
    {
        s_nCount = 0;
        ::SetCursor(s_hcurRestore);
    }
}

inline MWaitCursor::MWaitCursor()
{
    MWaitCursor::DoWaitCursor(1);
}

inline /*virtual*/ MWaitCursor::~MWaitCursor()
{
    MWaitCursor::DoWaitCursor(-1);
}

inline VOID MWaitCursor::Restore()
{
    MWaitCursor::DoWaitCursor(0);
}

////////////////////////////////////////////////////////////////////////////

#endif  // ndef MZC4_MWAITCURSOR_HPP_

```

`src/MWindowBase.hpp`:

```hpp
// MWindowBase.hpp --- MZC4 window base and dialog base         -*- C++ -*-
// This file is part of MZC4.  See file "ReadMe.txt" and "License.txt".
//////////////////////////////////////////////////////////////////////////////

#ifndef MZC4_MWINDOWBASE_HPP_
#define MZC4_MWINDOWBASE_HPP_    171     /* Version 171 */

class MWindowBase;
class MDialogBase;

//////////////////////////////////////////////////////////////////////////////

#if _MSC_VER > 1000
    #pragma once        // For speed!
#endif

#ifndef STRICT
    #define STRICT  1   // We must do strictly! Good bye to old style!
#endif

#if defined(_MSC_VER) && !defined(NDEBUG) && !defined(_CRTDBG_MAP_ALLOC)
    // for detecting memory leak (MSVC only)
    #define _CRTDBG_MAP_ALLOC
    #include <crtdbg.h>
#endif

#if __STDC_VERSION__ >= 199901L && !defined(C99)
    #define C99             1
#endif
#if __cplusplus >= 201103L && !defined(CXX11)
    #define CXX11           1
#endif

//#define MZC4_FAT_AND_RICH   1
//#define MZC4_HANDLE_MAP     1

//////////////////////////////////////////////////////////////////////////////
// headers

// Win32API headers
#ifndef _INC_WINDOWS
    #include <windows.h>    // Win32API
#endif
#ifndef _INC_WINDOWSX
    #include <windowsx.h>   // Win32API Macro APIs
#endif
#ifndef _INC_COMMCTRL
    #include <commctrl.h>   // common controls
#endif
#ifndef _INC_COMMDLG
    #include <commdlg.h>    // common dialogs
#endif
#ifndef _INC_SHLWAPI
    #include <shlwapi.h>    // Shell Light-Weight API
#endif
#ifndef _INC_TCHAR
    #include <tchar.h>      // generic text mappings
#endif

#include <dlgs.h>           // dialog control IDs

#ifndef NO_STRSAFE
    #include <strsafe.h>    // StringCch* or StringCb*
#endif

// standard C/C++ library
#include <cassert>          // assert
#include <cstring>          // C string library

#include <map>              // std::map

//////////////////////////////////////////////////////////////////////////////

#ifndef _countof
    #define _countof(array)     (sizeof(array) / sizeof(array[0]))
#endif

// MString
#ifndef MString
    #include <string>       // std::string and std::wstring
    typedef std::string     MStringA;
    typedef std::wstring    MStringW;
    #ifdef UNICODE
        #define MString     MStringW
    #else
        #define MString     MStringA
    #endif
#endif

// NOTE: Old Digital Mars C/C++ Compiler doesn't define INT_PTR type likely.
#ifdef __DMC__
    #ifndef INT_PTR
        #ifdef _WIN64
            #define INT_PTR     LPARAM
        #else
            #define INT_PTR     BOOL
        #endif
    #endif
#endif

//////////////////////////////////////////////////////////////////////////////
// public functions

#ifndef MZCAPI
    #define MZCAPI      WINAPI
#endif

#ifndef MZCAPIV
    #define MZCAPIV     WINAPIV
#endif

VOID MZCAPIV DebugPrintDx(const char *format, ...);
VOID MZCAPIV DebugPrintDx(const WCHAR *format, ...);
RECT MZCAPI GetVirtualScreenRectDx();
VOID MZCAPI RepositionPointDx(LPPOINT ppt, SIZE siz, LPCRECT prc);
RECT MZCAPI WorkAreaFromWindowDx(HWND hwnd);
SIZE MZCAPI SizeFromRectDx(LPCRECT prc);
LPTSTR MZCAPI LoadStringDx(INT nID);
LPTSTR MZCAPIV LoadStringPrintfDx(INT nID, ...);
LPTSTR MZCAPI LoadStringVPrintfDx(INT nID, va_list va);
LPCTSTR MZCAPI GetStringDx(INT nStringID);
LPCTSTR MZCAPI GetStringDx(LPCTSTR psz);
BOOL MZCAPI GetWindowPosDx(HWND hwnd, POINT *ppt = NULL, SIZE *psiz = NULL);
BOOL MZCAPI GetWindowPosDx(HWND hwnd, RECT *prc);
BOOL MZCAPI SetWindowPosDx(HWND hwnd, LPPOINT ppt = NULL, LPSIZE psiz = NULL, 
    HWND hwndInsertAfter = NULL, 
    UINT uFlags = SWP_NOACTIVATE | SWP_NOOWNERZORDER);
BOOL MZCAPI SetWindowPosDx(HWND hwnd, const RECT *prc);
LPSTR MZCAPI MakeFilterDx(LPSTR psz);
LPWSTR MZCAPI MakeFilterDx(LPWSTR psz);
HBITMAP MZCAPI Create24BppBitmapDx(INT width, INT height);
void MZCAPI FillBitmapDx(HBITMAP hbm, HBRUSH hbr);
void MZCAPI PremultiplyDx(HBITMAP hbm32bpp);
BOOL MZCAPI CopyTextDx(HWND hwnd, const MString& text);
void MZCAPI
PopupMenuDx(HWND hwnd, HWND hContext, UINT nMenuID, INT iSubMenu, INT x, INT y);

//////////////////////////////////////////////////////////////////////////////
// Messaging

// LRESULT OnMessage(HWND hwnd, WPARAM wParam, LPARAM lParam);
#define HANDLE_MESSAGE(hwnd, uMsg, OnMessage) \
    case (uMsg): return (OnMessage)((hwnd), (wParam), (lParam))

// LRESULT OnMessageEx(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam);
#define HANDLE_MESSAGE_EX(hwnd, uMsg, OnMessageEx) \
    case (uMsg): return (OnMessageEx)((hwnd), (uMsg), (wParam), (lParam))

#define DO_MSG(WM_, fn) \
    case (WM_): return HANDLE_##WM_(hwnd, (wParam), (lParam), (fn))
#define DO_MESSAGE(uMsg, OnMessage) \
    HANDLE_MESSAGE(hwnd, uMsg, OnMessage)
#define DO_MESSAGE_EX(uMsg, OnMessageEx) \
    HANDLE_MESSAGE_EX(hwnd, uMsg, OnMessage)

//////////////////////////////////////////////////////////////////////////////

class MWindowBase
{
protected:
    DWORD           m_dwWindowBaseMagic;
    MSG             m_msg;
public:
    HWND            m_hwnd;
    WNDPROC         m_fnOldProc;
    MWindowBase *   m_pwndSub;
    bool            m_bDynamicCreated;

    MWindowBase() :
        m_dwWindowBaseMagic(0xFEEDFEED), m_hwnd(NULL), m_fnOldProc(NULL), 
        m_pwndSub(NULL), m_bDynamicCreated(false)
    {
    }

    MWindowBase(HWND hwnd) :
        m_dwWindowBaseMagic(0xFEEDFEED), m_hwnd(hwnd), m_fnOldProc(NULL), 
        m_pwndSub(NULL), m_bDynamicCreated(false)
    {
    }

    virtual ~MWindowBase()
    {
    }

    operator HWND() const
    {
        return Handle();
    }
    bool operator!() const
    {
        return Handle() == NULL;
    }
    HWND Handle() const
    {
        return (this ? m_hwnd : NULL);
    }

#ifdef MZC4_HANDLE_MAP
    typedef std::map<HWND, void *> handle_map_type;
    static handle_map_type& GetHandleMap()
    {
        static handle_map_type s_map;
        return s_map;
    }
    static MWindowBase *GetUserData(HWND hwnd)
    {
        auto it = GetHandleMap().find(hwnd);
        if (it == GetHandleMap().end())
            return NULL;
        return reinterpret_cast<MWindowBase *>(it->second);
    }
    static void SetUserData(HWND hwnd, void *ptr)
    {
        if (ptr)
        {
            GetHandleMap()[hwnd] = ptr;
        }
        else
        {
            GetHandleMap().erase(hwnd);
        }
    }
#else
    static MWindowBase *GetUserData(HWND hwnd)
    {
        return reinterpret_cast<MWindowBase *>(GetWindowLongPtr(hwnd, GWLP_USERDATA));
    }
    static void SetUserData(HWND hwnd, void *ptr)
    {
        SetWindowLongPtr(hwnd, GWLP_USERDATA, (LONG_PTR)ptr);
    }
#endif
    virtual void PostNcDestroy()
    {
        SetUserData(m_hwnd, NULL);
        m_hwnd = NULL;
        if (m_bDynamicCreated)
        {
            delete this;
        }
    }

    MWindowBase *GetUserData() const
    {
        return GetUserData(m_hwnd);
    }

    LRESULT CALLBACK
    CallWindowProcDx(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
    {
        return ::CallWindowProc(m_fnOldProc, hwnd, uMsg, wParam, lParam);
    }

    virtual LRESULT MZCAPI
    DefaultProcDx(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
    {
        if (m_pwndSub)
        {
            assert(this != m_pwndSub);
            return m_pwndSub->WindowProcDx(hwnd, uMsg, wParam, lParam);
        }
        if (m_fnOldProc)
        {
            return ::CallWindowProc(m_fnOldProc, hwnd, uMsg, wParam, lParam);
        }
        return ::DefWindowProc(hwnd, uMsg, wParam, lParam);
    }

    LRESULT MZCAPI DefaultProcDx()
    {
        return DefaultProcDx(m_msg.hwnd, m_msg.message, m_msg.wParam, m_msg.lParam);
    }

    VOID SaveMessageDx(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam);

    virtual LRESULT CALLBACK
    WindowProcDx(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
    {
        return DefaultProcDx(hwnd, uMsg, wParam, lParam);
    }

    static LRESULT CALLBACK
    WindowProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam);

    virtual LPCTSTR GetWndClassNameDx() const
    {
        return TEXT("katahiromz's MWindowBase Class");
    }

    virtual VOID ModifyWndClassDx(WNDCLASSEX& wcx)
    {
    }

    BOOL RegisterClassDx();

    BOOL CreateWindowDx(HWND hwndParent, LPCTSTR pszText, 
                        DWORD Style = WS_OVERLAPPEDWINDOW, DWORD ExStyle = 0, 
                        INT x = CW_USEDEFAULT, INT y = CW_USEDEFAULT, 
                        INT cx = CW_USEDEFAULT, INT cy = CW_USEDEFAULT, 
                        HMENU hMenu = NULL);
    BOOL CreateAsChildDx(HWND hwndParent, LPCTSTR pszText, 
                         DWORD Style = WS_CHILD | WS_VISIBLE, 
                         DWORD ExStyle = 0, INT nCtrlID = -1, 
                         INT x = CW_USEDEFAULT, INT y = CW_USEDEFAULT, 
                         INT cx = CW_USEDEFAULT, INT cy = CW_USEDEFAULT);

    BOOL Attach(HWND hwnd)
    {
        MWindowBase *pwndSub = GetUserData(hwnd);
        m_hwnd = hwnd;
        SetUserData(m_hwnd, this);
        m_pwndSub = pwndSub;
        return m_hwnd != NULL;
    }

    HWND Detach()
    {
        HWND hwnd = m_hwnd;
        SetUserData(hwnd, m_pwndSub);
        m_hwnd = NULL;
        m_pwndSub = NULL;
        return hwnd;
    }

    virtual void PostSubclassDx(HWND hwnd)
    {
    }

    BOOL SubclassDx(HWND hwnd)
    {
        Attach(hwnd);
        if (!m_pwndSub)
        {
            m_fnOldProc = (WNDPROC)SetWindowLongPtrW(hwnd, GWLP_WNDPROC, (LONG_PTR)MWindowBase::WindowProc);
        }
        PostSubclassDx(hwnd);
        return m_pwndSub || m_fnOldProc;
    }

    VOID UnsubclassDx()
    {
        SetWindowLongPtrW(m_hwnd, GWLP_WNDPROC, (LONG_PTR)m_fnOldProc);
        SetUserData(m_hwnd, m_pwndSub);
        m_fnOldProc = NULL;
    }

    BOOL SubclassChildDx(MWindowBase& child, UINT nItemID)
    {
        assert(::IsWindow(m_hwnd));
        return child.SubclassDx(::GetDlgItem(m_hwnd, nItemID));
    }

    INT MsgBoxDx(LPCTSTR pszString, LPCTSTR pszTitle, 
                 UINT uType = MB_ICONINFORMATION);

    INT MsgBoxDx(UINT nStringID, UINT nTitleID, UINT uType)
    {
        return MsgBoxDx(MAKEINTRESOURCE(nStringID), MAKEINTRESOURCE(nTitleID), uType);
    }

    INT MsgBoxDx(UINT nStringID, LPCTSTR pszTitle, UINT uType)
    {
        return MsgBoxDx(MAKEINTRESOURCE(nStringID), pszTitle, uType);
    }

    INT MsgBoxDx(UINT nStringID, UINT uType)
    {
        return MsgBoxDx(MAKEINTRESOURCE(nStringID), NULL, uType);
    }

    INT MsgBoxDx(LPCTSTR pszString, UINT uType)
    {
        return MsgBoxDx(pszString, NULL, uType);
    }

    INT ErrorBoxDx(UINT nStringID, UINT uType = MB_ICONERROR)
    {
        return MsgBoxDx(MAKEINTRESOURCE(nStringID), TEXT("ERROR"), uType);
    }
    INT ErrorBoxDx(LPCTSTR pszString, UINT uType = MB_ICONERROR)
    {
        return MsgBoxDx(pszString, TEXT("ERROR"), uType);
    }

    VOID CenterWindowDx() const
    {
        CenterWindowDx(m_hwnd);
    }

    static INT GetWindowTextLength(HWND hwnd)
    {
        assert(::IsWindow(hwnd));
        return ::GetWindowTextLength(hwnd);
    }
    INT GetWindowTextLength() const
    {
        assert(::IsWindow(Handle()));
        return ::GetWindowTextLength(Handle());
    }

    static MString GetWindowText(HWND hwnd);
    static INT GetWindowText(HWND hwnd, LPTSTR pszText, INT cchMax)
    {
        assert(::IsWindow(hwnd));
        return ::GetWindowText(hwnd, pszText, cchMax);
    }
    MString GetWindowText() const
    {
        return GetWindowText(m_hwnd);
    }

    static UINT GetDlgItemText(HWND hwnd, INT nCtrlID, LPTSTR psz, INT cchMax)
    {
        assert(::IsWindow(hwnd));
        return ::GetDlgItemText(hwnd, nCtrlID, psz, cchMax);
    }
    static MString GetDlgItemText(HWND hwnd, INT nCtrlID)
    {
        assert(::IsWindow(hwnd));
        return GetWindowText(::GetDlgItem(hwnd, nCtrlID));
    }
    MString GetDlgItemText(INT nCtrlID) const
    {
        return GetWindowText(::GetDlgItem(m_hwnd, nCtrlID));
    }

    static BOOL SetWindowText(HWND hwnd, LPCTSTR pszText = NULL)
    {
        assert(::IsWindow(hwnd));
        return ::SetWindowText(hwnd, pszText);
    }
    BOOL SetWindowText(LPCTSTR pszText = NULL)
    {
        return SetWindowText(Handle(), pszText);
    }

    static VOID CenterWindowDx(HWND hwnd);

    static BOOL MZCAPI GetWindowPosDx(HWND hwnd, POINT *ppt = NULL, SIZE *psiz = NULL);
    static BOOL MZCAPI GetWindowPosDx(HWND hwnd, RECT *prc);

    BOOL MZCAPI GetWindowPosDx(POINT *ppt = NULL, SIZE *psiz = NULL);
    BOOL MZCAPI GetWindowPosDx(RECT *prc);

    static BOOL SetWindowPosDx(HWND hwnd, 
                               LPPOINT ppt = NULL, LPSIZE psiz = NULL, 
                               HWND hwndInsertAfter = NULL, 
                               UINT uFlags = SWP_NOACTIVATE | SWP_NOOWNERZORDER);
    static BOOL SetWindowPosDx(HWND hwnd, const RECT *prc);

    BOOL SetWindowPosDx(LPPOINT ppt = NULL, LPSIZE psiz = NULL, 
                        HWND hwndInsertAfter = NULL, 
                        UINT uFlags = SWP_NOACTIVATE | SWP_NOOWNERZORDER);
    BOOL SetWindowPosDx(const RECT *prc);

    static HWND GetAncestorDx(HWND hTarget);
    HWND GetAncestorDx() const
    {
        return GetAncestorDx(m_hwnd);
    }

    HICON LoadIconDx(INT id)
    {
        return LoadIcon(GetModuleHandle(NULL), MAKEINTRESOURCE(id));
    }

    HICON LoadSmallIconDx(UINT id)
    {
        INT cxSmall = GetSystemMetrics(SM_CXSMICON);
        INT cySmall = GetSystemMetrics(SM_CYSMICON);
        return HICON(LoadImage(GetModuleHandle(NULL), 
                               MAKEINTRESOURCE(id), 
                               IMAGE_ICON, cxSmall, cySmall, 0));
    }

    HFONT GetFontDx() const
    {
        assert(::IsWindow(m_hwnd));
        return GetWindowFont(m_hwnd);
    }
    void SetFontDx(HFONT hFont, BOOL bRedraw = TRUE)
    {
        assert(::IsWindow(m_hwnd));
        SetWindowFont(m_hwnd, hFont, bRedraw);
    }
    DWORD GetStyleDx() const
    {
        assert(::IsWindow(m_hwnd));
        return GetWindowStyle(m_hwnd);
    }
    DWORD SetStyleDx(DWORD dwNewStyle)
    {
        assert(::IsWindow(m_hwnd));
        return SetWindowLong(m_hwnd, GWL_STYLE, dwNewStyle);
    }
    void ModifyStyleDx(DWORD dwRemove, DWORD dwAdd)
    {
        assert(::IsWindow(m_hwnd));
        DWORD style = GetStyleDx();
        style &= ~dwRemove;
        style |= dwAdd;
        SetStyleDx(style);
    }
    DWORD GetExStyleDx() const
    {
        assert(::IsWindow(m_hwnd));
        return GetWindowExStyle(m_hwnd);
    }
    DWORD SetExStyleDx(DWORD dwNewExStyle)
    {
        assert(::IsWindow(m_hwnd));
        return SetWindowLong(m_hwnd, GWL_EXSTYLE, dwNewExStyle);
    }
    void ModifyExStyleDx(DWORD dwRemove, DWORD dwAdd)
    {
        assert(::IsWindow(m_hwnd));
        DWORD exstyle = GetExStyleDx();
        exstyle &= ~dwRemove;
        exstyle |= dwAdd;
        SetExStyleDx(exstyle);
    }

    HWND GetChildDx(HWND hwndChild) const
    {
        return hwndChild;
    }
    HWND GetChildDx(UINT id) const
    {
        return ::GetDlgItem(m_hwnd, id);
    }
    UINT GetCtrlIDDx(HWND hwndChild) const
    {
        return ::GetDlgCtrlID(hwndChild);
    }
    UINT GetCtrlIDDx(UINT nChildID) const
    {
        return nChildID;
    }

    LRESULT SendMessageDx(UINT uMsg, WPARAM wParam = 0, LPARAM lParam = 0) const
    {
        assert(::IsWindow(m_hwnd));
        return ::SendMessage(m_hwnd, uMsg, wParam, lParam);
    }
    BOOL PostMessageDx(UINT uMsg, WPARAM wParam = 0, LPARAM lParam = 0) const
    {
        assert(::IsWindow(m_hwnd));
        return ::PostMessage(m_hwnd, uMsg, wParam, lParam);
    }

    static HHOOK HookCenterMsgBoxDx(BOOL bHook);

private:
    static inline LRESULT CALLBACK
    _msgBoxCbtProcDx(INT nCode, WPARAM wParam, LPARAM lParam);

#ifdef MZC4_FAT_AND_RICH
public:
    #include "MWindowBaseRichMethods.hpp"
#endif

public:
    // for DECLARE_DYNAMIC/IMPLEMENT_DYNAMIC
    typedef MWindowBase *(*FNCREATEINSTANCEDX)();
    typedef std::map<MString, FNCREATEINSTANCEDX> class_to_create_map_t;

    static class_to_create_map_t& ClassToCreateMap()
    {
        static class_to_create_map_t s_class_to_create_map;
        return s_class_to_create_map;
    }
};

//////////////////////////////////////////////////////////////////////////////
// DECLARE_DYNAMIC/IMPLEMENT_DYNAMIC

#define DECLARE_DYNAMIC(class_name) \
    static MWindowBase *CreateInstanceDx();

#define IMPLEMENT_DYNAMIC(class_name) \
    /*static*/ MWindowBase *class_name::CreateInstanceDx() \
    { \
        return new class_name(); \
    } \
    struct class_name##AutoDynamicRegister \
    { \
        class_name##AutoDynamicRegister() \
        { \
            MWindowBase::ClassToCreateMap()[TEXT(#class_name)] = &class_name::CreateInstanceDx; \
        } \
    } class_name##AutoDynamicRegister##__LINE__;

#define IMPLEMENT_DYNAMIC2(class_name, wndclass_name) \
    /*static*/ MWindowBase *class_name::CreateInstanceDx() \
    { \
        return new class_name(); \
    } \
    struct class_name##AutoDynamicRegister \
    { \
        class_name##AutoDynamicRegister() \
        { \
            MWindowBase::ClassToCreateMap()[TEXT(#wndclass_name)] = &class_name::CreateInstanceDx; \
        } \
    } class_name##AutoDynamicRegister##__LINE__;

//////////////////////////////////////////////////////////////////////////////

class MDialogBase : public MWindowBase
{
public:
    BOOL    m_bModal;
    HWND    m_hwndOwner;
    LPCTSTR m_pDialogName;

    MDialogBase() : m_bModal(FALSE), m_hwndOwner(NULL), m_pDialogName(NULL)
    {
    }

    MDialogBase(HWND hwndOwner)
        : m_bModal(FALSE), m_hwndOwner(hwndOwner), m_pDialogName(NULL)
    {
    }

    MDialogBase(HWND hwndOwner, INT nDialogID)
        : m_bModal(FALSE), m_hwndOwner(hwndOwner), 
          m_pDialogName(MAKEINTRESOURCE(nDialogID))
    {
    }

    MDialogBase(HWND hwndOwner, LPCTSTR pDialogName)
        : m_bModal(FALSE), m_hwndOwner(hwndOwner), 
          m_pDialogName(pDialogName)
    {
    }

    MDialogBase(INT nDialogID)
        : m_bModal(FALSE), m_hwndOwner(NULL), 
          m_pDialogName(MAKEINTRESOURCE(nDialogID))
    {
    }

    virtual LPCTSTR GetWndClassNameDx() const
    {
        return TEXT("#32770");
    }

    virtual LRESULT MZCAPI
    DefaultProcDx(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
    {
        return 0;
    }

    LRESULT MZCAPI DefaultProcDx()
    {
        return DefaultProcDx(m_msg.hwnd, m_msg.message, m_msg.wParam, m_msg.lParam);
    }

    virtual INT_PTR CALLBACK
    DialogProcDx(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
    {
        return 0;
    }

    static INT_PTR CALLBACK
    DialogProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam);

    static MDialogBase *GetUserData(HWND hwnd)
    {
        return (MDialogBase *)GetWindowLongPtr(hwnd, DWLP_USER);
    }
    static VOID SetUserData(HWND hwnd, VOID *ptr)
    {
        SetWindowLongPtr(hwnd, DWLP_USER, (LONG_PTR)ptr);
    }

    BOOL CreateDialogDx(HWND hwndOwner, INT nDialogID);
    BOOL CreateDialogDx(HWND hwndOwner, LPCTSTR pDialogName);
    INT_PTR DialogBoxDx(HWND hwndOwner, INT nDialogID);
    INT_PTR DialogBoxDx(HWND hwndOwner, LPCTSTR pDialogName);
    BOOL CreateDialogIndirectDx(HWND hwndOwner, const VOID *ptr);
    INT_PTR DialogBoxIndirectDx(HWND hwndOwner, const VOID *ptr);

    BOOL CreateDialogDx(HWND hwndOwner)
    {
        return CreateDialogDx(hwndOwner, m_pDialogName);
    }

    INT_PTR DialogBoxDx(HWND hwndOwner)
    {
        return DialogBoxDx(hwndOwner, m_pDialogName);
    }

    DWORD GetDefID() const
    {
        return (DWORD)SendMessageDx(DM_GETDEFID);
    }
    BOOL SetDefID(UINT nID)
    {
        return (BOOL)SendMessageDx(DM_SETDEFID, (WPARAM)nID);
    }

    BOOL EndDialog(INT_PTR nResult)
    {
        assert(::IsWindow(Handle()));
        return ::EndDialog(Handle(), nResult);
    }
    static BOOL EndDialog(HWND hwnd, INT_PTR nResult)
    {
        assert(::IsWindow(hwnd));
        return ::EndDialog(hwnd, nResult);
    }

    VOID NextDlgCtrl() const
    {
        PostMessageDx(WM_NEXTDLGCTL, FALSE);
    }
    VOID PrevDlgCtrl() const
    {
        PostMessageDx(WM_NEXTDLGCTL, TRUE);
    }
    VOID GotoDlgCtrl(HWND hwndCtrl)
    {
        PostMessageDx(WM_NEXTDLGCTL, (WPARAM)hwndCtrl, 1);
    }

    BOOL MapDialogRect(LPRECT prc) const
    {
        assert(IsWindow(Handle()));
        return ::MapDialogRect(Handle(), prc);
    }
    static BOOL MapDialogRect(HWND hwnd, LPRECT prc)
    {
        assert(IsWindow(hwnd));
        return ::MapDialogRect(hwnd, prc);
    }

    BOOL IsDialogMessage(LPMSG pMsg)
    {
        return ::IsDialogMessage(Handle(), pMsg);
    }

    BOOL Attach(HWND hwnd)
    {
        m_hwnd = hwnd;
        SetUserData(m_hwnd, this);
        return m_hwnd != NULL;
    }

    HWND Detach()
    {
        HWND hwnd = m_hwnd;
        SetUserData(hwnd, NULL);
        m_hwnd = NULL;
        return hwnd;
    }
};

//////////////////////////////////////////////////////////////////////////////
// public inline functions

inline VOID MZCAPIV DebugPrintDx(const char *format, ...)
{
    #ifndef NDEBUG
        char szBuff[512];
        va_list va;
        va_start(va, format);
#ifdef NO_STRSAFE
        wsprintfA(szBuff, format, va);
#else
        StringCchVPrintfA(szBuff, _countof(szBuff), format, va);
#endif
        va_end(va);
        OutputDebugStringA(szBuff);
    #endif
}

inline VOID MZCAPIV DebugPrintDx(const WCHAR *format, ...)
{
    #ifndef NDEBUG
        WCHAR szBuff[512];
        va_list va;
        va_start(va, format);
#ifdef NO_STRSAFE
        wsprintfW(szBuff, format, va);
#else
        StringCchVPrintfW(szBuff, _countof(szBuff), format, va);
#endif
        va_end(va);
        OutputDebugStringW(szBuff);
    #endif
}

inline RECT MZCAPI GetVirtualScreenRectDx()
{
    RECT rc;
#ifndef SM_XVIRTUALSCREEN
    #define SM_XVIRTUALSCREEN   76
    #define SM_YVIRTUALSCREEN   77
    #define SM_CXVIRTUALSCREEN  78
    #define SM_CYVIRTUALSCREEN  79
#endif
    INT x = ::GetSystemMetrics(SM_XVIRTUALSCREEN);
    INT y = ::GetSystemMetrics(SM_YVIRTUALSCREEN);
    INT cx = ::GetSystemMetrics(SM_CXVIRTUALSCREEN);
    INT cy = ::GetSystemMetrics(SM_CYVIRTUALSCREEN);
    if (cx == 0)
        cx = ::GetSystemMetrics(SM_CXSCREEN);
    if (cy == 0)
        cy = ::GetSystemMetrics(SM_CYSCREEN);
    SetRect(&rc, x, y, x + cx, y + cy);
    return rc;
}

inline VOID MZCAPI RepositionPointDx(LPPOINT ppt, SIZE siz, LPCRECT prc)
{
    if (ppt->x + siz.cx > prc->right)
        ppt->x = prc->right - siz.cx;
    if (ppt->y + siz.cy > prc->bottom)
        ppt->y = prc->bottom - siz.cy;
    if (ppt->x < prc->left)
        ppt->x = prc->left;
    if (ppt->y < prc->top)
        ppt->y = prc->top;
}

inline RECT MZCAPI WorkAreaFromWindowDx(HWND hwnd)
{
#if (WINVER >= 0x0500)
    MONITORINFO mi;
    mi.cbSize = sizeof(mi);
    HMONITOR hMonitor = MonitorFromWindow(hwnd, MONITOR_DEFAULTTONEAREST);
    if (GetMonitorInfo(hMonitor, &mi))
    {
        return mi.rcWork;
    }
#endif
    RECT rc;
    ::SystemParametersInfo(SPI_GETWORKAREA, 0, &rc, 0);
    return rc;
}

inline SIZE MZCAPI SizeFromRectDx(LPCRECT prc)
{
    SIZE siz;
    siz.cx = prc->right - prc->left;
    siz.cy = prc->bottom - prc->top;
    return siz;
}

inline LPTSTR MZCAPI LoadStringDx(INT nID)
{
    static UINT s_index = 0;
    const UINT cchBuffMax = 1024;
    static TCHAR s_sz[4][cchBuffMax];

    TCHAR *pszBuff = s_sz[s_index];
    s_index = (s_index + 1) % _countof(s_sz);
    pszBuff[0] = 0;
    if (!::LoadString(NULL, nID, pszBuff, cchBuffMax))
        assert(0);
    return pszBuff;
}

inline LPTSTR MZCAPI LoadStringVPrintfDx(INT nID, va_list va)
{
    static UINT s_index = 0;
    const UINT cchBuffMax = 1024;
    static TCHAR s_sz[4][cchBuffMax];

    TCHAR *pszBuff = s_sz[s_index];
    s_index = (s_index + 1) % _countof(s_sz);
    pszBuff[0] = 0;
#ifdef NO_STRSAFE
    wvsprintf(pszBuff, LoadStringDx(nID), va);
#else
    StringCchVPrintf(pszBuff, cchBuffMax, LoadStringDx(nID), va);
#endif
    return pszBuff;
}

inline LPTSTR MZCAPIV LoadStringPrintfDx(INT nID, ...)
{
    va_list va;
    va_start(va, nID);
    LPTSTR psz = LoadStringVPrintfDx(nID, va);
    va_end(va);
    return psz;
}

inline LPCTSTR MZCAPI GetStringDx(LPCTSTR psz)
{
    if (psz == NULL)
        return NULL;
    if (IS_INTRESOURCE(psz))
        return LoadStringDx(LOWORD(psz));
    return psz;
}

inline LPCTSTR MZCAPI GetStringDx(INT nStringID)
{
    return LoadStringDx(nStringID);
}

inline BOOL MZCAPI
GetWindowPosDx(HWND hwnd, POINT *ppt/* = NULL*/, SIZE *psiz/* = NULL*/)
{
    RECT rc;
    if (!GetWindowRect(hwnd, &rc))
        return FALSE;

    if (ppt)
    {
        ppt->x = rc.left;
        ppt->y = rc.top;
        if (GetWindowStyle(hwnd) & WS_CHILD)
        {
            MapWindowPoints(NULL, GetParent(hwnd), ppt, 1);
        }
    }
    if (psiz)
    {
        psiz->cx = rc.right - rc.left;
        psiz->cy = rc.bottom - rc.top;
    }
    return TRUE;
}

inline BOOL MZCAPI GetWindowPosDx(HWND hwnd, RECT *prc)
{
    POINT pt;
    SIZE siz;
    if (!GetWindowPosDx(hwnd, &pt, &siz))
        return FALSE;
    prc->left = pt.x;
    prc->top = pt.y;
    prc->right = pt.x + siz.cx;
    prc->bottom = pt.x + siz.cy;
    return TRUE;
}

inline BOOL MZCAPI
SetWindowPosDx(HWND hwnd, LPPOINT ppt/* = NULL*/, LPSIZE psiz/* = NULL*/, 
    HWND hwndInsertAfter/* = NULL*/, 
    UINT uFlags/* = SWP_NOACTIVATE | SWP_NOOWNERZORDER*/)
{
    if (hwndInsertAfter == NULL)
    {
        uFlags |= SWP_NOZORDER;
    }

    INT x = 0, y = 0;
    if (ppt == NULL)
    {
        uFlags |= SWP_NOMOVE;
    }
    else
    {
        x = ppt->x;
        y = ppt->y;
    }

    INT cx = 0, cy = 0;
    if (psiz == NULL)
    {
        uFlags |= SWP_NOSIZE;
    }
    else
    {
        cx = psiz->cx;
        cy = psiz->cy;
    }

    return ::SetWindowPos(hwnd, hwndInsertAfter, x, y, cx, cy, uFlags);
}

inline BOOL MZCAPI
SetWindowPosDx(HWND hwnd, const RECT *prc)
{
    assert(prc);
    POINT pt;
    SIZE siz;
    pt.x = prc->left;
    pt.y = prc->top;
    siz.cx = prc->right - prc->left;
    siz.cy = prc->bottom - prc->top;
    return ::SetWindowPosDx(hwnd, &pt, &siz);
}

inline LPSTR MZCAPI MakeFilterDx(LPSTR psz)
{
    for (LPSTR pch = psz; *pch; ++pch)
    {
        if (*pch == '|')
            *pch = 0;
    }
    return psz;
}

inline LPWSTR MZCAPI MakeFilterDx(LPWSTR psz)
{
    for (LPWSTR pch = psz; *pch; ++pch)
    {
        if (*pch == L'|')
            *pch = 0;
    }
    return psz;
}

inline HBITMAP MZCAPI Create24BppBitmapDx(INT width, INT height)
{
    BITMAPINFO bi;
    ZeroMemory(&bi, sizeof(bi));
    bi.bmiHeader.biSize = sizeof(BITMAPINFOHEADER);
    bi.bmiHeader.biWidth = width;
    bi.bmiHeader.biHeight = height;
    bi.bmiHeader.biPlanes = 1;
    bi.bmiHeader.biBitCount = 24;
    bi.bmiHeader.biCompression = BI_RGB;
    HDC hDC = CreateCompatibleDC(NULL);
    LPVOID pvBits;
    HBITMAP hbm = CreateDIBSection(hDC, &bi, DIB_RGB_COLORS, 
                                   &pvBits, NULL, 0);
    DeleteDC(hDC);
    return hbm;
}

inline void MZCAPI FillBitmapDx(HBITMAP hbm, HBRUSH hbr)
{
    BITMAP bm;
    if (!GetObject(hbm, sizeof(bm), &bm))
        return;

    HDC hDC = CreateCompatibleDC(NULL);
    {
        HGDIOBJ hbmOld = SelectObject(hDC, hbm);
        {
            RECT rc;
            SetRect(&rc, 0, 0, bm.bmWidth, bm.bmHeight);
            FillRect(hDC, &rc, hbr);
            DeleteObject(hbr);
        }
        SelectObject(hDC, hbmOld);
    }
    DeleteDC(hDC);
}

inline void MZCAPI
PremultiplyDx(HBITMAP hbm32bpp)
{
    BITMAP bm;
    DWORD cdw;
    LPBYTE pb;
    BYTE alpha;
    GetObject(hbm32bpp, sizeof(bm), &bm);
    if (bm.bmBitsPixel == 32)
    {
        cdw = bm.bmWidth * bm.bmHeight;
        pb = (LPBYTE) bm.bmBits;
        while (cdw--)
        {
            alpha = pb[3];
            pb[0] = (BYTE) ((DWORD) pb[0] * alpha / 255);
            pb[1] = (BYTE) ((DWORD) pb[1] * alpha / 255);
            pb[2] = (BYTE) ((DWORD) pb[2] * alpha / 255);
            pb += 4;
        }
    }
}

inline BOOL MZCAPI CopyTextDx(HWND hwnd, const MString& text)
{
#ifdef UNICODE
    UINT CF_ = CF_UNICODETEXT;
#else
    UINT CF_ = CF_TEXT;
#endif
    DWORD size = DWORD((text.size() + 1) * sizeof(TCHAR));
    LPTSTR psz = (LPTSTR)GlobalAllocPtr(GMEM_SHARE | GMEM_MOVEABLE, size);
    if (psz)
    {
        HGLOBAL hGlobal = GlobalPtrHandle(psz);
        CopyMemory(psz, text.c_str(), size);
        GlobalUnlockPtr(psz);

        if (OpenClipboard(hwnd))
        {
            EmptyClipboard();
            SetClipboardData(CF_, hGlobal);
            return CloseClipboard();
        }
    }
    return FALSE;
}

inline void MZCAPI
PopupMenuDx(HWND hwnd, HWND hContext, UINT nMenuID, INT iSubMenu, INT x, INT y)
{
    HMENU hMenu = LoadMenu(GetModuleHandle(NULL), MAKEINTRESOURCE(nMenuID));
    HMENU hSubMenu = GetSubMenu(hMenu, iSubMenu);

    if (x == 0xFFFF && y == 0xFFFF)
    {
        RECT rc;
        GetWindowRect(hContext, &rc);
        x = rc.left;
        y = rc.top;
    }

    SetForegroundWindow(hwnd);
    TrackPopupMenu(hSubMenu, TPM_LEFTALIGN | TPM_RIGHTBUTTON, 
        x, y, 0, hwnd, NULL);
    PostMessage(hwnd, WM_NULL, 0, 0);
    DestroyMenu(hMenu);
}

//////////////////////////////////////////////////////////////////////////////

inline VOID
MWindowBase::SaveMessageDx(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    m_msg.hwnd = hwnd;
    m_msg.message = uMsg;
    m_msg.wParam = wParam;
    m_msg.lParam = lParam;
    m_msg.time = GetMessageTime();
    LONG nPos = GetMessagePos();
    m_msg.pt.x = GET_X_LPARAM(nPos);
    m_msg.pt.y = GET_Y_LPARAM(nPos);
}

inline /*static*/ LRESULT CALLBACK
MWindowBase::WindowProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
 {
    MWindowBase *base;
    if (uMsg == WM_CREATE)
    {
        TCHAR szClass[128];
        GetClassName(hwnd, szClass, _countof(szClass));

        LPCREATESTRUCT pcs = (LPCREATESTRUCT)lParam;
        if (pcs->lpCreateParams &&
            !IsBadReadPtr(pcs->lpCreateParams, sizeof(MWindowBase)) &&
            ((MWindowBase*)(pcs->lpCreateParams))->m_dwWindowBaseMagic == 0xFEEDFEED)
        {
            base = reinterpret_cast<MWindowBase *>(pcs->lpCreateParams);
            base->m_hwnd = hwnd;
        }
        else
        {
            // for DECLARE_DYNAMIC/IMPLEMENT_DYNAMIC
            auto it = MWindowBase::ClassToCreateMap().find(szClass);
            if (it == MWindowBase::ClassToCreateMap().end())
            {
                assert(0);
                return 0;
            }

            base = (*it->second)();
            base->m_bDynamicCreated = true;
            base->Attach(hwnd);
        }
    }
    else
    {
        base = GetUserData(hwnd);
    }

    LRESULT ret = 0;
    if (base)
    {
#ifndef NDEBUG
        TCHAR szClass[128];
        GetClassName(hwnd, szClass, _countof(szClass));
#endif
        base->SaveMessageDx(hwnd, uMsg, wParam, lParam);
        ret = base->WindowProcDx(hwnd, uMsg, wParam, lParam);

        if (uMsg == WM_NCDESTROY)
        {
            base->PostNcDestroy();
        }
    }
    else
    {
        ret = ::DefWindowProc(hwnd, uMsg, wParam, lParam);
    }

    return ret;
}

inline BOOL MWindowBase::RegisterClassDx()
{
    HMODULE hMod = ::GetModuleHandle(NULL);

    WNDCLASSEX wcx;
    LPCTSTR pszClass = GetWndClassNameDx();
    if (::GetClassInfoEx(NULL, pszClass, &wcx) ||
        ::GetClassInfoEx(hMod, pszClass, &wcx))
    {
        return TRUE;
    }

    ZeroMemory(&wcx, sizeof(wcx));
    wcx.cbSize = sizeof(wcx);
    wcx.style = CS_HREDRAW | CS_VREDRAW | CS_DBLCLKS;
    wcx.lpfnWndProc = MWindowBase::WindowProc;
    wcx.hInstance = hMod;
    wcx.hIcon = ::LoadIcon(NULL, IDI_APPLICATION);
    wcx.hCursor = ::LoadCursor(NULL, IDC_ARROW);
    wcx.hbrBackground = ::GetSysColorBrush(COLOR_3DFACE);
    wcx.lpszMenuName = NULL;
    wcx.lpszClassName = pszClass;
    wcx.hIconSm = ::LoadIcon(NULL, IDI_APPLICATION);

    ModifyWndClassDx(wcx);

    return ::RegisterClassEx(&wcx);
}

inline BOOL MWindowBase::CreateWindowDx(
    HWND hwndParent, LPCTSTR pszText, 
    DWORD Style/* = WS_OVERLAPPEDWINDOW*/, DWORD ExStyle/* = 0*/, 
    INT x/* = CW_USEDEFAULT*/, INT y/* = CW_USEDEFAULT*/, 
    INT cx/* = CW_USEDEFAULT*/, INT cy/* = CW_USEDEFAULT*/, 
    HMENU hMenu/* = NULL*/)
{
    if (!RegisterClassDx())
        return FALSE;

    HWND hwnd = ::CreateWindowEx(ExStyle, GetWndClassNameDx(), 
        GetStringDx(pszText), Style, x, y, cx, cy, hwndParent, 
        hMenu, GetModuleHandle(NULL), this);
    return Attach(hwnd);
}

inline BOOL
MWindowBase::CreateAsChildDx(
    HWND hwndParent, LPCTSTR pszText, 
    DWORD Style/* = WS_CHILD | WS_VISIBLE*/, 
    DWORD ExStyle/* = 0*/, INT nCtrlID/* = -1*/, 
    INT x/* = CW_USEDEFAULT*/, INT y/* = CW_USEDEFAULT*/, 
    INT cx/* = CW_USEDEFAULT*/, INT cy/* = CW_USEDEFAULT*/)
{
    Style |= WS_CHILD;
    return CreateWindowDx(hwndParent, pszText, Style, ExStyle, 
        x, y, cx, cy, (HMENU)(INT_PTR)nCtrlID);
}

inline INT
MWindowBase::MsgBoxDx(LPCTSTR pszString, LPCTSTR pszTitle, 
                      UINT uType/* = MB_ICONINFORMATION*/)
{
    MString Title;
    if (pszTitle == NULL)
    {
#ifdef IDS_APPNAME
        Title = LoadStringDx(IDS_APPNAME);
#else
        if (m_hwnd)
        {
            Title = GetWindowText(GetAncestorDx());
            size_t i = Title.find(TEXT(" - "));
            if (i != MString::npos)
            {
                Title = Title.substr(i + 3);
            }
        }
        else
        {
            Title = TEXT("ERROR");
        }
#endif
    }
    else
    {
        Title = GetStringDx(pszTitle);
    }

    extern BOOL g_bNoGuiMode;
    extern LPWSTR g_pszLogFile;
    UINT nID;
    if (g_bNoGuiMode)
    {
        if (g_pszLogFile)
        {
            if (FILE *fp = _wfopen(g_pszLogFile, L"a"))
            {
                fprintf(fp, "%ls\n", GetStringDx(pszString));
                fclose(fp);
            }
        }
        nID = IDYES;
    }
    else
    {
        MWindowBase::HookCenterMsgBoxDx(TRUE);
        nID = ::MessageBox(m_hwnd, GetStringDx(pszString), Title.c_str(), uType);
        MWindowBase::HookCenterMsgBoxDx(FALSE);
    }

    return nID;
}

inline /*static*/ MString MWindowBase::GetWindowText(HWND hwnd)
{
    INT cch = ::GetWindowTextLength(hwnd);
    MString ret;
    ret.resize(cch);
    if (!::GetWindowText(hwnd, &ret[0], cch + 1))
        ret.clear();
    return ret;
}

inline /*static*/ VOID MWindowBase::CenterWindowDx(HWND hwnd)
{
    assert(IsWindow(hwnd));

    BOOL bChild = !!(GetWindowStyle(hwnd) & WS_CHILD);

    HWND hwndParent;
    if (bChild)
        hwndParent = ::GetParent(hwnd);
    else
        hwndParent = ::GetWindow(hwnd, GW_OWNER);

    RECT rcWorkArea = WorkAreaFromWindowDx(hwnd);

    RECT rcParent;
    if (hwndParent)
        ::GetWindowRect(hwndParent, &rcParent);
    else
        rcParent = rcWorkArea;

    SIZE sizParent = SizeFromRectDx(&rcParent);

    RECT rc;
    ::GetWindowRect(hwnd, &rc);
    SIZE siz = SizeFromRectDx(&rc);

    POINT pt;
    pt.x = rcParent.left + (sizParent.cx - siz.cx) / 2;
    pt.y = rcParent.top + (sizParent.cy - siz.cy) / 2;

    if (bChild && hwndParent)
    {
        ::GetClientRect(hwndParent, &rcParent);
        ::MapWindowPoints(hwndParent, NULL, (LPPOINT)&rcParent, 2);
        RepositionPointDx(&pt, siz, &rcParent);

        ::ScreenToClient(hwndParent, &pt);
    }
    else
    {
        RepositionPointDx(&pt, siz, &rcWorkArea);
    }

    ::SetWindowPos(hwnd, NULL, pt.x, pt.y, 0, 0, 
                   SWP_NOSIZE | SWP_NOZORDER | SWP_NOACTIVATE);
}

inline /*static*/ BOOL MZCAPI
MWindowBase::GetWindowPosDx(HWND hwnd, POINT *ppt/* = NULL*/, SIZE *psiz/* = NULL*/)
{
    assert(IsWindow(hwnd));
    return ::GetWindowPosDx(hwnd, ppt, psiz);
}

inline BOOL MZCAPI
MWindowBase::GetWindowPosDx(POINT *ppt/* = NULL*/, SIZE *psiz/* = NULL*/)
{
    assert(IsWindow(m_hwnd));
    return ::GetWindowPosDx(m_hwnd, ppt, psiz);
}

inline /*static*/ BOOL MZCAPI MWindowBase::GetWindowPosDx(HWND hwnd, RECT *prc)
{
    assert(IsWindow(hwnd));
    return ::GetWindowPosDx(hwnd, prc);
}

inline BOOL MZCAPI MWindowBase::GetWindowPosDx(RECT *prc)
{
    assert(IsWindow(m_hwnd));
    return ::GetWindowPosDx(m_hwnd, prc);
}

inline /*static*/ BOOL
MWindowBase::SetWindowPosDx(
    HWND hwnd, LPPOINT ppt/* = NULL*/, LPSIZE psiz/* = NULL*/, 
    HWND hwndInsertAfter/* = NULL*/, 
    UINT uFlags/* = SWP_NOACTIVATE | SWP_NOOWNERZORDER*/)
{
    assert(IsWindow(hwnd));
    return ::SetWindowPosDx(hwnd, ppt, psiz, hwndInsertAfter, uFlags);
}

inline /*static*/ BOOL MWindowBase::SetWindowPosDx(HWND hwnd, const RECT *prc)
{
    assert(IsWindow(hwnd));
    return ::SetWindowPosDx(hwnd, prc);
}

inline BOOL
MWindowBase::SetWindowPosDx(
    LPPOINT ppt/* = NULL*/, LPSIZE psiz/* = NULL*/, 
    HWND hwndInsertAfter/* = NULL*/, 
    UINT uFlags/* = SWP_NOACTIVATE | SWP_NOOWNERZORDER*/)
{
    assert(IsWindow(m_hwnd));
    return ::SetWindowPosDx(m_hwnd, ppt, psiz, hwndInsertAfter, uFlags);
}

inline BOOL MWindowBase::SetWindowPosDx(const RECT *prc)
{
    assert(IsWindow(m_hwnd));
    return ::SetWindowPosDx(m_hwnd, prc);
}

inline /*static*/ HWND MWindowBase::GetAncestorDx(HWND hTarget)
{
    HWND hwndParent;
    for (;;)
    {
        hwndParent = ::GetParent(hTarget);
        if (hwndParent == NULL)
        {
            hwndParent = ::GetWindow(hTarget, GW_OWNER);
            if (hwndParent == NULL)
            {
                break;
            }
        }
        hTarget = hwndParent;
    }
    return hTarget;
}

/*static*/ inline LRESULT CALLBACK
MWindowBase::_msgBoxCbtProcDx(INT nCode, WPARAM wParam, LPARAM lParam)
{
#ifndef MZC_NO_CENTER_MSGBOX
    if (nCode == HCBT_ACTIVATE)
    {
        HWND hwnd = (HWND)wParam;
        TCHAR szClassName[16];
        ::GetClassName(hwnd, szClassName, _countof(szClassName));
        if (lstrcmpi(szClassName, TEXT("#32770")) == 0)
        {
            CenterWindowDx(hwnd);
        }
    }
#endif  // ndef MZC_NO_CENTER_MSGBOX

    return 0;   // allow the operation
}

inline /*static*/ HHOOK MWindowBase::HookCenterMsgBoxDx(BOOL bHook)
{
#ifdef MZC_NO_CENTER_MSGBOX
    return NULL;
#else   // ndef MZC_NO_CENTER_MSGBOX
    static HHOOK s_hHook = NULL;
    if (bHook)
    {
        if (s_hHook == NULL)
        {
            DWORD dwThreadID = GetCurrentThreadId();
            s_hHook = ::SetWindowsHookEx(WH_CBT, _msgBoxCbtProcDx, NULL, dwThreadID);
        }
    }
    else
    {
        if (s_hHook)
        {
            if (::UnhookWindowsHookEx(s_hHook))
            {
                s_hHook = NULL;
            }
        }
    }
    return s_hHook;
#endif  // ndef MZC_NO_CENTER_MSGBOX
}

//////////////////////////////////////////////////////////////////////////////

inline /*static*/ INT_PTR CALLBACK
MDialogBase::DialogProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    MDialogBase *base;
    if (uMsg == WM_INITDIALOG)
    {
        assert(lParam);
        base = (MDialogBase *)lParam;
        base->Attach(hwnd);
    }
    else
    {
        base = GetUserData(hwnd);
    }

    INT_PTR ret = 0;
    if (base)
    {
        base->SaveMessageDx(hwnd, uMsg, wParam, lParam);
        ret = base->DialogProcDx(hwnd, uMsg, wParam, lParam);
        if (uMsg == WM_NCDESTROY)
        {
            base->PostNcDestroy();
        }
    }

    return ret;
}

inline BOOL MDialogBase::CreateDialogDx(HWND hwndOwner, INT nDialogID)
{
    return CreateDialogDx(hwndOwner, MAKEINTRESOURCE(nDialogID));
}

inline INT_PTR MDialogBase::DialogBoxDx(HWND hwndOwner, INT nDialogID)
{
    return DialogBoxDx(hwndOwner, MAKEINTRESOURCE(nDialogID));
}

inline BOOL
MDialogBase::CreateDialogIndirectDx(HWND hwndOwner, const VOID *ptr)
{
    if (hwndOwner)
    {
        m_hwndOwner = hwndOwner;
    }
    m_bModal = FALSE;
    HWND hwnd = ::CreateDialogIndirectParam(::GetModuleHandle(NULL), 
        reinterpret_cast<const DLGTEMPLATE *>(ptr), 
        m_hwndOwner, MDialogBase::DialogProc, 
        reinterpret_cast<LPARAM>(this));
    if (hwnd == NULL)
    {
        Detach();
    }
    return hwnd != NULL;
}

inline INT_PTR
MDialogBase::DialogBoxIndirectDx(HWND hwndOwner, const VOID *ptr)
{
    if (hwndOwner)
    {
        m_hwndOwner = hwndOwner;
    }
    m_bModal = TRUE;
    INT_PTR nID = ::DialogBoxIndirectParam(::GetModuleHandle(NULL), 
                                           (const DLGTEMPLATE *)ptr, 
                                           m_hwndOwner, 
                                           MDialogBase::DialogProc, 
                                           reinterpret_cast<LPARAM>(this));
    return nID;
}

inline BOOL
MDialogBase::CreateDialogDx(HWND hwndOwner, LPCTSTR pDialogName)
{
    if (hwndOwner)
    {
        m_hwndOwner = hwndOwner;
    }
    m_bModal = FALSE;
    HWND hwnd = ::CreateDialogParam(::GetModuleHandle(NULL), pDialogName, 
                                    m_hwndOwner, MDialogBase::DialogProc, 
                                    reinterpret_cast<LPARAM>(this));
    if (hwnd == NULL)
    {
        Detach();
    }
    return hwnd != NULL;
}

inline INT_PTR
MDialogBase::DialogBoxDx(HWND hwndOwner, LPCTSTR pDialogName)
{
    if (hwndOwner)
    {
        m_hwndOwner = hwndOwner;
    }
    m_bModal = TRUE;
    INT_PTR nID = ::DialogBoxParam(::GetModuleHandle(NULL), 
        pDialogName, m_hwndOwner, MDialogBase::DialogProc, (LPARAM)this);
    return nID;
}

//////////////////////////////////////////////////////////////////////////////

#endif  // ndef MZC4_MWINDOWBASE_HPP_

```

`src/MacroParser.hpp`:

```hpp
// MacroParser.hpp --- macro parser for RisohEditor
//////////////////////////////////////////////////////////////////////////////
// RisohEditor --- Another free Win32 resource editor
// Copyright (C) 2017-2018 Katayama Hirofumi MZ <katayama.hirofumi.mz@gmail.com>
// 
// This program is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
// 
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
// 
// You should have received a copy of the GNU General Public License
// along with this program.  If not, see <http://www.gnu.org/licenses/>.
//////////////////////////////////////////////////////////////////////////////

#pragma once

#include <string>
#include <vector>
#include <cstdio>
#include <cassert>
#include <cstring>

/////////////////////////////////////////////////////////////////////////
// the BNF (subset of C language:
//
// <constant_expression> ::= <conditional_expression> (',' <conditional_expression>)*
//                         | <conditional_expression>
// <conditional_expression> ::= <logical_or_expression>
//                            | <logical_or_expression> '?' <constant_expression> ':' <conditional_expression>
// <logical_or_expression> ::= <logical_and_expression> ('||' <logical_and_expression>)*
// <logical_and_expression> ::= <inclusive_or_expression> ('&&' <inclusive_or_expression>)*
// <inclusive_or_expression> ::= <exclusive_or_expression> ('|' <exclusive_or_expression>)*
// <exclusive_or_expression> ::= <and_expression> ('^' <and_expression>)*
// <and_expression> ::= <equality_expression> ('&' <equality_expression>)*
// <equality_expression> ::= <relational_expression> (('=='|'!=') <relational_expression>)*
// <relational_expression> ::= <shift_expression> (('<'|'>'|'<='|'>=') <shift_expression>)*
// <shift_expression> ::= <additive_expression> (('<<'|'>>') <additive_expression>)*
// <additive_expression> ::= <multiplicative_expression> (('+'|'-') <multiplicative_expression>)*
// <multiplicative_expression> ::= <cast_expression> (('*'|'/'|'%') <cast_expression>)*
// <cast_expression> ::= <unary_expression>
// <unary_expression> ::= <postfix_expression>
//                      | <unary_operator>* <postfix_expression>
// <postfix_expression> ::= <primary_expression>
// <primary_expression> ::= <identifier>
//                        | <constant>
//                        | <string>
//                        | '(' <constant_expression> ')'
namespace MacroParser
{
    typedef std::string string_type;

    enum TokenType
    {
        TOK_IDENT,
        TOK_INTEGER,
        TOK_STRING,
        TOK_SYMBOL,
        TOK_EOF
    };

    inline bool isdigit(char ch)
    {
        return '0' <= ch && ch <= '9';
    }
    inline bool isoctal(char ch)
    {
        return '0' <= ch && ch <= '7';
    }
    inline bool isxdigit(char ch)
    {
        return isdigit(ch) || ('a' <= ch && ch <= 'f') || ('A' <= ch && ch <= 'F');
    }
    inline bool islower(char ch)
    {
        return 'a' <= ch && ch <= 'z';
    }
    inline bool isupper(char ch)
    {
        return 'A' <= ch && ch <= 'Z';
    }
    inline bool isalpha(char ch)
    {
        return islower(ch) || isupper(ch);
    }
    inline bool isalnum(char ch)
    {
        return isalpha(ch) || isdigit(ch);
    }
#undef iscsymf
#undef iscsym
    inline bool iscsymf(char ch)
    {
        return isalpha(ch) || ch == '_';
    }
    inline bool iscsym(char ch)
    {
        return isalnum(ch) || ch == '_';
    }
    inline bool isspace(char ch)
    {
        return strchr(" \t\n\r\f\v", ch) != NULL;
    }

    /////////////////////////////////////////////////////////////////////////

    class Token
    {
    public:
        string_type m_str;
        TokenType m_type;
        int m_integer;

        Token(string_type str, TokenType type)
            : m_str(str), m_type(type), m_integer(0)
        {
        }
        Token(string_type str, TokenType type, int i)
            : m_str(str), m_type(type), m_integer(i)
        {
        }

        void print() const
        {
            std::printf("(%d %s %d)", (int)m_type, m_str.c_str(), m_integer);
        }
    };
    typedef std::vector<Token> tokens_type;

    /////////////////////////////////////////////////////////////////////////

    class StringScanner
    {
    public:
        StringScanner(const string_type& str) : m_str(str), m_index(0)
        {
        }

        char getch()
        {
            if (m_index < m_str.size())
                return m_str[m_index++];
            return -1;
        }
        void ungetch()
        {
            if (m_index > 0)
                --m_index;
        }
        const char *peek() const
        {
            return &m_str[m_index];
        }
        bool match_get(const char *psz, string_type& str)
        {
            size_t len = strlen(psz);
            if (memcmp(peek(), psz, len) == 0)
            {
                str = psz;
                skip(len);
                return true;
            }
            return false;
        }
        void skip(size_t count)
        {
            if (m_index + count <= m_str.size())
                m_index += count;
        }

        string_type get_quoted();

    protected:
        string_type     m_str;
        size_t          m_index;
    };

    /////////////////////////////////////////////////////////////////////////

    class TokenStream
    {
    public:
        tokens_type     m_tokens;

        TokenStream(StringScanner& scanner);
        bool read_tokens();

              Token& token();
        const Token& token() const;
        void unget(size_t count = 1);
        bool next();

        size_t index() const;
        bool index(size_t i);
        size_t size() const;

        TokenType type() const;
        string_type str() const;
        int integer() const;

        void print() const;

        void push_back(const Token& t);

    protected:
        size_t          m_index;
        StringScanner&  m_scanner;

        char getch()
        {
            return m_scanner.getch();
        }
        void ungetch()
        {
            m_scanner.ungetch();
        }
    };

    /////////////////////////////////////////////////////////////////////////
    // AST

    enum AstID
    {
        ASTID_BINARY,
        ASTID_COMMA,
        ASTID_IDENT,
        ASTID_INTEGER,
        ASTID_STRING,
        ASTID_TRIPLE,
        ASTID_UNARY
    };

    struct BaseAst
    {
        AstID m_id;

        static int& alive_count()
        {
            static int s_count = 0;
            return s_count;
        }

        BaseAst(AstID id) : m_id(id)
        {
            ++alive_count();
        }
        virtual ~BaseAst()
        {
            --alive_count();
        }
        virtual void print() const
        {
            std::printf("[AST#%d]", (int)m_id);
        }
    private:
        BaseAst();
        BaseAst(const BaseAst&);
        BaseAst& operator=(const BaseAst&);
    };

    struct IdentAst : public BaseAst
    {
        string_type     m_name;

        IdentAst(const string_type& name) : BaseAst(ASTID_IDENT), m_name(name)
        {
        }
        virtual void print() const
        {
            BaseAst::print();
            std::printf(":%s.", m_name.c_str());
        }
    };

    struct IntegerAst : public BaseAst
    {
        int     m_value;

        IntegerAst(int value) : BaseAst(ASTID_INTEGER), m_value(value)
        {
        }
        virtual void print() const
        {
            BaseAst::print();
            std::printf(":%d.", m_value);
        }
    };

    struct StringAst : public BaseAst
    {
        string_type m_str;

        StringAst(const string_type& str) : BaseAst(ASTID_STRING), m_str(str)
        {
        }
        virtual void print() const
        {
            BaseAst::print();
            std::printf(":%s.", m_str.c_str());
        }
    };

    struct UnaryAst : public BaseAst
    {
        string_type m_str;
        BaseAst *m_arg;

        UnaryAst(const string_type& str, BaseAst *arg = NULL)
            : BaseAst(ASTID_UNARY), m_str(str), m_arg(arg)
        {
        }
        ~UnaryAst()
        {
            delete m_arg;
        }
        virtual void print() const
        {
            BaseAst::print();
            std::printf(":%s;", m_str.c_str());
            m_arg->print();
        }
    };

    struct BinaryAst : public BaseAst
    {
        string_type m_str;
        BaseAst *m_left;
        BaseAst *m_right;

        BinaryAst(const string_type& str, BaseAst *left, BaseAst *right)
            : BaseAst(ASTID_BINARY), m_str(str), m_left(left), m_right(right)
        {
        }
        ~BinaryAst()
        {
            delete m_left;
            delete m_right;
        }
        virtual void print() const
        {
            BaseAst::print();
            std::printf(":%s<", m_str.c_str());
            m_left->print();
            std::printf(",");
            m_right->print();
            std::printf(">");
        }
    };

    struct TripleAst : public BaseAst
    {
        string_type m_str;
        BaseAst *m_first;
        BaseAst *m_second;
        BaseAst *m_third;

        TripleAst(const string_type& str,
                  BaseAst *first, BaseAst *second, BaseAst *third)
            : BaseAst(ASTID_TRIPLE), m_str(str),
              m_first(first), m_second(second), m_third(third)
        {
        }
        ~TripleAst()
        {
            delete m_first;
            delete m_second;
            delete m_third;
        }
        virtual void print() const
        {
            BaseAst::print();
            std::printf(":%s<", m_str.c_str());
            m_first->print();
            std::printf(",");
            m_second->print();
            std::printf(",");
            m_third->print();
            std::printf(">");
        }
    };

    struct CommaAst : public BaseAst
    {
        std::vector<BaseAst *> m_args;

        CommaAst() : BaseAst(ASTID_COMMA)
        {
        }
        ~CommaAst()
        {
            for (size_t i = 0; i < m_args.size(); ++i)
            {
                delete m_args[i];
            }
        }
        void add(BaseAst *ast)
        {
            m_args.push_back(ast);
        }
        virtual void print() const
        {
            BaseAst::print();
            std::printf("<");
            if (m_args.size())
            {
                m_args[0]->print();
                for (size_t i = 1; i < m_args.size(); ++i)
                {
                    std::printf(",");
                    m_args[i]->print();
                }
            }
            std::printf(">");
        }
    };

    /////////////////////////////////////////////////////////////////////////

    class Parser
    {
    public:
        Parser(TokenStream& stream) : m_stream(stream), m_ast(NULL)
        {
        }
        ~Parser()
        {
            delete m_ast;
        }

        BaseAst *ast() const
        {
            return m_ast;
        }

        bool parse();

        BaseAst *visit_constant_expression();
        BaseAst *visit_conditional_expression();
        BaseAst *visit_logical_or_expression();
        BaseAst *visit_logical_and_expression();
        BaseAst *visit_inclusive_or_expression();
        BaseAst *visit_exclusive_or_expression();
        BaseAst *visit_and_expression();
        BaseAst *visit_equality_expression();
        BaseAst *visit_relational_expression();
        BaseAst *visit_shift_expression();
        BaseAst *visit_additive_expression();
        BaseAst *visit_multiplicative_expression();
        BaseAst *visit_cast_expression()
        {
            return visit_unary_expression();
        }
        BaseAst *visit_unary_expression();
        BaseAst *visit_postfix_expression()
        {
            return visit_primary_expression();
        }
        BaseAst *visit_primary_expression();

    protected:
        TokenStream m_stream;
        BaseAst *m_ast;

        size_t index() const
        {
            return m_stream.index();
        }
        void index(size_t i)
        {
            m_stream.index(i);
        }
        bool next()
        {
            return m_stream.next();
        }
        Token& token()
        {
            return m_stream.token();
        }
        const Token& token() const
        {
            return m_stream.token();
        }
        TokenType type() const
        {
            return m_stream.type();
        }
        string_type str() const
        {
            return m_stream.str();
        }
    };

    bool eval_int(const BaseAst *ast, int& value);

    /////////////////////////////////////////////////////////////////////////

    inline TokenStream::TokenStream(StringScanner& scanner)
        : m_index(0), m_scanner(scanner)
    {
    }

    inline void TokenStream::unget(size_t count/* = 1*/)
    {
        if (count <= m_index)
            m_index -= count;
        else
            m_index = 0;
    }

    inline bool TokenStream::next()
    {
        if (m_index + 1 < size())
        {
            ++m_index;
            return true;
        }
        return false;
    }

    inline void TokenStream::push_back(const Token& t)
    {
        m_tokens.push_back(t);
    }

    inline Token& TokenStream::token()
    {
        assert(m_index <= size());
        return m_tokens[m_index];
    }

    inline const Token& TokenStream::token() const
    {
        assert(m_index <= size());
        return m_tokens[m_index];
    }

    inline TokenType TokenStream::type() const
    {
        return token().m_type;
    }

    inline string_type TokenStream::str() const
    {
        return token().m_str;
    }

    inline int TokenStream::integer() const
    {
        return token().m_integer;
    }

    inline size_t TokenStream::index() const
    {
        return m_index;
    }

    inline size_t TokenStream::size() const
    {
        return m_tokens.size();
    }

    inline bool TokenStream::index(size_t i)
    {
        if (i <= size())
        {
            m_index = i;
            return true;
        }
        return false;
    }

    inline void TokenStream::print() const
    {
        std::printf("#: %d\n", (int)size());
        size_t i = 0;
        tokens_type::const_iterator it, end = m_tokens.end();
        for (it = m_tokens.begin(); it != end; ++it)
        {
            std::printf("token#%d: ", (int)i++);
            it->print();
            std::printf("\n");
        }
    }

    inline bool TokenStream::read_tokens()
    {
        m_tokens.clear();

        char ch;
        string_type str;
        for (;;)
        {
            ch = getch();
            if (isspace(ch))
            {
                continue;
            }
            else if (isdigit(ch))
            {
                // 0123456789
                str.clear();
                str += ch;
                for (;;)
                {
                    ch = getch();
                    if (ch == -1)
                    {
                        break;
                    }
                    if (!isalnum(ch) && ch != '_')
                    {
                        ungetch();
                        break;
                    }
                    str += ch;
                }
                int i = strtoul(str.c_str(), NULL, 0);
                Token token(str, TOK_INTEGER, i);
                m_tokens.push_back(token);
            }
            else if (iscsymf(ch) || ch == '_')
            {
                str.clear();
                str += ch;
                if (ch == 'L')
                {
                    // L"string"
                    ch = getch();
                    if (ch == '"')
                    {
                        ungetch();
                        str = m_scanner.get_quoted();
                        Token token("L" + str, TOK_STRING);
                        m_tokens.push_back(token);
                        continue;
                    }
                    ungetch();
                }
                // identifier
                for (;;)
                {
                    ch = getch();
                    if (ch == -1)
                    {
                        break;
                    }
                    if (!iscsym(ch))
                    {
                        ungetch();
                        break;
                    }
                    str += ch;
                }
                Token token(str, TOK_IDENT);
                m_tokens.push_back(token);
            }
            else if (ch == '"')
            {
                // "string"
                ungetch();
                str = m_scanner.get_quoted();
                Token token(str, TOK_STRING);
                m_tokens.push_back(token);
            }
            else if (ch == -1)
            {
                Token token("", TOK_EOF);
                m_tokens.push_back(token);
                return true;
            }
            else
            {
                str.clear();
                str += ch;
                if (strchr("+-*/%~()^,?:", ch) != NULL)
                {
                    Token token(str, TOK_SYMBOL);
                    m_tokens.push_back(token);
                }
                else
                {
                    ungetch();
                    if (m_scanner.match_get("<<", str) ||
                        m_scanner.match_get("<=", str) ||
                        m_scanner.match_get("<", str) ||
                        m_scanner.match_get(">>", str) ||
                        m_scanner.match_get(">=", str) ||
                        m_scanner.match_get(">", str) ||
                        m_scanner.match_get("==", str) ||
                        m_scanner.match_get("&&", str) ||
                        m_scanner.match_get("&", str) ||
                        m_scanner.match_get("||", str) ||
                        m_scanner.match_get("|", str) ||
                        m_scanner.match_get("!=", str) ||
                        m_scanner.match_get("!", str))
                    {
                        Token token(str, TOK_SYMBOL);
                        m_tokens.push_back(token);
                    }
                    else
                    {
                        return false;
                    }
                }
            }
        }
    }

    inline string_type StringScanner::get_quoted()
    {
        string_type ret;
        char ch = getch();
        assert(ch == '"');
        ret += ch;

        string_type str;
        for (;;)
        {
            if (match_get("\"\"", str) ||
                match_get("\\\"", str) ||
                match_get("\\\\", str))
            {
                ret += str;
                continue;
            }
            ch = getch();
            if (ch == -1)
                break;
            ret += ch;
            if (ch == '"')
                break;
        }
        return ret;
    }

    inline bool Parser::parse()
    {
        if (m_stream.size() == 0)
            return false;

        delete m_ast;
        m_ast = visit_constant_expression();
        if (m_ast != NULL && type() == TOK_EOF)
            return true;

        delete m_ast;
        m_ast = NULL;
        return false;
    }

    // <constant_expression> ::= <conditional_expression> (',' <conditional_expression>)*
    //                         | <conditional_expression>
    inline BaseAst *Parser::visit_constant_expression()
    {
        BaseAst *cond = visit_conditional_expression();
        if (cond == NULL)
            return NULL;

        if (type() == TOK_SYMBOL && str() == ",")
        {
            CommaAst *comma = new CommaAst();
            comma->add(cond);
            do
            {
                next();
                cond = visit_conditional_expression();
                if (cond == NULL)
                {
                    delete comma;
                    return NULL;
                }
                comma->add(cond);
            } while (type() == TOK_SYMBOL && str() == ",");
            return comma;
        }
        return cond;
    }

    // <conditional_expression> ::= <logical_or_expression>
    //                            | <logical_or_expression> '?' <constant_expression> ':' <conditional_expression>
    inline BaseAst* Parser::visit_conditional_expression()
    {
        BaseAst *first = visit_logical_or_expression();
        if (first == NULL)
            return NULL;

        if (type() == TOK_SYMBOL && str() == "?")
        {
            next();
            BaseAst *second = visit_constant_expression();
            if (second)
            {
                if (type() == TOK_SYMBOL && str() == ":")
                {
                    next();
                    BaseAst *third = visit_conditional_expression();
                    if (third)
                    {
                        return new TripleAst("?", first, second, third);
                    }
                }
            }
            delete second;
            delete first;
            return NULL;
        }
        return first;
    }

    // <logical_or_expression> ::= <logical_and_expression> ('||' <logical_and_expression>)*
    inline BaseAst* Parser::visit_logical_or_expression()
    {
        BaseAst *first = visit_logical_and_expression();
        while (first)
        {
            if (type() == TOK_SYMBOL && str() == "||")
            {
                next();
                BaseAst *second = visit_logical_and_expression();
                if (second)
                {
                    first = new BinaryAst("||", first, second);
                    continue;
                }
                delete first;
                return NULL;
            }
            else
            {
                break;
            }
        }
        return first;
    }

    // <logical_and_expression> ::= <inclusive_or_expression> ('&&' <inclusive_or_expression>)*
    inline BaseAst* Parser::visit_logical_and_expression()
    {
        BaseAst *first = visit_inclusive_or_expression();
        while (first)
        {
            if (type() == TOK_SYMBOL && str() == "&&")
            {
                next();
                BaseAst *second = visit_inclusive_or_expression();
                if (second)
                {
                    first = new BinaryAst("&&", first, second);
                    continue;
                }
                delete first;
                return NULL;
            }
            else
            {
                break;
            }
        }
        return first;
    }

    // <inclusive_or_expression> ::= <exclusive_or_expression> ('|' <exclusive_or_expression>)*
    inline BaseAst* Parser::visit_inclusive_or_expression()
    {
        BaseAst *first = visit_exclusive_or_expression();
        while (first)
        {
            if (type() == TOK_SYMBOL && str() == "|")
            {
                next();
                BaseAst *second = visit_exclusive_or_expression();
                if (second)
                {
                    first = new BinaryAst("|", first, second);
                    continue;
                }
                delete first;
                return NULL;
            }
            else
            {
                break;
            }
        }
        return first;
    }

    // <exclusive_or_expression> ::= <and_expression> ('^' <and_expression>)*
    inline BaseAst* Parser::visit_exclusive_or_expression()
    {
        BaseAst *first = visit_and_expression();
        while (first)
        {
            if (type() == TOK_SYMBOL && str() == "^")
            {
                next();
                BaseAst *second = visit_and_expression();
                if (second)
                {
                    first = new BinaryAst("^", first, second);
                    continue;
                }
                delete first;
                return NULL;
            }
            else
            {
                break;
            }
        }
        return first;
    }

    // <and_expression> ::= <equality_expression> ('&' <equality_expression>)*
    inline BaseAst* Parser::visit_and_expression()
    {
        BaseAst *first = visit_equality_expression();
        while (first)
        {
            if (type() == TOK_SYMBOL && str() == "&")
            {
                next();
                BaseAst *second = visit_equality_expression();
                if (second)
                {
                    first = new BinaryAst("&", first, second);
                    continue;
                }
                delete first;
                return NULL;
            }
            else
            {
                break;
            }
        }
        return first;
    }

    // <equality_expression> ::= <relational_expression> (('=='|'!=') <relational_expression>)*
    inline BaseAst* Parser::visit_equality_expression()
    {
        BaseAst *first = visit_relational_expression();
        while (first)
        {
            string_type s = str();
            if (type() == TOK_SYMBOL && (s == "==" || s == "!="))
            {
                next();
                BaseAst *second = visit_relational_expression();
                if (second)
                {
                    first = new BinaryAst(s, first, second);
                    continue;
                }
                delete first;
                return NULL;
            }
            else
            {
                break;
            }
        }
        return first;
    }

    // <relational_expression> ::= <shift_expression> (('<'|'>'|'<='|'>=') <shift_expression>)*
    inline BaseAst* Parser::visit_relational_expression()
    {
        BaseAst *first = visit_shift_expression();
        while (first)
        {
            string_type s = str();
            if (type() == TOK_SYMBOL &&
                (s == "<" || s == ">" || s == "<=" || s == ">="))
            {
                next();
                BaseAst *second = visit_shift_expression();
                if (second)
                {
                    first = new BinaryAst(s, first, second);
                    continue;
                }
                delete first;
                return NULL;
            }
            else
            {
                break;
            }
        }
        return first;
    }

    // <shift_expression> ::= <additive_expression> (('<<'|'>>') <additive_expression>)*
    inline BaseAst* Parser::visit_shift_expression()
    {
        BaseAst *first = visit_additive_expression();
        while (first)
        {
            string_type s = str();
            if (type() == TOK_SYMBOL && (s == "<<" || s == ">>"))
            {
                next();
                BaseAst *second = visit_additive_expression();
                if (second)
                {
                    first = new BinaryAst(s, first, second);
                    continue;
                }
                delete first;
                return NULL;
            }
            else
            {
                break;
            }
        }
        return first;
    }

    // <additive_expression> ::= <multiplicative_expression> (('+'|'-') <multiplicative_expression>)*
    inline BaseAst* Parser::visit_additive_expression()
    {
        BaseAst *first = visit_multiplicative_expression();
        while (first)
        {
            string_type s = str();
            if (type() == TOK_SYMBOL && (s == "+" || s == "-"))
            {
                next();
                BaseAst *second = visit_multiplicative_expression();
                if (second)
                {
                    first = new BinaryAst(s, first, second);
                    continue;
                }
                delete first;
                return NULL;
            }
            else
            {
                break;
            }
        }
        return first;
    }

    // <multiplicative_expression> ::= <cast_expression> (('*'|'/'|'%') <cast_expression>)*
    inline BaseAst* Parser::visit_multiplicative_expression()
    {
        BaseAst *first = visit_cast_expression();
        while (first)
        {
            string_type s = str();
            if (type() == TOK_SYMBOL && (s == "*" || s == "/" || s == "%"))
            {
                next();
                BaseAst *second = visit_cast_expression();
                if (second)
                {
                    first = new BinaryAst(s, first, second);
                    continue;
                }
                delete first;
                return NULL;
            }
            else
            {
                break;
            }
        }
        return first;
    }

    // <unary_expression> ::= <postfix_expression>
    //                      | <unary_operator>* <postfix_expression>
    inline BaseAst* Parser::visit_unary_expression()
    {
        UnaryAst *ret = NULL, *first = NULL;
        while (type() == TOK_SYMBOL &&
               (str() == "+" || str() == "-" || str() == "~" || str() == "!"))
        {
            ret = new UnaryAst(str(), ret);
            if (first == NULL)
                first = ret;
            next();
        }
        if (ret)
        {
            BaseAst *postfix = visit_postfix_expression();
            if (postfix)
            {
                first->m_arg = postfix;
                return ret;
            }
            delete ret;
            return NULL;
        }
        else
        {
            return visit_postfix_expression();
        }
    }

    // <primary_expression> ::= <identifier>
    //                        | <constant>
    //                        | <string>
    //                        | '(' <constant_expression> ')'
    inline BaseAst* Parser::visit_primary_expression()
    {
        BaseAst *ast = NULL;
        switch (type())
        {
        case TOK_IDENT:
            ast = new IdentAst(str());
            next();
            return ast;
        case TOK_INTEGER:
            ast = new IntegerAst(token().m_integer);
            next();
            break;
        case TOK_STRING:
            ast = new StringAst(str());
            next();
            break;
        case TOK_SYMBOL:
            if (str() == "(")
            {
                next();
                ast = visit_constant_expression();
                if (ast)
                {
                    if (type() == TOK_SYMBOL && str() == ")")
                    {
                        next();
                        return ast;
                    }
                    delete ast;
                    ast = NULL;
                }
            }
            else
            {
                ast = NULL;
            }
            break;
        case TOK_EOF:
            ast = NULL;
            break;
        }
        return ast;
    }

    inline bool eval_binary(const BaseAst *ast, int& value)
    {
        const BinaryAst *binary = (const BinaryAst *)ast;
        int left, right;
        if (!eval_int(binary->m_left, left) || !eval_int(binary->m_right, right))
        {
            value = 0;
            return false;
        }

        if (binary->m_str == "+") value = left + right;
        else if (binary->m_str == "-") value = left - right;
        else if (binary->m_str == "*") value = left * right;
        else if (binary->m_str == "/") value = left / right;
        else if (binary->m_str == "%") value = left % right;
        else if (binary->m_str == "^") value = left ^ right;
        else if (binary->m_str == "<<") value = left << right;
        else if (binary->m_str == "<=") value = left <= right;
        else if (binary->m_str == "<") value = left < right;
        else if (binary->m_str == ">>") value = left >> right;
        else if (binary->m_str == ">=") value = left >= right;
        else if (binary->m_str == ">") value = left > right;
        else if (binary->m_str == "==") value = left == right;
        else if (binary->m_str == "&&") value = left && right;
        else if (binary->m_str == "&") value = left & right;
        else if (binary->m_str == "||") value = left || right;
        else if (binary->m_str == "|") value = left | right;
        else if (binary->m_str == "!=") value = left != right;
        else return false;
        return true;
    }
    inline bool eval_comma(const BaseAst *ast, int& value)
    {
        const CommaAst *comma = (const CommaAst *)ast;
        if (comma->m_args.empty())
        {
            value = 0;
            return false;
        }
        return eval_int(comma->m_args[comma->m_args.size() - 1], value);
    }
    inline bool eval_ident(const BaseAst *ast, int& value)
    {
        value = 0;
        return false;
    }
    inline bool eval_integer(const BaseAst *ast, int& value)
    {
        const IntegerAst *integer = (const IntegerAst *)ast;
        value = integer->m_value;
        return true;
    }
    inline bool eval_string(const BaseAst *ast, string_type& value)
    {
        if (ast->m_id == ASTID_STRING)
        {
            const StringAst *str = (const StringAst *)ast;
            value = str->m_str;
            return true;
        }
        return false;
    }
    inline bool eval_triple(const BaseAst *ast, int& value)
    {
        const TripleAst *triple = (const TripleAst *)ast;
        if (triple->m_str != "?")
        {
            value = 0;
            return false;
        }
        int first, second, third;
        if (!eval_int(triple->m_first, first) ||
            !eval_int(triple->m_second, second) ||
            !eval_int(triple->m_third, third))
        {
            value = 0;
            return false;
        }
        value = first ? second : third;
        return true;
    }
    inline bool eval_unary(const BaseAst *ast, int& value)
    {
        const UnaryAst *unary = (const UnaryAst *)ast;
        if (!eval_int(unary->m_arg, value))
            return false;

        if (unary->m_str == "+") value = value;
        else if (unary->m_str == "-") value = -value;
        else if (unary->m_str == "~") value = ~value;
        else if (unary->m_str == "!") value = !value;
        else if (unary->m_str == "+") value = value;
        else if (unary->m_str == "+") value = value;
        else return false;
        return true;
    }

    inline bool eval_int(const BaseAst *ast, int& value)
    {
        switch (ast->m_id)
        {
        case ASTID_BINARY:
            return eval_binary(ast, value);
        case ASTID_COMMA:
            return eval_comma(ast, value);
        case ASTID_IDENT:
            return eval_ident(ast, value);
        case ASTID_INTEGER:
            return eval_integer(ast, value);
        case ASTID_STRING:
            value = 0;
            return true;
        case ASTID_TRIPLE:
            return eval_triple(ast, value);
        case ASTID_UNARY:
            return eval_unary(ast, value);
        default:
            value = 0;
            return false;
        }
    }

    inline bool is_str(const BaseAst *ast)
    {
        return ast->m_id == ASTID_STRING;
    }
} // namespace MacroParser

```

`src/MenuRes.cpp`:

```cpp
// MenuRes.cpp --- Menu Resources
//////////////////////////////////////////////////////////////////////////////
// RisohEditor --- Another free Win32 resource editor
// Copyright (C) 2017-2020 Katayama Hirofumi MZ <katayama.hirofumi.mz@gmail.com>
// 
// This program is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
// 
// This program is distributed in the hope that it will be useful, 
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
// 
// You should have received a copy of the GNU General Public License
// along with this program.  If not, see <http://www.gnu.org/licenses/>.
//////////////////////////////////////////////////////////////////////////////

#include "MenuRes.hpp"
#include "ConstantsDB.hpp"
#include <stack>
#include <cassert>

MStringW GetMenuFlags(WORD fItemFlags)
{
    MStringW str;

    if ((fItemFlags & MF_GRAYED) == MF_GRAYED)
        str += L"G ";

    if ((fItemFlags & MF_BITMAP) == MF_BITMAP)
        str += L"B ";

    if ((fItemFlags & MF_OWNERDRAW) == MF_OWNERDRAW)
        str += L"OD ";

    if ((fItemFlags & MF_CHECKED) == MF_CHECKED)
        str += L"C ";

    if ((fItemFlags & MF_MENUBARBREAK) == MF_MENUBARBREAK)
        str += L"MBB ";

    if ((fItemFlags & MF_MENUBREAK) == MF_MENUBREAK)
        str += L"MB ";

    if ((fItemFlags & MF_HELP) == MF_HELP)
        str += L"HP ";

    return str;
}

void SetMenuFlags(WORD& fItemFlags, const MStringW& str)
{
    fItemFlags = 0;
    MStringW str2 = L" " + str;

    if (str2.find(L" G ") != MStringW::npos)
        fItemFlags |= MF_GRAYED;

    if (str2.find(L" B ") != MStringW::npos)
        fItemFlags |= MF_BITMAP;

    if (str2.find(L" OD ") != MStringW::npos)
        fItemFlags |= MF_OWNERDRAW;

    if (str2.find(L" C ") != MStringW::npos)
        fItemFlags |= MF_CHECKED;

    if (str2.find(L" MBB ") != MStringW::npos)
        fItemFlags |= MF_MENUBARBREAK;

    if (str2.find(L" MB ") != MStringW::npos)
        fItemFlags |= MF_MENUBREAK;

    if (str2.find(L" HP ") != MStringW::npos)
        fItemFlags |= MF_HELP;
}

MStringW GetMenuTypeAndState(DWORD dwType, DWORD dwState)
{
    MStringW str;

    if ((dwState & MFS_GRAYED) == MFS_GRAYED)
        str += L"G ";

    if ((dwType & MFT_BITMAP) == MFT_BITMAP)
        str += L"B ";

    if ((dwType & MFT_OWNERDRAW) == MFT_OWNERDRAW)
        str += L"OD ";

    if ((dwState & MFS_CHECKED) == MFS_CHECKED)
        str += L"C ";

    if ((dwType & MFT_SEPARATOR) == MFT_SEPARATOR)
        str += L"S ";

    if ((dwType & MFT_MENUBARBREAK) == MFT_MENUBARBREAK)
        str += L"MBB ";

    if ((dwType & MFT_MENUBREAK) == MFT_MENUBREAK)
        str += L"MB ";

    if ((dwState & MFS_DEFAULT) == MFS_DEFAULT)
        str += L"D ";

    if ((dwState & MFS_HILITE) == MFS_HILITE)
        str += L"H ";

    if ((dwType & MFT_RADIOCHECK) == MFT_RADIOCHECK)
        str += L"RC ";

    if ((dwType & MFT_RIGHTORDER) == MFT_RIGHTORDER)
        str += L"RO ";

    if ((dwType & MFT_RIGHTJUSTIFY) == MFT_RIGHTJUSTIFY)
        str += L"RJ ";

    return str;
}

void SetMenuTypeAndState(DWORD& dwType, DWORD& dwState, const MStringW& str)
{
    dwType = dwState = 0;
    MStringW str2 = L" " + str;

    if (str2.find(L" G ") != MStringW::npos)
        dwState |= MFS_GRAYED;

    if (str2.find(L" B ") != MStringW::npos)
        dwType |= MFT_BITMAP;

    if (str2.find(L" OD ") != MStringW::npos)
        dwType |= MFT_OWNERDRAW;

    if (str2.find(L" C ") != MStringW::npos)
        dwState |= MFS_CHECKED;

    if (str2.find(L" S ") != MStringW::npos)
        dwType |= MFT_SEPARATOR;

    if (str2.find(L" MBB ") != MStringW::npos)
        dwType |= MFT_MENUBARBREAK;

    if (str2.find(L" MB ") != MStringW::npos)
        dwType |= MFT_MENUBREAK;

    if (str2.find(L" D ") != MStringW::npos)
        dwState |= MFS_DEFAULT;

    if (str2.find(L" H ") != MStringW::npos)
        dwState |= MFS_HILITE;

    if (str2.find(L" RC ") != MStringW::npos)
        dwType |= MFT_RADIOCHECK;

    if (str2.find(L" RO ") != MStringW::npos)
        dwType |= MFT_RIGHTORDER;

    if (str2.find(L" RJ ") != MStringW::npos)
        dwType |= MFT_RIGHTJUSTIFY;
}

//////////////////////////////////////////////////////////////////////////////

bool MenuRes::LoadFromStream(const MByteStreamEx& stream)
{
    if (!stream.PeekWord(m_header.wVersion))
        return false;

    if (m_header.wVersion == 1)
        return LoadFromStreamEx(stream);

    MENUHEADER header;
    if (!stream.ReadRaw(header) ||
        header.wVersion != 0 || header.cbHeaderSize != 0)
    {
        return false;
    }

    std::stack<BYTE> flag_stack;
    flag_stack.push(true);

    WORD wDepth = 0, fItemFlags;
    MenuItem item;
    while (stream.PeekWord(fItemFlags))
    {
        if (fItemFlags & MF_POPUP)
        {
            flag_stack.push(!!(fItemFlags & MF_END));

            POPUPMENUITEMHEAD head;
            if (!stream.ReadRaw(head) || !stream.ReadSz(item.text))
                break;

            item.fItemFlags = fItemFlags;
            item.wMenuID = 0;
            item.wDepth = wDepth++;
            m_items.push_back(item);
        }
        else
        {
            NORMALMENUITEMHEAD head;
            if (!stream.ReadRaw(head) || !stream.ReadSz(item.text))
                break;

            item.fItemFlags = fItemFlags;
            item.wMenuID = head.wMenuID;
            item.wDepth = wDepth;
            m_items.push_back(item);

            if (fItemFlags & MF_END)
            {
                --wDepth;
                while (flag_stack.size() && flag_stack.top())
                {
                    flag_stack.pop();
                    if (wDepth == 0)
                        break;
                    --wDepth;
                }
                if (flag_stack.empty())
                    break;
            }
        }
    }

    return true;
}

bool MenuRes::LoadFromStreamEx(const MByteStreamEx& stream)
{
    if (!stream.ReadRaw(m_header))
    {
        assert(0);
        return false;
    }

    if (m_header.wVersion != 1 || m_header.wOffset < 4)
    {
        assert(0);
        return false;
    }
    stream.pos(4 + m_header.wOffset);
    stream.ReadDwordAlignment();

    std::stack<BYTE> flag_stack;
    flag_stack.push(true);

    WORD wDepth = 0;
    ExMenuItem exitem;
    MENUEX_TEMPLATE_ITEM_HEADER item_header;

    stream.ReadDwordAlignment();
    while (stream.ReadRaw(item_header))
    {
        if (!stream.ReadSz(exitem.text))
            break;

        if (item_header.bResInfo & 0x01)
        {
            flag_stack.push(!!(item_header.bResInfo & 0x80));

            stream.ReadDwordAlignment();
            if (!stream.ReadRaw(exitem.dwHelpId))
                break;

            exitem.dwType = item_header.dwType;
            exitem.dwState = item_header.dwState;
            exitem.menuId = item_header.menuId;
            exitem.bResInfo = item_header.bResInfo;
            exitem.wDepth = wDepth++;
            m_exitems.push_back(exitem);
        }
        else
        {
            exitem.dwHelpId = 0;
            exitem.dwType = item_header.dwType;
            exitem.dwState = item_header.dwState;
            exitem.menuId = item_header.menuId;
            exitem.bResInfo = item_header.bResInfo;
            exitem.wDepth = wDepth;
            m_exitems.push_back(exitem);

            if (item_header.bResInfo & 0x80)
            {
                --wDepth;
                while (flag_stack.size() && flag_stack.top())
                {
                    flag_stack.pop();
                    if (wDepth == 0)
                        break;
                    --wDepth;
                }
                if (flag_stack.empty())
                    break;
            }
        }
        stream.ReadDwordAlignment();
    }
    return true;
}

MenuRes::string_type
MenuRes::DumpFlags(WORD fItemFlags) const
{
    string_type ret;
    if (fItemFlags & MF_GRAYED)
        ret += L", GRAYED";
    if (fItemFlags & MF_INACTIVE)
        ret += L", INACTIVE";
    if (fItemFlags & MF_BITMAP)
        ret += L", BITMAP";
    if (fItemFlags & MF_OWNERDRAW)
        ret += L", OWNERDRAW";
    if (fItemFlags & MF_CHECKED)
        ret += L", CHECKED";
    if (fItemFlags & MF_MENUBARBREAK)
        ret += L", MENUBARBREAK";
    if (fItemFlags & MF_MENUBREAK)
        ret += L", MENUBREAK";
    if (fItemFlags & MF_HELP)
        ret += L", HELP";
    return ret;
}

std::vector<BYTE> MenuRes::data() const
{
    MByteStreamEx stream;
    if (IsExtended())
        SaveToStreamEx(stream);
    else
        SaveToStream(stream);
    return stream.data();
}

bool MenuRes::SaveToStream(MByteStreamEx& stream) const
{
    if (IsExtended())
        return SaveToStreamEx(stream);

    MENUHEADER header;
    header.wVersion = 0;
    header.cbHeaderSize = 0;
    if (!stream.WriteRaw(header))
        return false;

    for (auto& item : m_items)
    {
        WORD fItemFlags = item.fItemFlags;
        if (fItemFlags & MF_POPUP)
        {
            POPUPMENUITEMHEAD head;
            head.fItemFlags = fItemFlags;
            if (!stream.WriteRaw(head) || !stream.WriteSz(item.text))
                return false;
        }
        else
        {
            NORMALMENUITEMHEAD head;
            head.fItemFlags = item.fItemFlags;
            head.wMenuID = item.wMenuID;
            if (!stream.WriteRaw(head) || !stream.WriteSz(item.text))
                return false;
        }
    }

    return true;
}

bool MenuRes::SaveToStreamEx(MByteStreamEx& stream) const
{
    if (!IsExtended())
        return false;

    MENUEX_TEMPLATE_HEADER header;
    header.wVersion = 1;
    header.wOffset = 4;
    header.dwHelpId = m_header.dwHelpId;
    if (!stream.WriteRaw(header))
    {
        assert(0);
        return false;
    }

    for (auto& exitem : m_exitems)
    {
        stream.WriteDwordAlignment();

        MENUEX_TEMPLATE_ITEM_HEADER item_header;
        item_header.dwType = exitem.dwType;
        item_header.dwState = exitem.dwState;
        item_header.menuId = exitem.menuId;
        item_header.bResInfo = exitem.bResInfo;
        if (!stream.WriteRaw(item_header) ||
            !stream.WriteSz(exitem.text))
        {
            assert(0);
            return false;
        }

        if (item_header.bResInfo & 0x01)
        {
            stream.WriteDwordAlignment();
            if (!stream.WriteRaw(exitem.dwHelpId))
                return false;
        }
    }

    return true;
}

MenuRes::string_type
MenuRes::Dump(const MIdOrString& name) const
{
    if (IsExtended())
        return DumpEx(name);

    string_type ret;

    if (name.m_id == 0)
    {
        ret += name.str();
    }
    else
    {
        ret += g_db.GetNameOfResID(IDTYPE_MENU, name.m_id, true);
    }

    ret += L" MENU\r\n";
    if (g_settings.bUseBeginEnd)
        ret += L"BEGIN\r\n";
    else
        ret += L"{\r\n";

    WORD wDepth = 0;
    for (auto& item : m_items)
    {
        while (item.wDepth < wDepth)
        {
            --wDepth;
            ret += string_type((wDepth + 1) * 4, L' ');
            if (g_settings.bUseBeginEnd)
                ret += L"END\r\n";
            else
                ret += L"}\r\n";
        }
        wDepth = item.wDepth;
        if (item.fItemFlags & MF_POPUP)
        {
            ret += string_type((item.wDepth + 1) * 4, L' ');
            ret += L"POPUP \"";
            ret += mstr_escape(item.text);
            ret += L"\"";
            ret += DumpFlags(item.fItemFlags);
            ret += L"\r\n";
            ret += string_type((item.wDepth + 1) * 4, L' ');
            if (g_settings.bUseBeginEnd)
                ret += L"BEGIN\r\n";
            else
                ret += L"{\r\n";
        }
        else
        {
            ret += string_type((item.wDepth + 1) * 4, L' ');
            if (item.text.empty())
            {
                ret += L"MENUITEM SEPARATOR\r\n";
            }
            else
            {
                ret += L"MENUITEM \"";
                ret += mstr_escape(item.text);
                ret += L"\", ";
                if (0)
                {
                    ret += mstr_dec_word(item.wMenuID);
                }
                else
                {
                    ret += g_db.GetNameOfResID(IDTYPE_COMMAND, IDTYPE_NEWCOMMAND, item.wMenuID, true);
                }
                ret += DumpFlags(item.fItemFlags);
                ret += L"\r\n";
            }
        }
    }
    while (0 < wDepth)
    {
        --wDepth;
        ret += string_type((wDepth + 1) * 4, L' ');
        if (g_settings.bUseBeginEnd)
            ret += L"END\r\n";
        else
            ret += L"}\r\n";
    }

    if (g_settings.bUseBeginEnd)
        ret += L"END\r\n";
    else
        ret += L"}\r\n";

    return ret;
}

MenuRes::string_type
MenuRes::DumpEx(const MIdOrString& name) const
{
    string_type ret;

    if (name.m_id == 0)
    {
        ret += name.str();
    }
    else
    {
        ret += g_db.GetNameOfResID(IDTYPE_MENU, name.m_id, true);
    }

    ret += L" MENUEX\r\n";
    if (g_settings.bUseBeginEnd)
        ret += L"BEGIN\r\n";
    else
        ret += L"{\r\n";

    WORD wDepth = 0;
    for (auto& item : m_exitems)
    {
        while (item.wDepth < wDepth)
        {
            --wDepth;
            ret += string_type((wDepth + 1) * 4, L' ');
            if (g_settings.bUseBeginEnd)
                ret += L"END\r\n";
            else
                ret += L"}\r\n";
        }
        wDepth = item.wDepth;
        if (item.bResInfo & 0x01)
        {
            ret += string_type((item.wDepth + 1) * 4, L' ');
            ret += L"POPUP ";
            ret += mstr_quote(item.text);
            if (item.menuId || item.dwType || item.dwState || item.dwHelpId)
            {
                ret += L", ";
                if (0)
                {
                    ret += mstr_dec_dword(item.menuId);
                }
                else
                {
                    ret += g_db.GetNameOfResID(IDTYPE_COMMAND, IDTYPE_NEWCOMMAND, item.menuId, true);
                }
            }
            if (item.dwType || item.dwState || item.dwHelpId)
            {
                ret += L", ";
                DWORD value = item.dwType;
                ret += g_db.DumpBitFieldOrZero(L"MFT_", value);
            }
            if (item.dwState || item.dwHelpId)
            {
                ret += L", ";
                DWORD value = item.dwState;
                ret += g_db.DumpBitFieldOrZero(L"MFS_", value);
            }
            if (item.dwHelpId)
            {
                ret += L", ";
                if (0)
                {
                    ret += mstr_dec_dword(item.dwHelpId);
                }
                else
                {
                    ret += g_db.GetNameOfResID(IDTYPE_HELP, item.dwHelpId);
                }
            }
            ret += L"\r\n";
            ret += string_type((item.wDepth + 1) * 4, L' ');
            if (g_settings.bUseBeginEnd)
                ret += L"BEGIN\r\n";
            else
                ret += L"{\r\n";
        }
        else
        {
            ret += string_type((item.wDepth + 1) * 4, L' ');
            ret += L"MENUITEM ";
            ret += mstr_quote(item.text);
            if (item.menuId || item.dwType || item.dwState)
            {
                ret += L", ";
                if (0)
                {
                    ret += mstr_dec_dword(item.menuId);
                }
                else
                {
                    ret += g_db.GetNameOfResID(IDTYPE_COMMAND, IDTYPE_NEWCOMMAND, item.menuId, true);
                }
            }
            if (item.dwType || item.dwState)
            {
                ret += L", ";
                DWORD value = item.dwType;
                ret += g_db.DumpBitFieldOrZero(L"MFT_", value);
            }
            if (item.dwState)
            {
                ret += L", ";
                DWORD value = item.dwState;
                ret += g_db.DumpBitFieldOrZero(L"MFS_", value);
            }
            ret += L"\r\n";
        }
    }
    while (0 < wDepth)
    {
        --wDepth;
        ret += string_type((wDepth + 1) * 4, L' ');
        if (g_settings.bUseBeginEnd)
            ret += L"END\r\n";
        else
            ret += L"}\r\n";
    }

    if (g_settings.bUseBeginEnd)
        ret += L"END\r\n";
    else
        ret += L"}\r\n";

    return ret;
}

void MenuRes::Update()
{
    if (IsExtended())
    {
        for (size_t i = 0; i < m_exitems.size(); ++i)
        {
            if (IsLastItem(i))
            {
                m_exitems[i].bResInfo |= 0x80;
            }
            else
            {
                m_exitems[i].bResInfo &= ~0x80;
            }

            if (IsParent(i))
            {
                m_exitems[i].bResInfo |= 0x01;
            }
            else
            {
                m_exitems[i].bResInfo &= ~0x01;
            }
        }
    }
    else
    {
        for (size_t i = 0; i < m_items.size(); ++i)
        {
            if (IsLastItem(i))
            {
                m_items[i].fItemFlags |= MF_END;
            }
            else
            {
                m_items[i].fItemFlags &= ~MF_END;
            }

            if (IsParent(i))
            {
                m_items[i].fItemFlags |= MF_POPUP;
            }
            else
            {
                m_items[i].fItemFlags &= ~MF_POPUP;
            }
        }
    }
}

bool MenuRes::IsParent(size_t iItem) const
{
    if (IsExtended())
    {
        WORD wDepth = m_exitems[iItem].wDepth;
        if (iItem + 1 < m_exitems.size() &&
            wDepth < m_exitems[iItem + 1].wDepth)
        {
            return true;
        }
    }
    else
    {
        WORD wDepth = m_items[iItem].wDepth;
        if (iItem + 1 < m_items.size() &&
            wDepth < m_items[iItem + 1].wDepth)
        {
            return true;
        }
    }
    return false;
}

bool MenuRes::IsLastItem(size_t iItem) const
{
    bool Found = false;
    if (IsExtended())
    {
        WORD wDepth = m_exitems[iItem].wDepth;
        for (size_t i = iItem + 1; i < m_exitems.size(); ++i)
        {
            if (m_exitems[i].wDepth == wDepth)
            {
                Found = true;
            }
            if (m_exitems[i].wDepth < wDepth)
            {
                break;
            }
        }
    }
    else
    {
        WORD wDepth = m_items[iItem].wDepth;
        for (size_t i = iItem + 1; i < m_items.size(); ++i)
        {
            if (m_items[i].wDepth == wDepth)
            {
                Found = true;
            }
            if (m_items[i].wDepth < wDepth)
            {
                break;
            }
        }
    }
    return !Found;
}

```

`src/MenuRes.hpp`:

```hpp
// MenuRes.hpp  --- Menu Resources
//////////////////////////////////////////////////////////////////////////////
// RisohEditor --- Another free Win32 resource editor
// Copyright (C) 2017-2020 Katayama Hirofumi MZ <katayama.hirofumi.mz@gmail.com>
// 
// This program is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
// 
// This program is distributed in the hope that it will be useful, 
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
// 
// You should have received a copy of the GNU General Public License
// along with this program.  If not, see <http://www.gnu.org/licenses/>.
//////////////////////////////////////////////////////////////////////////////

#pragma once

#ifndef _INC_WINDOWS
    #include <windows.h>
#endif
#include <vector>
#include "MByteStreamEx.hpp"

MStringW GetMenuFlags(WORD fItemFlags);
void SetMenuFlags(WORD& fItemFlags, const MStringW& str);
MStringW GetMenuTypeAndState(DWORD dwType, DWORD dwState);
void SetMenuTypeAndState(DWORD& dwType, DWORD& dwState, const MStringW& str);

//////////////////////////////////////////////////////////////////////////////

// header of RT_MENU
typedef struct MENUHEADER
{
    WORD    wVersion;       // zero
    WORD    cbHeaderSize;   // zero
} MENUHEADER;

typedef struct NORMALMENUITEMHEAD
{
    WORD   fItemFlags;      // MF_
    WORD   wMenuID;
    //WCHAR  szItemText[];
} NORMALMENUITEMHEAD;

typedef struct POPUPMENUITEMHEAD
{
    WORD    fItemFlags;     // MF_
    //WCHAR  szItemText[];
} POPUPMENUITEMHEAD;

// You can use the following flags for fItemFlags:
//     MF_GRAYED        0x0001   // 'GRAYED' keyword 
//     MF_INACTIVE      0x0002   // 'INACTIVE' keyword 
//     MF_BITMAP        0x0004   // 'BITMAP' keyword 
//     MF_OWNERDRAW     0x0100   // 'OWNERDRAW' keyword 
//     MF_CHECKED       0x0008   // 'CHECKED' keyword 
//     MF_POPUP         0x0010   // Used internally 
//     MF_MENUBARBREAK  0x0020   // 'MENUBARBREAK' keyword 
//     MF_MENUBREAK     0x0040   // 'MENUBREAK' keyword 
//     MF_END           0x0080   // Used internally 

#ifndef MF_INACTIVE
    #define MF_INACTIVE     MF_DISABLED
#endif
#ifndef MF_END
    #define MF_END          0x0080
#endif

// header of RT_MENU (MENUEX)
typedef struct MENUEX_TEMPLATE_HEADER
{
    WORD    wVersion;       // one
    WORD    wOffset;        // offset to items from this structure
    DWORD   dwHelpId;
} MENUEX_TEMPLATE_HEADER;

// item of MENUEX resource
#include <pshpack1.h>
typedef struct MENUEX_TEMPLATE_ITEM_HEADER
{
    DWORD   dwType;         // MFT_
    DWORD   dwState;        // MFS_
    DWORD   menuId;
    WORD    bResInfo;       // 0x80: is it last?, 0x01: popup
    //WCHAR szText[];
    //DWORD dwHelpId;       // only if popup
} MENUEX_TEMPLATE_ITEM_HEADER;
#include <poppack.h>

struct MENU_ENTRY
{
    WCHAR szCaption[128];
    WCHAR szFlags[64];
    WCHAR szCommandID[64];
    WCHAR szHelpID[64];
    WORD wDepth;
};

//////////////////////////////////////////////////////////////////////////////

class MenuRes
{
public:
    typedef MStringW    string_type;
    struct MenuItem
    {
        WORD            fItemFlags;
        WORD            wMenuID;
        WORD            wDepth;
        string_type     text;
    };
    typedef std::vector<MenuItem>  MenuItemsType;
    struct ExMenuItem
    {
        DWORD           dwType;     // MFT_
        DWORD           dwState;    // MFS_
        UINT            menuId;
        WORD            bResInfo;
        string_type     text;
        DWORD           dwHelpId;
        WORD            wDepth;
    };
    typedef std::vector<ExMenuItem>  ExMenuItemsType;

    MenuRes()
    {
        ZeroMemory(&m_header, sizeof(m_header));
    }

    bool IsExtended() const
    {
        return (m_header.wVersion == 1);
    }

    bool LoadFromStream(const MByteStreamEx& stream);
    bool LoadFromStreamEx(const MByteStreamEx& stream);
    bool SaveToStream(MByteStreamEx& stream) const;
    bool SaveToStreamEx(MByteStreamEx& stream) const;
    string_type Dump(const MIdOrString& name) const;
    string_type DumpEx(const MIdOrString& name) const;
    std::vector<BYTE> data() const;

    void Update();

    MENUEX_TEMPLATE_HEADER& header()
    {
        return m_header;
    }
    const MENUEX_TEMPLATE_HEADER& header() const
    {
        return m_header;
    }

    MenuItemsType& items()
    {
        return m_items;
    }
    const MenuItemsType& items() const
    {
        return m_items;
    }

    ExMenuItemsType& exitems()
    {
        return m_exitems;
    }
    const ExMenuItemsType& exitems() const
    {
        return m_exitems;
    }

protected:
    MENUEX_TEMPLATE_HEADER  m_header;
    MenuItemsType           m_items;
    ExMenuItemsType         m_exitems;

    bool IsParent(size_t iItem) const;
    bool IsLastItem(size_t iItem) const;
    string_type DumpFlags(WORD fItemFlags) const;
};

```

`src/MessageRes.hpp`:

```hpp
// MessageRes.hpp --- Message Table Resources
//////////////////////////////////////////////////////////////////////////////
// RisohEditor --- Another free Win32 resource editor
// Copyright (C) 2017-2018 Katayama Hirofumi MZ <katayama.hirofumi.mz@gmail.com>
// 
// This program is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
// 
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
// 
// You should have received a copy of the GNU General Public License
// along with this program.  If not, see <http://www.gnu.org/licenses/>.
//////////////////////////////////////////////////////////////////////////////

#pragma once

#include "MByteStream.hpp"
#include "MString.hpp"
#include "MTextToText.hpp"
#ifndef NO_CONSTANTS_DB
    #include "ConstantsDB.hpp"
#endif
#include <map>

//////////////////////////////////////////////////////////////////////////////

#if !defined(_WIN32) || defined(WONVER)
    typedef struct _MESSAGE_RESOURCE_BLOCK {
        DWORD    LowId;
        DWORD    HighId;
        DWORD    OffsetToEntries;        // from this structure
    } MESSAGE_RESOURCE_BLOCK, *PMESSAGE_RESOURCE_BLOCK;

    typedef struct _MESSAGE_RESOURCE_DATA {
        DWORD                    NumberOfBlocks;
        MESSAGE_RESOURCE_BLOCK   Blocks[1];
    } MESSAGE_RESOURCE_DATA, *PMESSAGE_RESOURCE_DATA;

    typedef struct _MESSAGE_RESOURCE_ENTRY {
        WORD   Length;
        WORD   Flags;        // 0 for ANSI, 1 for Unicode
        BYTE   Text[1];
    } MESSAGE_RESOURCE_ENTRY, *PMESSAGE_RESOURCE_ENTRY;

    #define MESSAGE_RESOURCE_UNICODE 0x0001
#endif

typedef struct _MESSAGE_RESOURCE_DATA_HEADER {
    DWORD                    NumberOfBlocks;
} MESSAGE_RESOURCE_DATA_HEADER, *PMESSAGE_RESOURCE_DATA_HEADER;

typedef struct _MESSAGE_RESOURCE_ENTRY_HEADER {
    WORD   Length;
    WORD   Flags;        // 0 for ANSI, 1 for Unicode
} MESSAGE_RESOURCE_ENTRY_HEADER, *PMESSAGE_RESOURCE_ENTRY_HEADER;

//////////////////////////////////////////////////////////////////////////////

#ifndef NO_CONSTANTS_DB
    struct MESSAGE_ENTRY
    {
        WCHAR MessageID[128];
        WCHAR MessageValue[512];
    };

    BOOL MsgDlg_GetEntry(HWND hwnd, MESSAGE_ENTRY& entry);
    void MsgDlg_SetEntry(HWND hwnd, MESSAGE_ENTRY& entry);
#endif

//////////////////////////////////////////////////////////////////////////////

class MessageRes
{
public:
    typedef MStringW string_type;
    typedef std::map<ULONG, string_type> map_type;
    map_type    m_map;

    map_type& map()
    {
        return m_map;
    }
    const map_type& map() const
    {
        return m_map;
    }

    MessageRes() = default;

    bool empty() const
    {
        return m_map.empty();
    }

    void clear()
    {
        m_map.clear();
    }

    bool LoadFromStream(const MByteStream& stream, WORD wUnused)
    {
        m_map.clear();
        if (stream.size() < sizeof(MESSAGE_RESOURCE_DATA))
            return false;

        MESSAGE_RESOURCE_DATA_HEADER data;
        if (!stream.ReadRaw(data) || data.NumberOfBlocks == 0)
            return false;

        std::vector<MESSAGE_RESOURCE_BLOCK> blocks(data.NumberOfBlocks);
        DWORD dwSizeOfBlocks = sizeof(MESSAGE_RESOURCE_BLOCK) * data.NumberOfBlocks;
        if (!stream.ReadData(&blocks[0], dwSizeOfBlocks))
            return false;

        for (DWORD i = 0; i < data.NumberOfBlocks; ++i)
        {
            const MESSAGE_RESOURCE_BLOCK& block = blocks[i];

            DWORD dwOffset = block.OffsetToEntries;
            stream.pos(dwOffset);

            for (DWORD dwID = block.LowId; dwID <= block.HighId; ++dwID)
            {
                size_t pos = stream.pos();

                MESSAGE_RESOURCE_ENTRY_HEADER entry_head;
                if (!stream.ReadRaw(entry_head))
                    return false;

                if (entry_head.Flags & MESSAGE_RESOURCE_UNICODE)
                {
                    size_t len = (entry_head.Length - sizeof(entry_head)) / sizeof(WCHAR);
                    MStringW str;
                    str.resize(len);
                    if (!stream.ReadData(&str[0], len * sizeof(WCHAR)))
                    {
                        return false;
                    }
                    str.resize(mstrlen(str.c_str()));
                    m_map[dwID] = std::move(str);
                }
                else
                {
                    size_t len = entry_head.Length - sizeof(entry_head);
                    MStringA str;
                    str.resize(len);
                    if (!stream.ReadData(&str[0], len * sizeof(char)))
                    {
                        return false;
                    }
                    str.resize(std::strlen(str.c_str()));
                    m_map[dwID] = MAnsiToWide(CP_ACP, str.c_str()).c_str();
                }

                stream.pos(pos + entry_head.Length);
            }
        }

        return true;
    }

    bool SaveToStream(MByteStream& stream)
    {
        if (m_map.empty())
            return true;

        ranges_type ranges;
        if (!GetRanges(ranges))
            return false;

        offsets_type offsets;
        if (!OffsetsFromRanges(offsets, ranges))
            return false;

        ULONG NumberOfBlocks = DWORD(ranges.size());
        if (!stream.WriteRaw(NumberOfBlocks))
            return false;

        std::vector<MESSAGE_RESOURCE_BLOCK> Blocks;
        {
            size_t i = 0;
            auto end = ranges.end();
            for (auto it = ranges.begin(); it != end; ++it, ++i)
            {
                MESSAGE_RESOURCE_BLOCK Block;
                Block.LowId = it->FirstId;
                Block.HighId = it->LastId;
                Block.OffsetToEntries = (DWORD)offsets[i];
                Blocks.push_back(Block);
            }
        }

        size_t SizeOfBlocks = Blocks.size() * sizeof(MESSAGE_RESOURCE_BLOCK);
        if (!stream.WriteData(&Blocks[0], SizeOfBlocks))
            return false;

        {
            auto end = ranges.end();
            for (auto it = ranges.begin(); it != end; ++it)
            {
                for (DWORD k = it->FirstId; k <= it->LastId; ++k)
                {
                    MStringW& wstr = m_map[k];

                    MESSAGE_RESOURCE_ENTRY_HEADER header;
                    header.Length = (WORD)(sizeof(header) + (wstr.size() + 1) * sizeof(WCHAR));
                    header.Flags = MESSAGE_RESOURCE_UNICODE;
                    if (!stream.WriteRaw(header))
                        return false;

                    size_t size = (wstr.size() + 1) * sizeof(WCHAR);
                    if (!stream.WriteData(&wstr[0], size))
                        return false;
                }
            }
        }

        return true;
    }

#ifdef NO_CONSTANTS_DB
    string_type Dump() const
    {
        MStringW ret, str;

        ret += WIDE("MESSAGETABLEDX\r\n");
        ret += WIDE("{\r\n");

        map_type::const_iterator it, end = m_map.end();
        for (it = m_map.begin(); it != end; ++it)
        {
            ret += WIDE("    0x");
            {
                mstr_to_hex(str, it->first);
                ret += str;
            }
            ret += WIDE(", \"");
            ret += mstr_escape(it->second);
            ret += WIDE("\"\r\n");
        }

        ret += WIDE("}\r\n");
        return ret;
    }
#else
    string_type Dump(WORD wName) const
    {
        MStringW ret;

        ret += WIDE("MESSAGETABLEDX\r\n");
        if (g_settings.bUseBeginEnd)
            ret += WIDE("BEGIN\r\n");
        else
            ret += WIDE("{\r\n");

        map_type::const_iterator it, end = m_map.end();
        for (it = m_map.begin(); it != end; ++it)
        {
            ret += WIDE("    ");
            ret += g_db.GetNameOfResID(IDTYPE_MESSAGE, it->first);
            ret += WIDE(", \"");
            ret += mstr_escape(it->second);
            ret += WIDE("\"\r\n");
        }

        if (g_settings.bUseBeginEnd)
            ret += WIDE("END\r\n");
        else
            ret += WIDE("}\r\n");
        return ret;
    }
    string_type Dump() const
    {
        return Dump(1);
    }
#endif

protected:
    struct RANGE_OF_ID
    {
        ULONG FirstId;
        ULONG LastId;
    };
    typedef RANGE_OF_ID range_type;
    typedef std::vector<range_type> ranges_type;

    bool GetRanges(ranges_type& ranges) const
    {
        RANGE_OF_ID range = { 0xFFFFFFFF, 0xFFFFFFFF };

        map_type::const_iterator it, end = m_map.end();
        for (it = m_map.begin(); it != end; ++it)
        {
            if (range.LastId == 0xFFFFFFFF)
            {
                range.FirstId = range.LastId = it->first;
            }
            else if (range.LastId + 1 == it->first)
            {
                ++range.LastId;
            }
            else
            {
                ranges.push_back(range);
                range.FirstId = range.LastId = it->first;
            }
        }
        ranges.push_back(range);

        return true;
    }

    typedef std::vector<size_t> offsets_type;
    bool OffsetsFromRanges(offsets_type& offsets, const ranges_type& ranges)
    {
        size_t offset = sizeof(ULONG);
        offset += sizeof(MESSAGE_RESOURCE_BLOCK) * ranges.size();

        ranges_type::const_iterator it, end = ranges.end();
        for (it = ranges.begin(); it != end; ++it)
        {
            offsets.push_back(offset);
            for (DWORD k = it->FirstId; k <= it->LastId; ++k)
            {
                offset += sizeof(MESSAGE_RESOURCE_ENTRY_HEADER);
                offset += (m_map[k].size() + 1) * sizeof(WCHAR);
            }
        }
        return true;
    }
};

```

`src/PackedDIB.cpp`:

```cpp
// PackedDIB.cpp --- Packed DIB
//////////////////////////////////////////////////////////////////////////////
// RisohEditor --- Another free Win32 resource editor
// Copyright (C) 2017-2018 Katayama Hirofumi MZ <katayama.hirofumi.mz@gmail.com>
// 
// This program is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
// 
// This program is distributed in the hope that it will be useful, 
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
// 
// You should have received a copy of the GNU General Public License
// along with this program.  If not, see <http://www.gnu.org/licenses/>.
//////////////////////////////////////////////////////////////////////////////

#include "PackedDIB.hpp"
#include "MIdOrString.hpp"
#include "MByteStreamEx.hpp"
#include <strsafe.h>
#include <gdiplus.h>

#define WIDTHBYTES(i) (((i) + 31) / 32 * 4)

//////////////////////////////////////////////////////////////////////////////

inline INT GetEncoderClsid(const WCHAR *format, CLSID *pClsid)
{
    UINT nCount = 0, cbItem = 0;

    Gdiplus::GetImageEncodersSize(&nCount, &cbItem);
    if (cbItem == 0)
        return -1;  // Failure

    Gdiplus::ImageCodecInfo *pInfo = NULL;
    pInfo = (Gdiplus::ImageCodecInfo *)std::malloc(cbItem);
    if (pInfo == NULL)
        return -1;  // Failure

    GetImageEncoders(nCount, cbItem, pInfo);

    for (UINT k = 0; k < nCount; ++k)
    {
        if (lstrcmpW(pInfo[k].MimeType, format) == 0)
        {
            *pClsid = pInfo[k].Clsid;
            free(pInfo);
            return k;  // Success
        }
    }

    std::free(pInfo);
    return -1;  // Failure
}

DWORD
PackedDIB_GetBitsOffset(const void *pPackedDIB, DWORD dwSize)
{
    BITMAPCOREHEADER bc;
    BITMAPINFOHEADER bi;
    DWORD Ret;

    if (pPackedDIB == NULL || dwSize < sizeof(bc))
    {
        assert(0);
        return 0;   // failure
    }

    if (memcmp(pPackedDIB, "\x89\x50\x4E\x47", 4) == 0)
        return 0;   // PNG

    DWORD HeaderSize = *(DWORD *)pPackedDIB;
    DWORD ColorCount = 0;
    if (HeaderSize == sizeof(bc))
    {
        CopyMemory(&bc, pPackedDIB, sizeof(bc));

        switch (bc.bcBitCount)
        {
        case 1:     ColorCount = 2;     break;
        case 4:     ColorCount = 16;    break;
        case 8:     ColorCount = 256;   break;
        case 24:    break;
        default:
            assert(0);
            return 0;   // failure
        }

        Ret = bc.bcSize + ColorCount * sizeof(RGBTRIPLE);
        return (Ret <= dwSize) ? Ret : 0;
    }

    if (HeaderSize < sizeof(bi))
    {
        assert(0);
        return 0;       // failure
    }

    CopyMemory(&bi, pPackedDIB, sizeof(bi));

    switch (bi.biBitCount)
    {
    case 1:
        ColorCount = (bi.biClrUsed ? bi.biClrUsed : 2);
        break;
    case 4:
        ColorCount = (bi.biClrUsed ? bi.biClrUsed : 16);
        break;
    case 8:
        ColorCount = (bi.biClrUsed ? bi.biClrUsed : 256);
        break;
    case 16: case 32:
        if (bi.biCompression == BI_BITFIELDS)
        {
            ColorCount = 3;
        }
        break;
    case 24:
        break;
    default:
        assert(0);
        return 0;   // failure
    }

    Ret = bi.biSize + ColorCount * sizeof(RGBQUAD);
    if (Ret > dwSize)
    {
        assert(0);
        Ret = 0;
    }
    return Ret;
}

BOOL
PackedDIB_GetInfo(const void *pPackedDIB, DWORD dwSize, BITMAP& bm)
{
    DWORD Offset = PackedDIB_GetBitsOffset(pPackedDIB, dwSize);
    if (Offset == 0)
        return FALSE;   // failure

    const BYTE *pb = (const BYTE *)pPackedDIB;
    DWORD HeaderSize = *(const DWORD *)pPackedDIB;
    if (HeaderSize == sizeof(BITMAPCOREHEADER))
    {
        BITMAPCOREHEADER *pbc = (BITMAPCOREHEADER *)pPackedDIB;
        bm.bmType = 0;
        bm.bmWidth = pbc->bcWidth;
        bm.bmHeight = pbc->bcHeight;
        bm.bmWidthBytes = WIDTHBYTES(pbc->bcWidth * pbc->bcBitCount);
        bm.bmPlanes = 1;
        bm.bmBitsPixel = pbc->bcBitCount;
        bm.bmBits = (LPVOID)(LPBYTE)(pb + Offset);
        return TRUE;
    }

    if (HeaderSize >= sizeof(BITMAPINFOHEADER))
    {
        BITMAPINFOHEADER *pbi = (BITMAPINFOHEADER *)pPackedDIB;
        bm.bmType = 0;
        bm.bmWidth = pbi->biWidth;
        bm.bmHeight = pbi->biHeight;
        bm.bmWidthBytes = WIDTHBYTES(pbi->biWidth * pbi->biBitCount);
        bm.bmPlanes = 1;
        bm.bmBitsPixel = pbi->biBitCount;
        bm.bmBits = (LPVOID)(LPBYTE)(pb + Offset);
        return TRUE;
    }

    assert(0);
    return FALSE;    // failure
}

HBITMAP
PackedDIB_CreateBitmap(const void *pPackedDIB, DWORD dwSize)
{
    DWORD Offset = PackedDIB_GetBitsOffset(pPackedDIB, dwSize);
    if (Offset == 0)
        return NULL;

    LPBYTE pb = (LPBYTE)pPackedDIB + Offset;
    dwSize -= Offset;

    BITMAPINFO bi = *(const BITMAPINFO *)pPackedDIB;
    //BITMAPINFOHEADER *pbmih = &bi.bmiHeader;
    LPVOID pBits;

    HBITMAP hbm;
    HDC hDC = CreateCompatibleDC(NULL);
    hbm = CreateDIBSection(hDC, &bi, DIB_RGB_COLORS, &pBits, NULL, 0);
    DeleteDC(hDC);

    // FIXME: BI_RLE4 and BI_RLE8
    if (hbm)
    {
        CopyMemory(pBits, pb, dwSize);
    }

    return hbm;
}

HICON
PackedDIB_CreateIcon(const void *pPackedDIB, DWORD dwSize, BITMAP& bm, BOOL bIcon)
{
    LPBYTE pb = (LPBYTE)(void *)pPackedDIB;

    //int xHotSpot = 0, yHotSpot = 0;
    if (!bIcon)
    {
        //xHotSpot = ((LPWORD)pb)[0];
        //yHotSpot = ((LPWORD)pb)[1];
        pb += 2 * sizeof(WORD);
        dwSize -= 2 * sizeof(WORD);
    }

    if (!PackedDIB_GetInfo(pb, dwSize, bm))
    {
        return NULL;
    }
    bm.bmHeight /= 2;

    if (!bIcon)
    {
        pb -= 2 * sizeof(WORD);
        dwSize += 2 * sizeof(WORD);
    }

    HICON hIcon;
    hIcon = CreateIconFromResourceEx(pb, dwSize, bIcon, 0x00030000, 
                                     bm.bmWidth, bm.bmHeight, 0);
    assert(hIcon);
    return hIcon;
}

typedef struct tagBITMAPINFOEX
{
    BITMAPINFOHEADER bmiHeader;
    RGBQUAD          bmiColors[256];
} BITMAPINFOEX, FAR * LPBITMAPINFOEX;

BOOL
PackedDIB_CreateFromHandle(std::vector<BYTE>& vecData, HBITMAP hbm)
{
    vecData.clear();

    BITMAP bm;
    if (!GetObject(hbm, sizeof(bm), &bm))
        return FALSE;

    BITMAPINFOEX bi;
    BITMAPINFOHEADER *pbmih;
    DWORD cColors, cbColors;

    pbmih = &bi.bmiHeader;
    ZeroMemory(pbmih, sizeof(BITMAPINFOHEADER));
    pbmih->biSize             = sizeof(BITMAPINFOHEADER);
    pbmih->biWidth            = bm.bmWidth;
    pbmih->biHeight           = bm.bmHeight;
    pbmih->biPlanes           = 1;
    pbmih->biBitCount         = bm.bmBitsPixel;
    pbmih->biCompression      = BI_RGB;
    pbmih->biSizeImage        = bm.bmWidthBytes * bm.bmHeight;

    if (bm.bmBitsPixel < 16)
        cColors = 1 << bm.bmBitsPixel;
    else
        cColors = 0;
    cbColors = cColors * sizeof(RGBQUAD);

    std::vector<BYTE> Bits(pbmih->biSizeImage);
    HDC hDC = CreateCompatibleDC(NULL);
    if (hDC == NULL)
        return FALSE;

    LPBITMAPINFO pbi = LPBITMAPINFO(&bi);
    if (!GetDIBits(hDC, hbm, 0, bm.bmHeight, &Bits[0], pbi, DIB_RGB_COLORS))
    {
        DeleteDC(hDC);
        return FALSE;
    }

    DeleteDC(hDC);

    MByteStreamEx bs;
    if (bs.WriteRaw(*pbmih) &&
        bs.WriteData(bi.bmiColors, cbColors) &&
        bs.WriteData(&Bits[0], Bits.size()))
    {
        vecData = bs.data();
        return TRUE;
    }
    return FALSE;
}

BOOL
PackedDIB_Extract(LPCWSTR FileName, const void *ptr, size_t siz, BOOL WritePNG)
{
    BITMAPFILEHEADER FileHeader;

    if (WritePNG)
    {
        BOOL ret = FALSE;
        HBITMAP hbm = PackedDIB_CreateBitmap(ptr, DWORD(siz));
        Gdiplus::Bitmap *pBitmap = Gdiplus::Bitmap::FromHBITMAP(hbm, NULL);
        if (pBitmap)
        {
            CLSID cls;
            if (GetEncoderClsid(L"image/png", &cls) != -1)
            {
                ret = pBitmap->Save(FileName, &cls, NULL) == Gdiplus::Ok;
            }
        }
        DeleteObject(hbm);
        return ret;
    }

    FileHeader.bfType = 0x4d42;
    FileHeader.bfSize = (DWORD)(sizeof(FileHeader) + siz);
    FileHeader.bfReserved1 = 0;
    FileHeader.bfReserved2 = 0;

    DWORD dwOffset = PackedDIB_GetBitsOffset(ptr, DWORD(siz));
    if (dwOffset == 0)
        return FALSE;

    FileHeader.bfOffBits = sizeof(FileHeader) + dwOffset;

    MByteStreamEx bs;
    if (!bs.WriteRaw(FileHeader) || !bs.WriteData(ptr, siz))
        return FALSE;

    return bs.SaveToFile(FileName);
}

HBITMAP PackedDIB_CreateBitmapFromMemory(const void *ptr, size_t siz)
{
    HBITMAP hbm = NULL;

    // Try a dirty hack for BI_RLE4, BI_RLE8, ...
    WCHAR szPath[MAX_PATH], szTempFile[MAX_PATH];
    GetTempPathW(_countof(szPath), szPath);
    GetTempFileNameW(szPath, L"reb", 0, szTempFile);

    if (PackedDIB_Extract(szTempFile, ptr, siz, FALSE))
    {
        hbm = (HBITMAP)LoadImageW(NULL, szTempFile, IMAGE_BITMAP, 0, 0, 
                                  LR_LOADFROMFILE | LR_COLOR);
    }

    DeleteFileW(szTempFile);

    if (hbm == NULL)
        hbm = PackedDIB_CreateBitmap(ptr, DWORD(siz));

    return hbm;
}

```

`src/PackedDIB.hpp`:

```hpp
// PackedDIB.hpp --- Packed DIB
//////////////////////////////////////////////////////////////////////////////
// RisohEditor --- Another free Win32 resource editor
// Copyright (C) 2017-2018 Katayama Hirofumi MZ <katayama.hirofumi.mz@gmail.com>
// 
// This program is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
// 
// This program is distributed in the hope that it will be useful, 
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
// 
// You should have received a copy of the GNU General Public License
// along with this program.  If not, see <http://www.gnu.org/licenses/>.
//////////////////////////////////////////////////////////////////////////////

#pragma once

#ifndef _INC_WINDOWS
    #include <windows.h>
#endif
#include <vector>

//////////////////////////////////////////////////////////////////////////////

INT GetEncoderClsid(const WCHAR *format, CLSID *pClsid);
DWORD PackedDIB_GetBitsOffset(const void *pPackedDIB, DWORD dwSize);
BOOL PackedDIB_GetInfo(const void *pPackedDIB, DWORD dwSize, BITMAP& bm);
HBITMAP PackedDIB_CreateBitmap(const void *pPackedDIB, DWORD dwSize);
HICON PackedDIB_CreateIcon(const void *pPackedDIB, DWORD dwSize, BITMAP& bm, BOOL bIcon);
BOOL PackedDIB_CreateFromHandle(std::vector<BYTE>& vecData, HBITMAP hbm);
BOOL PackedDIB_Extract(LPCWSTR FileName, const void *ptr, size_t siz, BOOL WritePNG);
HBITMAP PackedDIB_CreateBitmapFromMemory(const void *ptr, size_t siz);

```

`src/Res.cpp`:

```cpp
// Res.cpp --- Win32 Resources
//////////////////////////////////////////////////////////////////////////////
// RisohEditor --- Another free Win32 resource editor
// Copyright (C) 2017-2020 Katayama Hirofumi MZ <katayama.hirofumi.mz@gmail.com>
// 
// This program is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
// 
// This program is distributed in the hope that it will be useful, 
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
// 
// You should have received a copy of the GNU General Public License
// along with this program.  If not, see <http://www.gnu.org/licenses/>.
//////////////////////////////////////////////////////////////////////////////

#include "Res.hpp"
#include "ToolbarRes.hpp"

struct AutoDeleteFileW
{
    std::wstring m_file;
    AutoDeleteFileW(const std::wstring& file) : m_file(file)
    {
    }
    ~AutoDeleteFileW()
    {
        ::DeleteFileW(m_file.c_str());
    }
};

BOOL
Res_IsEntityType(const MIdOrString& type)
{
    MStringW name;
    if (type.m_id)
    {
        name = g_db.GetName(L"RESOURCE", type.m_id);
        if (name.empty())
            name = mstr_dec_word(type.m_id);
    }
    else
    {
        name = type.str();
    }

    auto table = g_db.GetTable(L"NON.ENTITY.RESOURCE.TYPE");
    for (auto& table_entry : table)
    {
        if (table_entry.name == name)
        {
            return FALSE;
        }
    }

    return TRUE;
}

MStringW EntryBase::get_name_label() const
{
    WORD id = m_name.m_id;
    if (!id)
        return m_name.m_str;        // string name resource name

    // get an IDTYPE_ value
    IDTYPE_ nIDTYPE_ = g_db.IDTypeFromResType(m_type);

    // RT_DLGINIT uses dialog name
    if (m_type == RT_DLGINIT)
        nIDTYPE_ = IDTYPE_DIALOG;

    // RT_TOOLBAR uses bitmap name
    if (m_type == RT_TOOLBAR)
        nIDTYPE_ = IDTYPE_BITMAP;

    // get the label from an IDTYPE_ value
    MStringW label = g_db.GetNameOfResID(nIDTYPE_, id);
    if (label.empty() || m_type == RT_STRING || m_type == RT_MESSAGETABLE)
    {
        return mstr_dec_word(id);   // returns numeric text
    }

    // got the label 
    if (!mchr_is_digit(label[0]))   // first character is not digit
    {
        // add a parenthesis pair and numeric text
        label += L" (";
        label += mstr_dec_word(id);
        label += L")";
    }
    return label;
}

BOOL EntryBase::is_editable(LPCWSTR pszVCBat) const
{
    if (!this)
        return FALSE;

    const MIdOrString& type = m_type;
    switch (m_et)
    {
    case ET_LANG:
        if (type == RT_ACCELERATOR || type == RT_DIALOG || type == RT_HTML ||
            type == RT_MANIFEST || type == RT_MENU || type == RT_VERSION ||
            type == RT_DLGINIT || type == RT_TOOLBAR ||
            type == TEXT("RISOHTEMPLATE"))
        {
            return TRUE;
        }
        if (type == RT_RCDATA && is_delphi_dfm())
        {
            return TRUE;
        }
        if (type == L"TYPELIB" && PathFileExistsW(pszVCBat))
            return TRUE;
        return FALSE;
    case ET_STRING:
        return TRUE;
    case ET_MESSAGE:
        return !g_settings.bUseMSMSGTABLE;
    default:
        return FALSE;
    }
}

std::string
dfm_text_from_binary(LPCWSTR pszDFMSC, const void *binary, size_t size,
                     INT codepage, BOOL bComments)
{
    // get the temporary file path
    WCHAR szPath4[MAX_PATH], szPath5[MAX_PATH];
    StringCbCopyW(szPath4, sizeof(szPath4), GetTempFileNameDx(L"R4"));
    StringCbCopyW(szPath5, sizeof(szPath5), szPath4);
    StringCbCatW(szPath5, sizeof(szPath5), L".txt");

    // create the temporary file and wait
    DWORD cbWritten;
    MFile r4(szPath4, TRUE);
    r4.WriteFile(binary, DWORD(size), &cbWritten);
    r4.FlushFileBuffers();
    r4.CloseHandle();

    AutoDeleteFileW ad4(szPath4);
    AutoDeleteFileW ad5(szPath5);

    // build the command line text
    MStringW strCmdLine;
    strCmdLine += L'\"';
    strCmdLine += pszDFMSC;
    strCmdLine += L"\" --b2t";
    if (bComments)
    {
        strCmdLine += L" --comments";
    }
    if (codepage != 0)
    {
        strCmdLine += L" --codepage ";
        strCmdLine += mstr_dec_word(codepage);
    }
    strCmdLine += L" \"";
    strCmdLine += szPath4;
    strCmdLine += L"\"";
    //MessageBoxW(NULL, strCmdLine.c_str(), NULL, 0);

    BOOL bSuccess = FALSE;

    // create an mcdx.exe process
    MProcessMaker pmaker;
    pmaker.SetShowWindow(SW_HIDE);
    pmaker.SetCreationFlags(CREATE_NEW_CONSOLE);

    if (pmaker.CreateProcessDx(NULL, strCmdLine.c_str()))
    {
        SetPriorityClass(pmaker.GetProcessHandle(), HIGH_PRIORITY_CLASS);
        pmaker.WaitForSingleObject();
        pmaker.CloseAll();

        bSuccess = PathFileExistsW(szPath5);
    }

    if (bSuccess)
    {
        MStringA text;
        MFile input(szPath5);
        if (input.ReadAll(text))
            return text;
    }

    return std::string();
}

EntryBase::data_type
dfm_binary_from_text(LPCWSTR pszDFMSC, const std::string& text,
                     INT codepage, BOOL no_unicode, INT& iLine)
{
    // get the temporary file path
    WCHAR szPath6[MAX_PATH], szPath7[MAX_PATH];
    StringCbCopyW(szPath6, sizeof(szPath6), GetTempFileNameDx(L"R6"));
    StringCbCopyW(szPath7, sizeof(szPath7), szPath6);
    StringCbCatW(szPath7, sizeof(szPath7), L".dfm");

    // create the temporary file and wait
    DWORD cbWritten;
    MFile r6(szPath6, TRUE);
    r6.WriteFile("\xEF\xBB\xBF", 3, &cbWritten);
    r6.WriteFile(text.c_str(), DWORD(text.size()), &cbWritten);
    r6.FlushFileBuffers();
    r6.CloseHandle();

    AutoDeleteFileW adf6(szPath6);
    AutoDeleteFileW adf7(szPath7);

    // build the command line text
    MStringW strCmdLine;
    strCmdLine += L'\"';
    strCmdLine += pszDFMSC;
    strCmdLine += L"\" --t2b";
    if (no_unicode)
    {
        strCmdLine += L" --no-unicode";
    }
    if (codepage != 0)
    {
        strCmdLine += L" --codepage ";
        strCmdLine += mstr_dec_word(codepage);
    }
    strCmdLine += L" \"";
    strCmdLine += szPath6;
    strCmdLine += L"\"";
    //MessageBoxW(NULL, strCmdLine.c_str(), NULL, 0);

    BOOL bSuccess = FALSE;

    // create an mcdx.exe process
    MProcessMaker pmaker;
    pmaker.SetShowWindow(SW_HIDE);
    pmaker.SetCreationFlags(CREATE_NEW_CONSOLE);

    MFile error;
    pmaker.PrepareForRedirect(NULL, &error, &error);

    if (pmaker.CreateProcessDx(NULL, strCmdLine.c_str()))
    {
        SetPriorityClass(pmaker.GetProcessHandle(), HIGH_PRIORITY_CLASS);
        pmaker.WaitForSingleObject();
        DWORD dwExitCode = pmaker.GetExitCode();
        pmaker.CloseAll();

        if (dwExitCode == 0 && PathFileExistsW(szPath7))
        {
            bSuccess = TRUE;
        }
        else
        {
            std::string strOutput;
            error.ReadAll(strOutput);
            size_t ich = strOutput.find("expected on line ");
            if (ich != strOutput.npos)
            {
                ich += 17; // "expected on line "
                iLine = INT(strtoul(&strOutput[ich], NULL, 10));
            }
        }
    }

    if (bSuccess)
    {
        MStringA text;
        MFile input(szPath7);
        if (input.ReadAll(text))
            return EntryBase::data_type(text.begin(), text.end());
    }

    return EntryBase::data_type();
}

std::string
tlb_text_from_binary(LPCWSTR pszOleBow, const void *binary, size_t size)
{
    // get the temporary file path
    WCHAR szPath4[MAX_PATH], szPath5[MAX_PATH];
    StringCbCopyW(szPath4, sizeof(szPath4), GetTempFileNameDx(L"R4"));
    StringCbCopyW(szPath5, sizeof(szPath5), szPath4);
    StringCbCatW(szPath5, sizeof(szPath5), L".idl");

    // create the temporary file and wait
    DWORD cbWritten;
    MFile r4(szPath4, TRUE);
    r4.WriteFile(binary, DWORD(size), &cbWritten);
    r4.FlushFileBuffers();
    r4.CloseHandle();

    AutoDeleteFileW ad4(szPath4);
    AutoDeleteFileW ad5(szPath5);

    // build the command line text
    MStringW strCmdLine;
    strCmdLine += L'\"';
    strCmdLine += pszOleBow;
    strCmdLine += L"\" --codepage 65001 --sort \"";
    strCmdLine += szPath4;
    strCmdLine += L"\" \"";
    strCmdLine += szPath5;
    strCmdLine += L"\"";
    //MessageBoxW(NULL, strCmdLine.c_str(), NULL, 0);

    BOOL bSuccess = FALSE;

    // create an OleBow.exe process
    MProcessMaker pmaker;
    pmaker.SetShowWindow(SW_HIDE);
    pmaker.SetCreationFlags(CREATE_NEW_CONSOLE);

    if (pmaker.CreateProcessDx(NULL, strCmdLine.c_str()))
    {
        SetPriorityClass(pmaker.GetProcessHandle(), HIGH_PRIORITY_CLASS);
        pmaker.WaitForSingleObject(16 * 1000);
        pmaker.CloseAll();

        bSuccess = PathFileExistsW(szPath5);
    }

    if (bSuccess)
    {
        MStringA text;
        MFile input(szPath5);
        if (input.ReadAll(text))
            return text;
    }

    return std::string();
}

EntryBase::data_type
tlb_binary_from_text(LPCWSTR pszMidlWrap, LPCWSTR pszVCBat, MStringA& strOutput,
                     const std::string& text, bool is_64bit)
{
    EntryBase::data_type ret;

    // get the temporary file path
    WCHAR szPath4[MAX_PATH], szPath5[MAX_PATH];
    StringCbCopyW(szPath4, sizeof(szPath4), GetTempFileNameDx(L"R4"));
    StringCbCopyW(szPath5, sizeof(szPath5), szPath4);
    StringCbCatW(szPath5, sizeof(szPath5), L".tlb");

    // create the temporary file and wait
    DWORD cbWritten;
    MFile r4(szPath4, TRUE);
    r4.WriteFile(text.c_str(), DWORD(text.size()), &cbWritten);
    r4.FlushFileBuffers();
    r4.CloseHandle();

    AutoDeleteFileW ad4(szPath4);
    AutoDeleteFileW ad5(szPath5);

    // build the command line text
    MStringW strCmdLine;
    strCmdLine += L"cmd /C call \"";
    strCmdLine += pszMidlWrap;
    strCmdLine += L"\" \"";
    strCmdLine += pszVCBat;
    if (is_64bit)
        strCmdLine += L"\" amd64 \"";
    else
        strCmdLine += L"\" x86 \"";
    strCmdLine += szPath4;
    strCmdLine += L"\" \"";
    strCmdLine += szPath5;
    strCmdLine += L"\"";
    //MessageBoxW(NULL, strCmdLine.c_str(), NULL, 0);

    BOOL bSuccess = FALSE;

    // create an midlwrap.bat process
    MProcessMaker pmaker;
    pmaker.SetShowWindow(SW_HIDE);
    //pmaker.SetCreationFlags(CREATE_NEW_CONSOLE);

    MFile error;
    pmaker.PrepareForRedirect(NULL, &error, &error);

    if (pmaker.CreateProcessDx(NULL, strCmdLine.c_str()))
    {
        SetPriorityClass(pmaker.GetProcessHandle(), HIGH_PRIORITY_CLASS);
        pmaker.WaitForSingleObject(16 * 1000);
        pmaker.CloseAll();

        error.ReadAll(strOutput);

        bSuccess = PathFileExistsW(szPath5);
    }

    if (bSuccess)
    {
        MStringA text;
        MFile input(szPath5);
        if (input.ReadAll(text))
        {
            ret.assign(text.begin(), text.end());
        }
    }

    return ret;
}

bool EntrySet::intersect(const EntrySet& another) const
{
    if (size() == 0 && another.size() == 0)
        return false;

    for (auto item1 : *this)
    {
        if (item1->m_et != ET_LANG)
            continue;

        for (auto item2 : another)
        {
            if (item2->m_et != ET_LANG)
                continue;

            if (*item1 == *item2 && item1->valid() && item2->valid())
                return true;    // found
        }
    }

    return false;   // not found
}

EntryBase *
EntrySet::add_lang_entry(const MIdOrString& type, const MIdOrString& name, 
                         WORD lang, const EntryBase::data_type& data)
{
    if (m_hwndTV)   // it has the treeview handle
    {
        // add the related entries
        if (type == RT_STRING)
        {
            add_string_entry(lang);
        }
        if (type == RT_MESSAGETABLE)
        {
            add_message_entry(lang);
        }
    }

    // find the entry
    auto entry = find(ET_LANG, type, name, lang, true);
    if (!entry)
    {
        // if not found, then create it
        entry = Res_NewLangEntry(type, name, lang);
    }

    // store the data
    entry->m_data = data;

    // fixup RT_TOOLBAR
    if (entry->m_type == RT_TOOLBAR)
    {
        ToolbarRes toolbar_res;
        MByteStreamEx stream(entry->m_data);
        toolbar_res.LoadFromStream(stream);
        entry->m_data = toolbar_res.data();
    }

    // finish
    return on_insert_entry(entry);
}

void EntrySet::delete_entry(EntryBase *entry)
{
    // delete the related entries
    switch (entry->m_et)
    {
    case ET_LANG:
        if (entry->m_type == RT_GROUP_CURSOR)
        {
            on_delete_group_cursor(entry);
        }
        if (entry->m_type == RT_GROUP_ICON)
        {
            on_delete_group_icon(entry);
        }
        if (entry->m_type == RT_DIALOG)
        {
            on_delete_dialog(entry);
        }
        break;

    case ET_STRING:
        on_delete_string(entry);
        break;

    case ET_MESSAGE:
        on_delete_message(entry);
        break;

    default:
        break;
    }

    // mark it as invalid. real deletion is done in delete_invalid
    entry->mark_invalid();

    // delete the parent if necessary
    do
    {
        EntryBase *parent = get_parent(entry);
        if (!parent)
            break;  // no parent

        if (get_child(parent))
            break;  // has child

        delete_entry(parent);   // delete the parent
    } while (0);
}

void EntrySet::delete_invalid()
{
    // search the invalid
    super_type found;
    search_invalid(found);

    if (found.empty())
        return;

    // for all the invalid entries
    for (auto entry : found)
    {
        if (super()->find(entry) == super()->end())
            continue;   // not owned. skip it

        if (m_hwndTV && entry->m_hItem && entry == get_entry(entry->m_hItem))
        {
            // delete from treeview
            TreeView_DeleteItem(m_hwndTV, entry->m_hItem);
        }

        // real delete
        erase(entry);
        delete entry;
    }
}

UINT EntrySet::get_last_id(const MIdOrString& type, WORD lang) const
{
    WORD wLastID = 0;
    for (auto entry : *this)
    {
        // invalid?
        if (!entry->valid())
            continue;

        // not matched?
        if (entry->m_type != type || !entry->m_name.is_int() || entry->m_name.is_zero())
            continue;

        // not matched language?
        if (entry->m_lang != lang)
            continue;

        // update wLastID if necessary
        if (wLastID < entry->m_name.m_id)
            wLastID = entry->m_name.m_id;
    }
    return wLastID;
}

BOOL EntrySet::update_exe(LPCWSTR ExeFile) const
{
    // begin the update
    HANDLE hUpdate = ::BeginUpdateResourceW(ExeFile, TRUE);
    if (hUpdate == NULL)
    {
        return FALSE;   // failure
    }

    // for all the language entries
    for (auto entry : *this)
    {
        if (entry->m_et != ET_LANG)
            continue;

        // get the pointer and size
        void *pv = NULL;
        DWORD size = 0;
        if (!(*entry).empty())
        {
            pv = const_cast<void *>((*entry).ptr());
            size = (*entry).size();
        }

        // skip the empty entries
        if (!pv || !size)
            continue;

        // do update
        if (!::UpdateResourceW(hUpdate, (*entry).m_type.ptr(), (*entry).m_name.ptr(),
                               (*entry).m_lang, pv, size))
        {
            assert(0);
            ::EndUpdateResourceW(hUpdate, TRUE);    // discard
            return FALSE;   // failure
        }
    }

    // finish
    return ::EndUpdateResourceW(hUpdate, FALSE);
}

void EntrySet::do_bitmap(MTitleToBitmap& title_to_bitmap, DialogItem& item, WORD lang)
{
    MIdOrString type = RT_BITMAP;

    // find the entry
    auto entry = find(ET_LANG, type, item.m_title, lang);
    if (!entry)
    {
        entry = find(ET_LANG, type, item.m_title, BAD_LANG);
        if (!entry)
            return;
    }

    // create the bitmap object
    HBITMAP hbm = PackedDIB_CreateBitmapFromMemory(&(*entry)[0], (*entry).size());
    if (hbm)
    {
        if (!item.m_title.empty())  // title is not empty
        {
            // delete the previous
            if (title_to_bitmap[item.m_title])
                DeleteObject(title_to_bitmap[item.m_title]);

            // update title_to_bitmap
            title_to_bitmap[item.m_title] = hbm;
        }
    }
}

void EntrySet::do_icon(MTitleToIcon& title_to_icon, DialogItem& item, WORD lang)
{
    MIdOrString type = RT_GROUP_ICON;

    // find the entry
    auto entry = find(ET_LANG, type, item.m_title, lang);
    if (!entry)
    {
        entry = find(ET_LANG, type, item.m_title, BAD_LANG);
        if (!entry)
            return;
    }

    // too small?
    if (entry->size() < sizeof(ICONDIR) + sizeof(GRPICONDIRENTRY))
        return;

    // get the entries information
    ICONDIR& dir = (ICONDIR&)(*entry)[0];
    GRPICONDIRENTRY *pGroupIcon = (GRPICONDIRENTRY *)&(*entry)[sizeof(ICONDIR)];

    // get the largest icon image
    int cx = 0, cy = 0, bits = 0, n = 0;
    for (int m = 0; m < dir.idCount; ++m)
    {
        if (cx < pGroupIcon[m].bWidth ||
            cy < pGroupIcon[m].bHeight ||
            bits < pGroupIcon[m].wBitCount)
        {
            cx = pGroupIcon[m].bWidth;
            cy = pGroupIcon[m].bHeight;
            bits = pGroupIcon[m].wBitCount;
            n = m;
        }
    }

    // find the entry of the largest icon
    type = RT_ICON;
    entry = find(ET_LANG, type, pGroupIcon[n].nID, lang);
    if (!entry)
    {
        entry = find(ET_LANG, type, pGroupIcon[n].nID, BAD_LANG);
        if (!entry)
            return;
    }

    // create an icon object
    HICON hIcon = CreateIconFromResource((PBYTE)&(*entry)[0], (*entry).size(), TRUE, 0x00030000);
    if (hIcon)
    {
        if (!item.m_title.empty())  // the title was not empty
        {
            // delete the previous
            if (title_to_icon[item.m_title])
                DestroyIcon(title_to_icon[item.m_title]);

            // update title_to_icon
            title_to_icon[item.m_title] = hIcon;
        }
    }
}

bool EntrySet::extract_cursor(const EntryBase& c_entry, const wchar_t *file_name) const
{
    // copy the header
    LOCALHEADER local;
    if (c_entry.size() < sizeof(local))
    {
        assert(0);
        return false;   // too small
    }
    memcpy(&local, &c_entry[0], sizeof(local));

    // get the remainder pointer and size
    LPBYTE pb = LPBYTE(&c_entry[0]) + sizeof(local);
    DWORD cb = c_entry.size() - sizeof(local);

    // get the BITMAP info
    BITMAP bm;
    if (!PackedDIB_GetInfo(pb, cb, bm))
    {
        assert(0);
        return false;   // unable to get
    }

    // store data to the structures
    ICONDIR dir = { 0, RES_CURSOR, 1 };
    ICONDIRENTRY entry;
    entry.bWidth = (BYTE)bm.bmWidth;
    entry.bHeight = (BYTE)(bm.bmHeight / 2);
    entry.bColorCount = 0;
    entry.bReserved = 0;
    entry.xHotSpot = local.xHotSpot;
    entry.yHotSpot = local.yHotSpot;
    entry.dwBytesInRes = c_entry.size() - sizeof(local);
    entry.dwImageOffset = sizeof(dir) + sizeof(ICONDIRENTRY);

    // write them to the stream
    MByteStreamEx stream;
    if (!stream.WriteRaw(dir) ||
        !stream.WriteData(&entry, sizeof(entry)) ||
        !stream.WriteData(pb, cb))
    {
        assert(0);
        return false;
    }

    // save the stream to a file
    return stream.SaveToFile(file_name);
}

bool EntrySet::extract_group_cursor(const EntryBase& group, const wchar_t *file_name) const
{
    ICONDIR dir;
    if (group.m_type != RT_GROUP_CURSOR || group.size() < sizeof(dir))
    {
        assert(0);
        return false;   // invalid
    }

    // group --> dir
    memcpy(&dir, &group[0], sizeof(dir));
    if (dir.idReserved != 0 || dir.idType != RES_CURSOR || dir.idCount == 0)
    {
        assert(0);
        return false;   // invalid
    }

    // check the size
    DWORD SizeOfCursorEntries = sizeof(GRPCURSORDIRENTRY) * dir.idCount;
    if (group.size() < sizeof(dir) + SizeOfCursorEntries)
    {
        assert(0);
        return false;   // invalid
    }

    // group --> GroupEntries
    std::vector<GRPCURSORDIRENTRY> GroupEntries(dir.idCount);
    memcpy(&GroupEntries[0], &group[sizeof(dir)], 
           SizeOfCursorEntries);

    // set the current offset
    DWORD offset = sizeof(dir) + sizeof(ICONDIRENTRY) * dir.idCount;

    // store the entries to DirEntries
    std::vector<ICONDIRENTRY> DirEntries(dir.idCount);
    for (UINT i = 0; i < dir.idCount; ++i)
    {
        // find the RT_CURSOR
        auto entry = find(ET_LANG, RT_CURSOR, GroupEntries[i].nID, group.m_lang);
        if (!entry)
        {
            entry = find(ET_LANG, RT_CURSOR, GroupEntries[i].nID, BAD_LANG);
            if (!entry)
                continue;   // not found
        }

        // get the LOCALHEADER header
        LOCALHEADER local;
        if (entry->size() >= sizeof(local))
            memcpy(&local, &(*entry)[0], sizeof(local));

        // GroupEntries[i] --> DirEntries[i]
        DirEntries[i].bWidth = (BYTE)GroupEntries[i].wWidth;
        DirEntries[i].bHeight = (BYTE)GroupEntries[i].wHeight;
        if (GroupEntries[i].wBitCount >= 8)
            DirEntries[i].bColorCount = 0;
        else
            DirEntries[i].bColorCount = 1 << GroupEntries[i].wBitCount;
        DirEntries[i].bReserved = 0;
        DirEntries[i].xHotSpot = local.xHotSpot;
        DirEntries[i].yHotSpot = local.yHotSpot;
        DirEntries[i].dwBytesInRes = (*entry).size() - sizeof(local);
        DirEntries[i].dwImageOffset = offset;

        // move the offset
        offset += DirEntries[i].dwBytesInRes;
    }

    // write the header to the stream
    MByteStreamEx stream;
    if (!stream.WriteRaw(dir))
    {
        assert(0);
        return false;   // unable to write
    }

    // write the dir entries to the stream
    DWORD SizeOfDirEntries = sizeof(ICONDIRENTRY) * dir.idCount;
    if (!stream.WriteData(&DirEntries[0], SizeOfDirEntries))
    {
        assert(0);
        return false;   // unable to write
    }

    // write the images to the stream
    for (UINT i = 0; i < dir.idCount; ++i)
    {
        // find RT_CURSOR
        auto entry = find(ET_LANG, RT_CURSOR, GroupEntries[i].nID, group.m_lang);
        if (!entry)
        {
            entry = find(ET_LANG, RT_CURSOR, GroupEntries[i].nID, BAD_LANG);
            if (!entry)
                continue;
        }

        DWORD cbLocal = sizeof(LOCALHEADER);

        // get the current pointer and size
        LPBYTE pb = LPBYTE(&(*entry)[0]) + cbLocal;
        DWORD dwSize = (*entry).size() - cbLocal;
        if (!stream.WriteData(pb, dwSize))
        {
            assert(0);
            return FALSE;   // unable to write
        }
    }

    // save the stream to a file
    return stream.SaveToFile(file_name);
}

BOOL EntrySet::extract_icon(const EntryBase& i_entry, const wchar_t *file_name) const
{
    // get the BITMAP info
    BITMAP bm;
    if (!PackedDIB_GetInfo(&i_entry[0], i_entry.size(), bm))
    {
        MBitmapDx bitmap;
        bitmap.CreateFromMemory(&i_entry[0], i_entry.size());

        LONG cx, cy;
        HBITMAP hbm = bitmap.GetHBITMAP32(cx, cy);
        GetObject(hbm, sizeof(bm), &bm);
        DeleteObject(hbm);
    }

    // store
    ICONDIR dir = { 0, RES_ICON, 1 };
    ICONDIRENTRY entry;
    entry.bWidth = (BYTE)bm.bmWidth;
    entry.bHeight = (BYTE)bm.bmHeight;
    entry.bColorCount = 0;
    entry.bReserved = 0;
    entry.wPlanes = 1;
    entry.wBitCount = bm.bmBitsPixel;
    entry.dwBytesInRes = i_entry.size();
    entry.dwImageOffset = sizeof(dir) + sizeof(ICONDIRENTRY);

    // write the data to the straem
    MByteStreamEx stream;
    if (!stream.WriteRaw(dir) ||
        !stream.WriteData(&entry, sizeof(entry)) ||
        !stream.WriteData(&i_entry[0], i_entry.size()))
    {
        assert(0);
        return false;
    }

    // save the stream to a file
    return stream.SaveToFile(file_name);
}

bool EntrySet::extract_group_icon(const EntryBase& group, const wchar_t *file_name) const
{
    ICONDIR dir;

    // check the format
    if (group.m_type != RT_GROUP_ICON || group.size() < sizeof(dir))
    {
        assert(0);
        return false;   // invalid
    }

    // group --> dir
    memcpy(&dir, &group[0], sizeof(dir));

    // check the dir
    if (dir.idReserved != 0 || dir.idType != RES_ICON || dir.idCount == 0)
    {
        assert(0);
        return false;   // invalid
    }

    // check the size
    DWORD SizeOfIconEntries = sizeof(GRPICONDIRENTRY) * dir.idCount;
    if (group.size() < sizeof(dir) + SizeOfIconEntries)
    {
        assert(0);
        return false;   // invalid
    }

    // group --> GroupEntries
    std::vector<GRPICONDIRENTRY> GroupEntries(dir.idCount);
    memcpy(&GroupEntries[0], &group[sizeof(dir)], SizeOfIconEntries);

    // set the current offset
    DWORD offset = sizeof(dir) + sizeof(ICONDIRENTRY) * dir.idCount;

    std::vector<ICONDIRENTRY> DirEntries(dir.idCount);
    for (UINT i = 0; i < dir.idCount; ++i)
    {
        // find the RT_ICON entry
        auto entry = find(ET_LANG, RT_ICON, GroupEntries[i].nID, group.m_lang);
        if (!entry)
        {
            entry = find(ET_LANG, RT_ICON, GroupEntries[i].nID, BAD_LANG);
            if (!entry)
                continue;
        }

        // GroupEntries[i] --> DirEntries[i]
        DirEntries[i].bWidth = GroupEntries[i].bWidth;
        DirEntries[i].bHeight = GroupEntries[i].bHeight;
        if (GroupEntries[i].wBitCount >= 8)
            DirEntries[i].bColorCount = 0;
        else
            DirEntries[i].bColorCount = GroupEntries[i].bColorCount;
        DirEntries[i].bReserved = 0;
        DirEntries[i].wPlanes = 1;
        DirEntries[i].wBitCount = GroupEntries[i].wBitCount;
        DirEntries[i].dwBytesInRes = (*entry).size();
        DirEntries[i].dwImageOffset = offset;

        // move the offset
        offset += DirEntries[i].dwBytesInRes;
    }

    // write the header
    MByteStreamEx stream;
    if (!stream.WriteRaw(dir))
    {
        assert(0);
        return false;   // unable to write
    }

    // write the dir entries
    DWORD SizeOfDirEntries = sizeof(ICONDIRENTRY) * dir.idCount;
    if (!stream.WriteData(&DirEntries[0], SizeOfDirEntries))
    {
        assert(0);
        return false;   // unable to write
    }

    // write the images
    for (UINT i = 0; i < dir.idCount; ++i)
    {
        // find the RT_ICON entry
        auto entry = find(ET_LANG, RT_ICON, GroupEntries[i].nID, group.m_lang);
        if (!entry)
        {
            entry = find(ET_LANG, RT_ICON, GroupEntries[i].nID, BAD_LANG);
            if (!entry)
                continue;
        }

        // write it
        DWORD dwSize = (*entry).size();
        if (!stream.WriteData(&(*entry)[0], dwSize))
        {
            assert(0);
            return false;   // unable to write
        }
    }

    // save the stream to a file
    return stream.SaveToFile(file_name);
}

EntryBase *EntrySet::add_bitmap(const MIdOrString& name, WORD lang, const MStringW& file)
{
    // load the data from an *.bmp file
    MByteStreamEx stream;
    if (!stream.LoadFromFile(file.c_str()) || stream.size() <= 4)
        return NULL;

    // is it a JPEG, GIF or PNG image?
    if (stream.size() >= 4 &&
        (memcmp(&stream[0], "\xFF\xD8\xFF", 3) == 0 ||    // JPEG
         memcmp(&stream[0], "GIF", 3) == 0 ||             // GIF
         memcmp(&stream[0], "\x89\x50\x4E\x47", 4) == 0)) // PNG
    {
        // create a bitmap object from memory
        MBitmapDx bitmap;
        if (!bitmap.CreateFromMemory(&stream[0], (DWORD)stream.size()))
            return NULL;

        LONG cx, cy;
        HBITMAP hbm = bitmap.GetHBITMAP32(cx, cy);

        // create a packed DIB from bitmap handle
        std::vector<BYTE> PackedDIB;
        if (!PackedDIB_CreateFromHandle(PackedDIB, hbm))
        {
            DeleteObject(hbm);
            return NULL;
        }
        DeleteObject(hbm);

        // add the entry
        return add_lang_entry(RT_BITMAP, name, lang, PackedDIB);
    }

    // check the size
    size_t head_size = sizeof(BITMAPFILEHEADER);
    if (stream.size() < head_size)
        return NULL;    // invalid

    // add the entry
    size_t i0 = head_size, i1 = stream.size();
    EntryBase::data_type HeadLess(&stream[i0], &stream[i0] + (i1 - i0));
    return add_lang_entry(RT_BITMAP, name, lang, HeadLess);
}

EntryBase *
EntrySet::add_group_icon(const MIdOrString& name, WORD lang, 
                         const MStringW& file_name)
{
    // load the data from an *.ico file
    IconFile icon;
    if (!icon.LoadFromFile(file_name.c_str()) || icon.type() != RES_ICON)
        return NULL;

    // get the next icon ID
    UINT LastIconID = get_last_id(RT_ICON, lang);
    UINT NextIconID = LastIconID + 1;

    // add the icon images (RT_ICON)
    int i, nCount = icon.GetImageCount();
    for (i = 0; i < nCount; ++i)
    {
        add_lang_entry(RT_ICON, WORD(NextIconID + i), lang, icon.GetImage(i));
    }

    // add the entry
    IconFile::DataType data(icon.GetIconGroup(NextIconID));
    return add_lang_entry(RT_GROUP_ICON, name, lang, data);
}

EntryBase *
EntrySet::add_group_cursor(const MIdOrString& name, WORD lang, 
                           const MStringW& file_name)
{
    // load the data from an *.cur file
    CursorFile cur;
    if (!cur.LoadFromFile(file_name.c_str()) || cur.type() != RES_CURSOR)
        return NULL;

    // get the next cursor ID
    UINT LastCursorID = get_last_id(RT_CURSOR, lang);
    UINT NextCursorID = LastCursorID + 1;

    // add the cursor images (RT_CURSOR)
    int i, nCount = cur.GetImageCount();
    for (i = 0; i < nCount; ++i)
    {
        add_lang_entry(RT_CURSOR, WORD(NextCursorID + i), lang, cur.GetImage(i));
    }

    // add the entry
    CursorFile::DataType data(cur.GetCursorGroup(NextCursorID));
    return add_lang_entry(RT_GROUP_CURSOR, name, lang, data);
}

HTREEITEM EntrySet::get_insert_parent(EntryBase *entry)
{
    if (m_hwndTV == NULL)
        return NULL;    // no treeview handle

    if (entry->m_et == ET_TYPE)
        return TVI_ROOT;    // the root handle

    auto new_entry = add_type_entry(entry->m_type, false);
    if (!new_entry)
        return NULL;    // unable to add

    switch (entry->m_et)
    {
    case ET_NAME: case ET_STRING: case ET_MESSAGE:
        return new_entry->m_hItem;  // success

    case ET_LANG:
        break;

    default:
        return NULL;
    }

    // add the name entry
    new_entry = add_name_entry(entry->m_type, entry->m_name);
    if (!new_entry)
        return NULL;    // unable to add

    return new_entry->m_hItem;  // success
}

HTREEITEM EntrySet::get_insert_position(EntryBase *entry)
{
    if (m_hwndTV == NULL)
        return NULL;    // no treeview handle

    // get the entries to determine the position
    self_type found;
    switch (entry->m_et)
    {
    case ET_TYPE:
        search(found, ET_TYPE);
        break;

    case ET_NAME:
        search(found, ET_NAME, entry->m_type);
        if (entry->m_type == RT_STRING)
            search(found, ET_STRING, entry->m_type);
        if (entry->m_type == RT_MESSAGETABLE)
            search(found, ET_MESSAGE, entry->m_type);
        break;

    case ET_STRING:
        search(found, ET_STRING, entry->m_type);
        search(found, ET_NAME, entry->m_type);
        break;

    case ET_MESSAGE:
        search(found, ET_MESSAGE, entry->m_type);
        search(found, ET_NAME, entry->m_type);
        break;

    case ET_LANG:
        search(found, ET_LANG, entry->m_type, entry->m_name);
        break;

    default:
        return NULL;
    }

    // determine the target
    EntryBase *target = NULL;
    for (auto e : found)
    {
        if (*e < *entry)
        {
            if (!target)    // there is no target yet
            {
                target = e;     // set the target
            }
            else if (*target < *e)  // check the position
            {
                target = e;     // set the new target
            }
        }
    }

    if (target)
        return target->m_hItem;     // returns the target

    return TVI_FIRST;   // insert as a first
}

EntryBase *EntrySet::get_parent(EntryBase *entry)
{
    if (!entry)
        return NULL;    // no parent

    EntryBase *parent;
    switch (entry->m_et)
    {
    case ET_NAME:
    case ET_STRING:
    case ET_MESSAGE:
        // parent is a type entry
        parent = find(ET_TYPE, entry->m_type);
        break;

    case ET_LANG:
        // parent is a name entry
        parent = find(ET_NAME, entry->m_type, entry->m_name);
        break;

    default:
        parent = NULL;  // no parent
        break;
    }

    return parent;
}

bool EntrySet::is_childless_parent(EntryBase *entry) const
{
    assert(entry);
    switch (entry->m_et)
    {
    case ET_TYPE:
        return !find(ET_NAME, entry->m_type);

    case ET_NAME:
        return !find(ET_LANG, entry->m_type, entry->m_name);

    case ET_STRING:
    case ET_MESSAGE:
    case ET_LANG:
    default:
        return false;   // not parent
    }
}

MStringW EntrySet::get_label(const EntryBase *entry)
{
    MStringW strText;

    // get the preferred label by the entry type
    switch (entry->m_et)
    {
    case ET_TYPE:
        strText = entry->get_type_label();
        break;

    case ET_NAME:
        strText = entry->get_name_label();
        break;

    case ET_LANG:
    case ET_STRING:
    case ET_MESSAGE:
        strText = entry->get_lang_label();
        break;

    default:
        assert(0);
        break;
    }

    return strText;
}

EntryBase *EntrySet::on_insert_entry(EntryBase *entry)
{
    DebugPrintDx(L"on_insert_entry: %p, %s, %s, %u, %s\n",
        entry, entry->m_type.c_str(), entry->m_name.c_str(),
        entry->m_lang, entry->m_strLabel.c_str());

    if (m_hwndTV == NULL)   // no treeview handle
    {
        entry->m_valid = true;
        insert(entry);
        return NULL;
    }

    // get/insert the insertion parent
    HTREEITEM hParent = get_insert_parent(entry);

    // get the insertion position
    HTREEITEM hPosition = get_insert_position(entry);

    // ok, insert it
    return on_insert_after(hParent, entry, hPosition);
}

EntryBase *
EntrySet::on_insert_after(HTREEITEM hParent, EntryBase *entry, HTREEITEM hInsertAfter)
{
    assert(entry);

    // make it valid
    entry->m_valid = true;

    if (m_hwndTV == NULL)
        return entry;   // no treeview handle

    if (entry->m_hItem && entry == get_entry(entry->m_hItem))
    {
        // it already has its item handle
        insert(entry);
        return entry;
    }

    // initialize the TV_INSERTSTRUCT structure
    TV_INSERTSTRUCTW insert_struct;
    ZeroMemory(&insert_struct, sizeof(insert_struct));

    insert_struct.hParent = hParent;
    insert_struct.hInsertAfter = hInsertAfter;
    insert_struct.item.mask = TVIF_TEXT | TVIF_STATE | TVIF_PARAM |
                              TVIF_IMAGE | TVIF_SELECTEDIMAGE;
    insert_struct.item.state = 0;
    insert_struct.item.stateMask = 0;

    entry->m_strLabel = get_label(entry);
    insert_struct.item.pszText = &entry->m_strLabel[0];

    insert_struct.item.lParam = (LPARAM)entry;
    if (entry->m_et == ET_TYPE || entry->m_et == ET_NAME)
    {
        insert_struct.item.iImage = 1;
        insert_struct.item.iSelectedImage = 1;
    }
    else
    {
        insert_struct.item.iImage = 0;
        insert_struct.item.iSelectedImage = 0;
    }

    // insert it to the treeview
    if (auto hItem = TreeView_InsertItem(m_hwndTV, &insert_struct))
    {
        entry->m_hItem = hItem;     // set the item handle

        insert(entry);  // insert the entry pointer to this instance

        return entry;
    }

    return NULL;    // failure
}

bool EntrySet::on_delete_group_icon(EntryBase *entry)
{
    // validate the entry
    if (entry->m_et != ET_LANG || entry->m_type != RT_GROUP_ICON)
        return false;   // invalid

    // store the data to the stream
    MByteStreamEx bs(entry->m_data);

    // read the header from the stream
    ICONDIR dir;
    if (!bs.ReadRaw(dir))
        return false;   // unable to read

    // read the dir entries from the stream
    DWORD size = sizeof(GRPICONDIRENTRY) * dir.idCount;
    if (size == 0)
        return false;  // invalid
    std::vector<GRPICONDIRENTRY> DirEntries(dir.idCount);
    if (!bs.ReadData(&DirEntries[0], size))
        return false;   // unable to read

    // delete the related RT_ICON entries
    DWORD i, nCount = dir.idCount;
    for (i = 0; i < nCount; ++i)
    {
        search_and_delete(ET_LANG, RT_ICON, DirEntries[i].nID, (*entry).m_lang);
    }

    return true;    // success
}

bool EntrySet::on_delete_group_cursor(EntryBase *entry)
{
    // validate the entry
    if (entry->m_et != ET_LANG || entry->m_type != RT_GROUP_CURSOR)
        return false;   // invalid

    // store the data to the stream
    MByteStreamEx bs(entry->m_data);

    // read the header from the stream
    ICONDIR dir;
    if (!bs.ReadRaw(dir))
        return false;   // unable to read

    // read the dir entries from the stream
    DWORD size = sizeof(GRPCURSORDIRENTRY) * dir.idCount;
    if (size == 0)
        return false;   // invalid
    std::vector<GRPCURSORDIRENTRY> DirEntries(dir.idCount);
    if (!bs.ReadData(&DirEntries[0], size))
        return false;   // unable to read

    // delete the related RT_CURSOR entries
    DWORD i, nCount = dir.idCount;
    for (i = 0; i < nCount; ++i)
    {
        search_and_delete(ET_LANG, RT_CURSOR, DirEntries[i].nID, (*entry).m_lang);
    }

    return true;    // success
}

EntryBase *
EntrySet::add_res_entry(HMODULE hMod, LPCWSTR type, LPCWSTR name, WORD lang)
{
    // find the resource in hMod
    HRSRC hResInfo = FindResourceExW(hMod, type, name, lang);
    if (!hResInfo)
        return NULL;

    // get the size and the pointer
    DWORD dwSize = SizeofResource(hMod, hResInfo);
    HGLOBAL hGlobal = LoadResource(hMod, hResInfo);
    LPVOID pv = LockResource(hGlobal);
    if (pv && dwSize)
    {
        // got it. add a language entry
        EntryBase::data_type data((LPBYTE)(pv), (LPBYTE)(pv) + dwSize);
        return add_lang_entry(type, name, lang, data);
    }

    return NULL;    // unable to get
}

EntryBase *EntrySet::get_child(EntryBase *parent) const
{
    if (!parent)
        return NULL;    // no parent, no child

    // get child
    EntryBase *child;
    switch (parent->m_et)
    {
    case ET_TYPE:
        child = find(ET_NAME, parent->m_type);
        break;

    case ET_NAME:
        child = find(ET_LANG, parent->m_type, parent->m_name);
        break;

    default:
        child = NULL;   // no child
        break;
    }

    return child;
}

BOOL EntrySet::copy_group_icon(EntryBase *entry, const MIdOrString& new_name, WORD new_lang)
{
    assert(entry->m_et == ET_LANG);
    assert(entry->m_type == RT_GROUP_ICON);

    // check the size
    ICONDIR dir;
    if (entry->size() < sizeof(dir))
    {
        assert(0);
        return FALSE;   // invalid
    }

    // entry --> dir
    memcpy(&dir, &(*entry)[0], sizeof(dir));

    // check the format
    if (dir.idReserved != 0 || dir.idType != RES_ICON || dir.idCount == 0)
    {
        assert(0);
        return FALSE;   // invalid
    }

    // check the size
    if (entry->size() < sizeof(dir) + dir.idCount * sizeof(GRPICONDIRENTRY))
    {
        assert(0);
        return FALSE;   // invalid
    }

    // get the pointers of old and new entries
    auto data = entry->m_data;
    auto old_entries = (GRPCURSORDIRENTRY *)&(*entry)[sizeof(dir)];
    auto new_entries = (GRPCURSORDIRENTRY *)&data[sizeof(dir)];

    for (UINT i = 0; i < dir.idCount; ++i)
    {
        // find the RT_ICON entry
        auto e = find(ET_LANG, RT_ICON, old_entries[i].nID, entry->m_lang);
        if (!e)
        {
            e = find(ET_LANG, RT_ICON, old_entries[i].nID, BAD_LANG);
            if (!e)
                return FALSE;
        }

        // get the next ID
        UINT nLastID = get_last_id(RT_ICON, new_lang);
        UINT nNextID = nLastID + 1;

        // add a RT_ICON entry
        add_lang_entry(RT_ICON, WORD(nNextID), new_lang, e->m_data);

        // update the ID in new_entries
        new_entries[i].nID = (WORD)nNextID;
    }

    // add a RT_GROUP_ICON entry
    add_lang_entry(RT_GROUP_ICON, new_name, new_lang, data);
    return TRUE;
}

BOOL EntrySet::copy_group_cursor(EntryBase *entry, const MIdOrString& new_name, WORD new_lang)
{
    assert(entry->m_et == ET_LANG);
    assert(entry->m_type == RT_GROUP_CURSOR);

    // check the size
    ICONDIR dir;
    if (entry->size() < sizeof(dir))
    {
        assert(0);
        return FALSE;   // invalid
    }

    // entry --> dir
    memcpy(&dir, &(*entry)[0], sizeof(dir));

    // check the format
    if (dir.idReserved != 0 || dir.idType != RES_CURSOR || dir.idCount == 0)
    {
        assert(0);
        return FALSE;   // invalid
    }

    // check the size
    if (entry->size() < sizeof(dir) + dir.idCount * sizeof(GRPCURSORDIRENTRY))
    {
        assert(0);
        return FALSE;   // invalid
    }

    // get the pointers of old and new entries
    auto data = entry->m_data;
    auto old_entries = (GRPCURSORDIRENTRY *)&(*entry)[sizeof(dir)];
    auto new_entries = (GRPCURSORDIRENTRY *)&data[sizeof(dir)];

    for (UINT i = 0; i < dir.idCount; ++i)
    {
        // find the RT_CURSOR entry
        auto e = find(ET_LANG, RT_CURSOR, old_entries[i].nID, entry->m_lang);
        if (!e)
        {
            e = find(ET_LANG, RT_CURSOR, old_entries[i].nID, BAD_LANG);
            if (!e)
                return FALSE;
        }

        // get the next ID
        UINT nLastID = get_last_id(RT_CURSOR, new_lang);
        UINT nNextID = nLastID + 1;

        add_lang_entry(RT_CURSOR, WORD(nNextID), new_lang, e->m_data);

        // update the ID in new_entries
        new_entries[i].nID = (WORD)nNextID;
    }

    // add a RT_GROUP_CURSOR entry
    add_lang_entry(RT_GROUP_CURSOR, new_name, new_lang, data);
    return TRUE;
}

BOOL EntrySet::extract_res(LPCWSTR pszFileName, const EntryBase *entry) const
{
    EntrySet found;

    switch (entry->m_et)
    {
    case ET_ANY:
        search(found, ET_LANG);
        break;

    case ET_TYPE:
        search(found, ET_LANG, entry->m_type);
        break;

    case ET_STRING:
    case ET_MESSAGE:
        search(found, ET_LANG, entry->m_type, WORD(0), entry->m_lang);
        break;

    case ET_NAME:
        search(found, ET_LANG, entry->m_type, entry->m_name);
        break;

    case ET_LANG:
        search(found, ET_LANG, entry->m_type, entry->m_name, entry->m_lang);
        break;

    default:
        return FALSE;
    }

    return extract_res(pszFileName, found);
}

BOOL EntrySet::extract_res(LPCWSTR pszFileName, const EntrySet& res) const
{
    MByteStreamEx bs;   // the stream

    // write the header to the stream
    ResHeader header;
    if (!header.WriteTo(bs))
        return FALSE;   // unable to write

    // for all the language entries in res
    for (auto entry : res)
    {
        if (entry->m_et != ET_LANG)
            continue;

        header.DataSize = entry->size();

        // check the header size
        header.HeaderSize = header.GetHeaderSize(entry->m_type, entry->m_name);
        if (header.HeaderSize == 0 || header.HeaderSize >= 0x10000)
            return FALSE;   // invalid

        header.type = entry->m_type;
        header.name = entry->m_name;
        header.DataVersion = 0;
        header.MemoryFlags = MEMORYFLAG_DISCARDABLE | MEMORYFLAG_PURE |
                             MEMORYFLAG_MOVEABLE;
        header.LanguageId = entry->m_lang;
        header.Version = 0;
        header.Characteristics = 0;

        // write the header to the stream
        if (!header.WriteTo(bs))
            return FALSE;   // unable to write

        // write the data to the stream
        if (!bs.WriteData(&(*entry)[0], entry->size()))
            return FALSE;   // unable to write

        // adjust the alignment
        bs.WriteDwordAlignment();
    }

    // save the stream to an *.res file
    return bs.SaveToFile(pszFileName);
}

BOOL EntrySet::extract_cursor(LPCWSTR pszFileName, const EntryBase *entry) const
{
    if (entry->m_type == RT_GROUP_CURSOR)
    {
        // RT_GROUP_CURSOR
        return extract_group_cursor(*entry, pszFileName);
    }
    else if (entry->m_type == RT_CURSOR)
    {
        // RT_CURSOR
        return extract_cursor(*entry, pszFileName);
    }
    else if (entry->m_type == RT_ANICURSOR)
    {
        // RT_ANICURSOR
        MFile file;
        DWORD cbWritten = 0;
        if (file.OpenFileForOutput(pszFileName) &&
            file.WriteFile(&(*entry)[0], entry->size(), &cbWritten))
        {
            // written to the file
            file.FlushFileBuffers();
            file.CloseHandle();
            return TRUE;    // success
        }
    }
    return FALSE;   // failure
}

BOOL EntrySet::extract_icon(LPCWSTR pszFileName, const EntryBase *entry) const
{
    if (entry->m_type == RT_GROUP_ICON)
    {
        // RT_GROUP_ICON
        return extract_group_icon(*entry, pszFileName);
    }
    else if (entry->m_type == RT_ICON)
    {
        // RT_ICON
        return extract_icon(*entry, pszFileName);
    }
    else if (entry->m_type == RT_ANIICON)
    {
        // RT_ANIICON
        MFile file;
        DWORD cbWritten = 0;
        if (file.OpenFileForOutput(pszFileName) &&
            file.WriteFile(&(*entry)[0], entry->size(), &cbWritten))
        {
            // written to the file
            file.FlushFileBuffers();
            file.CloseHandle();
            return TRUE;    // success
        }
    }
    return FALSE;   // failure
}

BOOL EntrySet::import_res(LPCWSTR pszResFile)
{
    // load the file to the stream
    MByteStreamEx stream;
    if (!stream.LoadFromFile(pszResFile))
        return FALSE;   // failure

    BOOL bAdded = FALSE;
    ResHeader header;
    while (header.ReadFrom(stream))     // repeat reading
    {
        // header was loaded

        bAdded = TRUE;
        if (header.DataSize == 0)   // no data
        {
            stream.ReadDwordAlignment();
            continue;   // go to next
        }

        if (header.DataSize > stream.remainder())
            return FALSE;   // invalid size

        // read the data
        EntryBase::data_type data;
        if (header.DataSize)
        {
            // store to data
            data.resize(header.DataSize);
            if (!stream.ReadData(&data[0], header.DataSize))
            {
                break;
            }
        }

        // add a language entry with data
        add_lang_entry(header.type, header.name, header.LanguageId, data);

        // adjust the alignment
        stream.ReadDwordAlignment();
    }

    return bAdded;
}

BOOL
EntrySet::load_msg_table(LPCWSTR pszRCFile, MStringA& strOutput, const MString& strMcdxExe,
                         const MStringW& strMacrosDump, const MStringW& strIncludesDump)
{
    // get the temporary file path
    WCHAR szPath3[MAX_PATH];
    StringCchCopyW(szPath3, _countof(szPath3), GetTempFileNameDx(L"R3"));

    // create the temporary file and wait
    MFile r3(szPath3, TRUE);
    r3.CloseHandle();

    AutoDeleteFileW ad3(szPath3);

    // build the command line text
    MStringW strCmdLine;
    strCmdLine += L'\"';
    strCmdLine += strMcdxExe;
    strCmdLine += L"\" -DMCDX_INVOKED=1 ";
    strCmdLine += strMacrosDump;
    strCmdLine += L' ';
    strCmdLine += strIncludesDump;
    strCmdLine += L" -o \"";
    strCmdLine += szPath3;
    strCmdLine += L"\" -J rc -O res \"";
    strCmdLine += pszRCFile;
    strCmdLine += L'\"';
    //MessageBoxW(NULL, strCmdLine.c_str(), NULL, 0);

    BOOL bSuccess = FALSE;

    // create an mcdx.exe process
    MProcessMaker pmaker;
    pmaker.SetShowWindow(SW_HIDE);
    pmaker.SetCreationFlags(CREATE_NEW_CONSOLE);

    MFile hInputWrite, hOutputRead;
    if (pmaker.PrepareForRedirect(&hInputWrite, &hOutputRead) &&
        pmaker.CreateProcessDx(NULL, strCmdLine.c_str()))
    {
        // read all with timeout
        pmaker.ReadAll(strOutput, hOutputRead, PROCESS_TIMEOUT);

        if (pmaker.GetExitCode() == 0)
        {
            // import from the temporary file
            if (import_res(szPath3))
            {
                bSuccess = TRUE;
            }
        }
    }

    return bSuccess;
}

BOOL EntrySet::IsUTF16File(LPCWSTR pszRCFile) const
{
    if (FILE *fp = _wfopen(pszRCFile, L"rb"))
    {
        BYTE ab[2];
        if (fread(ab, 1, 2, fp) == 2)
        {
            if (memcmp(ab, "\xFF\xFE", 2) == 0)
            {
                fclose(fp);
                return TRUE;
            }
            if (ab[0] && !ab[1])
            {
                fclose(fp);
                return TRUE;
            }
        }
        fclose(fp);
    }
    return FALSE;
}

BOOL EntrySet::load_rc(LPCWSTR pszRCFile, MStringA& strOutput,
    const MString& strWindresExe, const MString& strCppExe,
    const MString& strMcdxExe, const MStringW& strMacrosDump,
    const MStringW& strIncludesDump)
{
    // get the temporary file path
    WCHAR szPath3[MAX_PATH];
    StringCchCopyW(szPath3, _countof(szPath3), GetTempFileNameDx(L"R3"));

    // create the temporary file and wait
    MFile r3(szPath3, TRUE);
    r3.CloseHandle();

    AutoDeleteFileW ad3(szPath3);

    // build the command line text
    MStringW strCmdLine;
    strCmdLine += L'\"';
    strCmdLine += strWindresExe;
    strCmdLine += L"\" -DRC_INVOKED ";
    strCmdLine += strMacrosDump;
    strCmdLine += L' ';
    strCmdLine += strIncludesDump;
    strCmdLine += L" -o \"";
    strCmdLine += szPath3;
    strCmdLine += L"\" -J rc -O res -F pe-i386 \"--preprocessor=";
    strCmdLine += strCppExe;
    strCmdLine += L"\" --preprocessor-arg=\"\" \"";
    strCmdLine += pszRCFile;
    strCmdLine += L'\"';
    //MessageBoxW(NULL, strCmdLine.c_str(), NULL, 0);

    BOOL bSuccess = FALSE;

    // create a windres.exe process
    MProcessMaker pmaker;
    pmaker.SetShowWindow(SW_HIDE);
    pmaker.SetCreationFlags(CREATE_NEW_CONSOLE | CREATE_UNICODE_ENVIRONMENT);

    MFile hInputWrite, hOutputRead;

    if (pmaker.PrepareForRedirect(&hInputWrite, &hOutputRead) &&
        pmaker.CreateProcessDx(NULL, strCmdLine.c_str()))
    {
        // read all with timeout
        pmaker.ReadAll(strOutput, hOutputRead, PROCESS_TIMEOUT);

        if (pmaker.GetExitCode() == 0)
        {
            // import the resource from the temporary file
            bSuccess = import_res(szPath3);
        }
        else if (strOutput.find(": no resources") != MStringA::npos)
        {
            // there is no resource data
            bSuccess = TRUE;
            strOutput.clear();
        }
    }

    if (bSuccess)
    {
        // load the message table if any
        EntrySet es;
        if (es.load_msg_table(pszRCFile, strOutput, strMcdxExe, strMacrosDump, strIncludesDump))
        {
            merge(es);
        }
    }

    return bSuccess;
}

```

`src/Res.hpp`:

```hpp
// Res.hpp --- Win32 Resources
//////////////////////////////////////////////////////////////////////////////
// RisohEditor --- Another free Win32 resource editor
// Copyright (C) 2017-2020 Katayama Hirofumi MZ <katayama.hirofumi.mz@gmail.com>
// 
// This program is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
// 
// This program is distributed in the hope that it will be useful, 
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
// 
// You should have received a copy of the GNU General Public License
// along with this program.  If not, see <http://www.gnu.org/licenses/>.
//////////////////////////////////////////////////////////////////////////////

#pragma once

#include <windows.h>
#include <commctrl.h>
#include <cctype>
#include <cwchar>
#include <set>
#include <unordered_set>     // for std::unordered_set
#include <shlwapi.h>

#include "IconRes.hpp"
#include "MString.hpp"
#include "MProcessMaker.hpp"
#include "PackedDIB.hpp"
#include "MBitmapDx.hpp"
#include "ConstantsDB.hpp"
#include "DialogRes.hpp"
#include "ResHeader.hpp"
#include "ToolbarRes.hpp"

struct BaseEntry;
struct EntrySet;

typedef std::map<MIdOrString, HBITMAP>  MTitleToBitmap;
typedef std::map<MIdOrString, HICON>    MTitleToIcon;

BOOL PackedDIB_GetInfo(const void *pPackedDIB, DWORD dwSize, BITMAP& bm);

///////////////////////////////////////////////////////////////////////////////

#ifndef RT_HTML
    #define RT_HTML         MAKEINTRESOURCE(23)
#endif
#ifndef RT_MANIFEST
    #define RT_MANIFEST     MAKEINTRESOURCE(24)
#endif

#ifndef PROCESS_TIMEOUT
    #define PROCESS_TIMEOUT     (20 * 1000)     // 20 seconds
#endif

///////////////////////////////////////////////////////////////////////////////

// is the resource type an "entity type" ?
BOOL Res_IsEntityType(const MIdOrString& type);

// has the resource type no name?
inline BOOL
Res_HasNoName(const MIdOrString& type)
{
    return type == RT_STRING || type == RT_MESSAGETABLE;
}

///////////////////////////////////////////////////////////////////////////////
// EntryType --- the entry type

enum EntryType
{
    ET_ANY,         // Any.
    ET_TYPE,        // TypeEntry.
    ET_STRING,      // StringEntry.
    ET_MESSAGE,     // MessageEntry.
    ET_NAME,        // NameEntry.
    ET_LANG         // EntryBase.
};

///////////////////////////////////////////////////////////////////////////////
// EntryBase

#define BAD_LANG    0xFFFF      // invalid language value

struct EntryBase
{
    typedef DWORD               size_type;
    typedef std::vector<BYTE>   data_type;

    EntryType       m_et;                   // entry type
    MIdOrString     m_type;                 // resource type
    MIdOrString     m_name;                 // resource name
    WORD            m_lang;                 // resource language
    HTREEITEM       m_hItem;                // treeview item handle
    bool            m_valid;                // "is it valid?" flag
    data_type       m_data;                 // the item data
    MStringW        m_strLabel;             // the label string

    // constructor
    EntryBase() : m_lang(BAD_LANG), m_hItem(NULL), m_valid(true)
    {
    }

    // constructor
    EntryBase(EntryType et, const MIdOrString& type, 
            const MIdOrString& name = WORD(0), WORD lang = BAD_LANG)
        : m_et(et), m_type(type), m_name(name), m_lang(lang), m_hItem(NULL), m_valid(true)
    {
    }

    // destructor
    virtual ~EntryBase()
    {
    }

    // is it valid?
    bool valid() const
    {
        if (m_et == ET_LANG)
            return !empty() && m_valid;

        if (!m_hItem)
            return false;

        return m_valid;
    }

    // make it invalid
    void mark_invalid()
    {
        m_valid = false;
        m_data.clear();
    }

    // can it be editted by GUI?
    bool can_gui_edit() const
    {
        if (m_type == RT_DIALOG || m_type == RT_MENU ||
            m_type == RT_STRING ||
            m_type == RT_ACCELERATOR || m_type == WORD(240))
        {
            return true;
        }
        if (m_type == RT_TOOLBAR)
            return true;
        if (m_type == RT_MESSAGETABLE)
            return !g_settings.bUseMSMSGTABLE;
        return false;
    }

    // is it testable?
    bool is_testable() const
    {
        return m_type == RT_DIALOG || m_type == RT_MENU;
    }

    // pattern match
    bool match(EntryType et, const MIdOrString& type, const MIdOrString& name,
               WORD lang = BAD_LANG) const
    {
        if (et != ET_ANY && m_et != et)
            return false;
        if (!type.is_zero() && m_type != type)
            return false;
        if (!name.is_zero() && m_name != name)
            return false;
        if (lang != BAD_LANG && m_lang != lang)
            return false;
        return true;
    }

    // compare
    bool operator==(const EntryBase& entry) const
    {
        return m_et == entry.m_et &&
               m_lang == entry.m_lang &&
               m_type == entry.m_type &&
               m_name == entry.m_name;
    }
    bool operator!=(const EntryBase& entry) const
    {
        return !(*this == entry);
    }
    bool operator<(const EntryBase& entry) const
    {
        if (m_type < entry.m_type)
            return true;
        if (m_type > entry.m_type)
            return false;
        if (m_et < entry.m_et)
            return true;
        if (m_et > entry.m_et)
            return false;
        if (m_name < entry.m_name)
            return true;
        if (m_name > entry.m_name)
            return false;
        if (m_lang < entry.m_lang)
            return true;
        if (m_lang > entry.m_lang)
            return false;
        return false;
    }

    // get the resource type label
    MStringW get_type_label() const
    {
        if (!m_type.m_id)
            return m_type.m_str;    // string name type

        // it was integer name type

        MStringW label = g_db.GetName(L"RESOURCE", m_type.m_id);
        if (label.empty())  // unable to get the label
            return mstr_dec_word(m_type.m_id);  // returns the numeric text

        // got the label
        if (!mchr_is_digit(label[0]))   // first character is not digit
        {
            // add a parenthesis pair and numeric text
            label += L" (";
            label += mstr_dec_word(m_type.m_id);
            label += L")";
        }

        return label;
    }

    // get the resource name label
    MStringW get_name_label() const;

    // get the resource language label
    MStringW get_lang_label() const
    {
        // use an external helper function
        MStringW TextFromLang(WORD lang);
        return TextFromLang(m_lang);
    }

    // clear the data
    void clear_data()
    {
        m_data.clear();
    }

    // clear all
    void clear()
    {
        clear_data();
        m_lang = BAD_LANG;
        m_name = (WORD)0;
        m_type = (WORD)0;
    }

    // is it empty?
    bool empty() const
    {
        return size() == 0;
    }
    // the size of data
    size_type size() const
    {
        return size_type(m_data.size());
    }
    // the index accessor
    BYTE& operator[](DWORD index)
    {
        assert(index <= m_data.size());
        return m_data[index];
    }
    const BYTE& operator[](DWORD index) const
    {
        assert(index <= m_data.size());
        return m_data[index];
    }

    // the pointer to data
    void *ptr(DWORD index = 0)
    {
        return &m_data[index];
    }
    const void *ptr(DWORD index = 0) const
    {
        return &m_data[index];
    }

    // assign the data
    void assign(const data_type& data)
    {
        m_data = data;
    }
    void assign(const void *ptr, size_type nSize)
    {
        if (ptr && nSize)
        {
            m_data.resize(nSize);
            memcpy(&m_data[0], ptr, nSize);
        }
        else
        {
            m_data.clear();
        }
    }

    // is it editable?
    BOOL is_editable(LPCWSTR pszVCBat) const;

    BOOL is_delphi_dfm() const
    {
        return m_type == RT_RCDATA && size() >= 4 && memcmp(ptr(), "TPF0", 4) == 0;
    }

    std::string get_dfm_text(LPCWSTR pszDFMSC) const;
    void set_dfm_text(LPCWSTR pszDFMSC, std::string& text);
};

inline EntryBase *
Res_NewTypeEntry(const MIdOrString& type)
{
    return new EntryBase(ET_TYPE, type);
}

inline EntryBase *
Res_NewNameEntry(const MIdOrString& type, const MIdOrString& name)
{
    return new EntryBase(ET_NAME, type, name);
}

inline EntryBase *
Res_NewStringEntry(WORD lang)
{
    return new EntryBase(ET_STRING, RT_STRING, WORD(0), lang);
}

inline EntryBase *
Res_NewMessageEntry(WORD lang)
{
    return new EntryBase(ET_MESSAGE, RT_MESSAGETABLE, WORD(0), lang);
}

inline EntryBase *
Res_NewLangEntry(const MIdOrString& type, const MIdOrString& name, WORD lang = BAD_LANG)
{
    return new EntryBase(ET_LANG, type, name, lang);
}

std::string
dfm_text_from_binary(LPCWSTR pszDFMSC, const void *binary, size_t size,
                     INT codepage, BOOL bComments);

EntryBase::data_type
dfm_binary_from_text(LPCWSTR pszDFMSC, const std::string& text,
                     INT codepage, BOOL no_unicode, INT& iLine);

std::string
tlb_text_from_binary(LPCWSTR pszOleBow, const void *binary, size_t size);

EntryBase::data_type
tlb_binary_from_text(LPCWSTR pszMidlWrap, LPCWSTR pszVCBat, MStringA& strOutput, const std::string& text, bool is_64bit);

///////////////////////////////////////////////////////////////////////////////
// EntrySet

// https://msdn.microsoft.com/ja-jp/library/windows/desktop/bb773793.aspx
// NOTE: It is not safe to delete items in response to a notification such as TVN_SELCHANGING.

struct EntryLess
{
    bool operator()(const EntryBase *e1, const EntryBase *e2) const
    {
        return *e1 < *e2;
    }
};

typedef std::set<EntryBase *, EntryLess> EntrySetBase;

struct EntrySet : protected EntrySetBase
{
    typedef EntrySetBase super_type;
    typedef EntrySet self_type;
    using super_type::empty;
    using super_type::size;
    using super_type::clear;
    using super_type::begin;
    using super_type::end;
    using super_type::insert;
    using super_type::erase;
    using super_type::swap;

    HWND m_hwndTV;      // the treeview handle

    // constructor
    EntrySet(HWND hwndTV = NULL) : m_hwndTV(hwndTV)
    {
    }

    // constructor
    EntrySet(const super_type& super, HWND hwndTV = NULL)
        : super_type(super), m_hwndTV(hwndTV)
    {
    }

    // the super class pointer
    super_type *super()
    {
        return dynamic_cast<super_type *>(this);
    }
    const super_type *super() const
    {
        return dynamic_cast<const super_type *>(this);
    }

    // search by pattern matching
    bool search(self_type& found, EntryType et, const MIdOrString& type = WORD(0), 
                const MIdOrString& name = WORD(0), WORD lang = BAD_LANG, bool invalid_ok = false) const
    {
        for (auto entry : *this)
        {
            if (!entry->valid() && !invalid_ok)
                continue;
            if (entry->match(et, type, name, lang))
                found.insert(entry);
        }
        return !found.empty();
    }

    // find by pattern matching
    EntryBase *find(EntryType et, const MIdOrString& type = WORD(0),
                    const MIdOrString& name = WORD(0),
                    WORD lang = BAD_LANG, bool invalid_ok = false) const
    {
        self_type found;
        if (search(found, et, type, name, lang, invalid_ok))
        {
            return *found.begin();
        }
        return NULL;
    }
    EntryBase *find(EntryBase *entry, bool invalid_ok = false) const
    {
        return find(entry->m_et, entry->m_type, entry->m_name, entry->m_lang, invalid_ok);
    }

    // is it overlapped with another?
    bool intersect(const EntrySet& another) const;

    // merge another
    void merge(const EntrySet& another)
    {
        for (auto entry : another)
        {
            if (entry->m_et != ET_LANG)
                continue;   // we will merge the ET_LANG entries only

            add_lang_entry(entry->m_type, entry->m_name, entry->m_lang, entry->m_data);
        }
    }

    // add a language entry
    EntryBase *
    add_lang_entry(const MIdOrString& type, const MIdOrString& name, WORD lang)
    {
        EntryBase::data_type data;
        return add_lang_entry(type, name, lang, data);
    }
    EntryBase *
    add_lang_entry(const MIdOrString& type, const MIdOrString& name, 
                   WORD lang, const EntryBase::data_type& data);

    // delete an entry (and related entries)
    void delete_entry(EntryBase *entry);

    // search the invalid entries
    void search_invalid(super_type& found)
    {
        for (auto entry : *this)
        {
            // add the invalid
            if (!entry->valid())
                found.insert(entry);

            // add the childless
            if (is_childless_parent(entry))
                found.insert(entry);
        }
    }

    // delete the invalid entries
    void delete_invalid();

    // search and delete
    bool search_and_delete(EntryType et, const MIdOrString& type = WORD(0), 
                           const MIdOrString& name = WORD(0), WORD lang = BAD_LANG)
    {
        // search
        self_type found;
        search(found, et, type, name, lang);

        // delete
        bool ret = false;
        for (auto entry : found)
        {
            ret = true;
            delete_entry(entry);
        }
        return ret;
    }

    // get last ID of the specified type and language
    UINT get_last_id(const MIdOrString& type, WORD lang) const;

    // update the executable
    BOOL update_exe(LPCWSTR ExeFile) const;

    // helper method for MRadWindow and MTestDialog
    void do_bitmap(MTitleToBitmap& title_to_bitmap, DialogItem& item, WORD lang);

    // helper method for MRadWindow and MTestDialog
    void do_icon(MTitleToIcon& title_to_icon, DialogItem& item, WORD lang);

    // extract the cursor as a *.cur file
    bool extract_cursor(const EntryBase& c_entry, const wchar_t *file_name) const;

    // extract the group cursor as a *.cur file
    bool extract_group_cursor(const EntryBase& group, const wchar_t *file_name) const;

    // extract the icon as a *.ico file
    BOOL extract_icon(const EntryBase& i_entry, const wchar_t *file_name) const;

    // extract the group icon as a *.ico file
    bool extract_group_icon(const EntryBase& group, const wchar_t *file_name) const;

    // add a bitmap entry
    EntryBase *add_bitmap(const MIdOrString& name, WORD lang, const MStringW& file);

    // add a group icon
    EntryBase *
    add_group_icon(const MIdOrString& name, WORD lang, 
                   const MStringW& file_name);

    // add a group cursor
    EntryBase *
    add_group_cursor(const MIdOrString& name, WORD lang, 
                     const MStringW& file_name);

    // add a string entry
    EntryBase *
    add_string_entry(WORD lang)
    {
        auto entry = find(ET_STRING, RT_STRING, (WORD)0, lang, true);
        if (!entry)
            entry = Res_NewStringEntry(lang);
        return on_insert_entry(entry);
    }

    // add a message entry
    EntryBase *
    add_message_entry(WORD lang)
    {
        auto entry = find(ET_MESSAGE, RT_MESSAGETABLE, (WORD)0, lang, true);
        if (!entry)
            entry = Res_NewMessageEntry(lang);
        return on_insert_entry(entry);
    }

    // add a name entry
    EntryBase *
    add_name_entry(const MIdOrString& type, const MIdOrString& name)
    {
        auto entry = find(ET_NAME, type, name, BAD_LANG, true);
        if (!entry)
            entry = Res_NewNameEntry(type, name);
        return on_insert_entry(entry);
    }

    // add a type entry
    EntryBase *
    add_type_entry(const MIdOrString& type, bool replace)
    {
        auto entry = find(ET_TYPE, type, (WORD)0, BAD_LANG, true);
        if (!entry)
            entry = Res_NewTypeEntry(type);
        return on_insert_entry(entry);
    }

    // insert or get the parent entry to be insert there
    HTREEITEM get_insert_parent(EntryBase *entry);

    // get the insertion position
    HTREEITEM get_insert_position(EntryBase *entry);

    // get the parent entry
    EntryBase *get_parent(EntryBase *entry);

    // is it a childless entry?
    bool is_childless_parent(EntryBase *entry) const;

    // get the label for a treeview item
    MStringW get_label(const EntryBase *entry);

    // helper method for entry insertion
    EntryBase *on_insert_entry(EntryBase *entry);

    EntryBase *
    on_insert_after(HTREEITEM hParent, EntryBase *entry, HTREEITEM hInsertAfter);

    // helper method to delete the dialog
    void on_delete_dialog(EntryBase *entry)
    {
        assert(entry->m_et == ET_LANG && entry->m_type == RT_DIALOG);
    }

    // helper method to delete the strings
    void on_delete_string(EntryBase *entry)
    {
        assert(entry->m_et == ET_STRING);
        search_and_delete(ET_LANG, RT_STRING, (WORD)0, entry->m_lang);
    }

    // helper method to delete the messages
    void on_delete_message(EntryBase *entry)
    {
        assert(entry->m_et == ET_MESSAGE);
        search_and_delete(ET_LANG, RT_MESSAGETABLE, (WORD)0, entry->m_lang);
    }

    // helper method to delete the group icon
    bool on_delete_group_icon(EntryBase *entry);

    // helper method to delete the group cursor
    bool on_delete_group_cursor(EntryBase *entry);

    struct EnumResStruct
    {
        EntrySet *this_;
    };

    // add a resource entry from an executable module
    EntryBase *
    add_res_entry(HMODULE hMod, LPCWSTR type, LPCWSTR name, WORD lang);

    // callback to insert the resource in the executable
    static BOOL CALLBACK
    EnumResLangProc(HMODULE hMod, LPCWSTR lpszType, LPCWSTR lpszName, 
                    WORD wIDLanguage, LPARAM lParam)
    {
        auto ers = (EnumResStruct *)lParam;
        ers->this_->add_res_entry(hMod, lpszType, lpszName, wIDLanguage);
        return TRUE;
    }

    // callback to insert the resource in the executable
    static BOOL CALLBACK
    EnumResNameProc(HMODULE hMod, LPCWSTR lpszType, LPWSTR lpszName, LPARAM lParam)
    {
        return ::EnumResourceLanguagesW(hMod, lpszType, lpszName, EnumResLangProc, lParam);
    }

    // callback to insert the resource in the executable
    static BOOL CALLBACK
    EnumResTypeProc(HMODULE hMod, LPWSTR lpszType, LPARAM lParam)
    {
        return ::EnumResourceNamesW(hMod, lpszType, EnumResNameProc, lParam);
    }

    // get the child if any
    EntryBase *get_child(EntryBase *parent) const;

public:
    // add the resources in the executable module
    BOOL from_res(HMODULE hMod)
    {
        EnumResStruct ers;
        ers.this_ = this;
        return ::EnumResourceTypesW(hMod, EnumResTypeProc, (LPARAM)&ers);
    }

    // delete all the entries
    void delete_all(void)
    {
        if (m_hwndTV)
        {
            TreeView_DeleteAllItems(m_hwndTV);
        }
        else
        {
            search_and_delete(ET_ANY, (WORD)0, (WORD)0, BAD_LANG);
            delete_invalid();
        }
    }

    // for TVN_DELETEITEM
    void on_delete_item(EntryBase *entry)
    {
        if (!entry || super()->find(entry) == super()->end())
            return;

        DebugPrintDx(L"on_delete_item: %p, %s, %s, %u, %s\n", entry, entry->m_type.c_str(), entry->m_name.c_str(), entry->m_lang, entry->m_strLabel.c_str());
        entry->m_hItem = NULL;
        delete_entry(entry);
    }

    // get the LPARAM parameter of the currently selected or the specified handle
    LPARAM get_param(HTREEITEM hItem = NULL) const
    {
        if (!hItem)
            hItem = TreeView_GetSelection(m_hwndTV);

        TV_ITEM item;
        ZeroMemory(&item, sizeof(item));
        item.mask = TVIF_PARAM;
        item.hItem = hItem;
        TreeView_GetItem(m_hwndTV, &item);

        return item.lParam;
    }

    // get the entry pointer of the currently selected or the specified info
    EntryBase *get_entry(HTREEITEM hItem = NULL, EntryType et = ET_ANY) const
    {
        LPARAM lParam = get_param(hItem);
        if (!lParam)
            return NULL;
        auto e = (EntryBase *)lParam;
        if (et != ET_ANY && et != e->m_et)
            return NULL;
        return e;
    }

    // get a language entry of the currently selected or the specified handle
    EntryBase *get_lang_entry(HTREEITEM hItem = NULL) const
    {
        return get_entry(hItem, ET_LANG);
    }

    // get the selected item handle of treeview
    HTREEITEM get_item(void) const
    {
        return TreeView_GetSelection(m_hwndTV);
    }

    // copy the group icon
    BOOL copy_group_icon(EntryBase *entry, const MIdOrString& new_name, WORD new_lang);

    // copy the group cursor
    BOOL copy_group_cursor(EntryBase *entry, const MIdOrString& new_name, WORD new_lang);

    // extract one resource item as an *.res file
    BOOL extract_res(LPCWSTR pszFileName, const EntryBase *entry) const;

    // extract some resource items as an *.res file
    BOOL extract_res(LPCWSTR pszFileName, const EntrySet& res) const;

    // extract the cursor as an *.cur or *.ani file
    BOOL extract_cursor(LPCWSTR pszFileName, const EntryBase *entry) const;

    // extract the icon as an *.ico file
    BOOL extract_icon(LPCWSTR pszFileName, const EntryBase *entry) const;

    // extract the resource data as a binary file
    BOOL extract_bin(LPCWSTR pszFileName, const EntryBase *e) const
    {
        if (e->m_et != ET_LANG)
            return FALSE;   // invalid

        // write the resource data to a binary file
        MByteStreamEx bs(e->m_data);
        return bs.SaveToFile(pszFileName);
    }

    // import the resource data from the specified *.res file
    BOOL import_res(LPCWSTR pszResFile);

    // load the message table from a *.rc file
    BOOL load_msg_table(LPCWSTR pszRCFile, MStringA& strOutput, const MString& strMcdxExe,
                        const MStringW& strMacrosDump, const MStringW& strIncludesDump);

    BOOL IsUTF16File(LPCWSTR pszRCFile) const;

    // load the resources from a *.rc file
    BOOL load_rc(LPCWSTR pszRCFile, MStringA& strOutput,
        const MString& strWindresExe, const MString& strCppExe,
        const MString& strMcdxExe, const MStringW& strMacrosDump,
        const MStringW& strIncludesDump);
};

// g_res
#ifdef USE_GLOBALS
    extern EntrySet g_res;
#else
    inline EntrySet&
    Res_GetMaster(void)
    {
        static EntrySet eset;
        return eset;
    }
    #define g_res   Res_GetMaster()
#endif

```

`src/ResHeader.hpp`:

```hpp
// ResHeader.hpp --- Win32 Resource Header
//////////////////////////////////////////////////////////////////////////////
// RisohEditor --- Another free Win32 resource editor
// Copyright (C) 2017-2018 Katayama Hirofumi MZ <katayama.hirofumi.mz@gmail.com>
// 
// This program is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
// 
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
// 
// You should have received a copy of the GNU General Public License
// along with this program.  If not, see <http://www.gnu.org/licenses/>.
//////////////////////////////////////////////////////////////////////////////

#pragma once

#include "MIdOrString.hpp"
#include "MByteStreamEx.hpp"

class ResHeader;

//////////////////////////////////////////////////////////////////////////////

#define    MEMORYFLAG_MOVEABLE     0x0010
#define    MEMORYFLAG_PURE         0x0020
#define    MEMORYFLAG_PRELOAD      0x0040
#define    MEMORYFLAG_DISCARDABLE  0x1000

class ResHeader
{
public:
    DWORD           DataSize;
    DWORD           HeaderSize;
    MIdOrString     type;
    MIdOrString     name;
    DWORD           DataVersion;
    WORD            MemoryFlags;
    WORD            LanguageId;
    DWORD           Version;
    DWORD           Characteristics;

    ResHeader()
    {
        DataSize = 0;
        HeaderSize = 0x20;
        type = (WORD)0;
        name = (WORD)0;
        DataVersion = 0;
        MemoryFlags = 0;
        LanguageId = 0;
        Version = 0;
        Characteristics = 0;
    }

    bool ReadFrom(const MByteStreamEx& bs)
    {
        if (!bs.ReadRaw(DataSize) || !bs.ReadRaw(HeaderSize) ||
            !bs.ReadID(type) || !bs.ReadID(name))
        {
            return false;
        }
        bs.ReadDwordAlignment();

        if (!bs.ReadRaw(DataVersion) || !bs.ReadRaw(MemoryFlags) ||
            !bs.ReadRaw(LanguageId) || !bs.ReadRaw(Version) ||
            !bs.ReadRaw(Characteristics))
        {
            return false;
        }
        bs.ReadDwordAlignment();

        return true;
    }

    bool WriteTo(MByteStreamEx& bs) const
    {
        if (!bs.WriteRaw(DataSize) || !bs.WriteRaw(HeaderSize) ||
            !bs.WriteID(type) || !bs.WriteID(name))
        {
            return false;
        }
        bs.WriteDwordAlignment();

        if (!bs.WriteRaw(DataVersion) || !bs.WriteRaw(MemoryFlags) ||
            !bs.WriteRaw(LanguageId) || !bs.WriteRaw(Version) ||
            !bs.WriteRaw(Characteristics))
        {
            return false;
        }
        bs.WriteDwordAlignment();

        return true;
    }

    DWORD GetHeaderSize(const MIdOrString& type, MIdOrString name) const
    {
        size_t size = 0;
        if (type.is_str())
            size += (type.m_str.size() + 1) * sizeof(WCHAR);
        else
            size += sizeof(WORD) * 2;

        if (name.is_str())
            size += (name.m_str.size() + 1) * sizeof(WCHAR);
        else
            size += sizeof(WORD) * 2;

        if (size & 3)
            size += 4 - (size & 3);

        return DWORD(sizeof(DWORD) * 6 + size);
    }
};

```

`src/ResToText.cpp`:

```cpp
// ResToText.cpp --- Dumping Resource
//////////////////////////////////////////////////////////////////////////////
// RisohEditor --- Another free Win32 resource editor
// Copyright (C) 2017-2018 Katayama Hirofumi MZ <katayama.hirofumi.mz@gmail.com>
// 
// This program is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
// 
// This program is distributed in the hope that it will be useful, 
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
// 
// You should have received a copy of the GNU General Public License
// along with this program.  If not, see <http://www.gnu.org/licenses/>.
//////////////////////////////////////////////////////////////////////////////

#include "resource.h"
#include "ResToText.hpp"
#include "MTextToText.hpp"
#include "ConstantsDB.hpp"
#include "RisohSettings.hpp"

#include "DialogRes.hpp"
#include "MenuRes.hpp"
#include "VersionRes.hpp"
#include "StringRes.hpp"
#include "AccelRes.hpp"
#include "DlgInitRes.hpp"
#include "MessageRes.hpp"
#include "ToolbarRes.hpp"

MString
ResToText::GetEntryFileName(const EntryBase& entry)
{
    MString ret;

    if (entry.m_type.is_int())
    {
        WORD wType = entry.m_type.m_id;
        if (wType == (WORD)(UINT_PTR)RT_CURSOR)
        {
            // No output file
        }
        else if (wType == (WORD)(UINT_PTR)RT_BITMAP)
        {
            ret += L"Bitmap_";
            ret += DumpEscapedName(entry.m_name);
            ret += L".bmp";
        }
        else if (wType == (WORD)(UINT_PTR)RT_ICON)
        {
            // No output file
        }
        else if (wType == (WORD)(UINT_PTR)RT_MENU)
        {
            // No output file
        }
        else if (wType == (WORD)(UINT_PTR)RT_TOOLBAR)
        {
            // No output file
        }
        else if (wType == (WORD)(UINT_PTR)RT_DIALOG)
        {
            // No output file
        }
        else if (wType == (WORD)(UINT_PTR)RT_STRING)
        {
            // No output file
        }
        else if (wType == (WORD)(UINT_PTR)RT_FONTDIR)
        {
            // No output file
        }
        else if (wType == (WORD)(UINT_PTR)RT_FONT)
        {
            if (entry.m_data.size() < 4)
            {
                // No output file
            }
            else
            {
                if (memcmp(&entry.m_data[0], "OTTO", 4) == 0)
                {
                    // OpenType
                    ret += L"Font_";
                    ret += DumpEscapedName(entry.m_name);
                    ret += L".otf";
                }
                else if (memcmp(&entry.m_data[0], "\x00\x01\x00\x00", 4) == 0)
                {
                    // TrueType
                    ret += L"Font_";
                    ret += DumpEscapedName(entry.m_name);
                    ret += L".ttf";
                }
                else if (memcmp(&entry.m_data[0], "ttcf", 4) == 0)
                {
                    // TrueType Collection
                    ret += L"Font_";
                    ret += DumpEscapedName(entry.m_name);
                    ret += L".ttc";
                }
                else
                {
                    // otherwise
                    ret += L"Font_";
                    ret += DumpEscapedName(entry.m_name);
                    ret += L".fon";
                }
            }
        }
        else if (wType == (WORD)(UINT_PTR)RT_ACCELERATOR)
        {
            // No output file
        }
        else if (wType == (WORD)(UINT_PTR)RT_RCDATA)
        {
            if (entry.is_delphi_dfm())
            {
                ret += L"Delphi_";
                ret += DumpEscapedName(entry.m_name);
                ret += L".dfm";
            }
            else
            {
                ret += L"RCData_";
                ret += DumpEscapedName(entry.m_name);
                ret += L".bin";
            }
        }
        else if (wType == (WORD)(UINT_PTR)RT_MESSAGETABLE)
        {
            if (g_settings.bUseMSMSGTABLE)
            {
                ret += L"MessageTable_";
                if (entry.m_name.is_zero())
                    ret += DumpEscapedName(1);
                else
                    ret += DumpEscapedName(entry.m_name);
                ret += L".bin";
            }
            else
            {
                // No output file
            }
        }
        else if (wType == (WORD)(UINT_PTR)RT_GROUP_CURSOR)
        {
            ret += L"Cursor_";
            ret += DumpEscapedName(entry.m_name);
            ret += L".cur";
        }
        else if (wType == (WORD)(UINT_PTR)RT_GROUP_ICON)
        {
            ret += L"Icon_";
            ret += DumpEscapedName(entry.m_name);
            ret += L".ico";
        }
        else if (wType == (WORD)(UINT_PTR)RT_VERSION)
        {
            // No output file
        }
        else if (wType == (WORD)(UINT_PTR)RT_DLGINCLUDE)
        {
            // TODO:
        }
        else if (wType == (WORD)(UINT_PTR)RT_PLUGPLAY)
        {
            // TODO:
        }
        else if (wType == (WORD)(UINT_PTR)RT_VXD)
        {
            // TODO:
        }
        else if (wType == (WORD)(UINT_PTR)RT_ANICURSOR)
        {
            ret += L"AniCursor_";
            ret += DumpEscapedName(entry.m_name);
            ret += L".ani";
        }
        else if (wType == (WORD)(UINT_PTR)RT_ANIICON)
        {
            ret += L"AniIcon_";
            ret += DumpEscapedName(entry.m_name);
            ret += L".ani";
        }
        else if (wType == (WORD)(UINT_PTR)RT_HTML)
        {
            ret += L"Html_";
            ret += DumpEscapedName(entry.m_name);
            ret += L".html";
        }
        else if (wType == (WORD)(UINT_PTR)RT_MANIFEST)
        {
            ret += L"Manifest_";
            ret += DumpEscapedName(entry.m_name);
            ret += L".manifest";
        }
        else if (wType == (WORD)(UINT_PTR)RT_FONT)
        {
            ret += L"Font_";
            ret += DumpEscapedName(entry.m_name);
            ret += L".fon";
        }
        else
        {
            ret += entry.m_type.str();
            ret += L"_";
            ret += DumpEscapedName(entry.m_name);
            ret += L".bin";
        }
    }
    else
    {
        if (entry.m_type == L"AVI")
        {
            ret += L"Avi_";
            ret += DumpEscapedName(entry.m_name);
            ret += L".avi";
        }
        else if (entry.m_type == L"PNG")
        {
            ret += L"Png_";
            ret += DumpEscapedName(entry.m_name);
            ret += L".png";
        }
        else if (entry.m_type == L"GIF")
        {
            ret += L"Gif_";
            ret += DumpEscapedName(entry.m_name);
            ret += L".gif";
        }
        else if (entry.m_type == L"JPEG")
        {
            ret += L"Jpeg_";
            ret += DumpEscapedName(entry.m_name);
            ret += L".jpg";
        }
        else if (entry.m_type == L"JPG")
        {
            ret += L"Jpg_";
            ret += DumpEscapedName(entry.m_name);
            ret += L".jpg";
        }
        else if (entry.m_type == L"TIFF")
        {
            ret += L"Tiff_";
            ret += DumpEscapedName(entry.m_name);
            ret += L".tif";
        }
        else if (entry.m_type == L"TIF")
        {
            ret += L"Tif_";
            ret += DumpEscapedName(entry.m_name);
            ret += L".tif";
        }
        else if (entry.m_type == L"EMF")
        {
            ret += L"Emf_";
            ret += DumpEscapedName(entry.m_name);
            ret += L".emf";
        }
        else if (entry.m_type == L"ENHMETAFILE")
        {
            ret += L"EnhMetaFile_";
            ret += DumpEscapedName(entry.m_name);
            ret += L".emf";
        }
        else if (entry.m_type == L"ENHMETAPICT")
        {
            ret += L"EnhMetaPict_";
            ret += DumpEscapedName(entry.m_name);
            ret += L".emf";
        }
        else if (entry.m_type == L"WMF")
        {
            ret += L"Wmf_";
            ret += DumpEscapedName(entry.m_name);
            ret += L".wmf";
        }
        else if (entry.m_type == L"WAVE")
        {
            ret += L"Wave_";
            ret += DumpEscapedName(entry.m_name);
            ret += L".wav";
        }
        else if (entry.m_type == L"TYPELIB")
        {
            ret += L"TYPELIB_";
            ret += DumpEscapedName(entry.m_name);
            ret += L".tlb";
        }
        else if (entry.m_type == L"IMAGE")
        {
            if (entry.m_et == ET_LANG)
            {
                if (entry.size() >= 4)
                {
                    if (memcmp(&entry[0], "BM", 2) == 0)
                    {
                        ret += L"Image_";
                        ret += DumpEscapedName(entry.m_name);
                        ret += L".bmp";
                    }
                    else if (memcmp(&entry[0], "GIF", 3) == 0)
                    {
                        ret += L"Image_";
                        ret += DumpEscapedName(entry.m_name);
                        ret += L".gif";
                    }
                    else if (memcmp(&entry[0], "\x89\x50\x4E\x47", 4) == 0)
                    {
                        ret += L"Image_";
                        ret += DumpEscapedName(entry.m_name);
                        ret += L".png";
                    }
                    else if (memcmp(&entry[0], "\xFF\xD8", 2) == 0)
                    {
                        ret += L"Image_";
                        ret += DumpEscapedName(entry.m_name);
                        ret += L".jpg";
                    }
                    else if (memcmp(&entry[0], "\x4D\x4D", 2) == 0 ||
                             memcmp(&entry[0], "\x49\x49", 2) == 0)
                    {
                        ret += L"Image_";
                        ret += DumpEscapedName(entry.m_name);
                        ret += L".tif";
                    }
                }
            }
        }
        else
        {
            ret += entry.m_type.str();
            ret += L"_";
            ret += DumpEscapedName(entry.m_name);
            ret += L".bin";
        }
    }

    if (ret.size())
    {
        if (entry.m_lang != 0 && entry.m_lang != BAD_LANG)
        {
            WCHAR sz[32];
            StringCchPrintfW(sz, _countof(sz), L"%u_", entry.m_lang);
            ret = sz + ret;
        }
        ret = m_strFilePrefix + ret;
    }

    return ret;
}

MString
ResToText::DoCursor(const EntryBase& entry)
{
    MString str;

    if (m_bHumanReadable)
    {
        BITMAP bm;
        HCURSOR hCursor = PackedDIB_CreateIcon(&entry[0], entry.size(), bm, FALSE);
        HBITMAP hbm = CreateBitmapFromIconDx(hCursor, bm.bmWidth, bm.bmHeight, TRUE);
        str += DumpIconInfo(bm, FALSE);
        DestroyCursor(hCursor);
        DeleteObject(hbm);

        str += L"\r\n";
    }

    return str;
}

MString
ResToText::DoBitmap(const EntryBase& entry)
{
    HBITMAP hbm = PackedDIB_CreateBitmap(&entry[0], entry.size());
    MString str;

    if (m_bHumanReadable)
    {
        str += DumpBitmapInfo(hbm);
        str += L"\r\n";
    }

    // LANGUAGE ..., ...
    str += GetLanguageStatement(entry.m_lang);

    str += DumpName(entry.m_type, entry.m_name);
    str += L" BITMAP \"";
    str += GetEntryFileName(entry);
    str += L"\"\r\n\r\n";

    DeleteObject(hbm);
    return str;
}

MString
ResToText::DoIcon(const EntryBase& entry)
{
    MString str;

    if (m_bHumanReadable)
    {
        BITMAP bm;
        HBITMAP hbm = CreateBitmapFromIconOrPngDx(m_hwnd, entry, bm);

        HICON hIcon = PackedDIB_CreateIcon(&entry[0], entry.size(), bm, TRUE);
        if (hIcon)
        {
            str += DumpIconInfo(bm, TRUE);
        }
        else
        {
            str += DumpBitmapInfo(hbm);
        }
        DestroyIcon(hIcon);
        DeleteObject(hbm);

        str += L"\r\n";
    }

    return str;
}

MString
ResToText::DoMenu(const EntryBase& entry)
{
    MByteStreamEx stream(entry.m_data);
    MenuRes menu_res;
    if (menu_res.LoadFromStream(stream))
    {
        MString str = GetLanguageStatement(entry.m_lang);
        str += menu_res.Dump(entry.m_name);
        str += L"\r\n";
        return str;
    }
    return LoadStringDx(IDS_INVALIDDATA);
}

MString
ResToText::DoToolbar(const EntryBase& entry)
{
    MByteStreamEx stream(entry.m_data);
    ToolbarRes toolbar_res;
    if (toolbar_res.LoadFromStream(stream))
    {
        MString str = GetLanguageStatement(entry.m_lang);
        str += toolbar_res.Dump(entry.m_name);
        str += L"\r\n";
        return str;
    }
    return LoadStringDx(IDS_INVALIDDATA);
}

MString
ResToText::DoDialog(const EntryBase& entry)
{
    MByteStreamEx stream(entry.m_data);
    DialogRes dialog_res;
    if (dialog_res.LoadFromStream(stream))
    {
        MString str = GetLanguageStatement(entry.m_lang);
        str += dialog_res.Dump(entry.m_name, !!g_settings.bAlwaysControl);
        str += L"\r\n";
        return str;
    }
    return LoadStringDx(IDS_INVALIDDATA);
}

MString
ResToText::DoString(const EntryBase& entry)
{
    EntrySet found;
    g_res.search(found, ET_LANG, RT_STRING, entry.m_name, entry.m_lang);

    StringRes str_res;
    for (auto e : found)
    {
        MByteStreamEx stream(e->m_data);
        if (!str_res.LoadFromStream(stream, e->m_name.m_id))
            return LoadStringDx(IDS_INVALIDDATA);
    }

    MString str;
    if (entry.m_name.empty())
        str += GetLanguageStatement(entry.m_lang);
    str += str_res.Dump();
    str += L"\r\n\r\n";
    return str;
}

MString
ResToText::DoMessage(const EntryBase& entry)
{
    EntrySet found;
    g_res.search(found, ET_LANG, RT_MESSAGETABLE, entry.m_name, entry.m_lang);

    MIdOrString name = entry.m_name;
    MessageRes msg_res;
    for (auto e : found)
    {
        MByteStreamEx stream(e->m_data);
        if (!msg_res.LoadFromStream(stream, 0))
            return LoadStringDx(IDS_INVALIDDATA);
        name = e->m_name;
        break;
    }

    MString str;
    if (entry.m_name.empty())
        str += GetLanguageStatement(entry.m_lang);

    if (g_settings.bUseMSMSGTABLE)
    {
        str += DumpName(entry.m_type, name);
        str += L" MESSAGETABLE \"";
        str += GetEntryFileName(entry);
        str += L"\"\r\n\r\n";
    }
    else
    {
        str += L"#ifdef MCDX_INVOKED\r\n";
        str += msg_res.Dump();
        str += L"#endif\r\n\r\n";
    }

    return str;
}

MString
ResToText::DoAccel(const EntryBase& entry)
{
    MByteStreamEx stream(entry.m_data);
    AccelRes accel;
    if (accel.LoadFromStream(stream))
    {
        MString str = GetLanguageStatement(entry.m_lang);
        str += accel.Dump(entry.m_name);
        str += L"\r\n\r\n";
        return str;
    }
    return LoadStringDx(IDS_INVALIDDATA);
}

MString
ResToText::DoGroupCursor(const EntryBase& entry)
{
    MStringW str;

    if (m_bHumanReadable)
    {
        str += DumpGroupCursorInfo(entry.m_data);
        str += L"\r\n";
    }

    // LANGUAGE ..., ...
    str += GetLanguageStatement(entry.m_lang);

    str += DumpName(entry.m_type, entry.m_name);
    str += L" CURSOR \"";
    str += GetEntryFileName(entry);
    str += L"\"\r\n\r\n";

    return str;
}

MString
ResToText::DoGroupIcon(const EntryBase& entry)
{
    MStringW str;

    if (m_bHumanReadable)
    {
        str += DumpGroupIconInfo(entry.m_data);
        str += L"\r\n";
    }

    // LANGUAGE ..., ...
    str += GetLanguageStatement(entry.m_lang);

    str += DumpName(entry.m_type, entry.m_name);
    str += L" ICON \"";
    str += GetEntryFileName(entry);
    str += L"\"\r\n\r\n";

    return str;
}

MString
ResToText::DoVersion(const EntryBase& entry)
{
    VersionRes ver_res;
    if (ver_res.LoadFromData(entry.m_data))
    {
        MString str = GetLanguageStatement(entry.m_lang);
        str += ver_res.Dump(entry.m_name);
        str += L"\r\n";
        return str;
    }
    return LoadStringDx(IDS_INVALIDDATA);
}

MString
ResToText::DoAniCursor(const EntryBase& entry)
{
    MString str;

    if (m_bHumanReadable)
    {
        str += LoadStringDx(IDS_ANICURSOR);
        str += L"\r\n";
    }

    // LANGUAGE ..., ...
    str += GetLanguageStatement(entry.m_lang);

    str += DumpName(entry.m_type, entry.m_name);
    str += L" ANICURSOR \"";
    str += GetEntryFileName(entry);
    str += L"\"\r\n\r\n";

    return str;
}

MString
ResToText::DoAniIcon(const EntryBase& entry)
{
    MString str;

    if (m_bHumanReadable)
    {
        str += LoadStringDx(IDS_ANIICON);
        str += L"\r\n";
    }

    // LANGUAGE ..., ...
    str += GetLanguageStatement(entry.m_lang);

    str += DumpName(entry.m_type, entry.m_name);
    str += L" ANIICON \"";
    str += GetEntryFileName(entry);
    str += L"\"\r\n\r\n";

    return str;
}

MString
ResToText::DoText(const EntryBase& entry)
{
    MString str;
    if (m_bHumanReadable)
    {
        MTextType type;
        type.nNewLine = MNEWLINE_CRLF;
        if (entry.size())
        {
            str = mstr_from_bin(&entry.m_data[0], entry.m_data.size(), &type);
        }
    }
    else
    {
        str += GetLanguageStatement(entry.m_lang);
        str += DumpName(entry.m_type, entry.m_name);
        str += L" ";
        str += DumpEscapedName(entry.m_type);
        str += L" \"";
        str += GetEntryFileName(entry);
        str += L"\"\r\n\r\n";
    }
    return str;
}

MString
ResToText::DoManifest(const EntryBase& entry)
{
    MString str;
    if (m_bHumanReadable)
    {
        MTextType type;
        type.nNewLine = MNEWLINE_CRLF;
        if (entry.size())
        {
            str = mstr_from_bin(&entry.m_data[0], entry.m_data.size(), &type);
        }
    }
    else
    {
        if (g_settings.bWrapManifest)
        {
            str += L"#ifndef MSVC\r\n";
        }
        str += GetLanguageStatement(entry.m_lang);
        str += DumpName(entry.m_type, entry.m_name);
        str += L" ";
        str += DumpEscapedName(entry.m_type);
        str += L" \"";
        str += GetEntryFileName(entry);
        str += L"\"\r\n";
        if (g_settings.bWrapManifest)
        {
            str += L"#endif\r\n";
        }
        str += L"\r\n";
    }
    return str;
}

MString
ResToText::DoImage(const EntryBase& entry)
{
    MString str;

    if (m_bHumanReadable)
    {
        HBITMAP hbm = NULL;

        MBitmapDx bitmap;
        if (bitmap.CreateFromMemory(&entry[0], entry.size()))
        {
            LONG cx, cy;
            hbm = bitmap.GetHBITMAP(cx, cy);
        }

        str += DumpBitmapInfo(hbm);
        DeleteObject(hbm);

        str += L"\r\n";
    }

    // LANGUAGE ..., ...
    str += GetLanguageStatement(entry.m_lang);

    if (entry.m_type == L"PNG")
    {
        str += DumpName(entry.m_type, entry.m_name);
        str += L" PNG \"";
        str += GetEntryFileName(entry);
        str += L"\"\r\n\r\n";
    }
    else if (entry.m_type == L"GIF")
    {
        str += DumpName(entry.m_type, entry.m_name);
        str += L" GIF \"";
        str += GetEntryFileName(entry);
        str += L"\"\r\n\r\n";
    }
    else if (entry.m_type == L"JPEG")
    {
        str += DumpName(entry.m_type, entry.m_name);
        str += L" JPEG \"";
        str += GetEntryFileName(entry);
        str += L"\"\r\n\r\n";
    }
    else if (entry.m_type == L"JPG")
    {
        str += DumpName(entry.m_type, entry.m_name);
        str += L" JPG \"";
        str += GetEntryFileName(entry);
        str += L"\"\r\n\r\n";
    }
    else if (entry.m_type == L"TIFF")
    {
        str += DumpName(entry.m_type, entry.m_name);
        str += L" TIFF \"";
        str += GetEntryFileName(entry);
        str += L"\"\r\n\r\n";
    }
    else if (entry.m_type == L"TIF")
    {
        str += DumpName(entry.m_type, entry.m_name);
        str += L" TIF \"";
        str += GetEntryFileName(entry);
        str += L"\"\r\n\r\n";
    }
    else if (entry.m_type == L"EMF")
    {
        str += DumpName(entry.m_type, entry.m_name);
        str += L" EMF \"";
        str += GetEntryFileName(entry);
        str += L"\"\r\n\r\n";
    }
    else if (entry.m_type == L"ENHMETAFILE")
    {
        str += DumpName(entry.m_type, entry.m_name);
        str += L" ENHMETAFILE \"";
        str += GetEntryFileName(entry);
        str += L"\"\r\n\r\n";
    }
    else if (entry.m_type == L"ENHMETAPICT")
    {
        str += DumpName(entry.m_type, entry.m_name);
        str += L" ENHMETAPICT \"";
        str += GetEntryFileName(entry);
        str += L"\"\r\n\r\n";
    }
    else if (entry.m_type == L"WMF")
    {
        str += DumpName(entry.m_type, entry.m_name);
        str += L" WMF \"";
        str += GetEntryFileName(entry);
        str += L"\"\r\n\r\n";
    }
    else if (entry.m_type == L"IMAGE")
    {
        if (entry.size() >= 4)
        {
            if (memcmp(&entry[0], "BM", 2) == 0)
            {
                str += DumpName(entry.m_type, entry.m_name);
                str += L" IMAGE \"";
                str += GetEntryFileName(entry);
                str += L"\"\r\n\r\n";
            }
            else if (memcmp(&entry[0], "GIF", 3) == 0)
            {
                str += DumpName(entry.m_type, entry.m_name);
                str += L" IMAGE \"";
                str += GetEntryFileName(entry);
                str += L"\"\r\n\r\n";
            }
            else if (memcmp(&entry[0], "\x89\x50\x4E\x47", 4) == 0)
            {
                str += DumpName(entry.m_type, entry.m_name);
                str += L" IMAGE \"";
                str += GetEntryFileName(entry);
                str += L"\"\r\n\r\n";
            }
            else if (memcmp(&entry[0], "\xFF\xD8", 2) == 0)
            {
                str += DumpName(entry.m_type, entry.m_name);
                str += L" IMAGE \"";
                str += GetEntryFileName(entry);
                str += L"\"\r\n\r\n";
            }
            else if (memcmp(&entry[0], "\x4D\x4D", 2) == 0 ||
                     memcmp(&entry[0], "\x49\x49", 2) == 0)
            {
                str += DumpName(entry.m_type, entry.m_name);
                str += L" IMAGE \"";
                str += GetEntryFileName(entry);
                str += L"\"\r\n\r\n";
            }
        }
    }

    return str;
}

MString
ResToText::DumpEntry(const EntryBase& entry)
{
    if (entry.m_type.m_id)
    {
        switch (entry.m_type.m_id)
        {
        case 1: // RT_CURSOR
            return DoCursor(entry);
        case 2: // RT_BITMAP
            return DoBitmap(entry);
        case 3: // RT_ICON
            return DoIcon(entry);
        case 4: // RT_MENU
            return DoMenu(entry);
        case 5: // RT_DIALOG
            return DoDialog(entry);
        case 6: // RT_STRING
            return DoString(entry);
        case 7: // RT_FONTDIR
            return DoFontDir(entry);
        case 8: // RT_FONT
            return DoFont(entry);
        case 9: // RT_ACCELERATOR
            return DoAccel(entry);
        case 10: // RT_RCDATA
            return DoRCData(entry);
        case 11: // RT_MESSAGETABLE
            return DoMessage(entry);
        case 12: // RT_GROUP_CURSOR
            return DoGroupCursor(entry);
        case 14: // RT_GROUP_ICON
            return DoGroupIcon(entry);
        case 16: // RT_VERSION
            return DoVersion(entry);
        case 17: // RT_DLGINCLUDE
            break;
        case 19: // RT_PLUGPLAY
            break;
        case 20: // RT_VXD
            break;
        case 21: // RT_ANICURSOR
            return DoAniCursor(entry);
        case 22: // RT_ANIICON
            return DoAniIcon(entry);
        case 23: // RT_HTML
            return DoText(entry);
        case 24: // RT_MANIFEST
            return DoManifest(entry);
        case 240: // RT_DLGINIT
            return DoDlgInit(entry);
        case 241: // RT_TOOLBAR
            return DoToolbar(entry);
        default:
            return DoUnknown(entry);
        }
    }
    else
    {
        MString type = entry.m_type.m_str;
        if (type == L"PNG" || type == L"GIF" ||
            type == L"JPEG" || type == L"TIFF" ||
            type == L"JPG" || type == L"TIF" ||
            type == L"EMF" || type == L"ENHMETAFILE" ||
            type == L"ENHMETAPICT" || type == L"WMF" || type == L"IMAGE")
        {
            return DoImage(entry);
        }
        else if (type == L"WAVE")
        {
            return DoWave(entry);
        }
        else if (entry.m_type == L"AVI")
        {
            return DoAVI(entry);
        }
        else if (entry.m_type == L"TYPELIB")
        {
            return DoTypeLib(entry);
        }
    }
    return DoUnknown(entry);
}

MStringW
ResToText::GetResTypeName(const MIdOrString& type) const
{
    if (type.m_id)
    {
        switch (type.m_id)
        {
        case 1: return L"RT_CURSOR";
        case 2: return L"RT_BITMAP";
        case 3: return L"RT_ICON";
        case 4: return L"RT_MENU";
        case 5: return L"RT_DIALOG";
        case 6: return L"RT_STRING";
        case 7: return L"RT_FONTDIR";
        case 8: return L"RT_FONT";
        case 9: return L"RT_ACCELERATOR";
        case 10: return L"RT_RCDATA";
        case 11: return L"RT_MESSAGETABLE";
        case 12: return L"RT_GROUP_CURSOR";
        case 14: return L"RT_GROUP_ICON";
        case 16: return L"RT_VERSION";
        case 17: return L"RT_DLGINCLUDE";
        case 19: return L"RT_PLUGPLAY";
        case 20: return L"RT_VXD";
        case 21: return L"RT_ANICURSOR";
        case 22: return L"RT_ANIICON";
        case 23: return L"RT_HTML";
        case 24: return L"RT_MANIFEST";
        case 240: return L"RT_DLGINIT";
        case 241: return L"RT_TOOLBAR";
        }
    }
    return type.str();
}

MString ResToText::DoWave(const EntryBase& entry)
{
    MString str;

    if (m_bHumanReadable)
    {
        str += LoadStringDx(IDS_WAVESOUND);
        str += L"\r\n";
    }

    // LANGUAGE ..., ...
    str += GetLanguageStatement(entry.m_lang);

    str += DumpName(entry.m_type, entry.m_name);
    str += L" WAVE \"";
    str += GetEntryFileName(entry);
    str += L"\"\r\n\r\n";

    return str;
}

MString ResToText::DoAVI(const EntryBase& entry)
{
    MString str;

    if (m_bHumanReadable)
    {
        str += LoadStringDx(IDS_AVIMOVIE);
        str += L"\r\n";
    }

    // LANGUAGE ..., ...
    str += GetLanguageStatement(entry.m_lang);

    str += DumpName(entry.m_type, entry.m_name);
    str += L" AVI \"";
    str += GetEntryFileName(entry);
    str += L"\"\r\n\r\n";

    return str;
}

MString ResToText::DoDlgInit(const EntryBase& entry)
{
    MStringW str;

    MByteStreamEx stream(entry.m_data);
    DlgInitRes dlginit;
    if (dlginit.LoadFromStream(stream))
    {
        str += GetLanguageStatement(entry.m_lang);
        str += dlginit.Dump(entry.m_name);
    }

    return str;
}

MString ResToText::DoTypeLib(const EntryBase& entry)
{
    MString str;

    if (m_bHumanReadable)
    {
        MString str;
        SendMessageW(m_hwnd, MYWM_TLB_B2T, (WPARAM)&str, (LPARAM)&entry);
        if (str.size())
        {
            return str;
        }
        return LoadStringDx(IDS_INVALIDDATA);
    }
    else
    {
        // LANGUAGE ..., ...
        str += GetLanguageStatement(entry.m_lang);

        str += DumpName(entry.m_type, entry.m_name);
        str += L" TYPELIB \"";
        str += GetEntryFileName(entry);
        str += L"\"\r\n\r\n";
    }

    return str;
}

MString ResToText::DoRCData(const EntryBase& entry)
{
    MString str;

    if (m_bHumanReadable && entry.is_delphi_dfm())
    {
        MString str;
        SendMessageW(m_hwnd, MYWM_DELPHI_DFM_B2T, (WPARAM)&str, (LPARAM)&entry);
        if (str.size())
        {
            return str;
        }
        return LoadStringDx(IDS_INVALIDDATA);
    }
    else
    {
        // LANGUAGE ..., ...
        str += GetLanguageStatement(entry.m_lang);

        str += DumpName(entry.m_type, entry.m_name);
        str += L" RCDATA \"";
        str += GetEntryFileName(entry);
        str += L"\"\r\n\r\n";
    }

    return str;
}

MString ResToText::DoEncodedText(const EntryBase& entry, const MStringW& enc)
{
    MString str;
    if (m_bHumanReadable)
    {
        if (enc == L"ansi")
        {
            std::string str(reinterpret_cast<const char *>(&entry.m_data[0]),
                            entry.m_data.size());
            MAnsiToWide a2w(CP_ACP, str.c_str());
            MStringW wide = a2w.c_str();
            mstr_replace_all(wide, L"\r\n", L"\n");
            mstr_replace_all(wide, L"\n", L"\r\n");
            return wide;
        }
        if (enc == L"wide")
        {
            std::wstring str(reinterpret_cast<const wchar_t *>(&entry.m_data[0]),
                             entry.m_data.size() / sizeof(wchar_t));
            mstr_replace_all(str, L"\r\n", L"\n");
            mstr_replace_all(str, L"\n", L"\r\n");
            return str;
        }
        if (enc == L"utf8" || enc == L"utf8n")
        {
            std::string str(reinterpret_cast<const char *>(&entry.m_data[0]),
                            entry.m_data.size());
            if (str.size() >= 3 && memcmp(str.c_str(), "\xEF\xBB\xBF", 3) == 0)
            {
                str.erase(0, 3);
            }
            MAnsiToWide a2w(CP_UTF8, str.c_str());
            MStringW wide = a2w.c_str();
            mstr_replace_all(wide, L"\r\n", L"\n");
            mstr_replace_all(wide, L"\n", L"\r\n");
            return wide;
        }
        if (enc == L"sjis")
        {
            std::string str((char *)&entry.m_data[0], entry.m_data.size());
            MAnsiToWide a2w(932, str.c_str());
            MStringW wide = a2w.c_str();
            mstr_replace_all(wide, L"\r\n", L"\n");
            mstr_replace_all(wide, L"\n", L"\r\n");
            return wide;
        }
    }
    else
    {
        str += GetLanguageStatement(entry.m_lang);
        str += DumpName(entry.m_type, entry.m_name);
        str += L" ";
        str += DumpEscapedName(entry.m_type);
        str += L" \"";
        str += GetEntryFileName(entry);
        str += L"\"\r\n\r\n";
    }
    return str;
}

MString ResToText::DoUnknown(const EntryBase& entry)
{
    MStringW GetResTypeEncoding(const MIdOrString& type);

    MStringW enc = GetResTypeEncoding(entry.m_type);
    if (enc.size())
    {
        return DoEncodedText(entry, enc);
    }

    MString str;
    if (entry.m_et != ET_LANG)
        return str;

    if (m_bHumanReadable)
    {
        str += LoadStringDx(IDS_UNKNOWNFORMAT);
        str += L"\r\n";
    }

    // LANGUAGE ..., ...
    str += GetLanguageStatement(entry.m_lang);

    str += DumpName(entry.m_type, entry.m_name);
    str += L" ";
    str += entry.m_type.str();
    str += L" \"";
    str += GetEntryFileName(entry);
    str += L"\"\r\n\r\n";

    return str;
}

MString ResToText::DoFont(const EntryBase& entry)
{
    MStringW GetResTypeEncoding(const MIdOrString& type);

    MStringW enc = GetResTypeEncoding(entry.m_type);
    if (enc.size())
    {
        return DoEncodedText(entry, enc);
    }

    MString str;
    if (entry.m_et != ET_LANG)
        return str;

    // LANGUAGE ..., ...
    str += GetLanguageStatement(entry.m_lang);

    str += DumpName(entry.m_type, entry.m_name);
    str += L" FONT \"";
    str += GetEntryFileName(entry);
    str += L"\"\r\n\r\n";

    return str;
}

MString ResToText::DoFontDir(const EntryBase& entry)
{
    MString str;

    if (!m_bHumanReadable)
    {
        return str;
    }

    size_t size = entry.m_data.size();
    const BYTE *pb = (const BYTE *)&entry.m_data[0];

    if (size <= sizeof(WORD))
    {
        return str;
    }

    WORD wCount = *(const WORD *)pb;

    TCHAR szText[64];
    StringCbPrintf(szText, sizeof(szText), TEXT("Count: %u\r\n---\r\n"), wCount);
    str += szText;

#define FONTDIRENTRYSIZE 165
    if (size < sizeof(WORD) + FONTDIRENTRYSIZE * wCount)
    {
        // NOTE: I think windres RT_FONTDIR is broken. Just ignore it.
        return str;
    }

    pb += 2;
    for (UINT i = 0; i < wCount; ++i)
    {
        StringCbPrintf(szText, sizeof(szText), TEXT("Font #%u: Ordinal %u ("),
                       i, *(const WORD *)pb);
        str += szText;

        if (memcmp(&pb[2], "OTTO", 4) == 0)
        {
            // OpenType
            str += TEXT("OpenType");
        }
        else if (memcmp(&pb[2], "\x00\x01\x00\x00", 4) == 0)
        {
            // TrueType
            str += TEXT("TrueType");
        }
        else if (memcmp(&pb[2], "ttcf", 4) == 0)
        {
            // TrueType Collection
            str += TEXT("TrueType Collection");
        }
        else
        {
            // otherwise
            str += TEXT("WinFNT");
        }

        str += TEXT(")\r\n");
        pb += FONTDIRENTRYSIZE;
    }

    return str;
#undef FONTDIRENTRYSIZE
}

MString ResToText::DumpName(const MIdOrString& type, const MIdOrString& name)
{
    MString ret;
    if (name.is_str())
    {
        ret += name.str();
    }
    else
    {
        ret += g_db.GetNameOfResID(g_db.IDTypeFromResType(type), name.m_id);
    }
    return ret;
}

MString ResToText::DumpEscapedName(const MIdOrString& name)
{
    MString ret = name.str(true);
    mstr_escape(ret);
    return ret;
}

//////////////////////////////////////////////////////////////////////////////

HBITMAP
CreateBitmapFromIconDx(HICON hIcon, INT width, INT height, BOOL bCursor)
{
    HBITMAP hbm = Create24BppBitmapDx(width, height);
    if (hbm == NULL)
    {
        assert(0);
        return NULL;
    }
    FillBitmapDx(hbm, GetStockBrush(LTGRAY_BRUSH));

    HDC hDC = CreateCompatibleDC(NULL);
    HGDIOBJ hbmOld = SelectObject(hDC, hbm);
    {
        HBRUSH hbr = GetStockBrush(LTGRAY_BRUSH);
        DrawIconEx(hDC, 0, 0, hIcon, width, height, 0, hbr, DI_NORMAL);
    }
    SelectObject(hDC, hbmOld);
    DeleteDC(hDC);

    return hbm;
}

MStringW
DumpBitmapInfo(HBITMAP hbm)
{
    MStringW ret;
    BITMAP bm;
    if (!GetObjectW(hbm, sizeof(bm), &bm))
        return ret;

    ret = LoadStringPrintfDx(IDS_IMAGEINFO, bm.bmWidth, bm.bmHeight, bm.bmBitsPixel);
    return ret;
}

MStringW
DumpIconInfo(const BITMAP& bm, BOOL bIcon/* = TRUE*/)
{
    MStringW ret;

    ret = LoadStringPrintfDx(IDS_IMAGEINFO, bm.bmWidth, bm.bmHeight, bm.bmBitsPixel);

    return ret;
}

MStringW
DumpGroupIconInfo(const std::vector<BYTE>& data)
{
    MStringW ret;

    ICONDIR dir;
    if (data.size() < sizeof(dir))
        return ret;

    memcpy(&dir, &data[0], sizeof(dir));

    if (dir.idReserved != 0 || dir.idType != 1 || dir.idCount == 0)
    {
        return ret;
    }

    ret += LoadStringPrintfDx(IDS_IMAGECOUNT, dir.idCount);;
    ret += L"-------\r\n";

    const GRPICONDIRENTRY *pEntries;
    pEntries = (const GRPICONDIRENTRY *)&data[sizeof(dir)];

    for (UINT i = 0; i < dir.idCount; ++i)
    {
        WORD Width = pEntries[i].bWidth;
        WORD Height = pEntries[i].bHeight;
        WORD nID = pEntries[i].nID;

        if (Width == 0)
            Width = 256;
        if (Height == 0)
            Height = 256;

        ret += LoadStringPrintfDx(IDS_ICONINFO, 
            i, Width, Height, pEntries[i].wBitCount, nID);
    }

    return ret;
}

MStringW
DumpGroupCursorInfo(const std::vector<BYTE>& data)
{
    MStringW ret;

    ICONDIR dir;
    if (data.size() < sizeof(dir))
        return ret;

    memcpy(&dir, &data[0], sizeof(dir));

    if (dir.idReserved != 0 || dir.idType != RES_CURSOR || dir.idCount == 0)
    {
        return ret;
    }

    ret += LoadStringPrintfDx(IDS_IMAGECOUNT, dir.idCount);
    ret += L"-------\r\n";

    const GRPCURSORDIRENTRY *pEntries;
    pEntries = (const GRPCURSORDIRENTRY *)&data[sizeof(dir)];

    for (UINT i = 0; i < dir.idCount; ++i)
    {
        WORD Width = pEntries[i].wWidth;
        WORD Height = pEntries[i].wHeight / 2;
        WORD BitCount = pEntries[i].wBitCount;
        WORD nID = pEntries[i].nID;
        WORD xHotSpot = 0;
        WORD yHotSpot = 0;

        if (auto entry = g_res.find(ET_LANG, RT_CURSOR, nID))
        {
            auto& cursor_entry = (EntryBase&)*entry;
            LOCALHEADER header;
            if (cursor_entry.size() >= sizeof(header))
            {
                memcpy(&header, &cursor_entry[0], sizeof(header));
                xHotSpot = header.xHotSpot;
                yHotSpot = header.yHotSpot;
            }
        }

        if (Width == 0)
            Width = 256;
        if (Height == 0)
            Height = 256;

        ret += LoadStringPrintfDx(IDS_CURSORINFO, 
            i, Width, Height, BitCount, xHotSpot, yHotSpot, nID);
    }

    return ret;
}

HBITMAP
CreateBitmapFromIconOrPngDx(HWND hwnd, const EntryBase& entry, BITMAP& bm)
{
    HBITMAP hbmIcon;

    if (entry.size() >= 4 &&
        memcmp(&entry[0], "\x89\x50\x4E\x47", 4) == 0)
    {
        MBitmapDx bitmap;
        bitmap.CreateFromMemory(&entry[0], entry.size());
        LONG cx, cy;
        hbmIcon = bitmap.GetHBITMAP32(cx, cy);
    }
    else
    {
        HICON hIcon;
        BITMAP bm;
        hIcon = PackedDIB_CreateIcon(&entry[0], entry.size(), bm, TRUE);
        assert(hIcon);
        hbmIcon = CreateBitmapFromIconDx(hIcon, 
                                         bm.bmWidth, bm.bmHeight, FALSE);
        DestroyIcon(hIcon);
    }

    GetObject(hbmIcon, sizeof(bm), &bm);
    if (bm.bmBitsPixel == 32)
    {
        PremultiplyDx(hbmIcon);
    }

    return hbmIcon;
}

void
DrawBitmapDx(HBITMAP hbm, HBITMAP hbmSrc, INT x, INT y)
{
    BITMAP bmSrc;
    GetObject(hbmSrc, sizeof(bmSrc), &bmSrc);

    HDC hDC = CreateCompatibleDC(NULL);
    HDC hDC2 = CreateCompatibleDC(NULL);
    {
        HGDIOBJ hbmOld = SelectObject(hDC, hbm);
        HGDIOBJ hbm2Old = SelectObject(hDC2, hbmSrc);
        if (bmSrc.bmBitsPixel == 32)
        {
            BLENDFUNCTION bf;
            bf.BlendOp = AC_SRC_OVER;
            bf.BlendFlags = 0;
            bf.SourceConstantAlpha = 0xFF;
            bf.AlphaFormat = AC_SRC_ALPHA;
            AlphaBlend(hDC, x, y, bmSrc.bmWidth, bmSrc.bmHeight, 
                       hDC2, 0, 0, bmSrc.bmWidth, bmSrc.bmHeight, bf);
        }
        else
        {
            BitBlt(hDC, x, y, bmSrc.bmWidth, bmSrc.bmHeight, 
                   hDC2, 0, 0, SRCCOPY);
        }
        SelectObject(hDC, hbm2Old);
        SelectObject(hDC, hbmOld);
    }
    DeleteDC(hDC2);
    DeleteDC(hDC);
}

HBITMAP
CreateBitmapFromIconsDx(HWND hwnd, const EntryBase& entry)
{
    ICONDIR dir;
    if (entry.size() < sizeof(dir))
    {
        assert(0);
        return NULL;
    }

    memcpy(&dir, &entry[0], sizeof(dir));

    if (dir.idReserved != 0 || dir.idType != RES_ICON || dir.idCount == 0)
    {
        assert(0);
        return NULL;
    }

    if (entry.size() < sizeof(dir) + dir.idCount * sizeof(GRPICONDIRENTRY))
    {
        assert(0);
        return FALSE;
    }

    const GRPICONDIRENTRY *pEntries;
    pEntries = (const GRPICONDIRENTRY *)&entry[sizeof(dir)];

    LONG cx = 0, cy = 0;
    for (UINT i = 0; i < dir.idCount; ++i)
    {
        auto e = g_res.find(ET_LANG, RT_ICON, pEntries[i].nID, entry.m_lang);
        if (!e)
        {
            e = g_res.find(ET_LANG, RT_ICON, pEntries[i].nID, BAD_LANG);
        }
        if (!e)
        {
            assert(0);
            return NULL;
        }

        auto& icon_entry = (EntryBase&)*e;

        BITMAP bm;
        HBITMAP hbmIcon = CreateBitmapFromIconOrPngDx(hwnd, icon_entry, bm);

        if (cx < bm.bmWidth)
            cx = bm.bmWidth;
        cy += bm.bmHeight;

        DeleteObject(hbmIcon);
    }

    HBITMAP hbm = Create24BppBitmapDx(cx, cy);
    if (hbm == NULL)
    {
        assert(0);
        return NULL;
    }
    FillBitmapDx(hbm, GetStockBrush(LTGRAY_BRUSH));
    
    BITMAP bm;
    GetObject(hbm, sizeof(bm), &bm);

    INT y = 0;
    for (UINT i = 0; i < dir.idCount; ++i)
    {
        auto e = g_res.find(ET_LANG, RT_ICON, pEntries[i].nID, entry.m_lang);
        if (!e)
        {
            e = g_res.find(ET_LANG, RT_ICON, pEntries[i].nID, BAD_LANG);
        }
        if (!e)
        {
            DeleteObject(hbm);
            return NULL;
        }
        auto icon_entry = (EntryBase&)*e;

        HBITMAP hbmIcon = CreateBitmapFromIconOrPngDx(hwnd, icon_entry, bm);

        DrawBitmapDx(hbm, hbmIcon, 0, y);
        y += bm.bmHeight;
    }

    return hbm;
}

HBITMAP
CreateBitmapFromCursorDx(HWND hwnd, const EntryBase& entry, BITMAP& bm)
{
    HBITMAP hbmCursor;

    HICON hCursor;
    hCursor = PackedDIB_CreateIcon(&entry[0], entry.size(), bm, FALSE);
    assert(hCursor);
    hbmCursor = CreateBitmapFromIconDx(hCursor, bm.bmWidth, bm.bmHeight, TRUE);
    DestroyCursor(hCursor);

    GetObject(hbmCursor, sizeof(bm), &bm);
    assert(hbmCursor);
    return hbmCursor;
}

HBITMAP
CreateBitmapFromCursorsDx(HWND hwnd, const EntryBase& entry)
{
    ICONDIR dir;
    if (entry.size() < sizeof(dir))
    {
        assert(0);
        return NULL;
    }

    memcpy(&dir, &entry[0], sizeof(dir));

    if (dir.idReserved != 0 || dir.idType != RES_CURSOR || dir.idCount == 0)
    {
        assert(0);
        return NULL;
    }

    if (entry.size() < sizeof(dir) + dir.idCount * sizeof(GRPCURSORDIRENTRY))
    {
        assert(0);
        return FALSE;
    }

    const GRPCURSORDIRENTRY *pEntries;
    pEntries = (const GRPCURSORDIRENTRY *)&entry[sizeof(dir)];

    LONG cx = 0, cy = 0;
    for (UINT i = 0; i < dir.idCount; ++i)
    {
        auto e = g_res.find(ET_LANG, RT_CURSOR, pEntries[i].nID, entry.m_lang);
        if (!e)
        {
            e = g_res.find(ET_LANG, RT_CURSOR, pEntries[i].nID, BAD_LANG);
        }
        if (!e)
        {
            assert(0);
            return NULL;
        }
        auto cursor_entry = (EntryBase&)*e;

        BITMAP bm;
        HBITMAP hbmCursor = CreateBitmapFromCursorDx(hwnd, cursor_entry, bm);
        assert(hbmCursor);
        assert(bm.bmWidth);
        assert(bm.bmHeight);

        if (cx < bm.bmWidth)
            cx = bm.bmWidth;
        cy += bm.bmHeight;

        DeleteObject(hbmCursor);
    }

    HBITMAP hbm = Create24BppBitmapDx(cx, cy);
    if (hbm == NULL)
    {
        assert(0);
        return NULL;
    }
    FillBitmapDx(hbm, GetStockBrush(LTGRAY_BRUSH));

    HDC hDC = CreateCompatibleDC(NULL);
    HDC hDC2 = CreateCompatibleDC(NULL);
    HGDIOBJ hbmOld = SelectObject(hDC, hbm);
    {
        INT y = 0;
        for (UINT i = 0; i < dir.idCount; ++i)
        {
            auto e = g_res.find(ET_LANG, RT_CURSOR, pEntries[i].nID, entry.m_lang);
            if (!e)
            {
                e = g_res.find(ET_LANG, RT_CURSOR, pEntries[i].nID, BAD_LANG);
            }
            if (!e)
            {
                assert(0);
                DeleteObject(hbm);
                return NULL;
            }
            auto& cursor_entry = (EntryBase&)*e;

            BITMAP bm;
            HBITMAP hbmCursor = CreateBitmapFromCursorDx(hwnd, cursor_entry, bm);
            assert(hbmCursor);
            assert(bm.bmWidth);
            assert(bm.bmHeight);
            {
                HGDIOBJ hbm2Old = SelectObject(hDC2, hbmCursor);
                BitBlt(hDC, 0, y, bm.bmWidth, bm.bmHeight, hDC2, 0, 0, SRCCOPY);
                SelectObject(hDC2, hbm2Old);
            }
            DeleteObject(hbmCursor);

            y += bm.bmHeight;
        }
    }
    SelectObject(hDC, hbmOld);
    DeleteDC(hDC2);
    DeleteDC(hDC);

    return hbm;
}

```

`src/ResToText.hpp`:

```hpp
// ResToText.hpp --- Dumping Resource
//////////////////////////////////////////////////////////////////////////////
// RisohEditor --- Another free Win32 resource editor
// Copyright (C) 2017-2018 Katayama Hirofumi MZ <katayama.hirofumi.mz@gmail.com>
// 
// This program is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
// 
// This program is distributed in the hope that it will be useful, 
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
// 
// You should have received a copy of the GNU General Public License
// along with this program.  If not, see <http://www.gnu.org/licenses/>.
//////////////////////////////////////////////////////////////////////////////

#pragma once

#include "MWindowBase.hpp"
#include "MString.hpp"
#include "Res.hpp"

#define MYWM_DELPHI_DFM_B2T (WM_USER + 300)
#define MYWM_TLB_B2T (WM_USER + 301)

HBITMAP CreateBitmapFromIconDx(HICON hIcon, INT width, INT height, BOOL bCursor);
MStringW DumpIconInfo(const BITMAP& bm, BOOL bIcon = TRUE);
MStringW DumpBitmapInfo(HBITMAP hbm);
MStringW DumpGroupIconInfo(const std::vector<BYTE>& data);
MStringW DumpGroupCursorInfo(const std::vector<BYTE>& data);

HBITMAP
CreateBitmapFromIconOrPngDx(HWND hwnd, const EntryBase& entry, BITMAP& bm);

HBITMAP
CreateBitmapFromIconsDx(HWND hwnd, const EntryBase& entry);

HBITMAP
CreateBitmapFromCursorDx(HWND hwnd, const EntryBase& entry, BITMAP& bm);

HBITMAP
CreateBitmapFromCursorsDx(HWND hwnd, const EntryBase& entry);

MString GetLanguageStatement(WORD langid, BOOL bOldStyle);

//////////////////////////////////////////////////////////////////////////////

class ResToText
{
public:
    typedef std::vector<BYTE> data_type;

    ResToText() : m_hwnd(NULL), m_hwndDialog(NULL), 
                  m_bHumanReadable(TRUE), m_bNoLanguage(FALSE)
    {
    }

    MString DumpEntry(const EntryBase& entry);
    MStringW GetResTypeName(const MIdOrString& type) const;

public:
    HWND m_hwnd;
    HWND m_hwndDialog;
    BOOL m_bHumanReadable;
    BOOL m_bNoLanguage;
    MString m_strFilePrefix;

    MString GetLanguageStatement(WORD langid)
    {
        if (!m_bNoLanguage)
            return ::GetLanguageStatement(langid, TRUE) + TEXT("\r\n");
        else
            return TEXT("");
    }

    MString DoCursor(const EntryBase& entry);
    MString DoBitmap(const EntryBase& entry);
    MString DoIcon(const EntryBase& entry);
    MString DoMenu(const EntryBase& entry);
    MString DoToolbar(const EntryBase& entry);
    MString DoDialog(const EntryBase& entry);
    MString DoString(const EntryBase& entry);
    MString DoAccel(const EntryBase& entry);
    MString DoGroupCursor(const EntryBase& entry);
    MString DoGroupIcon(const EntryBase& entry);
    MString DoVersion(const EntryBase& entry);
    MString DoAniCursor(const EntryBase& entry);
    MString DoAniIcon(const EntryBase& entry);
    MString DoText(const EntryBase& entry);
    MString DoManifest(const EntryBase& entry);
    MString DoImage(const EntryBase& entry);
    MString DoMessage(const EntryBase& entry);
    MString DoWave(const EntryBase& entry);
    MString DoAVI(const EntryBase& entry);
    MString DoTypeLib(const EntryBase& entry);
    MString DoDlgInit(const EntryBase& entry);
    MString DoRCData(const EntryBase& entry);
    MString DoUnknown(const EntryBase& entry);
    MString DoFont(const EntryBase& entry);
    MString DoFontDir(const EntryBase& entry);
    MString DoEncodedText(const EntryBase& entry, const MStringW& enc);

    MString DumpName(const MIdOrString& type, const MIdOrString& name);
    MString DumpEscapedName(const MIdOrString& name);

    MString GetEntryFileName(const EntryBase& entry);
};

```

`src/RisohEditor.cpp`:

```cpp
// RisohEditor.cpp --- RisohEditor
//////////////////////////////////////////////////////////////////////////////
// RisohEditor --- Another free Win32 resource editor
// Copyright (C) 2017-2021 Katayama Hirofumi MZ <katayama.hirofumi.mz@gmail.com>
//
// This program is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with this program.  If not, see <http://www.gnu.org/licenses/>.
//////////////////////////////////////////////////////////////////////////////

#include "RisohEditor.hpp"
#define LINENUMEDIT_IMPL
#include "LineNumEdit.hpp"
#include "MLangAutoComplete.hpp"
#include "MChooseLangDlg.hpp"
#include "ToolbarRes.hpp"
#ifdef PORTABLE
    #include "MRegKeyPortable.hpp"
#else
    #include "MRegKey.hpp"
#endif

INT g_bNoGuiMode = 0; // No-GUI mode
LPWSTR g_pszLogFile = NULL;

IMPLEMENT_DYNAMIC(MEgaDlg)

INT LogMessageBoxW(HWND hwnd, LPCWSTR text, LPCWSTR title, UINT uType)
{
    if (g_bNoGuiMode)
    {
        if (g_pszLogFile)
        {
            if (FILE *fp = _wfopen(g_pszLogFile, L"a"))
            {
                fprintf(fp, "%ls\n", title);
                fclose(fp);
            }
        }
        return IDYES;
    }
    else
    {
        return ::MessageBoxW(hwnd, text, title, uType);
    }
}

//////////////////////////////////////////////////////////////////////////////
// constants

#define TV_WIDTH        250     // default m_hwndTV width
#define BV_WIDTH        160     // default m_hBmpView width
#define BE_HEIGHT       90      // default m_hHexViewer height
#define CX_STATUS_PART  80      // status bar part width
#define ERROR_LINE_COLOR RGB(255, 191, 191)

#define MYWM_UPDATELANGARROW (WM_USER + 114)
#define MYWM_GETDLGHEADLINES (WM_USER + 250)

MString GetLanguageStatement(WORD langid, BOOL bOldStyle);

// the maximum number of captions to remember
static const DWORD s_nMaxCaptions = 10;

// the maximum number of backup
static const UINT s_nBackupMaxCount = 5;

// contents modified?
static BOOL s_bModified = FALSE;

// UI Language
static DWORD s_ui_lang = GetThreadUILanguage();

void DoSetFileModified(BOOL bModified)
{
    s_bModified = bModified;
}

static HWND s_hMainWnd = NULL;
static INT s_ret = 0;

enum IMPORT_RESULT
{
    IMPORTED,
    IMPORT_CANCELLED,
    IMPORT_FAILED,
    NOT_IMPORTABLE
};

WORD GetMachineOfBinary(LPCWSTR pszExeFile)
{
    WORD wMachine = IMAGE_FILE_MACHINE_UNKNOWN;
    if (FILE *fp = _wfopen(pszExeFile, L"rb"))
    {
        SIZE_T ib = 0;
        IMAGE_DOS_HEADER dos = { 0 };
        fread(&dos, sizeof(dos), 1, fp);
        if (dos.e_magic == IMAGE_DOS_SIGNATURE)
        {
            ib = dos.e_lfanew;
        }
#ifdef _WIN64
        _fseeki64(fp, ib, SEEK_SET);
#else
        fseek(fp, ib, SEEK_SET);
#endif
        IMAGE_NT_HEADERS nt = { 0 };
        fread(&nt, sizeof(nt), 1, fp);
        if (nt.Signature == IMAGE_NT_SIGNATURE)
        {
            auto& file = nt.FileHeader;
            wMachine = file.Machine;
        }
        fclose(fp);
    }
    return wMachine;
}

//////////////////////////////////////////////////////////////////////////////
// global variables

#ifdef USE_GLOBALS
    ConstantsDB g_db;           // constants database
    RisohSettings g_settings;   // settings
    EntrySet g_res;             // the set of resource items
#endif

typedef HRESULT (WINAPI *SETWINDOWTHEME)(HWND, LPCWSTR, LPCWSTR);
static SETWINDOWTHEME s_pSetWindowTheme = NULL;

//////////////////////////////////////////////////////////////////////////////
// useful global functions

BOOL IsFileLockedDx(LPCTSTR pszFileName)
{
    if (!PathFileExistsW(pszFileName))
        return FALSE;

    HANDLE hFile;
    hFile = CreateFileW(pszFileName, GENERIC_WRITE, FILE_SHARE_READ, NULL,
                        OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);
    if (hFile != INVALID_HANDLE_VALUE)
    {
        CloseHandle(hFile);
        return FALSE;
    }

    return TRUE;
}

// "." or ".."
#define IS_DOTS(psz) ((psz)[0] == '.' && ((psz)[1] == '\0' || ((psz)[1] == '.' && (psz)[2] == '\0')))

// delete a directory (a folder)
BOOL DeleteDirectoryDx(LPCTSTR pszDir)
{
    TCHAR szDirOld[MAX_PATH];
    HANDLE hFind;
    WIN32_FIND_DATA find;

    GetCurrentDirectory(MAX_PATH, szDirOld);
    if (!SetCurrentDirectory(pszDir))
        return FALSE;

    hFind = FindFirstFile(TEXT("*"), &find);
    if (hFind != INVALID_HANDLE_VALUE)
    {
        do
        {
            if (!IS_DOTS(find.cFileName))
            {
                if (find.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY)
                {
                    DeleteDirectoryDx(find.cFileName);
                }
                else
                {
                    SetFileAttributes(find.cFileName, FILE_ATTRIBUTE_NORMAL);
                    DeleteFile(find.cFileName);
                }
            }
        } while(FindNextFile(hFind, &find));
        FindClose(hFind);
    }
    SetCurrentDirectory(szDirOld);

    SetFileAttributes(pszDir, FILE_ATTRIBUTE_DIRECTORY);
    return RemoveDirectory(pszDir);
}

// is the path an empty directory?
BOOL IsEmptyDirectoryDx(LPCTSTR pszPath)
{
    WCHAR sz[MAX_PATH];
    StringCchCopy(sz, _countof(sz), pszPath);
    StringCchCat(sz, _countof(sz), L"\\*");

    BOOL bFound = FALSE;
    WIN32_FIND_DATA find;
    HANDLE hFind = FindFirstFile(sz, &find);
    if (hFind != INVALID_HANDLE_VALUE)
    {
        do
        {
            MString str = find.cFileName;
            if (str != L"." && str != L"..")
            {
                bFound = TRUE;
                break;
            }
        } while (FindNextFile(hFind, &find));

        FindClose(hFind);
    }

    return !bFound;
}

// replace some fullwidth characters with halfwidth characters
void ReplaceFullWithHalf(LPWSTR pszText)
{
    MStringW strFullWidth = LoadStringDx(IDS_FULLWIDTH);
    MStringW strHalfWidth = LoadStringDx(IDS_HALFWIDTH);

    for (DWORD i = 0; pszText[i]; ++i)
    {
        size_t k = strFullWidth.find(pszText[i]);
        if (k != MStringW::npos)
        {
            pszText[i] = strHalfWidth[k];
        }
    }
}

// replace some fullwidth characters with halfwidth characters
void ReplaceFullWithHalf(MStringW& strText)
{
    ReplaceFullWithHalf(&strText[0]);
}

// get the path of a shortcut file
BOOL GetPathOfShortcutDx(HWND hwnd, LPCWSTR pszLnkFile, LPWSTR pszPath)
{
    BOOL                bRes = FALSE;
    WIN32_FIND_DATAW    find;
    IShellLinkW*        pShellLink;
    IPersistFile*       pPersistFile;
    HRESULT             hRes;

    // NOTE: CoInitialize/CoInitializeEx call required before this
    pszPath[0] = 0;
    hRes = CoCreateInstance(CLSID_ShellLink, NULL, CLSCTX_INPROC_SERVER,
                            IID_IShellLinkW, (void **)&pShellLink);
    if (SUCCEEDED(hRes))
    {
        hRes = pShellLink->QueryInterface(IID_IPersistFile,
                                          (void **)&pPersistFile);
        if (SUCCEEDED(hRes))
        {
            hRes = pPersistFile->Load(pszLnkFile, STGM_READ);
            if (SUCCEEDED(hRes))
            {
                pShellLink->Resolve(hwnd, SLR_NO_UI | SLR_UPDATE);

                hRes = pShellLink->GetPath(pszPath, MAX_PATH, &find, 0);
                if (SUCCEEDED(hRes) && 0 != pszPath[0])
                {
                    bRes = TRUE;
                }
            }
            pPersistFile->Release();
        }
        pShellLink->Release();
    }
    return bRes;
}

// dump a file
BOOL DumpBinaryFileDx(const WCHAR *filename, LPCVOID pv, DWORD size)
{
    using namespace std;

    FILE *fp = _wfopen(filename, L"wb");        // open

    int n = (int)fwrite(pv, size, 1, fp);   // write

    fflush(fp);
    fclose(fp);     // close the files

    return n == 1;  // success or not
}

// dump data as a text
MStringW DumpBinaryAsText(const std::vector<BYTE>& data)
{
    MStringW ret;
    WCHAR sz[64];
    DWORD addr, size = DWORD(data.size());

    // is it empty?
    if (data.empty())
    {
        return ret;
    }

    ret.reserve(data.size() * 3);   // for speed

    // add the head
    ret +=
        L"+ADDRESS  +0 +1 +2 +3 +4 +5 +6 +7  +8 +9 +A +B +C +D +E +F  0123456789ABCDEF\r\n"
        L"--------  -----------------------  -----------------------  ----------------\r\n";

    // for all the addresses
    bool ending_flag = false;
    for (addr = 0; !ending_flag; ++addr)
    {
        if ((addr & 0xF) != 0)
            continue;

        // add the address
        StringCchPrintfW(sz, _countof(sz), L"%08lX  ", addr);
        ret += sz;

        ending_flag = false;

        // add the data
        for (DWORD i = 0; i < 16; ++i)
        {
            // add a space if the lowest digit was 8
            if (i == 8)
                ret += L' ';

            // add 3 characters
            DWORD offset = addr + i;    // the address to output
            if (offset < size)
            {
                StringCchPrintfW(sz, _countof(sz), L"%02X ", data[offset]);
                ret += sz;
            }
            else
            {
                ret += L"   ";
                ending_flag = true;
            }
        }

        // add the separation space
        ret += L' ';

        // add the characters
        for (DWORD i = 0; i < 16; ++i)
        {
            DWORD offset = addr + i;    // the address to output
            if (offset < size)
            {
                if (data[offset] == 0)
                    ret += L' ';        // the NUL character
                else if (data[offset] < 0x20 || data[offset] > 0x7F)
                    ret += L'.';        // invisible character
                else
                    ret += WCHAR(data[offset]);     // otherwise
            }
            else
            {
                ret += L' ';            // out of range
                ending_flag = true;
            }
        }

        // add a newline
        ret += L"\r\n";
    }

    return ret;     // the result
}

struct AutoDeleteFileW
{
    std::wstring m_file;
    AutoDeleteFileW(const std::wstring& file) : m_file(file)
    {
    }
    ~AutoDeleteFileW()
    {
        ::DeleteFileW(m_file.c_str());
    }
};

//////////////////////////////////////////////////////////////////////////////
// window styles

// store the window style info to a vector
void GetStyleSelect(HWND hLst, std::vector<BYTE>& sel)
{
    for (size_t i = 0; i < sel.size(); ++i)
    {
        sel[i] = (ListBox_GetSel(hLst, (DWORD)i) > 0);
    }
}

// store the window style info to a vector
void GetStyleSelect(std::vector<BYTE>& sel,
                    const ConstantsDB::TableType& table, DWORD dwValue)
{
    sel.resize(table.size());
    for (size_t i = 0; i < table.size(); ++i)
    {
        if (table[i].name.find(L'|') != ConstantsDB::StringType::npos)
            continue;

        if ((dwValue & table[i].mask) == table[i].value)
            sel[i] = TRUE;
        else
            sel[i] = FALSE;
    }
}

// analyse the difference of two window styles
DWORD AnalyseStyleDiff(
    DWORD dwValue, ConstantsDB::TableType& table,
    std::vector<BYTE>& old_sel, std::vector<BYTE>& new_sel)
{
    assert(old_sel.size() == new_sel.size());
    for (size_t i = 0; i < old_sel.size(); ++i)
    {
        if (table[i].name.find(L'|') != ConstantsDB::StringType::npos)
            continue;

        if (old_sel[i] && !new_sel[i])
        {
            dwValue &= ~table[i].mask;
        }
        else if (!old_sel[i] && new_sel[i])
        {
            dwValue &= ~table[i].mask;
            dwValue |= table[i].value;
        }
    }
    return dwValue;
}

// initialize the style list box
void InitStyleListBox(HWND hLst, ConstantsDB::TableType& table)
{
    // clear all the items of listbox
    ListBox_ResetContent(hLst);

    for (auto& table_entry : table)
    {
        if (table_entry.name.find(L'|') != ConstantsDB::StringType::npos)
            continue;

        ListBox_AddString(hLst, table_entry.name.c_str());
    }

    ListBox_SetHorizontalExtent(hLst, 300);
}

//////////////////////////////////////////////////////////////////////////////
// font names

// the callback for InitFontComboBox
static int CALLBACK
EnumFontFamProc(ENUMLOGFONT *lpelf,
                NEWTEXTMETRIC *lpntm,
                INT FontType,
                LPARAM lParam)
{
    HWND hCmb = HWND(lParam);

    // ignore vertical fonts
    if (lpelf->elfLogFont.lfFaceName[0] != TEXT('@'))
        ComboBox_AddString(hCmb, lpelf->elfLogFont.lfFaceName);

    return TRUE;    // continue
}

// initialize the font combobox
void InitFontComboBox(HWND hCmb)
{
    ComboBox_AddString(hCmb, L"MS Shell Dlg");
    ComboBox_AddString(hCmb, L"MS Shell Dlg 2");

    HDC hDC = CreateCompatibleDC(NULL);
    EnumFontFamilies(hDC, NULL, (FONTENUMPROC)EnumFontFamProc, (LPARAM)hCmb);
    DeleteDC(hDC);
}

// character set information
typedef struct CharSetData
{
    BYTE CharSet;
    LPCTSTR name;
} CharSetData;

static const CharSetData s_charset_entries[] =
{
    { ANSI_CHARSET, TEXT("ANSI_CHARSET") },
    { DEFAULT_CHARSET, TEXT("DEFAULT_CHARSET") },
    { SYMBOL_CHARSET, TEXT("SYMBOL_CHARSET") },
    { SHIFTJIS_CHARSET, TEXT("SHIFTJIS_CHARSET") },
    { HANGEUL_CHARSET, TEXT("HANGEUL_CHARSET") },
    { HANGUL_CHARSET, TEXT("HANGUL_CHARSET") },
    { GB2312_CHARSET, TEXT("GB2312_CHARSET") },
    { CHINESEBIG5_CHARSET, TEXT("CHINESEBIG5_CHARSET") },
    { OEM_CHARSET, TEXT("OEM_CHARSET") },
    { JOHAB_CHARSET, TEXT("JOHAB_CHARSET") },
    { HEBREW_CHARSET, TEXT("HEBREW_CHARSET") },
    { ARABIC_CHARSET, TEXT("ARABIC_CHARSET") },
    { GREEK_CHARSET, TEXT("GREEK_CHARSET") },
    { TURKISH_CHARSET, TEXT("TURKISH_CHARSET") },
    { VIETNAMESE_CHARSET, TEXT("VIETNAMESE_CHARSET") },
    { THAI_CHARSET, TEXT("THAI_CHARSET") },
    { EASTEUROPE_CHARSET, TEXT("EASTEUROPE_CHARSET") },
    { RUSSIAN_CHARSET, TEXT("RUSSIAN_CHARSET") },
    { MAC_CHARSET, TEXT("MAC_CHARSET") },
    { BALTIC_CHARSET, TEXT("BALTIC_CHARSET") },
};

// initialize the charset combobox
void InitCharSetComboBox(HWND hCmb, BYTE CharSet)
{
    // clear all the items of combobox
    ComboBox_ResetContent(hCmb);

    // add entries to combobox
    for (auto& entry : s_charset_entries)
    {
        ComboBox_AddString(hCmb, entry.name);
    }

    // set data (charset values)
    for (UINT i = 0; i < _countof(s_charset_entries); ++i)
    {
        ComboBox_SetItemData(hCmb, i, s_charset_entries[i].CharSet);
    }

    // select DEFAULT_CHARSET
    ComboBox_SetCurSel(hCmb, 1);

    for (UINT i = 0; i < _countof(s_charset_entries); ++i)
    {
        if (s_charset_entries[i].CharSet == CharSet)
        {
            // charset was matched
            ComboBox_SetCurSel(hCmb, i);
            break;
        }
    }
}

// get charset value from the charset combobox
BYTE GetCharSetFromComboBox(HWND hCmb)
{
    // get current selection of combobox
    INT i = ComboBox_GetCurSel(hCmb);
    if (i == CB_ERR)    // not selected
        return DEFAULT_CHARSET;     // return the default value

    if (i < INT(_countof(s_charset_entries)))
        return s_charset_entries[i].CharSet;    // return the charset value

    return DEFAULT_CHARSET;     // return the default value
}

//////////////////////////////////////////////////////////////////////////////
// misc.

// initialize the caption combobox
void InitCaptionComboBox(HWND hCmb, LPCTSTR pszCaption)
{
    // clear all the items of combobox
    ComboBox_ResetContent(hCmb);

    // add captions from settings
    for (auto& cap : g_settings.captions)
    {
        ComboBox_AddString(hCmb, cap.c_str());
    }

    // set the text
    ComboBox_SetText(hCmb, pszCaption);
}

// initialize the control class combobox
void InitClassComboBox(HWND hCmb, LPCTSTR pszClass)
{
    // clear all the items of combobox
    ComboBox_ResetContent(hCmb);

    auto table = g_db.GetTable(TEXT("CONTROL.CLASSES"));

    for (auto& table_entry : table)
    {
        INT i = ComboBox_AddString(hCmb, table_entry.name.c_str());
        if (table_entry.name == pszClass)
        {
            ComboBox_SetCurSel(hCmb, i);
        }
    }
}

// initialize the window class combobox
void InitWndClassComboBox(HWND hCmb, LPCTSTR pszWndClass)
{
    // clear all the items of combobox
    ComboBox_ResetContent(hCmb);

    // get the control classes
    auto table = g_db.GetTable(TEXT("CONTROL.CLASSES"));

    for (auto& table_entry : table)
    {
        if (table_entry.value > 2)
            continue;   // not a window class

        // add the window class
        INT i = ComboBox_AddString(hCmb, table_entry.name.c_str());
        if (table_entry.name == pszWndClass)
        {
            // matched. select
            ComboBox_SetCurSel(hCmb, i);
        }
    }
}

// initialize the control ID combobox
void InitCtrlIDComboBox(HWND hCmb)
{
    // add the control IDs
    auto table = g_db.GetTable(TEXT("CTRLID"));
    for (auto& table_entry : table)
    {
        ComboBox_AddString(hCmb, table_entry.name.c_str());
    }

    // get the prefix of Control.ID
    table = g_db.GetTable(L"RESOURCE.ID.PREFIX");
    MStringW prefix = table[IDTYPE_CONTROL].name;
    if (prefix.size())
    {
        // get the resource IDs by the prefix
        table = g_db.GetTableByPrefix(L"RESOURCE.ID", prefix);
        for (auto& table_entry : table)
        {
            // add the resource IDs
            ComboBox_AddString(hCmb, table_entry.name.c_str());
        }
    }

    // get the prefix of Command.ID
    table = g_db.GetTable(L"RESOURCE.ID.PREFIX");
    prefix = table[IDTYPE_COMMAND].name;
    if (prefix.size())
    {
        // get the resource IDs by the prefix
        table = g_db.GetTableByPrefix(L"RESOURCE.ID", prefix);
        for (auto& table_entry : table)
        {
            // add the resource IDs
            ComboBox_AddString(hCmb, table_entry.name.c_str());
        }
    }

    // get the prefix of New.Command.ID
    table = g_db.GetTable(L"RESOURCE.ID.PREFIX");
    prefix = table[IDTYPE_NEWCOMMAND].name;
    if (prefix.size())
    {
        // get the resource IDs by the prefix
        table = g_db.GetTableByPrefix(L"RESOURCE.ID", prefix);
        for (auto& table_entry : table)
        {
            // add the resource IDs
            ComboBox_AddString(hCmb, table_entry.name.c_str());
        }
    }
}

//////////////////////////////////////////////////////////////////////////////
// resources

// switch between a resource ID and an IDTYPE_
void Res_ReplaceResTypeString(MString& str, bool bRevert = false)
{
    if (bRevert)
    {
        // revert
        if (str == L"Icon.ID")
            str = L"RT_GROUP_ICON";
        else if (str == L"Cursor.ID")
            str = L"RT_GROUP_CURSOR";
        else if (str == L"Accel.ID")
            str = L"RT_ACCELERATOR";
        else if (str == L"AniCursor.ID")
            str = L"RT_ANICURSOR";
        else if (str == L"AniIcon.ID")
            str = L"RT_ANIICON";
        else if (str == L"Dialog.ID")
            str = L"RT_DIALOG";
        else if (str == L"Menu.ID")
            str = L"RT_MENU";
        else if (str == L"Bitmap.ID")
            str = L"RT_BITMAP";
        else if (str == L"RCData.ID")
            str = L"RT_RCDATA";
        else if (str == L"Html.ID")
            str = L"RT_HTML";
    }
    else
    {
        // convert
        if (str == L"RT_GROUP_CURSOR")
            str = L"Cursor.ID";
        else if (str == L"RT_GROUP_ICON")
            str = L"Icon.ID";
        else if (str == L"RT_ACCELERATOR")
            str = L"Accel.ID";
        else if (str == L"RT_ANICURSOR")
            str = L"AniCursor.ID";
        else if (str == L"RT_ANIICON")
            str = L"AniIcon.ID";
        else if (str == L"RT_DIALOG")
            str = L"Dialog.ID";
        else if (str == L"RT_MENU")
            str = L"Menu.ID";
        else if (str == L"RT_BITMAP")
            str = L"Bitmap.ID";
        else if (str == L"RT_RCDATA")
            str = L"RCData.ID";
        else if (str == L"RT_HTML")
            str = L"Html.ID";
    }
}

MIdOrString ResourceTypeFromIDType(INT nIDTYPE_)
{
    MIdOrString type;
    switch (nIDTYPE_)
    {
    case IDTYPE_CURSOR:     type = RT_GROUP_CURSOR; break;
    case IDTYPE_BITMAP:     type = RT_BITMAP; break;
    case IDTYPE_MENU:       type = RT_MENU; break;
    case IDTYPE_DIALOG:     type = RT_DIALOG; break;
    case IDTYPE_ACCEL:      type = RT_ACCELERATOR; break;
    case IDTYPE_ICON:       type = RT_GROUP_ICON; break;
    case IDTYPE_ANICURSOR:  type = RT_ANICURSOR; break;
    case IDTYPE_ANIICON:    type = RT_ANIICON; break;
    case IDTYPE_HTML:       type = RT_HTML; break;
    case IDTYPE_RESOURCE:   type.clear(); break;
    case IDTYPE_RCDATA:     type = RT_RCDATA; break;
    default: break;
    }
    return type;
}

MString GetAssoc(const MString& name)
{
    if (name == L"IDC_STATIC")
        return L"Control.ID";

    MString ret;
    MString prefix = name.substr(0, name.find(L'_') + 1);
    if (prefix.empty())
        return L"";

    MIdOrString type;

    std::vector<INT> indexes = GetPrefixIndexes(prefix);
    for (size_t i = 0; i < indexes.size(); ++i)
    {
        auto nIDTYPE_ = IDTYPE_(indexes[i]);
        if (nIDTYPE_ == IDTYPE_UNKNOWN)
            continue;

        auto type = ResourceTypeFromIDType(nIDTYPE_);

        MIdOrString name_or_id;
        WORD wName = (WORD)g_db.GetValue(L"RESOURCE.ID", name);
        if (wName)
            name_or_id = wName;
        else
            name_or_id.m_str = name;

        EntrySet found;
        g_res.search(found, ET_LANG, type, name_or_id);

        if (found.size() && g_db.IsEntityIDType(nIDTYPE_))
        {
            for (auto e : found)    // enumerate the found entries
            {
                MString res_type;
                if (e->m_type.is_int()) // it's an integral name
                {
                    // get resource type name
                    res_type = g_db.GetName(L"RESOURCE", e->m_type.m_id);
                    if (res_type.empty())   // no name
                    {
                        res_type = mstr_dec(e->m_type.m_id);    // store numeric
                    }

                    // convert the resource type
                    Res_ReplaceResTypeString(res_type, false);
                }
                else
                {
                    res_type = e->m_type.str();
                }

                if (res_type.size())
                {
                    // add a resource type tag
                    if (ret.find(L"[" + res_type + L"]") == MString::npos)
                    {
                        ret += L"[";
                        ret += res_type;
                        ret += L"]";
                    }
                }
            }
        }
    }

    if (ret.empty())
    {
        for (size_t i = 0; i < indexes.size(); ++i)
        {
            auto nIDTYPE_ = IDTYPE_(indexes[i]);
            if (nIDTYPE_ == IDTYPE_UNKNOWN)
                continue;

            if (ret.empty())
            {
                ret = g_db.GetName(L"RESOURCE.ID.TYPE", nIDTYPE_);
            }
            else
            {
                ret += TEXT("/");
                ret += g_db.GetName(L"RESOURCE.ID.TYPE", nIDTYPE_);
            }
        }
    }

    // convert tags with slashes
    mstr_replace_all(ret, L"][", L"/");
    mstr_replace_all(ret, L"[", L"");
    mstr_replace_all(ret, L"]", L"");

    return ret;
}

void InitComboBoxPlaceholder(HWND hCmb, UINT nStringID)
{
    HWND hEdit = (HWND)SendMessage(hCmb, CBEM_GETEDITCONTROL, 0, 0);
    if (!hEdit)
    {
        hEdit = FindWindowEx(hCmb, NULL, TEXT("EDIT"), NULL);
        if (!hEdit)
        {
            hCmb = FindWindowEx(hCmb, NULL, TEXT("COMBOBOX"), NULL);
            hEdit = FindWindowEx(hCmb, NULL, TEXT("EDIT"), NULL);
        }
    }

    if (hEdit)
    {
        SendMessage(hEdit, EM_SETCUEBANNER, 0, (LPARAM)LoadStringDx(nStringID));
    }
}

void InitResTypeComboBox(HWND hCmb1, const MIdOrString& type)
{
    InitComboBoxPlaceholder(hCmb1, IDS_INTEGERORIDENTIFIER);

    auto table = g_db.GetTable(L"RESOURCE");
    for (auto& table_entry : table)
    {
        WCHAR sz[MAX_PATH];
        StringCchPrintfW(sz, _countof(sz), L"%s (%lu)",
                         table_entry.name.c_str(), table_entry.value);
        INT k = ComboBox_AddString(hCmb1, sz);
        if (type == WORD(table_entry.value))
        {
            ComboBox_SetCurSel(hCmb1, k);
        }
    }

    table = g_db.GetTable(L"RESOURCE.STRING.TYPE");
    for (auto& table_entry : table)
    {
        INT k = ComboBox_AddString(hCmb1, table_entry.name.c_str());
        if (type == table_entry.name.c_str())
        {
            ComboBox_SetCurSel(hCmb1, k);
        }
    }
}

// initialize the resource name combobox
void InitResNameComboBox(HWND hCmb, const MIdOrString& id, IDTYPE_ nIDTYPE_)
{
    InitComboBoxPlaceholder(hCmb, IDS_INTEGERORIDENTIFIER);

    // set the text of the ID
    SetWindowTextW(hCmb, id.c_str());

    if (g_settings.bHideID)
        return;     // don't use macro IDs

    INT k = -1;     // not matched yet
    MStringW prefix;
    if (nIDTYPE_ != IDTYPE_UNKNOWN)
    {
        // get the prefix from an IDTYPE_ value
        auto table = g_db.GetTable(L"RESOURCE.ID.PREFIX");
        prefix = table[nIDTYPE_].name;
        if (prefix.empty())
            return;     // unable to get

        // get the resource IDs by the prefix
        table = g_db.GetTableByPrefix(L"RESOURCE.ID", prefix);
        for (auto& table_entry : table)
        {
            // add a resource ID to combobox
            INT i = ComboBox_AddString(hCmb, table_entry.name.c_str());
            if (table_entry.value == id.m_id)   // matched
            {
                k = i;  // matched index is k
                ComboBox_SetCurSel(hCmb, i);    // select its
                SetWindowTextW(hCmb, table_entry.name.c_str()); // set the text
            }
        }
    }

    if (k == -1 &&
        nIDTYPE_ != IDTYPE_RESOURCE && g_db.IsEntityIDType(nIDTYPE_))
    {
        // not found

        // get the prefix of Resource.ID
        auto table = g_db.GetTable(L"RESOURCE.ID.PREFIX");
        prefix = table[IDTYPE_RESOURCE].name;

        // get the resource IDs by the prefix
        table = g_db.GetTableByPrefix(L"RESOURCE.ID", prefix);
        for (auto& table_entry : table)
        {
            // add the resource name to combobox
            INT i = ComboBox_AddString(hCmb, table_entry.name.c_str());
            if (table_entry.value == id.m_id)   // matched
            {
                ComboBox_SetCurSel(hCmb, i);    // selected
                SetWindowTextW(hCmb, table_entry.name.c_str());  // set the text
            }
        }
    }
}

// initialize the resource name combobox
void InitResNameComboBox(HWND hCmb, const MIdOrString& id, IDTYPE_ nIDTYPE_1, IDTYPE_ nIDTYPE_2)
{
    InitComboBoxPlaceholder(hCmb, IDS_INTEGERORIDENTIFIER);

    // set the ID text to combobox
    SetWindowTextW(hCmb, id.c_str());

    if (g_settings.bHideID)
        return;     // don't use the macro IDs

    INT k = -1; // not found yet
    MStringW prefix;
    if (nIDTYPE_1 != IDTYPE_UNKNOWN)
    {
        // get the prefix from nIDTYPE_1
        auto table = g_db.GetTable(L"RESOURCE.ID.PREFIX");
        prefix = table[nIDTYPE_1].name;
        if (prefix.empty())
            return;

        // get the resource IDs from the prefix
        table = g_db.GetTableByPrefix(L"RESOURCE.ID", prefix);

        // add the resource IDs
        for (auto& table_entry : table)
        {
            // add an item to combobox
            INT i = ComboBox_AddString(hCmb, table_entry.name.c_str());
            if (table_entry.value == id.m_id)   // matched
            {
                k = i;  // found

                // select it in combobox
                ComboBox_SetCurSel(hCmb, i);

                // set its text to combobox
                SetWindowTextW(hCmb, table_entry.name.c_str());
            }
        }
    }
    if (nIDTYPE_2 != IDTYPE_UNKNOWN)
    {
        // get the prefix from nIDTYPE_2
        auto table = g_db.GetTable(L"RESOURCE.ID.PREFIX");
        prefix = table[nIDTYPE_2].name;
        if (prefix.empty())
            return;

        // get the resource IDs from the prefix
        table = g_db.GetTableByPrefix(L"RESOURCE.ID", prefix);
        for (auto& table_entry : table)
        {
            // add an item to combobox
            INT i = ComboBox_AddString(hCmb, table_entry.name.c_str());
            if (table_entry.value == id.m_id)   // matched
            {
                k = i;  // found

                // select it in combobox
                ComboBox_SetCurSel(hCmb, i);

                // set its text to combobox
                SetWindowTextW(hCmb, table_entry.name.c_str());
            }
        }
    }

    if (k == -1 &&
        nIDTYPE_1 != IDTYPE_RESOURCE && g_db.IsEntityIDType(nIDTYPE_1))
    {
        // not found

        // get the prefix from IDTYPE_RESOURCE
        auto table = g_db.GetTable(L"RESOURCE.ID.PREFIX");
        prefix = table[IDTYPE_RESOURCE].name;

        // get the resource IDs from the prefix
        table = g_db.GetTableByPrefix(L"RESOURCE.ID", prefix);
        for (auto& table_entry : table)
        {
            // add an item to combobox
            INT i = ComboBox_AddString(hCmb, table_entry.name.c_str());
            if (table_entry.value == id.m_id)   // matched
            {
                // select it in combobox
                ComboBox_SetCurSel(hCmb, i);

                // set its text to combobox
                SetWindowTextW(hCmb, table_entry.name.c_str());
            }
        }
    }
}

// check the command ID text
BOOL CheckCommand(MString strCommand)
{
    // trim the string
    mstr_trim(strCommand);

    if (('0' <= strCommand[0] && strCommand[0] <= '9') ||
        strCommand[0] == '-' || strCommand[0] == '+')
    {
        // a numeric command ID
        return TRUE;    // OK
    }

    return g_db.HasResID(strCommand);   // is it resource ID name?
}

void InitConstantComboBox(HWND hCmb)
{
    auto table = g_db.GetWholeTable();

    // add the resource IDs
    for (auto& table_entry : table)
    {
        ComboBox_AddString(hCmb, table_entry.name.c_str());
    }

    for (auto& pair : g_settings.id_map)
    {
        MAnsiToWide wide(CP_ACP, pair.first);

        if (ComboBox_FindStringExact(hCmb, -1, wide.c_str()) != CB_ERR)
            continue;

        ComboBox_AddString(hCmb, wide.c_str());
    }
}

// initialize the resource string ID combobox
void InitStringComboBox(HWND hCmb, const MString& strString)
{
    // set the text to combobox
    SetWindowText(hCmb, strString.c_str());

    if (g_settings.bHideID)
        return;     // don't use macro IDs

    // get the prefix from IDTYPE_STRING
    auto table = g_db.GetTable(L"RESOURCE.ID.PREFIX");
    MStringW prefix = table[IDTYPE_STRING].name;
    if (prefix.empty())
        return;

    // get the resource IDs from the prefix
    table = g_db.GetTableByPrefix(L"RESOURCE.ID", prefix);

    // add the resource IDs
    for (auto& table_entry : table)
    {
        // add an item to combobox
        INT i = ComboBox_AddString(hCmb, table_entry.name.c_str());
        if (table_entry.name == strString)  // matched
        {
            // select it
            ComboBox_SetCurSel(hCmb, i);
        }
    }

    // get the prefix from IDTYPE_PROMPT
    table = g_db.GetTable(L"RESOURCE.ID.PREFIX");
    prefix = table[IDTYPE_PROMPT].name;

    // get the resource IDs from the prefix
    table = g_db.GetTableByPrefix(L"RESOURCE.ID", prefix);

    // add the resource IDs
    for (auto& table_entry : table)
    {
        // add an item to combobox
        INT i = ComboBox_AddString(hCmb, table_entry.name.c_str());
        if (table_entry.name == strString)  // matched
        {
            // select it
            ComboBox_SetCurSel(hCmb, i);
        }
    }
}

// initialize the resource message ID combobox
void InitMessageComboBox(HWND hCmb, const MString& strString)
{
    // set the text to combobox
    SetWindowText(hCmb, strString.c_str());

    if (g_settings.bHideID)
        return;     // don't use macro IDs

    // get the prefix from IDTYPE_MESSAGE
    auto table = g_db.GetTable(L"RESOURCE.ID.PREFIX");
    MStringW prefix = table[IDTYPE_MESSAGE].name;
    if (prefix.empty())
        return;

    // get the resource IDs from the prefix
    table = g_db.GetTableByPrefix(L"RESOURCE.ID", prefix);

    // add the resource IDs
    for (auto& table_entry : table)
    {
        // add an item to combobox
        INT i = ComboBox_AddString(hCmb, table_entry.name.c_str());
        if (table_entry.name == strString)  // matched
        {
            ComboBox_SetCurSel(hCmb, i);    // select it
        }
    }
}

//////////////////////////////////////////////////////////////////////////////
// languages

// structure for language information
struct LANG_ENTRY
{
    WORD LangID;    // language ID
    MStringW str;   // string

    // for sorting
    bool operator<(const LANG_ENTRY& ent) const
    {
        return str < ent.str;
    }
};
std::vector<LANG_ENTRY> g_langs;

static BOOL CALLBACK
EnumResLangProc(HMODULE hModule, LPCTSTR lpszType, LPCTSTR lpszName, WORD wIDLanguage,
                LPARAM lParam)
{
    LPDWORD pvalue = (LPDWORD)lParam;
    if (wIDLanguage == *pvalue)
    {
        *pvalue = 0;
        return FALSE;
    }
    return TRUE;
}

BOOL IsValidUILang(LANGID langid)
{
    DWORD value = langid;
    LPARAM lParam = (LPARAM)&value;
    EnumResourceLanguagesW(NULL, RT_MENU, MAKEINTRESOURCEW(IDR_MAINMENU), EnumResLangProc, lParam);
    return value != langid;
}

MLangAutoComplete::MLangAutoComplete(BOOL bUILanguage)
{
    m_nCurrentElement = 0;
    m_nRefCount = 0;
    m_fBound = FALSE;
    m_pAC = NULL;

    for (auto& lang : g_langs)
    {
        if (bUILanguage && !IsValidUILang(lang.LangID))
            continue;

        push_back(lang.str);
    }
}

// initialize the language combobox
void InitLangComboBox(HWND hCmb3, LANGID langid, BOOL bUILanguage)
{
    InitComboBoxPlaceholder(hCmb3, IDS_INTEGERORIDENTIFIER);

    // for all the elements of g_langs
    for (auto& entry : g_langs)
    {
        if (bUILanguage && !IsValidUILang(entry.LangID))
            continue;

        // build the text
        WCHAR sz[MAX_PATH];
        StringCchPrintfW(sz, _countof(sz), L"%s (%u)", entry.str.c_str(), entry.LangID);

        // search the text
        if (ComboBox_FindStringExact(hCmb3, -1, sz) != CB_ERR)
            continue;   // found

        // add the text as a new item to combobox
        INT k = ComboBox_AddString(hCmb3, sz);
        if (langid == entry.LangID)     // matched
        {
            ComboBox_SetCurSel(hCmb3, k);   // select it
        }
    }

    auto table = g_db.GetTable(L"LANGUAGES");
    for (auto& table_entry : table)
    {
        if (bUILanguage && !IsValidUILang(LANGID(table_entry.value)))
            continue;

        // build the text
        WCHAR sz[MAX_PATH];
        StringCchPrintfW(sz, _countof(sz), L"%s (%lu)", table_entry.name.c_str(), table_entry.value);

        // search the text
        if (ComboBox_FindStringExact(hCmb3, -1, sz) != CB_ERR)
            continue;   // found

        // add the text as a new item to combobox
        ComboBox_AddString(hCmb3, sz);
    }
}

// initialize the language combobox
void InitLangComboBox(HWND hCmb3, LANGID langid)
{
    InitLangComboBox(hCmb3, langid, FALSE);
}

// initialize the language listview
void InitLangListView(HWND hLst1, LPCTSTR pszText)
{
    // delete all the items of listview
    ListView_DeleteAllItems(hLst1);

    WCHAR szText[128];
    if (pszText)
    {
        StringCbCopyW(szText, sizeof(szText), pszText);
        CharUpperW(szText);
    }

    WCHAR sz1[64], sz2[64];
    LV_ITEM item;
    INT iItem = 0;
    for (auto& entry : g_langs)     // for all the items of g_langs
    {
        // build two texts of an entry
        StringCchPrintfW(sz1, _countof(sz1), L"%s", entry.str.c_str());
        StringCchPrintfW(sz2, _countof(sz2), L"%u", entry.LangID);

        if (pszText)
        {
            // filtering by pszText
            MString str = sz1;
            CharUpperW(&str[0]);
            if (str.find(szText) == MString::npos)
            {
                str = sz2;
                CharUpperW(&str[0]);
                if (str.find(szText) == MString::npos)
                    continue;
            }
        }

        // if it exists, don't add it
        LV_FINDINFO find = { LVFI_STRING, sz1 };
        INT iFound = ListView_FindItem(hLst1, -1, &find);
        if (iFound != -1)
            continue;

        // add it
        ZeroMemory(&item, sizeof(item));
        item.iItem = iItem;
        item.mask = LVIF_TEXT;
        item.iSubItem = 0;
        item.pszText = sz1;
        ListView_InsertItem(hLst1, &item);

        item.iSubItem = 1;
        item.pszText = sz2;
        ListView_SetItem(hLst1, &item);

        ++iItem;    // next item index
    }

    auto table = g_db.GetTable(L"LANGUAGES");
    for (auto& table_entry : table)
    {
        // build two texts of an entry
        StringCchPrintfW(sz1, _countof(sz1), L"%s", table_entry.name.c_str());
        StringCchPrintfW(sz2, _countof(sz2), L"%lu", table_entry.value);

        if (pszText)
        {
            // filtering by pszText
            MString str = sz1;
            if (str.find(pszText) == MString::npos)
            {
                str = sz2;
                if (str.find(pszText) == MString::npos)
                    continue;
            }
        }

        // if it exists, don't add it
        LV_FINDINFO find = { LVFI_STRING, sz1 };
        INT iFound = ListView_FindItem(hLst1, -1, &find);
        if (iFound != -1)
            continue;

        // add it
        ZeroMemory(&item, sizeof(item));
        item.iItem = iItem;
        item.mask = LVIF_TEXT;
        item.iSubItem = 0;
        item.pszText = sz1;
        ListView_InsertItem(hLst1, &item);

        item.iSubItem = 1;
        item.pszText = sz2;
        ListView_SetItem(hLst1, &item);

        ++iItem;    // next item index
    }
}

// get the language ID from a text
WORD LangFromText(LPWSTR pszLang)
{
    WORD lang = BAD_LANG;     // not found yet

    // replace the fullwidth characters with halfwidth characters
    ReplaceFullWithHalf(pszLang);

    // trim and store to pszLang and strLang
    MStringW strLang = pszLang;
    mstr_trim(strLang);
    StringCchCopyW(pszLang, MAX_PATH, strLang.c_str());

    do
    {
        if (strLang[0] == 0)
            break;  // it's empty. invalid

        // is it American English?
        if (lstrcmpiW(pszLang, L"en") == 0 ||
            lstrcmpiW(pszLang, L"English") == 0 ||
            lstrcmpiW(pszLang, L"America") == 0 ||
            lstrcmpiW(pszLang, L"American") == 0 ||
            lstrcmpiW(pszLang, L"United States") == 0 ||
            lstrcmpiW(pszLang, L"USA") == 0 ||
            lstrcmpiW(pszLang, L"US") == 0 ||
            lstrcmpiW(pszLang, LoadStringDx(IDS_AMERICA)) == 0 ||
            lstrcmpiW(pszLang, LoadStringDx(IDS_ENGLISH)) == 0)
        {
            // American English
            lang = MAKELANGID(LANG_ENGLISH, SUBLANG_ENGLISH_US);
            break;
        }

        // is it Chinese?
        if (lstrcmpiW(pszLang, L"Chinese") == 0 ||
            lstrcmpiW(pszLang, L"PRC") == 0 ||
            lstrcmpiW(pszLang, L"CHN") == 0 ||
            lstrcmpiW(pszLang, L"CN") == 0 ||
            lstrcmpiW(pszLang, LoadStringDx(IDS_CHINA)) == 0 ||
            lstrcmpiW(pszLang, LoadStringDx(IDS_CHINESE)) == 0)
        {
            // Chinese
            lang = MAKELANGID(LANG_CHINESE, SUBLANG_CHINESE_SIMPLIFIED);
            break;
        }

        // is it Russian?
        if (lstrcmpiW(pszLang, L"Russia") == 0 ||
            lstrcmpiW(pszLang, L"Russian") == 0 ||
            lstrcmpiW(pszLang, L"RUS") == 0 ||
            lstrcmpiW(pszLang, L"RU") == 0 ||
            lstrcmpiW(pszLang, LoadStringDx(IDS_RUSSIA)) == 0 ||
            lstrcmpiW(pszLang, LoadStringDx(IDS_RUSSIAN)) == 0)
        {
            // Russian
            lang = MAKELANGID(LANG_RUSSIAN, SUBLANG_RUSSIAN_RUSSIA);
            break;
        }

        // is it British?
        if (lstrcmpiW(pszLang, L"United Kingdom") == 0 ||
            lstrcmpiW(pszLang, L"Great Britain") == 0 ||
            lstrcmpiW(pszLang, L"British") == 0 ||
            lstrcmpiW(pszLang, L"GBR") == 0 ||
            lstrcmpiW(pszLang, L"GB") == 0 ||
            lstrcmpiW(pszLang, LoadStringDx(IDS_UNITEDKINGDOM)) == 0 ||
            lstrcmpiW(pszLang, LoadStringDx(IDS_GREATBRITAIN)) == 0 ||
            lstrcmpiW(pszLang, LoadStringDx(IDS_BRITISH)) == 0)
        {
            // Russian
            lang = MAKELANGID(LANG_ENGLISH, SUBLANG_ENGLISH_UK);
            break;
        }

        // is it French?
        if (lstrcmpiW(pszLang, L"French") == 0 ||
            lstrcmpiW(pszLang, L"France") == 0 ||
            lstrcmpiW(pszLang, L"FRA") == 0 ||
            lstrcmpiW(pszLang, L"FR") == 0 ||
            lstrcmpiW(pszLang, LoadStringDx(IDS_FRANCE)) == 0 ||
            lstrcmpiW(pszLang, LoadStringDx(IDS_FRENCH)) == 0)
        {
            // French
            lang = MAKELANGID(LANG_FRENCH, SUBLANG_FRENCH);
            break;
        }

        // is it Germany?
        if (lstrcmpiW(pszLang, L"Germany") == 0 ||
            lstrcmpiW(pszLang, L"German") == 0 ||
            lstrcmpiW(pszLang, L"DEU") == 0 ||
            lstrcmpiW(pszLang, L"DE") == 0 ||
            lstrcmpiW(pszLang, LoadStringDx(IDS_GERMANY)) == 0 ||
            lstrcmpiW(pszLang, LoadStringDx(IDS_GERMAN)) == 0)
        {
            // Germany
            lang = MAKELANGID(LANG_GERMAN, SUBLANG_GERMAN);
            break;
        }

        // is it Spanish?
        if (lstrcmpiW(pszLang, L"Spanish") == 0 ||
            lstrcmpiW(pszLang, L"Spain") == 0 ||
            lstrcmpiW(pszLang, L"ESP") == 0 ||
            lstrcmpiW(pszLang, L"ES") == 0 ||
            lstrcmpiW(pszLang, LoadStringDx(IDS_SPANISH)) == 0 ||
            lstrcmpiW(pszLang, LoadStringDx(IDS_SPAIN)) == 0)
        {
            // Spanish
            lang = MAKELANGID(LANG_SPANISH, SUBLANG_SPANISH);
            break;
        }

        // maybe en_US, or jp_JP etc.
        if (INT nValue = g_db.GetValueI(L"LANGUAGES", strLang))
        {
            lang = (WORD)nValue;    // found
            break;
        }

        // maybe en-US, or jp-JP etc.
        {
            MStringW str = strLang;

            // replace '-' with '_'
            auto i = str.find(L'-');
            if (i != MString::npos)
                str[i] = L'_';

            // maybe en_US, or jp_JP etc.
            if (INT nValue = g_db.GetValueI(L"LANGUAGES", str))
            {
                lang = (WORD)nValue;    // found
                break;
            }
        }

        // is it numeric?
        if (mchr_is_digit(strLang[0]))
        {
            // strLang is numeric
            int nValue = mstr_parse_int(pszLang);
            if (nValue < 0 || BAD_LANG <= nValue)
                break;  // invalid

            lang = WORD(nValue);
        }

        if (lang == BAD_LANG)     // not found yet?
        {
            // whole match
            for (auto& entry : g_langs)
            {
                if (lstrcmpiW(entry.str.c_str(), pszLang) == 0) // matched
                {
                    lang = entry.LangID;
                    break;
                }
            }
        }

        if (lang == BAD_LANG)     // not found yet?
        {
            // numeric after parenthesis
            if (WCHAR *pch = wcsrchr(pszLang, L'('))
            {
                ++pch;
                if (mchr_is_digit(*pch))
                {
                    int nValue = mstr_parse_int(pch);
                    if (nValue < 0 || BAD_LANG <= nValue)
                        break;  // invalid

                    lang = WORD(nValue);
                }
            }
        }

        if (lang == BAD_LANG)     // not found yet?
        {
            // partial match
            for (auto& entry : g_langs)
            {
                if (wcsstr(entry.str.c_str(), pszLang) != NULL)
                {
                    lang = entry.LangID;
                    break;
                }
            }
        }

        if (lang == BAD_LANG)     // not found yet?
        {
            // ignore case, partial match
            CharUpperW(&strLang[0]);
            for (auto& entry : g_langs)
            {
                MStringW strEntry = entry.str;
                CharUpperW(&strEntry[0]);

                if (wcsstr(strEntry.c_str(), pszLang) != NULL)
                {
                    lang = entry.LangID;
                    break;
                }
            }
        }
    } while (0);

    return lang;
}

// verify the language combobox
BOOL CheckLangComboBox(HWND hCmb3, WORD& lang, BOOL bUILanguage)
{
    // get the text from combobox
    WCHAR szLang[MAX_PATH];
    GetWindowTextW(hCmb3, szLang, _countof(szLang));

    // get the language ID from texts
    lang = LangFromText(szLang);
    if ((!bUILanguage || IsValidUILang(lang)) && lang != BAD_LANG)
        return TRUE;    // success

    // error
    ComboBox_SetEditSel(hCmb3, 0, -1);
    SetFocus(hCmb3);
    LogMessageBoxW(GetParent(hCmb3), LoadStringDx(IDS_ENTERLANG),
                   NULL, MB_ICONERROR);
    return FALSE;   // failure
}

// verify the language combobox
BOOL CheckLangComboBox(HWND hCmb3, WORD& lang)
{
    return CheckLangComboBox(hCmb3, lang, FALSE);
}

// callback function for MMainWnd::DoLoadLangInfo
static BOOL CALLBACK
EnumLocalesProc(LPWSTR lpLocaleString)
{
    // get the locale ID from string
    LCID lcid = mstr_parse_int(lpLocaleString, false, 16);

    LANG_ENTRY entry;
    entry.LangID = LANGIDFROMLCID(lcid);    // store the language ID

    // get the localized language and country
    WCHAR sz[128] = L"";
    if (lcid == 0)
        return TRUE;    // continue
    if (!GetLocaleInfoW(lcid, LOCALE_SLANGUAGE, sz, _countof(sz)))
        return TRUE;    // continue

    entry.str = sz;     // store the text

    // add it
    g_langs.push_back(entry);

    return TRUE;    // continue
}

// callback function for MMainWnd::DoLoadLangInfo
static BOOL CALLBACK
EnumEngLocalesProc(LPWSTR lpLocaleString)
{
    // get the locale ID from string
    LCID lcid = mstr_parse_int(lpLocaleString, false, 16);

    LANG_ENTRY entry;
    entry.LangID = LANGIDFROMLCID(lcid);    // store the language ID

    // get the language and country in English
    WCHAR sz1[128] = L"", sz2[128] = L"";
    if (lcid == 0)
        return TRUE;    // continue
    if (!GetLocaleInfoW(lcid, LOCALE_SENGLANGUAGE, sz1, _countof(sz1)))
        return TRUE;    // continue
    if (!GetLocaleInfoW(lcid, LOCALE_SENGCOUNTRY, sz2, _countof(sz2)))
        return TRUE;    // continue

    // join them and store it
    entry.str = sz1;
    entry.str += L" (";
    entry.str += sz2;
    entry.str += L")";

    // add it
    g_langs.push_back(entry);

    return TRUE;    // continue
}

// get the text from a language ID
MStringW TextFromLang(WORD lang)
{
    WCHAR sz[128], szLoc[128];

    // get the locale ID
    LCID lcid = MAKELCID(lang, SORT_DEFAULT);
    if (lcid == 0)
    {
        // neutral language
        StringCchPrintfW(sz, _countof(sz), L"%s (0)", LoadStringDx(IDS_NEUTRAL));
    }
    else
    {
        if (GetLocaleInfo(lcid, LOCALE_SLANGUAGE, szLoc, _countof(szLoc)))
        {
            // a valid language
            StringCchPrintfW(sz, _countof(sz), L"%s (%u)", szLoc, lang);
        }
        else
        {
            // invalid or unknown language. just store numeric
            StringCchPrintfW(sz, _countof(sz), L"%u", lang);
        }
    }

    return MStringW(sz);
}

//////////////////////////////////////////////////////////////////////////////
// the specialized toolbar

// buttons info #0
TBBUTTON g_buttons0[] =
{
    { 11, ID_GUIEDIT, TBSTATE_ENABLED, BTNS_BUTTON, {0}, 0, IDS_TOOL_GUIEDIT },
    { 12, ID_TEST, TBSTATE_ENABLED, BTNS_BUTTON, {0}, 0, IDS_TEST },
    { -1, 0, TBSTATE_ENABLED, BTNS_SEP, {0}, 0, 0 },
    { 0, ID_NEW, TBSTATE_ENABLED, BTNS_BUTTON, {0}, 0, IDS_TOOL_NEW },
    { 1, ID_OPEN, TBSTATE_ENABLED, BTNS_BUTTON, {0}, 0, IDS_TOOL_OPEN },
    { 2, ID_SAVE, TBSTATE_ENABLED, BTNS_BUTTON, {0}, 0, IDS_TOOL_SAVE },
    { -1, 0, TBSTATE_ENABLED, BTNS_SEP, {0}, 0, 0 },
    { 3, ID_EXPAND_ALL, TBSTATE_ENABLED, BTNS_BUTTON, {0}, 0, IDS_TOOL_EXPAND },
    { 4, ID_COLLAPSE_ALL, TBSTATE_ENABLED, BTNS_BUTTON, {0}, 0, IDS_TOOL_COLLAPSE },
    { -1, 0, TBSTATE_ENABLED, BTNS_SEP, {0}, 0, 0 },
    { 5, ID_ADDBANG, TBSTATE_ENABLED, BTNS_AUTOSIZE | BTNS_DROPDOWN, {0}, 0, IDS_TOOL_PLUS },
    { 6, ID_DELETERES, TBSTATE_ENABLED, BTNS_BUTTON, {0}, 0, IDS_TOOL_MINUS },
    { 7, ID_EDITLABEL, TBSTATE_ENABLED, BTNS_BUTTON, {0}, 0, IDS_TOOL_CHANGE },
    { 8, ID_CLONE, TBSTATE_ENABLED, BTNS_BUTTON, {0}, 0, IDS_TOOL_CLONE },
    { -1, 0, TBSTATE_ENABLED, BTNS_SEP, {0}, 0, 0 },
    { 13, ID_IMPORT, TBSTATE_ENABLED, BTNS_BUTTON, {0}, 0, IDS_TOOL_IMPORT },
    { 14, ID_EXPORTRES, TBSTATE_ENABLED, BTNS_BUTTON, {0}, 0, IDS_TOOL_EXPORT },
};

// buttons info #1
TBBUTTON g_buttons1[] =
{
    { 12, ID_TEST, TBSTATE_ENABLED, BTNS_BUTTON, {0}, 0, IDS_TEST },
    { -1, 0, TBSTATE_ENABLED, BTNS_SEP, {0}, 0, 0 },
    { 0, ID_NEW, TBSTATE_ENABLED, BTNS_BUTTON, {0}, 0, IDS_TOOL_NEW },
    { 1, ID_OPEN, TBSTATE_ENABLED, BTNS_BUTTON, {0}, 0, IDS_TOOL_OPEN },
    { 2, ID_SAVE, TBSTATE_ENABLED, BTNS_BUTTON, {0}, 0, IDS_TOOL_SAVE },
    { -1, 0, TBSTATE_ENABLED, BTNS_SEP, {0}, 0, 0 },
    { 3, ID_EXPAND_ALL, TBSTATE_ENABLED, BTNS_BUTTON, {0}, 0, IDS_TOOL_EXPAND },
    { 4, ID_COLLAPSE_ALL, TBSTATE_ENABLED, BTNS_BUTTON, {0}, 0, IDS_TOOL_COLLAPSE },
    { -1, 0, TBSTATE_ENABLED, BTNS_SEP, {0}, 0, 0 },
    { 5, ID_ADDBANG, TBSTATE_ENABLED, BTNS_AUTOSIZE | BTNS_DROPDOWN, {0}, 0, IDS_TOOL_PLUS },
    { 6, ID_DELETERES, TBSTATE_ENABLED, BTNS_BUTTON, {0}, 0, IDS_TOOL_MINUS },
    { 7, ID_EDITLABEL, TBSTATE_ENABLED, BTNS_BUTTON, {0}, 0, IDS_TOOL_CHANGE },
    { 8, ID_CLONE, TBSTATE_ENABLED, BTNS_BUTTON, {0}, 0, IDS_TOOL_CLONE },
    { -1, 0, TBSTATE_ENABLED, BTNS_SEP, {0}, 0, 0 },
    { 13, ID_IMPORT, TBSTATE_ENABLED, BTNS_BUTTON, {0}, 0, IDS_TOOL_IMPORT },
    { 14, ID_EXPORTRES, TBSTATE_ENABLED, BTNS_BUTTON, {0}, 0, IDS_TOOL_EXPORT },
};

// buttons info #2
TBBUTTON g_buttons2[] =
{
    { 9, ID_COMPILE, TBSTATE_ENABLED, BTNS_BUTTON, {0}, 0, IDS_TOOL_RECOMPILE },
    { 10, ID_CANCELEDIT, TBSTATE_ENABLED, BTNS_BUTTON, {0}, 0, IDS_TOOL_CANCELEDIT },
    { -1, 0, TBSTATE_ENABLED, BTNS_SEP, {0}, 0, 0 },
    { 0, ID_NEW, TBSTATE_ENABLED, BTNS_BUTTON, {0}, 0, IDS_TOOL_NEW },
    { 1, ID_OPEN, TBSTATE_ENABLED, BTNS_BUTTON, {0}, 0, IDS_TOOL_OPEN },
    { 2, ID_SAVE, TBSTATE_ENABLED, BTNS_BUTTON, {0}, 0, IDS_TOOL_SAVE },
    { -1, 0, TBSTATE_ENABLED, BTNS_SEP, {0}, 0, 0 },
    { 3, ID_EXPAND_ALL, TBSTATE_ENABLED, BTNS_BUTTON, {0}, 0, IDS_TOOL_EXPAND },
    { 4, ID_COLLAPSE_ALL, TBSTATE_ENABLED, BTNS_BUTTON, {0}, 0, IDS_TOOL_COLLAPSE },
    { -1, 0, TBSTATE_ENABLED, BTNS_SEP, {0}, 0, 0 },
    { 5, ID_ADDBANG, TBSTATE_ENABLED, BTNS_AUTOSIZE | BTNS_DROPDOWN, {0}, 0, IDS_TOOL_PLUS },
    { 6, ID_DELETERES, TBSTATE_ENABLED, BTNS_BUTTON, {0}, 0, IDS_TOOL_MINUS },
    { 7, ID_EDITLABEL, TBSTATE_ENABLED, BTNS_BUTTON, {0}, 0, IDS_TOOL_CHANGE },
    { 8, ID_CLONE, TBSTATE_ENABLED, BTNS_BUTTON, {0}, 0, IDS_TOOL_CLONE },
    { -1, 0, TBSTATE_ENABLED, BTNS_SEP, {0}, 0, 0 },
    { 13, ID_IMPORT, TBSTATE_ENABLED, BTNS_BUTTON, {0}, 0, IDS_TOOL_IMPORT },
    { 14, ID_EXPORTRES, TBSTATE_ENABLED, BTNS_BUTTON, {0}, 0, IDS_TOOL_EXPORT },
};

// buttons info #3
TBBUTTON g_buttons3[] =
{
    { 0, ID_NEW, TBSTATE_ENABLED, BTNS_BUTTON, {0}, 0, IDS_TOOL_NEW },
    { 1, ID_OPEN, TBSTATE_ENABLED, BTNS_BUTTON, {0}, 0, IDS_TOOL_OPEN },
    { 2, ID_SAVE, TBSTATE_ENABLED, BTNS_BUTTON, {0}, 0, IDS_TOOL_SAVE },
    { -1, 0, TBSTATE_ENABLED, BTNS_SEP, {0}, 0, 0 },
    { 3, ID_EXPAND_ALL, TBSTATE_ENABLED, BTNS_BUTTON, {0}, 0, IDS_TOOL_EXPAND },
    { 4, ID_COLLAPSE_ALL, TBSTATE_ENABLED, BTNS_BUTTON, {0}, 0, IDS_TOOL_COLLAPSE },
    { -1, 0, TBSTATE_ENABLED, BTNS_SEP, {0}, 0, 0 },
    { 5, ID_ADDBANG, TBSTATE_ENABLED, BTNS_AUTOSIZE | BTNS_DROPDOWN, {0}, 0, IDS_TOOL_PLUS },
    { 6, ID_DELETERES, TBSTATE_ENABLED, BTNS_BUTTON, {0}, 0, IDS_TOOL_MINUS },
    { 7, ID_EDITLABEL, TBSTATE_ENABLED, BTNS_BUTTON, {0}, 0, IDS_TOOL_CHANGE },
    { 8, ID_CLONE, TBSTATE_ENABLED, BTNS_BUTTON, {0}, 0, IDS_TOOL_CLONE },
    { -1, 0, TBSTATE_ENABLED, BTNS_SEP, {0}, 0, 0 },
    { 13, ID_IMPORT, TBSTATE_ENABLED, BTNS_BUTTON, {0}, 0, IDS_TOOL_IMPORT },
    { 14, ID_EXPORTRES, TBSTATE_ENABLED, BTNS_BUTTON, {0}, 0, IDS_TOOL_EXPORT },
};

// buttons info #4
TBBUTTON g_buttons4[] =
{
    { 11, ID_GUIEDIT, TBSTATE_ENABLED, BTNS_BUTTON, {0}, 0, IDS_TOOL_GUIEDIT },
    { -1, 0, TBSTATE_ENABLED, BTNS_SEP, {0}, 0, 0 },
    { 0, ID_NEW, TBSTATE_ENABLED, BTNS_BUTTON, {0}, 0, IDS_TOOL_NEW },
    { 1, ID_OPEN, TBSTATE_ENABLED, BTNS_BUTTON, {0}, 0, IDS_TOOL_OPEN },
    { 2, ID_SAVE, TBSTATE_ENABLED, BTNS_BUTTON, {0}, 0, IDS_TOOL_SAVE },
    { -1, 0, TBSTATE_ENABLED, BTNS_SEP, {0}, 0, 0 },
    { 3, ID_EXPAND_ALL, TBSTATE_ENABLED, BTNS_BUTTON, {0}, 0, IDS_TOOL_EXPAND },
    { 4, ID_COLLAPSE_ALL, TBSTATE_ENABLED, BTNS_BUTTON, {0}, 0, IDS_TOOL_COLLAPSE },
    { -1, 0, TBSTATE_ENABLED, BTNS_SEP, {0}, 0, 0 },
    { 5, ID_ADDBANG, TBSTATE_ENABLED, BTNS_AUTOSIZE | BTNS_DROPDOWN, {0}, 0, IDS_TOOL_PLUS },
    { 6, ID_DELETERES, TBSTATE_ENABLED, BTNS_BUTTON, {0}, 0, IDS_TOOL_MINUS },
    { 7, ID_EDITLABEL, TBSTATE_ENABLED, BTNS_BUTTON, {0}, 0, IDS_TOOL_CHANGE },
    { 8, ID_CLONE, TBSTATE_ENABLED, BTNS_BUTTON, {0}, 0, IDS_TOOL_CLONE },
    { -1, 0, TBSTATE_ENABLED, BTNS_SEP, {0}, 0, 0 },
    { 13, ID_IMPORT, TBSTATE_ENABLED, BTNS_BUTTON, {0}, 0, IDS_TOOL_IMPORT },
    { 14, ID_EXPORTRES, TBSTATE_ENABLED, BTNS_BUTTON, {0}, 0, IDS_TOOL_EXPORT },
};

// store the toolbar strings
VOID ToolBar_StoreStrings(HWND hwnd, INT nCount, TBBUTTON *pButtons)
{
    for (INT i = 0; i < nCount; ++i)
    {
        if (pButtons[i].idCommand == 0 || (pButtons[i].fsStyle & BTNS_SEP))
            continue;   // ignore separators

        // replace the resource string ID with a toolbar string ID
        INT_PTR id = pButtons[i].iString;
        LPWSTR psz = LoadStringDx(INT(id));
        id = SendMessageW(hwnd, TB_ADDSTRING, 0, (LPARAM)psz);
        pButtons[i].iString = id;
    }
}

//////////////////////////////////////////////////////////////////////////////

// verify the resource type combobox
BOOL CheckTypeComboBox(HWND hCmb1, MIdOrString& type)
{
    // get the combobox text
    WCHAR szType[MAX_PATH];
    GetWindowTextW(hCmb1, szType, _countof(szType));

    // replace the fullwidth characters with halfwidth characters
    ReplaceFullWithHalf(szType);

    // trim and store it to str and szType
    MStringW str = szType;
    mstr_trim(str);
    StringCchCopyW(szType, _countof(szType), str.c_str());

    if (szType[0] == 0)  // an empty string
    {
        ComboBox_SetEditSel(hCmb1, 0, -1);  // select all
        SetFocus(hCmb1);    // set focus
        // show error message
        LogMessageBoxW(GetParent(hCmb1), LoadStringDx(IDS_ENTERTYPE),
                       NULL, MB_ICONERROR);
        return FALSE;   // failure
    }
    else if (mchr_is_digit(szType[0]) || szType[0] == L'-' || szType[0] == L'+')
    {
        // numeric type name
        type = WORD(mstr_parse_int(szType));
        if (type == (WORD)0)
        {
            ComboBox_SetEditSel(hCmb1, 0, -1);  // select all
            SetFocus(hCmb1);    // set focus
            // show error message
            LogMessageBoxW(GetParent(hCmb1), LoadStringDx(IDS_ENTERNONZEROTYPE),
                           NULL, MB_ICONERROR);
            return FALSE;   // failure
        }
    }
    else
    {
        MStringW str = szType;
        size_t i = str.rfind(L'('); // ')'
        if (i != MStringW::npos && mchr_is_digit(str[i + 1]))
        {
            // numeric type name after the parenthesis
            type = WORD(mstr_parse_int(&str[i + 1]));
        }
        else
        {
            WORD nRT_ = (WORD)g_db.GetValue(L"RESOURCE", str);
            if (nRT_ != 0)
            {
                type = nRT_;
            }
            else
            {
                // a string type name
                type = szType;
            }
        }
    }

    return TRUE;    // success
}

// verify the resource name combobox
BOOL CheckNameComboBox(HWND hCmb2, MIdOrString& name)
{
    // get the combobox text
    WCHAR szName[MAX_PATH];
    GetWindowTextW(hCmb2, szName, _countof(szName));

    // replace the fullwidth characters with halfwidth characters
    ReplaceFullWithHalf(szName);

    // trim and store it to str and szType
    MStringW str = szName;
    mstr_trim(str);
    StringCchCopyW(szName, _countof(szName), str.c_str());

    if (szName[0] == 0) // an empty string
    {
        ComboBox_SetEditSel(hCmb2, 0, -1);  // select all
        SetFocus(hCmb2);    // set focus
        // show error message
        LogMessageBoxW(GetParent(hCmb2), LoadStringDx(IDS_ENTERNAME),
                       NULL, MB_ICONERROR);
        return FALSE;   // failure
    }
    else if (mchr_is_digit(szName[0]) || szName[0] == L'-' || szName[0] == L'+')
    {
        // a numeric name
        name = WORD(mstr_parse_int(szName));
        if (name == (WORD)0)
        {
            ComboBox_SetEditSel(hCmb2, 0, -1);  // select all
            SetFocus(hCmb2);    // set focus
            // show error message
            LogMessageBoxW(GetParent(hCmb2), LoadStringDx(IDS_ENTERNONZERONAME),
                           NULL, MB_ICONERROR);
            return FALSE;   // failure
        }
    }
    else
    {
        // a non-numeric name
        if (g_db.HasResID(szName))
            name = (WORD)g_db.GetResIDValue(szName);    // a valued name
        else
            name = szName;  // a string name
    }

    return TRUE;    // success
}

// verify the file textbox
BOOL Edt1_CheckFile(HWND hEdt1, MStringW& file)
{
    // get the text from textbox
    WCHAR szFile[MAX_PATH];
    GetWindowTextW(hEdt1, szFile, _countof(szFile));

    // trim and store to str and szFile
    MStringW str = szFile;
    mstr_trim(str);
    StringCchCopyW(szFile, _countof(szFile), str.c_str());

    if (!PathFileExistsW(szFile))    // not exists
        return FALSE;   // failure

    // store
    file = szFile;

    return TRUE;    // success
}

// get the text from a command ID
MStringW GetKeyID(UINT wId)
{
    if (g_settings.bHideID) // don't use the macro IDs
        return mstr_dec_short((SHORT)wId);  // return the numeric ID string

    // convert the numeric ID value to the named ID name
    return g_db.GetNameOfResID(IDTYPE_COMMAND, IDTYPE_NEWCOMMAND, wId);
}

// initialize the virtual key combobox
void Cmb1_InitVirtualKeys(HWND hCmb1)
{
    // clear all the items of combobox
    ComboBox_ResetContent(hCmb1);

    // add items to combobox
    auto table = g_db.GetTable(L"VIRTUALKEYS");
    for (auto& table_entry : table)
    {
        // add an item to combobox
        ComboBox_AddString(hCmb1, table_entry.name.c_str());
    }
}

// verify the virtual key combobox
BOOL Cmb1_CheckKey(HWND hwnd, HWND hCmb1, BOOL bVirtKey, MStringW& str)
{
    BOOL bOK;
    if (bVirtKey)
    {
        // a virtual key
        INT i = ComboBox_FindStringExact(hCmb1, -1, str.c_str());
        if (i == CB_ERR)
        {
            // not a string. is it numeric?
            i = GetDlgItemInt(hwnd, cmb1, &bOK, TRUE);
            if (!bOK)
            {
                return FALSE;   // not a string nor a numeric. invalid
            }
            str = mstr_dec(i);
        }
    }
    else
    {
        // a non-virtual key
        INT i = GetDlgItemInt(hwnd, cmb1, &bOK, TRUE);
        if (bOK)
        {
            // a numeric
            str = mstr_dec(i);
        }
        else
        {
            // not a numeric. is it a string?
            LPCWSTR pch = str.c_str();
            MStringW str2;
            if (!guts_quote(str2, pch) || str2.size() != 1)
            {
                return FALSE;   // invalid
            }
            str = mstr_quote(str2);
        }
    }

    return TRUE;    // success
}

//////////////////////////////////////////////////////////////////////////////
// STRING_ENTRY

// helper function for MAddStrDlg and MModifyStrDlg
BOOL StrDlg_GetEntry(HWND hwnd, STRING_ENTRY& entry)
{
    // get the text from combobox
    // replace the fullwidth characters with halfwidth characters
    MString str = MWindowBase::GetDlgItemText(hwnd, cmb1);
    ReplaceFullWithHalf(str);

    if (('0' <= str[0] && str[0] <= '9') || str[0] == '-' || str[0] == '+')
    {
        // numeric
        LONG n = mstr_parse_int(str.c_str());
        str = mstr_dec_word(WORD(n));
    }
    else if (!g_db.HasResID(str))
    {
        // non-numeric and not resource ID. invalid
        return FALSE;   // failure
    }

    // store the string to entry.StringID
    StringCchCopyW(entry.StringID, _countof(entry.StringID), str.c_str());

    // get the text from EDIT control
    str = MWindowBase::GetDlgItemText(hwnd, edt1);
    //mstr_trim(str);     // trim it

    // unquote if quoted
    if (str[0] == L'"')
    {
        mstr_unquote(str);
    }

    // store the text to entry.StringValue
    StringCchCopyW(entry.StringValue, _countof(entry.StringValue), str.c_str());

    return TRUE;    // success
}

// helper function for MAddStrDlg and MModifyStrDlg
void StrDlg_SetEntry(HWND hwnd, STRING_ENTRY& entry)
{
    // store entry.StringID to combobox
    SetDlgItemTextW(hwnd, cmb1, entry.StringID);

    // store the quoted entry.StringValue to the EDIT control
    MStringW str = entry.StringValue;
    str = mstr_quote(str);
    SetDlgItemTextW(hwnd, edt1, str.c_str());
}

//////////////////////////////////////////////////////////////////////////////
// MESSAGE_ENTRY

// helper function for MAddMsgDlg and MModifyMsgDlg
BOOL MsgDlg_GetEntry(HWND hwnd, MESSAGE_ENTRY& entry)
{
    // get the text from combobox
    // replace the fullwidth characters with halfwidth characters
    MString str = MWindowBase::GetDlgItemText(hwnd, cmb1);
    ReplaceFullWithHalf(str);

    if (('0' <= str[0] && str[0] <= '9') || str[0] == '-' || str[0] == '+')
    {
        // numeric
        LONG n = mstr_parse_int(str.c_str());
        str = mstr_hex(n);      // make it hexidemical
    }
    else if (!g_db.HasResID(str))
    {
        // non-numeric and not resource ID. invalid
        return FALSE;   // failure
    }

    // store the string to entry.MessageID
    StringCchCopyW(entry.MessageID, _countof(entry.MessageID), str.c_str());

    // get the text from EDIT control
    str = MWindowBase::GetDlgItemText(hwnd, edt1);

    // unquote if quoted
    if (str[0] == L'"')
    {
        mstr_unquote(str);
    }

    // store the text to entry.MessageValue
    StringCchCopyW(entry.MessageValue, _countof(entry.MessageValue), str.c_str());

    return TRUE;    // success
}

// helper function for MAddMsgDlg and MModifyMsgDlg
void MsgDlg_SetEntry(HWND hwnd, MESSAGE_ENTRY& entry)
{
    // get the text from combobox
    SetDlgItemTextW(hwnd, cmb1, entry.MessageID);

    // set the quoted entry.MessageValue to the EDIT control
    MStringW str = entry.MessageValue;
    str = mstr_quote(str);
    SetDlgItemTextW(hwnd, edt1, str.c_str());
}

//////////////////////////////////////////////////////////////////////////////
// MMainWnd --- the main window

// the file type
enum FileType
{
    FT_NONE,
    FT_EXECUTABLE,
    FT_RC,
    FT_RES
};

class MMainWnd : public MWindowBase
{
protected:
    INT         m_argc;         // number of command line parameters
    TCHAR **    m_targv;        // command line parameters
    BOOL        m_bLoading;     // loading now?

    // handles
    HINSTANCE   m_hInst;        // the instance handle
    HICON       m_hIcon;        // the icon handle
    HICON       m_hIconSm;      // the small icon handle
    HACCEL      m_hAccel;       // the accelerator handle
    HWND        m_hwndTV;       // the tree control
    HIMAGELIST  m_hImageList;   // the image list for m_hwndTV
    INT         m_nCommandLock; // the lock count of WM_COMMAND message
    HICON       m_hFileIcon;    // the file icon
    HICON       m_hFolderIcon;  // the folder icon
    HFONT       m_hSrcFont;     // the source font
    HFONT       m_hBinFont;     // the binary font
    HWND        m_hToolBar;     // the toolbar window handle
    HWND        m_hStatusBar;   // the status bar handle
    HWND        m_hFindReplaceDlg;  // the find/replace dialog handle
    HIMAGELIST  m_himlTools;        // the image list for the toolbar

    // data and sub-programs
    WCHAR       m_szDataFolder[MAX_PATH];       // the data folder location
    WCHAR       m_szConstantsFile[MAX_PATH];    // the Constants.txt file location
    WCHAR       m_szMCppExe[MAX_PATH];          // the mcpp.exe location
    WCHAR       m_szWindresExe[MAX_PATH];       // the windres.exe location
    WCHAR       m_szUpxExe[MAX_PATH];           // the upx.exe location
    WCHAR       m_szMcdxExe[MAX_PATH];          // the mcdx.exe location
    WCHAR       m_szDFMSC[MAX_PATH];            // the dfmsc.exe location
    WCHAR       m_szOleBow[MAX_PATH];           // the OleBow program location
    WCHAR       m_szMidlWrap[MAX_PATH];         // the midlwrap.bat location
    WCHAR       m_szVCBat[MAX_PATH];            // the vcvarsall.bat location
    WCHAR       m_szIncludeDir[MAX_PATH];       // the include directory
    INT         m_nStatusStringID;

    // file info
    FileType    m_file_type;
    WCHAR       m_szFile[MAX_PATH];             // the file location
    WCHAR       m_szResourceH[MAX_PATH];        // the resource.h file location
    BOOL        m_bUpxCompressed;               // is the real file compressed?

    BOOL UpdateFileInfo(FileType ft, LPCWSTR pszFile, BOOL bCompressed);
    void UpdateTitleBar();

    // selection
    MIdOrString     m_type;
    MIdOrString     m_name;
    WORD            m_lang;

    // classes
    MRadWindow      m_rad_window;               // the RADical window
    MEditCtrl       m_hHexViewer;               // the EDIT control for binary
    HWND            m_hCodeEditor;              // the EDIT control for source
    MBmpView        m_hBmpView;                 // the bitmap view
    MSplitterWnd    m_splitter1;                // 1st splitter window
    MSplitterWnd    m_splitter2;                // 2nd splitter window
    MIDListDlg      m_id_list_dlg;              // the ID List window
    ITEM_SEARCH     m_search;                   // the search options
    MTabCtrl        m_tab;                      // the tab control

    // auto completion
    MLangAutoCompleteEdit   m_auto_comp_edit;
    MLangAutoComplete *     m_pAutoComplete;

public:
    MDropdownArrow  m_arrow;                    // the language drop-down arrow
    MStringW m_commands;
    MStringW m_load_options;
    MStringW m_save_options;

    BOOL ParseCommandLine(HWND hwnd, INT argc, WCHAR **targv);

    // constructor
    MMainWnd(int argc, TCHAR **targv, HINSTANCE hInst) :
        m_argc(argc), m_targv(targv), m_bLoading(FALSE),
        m_hInst(hInst), m_hIcon(NULL), m_hIconSm(NULL), m_hAccel(NULL),
        m_hwndTV(NULL), m_hImageList(NULL), m_nCommandLock(0),
        m_hFileIcon(NULL), m_hFolderIcon(NULL), m_hSrcFont(NULL), m_hBinFont(NULL),
        m_hToolBar(NULL), m_hStatusBar(NULL),
        m_hFindReplaceDlg(NULL), m_himlTools(NULL), m_file_type(FT_NONE)
    {
        m_szDataFolder[0] = 0;
        m_szConstantsFile[0] = 0;
        m_szMCppExe[0] = 0;
        m_szWindresExe[0] = 0;
        m_szUpxExe[0] = 0;
        m_szMcdxExe[0] = 0;
        m_szDFMSC[0] = 0;
        m_szOleBow[0] = 0;
        m_szMidlWrap[0] = 0;
        m_szVCBat[0] = 0;
        m_szIncludeDir[0] = 0;
        m_nStatusStringID = 0;
        m_szFile[0] = 0;
        m_szResourceH[0] = 0;

        m_bUpxCompressed = FALSE;

        m_lang = BAD_LANG;
        m_pAutoComplete = NULL;
    }

    // settings
    void SetDefaultSettings(HWND hwnd);
    BOOL LoadSettings(HWND hwnd);
    BOOL SaveSettings(HWND hwnd);
    void UpdatePrefixDB(HWND hwnd);
    BOOL ReCreateSrcEdit(HWND hwnd);

    virtual void ModifyWndClassDx(WNDCLASSEX& wcx)
    {
        MWindowBase::ModifyWndClassDx(wcx);

        // set a class menu
        wcx.lpszMenuName = MAKEINTRESOURCE(IDR_MAINMENU);

        // change the window icon
        wcx.hIcon = m_hIcon;
        wcx.hIconSm = m_hIconSm;
    }

    virtual LPCTSTR GetWndClassNameDx() const
    {
        // the window class name of the main window
        return TEXT("katahiromz's RisohEditor");
    }

    BOOL StartDx();
    INT_PTR RunDx();
    void DoEvents();
    void DoMsg(MSG& msg);

    virtual LRESULT CALLBACK
    WindowProcDx(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam);

    //////////////////////////////////////////////////////////////////////

    // status bar
    void ChangeStatusText(INT nID)
    {
        ChangeStatusText(LoadStringDx(nID));
    }
    void ChangeStatusText(LPCTSTR pszText)
    {
        SendMessage(m_hStatusBar, SB_SETTEXT, 0, (LPARAM)pszText);
    }

    // utilities
    BOOL CheckDataFolder(VOID);
    INT CheckData(VOID);

    void UpdateMenu();

    enum STV
    {
        STV_RESETTEXTANDMODIFIED,
        STV_RESETTEXT,
        STV_DONTRESET
    };

    void SelectTV(EntryBase *entry, BOOL bDoubleClick, STV stv = STV_RESETTEXTANDMODIFIED);
    void SelectTV(EntryType et, const MIdOrString& type,
                  const MIdOrString& name, WORD lang,
                  BOOL bDoubleClick, STV stv = STV_RESETTEXTANDMODIFIED);

    template <typename T_DIALOG>
    void SelectTV(EntryType et, const T_DIALOG& dialog, BOOL bDoubleClick, STV stv = STV_RESETTEXTANDMODIFIED)
    {
        SelectTV(et, dialog.m_type, dialog.m_name, dialog.m_lang, FALSE, stv);
    }

    BOOL CompileIfNecessary(BOOL bReopen = FALSE);
    BOOL ReCompileOnSelChange(BOOL bReopen = FALSE);
    void SelectString(void);
    void SelectMessage(void);
    BOOL CreateOurToolBar(HWND hwndParent, HIMAGELIST himlTools);
    void UpdateOurToolBarButtons(INT iType);
    void UpdateToolBarStatus();
    bool IsEntryTextEditable(const EntryBase *entry);

    // ID list
    void OnIDList(HWND hwnd);
    void OnIdAssoc(HWND hwnd);
    void OnPredefMacros(HWND hwnd);
    void OnEditLabel(HWND hwnd);
    void OnSetPaths(HWND hwnd);
    void OnShowLangs(HWND hwnd);
    void OnShowHideToolBar(HWND hwnd);

    // show/hide
    void ShowIDList(HWND hwnd, BOOL bShow = TRUE);

    enum SHOW_MODE {
        SHOW_MOVIE, SHOW_CODEONLY, SHOW_CODEANDBMP
    };
    SHOW_MODE m_nShowMode;
    void SetShowMode(SHOW_MODE mode);
    void ShowStatusBar(BOOL bShow = TRUE);
    BOOL ShowLangArrow(BOOL bShow, HTREEITEM hItem = NULL);
    void UpdateLangArrow();
    void PostUpdateLangArrow(HWND hwnd);

    // preview
    VOID HidePreview(STV stv = STV_RESETTEXTANDMODIFIED);
    BOOL Preview(HWND hwnd, const EntryBase *entry, STV stv = STV_RESETTEXTANDMODIFIED);

    // actions
    BOOL DoLoadResH(HWND hwnd, LPCTSTR pszFile);
    void DoLoadLangInfo(VOID);
    BOOL DoLoadFile(HWND hwnd, LPCWSTR pszFileName, DWORD nFilterIndex = 0, BOOL bForceDecompress = FALSE);
    BOOL DoLoadRC(HWND hwnd, LPCWSTR szRCFile, EntrySet& res);
    BOOL DoExtract(const EntryBase *entry, BOOL bExporting);
    BOOL DoExport(LPCWSTR pszRCFile, LPWSTR pszResHFile = NULL);
    BOOL DoExport(LPCWSTR pszRCFile, LPWSTR pszResHFile, const EntrySet& found);
    void DoIDStat(UINT anValues[5]);
    BOOL DoBackupFile(LPCWSTR pszFileName, UINT nCount = 0);
    BOOL DoBackupFolder(LPCWSTR pszFileName, UINT nCount = 0);
    BOOL DoWriteRC(LPCWSTR pszFileName, LPCWSTR pszResH);
    BOOL DoWriteRC(LPCWSTR pszFileName, LPCWSTR pszResH, const EntrySet& found);
    BOOL DoWriteRCLang(MFile& file, ResToText& res2text, WORD lang, const EntrySet& targets);
    BOOL DoWriteRCLangUTF8(MFile& file, ResToText& res2text, WORD lang, const EntrySet& targets);
    BOOL DoWriteRCLangUTF16(MFile& file, ResToText& res2text, WORD lang, const EntrySet& targets);
    BOOL DoWriteResH(LPCWSTR pszResH, LPCWSTR pszRCFile = NULL);
    BOOL DoWriteResHOfExe(LPCWSTR pszExeFile);
    BOOL DoSaveResAs(LPCWSTR pszResFile);
    BOOL DoSaveAs(LPCWSTR pszExeFile);
    BOOL DoSaveAsCompression(LPCWSTR pszExeFile);
    BOOL DoSaveExeAs(LPCWSTR pszExeFile, BOOL bCompression = FALSE);
    BOOL DoSaveInner(LPCWSTR pszExeFile, BOOL bCompression = FALSE);
    BOOL DoSaveFile(HWND hwnd, LPCWSTR pszFile);
    IMPORT_RESULT DoImport(HWND hwnd, LPCWSTR pszFile, LPCWSTR pchDotExt);
    IMPORT_RESULT DoImportRes(HWND hwnd, LPCWSTR pszFile);
    IMPORT_RESULT DoImportRC(HWND hwnd, LPCWSTR pszFile);
    BOOL DoUpxTest(LPCWSTR pszUpx, LPCWSTR pszFile);
    BOOL DoUpxDecompress(LPCWSTR pszUpx, LPCWSTR pszFile);
    BOOL DoUpxCompress(LPCWSTR pszUpx, LPCWSTR pszExeFile);
    void DoRenameEntry(LPWSTR pszText, EntryBase *entry, const MIdOrString& old_name, const MIdOrString& new_name);
    void DoRelangEntry(LPWSTR pszText, EntryBase *entry, WORD old_lang, WORD new_lang);
    void DoRefreshTV(HWND hwnd);
    void DoRefreshIDList(HWND hwnd);
    void DoLangEditAutoComplete(HWND hwnd, HWND hwndEdit);
    void DoLangEditAutoCompleteRelease(HWND hwnd);

    void ReCreateFonts(HWND hwnd);
    void ReSetPaths(HWND hwnd);
    BOOL DoItemSearch(ITEM_SEARCH& search);
    BOOL DoItemSearchBang(HWND hwnd, MItemSearchDlg *pDialog);

    bool DoResLoad(const MStringW& filename, const MStringW& options = L"");
    bool DoResSave(const MStringW& filename, const MStringW& options = L"");

    EGA::arg_t RES_load(const EGA::args_t& args);
    EGA::arg_t RES_save(const EGA::args_t& args);
    EGA::arg_t RES_search(const EGA::args_t& args);
    EGA::arg_t RES_delete(const EGA::args_t& args);
    EGA::arg_t RES_clone_by_name(const EGA::args_t& args);
    EGA::arg_t RES_clone_by_lang(const EGA::args_t& args);
    EGA::arg_t RES_unload_resh(const EGA::args_t& args);
    EGA::arg_t RES_select(const EGA::args_t& args);
    EGA::arg_t RES_get_binary(const EGA::args_t& args);
    EGA::arg_t RES_set_binary(const EGA::args_t& args);
    EGA::arg_t RES_get_text(EGA::arg_t arg0, EGA::arg_t arg1, EGA::arg_t arg2);
    EGA::arg_t RES_set_text(EGA::arg_t arg0, EGA::arg_t arg1, EGA::arg_t arg2, EGA::arg_t arg3);
    EGA::arg_t RES_const(const EGA::args_t& args);
    EGA::arg_t RES_str_get(EGA::arg_t arg0);
    EGA::arg_t RES_str_get(EGA::arg_t arg0, EGA::arg_t arg1);
    EGA::arg_t RES_str_set(EGA::arg_t arg0, EGA::arg_t arg1);
    EGA::arg_t RES_str_set(EGA::arg_t arg0, EGA::arg_t arg1, EGA::arg_t arg2);

    LRESULT CALLBACK TreeViewWndProcDx(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam);

protected:
    // parsing resource IDs
    BOOL CompileParts(MStringA& strOutput, const MIdOrString& type, const MIdOrString& name,
                      WORD lang, const MStringW& strWide, BOOL bReopen = FALSE);
    BOOL CompileStringTable(MStringA& strOutput, const MIdOrString& name, WORD lang, const MStringW& strWide);
    BOOL CompileMessageTable(MStringA& strOutput, const MIdOrString& name, WORD lang, const MStringW& strWide);
    BOOL CompileRCData(MStringA& strOutput, const MIdOrString& name, WORD lang, const MStringW& strWide);
    BOOL CompileTYPELIB(MStringA& strOutput, const MIdOrString& name, WORD lang, const MStringW& strWide);
    BOOL CheckResourceH(HWND hwnd, LPCTSTR pszPath);
    BOOL ParseResH(HWND hwnd, LPCTSTR pszFile, const char *psz, DWORD len);
    BOOL ParseMacros(HWND hwnd, LPCTSTR pszFile, const std::vector<MStringA>& macros, MStringA& str);
    BOOL UnloadResourceH(HWND hwnd);
    void SetErrorMessage(const MStringA& strOutput, BOOL bBox = FALSE);
    MStringW GetMacroDump() const;
    MStringW GetIncludesDump() const;
    MStringW GetIncludesDumpForWindres() const;
    void ReadResHLines(FILE *fp, std::vector<MStringA>& lines);
    void UpdateResHLines(std::vector<MStringA>& lines);

    void JoinLinesByBackslash(std::vector<MStringA>& lines);
    void DeleteIncludeGuard(std::vector<MStringA>& lines);
    void AddAdditionalMacroLines(std::vector<MStringA>& lines);
    void DeleteSpecificMacroLines(std::vector<MStringA>& lines);
    void AddApStudioBlock(std::vector<MStringA>& lines);
    void DeleteApStudioBlock(std::vector<MStringA>& lines);
    void AddHeadComment(std::vector<MStringA>& lines);
    void DeleteHeadComment(std::vector<MStringA>& lines);
    void DoAddRes(HWND hwnd, MAddResDlg& dialog);

    // preview
    void PreviewIcon(HWND hwnd, const EntryBase& entry);
    void PreviewCursor(HWND hwnd, const EntryBase& entry);
    void PreviewGroupIcon(HWND hwnd, const EntryBase& entry);
    void PreviewGroupCursor(HWND hwnd, const EntryBase& entry);
    void PreviewBitmap(HWND hwnd, const EntryBase& entry);
    void PreviewImage(HWND hwnd, const EntryBase& entry);
    void PreviewWAVE(HWND hwnd, const EntryBase& entry);
    void PreviewAVI(HWND hwnd, const EntryBase& entry);
    void PreviewAccel(HWND hwnd, const EntryBase& entry);
    void PreviewMessage(HWND hwnd, const EntryBase& entry);
    void PreviewString(HWND hwnd, const EntryBase& entry);
    void PreviewHtml(HWND hwnd, const EntryBase& entry);
    void PreviewMenu(HWND hwnd, const EntryBase& entry);
    void PreviewToolbar(HWND hwnd, const EntryBase& entry);
    void PreviewVersion(HWND hwnd, const EntryBase& entry);
    void PreviewDialog(HWND hwnd, const EntryBase& entry);
    void PreviewAniIcon(HWND hwnd, const EntryBase& entry, BOOL bIcon);
    void PreviewStringTable(HWND hwnd, const EntryBase& entry);
    void PreviewMessageTable(HWND hwnd, const EntryBase& entry);
    void PreviewRCData(HWND hwnd, const EntryBase& entry);
    void PreviewTypeLib(HWND hwnd, const EntryBase& entry);
    void PreviewDlgInit(HWND hwnd, const EntryBase& entry);
    void PreviewUnknown(HWND hwnd, const EntryBase& entry);

    BOOL OnCreate(HWND hwnd, LPCREATESTRUCT lpCreateStruct);
    void OnActivate(HWND hwnd, UINT state, HWND hwndActDeact, BOOL fMinimized);
    void OnSysColorChange(HWND hwnd);
    void OnSetFocus(HWND hwnd, HWND hwndOldFocus);
    void OnKillFocus(HWND hwnd, HWND hwndNewFocus);
    void OnPlay(HWND hwnd);
    void OnDropFiles(HWND hwnd, HDROP hdrop);
    void OnMove(HWND hwnd, int x, int y);
    void OnSize(HWND hwnd, UINT state, int cx, int cy);
    void OnInitMenu(HWND hwnd, HMENU hMenu);
    void OnContextMenu(HWND hwnd, HWND hwndContext, UINT xPos, UINT yPos);
    void OnCommand(HWND hwnd, int id, HWND hwndCtl, UINT codeNotify);
    LRESULT OnNotify(HWND hwnd, int idFrom, NMHDR *pnmhdr);
    void OnClose(HWND hwnd);
    void OnDestroy(HWND hwnd);

    void OnSelChange(HWND hwnd, INT iSelected);
    void OnCancelEdit(HWND hwnd);
    void OnCompile(HWND hwnd);
    void OnGuiEdit(HWND hwnd);
    void OnEdit(HWND hwnd);
    void OnCopyAsNewName(HWND hwnd);
    void OnCopyAsNewLang(HWND hwnd);
    void OnCopyToMultiLang(HWND hwnd);
    void OnItemSearch(HWND hwnd);
    void OnExpandAll(HWND hwnd);
    void OnCollapseAll(HWND hwnd);
    void Expand(HTREEITEM hItem);
    void Collapse(HTREEITEM hItem);
    void OnWordWrap(HWND hwnd);
    void OnSaveAsWithCompression(HWND hwnd);
    void OnClone(HWND hwnd);
    void OnAddBang(HWND hwnd, NMTOOLBAR *pToolBar);
    void OnExtractBang(HWND hwnd);
    void OnGuide(HWND hwnd);
    void OnEncoding(HWND hwnd);
    void OnQueryConstant(HWND hwnd);
    void OnUseBeginEnd(HWND hwnd);
    void OnUseMSMSGTBL(HWND hwnd);
    void OnRefreshAll(HWND hwnd);

    LRESULT OnCompileCheck(HWND hwnd, WPARAM wParam, LPARAM lParam);
    LRESULT OnMoveSizeReport(HWND hwnd, WPARAM wParam, LPARAM lParam);
    LRESULT OnClearStatus(HWND hwnd, WPARAM wParam, LPARAM lParam);
    LRESULT OnReopenRad(HWND hwnd, WPARAM wParam, LPARAM lParam);
    LRESULT OnPostSearch(HWND hwnd, WPARAM wParam, LPARAM lParam);
    LRESULT OnIDJumpBang(HWND hwnd, WPARAM wParam, LPARAM lParam);
    LRESULT OnRadSelChange(HWND hwnd, WPARAM wParam, LPARAM lParam);
    LRESULT OnUpdateDlgRes(HWND hwnd, WPARAM wParam, LPARAM lParam);
    LRESULT OnGetHeadLines(HWND hwnd, WPARAM wParam, LPARAM lParam);
    LRESULT OnDelphiDFMB2T(HWND hwnd, WPARAM wParam, LPARAM lParam);
    LRESULT OnTLB2IDL(HWND hwnd, WPARAM wParam, LPARAM lParam);
    LRESULT OnIDL2TLB(HWND hwnd, WPARAM wParam, LPARAM lParam);
    void OnIDJumpBang2(HWND hwnd, const MString& name, MString& strType);
    LRESULT OnItemSearchBang(HWND hwnd, WPARAM wParam, LPARAM lParam);
    LRESULT OnComplement(HWND hwnd, WPARAM wParam, LPARAM lParam);
    BOOL DoInnerSearch(HWND hwnd);
    LRESULT OnUpdateLangArrow(HWND hwnd, WPARAM wParam, LPARAM lParam);
    LRESULT OnRadDblClick(HWND hwnd, WPARAM wParam, LPARAM lParam);

    void OnAddBitmap(HWND hwnd);
    void OnAddCursor(HWND hwnd);
    void OnAddDialog(HWND hwnd);
    void OnAddIcon(HWND hwnd);
    void OnAddMenu(HWND hwnd);
    void OnAddToolbar(HWND hwnd);
    void OnAddRes(HWND hwnd);
    void OnAddVerInfo(HWND hwnd);
    void OnAddManifest(HWND hwnd);
    void OnAddStringTable(HWND hwnd);
    void OnAddMessageTable(HWND hwnd);
    void OnAddHtml(HWND hwnd);
    void OnAddAccel(HWND hwnd);
    void OnDeleteRes(HWND hwnd);
    void OnExtractBin(HWND hwnd);
    void OnExportRes(HWND hwnd);
    void OnCheckUpdate(HWND hwnd);
    void OnDfmSettings(HWND hwnd);

    void OnExtractRC(HWND hwnd);
    void OnExtractDFM(HWND hwnd);
    void OnExtractTLB(HWND hwnd);
    void OnExtractBitmap(HWND hwnd);
    void OnExtractCursor(HWND hwnd);
    void OnExtractIcon(HWND hwnd);
    void OnReplaceBin(HWND hwnd);
    void OnReplaceBitmap(HWND hwnd);
    void OnReplaceCursor(HWND hwnd);
    void OnReplaceIcon(HWND hwnd);
    void OnUpdateResHBang(HWND hwnd);

    BOOL DoQuerySaveChange(HWND hwnd);

    void OnNew(HWND hwnd);
    void OnOpen(HWND hwnd);
    BOOL OnSave(HWND hwnd);
    BOOL OnSaveAs(HWND hwnd);
    void OnEga(HWND hwnd, LPCWSTR file = NULL);
    void OnEgaProgram(HWND hwnd);
    void OnImport(HWND hwnd);
    void OnLoadResH(HWND hwnd);
    void OnLoadResHBang(HWND hwnd);
    void OnLoadWCLib(HWND hwnd);
    void OnExport(HWND hwnd);
    void OnFonts(HWND hwnd);
    void OnAbout(HWND hwnd);
    void OnConfig(HWND hwnd);
    void OnOpenLocalFile(HWND hwnd, LPCWSTR filename);
    void OnDebugTreeNode(HWND hwnd);
    void OnAdviceResH(HWND hwnd);
    void OnUnloadResH(HWND hwnd);
    void OnHideIDMacros(HWND hwnd);
    void OnUseIDC_STATIC(HWND hwnd);
    void OnTest(HWND hwnd);
    void OnDialogFontSubst(HWND hwnd);
    void OnHelp(HWND hwnd);
    void OnNextPane(HWND hwnd, BOOL bNext);

    // find/replace
    void OnFind(HWND hwnd);
    BOOL OnFindNext(HWND hwnd);
    BOOL OnFindPrev(HWND hwnd);

protected:
    MString GetLanguageStatement(WORD langid)
    {
        return ::GetLanguageStatement(langid, TRUE) + L"\r\n";
    }

    void UpdateNames(BOOL bModified = TRUE);
    void UpdateEntryName(EntryBase *e, LPWSTR pszText = NULL);
    void UpdateEntryLang(EntryBase *e, LPWSTR pszText = NULL);

    std::wstring GetRisohEditorVersion() const;
    std::wstring ParseVersionFile(LPCWSTR pszFile, std::wstring& url) const;
};

//////////////////////////////////////////////////////////////////////////////
// MMainWnd out-of-line functions

// WM_SYSCOLORCHANGE: system color settings was changed
void MMainWnd::OnSysColorChange(HWND hwnd)
{
    // notify the main window children
    m_splitter1.SendMessageDx(WM_SYSCOLORCHANGE);
    m_splitter2.SendMessageDx(WM_SYSCOLORCHANGE);
    m_rad_window.SendMessageDx(WM_SYSCOLORCHANGE);
}

// WM_SETFOCUS
void MMainWnd::OnSetFocus(HWND hwnd, HWND hwndOldFocus)
{
    m_arrow.ShowDropDownList(m_arrow, FALSE);
}

// WM_KILLFOCUS
void MMainWnd::OnKillFocus(HWND hwnd, HWND hwndNewFocus)
{
    m_arrow.ShowDropDownList(m_arrow, FALSE);
}

// check whether it needs compilation
LRESULT MMainWnd::OnCompileCheck(HWND hwnd, WPARAM wParam, LPARAM lParam)
{
    // compile if necessary
    return CompileIfNecessary(TRUE);
}

// reopen the RADical window
LRESULT MMainWnd::OnReopenRad(HWND hwnd, WPARAM wParam, LPARAM lParam)
{
    OnGuiEdit(hwnd);
    return 0;
}

// report the position and size to the status bar
LRESULT MMainWnd::OnMoveSizeReport(HWND hwnd, WPARAM wParam, LPARAM lParam)
{
    // position
    INT x = (SHORT)LOWORD(wParam);
    INT y = (SHORT)HIWORD(wParam);

    // size
    INT cx = (SHORT)LOWORD(lParam);
    INT cy = (SHORT)HIWORD(lParam);

    // set the text to status bar
    ChangeStatusText(LoadStringPrintfDx(IDS_COORD, x, y, cx, cy));

    DoSetFileModified(TRUE);
    return 0;
}

// clear the status bar
LRESULT MMainWnd::OnClearStatus(HWND hwnd, WPARAM wParam, LPARAM lParam)
{
    ChangeStatusText(TEXT(""));
    return 0;
}

// WM_ACTIVATE: if activated, then set focus to m_hwndTV
void MMainWnd::OnActivate(HWND hwnd, UINT state, HWND hwndActDeact, BOOL fMinimized)
{
    static HWND s_hwndOldFocus = NULL;

    if (state == WA_ACTIVE || state == WA_CLICKACTIVE)
    {
        if (s_hwndOldFocus)
            SetFocus(s_hwndOldFocus);
        else
            SetFocus(m_hwndTV);
    }

    if (state == WA_INACTIVE)
    {
        s_hwndOldFocus = GetFocus();
    }

    // default processing
    FORWARD_WM_ACTIVATE(hwnd, state, hwndActDeact, fMinimized, CallWindowProcDx);
}

// update the menu for recently used files
void MMainWnd::UpdateMenu()
{
    // get 'File' menu
    HMENU hMenu = GetMenu(m_hwnd);
    HMENU hFileMenu = GetSubMenu(hMenu, 0);

    // get Most Recently Used menu from 'File' menu
    HMENU hMruMenu = GetSubMenu(hFileMenu, GetMenuItemCount(hFileMenu) - 3);
    assert(hMruMenu);

    // delete all the menu items from MRU menu
    while (DeleteMenu(hMruMenu, 0, MF_BYPOSITION))
        ;

    TCHAR szText[MAX_PATH * 2];
    static const TCHAR szPrefix[] = TEXT("123456789ABCDEF0");

    // add the MRU menu items to the MRU menu
    INT i = 0;
    for (auto& recent : g_settings.vecRecentlyUsed)
    {
        // get the file title
        LPCTSTR pch = _tcsrchr(recent.c_str(), TEXT('\\'));
        if (pch == NULL)
            pch = _tcsrchr(recent.c_str(), TEXT('/'));
        if (pch == NULL)
            pch = recent.c_str();
        else
            ++pch;

        // build the text
        StringCchPrintf(szText, _countof(szText), TEXT("&%c  %s"), szPrefix[i], pch);

        // insert an item to the MRU menu
        InsertMenu(hMruMenu, i, MF_BYPOSITION | MF_STRING, ID_MRUFILE0 + i, szText);

        ++i;    // increment the index
    }

    if (g_settings.vecRecentlyUsed.empty())
    {
        // set the "(none)" item if empty
        InsertMenu(hMruMenu, 0, MF_BYPOSITION | MF_STRING | MF_GRAYED, -1, LoadStringDx(IDS_NONE));
    }
}

void MMainWnd::OnExtractDFM(HWND hwnd)
{
    // compile if necessary
    if (!CompileIfNecessary(FALSE))
        return;

    // get the selected language entry
    auto entry = g_res.get_lang_entry();
    if (!entry)
        return;

    WCHAR szFile[MAX_PATH] = L"";
    ResToText res2text;
    MString strFile = res2text.GetEntryFileName(*entry);
    if (strFile.size())
    {
        StringCbCopyW(szFile, sizeof(szFile), strFile.c_str());
    }

    // initialize OPENFILENAME structure
    OPENFILENAMEW ofn = { OPENFILENAME_SIZE_VERSION_400W, hwnd };
    ofn.lpstrFilter = MakeFilterDx(LoadStringDx(IDS_DFMFILTER));
    ofn.lpstrFile = szFile;
    ofn.nMaxFile = _countof(szFile);
    ofn.lpstrTitle = LoadStringDx(IDS_EXTRACTDFM);
    ofn.Flags = OFN_ENABLESIZING | OFN_EXPLORER | OFN_HIDEREADONLY |
                OFN_PATHMUSTEXIST | OFN_OVERWRITEPROMPT;
    ofn.lpstrDefExt = L"dfm";

    // let the user choose the path
    if (GetSaveFileNameW(&ofn))
    {
        if (lstrcmpiW(PathFindExtensionW(szFile), L".txt") == 0)
        {
            if (FILE *fp = _wfopen(szFile, L"wb"))
            {
                auto ansi = dfm_text_from_binary(m_szDFMSC, entry->ptr(), entry->size(),
                                                 g_settings.nDfmCodePage, g_settings.bDfmRawTextComments);
                fwrite(ansi.c_str(), ansi.size(), 1, fp);
                fflush(fp);
                fclose(fp);
            }
            else
            {
                ErrorBoxDx(IDS_CANTEXTRACTDFM);
            }
        }
        else
        {
            if (!g_res.extract_bin(ofn.lpstrFile, entry))
            {
                ErrorBoxDx(IDS_CANTEXTRACTDFM);
            }
        }
    }
}

void MMainWnd::OnExtractTLB(HWND hwnd)
{
    // compile if necessary
    if (!CompileIfNecessary(FALSE))
        return;

    // get the selected language entry
    auto entry = g_res.get_lang_entry();
    if (!entry)
        return;

    WCHAR szFile[MAX_PATH] = L"";
    ResToText res2text;
    MString strFile = res2text.GetEntryFileName(*entry);
    if (strFile.size())
    {
        StringCbCopyW(szFile, sizeof(szFile), strFile.c_str());
    }

    // initialize OPENFILENAME structure
    OPENFILENAMEW ofn = { OPENFILENAME_SIZE_VERSION_400W, hwnd };
    ofn.lpstrFilter = MakeFilterDx(LoadStringDx(IDS_TLBRESBINFILTER));
    ofn.lpstrFile = szFile;
    ofn.nMaxFile = _countof(szFile);
    ofn.lpstrTitle = LoadStringDx(IDS_EXTRACTTLB);
    ofn.Flags = OFN_ENABLESIZING | OFN_EXPLORER | OFN_HIDEREADONLY |
                OFN_PATHMUSTEXIST | OFN_OVERWRITEPROMPT;
    ofn.lpstrDefExt = L"tlb";

    // let the user choose the path
    if (!GetSaveFileNameW(&ofn))
        return;

    auto dotext = PathFindExtensionW(szFile);
    if (lstrcmpiW(dotext, L".txt") == 0 || lstrcmpiW(dotext, L".idl") == 0)
    {
        std::string ansi;
        ansi = tlb_text_from_binary(m_szOleBow, entry->ptr(), entry->size());
        if (FILE *fp = _wfopen(szFile, L"wb"))
        {
            fwrite(ansi.c_str(), ansi.size(), 1, fp);
            fflush(fp);
            fclose(fp);
        }
        else
        {
            ErrorBoxDx(IDS_CANTEXTRACTTLB);
        }
    }
    else
    {
        if (!g_res.extract_bin(ofn.lpstrFile, entry))
        {
            ErrorBoxDx(IDS_CANTEXTRACTTLB);
        }
    }
}

std::wstring MMainWnd::ParseVersionFile(LPCWSTR pszFile, std::wstring& url) const
{
    std::wstring ret;
    char buf[256];
    if (FILE *fp = _wfopen(pszFile, L"rb"))
    {
        while (fgets(buf, 256, fp))
        {
            std::string str = buf;
            mstr_trim(str, " \t\r\n");
            if (str.find("VERSION:") == 0)
            {
                str = str.substr(8);
                mstr_trim(str, " \t\r\n");
                MAnsiToWide a2w(CP_ACP, str);
                ret = a2w.c_str();
            }
            else if (str.find("URL:") == 0)
            {
                str = str.substr(4);
                mstr_trim(str, " \t\r\n");
                MAnsiToWide a2w(CP_ACP, str);
                url = a2w.c_str();
            }
        }

        fclose(fp);
    }
    return ret;
}

std::wstring MMainWnd::GetRisohEditorVersion() const
{
    WCHAR szFile[MAX_PATH];
    GetModuleFileNameW(NULL, szFile, _countof(szFile));

    DWORD dwHandle;
    DWORD dwSize = GetFileVersionInfoSizeW(szFile, &dwHandle);
    if (!dwSize)
    {
        assert(0);
        return L"";
    }

    std::vector<BYTE> data;
    data.resize(dwSize);
    if (!GetFileVersionInfoW(szFile, dwHandle, dwSize, &data[0]))
    {
        assert(0);
        return L"";
    }

    LPVOID pValue;
    UINT uLen;

    if (!VerQueryValueW(&data[0], L"\\VarFileInfo\\Translation",
                        &pValue, &uLen))
    {
        assert(0);
        return L"";
    }

    WCHAR szValue[16];
    DWORD dwValue = *(LPDWORD)pValue;
    StringCbPrintfW(szValue, sizeof(szValue), L"%04X%04X", LOWORD(dwValue), HIWORD(dwValue));

    std::wstring key = L"\\StringFileInfo\\";
    key += szValue;
    key += L"\\ProductVersion";
    if (!VerQueryValueW(&data[0], key.c_str(), &pValue, &uLen))
    {
        assert(0);
        return L"";
    }

    std::wstring ret = (LPWSTR)pValue;
    return ret;
}

void MMainWnd::OnCheckUpdate(HWND hwnd)
{
    std::wstring local_version = GetRisohEditorVersion();
    if (local_version.empty())
    {
        ErrorBoxDx(IDS_CANTCHECKUPDATE);
        return;
    }

    WCHAR szPath[MAX_PATH], szFile[MAX_PATH];
    GetTempPathW(_countof(szPath), szPath);
    GetTempFileNameW(szPath, L"Upd", 0, szFile);

    std::wstring page = L"https://katahiromz.web.fc2.com/re/version.html";
    DeleteUrlCacheEntryW(page.c_str());
    HRESULT hr = URLDownloadToFileW(NULL, page.c_str(), szFile, 0, NULL);
    if (FAILED(hr))
    {
        ErrorBoxDx(IDS_CANTCHECKUPDATE);
        return;
    }

    std::wstring url;
    std::wstring remote_version = ParseVersionFile(szFile, url);
    DeleteFileW(szFile);
    if (remote_version.empty() || url.empty())
    {
        ErrorBoxDx(IDS_CANTCHECKUPDATE);
        return;
    }

    WCHAR szText[256];
    if (local_version < remote_version)
    {
        StringCbPrintfW(szText, sizeof(szText), LoadStringDx(IDS_THEREISUPDATE),
                        remote_version.c_str());
        if (MsgBoxDx(szText, MB_ICONINFORMATION | MB_YESNOCANCEL) == IDYES)
        {
            ShellExecuteW(hwnd, NULL, url.c_str(), NULL, NULL, SW_SHOWNORMAL);
        }
    }
    else
    {
        MsgBoxDx(IDS_NOUPDATE, MB_ICONINFORMATION);
    }
}

void MMainWnd::OnExportRes(HWND hwnd)
{
    // compile if necessary
    if (!CompileIfNecessary(TRUE))
        return;

    // get the selected entry
    auto e = g_res.get_entry();
    if (!e)
        return;     // not selected

    if (e->is_delphi_dfm())
        return OnExtractDFM(hwnd);

    // initialize OPENFILENAME structure
    WCHAR szFile[MAX_PATH] = L"";
    OPENFILENAMEW ofn = { OPENFILENAME_SIZE_VERSION_400W, hwnd };
    ofn.lpstrFile = szFile;
    ofn.nMaxFile = _countof(szFile);
    ofn.lpstrFilter = MakeFilterDx(LoadStringDx(IDS_RESFILTER));
    ofn.lpstrTitle = LoadStringDx(IDS_EXTRACTRES);
    ofn.Flags = OFN_ENABLESIZING | OFN_EXPLORER | OFN_HIDEREADONLY |
                OFN_PATHMUSTEXIST | OFN_OVERWRITEPROMPT;
    ofn.lpstrDefExt = L"res";   // the default extension

    // let the user choose the path
    if (GetSaveFileNameW(&ofn))
    {
        // extract it to a file
        if (lstrcmpiW(&ofn.lpstrFile[ofn.nFileExtension], L"res") == 0)
        {
            // it was a *.res file
            if (!g_res.extract_res(ofn.lpstrFile, e))
            {
                ErrorBoxDx(IDS_CANNOTSAVE);
            }
        }
        else
        {
            // it was not a *.res file
            if (!g_res.extract_bin(ofn.lpstrFile, e))
            {
                ErrorBoxDx(IDS_CANNOTSAVE);
            }
        }
    }
}

// extract the binary as a file
void MMainWnd::OnExtractBin(HWND hwnd)
{
    // compile if necessary
    if (!CompileIfNecessary(TRUE))
        return;

    // get the selected entry
    auto e = g_res.get_entry();
    if (!e)
        return;     // not selected

    if (e->is_delphi_dfm())
        return OnExtractDFM(hwnd);

    if (e->m_type == L"TYPELIB")
        return OnExtractTLB(hwnd);

    // initialize OPENFILENAME structure
    WCHAR szFile[MAX_PATH] = L"";
    OPENFILENAMEW ofn = { OPENFILENAME_SIZE_VERSION_400W, hwnd };
    ofn.lpstrFile = szFile;
    ofn.nMaxFile = _countof(szFile);

    // use the prefered filter by the entry
    switch (e->m_et)
    {
    case ET_STRING:
    case ET_MESSAGE:
    case ET_TYPE:
    case ET_NAME:
        ofn.lpstrFilter = MakeFilterDx(LoadStringDx(IDS_RESFILTER));
        ofn.lpstrDefExt = L"res";
        break;
    case ET_LANG:
        if (e->m_type == L"PNG")
        {
            ofn.lpstrFilter = MakeFilterDx(LoadStringDx(IDS_PNGRESBINFILTER));
            ofn.lpstrDefExt = L"png";
        }
        else if (e->m_type == L"JPEG")
        {
            ofn.lpstrFilter = MakeFilterDx(LoadStringDx(IDS_JPEGRESBINFILTER));
            ofn.lpstrDefExt = L"jpg";
        }
        else if (e->m_type == L"GIF")
        {
            ofn.lpstrFilter = MakeFilterDx(LoadStringDx(IDS_GIFRESBINFILTER));
            ofn.lpstrDefExt = L"gif";
        }
        else if (e->m_type == L"TIFF")
        {
            ofn.lpstrFilter = MakeFilterDx(LoadStringDx(IDS_TIFFRESBINFILTER));
            ofn.lpstrDefExt = L"tif";
        }
        else if (e->m_type == L"AVI")
        {
            ofn.lpstrFilter = MakeFilterDx(LoadStringDx(IDS_AVIRESBINFILTER));
            ofn.lpstrDefExt = L"avi";
        }
        else if (e->m_type == L"WAVE")
        {
            ofn.lpstrFilter = MakeFilterDx(LoadStringDx(IDS_WAVERESBINFILTER));
            ofn.lpstrDefExt = L"wav";
        }
        else
        {
            ofn.lpstrFilter = MakeFilterDx(LoadStringDx(IDS_RESBINFILTER));
            ofn.lpstrDefExt = L"res";
        }
        break;
    default:
        return;
    }

    ofn.lpstrTitle = LoadStringDx(IDS_EXTRACTRES);
    ofn.Flags = OFN_ENABLESIZING | OFN_EXPLORER | OFN_HIDEREADONLY |
                OFN_PATHMUSTEXIST | OFN_OVERWRITEPROMPT;

    // let the user choose the path
    if (GetSaveFileNameW(&ofn))
    {
        // extract it to a file
        if (lstrcmpiW(&ofn.lpstrFile[ofn.nFileExtension], L"res") == 0)
        {
            // it was a *.res file
            if (!g_res.extract_res(ofn.lpstrFile, e))
            {
                ErrorBoxDx(IDS_CANNOTSAVE);
            }
        }
        else
        {
            // it was not a *.res file
            if (!g_res.extract_bin(ofn.lpstrFile, e))
            {
                ErrorBoxDx(IDS_CANNOTSAVE);
            }
        }
    }
}

void MMainWnd::OnExtractRC(HWND hwnd)
{
    // compile if necessary
    if (!CompileIfNecessary(TRUE))
        return;

    // get the selected entry
    auto e = g_res.get_entry();
    if (!e)
        return;     // not selected

    // initialize OPENFILENAME structure
    WCHAR szFile[MAX_PATH] = L"";
    OPENFILENAMEW ofn = { OPENFILENAME_SIZE_VERSION_400W, hwnd };
    ofn.lpstrFile = szFile;
    ofn.nMaxFile = _countof(szFile);
    ofn.lpstrFilter = MakeFilterDx(LoadStringDx(IDS_RCFILTER));
    ofn.lpstrTitle = LoadStringDx(IDS_EXTRACTRES);
    ofn.Flags = OFN_ENABLESIZING | OFN_EXPLORER | OFN_HIDEREADONLY |
                OFN_PATHMUSTEXIST | OFN_OVERWRITEPROMPT;
    ofn.lpstrDefExt = L"rc";   // the default extension

    // use the prefered filter by the entry
    EntrySet found;
    MIdOrString type = e->m_type;
    switch (e->m_et)
    {
    case ET_STRING:
        g_res.search(found, ET_LANG, RT_STRING, WORD(0), e->m_lang);
        break;
    case ET_MESSAGE:
        g_res.search(found, ET_LANG, RT_MESSAGETABLE, WORD(0), e->m_lang);
        break;
    case ET_TYPE:
        if (type == RT_ICON)
            type = RT_GROUP_ICON;
        else if (type == RT_CURSOR)
            type = RT_GROUP_CURSOR;
        g_res.search(found, ET_LANG, type, WORD(0), BAD_LANG);
        break;
    case ET_NAME:
        g_res.search(found, ET_LANG, type, e->m_name, BAD_LANG);
        break;
    case ET_LANG:
        g_res.search(found, ET_LANG, type, e->m_name, e->m_lang);
        break;
    default:
        return;
    }

    if (found.empty())
    {
        ErrorBoxDx(IDS_DATAISEMPTY);
        return;
    }

    // let the user choose the path
    if (GetSaveFileNameW(&ofn))
    {
        // show the "export options" dialog
        MExportOptionsDlg dialog;
        if (dialog.DialogBoxDx(hwnd) != IDOK)
            return;

        if (!DoExport(szFile, NULL, found))
        {
            ErrorBoxDx(IDS_CANTEXPORT);
        }
    }
}

void MMainWnd::PostUpdateLangArrow(HWND hwnd)
{
    PostMessage(hwnd, MYWM_UPDATELANGARROW, 0, 0);
}

// MYWM_UPDATELANGARROW
LRESULT MMainWnd::OnUpdateLangArrow(HWND hwnd, WPARAM wParam, LPARAM lParam)
{
    UpdateLangArrow();
    return 0;
}

// MYWM_RADDBLCLICK
LRESULT MMainWnd::OnRadDblClick(HWND hwnd, WPARAM wParam, LPARAM lParam)
{
    if (lParam)
        m_rad_window.OnCtrlProp(m_rad_window);
    else
        m_rad_window.OnDlgProp(m_rad_window);
    return 0;
}

// extract an icon as an *.ico file
void MMainWnd::OnExtractIcon(HWND hwnd)
{
    enum IconFilterIndex  // see also: IDS_ICOFILTER
    {
        IFI_NONE = 0,
        IFI_ICO = 1,
        IFI_ANI = 2,
        IFI_ALL = 3
    };

    // compile if necessary
    if (!CompileIfNecessary(FALSE))
        return;

    // get the selected language entry
    auto entry = g_res.get_lang_entry();
    if (!entry)
        return;

    WCHAR szFile[MAX_PATH] = L"";
    ResToText res2text;
    MString strFile = res2text.GetEntryFileName(*entry);
    if (strFile.size())
    {
        StringCbCopyW(szFile, sizeof(szFile), strFile.c_str());
    }

    // initialize OPENFILENAME structure
    OPENFILENAMEW ofn = { OPENFILENAME_SIZE_VERSION_400W, hwnd };
    ofn.lpstrFilter = MakeFilterDx(LoadStringDx(IDS_ICOFILTER));
    ofn.lpstrFile = szFile;
    ofn.nMaxFile = _countof(szFile);
    ofn.lpstrTitle = LoadStringDx(IDS_EXTRACTICO);
    ofn.Flags = OFN_ENABLESIZING | OFN_EXPLORER | OFN_HIDEREADONLY |
                OFN_PATHMUSTEXIST | OFN_OVERWRITEPROMPT;

    // use the prefered filter by the entry
    if (entry->m_type == RT_ANIICON)
    {
        ofn.nFilterIndex = IFI_ANI;
        ofn.lpstrDefExt = L"ani";   // the default extension
    }
    else
    {
        ofn.nFilterIndex = IFI_ICO;
        ofn.lpstrDefExt = L"ico";   // the default extension
    }

    // let the user choose the path
    if (GetSaveFileNameW(&ofn))
    {
        // extract it to an *.ico or *.ani file
        if (!g_res.extract_icon(ofn.lpstrFile, entry))
        {
            ErrorBoxDx(IDS_CANTEXTRACTICO);
        }
    }
}

// extract a cursor as an *.cur or *.ani file
void MMainWnd::OnExtractCursor(HWND hwnd)
{
    enum CursorFilterIndex      // see also: IDS_CURFILTER
    {
        CFI_NONE = 0,
        CFI_CUR = 1,
        CFI_ANI = 2,
        CFI_ALL = 3
    };

    // compile if necessary
    if (!CompileIfNecessary(FALSE))
        return;

    // get the selected language entry
    auto entry = g_res.get_lang_entry();
    if (!entry)     // not selected
        return;

    WCHAR szFile[MAX_PATH] = L"";
    ResToText res2text;
    MString strFile = res2text.GetEntryFileName(*entry);
    if (strFile.size())
    {
        StringCbCopyW(szFile, sizeof(szFile), strFile.c_str());
    }

    // initialize OPENFILENAME structure
    OPENFILENAMEW ofn = { OPENFILENAME_SIZE_VERSION_400W, hwnd };
    ofn.lpstrFilter = MakeFilterDx(LoadStringDx(IDS_CURFILTER));
    ofn.lpstrFile = szFile;
    ofn.nMaxFile = _countof(szFile);
    ofn.lpstrTitle = LoadStringDx(IDS_EXTRACTCUR);
    ofn.Flags = OFN_ENABLESIZING | OFN_EXPLORER | OFN_HIDEREADONLY |
                OFN_PATHMUSTEXIST | OFN_OVERWRITEPROMPT;

    // use the prefered filter by the entry
    if (entry->m_type == RT_ANICURSOR)
    {
        ofn.nFilterIndex = CFI_ANI;
        ofn.lpstrDefExt = L"ani";   // the default extension
    }
    else
    {
        ofn.nFilterIndex = CFI_CUR;
        ofn.lpstrDefExt = L"cur";   // the default extension
    }

    // let the user choose the path
    if (GetSaveFileNameW(&ofn))
    {
        // extract it to an *.cur or *.ani file
        if (!g_res.extract_cursor(ofn.lpstrFile, entry))
        {
            ErrorBoxDx(IDS_CANTEXTRACTCUR);
        }
    }
}

// extract a bitmap as an *.bmp file
void MMainWnd::OnExtractBitmap(HWND hwnd)
{
    // compile if necessary
    if (!CompileIfNecessary(FALSE))
        return;

    // get the selected language entry
    auto entry = g_res.get_lang_entry();
    if (!entry)     // not selected
        return;

    WCHAR szFile[MAX_PATH] = L"";
    ResToText res2text;
    MString strFile = res2text.GetEntryFileName(*entry);
    if (strFile.size())
    {
        StringCbCopyW(szFile, sizeof(szFile), strFile.c_str());
    }

    // initialize OPENFILENAME structure
    OPENFILENAMEW ofn = { OPENFILENAME_SIZE_VERSION_400W, hwnd };
    ofn.lpstrFilter = MakeFilterDx(LoadStringDx(IDS_BMPFILTER));
    ofn.lpstrFile = szFile;
    ofn.nMaxFile = MAX_PATH;
    ofn.lpstrTitle = LoadStringDx(IDS_EXTRACTBMP);
    ofn.Flags = OFN_ENABLESIZING | OFN_EXPLORER | OFN_HIDEREADONLY |
                OFN_PATHMUSTEXIST | OFN_OVERWRITEPROMPT;
    ofn.lpstrDefExt = L"bmp";   // the default extension

    // let the user choose the path
    if (GetSaveFileNameW(&ofn))
    {
        // extract a bitmap as an *.bmp or *.png file
        BOOL bPNG = (lstrcmpiW(&ofn.lpstrFile[ofn.nFileExtension], L"png") == 0);
        if (!PackedDIB_Extract(ofn.lpstrFile, &(*entry)[0], (*entry).size(), bPNG))
        {
            ErrorBoxDx(IDS_CANTEXTRACTBMP);
        }
    }
}

// replace the resource data by a binary file
void MMainWnd::OnReplaceBin(HWND hwnd)
{
    // compile if necessary
    if (!CompileIfNecessary(TRUE))
        return;

    // get the selected language entry
    auto entry = g_res.get_lang_entry();
    if (!entry)
        return;

    // show the dialog
    MReplaceBinDlg dialog(entry);
    if (dialog.DialogBoxDx(hwnd) == IDOK)
    {
        // select the entry
        SelectTV(ET_LANG, dialog, FALSE);
    }

    DoSetFileModified(TRUE);
}

// version info
void MMainWnd::OnAbout(HWND hwnd)
{
    // compile if necessary
    if (!CompileIfNecessary(FALSE))
        return;

    // show the dialog
    MVersionInfoDlg dialog;
    dialog.DialogBoxDx(hwnd);
}

// show the MFontsDlg to allow the user to change the font settings
void MMainWnd::OnFonts(HWND hwnd)
{
    // compile if necessary
    if (!CompileIfNecessary(FALSE))
        return;

    // show the fonts dialog
    MFontsDlg dialog;
    if (dialog.DialogBoxDx(hwnd) == IDOK)
    {
        // update m_hBinFont and set it to m_hHexViewer
        DeleteObject(m_hBinFont);
        m_hBinFont = dialog.DetachBinFont();
        SetWindowFont(m_hHexViewer, m_hBinFont, TRUE);

        // update m_hSrcFont and set it to m_hCodeEditor
        DeleteObject(m_hSrcFont);
        m_hSrcFont = dialog.DetachSrcFont();
        SetWindowFont(m_hCodeEditor, m_hSrcFont, TRUE);
    }
}

// export all the resource items to an RC file
void MMainWnd::OnExport(HWND hwnd)
{
    // compile if necessary
    if (!CompileIfNecessary(TRUE))
        return;

    // initialize OPENFILENAME structure
    WCHAR file[MAX_PATH] = TEXT("");
    OPENFILENAMEW ofn = { OPENFILENAME_SIZE_VERSION_400W, hwnd };
    ofn.lpstrFilter = MakeFilterDx(LoadStringDx(IDS_RCFILTER));
    ofn.lpstrFile = file;
    ofn.nMaxFile = _countof(file);
    ofn.lpstrTitle = LoadStringDx(IDS_EXPORT);
    ofn.Flags = OFN_ENABLESIZING | OFN_EXPLORER | OFN_HIDEREADONLY |
                OFN_OVERWRITEPROMPT | OFN_PATHMUSTEXIST;
    ofn.lpstrDefExt = L"rc";    // the default extension

    // let the user choose the path
    if (GetSaveFileNameW(&ofn))
    {
        // show the "export options" dialog
        MExportOptionsDlg dialog;
        if (dialog.DialogBoxDx(hwnd) != IDOK)
            return;

        // do export!
        if (!DoExport(file))
        {
            ErrorBoxDx(IDS_CANTEXPORT);
        }
    }
}

// the window class libraries
typedef std::unordered_set<HMODULE> wclib_t;
wclib_t s_wclib;

// is there a window class that is named pszName?
BOOL IsThereWndClass(const WCHAR *pszName)
{
    if (!pszName || pszName[0] == 0)
        return FALSE;   // failure

    WNDCLASSEX cls;
    if (GetClassInfoEx(NULL, pszName, &cls) ||
        GetClassInfoEx(GetModuleHandle(NULL), pszName, &cls))
    {
        return TRUE;    // already exists
    }

    // in the window class libraries?
    for (auto& library : s_wclib)
    {
        if (GetClassInfoEx(library, pszName, &cls))
            return TRUE;    // found
    }

    // CLSID?
    if (pszName[0] == L'{' &&
        pszName[9] == L'-' && pszName[14] == L'-' &&
        pszName[19] == L'-' && pszName[24] == L'-' &&
        pszName[37] == L'}')
    {
        return TRUE;        // it's a CLSID
    }

    // ATL OLE control?
    if (std::wstring(pszName).find(L"AtlAxWin") == 0)
        return TRUE;        // it's an ATL OLE control

    return FALSE;   // failure
}

// release all the window class libraries
void FreeWCLib()
{
    for (auto& library : s_wclib)
    {
        FreeLibrary(library);
        //library = NULL;
    }
    s_wclib.clear();
}

// load a window class library
void MMainWnd::OnLoadWCLib(HWND hwnd)
{
    // compile if necessary
    if (!CompileIfNecessary(TRUE))
        return;

    WCHAR file[MAX_PATH] = TEXT("");

    // initialize OPENFILENAME structure
    OPENFILENAMEW ofn = { OPENFILENAME_SIZE_VERSION_400W, hwnd };
    ofn.lpstrFilter = MakeFilterDx(LoadStringDx(IDS_DLLFILTER));
    ofn.lpstrFile = file;
    ofn.nMaxFile = _countof(file);
    ofn.lpstrTitle = LoadStringDx(IDS_LOADWCLIB);
    ofn.Flags = OFN_ENABLESIZING | OFN_EXPLORER | OFN_FILEMUSTEXIST |
                OFN_HIDEREADONLY | OFN_PATHMUSTEXIST;
    ofn.lpstrDefExt = L"dll";       // the default extension

    // let the user choose the path
    if (GetOpenFileNameW(&ofn))
    {
        // load the window class library
        HMODULE hMod = LoadLibraryW(file);
        if (hMod)
        {
            // success. add it
            s_wclib.insert(hMod);
        }
        else
        {
            ErrorBoxDx(IDS_CANNOTLOAD);
        }
    }
}

// import the resource data additionally
void MMainWnd::OnImport(HWND hwnd)
{
    // compile if necessary
    if (!CompileIfNecessary(FALSE))
        return;

    WCHAR file[MAX_PATH] = TEXT("");

    // initialize OPENFILENAME structure
    OPENFILENAMEW ofn = { OPENFILENAME_SIZE_VERSION_400W, hwnd };
    ofn.lpstrFilter = MakeFilterDx(LoadStringDx(IDS_IMPORTFILTER));
    ofn.lpstrFile = file;
    ofn.nMaxFile = _countof(file);
    ofn.lpstrTitle = LoadStringDx(IDS_IMPORTRES);
    ofn.Flags = OFN_ENABLESIZING | OFN_EXPLORER | OFN_FILEMUSTEXIST |
                OFN_HIDEREADONLY | OFN_PATHMUSTEXIST;
    ofn.lpstrDefExt = L"res";       // the default extension

    // let the user choose the path
    if (GetOpenFileNameW(&ofn))
    {
        // find the file title
        LPCWSTR pch = wcsrchr(file, L'\\');
        if (pch == NULL)
            pch = wcsrchr(file, L'/');
        if (pch == NULL)
            pch = file;
        else
            ++pch;

        // find the dot extension
        pch = wcsrchr(pch, L'.');

        if (IMPORT_FAILED == DoImport(hwnd, file, pch))
        {
            ErrorBoxDx(IDS_CANNOTIMPORT);
        }
        DoSetFileModified(TRUE);
    }
}

// open a file
void MMainWnd::OnOpen(HWND hwnd)
{
    // compile if necessary
    if (!CompileIfNecessary(FALSE))
        return;

    if (!DoQuerySaveChange(hwnd))
        return;

    // store the nominal path
    WCHAR szFile[MAX_PATH];
    StringCchCopyW(szFile, _countof(szFile), m_szFile);

    // if path was not valid, make it empty
    if (!PathFileExistsW(szFile))
        szFile[0] = 0;

    // initialize OPENFILENAME structure
    OPENFILENAMEW ofn = { OPENFILENAME_SIZE_VERSION_400W, hwnd };
    ofn.lpstrFilter = MakeFilterDx(LoadStringDx(IDS_EXERESRCFILTER));
    ofn.lpstrFile = szFile;
    ofn.nMaxFile = _countof(szFile);
    ofn.lpstrTitle = LoadStringDx(IDS_OPEN);
    ofn.Flags = OFN_ENABLESIZING | OFN_EXPLORER | OFN_FILEMUSTEXIST |
                OFN_HIDEREADONLY | OFN_PATHMUSTEXIST;
    ofn.lpstrDefExt = L"exe";       // the default extension

    // let the user choose the path
    if (GetOpenFileNameW(&ofn))
    {
        // load the file
        DoLoadFile(hwnd, szFile, ofn.nFilterIndex);
    }
}

BOOL MMainWnd::DoQuerySaveChange(HWND hwnd)
{
    if (!s_bModified)
        return TRUE;

    INT id = MsgBoxDx(IDS_QUERYSAVECHANGE, MB_ICONINFORMATION | MB_YESNOCANCEL);
    if (id == IDCANCEL)
        return FALSE;

    if (id == IDYES)
        return OnSave(hwnd);

    return TRUE;
}

// clear all the resource data
void MMainWnd::OnNew(HWND hwnd)
{
    if (!DoQuerySaveChange(hwnd))
        return;

    // close preview
    HidePreview();

    // unload the resource.h file
    OnUnloadResH(hwnd);

    // update the file info
    UpdateFileInfo(FT_NONE, NULL, FALSE);

    // unselect
    SelectTV(NULL, FALSE);

    // clean up
    g_res.delete_all();

    // update modified flag
    DoSetFileModified(FALSE);

    // update language arrow
    PostUpdateLangArrow(hwnd);
}

enum ResFileFilterIndex     // see also: IDS_EXERESFILTER
{
    RFFI_NONE = 0,
    RFFI_EXECUTABLE = 1,
    RFFI_RC = 2,
    RFFI_RES = 3,
    RFFI_ALL = 4
};

// save as a file or files
BOOL MMainWnd::OnSaveAs(HWND hwnd)
{
    // compile if necessary
    if (!CompileIfNecessary(TRUE))
        return FALSE;

    // store m_szFile to szFile
    WCHAR szFile[MAX_PATH];
    StringCchCopyW(szFile, _countof(szFile), m_szFile);

    // if not found, then make it empty
    if (!PathFileExistsW(szFile))
        szFile[0] = 0;

    // was it an executable?
    BOOL bWasExecutable = (m_file_type == FT_EXECUTABLE);

    // get and delete the filename extension
    WCHAR szExt[32] = L"";
    LPWSTR pch = wcsrchr(szFile, L'.');
    static const LPCWSTR s_DotExts[] =
    {
        L".exe", L".dll", L".ocx", L".cpl", L".scr", L".mui", L".rc", L".res"
    };
    for (auto ext : s_DotExts)
    {
        if (lstrcmpiW(pch, ext) == 0)
        {
            StringCbCopyW(szExt, sizeof(szExt), ext + 1);
            *pch = 0;
            break;
        }
    }

    // initialize OPENFILENAME structure
    OPENFILENAMEW ofn = { OPENFILENAME_SIZE_VERSION_400W, hwnd };
    ofn.lpstrFilter = MakeFilterDx(LoadStringDx(IDS_EXERESFILTER));

    // use the prefered filter by the entry
    ofn.nFilterIndex = g_settings.nSaveFilterIndex;
    if (bWasExecutable)
    {
        if (ofn.nFilterIndex != RFFI_EXECUTABLE)
            ofn.nFilterIndex = RFFI_EXECUTABLE;
    }
    else
    {
        if (ofn.nFilterIndex == RFFI_EXECUTABLE)
            ofn.nFilterIndex = RFFI_RC;
    }

    // use the preferred extension
    switch (ofn.nFilterIndex)
    {
    case RFFI_EXECUTABLE:
        if (szExt[0])
        {
            ofn.lpstrDefExt = szExt;
        }
        else
        {
            ofn.lpstrDefExt = L"exe";       // the default extension
        }
        break;

    case RFFI_RC:
        ofn.lpstrDefExt = L"rc";        // the default extension
        break;

    case RFFI_RES:
    default:
        ofn.lpstrDefExt = L"res";       // the default extension
        break;
    }

    ofn.lpstrFile = szFile;
    ofn.nMaxFile = _countof(szFile);
    ofn.lpstrTitle = LoadStringDx(IDS_SAVEAS);
    ofn.Flags = OFN_ENABLESIZING | OFN_EXPLORER | OFN_HIDEREADONLY |
                OFN_OVERWRITEPROMPT | OFN_PATHMUSTEXIST;

    // let the user choose the path
    if (GetSaveFileNameW(&ofn))
    {
        // save the filter index to the settings
        g_settings.nSaveFilterIndex = ofn.nFilterIndex;

        if (ofn.nFilterIndex == RFFI_ALL)
        {
            ofn.nFilterIndex = RFFI_EXECUTABLE;
        }

        switch (ofn.nFilterIndex)
        {
        case RFFI_EXECUTABLE:
            // save it
            if (DoSaveAs(szFile))
            {
                m_nStatusStringID = IDS_FILESAVED;
                return TRUE;
            }
            ErrorBoxDx(IDS_CANNOTSAVE);
            break;

        case RFFI_RC:
            // export and save it
            {
                // show "save options" dialog
                MSaveOptionsDlg save_options;
                if (save_options.DialogBoxDx(hwnd) != IDOK)
                    return FALSE;

                // export
                WCHAR szResH[MAX_PATH] = L"";
                if (DoExport(szFile, szResH))   // succeeded
                {
                    // save the resource.h path
                    StringCchCopyW(m_szResourceH, _countof(m_szResourceH), szResH);

                    // update the file info
                    UpdateFileInfo(FT_RC, szFile, FALSE);

                    m_nStatusStringID = IDS_FILESAVED;
                    return TRUE;
                }
                else
                {
                    ErrorBoxDx(IDS_CANNOTSAVE);
                }
            }
            break;

        case RFFI_RES:
            // save the *.res file
            if (DoSaveResAs(szFile))
            {
                m_nStatusStringID = IDS_FILESAVED;
                return TRUE;
            }
            ErrorBoxDx(IDS_CANNOTSAVE);
            break;

        default:
            assert(0);
            break;
        }
    }

    return FALSE;
}

void MMainWnd::OnEga(HWND hwnd, LPCWSTR file)
{
    // Hide ID list
    ShowIDList(hwnd, FALSE);

    // compile if necessary
    if (!CompileIfNecessary(TRUE))
        return;

    if (s_hwndEga && ::IsWindow(s_hwndEga))
    {
        ::ShowWindow(s_hwndEga, SW_SHOWNORMAL);
        ::SetForegroundWindow(s_hwndEga);
        auto pDialog = dynamic_cast<MEgaDlg*>(MDialogBase::GetUserData(s_hwndEga));
        assert(pDialog);
        if (pDialog)
            pDialog->Run(file);
        return;
    }

    auto pDialog = dynamic_cast<MEgaDlg*>(MEgaDlg::CreateInstanceDx());
    assert(pDialog);
    pDialog->CreateDialogDx(hwnd);
    ::ShowWindow(*pDialog, SW_SHOWNORMAL);
    pDialog->Run(file);
}

void MMainWnd::OnEgaProgram(HWND hwnd)
{
    // compile if necessary
    if (!CompileIfNecessary(TRUE))
        return;

    OPENFILENAMEW ofn = { OPENFILENAME_SIZE_VERSION_400W, hwnd };

    WCHAR szDir[MAX_PATH];
    GetModuleFileNameW(NULL, szDir, ARRAYSIZE(szDir));
    PathRemoveFileSpecW(szDir);

    WCHAR szFile[MAX_PATH] = L"";
    StringCbCopyW(szFile, sizeof(szFile), szDir);
    PathAppendW(szFile, L"EGA");
    if (!PathIsDirectoryW(szFile))
    {
        StringCbCopyW(szFile, sizeof(szFile), szDir);
        PathAppendW(szFile, L"..\\EGA-samples");
        if (!PathIsDirectoryW(szFile))
        {
            StringCbCopyW(szFile, sizeof(szFile), szDir);
            PathAppendW(szFile, L"..\\..\\EGA-samples");
            if (!PathIsDirectoryW(szFile))
            {
                StringCbCopyW(szFile, sizeof(szFile), szDir);
                PathAppendW(szFile, L"..\\..\\..\\EGA-samples");
                if (!PathIsDirectoryW(szFile))
                {
                    return;
                }
            }
        }
    }
    PathAppendW(szFile, L"*.ega");

    ofn.hwndOwner = hwnd;
    ofn.lpstrFilter = MakeFilterDx(LoadStringDx(IDS_EGAFILTER));
    ofn.lpstrFile = szFile;
    ofn.nMaxFile = ARRAYSIZE(szFile);
    ofn.lpstrTitle = LoadStringDx(IDS_LOADEGAPROGRAM);
    ofn.lpstrDefExt = L"ega";
    if (GetOpenFileNameW(&ofn))
    {
        OnEga(hwnd, szFile);
    }
}

BOOL MMainWnd::OnSave(HWND hwnd)
{
    // compile if necessary
    if (!CompileIfNecessary(TRUE))
        return FALSE;

    if (!m_szFile[0])
    {
        return OnSaveAs(hwnd);
    }

    LPWSTR pchDotExt = PathFindExtensionW(m_szFile);
    if (lstrcmpiW(pchDotExt, L".res") == 0)
    {
        g_settings.nSaveFilterIndex = RFFI_RES;
    }
    else if (lstrcmpiW(pchDotExt, L".rc") == 0)
    {
        g_settings.nSaveFilterIndex = RFFI_RC;
    }
    else
    {
        g_settings.nSaveFilterIndex = RFFI_EXECUTABLE;
    }

    switch (g_settings.nSaveFilterIndex)
    {
    case RFFI_EXECUTABLE:
        // save it
        if (DoSaveAs(m_szFile))
        {
            m_nStatusStringID = IDS_FILESAVED;
            return TRUE;
        }
        ErrorBoxDx(IDS_CANNOTSAVE);
        break;

    case RFFI_RC:
        // export and save it
        {
            // show "save options" dialog
            MSaveOptionsDlg save_options;
            if (save_options.DialogBoxDx(hwnd) != IDOK)
                return FALSE;

            // export
            WCHAR szResH[MAX_PATH] = L"";
            if (DoExport(m_szFile, szResH))   // succeeded
            {
                // save the resource.h path
                StringCchCopyW(m_szResourceH, _countof(m_szResourceH), szResH);

                // update the file info
                UpdateFileInfo(FT_RC, m_szFile, FALSE);

                m_nStatusStringID = IDS_FILESAVED;
                return TRUE;
            }
            else
            {
                ErrorBoxDx(IDS_CANNOTSAVE);
            }
        }
        break;

    case RFFI_RES:
        // save the *.res file
        if (DoSaveResAs(m_szFile))
        {
            m_nStatusStringID = IDS_FILESAVED;
            return TRUE;
        }
        ErrorBoxDx(IDS_CANNOTSAVE);
        break;

    default:
        assert(0);
        break;
    }

    return FALSE;
}

// update the fonts by the font settings
void MMainWnd::ReCreateFonts(HWND hwnd)
{
    // delete the fonts
    if (m_hBinFont)
    {
        DeleteObject(m_hBinFont);
        m_hBinFont = NULL;
    }
    if (m_hSrcFont)
    {
        DeleteObject(m_hSrcFont);
        m_hSrcFont = NULL;
    }

    // initialize LOGFONT structures
    LOGFONTW lfBin, lfSrc;
    ZeroMemory(&lfBin, sizeof(lfBin));
    ZeroMemory(&lfSrc, sizeof(lfSrc));

    // set lfFaceName from settings
    StringCchCopy(lfBin.lfFaceName, _countof(lfBin.lfFaceName), g_settings.strBinFont.c_str());
    StringCchCopy(lfSrc.lfFaceName, _countof(lfSrc.lfFaceName), g_settings.strSrcFont.c_str());

    // calculate the height
    if (HDC hDC = CreateCompatibleDC(NULL))
    {
        lfBin.lfHeight = -MulDiv(g_settings.nBinFontSize, GetDeviceCaps(hDC, LOGPIXELSY), 72);
        lfSrc.lfHeight = -MulDiv(g_settings.nSrcFontSize, GetDeviceCaps(hDC, LOGPIXELSY), 72);
        DeleteDC(hDC);
    }

    // create the fonts
    m_hBinFont = CreateFontIndirectW(&lfBin);
    assert(m_hBinFont);
    m_hSrcFont = ::CreateFontIndirectW(&lfSrc);
    assert(m_hSrcFont);

    // set the fonts to the controls
    SetWindowFont(m_hHexViewer, m_hBinFont, TRUE);
    SetWindowFont(m_hCodeEditor, m_hSrcFont, TRUE);
}

// check the text for item search
static bool CheckTextForSearch(ITEM_SEARCH *pSearch, EntryBase *entry, MString text)
{
    // make the text uppercase to ignore case
    if (pSearch->bIgnoreCases)
        CharUpperW(&text[0]);

    // find?
    if (text.find(pSearch->strText) == MString::npos)
        return false;   // not found

    if (pSearch->bDownward)     // go downward
    {
        // check the position
        if (pSearch->pCurrent == NULL || *pSearch->pCurrent < *entry)
        {
            if (pSearch->pFound)    // already found
            {
                if (*entry < *pSearch->pFound)  // compare with the found one
                {
                    pSearch->pFound = entry;
                    return true;    // found
                }
            }
            else    // not found yet
            {
                pSearch->pFound = entry;    // found
                return true;    // found
            }
        }
    }
    else    // go upward
    {
        // check the position
        if (pSearch->pCurrent == NULL || *entry < *pSearch->pCurrent)
        {
            if (pSearch->pFound)    // already found
            {
                if (*pSearch->pFound < *entry)  // compare with the found one
                {
                    pSearch->pFound = entry;
                    return true;    // found
                }
            }
            else
            {
                pSearch->pFound = entry;
                return true;    // found
            }
        }
    }

    return false;    // not found
}

// a function for item search
static unsigned __stdcall
search_proc(void *arg)
{
    auto pSearch = (ITEM_SEARCH *)arg;
    MString text;

    for (auto entry : g_res)
    {
        if (!entry->valid())
            continue;

        EntryBase e = *entry;

        // check label
        text = e.m_strLabel;
        if (CheckTextForSearch(pSearch, entry, text))
        {
            //MessageBoxW(NULL, e.m_strLabel.c_str(), L"OK", 0);
            continue;
        }

        // check internal text
        switch (e.m_et)
        {
        case ET_LANG:
        case ET_MESSAGE:
            break;
        case ET_STRING:
            // ignore the name
            e.m_name.clear();
            break;
        default:
            continue;
        }
        text = pSearch->res2text.DumpEntry(e);
        if (CheckTextForSearch(pSearch, entry, text))
        {
            //MessageBoxW(NULL, (e.m_strLabel + L"<>" + text).c_str(), NULL, 0);
            continue;
        }
    }

    pSearch->bRunning = FALSE;  // finish
    return 0;
}

// do item search
BOOL MMainWnd::DoItemSearch(ITEM_SEARCH& search)
{
    MWaitCursor wait;

    if (search.bIgnoreCases)
        CharUpperW(&search.strText[0]);

    search_proc(&search);

    return search.pFound != NULL;
}

// clone the resource item in new name
void MMainWnd::OnCopyAsNewName(HWND hwnd)
{
    // compile if necessary
    if (!CompileIfNecessary(FALSE))
        return;

    // get the selected name entry
    auto entry = g_res.get_entry();
    if (!entry || entry->m_et != ET_NAME)
        return;

    // show the dialog
    MCloneInNewNameDlg dialog(entry);
    if (dialog.DialogBoxDx(hwnd) == IDOK)
    {
        // search the ET_LANG entries
        EntrySet found;
        g_res.search(found, ET_LANG, entry->m_type, entry->m_name);

        if (entry->m_type == RT_GROUP_ICON)     // group icon
        {
            for (auto e : found)
            {
                g_res.copy_group_icon(e, dialog.m_name, e->m_lang);
            }
        }
        else if (entry->m_type == RT_GROUP_CURSOR)  // group cursor
        {
            for (auto e : found)
            {
                g_res.copy_group_cursor(e, dialog.m_name, e->m_lang);
            }
        }
        else    // otherwise
        {
            for (auto e : found)
            {
                g_res.add_lang_entry(e->m_type, dialog.m_name, e->m_lang, e->m_data);
            }
        }

        // select the entry
        SelectTV(ET_NAME, dialog.m_type, dialog.m_name, BAD_LANG, FALSE);
        DoSetFileModified(TRUE);
    }
}

// clone the resource item in new language
void MMainWnd::OnCopyAsNewLang(HWND hwnd)
{
    // compile if necessary
    if (!CompileIfNecessary(FALSE))
        return;

    // get the selected entry
    auto entry = g_res.get_entry();
    if (!entry)
        return;

    switch (entry->m_et)
    {
    case ET_LANG: case ET_STRING: case ET_MESSAGE:
        break;      // ok

    default:
        return;     // unable to copy the language
    }

    // show the dialog
    MCloneInNewLangDlg dialog(entry);
    if (dialog.DialogBoxDx(hwnd) == IDOK)
    {
        if (entry->m_type == RT_GROUP_ICON)     // group icon
        {
            // search the group icons
            EntrySet found;
            g_res.search(found, ET_LANG, RT_GROUP_ICON, entry->m_name, entry->m_lang);

            // copy them
            for (auto e : found)
            {
                g_res.copy_group_icon(e, e->m_name, dialog.m_lang);
            }

            // select the entry
            SelectTV(ET_LANG, dialog.m_type, dialog.m_name, dialog.m_lang, FALSE);
        }
        else if (entry->m_type == RT_GROUP_CURSOR)
        {
            // search the group cursors
            EntrySet found;
            g_res.search(found, ET_LANG, RT_GROUP_CURSOR, entry->m_name, entry->m_lang);

            // copy them
            for (auto e : found)
            {
                g_res.copy_group_cursor(e, e->m_name, dialog.m_lang);
            }

            // select the entry
            SelectTV(ET_LANG, dialog.m_type, dialog.m_name, dialog.m_lang, FALSE);
        }
        else if (entry->m_et == ET_STRING)
        {
            // search the strings
            EntrySet found;
            g_res.search(found, ET_LANG, RT_STRING, WORD(0), entry->m_lang);

            // copy them
            for (auto e : found)
            {
                g_res.add_lang_entry(e->m_type, e->m_name, dialog.m_lang, e->m_data);
            }

            // select the entry
            SelectTV(ET_STRING, dialog.m_type, WORD(0), dialog.m_lang, FALSE);
        }
        else if (entry->m_et == ET_MESSAGE)
        {
            // search the messagetables
            EntrySet found;
            g_res.search(found, ET_LANG, RT_MESSAGETABLE, WORD(0), entry->m_lang);

            // copy them
            for (auto e : found)
            {
                g_res.add_lang_entry(e->m_type, e->m_name, dialog.m_lang, e->m_data);
            }

            // select the entry
            SelectTV(ET_MESSAGE, dialog.m_type, WORD(0), dialog.m_lang, FALSE);
        }
        else
        {
            // search the entries
            EntrySet found;
            g_res.search(found, ET_LANG, entry->m_type, entry->m_name, entry->m_lang);

            // copy them
            for (auto e : found)
            {
                g_res.add_lang_entry(e->m_type, e->m_name, dialog.m_lang, e->m_data);
            }

            // select the entry
            SelectTV(ET_LANG, dialog.m_type, dialog.m_name, dialog.m_lang, FALSE);
        }
        DoSetFileModified(TRUE);
    }
}

void MMainWnd::OnCopyToMultiLang(HWND hwnd)
{
    // compile if necessary
    if (!CompileIfNecessary(FALSE))
        return;

    // get the selected entry
    auto entry = g_res.get_entry();
    if (!entry)
        return;

    switch (entry->m_et)
    {
    case ET_LANG: case ET_STRING: case ET_MESSAGE:
        break;      // ok

    default:
        return;     // unable to copy the language
    }

    // show the dialog
    MCopyToMultiLangDlg dialog(entry);
    WORD wLang = BAD_LANG;
    if (dialog.DialogBoxDx(hwnd) == IDOK)
    {
        for (auto& lang : dialog.m_langs)
        {
            wLang = lang;
            if (entry->m_type == RT_GROUP_ICON)     // group icon
            {
                // search the group icons
                EntrySet found;
                g_res.search(found, ET_LANG, RT_GROUP_ICON, entry->m_name, entry->m_lang);

                // copy them
                for (auto e : found)
                {
                    g_res.copy_group_icon(e, e->m_name, lang);
                }
            }
            else if (entry->m_type == RT_GROUP_CURSOR)
            {
                // search the group cursors
                EntrySet found;
                g_res.search(found, ET_LANG, RT_GROUP_CURSOR, entry->m_name, entry->m_lang);

                // copy them
                for (auto e : found)
                {
                    g_res.copy_group_cursor(e, e->m_name, lang);
                }
            }
            else if (entry->m_et == ET_STRING)
            {
                // search the strings
                EntrySet found;
                g_res.search(found, ET_LANG, RT_STRING, WORD(0), entry->m_lang);

                // copy them
                for (auto e : found)
                {
                    g_res.add_lang_entry(e->m_type, e->m_name, lang, e->m_data);
                }
            }
            else if (entry->m_et == ET_MESSAGE)
            {
                // search the messagetables
                EntrySet found;
                g_res.search(found, ET_LANG, RT_MESSAGETABLE, WORD(0), entry->m_lang);

                // copy them
                for (auto e : found)
                {
                    g_res.add_lang_entry(e->m_type, e->m_name, lang, e->m_data);
                }
            }
            else
            {
                // search the entries
                EntrySet found;
                g_res.search(found, ET_LANG, entry->m_type, entry->m_name, entry->m_lang);

                // copy them
                for (auto e : found)
                {
                    g_res.add_lang_entry(e->m_type, e->m_name, lang, e->m_data);
                }
            }
        }

        DoSetFileModified(TRUE);

        // select the entry
        SelectTV(ET_LANG, entry->m_type, entry->m_name, wLang, FALSE);
    }
}

// show the item search dialog
void MMainWnd::OnItemSearch(HWND hwnd)
{
    // is there "item search" dialogs?
    if (!MItemSearchDlg::Dialogs().empty())
    {
        // bring it to the top
        HWND hDlg = **MItemSearchDlg::Dialogs().begin();
        SetForegroundWindow(hDlg);
        SetFocus(hDlg);
        return;
    }

    // create dialog
    MItemSearchDlg *pDialog = new MItemSearchDlg(m_search);
    pDialog->CreateDialogDx(hwnd);

    // set the window handles to m_search.res2text
    m_search.res2text.m_hwnd = hwnd;
    m_search.res2text.m_hwndDialog = *pDialog;

    // show it
    ShowWindow(*pDialog, SW_SHOWNORMAL);
    UpdateWindow(*pDialog);
}

// MYWM_ITEMSEARCH: do item search
LRESULT MMainWnd::OnItemSearchBang(HWND hwnd, WPARAM wParam, LPARAM lParam)
{
    DoItemSearchBang(hwnd, (MItemSearchDlg *)lParam);
    return 0;
}

// MYWM_COMPLEMENT
LRESULT MMainWnd::OnComplement(HWND hwnd, WPARAM wParam, LPARAM lParam)
{
    INT index = (INT)wParam;

    if (index >= (INT)g_langs.size())
        return FALSE; // reject

    WORD wNewLang = g_langs[index].LangID;

    auto entry = g_res.get_entry();
    if (!entry || entry->m_et == ET_TYPE || entry->m_et == ET_NAME)
        return FALSE;   // reject

    WORD wOldLang = entry->m_lang;
    if (wNewLang == BAD_LANG || wOldLang == wNewLang)
        return FALSE;   // reject

    // check if it already exists
    if (g_res.find(ET_LANG, entry->m_type, entry->m_name, wNewLang))
    {
        ErrorBoxDx(IDS_ALREADYEXISTS);
        return FALSE;   // reject
    }

    PostUpdateLangArrow(hwnd);

    WCHAR szText[MAX_PATH];
    MString strLang = TextFromLang(wNewLang);
    StringCbCopy(szText, sizeof(szText), strLang.c_str());
    DoRelangEntry(szText, entry, wOldLang, wNewLang);
    DoSetFileModified(TRUE);
    return TRUE; // accepted
}

BOOL MMainWnd::DoInnerSearch(HWND hwnd)
{
    DWORD ich, ichEnd;
    SendMessageW(m_hCodeEditor, EM_GETSEL, (WPARAM)&ich, (LPARAM)&ichEnd);

    MString strText = MWindowBase::GetWindowText(m_hCodeEditor);

    MString strTarget = m_search.strText;
    if (m_search.bIgnoreCases)
    {
        CharUpperW(&strText[0]);
        CharUpperW(&strTarget[0]);
    }

    size_t index = MString::npos;
    if (m_search.bDownward)
    {
        if (ich == ichEnd)
            index = strText.find(strTarget);
        else if (ich + 1 < strText.size())
            index = strText.find(strTarget, ich + 1);
    }
    else
    {
        if (ich == ichEnd)
            index = strText.rfind(strTarget);
        else if (ich > 0)
            index = strText.rfind(strTarget, ich - 1);
    }

    if (index != MString::npos)
    {
        SendMessageW(m_hCodeEditor, EM_SETSEL, INT(index), INT(index + strTarget.size()));
        SendMessageW(m_hCodeEditor, EM_SCROLLCARET, 0, 0);
        return TRUE;
    }

    return FALSE;
}

BOOL MMainWnd::DoItemSearchBang(HWND hwnd, MItemSearchDlg *pDialog)
{
    // is it visible?
    if (pDialog == NULL || !IsWindowVisible(pDialog->m_hwnd))
    {
        pDialog = NULL;
    }

    // get the selected entry
    auto entry = g_res.get_entry();

    if (m_search.bIgnoreCases)
    {
        CharUpperW(&m_search.strText[0]);
    }

    // initialize
    m_search.bCancelled = FALSE;
    m_search.pFound = NULL;
    m_search.pCurrent = entry;

    // start searching
    if (DoInnerSearch(hwnd))
    {
        m_search.bRunning = FALSE;

        if (pDialog)
            pDialog->Done();    // uninitialize

        return TRUE;
    }

    if (DoItemSearch(m_search) && m_search.pFound)
    {
        m_search.bRunning = FALSE;

        if (pDialog)
            pDialog->Done();    // uninitialize

        // select the found one
        TreeView_SelectItem(m_hwndTV, m_search.pFound->m_hItem);
        TreeView_EnsureVisible(m_hwndTV, m_search.pFound->m_hItem);

        DoInnerSearch(hwnd);
        return TRUE;
    }

    m_search.bRunning = FALSE;

    if (pDialog)
        pDialog->Done();    // uninitialize

    // is it not cancelled?
    if (!m_search.bCancelled)
    {
        // "no more item" message
        if (pDialog)
            EnableWindow(*pDialog, FALSE);
        MsgBoxDx(IDS_NOMOREITEM, MB_ICONINFORMATION);
        if (pDialog)
            EnableWindow(*pDialog, TRUE);
    }

    // set focus to the dialog
    if (pDialog)
        SetFocus(*pDialog);

    return FALSE;
}

// delete a resource item
void MMainWnd::OnDeleteRes(HWND hwnd)
{
    // compile if necessary
    if (!CompileIfNecessary(FALSE))
        return;

    // get the selected entry
    if (auto entry = g_res.get_entry())
    {
        // delete it
        if (g_res.super()->find(entry) != g_res.end())
            TreeView_DeleteItem(m_hwndTV, entry->m_hItem);
    }
    DoSetFileModified(TRUE);
}

// play the sound
void MMainWnd::OnPlay(HWND hwnd)
{
    // is it a WAVE sound?
    auto entry = g_res.get_lang_entry();
    if (entry && entry->m_type == L"WAVE")
    {
        // play the sound
        PlaySound(reinterpret_cast<LPCTSTR>(&(*entry)[0]), NULL,
                  SND_ASYNC | SND_NODEFAULT | SND_MEMORY);
    }
}

void MMainWnd::OnSelChange(HWND hwnd, INT iSelected)
{
    if (iSelected != m_tab.GetCurSel())
    {
        // update tab control selection
        m_tab.SetCurSel(iSelected);
    }

    // update g_settings.bShowBinEdit
    switch (iSelected)
    {
    case 0:
        g_settings.bShowBinEdit = FALSE;
        break;
    case 1:
        g_settings.bShowBinEdit = TRUE;
        break;
    }

    // update show
    SetShowMode(m_nShowMode);

    // relayout
    PostMessage(hwnd, WM_SIZE, 0, 0);
}

// cancel edit
void MMainWnd::OnCancelEdit(HWND hwnd)
{
    // clear modification flag
    Edit_SetModify(m_hCodeEditor, FALSE);
    Edit_SetReadOnly(m_hCodeEditor, FALSE);

    // reselect to update the m_hCodeEditor
    auto entry = g_res.get_entry();
    SelectTV(entry, FALSE);
}

// set error message
void MMainWnd::SetErrorMessage(const MStringA& strOutput, BOOL bBox)
{
    // show the message box
    if (strOutput.empty())
    {
        MsgBoxDx(LoadStringDx(IDS_COMPILEERROR), MB_ICONERROR);
    }
    else
    {
        MAnsiToWide wide(CP_ACP, strOutput);
        MsgBoxDx(wide.c_str(), MB_ICONERROR);
    }
}

// compile the source text
void MMainWnd::OnCompile(HWND hwnd)
{
    // needs reopen?
    BOOL bReopen = IsWindowVisible(m_rad_window);

    // get the selected entry
    auto entry = g_res.get_entry();
    if (!entry)
        return;

    // is it not modified?
    if (!Edit_GetModify(m_hCodeEditor))
    {
        // select the entry
        SelectTV(entry, FALSE);
        return;
    }

    ChangeStatusText(IDS_COMPILING);

    // m_hCodeEditor --> strWide
    MStringW strWide = MWindowBase::GetWindowTextW(m_hCodeEditor);

    // compile the strWide text
    MStringA strOutput;
    if (CompileParts(strOutput, entry->m_type, entry->m_name, entry->m_lang, strWide, bReopen))
    {
        m_nStatusStringID = IDS_RECOMPILEOK;

        // clear the control selection
        MRadCtrl::GetTargets().clear();
        ::SendMessageW(m_hCodeEditor, LNEM_CLEARLINEMARKS, 0, 0);

        // clear the modification flag
        Edit_SetModify(m_hCodeEditor, FALSE);

        // select the entry
        SelectTV(entry, FALSE);
    }
    else
    {
        // failed
        m_nStatusStringID = IDS_RECOMPILEFAILED;
        SetErrorMessage(strOutput);
    }
}

// do GUI edit
void MMainWnd::OnGuiEdit(HWND hwnd)
{
    // get the selected entry
    auto entry = g_res.get_entry();
    if (!entry->is_editable(m_szVCBat))
        return;     // not editable

    if (!entry->can_gui_edit())
        return;     // unable to edit by GUI?

    // compile if necessary
    if (!CompileIfNecessary(FALSE))
    {
        return;
    }

    if (entry->m_type == RT_ACCELERATOR)
    {
        // entry->m_data --> accel_res
        AccelRes accel_res;
        MByteStreamEx stream(entry->m_data);
        if (accel_res.LoadFromStream(stream))
        {
            // editing...
            ChangeStatusText(IDS_EDITINGBYGUI);

            // show the dialog
            MEditAccelDlg dialog(accel_res);
            INT nID = (INT)dialog.DialogBoxDx(hwnd);
            if (nID == IDOK && entry == g_res.get_entry())
            {
                DoSetFileModified(TRUE);

                // update accel_res
                accel_res.Update();

                // accel_res --> entry->m_data
                entry->m_data = accel_res.data();
            }
        }

        // make it non-read-only
        Edit_SetReadOnly(m_hCodeEditor, FALSE);

        // select the entry
        if (entry == g_res.get_entry())
            SelectTV(entry, FALSE);

        // ready
        ChangeStatusText(IDS_READY);
    }
    else if (entry->m_type == RT_MENU)
    {
        // entry->m_data --> menu_res
        MenuRes menu_res;
        MByteStreamEx stream(entry->m_data);
        if (menu_res.LoadFromStream(stream))
        {
            // editing...
            ChangeStatusText(IDS_EDITINGBYGUI);

            // show the dialog
            MEditMenuDlg dialog(menu_res);
            INT nID = (INT)dialog.DialogBoxDx(hwnd);
            if (nID == IDOK && entry == g_res.get_entry())
            {
                DoSetFileModified(TRUE);

                // update menu_res
                menu_res.Update();

                // menu_res --> entry->m_data
                entry->m_data = menu_res.data();
            }
        }

        // make it non-read-only
        Edit_SetReadOnly(m_hCodeEditor, FALSE);

        // select the entry
        if (entry == g_res.get_entry())
            SelectTV(entry, FALSE);

        // ready
        ChangeStatusText(IDS_READY);
    }
    else if (entry->m_type == RT_TOOLBAR)
    {
        // entry->m_data --> toolbar_res
        ToolbarRes toolbar_res;
        MByteStreamEx stream(entry->m_data);
        if (toolbar_res.LoadFromStream(stream))
        {
            // editing...
            ChangeStatusText(IDS_EDITINGBYGUI);

            // show the dialog
            MEditToolbarDlg dialog(toolbar_res);
            INT nID = (INT)dialog.DialogBoxDx(hwnd);
            if (nID == IDOK && entry == g_res.get_entry())
            {
                DoSetFileModified(TRUE);

                // toolbar_res --> entry->m_data
                entry->m_data = toolbar_res.data();
            }
        }

        // make it non-read-only
        Edit_SetReadOnly(m_hCodeEditor, FALSE);

        // select the entry
        if (entry == g_res.get_entry())
            SelectTV(entry, FALSE);

        // ready
        ChangeStatusText(IDS_READY);
    }
    else if (entry->m_type == RT_DIALOG)
    {
        // editing...
        ChangeStatusText(IDS_EDITINGBYGUI);

        // entry->m_data --> m_rad_window.m_dialog_res
        MByteStreamEx stream(entry->m_data);
        m_rad_window.m_dialog_res.LoadFromStream(stream);
        m_rad_window.m_dialog_res.m_lang = entry->m_lang;
        m_rad_window.m_dialog_res.m_name = entry->m_name;
        m_rad_window.clear_maps();
        m_rad_window.create_maps(entry->m_lang);

        // load RT_DLGINIT
        if (auto e = g_res.find(ET_LANG, RT_DLGINIT, entry->m_name, entry->m_lang))
        {
            m_rad_window.m_dialog_res.LoadDlgInitData(e->m_data);
        }
        else if (auto e = g_res.find(ET_LANG, RT_DLGINIT, entry->m_name, BAD_LANG))
        {
            m_rad_window.m_dialog_res.LoadDlgInitData(e->m_data);
        }

        // recreate the RADical dialog
        if (::IsWindow(m_rad_window))
        {
            m_rad_window.ReCreateRadDialog(m_rad_window);
        }
        else
        {
            if (!m_rad_window.CreateDx(m_hwnd))
            {
                ErrorBoxDx(IDS_DLGFAIL);
            }
        }

        // make it non-read-only
        Edit_SetReadOnly(m_hCodeEditor, FALSE);
    }
    else if (entry->m_type == RT_DLGINIT)
    {
        // entry->m_data --> dlginit_res
        DlgInitRes dlginit_res;
        MByteStreamEx stream(entry->m_data);
        if (dlginit_res.LoadFromStream(stream))
        {
            // editing...
            ChangeStatusText(IDS_EDITINGBYGUI);

            // show the dialog
            MDlgInitDlg dialog(dlginit_res);
            INT nID = (INT)dialog.DialogBoxDx(hwnd);
            if (nID == IDOK && entry == g_res.get_entry())
            {
                DoSetFileModified(TRUE);

                // dlginit_res --> entry->m_data
                entry->m_data = dlginit_res.data();
            }
        }

        // make it non-read-only
        Edit_SetReadOnly(m_hCodeEditor, FALSE);

        // select the entry
        if (entry == g_res.get_entry())
            SelectTV(entry, FALSE);

        // ready
        ChangeStatusText(IDS_READY);
    }
    else if (entry->m_type == RT_STRING && entry->m_et == ET_STRING)
    {
        // g_res --> found
        WORD lang = entry->m_lang;
        EntrySet found;
        g_res.search(found, ET_LANG, RT_STRING, WORD(0), lang);

        // found --> str_res
        StringRes str_res;
        for (auto e : found)
        {
            MByteStreamEx stream(e->m_data);
            if (!str_res.LoadFromStream(stream, e->m_name.m_id))
            {
                ErrorBoxDx(IDS_CANNOTLOAD);
                return;
            }
        }

        // editing...
        ChangeStatusText(IDS_EDITINGBYGUI);

        // show the dialog
        MStringsDlg dialog(str_res);
        INT nID = (INT)dialog.DialogBoxDx(hwnd);
        if (nID == IDOK)
        {
            DoSetFileModified(TRUE);

            // dialog --> str_res
            str_res = dialog.m_str_res;

            // dump (with disabling macro IDs)
            bool shown = !g_settings.bHideID;
            g_settings.bHideID = false;
            MStringW strWide = str_res.Dump();
            g_settings.bHideID = !shown;

            // compile the dumped result
            MStringA strOutput;
            if (CompileParts(strOutput, RT_STRING, WORD(0), lang, strWide))
            {
                m_nStatusStringID = IDS_RECOMPILEOK;

                // select the entry to update the source
                SelectTV(ET_STRING, RT_STRING, WORD(0), lang, FALSE);
            }
            else
            {
                m_nStatusStringID = IDS_RECOMPILEFAILED;
                SetErrorMessage(strOutput);
            }
        }

        // make it non-read-only
        Edit_SetReadOnly(m_hCodeEditor, FALSE);

        // ready
        ChangeStatusText(IDS_READY);
    }
    else if (entry->m_type == RT_MESSAGETABLE && entry->m_et == ET_MESSAGE)
    {
        if (g_settings.bUseMSMSGTABLE)
            return;

        // g_res --> found
        WORD lang = entry->m_lang;
        EntrySet found;
        g_res.search(found, ET_LANG, RT_MESSAGETABLE, WORD(0), lang);

        // found --> msg_res
        MessageRes msg_res;
        for (auto e : found)
        {
            MByteStreamEx stream(e->m_data);
            if (!msg_res.LoadFromStream(stream, e->m_name.m_id))
            {
                ErrorBoxDx(IDS_CANNOTLOAD);
                return;
            }
        }

        // editing...
        ChangeStatusText(IDS_EDITINGBYGUI);

        // show the dialog
        MMessagesDlg dialog(msg_res);
        INT nID = (INT)dialog.DialogBoxDx(hwnd);
        if (nID == IDOK)
        {
            DoSetFileModified(TRUE);

            // dialog --> msg_res
            msg_res = dialog.m_msg_res;

            // dump (with disabling macro IDs)
            bool shown = !g_settings.bHideID;
            g_settings.bHideID = false;
            MStringW strWide = msg_res.Dump();
            g_settings.bHideID = !shown;

            // compile the dumped result
            MStringA strOutput;
            if (CompileParts(strOutput, RT_MESSAGETABLE, WORD(1), lang, strWide))
            {
                m_nStatusStringID = IDS_RECOMPILEOK;

                // select the entry
                SelectTV(ET_MESSAGE, RT_MESSAGETABLE, (WORD)0, lang, FALSE);
            }
            else
            {
                m_nStatusStringID = IDS_RECOMPILEFAILED;
                SetErrorMessage(strOutput);
            }
        }

        Edit_SetReadOnly(m_hCodeEditor, g_settings.bUseMSMSGTABLE);

        // ready
        ChangeStatusText(IDS_READY);
    }
}

MStringW
GetResTypeEncoding(const MIdOrString& type)
{
    MStringW name;

    if (type.m_id)
    {
        name = g_db.GetName(L"RESOURCE", type.m_id);
        if (name.empty())
            name = mstr_dec_word(type.m_id);
    }
    else
    {
        name = type.str();
    }

    auto it = g_settings.encoding_map.find(name);
    if (it != g_settings.encoding_map.end())
        return it->second;

    return L"";
}

bool MMainWnd::IsEntryTextEditable(const EntryBase *entry)
{
    if (!entry)
        return false;

    if (entry->is_editable(m_szVCBat))
        return true;

    auto enc = GetResTypeEncoding(entry->m_type);
    if (enc.size() && enc != L"bin")
        return true;

    return false;
}

// do text edit
void MMainWnd::OnEdit(HWND hwnd)
{
    // compile if necessary
    if (!CompileIfNecessary(::IsWindowVisible(m_rad_window)))
        return;

    // get the selected entry
    auto entry = g_res.get_entry();
    if (!IsEntryTextEditable(entry))
        return;

    // make it non-read-only
    Edit_SetReadOnly(m_hCodeEditor, FALSE);

    // select the entry
    SelectTV(entry, TRUE);
}

void MMainWnd::OnOpenLocalFile(HWND hwnd, LPCWSTR filename)
{
    // compile if necessary
    if (!CompileIfNecessary(::IsWindowVisible(m_rad_window)))
        return;

    // get the module path filename of this application module
    WCHAR szPath[MAX_PATH];
    GetModuleFileNameW(NULL, szPath, _countof(szPath));

    LPWSTR pch = PathFindFileNameW(szPath);
    *pch = 0;

    for (INT m = 0; m <= 3; ++m)
    {
        MString strPath = szPath;
        for (INT n = 0; n < m; ++n)
            strPath += L"..\\";

        strPath += filename;

        if (PathFileExistsW(strPath.c_str()))
        {
            // open it
            ShellExecuteW(hwnd, NULL, strPath.c_str(), NULL, NULL, SW_SHOWNORMAL);
            return;
        }
    }
}

// do UPX test to check whether the file is compressed or not
BOOL MMainWnd::DoUpxTest(LPCWSTR pszUpx, LPCWSTR pszFile)
{
    // build the command line text
    MStringW strCmdLine;
    strCmdLine += L"\"";
    strCmdLine += pszUpx;
    strCmdLine += L"\" -t \"";
    strCmdLine += pszFile;
    strCmdLine += L"\"";
    //MessageBoxW(hwnd, strCmdLine.c_str(), NULL, 0);

    BOOL bOK = FALSE;

    // create an upx.exe process
    MProcessMaker pmaker;
    pmaker.SetShowWindow(SW_HIDE);
    pmaker.SetCreationFlags(CREATE_NEW_CONSOLE);

    MFile hInputWrite, hOutputRead;
    if (pmaker.PrepareForRedirect(&hInputWrite, &hOutputRead) &&
        pmaker.CreateProcessDx(NULL, strCmdLine.c_str()))
    {
        // read all with timeout
        MStringA strOutput;
        pmaker.ReadAll(strOutput, hOutputRead, PROCESS_TIMEOUT);
        pmaker.WaitForSingleObject(PROCESS_TIMEOUT);

        if (pmaker.GetExitCode() == 0)
        {
            if (strOutput.find("[OK]") != MStringA::npos)
            {
                // success
                bOK = TRUE;
            }
        }
    }

    return bOK;
}

// do UPX extract to decompress the file
BOOL MMainWnd::DoUpxDecompress(LPCWSTR pszUpx, LPCWSTR pszFile)
{
    // build the command line text
    MStringW strCmdLine;
    strCmdLine += L"\"";
    strCmdLine += pszUpx;
    strCmdLine += L"\" -d \"";
    strCmdLine += pszFile;
    strCmdLine += L"\"";
    //MessageBoxW(hwnd, strCmdLine.c_str(), NULL, 0);

    BOOL bOK = FALSE;

    // create the upx.exe process
    MProcessMaker pmaker;
    pmaker.SetShowWindow(SW_HIDE);
    pmaker.SetCreationFlags(CREATE_NEW_CONSOLE);

    MFile hInputWrite, hOutputRead;
    if (pmaker.PrepareForRedirect(&hInputWrite, &hOutputRead) &&
        pmaker.CreateProcessDx(NULL, strCmdLine.c_str()))
    {
        // read all with timeout
        MStringA strOutput;
        bOK = pmaker.ReadAll(strOutput, hOutputRead, PROCESS_TIMEOUT);
        pmaker.WaitForSingleObject(PROCESS_TIMEOUT);

        if (pmaker.GetExitCode() == 0 && bOK)
        {
            DebugPrintDx("%s\n", strOutput.c_str());
            bOK = (strOutput.find("Unpacked") != MStringA::npos);
        }
    }

    return bOK;
}

// for debugging purpose
void MMainWnd::OnDebugTreeNode(HWND hwnd)
{
    WCHAR sz[MAX_PATH * 2 + 32];

    // show the file paths
    StringCchPrintfW(sz, _countof(sz), L"%s\n\n%s", m_szFile, m_szResourceH);
    MsgBoxDx(sz, MB_ICONINFORMATION);

    // get the selected entry
    auto entry = g_res.get_entry();
    if (!entry)
        return;

    static const LPCWSTR apszI_[] =
    {
        L"ET_ANY",
        L"ET_TYPE",
        L"ET_STRING",
        L"ET_MESSAGE",
        L"ET_NAME",
        L"ET_LANG"
    };

    MStringW type = entry->m_type.str();
    MStringW name = entry->m_name.str();
    StringCchPrintfW(sz, _countof(sz),
        L"%s: type:%s, name:%s, lang:0x%04X, entry:%p, hItem:%p, strLabel:%s", apszI_[entry->m_et],
        type.c_str(), name.c_str(), entry->m_lang, entry, entry->m_hItem, entry->m_strLabel.c_str());
    MsgBoxDx(sz, MB_ICONINFORMATION);
}

void MMainWnd::SetShowMode(SHOW_MODE mode)
{
    m_nShowMode = mode;
    if (g_settings.bShowBinEdit)
    {
        ShowWindow(m_hCodeEditor, SW_HIDE);
        ShowWindow(m_hBmpView, SW_HIDE);
        ShowWindow(m_hHexViewer, SW_SHOWNOACTIVATE);
        m_splitter2.SetPaneCount(1);
        m_splitter2.SetPane(0, m_hHexViewer);
    }
    else
    {
        switch (mode)
        {
        case SHOW_MOVIE:
            ShowWindow(m_hCodeEditor, SW_HIDE);
            ShowWindow(m_hBmpView, SW_SHOWNOACTIVATE);
            ShowWindow(m_hHexViewer, SW_HIDE);
            m_splitter2.SetPaneCount(1);
            m_splitter2.SetPane(0, m_hBmpView);
            break;
        case SHOW_CODEONLY:
            ShowWindow(m_hCodeEditor, SW_SHOWNOACTIVATE);
            ShowWindow(m_hBmpView, SW_HIDE);
            ShowWindow(m_hHexViewer, SW_HIDE);
            m_splitter2.SetPaneCount(1);
            m_splitter2.SetPane(0, m_hCodeEditor);
            break;
        case SHOW_CODEANDBMP:
            ShowWindow(m_hCodeEditor, SW_SHOWNOACTIVATE);
            ShowWindow(m_hBmpView, SW_SHOWNOACTIVATE);
            ShowWindow(m_hHexViewer, SW_HIDE);
            m_splitter2.SetPaneCount(2);
            m_splitter2.SetPane(0, m_hCodeEditor);
            m_splitter2.SetPane(1, m_hBmpView);
            m_splitter2.SetPaneExtent(1, g_settings.nBmpViewWidth);
            break;
        }
    }
    PostMessage(m_hwnd, WM_SIZE, 0, 0);
}

// show the status bar or not
void MMainWnd::ShowStatusBar(BOOL bShow/* = TRUE*/)
{
    if (bShow)
        ShowWindow(m_hStatusBar, SW_SHOWNOACTIVATE);
    else
        ShowWindow(m_hStatusBar, SW_HIDE);
}

// WM_MOVE: the main window has moved
void MMainWnd::OnMove(HWND hwnd, int x, int y)
{
    // is the window maximized or minimized?
    if (!IsZoomed(hwnd) && !IsIconic(hwnd))
    {
        // if so, then remember the position
        RECT rc;
        GetWindowRect(hwnd, &rc);
        g_settings.nWindowLeft = rc.left;
        g_settings.nWindowTop = rc.top;
    }
}

// WM_SIZE: the main window has changed in size
void MMainWnd::OnSize(HWND hwnd, UINT state, int cx, int cy)
{
    // auto move and resize the toolbar
    SendMessageW(m_hToolBar, TB_AUTOSIZE, 0, 0);

    // auto move and resize the status bar
    SendMessageW(m_hStatusBar, WM_SIZE, 0, 0);

    RECT rc, ClientRect;

    // is the main window maximized?
    if (IsZoomed(hwnd))
    {
        g_settings.bMaximized = TRUE;
    }
    else if (IsIconic(hwnd))   // is it minimized?
    {
        ;
    }
    else
    {
        // not maximized nor minimized
        // remember the size
        GetWindowRect(hwnd, &rc);
        g_settings.nWindowWidth = rc.right - rc.left;
        g_settings.nWindowHeight = rc.bottom - rc.top;
        g_settings.bMaximized = FALSE;
    }

    // get the client rectangle from the main window
    GetClientRect(hwnd, &ClientRect);
    SIZE sizClient = SizeFromRectDx(&ClientRect);

    // currently, the upper left corner of the client rectangle is (0, 0)
    INT x = 0, y = 0;

    // reserve the toolbar space
    if (::IsWindowVisible(m_hToolBar))
    {
        GetWindowRect(m_hToolBar, &rc);
        y += rc.bottom - rc.top;
        sizClient.cy -= rc.bottom - rc.top;
    }

    // reserve the status bar space
    if (::IsWindowVisible(m_hStatusBar))
    {
        INT anWidths[] = { ClientRect.right - CX_STATUS_PART, -1 };
        SendMessage(m_hStatusBar, SB_SETPARTS, 2, (LPARAM)anWidths);
        GetWindowRect(m_hStatusBar, &rc);
        sizClient.cy -= rc.bottom - rc.top;
    }

    // notify the size change to m_splitter1
    MoveWindow(m_splitter1, x, y, sizClient.cx, sizClient.cy, TRUE);

    // resize m_splitter2
    GetClientRect(m_tab, &rc);
    m_tab.AdjustRect(FALSE, &rc);
    MapWindowRect(m_tab, GetParent(m_splitter2), &rc);
    SIZE siz = SizeFromRectDx(&rc);
    MoveWindow(m_splitter2, rc.left, rc.top, siz.cx, siz.cy, TRUE);
}

// WM_INITMENU: update the menus
void MMainWnd::OnInitMenu(HWND hwnd, HMENU hMenu)
{
    if (g_settings.bWordWrap)
        CheckMenuItem(hMenu, ID_WORD_WRAP, MF_BYCOMMAND | MF_CHECKED);
    else
        CheckMenuItem(hMenu, ID_WORD_WRAP, MF_BYCOMMAND | MF_UNCHECKED);

    if (m_szResourceH[0])
        EnableMenuItem(hMenu, ID_UNLOADRESH, MF_BYCOMMAND | MF_ENABLED);
    else
        EnableMenuItem(hMenu, ID_UNLOADRESH, MF_BYCOMMAND | MF_GRAYED);

    // search the language entries
    EntrySet found;
    g_res.search(found, ET_LANG);

    if (found.empty())
    {
        EnableMenuItem(hMenu, ID_ITEMSEARCH, MF_GRAYED);
        EnableMenuItem(hMenu, ID_EXPAND_ALL, MF_GRAYED);
        EnableMenuItem(hMenu, ID_COLLAPSE_ALL, MF_GRAYED);
        EnableMenuItem(hMenu, ID_FIND, MF_GRAYED);
        EnableMenuItem(hMenu, ID_FINDUPWARD, MF_GRAYED);
        EnableMenuItem(hMenu, ID_FINDDOWNWARD, MF_GRAYED);
        EnableMenuItem(hMenu, ID_REPLACE, MF_GRAYED);
    }
    else
    {
        EnableMenuItem(hMenu, ID_ITEMSEARCH, MF_ENABLED);
        EnableMenuItem(hMenu, ID_EXPAND_ALL, MF_ENABLED);
        EnableMenuItem(hMenu, ID_COLLAPSE_ALL, MF_ENABLED);
        EnableMenuItem(hMenu, ID_FIND, MF_ENABLED);
        EnableMenuItem(hMenu, ID_FINDUPWARD, MF_ENABLED);
        EnableMenuItem(hMenu, ID_FINDDOWNWARD, MF_ENABLED);
        EnableMenuItem(hMenu, ID_REPLACE, MF_ENABLED);
    }

    if (g_settings.bShowToolBar)
        CheckMenuItem(hMenu, ID_SHOWHIDETOOLBAR, MF_BYCOMMAND | MF_CHECKED);
    else
        CheckMenuItem(hMenu, ID_SHOWHIDETOOLBAR, MF_BYCOMMAND | MF_UNCHECKED);

    if (g_settings.bUseBeginEnd)
        CheckMenuItem(hMenu, ID_USEBEGINEND, MF_BYCOMMAND | MF_CHECKED);
    else
        CheckMenuItem(hMenu, ID_USEBEGINEND, MF_BYCOMMAND | MF_UNCHECKED);

    if (g_settings.bUseMSMSGTABLE)
        CheckMenuItem(hMenu, ID_USEMSMSGTBL, MF_BYCOMMAND | MF_CHECKED);
    else
        CheckMenuItem(hMenu, ID_USEMSMSGTBL, MF_BYCOMMAND | MF_UNCHECKED);

    BOOL bCanEditLabel = TRUE;

    // get the selected entry
    auto entry = g_res.get_entry();
    if (!entry || entry->m_et == ET_TYPE)
    {
        bCanEditLabel = FALSE;
    }

    if (bCanEditLabel)
    {
        if (entry)
        {
            if (entry->m_et == ET_NAME || entry->m_et == ET_LANG)
            {
                if (entry->m_type == RT_STRING || entry->m_type == RT_MESSAGETABLE)
                {
                    bCanEditLabel = FALSE;
                }
            }
        }
        else
        {
            bCanEditLabel = FALSE;
        }
    }

    if (bCanEditLabel)
        EnableMenuItem(hMenu, ID_EDITLABEL, MF_BYCOMMAND | MF_ENABLED);
    else
        EnableMenuItem(hMenu, ID_EDITLABEL, MF_BYCOMMAND | MF_GRAYED);

    if (IsWindowVisible(m_hStatusBar))
        CheckMenuItem(hMenu, ID_STATUSBAR, MF_CHECKED);
    else
        CheckMenuItem(hMenu, ID_STATUSBAR, MF_UNCHECKED);

    if (g_settings.bShowBinEdit)
        CheckMenuItem(hMenu, ID_BINARYPANE, MF_CHECKED);
    else
        CheckMenuItem(hMenu, ID_BINARYPANE, MF_UNCHECKED);

    if (g_settings.bAlwaysControl)
        CheckMenuItem(hMenu, ID_ALWAYSCONTROL, MF_CHECKED);
    else
        CheckMenuItem(hMenu, ID_ALWAYSCONTROL, MF_UNCHECKED);

    if (g_settings.bHideID)
        CheckMenuItem(hMenu, ID_HIDEIDMACROS, MF_CHECKED);
    else
        CheckMenuItem(hMenu, ID_HIDEIDMACROS, MF_UNCHECKED);

    if (g_settings.bUseIDC_STATIC)
        CheckMenuItem(hMenu, ID_USEIDC_STATIC, MF_CHECKED);
    else
        CheckMenuItem(hMenu, ID_USEIDC_STATIC, MF_UNCHECKED);

    if (!entry || !entry->m_hItem)
    {
        EnableMenuItem(hMenu, ID_REPLACEICON, MF_GRAYED);
        EnableMenuItem(hMenu, ID_REPLACECURSOR, MF_GRAYED);
        EnableMenuItem(hMenu, ID_REPLACEBITMAP, MF_GRAYED);
        EnableMenuItem(hMenu, ID_REPLACEBIN, MF_GRAYED);
        EnableMenuItem(hMenu, ID_EXTRACTICON, MF_GRAYED);
        EnableMenuItem(hMenu, ID_EXTRACTCURSOR, MF_GRAYED);
        EnableMenuItem(hMenu, ID_EXTRACTBITMAP, MF_GRAYED);
        EnableMenuItem(hMenu, ID_EXTRACTBIN, MF_GRAYED);
        EnableMenuItem(hMenu, ID_DELETERES, MF_GRAYED);
        EnableMenuItem(hMenu, ID_TEST, MF_GRAYED);
        EnableMenuItem(hMenu, ID_EDIT, MF_GRAYED);
        EnableMenuItem(hMenu, ID_GUIEDIT, MF_GRAYED);
        EnableMenuItem(hMenu, ID_COPYASNEWNAME, MF_GRAYED);
        EnableMenuItem(hMenu, ID_COPYTOMULTILANG, MF_GRAYED);
        EnableMenuItem(hMenu, ID_EXTRACTRC, MF_GRAYED);
        return;
    }

    EnableMenuItem(hMenu, ID_EXTRACTRC, MF_ENABLED);

    BOOL bEditable = entry && entry->is_editable(m_szVCBat);
    if (bEditable)
    {
        EnableMenuItem(hMenu, ID_EDIT, MF_ENABLED);
        if (entry->can_gui_edit())
        {
            EnableMenuItem(hMenu, ID_GUIEDIT, MF_ENABLED);
        }
        else
        {
            EnableMenuItem(hMenu, ID_GUIEDIT, MF_GRAYED);
        }
    }
    else
    {
        EnableMenuItem(hMenu, ID_EDIT, MF_GRAYED);
        EnableMenuItem(hMenu, ID_GUIEDIT, MF_GRAYED);
    }

    switch (entry ? entry->m_et : ET_ANY)
    {
    case ET_TYPE:
        EnableMenuItem(hMenu, ID_REPLACEICON, MF_GRAYED);
        EnableMenuItem(hMenu, ID_REPLACECURSOR, MF_GRAYED);
        EnableMenuItem(hMenu, ID_REPLACEBITMAP, MF_GRAYED);
        EnableMenuItem(hMenu, ID_REPLACEBIN, MF_GRAYED);
        EnableMenuItem(hMenu, ID_EXTRACTICON, MF_GRAYED);
        EnableMenuItem(hMenu, ID_EXTRACTCURSOR, MF_GRAYED);
        EnableMenuItem(hMenu, ID_EXTRACTBITMAP, MF_GRAYED);
        EnableMenuItem(hMenu, ID_EXTRACTBIN, MF_ENABLED);
        EnableMenuItem(hMenu, ID_DELETERES, MF_ENABLED);
        EnableMenuItem(hMenu, ID_TEST, MF_GRAYED);
        EnableMenuItem(hMenu, ID_COPYASNEWNAME, MF_GRAYED);
        EnableMenuItem(hMenu, ID_COPYASNEWLANG, MF_GRAYED);
        EnableMenuItem(hMenu, ID_COPYTOMULTILANG, MF_GRAYED);
        break;
    case ET_NAME:
        EnableMenuItem(hMenu, ID_REPLACEICON, MF_GRAYED);
        EnableMenuItem(hMenu, ID_REPLACECURSOR, MF_GRAYED);
        EnableMenuItem(hMenu, ID_REPLACEBITMAP, MF_GRAYED);
        EnableMenuItem(hMenu, ID_REPLACEBIN, MF_GRAYED);
        EnableMenuItem(hMenu, ID_EXTRACTICON, MF_GRAYED);
        EnableMenuItem(hMenu, ID_EXTRACTCURSOR, MF_GRAYED);
        EnableMenuItem(hMenu, ID_EXTRACTBITMAP, MF_GRAYED);
        EnableMenuItem(hMenu, ID_EXTRACTBIN, MF_ENABLED);
        EnableMenuItem(hMenu, ID_DELETERES, MF_ENABLED);
        EnableMenuItem(hMenu, ID_TEST, MF_GRAYED);
        EnableMenuItem(hMenu, ID_COPYASNEWNAME, MF_ENABLED);
        EnableMenuItem(hMenu, ID_COPYASNEWLANG, MF_GRAYED);
        EnableMenuItem(hMenu, ID_COPYTOMULTILANG, MF_GRAYED);
        break;

    case ET_LANG:
        if (entry->m_type == RT_GROUP_ICON || entry->m_type == RT_ICON ||
            entry->m_type == RT_ANIICON)
        {
            EnableMenuItem(hMenu, ID_EXTRACTICON, MF_ENABLED);
        }
        else
        {
            EnableMenuItem(hMenu, ID_EXTRACTICON, MF_GRAYED);
        }
        if (entry->m_type == RT_GROUP_ICON || entry->m_type == RT_ANIICON)
        {
            EnableMenuItem(hMenu, ID_REPLACEICON, MF_ENABLED);
        }
        else
        {
            EnableMenuItem(hMenu, ID_REPLACEICON, MF_GRAYED);
        }

        if (entry->m_type == RT_BITMAP)
        {
            EnableMenuItem(hMenu, ID_EXTRACTBITMAP, MF_ENABLED);
            EnableMenuItem(hMenu, ID_REPLACEBITMAP, MF_ENABLED);
        }
        else
        {
            EnableMenuItem(hMenu, ID_EXTRACTBITMAP, MF_GRAYED);
            EnableMenuItem(hMenu, ID_REPLACEBITMAP, MF_GRAYED);
        }

        if (entry->m_type == RT_GROUP_CURSOR || entry->m_type == RT_CURSOR ||
            entry->m_type == RT_ANICURSOR)
        {
            EnableMenuItem(hMenu, ID_EXTRACTCURSOR, MF_ENABLED);
        }
        else
        {
            EnableMenuItem(hMenu, ID_EXTRACTCURSOR, MF_GRAYED);
        }
        if (entry->m_type == RT_GROUP_CURSOR || entry->m_type == RT_ANICURSOR)
        {
            EnableMenuItem(hMenu, ID_REPLACECURSOR, MF_ENABLED);
        }
        else
        {
            EnableMenuItem(hMenu, ID_REPLACECURSOR, MF_GRAYED);
        }

        if (entry->is_testable())
        {
            EnableMenuItem(hMenu, ID_TEST, MF_ENABLED);
        }
        else
        {
            EnableMenuItem(hMenu, ID_TEST, MF_GRAYED);
        }

        EnableMenuItem(hMenu, ID_REPLACEBIN, MF_ENABLED);
        EnableMenuItem(hMenu, ID_EXTRACTBIN, MF_ENABLED);
        EnableMenuItem(hMenu, ID_DELETERES, MF_ENABLED);
        EnableMenuItem(hMenu, ID_COPYASNEWNAME, MF_GRAYED);
        if (entry->m_type == RT_STRING || entry->m_type == RT_MESSAGETABLE)
        {
            EnableMenuItem(hMenu, ID_COPYASNEWLANG, MF_GRAYED);
            EnableMenuItem(hMenu, ID_COPYTOMULTILANG, MF_GRAYED);
        }
        else
        {
            EnableMenuItem(hMenu, ID_COPYASNEWLANG, MF_ENABLED);
            EnableMenuItem(hMenu, ID_COPYTOMULTILANG, MF_ENABLED);
        }
        break;

    case ET_STRING: case ET_MESSAGE:
        EnableMenuItem(hMenu, ID_REPLACEICON, MF_GRAYED);
        EnableMenuItem(hMenu, ID_REPLACECURSOR, MF_GRAYED);
        EnableMenuItem(hMenu, ID_REPLACEBITMAP, MF_GRAYED);
        EnableMenuItem(hMenu, ID_REPLACEBIN, MF_GRAYED);
        EnableMenuItem(hMenu, ID_EXTRACTICON, MF_GRAYED);
        EnableMenuItem(hMenu, ID_EXTRACTCURSOR, MF_GRAYED);
        EnableMenuItem(hMenu, ID_EXTRACTBITMAP, MF_GRAYED);
        EnableMenuItem(hMenu, ID_EXTRACTBIN, MF_ENABLED);
        EnableMenuItem(hMenu, ID_DELETERES, MF_ENABLED);
        EnableMenuItem(hMenu, ID_TEST, MF_GRAYED);
        EnableMenuItem(hMenu, ID_COPYASNEWNAME, MF_GRAYED);
        EnableMenuItem(hMenu, ID_COPYASNEWLANG, MF_ENABLED);
        EnableMenuItem(hMenu, ID_COPYTOMULTILANG, MF_GRAYED);
        break;

    default:
        EnableMenuItem(hMenu, ID_REPLACEICON, MF_GRAYED);
        EnableMenuItem(hMenu, ID_REPLACECURSOR, MF_GRAYED);
        EnableMenuItem(hMenu, ID_REPLACEBITMAP, MF_GRAYED);
        EnableMenuItem(hMenu, ID_REPLACEBIN, MF_GRAYED);
        EnableMenuItem(hMenu, ID_EXTRACTICON, MF_GRAYED);
        EnableMenuItem(hMenu, ID_EXTRACTCURSOR, MF_GRAYED);
        EnableMenuItem(hMenu, ID_EXTRACTBITMAP, MF_GRAYED);
        EnableMenuItem(hMenu, ID_EXTRACTBIN, MF_GRAYED);
        EnableMenuItem(hMenu, ID_DELETERES, MF_GRAYED);
        EnableMenuItem(hMenu, ID_COPYASNEWNAME, MF_GRAYED);
        EnableMenuItem(hMenu, ID_COPYASNEWLANG, MF_GRAYED);
        EnableMenuItem(hMenu, ID_COPYTOMULTILANG, MF_GRAYED);
        break;
    }
}

// WM_CONTEXTMENU: the context menu is shown
void MMainWnd::OnContextMenu(HWND hwnd, HWND hwndContext, UINT xPos, UINT yPos)
{
    if (hwndContext != m_hwndTV)
        return;     // ignore

    // if RADical window is displayed
    if (IsWindowVisible(m_rad_window))
    {
        // destroy it
        m_rad_window.DestroyWindow();
    }

    // get screen coordinates from xPos and yPos
    POINT pt = {(SHORT)xPos, (SHORT)yPos};
    HTREEITEM hItem;
    if (pt.x == -1 && pt.y == -1)
    {
        // context menu from keyboard
        hItem = TreeView_GetSelection(hwndContext);

        RECT rc;
        TreeView_GetItemRect(hwndContext, hItem, &rc, FALSE);
        pt.x = (rc.left + rc.right) / 2;
        pt.y = (rc.top + rc.bottom) / 2;
    }
    else
    {
        // context menu from mouse
        ScreenToClient(hwndContext, &pt);

        // hit test
        TV_HITTESTINFO HitTest;
        ZeroMemory(&HitTest, sizeof(HitTest));
        HitTest.pt = pt;
        TreeView_HitTest(hwndContext, &HitTest);
        hItem = HitTest.hItem;
    }

    // select the item
    TreeView_SelectItem(hwndContext, hItem);

    // load the menu
    HMENU hMenu = LoadMenuW(m_hInst, MAKEINTRESOURCEW(IDR_POPUPMENUS));
    OnInitMenu(hwnd, hMenu);
    HMENU hSubMenu = ::GetSubMenu(hMenu, 0);
    if (hMenu == NULL || hSubMenu == NULL)
        return;

    // convert the client coordinates to the screen coordinates
    ClientToScreen(hwndContext, &pt);

    // See: https://msdn.microsoft.com/en-us/library/windows/desktop/ms648002.aspx
    SetForegroundWindow(hwndContext);

    UINT Flags = TPM_LEFTALIGN | TPM_RIGHTBUTTON | TPM_RETURNCMD;
    INT id = TrackPopupMenu(hSubMenu, Flags, pt.x, pt.y, 0, hwndContext, NULL);

    // See: https://msdn.microsoft.com/en-us/library/windows/desktop/ms648002.aspx
    PostMessageW(hwndContext, WM_NULL, 0, 0);

    // destroy the menu
    DestroyMenu(hMenu);

    if (id)
    {
        // execute the command
        SendMessageW(hwnd, WM_COMMAND, id, 0);
    }
}

// preview the icon resource
void MMainWnd::PreviewIcon(HWND hwnd, const EntryBase& entry)
{
    // create a bitmap object from the entry and set it to m_hBmpView
    BITMAP bm;
    m_hBmpView.SetBitmap(CreateBitmapFromIconOrPngDx(hwnd, entry, bm));

    // create the icon
    MStringW str;
    HICON hIcon = PackedDIB_CreateIcon(&entry[0], entry.size(), bm, TRUE);

    // dump info to m_hCodeEditor
    if (hIcon)
    {
        str = DumpIconInfo(bm, TRUE);
    }
    else
    {
        str = DumpBitmapInfo(m_hBmpView.m_hBitmap);
    }
    SetWindowTextW(m_hCodeEditor, str.c_str());

    // destroy the icon
    DestroyIcon(hIcon);

    // show
    SetShowMode(SHOW_CODEANDBMP);
}

// preview the cursor resource
void MMainWnd::PreviewCursor(HWND hwnd, const EntryBase& entry)
{
    // create a cursor object from the entry and set it to m_hBmpView
    BITMAP bm;
    HCURSOR hCursor = PackedDIB_CreateIcon(&entry[0], entry.size(), bm, FALSE);
    m_hBmpView.SetBitmap(CreateBitmapFromIconDx(hCursor, bm.bmWidth, bm.bmHeight, TRUE));

    // dump info to m_hCodeEditor
    MStringW str = DumpIconInfo(bm, FALSE);
    SetWindowTextW(m_hCodeEditor, str.c_str());

    // destroy the cursor
    DestroyCursor(hCursor);

    // show
    SetShowMode(SHOW_CODEANDBMP);
}

// preview the group icon resource
void MMainWnd::PreviewGroupIcon(HWND hwnd, const EntryBase& entry)
{
    // create a bitmap object from the entry and set it to m_hBmpView
    m_hBmpView.SetBitmap(CreateBitmapFromIconsDx(hwnd, entry));

    // dump the text to m_hCodeEditor
    ResToText res2text;
    MString str = res2text.DumpEntry(entry);
    SetWindowTextW(m_hCodeEditor, str.c_str());

    // show
    SetShowMode(SHOW_CODEANDBMP);
}

// preview the group cursor resource
void MMainWnd::PreviewGroupCursor(HWND hwnd, const EntryBase& entry)
{
    // create a bitmap object from the entry and set it to m_hBmpView
    m_hBmpView.SetBitmap(CreateBitmapFromCursorsDx(hwnd, entry));
    assert(m_hBmpView);

    // dump the text to m_hCodeEditor
    ResToText res2text;
    MString str = res2text.DumpEntry(entry);
    SetWindowTextW(m_hCodeEditor, str.c_str());

    // show
    SetShowMode(SHOW_CODEANDBMP);
}

// preview the bitmap resource
void MMainWnd::PreviewBitmap(HWND hwnd, const EntryBase& entry)
{
    // create a bitmap object from the entry and set it to m_hBmpView
    HBITMAP hbm = PackedDIB_CreateBitmapFromMemory(&entry[0], entry.size());
    m_hBmpView.SetBitmap(hbm);

    // dump the text to m_hCodeEditor
    ResToText res2text;
    MString str = res2text.DumpEntry(entry);
    SetWindowTextW(m_hCodeEditor, str.c_str());

    // show
    SetShowMode(SHOW_CODEANDBMP);
}

// preview the image resource
void MMainWnd::PreviewImage(HWND hwnd, const EntryBase& entry)
{
    // dump the text to m_hCodeEditor
    ResToText res2text;
    MStringW str = res2text.DumpEntry(entry);
    SetWindowTextW(m_hCodeEditor, str.c_str());

    // set the entry image to m_hBmpView
    m_hBmpView.SetImage(&entry[0], entry.size());

    // show
    SetShowMode(SHOW_CODEANDBMP);
}

// preview the WAVE resource
void MMainWnd::PreviewWAVE(HWND hwnd, const EntryBase& entry)
{
    // dump the text to m_hCodeEditor
    ResToText res2text;
    MString str = res2text.DumpEntry(entry);
    SetWindowTextW(m_hCodeEditor, str.c_str());

    // make it playable
    m_hBmpView.SetPlay();

    // show
    SetShowMode(SHOW_CODEANDBMP);
}

// preview the AVI resource
void MMainWnd::PreviewAVI(HWND hwnd, const EntryBase& entry)
{
    // dump the text to m_hCodeEditor
    ResToText res2text;
    MString str = res2text.DumpEntry(entry);
    SetWindowTextW(m_hCodeEditor, str.c_str());

    // set the AVI
    m_hBmpView.SetMedia(&entry[0], entry.size());

    // show movie
    SetShowMode(SHOW_MOVIE);
}

// preview the RT_ACCELERATOR resource
void MMainWnd::PreviewAccel(HWND hwnd, const EntryBase& entry)
{
    // entry.m_data --> stream --> accel
    AccelRes accel;
    MByteStreamEx stream(entry.m_data);
    if (accel.LoadFromStream(stream))
    {
        // dump the text to m_hCodeEditor
        MString str = GetLanguageStatement(entry.m_lang);
        str += accel.Dump(entry.m_name);
        SetWindowTextW(m_hCodeEditor, str.c_str());
    }
}

// preview the message table resource
void MMainWnd::PreviewMessage(HWND hwnd, const EntryBase& entry)
{
    // entry.m_data --> stream --> mes
    MessageRes mes;
    MByteStreamEx stream(entry.m_data);
    WORD nNameID = entry.m_name.m_id;
    if (mes.LoadFromStream(stream, nNameID))
    {
        // dump the text to m_hCodeEditor
        MStringW str = mes.Dump(nNameID);
        SetWindowTextW(m_hCodeEditor, str.c_str());
    }
}

// preview the string resource
void MMainWnd::PreviewString(HWND hwnd, const EntryBase& entry)
{
    // entry.m_data --> stream --> str_res
    StringRes str_res;
    MByteStreamEx stream(entry.m_data);
    WORD nNameID = entry.m_name.m_id;
    if (str_res.LoadFromStream(stream, nNameID))
    {
        // dump the text to m_hCodeEditor
        MStringW str = str_res.Dump(nNameID);
        SetWindowTextW(m_hCodeEditor, str.c_str());
    }
}

// preview the HTML resource
void MMainWnd::PreviewHtml(HWND hwnd, const EntryBase& entry)
{
    // load a text file
    MTextType type;
    type.nNewLine = MNEWLINE_CRLF;
    MStringW str;
    if (entry.size())
        str = mstr_from_bin(&entry.m_data[0], entry.m_data.size(), &type);

    // dump the text to m_hCodeEditor
    SetWindowTextW(m_hCodeEditor, str.c_str());
}

// preview the menu resource
void MMainWnd::PreviewMenu(HWND hwnd, const EntryBase& entry)
{
    // entry.m_data --> stream --> menu_res
    MenuRes menu_res;
    MByteStreamEx stream(entry.m_data);
    if (menu_res.LoadFromStream(stream))
    {
        // dump the text to m_hCodeEditor
        MString str = GetLanguageStatement(entry.m_lang);
        str += menu_res.Dump(entry.m_name);
        SetWindowTextW(m_hCodeEditor, str.c_str());
    }
}

// preview the TOOLBAR resource
void MMainWnd::PreviewToolbar(HWND hwnd, const EntryBase& entry)
{
    // entry.m_data --> stream --> toolbar_res
    ToolbarRes toolbar_res;
    MByteStreamEx stream(entry.m_data);
    if (toolbar_res.LoadFromStream(stream))
    {
        // dump the text to m_hCodeEditor
        MString str = GetLanguageStatement(entry.m_lang);
        str += toolbar_res.Dump(entry.m_name);
        SetWindowTextW(m_hCodeEditor, str.c_str());
    }
}

// preview the version resource
void MMainWnd::PreviewVersion(HWND hwnd, const EntryBase& entry)
{
    // entry.m_data --> ver_res
    VersionRes ver_res;
    if (ver_res.LoadFromData(entry.m_data))
    {
        // dump the text to m_hCodeEditor
        MString str = GetLanguageStatement(entry.m_lang);
        str += ver_res.Dump(entry.m_name);
        SetWindowTextW(m_hCodeEditor, str.c_str());
    }
}

// preview the unknown resource
void MMainWnd::PreviewUnknown(HWND hwnd, const EntryBase& entry)
{
    // dump the text to m_hCodeEditor
    ResToText res2text;
    MString str = res2text.DumpEntry(entry);
    SetWindowTextW(m_hCodeEditor, str.c_str());
}

void MMainWnd::PreviewTypeLib(HWND hwnd, const EntryBase& entry)
{
    // dump the text to m_hCodeEditor
    ResToText res2text;
    res2text.m_hwnd = m_hwnd;
    res2text.m_bHumanReadable = TRUE;
    MString str = res2text.DumpEntry(entry);
    SetWindowTextW(m_hCodeEditor, str.c_str());
}

// preview the RT_RCDATA resource
void MMainWnd::PreviewRCData(HWND hwnd, const EntryBase& entry)
{
    // dump the text to m_hCodeEditor
    ResToText res2text;
    res2text.m_hwnd = m_hwnd;
    res2text.m_bHumanReadable = TRUE;
    MString str = res2text.DumpEntry(entry);
    SetWindowTextW(m_hCodeEditor, str.c_str());
}

// preview the DLGINIT resource
void MMainWnd::PreviewDlgInit(HWND hwnd, const EntryBase& entry)
{
    // dump the text to m_hCodeEditor
    ResToText res2text;
    MString str = res2text.DumpEntry(entry);
    SetWindowTextW(m_hCodeEditor, str.c_str());
}

// preview the dialog template resource
void MMainWnd::PreviewDialog(HWND hwnd, const EntryBase& entry)
{
    // entry.m_data --> stream --> dialog_res
    DialogRes dialog_res;
    MByteStreamEx stream(entry.m_data);
    if (dialog_res.LoadFromStream(stream))
    {
        // dump the text to m_hCodeEditor
        MString str = GetLanguageStatement(entry.m_lang);
        str += dialog_res.Dump(entry.m_name, !!g_settings.bAlwaysControl);
        SetWindowTextW(m_hCodeEditor, str.c_str());
    }
}

// preview the animation icon resource
void MMainWnd::PreviewAniIcon(HWND hwnd, const EntryBase& entry, BOOL bIcon)
{
    HICON hIcon = NULL;

    {
        WCHAR szPath[MAX_PATH], szTempFile[MAX_PATH];
        GetTempPathW(_countof(szPath), szPath);
        GetTempFileNameW(szPath, L"ani", 0, szTempFile);

        MFile file;
        DWORD cbWritten = 0;
        if (file.OpenFileForOutput(szTempFile) &&
            file.WriteFile(&entry[0], entry.size(), &cbWritten))
        {
            file.FlushFileBuffers();    // flush
            file.CloseHandle();         // close the handle

            if (bIcon)
            {
                hIcon = (HICON)LoadImage(NULL, szTempFile, IMAGE_ICON,
                    0, 0, LR_LOADFROMFILE);
            }
            else
            {
                hIcon = (HICON)LoadImage(NULL, szTempFile, IMAGE_CURSOR,
                    0, 0, LR_LOADFROMFILE);
            }
        }
        DeleteFileW(szTempFile);
    }

    if (hIcon)
    {
        m_hBmpView.SetIcon(hIcon, bIcon);

        ResToText res2text;
        MString str = res2text.DumpEntry(entry);
        SetWindowTextW(m_hCodeEditor, str.c_str());
    }
    else
    {
        m_hBmpView.DestroyView();
    }

    // show
    SetShowMode(SHOW_CODEANDBMP);

    // show
    SetShowMode(SHOW_CODEANDBMP);
}

// preview the string table resource
void MMainWnd::PreviewStringTable(HWND hwnd, const EntryBase& entry)
{
    // search the strings
    EntrySet found;
    g_res.search(found, ET_LANG, RT_STRING, (WORD)0, entry.m_lang);

    // found --> str_res
    StringRes str_res;
    for (auto e : found)
    {
        MByteStreamEx stream(e->m_data);
        if (!str_res.LoadFromStream(stream, e->m_name.m_id))
            return;
    }

    // dump the text to m_hCodeEditor
    MString str = GetLanguageStatement(entry.m_lang);
    str += str_res.Dump();
    SetWindowTextW(m_hCodeEditor, str.c_str());

    // show code only
    SetShowMode(SHOW_CODEONLY);
}

// preview the message table resource
void MMainWnd::PreviewMessageTable(HWND hwnd, const EntryBase& entry)
{
    // search the message tables
    EntrySet found;
    g_res.search(found, ET_LANG, RT_MESSAGETABLE, (WORD)0, entry.m_lang);

    // dump the text to m_hCodeEditor
    MString str;
    str += GetLanguageStatement(entry.m_lang);
    if (g_settings.bUseMSMSGTABLE)
    {
        ResToText res2text;
        str = res2text.DumpEntry(entry);
    }
    else
    {
        // found --> msg_res
        MessageRes msg_res;
        for (auto e : found)
        {
            MByteStreamEx stream(e->m_data);
            if (!msg_res.LoadFromStream(stream, e->m_name.m_id))
                return;
        }

        str += L"#ifdef APSTUDIO_INVOKED\r\n";
        str += L"    #error Ap Studio cannot edit this message table.\r\n";
        str += L"#endif\r\n";
        str += L"#ifdef MCDX_INVOKED\r\n";
        str += msg_res.Dump();
        str += L"#endif\r\n\r\n";
    }
    SetWindowTextW(m_hCodeEditor, str.c_str());
    ::SendMessageW(m_hCodeEditor, LNEM_CLEARLINEMARKS, 0, 0);

    // show code only
    SetShowMode(SHOW_CODEONLY);
}

// close the preview
VOID MMainWnd::HidePreview(STV stv)
{
    // destroy the RADical window if any
    if (IsWindow(m_rad_window))
    {
        m_rad_window.DestroyWindow();
    }

    // clear m_hHexViewer
    SetWindowTextW(m_hHexViewer, NULL);
    Edit_SetModify(m_hHexViewer, FALSE);

    // clear m_hCodeEditor
    if (stv == STV_RESETTEXT || stv == STV_RESETTEXTANDMODIFIED)
    {
        SetWindowTextW(m_hCodeEditor, NULL);
        ::SendMessageW(m_hCodeEditor, LNEM_CLEARLINEMARKS, 0, 0);
    }
    if (stv != STV_DONTRESET)
    {
        Edit_SetModify(m_hCodeEditor, FALSE);
    }

    // close and hide m_hBmpView
    m_hBmpView.DestroyView();

    // Code Viewer only
    SetShowMode(SHOW_CODEONLY);

    // recalculate the splitter
    PostMessageDx(WM_SIZE);
}

// do preview the resource item
BOOL MMainWnd::Preview(HWND hwnd, const EntryBase *entry, STV stv)
{
    // close the preview
    HidePreview(stv);

    if (stv == STV_DONTRESET)
        return IsEntryTextEditable(entry);

    // show the binary
    MStringW str = DumpBinaryAsText(entry->m_data);
    SetWindowTextW(m_hHexViewer, str.c_str());

    // code only
    SetShowMode(SHOW_CODEONLY);

    // do preview the resource item
    if (entry->m_type.m_id != 0)
    {
        WORD wType = entry->m_type.m_id;
        if (wType == (WORD)(UINT_PTR)RT_ICON)
        {
            PreviewIcon(hwnd, *entry);
        }
        else if (wType == (WORD)(UINT_PTR)RT_CURSOR)
        {
            PreviewCursor(hwnd, *entry);
        }
        else if (wType == (WORD)(UINT_PTR)RT_GROUP_ICON)
        {
            PreviewGroupIcon(hwnd, *entry);
        }
        else if (wType == (WORD)(UINT_PTR)RT_GROUP_CURSOR)
        {
            PreviewGroupCursor(hwnd, *entry);
        }
        else if (wType == (WORD)(UINT_PTR)RT_BITMAP)
        {
            PreviewBitmap(hwnd, *entry);
        }
        else if (wType == (WORD)(UINT_PTR)RT_ACCELERATOR)
        {
            PreviewAccel(hwnd, *entry);
        }
        else if (wType == (WORD)(UINT_PTR)RT_STRING)
        {
            PreviewString(hwnd, *entry);
        }
        else if (wType == (WORD)(UINT_PTR)RT_MENU)
        {
            PreviewMenu(hwnd, *entry);
        }
        else if (wType == (WORD)(UINT_PTR)RT_TOOLBAR)
        {
            PreviewToolbar(hwnd, *entry);
        }
        else if (wType == (WORD)(UINT_PTR)RT_DIALOG)
        {
            PreviewDialog(hwnd, *entry);
        }
        else if (wType == (WORD)(UINT_PTR)RT_ANIICON)
        {
            PreviewAniIcon(hwnd, *entry, TRUE);
        }
        else if (wType == (WORD)(UINT_PTR)RT_ANICURSOR)
        {
            PreviewAniIcon(hwnd, *entry, FALSE);
        }
        else if (wType == (WORD)(UINT_PTR)RT_MESSAGETABLE)
        {
            PreviewMessage(hwnd, *entry);
        }
        else if (wType == (WORD)(UINT_PTR)RT_MANIFEST || wType == (WORD)(UINT_PTR)RT_HTML)
        {
            PreviewHtml(hwnd, *entry);
        }
        else if (wType == (WORD)(UINT_PTR)RT_VERSION)
        {
            PreviewVersion(hwnd, *entry);
        }
        else if (wType == (WORD)(UINT_PTR)RT_RCDATA)
        {
            PreviewRCData(hwnd, *entry);
        }
        else if (wType == (WORD)(UINT_PTR)RT_DLGINIT)
        {
            PreviewDlgInit(hwnd, *entry);
        }
        else
        {
            PreviewUnknown(hwnd, *entry);
        }
    }
    else
    {
        if (entry->m_type == L"PNG" || entry->m_type == L"GIF" ||
            entry->m_type == L"JPEG" || entry->m_type == L"TIFF" ||
            entry->m_type == L"JPG" || entry->m_type == L"TIF" ||
            entry->m_type == L"EMF" || entry->m_type == L"ENHMETAFILE" ||
            entry->m_type == L"ENHMETAPICT" ||
            entry->m_type == L"WMF" || entry->m_type == L"IMAGE")
        {
            PreviewImage(hwnd, *entry);
        }
        else if (entry->m_type == L"WAVE")
        {
            PreviewWAVE(hwnd, *entry);
        }
        else if (entry->m_type == L"AVI")
        {
            PreviewAVI(hwnd, *entry);
        }
        else if (entry->m_type == L"TYPELIB")
        {
            PreviewTypeLib(hwnd, *entry);
        }
        else
        {
            PreviewUnknown(hwnd, *entry);
        }
    }

    // recalculate the splitter
    PostMessageDx(WM_SIZE);

    return IsEntryTextEditable(entry);
}

// create the toolbar
BOOL MMainWnd::CreateOurToolBar(HWND hwndParent, HIMAGELIST himlTools)
{
    // create a toolbar
    HWND hwndTB = CreateWindowW(TOOLBARCLASSNAME, NULL,
        WS_CHILD | WS_VISIBLE | CCS_TOP | TBSTYLE_LIST | TBSTYLE_TOOLTIPS,
        0, 0, 0, 0, hwndParent, (HMENU)1, GetWindowInstance(hwndParent), NULL);
    if (hwndTB == NULL)
        return FALSE;

    // initialize
    SendMessageW(hwndTB, TB_BUTTONSTRUCTSIZE, sizeof(TBBUTTON), 0);
    SendMessageW(hwndTB, TB_SETBITMAPSIZE, 0, MAKELPARAM(0, 0));
    SendMessageW(hwndTB, TB_SETIMAGELIST, 0, (LPARAM)himlTools);
    SendMessageW(hwndTB, TB_SETEXTENDEDSTYLE, 0, TBSTYLE_EX_MIXEDBUTTONS);

    ToolBar_StoreStrings(hwndTB, _countof(g_buttons0), g_buttons0);
    ToolBar_StoreStrings(hwndTB, _countof(g_buttons1), g_buttons1);
    ToolBar_StoreStrings(hwndTB, _countof(g_buttons2), g_buttons2);
    ToolBar_StoreStrings(hwndTB, _countof(g_buttons3), g_buttons3);
    ToolBar_StoreStrings(hwndTB, _countof(g_buttons4), g_buttons4);

    m_hToolBar = hwndTB;
    UpdateOurToolBarButtons(3);

    return TRUE;
}

void MMainWnd::UpdateToolBarStatus()
{
    if (TreeView_GetCount(m_hwndTV) == 0)
    {
        SendMessageW(m_hToolBar, TB_SETSTATE, ID_EXPAND_ALL, 0);
        SendMessageW(m_hToolBar, TB_SETSTATE, ID_COLLAPSE_ALL, 0);
        SendMessageW(m_hToolBar, TB_SETSTATE, ID_EXPORTRES, 0);
    }
    else
    {
        SendMessageW(m_hToolBar, TB_SETSTATE, ID_EXPAND_ALL, TBSTATE_ENABLED);
        SendMessageW(m_hToolBar, TB_SETSTATE, ID_COLLAPSE_ALL, TBSTATE_ENABLED);
        SendMessageW(m_hToolBar, TB_SETSTATE, ID_EXPORTRES, TBSTATE_ENABLED);
    }

    BOOL bCanEditLabel = TRUE;

    // get the selected entry
    auto entry = g_res.get_entry();
    if (entry && !entry->valid())
        entry = NULL;
    if (!entry || entry->m_et == ET_TYPE)
    {
        bCanEditLabel = FALSE;
    }

    if (bCanEditLabel)
    {
        if (entry)
        {
            if (entry->m_et == ET_NAME || entry->m_et == ET_LANG)
            {
                if (entry->m_type == RT_STRING || entry->m_type == RT_MESSAGETABLE)
                {
                    bCanEditLabel = FALSE;
                }
            }
        }
        else
        {
            bCanEditLabel = FALSE;
        }
    }

    if (bCanEditLabel)
        SendMessageW(m_hToolBar, TB_SETSTATE, ID_EDITLABEL, TBSTATE_ENABLED);
    else
        SendMessageW(m_hToolBar, TB_SETSTATE, ID_EDITLABEL, 0);

    if (!entry || !entry->m_hItem)
    {
        SendMessageW(m_hToolBar, TB_SETSTATE, ID_GUIEDIT, 0);
        SendMessageW(m_hToolBar, TB_SETSTATE, ID_CLONE, 0);
        SendMessageW(m_hToolBar, TB_SETSTATE, ID_DELETERES, 0);
        return;
    }

    BOOL bEditable = entry && entry->is_editable(m_szVCBat);
    if (bEditable)
    {
        if (entry->can_gui_edit())
        {
            SendMessageW(m_hToolBar, TB_SETSTATE, ID_GUIEDIT, TBSTATE_ENABLED);
        }
        else
        {
            SendMessageW(m_hToolBar, TB_SETSTATE, ID_GUIEDIT, 0);
        }
    }
    else
    {
        SendMessageW(m_hToolBar, TB_SETSTATE, ID_GUIEDIT, 0);
    }

    switch (entry ? entry->m_et : ET_ANY)
    {
    case ET_TYPE:
        SendMessageW(m_hToolBar, TB_SETSTATE, ID_DELETERES, TBSTATE_ENABLED);
        SendMessageW(m_hToolBar, TB_SETSTATE, ID_TEST, 0);
        SendMessageW(m_hToolBar, TB_SETSTATE, ID_CLONE, 0);
        break;

    case ET_NAME:
        SendMessageW(m_hToolBar, TB_SETSTATE, ID_DELETERES, TBSTATE_ENABLED);
        SendMessageW(m_hToolBar, TB_SETSTATE, ID_TEST, 0);
        SendMessageW(m_hToolBar, TB_SETSTATE, ID_CLONE, TBSTATE_ENABLED);
        break;

    case ET_LANG:
        if (entry->is_testable())
        {
            SendMessageW(m_hToolBar, TB_SETSTATE, ID_TEST, TBSTATE_ENABLED);
        }
        else
        {
            SendMessageW(m_hToolBar, TB_SETSTATE, ID_TEST, 0);
        }

        SendMessageW(m_hToolBar, TB_SETSTATE, ID_DELETERES, TBSTATE_ENABLED);
        if (entry->m_type == RT_STRING || entry->m_type == RT_MESSAGETABLE)
            SendMessageW(m_hToolBar, TB_SETSTATE, ID_CLONE, 0);
        else
            SendMessageW(m_hToolBar, TB_SETSTATE, ID_CLONE, TBSTATE_ENABLED);
        break;

    case ET_STRING: case ET_MESSAGE:
        SendMessageW(m_hToolBar, TB_SETSTATE, ID_DELETERES, TBSTATE_ENABLED);
        SendMessageW(m_hToolBar, TB_SETSTATE, ID_TEST, 0);
        SendMessageW(m_hToolBar, TB_SETSTATE, ID_CLONE, TBSTATE_ENABLED);
        break;

    default:
        SendMessageW(m_hToolBar, TB_SETSTATE, ID_DELETERES, 0);
        SendMessageW(m_hToolBar, TB_SETSTATE, ID_CLONE, 0);
        break;
    }
}

// update the toolbar buttons
void MMainWnd::UpdateOurToolBarButtons(INT iType)
{
    // delete all the buttons of toolbar
    while (SendMessageW(m_hToolBar, TB_DELETEBUTTON, 0, 0))
        ;

    // add the buttons
    switch (iType)
    {
    case 0:
        SendMessageW(m_hToolBar, TB_ADDBUTTONS, _countof(g_buttons0), (LPARAM)g_buttons0);
        break;
    case 1:
        SendMessageW(m_hToolBar, TB_ADDBUTTONS, _countof(g_buttons1), (LPARAM)g_buttons1);
        break;
    case 2:
        SendMessageW(m_hToolBar, TB_ADDBUTTONS, _countof(g_buttons2), (LPARAM)g_buttons2);
        break;
    case 3:
        SendMessageW(m_hToolBar, TB_ADDBUTTONS, _countof(g_buttons3), (LPARAM)g_buttons3);
        break;
    case 4:
        SendMessageW(m_hToolBar, TB_ADDBUTTONS, _countof(g_buttons4), (LPARAM)g_buttons4);
        break;
    }

    UpdateToolBarStatus();

    // show/hide the toolbar by settings
    if (g_settings.bShowToolBar)
        ShowWindow(m_hToolBar, SW_SHOWNOACTIVATE);
    else
        ShowWindow(m_hToolBar, SW_HIDE);
}

// select an item in the tree control
void
MMainWnd::SelectTV(EntryType et, const MIdOrString& type,
                   const MIdOrString& name, WORD lang,
                   BOOL bDoubleClick, STV stv)
{
    // close the preview
    HidePreview(stv);

    // find the entry
    if (auto entry = g_res.find(et, type, name, lang))
    {
        // select it
        SelectTV(entry, bDoubleClick, stv);
    }
}

// select an item in the tree control
void MMainWnd::SelectTV(EntryBase *entry, BOOL bDoubleClick, STV stv)
{
    BOOL bModified = Edit_GetModify(m_hCodeEditor);

    // close the preview
    HidePreview(stv);

    if (!entry)     // not selected
    {
        UpdateOurToolBarButtons(3);
        return;
    }

    if (stv != STV_DONTRESET)
    {
        // expand the parent and ensure visible
        auto parent = g_res.get_parent(entry);
        while (parent && parent->m_hItem)
        {
            TreeView_Expand(m_hwndTV, parent->m_hItem, TVE_EXPAND);
            parent = g_res.get_parent(parent);
        }
        TreeView_SelectItem(m_hwndTV, entry->m_hItem);
        TreeView_EnsureVisible(m_hwndTV, entry->m_hItem);
    }

    m_type = entry->m_type;
    m_name = entry->m_name;
    m_lang = entry->m_lang;

    BOOL bEditable;
    switch (entry->m_et)
    {
    case ET_LANG:
        // do preview
        bEditable = Preview(m_hwnd, entry, stv);
        break;

    case ET_STRING:
        // clean up m_hBmpView
        m_hBmpView.DestroyView();
        m_hBmpView.DeleteTempFile();

        if (stv != STV_DONTRESET)
        {
            // show the string table
            PreviewStringTable(m_hwnd, *entry);
        }

        // hide the binary EDIT control
        SetWindowTextW(m_hHexViewer, NULL);

        // it's editable
        bEditable = TRUE;
        break;

    case ET_MESSAGE:
        // clean up m_hBmpView
        m_hBmpView.DestroyView();
        m_hBmpView.DeleteTempFile();

        if (stv != STV_DONTRESET)
        {
            // show the message table
            PreviewMessageTable(m_hwnd, *entry);
        }

        // hide the binary EDIT control
        SetWindowTextW(m_hHexViewer, NULL);

        // editable?
        bEditable = !g_settings.bUseMSMSGTABLE;
        break;

    default:
        // otherwise
        // clean up m_hBmpView
        m_hBmpView.DestroyView();
        m_hBmpView.DeleteTempFile();

        // hide the binary EDIT control
        SetWindowTextW(m_hHexViewer, NULL);

        // it's non editable
        bEditable = FALSE;

        // update show mode
        SetShowMode(SHOW_CODEONLY);
    }

    if (stv == STV_DONTRESET || stv == STV_RESETTEXT)
    {
        // restore the modified flag
        Edit_SetModify(m_hCodeEditor, bModified);
    }

    if (bEditable)  // editable
    {
        // make it not read-only
        Edit_SetReadOnly(m_hCodeEditor, FALSE);

        // update the toolbar
        if (Edit_GetModify(m_hCodeEditor))
        {
            UpdateOurToolBarButtons(2);
        }
        else if (entry->is_testable())
        {
            UpdateOurToolBarButtons(0);
        }
        else if (entry->can_gui_edit())
        {
            UpdateOurToolBarButtons(4);
        }
        else
        {
            UpdateOurToolBarButtons(3);
        }
    }
    else
    {
        // make it read-only
        Edit_SetReadOnly(m_hCodeEditor, TRUE);

        // update the toolbar
        UpdateOurToolBarButtons(3);
    }

    // update show
    SetShowMode(m_nShowMode);

    // recalculate the splitter
    PostMessageDx(WM_SIZE);
}

// dump all the macros
MStringW MMainWnd::GetMacroDump() const
{
    MStringW ret;
    for (auto& macro : g_settings.macros)   // for each predefined macros
    {
        // " -Dmacro=contents"
        ret += L" -D";
        ret += macro.first;
        if (macro.second.size())
        {
            ret += L"=";
            ret += macro.second;
        }
    }
    ret += L" ";
    return ret;
}

// dump all the #include's
MStringW MMainWnd::GetIncludesDump() const
{
    MStringW ret;
    for (auto& path : g_settings.includes)
    {
        // " -Ipath"
        auto& str = path;
        if (str.empty())
            continue;

        ret += L" \"-I";
        ret += str;
        ret += L"\"";
    }
    if (m_szIncludeDir[0])
    {
        ret += L" \"-I";
        ret += m_szIncludeDir;
        ret += L"\"";
    }
    ret += L" ";
    return ret;
}

// dump all the #include's
MStringW MMainWnd::GetIncludesDumpForWindres() const
{
    MStringW ret;
    for (auto& path : g_settings.includes)
    {
        // " -Ipath"
        auto& str = path;
        if (str.empty())
            continue;

        ret += L" -I \"";
        ret += str;
        ret += L"\"";
    }
    if (m_szIncludeDir[0])
    {
        ret += L" -I \"";
        ret += m_szIncludeDir;
        ret += L"\"";
    }
    ret += L" ";
    return ret;
}

// compile the string table
BOOL MMainWnd::CompileStringTable(MStringA& strOutput, const MIdOrString& name, WORD lang, const MStringW& strWide)
{
    // convert strWide to UTF-8
    MStringA strUtf8 = MWideToAnsi(CP_UTF8, strWide).c_str();

    WCHAR szPath1[MAX_PATH], szPath2[MAX_PATH], szPath3[MAX_PATH];

    // Source file #1
    StringCchCopyW(szPath1, MAX_PATH, GetTempFileNameDx(L"R1"));
    MFile r1(szPath1, TRUE);

    // Header file
    StringCchCopyW(szPath2, MAX_PATH, GetTempFileNameDx(L"R2"));

    // Output resource object file (imported)
    StringCchCopyW(szPath3, MAX_PATH, GetTempFileNameDx(L"R3"));
    MFile r3(szPath3, TRUE);    // create
    r3.CloseHandle();   // close the handle

    AutoDeleteFileW adf1(szPath1);
    AutoDeleteFileW adf3(szPath3);

    if (!g_settings.IsIDMapEmpty() && DoWriteResH(szPath2))
    {
        r1.WriteFormatA("#include \"%s\"\r\n", MWideToAnsi(CP_ACP, szPath2).c_str());
    }
    else if (m_szResourceH[0])
    {
        r1.WriteFormatA("#include \"%s\"\r\n", MWideToAnsi(CP_ACP, m_szResourceH).c_str());
    }
    r1.WriteFormatA("#include <windows.h>\r\n");
    r1.WriteFormatA("#include <commctrl.h>\r\n");
    r1.WriteFormatA("#pragma code_page(65001) // UTF-8\r\n");
    r1.WriteFormatA("LANGUAGE 0x%04X, 0x%04X\r\n", PRIMARYLANGID(lang), SUBLANGID(lang));

    // dump the macros
    for (auto& pair : g_settings.id_map)
    {
        if (pair.first == "IDC_STATIC")
        {
            r1.WriteFormatA("#undef IDC_STATIC\r\n");
            r1.WriteFormatA("#define IDC_STATIC -1\r\n");
        }
        else
        {
            r1.WriteFormatA("#undef %s\r\n", pair.first.c_str());
            r1.WriteFormatA("#define %s %s\r\n", pair.first.c_str(), pair.second.c_str());
        }
    }

    // write the UTF-8 file to Source file #2
    DWORD cbWritten, cbWrite = DWORD(strUtf8.size() * sizeof(char));
    r1.WriteFormatA("#pragma RisohEditor\r\n");
    r1.WriteFile(strUtf8.c_str(), cbWrite, &cbWritten);
    r1.CloseHandle();   // close the handle

    // build the command line text
    MStringW strCmdLine;
    strCmdLine += L'\"';
    strCmdLine += m_szWindresExe;
    strCmdLine += L"\" -DRC_INVOKED ";
    strCmdLine += GetMacroDump();
    strCmdLine += GetIncludesDumpForWindres();
    strCmdLine += L" -o \"";
    strCmdLine += szPath3;
    strCmdLine += L"\" -J rc -O res -F pe-i386 \"--preprocessor=";
    strCmdLine += m_szMCppExe;
    strCmdLine += L"\" \"";
    strCmdLine += szPath1;
    strCmdLine += '\"';
    //MessageBoxW(m_hwnd, strCmdLine.c_str(), NULL, 0);

    BOOL bOK = FALSE;

    // create a windres.exe process
    MProcessMaker pmaker;
    pmaker.SetShowWindow(SW_HIDE);
    pmaker.SetCreationFlags(CREATE_NEW_CONSOLE);

    MFile hInputWrite, hOutputRead;
    if (pmaker.PrepareForRedirect(&hInputWrite, &hOutputRead) &&
        pmaker.CreateProcessDx(NULL, strCmdLine.c_str()))
    {
        // read all with timeout
        bOK = pmaker.ReadAll(strOutput, hOutputRead, PROCESS_TIMEOUT);
        pmaker.WaitForSingleObject(PROCESS_TIMEOUT);

        if (pmaker.GetExitCode() == 0 && bOK)
        {
            bOK = FALSE;

            // import res
            EntrySet res;
            if (res.import_res(szPath3))
            {
                // resource type check
                bOK = TRUE;
                for (auto entry : res)
                {
                    if (entry->m_type != RT_STRING)
                    {
                        ErrorBoxDx(IDS_RESMISMATCH);
                        bOK = FALSE;
                        break;
                    }
                }

                if (bOK)
                {
                    // merge
                    g_res.search_and_delete(ET_LANG, RT_STRING, (WORD)0, lang);
                    g_res.merge(res);
                }
            }

            // clean res up
            res.delete_all();
        }
        else
        {
            bOK = FALSE;
            // error message
            size_t ich = strOutput.find("RisohEditor.rc:");
            if (ich != strOutput.npos)
            {
                ich += 15; // "RisohEditor.rc:"
                INT iLine = INT(strtoul(&strOutput[ich], NULL, 10));
                ::SendMessageW(m_hCodeEditor, LNEM_CLEARLINEMARKS, 0, 0);
                ::SendMessageW(m_hCodeEditor, LNEM_SETLINEMARK, iLine, ERROR_LINE_COLOR);
            }
            strOutput = MWideToAnsi(CP_ACP, LoadStringDx(IDS_COMPILEERROR));
        }
    }
    else
    {
        // error message
        strOutput = MWideToAnsi(CP_ACP, LoadStringDx(IDS_CANNOTSTARTUP));
    }

    // recalculate the splitter
    PostMessageDx(WM_SIZE);

    AutoDeleteFileW adf2(szPath2);

    if (bOK)
        DoSetFileModified(TRUE);
    return bOK;
}

BOOL MMainWnd::CompileTYPELIB(MStringA& strOutput, const MIdOrString& name, WORD lang, const MStringW& strWide)
{
    // convert strWide to ANSI
    MStringA ansi = MWideToAnsi(CP_ACP, strWide).c_str();

    bool is_64bit = (GetMachineOfBinary(m_szFile) == IMAGE_FILE_MACHINE_AMD64);

    auto binary = tlb_binary_from_text(m_szMidlWrap, m_szVCBat, strOutput, ansi, is_64bit);
    if (binary.empty())
    {
        // error message
        if (strOutput.empty())
            strOutput = MWideToAnsi(CP_ACP, LoadStringDx(IDS_COMPILEERROR));

        std::vector<MStringA> lines;
        mstr_split(lines, strOutput, "\n");
        std::vector<MStringA> new_lines;
        for (auto& line : lines)
        {
            if (line.find("error") == line.npos)
                continue;
            if (line.find('*') == 0 || line.find('[') == 0)
                continue;
            if (line.find("Processing ") == 0)
                continue;
            new_lines.push_back(line);
            if (new_lines.size() >= 10)
            {
                new_lines.push_back("...");
                break;
            }
        }
        strOutput = mstr_join(new_lines, "\n");
        return FALSE;
    }

    g_res.add_lang_entry(L"TYPELIB", name, lang, binary);
    DoSetFileModified(TRUE);
    return TRUE;
}

BOOL MMainWnd::CompileRCData(MStringA& strOutput, const MIdOrString& name, WORD lang, const MStringW& strWide)
{
    EntryBase *entry = g_res.find(ET_LANG, RT_RCDATA, name, lang);
    if (!entry || !entry->is_delphi_dfm())
        return FALSE;

    MWideToAnsi w2a(CP_UTF8, strWide);
    MStringA ansi(w2a.c_str());

    // remove "//-" ... "-//"
    for (;;)
    {
        auto i = ansi.find("//-");
        if (i == MStringA::npos)
            break;
        auto j = ansi.find("-//", i);
        auto k = ansi.find('\n', i);
        if (j != MStringA::npos && k != MStringA::npos)
        {
            if (j < k)
                ansi.erase(i, j - i + 3);
            else
                ansi.erase(i, k - i);
        }
        else if (j != MStringA::npos)
        {
            ansi.erase(i, j - i + 3);
        }
        else if (k != MStringA::npos)
        {
            ansi.erase(i, k - i);
        }
        else
        {
            ansi.erase(0, i);
            break;
        }
    }

    INT iLine = 0;
    EntryBase::data_type data =
        dfm_binary_from_text(m_szDFMSC, ansi,
                             g_settings.nDfmCodePage, g_settings.bDfmNoUnicode, iLine);
    auto text = dfm_text_from_binary(m_szDFMSC, data.data(), data.size(),
                                     g_settings.nDfmCodePage, g_settings.bDfmRawTextComments);
    if (text.empty())
    {
        MWideToAnsi w2a(CP_ACP, LoadStringDx(IDS_COMPILEERROR));
        strOutput = w2a.c_str();
        if (iLine != 0)
        {
            ::SendMessageW(m_hCodeEditor, LNEM_CLEARLINEMARKS, 0, 0);
            ::SendMessageW(m_hCodeEditor, LNEM_SETLINEMARK, iLine, ERROR_LINE_COLOR);
        }
        return FALSE;
    }

    entry->m_data = std::move(data);
    DoSetFileModified(TRUE);
    return TRUE;
}

// compile the message table
BOOL MMainWnd::CompileMessageTable(MStringA& strOutput, const MIdOrString& name, WORD lang, const MStringW& strWide)
{
    // convert strWide to UTF-8
    MStringA strUtf8 = MWideToAnsi(CP_UTF8, strWide).c_str();

    WCHAR szPath1[MAX_PATH], szPath2[MAX_PATH], szPath3[MAX_PATH];

    // Source file #1
    StringCchCopyW(szPath1, MAX_PATH, GetTempFileNameDx(L"R1"));
    MFile r1(szPath1, TRUE);

    // Header file
    StringCchCopyW(szPath2, MAX_PATH, GetTempFileNameDx(L"R2"));

    // Output resource object file (imported)
    StringCchCopyW(szPath3, MAX_PATH, GetTempFileNameDx(L"R3"));

    MFile r3(szPath3, TRUE);    // create the file
    r3.CloseHandle();   // close the handle

    AutoDeleteFileW adf1(szPath1);
    AutoDeleteFileW adf3(szPath3);

    if (!g_settings.IsIDMapEmpty() && DoWriteResH(szPath2))
    {
        r1.WriteFormatA("#include \"%s\"\r\n", MWideToAnsi(CP_ACP, szPath2).c_str());
    }
    else if (m_szResourceH[0])
    {
        r1.WriteFormatA("#include \"%s\"\r\n", MWideToAnsi(CP_ACP, m_szResourceH).c_str());
    }
    r1.WriteFormatA("#include <windows.h>\r\n");
    r1.WriteFormatA("#include <commctrl.h>\r\n");
    r1.WriteFormatA("#pragma code_page(65001) // UTF-8\r\n");
    r1.WriteFormatA("LANGUAGE 0x%04X, 0x%04X\r\n", PRIMARYLANGID(lang), SUBLANGID(lang));

    DWORD cbWritten, cbWrite = DWORD(strUtf8.size() * sizeof(char));
    r1.WriteFormatA("#pragma RisohEditor\r\n");
    r1.WriteFile(strUtf8.c_str(), cbWrite, &cbWritten);
    r1.CloseHandle();       // close the handle

    // build the command line text
    MStringW strCmdLine;
    strCmdLine += L'\"';
    strCmdLine += m_szMcdxExe;
    strCmdLine += L"\" ";
    strCmdLine += GetMacroDump();
    strCmdLine += GetIncludesDump();
    strCmdLine += L" \"--preprocessor=";
    strCmdLine += m_szMCppExe;
    strCmdLine += L"\" -o \"";
    strCmdLine += szPath3;
    strCmdLine += L"\" -J rc -O res \"";
    strCmdLine += szPath1;
    strCmdLine += L'\"';
    //MessageBoxW(NULL, strCmdLine.c_str(), NULL, 0);

    BOOL bOK = FALSE;

    // create the mcdx.exe process
    MProcessMaker pmaker;
    pmaker.SetShowWindow(SW_HIDE);
    pmaker.SetCreationFlags(CREATE_NEW_CONSOLE);

    MFile hInputWrite, hOutputRead;
    if (pmaker.PrepareForRedirect(&hInputWrite, &hOutputRead) &&
        pmaker.CreateProcessDx(NULL, strCmdLine.c_str()))
    {
        // read all with timeout
        bOK = pmaker.ReadAll(strOutput, hOutputRead, PROCESS_TIMEOUT);
        pmaker.WaitForSingleObject(PROCESS_TIMEOUT);

        if (pmaker.GetExitCode() == 0 && bOK)
        {
            bOK = FALSE;

            // import res
            EntrySet res;
            if (res.import_res(szPath3))
            {
                // resource type check
                bOK = TRUE;
                for (auto entry : res)
                {
                    if (entry->m_type != RT_MESSAGETABLE)
                    {
                        ErrorBoxDx(IDS_RESMISMATCH);
                        bOK = FALSE;
                        break;
                    }
                }

                if (bOK)
                {
                    // merge
                    g_res.search_and_delete(ET_LANG, RT_MESSAGETABLE, (WORD)0, lang);
                    g_res.merge(res);
                }
            }

            // clean res up
            res.delete_all();
        }
        else
        {
            bOK = FALSE;
            size_t ich = strOutput.find("RisohEditor.rc (");
            if (ich != strOutput.npos)
            {
                ich += 16; // "RisohEditor.rc ("
                INT iLine = INT(strtoul(&strOutput[ich], NULL, 10));
                iLine += 4; // FIXME: workaround
                ::SendMessageW(m_hCodeEditor, LNEM_CLEARLINEMARKS, 0, 0);
                ::SendMessageW(m_hCodeEditor, LNEM_SETLINEMARK, iLine, ERROR_LINE_COLOR);
            }
            // error message
            strOutput = MWideToAnsi(CP_ACP, LoadStringDx(IDS_COMPILEERROR));
        }
    }
    else
    {
        // error message
        strOutput = MWideToAnsi(CP_ACP, LoadStringDx(IDS_CANNOTSTARTUP));
    }

    // recalculate the splitter
    PostMessageDx(WM_SIZE);

    AutoDeleteFileW adf2(szPath2);

    if (bOK)
        DoSetFileModified(TRUE);

    return bOK;
}

// compile a resource item source
BOOL MMainWnd::CompileParts(MStringA& strOutput, const MIdOrString& type, const MIdOrString& name,
                            WORD lang, const MStringW& strWide, BOOL bReopen)
{
    if (type == RT_STRING)
    {
        return CompileStringTable(strOutput, name, lang, strWide);
    }
    if (type == RT_MESSAGETABLE && !g_settings.bUseMSMSGTABLE)
    {
        return CompileMessageTable(strOutput, name, lang, strWide);
    }
    if (type == RT_RCDATA)
    {
        return CompileRCData(strOutput, name, lang, strWide);
    }
    if (type == L"TYPELIB")
    {
        return CompileTYPELIB(strOutput, name, lang, strWide);
    }

    // add a UTF-8 BOM to data
    static const BYTE bom[] = {0xEF, 0xBB, 0xBF, 0};

    // strWide --> strUtf8 (in UTF-8)
    MStringA strUtf8 = MWideToAnsi(CP_UTF8, strWide).c_str();
    auto enc = GetResTypeEncoding(type);
    BOOL bDataOK = FALSE;
    EntryBase::data_type data;
    if (enc.size())
    {
        bDataOK = TRUE;

        if (enc == L"utf8" || enc == L"utf8n")
        {
            data.assign(strUtf8.begin(), strUtf8.end());

            if (enc != L"utf8n")
            {
                // add a UTF-8 BOM to data
                data.insert(data.begin(), &bom[0], &bom[3]);
            }
        }
        else if (enc == L"ansi")
        {
            // strWide --> data (in ANSI)
            MStringA TextAnsi = MWideToAnsi(CP_ACP, strWide).c_str();
            data.assign(TextAnsi.begin(), TextAnsi.end());
        }
        else if (enc == L"wide")
        {
            data.assign((BYTE *)&strWide[0], (BYTE *)&strWide.c_str()[strWide.size()]);
        }
        else if (enc == L"sjis")
        {
            MStringA TextSjis = MWideToAnsi(932, strWide).c_str();
            data.assign(TextSjis.begin(), TextSjis.end());
        }
        else
        {
            bDataOK = FALSE;
        }
    }
    else if (type == RT_HTML || type == RT_MANIFEST ||
             type == L"RISOHTEMPLATE")
    {
        data.assign(strUtf8.begin(), strUtf8.end());
        data.insert(data.begin(), &bom[0], &bom[3]);

        bDataOK = TRUE;
    }

    if (bDataOK)
    {
        if (data.empty())
        {
            ErrorBoxDx(IDS_DATAISEMPTY);
            return FALSE;
        }

        // add a language entry
        auto entry = g_res.add_lang_entry(type, name, lang, data);

        // select the added entry
        SelectTV(entry, FALSE);

        DoSetFileModified(TRUE);

        return TRUE;    // success
    }

    WCHAR szPath1[MAX_PATH], szPath2[MAX_PATH], szPath3[MAX_PATH];

    // Source file #1
    StringCchCopyW(szPath1, MAX_PATH, GetTempFileNameDx(L"R1"));
    MFile r1(szPath1, TRUE);

    // Header file
    StringCchCopyW(szPath2, MAX_PATH, GetTempFileNameDx(L"R2"));

    // Output resource object file (imported)
    StringCchCopyW(szPath3, MAX_PATH, GetTempFileNameDx(L"R3"));
    MFile r3(szPath3, TRUE);
    r3.CloseHandle();   // close the handle

    AutoDeleteFileW adf1(szPath1);
    AutoDeleteFileW adf3(szPath3);

    // dump the head to Source file #1
    if (!g_settings.IsIDMapEmpty() && DoWriteResH(szPath2))
    {
        r1.WriteFormatA("#include \"%s\"\r\n", MWideToAnsi(CP_ACP, szPath2).c_str());
    }
    else if (m_szResourceH[0])
    {
        r1.WriteFormatA("#include \"%s\"\r\n", MWideToAnsi(CP_ACP, m_szResourceH).c_str());
    }
    r1.WriteSzA("#include <windows.h>\r\n");
    r1.WriteSzA("#include <commctrl.h>\r\n");
    r1.WriteFormatA("LANGUAGE 0x%04X, 0x%04X\r\n", PRIMARYLANGID(lang), SUBLANGID(lang));
    r1.WriteSzA("#pragma code_page(65001) // UTF-8\r\n\r\n");
    r1.WriteSzA("#ifndef IDC_STATIC\r\n");
    r1.WriteSzA("    #define IDC_STATIC (-1)\r\n");
    r1.WriteSzA("#endif\r\n\r\n");

    DWORD cbWritten, cbWrite = DWORD(strUtf8.size() * sizeof(char));
    r1.WriteSzA("#pragma RisohEditor\r\n");
    r1.WriteFile(strUtf8.c_str(), cbWrite, &cbWritten);
    r1.FlushFileBuffers();
    r1.CloseHandle();   // close the handle

    // build the command line text
    MStringW strCmdLine;
    strCmdLine += L'\"';
    strCmdLine += m_szWindresExe;
    strCmdLine += L"\" -DRC_INVOKED ";
    strCmdLine += GetMacroDump();
    strCmdLine += GetIncludesDumpForWindres();
    strCmdLine += L" -o \"";
    strCmdLine += szPath3;
    strCmdLine += L"\" -J rc -O res -F pe-i386 --preprocessor=\"";
    strCmdLine += m_szMCppExe;
    strCmdLine += L"\" \"";
    strCmdLine += szPath1;
    strCmdLine += '\"';
    //MessageBoxW(NULL, strCmdLine.c_str(), NULL, 0);

    BOOL bOK = FALSE;

    // create a windres.exe process
    MProcessMaker pmaker;
    pmaker.SetShowWindow(SW_HIDE);
    pmaker.SetCreationFlags(CREATE_NEW_CONSOLE);

    MFile hInputWrite, hOutputRead;
    if (pmaker.PrepareForRedirect(&hInputWrite, &hOutputRead) &&
        pmaker.CreateProcessDx(NULL, strCmdLine.c_str()))
    {
        // read all with timeout
        bOK = pmaker.ReadAll(strOutput, hOutputRead, PROCESS_TIMEOUT);
        pmaker.WaitForSingleObject(PROCESS_TIMEOUT);

        // check the exit code
        if (pmaker.GetExitCode() == 0 && bOK)
        {
            bOK = FALSE;

            // import res
            EntrySet res;
            if (res.import_res(szPath3))
            {
                bOK = TRUE;
                for (auto entry : res)
                {
                    if (entry->m_et != ET_LANG)
                        continue;

                    // resource type check
                    if (entry->m_type != type)
                    {
                        ErrorBoxDx(IDS_RESMISMATCH);
                        bOK = FALSE;
                        break;
                    }

                    // adjust names and languages
                    entry->m_name = name;
                    entry->m_lang = lang;

                    if (entry->m_type == RT_TOOLBAR)
                    {
                        ToolbarRes toolbar_res;
                        MByteStreamEx stream(entry->m_data);
                        toolbar_res.LoadFromStream(stream);
                        entry->m_data = toolbar_res.data();
                    }
                }

                if (bOK)
                {
                    // merge
                    g_res.search_and_delete(ET_LANG, type, name, lang);
                    g_res.merge(res);
                }

                // clean res up
                res.delete_all();
            }
        }
        else
        {
            bOK = FALSE;
            // error message
            size_t ich = strOutput.find("RisohEditor.rc:");
            if (ich != strOutput.npos)
            {
                ich += 15; // "RisohEditor.rc:"
                INT iLine = INT(strtoul(&strOutput[ich], NULL, 10));
                ::SendMessageW(m_hCodeEditor, LNEM_CLEARLINEMARKS, 0, 0);
                ::SendMessageW(m_hCodeEditor, LNEM_SETLINEMARK, iLine, ERROR_LINE_COLOR);
            }
            strOutput = MWideToAnsi(CP_ACP, LoadStringDx(IDS_COMPILEERROR));
        }
    }
    else
    {
        // error message
        strOutput = MWideToAnsi(CP_ACP, LoadStringDx(IDS_CANNOTSTARTUP));
    }

    if (bOK)
    {
        if (bReopen && type == RT_DIALOG)
        {
            PostMessageDx(MYWM_REOPENRAD);
        }

        DoSetFileModified(TRUE);
    }

    // recalculate the splitter
    PostMessageDx(WM_SIZE);

    AutoDeleteFileW adf2(szPath2);

    return bOK;
}

// recompile the resource item on selection change.
// reopen if necessary
BOOL MMainWnd::ReCompileOnSelChange(BOOL bReopen/* = FALSE*/)
{
    MStringW strWide = MWindowBase::GetWindowTextW(m_hCodeEditor);

    // get the selected entry
    auto entry = g_res.get_entry();
    if (!entry)
        return FALSE;   // no selection

    // compile the entry
    MStringA strOutput;
    if (!CompileParts(strOutput, entry->m_type, entry->m_name, entry->m_lang, strWide))
    {
        // compilation failed
        m_nStatusStringID = IDS_RECOMPILEFAILED;
        SetErrorMessage(strOutput);
        return FALSE;   // failure
    }

    // compilation OK
    m_nStatusStringID = IDS_RECOMPILEOK;

    // compiled. clear the modification flag
    Edit_SetModify(m_hCodeEditor, FALSE);

    // destroy the RADical window if any
    if (IsWindow(m_rad_window))
    {
        m_rad_window.DestroyWindow();
    }

    // reopen if necessary
    if (bReopen)
    {
        if (m_type == entry->m_type &&
            m_name == entry->m_name &&
            m_lang == entry->m_lang)
        {
            if (entry->m_et == ET_LANG && entry->m_type == RT_DIALOG)
            {
                MByteStreamEx stream(entry->m_data);
                m_rad_window.m_dialog_res.LoadFromStream(stream);
                m_rad_window.CreateDx(m_hwnd);
            }
        }
    }

    return TRUE;
}

// compile the source if necessary
BOOL MMainWnd::CompileIfNecessary(BOOL bReopen/* = FALSE*/)
{
    if (Edit_GetModify(m_hCodeEditor))
    {
        // the modification flag is set. query to compile
        INT id = MsgBoxDx(IDS_COMPILENOW, MB_ICONINFORMATION | MB_YESNOCANCEL);
        switch (id)
        {
        case IDYES:
            // ok, let's compile
            return ReCompileOnSelChange(bReopen);

        case IDNO:
            // clear the modification flag
            Edit_SetModify(m_hCodeEditor, FALSE);

            // destroy the RADical window if any
            if (IsWindow(m_rad_window))
                m_rad_window.DestroyWindow();
            break;

        case IDCANCEL:
            return FALSE;   // cancelled
        }
    }

    return TRUE;    // go
}

// check the data folder
BOOL MMainWnd::CheckDataFolder(VOID)
{
    // get the module path filename of this application module
    WCHAR szPath[MAX_PATH], *pch;
    GetModuleFileNameW(NULL, szPath, _countof(szPath));

    // find the last '\\' or '/'
    pch = wcsrchr(szPath, L'\\');
    if (pch == NULL)
        pch = wcsrchr(szPath, L'/');
    if (pch == NULL)
        return FALSE;

    // find the data folder
    size_t diff = pch - szPath;
    StringCchCopyW(pch, diff, L"\\data");
    if (!PathFileExistsW(szPath))
    {
        StringCchCopyW(pch, diff, L"\\..\\data");
        if (!PathFileExistsW(szPath))
        {
            StringCchCopyW(pch, diff, L"\\..\\..\\data");
            if (!PathFileExistsW(szPath))
            {
                StringCchCopyW(pch, diff, L"\\..\\..\\..\\data");
                if (!PathFileExistsW(szPath))
                {
                    StringCchCopyW(pch, diff, L"\\..\\..\\..\\..\\data");
                    if (!PathFileExistsW(szPath))
                    {
                        return FALSE;   // not found
                    }
                }
            }
        }
    }

    // found. store to m_szDataFolder
    StringCchCopyW(m_szDataFolder, _countof(m_szDataFolder), szPath);

    // get the PATH environment variable
    MStringW env, str;
    DWORD cch = GetEnvironmentVariableW(L"PATH", NULL, 0);
    env.resize(cch);
    GetEnvironmentVariableW(L"PATH", &env[0], cch);

    // add "data/bin" to the PATH variable
    str = m_szDataFolder;
    str += L"\\bin;";
    str += env;
    SetEnvironmentVariableW(L"PATH", str.c_str());

    return TRUE;
}

BOOL DoCheckFile(std::wstring& file, LPCWSTR psz)
{
    WCHAR szPath[MAX_PATH];
    ExpandEnvironmentStringsW(psz, szPath, _countof(szPath));
    if (PathFileExistsW(szPath))
    {
        file = szPath;
        return TRUE;
    }
    return FALSE;
}

// check the data and the helper programs
INT MMainWnd::CheckData(VOID)
{
    WCHAR szPath[MAX_PATH];

    if (!CheckDataFolder())
    {
        ErrorBoxDx(TEXT("ERROR: data folder was not found!"));
        return -1;  // failure
    }

    // Constants.txt
    StringCchCopyW(m_szConstantsFile, _countof(m_szConstantsFile), m_szDataFolder);
    StringCchCatW(m_szConstantsFile, _countof(m_szConstantsFile), L"\\Constants.txt");
    if (!g_db.LoadFromFile(m_szConstantsFile))
    {
        ErrorBoxDx(TEXT("ERROR: Unable to load Constants.txt file."));
        return -2;  // failure
    }
    g_db.m_map[L"CTRLID"].emplace_back(L"IDC_STATIC", (WORD)-1);

    // mcpp.exe
    StringCchCopyW(m_szMCppExe, _countof(m_szMCppExe), m_szDataFolder);
    StringCchCatW(m_szMCppExe, _countof(m_szMCppExe), L"\\bin\\mcpp.exe");
    // NOTE: _popen has bug: https://github.com/katahiromz/win_popen_bug
    //       To avoid this problem, we use short path.
    GetShortPathNameW(m_szMCppExe, m_szMCppExe, _countof(m_szMCppExe));
    if (!PathFileExistsW(m_szMCppExe))
    {
        ErrorBoxDx(TEXT("ERROR: No mcpp.exe found."));
        return -3;  // failure
    }
    //MessageBoxW(NULL, m_szMCppExe, NULL, 0);

    // windres.exe
    StringCchCopyW(m_szWindresExe, _countof(m_szWindresExe), m_szDataFolder);
    StringCchCatW(m_szWindresExe, _countof(m_szWindresExe), L"\\bin\\windres.exe");
    GetShortPathNameW(m_szWindresExe, m_szWindresExe, _countof(m_szWindresExe));
    if (!PathFileExistsW(m_szWindresExe))
    {
        ErrorBoxDx(TEXT("ERROR: No windres.exe found."));
        return -4;  // failure
    }
    //MessageBoxW(NULL, m_szWindresExe, NULL, 0);

    // upx.exe
    StringCchCopyW(m_szUpxExe, _countof(m_szUpxExe), m_szDataFolder);
    StringCchCatW(m_szUpxExe, _countof(m_szUpxExe), L"\\bin\\upx.exe");
    if (!PathFileExistsW(m_szUpxExe))
    {
        ErrorBoxDx(TEXT("ERROR: No upx.exe found."));
        return -5;  // failure
    }

    // include directory
    StringCchCopyW(m_szIncludeDir, _countof(m_szIncludeDir), m_szDataFolder);
    StringCchCatW(m_szIncludeDir, _countof(m_szIncludeDir), L"\\lib\\gcc\\i686-w64-mingw32\\10.2.0\\include");
    if (!PathFileExistsW(m_szIncludeDir))
    {
        ErrorBoxDx(TEXT("ERROR: No include directory found."));
        return -6;  // failure
    }

    // dfmsc.exe
    StringCchCopyW(m_szDFMSC, _countof(m_szDFMSC), m_szDataFolder);
    StringCchCatW(m_szDFMSC, _countof(m_szDFMSC), L"\\bin\\dfmsc.exe");
    if (!PathFileExistsW(m_szDFMSC))
    {
        ErrorBoxDx(TEXT("ERROR: No dfmsc.exe found."));
        return -7;  // failure
    }

    // OleBow.exe
    StringCchCopyW(m_szOleBow, _countof(m_szOleBow), m_szDataFolder);
    StringCchCatW(m_szOleBow, _countof(m_szOleBow), L"\\bin\\olebow.exe");
    if (!PathFileExistsW(m_szOleBow))
    {
        ErrorBoxDx(TEXT("ERROR: No OleBow.exe found."));
        return -7;  // failure
    }

    // midlwrap.bat
    StringCchCopyW(m_szMidlWrap, _countof(m_szMidlWrap), m_szDataFolder);
    StringCchCatW(m_szMidlWrap, _countof(m_szMidlWrap), L"\\bin\\midlwrap.bat");
    if (!PathFileExistsW(m_szMidlWrap))
    {
        ErrorBoxDx(TEXT("ERROR: No midlwrap.bat found."));
        return -8;  // failure
    }

    // vcvarsall.bat
    std::wstring file;
    m_szVCBat[0] = 0;
    if (DoCheckFile(file, LR"(C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Auxiliary\Build\vcvarsall.bat)") ||
        DoCheckFile(file, LR"(C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Auxiliary\Build\vcvarsall.bat)") ||
        DoCheckFile(file, LR"(C:\Program Files\Microsoft Visual Studio\2019\Professional\VC\Auxiliary\Build\vcvarsall.bat)") ||
        DoCheckFile(file, LR"(C:\Program Files\Microsoft Visual Studio\2019\Community\VC\Auxiliary\Build\vcvarsall.bat)") ||
        DoCheckFile(file, LR"(C:\Program Files (x86)\Microsoft Visual Studio\2017\Professional\VC\Auxiliary\Build\vcvarsall.bat)") ||
        DoCheckFile(file, LR"(C:\Program Files (x86)\Microsoft Visual Studio\2017\Community\VC\Auxiliary\Build\vcvarsall.bat)") ||
        DoCheckFile(file, LR"(C:\Program Files\Microsoft Visual Studio\2017\Professional\VC\Auxiliary\Build\vcvarsall.bat)") ||
        DoCheckFile(file, LR"(C:\Program Files\Microsoft Visual Studio\2017\Community\VC\Auxiliary\Build\vcvarsall.bat)") ||
        DoCheckFile(file, LR"(%VS140COMNTOOLS%..\..\VC\vcvarsall.bat)") ||
        DoCheckFile(file, LR"(%VS120COMNTOOLS%..\..\VC\vcvarsall.bat)") ||
        DoCheckFile(file, LR"(%VS110COMNTOOLS%..\..\VC\vcvarsall.bat)") ||
        DoCheckFile(file, LR"(%VS100COMNTOOLS%..\..\VC\vcvarsall.bat)") ||
        DoCheckFile(file, LR"(%VS90COMNTOOLS%..\..\VC\vcvarsall.bat)"))
    {
        StringCchCopyW(m_szVCBat, _countof(m_szVCBat), file.c_str());
    }

    // get the module path filename of this application module
    GetModuleFileNameW(NULL, szPath, _countof(szPath));

    // mcdx.exe
    PathRemoveFileSpecW(szPath);
    PathAppendW(szPath, L"mcdx.exe");
    if (PathFileExistsW(szPath))
    {
        StringCchCopyW(m_szMcdxExe, _countof(m_szMcdxExe), szPath);
    }
    else
    {
        StringCchCopyW(m_szMcdxExe, _countof(m_szMcdxExe), m_szDataFolder);
        StringCchCatW(m_szMcdxExe, _countof(m_szMcdxExe), L"\\bin\\mcdx.exe");
        if (!PathFileExistsW(m_szMcdxExe))
        {
            ErrorBoxDx(TEXT("ERROR: No mcdx.exe found."));
            return -8;  // failure
        }
    }

    return 0;   // success
}

// load the language information
void MMainWnd::DoLoadLangInfo(VOID)
{
    // enumerate localized languages
    EnumSystemLocalesW(EnumLocalesProc, LCID_SUPPORTED);

    // enumerate English languages
    EnumSystemLocalesW(EnumEngLocalesProc, LCID_SUPPORTED);

    // add the neutral language
    {
        LANG_ENTRY entry;
        entry.LangID = MAKELANGID(LANG_NEUTRAL, SUBLANG_NEUTRAL);
        entry.str = LoadStringDx(IDS_NEUTRAL);
        g_langs.push_back(entry);
    }

    // sort
    std::sort(g_langs.begin(), g_langs.end());
}

BOOL InitLangListBox(HWND hwnd)
{
    for (auto& lang : g_langs)
    {
        INT index = (INT)SendMessageW(hwnd, LB_ADDSTRING, 0, (LPARAM)lang.str.c_str());
        SendMessageW(hwnd, LB_SETITEMDATA, index, (LPARAM)lang.LangID);
    }
    return TRUE;
}

// load a file
BOOL MMainWnd::DoLoadFile(HWND hwnd, LPCWSTR pszFileName, DWORD nFilterIndex, BOOL bForceDecompress)
{
    MWaitCursor wait;
    WCHAR szPath[MAX_PATH], szResolvedPath[MAX_PATH], *pchPart;

    enum LoadFilterIndex        // see also: IDS_EXERESRCFILTER
    {
        LFI_NONE = 0,
        LFI_EXECUTABLE = 1,
        LFI_RES = 2,
        LFI_RC = 3,
        LFI_ALL = 4
    };

    if (nFilterIndex == LFI_ALL)
        nFilterIndex = LFI_NONE;

    // if it was a shortcut file, then resolve it.
    // pszFileName --> szPath
    if (GetPathOfShortcutDx(hwnd, pszFileName, szResolvedPath))
    {
        GetFullPathNameW(szResolvedPath, _countof(szPath), szPath, &pchPart);
    }
    else
    {
        GetFullPathNameW(pszFileName, _countof(szPath), szPath, &pchPart);
    }

    // find the dot extension
    LPWSTR pch = wcsrchr(szPath, L'.');
    if (nFilterIndex == LFI_NONE || nFilterIndex == LFI_EXECUTABLE)
    {
        if (pch && lstrcmpiW(pch, L".res") == 0)
            nFilterIndex = LFI_RES;
        else if (pch && lstrcmpiW(pch, L".rc") == 0)
            nFilterIndex = LFI_RC;
    }

    if (nFilterIndex == LFI_RES)     // .res files
    {
        // reload the resource.h if necessary
        UnloadResourceH(hwnd);
        if (g_settings.bAutoLoadNearbyResH)
            CheckResourceH(hwnd, szPath);

        // do import to the res variable
        EntrySet res;
        if (!res.import_res(szPath))
        {
            ErrorBoxDx(IDS_CANNOTOPEN);
            return FALSE;
        }

        // load it now
        m_bLoading = TRUE;
        {
            ShowLangArrow(FALSE);

            // renewal
            g_res.delete_all();
            g_res.merge(res);

            // clean up
            res.delete_all();
        }
        m_bLoading = FALSE;

        // update the file info
        UpdateFileInfo(FT_RES, szPath, FALSE);

        // show ID list if necessary
        if (m_szResourceH[0] && g_settings.bAutoShowIDList)
        {
            ShowIDList(hwnd, TRUE);
        }

        // select none
        SelectTV(NULL, FALSE);

        DoSetFileModified(FALSE);
        return TRUE;
    }

    if (nFilterIndex == LFI_RC)  // .rc files
    {
        // reload the resource.h if necessary
        UnloadResourceH(hwnd);
        if (g_settings.bAutoLoadNearbyResH)
            CheckResourceH(hwnd, szPath);

        // load the RC file to the res variable
        EntrySet res;
        if (!DoLoadRC(hwnd, szPath, res))
        {
            ErrorBoxDx(IDS_CANNOTOPEN);
            return FALSE;
        }

        // load it now
        m_bLoading = TRUE;
        {
            ShowLangArrow(FALSE);

            // renewal
            g_res.delete_all();
            g_res.merge(res);

            // clean up
            res.delete_all();
        }
        m_bLoading = FALSE;

        // update the file info
        UpdateFileInfo(FT_RC, szPath, FALSE);

        // show ID list if necessary
        if (m_szResourceH[0] && g_settings.bAutoShowIDList)
        {
            ShowIDList(hwnd, TRUE);
        }

        // select none
        SelectTV(NULL, FALSE);

        DoSetFileModified(FALSE);
        return TRUE;
    }

    LPWSTR pszPath = szPath;        // the real path

    // check whether it was compressed
    MStringW strToOpen = pszPath;
    BOOL bCompressed = DoUpxTest(m_szUpxExe, pszPath);
    if (bCompressed)   // it was compressed
    {
        INT nID;
        if (bForceDecompress)
        {
            nID = IDYES;    // no veto for you
        }
        else
        {
            // confirm to the user to decompress
            LPWSTR szMsg = LoadStringPrintfDx(IDS_FILEISUPXED, pszPath);
            nID = MsgBoxDx(szMsg, MB_ICONINFORMATION | MB_YESNOCANCEL);
            if (nID == IDCANCEL)
                return FALSE;   // cancelled
        }

        if (nID == IDYES)   // try to decompress
        {
            // build a temporary file path
            WCHAR szTempFile[MAX_PATH];
            StringCchCopyW(szTempFile, _countof(szTempFile), GetTempFileNameDx(L"UPX"));

            // pszPath --> szTempFile (to be decompressed)
            if (!CopyFileW(pszPath, szTempFile, FALSE) ||
                !DoUpxDecompress(m_szUpxExe, szTempFile))
            {
                DeleteFileW(szTempFile);
                ErrorBoxDx(IDS_CANTUPXEXTRACT);
                return FALSE;   // failure
            }

            // decompressed
            strToOpen = szTempFile;
        }
        else
        {
            // consider as uncompressed
            bCompressed = FALSE;
        }
    }

    // load an executable files
    HMODULE hMod = LoadLibraryExW(strToOpen.c_str(), NULL, LOAD_LIBRARY_AS_DATAFILE |
                                  LOAD_LIBRARY_AS_IMAGE_RESOURCE |
                                  LOAD_WITH_ALTERED_SEARCH_PATH);
    if (hMod == NULL)
    {
        // replace the path
        #ifdef _WIN64
            mstr_replace_all(strToOpen,
                L"C:\\Program Files\\",
                L"C:\\Program Files (x86)\\");
        #else
            mstr_replace_all(strToOpen,
                L"C:\\Program Files (x86)\\",
                L"C:\\Program Files\\");
        #endif

        // retry to load
        hMod = LoadLibraryExW(strToOpen.c_str(), NULL, LOAD_LIBRARY_AS_DATAFILE |
            LOAD_LIBRARY_AS_IMAGE_RESOURCE | LOAD_WITH_ALTERED_SEARCH_PATH);
        if (hMod)
        {
            // ok, succeeded
            StringCchCopy(pszPath, _countof(szPath), strToOpen.c_str());
        }
        else
        {
            // retry again
            hMod = LoadLibraryW(strToOpen.c_str());
            if (hMod == NULL)
            {
                ErrorBoxDx(IDS_CANNOTOPEN);

                // delete the decompressed file if any
                if (bCompressed)
                {
                    ::DeleteFileW(strToOpen.c_str());
                }

                return FALSE;       // failure
            }
        }
    }

    // unload the resource.h file
    UnloadResourceH(hwnd);
    if (g_settings.bAutoLoadNearbyResH)
        CheckResourceH(hwnd, pszPath);

    // load all the resource items from the executable
    m_bLoading = TRUE;
    {
        ShowLangArrow(FALSE);
        g_res.delete_all();
        g_res.from_res(hMod);
    }
    m_bLoading = FALSE;

    // free the executable
    FreeLibrary(hMod);

    // update the file info (using the real path)
    UpdateFileInfo(FT_EXECUTABLE, pszPath, bCompressed);

    // delete the decompressed file if any
    if (bCompressed)
    {
        ::DeleteFileW(strToOpen.c_str());
    }

    // open the ID list window if necessary
    if (m_szResourceH[0] && g_settings.bAutoShowIDList)
    {
        ShowIDList(hwnd, TRUE);
    }

    // select none
    SelectTV(NULL, FALSE);

    DoSetFileModified(FALSE);

    // update language arrow
    PostUpdateLangArrow(m_hwnd);

    return TRUE;    // success
}

// unload resource.h
BOOL MMainWnd::UnloadResourceH(HWND hwnd)
{
    // delete all the macro IDs
    auto it = g_db.m_map.find(L"RESOURCE.ID");
    if (it != g_db.m_map.end())
    {
        it->second.clear();
    }

    // reset the settings of the resource.h file
    g_settings.AddIDC_STATIC();
    g_settings.id_map.clear();
    g_settings.added_ids.clear();
    g_settings.removed_ids.clear();
    m_szResourceH[0] = 0;

    // update the names
    UpdateNames();

    // select the selected entry
    auto entry = g_res.get_entry();
    SelectTV(entry, FALSE);

    // hide the ID list window
    ShowIDList(hwnd, FALSE);

    return TRUE;
}

// check the resource.h file
BOOL MMainWnd::CheckResourceH(HWND hwnd, LPCTSTR pszPath)
{
    // unload the resource.h file
    UnloadResourceH(hwnd);

    // pszPath --> szPath
    TCHAR szPath[MAX_PATH];
    StringCchCopy(szPath, _countof(szPath), pszPath);

    // find the last '\\' or '/'
    TCHAR *pch = _tcsrchr(szPath, TEXT('\\'));
    if (pch == NULL)
        pch = _tcsrchr(szPath, TEXT('/'));
    if (pch == NULL)
        pch = szPath;
    else
        ++pch;

    // find the nearest resource.h file
    size_t diff = pch - szPath;
    StringCchCopy(pch, diff, TEXT("resource.h"));
    if (!PathFileExistsW(szPath))
    {
        StringCchCopy(pch, diff, TEXT("..\\resource.h"));
        if (!PathFileExistsW(szPath))
        {
            StringCchCopy(pch, diff, TEXT("..\\..\\resource.h"));
            if (!PathFileExistsW(szPath))
            {
                StringCchCopy(pch, diff, TEXT("..\\..\\..\\resource.h"));
                if (!PathFileExistsW(szPath))
                {
                    StringCchCopy(pch, diff, TEXT("..\\src\\resource.h"));
                    if (!PathFileExistsW(szPath))
                    {
                        StringCchCopy(pch, diff, TEXT("..\\..\\src\\resource.h"));
                        if (!PathFileExistsW(szPath))
                        {
                            StringCchCopy(pch, diff, TEXT("..\\..\\..\\src\\resource.h"));
                            if (!PathFileExistsW(szPath))
                            {
                                return FALSE;   // not found
                            }
                        }
                    }
                }
            }
        }
    }

    // load the resource.h file
    return DoLoadResH(hwnd, szPath);
}

// load an RC file
BOOL MMainWnd::DoLoadRC(HWND hwnd, LPCWSTR szRCFile, EntrySet& res)
{
    // load the RC file to the res variable
    MStringA strOutput;
    BOOL bOK = res.load_rc(szRCFile, strOutput, m_szWindresExe,
                           m_szMCppExe, m_szMcdxExe, GetMacroDump(),
                           GetIncludesDump());
    if (!bOK)
    {
        // failed. show error message
        if (strOutput.empty())
        {
            MsgBoxDx(LoadStringDx(IDS_COMPILEERROR), MB_ICONERROR);
        }
        else
        {
            MAnsiToWide a2w(CP_ACP, strOutput);
            ErrorBoxDx(a2w.c_str());
        }
    }

    // close the preview
    HidePreview();

    // recalculate the splitter
    PostMessageDx(WM_SIZE);

    return bOK;
}

// find the text
void MMainWnd::OnFind(HWND hwnd)
{
    m_search.bDownward = TRUE;
    OnItemSearch(hwnd);
}

// find next
BOOL MMainWnd::OnFindNext(HWND hwnd)
{
    m_search.bDownward = TRUE;
    if (m_search.strText.empty())
    {
        OnItemSearch(hwnd);
        return TRUE;
    }
    DoItemSearchBang(hwnd, NULL);
    return TRUE;
}

// find previous
BOOL MMainWnd::OnFindPrev(HWND hwnd)
{
    m_search.bDownward = FALSE;
    if (m_search.strText.empty())
    {
        OnItemSearch(hwnd);
        return TRUE;
    }
    DoItemSearchBang(hwnd, NULL);
    return TRUE;
}

BOOL MMainWnd::DoWriteRCLangUTF8(MFile& file, ResToText& res2text, WORD lang, const EntrySet& targets)
{
    MTextToAnsi comment_sep(CP_UTF8, LoadStringDx(IDS_COMMENT_SEP));

    if (!g_settings.bSepFilesByLang && g_settings.bRedundantComments)
    {
        file.WriteSzA(comment_sep.c_str());
        file.WriteSzA("\r\n");
    }

    // dump a comment and a LANGUAGE statement
    MString strLang = ::GetLanguageStatement(lang, TRUE);
    strLang += L"\r\n";
    file.WriteSzA(MWideToAnsi(CP_ACP, strLang).c_str());

    // search the language entries
    EntrySet found;
    targets.search(found, ET_LANG, WORD(0), WORD(0), lang);

    std::vector<EntryBase *> vecFound(found.begin(), found.end());

    std::sort(vecFound.begin(), vecFound.end(),
        [](const EntryBase *a, const EntryBase *b) {
            if (a->m_type < b->m_type)
                return true;
            if (a->m_type > b->m_type)
                return false;
            return a->m_name < b->m_name;
        }
    );

    MIdOrString type, old_type;

    // for all found entries
    for (auto entry : vecFound)
    {
        old_type = type;
        type = entry->m_type;

        // ignore the string or message tables or font dir
        if (type == RT_STRING || type == RT_FONTDIR)
            continue;
        if (type == RT_MESSAGETABLE && !g_settings.bUseMSMSGTABLE)
            continue;

        // dump the entry
        MString str = res2text.DumpEntry(*entry);
        if (!str.empty())
        {
            // output redundant comments
            if (type != old_type && g_settings.bRedundantComments)
            {
                file.WriteSzA(comment_sep.c_str());
                MStringW strType = res2text.GetResTypeName(type);
                MWideToAnsi utf8(CP_UTF8, strType);
                file.WriteSzA("// ");
                file.WriteSzA(utf8.c_str());
                file.WriteSzA("\r\n\r\n");
            }

            mstr_trim(str);     // trim

            // convert the text to UTF-8
            MTextToAnsi t2a(CP_UTF8, str.c_str());
            file.WriteSzA(t2a.c_str());

            // add newlines
            file.WriteSzA("\r\n\r\n");
        }
    }

    // search the string tables
    found.clear();
    targets.search(found, ET_LANG, RT_STRING, (WORD)0, lang);
    if (found.size())
    {
        if (g_settings.bRedundantComments)
        {
            file.WriteSzA(comment_sep.c_str());
            file.WriteSzA("// RT_STRING\r\n\r\n");
        }

        // found --> str_res
        StringRes str_res;
        for (auto e : found)
        {
            if (e->m_lang != lang)
                continue;       // must be same language

            MByteStreamEx stream(e->m_data);
            if (!str_res.LoadFromStream(stream, e->m_name.m_id))
                return FALSE;
        }

        // dump
        MString str = str_res.Dump();

        // trim
        mstr_trim(str);

        // append newlines
        str += L"\r\n\r\n";

        // convert the text to UTF-8
        MTextToAnsi t2a(CP_UTF8, str.c_str());

        // write it
        file.WriteSzA(t2a.c_str());
    }

    // search the message tables
    found.clear();
    if (!g_settings.bUseMSMSGTABLE)
    {
        targets.search(found, ET_LANG, RT_MESSAGETABLE, (WORD)0, lang);
        if (found.size())
        {
            if (g_settings.bRedundantComments)
            {
                file.WriteSzA(comment_sep.c_str());
                file.WriteSzA("// RT_MESSAGETABLE\r\n\r\n");
            }

            // found --> msg_res
            MessageRes msg_res;
            for (auto e : found)
            {
                if (e->m_lang != lang)
                    continue;       // must be same language

                MByteStreamEx stream(e->m_data);
                if (!msg_res.LoadFromStream(stream, e->m_name.m_id))
                    return FALSE;
            }

            // dump it
            MString str;
            str += L"#ifdef APSTUDIO_INVOKED\r\n";
            str += L"    #error Ap Studio cannot edit this message table.\r\n";
            str += L"#endif\r\n";
            str += L"#ifdef MCDX_INVOKED\r\n";
            str += msg_res.Dump();
            str += L"#endif\r\n\r\n";

            // convert it to UTF-8
            MTextToAnsi t2a(CP_UTF8, str.c_str());

            // write it
            file.WriteSzA(t2a.c_str());
        }
    }

    return TRUE;
}

BOOL MMainWnd::DoWriteRCLangUTF16(MFile& file, ResToText& res2text, WORD lang, const EntrySet& targets)
{
    MString comment_sep(LoadStringDx(IDS_COMMENT_SEP));

    if (!g_settings.bSepFilesByLang && g_settings.bRedundantComments)
    {
        file.WriteSzW(comment_sep.c_str());
        file.WriteSzW(L"\r\n");
    }

    // dump a comment and a LANGUAGE statement
    MString strLang = ::GetLanguageStatement(lang, TRUE);
    strLang += L"\r\n";
    file.WriteSzW(strLang.c_str());

    // search the language entries
    EntrySet found;
    targets.search(found, ET_LANG, WORD(0), WORD(0), lang);

    std::vector<EntryBase *> vecFound(found.begin(), found.end());

    std::sort(vecFound.begin(), vecFound.end(),
        [](const EntryBase *a, const EntryBase *b) {
            if (a->m_type < b->m_type)
                return true;
            if (a->m_type > b->m_type)
                return false;
            return a->m_name < b->m_name;
        }
    );

    MIdOrString type, old_type;

    // for all found entries
    for (auto entry : vecFound)
    {
        old_type = type;
        type = entry->m_type;

        // ignore the string or message tables or font dir 
        if (type == RT_STRING || type == RT_FONTDIR)
            continue;
        if (type == RT_MESSAGETABLE && !g_settings.bUseMSMSGTABLE)
            continue;

        // dump the entry
        MString str = res2text.DumpEntry(*entry);
        if (!str.empty())
        {
            // output redundant comments
            if (type != old_type && g_settings.bRedundantComments)
            {
                file.WriteSzW(comment_sep.c_str());
                MStringW strType = res2text.GetResTypeName(type);
                file.WriteSzW(L"// ");
                file.WriteSzW(strType.c_str());
                file.WriteSzW(L"\r\n\r\n");
            }

            mstr_trim(str);     // trim

            // convert the text to UTF-8
            file.WriteSzW(str.c_str());

            // add newlines
            file.WriteSzW(L"\r\n\r\n");
        }
    }

    // search the string tables
    found.clear();
    targets.search(found, ET_LANG, RT_STRING, (WORD)0, lang);
    if (found.size())
    {
        if (g_settings.bRedundantComments)
        {
            file.WriteSzW(comment_sep.c_str());
            file.WriteSzW(L"// RT_STRING\r\n\r\n");
        }

        // found --> str_res
        StringRes str_res;
        for (auto e : found)
        {
            if (e->m_lang != lang)
                continue;       // must be same language

            MByteStreamEx stream(e->m_data);
            if (!str_res.LoadFromStream(stream, e->m_name.m_id))
                return FALSE;
        }

        // dump
        MString str = str_res.Dump();

        // trim
        mstr_trim(str);

        // append newlines
        str += L"\r\n\r\n";

        // write it
        file.WriteSzW(str.c_str());
    }

    // search the message tables
    found.clear();
    if (!g_settings.bUseMSMSGTABLE)
    {
        targets.search(found, ET_LANG, RT_MESSAGETABLE, (WORD)0, lang);
        if (found.size())
        {
            if (g_settings.bRedundantComments)
            {
                file.WriteSzW(comment_sep.c_str());
                file.WriteSzW(L"// RT_MESSAGETABLE\r\n\r\n");
            }

            // found --> msg_res
            MessageRes msg_res;
            for (auto e : found)
            {
                if (e->m_lang != lang)
                    continue;       // must be same language

                MByteStreamEx stream(e->m_data);
                if (!msg_res.LoadFromStream(stream, e->m_name.m_id))
                    return FALSE;
            }

            // dump it
            MString str;
            str += L"#ifdef APSTUDIO_INVOKED\r\n";
            str += L"    #error Ap Studio cannot edit this message table.\r\n";
            str += L"#endif\r\n";
            str += L"#ifdef MCDX_INVOKED\r\n";
            str += msg_res.Dump();
            str += L"#endif\r\n\r\n";

            // write it
            file.WriteSzW(str.c_str());
        }
    }

    return TRUE;
}

// write a language-specific RC text
BOOL MMainWnd::DoWriteRCLang(MFile& file, ResToText& res2text, WORD lang, const EntrySet& targets)
{
    if (g_settings.bRCFileUTF16)
        return DoWriteRCLangUTF16(file, res2text, lang, targets);
    else
        return DoWriteRCLangUTF8(file, res2text, lang, targets);
}

// do backup a folder
BOOL MMainWnd::DoBackupFolder(LPCWSTR pszPath, UINT nCount)
{
    if (!PathIsDirectoryW(pszPath))
        return TRUE;    // no files to be backup'ed

    if (nCount < s_nBackupMaxCount)     // less than max count
    {
        MString strPath = pszPath;
        strPath += g_settings.strBackupSuffix;

        // do backup the "old" folder (recursively)
        DoBackupFolder(strPath.c_str(), nCount + 1);

        // rename the current folder as an "old" folder
        return MoveFileExW(pszPath, strPath.c_str(),
                           MOVEFILE_COPY_ALLOWED | MOVEFILE_REPLACE_EXISTING);
    }
    else
    {
        // unable to create one more backup. delete it
        DeleteDirectoryDx(pszPath);
    }

    return TRUE;
}

// do backup a file
BOOL MMainWnd::DoBackupFile(LPCWSTR pszPath, UINT nCount)
{
    if (!PathFileExistsW(pszPath))
        return TRUE;

    if (nCount < s_nBackupMaxCount)     // less than max count
    {
        MString strPath = pszPath;
        strPath += g_settings.strBackupSuffix;

        // do backup the "old" file (recursively)
        DoBackupFile(strPath.c_str(), nCount + 1);

        // copy the current file as an "old" file
        return CopyFileW(pszPath, strPath.c_str(), FALSE);
    }
    else
    {
        // otherwise overwritten
    }

    return TRUE;
}

// write a RC file
BOOL MMainWnd::DoWriteRC(LPCWSTR pszFileName, LPCWSTR pszResH)
{
    EntrySet found;
    g_res.search(found, ET_LANG);

    return DoWriteRC(pszFileName, pszResH, found);
}

// write a RC file
BOOL MMainWnd::DoWriteRC(LPCWSTR pszFileName, LPCWSTR pszResH, const EntrySet& found)
{
    ResToText res2text;
    res2text.m_bHumanReadable = FALSE;  // it's not human-friendly
    res2text.m_bNoLanguage = TRUE;      // no LANGUAGE statements generated

    MWideToAnsi comment_sep(CP_UTF8, LoadStringDx(IDS_COMMENT_SEP));

    // check not locking
    if (IsFileLockedDx(pszFileName))
    {
        WCHAR szMsg[MAX_PATH + 256];
        StringCchPrintfW(szMsg, _countof(szMsg), LoadStringDx(IDS_CANTWRITEBYLOCK), pszFileName);
        ErrorBoxDx(szMsg);
        return FALSE;
    }

    // at first, backup it
    if (g_settings.bBackup)
        DoBackupFile(pszFileName);

    // create a RC file
    MFile file(pszFileName, TRUE);
    if (!file)
        return FALSE;

    BOOL bRCFileUTF16 = g_settings.bRCFileUTF16;

    WCHAR szTitle[MAX_PATH];
    GetFileTitleW(pszFileName, szTitle, _countof(szTitle));

    // dump heading
    if (bRCFileUTF16)
    {
        file.WriteFormatW(L"// %s\r\n", szTitle);

        file.WriteSzW(LoadStringDx(IDS_NOTICE));
        file.WriteSzW(LoadStringDx(IDS_DAGGER));
        file.WriteSzW(L"\r\n");

        if (pszResH && pszResH[0])
            file.WriteSzW(L"#include \"resource.h\"\r\n");
        file.WriteSzW(L"#define APSTUDIO_HIDDEN_SYMBOLS\r\n");
        file.WriteSzW(L"#include <windows.h>\r\n");
        file.WriteSzW(L"#include <commctrl.h>\r\n");
        file.WriteSzW(L"#undef APSTUDIO_HIDDEN_SYMBOLS\r\n");
        file.WriteSzW(L"#pragma code_page(65001) // UTF-8\r\n\r\n");

        if (g_settings.bUseIDC_STATIC && !g_settings.bHideID)
        {
            file.WriteSzW(L"#ifndef IDC_STATIC\r\n");
            file.WriteSzW(L"    #define IDC_STATIC (-1)\r\n");
            file.WriteSzW(L"#endif\r\n\r\n");
        }
    }
    else
    {
        MWideToAnsi utf8(CP_UTF8, szTitle);
        file.WriteFormatA("// %s\r\n", utf8.c_str());

        MWideToAnsi utf8Notice(CP_UTF8, LoadStringDx(IDS_NOTICE));
        MWideToAnsi utf8Dagger(CP_UTF8, LoadStringDx(IDS_DAGGER));
        file.WriteSzA(utf8Notice.c_str());
        file.WriteSzA(utf8Dagger.c_str());
        file.WriteSzA("\r\n");

        if (pszResH && pszResH[0])
            file.WriteSzA("#include \"resource.h\"\r\n");
        file.WriteSzA("#define APSTUDIO_HIDDEN_SYMBOLS\r\n");
        file.WriteSzA("#include <windows.h>\r\n");
        file.WriteSzA("#include <commctrl.h>\r\n");
        file.WriteSzA("#undef APSTUDIO_HIDDEN_SYMBOLS\r\n");
        file.WriteSzA("#pragma code_page(65001) // UTF-8\r\n\r\n");

        if (g_settings.bUseIDC_STATIC && !g_settings.bHideID)
        {
            file.WriteSzA("#ifndef IDC_STATIC\r\n");
            file.WriteSzA("    #define IDC_STATIC (-1)\r\n");
            file.WriteSzA("#endif\r\n\r\n");
        }
    }

    // get the used languages
    std::unordered_set<WORD> langs;
    typedef std::pair<WORD, MStringW> lang_pair;
    std::vector<lang_pair> lang_vec;

    for (auto res : found)
    {
        WORD lang = res->m_lang;
        if (langs.insert(lang).second)
        {
            MString lang_name = g_db.GetLangName(lang);
            lang_vec.push_back(std::make_pair(lang, lang_name));
        }
    }

    // sort by lang_name
    std::sort(lang_vec.begin(), lang_vec.end(),
        [](const lang_pair& a, const lang_pair& b) {
            return (a.second < b.second);
        }
    );

    // add "res/" to the prefix if necessary
    if (g_settings.bStoreToResFolder)
        res2text.m_strFilePrefix = L"res/";

    // use the "lang" folder?
    if (g_settings.bSepFilesByLang)
    {
        // dump neutral
        if (langs.count(0) > 0)
        {
            if (!DoWriteRCLang(file, res2text, 0, found))
                return FALSE;
        }

        // create "lang" directory path
        WCHAR szLangDir[MAX_PATH];
        StringCchCopyW(szLangDir, _countof(szLangDir), pszFileName);

        // find the last '\\' or '/'
        WCHAR *pch = wcsrchr(szLangDir, L'\\');
        if (pch == NULL)
            pch = mstrrchr(szLangDir, L'/');
        if (pch == NULL)
            return FALSE;

        // build the lang directory path
        *pch = 0;
        StringCchCatW(szLangDir, _countof(szLangDir), TEXT("/lang"));

        // backup and create "lang" directory
        for (auto lang_pair : lang_vec)
        {
            if (!lang_pair.first)
                continue;

            if (g_settings.bBackup)
                DoBackupFolder(szLangDir);

            CreateDirectory(szLangDir, NULL);
            break;
        }

        // for each language
        for (auto lang_pair : lang_vec)
        {
            auto lang = lang_pair.first;
            if (!lang)
                continue;

            // create lang/XX_XX.rc file
            WCHAR szLangFile[MAX_PATH];
            StringCchCopyW(szLangFile, _countof(szLangFile), szLangDir);
            StringCchCatW(szLangFile, _countof(szLangFile), TEXT("/"));
            MStringW lang_name = lang_pair.second;
            StringCchCatW(szLangFile, _countof(szLangFile), lang_name.c_str());
            StringCchCatW(szLangFile, _countof(szLangFile), TEXT(".rc"));
            //MessageBox(NULL, szLangFile, NULL, 0);

            if (g_settings.bBackup)
                DoBackupFile(szLangFile);

            // dump to lang/XX_XX.rc file
            MFile lang_file(szLangFile, TRUE);
            if (bRCFileUTF16)
            {
                lang_file.WriteSzW(LoadStringDx(IDS_NOTICE));
                lang_file.WriteSzW(LoadStringDx(IDS_DAGGER));
                lang_file.WriteSzW(L"\r\n");
                lang_file.WriteSzW(L"#pragma code_page(65001) // UTF-8\r\n\r\n");
            }
            else
            {
                MWideToAnsi utf8Notice(CP_UTF8, LoadStringDx(IDS_NOTICE));
                MWideToAnsi utf8Dagger(CP_UTF8, LoadStringDx(IDS_DAGGER));
                lang_file.WriteSzA(utf8Notice.c_str());
                lang_file.WriteSzA(utf8Dagger.c_str());
                lang_file.WriteSzA("\r\n");
                lang_file.WriteSzA("#pragma code_page(65001) // UTF-8\r\n\r\n");
            }
            if (!lang_file)
                return FALSE;
            if (!DoWriteRCLang(lang_file, res2text, lang, found))
                return FALSE;

            if (g_settings.bRedundantComments)
            {
                if (bRCFileUTF16)
                {
                    lang_file.WriteSzW(LoadStringDx(IDS_COMMENT_SEP));
                }
                else
                {
                    lang_file.WriteSzA(comment_sep.c_str());
                }
            }
        }
    }
    else
    {
        // don't use the "lang" folder
        for (auto lang_pair : lang_vec)
        {
            auto lang = lang_pair.first;
            // write it for each language
            if (!DoWriteRCLang(file, res2text, lang, found))
                return FALSE;
        }
    }

    // dump language includes
    if (g_settings.bSepFilesByLang)
    {
        // write a C++ comment to make a section
        if (g_settings.bRedundantComments)
        {
            if (bRCFileUTF16)
            {
                file.WriteSzW(LoadStringDx(IDS_COMMENT_SEP));
                file.WriteSzW(L"// Languages\r\n\r\n");
            }
            else
            {
                file.WriteSzA(comment_sep.c_str());
                file.WriteSzA("// Languages\r\n\r\n");
            }
        }

        if (g_settings.bSelectableByMacro)
        {
            for (auto lang_pair : lang_vec)     // for each language
            {
                auto lang = lang_pair.first;
                if (!lang)
                    continue;       // ignore neutral language

                // get the language name (such as en_US, ja_JP, etc.) from database
                MString lang_name1 = g_db.GetLangName(lang);

                // make uppercase one
                MString lang_name2 = lang_name1;
                CharUpperW(&lang_name2[0]);

                if (bRCFileUTF16)
                {
                    // write "#ifdef LANGUAGE_...\r\n"
                    file.WriteSzW(L"#ifdef LANGUAGE_");
                    file.WriteSzW(lang_name2.c_str());
                    file.WriteSzW(L"\r\n");

                    // write "#define \"lang/....rc\"\r\n"
                    file.WriteSzW(L"    #include \"lang/");
                    file.WriteSzW(lang_name1.c_str());
                    file.WriteSzW(L".rc\"\r\n");

                    // write "#endif\r\n"
                    file.WriteSzW(L"#endif\r\n");
                }
                else
                {
                    // write "#ifdef LANGUAGE_...\r\n"
                    file.WriteSzA("#ifdef LANGUAGE_");
                    MWideToAnsi lang2_w2a(CP_ACP, lang_name2);
                    file.WriteSzA(lang2_w2a.c_str());
                    file.WriteSzA("\r\n");

                    // write "#define \"lang/....rc\"\r\n"
                    file.WriteSzA("    #include \"lang/");
                    MWideToAnsi lang1_w2a(CP_ACP, lang_name1);
                    file.WriteSzA(lang1_w2a.c_str());
                    file.WriteSzA(".rc\"\r\n");

                    // write "#endif\r\n"
                    file.WriteSzA("#endif\r\n");
                }
            }
        }
        else
        {
            for (auto lang_pair : lang_vec)
            {
                auto lang = lang_pair.first;
                if (!lang)
                    continue;   // ignore the neutral language

                // get the language name (such as en_US, ja_JP, etc.) from database
                MString lang_name1 = g_db.GetLangName(lang);

                if (bRCFileUTF16)
                {
                    // write "#include \"lang/....rc\"\r\n"
                    file.WriteSzW(L"#include \"lang/");
                    file.WriteSzW(lang_name1.c_str());
                    file.WriteSzW(L".rc\"\r\n");
                }
                else
                {
                    // write "#include \"lang/....rc\"\r\n"
                    file.WriteSzA("#include \"lang/");
                    file.WriteSzA(MWideToAnsi(CP_ACP, lang_name1).c_str());
                    file.WriteSzA(".rc\"\r\n");
                }
            }
        }

        if (bRCFileUTF16)
            file.WriteSzW(L"\r\n");
        else
            file.WriteSzA("\r\n");
    }

    if (g_settings.bRedundantComments)
    {
        if (bRCFileUTF16)
        {
            file.WriteSzW(LoadStringDx(IDS_COMMENT_SEP));
            file.WriteSzW(L"// TEXTINCLUDE\r\n\r\n");
        }
        else
        {
            file.WriteSzA(comment_sep.c_str());
            file.WriteSzA("// TEXTINCLUDE\r\n\r\n");
        }
    }

    if (bRCFileUTF16)
    {
        file.WriteSzW(L"#ifdef APSTUDIO_INVOKED\r\n\r\n");

        // write three TEXTINCLUDE's
        file.WriteSzW(L"1 TEXTINCLUDE\r\n");
        file.WriteSzW(L"BEGIN\r\n");
        file.WriteSzW(L"    \"resource.h\\0\"\r\n");
        file.WriteSzW(L"END\r\n\r\n");

        file.WriteSzW(L"2 TEXTINCLUDE\r\n");
        file.WriteSzW(L"BEGIN\r\n");
        file.WriteSzW(L"    \"#define APSTUDIO_HIDDEN_SYMBOLS\\r\\n\"\r\n");
        file.WriteSzW(L"    \"#include <windows.h>\\r\\n\"\r\n");
        file.WriteSzW(L"    \"#include <commctrl.h>\\r\\n\"\r\n");
        file.WriteSzW(L"    \"#undef APSTUDIO_HIDDEN_SYMBOLS\\r\\n\"\r\n");
        file.WriteSzW(L"    \"\\0\"\r\n");
        file.WriteSzW(L"END\r\n\r\n");

        file.WriteSzW(L"3 TEXTINCLUDE\r\n");
        file.WriteSzW(L"BEGIN\r\n");
        file.WriteSzW(L"    \"\\r\\n\"\r\n");
        file.WriteSzW(L"    \"\\0\"\r\n");
        file.WriteSzW(L"END\r\n\r\n");

        file.WriteSzW(L"#endif    // APSTUDIO_INVOKED\r\n");

        if (g_settings.bRedundantComments)
        {
            file.WriteSzW(L"\r\n");
            file.WriteSzW(LoadStringDx(IDS_COMMENT_SEP));
        }
    }
    else
    {
        file.WriteSzA("#ifdef APSTUDIO_INVOKED\r\n\r\n");

        // write three TEXTINCLUDE's
        file.WriteSzA("1 TEXTINCLUDE\r\n");
        file.WriteSzA("BEGIN\r\n");
        file.WriteSzA("    \"resource.h\\0\"\r\n");
        file.WriteSzA("END\r\n\r\n");

        file.WriteSzA("2 TEXTINCLUDE\r\n");
        file.WriteSzA("BEGIN\r\n");
        file.WriteSzA("    \"#define APSTUDIO_HIDDEN_SYMBOLS\\r\\n\"\r\n");
        file.WriteSzA("    \"#include <windows.h>\\r\\n\"\r\n");
        file.WriteSzA("    \"#include <commctrl.h>\\r\\n\"\r\n");
        file.WriteSzA("    \"#undef APSTUDIO_HIDDEN_SYMBOLS\\r\\n\"\r\n");
        file.WriteSzA("    \"\\0\"\r\n");
        file.WriteSzA("END\r\n\r\n");

        file.WriteSzA("3 TEXTINCLUDE\r\n");
        file.WriteSzA("BEGIN\r\n");
        file.WriteSzA("    \"\\r\\n\"\r\n");
        file.WriteSzA("    \"\\0\"\r\n");
        file.WriteSzA("END\r\n\r\n");

        file.WriteSzA("#endif    // APSTUDIO_INVOKED\r\n");

        if (g_settings.bRedundantComments)
        {
            file.WriteSzA("\r\n");
            file.WriteSzA(comment_sep.c_str());
        }
    }

    return TRUE;
}

struct MACRO_DEF
{
    MStringA prefix;
    MStringA name;
    DWORD value;
    MStringA definition;
};

void WriteMacroLine(MFile& file, const MStringA& name, const MStringA& definition)
{
    MStringA strSpace(" ");
    if (name.size() < 35)
        strSpace.assign(35 - name.size(), ' ');
    file.WriteFormatA("#define %s %s%s\r\n",
        name.c_str(), strSpace.c_str(), definition.c_str());
}

// write the resource.h file
BOOL MMainWnd::DoWriteResH(LPCWSTR pszResH, LPCWSTR pszRCFile)
{
    // check not locking
    if (IsFileLockedDx(pszResH))
    {
        WCHAR szMsg[MAX_PATH + 256];
        StringCchPrintfW(szMsg, _countof(szMsg), LoadStringDx(IDS_CANTWRITEBYLOCK), pszResH);
        ErrorBoxDx(szMsg);
        return FALSE;
    }

    // do backup the resource.h file
    if (g_settings.bBackup)
        DoBackupFile(pszResH);

    // create the resource.h file
    MFile file(pszResH, TRUE);
    if (!file)
        return FALSE;

    // write a heading
    file.WriteSzA("//{{NO_DEPENDENCIES}}\r\n");
    file.WriteSzA("// Microsoft Visual C++ Compatible\r\n");

    MWideToAnsi utf8Notice(CP_UTF8, LoadStringDx(IDS_NOTICE));
    file.WriteFormatA(utf8Notice.c_str());

    // write the RC file info if necessary
    if (pszRCFile)
    {
        // get file title
        TCHAR szFileTitle[64];
        GetFileTitle(pszRCFile, szFileTitle, _countof(szFileTitle));

        // change extension to .rc
        LPTSTR pch = mstrrchr(szFileTitle, TEXT('.'));
        if (pch)
        {
            *pch = 0;
            StringCchCatW(szFileTitle, _countof(szFileTitle), TEXT(".rc"));
        }

        // write file title
        file.WriteSzA("// ");
        file.WriteSzA(MTextToAnsi(CP_ACP, szFileTitle).c_str());
        file.WriteSzA("\r\n");
    }

    // sort macro definitions
    std::vector<MACRO_DEF> defs;
    for (auto& pair : g_settings.id_map)
    {
        if (pair.first == "IDC_STATIC")
            continue;

        MACRO_DEF def;
        def.name = pair.first;
        def.definition = pair.second;
        def.value = mstr_parse_int(pair.second.c_str(), true, 0);
        size_t i = pair.first.find('_');
        if (i != MStringA::npos)
        {
            def.prefix = pair.first.substr(0, i + 1);
        }
        defs.push_back(def);
    }
    std::sort(defs.begin(), defs.end(),
        [](const MACRO_DEF& a, const MACRO_DEF& b) {
            if (a.prefix.empty() && b.prefix.empty())
                return a.value < b.value;
            if (a.prefix.empty())
                return false;
            if (b.prefix.empty())
                return true;
            if (a.prefix < b.prefix)
                return true;
            if (a.prefix > b.prefix)
                return false;
            if (a.definition.empty() && b.definition.empty())
                return false;
            if (a.definition.empty())
                return true;
            if (b.definition.empty())
                return false;
            if (a.definition[0] == '"' && b.definition[0] == '"')
                return a.definition < b.definition;
            if (a.definition[0] == '"')
                return false;
            if (b.definition[0] == '"')
                return true;
            if (a.value < b.value)
                return true;
            if (a.value > b.value)
                return false;
            return false;
        }
    );

    if (g_settings.bUseIDC_STATIC)
    {
        // write the macro definitions
        file.WriteSzA("\r\n");
        WriteMacroLine(file, "IDC_STATIC", "(-1)");
    }

    MStringA prefix;
    bool first = true;
    file.WriteFormatA("\r\n");
    for (auto& def : defs)
    {
        if (def.name == "IDC_STATIC")
            continue;

        if (!first && prefix != def.prefix)
            file.WriteFormatA("\r\n");

        WriteMacroLine(file, def.name, def.definition);

        prefix = def.prefix;
        first = false;
    }

    // do statistics about resource IDs
    UINT anValues[5];
    DoIDStat(anValues);

    // dump the statistics
    file.WriteFormatA("\r\n");
    file.WriteFormatA("#ifdef APSTUDIO_INVOKED\r\n");
    file.WriteFormatA("    #ifndef APSTUDIO_READONLY_SYMBOLS\r\n");
    file.WriteFormatA("        #define _APS_NO_MFC                 %u\r\n", anValues[0]);
    file.WriteFormatA("        #define _APS_NEXT_RESOURCE_VALUE    %u\r\n", anValues[1]);
    file.WriteFormatA("        #define _APS_NEXT_COMMAND_VALUE     %u\r\n", anValues[2]);
    file.WriteFormatA("        #define _APS_NEXT_CONTROL_VALUE     %u\r\n", anValues[3]);
    file.WriteFormatA("        #define _APS_NEXT_SYMED_VALUE       %u\r\n", anValues[4]);
    file.WriteFormatA("    #endif\r\n");
    file.WriteFormatA("#endif\r\n");

    return TRUE;
}

// write the resource.h file
BOOL MMainWnd::DoWriteResHOfExe(LPCWSTR pszExeFile)
{
    assert(pszExeFile);

    // pszExeFile --> szResH
    WCHAR szResH[MAX_PATH];
    StringCchCopyW(szResH, _countof(szResH), pszExeFile);

    // find the last '\\' or '/'
    LPWSTR pch = wcsrchr(szResH, L'\\');
    if (!pch)
        pch = wcsrchr(szResH, L'/');
    if (!pch)
        return FALSE;

    // build the "resource.h" file path
    ++pch;
    *pch = 0;
    StringCchCatW(szResH, _countof(szResH), L"resource.h");

    // write the "resource.h" file
    if (DoWriteResH(szResH))
    {
        // szResH --> m_szResourceH
        StringCchCopyW(m_szResourceH, _countof(m_szResourceH), szResH);
        return TRUE;
    }

    return FALSE;   // failure
}

// do statistics for resource IDs
void MMainWnd::DoIDStat(UINT anValues[5])
{
    const size_t count = 4;

    INT anNext[count];
    MString prefixes[count];
    prefixes[0] = g_settings.assoc_map[L"Resource.ID"];
    prefixes[1] = g_settings.assoc_map[L"Command.ID"];
    prefixes[2] = g_settings.assoc_map[L"New.Command.ID"];
    prefixes[3] = g_settings.assoc_map[L"Control.ID"];

    for (size_t i = 0; i < count; ++i)
    {
        auto table = g_db.GetTableByPrefix(L"RESOURCE.ID", prefixes[i]);

        UINT nMax = 0;
        for (auto& table_entry : table)
        {
            if (table_entry.name == L"IDC_STATIC")
                continue;

            if (i == 3)
            {
                if (g_res.find(ET_LANG, RT_CURSOR, WORD(table_entry.value)))
                    continue;   // it was Cursor.ID, not Control.ID
            }

            if (nMax < table_entry.value)
                nMax = table_entry.value;
        }

        anNext[i] = nMax + 1;
    }

    anValues[0] = 1;
    anValues[1] = anNext[0];
#undef max
    anValues[2] = std::max(anNext[1], anNext[2]);
    anValues[3] = anNext[3];
    anValues[4] = 300;

    // fix for preferable values
    if (anValues[1] < 100)
        anValues[1] = 100;
    if (anValues[2] < 100)
        anValues[2] = 100;
    if (anValues[3] < 1000)
        anValues[3] = 1000;
}

// extract the resource data to a file
inline BOOL MMainWnd::DoExtract(const EntryBase *entry, BOOL bExporting)
{
    ResToText res2text;

    if (bExporting && g_settings.bStoreToResFolder)
    {
        // add "res\\" to the prefix if necessary
        res2text.m_strFilePrefix = L"res\\";
    }

    // get the entry file name
    MString filename = res2text.GetEntryFileName(*entry);
    if (filename.empty())
        return TRUE;        // no need to extract

    //MessageBox(NULL, filename.c_str(), NULL, 0);

    if (entry->m_type.is_int())
    {
        WORD wType = entry->m_type.m_id;
        if (wType == (WORD)(UINT_PTR)RT_CURSOR)
        {
            // No output file
            return TRUE;
        }
        if (wType == (WORD)(UINT_PTR)RT_BITMAP)
        {
            return PackedDIB_Extract(filename.c_str(), &(*entry)[0], entry->size(), FALSE);
        }
        if (wType == (WORD)(UINT_PTR)RT_ICON)
        {
            // No output file
            return TRUE;
        }
        if (wType == (WORD)(UINT_PTR)RT_MENU)
        {
            // No output file
            return TRUE;
        }
        if (wType == (WORD)(UINT_PTR)RT_TOOLBAR)
        {
            // No output file
            return TRUE;
        }
        if (wType == (WORD)(UINT_PTR)RT_DIALOG)
        {
            // No output file
            return TRUE;
        }
        if (wType == (WORD)(UINT_PTR)RT_STRING)
        {
            // No output file
            return TRUE;
        }
        if (wType == (WORD)(UINT_PTR)RT_FONTDIR)
        {
            return TRUE;
        }
        if (wType == (WORD)(UINT_PTR)RT_FONT)
        {
            return g_res.extract_bin(filename.c_str(), entry);
        }
        if (wType == (WORD)(UINT_PTR)RT_ACCELERATOR)
        {
            // No output file
            return TRUE;
        }
        if (wType == (WORD)(UINT_PTR)RT_RCDATA)
        {
            return g_res.extract_bin(filename.c_str(), entry);
        }
        if (wType == (WORD)(UINT_PTR)RT_MESSAGETABLE)
        {
            if (g_settings.bUseMSMSGTABLE)
            {
                return g_res.extract_bin(filename.c_str(), entry);
            }
            else
            {
                // No output file
                return TRUE;
            }
        }
        if (wType == (WORD)(UINT_PTR)RT_GROUP_CURSOR)
        {
            return g_res.extract_cursor(filename.c_str(), entry);
        }
        if (wType == (WORD)(UINT_PTR)RT_GROUP_ICON)
        {
            return g_res.extract_icon(filename.c_str(), entry);
        }
        if (wType == (WORD)(UINT_PTR)RT_VERSION)
        {
            // No output file
            return TRUE;
        }
        if (wType == (WORD)(UINT_PTR)RT_DLGINIT)
        {
            // No output file
            return TRUE;
        }
        if (wType == (WORD)(UINT_PTR)RT_DLGINCLUDE)
        {
            return g_res.extract_bin(filename.c_str(), entry);
        }
        if (wType == (WORD)(UINT_PTR)RT_PLUGPLAY)
        {
            return g_res.extract_bin(filename.c_str(), entry);
        }
        if (wType == (WORD)(UINT_PTR)RT_VXD)
        {
            return g_res.extract_bin(filename.c_str(), entry);
        }
        if (wType == (WORD)(UINT_PTR)RT_ANICURSOR)
        {
            return g_res.extract_cursor(filename.c_str(), entry);
        }
        if (wType == (WORD)(UINT_PTR)RT_ANIICON)
        {
            return g_res.extract_icon(filename.c_str(), entry);
        }
    }
    else
    {
        if (entry->m_type == L"AVI")
        {
            return g_res.extract_bin(filename.c_str(), entry);
        }
        if (entry->m_type == L"PNG")
        {
            return g_res.extract_bin(filename.c_str(), entry);
        }
        if (entry->m_type == L"GIF")
        {
            return g_res.extract_bin(filename.c_str(), entry);
        }
        if (entry->m_type == L"JPEG")
        {
            return g_res.extract_bin(filename.c_str(), entry);
        }
        if (entry->m_type == L"JPG")
        {
            return g_res.extract_bin(filename.c_str(), entry);
        }
        if (entry->m_type == L"TIFF")
        {
            return g_res.extract_bin(filename.c_str(), entry);
        }
        if (entry->m_type == L"TIF")
        {
            return g_res.extract_bin(filename.c_str(), entry);
        }
        if (entry->m_type == L"EMF")
        {
            return g_res.extract_bin(filename.c_str(), entry);
        }
        if (entry->m_type == L"ENHMETAFILE")
        {
            return g_res.extract_bin(filename.c_str(), entry);
        }
        if (entry->m_type == L"WMF")
        {
            return g_res.extract_bin(filename.c_str(), entry);
        }
        if (entry->m_type == L"WAVE")
        {
            return g_res.extract_bin(filename.c_str(), entry);
        }
        if (entry->m_type == L"IMAGE")
        {
            return g_res.extract_bin(filename.c_str(), entry);
        }
    }

    return g_res.extract_bin(filename.c_str(), entry);
}

// do export the resource data to an RC file and related files
BOOL MMainWnd::DoExport(LPCWSTR pszRCFile, LPWSTR pszResHFile)
{
    // search the language entries
    EntrySet found;
    g_res.search(found, ET_LANG);

    return DoExport(pszRCFile, pszResHFile, found);
}

// do export the resource data to an RC file and related files
BOOL MMainWnd::DoExport(LPCWSTR pszRCFile, LPWSTR pszResHFile, const EntrySet& found)
{
    if (found.empty())
    {
        // unable to export the empty data
        ErrorBoxDx(IDS_DATAISEMPTY);
        return FALSE;
    }

    // pszRCFile --> szPath
    WCHAR szPath[MAX_PATH];
    StringCchCopy(szPath, _countof(szPath), pszRCFile);

    // find the '\\' or '/' character
    WCHAR *pch = mstrrchr(szPath, L'\\');
    if (!pch)
        pch = mstrrchr(szPath, L'/');
    if (!pch)
        return FALSE;   // failure

    *pch = 0;

    // check whether there is an external file to be extracted
    BOOL bHasExternFile = FALSE;
    for (auto e : found)
    {
        ResToText res2text;
        MString filename = res2text.GetEntryFileName(*e);
        if (filename.size())
        {
            bHasExternFile = TRUE;
            break;
        }
    }

    // if g_settings.bStoreToResFolder is set, then check the folder is not empty
    if (!IsEmptyDirectoryDx(szPath))
    {
        if (bHasExternFile && !g_settings.bStoreToResFolder)
        {
            ErrorBoxDx(IDS_MUSTBEEMPTYDIR);
            return FALSE;
        }
    }

    // save the current directory and move the current directory
    WCHAR szCurDir[MAX_PATH];
    GetCurrentDirectory(_countof(szCurDir), szCurDir);
    if (!SetCurrentDirectory(szPath))
        return FALSE;

    if (bHasExternFile)
    {
        // create the "res" folder (with backuping) if necessary
        if (g_settings.bStoreToResFolder)
        {
            MString strResDir = szPath;
            strResDir += TEXT("\\res");

            if (g_settings.bBackup)
                DoBackupFolder(strResDir.c_str());

            CreateDirectory(strResDir.c_str(), NULL);
        }

        // extract each data if necessary
        for (auto e : found)
        {
            if (e->m_type == RT_STRING || e->m_type == RT_FONTDIR)
                continue;
            if (e->m_type == RT_MESSAGETABLE && !g_settings.bUseMSMSGTABLE)
                continue;
            if (!DoExtract(e, TRUE))
                return FALSE;
        }
    }

    BOOL bOK = FALSE;
    if ((m_szResourceH[0] || !g_settings.IsIDMapEmpty()) &&
        !g_settings.bHideID)
    {
        // build the resource.h file path
        *pch = 0;
        StringCchCatW(szPath, _countof(szPath), L"\\resource.h");

        // write the resource.h file and the RC file
        bOK = DoWriteResH(szPath, pszRCFile) && DoWriteRC(pszRCFile, szPath, found);

        // szPath --> pszResHFile
        if (bOK && pszResHFile)
            StringCchCopyW(pszResHFile, MAX_PATH, szPath);
    }
    else
    {
        // write the RC file
        bOK = DoWriteRC(pszRCFile, NULL, found);
    }

    // resume the current directory
    SetCurrentDirectory(szCurDir);

    if (bOK)
    {
        DoSetFileModified(FALSE);
        m_nStatusStringID = IDS_FILESAVED;
    }

    return bOK;
}

// save the resource data as a *.res file
BOOL MMainWnd::DoSaveResAs(LPCWSTR pszResFile)
{
    // compile if necessary
    if (!CompileIfNecessary(TRUE))
        return FALSE;

    if (g_res.extract_res(pszResFile, g_res))
    {
        UpdateFileInfo(FT_RES, pszResFile, FALSE);
        DoSetFileModified(FALSE);
        return TRUE;
    }
    return FALSE;
}

BOOL MMainWnd::DoSaveFile(HWND hwnd, LPCWSTR pszFile)
{
    LPWSTR pchDotExt = PathFindExtensionW(pszFile);
    if (lstrcmpiW(pchDotExt, L".exe") == 0)
        return DoSaveExeAs(pszFile);
    if (lstrcmpiW(pchDotExt, L".rc") == 0)
        return DoExport(pszFile, NULL);
    if (lstrcmpiW(pchDotExt, L".res") == 0)
        return DoSaveResAs(pszFile);
    if (*pchDotExt == 0)
    {
        WCHAR szPath[MAX_PATH];
        StringCbCopyW(szPath, sizeof(szPath), pszFile);
        PathAddExtensionW(szPath, L".rc");
        return DoExport(szPath, NULL);
    }
    return FALSE;
}

// save the file
BOOL MMainWnd::DoSaveAs(LPCWSTR pszExeFile)
{
    // compile if necessary
    if (!CompileIfNecessary(TRUE))
        return TRUE;

    return DoSaveExeAs(pszExeFile);
}

BOOL MMainWnd::DoSaveAsCompression(LPCWSTR pszExeFile)
{
    // compile if necessary
    if (!CompileIfNecessary(TRUE))
        return TRUE;

    return DoSaveExeAs(pszExeFile, TRUE);
}

BOOL IsExeOrDll(LPCWSTR pszFileName)
{
    BYTE ab[2] = { 0, 0 };
    if (FILE *fp = _wfopen(pszFileName, L"rb"))
    {
        fread(ab, 2, 1, fp);
        fclose(fp);
    }

    if (ab[0] == 'M' && ab[1] == 'Z')
        return TRUE;
    if (ab[0] == 'P' && ab[1] == 'E')
        return TRUE;
    return FALSE;
}

BOOL IsDotExe(LPCWSTR pszFileName)
{
    return lstrcmpiW(PathFindExtensionW(pszFileName), L".exe") == 0;
}

BOOL DumpTinyExeOrDll(HINSTANCE hInst, LPCWSTR pszFileName, INT nID)
{
    if (HRSRC hRsrc = FindResourceW(hInst, MAKEINTRESOURCEW(nID), RT_RCDATA))
    {
        if (HGLOBAL hGlobal = LoadResource(hInst, hRsrc))
        {
            if (LPVOID pvData = LockResource(hGlobal))
            {
                DWORD cbData = SizeofResource(hInst, hRsrc);
                if (FILE *fp = _wfopen(pszFileName, L"wb"))
                {
                    size_t nOK = fwrite(pvData, cbData, 1, fp);
                    fflush(fp);
                    fclose(fp);

                    return !!nOK;
                }
            }
        }
    }
    return FALSE;
}

BOOL DoResetCheckSum(LPCWSTR pszExeFile)
{
    MByteStreamEx stream;
    if (!stream.LoadFromFile(pszExeFile))
    {
        assert(0);
        return FALSE;
    }

    if (stream.size() <= sizeof(IMAGE_DOS_SIGNATURE))
    {
        assert(0);
        return FALSE;
    }

    auto dos = stream.pointer<IMAGE_DOS_HEADER>();
    IMAGE_NT_HEADERS *nt;
    if (dos && dos->e_magic == IMAGE_DOS_SIGNATURE && dos->e_lfanew != 0)
        nt = stream.pointer<IMAGE_NT_HEADERS>(dos->e_lfanew);
    else
        nt = stream.pointer<IMAGE_NT_HEADERS>();

    if (!nt || nt->Signature != IMAGE_NT_SIGNATURE)
    {
        assert(0);
        return FALSE;
    }

    IMAGE_NT_HEADERS32 *nt32 = reinterpret_cast<IMAGE_NT_HEADERS32 *>(nt);
    IMAGE_NT_HEADERS64 *nt64 = reinterpret_cast<IMAGE_NT_HEADERS64 *>(nt);

    IMAGE_FILE_HEADER *file = &nt->FileHeader;
    IMAGE_OPTIONAL_HEADER32 *optional32 = NULL;
    IMAGE_OPTIONAL_HEADER64 *optional64 = NULL;

    switch (file->SizeOfOptionalHeader)
    {
    case sizeof(IMAGE_OPTIONAL_HEADER32):
        optional32 = &nt32->OptionalHeader;
        if (optional32->Magic != IMAGE_NT_OPTIONAL_HDR32_MAGIC)
            return FALSE;
        optional32->CheckSum = 0;
        break;

    case sizeof(IMAGE_OPTIONAL_HEADER64):
        optional64 = &nt64->OptionalHeader;
        if (optional64->Magic != IMAGE_NT_OPTIONAL_HDR64_MAGIC)
            return FALSE;
        optional64->CheckSum = 0;
        break;

    default:
        assert(0);
        return FALSE;
    }

    return stream.SaveToFile(pszExeFile);
}

BOOL MMainWnd::DoSaveInner(LPCWSTR pszExeFile, BOOL bCompression)
{
    // src is not exe and dest exe is respected
    DoResetCheckSum(pszExeFile);

    // Now the executable is updated. Wait a little for virus checker.
    Sleep(300);

    if (!g_res.update_exe(pszExeFile))
    {
        return FALSE;
    }

    // Now the executable is updated. Wait a little for virus checker.
    Sleep(300);

    // update file info
    UpdateFileInfo(FT_EXECUTABLE, pszExeFile, m_bUpxCompressed);

    // do compress by UPX
    if (g_settings.bCompressByUPX || bCompression)
    {
        DoUpxCompress(m_szUpxExe, pszExeFile);
    }

    // is there any resource ID?
    if (m_szResourceH[0] || !g_settings.id_map.empty())
    {
        // query
        if (MsgBoxDx(IDS_WANNAGENRESH, MB_ICONINFORMATION | MB_YESNO) == IDYES)
        {
            // write the resource.h file
            return DoWriteResHOfExe(pszExeFile);
        }
    }

    DoSetFileModified(FALSE);

    return TRUE;    // success
}

// open the dialog to save the EXE file
BOOL MMainWnd::DoSaveExeAs(LPCWSTR pszExeFile, BOOL bCompression)
{
    LPCWSTR src = m_szFile;
    LPCWSTR dest = pszExeFile;
    WCHAR szTempFile[MAX_PATH] = L"";
    AutoDeleteFileW ad(szTempFile);

    // check not locking
    if (IsFileLockedDx(dest))
    {
        WCHAR szMsg[MAX_PATH + 256];
        StringCchPrintfW(szMsg, _countof(szMsg), LoadStringDx(IDS_CANTWRITEBYLOCK), dest);
        ErrorBoxDx(szMsg);
        return FALSE;
    }

    // is the file compressed?
    if (m_bUpxCompressed)
    {
        // build a temporary file path
        StringCchCopyW(szTempFile, _countof(szTempFile), GetTempFileNameDx(L"UPX"));

        // src --> szTempFile (decompressed)
        if (!CopyFileW(src, szTempFile, FALSE) ||
            !DoUpxDecompress(m_szUpxExe, szTempFile))
        {
            ErrorBoxDx(IDS_CANTUPXEXTRACT);
            return FALSE;   // failure
        }

        src = szTempFile;

        // Now the executable is updated. Wait a little for virus checker.
        Sleep(300);
    }

    // do backup the dest
    if (g_settings.bBackup)
    {
        DoBackupFile(dest);

        // Now the executable is updated. Wait a little for virus checker.
        Sleep(300);
    }

    // check whether it is an executable or not
    BOOL bSrcExecutable = IsExeOrDll(src);
    BOOL bDestExecutable = IsExeOrDll(dest);

    if (bSrcExecutable)
    {
        // copy src to dest (if src and dest are not same), then update resource
        if (lstrcmpiW(src, dest) == 0 ||
            CopyFileW(src, dest, FALSE))
        {
            // Now the executable is updated. Wait a little for virus checker.
            Sleep(300);

            return DoSaveInner(dest, bCompression);
        }
    }
    else if (bDestExecutable)
    {
        return DoSaveInner(dest, bCompression);
    }
    else
    {
        // if src and dest are non-executable, then dump tiny exe or dll to dest
        if (IsDotExe(dest))
        {
            if (DumpTinyExeOrDll(m_hInst, dest, IDR_TINYEXE))
            {
                // Now the executable is updated. Wait a little for virus checker.
                Sleep(300);

                return DoSaveInner(dest, bCompression);
            }
        }
        else
        {
            if (DumpTinyExeOrDll(m_hInst, dest, IDR_TINYDLL))
            {
                // Now the executable is updated. Wait a little for virus checker.
                Sleep(300);

                return DoSaveInner(dest, bCompression);
            }
        }
    }

    return FALSE;   // failure
}

// do compress the file by UPX.exe
BOOL MMainWnd::DoUpxCompress(LPCWSTR pszUpx, LPCWSTR pszExeFile)
{
    // build the command line
    MStringW strCmdLine;
    strCmdLine += L"\"";
    strCmdLine += pszUpx;
    strCmdLine += L"\" -9 \"";
    strCmdLine += pszExeFile;
    strCmdLine += L"\"";
    //MessageBoxW(hwnd, strCmdLine.c_str(), NULL, 0);

    BOOL bOK = FALSE;

    // create a UPX process
    MProcessMaker pmaker;
    pmaker.SetShowWindow(SW_HIDE);
    pmaker.SetCreationFlags(CREATE_NEW_CONSOLE);

    MFile hInputWrite, hOutputRead;
    if (pmaker.PrepareForRedirect(&hInputWrite, &hOutputRead) &&
        pmaker.CreateProcessDx(NULL, strCmdLine.c_str()))
    {
        // read all output
        MStringA strOutput;
        bOK = pmaker.ReadAll(strOutput, hOutputRead, PROCESS_TIMEOUT);
        pmaker.WaitForSingleObject(PROCESS_TIMEOUT);

        if (pmaker.GetExitCode() == 0 && bOK)
        {
            bOK = (strOutput.find("Packed") != MStringA::npos);
        }
    }

    return bOK;
}

IMPORT_RESULT MMainWnd::DoImportRC(HWND hwnd, LPCWSTR pszFile)
{
    MWaitCursor wait;

    // load the RC file to the res variable
    EntrySet res;
    if (!DoLoadRC(hwnd, pszFile, res))
    {
        ErrorBoxDx(IDS_CANNOTIMPORT);
        return IMPORT_FAILED;
    }

    bool found = false;
    for (auto entry : res)
    {
        if (entry->m_et != ET_LANG)
            continue;   // we will merge the ET_LANG entries only

        if (g_res.find(ET_LANG, entry->m_type, entry->m_name, entry->m_lang))
        {
            found = true;
            break;
        }
    }

    if (found)
    {
        if (MsgBoxDx(IDS_EXISTSOVERWRITE, MB_ICONINFORMATION | MB_YESNOCANCEL) != IDYES)
            return IMPORT_CANCELLED;
    }

    // load it now
    m_bLoading = TRUE;
    {
        ShowLangArrow(FALSE);

        // merge
        g_res.merge(res);

        // clean up
        res.delete_all();
    }
    m_bLoading = FALSE;

    // select none
    SelectTV(NULL, FALSE);

    // update language arrow
    PostUpdateLangArrow(hwnd);

    DoSetFileModified(TRUE);
    return IMPORTED;
}

IMPORT_RESULT MMainWnd::DoImportRes(HWND hwnd, LPCWSTR pszFile)
{
    // do import to the res variable
    EntrySet res;
    if (!res.import_res(pszFile))
    {
        return IMPORT_FAILED;
    }

    // is it overlapped?
    if (g_res.intersect(res))
    {
        // query overwrite
        INT nID = MsgBoxDx(IDS_EXISTSOVERWRITE, MB_ICONINFORMATION | MB_YESNOCANCEL);
        switch (nID)
        {
        case IDYES:
            // delete the overlapped entries
            for (auto entry : res)
            {
                if (entry->m_et != ET_LANG)
                    continue;

                g_res.search_and_delete(ET_LANG, entry->m_type, entry->m_name, entry->m_lang);
            }
            break;

        case IDNO:
        case IDCANCEL:
            // clean up
            res.delete_all();
            return IMPORT_CANCELLED;
        }
    }

    // load it now
    m_bLoading = TRUE;
    {
        ShowLangArrow(FALSE);

        // renewal
        g_res.merge(res);

        // clean up
        res.delete_all();
    }
    m_bLoading = FALSE;

    // refresh the ID list window
    DoRefreshIDList(hwnd);

    // update language arrow
    PostUpdateLangArrow(hwnd);

    return IMPORTED;
}

IMPORT_RESULT MMainWnd::DoImport(HWND hwnd, LPCWSTR pszFile, LPCWSTR pchDotExt)
{
    if (!pchDotExt)
        return NOT_IMPORTABLE;

    if (lstrcmpiW(pchDotExt, L".rc") == 0)
    {
        return DoImportRC(hwnd, pszFile);
    }
    else if (lstrcmpiW(pchDotExt, L".res") == 0)
    {
        return DoImportRes(hwnd, pszFile);
    }
    else if (lstrcmpiW(pchDotExt, L".ico") == 0)
    {
        // show the dialog
        MAddIconDlg dialog;
        dialog.m_file = pszFile;
        if (dialog.DialogBoxDx(hwnd) == IDOK)
        {
            // refresh the ID list window
            DoRefreshIDList(hwnd);

            // select the entry
            SelectTV(ET_LANG, dialog, FALSE);

            DoSetFileModified(TRUE);

            return IMPORTED;
        }
        return IMPORT_CANCELLED;
    }
    else if (lstrcmpiW(pchDotExt, L".cur") == 0 || lstrcmpiW(pchDotExt, L".ani") == 0)
    {
        // show the dialog
        MAddCursorDlg dialog;
        dialog.m_file = pszFile;
        if (dialog.DialogBoxDx(hwnd) == IDOK)
        {
            // refresh the ID list window
            DoRefreshIDList(hwnd);

            // select the entry
            SelectTV(ET_LANG, dialog, FALSE);

            DoSetFileModified(TRUE);

            return IMPORTED;
        }
        return IMPORT_CANCELLED;
    }
    else if (lstrcmpiW(pchDotExt, L".html") == 0 || lstrcmpiW(pchDotExt, L".htm") == 0)
    {
        // show the dialog
        MAddResDlg dialog;
        dialog.m_type = RT_HTML;
        dialog.m_file = pszFile;
        if (dialog.DialogBoxDx(hwnd) == IDOK)
        {
            // add a resource item
            DoAddRes(hwnd, dialog);

            DoSetFileModified(TRUE);

            return IMPORTED;
        }
        return IMPORT_CANCELLED;
    }
    else if (lstrcmpiW(pchDotExt, L".manifest") == 0)
    {
        // show the dialog
        MAddResDlg dialog;
        dialog.m_type = RT_MANIFEST;
        dialog.m_file = pszFile;
        if (dialog.DialogBoxDx(hwnd) == IDOK)
        {
            // add a resource item
            DoAddRes(hwnd, dialog);

            DoSetFileModified(TRUE);

            return IMPORTED;
        }
        return IMPORT_CANCELLED;
    }
    else if (lstrcmpiW(pchDotExt, L".wav") == 0)
    {
        // show the dialog
        MAddResDlg dialog;
        dialog.m_type = L"WAVE";
        dialog.m_file = pszFile;
        if (dialog.DialogBoxDx(hwnd) == IDOK)
        {
            // add a resource item
            DoAddRes(hwnd, dialog);

            DoSetFileModified(TRUE);

            return IMPORTED;
        }
        return IMPORT_CANCELLED;
    }
    else if (lstrcmpiW(pchDotExt, L".bmp") == 0 || lstrcmpiW(pchDotExt, L".dib") == 0)
    {
        // show the dialog
        MAddBitmapDlg dialog;
        dialog.m_file = pszFile;
        if (dialog.DialogBoxDx(hwnd) == IDOK)
        {
            // refresh the ID list window
            DoRefreshIDList(hwnd);

            // select the entry
            SelectTV(ET_LANG, dialog, FALSE);

            DoSetFileModified(TRUE);

            return IMPORTED;
        }
        return IMPORT_CANCELLED;
    }
    else if (lstrcmpiW(pchDotExt, L".png") == 0)
    {
        // show the dialog
        MAddResDlg dialog;
        dialog.m_file = pszFile;
        dialog.m_type = L"PNG";
        if (dialog.DialogBoxDx(hwnd) == IDOK)
        {
            // add a resource item
            DoAddRes(hwnd, dialog);

            DoSetFileModified(TRUE);

            return IMPORTED;
        }
        return IMPORT_CANCELLED;
    }
    else if (lstrcmpiW(pchDotExt, L".gif") == 0)
    {
        // show the dialog
        MAddResDlg dialog;
        dialog.m_file = pszFile;
        dialog.m_type = L"GIF";
        if (dialog.DialogBoxDx(hwnd) == IDOK)
        {
            // add a resource item
            DoAddRes(hwnd, dialog);

            DoSetFileModified(TRUE);

            return IMPORTED;
        }
        return IMPORT_CANCELLED;
    }
    else if (lstrcmpiW(pchDotExt, L".jpg") == 0 || lstrcmpiW(pchDotExt, L".jpeg") == 0 ||
             lstrcmpiW(pchDotExt, L".jpe") == 0 || lstrcmpiW(pchDotExt, L".jfif") == 0)
    {
        // show the dialog
        MAddResDlg dialog;
        dialog.m_file = pszFile;
        dialog.m_type = L"JPEG";
        if (dialog.DialogBoxDx(hwnd) == IDOK)
        {
            // add a resource item
            DoAddRes(hwnd, dialog);

            DoSetFileModified(TRUE);

            return IMPORTED;
        }
        return IMPORT_CANCELLED;
    }
    else if (lstrcmpiW(pchDotExt, L".tif") == 0 || lstrcmpiW(pchDotExt, L".tiff") == 0)
    {
        // show the dialog
        MAddResDlg dialog;
        dialog.m_file = pszFile;
        dialog.m_type = L"TIFF";
        if (dialog.DialogBoxDx(hwnd) == IDOK)
        {
            // add a resource item
            DoAddRes(hwnd, dialog);

            DoSetFileModified(TRUE);

            return IMPORTED;
        }
        return IMPORT_CANCELLED;
    }
    else if (lstrcmpiW(pchDotExt, L".avi") == 0)
    {
        // show the dialog
        MAddResDlg dialog;
        dialog.m_file = pszFile;
        dialog.m_type = L"AVI";
        if (dialog.DialogBoxDx(hwnd) == IDOK)
        {
            // add a resource item
            DoAddRes(hwnd, dialog);

            DoSetFileModified(TRUE);

            return IMPORTED;
        }
        return IMPORT_CANCELLED;
    }
    else if (lstrcmpiW(pchDotExt, L".wmf") == 0)
    {
        // show the dialog
        MAddResDlg dialog;
        dialog.m_file = pszFile;
        dialog.m_type = L"WMF";
        if (dialog.DialogBoxDx(hwnd) == IDOK)
        {
            // add a resource item
            DoAddRes(hwnd, dialog);

            DoSetFileModified(TRUE);

            return IMPORTED;
        }
        return IMPORT_CANCELLED;
    }
    else if (lstrcmpiW(pchDotExt, L".emf") == 0)
    {
        // show the dialog
        MAddResDlg dialog;
        dialog.m_file = pszFile;
        dialog.m_type = L"EMF";
        if (dialog.DialogBoxDx(hwnd) == IDOK)
        {
            // add a resource item
            DoAddRes(hwnd, dialog);

            DoSetFileModified(TRUE);

            return IMPORTED;
        }
        return IMPORT_CANCELLED;
    }
    else if (lstrcmpiW(pchDotExt, L".dfm") == 0)
    {
        // show the dialog
        MAddResDlg dialog;
        dialog.m_file = pszFile;
        dialog.m_type = RT_RCDATA;
        if (dialog.DialogBoxDx(hwnd) == IDOK)
        {
            // add a resource item
            DoAddRes(hwnd, dialog);

            DoSetFileModified(TRUE);

            return IMPORTED;
        }
        return IMPORT_CANCELLED;
    }
    else if (lstrcmpiW(pchDotExt, L".tlb") == 0)
    {
        // show the dialog
        MAddResDlg dialog;
        dialog.m_file = pszFile;
        dialog.m_type = L"TYPELIB";
        if (dialog.DialogBoxDx(hwnd) == IDOK)
        {
            // add a resource item
            DoAddRes(hwnd, dialog);

            DoSetFileModified(TRUE);

            return IMPORTED;
        }
        return IMPORT_CANCELLED;
    }

    return NOT_IMPORTABLE;
}

// WM_DROPFILES: file(s) has been dropped
void MMainWnd::OnDropFiles(HWND hwnd, HDROP hdrop)
{
    MWaitCursor wait;
    ChangeStatusText(IDS_EXECUTINGCMD);     // executing command

    // compile if necessary
    if (!CompileIfNecessary(FALSE))
    {
        ChangeStatusText(IDS_READY);
        return;
    }

    // add the command lock
    ++m_nCommandLock;

    WCHAR file[MAX_PATH], *pch;

    // get the dropped file path
    DragQueryFileW(hdrop, 0, file, _countof(file));

    // free hdrop
    DragFinish(hdrop);

    // make the window foreground
    SetForegroundWindow(hwnd);

    // find the dot extension
    pch = PathFindExtensionW(file);

    IMPORT_RESULT result = NOT_IMPORTABLE;
    if (pch && lstrcmpiW(pch, L".rc") != 0)
    {
        result = DoImport(hwnd, file, pch);
    }

    if (result == IMPORTED || result == IMPORT_CANCELLED)
    {
        // do nothing
    }
    else if (result == IMPORT_FAILED)
    {
        ErrorBoxDx(IDS_CANNOTIMPORT);
    }
    else if (pch && lstrcmpiW(pch, L".h") == 0)
    {
        // unload the resource.h file
        UnloadResourceH(hwnd);

        CheckResourceH(hwnd, file);
        if (m_szResourceH[0] && g_settings.bAutoShowIDList)
        {
            ShowIDList(hwnd, TRUE);
        }

        // update the names
        UpdateNames();
    }
    else
    {
        if (!DoQuerySaveChange(hwnd))
            return;

        // otherwise, load the file
        DoLoadFile(hwnd, file);
    }

    // update language arrow
    PostUpdateLangArrow(hwnd);

    // remove the command lock
    --m_nCommandLock;

    // show "ready" if just unlocked
    if (m_nCommandLock == 0 && !::IsWindow(m_rad_window))
        ChangeStatusText(IDS_READY);
}

// open the dialog to load the resource.h
void MMainWnd::OnLoadResH(HWND hwnd)
{
    // compile if necessary
    if (!CompileIfNecessary(FALSE))
    {
        return;
    }

    // (resource.h file path) --> szFile
    WCHAR szFile[MAX_PATH];
    if (m_szResourceH[0])
        StringCchCopyW(szFile, _countof(szFile), m_szResourceH);
    else
        StringCchCopyW(szFile, _countof(szFile), L"resource.h");

    // if it does not exist, clear the file path
    if (!PathFileExistsW(szFile))
        szFile[0] = 0;

    // initialize OPENFILENAME structure
    OPENFILENAMEW ofn = { OPENFILENAME_SIZE_VERSION_400W, hwnd };
    ofn.lpstrFilter = MakeFilterDx(LoadStringDx(IDS_HEADFILTER));
    ofn.lpstrFile = szFile;
    ofn.nMaxFile = _countof(szFile);
    ofn.lpstrTitle = LoadStringDx(IDS_LOADRESH);
    ofn.Flags = OFN_ENABLESIZING | OFN_EXPLORER | OFN_FILEMUSTEXIST |
                OFN_HIDEREADONLY | OFN_PATHMUSTEXIST;
    ofn.lpstrDefExt = L"h";     // the default extension

    // let the user choose the path
    if (GetOpenFileNameW(&ofn))
    {
        // load the resource.h file
        DoLoadResH(hwnd, szFile);

        // is the resource.h file loaded?
        if (m_szResourceH[0])
        {
            // show the ID list window
            ShowIDList(hwnd, TRUE);
        }

        // update the names
        UpdateNames();
    }
}

// load the resource.h file
void MMainWnd::OnLoadResHBang(HWND hwnd)
{
    if (m_szResourceH[0])
    {
        MString strFile = m_szResourceH;
        DoLoadResH(hwnd, strFile.c_str());

        if (m_szResourceH[0])
        {
            ShowIDList(hwnd, TRUE);
        }
    }
}

void MMainWnd::OnClose(HWND hwnd)
{
    // compile if necessary
    if (!CompileIfNecessary(FALSE))
        return;

    if (DoQuerySaveChange(hwnd))
        DestroyWindow(hwnd);
}

// WM_DESTROY: the main window has been destroyed
void MMainWnd::OnDestroy(HWND hwnd)
{
    // close preview
    HidePreview();

    // unload the resource.h file
    OnUnloadResH(hwnd);

    // update the file info
    UpdateFileInfo(FT_NONE, NULL, FALSE);

    // unselect
    SelectTV(NULL, FALSE);

    // clean up
    g_res.delete_all();

    // save the settings
    SaveSettings(hwnd);

    //DestroyIcon(m_hIcon);     // LR_SHARED
    DestroyIcon(m_hIconSm);
    DestroyAcceleratorTable(m_hAccel);
    ImageList_Destroy(m_hImageList);
    ImageList_Destroy(m_himlTools);
    DestroyIcon(m_hFileIcon);
    DestroyIcon(m_hFolderIcon);
    DeleteObject(m_hSrcFont);
    DeleteObject(m_hBinFont);

    //DestroyIcon(MRadCtrl::Icon());    // LR_SHARED
    DeleteObject(MRadCtrl::Bitmap());
    DestroyCursor(MSplitterWnd::CursorNS());
    DestroyCursor(MSplitterWnd::CursorWE());

    // clean up
    g_res.delete_all();
    g_res.delete_invalid();

    // destroy the window's
    m_rad_window.DestroyWindow();
    DestroyWindow(m_hHexViewer);
    DestroyWindow(m_hCodeEditor);
    m_hBmpView.DestroyView();
    DestroyWindow(m_hBmpView);
    DestroyWindow(m_id_list_dlg);

    DestroyWindow(s_hwndEga);
    s_hwndEga = NULL;

    DestroyWindow(m_hwndTV);
    DestroyWindow(m_hToolBar);
    DestroyWindow(m_hStatusBar);
    DestroyWindow(m_hFindReplaceDlg);

    DestroyWindow(m_splitter1);
    DestroyWindow(m_splitter2);

    s_hMainWnd = NULL;

    // post WM_QUIT message to quit the application
    PostQuitMessage(0);
}

// parse the macros
BOOL MMainWnd::ParseMacros(HWND hwnd, LPCTSTR pszFile,
                           const std::vector<MStringA>& macros, MStringA& str)
{
    // split text to lines by "\n"
    std::vector<MStringA> lines;
    mstr_trim(str);
    mstr_split(lines, str, "\n");

    // erase the first line (the special pragma)
    lines.erase(lines.begin());

    // check the line count
    size_t line_count = lines.size();
    if (macros.size() < line_count)
        line_count = macros.size();

    for (size_t i = 0; i < line_count; ++i)
    {
        auto& macro = macros[i];
        auto& line = lines[i];

        // scan the line lexically
        using namespace MacroParser;
        StringScanner scanner(line);

        // tokenize it
        MacroParser::TokenStream stream(scanner);
        stream.read_tokens();

        // and parse it
        Parser parser(stream);
        if (parser.parse())     // successful
        {
            if (is_str(parser.ast()))
            {
                // it's a string value macro
                string_type value;
                if (eval_string(parser.ast(), value))   // evaluate
                {
                    // add an ID mapping's pair
                    g_settings.id_map[macro] = std::move(value);
                }
            }
            else
            {
                // it's an integer value macro
                int value = 0;
                if (eval_int(parser.ast(), value))  // evaluate
                {
                    // convert to a string by base m_id_list_dlg.m_nBase
                    char sz[32];
                    if (m_id_list_dlg.m_nBase == 16)
                        StringCchPrintfA(sz, _countof(sz), "0x%X", value);
                    else
                        StringCchPrintfA(sz, _countof(sz), "%d", value);

                    // ignore some special macros
                    if (macro != "WIN32" && macro != "WINNT" && macro != "i386")
                    {
                        // add an ID mapping's pair
                        g_settings.id_map[macro] = sz;
                    }
                }
            }
        }
    }

    // clear the resource IDs in the constants database
    auto& table = g_db.m_map[L"RESOURCE.ID"];
    table.clear();

    // add the resource ID entries to the "RESOURCE.ID" table from the ID mapping
    for (auto& pair : g_settings.id_map)
    {
        MStringW str1 = MAnsiToWide(CP_ACP, pair.first).c_str();
        MStringW str2 = MAnsiToWide(CP_ACP, pair.second).c_str();
        DWORD value2 = mstr_parse_int(str2.c_str());
        ConstantsDB::EntryType entry(str1, value2);
        table.push_back(entry);
    }

    // add IDC_STATIC macro
    g_settings.AddIDC_STATIC();

    // save the resource.h file location to m_szResourceH
    StringCchCopyW(m_szResourceH, _countof(m_szResourceH), pszFile);

    return TRUE;
}

// parse the resource.h file
BOOL MMainWnd::ParseResH(HWND hwnd, LPCTSTR pszFile, const char *psz, DWORD len)
{
    // split text to lines by "\n"
    MStringA str(psz, len);
    std::vector<MStringA> lines, macros;
    mstr_split(lines, str, "\n");

    const size_t lenDefine = strlen("#define");
    for (auto& line : lines)
    {
        // trim
        mstr_trim(line);
        if (line.empty())
            continue;   // empty ones are ignored

        // the macro that begins with "_" will be ignored
        if (line.find("#define _") != MStringA::npos)
            continue;

        // find "#define "
        size_t found0 = line.find("#define");
        if (found0 == MStringA::npos)
            continue;

        // parse the line
        line = line.substr(lenDefine);
        mstr_trim(line);
        size_t found1 = line.find_first_of(" \t");
        size_t found2 = line.find('(');
        if (found1 == MStringA::npos)
            continue;   // without space is an invalid #define
        if (found2 != MStringA::npos && found2 < found1)
            continue;   // we ignore the function-like macros

        // push the macro
        macros.push_back(line.substr(0, found1));
    }

    g_settings.id_map.clear();

    if (macros.empty())
    {
        // no macros to 
        return TRUE;
    }

    // (new temporary file path) --> szTempFile1
    WCHAR szTempFile1[MAX_PATH];
    StringCchCopyW(szTempFile1, _countof(szTempFile1), GetTempFileNameDx(L"R1"));

    AutoDeleteFileW adf1(szTempFile1);

    // create the temporary file
    MFile file1(szTempFile1, TRUE);

    // pszFile --> szFile
    WCHAR szFile[MAX_PATH];
    StringCchCopyW(szFile, _countof(szFile), pszFile);

    // write the heading
    DWORD cbWritten;
    file1.WriteSzA("#include \"", &cbWritten);
    file1.WriteSzA(MTextToAnsi(CP_ACP, szFile).c_str(), &cbWritten);
    file1.WriteSzA("\"\n", &cbWritten);
    file1.WriteSzA("#pragma macros\n", &cbWritten);    // the special pragma

    // write the macro names (in order to retrieve the value after)
    char buf[MAX_PATH + 64];
    for (size_t i = 0; i < macros.size(); ++i)
    {
        StringCchPrintfA(buf, _countof(buf), "%s\n", macros[i].c_str());
        file1.WriteSzA(buf, &cbWritten);
    }
    file1.FlushFileBuffers();
    file1.CloseHandle();    // close the handle

    // build the command line text
    MString strCmdLine;
    strCmdLine += L'\"';
    strCmdLine += m_szMCppExe;       // mcpp.exe
    strCmdLine += L"\" ";
    strCmdLine += GetIncludesDump();
    strCmdLine += GetMacroDump();
    strCmdLine += L" \"";
    strCmdLine += szTempFile1;
    strCmdLine += L'\"';
    //MessageBoxW(hwnd, strCmdLine.c_str(), NULL, 0);

    BOOL bOK = FALSE;

    // create a cpp.exe process
    MProcessMaker pmaker;
    pmaker.SetShowWindow(SW_HIDE);
    pmaker.SetCreationFlags(CREATE_NEW_CONSOLE);

    MStringA strOutput;
    MFile hInputWrite, hOutputRead;
    if (pmaker.PrepareForRedirect(&hInputWrite, &hOutputRead) &&
        pmaker.CreateProcessDx(NULL, strCmdLine.c_str()))
    {
        // read all with timeout
        bOK = pmaker.ReadAll(strOutput, hOutputRead, PROCESS_TIMEOUT);
        pmaker.WaitForSingleObject(PROCESS_TIMEOUT);

        if (bOK)
        {
            bOK = FALSE;

            // find the special pragma
            size_t pragma_found = strOutput.find("#pragma macros");
            if (pragma_found != MStringA::npos)
            {
                // get text after the special pragma
                strOutput = strOutput.substr(pragma_found);

                // parse macros
                bOK = ParseMacros(hwnd, pszFile, macros, strOutput);
            }
        }
    }

    return bOK;
}

// load the resource.h
BOOL MMainWnd::DoLoadResH(HWND hwnd, LPCTSTR pszFile)
{
    // unload the resource.h file
    UnloadResourceH(hwnd);

    // (new temporary file path) --> szTempFile
    WCHAR szTempFile[MAX_PATH];
    StringCchCopyW(szTempFile, _countof(szTempFile), GetTempFileNameDx(L"R1"));

    // create a temporary file
    MFile file(szTempFile, TRUE);
    file.CloseHandle();     // close the handle

    AutoDeleteFileW adf1(szTempFile);

    // build a command line
    MString strCmdLine;
    strCmdLine += L'"';
    strCmdLine += m_szMCppExe;
    strCmdLine += L"\" -dM -DRC_INVOKED -o \"";
    strCmdLine += szTempFile;
    strCmdLine += L"\" \"-I";
    strCmdLine += m_szIncludeDir;
    strCmdLine += L"\" \"";
    strCmdLine += pszFile;
    strCmdLine += L"\"";
    //MessageBoxW(hwnd, strCmdLine.c_str(), NULL, 0);

    BOOL bOK = FALSE;

    // create a cpp.exe process
    MProcessMaker pmaker;
    pmaker.SetShowWindow(SW_HIDE);
    pmaker.SetCreationFlags(CREATE_NEW_CONSOLE);

    MStringA strOutput;
    MFile hInputWrite, hOutputRead;
    if (pmaker.PrepareForRedirect(&hInputWrite, &hOutputRead) &&
        pmaker.CreateProcessDx(NULL, strCmdLine.c_str()))
    {
        // read all with timeout
        bOK = pmaker.ReadAll(strOutput, hOutputRead, PROCESS_TIMEOUT);
        pmaker.WaitForSingleObject(PROCESS_TIMEOUT);

        if (bOK && pmaker.GetExitCode() == 0)
        {
            // read all from szTempFile
            MStringA data;
            MFile file(szTempFile);
            bOK = file.ReadAll(data);
            file.CloseHandle();

            if (bOK)
            {
                // parse the resource.h
                bOK = ParseResH(hwnd, pszFile, &data[0], DWORD(data.size()));
            }
        }
    }

    return bOK;
}

// refresh the ID list window
void MMainWnd::DoRefreshIDList(HWND hwnd)
{
    ShowIDList(hwnd, IsWindow(m_id_list_dlg));
}

// refresh the treeview
void MMainWnd::DoRefreshTV(HWND hwnd)
{
    // refresh the resource items
    EntrySet res;
    res.merge(g_res);
    g_res.delete_all();
    g_res.merge(res);

    // clean up
    res.delete_all();

    // redraw
    InvalidateRect(m_hwndTV, NULL, TRUE);
}

// advice the change for resource.h file
void MMainWnd::OnAdviceResH(HWND hwnd)
{
    // compile if necessary
    if (!CompileIfNecessary(TRUE))
        return;

    MString str;

    if (!g_settings.removed_ids.empty() &&
        (g_settings.removed_ids.size() != 1 ||
         g_settings.removed_ids.find("IDC_STATIC") == g_settings.removed_ids.end()))
    {
        str += LoadStringDx(IDS_DELETENEXTIDS);

        for (auto& pair : g_settings.removed_ids)
        {
            if (pair.first == "IDC_STATIC")
                continue;

            str += TEXT("#define ");
            str += MAnsiToText(CP_ACP, pair.first).c_str();
            str += TEXT(" ");
            str += MAnsiToText(CP_ACP, pair.second).c_str();
            str += TEXT("\r\n");
        }
        str += TEXT("\r\n");
    }

    if (!g_settings.added_ids.empty() &&
        (g_settings.added_ids.size() != 1 ||
         g_settings.added_ids.find("IDC_STATIC") == g_settings.added_ids.end() ||
         !g_settings.bUseIDC_STATIC))
    {
        str += LoadStringDx(IDS_ADDNEXTIDS);

        for (auto& pair : g_settings.added_ids)
        {
            str += TEXT("#define ");
            str += MAnsiToText(CP_ACP, pair.first).c_str();
            str += TEXT(" ");
            str += MAnsiToText(CP_ACP, pair.second).c_str();
            str += TEXT("\r\n");
        }
        str += TEXT("\r\n");
    }

    if (str.empty())
    {
        str += LoadStringDx(IDS_NOCHANGE);
        str += TEXT("\r\n");
    }

    // show the dialog
    MAdviceResHDlg dialog(str);
    dialog.DialogBoxDx(hwnd);
}

// unload the resource.h info
void MMainWnd::OnUnloadResH(HWND hwnd)
{
    // compile if necessary
    if (!CompileIfNecessary(TRUE))
        return;

    // unload the resource.h file
    UnloadResourceH(hwnd);
}

// the configuration dialog
void MMainWnd::OnConfig(HWND hwnd)
{
    // compile if necessary
    if (!CompileIfNecessary(FALSE))
        return;

    // show the dialog
    MConfigDlg dialog;
    if (dialog.DialogBoxDx(hwnd) == IDOK)
    {
        // refresh PATHs
        ReSetPaths(hwnd);

        // update word wrapping
        ReCreateSrcEdit(hwnd);

        // update the fonts
        ReCreateFonts(hwnd);

        // update the labels of the entries
        UpdateNames(FALSE);

        // select the entry to update the text
        auto entry = g_res.get_entry();
        SelectTV(entry, FALSE);

        // update title bar
        UpdateTitleBar();
    }

    // update menu
    UpdateMenu();
}

// reset the path settings
void MMainWnd::ReSetPaths(HWND hwnd)
{
    // windres.exe
    if (g_settings.strWindResExe.size())
    {
        // g_settings.strWindResExe --> m_szWindresExe
        StringCchCopyW(m_szWindresExe, _countof(m_szWindresExe), g_settings.strWindResExe.c_str());
    }
    else
    {
        // g_settings.m_szDataFolder + L"\\bin\\windres.exe" --> m_szWindresExe
        StringCchCopyW(m_szWindresExe, _countof(m_szWindresExe), m_szDataFolder);
        StringCchCatW(m_szWindresExe, _countof(m_szWindresExe), L"\\bin\\windres.exe");
    }

    // cpp.exe
    if (g_settings.strCppExe.size())
    {
        // g_settings.strCppExe --> m_szMCppExe
        StringCchCopy(m_szMCppExe, _countof(m_szMCppExe), g_settings.strCppExe.c_str());
    }
    else
    {
        // m_szDataFolder + "\\bin\\cpp.exe" --> m_szMCppExe
        StringCchCopyW(m_szMCppExe, _countof(m_szMCppExe), m_szDataFolder);
        StringCchCatW(m_szMCppExe, _countof(m_szMCppExe), L"\\bin\\mcpp.exe");
    }
}

// use IDC_STATIC macro or not
void MMainWnd::OnUseIDC_STATIC(HWND hwnd)
{
    // toggle the flag
    g_settings.bUseIDC_STATIC = !g_settings.bUseIDC_STATIC;

    // select the entry to update the text
    auto entry = g_res.get_entry();
    SelectTV(entry, FALSE, STV_RESETTEXT);
}

// update the name of the tree control
void MMainWnd::UpdateNames(BOOL bModified)
{
    EntrySet found;
    g_res.search(found, ET_NAME);

    for (auto entry : found)
    {
        UpdateEntryName(entry);
    }

    auto entry = g_res.get_entry();
    SelectTV(entry, FALSE);

    if (bModified)
        DoSetFileModified(TRUE);
}

void MMainWnd::UpdateEntryName(EntryBase *e, LPWSTR pszText)
{
    // update name label
    e->m_strLabel = e->get_name_label();

    // set the label text
    TV_ITEM item;
    ZeroMemory(&item, sizeof(item));
    item.mask = TVIF_TEXT | TVIF_HANDLE;
    item.hItem = e->m_hItem;
    item.pszText = &e->m_strLabel[0];
    TreeView_SetItem(m_hwndTV, &item);

    // update pszText if any
    if (pszText)
        StringCchCopyW(pszText, MAX_PATH, item.pszText);
}

void MMainWnd::UpdateEntryLang(EntryBase *e, LPWSTR pszText)
{
    // update lang label
    e->m_strLabel = e->get_lang_label();

    // set the label text
    TV_ITEM item;
    ZeroMemory(&item, sizeof(item));
    item.mask = TVIF_TEXT | TVIF_HANDLE;
    item.hItem = e->m_hItem;
    item.pszText = &e->m_strLabel[0];
    TreeView_SetItem(m_hwndTV, &item);

    // update pszText if any
    if (pszText)
        StringCchCopyW(pszText, MAX_PATH, item.pszText);

    DoSetFileModified(TRUE);
}

// show/hide the ID macros
void MMainWnd::OnHideIDMacros(HWND hwnd)
{
    BOOL bListOpen = IsWindow(m_id_list_dlg);

    // toggle the flag
    g_settings.bHideID = !g_settings.bHideID;

    UpdateNames(FALSE);

    ShowIDList(hwnd, bListOpen);

    // select the entry to update the text
    auto entry = g_res.get_entry();
    SelectTV(entry, FALSE);
}

void MMainWnd::OnDfmSettings(HWND hwnd)
{
    // compile if necessary
    if (!CompileIfNecessary(TRUE))
        return;

    MDfmSettingsDlg dialog;
    if (dialog.DialogBoxDx(hwnd) == IDOK)
    {
        g_settings.nDfmCodePage = dialog.m_nCodePage;
        g_settings.bDfmRawTextComments = dialog.m_bComments;
        g_settings.bDfmNoUnicode = dialog.m_bNoUnicode;

        // select the entry to update the text
        auto entry = g_res.get_entry();
        SelectTV(entry, FALSE);
    }
}

// show/hide the ID list window
void MMainWnd::ShowIDList(HWND hwnd, BOOL bShow/* = TRUE*/)
{
    if (bShow)
    {
        if (IsWindow(m_id_list_dlg))
            DestroyWindow(m_id_list_dlg);
        m_id_list_dlg.CreateDialogDx(hwnd);
        ShowWindow(m_id_list_dlg, (g_bNoGuiMode ? SW_HIDE : SW_SHOWNOACTIVATE));
        UpdateWindow(m_id_list_dlg);
    }
    else
    {
        ShowWindow(m_id_list_dlg, SW_HIDE);
        DestroyWindow(m_id_list_dlg);
    }
}

// show the ID list window
void MMainWnd::OnIDList(HWND hwnd)
{
    ShowIDList(hwnd, TRUE);
}

// show the ID association dialog
void MMainWnd::OnIdAssoc(HWND hwnd)
{
    // compile if necessary
    if (!CompileIfNecessary(::IsWindowVisible(m_rad_window)))
        return;

    // show the dialog
    MIdAssocDlg dialog;
    dialog.DialogBoxDx(hwnd);

    // update the prefix database
    UpdatePrefixDB(hwnd);
}

// show the language list
void MMainWnd::OnShowLangs(HWND hwnd)
{
    // compile if necessary
    if (!CompileIfNecessary(FALSE))
        return;

    // show the dialog
    MLangsDlg dialog;
    dialog.DialogBoxDx(hwnd);
}

// show/hide the toolbar
void MMainWnd::OnShowHideToolBar(HWND hwnd)
{
    // toggle the flag
    g_settings.bShowToolBar = !g_settings.bShowToolBar;

    if (g_settings.bShowToolBar)
        ShowWindow(m_hToolBar, SW_SHOWNOACTIVATE);
    else
        ShowWindow(m_hToolBar, SW_HIDE);

    // recalculate the splitter
    PostMessageDx(WM_SIZE);
}

// the paths dialog
void MMainWnd::OnSetPaths(HWND hwnd)
{
    // compile if necessary
    if (!CompileIfNecessary(FALSE))
        return;

    // show the dialog
    MPathsDlg dialog;
    if (dialog.DialogBoxDx(hwnd) == IDOK)
    {
        ReSetPaths(hwnd);
    }
}

// start changing the resource name/language
void MMainWnd::OnEditLabel(HWND hwnd)
{
    // compile if necessary
    if (!CompileIfNecessary(FALSE))
        return;

    // get the selected type entry
    auto entry = g_res.get_entry();
    if (!entry || entry->m_et == ET_TYPE)
    {
        return;
    }

    if (entry->m_et == ET_NAME || entry->m_et == ET_LANG)
    {
        if (entry->m_type == RT_STRING || entry->m_type == RT_MESSAGETABLE)
        {
            return;
        }
    }

    HTREEITEM hItem = TreeView_GetSelection(m_hwndTV);
    TreeView_EditLabel(m_hwndTV, hItem);
}

// the predefined macro dialog
void MMainWnd::OnPredefMacros(HWND hwnd)
{
    // compile if necessary
    if (!CompileIfNecessary(FALSE))
        return;

    // show the dialog
    MMacrosDlg dialog;
    INT_PTR nID = dialog.DialogBoxDx(hwnd);
    switch (INT(nID))
    {
    case IDOK:
        g_settings.macros = dialog.m_map;
        break;
    case psh6:
        g_settings.ResetMacros();
        break;
    }
}

// expand all the tree control items
void MMainWnd::OnExpandAll(HWND hwnd)
{
    ShowLangArrow(FALSE);

    // get the selected entry
    auto entry = g_res.get_entry();

    HTREEITEM hItem = TreeView_GetRoot(m_hwndTV);
    do
    {
        Expand(hItem);
        hItem = TreeView_GetNextSibling(m_hwndTV, hItem);
    } while (hItem);

    // select the entry
    SelectTV(entry, FALSE);

    // update language arrow
    PostUpdateLangArrow(hwnd);
}

// unexpand all the tree control items
void MMainWnd::OnCollapseAll(HWND hwnd)
{
    ShowLangArrow(FALSE);

    HTREEITEM hItem = TreeView_GetRoot(m_hwndTV);
    do
    {
        Collapse(hItem);
        hItem = TreeView_GetNextSibling(m_hwndTV, hItem);
    } while (hItem);

    // select the entry
    SelectTV(NULL, FALSE);

    // update language arrow
    PostUpdateLangArrow(hwnd);
}

void MMainWnd::OnAddBang(HWND hwnd, NMTOOLBAR *pToolBar)
{
    // TODO: If you edited "Edit" menu, then you may have to update the below codes
    HMENU hMenu = GetMenu(hwnd);
    HMENU hEditMenu = GetSubMenu(hMenu, 1);
    HMENU hAddMenu = GetSubMenu(hEditMenu, 2);

    // the button rectangle
    RECT rcItem = pToolBar->rcButton;

    // get the hot point
    POINT pt;
    pt.x = rcItem.left;
    pt.y = rcItem.bottom;
    ClientToScreen(m_hToolBar, &pt);

    // get the monitor info
    HMONITOR hMon = MonitorFromPoint(pt, MONITOR_DEFAULTTONEAREST);
    MONITORINFO mi;
    ZeroMemory(&mi, sizeof(mi));
    mi.cbSize = sizeof(mi);
    GetMonitorInfo(hMon, &mi);

    // by the hot point, change the menu alignment
    UINT uFlags = TPM_LEFTALIGN | TPM_LEFTBUTTON | TPM_VERTICAL;
    if (pt.y >= (mi.rcWork.top + mi.rcWork.bottom) / 2)
    {
        uFlags |= TPM_BOTTOMALIGN;
        pt.x = rcItem.left;
        pt.y = rcItem.top;
        ClientToScreen(m_hToolBar, &pt);
    }
    else
    {
        uFlags |= TPM_TOPALIGN;
    }

    // See: https://msdn.microsoft.com/en-us/library/windows/desktop/ms648002.aspx
    SetForegroundWindow(m_hwnd);

    // show the popup menu
    TPMPARAMS params;
    ZeroMemory(&params, sizeof(params));
    params.cbSize = sizeof(params);
    params.rcExclude = rcItem;
    TrackPopupMenuEx(hAddMenu, uFlags, pt.x, pt.y, m_hwnd, &params);

    // See: https://msdn.microsoft.com/en-us/library/windows/desktop/ms648002.aspx
    SendMessageDx(WM_NULL);
}

void MMainWnd::OnClone(HWND hwnd)
{
    // compile if necessary
    if (!CompileIfNecessary(FALSE))
        return;

    auto entry = g_res.get_entry();
    if (!entry)
        return;

    switch (entry->m_et)
    {
    case ET_TYPE:
        break;

    case ET_NAME:
        OnCopyAsNewName(hwnd);
        break;

    case ET_LANG:
    case ET_STRING:
    case ET_MESSAGE:
        OnCopyAsNewLang(hwnd);
        break;

    default:
        break;
    }
}

void MMainWnd::OnGuide(HWND hwnd)
{
    static const WCHAR szJapaneseURL[] =
        L"https://katahiromz.web.fc2.com/colony3rd/risoheditor/";
    static const WCHAR szEnglishURL[] =
        L"https://katahiromz.web.fc2.com/colony3rd/risoheditor/en/";

    if (PRIMARYLANGID(GetThreadUILanguage()) == LANG_JAPANESE)
        ShellExecuteW(hwnd, NULL, szJapaneseURL, NULL, NULL, SW_SHOWNORMAL);
    else
        ShellExecuteW(hwnd, NULL, szEnglishURL, NULL, NULL, SW_SHOWNORMAL);
}

void MMainWnd::OnEncoding(HWND hwnd)
{
    // compile if necessary
    if (!CompileIfNecessary(FALSE))
        return;

    MEncodingDlg dialog;
    if (IDOK == dialog.DialogBoxDx(hwnd))
    {
        // select the entry
        auto entry = g_res.get_entry();
        SelectTV(entry, FALSE);
    }
}

void MMainWnd::OnQueryConstant(HWND hwnd)
{
    // compile if necessary
    if (!CompileIfNecessary(FALSE))
        return;

    MConstantDlg dialog;
    dialog.DialogBoxDx(hwnd);
}

void MMainWnd::OnExtractBang(HWND hwnd)
{
    auto entry = g_res.get_entry();
    if (!entry)
        return;

    switch (entry->m_et)
    {
    case ET_TYPE:
    case ET_NAME:
    case ET_STRING:
    case ET_MESSAGE:
        OnExtractBin(hwnd);
        break;

    case ET_LANG:
        if (entry->m_type == RT_ICON || entry->m_type == RT_GROUP_ICON ||
            entry->m_type == RT_ANIICON)
        {
            OnExtractIcon(hwnd);
        }
        else if (entry->m_type == RT_CURSOR || entry->m_type == RT_GROUP_CURSOR ||
                 entry->m_type == RT_ANICURSOR)
        {
            OnExtractCursor(hwnd);
        }
        else if (entry->m_type == RT_BITMAP)
        {
            OnExtractBitmap(hwnd);
        }
        else if (entry->m_type == RT_RCDATA && entry->is_delphi_dfm())
        {
            OnExtractDFM(hwnd);
        }
        else if (entry->m_type == L"TYPELIB")
        {
            OnExtractTLB(hwnd);
        }
        else
        {
            OnExtractBin(hwnd);
        }
        break;

    default:
        break;
    }
}

void MMainWnd::OnSaveAsWithCompression(HWND hwnd)
{
    enum ResFileFilterIndex     // see also: IDS_EXEFILTER
    {
        RFFI2_NONE = 0,
        RFFI2_EXECUTABLE = 1,
        RFFI2_ALL = 2
    };

    // compile if necessary
    if (!CompileIfNecessary(TRUE))
        return;

    // store m_szFile to szFile
    WCHAR szFile[MAX_PATH];
    StringCchCopyW(szFile, _countof(szFile), m_szFile);

    // if not found, then make it empty
    if (!PathFileExistsW(szFile))
        szFile[0] = 0;

    // initialize OPENFILENAME structure
    OPENFILENAMEW ofn = { OPENFILENAME_SIZE_VERSION_400W, hwnd };
    ofn.lpstrFilter = MakeFilterDx(LoadStringDx(IDS_EXEFILTER));

    // use the prefered filter by the entry
    ofn.nFilterIndex = RFFI2_EXECUTABLE;

    // use the preferred extension
    WCHAR szExt[32];
    LPWSTR pchDotExt = PathFindExtensionW(m_szFile);
    if (pchDotExt && *pchDotExt == L'.')
    {
        StringCbCopyW(szExt, sizeof(szExt), pchDotExt + 1);
        ofn.lpstrDefExt = szExt;
    }
    else
    {
        ofn.lpstrDefExt = L"exe";       // the default extension
    }

    ofn.lpstrFile = szFile;
    ofn.nMaxFile = _countof(szFile);
    ofn.lpstrTitle = LoadStringDx(IDS_SAVEASCOMPRESS);
    ofn.Flags = OFN_ENABLESIZING | OFN_EXPLORER | OFN_HIDEREADONLY |
                OFN_OVERWRITEPROMPT | OFN_PATHMUSTEXIST;

    // let the user choose the path
    if (GetSaveFileNameW(&ofn))
    {
        // save it
        if (!DoSaveAsCompression(szFile))
        {
            ErrorBoxDx(IDS_CANNOTSAVE);
        }
    }
}

// toggle the word wrapping of the source EDIT control
void MMainWnd::OnWordWrap(HWND hwnd)
{
    // save the modified flag
    BOOL bModified = Edit_GetModify(m_hCodeEditor);

    // switch the flag
    g_settings.bWordWrap = !g_settings.bWordWrap;

    // get text
    MString strText = GetWindowTextW(m_hCodeEditor);

    // create the source EDIT control
    ReCreateSrcEdit(hwnd);

    // reset fonts
    ReCreateFonts(hwnd);

    // restore text
    SetWindowTextW(m_hCodeEditor, strText.c_str());

    // restore the modified flag
    Edit_SetModify(m_hCodeEditor, bModified);

    // select the entry to refresh
    auto entry = g_res.get_entry();
    SelectTV(entry, FALSE, STV_DONTRESET);
}

void MMainWnd::OnUseMSMSGTBL(HWND hwnd)
{
    g_settings.bUseMSMSGTABLE = !g_settings.bUseMSMSGTABLE;

    // create the source EDIT control
    ReCreateSrcEdit(hwnd);

    // reset fonts
    ReCreateFonts(hwnd);

    // select the entry to refresh
    auto entry = g_res.get_entry();
    SelectTV(entry, FALSE, STV_RESETTEXT);
}

void MMainWnd::OnUseBeginEnd(HWND hwnd)
{
    g_settings.bUseBeginEnd = !g_settings.bUseBeginEnd;

    // create the source EDIT control
    ReCreateSrcEdit(hwnd);

    // reset fonts
    ReCreateFonts(hwnd);

    // select the entry to refresh
    auto entry = g_res.get_entry();
    SelectTV(entry, FALSE, STV_RESETTEXT);
}

// expand the treeview items
void MMainWnd::Expand(HTREEITEM hItem)
{
    TreeView_Expand(m_hwndTV, hItem, TVE_EXPAND);
    hItem = TreeView_GetChild(m_hwndTV, hItem);
    if (hItem == NULL)
        return;
    do
    {
        Expand(hItem);
        hItem = TreeView_GetNextSibling(m_hwndTV, hItem);
    } while (hItem);
}

void MMainWnd::UpdateLangArrow()
{
    EntryBase *entry = g_res.get_entry();
    if (!entry)
    {
        HTREEITEM hItem = TreeView_GetSelection(m_hwndTV);
        ShowLangArrow(FALSE, hItem);
        return;
    }

    HTREEITEM hItem = entry->m_hItem;

    switch (entry->m_et)
    {
    case ET_LANG:
        if (entry->m_type != RT_STRING && entry->m_type != RT_MESSAGETABLE)
            ShowLangArrow(TRUE, hItem);
        else
            ShowLangArrow(FALSE, hItem);
        break;
    case ET_STRING:
    case ET_MESSAGE:
        ShowLangArrow(TRUE, hItem);
        break;
    default:
        ShowLangArrow(FALSE, hItem);
        break;
    }
}

// unexpand the treeview items
void MMainWnd::Collapse(HTREEITEM hItem)
{
    TreeView_Expand(m_hwndTV, hItem, TVE_COLLAPSE);
    hItem = TreeView_GetChild(m_hwndTV, hItem);
    if (hItem == NULL)
        return;
    do
    {
        Collapse(hItem);
        hItem = TreeView_GetNextSibling(m_hwndTV, hItem);
    } while (hItem);
}

void MMainWnd::OnRefreshAll(HWND hwnd)
{
    BOOL bModifiedOld = s_bModified;
    DoRefreshTV(hwnd);
    DoRefreshIDList(hwnd);
    SelectTV(g_res.get_entry(), FALSE);

    s_bModified = bModifiedOld;

    PostUpdateLangArrow(hwnd);
}

// WM_COMMAND
void MMainWnd::OnCommand(HWND hwnd, int id, HWND hwndCtl, UINT codeNotify)
{
    MWaitCursor wait;

    if (codeNotify == EN_CHANGE && m_hCodeEditor == hwndCtl)
    {
        // the source EDIT control was modified.
        // change the toolbar
        UpdateOurToolBarButtons(2);

        // show "ready" status
        ChangeStatusText(IDS_READY);
        return;
    }

    // show "executing command..." status
    if (!::IsWindow(m_rad_window) && id >= 100)
        ChangeStatusText(IDS_EXECUTINGCMD);

    // add a command lock
    ++m_nCommandLock;

    // execute the command
    BOOL bUpdateStatus = TRUE;
    switch (id)
    {
    case ID_NEW:
        OnNew(hwnd);
        break;
    case ID_OPEN:
        OnOpen(hwnd);
        break;
    case ID_SAVEAS:
        OnSaveAs(hwnd);
        break;
    case ID_IMPORT:
        OnImport(hwnd);
        break;
    case ID_EXIT:
        DestroyWindow(hwnd);
        break;
    case ID_ADDICON:
        OnAddIcon(hwnd);
        break;
    case ID_ADDCURSOR:
        OnAddCursor(hwnd);
        break;
    case ID_ADDBITMAP:
        OnAddBitmap(hwnd);
        break;
    case ID_ADDRES:
        OnAddRes(hwnd);
        break;
    case ID_REPLACEICON:
        OnReplaceIcon(hwnd);
        break;
    case ID_REPLACECURSOR:
        OnReplaceCursor(hwnd);
        break;
    case ID_REPLACEBITMAP:
        OnReplaceBitmap(hwnd);
        break;
    case ID_REPLACEBIN:
        OnReplaceBin(hwnd);
        break;
    case ID_DELETERES:
        OnDeleteRes(hwnd);
        break;
    case ID_EDIT:
        OnEdit(hwnd);
        break;
    case ID_EXTRACTICON:
        OnExtractIcon(hwnd);
        break;
    case ID_EXTRACTCURSOR:
        OnExtractCursor(hwnd);
        break;
    case ID_EXTRACTBITMAP:
        OnExtractBitmap(hwnd);
        break;
    case ID_EXTRACTBIN:
        OnExtractBin(hwnd);
        break;
    case ID_ABOUT:
        OnAbout(hwnd);
        break;
    case ID_TEST:
        OnTest(hwnd);
        break;
    case ID_CANCELEDIT:
        OnCancelEdit(hwnd);
        break;
    case ID_COMPILE:
        OnCompile(hwnd);
        break;
    case ID_GUIEDIT:
        OnGuiEdit(hwnd);
        break;
    case ID_DESTROYRAD:
        OnCancelEdit(hwnd);
        break;
    case ID_DELCTRL:
        MRadCtrl::DeleteSelection();
        ::SendMessageW(m_hCodeEditor, LNEM_CLEARLINEMARKS, 0, 0);
        break;
    case ID_ADDCTRL:
        m_rad_window.OnAddCtrl(m_rad_window);
        break;
    case ID_CTRLPROP:
        m_rad_window.OnCtrlProp(m_rad_window);
        break;
    case ID_DLGPROP:
        m_rad_window.OnDlgProp(m_rad_window);
        break;
    case ID_CTRLINDEXTOP:
        m_rad_window.IndexTop(m_rad_window);
        ::SendMessageW(m_hCodeEditor, LNEM_CLEARLINEMARKS, 0, 0);
        break;
        break;
    case ID_CTRLINDEXBOTTOM:
        m_rad_window.IndexBottom(m_rad_window);
        ::SendMessageW(m_hCodeEditor, LNEM_CLEARLINEMARKS, 0, 0);
        break;
        break;
    case ID_CTRLINDEXMINUS:
        m_rad_window.IndexMinus(m_rad_window);
        ::SendMessageW(m_hCodeEditor, LNEM_CLEARLINEMARKS, 0, 0);
        break;
        break;
    case ID_CTRLINDEXPLUS:
        m_rad_window.IndexPlus(m_rad_window);
        ::SendMessageW(m_hCodeEditor, LNEM_CLEARLINEMARKS, 0, 0);
        break;
    case ID_SHOWHIDEINDEX:
        m_rad_window.OnShowHideIndex(m_rad_window);
        break;
    case ID_TOPALIGN:
        m_rad_window.OnTopAlign(m_rad_window);
        break;
    case ID_BOTTOMALIGN:
        m_rad_window.OnBottomAlign(m_rad_window);
        break;
    case ID_LEFTALIGN:
        m_rad_window.OnLeftAlign(m_rad_window);
        break;
    case ID_RIGHTALIGN:
        m_rad_window.OnRightAlign(m_rad_window);
        break;
    case ID_FITTOGRID:
        m_rad_window.OnFitToGrid(m_rad_window);
        bUpdateStatus = FALSE;
        break;
    case ID_STATUSBAR:
        // toggle the flag
        g_settings.bShowStatusBar = !g_settings.bShowStatusBar;

        // show/hide the scroll bar
        ShowStatusBar(g_settings.bShowStatusBar);

        // relayout
        PostMessageDx(WM_SIZE);
        break;
    case ID_BINARYPANE:
        // toggle the flag
        g_settings.bShowBinEdit = !g_settings.bShowBinEdit;
        // show/hide the binary
        m_tab.SetCurSel(!!g_settings.bShowBinEdit);
        OnSelChange(hwnd, !!g_settings.bShowBinEdit);
        break;
    case ID_ALWAYSCONTROL:
        {
            // toggle the flag
            g_settings.bAlwaysControl = !g_settings.bAlwaysControl;

            // select the entry to update the text
            auto entry = g_res.get_entry();
            SelectTV(entry, FALSE);
        }
        break;
    case ID_MRUFILE0:
    case ID_MRUFILE1:
    case ID_MRUFILE2:
    case ID_MRUFILE3:
    case ID_MRUFILE4:
    case ID_MRUFILE5:
    case ID_MRUFILE6:
    case ID_MRUFILE7:
    case ID_MRUFILE8:
    case ID_MRUFILE9:
    case ID_MRUFILE10:
    case ID_MRUFILE11:
    case ID_MRUFILE12:
    case ID_MRUFILE13:
    case ID_MRUFILE14:
    case ID_MRUFILE15:
        {
            DWORD i = id - ID_MRUFILE0;
            if (i < g_settings.vecRecentlyUsed.size())
            {
                DoLoadFile(hwnd, g_settings.vecRecentlyUsed[i].c_str());
            }
        }
        break;
    case ID_PLAY:
        OnPlay(hwnd);
        break;
    case ID_READY:
        if (g_bNoGuiMode)
        {
            std::vector<MStringW> commands;
            mstr_split(commands, m_commands, L"\n");
            for (auto& command : commands)
            {
                if (command.empty())
                    continue;

                if (command.find(L"load:") == 0)
                {
                    command = command.substr(5);
                    if (!DoResLoad(command, m_load_options))
                        s_ret = 3;
                    continue;
                }

                if (command.find(L"save:") == 0)
                {
                    command = command.substr(5);
                    if (!DoResSave(command, m_save_options))
                        s_ret = 4;
                    continue;
                }
            }

            PostMessageW(hwnd, WM_CLOSE, 0, 0);
        }
        break;
    case ID_IDASSOC:
        OnIdAssoc(hwnd);
        break;
    case ID_LOADRESH:
        OnLoadResH(hwnd);
        break;
    case ID_IDLIST:
        OnIDList(hwnd);
        break;
    case ID_UNLOADRESH:
        OnUnloadResH(hwnd);
        break;
    case ID_HIDEIDMACROS:
        OnHideIDMacros(hwnd);
        break;
    case ID_USEIDC_STATIC:
        OnUseIDC_STATIC(hwnd);
        break;
    case ID_CONFIG:
        OnConfig(hwnd);
        break;
    case ID_ADVICERESH:
        OnAdviceResH(hwnd);
        break;
    case ID_UPDATEID:
        UpdateNames();
        break;
    case ID_OPENREADME:
        OnOpenLocalFile(hwnd, L"README.txt");
        break;
    case ID_OPENREADMEJP:
        OnOpenLocalFile(hwnd, L"README-JPN.txt");
        break;
    case ID_LOADWCLIB:
        OnLoadWCLib(hwnd);
        break;
    case ID_FIND:
        OnFind(hwnd);
        break;
    case ID_FINDDOWNWARD:
        OnFindNext(hwnd);
        break;
    case ID_FINDUPWARD:
        OnFindPrev(hwnd);
        break;
    case ID_REPLACE:
        break;
    case ID_ADDMENU:
        OnAddMenu(hwnd);
        break;
    case ID_ADDTOOLBAR:
        OnAddToolbar(hwnd);
        break;
    case ID_ADDVERINFO:
        OnAddVerInfo(hwnd);
        break;
    case ID_ADDMANIFEST:
        OnAddManifest(hwnd);
        break;
    case ID_ADDDIALOG:
        OnAddDialog(hwnd);
        break;
    case ID_ADDSTRINGTABLE:
        OnAddStringTable(hwnd);
        break;
    case ID_ADDMESSAGETABLE:
        OnAddMessageTable(hwnd);
        break;
    case ID_ADDHTML:
        OnAddHtml(hwnd);
        break;
    case ID_ADDACCEL:
        OnAddAccel(hwnd);
        break;
    case ID_COPYASNEWNAME:
        OnCopyAsNewName(hwnd);
        break;
    case ID_COPYASNEWLANG:
        OnCopyAsNewLang(hwnd);
        break;
    case ID_COPYTOMULTILANG:
        OnCopyToMultiLang(hwnd);
        break;
    case ID_ITEMSEARCH:
        OnItemSearch(hwnd);
        break;
    case ID_UPDATERESHBANG:
        OnUpdateResHBang(hwnd);
        break;
    case ID_OPENLICENSE:
        OnOpenLocalFile(hwnd, L"LICENSE.txt");
        break;
    case ID_OPENHISTORY:
        OnOpenLocalFile(hwnd, L"HISTORY.txt");
        break;
    case ID_OPENHISTORYITA:
        OnOpenLocalFile(hwnd, L"HISTORY-ITA.txt");
        break;
    case ID_OPENHISTORYJPN:
        OnOpenLocalFile(hwnd, L"HISTORY-JPN.txt");
        break;
    case ID_OPENHISTORYKOR:
        OnOpenLocalFile(hwnd, L"HISTORY-KOR.txt");
        break;
    case ID_OPENHYOJUNKA:
        OnOpenLocalFile(hwnd, L"HYOJUNKA.txt");
        break;
    case ID_DEBUGTREENODE:
        OnDebugTreeNode(hwnd);
        break;
    case ID_LOADRESHBANG:
        OnLoadResHBang(hwnd);
        break;
    case ID_REFRESHDIALOG:
        m_rad_window.OnRefresh(m_rad_window);
        break;
    case ID_REFRESHALL:
        OnRefreshAll(hwnd);
        break;
    case ID_EXPORT:
        OnExport(hwnd);
        break;
    case ID_FONTS:
        OnFonts(hwnd);
        break;
    case ID_REFRESH:
        DoRefreshTV(hwnd);
        break;
    case ID_PREDEFMACROS:
        OnPredefMacros(hwnd);
        break;
    case ID_EDITLABEL:
        OnEditLabel(hwnd);
        break;
    case ID_SETPATHS:
        OnSetPaths(hwnd);
        break;
    case ID_SETDEFAULTS:
        SetDefaultSettings(hwnd);
        break;
    case ID_SHOWLANGS:
        OnShowLangs(hwnd);
        break;
    case ID_SHOWHIDETOOLBAR:
        OnShowHideToolBar(hwnd);
        break;
    case ID_EXPAND_ALL:
        OnExpandAll(hwnd);
        break;
    case ID_COLLAPSE_ALL:
        OnCollapseAll(hwnd);
        break;
    case ID_WORD_WRAP:
        OnWordWrap(hwnd);
        break;
    case ID_SAVEASCOMPRESS:
        OnSaveAsWithCompression(hwnd);
        break;
    case ID_CLONE:
        OnClone(hwnd);
        break;
    case ID_ADDBANG:
        break;
    case ID_EXTRACTBANG:
        OnExtractBang(hwnd);
        break;
    case ID_GUIDE:
        OnGuide(hwnd);
        break;
    case ID_ENCODING:
        OnEncoding(hwnd);
        break;
    case ID_QUERYCONSTANT:
        OnQueryConstant(hwnd);
        break;
    case ID_USEBEGINEND:
        OnUseBeginEnd(hwnd);
        break;
    case ID_USEMSMSGTBL:
        OnUseMSMSGTBL(hwnd);
        break;
    case ID_SAVE:
        OnSave(hwnd);
        break;
    case ID_EGA:
        OnEga(hwnd);
        break;
    case ID_EGA_PROGRAM:
        OnEgaProgram(hwnd);
        break;
    case ID_OPENREADMEIT:
        OnOpenLocalFile(hwnd, L"README-ITA.txt");
        break;
    case ID_OPEN_EGA_MANUAL:
        OnOpenLocalFile(hwnd, L"EGA\\EGA-Manual.pdf");
        break;
    case ID_DIALOG_FONT_SUBSTITUTES:
        OnDialogFontSubst(hwnd);
        break;
    case ID_HELP:
        OnHelp(hwnd);
        break;
    case ID_NEXTPANE:
        OnNextPane(hwnd, TRUE);
        break;
    case ID_PREVPANE:
        OnNextPane(hwnd, FALSE);
        break;
    case ID_EXTRACTRC:
        OnExtractRC(hwnd);
        break;
    case ID_EXPORTRES:
        OnExportRes(hwnd);
        break;
    case ID_CHECKUPDATE:
        OnCheckUpdate(hwnd);
        break;
    case ID_DFMSETTINGS:
        OnDfmSettings(hwnd);
        break;
    case ID_AUTOCOMPLETE:
        {
            HWND hwndEdit = TreeView_GetEditControl(m_hwndTV);
            DoLangEditAutoComplete(hwnd, hwndEdit);
        }
        break;
    case ID_AUTOCOMPLETEDONE:
        DoLangEditAutoCompleteRelease(hwnd);
        break;
    case ID_OPENREADMEKO:
        OnOpenLocalFile(hwnd, L"README-KOR.txt");
        break;
    case ID_CHOOSEUILANG:
        {
            MChooseLangDlg dialog;
            if (dialog.DialogBoxDx(hwnd) == IDOK)
                s_ui_lang = dialog.m_langid;
        }
        break;
    case ID_OPENREADMETR:
        OnOpenLocalFile(hwnd, L"README-TR.txt");
        break;
    case ID_OPENREADMEID:
        OnOpenLocalFile(hwnd, L"README-ID.txt");
        break;
    case ID_OPENHISTORYID:
        OnOpenLocalFile(hwnd, L"HISTORY-ID.txt");
        break;
    case ID_OPENREADMEPTB:
        OnOpenLocalFile(hwnd, L"README-PTB.txt");
        break;
    case ID_OPENHISTORYPTB:
        OnOpenLocalFile(hwnd, L"HISTORY-PTB.txt");
        break;
    default:
        bUpdateStatus = FALSE;
        break;
    }

    // remove the command lock
    --m_nCommandLock;

    if (m_nCommandLock == 0)
        g_res.delete_invalid();     // clean up invalids

    UpdateToolBarStatus();

    // show "ready" status if ready
    if (m_nCommandLock == 0 && bUpdateStatus && !::IsWindow(m_rad_window))
    {
        if (m_nStatusStringID != 0)
        {
            ChangeStatusText(m_nStatusStringID);
            m_nStatusStringID = 0;
        }
        else
        {
            ChangeStatusText(IDS_READY);
        }
    }

#if 0 && !defined(NDEBUG) && (WINVER >= 0x0500)
    // show object counts (for debugging purpose)
    HANDLE hProcess = GetCurrentProcess();
    TCHAR szText[64];
    StringCchPrintf(szText, _countof(szText), TEXT("GDI:%ld, USER:%ld"),
             GetGuiResources(hProcess, GR_GDIOBJECTS),
             GetGuiResources(hProcess, GR_USEROBJECTS));
    ChangeStatusText(szText);
#endif
}

// get the resource name from text
MIdOrString GetNameFromText(const WCHAR *pszText)
{
    // pszText --> szText
    WCHAR szText[128];
    StringCchCopyW(szText, _countof(szText), pszText);

    // replace the fullwidth characters with halfwidth characters
    ReplaceFullWithHalf(szText);

    if (szText[0] == 0)
    {
        return (WORD)0;     // empty
    }
    else if (mchr_is_digit(szText[0]) || szText[0] == L'-' || szText[0] == L'+')
    {
        // numeric
        return WORD(mstr_parse_int(szText));
    }
    else
    {
        // string value
        MStringW str = szText;

        // is there parenthesis?
        size_t i = str.rfind(L'('); // ')'
        if (i != MStringW::npos && mchr_is_digit(str[i + 1]))
        {
            // parse the text after the last parenthesis
            return WORD(mstr_parse_int(&str[i + 1]));
        }

        // string
        return MIdOrString(szText);
    }
}

// get the IDTYPE_ values by the specified prefix
std::vector<INT> GetPrefixIndexes(const MString& prefix)
{
    std::vector<INT> ret;
    for (auto& pair : g_settings.assoc_map)
    {
        if (prefix == pair.second && !pair.second.empty())
        {
            auto nIDTYPE_ = IDTYPE_(g_db.GetValue(L"RESOURCE.ID.TYPE", pair.first));
            ret.push_back(nIDTYPE_);
        }
    }
    return ret;
}

BOOL MMainWnd::ShowLangArrow(BOOL bShow, HTREEITEM hItem)
{
    auto entry = g_res.get_entry();
    if (!entry)
    {
        ShowWindowAsync(m_arrow, SW_HIDE);
        return FALSE;
    }

    if (hItem == NULL)
    {
        hItem = TreeView_GetSelection(m_hwndTV);
    }

    RECT rc;
    TreeView_GetItemRect(m_hwndTV, hItem, &rc, TRUE);

    RECT rcClient;
    GetClientRect(m_hwndTV, &rcClient);
    SIZE siz = m_arrow.GetArrowSize(&rc);
    LONG x = rcClient.right - siz.cx;
    LONG y = rc.top;

    m_arrow.ShowDropDownList(m_arrow, FALSE);

    if (bShow)
    {
        if (IsWindow(m_arrow))
        {
            UINT uFlags = SWP_NOSIZE | SWP_NOACTIVATE | SWP_NOZORDER;
            SetWindowPos(m_arrow, NULL, x, y, 0, 0, uFlags);
        }
        else
        {
            m_arrow.CreateAsChildDx(m_hwndTV, NULL, WS_CHILD, 0, -1, x, y);
        }
        m_arrow.m_hwndMain = m_hwnd;
        m_arrow.SendMessageDx(MYWM_SETITEMRECT, 0, (LPARAM)&rc);
        ShowWindowAsync(m_arrow, SW_SHOWNOACTIVATE);
    }
    else
    {
        if (IsWindow(m_arrow))
        {
            ShowWindow(m_arrow, SW_HIDE);
            InvalidateRect(m_hwndTV, &rc, TRUE);
        }
    }

    return TRUE;
}

void MMainWnd::DoLangEditAutoCompleteRelease(HWND hwnd)
{
    if (m_pAutoComplete)
    {
        m_pAutoComplete->unbind();
        m_pAutoComplete->Release();
        m_pAutoComplete = NULL;
    }

    m_auto_comp_edit.unhook();
}

void MMainWnd::DoLangEditAutoComplete(HWND hwnd, HWND hwndEdit)
{
    DoLangEditAutoCompleteRelease(hwnd);

    m_pAutoComplete = new MLangAutoComplete();
    if (!m_pAutoComplete)
        return;

    m_pAutoComplete->AddRef();
    m_pAutoComplete->bind(hwndEdit);
    m_auto_comp_edit.hook(hwndEdit, m_hwndTV);
    m_auto_comp_edit.m_bAdjustSize = TRUE;
}

// WM_NOTIFY
LRESULT MMainWnd::OnNotify(HWND hwnd, int idFrom, NMHDR *pnmhdr)
{
    // get the selected entry
    auto entry = g_res.get_entry();

    if (pnmhdr->code == TCN_SELCHANGE)
    {
        if (pnmhdr->hwndFrom == m_tab)
        {
            INT iSelected = m_tab.GetCurSel();
            OnSelChange(hwnd, iSelected);
        }
    }
    else if (pnmhdr->code == MSplitterWnd::NOTIFY_CHANGED)
    {
        MWaitCursor wait;
        if (pnmhdr->hwndFrom == m_splitter1)
        {
            if (m_splitter1.GetPaneCount() >= 2)
            {
                g_settings.nTreeViewWidth = m_splitter1.GetPaneExtent(0);

                // relayout
                PostMessage(hwnd, WM_SIZE, 0, 0);
            }
        }
        else if (pnmhdr->hwndFrom == m_splitter2)
        {
            if (m_splitter2.GetPaneCount() >= 2)
                g_settings.nBmpViewWidth = m_splitter2.GetPaneExtent(1);
        }
    }
    else if (pnmhdr->code == TVN_DELETEITEM)
    {
        MWaitCursor wait;
        auto ptv = (NM_TREEVIEW *)pnmhdr;
        auto entry = (EntryBase *)ptv->itemOld.lParam;
        g_res.on_delete_item(entry);
        DoSetFileModified(TRUE);
    }
    else if (pnmhdr->code == NM_DBLCLK)
    {
        MWaitCursor wait;
        if (pnmhdr->hwndFrom == m_hwndTV)
        {
            switch (entry->m_et)
            {
            case ET_LANG:
                OnEdit(hwnd);
                if (g_settings.bGuiByDblClick)
                {
                    OnGuiEdit(hwnd);
                }
                return 1;
            case ET_STRING:
                OnEdit(hwnd);
                if (g_settings.bGuiByDblClick)
                {
                    OnGuiEdit(hwnd);
                }
                return 1;
            case ET_MESSAGE:
                OnEdit(hwnd);
                if (g_settings.bGuiByDblClick)
                {
                    OnGuiEdit(hwnd);
                }
                return 1;
            default:
                break;
            }
        }
    }
    else if (pnmhdr->code == TVN_SELCHANGING)
    {
        MWaitCursor wait;
        if (!m_bLoading)
        {
            // compile if necessary
            if (!CompileIfNecessary(FALSE))
                return TRUE;
        }
        if (IsWindow(m_rad_window))
        {
            m_rad_window.DestroyWindow();
        }
    }
    else if (pnmhdr->code == TVN_SELCHANGED)
    {
        MWaitCursor wait;
        if (!m_bLoading && entry)
        {
            // select the entry to update the text
            SelectTV(entry, FALSE);
            OnSelChange(hwnd, 0);

            PostUpdateLangArrow(hwnd);
        }
    }
    else if (pnmhdr->code == TVN_ITEMEXPANDING)
    {
        m_arrow.ShowDropDownList(m_arrow, FALSE);
        ShowLangArrow(FALSE);
    }
    else if (pnmhdr->code == TVN_ITEMEXPANDED)
    {
        PostUpdateLangArrow(hwnd);
    }
    else if (pnmhdr->code == NM_RETURN)
    {
        MWaitCursor wait;
        if (pnmhdr->hwndFrom == m_hwndTV)
        {
            switch (entry->m_et)
            {
            case ET_LANG:
                OnEdit(hwnd);
                if (g_settings.bGuiByDblClick)
                {
                    OnGuiEdit(hwnd);
                }
                return 1;
            case ET_STRING:
                OnEdit(hwnd);
                if (g_settings.bGuiByDblClick)
                {
                    OnGuiEdit(hwnd);
                }
                return 1;
            case ET_MESSAGE:
                OnEdit(hwnd);
                if (g_settings.bGuiByDblClick)
                {
                    OnGuiEdit(hwnd);
                }
                return 1;
            default:
                break;
            }
        }
    }
    else if (pnmhdr->code == TVN_KEYDOWN)
    {
        MWaitCursor wait;
        auto pTVKD = (TV_KEYDOWN *)pnmhdr;
        switch (pTVKD->wVKey)
        {
        case VK_DELETE:
            PostMessageW(hwnd, WM_COMMAND, ID_DELETERES, 0);
            DoSetFileModified(TRUE);
            return TRUE;
        case VK_LEFT:
        case VK_RIGHT:
            ShowLangArrow(FALSE);
            PostUpdateLangArrow(hwnd);
            break;
        case VK_F2:
            {
                // compile if necessary
                if (!CompileIfNecessary(FALSE))
                    return TRUE;

                // get the selected type entry
                auto entry = g_res.get_entry();
                if (!entry || entry->m_et == ET_TYPE)
                {
                    return TRUE;
                }

                if (entry->m_et == ET_NAME || entry->m_et == ET_LANG)
                {
                    if (entry->m_type == RT_STRING || entry->m_type == RT_MESSAGETABLE)
                    {
                        return TRUE;
                    }
                }

                HTREEITEM hItem = TreeView_GetSelection(m_hwndTV);
                TreeView_EditLabel(m_hwndTV, hItem);
            }
            return TRUE;
        }
    }
    else if (pnmhdr->code == TVN_GETINFOTIP)
    {
        MWaitCursor wait;
        auto pGetInfoTip = (NMTVGETINFOTIP *)pnmhdr;
        auto entry = (EntryBase *)pGetInfoTip->lParam;
        if (g_res.super()->find(entry) != g_res.super()->end())
        {
            StringCchCopyW(pGetInfoTip->pszText, pGetInfoTip->cchTextMax,
                           entry->m_strLabel.c_str());
        }
    }
    else
    {
        static WORD old_lang = BAD_LANG;
        static WCHAR szOldText[MAX_PATH] = L"";

        if (pnmhdr->code == TBN_DROPDOWN)
        {
            auto pToolBar = (NMTOOLBAR *)pnmhdr;
            OnAddBang(hwnd, pToolBar);
        }
        else if (pnmhdr->code == TVN_BEGINLABELEDIT)
        {
            MWaitCursor wait;
            auto pInfo = (TV_DISPINFO *)pnmhdr;
            LPARAM lParam = pInfo->item.lParam;
            LPWSTR pszOldText = pInfo->item.pszText;
            //MessageBoxW(NULL, pszOldText, NULL, 0);

            if (IsWindow(m_arrow.m_dialog))
            {
                return TRUE;    // prevent
            }

            auto entry = (EntryBase *)lParam;

            if (entry->m_et == ET_TYPE)
            {
                return TRUE;    // prevent
            }

            if (entry->m_et == ET_NAME || entry->m_et== ET_LANG)
            {
                if (entry->m_type == RT_STRING || entry->m_type == RT_MESSAGETABLE)
                {
                    return TRUE;    // prevent
                }
            }

            StringCchCopyW(szOldText, _countof(szOldText), pszOldText);
            mstr_trim(szOldText);

            if (entry->m_et == ET_LANG || entry->m_et == ET_STRING ||
                entry->m_et == ET_MESSAGE)
            {
                old_lang = LangFromText(szOldText);
                if (old_lang == BAD_LANG)
                {
                    return TRUE;    // prevent
                }
            }

            m_arrow.ShowDropDownList(m_arrow, FALSE);
            ShowLangArrow(FALSE);

            switch (entry->m_et)
            {
            case ET_LANG:
            case ET_MESSAGE:
            case ET_STRING:
                PostMessage(hwnd, WM_COMMAND, ID_AUTOCOMPLETE, 0);
                break;
            }

            return FALSE;       // accept
        }
        else if (pnmhdr->code == TVN_ENDLABELEDIT)
        {
            MWaitCursor wait;
            auto pInfo = (TV_DISPINFO *)pnmhdr;
            LPARAM lParam = pInfo->item.lParam;
            LPWSTR pszNewText = pInfo->item.pszText;

            auto entry = (EntryBase *)lParam;

            switch (entry->m_et)
            {
            case ET_LANG:
            case ET_MESSAGE:
            case ET_STRING:
                PostMessage(hwnd, WM_COMMAND, ID_AUTOCOMPLETEDONE, 0);
                break;
            }

            if (pszNewText == NULL)
            {
                PostUpdateLangArrow(hwnd);
                return FALSE;   // reject
            }

            if (!entry || entry->m_et == ET_TYPE)
            {
                return FALSE;   // reject
            }

            if (entry->m_et == ET_NAME || entry->m_et == ET_LANG)
            {
                if (entry->m_type == RT_STRING || entry->m_type == RT_MESSAGETABLE)
                {
                    return FALSE;   // reject
                }
            }

            WCHAR szNewText[MAX_PATH];
            StringCchCopyW(szNewText, _countof(szNewText), pszNewText);
            mstr_trim(szNewText);

            if (entry->m_et == ET_NAME)
            {
                // rename the name
                MIdOrString old_name = GetNameFromText(szOldText);
                MIdOrString new_name = GetNameFromText(szNewText);

                if (old_name.empty())
                    return FALSE;   // reject

                if (new_name.empty())
                {
                    ErrorBoxDx(IDS_INVALIDNAME);
                    return FALSE;   // reject
                }

                if (old_name == new_name)
                    return FALSE;   // reject

                // check if it already exists
                if (g_res.find(ET_LANG, entry->m_type, new_name))
                {
                    ErrorBoxDx(IDS_ALREADYEXISTS);
                    return FALSE;   // reject
                }

                DoRenameEntry(pszNewText, entry, old_name, new_name);
                DoSetFileModified(TRUE);
                return TRUE;   // accept
            }
            else if (entry->m_et == ET_LANG)
            {
                PostUpdateLangArrow(hwnd);

                old_lang = LangFromText(szOldText);
                if (old_lang == BAD_LANG)
                    return FALSE;   // reject

                WORD new_lang = LangFromText(szNewText);
                if (new_lang == BAD_LANG)
                {
                    ErrorBoxDx(IDS_INVALIDLANG);
                    return FALSE;   // reject
                }

                if (old_lang == new_lang)
                    return FALSE;   // reject

                // check if it already exists
                if (g_res.find(ET_LANG, entry->m_type, entry->m_name, new_lang))
                {
                    ErrorBoxDx(IDS_ALREADYEXISTS);
                    return FALSE;   // reject
                }

                DoRelangEntry(pszNewText, entry, old_lang, new_lang);
                DoSetFileModified(TRUE);

                return TRUE;   // accept
            }
            else if (entry->m_et == ET_STRING || entry->m_et == ET_MESSAGE)
            {
                PostUpdateLangArrow(hwnd);

                old_lang = LangFromText(szOldText);
                if (old_lang == BAD_LANG)
                    return FALSE;   // reject

                WORD new_lang = LangFromText(szNewText);
                if (new_lang == BAD_LANG)
                {
                    ErrorBoxDx(IDS_INVALIDLANG);
                    return FALSE;   // reject
                }

                if (old_lang == new_lang)
                    return FALSE;   // reject

                // check if it already exists
                if (g_res.find(ET_LANG, entry->m_type, WORD(0), new_lang))
                {
                    ErrorBoxDx(IDS_ALREADYEXISTS);
                    return FALSE;   // reject
                }

                DoRelangEntry(pszNewText, entry, old_lang, new_lang);
                DoSetFileModified(TRUE);
                return TRUE;   // accept
            }

            return FALSE;   // reject
        }
    }
    return 0;
}

static int CALLBACK
TreeViewCompare(LPARAM lParam1, LPARAM lParam2, LPARAM lParamSort)
{
    auto entry1 = (const EntryBase *)lParam1;
    auto entry2 = (const EntryBase *)lParam2;
    if (*entry1 < *entry2)
        return -1;
    if (*entry1 == *entry2)
        return 0;
    return 1;
}

// change the name of the resource entries
void MMainWnd::DoRenameEntry(LPWSTR pszText, EntryBase *entry, const MIdOrString& old_name, const MIdOrString& new_name)
{
    // search the old named language entries
    EntrySet found;
    g_res.search(found, ET_LANG, entry->m_type, old_name);

    // rename them
    for (auto e : found)
    {
        assert(e->m_name == old_name);
        e->m_name = new_name;
    }

    // update the entry name
    entry->m_name = new_name;
    UpdateEntryName(entry, pszText);
    DoRefreshIDList(m_hwnd);

    // select the entry to update the text
    SelectTV(entry, FALSE);

    DoSetFileModified(TRUE);

    // sort
    HTREEITEM hParent = TreeView_GetParent(m_hwndTV, entry->m_hItem);
    TV_SORTCB cb = { hParent, TreeViewCompare };
    TreeView_SortChildrenCB(m_hwndTV, &cb, 0);
}

// change the language of the resource entries
void MMainWnd::DoRelangEntry(LPWSTR pszText, EntryBase *entry, WORD old_lang, WORD new_lang)
{
    EntrySet found;

    switch (entry->m_et)
    {
    case ET_STRING:
        // serach the resource strings
        g_res.search(found, ET_LANG, entry->m_type, (WORD)0, old_lang);

        // replace the language
        for (auto e : found)
        {
            assert(e->m_lang == old_lang);
            e->m_lang = new_lang;
            UpdateEntryLang(e, pszText);
        }
        found.clear();
        break;

    case ET_MESSAGE:
        // serach the resource messages
        g_res.search(found, ET_LANG, entry->m_type, (WORD)0, old_lang);

        // replace the language
        for (auto e : found)
        {
            assert(e->m_lang == old_lang);
            e->m_lang = new_lang;
            UpdateEntryLang(e, pszText);
        }
        found.clear();
        break;

    case ET_LANG:
        break;

    default:
        return;
    }

    // search the old named old language entries
    g_res.search(found, ET_ANY, entry->m_type, entry->m_name, old_lang);
    for (auto e : found)
    {
        // replace the language
        assert(e->m_lang == old_lang);
        e->m_lang = new_lang;

        // update the language
        UpdateEntryLang(e, pszText);
    }

    // select the entry
    SelectTV(entry, FALSE);

    DoSetFileModified(TRUE);

    // sort
    HTREEITEM hParent = TreeView_GetParent(m_hwndTV, entry->m_hItem);
    TV_SORTCB cb = { hParent, TreeViewCompare };
    TreeView_SortChildrenCB(m_hwndTV, &cb, 0);
}

void MMainWnd::OnNextPane(HWND hwnd, BOOL bNext)
{
    HWND hwndCodeEditor = m_hCodeEditor;
    HWND hwndHexViewer = m_hHexViewer;
    HWND hwndRad = IsWindow(m_rad_window) ? (HWND)m_rad_window : NULL;
    HWND hwndIDList = IsWindow(m_id_list_dlg) ? (HWND)m_id_list_dlg : NULL;
    HWND hwndFind = IsWindow(m_hFindReplaceDlg) ? (HWND)m_hFindReplaceDlg : NULL;

    HWND hwndFocus = GetFocus();

    if (hwndRad != NULL && GetParent(hwndFocus) == hwndRad)
        hwndFocus = hwndRad;

    if (hwndIDList != NULL && GetParent(hwndFocus) == hwndIDList)
        hwndFocus = hwndIDList;

    if (hwndFind != NULL && GetParent(hwndFocus) == hwndFind)
        hwndFocus = hwndFind;

    if (hwndFocus == NULL)
    {
        SetFocus(m_hwndTV);
        return;
    }

    HWND ahwnd[] =
    {
        m_hwndTV, m_hCodeEditor, m_hHexViewer, hwndRad, m_hFindReplaceDlg, hwndIDList
    };

    UINT i;
    for (i = 0; i < _countof(ahwnd); ++i)
    {
        if (ahwnd[i] == hwndFocus)
            break;
    }

    if (i == _countof(ahwnd))
    {
        SetFocus(m_hwndTV);
        return;
    }

    if (bNext)
    {
        do
        {
            ++i;
            if (i == _countof(ahwnd))
                i = 0;
        } while (ahwnd[i] == NULL);
    }
    else
    {
        do
        {
            if (i == 0)
                i = _countof(ahwnd) - 1;
            else
                --i;
        } while (ahwnd[i] == NULL);
    }

    if (hwndCodeEditor == ahwnd[i])
    {
        OnSelChange(hwnd, 0);
        SetFocus(m_hCodeEditor);
    }
    else if (hwndHexViewer == ahwnd[i])
    {
        OnSelChange(hwnd, 1);
        SetFocus(m_hHexViewer);
    }
    else
    {
        SetFocus(ahwnd[i]);
    }
}

void MMainWnd::OnHelp(HWND hwnd)
{
    ShellExecuteW(hwnd, NULL, LoadStringDx(IDS_HOMEPAGE), NULL, NULL, SW_SHOWNORMAL);
}

void MMainWnd::OnDialogFontSubst(HWND hwnd)
{
    // compile if necessary
    if (!CompileIfNecessary(FALSE))
        return;

    // if RADical window is displayed
    if (IsWindowVisible(m_rad_window))
    {
        // destroy it
        m_rad_window.DestroyWindow();
    }

    MDialogFontSubstDlg dialog;
    dialog.DialogBoxDx(hwnd);
}

// do resource test
void MMainWnd::OnTest(HWND hwnd)
{
    // compile if necessary
    if (!CompileIfNecessary(::IsWindowVisible(m_rad_window)))
        return;

    // get the selected entry
    auto entry = g_res.get_entry();
    if (!entry)
        return;

    if (entry->m_type == RT_DIALOG)
    {
        // entry->m_data --> stream --> dialog_res
        DialogRes dialog_res;
        MByteStreamEx stream(entry->m_data);
        dialog_res.LoadFromStream(stream);

        if (!dialog_res.m_class.empty())
        {
            // TODO: support the classed dialogs
            ErrorBoxDx(IDS_CANTTESTCLASSDLG);
        }
        else
        {
            // detach the dialog template menu (it will be used after)
            MIdOrString menu = dialog_res.m_menu;
            dialog_res.m_menu.clear();
            stream.clear();

            // fixup for "AtlAxWin*" and/or "{...}" window classes.
            // see also: DialogRes::FixupForTest
            dialog_res.FixupForTest(false);
            dialog_res.SaveToStream(stream);
            dialog_res.FixupForTest(true);

            // load RT_DLGINIT if any
            std::vector<BYTE> dlginit_data;
            if (auto e = g_res.find(ET_LANG, RT_DLGINIT, entry->m_name, entry->m_lang))
            {
                dlginit_data = e->m_data;
            }

            // show test dialog
            if (dialog_res.m_style & WS_CHILD)
            {
                // dialog_res is a child dialog. create its parent (with menu if any)
                auto window = new MTestParentWnd(dialog_res, menu, entry->m_lang,
                                                 stream, dlginit_data);
                window->CreateWindowDx(hwnd, LoadStringDx(IDS_PARENTWND),
                    WS_DLGFRAME | WS_POPUPWINDOW, WS_EX_APPWINDOW);

                // show it
                ShowWindow(*window, g_bNoGuiMode ? SW_HIDE : SW_SHOWNORMAL);
                UpdateWindow(*window);
            }
            else
            {
                // it's a non-child dialog. show the test dialog (with menu if any)
                MTestDialog dialog(dialog_res, menu, entry->m_lang, dlginit_data);
                dialog.DialogBoxIndirectDx(hwnd, stream.ptr());
                stream = std::move(stream);
            }
        }
    }
    else if (entry->m_type == RT_MENU)
    {
        // load a menu from memory
        HMENU hMenu = LoadMenuIndirect(&(*entry)[0]);
        if (hMenu)
        {
            // show the dialog
            MTestMenuDlg dialog(hMenu);
            dialog.DialogBoxDx(hwnd, IDD_MENUTEST);

            // unload the menu
            DestroyMenu(hMenu);
        }
    }
}

// join the lines by '\\'
void MMainWnd::JoinLinesByBackslash(std::vector<MStringA>& lines)
{
    // join by '\\'
    for (size_t i = 0; i < lines.size(); ++i)
    {
        MStringA& line = lines[i];
        if (line.size())
        {
            if (line[line.size() - 1] == '\\')
            {
                line = line.substr(0, line.size() - 1);
                lines[i] = line + lines[i + 1];
                lines.erase(lines.begin() + (i + 1));
                --i;
            }
        }
    }
}

// delete the include guard
void MMainWnd::DeleteIncludeGuard(std::vector<MStringA>& lines)
{
    size_t k0 = -1, k1 = -1;
    MStringA name0;

    for (size_t i = 0; i < lines.size(); ++i)
    {
        MStringA& line = lines[i];
        const char *pch = mstr_skip_space(&line[0]);
        if (*pch != '#')
            continue;

        ++pch;
        pch = mstr_skip_space(pch);
        if (memcmp(pch, "ifndef", 6) == 0 && mchr_is_space(pch[6]))
        {
            // #ifndef
            pch += 6;
            const char *pch0 = pch = mstr_skip_space(pch);
            while (std::isalnum(*pch) || *pch == '_')
            {
                ++pch;
            }

            if (name0.empty())
            {
                MStringA name(pch0, pch);
                k0 = i;
                name0 = std::move(name);
            }
            else
            {
                name0.clear();
                break;
            }
        }
        else if (memcmp(pch, "if", 2) == 0)
        {
            break;
        }
        else if (memcmp(pch, "define", 6) == 0 && mchr_is_space(pch[6]))
        {
            if (name0.empty())
                break;

            // #define
            pch += 6;
            const char *pch0 = pch = mstr_skip_space(pch);
            while (std::isalnum(*pch) || *pch == '_')
            {
                ++pch;
            }
            MStringA name(pch0, pch);
            if (name0 == name)
            {
                k1 = i;
                break;
            }
        }
        else
        {
            // otherwise
            break;
        }
    }

    if (name0.empty())
        return;

    for (size_t i = lines.size(); i > 0; )
    {
        --i;
        MStringA& line = lines[i];
        const char *pch = mstr_skip_space(&line[0]);
        if (*pch != '#')
            continue;

        ++pch;
        pch = mstr_skip_space(pch);
        if (memcmp(pch, "endif", 5) == 0)
        {
            lines.erase(lines.begin() + i);
            lines.erase(lines.begin() + k1);
            lines.erase(lines.begin() + k0);
            break;
        }
        else
        {
            break;
        }
    }
}

// add the head comments
void MMainWnd::AddHeadComment(std::vector<MStringA>& lines)
{
    if (m_szFile[0])
    {
        WCHAR title[64];
        GetFileTitleW(m_szFile, title, _countof(title));
        MStringA line = "// ";
        line += MWideToAnsi(CP_ACP, title).c_str();
        lines.insert(lines.begin(), line);
    }
    lines.insert(lines.begin(), "// Microsoft Visual C++ Compatible");
    lines.insert(lines.begin(), "//{{NO_DEPENDENCIES}}");
}

// delete the head comments
void MMainWnd::DeleteHeadComment(std::vector<MStringA>& lines)
{
    for (size_t i = 0; i < lines.size(); ++i)
    {
        MStringA& line = lines[i];
        if (line.find("//") == 0)
        {
            if (line.find("{{NO_DEPENDENCIES}}") != MStringA::npos ||
                line.find("Microsoft Visual C++") != MStringA::npos ||
                line.find(".rc") != MStringA::npos)
            {
                lines.erase(lines.begin() + i);
                --i;
            }
        }
    }
}

// delete the specific macro lines
void MMainWnd::DeleteSpecificMacroLines(std::vector<MStringA>& lines)
{
    for (size_t i = lines.size(); i > 0; )
    {
        --i;
        MStringA& line = lines[i];
        const char *pch = mstr_skip_space(&line[0]);
        if (*pch != '#')
            continue;

        ++pch;
        pch = mstr_skip_space(pch);
        if (memcmp(pch, "define", 6) == 0 && mchr_is_space(pch[6]))
        {
            // #define
            pch += 6;
            const char *pch0 = pch = mstr_skip_space(pch);
            while (std::isalnum(*pch) || *pch == '_')
            {
                ++pch;
            }
            MStringA name(pch0, pch);

            if (g_settings.removed_ids.find(name) != g_settings.removed_ids.end())
            {
                lines.erase(lines.begin() + i);
            }
        }
    }
}

// add additional macro lines
void MMainWnd::AddAdditionalMacroLines(std::vector<MStringA>& lines)
{
    for (auto& pair : g_settings.added_ids)
    {
        MStringA line = "#define ";
        if (pair.first == "IDC_STATIC")
        {
            line += "IDC_STATIC -1";
        }
        else
        {
            line += pair.first;
            line += " ";
            line += pair.second;
        }
        lines.push_back(line);
    }
}

// add the '#ifdef APSTUDIO_INVOKED ... #endif' block
void MMainWnd::AddApStudioBlock(std::vector<MStringA>& lines)
{
    UINT anValues[5];
    DoIDStat(anValues);

    lines.push_back("#ifdef APSTUDIO_INVOKED");
    lines.push_back("    #ifndef APSTUDIO_READONLY_SYMBOLS");

    char buf[256];
    StringCchPrintfA(buf, _countof(buf), "        #define _APS_NO_MFC                 %u", anValues[0]);
    lines.push_back(buf);
    StringCchPrintfA(buf, _countof(buf), "        #define _APS_NEXT_RESOURCE_VALUE    %u", anValues[1]);
    lines.push_back(buf);
    StringCchPrintfA(buf, _countof(buf), "        #define _APS_NEXT_COMMAND_VALUE     %u", anValues[2]);
    lines.push_back(buf);
    StringCchPrintfA(buf, _countof(buf), "        #define _APS_NEXT_CONTROL_VALUE     %u", anValues[3]);
    lines.push_back(buf);
    StringCchPrintfA(buf, _countof(buf), "        #define _APS_NEXT_SYMED_VALUE       %u", anValues[4]);
    lines.push_back(buf);
    lines.push_back("    #endif");
    lines.push_back("#endif");
}

// delete the '#ifdef APSTUDIO_INVOKED ... #endif' block
void MMainWnd::DeleteApStudioBlock(std::vector<MStringA>& lines)
{
    bool inside = false;
    size_t nest = 0;
    std::ptrdiff_t k = -1;
    for (size_t i = 0; i < lines.size(); ++i)
    {
        MStringA& line = lines[i];
        const char *pch = mstr_skip_space(&line[0]);
        if (*pch != '#')
            continue;

        ++pch;
        pch = mstr_skip_space(pch);
        if (memcmp(pch, "ifdef", 5) == 0 && mchr_is_space(pch[5]))
        {
            // #ifdef
            pch += 5;
            const char *pch0 = pch = mstr_skip_space(pch);
            while (std::isalnum(*pch) || *pch == '_')
            {
                ++pch;
            }
            MStringA name(pch0, pch);

            if (name == "APSTUDIO_INVOKED")
            {
                inside = true;
                k = i;
                ++nest;
            }
        }
        else if (memcmp(pch, "if", 2) == 0)
        {
            ++nest;
        }
        else if (memcmp(pch, "define", 6) == 0 && mchr_is_space(pch[6]))
        {
            if (!inside)
                continue;

            // #define
            pch += 6;
            const char *pch0 = pch = mstr_skip_space(pch);
            while (std::isalnum(*pch) || *pch == '_')
            {
                ++pch;
            }
        }
        else if (memcmp(pch, "endif", 5) == 0)
        {
            --nest;
            if (nest == 0 && k != -1)
            {
                lines.erase(lines.begin() + k, lines.begin() + i + 1);
                break;
            }
        }
    }
}

// helper method for MMainWnd::OnUpdateResHBang
void MMainWnd::UpdateResHLines(std::vector<MStringA>& lines)
{
    JoinLinesByBackslash(lines);
    DeleteIncludeGuard(lines);
    DeleteHeadComment(lines);
    DeleteSpecificMacroLines(lines);
    AddAdditionalMacroLines(lines);
    DeleteApStudioBlock(lines);
    AddApStudioBlock(lines);
    AddHeadComment(lines);
}

// helper method for MMainWnd::OnUpdateResHBang
void MMainWnd::ReadResHLines(FILE *fp, std::vector<MStringA>& lines)
{
    // read lines
    CHAR buf[512];
    while (fgets(buf, _countof(buf), fp) != NULL)
    {
        size_t len = std::strlen(buf);
        if (len == 0)
            break;
        if (buf[len - 1] == '\n')
            buf[len - 1] = 0;
        lines.push_back(buf);
    }
}

// do save or update the resource.h file
void MMainWnd::OnUpdateResHBang(HWND hwnd)
{
    // check whether the ID list window is open or not
    BOOL bListOpen = IsWindow(m_id_list_dlg);

    // destroy the ID list window
    DestroyWindow(m_id_list_dlg);

    // // query update to the user
    // if (MsgBoxDx(IDS_UPDATERESH, MB_ICONINFORMATION | MB_YESNO) == IDNO)    // don't update
    // {
    //     ShowIDList(hwnd, bListOpen);
    //     return;
    // }

    if (1)
    {
        // build new "resource.h" file path
        WCHAR szResH[MAX_PATH];

        if (m_szResourceH[0])
        {
            StringCchCopyW(szResH, _countof(szResH), m_szResourceH);
        }
        else if (m_szFile[0])
        {
            StringCchCopyW(szResH, _countof(szResH), m_szFile);

            WCHAR *pch = wcsrchr(szResH, L'\\');
            if (pch == NULL)
                pch = wcsrchr(szResH, L'/');
            if (pch == NULL)
                return; // failure

            *pch = 0;
            StringCchCatW(szResH, _countof(szResH), L"\\resource.h");
        }
        else
        {
            StringCchCopyW(szResH, _countof(szResH), L"resource.h");
        }

        // initialize OPENFILENAME structure
        OPENFILENAMEW ofn = { OPENFILENAME_SIZE_VERSION_400W, hwnd };
        ofn.lpstrFilter = MakeFilterDx(LoadStringDx(IDS_HEADFILTER));
        ofn.lpstrFile = szResH;
        ofn.nMaxFile = _countof(szResH);
        ofn.lpstrTitle = LoadStringDx(IDS_SAVERESH);
        ofn.Flags = OFN_ENABLESIZING | OFN_EXPLORER | OFN_HIDEREADONLY |
                    OFN_PATHMUSTEXIST | OFN_OVERWRITEPROMPT;
        ofn.lpstrDefExt = L"h";

        // let the user choose the path
        if (!GetSaveFileNameW(&ofn))
        {
            return;     // cancelled
        }

        // create new
        if (!DoWriteResH(szResH))
        {
            ErrorBoxDx(IDS_CANTWRITERESH);
            ShowIDList(hwnd, bListOpen);
            return;     // failure
        }

        // szResH --> m_szResourceH
        StringCchCopyW(m_szResourceH, _countof(m_szResourceH), szResH);
    }
    else    // update the resource.h file by modification
    {
        // do backup the resource.h file
        if (g_settings.bBackup)
            DoBackupFile(m_szResourceH);

        // open file
        FILE *fp = _wfopen(m_szResourceH, L"r");
        if (!fp)
        {
            ErrorBoxDx(IDS_CANTWRITERESH);
            ShowIDList(hwnd, bListOpen);
            return;
        }

        // read the resource.h lines
        std::vector<MStringA> lines;
        ReadResHLines(fp, lines);
        fclose(fp);     // close the files

        // modify the lines
        UpdateResHLines(lines);

        // reopen the file to write
        fp = _wfopen(m_szResourceH, L"w");
        if (!fp)
        {
            ErrorBoxDx(IDS_CANTWRITERESH);
            ShowIDList(hwnd, bListOpen);
            return;
        }

        // write now
        for (size_t i = 0; i < lines.size(); ++i)
        {
            fprintf(fp, "%s\n", lines[i].c_str());
        }

        fflush(fp);
        fclose(fp);     // close the files
    }

    // clear modification of IDs
    g_settings.added_ids.clear();
    g_settings.removed_ids.clear();

    // reopen the ID list window if necessary
    ShowIDList(hwnd, bListOpen);

    DoSetFileModified(TRUE);
}

// add an icon resource
void MMainWnd::OnAddIcon(HWND hwnd)
{
    // compile if necessary
    if (!CompileIfNecessary(FALSE))
        return;

    // show the dialog
    MAddIconDlg dialog;
    if (dialog.DialogBoxDx(hwnd) == IDOK)
    {
        // refresh the ID list window
        DoRefreshIDList(hwnd);

        // select the entry
        SelectTV(ET_LANG, dialog, FALSE);

        DoSetFileModified(TRUE);
    }
}

// replace the icon resource
void MMainWnd::OnReplaceIcon(HWND hwnd)
{
    // compile if necessary
    if (!CompileIfNecessary(FALSE))
        return;

    // get the selected language entry
    auto entry = g_res.get_lang_entry();
    if (!entry)
        return;

    // show the dialog
    MReplaceIconDlg dialog(entry);
    if (dialog.DialogBoxDx(hwnd) == IDOK)
    {
        // select the entry
        SelectTV(ET_LANG, dialog, FALSE);

        DoSetFileModified(TRUE);
    }
}

// replace the cursor resource
void MMainWnd::OnReplaceCursor(HWND hwnd)
{
    // compile if necessary
    if (!CompileIfNecessary(FALSE))
        return;

    // get the selected language entry
    auto entry = g_res.get_lang_entry();
    if (!entry)
        return;

    // show the dialog
    MReplaceCursorDlg dialog(entry);
    if (dialog.DialogBoxDx(hwnd) == IDOK)
    {
        // select the entry
        SelectTV(ET_LANG, dialog, FALSE);

        DoSetFileModified(TRUE);
    }
}

// add a bitmap resource
void MMainWnd::OnAddBitmap(HWND hwnd)
{
    // compile if necessary
    if (!CompileIfNecessary(FALSE))
        return;

    // show the dialog
    MAddBitmapDlg dialog;
    if (dialog.DialogBoxDx(hwnd) == IDOK)
    {
        // refresh the ID list window
        DoRefreshIDList(hwnd);

        // select the entry
        SelectTV(ET_LANG, dialog, FALSE);

        DoSetFileModified(TRUE);
    }
}

// replace the bitmap resource
void MMainWnd::OnReplaceBitmap(HWND hwnd)
{
    // compile if necessary
    if (!CompileIfNecessary(FALSE))
        return;

    // get the selected entry
    auto entry = g_res.get_entry();
    if (!entry)
        return;

    // show the dialog
    MReplaceBitmapDlg dialog(*entry);
    if (dialog.DialogBoxDx(hwnd) == IDOK)
    {
        // select the entry
        SelectTV(ET_LANG, dialog, FALSE);

        DoSetFileModified(TRUE);
    }
}

// add a cursor
void MMainWnd::OnAddCursor(HWND hwnd)
{
    // compile if necessary
    if (!CompileIfNecessary(FALSE))
        return;

    // show the dialog
    MAddCursorDlg dialog;
    if (dialog.DialogBoxDx(hwnd) == IDOK)
    {
        // refresh the ID list window
        DoRefreshIDList(hwnd);

        // select the entry
        SelectTV(ET_LANG, dialog, FALSE);

        DoSetFileModified(TRUE);
    }
}

// add a resource item
void MMainWnd::OnAddRes(HWND hwnd)
{
    // compile if necessary
    if (!CompileIfNecessary(FALSE))
        return;

    // show the dialog
    MAddResDlg dialog;
    if (dialog.DialogBoxDx(hwnd) == IDOK)
    {
        // add a resource item
        DoAddRes(hwnd, dialog);

        DoSetFileModified(TRUE);
    }
}

// add a menu
void MMainWnd::OnAddMenu(HWND hwnd)
{
    // compile if necessary
    if (!CompileIfNecessary(FALSE))
        return;

    // show the dialog
    MAddResDlg dialog;
    dialog.m_type = RT_MENU;
    if (dialog.DialogBoxDx(hwnd) == IDOK)
    {
        // add a resource item
        DoAddRes(hwnd, dialog);

        DoSetFileModified(TRUE);
    }
}

// add a TOOLBAR
void MMainWnd::OnAddToolbar(HWND hwnd)
{
    // compile if necessary
    if (!CompileIfNecessary(FALSE))
        return;

    // show the dialog
    MAddResDlg dialog;
    dialog.m_type = RT_TOOLBAR;
    if (dialog.DialogBoxDx(hwnd) == IDOK)
    {
        // add a resource item
        DoAddRes(hwnd, dialog);

        DoSetFileModified(TRUE);
    }
}

// add a string table
void MMainWnd::OnAddStringTable(HWND hwnd)
{
    // compile if necessary
    if (!CompileIfNecessary(FALSE))
        return;

    // show the dialog
    MAddResDlg dialog;
    dialog.m_type = RT_STRING;
    if (dialog.DialogBoxDx(hwnd) == IDOK)
    {
        // add a resource item
        DoAddRes(hwnd, dialog);

        DoSetFileModified(TRUE);
    }
}

// add a message table resource
void MMainWnd::OnAddMessageTable(HWND hwnd)
{
    // compile if necessary
    if (!CompileIfNecessary(FALSE))
        return;

    // show the dialog
    MAddResDlg dialog;
    dialog.m_type = RT_MESSAGETABLE;
    if (dialog.DialogBoxDx(hwnd) == IDOK)
    {
        // add a resource item
        DoAddRes(hwnd, dialog);

        DoSetFileModified(TRUE);
    }
}

// add an HTML resource
void MMainWnd::OnAddHtml(HWND hwnd)
{
    // compile if necessary
    if (!CompileIfNecessary(FALSE))
        return;

    // show the dialog
    MAddResDlg dialog;
    dialog.m_type = RT_HTML;
    if (dialog.DialogBoxDx(hwnd) == IDOK)
    {
        // add a resource item
        DoAddRes(hwnd, dialog);

        DoSetFileModified(TRUE);
    }
}

// add an RT_ACCELERATOR resource
void MMainWnd::OnAddAccel(HWND hwnd)
{
    // compile if necessary
    if (!CompileIfNecessary(FALSE))
        return;

    // show the dialog
    MAddResDlg dialog;
    dialog.m_type = RT_ACCELERATOR;
    if (dialog.DialogBoxDx(hwnd) == IDOK)
    {
        // add a resource item
        DoAddRes(hwnd, dialog);

        DoSetFileModified(TRUE);
    }
}

// add a version info resource
void MMainWnd::OnAddVerInfo(HWND hwnd)
{
    // compile if necessary
    if (!CompileIfNecessary(FALSE))
        return;

    // show the dialog
    MAddResDlg dialog;
    dialog.m_type = RT_VERSION;
    if (dialog.DialogBoxDx(hwnd) == IDOK)
    {
        // add a resource item
        DoAddRes(hwnd, dialog);

        DoSetFileModified(TRUE);
    }
}

// add a manifest resource
void MMainWnd::OnAddManifest(HWND hwnd)
{
    // compile if necessary
    if (!CompileIfNecessary(FALSE))
        return;

    // show the dialog
    MAddResDlg dialog;
    dialog.m_type = RT_MANIFEST;
    if (dialog.DialogBoxDx(hwnd) == IDOK)
    {
        // add a resource item
        DoAddRes(hwnd, dialog);

        DoSetFileModified(TRUE);
    }
}

// add a resource item
void MMainWnd::DoAddRes(HWND hwnd, MAddResDlg& dialog)
{
    if (dialog.m_strTemplate.empty())   // already added
    {
        // refresh the ID list window
        DoRefreshIDList(hwnd);

        // select it
        SelectTV(ET_LANG, dialog, FALSE);

        // clear the modification flag
        Edit_SetModify(m_hCodeEditor, FALSE);
    }
    else        // use dialog.m_strTemplate
    {
        // dialog.m_strTemplate --> m_hCodeEditor
        SetWindowTextW(m_hCodeEditor, dialog.m_strTemplate.c_str());
        ::SendMessageW(m_hCodeEditor, LNEM_CLEARLINEMARKS, 0, 0);

        // workaround to edit the Microsoft message table
        if (dialog.m_type == RT_MESSAGETABLE &&
            g_settings.bUseMSMSGTABLE)
        {
            g_settings.bUseMSMSGTABLE = FALSE;
        }

        // compile dialog.m_strTemplate
        MStringA strOutput;
        if (CompileParts(strOutput, dialog.m_type, dialog.m_name, dialog.m_lang, dialog.m_strTemplate, FALSE))
        {
            // success. clear the modification flag
            Edit_SetModify(m_hCodeEditor, FALSE);
            m_nStatusStringID = IDS_RECOMPILEOK;
        }
        else
        {
            // failure
            m_nStatusStringID = IDS_RECOMPILEFAILED;
            UpdateOurToolBarButtons(2);

            // set the error message
            SetErrorMessage(strOutput, TRUE);

            // set the modification flag
            Edit_SetModify(m_hCodeEditor, TRUE);

            // make it non-read-only
            Edit_SetReadOnly(m_hCodeEditor, FALSE);
        }

        // select the added entry
        if (dialog.m_type == RT_STRING)
            SelectTV(ET_STRING, dialog.m_type, (WORD)0, BAD_LANG, FALSE);
        else if (dialog.m_type == RT_MESSAGETABLE)
            SelectTV(ET_MESSAGE, dialog.m_type, (WORD)0, BAD_LANG, FALSE);
        else
            SelectTV(ET_LANG, dialog, FALSE);
   }
}

// add a dialog template
void MMainWnd::OnAddDialog(HWND hwnd)
{
    // compile if necessary
    if (!CompileIfNecessary(FALSE))
        return;

    // show the dialog
    MAddResDlg dialog;
    dialog.m_type = RT_DIALOG;
    if (dialog.DialogBoxDx(hwnd) == IDOK)
    {
        // add a resource item
        DoAddRes(hwnd, dialog);

        DoSetFileModified(TRUE);
    }
}

void MMainWnd::UpdateTitleBar()
{
    if (m_szFile[0] == 0)
    {
        SetWindowTextW(m_hwnd, LoadStringDx(IDS_APPNAME));
    }
    else if (g_settings.bShowFullPath)
    {
        // set the full file path to the title bar
        SetWindowTextW(m_hwnd, LoadStringPrintfDx(IDS_TITLEWITHFILE, m_szFile));
    }
    else
    {
        // set the file title to the title bar
        SetWindowTextW(m_hwnd, LoadStringPrintfDx(IDS_TITLEWITHFILE, PathFindFileNameW(m_szFile)));
    }
}

// set the file-related info
BOOL MMainWnd::UpdateFileInfo(FileType ft, LPCWSTR pszFile, BOOL bCompressed)
{
    m_file_type = ft;
    m_bUpxCompressed = bCompressed;

    if (pszFile == NULL || pszFile[0] == 0)
    {
        // clear the file info
        m_szFile[0] = 0;
        UpdateTitleBar();
        return TRUE;
    }

    if (m_szFile != pszFile)
    {
        // pszFile --> m_szFile (full path)
        GetFullPathNameW(pszFile, _countof(m_szFile), m_szFile, NULL);
    }

    UpdateTitleBar();

    // add to the recently used files
    g_settings.AddFile(m_szFile);

    // update the menu
    UpdateMenu();

    return TRUE;
}

// set the default settings
void MMainWnd::SetDefaultSettings(HWND hwnd)
{
    s_ui_lang = ::GetThreadUILanguage();
    g_settings.bShowBinEdit = FALSE;
    g_settings.bAlwaysControl = FALSE;
    g_settings.bShowStatusBar = TRUE;
    g_settings.nTreeViewWidth = TV_WIDTH;
    g_settings.nBmpViewWidth = BV_WIDTH;
    g_settings.bGuiByDblClick = TRUE;
    g_settings.bResumeWindowPos = TRUE;
    g_settings.bAutoLoadNearbyResH = TRUE;
    g_settings.bAutoShowIDList = TRUE;
    g_settings.bHideID = FALSE;
    g_settings.bUseIDC_STATIC = FALSE;
    g_settings.bShowDotsOnDialog = TRUE;
    g_settings.nComboHeight = 300;
    g_settings.vecRecentlyUsed.clear();
    g_settings.nWindowLeft = CW_USEDEFAULT;
    g_settings.nWindowTop = CW_USEDEFAULT;
    g_settings.nWindowWidth = 760;
    g_settings.nWindowHeight = 480;
    g_settings.bMaximized = FALSE;
    g_settings.nIDListLeft = CW_USEDEFAULT;
    g_settings.nIDListTop = CW_USEDEFAULT;
    g_settings.nIDListWidth = 366;
    g_settings.nIDListHeight = 490;
    g_settings.nRadLeft = CW_USEDEFAULT;
    g_settings.nRadTop = CW_USEDEFAULT;
    g_settings.bAskUpdateResH = FALSE;
    g_settings.bCompressByUPX = FALSE;
    g_settings.bUseBeginEnd = FALSE;
    g_settings.bShowFullPath = TRUE;
    g_settings.nDfmCodePage = 0;
    g_settings.bDfmRawTextComments = TRUE;
    g_settings.bDfmNoUnicode = FALSE;
    g_settings.bUseMSMSGTABLE = FALSE;
    g_settings.nEgaX = CW_USEDEFAULT;
    g_settings.nEgaY = CW_USEDEFAULT;
    g_settings.nEgaWidth = CW_USEDEFAULT;
    g_settings.nEgaHeight = CW_USEDEFAULT;

    HFONT hFont;
    LOGFONTW lf, lfBin, lfSrc;

    // get GUI font
    GetObject(GetStockObject(DEFAULT_GUI_FONT), sizeof(lf), &lf);

    ZeroMemory(&lfBin, sizeof(lfBin));
    lfBin.lfHeight = 10;
    lfBin.lfPitchAndFamily = FIXED_PITCH | FF_MODERN;
    lfBin.lfCharSet = lf.lfCharSet;
    hFont = CreateFontIndirectW(&lfBin);
    GetObject(hFont, sizeof(lfBin), &lfBin);
    if (HDC hDC = CreateCompatibleDC(NULL))
    {
        SelectObject(hDC, hFont);
        GetTextFace(hDC, LF_FACESIZE, lfBin.lfFaceName);
        DeleteDC(hDC);
    }
    DeleteObject(hFont);

    ZeroMemory(&lfSrc, sizeof(lfSrc));
    lfSrc.lfHeight = 13;
    lfSrc.lfPitchAndFamily = FIXED_PITCH | FF_MODERN;
    lfSrc.lfCharSet = lf.lfCharSet;
    hFont = CreateFontIndirectW(&lfSrc);
    GetObject(hFont, sizeof(lfSrc), &lfSrc);
    if (HDC hDC = CreateCompatibleDC(NULL))
    {
        SelectObject(hDC, hFont);
        GetTextFace(hDC, LF_FACESIZE, lfSrc.lfFaceName);
        DeleteDC(hDC);
    }
    DeleteObject(hFont);

    g_settings.strSrcFont = lfSrc.lfFaceName;
    g_settings.strBinFont = lfBin.lfFaceName;

    g_settings.nSrcFontSize = 12;
    g_settings.nBinFontSize = 9;

    if (HDC hDC = CreateCompatibleDC(NULL))
    {
        if (lfBin.lfHeight < 0)
        {
            g_settings.nBinFontSize = -MulDiv(lfBin.lfHeight, 72, GetDeviceCaps(hDC, LOGPIXELSY));
        }
        else
        {
            g_settings.nBinFontSize = MulDiv(lfBin.lfHeight, 72, GetDeviceCaps(hDC, LOGPIXELSY));
        }

        if (lfSrc.lfHeight < 0)
        {
            g_settings.nSrcFontSize = -MulDiv(lfSrc.lfHeight, 72, GetDeviceCaps(hDC, LOGPIXELSY));
        }
        else
        {
            g_settings.nSrcFontSize = MulDiv(lfSrc.lfHeight, 72, GetDeviceCaps(hDC, LOGPIXELSY));
        }

        DeleteDC(hDC);
    }

    auto table1 = g_db.GetTable(L"RESOURCE.ID.TYPE");
    auto table2 = g_db.GetTable(L"RESOURCE.ID.PREFIX");
    assert(table1.size() == table2.size());

    g_settings.assoc_map.clear();
    if (table1.size() && table1.size() == table2.size())
    {
        for (size_t i = 0; i < table1.size(); ++i)
        {
            g_settings.assoc_map.insert(std::make_pair(table1[i].name, table2[i].name));
        }
    }
    else
    {
        g_settings.ResetAssoc();
    }

    g_settings.id_map.clear();
    g_settings.added_ids.clear();
    g_settings.removed_ids.clear();

    g_settings.ResetMacros();

    g_settings.includes.clear();

    g_settings.strWindResExe.clear();
    g_settings.strCppExe.clear();

    // cpp.exe
    StringCchCopyW(m_szMCppExe, _countof(m_szMCppExe), m_szDataFolder);
    StringCchCatW(m_szMCppExe, _countof(m_szMCppExe), L"\\bin\\mcpp.exe");
    GetShortPathNameW(m_szMCppExe, m_szMCppExe, _countof(m_szMCppExe));

    // windres.exe
    StringCchCopyW(m_szWindresExe, _countof(m_szWindresExe), m_szDataFolder);
    StringCchCatW(m_szWindresExe, _countof(m_szWindresExe), L"\\bin\\windres.exe");
    GetShortPathNameW(m_szWindresExe, m_szWindresExe, _countof(m_szWindresExe));

    g_settings.strPrevVersion.clear();

    g_settings.bSepFilesByLang = FALSE;
    g_settings.bStoreToResFolder = TRUE;
    g_settings.bSelectableByMacro = FALSE;

    g_settings.captions.clear();

    g_settings.bShowToolBar = TRUE;
#ifdef ATL_SUPPORT
    g_settings.strAtlAxWin = TEXT(ATLAXWIN_CLASS);
#else
    g_settings.strAtlAxWin = TEXT("AtlAxWin");
#endif
    g_settings.nSaveFilterIndex = 1;
    g_settings.bWordWrap = FALSE;

    g_settings.bBackup = TRUE;
    g_settings.strBackupSuffix = L"~";

    g_settings.bRedundantComments = TRUE;
    g_settings.bWrapManifest = FALSE;

    g_settings.bRCFileUTF16 = FALSE;

    g_settings.ResetEncoding();

    g_settings.strFontReplaceFrom1 = L"MS Shell Dlg";
    g_settings.strFontReplaceTo1 = L"MS Shell Dlg";

    g_settings.strFontReplaceFrom2 = L"MS Shell Dlg 2";
    g_settings.strFontReplaceTo2 = L"MS Shell Dlg 2";

    g_settings.strFontReplaceFrom3.clear();
    g_settings.strFontReplaceTo3.clear();

    // update the menu
    UpdateMenu();
}

// update the prefix data
void MMainWnd::UpdatePrefixDB(HWND hwnd)
{
    // update "RESOURCE.ID.PREFIX" table
    auto& table = g_db.m_map[L"RESOURCE.ID.PREFIX"];
    for (size_t i = 0; i < table.size(); ++i)
    {
        for (auto& pair : g_settings.assoc_map)
        {
            if (table[i].name == pair.first)    // matched
            {
                // update the value
                table[i].value = mstr_parse_int(pair.second.c_str());
                break;
            }
        }
    }
}

// load the settings
BOOL MMainWnd::LoadSettings(HWND hwnd)
{
    SetDefaultSettings(hwnd);

#ifdef PORTABLE
    MRegKeyPortable keyRisoh(TEXT("RisohEditor"), NULL);
#else
    // open the "HKEY_CURRENT_USER\Software\Katayama Hirofumi MZ\RisohEditor" key
    MRegKey keyRisoh(HKCU, TEXT("Software\\Katayama Hirofumi MZ\\RisohEditor"));
    if (!keyRisoh)
        return FALSE;
#endif

    keyRisoh.QueryDword(TEXT("UILanguage"), (DWORD&)s_ui_lang);
    if (s_ui_lang == 0)
        s_ui_lang = GetThreadUILanguage();

    keyRisoh.QueryDword(TEXT("HIDE.ID"), (DWORD&)g_settings.bHideID);
    keyRisoh.QueryDword(TEXT("bUseIDC_STATIC"), (DWORD&)g_settings.bUseIDC_STATIC);
    keyRisoh.QueryDword(TEXT("ShowStatusBar"), (DWORD&)g_settings.bShowStatusBar);
    //keyRisoh.QueryDword(TEXT("ShowBinEdit"), (DWORD&)g_settings.bShowBinEdit);
    keyRisoh.QueryDword(TEXT("AlwaysControl"), (DWORD&)g_settings.bAlwaysControl);
    keyRisoh.QueryDword(TEXT("TreeViewWidth"), (DWORD&)g_settings.nTreeViewWidth);
    keyRisoh.QueryDword(TEXT("BmpViewWidth"), (DWORD&)g_settings.nBmpViewWidth);
    keyRisoh.QueryDword(TEXT("bGuiByDblClick"), (DWORD&)g_settings.bGuiByDblClick);
    keyRisoh.QueryDword(TEXT("bResumeWindowPos"), (DWORD&)g_settings.bResumeWindowPos);
    keyRisoh.QueryDword(TEXT("bAutoLoadNearbyResH"), (DWORD&)g_settings.bAutoLoadNearbyResH);
    keyRisoh.QueryDword(TEXT("bAutoShowIDList"), (DWORD&)g_settings.bAutoShowIDList);
    keyRisoh.QueryDword(TEXT("bShowDotsOnDialog"), (DWORD&)g_settings.bShowDotsOnDialog);
    keyRisoh.QueryDword(TEXT("nComboHeight"), (DWORD&)g_settings.nComboHeight);
    keyRisoh.QueryDword(TEXT("nWindowLeft"), (DWORD&)g_settings.nWindowLeft);
    keyRisoh.QueryDword(TEXT("nWindowTop"), (DWORD&)g_settings.nWindowTop);
    keyRisoh.QueryDword(TEXT("nWindowWidth"), (DWORD&)g_settings.nWindowWidth);
    keyRisoh.QueryDword(TEXT("nWindowHeight"), (DWORD&)g_settings.nWindowHeight);
    keyRisoh.QueryDword(TEXT("bMaximized"), (DWORD&)g_settings.bMaximized);
    keyRisoh.QueryDword(TEXT("nIDListLeft"), (DWORD&)g_settings.nIDListLeft);
    keyRisoh.QueryDword(TEXT("nIDListTop"), (DWORD&)g_settings.nIDListTop);
    keyRisoh.QueryDword(TEXT("nIDListWidth"), (DWORD&)g_settings.nIDListWidth);
    keyRisoh.QueryDword(TEXT("nIDListHeight"), (DWORD&)g_settings.nIDListHeight);
    keyRisoh.QueryDword(TEXT("nRadLeft"), (DWORD&)g_settings.nRadLeft);
    keyRisoh.QueryDword(TEXT("nRadTop"), (DWORD&)g_settings.nRadTop);
    keyRisoh.QueryDword(TEXT("bAskUpdateResH"), (DWORD&)g_settings.bAskUpdateResH);
    keyRisoh.QueryDword(TEXT("bCompressByUPX"), (DWORD&)g_settings.bCompressByUPX);
    keyRisoh.QueryDword(TEXT("bUseBeginEnd"), (DWORD&)g_settings.bUseBeginEnd);
    keyRisoh.QueryDword(TEXT("bShowFullPath"), (DWORD&)g_settings.bShowFullPath);
    keyRisoh.QueryDword(TEXT("nDfmCodePage"), (DWORD&)g_settings.nDfmCodePage);
    keyRisoh.QueryDword(TEXT("bDfmRawTextComments"), (DWORD&)g_settings.bDfmRawTextComments);
    keyRisoh.QueryDword(TEXT("bDfmNoUnicode"), (DWORD&)g_settings.bDfmNoUnicode);
    keyRisoh.QueryDword(TEXT("bUseMSMSGTABLE"), (DWORD&)g_settings.bUseMSMSGTABLE);
    keyRisoh.QueryDword(TEXT("nEgaX"), (DWORD&)g_settings.nEgaX);
    keyRisoh.QueryDword(TEXT("nEgaY"), (DWORD&)g_settings.nEgaY);
    keyRisoh.QueryDword(TEXT("nEgaWidth"), (DWORD&)g_settings.nEgaWidth);
    keyRisoh.QueryDword(TEXT("nEgaHeight"), (DWORD&)g_settings.nEgaHeight);

    TCHAR szText[128];
    TCHAR szValueName[128];

    // load the macros
    DWORD dwMacroCount = 0;
    if (keyRisoh.QueryDword(TEXT("dwMacroCount"), dwMacroCount) == ERROR_SUCCESS)
    {
        g_settings.macros.clear();

        for (DWORD i = 0; i < dwMacroCount; ++i)
        {
            MString key, value;

            StringCchPrintf(szValueName, _countof(szValueName), TEXT("MacroName%lu"), i);
            if (keyRisoh.QuerySz(szValueName, szText, _countof(szText)) == ERROR_SUCCESS)
                key = szText;

            StringCchPrintf(szValueName, _countof(szValueName), TEXT("MacroValue%lu"), i);
            if (keyRisoh.QuerySz(szValueName, szText, _countof(szText)) == ERROR_SUCCESS)
                value = szText;

            if (!key.empty())
                g_settings.macros.insert(std::make_pair(key, value));
        }
    }

    // load the includes
    DWORD dwNumIncludes = 0;
    if (keyRisoh.QueryDword(TEXT("dwNumIncludes"), dwNumIncludes) == ERROR_SUCCESS)
    {
        g_settings.includes.clear();

        for (DWORD i = 0; i < dwNumIncludes; ++i)
        {
            MString value;

            StringCchPrintf(szValueName, _countof(szValueName), TEXT("Include%lu"), i);
            if (keyRisoh.QuerySz(szValueName, szText, _countof(szText)) == ERROR_SUCCESS)
                value = szText;

            if (!value.empty())
                g_settings.includes.push_back(value);
        }
    }

    if (keyRisoh.QuerySz(TEXT("strSrcFont"), szText, _countof(szText)) == ERROR_SUCCESS)
        g_settings.strSrcFont = szText;
    keyRisoh.QueryDword(TEXT("nSrcFontSize"), (DWORD&)g_settings.nSrcFontSize);

    if (keyRisoh.QuerySz(TEXT("strBinFont"), szText, _countof(szText)) == ERROR_SUCCESS)
        g_settings.strBinFont = szText;
    keyRisoh.QueryDword(TEXT("nBinFontSize"), (DWORD&)g_settings.nBinFontSize);

    INT xVirtualScreen = GetSystemMetrics(SM_XVIRTUALSCREEN);
    INT yVirtualScreen = GetSystemMetrics(SM_YVIRTUALSCREEN);
    INT cxVirtualScreen = GetSystemMetrics(SM_CXVIRTUALSCREEN);
    INT cyVirtualScreen = GetSystemMetrics(SM_CYVIRTUALSCREEN);
    INT cxMin = 200, cyMin = 180;

    if (g_settings.nWindowLeft < xVirtualScreen)
        g_settings.nWindowLeft = CW_USEDEFAULT;
    if (g_settings.nWindowTop < yVirtualScreen)
        g_settings.nWindowTop = CW_USEDEFAULT;
    if (g_settings.nWindowWidth <= cxMin)
        g_settings.nWindowWidth = 760;
    if (g_settings.nWindowHeight <= cyMin)
        g_settings.nWindowHeight = 480;
    if (g_settings.nWindowLeft + cxMin >= xVirtualScreen + cxVirtualScreen)
        g_settings.nWindowLeft = CW_USEDEFAULT;
    if (g_settings.nWindowTop + cyMin >= yVirtualScreen + cyVirtualScreen)
        g_settings.nWindowTop = CW_USEDEFAULT;
    if (g_settings.nWindowTop == CW_USEDEFAULT)
        g_settings.nWindowLeft = CW_USEDEFAULT;

    if (g_settings.nIDListLeft < xVirtualScreen)
        g_settings.nIDListLeft = CW_USEDEFAULT;
    if (g_settings.nIDListTop < yVirtualScreen)
        g_settings.nIDListTop = CW_USEDEFAULT;
    if (g_settings.nIDListWidth <= cxMin)
        g_settings.nIDListWidth = 366;
    if (g_settings.nIDListHeight <= cyMin)
        g_settings.nIDListHeight = 490;
    if (g_settings.nIDListLeft + cxMin >= xVirtualScreen + cxVirtualScreen)
        g_settings.nIDListLeft = CW_USEDEFAULT;
    if (g_settings.nIDListTop + cyMin >= yVirtualScreen + cyVirtualScreen)
        g_settings.nIDListTop = CW_USEDEFAULT;
    if (g_settings.nIDListTop == CW_USEDEFAULT)
        g_settings.nIDListLeft = CW_USEDEFAULT;

    if (g_settings.nRadLeft < xVirtualScreen)
        g_settings.nRadLeft = CW_USEDEFAULT;
    if (g_settings.nRadTop < yVirtualScreen)
        g_settings.nRadTop = CW_USEDEFAULT;
    if (g_settings.nRadLeft + cxMin >= xVirtualScreen + cxVirtualScreen)
        g_settings.nRadLeft = CW_USEDEFAULT;
    if (g_settings.nRadTop + cyMin >= yVirtualScreen + cyVirtualScreen)
        g_settings.nRadTop = CW_USEDEFAULT;
    if (g_settings.nRadTop == CW_USEDEFAULT)
        g_settings.nRadLeft = CW_USEDEFAULT;

    DWORD i, dwCount;
    TCHAR szFormat[32], szFile[MAX_PATH];

    // load the recently used files
    keyRisoh.QueryDword(TEXT("FileCount"), dwCount);
    if (dwCount > MAX_MRU)
        dwCount = MAX_MRU;
    for (i = 0; i < dwCount; ++i)
    {
        StringCchPrintf(szFormat, _countof(szFormat), TEXT("File%lu"), i);
        if (keyRisoh.QuerySz(szFormat, szFile, _countof(szFile)) == ERROR_SUCCESS)
        {
            if (PathFileExistsW(szFile))
            {
                g_settings.vecRecentlyUsed.push_back(szFile);
            }
        }
    }

    if (keyRisoh.QuerySz(TEXT("strWindResExe"), szText, _countof(szText)) == ERROR_SUCCESS)
    {
        if (PathFileExistsW(szText))
            g_settings.strWindResExe = szText;
    }

    if (keyRisoh.QuerySz(TEXT("strCppExe"), szText, _countof(szText)) == ERROR_SUCCESS)
    {
        if (PathFileExistsW(szText))
            g_settings.strCppExe = szText;
    }

    if (keyRisoh.QuerySz(TEXT("strPrevVersion"), szText, _countof(szText)) == ERROR_SUCCESS)
    {
        g_settings.strPrevVersion = szText;
    }

    // update association if version > 3.8
    if (!g_settings.strPrevVersion.empty() && g_settings.strPrevVersion > L"3.8")
    {
        TCHAR szName[MAX_PATH];
        for (auto& pair : g_settings.assoc_map)
        {
            if (keyRisoh.QuerySz(pair.first.c_str(), szName, _countof(szName)) == ERROR_SUCCESS)
            {
                pair.second = szName;
            }
        }
        UpdatePrefixDB(hwnd);
    }

    keyRisoh.QueryDword(TEXT("bSepFilesByLang"), (DWORD&)g_settings.bSepFilesByLang);
    g_settings.bStoreToResFolder = TRUE;
    keyRisoh.QueryDword(TEXT("bSelectableByMacro"), (DWORD&)g_settings.bSelectableByMacro);

    // load the captions
    DWORD dwNumCaptions = 0;
    keyRisoh.QueryDword(TEXT("dwNumCaptions"), (DWORD&)dwNumCaptions);
    if (dwNumCaptions > s_nMaxCaptions)
        dwNumCaptions = s_nMaxCaptions;

    for (DWORD i = 0; i < dwNumCaptions; ++i)
    {
        StringCchPrintf(szValueName, _countof(szValueName), TEXT("Caption%lu"), i);
        if (keyRisoh.QuerySz(szValueName, szText, _countof(szText)) == ERROR_SUCCESS)
        {
            g_settings.captions.push_back(szText);
        }
    }

    keyRisoh.QueryDword(TEXT("bShowToolBar"), (DWORD&)g_settings.bShowToolBar);

    if (keyRisoh.QuerySz(L"strAtlAxWin", szText, _countof(szText)) == ERROR_SUCCESS)
    {
        g_settings.strAtlAxWin = szText;
    }

    keyRisoh.QueryDword(TEXT("nSaveFilterIndex"), (DWORD&)g_settings.nSaveFilterIndex);
    keyRisoh.QueryDword(TEXT("bWordWrap"), (DWORD&)g_settings.bWordWrap);
    keyRisoh.QueryDword(TEXT("RCFileUTF16"), (DWORD&)g_settings.bRCFileUTF16);

    keyRisoh.QueryDword(TEXT("bBackup"), (DWORD&)g_settings.bBackup);

    if (keyRisoh.QuerySz(L"strBackupSuffix", szText, _countof(szText)) == ERROR_SUCCESS)
    {
        g_settings.strBackupSuffix = szText;
    }

    keyRisoh.QueryDword(TEXT("bRedundantComments"), (DWORD&)g_settings.bRedundantComments);
    keyRisoh.QueryDword(TEXT("bWrapManifest"), (DWORD&)g_settings.bWrapManifest);

    DWORD encoding_count = 0;
    if (keyRisoh.QueryDword(TEXT("encoding_count"), (DWORD&)encoding_count) == ERROR_SUCCESS)
    {
        g_settings.encoding_map.clear();
        for (DWORD i = 0; i < encoding_count; ++i)
        {
            WCHAR szName[32];
            StringCchPrintfW(szName, _countof(szName), L"encoding%lu", i);
            if (keyRisoh.QuerySz(szName, szText, _countof(szText)) == ERROR_SUCCESS)
            {
                if (LPWSTR pch = wcschr(szText, L':'))
                {
                    *pch = 0;
                    ++pch;
                    ::CharLowerW(pch);
                    if (lstrcmpW(pch, L"ansi") == 0 ||
                        lstrcmpW(pch, L"wide") == 0 ||
                        lstrcmpW(pch, L"utf8") == 0 ||
                        lstrcmpW(pch, L"utf8n") == 0 ||
                        lstrcmpW(pch, L"sjis") == 0)
                    {
                        g_settings.encoding_map[szText] = pch;
                    }
                }
            }
        }
    }

    std::wstring strFrom;

    if (keyRisoh.QuerySz(TEXT("FontReplaceFrom1"), szText, _countof(szText)) == ERROR_SUCCESS)
    {
        strFrom = szText;
        if (keyRisoh.QuerySz(TEXT("FontReplaceTo1"), szText, _countof(szText)) == ERROR_SUCCESS)
        {
            g_settings.strFontReplaceFrom1 = strFrom;
            g_settings.strFontReplaceTo1 = szText;
        }
    }

    if (keyRisoh.QuerySz(TEXT("FontReplaceFrom2"), szText, _countof(szText)) == ERROR_SUCCESS)
    {
        strFrom = szText;
        if (keyRisoh.QuerySz(TEXT("FontReplaceTo2"), szText, _countof(szText)) == ERROR_SUCCESS)
        {
            g_settings.strFontReplaceFrom2 = strFrom;
            g_settings.strFontReplaceTo2 = szText;
        }
    }

    if (keyRisoh.QuerySz(TEXT("FontReplaceFrom3"), szText, _countof(szText)) == ERROR_SUCCESS)
    {
        strFrom = szText;
        if (keyRisoh.QuerySz(TEXT("FontReplaceTo3"), szText, _countof(szText)) == ERROR_SUCCESS)
        {
            g_settings.strFontReplaceFrom3 = std::move(strFrom);
            g_settings.strFontReplaceTo3 = szText;
        }
    }

    // update the menu
    UpdateMenu();

    return TRUE;
}

// save the settings
BOOL MMainWnd::SaveSettings(HWND hwnd)
{
#ifdef PORTABLE
    MRegKeyPortable keyRisoh(TEXT("RisohEditor"), NULL);
#else
    // open HKEY_CURRENT_USER\Software
    MRegKey key(HKCU, TEXT("Software"), TRUE);
    if (!key)
        return FALSE;

    // create HKEY_CURRENT_USER\Software\Katayama Hirofumi MZ
    MRegKey keySoftware(key, TEXT("Katayama Hirofumi MZ"), TRUE);
    if (!keySoftware)
        return FALSE;

    // create HKEY_CURRENT_USER\Software\Katayama Hirofumi MZ\RisohEditor
    MRegKey keyRisoh(keySoftware, TEXT("RisohEditor"), TRUE);
    if (!keyRisoh)
        return FALSE;
#endif

    // update pane extent settings
    if (m_splitter2.GetPaneCount() >= 2)
        g_settings.nBmpViewWidth = m_splitter2.GetPaneExtent(1);
    if (m_splitter1.GetPaneCount() >= 2)
        g_settings.nTreeViewWidth = m_splitter1.GetPaneExtent(0);

    keyRisoh.SetDword(TEXT("UILanguage"), s_ui_lang);
    keyRisoh.SetDword(TEXT("HIDE.ID"), g_settings.bHideID);
    keyRisoh.SetDword(TEXT("bUseIDC_STATIC"), g_settings.bUseIDC_STATIC);
    keyRisoh.SetDword(TEXT("ShowStatusBar"), g_settings.bShowStatusBar);
    //keyRisoh.SetDword(TEXT("ShowBinEdit"), g_settings.bShowBinEdit);
    keyRisoh.SetDword(TEXT("AlwaysControl"), g_settings.bAlwaysControl);
    keyRisoh.SetDword(TEXT("TreeViewWidth"), g_settings.nTreeViewWidth);
    keyRisoh.SetDword(TEXT("BmpViewWidth"), g_settings.nBmpViewWidth);
    keyRisoh.SetDword(TEXT("bGuiByDblClick"), g_settings.bGuiByDblClick);
    keyRisoh.SetDword(TEXT("bResumeWindowPos"), g_settings.bResumeWindowPos);
    keyRisoh.SetDword(TEXT("bAutoLoadNearbyResH"), g_settings.bAutoLoadNearbyResH);
    keyRisoh.SetDword(TEXT("bAutoShowIDList"), g_settings.bAutoShowIDList);
    keyRisoh.SetDword(TEXT("bShowDotsOnDialog"), g_settings.bShowDotsOnDialog);
    keyRisoh.SetDword(TEXT("nComboHeight"), g_settings.nComboHeight);
    keyRisoh.SetDword(TEXT("nWindowLeft"), g_settings.nWindowLeft);
    keyRisoh.SetDword(TEXT("nWindowTop"), g_settings.nWindowTop);
    keyRisoh.SetDword(TEXT("nWindowWidth"), g_settings.nWindowWidth);
    keyRisoh.SetDword(TEXT("nWindowHeight"), g_settings.nWindowHeight);
    keyRisoh.SetDword(TEXT("bMaximized"), g_settings.bMaximized);
    keyRisoh.SetDword(TEXT("nIDListLeft"), g_settings.nIDListLeft);
    keyRisoh.SetDword(TEXT("nIDListTop"), g_settings.nIDListTop);
    keyRisoh.SetDword(TEXT("nIDListWidth"), g_settings.nIDListWidth);
    keyRisoh.SetDword(TEXT("nIDListHeight"), g_settings.nIDListHeight);
    keyRisoh.SetDword(TEXT("nRadLeft"), g_settings.nRadLeft);
    keyRisoh.SetDword(TEXT("nRadTop"), g_settings.nRadTop);
    keyRisoh.SetDword(TEXT("bAskUpdateResH"), g_settings.bAskUpdateResH);
    keyRisoh.SetDword(TEXT("bCompressByUPX"), g_settings.bCompressByUPX);
    keyRisoh.SetDword(TEXT("bUseBeginEnd"), g_settings.bUseBeginEnd);
    keyRisoh.SetDword(TEXT("bShowFullPath"), g_settings.bShowFullPath);
    keyRisoh.SetDword(TEXT("nDfmCodePage"), g_settings.nDfmCodePage);
    keyRisoh.SetDword(TEXT("bDfmRawTextComments"), g_settings.bDfmRawTextComments);
    keyRisoh.SetDword(TEXT("bDfmNoUnicode"), g_settings.bDfmNoUnicode);
    keyRisoh.SetDword(TEXT("bUseMSMSGTABLE"), g_settings.bUseMSMSGTABLE);
    keyRisoh.SetDword(TEXT("nEgaX"), g_settings.nEgaX);
    keyRisoh.SetDword(TEXT("nEgaY"), g_settings.nEgaY);
    keyRisoh.SetDword(TEXT("nEgaWidth"), g_settings.nEgaWidth);
    keyRisoh.SetDword(TEXT("nEgaHeight"), g_settings.nEgaHeight);
    keyRisoh.SetSz(TEXT("strSrcFont"), g_settings.strSrcFont.c_str());
    keyRisoh.SetDword(TEXT("nSrcFontSize"), g_settings.nSrcFontSize);
    keyRisoh.SetSz(TEXT("strBinFont"), g_settings.strBinFont.c_str());
    keyRisoh.SetDword(TEXT("nBinFontSize"), g_settings.nBinFontSize);

    DWORD i, dwCount;

    // save the recently used files
    dwCount = (DWORD)g_settings.vecRecentlyUsed.size();
    if (dwCount > MAX_MRU)
        dwCount = MAX_MRU;
    keyRisoh.SetDword(TEXT("FileCount"), dwCount);
    TCHAR szValueName[128];
    for (i = 0; i < dwCount; ++i)
    {
        StringCchPrintf(szValueName, _countof(szValueName), TEXT("File%lu"), i);
        keyRisoh.SetSz(szValueName, g_settings.vecRecentlyUsed[i].c_str());
    }

    // save the ID association mapping
    for (auto& pair : g_settings.assoc_map)
    {
        keyRisoh.SetSz(pair.first.c_str(), pair.second.c_str());
        //MessageBoxW(NULL, pair.first.c_str(), pair.second.c_str(), 0);
    }

    // save the macros
    DWORD dwMacroCount = DWORD(g_settings.macros.size());
    keyRisoh.SetDword(TEXT("dwMacroCount"), dwMacroCount);
    i = 0;
    for (auto& macro : g_settings.macros)
    {
        StringCchPrintf(szValueName, _countof(szValueName), TEXT("MacroName%lu"), i);
        keyRisoh.SetSz(szValueName, macro.first.c_str());

        StringCchPrintf(szValueName, _countof(szValueName), TEXT("MacroValue%lu"), i);
        keyRisoh.SetSz(szValueName, macro.second.c_str());
        ++i;
    }

    // save the includes
    DWORD dwNumIncludes = DWORD(g_settings.includes.size());
    keyRisoh.SetDword(TEXT("dwNumIncludes"), dwNumIncludes);
    i = 0;
    for (auto& strInclude : g_settings.includes)
    {
        StringCchPrintf(szValueName, _countof(szValueName), TEXT("Include%lu"), i);
        keyRisoh.SetSz(szValueName, strInclude.c_str());
        ++i;
    }

    keyRisoh.SetSz(TEXT("strWindResExe"), g_settings.strWindResExe.c_str());
    keyRisoh.SetSz(TEXT("strCppExe"), g_settings.strCppExe.c_str());

    // always use old style
    keyRisoh.SetDword(TEXT("bOldStyle"), TRUE);

    keyRisoh.SetSz(TEXT("strPrevVersion"), GetRisohEditorVersion().c_str());

    keyRisoh.SetDword(TEXT("bSepFilesByLang"), g_settings.bSepFilesByLang);
    keyRisoh.SetDword(TEXT("bStoreToResFolder"), TRUE);
    keyRisoh.SetDword(TEXT("bSelectableByMacro"), g_settings.bSelectableByMacro);

    // save the captions
    DWORD dwNumCaptions = DWORD(g_settings.captions.size());
    if (dwNumCaptions > s_nMaxCaptions)
        dwNumCaptions = s_nMaxCaptions;
    keyRisoh.SetDword(TEXT("dwNumCaptions"), dwNumCaptions);
    for (DWORD i = 0; i < dwNumCaptions; ++i)
    {
        StringCchPrintf(szValueName, _countof(szValueName), TEXT("Caption%lu"), i);
        keyRisoh.SetSz(szValueName, g_settings.captions[i].c_str());
    }

    keyRisoh.SetDword(TEXT("bShowToolBar"), g_settings.bShowToolBar);
    keyRisoh.SetSz(L"strAtlAxWin", g_settings.strAtlAxWin.c_str());
    keyRisoh.SetDword(TEXT("nSaveFilterIndex"), g_settings.nSaveFilterIndex);
    keyRisoh.SetDword(TEXT("bWordWrap"), g_settings.bWordWrap);
    keyRisoh.SetDword(TEXT("RCFileUTF16"), g_settings.bRCFileUTF16);

    keyRisoh.SetDword(TEXT("bBackup"), g_settings.bBackup);

    keyRisoh.SetSz(TEXT("strBackupSuffix"), GetRisohEditorVersion().c_str());
    keyRisoh.SetSz(L"strBackupSuffix", g_settings.strBackupSuffix.c_str());

    keyRisoh.SetDword(TEXT("bRedundantComments"), g_settings.bRedundantComments);
    keyRisoh.SetDword(TEXT("bWrapManifest"), g_settings.bWrapManifest);

    DWORD encoding_count = DWORD(g_settings.encoding_map.size());
    keyRisoh.SetDword(TEXT("encoding_count"), encoding_count);
    {
        DWORD i = 0;
        for (auto pair : g_settings.encoding_map)
        {
            WCHAR szName[32];
            StringCchPrintfW(szName, _countof(szName), L"encoding%lu", i);

            WCHAR szText[64];
            StringCchPrintfW(szText, _countof(szText), L"%s:%s", pair.first.c_str(), pair.second.c_str());

            keyRisoh.SetSz(szName, szText);

            ++i;
        }
    }

    keyRisoh.SetSz(TEXT("FontReplaceFrom1"), g_settings.strFontReplaceFrom1.c_str());
    keyRisoh.SetSz(TEXT("FontReplaceTo1"), g_settings.strFontReplaceTo1.c_str());

    keyRisoh.SetSz(TEXT("FontReplaceFrom2"), g_settings.strFontReplaceFrom2.c_str());
    keyRisoh.SetSz(TEXT("FontReplaceTo2"), g_settings.strFontReplaceTo2.c_str());

    keyRisoh.SetSz(TEXT("FontReplaceFrom3"), g_settings.strFontReplaceFrom3.c_str());
    keyRisoh.SetSz(TEXT("FontReplaceTo3"), g_settings.strFontReplaceTo3.c_str());

    return TRUE;
}

BOOL MMainWnd::ReCreateSrcEdit(HWND hwnd)
{
    BOOL bModify = Edit_GetModify(m_hCodeEditor);

    if (IsWindow(m_hCodeEditor))
        DestroyWindow(m_hCodeEditor);

    DWORD style = WS_CHILD | WS_VISIBLE | WS_VSCROLL | WS_TABSTOP |
                  ES_AUTOVSCROLL | ES_LEFT | ES_MULTILINE |
                  ES_NOHIDESEL | ES_READONLY | ES_WANTRETURN;
    if (!g_settings.bWordWrap)
    {
        style |= WS_HSCROLL | ES_AUTOHSCROLL;
    }

    WNDCLASSEXW wcx;
    BOOL bLineNumEdit = ::GetClassInfoExW(NULL, L"LineNumEdit", &wcx);

    DWORD exstyle = WS_EX_CLIENTEDGE;
    HWND hSrcEdit = ::CreateWindowEx(exstyle,
        (bLineNumEdit ? L"LineNumEdit" : L"EDIT"), NULL,
        style, 0, 0, 1, 1, m_splitter2,
        (HMENU)(INT_PTR)2, GetModuleHandle(NULL), NULL);
    if (hSrcEdit)
    {
        m_hCodeEditor = hSrcEdit;
        SendMessage(m_hCodeEditor, EM_SETLIMITTEXT, 0x100000, 0);
        SendMessage(m_hCodeEditor, LNEM_SETNUMOFDIGITS, 3, 0);
        SendMessage(m_hCodeEditor, EM_SETMARGINS, EC_LEFTMARGIN | EC_RIGHTMARGIN, MAKELONG(3, 3));
        Edit_SetModify(m_hCodeEditor, bModify);
        return TRUE;
    }
    return FALSE;
}

static WNDPROC s_fnTreeViewOldWndProc = NULL;

LRESULT CALLBACK
TreeViewWndProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    MMainWnd *this_ = (MMainWnd *)GetWindowLongPtr(hwnd, GWLP_USERDATA);
    return this_->TreeViewWndProcDx(hwnd, uMsg, wParam, lParam);
}

LRESULT CALLBACK
MMainWnd::TreeViewWndProcDx(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    LRESULT ret;
    switch (uMsg)
    {
    case WM_SIZE: case WM_HSCROLL: case WM_VSCROLL:
    case WM_MOUSEWHEEL: case WM_KEYDOWN: case WM_CHAR:
        if (IsWindow(m_arrow))
        {
            // hide language arrow
            ShowLangArrow(FALSE);

            // get selected item rect
            RECT rc;
            HTREEITEM hItem = TreeView_GetSelection(hwnd);
            TreeView_GetItemRect(hwnd, hItem, &rc, FALSE);

            // default processing
            ret = CallWindowProc(s_fnTreeViewOldWndProc, hwnd, uMsg, wParam, lParam);

            // redraw the rect
            InvalidateRect(hwnd, &rc, TRUE);

            // restore language arrow
            PostUpdateLangArrow(m_hwnd);

            return ret;
        }
        break;
    case WM_SYSKEYDOWN:
        if (wParam == VK_DOWN && IsWindow(m_arrow))
        {
            m_arrow.ShowDropDownList(m_arrow, TRUE);
            return 0;
        }
        break;
    }
    return CallWindowProc(s_fnTreeViewOldWndProc, hwnd, uMsg, wParam, lParam);
}

// WM_CREATE: the main window is to be created
BOOL MMainWnd::OnCreate(HWND hwnd, LPCREATESTRUCT lpCreateStruct)
{
    MWaitCursor wait;

    m_id_list_dlg.m_hMainWnd = hwnd;    // set the main window to the ID list window

    s_hMainWnd = hwnd;
    m_nShowMode = SHOW_CODEONLY;

    DoLoadLangInfo();   // load the language information

    // check the data
    INT nRet = CheckData();
    if (nRet)
        return FALSE;   // failure

    // load the RisohEditor settings
    LoadSettings(hwnd);

    if (g_settings.bResumeWindowPos)
    {
        // resume the main window pos
        if (g_settings.nWindowLeft != CW_USEDEFAULT)
        {
            POINT pt = { g_settings.nWindowLeft, g_settings.nWindowTop };
            SetWindowPosDx(&pt);
        }
        if (g_settings.nWindowWidth != CW_USEDEFAULT)
        {
            SIZE siz = { g_settings.nWindowWidth, g_settings.nWindowHeight };
            SetWindowPosDx(NULL, &siz);
        }
    }

    // create the image list for treeview
    m_hImageList = ImageList_Create(16, 16, ILC_COLOR32 | ILC_MASK, 3, 1);
    if (m_hImageList == NULL)
        return FALSE;

    // load some icons
    m_hFileIcon = LoadSmallIconDx(IDI_FILE);        // load a file icon
    m_hFolderIcon = LoadSmallIconDx(IDI_FOLDER);    // load a folder icon

    // add these icons
    ImageList_AddIcon(m_hImageList, m_hFileIcon);
    ImageList_AddIcon(m_hImageList, m_hFolderIcon);

    // create the tool image list for toolbar
    m_himlTools = (HIMAGELIST)ImageList_LoadBitmap(m_hInst, MAKEINTRESOURCE(IDB_TOOLBAR),
                                                   32, 8, RGB(255, 0, 255));
    if (m_himlTools == NULL)
    {
        DWORD dwError = GetLastError();
        DebugPrintDx(L"GetLastError(): %ld\n", dwError);
        return FALSE;
    }

    // create the toolbar
    if (!CreateOurToolBar(hwnd, m_himlTools))
    {
        return FALSE;
    }

    DWORD style, exstyle;

    // create the splitter windows
    style = WS_CHILD | WS_VISIBLE | SWS_HORZ | SWS_LEFTALIGN;
    if (!m_splitter1.CreateDx(hwnd, 2, style))
        return FALSE;

    style = WS_CHILD | WS_VISIBLE | WS_BORDER | TCS_BOTTOM | TCS_TABS | TCS_TOOLTIPS |
            TCS_FOCUSNEVER | TCS_HOTTRACK | TCS_MULTILINE;
    if (!m_tab.CreateWindowDx(m_splitter1, NULL, style))
        return FALSE;
    SetWindowFont(m_tab, GetStockFont(DEFAULT_GUI_FONT), TRUE);

    m_tab.InsertItem(0, LoadStringDx(IDS_CODEEDITOR));
    m_tab.InsertItem(1, LoadStringDx(IDS_HEXVIEWER));
    m_tab.SetCurSel(0);

    style = WS_CHILD | WS_VISIBLE | SWS_HORZ | SWS_RIGHTALIGN;
    if (!m_splitter2.CreateDx(m_splitter1, 1, style))
        return FALSE;

    // create a treeview (tree control) window
    style = WS_CHILD | WS_VISIBLE | WS_HSCROLL | WS_VSCROLL | WS_TABSTOP |
        TVS_DISABLEDRAGDROP | TVS_HASBUTTONS | TVS_LINESATROOT |
        TVS_SHOWSELALWAYS | TVS_EDITLABELS | TVS_FULLROWSELECT | TVS_INFOTIP;
    m_hwndTV = CreateWindowExW(WS_EX_CLIENTEDGE,
        WC_TREEVIEWW, NULL, style, 0, 0, 0, 0, m_splitter1,
        (HMENU)1, m_hInst, NULL);
    if (m_hwndTV == NULL)
        return FALSE;

    SetWindowLongPtr(m_hwndTV, GWLP_USERDATA, (LONG_PTR)this);
    s_fnTreeViewOldWndProc = (WNDPROC)SetWindowLongPtrW(m_hwndTV, GWLP_WNDPROC, (LONG_PTR)TreeViewWndProc);

    // store the treeview handl to g_res (important!)
    g_res.m_hwndTV = m_hwndTV;

    if (s_pSetWindowTheme)
    {
        // apply Explorer's visual style
        (*s_pSetWindowTheme)(m_hwndTV, L"Explorer", NULL);
    }

    // set the imagelists to treeview
    TreeView_SetImageList(m_hwndTV, m_hImageList, TVSIL_NORMAL);

    // create the binary EDIT control
    style = WS_CHILD | WS_VISIBLE | WS_HSCROLL | WS_VSCROLL | WS_TABSTOP |
        ES_AUTOVSCROLL | ES_LEFT | ES_MULTILINE |
        ES_NOHIDESEL | ES_READONLY | ES_WANTRETURN;
    exstyle = WS_EX_CLIENTEDGE;
    m_hHexViewer.CreateAsChildDx(m_splitter2, NULL, style, exstyle, 3);
    m_hHexViewer.SendMessageDx(EM_SETLIMITTEXT, 0x100000);

    // create source EDIT control
    if (!ReCreateSrcEdit(m_splitter2))
        return FALSE;

    // create MBmpView
    if (!m_hBmpView.CreateDx(m_splitter2, 4))
        return FALSE;

    // create status bar
    style = WS_CHILD | WS_VISIBLE | SBARS_SIZEGRIP | CCS_BOTTOM;
    m_hStatusBar = CreateStatusWindow(style, LoadStringDx(IDS_STARTING), hwnd, 8);
    if (m_hStatusBar == NULL)
        return FALSE;

    // set the status text
    ChangeStatusText(IDS_STARTING);

    // setup the status bar
    INT anWidths[] = { -1 };
    SendMessage(m_hStatusBar, SB_SETPARTS, 1, (LPARAM)anWidths);

    // show the status bar or not
    if (g_settings.bShowStatusBar)
        ShowWindow(m_hStatusBar, SW_SHOWNOACTIVATE);
    else
        ShowWindow(m_hStatusBar, SW_HIDE);

    // set the pane contents of splitters
    m_splitter1.SetPane(0, m_hwndTV);
    m_splitter1.SetPane(1, m_tab);
    m_splitter1.SetPaneExtent(0, g_settings.nTreeViewWidth);
    m_splitter2.SetPane(0, m_hCodeEditor);

    // create the fonts
    ReCreateFonts(hwnd);

    if (m_argc >= 2)
    {
        if (!ParseCommandLine(hwnd, m_argc, m_targv))
        {
            PostMessageW(hwnd, WM_CLOSE, 0, 0);
        }
    }

    // enable file dropping
    DragAcceptFiles(hwnd, TRUE);

    // set focus to treeview
    SetFocus(m_hwndTV);

    // update the menu
    UpdateMenu();

    // store the file paths from settings
    if (g_settings.strWindResExe.size())
    {
        StringCchCopy(m_szWindresExe, _countof(m_szWindresExe), g_settings.strWindResExe.c_str());
        GetShortPathNameW(m_szWindresExe, m_szWindresExe, _countof(m_szWindresExe));
    }
    if (g_settings.strCppExe.size())
    {
        StringCchCopy(m_szMCppExe, _countof(m_szMCppExe), g_settings.strCppExe.c_str());
        GetShortPathNameW(m_szMCppExe, m_szMCppExe, _countof(m_szMCppExe));
    }

    // OK, ready
    PostMessageDx(WM_COMMAND, ID_READY);

    return TRUE;    // success
}

// the window procedure of the main window
/*virtual*/ LRESULT CALLBACK
MMainWnd::WindowProcDx(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    switch (uMsg)
    {
        DO_MSG(WM_CREATE, OnCreate);
        DO_MSG(WM_COMMAND, OnCommand);
        DO_MSG(WM_CLOSE, OnClose);
        DO_MSG(WM_DESTROY, OnDestroy);
        DO_MSG(WM_DROPFILES, OnDropFiles);
        DO_MSG(WM_MOVE, OnMove);
        DO_MSG(WM_SIZE, OnSize);
        DO_MSG(WM_NOTIFY, OnNotify);
        DO_MSG(WM_CONTEXTMENU, OnContextMenu);
        DO_MSG(WM_INITMENU, OnInitMenu);
        DO_MSG(WM_ACTIVATE, OnActivate);
        DO_MSG(WM_SYSCOLORCHANGE, OnSysColorChange);
        DO_MSG(WM_SETFOCUS, OnSetFocus);
        DO_MSG(WM_KILLFOCUS, OnKillFocus);
        DO_MESSAGE(MYWM_CLEARSTATUS, OnClearStatus);
        DO_MESSAGE(MYWM_MOVESIZEREPORT, OnMoveSizeReport);
        DO_MESSAGE(MYWM_COMPILECHECK, OnCompileCheck);
        DO_MESSAGE(MYWM_REOPENRAD, OnReopenRad);
        DO_MESSAGE(MYWM_IDJUMPBANG, OnIDJumpBang);
        DO_MESSAGE(MYWM_SELCHANGE, OnRadSelChange);
        DO_MESSAGE(MYWM_UPDATEDLGRES, OnUpdateDlgRes);
        DO_MESSAGE(MYWM_GETDLGHEADLINES, OnGetHeadLines);
        DO_MESSAGE(MYWM_DELPHI_DFM_B2T, OnDelphiDFMB2T);
        DO_MESSAGE(MYWM_TLB_B2T, OnTLB2IDL);
        DO_MESSAGE(MYWM_ITEMSEARCH, OnItemSearchBang);
        DO_MESSAGE(MYWM_COMPLEMENT, OnComplement);
        DO_MESSAGE(MYWM_UPDATELANGARROW, OnUpdateLangArrow);
        DO_MESSAGE(MYWM_RADDBLCLICK, OnRadDblClick);

    default:
        return DefaultProcDx();
    }
}

// select the string entry in the tree control
void MMainWnd::SelectString(void)
{
    // find the string entry
    if (auto entry = g_res.find(ET_STRING, RT_STRING))
    {
        // select the entry
        SelectTV(entry, FALSE);
    }
}

// select the message entry in the tree control
void MMainWnd::SelectMessage()
{
    // find the message table entry
    if (auto entry = g_res.find(ET_MESSAGE, RT_MESSAGETABLE))
    {
        // select the entry
        SelectTV(entry, FALSE);
    }
}

// do ID jump now!
void MMainWnd::OnIDJumpBang2(HWND hwnd, const MString& name, MString& strType)
{
    if (strType == L"Unknown.ID")
        return;     // ignore Unknown.ID jump

    // revert the resource type string
    Res_ReplaceResTypeString(strType, true);

    // get the prefix
    MString prefix = name.substr(0, name.find(L'_') + 1);

    // get the IDTYPE_'s from the prefix
    auto indexes = GetPrefixIndexes(prefix);
    for (size_t i = 0; i < indexes.size(); ++i)
    {
        INT nIDTYPE_ = indexes[i];
        if (nIDTYPE_ == IDTYPE_STRING || nIDTYPE_ == IDTYPE_PROMPT)
        {
            // select the string entry
            SelectString();
            return;     // done
        }
        if (nIDTYPE_ == IDTYPE_MESSAGE)
        {
            // select the message entry
            SelectMessage();
            return;     // done
        }
    }

    // get the type value
    MIdOrString type = WORD(g_db.GetValue(L"RESOURCE", strType));
    if (type.empty())
        type.m_str = strType;

    // name --> name_or_id
    MIdOrString name_or_id;
    if (name[0] == L'\"')
    {
        // non-numeric name
        MString name_clone = name;
        mstr_unquote(name_clone);   // unquote
        name_or_id = name_clone.c_str();
    }
    else
    {
        // numeric name
        name_or_id = WORD(g_db.GetResIDValue(name));
    }

    if (name_or_id.empty())  // name_or_id was empty
    {
        // name --> strA (ANSI)
        MStringA strA = MTextToAnsi(CP_ACP, name).c_str();

        // find strA from g_settings.id_map
        auto it = g_settings.id_map.find(strA);
        if (it != g_settings.id_map.end())  // found
        {
            MStringA strA = it->second;
            if (strA[0] == 'L')
                strA = strA.substr(1);

            // unquote
            mstr_unquote(strA);

            // resource name
            name_or_id.m_str = MAnsiToWide(CP_ACP, strA).c_str();
        }
    }

    // find the entry
    if (auto entry = g_res.find(ET_LANG, type, name_or_id))
    {
        // select the entry
        SelectTV(entry, FALSE);

        // set focus to the main window
        SetForegroundWindow(m_hwnd);
        BringWindowToTop(m_hwnd);
        SetFocus(m_hwnd);
    }
}

// MYWM_TLB_B2T
LRESULT MMainWnd::OnTLB2IDL(HWND hwnd, WPARAM wParam, LPARAM lParam)
{
    auto& str = *(MString *)wParam;
    auto& entry = *(const EntryBase *)lParam;

    std::string ansi;
    ansi = tlb_text_from_binary(m_szOleBow, entry.ptr(), entry.size());
    MAnsiToWide a2w(CP_UTF8, ansi);
    str = a2w.c_str();
    return 0;
}

// MYWM_DELPHI_DFM_B2T
LRESULT MMainWnd::OnDelphiDFMB2T(HWND hwnd, WPARAM wParam, LPARAM lParam)
{
    auto& str = *(MString *)wParam;
    auto& entry = *(const EntryBase *)lParam;

    auto ansi = dfm_text_from_binary(m_szDFMSC, entry.ptr(), entry.size(),
                                     g_settings.nDfmCodePage, g_settings.bDfmRawTextComments);
    MAnsiToWide a2w(CP_UTF8, ansi);
    str = a2w.c_str();
    return 0;
}

LRESULT MMainWnd::OnGetHeadLines(HWND hwnd, WPARAM wParam, LPARAM lParam)
{
    // get the selected entry
    auto entry = g_res.get_lang_entry();
    if (!entry)
        return -1;

    if (entry->m_type == RT_DIALOG)
    {
        DialogRes dialog_res;
        MByteStreamEx stream(entry->m_data);
        dialog_res.LoadFromStream(stream);
        return dialog_res.GetHeadLines();
    }
    return -1;
}

LRESULT MMainWnd::OnUpdateDlgRes(HWND hwnd, WPARAM wParam, LPARAM lParam)
{
    DoSetFileModified(TRUE);

    // get the selected language entry
    auto entry = g_res.get_lang_entry();
    if (!entry || entry->m_type != RT_DIALOG)
    {
        return 0;
    }

    auto& dialog_res = m_rad_window.m_dialog_res;

    // dialog_res --> entry->m_data
    MByteStreamEx stream;
    dialog_res.SaveToStream(stream);
    entry->m_data = stream.data();

    // entry->m_lang + dialog_res --> str --> m_hCodeEditor (text)
    MString str = GetLanguageStatement(entry->m_lang);
    str += dialog_res.Dump(entry->m_name);
    SetWindowTextW(m_hCodeEditor, str.c_str());

    // entry->m_data --> m_hHexViewer (binary)
    str = DumpBinaryAsText(entry->m_data);
    SetWindowTextW(m_hHexViewer, str.c_str());

    return 0;
}

LRESULT MMainWnd::OnRadSelChange(HWND hwnd, WPARAM wParam, LPARAM lParam)
{
    ::SendMessageW(m_hCodeEditor, LNEM_CLEARLINEMARKS, 0, 0);
    if (!IsWindow(m_rad_window))
        return 0;

    INT cHeads = INT(SendMessageW(hwnd, MYWM_GETDLGHEADLINES, 0, 0)) + 1;
    auto indeces = MRadCtrl::GetTargetIndeces();
    for (auto index : indeces)
    {
        ::SendMessageW(m_hCodeEditor, LNEM_SETLINEMARK, cHeads + index, RGB(255, 255, 120));
    }
    return 0;
}

// do ID jump now!
LRESULT MMainWnd::OnIDJumpBang(HWND hwnd, WPARAM wParam, LPARAM lParam)
{
    // the item index
    INT iItem = (INT)wParam;
    if (iItem == -1)
        return 0;

    // get the 1st and 2nd subitem texts
    TCHAR szText[128];
    ListView_GetItemText(m_id_list_dlg.m_hLst1, iItem, 0, szText, _countof(szText));
    MString name = szText;      // 1st is name
    ListView_GetItemText(m_id_list_dlg.m_hLst1, iItem, 1, szText, _countof(szText));
    MString strTypes = szText;  // 2nd is types

    // split the text to the types by slash
    std::vector<MString> vecTypes;
    mstr_split(vecTypes, strTypes, L"/");

    // ignore if no type
    if (vecTypes.empty() || vecTypes.size() <= size_t(lParam))
        return 0;

    // do ID jump
    OnIDJumpBang2(hwnd, name, vecTypes[lParam]);

    return 0;
}

// start up the program
BOOL MMainWnd::StartDx()
{
    // get cursors for MSplitterWnd
    MSplitterWnd::CursorNS() = LoadCursor(m_hInst, MAKEINTRESOURCE(IDC_CURSORNS));
    MSplitterWnd::CursorWE() = LoadCursor(m_hInst, MAKEINTRESOURCE(IDC_CURSORWE));

    // get the main icon
    m_hIcon = LoadIconDx(IDI_MAIN);
    m_hIconSm = LoadSmallIconDx(IDI_MAIN);

    // get the access keys
    m_hAccel = ::LoadAccelerators(m_hInst, MAKEINTRESOURCE(IDR_MAINACCEL));

    // create the main window
    if (!CreateWindowDx(NULL, MAKEINTRESOURCE(IDS_APPNAME),
        WS_OVERLAPPEDWINDOW, 0, CW_USEDEFAULT, CW_USEDEFAULT, 760, 480))
    {
        ErrorBoxDx(TEXT("failure of CreateWindow"));
        return FALSE;
    }
    assert(IsWindow(m_hwnd));

    if (!g_bNoGuiMode)
    {
        // maximize or not
        if (g_settings.bResumeWindowPos && g_settings.bMaximized)
        {
            ShowWindow(m_hwnd, SW_SHOWMAXIMIZED);
        }
        else
        {
            ShowWindow(m_hwnd, SW_SHOWNORMAL);
        }
    }

    UpdateWindow(m_hwnd);

    return TRUE;
}

// do one window message
void MMainWnd::DoEvents()
{
    MSG msg;
    if (PeekMessage(&msg, NULL, 0, 0, PM_REMOVE))
    {
        DoMsg(msg);
    }
}

static BOOL DoMsgCtrlA(MSG *pMsg)
{
    WCHAR szClass[16] = L"";
    GetClassNameW(pMsg->hwnd, szClass, _countof(szClass));

    if (lstrcmpiW(szClass, L"EDIT") == 0 || lstrcmpiW(szClass, L"LineNumEdit") == 0)
    {
        if (pMsg->message == WM_KEYDOWN)
        {
            if (pMsg->wParam == 'A' &&
                GetAsyncKeyState(VK_CONTROL) < 0 &&
                GetAsyncKeyState(VK_SHIFT) >= 0 &&
                GetAsyncKeyState(VK_MENU) >= 0)
            {
                PeekMessage(pMsg, pMsg->hwnd, WM_KEYDOWN, WM_KEYDOWN, PM_REMOVE);
                PostMessage(pMsg->hwnd, EM_SETSEL, 0, -1);
                return TRUE;
            }
        }
    }

    return FALSE;
}

// do the window messages
void MMainWnd::DoMsg(MSG& msg)
{
    // Ctrl+A on EDIT control and LineNumEdit
    if (DoMsgCtrlA(&msg))
        return;

    // do access keys
    if (IsWindow(m_hwnd))
    {
        if (::TranslateAccelerator(m_hwnd, m_hAccel, &msg))
            return;
    }

    if (IsWindow(m_arrow.m_dialog))
    {
        if (msg.message == WM_KEYDOWN)
        {
            if (m_arrow.DoComplement(m_arrow, msg.wParam))
                return;
        }
        if (::IsDialogMessage(m_arrow.m_dialog, &msg))
            return;
    }

    // do the popup windows
    if (IsWindow(m_rad_window))
    {
        if (::TranslateAccelerator(m_rad_window, m_hAccel, &msg))
            return;
    }
    if (IsWindow(m_rad_window.m_rad_dialog))
    {
        if (::TranslateAccelerator(m_rad_window.m_rad_dialog, m_hAccel, &msg))
            return;
        if (::IsDialogMessage(m_rad_window.m_rad_dialog, &msg))
            return;
    }
    if (IsWindow(m_id_list_dlg))
    {
        if (::TranslateAccelerator(m_id_list_dlg, m_hAccel, &msg))
            return;
        if (::IsDialogMessage(m_id_list_dlg, &msg))
            return;
    }

    // close the find/replace dialog if any
    if (IsWindow(m_hFindReplaceDlg))
    {
        if (::IsDialogMessage(m_hFindReplaceDlg, &msg))
            return;
    }

    // do the item search dialogs
    if (MItemSearchDlg::Dialogs().size())
    {
        BOOL bProcessed = FALSE;
        for (auto& item : MItemSearchDlg::Dialogs())
        {
            if (IsDialogMessage(*item, &msg))
            {
                bProcessed = TRUE;
                break;
            }
        }
        if (bProcessed)
            return;
    }

    // the default processing
    TranslateMessage(&msg);
    DispatchMessage(&msg);
}

// the main loop
INT_PTR MMainWnd::RunDx()
{
    MSG msg;

    while (BOOL bGot = ::GetMessage(&msg, NULL, 0, 0))
    {
        if (bGot < 0)   // fatal error
        {
            DebugPrintDx(TEXT("Application fatal error: %ld\n"), GetLastError());
            DebugBreak();
            return -1;
        }

        if (::IsWindow(s_hwndEga) && ::IsDialogMessage(s_hwndEga, &msg))
            continue;

        // do messaging
        DoMsg(msg);
    }

    return INT(msg.wParam);
}

//////////////////////////////////////////////////////////////////////////////

// get the LANGUAGE statement
MString GetLanguageStatement(WORD langid, BOOL bOldStyle)
{
    MString strPrim, strSub;

#define SWITCH_SUBLANG() switch (SUBLANGID(langid))

    // try to get the primary language name and the sub-language name
    switch (PRIMARYLANGID(langid))
    {
    case LANG_NEUTRAL: strPrim = TEXT("LANG_NEUTRAL");
        break;
    case LANG_INVARIANT: strPrim = TEXT("LANG_INVARIANT");
        break;
    case LANG_AFRIKAANS: strPrim = TEXT("LANG_AFRIKAANS");
        SWITCH_SUBLANG()
        {
        case SUBLANG_AFRIKAANS_SOUTH_AFRICA: strSub = TEXT("SUBLANG_AFRIKAANS_SOUTH_AFRICA"); break;
        }
        break;
    case LANG_ALBANIAN: strPrim = TEXT("LANG_ALBANIAN");
        SWITCH_SUBLANG()
        {
        case SUBLANG_ALBANIAN_ALBANIA: strSub = TEXT("SUBLANG_ALBANIAN_ALBANIA"); break;
        }
        break;
    case LANG_ALSATIAN: strPrim = TEXT("LANG_ALSATIAN");
        SWITCH_SUBLANG()
        {
        case SUBLANG_ALSATIAN_FRANCE: strSub = TEXT("SUBLANG_ALSATIAN_FRANCE"); break;
        }
        break;
    case LANG_AMHARIC: strPrim = TEXT("LANG_AMHARIC");
        SWITCH_SUBLANG()
        {
        case SUBLANG_AMHARIC_ETHIOPIA: strSub = TEXT("SUBLANG_AMHARIC_ETHIOPIA"); break;
        }
        break;
    case LANG_ARABIC: strPrim = TEXT("LANG_ARABIC");
        SWITCH_SUBLANG()
        {
        case SUBLANG_ARABIC_SAUDI_ARABIA: strSub = TEXT("SUBLANG_ARABIC_SAUDI_ARABIA"); break;
        case SUBLANG_ARABIC_IRAQ: strSub = TEXT("SUBLANG_ARABIC_IRAQ"); break;
        case SUBLANG_ARABIC_EGYPT: strSub = TEXT("SUBLANG_ARABIC_EGYPT"); break;
        case SUBLANG_ARABIC_LIBYA: strSub = TEXT("SUBLANG_ARABIC_LIBYA"); break;
        case SUBLANG_ARABIC_ALGERIA: strSub = TEXT("SUBLANG_ARABIC_ALGERIA"); break;
        case SUBLANG_ARABIC_MOROCCO: strSub = TEXT("SUBLANG_ARABIC_MOROCCO"); break;
        case SUBLANG_ARABIC_TUNISIA: strSub = TEXT("SUBLANG_ARABIC_TUNISIA"); break;
        case SUBLANG_ARABIC_OMAN: strSub = TEXT("SUBLANG_ARABIC_OMAN"); break;
        case SUBLANG_ARABIC_YEMEN: strSub = TEXT("SUBLANG_ARABIC_YEMEN"); break;
        case SUBLANG_ARABIC_SYRIA: strSub = TEXT("SUBLANG_ARABIC_SYRIA"); break;
        case SUBLANG_ARABIC_JORDAN: strSub = TEXT("SUBLANG_ARABIC_JORDAN"); break;
        case SUBLANG_ARABIC_LEBANON: strSub = TEXT("SUBLANG_ARABIC_LEBANON"); break;
        case SUBLANG_ARABIC_KUWAIT: strSub = TEXT("SUBLANG_ARABIC_KUWAIT"); break;
        case SUBLANG_ARABIC_UAE: strSub = TEXT("SUBLANG_ARABIC_UAE"); break;
        case SUBLANG_ARABIC_BAHRAIN: strSub = TEXT("SUBLANG_ARABIC_BAHRAIN"); break;
        case SUBLANG_ARABIC_QATAR: strSub = TEXT("SUBLANG_ARABIC_QATAR"); break;
        }
        break;
    case LANG_ARMENIAN: strPrim = TEXT("LANG_ARMENIAN");
        SWITCH_SUBLANG()
        {
        case SUBLANG_ARMENIAN_ARMENIA: strSub = TEXT("SUBLANG_ARMENIAN_ARMENIA"); break;
        }
        break;
    case LANG_ASSAMESE: strPrim = TEXT("LANG_ASSAMESE");
        SWITCH_SUBLANG()
        {
        case SUBLANG_ASSAMESE_INDIA: strSub = TEXT("SUBLANG_ASSAMESE_INDIA"); break;
        }
        break;
    case LANG_AZERI: strPrim = TEXT("LANG_AZERI");
        SWITCH_SUBLANG()
        {
        case SUBLANG_AZERI_LATIN: strSub = TEXT("SUBLANG_AZERI_LATIN"); break;
        case SUBLANG_AZERI_CYRILLIC: strSub = TEXT("SUBLANG_AZERI_CYRILLIC"); break;
        }
        break;
    //case LANG_AZERBAIJANI: strPrim = TEXT("LANG_AZERBAIJANI"); // same as LANG_AZERI
    //    SWITCH_SUBLANG()
    //    {
    //        case SUBLANG_AZERBAIJANI_AZERBAIJAN_LATIN: strSub = TEXT("SUBLANG_AZERBAIJANI_AZERBAIJAN_LATIN"); break;
    //        case SUBLANG_AZERBAIJANI_AZERBAIJAN_CYRILLIC: strSub = TEXT("SUBLANG_AZERBAIJANI_AZERBAIJAN_CYRILLIC"); break;
    //    }
    //    break;
    //case LANG_BANGLA: strPrim = TEXT("LANG_BANGLA"); // same as LANG_BENGALI
    //    SWITCH_SUBLANG()
    //    {
    //    case SUBLANG_BANGLA_INDIA: strSub = TEXT("SUBLANG_BANGLA_INDIA"); break;
    //    case SUBLANG_BANGLA_BANGLADESH: strSub = TEXT("SUBLANG_BANGLA_BANGLADESH"); break;
    //    }
    //    break;
    case LANG_BASHKIR: strPrim = TEXT("LANG_BASHKIR");
        SWITCH_SUBLANG()
        {
        case SUBLANG_BASHKIR_RUSSIA: strSub = TEXT("SUBLANG_BASHKIR_RUSSIA"); break;
        }
        break;
    case LANG_BASQUE: strPrim = TEXT("LANG_BASQUE");
        SWITCH_SUBLANG()
        {
        case SUBLANG_BASQUE_BASQUE: strSub = TEXT("SUBLANG_BASQUE_BASQUE"); break;
        }
        break;
    case LANG_BELARUSIAN: strPrim = TEXT("LANG_BELARUSIAN");
        SWITCH_SUBLANG()
        {
        case SUBLANG_BELARUSIAN_BELARUS: strSub = TEXT("SUBLANG_BELARUSIAN_BELARUS"); break;
        }
        break;
    case LANG_BENGALI: strPrim = TEXT("LANG_BENGALI");
        SWITCH_SUBLANG()
        {
            case SUBLANG_BENGALI_INDIA: strSub = TEXT("SUBLANG_BENGALI_INDIA"); break;
            case SUBLANG_BENGALI_BANGLADESH: strSub = TEXT("SUBLANG_BENGALI_BANGLADESH"); break;
        }
        break;
    case LANG_BRETON: strPrim = TEXT("LANG_BRETON");
        SWITCH_SUBLANG()
        {
        case SUBLANG_BRETON_FRANCE: strSub = TEXT("SUBLANG_BRETON_FRANCE"); break;
        }
        break;
    case LANG_BOSNIAN: strPrim = TEXT("LANG_BOSNIAN");
        SWITCH_SUBLANG()
        {
        case SUBLANG_BOSNIAN_BOSNIA_HERZEGOVINA_LATIN: strSub = TEXT("SUBLANG_BOSNIAN_BOSNIA_HERZEGOVINA_LATIN"); break;
        case SUBLANG_BOSNIAN_BOSNIA_HERZEGOVINA_CYRILLIC: strSub = TEXT("SUBLANG_BOSNIAN_BOSNIA_HERZEGOVINA_CYRILLIC"); break;
        }
        break;
    case LANG_BOSNIAN_NEUTRAL: strPrim = TEXT("LANG_BOSNIAN_NEUTRAL");
        SWITCH_SUBLANG()
        {
        case SUBLANG_BOSNIAN_BOSNIA_HERZEGOVINA_LATIN: strSub = TEXT("SUBLANG_BOSNIAN_BOSNIA_HERZEGOVINA_LATIN"); break;
        case SUBLANG_BOSNIAN_BOSNIA_HERZEGOVINA_CYRILLIC: strSub = TEXT("SUBLANG_BOSNIAN_BOSNIA_HERZEGOVINA_CYRILLIC"); break;
        }
        break;
    case LANG_BULGARIAN: strPrim = TEXT("LANG_BULGARIAN");
        SWITCH_SUBLANG()
        {
        case SUBLANG_BULGARIAN_BULGARIA: strSub = TEXT("SUBLANG_BULGARIAN_BULGARIA"); break;
        }
        break;
    case LANG_CATALAN: strPrim = TEXT("LANG_CATALAN");
        SWITCH_SUBLANG()
        {
        case SUBLANG_CATALAN_CATALAN: strSub = TEXT("SUBLANG_CATALAN_CATALAN"); break;
        }
        break;
#ifdef ENABLE_NEW_LANGS
    case LANG_CENTRAL_KURDISH: strPrim = TEXT("LANG_CENTRAL_KURDISH");
        SWITCH_SUBLANG()
        {
        case SUBLANG_CENTRAL_KURDISH_IRAQ: strSub = TEXT("SUBLANG_CENTRAL_KURDISH_IRAQ"); break;
        }
        break;
#endif
#ifdef ENABLE_NEW_LANGS
    case LANG_CHEROKEE: strPrim = TEXT("LANG_CHEROKEE");
        SWITCH_SUBLANG()
        {
        case SUBLANG_CHEROKEE_CHEROKEE: strSub = TEXT("SUBLANG_CHEROKEE_CHEROKEE"); break;
        }
        break;
#endif
    case LANG_CHINESE: strPrim = TEXT("LANG_CHINESE");
        SWITCH_SUBLANG()
        {
        case SUBLANG_CHINESE_TRADITIONAL: strSub = TEXT("SUBLANG_CHINESE_TRADITIONAL"); break;
        case SUBLANG_CHINESE_SIMPLIFIED: strSub = TEXT("SUBLANG_CHINESE_SIMPLIFIED"); break;
        case SUBLANG_CHINESE_HONGKONG: strSub = TEXT("SUBLANG_CHINESE_HONGKONG"); break;
        case SUBLANG_CHINESE_SINGAPORE: strSub = TEXT("SUBLANG_CHINESE_SINGAPORE"); break;
        case SUBLANG_CHINESE_MACAU: strSub = TEXT("SUBLANG_CHINESE_MACAU"); break;
        }
        break;
    //case LANG_CHINESE_SIMPLIFIED: strPrim = TEXT("LANG_CHINESE_SIMPLIFIED"); // same as LANG_CHINESE
    //    SWITCH_SUBLANG()
    //    {
    //        case SUBLANG_CHINESE_TRADITIONAL: strSub = TEXT("SUBLANG_CHINESE_TRADITIONAL"); break;
    //        case SUBLANG_CHINESE_SIMPLIFIED: strSub = TEXT("SUBLANG_CHINESE_SIMPLIFIED"); break;
    //        case SUBLANG_CHINESE_HONGKONG: strSub = TEXT("SUBLANG_CHINESE_HONGKONG"); break;
    //        case SUBLANG_CHINESE_SINGAPORE: strSub = TEXT("SUBLANG_CHINESE_SINGAPORE"); break;
    //        case SUBLANG_CHINESE_MACAU: strSub = TEXT("SUBLANG_CHINESE_MACAU"); break;
    //    }
    //    break;
    case LANG_CHINESE_TRADITIONAL: strPrim = TEXT("LANG_CHINESE_TRADITIONAL");
        SWITCH_SUBLANG()
        {
        case SUBLANG_CHINESE_TRADITIONAL: strSub = TEXT("SUBLANG_CHINESE_TRADITIONAL"); break;
        case SUBLANG_CHINESE_SIMPLIFIED: strSub = TEXT("SUBLANG_CHINESE_SIMPLIFIED"); break;
        case SUBLANG_CHINESE_HONGKONG: strSub = TEXT("SUBLANG_CHINESE_HONGKONG"); break;
        case SUBLANG_CHINESE_SINGAPORE: strSub = TEXT("SUBLANG_CHINESE_SINGAPORE"); break;
        case SUBLANG_CHINESE_MACAU: strSub = TEXT("SUBLANG_CHINESE_MACAU"); break;
        }
        break;
    case LANG_CORSICAN: strPrim = TEXT("LANG_CORSICAN");
        SWITCH_SUBLANG()
        {
        case SUBLANG_CORSICAN_FRANCE: strSub = TEXT("SUBLANG_CORSICAN_FRANCE"); break;
        }
        break;
    //case LANG_CROATIAN: strPrim = TEXT("LANG_CROATIAN"); // same as LANG_BOSNIAN
    //    SWITCH_SUBLANG()
    //    {
    //        case SUBLANG_CROATIAN_CROATIA: strSub = TEXT("SUBLANG_CROATIAN_CROATIA"); break;
    //        case SUBLANG_CROATIAN_BOSNIA_HERZEGOVINA_LATIN: strSub = TEXT("SUBLANG_CROATIAN_BOSNIA_HERZEGOVINA_LATIN"); break;
    //    }
    //    break;
    case LANG_CZECH: strPrim = TEXT("LANG_CZECH");
        SWITCH_SUBLANG()
        {
        case SUBLANG_CZECH_CZECH_REPUBLIC: strSub = TEXT("SUBLANG_CZECH_CZECH_REPUBLIC"); break;
        }
        break;
    case LANG_DANISH: strPrim = TEXT("LANG_DANISH");
        SWITCH_SUBLANG()
        {
        case SUBLANG_DANISH_DENMARK: strSub = TEXT("SUBLANG_DANISH_DENMARK"); break;
        }
        break;
    case LANG_DARI: strPrim = TEXT("LANG_DARI");
        SWITCH_SUBLANG()
        {
        case SUBLANG_DARI_AFGHANISTAN: strSub = TEXT("SUBLANG_DARI_AFGHANISTAN"); break;
        }
        break;
    case LANG_DIVEHI: strPrim = TEXT("LANG_DIVEHI");
        SWITCH_SUBLANG()
        {
        case SUBLANG_DIVEHI_MALDIVES: strSub = TEXT("SUBLANG_DIVEHI_MALDIVES"); break;
        }
        break;
    case LANG_DUTCH: strPrim = TEXT("LANG_DUTCH");
        SWITCH_SUBLANG()
        {
        case SUBLANG_DUTCH: strSub = TEXT("SUBLANG_DUTCH"); break;
        case SUBLANG_DUTCH_BELGIAN: strSub = TEXT("SUBLANG_DUTCH_BELGIAN"); break;
        }
        break;
    case LANG_ENGLISH: strPrim = TEXT("LANG_ENGLISH");
        SWITCH_SUBLANG()
        {
        case SUBLANG_ENGLISH_US: strSub = TEXT("SUBLANG_ENGLISH_US"); break;
        case SUBLANG_ENGLISH_UK: strSub = TEXT("SUBLANG_ENGLISH_UK"); break;
        case SUBLANG_ENGLISH_AUS: strSub = TEXT("SUBLANG_ENGLISH_AUS"); break;
        case SUBLANG_ENGLISH_CAN: strSub = TEXT("SUBLANG_ENGLISH_CAN"); break;
        case SUBLANG_ENGLISH_NZ: strSub = TEXT("SUBLANG_ENGLISH_NZ"); break;
        //case SUBLANG_ENGLISH_IRELAND: strSub = TEXT("SUBLANG_ENGLISH_IRELAND"); break; // same as SUBLANG_ENGLISH_EIRE
        case SUBLANG_ENGLISH_EIRE: strSub = TEXT("SUBLANG_ENGLISH_EIRE"); break;
        case SUBLANG_ENGLISH_SOUTH_AFRICA: strSub = TEXT("SUBLANG_ENGLISH_SOUTH_AFRICA"); break;
        case SUBLANG_ENGLISH_JAMAICA: strSub = TEXT("SUBLANG_ENGLISH_JAMAICA"); break;
        case SUBLANG_ENGLISH_CARIBBEAN: strSub = TEXT("SUBLANG_ENGLISH_CARIBBEAN"); break;
        case SUBLANG_ENGLISH_BELIZE: strSub = TEXT("SUBLANG_ENGLISH_BELIZE"); break;
        case SUBLANG_ENGLISH_TRINIDAD: strSub = TEXT("SUBLANG_ENGLISH_TRINIDAD"); break;
        case SUBLANG_ENGLISH_ZIMBABWE: strSub = TEXT("SUBLANG_ENGLISH_ZIMBABWE"); break;
        case SUBLANG_ENGLISH_PHILIPPINES: strSub = TEXT("SUBLANG_ENGLISH_PHILIPPINES"); break;
        case SUBLANG_ENGLISH_INDIA: strSub = TEXT("SUBLANG_ENGLISH_INDIA"); break;
        case SUBLANG_ENGLISH_MALAYSIA: strSub = TEXT("SUBLANG_ENGLISH_MALAYSIA"); break;
        case SUBLANG_ENGLISH_SINGAPORE: strSub = TEXT("SUBLANG_ENGLISH_SINGAPORE"); break;
        }
        break;
    case LANG_ESTONIAN: strPrim = TEXT("LANG_ESTONIAN");
        SWITCH_SUBLANG()
        {
        case SUBLANG_ESTONIAN_ESTONIA: strSub = TEXT("SUBLANG_ESTONIAN_ESTONIA"); break;
        }
        break;
    case LANG_FAEROESE: strPrim = TEXT("LANG_FAEROESE");
        SWITCH_SUBLANG()
        {
        case SUBLANG_FAEROESE_FAROE_ISLANDS: strSub = TEXT("SUBLANG_FAEROESE_FAROE_ISLANDS"); break;
        }
        break;
    //case LANG_FARSI: strPrim = TEXT("LANG_FARSI"); // same as LANG_PERSIAN
    //    break;
    case LANG_FILIPINO: strPrim = TEXT("LANG_FILIPINO");
        SWITCH_SUBLANG()
        {
        case SUBLANG_FILIPINO_PHILIPPINES: strSub = TEXT("SUBLANG_FILIPINO_PHILIPPINES"); break;
        }
        break;
    case LANG_FINNISH: strPrim = TEXT("LANG_FINNISH");
        SWITCH_SUBLANG()
        {
        case SUBLANG_FINNISH_FINLAND: strSub = TEXT("SUBLANG_FINNISH_FINLAND"); break;
        }
        break;
    case LANG_FRENCH: strPrim = TEXT("LANG_FRENCH");
        SWITCH_SUBLANG()
        {
        case SUBLANG_FRENCH: strSub = TEXT("SUBLANG_FRENCH"); break;
        case SUBLANG_FRENCH_BELGIAN: strSub = TEXT("SUBLANG_FRENCH_BELGIAN"); break;
        case SUBLANG_FRENCH_CANADIAN: strSub = TEXT("SUBLANG_FRENCH_CANADIAN"); break;
        case SUBLANG_FRENCH_SWISS: strSub = TEXT("SUBLANG_FRENCH_SWISS"); break;
        case SUBLANG_FRENCH_LUXEMBOURG: strSub = TEXT("SUBLANG_FRENCH_LUXEMBOURG"); break;
        case SUBLANG_FRENCH_MONACO: strSub = TEXT("SUBLANG_FRENCH_MONACO"); break;
        }
        break;
    case LANG_FRISIAN: strPrim = TEXT("LANG_FRISIAN");
        SWITCH_SUBLANG()
        {
        case SUBLANG_FRISIAN_NETHERLANDS: strSub = TEXT("SUBLANG_FRISIAN_NETHERLANDS"); break;
        }
        break;
    //case LANG_FULAH: strPrim = TEXT("LANG_FULAH"); // same as LANG_PULAR
    //    SWITCH_SUBLANG()
    //    {
    //    case SUBLANG_FULAH_SENEGAL: strSub = TEXT("SUBLANG_FULAH_SENEGAL"); break;
    //    }
    //    break;
    case LANG_GALICIAN: strPrim = TEXT("LANG_GALICIAN");
        SWITCH_SUBLANG()
        {
        case SUBLANG_GALICIAN_GALICIAN: strSub = TEXT("SUBLANG_GALICIAN_GALICIAN"); break;
        }
        break;
    case LANG_GEORGIAN: strPrim = TEXT("LANG_GEORGIAN");
        SWITCH_SUBLANG()
        {
        case SUBLANG_GEORGIAN_GEORGIA: strSub = TEXT("SUBLANG_GEORGIAN_GEORGIA"); break;
        }
        break;
    case LANG_GERMAN: strPrim = TEXT("LANG_GERMAN");
        SWITCH_SUBLANG()
        {
        case SUBLANG_GERMAN: strSub = TEXT("SUBLANG_GERMAN"); break;
        case SUBLANG_GERMAN_SWISS: strSub = TEXT("SUBLANG_GERMAN_SWISS"); break;
        case SUBLANG_GERMAN_AUSTRIAN: strSub = TEXT("SUBLANG_GERMAN_AUSTRIAN"); break;
        case SUBLANG_GERMAN_LUXEMBOURG: strSub = TEXT("SUBLANG_GERMAN_LUXEMBOURG"); break;
        case SUBLANG_GERMAN_LIECHTENSTEIN: strSub = TEXT("SUBLANG_GERMAN_LIECHTENSTEIN"); break;
        }
        break;
    case LANG_GREEK: strPrim = TEXT("LANG_GREEK");
        SWITCH_SUBLANG()
        {
        case SUBLANG_GREEK_GREECE: strSub = TEXT("SUBLANG_GREEK_GREECE"); break;
        }
        break;
    case LANG_GREENLANDIC: strPrim = TEXT("LANG_GREENLANDIC");
        SWITCH_SUBLANG()
        {
        case SUBLANG_GREENLANDIC_GREENLAND: strSub = TEXT("SUBLANG_GREENLANDIC_GREENLAND"); break;
        }
        break;
    case LANG_GUJARATI: strPrim = TEXT("LANG_GUJARATI");
        SWITCH_SUBLANG()
        {
        case SUBLANG_GUJARATI_INDIA: strSub = TEXT("SUBLANG_GUJARATI_INDIA"); break;
        }
        break;
    case LANG_HAUSA: strPrim = TEXT("LANG_HAUSA");
        SWITCH_SUBLANG()
        {
        case SUBLANG_HAUSA_NIGERIA_LATIN: strSub = TEXT("SUBLANG_HAUSA_NIGERIA_LATIN"); break;
        }
        break;
    case LANG_HEBREW: strPrim = TEXT("LANG_HEBREW");
        SWITCH_SUBLANG()
        {
        case SUBLANG_HEBREW_ISRAEL: strSub = TEXT("SUBLANG_HEBREW_ISRAEL"); break;
        }
        break;
    case LANG_HINDI: strPrim = TEXT("LANG_HINDI");
        SWITCH_SUBLANG()
        {
        case SUBLANG_HINDI_INDIA: strSub = TEXT("SUBLANG_HINDI_INDIA"); break;
        }
        break;
    case LANG_HUNGARIAN: strPrim = TEXT("LANG_HUNGARIAN");
        SWITCH_SUBLANG()
        {
        case SUBLANG_HUNGARIAN_HUNGARY: strSub = TEXT("SUBLANG_HUNGARIAN_HUNGARY"); break;
        }
        break;
    case LANG_ICELANDIC: strPrim = TEXT("LANG_ICELANDIC");
        SWITCH_SUBLANG()
        {
        case SUBLANG_ICELANDIC_ICELAND: strSub = TEXT("SUBLANG_ICELANDIC_ICELAND"); break;
        }
        break;
    case LANG_IGBO: strPrim = TEXT("LANG_IGBO");
        SWITCH_SUBLANG()
        {
        case SUBLANG_IGBO_NIGERIA: strSub = TEXT("SUBLANG_IGBO_NIGERIA"); break;
        }
        break;
    case LANG_INDONESIAN: strPrim = TEXT("LANG_INDONESIAN");
        SWITCH_SUBLANG()
        {
        case SUBLANG_INDONESIAN_INDONESIA: strSub = TEXT("SUBLANG_INDONESIAN_INDONESIA"); break;
        }
        break;
    case LANG_INUKTITUT: strPrim = TEXT("LANG_INUKTITUT");
        SWITCH_SUBLANG()
        {
        case SUBLANG_INUKTITUT_CANADA: strSub = TEXT("SUBLANG_INUKTITUT_CANADA"); break;
        case SUBLANG_INUKTITUT_CANADA_LATIN: strSub = TEXT("SUBLANG_INUKTITUT_CANADA_LATIN"); break;
        }
        break;
    case LANG_IRISH: strPrim = TEXT("LANG_IRISH");
        SWITCH_SUBLANG()
        {
        case SUBLANG_IRISH_IRELAND: strSub = TEXT("SUBLANG_IRISH_IRELAND"); break;
        }
        break;
    case LANG_ITALIAN: strPrim = TEXT("LANG_ITALIAN");
        SWITCH_SUBLANG()
        {
        case SUBLANG_ITALIAN: strSub = TEXT("SUBLANG_ITALIAN"); break;
        case SUBLANG_ITALIAN_SWISS: strSub = TEXT("SUBLANG_ITALIAN_SWISS"); break;
        }
        break;
    case LANG_JAPANESE: strPrim = TEXT("LANG_JAPANESE");
        SWITCH_SUBLANG()
        {
        case SUBLANG_JAPANESE_JAPAN: strSub = TEXT("SUBLANG_JAPANESE_JAPAN"); break;
        }
        break;
    case LANG_KANNADA: strPrim = TEXT("LANG_KANNADA");
        SWITCH_SUBLANG()
        {
        case SUBLANG_KANNADA_INDIA: strSub = TEXT("SUBLANG_KANNADA_INDIA"); break;
        }
        break;
    case LANG_KASHMIRI: strPrim = TEXT("LANG_KASHMIRI");
        SWITCH_SUBLANG()
        {
        case SUBLANG_KASHMIRI_INDIA: strSub = TEXT("SUBLANG_KASHMIRI_INDIA"); break;
        //case SUBLANG_KASHMIRI_SASIA: strSub = TEXT("SUBLANG_KASHMIRI_SASIA"); break; // same as SUBLANG_KASHMIRI_INDIA
        }
        break;
    case LANG_KAZAK: strPrim = TEXT("LANG_KAZAK");
        SWITCH_SUBLANG()
        {
        case SUBLANG_KAZAK_KAZAKHSTAN: strSub = TEXT("SUBLANG_KAZAK_KAZAKHSTAN"); break;
        }
        break;
    case LANG_KHMER: strPrim = TEXT("LANG_KHMER");
        SWITCH_SUBLANG()
        {
        case SUBLANG_KHMER_CAMBODIA: strSub = TEXT("SUBLANG_KHMER_CAMBODIA"); break;
        }
        break;
    case LANG_KICHE: strPrim = TEXT("LANG_KICHE");
        SWITCH_SUBLANG()
        {
        case SUBLANG_KICHE_GUATEMALA: strSub = TEXT("SUBLANG_KICHE_GUATEMALA"); break;
        }
        break;
    case LANG_KINYARWANDA: strPrim = TEXT("LANG_KINYARWANDA");
        SWITCH_SUBLANG()
        {
        case SUBLANG_KINYARWANDA_RWANDA: strSub = TEXT("SUBLANG_KINYARWANDA_RWANDA"); break;
        }
        break;
    case LANG_KONKANI: strPrim = TEXT("LANG_KONKANI");
        SWITCH_SUBLANG()
        {
        case SUBLANG_KONKANI_INDIA: strSub = TEXT("SUBLANG_KONKANI_INDIA"); break;
        }
        break;
    case LANG_KOREAN: strPrim = TEXT("LANG_KOREAN");
        SWITCH_SUBLANG()
        {
        case SUBLANG_KOREAN: strSub = TEXT("SUBLANG_KOREAN"); break;
        }
        break;
    case LANG_KYRGYZ: strPrim = TEXT("LANG_KYRGYZ");
        SWITCH_SUBLANG()
        {
        case SUBLANG_KYRGYZ_KYRGYZSTAN: strSub = TEXT("SUBLANG_KYRGYZ_KYRGYZSTAN"); break;
        }
        break;
    case LANG_LAO: strPrim = TEXT("LANG_LAO");
        SWITCH_SUBLANG()
        {
        case SUBLANG_LAO_LAO: strSub = TEXT("SUBLANG_LAO_LAO"); break;
        }
        break;
    case LANG_LATVIAN: strPrim = TEXT("LANG_LATVIAN");
        SWITCH_SUBLANG()
        {
        case SUBLANG_LATVIAN_LATVIA: strSub = TEXT("SUBLANG_LATVIAN_LATVIA"); break;
        }
        break;
    case LANG_LITHUANIAN: strPrim = TEXT("LANG_LITHUANIAN");
#if (WINVER >= 0x0600) && defined(ENABLE_NEW_LANGS)
        SWITCH_SUBLANG()
        {
        case SUBLANG_LITHUANIAN_LITHUANIA: strSub = TEXT("SUBLANG_LITHUANIAN_LITHUANIA"); break;
        }
#endif
        break;
    //case LANG_LOWER_SORBIAN: strPrim = TEXT("LANG_LOWER_SORBIAN"); // same as LANG_UPPER_SORBIAN
    //    SWITCH_SUBLANG()
    //    {
    //    case SUBLANG_LOWER_SORBIAN_GERMANY: strSub = TEXT("SUBLANG_LOWER_SORBIAN_GERMANY"); break;
    //    }
    //    break;
    case LANG_LUXEMBOURGISH: strPrim = TEXT("LANG_LUXEMBOURGISH");
        SWITCH_SUBLANG()
        {
        case SUBLANG_LUXEMBOURGISH_LUXEMBOURG: strSub = TEXT("SUBLANG_LUXEMBOURGISH_LUXEMBOURG"); break;
        }
        break;
    case LANG_MACEDONIAN: strPrim = TEXT("LANG_MACEDONIAN");
        SWITCH_SUBLANG()
        {
        case SUBLANG_MACEDONIAN_MACEDONIA: strSub = TEXT("SUBLANG_MACEDONIAN_MACEDONIA"); break;
        }
        break;
    case LANG_MALAY: strPrim = TEXT("LANG_MALAY");
        SWITCH_SUBLANG()
        {
        case SUBLANG_MALAY_MALAYSIA: strSub = TEXT("SUBLANG_MALAY_MALAYSIA"); break;
        case SUBLANG_MALAY_BRUNEI_DARUSSALAM: strSub = TEXT("SUBLANG_MALAY_BRUNEI_DARUSSALAM"); break;
        }
        break;
    case LANG_MALAYALAM: strPrim = TEXT("LANG_MALAYALAM");
        SWITCH_SUBLANG()
        {
        case SUBLANG_MALAYALAM_INDIA: strSub = TEXT("SUBLANG_MALAYALAM_INDIA"); break;
        }
        break;
    case LANG_MALTESE: strPrim = TEXT("LANG_MALTESE");
        SWITCH_SUBLANG()
        {
        case SUBLANG_MALTESE_MALTA: strSub = TEXT("SUBLANG_MALTESE_MALTA"); break;
        }
        break;
    case LANG_MANIPURI: strPrim = TEXT("LANG_MANIPURI");
        break;
    case LANG_MAORI: strPrim = TEXT("LANG_MAORI");
        SWITCH_SUBLANG()
        {
        case SUBLANG_MAORI_NEW_ZEALAND: strSub = TEXT("SUBLANG_MAORI_NEW_ZEALAND"); break;
        }
        break;
    case LANG_MAPUDUNGUN: strPrim = TEXT("LANG_MAPUDUNGUN");
        SWITCH_SUBLANG()
        {
        case SUBLANG_MAPUDUNGUN_CHILE: strSub = TEXT("SUBLANG_MAPUDUNGUN_CHILE"); break;
        }
        break;
    case LANG_MARATHI: strPrim = TEXT("LANG_MARATHI");
        SWITCH_SUBLANG()
        {
        case SUBLANG_MARATHI_INDIA: strSub = TEXT("SUBLANG_MARATHI_INDIA"); break;
        }
        break;
    case LANG_MOHAWK: strPrim = TEXT("LANG_MOHAWK");
        SWITCH_SUBLANG()
        {
        case SUBLANG_MOHAWK_MOHAWK: strSub = TEXT("SUBLANG_MOHAWK_MOHAWK"); break;
        }
        break;
    case LANG_MONGOLIAN: strPrim = TEXT("LANG_MONGOLIAN");
        SWITCH_SUBLANG()
        {
        case SUBLANG_MONGOLIAN_CYRILLIC_MONGOLIA: strSub = TEXT("SUBLANG_MONGOLIAN_CYRILLIC_MONGOLIA"); break;
        case SUBLANG_MONGOLIAN_PRC: strSub = TEXT("SUBLANG_MONGOLIAN_PRC"); break;
        }
        break;
    case LANG_NEPALI: strPrim = TEXT("LANG_NEPALI");
        SWITCH_SUBLANG()
        {
        case SUBLANG_NEPALI_NEPAL: strSub = TEXT("SUBLANG_NEPALI_NEPAL"); break;
        case SUBLANG_NEPALI_INDIA: strSub = TEXT("SUBLANG_NEPALI_INDIA"); break;
        }
        break;
    case LANG_NORWEGIAN: strPrim = TEXT("LANG_NORWEGIAN");
        SWITCH_SUBLANG()
        {
        case SUBLANG_NORWEGIAN_BOKMAL: strSub = TEXT("SUBLANG_NORWEGIAN_BOKMAL"); break;
        case SUBLANG_NORWEGIAN_NYNORSK: strSub = TEXT("SUBLANG_NORWEGIAN_NYNORSK"); break;
        }
        break;
    case LANG_OCCITAN: strPrim = TEXT("LANG_OCCITAN");
        SWITCH_SUBLANG()
        {
        case SUBLANG_OCCITAN_FRANCE: strSub = TEXT("SUBLANG_OCCITAN_FRANCE"); break;
        }
        break;
    //case LANG_ODIA: strPrim = TEXT("LANG_ODIA");  // same as LANG_ORIYA
    //    break;
    case LANG_ORIYA: strPrim = TEXT("LANG_ORIYA");
        SWITCH_SUBLANG()
        {
        case SUBLANG_ORIYA_INDIA: strSub = TEXT("SUBLANG_ORIYA_INDIA"); break;
        }
        break;
    case LANG_PASHTO: strPrim = TEXT("LANG_PASHTO");
        SWITCH_SUBLANG()
        {
        case SUBLANG_PASHTO_AFGHANISTAN: strSub = TEXT("SUBLANG_PASHTO_AFGHANISTAN"); break;
        }
        break;
    case LANG_PERSIAN: strPrim = TEXT("LANG_PERSIAN");
        SWITCH_SUBLANG()
        {
        case SUBLANG_PERSIAN_IRAN: strSub = TEXT("SUBLANG_PERSIAN_IRAN"); break;
        }
        break;
    case LANG_POLISH: strPrim = TEXT("LANG_POLISH");
        SWITCH_SUBLANG()
        {
        case SUBLANG_POLISH_POLAND: strSub = TEXT("SUBLANG_POLISH_POLAND"); break;
        }
        break;
    case LANG_PORTUGUESE: strPrim = TEXT("LANG_PORTUGUESE");
        SWITCH_SUBLANG()
        {
        case SUBLANG_PORTUGUESE: strSub = TEXT("SUBLANG_PORTUGUESE"); break;
        case SUBLANG_PORTUGUESE_BRAZILIAN: strSub = TEXT("SUBLANG_PORTUGUESE_BRAZILIAN"); break;
        }
        break;
#ifdef ENABLE_NEW_LANGS
    case LANG_PULAR: strPrim = TEXT("LANG_PULAR"); // same as LANG_FULAH
        SWITCH_SUBLANG()
        {
        case SUBLANG_PULAR_SENEGAL: strSub = TEXT("SUBLANG_PULAR_SENEGAL"); break;
        default: break;
        }
#endif
        break;
    case LANG_PUNJABI: strPrim = TEXT("LANG_PUNJABI");
        SWITCH_SUBLANG()
        {
        case SUBLANG_PUNJABI_INDIA: strSub = TEXT("SUBLANG_PUNJABI_INDIA"); break;
#ifdef ENABLE_NEW_LANGS
        case SUBLANG_PUNJABI_PAKISTAN: strSub = TEXT("SUBLANG_PUNJABI_PAKISTAN"); break;
#endif
        default: break;
        }
        break;
    case LANG_QUECHUA: strPrim = TEXT("LANG_QUECHUA");
        SWITCH_SUBLANG()
        {
        case SUBLANG_QUECHUA_BOLIVIA: strSub = TEXT("SUBLANG_QUECHUA_BOLIVIA"); break;
        case SUBLANG_QUECHUA_ECUADOR: strSub = TEXT("SUBLANG_QUECHUA_ECUADOR"); break;
        case SUBLANG_QUECHUA_PERU: strSub = TEXT("SUBLANG_QUECHUA_PERU"); break;
        }
        break;
    case LANG_ROMANIAN: strPrim = TEXT("LANG_ROMANIAN");
        SWITCH_SUBLANG()
        {
        case SUBLANG_ROMANIAN_ROMANIA: strSub = TEXT("SUBLANG_ROMANIAN_ROMANIA"); break;
        }
        break;
    case LANG_ROMANSH: strPrim = TEXT("LANG_ROMANSH");
        SWITCH_SUBLANG()
        {
        case SUBLANG_ROMANSH_SWITZERLAND: strSub = TEXT("SUBLANG_ROMANSH_SWITZERLAND"); break;
        }
        break;
    case LANG_RUSSIAN: strPrim = TEXT("LANG_RUSSIAN");
        SWITCH_SUBLANG()
        {
        case SUBLANG_RUSSIAN_RUSSIA: strSub = TEXT("SUBLANG_RUSSIAN_RUSSIA"); break;
        }
        break;
#ifdef ENABLE_NEW_LANGS
    case LANG_SAKHA: strPrim = TEXT("LANG_SAKHA");
        SWITCH_SUBLANG()
        {
        case SUBLANG_SAKHA_RUSSIA: strSub = TEXT("SUBLANG_SAKHA_RUSSIA"); break;
        default: break;
        }
        break;
#endif
    case LANG_SAMI: strPrim = TEXT("LANG_SAMI");
        SWITCH_SUBLANG()
        {
        case SUBLANG_SAMI_NORTHERN_NORWAY: strSub = TEXT("SUBLANG_SAMI_NORTHERN_NORWAY"); break;
        case SUBLANG_SAMI_NORTHERN_SWEDEN: strSub = TEXT("SUBLANG_SAMI_NORTHERN_SWEDEN"); break;
        case SUBLANG_SAMI_NORTHERN_FINLAND: strSub = TEXT("SUBLANG_SAMI_NORTHERN_FINLAND"); break;
        case SUBLANG_SAMI_LULE_NORWAY: strSub = TEXT("SUBLANG_SAMI_LULE_NORWAY"); break;
        case SUBLANG_SAMI_LULE_SWEDEN: strSub = TEXT("SUBLANG_SAMI_LULE_SWEDEN"); break;
        case SUBLANG_SAMI_SOUTHERN_NORWAY: strSub = TEXT("SUBLANG_SAMI_SOUTHERN_NORWAY"); break;
        case SUBLANG_SAMI_SOUTHERN_SWEDEN: strSub = TEXT("SUBLANG_SAMI_SOUTHERN_SWEDEN"); break;
        case SUBLANG_SAMI_SKOLT_FINLAND: strSub = TEXT("SUBLANG_SAMI_SKOLT_FINLAND"); break;
        case SUBLANG_SAMI_INARI_FINLAND: strSub = TEXT("SUBLANG_SAMI_INARI_FINLAND"); break;
        }
        break;
    case LANG_SANSKRIT: strPrim = TEXT("LANG_SANSKRIT");
        SWITCH_SUBLANG()
        {
        case SUBLANG_SANSKRIT_INDIA: strSub = TEXT("SUBLANG_SANSKRIT_INDIA"); break;
        }
        break;
#ifdef ENABLE_NEW_LANGS
    case LANG_SCOTTISH_GAELIC: strPrim = TEXT("LANG_SCOTTISH_GAELIC");
        SWITCH_SUBLANG()
        {
        case SUBLANG_SCOTTISH_GAELIC: strSub = TEXT("SUBLANG_SCOTTISH_GAELIC"); break;
        default: break;
        }
        break;
#endif
    //case LANG_SERBIAN: strPrim = TEXT("LANG_SERBIAN"); // same as LANG_BOSNIAN
    //    SWITCH_SUBLANG()
    //    {
    //    case SUBLANG_SERBIAN_LATIN: strSub = TEXT("SUBLANG_SERBIAN_LATIN"); break;
    //    case SUBLANG_SERBIAN_CYRILLIC: strSub = TEXT("SUBLANG_SERBIAN_CYRILLIC"); break;
    //    case SUBLANG_SERBIAN_BOSNIA_HERZEGOVINA_LATIN: strSub = TEXT("SUBLANG_SERBIAN_BOSNIA_HERZEGOVINA_LATIN"); break;
    //    case SUBLANG_SERBIAN_BOSNIA_HERZEGOVINA_CYRILLIC: strSub = TEXT("SUBLANG_SERBIAN_BOSNIA_HERZEGOVINA_CYRILLIC"); break;
    //    case SUBLANG_SERBIAN_MONTENEGRO_LATIN: strSub = TEXT("SUBLANG_SERBIAN_MONTENEGRO_LATIN"); break;
    //    case SUBLANG_SERBIAN_MONTENEGRO_CYRILLIC: strSub = TEXT("SUBLANG_SERBIAN_MONTENEGRO_CYRILLIC"); break;
    //    case SUBLANG_SERBIAN_SERBIA_LATIN: strSub = TEXT("SUBLANG_SERBIAN_SERBIA_LATIN"); break;
    //    case SUBLANG_SERBIAN_SERBIA_CYRILLIC: strSub = TEXT("SUBLANG_SERBIAN_SERBIA_CYRILLIC"); break;
    //    }
    //    break;
    case LANG_SERBIAN_NEUTRAL: strPrim = TEXT("LANG_SERBIAN_NEUTRAL");
        SWITCH_SUBLANG()
        {
        case SUBLANG_SERBIAN_LATIN: strSub = TEXT("SUBLANG_SERBIAN_LATIN"); break;
        case SUBLANG_SERBIAN_CYRILLIC: strSub = TEXT("SUBLANG_SERBIAN_CYRILLIC"); break;
        case SUBLANG_SERBIAN_BOSNIA_HERZEGOVINA_LATIN: strSub = TEXT("SUBLANG_SERBIAN_BOSNIA_HERZEGOVINA_LATIN"); break;
        case SUBLANG_SERBIAN_BOSNIA_HERZEGOVINA_CYRILLIC: strSub = TEXT("SUBLANG_SERBIAN_BOSNIA_HERZEGOVINA_CYRILLIC"); break;
#ifdef ENABLE_NEW_LANGS
        case SUBLANG_SERBIAN_MONTENEGRO_LATIN: strSub = TEXT("SUBLANG_SERBIAN_MONTENEGRO_LATIN"); break;
        case SUBLANG_SERBIAN_MONTENEGRO_CYRILLIC: strSub = TEXT("SUBLANG_SERBIAN_MONTENEGRO_CYRILLIC"); break;
        case SUBLANG_SERBIAN_SERBIA_LATIN: strSub = TEXT("SUBLANG_SERBIAN_SERBIA_LATIN"); break;
        case SUBLANG_SERBIAN_SERBIA_CYRILLIC: strSub = TEXT("SUBLANG_SERBIAN_SERBIA_CYRILLIC"); break;
#endif
        }
        break;
    case LANG_SINDHI: strPrim = TEXT("LANG_SINDHI");
        SWITCH_SUBLANG()
        {
        case SUBLANG_SINDHI_INDIA: strSub = TEXT("SUBLANG_SINDHI_INDIA"); break;
        case SUBLANG_SINDHI_AFGHANISTAN: strSub = TEXT("SUBLANG_SINDHI_AFGHANISTAN"); break;
        //case SUBLANG_SINDHI_PAKISTAN: strSub = TEXT("SUBLANG_SINDHI_PAKISTAN"); break; // same as SUBLANG_SINDHI_AFGHANISTAN
        }
        break;
    case LANG_SINHALESE: strPrim = TEXT("LANG_SINHALESE");
        SWITCH_SUBLANG()
        {
        case SUBLANG_SINHALESE_SRI_LANKA: strSub = TEXT("SUBLANG_SINHALESE_SRI_LANKA"); break;
        }
        break;
    case LANG_SLOVAK: strPrim = TEXT("LANG_SLOVAK");
        SWITCH_SUBLANG()
        {
        case SUBLANG_SLOVAK_SLOVAKIA: strSub = TEXT("SUBLANG_SLOVAK_SLOVAKIA"); break;
        }
        break;
    case LANG_SLOVENIAN: strPrim = TEXT("LANG_SLOVENIAN");
        SWITCH_SUBLANG()
        {
        case SUBLANG_SLOVENIAN_SLOVENIA: strSub = TEXT("SUBLANG_SLOVENIAN_SLOVENIA"); break;
        }
        break;
    case LANG_SOTHO: strPrim = TEXT("LANG_SOTHO");
        SWITCH_SUBLANG()
        {
        case SUBLANG_SOTHO_NORTHERN_SOUTH_AFRICA: strSub = TEXT("SUBLANG_SOTHO_NORTHERN_SOUTH_AFRICA"); break;
        }
        break;
    case LANG_SPANISH: strPrim = TEXT("LANG_SPANISH");
        SWITCH_SUBLANG()
        {
        case SUBLANG_SPANISH: strSub = TEXT("SUBLANG_SPANISH"); break;
        case SUBLANG_SPANISH_MEXICAN: strSub = TEXT("SUBLANG_SPANISH_MEXICAN"); break;
        case SUBLANG_SPANISH_MODERN: strSub = TEXT("SUBLANG_SPANISH_MODERN"); break;
        case SUBLANG_SPANISH_GUATEMALA: strSub = TEXT("SUBLANG_SPANISH_GUATEMALA"); break;
        case SUBLANG_SPANISH_COSTA_RICA: strSub = TEXT("SUBLANG_SPANISH_COSTA_RICA"); break;
        case SUBLANG_SPANISH_PANAMA: strSub = TEXT("SUBLANG_SPANISH_PANAMA"); break;
        case SUBLANG_SPANISH_DOMINICAN_REPUBLIC: strSub = TEXT("SUBLANG_SPANISH_DOMINICAN_REPUBLIC"); break;
        case SUBLANG_SPANISH_VENEZUELA: strSub = TEXT("SUBLANG_SPANISH_VENEZUELA"); break;
        case SUBLANG_SPANISH_COLOMBIA: strSub = TEXT("SUBLANG_SPANISH_COLOMBIA"); break;
        case SUBLANG_SPANISH_PERU: strSub = TEXT("SUBLANG_SPANISH_PERU"); break;
        case SUBLANG_SPANISH_ARGENTINA: strSub = TEXT("SUBLANG_SPANISH_ARGENTINA"); break;
        case SUBLANG_SPANISH_ECUADOR: strSub = TEXT("SUBLANG_SPANISH_ECUADOR"); break;
        case SUBLANG_SPANISH_CHILE: strSub = TEXT("SUBLANG_SPANISH_CHILE"); break;
        case SUBLANG_SPANISH_URUGUAY: strSub = TEXT("SUBLANG_SPANISH_URUGUAY"); break;
        case SUBLANG_SPANISH_PARAGUAY: strSub = TEXT("SUBLANG_SPANISH_PARAGUAY"); break;
        case SUBLANG_SPANISH_BOLIVIA: strSub = TEXT("SUBLANG_SPANISH_BOLIVIA"); break;
        case SUBLANG_SPANISH_EL_SALVADOR: strSub = TEXT("SUBLANG_SPANISH_EL_SALVADOR"); break;
        case SUBLANG_SPANISH_HONDURAS: strSub = TEXT("SUBLANG_SPANISH_HONDURAS"); break;
        case SUBLANG_SPANISH_NICARAGUA: strSub = TEXT("SUBLANG_SPANISH_NICARAGUA"); break;
        case SUBLANG_SPANISH_PUERTO_RICO: strSub = TEXT("SUBLANG_SPANISH_PUERTO_RICO"); break;
        case SUBLANG_SPANISH_US: strSub = TEXT("SUBLANG_SPANISH_US"); break;
        }
        break;
    case LANG_SWAHILI: strPrim = TEXT("LANG_SWAHILI");
        SWITCH_SUBLANG()
        {
        case SUBLANG_SWAHILI_KENYA: strSub = TEXT("SUBLANG_SWAHILI_KENYA"); break;
        }
        break;
    case LANG_SWEDISH: strPrim = TEXT("LANG_SWEDISH");
        SWITCH_SUBLANG()
        {
        //case SUBLANG_SWEDISH_SWEDEN: strSub = TEXT("SUBLANG_SWEDISH_SWEDEN"); break; // same as SUBLANG_SWEDISH
        case SUBLANG_SWEDISH: strSub = TEXT("SUBLANG_SWEDISH"); break;
        case SUBLANG_SWEDISH_FINLAND: strSub = TEXT("SUBLANG_SWEDISH_FINLAND"); break;
        }
        break;
    case LANG_SYRIAC: strPrim = TEXT("LANG_SYRIAC");
#if defined(ENABLE_NEW_LANGS)
        SWITCH_SUBLANG()
        {
        case SUBLANG_SYRIAC: strSub = TEXT("SUBLANG_SYRIAC"); break;
        }
#endif
        break;
    case LANG_TAJIK: strPrim = TEXT("LANG_TAJIK");
        SWITCH_SUBLANG()
        {
        case SUBLANG_TAJIK_TAJIKISTAN: strSub = TEXT("SUBLANG_TAJIK_TAJIKISTAN"); break;
        }
        break;
    case LANG_TAMAZIGHT: strPrim = TEXT("LANG_TAMAZIGHT");
        SWITCH_SUBLANG()
        {
        case SUBLANG_TAMAZIGHT_ALGERIA_LATIN   : strSub = TEXT("SUBLANG_TAMAZIGHT_ALGERIA_LATIN   "); break;
#ifdef ENABLE_NEW_LANGS
        case SUBLANG_TAMAZIGHT_MOROCCO_TIFINAGH: strSub = TEXT("SUBLANG_TAMAZIGHT_MOROCCO_TIFINAGH"); break;
#endif
        }
        break;
    case LANG_TAMIL: strPrim = TEXT("LANG_TAMIL");
        SWITCH_SUBLANG()
        {
        case SUBLANG_TAMIL_INDIA: strSub = TEXT("SUBLANG_TAMIL_INDIA"); break;
#ifdef ENABLE_NEW_LANGS
        case SUBLANG_TAMIL_SRI_LANKA: strSub = TEXT("SUBLANG_TAMIL_SRI_LANKA"); break;
#endif
        default: break;
        }
        break;
    case LANG_TATAR: strPrim = TEXT("LANG_TATAR");
        SWITCH_SUBLANG()
        {
        case SUBLANG_TATAR_RUSSIA: strSub = TEXT("SUBLANG_TATAR_RUSSIA"); break;
        }
        break;
    case LANG_TELUGU: strPrim = TEXT("LANG_TELUGU");
        SWITCH_SUBLANG()
        {
        case SUBLANG_TELUGU_INDIA: strSub = TEXT("SUBLANG_TELUGU_INDIA"); break;
        }
        break;
    case LANG_THAI: strPrim = TEXT("LANG_THAI");
        SWITCH_SUBLANG()
        {
        case SUBLANG_THAI_THAILAND: strSub = TEXT("SUBLANG_THAI_THAILAND"); break;
        }
        break;
    case LANG_TIBETAN: strPrim = TEXT("LANG_TIBETAN");
        SWITCH_SUBLANG()
        {
        case SUBLANG_TIBETAN_PRC: strSub = TEXT("SUBLANG_TIBETAN_PRC"); break;
#if defined(ENABLE_NEW_LANGS)
        case SUBLANG_TIBETAN_BHUTAN: strSub = TEXT("SUBLANG_TIBETAN_BHUTAN"); break;
#endif
        }
        break;
    case LANG_TIGRIGNA: strPrim = TEXT("LANG_TIGRIGNA"); // same as LANG_TIGRINYA
        SWITCH_SUBLANG()
        {
        case SUBLANG_TIGRIGNA_ERITREA: strSub = TEXT("SUBLANG_TIGRIGNA_ERITREA"); break;
        default: break;
        }
        break;
    //case LANG_TIGRINYA: strPrim = TEXT("LANG_TIGRINYA"); // same as LANG_TIGRIGNA
    //    SWITCH_SUBLANG()
    //    {
    //    case SUBLANG_TIGRINYA_ERITREA: strSub = TEXT("SUBLANG_TIGRINYA_ERITREA"); break;
    //    case SUBLANG_TIGRINYA_ETHIOPIA: strSub = TEXT("SUBLANG_TIGRINYA_ETHIOPIA"); break;
    //    }
    //    break;
    case LANG_TSWANA: strPrim = TEXT("LANG_TSWANA");
        SWITCH_SUBLANG()
        {
#ifdef ENABLE_NEW_LANGS
        case SUBLANG_TSWANA_BOTSWANA: strSub = TEXT("SUBLANG_TSWANA_BOTSWANA"); break;
#endif
        case SUBLANG_TSWANA_SOUTH_AFRICA: strSub = TEXT("SUBLANG_TSWANA_SOUTH_AFRICA"); break;
        }
        break;
    case LANG_TURKISH: strPrim = TEXT("LANG_TURKISH");
        SWITCH_SUBLANG()
        {
        case SUBLANG_TURKISH_TURKEY: strSub = TEXT("SUBLANG_TURKISH_TURKEY"); break;
        }
        break;
    case LANG_TURKMEN: strPrim = TEXT("LANG_TURKMEN");
        SWITCH_SUBLANG()
        {
        case SUBLANG_TURKMEN_TURKMENISTAN: strSub = TEXT("SUBLANG_TURKMEN_TURKMENISTAN"); break;
        }
        break;
    case LANG_UIGHUR: strPrim = TEXT("LANG_UIGHUR");
        SWITCH_SUBLANG()
        {
        case SUBLANG_UIGHUR_PRC: strSub = TEXT("SUBLANG_UIGHUR_PRC"); break;
        }
        break;
    case LANG_UKRAINIAN: strPrim = TEXT("LANG_UKRAINIAN");
        SWITCH_SUBLANG()
        {
        case SUBLANG_UKRAINIAN_UKRAINE: strSub = TEXT("SUBLANG_UKRAINIAN_UKRAINE"); break;
        }
        break;
    case LANG_UPPER_SORBIAN: strPrim = TEXT("LANG_UPPER_SORBIAN");
        SWITCH_SUBLANG()
        {
        case SUBLANG_UPPER_SORBIAN_GERMANY: strSub = TEXT("SUBLANG_UPPER_SORBIAN_GERMANY"); break;
        }
        break;
    case LANG_URDU: strPrim = TEXT("LANG_URDU");
        SWITCH_SUBLANG()
        {
        case SUBLANG_URDU_PAKISTAN: strSub = TEXT("SUBLANG_URDU_PAKISTAN"); break;
        case SUBLANG_URDU_INDIA: strSub = TEXT("SUBLANG_URDU_INDIA"); break;
        }
        break;
    case LANG_UZBEK: strPrim = TEXT("LANG_UZBEK");
        SWITCH_SUBLANG()
        {
        case SUBLANG_UZBEK_LATIN: strSub = TEXT("SUBLANG_UZBEK_LATIN"); break;
        case SUBLANG_UZBEK_CYRILLIC: strSub = TEXT("SUBLANG_UZBEK_CYRILLIC"); break;
        }
        break;
    //case LANG_VALENCIAN: strPrim = TEXT("LANG_VALENCIAN"); // same as LANG_CATALAN
    //    SWITCH_SUBLANG()
    //    {
    //    case SUBLANG_VALENCIAN_VALENCIA: strSub = TEXT("SUBLANG_VALENCIAN_VALENCIA"); break;
    //    }
    //    break;
    case LANG_VIETNAMESE: strPrim = TEXT("LANG_VIETNAMESE");
        SWITCH_SUBLANG()
        {
        case SUBLANG_VIETNAMESE_VIETNAM: strSub = TEXT("SUBLANG_VIETNAMESE_VIETNAM"); break;
        }
        break;
    case LANG_WELSH: strPrim = TEXT("LANG_WELSH");
        SWITCH_SUBLANG()
        {
        case SUBLANG_WELSH_UNITED_KINGDOM: strSub = TEXT("SUBLANG_WELSH_UNITED_KINGDOM"); break;
        }
        break;
    case LANG_WOLOF: strPrim = TEXT("LANG_WOLOF");
        SWITCH_SUBLANG()
        {
        case SUBLANG_WOLOF_SENEGAL: strSub = TEXT("SUBLANG_WOLOF_SENEGAL"); break;
        }
        break;
    case LANG_XHOSA: strPrim = TEXT("LANG_XHOSA");
        SWITCH_SUBLANG()
        {
        case SUBLANG_XHOSA_SOUTH_AFRICA: strSub = TEXT("SUBLANG_XHOSA_SOUTH_AFRICA"); break;
        }
        break;
    //case LANG_YAKUT: strPrim = TEXT("LANG_YAKUT"); // same as LANG_SAKHA
    //    SWITCH_SUBLANG()
    //    {
    //    case SUBLANG_YAKUT_RUSSIA: strSub = TEXT("SUBLANG_YAKUT_RUSSIA"); break;
    //    }
    //    break;
    case LANG_YI: strPrim = TEXT("LANG_YI");
        SWITCH_SUBLANG()
        {
        case SUBLANG_YI_PRC: strSub = TEXT("SUBLANG_YI_PRC"); break;
        }
        break;
    case LANG_YORUBA: strPrim = TEXT("LANG_YORUBA");
        SWITCH_SUBLANG()
        {
        case SUBLANG_YORUBA_NIGERIA: strSub = TEXT("SUBLANG_YORUBA_NIGERIA"); break;
        }
        break;
    case LANG_ZULU: strPrim = TEXT("LANG_ZULU");
        SWITCH_SUBLANG()
        {
        case SUBLANG_ZULU_SOUTH_AFRICA: strSub = TEXT("SUBLANG_ZULU_SOUTH_AFRICA"); break;
        }
        break;
    default:
        break;
    }

    TCHAR szText[32];
    if (strPrim.empty())
    {
        StringCchPrintf(szText, _countof(szText), TEXT("0x%04X"), PRIMARYLANGID(langid));
        strPrim = szText;
    }

    if (bOldStyle)
        strSub.clear();

    // sub-language
    if (strSub.empty())
    {
        switch (SUBLANGID(langid))
        {
        case SUBLANG_NEUTRAL: strSub = TEXT("SUBLANG_NEUTRAL"); break;
        case SUBLANG_DEFAULT: strSub = TEXT("SUBLANG_DEFAULT"); break;
        case SUBLANG_SYS_DEFAULT: strSub = TEXT("SUBLANG_SYS_DEFAULT"); break;
        case SUBLANG_CUSTOM_DEFAULT: strSub = TEXT("SUBLANG_CUSTOM_DEFAULT"); break;
        case SUBLANG_CUSTOM_UNSPECIFIED: strSub = TEXT("SUBLANG_CUSTOM_UNSPECIFIED"); break;
        case SUBLANG_UI_CUSTOM_DEFAULT: strSub = TEXT("SUBLANG_UI_CUSTOM_DEFAULT"); break;
        default:
            break;
        }
    }

    // sub-language
    if (strSub.empty())
    {
        StringCchPrintf(szText, _countof(szText), TEXT("0x%04X"), SUBLANGID(langid));
        strSub = szText;
    }
#undef SWITCH_SUBLANG

    // output the LANGUAGE statement
    MString str = TEXT("LANGUAGE ");
    str += strPrim;
    str += TEXT(", ");
    str += strSub;
    str += TEXT("\r\n");

    return str;
}

// get the RISOHTEMPLATE text
MStringW GetRisohTemplate(const MIdOrString& type, WORD wLang)
{
    // get this application module
    HINSTANCE hInst = GetModuleHandle(NULL);

    if (type.empty())
    {
        return L"";    // failure
    }

    // try to find the RISOHTEMPLATE resource
    WORD LangID = PRIMARYLANGID(wLang);
    HRSRC hRsrc = NULL;
    if (hRsrc == NULL)
        hRsrc = FindResourceExW(hInst, L"RISOHTEMPLATE", type.ptr(), wLang);
    if (hRsrc == NULL)
        hRsrc = FindResourceExW(hInst, L"RISOHTEMPLATE", type.ptr(), MAKELANGID(LangID, SUBLANG_NEUTRAL));
    if (hRsrc == NULL)
        hRsrc = FindResourceExW(hInst, L"RISOHTEMPLATE", type.ptr(), MAKELANGID(LANG_ENGLISH, SUBLANG_ENGLISH_US));
    if (hRsrc == NULL)
        hRsrc = FindResourceExW(hInst, L"RISOHTEMPLATE", type.ptr(), MAKELANGID(LANG_ENGLISH, SUBLANG_NEUTRAL));
    if (hRsrc == NULL)
        hRsrc = FindResourceExW(hInst, L"RISOHTEMPLATE", type.ptr(), MAKELANGID(LANG_NEUTRAL, SUBLANG_NEUTRAL));
    if (hRsrc == NULL)
    {
        return L"";
    }

    // get the pointer and byte size
    HGLOBAL hGlobal = LoadResource(hInst, hRsrc);
    DWORD cb = SizeofResource(hInst, hRsrc);
    const BYTE *pb = (const BYTE *)LockResource(hGlobal);

    // ignore the BOM if any
    if (memcmp(pb, "\xEF\xBB\xBF", 3) == 0)
    {
        pb += 3;
        cb -= 3;
    }

    // convert the UTF-8 text to the UTF-16 text (wide)
    MStringA utf8((LPCSTR)(pb), (LPCSTR)(pb) + cb);
    MAnsiToWide wide(CP_UTF8, utf8);

    return wide.c_str();    // return the wide
}

////////////////////////////////////////////////////////////////////////////

static MMainWnd *s_pMainWnd = NULL;

bool MMainWnd::DoResLoad(const MStringW& filename, const MStringW& options)
{
    bool bOK;
    ++g_bNoGuiMode;
    BOOL bAutoLoadNearbyResH = g_settings.bAutoLoadNearbyResH;
    g_settings.bAutoLoadNearbyResH = options.find(L"(no-load-res-h)") != options.npos;
    {
        bOK = !!DoLoadFile(m_hwnd, filename.c_str(), 0, TRUE);
    }
    g_settings.bAutoLoadNearbyResH = bAutoLoadNearbyResH;
    --g_bNoGuiMode;
    return bOK;
}

bool MMainWnd::DoResSave(const MStringW& filename, const MStringW& options)
{
    bool bOK;
    ++g_bNoGuiMode;
    BOOL bUseIDC_STATIC = g_settings.bUseIDC_STATIC;
    BOOL bAskUpdateResH = g_settings.bAskUpdateResH;
    BOOL bCompressByUPX = g_settings.bCompressByUPX;
    BOOL bSepFilesByLang = g_settings.bSepFilesByLang;
    BOOL bStoreToResFolder = g_settings.bStoreToResFolder;
    BOOL bSelectableByMacro = g_settings.bSelectableByMacro;
    BOOL bRedundantComments = g_settings.bRedundantComments;
    BOOL bWrapManifest = g_settings.bWrapManifest;
    BOOL bUseBeginEnd = g_settings.bUseBeginEnd;
    BOOL bRCFileUTF16 = g_settings.bRCFileUTF16;
    BOOL bBackup = g_settings.bBackup;
    BOOL bUseMSMSGTABLE = g_settings.bUseMSMSGTABLE;
    g_settings.bUseIDC_STATIC = options.find(L"(idc-static)") != options.npos;
    g_settings.bAskUpdateResH = FALSE;
    g_settings.bCompressByUPX = options.find(L"(compress)") != options.npos;
    g_settings.bSepFilesByLang = options.find(L"(sep-lang)") != options.npos;
    g_settings.bStoreToResFolder = options.find(L"(no-res-folder)") == options.npos;
    g_settings.bSelectableByMacro = options.find(L"(lang-macro)") != options.npos;
    g_settings.bRedundantComments = options.find(L"(less-comments)") == options.npos;
    g_settings.bWrapManifest = options.find(L"(wrap-manifest)") != options.npos;
    g_settings.bUseBeginEnd = options.find(L"(begin-end)") != options.npos;
    g_settings.bRCFileUTF16 = options.find(L"(utf-16)") != options.npos;
    g_settings.bBackup = options.find(L"(backup)") != options.npos;
    g_settings.bUseMSMSGTABLE = options.find(L"(ms-msgtbl)") != options.npos;
    {
        bOK = !!DoSaveFile(m_hwnd, filename.c_str());
    }
    g_settings.bUseIDC_STATIC = bUseIDC_STATIC;
    g_settings.bAskUpdateResH = bAskUpdateResH;
    g_settings.bCompressByUPX = bCompressByUPX;
    g_settings.bSepFilesByLang = bSepFilesByLang;
    g_settings.bStoreToResFolder = bStoreToResFolder;
    g_settings.bSelectableByMacro = bSelectableByMacro;
    g_settings.bRedundantComments = bRedundantComments;
    g_settings.bWrapManifest = bWrapManifest;
    g_settings.bUseBeginEnd = bUseBeginEnd;
    g_settings.bRCFileUTF16 = bRCFileUTF16;
    g_settings.bBackup = bBackup;
    g_settings.bUseMSMSGTABLE = bUseMSMSGTABLE;

    --g_bNoGuiMode;
    return bOK;
}

EGA::arg_t EGA_FN EGA_RES_load(const EGA::args_t& args)
{
    return s_pMainWnd->RES_load(args);
}

EGA::arg_t EGA_FN EGA_RES_save(const EGA::args_t& args)
{
    return s_pMainWnd->RES_save(args);
}

EGA::arg_t EGA_FN EGA_RES_search(const EGA::args_t& args)
{
    return s_pMainWnd->RES_search(args);
}

EGA::arg_t EGA_FN EGA_RES_delete(const EGA::args_t& args)
{
    return s_pMainWnd->RES_delete(args);
}

EGA::arg_t EGA_FN EGA_RES_clone_by_name(const EGA::args_t& args)
{
    return s_pMainWnd->RES_clone_by_name(args);
}

EGA::arg_t EGA_FN EGA_RES_clone_by_lang(const EGA::args_t& args)
{
    return s_pMainWnd->RES_clone_by_lang(args);
}

EGA::arg_t EGA_FN EGA_RES_unload_resh(const EGA::args_t& args)
{
    return s_pMainWnd->RES_unload_resh(args);
}

EGA::arg_t EGA_FN EGA_RES_select(const EGA::args_t& args)
{
    return s_pMainWnd->RES_select(args);
}

EGA::arg_t EGA_FN EGA_RES_get_binary(const EGA::args_t& args)
{
    return s_pMainWnd->RES_get_binary(args);
}

EGA::arg_t EGA_FN EGA_RES_set_binary(const EGA::args_t& args)
{
    return s_pMainWnd->RES_set_binary(args);
}

EGA::arg_t EGA_FN EGA_RES_get_text(const EGA::args_t& args)
{
    return s_pMainWnd->RES_get_text(args[0], args[1], args[2]);
}

EGA::arg_t EGA_FN EGA_RES_set_text(const EGA::args_t& args)
{
    return s_pMainWnd->RES_set_text(args[0], args[1], args[2], args[3]);
}

EGA::arg_t EGA_FN EGA_RES_const(const EGA::args_t& args)
{
    return s_pMainWnd->RES_const(args);
}

EGA::arg_t EGA_FN EGA_RES_str_get(const EGA::args_t& args)
{
    if (args.size() == 1)
        return s_pMainWnd->RES_str_get(args[0]);
    else
        return s_pMainWnd->RES_str_get(args[0], args[1]);
}

EGA::arg_t EGA_FN EGA_RES_str_set(const EGA::args_t& args)
{
    if (args.size() == 2)
        return s_pMainWnd->RES_str_set(args[0], args[1]);
    else
        return s_pMainWnd->RES_str_set(args[0], args[1], args[2]);
}

MIdOrString EGA_get_id_or_str(const arg_t& arg0)
{
    MIdOrString ret;

    if (arg0->get_type() == AST_INT)
    {
        ret = (WORD)EGA_get_int(arg0);
    }
    else
    {
        std::string str = EGA_get_str(arg0);
        MAnsiToWide wide(CP_UTF8, str);
        ret = wide.c_str();
    }

    return ret;
}

EGA::arg_t EGA_set_id_or_str(const MIdOrString& id)
{
    if (id.is_str())
    {
        MWideToAnsi ansi(CP_UTF8, id.m_str);
        return EGA::make_arg<AstStr>(ansi.str());
    }
    else
    {
        return EGA::make_arg<AstInt>(id.m_id);
    }
}

EGA::arg_t MMainWnd::RES_load(const EGA::args_t& args)
{
    using namespace EGA;
    arg_t arg0, arg1;

    if (args.size() >= 1)
        arg0 = EGA_eval_arg(args[0], true);
    if (args.size() >= 2)
        arg1 = EGA_eval_arg(args[1], false);

    bool ret;
    MAnsiToWide str0(CP_UTF8, EGA_get_str(arg0));
    if (args.size() >= 2)
    {
        MAnsiToWide str1(CP_UTF8, EGA_get_str(arg1));
        ret = DoResLoad(str0.c_str(), str1.c_str());
    }
    else
    {
        ret = DoResLoad(str0.c_str(), L"");
    }

    return make_arg<AstInt>(ret);
}

EGA::arg_t MMainWnd::RES_save(const EGA::args_t& args)
{
    using namespace EGA;
    arg_t arg0, arg1;

    if (args.size() >= 1)
        arg0 = EGA_eval_arg(args[0], true);
    if (args.size() >= 2)
        arg1 = EGA_eval_arg(args[1], false);

    bool ret;
    MAnsiToWide str0(CP_UTF8, EGA_get_str(arg0));
    if (args.size() >= 2)
    {
        MAnsiToWide str1(CP_UTF8, EGA_get_str(arg1));
        ret = DoResSave(str0.c_str(), str1.c_str());
    }
    else
    {
        ret = DoResSave(str0.c_str(), L"");
    }

    return make_arg<AstInt>(ret);
}

EGA::arg_t MMainWnd::RES_search(const EGA::args_t& args)
{
    using namespace EGA;
    arg_t arg0, arg1, arg2;

    if (args.size() >= 1)
        arg0 = EGA_eval_arg(args[0], false);
    if (args.size() >= 2)
        arg1 = EGA_eval_arg(args[1], false);
    if (args.size() >= 3)
        arg2 = EGA_eval_arg(args[2], false);

    MIdOrString type, name;
    WORD lang = BAD_LANG;

    if (arg0)
        type = EGA_get_id_or_str(arg0);
    if (arg1)
        name = EGA_get_id_or_str(arg1);
    if (arg2)
        lang = (WORD)EGA_get_int(arg2);

    EntrySet found;
    g_res.search(found, ET_LANG, type, name, lang);

    auto array = make_arg<AstContainer>(AST_ARRAY, 0, "RES_LIST");
    for (auto& item : found)
    {
        auto child = make_arg<AstContainer>(AST_ARRAY, 0, "RES");
        child->add(EGA_set_id_or_str(item->m_type));
        child->add(EGA_set_id_or_str(item->m_name));
        child->add(EGA::make_arg<AstInt>(item->m_lang));
        array->add(child);
    }
    return array;
}

EGA::arg_t MMainWnd::RES_delete(const EGA::args_t& args)
{
    using namespace EGA;
    arg_t arg0, arg1, arg2;

    if (args.size() >= 1)
        arg0 = EGA_eval_arg(args[0], false);
    if (args.size() >= 2)
        arg1 = EGA_eval_arg(args[1], false);
    if (args.size() >= 3)
        arg2 = EGA_eval_arg(args[2], false);

    MIdOrString type, name;
    WORD lang = BAD_LANG;

    if (arg0)
        type = EGA_get_id_or_str(arg0);
    if (arg1)
        name = EGA_get_id_or_str(arg1);
    if (arg2)
        lang = (WORD)EGA_get_int(arg2);

    bool ret = g_res.search_and_delete(ET_ANY, type, name, lang);
    g_res.delete_invalid();

    if (ret)
    {
        DoSetFileModified(TRUE);

        SelectTV(NULL, FALSE);
    }

    PostMessageW(s_hMainWnd, WM_COMMAND, ID_REFRESHALL, 0);

    return make_arg<AstInt>(ret);
}

EGA::arg_t MMainWnd::RES_clone_by_name(const EGA::args_t& args)
{
    using namespace EGA;
    arg_t arg0, arg1, arg2;

    if (args.size() >= 1)
        arg0 = EGA_eval_arg(args[0], false);
    if (args.size() >= 2)
        arg1 = EGA_eval_arg(args[1], false);
    if (args.size() >= 3)
        arg2 = EGA_eval_arg(args[2], false);

    MIdOrString type, src_name, dest_name;
    WORD lang = BAD_LANG;

    if (arg0)
        type = EGA_get_id_or_str(arg0);
    if (arg1)
        src_name = EGA_get_id_or_str(arg1);
    if (arg2)
        dest_name = EGA_get_id_or_str(arg2);

    EntrySet found;
    g_res.search(found, ET_LANG, type, src_name, lang);

    if (type == RT_GROUP_ICON)     // group icon
    {
        for (auto e : found)
        {
            g_res.copy_group_icon(e, dest_name, e->m_lang);
        }
    }
    else if (type == RT_GROUP_CURSOR)  // group cursor
    {
        for (auto e : found)
        {
            g_res.copy_group_cursor(e, dest_name, e->m_lang);
        }
    }
    else    // otherwise
    {
        for (auto e : found)
        {
            g_res.add_lang_entry(e->m_type, dest_name, e->m_lang, e->m_data);
        }
    }

    g_res.delete_invalid();

    if (!found.empty())
        DoSetFileModified(TRUE);

    PostMessageW(s_hMainWnd, WM_COMMAND, ID_REFRESHALL, 0);

    return make_arg<AstInt>(!found.empty());
}

EGA::arg_t MMainWnd::RES_clone_by_lang(const EGA::args_t& args)
{
    using namespace EGA;
    arg_t arg0, arg1, arg2, arg3;

    if (args.size() >= 1)
        arg0 = EGA_eval_arg(args[0], false);
    if (args.size() >= 2)
        arg1 = EGA_eval_arg(args[1], false);
    if (args.size() >= 3)
        arg2 = EGA_eval_arg(args[2], false);
    if (args.size() >= 4)
        arg3 = EGA_eval_arg(args[3], false);

    MIdOrString type, name;
    WORD src_lang = BAD_LANG, dest_lang = BAD_LANG;

    if (arg0)
        type = EGA_get_id_or_str(arg0);
    if (arg1)
        name = EGA_get_id_or_str(arg1);
    if (arg2)
        src_lang = EGA_get_int(arg2);
    if (arg3)
        dest_lang = EGA_get_int(arg3);

    EntrySet found2;
    g_res.search(found2, ET_LANG, type, name, src_lang);

    for (auto& entry : found2)
    {
        if (entry->m_type == RT_GROUP_ICON)     // group icon
        {
            // search the group icons
            EntrySet found;
            g_res.search(found, ET_LANG, RT_GROUP_ICON, name, src_lang);

            // copy them
            for (auto e : found)
            {
                g_res.copy_group_icon(e, e->m_name, dest_lang);
            }
        }
        else if (entry->m_type == RT_GROUP_CURSOR)
        {
            // search the group cursors
            EntrySet found;
            g_res.search(found, ET_LANG, RT_GROUP_CURSOR, name, src_lang);

            // copy them
            for (auto e : found)
            {
                g_res.copy_group_cursor(e, e->m_name, dest_lang);
            }
        }
        else if (entry->m_et == ET_STRING)
        {
            // search the strings
            EntrySet found;
            g_res.search(found, ET_LANG, RT_STRING, WORD(0), src_lang);

            // copy them
            for (auto e : found)
            {
                g_res.add_lang_entry(e->m_type, e->m_name, dest_lang, e->m_data);
            }
        }
        else if (entry->m_et == ET_MESSAGE)
        {
            // search the messagetables
            EntrySet found;
            g_res.search(found, ET_LANG, RT_MESSAGETABLE, WORD(0), entry->m_lang);

            // copy them
            for (auto e : found)
            {
                g_res.add_lang_entry(e->m_type, e->m_name, dest_lang, e->m_data);
            }
        }
        else
        {
            // search the entries
            EntrySet found;
            g_res.search(found, ET_LANG, entry->m_type, entry->m_name, entry->m_lang);

            // copy them
            for (auto e : found)
            {
                g_res.add_lang_entry(e->m_type, e->m_name, dest_lang, e->m_data);
            }
        }
    }

    g_res.delete_invalid();

    if (!found2.empty())
        DoSetFileModified(TRUE);

    PostMessageW(s_hMainWnd, WM_COMMAND, ID_REFRESHALL, 0);

    return make_arg<AstInt>(!found2.empty());
}

EGA::arg_t MMainWnd::RES_const(const EGA::args_t& args)
{
    using namespace EGA;
    arg_t arg0 = EGA_eval_arg(args[0], true);
    std::string name = EGA_get_str(arg0);
    MAnsiToWide a2w(CP_ACP, name);

    ConstantsDB::ValueType value;
    BOOL bOK = g_db.GetValueOfName(a2w.c_str(), value);
    if (!bOK)
    {
        for (auto& pair : g_settings.id_map)
        {
            if (name == pair.first)
            {
                value = strtol(pair.second.c_str(), NULL, 0);
                bOK = TRUE;
                break;
            }
        }
    }

    return make_arg<AstInt>(bOK ? value : 0);
}

EGA::arg_t MMainWnd::RES_set_binary(const EGA::args_t& args)
{
    using namespace EGA;
    arg_t arg0, arg1, arg2, arg3;

    arg0 = EGA_eval_arg(args[0], true);
    arg1 = EGA_eval_arg(args[1], true);
    arg2 = EGA_eval_arg(args[2], true);
    arg3 = EGA_eval_arg(args[3], true);

    MIdOrString type, name;
    std::string contents;
    WORD lang;

    type = EGA_get_id_or_str(arg0);
    name = EGA_get_id_or_str(arg1);
    lang = EGA_get_int(arg2);
    contents = EGA_get_str(arg3);
    if (type.empty() || name.empty() || lang == BAD_LANG || contents.empty())
        return make_arg<AstInt>(0);

    int ret = 0;
    EntryBase::data_type data(contents.begin(), contents.end());
    if (g_res.add_lang_entry(type, name, lang, data))
        ret = 1;

    DoSetFileModified(TRUE);
    PostMessageW(s_hMainWnd, WM_COMMAND, ID_REFRESHALL, 0);

    return make_arg<AstInt>(ret);
}

EGA::arg_t MMainWnd::RES_get_binary(const EGA::args_t& args)
{
    using namespace EGA;
    arg_t arg0, arg1, arg2;

    if (args.size() >= 1)
        arg0 = EGA_eval_arg(args[0], false);
    if (args.size() >= 2)
        arg1 = EGA_eval_arg(args[1], false);
    if (args.size() >= 3)
        arg2 = EGA_eval_arg(args[2], false);

    MIdOrString type, name;
    WORD lang = BAD_LANG;

    if (arg0)
        type = EGA_get_id_or_str(arg0);
    if (arg1)
        name = EGA_get_id_or_str(arg1);
    if (arg2)
        lang = EGA_get_int(arg2);

    EntrySet found;
    g_res.search(found, ET_LANG, type, name, lang);

    std::string ret;
    if (found.size())
    {
        for (auto e : found)
        {
            ret.resize(e->size());
            memcpy(&ret[0], &e->m_data[0], e->size());
            break;
        }
    }

    return make_arg<AstStr>(ret);
}

EGA::arg_t MMainWnd::RES_get_text(EGA::arg_t arg0, EGA::arg_t arg1, EGA::arg_t arg2)
{
    using namespace EGA;

    arg0 = EGA_eval_arg(arg0, true);
    arg1 = EGA_eval_arg(arg1, true);
    arg2 = EGA_eval_arg(arg2, true);

    MIdOrString type = EGA_get_id_or_str(arg0);
    MIdOrString name = EGA_get_id_or_str(arg1);
    WORD lang = static_cast<WORD>(EGA_get_int(arg2));

    auto bHideID = g_settings.bHideID; // Save old value
    g_settings.bHideID = TRUE;

    std::wstring ret;
    auto entry = g_res.find(ET_LANG, type, name, lang);
    if (entry)
    {
        ResToText res2text;
        ret = res2text.DumpEntry(*entry);
    }

    g_settings.bHideID = bHideID;

    MWideToAnsi ansi(CP_UTF8, ret);
    return make_arg<AstStr>(ansi.str());
}

EGA::arg_t MMainWnd::RES_set_text(EGA::arg_t arg0, EGA::arg_t arg1, EGA::arg_t arg2, EGA::arg_t arg3)
{
    using namespace EGA;

    arg0 = EGA_eval_arg(arg0, true);
    arg1 = EGA_eval_arg(arg1, true);
    arg2 = EGA_eval_arg(arg2, true);
    arg3 = EGA_eval_arg(arg3, true);

    MIdOrString type = EGA_get_id_or_str(arg0);
    MIdOrString name = EGA_get_id_or_str(arg1);
    WORD lang = static_cast<WORD>(EGA_get_int(arg2));
    auto ansi = EGA_get_str(arg3);
    MAnsiToWide wide(CP_UTF8, ansi);

    MStringA strOutput;
    ++g_bNoGuiMode;
    BOOL ret = CompileParts(strOutput, type, name, lang, wide.str(), FALSE);
    --g_bNoGuiMode;

    DoSetFileModified(TRUE);
    PostMessageW(s_hMainWnd, WM_COMMAND, ID_REFRESHALL, 0);

    return make_arg<AstInt>(ret);
}

EGA::arg_t MMainWnd::RES_str_get(EGA::arg_t arg0)
{
    using namespace EGA;

    arg0 = EGA_eval_arg(arg0, true);
    WORD lang = static_cast<WORD>(EGA_get_int(arg0));

    EntrySet found;
    g_res.search(found, ET_LANG, RT_STRING, WORD(0), lang);
    if (found.empty())
        return make_arg<AstContainer>(); // error

    // found --> str_res
    StringRes str_res;
    for (auto e : found)
    {
        MByteStreamEx stream(e->m_data);
        if (!str_res.LoadFromStream(stream, e->m_name.m_id))
            return make_arg<AstContainer>(); // error
    }

    auto array1 = make_arg<AstContainer>();
    for (auto& pair : str_res.map())
    {
        MWideToAnsi ansi(CP_UTF8, pair.second);

        auto array2 = make_arg<AstContainer>();
        array2->add(make_arg<AstInt>(pair.first));
        array2->add(make_arg<AstStr>(ansi.str()));

        array1->add(array2);
    }

    return array1;
}

EGA::arg_t MMainWnd::RES_str_get(EGA::arg_t arg0, EGA::arg_t arg1)
{
    using namespace EGA;

    arg0 = EGA_eval_arg(arg0, true);
    arg1 = EGA_eval_arg(arg1, true);
    WORD lang = static_cast<WORD>(EGA_get_int(arg0));
    int index = EGA_get_int(arg1);
    if (index < 0)
        return make_arg<AstStr>(); // error

    EntrySet found;
    g_res.search(found, ET_LANG, RT_STRING, static_cast<WORD>(0), lang);
    if (found.empty())
        return make_arg<AstStr>(); // error

    // found --> str_res
    StringRes str_res;
    for (auto e : found)
    {
        MByteStreamEx stream(e->m_data);
        if (!str_res.LoadFromStream(stream, e->m_name.m_id))
            return make_arg<AstStr>(); // error
    }

    for (auto& pair : str_res.map())
    {
        if (pair.first == static_cast<WORD>(index))
        {
            MWideToAnsi ansi(CP_UTF8, pair.second);
            return make_arg<AstStr>(ansi.str());
        }
    }

    return make_arg<AstStr>(); // error
}

EGA::arg_t MMainWnd::RES_str_set(EGA::arg_t arg0, EGA::arg_t arg1)
{
    arg0 = EGA_eval_arg(arg0, true);
    arg1 = EGA_eval_arg(arg1, true);

    WORD lang = static_cast<WORD>(EGA_get_int(arg0));
    auto array1 = EGA_get_array(arg1);

    StringRes str_res;
    for (size_t i = 0; i < array1->size(); ++i)
    {
        auto ary2 = (*array1)[i];
        auto& array2 = *EGA_get_array(ary2);
        if (array2.size() != 2)
            throw EGA_index_out_of_range(array2.get_lineno());

        WORD str_id = static_cast<WORD>(EGA_get_int(array2[0]));
        auto str = EGA_get_str(array2[1]);

        MAnsiToWide wide(CP_UTF8, str);
        str_res.map()[str_id] = wide.c_str();
    }

    g_res.search_and_delete(ET_ANY, RT_STRING, (WORD)0, lang);

    std::set<WORD> names;
    for (auto& pair : str_res.map())
    {
        auto str_id = pair.first;
        WORD name = str_res.NameFromId(str_id);
        if (names.count(name) > 0)
            continue;
        names.insert(name);

        if (str_res.HasAnyValues(name))
        {
            MByteStreamEx stream;
            str_res.SaveToStream(stream, name);

            if (!g_res.add_lang_entry(RT_STRING, name, lang, stream.data()))
                return make_arg<AstInt>(0); // failed
        }
    }

    return make_arg<AstInt>(1); // success
}

EGA::arg_t MMainWnd::RES_str_set(EGA::arg_t arg0, EGA::arg_t arg1, EGA::arg_t arg2)
{
    arg0 = EGA_eval_arg(arg0, true);
    arg1 = EGA_eval_arg(arg1, true);
    arg2 = EGA_eval_arg(arg2, true);

    WORD lang = static_cast<WORD>(EGA_get_int(arg0));

    EntrySet found;
    g_res.search(found, ET_LANG, RT_STRING, WORD(0), lang);

    // found --> str_res
    StringRes str_res;
    for (auto e : found)
    {
        MByteStreamEx stream(e->m_data);
        if (!str_res.LoadFromStream(stream, e->m_name.m_id))
            return make_arg<AstInt>(0); // error
    }

    std::string str = EGA_get_str(arg2);
    MAnsiToWide wide(CP_UTF8, str);

    WORD str_id = static_cast<WORD>(EGA_get_int(arg1));
    str_res.map()[str_id] = wide;

    WORD name = str_res.NameFromId(str_id);

    if (str_res.HasAnyValues(name))
    {
        MByteStreamEx stream;
        str_res.SaveToStream(stream, name);

        if (!g_res.add_lang_entry(RT_STRING, name, lang, stream.data()))
            return make_arg<AstInt>(0); // error
    }
    else
    {
        g_res.search_and_delete(ET_ANY, RT_STRING, name, lang);
    }

    DoSetFileModified(TRUE);
    PostMessageW(s_hMainWnd, WM_COMMAND, ID_REFRESHALL, 0);

    return make_arg<AstInt>(1); // success
}

EGA::arg_t MMainWnd::RES_select(const EGA::args_t& args)
{
    using namespace EGA;
    arg_t arg0, arg1, arg2;

    if (args.size() >= 1)
        arg0 = EGA_eval_arg(args[0], false);
    if (args.size() >= 2)
        arg1 = EGA_eval_arg(args[1], false);
    if (args.size() >= 3)
        arg2 = EGA_eval_arg(args[2], false);

    MIdOrString type, name;
    WORD lang = BAD_LANG;

    if (arg0)
        type = EGA_get_id_or_str(arg0);
    if (arg1)
        name = EGA_get_id_or_str(arg1);
    if (arg2)
        lang = EGA_get_int(arg2);

    EntrySet found;
    g_res.search(found, ET_LANG, type, name, lang);

    if (found.size())
    {
        for (auto e : found)
        {
            SelectTV(e, FALSE);
            break;
        }
    }

    return make_arg<AstInt>(!found.empty());
}

EGA::arg_t MMainWnd::RES_unload_resh(const EGA::args_t& args)
{
    using namespace EGA;

    UnloadResourceH(m_hwnd);

    DoSetFileModified(TRUE);
    PostMessageW(s_hMainWnd, WM_COMMAND, ID_REFRESHALL, 0);

    return make_arg<AstInt>(1);
}

void EGA_extension(void)
{
    EGA_add_fn("RES_clone_by_lang", 4, 4, EGA_RES_clone_by_lang, "RES_clone_by_lang(type, name, src_lang, dest_lang)");
    EGA_add_fn("RES_clone_by_name", 3, 3, EGA_RES_clone_by_name, "RES_clone_by_name(type, src_name, dest_name)");
    EGA_add_fn("RES_delete", 0, 3, EGA_RES_delete, "RES_delete([type[, name[, lang]]])");
    EGA_add_fn("RES_get_binary", 0, 3, EGA_RES_get_binary, "RES_get_binary([type[, name[, lang]]])");
    EGA_add_fn("RES_set_binary", 4, 4, EGA_RES_set_binary, "RES_set_binary(type, name, lang, bin)");
    EGA_add_fn("RES_const", 1, 1, EGA_RES_const, "RES_const(name)");
    EGA_add_fn("RES_load", 1, 2, EGA_RES_load, "RES_load(filename[, options])");
    EGA_add_fn("RES_save", 1, 2, EGA_RES_save, "RES_save(filename[, options])");
    EGA_add_fn("RES_search", 0, 3, EGA_RES_search, "RES_search([type[, name[, lang]]])");
    EGA_add_fn("RES_select", 0, 3, EGA_RES_select, "RES_select([type[, name[, lang]]])");
    EGA_add_fn("RES_unload_resh", 0, 0, EGA_RES_unload_resh, "RES_unload_resh()");
    EGA_add_fn("RES_str_get", 1, 2, EGA_RES_str_get, "RES_str_get(lang[, str_id])");
    EGA_add_fn("RES_str_set", 2, 3, EGA_RES_str_set, "RES_str_set(lang, str_id, str) or RES_str_set(lang, ary)");
    EGA_add_fn("RES_get_text", 3, 3, EGA_RES_get_text, "RES_get_text(type, name, lang)");
    EGA_add_fn("RES_set_text", 4, 4, EGA_RES_set_text, "RES_set_text(type, name, lang, text)");
}

////////////////////////////////////////////////////////////////////////////

#ifdef _MSC_VER
    // the manifest information
    #pragma comment(linker, "/manifestdependency:\"type='win32' \
      name='Microsoft.Windows.Common-Controls' \
      version='6.0.0.0' \
      processorArchitecture='*' \
      publicKeyToken='6595b64144ccf1df' \
      language='*'\"")
#endif

BOOL MMainWnd::ParseCommandLine(HWND hwnd, INT argc, WCHAR **targv)
{
    LPWSTR file = NULL;
    BOOL bNoGUI = FALSE;
    m_commands.clear();
    for (INT iarg = 1; iarg < argc; ++iarg)
    {
        LPWSTR arg = targv[iarg];
        if (lstrcmpiW(arg, L"-help") == 0 ||
            lstrcmpiW(arg, L"--help") == 0 || 
            lstrcmpiW(arg, L"/?") == 0)
        {
            MessageBoxW(NULL, LoadStringDx(IDS_USAGE), LoadStringDx(IDS_APPNAME), MB_ICONINFORMATION);
            return FALSE;
        }
        if (lstrcmpiW(arg, L"-version") == 0 ||
            lstrcmpiW(arg, L"--version") == 0)
        {
            MessageBoxW(NULL, LoadStringDx(IDS_APPNAME), LoadStringDx(IDS_APPNAME), MB_ICONINFORMATION);
            return FALSE;
        }

        if (lstrcmpiW(arg, L"-load") == 0 ||
            lstrcmpiW(arg, L"--load") == 0)
        {
            bNoGUI = TRUE;
            arg = targv[++iarg];
            m_commands += L"load:";
            m_commands += arg;
            m_commands += L"\n";
            continue;
        }
        if (lstrcmpiW(arg, L"-load-options") == 0 ||
            lstrcmpiW(arg, L"--load-options") == 0)
        {
            arg = targv[++iarg];
            m_load_options = arg;
            continue;
        }

        if (lstrcmpiW(arg, L"-save") == 0 ||
            lstrcmpiW(arg, L"--save") == 0)
        {
            bNoGUI = TRUE;
            arg = targv[++iarg];
            m_commands += L"save:";
            m_commands += arg;
            m_commands += L"\n";
        }
        if (lstrcmpiW(arg, L"-save-options") == 0 ||
            lstrcmpiW(arg, L"--save-options") == 0)
        {
            arg = targv[++iarg];
            m_save_options = arg;
            continue;
        }

        if (lstrcmpiW(arg, L"-log-file") == 0 ||
            lstrcmpiW(arg, L"--log-file") == 0)
        {
            arg = targv[++iarg];
            g_pszLogFile = arg;
            continue;
        }

        if (PathFileExistsW(arg))
        {
            if (!file)
                file = arg;
            continue;
        }
    }

    if (file && !bNoGUI)
    {
        // load the file now
        DoLoadFile(hwnd, file);
        return TRUE;
    }
    else if (bNoGUI)
    {
        ++g_bNoGuiMode;
        return TRUE;
    }

    return FALSE;
}

LANGID GetUILang(void)
{
    DWORD langid = ::GetThreadUILanguage();

#ifdef PORTABLE
    MRegKeyPortable keyRisoh(TEXT("RisohEditor"), NULL);
#else
    // open the "HKEY_CURRENT_USER\Software\Katayama Hirofumi MZ\RisohEditor" key
    MRegKey keyRisoh(HKCU, TEXT("Software\\Katayama Hirofumi MZ\\RisohEditor"));
    if (!keyRisoh)
        return LANGID(langid);
#endif
    keyRisoh.QueryDword(TEXT("UILanguage"), (DWORD&)langid);
    if (langid == 0)
        langid = GetThreadUILanguage();
    return LANGID(langid);
}

// the main function of the windows application
extern "C"
INT WINAPI
wWinMain(HINSTANCE   hInstance,
         HINSTANCE   hPrevInstance,
         LPWSTR       lpCmdLine,
         INT         nCmdShow)
{
    SetEnvironmentVariableW(L"LANG", L"en_US");
    setlocale(LC_CTYPE, "");

    // set the UI language
    s_ui_lang = GetUILang();
    SetThreadUILanguage(LANGID(s_ui_lang));

    // initialize the libraries
    OleInitialize(NULL);

    // register MOleSite window class
    MOleSite::RegisterDx();

    // initialize common controls
    INITCOMMONCONTROLSEX iccx;
    iccx.dwSize = sizeof(iccx);
    iccx.dwICC = ICC_WIN95_CLASSES |
                 ICC_DATE_CLASSES |
                 ICC_USEREX_CLASSES |
                 ICC_COOL_CLASSES |
                 ICC_INTERNET_CLASSES |
                 ICC_PAGESCROLLER_CLASS |
                 ICC_NATIVEFNTCTL_CLASS |
                 ICC_STANDARD_CLASSES |
                 ICC_LINK_CLASS;
    InitCommonControlsEx(&iccx);

    // load RichEdit
    HINSTANCE hinstRichEdit = LoadLibrary(TEXT("RICHED32.DLL"));

    HINSTANCE hinstUXTheme = LoadLibrary(TEXT("UXTHEME.DLL"));
    FARPROC fn = GetProcAddress(hinstUXTheme, "SetWindowTheme");
    s_pSetWindowTheme = *reinterpret_cast<SETWINDOWTHEME *>(&fn);

    // load LineNumEdit
    LineNumEdit::SuperclassWindow();

    // load GDI+
    Gdiplus::GdiplusStartupInput gp_startup_input;
    ULONG_PTR gp_token;
    Gdiplus::GdiplusStartup(&gp_token, &gp_startup_input, NULL);

    // main process
    s_ret = 0;
    MEditCtrl::SetCtrlAHookDx(TRUE);
    {
#ifdef ATL_SUPPORT
        ::AtlAxWinInit();
        CComModule _Module;
#endif
        {
            MMainWnd app(__argc, __targv, hInstance);
            s_pMainWnd = &app;

            if (app.StartDx())
            {
                // main loop
                app.RunDx();
            }
            else
            {
                s_ret = 2;
            }
        }
#ifdef ATL_SUPPORT
        ::AtlAxWinTerm();
#endif
    }
    MEditCtrl::SetCtrlAHookDx(FALSE);

    // free GDI+
    Gdiplus::GdiplusShutdown(gp_token);

    // free the libraries
    FreeLibrary(hinstRichEdit);
    FreeLibrary(hinstUXTheme);
    OleUninitialize();
    FreeWCLib();

    // check object counts
    assert(MacroParser::BaseAst::alive_count() == 0);

#if (WINVER >= 0x0500)
    HANDLE hProcess = GetCurrentProcess();
    DebugPrintDx(TEXT("Count of GDI objects: %ld\n"),
                 GetGuiResources(hProcess, GR_GDIOBJECTS));
    DebugPrintDx(TEXT("Count of USER objects: %ld\n"),
                 GetGuiResources(hProcess, GR_USEROBJECTS));
#endif

#if defined(_MSC_VER) && !defined(NDEBUG)
    // for detecting memory leak (MSVC only)
    _CrtSetDbgFlag(_CRTDBG_ALLOC_MEM_DF | _CRTDBG_LEAK_CHECK_DF);
#endif

    return s_ret;
}

//////////////////////////////////////////////////////////////////////////////

```

`src/RisohEditor.hpp`:

```hpp
// RisohEditor.hpp --- RisohEditor header
//////////////////////////////////////////////////////////////////////////////
// RisohEditor --- Another free Win32 resource editor
// Copyright (C) 2017-2021 Katayama Hirofumi MZ <katayama.hirofumi.mz@gmail.com>
// 
// This program is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
// 
// This program is distributed in the hope that it will be useful, 
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
// 
// You should have received a copy of the GNU General Public License
// along with this program.  If not, see <http://www.gnu.org/licenses/>.
//////////////////////////////////////////////////////////////////////////////

#pragma once

#include <initguid.h>
#include <windows.h>
#include <windowsx.h>
#include <shlobj.h>
#include <shlwapi.h>
#include <dlgs.h>
#include <tchar.h>
#include <commctrl.h>
#include <commdlg.h>
#include <mbstring.h>
#include <mmsystem.h>
#include <process.h>
#include <uxtheme.h>
#include <urlmon.h>
#include <wininet.h>
#ifdef ATL_SUPPORT
    #include <cguid.h>
    #include <atlbase.h>
    #include <atlhost.h>
#endif

#include <algorithm>    // for std::sort
#include <string>       // for std::string, std::wstring
#include <cassert>      // for assert macro
#include <vector>       // for std::vector
#include <map>          // for std::map
#include <cstdio>
#include <clocale>
#include <strsafe.h>

////////////////////////////////////////////////////////////////////////////

INT LogMessageBoxW(HWND hwnd, LPCWSTR text, LPCWSTR title, UINT uType);

#include "WonSetThreadUILanguage.h"

#include "resource.h"
#include "MWindowBase.hpp"
#include "MEditCtrl.hpp"
#include "MSplitterWnd.hpp"
#include "MBitmapDx.hpp"
#include "Res.hpp"
#include "ConstantsDB.hpp"
#include "MacroParser.hpp"
#include "MWaitCursor.hpp"
#include "RisohSettings.hpp"

// RisohEditor.cpp
BOOL GetPathOfShortcutDx(HWND hwnd, LPCWSTR pszLnkFile, LPWSTR pszPath);
BOOL DumpBinaryFileDx(const WCHAR *filename, LPCVOID pv, DWORD size);
HBITMAP CreateBitmapFromIconDx(HICON hIcon, INT width, INT height, BOOL bCursor);

////////////////////////////////////////////////////////////////////////////

#include "MRadWindow.hpp"
#include "MReplaceBinDlg.hpp"
#include "MTestMenuDlg.hpp"
#include "MTestDialog.hpp"
#include "MAddIconDlg.hpp"
#include "MReplaceIconDlg.hpp"
#include "MReplaceCursorDlg.hpp"
#include "MAddBitmapDlg.hpp"
#include "MReplaceBitmapDlg.hpp"
#include "MAddCursorDlg.hpp"
#include "MAddResDlg.hpp"
#include "MStringsDlg.hpp"
#include "MMessagesDlg.hpp"
#include "MEditMenuDlg.hpp"
#include "MEditToolbarDlg.hpp"
#include "MEditAccelDlg.hpp"
#include "MIdAssocDlg.hpp"
#include "MBmpView.hpp"
#include "MIDListDlg.hpp"
#include "MConfigDlg.hpp"
#include "MAdviceResHDlg.hpp"
#include "MCloneInNewNameDlg.hpp"
#include "MCloneInNewLangDlg.hpp"
#include "MCopyToMultiLangDlg.hpp"
#include "MItemSearchDlg.hpp"
#include "MVersionInfoDlg.hpp"
#include "MFontsDlg.hpp"
#include "MMacrosDlg.hpp"
#include "MPathsDlg.hpp"
#include "MExportOptionsDlg.hpp"
#include "MSaveOptionsDlg.hpp"
#include "MLangsDlg.hpp"
#include "MTestParentWnd.hpp"
#include "MDlgInitDlg.hpp"
#include "MEncodingDlg.hpp"
#include "MConstantDlg.hpp"
#include "MEgaDlg.hpp"
#include "MDialogFontSubstDlg.hpp"
#include "MDropdownArrow.hpp"
#include "MTabCtrl.hpp"
#include "MDfmSettingsDlg.hpp"

#include "MString.hpp"
#include "MByteStream.hpp"

#include "AccelRes.hpp"
#include "IconRes.hpp"
#include "MenuRes.hpp"
#include "MessageRes.hpp"
#include "StringRes.hpp"
#include "DialogRes.hpp"
#include "VersionRes.hpp"
#include "DlgInitRes.hpp"

#include "ConstantsDB.hpp"
#include "PackedDIB.hpp"
#include "Res.hpp"
#include "ResHeader.hpp"

#include "MFile.hpp"
#include "MProcessMaker.hpp"

#include "ResToText.hpp"

```

`src/RisohEditor_res.rc`:

```rc
// RisohEditor_res.rc
// This file is automatically generated by RisohEditor 5.7.9.
// † <-- This dagger helps UTF-8 detection.

#include "resource.h"
#define APSTUDIO_HIDDEN_SYMBOLS
#include <windows.h>
#include <commctrl.h>
#undef APSTUDIO_HIDDEN_SYMBOLS
#pragma code_page(65001) // UTF-8

LANGUAGE LANG_NEUTRAL, SUBLANG_NEUTRAL

//////////////////////////////////////////////////////////////////////////////
// RT_BITMAP

IDB_BMP BITMAP "res/Bitmap_100.bmp"

IDB_CONTROLS BITMAP "res/Bitmap_101.bmp"

IDB_TOOLBAR BITMAP "res/Bitmap_102.bmp"

//////////////////////////////////////////////////////////////////////////////
// RT_DIALOG

IDD_UILANG DIALOG 0, 0, 225, 55
CAPTION "UI Language Select (UI语言选择)"
STYLE DS_CENTER | DS_MODALFRAME | WS_POPUPWINDOW | WS_CAPTION
FONT 12, "MS Shell Dlg"
{
    LTEXT "&UI Language:", -1, 5, 5, 67, 11
    COMBOBOX cmb3, 80, 5, 140, 300, CBS_HASSTRINGS | CBS_AUTOHSCROLL | CBS_DROPDOWN | WS_VSCROLL | WS_TABSTOP
    DEFPUSHBUTTON "OK", IDOK, 95, 35, 60, 14
    PUSHBUTTON "Cancel", IDCANCEL, 160, 35, 60, 14
    LTEXT "* Effective on next startup (在下次启动时生效)", -1, 5, 20, 215, 12
    PUSHBUTTON "&Reset", psh1, 5, 35, 60, 14
}

STRINGID DIALOG 0, 0, 205, 90
CAPTION "StringID"
STYLE DS_MODALFRAME | WS_POPUPWINDOW | WS_CAPTION
FONT 9, "MS Shell Dlg"
{
    DEFPUSHBUTTON "OK", IDOK, 75, 70, 60, 14
    PUSHBUTTON "Cancel", IDCANCEL, 140, 70, 60, 14
}

//////////////////////////////////////////////////////////////////////////////
// RT_ACCELERATOR

IDR_MAINACCEL ACCELERATORS
{
    "N", ID_NEW, CONTROL, VIRTKEY
    "O", ID_OPEN, CONTROL, VIRTKEY
    "S", ID_SAVE, CONTROL, VIRTKEY
    "S", ID_SAVEAS, CONTROL, SHIFT, VIRTKEY
    "I", ID_IMPORT, CONTROL, VIRTKEY
    "P", ID_EXPORT, CONTROL, VIRTKEY
    "E", ID_CANCELEDIT, CONTROL, VIRTKEY
    "G", ID_GUIEDIT, CONTROL, VIRTKEY
    "T", ID_TEXTEDIT, CONTROL, VIRTKEY
    VK_F8, ID_COMPILE, VIRTKEY
    "R", ID_LOADRESH, CONTROL, VIRTKEY
    "F", ID_FIND, CONTROL, VIRTKEY
    "H", ID_REPLACE, CONTROL, VIRTKEY
    VK_F3, ID_FINDUPWARD, SHIFT, VIRTKEY
    VK_F3, ID_FINDDOWNWARD, VIRTKEY
    "L", ID_DEBUGTREENODE, CONTROL, SHIFT, VIRTKEY
    "K", ID_EXPAND_ALL, CONTROL, VIRTKEY
    "L", ID_COLLAPSE_ALL, CONTROL, VIRTKEY
    VK_F1, ID_HELP, VIRTKEY
    VK_F5, ID_REFRESHALL, VIRTKEY
    VK_F6, ID_NEXTPANE, VIRTKEY
    VK_F6, ID_PREVPANE, SHIFT, VIRTKEY
}

//////////////////////////////////////////////////////////////////////////////
// RT_RCDATA

IDR_MAINFRAME RCDATA "res/RCData_100.bin"

IDR_TINYEXE RCDATA "res/RCData_106.bin"

IDR_TINYDLL RCDATA "res/RCData_107.bin"

//////////////////////////////////////////////////////////////////////////////
// RT_GROUP_CURSOR

IDC_CURSORNS CURSOR "res/Cursor_101.cur"

IDC_CURSORWE CURSOR "res/Cursor_102.cur"

//////////////////////////////////////////////////////////////////////////////
// RT_GROUP_ICON

IDI_MAIN ICON "res/Icon_100.ico"

IDI_ICO ICON "res/Icon_101.ico"

IDI_SMILY ICON "res/Icon_102.ico"

IDI_FIND ICON "res/Icon_103.ico"

IDI_FILE ICON "res/Icon_104.ico"

IDI_FOLDER ICON "res/Icon_105.ico"

IDI_PLAY ICON "res/Icon_106.ico"

IDI_DIAMOND ICON "res/Icon_107.ico"

IDI_MARK ICON "res/Icon_108.ico"

IDI_ARROW ICON "res/Icon_109.ico"

IDI_DFMICON ICON "res/Icon_110.ico"

//////////////////////////////////////////////////////////////////////////////
// RT_ANICURSOR

IDR_BOUNCEANICUR ANICURSOR "res/AniCursor_103.ani"

//////////////////////////////////////////////////////////////////////////////
// RT_MANIFEST

1 24 "res/Manifest_1.manifest"

//////////////////////////////////////////////////////////////////////////////
// RT_DLGINIT

IDD_ADDDLGINIT 240
{
    cmb2, 0x0143, 0x000D, 0, 0x4243, 0x415F, 0x4444, 0x5453, 0x4952, 0x474E, "\000", 
    cmb2, 0x0143, 0x000D, 0, 0x424C, 0x415F, 0x4444, 0x5453, 0x4952, 0x474E, "\000", 
    cmb2, 0x0143, 0x0010, 0, 0x4243, 0x4D45, 0x495F, 0x534E, 0x5245, 0x4954, 0x4554, 0x004D, 
    0
}

IDD_MODIFYDLGINIT 240
{
    cmb2, 0x0143, 0x000D, 0, 0x4243, 0x415F, 0x4444, 0x5453, 0x4952, 0x474E, "\000", 
    cmb2, 0x0143, 0x000D, 0, 0x424C, 0x415F, 0x4444, 0x5453, 0x4952, 0x474E, "\000", 
    cmb2, 0x0143, 0x0010, 0, 0x4243, 0x4D45, 0x495F, 0x534E, 0x5245, 0x4954, 0x4554, 0x004D, 
    0
}

//////////////////////////////////////////////////////////////////////////////
// 999

IDR_UNKNOWNRESID 999 "res/999_105.bin"

//////////////////////////////////////////////////////////////////////////////
// AVI

IDR_MAINFRAME AVI "res/Avi_100.avi"

//////////////////////////////////////////////////////////////////////////////
// EMF

IDR_MAINFRAME EMF "res/Emf_100.emf"

//////////////////////////////////////////////////////////////////////////////
// GIF

IDR_MAINFRAME GIF "res/Gif_100.gif"

//////////////////////////////////////////////////////////////////////////////
// PNG

IDR_MAINFRAME PNG "res/Png_100.png"

//////////////////////////////////////////////////////////////////////////////
// RISOHTEMPLATE

6 RISOHTEMPLATE "res/RISOHTEMPLATE_6.bin"

9 RISOHTEMPLATE "res/RISOHTEMPLATE_9.bin"

11 RISOHTEMPLATE "res/RISOHTEMPLATE_11.bin"

16 RISOHTEMPLATE "res/RISOHTEMPLATE_16.bin"

23 RISOHTEMPLATE "res/RISOHTEMPLATE_23.bin"

24 RISOHTEMPLATE "res/RISOHTEMPLATE_24.bin"

241 RISOHTEMPLATE "res/RISOHTEMPLATE_241.bin"

RISOHTEMPLATE RISOHTEMPLATE "res/RISOHTEMPLATE_RISOHTEMPLATE.bin"

//////////////////////////////////////////////////////////////////////////////
// WAVE

IDR_MAINFRAME WAVE "res/Wave_100.wav"

//////////////////////////////////////////////////////////////////////////////
// Languages

#include "lang/de_DE.rc"
#include "lang/en_US.rc"
#include "lang/fi_FI.rc"
#include "lang/fr_FR.rc"
#include "lang/id_ID.rc"
#include "lang/it_IT.rc"
#include "lang/ja_JP.rc"
#include "lang/ko_KR.rc"
#include "lang/pl_PL.rc"
#include "lang/pt_BR.rc"
#include "lang/ru_RU.rc"
#include "lang/zh_CN.rc"
#include "lang/zh_TW.rc"

//////////////////////////////////////////////////////////////////////////////
// TEXTINCLUDE

#ifdef APSTUDIO_INVOKED

1 TEXTINCLUDE
BEGIN
    "resource.h\0"
END

2 TEXTINCLUDE
BEGIN
    "#define APSTUDIO_HIDDEN_SYMBOLS\r\n"
    "#include <windows.h>\r\n"
    "#include <commctrl.h>\r\n"
    "#undef APSTUDIO_HIDDEN_SYMBOLS\r\n"
    "\0"
END

3 TEXTINCLUDE
BEGIN
    "\r\n"
    "\0"
END

#endif    // APSTUDIO_INVOKED

//////////////////////////////////////////////////////////////////////////////

```

`src/RisohSettings.hpp`:

```hpp
// RisohSettings.hpp --- RisohEditor settings
//////////////////////////////////////////////////////////////////////////////
// RisohEditor --- Another free Win32 resource editor
// Copyright (C) 2017-2021 Katayama Hirofumi MZ <katayama.hirofumi.mz@gmail.com>
// 
// This program is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
// 
// This program is distributed in the hope that it will be useful, 
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
// 
// You should have received a copy of the GNU General Public License
// along with this program.  If not, see <http://www.gnu.org/licenses/>.
//////////////////////////////////////////////////////////////////////////////

#pragma once

#include "MWindowBase.hpp"
#include "MIdOrString.hpp"
#include <vector>
#include <map>

//////////////////////////////////////////////////////////////////////////////

#define MAX_MRU     5       // the number of most recently used (MRU) files

typedef std::vector<MString>            mru_type;           // MRU list type
typedef std::map<MString, MString>      assoc_map_type;     // association type
typedef std::map<MStringA, MStringA>    id_map_type;        // ID mapping type
typedef std::map<MString, MString>      macro_map_type;     // macros type
typedef std::map<MString, MString>      encoding_map_type;  // text resource encoding
typedef std::vector<MString>            include_dirs_type;  // includes type
typedef std::vector<MString>            captions_type;      // captions type

//////////////////////////////////////////////////////////////////////////////

struct RisohSettings
{
    BOOL        bShowBinEdit;           // show the binary EDIT control?
    BOOL        bAlwaysControl;         // always show CONTROL statements?
    BOOL        bShowStatusBar;         // show the status bar?
    INT         nTreeViewWidth;         // the treeview width
    INT         nBmpViewWidth;          // the MBmpview width
    BOOL        bGuiByDblClick;         // start GUI edit by double click?
    BOOL        bResumeWindowPos;       // resume the window position?
    BOOL        bAutoLoadNearbyResH;    // auto loading resource.h?
    BOOL        bAutoShowIDList;        // auto show ID list window?
    BOOL        bHideID;                // don't show ID macros?
    BOOL        bUseIDC_STATIC;         // use IDC_STATIC?
    BOOL        bShowDotsOnDialog;      // show dots on the dialog?
    INT         nComboHeight;           // the combobox height
    mru_type    vecRecentlyUsed;        // the MRU files
    INT         nWindowLeft;            // the main window X coordinate
    INT         nWindowTop;             // the main window Y coordinate
    INT         nWindowWidth;           // the main window width
    INT         nWindowHeight;          // the main window height
    BOOL        bMaximized;             // is the main window maximized?
    INT         nIDListLeft;            // the ID list X coordinate
    INT         nIDListTop;             // the ID list Y coordinate
    INT         nIDListWidth;           // the ID list width
    INT         nIDListHeight;          // the ID list height
    INT         nRadLeft;               // the RAD window X coordinate
    INT         nRadTop;                // the RAD window Y coordinate
    BOOL        bAskUpdateResH;         // ask update the resource.h file?
    BOOL        bCompressByUPX;         // compress the file by UPX?
    MString     strSrcFont;             // the source view font name
    INT         nSrcFontSize;           // the source view font size in points
    MString     strBinFont;             // the binary view font name
    INT         nBinFontSize;           // the binary view font size in points
    assoc_map_type      assoc_map;      // the ID association
    id_map_type         id_map;         // the macro ID mapping
    id_map_type         added_ids;      // the added macro IDs
    id_map_type         removed_ids;    // the removed macro IDs
    macro_map_type      macros;         // the predefined macros
    include_dirs_type   includes;       // the #include's directories
    MString             strWindResExe;  // the windres.exe location
    MString             strCppExe;      // the cpp.exe location
    MString             strPrevVersion;     // the previous RisohEditor version
    BOOL                bSepFilesByLang;    // use the "lang" folder to export and/or save?
    BOOL                bStoreToResFolder;  // store to the "res" folder?
    BOOL                bSelectableByMacro; // choose languages by macros?
    captions_type       captions;           // the remembered captions
    BOOL                bShowToolBar;       // show the toolbar?
    MString             strAtlAxWin;        // ATL OLE control name
    INT                 nSaveFilterIndex;   // the filter index on save
    BOOL                bWordWrap;          // do word wrap?
    BOOL                bBackup;            // do backup?
    MString             strBackupSuffix;    // backup suffix
    BOOL                bRedundantComments; // output redundant comments?
    BOOL                bWrapManifest;      // wrap manifest statements by #ifndef MSVC ... #endif?
    encoding_map_type   encoding_map;       // text resource encoding
    BOOL                bRCFileUTF16;       // output RC files as UTF-16?
    BOOL                bUseBeginEnd;       // Use BEGIN/END instead of braces?
    BOOL                bShowFullPath;      // Show full path on title bar
    INT                 nDfmCodePage;       // Delphi DFM Data codepage
    BOOL                bDfmRawTextComments; // Delphi DFM raw text comments
    BOOL                bDfmNoUnicode;      // Don't use Unicode nor UTF-8 in Delphi DFM
    BOOL                bUseMSMSGTABLE;     // Use Microsoft's MESSAGETABLE
    INT                 nEgaX;
    INT                 nEgaY;
    INT                 nEgaWidth;
    INT                 nEgaHeight;
    MString             strFontReplaceFrom1;
    MString             strFontReplaceFrom2;
    MString             strFontReplaceFrom3;
    MString             strFontReplaceTo1;
    MString             strFontReplaceTo2;
    MString             strFontReplaceTo3;

    RisohSettings()
    {
    }

    bool IsIDMapEmpty() const
    {
        if (id_map.empty())
            return true;
        if (id_map.size() == 1 && id_map.begin()->first == "IDC_STATIC")
            return true;
        return false;
    }

    void AddCaption(LPCTSTR pszCaption)
    {
        if (!pszCaption || !pszCaption[0])
            return;

        for (size_t i = 0; i < captions.size(); ++i)
        {
            if (captions[i] == pszCaption)
            {
                captions.erase(captions.begin() + i);
                break;
            }
        }

        captions.insert(captions.begin(), pszCaption);
    }

    void AddFile(LPCTSTR pszFile)
    {
        for (size_t i = 0; i < vecRecentlyUsed.size(); ++i)
        {
            if (vecRecentlyUsed[i] == pszFile)
            {
                vecRecentlyUsed.erase(vecRecentlyUsed.begin() + i);
                break;
            }
        }
        vecRecentlyUsed.insert(vecRecentlyUsed.begin(), pszFile);
        if (vecRecentlyUsed.size() > MAX_MRU)
            vecRecentlyUsed.resize(MAX_MRU);
    }

    void AddIDC_STATIC()
    {
        id_map["IDC_STATIC"] = "-1";
        added_ids["IDC_STATIC"] = "-1";
        removed_ids["IDC_STATIC"] = "-1";
    }

    void ResetEncoding()
    {
        encoding_map.clear();
        encoding_map[L"RISOHTEMPLATE"] = L"utf8";
        encoding_map[L"REGISTRY"] = L"ansi";
        encoding_map[L"XML"] = L"utf8";
        encoding_map[L"XSLT"] = L"utf8";
        encoding_map[L"SCHEMA"] = L"utf8";
        encoding_map[L"REGINST"] = L"ansi";
        encoding_map[mstr_dec((WORD)(UINT_PTR)RT_DLGINCLUDE)] = L"utf8n";
    }

    void ResetAssoc()
    {
        assoc_map[L"Cursor.ID"] = L"IDC_";
        assoc_map[L"Bitmap.ID"] = L"IDB_";
        assoc_map[L"Menu.ID"] = L"IDR_";
        assoc_map[L"Dialog.ID"] = L"IDD_";
        assoc_map[L"String.ID"] = L"IDS_";
        assoc_map[L"Accel.ID"] = L"IDR_";
        assoc_map[L"Icon.ID"] = L"IDI_";
        assoc_map[L"AniCursor.ID"] = L"IDR_";
        assoc_map[L"AniIcon.ID"] = L"IDR_";
        assoc_map[L"Html.ID"] = L"IDR_";
        assoc_map[L"Help.ID"] = L"HID_";
        assoc_map[L"Command.ID"] = L"IDM_";
        assoc_map[L"Control.ID"] = L"IDC_";
        assoc_map[L"Resource.ID"] = L"IDR_";
        assoc_map[L"Message.ID"] = L"MSGID_";
        assoc_map[L"Window.ID"] = L"IDW_";
        assoc_map[L"New.Command.ID"] = L"ID_";
        assoc_map[L"Prompt.ID"] = L"IDP_";
        assoc_map[L"RCData.ID"] = L"IDR_";
        assoc_map[L"Unknown.ID"].clear();
    }

    void ResetMacros()
    {
        macros.clear();

#define DEF_VALUE(x, val)         macros.insert(std::make_pair(TEXT(#x), TEXT(#val)))
        // TODO: update these values
        DEF_VALUE(_WIN32, 1);
        DEF_VALUE(__GNUC__, 10);
        DEF_VALUE(__GNUC_MINOR__, 2);
        DEF_VALUE(__GNUC_PATCHLEVEL__, 0);
        //#ifdef _WIN64
        //    DEF_VALUE(_WIN64, 1);
        //    DEF_VALUE(__x86_64, 1);
        //    DEF_VALUE(__x86_64__, 1);
        //    DEF_VALUE(__amd64, 1);
        //    DEF_VALUE(__amd64__, 1);
        //#else
            DEF_VALUE(_X86_, 1);
            DEF_VALUE(__i386, 1);
            DEF_VALUE(__i386__, 1);
        //#endif
#undef DEF_VALUE

#define DEF_LANG(lang) macros.insert(std::make_pair(TEXT(lang), TEXT("")))
    DEF_LANG("LANGUAGE_AR_SA");
    DEF_LANG("LANGUAGE_BG_BG");
    DEF_LANG("LANGUAGE_ZH_CN");
    DEF_LANG("LANGUAGE_ZH_TW");
    DEF_LANG("LANGUAGE_HR_HR");
    DEF_LANG("LANGUAGE_CS_CZ");
    DEF_LANG("LANGUAGE_DA_DK");
    DEF_LANG("LANGUAGE_NL_NL");
    DEF_LANG("LANGUAGE_EN_US");
    DEF_LANG("LANGUAGE_EN_GB");
    DEF_LANG("LANGUAGE_ET_EE");
    DEF_LANG("LANGUAGE_FI_FI");
    DEF_LANG("LANGUAGE_FR_CA");
    DEF_LANG("LANGUAGE_FR_FR");
    DEF_LANG("LANGUAGE_DE_DE");
    DEF_LANG("LANGUAGE_EL_GR");
    DEF_LANG("LANGUAGE_HE_IL");
    DEF_LANG("LANGUAGE_HU_HU");
    DEF_LANG("LANGUAGE_IT_IT");
    DEF_LANG("LANGUAGE_JA_JP");
    DEF_LANG("LANGUAGE_KO_KR");
    DEF_LANG("LANGUAGE_LV_LV");
    DEF_LANG("LANGUAGE_LT_LT");
    DEF_LANG("LANGUAGE_NB_NO");
    DEF_LANG("LANGUAGE_PL_PL");
    DEF_LANG("LANGUAGE_PT_BR");
    DEF_LANG("LANGUAGE_PT_PT");
    DEF_LANG("LANGUAGE_RO_RO");
    DEF_LANG("LANGUAGE_RU_RU");
    DEF_LANG("LANGUAGE_SK_SK");
    DEF_LANG("LANGUAGE_SL_SI");
    DEF_LANG("LANGUAGE_ES_MX");
    DEF_LANG("LANGUAGE_ES_ES");
    DEF_LANG("LANGUAGE_SV_SE");
    DEF_LANG("LANGUAGE_TH_TH");
    DEF_LANG("LANGUAGE_TR_TR");
    DEF_LANG("LANGUAGE_UK_UA");
#undef DEF_LANG
    }
};

#ifdef USE_GLOBALS
    extern RisohSettings g_settings;
#else
    inline RisohSettings&
    RisohSettings_GetMaster(void)
    {
        static RisohSettings s_settings;
        return s_settings;
    }
    #define g_settings RisohSettings_GetMaster()
#endif

```

`src/StringRes.cpp`:

```cpp
// StringRes.cpp --- String Resources
//////////////////////////////////////////////////////////////////////////////
// RisohEditor --- Another free Win32 resource editor
// Copyright (C) 2017-2018 Katayama Hirofumi MZ <katayama.hirofumi.mz@gmail.com>
// 
// This program is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
// 
// This program is distributed in the hope that it will be useful, 
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
// 
// You should have received a copy of the GNU General Public License
// along with this program.  If not, see <http://www.gnu.org/licenses/>.
//////////////////////////////////////////////////////////////////////////////

#include "StringRes.hpp"
#include "ConstantsDB.hpp"

bool
StringRes::LoadFromStream(const MByteStreamEx& stream, WORD wName)
{
    for (UINT i = 0; i < 16; ++i)
    {
        m_map.erase((wName - 1) * 16 + i);
    }

    WORD wLen;
    for (UINT i = 0; i < 16; ++i)
    {
        if (!stream.ReadWord(wLen))
            break;

        if (wLen > 0)
        {
            string_type str(wLen, 0);
            if (!stream.ReadData(&str[0], wLen * sizeof(WCHAR)))
                break;

            m_map[(wName - 1) * 16 + i] = std::move(str);
        }
    }

    return true;
}

bool
StringRes::SaveToStream(MByteStreamEx& stream, WORD wName)
{
    WORD first, last;
    IdRangeFromName(wName, first, last);

    for (UINT i = first; i <= last; ++i)
    {
        const string_type& str = m_map[i];
        WORD wLen = WORD(str.size());
        if (!stream.WriteWord(wLen) ||
            !stream.WriteData(&str[0], wLen * sizeof(WCHAR)))
            return false;
    }

    return true;
}

StringRes::string_type
StringRes::Dump(WORD wName)
{
    string_type ret;

    ret += L"STRINGTABLE\r\n";
    if (g_settings.bUseBeginEnd)
        ret += L"BEGIN\r\n";
    else
        ret += L"{\r\n";

    WORD first, last;
    IdRangeFromName(wName, first, last);
    for (UINT i = first; i <= last; ++i)
    {
        if (m_map[i].empty())
            continue;

        ret += L"    ";
        if (0)
        {
            ret += mstr_dec_word(i);
        }
        else
        {
            ret += g_db.GetNameOfResID(IDTYPE_STRING, IDTYPE_PROMPT, i);
        }

        ret += L", \"";
        ret += mstr_escape(m_map[i]);
        ret += L"\"\r\n";
    }

    if (g_settings.bUseBeginEnd)
        ret += L"END\r\n";
    else
        ret += L"}\r\n";

    return ret;
}

StringRes::string_type
StringRes::Dump()
{
    string_type ret;

    ret += L"STRINGTABLE\r\n";
    if (g_settings.bUseBeginEnd)
        ret += L"BEGIN\r\n";
    else
        ret += L"{\r\n";

    for (auto& pair : m_map)
    {
        if (pair.second.empty())
            continue;

        ret += L"    ";
        if (0)
        {
            ret += mstr_dec_word(pair.first);
        }
        else
        {
            ret += g_db.GetNameOfResID(IDTYPE_STRING, IDTYPE_PROMPT, pair.first);
        }

        ret += L", \"";
        ret += mstr_escape(pair.second);
        ret += L"\"\r\n";
    }

    if (g_settings.bUseBeginEnd)
        ret += L"END\r\n";
    else
        ret += L"}\r\n";

    return ret;
}

```

`src/StringRes.hpp`:

```hpp
// StringRes.hpp --- String Resources
//////////////////////////////////////////////////////////////////////////////
// RisohEditor --- Another free Win32 resource editor
// Copyright (C) 2017-2018 Katayama Hirofumi MZ <katayama.hirofumi.mz@gmail.com>
// 
// This program is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
// 
// This program is distributed in the hope that it will be useful, 
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
// 
// You should have received a copy of the GNU General Public License
// along with this program.  If not, see <http://www.gnu.org/licenses/>.
//////////////////////////////////////////////////////////////////////////////

#pragma once

#include "MByteStreamEx.hpp"
#include "MString.hpp"
#include <map>

//////////////////////////////////////////////////////////////////////////////

struct STRING_ENTRY
{
    WCHAR StringID[128];
    WCHAR StringValue[512];
};

class StringRes
{
public:
    typedef MStringW string_type;
    typedef std::map<WORD, string_type> map_type;
    WORD        m_wName;
    map_type    m_map;

    StringRes() = default;

    bool LoadFromStream(const MByteStreamEx& stream, WORD wName);
    bool SaveToStream(MByteStreamEx& stream, WORD wName);

    string_type Dump(WORD wName);
    string_type Dump();

    map_type& map()
    {
        return m_map;
    }
    const map_type& map() const
    {
        return m_map;
    }

    void IdRangeFromName(WORD name, WORD& first, WORD& last) const
    {
        first = (name - 1) * 16;
        last = first + 16 - 1;
    }

    WORD NameFromId(WORD id) const
    {
        return (id / 16) + 1;
    }

    bool HasAnyValues() const
    {
        for (auto& pair : m_map)
        {
            if (pair.second.size())
                return true;
        }
        return false;
    }

    bool HasAnyValues(WORD name) const
    {
        for (auto& pair : m_map)
        {
            if (NameFromId(pair.first) == name && pair.second.size())
                return true;
        }
        return false;
    }
};

```

`src/Toolbar.h`:

```h
#pragma once

#ifndef _INC_WINDOWS
    #include <windows.h>
#endif
#ifndef _INC_COMMCTRL
    #include <commctrl.h>
#endif
#include <cassert>
#include <vector>

#ifndef RT_TOOLBAR
    #define RT_TOOLBAR  MAKEINTRESOURCE(241)
#endif

// for MSVC rc
typedef struct tagTOOLBARDATA
{
    WORD wVersion;                  // Always 1
    WORD wWidth;                    // icon width
    WORD wHeight;                   // icon height
    WORD wItemCount;                // the # of items
    WORD aItems[ANYSIZE_ARRAY];     // The command IDs (a separator is zero)
} TOOLBARDATA, *PTOOLBARDATA;

// for MinGW/clang windres (non-standard)
typedef struct tagTOOLBARDATAWINDRES
{
    union
    {
        WORD wVersion;              // >= 3
        DWORD wWidth;               // icon width
    };
    DWORD wHeight;                  // icon height
    DWORD wItemCount;               // the # of items
    DWORD aItems[ANYSIZE_ARRAY];    // The command IDs (a separator is zero)
} TOOLBARDATAWINDRES, *PTOOLBARDATAWINDRES;

typedef INT (CALLBACK *FN_INT2INT)(INT id);
typedef BOOL (CALLBACK *FN_INT2STR)(INT id, LPTSTR pszText, INT cchTextMax);

// See: https://github.com/katahiromz/RisohEditor/blob/master/tests/ToolbarTest/ToolbarTest.cpp
inline BOOL
LoadToolbarResource(HWND hwndTB, HINSTANCE hInst, LPCTSTR lpName,
                    FN_INT2INT fnCommandIdToImageIndex,
                    FN_INT2STR fnCommandIdToText = NULL)
{
    assert(IsWindow(hwndTB));
    assert(lpName != NULL);
    assert(fnCommandIdToImageIndex != NULL);

    if (hInst == NULL)
        hInst = GetModuleHandle(NULL);

    // Set BUTTON struct size
    SendMessage(hwndTB, TB_BUTTONSTRUCTSIZE, sizeof(TBBUTTON), 0);

    // Load RT_TOOLBAR resource
    HRSRC hRsrc = FindResource(hInst, lpName, RT_TOOLBAR);
    DWORD cbReal = SizeofResource(hInst, hRsrc);
    if (cbReal < sizeof(TOOLBARDATA) - sizeof(WORD))
    {
        assert(0);
        return FALSE;
    }
    HGLOBAL hResData = LoadResource(hInst, hRsrc);
    LPVOID pvData = LockResource(hResData);
    if (pvData == NULL)
    {
        assert(0);
        return FALSE;
    }

    // Validate the data
    PTOOLBARDATA pData1 = (PTOOLBARDATA)pvData;
    if (pData1->wVersion == 1)
    {
        WORD wWidth = pData1->wWidth, wHeight = pData1->wHeight;
        if (wWidth < 3 || wHeight < 3)
        {
            assert(0);
            return FALSE;
        }

        DWORD wItemCount = pData1->wItemCount;
        size_t cbExpect = sizeof(TOOLBARDATA) + (wItemCount - 1) * sizeof(WORD);
        if (cbReal < cbExpect)
        {
            assert(0);
            return FALSE;
        }

        SendMessage(hwndTB, TB_SETBITMAPSIZE, 0, MAKELPARAM(wWidth, wHeight));

        // load image and set image list
        HIMAGELIST himl = ImageList_LoadImage(hInst, lpName, wWidth, 0, RGB(255, 0, 255),
                                              IMAGE_BITMAP, LR_CREATEDIBSECTION);
        if (himl == NULL)
        {
            assert(0);
            return FALSE;
        }
        SendMessage(hwndTB, TB_SETIMAGELIST, 0, (LPARAM)himl);

        // add buttons
        std::vector<TBBUTTON> buttons;
        for (DWORD i = 0; i < wItemCount; ++i)
        {
            TBBUTTON button;
            ZeroMemory(&button, sizeof(button));

            INT idCommand = button.idCommand = pData1->aItems[i];
            button.fsState = TBSTATE_ENABLED;
            button.iBitmap = -1;
            button.iString = -1;
            if (idCommand)
            {
                button.iBitmap = fnCommandIdToImageIndex(idCommand);
                button.fsStyle = BTNS_BUTTON | BTNS_AUTOSIZE;

                TCHAR szText[MAX_PATH];
                szText[0] = 0;
                if (fnCommandIdToText && fnCommandIdToText(idCommand, szText, _countof(szText)))
                    button.iString = (INT)SendMessage(hwndTB, TB_ADDSTRING, 0, (LPARAM)szText);
            }
            else
            {
                button.fsStyle = BTNS_SEP;
            }

            buttons.push_back(button);
        }
        SendMessage(hwndTB, TB_ADDBUTTONS, WPARAM(buttons.size()), (LPARAM)buttons.data());
    }
#ifndef _MSC_VER // Not Visual C++
    else if (pData1->wVersion >= 3)
    {
        PTOOLBARDATAWINDRES pData2 = (PTOOLBARDATAWINDRES)pvData;
        DWORD wWidth = pData2->wWidth, wHeight = pData2->wHeight;
        if (wWidth < 3 || wHeight < 3)
        {
            assert(0);
            return FALSE;
        }

        DWORD wItemCount = pData2->wItemCount;
        size_t cbExpect = sizeof(TOOLBARDATA) + (wItemCount - 1) * sizeof(WORD);
        if (cbReal < cbExpect)
        {
            assert(0);
            return FALSE;
        }

        SendMessage(hwndTB, TB_SETBITMAPSIZE, 0, MAKELPARAM(wWidth, wHeight));

        // load image and set image list
        HIMAGELIST himl = ImageList_LoadImage(hInst, lpName, wWidth, 0, RGB(255, 0, 255),
                                              IMAGE_BITMAP, LR_CREATEDIBSECTION);
        if (himl == NULL)
        {
            assert(0);
            return FALSE;
        }
        SendMessage(hwndTB, TB_SETIMAGELIST, 0, (LPARAM)himl);

        // add buttons
        std::vector<TBBUTTON> buttons;
        for (DWORD i = 0; i < wItemCount; ++i)
        {
            TBBUTTON button;
            ZeroMemory(&button, sizeof(button));

            INT idCommand = button.idCommand = pData2->aItems[i];
            button.fsState = TBSTATE_ENABLED;
            button.iBitmap = -1;
            button.iString = -1;
            if (idCommand)
            {
                button.iBitmap = fnCommandIdToImageIndex(idCommand);
                button.fsStyle = BTNS_BUTTON | BTNS_AUTOSIZE;
                TCHAR szText[MAX_PATH];
                szText[0] = 0;
                if (fnCommandIdToText && fnCommandIdToText(idCommand, szText, _countof(szText)))
                    button.iString = (INT)SendMessage(hwndTB, TB_ADDSTRING, 0, (LPARAM)szText);
            }
            else
            {
                button.fsStyle = BTNS_SEP;
            }

            buttons.push_back(button);
        }
        SendMessage(hwndTB, TB_ADDBUTTONS, WPARAM(buttons.size()), (LPARAM)buttons.data());
    }
#endif // ndef _MSC_VER
    else
    {
        return FALSE;
    }

    // Modify extended style
    DWORD extended = (DWORD)SendMessage(hwndTB, TB_GETEXTENDEDSTYLE, 0, 0);
    extended |= TBSTYLE_EX_DRAWDDARROWS; // BTNS_DROPDOWN and BTNS_WHOLEDROPDOWN will work
    //extended |= TBSTYLE_EX_MIXEDBUTTONS; // BTNS_SHOWTEXT works
    SendMessage(hwndTB, TB_SETEXTENDEDSTYLE, 0, extended);
    return TRUE;
}

```

`src/ToolbarRes.cpp`:

```cpp
// ToolbarRes.cpp --- TOOLBAR Resource
//////////////////////////////////////////////////////////////////////////////
// RisohEditor --- Another free Win32 resource editor
// Copyright (C) 2022 Katayama Hirofumi MZ <katayama.hirofumi.mz@gmail.com>
// 
// This program is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
// 
// This program is distributed in the hope that it will be useful, 
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
// 
// You should have received a copy of the GNU General Public License
// along with this program.  If not, see <http://www.gnu.org/licenses/>.
//////////////////////////////////////////////////////////////////////////////

#include "ToolbarRes.hpp"
#include "ConstantsDB.hpp"

bool ToolbarRes::LoadFromStream(const MByteStreamEx& stream)
{
    m_items.clear();

    WORD wVer;
    if (!stream.PeekWord(wVer))
        return false;

    if (wVer == 1)
    {
        WORD wWidth, wHeight, wCount;
        if (!stream.ReadWord(wVer) ||
            !stream.ReadWord(wWidth) ||
            !stream.ReadWord(wHeight) ||
            !stream.ReadWord(wCount))
        {
            return false;
        }

        if (wVer != 1 || wWidth == 0 || wHeight == 0)
            return false;

        for (DWORD i = 0; i < wCount; ++i)
        {
            WORD item;
            if (!stream.ReadWord(item))
            {
                m_items.clear();
                return false;
            }
            m_items.push_back(item);
        }

        m_width = wWidth;
        m_height = wHeight;
        return true;
    }
    else if (wVer >= 3)
    {
        uint32_t wWidth, wHeight, dwCount;
        if (!stream.ReadDword(wWidth) ||
            !stream.ReadDword(wHeight) ||
            !stream.ReadDword(dwCount))
        {
            return false;
        }

        if (wWidth == 0 || wHeight == 0)
            return false;

        for (DWORD i = 0; i < dwCount; ++i)
        {
            uint32_t item;
            if (!stream.ReadDword(item))
            {
                m_items.clear();
                return false;
            }
            m_items.push_back(item);
        }

        m_width = wWidth;
        m_height = wHeight;
        return true;
    }
    else
    {
        return false;
    }
}

bool ToolbarRes::SaveToStream(MByteStreamEx& stream) const
{
    if (!stream.WriteWord(WORD(1)) ||
        !stream.WriteWord(WORD(m_width)) ||
        !stream.WriteWord(WORD(m_height)) ||
        !stream.WriteWord(WORD(m_items.size())))
    {
        return false;
    }

    for (auto item : m_items)
    {
        if (!stream.WriteWord(WORD(item)))
            return false;
    }

    return true;
}

MStringW ToolbarRes::Dump(const MIdOrString& id_or_str) const
{
    MStringW ret;

    if (id_or_str.is_str())
    {
        ret += id_or_str.str();
    }
    else
    {
        ret += g_db.GetNameOfResID(IDTYPE_BITMAP, id_or_str.m_id);
    }

    ret += L" TOOLBAR ";
    ret += std::to_wstring(m_width);
    ret += L", ";
    ret += std::to_wstring(m_height);
    ret += L"\r\n";

    if (g_settings.bUseBeginEnd)
        ret += L"BEGIN\r\n";
    else
        ret += L"{\r\n";

    for (auto item : m_items)
    {
        if (item == 0)
        {
            ret += L"    SEPARATOR\r\n";
        }
        else
        {
            ret += L"    BUTTON ";
            ret += g_db.GetNameOfResID(IDTYPE_COMMAND, IDTYPE_NEWCOMMAND, item, true);
            ret += L"\r\n";
        }
    }

    if (g_settings.bUseBeginEnd)
        ret += L"END\r\n";
    else
        ret += L"}\r\n";

    return ret;
}

std::vector<BYTE> ToolbarRes::data() const
{
    MByteStreamEx stream;
    SaveToStream(stream);
    return stream.data();
}

```

`src/ToolbarRes.hpp`:

```hpp
// ToolbarRes.hpp --- TOOLBAR Resource
//////////////////////////////////////////////////////////////////////////////
// RisohEditor --- Another free Win32 resource editor
// Copyright (C) 2022 Katayama Hirofumi MZ <katayama.hirofumi.mz@gmail.com>
// 
// This program is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
// 
// This program is distributed in the hope that it will be useful, 
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
// 
// You should have received a copy of the GNU General Public License
// along with this program.  If not, see <http://www.gnu.org/licenses/>.
//////////////////////////////////////////////////////////////////////////////

#pragma once

#ifndef _INC_WINDOWS
    #include <windows.h>
#endif
#include <cassert>
#include <vector>

#include "MByteStreamEx.hpp"
#include "MString.hpp"

#ifndef RT_TOOLBAR
    #define RT_TOOLBAR  MAKEINTRESOURCE(241)
#endif

//////////////////////////////////////////////////////////////////////////////

class ToolbarRes
{
protected:
    DWORD m_width;
    DWORD m_height;
    std::vector<DWORD> m_items;

public:
    ToolbarRes() = default;

    bool LoadFromStream(const MByteStreamEx& stream);
    bool SaveToStream(MByteStreamEx& stream) const;
    MStringW Dump(const MIdOrString& id_or_str) const;

    INT width() const
    {
        return m_width;
    }
    void width(INT cx)
    {
        m_width = cx;
    }
    INT height() const
    {
        return m_height;
    }
    void height(INT cy)
    {
        m_height = cy;
    }

    bool empty() const
    {
        return size() == 0;
    }
    size_t size() const
    {
        return m_items.size();
    }
    DWORD& operator[](size_t i)
    {
        return m_items[i];
    }
    const DWORD& operator[](size_t i) const
    {
        return m_items[i];
    }
    void push_back(DWORD entry)
    {
        m_items.push_back(entry);
    }
    void clear()
    {
        m_items.clear();
    }

    std::vector<BYTE> data() const;
};

```

`src/UTF16_validator.h`:

```h
/* UTF16_validator.h --- MZC4 UTF-16 Validator
 */

#ifndef MZC4_UTF16_VALIDATOR_H_
#define MZC4_UTF16_VALIDATOR_H_      3   /* Version 3 */

#include "UTF8_validator.h"

#ifdef __cplusplus
    #include <cstring>
    #include <cassert>
#else
    #include <string.h>
    #include <assert.h>
#endif

bool UTF16_validate(const void *pv, size_t cb);

/****************************************************************************/

inline bool
UTF16_validate(const void *pv, size_t cb)
{
#if defined(_WIN32) && !defined(WONVER)
    return !!IsTextUnicode(pv, (int)cb, NULL);
#else
    const WCHAR *wide_str;
    int cch, k;
    bool bASCII;

    assert(sizeof(WCHAR) == 2);

    /* check zero length */
    if (cb == 0)
        return true;

    /* check odd length */
    if ((cb & 1) != 0)
        return false;

    wide_str = (const WCHAR *)pv;
    cch = cb / 2;

    /* check BOM */
    if (memcmp(pv, "\xFE\xFF", 2) == 0)   /* UTF-16BE */
    {
        return false;
    }
    if (memcmp(pv, "\xFF\xFE", 2) == 0)   /* UTF-16LE */
    {
        return true;
    }
    if (cb >= 3)
    {
        if (memcmp(pv, "\xEF\xBB\xBF", 3) == 0)   /* UTF-8 */
        {
            return false;
        }
        if (memcmp(pv, "\x2B\x2F\x76", 3) == 0)   /* UTF-7 */
        {
            return false;
        }
    }
    if (cb >= 4)
    {
        if (memcmp(pv, "\0\0\xFE\xFF", 4) == 0)   /* UTF-32BE */
        {
            return false;
        }
        if (memcmp(pv, "\xFF\xFE\0\0", 4) == 0)   /* UTF-32LE */
        {
            return false;
        }
    }

    /* check illegal */
    for (k = 0; k < cch; ++k)
    {
        WCHAR wch = wide_str[k];
        if (wch == 0 || wch == 0xFFFF ||
            memcmp(&wch, "\xFE\xFF", 2) == 0 ||
            memcmp(&wch, "\r\n", 2) == 0)
        {
            return false;
        }
    }

    /* check ASCII */
    bASCII = true;
    for (k = 0; k < cch; ++k)
    {
        if (wide_str[k] & 0xFF00)
        {
            bASCII = false;
            break;
        }
    }
    if (bASCII)
    {
        return true;
    }

    /* check UTF-8 */
    if (UTF8_validate(pv, cb))
        return false;

    return true;
#endif
} /* UTF16_validate */

/****************************************************************************/

#endif  /* ndef MZC4_UTF16_VALIDATOR_H_ */

```

`src/UTF8_validator.h`:

```h
/* UTF8_validator.h --- MZC4 UTF-8 Validator
 *
 * Copyright (c) 2008-2009 Bjoern Hoehrmann <bjoern@hoehrmann.de>
 * Copyright (c) 2018 Katayama Hirofumi MZ <katayama.hirofumi.mz@gmail.com>
 *
 * See http://bjoern.hoehrmann.de/utf-8/decoder/dfa/ for details.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the "Software"),
 * to deal in the Software without restriction, including without limitation
 * the rights to use, copy, modify, merge, publish, distribute, sublicense,
 * and/or sell copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL
 * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 */

#ifndef MZC4_UTF8_VALIDATOR_H_
#define MZC4_UTF8_VALIDATOR_H_      3   /* Version 3 */

#if __cplusplus >= 201103L          /* C++11 */
    #include <cstdint>
#elif __STDC_VERSION__ >= 199901L   /* C99 */
    #include <stdint.h>
    #include <stdbool.h>
#else
    #include "pstdint.h"
    #include "pstdbool.h"
#endif

/****************************************************************************/

#define UTF8_ACCEPT 0
#define UTF8_REJECT 1

inline const uint8_t *
UTF8_table(void)
{
    static const uint8_t utf8d[] =
    {
        0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0, /* 00..1f */
        0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0, /* 20..3f */
        0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0, /* 40..5f */
        0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0, /* 60..7f */
        1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9, /* 80..9f */
        7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7, /* a0..bf */
        8,8,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2, /* c0..df */
        0xa,0x3,0x3,0x3,0x3,0x3,0x3,0x3,0x3,0x3,0x3,0x3,0x3,0x4,0x3,0x3, /* e0..ef */
        0xb,0x6,0x6,0x6,0x5,0x8,0x8,0x8,0x8,0x8,0x8,0x8,0x8,0x8,0x8,0x8, /* f0..ff */
        0x0,0x1,0x2,0x3,0x5,0x8,0x7,0x1,0x1,0x1,0x4,0x6,0x1,0x1,0x1,0x1, /* s0..s0 */
        1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,1,1,1,1,1,0,1,0,1,1,1,1,1,1, /* s1..s2 */
        1,2,1,1,1,1,1,2,1,2,1,1,1,1,1,1,1,1,1,1,1,1,1,2,1,1,1,1,1,1,1,1, /* s3..s4 */
        1,2,1,1,1,1,1,1,1,2,1,1,1,1,1,1,1,1,1,1,1,1,1,3,1,3,1,1,1,1,1,1, /* s5..s6 */
        1,3,1,1,1,1,1,3,1,3,1,1,1,1,1,1,1,3,1,1,1,1,1,1,1,1,1,1,1,1,1,1, /* s7..s8 */
    };
    return utf8d;
}

inline uint32_t
UTF8_decode(uint32_t* state, uint32_t* codep, uint32_t byte)
{
    uint32_t type = UTF8_table()[byte];

    *codep = (*state != UTF8_ACCEPT) ?
        (byte & 0x3fu) | (*codep << 6) :
        (0xff >> type) & (byte);

    *state = UTF8_table()[256 + *state * 16 + type];
    return *state;
}

inline bool
UTF8_count_code_points(const char *str, size_t *count)
{
    uint32_t codepoint, state = 0;

    for (*count = 0; *str; ++str)
    {
        if (!UTF8_decode(&state, &codepoint, *str))
        {
            ++(*count);
        }
    }

    return state != UTF8_ACCEPT;
}

inline uint32_t
UTF8_validate_state(uint32_t *state, const char *str, size_t len)
{
    size_t i;
    uint32_t type;

    for (i = 0; i < len; i++)
    {
        type = UTF8_table()[(uint8_t)str[i]];
        *state = UTF8_table()[256 + (*state) * 16 + type];

        if (*state == UTF8_REJECT)
            break;
    }

    return *state;
}

inline bool
UTF8_validate(const void *str, size_t len)
{
    uint32_t state = UTF8_ACCEPT;
    return UTF8_validate_state(&state, (const char *)str, len) == UTF8_ACCEPT;
}

/****************************************************************************/

#endif  /* ndef MZC4_UTF8_VALIDATOR_H_ */

```

`src/VersionRes.cpp`:

```cpp
// VersionRes.cpp --- Version Resources
//////////////////////////////////////////////////////////////////////////////
// RisohEditor --- Another free Win32 resource editor
// Copyright (C) 2017-2020 Katayama Hirofumi MZ <katayama.hirofumi.mz@gmail.com>
// 
// This program is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
// 
// This program is distributed in the hope that it will be useful, 
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
// 
// You should have received a copy of the GNU General Public License
// along with this program.  If not, see <http://www.gnu.org/licenses/>.
//////////////////////////////////////////////////////////////////////////////

#include "VersionRes.hpp"
#include "ConstantsDB.hpp"

bool VersionRes::VarsFromStream(Vars& vars, const MByteStreamEx& stream)
{
    Var var;

    stream.ReadDwordAlignment();

    size_t pos0 = stream.pos();

    if (!stream.ReadRaw(var.head) || !stream.ReadSz(var.key))
        return false;

    size_t pos1 = pos0 + var.head.wLength;
    stream.ReadDwordAlignment();

    if (var.head.wValueLength)
    {
        DWORD dwSize = var.head.wValueLength;
        if (var.head.wType == 1)
            dwSize *= 2;
        var.value.resize(dwSize);
        if (!stream.ReadData(&var.value[0], dwSize))
            return false;
    }
    stream.ReadDwordAlignment();

    while (stream.pos() < pos1)
    {
        VarsFromStream(var.vars, stream);
    }

    vars.push_back(var);

    return true;
}

bool VersionRes::LoadFromData(const std::vector<BYTE>& data)
{
    ZeroMemory(&m_fixed, sizeof(m_fixed));

    MByteStreamEx stream(data);
    if (!VarsFromStream(m_vars, stream))
        return false;

    if (m_vars.size() != 1)
        return false;

    Var& var = m_vars[0];
    if (var.key != L"VS_VERSION_INFO")
        return false;

    if (var.value.size() == sizeof(VS_FIXEDFILEINFO))
    {
        CopyMemory(&m_fixed, &var.value[0], var.value.size());
    }

    return true;
}

MStringW
VersionRes::DumpValue(WORD wType, const Var& value, int depth) const
{
    MStringW ret = MStringW(depth * 4, L' ');
    ret += L"VALUE ";
    ret += mstr_quote(value.key);

    if (value.value.size() >= 2)
    {
        if (wType == 0)
        {
            const WORD *pw = reinterpret_cast<const WORD *>(&value.value[0]);
            WCHAR buf[MAX_PATH];
            for (size_t i = 0; i < value.value.size(); i += 2)
            {
                StringCchPrintfW(buf, _countof(buf), L", 0x%04X", *pw++);
                ret += buf;
            }
        }
        else
        {
            const WCHAR *pch = reinterpret_cast<const WCHAR *>(&value.value[0]);
            MStringW str(pch, value.value.size() / 2);
            ret += L", ";
            ret += mstr_quote(str);
        }
    }
    else
    {
        ret += L", \"\"";
    }

    ret += L"\r\n";
    return ret;
}

MStringW
VersionRes::DumpBlock(const Var& var, int depth) const
{
    MStringW ret;

    ret += MStringW(depth * 4, L' ');
    ret += L"BLOCK \"";
    ret += var.key;
    ret += L"\"\r\n";
    ret += MStringW(depth * 4, L' ');
    if (g_settings.bUseBeginEnd)
        ret += L"BEGIN\r\n";
    else
        ret += L"{\r\n";

    for (auto& item : var.vars)
    {
        if (var.key == L"StringFileInfo")
        {
            ret += DumpBlock(item, depth + 1);
        }
        else
        {
            ret += DumpValue(item.head.wType, item, depth + 1);
        }
    }

    ret += MStringW(depth * 4, L' ');
    if (g_settings.bUseBeginEnd)
        ret += L"END\r\n";
    else
        ret += L"}\r\n";

    return ret;
}

MStringW
VersionRes::Dump(const MIdOrString& name) const
{
    MStringW ret;
    WCHAR line[MAX_PATH];

    ret += name.str();
    ret += L" VERSIONINFO\r\n";

    StringCchPrintfW(line, _countof(line), 
        L"FILEVERSION     %u, %u, %u, %u\r\n", 
        HIWORD(m_fixed.dwFileVersionMS), 
        LOWORD(m_fixed.dwFileVersionMS), 
        HIWORD(m_fixed.dwFileVersionLS), 
        LOWORD(m_fixed.dwFileVersionLS));
    ret += line;

    StringCchPrintfW(line, _countof(line), 
        L"PRODUCTVERSION  %u, %u, %u, %u\r\n", 
        HIWORD(m_fixed.dwProductVersionMS), 
        LOWORD(m_fixed.dwProductVersionMS), 
        HIWORD(m_fixed.dwProductVersionLS), 
        LOWORD(m_fixed.dwProductVersionLS));
    ret += line;

    StringCchPrintfW(line, _countof(line), L"FILEOS          0x%04lX\r\n", m_fixed.dwFileOS);
    ret += line;

    StringCchPrintfW(line, _countof(line), L"FILETYPE        0x%X\r\n", m_fixed.dwFileType);
    ret += line;

    StringCchPrintfW(line, _countof(line), L"FILESUBTYPE     0x%X\r\n", m_fixed.dwFileSubtype);
    ret += line;

    if (g_settings.bUseBeginEnd)
        ret += L"BEGIN\r\n";
    else
        ret += L"{\r\n";

    const std::vector<Var>& vars = m_vars[0].vars;
    for (auto& item : vars)
    {
        ret += DumpBlock(item, 1);
    }
    if (g_settings.bUseBeginEnd)
        ret += L"END\r\n";
    else
        ret += L"}\r\n";

    return ret;
}

```

`src/VersionRes.hpp`:

```hpp
// VersionRes.hpp --- Version Resources
//////////////////////////////////////////////////////////////////////////////
// RisohEditor --- Another free Win32 resource editor
// Copyright (C) 2017-2020 Katayama Hirofumi MZ <katayama.hirofumi.mz@gmail.com>
// 
// This program is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
// 
// This program is distributed in the hope that it will be useful, 
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
// 
// You should have received a copy of the GNU General Public License
// along with this program.  If not, see <http://www.gnu.org/licenses/>.
//////////////////////////////////////////////////////////////////////////////

#pragma once

#ifndef _INC_WINDOWS
    #include <windows.h>
#endif
#include <cassert>
#include <vector>
#include <map>

#include "MByteStreamEx.hpp"
#include "MString.hpp"
#include "MIdOrString.hpp"

//////////////////////////////////////////////////////////////////////////////

typedef struct VarInfoHead
{
    WORD    wLength;
    WORD    wValueLength;
    WORD    wType;
} VarInfoHead;

struct Var
{
    VarInfoHead             head;
    MStringW                key;
    std::vector<BYTE>       value;
    std::vector<BYTE>       children;
    std::vector<Var>        vars;
};
typedef std::vector<Var> Vars;

//////////////////////////////////////////////////////////////////////////////

class VersionRes
{
public:
    VersionRes() = default;

    bool VarsFromStream(Vars& vars, const MByteStreamEx& stream);
    bool LoadFromData(const std::vector<BYTE>& data);
    MStringW Dump(const MIdOrString& name) const;

protected:
    std::vector<Var>        m_vars;
    VS_FIXEDFILEINFO        m_fixed;

    MStringW DumpValue(WORD wType, const Var& value, int depth = 0) const;
    MStringW DumpBlock(const Var& var, int depth = 0) const;
};

```

`src/lang/de_DE.rc`:

```rc
// This file is automatically generated by RisohEditor 5.7.9.
// † <-- This dagger helps UTF-8 detection.

#pragma code_page(65001) // UTF-8

LANGUAGE LANG_GERMAN, SUBLANG_DEFAULT

//////////////////////////////////////////////////////////////////////////////
// RT_MENU

IDR_MAINMENU MENU
{
    POPUP "&Datei"
    {
        MENUITEM "&Neu\tCtrl+N", ID_NEW
        MENUITEM SEPARATOR
        MENUITEM "&Öffnen...\tCtrl+O", ID_OPEN
        MENUITEM "&Speichern...\tCtrl+S", ID_SAVE
        MENUITEM "Speichern &als...\tShift+Ctrl+S", ID_SAVEAS
        MENUITEM "Mit &Komprimierung speichern...", ID_SAVEASCOMPRESS
        MENUITEM SEPARATOR
        MENUITEM "&Importieren...\tCtrl+I", ID_IMPORT
        MENUITEM "&Export...\tCtrl+P", ID_EXPORT
        MENUITEM SEPARATOR
        MENUITEM "Neu laden &resource.h...\tCtrl+R", ID_LOADRESH
        MENUITEM "Speichern re&source.h...", ID_UPDATERESHBANG
        MENUITEM "&Hinweis resource.h Änderung...", ID_ADVICERESH
        MENUITEM "&Entladen resource.h", ID_UNLOADRESH
        MENUITEM SEPARATOR
        MENUITEM "Laden Sie die Fensterklassenbibliothek...", ID_LOADWCLIB
        MENUITEM SEPARATOR
        POPUP "Kürzlich verwendete Dateien"
        {
            MENUITEM "(Keiner)", -1, GRAYED
        }
        MENUITEM SEPARATOR
        MENUITEM "&Ausgang\tAlt+F4", ID_EXIT
    }
    POPUP "&Bearbeiten"
    {
        MENUITEM "Bearbeiten per &GUI...\tCtrl+G", ID_GUIEDIT
        MENUITEM SEPARATOR
        POPUP "&Hinzufügen"
        {
            MENUITEM "&Symbol hinzufügen...", ID_ADDICON
            MENUITEM "&Cursor hinzufügen...", ID_ADDCURSOR
            MENUITEM "&Bitmap hinzufügen...", ID_ADDBITMAP
            MENUITEM "&Dialogfeld hinzufügen...", ID_ADDDIALOG
            MENUITEM "&Menü hinzufügen...", ID_ADDMENU
            MENUITEM "&String-Tabelle hinzufügen...", ID_ADDSTRINGTABLE
            MENUITEM "&Nachrichtentabelle hinzufügen...", ID_ADDMESSAGETABLE
            MENUITEM "&HTML hinzufügen...", ID_ADDHTML
            MENUITEM "&Beschleuniger hinzufügen...", ID_ADDACCEL
            MENUITEM "&Versionsinfo hinzufügen...", ID_ADDVERINFO
            MENUITEM "&Manifest hinzufügen...", ID_ADDMANIFEST
            MENUITEM "S&ymbolleiste hinzufügen...", ID_ADDTOOLBAR
            MENUITEM "&Ressourcenelement hinzufügen...", ID_ADDRES
        }
        POPUP "&Ersetzen"
        {
            MENUITEM "&Symbol ersetzen...", ID_REPLACEICON
            MENUITEM "&Cursor ersetzen...", ID_REPLACECURSOR
            MENUITEM "&Bitmap ersetzen...", ID_REPLACEBITMAP
            MENUITEM "&Ersetzen Sie das binäre Ressourcenelement...", ID_REPLACEBIN
        }
        POPUP "&Extrakt"
        {
            MENUITEM "&Symbol extrahieren...", ID_EXTRACTICON
            MENUITEM "&Cursor extrahieren...", ID_EXTRACTCURSOR
            MENUITEM "&Bitmap extrahieren...", ID_EXTRACTBITMAP
            MENUITEM "&Als RC-Datei extrahieren...", ID_EXTRACTRC
            MENUITEM "&Binäres Ressourcenelement extrahieren...", ID_EXTRACTBIN
        }
        MENUITEM SEPARATOR
        MENUITEM "&Name/Sprache ändern\tF2", ID_EDITLABEL
        MENUITEM SEPARATOR
        MENUITEM "In neuen &Namen klonen...", ID_COPYASNEWNAME
        MENUITEM "In neuer &Sprache klonen...", ID_COPYASNEWLANG
        MENUITEM "In mehrere Sprachen kopieren...", ID_COPYTOMULTILANG
        MENUITEM SEPARATOR
        MENUITEM "&Test machen", ID_TEST
        MENUITEM SEPARATOR
        MENUITEM "&Löschen\tDel", ID_DELETERES
        MENUITEM SEPARATOR
        MENUITEM "&ID Association...", ID_IDASSOC
        MENUITEM "&Vordefinierte Makros...", ID_PREDEFMACROS
        MENUITEM "&Schriftarteinstellungen...", ID_FONTS
        MENUITEM "&Pfade festlegen...", ID_SETPATHS
        MENUITEM SEPARATOR
        MENUITEM "&UI Language Select (UI语言选择)...", ID_CHOOSEUILANG
        MENUITEM SEPARATOR
        MENUITEM "Delphi DFM-&Einstellungen...", ID_DFMSETTINGS
        MENUITEM "&Aufbau...", ID_CONFIG
    }
    POPUP "&Suche"
    {
        MENUITEM "&Finden...\tCtrl+F", ID_FIND
        MENUITEM SEPARATOR
        MENUITEM "Suche nach &oben\tShift+F3", ID_FINDUPWARD
        MENUITEM "Suche nach &unten\tF3", ID_FINDDOWNWARD
        MENUITEM SEPARATOR
        MENUITEM "&Abfragekonstante...", ID_QUERYCONSTANT
    }
    POPUP "&Aussicht"
    {
        MENUITEM "&Statusleiste", ID_STATUSBAR
        MENUITEM "&Symbolleiste", ID_SHOWHIDETOOLBAR
        MENUITEM "&Binär", ID_BINARYPANE
        MENUITEM SEPARATOR
        MENUITEM "Alle &erweitern\tCtrl+K", ID_EXPAND_ALL
        MENUITEM "Alle &reduzieren\tCtrl+L", ID_COLLAPSE_ALL
        MENUITEM SEPARATOR
        MENUITEM "Liste der Ressourcen-IDs", ID_IDLIST
        MENUITEM "Liste der Sprachen...", ID_SHOWLANGS
        MENUITEM SEPARATOR
        MENUITEM "Immer CONTROL-Anweisung", ID_ALWAYSCONTROL
        MENUITEM "Verwenden Sie keine ID-Makros", ID_HIDEIDMACROS
        MENUITEM "Verwenden Sie IDC_STATIC", ID_USEIDC_STATIC
        MENUITEM "Zeilenumbruch", ID_WORD_WRAP
        MENUITEM "Verwenden Sie BEGIN / END", ID_USEBEGINEND
        MENUITEM "Use Microsoft Message &Table", ID_USEMSMSGTBL
        MENUITEM SEPARATOR
        MENUITEM "&Codierung des Ressourcenelements...", ID_ENCODING
        MENUITEM "Dialog &font substitutes...", ID_DIALOG_FONT_SUBSTITUTES
        MENUITEM SEPARATOR
        MENUITEM "Aktualisierung", ID_REFRESHALL
    }
    POPUP "&Automatisierung"
    {
        MENUITEM "Die Programmiersprache EGA...", ID_EGA
        MENUITEM "&Führen Sie das EGA-Programm aus...", ID_EGA_PROGRAM
        MENUITEM "Öffnen &Sie das EGA-Handbuch", ID_OPEN_EGA_MANUAL
    }
    POPUP "&Hilfe"
    {
        MENUITEM "Öffnen &README.txt (Englisch)", ID_OPENREADME
        MENUITEM "Öffnen &LICENSE.txt", ID_OPENLICENSE
        MENUITEM SEPARATOR
        MENUITEM "&Ein Leitfaden für RisohEditor", ID_GUIDE
        MENUITEM "Überprüfen Sie das RisohEditor-&Update...", ID_CHECKUPDATE
        MENUITEM SEPARATOR
        MENUITEM "&Über...", ID_ABOUT
    }
}

IDR_POPUPMENUS MENU
{
    POPUP "Pop-up #0"
    {
        MENUITEM "&Bearbeiten per GUI...\tCtrl+G", ID_GUIEDIT
        MENUITEM SEPARATOR
        POPUP "&Hinzufügen"
        {
            MENUITEM "&Symbol hinzufügen...", ID_ADDICON
            MENUITEM "&Cursor hinzufügen...", ID_ADDCURSOR
            MENUITEM "&Bitmap hinzufügen...", ID_ADDBITMAP
            MENUITEM "&Dialogfeld hinzufügen...", ID_ADDDIALOG
            MENUITEM "&Menü hinzufügen...", ID_ADDMENU
            MENUITEM "&String-Tabelle hinzufügen...", ID_ADDSTRINGTABLE
            MENUITEM "&Nachrichtentabelle hinzufügen...", ID_ADDMESSAGETABLE
            MENUITEM "&HTML hinzufügen...", ID_ADDHTML
            MENUITEM "&Beschleuniger hinzufügen...", ID_ADDACCEL
            MENUITEM "&Versionsinfo hinzufügen...", ID_ADDVERINFO
            MENUITEM "&Manifest hinzufügen...", ID_ADDMANIFEST
            MENUITEM "S&ymbolleiste hinzufügen...", ID_ADDTOOLBAR
            MENUITEM "&Ressourcenelement hinzufügen...", ID_ADDRES
        }
        POPUP "&Ersetzen"
        {
            MENUITEM "&Symbol ersetzen...", ID_REPLACEICON
            MENUITEM "&Cursor ersetzen...", ID_REPLACECURSOR
            MENUITEM "&Bitmap ersetzen...", ID_REPLACEBITMAP
            MENUITEM "&Ersetzen Sie das binäre Ressourcenelement...", ID_REPLACEBIN
        }
        POPUP "&Extrakt"
        {
            MENUITEM "&Symbol extrahieren...", ID_EXTRACTICON
            MENUITEM "&Cursor extrahieren...", ID_EXTRACTCURSOR
            MENUITEM "&Bitmap extrahieren...", ID_EXTRACTBITMAP
            MENUITEM "&Als RC-Datei extrahieren...", ID_EXTRACTRC
            MENUITEM "&Binäres Ressourcenelement extrahieren...", ID_EXTRACTBIN
        }
        MENUITEM SEPARATOR
        MENUITEM "Name / Sprache ändern\tF2", ID_EDITLABEL
        MENUITEM SEPARATOR
        MENUITEM "In neuen &Namen klonen...", ID_COPYASNEWNAME
        MENUITEM "In neuer &Sprache klonen...", ID_COPYASNEWLANG
        MENUITEM "In mehrere Sprachen kopieren...", ID_COPYTOMULTILANG
        MENUITEM SEPARATOR
        MENUITEM "&Test machen", ID_TEST
        MENUITEM SEPARATOR
        MENUITEM "&Löschen\tDel", ID_DELETERES
    }
    POPUP "Pop-up #1"
    {
        MENUITEM "&Kontrolle hinzufügen...", ID_ADDCTRL
        MENUITEM SEPARATOR
        MENUITEM "&Schnitt\tCtrl+X", ID_CUT
        MENUITEM "&Kopieren\tCtrl+C", ID_COPY
        MENUITEM "&Einfügen\tCtrl+V", ID_PASTE
        MENUITEM "&Löschen\tDel", ID_DELCTRL
        MENUITEM SEPARATOR
        POPUP "&Index"
        {
            MENUITEM "&Zum Seitenanfang", ID_CTRLINDEXTOP
            MENUITEM SEPARATOR
            MENUITEM "Index &verringern", ID_CTRLINDEXMINUS
            MENUITEM "&Inkrement-Index", ID_CTRLINDEXPLUS
            MENUITEM SEPARATOR
            MENUITEM "&Geh nach unten", ID_CTRLINDEXBOTTOM
            MENUITEM SEPARATOR
            MENUITEM "Indizes ein-/ausblenden\tCtrl+D", ID_SHOWHIDEINDEX
        }
        POPUP "&Ausrichtung"
        {
            MENUITEM "&Top-Align", ID_TOPALIGN
            MENUITEM "&Bottom-Align", ID_BOTTOMALIGN
            MENUITEM "&Left-Align", ID_LEFTALIGN
            MENUITEM "&Right-Align", ID_RIGHTALIGN
            MENUITEM SEPARATOR
            MENUITEM "An das Gitter anpassen", ID_FITTOGRID
        }
        MENUITEM SEPARATOR
        MENUITEM "&Aktualisierung", ID_REFRESHDIALOG
        MENUITEM SEPARATOR
        MENUITEM "&Eigenschaften für die Steuerung...", ID_CTRLPROP
        MENUITEM "Eigenschaften für &Dialog...", ID_DLGPROP
    }
    POPUP "Pop-up #2"
    {
        MENUITEM "&Ändern...", ID_MODIFYASSOC
    }
    POPUP "Pop-up #3"
    {
        MENUITEM "&Gehen!", ID_IDJUMP
        MENUITEM SEPARATOR
        MENUITEM "&ID hinzufügen...", ID_ADDRESID
        MENUITEM "&ID ändern...", ID_MODIFYRESID
        MENUITEM SEPARATOR
        MENUITEM "&Name kopieren", ID_COPYRESIDNAME
        MENUITEM "&Wert kopieren", ID_COPYRESIDVALUE
        MENUITEM "&Definition kopieren\tCtrl+C", ID_COPYIDDEF
        MENUITEM SEPARATOR
        MENUITEM "&ID löschen\tDel", ID_DELETERESID
        MENUITEM SEPARATOR
        MENUITEM "&Dezimal Zahlen", ID_BASE10
        MENUITEM "&Hexadezimalzahlen", ID_BASE16
        MENUITEM SEPARATOR
        MENUITEM "&Neu laden", ID_LOADRESH
    }
    POPUP "Pop-up #4"
    {
        MENUITEM "&Hinzufügen...", ID_ADD
        MENUITEM SEPARATOR
        MENUITEM "&Namen ändern...\tF2", ID_RENAME
        MENUITEM "&Wert ändern...", ID_MODIFY
        MENUITEM SEPARATOR
        MENUITEM "&Löschen\tDel", ID_DELETE
    }
    POPUP "Pop-up #5"
    {
        MENUITEM "&Ganzzahligen Wert kopieren", ID_COPY
    }
    POPUP "Pop-up #6"
    {
        MENUITEM "&Hinzufügen...", psh1
        MENUITEM "&Ändern...", psh2
        MENUITEM SEPARATOR
        MENUITEM "&Oben", psh4
        MENUITEM "&Nieder", psh5
        MENUITEM "&Links", psh6
        MENUITEM "&Recht", psh7
        MENUITEM SEPARATOR
        MENUITEM "&Löschen\tDel", psh3
    }
    POPUP "Pop-up #7"
    {
        MENUITEM "&Hinzufügen...", psh1
        MENUITEM "&Ändern...", psh2
        MENUITEM SEPARATOR
        MENUITEM "&Oben", psh4
        MENUITEM "&Nieder", psh5
        MENUITEM SEPARATOR
        MENUITEM "&Löschen\tDel", psh3
    }
    POPUP "Pop-up #8"
    {
        MENUITEM "&Hinzufügen...", ID_ADD
        MENUITEM "&Ändern...", ID_MODIFY
        MENUITEM SEPARATOR
        MENUITEM "&Löschen\tDel", ID_DELETE
    }
}

//////////////////////////////////////////////////////////////////////////////
// RT_DIALOG

IDD_REPLACERES DIALOGEX 0, 0, 215, 170
CAPTION "Ressource ersetzen"
STYLE DS_MODALFRAME | WS_POPUPWINDOW | WS_CAPTION
FONT 9, "MS Shell Dlg", 0, 0, 1
{
    LTEXT "Ressourcentyp:", -1, 5, 7, 70, 12
    COMBOBOX cmb1, 75, 5, 135, 200, CBS_HASSTRINGS | CBS_AUTOHSCROLL | CBS_DROPDOWN | WS_BORDER | WS_VSCROLL | WS_TABSTOP
    LTEXT "Ressourcenname:", -1, 5, 32, 70, 12
    COMBOBOX cmb2, 75, 30, 135, 200, CBS_HASSTRINGS | CBS_AUTOHSCROLL | CBS_DROPDOWN | WS_DISABLED | WS_BORDER | WS_VSCROLL | WS_TABSTOP
    LTEXT "Ressourcensprache:", -1, 5, 57, 70, 12
    COMBOBOX cmb3, 75, 55, 135, 200, CBS_HASSTRINGS | CBS_AUTOHSCROLL | CBS_DROPDOWN | WS_DISABLED | WS_BORDER | WS_VSCROLL | WS_TABSTOP
    LTEXT "Binärdatei:", -1, 5, 85, 100, 12
    EDITTEXT edt1, 5, 97, 205, 14, ES_AUTOHSCROLL
    PUSHBUTTON "Durchsuche...", psh1, 150, 115, 60, 14
    DEFPUSHBUTTON "OK", IDOK, 35, 150, 60, 14
    PUSHBUTTON "Stornieren", IDCANCEL, 115, 150, 60, 14
    {
        0x1234, 0x5678, 0x0011
    }
}

IDD_ADDICON DIALOG 0, 0, 215, 135
CAPTION "Symbol hinzufügen"
STYLE DS_MODALFRAME | WS_POPUPWINDOW | WS_CAPTION
FONT 9, "MS Shell Dlg"
{
    LTEXT "&Symboldatei:", -1, 5, 7, 100, 12
    EDITTEXT edt1, 5, 18, 205, 14, ES_AUTOHSCROLL
    PUSHBUTTON "&Durchsuche...", psh1, 150, 35, 60, 14
    ICON 0, ico1, 5, 35, 0, 0
    LTEXT "Ressourcenname:", -1, 5, 67, 70, 12
    COMBOBOX cmb2, 75, 65, 120, 300, CBS_HASSTRINGS | CBS_AUTOHSCROLL | CBS_DROPDOWN | WS_BORDER | WS_VSCROLL | WS_TABSTOP
    PUSHBUTTON "&...", psh2, 195, 65, 15, 14
    LTEXT "Ressourcensprache:", -1, 5, 92, 70, 12
    COMBOBOX cmb3, 75, 90, 135, 200, CBS_HASSTRINGS | CBS_AUTOHSCROLL | CBS_DROPDOWN | WS_BORDER | WS_VSCROLL | WS_TABSTOP
    DEFPUSHBUTTON "OK", IDOK, 35, 115, 60, 14
    PUSHBUTTON "Stornieren", IDCANCEL, 115, 115, 60, 14
}

IDD_REPLACEICON DIALOG 0, 0, 215, 135
CAPTION "Symbol ersetzen"
STYLE DS_MODALFRAME | WS_POPUPWINDOW | WS_CAPTION
FONT 9, "MS Shell Dlg"
{
    LTEXT "&Symboldatei:", -1, 5, 7, 100, 12
    EDITTEXT edt1, 5, 18, 205, 14, ES_AUTOHSCROLL
    PUSHBUTTON "&Durchsuche...", psh1, 150, 35, 60, 14
    ICON 0, ico1, 5, 35, 0, 0
    LTEXT "Ressourcenname:", -1, 5, 67, 70, 12
    COMBOBOX cmb2, 75, 65, 135, 13, CBS_HASSTRINGS | CBS_AUTOHSCROLL | CBS_DROPDOWN | WS_DISABLED | WS_BORDER | WS_VSCROLL | WS_TABSTOP
    LTEXT "Ressourcensprache:", -1, 5, 92, 70, 12
    COMBOBOX cmb3, 75, 90, 135, 13, CBS_HASSTRINGS | CBS_AUTOHSCROLL | CBS_DROPDOWN | WS_DISABLED | WS_BORDER | WS_VSCROLL | WS_TABSTOP
    DEFPUSHBUTTON "OK", IDOK, 35, 115, 60, 14
    PUSHBUTTON "Stornieren", IDCANCEL, 115, 115, 60, 14
}

IDD_ADDBITMAP DIALOG 0, 0, 215, 135
CAPTION "Bitmap hinzufügen"
STYLE DS_MODALFRAME | WS_POPUPWINDOW | WS_CAPTION
FONT 9, "MS Shell Dlg"
{
    LTEXT "&Bitmap-Datei:", -1, 5, 7, 100, 12
    EDITTEXT edt1, 5, 18, 205, 14, ES_AUTOHSCROLL
    PUSHBUTTON "&Durchsuche...", psh1, 150, 35, 60, 14
    LTEXT "Ressourcenname:", -1, 5, 67, 70, 12
    COMBOBOX cmb2, 75, 65, 120, 300, CBS_HASSTRINGS | CBS_AUTOHSCROLL | CBS_DROPDOWN | WS_BORDER | WS_VSCROLL | WS_TABSTOP
    PUSHBUTTON "&...", psh2, 195, 65, 15, 14
    LTEXT "Ressourcensprache:", -1, 5, 92, 70, 12
    COMBOBOX cmb3, 75, 90, 135, 200, CBS_HASSTRINGS | CBS_AUTOHSCROLL | CBS_DROPDOWN | WS_BORDER | WS_VSCROLL | WS_TABSTOP
    DEFPUSHBUTTON "OK", IDOK, 35, 115, 60, 14
    PUSHBUTTON "Stornieren", IDCANCEL, 115, 115, 60, 14
}

IDD_REPLACEBMP DIALOG 0, 0, 215, 135
CAPTION "Bitmap ersetzen"
STYLE DS_MODALFRAME | WS_POPUPWINDOW | WS_CAPTION
FONT 9, "MS Shell Dlg"
{
    LTEXT "&Bitmap-Datei:", -1, 5, 7, 100, 12
    EDITTEXT edt1, 5, 18, 205, 14, ES_AUTOHSCROLL
    PUSHBUTTON "&Durchsuche...", psh1, 150, 35, 60, 14
    LTEXT "Ressourcenname:", -1, 5, 67, 70, 12
    COMBOBOX cmb2, 75, 65, 135, 200, CBS_HASSTRINGS | CBS_AUTOHSCROLL | CBS_DROPDOWN | WS_DISABLED | WS_BORDER | WS_VSCROLL | WS_TABSTOP
    LTEXT "Ressourcensprache:", -1, 5, 92, 70, 12
    COMBOBOX cmb3, 75, 90, 135, 200, CBS_HASSTRINGS | CBS_AUTOHSCROLL | CBS_DROPDOWN | WS_DISABLED | WS_BORDER | WS_VSCROLL | WS_TABSTOP
    DEFPUSHBUTTON "OK", IDOK, 35, 115, 60, 14
    PUSHBUTTON "Stornieren", IDCANCEL, 115, 115, 60, 14
}

IDD_ADDRES DIALOG 0, 0, 215, 170
CAPTION "Ressource hinzufügen"
STYLE DS_MODALFRAME | WS_POPUPWINDOW | WS_CAPTION
FONT 9, "MS Shell Dlg"
{
    LTEXT "Ressourcentyp:", -1, 5, 7, 70, 12
    COMBOBOX cmb1, 75, 5, 135, 200, CBS_HASSTRINGS | CBS_AUTOHSCROLL | CBS_DROPDOWN | WS_BORDER | WS_VSCROLL | WS_TABSTOP
    LTEXT "Ressourcenname:", -1, 5, 32, 70, 12
    COMBOBOX cmb2, 75, 30, 120, 300, CBS_HASSTRINGS | CBS_AUTOHSCROLL | CBS_DROPDOWN | WS_BORDER | WS_VSCROLL | WS_TABSTOP
    PUSHBUTTON "&...", psh2, 195, 30, 15, 14
    LTEXT "", stc1, 75, 43, 115, 10
    LTEXT "Ressourcensprache:", -1, 5, 57, 70, 12
    COMBOBOX cmb3, 75, 55, 135, 200, CBS_HASSTRINGS | CBS_AUTOHSCROLL | CBS_DROPDOWN | WS_BORDER | WS_VSCROLL | WS_TABSTOP
    LTEXT "Binärdatei:", -1, 5, 85, 100, 12
    EDITTEXT edt1, 5, 97, 205, 14, ES_AUTOHSCROLL
    PUSHBUTTON "&Durchsuche...", psh1, 150, 115, 60, 14
    LTEXT "", stc2, 5, 112, 100, 10
    DEFPUSHBUTTON "OK", IDOK, 35, 150, 60, 14
    PUSHBUTTON "Stornieren", IDCANCEL, 115, 150, 60, 14
}

IDD_ADDCURSOR DIALOG 0, 0, 215, 135
CAPTION "Cursor hinzufügen"
STYLE DS_MODALFRAME | WS_POPUPWINDOW | WS_CAPTION
FONT 9, "MS Shell Dlg"
{
    LTEXT "&Cursor-Datei:", -1, 5, 7, 100, 12
    EDITTEXT edt1, 5, 18, 205, 14, ES_AUTOHSCROLL
    PUSHBUTTON "&Durchsuche...", psh1, 150, 35, 60, 14
    ICON 0, ico1, 5, 35, 0, 0
    LTEXT "Ressourcenname:", -1, 5, 67, 70, 12
    COMBOBOX cmb2, 75, 65, 120, 200, CBS_HASSTRINGS | CBS_AUTOHSCROLL | CBS_DROPDOWN | WS_BORDER | WS_VSCROLL | WS_TABSTOP
    PUSHBUTTON "&...", psh2, 195, 65, 15, 14
    LTEXT "Ressourcensprache:", -1, 5, 92, 70, 12
    COMBOBOX cmb3, 75, 90, 135, 200, CBS_HASSTRINGS | CBS_AUTOHSCROLL | CBS_DROPDOWN | WS_BORDER | WS_VSCROLL | WS_TABSTOP
    DEFPUSHBUTTON "OK", IDOK, 35, 115, 60, 14
    PUSHBUTTON "Stornieren", IDCANCEL, 115, 115, 60, 14
}

IDD_REPLACECUR DIALOG 0, 0, 215, 135
CAPTION "Cursor ersetzen"
STYLE DS_MODALFRAME | WS_POPUPWINDOW | WS_CAPTION
FONT 9, "MS Shell Dlg"
{
    LTEXT "&Cursor-Datei:", -1, 5, 7, 100, 12
    EDITTEXT edt1, 5, 18, 205, 14, ES_AUTOHSCROLL
    PUSHBUTTON "&Durchsuche...", psh1, 150, 35, 60, 14
    ICON 0, ico1, 5, 35, 0, 0
    LTEXT "Ressourcenname:", -1, 5, 67, 70, 12
    COMBOBOX cmb2, 75, 65, 135, 200, CBS_HASSTRINGS | CBS_AUTOHSCROLL | CBS_DROPDOWN | WS_DISABLED | WS_BORDER | WS_VSCROLL | WS_TABSTOP
    LTEXT "Ressourcensprache:", -1, 5, 92, 70, 12
    COMBOBOX cmb3, 75, 90, 135, 200, CBS_HASSTRINGS | CBS_AUTOHSCROLL | CBS_DROPDOWN | WS_DISABLED | WS_BORDER | WS_VSCROLL | WS_TABSTOP
    DEFPUSHBUTTON "OK", IDOK, 35, 115, 60, 14
    PUSHBUTTON "Stornieren", IDCANCEL, 115, 115, 60, 14
}

IDD_MENUTEST DIALOG 0, 0, 215, 135
CAPTION "Menütest"
STYLE DS_MODALFRAME | WS_POPUPWINDOW | WS_CAPTION
FONT 9, "MS Shell Dlg"
{
}

IDD_ADDKEY DIALOG 0, 0, 190, 120
CAPTION "Schlüssel hinzufügen"
STYLE DS_MODALFRAME | WS_POPUPWINDOW | WS_CAPTION
FONT 9, "MS Shell Dlg"
{
    RTEXT "&Schlüssel:", -1, 5, 12, 60, 14
    COMBOBOX cmb1, 70, 10, 110, 200, CBS_DROPDOWN | WS_BORDER | WS_VSCROLL | WS_TABSTOP
    RTEXT "Befehls-ID:", -1, 5, 37, 60, 14
    COMBOBOX cmb2, 70, 35, 95, 300, CBS_DROPDOWN | WS_BORDER | WS_VSCROLL | WS_TABSTOP
    PUSHBUTTON "&...", psh1, 165, 35, 15, 14
    AUTOCHECKBOX "&VIRTKEY", chx1, 5, 60, 60, 14
    AUTOCHECKBOX "&NOINVERT", chx2, 70, 60, 60, 14
    AUTOCHECKBOX "&CONTROL", chx3, 5, 75, 60, 14
    AUTOCHECKBOX "&SHIFT", chx4, 70, 75, 60, 14
    AUTOCHECKBOX "&ALT", chx5, 140, 75, 45, 14
    DEFPUSHBUTTON "OK", IDOK, 60, 100, 60, 14
    PUSHBUTTON "Stornieren", IDCANCEL, 125, 100, 60, 14
}

IDD_MODIFYKEY DIALOG 0, 0, 190, 120
CAPTION "Schlüssel ändern"
STYLE DS_MODALFRAME | WS_POPUPWINDOW | WS_CAPTION
FONT 9, "MS Shell Dlg"
{
    RTEXT "&Schlüssel:", -1, 5, 12, 60, 14
    COMBOBOX cmb1, 70, 10, 110, 200, CBS_DROPDOWN | WS_BORDER | WS_VSCROLL | WS_TABSTOP
    RTEXT "Befehls-ID:", -1, 5, 37, 60, 14
    COMBOBOX cmb2, 70, 35, 95, 200, CBS_DROPDOWN | WS_BORDER | WS_VSCROLL | WS_TABSTOP
    PUSHBUTTON "&...", psh1, 165, 35, 15, 14
    AUTOCHECKBOX "&VIRTKEY", chx1, 5, 60, 60, 14
    AUTOCHECKBOX "&NOINVERT", chx2, 70, 60, 60, 14
    AUTOCHECKBOX "&CONTROL", chx3, 5, 75, 60, 14
    AUTOCHECKBOX "&SHIFT", chx4, 70, 75, 60, 14
    AUTOCHECKBOX "&ALT", chx5, 140, 75, 45, 14
    DEFPUSHBUTTON "OK", IDOK, 60, 100, 60, 14
    PUSHBUTTON "Stornieren", IDCANCEL, 125, 100, 60, 14
}

IDD_EDITACCEL DIALOG 0, 0, 285, 165
CAPTION "Beschleuniger bearbeiten"
STYLE WS_POPUPWINDOW | WS_CAPTION | WS_THICKFRAME
FONT 9, "MS Shell Dlg"
{
    LTEXT "Schlüsselliste:", -1, 5, 7, 100, 12
    CONTROL "", lst1, "SysListView32", LVS_NOSORTHEADER | LVS_AUTOARRANGE | LVS_NOLABELWRAP | LVS_SHOWSELALWAYS | LVS_SINGLESEL | LVS_REPORT | WS_BORDER | WS_VSCROLL | WS_HSCROLL | WS_TABSTOP, 5, 20, 210, 120
    PUSHBUTTON "&Hinzufügen...", psh1, 220, 20, 60, 14
    PUSHBUTTON "&Ändern...", psh2, 220, 40, 60, 14
    PUSHBUTTON "&Löschen", psh3, 220, 60, 60, 14
    PUSHBUTTON "&Oben", psh4, 220, 100, 60, 14
    PUSHBUTTON "&Nieder", psh5, 220, 120, 60, 14
    DEFPUSHBUTTON "OK", IDOK, 155, 145, 60, 14
    PUSHBUTTON "Stornieren", IDCANCEL, 220, 145, 60, 14
    PUSHBUTTON "&Alles löschen", psh6, 5, 145, 79, 14
}

IDD_ADDSTR DIALOG 0, 0, 255, 115
CAPTION "String-Eintrag hinzufügen"
STYLE WS_POPUPWINDOW | WS_CAPTION | WS_THICKFRAME
FONT 9, "MS Shell Dlg"
{
    LTEXT "String &ID:", -1, 5, 7, 50, 12
    COMBOBOX cmb1, 60, 5, 134, 200, CBS_HASSTRINGS | CBS_AUTOHSCROLL | CBS_DROPDOWN | WS_BORDER | WS_VSCROLL | WS_TABSTOP
    PUSHBUTTON "&...", psh1, 195, 5, 15, 14
    LTEXT "String-&Wert:", -1, 5, 27, 54, 12
    EDITTEXT edt1, 60, 25, 190, 45, ES_WANTRETURN | ES_AUTOVSCROLL | ES_MULTILINE | WS_VSCROLL
    AUTOCHECKBOX "&Ersetzen Sie ""\\r\\n"" durch ""\\n""", chx1, 60, 75, 190, 14
    DEFPUSHBUTTON "OK", IDOK, 125, 95, 60, 14
    PUSHBUTTON "Stornieren", IDCANCEL, 190, 95, 60, 14
}

IDD_MODIFYSTR DIALOG 0, 0, 255, 115
CAPTION "String-Eintrag ändern"
STYLE WS_POPUPWINDOW | WS_CAPTION | WS_THICKFRAME
FONT 9, "MS Shell Dlg"
{
    LTEXT "String &ID:", -1, 5, 7, 50, 12
    COMBOBOX cmb1, 60, 5, 134, 200, CBS_HASSTRINGS | CBS_AUTOHSCROLL | CBS_DROPDOWN | WS_BORDER | WS_VSCROLL | WS_TABSTOP
    PUSHBUTTON "&...", psh1, 195, 5, 15, 14
    LTEXT "String-&Wert:", -1, 5, 27, 54, 12
    EDITTEXT edt1, 60, 25, 190, 45, ES_WANTRETURN | ES_AUTOVSCROLL | ES_MULTILINE | WS_VSCROLL
    AUTOCHECKBOX "&Ersetzen Sie ""\\r\\n"" durch ""\\n""", chx1, 60, 75, 190, 14
    DEFPUSHBUTTON "OK", IDOK, 125, 95, 60, 14
    PUSHBUTTON "Stornieren", IDCANCEL, 190, 95, 60, 14
}

IDD_STRINGS DIALOG 0, 0, 325, 160
CAPTION "String-Tabelle"
STYLE WS_POPUPWINDOW | WS_CAPTION | WS_THICKFRAME
FONT 9, "MS Shell Dlg"
{
    LTEXT "String-Einträge:", -1, 5, 7, 100, 12
    CONTROL "", lst1, "SysListView32", LVS_NOSORTHEADER | LVS_AUTOARRANGE | LVS_NOLABELWRAP | LVS_SHOWSELALWAYS | LVS_SINGLESEL | LVS_REPORT | WS_BORDER | WS_VSCROLL | WS_HSCROLL | WS_TABSTOP, 5, 20, 315, 115
    PUSHBUTTON "&Hinzufügen...", psh1, 130, 3, 60, 14
    PUSHBUTTON "&Ändern...", psh2, 195, 3, 60, 14
    PUSHBUTTON "&Löschen", psh3, 260, 3, 60, 14
    DEFPUSHBUTTON "OK", IDOK, 195, 140, 60, 14
    PUSHBUTTON "Stornieren", IDCANCEL, 260, 140, 60, 14
    PUSHBUTTON "&Alles löschen", psh4, 5, 140, 75, 14
}

IDD_ADDMITEM DIALOG 0, 0, 210, 200
CAPTION "Menüelement hinzufügen"
STYLE DS_MODALFRAME | WS_POPUPWINDOW | WS_CAPTION
FONT 9, "MS Shell Dlg"
{
    LTEXT "Bildbeschriftung:", -1, 5, 7, 55, 12
    COMBOBOX cmb1, 65, 6, 140, 200, CBS_AUTOHSCROLL | CBS_DROPDOWN | WS_BORDER | WS_VSCROLL | WS_TABSTOP
    LTEXT "Befehls-ID:", -1, 5, 32, 55, 12
    COMBOBOX cmb2, 65, 30, 125, 200, CBS_AUTOHSCROLL | CBS_DROPDOWN | WS_BORDER | WS_VSCROLL | WS_TABSTOP
    PUSHBUTTON "&...", psh1, 190, 30, 15, 14
    AUTOCHECKBOX "&GRAYED", chx1, 5, 60, 60, 14
    AUTOCHECKBOX "&BITMAP", chx3, 135, 60, 60, 14
    AUTOCHECKBOX "&OWNERDRAW", chx4, 5, 80, 65, 14
    AUTOCHECKBOX "&CHECKED", chx5, 75, 80, 60, 14
    AUTOCHECKBOX "SE&PARATOR", chx6, 140, 80, 60, 14
    AUTOCHECKBOX "MENU&BARBREAK", chx7, 5, 100, 75, 14
    AUTOCHECKBOX "MENUB&REAK", chx8, 85, 100, 70, 14
    AUTOCHECKBOX "&DEFAULT", chx9, 5, 120, 60, 14
    AUTOCHECKBOX "&HILITE", chx10, 70, 120, 60, 14
    AUTOCHECKBOX "RADIOCHEC&K", chx11, 135, 120, 60, 14
    AUTOCHECKBOX "RIGH&TORDER", chx12, 5, 139, 60, 14
    AUTOCHECKBOX "RIGHT&JUSTIFY", chx13, 70, 140, 70, 14
    LTEXT "Hilfe-ID:", -1, 5, 162, 45, 12
    COMBOBOX cmb3, 55, 160, 100, 300, CBS_AUTOHSCROLL | CBS_DROPDOWN | WS_BORDER | WS_VSCROLL | WS_TABSTOP
    DEFPUSHBUTTON "OK", IDOK, 80, 180, 60, 14
    PUSHBUTTON "Stornieren", IDCANCEL, 145, 180, 60, 14
}

IDD_MODIFYMITEM DIALOG 0, 0, 210, 200
CAPTION "Menüpunkt ändern"
STYLE DS_MODALFRAME | WS_POPUPWINDOW | WS_CAPTION
FONT 9, "MS Shell Dlg"
{
    LTEXT "Bildbeschriftung:", -1, 5, 7, 55, 12
    COMBOBOX cmb1, 65, 6, 140, 200, CBS_AUTOHSCROLL | CBS_DROPDOWN | WS_BORDER | WS_VSCROLL | WS_TABSTOP
    LTEXT "Befehls-ID:", -1, 5, 32, 55, 12
    COMBOBOX cmb2, 65, 30, 125, 200, CBS_AUTOHSCROLL | CBS_DROPDOWN | WS_BORDER | WS_VSCROLL | WS_TABSTOP
    PUSHBUTTON "&...", psh1, 190, 30, 15, 14
    AUTOCHECKBOX "&GRAYED", chx1, 5, 60, 60, 14
    AUTOCHECKBOX "&BITMAP", chx3, 135, 60, 60, 14
    AUTOCHECKBOX "&OWNERDRAW", chx4, 5, 80, 65, 14
    AUTOCHECKBOX "&CHECKED", chx5, 75, 80, 60, 14
    AUTOCHECKBOX "SE&PARATOR", chx6, 140, 80, 60, 14
    AUTOCHECKBOX "MENU&BARBREAK", chx7, 5, 100, 75, 14
    AUTOCHECKBOX "MENUB&REAK", chx8, 85, 100, 70, 14
    AUTOCHECKBOX "&DEFAULT", chx9, 5, 120, 60, 14
    AUTOCHECKBOX "&HILITE", chx10, 70, 120, 60, 14
    AUTOCHECKBOX "RADIOCHEC&K", chx11, 135, 120, 60, 14
    AUTOCHECKBOX "RIGH&TORDER", chx12, 5, 139, 60, 14
    AUTOCHECKBOX "RIGHT&JUSTIFY", chx13, 70, 140, 70, 14
    LTEXT "Hilfe-ID:", -1, 5, 162, 45, 12
    COMBOBOX cmb3, 55, 160, 100, 300, CBS_AUTOHSCROLL | CBS_DROPDOWN | WS_BORDER | WS_VSCROLL | WS_TABSTOP
    DEFPUSHBUTTON "OK", IDOK, 80, 180, 60, 14
    PUSHBUTTON "Stornieren", IDCANCEL, 145, 180, 60, 14
}

IDD_EDITMENU DIALOG 0, 0, 325, 160
CAPTION "Menüressource bearbeiten"
STYLE WS_POPUPWINDOW | WS_CAPTION | WS_THICKFRAME
FONT 9, "MS Shell Dlg"
{
    LTEXT "Menü Ressource:", -1, 5, 7, 85, 12
    CONTROL "", lst1, "SysListView32", LVS_NOSORTHEADER | LVS_AUTOARRANGE | LVS_NOLABELWRAP | LVS_SHOWSELALWAYS | LVS_SINGLESEL | LVS_REPORT | WS_BORDER | WS_VSCROLL | WS_HSCROLL | WS_TABSTOP, 5, 20, 315, 115
    PUSHBUTTON "&Hinzufügen...", psh1, 95, 3, 50, 14
    PUSHBUTTON "&Ändern...", psh2, 150, 3, 50, 14
    PUSHBUTTON "&Löschen", psh3, 205, 3, 50, 14
    PUSHBUTTON "&Oben", psh4, 5, 140, 40, 14
    PUSHBUTTON "&Nieder", psh5, 50, 140, 40, 14
    PUSHBUTTON "&Links", psh6, 95, 140, 40, 14
    PUSHBUTTON "&Recht", psh7, 140, 140, 41, 14
    AUTOCHECKBOX "Verlängert", chx1, 260, 3, 60, 14
    DEFPUSHBUTTON "OK", IDOK, 195, 140, 60, 14
    PUSHBUTTON "Stornieren", IDCANCEL, 260, 140, 60, 14
}

IDD_DLGPROP DIALOG 0, 0, 235, 315
CAPTION "Eigenschaften für Dialog"
STYLE DS_MODALFRAME | WS_POPUPWINDOW | WS_CAPTION
FONT 9, "MS Shell Dlg"
{
    LTEXT "Bildbeschriftung:", -1, 5, 7, 85, 11
    COMBOBOX cmb1, 5, 20, 225, 300, CBS_HASSTRINGS | CBS_AUTOHSCROLL | CBS_DROPDOWN | WS_BORDER | WS_VSCROLL | WS_TABSTOP
    AUTOCHECKBOX "E&xtended Dialog", chx1, 100, 5, 86, 14
    LTEXT "&Links:", -1, 5, 40, 33, 10
    EDITTEXT edt1, 5, 53, 30, 14, ES_NUMBER | ES_RIGHT
    CONTROL "", scr1, "msctls_updown32", UDS_NOTHOUSANDS | UDS_ARROWKEYS | UDS_AUTOBUDDY | UDS_ALIGNRIGHT | UDS_SETBUDDYINT, 23, 53, 12, 20
    LTEXT "&Oben:", -1, 50, 40, 33, 10
    EDITTEXT edt2, 50, 53, 30, 14, ES_NUMBER | ES_RIGHT
    CONTROL "", scr2, "msctls_updown32", UDS_NOTHOUSANDS | UDS_ARROWKEYS | UDS_AUTOBUDDY | UDS_ALIGNRIGHT | UDS_SETBUDDYINT, 53, 53, 12, 20
    LTEXT "&Breite:", -1, 95, 40, 33, 10
    EDITTEXT edt3, 95, 53, 30, 14, ES_NUMBER | ES_RIGHT
    CONTROL "", scr3, "msctls_updown32", UDS_NOTHOUSANDS | UDS_ARROWKEYS | UDS_AUTOBUDDY | UDS_ALIGNRIGHT | UDS_SETBUDDYINT, 129, 56, 12, 20
    LTEXT "&Höhe:", -1, 142, 40, 33, 10
    EDITTEXT edt4, 142, 53, 30, 14, ES_NUMBER | ES_RIGHT
    CONTROL "", scr4, "msctls_updown32", UDS_NOTHOUSANDS | UDS_ARROWKEYS | UDS_AUTOBUDDY | UDS_ALIGNRIGHT | UDS_SETBUDDYINT, 162, 53, 12, 20
    LTEXT "&Klassenname:", -1, 5, 73, 85, 11
    COMBOBOX cmb2, 5, 88, 115, 200, CBS_HASSTRINGS | CBS_AUTOHSCROLL | CBS_DROPDOWN | WS_BORDER | WS_VSCROLL | WS_TABSTOP
    LTEXT "&Hilfe-ID:", -1, 125, 73, 64, 11
    COMBOBOX cmb3, 125, 88, 65, 200, CBS_HASSTRINGS | CBS_AUTOHSCROLL | CBS_DROPDOWN | WS_BORDER | WS_VSCROLL | WS_TABSTOP
    LTEXT "&Schriftartenname:", -1, 5, 105, 80, 11
    COMBOBOX cmb4, 6, 118, 100, 200, CBS_HASSTRINGS | CBS_SORT | CBS_AUTOHSCROLL | CBS_DROPDOWN | WS_BORDER | WS_VSCROLL | WS_TABSTOP
    LTEXT "&Größe:", -1, 110, 105, 38, 12
    EDITTEXT edt5, 110, 118, 25, 14, ES_NUMBER
    AUTOCHECKBOX "&B", chx2, 140, 118, 20, 14
    AUTOCHECKBOX "&I", chx3, 165, 118, 20, 14
    LTEXT "Cha&rSet:", -1, 5, 138, 80, 11
    COMBOBOX cmb5, 5, 148, 100, 100, CBS_AUTOHSCROLL | CBS_DROPDOWNLIST | WS_VSCROLL | WS_TABSTOP
    LTEXT "&Menüname:", -1, 110, 138, 55, 11
    COMBOBOX cmb6, 110, 148, 99, 300, CBS_HASSTRINGS | CBS_AUTOHSCROLL | CBS_DROPDOWN | WS_BORDER | WS_VSCROLL | WS_TABSTOP
    LTEXT "&Stil:", -1, 5, 168, 45, 11
    RTEXT "0x", -1, 52, 169, 10, 11
    EDITTEXT edt6, 67, 165, 45, 14, ES_AUTOHSCROLL
    LISTBOX lst1, 5, 183, 110, 110, LBS_DISABLENOSCROLL | LBS_NOINTEGRALHEIGHT | LBS_HASSTRINGS | LBS_MULTIPLESEL | WS_VSCROLL | WS_HSCROLL | WS_TABSTOP
    LTEXT "&ExStil:", -1, 120, 168, 48, 11
    RTEXT "0x", -1, 170, 169, 10, 11
    EDITTEXT edt7, 185, 165, 45, 14, ES_AUTOHSCROLL
    LISTBOX lst2, 120, 183, 110, 110, LBS_DISABLENOSCROLL | LBS_NOINTEGRALHEIGHT | LBS_HASSTRINGS | LBS_MULTIPLESEL | WS_VSCROLL | WS_HSCROLL | WS_TABSTOP
    DEFPUSHBUTTON "OK", IDOK, 106, 298, 60, 14
    PUSHBUTTON "Stornieren", IDCANCEL, 171, 298, 60, 14
}

IDD_CTRLPROP DIALOG 0, 0, 235, 330
CAPTION "Eigenschaften für die Steuerung"
STYLE DS_MODALFRAME | WS_POPUPWINDOW | WS_CAPTION
FONT 9, "MS Shell Dlg"
{
    LTEXT "Predef. Strg:", -1, 5, 7, 68, 12
    COMBOBOX cmb1, 75, 5, 120, 55, CBS_HASSTRINGS | CBS_AUTOHSCROLL | CBS_DROPDOWN | WS_BORDER | WS_VSCROLL | WS_TABSTOP
    CONTROL "", ctl1, "ToolbarWindow32", TBSTYLE_FLAT | TBSTYLE_WRAPABLE | TBSTYLE_TOOLTIPS | CCS_NODIVIDER | CCS_NORESIZE, 5, 22, 185, 30
    LTEXT "Bildbeschriftung:", -1, 5, 55, 75, 12
    COMBOBOX cmb2, 5, 65, 195, 300, CBS_HASSTRINGS | CBS_AUTOHSCROLL | CBS_DROPDOWN | WS_BORDER | WS_VSCROLL | WS_TABSTOP
    PUSHBUTTON "&OLE...", psh2, 205, 65, 25, 14
    LTEXT "&Links:", -1, 5, 85, 33, 11
    EDITTEXT edt1, 5, 99, 25, 14, ES_NUMBER | ES_RIGHT
    CONTROL "", scr1, "msctls_updown32", UDS_NOTHOUSANDS | UDS_ARROWKEYS | UDS_AUTOBUDDY | UDS_ALIGNRIGHT | UDS_SETBUDDYINT, 20, 99, 12, 20
    LTEXT "&Oben:", -1, 40, 85, 33, 11
    EDITTEXT edt2, 40, 99, 25, 14, ES_NUMBER | ES_RIGHT
    CONTROL "", scr2, "msctls_updown32", UDS_NOTHOUSANDS | UDS_ARROWKEYS | UDS_AUTOBUDDY | UDS_ALIGNRIGHT | UDS_SETBUDDYINT, 55, 99, 12, 20
    LTEXT "&Breite:", -1, 75, 85, 33, 11
    EDITTEXT edt3, 75, 99, 25, 14, ES_NUMBER | ES_RIGHT
    CONTROL "", scr3, "msctls_updown32", UDS_NOTHOUSANDS | UDS_ARROWKEYS | UDS_AUTOBUDDY | UDS_ALIGNRIGHT | UDS_SETBUDDYINT, 90, 99, 12, 20
    LTEXT "&Höhe:", -1, 111, 85, 33, 11
    EDITTEXT edt4, 110, 99, 25, 14, ES_NUMBER | ES_RIGHT
    CONTROL "", scr4, "msctls_updown32", UDS_NOTHOUSANDS | UDS_ARROWKEYS | UDS_AUTOBUDDY | UDS_ALIGNRIGHT | UDS_SETBUDDYINT, 125, 99, 12, 20
    LTEXT "&ID:", -1, 150, 85, 70, 12
    COMBOBOX cmb3, 150, 99, 80, 300, CBS_HASSTRINGS | CBS_AUTOHSCROLL | CBS_DROPDOWN | WS_BORDER | WS_VSCROLL | WS_TABSTOP
    LTEXT "Name der Fensterklasse:", -1, 5, 119, 100, 12
    COMBOBOX cmb4, 5, 133, 115, 200, CBS_HASSTRINGS | CBS_AUTOHSCROLL | CBS_DROPDOWN | WS_BORDER | WS_VSCROLL | WS_TABSTOP
    LTEXT "Hilfe-ID:", -1, 125, 119, 70, 12
    COMBOBOX cmb5, 125, 133, 65, 200, CBS_HASSTRINGS | CBS_AUTOHSCROLL | CBS_DROPDOWN | WS_BORDER | WS_VSCROLL | WS_TABSTOP
    LTEXT "Stil:", -1, 5, 153, 45, 12
    RTEXT "0x", -1, 54, 153, 10, 12
    EDITTEXT edt6, 70, 151, 45, 14, ES_AUTOHSCROLL
    LISTBOX lst1, 5, 167, 110, 120, LBS_DISABLENOSCROLL | LBS_NOINTEGRALHEIGHT | LBS_HASSTRINGS | LBS_MULTIPLESEL | WS_VSCROLL | WS_HSCROLL | WS_TABSTOP
    LTEXT "&ExStil:", -1, 120, 153, 50, 12
    RTEXT "0x", -1, 172, 153, 10, 12
    EDITTEXT edt7, 185, 151, 45, 14, ES_AUTOHSCROLL
    LISTBOX lst2, 120, 167, 110, 120, LBS_DISABLENOSCROLL | LBS_NOINTEGRALHEIGHT | LBS_HASSTRINGS | LBS_MULTIPLESEL | WS_VSCROLL | WS_HSCROLL | WS_TABSTOP
    DEFPUSHBUTTON "OK", IDOK, 170, 293, 60, 14
    PUSHBUTTON "Stornieren", IDCANCEL, 170, 309, 60, 14
    PUSHBUTTON "&Daten...", psh1, 5, 293, 90, 14
    PUSHBUTTON "Die &Stringliste...", psh3, 5, 309, 90, 14
}

IDD_ADDCTRL DIALOG 0, 0, 235, 330
CAPTION "Kontrolle hinzufügen"
STYLE DS_MODALFRAME | WS_POPUPWINDOW | WS_CAPTION
FONT 9, "MS Shell Dlg"
{
    LTEXT "Predef. Strg:", -1, 5, 7, 68, 12
    COMBOBOX cmb1, 75, 5, 120, 55, CBS_HASSTRINGS | CBS_AUTOHSCROLL | CBS_DROPDOWN | WS_BORDER | WS_VSCROLL | WS_TABSTOP
    CONTROL "", ctl1, "ToolbarWindow32", TBSTYLE_FLAT | TBSTYLE_WRAPABLE | TBSTYLE_TOOLTIPS | CCS_NODIVIDER | CCS_NORESIZE, 5, 22, 185, 30
    LTEXT "Bildbeschriftung:", -1, 5, 55, 75, 12
    COMBOBOX cmb2, 5, 65, 195, 300, CBS_HASSTRINGS | CBS_AUTOHSCROLL | CBS_DROPDOWN | WS_BORDER | WS_VSCROLL | WS_TABSTOP
    PUSHBUTTON "&OLE...", psh2, 205, 65, 25, 14
    LTEXT "&Links:", -1, 5, 85, 33, 11
    EDITTEXT edt1, 5, 99, 25, 14, ES_NUMBER | ES_RIGHT
    CONTROL "", scr1, "msctls_updown32", UDS_NOTHOUSANDS | UDS_ARROWKEYS | UDS_AUTOBUDDY | UDS_ALIGNRIGHT | UDS_SETBUDDYINT, 20, 99, 12, 20
    LTEXT "&Oben:", -1, 40, 85, 33, 11
    EDITTEXT edt2, 40, 99, 25, 14, ES_NUMBER | ES_RIGHT
    CONTROL "", scr2, "msctls_updown32", UDS_NOTHOUSANDS | UDS_ARROWKEYS | UDS_AUTOBUDDY | UDS_ALIGNRIGHT | UDS_SETBUDDYINT, 55, 99, 12, 20
    LTEXT "&Breite:", -1, 75, 85, 33, 11
    EDITTEXT edt3, 75, 99, 25, 14, ES_NUMBER | ES_RIGHT
    CONTROL "", scr3, "msctls_updown32", UDS_NOTHOUSANDS | UDS_ARROWKEYS | UDS_AUTOBUDDY | UDS_ALIGNRIGHT | UDS_SETBUDDYINT, 90, 99, 12, 20
    LTEXT "&Höhe:", -1, 111, 85, 33, 11
    EDITTEXT edt4, 110, 99, 25, 14, ES_NUMBER | ES_RIGHT
    CONTROL "", scr4, "msctls_updown32", UDS_NOTHOUSANDS | UDS_ARROWKEYS | UDS_AUTOBUDDY | UDS_ALIGNRIGHT | UDS_SETBUDDYINT, 125, 99, 12, 20
    LTEXT "&ID:", -1, 150, 85, 70, 12
    COMBOBOX cmb3, 150, 99, 80, 300, CBS_HASSTRINGS | CBS_AUTOHSCROLL | CBS_DROPDOWN | WS_BORDER | WS_VSCROLL | WS_TABSTOP
    LTEXT "Name der Fensterklasse:", -1, 5, 119, 100, 12
    COMBOBOX cmb4, 5, 133, 115, 200, CBS_HASSTRINGS | CBS_AUTOHSCROLL | CBS_DROPDOWN | WS_BORDER | WS_VSCROLL | WS_TABSTOP
    LTEXT "Hilfe-ID:", -1, 125, 119, 70, 12
    COMBOBOX cmb5, 125, 133, 65, 200, CBS_HASSTRINGS | CBS_AUTOHSCROLL | CBS_DROPDOWN | WS_BORDER | WS_VSCROLL | WS_TABSTOP
    LTEXT "Stil:", -1, 5, 153, 45, 12
    RTEXT "0x", -1, 54, 153, 10, 12
    EDITTEXT edt6, 70, 151, 45, 14, ES_AUTOHSCROLL
    LISTBOX lst1, 5, 167, 110, 120, LBS_DISABLENOSCROLL | LBS_NOINTEGRALHEIGHT | LBS_HASSTRINGS | LBS_MULTIPLESEL | WS_VSCROLL | WS_HSCROLL | WS_TABSTOP
    LTEXT "&ExStil:", -1, 120, 153, 50, 12
    RTEXT "0x", -1, 172, 153, 10, 12
    EDITTEXT edt7, 185, 151, 45, 14, ES_AUTOHSCROLL
    LISTBOX lst2, 120, 167, 110, 120, LBS_DISABLENOSCROLL | LBS_NOINTEGRALHEIGHT | LBS_HASSTRINGS | LBS_MULTIPLESEL | WS_VSCROLL | WS_HSCROLL | WS_TABSTOP
    DEFPUSHBUTTON "OK", IDOK, 170, 293, 60, 14
    PUSHBUTTON "Stornieren", IDCANCEL, 170, 309, 60, 14
    PUSHBUTTON "&Daten...", psh1, 5, 293, 90, 14
    PUSHBUTTON "Die &Stringliste...", psh3, 5, 309, 90, 14
}

IDD_IDASSOC DIALOG 0, 0, 200, 220
CAPTION "ID Association"
STYLE DS_MODALFRAME | WS_POPUPWINDOW | WS_CAPTION
FONT 9, "MS Shell Dlg"
{
    LTEXT "ID Assocation:", -1, 5, 5, 116, 12
    CONTROL "", lst1, "SysListView32", LVS_SHOWSELALWAYS | LVS_SINGLESEL | LVS_REPORT | WS_BORDER | WS_TABSTOP, 5, 20, 190, 150
    PUSHBUTTON "&Alles zurücksetzen", psh2, 5, 175, 85, 14
    PUSHBUTTON "&Ändern", psh1, 135, 175, 60, 14
    DEFPUSHBUTTON "OK", IDOK, 70, 200, 60, 14
    PUSHBUTTON "Stornieren", IDCANCEL, 135, 200, 60, 14
}

IDD_MODIFYASSOC DIALOG 0, 0, 165, 68
CAPTION "ID-Zuordnung ändern"
STYLE DS_MODALFRAME | WS_POPUPWINDOW | WS_CAPTION
FONT 9, "MS Shell Dlg"
{
    RTEXT "&Art der ID:", -1, 5, 7, 65, 12
    EDITTEXT edt1, 80, 5, 80, 14, WS_DISABLED
    RTEXT "&Präfix der ID:", -1, 5, 32, 65, 12
    EDITTEXT edt2, 80, 28, 80, 14, ES_AUTOHSCROLL
    DEFPUSHBUTTON "OK", IDOK, 35, 50, 60, 14
    PUSHBUTTON "Stornieren", IDCANCEL, 100, 50, 60, 14
}

IDD_IDLIST DIALOG 0, 0, 200, 300
CAPTION "Liste der Ressourcen-IDs"
STYLE WS_OVERLAPPEDWINDOW
EXSTYLE WS_EX_TOOLWINDOW
FONT 9, "MS Shell Dlg"
{
    COMBOBOX cmb1, 0, 0, 200, 300, CBS_HASSTRINGS | CBS_SORT | CBS_OWNERDRAWFIXED | CBS_DROPDOWNLIST | WS_VSCROLL | WS_TABSTOP
    CONTROL "", lst1, "SysListView32", LVS_REPORT | WS_BORDER | WS_VSCROLL | WS_HSCROLL | WS_TABSTOP, 0, 15, 200, 285
}

IDD_CONFIG DIALOG 0, 0, 210, 285
CAPTION "Aufbau"
STYLE DS_MODALFRAME | WS_POPUPWINDOW | WS_CAPTION
FONT 9, "MS Shell Dlg"
{
    AUTOCHECKBOX "Vollständigen Dateipfad in der Titelleiste anzeigen", chx1, 5, 5, 200, 14
    AUTOCHECKBOX "Verwenden Sie keine ID-Makros", chx2, 5, 25, 200, 14
    AUTOCHECKBOX "Setzen Sie die vorherige Fensterposition fort", chx3, 5, 45, 200, 14
    AUTOCHECKBOX "Laden Sie automatisch in der Nähe ""resource.h""", chx4, 5, 65, 200, 14
    AUTOCHECKBOX "Zeigt automatisch die Liste der Ressourcen-IDs an", chx5, 5, 85, 200, 14
    AUTOCHECKBOX "Punkte beim Bearbeiten des Dialogfelds anzeigen", chx6, 5, 105, 200, 14
    RTEXT "Höhe der ComboBox:", -1, 10, 127, 75, 12
    EDITTEXT edt1, 90, 125, 34, 14, ES_NUMBER | ES_RIGHT
    CONTROL "", scr1, "msctls_updown32", UDS_NOTHOUSANDS | UDS_ARROWKEYS | UDS_AUTOBUDDY | UDS_ALIGNRIGHT | UDS_SETBUDDYINT, 129, 49, 12, 20
    AUTOCHECKBOX "&Zeilenumbruch", chx9, 135, 125, 70, 14
    AUTOCHECKBOX "Fragen Sie nach dem Update von ""resource.h""", chx7, 5, 145, 200, 14
    AUTOCHECKBOX "Komprimieren Sie EXE von UPX beim Speichern", chx8, 5, 165, 200, 14
    PUSHBUTTON "&Schriftarten...", psh4, 5, 185, 200, 14
    PUSHBUTTON "Vordefinierte Makros...", psh1, 5, 205, 93, 14
    PUSHBUTTON "Pfade festlegen...", psh2, 107, 205, 98, 14
    RTEXT "Name der OLE-Steuerelemente:", -1, 5, 222, 80, 18
    COMBOBOX cmb1, 90, 225, 75, 300, CBS_HASSTRINGS | CBS_AUTOHSCROLL | CBS_DROPDOWN | WS_VSCROLL | WS_TABSTOP
    AUTOCHECKBOX "Ein Backup erstellen", chx10, 5, 245, 80, 15
    RTEXT "Backup-Suffix:", -1, 90, 245, 60, 15
    COMBOBOX cmb2, 158, 244, 45, 300, CBS_HASSTRINGS | CBS_AUTOHSCROLL | CBS_DROPDOWN | WS_VSCROLL | WS_TABSTOP
    DEFPUSHBUTTON "OK", IDOK, 100, 265, 50, 14
    PUSHBUTTON "Stornieren", IDCANCEL, 155, 265, 50, 14
    PUSHBUTTON "Alles zurücksetzen", psh3, 5, 265, 75, 14
}

IDD_ADDRESID DIALOG 0, 0, 165, 90
CAPTION "Ressourcen-ID hinzufügen"
STYLE DS_MODALFRAME | WS_POPUPWINDOW | WS_CAPTION
FONT 9, "MS Shell Dlg"
{
    RTEXT "&Art der ID:", -1, 10, 7, 50, 14
    COMBOBOX cmb1, 65, 5, 95, 300, CBS_AUTOHSCROLL | CBS_DROPDOWNLIST | WS_VSCROLL | WS_TABSTOP
    RTEXT "&Name der ID:", -1, 10, 27, 50, 14
    EDITTEXT edt1, 65, 25, 75, 14, ES_AUTOHSCROLL
    RTEXT "&Integer Wert:", -1, 10, 47, 50, 14
    EDITTEXT edt2, 65, 45, 48, 14, ES_AUTOHSCROLL
    CONTROL "", scr1, "msctls_updown32", UDS_NOTHOUSANDS | UDS_ARROWKEYS | UDS_AUTOBUDDY | UDS_ALIGNRIGHT | UDS_SETBUDDYINT, 129, 49, 12, 20
    PUSHBUTTON "&Auto", psh1, 115, 45, 45, 14
    DEFPUSHBUTTON "OK", IDOK, 20, 70, 60, 14
    PUSHBUTTON "Stornieren", IDCANCEL, 85, 70, 60, 14
}

IDD_MODIFYRESID DIALOG 0, 0, 165, 90
CAPTION "Ressourcen-ID ändern"
STYLE DS_MODALFRAME | WS_POPUPWINDOW | WS_CAPTION
FONT 9, "MS Shell Dlg"
{
    RTEXT "&Name der ID:", -1, 10, 12, 50, 14, SS_REALSIZEIMAGE | NOT WS_GROUP
    EDITTEXT edt1, 65, 10, 95, 14, ES_AUTOHSCROLL
    RTEXT "&Art der ID:", -1, 10, 32, 50, 14
    EDITTEXT edt2, 65, 30, 95, 14, ES_READONLY
    RTEXT "&Integer Wert:", -1, 10, 52, 50, 14
    EDITTEXT edt3, 65, 50, 48, 14, ES_AUTOHSCROLL
    CONTROL "", scr1, "msctls_updown32", UDS_NOTHOUSANDS | UDS_ARROWKEYS | UDS_AUTOBUDDY | UDS_ALIGNRIGHT | UDS_SETBUDDYINT, 129, 49, 12, 20
    DEFPUSHBUTTON "OK", IDOK, 20, 70, 60, 14
    PUSHBUTTON "Stornieren", IDCANCEL, 85, 70, 60, 14
}

IDD_ADVICERESH DIALOG 0, 0, 209, 184
CAPTION "Hinweis zur Änderung der Datei ""resource.h"""
STYLE DS_MODALFRAME | WS_POPUPWINDOW | WS_CAPTION
FONT 9, "MS Shell Dlg"
{
    LTEXT "Bitte ändern Sie die Datei ""resource.h"" wie folgt:", -1, 10, 10, 195, 20
    EDITTEXT edt1, 10, 30, 190, 130, ES_READONLY | ES_MULTILINE
    DEFPUSHBUTTON "OK", IDOK, 140, 165, 60, 14
    PUSHBUTTON "&Deutliche Änderung", psh1, 10, 165, 90, 14
}

IDD_CLONEINNEWNAME DIALOG 0, 0, 215, 75
CAPTION "In neuen Namen klonen"
STYLE DS_MODALFRAME | WS_POPUPWINDOW | WS_CAPTION
FONT 9, "MS Shell Dlg"
{
    LTEXT "Ressourcentyp:", -1, 5, 7, 70, 12
    COMBOBOX cmb1, 75, 5, 135, 200, CBS_HASSTRINGS | CBS_AUTOHSCROLL | CBS_DROPDOWN | WS_DISABLED | WS_BORDER | WS_VSCROLL | WS_TABSTOP
    LTEXT "Resource Name:", -1, 5, 32, 70, 12
    COMBOBOX cmb2, 75, 30, 120, 200, CBS_HASSTRINGS | CBS_AUTOHSCROLL | CBS_DROPDOWN | WS_BORDER | WS_VSCROLL | WS_TABSTOP
    PUSHBUTTON "&...", psh1, 195, 30, 15, 14
    DEFPUSHBUTTON "OK", IDOK, 35, 55, 60, 14
    PUSHBUTTON "Stornieren", IDCANCEL, 115, 55, 60, 14
}

IDD_CLONEINNEWLANG DIALOG 0, 0, 215, 105
CAPTION "In neuer Sprache klonen"
STYLE DS_MODALFRAME | WS_POPUPWINDOW | WS_CAPTION
FONT 9, "MS Shell Dlg"
{
    LTEXT "Ressourcentyp:", -1, 5, 7, 70, 12
    COMBOBOX cmb1, 75, 5, 135, 200, CBS_HASSTRINGS | CBS_AUTOHSCROLL | CBS_DROPDOWN | WS_DISABLED | WS_BORDER | WS_VSCROLL | WS_TABSTOP
    LTEXT "Ressourcenname:", -1, 5, 32, 70, 12
    COMBOBOX cmb2, 75, 30, 120, 200, CBS_HASSTRINGS | CBS_AUTOHSCROLL | CBS_DROPDOWN | WS_DISABLED | WS_BORDER | WS_VSCROLL | WS_TABSTOP
    LTEXT "Ressourcensprache:", -1, 5, 57, 70, 12
    COMBOBOX cmb3, 75, 55, 135, 200, CBS_HASSTRINGS | CBS_AUTOHSCROLL | CBS_DROPDOWN | WS_BORDER | WS_VSCROLL | WS_TABSTOP
    DEFPUSHBUTTON "OK", IDOK, 35, 85, 60, 14
    PUSHBUTTON "Stornieren", IDCANCEL, 115, 85, 60, 14
}

IDD_ITEMSEARCH DIALOG 0, 0, 171, 135
CAPTION "Suche"
STYLE WS_POPUPWINDOW | WS_CAPTION
FONT 9, "MS Shell Dlg"
{
    LTEXT "&Zu suchende Zeichenfolge:", -1, 4, 10, 100, 14
    EDITTEXT edt1, 5, 25, 160, 15, ES_AUTOHSCROLL
    AUTOCHECKBOX "&Groß- und Kleinschreibung beachten", chx1, 5, 45, 120, 18
    GROUPBOX "Richtung", -1, 5, 65, 160, 42
    AUTORADIOBUTTON "&Nach oben", rad1, 15, 80, 60, 14, WS_TABSTOP
    AUTORADIOBUTTON "&Nach unten", rad2, 90, 80, 60, 14, WS_TABSTOP
    DEFPUSHBUTTON "&Finden", IDOK, 40, 115, 60, 14
    PUSHBUTTON "Stornieren", IDCANCEL, 105, 115, 60, 14
}

IDD_VERSIONINFO DIALOG 0, 0, 174, 150
CAPTION "Über RisohEditor"
STYLE DS_MODALFRAME | WS_POPUPWINDOW | WS_CAPTION
FONT 12, "MS Shell Dlg"
{
    ICON IDI_MAIN, -1, 5, 5, 0, 0
    LTEXT "...", stc1, 30, 5, 140, 50
    CTEXT "https://katahiromz.web.fc2.com", stc2, 5, 60, 165, 12, SS_CENTERIMAGE | SS_NOTIFY | NOT WS_GROUP
    CONTROL "...", edt1, "EDIT", ES_READONLY | ES_AUTOHSCROLL | ES_AUTOVSCROLL | ES_MULTILINE | WS_BORDER | WS_VSCROLL | WS_HSCROLL, 5, 75, 165, 50
    DEFPUSHBUTTON "OK", IDOK, 55, 130, 60, 14
}

IDD_ADDMSG DIALOG 0, 0, 255, 105
CAPTION "Nachrichteneintrag hinzufügen"
STYLE DS_MODALFRAME | WS_POPUPWINDOW | WS_CAPTION
FONT 9, "MS Shell Dlg"
{
    LTEXT "Nachrichten ID:", -1, 5, 7, 50, 12
    COMBOBOX cmb1, 65, 5, 134, 200, CBS_HASSTRINGS | CBS_AUTOHSCROLL | CBS_DROPDOWN | WS_BORDER | WS_VSCROLL | WS_TABSTOP
    PUSHBUTTON "&...", psh1, 200, 5, 15, 14
    LTEXT "Nachrichtenwert:", -1, 5, 27, 80, 12
    EDITTEXT edt1, 5, 40, 245, 35, ES_WANTRETURN | ES_AUTOHSCROLL | ES_AUTOVSCROLL | ES_MULTILINE
    DEFPUSHBUTTON "OK", IDOK, 125, 85, 60, 14
    PUSHBUTTON "Stornieren", IDCANCEL, 190, 85, 60, 14
}

IDD_MODIFYMSG DIALOG 0, 0, 255, 105
CAPTION "Nachrichteneintrag ändern"
STYLE DS_MODALFRAME | WS_POPUPWINDOW | WS_CAPTION
FONT 9, "MS Shell Dlg"
{
    LTEXT "Nachrichten ID:", -1, 5, 7, 50, 12
    COMBOBOX cmb1, 65, 5, 134, 200, CBS_HASSTRINGS | CBS_AUTOHSCROLL | CBS_DROPDOWN | WS_DISABLED | WS_BORDER | WS_VSCROLL | WS_TABSTOP
    LTEXT "Nachrichtenwert:", -1, 5, 27, 80, 12
    EDITTEXT edt1, 5, 40, 245, 35, ES_WANTRETURN | ES_AUTOHSCROLL | ES_AUTOVSCROLL | ES_MULTILINE
    DEFPUSHBUTTON "OK", IDOK, 125, 85, 60, 14
    PUSHBUTTON "Stornieren", IDCANCEL, 190, 85, 60, 14
}

IDD_MESSAGES DIALOG 0, 0, 325, 160
CAPTION "Nachrichtentabelle"
STYLE WS_POPUPWINDOW | WS_CAPTION | WS_THICKFRAME
FONT 9, "MS Shell Dlg"
{
    LTEXT "Nachrichteneinträge:", -1, 5, 7, 80, 12
    CONTROL "", lst1, "SysListView32", LVS_NOSORTHEADER | LVS_AUTOARRANGE | LVS_NOLABELWRAP | LVS_SHOWSELALWAYS | LVS_SINGLESEL | LVS_REPORT | WS_BORDER | WS_VSCROLL | WS_HSCROLL | WS_TABSTOP, 5, 20, 315, 115
    PUSHBUTTON "&Hinzufügen...", psh1, 130, 3, 60, 14
    PUSHBUTTON "&Ändern...", psh2, 195, 3, 60, 14
    PUSHBUTTON "&Löschen", psh3, 260, 3, 60, 14
    DEFPUSHBUTTON "OK", IDOK, 195, 140, 60, 14
    PUSHBUTTON "Stornieren", IDCANCEL, 260, 140, 60, 14
    PUSHBUTTON "Alles löschen", psh4, 5, 140, 75, 14
}

IDD_FONTS DIALOG 0, 0, 195, 110
CAPTION "Schriftarteneinstellungen"
STYLE DS_MODALFRAME | WS_POPUPWINDOW | WS_CAPTION
FONT 9, "MS Shell Dlg"
{
    RTEXT "&Quelle:", -1, 5, 5, 55, 15, SS_CENTERIMAGE | NOT WS_GROUP
    EDITTEXT edt1, 65, 5, 100, 14, ES_READONLY | ES_AUTOHSCROLL
    PUSHBUTTON "...", psh1, 170, 5, 19, 14
    RTEXT "&Binär:", -1, 5, 25, 55, 15, SS_CENTERIMAGE | NOT WS_GROUP
    EDITTEXT edt2, 65, 25, 100, 14, ES_READONLY | ES_AUTOHSCROLL
    PUSHBUTTON "...", psh2, 170, 25, 19, 14
    GROUPBOX "Vorschau", -1, 5, 45, 185, 39
    CTEXT "Quelle", stc1, 15, 55, 80, 25, SS_CENTERIMAGE | NOT WS_GROUP
    CTEXT "Binär", stc2, 100, 55, 85, 25, SS_CENTERIMAGE | NOT WS_GROUP
    DEFPUSHBUTTON "OK", IDOK, 65, 90, 60, 14
    PUSHBUTTON "Stornieren", IDCANCEL, 130, 90, 60, 14
}

IDD_MACROS DIALOG 0, 0, 265, 165
CAPTION "Vordefinierte Makros"
STYLE WS_POPUPWINDOW | WS_CAPTION | WS_THICKFRAME
FONT 9, "MS Shell Dlg"
{
    LTEXT "Vordefinierte Makros:", -1, 5, 0, 100, 15, SS_CENTERIMAGE | NOT WS_GROUP
    CONTROL "", lst1, "SysListView32", LVS_EDITLABELS | LVS_SHOWSELALWAYS | LVS_SINGLESEL | LVS_REPORT | WS_BORDER | WS_TABSTOP, 5, 15, 190, 125
    PUSHBUTTON "&Hinzufügen...", psh1, 200, 15, 60, 14
    PUSHBUTTON "&Bearbeiten...", psh2, 200, 35, 60, 14
    PUSHBUTTON "&Löschen", psh3, 200, 55, 60, 14
    PUSHBUTTON "Alles löschen", psh7, 200, 105, 60, 14
    DEFPUSHBUTTON "OK", IDOK, 135, 145, 60, 14
    PUSHBUTTON "Stornieren", IDCANCEL, 200, 145, 60, 14
    PUSHBUTTON "&Alles zurücksetzen", psh6, 5, 145, 60, 14
}

IDD_ADDMACRO DIALOG 0, 0, 190, 80
CAPTION "Fügen Sie ein vordefiniertes Makro hinzu"
STYLE DS_MODALFRAME | WS_POPUPWINDOW | WS_CAPTION
FONT 9, "MS Shell Dlg"
{
    RTEXT "&Schlüssel:", -1, 5, 12, 60, 14
    COMBOBOX cmb1, 70, 10, 110, 200, CBS_DROPDOWN | WS_BORDER | WS_VSCROLL | WS_TABSTOP
    RTEXT "&Wert:", -1, 5, 37, 60, 14
    COMBOBOX cmb2, 70, 35, 110, 300, CBS_DROPDOWN | WS_BORDER | WS_VSCROLL | WS_TABSTOP
    DEFPUSHBUTTON "OK", IDOK, 60, 60, 60, 14
    PUSHBUTTON "Stornieren", IDCANCEL, 125, 60, 60, 14
}

IDD_EDITMACRO DIALOG 0, 0, 190, 80
CAPTION "Vordefiniertes Makro bearbeiten"
STYLE DS_MODALFRAME | WS_POPUPWINDOW | WS_CAPTION
FONT 9, "MS Shell Dlg"
{
    RTEXT "&Schlüssel:", -1, 5, 12, 60, 14
    COMBOBOX cmb1, 70, 10, 110, 200, CBS_DROPDOWN | WS_DISABLED | WS_BORDER | WS_VSCROLL | WS_TABSTOP
    RTEXT "&Wert:", -1, 5, 37, 60, 14
    COMBOBOX cmb2, 70, 35, 110, 300, CBS_DROPDOWN | WS_BORDER | WS_VSCROLL | WS_TABSTOP
    DEFPUSHBUTTON "OK", IDOK, 60, 60, 60, 14
    PUSHBUTTON "Stornieren", IDCANCEL, 125, 60, 60, 14
}

IDD_CTRLDATA DIALOG 0, 0, 190, 130
CAPTION "Kontrolldaten bearbeiten"
STYLE DS_MODALFRAME | WS_POPUPWINDOW | WS_CAPTION
FONT 9, "MS Shell Dlg"
{
    LTEXT "&Binärdaten:", -1, 5, 2, 87, 12
    EDITTEXT edt1, 5, 15, 180, 60, ES_AUTOVSCROLL | ES_MULTILINE | WS_VSCROLL
    LTEXT "Sie können die Steuerdaten durch durch Leerzeichen getrennte 16-Bit-Ganzzahlen festlegen.", -1, 5, 80, 180, 25
    DEFPUSHBUTTON "OK", IDOK, 60, 110, 60, 14
    PUSHBUTTON "Stornieren", IDCANCEL, 125, 110, 60, 14
}

IDD_PATHS DIALOG 0, 0, 295, 220
CAPTION "Pfade festlegen"
STYLE WS_POPUPWINDOW | WS_CAPTION | WS_THICKFRAME
FONT 9, "MS Shell Dlg"
{
    LTEXT "&Verzeichnisse einschließen:", -1, 5, 5, 102, 12
    LISTBOX lst1, 5, 20, 220, 105, LBS_NOINTEGRALHEIGHT | LBS_HASSTRINGS | LBS_SORT | WS_VSCROLL | WS_HSCROLL | WS_TABSTOP
    PUSHBUTTON "&Hinzufügen...", psh1, 230, 20, 60, 14
    PUSHBUTTON "&Bearbeiten...", psh2, 230, 40, 60, 14
    PUSHBUTTON "&Löschen", psh3, 230, 60, 60, 14
    PUSHBUTTON "&Oben", psh4, 230, 80, 60, 14
    PUSHBUTTON "&Nieder", psh5, 230, 100, 60, 14
    PUSHBUTTON "&Alles löschen", psh6, 5, 130, 95, 14
    RTEXT "&windres.exe:", stc1, 5, 157, 55, 12
    COMBOBOX cmb1, 70, 155, 155, 300, CBS_HASSTRINGS | CBS_AUTOHSCROLL | CBS_DROPDOWN | WS_VSCROLL | WS_TABSTOP
    PUSHBUTTON "&Durchsuche...", psh7, 230, 155, 60, 14
    RTEXT "&cpp.exe:", stc2, 5, 177, 55, 12
    COMBOBOX cmb2, 70, 175, 155, 300, CBS_HASSTRINGS | CBS_AUTOHSCROLL | CBS_DROPDOWN | WS_VSCROLL | WS_TABSTOP
    PUSHBUTTON "&Durchsuche...", psh8, 230, 175, 60, 14
    DEFPUSHBUTTON "OK", IDOK, 165, 200, 60, 14
    PUSHBUTTON "Stornieren", IDCANCEL, 230, 200, 60, 14
    PUSHBUTTON "Alles &zurücksetzen", psh9, 5, 200, 95, 14
}

IDD_EXP_OPTIONS DIALOG 0, 0, 250, 225
CAPTION "Exportoptionen"
STYLE DS_MODALFRAME | WS_POPUPWINDOW | WS_CAPTION
FONT 9, "MS Shell Dlg"
{
    ICON IDI_MAIN, -1, 5, 10, 0, 0
    LTEXT "Beim Exportieren einer RC-Datei werden einige verwandte Dateien generiert. Sie können folgende Optionen auswählen:", -1, 35, 5, 210, 29
    AUTOCHECKBOX "Use Microsoft MESSAGE&TABLE", chx8, 5, 40, 240, 14
    AUTOCHECKBOX "Trennen Sie die Ressourcendateien nach Sprache", chx1, 5, 60, 240, 14
    AUTOCHECKBOX "Verwenden Sie die Schlüsselwörter BEGIN / END", chx2, 5, 80, 240, 14
    AUTOCHECKBOX "Machen Sie die Sprache mit dem Makro LANGUAGE_* wählbar", chx3, 5, 97, 240, 18, BS_MULTILINE | NOT WS_TABSTOP
    AUTOCHECKBOX "Ein Backup erstellen", chx4, 5, 120, 110, 14
    RTEXT "Backup-Suffix:", -1, 120, 122, 75, 12
    COMBOBOX cmb1, 200, 120, 45, 300, CBS_HASSTRINGS | CBS_AUTOHSCROLL | CBS_DROPDOWN | WS_VSCROLL | WS_TABSTOP
    AUTOCHECKBOX "Redundante Kommentare ausgeben", chx5, 5, 140, 240, 14
    AUTOCHECKBOX "Schließen Sie die Manifest-Anweisungen mit #ifndef MSVC ... #endif ein", chx6, 5, 157, 240, 18, BS_MULTILINE | NOT WS_TABSTOP
    AUTOCHECKBOX "RC-Dateien als UTF-16 ausgeben", chx7, 5, 180, 240, 14
    DEFPUSHBUTTON "OK", IDOK, 120, 205, 60, 14
    PUSHBUTTON "Stornieren", IDCANCEL, 185, 205, 60, 14
}

IDD_LANGS DIALOG 0, 0, 250, 235
CAPTION "Sprachen"
STYLE WS_POPUPWINDOW | WS_CAPTION | WS_THICKFRAME
FONT 9, "MS Shell Dlg"
{
    CONTROL "", lst1, "SysListView32", LVS_SHOWSELALWAYS | LVS_SINGLESEL | LVS_REPORT | WS_BORDER | WS_TABSTOP, 5, 5, 240, 179
    RTEXT "&Suche:", stc1, 5, 192, 45, 12
    COMBOBOX cmb1, 55, 190, 85, 300, CBS_SORT | CBS_DROPDOWN | WS_VSCROLL | WS_TABSTOP
    EDITTEXT edt1, 4, 209, 240, 20, ES_AUTOHSCROLL | ES_AUTOVSCROLL | ES_MULTILINE
}

IDD_CHILD DIALOG 0, 0, 215, 135
CAPTION "Untergeordneter Dialog"
STYLE WS_CHILD | WS_OVERLAPPEDWINDOW
FONT 9, "MS Shell Dlg"
{
    DEFPUSHBUTTON "OK", IDOK, 35, 115, 60, 14
    PUSHBUTTON "Stornieren", IDCANCEL, 115, 115, 60, 14
}

IDD_DLGINITEDIT DIALOG 0, 0, 325, 165
CAPTION "Bearbeiten Sie DLGINIT"
STYLE WS_POPUPWINDOW | WS_CAPTION | WS_THICKFRAME
FONT 9, "MS Shell Dlg"
{
    LTEXT "Nachrichteneinträge:", -1, 5, 7, 100, 12
    CONTROL "", lst1, "SysListView32", LVS_NOSORTHEADER | LVS_AUTOARRANGE | LVS_NOLABELWRAP | LVS_SHOWSELALWAYS | LVS_SINGLESEL | LVS_REPORT | WS_BORDER | WS_VSCROLL | WS_HSCROLL | WS_TABSTOP, 5, 20, 250, 120
    PUSHBUTTON "&Hinzufügen...", psh1, 260, 20, 60, 14
    PUSHBUTTON "&Ändern...", psh2, 260, 40, 60, 14
    PUSHBUTTON "&Löschen", psh3, 260, 60, 60, 14
    PUSHBUTTON "&Oben", psh4, 260, 100, 60, 14
    PUSHBUTTON "&Nieder", psh5, 260, 120, 60, 14
    DEFPUSHBUTTON "OK", IDOK, 195, 145, 60, 14
    PUSHBUTTON "Stornieren", IDCANCEL, 260, 145, 60, 14
    PUSHBUTTON "&Alles löschen", psh6, 5, 145, 79, 14
}

IDD_ADDDLGINIT DIALOG 0, 0, 184, 137
CAPTION "Fügen Sie DLGINIT-Daten hinzu"
STYLE DS_MODALFRAME | WS_POPUPWINDOW | WS_CAPTION
FONT 9, "MS Shell Dlg"
{
    LTEXT "Kontroll-ID:", -1, 5, 7, 56, 12
    COMBOBOX cmb1, 65, 5, 115, 300, CBS_HASSTRINGS | CBS_AUTOHSCROLL | CBS_DROPDOWN | WS_VSCROLL | WS_TABSTOP
    LTEXT "&Botschaft:", -1, 5, 32, 55, 12
    COMBOBOX cmb2, 65, 30, 95, 300, CBS_HASSTRINGS | CBS_AUTOHSCROLL | CBS_DROPDOWN | WS_VSCROLL | WS_TABSTOP
    LTEXT "&String:", -1, 5, 52, 55, 12
    EDITTEXT edt1, 5, 65, 175, 50, ES_WANTRETURN | ES_MULTILINE | WS_VSCROLL | WS_HSCROLL
    DEFPUSHBUTTON "OK", IDOK, 55, 120, 60, 14
    PUSHBUTTON "Stornieren", IDCANCEL, 120, 120, 60, 14
}

IDD_MODIFYDLGINIT DIALOG 0, 0, 184, 137
CAPTION "Ändern Sie die DLGINIT-Daten"
STYLE DS_MODALFRAME | WS_POPUPWINDOW | WS_CAPTION
FONT 9, "MS Shell Dlg"
{
    LTEXT "Kontroll-ID:", -1, 5, 7, 56, 12
    COMBOBOX cmb1, 65, 5, 115, 300, CBS_HASSTRINGS | CBS_AUTOHSCROLL | CBS_DROPDOWN | WS_VSCROLL | WS_TABSTOP
    LTEXT "&Botschaft:", -1, 5, 32, 55, 12
    COMBOBOX cmb2, 65, 30, 95, 300, CBS_HASSTRINGS | CBS_AUTOHSCROLL | CBS_DROPDOWN | WS_VSCROLL | WS_TABSTOP
    LTEXT "&String:", -1, 5, 52, 55, 12
    EDITTEXT edt1, 5, 65, 175, 50, ES_WANTRETURN | ES_MULTILINE | WS_VSCROLL | WS_HSCROLL
    DEFPUSHBUTTON "OK", IDOK, 55, 120, 60, 14
    PUSHBUTTON "Stornieren", IDCANCEL, 120, 120, 60, 14
}

IDD_STRINGLIST DIALOG 0, 0, 205, 220
CAPTION "Steuerzeichenfolgenliste"
STYLE WS_POPUPWINDOW | WS_CAPTION | WS_THICKFRAME
FONT 9, "MS Shell Dlg"
{
    LTEXT "", stc1, 5, 5, 195, 70
    EDITTEXT edt1, 5, 80, 195, 115, ES_WANTRETURN | ES_MULTILINE | WS_VSCROLL | WS_HSCROLL
    DEFPUSHBUTTON "OK", IDOK, 75, 200, 60, 14
    PUSHBUTTON "Stornieren", IDCANCEL, 140, 200, 60, 14
}

IDD_SAVE_OPTIONS DIALOG 0, 0, 250, 225
CAPTION "Optionen speichern"
STYLE DS_MODALFRAME | WS_POPUPWINDOW | WS_CAPTION
FONT 9, "MS Shell Dlg"
{
    ICON IDI_MAIN, -1, 5, 10, 0, 0
    LTEXT "Beim Exportieren einer RC-Datei werden einige verwandte Dateien generiert. Sie können folgende Optionen auswählen:", -1, 35, 5, 210, 29
    AUTOCHECKBOX "Use Microsoft MESSAGE&TABLE", chx8, 5, 40, 240, 14
    AUTOCHECKBOX "Trennen Sie die Ressourcendateien nach Sprache", chx1, 5, 60, 240, 14
    AUTOCHECKBOX "Verwenden Sie die Schlüsselwörter BEGIN / END", chx2, 5, 80, 240, 14
    AUTOCHECKBOX "Machen Sie die Sprache mit dem Makro LANGUAGE_* wählbar", chx3, 5, 97, 240, 18, BS_MULTILINE | NOT WS_TABSTOP
    AUTOCHECKBOX "Ein Backup erstellen", chx4, 5, 120, 110, 14
    RTEXT "Backup-Suffix:", -1, 120, 122, 75, 12
    COMBOBOX cmb1, 200, 120, 45, 300, CBS_HASSTRINGS | CBS_AUTOHSCROLL | CBS_DROPDOWN | WS_VSCROLL | WS_TABSTOP
    AUTOCHECKBOX "Redundante Kommentare ausgeben", chx5, 5, 140, 240, 14
    AUTOCHECKBOX "Schließen Sie die Manifest-Anweisungen mit #ifndef MSVC ... #endif ein", chx6, 5, 157, 240, 18, BS_MULTILINE | NOT WS_TABSTOP
    AUTOCHECKBOX "RC-Dateien als UTF-16 ausgeben", chx7, 5, 180, 240, 14
    DEFPUSHBUTTON "OK", IDOK, 120, 205, 60, 14
    PUSHBUTTON "Stornieren", IDCANCEL, 185, 205, 60, 14
}

IDD_ENCODING DIALOG 0, 0, 200, 170
CAPTION "Codierung des Ressourcenelements"
STYLE DS_MODALFRAME | WS_POPUPWINDOW | WS_CAPTION
FONT 9, "MS Shell Dlg"
{
    CONTROL "", lst1, "SysListView32", LVS_SHOWSELALWAYS | LVS_SINGLESEL | LVS_REPORT | WS_BORDER, 5, 5, 190, 115
    PUSHBUTTON "&Hinzufügen...", psh1, 5, 125, 60, 14
    PUSHBUTTON "&Ändern...", psh2, 70, 125, 60, 14
    PUSHBUTTON "&Löschen", psh3, 135, 125, 60, 14
    DEFPUSHBUTTON "OK", IDOK, 70, 150, 60, 14
    PUSHBUTTON "Stornieren", IDCANCEL, 135, 150, 60, 14
    PUSHBUTTON "&Zurücksetzen", psh5, 5, 149, 60, 14
}

IDD_ADDENC DIALOG 0, 0, 215, 80
CAPTION "Ressourcencodierung hinzufügen"
STYLE DS_MODALFRAME | WS_POPUPWINDOW | WS_CAPTION
FONT 9, "MS Shell Dlg"
{
    LTEXT "Ressourcentyp:", -1, 5, 7, 70, 12
    COMBOBOX cmb1, 75, 5, 135, 200, CBS_HASSTRINGS | CBS_AUTOHSCROLL | CBS_DROPDOWN | WS_BORDER | WS_VSCROLL | WS_TABSTOP
    LTEXT "&Codierung:", -1, 5, 30, 70, 12
    COMBOBOX cmb2, 75, 30, 85, 300, CBS_HASSTRINGS | CBS_AUTOHSCROLL | CBS_DROPDOWNLIST | WS_VSCROLL | WS_TABSTOP
    DEFPUSHBUTTON "OK", IDOK, 86, 60, 60, 14
    PUSHBUTTON "Stornieren", IDCANCEL, 150, 60, 60, 14
}

IDD_MODIFYENC DIALOG 0, 0, 215, 80
CAPTION "Ändern Sie die Ressourcencodierung"
STYLE DS_MODALFRAME | WS_POPUPWINDOW | WS_CAPTION
FONT 9, "MS Shell Dlg"
{
    LTEXT "Ressourcentyp:", -1, 5, 7, 70, 12
    COMBOBOX cmb1, 75, 5, 135, 200, CBS_HASSTRINGS | CBS_AUTOHSCROLL | CBS_DROPDOWN | WS_DISABLED | WS_BORDER | WS_VSCROLL | WS_TABSTOP
    LTEXT "&Codierung:", -1, 5, 30, 70, 12
    COMBOBOX cmb2, 75, 30, 85, 300, CBS_HASSTRINGS | CBS_AUTOHSCROLL | CBS_DROPDOWNLIST | WS_VSCROLL | WS_TABSTOP
    DEFPUSHBUTTON "OK", IDOK, 86, 60, 60, 14
    PUSHBUTTON "Stornieren", IDCANCEL, 150, 60, 60, 14
}

IDD_CONSTANT DIALOG 0, 0, 205, 75
CAPTION "Abfragekonstante"
STYLE DS_MODALFRAME | WS_POPUPWINDOW | WS_CAPTION
FONT 9, "MS Shell Dlg"
{
    LTEXT "Konstanter Name:", -1, 5, 7, 80, 12
    COMBOBOX cmb1, 94, 7, 105, 300, CBS_HASSTRINGS | CBS_AUTOHSCROLL | CBS_DROPDOWN | WS_VSCROLL | WS_TABSTOP
    LTEXT "Konstanter Wert:", -1, 5, 32, 80, 12
    EDITTEXT edt2, 95, 30, 50, 14, ES_READONLY
    EDITTEXT edt3, 150, 30, 50, 14, ES_READONLY
    DEFPUSHBUTTON "OK", IDOK, 70, 55, 60, 14
}

IDD_EGA DIALOG 0, 0, 400, 225
CAPTION "Die Programmiersprache EGA"
STYLE WS_POPUPWINDOW | WS_CAPTION | WS_THICKFRAME
FONT 9, "MS Shell Dlg"
{
    GROUPBOX "EGA-Konsole", grp1, 5, 5, 390, 195
    EDITTEXT edt1, 10, 20, 380, 170, ES_READONLY | ES_AUTOVSCROLL | ES_MULTILINE | WS_VSCROLL | NOT WS_TABSTOP
    RTEXT "EGA>", stc1, 10, 208, 20, 10
    EDITTEXT edt2, 35, 205, 300, 15, ES_WANTRETURN | ES_AUTOHSCROLL | ES_AUTOVSCROLL | ES_MULTILINE
    PUSHBUTTON "&Eingeben", IDOK, 345, 205, 50, 15
}

IDD_FONTSUBST DIALOG 0, 0, 185, 180
CAPTION "Dialog Font Substitutes"
STYLE DS_CENTER | DS_MODALFRAME | WS_POPUPWINDOW | WS_CAPTION
FONT 9, "MS Shell Dlg"
{
    LTEXT "Schriftart #&1:", -1, 5, 7, 44, 12
    COMBOBOX cmb1, 55, 5, 125, 300, CBS_HASSTRINGS | CBS_AUTOHSCROLL | CBS_DROPDOWN | WS_VSCROLL | WS_TABSTOP
    ICON IDI_ARROW, -1, 30, 25, 0, 0
    COMBOBOX cmb2, 55, 30, 125, 300, CBS_HASSTRINGS | CBS_AUTOHSCROLL | CBS_DROPDOWN | WS_VSCROLL | WS_TABSTOP
    LTEXT "Schriftart #&2:", -1, 5, 57, 44, 12
    COMBOBOX cmb3, 55, 55, 125, 300, CBS_HASSTRINGS | CBS_AUTOHSCROLL | CBS_DROPDOWN | WS_VSCROLL | WS_TABSTOP
    ICON IDI_ARROW, -1, 30, 75, 0, 0
    COMBOBOX cmb4, 55, 80, 125, 300, CBS_HASSTRINGS | CBS_AUTOHSCROLL | CBS_DROPDOWN | WS_VSCROLL | WS_TABSTOP
    LTEXT "Schriftart #&3:", -1, 5, 105, 44, 12
    COMBOBOX cmb5, 55, 105, 125, 300, CBS_HASSTRINGS | CBS_AUTOHSCROLL | CBS_DROPDOWN | WS_VSCROLL | WS_TABSTOP
    ICON IDI_ARROW, -1, 30, 125, 0, 0
    COMBOBOX cmb6, 55, 130, 125, 300, CBS_HASSTRINGS | CBS_AUTOHSCROLL | CBS_DROPDOWN | WS_VSCROLL | WS_TABSTOP
    DEFPUSHBUTTON "OK", IDOK, 75, 160, 50, 14
    PUSHBUTTON "Stornieren", IDCANCEL, 130, 160, 50, 14
    PUSHBUTTON "&Zurücksetzen", psh1, 5, 160, 55, 14
}

IDD_DROPDOWNPOPUP DIALOG 0, 0, 120, 150
CAPTION " "
STYLE WS_POPUP | WS_DLGFRAME | NOT WS_BORDER
FONT 9, "MS Shell Dlg"
{
    LISTBOX lst1, 0, 0, 120, 150, LBS_WANTKEYBOARDINPUT | LBS_NOINTEGRALHEIGHT | LBS_HASSTRINGS | WS_VSCROLL | WS_TABSTOP, WS_EX_CLIENTEDGE
}

IDD_DFMSETTINGS DIALOG 0, 0, 210, 135
CAPTION "Delphi DFM-Einstellungen"
STYLE DS_CENTER | DS_MODALFRAME | WS_POPUPWINDOW | WS_CAPTION
FONT 9, "MS Shell Dlg"
{
    LTEXT "Die folgenden Einstellungen sind für Delphi DFM relevant:", -1, 35, 5, 171, 20
    ICON IDI_DFMICON, -1, 5, 5, 0, 0
    RTEXT "&Codepage:", -1, 6, 32, 70, 12
    COMBOBOX cmb1, 85, 30, 120, 300, CBS_HASSTRINGS | CBS_AUTOHSCROLL | CBS_DROPDOWN | WS_VSCROLL | WS_TABSTOP
    AUTOCHECKBOX "&Fügen Sie Kommentare zu rohen Zeichenfolgen ein", chx1, 5, 50, 200, 14
    AUTOCHECKBOX "Verwenden Sie nicht &Unicode und UTF-8", chx2, 5, 70, 200, 14
    DEFPUSHBUTTON "OK", IDOK, 80, 115, 60, 14
    PUSHBUTTON "Stornieren", IDCANCEL, 145, 115, 60, 14
}

IDD_COPYTOMULTILANG DIALOG 0, 0, 200, 195
CAPTION "In mehrere Sprachen kopieren"
STYLE DS_CENTER | DS_MODALFRAME | WS_POPUPWINDOW | WS_CAPTION
FONT 9, "MS Shell Dlg"
{
    LTEXT "Bitte fügen Sie die Sprachen hinzu, in die Sie die Ressource kopieren möchten:", -1, 5, 5, 190, 22
    LTEXT "&Sprachen:", -1, 5, 35, 82, 12
    LISTBOX lst1, 5, 50, 190, 100, LBS_WANTKEYBOARDINPUT | LBS_NOINTEGRALHEIGHT | LBS_HASSTRINGS | WS_VSCROLL | WS_TABSTOP
    COMBOBOX cmb3, 5, 155, 126, 14, CBS_HASSTRINGS | CBS_AUTOHSCROLL | CBS_DROPDOWN | WS_BORDER | WS_VSCROLL | WS_TABSTOP
    PUSHBUTTON "&Hinzufügen", psh1, 135, 155, 60, 14
    DEFPUSHBUTTON "OK", IDOK, 5, 175, 60, 14
    PUSHBUTTON "Stornieren", IDCANCEL, 70, 175, 60, 14
}

IDD_TOOLBARRES DIALOG 0, 0, 230, 195
CAPTION "Symbolleiste Ressource"
STYLE DS_CENTER | DS_MODALFRAME | WS_POPUPWINDOW | WS_CAPTION
FONT 9, "MS Shell Dlg"
{
    RTEXT "Symbol&breite:", -1, 5, 5, 60, 15, SS_CENTERIMAGE | NOT WS_GROUP
    EDITTEXT edt1, 70, 5, 30, 15, ES_NUMBER | ES_RIGHT
    CONTROL "", scr1, "msctls_updown32", UDS_NOTHOUSANDS | UDS_ARROWKEYS | UDS_AUTOBUDDY | UDS_ALIGNRIGHT | UDS_SETBUDDYINT, 80, 5, 30, 15
    RTEXT "Symbol&höhe:", -1, 110, 5, 60, 15, SS_CENTERIMAGE | NOT WS_GROUP
    EDITTEXT edt2, 180, 5, 30, 15, ES_NUMBER | ES_RIGHT
    CONTROL "", scr2, "msctls_updown32", UDS_NOTHOUSANDS | UDS_ARROWKEYS | UDS_AUTOBUDDY | UDS_ALIGNRIGHT | UDS_SETBUDDYINT, 190, 5, 30, 15
    LTEXT "&Symbolleiste tasten:", -1, 5, 25, 140, 15, SS_CENTERIMAGE | NOT WS_GROUP
    LISTBOX lst1, 5, 40, 140, 130, LBS_DISABLENOSCROLL | LBS_WANTKEYBOARDINPUT | LBS_NOINTEGRALHEIGHT | LBS_HASSTRINGS | LBS_OWNERDRAWFIXED | WS_VSCROLL | WS_TABSTOP
    PUSHBUTTON "&Hinzufügen...", psh1, 150, 40, 75, 15
    PUSHBUTTON "&Ändern...", psh2, 150, 60, 75, 15
    PUSHBUTTON "&Löschen", psh3, 150, 80, 75, 15
    PUSHBUTTON "&Oben", psh4, 150, 135, 75, 15
    PUSHBUTTON "&Nieder", psh5, 150, 155, 75, 15
    DEFPUSHBUTTON "OK", IDOK, 5, 175, 60, 15
    PUSHBUTTON "Stornieren", IDCANCEL, 70, 175, 60, 15
}

IDD_ADDTBBTN DIALOG 0, 0, 177, 92
CAPTION "Symbolleistenschaltfläche hinzufügen"
STYLE DS_CENTER | DS_MODALFRAME | WS_POPUPWINDOW | WS_CAPTION
FONT 9, "MS Shell Dlg"
{
    LTEXT "&Befehls-ID der Symbolleistenschaltfläche:", -1, 5, 5, 160, 15, SS_CENTERIMAGE | NOT WS_GROUP
    COMBOBOX cmb1, 5, 25, 150, 150, CBS_HASSTRINGS | CBS_AUTOHSCROLL | CBS_DROPDOWN | WS_VSCROLL | WS_TABSTOP
    AUTOCHECKBOX "&Separator", chx1, 5, 45, 90, 15
    DEFPUSHBUTTON "OK", IDOK, 45, 70, 60, 15
    PUSHBUTTON "Stornieren", IDCANCEL, 110, 70, 60, 15
}

IDD_MODIFYTBBTN DIALOG 0, 0, 177, 92
CAPTION "Symbolleistenschaltfläche ändern"
STYLE DS_CENTER | DS_MODALFRAME | WS_POPUPWINDOW | WS_CAPTION
FONT 9, "MS Shell Dlg"
{
    LTEXT "&Befehls-ID der Symbolleistenschaltfläche:", -1, 5, 5, 160, 15, SS_CENTERIMAGE | NOT WS_GROUP
    COMBOBOX cmb1, 5, 25, 150, 150, CBS_HASSTRINGS | CBS_AUTOHSCROLL | CBS_DROPDOWN | WS_VSCROLL | WS_TABSTOP
    AUTOCHECKBOX "&Separator", chx1, 5, 45, 90, 15
    DEFPUSHBUTTON "OK", IDOK, 45, 70, 60, 15
    PUSHBUTTON "Stornieren", IDCANCEL, 110, 70, 60, 15
}

//////////////////////////////////////////////////////////////////////////////
// RT_VERSION

1 VERSIONINFO
FILEVERSION     5, 7, 9, 0
PRODUCTVERSION  5, 7, 9, 0
FILEOS          0x40004
FILETYPE        0x1
FILESUBTYPE     0x0
{
    BLOCK "StringFileInfo"
    {
        BLOCK "040704E4"
        {
            VALUE "CompanyName", "Katayama Hirofumi MZ\0"
            VALUE "FileDescription", "RisohEditor\0"
            VALUE "FileVersion", "5.7.9\0"
            VALUE "LegalCopyright", "Copyright (C) 2017-2020 Katayama Hirofumi MZ. All rights reserved.\0"
            VALUE "ProductName", "RisohEditor\0"
            VALUE "ProductVersion", "5.7.9\0"
        }
    }
    BLOCK "VarFileInfo"
    {
        VALUE "Translation", 0x0407, 0x04E4
    }
}

//////////////////////////////////////////////////////////////////////////////
// RISOHTEMPLATE

4 RISOHTEMPLATE "res/1031_RISOHTEMPLATE_4.bin"

5 RISOHTEMPLATE "res/1031_RISOHTEMPLATE_5.bin"

//////////////////////////////////////////////////////////////////////////////
// RT_STRING

STRINGTABLE
{
    IDS_APPNAME, "RisohEditor 5.7.9 von Katayama Hirofumi MZ"
    IDS_TITLEWITHFILE, "RisohEditor 5.7.9 - Datei: %s"
    IDS_EXTRACTRES, "Ressource extrahieren"
    IDS_RESBINFILTER, "Binäre Ressourcen (*.res)|*.res|Binärdateien (*.bin)|*.bin|Alle Dateien (*.*)|*.*|"
    IDS_CANNOTSAVE, "Speichern nicht möglich."
    IDS_REPLACERES, "Ressource ersetzen"
    IDS_ALLFILES, "Alle Dateien (*.*)|*.*|"
    IDS_ENTERTYPE, "Bitte geben Sie einen Ressourcentyp ein."
    IDS_ENTERNAME, "Bitte geben Sie einen Ressourcennamen ein."
    IDS_ENTERLANG, "Bitte geben Sie eine Ressourcensprache ein."
    IDS_FILENOTFOUND, "Datei konnte nicht gefunden werden."
    IDS_CANNOTREPLACE, "Nicht ersetzbar."
    IDS_EXERESFILTER, "Ausführbare Dateien (*.exe;*.dll;*.ocx;*.cpl;*.scr;*.mui)|*.exe;*.dll;*.ocx;*.cpl;*.scr;*.mui|RC-Dateien (*.rc)|*.rc|Binäre Ressourcen (*.res)|*.res|Alle Dateien (*.*)|*.*|"
    IDS_SAVEAS, "Speichern als"
    IDS_CANNOTADDICON, "Das Symbol kann nicht hinzugefügt werden."
    IDS_ADDICON, "Symbol hinzufügen"
    IDS_ICOFILTER, "Symboldateien (*.ico)|*.ico|Alle Dateien (*.*)|*.*|"
    IDS_REPLACEICO, "Symbol ersetzen"
    IDS_CANTREPLACEICO, "Symbol kann nicht ersetzt werden."
    IDS_EXISTSOVERWRITE, "Der Artikel ist bereits vorhanden. Überschreiben?"
    IDS_OPEN, "Öffnen"
    IDS_CANNOTOPEN, "Datei kann nicht geöffnet werden."
    IDS_ADDBMP, "Bitmap hinzufügen"
    IDS_BMPFILTER, "Bitmap-Dateien (*.bmp)|*.bmp|PNG-Bilder (*.png)|*.png|Alle Dateien (*.*)|*.*|"
    IDS_CANTREPLACEBMP, "Bitmap kann nicht ersetzt werden."
    IDS_REPLACEBMP, "Bitmap ersetzen"
    IDS_ERRORCODE, "Fehlercode %d"
    IDS_VERSIONINFO, "RisohEditor Version 5.7.9\r\n\r\nKatayama Hirofumi MZ\r\n\r\nLizenz: GPLv3 (free software)"
    IDS_ADDRES, "Ressource hinzufügen"
    IDS_CANNOTADDRES, "Die Ressource kann nicht hinzugefügt werden."
    IDS_CANTADDBMP, "Die Bitmap kann nicht hinzugefügt werden."
    IDS_EXTRACTBMP, "Bitmap extrahieren"
    IDS_CANTEXTRACTBMP, "Die Bitmap kann nicht extrahiert werden."
    IDS_CANTREPLACECUR, "Der Cursor kann nicht ersetzt werden."
    IDS_CANNOTADDCUR, "Der Cursor kann nicht hinzugefügt werden."
    IDS_CURFILTER, "Cursor-Dateien (*.cur)|*.cur|Animationscursor (*.ani)|*.ani|Alle Dateien (*.*)|*.*|"
    IDS_ADDCUR, "Cursor hinzufügen"
    IDS_REPLACECUR, "Cursor ersetzen"
    IDS_EXTRACTICO, "Symbol extrahieren"
    IDS_CANTEXTRACTICO, "Das Symbol kann nicht extrahiert werden."
    IDS_EXTRACTCUR, "Cursor extrahieren"
    IDS_CANTEXTRACTCUR, "Der Cursor kann nicht extrahiert werden."
    IDS_RESFILTER, "Binäre Ressourcen (*.res)|*.res|Alle Dateien (*.*)|*.*|"
    IDS_NEUTRAL, "Neutral"
    IDS_IMPORTRES, "Importieren"
    IDS_CANNOTIMPORT, "Die Ressource kann nicht importiert werden."
    IDS_COMPILE, "Kompilieren (F8)"
    IDS_CANCELEDIT, "Abbrechen Bearbeiten (Ctrl+E)"
    IDS_GUIEDIT, "Bearbeiten per GUI (Ctrl+G)"
    IDS_CANNOTSTARTUP, "Der Ressourcen-Compiler kann nicht gestartet werden."
    IDS_RESMISMATCH, "Der Ressourcentyp stimmte nicht überein."
    IDS_SAMPLETEXT, "Dies ist ein Beispiel."
    IDS_ALREADYEXISTS, "Ist bereits vorhanden."
    IDS_KEY, "Schlüssel"
    IDS_FLAGS, "Flaggen"
    IDS_COMMANDID, "Befehls-ID"
    IDS_INVALIDKEY, "Ungültiger Schlüssel."
    IDS_COMPILEERROR, "Kompilierung fehlgeschlagen."
    IDS_STRINGID, "String ID"
    IDS_STRINGVALUE, "String-Wert"
    IDS_CAPTION, "Bildbeschriftung"
    IDS_HELPID, "Hilfe-ID"
    IDS_INDENT, "» "
    IDS_DATAISEMPTY, "Daten sind leer."
    IDS_TEST, "Test machen"
    IDS_SEPARATOR, "---"
    IDS_COMPILENOW, "Daten wurden geändert. Jetzt kompilieren?"
    IDS_RADWINDOW, "Dialogfeld Bearbeiten"
    IDS_ENTERCLASS, "Bitte geben Sie einen gültigen Namen für die Fensterklasse ein."
    IDS_TEXTEDIT, "Nach Text bearbeiten (Ctrl+T)"
    IDS_CURSORINFO, "Bild #%u: Breite %u, Höhe %u, Bitanzahl %u, xHotSpot %u, yHotSpot %u, ID %u\r\n"
    IDS_IMAGECOUNT, "ImageCount: %u\r\n"
    IDS_ICONINFO, "Bild #%u: Breite %u, Höhe %u, Bitanzahl %u, ID %u\r\n"
    IDS_READY, "Bereit"
    IDS_EXECUTINGCMD, "Befehl ausführen..."
    IDS_EDITINGBYGUI, "Bearbeitung per GUI..."
    IDS_COORD, "%d, %d, %d, %d"
    IDS_STARTING, "Beginnend..."
    IDS_COMPILING, "Kompilieren..."
    IDS_CANNOTLOAD, "Unfähig zu laden."
    IDS_NONE, "(Keiner)"
    IDS_WAVESOUND, "(WAVE Sound)\r\n"
    IDS_IDTYPE, "ID-Typ"
    IDS_IDPREFIX, "ID-Präfix"
    IDS_EMPTYSTR, "Bitte geben Sie eine Zeichenfolge ein."
    IDS_ANICURSOR, "(Animationscursor)\r\n"
    IDS_ANIICON, "(Animationssymbol)\r\n"
    IDS_HEADFILTER, "Header-Dateien (*.h)|*.h|Alle Dateien (*.*)|*.*|"
    IDS_LOADRESH, "Laden Sie die Datei ""resource.h"""
    IDS_NAME, "Name"
    IDS_VALUE, "Wert"
    IDS_NOSUCHID, "Keine solche ID gefunden."
    IDS_IMAGEINFO, "Breite %u, Höhe %u, BitsPixel %u\r\n"
    IDS_ENTERINT, "Bitte geben Sie eine gültige Ganzzahl ein."
    IDS_ENTERTEXT, "Bitte geben Sie einen gültigen Text ein."
    IDS_ENTERID, "Bitte geben Sie einen gültigen Ausweis ein."
    IDS_ADDNEXTIDS, "Bitte fügen Sie die folgenden IDs zu ""resource.h"" hinzu:\r\n\r\n"
    IDS_DELETENEXTIDS, "Bitte löschen Sie die folgenden IDs aus ""resource.h"":\r\n\r\n"
    IDS_NOCHANGE, "Es gibt keine Änderung der Ressourcen-IDs."
    IDS_DLGFAIL, "Hoppla, ich konnte keinen RAD-Dialog erstellen."
    IDS_LOADWCLIB, "Laden Sie eine Fensterklassenbibliothek"
    IDS_AVIMOVIE, "(AVI-Film)\r\n"
    IDS_ADDDIALOG, "Dialogfeld hinzufügen"
    IDS_ADDMENU, "Menü hinzufügen"
    IDS_ADDVERINFO, "Versionsinfo hinzufügen"
    IDS_ADDCURSOR, "Cursor hinzufügen"
    IDS_NOMOREITEM, "Keine Gegenstände mehr."
    IDS_INVALIDDATA, "(ungültige Daten)\r\n"
    IDS_UPDATERESH, """resource.h"" aktualisieren?"
    IDS_CANTWRITERESH, """resource.h"" kann nicht geschrieben werden."
    IDS_SAVERESH, "Speichern Sie die Datei ""resource.h"""
    IDS_DLLFILTER, "DLL-Dateien (*.dll;*.ocx;*.mui)|*.dll;*.ocx;*.mui|Alle Dateien (*.*)|*.*|"
    IDS_EXERESRCFILTER, "Ladefähige Dateien (*.exe;*.dll;*.ocx;*.cpl;*.scr;*.mui;*.res;*.rc)|*.exe;*.dll;*.ocx;*.cpl;*.scr;*.mui;*.res;*.rc|Ausführbare Dateien (*.exe;*.dll;*.ocx;*.cpl;*.scr;*.mui)|*.exe;*.dll;*.ocx;*.cpl;*.scr;*.mui|Binäre Ressourcen (*.res)|*.res|Ressourcendateien (*.rc)|*.rc|Alle Dateien (*.*)|*.*|"
    IDS_CANTTESTCHILDWND, "Der Dialog kann nicht getestet werden, da es sich um ein untergeordnetes Fenster handelt."
    IDS_CANTTESTCLASSDLG, "Der Dialog kann nicht getestet werden, da er klassifiziert ist."
    IDS_FILEISUPXED, "Datei\r\n\r\n'%s'\r\n\r\nwird von UPX komprimiert. Möchten Sie es mithilfe einer temporären Datei extrahieren?\r\n\r\nWenn Sie es nicht erweitert haben, schlägt das Lesen möglicherweise fehl."
    IDS_CANTUPXEXTRACT, "Mit UPX kann nicht extrahiert werden."
    IDS_CANTSAVEUPXED, "Die Datei kann nicht gespeichert werden, da sie von UPX komprimiert wurde."
    IDS_MESSAGEID, "Nachrichten ID"
    IDS_MESSAGEVALUE, "Nachrichtenwert"
    IDS_RCFILTER, "RC-Dateien (*.rc)|*.rc|"
    IDS_EXPORT, "Export"
    IDS_CANTEXPORT, "Export fehlgeschlagen."
    IDS_MUSTBEEMPTYDIR, "Wenn eine externe Datei vorhanden ist, muss das Exportziel ein leerer Ordner sein."
    IDS_FULLWIDTH, "０１２３４５６７８９ＡＢＣＤＥＦＧＨＩＪＫＬＭＮＯＰＱＲＳＴＵＶＷＸＹＺａｂｃｄｅｆｇｈｉｊｋｌｍｎｏｐｑｒｓｔｕｖｗｘｙｚ－＿（）．　"
    IDS_HALFWIDTH, "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz-_(). "
    IDS_MACRONAME, "Makroname"
    IDS_MACROVALUE, "Makrowert"
    IDS_OPTIONAL, "(Optional)"
    IDS_ADDINCLUDE, "Include-Verzeichnis hinzufügen"
    IDS_EDITINCLUDE, "Bearbeiten Include-Verzeichnis"
    IDS_WINDRESEXE, "windres.exe|windres.exe|"
    IDS_CPPEXE, "cpp.exe|cpp.exe|"
    IDS_INVALIDPATH, "Ungültigen Pfad."
    IDS_DATATOOLONG, "Daten sind zu lang."
    IDS_ALL, "(Alle)"
    IDS_UNKNOWNFORMAT, "(Unbekanntes Datenformat)\r\n"
    IDS_LANGUAGE, "Sprache"
    IDS_INTVALUE, "Integer Wert"
    IDS_PARENTWND, "Übergeordnetes Testfenster"
    IDS_CHOOSE_OLE_CLSID, "Wählen Sie OLE CLSID"
    IDS_CONTROL, "Steuerung"
    IDS_MESSAGE, "Botschaft"
    IDS_STRING, "String"
    IDS_DATAISINVALID, "Daten sind ungültig."
    IDS_DLGINIT1, "Sie können die Initialisierung von Kombinationsfeldern und Listenfeldern festlegen, indem Sie Initialisierungsdaten in den RT_DLGINIT-Ressourcendaten mit demselben Namen wie die Dialogressource festlegen."
    IDS_DLGINIT2, "Wenn die WM_INITDIALOG-Nachricht eintrifft, Die Anwendung kann den Dialog durch Aufrufen der ExecuteDlgInitDx-Funktion der angehängten Datei ""DlgInit/DlgInit.h"" initialisieren.\r\n\r\n"
    IDS_DLGINIT3, "Bitte geben Sie eine Liste von Zeichenfolgen an, die durch Zeilenumbrüche für RT_DLGINIT getrennt sind."
    IDS_SAMELANG, "Es ist die gleiche Sprache."
    IDS_SAMENAME, "Es ist der gleiche Ressourcenname."
    IDS_CANTSAVETOEXE, "Es kann nicht als EXE aus einer nicht ausführbaren Datei gespeichert werden."
    IDS_CANTSTARTSEARCH, "Suche kann nicht gestartet werden."
    IDS_AMERICA, "Amerika"
    IDS_ENGLISH, "Englisch"
    IDS_CHINA, "China"
    IDS_CHINESE, "Chinesisch"
    IDS_RUSSIA, "Russland"
    IDS_RUSSIAN, "Russisch"
    IDS_WANNAGENRESH, "Möchten Sie die Datei 'resource.h' generieren?"
    IDS_EXEFILTER, "Ausführbare Dateien (*.exe;*.dll;*.ocx;*.cpl;*.scr;*.mui)|*.exe;*.dll;*.ocx;*.cpl;*.scr;*.mui|Alle Dateien (*.*)|*.*|"
    IDS_SAVEASCOMPRESS, "Speichern mit komprimiert"
    IDS_TOOL_NEW, "Neu"
    IDS_TOOL_OPEN, "Öffnen..."
    IDS_TOOL_SAVE, "Speichern als..."
    IDS_TOOL_EXPAND, "Alle erweitern"
    IDS_TOOL_COLLAPSE, "Alle reduzieren"
    IDS_TOOL_PLUS, "Artikel hinzufügen..."
    IDS_TOOL_MINUS, "Item löschen"
    IDS_TOOL_CHANGE, "Name / Sprache ändern"
    IDS_TOOL_CLONE, "In einen anderen Namen / eine andere Sprache klonen"
    IDS_TOOL_RECOMPILE, "Neu kompilieren"
    IDS_TOOL_CANCELEDIT, "Abbrechen Bearbeiten"
    IDS_TOOL_IMPORT, "Importieren..."
    IDS_TOOL_EXTRACT, "Extrakt..."
    IDS_TOOL_GUIEDIT, "Bearbeiten per GUI"
    IDS_UNITEDKINGDOM, "Großbritannien"
    IDS_GREATBRITAIN, "Großbritannien"
    IDS_BRITISH, "britisch"
    IDS_FRANCE, "Frankreich"
    IDS_FRENCH, "Französisch"
    IDS_GERMANY, "Deutschland"
    IDS_GERMAN, "Deutsche"
    IDS_SPAIN, "Spanien"
    IDS_SPANISH, "Spanisch"
    IDS_INVALIDLANG, "Nicht erkennbare Sprache."
    IDS_INVALIDNAME, "Ungültiger Ressourcenname."
    IDS_PNGRESBINFILTER, "PNG-Bild (*.png)|*.png|Binäre Ressourcen (*.res)|*.res|Binärdateien (*.bin)|*.bin|Alle Dateien (*.*)|*.*|"
    IDS_JPEGRESBINFILTER, "JPEG-Bild (*.jpg;*.jpeg;*.jpe;*.jfif)|*.jpg;*.jpeg;*.jpe;*.jfif|Binäre Ressourcen (*.res)|*.res|Binärdateien (*.bin)|*.bin|Alle Dateien (*.*)|*.*|"
    IDS_GIFRESBINFILTER, "GIF-Bild (*.gif)|*.gif|Binäre Ressourcen (*.res)|*.res|Binärdateien (*.bin)|*.bin|Alle Dateien (*.*)|*.*|"
    IDS_TIFFRESBINFILTER, "TIFF-Bild (*.tif;*.tiff)|*.tif;*.tiff|Binäre Ressourcen (*.res)|*.res|Binärdateien (*.bin)|*.bin|Alle Dateien (*.*)|*.*|"
    IDS_AVIRESBINFILTER, "AVI-Film (*.avi)|*.avi|Binäre Ressourcen (*.res)|*.res|Binärdateien (*.bin)|*.bin|Alle Dateien (*.*)|*.*|"
    IDS_WAVERESBINFILTER, "WAVE Sound (*.wav)|*.wav|Binäre Ressourcen (*.res)|*.res|Binärdateien (*.bin)|*.bin|Alle Dateien (*.*)|*.*|"
    IDS_COMMENT_SEP, "//////////////////////////////////////////////////////////////////////////////\r\n\r\n"
    IDS_NEWLINE, "\r\n"
    IDS_NOTICE, "// This file is automatically generated by RisohEditor 5.7.9.\r\n"
    IDS_DAGGER, "// † <-- This dagger helps UTF-8 detection.\r\n"
    IDS_IMPORTFILTER, "Importierbare Dateien|*.rc;*.res;*.dfm;*.html;*.htm;*.manifest;*.ico;*.cur;*.ani;*.wav;*.bmp;*.dib;*.png;*.gif;*.jpg;*.jpeg;*.jpe;*.jfif;*.tif;*.tiff;*.avi;*.wmf;*.emf|RC-Dateien (*.rc)|*.rc|Binäre Ressourcen (*.res)|*.res|Bilddateien|*.bmp;*.dib;*.png;*.gif;*.jpg;*.jpeg;*.jpe;*.jfif;*.tif;*.tiff;*.wmf;*.emf;*.tlb|Cursor-Dateien (*.cur;*.ani)|*.cur;*.ani|Symboldateien (*.ico)|*.ico|WAVE-Sounddateien (*.wav)|*.wav|HTML-Dateien (*.html;*.htm)|*.html;*.htm|Manifestdateien (*.manifest)|*.manifest|Delphi DFM-Dateien (*.dfm)|*.dfm|TYPELIB Files (*.tlb)|*.tlb|Alle Dateien (*.*)|*.*|"
    IDS_CANTWRITEBYLOCK, "Die Datei kann nicht geschrieben werden, da die folgende Datei gesperrt ist.\r\n\r\n%s"
    IDS_ANSI, "ANSI"
    IDS_WIDE, "Unicode"
    IDS_UTF8, "UTF-8 (mit BOM)"
    IDS_UTF8N, "UTF-8 (ohne BOM)"
    IDS_SJIS, "Shift_JIS"
    IDS_BINARY, "(Binärdaten)"
    IDS_RESTYPE, "Ressourcentyp"
    IDS_ENCODING, "Codierung"
    IDS_INVALIDRESTYPE, "Ungültiger Ressourcentyp."
    IDS_PATHSPACEERROR, "Sie haben fälschlicherweise mit Leerzeichen an der Stelle installiert! Der Ressourcen-Compiler kann keinen Speicherplatz akzeptieren.\n\nBitte vermeiden Sie ""C:\\Program Files""."
    IDS_LOADEGAPROGRAM, "Laden Sie das EGA-Programm..."
    IDS_EGAFILTER, "EGA-Programm (*.ega)|*.ega|Alle Dateien (*.*)|*.*|"
    IDS_QUERYSAVECHANGE, "Die Datei wurde geändert. Möchten Sie jetzt Änderungen speichern?"
    IDS_DFMFILTER, "DFM-Datei (*.dfm)|*.dfm|Textdateien (*.txt)|*.txt|Alle Dateien (*.*)|*.*|"
    IDS_CANTEXTRACTDFM, "DFM-Daten können nicht extrahiert werden."
    IDS_EXTRACTDFM, "DFM-Daten extrahieren"
    IDS_ENTERNONZERONAME, "Bitte geben Sie einen Ressourcennamen ungleich Null ein."
    IDS_ENTERNONZEROTYPE, "Bitte geben Sie einen Ressourcentyp ungleich Null ein."
    IDS_HOMEPAGE, "https://katahiromz.web.fc2.com/re/en/"
    IDS_FILESAVED, "Datei gespeichert."
    IDS_RECOMPILEOK, "Neukompilierung abgeschlossen."
    IDS_RECOMPILEFAILED, "Neukompilierung fehlgeschlagen (Syntaxfehler)."
    IDS_TOOL_EXPORT, "Export..."
    IDS_CODEEDITOR, "Code-Editor"
    IDS_HEXVIEWER, "Hex Viewer"
    IDS_INTEGERORIDENTIFIER, "(Ganzzahl oder Kennung)"
    IDS_NOTEXT, " "
    IDS_NOUPDATE, "Sie verwenden den neuesten RisohEditor."
    IDS_THEREISUPDATE, "RisohEditor %s ist verfügbar. Jetzt downloaden?"
    IDS_CANTCHECKUPDATE, "Fehler beim Überprüfen des RisohEditor-Updates."
    IDS_CODEPAGE1252, "1252 (Latein 1)"
    IDS_CODEPAGE1250, "1250 (Latein 2)"
    IDS_CODEPAGE1251, "1251 (Kyrillisch)"
    IDS_CODEPAGE1253, "1253 (Griechisch)"
    IDS_CODEPAGE1254, "1254 (Türkisch)"
    IDS_CODEPAGE1255, "1255 (Hebräisch)"
    IDS_CODEPAGE1256, "1256 (Arabisch)"
    IDS_CODEPAGE1257, "1257 (Baltisch)"
    IDS_CODEPAGE874, "874 (Thai)"
    IDS_CODEPAGE932, "932 (Japanisch)"
    IDS_CODEPAGE936, "936 (Vereinfachtes Chinesisch)"
    IDS_CODEPAGE949, "949 (Koreanisch)"
    IDS_CODEPAGE950, "950 (Traditionelles Chinesisch)"
    IDS_CODEPAGE65001, "65001 (UTF-8)"
    IDS_EXTRACTTLB, "Extract TYPELIB data"
    IDS_CANTEXTRACTTLB, "Unable to extract the TYPELIB data."
    IDS_TLBRESBINFILTER, "TYPELIB data (*.tlb)|*.tlb|Binary Resources (*.res)|*.res|Text Files (*.txt)|*.txt|MIDL Files (*.idl)|*.idl|All Files (*.*)|*.*|"
    IDS_USAGE, "Usage: RisohEditor [options | ""file""]\n\nOptions:\n--help  Show this message.\n--version  Show version info.\n--load ""your-file.rc""  Load the file (without GUI)\n--save ""your-file.res""  Save the file (without GUI)\n--log-file ""log-file.txt""  Specify the log file.\n--load-options OPTIONS  Set load options.\n--save-options OPTIONS  Set save options.\n\nLoad options: (no-load-res-h)\nSave options: (idc-static)(compress)(sep-lang)(no-res-folder)(lang-macro)(less-comments)(wrap-manifest)(begin-end)(utf-16)(backup)(ms-msgtbl)"
    IDS_NOSELECTION, "Es gibt keine Auswahl."
    IDS_TRANSLATORS, "[Translators]\r\nEnglish: Katayama Hirofumi MZ\r\nFinnish: Veikko Muurikainen\r\nIndonesian: Mas Ahmad Muhammad\r\nItalian: R.B.\r\nJapanese: Katayama Hirofumi MZ\r\nKorean: VenusGirl (비너스걸)\r\nPolish: Piotr Hetnarowicz\r\nPortuguese: JNylson\r\nRussian: Dmitry Yerokhin\r\nSimplified Chinese: 林鸿湘\r\n"
}

//////////////////////////////////////////////////////////////////////////////

```

`src/lang/en_US.rc`:

```rc
// This file is automatically generated by RisohEditor 5.7.9.
// † <-- This dagger helps UTF-8 detection.

#pragma code_page(65001) // UTF-8

LANGUAGE LANG_ENGLISH, SUBLANG_DEFAULT

//////////////////////////////////////////////////////////////////////////////
// RT_MENU

IDR_MAINMENU MENU
{
    POPUP "&File"
    {
        MENUITEM "&New\tCtrl+N", ID_NEW
        MENUITEM SEPARATOR
        MENUITEM "&Open...\tCtrl+O", ID_OPEN
        MENUITEM "&Save...\tCtrl+S", ID_SAVE
        MENUITEM "Save &As...\tShift+Ctrl+S", ID_SAVEAS
        MENUITEM "Save With Co&mpression...", ID_SAVEASCOMPRESS
        MENUITEM SEPARATOR
        MENUITEM "&Import...\tCtrl+I", ID_IMPORT
        MENUITEM "&Export...\tCtrl+P", ID_EXPORT
        MENUITEM SEPARATOR
        MENUITEM "Reload &resource.h...\tCtrl+R", ID_LOADRESH
        MENUITEM "Save re&source.h...", ID_UPDATERESHBANG
        MENUITEM "Ad&vice resource.h Modification...", ID_ADVICERESH
        MENUITEM "&Unload resource.h", ID_UNLOADRESH
        MENUITEM SEPARATOR
        MENUITEM "Load &Window Class Library...", ID_LOADWCLIB
        MENUITEM SEPARATOR
        POPUP "Recently Used Files"
        {
            MENUITEM "(None)", -1, GRAYED
        }
        MENUITEM SEPARATOR
        MENUITEM "E&xit\tAlt+F4", ID_EXIT
    }
    POPUP "&Edit"
    {
        MENUITEM "Edit by &GUI...\tCtrl+G", ID_GUIEDIT
        MENUITEM SEPARATOR
        POPUP "&Add"
        {
            MENUITEM "Add &Icon...", ID_ADDICON
            MENUITEM "Add &Cursor...", ID_ADDCURSOR
            MENUITEM "Add &Bitmap...", ID_ADDBITMAP
            MENUITEM "Add &Dialog...", ID_ADDDIALOG
            MENUITEM "Add &Menu...", ID_ADDMENU
            MENUITEM "Add &String Table...", ID_ADDSTRINGTABLE
            MENUITEM "Add M&essage Table...", ID_ADDMESSAGETABLE
            MENUITEM "Add &HTML...", ID_ADDHTML
            MENUITEM "Add &Accelerators...", ID_ADDACCEL
            MENUITEM "Add &Version Info...", ID_ADDVERINFO
            MENUITEM "Add Mani&fest...", ID_ADDMANIFEST
            MENUITEM "Add &Toolbar", ID_ADDTOOLBAR
            MENUITEM "Add &Resource Item...", ID_ADDRES
        }
        POPUP "&Replace"
        {
            MENUITEM "Replace &Icon...", ID_REPLACEICON
            MENUITEM "Replace &Cursor...", ID_REPLACECURSOR
            MENUITEM "Replace &Bitmap...", ID_REPLACEBITMAP
            MENUITEM "Replace Binary &Resource Item...", ID_REPLACEBIN
        }
        POPUP "&Extract"
        {
            MENUITEM "Extract &Icon...", ID_EXTRACTICON
            MENUITEM "Extract &Cursor...", ID_EXTRACTCURSOR
            MENUITEM "Extract &Bitmap...", ID_EXTRACTBITMAP
            MENUITEM "Extract &as RC file...", ID_EXTRACTRC
            MENUITEM "Extract Binary &Resource Item...", ID_EXTRACTBIN
        }
        MENUITEM SEPARATOR
        MENUITEM "C&hange Name/Language\tF2", ID_EDITLABEL
        MENUITEM SEPARATOR
        MENUITEM "Clone In New &Name...", ID_COPYASNEWNAME
        MENUITEM "Clone In New &Language...", ID_COPYASNEWLANG
        MENUITEM "Copy to multiple languages...", ID_COPYTOMULTILANG
        MENUITEM SEPARATOR
        MENUITEM "Do &Test", ID_TEST
        MENUITEM SEPARATOR
        MENUITEM "&Delete\tDel", ID_DELETERES
        MENUITEM SEPARATOR
        MENUITEM "&ID Association...", ID_IDASSOC
        MENUITEM "Predefined &Macros...", ID_PREDEFMACROS
        MENUITEM "&Font settings...", ID_FONTS
        MENUITEM "Set &Paths...", ID_SETPATHS
        MENUITEM SEPARATOR
        MENUITEM "&UI Language Select (UI语言选择)...", ID_CHOOSEUILANG
        MENUITEM SEPARATOR
        MENUITEM "Delphi DFM &settings...", ID_DFMSETTINGS
        MENUITEM "&Configuration...", ID_CONFIG
    }
    POPUP "&Search"
    {
        MENUITEM "&Find...\tCtrl+F", ID_FIND
        MENUITEM SEPARATOR
        MENUITEM "Search &Upward\tShift+F3", ID_FINDUPWARD
        MENUITEM "Search &Downward\tF3", ID_FINDDOWNWARD
        MENUITEM SEPARATOR
        MENUITEM "&Query constant...", ID_QUERYCONSTANT
    }
    POPUP "&View"
    {
        MENUITEM "&Status Bar", ID_STATUSBAR
        MENUITEM "&Tool Bar", ID_SHOWHIDETOOLBAR
        MENUITEM "&Binary", ID_BINARYPANE
        MENUITEM SEPARATOR
        MENUITEM "E&xpand All\tCtrl+K", ID_EXPAND_ALL
        MENUITEM "C&ollapse All\tCtrl+L", ID_COLLAPSE_ALL
        MENUITEM SEPARATOR
        MENUITEM "List of &Resource IDs", ID_IDLIST
        MENUITEM "List of &Languages...", ID_SHOWLANGS
        MENUITEM SEPARATOR
        MENUITEM "Always &CONTROL statement", ID_ALWAYSCONTROL
        MENUITEM "Don't Use &ID Macros", ID_HIDEIDMACROS
        MENUITEM "Use IDC_ST&ATIC", ID_USEIDC_STATIC
        MENUITEM "&Word Wrapping", ID_WORD_WRAP
        MENUITEM "Use BE&GIN/END", ID_USEBEGINEND
        MENUITEM "Use Microsoft Message &Table", ID_USEMSMSGTBL
        MENUITEM SEPARATOR
        MENUITEM "&Encoding of resource item...", ID_ENCODING
        MENUITEM "Dialog &font substitutes...", ID_DIALOG_FONT_SUBSTITUTES
        MENUITEM SEPARATOR
        MENUITEM "Re&fresh", ID_REFRESHALL
    }
    POPUP "&Automation"
    {
        MENUITEM "Programming Language &EGA...", ID_EGA
        MENUITEM "&Run EGA program...", ID_EGA_PROGRAM
        MENUITEM "Open EGA &Manual", ID_OPEN_EGA_MANUAL
    }
    POPUP "&Help"
    {
        MENUITEM "Open &README.txt (English)", ID_OPENREADME
        MENUITEM "Open HISTORY.txt", ID_OPENHISTORY
        MENUITEM "Open &LICENSE.txt", ID_OPENLICENSE
        MENUITEM SEPARATOR
        MENUITEM "A &Guide to RisohEditor", ID_GUIDE
        MENUITEM "Check RisohEditor &Update...", ID_CHECKUPDATE
        MENUITEM SEPARATOR
        MENUITEM "&About...", ID_ABOUT
    }
}

IDR_POPUPMENUS MENU
{
    POPUP "Popup #0"
    {
        MENUITEM "Edit by &GUI...\tCtrl+G", ID_GUIEDIT
        MENUITEM SEPARATOR
        POPUP "&Add"
        {
            MENUITEM "Add &Icon...", ID_ADDICON
            MENUITEM "Add &Cursor...", ID_ADDCURSOR
            MENUITEM "Add &Bitmap...", ID_ADDBITMAP
            MENUITEM "Add &Dialog...", ID_ADDDIALOG
            MENUITEM "Add &Menu...", ID_ADDMENU
            MENUITEM "Add &String Table...", ID_ADDSTRINGTABLE
            MENUITEM "Add M&essage Table...", ID_ADDMESSAGETABLE
            MENUITEM "Add &HTML...", ID_ADDHTML
            MENUITEM "Add &Accelerators...", ID_ADDACCEL
            MENUITEM "Add &Version Info...", ID_ADDVERINFO
            MENUITEM "Add Mani&fest...", ID_ADDMANIFEST
            MENUITEM "Add &Toolbar", ID_ADDTOOLBAR
            MENUITEM "Add &Resource Item...", ID_ADDRES
        }
        POPUP "&Replace"
        {
            MENUITEM "Replace &Icon...", ID_REPLACEICON
            MENUITEM "Replace &Cursor...", ID_REPLACECURSOR
            MENUITEM "Replace &Bitmap...", ID_REPLACEBITMAP
            MENUITEM "Replace Binary &Resource Item...", ID_REPLACEBIN
        }
        POPUP "&Extract"
        {
            MENUITEM "Extract &Icon...", ID_EXTRACTICON
            MENUITEM "Extract &Cursor...", ID_EXTRACTCURSOR
            MENUITEM "Extract &Bitmap...", ID_EXTRACTBITMAP
            MENUITEM "Extract &as RC file...", ID_EXTRACTRC
            MENUITEM "Extract Binary &Resource Item...", ID_EXTRACTBIN
        }
        MENUITEM SEPARATOR
        MENUITEM "C&hange Name/Language\tF2", ID_EDITLABEL
        MENUITEM SEPARATOR
        MENUITEM "Clone In New &Name...", ID_COPYASNEWNAME
        MENUITEM "Clone In New &Language...", ID_COPYASNEWLANG
        MENUITEM "Copy to multiple languages...", ID_COPYTOMULTILANG
        MENUITEM SEPARATOR
        MENUITEM "Do &Test", ID_TEST
        MENUITEM SEPARATOR
        MENUITEM "&Delete\tDel", ID_DELETERES
    }
    POPUP "Popup #1"
    {
        MENUITEM "&Add Control...", ID_ADDCTRL
        MENUITEM SEPARATOR
        MENUITEM "Cu&t\tCtrl+X", ID_CUT
        MENUITEM "&Copy\tCtrl+C", ID_COPY
        MENUITEM "&Paste\tCtrl+V", ID_PASTE
        MENUITEM "&Delete\tDel", ID_DELCTRL
        MENUITEM SEPARATOR
        POPUP "&Index"
        {
            MENUITEM "Go &Top", ID_CTRLINDEXTOP
            MENUITEM SEPARATOR
            MENUITEM "&Decrement Index", ID_CTRLINDEXMINUS
            MENUITEM "&Increment Index", ID_CTRLINDEXPLUS
            MENUITEM SEPARATOR
            MENUITEM "Go &Bottom", ID_CTRLINDEXBOTTOM
            MENUITEM SEPARATOR
            MENUITEM "Show/Hide Indeces\tCtrl+D", ID_SHOWHIDEINDEX
        }
        POPUP "&Alignment"
        {
            MENUITEM "&Top-Align", ID_TOPALIGN
            MENUITEM "&Bottom-Align", ID_BOTTOMALIGN
            MENUITEM "&Left-Align", ID_LEFTALIGN
            MENUITEM "&Right-Align", ID_RIGHTALIGN
            MENUITEM SEPARATOR
            MENUITEM "Fit To &Grid", ID_FITTOGRID
        }
        MENUITEM SEPARATOR
        MENUITEM "&Refresh", ID_REFRESHDIALOG
        MENUITEM SEPARATOR
        MENUITEM "&Properties for Control...", ID_CTRLPROP
        MENUITEM "Pr&operties for Dialog...", ID_DLGPROP
    }
    POPUP "Popup #2"
    {
        MENUITEM "&Modify...", ID_MODIFYASSOC
    }
    POPUP "Popup #3"
    {
        MENUITEM "&Jump!", ID_IDJUMP
        MENUITEM SEPARATOR
        MENUITEM "&Add ID...", ID_ADDRESID
        MENUITEM "&Modify ID...", ID_MODIFYRESID
        MENUITEM SEPARATOR
        MENUITEM "Copy &Name", ID_COPYRESIDNAME
        MENUITEM "Copy &Value", ID_COPYRESIDVALUE
        MENUITEM "Copy &Definition\tCtrl+C", ID_COPYIDDEF
        MENUITEM SEPARATOR
        MENUITEM "&Delete ID\tDel", ID_DELETERESID
        MENUITEM SEPARATOR
        MENUITEM "&Decimal Numbers", ID_BASE10
        MENUITEM "&Hexadecimal Numbers", ID_BASE16
        MENUITEM SEPARATOR
        MENUITEM "&Reload", ID_LOADRESH
    }
    POPUP "Popup #4"
    {
        MENUITEM "&Add...", ID_ADD
        MENUITEM SEPARATOR
        MENUITEM "Change &Name...\tF2", ID_RENAME
        MENUITEM "Change &Value...", ID_MODIFY
        MENUITEM SEPARATOR
        MENUITEM "&Delete\tDel", ID_DELETE
    }
    POPUP "Popup #5"
    {
        MENUITEM "&Copy Integer Value", ID_COPY
    }
    POPUP "Popup #6"
    {
        MENUITEM "&Add...", psh1
        MENUITEM "&Modify...", psh2
        MENUITEM SEPARATOR
        MENUITEM "&Up", psh4
        MENUITEM "&Down", psh5
        MENUITEM "&Left", psh6
        MENUITEM "&Right", psh7
        MENUITEM SEPARATOR
        MENUITEM "Dele&te\tDel", psh3
    }
    POPUP "Popup #7"
    {
        MENUITEM "&Add...", psh1
        MENUITEM "&Modify...", psh2
        MENUITEM SEPARATOR
        MENUITEM "&Up", psh4
        MENUITEM "&Down", psh5
        MENUITEM SEPARATOR
        MENUITEM "Dele&te\tDel", psh3
    }
    POPUP "Popup #8"
    {
        MENUITEM "&Add...", ID_ADD
        MENUITEM "&Modify...", ID_MODIFY
        MENUITEM SEPARATOR
        MENUITEM "&Delete\tDel", ID_DELETE
    }
}

//////////////////////////////////////////////////////////////////////////////
// RT_DIALOG

IDD_REPLACERES DIALOGEX 0, 0, 215, 170
CAPTION "Replace Resource"
STYLE DS_MODALFRAME | WS_POPUPWINDOW | WS_CAPTION
FONT 9, "MS Shell Dlg", 0, 0, 1
{
    LTEXT "Resource &Type:", -1, 5, 7, 70, 12
    COMBOBOX cmb1, 75, 5, 135, 200, CBS_HASSTRINGS | CBS_AUTOHSCROLL | CBS_DROPDOWN | WS_BORDER | WS_VSCROLL | WS_TABSTOP
    LTEXT "Resource &Name:", -1, 5, 32, 70, 12
    COMBOBOX cmb2, 75, 30, 135, 200, CBS_HASSTRINGS | CBS_AUTOHSCROLL | CBS_DROPDOWN | WS_DISABLED | WS_BORDER | WS_VSCROLL | WS_TABSTOP
    LTEXT "Resource &Language:", -1, 5, 57, 70, 12
    COMBOBOX cmb3, 75, 55, 135, 200, CBS_HASSTRINGS | CBS_AUTOHSCROLL | CBS_DROPDOWN | WS_DISABLED | WS_BORDER | WS_VSCROLL | WS_TABSTOP
    LTEXT "Binary &File:", -1, 5, 85, 100, 12
    EDITTEXT edt1, 5, 97, 205, 14, ES_AUTOHSCROLL
    PUSHBUTTON "&Browse...", psh1, 150, 115, 60, 14
    DEFPUSHBUTTON "OK", IDOK, 35, 150, 60, 14
    PUSHBUTTON "Cancel", IDCANCEL, 115, 150, 60, 14
    {
        0x1234, 0x5678, 0x0011
    }
}

IDD_ADDICON DIALOG 0, 0, 215, 135
CAPTION "Add Icon"
STYLE DS_MODALFRAME | WS_POPUPWINDOW | WS_CAPTION
FONT 9, "MS Shell Dlg"
{
    LTEXT "&Icon File:", -1, 5, 7, 100, 12
    EDITTEXT edt1, 5, 18, 205, 14, ES_AUTOHSCROLL
    PUSHBUTTON "&Browse...", psh1, 150, 35, 60, 14
    ICON 0, ico1, 5, 35, 0, 0
    LTEXT "Resource &Name:", -1, 5, 67, 70, 12
    COMBOBOX cmb2, 75, 65, 120, 300, CBS_HASSTRINGS | CBS_AUTOHSCROLL | CBS_DROPDOWN | WS_BORDER | WS_VSCROLL | WS_TABSTOP
    PUSHBUTTON "&...", psh2, 195, 65, 15, 14
    LTEXT "Resource &Language:", -1, 5, 92, 70, 12
    COMBOBOX cmb3, 75, 90, 135, 200, CBS_HASSTRINGS | CBS_AUTOHSCROLL | CBS_DROPDOWN | WS_BORDER | WS_VSCROLL | WS_TABSTOP
    DEFPUSHBUTTON "OK", IDOK, 35, 115, 60, 14
    PUSHBUTTON "Cancel", IDCANCEL, 115, 115, 60, 14
}

IDD_REPLACEICON DIALOG 0, 0, 215, 135
CAPTION "Replace Icon"
STYLE DS_MODALFRAME | WS_POPUPWINDOW | WS_CAPTION
FONT 9, "MS Shell Dlg"
{
    LTEXT "&Icon File:", -1, 5, 7, 100, 12
    EDITTEXT edt1, 5, 18, 205, 14, ES_AUTOHSCROLL
    PUSHBUTTON "&Browse...", psh1, 150, 35, 60, 14
    ICON 0, ico1, 5, 35, 0, 0
    LTEXT "Resource &Name:", -1, 5, 67, 70, 12
    COMBOBOX cmb2, 75, 65, 135, 13, CBS_HASSTRINGS | CBS_AUTOHSCROLL | CBS_DROPDOWN | WS_DISABLED | WS_BORDER | WS_VSCROLL | WS_TABSTOP
    LTEXT "Resource &Language:", -1, 5, 92, 70, 12
    COMBOBOX cmb3, 75, 90, 135, 13, CBS_HASSTRINGS | CBS_AUTOHSCROLL | CBS_DROPDOWN | WS_DISABLED | WS_BORDER | WS_VSCROLL | WS_TABSTOP
    DEFPUSHBUTTON "OK", IDOK, 35, 115, 60, 14
    PUSHBUTTON "Cancel", IDCANCEL, 115, 115, 60, 14
}

IDD_ADDBITMAP DIALOG 0, 0, 215, 135
CAPTION "Add Bitmap"
STYLE DS_MODALFRAME | WS_POPUPWINDOW | WS_CAPTION
FONT 9, "MS Shell Dlg"
{
    LTEXT "&Bitmap File:", -1, 5, 7, 100, 12
    EDITTEXT edt1, 5, 18, 205, 14, ES_AUTOHSCROLL
    PUSHBUTTON "&Browse...", psh1, 150, 35, 60, 14
    LTEXT "Resource &Name:", -1, 5, 67, 70, 12
    COMBOBOX cmb2, 75, 65, 120, 300, CBS_HASSTRINGS | CBS_AUTOHSCROLL | CBS_DROPDOWN | WS_BORDER | WS_VSCROLL | WS_TABSTOP
    PUSHBUTTON "&...", psh2, 195, 65, 15, 14
    LTEXT "Resource &Language:", -1, 5, 92, 70, 12
    COMBOBOX cmb3, 75, 90, 135, 200, CBS_HASSTRINGS | CBS_AUTOHSCROLL | CBS_DROPDOWN | WS_BORDER | WS_VSCROLL | WS_TABSTOP
    DEFPUSHBUTTON "OK", IDOK, 35, 115, 60, 14
    PUSHBUTTON "Cancel", IDCANCEL, 115, 115, 60, 14
}

IDD_REPLACEBMP DIALOG 0, 0, 215, 135
CAPTION "Replace Bitmap"
STYLE DS_MODALFRAME | WS_POPUPWINDOW | WS_CAPTION
FONT 9, "MS Shell Dlg"
{
    LTEXT "&Bitmap File:", -1, 5, 7, 100, 12
    EDITTEXT edt1, 5, 18, 205, 14, ES_AUTOHSCROLL
    PUSHBUTTON "&Browse...", psh1, 150, 35, 60, 14
    LTEXT "Resource &Name:", -1, 5, 67, 70, 12
    COMBOBOX cmb2, 75, 65, 135, 200, CBS_HASSTRINGS | CBS_AUTOHSCROLL | CBS_DROPDOWN | WS_DISABLED | WS_BORDER | WS_VSCROLL | WS_TABSTOP
    LTEXT "Resource &Language:", -1, 5, 92, 70, 12
    COMBOBOX cmb3, 75, 90, 135, 200, CBS_HASSTRINGS | CBS_AUTOHSCROLL | CBS_DROPDOWN | WS_DISABLED | WS_BORDER | WS_VSCROLL | WS_TABSTOP
    DEFPUSHBUTTON "OK", IDOK, 35, 115, 60, 14
    PUSHBUTTON "Cancel", IDCANCEL, 115, 115, 60, 14
}

IDD_ADDRES DIALOG 0, 0, 215, 170
CAPTION "Add Resource"
STYLE DS_MODALFRAME | WS_POPUPWINDOW | WS_CAPTION
FONT 9, "MS Shell Dlg"
{
    LTEXT "Resource &Type:", -1, 5, 7, 70, 12
    COMBOBOX cmb1, 75, 5, 135, 200, CBS_HASSTRINGS | CBS_AUTOHSCROLL | CBS_DROPDOWN | WS_BORDER | WS_VSCROLL | WS_TABSTOP
    LTEXT "Resource &Name:", -1, 5, 32, 70, 12
    COMBOBOX cmb2, 75, 30, 120, 300, CBS_HASSTRINGS | CBS_AUTOHSCROLL | CBS_DROPDOWN | WS_BORDER | WS_VSCROLL | WS_TABSTOP
    PUSHBUTTON "&...", psh2, 195, 30, 15, 14
    LTEXT "", stc1, 75, 43, 115, 10
    LTEXT "Resource &Language:", -1, 5, 57, 70, 12
    COMBOBOX cmb3, 75, 55, 135, 200, CBS_HASSTRINGS | CBS_AUTOHSCROLL | CBS_DROPDOWN | WS_BORDER | WS_VSCROLL | WS_TABSTOP
    LTEXT "Binary &File:", -1, 5, 85, 100, 12
    EDITTEXT edt1, 5, 97, 205, 14, ES_AUTOHSCROLL
    PUSHBUTTON "&Browse...", psh1, 150, 115, 60, 14
    LTEXT "", stc2, 5, 112, 100, 10
    DEFPUSHBUTTON "OK", IDOK, 35, 150, 60, 14
    PUSHBUTTON "Cancel", IDCANCEL, 115, 150, 60, 14
}

IDD_ADDCURSOR DIALOG 0, 0, 215, 135
CAPTION "Add Cursor"
STYLE DS_MODALFRAME | WS_POPUPWINDOW | WS_CAPTION
FONT 9, "MS Shell Dlg"
{
    LTEXT "&Cursor File:", -1, 5, 7, 100, 12
    EDITTEXT edt1, 5, 18, 205, 14, ES_AUTOHSCROLL
    PUSHBUTTON "&Browse...", psh1, 150, 35, 60, 14
    ICON 0, ico1, 5, 35, 0, 0
    LTEXT "Resource &Name:", -1, 5, 67, 70, 12
    COMBOBOX cmb2, 75, 65, 120, 200, CBS_HASSTRINGS | CBS_AUTOHSCROLL | CBS_DROPDOWN | WS_BORDER | WS_VSCROLL | WS_TABSTOP
    PUSHBUTTON "&...", psh2, 195, 65, 15, 14
    LTEXT "Resource &Language:", -1, 5, 92, 70, 12
    COMBOBOX cmb3, 75, 90, 135, 200, CBS_HASSTRINGS | CBS_AUTOHSCROLL | CBS_DROPDOWN | WS_BORDER | WS_VSCROLL | WS_TABSTOP
    DEFPUSHBUTTON "OK", IDOK, 35, 115, 60, 14
    PUSHBUTTON "Cancel", IDCANCEL, 115, 115, 60, 14
}

IDD_REPLACECUR DIALOG 0, 0, 215, 135
CAPTION "Replace Cursor"
STYLE DS_MODALFRAME | WS_POPUPWINDOW | WS_CAPTION
FONT 9, "MS Shell Dlg"
{
    LTEXT "&Cursor File:", -1, 5, 7, 100, 12
    EDITTEXT edt1, 5, 18, 205, 14, ES_AUTOHSCROLL
    PUSHBUTTON "&Browse...", psh1, 150, 35, 60, 14
    ICON 0, ico1, 5, 35, 0, 0
    LTEXT "Resource &Name:", -1, 5, 67, 70, 12
    COMBOBOX cmb2, 75, 65, 135, 200, CBS_HASSTRINGS | CBS_AUTOHSCROLL | CBS_DROPDOWN | WS_DISABLED | WS_BORDER | WS_VSCROLL | WS_TABSTOP
    LTEXT "Resource &Language:", -1, 5, 92, 70, 12
    COMBOBOX cmb3, 75, 90, 135, 200, CBS_HASSTRINGS | CBS_AUTOHSCROLL | CBS_DROPDOWN | WS_DISABLED | WS_BORDER | WS_VSCROLL | WS_TABSTOP
    DEFPUSHBUTTON "OK", IDOK, 35, 115, 60, 14
    PUSHBUTTON "Cancel", IDCANCEL, 115, 115, 60, 14
}

IDD_MENUTEST DIALOG 0, 0, 215, 135
CAPTION "Menu Test"
STYLE DS_MODALFRAME | WS_POPUPWINDOW | WS_CAPTION
FONT 9, "MS Shell Dlg"
{
}

IDD_ADDKEY DIALOG 0, 0, 190, 120
CAPTION "Add Key"
STYLE DS_MODALFRAME | WS_POPUPWINDOW | WS_CAPTION
FONT 9, "MS Shell Dlg"
{
    RTEXT "&Key:", -1, 5, 12, 60, 14
    COMBOBOX cmb1, 70, 10, 110, 200, CBS_DROPDOWN | WS_BORDER | WS_VSCROLL | WS_TABSTOP
    RTEXT "Command &ID:", -1, 5, 37, 60, 14
    COMBOBOX cmb2, 70, 35, 95, 300, CBS_DROPDOWN | WS_BORDER | WS_VSCROLL | WS_TABSTOP
    PUSHBUTTON "&...", psh1, 165, 35, 15, 14
    AUTOCHECKBOX "&VIRTKEY", chx1, 5, 60, 60, 14
    AUTOCHECKBOX "&NOINVERT", chx2, 70, 60, 60, 14
    AUTOCHECKBOX "&CONTROL", chx3, 5, 75, 60, 14
    AUTOCHECKBOX "&SHIFT", chx4, 70, 75, 60, 14
    AUTOCHECKBOX "&ALT", chx5, 140, 75, 45, 14
    DEFPUSHBUTTON "OK", IDOK, 60, 100, 60, 14
    PUSHBUTTON "Cancel", IDCANCEL, 125, 100, 60, 14
}

IDD_MODIFYKEY DIALOG 0, 0, 190, 120
CAPTION "Modify Key"
STYLE DS_MODALFRAME | WS_POPUPWINDOW | WS_CAPTION
FONT 9, "MS Shell Dlg"
{
    RTEXT "&Key:", -1, 5, 12, 60, 14
    COMBOBOX cmb1, 70, 10, 110, 200, CBS_DROPDOWN | WS_BORDER | WS_VSCROLL | WS_TABSTOP
    RTEXT "Command &ID:", -1, 5, 37, 60, 14
    COMBOBOX cmb2, 70, 35, 95, 200, CBS_DROPDOWN | WS_BORDER | WS_VSCROLL | WS_TABSTOP
    PUSHBUTTON "&...", psh1, 165, 35, 15, 14
    AUTOCHECKBOX "&VIRTKEY", chx1, 5, 60, 60, 14
    AUTOCHECKBOX "&NOINVERT", chx2, 70, 60, 60, 14
    AUTOCHECKBOX "&CONTROL", chx3, 5, 75, 60, 14
    AUTOCHECKBOX "&SHIFT", chx4, 70, 75, 60, 14
    AUTOCHECKBOX "&ALT", chx5, 140, 75, 45, 14
    DEFPUSHBUTTON "OK", IDOK, 60, 100, 60, 14
    PUSHBUTTON "Cancel", IDCANCEL, 125, 100, 60, 14
}

IDD_EDITACCEL DIALOG 0, 0, 285, 165
CAPTION "Edit Accelerators"
STYLE WS_POPUPWINDOW | WS_CAPTION | WS_THICKFRAME
FONT 9, "MS Shell Dlg"
{
    LTEXT "Key &List:", -1, 5, 7, 100, 12
    CONTROL "", lst1, "SysListView32", LVS_NOSORTHEADER | LVS_AUTOARRANGE | LVS_NOLABELWRAP | LVS_SHOWSELALWAYS | LVS_SINGLESEL | LVS_REPORT | WS_BORDER | WS_VSCROLL | WS_HSCROLL | WS_TABSTOP, 5, 20, 210, 120
    PUSHBUTTON "&Add...", psh1, 220, 20, 60, 14
    PUSHBUTTON "&Modify...", psh2, 220, 40, 60, 14
    PUSHBUTTON "&Delete", psh3, 220, 60, 60, 14
    PUSHBUTTON "&Up", psh4, 220, 100, 60, 14
    PUSHBUTTON "D&own", psh5, 220, 120, 60, 14
    DEFPUSHBUTTON "OK", IDOK, 155, 145, 60, 14
    PUSHBUTTON "Cancel", IDCANCEL, 220, 145, 60, 14
    PUSHBUTTON "Delete A&ll", psh6, 5, 145, 79, 14
}

IDD_ADDSTR DIALOG 0, 0, 255, 115
CAPTION "Add String Entry"
STYLE WS_POPUPWINDOW | WS_CAPTION | WS_THICKFRAME
FONT 9, "MS Shell Dlg"
{
    LTEXT "String &ID:", -1, 5, 7, 50, 12
    COMBOBOX cmb1, 60, 5, 134, 200, CBS_HASSTRINGS | CBS_AUTOHSCROLL | CBS_DROPDOWN | WS_BORDER | WS_VSCROLL | WS_TABSTOP
    PUSHBUTTON "&...", psh1, 195, 5, 15, 14
    LTEXT "String &Value:", -1, 5, 27, 54, 12
    EDITTEXT edt1, 60, 25, 190, 45, ES_WANTRETURN | ES_AUTOVSCROLL | ES_MULTILINE | WS_VSCROLL
    AUTOCHECKBOX "&Replace ""\\r\\n"" with ""\\n""", chx1, 60, 75, 190, 14
    DEFPUSHBUTTON "OK", IDOK, 125, 95, 60, 14
    PUSHBUTTON "Cancel", IDCANCEL, 190, 95, 60, 14
}

IDD_MODIFYSTR DIALOG 0, 0, 255, 115
CAPTION "Modify String Entry"
STYLE WS_POPUPWINDOW | WS_CAPTION | WS_THICKFRAME
FONT 9, "MS Shell Dlg"
{
    LTEXT "String &ID:", -1, 5, 7, 50, 12
    COMBOBOX cmb1, 60, 5, 134, 200, CBS_HASSTRINGS | CBS_AUTOHSCROLL | CBS_DROPDOWN | WS_BORDER | WS_VSCROLL | WS_TABSTOP
    PUSHBUTTON "&...", psh1, 195, 5, 15, 14
    LTEXT "String &Value:", -1, 5, 27, 54, 12
    EDITTEXT edt1, 60, 25, 190, 45, ES_WANTRETURN | ES_AUTOVSCROLL | ES_MULTILINE | WS_VSCROLL
    AUTOCHECKBOX "&Replace ""\\r\\n"" with ""\\n""", chx1, 60, 75, 190, 14
    DEFPUSHBUTTON "OK", IDOK, 125, 95, 60, 14
    PUSHBUTTON "Cancel", IDCANCEL, 190, 95, 60, 14
}

IDD_STRINGS DIALOG 0, 0, 325, 160
CAPTION "String Table"
STYLE WS_POPUPWINDOW | WS_CAPTION | WS_THICKFRAME
FONT 9, "MS Shell Dlg"
{
    LTEXT "String &Entries:", -1, 5, 7, 100, 12
    CONTROL "", lst1, "SysListView32", LVS_NOSORTHEADER | LVS_AUTOARRANGE | LVS_NOLABELWRAP | LVS_SHOWSELALWAYS | LVS_SINGLESEL | LVS_REPORT | WS_BORDER | WS_VSCROLL | WS_HSCROLL | WS_TABSTOP, 5, 20, 315, 115
    PUSHBUTTON "&Add...", psh1, 130, 3, 60, 14
    PUSHBUTTON "&Modify...", psh2, 195, 3, 60, 14
    PUSHBUTTON "&Delete", psh3, 260, 3, 60, 14
    DEFPUSHBUTTON "OK", IDOK, 195, 140, 60, 14
    PUSHBUTTON "Cancel", IDCANCEL, 260, 140, 60, 14
    PUSHBUTTON "Delete A&ll", psh4, 5, 140, 75, 14
}

IDD_ADDMITEM DIALOG 0, 0, 210, 200
CAPTION "Add Menu Item"
STYLE DS_MODALFRAME | WS_POPUPWINDOW | WS_CAPTION
FONT 9, "MS Shell Dlg"
{
    LTEXT "C&aption:", -1, 5, 7, 55, 12
    COMBOBOX cmb1, 65, 6, 140, 200, CBS_AUTOHSCROLL | CBS_DROPDOWN | WS_BORDER | WS_VSCROLL | WS_TABSTOP
    LTEXT "Co&mmand ID:", -1, 5, 32, 55, 12
    COMBOBOX cmb2, 65, 30, 125, 200, CBS_AUTOHSCROLL | CBS_DROPDOWN | WS_BORDER | WS_VSCROLL | WS_TABSTOP
    PUSHBUTTON "&...", psh1, 190, 30, 15, 14
    AUTOCHECKBOX "&GRAYED", chx1, 5, 60, 60, 14
    AUTOCHECKBOX "&BITMAP", chx3, 135, 60, 60, 14
    AUTOCHECKBOX "&OWNERDRAW", chx4, 5, 80, 65, 14
    AUTOCHECKBOX "&CHECKED", chx5, 75, 80, 60, 14
    AUTOCHECKBOX "SE&PARATOR", chx6, 140, 80, 60, 14
    AUTOCHECKBOX "MENU&BARBREAK", chx7, 5, 100, 75, 14
    AUTOCHECKBOX "MENUB&REAK", chx8, 85, 100, 70, 14
    AUTOCHECKBOX "&DEFAULT", chx9, 5, 120, 60, 14
    AUTOCHECKBOX "&HILITE", chx10, 70, 120, 60, 14
    AUTOCHECKBOX "RADIOCHEC&K", chx11, 135, 120, 60, 14
    AUTOCHECKBOX "RIGH&TORDER", chx12, 5, 139, 60, 14
    AUTOCHECKBOX "RIGHT&JUSTIFY", chx13, 70, 140, 70, 14
    LTEXT "He&lp ID:", -1, 5, 162, 45, 12
    COMBOBOX cmb3, 55, 160, 100, 300, CBS_AUTOHSCROLL | CBS_DROPDOWN | WS_BORDER | WS_VSCROLL | WS_TABSTOP
    DEFPUSHBUTTON "OK", IDOK, 80, 180, 60, 14
    PUSHBUTTON "Cancel", IDCANCEL, 145, 180, 60, 14
}

IDD_MODIFYMITEM DIALOG 0, 0, 210, 200
CAPTION "Modify Menu Item"
STYLE DS_MODALFRAME | WS_POPUPWINDOW | WS_CAPTION
FONT 9, "MS Shell Dlg"
{
    LTEXT "C&aption:", -1, 5, 7, 55, 12
    COMBOBOX cmb1, 65, 6, 140, 200, CBS_AUTOHSCROLL | CBS_DROPDOWN | WS_BORDER | WS_VSCROLL | WS_TABSTOP
    LTEXT "Co&mmand ID:", -1, 5, 32, 55, 12
    COMBOBOX cmb2, 65, 30, 125, 200, CBS_AUTOHSCROLL | CBS_DROPDOWN | WS_BORDER | WS_VSCROLL | WS_TABSTOP
    PUSHBUTTON "&...", psh1, 190, 30, 15, 14
    AUTOCHECKBOX "&GRAYED", chx1, 5, 60, 60, 14
    AUTOCHECKBOX "&BITMAP", chx3, 135, 60, 60, 14
    AUTOCHECKBOX "&OWNERDRAW", chx4, 5, 80, 65, 14
    AUTOCHECKBOX "&CHECKED", chx5, 75, 80, 60, 14
    AUTOCHECKBOX "SE&PARATOR", chx6, 140, 80, 60, 14
    AUTOCHECKBOX "MENU&BARBREAK", chx7, 5, 100, 75, 14
    AUTOCHECKBOX "MENUB&REAK", chx8, 85, 100, 70, 14
    AUTOCHECKBOX "&DEFAULT", chx9, 5, 120, 60, 14
    AUTOCHECKBOX "&HILITE", chx10, 70, 120, 60, 14
    AUTOCHECKBOX "RADIOCHEC&K", chx11, 135, 120, 60, 14
    AUTOCHECKBOX "RIGH&TORDER", chx12, 5, 139, 60, 14
    AUTOCHECKBOX "RIGHT&JUSTIFY", chx13, 70, 140, 70, 14
    LTEXT "He&lp ID:", -1, 5, 162, 45, 12
    COMBOBOX cmb3, 55, 160, 100, 300, CBS_AUTOHSCROLL | CBS_DROPDOWN | WS_BORDER | WS_VSCROLL | WS_TABSTOP
    DEFPUSHBUTTON "OK", IDOK, 80, 180, 60, 14
    PUSHBUTTON "Cancel", IDCANCEL, 145, 180, 60, 14
}

IDD_EDITMENU DIALOG 0, 0, 325, 160
CAPTION "Edit Menu Resource"
STYLE WS_POPUPWINDOW | WS_CAPTION | WS_THICKFRAME
FONT 9, "MS Shell Dlg"
{
    LTEXT "Menu Re&souce:", -1, 5, 7, 85, 12
    CONTROL "", lst1, "SysListView32", LVS_NOSORTHEADER | LVS_AUTOARRANGE | LVS_NOLABELWRAP | LVS_SHOWSELALWAYS | LVS_SINGLESEL | LVS_REPORT | WS_BORDER | WS_VSCROLL | WS_HSCROLL | WS_TABSTOP, 5, 20, 315, 115
    PUSHBUTTON "&Add...", psh1, 95, 3, 50, 14
    PUSHBUTTON "&Modify...", psh2, 150, 3, 50, 14
    PUSHBUTTON "Dele&te", psh3, 205, 3, 50, 14
    PUSHBUTTON "&Up", psh4, 5, 140, 40, 14
    PUSHBUTTON "&Down", psh5, 50, 140, 40, 14
    PUSHBUTTON "&Left", psh6, 95, 140, 40, 14
    PUSHBUTTON "&Right", psh7, 140, 140, 41, 14
    AUTOCHECKBOX "E&xtended", chx1, 260, 3, 60, 14
    DEFPUSHBUTTON "OK", IDOK, 195, 140, 60, 14
    PUSHBUTTON "Cancel", IDCANCEL, 260, 140, 60, 14
}

IDD_DLGPROP DIALOG 0, 0, 235, 315
CAPTION "Properties for Dialog"
STYLE DS_MODALFRAME | WS_POPUPWINDOW | WS_CAPTION
FONT 9, "MS Shell Dlg"
{
    LTEXT "C&aption:", -1, 5, 7, 85, 11
    COMBOBOX cmb1, 5, 20, 225, 300, CBS_HASSTRINGS | CBS_AUTOHSCROLL | CBS_DROPDOWN | WS_BORDER | WS_VSCROLL | WS_TABSTOP
    AUTOCHECKBOX "E&xtended Dialog", chx1, 100, 5, 86, 14
    LTEXT "&Left:", -1, 5, 40, 33, 10
    EDITTEXT edt1, 5, 53, 30, 14, ES_NUMBER | ES_RIGHT
    CONTROL "", scr1, "msctls_updown32", UDS_NOTHOUSANDS | UDS_ARROWKEYS | UDS_AUTOBUDDY | UDS_ALIGNRIGHT | UDS_SETBUDDYINT, 23, 53, 12, 20
    LTEXT "T&op:", -1, 50, 40, 33, 10
    EDITTEXT edt2, 50, 53, 30, 14, ES_NUMBER | ES_RIGHT
    CONTROL "", scr2, "msctls_updown32", UDS_NOTHOUSANDS | UDS_ARROWKEYS | UDS_AUTOBUDDY | UDS_ALIGNRIGHT | UDS_SETBUDDYINT, 53, 53, 12, 20
    LTEXT "&Width:", -1, 95, 40, 33, 10
    EDITTEXT edt3, 95, 53, 30, 14, ES_NUMBER | ES_RIGHT
    CONTROL "", scr3, "msctls_updown32", UDS_NOTHOUSANDS | UDS_ARROWKEYS | UDS_AUTOBUDDY | UDS_ALIGNRIGHT | UDS_SETBUDDYINT, 129, 56, 12, 20
    LTEXT "&Height:", -1, 142, 40, 33, 10
    EDITTEXT edt4, 142, 53, 30, 14, ES_NUMBER | ES_RIGHT
    CONTROL "", scr4, "msctls_updown32", UDS_NOTHOUSANDS | UDS_ARROWKEYS | UDS_AUTOBUDDY | UDS_ALIGNRIGHT | UDS_SETBUDDYINT, 162, 53, 12, 20
    LTEXT "Cla&ss Name:", -1, 5, 73, 85, 11
    COMBOBOX cmb2, 5, 88, 115, 200, CBS_HASSTRINGS | CBS_AUTOHSCROLL | CBS_DROPDOWN | WS_BORDER | WS_VSCROLL | WS_TABSTOP
    LTEXT "Hel&p ID:", -1, 125, 73, 64, 11
    COMBOBOX cmb3, 125, 88, 65, 200, CBS_HASSTRINGS | CBS_AUTOHSCROLL | CBS_DROPDOWN | WS_BORDER | WS_VSCROLL | WS_TABSTOP
    LTEXT "&Font Name:", -1, 5, 105, 80, 11
    COMBOBOX cmb4, 6, 118, 100, 200, CBS_HASSTRINGS | CBS_SORT | CBS_AUTOHSCROLL | CBS_DROPDOWN | WS_BORDER | WS_VSCROLL | WS_TABSTOP
    LTEXT "Si&ze:", -1, 110, 105, 38, 12
    EDITTEXT edt5, 110, 118, 25, 14, ES_NUMBER
    AUTOCHECKBOX "&B", chx2, 140, 118, 20, 14
    AUTOCHECKBOX "&I", chx3, 165, 118, 20, 14
    LTEXT "Cha&rSet:", -1, 5, 138, 80, 11
    COMBOBOX cmb5, 5, 148, 100, 100, CBS_AUTOHSCROLL | CBS_DROPDOWNLIST | WS_VSCROLL | WS_TABSTOP
    LTEXT "&Menu Name:", -1, 110, 138, 55, 11
    COMBOBOX cmb6, 110, 148, 99, 300, CBS_HASSTRINGS | CBS_AUTOHSCROLL | CBS_DROPDOWN | WS_BORDER | WS_VSCROLL | WS_TABSTOP
    LTEXT "S&tyle:", -1, 5, 168, 45, 11
    RTEXT "0x", -1, 52, 169, 10, 11
    EDITTEXT edt6, 67, 165, 45, 14, ES_AUTOHSCROLL
    LISTBOX lst1, 5, 183, 110, 110, LBS_DISABLENOSCROLL | LBS_NOINTEGRALHEIGHT | LBS_HASSTRINGS | LBS_MULTIPLESEL | WS_VSCROLL | WS_HSCROLL | WS_TABSTOP
    LTEXT "&ExStyle:", -1, 120, 168, 48, 11
    RTEXT "0x", -1, 170, 169, 10, 11
    EDITTEXT edt7, 185, 165, 45, 14, ES_AUTOHSCROLL
    LISTBOX lst2, 120, 183, 110, 110, LBS_DISABLENOSCROLL | LBS_NOINTEGRALHEIGHT | LBS_HASSTRINGS | LBS_MULTIPLESEL | WS_VSCROLL | WS_HSCROLL | WS_TABSTOP
    DEFPUSHBUTTON "OK", IDOK, 106, 298, 60, 14
    PUSHBUTTON "Cancel", IDCANCEL, 171, 298, 60, 14
}

IDD_CTRLPROP DIALOG 0, 0, 235, 330
CAPTION "Properties for Control"
STYLE DS_MODALFRAME | WS_POPUPWINDOW | WS_CAPTION
FONT 9, "MS Shell Dlg"
{
    LTEXT "Predef. &Ctrl:", -1, 5, 7, 68, 12
    COMBOBOX cmb1, 75, 5, 120, 55, CBS_HASSTRINGS | CBS_AUTOHSCROLL | CBS_DROPDOWN | WS_BORDER | WS_VSCROLL | WS_TABSTOP
    CONTROL "", ctl1, "ToolbarWindow32", TBSTYLE_FLAT | TBSTYLE_WRAPABLE | TBSTYLE_TOOLTIPS | CCS_NODIVIDER | CCS_NORESIZE, 5, 22, 185, 30
    LTEXT "C&aption:", -1, 5, 55, 75, 12
    COMBOBOX cmb2, 5, 65, 195, 300, CBS_HASSTRINGS | CBS_AUTOHSCROLL | CBS_DROPDOWN | WS_BORDER | WS_VSCROLL | WS_TABSTOP
    PUSHBUTTON "&OLE...", psh2, 205, 65, 25, 14
    LTEXT "&Left:", -1, 5, 85, 33, 11
    EDITTEXT edt1, 5, 99, 25, 14, ES_NUMBER | ES_RIGHT
    CONTROL "", scr1, "msctls_updown32", UDS_NOTHOUSANDS | UDS_ARROWKEYS | UDS_AUTOBUDDY | UDS_ALIGNRIGHT | UDS_SETBUDDYINT, 20, 99, 12, 20
    LTEXT "T&op:", -1, 40, 85, 33, 11
    EDITTEXT edt2, 40, 99, 25, 14, ES_NUMBER | ES_RIGHT
    CONTROL "", scr2, "msctls_updown32", UDS_NOTHOUSANDS | UDS_ARROWKEYS | UDS_AUTOBUDDY | UDS_ALIGNRIGHT | UDS_SETBUDDYINT, 55, 99, 12, 20
    LTEXT "&Width:", -1, 75, 85, 33, 11
    EDITTEXT edt3, 75, 99, 25, 14, ES_NUMBER | ES_RIGHT
    CONTROL "", scr3, "msctls_updown32", UDS_NOTHOUSANDS | UDS_ARROWKEYS | UDS_AUTOBUDDY | UDS_ALIGNRIGHT | UDS_SETBUDDYINT, 90, 99, 12, 20
    LTEXT "&Height:", -1, 111, 85, 33, 11
    EDITTEXT edt4, 110, 99, 25, 14, ES_NUMBER | ES_RIGHT
    CONTROL "", scr4, "msctls_updown32", UDS_NOTHOUSANDS | UDS_ARROWKEYS | UDS_AUTOBUDDY | UDS_ALIGNRIGHT | UDS_SETBUDDYINT, 125, 99, 12, 20
    LTEXT "&ID:", -1, 150, 85, 70, 12
    COMBOBOX cmb3, 150, 99, 80, 300, CBS_HASSTRINGS | CBS_AUTOHSCROLL | CBS_DROPDOWN | WS_BORDER | WS_VSCROLL | WS_TABSTOP
    LTEXT "Window Cla&ss Name:", -1, 5, 119, 100, 12
    COMBOBOX cmb4, 5, 133, 115, 200, CBS_HASSTRINGS | CBS_AUTOHSCROLL | CBS_DROPDOWN | WS_BORDER | WS_VSCROLL | WS_TABSTOP
    LTEXT "Hel&p ID:", -1, 125, 119, 70, 12
    COMBOBOX cmb5, 125, 133, 65, 200, CBS_HASSTRINGS | CBS_AUTOHSCROLL | CBS_DROPDOWN | WS_BORDER | WS_VSCROLL | WS_TABSTOP
    LTEXT "S&tyle:", -1, 5, 153, 45, 12
    RTEXT "0x", -1, 54, 153, 10, 12
    EDITTEXT edt6, 70, 151, 45, 14, ES_AUTOHSCROLL
    LISTBOX lst1, 5, 167, 110, 120, LBS_DISABLENOSCROLL | LBS_NOINTEGRALHEIGHT | LBS_HASSTRINGS | LBS_MULTIPLESEL | WS_VSCROLL | WS_HSCROLL | WS_TABSTOP
    LTEXT "&ExStyle:", -1, 120, 153, 50, 12
    RTEXT "0x", -1, 172, 153, 10, 12
    EDITTEXT edt7, 185, 151, 45, 14, ES_AUTOHSCROLL
    LISTBOX lst2, 120, 167, 110, 120, LBS_DISABLENOSCROLL | LBS_NOINTEGRALHEIGHT | LBS_HASSTRINGS | LBS_MULTIPLESEL | WS_VSCROLL | WS_HSCROLL | WS_TABSTOP
    DEFPUSHBUTTON "OK", IDOK, 170, 293, 60, 14
    PUSHBUTTON "Cancel", IDCANCEL, 170, 309, 60, 14
    PUSHBUTTON "&Data...", psh1, 5, 293, 90, 14
    PUSHBUTTON "The string l&ist...", psh3, 5, 309, 90, 14
}

IDD_ADDCTRL DIALOG 0, 0, 235, 330
CAPTION "Add Control"
STYLE DS_MODALFRAME | WS_POPUPWINDOW | WS_CAPTION
FONT 9, "MS Shell Dlg"
{
    LTEXT "Predef. &Ctrl:", -1, 5, 7, 68, 12
    COMBOBOX cmb1, 75, 5, 120, 55, CBS_HASSTRINGS | CBS_AUTOHSCROLL | CBS_DROPDOWN | WS_BORDER | WS_VSCROLL | WS_TABSTOP
    CONTROL "", ctl1, "ToolbarWindow32", TBSTYLE_FLAT | TBSTYLE_WRAPABLE | TBSTYLE_TOOLTIPS | CCS_NODIVIDER | CCS_NORESIZE, 5, 22, 185, 30
    LTEXT "C&aption:", -1, 5, 55, 75, 12
    COMBOBOX cmb2, 5, 65, 195, 300, CBS_HASSTRINGS | CBS_AUTOHSCROLL | CBS_DROPDOWN | WS_BORDER | WS_VSCROLL | WS_TABSTOP
    PUSHBUTTON "&OLE...", psh2, 205, 65, 25, 14
    LTEXT "&Left:", -1, 5, 85, 33, 11
    EDITTEXT edt1, 5, 99, 25, 14, ES_NUMBER | ES_RIGHT
    CONTROL "", scr1, "msctls_updown32", UDS_NOTHOUSANDS | UDS_ARROWKEYS | UDS_AUTOBUDDY | UDS_ALIGNRIGHT | UDS_SETBUDDYINT, 20, 99, 12, 20
    LTEXT "T&op:", -1, 40, 85, 33, 11
    EDITTEXT edt2, 40, 99, 25, 14, ES_NUMBER | ES_RIGHT
    CONTROL "", scr2, "msctls_updown32", UDS_NOTHOUSANDS | UDS_ARROWKEYS | UDS_AUTOBUDDY | UDS_ALIGNRIGHT | UDS_SETBUDDYINT, 55, 99, 12, 20
    LTEXT "&Width:", -1, 75, 85, 33, 11
    EDITTEXT edt3, 75, 99, 25, 14, ES_NUMBER | ES_RIGHT
    CONTROL "", scr3, "msctls_updown32", UDS_NOTHOUSANDS | UDS_ARROWKEYS | UDS_AUTOBUDDY | UDS_ALIGNRIGHT | UDS_SETBUDDYINT, 90, 99, 12, 20
    LTEXT "&Height:", -1, 111, 85, 33, 11
    EDITTEXT edt4, 110, 99, 25, 14, ES_NUMBER | ES_RIGHT
    CONTROL "", scr4, "msctls_updown32", UDS_NOTHOUSANDS | UDS_ARROWKEYS | UDS_AUTOBUDDY | UDS_ALIGNRIGHT | UDS_SETBUDDYINT, 125, 99, 12, 20
    LTEXT "&ID:", -1, 150, 85, 70, 12
    COMBOBOX cmb3, 150, 99, 80, 300, CBS_HASSTRINGS | CBS_AUTOHSCROLL | CBS_DROPDOWN | WS_BORDER | WS_VSCROLL | WS_TABSTOP
    LTEXT "Window Cla&ss Name:", -1, 5, 119, 100, 12
    COMBOBOX cmb4, 5, 133, 115, 200, CBS_HASSTRINGS | CBS_AUTOHSCROLL | CBS_DROPDOWN | WS_BORDER | WS_VSCROLL | WS_TABSTOP
    LTEXT "Hel&p ID:", -1, 125, 119, 70, 12
    COMBOBOX cmb5, 125, 133, 65, 200, CBS_HASSTRINGS | CBS_AUTOHSCROLL | CBS_DROPDOWN | WS_BORDER | WS_VSCROLL | WS_TABSTOP
    LTEXT "S&tyle:", -1, 5, 153, 45, 12
    RTEXT "0x", -1, 54, 153, 10, 12
    EDITTEXT edt6, 70, 151, 45, 14, ES_AUTOHSCROLL
    LISTBOX lst1, 5, 167, 110, 120, LBS_DISABLENOSCROLL | LBS_NOINTEGRALHEIGHT | LBS_HASSTRINGS | LBS_MULTIPLESEL | WS_VSCROLL | WS_HSCROLL | WS_TABSTOP
    LTEXT "&ExStyle:", -1, 120, 153, 50, 12
    RTEXT "0x", -1, 172, 153, 10, 12
    EDITTEXT edt7, 185, 151, 45, 14, ES_AUTOHSCROLL
    LISTBOX lst2, 120, 167, 110, 120, LBS_DISABLENOSCROLL | LBS_NOINTEGRALHEIGHT | LBS_HASSTRINGS | LBS_MULTIPLESEL | WS_VSCROLL | WS_HSCROLL | WS_TABSTOP
    DEFPUSHBUTTON "OK", IDOK, 170, 293, 60, 14
    PUSHBUTTON "Cancel", IDCANCEL, 170, 309, 60, 14
    PUSHBUTTON "&Data...", psh1, 5, 293, 90, 14
    PUSHBUTTON "The string l&ist...", psh3, 5, 309, 90, 14
}

IDD_IDASSOC DIALOG 0, 0, 200, 220
CAPTION "ID Association"
STYLE DS_MODALFRAME | WS_POPUPWINDOW | WS_CAPTION
FONT 9, "MS Shell Dlg"
{
    LTEXT "ID &Assocation:", -1, 5, 5, 116, 12
    CONTROL "", lst1, "SysListView32", LVS_SHOWSELALWAYS | LVS_SINGLESEL | LVS_REPORT | WS_BORDER | WS_TABSTOP, 5, 20, 190, 150
    PUSHBUTTON "&Reset All", psh2, 5, 175, 85, 14
    PUSHBUTTON "&Modify", psh1, 135, 175, 60, 14
    DEFPUSHBUTTON "OK", IDOK, 70, 200, 60, 14
    PUSHBUTTON "Cancel", IDCANCEL, 135, 200, 60, 14
}

IDD_MODIFYASSOC DIALOG 0, 0, 165, 68
CAPTION "Modify ID Association"
STYLE DS_MODALFRAME | WS_POPUPWINDOW | WS_CAPTION
FONT 9, "MS Shell Dlg"
{
    RTEXT "&Type of ID:", -1, 5, 7, 65, 12
    EDITTEXT edt1, 80, 5, 80, 14, WS_DISABLED
    RTEXT "&Prefix of ID:", -1, 5, 32, 65, 12
    EDITTEXT edt2, 80, 28, 80, 14, ES_AUTOHSCROLL
    DEFPUSHBUTTON "OK", IDOK, 35, 50, 60, 14
    PUSHBUTTON "Cancel", IDCANCEL, 100, 50, 60, 14
}

IDD_IDLIST DIALOG 0, 0, 200, 300
CAPTION "List of Resource IDs"
STYLE WS_OVERLAPPEDWINDOW
EXSTYLE WS_EX_TOOLWINDOW
FONT 9, "MS Shell Dlg"
{
    COMBOBOX cmb1, 0, 0, 200, 300, CBS_HASSTRINGS | CBS_SORT | CBS_OWNERDRAWFIXED | CBS_DROPDOWNLIST | WS_VSCROLL | WS_TABSTOP
    CONTROL "", lst1, "SysListView32", LVS_REPORT | WS_BORDER | WS_VSCROLL | WS_HSCROLL | WS_TABSTOP, 0, 15, 200, 285
}

IDD_CONFIG DIALOG 0, 0, 210, 285
CAPTION "Configuration"
STYLE DS_MODALFRAME | WS_POPUPWINDOW | WS_CAPTION
FONT 9, "MS Shell Dlg"
{
    AUTOCHECKBOX "Show &full file path on title bar", chx1, 5, 5, 200, 14
    AUTOCHECKBOX "Don't use ID &macros", chx2, 5, 25, 200, 14
    AUTOCHECKBOX "Resume previous window &position", chx3, 5, 45, 200, 14
    AUTOCHECKBOX "Automatically load nearby ""&resource.h""", chx4, 5, 65, 200, 14
    AUTOCHECKBOX "Automatically show the &list of resource IDs", chx5, 5, 85, 200, 14
    AUTOCHECKBOX "Show &dots on dialog edit", chx6, 5, 105, 200, 14
    RTEXT "Height of Combo&Box:", -1, 10, 127, 75, 12
    EDITTEXT edt1, 90, 125, 34, 14, ES_NUMBER | ES_RIGHT
    CONTROL "", scr1, "msctls_updown32", UDS_NOTHOUSANDS | UDS_ARROWKEYS | UDS_AUTOBUDDY | UDS_ALIGNRIGHT | UDS_SETBUDDYINT, 129, 49, 12, 20
    AUTOCHECKBOX "&Word wrapping", chx9, 135, 125, 70, 14
    AUTOCHECKBOX "Ask ""&resource.h""'s update", chx7, 5, 145, 200, 14
    AUTOCHECKBOX "Compress EXE by &UPX on saving it", chx8, 5, 165, 200, 14
    PUSHBUTTON "&Fonts...", psh4, 5, 185, 200, 14
    PUSHBUTTON "Predefined &Macros...", psh1, 5, 205, 93, 14
    PUSHBUTTON "Set Pa&ths...", psh2, 107, 205, 98, 14
    RTEXT "Name of &OLE controls:", -1, 5, 227, 80, 12
    COMBOBOX cmb1, 90, 225, 75, 300, CBS_HASSTRINGS | CBS_AUTOHSCROLL | CBS_DROPDOWN | WS_VSCROLL | WS_TABSTOP
    AUTOCHECKBOX "Create &backup", chx10, 5, 245, 75, 15
    RTEXT "Backup Suffix:", -1, 90, 245, 60, 15
    COMBOBOX cmb2, 158, 244, 45, 300, CBS_HASSTRINGS | CBS_AUTOHSCROLL | CBS_DROPDOWN | WS_VSCROLL | WS_TABSTOP
    DEFPUSHBUTTON "OK", IDOK, 100, 265, 50, 14
    PUSHBUTTON "Cancel", IDCANCEL, 155, 265, 50, 14
    PUSHBUTTON "Re&set All", psh3, 5, 265, 75, 14
}

IDD_ADDRESID DIALOG 0, 0, 165, 90
CAPTION "Add Resource ID"
STYLE DS_MODALFRAME | WS_POPUPWINDOW | WS_CAPTION
FONT 9, "MS Shell Dlg"
{
    RTEXT "&Type of ID:", -1, 10, 7, 50, 14
    COMBOBOX cmb1, 65, 5, 95, 300, CBS_AUTOHSCROLL | CBS_DROPDOWNLIST | WS_VSCROLL | WS_TABSTOP
    RTEXT "&Name of ID:", -1, 10, 27, 50, 14
    EDITTEXT edt1, 65, 25, 75, 14, ES_AUTOHSCROLL
    RTEXT "&Integer value:", -1, 10, 47, 50, 14
    EDITTEXT edt2, 65, 45, 48, 14, ES_AUTOHSCROLL
    CONTROL "", scr1, "msctls_updown32", UDS_NOTHOUSANDS | UDS_ARROWKEYS | UDS_AUTOBUDDY | UDS_ALIGNRIGHT | UDS_SETBUDDYINT, 129, 49, 12, 20
    PUSHBUTTON "&Auto", psh1, 115, 45, 45, 14
    DEFPUSHBUTTON "OK", IDOK, 20, 70, 60, 14
    PUSHBUTTON "Cancel", IDCANCEL, 85, 70, 60, 14
}

IDD_MODIFYRESID DIALOG 0, 0, 165, 90
CAPTION "Modify Resource ID"
STYLE DS_MODALFRAME | WS_POPUPWINDOW | WS_CAPTION
FONT 9, "MS Shell Dlg"
{
    RTEXT "&Name of ID:", -1, 10, 12, 50, 14, SS_REALSIZEIMAGE | NOT WS_GROUP
    EDITTEXT edt1, 65, 10, 95, 14, ES_AUTOHSCROLL
    RTEXT "&Type of ID:", -1, 10, 32, 50, 14
    EDITTEXT edt2, 65, 30, 95, 14, ES_READONLY
    RTEXT "&Integer value:", -1, 10, 52, 50, 14
    EDITTEXT edt3, 65, 50, 48, 14, ES_AUTOHSCROLL
    CONTROL "", scr1, "msctls_updown32", UDS_NOTHOUSANDS | UDS_ARROWKEYS | UDS_AUTOBUDDY | UDS_ALIGNRIGHT | UDS_SETBUDDYINT, 129, 49, 12, 20
    DEFPUSHBUTTON "OK", IDOK, 20, 70, 60, 14
    PUSHBUTTON "Cancel", IDCANCEL, 85, 70, 60, 14
}

IDD_ADVICERESH DIALOG 0, 0, 209, 184
CAPTION "Advice of modification of file ""resource.h"""
STYLE DS_MODALFRAME | WS_POPUPWINDOW | WS_CAPTION
FONT 9, "MS Shell Dlg"
{
    LTEXT "Please modify the file ""resource.h"" As Follows:", -1, 10, 10, 195, 20
    EDITTEXT edt1, 10, 30, 190, 130, ES_READONLY | ES_MULTILINE
    DEFPUSHBUTTON "OK", IDOK, 140, 165, 60, 14
    PUSHBUTTON "&Clear modification", psh1, 10, 165, 90, 14
}

IDD_CLONEINNEWNAME DIALOG 0, 0, 215, 75
CAPTION "Clone In New Name"
STYLE DS_MODALFRAME | WS_POPUPWINDOW | WS_CAPTION
FONT 9, "MS Shell Dlg"
{
    LTEXT "Resource &Type:", -1, 5, 7, 70, 12
    COMBOBOX cmb1, 75, 5, 135, 200, CBS_HASSTRINGS | CBS_AUTOHSCROLL | CBS_DROPDOWN | WS_DISABLED | WS_BORDER | WS_VSCROLL | WS_TABSTOP
    LTEXT "Resource &Name:", -1, 5, 32, 70, 12
    COMBOBOX cmb2, 75, 30, 120, 200, CBS_HASSTRINGS | CBS_AUTOHSCROLL | CBS_DROPDOWN | WS_BORDER | WS_VSCROLL | WS_TABSTOP
    PUSHBUTTON "&...", psh1, 195, 30, 15, 14
    DEFPUSHBUTTON "OK", IDOK, 35, 55, 60, 14
    PUSHBUTTON "Cancel", IDCANCEL, 115, 55, 60, 14
}

IDD_CLONEINNEWLANG DIALOG 0, 0, 215, 105
CAPTION "Clone In New Language"
STYLE DS_MODALFRAME | WS_POPUPWINDOW | WS_CAPTION
FONT 9, "MS Shell Dlg"
{
    LTEXT "Resource &Type:", -1, 5, 7, 70, 12
    COMBOBOX cmb1, 75, 5, 135, 200, CBS_HASSTRINGS | CBS_AUTOHSCROLL | CBS_DROPDOWN | WS_DISABLED | WS_BORDER | WS_VSCROLL | WS_TABSTOP
    LTEXT "Resource &Name:", -1, 5, 32, 70, 12
    COMBOBOX cmb2, 75, 30, 120, 200, CBS_HASSTRINGS | CBS_AUTOHSCROLL | CBS_DROPDOWN | WS_DISABLED | WS_BORDER | WS_VSCROLL | WS_TABSTOP
    LTEXT "Resource &Language:", -1, 5, 57, 70, 12
    COMBOBOX cmb3, 75, 55, 135, 200, CBS_HASSTRINGS | CBS_AUTOHSCROLL | CBS_DROPDOWN | WS_BORDER | WS_VSCROLL | WS_TABSTOP
    DEFPUSHBUTTON "OK", IDOK, 35, 85, 60, 14
    PUSHBUTTON "Cancel", IDCANCEL, 115, 85, 60, 14
}

IDD_ITEMSEARCH DIALOG 0, 0, 171, 135
CAPTION "Search"
STYLE WS_POPUPWINDOW | WS_CAPTION
FONT 9, "MS Shell Dlg"
{
    LTEXT "&String to search:", -1, 4, 10, 100, 14
    EDITTEXT edt1, 5, 25, 160, 15, ES_AUTOHSCROLL
    AUTOCHECKBOX "&Case sensitive", chx1, 5, 45, 120, 18
    GROUPBOX "Direction", -1, 5, 65, 160, 42
    AUTORADIOBUTTON "&Upward", rad1, 15, 80, 60, 14, WS_TABSTOP
    AUTORADIOBUTTON "&Downward", rad2, 90, 80, 60, 14, WS_TABSTOP
    DEFPUSHBUTTON "&Find", IDOK, 40, 115, 60, 14
    PUSHBUTTON "Cancel", IDCANCEL, 105, 115, 60, 14
}

IDD_VERSIONINFO DIALOG 0, 0, 174, 150
CAPTION "About RisohEditor"
STYLE DS_MODALFRAME | WS_POPUPWINDOW | WS_CAPTION
FONT 12, "MS Shell Dlg"
{
    ICON IDI_MAIN, -1, 5, 5, 0, 0
    LTEXT "...", stc1, 30, 5, 140, 50
    CTEXT "https://katahiromz.web.fc2.com", stc2, 5, 60, 165, 12, SS_CENTERIMAGE | SS_NOTIFY | NOT WS_GROUP
    CONTROL "...", edt1, "EDIT", ES_READONLY | ES_AUTOHSCROLL | ES_AUTOVSCROLL | ES_MULTILINE | WS_BORDER | WS_VSCROLL | WS_HSCROLL, 5, 75, 165, 50
    DEFPUSHBUTTON "OK", IDOK, 55, 130, 60, 14
}

IDD_ADDMSG DIALOG 0, 0, 255, 105
CAPTION "Add Message Entry"
STYLE DS_MODALFRAME | WS_POPUPWINDOW | WS_CAPTION
FONT 9, "MS Shell Dlg"
{
    LTEXT "Message &ID:", -1, 5, 7, 50, 12
    COMBOBOX cmb1, 65, 5, 134, 200, CBS_HASSTRINGS | CBS_AUTOHSCROLL | CBS_DROPDOWN | WS_BORDER | WS_VSCROLL | WS_TABSTOP
    PUSHBUTTON "&...", psh1, 200, 5, 15, 14
    LTEXT "Message &Value:", -1, 5, 27, 80, 12
    EDITTEXT edt1, 5, 40, 245, 35, ES_WANTRETURN | ES_AUTOHSCROLL | ES_AUTOVSCROLL | ES_MULTILINE
    DEFPUSHBUTTON "OK", IDOK, 125, 85, 60, 14
    PUSHBUTTON "Cancel", IDCANCEL, 190, 85, 60, 14
}

IDD_MODIFYMSG DIALOG 0, 0, 255, 105
CAPTION "Modify Message Entry"
STYLE DS_MODALFRAME | WS_POPUPWINDOW | WS_CAPTION
FONT 9, "MS Shell Dlg"
{
    LTEXT "Message &ID:", -1, 5, 7, 50, 12
    COMBOBOX cmb1, 65, 5, 134, 200, CBS_HASSTRINGS | CBS_AUTOHSCROLL | CBS_DROPDOWN | WS_DISABLED | WS_BORDER | WS_VSCROLL | WS_TABSTOP
    LTEXT "Message &Value:", -1, 5, 27, 80, 12
    EDITTEXT edt1, 5, 40, 245, 35, ES_WANTRETURN | ES_AUTOHSCROLL | ES_AUTOVSCROLL | ES_MULTILINE
    DEFPUSHBUTTON "OK", IDOK, 125, 85, 60, 14
    PUSHBUTTON "Cancel", IDCANCEL, 190, 85, 60, 14
}

IDD_MESSAGES DIALOG 0, 0, 325, 160
CAPTION "Message Table"
STYLE WS_POPUPWINDOW | WS_CAPTION | WS_THICKFRAME
FONT 9, "MS Shell Dlg"
{
    LTEXT "Message &Entries:", -1, 5, 7, 80, 12
    CONTROL "", lst1, "SysListView32", LVS_NOSORTHEADER | LVS_AUTOARRANGE | LVS_NOLABELWRAP | LVS_SHOWSELALWAYS | LVS_SINGLESEL | LVS_REPORT | WS_BORDER | WS_VSCROLL | WS_HSCROLL | WS_TABSTOP, 5, 20, 315, 115
    PUSHBUTTON "&Add...", psh1, 130, 3, 60, 14
    PUSHBUTTON "&Modify...", psh2, 195, 3, 60, 14
    PUSHBUTTON "&Delete", psh3, 260, 3, 60, 14
    DEFPUSHBUTTON "OK", IDOK, 195, 140, 60, 14
    PUSHBUTTON "Cancel", IDCANCEL, 260, 140, 60, 14
    PUSHBUTTON "Delete A&ll", psh4, 5, 140, 75, 14
}

IDD_FONTS DIALOG 0, 0, 195, 110
CAPTION "Font Settings"
STYLE DS_MODALFRAME | WS_POPUPWINDOW | WS_CAPTION
FONT 9, "MS Shell Dlg"
{
    RTEXT "&Source:", -1, 5, 5, 55, 15, SS_CENTERIMAGE | NOT WS_GROUP
    EDITTEXT edt1, 65, 5, 100, 14, ES_READONLY | ES_AUTOHSCROLL
    PUSHBUTTON "...", psh1, 170, 5, 19, 14
    RTEXT "&Binary:", -1, 5, 25, 55, 15, SS_CENTERIMAGE | NOT WS_GROUP
    EDITTEXT edt2, 65, 25, 100, 14, ES_READONLY | ES_AUTOHSCROLL
    PUSHBUTTON "...", psh2, 170, 25, 19, 14
    GROUPBOX "Preview", -1, 5, 45, 185, 39
    CTEXT "Source", stc1, 15, 55, 80, 25, SS_CENTERIMAGE | NOT WS_GROUP
    CTEXT "Binary", stc2, 100, 55, 85, 25, SS_CENTERIMAGE | NOT WS_GROUP
    DEFPUSHBUTTON "OK", IDOK, 65, 90, 60, 14
    PUSHBUTTON "Cancel", IDCANCEL, 130, 90, 60, 14
}

IDD_MACROS DIALOG 0, 0, 265, 165
CAPTION "Predefined Macros"
STYLE WS_POPUPWINDOW | WS_CAPTION | WS_THICKFRAME
FONT 9, "MS Shell Dlg"
{
    LTEXT "Predefined &Macros:", -1, 5, 0, 100, 15, SS_CENTERIMAGE | NOT WS_GROUP
    CONTROL "", lst1, "SysListView32", LVS_EDITLABELS | LVS_SHOWSELALWAYS | LVS_SINGLESEL | LVS_REPORT | WS_BORDER | WS_TABSTOP, 5, 15, 190, 125
    PUSHBUTTON "&Add...", psh1, 200, 15, 60, 14
    PUSHBUTTON "&Edit...", psh2, 200, 35, 60, 14
    PUSHBUTTON "&Delete", psh3, 200, 55, 60, 14
    PUSHBUTTON "Delete A&ll", psh7, 200, 105, 60, 14
    DEFPUSHBUTTON "OK", IDOK, 135, 145, 60, 14
    PUSHBUTTON "Cancel", IDCANCEL, 200, 145, 60, 14
    PUSHBUTTON "&Reset All", psh6, 5, 145, 60, 14
}

IDD_ADDMACRO DIALOG 0, 0, 190, 80
CAPTION "Add Predefined Macro"
STYLE DS_MODALFRAME | WS_POPUPWINDOW | WS_CAPTION
FONT 9, "MS Shell Dlg"
{
    RTEXT "&Key:", -1, 5, 12, 60, 14
    COMBOBOX cmb1, 70, 10, 110, 200, CBS_DROPDOWN | WS_BORDER | WS_VSCROLL | WS_TABSTOP
    RTEXT "&Value:", -1, 5, 37, 60, 14
    COMBOBOX cmb2, 70, 35, 110, 300, CBS_DROPDOWN | WS_BORDER | WS_VSCROLL | WS_TABSTOP
    DEFPUSHBUTTON "OK", IDOK, 60, 60, 60, 14
    PUSHBUTTON "Cancel", IDCANCEL, 125, 60, 60, 14
}

IDD_EDITMACRO DIALOG 0, 0, 190, 80
CAPTION "Edit Predefined Macro"
STYLE DS_MODALFRAME | WS_POPUPWINDOW | WS_CAPTION
FONT 9, "MS Shell Dlg"
{
    RTEXT "&Key:", -1, 5, 12, 60, 14
    COMBOBOX cmb1, 70, 10, 110, 200, CBS_DROPDOWN | WS_DISABLED | WS_BORDER | WS_VSCROLL | WS_TABSTOP
    RTEXT "&Value:", -1, 5, 37, 60, 14
    COMBOBOX cmb2, 70, 35, 110, 300, CBS_DROPDOWN | WS_BORDER | WS_VSCROLL | WS_TABSTOP
    DEFPUSHBUTTON "OK", IDOK, 60, 60, 60, 14
    PUSHBUTTON "Cancel", IDCANCEL, 125, 60, 60, 14
}

IDD_CTRLDATA DIALOG 0, 0, 190, 130
CAPTION "Edit Control Data"
STYLE DS_MODALFRAME | WS_POPUPWINDOW | WS_CAPTION
FONT 9, "MS Shell Dlg"
{
    LTEXT "&Binary Data:", -1, 5, 2, 87, 12
    EDITTEXT edt1, 5, 15, 180, 60, ES_AUTOVSCROLL | ES_MULTILINE | WS_VSCROLL
    LTEXT "You can set the control data by space-separated 16-bit integers.", -1, 5, 80, 180, 25
    DEFPUSHBUTTON "OK", IDOK, 60, 110, 60, 14
    PUSHBUTTON "Cancel", IDCANCEL, 125, 110, 60, 14
}

IDD_PATHS DIALOG 0, 0, 295, 220
CAPTION "Set Paths"
STYLE WS_POPUPWINDOW | WS_CAPTION | WS_THICKFRAME
FONT 9, "MS Shell Dlg"
{
    LTEXT "&Include Directories:", -1, 5, 5, 102, 12
    LISTBOX lst1, 5, 20, 220, 105, LBS_NOINTEGRALHEIGHT | LBS_HASSTRINGS | LBS_SORT | WS_VSCROLL | WS_HSCROLL | WS_TABSTOP
    PUSHBUTTON "&Add...", psh1, 230, 20, 60, 14
    PUSHBUTTON "&Edit...", psh2, 230, 40, 60, 14
    PUSHBUTTON "&Delete", psh3, 230, 60, 60, 14
    PUSHBUTTON "&Up", psh4, 230, 80, 60, 14
    PUSHBUTTON "D&own", psh5, 230, 100, 60, 14
    PUSHBUTTON "Delete A&ll", psh6, 5, 130, 95, 14
    RTEXT "&windres.exe:", stc1, 5, 157, 55, 12
    COMBOBOX cmb1, 70, 155, 155, 300, CBS_HASSTRINGS | CBS_AUTOHSCROLL | CBS_DROPDOWN | WS_VSCROLL | WS_TABSTOP
    PUSHBUTTON "&Browse...", psh7, 230, 155, 60, 14
    RTEXT "&cpp.exe:", stc2, 5, 177, 55, 12
    COMBOBOX cmb2, 70, 175, 155, 300, CBS_HASSTRINGS | CBS_AUTOHSCROLL | CBS_DROPDOWN | WS_VSCROLL | WS_TABSTOP
    PUSHBUTTON "B&rowse...", psh8, 230, 175, 60, 14
    DEFPUSHBUTTON "OK", IDOK, 165, 200, 60, 14
    PUSHBUTTON "Cancel", IDCANCEL, 230, 200, 60, 14
    PUSHBUTTON "Re&set All", psh9, 5, 200, 95, 14
}

IDD_EXP_OPTIONS DIALOG 0, 0, 250, 225
CAPTION "Export Options"
STYLE DS_MODALFRAME | WS_POPUPWINDOW | WS_CAPTION
FONT 9, "MS Shell Dlg"
{
    ICON IDI_MAIN, -1, 5, 10, 0, 0
    LTEXT "Exporting a RC file will generate some related files. You can choose the following options:", -1, 35, 5, 210, 29
    AUTOCHECKBOX "Use Microsoft MESSAGE&TABLE", chx8, 5, 40, 240, 14
    AUTOCHECKBOX "Separate resource files by &language", chx1, 5, 60, 240, 14
    AUTOCHECKBOX "Use B&EGIN/END keywords", chx2, 5, 80, 240, 14
    AUTOCHECKBOX "Make language selectable by LANGUAGE_* macro", chx3, 5, 100, 240, 14
    AUTOCHECKBOX "Create &backup", chx4, 5, 120, 110, 14
    RTEXT "Backup-Suffix:", -1, 120, 122, 75, 12
    COMBOBOX cmb1, 200, 120, 45, 300, CBS_HASSTRINGS | CBS_AUTOHSCROLL | CBS_DROPDOWN | WS_VSCROLL | WS_TABSTOP
    AUTOCHECKBOX "Output redundant &comments", chx5, 5, 140, 240, 14
    AUTOCHECKBOX "Wrap the ma&nifest statements by #ifndef MSVC ... #endif", chx6, 5, 160, 240, 14
    AUTOCHECKBOX "Output RC files as &UTF-16", chx7, 5, 180, 240, 14
    DEFPUSHBUTTON "OK", IDOK, 120, 205, 60, 14
    PUSHBUTTON "Cancel", IDCANCEL, 185, 205, 60, 14
}

IDD_LANGS DIALOG 0, 0, 250, 235
CAPTION "Languages"
STYLE WS_POPUPWINDOW | WS_CAPTION | WS_THICKFRAME
FONT 9, "MS Shell Dlg"
{
    CONTROL "", lst1, "SysListView32", LVS_SHOWSELALWAYS | LVS_SINGLESEL | LVS_REPORT | WS_BORDER | WS_TABSTOP, 5, 5, 240, 179
    RTEXT "&Search:", stc1, 5, 192, 45, 12
    COMBOBOX cmb1, 55, 190, 85, 300, CBS_SORT | CBS_DROPDOWN | WS_VSCROLL | WS_TABSTOP
    EDITTEXT edt1, 4, 209, 240, 20, ES_AUTOHSCROLL | ES_AUTOVSCROLL | ES_MULTILINE
}

IDD_CHILD DIALOG 0, 0, 215, 135
CAPTION "Child Dialog"
STYLE WS_CHILD | WS_OVERLAPPEDWINDOW
FONT 9, "MS Shell Dlg"
{
    DEFPUSHBUTTON "OK", IDOK, 35, 115, 60, 14
    PUSHBUTTON "Cancel", IDCANCEL, 115, 115, 60, 14
}

IDD_DLGINITEDIT DIALOG 0, 0, 325, 165
CAPTION "Edit DLGINIT"
STYLE WS_POPUPWINDOW | WS_CAPTION | WS_THICKFRAME
FONT 9, "MS Shell Dlg"
{
    LTEXT "Message &Entries:", -1, 5, 7, 100, 12
    CONTROL "", lst1, "SysListView32", LVS_NOSORTHEADER | LVS_AUTOARRANGE | LVS_NOLABELWRAP | LVS_SHOWSELALWAYS | LVS_SINGLESEL | LVS_REPORT | WS_BORDER | WS_VSCROLL | WS_HSCROLL | WS_TABSTOP, 5, 20, 250, 120
    PUSHBUTTON "&Add...", psh1, 260, 20, 60, 14
    PUSHBUTTON "&Modify...", psh2, 260, 40, 60, 14
    PUSHBUTTON "&Delete", psh3, 260, 60, 60, 14
    PUSHBUTTON "&Up", psh4, 260, 100, 60, 14
    PUSHBUTTON "D&own", psh5, 260, 120, 60, 14
    DEFPUSHBUTTON "OK", IDOK, 195, 145, 60, 14
    PUSHBUTTON "Cancel", IDCANCEL, 260, 145, 60, 14
    PUSHBUTTON "Delete A&ll", psh6, 5, 145, 79, 14
}

IDD_ADDDLGINIT DIALOG 0, 0, 184, 137
CAPTION "Add DLGINIT data"
STYLE DS_MODALFRAME | WS_POPUPWINDOW | WS_CAPTION
FONT 9, "MS Shell Dlg"
{
    LTEXT "Control &ID:", -1, 5, 7, 56, 12
    COMBOBOX cmb1, 65, 5, 115, 300, CBS_HASSTRINGS | CBS_AUTOHSCROLL | CBS_DROPDOWN | WS_VSCROLL | WS_TABSTOP
    LTEXT "&Message:", -1, 5, 32, 55, 12
    COMBOBOX cmb2, 65, 30, 95, 300, CBS_HASSTRINGS | CBS_AUTOHSCROLL | CBS_DROPDOWN | WS_VSCROLL | WS_TABSTOP
    LTEXT "&String:", -1, 5, 52, 55, 12
    EDITTEXT edt1, 5, 65, 175, 50, ES_WANTRETURN | ES_MULTILINE | WS_VSCROLL | WS_HSCROLL
    DEFPUSHBUTTON "OK", IDOK, 55, 120, 60, 14
    PUSHBUTTON "Cancel", IDCANCEL, 120, 120, 60, 14
}

IDD_MODIFYDLGINIT DIALOG 0, 0, 184, 137
CAPTION "Modify DLGINIT data"
STYLE DS_MODALFRAME | WS_POPUPWINDOW | WS_CAPTION
FONT 9, "MS Shell Dlg"
{
    LTEXT "Control &ID:", -1, 5, 7, 56, 12
    COMBOBOX cmb1, 65, 5, 115, 300, CBS_HASSTRINGS | CBS_AUTOHSCROLL | CBS_DROPDOWN | WS_VSCROLL | WS_TABSTOP
    LTEXT "&Message:", -1, 5, 32, 55, 12
    COMBOBOX cmb2, 65, 30, 95, 300, CBS_HASSTRINGS | CBS_AUTOHSCROLL | CBS_DROPDOWN | WS_VSCROLL | WS_TABSTOP
    LTEXT "&String:", -1, 5, 52, 55, 12
    EDITTEXT edt1, 5, 65, 175, 50, ES_WANTRETURN | ES_MULTILINE | WS_VSCROLL | WS_HSCROLL
    DEFPUSHBUTTON "OK", IDOK, 55, 120, 60, 14
    PUSHBUTTON "Cancel", IDCANCEL, 120, 120, 60, 14
}

IDD_STRINGLIST DIALOG 0, 0, 205, 220
CAPTION "Control String List"
STYLE WS_POPUPWINDOW | WS_CAPTION | WS_THICKFRAME
FONT 9, "MS Shell Dlg"
{
    LTEXT "", stc1, 5, 5, 195, 70
    EDITTEXT edt1, 5, 80, 195, 115, ES_WANTRETURN | ES_MULTILINE | WS_VSCROLL | WS_HSCROLL
    DEFPUSHBUTTON "OK", IDOK, 75, 200, 60, 14
    PUSHBUTTON "Cancel", IDCANCEL, 140, 200, 60, 14
}

IDD_SAVE_OPTIONS DIALOG 0, 0, 250, 225
CAPTION "Save Options"
STYLE DS_MODALFRAME | WS_POPUPWINDOW | WS_CAPTION
FONT 9, "MS Shell Dlg"
{
    ICON IDI_MAIN, -1, 5, 10, 0, 0
    LTEXT "Saving a RC file will generate some related files. You can choose the following options:", -1, 35, 5, 210, 29
    AUTOCHECKBOX "Use Microsoft MESSAGE&TABLE", chx8, 5, 40, 240, 14
    AUTOCHECKBOX "Separate resource files by &language", chx1, 5, 60, 240, 14
    AUTOCHECKBOX "Use B&EGIN/END keywords", chx2, 5, 80, 240, 14
    AUTOCHECKBOX "Make language selectable by LANGUAGE_* macro", chx3, 5, 100, 240, 14
    AUTOCHECKBOX "Create &backup", chx4, 5, 120, 110, 14
    RTEXT "Backup Suffix:", -1, 120, 122, 75, 12
    COMBOBOX cmb1, 200, 120, 45, 300, CBS_HASSTRINGS | CBS_AUTOHSCROLL | CBS_DROPDOWN | WS_VSCROLL | WS_TABSTOP
    AUTOCHECKBOX "Output redundant &comments", chx5, 5, 140, 240, 14
    AUTOCHECKBOX "Wrap the ma&nifest statements by #ifndef MSVC ... #endif", chx6, 5, 160, 240, 14
    AUTOCHECKBOX "Output RC files as &UTF-16", chx7, 5, 180, 240, 14
    DEFPUSHBUTTON "OK", IDOK, 120, 205, 60, 14
    PUSHBUTTON "Cancel", IDCANCEL, 185, 205, 60, 14
}

IDD_ENCODING DIALOG 0, 0, 200, 170
CAPTION "Encoding of Resource Item"
STYLE DS_MODALFRAME | WS_POPUPWINDOW | WS_CAPTION
FONT 9, "MS Shell Dlg"
{
    CONTROL "", lst1, "SysListView32", LVS_SHOWSELALWAYS | LVS_SINGLESEL | LVS_REPORT | WS_BORDER, 5, 5, 190, 115
    PUSHBUTTON "&Add...", psh1, 5, 125, 60, 14
    PUSHBUTTON "&Modify...", psh2, 70, 125, 60, 14
    PUSHBUTTON "&Delete", psh3, 135, 125, 60, 14
    DEFPUSHBUTTON "OK", IDOK, 70, 150, 60, 14
    PUSHBUTTON "Cancel", IDCANCEL, 135, 150, 60, 14
    PUSHBUTTON "&Reset", psh5, 5, 149, 60, 14
}

IDD_ADDENC DIALOG 0, 0, 215, 80
CAPTION "Add Resource Encoding"
STYLE DS_MODALFRAME | WS_POPUPWINDOW | WS_CAPTION
FONT 9, "MS Shell Dlg"
{
    LTEXT "Resource &Type:", -1, 5, 7, 70, 12
    COMBOBOX cmb1, 75, 5, 135, 200, CBS_HASSTRINGS | CBS_AUTOHSCROLL | CBS_DROPDOWN | WS_BORDER | WS_VSCROLL | WS_TABSTOP
    LTEXT "&Encoding:", -1, 5, 30, 70, 12
    COMBOBOX cmb2, 75, 30, 85, 300, CBS_HASSTRINGS | CBS_AUTOHSCROLL | CBS_DROPDOWNLIST | WS_VSCROLL | WS_TABSTOP
    DEFPUSHBUTTON "OK", IDOK, 86, 60, 60, 14
    PUSHBUTTON "Cancel", IDCANCEL, 150, 60, 60, 14
}

IDD_MODIFYENC DIALOG 0, 0, 215, 80
CAPTION "Modify Resource Encoding"
STYLE DS_MODALFRAME | WS_POPUPWINDOW | WS_CAPTION
FONT 9, "MS Shell Dlg"
{
    LTEXT "Resource &Type:", -1, 5, 7, 70, 12
    COMBOBOX cmb1, 75, 5, 135, 200, CBS_HASSTRINGS | CBS_AUTOHSCROLL | CBS_DROPDOWN | WS_DISABLED | WS_BORDER | WS_VSCROLL | WS_TABSTOP
    LTEXT "&Encoding:", -1, 5, 30, 70, 12
    COMBOBOX cmb2, 75, 30, 85, 300, CBS_HASSTRINGS | CBS_AUTOHSCROLL | CBS_DROPDOWNLIST | WS_VSCROLL | WS_TABSTOP
    DEFPUSHBUTTON "OK", IDOK, 86, 60, 60, 14
    PUSHBUTTON "Cancel", IDCANCEL, 150, 60, 60, 14
}

IDD_CONSTANT DIALOG 0, 0, 205, 75
CAPTION "Query Constant"
STYLE DS_MODALFRAME | WS_POPUPWINDOW | WS_CAPTION
FONT 9, "MS Shell Dlg"
{
    LTEXT "Constant &Name:", -1, 5, 7, 80, 12
    COMBOBOX cmb1, 94, 7, 105, 300, CBS_HASSTRINGS | CBS_AUTOHSCROLL | CBS_DROPDOWN | WS_VSCROLL | WS_TABSTOP
    LTEXT "Constant &Value:", -1, 5, 32, 80, 12
    EDITTEXT edt2, 95, 30, 50, 14, ES_READONLY
    EDITTEXT edt3, 150, 30, 50, 14, ES_READONLY
    DEFPUSHBUTTON "OK", IDOK, 70, 55, 60, 14
}

IDD_EGA DIALOG 0, 0, 400, 225
CAPTION "Programming Language EGA"
STYLE WS_POPUPWINDOW | WS_CAPTION | WS_THICKFRAME
FONT 9, "MS Shell Dlg"
{
    GROUPBOX "EGA Console", grp1, 5, 5, 390, 195
    EDITTEXT edt1, 10, 20, 380, 170, ES_READONLY | ES_AUTOVSCROLL | ES_MULTILINE | WS_VSCROLL | NOT WS_TABSTOP
    RTEXT "EGA>", stc1, 10, 208, 20, 10
    EDITTEXT edt2, 35, 205, 300, 15, ES_WANTRETURN | ES_AUTOHSCROLL | ES_AUTOVSCROLL | ES_MULTILINE
    PUSHBUTTON "&Enter", IDOK, 345, 205, 50, 15
}

IDD_FONTSUBST DIALOG 0, 0, 185, 180
CAPTION "Dialog Font Substitutes"
STYLE DS_CENTER | DS_MODALFRAME | WS_POPUPWINDOW | WS_CAPTION
FONT 9, "MS Shell Dlg"
{
    LTEXT "Font #&1:", -1, 5, 7, 44, 12
    COMBOBOX cmb1, 55, 5, 125, 300, CBS_HASSTRINGS | CBS_AUTOHSCROLL | CBS_DROPDOWN | WS_VSCROLL | WS_TABSTOP
    ICON IDI_ARROW, -1, 30, 25, 0, 0
    COMBOBOX cmb2, 55, 30, 125, 300, CBS_HASSTRINGS | CBS_AUTOHSCROLL | CBS_DROPDOWN | WS_VSCROLL | WS_TABSTOP
    LTEXT "Font #&2:", -1, 5, 57, 44, 12
    COMBOBOX cmb3, 55, 55, 125, 300, CBS_HASSTRINGS | CBS_AUTOHSCROLL | CBS_DROPDOWN | WS_VSCROLL | WS_TABSTOP
    ICON IDI_ARROW, -1, 30, 75, 0, 0
    COMBOBOX cmb4, 55, 80, 125, 300, CBS_HASSTRINGS | CBS_AUTOHSCROLL | CBS_DROPDOWN | WS_VSCROLL | WS_TABSTOP
    LTEXT "Font #&3:", -1, 5, 105, 44, 12
    COMBOBOX cmb5, 55, 105, 125, 300, CBS_HASSTRINGS | CBS_AUTOHSCROLL | CBS_DROPDOWN | WS_VSCROLL | WS_TABSTOP
    ICON IDI_ARROW, -1, 30, 125, 0, 0
    COMBOBOX cmb6, 55, 130, 125, 300, CBS_HASSTRINGS | CBS_AUTOHSCROLL | CBS_DROPDOWN | WS_VSCROLL | WS_TABSTOP
    DEFPUSHBUTTON "OK", IDOK, 75, 160, 50, 14
    PUSHBUTTON "Cancel", IDCANCEL, 130, 160, 50, 14
    PUSHBUTTON "&Reset", psh1, 5, 160, 55, 14
}

IDD_DROPDOWNPOPUP DIALOG 0, 0, 120, 150
CAPTION " "
STYLE WS_POPUP | WS_DLGFRAME | NOT WS_BORDER
FONT 9, "MS Shell Dlg"
{
    LISTBOX lst1, 0, 0, 120, 150, LBS_WANTKEYBOARDINPUT | LBS_NOINTEGRALHEIGHT | LBS_HASSTRINGS | WS_VSCROLL | WS_TABSTOP, WS_EX_CLIENTEDGE
}

IDD_DFMSETTINGS DIALOG 0, 0, 210, 135
CAPTION "Delphi DFM Settings"
STYLE DS_CENTER | DS_MODALFRAME | WS_POPUPWINDOW | WS_CAPTION
FONT 9, "MS Shell Dlg"
{
    LTEXT "The following settings are relevant to Delphi DFM:", -1, 35, 5, 171, 20
    ICON IDI_DFMICON, -1, 5, 5, 0, 0
    RTEXT "&Codepage:", -1, 6, 32, 70, 12
    COMBOBOX cmb1, 85, 30, 120, 300, CBS_HASSTRINGS | CBS_AUTOHSCROLL | CBS_DROPDOWN | WS_VSCROLL | WS_TABSTOP
    AUTOCHECKBOX "&Insert raw string comments", chx1, 5, 50, 200, 14
    AUTOCHECKBOX "Don't use &Unicode and UTF-8", chx2, 5, 70, 200, 14
    DEFPUSHBUTTON "OK", IDOK, 80, 115, 60, 14
    PUSHBUTTON "Cancel", IDCANCEL, 145, 115, 60, 14
}

IDD_COPYTOMULTILANG DIALOG 0, 0, 200, 195
CAPTION "Copy to multple languages"
STYLE DS_CENTER | DS_MODALFRAME | WS_POPUPWINDOW | WS_CAPTION
FONT 9, "MS Shell Dlg"
{
    LTEXT "Please add the languages that you want to copy the resource to:", -1, 5, 5, 190, 22
    LTEXT "&Languages:", -1, 5, 35, 82, 12
    LISTBOX lst1, 5, 50, 190, 100, LBS_WANTKEYBOARDINPUT | LBS_NOINTEGRALHEIGHT | LBS_HASSTRINGS | WS_VSCROLL | WS_TABSTOP
    COMBOBOX cmb3, 5, 155, 126, 14, CBS_HASSTRINGS | CBS_AUTOHSCROLL | CBS_DROPDOWN | WS_BORDER | WS_VSCROLL | WS_TABSTOP
    PUSHBUTTON "&Add", psh1, 135, 155, 60, 14
    DEFPUSHBUTTON "OK", IDOK, 5, 175, 60, 14
    PUSHBUTTON "Cancel", IDCANCEL, 70, 175, 60, 14
}

IDD_TOOLBARRES DIALOG 0, 0, 230, 195
CAPTION "Toolbar resource"
STYLE DS_CENTER | DS_MODALFRAME | WS_POPUPWINDOW | WS_CAPTION
FONT 9, "MS Shell Dlg"
{
    RTEXT "Icon &width:", -1, 5, 5, 60, 15, SS_CENTERIMAGE | NOT WS_GROUP
    EDITTEXT edt1, 70, 5, 30, 15, ES_NUMBER | ES_RIGHT
    CONTROL "", scr1, "msctls_updown32", UDS_NOTHOUSANDS | UDS_ARROWKEYS | UDS_AUTOBUDDY | UDS_ALIGNRIGHT | UDS_SETBUDDYINT, 80, 5, 30, 15
    RTEXT "Icon &height:", -1, 110, 5, 60, 15, SS_CENTERIMAGE | NOT WS_GROUP
    EDITTEXT edt2, 180, 5, 30, 15, ES_NUMBER | ES_RIGHT
    CONTROL "", scr2, "msctls_updown32", UDS_NOTHOUSANDS | UDS_ARROWKEYS | UDS_AUTOBUDDY | UDS_ALIGNRIGHT | UDS_SETBUDDYINT, 190, 5, 30, 15
    LTEXT "&Toolbar buttons:", -1, 5, 25, 140, 15, SS_CENTERIMAGE | NOT WS_GROUP
    LISTBOX lst1, 5, 40, 140, 130, LBS_DISABLENOSCROLL | LBS_WANTKEYBOARDINPUT | LBS_NOINTEGRALHEIGHT | LBS_HASSTRINGS | LBS_OWNERDRAWFIXED | WS_VSCROLL | WS_TABSTOP
    PUSHBUTTON "&Add...", psh1, 150, 40, 75, 15
    PUSHBUTTON "&Modify...", psh2, 150, 60, 75, 15
    PUSHBUTTON "&Delete", psh3, 150, 80, 75, 15
    PUSHBUTTON "&Up", psh4, 150, 135, 75, 15
    PUSHBUTTON "D&own", psh5, 150, 155, 75, 15
    DEFPUSHBUTTON "OK", IDOK, 5, 175, 60, 15
    PUSHBUTTON "Cancel", IDCANCEL, 70, 175, 60, 15
}

IDD_ADDTBBTN DIALOG 0, 0, 177, 92
CAPTION "Add Toolbar button"
STYLE DS_CENTER | DS_MODALFRAME | WS_POPUPWINDOW | WS_CAPTION
FONT 9, "MS Shell Dlg"
{
    LTEXT "&Command ID of Toolbar button:", -1, 5, 5, 160, 15, SS_CENTERIMAGE | NOT WS_GROUP
    COMBOBOX cmb1, 5, 25, 150, 150, CBS_HASSTRINGS | CBS_AUTOHSCROLL | CBS_DROPDOWN | WS_VSCROLL | WS_TABSTOP
    AUTOCHECKBOX "&Separator", chx1, 5, 45, 90, 15
    DEFPUSHBUTTON "OK", IDOK, 45, 70, 60, 15
    PUSHBUTTON "Cancel", IDCANCEL, 110, 70, 60, 15
}

IDD_MODIFYTBBTN DIALOG 0, 0, 177, 92
CAPTION "Modify Toolbar button"
STYLE DS_CENTER | DS_MODALFRAME | WS_POPUPWINDOW | WS_CAPTION
FONT 9, "MS Shell Dlg"
{
    LTEXT "&Command ID of Toolbar button:", -1, 5, 5, 160, 15, SS_CENTERIMAGE | NOT WS_GROUP
    COMBOBOX cmb1, 5, 25, 150, 150, CBS_HASSTRINGS | CBS_AUTOHSCROLL | CBS_DROPDOWN | WS_VSCROLL | WS_TABSTOP
    AUTOCHECKBOX "&Separator", chx1, 5, 45, 90, 15
    DEFPUSHBUTTON "OK", IDOK, 45, 70, 60, 15
    PUSHBUTTON "Cancel", IDCANCEL, 110, 70, 60, 15
}

//////////////////////////////////////////////////////////////////////////////
// RT_VERSION

1 VERSIONINFO
FILEVERSION     5, 7, 9, 0
PRODUCTVERSION  5, 7, 9, 0
FILEOS          0x40004
FILETYPE        0x1
FILESUBTYPE     0x0
{
    BLOCK "StringFileInfo"
    {
        BLOCK "040904E4"
        {
            VALUE "CompanyName", "Katayama Hirofumi MZ\0"
            VALUE "FileDescription", "RisohEditor\0"
            VALUE "FileVersion", "5.7.9\0"
            VALUE "LegalCopyright", "Copyright (C) 2017-2020 Katayama Hirofumi MZ. All rights reserved.\0"
            VALUE "ProductName", "RisohEditor\0"
            VALUE "ProductVersion", "5.7.9\0"
        }
    }
    BLOCK "VarFileInfo"
    {
        VALUE "Translation", 0x0409, 0x04E4
    }
}

//////////////////////////////////////////////////////////////////////////////
// RISOHTEMPLATE

4 RISOHTEMPLATE "res/1033_RISOHTEMPLATE_4.bin"

5 RISOHTEMPLATE "res/1033_RISOHTEMPLATE_5.bin"

//////////////////////////////////////////////////////////////////////////////
// RT_STRING

STRINGTABLE
{
    IDS_APPNAME, "RisohEditor 5.7.9 by Katayama Hirofumi MZ"
    IDS_TITLEWITHFILE, "RisohEditor 5.7.9 - File: %s"
    IDS_EXTRACTRES, "Extract Resource"
    IDS_RESBINFILTER, "Binary Resources (*.res)|*.res|Binary Files (*.bin)|*.bin|All Files (*.*)|*.*|"
    IDS_CANNOTSAVE, "Unable to save."
    IDS_REPLACERES, "Replace Resource"
    IDS_ALLFILES, "All Files (*.*)|*.*|"
    IDS_ENTERTYPE, "Please enter a resource type."
    IDS_ENTERNAME, "Please enter a resource name."
    IDS_ENTERLANG, "Please enter a resource language."
    IDS_FILENOTFOUND, "File could not be found."
    IDS_CANNOTREPLACE, "Unable to replace."
    IDS_EXERESFILTER, "Executables (*.exe;*.dll;*.ocx;*.cpl;*.scr;*.mui)|*.exe;*.dll;*.ocx;*.cpl;*.scr;*.mui|RC Files (*.rc)|*.rc|Binary Resources (*.res)|*.res|All Files (*.*)|*.*|"
    IDS_SAVEAS, "Save As"
    IDS_CANNOTADDICON, "Unable to add the icon."
    IDS_ADDICON, "Add Icon"
    IDS_ICOFILTER, "Icon Files (*.ico)|*.ico|All Files (*.*)|*.*|"
    IDS_REPLACEICO, "Replace Icon"
    IDS_CANTREPLACEICO, "Unable to replace icon."
    IDS_EXISTSOVERWRITE, "The item already exists. Overwrite?"
    IDS_OPEN, "Open"
    IDS_CANNOTOPEN, "Unable to open the file."
    IDS_ADDBMP, "Add Bitmap"
    IDS_BMPFILTER, "Bitmap Files (*.bmp)|*.bmp|PNG Images (*.png)|*.png|All Files (*.*)|*.*|"
    IDS_CANTREPLACEBMP, "Unable to replace bitmap."
    IDS_REPLACEBMP, "Replace Bitmap"
    IDS_ERRORCODE, "Error Code %d"
    IDS_VERSIONINFO, "RisohEditor Version 5.7.9\r\n\r\nKatayama Hirofumi MZ\r\n\r\nLicense: GPLv3 (free software)"
    IDS_ADDRES, "Add Resource"
    IDS_CANNOTADDRES, "Unable to add the resource."
    IDS_CANTADDBMP, "Unable to add the bitmap."
    IDS_EXTRACTBMP, "Extract Bitmap"
    IDS_CANTEXTRACTBMP, "Unable to extract the bitmap."
    IDS_CANTREPLACECUR, "Unable to replace the cursor."
    IDS_CANNOTADDCUR, "Unable to add the cursor."
    IDS_CURFILTER, "Cursor Files (*.cur)|*.cur|Animation Cursor (*.ani)|*.ani|All Files (*.*)|*.*|"
    IDS_ADDCUR, "Add Cursor"
    IDS_REPLACECUR, "Replace Cursor"
    IDS_EXTRACTICO, "Extract Icon"
    IDS_CANTEXTRACTICO, "Unable to extract the icon."
    IDS_EXTRACTCUR, "Extract Cursor"
    IDS_CANTEXTRACTCUR, "Unable to extract the cursor."
    IDS_RESFILTER, "Binary Resources (*.res)|*.res|All Files (*.*)|*.*|"
    IDS_NEUTRAL, "Neutral"
    IDS_IMPORTRES, "Import"
    IDS_CANNOTIMPORT, "Unable to import the resource."
    IDS_COMPILE, "Compile (F8)"
    IDS_CANCELEDIT, "Cancel Edit (Ctrl+E)"
    IDS_GUIEDIT, "Edit by GUI (Ctrl+G)"
    IDS_CANNOTSTARTUP, "Unable to start up the resource compiler."
    IDS_RESMISMATCH, "Resource type was mismatched."
    IDS_SAMPLETEXT, "This is a sample."
    IDS_ALREADYEXISTS, "Already exists."
    IDS_KEY, "Key"
    IDS_FLAGS, "Flags"
    IDS_COMMANDID, "Command ID"
    IDS_INVALIDKEY, "Invalid key."
    IDS_COMPILEERROR, "Failed to compile."
    IDS_STRINGID, "String ID"
    IDS_STRINGVALUE, "String Value"
    IDS_CAPTION, "Caption"
    IDS_HELPID, "Help ID"
    IDS_INDENT, "» "
    IDS_DATAISEMPTY, "Data is empty."
    IDS_TEST, "Do Test"
    IDS_SEPARATOR, "---"
    IDS_COMPILENOW, "Data has been changed. Compile now?"
    IDS_RADWINDOW, "Edit Dialog"
    IDS_ENTERCLASS, "Please enter a valid window class name."
    IDS_TEXTEDIT, "Edit by Text (Ctrl+T)"
    IDS_CURSORINFO, "Image #%u: Width %u, Height %u, BitCount %u, xHotSpot %u, yHotSpot %u, ID %u\r\n"
    IDS_IMAGECOUNT, "ImageCount: %u\r\n"
    IDS_ICONINFO, "Image #%u: Width %u, Height %u, BitCount %u, ID %u\r\n"
    IDS_READY, "Ready"
    IDS_EXECUTINGCMD, "Executing command..."
    IDS_EDITINGBYGUI, "Editing by GUI..."
    IDS_COORD, "%d, %d, %d, %d"
    IDS_STARTING, "Starting..."
    IDS_COMPILING, "Compiling..."
    IDS_CANNOTLOAD, "Unable to load."
    IDS_NONE, "(None)"
    IDS_WAVESOUND, "(WAVE Sound)\r\n"
    IDS_IDTYPE, "ID Type"
    IDS_IDPREFIX, "ID Prefix"
    IDS_EMPTYSTR, "Please enter a string."
    IDS_ANICURSOR, "(Animation Cursor)\r\n"
    IDS_ANIICON, "(Animation Icon)\r\n"
    IDS_HEADFILTER, "Header Files (*.h)|*.h|All Files (*.*)|*.*|"
    IDS_LOADRESH, "Load ""resource.h"" File"
    IDS_NAME, "Name"
    IDS_VALUE, "Value"
    IDS_NOSUCHID, "No such ID found."
    IDS_IMAGEINFO, "Width %u, Height %u, BitsPixel %u\r\n"
    IDS_ENTERINT, "Please enter a valid integer."
    IDS_ENTERTEXT, "Please enter a valid text."
    IDS_ENTERID, "Please enter a valid ID."
    IDS_ADDNEXTIDS, "Please add the following IDs to ""resource.h"":\r\n\r\n"
    IDS_DELETENEXTIDS, "Please delete the following IDs from ""resource.h"":\r\n\r\n"
    IDS_NOCHANGE, "There is no change of Resource IDs."
    IDS_DLGFAIL, "Oops, I failed to create a RAD dialog."
    IDS_LOADWCLIB, "Load A Window Class Library"
    IDS_AVIMOVIE, "(AVI Movie)\r\n"
    IDS_ADDDIALOG, "Add Dialog"
    IDS_ADDMENU, "Add Menu"
    IDS_ADDVERINFO, "Add Version Info"
    IDS_ADDCURSOR, "Add Cursor"
    IDS_NOMOREITEM, "No more items."
    IDS_INVALIDDATA, "(invalid data)\r\n"
    IDS_UPDATERESH, "Update ""resource.h""?"
    IDS_CANTWRITERESH, "Unable to write ""resource.h""."
    IDS_SAVERESH, "Save ""resource.h"" File"
    IDS_DLLFILTER, "DLL Files (*.dll;*.ocx;*.mui)|*.dll;*.ocx;*.mui|All Files (*.*)|*.*|"
    IDS_EXERESRCFILTER, "Loadable Files (*.exe;*.dll;*.ocx;*.cpl;*.scr;*.mui;*.res;*.rc)|*.exe;*.dll;*.ocx;*.cpl;*.scr;*.mui;*.res;*.rc|Executables (*.exe;*.dll;*.ocx;*.cpl;*.scr;*.mui)|*.exe;*.dll;*.ocx;*.cpl;*.scr;*.mui|Binary Resources (*.res)|*.res|Resource Files (*.rc)|*.rc|All Files (*.*)|*.*|"
    IDS_CANTTESTCHILDWND, "Unable to test the dialog because it is a child window."
    IDS_CANTTESTCLASSDLG, "Unable to test the dialog because it is classed."
    IDS_FILEISUPXED, "File\r\n\r\n'%s'\r\n\r\nis compressed by UPX. Do you want to extract it by using a temporary file?\r\n\r\nIf you didn't expand it, reading might fail."
    IDS_CANTUPXEXTRACT, "Unable to extract by UPX."
    IDS_CANTSAVEUPXED, "Unable to save the file because it was compressed by UPX."
    IDS_MESSAGEID, "Message ID"
    IDS_MESSAGEVALUE, "Message Value"
    IDS_RCFILTER, "RC Files (*.rc)|*.rc|"
    IDS_EXPORT, "Export"
    IDS_CANTEXPORT, "Export failed."
    IDS_MUSTBEEMPTYDIR, "If there is any external file, then the export destination must be an empty folder."
    IDS_FULLWIDTH, "０１２３４５６７８９ＡＢＣＤＥＦＧＨＩＪＫＬＭＮＯＰＱＲＳＴＵＶＷＸＹＺａｂｃｄｅｆｇｈｉｊｋｌｍｎｏｐｑｒｓｔｕｖｗｘｙｚ－＿（）．　"
    IDS_HALFWIDTH, "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz-_(). "
    IDS_MACRONAME, "Macro Name"
    IDS_MACROVALUE, "Macro Value"
    IDS_OPTIONAL, "(Optional)"
    IDS_ADDINCLUDE, "Add Include Directory"
    IDS_EDITINCLUDE, "Edit Include Directory"
    IDS_WINDRESEXE, "windres.exe|windres.exe|"
    IDS_CPPEXE, "cpp.exe|cpp.exe|"
    IDS_INVALIDPATH, "Invalid path."
    IDS_DATATOOLONG, "Data is too long."
    IDS_ALL, "(All)"
    IDS_UNKNOWNFORMAT, "(Unknown Data Format)\r\n"
    IDS_LANGUAGE, "Language"
    IDS_INTVALUE, "Integer Value"
    IDS_PARENTWND, "Parent Test Window"
    IDS_CHOOSE_OLE_CLSID, "Choose OLE CLSID"
    IDS_CONTROL, "Control"
    IDS_MESSAGE, "Message"
    IDS_STRING, "String"
    IDS_DATAISINVALID, "Data is invalid."
    IDS_DLGINIT1, "You can specify initialization of combo boxes and list boxes by setting initialization data in the RT_DLGINIT resource data of the same name as the dialog resource. "
    IDS_DLGINIT2, "When the WM_INITDIALOG message arrives, the application can initialize the dialog by calling the ExecuteDlgInitDx function of the attached file ""DlgInit/DlgInit.h"".\r\n\r\n"
    IDS_DLGINIT3, "Please specify a list of character strings separated by line breaks for RT_DLGINIT."
    IDS_SAMELANG, "It's the same language."
    IDS_SAMENAME, "It's the same resource name."
    IDS_CANTSAVETOEXE, "Unable to save as EXE from a non-executable file."
    IDS_CANTSTARTSEARCH, "Unable to start search."
    IDS_AMERICA, "America"
    IDS_ENGLISH, "English"
    IDS_CHINA, "China"
    IDS_CHINESE, "Chinese"
    IDS_RUSSIA, "Russia"
    IDS_RUSSIAN, "Russian"
    IDS_WANNAGENRESH, "Do you wanna generate file 'resource.h'?"
    IDS_EXEFILTER, "Executables (*.exe;*.dll;*.ocx;*.cpl;*.scr;*.mui)|*.exe;*.dll;*.ocx;*.cpl;*.scr;*.mui|All Files (*.*)|*.*|"
    IDS_SAVEASCOMPRESS, "Save With Compressed"
    IDS_TOOL_NEW, "New"
    IDS_TOOL_OPEN, "Open..."
    IDS_TOOL_SAVE, "Save As..."
    IDS_TOOL_EXPAND, "Expand All"
    IDS_TOOL_COLLAPSE, "Collapse All"
    IDS_TOOL_PLUS, "Add Item..."
    IDS_TOOL_MINUS, "Delete Item"
    IDS_TOOL_CHANGE, "Change Name/Language"
    IDS_TOOL_CLONE, "Clone In Another Name/Language"
    IDS_TOOL_RECOMPILE, "Recompile"
    IDS_TOOL_CANCELEDIT, "Cancel Edit"
    IDS_TOOL_IMPORT, "Import..."
    IDS_TOOL_EXTRACT, "Extract..."
    IDS_TOOL_GUIEDIT, "Edit by GUI"
    IDS_UNITEDKINGDOM, "United Kingdom"
    IDS_GREATBRITAIN, "Great Britain"
    IDS_BRITISH, "British"
    IDS_FRANCE, "France"
    IDS_FRENCH, "French"
    IDS_GERMANY, "Germany"
    IDS_GERMAN, "German"
    IDS_SPAIN, "Spain"
    IDS_SPANISH, "Spanish"
    IDS_INVALIDLANG, "Unrecognizable language."
    IDS_INVALIDNAME, "Invalid resource name."
    IDS_PNGRESBINFILTER, "PNG Image (*.png)|*.png|Binary Resources (*.res)|*.res|Binary Files (*.bin)|*.bin|All Files (*.*)|*.*|"
    IDS_JPEGRESBINFILTER, "JPEG Image (*.jpg;*.jpeg;*.jpe;*.jfif)|*.jpg;*.jpeg;*.jpe;*.jfif|Binary Resources (*.res)|*.res|Binary Files (*.bin)|*.bin|All Files (*.*)|*.*|"
    IDS_GIFRESBINFILTER, "GIF Image (*.gif)|*.gif|Binary Resources (*.res)|*.res|Binary Files (*.bin)|*.bin|All Files (*.*)|*.*|"
    IDS_TIFFRESBINFILTER, "TIFF Image (*.tif;*.tiff)|*.tif;*.tiff|Binary Resources (*.res)|*.res|Binary Files (*.bin)|*.bin|All Files (*.*)|*.*|"
    IDS_AVIRESBINFILTER, "AVI Movie (*.avi)|*.avi|Binary Resources (*.res)|*.res|Binary Files (*.bin)|*.bin|All Files (*.*)|*.*|"
    IDS_WAVERESBINFILTER, "WAVE Sound (*.wav)|*.wav|Binary Resources (*.res)|*.res|Binary Files (*.bin)|*.bin|All Files (*.*)|*.*|"
    IDS_COMMENT_SEP, "//////////////////////////////////////////////////////////////////////////////\r\n\r\n"
    IDS_NEWLINE, "\r\n"
    IDS_NOTICE, "// This file is automatically generated by RisohEditor 5.7.9.\r\n"
    IDS_DAGGER, "// † <-- This dagger helps UTF-8 detection.\r\n"
    IDS_IMPORTFILTER, "Importable Files|*.rc;*.res;*.dfm;*.html;*.htm;*.manifest;*.ico;*.cur;*.ani;*.wav;*.bmp;*.dib;*.png;*.gif;*.jpg;*.jpeg;*.jpe;*.jfif;*.tif;*.tiff;*.avi;*.wmf;*.emf;*.tlb|RC Files (*.rc)|*.rc|Binary Resources (*.res)|*.res|Image Files|*.bmp;*.dib;*.png;*.gif;*.jpg;*.jpeg;*.jpe;*.jfif;*.tif;*.tiff;*.wmf;*.emf|Cursor Files (*.cur;*.ani)|*.cur;*.ani|Icon Files (*.ico)|*.ico|WAVE Sound Files (*.wav)|*.wav|HTML Files (*.html;*.htm)|*.html;*.htm|Manifest Files (*.manifest)|*.manifest|Delphi DFM Files (*.dfm)|*.dfm|TYPELIB Files (*.tlb)|*.tlb|All Files (*.*)|*.*|"
    IDS_CANTWRITEBYLOCK, "Unable to write the file because the following file is locked.\r\n\r\n%s"
    IDS_ANSI, "ANSI"
    IDS_WIDE, "Unicode"
    IDS_UTF8, "UTF-8 (with BOM)"
    IDS_UTF8N, "UTF-8 (without BOM)"
    IDS_SJIS, "Shift_JIS"
    IDS_BINARY, "(binary data)"
    IDS_RESTYPE, "Resource Type"
    IDS_ENCODING, "Encoding"
    IDS_INVALIDRESTYPE, "Invalid resource type."
    IDS_PATHSPACEERROR, "You wrongly installed into the location with space characters! The resource compiler can't accept space.\n\nPlease avoid ""C:\\Program Files""."
    IDS_LOADEGAPROGRAM, "Load EGA program..."
    IDS_EGAFILTER, "EGA Program (*.ega)|*.ega|All Files (*.*)|*.*|"
    IDS_QUERYSAVECHANGE, "The file has been modified. Do you want to save changes now?"
    IDS_DFMFILTER, "DFM File (*.dfm)|*.dfm|Text Files (*.txt)|*.txt|All Files (*.*)|*.*|"
    IDS_CANTEXTRACTDFM, "Unable to extract the DFM data."
    IDS_EXTRACTDFM, "Extract DFM data"
    IDS_ENTERNONZERONAME, "Please enter a non-zero resource name."
    IDS_ENTERNONZEROTYPE, "Please enter a non-zero resource type."
    IDS_HOMEPAGE, "https://katahiromz.web.fc2.com/re/en/"
    IDS_FILESAVED, "File saved."
    IDS_RECOMPILEOK, "Recompilation done."
    IDS_RECOMPILEFAILED, "Recompilation failed (syntax error)."
    IDS_TOOL_EXPORT, "Export..."
    IDS_CODEEDITOR, "Code Editor"
    IDS_HEXVIEWER, "Hex Viewer"
    IDS_INTEGERORIDENTIFIER, "(integer or identifier)"
    IDS_NOTEXT, " "
    IDS_NOUPDATE, "You are using the latest RisohEditor."
    IDS_THEREISUPDATE, "RisohEditor %s is available. Download now?"
    IDS_CANTCHECKUPDATE, "Failed to check RisohEditor update."
    IDS_CODEPAGE1252, "1252 (Latin 1)"
    IDS_CODEPAGE1250, "1250 (Latin 2)"
    IDS_CODEPAGE1251, "1251 (Cyrillic)"
    IDS_CODEPAGE1253, "1253 (Greek)"
    IDS_CODEPAGE1254, "1254 (Turkish)"
    IDS_CODEPAGE1255, "1255 (Hebrew)"
    IDS_CODEPAGE1256, "1256 (Arabic)"
    IDS_CODEPAGE1257, "1257 (Baltic)"
    IDS_CODEPAGE874, "874 (Thai)"
    IDS_CODEPAGE932, "932 (Japanese)"
    IDS_CODEPAGE936, "936 (Simplified Chinese)"
    IDS_CODEPAGE949, "949 (Korean)"
    IDS_CODEPAGE950, "950 (Traditional Chinese)"
    IDS_CODEPAGE65001, "65001 (UTF-8)"
    IDS_EXTRACTTLB, "Extract TYPELIB data"
    IDS_CANTEXTRACTTLB, "Unable to extract the TYPELIB data."
    IDS_TLBRESBINFILTER, "TYPELIB data (*.tlb)|*.tlb|Binary Resources (*.res)|*.res|Text Files (*.txt)|*.txt|MIDL Files (*.idl)|*.idl|All Files (*.*)|*.*|"
    IDS_USAGE, "Usage: RisohEditor [options | ""file""]\n\nOptions:\n--help  Show this message.\n--version  Show version info.\n--load ""your-file.rc""  Load the file (without GUI)\n--save ""your-file.res""  Save the file (without GUI)\n--log-file ""log-file.txt""  Specify the log file.\n--load-options OPTIONS  Set load options.\n--save-options OPTIONS  Set save options.\n\nLoad options: (no-load-res-h)\nSave options: (idc-static)(compress)(sep-lang)(no-res-folder)(lang-macro)(less-comments)(wrap-manifest)(begin-end)(utf-16)(backup)(ms-msgtbl)"
    IDS_NOSELECTION, "There is no selection."
    IDS_TRANSLATORS, "[Translators]\r\nEnglish: Katayama Hirofumi MZ\r\nFinnish: Veikko Muurikainen\r\nIndonesian: Mas Ahmad Muhammad\r\nItalian: R.B.\r\nJapanese: Katayama Hirofumi MZ\r\nKorean: VenusGirl (비너스걸)\r\nPolish: Piotr Hetnarowicz\r\nPortuguese: JNylson\r\nRussian: Dmitry Yerokhin\r\nSimplified Chinese: 林鸿湘\r\n"
}

//////////////////////////////////////////////////////////////////////////////

```

`src/lang/fi_FI.rc`:

```rc
// This file is automatically generated by RisohEditor 5.7.9.
// † <-- This dagger helps UTF-8 detection.

#pragma code_page(65001) // UTF-8

LANGUAGE LANG_FINNISH, SUBLANG_DEFAULT

//////////////////////////////////////////////////////////////////////////////
// RT_MENU

IDR_MAINMENU MENU
{
    POPUP "&File"
    {
        MENUITEM "&Uusi\tCtrl+N", ID_NEW
        MENUITEM SEPARATOR
        MENUITEM "&Avaa...\tCtrl+O", ID_OPEN
        MENUITEM "&Tallenna...\tCtrl+S", ID_SAVE
        MENUITEM "Tallenn&a nimellä...\tShift+Ctrl+S", ID_SAVEAS
        MENUITEM "Tallenna &pakattuna...", ID_SAVEASCOMPRESS
        MENUITEM SEPARATOR
        MENUITEM "&Tuo...\tCtrl+I", ID_IMPORT
        MENUITEM "&Vie...\tCtrl+P", ID_EXPORT
        MENUITEM SEPARATOR
        MENUITEM "Lataa resource.h uudelleen...\tCtrl+R", ID_LOADRESH
        MENUITEM "Tallenna re&source.h...", ID_UPDATERESHBANG
        MENUITEM "Neu&voja resource.h muuttamiseen...", ID_ADVICERESH
        MENUITEM "&Poista resource.h muistista", ID_UNLOADRESH
        MENUITEM SEPARATOR
        MENUITEM "Lataa &Windowsin luokkakirjasto...", ID_LOADWCLIB
        MENUITEM SEPARATOR
        POPUP "Viimeksi käytetyt tiedostot"
        {
            MENUITEM "(Ei mitään)", -1, GRAYED
        }
        MENUITEM SEPARATOR
        MENUITEM "P&oistu\tAlt+F4", ID_EXIT
    }
    POPUP "&Muokkaus"
    {
        MENUITEM "Muokkaa &GUI:ssa...\tCtrl+G", ID_GUIEDIT
        MENUITEM SEPARATOR
        POPUP "&Lisää"
        {
            MENUITEM "Lisää &kuvake...", ID_ADDICON
            MENUITEM "Lisää &kursori...", ID_ADDCURSOR
            MENUITEM "Lisää &bittikartta...", ID_ADDBITMAP
            MENUITEM "Lisää &dialogi...", ID_ADDDIALOG
            MENUITEM "Lisää &Valikko...", ID_ADDMENU
            MENUITEM "Lisää &merkkijonotaulukko...", ID_ADDSTRINGTABLE
            MENUITEM "Lisää &viestitaulukko...", ID_ADDMESSAGETABLE
            MENUITEM "Lisää &HTML...", ID_ADDHTML
            MENUITEM "Lisää &pikatoimintoja...", ID_ADDACCEL
            MENUITEM "Lisää &versiotiedot...", ID_ADDVERINFO
            MENUITEM "Lisää mani&festi...", ID_ADDMANIFEST
            MENUITEM "Lisää &työkalupalkki...", ID_ADDTOOLBAR
            MENUITEM "Lisää &Resurssikohde...", ID_ADDRES
        }
        POPUP "&Korvaus"
        {
            MENUITEM "Korvaa &kuvake...", ID_REPLACEICON
            MENUITEM "Korvaa &kursori...", ID_REPLACECURSOR
            MENUITEM "Korvaa &bittikartta...", ID_REPLACEBITMAP
            MENUITEM "Korvaa binaa&riresurssi...", ID_REPLACEBIN
        }
        POPUP "&Poiminta"
        {
            MENUITEM "Pura &kuvake...", ID_EXTRACTICON
            MENUITEM "Pura &kursori...", ID_EXTRACTCURSOR
            MENUITEM "Pura &bittikartta...", ID_EXTRACTBITMAP
            MENUITEM "Pura &RC-tiedostona...", ID_EXTRACTRC
            MENUITEM "Pura binaa&riresurssi...", ID_EXTRACTBIN
        }
        MENUITEM SEPARATOR
        MENUITEM "Vai&hda nimi/kieli\tF2", ID_EDITLABEL
        MENUITEM SEPARATOR
        MENUITEM "Klooni uudessa &nimessä...", ID_COPYASNEWNAME
        MENUITEM "Klooni uudessa kie&lessä...", ID_COPYASNEWLANG
        MENUITEM "Kopioi useille kielille...", ID_COPYTOMULTILANG
        MENUITEM SEPARATOR
        MENUITEM "&Testaa", ID_TEST
        MENUITEM SEPARATOR
        MENUITEM "&Poista\tDel", ID_DELETERES
        MENUITEM SEPARATOR
        MENUITEM "&ID assosiaatio...", ID_IDASSOC
        MENUITEM "Ennalta määritetyt &makrot...", ID_PREDEFMACROS
        MENUITEM "&Fonttiasetukset...", ID_FONTS
        MENUITEM "Aseta &polut...", ID_SETPATHS
        MENUITEM SEPARATOR
        MENUITEM "&UI Language Select (UI语言选择)...", ID_CHOOSEUILANG
        MENUITEM SEPARATOR
        MENUITEM "Delphi DFM &asetukset...", ID_DFMSETTINGS
        MENUITEM "&Konfiguraatio...", ID_CONFIG
    }
    POPUP "&Haku"
    {
        MENUITEM "&Etsi...\tCtrl+F", ID_FIND
        MENUITEM SEPARATOR
        MENUITEM "Etsi &ylöspäin\tShift+F3", ID_FINDUPWARD
        MENUITEM "Etsi &alaspäin\tF3", ID_FINDDOWNWARD
        MENUITEM SEPARATOR
        MENUITEM "&Kyselyvakio...", ID_QUERYCONSTANT
    }
    POPUP "&Näkymä"
    {
        MENUITEM "&Tilapalkki", ID_STATUSBAR
        MENUITEM "&Työkalupalkki", ID_SHOWHIDETOOLBAR
        MENUITEM "&Binaari", ID_BINARYPANE
        MENUITEM SEPARATOR
        MENUITEM "&Laajenna kaikki\tCtrl+K", ID_EXPAND_ALL
        MENUITEM "&Tiivistä kaikki\tCtrl+L", ID_COLLAPSE_ALL
        MENUITEM SEPARATOR
        MENUITEM "Luettelo &resurssitunnuksista", ID_IDLIST
        MENUITEM "Kie&liluettelo...", ID_SHOWLANGS
        MENUITEM SEPARATOR
        MENUITEM "&CONTROL-lauseke aina", ID_ALWAYSCONTROL
        MENUITEM "Älä käytä &ID-makroja", ID_HIDEIDMACROS
        MENUITEM "Käytä IDC_ST&ATIC", ID_USEIDC_STATIC
        MENUITEM "&Sanan rivitys", ID_WORD_WRAP
        MENUITEM "Käytä BE&GIN/END", ID_USEBEGINEND
        MENUITEM "Käytä Microsoft Message &Tablea", ID_USEMSMSGTBL
        MENUITEM SEPARATOR
        MENUITEM "R&esurssikohteen koodaus...", ID_ENCODING
        MENUITEM "Dialog &font substitutes...", ID_DIALOG_FONT_SUBSTITUTES
        MENUITEM SEPARATOR
        MENUITEM "&Päivitä", ID_REFRESHALL
    }
    POPUP "&Automaatio"
    {
        MENUITEM "Ohjelmointikieli &EGA...", ID_EGA
        MENUITEM "Suo&rita EGA-ohjelma...", ID_EGA_PROGRAM
        MENUITEM "Avaa EGA &manuaali", ID_OPEN_EGA_MANUAL
    }
    POPUP "O&hje"
    {
        MENUITEM "Avaa &README.txt (English)", ID_OPENREADME
        MENUITEM "Avaa &LICENSE.txt", ID_OPENLICENSE
        MENUITEM SEPARATOR
        MENUITEM "Opas &RisohEditorille", ID_GUIDE
        MENUITEM "Tarkista RisohEditor-p&äivitykset...", ID_CHECKUPDATE
        MENUITEM SEPARATOR
        MENUITEM "Tietoj&a...", ID_ABOUT
    }
}

IDR_POPUPMENUS MENU
{
    POPUP "Popup #0"
    {
        MENUITEM "Muokkaa &GUI:ssa...\tCtrl+G", ID_GUIEDIT
        MENUITEM SEPARATOR
        POPUP "&Lisää"
        {
            MENUITEM "Lisää &kuvake...", ID_ADDICON
            MENUITEM "Lisää &kursori...", ID_ADDCURSOR
            MENUITEM "Lisää &bittikartta...", ID_ADDBITMAP
            MENUITEM "Lisää &dialogi...", ID_ADDDIALOG
            MENUITEM "Lisää &dialogi...", ID_ADDMENU
            MENUITEM "Lisää &merkkijonotaulukko...", ID_ADDSTRINGTABLE
            MENUITEM "Lisää vi&estitaulukko...", ID_ADDMESSAGETABLE
            MENUITEM "Lisää &HTML...", ID_ADDHTML
            MENUITEM "Lisää &pikatoimintoja...", ID_ADDACCEL
            MENUITEM "Lisää &versiotiedot...", ID_ADDVERINFO
            MENUITEM "Lisää mani&festi...", ID_ADDMANIFEST
            MENUITEM "Lisää &työkalupalkki...", ID_ADDTOOLBAR
            MENUITEM "Lisää &resurssikohde...", ID_ADDRES
        }
        POPUP "&Korvaus"
        {
            MENUITEM "Korvaa &kuvake...", ID_REPLACEICON
            MENUITEM "Korvaa &kursori...", ID_REPLACECURSOR
            MENUITEM "Korvaa &bittikartta...", ID_REPLACEBITMAP
            MENUITEM "Korvaa &binaarinen resurssinimike...", ID_REPLACEBIN
        }
        POPUP "&Poiminta"
        {
            MENUITEM "Poimi &kuvake...", ID_EXTRACTICON
            MENUITEM "Poimi &kursori...", ID_EXTRACTCURSOR
            MENUITEM "Poimi &bittikartta...", ID_EXTRACTBITMAP
            MENUITEM "Poimi &RC tiedostoon...", ID_EXTRACTRC
            MENUITEM "Poimi &binaarinen resurssinimike...", ID_EXTRACTBIN
        }
        MENUITEM SEPARATOR
        MENUITEM "Vai&hda nimi/kieli\tF2", ID_EDITLABEL
        MENUITEM SEPARATOR
        MENUITEM "Klooni uudessa &nimessä...", ID_COPYASNEWNAME
        MENUITEM "Klooni uudessa kie&lessä...", ID_COPYASNEWLANG
        MENUITEM "Kopioi useille kielille...", ID_COPYTOMULTILANG
        MENUITEM SEPARATOR
        MENUITEM "&Testaa", ID_TEST
        MENUITEM SEPARATOR
        MENUITEM "&Poista\tDel", ID_DELETERES
    }
    POPUP "Popup #1"
    {
        MENUITEM "Lisää ohj&aus...", ID_ADDCTRL
        MENUITEM SEPARATOR
        MENUITEM "Le&ikkaa\tCtrl+X", ID_CUT
        MENUITEM "&Kopioi\tCtrl+C", ID_COPY
        MENUITEM "&Liitä\tCtrl+V", ID_PASTE
        MENUITEM "&Poista\tDel", ID_DELCTRL
        MENUITEM SEPARATOR
        POPUP "&Indeksi"
        {
            MENUITEM "Siirry y&lös", ID_CTRLINDEXTOP
            MENUITEM SEPARATOR
            MENUITEM "Vähennä in&deksiä", ID_CTRLINDEXMINUS
            MENUITEM "Lisää in&deksiä", ID_CTRLINDEXPLUS
            MENUITEM SEPARATOR
            MENUITEM "Siirry &alas", ID_CTRLINDEXBOTTOM
            MENUITEM SEPARATOR
            MENUITEM "Näytä/piilota indeksit\tCtrl+D", ID_SHOWHIDEINDEX
        }
        POPUP "T&asaus"
        {
            MENUITEM "Tasaa &ylös", ID_TOPALIGN
            MENUITEM "Tasaa &alas", ID_BOTTOMALIGN
            MENUITEM "Tasaa &vasemmalle", ID_LEFTALIGN
            MENUITEM "Tasaa &oikealle", ID_RIGHTALIGN
            MENUITEM SEPARATOR
            MENUITEM "Sovita &ruudukkoon", ID_FITTOGRID
        }
        MENUITEM SEPARATOR
        MENUITEM "&Päivitä", ID_REFRESHDIALOG
        MENUITEM SEPARATOR
        MENUITEM "Ohjauso&bjektin ominaisuudet...", ID_CTRLPROP
        MENUITEM "Dial&ogin ominaisuudet...", ID_DLGPROP
    }
    POPUP "Popup #2"
    {
        MENUITEM "&Muokkaus...", ID_MODIFYASSOC
    }
    POPUP "Popup #3"
    {
        MENUITEM "&Siirry!", ID_IDJUMP
        MENUITEM SEPARATOR
        MENUITEM "&Lisää ID...", ID_ADDRESID
        MENUITEM "&Muokkaa ID...", ID_MODIFYRESID
        MENUITEM SEPARATOR
        MENUITEM "Kopioi &nimi", ID_COPYRESIDNAME
        MENUITEM "Kopioi &arvo", ID_COPYRESIDVALUE
        MENUITEM "Kopioi &määritelmä\tCtrl+C", ID_COPYIDDEF
        MENUITEM SEPARATOR
        MENUITEM "&Poista ID\tDel", ID_DELETERESID
        MENUITEM SEPARATOR
        MENUITEM "&Desimaalinumerot", ID_BASE10
        MENUITEM "&Hexadecimal Numbers", ID_BASE16
        MENUITEM SEPARATOR
        MENUITEM "&Lataa uudelleen", ID_LOADRESH
    }
    POPUP "Popup #4"
    {
        MENUITEM "&Lisää...", ID_ADD
        MENUITEM SEPARATOR
        MENUITEM "Vaihda &nimi...\tF2", ID_RENAME
        MENUITEM "Vaihda ar&vo...", ID_MODIFY
        MENUITEM SEPARATOR
        MENUITEM "&Poista\tDel", ID_DELETE
    }
    POPUP "Popup #5"
    {
        MENUITEM "&Kopioi kokonaisluku", ID_COPY
    }
    POPUP "Popup #6"
    {
        MENUITEM "&Lisää...", psh1
        MENUITEM "&Muokkaa...", psh2
        MENUITEM SEPARATOR
        MENUITEM "&Ylös", psh4
        MENUITEM "&Alas", psh5
        MENUITEM "&Vasen", psh6
        MENUITEM "&Oikea", psh7
        MENUITEM SEPARATOR
        MENUITEM "&Poista\tDel", psh3
    }
    POPUP "Popup #7"
    {
        MENUITEM "&Lisää...", psh1
        MENUITEM "&Muokkaa...", psh2
        MENUITEM SEPARATOR
        MENUITEM "&Ylös", psh4
        MENUITEM "&Alas", psh5
        MENUITEM SEPARATOR
        MENUITEM "&Poista\tDel", psh3
    }
    POPUP "Popup #8"
    {
        MENUITEM "&Lisää...", ID_ADD
        MENUITEM "&Muokkaa...", ID_MODIFY
        MENUITEM SEPARATOR
        MENUITEM "&&Poista\tDel", ID_DELETE
    }
}

//////////////////////////////////////////////////////////////////////////////
// RT_DIALOG

IDD_REPLACERES DIALOGEX 0, 0, 215, 170
CAPTION "Korvaa resurssi"
STYLE DS_MODALFRAME | WS_POPUPWINDOW | WS_CAPTION
FONT 9, "MS Shell Dlg", 0, 0, 1
{
    LTEXT "Resurssin &tyyppi:", -1, 5, 7, 70, 12
    COMBOBOX cmb1, 75, 5, 135, 200, CBS_HASSTRINGS | CBS_AUTOHSCROLL | CBS_DROPDOWN | WS_BORDER | WS_VSCROLL | WS_TABSTOP
    LTEXT "Resurssin &nimi:", -1, 5, 32, 70, 12
    COMBOBOX cmb2, 75, 30, 135, 200, CBS_HASSTRINGS | CBS_AUTOHSCROLL | CBS_DROPDOWN | WS_DISABLED | WS_BORDER | WS_VSCROLL | WS_TABSTOP
    LTEXT "Reurssin kie&li:", -1, 5, 57, 70, 12
    COMBOBOX cmb3, 75, 55, 135, 200, CBS_HASSTRINGS | CBS_AUTOHSCROLL | CBS_DROPDOWN | WS_DISABLED | WS_BORDER | WS_VSCROLL | WS_TABSTOP
    LTEXT "Binaari&tiedosto:", -1, 5, 85, 100, 12
    EDITTEXT edt1, 5, 97, 205, 14, ES_AUTOHSCROLL
    PUSHBUTTON "&Selaa...", psh1, 150, 115, 60, 14
    DEFPUSHBUTTON "OK", IDOK, 35, 150, 60, 14
    PUSHBUTTON "Peruuta", IDCANCEL, 115, 150, 60, 14
    {
        0x1234, 0x5678, 0x0011
    }
}

IDD_ADDICON DIALOG 0, 0, 215, 135
CAPTION "Lisää kuvake"
STYLE DS_MODALFRAME | WS_POPUPWINDOW | WS_CAPTION
FONT 9, "MS Shell Dlg"
{
    LTEXT "Kuvaketiedosto:", -1, 5, 7, 100, 12
    EDITTEXT edt1, 5, 18, 205, 14, ES_AUTOHSCROLL
    PUSHBUTTON "&Selaa...", psh1, 150, 35, 60, 14
    ICON 0, ico1, 5, 35, 0, 0
    LTEXT "Resurssin &nimi:", -1, 5, 67, 70, 12
    COMBOBOX cmb2, 75, 65, 120, 300, CBS_HASSTRINGS | CBS_AUTOHSCROLL | CBS_DROPDOWN | WS_BORDER | WS_VSCROLL | WS_TABSTOP
    PUSHBUTTON "&...", psh2, 195, 65, 15, 14
    LTEXT "Resurssin kie&li:", -1, 5, 92, 70, 12
    COMBOBOX cmb3, 75, 90, 135, 200, CBS_HASSTRINGS | CBS_AUTOHSCROLL | CBS_DROPDOWN | WS_BORDER | WS_VSCROLL | WS_TABSTOP
    DEFPUSHBUTTON "OK", IDOK, 35, 115, 60, 14
    PUSHBUTTON "Peruuta", IDCANCEL, 115, 115, 60, 14
}

IDD_REPLACEICON DIALOG 0, 0, 215, 135
CAPTION "Korvaa kuvake"
STYLE DS_MODALFRAME | WS_POPUPWINDOW | WS_CAPTION
FONT 9, "MS Shell Dlg"
{
    LTEXT "Kuvaketiedosto:", -1, 5, 7, 100, 12
    EDITTEXT edt1, 5, 18, 205, 14, ES_AUTOHSCROLL
    PUSHBUTTON "&Selaa...", psh1, 150, 35, 60, 14
    ICON 0, ico1, 5, 35, 0, 0
    LTEXT "Resurssin &nimi:", -1, 5, 67, 70, 12
    COMBOBOX cmb2, 75, 65, 135, 13, CBS_HASSTRINGS | CBS_AUTOHSCROLL | CBS_DROPDOWN | WS_DISABLED | WS_BORDER | WS_VSCROLL | WS_TABSTOP
    LTEXT "Resurssin kie&li:", -1, 5, 92, 70, 12
    COMBOBOX cmb3, 75, 90, 135, 13, CBS_HASSTRINGS | CBS_AUTOHSCROLL | CBS_DROPDOWN | WS_DISABLED | WS_BORDER | WS_VSCROLL | WS_TABSTOP
    DEFPUSHBUTTON "OK", IDOK, 35, 115, 60, 14
    PUSHBUTTON "Peruuta", IDCANCEL, 115, 115, 60, 14
}

IDD_ADDBITMAP DIALOG 0, 0, 215, 135
CAPTION "Lisää bittikartta"
STYLE DS_MODALFRAME | WS_POPUPWINDOW | WS_CAPTION
FONT 9, "MS Shell Dlg"
{
    LTEXT "&Bittikarttatiedosto:", -1, 5, 7, 100, 12
    EDITTEXT edt1, 5, 18, 205, 14, ES_AUTOHSCROLL
    PUSHBUTTON "&Selaa...", psh1, 150, 35, 60, 14
    LTEXT "Resurssin &nimi:", -1, 5, 67, 70, 12
    COMBOBOX cmb2, 75, 65, 120, 300, CBS_HASSTRINGS | CBS_AUTOHSCROLL | CBS_DROPDOWN | WS_BORDER | WS_VSCROLL | WS_TABSTOP
    PUSHBUTTON "&...", psh2, 195, 65, 15, 14
    LTEXT "Resurssin kie&li:", -1, 5, 92, 70, 12
    COMBOBOX cmb3, 75, 90, 135, 200, CBS_HASSTRINGS | CBS_AUTOHSCROLL | CBS_DROPDOWN | WS_BORDER | WS_VSCROLL | WS_TABSTOP
    DEFPUSHBUTTON "OK", IDOK, 35, 115, 60, 14
    PUSHBUTTON "Peruuta", IDCANCEL, 115, 115, 60, 14
}

IDD_REPLACEBMP DIALOG 0, 0, 215, 135
CAPTION "Korvaa bittikartta"
STYLE DS_MODALFRAME | WS_POPUPWINDOW | WS_CAPTION
FONT 9, "MS Shell Dlg"
{
    LTEXT "&Bittikarttatiedosto:", -1, 5, 7, 100, 12
    EDITTEXT edt1, 5, 18, 205, 14, ES_AUTOHSCROLL
    PUSHBUTTON "&Selaa...", psh1, 150, 35, 60, 14
    LTEXT "Resurssin &nimi:", -1, 5, 67, 70, 12
    COMBOBOX cmb2, 75, 65, 135, 200, CBS_HASSTRINGS | CBS_AUTOHSCROLL | CBS_DROPDOWN | WS_DISABLED | WS_BORDER | WS_VSCROLL | WS_TABSTOP
    LTEXT "Resurssin kie&li:", -1, 5, 92, 70, 12
    COMBOBOX cmb3, 75, 90, 135, 200, CBS_HASSTRINGS | CBS_AUTOHSCROLL | CBS_DROPDOWN | WS_DISABLED | WS_BORDER | WS_VSCROLL | WS_TABSTOP
    DEFPUSHBUTTON "OK", IDOK, 35, 115, 60, 14
    PUSHBUTTON "Peruuta", IDCANCEL, 115, 115, 60, 14
}

IDD_ADDRES DIALOG 0, 0, 215, 170
CAPTION "Lisää resurssi"
STYLE DS_MODALFRAME | WS_POPUPWINDOW | WS_CAPTION
FONT 9, "MS Shell Dlg"
{
    LTEXT "Resurssin &tyyppi:", -1, 5, 7, 70, 12
    COMBOBOX cmb1, 75, 5, 135, 200, CBS_HASSTRINGS | CBS_AUTOHSCROLL | CBS_DROPDOWN | WS_BORDER | WS_VSCROLL | WS_TABSTOP
    LTEXT "Resurssin &nimi:", -1, 5, 32, 70, 12
    COMBOBOX cmb2, 75, 30, 120, 300, CBS_HASSTRINGS | CBS_AUTOHSCROLL | CBS_DROPDOWN | WS_BORDER | WS_VSCROLL | WS_TABSTOP
    PUSHBUTTON "&...", psh2, 195, 30, 15, 14
    LTEXT "", stc1, 75, 43, 115, 10
    LTEXT "Resurssin kie&li:", -1, 5, 57, 70, 12
    COMBOBOX cmb3, 75, 55, 135, 200, CBS_HASSTRINGS | CBS_AUTOHSCROLL | CBS_DROPDOWN | WS_BORDER | WS_VSCROLL | WS_TABSTOP
    LTEXT "Binaari&tiedosto:", -1, 5, 85, 100, 12
    EDITTEXT edt1, 5, 97, 205, 14, ES_AUTOHSCROLL
    PUSHBUTTON "&Selaa...", psh1, 150, 115, 60, 14
    LTEXT "", stc2, 5, 112, 100, 10
    DEFPUSHBUTTON "OK", IDOK, 35, 150, 60, 14
    PUSHBUTTON "Peruuta", IDCANCEL, 115, 150, 60, 14
}

IDD_ADDCURSOR DIALOG 0, 0, 215, 135
CAPTION "Lisää kursori"
STYLE DS_MODALFRAME | WS_POPUPWINDOW | WS_CAPTION
FONT 9, "MS Shell Dlg"
{
    LTEXT "&Kursoritiedosto:", -1, 5, 7, 100, 12
    EDITTEXT edt1, 5, 18, 205, 14, ES_AUTOHSCROLL
    PUSHBUTTON "&Selaa...", psh1, 150, 35, 60, 14
    ICON 0, ico1, 5, 35, 0, 0
    LTEXT "Resurssin &nimi:", -1, 5, 67, 70, 12
    COMBOBOX cmb2, 75, 65, 120, 200, CBS_HASSTRINGS | CBS_AUTOHSCROLL | CBS_DROPDOWN | WS_BORDER | WS_VSCROLL | WS_TABSTOP
    PUSHBUTTON "&...", psh2, 195, 65, 15, 14
    LTEXT "Resurssin kie&li:", -1, 5, 92, 70, 12
    COMBOBOX cmb3, 75, 90, 135, 200, CBS_HASSTRINGS | CBS_AUTOHSCROLL | CBS_DROPDOWN | WS_BORDER | WS_VSCROLL | WS_TABSTOP
    DEFPUSHBUTTON "OK", IDOK, 35, 115, 60, 14
    PUSHBUTTON "Peruuta", IDCANCEL, 115, 115, 60, 14
}

IDD_REPLACECUR DIALOG 0, 0, 215, 135
CAPTION "Korvaa kursori"
STYLE DS_MODALFRAME | WS_POPUPWINDOW | WS_CAPTION
FONT 9, "MS Shell Dlg"
{
    LTEXT "&Kursoritiedosto:", -1, 5, 7, 100, 12
    EDITTEXT edt1, 5, 18, 205, 14, ES_AUTOHSCROLL
    PUSHBUTTON "&Selaa...", psh1, 150, 35, 60, 14
    ICON 0, ico1, 5, 35, 0, 0
    LTEXT "Resurssin &nimi:", -1, 5, 67, 70, 12
    COMBOBOX cmb2, 75, 65, 135, 200, CBS_HASSTRINGS | CBS_AUTOHSCROLL | CBS_DROPDOWN | WS_DISABLED | WS_BORDER | WS_VSCROLL | WS_TABSTOP
    LTEXT "Resurssin kie&li:", -1, 5, 92, 70, 12
    COMBOBOX cmb3, 75, 90, 135, 200, CBS_HASSTRINGS | CBS_AUTOHSCROLL | CBS_DROPDOWN | WS_DISABLED | WS_BORDER | WS_VSCROLL | WS_TABSTOP
    DEFPUSHBUTTON "OK", IDOK, 35, 115, 60, 14
    PUSHBUTTON "Peruuta", IDCANCEL, 115, 115, 60, 14
}

IDD_MENUTEST DIALOG 0, 0, 215, 135
CAPTION "Valikkotesti"
STYLE DS_MODALFRAME | WS_POPUPWINDOW | WS_CAPTION
FONT 9, "MS Shell Dlg"
{
}

IDD_ADDKEY DIALOG 0, 0, 190, 120
CAPTION "Lisää avain"
STYLE DS_MODALFRAME | WS_POPUPWINDOW | WS_CAPTION
FONT 9, "MS Shell Dlg"
{
    RTEXT "&Avain:", -1, 5, 12, 60, 14
    COMBOBOX cmb1, 70, 10, 110, 200, CBS_DROPDOWN | WS_BORDER | WS_VSCROLL | WS_TABSTOP
    RTEXT "Komennon &ID:", -1, 5, 37, 60, 14
    COMBOBOX cmb2, 70, 35, 95, 300, CBS_DROPDOWN | WS_BORDER | WS_VSCROLL | WS_TABSTOP
    PUSHBUTTON "&...", psh1, 165, 35, 15, 14
    AUTOCHECKBOX "&VIRTKEY", chx1, 5, 60, 60, 14
    AUTOCHECKBOX "&NOINVERT", chx2, 70, 60, 60, 14
    AUTOCHECKBOX "&CONTROL", chx3, 5, 75, 60, 14
    AUTOCHECKBOX "&SHIFT", chx4, 70, 75, 60, 14
    AUTOCHECKBOX "&ALT", chx5, 140, 75, 45, 14
    DEFPUSHBUTTON "OK", IDOK, 60, 100, 60, 14
    PUSHBUTTON "Peruuta", IDCANCEL, 125, 100, 60, 14
}

IDD_MODIFYKEY DIALOG 0, 0, 190, 120
CAPTION "Muokkaa avainta"
STYLE DS_MODALFRAME | WS_POPUPWINDOW | WS_CAPTION
FONT 9, "MS Shell Dlg"
{
    RTEXT "&Avain:", -1, 5, 12, 60, 14
    COMBOBOX cmb1, 70, 10, 110, 200, CBS_DROPDOWN | WS_BORDER | WS_VSCROLL | WS_TABSTOP
    RTEXT "Komennon &ID:", -1, 5, 37, 60, 14
    COMBOBOX cmb2, 70, 35, 95, 200, CBS_DROPDOWN | WS_BORDER | WS_VSCROLL | WS_TABSTOP
    PUSHBUTTON "&...", psh1, 165, 35, 15, 14
    AUTOCHECKBOX "&VIRTKEY", chx1, 5, 60, 60, 14
    AUTOCHECKBOX "&NOINVERT", chx2, 70, 60, 60, 14
    AUTOCHECKBOX "&CONTROL", chx3, 5, 75, 60, 14
    AUTOCHECKBOX "&SHIFT", chx4, 70, 75, 60, 14
    AUTOCHECKBOX "&ALT", chx5, 140, 75, 45, 14
    DEFPUSHBUTTON "OK", IDOK, 60, 100, 60, 14
    PUSHBUTTON "Peruuta", IDCANCEL, 125, 100, 60, 14
}

IDD_EDITACCEL DIALOG 0, 0, 285, 165
CAPTION "Muokkaa pikatoimintoja"
STYLE WS_POPUPWINDOW | WS_CAPTION | WS_THICKFRAME
FONT 9, "MS Shell Dlg"
{
    LTEXT "Avain&luettelo:", -1, 5, 7, 100, 12
    CONTROL "", lst1, "SysListView32", LVS_NOSORTHEADER | LVS_AUTOARRANGE | LVS_NOLABELWRAP | LVS_SHOWSELALWAYS | LVS_SINGLESEL | LVS_REPORT | WS_BORDER | WS_VSCROLL | WS_HSCROLL | WS_TABSTOP, 5, 20, 210, 120
    PUSHBUTTON "&Lisää...", psh1, 220, 20, 60, 14
    PUSHBUTTON "&Muokkaa...", psh2, 220, 40, 60, 14
    PUSHBUTTON "&Poista", psh3, 220, 60, 60, 14
    PUSHBUTTON "&Ylös", psh4, 220, 100, 60, 14
    PUSHBUTTON "&Alas", psh5, 220, 120, 60, 14
    DEFPUSHBUTTON "OK", IDOK, 155, 145, 60, 14
    PUSHBUTTON "Peruuta", IDCANCEL, 220, 145, 60, 14
    PUSHBUTTON "Poista k&aikki", psh6, 5, 145, 79, 14
}

IDD_ADDSTR DIALOG 0, 0, 255, 115
CAPTION "Lisää &merkkijono"
STYLE WS_POPUPWINDOW | WS_CAPTION | WS_THICKFRAME
FONT 9, "MS Shell Dlg"
{
    LTEXT "Merkkijonon &ID:", -1, 5, 7, 50, 12
    COMBOBOX cmb1, 60, 5, 134, 200, CBS_HASSTRINGS | CBS_AUTOHSCROLL | CBS_DROPDOWN | WS_BORDER | WS_VSCROLL | WS_TABSTOP
    PUSHBUTTON "&...", psh1, 195, 5, 15, 14
    LTEXT "Merkkijono:", -1, 5, 27, 54, 12
    EDITTEXT edt1, 60, 25, 190, 45, ES_WANTRETURN | ES_AUTOVSCROLL | ES_MULTILINE | WS_VSCROLL
    AUTOCHECKBOX "Ko&rvaa ""\\r\\n"" merkillä ""\\n""", chx1, 60, 75, 190, 14
    DEFPUSHBUTTON "OK", IDOK, 125, 95, 60, 14
    PUSHBUTTON "Peruuta", IDCANCEL, 190, 95, 60, 14
}

IDD_MODIFYSTR DIALOG 0, 0, 255, 115
CAPTION "Muokkaa merkkijonoa"
STYLE WS_POPUPWINDOW | WS_CAPTION | WS_THICKFRAME
FONT 9, "MS Shell Dlg"
{
    LTEXT "Merkkijonon &ID:", -1, 5, 7, 50, 12
    COMBOBOX cmb1, 60, 5, 134, 200, CBS_HASSTRINGS | CBS_AUTOHSCROLL | CBS_DROPDOWN | WS_BORDER | WS_VSCROLL | WS_TABSTOP
    PUSHBUTTON "&...", psh1, 195, 5, 15, 14
    LTEXT "Merkkijono:", -1, 5, 27, 54, 12
    EDITTEXT edt1, 60, 25, 190, 45, ES_WANTRETURN | ES_AUTOVSCROLL | ES_MULTILINE | WS_VSCROLL
    AUTOCHECKBOX "Ko&rvaa ""\\r\\n"" merkillä ""\\n""", chx1, 60, 75, 190, 14
    DEFPUSHBUTTON "OK", IDOK, 125, 95, 60, 14
    PUSHBUTTON "Peruuta", IDCANCEL, 190, 95, 60, 14
}

IDD_STRINGS DIALOG 0, 0, 325, 160
CAPTION "Merkkijonotaulukko"
STYLE WS_POPUPWINDOW | WS_CAPTION | WS_THICKFRAME
FONT 9, "MS Shell Dlg"
{
    LTEXT "M&erkkijonot:", -1, 5, 7, 100, 12
    CONTROL "", lst1, "SysListView32", LVS_NOSORTHEADER | LVS_AUTOARRANGE | LVS_NOLABELWRAP | LVS_SHOWSELALWAYS | LVS_SINGLESEL | LVS_REPORT | WS_BORDER | WS_VSCROLL | WS_HSCROLL | WS_TABSTOP, 5, 20, 315, 115
    PUSHBUTTON "&Lisää...", psh1, 130, 3, 60, 14
    PUSHBUTTON "&Muokkaa...", psh2, 195, 3, 60, 14
    PUSHBUTTON "&Poista", psh3, 260, 3, 60, 14
    DEFPUSHBUTTON "OK", IDOK, 195, 140, 60, 14
    PUSHBUTTON "Peruuta", IDCANCEL, 260, 140, 60, 14
    PUSHBUTTON "Poista k&aikki", psh4, 5, 140, 75, 14
}

IDD_ADDMITEM DIALOG 0, 0, 210, 200
CAPTION "Lisää valikkokohde"
STYLE DS_MODALFRAME | WS_POPUPWINDOW | WS_CAPTION
FONT 9, "MS Shell Dlg"
{
    LTEXT "&Otsikko:", -1, 5, 7, 55, 12
    COMBOBOX cmb1, 65, 6, 140, 200, CBS_AUTOHSCROLL | CBS_DROPDOWN | WS_BORDER | WS_VSCROLL | WS_TABSTOP
    LTEXT "Ko&mennon ID:", -1, 5, 32, 55, 12
    COMBOBOX cmb2, 65, 30, 125, 200, CBS_AUTOHSCROLL | CBS_DROPDOWN | WS_BORDER | WS_VSCROLL | WS_TABSTOP
    PUSHBUTTON "&...", psh1, 190, 30, 15, 14
    AUTOCHECKBOX "&GRAYED", chx1, 5, 60, 60, 14
    AUTOCHECKBOX "&BITMAP", chx3, 135, 60, 60, 14
    AUTOCHECKBOX "&OWNERDRAW", chx4, 5, 80, 65, 14
    AUTOCHECKBOX "&CHECKED", chx5, 75, 80, 60, 14
    AUTOCHECKBOX "SE&PARATOR", chx6, 140, 80, 60, 14
    AUTOCHECKBOX "MENU&BARBREAK", chx7, 5, 100, 75, 14
    AUTOCHECKBOX "MENUB&REAK", chx8, 85, 100, 70, 14
    AUTOCHECKBOX "&DEFAULT", chx9, 5, 120, 60, 14
    AUTOCHECKBOX "&HILITE", chx10, 70, 120, 60, 14
    AUTOCHECKBOX "RADIOCHEC&K", chx11, 135, 120, 60, 14
    AUTOCHECKBOX "RIGH&TORDER", chx12, 5, 139, 60, 14
    AUTOCHECKBOX "RIGHT&JUSTIFY", chx13, 70, 140, 70, 14
    LTEXT "O&hjeen ID:", -1, 5, 162, 45, 12
    COMBOBOX cmb3, 55, 160, 100, 300, CBS_AUTOHSCROLL | CBS_DROPDOWN | WS_BORDER | WS_VSCROLL | WS_TABSTOP
    DEFPUSHBUTTON "OK", IDOK, 80, 180, 60, 14
    PUSHBUTTON "Peruuta", IDCANCEL, 145, 180, 60, 14
}

IDD_MODIFYMITEM DIALOG 0, 0, 210, 200
CAPTION "Muokkaa valikkokohdetta"
STYLE DS_MODALFRAME | WS_POPUPWINDOW | WS_CAPTION
FONT 9, "MS Shell Dlg"
{
    LTEXT "&Otsikko:", -1, 5, 7, 55, 12
    COMBOBOX cmb1, 65, 6, 140, 200, CBS_AUTOHSCROLL | CBS_DROPDOWN | WS_BORDER | WS_VSCROLL | WS_TABSTOP
    LTEXT "Ko&mennon ID:", -1, 5, 32, 55, 12
    COMBOBOX cmb2, 65, 30, 125, 200, CBS_AUTOHSCROLL | CBS_DROPDOWN | WS_BORDER | WS_VSCROLL | WS_TABSTOP
    PUSHBUTTON "&...", psh1, 190, 30, 15, 14
    AUTOCHECKBOX "&GRAYED", chx1, 5, 60, 60, 14
    AUTOCHECKBOX "&BITMAP", chx3, 135, 60, 60, 14
    AUTOCHECKBOX "&OWNERDRAW", chx4, 5, 80, 65, 14
    AUTOCHECKBOX "&CHECKED", chx5, 75, 80, 60, 14
    AUTOCHECKBOX "SE&PARATOR", chx6, 140, 80, 60, 14
    AUTOCHECKBOX "MENU&BARBREAK", chx7, 5, 100, 75, 14
    AUTOCHECKBOX "MENUB&REAK", chx8, 85, 100, 70, 14
    AUTOCHECKBOX "&DEFAULT", chx9, 5, 120, 60, 14
    AUTOCHECKBOX "&HILITE", chx10, 70, 120, 60, 14
    AUTOCHECKBOX "RADIOCHEC&K", chx11, 135, 120, 60, 14
    AUTOCHECKBOX "RIGH&TORDER", chx12, 5, 139, 60, 14
    AUTOCHECKBOX "RIGHT&JUSTIFY", chx13, 70, 140, 70, 14
    LTEXT "O&hjeen ID:", -1, 5, 162, 45, 12
    COMBOBOX cmb3, 55, 160, 100, 300, CBS_AUTOHSCROLL | CBS_DROPDOWN | WS_BORDER | WS_VSCROLL | WS_TABSTOP
    DEFPUSHBUTTON "OK", IDOK, 80, 180, 60, 14
    PUSHBUTTON "Peruuta", IDCANCEL, 145, 180, 60, 14
}

IDD_EDITMENU DIALOG 0, 0, 325, 160
CAPTION "Muokkaa valikkoresurssia"
STYLE WS_POPUPWINDOW | WS_CAPTION | WS_THICKFRAME
FONT 9, "MS Shell Dlg"
{
    LTEXT "Valikkore&surssi:", -1, 5, 7, 85, 12
    CONTROL "", lst1, "SysListView32", LVS_NOSORTHEADER | LVS_AUTOARRANGE | LVS_NOLABELWRAP | LVS_SHOWSELALWAYS | LVS_SINGLESEL | LVS_REPORT | WS_BORDER | WS_VSCROLL | WS_HSCROLL | WS_TABSTOP, 5, 20, 315, 115
    PUSHBUTTON "&Lisää...", psh1, 95, 3, 50, 14
    PUSHBUTTON "&Muokkaa...", psh2, 150, 3, 50, 14
    PUSHBUTTON "Pois&ta", psh3, 205, 3, 50, 14
    PUSHBUTTON "&Ylös", psh4, 5, 140, 40, 14
    PUSHBUTTON "&Alas", psh5, 50, 140, 40, 14
    PUSHBUTTON "&Vasen", psh6, 95, 140, 40, 14
    PUSHBUTTON "&Oikea", psh7, 140, 140, 41, 14
    AUTOCHECKBOX "Laa&jennettu", chx1, 260, 3, 60, 14
    DEFPUSHBUTTON "OK", IDOK, 195, 140, 60, 14
    PUSHBUTTON "Peruuta", IDCANCEL, 260, 140, 60, 14
}

IDD_DLGPROP DIALOG 0, 0, 235, 315
CAPTION "Dialogin ominaisuudet"
STYLE DS_MODALFRAME | WS_POPUPWINDOW | WS_CAPTION
FONT 9, "MS Shell Dlg"
{
    LTEXT "&Otsikko:", -1, 5, 7, 85, 11
    COMBOBOX cmb1, 5, 20, 225, 300, CBS_HASSTRINGS | CBS_AUTOHSCROLL | CBS_DROPDOWN | WS_BORDER | WS_VSCROLL | WS_TABSTOP
    AUTOCHECKBOX "&Laajennettu dialogi", chx1, 100, 5, 86, 14
    LTEXT "&Vasen:", -1, 5, 40, 33, 10
    EDITTEXT edt1, 5, 53, 30, 14, ES_NUMBER | ES_RIGHT
    CONTROL "", scr1, "msctls_updown32", UDS_NOTHOUSANDS | UDS_ARROWKEYS | UDS_AUTOBUDDY | UDS_ALIGNRIGHT | UDS_SETBUDDYINT, 23, 53, 12, 20
    LTEXT "&Ylä:", -1, 50, 40, 33, 10
    EDITTEXT edt2, 50, 53, 30, 14, ES_NUMBER | ES_RIGHT
    CONTROL "", scr2, "msctls_updown32", UDS_NOTHOUSANDS | UDS_ARROWKEYS | UDS_AUTOBUDDY | UDS_ALIGNRIGHT | UDS_SETBUDDYINT, 53, 53, 12, 20
    LTEXT "&Leveys:", -1, 95, 40, 33, 10
    EDITTEXT edt3, 95, 53, 30, 14, ES_NUMBER | ES_RIGHT
    CONTROL "", scr3, "msctls_updown32", UDS_NOTHOUSANDS | UDS_ARROWKEYS | UDS_AUTOBUDDY | UDS_ALIGNRIGHT | UDS_SETBUDDYINT, 129, 56, 12, 20
    LTEXT "&Korkeus:", -1, 142, 40, 33, 10
    EDITTEXT edt4, 142, 53, 30, 14, ES_NUMBER | ES_RIGHT
    CONTROL "", scr4, "msctls_updown32", UDS_NOTHOUSANDS | UDS_ARROWKEYS | UDS_AUTOBUDDY | UDS_ALIGNRIGHT | UDS_SETBUDDYINT, 162, 53, 12, 20
    LTEXT "&Luokan nimi:", -1, 5, 73, 85, 11
    COMBOBOX cmb2, 5, 88, 115, 200, CBS_HASSTRINGS | CBS_AUTOHSCROLL | CBS_DROPDOWN | WS_BORDER | WS_VSCROLL | WS_TABSTOP
    LTEXT "O&hjeen ID:", -1, 125, 73, 64, 11
    COMBOBOX cmb3, 125, 88, 65, 200, CBS_HASSTRINGS | CBS_AUTOHSCROLL | CBS_DROPDOWN | WS_BORDER | WS_VSCROLL | WS_TABSTOP
    LTEXT "&Fontin nimi:", -1, 5, 105, 80, 11
    COMBOBOX cmb4, 6, 118, 100, 200, CBS_HASSTRINGS | CBS_SORT | CBS_AUTOHSCROLL | CBS_DROPDOWN | WS_BORDER | WS_VSCROLL | WS_TABSTOP
    LTEXT "&Koko:", -1, 110, 105, 38, 12
    EDITTEXT edt5, 110, 118, 25, 14, ES_NUMBER
    AUTOCHECKBOX "&B", chx2, 140, 118, 20, 14
    AUTOCHECKBOX "&I", chx3, 165, 118, 20, 14
    LTEXT "Me&rkistö:", -1, 5, 138, 80, 11
    COMBOBOX cmb5, 5, 148, 100, 100, CBS_AUTOHSCROLL | CBS_DROPDOWNLIST | WS_VSCROLL | WS_TABSTOP
    LTEXT "&Valikon nimi:", -1, 110, 138, 55, 11
    COMBOBOX cmb6, 110, 148, 99, 300, CBS_HASSTRINGS | CBS_AUTOHSCROLL | CBS_DROPDOWN | WS_BORDER | WS_VSCROLL | WS_TABSTOP
    LTEXT "&Tyyli:", -1, 5, 168, 45, 11
    RTEXT "0x", -1, 52, 169, 10, 11
    EDITTEXT edt6, 67, 165, 45, 14, ES_AUTOHSCROLL
    LISTBOX lst1, 5, 183, 110, 110, LBS_DISABLENOSCROLL | LBS_NOINTEGRALHEIGHT | LBS_HASSTRINGS | LBS_MULTIPLESEL | WS_VSCROLL | WS_HSCROLL | WS_TABSTOP
    LTEXT "&ExTyyli:", -1, 120, 168, 48, 11
    RTEXT "0x", -1, 170, 169, 10, 11
    EDITTEXT edt7, 185, 165, 45, 14, ES_AUTOHSCROLL
    LISTBOX lst2, 120, 183, 110, 110, LBS_DISABLENOSCROLL | LBS_NOINTEGRALHEIGHT | LBS_HASSTRINGS | LBS_MULTIPLESEL | WS_VSCROLL | WS_HSCROLL | WS_TABSTOP
    DEFPUSHBUTTON "OK", IDOK, 106, 298, 60, 14
    PUSHBUTTON "Peruuta", IDCANCEL, 171, 298, 60, 14
}

IDD_CTRLPROP DIALOG 0, 0, 235, 330
CAPTION "Ohjausobjektin ominaisuudet"
STYLE DS_MODALFRAME | WS_POPUPWINDOW | WS_CAPTION
FONT 9, "MS Shell Dlg"
{
    LTEXT "E&simääritelty::", -1, 5, 7, 68, 12
    COMBOBOX cmb1, 75, 5, 120, 55, CBS_HASSTRINGS | CBS_AUTOHSCROLL | CBS_DROPDOWN | WS_BORDER | WS_VSCROLL | WS_TABSTOP
    CONTROL "", ctl1, "ToolbarWindow32", TBSTYLE_FLAT | TBSTYLE_WRAPABLE | TBSTYLE_TOOLTIPS | CCS_NODIVIDER | CCS_NORESIZE, 5, 22, 185, 30
    LTEXT "&Otsikko:", -1, 5, 55, 75, 12
    COMBOBOX cmb2, 5, 65, 195, 300, CBS_HASSTRINGS | CBS_AUTOHSCROLL | CBS_DROPDOWN | WS_BORDER | WS_VSCROLL | WS_TABSTOP
    PUSHBUTTON "&OLE...", psh2, 205, 65, 25, 14
    LTEXT "&Vasen:", -1, 5, 85, 33, 11
    EDITTEXT edt1, 5, 99, 25, 14, ES_NUMBER | ES_RIGHT
    CONTROL "", scr1, "msctls_updown32", UDS_NOTHOUSANDS | UDS_ARROWKEYS | UDS_AUTOBUDDY | UDS_ALIGNRIGHT | UDS_SETBUDDYINT, 20, 99, 12, 20
    LTEXT "&Ylä:", -1, 40, 85, 33, 11
    EDITTEXT edt2, 40, 99, 25, 14, ES_NUMBER | ES_RIGHT
    CONTROL "", scr2, "msctls_updown32", UDS_NOTHOUSANDS | UDS_ARROWKEYS | UDS_AUTOBUDDY | UDS_ALIGNRIGHT | UDS_SETBUDDYINT, 55, 99, 12, 20
    LTEXT "&Leveys:", -1, 75, 85, 33, 11
    EDITTEXT edt3, 75, 99, 25, 14, ES_NUMBER | ES_RIGHT
    CONTROL "", scr3, "msctls_updown32", UDS_NOTHOUSANDS | UDS_ARROWKEYS | UDS_AUTOBUDDY | UDS_ALIGNRIGHT | UDS_SETBUDDYINT, 90, 99, 12, 20
    LTEXT "&Korkeus:", -1, 111, 85, 33, 11
    EDITTEXT edt4, 110, 99, 25, 14, ES_NUMBER | ES_RIGHT
    CONTROL "", scr4, "msctls_updown32", UDS_NOTHOUSANDS | UDS_ARROWKEYS | UDS_AUTOBUDDY | UDS_ALIGNRIGHT | UDS_SETBUDDYINT, 125, 99, 12, 20
    LTEXT "&ID:", -1, 150, 85, 70, 12
    COMBOBOX cmb3, 150, 99, 80, 300, CBS_HASSTRINGS | CBS_AUTOHSCROLL | CBS_DROPDOWN | WS_BORDER | WS_VSCROLL | WS_TABSTOP
    LTEXT "Ikkunaluo&kan nimi:", -1, 5, 119, 100, 12
    COMBOBOX cmb4, 5, 133, 115, 200, CBS_HASSTRINGS | CBS_AUTOHSCROLL | CBS_DROPDOWN | WS_BORDER | WS_VSCROLL | WS_TABSTOP
    LTEXT "O&hjeen ID:", -1, 125, 119, 70, 12
    COMBOBOX cmb5, 125, 133, 65, 200, CBS_HASSTRINGS | CBS_AUTOHSCROLL | CBS_DROPDOWN | WS_BORDER | WS_VSCROLL | WS_TABSTOP
    LTEXT "&Tyyli:", -1, 5, 153, 45, 12
    RTEXT "0x", -1, 54, 153, 10, 12
    EDITTEXT edt6, 70, 151, 45, 14, ES_AUTOHSCROLL
    LISTBOX lst1, 5, 167, 110, 120, LBS_DISABLENOSCROLL | LBS_NOINTEGRALHEIGHT | LBS_HASSTRINGS | LBS_MULTIPLESEL | WS_VSCROLL | WS_HSCROLL | WS_TABSTOP
    LTEXT "&ExTyyli:", -1, 120, 153, 50, 12
    RTEXT "0x", -1, 172, 153, 10, 12
    EDITTEXT edt7, 185, 151, 45, 14, ES_AUTOHSCROLL
    LISTBOX lst2, 120, 167, 110, 120, LBS_DISABLENOSCROLL | LBS_NOINTEGRALHEIGHT | LBS_HASSTRINGS | LBS_MULTIPLESEL | WS_VSCROLL | WS_HSCROLL | WS_TABSTOP
    DEFPUSHBUTTON "OK", IDOK, 170, 293, 60, 14
    PUSHBUTTON "Peruuta", IDCANCEL, 170, 309, 60, 14
    PUSHBUTTON "&Data...", psh1, 5, 293, 90, 14
    PUSHBUTTON "Merkk&ijonoluettelo...", psh3, 5, 309, 90, 14
}

IDD_ADDCTRL DIALOG 0, 0, 235, 330
CAPTION "Lisää ohjaus"
STYLE DS_MODALFRAME | WS_POPUPWINDOW | WS_CAPTION
FONT 9, "MS Shell Dlg"
{
    LTEXT "E&simääritelty::", -1, 5, 7, 68, 12
    COMBOBOX cmb1, 75, 5, 120, 55, CBS_HASSTRINGS | CBS_AUTOHSCROLL | CBS_DROPDOWN | WS_BORDER | WS_VSCROLL | WS_TABSTOP
    CONTROL "", ctl1, "ToolbarWindow32", TBSTYLE_FLAT | TBSTYLE_WRAPABLE | TBSTYLE_TOOLTIPS | CCS_NODIVIDER | CCS_NORESIZE, 5, 22, 185, 30
    LTEXT "&Otsikko:", -1, 5, 55, 75, 12
    COMBOBOX cmb2, 5, 65, 195, 300, CBS_HASSTRINGS | CBS_AUTOHSCROLL | CBS_DROPDOWN | WS_BORDER | WS_VSCROLL | WS_TABSTOP
    PUSHBUTTON "&OLE...", psh2, 205, 65, 25, 14
    LTEXT "&Vasen:", -1, 5, 85, 33, 11
    EDITTEXT edt1, 5, 99, 25, 14, ES_NUMBER | ES_RIGHT
    CONTROL "", scr1, "msctls_updown32", UDS_NOTHOUSANDS | UDS_ARROWKEYS | UDS_AUTOBUDDY | UDS_ALIGNRIGHT | UDS_SETBUDDYINT, 20, 99, 12, 20
    LTEXT "&Ylä:", -1, 40, 85, 33, 11
    EDITTEXT edt2, 40, 99, 25, 14, ES_NUMBER | ES_RIGHT
    CONTROL "", scr2, "msctls_updown32", UDS_NOTHOUSANDS | UDS_ARROWKEYS | UDS_AUTOBUDDY | UDS_ALIGNRIGHT | UDS_SETBUDDYINT, 55, 99, 12, 20
    LTEXT "&Leveys:", -1, 75, 85, 33, 11
    EDITTEXT edt3, 75, 99, 25, 14, ES_NUMBER | ES_RIGHT
    CONTROL "", scr3, "msctls_updown32", UDS_NOTHOUSANDS | UDS_ARROWKEYS | UDS_AUTOBUDDY | UDS_ALIGNRIGHT | UDS_SETBUDDYINT, 90, 99, 12, 20
    LTEXT "&Korkeus:", -1, 111, 85, 33, 11
    EDITTEXT edt4, 110, 99, 25, 14, ES_NUMBER | ES_RIGHT
    CONTROL "", scr4, "msctls_updown32", UDS_NOTHOUSANDS | UDS_ARROWKEYS | UDS_AUTOBUDDY | UDS_ALIGNRIGHT | UDS_SETBUDDYINT, 125, 99, 12, 20
    LTEXT "&ID:", -1, 150, 85, 70, 12
    COMBOBOX cmb3, 150, 99, 80, 300, CBS_HASSTRINGS | CBS_AUTOHSCROLL | CBS_DROPDOWN | WS_BORDER | WS_VSCROLL | WS_TABSTOP
    LTEXT "Ikkunaluo&kan nimi:", -1, 5, 119, 100, 12
    COMBOBOX cmb4, 5, 133, 115, 200, CBS_HASSTRINGS | CBS_AUTOHSCROLL | CBS_DROPDOWN | WS_BORDER | WS_VSCROLL | WS_TABSTOP
    LTEXT "O&hjeen ID:", -1, 125, 119, 70, 12
    COMBOBOX cmb5, 125, 133, 65, 200, CBS_HASSTRINGS | CBS_AUTOHSCROLL | CBS_DROPDOWN | WS_BORDER | WS_VSCROLL | WS_TABSTOP
    LTEXT "&Tyyli:", -1, 5, 153, 45, 12
    RTEXT "0x", -1, 54, 153, 10, 12
    EDITTEXT edt6, 70, 151, 45, 14, ES_AUTOHSCROLL
    LISTBOX lst1, 5, 167, 110, 120, LBS_DISABLENOSCROLL | LBS_NOINTEGRALHEIGHT | LBS_HASSTRINGS | LBS_MULTIPLESEL | WS_VSCROLL | WS_HSCROLL | WS_TABSTOP
    LTEXT "&ExTyyli:", -1, 120, 153, 50, 12
    RTEXT "0x", -1, 172, 153, 10, 12
    EDITTEXT edt7, 185, 151, 45, 14, ES_AUTOHSCROLL
    LISTBOX lst2, 120, 167, 110, 120, LBS_DISABLENOSCROLL | LBS_NOINTEGRALHEIGHT | LBS_HASSTRINGS | LBS_MULTIPLESEL | WS_VSCROLL | WS_HSCROLL | WS_TABSTOP
    DEFPUSHBUTTON "OK", IDOK, 170, 293, 60, 14
    PUSHBUTTON "Peruuta", IDCANCEL, 170, 309, 60, 14
    PUSHBUTTON "&Data...", psh1, 5, 293, 90, 14
    PUSHBUTTON "Merkk&ijonoluettelo...", psh3, 5, 309, 90, 14
}

IDD_IDASSOC DIALOG 0, 0, 200, 220
CAPTION "ID assosiaatio"
STYLE DS_MODALFRAME | WS_POPUPWINDOW | WS_CAPTION
FONT 9, "MS Shell Dlg"
{
    LTEXT "ID &assosiaatio:", -1, 5, 5, 116, 12
    CONTROL "", lst1, "SysListView32", LVS_SHOWSELALWAYS | LVS_SINGLESEL | LVS_REPORT | WS_BORDER | WS_TABSTOP, 5, 20, 190, 150
    PUSHBUTTON "&Palauta kaikki", psh2, 5, 175, 85, 14
    PUSHBUTTON "&Muokkaa", psh1, 135, 175, 60, 14
    DEFPUSHBUTTON "OK", IDOK, 70, 200, 60, 14
    PUSHBUTTON "Peruuta", IDCANCEL, 135, 200, 60, 14
}

IDD_MODIFYASSOC DIALOG 0, 0, 165, 68
CAPTION "Muokkaa ID assosiaatiota"
STYLE DS_MODALFRAME | WS_POPUPWINDOW | WS_CAPTION
FONT 9, "MS Shell Dlg"
{
    RTEXT "ID &tyyppi:", -1, 5, 7, 65, 12
    EDITTEXT edt1, 80, 5, 80, 14, WS_DISABLED
    RTEXT "ID:n etuliite:", -1, 5, 32, 65, 12
    EDITTEXT edt2, 80, 28, 80, 14, ES_AUTOHSCROLL
    DEFPUSHBUTTON "OK", IDOK, 35, 50, 60, 14
    PUSHBUTTON "Peruuta", IDCANCEL, 100, 50, 60, 14
}

IDD_IDLIST DIALOG 0, 0, 200, 300
CAPTION "Luettelo resurssitunnuksista"
STYLE WS_OVERLAPPEDWINDOW
EXSTYLE WS_EX_TOOLWINDOW
FONT 9, "MS Shell Dlg"
{
    COMBOBOX cmb1, 0, 0, 200, 300, CBS_HASSTRINGS | CBS_SORT | CBS_OWNERDRAWFIXED | CBS_DROPDOWNLIST | WS_VSCROLL | WS_TABSTOP
    CONTROL "", lst1, "SysListView32", LVS_REPORT | WS_BORDER | WS_VSCROLL | WS_HSCROLL | WS_TABSTOP, 0, 15, 200, 285
}

IDD_CONFIG DIALOG 0, 0, 210, 285
CAPTION "Konfiguraatio"
STYLE DS_MODALFRAME | WS_POPUPWINDOW | WS_CAPTION
FONT 9, "MS Shell Dlg"
{
    AUTOCHECKBOX "Näytä &koko tiedostopolku otsikkorivillä", chx1, 5, 5, 200, 14
    AUTOCHECKBOX "Älä käytä ID-&makroja", chx2, 5, 25, 200, 14
    AUTOCHECKBOX "Jatka edellisen ikkunan &sijainnista", chx3, 5, 45, 200, 14
    AUTOCHECKBOX "Lataa lähellä oleva ""&resource.h"" automaattisesti", chx4, 5, 65, 200, 14
    AUTOCHECKBOX "Näytä automaattisesti resurssien ID-&luettelo", chx5, 5, 85, 200, 14
    AUTOCHECKBOX "Näytä pisteet &dialogin muokkauksessa", chx6, 5, 105, 200, 14
    RTEXT "Yhdistelmäruudun kork:", -1, 10, 127, 75, 12
    EDITTEXT edt1, 90, 125, 34, 14, ES_NUMBER | ES_RIGHT
    CONTROL "", scr1, "msctls_updown32", UDS_NOTHOUSANDS | UDS_ARROWKEYS | UDS_AUTOBUDDY | UDS_ALIGNRIGHT | UDS_SETBUDDYINT, 129, 49, 12, 20
    AUTOCHECKBOX "&Sanan rivitys", chx9, 135, 125, 70, 14
    AUTOCHECKBOX "Kysy ""&resource.h"" päivityksestä", chx7, 5, 145, 200, 14
    AUTOCHECKBOX "Pakkaa EXE-tiedosto &UPX:llä tallennuksessa", chx8, 5, 165, 200, 14
    PUSHBUTTON "&Fontit...", psh4, 5, 185, 200, 14
    PUSHBUTTON "Esimääritetyt &makrot...", psh1, 5, 205, 93, 14
    PUSHBUTTON "Aseta polu&t...", psh2, 107, 205, 98, 14
    RTEXT "&OLE-ohjauksien nimet:", -1, 5, 227, 80, 12
    COMBOBOX cmb1, 90, 225, 75, 300, CBS_HASSTRINGS | CBS_AUTOHSCROLL | CBS_DROPDOWN | WS_VSCROLL | WS_TABSTOP
    AUTOCHECKBOX "Luo &varmuuskopio", chx10, 5, 245, 75, 15
    RTEXT "Kopion loppuliite:", -1, 90, 245, 60, 15
    COMBOBOX cmb2, 158, 244, 45, 300, CBS_HASSTRINGS | CBS_AUTOHSCROLL | CBS_DROPDOWN | WS_VSCROLL | WS_TABSTOP
    DEFPUSHBUTTON "OK", IDOK, 100, 265, 50, 14
    PUSHBUTTON "Peruuta", IDCANCEL, 155, 265, 50, 14
    PUSHBUTTON "&Palauta kaikki", psh3, 5, 265, 75, 14
}

IDD_ADDRESID DIALOG 0, 0, 165, 90
CAPTION "Lisää resurssin ID"
STYLE DS_MODALFRAME | WS_POPUPWINDOW | WS_CAPTION
FONT 9, "MS Shell Dlg"
{
    RTEXT "ID:n &tyyppi:", -1, 10, 7, 50, 14
    COMBOBOX cmb1, 65, 5, 95, 300, CBS_AUTOHSCROLL | CBS_DROPDOWNLIST | WS_VSCROLL | WS_TABSTOP
    RTEXT "ID:n &nimi:", -1, 10, 27, 50, 14
    EDITTEXT edt1, 65, 25, 75, 14, ES_AUTOHSCROLL
    RTEXT "Kokona&isluku:", -1, 10, 47, 50, 14
    EDITTEXT edt2, 65, 45, 48, 14, ES_AUTOHSCROLL
    CONTROL "", scr1, "msctls_updown32", UDS_NOTHOUSANDS | UDS_ARROWKEYS | UDS_AUTOBUDDY | UDS_ALIGNRIGHT | UDS_SETBUDDYINT, 129, 49, 12, 20
    PUSHBUTTON "&Auto", psh1, 115, 45, 45, 14
    DEFPUSHBUTTON "OK", IDOK, 20, 70, 60, 14
    PUSHBUTTON "Peruuta", IDCANCEL, 85, 70, 60, 14
}

IDD_MODIFYRESID DIALOG 0, 0, 165, 90
CAPTION "Muokkaa resurssitunnusta"
STYLE DS_MODALFRAME | WS_POPUPWINDOW | WS_CAPTION
FONT 9, "MS Shell Dlg"
{
    RTEXT "ID:n &nimi:", -1, 10, 12, 50, 14, SS_REALSIZEIMAGE | NOT WS_GROUP
    EDITTEXT edt1, 65, 10, 95, 14, ES_AUTOHSCROLL
    RTEXT "ID:n &tyyppi:", -1, 10, 32, 50, 14
    EDITTEXT edt2, 65, 30, 95, 14, ES_READONLY
    RTEXT "Kokona&isluku:", -1, 10, 52, 50, 14
    EDITTEXT edt3, 65, 50, 48, 14, ES_AUTOHSCROLL
    CONTROL "", scr1, "msctls_updown32", UDS_NOTHOUSANDS | UDS_ARROWKEYS | UDS_AUTOBUDDY | UDS_ALIGNRIGHT | UDS_SETBUDDYINT, 129, 49, 12, 20
    DEFPUSHBUTTON "OK", IDOK, 20, 70, 60, 14
    PUSHBUTTON "Peruuta", IDCANCEL, 85, 70, 60, 14
}

IDD_ADVICERESH DIALOG 0, 0, 209, 184
CAPTION "Neuvoja tiedoston ""resource.h"" muuttamisessa"
STYLE DS_MODALFRAME | WS_POPUPWINDOW | WS_CAPTION
FONT 9, "MS Shell Dlg"
{
    LTEXT "Muokkaa tiedostoa ""resource.h"" seuraavasti", -1, 10, 10, 195, 20
    EDITTEXT edt1, 10, 30, 190, 130, ES_READONLY | ES_MULTILINE
    DEFPUSHBUTTON "OK", IDOK, 140, 165, 60, 14
    PUSHBUTTON "No&llaa muokkaus", psh1, 10, 165, 90, 14
}

IDD_CLONEINNEWNAME DIALOG 0, 0, 215, 75
CAPTION "Klooni uudessa nimessä"
STYLE DS_MODALFRAME | WS_POPUPWINDOW | WS_CAPTION
FONT 9, "MS Shell Dlg"
{
    LTEXT "Resurssin &tyyppi:", -1, 5, 7, 70, 12
    COMBOBOX cmb1, 75, 5, 135, 200, CBS_HASSTRINGS | CBS_AUTOHSCROLL | CBS_DROPDOWN | WS_DISABLED | WS_BORDER | WS_VSCROLL | WS_TABSTOP
    LTEXT "Resurssin &nimi:", -1, 5, 32, 70, 12
    COMBOBOX cmb2, 75, 30, 120, 200, CBS_HASSTRINGS | CBS_AUTOHSCROLL | CBS_DROPDOWN | WS_BORDER | WS_VSCROLL | WS_TABSTOP
    PUSHBUTTON "&...", psh1, 195, 30, 15, 14
    DEFPUSHBUTTON "OK", IDOK, 35, 55, 60, 14
    PUSHBUTTON "Peruuta", IDCANCEL, 115, 55, 60, 14
}

IDD_CLONEINNEWLANG DIALOG 0, 0, 215, 105
CAPTION "Klooni uudessa kielessä"
STYLE DS_MODALFRAME | WS_POPUPWINDOW | WS_CAPTION
FONT 9, "MS Shell Dlg"
{
    LTEXT "Resurssin &tyyppi:", -1, 5, 7, 70, 12
    COMBOBOX cmb1, 75, 5, 135, 200, CBS_HASSTRINGS | CBS_AUTOHSCROLL | CBS_DROPDOWN | WS_DISABLED | WS_BORDER | WS_VSCROLL | WS_TABSTOP
    LTEXT "Resurssin &nimi:", -1, 5, 32, 70, 12
    COMBOBOX cmb2, 75, 30, 120, 200, CBS_HASSTRINGS | CBS_AUTOHSCROLL | CBS_DROPDOWN | WS_DISABLED | WS_BORDER | WS_VSCROLL | WS_TABSTOP
    LTEXT "Resurssin kie&li:", -1, 5, 57, 70, 12
    COMBOBOX cmb3, 75, 55, 135, 200, CBS_HASSTRINGS | CBS_AUTOHSCROLL | CBS_DROPDOWN | WS_BORDER | WS_VSCROLL | WS_TABSTOP
    DEFPUSHBUTTON "OK", IDOK, 35, 85, 60, 14
    PUSHBUTTON "Peruuta", IDCANCEL, 115, 85, 60, 14
}

IDD_ITEMSEARCH DIALOG 0, 0, 171, 135
CAPTION "Haku"
STYLE WS_POPUPWINDOW | WS_CAPTION
FONT 9, "MS Shell Dlg"
{
    LTEXT "Haettava &merkkijono:", -1, 4, 10, 100, 14
    EDITTEXT edt1, 5, 25, 160, 15, ES_AUTOHSCROLL
    AUTOCHECKBOX "&Sama kirjainkoko", chx1, 5, 45, 120, 18
    GROUPBOX "Suunta", -1, 5, 65, 160, 42
    AUTORADIOBUTTON "&Ylöspäin", rad1, 15, 80, 60, 14, WS_TABSTOP
    AUTORADIOBUTTON "&Alaspäin", rad2, 90, 80, 60, 14, WS_TABSTOP
    DEFPUSHBUTTON "&Etsi", IDOK, 40, 115, 60, 14
    PUSHBUTTON "Peruuta", IDCANCEL, 105, 115, 60, 14
}

IDD_VERSIONINFO DIALOG 0, 0, 174, 150
CAPTION "Tietoja RisohEditorista"
STYLE DS_MODALFRAME | WS_POPUPWINDOW | WS_CAPTION
FONT 12, "MS Shell Dlg"
{
    ICON IDI_MAIN, -1, 5, 5, 0, 0
    LTEXT "...", stc1, 30, 5, 140, 50
    CTEXT "https://katahiromz.web.fc2.com", stc2, 5, 60, 165, 12, SS_CENTERIMAGE | SS_NOTIFY | NOT WS_GROUP
    CONTROL "...", edt1, "EDIT", ES_READONLY | ES_AUTOHSCROLL | ES_AUTOVSCROLL | ES_MULTILINE | WS_BORDER | WS_VSCROLL | WS_HSCROLL, 5, 75, 165, 50
    DEFPUSHBUTTON "OK", IDOK, 55, 130, 60, 14
}

IDD_ADDMSG DIALOG 0, 0, 255, 105
CAPTION "Lisää viestikohde"
STYLE DS_MODALFRAME | WS_POPUPWINDOW | WS_CAPTION
FONT 9, "MS Shell Dlg"
{
    LTEXT "Viestin &ID:", -1, 5, 7, 50, 12
    COMBOBOX cmb1, 65, 5, 134, 200, CBS_HASSTRINGS | CBS_AUTOHSCROLL | CBS_DROPDOWN | WS_BORDER | WS_VSCROLL | WS_TABSTOP
    PUSHBUTTON "&...", psh1, 200, 5, 15, 14
    LTEXT "&Viesti:", -1, 5, 27, 80, 12
    EDITTEXT edt1, 5, 40, 245, 35, ES_WANTRETURN | ES_AUTOHSCROLL | ES_AUTOVSCROLL | ES_MULTILINE
    DEFPUSHBUTTON "OK", IDOK, 125, 85, 60, 14
    PUSHBUTTON "Peruuta", IDCANCEL, 190, 85, 60, 14
}

IDD_MODIFYMSG DIALOG 0, 0, 255, 105
CAPTION "Muokkaa viestikohdetta"
STYLE DS_MODALFRAME | WS_POPUPWINDOW | WS_CAPTION
FONT 9, "MS Shell Dlg"
{
    LTEXT "Viestin &ID:", -1, 5, 7, 50, 12
    COMBOBOX cmb1, 65, 5, 134, 200, CBS_HASSTRINGS | CBS_AUTOHSCROLL | CBS_DROPDOWN | WS_DISABLED | WS_BORDER | WS_VSCROLL | WS_TABSTOP
    LTEXT "&Viesti:", -1, 5, 27, 80, 12
    EDITTEXT edt1, 5, 40, 245, 35, ES_WANTRETURN | ES_AUTOHSCROLL | ES_AUTOVSCROLL | ES_MULTILINE
    DEFPUSHBUTTON "OK", IDOK, 125, 85, 60, 14
    PUSHBUTTON "Peruuta", IDCANCEL, 190, 85, 60, 14
}

IDD_MESSAGES DIALOG 0, 0, 325, 160
CAPTION "Viestiluettelo"
STYLE WS_POPUPWINDOW | WS_CAPTION | WS_THICKFRAME
FONT 9, "MS Shell Dlg"
{
    LTEXT "Vi&estit:", -1, 5, 7, 80, 12
    CONTROL "", lst1, "SysListView32", LVS_NOSORTHEADER | LVS_AUTOARRANGE | LVS_NOLABELWRAP | LVS_SHOWSELALWAYS | LVS_SINGLESEL | LVS_REPORT | WS_BORDER | WS_VSCROLL | WS_HSCROLL | WS_TABSTOP, 5, 20, 315, 115
    PUSHBUTTON "&Lisää...", psh1, 130, 3, 60, 14
    PUSHBUTTON "&Muokkaa...", psh2, 195, 3, 60, 14
    PUSHBUTTON "&Poista", psh3, 260, 3, 60, 14
    DEFPUSHBUTTON "OK", IDOK, 195, 140, 60, 14
    PUSHBUTTON "Peruuta", IDCANCEL, 260, 140, 60, 14
    PUSHBUTTON "Poista k&aikki", psh4, 5, 140, 75, 14
}

IDD_FONTS DIALOG 0, 0, 195, 110
CAPTION "Fonttien asetukset"
STYLE DS_MODALFRAME | WS_POPUPWINDOW | WS_CAPTION
FONT 9, "MS Shell Dlg"
{
    RTEXT "&Lähde:", -1, 5, 5, 55, 15, SS_CENTERIMAGE | NOT WS_GROUP
    EDITTEXT edt1, 65, 5, 100, 14, ES_READONLY | ES_AUTOHSCROLL
    PUSHBUTTON "...", psh1, 170, 5, 19, 14
    RTEXT "&Binaari:", -1, 5, 25, 55, 15, SS_CENTERIMAGE | NOT WS_GROUP
    EDITTEXT edt2, 65, 25, 100, 14, ES_READONLY | ES_AUTOHSCROLL
    PUSHBUTTON "...", psh2, 170, 25, 19, 14
    GROUPBOX "Esikatselu", -1, 5, 45, 185, 39
    CTEXT "Lähde", stc1, 15, 55, 80, 25, SS_CENTERIMAGE | NOT WS_GROUP
    CTEXT "Binaari", stc2, 100, 55, 85, 25, SS_CENTERIMAGE | NOT WS_GROUP
    DEFPUSHBUTTON "OK", IDOK, 65, 90, 60, 14
    PUSHBUTTON "Peruuta", IDCANCEL, 130, 90, 60, 14
}

IDD_MACROS DIALOG 0, 0, 265, 165
CAPTION "Esimääritetyt makrot"
STYLE WS_POPUPWINDOW | WS_CAPTION | WS_THICKFRAME
FONT 9, "MS Shell Dlg"
{
    LTEXT "Esimääritetyt &makrot:", -1, 5, 0, 100, 15, SS_CENTERIMAGE | NOT WS_GROUP
    CONTROL "", lst1, "SysListView32", LVS_EDITLABELS | LVS_SHOWSELALWAYS | LVS_SINGLESEL | LVS_REPORT | WS_BORDER | WS_TABSTOP, 5, 15, 190, 125
    PUSHBUTTON "&Lisää...", psh1, 200, 15, 60, 14
    PUSHBUTTON "&Muokkaa...", psh2, 200, 35, 60, 14
    PUSHBUTTON "&Poista", psh3, 200, 55, 60, 14
    PUSHBUTTON "Poista k&aikki", psh7, 200, 105, 60, 14
    DEFPUSHBUTTON "OK", IDOK, 135, 145, 60, 14
    PUSHBUTTON "Peruuta", IDCANCEL, 200, 145, 60, 14
    PUSHBUTTON "&Palauta kaikki", psh6, 5, 145, 60, 14
}

IDD_ADDMACRO DIALOG 0, 0, 190, 80
CAPTION "Lisää esimääritelty makro"
STYLE DS_MODALFRAME | WS_POPUPWINDOW | WS_CAPTION
FONT 9, "MS Shell Dlg"
{
    RTEXT "&Avain:", -1, 5, 12, 60, 14
    COMBOBOX cmb1, 70, 10, 110, 200, CBS_DROPDOWN | WS_BORDER | WS_VSCROLL | WS_TABSTOP
    RTEXT "&Arvo:", -1, 5, 37, 60, 14
    COMBOBOX cmb2, 70, 35, 110, 300, CBS_DROPDOWN | WS_BORDER | WS_VSCROLL | WS_TABSTOP
    DEFPUSHBUTTON "OK", IDOK, 60, 60, 60, 14
    PUSHBUTTON "Peruuta", IDCANCEL, 125, 60, 60, 14
}

IDD_EDITMACRO DIALOG 0, 0, 190, 80
CAPTION "Muokkaa esimääriteltyä makroa"
STYLE DS_MODALFRAME | WS_POPUPWINDOW | WS_CAPTION
FONT 9, "MS Shell Dlg"
{
    RTEXT "&Avain:", -1, 5, 12, 60, 14
    COMBOBOX cmb1, 70, 10, 110, 200, CBS_DROPDOWN | WS_DISABLED | WS_BORDER | WS_VSCROLL | WS_TABSTOP
    RTEXT "&Arvo:", -1, 5, 37, 60, 14
    COMBOBOX cmb2, 70, 35, 110, 300, CBS_DROPDOWN | WS_BORDER | WS_VSCROLL | WS_TABSTOP
    DEFPUSHBUTTON "OK", IDOK, 60, 60, 60, 14
    PUSHBUTTON "Peruuta", IDCANCEL, 125, 60, 60, 14
}

IDD_CTRLDATA DIALOG 0, 0, 190, 130
CAPTION "Muokkaa ohjaustietoja"
STYLE DS_MODALFRAME | WS_POPUPWINDOW | WS_CAPTION
FONT 9, "MS Shell Dlg"
{
    LTEXT "&Binaaridata:", -1, 5, 2, 87, 12
    EDITTEXT edt1, 5, 15, 180, 60, ES_AUTOVSCROLL | ES_MULTILINE | WS_VSCROLL
    LTEXT "Voit asettaa ohjaustiedot välilyönnillä erotetuilla 16-bittisillä kokonaisluvuilla.", -1, 5, 80, 180, 25
    DEFPUSHBUTTON "OK", IDOK, 60, 110, 60, 14
    PUSHBUTTON "Peruuta", IDCANCEL, 125, 110, 60, 14
}

IDD_PATHS DIALOG 0, 0, 295, 220
CAPTION "Aseta polut"
STYLE WS_POPUPWINDOW | WS_CAPTION | WS_THICKFRAME
FONT 9, "MS Shell Dlg"
{
    LTEXT "S&isällytä hakemistot:", -1, 5, 5, 102, 12
    LISTBOX lst1, 5, 20, 220, 105, LBS_NOINTEGRALHEIGHT | LBS_HASSTRINGS | LBS_SORT | WS_VSCROLL | WS_HSCROLL | WS_TABSTOP
    PUSHBUTTON "&Lisää...", psh1, 230, 20, 60, 14
    PUSHBUTTON "&Muokkaa...", psh2, 230, 40, 60, 14
    PUSHBUTTON "&Poista", psh3, 230, 60, 60, 14
    PUSHBUTTON "&Ylös", psh4, 230, 80, 60, 14
    PUSHBUTTON "Alas", psh5, 230, 100, 60, 14
    PUSHBUTTON "Poista k&aikki", psh6, 5, 130, 95, 14
    RTEXT "&windres.exe:", stc1, 5, 157, 55, 12
    COMBOBOX cmb1, 70, 155, 155, 300, CBS_HASSTRINGS | CBS_AUTOHSCROLL | CBS_DROPDOWN | WS_VSCROLL | WS_TABSTOP
    PUSHBUTTON "&Selaa...", psh7, 230, 155, 60, 14
    RTEXT "&cpp.exe:", stc2, 5, 177, 55, 12
    COMBOBOX cmb2, 70, 175, 155, 300, CBS_HASSTRINGS | CBS_AUTOHSCROLL | CBS_DROPDOWN | WS_VSCROLL | WS_TABSTOP
    PUSHBUTTON "S&elaa...", psh8, 230, 175, 60, 14
    DEFPUSHBUTTON "OK", IDOK, 165, 200, 60, 14
    PUSHBUTTON "Peruuta", IDCANCEL, 230, 200, 60, 14
    PUSHBUTTON "Palauta k&aikki", psh9, 5, 200, 95, 14
}

IDD_EXP_OPTIONS DIALOG 0, 0, 250, 225
CAPTION "Vientiasetukset"
STYLE DS_MODALFRAME | WS_POPUPWINDOW | WS_CAPTION
FONT 9, "MS Shell Dlg"
{
    ICON IDI_MAIN, -1, 5, 10, 0, 0
    LTEXT "RC-tiedoston vieminen luo joitakin toisiinsa liittyviä tiedostoja. Voit valita seuraavista vaihtoehdoista:", -1, 35, 5, 210, 29
    AUTOCHECKBOX "Käytä Microsoft MESSAGE&TABLEa", chx8, 5, 40, 240, 14
    AUTOCHECKBOX "Erota resurssitiedostot kie&len mukaan", chx1, 5, 60, 240, 14
    AUTOCHECKBOX "Käytä B&EGIN/END-avainsanoja", chx2, 5, 80, 240, 14
    AUTOCHECKBOX "Tee kielestä valittava LANGUAGE_* makrolla", chx3, 5, 100, 240, 14
    AUTOCHECKBOX "Luo &varmuuskopion", chx4, 5, 120, 110, 14
    RTEXT "jälkiliite:", -1, 120, 122, 75, 12
    COMBOBOX cmb1, 200, 120, 45, 300, CBS_HASSTRINGS | CBS_AUTOHSCROLL | CBS_DROPDOWN | WS_VSCROLL | WS_TABSTOP
    AUTOCHECKBOX "Tulosta turhat &kommentit", chx5, 5, 140, 240, 14
    AUTOCHECKBOX "Rivitä ma&nifestlausekkeet #ifndef MSVC ... #endif", chx6, 5, 160, 240, 14
    AUTOCHECKBOX "Tulosta RC-tiedostot &UTF-16 muodossa", chx7, 5, 180, 240, 14
    DEFPUSHBUTTON "OK", IDOK, 120, 205, 60, 14
    PUSHBUTTON "Peruuta", IDCANCEL, 185, 205, 60, 14
}

IDD_LANGS DIALOG 0, 0, 250, 235
CAPTION "Kielet"
STYLE WS_POPUPWINDOW | WS_CAPTION | WS_THICKFRAME
FONT 9, "MS Shell Dlg"
{
    CONTROL "", lst1, "SysListView32", LVS_SHOWSELALWAYS | LVS_SINGLESEL | LVS_REPORT | WS_BORDER | WS_TABSTOP, 5, 5, 240, 179
    RTEXT "&Etsi:", stc1, 5, 192, 45, 12
    COMBOBOX cmb1, 55, 190, 85, 300, CBS_SORT | CBS_DROPDOWN | WS_VSCROLL | WS_TABSTOP
    EDITTEXT edt1, 4, 209, 240, 20, ES_AUTOHSCROLL | ES_AUTOVSCROLL | ES_MULTILINE
}

IDD_CHILD DIALOG 0, 0, 215, 135
CAPTION "Alidialogi"
STYLE WS_CHILD | WS_OVERLAPPEDWINDOW
FONT 9, "MS Shell Dlg"
{
    DEFPUSHBUTTON "OK", IDOK, 35, 115, 60, 14
    PUSHBUTTON "Peruuta", IDCANCEL, 115, 115, 60, 14
}

IDD_DLGINITEDIT DIALOG 0, 0, 325, 165
CAPTION "Muokkaa DLGINIT"
STYLE WS_POPUPWINDOW | WS_CAPTION | WS_THICKFRAME
FONT 9, "MS Shell Dlg"
{
    LTEXT "Vi&estit:", -1, 5, 7, 100, 12
    CONTROL "", lst1, "SysListView32", LVS_NOSORTHEADER | LVS_AUTOARRANGE | LVS_NOLABELWRAP | LVS_SHOWSELALWAYS | LVS_SINGLESEL | LVS_REPORT | WS_BORDER | WS_VSCROLL | WS_HSCROLL | WS_TABSTOP, 5, 20, 250, 120
    PUSHBUTTON "&Lisää...", psh1, 260, 20, 60, 14
    PUSHBUTTON "&Muokkaa...", psh2, 260, 40, 60, 14
    PUSHBUTTON "&Poista", psh3, 260, 60, 60, 14
    PUSHBUTTON "&Ylös", psh4, 260, 100, 60, 14
    PUSHBUTTON "Alas", psh5, 260, 120, 60, 14
    DEFPUSHBUTTON "OK", IDOK, 195, 145, 60, 14
    PUSHBUTTON "Peruuta", IDCANCEL, 260, 145, 60, 14
    PUSHBUTTON "Poista k&aikki", psh6, 5, 145, 79, 14
}

IDD_ADDDLGINIT DIALOG 0, 0, 184, 137
CAPTION "Lisää DLGINIT data"
STYLE DS_MODALFRAME | WS_POPUPWINDOW | WS_CAPTION
FONT 9, "MS Shell Dlg"
{
    LTEXT "Ohjaus &ID:", -1, 5, 7, 56, 12
    COMBOBOX cmb1, 65, 5, 115, 300, CBS_HASSTRINGS | CBS_AUTOHSCROLL | CBS_DROPDOWN | WS_VSCROLL | WS_TABSTOP
    LTEXT "&Viesti:", -1, 5, 32, 55, 12
    COMBOBOX cmb2, 65, 30, 95, 300, CBS_HASSTRINGS | CBS_AUTOHSCROLL | CBS_DROPDOWN | WS_VSCROLL | WS_TABSTOP
    LTEXT "&Merkkijono:", -1, 5, 52, 55, 12
    EDITTEXT edt1, 5, 65, 175, 50, ES_WANTRETURN | ES_MULTILINE | WS_VSCROLL | WS_HSCROLL
    DEFPUSHBUTTON "OK", IDOK, 55, 120, 60, 14
    PUSHBUTTON "Peruuta", IDCANCEL, 120, 120, 60, 14
}

IDD_MODIFYDLGINIT DIALOG 0, 0, 184, 137
CAPTION "Muokkaa DLGINIT dataa"
STYLE DS_MODALFRAME | WS_POPUPWINDOW | WS_CAPTION
FONT 9, "MS Shell Dlg"
{
    LTEXT "Ohjaus &ID:", -1, 5, 7, 56, 12
    COMBOBOX cmb1, 65, 5, 115, 300, CBS_HASSTRINGS | CBS_AUTOHSCROLL | CBS_DROPDOWN | WS_VSCROLL | WS_TABSTOP
    LTEXT "&Viesti:", -1, 5, 32, 55, 12
    COMBOBOX cmb2, 65, 30, 95, 300, CBS_HASSTRINGS | CBS_AUTOHSCROLL | CBS_DROPDOWN | WS_VSCROLL | WS_TABSTOP
    LTEXT "&Merkkijono:", -1, 5, 52, 55, 12
    EDITTEXT edt1, 5, 65, 175, 50, ES_WANTRETURN | ES_MULTILINE | WS_VSCROLL | WS_HSCROLL
    DEFPUSHBUTTON "OK", IDOK, 55, 120, 60, 14
    PUSHBUTTON "Peruuta", IDCANCEL, 120, 120, 60, 14
}

IDD_STRINGLIST DIALOG 0, 0, 205, 220
CAPTION "Ohjausmerkkijonoluettelo"
STYLE WS_POPUPWINDOW | WS_CAPTION | WS_THICKFRAME
FONT 9, "MS Shell Dlg"
{
    LTEXT "", stc1, 5, 5, 195, 70
    EDITTEXT edt1, 5, 80, 195, 115, ES_WANTRETURN | ES_MULTILINE | WS_VSCROLL | WS_HSCROLL
    DEFPUSHBUTTON "OK", IDOK, 75, 200, 60, 14
    PUSHBUTTON "Peruuta", IDCANCEL, 140, 200, 60, 14
}

IDD_SAVE_OPTIONS DIALOG 0, 0, 250, 225
CAPTION "Tallenna asetukset"
STYLE DS_MODALFRAME | WS_POPUPWINDOW | WS_CAPTION
FONT 9, "MS Shell Dlg"
{
    ICON IDI_MAIN, -1, 5, 10, 0, 0
    LTEXT "RC tiedoston tallentaminen luo joitakin liittyviä tiedostoja. Voit valita seuraavista vaihtoehdoista:", -1, 35, 5, 210, 29
    AUTOCHECKBOX "Käytä Microsoft MESSAGE&TABLEa", chx8, 5, 40, 240, 14
    AUTOCHECKBOX "Erota resurssitiedostot kie&littäin", chx1, 5, 60, 240, 14
    AUTOCHECKBOX "Käytä B&EGIN/END-avainsanoja", chx2, 5, 80, 240, 14
    AUTOCHECKBOX "Tee kieli valittavaksi LANGUAGE_* makrolla", chx3, 5, 100, 240, 14
    AUTOCHECKBOX "Luo &varmuuskopion", chx4, 5, 120, 110, 14
    RTEXT "jälkiliite:", -1, 120, 122, 75, 12
    COMBOBOX cmb1, 200, 120, 45, 300, CBS_HASSTRINGS | CBS_AUTOHSCROLL | CBS_DROPDOWN | WS_VSCROLL | WS_TABSTOP
    AUTOCHECKBOX "Tulosta turhat &kommentit", chx5, 5, 140, 240, 14
    AUTOCHECKBOX "Rivitä ma&nifestlausekkeet #ifndef MSVC ... #endif", chx6, 5, 160, 240, 14
    AUTOCHECKBOX "Tulosta RC-tiedostot &UTF-16 muodossa", chx7, 5, 180, 240, 14
    DEFPUSHBUTTON "OK", IDOK, 120, 205, 60, 14
    PUSHBUTTON "Peruuta", IDCANCEL, 185, 205, 60, 14
}

IDD_ENCODING DIALOG 0, 0, 200, 170
CAPTION "Resurssinimikkeen koodaus"
STYLE DS_MODALFRAME | WS_POPUPWINDOW | WS_CAPTION
FONT 9, "MS Shell Dlg"
{
    CONTROL "", lst1, "SysListView32", LVS_SHOWSELALWAYS | LVS_SINGLESEL | LVS_REPORT | WS_BORDER, 5, 5, 190, 115
    PUSHBUTTON "&Lisää...", psh1, 5, 125, 60, 14
    PUSHBUTTON "&Muokkaa...", psh2, 70, 125, 60, 14
    PUSHBUTTON "&Poista", psh3, 135, 125, 60, 14
    DEFPUSHBUTTON "OK", IDOK, 70, 150, 60, 14
    PUSHBUTTON "Peruuta", IDCANCEL, 135, 150, 60, 14
    PUSHBUTTON "&Palauta", psh5, 5, 149, 60, 14
}

IDD_ADDENC DIALOG 0, 0, 215, 80
CAPTION "Lisää resurssin koodaus"
STYLE DS_MODALFRAME | WS_POPUPWINDOW | WS_CAPTION
FONT 9, "MS Shell Dlg"
{
    LTEXT "Resurssin &tyyppi:", -1, 5, 7, 70, 12
    COMBOBOX cmb1, 75, 5, 135, 200, CBS_HASSTRINGS | CBS_AUTOHSCROLL | CBS_DROPDOWN | WS_BORDER | WS_VSCROLL | WS_TABSTOP
    LTEXT "&Koodaus:", -1, 5, 30, 70, 12
    COMBOBOX cmb2, 75, 30, 85, 300, CBS_HASSTRINGS | CBS_AUTOHSCROLL | CBS_DROPDOWNLIST | WS_VSCROLL | WS_TABSTOP
    DEFPUSHBUTTON "OK", IDOK, 86, 60, 60, 14
    PUSHBUTTON "Peruuta", IDCANCEL, 150, 60, 60, 14
}

IDD_MODIFYENC DIALOG 0, 0, 215, 80
CAPTION "Muokkaa resurssikoodia"
STYLE DS_MODALFRAME | WS_POPUPWINDOW | WS_CAPTION
FONT 9, "MS Shell Dlg"
{
    LTEXT "Resurssin &tyyppi:", -1, 5, 7, 70, 12
    COMBOBOX cmb1, 75, 5, 135, 200, CBS_HASSTRINGS | CBS_AUTOHSCROLL | CBS_DROPDOWN | WS_DISABLED | WS_BORDER | WS_VSCROLL | WS_TABSTOP
    LTEXT "&Koodaus:", -1, 5, 30, 70, 12
    COMBOBOX cmb2, 75, 30, 85, 300, CBS_HASSTRINGS | CBS_AUTOHSCROLL | CBS_DROPDOWNLIST | WS_VSCROLL | WS_TABSTOP
    DEFPUSHBUTTON "OK", IDOK, 86, 60, 60, 14
    PUSHBUTTON "Peruuta", IDCANCEL, 150, 60, 60, 14
}

IDD_CONSTANT DIALOG 0, 0, 205, 75
CAPTION "Kyselyvakio"
STYLE DS_MODALFRAME | WS_POPUPWINDOW | WS_CAPTION
FONT 9, "MS Shell Dlg"
{
    LTEXT "Vakion &nimi:", -1, 5, 7, 80, 12
    COMBOBOX cmb1, 94, 7, 105, 300, CBS_HASSTRINGS | CBS_AUTOHSCROLL | CBS_DROPDOWN | WS_VSCROLL | WS_TABSTOP
    LTEXT "&Vakio:", -1, 5, 32, 80, 12
    EDITTEXT edt2, 95, 30, 50, 14, ES_READONLY
    EDITTEXT edt3, 150, 30, 50, 14, ES_READONLY
    DEFPUSHBUTTON "OK", IDOK, 70, 55, 60, 14
}

IDD_EGA DIALOG 0, 0, 400, 225
CAPTION "EGA Ohjelmointikieli"
STYLE WS_POPUPWINDOW | WS_CAPTION | WS_THICKFRAME
FONT 9, "MS Shell Dlg"
{
    GROUPBOX "EGA konsoli", grp1, 5, 5, 390, 195
    EDITTEXT edt1, 10, 20, 380, 170, ES_READONLY | ES_AUTOVSCROLL | ES_MULTILINE | WS_VSCROLL | NOT WS_TABSTOP
    RTEXT "EGA>", stc1, 10, 208, 20, 10
    EDITTEXT edt2, 35, 205, 300, 15, ES_WANTRETURN | ES_AUTOHSCROLL | ES_AUTOVSCROLL | ES_MULTILINE
    PUSHBUTTON "&OK", IDOK, 345, 205, 50, 15
}

IDD_FONTSUBST DIALOG 0, 0, 185, 180
CAPTION "Dialog Font Substitutes"
STYLE DS_CENTER | DS_MODALFRAME | WS_POPUPWINDOW | WS_CAPTION
FONT 9, "MS Shell Dlg"
{
    LTEXT "Fontti #&1:", -1, 5, 7, 44, 12
    COMBOBOX cmb1, 55, 5, 125, 300, CBS_HASSTRINGS | CBS_AUTOHSCROLL | CBS_DROPDOWN | WS_VSCROLL | WS_TABSTOP
    ICON IDI_ARROW, -1, 30, 25, 0, 0
    COMBOBOX cmb2, 55, 30, 125, 300, CBS_HASSTRINGS | CBS_AUTOHSCROLL | CBS_DROPDOWN | WS_VSCROLL | WS_TABSTOP
    LTEXT "Fontti #&2:", -1, 5, 57, 44, 12
    COMBOBOX cmb3, 55, 55, 125, 300, CBS_HASSTRINGS | CBS_AUTOHSCROLL | CBS_DROPDOWN | WS_VSCROLL | WS_TABSTOP
    ICON IDI_ARROW, -1, 30, 75, 0, 0
    COMBOBOX cmb4, 55, 80, 125, 300, CBS_HASSTRINGS | CBS_AUTOHSCROLL | CBS_DROPDOWN | WS_VSCROLL | WS_TABSTOP
    LTEXT "Fontti #&3:", -1, 5, 105, 44, 12
    COMBOBOX cmb5, 55, 105, 125, 300, CBS_HASSTRINGS | CBS_AUTOHSCROLL | CBS_DROPDOWN | WS_VSCROLL | WS_TABSTOP
    ICON IDI_ARROW, -1, 30, 125, 0, 0
    COMBOBOX cmb6, 55, 130, 125, 300, CBS_HASSTRINGS | CBS_AUTOHSCROLL | CBS_DROPDOWN | WS_VSCROLL | WS_TABSTOP
    DEFPUSHBUTTON "OK", IDOK, 75, 160, 50, 14
    PUSHBUTTON "Peruuta", IDCANCEL, 130, 160, 50, 14
    PUSHBUTTON "&Palauta", psh1, 5, 160, 55, 14
}

IDD_DROPDOWNPOPUP DIALOG 0, 0, 120, 150
CAPTION " "
STYLE WS_POPUP | WS_DLGFRAME | NOT WS_BORDER
FONT 9, "MS Shell Dlg"
{
    LISTBOX lst1, 0, 0, 120, 150, LBS_WANTKEYBOARDINPUT | LBS_NOINTEGRALHEIGHT | LBS_HASSTRINGS | WS_VSCROLL | WS_TABSTOP, WS_EX_CLIENTEDGE
}

IDD_DFMSETTINGS DIALOG 0, 0, 210, 135
CAPTION "Delphi DFM asetukset"
STYLE DS_CENTER | DS_MODALFRAME | WS_POPUPWINDOW | WS_CAPTION
FONT 9, "MS Shell Dlg"
{
    LTEXT "Seuraavat asetukset liittyvät Delphi DFM:ään:", -1, 35, 5, 171, 20
    ICON IDI_DFMICON, -1, 5, 5, 0, 0
    RTEXT "&Koodisivu:", -1, 6, 32, 70, 12
    COMBOBOX cmb1, 85, 30, 120, 300, CBS_HASSTRINGS | CBS_AUTOHSCROLL | CBS_DROPDOWN | WS_VSCROLL | WS_TABSTOP
    AUTOCHECKBOX "&Lisää raakamerkkijonokommentit", chx1, 5, 50, 200, 14
    AUTOCHECKBOX "Älä käytä &Unicodea tai UTF-8 tiedostomuotoa", chx2, 5, 70, 200, 14
    DEFPUSHBUTTON "OK", IDOK, 80, 115, 60, 14
    PUSHBUTTON "Peruuta", IDCANCEL, 145, 115, 60, 14
}

IDD_COPYTOMULTILANG DIALOG 0, 0, 200, 195
CAPTION "Kopioi useille kielille"
STYLE DS_CENTER | DS_MODALFRAME | WS_POPUPWINDOW | WS_CAPTION
FONT 9, "MS Shell Dlg"
{
    LTEXT "Lisää kielet, joihin haluat kopioida resurssin:", -1, 5, 5, 190, 22
    LTEXT "&Kieli:", -1, 5, 35, 82, 12
    LISTBOX lst1, 5, 50, 190, 100, LBS_WANTKEYBOARDINPUT | LBS_NOINTEGRALHEIGHT | LBS_HASSTRINGS | WS_VSCROLL | WS_TABSTOP
    COMBOBOX cmb3, 5, 155, 126, 14, CBS_HASSTRINGS | CBS_AUTOHSCROLL | CBS_DROPDOWN | WS_BORDER | WS_VSCROLL | WS_TABSTOP
    PUSHBUTTON "&Lisätä", psh1, 135, 155, 60, 14
    DEFPUSHBUTTON "OK", IDOK, 5, 175, 60, 14
    PUSHBUTTON "Peruuta", IDCANCEL, 70, 175, 60, 14
}

IDD_TOOLBARRES DIALOG 0, 0, 230, 195
CAPTION "Työkalupalkin resurssi"
STYLE DS_CENTER | DS_MODALFRAME | WS_POPUPWINDOW | WS_CAPTION
FONT 9, "MS Shell Dlg"
{
    RTEXT "Kuvakkeen &leveys:", -1, 5, 5, 60, 15, SS_CENTERIMAGE | NOT WS_GROUP
    EDITTEXT edt1, 70, 5, 30, 15, ES_NUMBER | ES_RIGHT
    CONTROL "", scr1, "msctls_updown32", UDS_NOTHOUSANDS | UDS_ARROWKEYS | UDS_AUTOBUDDY | UDS_ALIGNRIGHT | UDS_SETBUDDYINT, 80, 5, 30, 15
    RTEXT "Kuvakkeen &korkeus:", -1, 110, 5, 60, 15, SS_CENTERIMAGE | NOT WS_GROUP
    EDITTEXT edt2, 180, 5, 30, 15, ES_NUMBER | ES_RIGHT
    CONTROL "", scr2, "msctls_updown32", UDS_NOTHOUSANDS | UDS_ARROWKEYS | UDS_AUTOBUDDY | UDS_ALIGNRIGHT | UDS_SETBUDDYINT, 190, 5, 30, 15
    LTEXT "&Työkalupalkin painikkeet:", -1, 5, 25, 140, 15, SS_CENTERIMAGE | NOT WS_GROUP
    LISTBOX lst1, 5, 40, 140, 130, LBS_DISABLENOSCROLL | LBS_WANTKEYBOARDINPUT | LBS_NOINTEGRALHEIGHT | LBS_HASSTRINGS | LBS_OWNERDRAWFIXED | WS_VSCROLL | WS_TABSTOP
    PUSHBUTTON "&Lisätä...", psh1, 150, 40, 75, 15
    PUSHBUTTON "&Muuttaa...", psh2, 150, 60, 75, 15
    PUSHBUTTON "&Poistaa", psh3, 150, 80, 75, 15
    PUSHBUTTON "&Ylös", psh4, 150, 135, 75, 15
    PUSHBUTTON "&Alas", psh5, 150, 155, 75, 15
    DEFPUSHBUTTON "OK", IDOK, 5, 175, 60, 15
    PUSHBUTTON "Peruuta", IDCANCEL, 70, 175, 60, 15
}

IDD_ADDTBBTN DIALOG 0, 0, 177, 92
CAPTION "Lisää työkalupalkki -painike"
STYLE DS_CENTER | DS_MODALFRAME | WS_POPUPWINDOW | WS_CAPTION
FONT 9, "MS Shell Dlg"
{
    LTEXT "&Työkalupalkin painikkeen komentotunnus:", -1, 5, 5, 160, 15, SS_CENTERIMAGE | NOT WS_GROUP
    COMBOBOX cmb1, 5, 25, 150, 150, CBS_HASSTRINGS | CBS_AUTOHSCROLL | CBS_DROPDOWN | WS_VSCROLL | WS_TABSTOP
    AUTOCHECKBOX "&Erotin", chx1, 5, 45, 90, 15
    DEFPUSHBUTTON "OK", IDOK, 45, 70, 60, 15
    PUSHBUTTON "Peruuta", IDCANCEL, 110, 70, 60, 15
}

IDD_MODIFYTBBTN DIALOG 0, 0, 177, 92
CAPTION "Muokkaa työkalupalkkia -painiketta"
STYLE DS_CENTER | DS_MODALFRAME | WS_POPUPWINDOW | WS_CAPTION
FONT 9, "MS Shell Dlg"
{
    LTEXT "&Työkalupalkin painikkeen komentotunnus:", -1, 5, 5, 160, 15, SS_CENTERIMAGE | NOT WS_GROUP
    COMBOBOX cmb1, 5, 25, 150, 150, CBS_HASSTRINGS | CBS_AUTOHSCROLL | CBS_DROPDOWN | WS_VSCROLL | WS_TABSTOP
    AUTOCHECKBOX "&Erotin", chx1, 5, 45, 90, 15
    DEFPUSHBUTTON "OK", IDOK, 45, 70, 60, 15
    PUSHBUTTON "Peruuta", IDCANCEL, 110, 70, 60, 15
}

//////////////////////////////////////////////////////////////////////////////
// RT_VERSION

1 VERSIONINFO
FILEVERSION     5, 7, 9, 0
PRODUCTVERSION  5, 7, 9, 0
FILEOS          0x40004
FILETYPE        0x1
FILESUBTYPE     0x0
{
    BLOCK "StringFileInfo"
    {
        BLOCK "040B04E4"
        {
            VALUE "CompanyName", "Katayama Hirofumi MZ\0"
            VALUE "FileDescription", "RisohEditor\0"
            VALUE "FileVersion", "5.7.9\0"
            VALUE "LegalCopyright", "Copyright (C) 2017-2020 Katayama Hirofumi MZ. All rights reserved.\0"
            VALUE "ProductName", "RisohEditor\0"
            VALUE "ProductVersion", "5.7.9\0"
        }
    }
    BLOCK "VarFileInfo"
    {
        VALUE "Translation", 0x040B, 0x04E4
    }
}

//////////////////////////////////////////////////////////////////////////////
// RISOHTEMPLATE

4 RISOHTEMPLATE "res/1035_RISOHTEMPLATE_4.bin"

5 RISOHTEMPLATE "res/1035_RISOHTEMPLATE_5.bin"

//////////////////////////////////////////////////////////////////////////////
// RT_STRING

STRINGTABLE
{
    IDS_APPNAME, "RisohEditor 5.7.9 by Katayama Hirofumi MZ"
    IDS_TITLEWITHFILE, "RisohEditor 5.7.9 - Tiedosto: %s"
    IDS_EXTRACTRES, "Pura resurssi"
    IDS_RESBINFILTER, "Binaariresurssit (*.res)|*.res|Binaaritiedostot (*.bin)|*.bin|Kaikki tiedostot (*.*)|*.*|"
    IDS_CANNOTSAVE, "Tallentaminen epäonnistui."
    IDS_REPLACERES, "Korvaa resurssi"
    IDS_ALLFILES, "Kaikki tiedostot (*.*)|*.*|"
    IDS_ENTERTYPE, "Anna resurssin tyyyppi."
    IDS_ENTERNAME, "Anna resurssin nimi."
    IDS_ENTERLANG, "Anna resurssin kieli."
    IDS_FILENOTFOUND, "Tiedostoa ei löytynyt."
    IDS_CANNOTREPLACE, "Ei voi korvata."
    IDS_EXERESFILTER, "Suoritettavat (*.exe;*.dll;*.ocx;*.cpl;*.scr;*.mui)|*.exe;*.dll;*.ocx;*.cpl;*.scr;*.mui|RC tiedostot (*.rc)|*.rc|Binaariresurssit (*.res)|*.res|Kaikki tiedostot (*.*)|*.*|"
    IDS_SAVEAS, "Tallenna nimellä"
    IDS_CANNOTADDICON, "Kuvaketta ei voi lisätä."
    IDS_ADDICON, "Lisää kuvake"
    IDS_ICOFILTER, "Kuvaketiedostot (*.ico)|*.ico|Kaikki tiedostot (*.*)|*.*|"
    IDS_REPLACEICO, "Korvaa kuvake"
    IDS_CANTREPLACEICO, "Kuvaketta ei voi korvata."
    IDS_EXISTSOVERWRITE, "Kohde on jo olemassa. Korvataanko?"
    IDS_OPEN, "Avaa"
    IDS_CANNOTOPEN, "Tiedostoa ei voi avata."
    IDS_ADDBMP, "Lisää bittikartta"
    IDS_BMPFILTER, "Bittikarttatiedostot (*.bmp)|*.bmp|PNG kuvat (*.png)|*.png|Kaikki tiedostot (*.*)|*.*|"
    IDS_CANTREPLACEBMP, "Bittikarttaa ei voi korvata."
    IDS_REPLACEBMP, "Korvaa bittikartta"
    IDS_ERRORCODE, "Virhekoodi %d"
    IDS_VERSIONINFO, "RisohEditor Version 5.7.9\r\n\r\nKatayama Hirofumi MZ\r\n\r\nLicense: GPLv3 (free software)"
    IDS_ADDRES, "Lisää resurssi"
    IDS_CANNOTADDRES, "Resurssia ei voi lisätä."
    IDS_CANTADDBMP, "Bittikarttaa ei voi lisätä."
    IDS_EXTRACTBMP, "Pura bittikartta"
    IDS_CANTEXTRACTBMP, "Bittikarttaa ei voi purkaa."
    IDS_CANTREPLACECUR, "Kursoria ei voi korvata."
    IDS_CANNOTADDCUR, "Kursoria ei voi lisätä."
    IDS_CURFILTER, "Kursoritiedostot (*.cur)|*.cur|Animaatiokursori (*.ani)|*.ani|Kaikki tiedostot (*.*)|*.*|"
    IDS_ADDCUR, "Lisää kursori"
    IDS_REPLACECUR, "Korvaa kursori"
    IDS_EXTRACTICO, "Pura kuvake"
    IDS_CANTEXTRACTICO, "Kuvaketta ei voi purkaa."
    IDS_EXTRACTCUR, "Pura kursori"
    IDS_CANTEXTRACTCUR, "Kursoria ei voi purkaa."
    IDS_RESFILTER, "Binaariset resurssit (*.res)|*.res|Kaikki tiedostot (*.*)|*.*|"
    IDS_NEUTRAL, "Neutraali"
    IDS_IMPORTRES, "Tuo"
    IDS_CANNOTIMPORT, "Resurssia ei voi tuoda."
    IDS_COMPILE, "Käännä (F8)"
    IDS_CANCELEDIT, "Peruuta muokkaus (Ctrl+E)"
    IDS_GUIEDIT, "Muokkaa GUI:ssa (Ctrl+G)"
    IDS_CANNOTSTARTUP, "Resurssikääntäjää ei voi käynnistää."
    IDS_RESMISMATCH, "Resurssityyppi ei täsmää."
    IDS_SAMPLETEXT, "Tämä on näyte."
    IDS_ALREADYEXISTS, "On jo olemassa."
    IDS_KEY, "Avain"
    IDS_FLAGS, "Liput"
    IDS_COMMANDID, "Komennon ID"
    IDS_INVALIDKEY, "Virheellinen avain."
    IDS_COMPILEERROR, "Kääntäminen epäonnistui."
    IDS_STRINGID, "Merkkijonon ID"
    IDS_STRINGVALUE, "Merkkijonon arvo"
    IDS_CAPTION, "Otsikko"
    IDS_HELPID, "Ohjeen ID"
    IDS_INDENT, "» "
    IDS_DATAISEMPTY, "Data on tyhjä."
    IDS_TEST, "Testaa"
    IDS_SEPARATOR, "---"
    IDS_COMPILENOW, "Tietoja on muutettu. Käännetäänkö nyt?"
    IDS_RADWINDOW, "Muokkaa dialogia"
    IDS_ENTERCLASS, "Anna kelvollinen ikkunaluokan nimi."
    IDS_TEXTEDIT, "Muokkaa tekstin mukaan (Ctrl+T)"
    IDS_CURSORINFO, "Kuva #%u: Leveys %u, Korkeus %u, BitCount %u, xHotSpot %u, yHotSpot %u, ID %u\r\n"
    IDS_IMAGECOUNT, "Kuvamäärä: %u\r\n"
    IDS_ICONINFO, "Kuva #%u: Leveys %u, Korkeus %u, BitCount %u, ID %u\r\n"
    IDS_READY, "Valmis"
    IDS_EXECUTINGCMD, "Suoritetaan komento..."
    IDS_EDITINGBYGUI, "Muokataan GUI:ssa..."
    IDS_COORD, "%d, %d, %d, %d"
    IDS_STARTING, "Aloitetaan..."
    IDS_COMPILING, "Käännetään..."
    IDS_CANNOTLOAD, "Ei voi ladata."
    IDS_NONE, "(Ei mitään)"
    IDS_WAVESOUND, "(WAVE ääni)\r\n"
    IDS_IDTYPE, "ID tyyppi"
    IDS_IDPREFIX, "ID etuliite"
    IDS_EMPTYSTR, "Anna merkkijono."
    IDS_ANICURSOR, "(Animaatiokursori)\r\n"
    IDS_ANIICON, "(Animaatiokuvake)\r\n"
    IDS_HEADFILTER, "Header-tiedostot (*.h)|*.h|Kaikki tiedostot (*.*)|*.*|"
    IDS_LOADRESH, "Lataa ""resource.h"" tiedosto"
    IDS_NAME, "Nimi"
    IDS_VALUE, "Arvo"
    IDS_NOSUCHID, "Tällaista tunnusta ei löytynyt."
    IDS_IMAGEINFO, "Leveys %u, Korkeus %u, BitsPixel %u\r\n"
    IDS_ENTERINT, "Kirjoita kelvollinen kokonaisluku."
    IDS_ENTERTEXT, "Kirjoita kelvollinen teksti."
    IDS_ENTERID, "Kirjoita kelvollinen ID."
    IDS_ADDNEXTIDS, "Lisää seuraavat ID:t tiedostoon ""resource.h"":\r\n\r\n"
    IDS_DELETENEXTIDS, "Poista seuraavat ID:t tiedostosta ""resource.h"":\r\n\r\n"
    IDS_NOCHANGE, "Resurssitunnuksia ei ole muutettu."
    IDS_DLGFAIL, "Hups, RAD-dialogin luominen epäonnistui."
    IDS_LOADWCLIB, "Lataa Window Class Library"
    IDS_AVIMOVIE, "(AVI Movie)\r\n"
    IDS_ADDDIALOG, "Lisää dialogi"
    IDS_ADDMENU, "Lisää valikko"
    IDS_ADDVERINFO, "Lisää versiotiedot"
    IDS_ADDCURSOR, "Lisää kursori"
    IDS_NOMOREITEM, "Ei enää kohteita."
    IDS_INVALIDDATA, "(virheellinen data)\r\n"
    IDS_UPDATERESH, "Päivitetäänkö ""resource.h""?"
    IDS_CANTWRITERESH, "Ei voi kirjoittaa ""resource.h""."
    IDS_SAVERESH, "Tallenna ""resource.h"" tiedosto"
    IDS_DLLFILTER, "DLL tiedostot (*.dll;*.ocx;*.mui)|*.dll;*.ocx;*.mui|Kaikki tiedostot (*.*)|*.*|"
    IDS_EXERESRCFILTER, "Ladattavat tiedostot (*.exe;*.dll;*.ocx;*.cpl;*.scr;*.mui;*.res;*.rc)|*.exe;*.dll;*.ocx;*.cpl;*.scr;*.mui;*.res;*.rc|Suoritettavat (*.exe;*.dll;*.ocx;*.cpl;*.scr;*.mui)|*.exe;*.dll;*.ocx;*.cpl;*.scr;*.mui|Binaari resurssit (*.res)|*.res|Resurssitiedostot (*.rc)|*.rc|Kaikki tiedostot (*.*)|*.*|"
    IDS_CANTTESTCHILDWND, "Valintaikkunaa ei voi testata, koska se on ali-ikkuna."
    IDS_CANTTESTCLASSDLG, "Dialogia ei voi testata, koska se on luokiteltu."
    IDS_FILEISUPXED, "Tiedosto\r\n\r\n'%s'\r\n\r\non UPX pakattu. Haluatko purkaa sen käyttämällä väliaikaista tiedostoa?\r\n\r\nJos et laajentanut sitä, lukeminen voi epäonnistua.."
    IDS_CANTUPXEXTRACT, "UPX ei pysty purkamaan."
    IDS_CANTSAVEUPXED, "Tiedostoa ei voitu tallentaa, koska UPX on pakannut sen."
    IDS_MESSAGEID, "Viestin ID"
    IDS_MESSAGEVALUE, "Viestin arvo"
    IDS_RCFILTER, "RC tiedostot (*.rc)|*.rc|"
    IDS_EXPORT, "Vie"
    IDS_CANTEXPORT, "Vienti epäonnistui."
    IDS_MUSTBEEMPTYDIR, "Jos on olemassa ulkoinen tiedosto, vientikohteen on oltava tyhjä kansio."
    IDS_FULLWIDTH, "０１２３４５６７８９ＡＢＣＤＥＦＧＨＩＪＫＬＭＮＯＰＱＲＳＴＵＶＷＸＹＺａｂｃｄｅｆｇｈｉｊｋｌｍｎｏｐｑｒｓｔｕｖｗｘｙｚ－＿（）．　"
    IDS_HALFWIDTH, "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz-_(). "
    IDS_MACRONAME, "Makron nimi"
    IDS_MACROVALUE, "Makron arvo"
    IDS_OPTIONAL, "(Valinnainen)"
    IDS_ADDINCLUDE, "Lisää Include hakemisto"
    IDS_EDITINCLUDE, "Muokkaa Include hakemistoa"
    IDS_WINDRESEXE, "windres.exe|windres.exe|"
    IDS_CPPEXE, "cpp.exe|cpp.exe|"
    IDS_INVALIDPATH, "Virheellinen polku."
    IDS_DATATOOLONG, "Data on liian pitkä."
    IDS_ALL, "(Kaikki)"
    IDS_UNKNOWNFORMAT, "(Tuntematon tietomuoto)\r\n"
    IDS_LANGUAGE, "Kieli"
    IDS_INTVALUE, "Kokonaislukuarvo"
    IDS_PARENTWND, "Isätesti-ikkuna"
    IDS_CHOOSE_OLE_CLSID, "Valitse OLE CLSID"
    IDS_CONTROL, "Ohjaus"
    IDS_MESSAGE, "Viesti"
    IDS_STRING, "Merkkijono"
    IDS_DATAISINVALID, "Data on virheellistä."
    IDS_DLGINIT1, "Voit määrittää yhdistelmäruutujen ja luetteloruutujen alustamisen asettamalla alustustiedot RT_DLGINIT-resurssitietoihin, jonka nimi on sama, kuin valintaikkunan resurssi. "
    IDS_DLGINIT2, "Kun WM_INITDIALOG-viesti saapuu, sovellus voi alustaa dialogin kutsumalla liitetyn tiedoston ExecuteDlgInitDx-toiminnon ""DlgInit/DlgInit.h"".\r\n\r\n"
    IDS_DLGINIT3, "Määritä luettelo merkkijonoista, jotka on erotettu rivinvaihdoilla lausekkeelle RT_DLGINIT."
    IDS_SAMELANG, "Sama kieli."
    IDS_SAMENAME, "Sama resurssin nimi."
    IDS_CANTSAVETOEXE, "Ei voida tallentaa EXE-tiedostona ei-suoritettavasta tiedostosta."
    IDS_CANTSTARTSEARCH, "Hakua ei voitu aloittaa."
    IDS_AMERICA, "America"
    IDS_ENGLISH, "English"
    IDS_CHINA, "China"
    IDS_CHINESE, "Chinese"
    IDS_RUSSIA, "Russia"
    IDS_RUSSIAN, "Russian"
    IDS_WANNAGENRESH, "Haluatko luoda tiedoston 'resource.h'?"
    IDS_EXEFILTER, "Suoritettavat (*.exe;*.dll;*.ocx;*.cpl;*.scr;*.mui)|*.exe;*.dll;*.ocx;*.cpl;*.scr;*.mui|Kaikki tiedostot (*.*)|*.*|"
    IDS_SAVEASCOMPRESS, "Tallenna pakattuna"
    IDS_TOOL_NEW, "Uusi"
    IDS_TOOL_OPEN, "Avaa..."
    IDS_TOOL_SAVE, "Tallenna nimellä..."
    IDS_TOOL_EXPAND, "Laajenna kaikki"
    IDS_TOOL_COLLAPSE, "Tiivistä kaikki"
    IDS_TOOL_PLUS, "Lisää kohde..."
    IDS_TOOL_MINUS, "Poista kohde"
    IDS_TOOL_CHANGE, "Vaihda nimi/kieli"
    IDS_TOOL_CLONE, "Kloonaa toisella nimellä/kielellä"
    IDS_TOOL_RECOMPILE, "Käännä uudelleen"
    IDS_TOOL_CANCELEDIT, "Peruuta muokkaus"
    IDS_TOOL_IMPORT, "Tuo..."
    IDS_TOOL_EXTRACT, "Pura..."
    IDS_TOOL_GUIEDIT, "Muokkaa GUI:ssa"
    IDS_UNITEDKINGDOM, "United Kingdom"
    IDS_GREATBRITAIN, "Great Britain"
    IDS_BRITISH, "British"
    IDS_FRANCE, "France"
    IDS_FRENCH, "French"
    IDS_GERMANY, "Germany"
    IDS_GERMAN, "German"
    IDS_SPAIN, "Spain"
    IDS_SPANISH, "Spanish"
    IDS_INVALIDLANG, "Tunnistamaton kieli."
    IDS_INVALIDNAME, "Virheellinen resurssin nimi."
    IDS_PNGRESBINFILTER, "PNG kuva (*.png)|*.png|Binaariset resurssit (*.res)|*.res|Binaariset tiedostot (*.bin)|*.bin|Kaikki tiedostot (*.*)|*.*|"
    IDS_JPEGRESBINFILTER, "JPEG kuva (*.jpg;*.jpeg;*.jpe;*.jfif)|*.jpg;*.jpeg;*.jpe;*.jfif|Binaariset resurssit (*.res)|*.res|Binaariset tiedostot (*.bin)|*.bin|Kaikki tiedostot (*.*)|*.*|"
    IDS_GIFRESBINFILTER, "GIF kuva (*.gif)|*.gif|Binaariset resurssit (*.res)|*.res|Binaariset tiedostot (*.bin)|*.bin|Kaikki tiedostot (*.*)|*.*|"
    IDS_TIFFRESBINFILTER, "TIFF kuva (*.tif;*.tiff)|*.tif;*.tiff|Binary Resources (*.res)|*.res|Binaariset tiedostot (*.bin)|*.bin|Kaikki tiedostot (*.*)|*.*|"
    IDS_AVIRESBINFILTER, "AVI Movie (*.avi)|*.avi|Binaariset resurssit (*.res)|*.res|Binaariset tiedostot (*.bin)|*.bin|Kaikki tiedostot (*.*)|*.*|"
    IDS_WAVERESBINFILTER, "WAVE ääni (*.wav)|*.wav|Binaariset resurssit (*.res)|*.res|Binaariset tiedostot (*.bin)|*.bin|Kaikki tiedostot (*.*)|*.*|"
    IDS_COMMENT_SEP, "//////////////////////////////////////////////////////////////////////////////\r\n\r\n"
    IDS_NEWLINE, "\r\n"
    IDS_NOTICE, "// RisohEditor 5.7.9 on luonut tämän tiedoston automaattisesti.\r\n"
    IDS_DAGGER, "// † <-- Tämä daggeri auttaa UTF-8-tunnistuksessa.\r\n"
    IDS_IMPORTFILTER, "Tuotavat tiedostot|*.rc;*.res;*.dfm;*.html;*.htm;*.manifest;*.ico;*.cur;*.ani;*.wav;*.bmp;*.dib;*.png;*.gif;*.jpg;*.jpeg;*.jpe;*.jfif;*.tif;*.tiff;*.avi;*.wmf;*.emf|RC tiedostot (*.rc)|*.rc|Binaariset resurssit (*.res)|*.res|Kuvatiedostot|*.bmp;*.dib;*.png;*.gif;*.jpg;*.jpeg;*.jpe;*.jfif;*.tif;*.tiff;*.wmf;*.emf;*.tlb|Kursoritiedostot (*.cur;*.ani)|*.cur;*.ani|Kuvaketiedostot (*.ico)|*.ico|WAVE äänitiedostot (*.wav)|*.wav|HTML tiedostot (*.html;*.htm)|*.html;*.htm|Manifest tiedostot (*.manifest)|*.manifest|Delphi DFM tiedostot (*.dfm)|*.dfm|TYPELIB Files (*.tlb)|*.tlb|Kaikki tiedostot (*.*)|*.*|"
    IDS_CANTWRITEBYLOCK, "Tiedostoa ei voi kirjoittaa, koska seuraava tiedosto on lukittu.\r\n\r\n%s"
    IDS_ANSI, "ANSI"
    IDS_WIDE, "Unicode"
    IDS_UTF8, "UTF-8 (with BOM)"
    IDS_UTF8N, "UTF-8 (without BOM)"
    IDS_SJIS, "Shift_JIS"
    IDS_BINARY, "(binaarinen data)"
    IDS_RESTYPE, "Resurssin tyyppi"
    IDS_ENCODING, "Koodaus"
    IDS_INVALIDRESTYPE, "Virheellinen resurssityyppi."
    IDS_PATHSPACEERROR, "Asensit sijaintiin, jonka nimessä on välilyöntejä! Resurssikääntäjä ei hyväksy välilyöntejä.\n\nVältä ""C:\\Program Files""."
    IDS_LOADEGAPROGRAM, "Lataa EGA-ohjelma..."
    IDS_EGAFILTER, "EGA ohjelma (*.ega)|*.ega|Kaikki tiedostot (*.*)|*.*|"
    IDS_QUERYSAVECHANGE, "Tiedostoa on muokattu. Haluatko tallentaa muutokset nyt?"
    IDS_DFMFILTER, "Tiedostoa on muokattu. Haluatko tallentaa muutokset nyt?"
    IDS_CANTEXTRACTDFM, "DFM dataa ei voi purkaa."
    IDS_EXTRACTDFM, "Pura DFM data"
    IDS_ENTERNONZERONAME, "Anna nollasta poikkeava resurssin nimi."
    IDS_ENTERNONZEROTYPE, "Anna nollasta poikkeava resurssin tyyppi."
    IDS_HOMEPAGE, "https://katahiromz.web.fc2.com/re/en/"
    IDS_FILESAVED, "Tiedosto tallennettu."
    IDS_RECOMPILEOK, "Uudelleen kääntäminen tehty."
    IDS_RECOMPILEFAILED, "Uudelleen kääntäminen epäonnistui (syntaksivirhe)."
    IDS_TOOL_EXPORT, "Vie..."
    IDS_CODEEDITOR, "Koodieditori"
    IDS_HEXVIEWER, "Hex-katselu"
    IDS_INTEGERORIDENTIFIER, "(kokonaisluku tai tunnus)"
    IDS_NOTEXT, " "
    IDS_NOUPDATE, "Käytät uusinta RisohEditoria."
    IDS_THEREISUPDATE, "RisohEditor %s on saatavilla. Ladataanko nyt?"
    IDS_CANTCHECKUPDATE, "RisohEditorin päivityksen tarkistus epäonnistui."
    IDS_CODEPAGE1252, "1252 (Latin 1)"
    IDS_CODEPAGE1250, "1250 (Latin 2)"
    IDS_CODEPAGE1251, "1251 (Cyrillic)"
    IDS_CODEPAGE1253, "1253 (Greek)"
    IDS_CODEPAGE1254, "1254 (Turkish)"
    IDS_CODEPAGE1255, "1255 (Hebrew)"
    IDS_CODEPAGE1256, "1256 (Arabic)"
    IDS_CODEPAGE1257, "1257 (Baltic)"
    IDS_CODEPAGE874, "874 (Thai)"
    IDS_CODEPAGE932, "932 (Japanese)"
    IDS_CODEPAGE936, "936 (Simplified Chinese)"
    IDS_CODEPAGE949, "949 (Korean)"
    IDS_CODEPAGE950, "950 (Traditional Chinese)"
    IDS_CODEPAGE65001, "65001 (UTF-8)"
    IDS_EXTRACTTLB, "Extract TYPELIB data"
    IDS_CANTEXTRACTTLB, "Unable to extract the TYPELIB data."
    IDS_TLBRESBINFILTER, "TYPELIB data (*.tlb)|*.tlb|Binary Resources (*.res)|*.res|Text Files (*.txt)|*.txt|MIDL Files (*.idl)|*.idl|All Files (*.*)|*.*|"
    IDS_USAGE, "Usage: RisohEditor [options | ""file""]\n\nOptions:\n--help  Show this message.\n--version  Show version info.\n--load ""your-file.rc""  Load the file (without GUI)\n--save ""your-file.res""  Save the file (without GUI)\n--log-file ""log-file.txt""  Specify the log file.\n--load-options OPTIONS  Set load options.\n--save-options OPTIONS  Set save options.\n\nLoad options: (no-load-res-h)\nSave options: (idc-static)(compress)(sep-lang)(no-res-folder)(lang-macro)(less-comments)(wrap-manifest)(begin-end)(utf-16)(backup)(ms-msgtbl)"
    IDS_NOSELECTION, "Ei ole valintaa."
    IDS_TRANSLATORS, "[Translators]\r\nEnglish: Katayama Hirofumi MZ\r\nFinnish: Veikko Muurikainen\r\nIndonesian: Mas Ahmad Muhammad\r\nItalian: R.B.\r\nJapanese: Katayama Hirofumi MZ\r\nKorean: VenusGirl (비너스걸)\r\nPolish: Piotr Hetnarowicz\r\nPortuguese: JNylson\r\nRussian: Dmitry Yerokhin\r\nSimplified Chinese: 林鸿湘\r\n"
}

//////////////////////////////////////////////////////////////////////////////

```

`src/lang/fr_FR.rc`:

```rc
// This file is automatically generated by RisohEditor 5.7.9.
// † <-- This dagger helps UTF-8 detection.

#pragma code_page(65001) // UTF-8

LANGUAGE LANG_FRENCH, SUBLANG_DEFAULT

//////////////////////////////////////////////////////////////////////////////
// RT_MENU

IDR_MAINMENU MENU
{
    POPUP "&Fichier"
    {
        MENUITEM "&Nouveau\tCtrl+N", ID_NEW
        MENUITEM SEPARATOR
        MENUITEM "&Ouvert...\tCtrl+O", ID_OPEN
        MENUITEM "&Sauver...\tCtrl+S", ID_SAVE
        MENUITEM "Enregistrer sous...\tShift+Ctrl+S", ID_SAVEAS
        MENUITEM "Économisez avec la compression...", ID_SAVEASCOMPRESS
        MENUITEM SEPARATOR
        MENUITEM "&Importation...\tCtrl+I", ID_IMPORT
        MENUITEM "&Exportation...\tCtrl+P", ID_EXPORT
        MENUITEM SEPARATOR
        MENUITEM "Recharger &resource.h...\tCtrl+R", ID_LOADRESH
        MENUITEM "Sauver re&source.h...", ID_UPDATERESHBANG
        MENUITEM "Conseil resource.h Modification...", ID_ADVICERESH
        MENUITEM "&Décharger resource.h", ID_UNLOADRESH
        MENUITEM SEPARATOR
        MENUITEM "Charger la bibliothèque de classes de fenêtre...", ID_LOADWCLIB
        MENUITEM SEPARATOR
        POPUP "Fichiers récemment utilisés"
        {
            MENUITEM "(Aucun)", -1, GRAYED
        }
        MENUITEM SEPARATOR
        MENUITEM "Sortie\tAlt+F4", ID_EXIT
    }
    POPUP "&Éditer"
    {
        MENUITEM "Modifier par &GUI...\tCtrl+G", ID_GUIEDIT
        MENUITEM SEPARATOR
        POPUP "&Ajouter"
        {
            MENUITEM "Ajouter une icône...", ID_ADDICON
            MENUITEM "Ajouter un curseur...", ID_ADDCURSOR
            MENUITEM "Ajouter un bitmap...", ID_ADDBITMAP
            MENUITEM "Ajouter une boîte de dialogue...", ID_ADDDIALOG
            MENUITEM "Ajouter un menu...", ID_ADDMENU
            MENUITEM "Ajouter une table de chaînes...", ID_ADDSTRINGTABLE
            MENUITEM "Ajouter une table de messages...", ID_ADDMESSAGETABLE
            MENUITEM "Ajouter du HTML...", ID_ADDHTML
            MENUITEM "Ajouter des accélérateurs...", ID_ADDACCEL
            MENUITEM "Ajouter des informations sur la version...", ID_ADDVERINFO
            MENUITEM "Ajouter un manifeste...", ID_ADDMANIFEST
            MENUITEM "Ajouter une barre d'ou&tils...", ID_ADDTOOLBAR
            MENUITEM "Ajouter un élément de ressource...", ID_ADDRES
        }
        POPUP "&Remplacer"
        {
            MENUITEM "Remplacer l'icône...", ID_REPLACEICON
            MENUITEM "Remplacer le curseur...", ID_REPLACECURSOR
            MENUITEM "Remplacer le bitmap...", ID_REPLACEBITMAP
            MENUITEM "Remplacer l'élément de ressource binaire...", ID_REPLACEBIN
        }
        POPUP "&Extrait"
        {
            MENUITEM "Extraire l'icône...", ID_EXTRACTICON
            MENUITEM "Extraire le curseur...", ID_EXTRACTCURSOR
            MENUITEM "Extraire le bitmap...", ID_EXTRACTBITMAP
            MENUITEM "Extraire en tant que fichier RC...", ID_EXTRACTRC
            MENUITEM "Extraire l'élément de ressource binaire...", ID_EXTRACTBIN
        }
        MENUITEM SEPARATOR
        MENUITEM "Changer le nom / la langue\tF2", ID_EDITLABEL
        MENUITEM SEPARATOR
        MENUITEM "Cloner sous un nouveau nom...", ID_COPYASNEWNAME
        MENUITEM "Cloner dans une nouvelle langue...", ID_COPYASNEWLANG
        MENUITEM "Copier dans plusieurs langues...", ID_COPYTOMULTILANG
        MENUITEM SEPARATOR
        MENUITEM "Faire un test", ID_TEST
        MENUITEM SEPARATOR
        MENUITEM "Supprimer\tDel", ID_DELETERES
        MENUITEM SEPARATOR
        MENUITEM "&Association ID...", ID_IDASSOC
        MENUITEM "Macros prédéfinies...", ID_PREDEFMACROS
        MENUITEM "&Paramètres de police...", ID_FONTS
        MENUITEM "Définir les chemins...", ID_SETPATHS
        MENUITEM SEPARATOR
        MENUITEM "&UI Language Select (UI语言选择)...", ID_CHOOSEUILANG
        MENUITEM SEPARATOR
        MENUITEM "&Paramètres Delphi DFM...", ID_DFMSETTINGS
        MENUITEM "&Configuration...", ID_CONFIG
    }
    POPUP "&Chercher"
    {
        MENUITEM "&Trouver...\tCtrl+F", ID_FIND
        MENUITEM SEPARATOR
        MENUITEM "Rechercher vers le haut\tShift+F3", ID_FINDUPWARD
        MENUITEM "Recherche vers le bas\tF3", ID_FINDDOWNWARD
        MENUITEM SEPARATOR
        MENUITEM "&Constante de requête...", ID_QUERYCONSTANT
    }
    POPUP "&Vue"
    {
        MENUITEM "&Barre d'état", ID_STATUSBAR
        MENUITEM "&Barre d'outils", ID_SHOWHIDETOOLBAR
        MENUITEM "&Binaire", ID_BINARYPANE
        MENUITEM SEPARATOR
        MENUITEM "Développer tout\tCtrl+K", ID_EXPAND_ALL
        MENUITEM "Réduire tout\tCtrl+L", ID_COLLAPSE_ALL
        MENUITEM SEPARATOR
        MENUITEM "Liste des ID de ressource", ID_IDLIST
        MENUITEM "Liste des langues...", ID_SHOWLANGS
        MENUITEM SEPARATOR
        MENUITEM "Instruction Always CONTROL", ID_ALWAYSCONTROL
        MENUITEM "N'utilisez pas de macros d'identification", ID_HIDEIDMACROS
        MENUITEM "Utilisez IDC_STATIC", ID_USEIDC_STATIC
        MENUITEM "&Habillage de mots", ID_WORD_WRAP
        MENUITEM "Utilisez BEGIN / END", ID_USEBEGINEND
        MENUITEM "Use Microsoft Message &Table", ID_USEMSMSGTBL
        MENUITEM SEPARATOR
        MENUITEM "&Encodage de l'élément de ressource...", ID_ENCODING
        MENUITEM "Dialog &font substitutes...", ID_DIALOG_FONT_SUBSTITUTES
        MENUITEM SEPARATOR
        MENUITEM "Rafraîchir", ID_REFRESHALL
    }
    POPUP "&Automatisation"
    {
        MENUITEM "Le langage de programmation EGA...", ID_EGA
        MENUITEM "&Exécuter le programme EGA...", ID_EGA_PROGRAM
        MENUITEM "Ouvrir le manuel EGA", ID_OPEN_EGA_MANUAL
    }
    POPUP "&Aidez-moi"
    {
        MENUITEM "Ouvrez README.txt (Anglais)", ID_OPENREADME
        MENUITEM "Ouvrez LICENSE.txt", ID_OPENLICENSE
        MENUITEM SEPARATOR
        MENUITEM "Un &guide pour RisohEditor", ID_GUIDE
        MENUITEM "Vérifier la mise à jour de RisohEditor...", ID_CHECKUPDATE
        MENUITEM SEPARATOR
        MENUITEM "&À propos de...", ID_ABOUT
    }
}

IDR_POPUPMENUS MENU
{
    POPUP "Apparaitre #0"
    {
        MENUITEM "Modifier par &GUI...\tCtrl+G", ID_GUIEDIT
        MENUITEM SEPARATOR
        POPUP "&Ajouter"
        {
            MENUITEM "Ajouter une icône...", ID_ADDICON
            MENUITEM "Ajouter un curseur...", ID_ADDCURSOR
            MENUITEM "Ajouter un bitmap...", ID_ADDBITMAP
            MENUITEM "Ajouter une boîte de dialogue...", ID_ADDDIALOG
            MENUITEM "Ajouter un menu...", ID_ADDMENU
            MENUITEM "Ajouter une table de chaînes...", ID_ADDSTRINGTABLE
            MENUITEM "Ajouter une table de messages...", ID_ADDMESSAGETABLE
            MENUITEM "Ajouter du HTML...", ID_ADDHTML
            MENUITEM "Ajouter des accélérateurs...", ID_ADDACCEL
            MENUITEM "Ajouter des informations sur la version...", ID_ADDVERINFO
            MENUITEM "Ajouter un manifeste...", ID_ADDMANIFEST
            MENUITEM "Ajouter une barre d'ou&tils...", ID_ADDTOOLBAR
            MENUITEM "Ajouter un élément de ressource...", ID_ADDRES
        }
        POPUP "&Remplacer"
        {
            MENUITEM "Remplacer l'icône...", ID_REPLACEICON
            MENUITEM "Remplacer le curseur...", ID_REPLACECURSOR
            MENUITEM "Remplacer le bitmap...", ID_REPLACEBITMAP
            MENUITEM "Remplacer l'élément de ressource binaire...", ID_REPLACEBIN
        }
        POPUP "&Extrait"
        {
            MENUITEM "Extraire l'icône...", ID_EXTRACTICON
            MENUITEM "Extraire le curseur...", ID_EXTRACTCURSOR
            MENUITEM "Extraire le bitmap...", ID_EXTRACTBITMAP
            MENUITEM "Extraire en tant que fichier RC...", ID_EXTRACTRC
            MENUITEM "Extraire l'élément de ressource binaire...", ID_EXTRACTBIN
        }
        MENUITEM SEPARATOR
        MENUITEM "Changer le nom / la langue\tF2", ID_EDITLABEL
        MENUITEM SEPARATOR
        MENUITEM "Cloner sous un nouveau nom...", ID_COPYASNEWNAME
        MENUITEM "Cloner dans une nouvelle langue...", ID_COPYASNEWLANG
        MENUITEM "Copier dans plusieurs langues...", ID_COPYTOMULTILANG
        MENUITEM SEPARATOR
        MENUITEM "Faire un test", ID_TEST
        MENUITEM SEPARATOR
        MENUITEM "&Supprimer\tDel", ID_DELETERES
    }
    POPUP "Apparaitre #1"
    {
        MENUITEM "&Ajouter un contrôle...", ID_ADDCTRL
        MENUITEM SEPARATOR
        MENUITEM "Couper\tCtrl+X", ID_CUT
        MENUITEM "Copie\tCtrl+C", ID_COPY
        MENUITEM "Pâte\tCtrl+V", ID_PASTE
        MENUITEM "Supprimer\tDel", ID_DELCTRL
        MENUITEM SEPARATOR
        POPUP "&Indice"
        {
            MENUITEM "Aller en haut", ID_CTRLINDEXTOP
            MENUITEM SEPARATOR
            MENUITEM "Index de décrémentation", ID_CTRLINDEXMINUS
            MENUITEM "Indice d'incrément", ID_CTRLINDEXPLUS
            MENUITEM SEPARATOR
            MENUITEM "Aller en bas", ID_CTRLINDEXBOTTOM
            MENUITEM SEPARATOR
            MENUITEM "Afficher / masquer les index\tCtrl+D", ID_SHOWHIDEINDEX
        }
        POPUP "&Alignement"
        {
            MENUITEM "&Top-Align", ID_TOPALIGN
            MENUITEM "&Bottom-Align", ID_BOTTOMALIGN
            MENUITEM "&Left-Align", ID_LEFTALIGN
            MENUITEM "&Right-Align", ID_RIGHTALIGN
            MENUITEM SEPARATOR
            MENUITEM "Ajuster à la grille", ID_FITTOGRID
        }
        MENUITEM SEPARATOR
        MENUITEM "&Rafraîchir", ID_REFRESHDIALOG
        MENUITEM SEPARATOR
        MENUITEM "&Propriétés de contrôle...", ID_CTRLPROP
        MENUITEM "Propriétés de la boîte de dialogue...", ID_DLGPROP
    }
    POPUP "Apparaitre #2"
    {
        MENUITEM "&Modifier...", ID_MODIFYASSOC
    }
    POPUP "Apparaitre #3"
    {
        MENUITEM "&Saut!", ID_IDJUMP
        MENUITEM SEPARATOR
        MENUITEM "&Ajouter un identifiant...", ID_ADDRESID
        MENUITEM "&Modifier l'ID...", ID_MODIFYRESID
        MENUITEM SEPARATOR
        MENUITEM "Copier le nom", ID_COPYRESIDNAME
        MENUITEM "Copier la valeur", ID_COPYRESIDVALUE
        MENUITEM "Copier la définition\tCtrl+C", ID_COPYIDDEF
        MENUITEM SEPARATOR
        MENUITEM "&Supprimer l'ID\tDel", ID_DELETERESID
        MENUITEM SEPARATOR
        MENUITEM "&Nombres décimaux", ID_BASE10
        MENUITEM "&Nombres hexadécimaux", ID_BASE16
        MENUITEM SEPARATOR
        MENUITEM "&Recharger", ID_LOADRESH
    }
    POPUP "Apparaitre #4"
    {
        MENUITEM "&Ajouter...", ID_ADD
        MENUITEM SEPARATOR
        MENUITEM "Changer de nom...\tF2", ID_RENAME
        MENUITEM "Changer la valeur...", ID_MODIFY
        MENUITEM SEPARATOR
        MENUITEM "&Supprimer\tDel", ID_DELETE
    }
    POPUP "Apparaitre #5"
    {
        MENUITEM "&Copier la valeur entière", ID_COPY
    }
    POPUP "Apparaitre #6"
    {
        MENUITEM "&Ajouter...", psh1
        MENUITEM "&Modifier...", psh2
        MENUITEM SEPARATOR
        MENUITEM "&En haut", psh4
        MENUITEM "&Vers le bas", psh5
        MENUITEM "&Gauche", psh6
        MENUITEM "&Droit", psh7
        MENUITEM SEPARATOR
        MENUITEM "Delete\tDel", psh3
    }
    POPUP "Apparaitre #7"
    {
        MENUITEM "&Ajouter...", psh1
        MENUITEM "&Modifier...", psh2
        MENUITEM SEPARATOR
        MENUITEM "&En haut", psh4
        MENUITEM "&Vers le bas", psh5
        MENUITEM SEPARATOR
        MENUITEM "Supprimer\tDel", psh3
    }
    POPUP "Apparaitre #8"
    {
        MENUITEM "&Ajouter...", ID_ADD
        MENUITEM "&Modifier...", ID_MODIFY
        MENUITEM SEPARATOR
        MENUITEM "&Supprimer\tDel", ID_DELETE
    }
}

//////////////////////////////////////////////////////////////////////////////
// RT_DIALOG

IDD_REPLACERES DIALOGEX 0, 0, 215, 170
CAPTION "Remplacer la ressource"
STYLE DS_MODALFRAME | WS_POPUPWINDOW | WS_CAPTION
FONT 9, "MS Shell Dlg", 0, 0, 1
{
    LTEXT "&Type de ressource :", -1, 5, 7, 70, 12
    COMBOBOX cmb1, 75, 5, 135, 200, CBS_HASSTRINGS | CBS_AUTOHSCROLL | CBS_DROPDOWN | WS_BORDER | WS_VSCROLL | WS_TABSTOP
    LTEXT "&Nom de la ressource :", -1, 5, 32, 70, 12
    COMBOBOX cmb2, 75, 30, 135, 200, CBS_HASSTRINGS | CBS_AUTOHSCROLL | CBS_DROPDOWN | WS_DISABLED | WS_BORDER | WS_VSCROLL | WS_TABSTOP
    LTEXT "&Langue de la ressource :", -1, 5, 57, 80, 12
    COMBOBOX cmb3, 85, 54, 125, 300, CBS_HASSTRINGS | CBS_AUTOHSCROLL | CBS_DROPDOWN | WS_DISABLED | WS_BORDER | WS_VSCROLL | WS_TABSTOP
    LTEXT "&Binaire et fichier :", -1, 5, 85, 100, 12
    EDITTEXT edt1, 5, 97, 205, 14, ES_AUTOHSCROLL
    PUSHBUTTON "&Feuilleter...", psh1, 150, 115, 60, 14
    DEFPUSHBUTTON "OK", IDOK, 35, 150, 60, 14
    PUSHBUTTON "Annuler", IDCANCEL, 115, 150, 60, 14
    {
        0x1234, 0x5678, 0x0011
    }
}

IDD_ADDICON DIALOG 0, 0, 215, 135
CAPTION "Ajouter une icône"
STYLE DS_MODALFRAME | WS_POPUPWINDOW | WS_CAPTION
FONT 9, "MS Shell Dlg"
{
    LTEXT "Fichier d'icône :", -1, 5, 7, 100, 12
    EDITTEXT edt1, 5, 18, 205, 14, ES_AUTOHSCROLL
    PUSHBUTTON "&Feuilleter...", psh1, 150, 35, 60, 14
    ICON 0, ico1, 5, 35, 0, 0
    LTEXT "&Nom de la ressource :", -1, 5, 67, 70, 12
    COMBOBOX cmb2, 75, 65, 120, 300, CBS_HASSTRINGS | CBS_AUTOHSCROLL | CBS_DROPDOWN | WS_BORDER | WS_VSCROLL | WS_TABSTOP
    PUSHBUTTON "&...", psh2, 195, 65, 15, 14
    LTEXT "&Langue de la ressource :", -1, 5, 92, 80, 12
    COMBOBOX cmb3, 85, 89, 125, 300, CBS_HASSTRINGS | CBS_AUTOHSCROLL | CBS_DROPDOWN | WS_BORDER | WS_VSCROLL | WS_TABSTOP
    DEFPUSHBUTTON "OK", IDOK, 35, 115, 60, 14
    PUSHBUTTON "Annuler", IDCANCEL, 115, 115, 60, 14
}

IDD_REPLACEICON DIALOG 0, 0, 215, 135
CAPTION "Remplacer l'icône"
STYLE DS_MODALFRAME | WS_POPUPWINDOW | WS_CAPTION
FONT 9, "MS Shell Dlg"
{
    LTEXT "Fichier d'icône :", -1, 5, 7, 100, 12
    EDITTEXT edt1, 5, 18, 205, 14, ES_AUTOHSCROLL
    PUSHBUTTON "&Feuilleter...", psh1, 150, 35, 60, 14
    ICON 0, ico1, 5, 35, 0, 0
    LTEXT "&Nom de la ressource :", -1, 5, 67, 70, 12
    COMBOBOX cmb2, 75, 65, 135, 13, CBS_HASSTRINGS | CBS_AUTOHSCROLL | CBS_DROPDOWN | WS_DISABLED | WS_BORDER | WS_VSCROLL | WS_TABSTOP
    LTEXT "&Langue de la ressource :", -1, 5, 92, 80, 12
    COMBOBOX cmb3, 85, 89, 125, 300, CBS_HASSTRINGS | CBS_AUTOHSCROLL | CBS_DROPDOWN | WS_DISABLED | WS_BORDER | WS_VSCROLL | WS_TABSTOP
    DEFPUSHBUTTON "OK", IDOK, 35, 115, 60, 14
    PUSHBUTTON "Annuler", IDCANCEL, 115, 115, 60, 14
}

IDD_ADDBITMAP DIALOG 0, 0, 215, 135
CAPTION "Ajouter un bitmap"
STYLE DS_MODALFRAME | WS_POPUPWINDOW | WS_CAPTION
FONT 9, "MS Shell Dlg"
{
    LTEXT "Fichier &bitmap :", -1, 5, 7, 100, 12
    EDITTEXT edt1, 5, 18, 205, 14, ES_AUTOHSCROLL
    PUSHBUTTON "&Feuilleter...", psh1, 150, 35, 60, 14
    LTEXT "&Nom de la ressource :", -1, 5, 67, 70, 12
    COMBOBOX cmb2, 75, 65, 120, 300, CBS_HASSTRINGS | CBS_AUTOHSCROLL | CBS_DROPDOWN | WS_BORDER | WS_VSCROLL | WS_TABSTOP
    PUSHBUTTON "&...", psh2, 195, 65, 15, 14
    LTEXT "&Langue de la ressource :", -1, 5, 92, 80, 12
    COMBOBOX cmb3, 85, 89, 125, 300, CBS_HASSTRINGS | CBS_AUTOHSCROLL | CBS_DROPDOWN | WS_BORDER | WS_VSCROLL | WS_TABSTOP
    DEFPUSHBUTTON "OK", IDOK, 35, 115, 60, 14
    PUSHBUTTON "Annuler", IDCANCEL, 115, 115, 60, 14
}

IDD_REPLACEBMP DIALOG 0, 0, 215, 135
CAPTION "Remplacer le bitmap"
STYLE DS_MODALFRAME | WS_POPUPWINDOW | WS_CAPTION
FONT 9, "MS Shell Dlg"
{
    LTEXT "Fichier &bitmap :", -1, 5, 7, 100, 12
    EDITTEXT edt1, 5, 18, 205, 14, ES_AUTOHSCROLL
    PUSHBUTTON "&Feuilleter...", psh1, 150, 35, 60, 14
    LTEXT "&Nom de la ressource :", -1, 5, 67, 70, 12
    COMBOBOX cmb2, 75, 65, 135, 200, CBS_HASSTRINGS | CBS_AUTOHSCROLL | CBS_DROPDOWN | WS_DISABLED | WS_BORDER | WS_VSCROLL | WS_TABSTOP
    LTEXT "&Langue de la ressource :", -1, 5, 92, 80, 12
    COMBOBOX cmb3, 85, 89, 125, 300, CBS_HASSTRINGS | CBS_AUTOHSCROLL | CBS_DROPDOWN | WS_DISABLED | WS_BORDER | WS_VSCROLL | WS_TABSTOP
    DEFPUSHBUTTON "OK", IDOK, 35, 115, 60, 14
    PUSHBUTTON "Annuler", IDCANCEL, 115, 115, 60, 14
}

IDD_ADDRES DIALOG 0, 0, 215, 170
CAPTION "Ajouter une ressource"
STYLE DS_MODALFRAME | WS_POPUPWINDOW | WS_CAPTION
FONT 9, "MS Shell Dlg"
{
    LTEXT "&Type de ressource :", -1, 5, 7, 70, 12
    COMBOBOX cmb1, 75, 5, 135, 200, CBS_HASSTRINGS | CBS_AUTOHSCROLL | CBS_DROPDOWN | WS_BORDER | WS_VSCROLL | WS_TABSTOP
    LTEXT "&Nom de la ressource :", -1, 5, 32, 70, 12
    COMBOBOX cmb2, 75, 30, 120, 300, CBS_HASSTRINGS | CBS_AUTOHSCROLL | CBS_DROPDOWN | WS_BORDER | WS_VSCROLL | WS_TABSTOP
    PUSHBUTTON "&...", psh2, 195, 30, 15, 14
    LTEXT "", stc1, 75, 43, 115, 10
    LTEXT "&Langue de la ressource :", -1, 5, 57, 80, 12
    COMBOBOX cmb3, 85, 54, 125, 300, CBS_HASSTRINGS | CBS_AUTOHSCROLL | CBS_DROPDOWN | WS_BORDER | WS_VSCROLL | WS_TABSTOP
    LTEXT "&Binaire et fichier :", -1, 5, 85, 100, 12
    EDITTEXT edt1, 5, 97, 205, 14, ES_AUTOHSCROLL
    PUSHBUTTON "&Feuilleter...", psh1, 150, 115, 60, 14
    LTEXT "", stc2, 5, 112, 100, 10
    DEFPUSHBUTTON "OK", IDOK, 35, 150, 60, 14
    PUSHBUTTON "Annuler", IDCANCEL, 115, 150, 60, 14
}

IDD_ADDCURSOR DIALOG 0, 0, 215, 135
CAPTION "Ajouter un curseur"
STYLE DS_MODALFRAME | WS_POPUPWINDOW | WS_CAPTION
FONT 9, "MS Shell Dlg"
{
    LTEXT "Fichier de &curseur :", -1, 5, 7, 100, 12
    EDITTEXT edt1, 5, 18, 205, 14, ES_AUTOHSCROLL
    PUSHBUTTON "&Feuilleter...", psh1, 150, 35, 60, 14
    ICON 0, ico1, 5, 35, 0, 0
    LTEXT "&Nom de la ressource :", -1, 5, 67, 70, 12
    COMBOBOX cmb2, 75, 65, 120, 200, CBS_HASSTRINGS | CBS_AUTOHSCROLL | CBS_DROPDOWN | WS_BORDER | WS_VSCROLL | WS_TABSTOP
    PUSHBUTTON "&...", psh2, 195, 65, 15, 14
    LTEXT "&Langue de la ressource :", -1, 5, 92, 80, 12
    COMBOBOX cmb3, 85, 89, 125, 300, CBS_HASSTRINGS | CBS_AUTOHSCROLL | CBS_DROPDOWN | WS_BORDER | WS_VSCROLL | WS_TABSTOP
    DEFPUSHBUTTON "OK", IDOK, 35, 115, 60, 14
    PUSHBUTTON "Annuler", IDCANCEL, 115, 115, 60, 14
}

IDD_REPLACECUR DIALOG 0, 0, 215, 135
CAPTION "Remplacer le curseur"
STYLE DS_MODALFRAME | WS_POPUPWINDOW | WS_CAPTION
FONT 9, "MS Shell Dlg"
{
    LTEXT "Fichier de &curseur :", -1, 5, 7, 100, 12
    EDITTEXT edt1, 5, 18, 205, 14, ES_AUTOHSCROLL
    PUSHBUTTON "&Feuilleter...", psh1, 150, 35, 60, 14
    ICON 0, ico1, 5, 35, 0, 0
    LTEXT "&Nom de la ressource :", -1, 5, 67, 70, 12
    COMBOBOX cmb2, 75, 65, 135, 200, CBS_HASSTRINGS | CBS_AUTOHSCROLL | CBS_DROPDOWN | WS_DISABLED | WS_BORDER | WS_VSCROLL | WS_TABSTOP
    LTEXT "&Langue de la ressource :", -1, 5, 92, 80, 12
    COMBOBOX cmb3, 85, 89, 125, 300, CBS_HASSTRINGS | CBS_AUTOHSCROLL | CBS_DROPDOWN | WS_DISABLED | WS_BORDER | WS_VSCROLL | WS_TABSTOP
    DEFPUSHBUTTON "OK", IDOK, 35, 115, 60, 14
    PUSHBUTTON "Annuler", IDCANCEL, 115, 115, 60, 14
}

IDD_MENUTEST DIALOG 0, 0, 215, 135
CAPTION "Test de menu"
STYLE DS_MODALFRAME | WS_POPUPWINDOW | WS_CAPTION
FONT 9, "MS Shell Dlg"
{
}

IDD_ADDKEY DIALOG 0, 0, 190, 120
CAPTION "Ajouter une clé"
STYLE DS_MODALFRAME | WS_POPUPWINDOW | WS_CAPTION
FONT 9, "MS Shell Dlg"
{
    RTEXT "&Clé :", -1, 5, 12, 60, 14
    COMBOBOX cmb1, 70, 10, 110, 200, CBS_DROPDOWN | WS_BORDER | WS_VSCROLL | WS_TABSTOP
    RTEXT "ID de commande :", -1, 5, 37, 60, 14
    COMBOBOX cmb2, 70, 35, 95, 300, CBS_DROPDOWN | WS_BORDER | WS_VSCROLL | WS_TABSTOP
    PUSHBUTTON "&...", psh1, 165, 35, 15, 14
    AUTOCHECKBOX "&VIRTKEY", chx1, 5, 60, 60, 14
    AUTOCHECKBOX "&NOINVERT", chx2, 70, 60, 60, 14
    AUTOCHECKBOX "&CONTROL", chx3, 5, 75, 60, 14
    AUTOCHECKBOX "&SHIFT", chx4, 70, 75, 60, 14
    AUTOCHECKBOX "&ALT", chx5, 140, 75, 45, 14
    DEFPUSHBUTTON "OK", IDOK, 60, 100, 60, 14
    PUSHBUTTON "Annuler", IDCANCEL, 125, 100, 60, 14
}

IDD_MODIFYKEY DIALOG 0, 0, 190, 120
CAPTION "Modifier la clé"
STYLE DS_MODALFRAME | WS_POPUPWINDOW | WS_CAPTION
FONT 9, "MS Shell Dlg"
{
    RTEXT "&Clé :", -1, 5, 12, 60, 14
    COMBOBOX cmb1, 70, 10, 110, 200, CBS_DROPDOWN | WS_BORDER | WS_VSCROLL | WS_TABSTOP
    RTEXT "ID de commande :", -1, 5, 37, 60, 14
    COMBOBOX cmb2, 70, 35, 95, 200, CBS_DROPDOWN | WS_BORDER | WS_VSCROLL | WS_TABSTOP
    PUSHBUTTON "&...", psh1, 165, 35, 15, 14
    AUTOCHECKBOX "&VIRTKEY", chx1, 5, 60, 60, 14
    AUTOCHECKBOX "&NOINVERT", chx2, 70, 60, 60, 14
    AUTOCHECKBOX "&CONTROL", chx3, 5, 75, 60, 14
    AUTOCHECKBOX "&SHIFT", chx4, 70, 75, 60, 14
    AUTOCHECKBOX "&ALT", chx5, 140, 75, 45, 14
    DEFPUSHBUTTON "OK", IDOK, 60, 100, 60, 14
    PUSHBUTTON "Annuler", IDCANCEL, 125, 100, 60, 14
}

IDD_EDITACCEL DIALOG 0, 0, 285, 165
CAPTION "Modifier les accélérateurs"
STYLE WS_POPUPWINDOW | WS_CAPTION | WS_THICKFRAME
FONT 9, "MS Shell Dlg"
{
    LTEXT "Liste des clés :", -1, 5, 7, 100, 12
    CONTROL "", lst1, "SysListView32", LVS_NOSORTHEADER | LVS_AUTOARRANGE | LVS_NOLABELWRAP | LVS_SHOWSELALWAYS | LVS_SINGLESEL | LVS_REPORT | WS_BORDER | WS_VSCROLL | WS_HSCROLL | WS_TABSTOP, 5, 20, 210, 120
    PUSHBUTTON "&Ajouter...", psh1, 220, 20, 60, 14
    PUSHBUTTON "&Modifier...", psh2, 220, 40, 60, 14
    PUSHBUTTON "&Supprimer", psh3, 220, 60, 60, 14
    PUSHBUTTON "&En haut", psh4, 220, 100, 60, 14
    PUSHBUTTON "&Vers le bas", psh5, 220, 120, 60, 14
    DEFPUSHBUTTON "OK", IDOK, 155, 145, 60, 14
    PUSHBUTTON "Annuler", IDCANCEL, 220, 145, 60, 14
    PUSHBUTTON "Supprimer tout", psh6, 5, 145, 79, 14
}

IDD_ADDSTR DIALOG 0, 0, 255, 115
CAPTION "Ajouter une entrée de chaîne"
STYLE WS_POPUPWINDOW | WS_CAPTION | WS_THICKFRAME
FONT 9, "MS Shell Dlg"
{
    LTEXT "ID de chaîne :", -1, 5, 7, 50, 12
    COMBOBOX cmb1, 60, 5, 134, 200, CBS_HASSTRINGS | CBS_AUTOHSCROLL | CBS_DROPDOWN | WS_BORDER | WS_VSCROLL | WS_TABSTOP
    PUSHBUTTON "&...", psh1, 195, 5, 15, 14
    LTEXT "Valeur de chaîne :", -1, 5, 27, 54, 20
    EDITTEXT edt1, 60, 25, 190, 45, ES_WANTRETURN | ES_AUTOVSCROLL | ES_MULTILINE | WS_VSCROLL
    AUTOCHECKBOX "&Remplacez ""\\r\\n"" par ""\\n""", chx1, 60, 75, 190, 14
    DEFPUSHBUTTON "OK", IDOK, 125, 95, 60, 14
    PUSHBUTTON "Annuler", IDCANCEL, 190, 95, 60, 14
}

IDD_MODIFYSTR DIALOG 0, 0, 255, 115
CAPTION "Modifier l'entrée de chaîne"
STYLE WS_POPUPWINDOW | WS_CAPTION | WS_THICKFRAME
FONT 9, "MS Shell Dlg"
{
    LTEXT "ID de chaîne :", -1, 5, 7, 50, 12
    COMBOBOX cmb1, 60, 5, 134, 200, CBS_HASSTRINGS | CBS_AUTOHSCROLL | CBS_DROPDOWN | WS_BORDER | WS_VSCROLL | WS_TABSTOP
    PUSHBUTTON "&...", psh1, 195, 5, 15, 14
    LTEXT "Valeur de chaîne :", -1, 5, 27, 54, 12
    EDITTEXT edt1, 60, 25, 190, 45, ES_WANTRETURN | ES_AUTOVSCROLL | ES_MULTILINE | WS_VSCROLL
    AUTOCHECKBOX "&Remplacez ""\\r\\n"" par ""\\n""", chx1, 60, 75, 190, 14
    DEFPUSHBUTTON "OK", IDOK, 125, 95, 60, 14
    PUSHBUTTON "Annuler", IDCANCEL, 190, 95, 60, 14
}

IDD_STRINGS DIALOG 0, 0, 325, 160
CAPTION "Table à cordes"
STYLE WS_POPUPWINDOW | WS_CAPTION | WS_THICKFRAME
FONT 9, "MS Shell Dlg"
{
    LTEXT "Entrées de chaîne :", -1, 5, 7, 100, 12
    CONTROL "", lst1, "SysListView32", LVS_NOSORTHEADER | LVS_AUTOARRANGE | LVS_NOLABELWRAP | LVS_SHOWSELALWAYS | LVS_SINGLESEL | LVS_REPORT | WS_BORDER | WS_VSCROLL | WS_HSCROLL | WS_TABSTOP, 5, 20, 315, 115
    PUSHBUTTON "&Ajouter...", psh1, 130, 3, 60, 14
    PUSHBUTTON "&Modifier...", psh2, 195, 3, 60, 14
    PUSHBUTTON "&Supprimer", psh3, 260, 3, 60, 14
    DEFPUSHBUTTON "OK", IDOK, 195, 140, 60, 14
    PUSHBUTTON "Annuler", IDCANCEL, 260, 140, 60, 14
    PUSHBUTTON "Supprimer &tout", psh4, 5, 140, 75, 14
}

IDD_ADDMITEM DIALOG 0, 0, 210, 200
CAPTION "Ajouter un élément de menu"
STYLE DS_MODALFRAME | WS_POPUPWINDOW | WS_CAPTION
FONT 9, "MS Shell Dlg"
{
    LTEXT "Légende :", -1, 5, 7, 55, 12
    COMBOBOX cmb1, 65, 6, 140, 200, CBS_AUTOHSCROLL | CBS_DROPDOWN | WS_BORDER | WS_VSCROLL | WS_TABSTOP
    LTEXT "ID de commande :", -1, 5, 28, 55, 18
    COMBOBOX cmb2, 65, 30, 125, 200, CBS_AUTOHSCROLL | CBS_DROPDOWN | WS_BORDER | WS_VSCROLL | WS_TABSTOP
    PUSHBUTTON "&...", psh1, 190, 30, 15, 14
    AUTOCHECKBOX "&GRAYED", chx1, 5, 60, 60, 14
    AUTOCHECKBOX "&BITMAP", chx3, 135, 60, 60, 14
    AUTOCHECKBOX "&OWNERDRAW", chx4, 5, 80, 65, 14
    AUTOCHECKBOX "&CHECKED", chx5, 75, 80, 60, 14
    AUTOCHECKBOX "SE&PARATOR", chx6, 140, 80, 60, 14
    AUTOCHECKBOX "MENU&BARBREAK", chx7, 5, 100, 75, 14
    AUTOCHECKBOX "MENUB&REAK", chx8, 85, 100, 70, 14
    AUTOCHECKBOX "&DEFAULT", chx9, 5, 120, 60, 14
    AUTOCHECKBOX "&HILITE", chx10, 70, 120, 60, 14
    AUTOCHECKBOX "RADIOCHEC&K", chx11, 135, 120, 60, 14
    AUTOCHECKBOX "RIGH&TORDER", chx12, 5, 139, 60, 14
    AUTOCHECKBOX "RIGHT&JUSTIFY", chx13, 70, 140, 70, 14
    LTEXT "ID d'aide :", -1, 5, 162, 45, 12
    COMBOBOX cmb3, 55, 160, 100, 300, CBS_AUTOHSCROLL | CBS_DROPDOWN | WS_BORDER | WS_VSCROLL | WS_TABSTOP
    DEFPUSHBUTTON "OK", IDOK, 80, 180, 60, 14
    PUSHBUTTON "Annuler", IDCANCEL, 145, 180, 60, 14
}

IDD_MODIFYMITEM DIALOG 0, 0, 210, 200
CAPTION "Modifier l'élément de menu"
STYLE DS_MODALFRAME | WS_POPUPWINDOW | WS_CAPTION
FONT 9, "MS Shell Dlg"
{
    LTEXT "Légende :", -1, 5, 7, 55, 12
    COMBOBOX cmb1, 65, 6, 140, 200, CBS_AUTOHSCROLL | CBS_DROPDOWN | WS_BORDER | WS_VSCROLL | WS_TABSTOP
    LTEXT "ID de commande :", -1, 5, 28, 55, 18
    COMBOBOX cmb2, 65, 30, 125, 200, CBS_AUTOHSCROLL | CBS_DROPDOWN | WS_BORDER | WS_VSCROLL | WS_TABSTOP
    PUSHBUTTON "&...", psh1, 190, 30, 15, 14
    AUTOCHECKBOX "&GRAYED", chx1, 5, 60, 60, 14
    AUTOCHECKBOX "&BITMAP", chx3, 135, 60, 60, 14
    AUTOCHECKBOX "&OWNERDRAW", chx4, 5, 80, 65, 14
    AUTOCHECKBOX "&CHECKED", chx5, 75, 80, 60, 14
    AUTOCHECKBOX "SE&PARATOR", chx6, 140, 80, 60, 14
    AUTOCHECKBOX "MENU&BARBREAK", chx7, 5, 100, 75, 14
    AUTOCHECKBOX "MENUB&REAK", chx8, 85, 100, 70, 14
    AUTOCHECKBOX "&DEFAULT", chx9, 5, 120, 60, 14
    AUTOCHECKBOX "&HILITE", chx10, 70, 120, 60, 14
    AUTOCHECKBOX "RADIOCHEC&K", chx11, 135, 120, 60, 14
    AUTOCHECKBOX "RIGH&TORDER", chx12, 5, 139, 60, 14
    AUTOCHECKBOX "RIGHT&JUSTIFY", chx13, 70, 140, 70, 14
    LTEXT "ID d'aide :", -1, 5, 162, 45, 12
    COMBOBOX cmb3, 55, 160, 100, 300, CBS_AUTOHSCROLL | CBS_DROPDOWN | WS_BORDER | WS_VSCROLL | WS_TABSTOP
    DEFPUSHBUTTON "OK", IDOK, 80, 180, 60, 14
    PUSHBUTTON "Annuler", IDCANCEL, 145, 180, 60, 14
}

IDD_EDITMENU DIALOG 0, 0, 325, 160
CAPTION "Modifier la ressource du menu"
STYLE WS_POPUPWINDOW | WS_CAPTION | WS_THICKFRAME
FONT 9, "MS Shell Dlg"
{
    LTEXT "Ressource de menu :", -1, 5, 7, 85, 12
    CONTROL "", lst1, "SysListView32", LVS_NOSORTHEADER | LVS_AUTOARRANGE | LVS_NOLABELWRAP | LVS_SHOWSELALWAYS | LVS_SINGLESEL | LVS_REPORT | WS_BORDER | WS_VSCROLL | WS_HSCROLL | WS_TABSTOP, 5, 20, 315, 115
    PUSHBUTTON "&Ajouter...", psh1, 95, 3, 50, 14
    PUSHBUTTON "&Modifier...", psh2, 150, 3, 50, 14
    PUSHBUTTON "&Supprimer", psh3, 205, 3, 50, 14
    PUSHBUTTON "&En haut", psh4, 5, 140, 40, 14
    PUSHBUTTON "&Vers le bas", psh5, 50, 140, 40, 14
    PUSHBUTTON "&Gauche", psh6, 95, 140, 40, 14
    PUSHBUTTON "&Droit", psh7, 140, 140, 41, 14
    AUTOCHECKBOX "Élargi", chx1, 260, 3, 60, 14
    DEFPUSHBUTTON "OK", IDOK, 195, 140, 60, 14
    PUSHBUTTON "Annuler", IDCANCEL, 260, 140, 60, 14
}

IDD_DLGPROP DIALOG 0, 0, 235, 315
CAPTION "Propriétés de la boîte de dialogue"
STYLE DS_MODALFRAME | WS_POPUPWINDOW | WS_CAPTION
FONT 9, "MS Shell Dlg"
{
    LTEXT "Légende :", -1, 5, 7, 85, 11
    COMBOBOX cmb1, 5, 20, 225, 300, CBS_HASSTRINGS | CBS_AUTOHSCROLL | CBS_DROPDOWN | WS_BORDER | WS_VSCROLL | WS_TABSTOP
    AUTOCHECKBOX "Boîte de dialogue étendue", chx1, 100, 5, 86, 14
    LTEXT "&Gauche :", -1, 5, 40, 33, 10
    EDITTEXT edt1, 5, 53, 30, 14, ES_NUMBER | ES_RIGHT
    CONTROL "", scr1, "msctls_updown32", UDS_NOTHOUSANDS | UDS_ARROWKEYS | UDS_AUTOBUDDY | UDS_ALIGNRIGHT | UDS_SETBUDDYINT, 23, 53, 12, 20
    LTEXT "Haut :", -1, 50, 40, 33, 10
    EDITTEXT edt2, 50, 53, 30, 14, ES_NUMBER | ES_RIGHT
    CONTROL "", scr2, "msctls_updown32", UDS_NOTHOUSANDS | UDS_ARROWKEYS | UDS_AUTOBUDDY | UDS_ALIGNRIGHT | UDS_SETBUDDYINT, 53, 53, 12, 20
    LTEXT "&Largeur :", -1, 95, 40, 33, 10
    EDITTEXT edt3, 95, 53, 30, 14, ES_NUMBER | ES_RIGHT
    CONTROL "", scr3, "msctls_updown32", UDS_NOTHOUSANDS | UDS_ARROWKEYS | UDS_AUTOBUDDY | UDS_ALIGNRIGHT | UDS_SETBUDDYINT, 129, 56, 12, 20
    LTEXT "&Hauteur :", -1, 142, 40, 33, 10
    EDITTEXT edt4, 142, 53, 30, 14, ES_NUMBER | ES_RIGHT
    CONTROL "", scr4, "msctls_updown32", UDS_NOTHOUSANDS | UDS_ARROWKEYS | UDS_AUTOBUDDY | UDS_ALIGNRIGHT | UDS_SETBUDDYINT, 162, 53, 12, 20
    LTEXT "Nom du cours :", -1, 5, 73, 85, 11
    COMBOBOX cmb2, 5, 88, 115, 200, CBS_HASSTRINGS | CBS_AUTOHSCROLL | CBS_DROPDOWN | WS_BORDER | WS_VSCROLL | WS_TABSTOP
    LTEXT "ID d'aide :", -1, 125, 73, 64, 11
    COMBOBOX cmb3, 125, 88, 65, 200, CBS_HASSTRINGS | CBS_AUTOHSCROLL | CBS_DROPDOWN | WS_BORDER | WS_VSCROLL | WS_TABSTOP
    LTEXT "&Nom de police :", -1, 5, 105, 80, 11
    COMBOBOX cmb4, 6, 118, 100, 200, CBS_HASSTRINGS | CBS_SORT | CBS_AUTOHSCROLL | CBS_DROPDOWN | WS_BORDER | WS_VSCROLL | WS_TABSTOP
    LTEXT "Taille :", -1, 110, 105, 38, 12
    EDITTEXT edt5, 110, 118, 25, 14, ES_NUMBER
    AUTOCHECKBOX "&B", chx2, 140, 118, 20, 14
    AUTOCHECKBOX "&I", chx3, 165, 118, 20, 14
    LTEXT "Cha&rSet :", -1, 5, 138, 80, 11
    COMBOBOX cmb5, 5, 148, 100, 100, CBS_AUTOHSCROLL | CBS_DROPDOWNLIST | WS_VSCROLL | WS_TABSTOP
    LTEXT "&Nom du menu :", -1, 110, 138, 55, 11
    COMBOBOX cmb6, 110, 148, 99, 300, CBS_HASSTRINGS | CBS_AUTOHSCROLL | CBS_DROPDOWN | WS_BORDER | WS_VSCROLL | WS_TABSTOP
    LTEXT "Style :", -1, 5, 168, 45, 11
    RTEXT "0x", -1, 52, 169, 10, 11
    EDITTEXT edt6, 67, 165, 45, 14, ES_AUTOHSCROLL
    LISTBOX lst1, 5, 183, 110, 110, LBS_DISABLENOSCROLL | LBS_NOINTEGRALHEIGHT | LBS_HASSTRINGS | LBS_MULTIPLESEL | WS_VSCROLL | WS_HSCROLL | WS_TABSTOP
    LTEXT "&ExStyle :", -1, 120, 168, 48, 11
    RTEXT "0x", -1, 170, 169, 10, 11
    EDITTEXT edt7, 185, 165, 45, 14, ES_AUTOHSCROLL
    LISTBOX lst2, 120, 183, 110, 110, LBS_DISABLENOSCROLL | LBS_NOINTEGRALHEIGHT | LBS_HASSTRINGS | LBS_MULTIPLESEL | WS_VSCROLL | WS_HSCROLL | WS_TABSTOP
    DEFPUSHBUTTON "OK", IDOK, 106, 298, 60, 14
    PUSHBUTTON "Annuler", IDCANCEL, 171, 298, 60, 14
}

IDD_CTRLPROP DIALOG 0, 0, 235, 330
CAPTION "Propriétés de contrôle"
STYLE DS_MODALFRAME | WS_POPUPWINDOW | WS_CAPTION
FONT 9, "MS Shell Dlg"
{
    LTEXT "Predef. &Ctrl :", -1, 5, 7, 68, 12
    COMBOBOX cmb1, 75, 5, 120, 55, CBS_HASSTRINGS | CBS_AUTOHSCROLL | CBS_DROPDOWN | WS_BORDER | WS_VSCROLL | WS_TABSTOP
    CONTROL "", ctl1, "ToolbarWindow32", TBSTYLE_FLAT | TBSTYLE_WRAPABLE | TBSTYLE_TOOLTIPS | CCS_NODIVIDER | CCS_NORESIZE, 5, 22, 185, 30
    LTEXT "Légende :", -1, 5, 55, 75, 12
    COMBOBOX cmb2, 5, 65, 195, 300, CBS_HASSTRINGS | CBS_AUTOHSCROLL | CBS_DROPDOWN | WS_BORDER | WS_VSCROLL | WS_TABSTOP
    PUSHBUTTON "&OLE...", psh2, 205, 65, 25, 14
    LTEXT "&Gauche :", -1, 5, 85, 33, 11
    EDITTEXT edt1, 5, 99, 25, 14, ES_NUMBER | ES_RIGHT
    CONTROL "", scr1, "msctls_updown32", UDS_NOTHOUSANDS | UDS_ARROWKEYS | UDS_AUTOBUDDY | UDS_ALIGNRIGHT | UDS_SETBUDDYINT, 20, 99, 12, 20
    LTEXT "Haut :", -1, 40, 85, 33, 11
    EDITTEXT edt2, 40, 99, 25, 14, ES_NUMBER | ES_RIGHT
    CONTROL "", scr2, "msctls_updown32", UDS_NOTHOUSANDS | UDS_ARROWKEYS | UDS_AUTOBUDDY | UDS_ALIGNRIGHT | UDS_SETBUDDYINT, 55, 99, 12, 20
    LTEXT "&Largeur :", -1, 75, 85, 33, 11
    EDITTEXT edt3, 75, 99, 25, 14, ES_NUMBER | ES_RIGHT
    CONTROL "", scr3, "msctls_updown32", UDS_NOTHOUSANDS | UDS_ARROWKEYS | UDS_AUTOBUDDY | UDS_ALIGNRIGHT | UDS_SETBUDDYINT, 90, 99, 12, 20
    LTEXT "&Hauteur :", -1, 111, 85, 33, 11
    EDITTEXT edt4, 110, 99, 25, 14, ES_NUMBER | ES_RIGHT
    CONTROL "", scr4, "msctls_updown32", UDS_NOTHOUSANDS | UDS_ARROWKEYS | UDS_AUTOBUDDY | UDS_ALIGNRIGHT | UDS_SETBUDDYINT, 125, 99, 12, 20
    LTEXT "&ID :", -1, 150, 85, 70, 12
    COMBOBOX cmb3, 150, 99, 80, 300, CBS_HASSTRINGS | CBS_AUTOHSCROLL | CBS_DROPDOWN | WS_BORDER | WS_VSCROLL | WS_TABSTOP
    LTEXT "Nom de classe de fenêtre :", -1, 5, 119, 100, 12
    COMBOBOX cmb4, 5, 133, 115, 200, CBS_HASSTRINGS | CBS_AUTOHSCROLL | CBS_DROPDOWN | WS_BORDER | WS_VSCROLL | WS_TABSTOP
    LTEXT "ID d'aide :", -1, 125, 119, 70, 12
    COMBOBOX cmb5, 125, 133, 65, 200, CBS_HASSTRINGS | CBS_AUTOHSCROLL | CBS_DROPDOWN | WS_BORDER | WS_VSCROLL | WS_TABSTOP
    LTEXT "S&tyle :", -1, 5, 153, 45, 12
    RTEXT "0x", -1, 54, 153, 10, 12
    EDITTEXT edt6, 70, 151, 45, 14, ES_AUTOHSCROLL
    LISTBOX lst1, 5, 167, 110, 120, LBS_DISABLENOSCROLL | LBS_NOINTEGRALHEIGHT | LBS_HASSTRINGS | LBS_MULTIPLESEL | WS_VSCROLL | WS_HSCROLL | WS_TABSTOP
    LTEXT "&ExStyle :", -1, 120, 153, 50, 12
    RTEXT "0x", -1, 172, 153, 10, 12
    EDITTEXT edt7, 185, 151, 45, 14, ES_AUTOHSCROLL
    LISTBOX lst2, 120, 167, 110, 120, LBS_DISABLENOSCROLL | LBS_NOINTEGRALHEIGHT | LBS_HASSTRINGS | LBS_MULTIPLESEL | WS_VSCROLL | WS_HSCROLL | WS_TABSTOP
    DEFPUSHBUTTON "OK", IDOK, 170, 293, 60, 14
    PUSHBUTTON "Annuler", IDCANCEL, 170, 309, 60, 14
    PUSHBUTTON "&Les données...", psh1, 5, 293, 90, 14
    PUSHBUTTON "La liste des chaînes...", psh3, 5, 309, 90, 14
}

IDD_ADDCTRL DIALOG 0, 0, 235, 330
CAPTION "Ajouter un contrôle"
STYLE DS_MODALFRAME | WS_POPUPWINDOW | WS_CAPTION
FONT 9, "MS Shell Dlg"
{
    LTEXT "Predef. &Ctrl :", -1, 5, 7, 68, 12
    COMBOBOX cmb1, 75, 5, 120, 55, CBS_HASSTRINGS | CBS_AUTOHSCROLL | CBS_DROPDOWN | WS_BORDER | WS_VSCROLL | WS_TABSTOP
    CONTROL "", ctl1, "ToolbarWindow32", TBSTYLE_FLAT | TBSTYLE_WRAPABLE | TBSTYLE_TOOLTIPS | CCS_NODIVIDER | CCS_NORESIZE, 5, 22, 185, 30
    LTEXT "Légende :", -1, 5, 55, 75, 12
    COMBOBOX cmb2, 5, 65, 195, 300, CBS_HASSTRINGS | CBS_AUTOHSCROLL | CBS_DROPDOWN | WS_BORDER | WS_VSCROLL | WS_TABSTOP
    PUSHBUTTON "&OLE...", psh2, 205, 65, 25, 14
    LTEXT "&Gauche :", -1, 5, 85, 33, 11
    EDITTEXT edt1, 5, 99, 25, 14, ES_NUMBER | ES_RIGHT
    CONTROL "", scr1, "msctls_updown32", UDS_NOTHOUSANDS | UDS_ARROWKEYS | UDS_AUTOBUDDY | UDS_ALIGNRIGHT | UDS_SETBUDDYINT, 20, 99, 12, 20
    LTEXT "Haut :", -1, 40, 85, 33, 11
    EDITTEXT edt2, 40, 99, 25, 14, ES_NUMBER | ES_RIGHT
    CONTROL "", scr2, "msctls_updown32", UDS_NOTHOUSANDS | UDS_ARROWKEYS | UDS_AUTOBUDDY | UDS_ALIGNRIGHT | UDS_SETBUDDYINT, 55, 99, 12, 20
    LTEXT "&Largeur :", -1, 75, 85, 33, 11
    EDITTEXT edt3, 75, 99, 25, 14, ES_NUMBER | ES_RIGHT
    CONTROL "", scr3, "msctls_updown32", UDS_NOTHOUSANDS | UDS_ARROWKEYS | UDS_AUTOBUDDY | UDS_ALIGNRIGHT | UDS_SETBUDDYINT, 90, 99, 12, 20
    LTEXT "&Hauteur :", -1, 111, 85, 33, 11
    EDITTEXT edt4, 110, 99, 25, 14, ES_NUMBER | ES_RIGHT
    CONTROL "", scr4, "msctls_updown32", UDS_NOTHOUSANDS | UDS_ARROWKEYS | UDS_AUTOBUDDY | UDS_ALIGNRIGHT | UDS_SETBUDDYINT, 125, 99, 12, 20
    LTEXT "&ID :", -1, 150, 85, 70, 12
    COMBOBOX cmb3, 150, 99, 80, 300, CBS_HASSTRINGS | CBS_AUTOHSCROLL | CBS_DROPDOWN | WS_BORDER | WS_VSCROLL | WS_TABSTOP
    LTEXT "Nom de classe de fenêtre :", -1, 5, 119, 100, 12
    COMBOBOX cmb4, 5, 133, 115, 200, CBS_HASSTRINGS | CBS_AUTOHSCROLL | CBS_DROPDOWN | WS_BORDER | WS_VSCROLL | WS_TABSTOP
    LTEXT "ID d'aide :", -1, 125, 119, 70, 12
    COMBOBOX cmb5, 125, 133, 65, 200, CBS_HASSTRINGS | CBS_AUTOHSCROLL | CBS_DROPDOWN | WS_BORDER | WS_VSCROLL | WS_TABSTOP
    LTEXT "S&tyle :", -1, 5, 153, 45, 12
    RTEXT "0x", -1, 54, 153, 10, 12
    EDITTEXT edt6, 70, 151, 45, 14, ES_AUTOHSCROLL
    LISTBOX lst1, 5, 167, 110, 120, LBS_DISABLENOSCROLL | LBS_NOINTEGRALHEIGHT | LBS_HASSTRINGS | LBS_MULTIPLESEL | WS_VSCROLL | WS_HSCROLL | WS_TABSTOP
    LTEXT "&ExStyle :", -1, 120, 153, 50, 12
    RTEXT "0x", -1, 172, 153, 10, 12
    EDITTEXT edt7, 185, 151, 45, 14, ES_AUTOHSCROLL
    LISTBOX lst2, 120, 167, 110, 120, LBS_DISABLENOSCROLL | LBS_NOINTEGRALHEIGHT | LBS_HASSTRINGS | LBS_MULTIPLESEL | WS_VSCROLL | WS_HSCROLL | WS_TABSTOP
    DEFPUSHBUTTON "OK", IDOK, 170, 293, 60, 14
    PUSHBUTTON "Annuler", IDCANCEL, 170, 309, 60, 14
    PUSHBUTTON "&Les données...", psh1, 5, 293, 90, 14
    PUSHBUTTON "La liste des chaînes...", psh3, 5, 309, 90, 14
}

IDD_IDASSOC DIALOG 0, 0, 200, 220
CAPTION "Association ID"
STYLE DS_MODALFRAME | WS_POPUPWINDOW | WS_CAPTION
FONT 9, "MS Shell Dlg"
{
    LTEXT "Association ID :", -1, 5, 5, 116, 12
    CONTROL "", lst1, "SysListView32", LVS_SHOWSELALWAYS | LVS_SINGLESEL | LVS_REPORT | WS_BORDER | WS_TABSTOP, 5, 20, 190, 150
    PUSHBUTTON "&Effacer tout", psh2, 5, 175, 85, 14
    PUSHBUTTON "&Modifier", psh1, 135, 175, 60, 14
    DEFPUSHBUTTON "OK", IDOK, 70, 200, 60, 14
    PUSHBUTTON "Annuler", IDCANCEL, 135, 200, 60, 14
}

IDD_MODIFYASSOC DIALOG 0, 0, 165, 68
CAPTION "Modifier l'association d'ID"
STYLE DS_MODALFRAME | WS_POPUPWINDOW | WS_CAPTION
FONT 9, "MS Shell Dlg"
{
    RTEXT "&Type d'identifiant :", -1, 5, 7, 65, 12
    EDITTEXT edt1, 80, 5, 80, 14, WS_DISABLED
    RTEXT "&Préfixe de l'ID :", -1, 5, 32, 65, 12
    EDITTEXT edt2, 80, 28, 80, 14, ES_AUTOHSCROLL
    DEFPUSHBUTTON "OK", IDOK, 35, 50, 60, 14
    PUSHBUTTON "Annuler", IDCANCEL, 100, 50, 60, 14
}

IDD_IDLIST DIALOG 0, 0, 200, 300
CAPTION "Liste des ID de ressource"
STYLE WS_OVERLAPPEDWINDOW
EXSTYLE WS_EX_TOOLWINDOW
FONT 9, "MS Shell Dlg"
{
    COMBOBOX cmb1, 0, 0, 200, 300, CBS_HASSTRINGS | CBS_SORT | CBS_OWNERDRAWFIXED | CBS_DROPDOWNLIST | WS_VSCROLL | WS_TABSTOP
    CONTROL "", lst1, "SysListView32", LVS_REPORT | WS_BORDER | WS_VSCROLL | WS_HSCROLL | WS_TABSTOP, 0, 15, 200, 285
}

IDD_CONFIG DIALOG 0, 0, 210, 285
CAPTION "Configuration"
STYLE DS_MODALFRAME | WS_POPUPWINDOW | WS_CAPTION
FONT 9, "MS Shell Dlg"
{
    AUTOCHECKBOX "Afficher le chemin d'accès complet au fichier dans la barre de titre", chx1, 5, 2, 200, 18, BS_MULTILINE | NOT WS_TABSTOP
    AUTOCHECKBOX "N'utilisez pas de macros d'identification", chx2, 5, 25, 200, 14
    AUTOCHECKBOX "Reprendre la position précédente de la fenêtre", chx3, 5, 45, 200, 14
    AUTOCHECKBOX "Charger automatiquement ""resource.h"" à proximité", chx4, 5, 65, 200, 14
    AUTOCHECKBOX "Afficher automatiquement la liste des ID de ressource", chx5, 5, 85, 200, 14
    AUTOCHECKBOX "Afficher les points sur la boîte de dialogue Modifier", chx6, 5, 105, 200, 14
    RTEXT "Hauteur de ComboBox :", -1, 10, 127, 75, 12
    EDITTEXT edt1, 90, 125, 34, 14, ES_NUMBER | ES_RIGHT
    CONTROL "", scr1, "msctls_updown32", UDS_NOTHOUSANDS | UDS_ARROWKEYS | UDS_AUTOBUDDY | UDS_ALIGNRIGHT | UDS_SETBUDDYINT, 129, 49, 12, 20
    AUTOCHECKBOX "&Habillage de mots", chx9, 130, 124, 75, 15
    AUTOCHECKBOX "Demandez la mise à jour de ""&resource.h""", chx7, 5, 145, 200, 14
    AUTOCHECKBOX "Compressez EXE par UPX en l'enregistrant", chx8, 5, 165, 200, 14
    PUSHBUTTON "&Les polices...", psh4, 5, 185, 200, 14
    PUSHBUTTON "&Macros prédéfinies...", psh1, 5, 205, 93, 14
    PUSHBUTTON "Définir les chemins...", psh2, 107, 205, 98, 14
    RTEXT "Nom des contrôles OLE :", -1, 5, 227, 80, 12
    COMBOBOX cmb1, 90, 225, 75, 300, CBS_HASSTRINGS | CBS_AUTOHSCROLL | CBS_DROPDOWN | WS_VSCROLL | WS_TABSTOP
    AUTOCHECKBOX "Créer une sauvegarde", chx10, 5, 245, 80, 15
    RTEXT "Suffixe de sauvegarde :", -1, 90, 242, 60, 18
    COMBOBOX cmb2, 158, 244, 45, 300, CBS_HASSTRINGS | CBS_AUTOHSCROLL | CBS_DROPDOWN | WS_VSCROLL | WS_TABSTOP
    DEFPUSHBUTTON "OK", IDOK, 100, 265, 50, 14
    PUSHBUTTON "Annuler", IDCANCEL, 155, 265, 50, 14
    PUSHBUTTON "Effacer tout", psh3, 5, 265, 75, 14
}

IDD_ADDRESID DIALOG 0, 0, 165, 90
CAPTION "Ajouter un ID de ressource"
STYLE DS_MODALFRAME | WS_POPUPWINDOW | WS_CAPTION
FONT 9, "MS Shell Dlg"
{
    RTEXT "&Type d'identifiant :", -1, 10, 2, 50, 18
    COMBOBOX cmb1, 65, 5, 95, 300, CBS_AUTOHSCROLL | CBS_DROPDOWNLIST | WS_VSCROLL | WS_TABSTOP
    RTEXT "&Nom de l'ID :", -1, 10, 27, 50, 14
    EDITTEXT edt1, 65, 25, 75, 14, ES_AUTOHSCROLL
    RTEXT "&Valeur entière :", -1, 10, 47, 50, 14
    EDITTEXT edt2, 65, 45, 48, 14, ES_AUTOHSCROLL
    CONTROL "", scr1, "msctls_updown32", UDS_NOTHOUSANDS | UDS_ARROWKEYS | UDS_AUTOBUDDY | UDS_ALIGNRIGHT | UDS_SETBUDDYINT, 129, 49, 12, 20
    PUSHBUTTON "&Auto", psh1, 115, 45, 45, 14
    DEFPUSHBUTTON "OK", IDOK, 20, 70, 60, 14
    PUSHBUTTON "Annuler", IDCANCEL, 85, 70, 60, 14
}

IDD_MODIFYRESID DIALOG 0, 0, 165, 90
CAPTION "Modifier l'ID de ressource"
STYLE DS_MODALFRAME | WS_POPUPWINDOW | WS_CAPTION
FONT 9, "MS Shell Dlg"
{
    RTEXT "&Nom de l'ID :", -1, 10, 12, 50, 14, SS_REALSIZEIMAGE | NOT WS_GROUP
    EDITTEXT edt1, 65, 10, 95, 14, ES_AUTOHSCROLL
    RTEXT "&Type d'identifiant :", -1, 10, 27, 50, 18
    EDITTEXT edt2, 65, 30, 95, 14, ES_READONLY
    RTEXT "&Valeur entière :", -1, 10, 52, 50, 14
    EDITTEXT edt3, 65, 50, 48, 14, ES_AUTOHSCROLL
    CONTROL "", scr1, "msctls_updown32", UDS_NOTHOUSANDS | UDS_ARROWKEYS | UDS_AUTOBUDDY | UDS_ALIGNRIGHT | UDS_SETBUDDYINT, 129, 49, 12, 20
    DEFPUSHBUTTON "OK", IDOK, 20, 70, 60, 14
    PUSHBUTTON "Annuler", IDCANCEL, 85, 70, 60, 14
}

IDD_ADVICERESH DIALOG 0, 0, 209, 184
CAPTION "Avis de modification du fichier ""resource.h"""
STYLE DS_MODALFRAME | WS_POPUPWINDOW | WS_CAPTION
FONT 9, "MS Shell Dlg"
{
    LTEXT "Veuillez modifier le fichier ""resource.h"" comme suit :", -1, 10, 10, 195, 20
    EDITTEXT edt1, 10, 30, 190, 130, ES_READONLY | ES_MULTILINE
    DEFPUSHBUTTON "OK", IDOK, 140, 165, 60, 14
    PUSHBUTTON "&Modification claire", psh1, 10, 165, 90, 14
}

IDD_CLONEINNEWNAME DIALOG 0, 0, 215, 75
CAPTION "Cloner sous un nouveau nom"
STYLE DS_MODALFRAME | WS_POPUPWINDOW | WS_CAPTION
FONT 9, "MS Shell Dlg"
{
    LTEXT "&Type de ressource :", -1, 5, 7, 70, 12
    COMBOBOX cmb1, 75, 5, 135, 200, CBS_HASSTRINGS | CBS_AUTOHSCROLL | CBS_DROPDOWN | WS_DISABLED | WS_BORDER | WS_VSCROLL | WS_TABSTOP
    LTEXT "&Nom de la ressource :", -1, 5, 32, 70, 12
    COMBOBOX cmb2, 75, 30, 120, 200, CBS_HASSTRINGS | CBS_AUTOHSCROLL | CBS_DROPDOWN | WS_BORDER | WS_VSCROLL | WS_TABSTOP
    PUSHBUTTON "&...", psh1, 195, 30, 15, 14
    DEFPUSHBUTTON "OK", IDOK, 35, 55, 60, 14
    PUSHBUTTON "Annuler", IDCANCEL, 115, 55, 60, 14
}

IDD_CLONEINNEWLANG DIALOG 0, 0, 215, 105
CAPTION "Cloner dans une nouvelle langue"
STYLE DS_MODALFRAME | WS_POPUPWINDOW | WS_CAPTION
FONT 9, "MS Shell Dlg"
{
    LTEXT "&Type de ressource :", -1, 5, 7, 100, 12
    COMBOBOX cmb1, 75, 5, 135, 200, CBS_HASSTRINGS | CBS_AUTOHSCROLL | CBS_DROPDOWN | WS_DISABLED | WS_BORDER | WS_VSCROLL | WS_TABSTOP
    LTEXT "&Nom de la ressource :", -1, 5, 32, 70, 12
    COMBOBOX cmb2, 75, 30, 120, 200, CBS_HASSTRINGS | CBS_AUTOHSCROLL | CBS_DROPDOWN | WS_DISABLED | WS_BORDER | WS_VSCROLL | WS_TABSTOP
    LTEXT "&Langue de la ressource :", -1, 5, 52, 70, 18
    COMBOBOX cmb3, 75, 55, 135, 200, CBS_HASSTRINGS | CBS_AUTOHSCROLL | CBS_DROPDOWN | WS_BORDER | WS_VSCROLL | WS_TABSTOP
    DEFPUSHBUTTON "OK", IDOK, 35, 85, 60, 14
    PUSHBUTTON "Annuler", IDCANCEL, 115, 85, 60, 14
}

IDD_ITEMSEARCH DIALOG 0, 0, 171, 135
CAPTION "Chercher"
STYLE WS_POPUPWINDOW | WS_CAPTION
FONT 9, "MS Shell Dlg"
{
    LTEXT "&Chaîne à rechercher :", -1, 4, 10, 75, 14
    EDITTEXT edt1, 5, 25, 160, 15, ES_AUTOHSCROLL
    AUTOCHECKBOX "&Sensible aux majuscules et minuscules", chx1, 5, 45, 120, 18
    GROUPBOX "Direction", -1, 5, 65, 160, 42
    AUTORADIOBUTTON "&Ascendant", rad1, 15, 80, 60, 14, WS_TABSTOP
    AUTORADIOBUTTON "&Vers le bas", rad2, 90, 80, 60, 14, WS_TABSTOP
    DEFPUSHBUTTON "&Trouver", IDOK, 40, 115, 60, 14
    PUSHBUTTON "Annuler", IDCANCEL, 105, 115, 60, 14
}

IDD_VERSIONINFO DIALOG 0, 0, 174, 150
CAPTION "À propos de RisohEditor"
STYLE DS_MODALFRAME | WS_POPUPWINDOW | WS_CAPTION
FONT 12, "MS Shell Dlg"
{
    ICON IDI_MAIN, -1, 5, 5, 0, 0
    LTEXT "...", stc1, 30, 5, 140, 50
    CTEXT "https://katahiromz.web.fc2.com", stc2, 5, 60, 165, 12, SS_CENTERIMAGE | SS_NOTIFY | NOT WS_GROUP
    CONTROL "...", edt1, "EDIT", ES_READONLY | ES_AUTOHSCROLL | ES_AUTOVSCROLL | ES_MULTILINE | WS_BORDER | WS_VSCROLL | WS_HSCROLL, 5, 75, 165, 50
    DEFPUSHBUTTON "OK", IDOK, 55, 130, 60, 14
}

IDD_ADDMSG DIALOG 0, 0, 255, 105
CAPTION "Ajouter une entrée de message"
STYLE DS_MODALFRAME | WS_POPUPWINDOW | WS_CAPTION
FONT 9, "MS Shell Dlg"
{
    LTEXT "ID du message :", -1, 5, 7, 50, 12
    COMBOBOX cmb1, 65, 5, 134, 200, CBS_HASSTRINGS | CBS_AUTOHSCROLL | CBS_DROPDOWN | WS_BORDER | WS_VSCROLL | WS_TABSTOP
    PUSHBUTTON "&...", psh1, 200, 5, 15, 14
    LTEXT "Valeur du message :", -1, 5, 27, 80, 12
    EDITTEXT edt1, 5, 40, 245, 35, ES_WANTRETURN | ES_AUTOHSCROLL | ES_AUTOVSCROLL | ES_MULTILINE
    DEFPUSHBUTTON "OK", IDOK, 125, 85, 60, 14
    PUSHBUTTON "Annuler", IDCANCEL, 190, 85, 60, 14
}

IDD_MODIFYMSG DIALOG 0, 0, 255, 105
CAPTION "Modifier l'entrée de message"
STYLE DS_MODALFRAME | WS_POPUPWINDOW | WS_CAPTION
FONT 9, "MS Shell Dlg"
{
    LTEXT "ID du message :", -1, 5, 7, 50, 12
    COMBOBOX cmb1, 65, 5, 134, 200, CBS_HASSTRINGS | CBS_AUTOHSCROLL | CBS_DROPDOWN | WS_DISABLED | WS_BORDER | WS_VSCROLL | WS_TABSTOP
    LTEXT "Valeur du message :", -1, 5, 27, 80, 12
    EDITTEXT edt1, 5, 40, 245, 35, ES_WANTRETURN | ES_AUTOHSCROLL | ES_AUTOVSCROLL | ES_MULTILINE
    DEFPUSHBUTTON "OK", IDOK, 125, 85, 60, 14
    PUSHBUTTON "Annuler", IDCANCEL, 190, 85, 60, 14
}

IDD_MESSAGES DIALOG 0, 0, 325, 160
CAPTION "Tableau des messages"
STYLE WS_POPUPWINDOW | WS_CAPTION | WS_THICKFRAME
FONT 9, "MS Shell Dlg"
{
    LTEXT "Entrées de message :", -1, 5, 7, 80, 12
    CONTROL "", lst1, "SysListView32", LVS_NOSORTHEADER | LVS_AUTOARRANGE | LVS_NOLABELWRAP | LVS_SHOWSELALWAYS | LVS_SINGLESEL | LVS_REPORT | WS_BORDER | WS_VSCROLL | WS_HSCROLL | WS_TABSTOP, 5, 20, 315, 115
    PUSHBUTTON "&Ajouter...", psh1, 130, 3, 60, 14
    PUSHBUTTON "&Modifier...", psh2, 195, 3, 60, 14
    PUSHBUTTON "&Supprimer", psh3, 260, 3, 60, 14
    DEFPUSHBUTTON "OK", IDOK, 195, 140, 60, 14
    PUSHBUTTON "Annuler", IDCANCEL, 260, 140, 60, 14
    PUSHBUTTON "Supprimer tout", psh4, 5, 140, 75, 14
}

IDD_FONTS DIALOG 0, 0, 195, 110
CAPTION "Paramètres de police"
STYLE DS_MODALFRAME | WS_POPUPWINDOW | WS_CAPTION
FONT 9, "MS Shell Dlg"
{
    RTEXT "&La source :", -1, 5, 5, 55, 15, SS_CENTERIMAGE | NOT WS_GROUP
    EDITTEXT edt1, 65, 5, 100, 14, ES_READONLY | ES_AUTOHSCROLL
    PUSHBUTTON "...", psh1, 170, 5, 19, 14
    RTEXT "&Binaire :", -1, 5, 25, 55, 15, SS_CENTERIMAGE | NOT WS_GROUP
    EDITTEXT edt2, 65, 25, 100, 14, ES_READONLY | ES_AUTOHSCROLL
    PUSHBUTTON "...", psh2, 170, 25, 19, 14
    GROUPBOX "Preview", -1, 5, 45, 185, 39
    CTEXT "La source", stc1, 15, 55, 80, 25, SS_CENTERIMAGE | NOT WS_GROUP
    CTEXT "Binaire", stc2, 100, 55, 85, 25, SS_CENTERIMAGE | NOT WS_GROUP
    DEFPUSHBUTTON "OK", IDOK, 65, 90, 60, 14
    PUSHBUTTON "Annuler", IDCANCEL, 130, 90, 60, 14
}

IDD_MACROS DIALOG 0, 0, 265, 165
CAPTION "Macros prédéfinies"
STYLE WS_POPUPWINDOW | WS_CAPTION | WS_THICKFRAME
FONT 9, "MS Shell Dlg"
{
    LTEXT "Macros prédéfinies :", -1, 5, 0, 100, 15, SS_CENTERIMAGE | NOT WS_GROUP
    CONTROL "", lst1, "SysListView32", LVS_EDITLABELS | LVS_SHOWSELALWAYS | LVS_SINGLESEL | LVS_REPORT | WS_BORDER | WS_TABSTOP, 5, 15, 190, 125
    PUSHBUTTON "&Ajouter...", psh1, 200, 15, 60, 14
    PUSHBUTTON "&Éditer...", psh2, 200, 35, 60, 14
    PUSHBUTTON "&Supprimer", psh3, 200, 55, 60, 14
    PUSHBUTTON "Supprimer tout", psh7, 200, 105, 60, 14
    DEFPUSHBUTTON "OK", IDOK, 135, 145, 60, 14
    PUSHBUTTON "Annuler", IDCANCEL, 200, 145, 60, 14
    PUSHBUTTON "&Effacer tout", psh6, 5, 145, 60, 14
}

IDD_ADDMACRO DIALOG 0, 0, 190, 80
CAPTION "Ajouter une macro prédéfinie"
STYLE DS_MODALFRAME | WS_POPUPWINDOW | WS_CAPTION
FONT 9, "MS Shell Dlg"
{
    RTEXT "&Clé :", -1, 5, 12, 60, 14
    COMBOBOX cmb1, 70, 10, 110, 200, CBS_DROPDOWN | WS_BORDER | WS_VSCROLL | WS_TABSTOP
    RTEXT "&Valeur :", -1, 5, 37, 60, 14
    COMBOBOX cmb2, 70, 35, 110, 300, CBS_DROPDOWN | WS_BORDER | WS_VSCROLL | WS_TABSTOP
    DEFPUSHBUTTON "OK", IDOK, 60, 60, 60, 14
    PUSHBUTTON "Annuler", IDCANCEL, 125, 60, 60, 14
}

IDD_EDITMACRO DIALOG 0, 0, 190, 80
CAPTION "Modifier une macro prédéfinie"
STYLE DS_MODALFRAME | WS_POPUPWINDOW | WS_CAPTION
FONT 9, "MS Shell Dlg"
{
    RTEXT "&Clé :", -1, 5, 12, 60, 14
    COMBOBOX cmb1, 70, 10, 110, 200, CBS_DROPDOWN | WS_DISABLED | WS_BORDER | WS_VSCROLL | WS_TABSTOP
    RTEXT "&Valeur :", -1, 5, 37, 60, 14
    COMBOBOX cmb2, 70, 35, 110, 300, CBS_DROPDOWN | WS_BORDER | WS_VSCROLL | WS_TABSTOP
    DEFPUSHBUTTON "OK", IDOK, 60, 60, 60, 14
    PUSHBUTTON "Annuler", IDCANCEL, 125, 60, 60, 14
}

IDD_CTRLDATA DIALOG 0, 0, 190, 130
CAPTION "Modifier les données de contrôle"
STYLE DS_MODALFRAME | WS_POPUPWINDOW | WS_CAPTION
FONT 9, "MS Shell Dlg"
{
    LTEXT "&Données binaires :", -1, 5, 2, 87, 12
    EDITTEXT edt1, 5, 15, 180, 60, ES_AUTOVSCROLL | ES_MULTILINE | WS_VSCROLL
    LTEXT "Vous pouvez définir les données de contrôle par des entiers 16 bits séparés par des espaces.", -1, 5, 80, 180, 25
    DEFPUSHBUTTON "OK", IDOK, 60, 110, 60, 14
    PUSHBUTTON "Annuler", IDCANCEL, 125, 110, 60, 14
}

IDD_PATHS DIALOG 0, 0, 295, 220
CAPTION "Définir les chemins"
STYLE WS_POPUPWINDOW | WS_CAPTION | WS_THICKFRAME
FONT 9, "MS Shell Dlg"
{
    LTEXT "&Inclure les répertoires :", -1, 5, 5, 102, 12
    LISTBOX lst1, 5, 20, 220, 105, LBS_NOINTEGRALHEIGHT | LBS_HASSTRINGS | LBS_SORT | WS_VSCROLL | WS_HSCROLL | WS_TABSTOP
    PUSHBUTTON "&Ajouter...", psh1, 230, 20, 60, 14
    PUSHBUTTON "&Éditer...", psh2, 230, 40, 60, 14
    PUSHBUTTON "&Supprimer", psh3, 230, 60, 60, 14
    PUSHBUTTON "&En haut", psh4, 230, 80, 60, 14
    PUSHBUTTON "Vers le bas", psh5, 230, 100, 60, 14
    PUSHBUTTON "Supprimer tout", psh6, 5, 130, 95, 14
    RTEXT "&windres.exe :", stc1, 5, 157, 55, 12
    COMBOBOX cmb1, 70, 155, 155, 300, CBS_HASSTRINGS | CBS_AUTOHSCROLL | CBS_DROPDOWN | WS_VSCROLL | WS_TABSTOP
    PUSHBUTTON "&Feuilleter...", psh7, 230, 155, 60, 14
    RTEXT "&cpp.exe :", stc2, 5, 177, 55, 12
    COMBOBOX cmb2, 70, 175, 155, 300, CBS_HASSTRINGS | CBS_AUTOHSCROLL | CBS_DROPDOWN | WS_VSCROLL | WS_TABSTOP
    PUSHBUTTON "Feuilleter...", psh8, 230, 175, 60, 14
    DEFPUSHBUTTON "OK", IDOK, 165, 200, 60, 14
    PUSHBUTTON "Annuler", IDCANCEL, 230, 200, 60, 14
    PUSHBUTTON "Effacer tout", psh9, 5, 200, 95, 14
}

IDD_EXP_OPTIONS DIALOG 0, 0, 250, 225
CAPTION "Options d'exportation"
STYLE DS_MODALFRAME | WS_POPUPWINDOW | WS_CAPTION
FONT 9, "MS Shell Dlg"
{
    ICON IDI_MAIN, -1, 5, 10, 0, 0
    LTEXT "L'exportation d'un fichier RC générera certains fichiers associés. Vous pouvez choisir les options suivantes :", -1, 35, 5, 210, 29
    AUTOCHECKBOX "Use Microsoft MESSAGE&TABLE", chx8, 5, 40, 240, 14
    AUTOCHECKBOX "Fichiers de ressources séparés par langue", chx1, 5, 60, 240, 14
    AUTOCHECKBOX "Utilisez les mots clés BEGIN / END", chx2, 5, 80, 240, 14
    AUTOCHECKBOX "Rendre la langue sélectionnable par la macro LANGUAGE_*", chx3, 5, 97, 240, 18, BS_MULTILINE | NOT WS_TABSTOP
    AUTOCHECKBOX "Créer une sauvegarde", chx4, 5, 120, 110, 14
    RTEXT "Suffixe de sauvegarde :", -1, 120, 122, 75, 12
    COMBOBOX cmb1, 200, 120, 45, 300, CBS_HASSTRINGS | CBS_AUTOHSCROLL | CBS_DROPDOWN | WS_VSCROLL | WS_TABSTOP
    AUTOCHECKBOX "Sortie de commentaires redondants", chx5, 5, 140, 240, 14
    AUTOCHECKBOX "Enveloppez les instructions manifestes par #ifndef MSVC ... #endif", chx6, 5, 157, 240, 18, BS_MULTILINE | NOT WS_TABSTOP
    AUTOCHECKBOX "Sortie des fichiers RC en UTF-16", chx7, 5, 180, 240, 14
    DEFPUSHBUTTON "OK", IDOK, 120, 205, 60, 14
    PUSHBUTTON "Annuler", IDCANCEL, 185, 205, 60, 14
}

IDD_LANGS DIALOG 0, 0, 250, 235
CAPTION "Langages"
STYLE WS_POPUPWINDOW | WS_CAPTION | WS_THICKFRAME
FONT 9, "MS Shell Dlg"
{
    CONTROL "", lst1, "SysListView32", LVS_SHOWSELALWAYS | LVS_SINGLESEL | LVS_REPORT | WS_BORDER | WS_TABSTOP, 5, 5, 240, 179
    RTEXT "&Chercher :", stc1, 5, 192, 45, 12
    COMBOBOX cmb1, 55, 190, 85, 300, CBS_SORT | CBS_DROPDOWN | WS_VSCROLL | WS_TABSTOP
    EDITTEXT edt1, 4, 209, 240, 20, ES_AUTOHSCROLL | ES_AUTOVSCROLL | ES_MULTILINE
}

IDD_CHILD DIALOG 0, 0, 215, 135
CAPTION "Boîte de dialogue enfant"
STYLE WS_CHILD | WS_OVERLAPPEDWINDOW
FONT 9, "MS Shell Dlg"
{
    DEFPUSHBUTTON "OK", IDOK, 35, 115, 60, 14
    PUSHBUTTON "Annuler", IDCANCEL, 115, 115, 60, 14
}

IDD_DLGINITEDIT DIALOG 0, 0, 325, 165
CAPTION "Modifier DLGINIT"
STYLE WS_POPUPWINDOW | WS_CAPTION | WS_THICKFRAME
FONT 9, "MS Shell Dlg"
{
    LTEXT "Entrées de message :", -1, 5, 7, 100, 12
    CONTROL "", lst1, "SysListView32", LVS_NOSORTHEADER | LVS_AUTOARRANGE | LVS_NOLABELWRAP | LVS_SHOWSELALWAYS | LVS_SINGLESEL | LVS_REPORT | WS_BORDER | WS_VSCROLL | WS_HSCROLL | WS_TABSTOP, 5, 20, 250, 120
    PUSHBUTTON "&Ajouter...", psh1, 260, 20, 60, 14
    PUSHBUTTON "&Modifier...", psh2, 260, 40, 60, 14
    PUSHBUTTON "&Supprimer", psh3, 260, 60, 60, 14
    PUSHBUTTON "&En haut", psh4, 260, 100, 60, 14
    PUSHBUTTON "&Vers le bas", psh5, 260, 120, 60, 14
    DEFPUSHBUTTON "OK", IDOK, 195, 145, 60, 14
    PUSHBUTTON "Annuler", IDCANCEL, 260, 145, 60, 14
    PUSHBUTTON "Supprimer tout", psh6, 5, 145, 79, 14
}

IDD_ADDDLGINIT DIALOG 0, 0, 184, 137
CAPTION "Ajouter des données DLGINIT"
STYLE DS_MODALFRAME | WS_POPUPWINDOW | WS_CAPTION
FONT 9, "MS Shell Dlg"
{
    LTEXT "ID de contrôle :", -1, 5, 7, 56, 12
    COMBOBOX cmb1, 65, 5, 115, 300, CBS_HASSTRINGS | CBS_AUTOHSCROLL | CBS_DROPDOWN | WS_VSCROLL | WS_TABSTOP
    LTEXT "&Message :", -1, 5, 32, 55, 12
    COMBOBOX cmb2, 65, 30, 95, 300, CBS_HASSTRINGS | CBS_AUTOHSCROLL | CBS_DROPDOWN | WS_VSCROLL | WS_TABSTOP
    LTEXT "&Chaîne", -1, 5, 52, 55, 12
    EDITTEXT edt1, 5, 65, 175, 50, ES_WANTRETURN | ES_MULTILINE | WS_VSCROLL | WS_HSCROLL
    DEFPUSHBUTTON "OK", IDOK, 55, 120, 60, 14
    PUSHBUTTON "Annuler", IDCANCEL, 120, 120, 60, 14
}

IDD_MODIFYDLGINIT DIALOG 0, 0, 184, 137
CAPTION "Modifier les données DLGINIT"
STYLE DS_MODALFRAME | WS_POPUPWINDOW | WS_CAPTION
FONT 9, "MS Shell Dlg"
{
    LTEXT "ID de contrôle :", -1, 5, 7, 56, 12
    COMBOBOX cmb1, 65, 5, 115, 300, CBS_HASSTRINGS | CBS_AUTOHSCROLL | CBS_DROPDOWN | WS_VSCROLL | WS_TABSTOP
    LTEXT "&Message :", -1, 5, 32, 55, 12
    COMBOBOX cmb2, 65, 30, 95, 300, CBS_HASSTRINGS | CBS_AUTOHSCROLL | CBS_DROPDOWN | WS_VSCROLL | WS_TABSTOP
    LTEXT "&Chaîne", -1, 5, 52, 55, 12
    EDITTEXT edt1, 5, 65, 175, 50, ES_WANTRETURN | ES_MULTILINE | WS_VSCROLL | WS_HSCROLL
    DEFPUSHBUTTON "OK", IDOK, 55, 120, 60, 14
    PUSHBUTTON "Annuler", IDCANCEL, 120, 120, 60, 14
}

IDD_STRINGLIST DIALOG 0, 0, 205, 220
CAPTION "Liste des chaînes de contrôle"
STYLE WS_POPUPWINDOW | WS_CAPTION | WS_THICKFRAME
FONT 9, "MS Shell Dlg"
{
    LTEXT "", stc1, 5, 5, 195, 70
    EDITTEXT edt1, 5, 80, 195, 115, ES_WANTRETURN | ES_MULTILINE | WS_VSCROLL | WS_HSCROLL
    DEFPUSHBUTTON "OK", IDOK, 75, 200, 60, 14
    PUSHBUTTON "Annuler", IDCANCEL, 140, 200, 60, 14
}

IDD_SAVE_OPTIONS DIALOG 0, 0, 250, 225
CAPTION "Options d'enregistrement"
STYLE DS_MODALFRAME | WS_POPUPWINDOW | WS_CAPTION
FONT 9, "MS Shell Dlg"
{
    ICON IDI_MAIN, -1, 5, 10, 0, 0
    LTEXT "L'enregistrement d'un fichier RC générera des fichiers associés. Vous pouvez choisir les options suivantes :", -1, 35, 5, 210, 29
    AUTOCHECKBOX "Use Microsoft MESSAGE&TABLE", chx8, 5, 40, 240, 14
    AUTOCHECKBOX "Fichiers de ressources séparés par langue", chx1, 5, 60, 240, 14
    AUTOCHECKBOX "Utilisez les mots clés BEGIN / END", chx2, 5, 80, 240, 14
    AUTOCHECKBOX "Rendre la langue sélectionnable par la macro LANGUAGE_*", chx3, 5, 97, 240, 18, BS_MULTILINE | NOT WS_TABSTOP
    AUTOCHECKBOX "Créer une sauvegarde", chx4, 5, 120, 110, 14
    RTEXT "Suffixe de sauvegarde :", -1, 120, 122, 75, 12
    COMBOBOX cmb1, 200, 120, 45, 300, CBS_HASSTRINGS | CBS_AUTOHSCROLL | CBS_DROPDOWN | WS_VSCROLL | WS_TABSTOP
    AUTOCHECKBOX "Sortie de commentaires redondants", chx5, 5, 140, 240, 14
    AUTOCHECKBOX "Enveloppez les instructions manifestes par #ifndef MSVC ... #endif", chx6, 5, 157, 240, 18, BS_MULTILINE | NOT WS_TABSTOP
    AUTOCHECKBOX "Sortie des fichiers RC en UTF-16", chx7, 5, 180, 240, 14
    DEFPUSHBUTTON "OK", IDOK, 120, 205, 60, 14
    PUSHBUTTON "Annuler", IDCANCEL, 185, 205, 60, 14
}

IDD_ENCODING DIALOG 0, 0, 200, 170
CAPTION "Encodage de l'élément de ressource"
STYLE DS_MODALFRAME | WS_POPUPWINDOW | WS_CAPTION
FONT 9, "MS Shell Dlg"
{
    CONTROL "", lst1, "SysListView32", LVS_SHOWSELALWAYS | LVS_SINGLESEL | LVS_REPORT | WS_BORDER, 5, 5, 190, 115
    PUSHBUTTON "&Ajouter...", psh1, 5, 125, 60, 14
    PUSHBUTTON "&Modifier...", psh2, 70, 125, 60, 14
    PUSHBUTTON "&Supprimer", psh3, 135, 125, 60, 14
    DEFPUSHBUTTON "OK", IDOK, 70, 150, 60, 14
    PUSHBUTTON "Annuler", IDCANCEL, 135, 150, 60, 14
    PUSHBUTTON "&Réinitialiser", psh5, 5, 149, 60, 14
}

IDD_ADDENC DIALOG 0, 0, 215, 80
CAPTION "Ajouter un codage de ressource"
STYLE DS_MODALFRAME | WS_POPUPWINDOW | WS_CAPTION
FONT 9, "MS Shell Dlg"
{
    LTEXT "&Type de ressource :", -1, 5, 7, 70, 12
    COMBOBOX cmb1, 75, 5, 135, 200, CBS_HASSTRINGS | CBS_AUTOHSCROLL | CBS_DROPDOWN | WS_BORDER | WS_VSCROLL | WS_TABSTOP
    LTEXT "&Codage :", -1, 5, 30, 70, 12
    COMBOBOX cmb2, 75, 30, 85, 300, CBS_HASSTRINGS | CBS_AUTOHSCROLL | CBS_DROPDOWNLIST | WS_VSCROLL | WS_TABSTOP
    DEFPUSHBUTTON "OK", IDOK, 86, 60, 60, 14
    PUSHBUTTON "Annuler", IDCANCEL, 150, 60, 60, 14
}

IDD_MODIFYENC DIALOG 0, 0, 215, 80
CAPTION "Modifier l'encodage des ressources"
STYLE DS_MODALFRAME | WS_POPUPWINDOW | WS_CAPTION
FONT 9, "MS Shell Dlg"
{
    LTEXT "&Type de ressource :", -1, 5, 7, 70, 12
    COMBOBOX cmb1, 75, 5, 135, 200, CBS_HASSTRINGS | CBS_AUTOHSCROLL | CBS_DROPDOWN | WS_DISABLED | WS_BORDER | WS_VSCROLL | WS_TABSTOP
    LTEXT "&Codage :", -1, 5, 30, 70, 12
    COMBOBOX cmb2, 75, 30, 85, 300, CBS_HASSTRINGS | CBS_AUTOHSCROLL | CBS_DROPDOWNLIST | WS_VSCROLL | WS_TABSTOP
    DEFPUSHBUTTON "OK", IDOK, 86, 60, 60, 14
    PUSHBUTTON "Annuler", IDCANCEL, 150, 60, 60, 14
}

IDD_CONSTANT DIALOG 0, 0, 205, 75
CAPTION "Constante de requête"
STYLE DS_MODALFRAME | WS_POPUPWINDOW | WS_CAPTION
FONT 9, "MS Shell Dlg"
{
    LTEXT "Nom constant :", -1, 5, 7, 80, 12
    COMBOBOX cmb1, 94, 7, 105, 300, CBS_HASSTRINGS | CBS_AUTOHSCROLL | CBS_DROPDOWN | WS_VSCROLL | WS_TABSTOP
    LTEXT "Valeur constante :", -1, 5, 32, 80, 12
    EDITTEXT edt2, 95, 30, 50, 14, ES_READONLY
    EDITTEXT edt3, 150, 30, 50, 14, ES_READONLY
    DEFPUSHBUTTON "OK", IDOK, 70, 55, 60, 14
}

IDD_EGA DIALOG 0, 0, 400, 225
CAPTION "Le langage de programmation EGA"
STYLE WS_POPUPWINDOW | WS_CAPTION | WS_THICKFRAME
FONT 9, "MS Shell Dlg"
{
    GROUPBOX "Console EGA", grp1, 5, 5, 390, 195
    EDITTEXT edt1, 10, 20, 380, 170, ES_READONLY | ES_AUTOVSCROLL | ES_MULTILINE | WS_VSCROLL | NOT WS_TABSTOP
    RTEXT "EGA>", stc1, 10, 208, 20, 10
    EDITTEXT edt2, 35, 205, 300, 15, ES_WANTRETURN | ES_AUTOHSCROLL | ES_AUTOVSCROLL | ES_MULTILINE
    PUSHBUTTON "&Entrer", IDOK, 345, 205, 50, 15
}

IDD_FONTSUBST DIALOG 0, 0, 185, 180
CAPTION "Dialog Font Substitutes"
STYLE DS_CENTER | DS_MODALFRAME | WS_POPUPWINDOW | WS_CAPTION
FONT 9, "MS Shell Dlg"
{
    LTEXT "Police #&1 :", -1, 5, 7, 44, 12
    COMBOBOX cmb1, 55, 5, 125, 300, CBS_HASSTRINGS | CBS_AUTOHSCROLL | CBS_DROPDOWN | WS_VSCROLL | WS_TABSTOP
    ICON IDI_ARROW, -1, 30, 25, 0, 0
    COMBOBOX cmb2, 55, 30, 125, 300, CBS_HASSTRINGS | CBS_AUTOHSCROLL | CBS_DROPDOWN | WS_VSCROLL | WS_TABSTOP
    LTEXT "Police #&2 :", -1, 5, 57, 44, 12
    COMBOBOX cmb3, 55, 55, 125, 300, CBS_HASSTRINGS | CBS_AUTOHSCROLL | CBS_DROPDOWN | WS_VSCROLL | WS_TABSTOP
    ICON IDI_ARROW, -1, 30, 75, 0, 0
    COMBOBOX cmb4, 55, 80, 125, 300, CBS_HASSTRINGS | CBS_AUTOHSCROLL | CBS_DROPDOWN | WS_VSCROLL | WS_TABSTOP
    LTEXT "Police #&3 :", -1, 5, 105, 44, 12
    COMBOBOX cmb5, 55, 105, 125, 300, CBS_HASSTRINGS | CBS_AUTOHSCROLL | CBS_DROPDOWN | WS_VSCROLL | WS_TABSTOP
    ICON IDI_ARROW, -1, 30, 125, 0, 0
    COMBOBOX cmb6, 55, 130, 125, 300, CBS_HASSTRINGS | CBS_AUTOHSCROLL | CBS_DROPDOWN | WS_VSCROLL | WS_TABSTOP
    DEFPUSHBUTTON "OK", IDOK, 75, 160, 50, 14
    PUSHBUTTON "Annuler", IDCANCEL, 130, 160, 50, 14
    PUSHBUTTON "&Réinitialiser", psh1, 5, 160, 55, 14
}

IDD_DROPDOWNPOPUP DIALOG 0, 0, 120, 150
CAPTION " "
STYLE WS_POPUP | WS_DLGFRAME | NOT WS_BORDER
FONT 9, "MS Shell Dlg"
{
    LISTBOX lst1, 0, 0, 120, 150, LBS_WANTKEYBOARDINPUT | LBS_NOINTEGRALHEIGHT | LBS_HASSTRINGS | WS_VSCROLL | WS_TABSTOP, WS_EX_CLIENTEDGE
}

IDD_DFMSETTINGS DIALOG 0, 0, 210, 135
CAPTION "Paramètres Delphi DFM"
STYLE DS_CENTER | DS_MODALFRAME | WS_POPUPWINDOW | WS_CAPTION
FONT 9, "MS Shell Dlg"
{
    LTEXT "Les paramètres suivants sont pertinents pour Delphi DFM :", -1, 35, 5, 171, 20
    ICON IDI_DFMICON, -1, 5, 5, 0, 0
    RTEXT "&Page de code :", -1, 6, 32, 70, 12
    COMBOBOX cmb1, 85, 30, 120, 300, CBS_HASSTRINGS | CBS_AUTOHSCROLL | CBS_DROPDOWN | WS_VSCROLL | WS_TABSTOP
    AUTOCHECKBOX "&Insérer des commentaires de chaîne brute", chx1, 5, 50, 200, 14
    AUTOCHECKBOX "N'utilisez pas &Unicode et UTF-8", chx2, 5, 70, 200, 14
    DEFPUSHBUTTON "OK", IDOK, 80, 115, 60, 14
    PUSHBUTTON "Annuler", IDCANCEL, 145, 115, 60, 14
}

IDD_COPYTOMULTILANG DIALOG 0, 0, 200, 195
CAPTION "Copier dans plusieurs langues"
STYLE DS_CENTER | DS_MODALFRAME | WS_POPUPWINDOW | WS_CAPTION
FONT 9, "MS Shell Dlg"
{
    LTEXT "Veuillez ajouter les langues dans lesquelles vous souhaitez copier la ressource :", -1, 5, 5, 190, 22
    LTEXT "&Languages :", -1, 5, 35, 82, 12
    LISTBOX lst1, 5, 50, 190, 100, LBS_WANTKEYBOARDINPUT | LBS_NOINTEGRALHEIGHT | LBS_HASSTRINGS | WS_VSCROLL | WS_TABSTOP
    COMBOBOX cmb3, 5, 155, 126, 14, CBS_HASSTRINGS | CBS_AUTOHSCROLL | CBS_DROPDOWN | WS_BORDER | WS_VSCROLL | WS_TABSTOP
    PUSHBUTTON "&Ajouter", psh1, 135, 155, 60, 14
    DEFPUSHBUTTON "OK", IDOK, 5, 175, 60, 14
    PUSHBUTTON "Annuler", IDCANCEL, 70, 175, 60, 14
}

IDD_TOOLBARRES DIALOG 0, 0, 230, 195
CAPTION "Ressource de la barre d'outils"
STYLE DS_CENTER | DS_MODALFRAME | WS_POPUPWINDOW | WS_CAPTION
FONT 9, "MS Shell Dlg"
{
    RTEXT "&Largeur de l'icône :", -1, 5, 5, 60, 15, SS_CENTERIMAGE | NOT WS_GROUP
    EDITTEXT edt1, 70, 5, 30, 15, ES_NUMBER | ES_RIGHT
    CONTROL "", scr1, "msctls_updown32", UDS_NOTHOUSANDS | UDS_ARROWKEYS | UDS_AUTOBUDDY | UDS_ALIGNRIGHT | UDS_SETBUDDYINT, 80, 5, 30, 15
    RTEXT "&Hauteur de l'icône :", -1, 110, 5, 60, 15, SS_CENTERIMAGE | NOT WS_GROUP
    EDITTEXT edt2, 180, 5, 30, 15, ES_NUMBER | ES_RIGHT
    CONTROL "", scr2, "msctls_updown32", UDS_NOTHOUSANDS | UDS_ARROWKEYS | UDS_AUTOBUDDY | UDS_ALIGNRIGHT | UDS_SETBUDDYINT, 190, 5, 30, 15
    LTEXT "&Boutons de la barre d'outils :", -1, 5, 25, 140, 15, SS_CENTERIMAGE | NOT WS_GROUP
    LISTBOX lst1, 5, 40, 140, 130, LBS_DISABLENOSCROLL | LBS_WANTKEYBOARDINPUT | LBS_NOINTEGRALHEIGHT | LBS_HASSTRINGS | LBS_OWNERDRAWFIXED | WS_VSCROLL | WS_TABSTOP
    PUSHBUTTON "&Ajouter...", psh1, 150, 40, 75, 15
    PUSHBUTTON "&Modifier...", psh2, 150, 60, 75, 15
    PUSHBUTTON "&Effacer", psh3, 150, 80, 75, 15
    PUSHBUTTON "&En haut", psh4, 150, 135, 75, 15
    PUSHBUTTON "&Vers le bas", psh5, 150, 155, 75, 15
    DEFPUSHBUTTON "OK", IDOK, 5, 175, 60, 15
    PUSHBUTTON "Annuler", IDCANCEL, 70, 175, 60, 15
}

IDD_ADDTBBTN DIALOG 0, 0, 177, 92
CAPTION "Bouton Ajouter une barre d'outils"
STYLE DS_CENTER | DS_MODALFRAME | WS_POPUPWINDOW | WS_CAPTION
FONT 9, "MS Shell Dlg"
{
    LTEXT "&ID de commande du bouton de la barre d'outils :", -1, 5, 5, 160, 15, SS_CENTERIMAGE | NOT WS_GROUP
    COMBOBOX cmb1, 5, 25, 150, 150, CBS_HASSTRINGS | CBS_AUTOHSCROLL | CBS_DROPDOWN | WS_VSCROLL | WS_TABSTOP
    AUTOCHECKBOX "&Séparateur", chx1, 5, 45, 90, 15
    DEFPUSHBUTTON "OK", IDOK, 45, 70, 60, 15
    PUSHBUTTON "Annuler", IDCANCEL, 110, 70, 60, 15
}

IDD_MODIFYTBBTN DIALOG 0, 0, 177, 92
CAPTION "Bouton Modifier la barre d'outils"
STYLE DS_CENTER | DS_MODALFRAME | WS_POPUPWINDOW | WS_CAPTION
FONT 9, "MS Shell Dlg"
{
    LTEXT "&ID de commande du bouton de la barre d'outils :", -1, 5, 5, 160, 15, SS_CENTERIMAGE | NOT WS_GROUP
    COMBOBOX cmb1, 5, 25, 150, 150, CBS_HASSTRINGS | CBS_AUTOHSCROLL | CBS_DROPDOWN | WS_VSCROLL | WS_TABSTOP
    AUTOCHECKBOX "&Séparateur", chx1, 5, 45, 90, 15
    DEFPUSHBUTTON "OK", IDOK, 45, 70, 60, 15
    PUSHBUTTON "Annuler", IDCANCEL, 110, 70, 60, 15
}

//////////////////////////////////////////////////////////////////////////////
// RT_VERSION

1 VERSIONINFO
FILEVERSION     5, 7, 9, 0
PRODUCTVERSION  5, 7, 9, 0
FILEOS          0x40004
FILETYPE        0x1
FILESUBTYPE     0x0
{
    BLOCK "StringFileInfo"
    {
        BLOCK "040C04E4"
        {
            VALUE "CompanyName", "Katayama Hirofumi MZ\0"
            VALUE "FileDescription", "RisohEditor\0"
            VALUE "FileVersion", "5.7.9\0"
            VALUE "LegalCopyright", "Copyright (C) 2017-2020 Katayama Hirofumi MZ. All rights reserved.\0"
            VALUE "ProductName", "RisohEditor\0"
            VALUE "ProductVersion", "5.7.9\0"
        }
    }
    BLOCK "VarFileInfo"
    {
        VALUE "Translation", 0x040C, 0x04E4
    }
}

//////////////////////////////////////////////////////////////////////////////
// RISOHTEMPLATE

4 RISOHTEMPLATE "res/1036_RISOHTEMPLATE_4.bin"

5 RISOHTEMPLATE "res/1036_RISOHTEMPLATE_5.bin"

//////////////////////////////////////////////////////////////////////////////
// RT_STRING

STRINGTABLE
{
    IDS_APPNAME, "RisohEditor 5.7.9 par Katayama Hirofumi MZ"
    IDS_TITLEWITHFILE, "RisohEditor 5.7.9 - Fichier: %s"
    IDS_EXTRACTRES, "Extraire la ressource"
    IDS_RESBINFILTER, "Ressources binaires (*.res)|*.res|Fichiers binaires (*.bin)|*.bin|Tous les fichiers (*.*)|*.*|"
    IDS_CANNOTSAVE, "Impossible de sauvegarder."
    IDS_REPLACERES, "Remplacer la ressource"
    IDS_ALLFILES, "Tous les fichiers (*.*)|*.*|"
    IDS_ENTERTYPE, "Veuillez saisir un type de ressource."
    IDS_ENTERNAME, "Veuillez saisir un nom de ressource."
    IDS_ENTERLANG, "Veuillez entrer une langue de ressource."
    IDS_FILENOTFOUND, "Le fichier est introuvable."
    IDS_CANNOTREPLACE, "Impossible de remplacer."
    IDS_EXERESFILTER, "Exécutables (*.exe;*.dll;*.ocx;*.cpl;*.scr;*.mui)|*.exe;*.dll;*.ocx;*.cpl;*.scr;*.mui|Fichiers RC (*.rc)|*.rc|Ressources binaires (*.res)|*.res|Tous les fichiers (*.*)|*.*|"
    IDS_SAVEAS, "Enregistrer sous"
    IDS_CANNOTADDICON, "Impossible d'ajouter l'icône."
    IDS_ADDICON, "Ajouter une icône"
    IDS_ICOFILTER, "Fichiers d'icônes (*.ico)|*.ico|Tous les fichiers (*.*)|*.*|"
    IDS_REPLACEICO, "Remplacer l'icône"
    IDS_CANTREPLACEICO, "Impossible de remplacer l'icône."
    IDS_EXISTSOVERWRITE, "L'article existe déjà. Écraser?"
    IDS_OPEN, "Ouvert"
    IDS_CANNOTOPEN, "Impossible d'ouvrir le fichier."
    IDS_ADDBMP, "Ajouter un bitmap"
    IDS_BMPFILTER, "Fichiers bitmap (*.bmp)|*.bmp|Images PNG (*.png)|*.png|Tous les fichiers (*.*)|*.*|"
    IDS_CANTREPLACEBMP, "Impossible de remplacer le bitmap."
    IDS_REPLACEBMP, "Remplacer le bitmap"
    IDS_ERRORCODE, "Code d'erreur %d"
    IDS_VERSIONINFO, "RisohEditor Version 5.7.9\r\n\r\nKatayama Hirofumi MZ\r\n\r\nLicence: GPLv3 (free software)"
    IDS_ADDRES, "Ajouter une ressource"
    IDS_CANNOTADDRES, "Impossible d'ajouter la ressource."
    IDS_CANTADDBMP, "Impossible d'ajouter le bitmap."
    IDS_EXTRACTBMP, "Extraire le bitmap"
    IDS_CANTEXTRACTBMP, "Impossible d'extraire le bitmap."
    IDS_CANTREPLACECUR, "Impossible de remplacer le curseur."
    IDS_CANNOTADDCUR, "Impossible d'ajouter le curseur."
    IDS_CURFILTER, "Fichiers de curseur (*.cur)|*.cur|Curseur d'animation (*.ani)|*.ani|Tous les fichiers (*.*)|*.*|"
    IDS_ADDCUR, "Ajouter un curseur"
    IDS_REPLACECUR, "Remplacer le curseur"
    IDS_EXTRACTICO, "Extraire l'icône"
    IDS_CANTEXTRACTICO, "Impossible d'extraire l'icône."
    IDS_EXTRACTCUR, "Extraire le curseur"
    IDS_CANTEXTRACTCUR, "Impossible d'extraire le curseur."
    IDS_RESFILTER, "Ressources binaires (*.res)|*.res|Tous les fichiers (*.*)|*.*|"
    IDS_NEUTRAL, "Neutre"
    IDS_IMPORTRES, "Importation"
    IDS_CANNOTIMPORT, "Impossible d'importer la ressource."
    IDS_COMPILE, "Compiler (F8)"
    IDS_CANCELEDIT, "Annuler la modification (Ctrl+E)"
    IDS_GUIEDIT, "Modifier par GUI (Ctrl+G)"
    IDS_CANNOTSTARTUP, "Impossible de démarrer le compilateur de ressources."
    IDS_RESMISMATCH, "Le type de ressource n'était pas compatible."
    IDS_SAMPLETEXT, "Ceci est un exemple."
    IDS_ALREADYEXISTS, "Existe déjà."
    IDS_KEY, "Clé"
    IDS_FLAGS, "Drapeaux"
    IDS_COMMANDID, "ID de commande"
    IDS_INVALIDKEY, "Clé non valide."
    IDS_COMPILEERROR, "Échec de la compilation."
    IDS_STRINGID, "ID de chaîne"
    IDS_STRINGVALUE, "Valeur de chaîne"
    IDS_CAPTION, "Légende"
    IDS_HELPID, "ID d'aide"
    IDS_INDENT, "» "
    IDS_DATAISEMPTY, "Les données sont vides."
    IDS_TEST, "Do Test"
    IDS_SEPARATOR, "---"
    IDS_COMPILENOW, "Les données ont été modifiées. Compiler maintenant?"
    IDS_RADWINDOW, "Boîte de dialogue Modifier"
    IDS_ENTERCLASS, "Veuillez saisir un nom de classe de fenêtre valide."
    IDS_TEXTEDIT, "Modifier par texte (Ctrl+T)"
    IDS_CURSORINFO, "Image #%u: Largeur %u, Hauteur %u, Nombre de bits %u, xHotSpot %u, yHotSpot %u, ID %u\r\n"
    IDS_IMAGECOUNT, "Nombre d'images: %u\r\n"
    IDS_ICONINFO, "Image #%u: Largeur %u, Hauteur %u, Nombre de bits %u, ID %u\r\n"
    IDS_READY, "Prêt"
    IDS_EXECUTINGCMD, "Exécution de la commande ..."
    IDS_EDITINGBYGUI, "Édition par GUI..."
    IDS_COORD, "%d, %d, %d, %d"
    IDS_STARTING, "Départ..."
    IDS_COMPILING, "Compilation..."
    IDS_CANNOTLOAD, "Incapable de charger."
    IDS_NONE, "(Aucun)"
    IDS_WAVESOUND, "(Son WAVE)\r\n"
    IDS_IDTYPE, "Type d'ID"
    IDS_IDPREFIX, "Préfixe ID"
    IDS_EMPTYSTR, "Veuillez saisir une chaîne."
    IDS_ANICURSOR, "(Curseur d'animation)\r\n"
    IDS_ANIICON, "(Icône d'animation)\r\n"
    IDS_HEADFILTER, "Fichiers d'en-tête (*.h)|*.h|Tous les fichiers (*.*)|*.*|"
    IDS_LOADRESH, "Charger le fichier ""resource.h"""
    IDS_NAME, "Nom"
    IDS_VALUE, "Valeur"
    IDS_NOSUCHID, "Aucun identifiant de ce type n'a été trouvé."
    IDS_IMAGEINFO, "Largeur %u, Hauteur %u, BitsPixel %u\r\n"
    IDS_ENTERINT, "Veuillez saisir un entier valide."
    IDS_ENTERTEXT, "Veuillez saisir un texte valide."
    IDS_ENTERID, "Veuillez saisir un ID valide."
    IDS_ADDNEXTIDS, "Veuillez ajouter les ID suivants à ""resource.h"":\r\n\r\n"
    IDS_DELETENEXTIDS, "Veuillez supprimer les ID suivants de ""resource.h"":\r\n\r\n"
    IDS_NOCHANGE, "Il n'y a aucun changement d'ID de ressource."
    IDS_DLGFAIL, "Oups, je n'ai pas réussi à créer une boîte de dialogue RAD."
    IDS_LOADWCLIB, "Charger une bibliothèque de classes de fenêtres"
    IDS_AVIMOVIE, "(Film AVI)\r\n"
    IDS_ADDDIALOG, "Ajouter une boîte de dialogue"
    IDS_ADDMENU, "Ajouter un menu"
    IDS_ADDVERINFO, "Ajouter des informations sur la version"
    IDS_ADDCURSOR, "Ajouter un curseur"
    IDS_NOMOREITEM, "Plus d'articles."
    IDS_INVALIDDATA, "(Données invalides)\r\n"
    IDS_UPDATERESH, "Mettre à jour ""resource.h""?"
    IDS_CANTWRITERESH, "Impossible d'écrire ""resource.h""."
    IDS_SAVERESH, "Enregistrer le fichier ""resource.h"""
    IDS_DLLFILTER, "Fichiers DLL (*.dll;*.ocx;*.mui)|*.dll;*.ocx;*.mui|Tous les fichiers (*.*)|*.*|"
    IDS_EXERESRCFILTER, "Fichiers chargeables (*.exe;*.dll;*.ocx;*.cpl;*.scr;*.mui;*.res;*.rc)|*.exe;*.dll;*.ocx;*.cpl;*.scr;*.mui;*.res;*.rc|Exécutables (*.exe;*.dll;*.ocx;*.cpl;*.scr;*.mui)|*.exe;*.dll;*.ocx;*.cpl;*.scr;*.mui|Ressources binaires (*.res)|*.res|Fichiers de ressources (*.rc)|*.rc|Tous les fichiers (*.*)|*.*|"
    IDS_CANTTESTCHILDWND, "Impossible de tester la boîte de dialogue car il s'agit d'une fenêtre enfant."
    IDS_CANTTESTCLASSDLG, "Impossible de tester la boîte de dialogue car elle est classée."
    IDS_FILEISUPXED, "Fichier\r\n\r\n'%s'\r\n\r\nest compressé par UPX. Voulez-vous l'extraire à l'aide d'un fichier temporaire?\r\n\r\nSi vous ne l'avez pas développé, la lecture peut échouer."
    IDS_CANTUPXEXTRACT, "Impossible d'extraire par UPX."
    IDS_CANTSAVEUPXED, "Impossible d'enregistrer le fichier car il a été compressé par UPX."
    IDS_MESSAGEID, "ID du message"
    IDS_MESSAGEVALUE, "Valeur du message"
    IDS_RCFILTER, "Fichiers RC (*.rc)|*.rc|"
    IDS_EXPORT, "Exportation"
    IDS_CANTEXPORT, "L'exportation a échoué."
    IDS_MUSTBEEMPTYDIR, "S'il existe un fichier externe, la destination d'exportation doit être un dossier vide."
    IDS_FULLWIDTH, "０１２３４５６７８９ＡＢＣＤＥＦＧＨＩＪＫＬＭＮＯＰＱＲＳＴＵＶＷＸＹＺａｂｃｄｅｆｇｈｉｊｋｌｍｎｏｐｑｒｓｔｕｖｗｘｙｚ－＿（）．　"
    IDS_HALFWIDTH, "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz-_(). "
    IDS_MACRONAME, "Nom de la macro"
    IDS_MACROVALUE, "Valeur macro"
    IDS_OPTIONAL, "(Optionnel)"
    IDS_ADDINCLUDE, "Ajouter un répertoire d'inclusion"
    IDS_EDITINCLUDE, "Modifier le répertoire d'inclusion"
    IDS_WINDRESEXE, "windres.exe|windres.exe|"
    IDS_CPPEXE, "cpp.exe|cpp.exe|"
    IDS_INVALIDPATH, "Chemin invalide."
    IDS_DATATOOLONG, "Les données sont trop longues."
    IDS_ALL, "(Tout)"
    IDS_UNKNOWNFORMAT, "(Format de données inconnu)\r\n"
    IDS_LANGUAGE, "Langue"
    IDS_INTVALUE, "Valeur entière"
    IDS_PARENTWND, "Fenêtre de test des parents"
    IDS_CHOOSE_OLE_CLSID, "Choisissez OLE CLSID"
    IDS_CONTROL, "Contrôle"
    IDS_MESSAGE, "Message"
    IDS_STRING, "Chaîne"
    IDS_DATAISINVALID, "Les données ne sont pas valides."
    IDS_DLGINIT1, "Vous pouvez spécifier l'initialisation des zones de liste modifiable et des zones de liste en définissant les données d'initialisation dans les données de ressource RT_DLGINIT du même nom que la ressource de boîte de dialogue."
    IDS_DLGINIT2, "Lorsque le message WM_INITDIALOG arrive, l'application peut initialiser la boîte de dialogue en appelant la fonction ExecuteDlgInitDx du fichier joint ""DlgInit/DlgInit.h"".\r\n\r\n"
    IDS_DLGINIT3, "Veuillez spécifier une liste de chaînes de caractères séparées par des sauts de ligne pour RT_DLGINIT."
    IDS_SAMELANG, "C'est la même langue."
    IDS_SAMENAME, "C'est le même nom de ressource."
    IDS_CANTSAVETOEXE, "Impossible d'enregistrer au format EXE à partir d'un fichier non exécutable."
    IDS_CANTSTARTSEARCH, "Impossible de démarrer la recherche."
    IDS_AMERICA, "Amérique"
    IDS_ENGLISH, "Anglais"
    IDS_CHINA, "Chine"
    IDS_CHINESE, "Chinois"
    IDS_RUSSIA, "Russie"
    IDS_RUSSIAN, "russe"
    IDS_WANNAGENRESH, "Voulez-vous générer le fichier 'resource.h'?"
    IDS_EXEFILTER, "Exécutables (*.exe;*.dll;*.ocx;*.cpl;*.scr;*.mui)|*.exe;*.dll;*.ocx;*.cpl;*.scr;*.mui|Tous les fichiers (*.*)|*.*|"
    IDS_SAVEASCOMPRESS, "Économisez avec compressé"
    IDS_TOOL_NEW, "Nouveau"
    IDS_TOOL_OPEN, "Ouvert..."
    IDS_TOOL_SAVE, "Enregistrer sous..."
    IDS_TOOL_EXPAND, "Développer tout"
    IDS_TOOL_COLLAPSE, "Réduire tout"
    IDS_TOOL_PLUS, "Ajouter un item..."
    IDS_TOOL_MINUS, "Effacer l'article"
    IDS_TOOL_CHANGE, "Changer le nom / la langue"
    IDS_TOOL_CLONE, "Cloner dans un autre nom / langue"
    IDS_TOOL_RECOMPILE, "Recompiler"
    IDS_TOOL_CANCELEDIT, "Annuler la modification"
    IDS_TOOL_IMPORT, "Importation..."
    IDS_TOOL_EXTRACT, "Extrait..."
    IDS_TOOL_GUIEDIT, "Modifier par GUI"
    IDS_UNITEDKINGDOM, "Royaume-Uni"
    IDS_GREATBRITAIN, "Grande Bretagne"
    IDS_BRITISH, "Britanique"
    IDS_FRANCE, "France"
    IDS_FRENCH, "Français"
    IDS_GERMANY, "Allemagne"
    IDS_GERMAN, "Allemand"
    IDS_SPAIN, "Espagne"
    IDS_SPANISH, "Espagnol"
    IDS_INVALIDLANG, "Langue méconnaissable."
    IDS_INVALIDNAME, "Nom de ressource non valide."
    IDS_PNGRESBINFILTER, "Image PNG (*.png)|*.png|Ressources binaires (*.res)|*.res|Fichiers binaires (*.bin)|*.bin|Tous les fichiers (*.*)|*.*|"
    IDS_JPEGRESBINFILTER, "Image JPEG (*.jpg;*.jpeg;*.jpe;*.jfif)|*.jpg;*.jpeg;*.jpe;*.jfif|Ressources binaires (*.res)|*.res|Fichiers binaires (*.bin)|*.bin|Tous les fichiers (*.*)|*.*|"
    IDS_GIFRESBINFILTER, "Image GIF (*.gif)|*.gif|Ressources binaires (*.res)|*.res|Fichiers binaires (*.bin)|*.bin|Tous les fichiers (*.*)|*.*|"
    IDS_TIFFRESBINFILTER, "Image TIFF (*.tif;*.tiff)|*.tif;*.tiff|Ressources binaires (*.res)|*.res|Fichiers binaires (*.bin)|*.bin|Tous les fichiers (*.*)|*.*|"
    IDS_AVIRESBINFILTER, "Film AVI (*.avi)|*.avi|Ressources binaires (*.res)|*.res|Fichiers binaires (*.bin)|*.bin|Tous les fichiers (*.*)|*.*|"
    IDS_WAVERESBINFILTER, "WAVE Sound (*.wav)|*.wav|Ressources binaires (*.res)|*.res|Fichiers binaires (*.bin)|*.bin|Tous les fichiers (*.*)|*.*|"
    IDS_COMMENT_SEP, "//////////////////////////////////////////////////////////////////////////////\r\n\r\n"
    IDS_NEWLINE, "\r\n"
    IDS_NOTICE, "// This file is automatically generated by RisohEditor 5.7.9.\r\n"
    IDS_DAGGER, "// † <-- This dagger helps UTF-8 detection.\r\n"
    IDS_IMPORTFILTER, "Fichiers importables|*.rc;*.res;*.dfm;*.html;*.htm;*.manifest;*.ico;*.cur;*.ani;*.wav;*.bmp;*.dib;*.png;*.gif;*.jpg;*.jpeg;*.jpe;*.jfif;*.tif;*.tiff;*.avi;*.wmf;*.emf|Fichiers RC (*.rc)|*.rc|Ressources binaires (*.res)|*.res|Image Files|*.bmp;*.dib;*.png;*.gif;*.jpg;*.jpeg;*.jpe;*.jfif;*.tif;*.tiff;*.wmf;*.emf;*.tlb|Fichiers de curseur (*.cur;*.ani)|*.cur;*.ani|Fichiers d'icônes (*.ico)|*.ico|Fichiers audio WAVE (*.wav)|*.wav|Fichiers HTML (*.html;*.htm)|*.html;*.htm|Fichiers manifeste (*.manifest)|*.manifest|Fichiers Delphi DFM (*.dfm)|*.dfm|TYPELIB Files (*.tlb)|*.tlb|Tous les fichiers (*.*)|*.*|"
    IDS_CANTWRITEBYLOCK, "Impossible d'écrire le fichier car le fichier suivant est verrouillé.\r\n\r\n%s"
    IDS_ANSI, "ANSI"
    IDS_WIDE, "Unicode"
    IDS_UTF8, "UTF-8 (avec BOM)"
    IDS_UTF8N, "UTF-8 (sans BOM)"
    IDS_SJIS, "Shift_JIS"
    IDS_BINARY, "(données binaires)"
    IDS_RESTYPE, "Type de ressource"
    IDS_ENCODING, "Codage"
    IDS_INVALIDRESTYPE, "Type de ressource non valide."
    IDS_PATHSPACEERROR, "Vous avez mal installé à l'emplacement avec des caractères d'espace! Le compilateur de ressources ne peut pas accepter d'espace.\n\nVeuillez éviter ""C:\\Program Files""."
    IDS_LOADEGAPROGRAM, "Charger le programme EGA..."
    IDS_EGAFILTER, "Programme EGA (*.ega)|*.ega|Tous les fichiers (*.*)|*.*|"
    IDS_QUERYSAVECHANGE, "Le fichier a été modifié. Voulez-vous enregistrer les modifications maintenant?"
    IDS_DFMFILTER, "Fichier DFM (*.dfm)|*.dfm|Fichiers texte (*.txt)|*.txt|Tous les fichiers (*.*)|*.*|"
    IDS_CANTEXTRACTDFM, "Impossible d'extraire les données DFM."
    IDS_EXTRACTDFM, "Extraire les données DFM"
    IDS_ENTERNONZERONAME, "Veuillez saisir un nom de ressource différent de zéro."
    IDS_ENTERNONZEROTYPE, "Veuillez saisir un type de ressource différent de zéro."
    IDS_HOMEPAGE, "https://katahiromz.web.fc2.com/re/en/"
    IDS_FILESAVED, "Fichier enregistré."
    IDS_RECOMPILEOK, "Recompilation effectuée."
    IDS_RECOMPILEFAILED, "La recompilation a échoué (erreur de syntaxe)."
    IDS_TOOL_EXPORT, "Exportation..."
    IDS_CODEEDITOR, "Éditeur de code"
    IDS_HEXVIEWER, "Visionneuse hexadécimale"
    IDS_INTEGERORIDENTIFIER, "(entier ou identifiant)"
    IDS_NOTEXT, " "
    IDS_NOUPDATE, "Vous utilisez le dernier RisohEditor."
    IDS_THEREISUPDATE, "RisohEditor% s est disponible. Télécharger maintenant?"
    IDS_CANTCHECKUPDATE, "Impossible de vérifier la mise à jour de RisohEditor."
    IDS_CODEPAGE1252, "1252 (Latin 1)"
    IDS_CODEPAGE1250, "1250 (Latin 2)"
    IDS_CODEPAGE1251, "1251 (Cyrillique)"
    IDS_CODEPAGE1253, "1253 (Grec)"
    IDS_CODEPAGE1254, "1254 (Turc)"
    IDS_CODEPAGE1255, "1255 (Hébreu)"
    IDS_CODEPAGE1256, "1256 (Arabe)"
    IDS_CODEPAGE1257, "1257 (Baltique)"
    IDS_CODEPAGE874, "874 (Thaïlandais)"
    IDS_CODEPAGE932, "932 (Japonais)"
    IDS_CODEPAGE936, "936 (Chinois Simplifié)"
    IDS_CODEPAGE949, "949 (Coréen)"
    IDS_CODEPAGE950, "950 (Chinois Traditionnel)"
    IDS_CODEPAGE65001, "65001 (UTF-8)"
    IDS_EXTRACTTLB, "Extract TYPELIB data"
    IDS_CANTEXTRACTTLB, "Unable to extract the TYPELIB data."
    IDS_TLBRESBINFILTER, "TYPELIB data (*.tlb)|*.tlb|Binary Resources (*.res)|*.res|Text Files (*.txt)|*.txt|MIDL Files (*.idl)|*.idl|All Files (*.*)|*.*|"
    IDS_USAGE, "Usage: RisohEditor [options | ""file""]\n\nOptions:\n--help  Show this message.\n--version  Show version info.\n--load ""your-file.rc""  Load the file (without GUI)\n--save ""your-file.res""  Save the file (without GUI)\n--log-file ""log-file.txt""  Specify the log file.\n--load-options OPTIONS  Set load options.\n--save-options OPTIONS  Set save options.\n\nLoad options: (no-load-res-h)\nSave options: (idc-static)(compress)(sep-lang)(no-res-folder)(lang-macro)(less-comments)(wrap-manifest)(begin-end)(utf-16)(backup)(ms-msgtbl)"
    IDS_NOSELECTION, "Il n'y a pas de sélection."
    IDS_TRANSLATORS, "[Translators]\r\nEnglish: Katayama Hirofumi MZ\r\nFinnish: Veikko Muurikainen\r\nIndonesian: Mas Ahmad Muhammad\r\nItalian: R.B.\r\nJapanese: Katayama Hirofumi MZ\r\nKorean: VenusGirl (비너스걸)\r\nPolish: Piotr Hetnarowicz\r\nPortuguese: JNylson\r\nRussian: Dmitry Yerokhin\r\nSimplified Chinese: 林鸿湘\r\n"
}

//////////////////////////////////////////////////////////////////////////////

```

`src/lang/id_ID.rc`:

```rc
// This file is automatically generated by RisohEditor 5.7.9.
// † <-- This dagger helps UTF-8 detection.

#pragma code_page(65001) // UTF-8

LANGUAGE LANG_INDONESIAN, SUBLANG_DEFAULT

//////////////////////////////////////////////////////////////////////////////
// RT_MENU

IDR_MAINMENU MENU
{
    POPUP "Be&rkas"
    {
        MENUITEM "&Baru\tCtrl+N", ID_NEW
        MENUITEM SEPARATOR
        MENUITEM "&Buka...\tCtrl+O", ID_OPEN
        MENUITEM "Si&mpan...\tCtrl+S", ID_SAVE
        MENUITEM "Simpan Seba&gai...\tShift+Ctrl+S", ID_SAVEAS
        MENUITEM "Simpan dengan &Kompresi...", ID_SAVEASCOMPRESS
        MENUITEM SEPARATOR
        MENUITEM "&Impor...\tCtrl+I", ID_IMPORT
        MENUITEM "&Ekspor...\tCtrl+P", ID_EXPORT
        MENUITEM SEPARATOR
        MENUITEM "Muat Ulang &resource.h...\tCtrl+R", ID_LOADRESH
        MENUITEM "Simpan re&source.h...", ID_UPDATERESHBANG
        MENUITEM "Sara&nkan Modifikasi resource.h...", ID_ADVICERESH
        MENUITEM "&Copot resource.h", ID_UNLOADRESH
        MENUITEM SEPARATOR
        MENUITEM "Muat Perpustakaan Kelas &Jendela...", ID_LOADWCLIB
        MENUITEM SEPARATOR
        POPUP "Berkas yang Digunakan Baru-Baru ini"
        {
            MENUITEM "(Tidak ada)", -1, GRAYED
        }
        MENUITEM SEPARATOR
        MENUITEM "Ke&luar\tAlt+F4", ID_EXIT
    }
    POPUP "&Edit"
    {
        MENUITEM "Edit dengan &GUI...\tCtrl+G", ID_GUIEDIT
        MENUITEM SEPARATOR
        POPUP "&Add"
        {
            MENUITEM "Tambah &Ikon...", ID_ADDICON
            MENUITEM "Tambah &Cursor...", ID_ADDCURSOR
            MENUITEM "Tambah &Bitmap...", ID_ADDBITMAP
            MENUITEM "Tambah &Dialog...", ID_ADDDIALOG
            MENUITEM "Tambah &Menu...", ID_ADDMENU
            MENUITEM "Tambah Tabel &String...", ID_ADDSTRINGTABLE
            MENUITEM "Tambah Tabel P&esan...", ID_ADDMESSAGETABLE
            MENUITEM "Tambah &HTML...", ID_ADDHTML
            MENUITEM "Tambah &Akselerator...", ID_ADDACCEL
            MENUITEM "Tambah Informasi &Versi...", ID_ADDVERINFO
            MENUITEM "Tambah Mani&fest...", ID_ADDMANIFEST
            MENUITEM "Tambahkan Bilah Ala&t...", ID_ADDTOOLBAR
            MENUITEM "Tambah Item Sumbe&r Daya...", ID_ADDRES
        }
        POPUP "&Ganti"
        {
            MENUITEM "Ganti &Ikon...", ID_REPLACEICON
            MENUITEM "Ganti &Cursor...", ID_REPLACECURSOR
            MENUITEM "Ganti &Bitmap...", ID_REPLACEBITMAP
            MENUITEM "Ganti Item Sumber Daya Bina&ry...", ID_REPLACEBIN
        }
        POPUP "&Ekstrak"
        {
            MENUITEM "Ekstrak &Ikon...", ID_EXTRACTICON
            MENUITEM "Ekstrak &Cursor...", ID_EXTRACTCURSOR
            MENUITEM "Ekstrak &Bitmap...", ID_EXTRACTBITMAP
            MENUITEM "Ekstrak Sebag&ai Berkas RC...", ID_EXTRACTRC
            MENUITEM "Ekstrak Item Sumber Daya Bina&ry...", ID_EXTRACTBIN
        }
        MENUITEM SEPARATOR
        MENUITEM "Uba&h Nama/Bahasa\tF2", ID_EDITLABEL
        MENUITEM SEPARATOR
        MENUITEM "Duplikat dengan &Nama Baru...", ID_COPYASNEWNAME
        MENUITEM "Duplikat dengan &Bahasa Baru...", ID_COPYASNEWLANG
        MENUITEM "Salin ke beberapa bahasa...", ID_COPYTOMULTILANG
        MENUITEM SEPARATOR
        MENUITEM "Lakukan &Tes", ID_TEST
        MENUITEM SEPARATOR
        MENUITEM "Ha&pus\tDel", ID_DELETERES
        MENUITEM SEPARATOR
        MENUITEM "Asosiasi &ID...", ID_IDASSOC
        MENUITEM "Yang Telah Ditentukan &Macro...", ID_PREDEFMACROS
        MENUITEM "Pengaturan &Fon...", ID_FONTS
        MENUITEM "Tentukan &Jalur...", ID_SETPATHS
        MENUITEM SEPARATOR
        MENUITEM "&UI Language Select (UI语言选择)...", ID_CHOOSEUILANG
        MENUITEM SEPARATOR
        MENUITEM "Pengaturan &Delphi DFM...", ID_DFMSETTINGS
        MENUITEM "&Konfigurasi...", ID_CONFIG
    }
    POPUP "&Cari"
    {
        MENUITEM "&Temukan...\tCtrl+F", ID_FIND
        MENUITEM SEPARATOR
        MENUITEM "Cari ke &Atas\tShift+F3", ID_FINDUPWARD
        MENUITEM "Cari ke &Bawah\tF3", ID_FINDDOWNWARD
        MENUITEM SEPARATOR
        MENUITEM "&Permintaan konstan...", ID_QUERYCONSTANT
    }
    POPUP "&Tampilan"
    {
        MENUITEM "&Bilah Status", ID_STATUSBAR
        MENUITEM "Bil&ah Alat", ID_SHOWHIDETOOLBAR
        MENUITEM "Bi&nary", ID_BINARYPANE
        MENUITEM SEPARATOR
        MENUITEM "&Perluas Semua\tCtrl+K", ID_EXPAND_ALL
        MENUITEM "Ciut&kan Semua\tCtrl+L", ID_COLLAPSE_ALL
        MENUITEM SEPARATOR
        MENUITEM "Daftar ID Su&mber Daya", ID_IDLIST
        MENUITEM "Daftar Baha&sa...", ID_SHOWLANGS
        MENUITEM SEPARATOR
        MENUITEM "Selalu pernyataan &CONTROL", ID_ALWAYSCONTROL
        MENUITEM "Jangan Gunakan Makro &ID", ID_HIDEIDMACROS
        MENUITEM "Gunakan IDC_ST&ATIC", ID_USEIDC_STATIC
        MENUITEM "Kemas Ka&ta", ID_WORD_WRAP
        MENUITEM "Gunakan BE&GIN/END", ID_USEBEGINEND
        MENUITEM "Gunakan Pesan &Tabel Microsoft", ID_USEMSMSGTBL
        MENUITEM SEPARATOR
        MENUITEM "&Enkoding Item Sumber Daya...", ID_ENCODING
        MENUITEM "Dialog &font substitutes...", ID_DIALOG_FONT_SUBSTITUTES
        MENUITEM SEPARATOR
        MENUITEM "Muat &Ulang", ID_REFRESHALL
    }
    POPUP "&Otomatisasi"
    {
        MENUITEM "Bahasa Pemrograman &EGA...", ID_EGA
        MENUITEM "&Jalankan Program EGA...", ID_EGA_PROGRAM
        MENUITEM "Buka &Manual EGA", ID_OPEN_EGA_MANUAL
    }
    POPUP "&Bantuan"
    {
        MENUITEM "Buka &README.txt (English)", ID_OPENREADME
        MENUITEM "Buka R&EADME-ID.txt (Indonesia)", ID_OPENREADMEID
        MENUITEM "Buka &HISTORY.txt", ID_OPENHISTORY
        MENUITEM "Buka H&ISTORY-ID.txt (Indonesia)", ID_OPENHISTORYID
        MENUITEM "Buka &LICENSE.txt", ID_OPENLICENSE
        MENUITEM SEPARATOR
        MENUITEM "Petu&njuk RisohEditor", ID_GUIDE
        MENUITEM "Cek Pembar&uan RisohEditor...", ID_CHECKUPDATE
        MENUITEM SEPARATOR
        MENUITEM "&Tentang...", ID_ABOUT
    }
}

IDR_POPUPMENUS MENU
{
    POPUP "Popup #0"
    {
        MENUITEM "Edit dengan &GUI...\tCtrl+G", ID_GUIEDIT
        MENUITEM SEPARATOR
        POPUP "&Add"
        {
            MENUITEM "Tambah &Ikon...", ID_ADDICON
            MENUITEM "Tambah &Cursor...", ID_ADDCURSOR
            MENUITEM "Tambah &Bitmap...", ID_ADDBITMAP
            MENUITEM "Tambah &Dialog...", ID_ADDDIALOG
            MENUITEM "Tambah &Menu...", ID_ADDMENU
            MENUITEM "Tambah Tabel &String...", ID_ADDSTRINGTABLE
            MENUITEM "Tambah Tab&el Pesan...", ID_ADDMESSAGETABLE
            MENUITEM "Tambah &HTML...", ID_ADDHTML
            MENUITEM "Tambah &Akselerator...", ID_ADDACCEL
            MENUITEM "Tambah Informasi &Versi...", ID_ADDVERINFO
            MENUITEM "Tambah Mani&fest...", ID_ADDMANIFEST
            MENUITEM "Tambahkan Bilah Ala&t...", ID_ADDTOOLBAR
            MENUITEM "Tambah Item Sumbe&r Daya...", ID_ADDRES
        }
        POPUP "&Ganti"
        {
            MENUITEM "Ganti &Ikon...", ID_REPLACEICON
            MENUITEM "Ganti &Cursor...", ID_REPLACECURSOR
            MENUITEM "Ganti &Bitmap...", ID_REPLACEBITMAP
            MENUITEM "Ganti Item Sumber Daya Bina&ry...", ID_REPLACEBIN
        }
        POPUP "&Extract"
        {
            MENUITEM "Ekstrak &Ikon...", ID_EXTRACTICON
            MENUITEM "Ekstrak &Cursor...", ID_EXTRACTCURSOR
            MENUITEM "Ekstrak &Bitmap...", ID_EXTRACTBITMAP
            MENUITEM "Ekstrak Sebag&ai Berkas RC...", ID_EXTRACTRC
            MENUITEM "Ekstrak Item Sumber Daya Bina&ry...", ID_EXTRACTBIN
        }
        MENUITEM SEPARATOR
        MENUITEM "Uba&h Nama/Bahasa\tF2", ID_EDITLABEL
        MENUITEM SEPARATOR
        MENUITEM "Duplikat dengan &Nama Baru...", ID_COPYASNEWNAME
        MENUITEM "Duplikat dengan &Bahasa Baru...", ID_COPYASNEWLANG
        MENUITEM "Salin ke beberapa bahasa...", ID_COPYTOMULTILANG
        MENUITEM SEPARATOR
        MENUITEM "Lakukan &Tes", ID_TEST
        MENUITEM SEPARATOR
        MENUITEM "Ha&pus\tDel", ID_DELETERES
    }
    POPUP "Popup #1"
    {
        MENUITEM "T&ambah control...", ID_ADDCTRL
        MENUITEM SEPARATOR
        MENUITEM "Gun&ting\tCtrl+X", ID_CUT
        MENUITEM "S&alin\tCtrl+C", ID_COPY
        MENUITEM "Te&mpel\tCtrl+V", ID_PASTE
        MENUITEM "Ha&pus\tDel", ID_DELCTRL
        MENUITEM SEPARATOR
        POPUP "&Indeks"
        {
            MENUITEM "Ke &Atas", ID_CTRLINDEXTOP
            MENUITEM SEPARATOR
            MENUITEM "&Turunkan Indeks", ID_CTRLINDEXMINUS
            MENUITEM "&Naikkan Indeks", ID_CTRLINDEXPLUS
            MENUITEM SEPARATOR
            MENUITEM "Ke &Bawah", ID_CTRLINDEXBOTTOM
            MENUITEM SEPARATOR
            MENUITEM "Tunjukkan/Sembuyikan Indeks\tCtrl+D", ID_SHOWHIDEINDEX
        }
        POPUP "Pe&nataan"
        {
            MENUITEM "Penataan A&tas", ID_TOPALIGN
            MENUITEM "Penataan &Bawah", ID_BOTTOMALIGN
            MENUITEM "Penataan &Kiri", ID_LEFTALIGN
            MENUITEM "Penataan Ka&nan", ID_RIGHTALIGN
            MENUITEM SEPARATOR
            MENUITEM "Muatkan ke &Ubin", ID_FITTOGRID
        }
        MENUITEM SEPARATOR
        MENUITEM "&Muat Ulang", ID_REFRESHDIALOG
        MENUITEM SEPARATOR
        MENUITEM "&Properti Kontrol...", ID_CTRLPROP
        MENUITEM "Pr&operti Dialog...", ID_DLGPROP
    }
    POPUP "Popup #2"
    {
        MENUITEM "&Ubah...", ID_MODIFYASSOC
    }
    POPUP "Popup #3"
    {
        MENUITEM "&Loncati!", ID_IDJUMP
        MENUITEM SEPARATOR
        MENUITEM "&Tambah ID...", ID_ADDRESID
        MENUITEM "&Ubah ID...", ID_MODIFYRESID
        MENUITEM SEPARATOR
        MENUITEM "Salin &Nama", ID_COPYRESIDNAME
        MENUITEM "Salin Nil&ai", ID_COPYRESIDVALUE
        MENUITEM "Salin &Definisi\tCtrl+C", ID_COPYIDDEF
        MENUITEM SEPARATOR
        MENUITEM "&Hapus ID\tDel", ID_DELETERESID
        MENUITEM SEPARATOR
        MENUITEM "Angka &Desimal", ID_BASE10
        MENUITEM "Angka &Hexadecimal", ID_BASE16
        MENUITEM SEPARATOR
        MENUITEM "&Muat Ulang", ID_LOADRESH
    }
    POPUP "Popup #4"
    {
        MENUITEM "&Tambah...", ID_ADD
        MENUITEM SEPARATOR
        MENUITEM "Ubah &Nama...\tF2", ID_RENAME
        MENUITEM "Ubah Nil&ai...", ID_MODIFY
        MENUITEM SEPARATOR
        MENUITEM "Ha&pus\tDel", ID_DELETE
    }
    POPUP "Popup #5"
    {
        MENUITEM "&Salin Nilai Integer", ID_COPY
    }
    POPUP "Popup #6"
    {
        MENUITEM "&Tambah...", psh1
        MENUITEM "&Ubah...", psh2
        MENUITEM SEPARATOR
        MENUITEM "&Atas", psh4
        MENUITEM "&Bawah", psh5
        MENUITEM "&Kiri", psh6
        MENUITEM "Ka&nan", psh7
        MENUITEM SEPARATOR
        MENUITEM "&Hapus\tDel", psh3
    }
    POPUP "Popup #7"
    {
        MENUITEM "&Tambah...", psh1
        MENUITEM "&Ubah...", psh2
        MENUITEM SEPARATOR
        MENUITEM "&Atas", psh4
        MENUITEM "&Bawah", psh5
        MENUITEM SEPARATOR
        MENUITEM "&Hapus\tDel", psh3
    }
    POPUP "Popup #8"
    {
        MENUITEM "&Tambah...", ID_ADD
        MENUITEM "&Ubah...", ID_MODIFY
        MENUITEM SEPARATOR
        MENUITEM "&Hapus\tDel", ID_DELETE
    }
}

//////////////////////////////////////////////////////////////////////////////
// RT_DIALOG

IDD_REPLACERES DIALOGEX 0, 0, 215, 170
CAPTION "Ganti Sumber Daya"
STYLE DS_MODALFRAME | WS_POPUPWINDOW | WS_CAPTION
FONT 9, "MS Shell Dlg", 0, 0, 1
{
    LTEXT "&Jenis Sumber Daya:", -1, 5, 7, 70, 12
    COMBOBOX cmb1, 75, 5, 135, 200, CBS_HASSTRINGS | CBS_AUTOHSCROLL | CBS_DROPDOWN | WS_BORDER | WS_VSCROLL | WS_TABSTOP
    LTEXT "&Nama Sumber Daya:", -1, 5, 32, 70, 12
    COMBOBOX cmb2, 75, 30, 135, 200, CBS_HASSTRINGS | CBS_AUTOHSCROLL | CBS_DROPDOWN | WS_DISABLED | WS_BORDER | WS_VSCROLL | WS_TABSTOP
    LTEXT "B&ahasa Sumber Daya:", -1, 5, 57, 70, 12
    COMBOBOX cmb3, 75, 55, 135, 200, CBS_HASSTRINGS | CBS_AUTOHSCROLL | CBS_DROPDOWN | WS_DISABLED | WS_BORDER | WS_VSCROLL | WS_TABSTOP
    LTEXT "&Berkas Binary:", -1, 5, 85, 100, 12
    EDITTEXT edt1, 5, 97, 205, 14, ES_AUTOHSCROLL
    PUSHBUTTON "J&elajahi...", psh1, 150, 115, 60, 14
    DEFPUSHBUTTON "OK", IDOK, 35, 150, 60, 14
    PUSHBUTTON "Batal", IDCANCEL, 115, 150, 60, 14
    {
        0x1234, 0x5678, 0x0011
    }
}

IDD_ADDICON DIALOG 0, 0, 215, 135
CAPTION "Tambah Ikon"
STYLE DS_MODALFRAME | WS_POPUPWINDOW | WS_CAPTION
FONT 9, "MS Shell Dlg"
{
    LTEXT "Berkas &Ikon:", -1, 5, 7, 100, 12
    EDITTEXT edt1, 5, 18, 205, 14, ES_AUTOHSCROLL
    PUSHBUTTON "J&elajahi...", psh1, 150, 35, 60, 14
    ICON 0, ico1, 5, 35, 0, 0
    LTEXT "&Nama Sumber Daya:", -1, 5, 67, 70, 12
    COMBOBOX cmb2, 75, 65, 120, 300, CBS_HASSTRINGS | CBS_AUTOHSCROLL | CBS_DROPDOWN | WS_BORDER | WS_VSCROLL | WS_TABSTOP
    PUSHBUTTON "&...", psh2, 195, 65, 15, 14
    LTEXT "&Bahasa Sumber Daya:", -1, 5, 92, 70, 12
    COMBOBOX cmb3, 75, 90, 135, 200, CBS_HASSTRINGS | CBS_AUTOHSCROLL | CBS_DROPDOWN | WS_BORDER | WS_VSCROLL | WS_TABSTOP
    DEFPUSHBUTTON "OK", IDOK, 35, 115, 60, 14
    PUSHBUTTON "Batal", IDCANCEL, 115, 115, 60, 14
}

IDD_REPLACEICON DIALOG 0, 0, 215, 135
CAPTION "Ganti Ikon"
STYLE DS_MODALFRAME | WS_POPUPWINDOW | WS_CAPTION
FONT 9, "MS Shell Dlg"
{
    LTEXT "Berkas &Ikon:", -1, 5, 7, 100, 12
    EDITTEXT edt1, 5, 18, 205, 14, ES_AUTOHSCROLL
    PUSHBUTTON "J&elajahi...", psh1, 150, 35, 60, 14
    ICON 0, ico1, 5, 35, 0, 0
    LTEXT "&Nama Sumber Daya:", -1, 5, 67, 70, 12
    COMBOBOX cmb2, 75, 65, 135, 13, CBS_HASSTRINGS | CBS_AUTOHSCROLL | CBS_DROPDOWN | WS_DISABLED | WS_BORDER | WS_VSCROLL | WS_TABSTOP
    LTEXT "&Bahasa Sumber Daya:", -1, 5, 92, 70, 12
    COMBOBOX cmb3, 75, 90, 135, 13, CBS_HASSTRINGS | CBS_AUTOHSCROLL | CBS_DROPDOWN | WS_DISABLED | WS_BORDER | WS_VSCROLL | WS_TABSTOP
    DEFPUSHBUTTON "OK", IDOK, 35, 115, 60, 14
    PUSHBUTTON "Batal", IDCANCEL, 115, 115, 60, 14
}

IDD_ADDBITMAP DIALOG 0, 0, 215, 135
CAPTION "Tambah Bitmap"
STYLE DS_MODALFRAME | WS_POPUPWINDOW | WS_CAPTION
FONT 9, "MS Shell Dlg"
{
    LTEXT "Berkas Bit&map:", -1, 5, 7, 100, 12
    EDITTEXT edt1, 5, 18, 205, 14, ES_AUTOHSCROLL
    PUSHBUTTON "J&elajahi...", psh1, 150, 35, 60, 14
    LTEXT "&Nama Sumber Daya:", -1, 5, 67, 70, 12
    COMBOBOX cmb2, 75, 65, 120, 300, CBS_HASSTRINGS | CBS_AUTOHSCROLL | CBS_DROPDOWN | WS_BORDER | WS_VSCROLL | WS_TABSTOP
    PUSHBUTTON "&...", psh2, 195, 65, 15, 14
    LTEXT "&Bahasa Sumber Daya:", -1, 5, 92, 70, 12
    COMBOBOX cmb3, 75, 90, 135, 200, CBS_HASSTRINGS | CBS_AUTOHSCROLL | CBS_DROPDOWN | WS_BORDER | WS_VSCROLL | WS_TABSTOP
    DEFPUSHBUTTON "OK", IDOK, 35, 115, 60, 14
    PUSHBUTTON "Batal", IDCANCEL, 115, 115, 60, 14
}

IDD_REPLACEBMP DIALOG 0, 0, 215, 135
CAPTION "Ganti Bitmap"
STYLE DS_MODALFRAME | WS_POPUPWINDOW | WS_CAPTION
FONT 9, "MS Shell Dlg"
{
    LTEXT "Berkas Bit&map:", -1, 5, 7, 100, 12
    EDITTEXT edt1, 5, 18, 205, 14, ES_AUTOHSCROLL
    PUSHBUTTON "J&elajahi...", psh1, 150, 35, 60, 14
    LTEXT "&Nama Sumber Daya:", -1, 5, 67, 70, 12
    COMBOBOX cmb2, 75, 65, 135, 200, CBS_HASSTRINGS | CBS_AUTOHSCROLL | CBS_DROPDOWN | WS_DISABLED | WS_BORDER | WS_VSCROLL | WS_TABSTOP
    LTEXT "&Bahasa Sumber Daya:", -1, 5, 92, 70, 12
    COMBOBOX cmb3, 75, 90, 135, 200, CBS_HASSTRINGS | CBS_AUTOHSCROLL | CBS_DROPDOWN | WS_DISABLED | WS_BORDER | WS_VSCROLL | WS_TABSTOP
    DEFPUSHBUTTON "OK", IDOK, 35, 115, 60, 14
    PUSHBUTTON "Batal", IDCANCEL, 115, 115, 60, 14
}

IDD_ADDRES DIALOG 0, 0, 215, 170
CAPTION "Tambah Sumber Daya"
STYLE DS_MODALFRAME | WS_POPUPWINDOW | WS_CAPTION
FONT 9, "MS Shell Dlg"
{
    LTEXT "&Jenis Sumber Daya:", -1, 5, 7, 70, 12
    COMBOBOX cmb1, 75, 5, 135, 200, CBS_HASSTRINGS | CBS_AUTOHSCROLL | CBS_DROPDOWN | WS_BORDER | WS_VSCROLL | WS_TABSTOP
    LTEXT "&Nama Sumber Daya:", -1, 5, 32, 70, 12
    COMBOBOX cmb2, 75, 30, 120, 300, CBS_HASSTRINGS | CBS_AUTOHSCROLL | CBS_DROPDOWN | WS_BORDER | WS_VSCROLL | WS_TABSTOP
    PUSHBUTTON "&...", psh2, 195, 30, 15, 14
    LTEXT "", stc1, 75, 43, 115, 10
    LTEXT "&Bahasa Sumber Daya:", -1, 5, 57, 70, 12
    COMBOBOX cmb3, 75, 55, 135, 200, CBS_HASSTRINGS | CBS_AUTOHSCROLL | CBS_DROPDOWN | WS_BORDER | WS_VSCROLL | WS_TABSTOP
    LTEXT "Be&rkas Binary:", -1, 5, 85, 100, 12
    EDITTEXT edt1, 5, 97, 205, 14, ES_AUTOHSCROLL
    PUSHBUTTON "J&elajahi...", psh1, 150, 115, 60, 14
    LTEXT "", stc2, 5, 112, 100, 10
    DEFPUSHBUTTON "OK", IDOK, 35, 150, 60, 14
    PUSHBUTTON "Batal", IDCANCEL, 115, 150, 60, 14
}

IDD_ADDCURSOR DIALOG 0, 0, 215, 135
CAPTION "Tambah Cursor"
STYLE DS_MODALFRAME | WS_POPUPWINDOW | WS_CAPTION
FONT 9, "MS Shell Dlg"
{
    LTEXT "Berkas &Kursor:", -1, 5, 7, 100, 12
    EDITTEXT edt1, 5, 18, 205, 14, ES_AUTOHSCROLL
    PUSHBUTTON "J&elajahi...", psh1, 150, 35, 60, 14
    ICON 0, ico1, 5, 35, 0, 0
    LTEXT "&Nama Sumber Daya:", -1, 5, 67, 70, 12
    COMBOBOX cmb2, 75, 65, 120, 200, CBS_HASSTRINGS | CBS_AUTOHSCROLL | CBS_DROPDOWN | WS_BORDER | WS_VSCROLL | WS_TABSTOP
    PUSHBUTTON "&...", psh2, 195, 65, 15, 14
    LTEXT "&Bahasa Sumber Daya:", -1, 5, 92, 70, 12
    COMBOBOX cmb3, 75, 90, 135, 200, CBS_HASSTRINGS | CBS_AUTOHSCROLL | CBS_DROPDOWN | WS_BORDER | WS_VSCROLL | WS_TABSTOP
    DEFPUSHBUTTON "OK", IDOK, 35, 115, 60, 14
    PUSHBUTTON "Batal", IDCANCEL, 115, 115, 60, 14
}

IDD_REPLACECUR DIALOG 0, 0, 215, 135
CAPTION "Ganti Kursor"
STYLE DS_MODALFRAME | WS_POPUPWINDOW | WS_CAPTION
FONT 9, "MS Shell Dlg"
{
    LTEXT "Berkas &Kursor:", -1, 5, 7, 100, 12
    EDITTEXT edt1, 5, 18, 205, 14, ES_AUTOHSCROLL
    PUSHBUTTON "J&elajahi...", psh1, 150, 35, 60, 14
    ICON 0, ico1, 5, 35, 0, 0
    LTEXT "&Nama Sumber Daya:", -1, 5, 67, 70, 12
    COMBOBOX cmb2, 75, 65, 135, 200, CBS_HASSTRINGS | CBS_AUTOHSCROLL | CBS_DROPDOWN | WS_DISABLED | WS_BORDER | WS_VSCROLL | WS_TABSTOP
    LTEXT "&Bahasa Sumber Daya:", -1, 5, 92, 70, 12
    COMBOBOX cmb3, 75, 90, 135, 200, CBS_HASSTRINGS | CBS_AUTOHSCROLL | CBS_DROPDOWN | WS_DISABLED | WS_BORDER | WS_VSCROLL | WS_TABSTOP
    DEFPUSHBUTTON "OK", IDOK, 35, 115, 60, 14
    PUSHBUTTON "Batal", IDCANCEL, 115, 115, 60, 14
}

IDD_MENUTEST DIALOG 0, 0, 215, 135
CAPTION "Tes Menu"
STYLE DS_MODALFRAME | WS_POPUPWINDOW | WS_CAPTION
FONT 9, "MS Shell Dlg"
{
}

IDD_ADDKEY DIALOG 0, 0, 190, 120
CAPTION "Tambah Tombol"
STYLE DS_MODALFRAME | WS_POPUPWINDOW | WS_CAPTION
FONT 9, "MS Shell Dlg"
{
    RTEXT "&Tombol:", -1, 5, 12, 60, 14
    COMBOBOX cmb1, 70, 10, 110, 200, CBS_DROPDOWN | WS_BORDER | WS_VSCROLL | WS_TABSTOP
    RTEXT "&ID Perintah:", -1, 5, 37, 60, 14
    COMBOBOX cmb2, 70, 35, 95, 300, CBS_DROPDOWN | WS_BORDER | WS_VSCROLL | WS_TABSTOP
    PUSHBUTTON "&...", psh1, 165, 35, 15, 14
    AUTOCHECKBOX "&VIRTKEY", chx1, 5, 60, 60, 14
    AUTOCHECKBOX "&NOINVERT", chx2, 70, 60, 60, 14
    AUTOCHECKBOX "&CONTROL", chx3, 5, 75, 60, 14
    AUTOCHECKBOX "&SHIFT", chx4, 70, 75, 60, 14
    AUTOCHECKBOX "&ALT", chx5, 140, 75, 45, 14
    DEFPUSHBUTTON "OK", IDOK, 60, 100, 60, 14
    PUSHBUTTON "Batal", IDCANCEL, 125, 100, 60, 14
}

IDD_MODIFYKEY DIALOG 0, 0, 190, 120
CAPTION "Ubah Tombol"
STYLE DS_MODALFRAME | WS_POPUPWINDOW | WS_CAPTION
FONT 9, "MS Shell Dlg"
{
    RTEXT "&Tombol:", -1, 5, 12, 60, 14
    COMBOBOX cmb1, 70, 10, 110, 200, CBS_DROPDOWN | WS_BORDER | WS_VSCROLL | WS_TABSTOP
    RTEXT "&ID Perintah:", -1, 5, 37, 60, 14
    COMBOBOX cmb2, 70, 35, 95, 200, CBS_DROPDOWN | WS_BORDER | WS_VSCROLL | WS_TABSTOP
    PUSHBUTTON "&...", psh1, 165, 35, 15, 14
    AUTOCHECKBOX "&VIRTKEY", chx1, 5, 60, 60, 14
    AUTOCHECKBOX "&NOINVERT", chx2, 70, 60, 60, 14
    AUTOCHECKBOX "&CONTROL", chx3, 5, 75, 60, 14
    AUTOCHECKBOX "&SHIFT", chx4, 70, 75, 60, 14
    AUTOCHECKBOX "&ALT", chx5, 140, 75, 45, 14
    DEFPUSHBUTTON "OK", IDOK, 60, 100, 60, 14
    PUSHBUTTON "Batal", IDCANCEL, 125, 100, 60, 14
}

IDD_EDITACCEL DIALOG 0, 0, 285, 165
CAPTION "Edit Akselerator"
STYLE WS_POPUPWINDOW | WS_CAPTION | WS_THICKFRAME
FONT 9, "MS Shell Dlg"
{
    LTEXT "&Daftar Tombol:", -1, 5, 7, 100, 12
    CONTROL "", lst1, "SysListView32", LVS_NOSORTHEADER | LVS_AUTOARRANGE | LVS_NOLABELWRAP | LVS_SHOWSELALWAYS | LVS_SINGLESEL | LVS_REPORT | WS_BORDER | WS_VSCROLL | WS_HSCROLL | WS_TABSTOP, 5, 20, 210, 120
    PUSHBUTTON "&Tambah...", psh1, 220, 20, 60, 14
    PUSHBUTTON "&Ubah...", psh2, 220, 40, 60, 14
    PUSHBUTTON "&Hapus", psh3, 220, 60, 60, 14
    PUSHBUTTON "&Atas", psh4, 220, 100, 60, 14
    PUSHBUTTON "&Bawah", psh5, 220, 120, 60, 14
    DEFPUSHBUTTON "OK", IDOK, 155, 145, 60, 14
    PUSHBUTTON "Batal", IDCANCEL, 220, 145, 60, 14
    PUSHBUTTON "Hapus &Semua", psh6, 5, 145, 79, 14
}

IDD_ADDSTR DIALOG 0, 0, 255, 115
CAPTION "Tambah Entri String"
STYLE WS_POPUPWINDOW | WS_CAPTION | WS_THICKFRAME
FONT 9, "MS Shell Dlg"
{
    LTEXT "&ID String:", -1, 5, 7, 50, 12
    COMBOBOX cmb1, 60, 5, 134, 200, CBS_HASSTRINGS | CBS_AUTOHSCROLL | CBS_DROPDOWN | WS_BORDER | WS_VSCROLL | WS_TABSTOP
    PUSHBUTTON "&...", psh1, 195, 5, 15, 14
    LTEXT "&Nilai String:", -1, 5, 27, 54, 12
    EDITTEXT edt1, 60, 25, 190, 45, ES_WANTRETURN | ES_AUTOVSCROLL | ES_MULTILINE | WS_VSCROLL
    AUTOCHECKBOX "&Ganti ""\\r\\n"" dengan ""\\n""", chx1, 60, 75, 190, 14
    DEFPUSHBUTTON "OK", IDOK, 125, 95, 60, 14
    PUSHBUTTON "Batal", IDCANCEL, 190, 95, 60, 14
}

IDD_MODIFYSTR DIALOG 0, 0, 255, 115
CAPTION "Ubah Entri String"
STYLE WS_POPUPWINDOW | WS_CAPTION | WS_THICKFRAME
FONT 9, "MS Shell Dlg"
{
    LTEXT "&ID String:", -1, 5, 7, 50, 12
    COMBOBOX cmb1, 60, 5, 134, 200, CBS_HASSTRINGS | CBS_AUTOHSCROLL | CBS_DROPDOWN | WS_BORDER | WS_VSCROLL | WS_TABSTOP
    PUSHBUTTON "&...", psh1, 195, 5, 15, 14
    LTEXT "&Nilai String:", -1, 5, 27, 54, 12
    EDITTEXT edt1, 60, 25, 190, 45, ES_WANTRETURN | ES_AUTOVSCROLL | ES_MULTILINE | WS_VSCROLL
    AUTOCHECKBOX "&Ganti ""\\r\\n"" dengan ""\\n""", chx1, 60, 75, 190, 14
    DEFPUSHBUTTON "OK", IDOK, 125, 95, 60, 14
    PUSHBUTTON "Batal", IDCANCEL, 190, 95, 60, 14
}

IDD_STRINGS DIALOG 0, 0, 325, 160
CAPTION "Tabel String"
STYLE WS_POPUPWINDOW | WS_CAPTION | WS_THICKFRAME
FONT 9, "MS Shell Dlg"
{
    LTEXT "&Daftar String:", -1, 5, 7, 100, 12
    CONTROL "", lst1, "SysListView32", LVS_NOSORTHEADER | LVS_AUTOARRANGE | LVS_NOLABELWRAP | LVS_SHOWSELALWAYS | LVS_SINGLESEL | LVS_REPORT | WS_BORDER | WS_VSCROLL | WS_HSCROLL | WS_TABSTOP, 5, 20, 315, 115
    PUSHBUTTON "&Tambah...", psh1, 130, 3, 60, 14
    PUSHBUTTON "&Ubah...", psh2, 195, 3, 60, 14
    PUSHBUTTON "&Hapus", psh3, 260, 3, 60, 14
    DEFPUSHBUTTON "OK", IDOK, 195, 140, 60, 14
    PUSHBUTTON "Batal", IDCANCEL, 260, 140, 60, 14
    PUSHBUTTON "Hapus &Semua", psh4, 5, 140, 75, 14
}

IDD_ADDMITEM DIALOG 0, 0, 210, 200
CAPTION "Tambah Item Menu"
STYLE DS_MODALFRAME | WS_POPUPWINDOW | WS_CAPTION
FONT 9, "MS Shell Dlg"
{
    LTEXT "J&udul:", -1, 5, 7, 55, 12
    COMBOBOX cmb1, 65, 6, 140, 200, CBS_AUTOHSCROLL | CBS_DROPDOWN | WS_BORDER | WS_VSCROLL | WS_TABSTOP
    LTEXT "&ID Perintah:", -1, 5, 32, 55, 12
    COMBOBOX cmb2, 65, 30, 125, 200, CBS_AUTOHSCROLL | CBS_DROPDOWN | WS_BORDER | WS_VSCROLL | WS_TABSTOP
    PUSHBUTTON "&...", psh1, 190, 30, 15, 14
    AUTOCHECKBOX "&GRAYED", chx1, 5, 60, 60, 14
    AUTOCHECKBOX "&BITMAP", chx3, 135, 60, 60, 14
    AUTOCHECKBOX "&OWNERDRAW", chx4, 5, 80, 65, 14
    AUTOCHECKBOX "&CHECKED", chx5, 75, 80, 60, 14
    AUTOCHECKBOX "SE&PARATOR", chx6, 140, 80, 60, 14
    AUTOCHECKBOX "MENU&BARBREAK", chx7, 5, 100, 75, 14
    AUTOCHECKBOX "MENUB&REAK", chx8, 85, 100, 70, 14
    AUTOCHECKBOX "&DEFAULT", chx9, 5, 120, 60, 14
    AUTOCHECKBOX "&HILITE", chx10, 70, 120, 60, 14
    AUTOCHECKBOX "RADIOCHEC&K", chx11, 135, 120, 60, 14
    AUTOCHECKBOX "RIGH&TORDER", chx12, 5, 139, 60, 14
    AUTOCHECKBOX "RIGHT&JUSTIFY", chx13, 70, 140, 70, 14
    LTEXT "ID Bantua&n:", -1, 5, 162, 45, 12
    COMBOBOX cmb3, 55, 160, 100, 300, CBS_AUTOHSCROLL | CBS_DROPDOWN | WS_BORDER | WS_VSCROLL | WS_TABSTOP
    DEFPUSHBUTTON "OK", IDOK, 80, 180, 60, 14
    PUSHBUTTON "Batal", IDCANCEL, 145, 180, 60, 14
}

IDD_MODIFYMITEM DIALOG 0, 0, 210, 200
CAPTION "Ubah Item Menu"
STYLE DS_MODALFRAME | WS_POPUPWINDOW | WS_CAPTION
FONT 9, "MS Shell Dlg"
{
    LTEXT "J&udul:", -1, 5, 7, 55, 12
    COMBOBOX cmb1, 65, 6, 140, 200, CBS_AUTOHSCROLL | CBS_DROPDOWN | WS_BORDER | WS_VSCROLL | WS_TABSTOP
    LTEXT "&ID Perintah:", -1, 5, 32, 55, 12
    COMBOBOX cmb2, 65, 30, 125, 200, CBS_AUTOHSCROLL | CBS_DROPDOWN | WS_BORDER | WS_VSCROLL | WS_TABSTOP
    PUSHBUTTON "&...", psh1, 190, 30, 15, 14
    AUTOCHECKBOX "&GRAYED", chx1, 5, 60, 60, 14
    AUTOCHECKBOX "&BITMAP", chx3, 135, 60, 60, 14
    AUTOCHECKBOX "&OWNERDRAW", chx4, 5, 80, 65, 14
    AUTOCHECKBOX "&CHECKED", chx5, 75, 80, 60, 14
    AUTOCHECKBOX "SE&PARATOR", chx6, 140, 80, 60, 14
    AUTOCHECKBOX "MENU&BARBREAK", chx7, 5, 100, 75, 14
    AUTOCHECKBOX "MENUB&REAK", chx8, 85, 100, 70, 14
    AUTOCHECKBOX "&DEFAULT", chx9, 5, 120, 60, 14
    AUTOCHECKBOX "&HILITE", chx10, 70, 120, 60, 14
    AUTOCHECKBOX "RADIOCHEC&K", chx11, 135, 120, 60, 14
    AUTOCHECKBOX "RIGH&TORDER", chx12, 5, 139, 60, 14
    AUTOCHECKBOX "RIGHT&JUSTIFY", chx13, 70, 140, 70, 14
    LTEXT "ID Bantua&n:", -1, 5, 162, 45, 12
    COMBOBOX cmb3, 55, 160, 100, 300, CBS_AUTOHSCROLL | CBS_DROPDOWN | WS_BORDER | WS_VSCROLL | WS_TABSTOP
    DEFPUSHBUTTON "OK", IDOK, 80, 180, 60, 14
    PUSHBUTTON "Batal", IDCANCEL, 145, 180, 60, 14
}

IDD_EDITMENU DIALOG 0, 0, 325, 160
CAPTION "Edit Sumber Daya Menu"
STYLE WS_POPUPWINDOW | WS_CAPTION | WS_THICKFRAME
FONT 9, "MS Shell Dlg"
{
    LTEXT "&Sumber Daya Menu:", -1, 5, 7, 85, 12
    CONTROL "", lst1, "SysListView32", LVS_NOSORTHEADER | LVS_AUTOARRANGE | LVS_NOLABELWRAP | LVS_SHOWSELALWAYS | LVS_SINGLESEL | LVS_REPORT | WS_BORDER | WS_VSCROLL | WS_HSCROLL | WS_TABSTOP, 5, 20, 315, 115
    PUSHBUTTON "&Tambah...", psh1, 95, 3, 50, 14
    PUSHBUTTON "&Ubah...", psh2, 150, 3, 50, 14
    PUSHBUTTON "&Hapus", psh3, 205, 3, 50, 14
    PUSHBUTTON "&Atas", psh4, 5, 140, 40, 14
    PUSHBUTTON "&Bawah", psh5, 50, 140, 40, 14
    PUSHBUTTON "&Kiri", psh6, 95, 140, 40, 14
    PUSHBUTTON "Ka&nan", psh7, 140, 140, 41, 14
    AUTOCHECKBOX "Di&perluas", chx1, 260, 3, 60, 14
    DEFPUSHBUTTON "OK", IDOK, 195, 140, 60, 14
    PUSHBUTTON "Batal", IDCANCEL, 260, 140, 60, 14
}

IDD_DLGPROP DIALOG 0, 0, 235, 315
CAPTION "Properti Dialog"
STYLE DS_MODALFRAME | WS_POPUPWINDOW | WS_CAPTION
FONT 9, "MS Shell Dlg"
{
    LTEXT "&Judul:", -1, 5, 7, 85, 11
    COMBOBOX cmb1, 5, 20, 225, 300, CBS_HASSTRINGS | CBS_AUTOHSCROLL | CBS_DROPDOWN | WS_BORDER | WS_VSCROLL | WS_TABSTOP
    AUTOCHECKBOX "P&erluas Dialog", chx1, 100, 5, 86, 14
    LTEXT "&Kiri:", -1, 5, 40, 33, 10
    EDITTEXT edt1, 5, 53, 30, 14, ES_NUMBER | ES_RIGHT
    CONTROL "", scr1, "msctls_updown32", UDS_NOTHOUSANDS | UDS_ARROWKEYS | UDS_AUTOBUDDY | UDS_ALIGNRIGHT | UDS_SETBUDDYINT, 23, 53, 12, 20
    LTEXT "&Atas:", -1, 50, 40, 33, 10
    EDITTEXT edt2, 50, 53, 30, 14, ES_NUMBER | ES_RIGHT
    CONTROL "", scr2, "msctls_updown32", UDS_NOTHOUSANDS | UDS_ARROWKEYS | UDS_AUTOBUDDY | UDS_ALIGNRIGHT | UDS_SETBUDDYINT, 53, 53, 12, 20
    LTEXT "&Lebar:", -1, 95, 40, 33, 10
    EDITTEXT edt3, 95, 53, 30, 14, ES_NUMBER | ES_RIGHT
    CONTROL "", scr3, "msctls_updown32", UDS_NOTHOUSANDS | UDS_ARROWKEYS | UDS_AUTOBUDDY | UDS_ALIGNRIGHT | UDS_SETBUDDYINT, 129, 56, 12, 20
    LTEXT "&Tinggi:", -1, 142, 40, 33, 10
    EDITTEXT edt4, 142, 53, 30, 14, ES_NUMBER | ES_RIGHT
    CONTROL "", scr4, "msctls_updown32", UDS_NOTHOUSANDS | UDS_ARROWKEYS | UDS_AUTOBUDDY | UDS_ALIGNRIGHT | UDS_SETBUDDYINT, 162, 53, 12, 20
    LTEXT "Nama Kela&s:", -1, 5, 73, 85, 11
    COMBOBOX cmb2, 5, 88, 115, 200, CBS_HASSTRINGS | CBS_AUTOHSCROLL | CBS_DROPDOWN | WS_BORDER | WS_VSCROLL | WS_TABSTOP
    LTEXT "ID &Bantuan:", -1, 125, 73, 64, 11
    COMBOBOX cmb3, 125, 88, 65, 200, CBS_HASSTRINGS | CBS_AUTOHSCROLL | CBS_DROPDOWN | WS_BORDER | WS_VSCROLL | WS_TABSTOP
    LTEXT "Nama &Fon:", -1, 5, 105, 80, 11
    COMBOBOX cmb4, 6, 118, 100, 200, CBS_HASSTRINGS | CBS_SORT | CBS_AUTOHSCROLL | CBS_DROPDOWN | WS_BORDER | WS_VSCROLL | WS_TABSTOP
    LTEXT "&Ukuran:", -1, 110, 105, 38, 12
    EDITTEXT edt5, 110, 118, 25, 14, ES_NUMBER
    AUTOCHECKBOX "&B", chx2, 140, 118, 20, 14
    AUTOCHECKBOX "&I", chx3, 165, 118, 20, 14
    LTEXT "SetKa&r:", -1, 5, 138, 80, 11
    COMBOBOX cmb5, 5, 148, 100, 100, CBS_AUTOHSCROLL | CBS_DROPDOWNLIST | WS_VSCROLL | WS_TABSTOP
    LTEXT "Nama &Menu:", -1, 110, 138, 55, 11
    COMBOBOX cmb6, 110, 148, 99, 300, CBS_HASSTRINGS | CBS_AUTOHSCROLL | CBS_DROPDOWN | WS_BORDER | WS_VSCROLL | WS_TABSTOP
    LTEXT "Ga&ya:", -1, 5, 168, 45, 11
    RTEXT "0x", -1, 52, 169, 10, 11
    EDITTEXT edt6, 67, 165, 45, 14, ES_AUTOHSCROLL
    LISTBOX lst1, 5, 183, 110, 110, LBS_DISABLENOSCROLL | LBS_NOINTEGRALHEIGHT | LBS_HASSTRINGS | LBS_MULTIPLESEL | WS_VSCROLL | WS_HSCROLL | WS_TABSTOP
    LTEXT "Ex&Gaya:", -1, 120, 168, 48, 11
    RTEXT "0x", -1, 170, 169, 10, 11
    EDITTEXT edt7, 185, 165, 45, 14, ES_AUTOHSCROLL
    LISTBOX lst2, 120, 183, 110, 110, LBS_DISABLENOSCROLL | LBS_NOINTEGRALHEIGHT | LBS_HASSTRINGS | LBS_MULTIPLESEL | WS_VSCROLL | WS_HSCROLL | WS_TABSTOP
    DEFPUSHBUTTON "OK", IDOK, 106, 298, 60, 14
    PUSHBUTTON "Batal", IDCANCEL, 171, 298, 60, 14
}

IDD_CTRLPROP DIALOG 0, 0, 235, 330
CAPTION "Properti Kontrol"
STYLE DS_MODALFRAME | WS_POPUPWINDOW | WS_CAPTION
FONT 9, "MS Shell Dlg"
{
    LTEXT "Kt&rl ydtentukan:", -1, 5, 7, 68, 12
    COMBOBOX cmb1, 75, 5, 120, 55, CBS_HASSTRINGS | CBS_AUTOHSCROLL | CBS_DROPDOWN | WS_BORDER | WS_VSCROLL | WS_TABSTOP
    CONTROL "", ctl1, "ToolbarWindow32", TBSTYLE_FLAT | TBSTYLE_WRAPABLE | TBSTYLE_TOOLTIPS | CCS_NODIVIDER | CCS_NORESIZE, 5, 22, 185, 30
    LTEXT "&Judul:", -1, 5, 55, 75, 12
    COMBOBOX cmb2, 5, 65, 195, 300, CBS_HASSTRINGS | CBS_AUTOHSCROLL | CBS_DROPDOWN | WS_BORDER | WS_VSCROLL | WS_TABSTOP
    PUSHBUTTON "&OLE...", psh2, 205, 65, 25, 14
    LTEXT "&Kiri:", -1, 5, 85, 33, 11
    EDITTEXT edt1, 5, 99, 25, 14, ES_NUMBER | ES_RIGHT
    CONTROL "", scr1, "msctls_updown32", UDS_NOTHOUSANDS | UDS_ARROWKEYS | UDS_AUTOBUDDY | UDS_ALIGNRIGHT | UDS_SETBUDDYINT, 20, 99, 12, 20
    LTEXT "&Atas:", -1, 40, 85, 33, 11
    EDITTEXT edt2, 40, 99, 25, 14, ES_NUMBER | ES_RIGHT
    CONTROL "", scr2, "msctls_updown32", UDS_NOTHOUSANDS | UDS_ARROWKEYS | UDS_AUTOBUDDY | UDS_ALIGNRIGHT | UDS_SETBUDDYINT, 55, 99, 12, 20
    LTEXT "&Lebar:", -1, 75, 85, 33, 11
    EDITTEXT edt3, 75, 99, 25, 14, ES_NUMBER | ES_RIGHT
    CONTROL "", scr3, "msctls_updown32", UDS_NOTHOUSANDS | UDS_ARROWKEYS | UDS_AUTOBUDDY | UDS_ALIGNRIGHT | UDS_SETBUDDYINT, 90, 99, 12, 20
    LTEXT "&Tinggi:", -1, 111, 85, 33, 11
    EDITTEXT edt4, 110, 99, 25, 14, ES_NUMBER | ES_RIGHT
    CONTROL "", scr4, "msctls_updown32", UDS_NOTHOUSANDS | UDS_ARROWKEYS | UDS_AUTOBUDDY | UDS_ALIGNRIGHT | UDS_SETBUDDYINT, 125, 99, 12, 20
    LTEXT "&ID:", -1, 150, 85, 70, 12
    COMBOBOX cmb3, 150, 99, 80, 300, CBS_HASSTRINGS | CBS_AUTOHSCROLL | CBS_DROPDOWN | WS_BORDER | WS_VSCROLL | WS_TABSTOP
    LTEXT "Na&ma Jendela Kelas:", -1, 5, 119, 100, 12
    COMBOBOX cmb4, 5, 133, 115, 200, CBS_HASSTRINGS | CBS_AUTOHSCROLL | CBS_DROPDOWN | WS_BORDER | WS_VSCROLL | WS_TABSTOP
    LTEXT "ID Ba&ntuan:", -1, 125, 119, 70, 12
    COMBOBOX cmb5, 125, 133, 65, 200, CBS_HASSTRINGS | CBS_AUTOHSCROLL | CBS_DROPDOWN | WS_BORDER | WS_VSCROLL | WS_TABSTOP
    LTEXT "&Gaya:", -1, 5, 153, 45, 12
    RTEXT "0x", -1, 54, 153, 10, 12
    EDITTEXT edt6, 70, 151, 45, 14, ES_AUTOHSCROLL
    LISTBOX lst1, 5, 167, 110, 120, LBS_DISABLENOSCROLL | LBS_NOINTEGRALHEIGHT | LBS_HASSTRINGS | LBS_MULTIPLESEL | WS_VSCROLL | WS_HSCROLL | WS_TABSTOP
    LTEXT "ExGa&ya:", -1, 120, 153, 50, 12
    RTEXT "0x", -1, 172, 153, 10, 12
    EDITTEXT edt7, 185, 151, 45, 14, ES_AUTOHSCROLL
    LISTBOX lst2, 120, 167, 110, 120, LBS_DISABLENOSCROLL | LBS_NOINTEGRALHEIGHT | LBS_HASSTRINGS | LBS_MULTIPLESEL | WS_VSCROLL | WS_HSCROLL | WS_TABSTOP
    DEFPUSHBUTTON "OK", IDOK, 170, 293, 60, 14
    PUSHBUTTON "Batal", IDCANCEL, 170, 309, 60, 14
    PUSHBUTTON "&Data...", psh1, 5, 293, 90, 14
    PUSHBUTTON "Daftar Str&ing...", psh3, 5, 309, 90, 14
}

IDD_ADDCTRL DIALOG 0, 0, 235, 330
CAPTION "Tambah Kontrol"
STYLE DS_MODALFRAME | WS_POPUPWINDOW | WS_CAPTION
FONT 9, "MS Shell Dlg"
{
    LTEXT "Kt&rl ydtentukan:", -1, 5, 7, 68, 12
    COMBOBOX cmb1, 75, 5, 120, 55, CBS_HASSTRINGS | CBS_AUTOHSCROLL | CBS_DROPDOWN | WS_BORDER | WS_VSCROLL | WS_TABSTOP
    CONTROL "", ctl1, "ToolbarWindow32", TBSTYLE_FLAT | TBSTYLE_WRAPABLE | TBSTYLE_TOOLTIPS | CCS_NODIVIDER | CCS_NORESIZE, 5, 22, 185, 30
    LTEXT "&Judul:", -1, 5, 55, 75, 12
    COMBOBOX cmb2, 5, 65, 195, 300, CBS_HASSTRINGS | CBS_AUTOHSCROLL | CBS_DROPDOWN | WS_BORDER | WS_VSCROLL | WS_TABSTOP
    PUSHBUTTON "&OLE...", psh2, 205, 65, 25, 14
    LTEXT "&Kiri:", -1, 5, 85, 33, 11
    EDITTEXT edt1, 5, 99, 25, 14, ES_NUMBER | ES_RIGHT
    CONTROL "", scr1, "msctls_updown32", UDS_NOTHOUSANDS | UDS_ARROWKEYS | UDS_AUTOBUDDY | UDS_ALIGNRIGHT | UDS_SETBUDDYINT, 20, 99, 12, 20
    LTEXT "&Atas:", -1, 40, 85, 33, 11
    EDITTEXT edt2, 40, 99, 25, 14, ES_NUMBER | ES_RIGHT
    CONTROL "", scr2, "msctls_updown32", UDS_NOTHOUSANDS | UDS_ARROWKEYS | UDS_AUTOBUDDY | UDS_ALIGNRIGHT | UDS_SETBUDDYINT, 55, 99, 12, 20
    LTEXT "&Lebar:", -1, 75, 85, 33, 11
    EDITTEXT edt3, 75, 99, 25, 14, ES_NUMBER | ES_RIGHT
    CONTROL "", scr3, "msctls_updown32", UDS_NOTHOUSANDS | UDS_ARROWKEYS | UDS_AUTOBUDDY | UDS_ALIGNRIGHT | UDS_SETBUDDYINT, 90, 99, 12, 20
    LTEXT "&Tinggi:", -1, 111, 85, 33, 11
    EDITTEXT edt4, 110, 99, 25, 14, ES_NUMBER | ES_RIGHT
    CONTROL "", scr4, "msctls_updown32", UDS_NOTHOUSANDS | UDS_ARROWKEYS | UDS_AUTOBUDDY | UDS_ALIGNRIGHT | UDS_SETBUDDYINT, 125, 99, 12, 20
    LTEXT "&ID:", -1, 150, 85, 70, 12
    COMBOBOX cmb3, 150, 99, 80, 300, CBS_HASSTRINGS | CBS_AUTOHSCROLL | CBS_DROPDOWN | WS_BORDER | WS_VSCROLL | WS_TABSTOP
    LTEXT "Na&ma Jendela Kelas:", -1, 5, 119, 100, 12
    COMBOBOX cmb4, 5, 133, 115, 200, CBS_HASSTRINGS | CBS_AUTOHSCROLL | CBS_DROPDOWN | WS_BORDER | WS_VSCROLL | WS_TABSTOP
    LTEXT "ID Ba&ntuan:", -1, 125, 119, 70, 12
    COMBOBOX cmb5, 125, 133, 65, 200, CBS_HASSTRINGS | CBS_AUTOHSCROLL | CBS_DROPDOWN | WS_BORDER | WS_VSCROLL | WS_TABSTOP
    LTEXT "&Gaya:", -1, 5, 153, 45, 12
    RTEXT "0x", -1, 54, 153, 10, 12
    EDITTEXT edt6, 70, 151, 45, 14, ES_AUTOHSCROLL
    LISTBOX lst1, 5, 167, 110, 120, LBS_DISABLENOSCROLL | LBS_NOINTEGRALHEIGHT | LBS_HASSTRINGS | LBS_MULTIPLESEL | WS_VSCROLL | WS_HSCROLL | WS_TABSTOP
    LTEXT "ExGa&ya:", -1, 120, 153, 50, 12
    RTEXT "0x", -1, 172, 153, 10, 12
    EDITTEXT edt7, 185, 151, 45, 14, ES_AUTOHSCROLL
    LISTBOX lst2, 120, 167, 110, 120, LBS_DISABLENOSCROLL | LBS_NOINTEGRALHEIGHT | LBS_HASSTRINGS | LBS_MULTIPLESEL | WS_VSCROLL | WS_HSCROLL | WS_TABSTOP
    DEFPUSHBUTTON "OK", IDOK, 170, 293, 60, 14
    PUSHBUTTON "Batal", IDCANCEL, 170, 309, 60, 14
    PUSHBUTTON "&Data...", psh1, 5, 293, 90, 14
    PUSHBUTTON "Daftar Str&ing...", psh3, 5, 309, 90, 14
}

IDD_IDASSOC DIALOG 0, 0, 200, 220
CAPTION "Asosiasi ID"
STYLE DS_MODALFRAME | WS_POPUPWINDOW | WS_CAPTION
FONT 9, "MS Shell Dlg"
{
    LTEXT "&Asosiasi ID:", -1, 5, 5, 116, 12
    CONTROL "", lst1, "SysListView32", LVS_SHOWSELALWAYS | LVS_SINGLESEL | LVS_REPORT | WS_BORDER | WS_TABSTOP, 5, 20, 190, 150
    PUSHBUTTON "&Setel Ulang Semua", psh2, 5, 175, 85, 14
    PUSHBUTTON "&Ubah", psh1, 135, 175, 60, 14
    DEFPUSHBUTTON "OK", IDOK, 70, 200, 60, 14
    PUSHBUTTON "Batal", IDCANCEL, 135, 200, 60, 14
}

IDD_MODIFYASSOC DIALOG 0, 0, 165, 68
CAPTION "Ubah Asosiasi ID"
STYLE DS_MODALFRAME | WS_POPUPWINDOW | WS_CAPTION
FONT 9, "MS Shell Dlg"
{
    RTEXT "&Jenis ID:", -1, 5, 7, 65, 12
    EDITTEXT edt1, 80, 5, 80, 14, WS_DISABLED
    RTEXT "&Prefix ID:", -1, 5, 32, 65, 12
    EDITTEXT edt2, 80, 28, 80, 14, ES_AUTOHSCROLL
    DEFPUSHBUTTON "OK", IDOK, 35, 50, 60, 14
    PUSHBUTTON "Batal", IDCANCEL, 100, 50, 60, 14
}

IDD_IDLIST DIALOG 0, 0, 200, 300
CAPTION "Daftar ID Suber Daya"
STYLE WS_OVERLAPPEDWINDOW
EXSTYLE WS_EX_TOOLWINDOW
FONT 9, "MS Shell Dlg"
{
    COMBOBOX cmb1, 0, 0, 200, 300, CBS_HASSTRINGS | CBS_SORT | CBS_OWNERDRAWFIXED | CBS_DROPDOWNLIST | WS_VSCROLL | WS_TABSTOP
    CONTROL "", lst1, "SysListView32", LVS_REPORT | WS_BORDER | WS_VSCROLL | WS_HSCROLL | WS_TABSTOP, 0, 15, 200, 285
}

IDD_CONFIG DIALOG 0, 0, 210, 285
CAPTION "Konfigurasi"
STYLE DS_MODALFRAME | WS_POPUPWINDOW | WS_CAPTION
FONT 9, "MS Shell Dlg"
{
    AUTOCHECKBOX "Tampilkan jalur berkas secara penuh pada bilah judu&l", chx1, 5, 5, 200, 14
    AUTOCHECKBOX "Jangan gunakan &makro ID", chx2, 5, 25, 200, 14
    AUTOCHECKBOX "Lanjutkan &posisi jendela yang lalu", chx3, 5, 45, 200, 14
    AUTOCHECKBOX "&Otomatis muat sekitar ""&resource.h""", chx4, 5, 65, 200, 14
    AUTOCHECKBOX "Otomati&s tampilkan daftar ID sumber daya", chx5, 5, 85, 200, 14
    AUTOCHECKBOX "Tampilkan titik pa&da dialog edit", chx6, 5, 105, 200, 14
    RTEXT "Tinggi Kotak Kom&bo:", -1, 10, 127, 75, 12
    EDITTEXT edt1, 90, 125, 34, 14, ES_NUMBER | ES_RIGHT
    CONTROL "", scr1, "msctls_updown32", UDS_NOTHOUSANDS | UDS_ARROWKEYS | UDS_AUTOBUDDY | UDS_ALIGNRIGHT | UDS_SETBUDDYINT, 129, 49, 12, 20
    AUTOCHECKBOX "&Kemas Kata", chx9, 135, 125, 70, 14
    AUTOCHECKBOX "Tanyakan perubahan ""&resource.h""", chx7, 5, 145, 200, 14
    AUTOCHECKBOX "Kompres EXE dengan &UPX ketika menyimpan", chx8, 5, 165, 200, 14
    PUSHBUTTON "&Fon...", psh4, 5, 185, 200, 14
    PUSHBUTTON "&Makro yang telah ditentukan...", psh1, 5, 205, 93, 14
    PUSHBUTTON "&Tentukan Jalur...", psh2, 107, 205, 98, 14
    RTEXT "Nama kontrol &OLE:", -1, 5, 227, 80, 12
    COMBOBOX cmb1, 90, 225, 75, 300, CBS_HASSTRINGS | CBS_AUTOHSCROLL | CBS_DROPDOWN | WS_VSCROLL | WS_TABSTOP
    AUTOCHECKBOX "Buat &Cadangan", chx10, 5, 245, 75, 15
    RTEXT "Suffix Cadangan:", -1, 90, 245, 60, 15
    COMBOBOX cmb2, 158, 244, 45, 300, CBS_HASSTRINGS | CBS_AUTOHSCROLL | CBS_DROPDOWN | WS_VSCROLL | WS_TABSTOP
    DEFPUSHBUTTON "OK", IDOK, 100, 265, 50, 14
    PUSHBUTTON "Batal", IDCANCEL, 155, 265, 50, 14
    PUSHBUTTON "Set &Ulang Semua", psh3, 5, 265, 75, 14
}

IDD_ADDRESID DIALOG 0, 0, 165, 90
CAPTION "Tambah ID Sumber Daya"
STYLE DS_MODALFRAME | WS_POPUPWINDOW | WS_CAPTION
FONT 9, "MS Shell Dlg"
{
    RTEXT "&Jenis ID:", -1, 10, 7, 50, 14
    COMBOBOX cmb1, 65, 5, 95, 300, CBS_AUTOHSCROLL | CBS_DROPDOWNLIST | WS_VSCROLL | WS_TABSTOP
    RTEXT "&Nama ID:", -1, 10, 27, 50, 14
    EDITTEXT edt1, 65, 25, 75, 14, ES_AUTOHSCROLL
    RTEXT "Nilai &Integer:", -1, 10, 47, 50, 14
    EDITTEXT edt2, 65, 45, 48, 14, ES_AUTOHSCROLL
    CONTROL "", scr1, "msctls_updown32", UDS_NOTHOUSANDS | UDS_ARROWKEYS | UDS_AUTOBUDDY | UDS_ALIGNRIGHT | UDS_SETBUDDYINT, 129, 49, 12, 20
    PUSHBUTTON "&Auto", psh1, 115, 45, 45, 14
    DEFPUSHBUTTON "OK", IDOK, 20, 70, 60, 14
    PUSHBUTTON "Batal", IDCANCEL, 85, 70, 60, 14
}

IDD_MODIFYRESID DIALOG 0, 0, 165, 90
CAPTION "Ubah ID Sumber Daya"
STYLE DS_MODALFRAME | WS_POPUPWINDOW | WS_CAPTION
FONT 9, "MS Shell Dlg"
{
    RTEXT "&Nama ID:", -1, 10, 12, 50, 14, SS_REALSIZEIMAGE | NOT WS_GROUP
    EDITTEXT edt1, 65, 10, 95, 14, ES_AUTOHSCROLL
    RTEXT "&Jenis ID:", -1, 10, 32, 50, 14
    EDITTEXT edt2, 65, 30, 95, 14, ES_READONLY
    RTEXT "Nilai &Integer:", -1, 10, 52, 50, 14
    EDITTEXT edt3, 65, 50, 48, 14, ES_AUTOHSCROLL
    CONTROL "", scr1, "msctls_updown32", UDS_NOTHOUSANDS | UDS_ARROWKEYS | UDS_AUTOBUDDY | UDS_ALIGNRIGHT | UDS_SETBUDDYINT, 129, 49, 12, 20
    DEFPUSHBUTTON "OK", IDOK, 20, 70, 60, 14
    PUSHBUTTON "Batal", IDCANCEL, 85, 70, 60, 14
}

IDD_ADVICERESH DIALOG 0, 0, 209, 184
CAPTION "Saran pengubahan pada berkas ""resource.h"""
STYLE DS_MODALFRAME | WS_POPUPWINDOW | WS_CAPTION
FONT 9, "MS Shell Dlg"
{
    LTEXT "Mohon ubah berkas ""resource.h"" Sebagai berikut:", -1, 10, 10, 195, 20
    EDITTEXT edt1, 10, 30, 190, 130, ES_READONLY | ES_MULTILINE
    DEFPUSHBUTTON "OK", IDOK, 140, 165, 60, 14
    PUSHBUTTON "&Bersihkan Pengubahan", psh1, 10, 165, 90, 14
}

IDD_CLONEINNEWNAME DIALOG 0, 0, 215, 75
CAPTION "Duplikat dalam Nama Baru"
STYLE DS_MODALFRAME | WS_POPUPWINDOW | WS_CAPTION
FONT 9, "MS Shell Dlg"
{
    LTEXT "&Jenis Sumber Daya:", -1, 5, 7, 70, 12
    COMBOBOX cmb1, 75, 5, 135, 200, CBS_HASSTRINGS | CBS_AUTOHSCROLL | CBS_DROPDOWN | WS_DISABLED | WS_BORDER | WS_VSCROLL | WS_TABSTOP
    LTEXT "&Nama Sumber Daya:", -1, 5, 32, 70, 12
    COMBOBOX cmb2, 75, 30, 120, 200, CBS_HASSTRINGS | CBS_AUTOHSCROLL | CBS_DROPDOWN | WS_BORDER | WS_VSCROLL | WS_TABSTOP
    PUSHBUTTON "&...", psh1, 195, 30, 15, 14
    DEFPUSHBUTTON "OK", IDOK, 35, 55, 60, 14
    PUSHBUTTON "Batal", IDCANCEL, 115, 55, 60, 14
}

IDD_CLONEINNEWLANG DIALOG 0, 0, 215, 105
CAPTION "Duplikat dalam Bahasa Baru"
STYLE DS_MODALFRAME | WS_POPUPWINDOW | WS_CAPTION
FONT 9, "MS Shell Dlg"
{
    LTEXT "&Jenis Sumber Daya:", -1, 5, 7, 70, 12
    COMBOBOX cmb1, 75, 5, 135, 200, CBS_HASSTRINGS | CBS_AUTOHSCROLL | CBS_DROPDOWN | WS_DISABLED | WS_BORDER | WS_VSCROLL | WS_TABSTOP
    LTEXT "&Nama Sumber Daya:", -1, 5, 32, 70, 12
    COMBOBOX cmb2, 75, 30, 120, 200, CBS_HASSTRINGS | CBS_AUTOHSCROLL | CBS_DROPDOWN | WS_DISABLED | WS_BORDER | WS_VSCROLL | WS_TABSTOP
    LTEXT "&Bahasa Sumber Daya:", -1, 5, 57, 70, 12
    COMBOBOX cmb3, 75, 55, 135, 200, CBS_HASSTRINGS | CBS_AUTOHSCROLL | CBS_DROPDOWN | WS_BORDER | WS_VSCROLL | WS_TABSTOP
    DEFPUSHBUTTON "OK", IDOK, 35, 85, 60, 14
    PUSHBUTTON "Batal", IDCANCEL, 115, 85, 60, 14
}

IDD_ITEMSEARCH DIALOG 0, 0, 171, 135
CAPTION "Pencarian"
STYLE WS_POPUPWINDOW | WS_CAPTION
FONT 9, "MS Shell Dlg"
{
    LTEXT "Cari &string:", -1, 4, 10, 100, 14
    EDITTEXT edt1, 5, 25, 160, 15, ES_AUTOHSCROLL
    AUTOCHECKBOX "&Ikuti BESAR-kecil", chx1, 5, 45, 120, 18
    GROUPBOX "jalur", -1, 5, 65, 160, 42
    AUTORADIOBUTTON "Ke &Atas", rad1, 15, 80, 60, 14, WS_TABSTOP
    AUTORADIOBUTTON "Ke &bawah", rad2, 90, 80, 60, 14, WS_TABSTOP
    DEFPUSHBUTTON "&Temukan", IDOK, 40, 115, 60, 14
    PUSHBUTTON "Batal", IDCANCEL, 105, 115, 60, 14
}

IDD_VERSIONINFO DIALOG 0, 0, 174, 150
CAPTION "Tentang RisohEditor"
STYLE DS_MODALFRAME | WS_POPUPWINDOW | WS_CAPTION
FONT 12, "MS Shell Dlg"
{
    ICON IDI_MAIN, -1, 5, 5, 0, 0
    LTEXT "...", stc1, 30, 5, 140, 50
    CTEXT "https://katahiromz.web.fc2.com", stc2, 5, 60, 165, 12, SS_CENTERIMAGE | SS_NOTIFY | NOT WS_GROUP
    CONTROL "...", edt1, "EDIT", ES_READONLY | ES_AUTOHSCROLL | ES_AUTOVSCROLL | ES_MULTILINE | WS_BORDER | WS_VSCROLL | WS_HSCROLL, 5, 75, 165, 50
    DEFPUSHBUTTON "OK", IDOK, 55, 130, 60, 14
}

IDD_ADDMSG DIALOG 0, 0, 255, 105
CAPTION "Tambah Antrian Pesan"
STYLE DS_MODALFRAME | WS_POPUPWINDOW | WS_CAPTION
FONT 9, "MS Shell Dlg"
{
    LTEXT "&ID Pesan:", -1, 5, 7, 50, 12
    COMBOBOX cmb1, 65, 5, 134, 200, CBS_HASSTRINGS | CBS_AUTOHSCROLL | CBS_DROPDOWN | WS_BORDER | WS_VSCROLL | WS_TABSTOP
    PUSHBUTTON "&...", psh1, 200, 5, 15, 14
    LTEXT "&Nilai Pesan:", -1, 5, 27, 80, 12
    EDITTEXT edt1, 5, 40, 245, 35, ES_WANTRETURN | ES_AUTOHSCROLL | ES_AUTOVSCROLL | ES_MULTILINE
    DEFPUSHBUTTON "OK", IDOK, 125, 85, 60, 14
    PUSHBUTTON "Batal", IDCANCEL, 190, 85, 60, 14
}

IDD_MODIFYMSG DIALOG 0, 0, 255, 105
CAPTION "Edit Antrian Pesan"
STYLE DS_MODALFRAME | WS_POPUPWINDOW | WS_CAPTION
FONT 9, "MS Shell Dlg"
{
    LTEXT "&ID Pesan:", -1, 5, 7, 50, 12
    COMBOBOX cmb1, 65, 5, 134, 200, CBS_HASSTRINGS | CBS_AUTOHSCROLL | CBS_DROPDOWN | WS_DISABLED | WS_BORDER | WS_VSCROLL | WS_TABSTOP
    LTEXT "&Nilai Pesan:", -1, 5, 27, 80, 12
    EDITTEXT edt1, 5, 40, 245, 35, ES_WANTRETURN | ES_AUTOHSCROLL | ES_AUTOVSCROLL | ES_MULTILINE
    DEFPUSHBUTTON "OK", IDOK, 125, 85, 60, 14
    PUSHBUTTON "Batal", IDCANCEL, 190, 85, 60, 14
}

IDD_MESSAGES DIALOG 0, 0, 325, 160
CAPTION "Tabel Pesan"
STYLE WS_POPUPWINDOW | WS_CAPTION | WS_THICKFRAME
FONT 9, "MS Shell Dlg"
{
    LTEXT "&Antrian Pesan:", -1, 5, 7, 80, 12
    CONTROL "", lst1, "SysListView32", LVS_NOSORTHEADER | LVS_AUTOARRANGE | LVS_NOLABELWRAP | LVS_SHOWSELALWAYS | LVS_SINGLESEL | LVS_REPORT | WS_BORDER | WS_VSCROLL | WS_HSCROLL | WS_TABSTOP, 5, 20, 315, 115
    PUSHBUTTON "&Tambah...", psh1, 130, 3, 60, 14
    PUSHBUTTON "&Ubah...", psh2, 195, 3, 60, 14
    PUSHBUTTON "&Hapus", psh3, 260, 3, 60, 14
    DEFPUSHBUTTON "OK", IDOK, 195, 140, 60, 14
    PUSHBUTTON "Batal", IDCANCEL, 260, 140, 60, 14
    PUSHBUTTON "Ha&pus Semua", psh4, 5, 140, 75, 14
}

IDD_FONTS DIALOG 0, 0, 195, 110
CAPTION "Pengaturan Fon"
STYLE DS_MODALFRAME | WS_POPUPWINDOW | WS_CAPTION
FONT 9, "MS Shell Dlg"
{
    RTEXT "&Sumber:", -1, 5, 5, 55, 15, SS_CENTERIMAGE | NOT WS_GROUP
    EDITTEXT edt1, 65, 5, 100, 14, ES_READONLY | ES_AUTOHSCROLL
    PUSHBUTTON "...", psh1, 170, 5, 19, 14
    RTEXT "&Binary:", -1, 5, 25, 55, 15, SS_CENTERIMAGE | NOT WS_GROUP
    EDITTEXT edt2, 65, 25, 100, 14, ES_READONLY | ES_AUTOHSCROLL
    PUSHBUTTON "...", psh2, 170, 25, 19, 14
    GROUPBOX "Pratinjau", -1, 5, 45, 185, 39
    CTEXT "Sumber", stc1, 15, 55, 80, 25, SS_CENTERIMAGE | NOT WS_GROUP
    CTEXT "Binary", stc2, 100, 55, 85, 25, SS_CENTERIMAGE | NOT WS_GROUP
    DEFPUSHBUTTON "OK", IDOK, 65, 90, 60, 14
    PUSHBUTTON "Batal", IDCANCEL, 130, 90, 60, 14
}

IDD_MACROS DIALOG 0, 0, 265, 165
CAPTION "Makro yang Telah Ditentukan"
STYLE WS_POPUPWINDOW | WS_CAPTION | WS_THICKFRAME
FONT 9, "MS Shell Dlg"
{
    LTEXT "Makro &yang Telah Ditentukan:", -1, 5, 0, 100, 15, SS_CENTERIMAGE | NOT WS_GROUP
    CONTROL "", lst1, "SysListView32", LVS_EDITLABELS | LVS_SHOWSELALWAYS | LVS_SINGLESEL | LVS_REPORT | WS_BORDER | WS_TABSTOP, 5, 15, 190, 125
    PUSHBUTTON "&Tambah...", psh1, 200, 15, 60, 14
    PUSHBUTTON "&Edit...", psh2, 200, 35, 60, 14
    PUSHBUTTON "&Hapus", psh3, 200, 55, 60, 14
    PUSHBUTTON "Hapus S&emua", psh7, 200, 105, 60, 14
    DEFPUSHBUTTON "OK", IDOK, 135, 145, 60, 14
    PUSHBUTTON "Batal", IDCANCEL, 200, 145, 60, 14
    PUSHBUTTON "Setel &Ulang Semua", psh6, 5, 145, 60, 14
}

IDD_ADDMACRO DIALOG 0, 0, 190, 80
CAPTION "Tambah Makro yang Telah Ditentukan"
STYLE DS_MODALFRAME | WS_POPUPWINDOW | WS_CAPTION
FONT 9, "MS Shell Dlg"
{
    RTEXT "&Kunci:", -1, 5, 12, 60, 14
    COMBOBOX cmb1, 70, 10, 110, 200, CBS_DROPDOWN | WS_BORDER | WS_VSCROLL | WS_TABSTOP
    RTEXT "&Nilai:", -1, 5, 37, 60, 14
    COMBOBOX cmb2, 70, 35, 110, 300, CBS_DROPDOWN | WS_BORDER | WS_VSCROLL | WS_TABSTOP
    DEFPUSHBUTTON "OK", IDOK, 60, 60, 60, 14
    PUSHBUTTON "Batal", IDCANCEL, 125, 60, 60, 14
}

IDD_EDITMACRO DIALOG 0, 0, 190, 80
CAPTION "Edit Makro yang Telah Ditentukan"
STYLE DS_MODALFRAME | WS_POPUPWINDOW | WS_CAPTION
FONT 9, "MS Shell Dlg"
{
    RTEXT "&Kunci:", -1, 5, 12, 60, 14
    COMBOBOX cmb1, 70, 10, 110, 200, CBS_DROPDOWN | WS_DISABLED | WS_BORDER | WS_VSCROLL | WS_TABSTOP
    RTEXT "&Nilai:", -1, 5, 37, 60, 14
    COMBOBOX cmb2, 70, 35, 110, 300, CBS_DROPDOWN | WS_BORDER | WS_VSCROLL | WS_TABSTOP
    DEFPUSHBUTTON "OK", IDOK, 60, 60, 60, 14
    PUSHBUTTON "Batal", IDCANCEL, 125, 60, 60, 14
}

IDD_CTRLDATA DIALOG 0, 0, 190, 130
CAPTION "Edit Data Kontrol"
STYLE DS_MODALFRAME | WS_POPUPWINDOW | WS_CAPTION
FONT 9, "MS Shell Dlg"
{
    LTEXT "Data &Binary:", -1, 5, 2, 87, 12
    EDITTEXT edt1, 5, 15, 180, 60, ES_AUTOVSCROLL | ES_MULTILINE | WS_VSCROLL
    LTEXT "Anda bisa mengatur data kontrol dengan space-separated integer 16-bit.", -1, 5, 80, 180, 25
    DEFPUSHBUTTON "OK", IDOK, 60, 110, 60, 14
    PUSHBUTTON "Batal", IDCANCEL, 125, 110, 60, 14
}

IDD_PATHS DIALOG 0, 0, 295, 220
CAPTION "Tentukan Jalur"
STYLE WS_POPUPWINDOW | WS_CAPTION | WS_THICKFRAME
FONT 9, "MS Shell Dlg"
{
    LTEXT "D&irektori termasuk:", -1, 5, 5, 102, 12
    LISTBOX lst1, 5, 20, 220, 105, LBS_NOINTEGRALHEIGHT | LBS_HASSTRINGS | LBS_SORT | WS_VSCROLL | WS_HSCROLL | WS_TABSTOP
    PUSHBUTTON "&Tambah...", psh1, 230, 20, 60, 14
    PUSHBUTTON "&Edit...", psh2, 230, 40, 60, 14
    PUSHBUTTON "&Hapus", psh3, 230, 60, 60, 14
    PUSHBUTTON "&Atas", psh4, 230, 80, 60, 14
    PUSHBUTTON "&Bawah", psh5, 230, 100, 60, 14
    PUSHBUTTON "Ha&pus Semua", psh6, 5, 130, 95, 14
    RTEXT "&windres.exe:", stc1, 5, 157, 55, 12
    COMBOBOX cmb1, 70, 155, 155, 300, CBS_HASSTRINGS | CBS_AUTOHSCROLL | CBS_DROPDOWN | WS_VSCROLL | WS_TABSTOP
    PUSHBUTTON "&Jelajah...", psh7, 230, 155, 60, 14
    RTEXT "&cpp.exe:", stc2, 5, 177, 55, 12
    COMBOBOX cmb2, 70, 175, 155, 300, CBS_HASSTRINGS | CBS_AUTOHSCROLL | CBS_DROPDOWN | WS_VSCROLL | WS_TABSTOP
    PUSHBUTTON "Je&lajah...", psh8, 230, 175, 60, 14
    DEFPUSHBUTTON "OK", IDOK, 165, 200, 60, 14
    PUSHBUTTON "Batal", IDCANCEL, 230, 200, 60, 14
    PUSHBUTTON "Set &Ulang Semua", psh9, 5, 200, 95, 14
}

IDD_EXP_OPTIONS DIALOG 0, 0, 250, 225
CAPTION "Pilihan Ekspor"
STYLE DS_MODALFRAME | WS_POPUPWINDOW | WS_CAPTION
FONT 9, "MS Shell Dlg"
{
    ICON IDI_MAIN, -1, 5, 10, 0, 0
    LTEXT "Mengekspor berkas RC akan membuat beberapa berkas terkait. Anda bisa memilih opsi berikut:", -1, 35, 5, 210, 29
    AUTOCHECKBOX "Use Microsoft MESSAGE&TABLE", chx8, 5, 40, 240, 14
    AUTOCHECKBOX "&Pisahkan berkas sumber daya dengan bahasa", chx1, 5, 60, 240, 14
    AUTOCHECKBOX "Gunakan kata kunci B&EGIN/END", chx2, 5, 80, 240, 14
    AUTOCHECKBOX "Buat bahasa bisa dipilih dengan makro LANGUAGE_*", chx3, 5, 100, 240, 14
    AUTOCHECKBOX "&Buat dadangan", chx4, 5, 120, 110, 14
    RTEXT "Suffix Cadangan:", -1, 120, 122, 75, 12
    COMBOBOX cmb1, 200, 120, 45, 300, CBS_HASSTRINGS | CBS_AUTOHSCROLL | CBS_DROPDOWN | WS_VSCROLL | WS_TABSTOP
    AUTOCHECKBOX "Ko&mentar keluaran yang tidak penting", chx5, 5, 140, 240, 14
    AUTOCHECKBOX "Kemas pernyataan ma&nifest dengan #ifndef MSVC ... #endif", chx6, 5, 160, 240, 14
    AUTOCHECKBOX "Berkas keluaran RC sebagai &UTF-16", chx7, 5, 180, 240, 14
    DEFPUSHBUTTON "OK", IDOK, 120, 205, 60, 14
    PUSHBUTTON "Batal", IDCANCEL, 185, 205, 60, 14
}

IDD_LANGS DIALOG 0, 0, 250, 235
CAPTION "Bahasa"
STYLE WS_POPUPWINDOW | WS_CAPTION | WS_THICKFRAME
FONT 9, "MS Shell Dlg"
{
    CONTROL "", lst1, "SysListView32", LVS_SHOWSELALWAYS | LVS_SINGLESEL | LVS_REPORT | WS_BORDER | WS_TABSTOP, 5, 5, 240, 179
    RTEXT "&Cari:", stc1, 5, 192, 45, 12
    COMBOBOX cmb1, 55, 190, 85, 300, CBS_SORT | CBS_DROPDOWN | WS_VSCROLL | WS_TABSTOP
    EDITTEXT edt1, 4, 209, 240, 20, ES_AUTOHSCROLL | ES_AUTOVSCROLL | ES_MULTILINE
}

IDD_CHILD DIALOG 0, 0, 215, 135
CAPTION "Dialog Anak"
STYLE WS_CHILD | WS_OVERLAPPEDWINDOW
FONT 9, "MS Shell Dlg"
{
    DEFPUSHBUTTON "OK", IDOK, 35, 115, 60, 14
    PUSHBUTTON "Batal", IDCANCEL, 115, 115, 60, 14
}

IDD_DLGINITEDIT DIALOG 0, 0, 325, 165
CAPTION "Edit DLGINIT"
STYLE WS_POPUPWINDOW | WS_CAPTION | WS_THICKFRAME
FONT 9, "MS Shell Dlg"
{
    LTEXT "A&ntrian Pesan:", -1, 5, 7, 100, 12
    CONTROL "", lst1, "SysListView32", LVS_NOSORTHEADER | LVS_AUTOARRANGE | LVS_NOLABELWRAP | LVS_SHOWSELALWAYS | LVS_SINGLESEL | LVS_REPORT | WS_BORDER | WS_VSCROLL | WS_HSCROLL | WS_TABSTOP, 5, 20, 250, 120
    PUSHBUTTON "&Tambah...", psh1, 260, 20, 60, 14
    PUSHBUTTON "&Ubah...", psh2, 260, 40, 60, 14
    PUSHBUTTON "&Hapus", psh3, 260, 60, 60, 14
    PUSHBUTTON "&Atas", psh4, 260, 100, 60, 14
    PUSHBUTTON "&Bawah", psh5, 260, 120, 60, 14
    DEFPUSHBUTTON "OK", IDOK, 195, 145, 60, 14
    PUSHBUTTON "Batal", IDCANCEL, 260, 145, 60, 14
    PUSHBUTTON "Ha&pus Semua", psh6, 5, 145, 79, 14
}

IDD_ADDDLGINIT DIALOG 0, 0, 184, 137
CAPTION "Tambah Data DLGINIT"
STYLE DS_MODALFRAME | WS_POPUPWINDOW | WS_CAPTION
FONT 9, "MS Shell Dlg"
{
    LTEXT "&ID Kontrol:", -1, 5, 7, 56, 12
    COMBOBOX cmb1, 65, 5, 115, 300, CBS_HASSTRINGS | CBS_AUTOHSCROLL | CBS_DROPDOWN | WS_VSCROLL | WS_TABSTOP
    LTEXT "&Pesan:", -1, 5, 32, 55, 12
    COMBOBOX cmb2, 65, 30, 95, 300, CBS_HASSTRINGS | CBS_AUTOHSCROLL | CBS_DROPDOWN | WS_VSCROLL | WS_TABSTOP
    LTEXT "&String:", -1, 5, 52, 55, 12
    EDITTEXT edt1, 5, 65, 175, 50, ES_WANTRETURN | ES_MULTILINE | WS_VSCROLL | WS_HSCROLL
    DEFPUSHBUTTON "OK", IDOK, 55, 120, 60, 14
    PUSHBUTTON "Batal", IDCANCEL, 120, 120, 60, 14
}

IDD_MODIFYDLGINIT DIALOG 0, 0, 184, 137
CAPTION "Ubah Data DLGINIT"
STYLE DS_MODALFRAME | WS_POPUPWINDOW | WS_CAPTION
FONT 9, "MS Shell Dlg"
{
    LTEXT "&ID Kontrol:", -1, 5, 7, 56, 12
    COMBOBOX cmb1, 65, 5, 115, 300, CBS_HASSTRINGS | CBS_AUTOHSCROLL | CBS_DROPDOWN | WS_VSCROLL | WS_TABSTOP
    LTEXT "&Pesan:", -1, 5, 32, 55, 12
    COMBOBOX cmb2, 65, 30, 95, 300, CBS_HASSTRINGS | CBS_AUTOHSCROLL | CBS_DROPDOWN | WS_VSCROLL | WS_TABSTOP
    LTEXT "&String:", -1, 5, 52, 55, 12
    EDITTEXT edt1, 5, 65, 175, 50, ES_WANTRETURN | ES_MULTILINE | WS_VSCROLL | WS_HSCROLL
    DEFPUSHBUTTON "OK", IDOK, 55, 120, 60, 14
    PUSHBUTTON "Batal", IDCANCEL, 120, 120, 60, 14
}

IDD_STRINGLIST DIALOG 0, 0, 205, 220
CAPTION "Daftar Kontrol String"
STYLE WS_POPUPWINDOW | WS_CAPTION | WS_THICKFRAME
FONT 9, "MS Shell Dlg"
{
    LTEXT "", stc1, 5, 5, 195, 70
    EDITTEXT edt1, 5, 80, 195, 115, ES_WANTRETURN | ES_MULTILINE | WS_VSCROLL | WS_HSCROLL
    DEFPUSHBUTTON "OK", IDOK, 75, 200, 60, 14
    PUSHBUTTON "Batal", IDCANCEL, 140, 200, 60, 14
}

IDD_SAVE_OPTIONS DIALOG 0, 0, 250, 225
CAPTION "Pilihan Simpan"
STYLE DS_MODALFRAME | WS_POPUPWINDOW | WS_CAPTION
FONT 9, "MS Shell Dlg"
{
    ICON IDI_MAIN, -1, 5, 10, 0, 0
    LTEXT "Menyimpan berkas RC akan membuat beberapa berkas terkait. Anda bisa memilih opsi berikut:", -1, 35, 5, 210, 29
    AUTOCHECKBOX "Gunakan MESSAGE&TABLE Microsoft", chx8, 5, 40, 240, 14
    AUTOCHECKBOX "Pisah berkas sumber daya dengan &bahasa", chx1, 5, 60, 240, 14
    AUTOCHECKBOX "Gunakan kata kunci B&EGIN/END", chx2, 5, 80, 240, 14
    AUTOCHECKBOX "Buat bahasa bisa dipilih dengan makro LANGUAGE_*", chx3, 5, 100, 240, 14
    AUTOCHECKBOX "Buat &cadangan", chx4, 5, 120, 110, 14
    RTEXT "Suffix Cadangan:", -1, 120, 122, 75, 12
    COMBOBOX cmb1, 200, 120, 45, 300, CBS_HASSTRINGS | CBS_AUTOHSCROLL | CBS_DROPDOWN | WS_VSCROLL | WS_TABSTOP
    AUTOCHECKBOX "Komentar keluaran &yang tidak diperlukan", chx5, 5, 140, 240, 14
    AUTOCHECKBOX "kemas pernyataan ma&nifest dengan #ifndef MSVC ... #endif", chx6, 5, 160, 240, 14
    AUTOCHECKBOX "Berkas keluaran RC sebagai &UTF-16", chx7, 5, 180, 240, 14
    DEFPUSHBUTTON "OK", IDOK, 120, 205, 60, 14
    PUSHBUTTON "Batal", IDCANCEL, 185, 205, 60, 14
}

IDD_ENCODING DIALOG 0, 0, 200, 170
CAPTION "Enkoding Item Sumber Daya"
STYLE DS_MODALFRAME | WS_POPUPWINDOW | WS_CAPTION
FONT 9, "MS Shell Dlg"
{
    CONTROL "", lst1, "SysListView32", LVS_SHOWSELALWAYS | LVS_SINGLESEL | LVS_REPORT | WS_BORDER, 5, 5, 190, 115
    PUSHBUTTON "&Tambah...", psh1, 5, 125, 60, 14
    PUSHBUTTON "&Ubah...", psh2, 70, 125, 60, 14
    PUSHBUTTON "&Hapus", psh3, 135, 125, 60, 14
    DEFPUSHBUTTON "OK", IDOK, 70, 150, 60, 14
    PUSHBUTTON "Batal", IDCANCEL, 135, 150, 60, 14
    PUSHBUTTON "&Set Ulang", psh5, 5, 149, 60, 14
}

IDD_ADDENC DIALOG 0, 0, 215, 80
CAPTION "Tambah Enkoding Sumber Daya"
STYLE DS_MODALFRAME | WS_POPUPWINDOW | WS_CAPTION
FONT 9, "MS Shell Dlg"
{
    LTEXT "&Jenis Sumber Daya:", -1, 5, 7, 70, 12
    COMBOBOX cmb1, 75, 5, 135, 200, CBS_HASSTRINGS | CBS_AUTOHSCROLL | CBS_DROPDOWN | WS_BORDER | WS_VSCROLL | WS_TABSTOP
    LTEXT "&Enkoding:", -1, 5, 30, 70, 12
    COMBOBOX cmb2, 75, 30, 85, 300, CBS_HASSTRINGS | CBS_AUTOHSCROLL | CBS_DROPDOWNLIST | WS_VSCROLL | WS_TABSTOP
    DEFPUSHBUTTON "OK", IDOK, 86, 60, 60, 14
    PUSHBUTTON "Batal", IDCANCEL, 150, 60, 60, 14
}

IDD_MODIFYENC DIALOG 0, 0, 215, 80
CAPTION "Ubah Enkoding Sumber Daya"
STYLE DS_MODALFRAME | WS_POPUPWINDOW | WS_CAPTION
FONT 9, "MS Shell Dlg"
{
    LTEXT "&Jenis Sumber Daya:", -1, 5, 7, 70, 12
    COMBOBOX cmb1, 75, 5, 135, 200, CBS_HASSTRINGS | CBS_AUTOHSCROLL | CBS_DROPDOWN | WS_DISABLED | WS_BORDER | WS_VSCROLL | WS_TABSTOP
    LTEXT "&Enkoding:", -1, 5, 30, 70, 12
    COMBOBOX cmb2, 75, 30, 85, 300, CBS_HASSTRINGS | CBS_AUTOHSCROLL | CBS_DROPDOWNLIST | WS_VSCROLL | WS_TABSTOP
    DEFPUSHBUTTON "OK", IDOK, 86, 60, 60, 14
    PUSHBUTTON "Batal", IDCANCEL, 150, 60, 60, 14
}

IDD_CONSTANT DIALOG 0, 0, 205, 75
CAPTION "Konstan Kueri"
STYLE DS_MODALFRAME | WS_POPUPWINDOW | WS_CAPTION
FONT 9, "MS Shell Dlg"
{
    LTEXT "&Nama Konstan:", -1, 5, 7, 80, 12
    COMBOBOX cmb1, 94, 7, 105, 300, CBS_HASSTRINGS | CBS_AUTOHSCROLL | CBS_DROPDOWN | WS_VSCROLL | WS_TABSTOP
    LTEXT "Nil&ai Konstan:", -1, 5, 32, 80, 12
    EDITTEXT edt2, 95, 30, 50, 14, ES_READONLY
    EDITTEXT edt3, 150, 30, 50, 14, ES_READONLY
    DEFPUSHBUTTON "OK", IDOK, 70, 55, 60, 14
}

IDD_EGA DIALOG 0, 0, 400, 225
CAPTION "Bahasa Pemrograman EGA"
STYLE WS_POPUPWINDOW | WS_CAPTION | WS_THICKFRAME
FONT 9, "MS Shell Dlg"
{
    GROUPBOX "Konsol EGA", grp1, 5, 5, 390, 195
    EDITTEXT edt1, 10, 20, 380, 170, ES_READONLY | ES_AUTOVSCROLL | ES_MULTILINE | WS_VSCROLL | NOT WS_TABSTOP
    RTEXT "EGA>", stc1, 10, 208, 20, 10
    EDITTEXT edt2, 35, 205, 300, 15, ES_WANTRETURN | ES_AUTOHSCROLL | ES_AUTOVSCROLL | ES_MULTILINE
    PUSHBUTTON "&Masukkan", IDOK, 345, 205, 50, 15
}

IDD_FONTSUBST DIALOG 0, 0, 185, 180
CAPTION "Penggantian Fon Dialog"
STYLE DS_CENTER | DS_MODALFRAME | WS_POPUPWINDOW | WS_CAPTION
FONT 9, "MS Shell Dlg"
{
    LTEXT "Font #&1:", -1, 5, 7, 44, 12
    COMBOBOX cmb1, 55, 5, 125, 300, CBS_HASSTRINGS | CBS_AUTOHSCROLL | CBS_DROPDOWN | WS_VSCROLL | WS_TABSTOP
    ICON IDI_ARROW, -1, 30, 25, 0, 0
    COMBOBOX cmb2, 55, 30, 125, 300, CBS_HASSTRINGS | CBS_AUTOHSCROLL | CBS_DROPDOWN | WS_VSCROLL | WS_TABSTOP
    LTEXT "Font #&2:", -1, 5, 57, 44, 12
    COMBOBOX cmb3, 55, 55, 125, 300, CBS_HASSTRINGS | CBS_AUTOHSCROLL | CBS_DROPDOWN | WS_VSCROLL | WS_TABSTOP
    ICON IDI_ARROW, -1, 30, 75, 0, 0
    COMBOBOX cmb4, 55, 80, 125, 300, CBS_HASSTRINGS | CBS_AUTOHSCROLL | CBS_DROPDOWN | WS_VSCROLL | WS_TABSTOP
    LTEXT "Font #&3:", -1, 5, 105, 44, 12
    COMBOBOX cmb5, 55, 105, 125, 300, CBS_HASSTRINGS | CBS_AUTOHSCROLL | CBS_DROPDOWN | WS_VSCROLL | WS_TABSTOP
    ICON IDI_ARROW, -1, 30, 125, 0, 0
    COMBOBOX cmb6, 55, 130, 125, 300, CBS_HASSTRINGS | CBS_AUTOHSCROLL | CBS_DROPDOWN | WS_VSCROLL | WS_TABSTOP
    DEFPUSHBUTTON "OK", IDOK, 75, 160, 50, 14
    PUSHBUTTON "Batal", IDCANCEL, 130, 160, 50, 14
    PUSHBUTTON "&Set Ulang", psh1, 5, 160, 55, 14
}

IDD_DROPDOWNPOPUP DIALOG 0, 0, 120, 150
CAPTION " "
STYLE WS_POPUP | WS_DLGFRAME | NOT WS_BORDER
FONT 9, "MS Shell Dlg"
{
    LISTBOX lst1, 0, 0, 120, 150, LBS_WANTKEYBOARDINPUT | LBS_NOINTEGRALHEIGHT | LBS_HASSTRINGS | WS_VSCROLL | WS_TABSTOP, WS_EX_CLIENTEDGE
}

IDD_DFMSETTINGS DIALOG 0, 0, 210, 135
CAPTION "Pengaturan Delphi DFM"
STYLE DS_CENTER | DS_MODALFRAME | WS_POPUPWINDOW | WS_CAPTION
FONT 9, "MS Shell Dlg"
{
    LTEXT "Pengaturan berikut relevan ke DFM:", -1, 35, 5, 171, 20
    ICON IDI_DFMICON, -1, 5, 5, 0, 0
    RTEXT "&Codepage:", -1, 6, 32, 70, 12
    COMBOBOX cmb1, 85, 30, 120, 300, CBS_HASSTRINGS | CBS_AUTOHSCROLL | CBS_DROPDOWN | WS_VSCROLL | WS_TABSTOP
    AUTOCHECKBOX "&Gunakan komentar raw string", chx1, 5, 50, 200, 14
    AUTOCHECKBOX "Jangan gunakan &Unicode dan UTF-8", chx2, 5, 70, 200, 14
    DEFPUSHBUTTON "OK", IDOK, 80, 115, 60, 14
    PUSHBUTTON "Batal", IDCANCEL, 145, 115, 60, 14
}

IDD_COPYTOMULTILANG DIALOG 0, 0, 200, 195
CAPTION "Salin ke beberapa bahasa"
STYLE DS_CENTER | DS_MODALFRAME | WS_POPUPWINDOW | WS_CAPTION
FONT 9, "MS Shell Dlg"
{
    LTEXT "Harap tambahkan bahasa yang ingin Anda salin sumber dayanya:", -1, 5, 5, 190, 22
    LTEXT "&Bahasa:", -1, 5, 35, 82, 12
    LISTBOX lst1, 5, 50, 190, 100, LBS_WANTKEYBOARDINPUT | LBS_NOINTEGRALHEIGHT | LBS_HASSTRINGS | WS_VSCROLL | WS_TABSTOP
    COMBOBOX cmb3, 5, 155, 126, 14, CBS_HASSTRINGS | CBS_AUTOHSCROLL | CBS_DROPDOWN | WS_BORDER | WS_VSCROLL | WS_TABSTOP
    PUSHBUTTON "&Menambahkan", psh1, 135, 155, 60, 14
    DEFPUSHBUTTON "OK", IDOK, 5, 175, 60, 14
    PUSHBUTTON "Batal", IDCANCEL, 70, 175, 60, 14
}

IDD_TOOLBARRES DIALOG 0, 0, 230, 195
CAPTION "Sumber daya bilah alat"
STYLE DS_CENTER | DS_MODALFRAME | WS_POPUPWINDOW | WS_CAPTION
FONT 9, "MS Shell Dlg"
{
    RTEXT "&Lebar ikon:", -1, 5, 5, 60, 15, SS_CENTERIMAGE | NOT WS_GROUP
    EDITTEXT edt1, 70, 5, 30, 15, ES_NUMBER | ES_RIGHT
    CONTROL "", scr1, "msctls_updown32", UDS_NOTHOUSANDS | UDS_ARROWKEYS | UDS_AUTOBUDDY | UDS_ALIGNRIGHT | UDS_SETBUDDYINT, 80, 5, 30, 15
    RTEXT "&Tinggi ikon:", -1, 110, 5, 60, 15, SS_CENTERIMAGE | NOT WS_GROUP
    EDITTEXT edt2, 180, 5, 30, 15, ES_NUMBER | ES_RIGHT
    CONTROL "", scr2, "msctls_updown32", UDS_NOTHOUSANDS | UDS_ARROWKEYS | UDS_AUTOBUDDY | UDS_ALIGNRIGHT | UDS_SETBUDDYINT, 190, 5, 30, 15
    LTEXT "&Tombol bilah alat:", -1, 5, 25, 140, 15, SS_CENTERIMAGE | NOT WS_GROUP
    LISTBOX lst1, 5, 40, 140, 130, LBS_DISABLENOSCROLL | LBS_WANTKEYBOARDINPUT | LBS_NOINTEGRALHEIGHT | LBS_HASSTRINGS | LBS_OWNERDRAWFIXED | WS_VSCROLL | WS_TABSTOP
    PUSHBUTTON "&Menambahkan...", psh1, 150, 40, 75, 15
    PUSHBUTTON "&Memodifikasi...", psh2, 150, 60, 75, 15
    PUSHBUTTON "&Menghapus", psh3, 150, 80, 75, 15
    PUSHBUTTON "&Ke atas", psh4, 150, 135, 75, 15
    PUSHBUTTON "&Turun", psh5, 150, 155, 75, 15
    DEFPUSHBUTTON "OK", IDOK, 5, 175, 60, 15
    PUSHBUTTON "Batal", IDCANCEL, 70, 175, 60, 15
}

IDD_ADDTBBTN DIALOG 0, 0, 177, 92
CAPTION "Tambahkan tombol Toolbar"
STYLE DS_CENTER | DS_MODALFRAME | WS_POPUPWINDOW | WS_CAPTION
FONT 9, "MS Shell Dlg"
{
    LTEXT "&ID Perintah tombol Toolbar:", -1, 5, 5, 160, 15, SS_CENTERIMAGE | NOT WS_GROUP
    COMBOBOX cmb1, 5, 25, 150, 150, CBS_HASSTRINGS | CBS_AUTOHSCROLL | CBS_DROPDOWN | WS_VSCROLL | WS_TABSTOP
    AUTOCHECKBOX "&pemisah", chx1, 5, 45, 90, 15
    DEFPUSHBUTTON "OK", IDOK, 45, 70, 60, 15
    PUSHBUTTON "Batal", IDCANCEL, 110, 70, 60, 15
}

IDD_MODIFYTBBTN DIALOG 0, 0, 177, 92
CAPTION "Ubah tombol Toolbar"
STYLE DS_CENTER | DS_MODALFRAME | WS_POPUPWINDOW | WS_CAPTION
FONT 9, "MS Shell Dlg"
{
    LTEXT "&ID Perintah tombol Toolbar:", -1, 5, 5, 160, 15, SS_CENTERIMAGE | NOT WS_GROUP
    COMBOBOX cmb1, 5, 25, 150, 150, CBS_HASSTRINGS | CBS_AUTOHSCROLL | CBS_DROPDOWN | WS_VSCROLL | WS_TABSTOP
    AUTOCHECKBOX "&pemisah", chx1, 5, 45, 90, 15
    DEFPUSHBUTTON "OK", IDOK, 45, 70, 60, 15
    PUSHBUTTON "Batal", IDCANCEL, 110, 70, 60, 15
}

//////////////////////////////////////////////////////////////////////////////
// RT_VERSION

1 VERSIONINFO
FILEVERSION     5, 7, 9, 0
PRODUCTVERSION  5, 7, 9, 0
FILEOS          0x40004
FILETYPE        0x1
FILESUBTYPE     0x0
{
    BLOCK "StringFileInfo"
    {
        BLOCK "042104B0"
        {
            VALUE "CompanyName", "Katayama Hirofumi MZ\0"
            VALUE "FileDescription", "RisohEditor\0"
            VALUE "FileVersion", "5.7.9\0"
            VALUE "LegalCopyright", "Hak cipta (C) 2017-2020 Katayama Hirofumi MZ and Mas Ahmad Muhammad. Hak cipta dilindungi.\0"
            VALUE "ProductName", "RisohEditor\0"
            VALUE "ProductVersion", "5.7.9\0"
        }
    }
    BLOCK "VarFileInfo"
    {
        VALUE "Translation", 0x0421, 0x04B0
    }
}

//////////////////////////////////////////////////////////////////////////////
// RISOHTEMPLATE

4 RISOHTEMPLATE "res/1057_RISOHTEMPLATE_4.bin"

5 RISOHTEMPLATE "res/1057_RISOHTEMPLATE_5.bin"

//////////////////////////////////////////////////////////////////////////////
// RT_STRING

STRINGTABLE
{
    IDS_APPNAME, "RisohEditor 5.7.9 oleh Katayama Hirofumi MZ"
    IDS_TITLEWITHFILE, "RisohEditor 5.7.9 - Berkas: %s"
    IDS_EXTRACTRES, "Ekstrak Sumber Daya"
    IDS_RESBINFILTER, "Sumber Daya Binary (*.res)|*.res|Berkas Binary (*.bin)|*.bin|Semua Berkas (*.*)|*.*|"
    IDS_CANNOTSAVE, "Tidak bisa disimpan."
    IDS_REPLACERES, "Ganti Sumber Daya"
    IDS_ALLFILES, "Semua Berkas (*.*)|*.*|"
    IDS_ENTERTYPE, "Mohon masukkan jenis sumber daya."
    IDS_ENTERNAME, "Mohon masukkan nama sumber daya."
    IDS_ENTERLANG, "Mohon masukkan bahasa sumber daya."
    IDS_FILENOTFOUND, "Berkas tidak bisa ditemukan."
    IDS_CANNOTREPLACE, "Tidak bisa mengganti."
    IDS_EXERESFILTER, "Eksekutabel (*.exe;*.dll;*.ocx;*.cpl;*.scr;*.mui)|*.exe;*.dll;*.ocx;*.cpl;*.scr;*.mui|Berkas RC (*.rc)|*.rc|Sumber Daya Binary (*.res)|*.res|Semua Berkas (*.*)|*.*|"
    IDS_SAVEAS, "Simpan Sebagai"
    IDS_CANNOTADDICON, "Tidak bisa menambahkan ikon."
    IDS_ADDICON, "Tambah ikon"
    IDS_ICOFILTER, "Berkas Ikon (*.ico)|*.ico|Semua Berkas (*.*)|*.*|"
    IDS_REPLACEICO, "Ganti Ikon"
    IDS_CANTREPLACEICO, "Tidak bisa mengganti ikon."
    IDS_EXISTSOVERWRITE, "Item telah tersedia. Timpa?"
    IDS_OPEN, "Buka"
    IDS_CANNOTOPEN, "Tidak bisa membuka berkas."
    IDS_ADDBMP, "Tambah Bitmap"
    IDS_BMPFILTER, "Berkas Bitmap (*.bmp)|*.bmp|Citra PNG (*.png)|*.png|Semua Berkas (*.*)|*.*|"
    IDS_CANTREPLACEBMP, "Tidak bisa mengganti bitmap."
    IDS_REPLACEBMP, "Ganti Bitmap"
    IDS_ERRORCODE, "Kode kesalahan %d"
    IDS_VERSIONINFO, "RisohEditor Versi 5.7.9\r\n\r\nKatayama Hirofumi MZ\r\n\r\nLisensi: GPLv3 (free software)"
    IDS_ADDRES, "Tambah Sumber Daya"
    IDS_CANNOTADDRES, "Tidak bisa menambahkan sumber daya."
    IDS_CANTADDBMP, "Tidak bisa menambahkan bitmap."
    IDS_EXTRACTBMP, "Ekstrak Bitmap"
    IDS_CANTEXTRACTBMP, "tidak bisa mengekstrak bitmap."
    IDS_CANTREPLACECUR, "Tidak bisa mengganti kursor."
    IDS_CANNOTADDCUR, "Tidak bisa menambahkan kursor."
    IDS_CURFILTER, "Berkas Kursor (*.cur)|*.cur|Kursor Animasi (*.ani)|*.ani|Semua Berkas (*.*)|*.*|"
    IDS_ADDCUR, "Tambah Kursor"
    IDS_REPLACECUR, "Ganti Kursor"
    IDS_EXTRACTICO, "Ekstrak Ikon"
    IDS_CANTEXTRACTICO, "Tidak bisa mengekstrak ikon."
    IDS_EXTRACTCUR, "Ekstrak Kursor"
    IDS_CANTEXTRACTCUR, "Tidak bisa mengekstrak kursor."
    IDS_RESFILTER, "Sumber Daya Binary (*.res)|*.res|Semua Berkas (*.*)|*.*|"
    IDS_NEUTRAL, "Netral"
    IDS_IMPORTRES, "Impor"
    IDS_CANNOTIMPORT, "Tidak bisa mengimpor sumber daya."
    IDS_COMPILE, "Susun (F8)"
    IDS_CANCELEDIT, "Batal Edit (Ctrl+E)"
    IDS_GUIEDIT, "Edit dengan GUI (Ctrl+G)"
    IDS_CANNOTSTARTUP, "Tidak bisa memulai penyusun sumber daya."
    IDS_RESMISMATCH, "Sumber daya tidak cocok."
    IDS_SAMPLETEXT, "Ini adalah contoh."
    IDS_ALREADYEXISTS, "Telah tersedia."
    IDS_KEY, "Tombol"
    IDS_FLAGS, "Flag"
    IDS_COMMANDID, "ID Perintah"
    IDS_INVALIDKEY, "Tombol tidak sah."
    IDS_COMPILEERROR, "Gagal menyusun."
    IDS_STRINGID, "ID String"
    IDS_STRINGVALUE, "Nilai String"
    IDS_CAPTION, "Judul"
    IDS_HELPID, "ID Bantuan"
    IDS_INDENT, "» "
    IDS_DATAISEMPTY, "Data kosong."
    IDS_TEST, "Lakukan Tes"
    IDS_SEPARATOR, "---"
    IDS_COMPILENOW, "Data telah diubah. Susun sekarang?"
    IDS_RADWINDOW, "Edit Dialog"
    IDS_ENTERCLASS, "Mohon masukkan nama kelas jendela yang sah."
    IDS_TEXTEDIT, "Edit dengan Teks (Ctrl+T)"
    IDS_CURSORINFO, "Citra #%u: Lebar %u, Tinggi %u, BitCount %u, xHotSpot %u, yHotSpot %u, ID %u\r\n"
    IDS_IMAGECOUNT, "ImageCount: %u\r\n"
    IDS_ICONINFO, "Citra #%u: Lebar %u, Tinggi %u, BitCount %u, ID %u\r\n"
    IDS_READY, "Siap"
    IDS_EXECUTINGCMD, "Melaksanakan perintah..."
    IDS_EDITINGBYGUI, "Mengedit dengan GUI..."
    IDS_COORD, "%d, %d, %d, %d"
    IDS_STARTING, "Memulai..."
    IDS_COMPILING, "Menyusun..."
    IDS_CANNOTLOAD, "Tidak bisa memuat."
    IDS_NONE, "(Tidak ada)"
    IDS_WAVESOUND, "(Suara WAVE)\r\n"
    IDS_IDTYPE, "Jenis ID"
    IDS_IDPREFIX, "Prefiks ID"
    IDS_EMPTYSTR, "Mohon masukkan string."
    IDS_ANICURSOR, "(Kursor Animasi)\r\n"
    IDS_ANIICON, "(Ikon Animasi)\r\n"
    IDS_HEADFILTER, "Berkas Header (*.h)|*.h|Semua Berkas (*.*)|*.*|"
    IDS_LOADRESH, "Muat Berkas ""resource.h"""
    IDS_NAME, "Nama"
    IDS_VALUE, "Nilai"
    IDS_NOSUCHID, "Tidak ada ID yang ditemukan."
    IDS_IMAGEINFO, "Lebar %u, Tinggi %u, BitsPixel %u\r\n"
    IDS_ENTERINT, "Mohon masukkan integer yang sah."
    IDS_ENTERTEXT, "Mohon masukkan teks yang sah."
    IDS_ENTERID, "Mohon masukkan ID yang sah."
    IDS_ADDNEXTIDS, "Mohon masukkan ID berikut ke ""resource.h"":\r\n\r\n"
    IDS_DELETENEXTIDS, "Mohon hapus ID berikut dari ""resource.h"":\r\n\r\n"
    IDS_NOCHANGE, "Tidak ada perubahan dari ID Sumber Daya."
    IDS_DLGFAIL, "Oops, Saya gagal membuat dialog RAD."
    IDS_LOADWCLIB, "Muat Perpustakaan Kelas Jendela"
    IDS_AVIMOVIE, "(Film AVI)\r\n"
    IDS_ADDDIALOG, "Tambah Dialog"
    IDS_ADDMENU, "Tambah Menu"
    IDS_ADDVERINFO, "Tambah Informasi Versi"
    IDS_ADDCURSOR, "Tambah Kursor"
    IDS_NOMOREITEM, "Tidak ada item lagi."
    IDS_INVALIDDATA, "(data tidak sah)\r\n"
    IDS_UPDATERESH, "Perbarui ""resource.h""?"
    IDS_CANTWRITERESH, "Tidak bisa menulis ""resource.h""."
    IDS_SAVERESH, "Simpan Berkas ""resource.h"""
    IDS_DLLFILTER, "Berkas DLL (*.dll;*.ocx;*.mui)|*.dll;*.ocx;*.mui|Semua Berkas (*.*)|*.*|"
    IDS_EXERESRCFILTER, "Berkas yang Bisa Dimuat (*.exe;*.dll;*.ocx;*.cpl;*.scr;*.mui;*.res;*.rc)|*.exe;*.dll;*.ocx;*.cpl;*.scr;*.mui;*.res;*.rc|Bisa Dieksekusi (*.exe;*.dll;*.ocx;*.cpl;*.scr;*.mui)|*.exe;*.dll;*.ocx;*.cpl;*.scr;*.mui|Sumber Daya Binary (*.res)|*.res|Berkas Sumber Daya (*.rc)|*.rc|Semua Berkas (*.*)|*.*|"
    IDS_CANTTESTCHILDWND, "Tidak dapat menguji dialog karena ini adalah anak jendela."
    IDS_CANTTESTCLASSDLG, "Tidak dapat menguji dialog karena telah digolongkan."
    IDS_FILEISUPXED, "Berkas\r\n\r\n'%s'\r\n\r\nterkompresi oleh UPX. Apakah anda ingin mengekstraknya melalui berkas sementara?\r\n\r\nJika anda tidak memperluasnya, berkas mungkin akan gagal terbaca."
    IDS_CANTUPXEXTRACT, "Tidak bisa mengekstrak dengan UPX."
    IDS_CANTSAVEUPXED, "Tidak bisa menyimpan berkas karena berupa berkas kompres oleh UPX."
    IDS_MESSAGEID, "ID Pesan"
    IDS_MESSAGEVALUE, "Nilai Pesan"
    IDS_RCFILTER, "Berkas RC (*.rc)|*.rc|"
    IDS_EXPORT, "Ekspor"
    IDS_CANTEXPORT, "Ekspor gagal."
    IDS_MUSTBEEMPTYDIR, "Jika terdapat beberapa file eksternal, maka tujuan ekspor harus berupa folder kosong."
    IDS_FULLWIDTH, "０１２３４５６７８９ＡＢＣＤＥＦＧＨＩＪＫＬＭＮＯＰＱＲＳＴＵＶＷＸＹＺａｂｃｄｅｆｇｈｉｊｋｌｍｎｏｐｑｒｓｔｕｖｗｘｙｚ－＿（）．　"
    IDS_HALFWIDTH, "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz-_(). "
    IDS_MACRONAME, "Nama Makro"
    IDS_MACROVALUE, "Nilai Makro"
    IDS_OPTIONAL, "(Opsional)"
    IDS_ADDINCLUDE, "Tambah Pemasukan Direktori"
    IDS_EDITINCLUDE, "Edit Pemasukan Direktori"
    IDS_WINDRESEXE, "windres.exe|windres.exe|"
    IDS_CPPEXE, "cpp.exe|cpp.exe|"
    IDS_INVALIDPATH, "Jalur tidak sah."
    IDS_DATATOOLONG, "Data terlalu panjang."
    IDS_ALL, "(Semua)"
    IDS_UNKNOWNFORMAT, "(Format Data Tidak DIketahui)\r\n"
    IDS_LANGUAGE, "Bahasa"
    IDS_INTVALUE, "Nilai Integer"
    IDS_PARENTWND, "Jendela Tes Induk"
    IDS_CHOOSE_OLE_CLSID, "Pilih OLE CLSID"
    IDS_CONTROL, "Control"
    IDS_MESSAGE, "Pesan"
    IDS_STRING, "String"
    IDS_DATAISINVALID, "Data tidak sah."
    IDS_DLGINIT1, "Anda bisa menentukan inisialisasi kotak kombo dan kotak daftar dengan mengatur data inisialisasi dalam data sumber daya RT_DLGINIT dengan nama yang sama pada sumber daya dialog. "
    IDS_DLGINIT2, "Ketika pesan WM_INITDIALOG muncul, aplikasi bisa memulai dialog dengan memanggil fungsi ExecuteDlgInitDx dari berkas yang terlampir ""DlgInit/DlgInit.h"".\r\n\r\n"
    IDS_DLGINIT3, "Mohon tentukan daftar strings karakter yang dipisah oleh line break untuk RT_DLGINIT."
    IDS_SAMELANG, "Ini adalah bahasa yang sama."
    IDS_SAMENAME, "Ini adalah sumber daya yang sama."
    IDS_CANTSAVETOEXE, "Tidak bisa menyimpan EXE dari berkas yang tidak bisa dieksekusi."
    IDS_CANTSTARTSEARCH, "Tidak bisa memulai pencarian."
    IDS_AMERICA, "Amerika"
    IDS_ENGLISH, "Inggris"
    IDS_CHINA, "China"
    IDS_CHINESE, "China"
    IDS_RUSSIA, "Rusia"
    IDS_RUSSIAN, "Rusia"
    IDS_WANNAGENRESH, "Anda ingin membuat 'resource.h'?"
    IDS_EXEFILTER, "Bisa Dieksekusi (*.exe;*.dll;*.ocx;*.cpl;*.scr;*.mui)|*.exe;*.dll;*.ocx;*.cpl;*.scr;*.mui|Semua Berkas (*.*)|*.*|"
    IDS_SAVEASCOMPRESS, "Simpan Dengan Kompresi"
    IDS_TOOL_NEW, "Baru"
    IDS_TOOL_OPEN, "Buka..."
    IDS_TOOL_SAVE, "Simpan Sebagai..."
    IDS_TOOL_EXPAND, "Perluas Semua"
    IDS_TOOL_COLLAPSE, "Ciutkan Semua"
    IDS_TOOL_PLUS, "Tambah Item..."
    IDS_TOOL_MINUS, "Hapus Item"
    IDS_TOOL_CHANGE, "Ubah Nama/Bahasa"
    IDS_TOOL_CLONE, "Duplikat dalam Nama/Bahasa Lain"
    IDS_TOOL_RECOMPILE, "Susun kembali"
    IDS_TOOL_CANCELEDIT, "Batal Edit"
    IDS_TOOL_IMPORT, "Impor..."
    IDS_TOOL_EXTRACT, "Ekstrak..."
    IDS_TOOL_GUIEDIT, "Edit dengan GUI"
    IDS_UNITEDKINGDOM, "United Kingdom"
    IDS_GREATBRITAIN, "Britain Raya"
    IDS_BRITISH, "Britis"
    IDS_FRANCE, "Prancis"
    IDS_FRENCH, "Prancis"
    IDS_GERMANY, "Jerman"
    IDS_GERMAN, "Jerman"
    IDS_SPAIN, "Spanyol"
    IDS_SPANISH, "Spanyol"
    IDS_INVALIDLANG, "Bahasa tidak dikenal."
    IDS_INVALIDNAME, "Nama sumber daya tidak sah."
    IDS_PNGRESBINFILTER, "Citra PNG (*.png)|*.png|Sumber Daya Binary (*.res)|*.res|Berkas Binary (*.bin)|*.bin|Semua Berkas (*.*)|*.*|"
    IDS_JPEGRESBINFILTER, "Citra JPEG (*.jpg;*.jpeg;*.jpe;*.jfif)|*.jpg;*.jpeg;*.jpe;*.jfif|Sumber Daya Binary (*.res)|*.res|Berkas Binary (*.bin)|*.bin|Semua Berkas (*.*)|*.*|"
    IDS_GIFRESBINFILTER, "Citra GIF (*.gif)|*.gif|Sumber Daya Binary (*.res)|*.res|Berkas Binary (*.bin)|*.bin|Semua Berkas (*.*)|*.*|"
    IDS_TIFFRESBINFILTER, "Citra TIFF (*.tif;*.tiff)|*.tif;*.tiff|Sumber Daya Binary (*.res)|*.res|Berkas Binary (*.bin)|*.bin|Semua Berkas (*.*)|*.*|"
    IDS_AVIRESBINFILTER, "Film AVI (*.avi)|*.avi|Sumber Daya Binary (*.res)|*.res|Berkas Binary (*.bin)|*.bin|Semua Berkas (*.*)|*.*|"
    IDS_WAVERESBINFILTER, "Suara WAVE (*.wav)|*.wav|Sumber Daya Binary (*.res)|*.res|Berkas Binary (*.bin)|*.bin|Semua Berkas (*.*)|*.*|"
    IDS_COMMENT_SEP, "//////////////////////////////////////////////////////////////////////////////\r\n\r\n"
    IDS_NEWLINE, "\r\n"
    IDS_NOTICE, "// Berkas ini secara otomatis dibuat oleh RisohEditor 5.7.9.\r\n"
    IDS_DAGGER, "// † <-- Salib ini membantu mendeteksi UTF-8.\r\n"
    IDS_IMPORTFILTER, "Berkas yang bisa diimpor|*.rc;*.res;*.dfm;*.html;*.htm;*.manifest;*.ico;*.cur;*.ani;*.wav;*.bmp;*.dib;*.png;*.gif;*.jpg;*.jpeg;*.jpe;*.jfif;*.tif;*.tiff;*.avi;*.wmf;*.emf|Berkas RC (*.rc)|*.rc|Sumber Daya Binary (*.res)|*.res|Berkas Citra|*.bmp;*.dib;*.png;*.gif;*.jpg;*.jpeg;*.jpe;*.jfif;*.tif;*.tiff;*.wmf;*.emf;*.tlb|Berkas Kursor (*.cur;*.ani)|*.cur;*.ani|Berkas Ikon (*.ico)|*.ico|Berkas Suara WAVE (*.wav)|*.wav|Berkas HTML (*.html;*.htm)|*.html;*.htm|Berkas Manifest (*.manifest)|*.manifest|Berkas Delphi DFM (*.dfm)|*.dfm|TYPELIB Files (*.tlb)|*.tlb|Semua Berkas (*.*)|*.*|"
    IDS_CANTWRITEBYLOCK, "Tidak bisa menulis berkas karena berkas tersebut terkunci.\r\n\r\n%s"
    IDS_ANSI, "ANSI"
    IDS_WIDE, "Unikode"
    IDS_UTF8, "UTF-8 (Dengan BOM)"
    IDS_UTF8N, "UTF-8 (Tanpa BOM)"
    IDS_SJIS, "Shift_JIS"
    IDS_BINARY, "(binary data)"
    IDS_RESTYPE, "Jenis Sumber Daya"
    IDS_ENCODING, "Enkoding"
    IDS_INVALIDRESTYPE, "Jenis sumber daya tidak sah."
    IDS_PATHSPACEERROR, "Anda memasang dengan salah pada lokasi dengan karakter spasi! Pensuyun sumber daya tidak menerima spasi.\nMohon hindari ""C:\\Program Files""."
    IDS_LOADEGAPROGRAM, "Muat Program EGA..."
    IDS_EGAFILTER, "Program EGA (*.ega)|*.ega|Semua Berkas (*.*)|*.*|"
    IDS_QUERYSAVECHANGE, "Berkas telah diubah. Anda ingin menyimpan perubahannya sekarang?"
    IDS_DFMFILTER, "Berkas DFM (*.dfm)|*.dfm|Berkas Teks (*.txt)|*.txt|Semua Berkas (*.*)|*.*|"
    IDS_CANTEXTRACTDFM, "Tidak bisa mengekstrak data DFM."
    IDS_EXTRACTDFM, "Ekstrak data DFM"
    IDS_ENTERNONZERONAME, "Mohon masukkan nama sumber daya non-zero."
    IDS_ENTERNONZEROTYPE, "Mohon masukkan jenis sumber daya non-zero."
    IDS_HOMEPAGE, "https://katahiromz.web.fc2.com/re/en/"
    IDS_FILESAVED, "Berkas tersimpan."
    IDS_RECOMPILEOK, "Penyusunan kembali selesai."
    IDS_RECOMPILEFAILED, "Penyusunan kembali gagal (kesalahan syntax)."
    IDS_TOOL_EXPORT, "Ekspor..."
    IDS_CODEEDITOR, "Editor Kode"
    IDS_HEXVIEWER, "Penampil Hex"
    IDS_INTEGERORIDENTIFIER, "(integer atau identifier)"
    IDS_NOTEXT, " "
    IDS_NOUPDATE, "Anda menggunakan RisohEditor terbaru."
    IDS_THEREISUPDATE, "RisohEditor %s tersedia. Unduh sekarang?"
    IDS_CANTCHECKUPDATE, "Gagal mengecek pembaruan RisohEditor."
    IDS_CODEPAGE1252, "1252 (Latin 1)"
    IDS_CODEPAGE1250, "1250 (Latin 2)"
    IDS_CODEPAGE1251, "1251 (Krilik)"
    IDS_CODEPAGE1253, "1253 (Yunani)"
    IDS_CODEPAGE1254, "1254 (Turki)"
    IDS_CODEPAGE1255, "1255 (Ibrani)"
    IDS_CODEPAGE1256, "1256 (Arabik)"
    IDS_CODEPAGE1257, "1257 (Baltik)"
    IDS_CODEPAGE874, "874 (Thai)"
    IDS_CODEPAGE932, "932 (Jepang)"
    IDS_CODEPAGE936, "936 (Mandarin Sederhana)"
    IDS_CODEPAGE949, "949 (Korea)"
    IDS_CODEPAGE950, "950 (Mandarin Tradisional)"
    IDS_CODEPAGE65001, "65001 (UTF-8)"
    IDS_EXTRACTTLB, "Ekstrak data TYPELIB"
    IDS_CANTEXTRACTTLB, "Tidak bisa mengekstrak data TYPELIB."
    IDS_TLBRESBINFILTER, "Data TYPELIB (*.tlb)|*.tlb|Sumber Daya Biner (*.res)|*.res|Berkas Teks (*.txt)|*.txt|Berkas MIDL (*.idl)|*.idl|All Files (*.*)|*.*|"
    IDS_USAGE, "Penggunaan: RisohEditor [pilihan | ""file""]\n\nOptions:\n--help  Show this message.\n--version  Show version info.\n--load ""your-file.rc""  Load the file (without GUI)\n--save ""your-file.res""  Save the file (without GUI)\n--log-file ""log-file.txt""  Specify the log file.\n--load-options OPTIONS  Set load options.\n--save-options OPTIONS  Set save options.\n\nLoad options: (no-load-res-h)\nSave options: (idc-static)(compress)(sep-lang)(no-res-folder)(lang-macro)(less-comments)(wrap-manifest)(begin-end)(utf-16)(backup)(ms-msgtbl)"
    IDS_NOSELECTION, "Tidak ada pilihan."
    IDS_TRANSLATORS, "[Translators]\r\nEnglish: Katayama Hirofumi MZ\r\nFinnish: Veikko Muurikainen\r\nIndonesian: Mas Ahmad Muhammad\r\nItalian: R.B.\r\nJapanese: Katayama Hirofumi MZ\r\nKorean: VenusGirl (비너스걸)\r\nPolish: Piotr Hetnarowicz\r\nPortuguese: JNylson\r\nRussian: Dmitry Yerokhin\r\nSimplified Chinese: 林鸿湘\r\n"
}

//////////////////////////////////////////////////////////////////////////////

```

`src/lang/it_IT.rc`:

```rc
// This file is automatically generated by RisohEditor 5.7.9.
// † <-- This dagger helps UTF-8 detection.

#pragma code_page(65001) // UTF-8

LANGUAGE LANG_ITALIAN, SUBLANG_DEFAULT

//////////////////////////////////////////////////////////////////////////////
// RT_MENU

IDR_MAINMENU MENU
{
    POPUP "&File"
    {
        MENUITEM "&Nuovo\tCtrl+N", ID_NEW
        MENUITEM SEPARATOR
        MENUITEM "&Apri...\tCtrl+O", ID_OPEN
        MENUITEM "&Salva...\tCtrl+S", ID_SAVE
        MENUITEM "Salva &come...\tShift+Ctrl+S", ID_SAVEAS
        MENUITEM "Salva con co&mpressione...", ID_SAVEASCOMPRESS
        MENUITEM SEPARATOR
        MENUITEM "&Importa...\tCtrl+I", ID_IMPORT
        MENUITEM "&Esporta...\tCtrl+P", ID_EXPORT
        MENUITEM SEPARATOR
        MENUITEM "Ricarica &resource.h...\tCtrl+R", ID_LOADRESH
        MENUITEM "Salva re&source.h...", ID_UPDATERESHBANG
        MENUITEM "A&vviso modifica resource.h...", ID_ADVICERESH
        MENUITEM "Annulla modifiche re&source.h", ID_UNLOADRESH
        MENUITEM SEPARATOR
        MENUITEM "Carica libreria classe &Window...", ID_LOADWCLIB
        MENUITEM SEPARATOR
        POPUP "File usati recentemente"
        {
            MENUITEM "(None)", -1, GRAYED
        }
        MENUITEM SEPARATOR
        MENUITEM "E&sci\tAlt+F4", ID_EXIT
    }
    POPUP "&Modifica"
    {
        MENUITEM "Modifica via &GUI...\tCtrl+G", ID_GUIEDIT
        MENUITEM SEPARATOR
        POPUP "&Aggiungi"
        {
            MENUITEM "Aggiungi &icona...", ID_ADDICON
            MENUITEM "Aggiungi &cursore..", ID_ADDCURSOR
            MENUITEM "Aggiungi &bitmap...", ID_ADDBITMAP
            MENUITEM "Aggiungi &finestra di dialogo...", ID_ADDDIALOG
            MENUITEM "Aggiungi &menu...", ID_ADDMENU
            MENUITEM "Aggiungi tabella &stringhe...", ID_ADDSTRINGTABLE
            MENUITEM "Aggiungi tabella m&essaggi...", ID_ADDMESSAGETABLE
            MENUITEM "Aggiungi &HTML...", ID_ADDHTML
            MENUITEM "Aggiungi &acceleratori...", ID_ADDACCEL
            MENUITEM "Aggiungi info &versione...", ID_ADDVERINFO
            MENUITEM "Aggiungi info mani&fest...", ID_ADDMANIFEST
            MENUITEM "Aggiungi barra s&trumenti...", ID_ADDTOOLBAR
            MENUITEM "Aggiungi &risorsa...", ID_ADDRES
        }
        POPUP "&Sostituisci"
        {
            MENUITEM "Sostituisci &icona...", ID_REPLACEICON
            MENUITEM "Sostituisci &cursore...", ID_REPLACECURSOR
            MENUITEM "Sostituisci &bitmap...", ID_REPLACEBITMAP
            MENUITEM "Sostituisci &risorsa binaria...", ID_REPLACEBIN
        }
        POPUP "&Estrai"
        {
            MENUITEM "Estrai &icona...", ID_EXTRACTICON
            MENUITEM "Estrai &cursore...", ID_EXTRACTCURSOR
            MENUITEM "Estrai &bitmap...", ID_EXTRACTBITMAP
            MENUITEM "Estr&ai come file .RC...", ID_EXTRACTRC
            MENUITEM "Estrai &risorsa binaria...", ID_EXTRACTBIN
        }
        MENUITEM SEPARATOR
        MENUITEM "&Modifica nome/Lingua\tF2", ID_EDITLABEL
        MENUITEM SEPARATOR
        MENUITEM "Clona con &nuovo nome...", ID_COPYASNEWNAME
        MENUITEM "Clona con nuova &lingua...", ID_COPYASNEWLANG
        MENUITEM "Copia in più lingue...", ID_COPYTOMULTILANG
        MENUITEM SEPARATOR
        MENUITEM "Effettua &test", ID_TEST
        MENUITEM SEPARATOR
        MENUITEM "&Elimina\tCanc", ID_DELETERES
        MENUITEM SEPARATOR
        MENUITEM "Associazione &ID...", ID_IDASSOC
        MENUITEM "&Macro predefinite...", ID_PREDEFMACROS
        MENUITEM "Impostazioni &font...", ID_FONTS
        MENUITEM "Impostazioni &percorsi...", ID_SETPATHS
        MENUITEM SEPARATOR
        MENUITEM "&UI Language Select (UI语言选择)...", ID_CHOOSEUILANG
        MENUITEM SEPARATOR
        MENUITEM "Impostazioni DFM &Delphi...", ID_DFMSETTINGS
        MENUITEM "&Impostazioni...", ID_CONFIG
    }
    POPUP "&Cerca"
    {
        MENUITEM "&Cerca...\tCtrl+F", ID_FIND
        MENUITEM SEPARATOR
        MENUITEM "Cerca &precedente\tShift+F3", ID_FINDUPWARD
        MENUITEM "Cerca &successivo\tF3", ID_FINDDOWNWARD
        MENUITEM SEPARATOR
        MENUITEM "Cerca &costante...", ID_QUERYCONSTANT
    }
    POPUP "&Visualizza"
    {
        MENUITEM "Barra &stato", ID_STATUSBAR
        MENUITEM "Barra &strumenti", ID_SHOWHIDETOOLBAR
        MENUITEM "&Binario", ID_BINARYPANE
        MENUITEM SEPARATOR
        MENUITEM "E&spandi tutto\tCtrl+K", ID_EXPAND_ALL
        MENUITEM "&Riduci tutto\tCtrl+L", ID_COLLAPSE_ALL
        MENUITEM SEPARATOR
        MENUITEM "Elenco ID &risorse", ID_IDLIST
        MENUITEM "Elenco &lingue...", ID_SHOWLANGS
        MENUITEM SEPARATOR
        MENUITEM "Sempre comando &CONTROL", ID_ALWAYSCONTROL
        MENUITEM "Non usare &ID macro", ID_HIDEIDMACROS
        MENUITEM "Usa IDC_ST&ATIC", ID_USEIDC_STATIC
        MENUITEM "A capo a&utomatico", ID_WORD_WRAP
        MENUITEM "Usa BE&GIN/END", ID_USEBEGINEND
        MENUITEM "Usa &tabella messaggi Microsoft", ID_USEMSMSGTBL
        MENUITEM SEPARATOR
        MENUITEM "Codifica &elementi risorse...", ID_ENCODING
        MENUITEM "Sostituzione &font finestra...", ID_DIALOG_FONT_SUBSTITUTES
        MENUITEM SEPARATOR
        MENUITEM "A&ggiorna", ID_REFRESHALL
    }
    POPUP "&Automazione"
    {
        MENUITEM "Linguaggio programmazione &EGA...", ID_EGA
        MENUITEM "Esegui p&rogramma EGA...", ID_EGA_PROGRAM
        MENUITEM "Apri &manuale EGA", ID_OPEN_EGA_MANUAL
    }
    POPUP "&?"
    {
        MENUITEM "Apri file Leggimi (i&taliano)", ID_OPENREADMEIT
        MENUITEM "Apri file cronologia programma (italiano)", ID_OPENHISTORYITA
        MENUITEM "Apri file Leggimi (&inglese)", ID_OPENREADME
        MENUITEM SEPARATOR
        MENUITEM "&Guida in linea RisohEditor", ID_GUIDE
        MENUITEM "&Controlla aggiornamenti RisohEditor...", ID_CHECKUPDATE
        MENUITEM SEPARATOR
        MENUITEM "&Info sul programma...", ID_ABOUT
    }
}

IDR_POPUPMENUS MENU
{
    POPUP "Popup #0"
    {
        MENUITEM "Modifica via &GUI...\tCtrl+G", ID_GUIEDIT
        MENUITEM SEPARATOR
        POPUP "&Aggiungi"
        {
            MENUITEM "Aggiungi &icona...", ID_ADDICON
            MENUITEM "Aggiungi &cursore...", ID_ADDCURSOR
            MENUITEM "Aggiungi &bitmap...", ID_ADDBITMAP
            MENUITEM "Aggiungi &finestra di dialogo...", ID_ADDDIALOG
            MENUITEM "Aggiungi &menu...", ID_ADDMENU
            MENUITEM "Aggiungi tabella &stringhe...", ID_ADDSTRINGTABLE
            MENUITEM "Aggiungi tabella m&essaggi...", ID_ADDMESSAGETABLE
            MENUITEM "Aggiungi codice &HTML...", ID_ADDHTML
            MENUITEM "Aggiungi &acceleratori...", ID_ADDACCEL
            MENUITEM "Aggiungi info &versione...", ID_ADDVERINFO
            MENUITEM "Aggiungi info mani&fest...", ID_ADDMANIFEST
            MENUITEM "Aggiungi barra s&trumenti...", ID_ADDTOOLBAR
            MENUITEM "Aggiungi &risorsa...", ID_ADDRES
        }
        POPUP "&Sostituisci"
        {
            MENUITEM "Sostituisci &icona...", ID_REPLACEICON
            MENUITEM "Sostituisci &cursore...", ID_REPLACECURSOR
            MENUITEM "Sostituisci &bitmap...", ID_REPLACEBITMAP
            MENUITEM "Sostituisci &risorsa binaria...", ID_REPLACEBIN
        }
        POPUP "&Estrai"
        {
            MENUITEM "Estrai &icona...", ID_EXTRACTICON
            MENUITEM "Estrai &cursore...", ID_EXTRACTCURSOR
            MENUITEM "Estrai &bitmap...", ID_EXTRACTBITMAP
            MENUITEM "Estr&ai come file .RC...", ID_EXTRACTRC
            MENUITEM "Estrai &risorsa binaria...", ID_EXTRACTBIN
        }
        MENUITEM SEPARATOR
        MENUITEM "&Modifica nome/lingua\tF2", ID_EDITLABEL
        MENUITEM SEPARATOR
        MENUITEM "Clona con nuova &nome...", ID_COPYASNEWNAME
        MENUITEM "Clona in una nuova &lingua...", ID_COPYASNEWLANG
        MENUITEM "Copia in più lingue...", ID_COPYTOMULTILANG
        MENUITEM SEPARATOR
        MENUITEM "Effettua &test", ID_TEST
        MENUITEM SEPARATOR
        MENUITEM "&Elimina\tCanc", ID_DELETERES
    }
    POPUP "Popup #1"
    {
        MENUITEM "&Aggiungi controllo...", ID_ADDCTRL
        MENUITEM SEPARATOR
        MENUITEM "&Taglia\tCtrl+X", ID_CUT
        MENUITEM "&Copia\tCtrl+C", ID_COPY
        MENUITEM "&Incolla\tCtrl+V", ID_PASTE
        MENUITEM "&Elimina\tCanc", ID_DELCTRL
        MENUITEM SEPARATOR
        POPUP "&Indice"
        {
            MENUITEM "Vai all'&inizio", ID_CTRLINDEXTOP
            MENUITEM SEPARATOR
            MENUITEM "&Decrementa indice", ID_CTRLINDEXMINUS
            MENUITEM "&Incrementa indice", ID_CTRLINDEXPLUS
            MENUITEM SEPARATOR
            MENUITEM "Vai alla &fine", ID_CTRLINDEXBOTTOM
            MENUITEM SEPARATOR
            MENUITEM "Visualizza/nascondi indici\tCtrl+D", ID_SHOWHIDEINDEX
        }
        POPUP "&Allineamento"
        {
            MENUITEM "Allinea in &alto", ID_TOPALIGN
            MENUITEM "Allinea in &basso", ID_BOTTOMALIGN
            MENUITEM "Allinea a &sinistra", ID_LEFTALIGN
            MENUITEM "Allinea a &destra", ID_RIGHTALIGN
            MENUITEM SEPARATOR
            MENUITEM "Adatta alla &griglia", ID_FITTOGRID
        }
        MENUITEM SEPARATOR
        MENUITEM "&Aggiorna", ID_REFRESHDIALOG
        MENUITEM SEPARATOR
        MENUITEM "&Proprietà controllo...", ID_CTRLPROP
        MENUITEM "Pr&oprietà finestra...", ID_DLGPROP
    }
    POPUP "Popup #2"
    {
        MENUITEM "&Modifica...", ID_MODIFYASSOC
    }
    POPUP "Popup #3"
    {
        MENUITEM "&Vai a!", ID_IDJUMP
        MENUITEM SEPARATOR
        MENUITEM "&Aggiungi ID...", ID_ADDRESID
        MENUITEM "&Modifica ID...", ID_MODIFYRESID
        MENUITEM SEPARATOR
        MENUITEM "Copia &nome", ID_COPYRESIDNAME
        MENUITEM "Copia &valore", ID_COPYRESIDVALUE
        MENUITEM "Copia &definizione\tCtrl+C", ID_COPYIDDEF
        MENUITEM SEPARATOR
        MENUITEM "&Elimina ID\tCanc", ID_DELETERESID
        MENUITEM SEPARATOR
        MENUITEM "Numeri &decimali", ID_BASE10
        MENUITEM "Numeri &esadecimali", ID_BASE16
        MENUITEM SEPARATOR
        MENUITEM "&Ricarica", ID_LOADRESH
    }
    POPUP "Popup #4"
    {
        MENUITEM "&Aggiungi...", ID_ADD
        MENUITEM SEPARATOR
        MENUITEM "Modifica &nome...\tF2", ID_RENAME
        MENUITEM "Modifica &valore...", ID_MODIFY
        MENUITEM SEPARATOR
        MENUITEM "&Elimina\tCanc", ID_DELETE
    }
    POPUP "Popup #5"
    {
        MENUITEM "&Copia valore intero", ID_COPY
    }
    POPUP "Popup #6"
    {
        MENUITEM "&Aggiungi...", psh1
        MENUITEM "&Modifica...", psh2
        MENUITEM SEPARATOR
        MENUITEM "&Su", psh4
        MENUITEM "&Giù", psh5
        MENUITEM "&Sinistra", psh6
        MENUITEM "&Destra", psh7
        MENUITEM SEPARATOR
        MENUITEM "&Elimina\tCanc", psh3
    }
    POPUP "Popup #7"
    {
        MENUITEM "&Aggiungi...", psh1
        MENUITEM "&Modifica...", psh2
        MENUITEM SEPARATOR
        MENUITEM "&Su", psh4
        MENUITEM "&Giù", psh5
        MENUITEM SEPARATOR
        MENUITEM "&Elimina\tCanc", psh3
    }
    POPUP "Popup #8"
    {
        MENUITEM "&Aggiungi...", ID_ADD
        MENUITEM "&Modifica...", ID_MODIFY
        MENUITEM SEPARATOR
        MENUITEM "&Elimina\tCanc", ID_DELETE
    }
}

//////////////////////////////////////////////////////////////////////////////
// RT_DIALOG

IDD_REPLACERES DIALOGEX 0, 0, 215, 170
CAPTION "Sostituzione risorsa"
STYLE DS_MODALFRAME | WS_POPUPWINDOW | WS_CAPTION
FONT 9, "MS Shell Dlg", 0, 0, 1
{
    LTEXT "&Tipo risorsa:", -1, 5, 7, 70, 12
    COMBOBOX cmb1, 75, 5, 135, 200, CBS_HASSTRINGS | CBS_AUTOHSCROLL | CBS_DROPDOWN | WS_BORDER | WS_VSCROLL | WS_TABSTOP
    LTEXT "&Nome risorsa:", -1, 5, 32, 70, 12
    COMBOBOX cmb2, 75, 30, 135, 200, CBS_HASSTRINGS | CBS_AUTOHSCROLL | CBS_DROPDOWN | WS_DISABLED | WS_BORDER | WS_VSCROLL | WS_TABSTOP
    LTEXT "&Lingua risorsa:", -1, 5, 57, 70, 12
    COMBOBOX cmb3, 75, 55, 135, 200, CBS_HASSTRINGS | CBS_AUTOHSCROLL | CBS_DROPDOWN | WS_DISABLED | WS_BORDER | WS_VSCROLL | WS_TABSTOP
    LTEXT "&File binario:", -1, 5, 85, 100, 12
    EDITTEXT edt1, 5, 97, 205, 14, ES_AUTOHSCROLL
    PUSHBUTTON "&Sfoglia...", psh1, 150, 115, 60, 14
    DEFPUSHBUTTON "OK", IDOK, 35, 150, 60, 14
    PUSHBUTTON "Annulla", IDCANCEL, 115, 150, 60, 14
    {
        0x1234, 0x5678, 0x0011
    }
}

IDD_ADDICON DIALOG 0, 0, 215, 135
CAPTION "Aggiungi icona"
STYLE DS_MODALFRAME | WS_POPUPWINDOW | WS_CAPTION
FONT 9, "MS Shell Dlg"
{
    LTEXT "File &icona:", -1, 5, 7, 100, 12
    EDITTEXT edt1, 5, 18, 205, 14, ES_AUTOHSCROLL
    PUSHBUTTON "&Sfoglia...", psh1, 150, 35, 60, 14
    ICON 0, ico1, 5, 35, 0, 0
    LTEXT "&Nome risorsa:", -1, 5, 67, 70, 12
    COMBOBOX cmb2, 75, 65, 120, 300, CBS_HASSTRINGS | CBS_AUTOHSCROLL | CBS_DROPDOWN | WS_BORDER | WS_VSCROLL | WS_TABSTOP
    PUSHBUTTON "&...", psh2, 195, 65, 15, 14
    LTEXT "&Lingua risorsa:", -1, 5, 92, 70, 12
    COMBOBOX cmb3, 75, 90, 135, 200, CBS_HASSTRINGS | CBS_AUTOHSCROLL | CBS_DROPDOWN | WS_BORDER | WS_VSCROLL | WS_TABSTOP
    DEFPUSHBUTTON "OK", IDOK, 35, 115, 60, 14
    PUSHBUTTON "Annulla", IDCANCEL, 115, 115, 60, 14
}

IDD_REPLACEICON DIALOG 0, 0, 215, 135
CAPTION "Sostituisci icone"
STYLE DS_MODALFRAME | WS_POPUPWINDOW | WS_CAPTION
FONT 9, "MS Shell Dlg"
{
    LTEXT "File &icona:", -1, 5, 7, 100, 12
    EDITTEXT edt1, 5, 18, 205, 14, ES_AUTOHSCROLL
    PUSHBUTTON "&Sfoglia...", psh1, 150, 35, 60, 14
    ICON 0, ico1, 5, 35, 0, 0
    LTEXT "&Nome risorsa:", -1, 5, 67, 70, 12
    COMBOBOX cmb2, 75, 65, 135, 13, CBS_HASSTRINGS | CBS_AUTOHSCROLL | CBS_DROPDOWN | WS_DISABLED | WS_BORDER | WS_VSCROLL | WS_TABSTOP
    LTEXT "&Lingua risorsa:", -1, 5, 92, 70, 12
    COMBOBOX cmb3, 75, 90, 135, 13, CBS_HASSTRINGS | CBS_AUTOHSCROLL | CBS_DROPDOWN | WS_DISABLED | WS_BORDER | WS_VSCROLL | WS_TABSTOP
    DEFPUSHBUTTON "OK", IDOK, 35, 115, 60, 14
    PUSHBUTTON "Annulla", IDCANCEL, 115, 115, 60, 14
}

IDD_ADDBITMAP DIALOG 0, 0, 215, 135
CAPTION "Aggiungi bitmap"
STYLE DS_MODALFRAME | WS_POPUPWINDOW | WS_CAPTION
FONT 9, "MS Shell Dlg"
{
    LTEXT "File &bitmap:", -1, 5, 7, 100, 12
    EDITTEXT edt1, 5, 18, 205, 14, ES_AUTOHSCROLL
    PUSHBUTTON "&Sfoglia...", psh1, 150, 35, 60, 14
    LTEXT "&Nome risorsa:", -1, 5, 67, 70, 12
    COMBOBOX cmb2, 75, 65, 120, 300, CBS_HASSTRINGS | CBS_AUTOHSCROLL | CBS_DROPDOWN | WS_BORDER | WS_VSCROLL | WS_TABSTOP
    PUSHBUTTON "&...", psh2, 195, 65, 15, 14
    LTEXT "&Lingua risorsa:", -1, 5, 92, 70, 12
    COMBOBOX cmb3, 75, 90, 135, 200, CBS_HASSTRINGS | CBS_AUTOHSCROLL | CBS_DROPDOWN | WS_BORDER | WS_VSCROLL | WS_TABSTOP
    DEFPUSHBUTTON "OK", IDOK, 35, 115, 60, 14
    PUSHBUTTON "Annulla", IDCANCEL, 115, 115, 60, 14
}

IDD_REPLACEBMP DIALOG 0, 0, 215, 135
CAPTION "Sostituisci bitmap"
STYLE DS_MODALFRAME | WS_POPUPWINDOW | WS_CAPTION
FONT 9, "MS Shell Dlg"
{
    LTEXT "File &bitmap:", -1, 5, 7, 100, 12
    EDITTEXT edt1, 5, 18, 205, 14, ES_AUTOHSCROLL
    PUSHBUTTON "&Sfoglia...", psh1, 150, 35, 60, 14
    LTEXT "&Nome risorsa:", -1, 5, 67, 70, 12
    COMBOBOX cmb2, 75, 65, 135, 200, CBS_HASSTRINGS | CBS_AUTOHSCROLL | CBS_DROPDOWN | WS_DISABLED | WS_BORDER | WS_VSCROLL | WS_TABSTOP
    LTEXT "&Lingua risorsa:", -1, 5, 92, 70, 12
    COMBOBOX cmb3, 75, 90, 135, 200, CBS_HASSTRINGS | CBS_AUTOHSCROLL | CBS_DROPDOWN | WS_DISABLED | WS_BORDER | WS_VSCROLL | WS_TABSTOP
    DEFPUSHBUTTON "OK", IDOK, 35, 115, 60, 14
    PUSHBUTTON "Annulla", IDCANCEL, 115, 115, 60, 14
}

IDD_ADDRES DIALOG 0, 0, 215, 170
CAPTION "Aggiungi risorsa"
STYLE DS_MODALFRAME | WS_POPUPWINDOW | WS_CAPTION
FONT 9, "MS Shell Dlg"
{
    LTEXT "&Tipo risorsa:", -1, 5, 7, 70, 12
    COMBOBOX cmb1, 75, 5, 135, 200, CBS_HASSTRINGS | CBS_AUTOHSCROLL | CBS_DROPDOWN | WS_BORDER | WS_VSCROLL | WS_TABSTOP
    LTEXT "&Nome risorsa:", -1, 5, 32, 70, 12
    COMBOBOX cmb2, 75, 30, 120, 300, CBS_HASSTRINGS | CBS_AUTOHSCROLL | CBS_DROPDOWN | WS_BORDER | WS_VSCROLL | WS_TABSTOP
    PUSHBUTTON "&...", psh2, 195, 30, 15, 14
    LTEXT "", stc1, 75, 43, 115, 10
    LTEXT "&Lingua risorsa:", -1, 5, 57, 70, 12
    COMBOBOX cmb3, 75, 55, 135, 200, CBS_HASSTRINGS | CBS_AUTOHSCROLL | CBS_DROPDOWN | WS_BORDER | WS_VSCROLL | WS_TABSTOP
    LTEXT "&File binario:", -1, 5, 85, 100, 12
    EDITTEXT edt1, 5, 97, 205, 14, ES_AUTOHSCROLL
    PUSHBUTTON "&Sfoglia...", psh1, 150, 115, 60, 14
    LTEXT "", stc2, 5, 112, 100, 10
    DEFPUSHBUTTON "OK", IDOK, 35, 150, 60, 14
    PUSHBUTTON "Annulla", IDCANCEL, 115, 150, 60, 14
}

IDD_ADDCURSOR DIALOG 0, 0, 215, 135
CAPTION "Aggiungi cursore"
STYLE DS_MODALFRAME | WS_POPUPWINDOW | WS_CAPTION
FONT 9, "MS Shell Dlg"
{
    LTEXT "File &cursore:", -1, 5, 7, 100, 12
    EDITTEXT edt1, 5, 18, 205, 14, ES_AUTOHSCROLL
    PUSHBUTTON "&Sfoglia...", psh1, 150, 35, 60, 14
    ICON 0, ico1, 5, 35, 0, 0
    LTEXT "&Nome risorsa:", -1, 5, 67, 70, 12
    COMBOBOX cmb2, 75, 65, 120, 200, CBS_HASSTRINGS | CBS_AUTOHSCROLL | CBS_DROPDOWN | WS_BORDER | WS_VSCROLL | WS_TABSTOP
    PUSHBUTTON "&...", psh2, 195, 65, 15, 14
    LTEXT "&Lingua risorsa:", -1, 5, 92, 70, 12
    COMBOBOX cmb3, 75, 90, 135, 200, CBS_HASSTRINGS | CBS_AUTOHSCROLL | CBS_DROPDOWN | WS_BORDER | WS_VSCROLL | WS_TABSTOP
    DEFPUSHBUTTON "OK", IDOK, 35, 115, 60, 14
    PUSHBUTTON "Annulla", IDCANCEL, 115, 115, 60, 14
}

IDD_REPLACECUR DIALOG 0, 0, 215, 135
CAPTION "Sostituisci cursore"
STYLE DS_MODALFRAME | WS_POPUPWINDOW | WS_CAPTION
FONT 9, "MS Shell Dlg"
{
    LTEXT "File &cursore:", -1, 5, 7, 100, 12
    EDITTEXT edt1, 5, 18, 205, 14, ES_AUTOHSCROLL
    PUSHBUTTON "&Sfoglia...", psh1, 150, 35, 60, 14
    ICON 0, ico1, 5, 35, 0, 0
    LTEXT "&Nome risorsa:", -1, 5, 67, 70, 12
    COMBOBOX cmb2, 75, 65, 135, 200, CBS_HASSTRINGS | CBS_AUTOHSCROLL | CBS_DROPDOWN | WS_DISABLED | WS_BORDER | WS_VSCROLL | WS_TABSTOP
    LTEXT "&Lingua risorsa:", -1, 5, 92, 70, 12
    COMBOBOX cmb3, 75, 90, 135, 200, CBS_HASSTRINGS | CBS_AUTOHSCROLL | CBS_DROPDOWN | WS_DISABLED | WS_BORDER | WS_VSCROLL | WS_TABSTOP
    DEFPUSHBUTTON "OK", IDOK, 35, 115, 60, 14
    PUSHBUTTON "Annulla", IDCANCEL, 115, 115, 60, 14
}

IDD_MENUTEST DIALOG 0, 0, 215, 135
CAPTION "Menu test"
STYLE DS_MODALFRAME | WS_POPUPWINDOW | WS_CAPTION
FONT 9, "MS Shell Dlg"
{
}

IDD_ADDKEY DIALOG 0, 0, 190, 120
CAPTION "Aggiungi chiave"
STYLE DS_MODALFRAME | WS_POPUPWINDOW | WS_CAPTION
FONT 9, "MS Shell Dlg"
{
    RTEXT "C&hiave:", -1, 5, 12, 60, 14
    COMBOBOX cmb1, 70, 10, 110, 200, CBS_DROPDOWN | WS_BORDER | WS_VSCROLL | WS_TABSTOP
    RTEXT "&ID comando:", -1, 5, 37, 60, 14
    COMBOBOX cmb2, 70, 35, 95, 300, CBS_DROPDOWN | WS_BORDER | WS_VSCROLL | WS_TABSTOP
    PUSHBUTTON "&...", psh1, 165, 35, 15, 14
    AUTOCHECKBOX "&VIRTKEY", chx1, 5, 60, 60, 14
    AUTOCHECKBOX "&NOINVERT", chx2, 70, 60, 60, 14
    AUTOCHECKBOX "&CONTROL", chx3, 5, 75, 60, 14
    AUTOCHECKBOX "&SHIFT", chx4, 70, 75, 60, 14
    AUTOCHECKBOX "&ALT", chx5, 140, 75, 45, 14
    DEFPUSHBUTTON "OK", IDOK, 60, 100, 60, 14
    PUSHBUTTON "Annulla", IDCANCEL, 125, 100, 60, 14
}

IDD_MODIFYKEY DIALOG 0, 0, 190, 120
CAPTION "Modifica chiave"
STYLE DS_MODALFRAME | WS_POPUPWINDOW | WS_CAPTION
FONT 9, "MS Shell Dlg"
{
    RTEXT "C&hiave:", -1, 5, 12, 60, 14
    COMBOBOX cmb1, 70, 10, 110, 200, CBS_DROPDOWN | WS_BORDER | WS_VSCROLL | WS_TABSTOP
    RTEXT "&ID comando:", -1, 5, 37, 60, 14
    COMBOBOX cmb2, 70, 35, 95, 200, CBS_DROPDOWN | WS_BORDER | WS_VSCROLL | WS_TABSTOP
    PUSHBUTTON "&...", psh1, 165, 35, 15, 14
    AUTOCHECKBOX "&VIRTKEY", chx1, 5, 60, 60, 14
    AUTOCHECKBOX "&NOINVERT", chx2, 70, 60, 60, 14
    AUTOCHECKBOX "&CONTROL", chx3, 5, 75, 60, 14
    AUTOCHECKBOX "&SHIFT", chx4, 70, 75, 60, 14
    AUTOCHECKBOX "&ALT", chx5, 140, 75, 45, 14
    DEFPUSHBUTTON "OK", IDOK, 60, 100, 60, 14
    PUSHBUTTON "Annulla", IDCANCEL, 125, 100, 60, 14
}

IDD_EDITACCEL DIALOG 0, 0, 285, 165
CAPTION "Modifica acceleratori"
STYLE WS_POPUPWINDOW | WS_CAPTION | WS_THICKFRAME
FONT 9, "MS Shell Dlg"
{
    LTEXT "E&lenco chiavi:", -1, 5, 7, 100, 12
    CONTROL "", lst1, "SysListView32", LVS_NOSORTHEADER | LVS_AUTOARRANGE | LVS_NOLABELWRAP | LVS_SHOWSELALWAYS | LVS_SINGLESEL | LVS_REPORT | WS_BORDER | WS_VSCROLL | WS_HSCROLL | WS_TABSTOP, 5, 20, 210, 120
    PUSHBUTTON "&Aggiungi...", psh1, 220, 20, 60, 14
    PUSHBUTTON "&Modifica...", psh2, 220, 40, 60, 14
    PUSHBUTTON "&Elimina", psh3, 220, 60, 60, 14
    PUSHBUTTON "&Su", psh4, 220, 100, 60, 14
    PUSHBUTTON "&Giù", psh5, 220, 120, 60, 14
    DEFPUSHBUTTON "OK", IDOK, 155, 145, 60, 14
    PUSHBUTTON "Annulla", IDCANCEL, 220, 145, 60, 14
    PUSHBUTTON "Elimina t&utto", psh6, 5, 145, 79, 14
}

IDD_ADDSTR DIALOG 0, 0, 255, 115
CAPTION "Aggiungi stringa"
STYLE WS_POPUPWINDOW | WS_CAPTION | WS_THICKFRAME
FONT 9, "MS Shell Dlg"
{
    LTEXT "&ID stringa:", -1, 5, 7, 50, 12
    COMBOBOX cmb1, 60, 5, 134, 200, CBS_HASSTRINGS | CBS_AUTOHSCROLL | CBS_DROPDOWN | WS_BORDER | WS_VSCROLL | WS_TABSTOP
    PUSHBUTTON "&...", psh1, 195, 5, 15, 14
    LTEXT "&Valore stringa:", -1, 5, 27, 54, 12
    EDITTEXT edt1, 60, 25, 190, 45, ES_WANTRETURN | ES_AUTOVSCROLL | ES_MULTILINE | WS_VSCROLL
    AUTOCHECKBOX "&Sostituisci '\\r\\n' con '\\n'", chx1, 60, 75, 190, 14
    DEFPUSHBUTTON "OK", IDOK, 125, 95, 60, 14
    PUSHBUTTON "Annulla", IDCANCEL, 190, 95, 60, 14
}

IDD_MODIFYSTR DIALOG 0, 0, 255, 115
CAPTION "Modifica stringa"
STYLE WS_POPUPWINDOW | WS_CAPTION | WS_THICKFRAME
FONT 9, "MS Shell Dlg"
{
    LTEXT "&ID stringa:", -1, 5, 7, 50, 12
    COMBOBOX cmb1, 60, 5, 134, 200, CBS_HASSTRINGS | CBS_AUTOHSCROLL | CBS_DROPDOWN | WS_BORDER | WS_VSCROLL | WS_TABSTOP
    PUSHBUTTON "&...", psh1, 195, 5, 15, 14
    LTEXT "&Valore stringa:", -1, 5, 27, 54, 12
    EDITTEXT edt1, 60, 25, 190, 45, ES_WANTRETURN | ES_AUTOVSCROLL | ES_MULTILINE | WS_VSCROLL
    AUTOCHECKBOX "&Sostituisci '\\r\\n' con '\\n'", chx1, 60, 75, 190, 14
    DEFPUSHBUTTON "OK", IDOK, 125, 95, 60, 14
    PUSHBUTTON "Annulla", IDCANCEL, 190, 95, 60, 14
}

IDD_STRINGS DIALOG 0, 0, 325, 160
CAPTION "Tabella stringhe"
STYLE WS_POPUPWINDOW | WS_CAPTION | WS_THICKFRAME
FONT 9, "MS Shell Dlg"
{
    LTEXT "&Elementi stringa:", -1, 5, 7, 100, 12
    CONTROL "", lst1, "SysListView32", LVS_NOSORTHEADER | LVS_AUTOARRANGE | LVS_NOLABELWRAP | LVS_SHOWSELALWAYS | LVS_SINGLESEL | LVS_REPORT | WS_BORDER | WS_VSCROLL | WS_HSCROLL | WS_TABSTOP, 5, 20, 315, 115
    PUSHBUTTON "&Aggiungi...", psh1, 130, 3, 60, 14
    PUSHBUTTON "&Modifica...", psh2, 195, 3, 60, 14
    PUSHBUTTON "&Elimina", psh3, 260, 3, 60, 14
    DEFPUSHBUTTON "OK", IDOK, 195, 140, 60, 14
    PUSHBUTTON "Annulla", IDCANCEL, 260, 140, 60, 14
    PUSHBUTTON "Elimina t&utto", psh4, 5, 140, 75, 14
}

IDD_ADDMITEM DIALOG 0, 0, 210, 200
CAPTION "Aggiungi elemento menu"
STYLE DS_MODALFRAME | WS_POPUPWINDOW | WS_CAPTION
FONT 9, "MS Shell Dlg"
{
    LTEXT "&Titolo:", -1, 5, 7, 55, 12
    COMBOBOX cmb1, 65, 6, 140, 200, CBS_AUTOHSCROLL | CBS_DROPDOWN | WS_BORDER | WS_VSCROLL | WS_TABSTOP
    LTEXT "ID co&mando:", -1, 5, 32, 55, 12
    COMBOBOX cmb2, 65, 30, 125, 200, CBS_AUTOHSCROLL | CBS_DROPDOWN | WS_BORDER | WS_VSCROLL | WS_TABSTOP
    PUSHBUTTON "&...", psh1, 190, 30, 15, 14
    AUTOCHECKBOX "&GRIGIO", chx1, 5, 60, 60, 14
    AUTOCHECKBOX "&BITMAP", chx3, 135, 60, 60, 14
    AUTOCHECKBOX "&OWNERDRAW", chx4, 5, 80, 65, 14
    AUTOCHECKBOX "&CHECKED", chx5, 75, 80, 60, 14
    AUTOCHECKBOX "SE&PARATORE", chx6, 140, 80, 60, 14
    AUTOCHECKBOX "MENU&BARBREAK", chx7, 5, 100, 75, 14
    AUTOCHECKBOX "MENUB&REAK", chx8, 85, 100, 70, 14
    AUTOCHECKBOX "&DEFAULT", chx9, 5, 120, 60, 14
    AUTOCHECKBOX "&HILITE", chx10, 70, 120, 60, 14
    AUTOCHECKBOX "RADIOCHEC&K", chx11, 135, 120, 60, 14
    AUTOCHECKBOX "RIGH&TORDER", chx12, 5, 139, 60, 14
    AUTOCHECKBOX "RIGHT&JUSTIFY", chx13, 70, 140, 70, 14
    LTEXT "ID &guida:", -1, 5, 162, 45, 12
    COMBOBOX cmb3, 55, 160, 100, 300, CBS_AUTOHSCROLL | CBS_DROPDOWN | WS_BORDER | WS_VSCROLL | WS_TABSTOP
    DEFPUSHBUTTON "OK", IDOK, 80, 180, 60, 14
    PUSHBUTTON "Annulla", IDCANCEL, 145, 180, 60, 14
}

IDD_MODIFYMITEM DIALOG 0, 0, 210, 200
CAPTION "Modifica elemento menu"
STYLE DS_MODALFRAME | WS_POPUPWINDOW | WS_CAPTION
FONT 9, "MS Shell Dlg"
{
    LTEXT "C&aption:", -1, 5, 7, 55, 12
    COMBOBOX cmb1, 65, 6, 140, 200, CBS_AUTOHSCROLL | CBS_DROPDOWN | WS_BORDER | WS_VSCROLL | WS_TABSTOP
    LTEXT "ID co&mando:", -1, 5, 32, 55, 12
    COMBOBOX cmb2, 65, 30, 125, 200, CBS_AUTOHSCROLL | CBS_DROPDOWN | WS_BORDER | WS_VSCROLL | WS_TABSTOP
    PUSHBUTTON "&...", psh1, 190, 30, 15, 14
    AUTOCHECKBOX "&GRIGIO", chx1, 5, 60, 60, 14
    AUTOCHECKBOX "&BITMAP", chx3, 135, 60, 60, 14
    AUTOCHECKBOX "&OWNERDRAW", chx4, 5, 80, 65, 14
    AUTOCHECKBOX "&CHECKED", chx5, 75, 80, 60, 14
    AUTOCHECKBOX "SE&PARATORE", chx6, 140, 80, 60, 14
    AUTOCHECKBOX "MENU&BARBREAK", chx7, 5, 100, 75, 14
    AUTOCHECKBOX "MENUB&REAK", chx8, 85, 100, 70, 14
    AUTOCHECKBOX "&DEFAULT", chx9, 5, 120, 60, 14
    AUTOCHECKBOX "&HILITE", chx10, 70, 120, 60, 14
    AUTOCHECKBOX "RADIOCHEC&K", chx11, 135, 120, 60, 14
    AUTOCHECKBOX "RIGH&TORDER", chx12, 5, 139, 60, 14
    AUTOCHECKBOX "RIGHT&JUSTIFY", chx13, 70, 140, 70, 14
    LTEXT "ID guida:", -1, 5, 162, 45, 12
    COMBOBOX cmb3, 55, 160, 100, 300, CBS_AUTOHSCROLL | CBS_DROPDOWN | WS_BORDER | WS_VSCROLL | WS_TABSTOP
    DEFPUSHBUTTON "OK", IDOK, 80, 180, 60, 14
    PUSHBUTTON "Annulla", IDCANCEL, 145, 180, 60, 14
}

IDD_EDITMENU DIALOG 0, 0, 325, 160
CAPTION "Modifica risorsa menu"
STYLE WS_POPUPWINDOW | WS_CAPTION | WS_THICKFRAME
FONT 9, "MS Shell Dlg"
{
    LTEXT "Ri&sorsa menu:", -1, 5, 7, 85, 12
    CONTROL "", lst1, "SysListView32", LVS_NOSORTHEADER | LVS_AUTOARRANGE | LVS_NOLABELWRAP | LVS_SHOWSELALWAYS | LVS_SINGLESEL | LVS_REPORT | WS_BORDER | WS_VSCROLL | WS_HSCROLL | WS_TABSTOP, 5, 20, 315, 115
    PUSHBUTTON "&Aggiungi...", psh1, 95, 3, 50, 14
    PUSHBUTTON "&Modifica...", psh2, 150, 3, 50, 14
    PUSHBUTTON "&Elimina", psh3, 205, 3, 50, 14
    PUSHBUTTON "S&u", psh4, 5, 140, 40, 14
    PUSHBUTTON "&Giù", psh5, 50, 140, 40, 14
    PUSHBUTTON "&Sinistra", psh6, 95, 140, 40, 14
    PUSHBUTTON "&Destra", psh7, 140, 140, 41, 14
    AUTOCHECKBOX "Es&tesa", chx1, 260, 3, 60, 14
    DEFPUSHBUTTON "OK", IDOK, 195, 140, 60, 14
    PUSHBUTTON "Annulla", IDCANCEL, 260, 140, 60, 14
}

IDD_DLGPROP DIALOG 0, 0, 235, 315
CAPTION "Proprietà finestra"
STYLE DS_MODALFRAME | WS_POPUPWINDOW | WS_CAPTION
FONT 9, "MS Shell Dlg"
{
    LTEXT "&Titolo:", -1, 5, 7, 85, 11
    COMBOBOX cmb1, 5, 20, 225, 300, CBS_HASSTRINGS | CBS_AUTOHSCROLL | CBS_DROPDOWN | WS_BORDER | WS_VSCROLL | WS_TABSTOP
    AUTOCHECKBOX "Finestra &estesa", chx1, 100, 5, 86, 14
    LTEXT "&Sinistra:", -1, 5, 40, 33, 10
    EDITTEXT edt1, 5, 53, 30, 14, ES_NUMBER | ES_RIGHT
    CONTROL "", scr1, "msctls_updown32", UDS_NOTHOUSANDS | UDS_ARROWKEYS | UDS_AUTOBUDDY | UDS_ALIGNRIGHT | UDS_SETBUDDYINT, 23, 53, 12, 20
    LTEXT "&Alto:", -1, 50, 40, 33, 10
    EDITTEXT edt2, 50, 53, 30, 14, ES_NUMBER | ES_RIGHT
    CONTROL "", scr2, "msctls_updown32", UDS_NOTHOUSANDS | UDS_ARROWKEYS | UDS_AUTOBUDDY | UDS_ALIGNRIGHT | UDS_SETBUDDYINT, 53, 53, 12, 20
    LTEXT "&Larghezza:", -1, 95, 40, 33, 10
    EDITTEXT edt3, 95, 53, 30, 14, ES_NUMBER | ES_RIGHT
    CONTROL "", scr3, "msctls_updown32", UDS_NOTHOUSANDS | UDS_ARROWKEYS | UDS_AUTOBUDDY | UDS_ALIGNRIGHT | UDS_SETBUDDYINT, 129, 56, 12, 20
    LTEXT "Alte&zza:", -1, 142, 40, 33, 10
    EDITTEXT edt4, 142, 53, 30, 14, ES_NUMBER | ES_RIGHT
    CONTROL "", scr4, "msctls_updown32", UDS_NOTHOUSANDS | UDS_ARROWKEYS | UDS_AUTOBUDDY | UDS_ALIGNRIGHT | UDS_SETBUDDYINT, 162, 53, 12, 20
    LTEXT "&Nome classe Windows:", -1, 5, 73, 85, 11
    COMBOBOX cmb2, 5, 88, 115, 200, CBS_HASSTRINGS | CBS_AUTOHSCROLL | CBS_DROPDOWN | WS_BORDER | WS_VSCROLL | WS_TABSTOP
    LTEXT "ID G&uida:", -1, 125, 73, 64, 11
    COMBOBOX cmb3, 125, 88, 65, 200, CBS_HASSTRINGS | CBS_AUTOHSCROLL | CBS_DROPDOWN | WS_BORDER | WS_VSCROLL | WS_TABSTOP
    LTEXT "Nome &font:", -1, 5, 105, 80, 11
    COMBOBOX cmb4, 6, 118, 100, 200, CBS_HASSTRINGS | CBS_SORT | CBS_AUTOHSCROLL | CBS_DROPDOWN | WS_BORDER | WS_VSCROLL | WS_TABSTOP
    LTEXT "&Dim.:", -1, 110, 105, 38, 12
    EDITTEXT edt5, 110, 118, 25, 14, ES_NUMBER
    AUTOCHECKBOX "&B", chx2, 140, 118, 20, 14
    AUTOCHECKBOX "&I", chx3, 165, 118, 20, 14
    LTEXT "&Set caratteri:", -1, 5, 138, 80, 11
    COMBOBOX cmb5, 5, 148, 100, 100, CBS_AUTOHSCROLL | CBS_DROPDOWNLIST | WS_VSCROLL | WS_TABSTOP
    LTEXT "Nome &menu:", -1, 110, 138, 55, 11
    COMBOBOX cmb6, 110, 148, 99, 300, CBS_HASSTRINGS | CBS_AUTOHSCROLL | CBS_DROPDOWN | WS_BORDER | WS_VSCROLL | WS_TABSTOP
    LTEXT "S&tile:", -1, 5, 168, 45, 11
    RTEXT "0x", -1, 52, 169, 10, 11
    EDITTEXT edt6, 67, 165, 45, 14, ES_AUTOHSCROLL
    LISTBOX lst1, 5, 183, 110, 110, LBS_DISABLENOSCROLL | LBS_NOINTEGRALHEIGHT | LBS_HASSTRINGS | LBS_MULTIPLESEL | WS_VSCROLL | WS_HSCROLL | WS_TABSTOP
    LTEXT "Stile &Ex:", -1, 120, 168, 48, 11
    RTEXT "0x", -1, 170, 169, 10, 11
    EDITTEXT edt7, 185, 165, 45, 14, ES_AUTOHSCROLL
    LISTBOX lst2, 120, 183, 110, 110, LBS_DISABLENOSCROLL | LBS_NOINTEGRALHEIGHT | LBS_HASSTRINGS | LBS_MULTIPLESEL | WS_VSCROLL | WS_HSCROLL | WS_TABSTOP
    DEFPUSHBUTTON "OK", IDOK, 106, 298, 60, 14
    PUSHBUTTON "Annulla", IDCANCEL, 171, 298, 60, 14
}

IDD_CTRLPROP DIALOG 0, 0, 235, 330
CAPTION "Proprietà controllo"
STYLE DS_MODALFRAME | WS_POPUPWINDOW | WS_CAPTION
FONT 9, "MS Shell Dlg"
{
    LTEXT "&Ctrl predefinito:", -1, 5, 7, 68, 12
    COMBOBOX cmb1, 75, 5, 120, 55, CBS_HASSTRINGS | CBS_AUTOHSCROLL | CBS_DROPDOWN | WS_BORDER | WS_VSCROLL | WS_TABSTOP
    CONTROL "", ctl1, "ToolbarWindow32", TBSTYLE_FLAT | TBSTYLE_WRAPABLE | TBSTYLE_TOOLTIPS | CCS_NODIVIDER | CCS_NORESIZE, 5, 22, 185, 30
    LTEXT "&Titolo:", -1, 5, 55, 75, 12
    COMBOBOX cmb2, 5, 65, 195, 300, CBS_HASSTRINGS | CBS_AUTOHSCROLL | CBS_DROPDOWN | WS_BORDER | WS_VSCROLL | WS_TABSTOP
    PUSHBUTTON "&OLE...", psh2, 205, 65, 25, 14
    LTEXT "&Sinistra:", -1, 5, 85, 33, 11
    EDITTEXT edt1, 5, 99, 25, 14, ES_NUMBER | ES_RIGHT
    CONTROL "", scr1, "msctls_updown32", UDS_NOTHOUSANDS | UDS_ARROWKEYS | UDS_AUTOBUDDY | UDS_ALIGNRIGHT | UDS_SETBUDDYINT, 20, 99, 12, 20
    LTEXT "&Alto:", -1, 40, 85, 33, 11
    EDITTEXT edt2, 40, 99, 25, 14, ES_NUMBER | ES_RIGHT
    CONTROL "", scr2, "msctls_updown32", UDS_NOTHOUSANDS | UDS_ARROWKEYS | UDS_AUTOBUDDY | UDS_ALIGNRIGHT | UDS_SETBUDDYINT, 55, 99, 12, 20
    LTEXT "&Larghezza:", -1, 75, 85, 33, 11
    EDITTEXT edt3, 75, 99, 25, 14, ES_NUMBER | ES_RIGHT
    CONTROL "", scr3, "msctls_updown32", UDS_NOTHOUSANDS | UDS_ARROWKEYS | UDS_AUTOBUDDY | UDS_ALIGNRIGHT | UDS_SETBUDDYINT, 90, 99, 12, 20
    LTEXT "Alte&zza:", -1, 111, 85, 33, 11
    EDITTEXT edt4, 110, 99, 25, 14, ES_NUMBER | ES_RIGHT
    CONTROL "", scr4, "msctls_updown32", UDS_NOTHOUSANDS | UDS_ARROWKEYS | UDS_AUTOBUDDY | UDS_ALIGNRIGHT | UDS_SETBUDDYINT, 125, 99, 12, 20
    LTEXT "&ID:", -1, 150, 85, 70, 12
    COMBOBOX cmb3, 150, 99, 80, 300, CBS_HASSTRINGS | CBS_AUTOHSCROLL | CBS_DROPDOWN | WS_BORDER | WS_VSCROLL | WS_TABSTOP
    LTEXT "Nome cla&sse Windows:", -1, 5, 119, 100, 12
    COMBOBOX cmb4, 5, 133, 115, 200, CBS_HASSTRINGS | CBS_AUTOHSCROLL | CBS_DROPDOWN | WS_BORDER | WS_VSCROLL | WS_TABSTOP
    LTEXT "ID &guida:", -1, 125, 119, 70, 12
    COMBOBOX cmb5, 125, 133, 65, 200, CBS_HASSTRINGS | CBS_AUTOHSCROLL | CBS_DROPDOWN | WS_BORDER | WS_VSCROLL | WS_TABSTOP
    LTEXT "S&tile:", -1, 5, 153, 45, 12
    RTEXT "0x", -1, 54, 153, 10, 12
    EDITTEXT edt6, 70, 151, 45, 14, ES_AUTOHSCROLL
    LISTBOX lst1, 5, 167, 110, 120, LBS_DISABLENOSCROLL | LBS_NOINTEGRALHEIGHT | LBS_HASSTRINGS | LBS_MULTIPLESEL | WS_VSCROLL | WS_HSCROLL | WS_TABSTOP
    LTEXT "Stile &ex.:", -1, 120, 153, 50, 12
    RTEXT "0x", -1, 172, 153, 10, 12
    EDITTEXT edt7, 185, 151, 45, 14, ES_AUTOHSCROLL
    LISTBOX lst2, 120, 167, 110, 120, LBS_DISABLENOSCROLL | LBS_NOINTEGRALHEIGHT | LBS_HASSTRINGS | LBS_MULTIPLESEL | WS_VSCROLL | WS_HSCROLL | WS_TABSTOP
    DEFPUSHBUTTON "OK", IDOK, 170, 293, 60, 14
    PUSHBUTTON "Annulla", IDCANCEL, 170, 309, 60, 14
    PUSHBUTTON "&Dati...", psh1, 5, 293, 90, 14
    PUSHBUTTON "Elenco str&inghe...", psh3, 5, 309, 90, 14
}

IDD_ADDCTRL DIALOG 0, 0, 235, 330
CAPTION "Aggiungi controllo"
STYLE DS_MODALFRAME | WS_POPUPWINDOW | WS_CAPTION
FONT 9, "MS Shell Dlg"
{
    LTEXT "&Ctrl predefinito:", -1, 5, 7, 68, 12
    COMBOBOX cmb1, 75, 5, 120, 55, CBS_HASSTRINGS | CBS_AUTOHSCROLL | CBS_DROPDOWN | WS_BORDER | WS_VSCROLL | WS_TABSTOP
    CONTROL "", ctl1, "ToolbarWindow32", TBSTYLE_FLAT | TBSTYLE_WRAPABLE | TBSTYLE_TOOLTIPS | CCS_NODIVIDER | CCS_NORESIZE, 5, 22, 185, 30
    LTEXT "&Titolo:", -1, 5, 55, 75, 12
    COMBOBOX cmb2, 5, 65, 195, 300, CBS_HASSTRINGS | CBS_AUTOHSCROLL | CBS_DROPDOWN | WS_BORDER | WS_VSCROLL | WS_TABSTOP
    PUSHBUTTON "&OLE...", psh2, 205, 65, 25, 14
    LTEXT "&Sinistra:", -1, 5, 85, 33, 11
    EDITTEXT edt1, 5, 99, 25, 14, ES_NUMBER | ES_RIGHT
    CONTROL "", scr1, "msctls_updown32", UDS_NOTHOUSANDS | UDS_ARROWKEYS | UDS_AUTOBUDDY | UDS_ALIGNRIGHT | UDS_SETBUDDYINT, 20, 99, 12, 20
    LTEXT "&Alto:", -1, 40, 85, 33, 11
    EDITTEXT edt2, 40, 99, 25, 14, ES_NUMBER | ES_RIGHT
    CONTROL "", scr2, "msctls_updown32", UDS_NOTHOUSANDS | UDS_ARROWKEYS | UDS_AUTOBUDDY | UDS_ALIGNRIGHT | UDS_SETBUDDYINT, 55, 99, 12, 20
    LTEXT "&Larghezza:", -1, 75, 85, 33, 11
    EDITTEXT edt3, 75, 99, 25, 14, ES_NUMBER | ES_RIGHT
    CONTROL "", scr3, "msctls_updown32", UDS_NOTHOUSANDS | UDS_ARROWKEYS | UDS_AUTOBUDDY | UDS_ALIGNRIGHT | UDS_SETBUDDYINT, 90, 99, 12, 20
    LTEXT "Alte&zza:", -1, 111, 85, 33, 11
    EDITTEXT edt4, 110, 99, 25, 14, ES_NUMBER | ES_RIGHT
    CONTROL "", scr4, "msctls_updown32", UDS_NOTHOUSANDS | UDS_ARROWKEYS | UDS_AUTOBUDDY | UDS_ALIGNRIGHT | UDS_SETBUDDYINT, 125, 99, 12, 20
    LTEXT "&ID:", -1, 150, 85, 70, 12
    COMBOBOX cmb3, 150, 99, 80, 300, CBS_HASSTRINGS | CBS_AUTOHSCROLL | CBS_DROPDOWN | WS_BORDER | WS_VSCROLL | WS_TABSTOP
    LTEXT "Nome cla&sse Windows:", -1, 5, 119, 100, 12
    COMBOBOX cmb4, 5, 133, 115, 200, CBS_HASSTRINGS | CBS_AUTOHSCROLL | CBS_DROPDOWN | WS_BORDER | WS_VSCROLL | WS_TABSTOP
    LTEXT "ID &guida:", -1, 125, 119, 70, 12
    COMBOBOX cmb5, 125, 133, 65, 200, CBS_HASSTRINGS | CBS_AUTOHSCROLL | CBS_DROPDOWN | WS_BORDER | WS_VSCROLL | WS_TABSTOP
    LTEXT "S&tile:", -1, 5, 153, 45, 12
    RTEXT "0x", -1, 54, 153, 10, 12
    EDITTEXT edt6, 70, 151, 45, 14, ES_AUTOHSCROLL
    LISTBOX lst1, 5, 167, 110, 120, LBS_DISABLENOSCROLL | LBS_NOINTEGRALHEIGHT | LBS_HASSTRINGS | LBS_MULTIPLESEL | WS_VSCROLL | WS_HSCROLL | WS_TABSTOP
    LTEXT "Stile &ex.:", -1, 120, 153, 50, 12
    RTEXT "0x", -1, 172, 153, 10, 12
    EDITTEXT edt7, 185, 151, 45, 14, ES_AUTOHSCROLL
    LISTBOX lst2, 120, 167, 110, 120, LBS_DISABLENOSCROLL | LBS_NOINTEGRALHEIGHT | LBS_HASSTRINGS | LBS_MULTIPLESEL | WS_VSCROLL | WS_HSCROLL | WS_TABSTOP
    DEFPUSHBUTTON "OK", IDOK, 170, 293, 60, 14
    PUSHBUTTON "Annulla", IDCANCEL, 170, 309, 60, 14
    PUSHBUTTON "&Dati...", psh1, 5, 293, 90, 14
    PUSHBUTTON "Elenco str&inghe...", psh3, 5, 309, 90, 14
}

IDD_IDASSOC DIALOG 0, 0, 200, 220
CAPTION "Associazione ID"
STYLE DS_MODALFRAME | WS_POPUPWINDOW | WS_CAPTION
FONT 9, "MS Shell Dlg"
{
    LTEXT "&Associazione ID:", -1, 5, 5, 116, 12
    CONTROL "", lst1, "SysListView32", LVS_SHOWSELALWAYS | LVS_SINGLESEL | LVS_REPORT | WS_BORDER | WS_TABSTOP, 5, 20, 190, 150
    PUSHBUTTON "&Ripristina tutto", psh2, 5, 175, 85, 14
    PUSHBUTTON "&Modifica", psh1, 135, 175, 60, 14
    DEFPUSHBUTTON "OK", IDOK, 70, 200, 60, 14
    PUSHBUTTON "Annulla", IDCANCEL, 135, 200, 60, 14
}

IDD_MODIFYASSOC DIALOG 0, 0, 165, 68
CAPTION "Modifica associazione ID"
STYLE DS_MODALFRAME | WS_POPUPWINDOW | WS_CAPTION
FONT 9, "MS Shell Dlg"
{
    RTEXT "&Tipo ID:", -1, 5, 7, 65, 12
    EDITTEXT edt1, 80, 5, 80, 14, WS_DISABLED
    RTEXT "&Prefisso ID:", -1, 5, 32, 65, 12
    EDITTEXT edt2, 80, 28, 80, 14, ES_AUTOHSCROLL
    DEFPUSHBUTTON "OK", IDOK, 35, 50, 60, 14
    PUSHBUTTON "Annulla", IDCANCEL, 100, 50, 60, 14
}

IDD_IDLIST DIALOG 0, 0, 200, 300
CAPTION "Elenco ID risorse"
STYLE WS_OVERLAPPEDWINDOW
EXSTYLE WS_EX_TOOLWINDOW
FONT 9, "MS Shell Dlg"
{
    COMBOBOX cmb1, 0, 0, 200, 300, CBS_HASSTRINGS | CBS_SORT | CBS_OWNERDRAWFIXED | CBS_DROPDOWNLIST | WS_VSCROLL | WS_TABSTOP
    CONTROL "", lst1, "SysListView32", LVS_REPORT | WS_BORDER | WS_VSCROLL | WS_HSCROLL | WS_TABSTOP, 0, 15, 200, 285
}

IDD_CONFIG DIALOG 0, 0, 235, 285
CAPTION "Impostazioni"
STYLE DS_MODALFRAME | WS_POPUPWINDOW | WS_CAPTION
FONT 9, "MS Shell Dlg"
{
    AUTOCHECKBOX "Visuali&zza percorso completo file nella barra del titolo", chx1, 5, 5, 200, 14
    AUTOCHECKBOX "Non usare ID &macro", chx2, 5, 25, 200, 14
    AUTOCHECKBOX "Riprendi posizione finestra &precedente", chx3, 5, 45, 200, 14
    AUTOCHECKBOX "Carica automaticamente '&resource.h' vicino", chx4, 5, 65, 200, 14
    AUTOCHECKBOX "Visualizza automaticamente e&lenco ID risorse", chx5, 5, 85, 200, 14
    AUTOCHECKBOX "Visualizza &punti nella finestra modifica", chx6, 5, 105, 200, 14
    RTEXT "Altezza combo&box:", -1, 10, 127, 75, 12
    EDITTEXT edt1, 90, 125, 34, 14, ES_NUMBER | ES_RIGHT
    CONTROL "", scr1, "msctls_updown32", UDS_NOTHOUSANDS | UDS_ARROWKEYS | UDS_AUTOBUDDY | UDS_ALIGNRIGHT | UDS_SETBUDDYINT, 129, 49, 12, 20
    AUTOCHECKBOX "&A capo automatico", chx9, 135, 125, 70, 14
    AUTOCHECKBOX "Chiedi per aggiornamento '&resource.h'", chx7, 5, 145, 200, 14
    AUTOCHECKBOX "Comprimi EXE con &UPX al salvataggio", chx8, 5, 165, 200, 14
    PUSHBUTTON "&Font...", psh4, 5, 185, 200, 14
    PUSHBUTTON "&Macro predefinite...", psh1, 5, 205, 93, 14
    PUSHBUTTON "Impos&ta percorsi...", psh2, 107, 205, 98, 14
    RTEXT "Nome controlli &OLE:", -1, 5, 227, 80, 12
    COMBOBOX cmb1, 90, 225, 75, 300, CBS_HASSTRINGS | CBS_AUTOHSCROLL | CBS_DROPDOWN | WS_VSCROLL | WS_TABSTOP
    AUTOCHECKBOX "Crea &backup", chx10, 5, 245, 75, 15
    RTEXT "Suffisso backup:", -1, 90, 245, 60, 15
    COMBOBOX cmb2, 158, 244, 45, 300, CBS_HASSTRINGS | CBS_AUTOHSCROLL | CBS_DROPDOWN | WS_VSCROLL | WS_TABSTOP
    DEFPUSHBUTTON "OK", IDOK, 100, 265, 50, 14
    PUSHBUTTON "Annulla", IDCANCEL, 155, 265, 50, 14
    PUSHBUTTON "Ripri&stina tutto", psh3, 5, 265, 75, 14
}

IDD_ADDRESID DIALOG 0, 0, 165, 90
CAPTION "Aggiungi ID risorsa"
STYLE DS_MODALFRAME | WS_POPUPWINDOW | WS_CAPTION
FONT 9, "MS Shell Dlg"
{
    RTEXT "&Tipo ID:", -1, 10, 7, 50, 14
    COMBOBOX cmb1, 65, 5, 95, 300, CBS_AUTOHSCROLL | CBS_DROPDOWNLIST | WS_VSCROLL | WS_TABSTOP
    RTEXT "&Nome ID:", -1, 10, 27, 50, 14
    EDITTEXT edt1, 65, 25, 75, 14, ES_AUTOHSCROLL
    RTEXT "Valore &intero:", -1, 10, 47, 50, 14
    EDITTEXT edt2, 65, 45, 48, 14, ES_AUTOHSCROLL
    CONTROL "", scr1, "msctls_updown32", UDS_NOTHOUSANDS | UDS_ARROWKEYS | UDS_AUTOBUDDY | UDS_ALIGNRIGHT | UDS_SETBUDDYINT, 129, 49, 12, 20
    PUSHBUTTON "&Automatico", psh1, 115, 45, 45, 14
    DEFPUSHBUTTON "OK", IDOK, 20, 70, 60, 14
    PUSHBUTTON "Annulla", IDCANCEL, 85, 70, 60, 14
}

IDD_MODIFYRESID DIALOG 0, 0, 165, 90
CAPTION "Modifica ID risorsa"
STYLE DS_MODALFRAME | WS_POPUPWINDOW | WS_CAPTION
FONT 9, "MS Shell Dlg"
{
    RTEXT "&Nome ID:", -1, 10, 12, 50, 14, SS_REALSIZEIMAGE | NOT WS_GROUP
    EDITTEXT edt1, 65, 10, 95, 14, ES_AUTOHSCROLL
    RTEXT "&Tipo ID:", -1, 10, 32, 50, 14
    EDITTEXT edt2, 65, 30, 95, 14, ES_READONLY
    RTEXT "Valore &intero:", -1, 10, 52, 50, 14
    EDITTEXT edt3, 65, 50, 48, 14, ES_AUTOHSCROLL
    CONTROL "", scr1, "msctls_updown32", UDS_NOTHOUSANDS | UDS_ARROWKEYS | UDS_AUTOBUDDY | UDS_ALIGNRIGHT | UDS_SETBUDDYINT, 129, 49, 12, 20
    DEFPUSHBUTTON "OK", IDOK, 20, 70, 60, 14
    PUSHBUTTON "Annulla", IDCANCEL, 85, 70, 60, 14
}

IDD_ADVICERESH DIALOG 0, 0, 209, 184
CAPTION "Avviso modifica file 'resource.h'"
STYLE DS_MODALFRAME | WS_POPUPWINDOW | WS_CAPTION
FONT 9, "MS Shell Dlg"
{
    LTEXT "Modifica il file 'resource.h' come di seguito:", -1, 10, 10, 195, 20
    EDITTEXT edt1, 10, 30, 190, 130, ES_READONLY | ES_MULTILINE
    DEFPUSHBUTTON "OK", IDOK, 140, 165, 60, 14
    PUSHBUTTON "A&nnulla modifiche", psh1, 10, 165, 90, 14
}

IDD_CLONEINNEWNAME DIALOG 0, 0, 215, 75
CAPTION "Clona con un nuovo nome"
STYLE DS_MODALFRAME | WS_POPUPWINDOW | WS_CAPTION
FONT 9, "MS Shell Dlg"
{
    LTEXT "&Tipo risorsa:", -1, 5, 7, 70, 12
    COMBOBOX cmb1, 75, 5, 135, 200, CBS_HASSTRINGS | CBS_AUTOHSCROLL | CBS_DROPDOWN | WS_DISABLED | WS_BORDER | WS_VSCROLL | WS_TABSTOP
    LTEXT "&Nome risorsa:", -1, 5, 32, 70, 12
    COMBOBOX cmb2, 75, 30, 120, 200, CBS_HASSTRINGS | CBS_AUTOHSCROLL | CBS_DROPDOWN | WS_BORDER | WS_VSCROLL | WS_TABSTOP
    PUSHBUTTON "&...", psh1, 195, 30, 15, 14
    DEFPUSHBUTTON "OK", IDOK, 35, 55, 60, 14
    PUSHBUTTON "Annulla", IDCANCEL, 115, 55, 60, 14
}

IDD_CLONEINNEWLANG DIALOG 0, 0, 215, 105
CAPTION "Clona in una nuova lingua"
STYLE DS_MODALFRAME | WS_POPUPWINDOW | WS_CAPTION
FONT 9, "MS Shell Dlg"
{
    LTEXT "&Tipo risorsa:", -1, 5, 7, 70, 12
    COMBOBOX cmb1, 75, 5, 135, 200, CBS_HASSTRINGS | CBS_AUTOHSCROLL | CBS_DROPDOWN | WS_DISABLED | WS_BORDER | WS_VSCROLL | WS_TABSTOP
    LTEXT "&Nome risorsa:", -1, 5, 32, 70, 12
    COMBOBOX cmb2, 75, 30, 120, 200, CBS_HASSTRINGS | CBS_AUTOHSCROLL | CBS_DROPDOWN | WS_DISABLED | WS_BORDER | WS_VSCROLL | WS_TABSTOP
    LTEXT "&Lingua risorsa:", -1, 5, 57, 70, 12
    COMBOBOX cmb3, 75, 55, 135, 200, CBS_HASSTRINGS | CBS_AUTOHSCROLL | CBS_DROPDOWN | WS_BORDER | WS_VSCROLL | WS_TABSTOP
    DEFPUSHBUTTON "OK", IDOK, 35, 85, 60, 14
    PUSHBUTTON "Annulla", IDCANCEL, 115, 85, 60, 14
}

IDD_ITEMSEARCH DIALOG 0, 0, 171, 135
CAPTION "Cerca"
STYLE WS_POPUPWINDOW | WS_CAPTION
FONT 9, "MS Shell Dlg"
{
    LTEXT "&Stringa da cercare:", -1, 4, 10, 100, 14
    EDITTEXT edt1, 5, 25, 160, 15, ES_AUTOHSCROLL
    AUTOCHECKBOX "Controlla maius&colo/minuscolo", chx1, 5, 45, 120, 18
    GROUPBOX "Direzione ricerca", -1, 5, 65, 160, 42
    AUTORADIOBUTTON "&Indietro", rad1, 15, 80, 60, 14, WS_TABSTOP
    AUTORADIOBUTTON "&Avanti", rad2, 90, 80, 60, 14, WS_TABSTOP
    DEFPUSHBUTTON "&Cerca", IDOK, 40, 115, 60, 14
    PUSHBUTTON "Annulla", IDCANCEL, 105, 115, 60, 14
}

IDD_VERSIONINFO DIALOG 0, 0, 174, 150
CAPTION "Info su RisohEditor"
STYLE DS_MODALFRAME | WS_POPUPWINDOW | WS_CAPTION
FONT 12, "MS Shell Dlg"
{
    ICON IDI_MAIN, -1, 5, 5, 0, 0
    LTEXT "...", stc1, 30, 5, 140, 50
    CTEXT "https://katahiromz.web.fc2.com", stc2, 5, 60, 165, 12, SS_CENTERIMAGE | SS_NOTIFY | NOT WS_GROUP
    CONTROL "...", edt1, "EDIT", ES_READONLY | ES_AUTOHSCROLL | ES_AUTOVSCROLL | ES_MULTILINE | WS_BORDER | WS_VSCROLL | WS_HSCROLL, 5, 75, 165, 50
    DEFPUSHBUTTON "OK", IDOK, 55, 130, 60, 14
}

IDD_ADDMSG DIALOG 0, 0, 255, 105
CAPTION "Aggiungi messaggio"
STYLE DS_MODALFRAME | WS_POPUPWINDOW | WS_CAPTION
FONT 9, "MS Shell Dlg"
{
    LTEXT "&ID messaggio:", -1, 5, 7, 50, 12
    COMBOBOX cmb1, 65, 5, 134, 200, CBS_HASSTRINGS | CBS_AUTOHSCROLL | CBS_DROPDOWN | WS_BORDER | WS_VSCROLL | WS_TABSTOP
    PUSHBUTTON "&...", psh1, 200, 5, 15, 14
    LTEXT "&Valore messaggio:", -1, 5, 27, 80, 12
    EDITTEXT edt1, 5, 40, 245, 35, ES_WANTRETURN | ES_AUTOHSCROLL | ES_AUTOVSCROLL | ES_MULTILINE
    DEFPUSHBUTTON "OK", IDOK, 125, 85, 60, 14
    PUSHBUTTON "Annulla", IDCANCEL, 190, 85, 60, 14
}

IDD_MODIFYMSG DIALOG 0, 0, 255, 105
CAPTION "Modifica messaggio"
STYLE DS_MODALFRAME | WS_POPUPWINDOW | WS_CAPTION
FONT 9, "MS Shell Dlg"
{
    LTEXT "&ID messaggio:", -1, 5, 7, 50, 12
    COMBOBOX cmb1, 65, 5, 134, 200, CBS_HASSTRINGS | CBS_AUTOHSCROLL | CBS_DROPDOWN | WS_DISABLED | WS_BORDER | WS_VSCROLL | WS_TABSTOP
    LTEXT "&Valore messaggio:", -1, 5, 27, 80, 12
    EDITTEXT edt1, 5, 40, 245, 35, ES_WANTRETURN | ES_AUTOHSCROLL | ES_AUTOVSCROLL | ES_MULTILINE
    DEFPUSHBUTTON "OK", IDOK, 125, 85, 60, 14
    PUSHBUTTON "Annulla", IDCANCEL, 190, 85, 60, 14
}

IDD_MESSAGES DIALOG 0, 0, 325, 160
CAPTION "Tabella messaggi"
STYLE WS_POPUPWINDOW | WS_CAPTION | WS_THICKFRAME
FONT 9, "MS Shell Dlg"
{
    LTEXT "&Elementi messaggi:", -1, 5, 7, 80, 12
    CONTROL "", lst1, "SysListView32", LVS_NOSORTHEADER | LVS_AUTOARRANGE | LVS_NOLABELWRAP | LVS_SHOWSELALWAYS | LVS_SINGLESEL | LVS_REPORT | WS_BORDER | WS_VSCROLL | WS_HSCROLL | WS_TABSTOP, 5, 20, 315, 115
    PUSHBUTTON "&Aggiungi...", psh1, 130, 3, 60, 14
    PUSHBUTTON "&Modifica...", psh2, 195, 3, 60, 14
    PUSHBUTTON "&Elimina", psh3, 260, 3, 60, 14
    DEFPUSHBUTTON "OK", IDOK, 195, 140, 60, 14
    PUSHBUTTON "Annulla", IDCANCEL, 260, 140, 60, 14
    PUSHBUTTON "Elimina t&utto", psh4, 5, 140, 75, 14
}

IDD_FONTS DIALOG 0, 0, 195, 110
CAPTION "Impostazioni font"
STYLE DS_MODALFRAME | WS_POPUPWINDOW | WS_CAPTION
FONT 9, "MS Shell Dlg"
{
    RTEXT "&Sorgente:", -1, 5, 5, 55, 15, SS_CENTERIMAGE | NOT WS_GROUP
    EDITTEXT edt1, 65, 5, 100, 14, ES_READONLY | ES_AUTOHSCROLL
    PUSHBUTTON "...", psh1, 170, 5, 19, 14
    RTEXT "&Binario:", -1, 5, 25, 55, 15, SS_CENTERIMAGE | NOT WS_GROUP
    EDITTEXT edt2, 65, 25, 100, 14, ES_READONLY | ES_AUTOHSCROLL
    PUSHBUTTON "...", psh2, 170, 25, 19, 14
    GROUPBOX "Anteprima", -1, 5, 45, 185, 39
    CTEXT "Sorgente", stc1, 15, 55, 80, 25, SS_CENTERIMAGE | NOT WS_GROUP
    CTEXT "Binario", stc2, 100, 55, 85, 25, SS_CENTERIMAGE | NOT WS_GROUP
    DEFPUSHBUTTON "OK", IDOK, 65, 90, 60, 14
    PUSHBUTTON "Annulla", IDCANCEL, 130, 90, 60, 14
}

IDD_MACROS DIALOG 0, 0, 265, 165
CAPTION "Macro predefinite"
STYLE WS_POPUPWINDOW | WS_CAPTION | WS_THICKFRAME
FONT 9, "MS Shell Dlg"
{
    LTEXT "&Macro predefinite:", -1, 5, 0, 100, 15, SS_CENTERIMAGE | NOT WS_GROUP
    CONTROL "", lst1, "SysListView32", LVS_EDITLABELS | LVS_SHOWSELALWAYS | LVS_SINGLESEL | LVS_REPORT | WS_BORDER | WS_TABSTOP, 5, 15, 190, 125
    PUSHBUTTON "&Aggiungi...", psh1, 200, 15, 60, 14
    PUSHBUTTON "&Modifica...", psh2, 200, 35, 60, 14
    PUSHBUTTON "&Elimina", psh3, 200, 55, 60, 14
    PUSHBUTTON "Elimina t&utto", psh7, 200, 105, 60, 14
    DEFPUSHBUTTON "OK", IDOK, 135, 145, 60, 14
    PUSHBUTTON "Annulla", IDCANCEL, 200, 145, 60, 14
    PUSHBUTTON "&Ripristina tutto", psh6, 5, 145, 60, 14
}

IDD_ADDMACRO DIALOG 0, 0, 190, 80
CAPTION "Aggiungi macro predefinita"
STYLE DS_MODALFRAME | WS_POPUPWINDOW | WS_CAPTION
FONT 9, "MS Shell Dlg"
{
    RTEXT "&Chiave:", -1, 5, 12, 60, 14
    COMBOBOX cmb1, 70, 10, 110, 200, CBS_DROPDOWN | WS_BORDER | WS_VSCROLL | WS_TABSTOP
    RTEXT "&Valore:", -1, 5, 37, 60, 14
    COMBOBOX cmb2, 70, 35, 110, 300, CBS_DROPDOWN | WS_BORDER | WS_VSCROLL | WS_TABSTOP
    DEFPUSHBUTTON "OK", IDOK, 60, 60, 60, 14
    PUSHBUTTON "Annulla", IDCANCEL, 125, 60, 60, 14
}

IDD_EDITMACRO DIALOG 0, 0, 190, 80
CAPTION "Modifica macro predefinita"
STYLE DS_MODALFRAME | WS_POPUPWINDOW | WS_CAPTION
FONT 9, "MS Shell Dlg"
{
    RTEXT "&Chiave:", -1, 5, 12, 60, 14
    COMBOBOX cmb1, 70, 10, 110, 200, CBS_DROPDOWN | WS_DISABLED | WS_BORDER | WS_VSCROLL | WS_TABSTOP
    RTEXT "&Valore:", -1, 5, 37, 60, 14
    COMBOBOX cmb2, 70, 35, 110, 300, CBS_DROPDOWN | WS_BORDER | WS_VSCROLL | WS_TABSTOP
    DEFPUSHBUTTON "OK", IDOK, 60, 60, 60, 14
    PUSHBUTTON "Annulla", IDCANCEL, 125, 60, 60, 14
}

IDD_CTRLDATA DIALOG 0, 0, 190, 130
CAPTION "Modifica dati controllo"
STYLE DS_MODALFRAME | WS_POPUPWINDOW | WS_CAPTION
FONT 9, "MS Shell Dlg"
{
    LTEXT "Dati &binari:", -1, 5, 2, 87, 12
    EDITTEXT edt1, 5, 15, 180, 60, ES_AUTOVSCROLL | ES_MULTILINE | WS_VSCROLL
    LTEXT "Puoi impostare i dati controllo con valori interi a 16 bit separati da spazio.", -1, 5, 80, 180, 25
    DEFPUSHBUTTON "OK", IDOK, 60, 110, 60, 14
    PUSHBUTTON "Annulla", IDCANCEL, 125, 110, 60, 14
}

IDD_PATHS DIALOG 0, 0, 295, 220
CAPTION "Impostazioni percorsi"
STYLE WS_POPUPWINDOW | WS_CAPTION | WS_THICKFRAME
FONT 9, "MS Shell Dlg"
{
    LTEXT "&Includi cartelle:", -1, 5, 5, 102, 12
    LISTBOX lst1, 5, 20, 220, 105, LBS_NOINTEGRALHEIGHT | LBS_HASSTRINGS | LBS_SORT | WS_VSCROLL | WS_HSCROLL | WS_TABSTOP
    PUSHBUTTON "&Aggiungi...", psh1, 230, 20, 60, 14
    PUSHBUTTON "&Modifica...", psh2, 230, 40, 60, 14
    PUSHBUTTON "&Elimina", psh3, 230, 60, 60, 14
    PUSHBUTTON "&Su", psh4, 230, 80, 60, 14
    PUSHBUTTON "Gi&ù", psh5, 230, 100, 60, 14
    PUSHBUTTON "Elimina t&utto", psh6, 5, 130, 95, 14
    RTEXT "&windres.exe:", stc1, 5, 157, 55, 12
    COMBOBOX cmb1, 70, 155, 155, 300, CBS_HASSTRINGS | CBS_AUTOHSCROLL | CBS_DROPDOWN | WS_VSCROLL | WS_TABSTOP
    PUSHBUTTON "&Sfoglia...", psh7, 230, 155, 60, 14
    RTEXT "&cpp.exe:", stc2, 5, 177, 55, 12
    COMBOBOX cmb2, 70, 175, 155, 300, CBS_HASSTRINGS | CBS_AUTOHSCROLL | CBS_DROPDOWN | WS_VSCROLL | WS_TABSTOP
    PUSHBUTTON "&Sfoglia...", psh8, 230, 175, 60, 14
    DEFPUSHBUTTON "OK", IDOK, 165, 200, 60, 14
    PUSHBUTTON "Annulla", IDCANCEL, 230, 200, 60, 14
    PUSHBUTTON "Ripri&stina tutto", psh9, 5, 200, 95, 14
}

IDD_EXP_OPTIONS DIALOG 0, 0, 250, 225
CAPTION "Opzioni esportazione"
STYLE DS_MODALFRAME | WS_POPUPWINDOW | WS_CAPTION
FONT 9, "MS Shell Dlg"
{
    ICON IDI_MAIN, -1, 5, 10, 0, 0
    LTEXT "L'esportazione di un file .rc genererà alcuni file relativi.\r\nPuoi scegliere le seguenti opzioni:", -1, 35, 5, 210, 29
    AUTOCHECKBOX "Usa &tabella messaggi Microsoft", chx8, 5, 40, 240, 14
    AUTOCHECKBOX "File risorse separati per &lingua", chx1, 5, 60, 240, 14
    AUTOCHECKBOX "Usa parole chiave B&EGIN/END", chx2, 5, 80, 240, 14
    AUTOCHECKBOX "Rendi la lingua selezionabile via macro LANGUAGE_*", chx3, 5, 100, 240, 14
    AUTOCHECKBOX "Crea file &backup", chx4, 5, 120, 110, 14
    RTEXT "con suffisso:", -1, 120, 122, 75, 12
    COMBOBOX cmb1, 200, 120, 45, 300, CBS_HASSTRINGS | CBS_AUTOHSCROLL | CBS_DROPDOWN | WS_VSCROLL | WS_TABSTOP
    AUTOCHECKBOX "Visualizza &commenti ridondanti", chx5, 5, 140, 240, 14
    AUTOCHECKBOX "Includi istruzioni ma&nifest tra #ifndef MSVC ... #endif", chx6, 5, 160, 240, 14
    AUTOCHECKBOX "File RC destinazione in &UTF-16", chx7, 5, 180, 240, 14
    DEFPUSHBUTTON "OK", IDOK, 120, 205, 60, 14
    PUSHBUTTON "Annulla", IDCANCEL, 185, 205, 60, 14
}

IDD_LANGS DIALOG 0, 0, 250, 235
CAPTION "Lingua"
STYLE WS_POPUPWINDOW | WS_CAPTION | WS_THICKFRAME
FONT 9, "MS Shell Dlg"
{
    CONTROL "", lst1, "SysListView32", LVS_SHOWSELALWAYS | LVS_SINGLESEL | LVS_REPORT | WS_BORDER | WS_TABSTOP, 5, 5, 240, 179
    RTEXT "&Cerca:", stc1, 5, 192, 45, 12
    COMBOBOX cmb1, 55, 190, 85, 300, CBS_SORT | CBS_DROPDOWN | WS_VSCROLL | WS_TABSTOP
    EDITTEXT edt1, 4, 209, 240, 20, ES_AUTOHSCROLL | ES_AUTOVSCROLL | ES_MULTILINE
}

IDD_CHILD DIALOG 0, 0, 215, 135
CAPTION "Finestra figlia"
STYLE WS_CHILD | WS_OVERLAPPEDWINDOW
FONT 9, "MS Shell Dlg"
{
    DEFPUSHBUTTON "OK", IDOK, 35, 115, 60, 14
    PUSHBUTTON "Annulla", IDCANCEL, 115, 115, 60, 14
}

IDD_DLGINITEDIT DIALOG 0, 0, 325, 165
CAPTION "Modifica DLGINIT"
STYLE WS_POPUPWINDOW | WS_CAPTION | WS_THICKFRAME
FONT 9, "MS Shell Dlg"
{
    LTEXT "&Elementi messaggi:", -1, 5, 7, 100, 12
    CONTROL "", lst1, "SysListView32", LVS_NOSORTHEADER | LVS_AUTOARRANGE | LVS_NOLABELWRAP | LVS_SHOWSELALWAYS | LVS_SINGLESEL | LVS_REPORT | WS_BORDER | WS_VSCROLL | WS_HSCROLL | WS_TABSTOP, 5, 20, 250, 120
    PUSHBUTTON "&Aggiungi...", psh1, 260, 20, 60, 14
    PUSHBUTTON "&Modifica...", psh2, 260, 40, 60, 14
    PUSHBUTTON "&Elimina", psh3, 260, 60, 60, 14
    PUSHBUTTON "S&u", psh4, 260, 100, 60, 14
    PUSHBUTTON "Gi&ù", psh5, 260, 120, 60, 14
    DEFPUSHBUTTON "OK", IDOK, 195, 145, 60, 14
    PUSHBUTTON "Annulla", IDCANCEL, 260, 145, 60, 14
    PUSHBUTTON "Elimina t&utto", psh6, 5, 145, 79, 14
}

IDD_ADDDLGINIT DIALOG 0, 0, 184, 137
CAPTION "Aggiungi dati DLGINIT"
STYLE DS_MODALFRAME | WS_POPUPWINDOW | WS_CAPTION
FONT 9, "MS Shell Dlg"
{
    LTEXT "&ID controllo:", -1, 5, 7, 56, 12
    COMBOBOX cmb1, 65, 5, 115, 300, CBS_HASSTRINGS | CBS_AUTOHSCROLL | CBS_DROPDOWN | WS_VSCROLL | WS_TABSTOP
    LTEXT "&Messaggio:", -1, 5, 32, 55, 12
    COMBOBOX cmb2, 65, 30, 95, 300, CBS_HASSTRINGS | CBS_AUTOHSCROLL | CBS_DROPDOWN | WS_VSCROLL | WS_TABSTOP
    LTEXT "&Stringa:", -1, 5, 52, 55, 12
    EDITTEXT edt1, 5, 65, 175, 50, ES_WANTRETURN | ES_MULTILINE | WS_VSCROLL | WS_HSCROLL
    DEFPUSHBUTTON "OK", IDOK, 55, 120, 60, 14
    PUSHBUTTON "Annulla", IDCANCEL, 120, 120, 60, 14
}

IDD_MODIFYDLGINIT DIALOG 0, 0, 184, 137
CAPTION "Modifica dati DLGINIT"
STYLE DS_MODALFRAME | WS_POPUPWINDOW | WS_CAPTION
FONT 9, "MS Shell Dlg"
{
    LTEXT "&ID controllo:", -1, 5, 7, 56, 12
    COMBOBOX cmb1, 65, 5, 115, 300, CBS_HASSTRINGS | CBS_AUTOHSCROLL | CBS_DROPDOWN | WS_VSCROLL | WS_TABSTOP
    LTEXT "&Messaggio:", -1, 5, 32, 55, 12
    COMBOBOX cmb2, 65, 30, 95, 300, CBS_HASSTRINGS | CBS_AUTOHSCROLL | CBS_DROPDOWN | WS_VSCROLL | WS_TABSTOP
    LTEXT "&Stringa:", -1, 5, 52, 55, 12
    EDITTEXT edt1, 5, 65, 175, 50, ES_WANTRETURN | ES_MULTILINE | WS_VSCROLL | WS_HSCROLL
    DEFPUSHBUTTON "OK", IDOK, 55, 120, 60, 14
    PUSHBUTTON "Annulla", IDCANCEL, 120, 120, 60, 14
}

IDD_STRINGLIST DIALOG 0, 0, 205, 220
CAPTION "Elenco stringhe controllo"
STYLE WS_POPUPWINDOW | WS_CAPTION | WS_THICKFRAME
FONT 9, "MS Shell Dlg"
{
    LTEXT "", stc1, 5, 5, 195, 70
    EDITTEXT edt1, 5, 80, 195, 115, ES_WANTRETURN | ES_MULTILINE | WS_VSCROLL | WS_HSCROLL
    DEFPUSHBUTTON "OK", IDOK, 75, 200, 60, 14
    PUSHBUTTON "Annulla", IDCANCEL, 140, 200, 60, 14
}

IDD_SAVE_OPTIONS DIALOG 0, 0, 250, 225
CAPTION "Opzioni salvataggio"
STYLE DS_MODALFRAME | WS_POPUPWINDOW | WS_CAPTION
FONT 9, "MS Shell Dlg"
{
    ICON IDI_MAIN, -1, 5, 10, 0, 0
    LTEXT "Il salvataggio di un file .rc genera un serie di file relativi.\r\nPuoi scegliere le seguenti opzioni:", -1, 35, 5, 210, 29
    AUTOCHECKBOX "Usa &tabella messaggi Microsoft", chx8, 5, 40, 240, 14
    AUTOCHECKBOX "Separa file risorse per &lingua", chx1, 5, 60, 240, 14
    AUTOCHECKBOX "Usa parole chiave B&EGIN/END", chx2, 5, 80, 240, 14
    AUTOCHECKBOX "Rendi la lingua selezionabile via macro LANGUAGE_*", chx3, 5, 100, 240, 14
    AUTOCHECKBOX "Crea file &backup", chx4, 5, 120, 110, 14
    RTEXT "con suffisso:", -1, 120, 122, 75, 12
    COMBOBOX cmb1, 200, 120, 45, 300, CBS_HASSTRINGS | CBS_AUTOHSCROLL | CBS_DROPDOWN | WS_VSCROLL | WS_TABSTOP
    AUTOCHECKBOX "&Commenti ridondanti output", chx5, 5, 140, 240, 14
    AUTOCHECKBOX "Includi le istruzioni ma&nifest tra #ifndef MSVC ... #endif", chx6, 5, 160, 240, 14
    AUTOCHECKBOX "File RC destinazione in &UTF-16", chx7, 5, 180, 240, 14
    DEFPUSHBUTTON "OK", IDOK, 120, 205, 60, 14
    PUSHBUTTON "Annulla", IDCANCEL, 185, 205, 60, 14
}

IDD_ENCODING DIALOG 0, 0, 200, 170
CAPTION "Codifica risorsa"
STYLE DS_MODALFRAME | WS_POPUPWINDOW | WS_CAPTION
FONT 9, "MS Shell Dlg"
{
    CONTROL "", lst1, "SysListView32", LVS_SHOWSELALWAYS | LVS_SINGLESEL | LVS_REPORT | WS_BORDER, 5, 5, 190, 115
    PUSHBUTTON "&Aggiungi...", psh1, 5, 125, 60, 14
    PUSHBUTTON "&Modifica...", psh2, 70, 125, 60, 14
    PUSHBUTTON "&Elimina", psh3, 135, 125, 60, 14
    DEFPUSHBUTTON "OK", IDOK, 70, 150, 60, 14
    PUSHBUTTON "Annulla", IDCANCEL, 135, 150, 60, 14
    PUSHBUTTON "&Ripristina", psh5, 5, 149, 60, 14
}

IDD_ADDENC DIALOG 0, 0, 215, 80
CAPTION "Aggiungi codifica risorsa"
STYLE DS_MODALFRAME | WS_POPUPWINDOW | WS_CAPTION
FONT 9, "MS Shell Dlg"
{
    LTEXT "&Tipo risorsa:", -1, 5, 7, 70, 12
    COMBOBOX cmb1, 75, 5, 135, 200, CBS_HASSTRINGS | CBS_AUTOHSCROLL | CBS_DROPDOWN | WS_BORDER | WS_VSCROLL | WS_TABSTOP
    LTEXT "&Codifica:", -1, 5, 30, 70, 12
    COMBOBOX cmb2, 75, 30, 85, 300, CBS_HASSTRINGS | CBS_AUTOHSCROLL | CBS_DROPDOWNLIST | WS_VSCROLL | WS_TABSTOP
    DEFPUSHBUTTON "OK", IDOK, 86, 60, 60, 14
    PUSHBUTTON "Annulla", IDCANCEL, 150, 60, 60, 14
}

IDD_MODIFYENC DIALOG 0, 0, 215, 80
CAPTION "Modifica codifica risorsa"
STYLE DS_MODALFRAME | WS_POPUPWINDOW | WS_CAPTION
FONT 9, "MS Shell Dlg"
{
    LTEXT "&Tipo risorsa:", -1, 5, 7, 70, 12
    COMBOBOX cmb1, 75, 5, 135, 200, CBS_HASSTRINGS | CBS_AUTOHSCROLL | CBS_DROPDOWN | WS_DISABLED | WS_BORDER | WS_VSCROLL | WS_TABSTOP
    LTEXT "&Codifica:", -1, 5, 30, 70, 12
    COMBOBOX cmb2, 75, 30, 85, 300, CBS_HASSTRINGS | CBS_AUTOHSCROLL | CBS_DROPDOWNLIST | WS_VSCROLL | WS_TABSTOP
    DEFPUSHBUTTON "OK", IDOK, 86, 60, 60, 14
    PUSHBUTTON "Annulla", IDCANCEL, 150, 60, 60, 14
}

IDD_CONSTANT DIALOG 0, 0, 205, 75
CAPTION "Cerca costante"
STYLE DS_MODALFRAME | WS_POPUPWINDOW | WS_CAPTION
FONT 9, "MS Shell Dlg"
{
    LTEXT "&Nome costante:", -1, 5, 7, 80, 12
    COMBOBOX cmb1, 94, 7, 105, 300, CBS_HASSTRINGS | CBS_AUTOHSCROLL | CBS_DROPDOWN | WS_VSCROLL | WS_TABSTOP
    LTEXT "&Valore costante:", -1, 5, 32, 80, 12
    EDITTEXT edt2, 95, 30, 50, 14, ES_READONLY
    EDITTEXT edt3, 150, 30, 50, 14, ES_READONLY
    DEFPUSHBUTTON "OK", IDOK, 70, 55, 60, 14
}

IDD_EGA DIALOG 0, 0, 400, 225
CAPTION "Linguaggio programmazione EGA"
STYLE WS_POPUPWINDOW | WS_CAPTION | WS_THICKFRAME
FONT 9, "MS Shell Dlg"
{
    GROUPBOX "Console EGA", grp1, 5, 5, 390, 195
    EDITTEXT edt1, 10, 20, 380, 170, ES_READONLY | ES_AUTOVSCROLL | ES_MULTILINE | WS_VSCROLL | NOT WS_TABSTOP
    RTEXT "EGA>", stc1, 10, 208, 20, 10
    EDITTEXT edt2, 35, 205, 300, 15, ES_WANTRETURN | ES_AUTOHSCROLL | ES_AUTOVSCROLL | ES_MULTILINE
    PUSHBUTTON "&Invio", IDOK, 345, 205, 50, 15
}

IDD_FONTSUBST DIALOG 0, 0, 185, 180
CAPTION "Sostituzione font finestra"
STYLE DS_CENTER | DS_MODALFRAME | WS_POPUPWINDOW | WS_CAPTION
FONT 9, "MS Shell Dlg"
{
    LTEXT "Font #&1:", -1, 5, 7, 44, 12
    COMBOBOX cmb1, 55, 5, 125, 300, CBS_HASSTRINGS | CBS_AUTOHSCROLL | CBS_DROPDOWN | WS_VSCROLL | WS_TABSTOP
    ICON IDI_ARROW, -1, 30, 25, 0, 0
    COMBOBOX cmb2, 55, 30, 125, 300, CBS_HASSTRINGS | CBS_AUTOHSCROLL | CBS_DROPDOWN | WS_VSCROLL | WS_TABSTOP
    LTEXT "Font #&2:", -1, 5, 57, 44, 12
    COMBOBOX cmb3, 55, 55, 125, 300, CBS_HASSTRINGS | CBS_AUTOHSCROLL | CBS_DROPDOWN | WS_VSCROLL | WS_TABSTOP
    ICON IDI_ARROW, -1, 30, 75, 0, 0
    COMBOBOX cmb4, 55, 80, 125, 300, CBS_HASSTRINGS | CBS_AUTOHSCROLL | CBS_DROPDOWN | WS_VSCROLL | WS_TABSTOP
    LTEXT "Font #&3:", -1, 5, 105, 44, 12
    COMBOBOX cmb5, 55, 105, 125, 300, CBS_HASSTRINGS | CBS_AUTOHSCROLL | CBS_DROPDOWN | WS_VSCROLL | WS_TABSTOP
    ICON IDI_ARROW, -1, 30, 125, 0, 0
    COMBOBOX cmb6, 55, 130, 125, 300, CBS_HASSTRINGS | CBS_AUTOHSCROLL | CBS_DROPDOWN | WS_VSCROLL | WS_TABSTOP
    DEFPUSHBUTTON "OK", IDOK, 75, 160, 50, 14
    PUSHBUTTON "Annulla", IDCANCEL, 130, 160, 50, 14
    PUSHBUTTON "&Ripristina", psh1, 5, 160, 55, 14
}

IDD_DROPDOWNPOPUP DIALOG 0, 0, 120, 150
CAPTION " "
STYLE WS_POPUP | WS_DLGFRAME | NOT WS_BORDER
FONT 9, "MS Shell Dlg"
{
    LISTBOX lst1, 0, 0, 120, 150, LBS_WANTKEYBOARDINPUT | LBS_NOINTEGRALHEIGHT | LBS_HASSTRINGS | WS_VSCROLL | WS_TABSTOP, WS_EX_CLIENTEDGE
}

IDD_DFMSETTINGS DIALOG 0, 0, 210, 135
CAPTION "Impostazioni DFM Delphi"
STYLE DS_CENTER | DS_MODALFRAME | WS_POPUPWINDOW | WS_CAPTION
FONT 9, "MS Shell Dlg"
{
    LTEXT "Le seguenti impostazioni sono rilevanti per DFM Delphi:", -1, 35, 5, 171, 20
    ICON IDI_DFMICON, -1, 5, 5, 0, 0
    RTEXT "Pagina &codice:", -1, 6, 32, 70, 12
    COMBOBOX cmb1, 85, 30, 120, 300, CBS_HASSTRINGS | CBS_AUTOHSCROLL | CBS_DROPDOWN | WS_VSCROLL | WS_TABSTOP
    AUTOCHECKBOX "&Inserisci stringa grezza commenti", chx1, 5, 50, 200, 14
    AUTOCHECKBOX "Non usare Unicode e UTF-8", chx2, 5, 70, 200, 14
    DEFPUSHBUTTON "OK", IDOK, 80, 115, 60, 14
    PUSHBUTTON "Annulla", IDCANCEL, 145, 115, 60, 14
}

IDD_COPYTOMULTILANG DIALOG 0, 0, 200, 195
CAPTION "Copia in più lingue"
STYLE DS_CENTER | DS_MODALFRAME | WS_POPUPWINDOW | WS_CAPTION
FONT 9, "MS Shell Dlg"
{
    LTEXT "Aggiungi le lingue in cui desideri copiare la risorsa:", -1, 5, 5, 190, 22
    LTEXT "&Le lingue:", -1, 5, 35, 82, 12
    LISTBOX lst1, 5, 50, 190, 100, LBS_WANTKEYBOARDINPUT | LBS_NOINTEGRALHEIGHT | LBS_HASSTRINGS | WS_VSCROLL | WS_TABSTOP
    COMBOBOX cmb3, 5, 155, 126, 14, CBS_HASSTRINGS | CBS_AUTOHSCROLL | CBS_DROPDOWN | WS_BORDER | WS_VSCROLL | WS_TABSTOP
    PUSHBUTTON "&Aggiungi", psh1, 135, 155, 60, 14
    DEFPUSHBUTTON "OK", IDOK, 5, 175, 60, 14
    PUSHBUTTON "Annulla", IDCANCEL, 70, 175, 60, 14
}

IDD_TOOLBARRES DIALOG 0, 0, 230, 195
CAPTION "Risorsa barra strumenti"
STYLE DS_CENTER | DS_MODALFRAME | WS_POPUPWINDOW | WS_CAPTION
FONT 9, "MS Shell Dlg"
{
    RTEXT "&Larghezza icona:", -1, 5, 5, 60, 15, SS_CENTERIMAGE | NOT WS_GROUP
    EDITTEXT edt1, 70, 5, 30, 15, ES_NUMBER | ES_RIGHT
    CONTROL "", scr1, "msctls_updown32", UDS_NOTHOUSANDS | UDS_ARROWKEYS | UDS_AUTOBUDDY | UDS_ALIGNRIGHT | UDS_SETBUDDYINT, 80, 5, 30, 15
    RTEXT "&Altezza icona:", -1, 110, 5, 60, 15, SS_CENTERIMAGE | NOT WS_GROUP
    EDITTEXT edt2, 180, 5, 30, 15, ES_NUMBER | ES_RIGHT
    CONTROL "", scr2, "msctls_updown32", UDS_NOTHOUSANDS | UDS_ARROWKEYS | UDS_AUTOBUDDY | UDS_ALIGNRIGHT | UDS_SETBUDDYINT, 190, 5, 30, 15
    LTEXT "&Pulsanti barra strumenti:", -1, 5, 25, 140, 15, SS_CENTERIMAGE | NOT WS_GROUP
    LISTBOX lst1, 5, 40, 140, 130, LBS_DISABLENOSCROLL | LBS_WANTKEYBOARDINPUT | LBS_NOINTEGRALHEIGHT | LBS_HASSTRINGS | LBS_OWNERDRAWFIXED | WS_VSCROLL | WS_TABSTOP
    PUSHBUTTON "&Aggiungi...", psh1, 150, 40, 75, 15
    PUSHBUTTON "&Modifica...", psh2, 150, 60, 75, 15
    PUSHBUTTON "&Elimina", psh3, 150, 80, 75, 15
    PUSHBUTTON "&Su", psh4, 150, 135, 75, 15
    PUSHBUTTON "&Giù", psh5, 150, 155, 75, 15
    DEFPUSHBUTTON "OK", IDOK, 5, 175, 60, 15
    PUSHBUTTON "Annulla", IDCANCEL, 70, 175, 60, 15
}

IDD_ADDTBBTN DIALOG 0, 0, 177, 92
CAPTION "Aggiungi pulsante barra strumenti"
STYLE DS_CENTER | DS_MODALFRAME | WS_POPUPWINDOW | WS_CAPTION
FONT 9, "MS Shell Dlg"
{
    LTEXT "&ID comando pulsante barra strumenti:", -1, 5, 5, 160, 15, SS_CENTERIMAGE | NOT WS_GROUP
    COMBOBOX cmb1, 5, 25, 150, 150, CBS_HASSTRINGS | CBS_AUTOHSCROLL | CBS_DROPDOWN | WS_VSCROLL | WS_TABSTOP
    AUTOCHECKBOX "&Separatore", chx1, 5, 45, 90, 15
    DEFPUSHBUTTON "OK", IDOK, 45, 70, 60, 15
    PUSHBUTTON "Annulla", IDCANCEL, 110, 70, 60, 15
}

IDD_MODIFYTBBTN DIALOG 0, 0, 177, 92
CAPTION "Modifica pulsante barra strumenti"
STYLE DS_CENTER | DS_MODALFRAME | WS_POPUPWINDOW | WS_CAPTION
FONT 9, "MS Shell Dlg"
{
    LTEXT "&ID comando pulsante barra strumenti:", -1, 5, 5, 160, 15, SS_CENTERIMAGE | NOT WS_GROUP
    COMBOBOX cmb1, 5, 25, 150, 150, CBS_HASSTRINGS | CBS_AUTOHSCROLL | CBS_DROPDOWN | WS_VSCROLL | WS_TABSTOP
    AUTOCHECKBOX "&Separatore", chx1, 5, 45, 90, 15
    DEFPUSHBUTTON "OK", IDOK, 45, 70, 60, 15
    PUSHBUTTON "Annulla", IDCANCEL, 110, 70, 60, 15
}

//////////////////////////////////////////////////////////////////////////////
// RT_VERSION

1 VERSIONINFO
FILEVERSION     5, 7, 9, 0
PRODUCTVERSION  5, 7, 9, 0
FILEOS          0x40004
FILETYPE        0x1
FILESUBTYPE     0x0
{
    BLOCK "StringFileInfo"
    {
        BLOCK "041004E4"
        {
            VALUE "CompanyName", "Katayama Hirofumi MZ\0"
            VALUE "FileDescription", "RisohEditor\0"
            VALUE "FileVersion", "5.7.9\0"
            VALUE "LegalCopyright", "Copyright (C) 2017-2020 Katayama Hirofumi MZ e R.B. Tutti i diritti riservati.\0"
            VALUE "ProductName", "RisohEditor\0"
            VALUE "ProductVersion", "5.7.9\0"
        }
    }
    BLOCK "VarFileInfo"
    {
        VALUE "Translation", 0x0410, 0x04E4
    }
}

//////////////////////////////////////////////////////////////////////////////
// RISOHTEMPLATE

4 RISOHTEMPLATE "res/1040_RISOHTEMPLATE_4.bin"

5 RISOHTEMPLATE "res/1040_RISOHTEMPLATE_5.bin"

//////////////////////////////////////////////////////////////////////////////
// RT_STRING

STRINGTABLE
{
    IDS_APPNAME, "RisohEditor 5.7.9 di Katayama Hirofumi MZ"
    IDS_TITLEWITHFILE, "RisohEditor 5.7.9 - File: %s"
    IDS_EXTRACTRES, "Estrai risorse"
    IDS_RESBINFILTER, "File risorse binarie (*.res)|*.res|File binario (*.bin)|*.bin|Tutti i file (*.*)|*.*|"
    IDS_CANNOTSAVE, "Impossibile salvare."
    IDS_REPLACERES, "Sostituisci risorsa"
    IDS_ALLFILES, "Tutti i file (*.*)|*.*|"
    IDS_ENTERTYPE, "Inserisci tipo risorsa."
    IDS_ENTERNAME, "Inserisci nome risorsa."
    IDS_ENTERLANG, "Inserisci lingua risorsa."
    IDS_FILENOTFOUND, "File non trovato."
    IDS_CANNOTREPLACE, "Impossibile sostituire."
    IDS_EXERESFILTER, "File eseguibile (*.exe;*.dll;*.ocx;*.cpl;*.scr;*.mui)|*.exe;*.dll;*.ocx;*.cpl;*.scr;*.mui|File RC (*.rc)|*.rc|File risorse binarie (*.res)|*.res|Tutti i file (*.*)|*.*|"
    IDS_SAVEAS, "Salva come"
    IDS_CANNOTADDICON, "Impossibile aggiungere l'icona."
    IDS_ADDICON, "Aggiungi icona"
    IDS_ICOFILTER, "File icone (*.ico)|*.ico|Tutti i file (*.*)|*.*|"
    IDS_REPLACEICO, "Sostituisci icona"
    IDS_CANTREPLACEICO, "Impossibile sostituire l'icona."
    IDS_EXISTSOVERWRITE, "L'elemento esiste già.\r\nVuoi sovrascriverlo?"
    IDS_OPEN, "Apri"
    IDS_CANNOTOPEN, "Impossibile aprire il file."
    IDS_ADDBMP, "Aggiungi bitmap"
    IDS_BMPFILTER, "File bitmap (*.bmp)|*.bmp|File PNG (*.png)|*.png|Tutti i file (*.*)|*.*|"
    IDS_CANTREPLACEBMP, "Impossibile sostituire la bitmap."
    IDS_REPLACEBMP, "Sostituisci bitmap"
    IDS_ERRORCODE, "Codice errore %d"
    IDS_VERSIONINFO, "RisohEditor versione 5.7.9\r\n\r\nAutore: Katayama Hirofumi MZ\r\n\r\nLicenza: GPLv3 (free software)"
    IDS_ADDRES, "Aggiungi risorsa"
    IDS_CANNOTADDRES, "Impossibile aggiungere la risorsa."
    IDS_CANTADDBMP, "Impossibile aggiungere la bitmap."
    IDS_EXTRACTBMP, "Estrai bitmaps"
    IDS_CANTEXTRACTBMP, "Impossibile estrarre la bitmap."
    IDS_CANTREPLACECUR, "Impossibile sostituire il cursore."
    IDS_CANNOTADDCUR, "Impossibile aggiungere il cursore."
    IDS_CURFILTER, "File cursori (*.cur)|*.cur|File Cursori animati (*.ani)|*.ani|Tutti i file (*.*)|*.*|"
    IDS_ADDCUR, "Aggiungi cursore"
    IDS_REPLACECUR, "Sostituisci cursore"
    IDS_EXTRACTICO, "Estrai icona"
    IDS_CANTEXTRACTICO, "Impossibile estrarre l'icona."
    IDS_EXTRACTCUR, "Estrai cursore"
    IDS_CANTEXTRACTCUR, "Impossibile estrarre il cursore."
    IDS_RESFILTER, "File risorse binarie (*.res)|*.res|Tutti i file (*.*)|*.*|"
    IDS_NEUTRAL, "Neutrale"
    IDS_IMPORTRES, "Importa"
    IDS_CANNOTIMPORT, "Impossibile importare la risorsa."
    IDS_COMPILE, "Compila (F8)"
    IDS_CANCELEDIT, "Annulla modifica (Ctrl+E)"
    IDS_GUIEDIT, "Modifica via GUI (Ctrl+G)"
    IDS_CANNOTSTARTUP, "Impossibile avviare compilatore risorse."
    IDS_RESMISMATCH, "Mancata corrispondenza risorsa."
    IDS_SAMPLETEXT, "Questo è un esempio."
    IDS_ALREADYEXISTS, "Esiste già."
    IDS_KEY, "Chiave"
    IDS_FLAGS, "Flag"
    IDS_COMMANDID, "ID comando"
    IDS_INVALIDKEY, "Chiave non valida."
    IDS_COMPILEERROR, "Compilazione fallita."
    IDS_STRINGID, "ID stringa"
    IDS_STRINGVALUE, "Valore stringa"
    IDS_CAPTION, "Titolo"
    IDS_HELPID, "ID guida"
    IDS_INDENT, "» "
    IDS_DATAISEMPTY, "Dati vuoti."
    IDS_TEST, "Effettua test"
    IDS_SEPARATOR, "---"
    IDS_COMPILENOW, "I dati sono stati modificati.\r\nVuoi compilare ora?"
    IDS_RADWINDOW, "Modifica finestra dialogo"
    IDS_ENTERCLASS, "Inserisci un nome classe finestra valido."
    IDS_TEXTEDIT, "Modifica testo (Ctrl+T)"
    IDS_CURSORINFO, "Immagine #%u: larghezza %u, altezza %u, n. bit %u, xHotSpot %u, yHotSpot %u, ID %u\r\n"
    IDS_IMAGECOUNT, "N. immagini: %u\r\n"
    IDS_ICONINFO, "Immagine #%u: larghezza %u, altezza %u, n. bit %u, ID %u\r\n"
    IDS_READY, "Pronto"
    IDS_EXECUTINGCMD, "Esecuzione comando..."
    IDS_EDITINGBYGUI, "Modifica via GUI..."
    IDS_COORD, "%d, %d, %d, %d"
    IDS_STARTING, "Avvio..."
    IDS_COMPILING, "Compilazione..."
    IDS_CANNOTLOAD, "Impossibile caricare."
    IDS_NONE, "(Nessuno)"
    IDS_WAVESOUND, "(Audio WAVE)\r\n"
    IDS_IDTYPE, "Tipo ID"
    IDS_IDPREFIX, "Prefisso ID"
    IDS_EMPTYSTR, "Inserisci una stringa."
    IDS_ANICURSOR, "(Cursore animato)\r\n"
    IDS_ANIICON, "(Icona animata)\r\n"
    IDS_HEADFILTER, "File intestazione (*.h)|*.h|Tutti i file (*.*)|*.*|"
    IDS_LOADRESH, "Carica file 'resource.h'"
    IDS_NAME, "Nome"
    IDS_VALUE, "Valore"
    IDS_NOSUCHID, "Nessun ID trovato."
    IDS_IMAGEINFO, "Larghezza %u, altezza %u, bit x pixel %u\r\n"
    IDS_ENTERINT, "Inserisci un valore intero valido."
    IDS_ENTERTEXT, "Inserisci un testo valido."
    IDS_ENTERID, "Inserisci un ID valido."
    IDS_ADDNEXTIDS, "Aggiungi i seguenti ID a 'resource.h':\r\n\r\n"
    IDS_DELETENEXTIDS, "Elimina i seguenti ID da 'resource.h':\r\n\r\n"
    IDS_NOCHANGE, "Nessuna modifica ID risorsa."
    IDS_DLGFAIL, "Creazione finestra dialogo RAD fallita."
    IDS_LOADWCLIB, "Carica una libreria classi finestra"
    IDS_AVIMOVIE, "(Filmato AVI)\r\n"
    IDS_ADDDIALOG, "Aggiungi finestra dialogo"
    IDS_ADDMENU, "Aggiungi menu"
    IDS_ADDVERINFO, "Aggiungi InfoVersione"
    IDS_ADDCURSOR, "Aggiungi cursore"
    IDS_NOMOREITEM, "Nessun altro elemento."
    IDS_INVALIDDATA, "(dati non validi)\r\n"
    IDS_UPDATERESH, "Vuoi aggiornare 'resource.h'?"
    IDS_CANTWRITERESH, "Impossibile scrivere 'resource.h'."
    IDS_SAVERESH, "Salva file 'resource.h'"
    IDS_DLLFILTER, "File DLL (*.dll;*.ocx;*.mui)|*.dll;*.ocx;*.mui|Tutti i file (*.*)|*.*|"
    IDS_EXERESRCFILTER, "File caricabile (*.exe;*.dll;*.ocx;*.cpl;*.scr;*.mui;*.res;*.rc)|*.exe;*.dll;*.ocx;*.cpl;*.scr;*.mui;*.res;*.rc|File eseguibile (*.exe;*.dll;*.ocx;*.cpl;*.scr;*.mui)|*.exe;*.dll;*.ocx;*.cpl;*.scr;*.mui|File risorse binarie (*.res)|*.res|File risorse (*.rc)|*.rc|Tutti i file (*.*)|*.*|"
    IDS_CANTTESTCHILDWND, "Impossibile provare la finestra di dialogo poiché è una finestra figlia."
    IDS_CANTTESTCLASSDLG, "Impossibile provare la finestra di dialogo poiché è una classe."
    IDS_FILEISUPXED, "Il file\r\n\r\n'%s'\r\n\r\nè compresso con UPX.\r\nVuoi estrarlo usando un file temporaneo?\r\n\r\nSe lo estrai, la lettura potrebbe fallire."
    IDS_CANTUPXEXTRACT, "Estrazione con UPX fallita."
    IDS_CANTSAVEUPXED, "Impossibile salvare il file poiché è compresso con UPX."
    IDS_MESSAGEID, "ID messaggio"
    IDS_MESSAGEVALUE, "Valore messaggio"
    IDS_RCFILTER, "File RC (*.rc)|*.rc|"
    IDS_EXPORT, "Esporta"
    IDS_CANTEXPORT, "Esportazione fallita."
    IDS_MUSTBEEMPTYDIR, "Se c'è un qualsiasi file esterno, la destinazione esportazione deve essere una cartella vuota."
    IDS_FULLWIDTH, "０１２３４５６７８９ＡＢＣＤＥＦＧＨＩＪＫＬＭＮＯＰＱＲＳＴＵＶＷＸＹＺａｂｃｄｅｆｇｈｉｊｋｌｍｎｏｐｑｒｓｔｕｖｗｘｙｚ－＿（）．　"
    IDS_HALFWIDTH, "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz-_(). "
    IDS_MACRONAME, "Nome macro"
    IDS_MACROVALUE, "Valore macro"
    IDS_OPTIONAL, "(Opzionale)"
    IDS_ADDINCLUDE, "Aggiungi cartella Include"
    IDS_EDITINCLUDE, "Modifica cartella Include"
    IDS_WINDRESEXE, "windres.exe|windres.exe|"
    IDS_CPPEXE, "cpp.exe|cpp.exe|"
    IDS_INVALIDPATH, "Percorso non valido."
    IDS_DATATOOLONG, "Il dato è troppo lungo."
    IDS_ALL, "(Tutti)"
    IDS_UNKNOWNFORMAT, "(Formato dati sconosciuto)\r\n"
    IDS_LANGUAGE, "Lingua"
    IDS_INTVALUE, "Valore intero"
    IDS_PARENTWND, "Finestra test genitore"
    IDS_CHOOSE_OLE_CLSID, "Scegli CLSID OLE"
    IDS_CONTROL, "Controllo"
    IDS_MESSAGE, "Messaggio"
    IDS_STRING, "Stringa"
    IDS_DATAISINVALID, "Il dato non è valido."
    IDS_DLGINIT1, "Puoi specificare l'inizializzazione dei combobox e box elenco impostando i dati inizializzazione nei dati risorsa di RT_DLGINIT con lo stesso nome della risorsa finestra di dialogo."
    IDS_DLGINIT2, "Quando arriva il messaggio WM_INITDIALOG, l'applicazione può inizializzare la finestra di dialogo chiamando la funzione 'ExecuteDlgInitDx' del file allegato 'DlgInit/DlgInit.h'.\r\n\r\n"
    IDS_DLGINIT3, "Specifica per RT_DLGINIT un elenco di stringhe carattere separate da un ritorno a capo."
    IDS_SAMELANG, "È la stessa lingua."
    IDS_SAMENAME, "È lo stesso nome risorsa."
    IDS_CANTSAVETOEXE, "Impossibile salvare come EXE da un file non eseguibile."
    IDS_CANTSTARTSEARCH, "Impossibile avviare la ricerca."
    IDS_AMERICA, "America"
    IDS_ENGLISH, "Inglese"
    IDS_CHINA, "Cina"
    IDS_CHINESE, "Cinese"
    IDS_RUSSIA, "Russia"
    IDS_RUSSIAN, "Russo"
    IDS_WANNAGENRESH, "Vuoi generare il file 'resource.h'?"
    IDS_EXEFILTER, "File eseguibile (*.exe;*.dll;*.ocx;*.cpl;*.scr;*.mui)|*.exe;*.dll;*.ocx;*.cpl;*.scr;*.mui|Tutti i file (*.*)|*.*|"
    IDS_SAVEASCOMPRESS, "Salva con compressione"
    IDS_TOOL_NEW, "Nuovo"
    IDS_TOOL_OPEN, "Apri..."
    IDS_TOOL_SAVE, "Salva come..."
    IDS_TOOL_EXPAND, "Espandi tutto"
    IDS_TOOL_COLLAPSE, "Riduci tutto"
    IDS_TOOL_PLUS, "Aggiungi elemento..."
    IDS_TOOL_MINUS, "Elimina elemento"
    IDS_TOOL_CHANGE, "Modifica nome/lingua"
    IDS_TOOL_CLONE, "Clona con un altro nome/lingua"
    IDS_TOOL_RECOMPILE, "Ricompila"
    IDS_TOOL_CANCELEDIT, "Annulla modifica"
    IDS_TOOL_IMPORT, "Importa..."
    IDS_TOOL_EXTRACT, "Estrai..."
    IDS_TOOL_GUIEDIT, "Modifica via GUI"
    IDS_UNITEDKINGDOM, "Regno Unito"
    IDS_GREATBRITAIN, "Gran Bretagna"
    IDS_BRITISH, "Britannico"
    IDS_FRANCE, "Francia"
    IDS_FRENCH, "Francese"
    IDS_GERMANY, "Germania"
    IDS_GERMAN, "Tedesco"
    IDS_SPAIN, "Spagna"
    IDS_SPANISH, "Spagnolo"
    IDS_INVALIDLANG, "Lingua non riconosciuta."
    IDS_INVALIDNAME, "Nome risorsa non valido."
    IDS_PNGRESBINFILTER, "File immagine PNG (*.png)|*.png|File risorse binarie (*.res)|*.res|File binario (*.bin)|*.bin|Tutti i file (*.*)|*.*|"
    IDS_JPEGRESBINFILTER, "File immagine JPEG (*.jpg;*.jpeg;*.jpe;*.jfif)|*.jpg;*.jpeg;*.jpe;*.jfif|File risorse binarie (*.res)|*.res|File binario (*.bin)|*.bin|Tutti i file (*.*)|*.*|"
    IDS_GIFRESBINFILTER, "File immagine GIF (*.gif)|*.gif|Risorse binarie (*.res)|*.res|File binario (*.bin)|*.bin|Tutti i file (*.*)|*.*|"
    IDS_TIFFRESBINFILTER, "File immagine TIFF (*.tif;*.tiff)|*.tif;*.tiff|File risorse binarie (*.res)|*.res|File binario (*.bin)|*.bin|Tutti i file (*.*)|*.*|"
    IDS_AVIRESBINFILTER, "File filmato AVI (*.avi)|*.avi|File risorse binarie (*.res)|*.res|File binario (*.bin)|*.bin|Tutti i file (*.*)|*.*|"
    IDS_WAVERESBINFILTER, "File audio WAVE (*.wav)|*.wav|File risorse binarie (*.res)|*.res|File binario (*.bin)|*.bin|Tutti i file (*.*)|*.*|"
    IDS_COMMENT_SEP, "//////////////////////////////////////////////////////////////////////////////\r\n\r\n"
    IDS_NEWLINE, "\r\n"
    IDS_NOTICE, "// Questo file è automaticamente generato da RisohEditor 5.7.9.\r\n"
    IDS_DAGGER, "// † <-- Questo dagger aiuta il rilevamento UTF-8.\r\n"
    IDS_IMPORTFILTER, "File importabile|*.rc;*.res;*.dfm;*.html;*.htm;*.manifest;*.ico;*.cur;*.ani;*.wav;*.bmp;*.dib;*.png;*.gif;*.jpg;*.jpeg;*.jpe;*.jfif;*.tif;*.tiff;*.avi;*.wmf;*.emf|File RC (*.rc)|*.rc|File risorse binarie (*.res)|*.res|File immagine|*.bmp;*.dib;*.png;*.gif;*.jpg;*.jpeg;*.jpe;*.jfif;*.tif;*.tiff;*.wmf;*.emf;*.tlb|File cursore (*.cur;*.ani)|*.cur;*.ani|File icone (*.ico)|*.ico|File audio WAVE (*.wav)|*.wav|File HTML (*.html;*.htm)|*.html;*.htm|File manifest (*.manifest)|*.manifest|File Delphi DFM (*.dfm)|*.dfm|File TYPELIB (*.tlb)|*.tlb|Tutti i file (*.*)|*.*|"
    IDS_CANTWRITEBYLOCK, "Impossibile scrivere il file poiché il file seguente è bloccato.\r\n\r\n%s"
    IDS_ANSI, "ANSI"
    IDS_WIDE, "Unicode"
    IDS_UTF8, "UTF-8 (con BOM)"
    IDS_UTF8N, "UTF-8 (senza BOM)"
    IDS_SJIS, "Shift_JIS"
    IDS_BINARY, "(dati binari)"
    IDS_RESTYPE, "Tipo risorsa"
    IDS_ENCODING, "Codifica"
    IDS_INVALIDRESTYPE, "Tipo risorsa non valida."
    IDS_PATHSPACEERROR, "Hai erroneamente installato RisohEditor in un percorso con uno spazio nel nome.\r\nIl compilatore risorse RisohEditor non accetta spazi nel nome percorso.\r\n\r\nMeglio evitare percorsi tipo ""C:\\Program Files""."
    IDS_LOADEGAPROGRAM, "Carica programma EGA..."
    IDS_EGAFILTER, "file programma EGA(*.ega)|*.ega|Tutti i file (*.*)|*.*|"
    IDS_QUERYSAVECHANGE, "Il file è stato modificato.\r\nVuoi salvare le modifiche ora?"
    IDS_DFMFILTER, "File DFM (*.dfm)|*.dfm|File testo (*.txt)|*.txt|Tutti i file (*.*)|*.*|"
    IDS_CANTEXTRACTDFM, "Impossibile estrarre i dati DFM."
    IDS_EXTRACTDFM, "Estrai i dati DFM"
    IDS_ENTERNONZERONAME, "Inserisci un nome risorsa non-zero."
    IDS_ENTERNONZEROTYPE, "Inserisci un nome risorsa non-zero."
    IDS_HOMEPAGE, "https://katahiromz.web.fc2.com/re/it/"
    IDS_FILESAVED, "Salvataggio file completato."
    IDS_RECOMPILEOK, "Ricompilazione completata."
    IDS_RECOMPILEFAILED, "Ricompilazione fallita (errore sintassi)."
    IDS_TOOL_EXPORT, "Esporta..."
    IDS_CODEEDITOR, "Editor codice"
    IDS_HEXVIEWER, "Visualizzatore HEX"
    IDS_INTEGERORIDENTIFIER, "(intero o identificatore)"
    IDS_NOTEXT, " "
    IDS_NOUPDATE, "La versione di RisohEditor installata è aggiornata."
    IDS_THEREISUPDATE, "È disponibile RisohEditor v. %s. \r\nVuoi scaricarlo ora?"
    IDS_CANTCHECKUPDATE, "Verifica aggiornamenti RisohEditor fallita."
    IDS_CODEPAGE1252, "1252 (Latino 1)"
    IDS_CODEPAGE1250, "1250 (Latino 2)"
    IDS_CODEPAGE1251, "1251 (Cirillico)"
    IDS_CODEPAGE1253, "1253 (Greco)"
    IDS_CODEPAGE1254, "1254 (Turco)"
    IDS_CODEPAGE1255, "1255 (Ebraico)"
    IDS_CODEPAGE1256, "1256 (Arabo)"
    IDS_CODEPAGE1257, "1257 (Baltico)"
    IDS_CODEPAGE874, "874 (Tailandese)"
    IDS_CODEPAGE932, "932 (Giapponese)"
    IDS_CODEPAGE936, "936 (Cinese semplificato)"
    IDS_CODEPAGE949, "949 (Coreano)"
    IDS_CODEPAGE950, "950 (Cinese tradizionale)"
    IDS_CODEPAGE65001, "65001 (UTF-8)"
    IDS_EXTRACTTLB, "Estrai dati TYPELIB data"
    IDS_CANTEXTRACTTLB, "Impossibile estrarre dati TYPELIB."
    IDS_TLBRESBINFILTER, "Dati TYPELIB (*.tlb)|*.tlb|Risorse binarie (*.res)|*.res|File testo (*.txt)|*.txt|File MIDL (*.idl)|*.idl|Tutti i file (*.*)|*.*|"
    IDS_USAGE, "Uso: RisohEditor [opzioni | ""file""]\n\nOpzioni:\n--help  visualizza questo messaggio.\n--version  visualizza informazioni sulla versione.\n--load ""your-file.rc""  Carica il file (senza GUI)\n--save ""your-file.res""  Salva il file (senza GUI)\n--log-file ""log-file.txt""  specifica il file registro.\n--load-options OPZIONI  imposta le opzioni di caricamento.\n--save-options OPZIONI  imposta le opzioni di salvataggio.\n\nOpzioni caricamento: (no-load-res-h)\nOpzioni salvataggio: (idc-static)(compress)(sep-lang)(no-res-folder)(lang-macro)(less-comments)(wrap-manifest)(begin-end)(utf-16)(backup)(ms-msgtbl)"
    IDS_NOSELECTION, "Non c'è selezione."
    IDS_TRANSLATORS, "[Translators]\r\nCinese semplificato: 林鸿湘\r\nCoreano: VenusGirl (비너스걸)\r\nGiapponese: Katayama Hirofumi MZ\r\nInglese: Katayama Hirofumi MZ\r\nFinlandese: Veikko Muurikainen\r\nIndonesiano: Mas Ahmad Muhammad\r\nItaliano: R.B.\r\nPolacco: Piotr Hetnarowicz\r\nPortoghese: JNylson\r\nRusso: Dmitry Yerokhin\r\n"
}

//////////////////////////////////////////////////////////////////////////////

```

`src/lang/ja_JP.rc`:

```rc
// This file is automatically generated by RisohEditor 5.7.9.
// † <-- This dagger helps UTF-8 detection.

#pragma code_page(65001) // UTF-8

LANGUAGE LANG_JAPANESE, SUBLANG_DEFAULT

//////////////////////////////////////////////////////////////////////////////
// RT_MENU

IDR_MAINMENU MENU
{
    POPUP "ファイル(&F)"
    {
        MENUITEM "新規作成(&N)\tCtrl+N", ID_NEW
        MENUITEM SEPARATOR
        MENUITEM "開く(&O)...\tCtrl+O", ID_OPEN
        MENUITEM "上書き保存(&S)...\tCtrl+S", ID_SAVE
        MENUITEM "名前を付けて保存(&A)...\tShift+Ctrl+S", ID_SAVEAS
        MENUITEM "名前を付けて圧縮保存(&M)...", ID_SAVEASCOMPRESS
        MENUITEM SEPARATOR
        MENUITEM "インポート(&I)...\tCtrl+I", ID_IMPORT
        MENUITEM "エクスポート(&E)...\tCtrl+P", ID_EXPORT
        MENUITEM SEPARATOR
        MENUITEM "&resource.h の再読み込み...\tCtrl+R", ID_LOADRESH
        MENUITEM "resource.h を保存する(&S)...", ID_UPDATERESHBANG
        MENUITEM "resource.h の変更を助言する(&V)...", ID_ADVICERESH
        MENUITEM "resource.h のアンロード(&U)", ID_UNLOADRESH
        MENUITEM SEPARATOR
        MENUITEM "ウィンドウ クラス ライブラリを読み込む(&W)...", ID_LOADWCLIB
        MENUITEM SEPARATOR
        POPUP "最近使ったファイル(&R)"
        {
            MENUITEM "(なし)", -1, GRAYED
        }
        MENUITEM SEPARATOR
        MENUITEM "終了(&X)\tAlt+F4", ID_EXIT
    }
    POPUP "編集(&E)"
    {
        MENUITEM "&GUI編集...\tCtrl+G", ID_GUIEDIT
        MENUITEM SEPARATOR
        POPUP "追加(&A)"
        {
            MENUITEM "アイコンを追加(&I)...", ID_ADDICON
            MENUITEM "カーソルを追加(&C)...", ID_ADDCURSOR
            MENUITEM "ビットマップを追加(&B)...", ID_ADDBITMAP
            MENUITEM "ダイアログを追加(&D)...", ID_ADDDIALOG
            MENUITEM "メニューを追加(&M)...", ID_ADDMENU
            MENUITEM "文字列テーブルを追加(&S)...", ID_ADDSTRINGTABLE
            MENUITEM "メッセージ テーブルを追加(&E)...", ID_ADDMESSAGETABLE
            MENUITEM "&HTMLを追加...", ID_ADDHTML
            MENUITEM "アクセスキーを追加(&A)...", ID_ADDACCEL
            MENUITEM "バージョン情報を追加(&V)...", ID_ADDVERINFO
            MENUITEM "マニフェストを追加(&F)...", ID_ADDMANIFEST
            MENUITEM "ツールバーを追加(&T)...", ID_ADDTOOLBAR
            MENUITEM "リソース項目を追加(&R)...", ID_ADDRES
        }
        POPUP "置き換え(&R)"
        {
            MENUITEM "アイコンを置き換え(&I)...", ID_REPLACEICON
            MENUITEM "カーソルを置き換え(&C)...", ID_REPLACECURSOR
            MENUITEM "ビットマップを置き換え(&B)...", ID_REPLACEBITMAP
            MENUITEM "バイナリ リソース項目を置き換え(&R)...", ID_REPLACEBIN
        }
        POPUP "抽出(&E)"
        {
            MENUITEM "アイコンを抽出(&I)...", ID_EXTRACTICON
            MENUITEM "カーソルを抽出(&C)...", ID_EXTRACTCURSOR
            MENUITEM "ビットマップを抽出(&B)...", ID_EXTRACTBITMAP
            MENUITEM "RC ファイルとして抽出(&A)...", ID_EXTRACTRC
            MENUITEM "バイナリ リソース項目を抽出(&R)...", ID_EXTRACTBIN
        }
        MENUITEM SEPARATOR
        MENUITEM "名前/言語を変更(&H)\tF2", ID_EDITLABEL
        MENUITEM SEPARATOR
        MENUITEM "別の名前で複製(&N)...", ID_COPYASNEWNAME
        MENUITEM "別の言語で複製(&L)...", ID_COPYASNEWLANG
        MENUITEM "複数の言語へ複製...", ID_COPYTOMULTILANG
        MENUITEM SEPARATOR
        MENUITEM "テストする(&T)", ID_TEST
        MENUITEM SEPARATOR
        MENUITEM "削除(&D)\tDel", ID_DELETERES
        MENUITEM SEPARATOR
        MENUITEM "&IDの関連付け...", ID_IDASSOC
        MENUITEM "定義済みマクロ(&M)...", ID_PREDEFMACROS
        MENUITEM "フォント設定(&F)...", ID_FONTS
        MENUITEM "PATHの設定(&P)...", ID_SETPATHS
        MENUITEM SEPARATOR
        MENUITEM "&UI Language Select (UI语言选择)...", ID_CHOOSEUILANG
        MENUITEM SEPARATOR
        MENUITEM "Delphi DFM の設定(&S)...", ID_DFMSETTINGS
        MENUITEM "設定(&C)...", ID_CONFIG
    }
    POPUP "検索(&S)"
    {
        MENUITEM "検索(&F)...\tCtrl+F", ID_FIND
        MENUITEM SEPARATOR
        MENUITEM "上検索(&U)\tShift+F3", ID_FINDUPWARD
        MENUITEM "下検索(&D)\tF3", ID_FINDDOWNWARD
        MENUITEM SEPARATOR
        MENUITEM "定数を問い合わせ(&Q)", ID_QUERYCONSTANT
    }
    POPUP "表示(&V)"
    {
        MENUITEM "ステータス バー(&S)", ID_STATUSBAR
        MENUITEM "ツール バー(&T)", ID_SHOWHIDETOOLBAR
        MENUITEM "バイナリー(&B)", ID_BINARYPANE
        MENUITEM SEPARATOR
        MENUITEM "すべて展開(&X)\tCtrl+K", ID_EXPAND_ALL
        MENUITEM "すべて折りたたむ(&O)\tCtrl+L", ID_COLLAPSE_ALL
        MENUITEM SEPARATOR
        MENUITEM "リソースIDの一覧(&R)", ID_IDLIST
        MENUITEM "言語の一覧(&L)...", ID_SHOWLANGS
        MENUITEM SEPARATOR
        MENUITEM "常に&CONTROL文", ID_ALWAYSCONTROL
        MENUITEM "&IDマクロを使用しない", ID_HIDEIDMACROS
        MENUITEM "IDC_ST&ATICを使用する", ID_USEIDC_STATIC
        MENUITEM "行を折り返す(&W)", ID_WORD_WRAP
        MENUITEM "BE&GIN/END を使う", ID_USEBEGINEND
        MENUITEM "Microsoft のメッセージテーブルを使用する(&T)", ID_USEMSMSGTBL
        MENUITEM SEPARATOR
        MENUITEM "リソース項目のエンコーディング(&E)...", ID_ENCODING
        MENUITEM "ダイアログ フォント代替(&F)...", ID_DIALOG_FONT_SUBSTITUTES
        MENUITEM SEPARATOR
        MENUITEM "最新の情報に更新(&F)", ID_REFRESHALL
    }
    POPUP "自動化(&A)"
    {
        MENUITEM "プログラム言語 &EGA...", ID_EGA
        MENUITEM "EGA プログラムを実行する(&R)...", ID_EGA_PROGRAM
        MENUITEM "EGA マニュアルを開く(&M)", ID_OPEN_EGA_MANUAL
    }
    POPUP "ヘルプ(&H)"
    {
        MENUITEM "&README.txtを開く", ID_OPENREADME
        MENUITEM "README-&JPN.txtを開く", ID_OPENREADMEJP
        MENUITEM "&HYOJUNKA.txtを開く", ID_OPENHYOJUNKA
        MENUITEM "&HISTORY.txtを開く", ID_OPENHISTORY
        MENUITEM "HISTORY-J&PN.txtを開く", ID_OPENHISTORYJPN
        MENUITEM "&LICENSE.txtを開く", ID_OPENLICENSE
        MENUITEM SEPARATOR
        MENUITEM "まとめサイトへジャンプ(&J)", ID_GUIDE
        MENUITEM "リソーエディタの更新を確認(&U)...", ID_CHECKUPDATE
        MENUITEM SEPARATOR
        MENUITEM "バージョン情報(&A)...", ID_ABOUT
    }
}

IDR_POPUPMENUS MENU
{
    POPUP "ポップアップ #0"
    {
        MENUITEM "&GUI編集...\tCtrl+G", ID_GUIEDIT
        MENUITEM SEPARATOR
        POPUP "追加(&A)"
        {
            MENUITEM "アイコンを追加(&I)...", ID_ADDICON
            MENUITEM "カーソルを追加(&C)...", ID_ADDCURSOR
            MENUITEM "ビットマップを追加(&B)...", ID_ADDBITMAP
            MENUITEM "ダイアログを追加(&D)...", ID_ADDDIALOG
            MENUITEM "メニューを追加(&M)...", ID_ADDMENU
            MENUITEM "文字列テーブルを追加(&S)...", ID_ADDSTRINGTABLE
            MENUITEM "メッセージ テーブルを追加(&E)...", ID_ADDMESSAGETABLE
            MENUITEM "&HTMLを追加...", ID_ADDHTML
            MENUITEM "アクセスキーを追加(&A)...", ID_ADDACCEL
            MENUITEM "バージョン情報を追加(&V)...", ID_ADDVERINFO
            MENUITEM "マニフェストを追加(&F)...", ID_ADDMANIFEST
            MENUITEM "ツールバーを追加(&T)...", ID_ADDTOOLBAR
            MENUITEM "リソース項目を追加(&R)...", ID_ADDRES
        }
        POPUP "置き換え(&R)"
        {
            MENUITEM "アイコンを置き換え(&I)...", ID_REPLACEICON
            MENUITEM "カーソルを置き換え(&C)...", ID_REPLACECURSOR
            MENUITEM "ビットマップを置き換え(&B)...", ID_REPLACEBITMAP
            MENUITEM "バイナリ リソース項目を置き換え(&R)...", ID_REPLACEBIN
        }
        POPUP "抽出(&E)"
        {
            MENUITEM "アイコンを抽出(&I)...", ID_EXTRACTICON
            MENUITEM "カーソルを抽出(&C)...", ID_EXTRACTCURSOR
            MENUITEM "ビットマップを抽出(&B)...", ID_EXTRACTBITMAP
            MENUITEM "RC ファイルとして抽出(&A)...", ID_EXTRACTRC
            MENUITEM "バイナリ リソース項目を抽出(&R)...", ID_EXTRACTBIN
        }
        MENUITEM SEPARATOR
        MENUITEM "名前/言語を変更(&H)\tF2", ID_EDITLABEL
        MENUITEM SEPARATOR
        MENUITEM "別の名前で複製(&N)...", ID_COPYASNEWNAME
        MENUITEM "別の言語で複製(&L)...", ID_COPYASNEWLANG
        MENUITEM "複数の言語へ複製...", ID_COPYTOMULTILANG
        MENUITEM SEPARATOR
        MENUITEM "テストする(&T)", ID_TEST
        MENUITEM SEPARATOR
        MENUITEM "削除(&D)\tDel", ID_DELETERES
    }
    POPUP "ポップアップ #1"
    {
        MENUITEM "コントロールの追加(&A)...", ID_ADDCTRL
        MENUITEM SEPARATOR
        MENUITEM "切り取り(&T)\tCtrl+X", ID_CUT
        MENUITEM "コピー(&C)\tCtrl+C", ID_COPY
        MENUITEM "貼り付け(&P)\tCtrl+V", ID_PASTE
        MENUITEM "削除(&D)\tDel", ID_DELCTRL
        MENUITEM SEPARATOR
        POPUP "インデックス(&I)"
        {
            MENUITEM "先頭へ(&T)", ID_CTRLINDEXTOP
            MENUITEM SEPARATOR
            MENUITEM "1減らす(&D)", ID_CTRLINDEXMINUS
            MENUITEM "1増やす(&I)", ID_CTRLINDEXPLUS
            MENUITEM SEPARATOR
            MENUITEM "末尾へ(&B)", ID_CTRLINDEXBOTTOM
            MENUITEM SEPARATOR
            MENUITEM "表示の切り替え(&S)\tCtrl+D", ID_SHOWHIDEINDEX
        }
        POPUP "位置そろえ(&A)"
        {
            MENUITEM "上そろえ(&T)", ID_TOPALIGN
            MENUITEM "下そろえ(&B)", ID_BOTTOMALIGN
            MENUITEM "左そろえ(&L)", ID_LEFTALIGN
            MENUITEM "右そろえ(&R)", ID_RIGHTALIGN
            MENUITEM SEPARATOR
            MENUITEM "グリッドに合わせる(&G)", ID_FITTOGRID
        }
        MENUITEM SEPARATOR
        MENUITEM "再描画(&R)", ID_REFRESHDIALOG
        MENUITEM SEPARATOR
        MENUITEM "コントロールのプロパティ(&P)...", ID_CTRLPROP
        MENUITEM "ダイアログのプロパティ(&O)...", ID_DLGPROP
    }
    POPUP "ポップアップ #2"
    {
        MENUITEM "変更(&M)...", ID_MODIFYASSOC
    }
    POPUP "ポップアップ #3"
    {
        MENUITEM "ジャンプ(&J)!", ID_IDJUMP
        MENUITEM SEPARATOR
        MENUITEM "追加(&A)...", ID_ADDRESID
        MENUITEM "変更(&M)...", ID_MODIFYRESID
        MENUITEM SEPARATOR
        MENUITEM "名前をコピー(&N)", ID_COPYRESIDNAME
        MENUITEM "値をコピー(&V)", ID_COPYRESIDVALUE
        MENUITEM "定義をコピー(&D)\tCtrl+C", ID_COPYIDDEF
        MENUITEM SEPARATOR
        MENUITEM "削除(&D)\tDel", ID_DELETERESID
        MENUITEM SEPARATOR
        MENUITEM "10進数(&D)", ID_BASE10
        MENUITEM "16進数(&H)", ID_BASE16
        MENUITEM SEPARATOR
        MENUITEM "再読み込み(&R)", ID_LOADRESH
    }
    POPUP "ポップアップ #4"
    {
        MENUITEM "追加(&A)...", ID_ADD
        MENUITEM SEPARATOR
        MENUITEM "名前の変更(&N)...\tF2", ID_RENAME
        MENUITEM "値の変更(&V)...", ID_MODIFY
        MENUITEM SEPARATOR
        MENUITEM "削除(&D)\tDel", ID_DELETE
    }
    POPUP "ポップアップ #5"
    {
        MENUITEM "整数値をコピー(&C)", ID_COPY
    }
    POPUP "ポップアップ #6"
    {
        MENUITEM "追加(&A)...", psh1
        MENUITEM "変更(&M)...", psh2
        MENUITEM SEPARATOR
        MENUITEM "上へ(&U)", psh4
        MENUITEM "下へ(&D)", psh5
        MENUITEM "左へ(&L)", psh6
        MENUITEM "右へ(&R)", psh7
        MENUITEM SEPARATOR
        MENUITEM "削除(&T)\tDel", psh3
    }
    POPUP "ポップアップ #7"
    {
        MENUITEM "追加(&A)...", psh1
        MENUITEM "変更(&M)...", psh2
        MENUITEM SEPARATOR
        MENUITEM "上へ(&U)", psh4
        MENUITEM "下へ(&D)", psh5
        MENUITEM SEPARATOR
        MENUITEM "削除(&T)\tDel", psh3
    }
    POPUP "ポップアップ #8"
    {
        MENUITEM "追加(&A)...", ID_ADD
        MENUITEM "変更(&M)...", ID_MODIFY
        MENUITEM SEPARATOR
        MENUITEM "削除(&D)\tDel", ID_DELETE
    }
}

//////////////////////////////////////////////////////////////////////////////
// RT_DIALOG

IDD_REPLACERES DIALOGEX 0, 0, 215, 170
CAPTION "リソースの置き換え"
STYLE DS_MODALFRAME | WS_POPUPWINDOW | WS_CAPTION
FONT 9, "MS UI Gothic", 0, 0, 1
{
    LTEXT "リソースの種類(&T):", -1, 5, 7, 70, 12
    COMBOBOX cmb1, 75, 5, 135, 200, CBS_HASSTRINGS | CBS_AUTOHSCROLL | CBS_DROPDOWN | WS_BORDER | WS_VSCROLL | WS_TABSTOP
    LTEXT "リソースの名前(&N):", -1, 5, 32, 70, 12
    COMBOBOX cmb2, 75, 30, 135, 200, CBS_HASSTRINGS | CBS_AUTOHSCROLL | CBS_DROPDOWN | WS_DISABLED | WS_BORDER | WS_VSCROLL | WS_TABSTOP
    LTEXT "リソースの言語(&L):", -1, 5, 57, 70, 12
    COMBOBOX cmb3, 75, 55, 135, 200, CBS_HASSTRINGS | CBS_AUTOHSCROLL | CBS_DROPDOWN | WS_DISABLED | WS_BORDER | WS_VSCROLL | WS_TABSTOP
    LTEXT "バイナリーファイル(&F):", -1, 5, 85, 100, 12
    EDITTEXT edt1, 5, 97, 205, 14, ES_AUTOHSCROLL
    PUSHBUTTON "参照(&B)...", psh1, 150, 115, 60, 14
    DEFPUSHBUTTON "OK", IDOK, 35, 150, 60, 14
    PUSHBUTTON "キャンセル", IDCANCEL, 115, 150, 60, 14
    {
        0x1234, 0x5678, 0x0011
    }
}

IDD_ADDICON DIALOG 0, 0, 215, 135
CAPTION "アイコンの追加"
STYLE DS_MODALFRAME | WS_POPUPWINDOW | WS_CAPTION
FONT 9, "MS UI Gothic"
{
    LTEXT "アイコン ファイル(&I):", -1, 5, 7, 100, 12
    EDITTEXT edt1, 5, 18, 205, 14, ES_AUTOHSCROLL
    PUSHBUTTON "参照(&B)...", psh1, 150, 35, 60, 14
    ICON 0, ico1, 5, 35, 0, 0
    LTEXT "リソースの名前(&N):", -1, 5, 67, 70, 12
    COMBOBOX cmb2, 75, 65, 120, 300, CBS_HASSTRINGS | CBS_AUTOHSCROLL | CBS_DROPDOWN | WS_BORDER | WS_VSCROLL | WS_TABSTOP
    PUSHBUTTON "&...", psh2, 195, 65, 15, 14
    LTEXT "リソースの言語(&L):", -1, 5, 92, 70, 12
    COMBOBOX cmb3, 75, 90, 135, 200, CBS_HASSTRINGS | CBS_AUTOHSCROLL | CBS_DROPDOWN | WS_BORDER | WS_VSCROLL | WS_TABSTOP
    DEFPUSHBUTTON "OK", IDOK, 35, 115, 60, 14
    PUSHBUTTON "キャンセル", IDCANCEL, 115, 115, 60, 14
}

IDD_REPLACEICON DIALOG 0, 0, 215, 135
CAPTION "アイコンの置き換え"
STYLE DS_MODALFRAME | WS_POPUPWINDOW | WS_CAPTION
FONT 9, "MS UI Gothic"
{
    LTEXT "アイコン ファイル(&I):", -1, 5, 7, 100, 12
    EDITTEXT edt1, 5, 18, 205, 14, ES_AUTOHSCROLL
    PUSHBUTTON "参照(&B)...", psh1, 150, 35, 60, 14
    ICON 0, ico1, 5, 35, 0, 0
    LTEXT "リソースの名前(&N):", -1, 5, 67, 70, 12
    COMBOBOX cmb2, 75, 65, 135, 200, CBS_HASSTRINGS | CBS_AUTOHSCROLL | CBS_DROPDOWN | WS_DISABLED | WS_BORDER | WS_VSCROLL | WS_TABSTOP
    LTEXT "リソースの言語(&L):", -1, 5, 92, 70, 12
    COMBOBOX cmb3, 75, 90, 135, 200, CBS_HASSTRINGS | CBS_AUTOHSCROLL | CBS_DROPDOWN | WS_DISABLED | WS_BORDER | WS_VSCROLL | WS_TABSTOP
    DEFPUSHBUTTON "OK", IDOK, 35, 115, 60, 14
    PUSHBUTTON "キャンセル", IDCANCEL, 115, 115, 60, 14
}

IDD_ADDBITMAP DIALOG 0, 0, 215, 135
CAPTION "ビットマップの追加"
STYLE DS_MODALFRAME | WS_POPUPWINDOW | WS_CAPTION
FONT 9, "MS UI Gothic"
{
    LTEXT "ビットマップ ファイル(&B):", -1, 5, 7, 100, 12
    EDITTEXT edt1, 5, 18, 205, 14, ES_AUTOHSCROLL
    PUSHBUTTON "参照(&B)...", psh1, 150, 35, 60, 14
    LTEXT "リソースの名前(&N):", -1, 5, 67, 70, 12
    COMBOBOX cmb2, 75, 65, 120, 300, CBS_HASSTRINGS | CBS_AUTOHSCROLL | CBS_DROPDOWN | WS_BORDER | WS_VSCROLL | WS_TABSTOP
    PUSHBUTTON "&...", psh2, 195, 65, 15, 14
    LTEXT "リソースの言語(&L):", -1, 5, 92, 70, 12
    COMBOBOX cmb3, 75, 90, 135, 200, CBS_HASSTRINGS | CBS_AUTOHSCROLL | CBS_DROPDOWN | WS_BORDER | WS_VSCROLL | WS_TABSTOP
    DEFPUSHBUTTON "OK", IDOK, 35, 115, 60, 14
    PUSHBUTTON "キャンセル", IDCANCEL, 115, 115, 60, 14
}

IDD_REPLACEBMP DIALOG 0, 0, 215, 135
CAPTION "ビットマップの置き換え"
STYLE DS_MODALFRAME | WS_POPUPWINDOW | WS_CAPTION
FONT 9, "MS UI Gothic"
{
    LTEXT "ビットマップ ファイル(&B):", -1, 5, 7, 100, 12
    EDITTEXT edt1, 5, 18, 205, 14, ES_AUTOHSCROLL
    PUSHBUTTON "参照(&B)...", psh1, 150, 35, 60, 14
    LTEXT "リソースの名前(&N):", -1, 5, 67, 70, 12
    COMBOBOX cmb2, 75, 65, 135, 200, CBS_HASSTRINGS | CBS_AUTOHSCROLL | CBS_DROPDOWN | WS_DISABLED | WS_BORDER | WS_VSCROLL | WS_TABSTOP
    LTEXT "リソースの言語(&L):", -1, 5, 92, 70, 12
    COMBOBOX cmb3, 75, 90, 135, 200, CBS_HASSTRINGS | CBS_AUTOHSCROLL | CBS_DROPDOWN | WS_DISABLED | WS_BORDER | WS_VSCROLL | WS_TABSTOP
    DEFPUSHBUTTON "OK", IDOK, 35, 115, 60, 14
    PUSHBUTTON "キャンセル", IDCANCEL, 115, 115, 60, 14
}

IDD_ADDRES DIALOG 0, 0, 215, 170
CAPTION "リソースの追加"
STYLE DS_MODALFRAME | WS_POPUPWINDOW | WS_CAPTION
FONT 9, "MS UI Gothic"
{
    LTEXT "リソースの種類(&T):", -1, 5, 7, 70, 12
    COMBOBOX cmb1, 75, 5, 135, 200, CBS_HASSTRINGS | CBS_AUTOHSCROLL | CBS_DROPDOWN | WS_BORDER | WS_VSCROLL | WS_TABSTOP
    LTEXT "リソースの名前(&N):", -1, 5, 32, 70, 12
    COMBOBOX cmb2, 75, 30, 120, 300, CBS_HASSTRINGS | CBS_AUTOHSCROLL | CBS_DROPDOWN | WS_BORDER | WS_VSCROLL | WS_TABSTOP
    PUSHBUTTON "&...", psh2, 195, 30, 15, 14
    LTEXT "", stc1, 75, 43, 115, 10
    LTEXT "リソースの言語(&L):", -1, 5, 57, 70, 12
    COMBOBOX cmb3, 75, 55, 135, 200, CBS_HASSTRINGS | CBS_AUTOHSCROLL | CBS_DROPDOWN | WS_BORDER | WS_VSCROLL | WS_TABSTOP
    LTEXT "バイナリーファイル(&F):", -1, 5, 85, 100, 12
    EDITTEXT edt1, 5, 97, 205, 14, ES_AUTOHSCROLL
    PUSHBUTTON "参照(&B)...", psh1, 150, 115, 60, 14
    LTEXT "", stc2, 5, 112, 100, 10
    DEFPUSHBUTTON "OK", IDOK, 35, 150, 60, 14
    PUSHBUTTON "キャンセル", IDCANCEL, 115, 150, 60, 14
}

IDD_ADDCURSOR DIALOG 0, 0, 215, 135
CAPTION "カーソルの追加"
STYLE DS_MODALFRAME | WS_POPUPWINDOW | WS_CAPTION
FONT 9, "MS UI Gothic"
{
    LTEXT "カーソル ファイル(&C):", -1, 5, 7, 100, 12
    EDITTEXT edt1, 5, 18, 205, 14, ES_AUTOHSCROLL
    PUSHBUTTON "参照(&B)...", psh1, 150, 35, 60, 14
    ICON 0, ico1, 5, 35, 0, 0
    LTEXT "リソースの名前(&N):", -1, 5, 67, 70, 12
    COMBOBOX cmb2, 75, 65, 120, 200, CBS_HASSTRINGS | CBS_AUTOHSCROLL | CBS_DROPDOWN | WS_BORDER | WS_VSCROLL | WS_TABSTOP
    PUSHBUTTON "&...", psh2, 195, 65, 15, 14
    LTEXT "リソースの言語(&L):", -1, 5, 92, 70, 12
    COMBOBOX cmb3, 75, 90, 135, 200, CBS_HASSTRINGS | CBS_AUTOHSCROLL | CBS_DROPDOWN | WS_BORDER | WS_VSCROLL | WS_TABSTOP
    DEFPUSHBUTTON "OK", IDOK, 35, 115, 60, 14
    PUSHBUTTON "キャンセル", IDCANCEL, 115, 115, 60, 14
}

IDD_REPLACECUR DIALOG 0, 0, 215, 135
CAPTION "カーソルの置き換え"
STYLE DS_MODALFRAME | WS_POPUPWINDOW | WS_CAPTION
FONT 9, "MS UI Gothic"
{
    LTEXT "カーソル ファイル(&C):", -1, 5, 7, 100, 12
    EDITTEXT edt1, 5, 18, 205, 14, ES_AUTOHSCROLL
    PUSHBUTTON "参照(&B)...", psh1, 150, 35, 60, 14
    ICON 0, ico1, 5, 35, 0, 0
    LTEXT "リソースの名前(&N):", -1, 5, 67, 70, 12
    COMBOBOX cmb2, 75, 65, 135, 200, CBS_HASSTRINGS | CBS_AUTOHSCROLL | CBS_DROPDOWN | WS_DISABLED | WS_BORDER | WS_VSCROLL | WS_TABSTOP
    LTEXT "リソースの言語(&L):", -1, 5, 92, 70, 12
    COMBOBOX cmb3, 75, 90, 135, 200, CBS_HASSTRINGS | CBS_AUTOHSCROLL | CBS_DROPDOWN | WS_DISABLED | WS_BORDER | WS_VSCROLL | WS_TABSTOP
    DEFPUSHBUTTON "OK", IDOK, 35, 115, 60, 14
    PUSHBUTTON "キャンセル", IDCANCEL, 115, 115, 60, 14
}

IDD_MENUTEST DIALOG 0, 0, 215, 135
CAPTION "メニューのテスト"
STYLE DS_MODALFRAME | WS_POPUPWINDOW | WS_CAPTION
FONT 9, "MS UI Gothic"
{
}

IDD_ADDKEY DIALOG 0, 0, 190, 120
CAPTION "キーの追加"
STYLE DS_MODALFRAME | WS_POPUPWINDOW | WS_CAPTION
FONT 9, "MS UI Gothic"
{
    RTEXT "キー(&K):", -1, 5, 12, 60, 14
    COMBOBOX cmb1, 70, 10, 110, 200, CBS_DROPDOWN | WS_BORDER | WS_VSCROLL | WS_TABSTOP
    RTEXT "コマンド&ID:", -1, 5, 37, 60, 14
    COMBOBOX cmb2, 70, 35, 95, 300, CBS_DROPDOWN | WS_BORDER | WS_VSCROLL | WS_TABSTOP
    PUSHBUTTON "&...", psh1, 165, 35, 15, 14
    AUTOCHECKBOX "&VIRTKEY", chx1, 5, 60, 60, 14
    AUTOCHECKBOX "&NOINVERT", chx2, 70, 60, 60, 14
    AUTOCHECKBOX "&CONTROL", chx3, 5, 75, 60, 14
    AUTOCHECKBOX "&SHIFT", chx4, 70, 75, 60, 14
    AUTOCHECKBOX "&ALT", chx5, 140, 75, 45, 14
    DEFPUSHBUTTON "OK", IDOK, 60, 100, 60, 14
    PUSHBUTTON "キャンセル", IDCANCEL, 125, 100, 60, 14
}

IDD_MODIFYKEY DIALOG 0, 0, 190, 120
CAPTION "キーの編集"
STYLE DS_MODALFRAME | WS_POPUPWINDOW | WS_CAPTION
FONT 9, "MS UI Gothic"
{
    RTEXT "キー(&K):", -1, 5, 12, 60, 14
    COMBOBOX cmb1, 70, 10, 110, 200, CBS_DROPDOWN | WS_BORDER | WS_VSCROLL | WS_TABSTOP
    RTEXT "コマンド&ID:", -1, 5, 37, 60, 14
    COMBOBOX cmb2, 70, 35, 95, 200, CBS_DROPDOWN | WS_BORDER | WS_VSCROLL | WS_TABSTOP
    PUSHBUTTON "&...", psh1, 165, 35, 15, 14
    AUTOCHECKBOX "&VIRTKEY", chx1, 5, 60, 60, 14
    AUTOCHECKBOX "&NOINVERT", chx2, 70, 60, 60, 14
    AUTOCHECKBOX "&CONTROL", chx3, 5, 75, 60, 14
    AUTOCHECKBOX "&SHIFT", chx4, 70, 75, 60, 14
    AUTOCHECKBOX "&ALT", chx5, 140, 75, 45, 14
    DEFPUSHBUTTON "OK", IDOK, 60, 100, 60, 14
    PUSHBUTTON "キャンセル", IDCANCEL, 125, 100, 60, 14
}

IDD_EDITACCEL DIALOG 0, 0, 285, 165
CAPTION "アクセスキーの編集"
STYLE WS_POPUPWINDOW | WS_CAPTION | WS_THICKFRAME
FONT 9, "MS UI Gothic"
{
    LTEXT "キーリスト(&L):", -1, 5, 7, 100, 12
    CONTROL "", lst1, "SysListView32", LVS_NOSORTHEADER | LVS_AUTOARRANGE | LVS_NOLABELWRAP | LVS_SHOWSELALWAYS | LVS_SINGLESEL | LVS_REPORT | WS_BORDER | WS_VSCROLL | WS_HSCROLL | WS_TABSTOP, 5, 20, 210, 120
    PUSHBUTTON "追加(&A)...", psh1, 220, 20, 60, 14
    PUSHBUTTON "変更(&M)...", psh2, 220, 40, 60, 14
    PUSHBUTTON "削除(&D)", psh3, 220, 60, 60, 14
    PUSHBUTTON "上へ(&U)", psh4, 220, 100, 60, 14
    PUSHBUTTON "下へ(&O)", psh5, 220, 120, 60, 14
    DEFPUSHBUTTON "OK", IDOK, 155, 145, 60, 14
    PUSHBUTTON "キャンセル", IDCANCEL, 220, 145, 60, 14
    PUSHBUTTON "すべて削除(&L)", psh6, 5, 145, 79, 14
}

IDD_ADDSTR DIALOG 0, 0, 255, 115
CAPTION "文字列エントリーの追加"
STYLE WS_POPUPWINDOW | WS_CAPTION | WS_THICKFRAME
FONT 9, "MS UI Gothic"
{
    LTEXT "文字列&ID:", -1, 5, 7, 50, 12
    COMBOBOX cmb1, 60, 5, 134, 200, CBS_HASSTRINGS | CBS_AUTOHSCROLL | CBS_DROPDOWN | WS_BORDER | WS_VSCROLL | WS_TABSTOP
    PUSHBUTTON "&...", psh1, 195, 5, 15, 14
    LTEXT "文字列の値(&V):", -1, 5, 27, 54, 12
    EDITTEXT edt1, 60, 25, 190, 45, ES_WANTRETURN | ES_AUTOVSCROLL | ES_MULTILINE | WS_VSCROLL
    AUTOCHECKBOX """\\r\\n""を""\\n""に置き換える(&R)", chx1, 60, 75, 190, 14
    DEFPUSHBUTTON "OK", IDOK, 125, 95, 60, 14
    PUSHBUTTON "キャンセル", IDCANCEL, 190, 95, 60, 14
}

IDD_MODIFYSTR DIALOG 0, 0, 255, 115
CAPTION "文字列エントリーの変更"
STYLE WS_POPUPWINDOW | WS_CAPTION | WS_THICKFRAME
FONT 9, "MS UI Gothic"
{
    LTEXT "文字列&ID:", -1, 5, 7, 50, 12
    COMBOBOX cmb1, 60, 5, 134, 200, CBS_HASSTRINGS | CBS_AUTOHSCROLL | CBS_DROPDOWN | WS_BORDER | WS_VSCROLL | WS_TABSTOP
    PUSHBUTTON "&...", psh1, 195, 5, 15, 14
    LTEXT "文字列の値(&V):", -1, 5, 27, 54, 12
    EDITTEXT edt1, 60, 25, 190, 45, ES_WANTRETURN | ES_AUTOVSCROLL | ES_MULTILINE | WS_VSCROLL
    AUTOCHECKBOX """\\r\\n""を""\\n""に置き換える(&R)", chx1, 60, 75, 190, 14
    DEFPUSHBUTTON "OK", IDOK, 125, 95, 60, 14
    PUSHBUTTON "キャンセル", IDCANCEL, 190, 95, 60, 14
}

IDD_STRINGS DIALOG 0, 0, 325, 160
CAPTION "文字列テーブル"
STYLE WS_POPUPWINDOW | WS_CAPTION | WS_THICKFRAME
FONT 9, "MS UI Gothic"
{
    LTEXT "文字列エントリー(&E):", -1, 5, 7, 100, 12
    CONTROL "", lst1, "SysListView32", LVS_NOSORTHEADER | LVS_AUTOARRANGE | LVS_NOLABELWRAP | LVS_SHOWSELALWAYS | LVS_SINGLESEL | LVS_REPORT | WS_BORDER | WS_VSCROLL | WS_HSCROLL | WS_TABSTOP, 5, 20, 315, 115
    PUSHBUTTON "追加(&A)...", psh1, 130, 3, 60, 14
    PUSHBUTTON "変更(&M)...", psh2, 195, 3, 60, 14
    PUSHBUTTON "削除(&D)", psh3, 260, 3, 60, 14
    DEFPUSHBUTTON "OK", IDOK, 195, 140, 60, 14
    PUSHBUTTON "キャンセル", IDCANCEL, 260, 140, 60, 14
    PUSHBUTTON "すべて削除(&L)", psh4, 5, 140, 75, 14
}

IDD_ADDMITEM DIALOG 0, 0, 210, 200
CAPTION "メニュー項目の追加"
STYLE DS_MODALFRAME | WS_POPUPWINDOW | WS_CAPTION
FONT 9, "MS UI Gothic"
{
    LTEXT "キャプション(&A):", -1, 5, 7, 55, 12
    COMBOBOX cmb1, 65, 6, 140, 200, CBS_AUTOHSCROLL | CBS_DROPDOWN | WS_BORDER | WS_VSCROLL | WS_TABSTOP
    LTEXT "コマンドID(&M):", -1, 5, 32, 55, 12
    COMBOBOX cmb2, 65, 30, 125, 200, CBS_AUTOHSCROLL | CBS_DROPDOWN | WS_BORDER | WS_VSCROLL | WS_TABSTOP
    PUSHBUTTON "&...", psh1, 190, 30, 15, 14
    AUTOCHECKBOX "&GRAYED", chx1, 5, 60, 60, 14
    AUTOCHECKBOX "&BITMAP", chx3, 135, 60, 60, 14
    AUTOCHECKBOX "&OWNERDRAW", chx4, 5, 80, 65, 14
    AUTOCHECKBOX "&CHECKED", chx5, 75, 80, 60, 14
    AUTOCHECKBOX "SE&PARATOR", chx6, 140, 80, 60, 14
    AUTOCHECKBOX "MENU&BARBREAK", chx7, 5, 100, 75, 14
    AUTOCHECKBOX "MENUB&REAK", chx8, 85, 100, 70, 14
    AUTOCHECKBOX "&DEFAULT", chx9, 5, 120, 60, 14
    AUTOCHECKBOX "&HILITE", chx10, 70, 120, 60, 14
    AUTOCHECKBOX "RADIOCHEC&K", chx11, 135, 120, 60, 14
    AUTOCHECKBOX "RIGH&TORDER", chx12, 5, 139, 60, 14
    AUTOCHECKBOX "RIGHT&JUSTIFY", chx13, 70, 140, 70, 14
    LTEXT "ヘルプID(&L):", -1, 5, 162, 45, 12
    COMBOBOX cmb3, 55, 160, 100, 300, CBS_AUTOHSCROLL | CBS_DROPDOWN | WS_BORDER | WS_VSCROLL | WS_TABSTOP
    DEFPUSHBUTTON "OK", IDOK, 80, 180, 60, 14
    PUSHBUTTON "キャンセル", IDCANCEL, 145, 180, 60, 14
}

IDD_MODIFYMITEM DIALOG 0, 0, 210, 200
CAPTION "メニュー項目の変更"
STYLE DS_MODALFRAME | WS_POPUPWINDOW | WS_CAPTION
FONT 9, "MS UI Gothic"
{
    LTEXT "キャプション(&A):", -1, 5, 7, 55, 12
    COMBOBOX cmb1, 65, 6, 140, 200, CBS_AUTOHSCROLL | CBS_DROPDOWN | WS_BORDER | WS_VSCROLL | WS_TABSTOP
    LTEXT "コマンドID(&M):", -1, 5, 32, 55, 12
    COMBOBOX cmb2, 65, 30, 125, 200, CBS_AUTOHSCROLL | CBS_DROPDOWN | WS_BORDER | WS_VSCROLL | WS_TABSTOP
    PUSHBUTTON "&...", psh1, 190, 30, 15, 14
    AUTOCHECKBOX "&GRAYED", chx1, 5, 60, 60, 14
    AUTOCHECKBOX "&BITMAP", chx3, 135, 60, 60, 14
    AUTOCHECKBOX "&OWNERDRAW", chx4, 5, 80, 65, 14
    AUTOCHECKBOX "&CHECKED", chx5, 75, 80, 60, 14
    AUTOCHECKBOX "SE&PARATOR", chx6, 140, 80, 60, 14
    AUTOCHECKBOX "MENU&BARBREAK", chx7, 5, 100, 75, 14
    AUTOCHECKBOX "MENUB&REAK", chx8, 85, 100, 70, 14
    AUTOCHECKBOX "&DEFAULT", chx9, 5, 120, 60, 14
    AUTOCHECKBOX "&HILITE", chx10, 70, 120, 60, 14
    AUTOCHECKBOX "RADIOCHEC&K", chx11, 135, 120, 60, 14
    AUTOCHECKBOX "RIGH&TORDER", chx12, 5, 139, 60, 14
    AUTOCHECKBOX "RIGHT&JUSTIFY", chx13, 70, 140, 70, 14
    LTEXT "ヘルプID(&L):", -1, 5, 162, 45, 12
    COMBOBOX cmb3, 55, 160, 100, 300, CBS_AUTOHSCROLL | CBS_DROPDOWN | WS_BORDER | WS_VSCROLL | WS_TABSTOP
    DEFPUSHBUTTON "OK", IDOK, 80, 180, 60, 14
    PUSHBUTTON "キャンセル", IDCANCEL, 145, 180, 60, 14
}

IDD_EDITMENU DIALOG 0, 0, 325, 160
CAPTION "メニュー リソースの編集"
STYLE WS_POPUPWINDOW | WS_CAPTION | WS_THICKFRAME
FONT 9, "MS UI Gothic"
{
    LTEXT "メニューリソース(&S):", -1, 5, 7, 85, 12
    CONTROL "", lst1, "SysListView32", LVS_NOSORTHEADER | LVS_AUTOARRANGE | LVS_NOLABELWRAP | LVS_SHOWSELALWAYS | LVS_SINGLESEL | LVS_REPORT | WS_BORDER | WS_VSCROLL | WS_HSCROLL | WS_TABSTOP, 5, 20, 315, 115
    PUSHBUTTON "追加(&A)...", psh1, 95, 3, 50, 14
    PUSHBUTTON "変更(&M)...", psh2, 150, 3, 50, 14
    PUSHBUTTON "削除(&T)", psh3, 205, 3, 50, 14
    PUSHBUTTON "↑(&U)", psh4, 5, 140, 40, 14
    PUSHBUTTON "↓(&D)", psh5, 50, 140, 40, 14
    PUSHBUTTON "←(&L)", psh6, 95, 140, 40, 14
    PUSHBUTTON "→(&R)", psh7, 140, 140, 41, 14
    AUTOCHECKBOX "拡張(&X)", chx1, 260, 3, 60, 14
    DEFPUSHBUTTON "OK", IDOK, 195, 140, 60, 14
    PUSHBUTTON "キャンセル", IDCANCEL, 260, 140, 60, 14
}

IDD_DLGPROP DIALOG 0, 0, 235, 315
CAPTION "ダイアログのプロパティ"
STYLE DS_MODALFRAME | WS_POPUPWINDOW | WS_CAPTION
FONT 9, "MS UI Gothic"
{
    LTEXT "キャプション(&A):", -1, 5, 7, 85, 11
    COMBOBOX cmb1, 5, 20, 225, 300, CBS_HASSTRINGS | CBS_AUTOHSCROLL | CBS_DROPDOWN | WS_BORDER | WS_VSCROLL | WS_TABSTOP
    AUTOCHECKBOX "拡張ダイアログ(&X)", chx1, 100, 5, 86, 14
    LTEXT "左(&L):", -1, 5, 40, 33, 10
    EDITTEXT edt1, 5, 53, 30, 14, ES_NUMBER | ES_RIGHT
    CONTROL "", scr1, "msctls_updown32", UDS_NOTHOUSANDS | UDS_ARROWKEYS | UDS_AUTOBUDDY | UDS_ALIGNRIGHT | UDS_SETBUDDYINT, 23, 53, 12, 20
    LTEXT "上(&O):", -1, 50, 40, 33, 10
    EDITTEXT edt2, 50, 53, 30, 14, ES_NUMBER | ES_RIGHT
    CONTROL "", scr2, "msctls_updown32", UDS_NOTHOUSANDS | UDS_ARROWKEYS | UDS_AUTOBUDDY | UDS_ALIGNRIGHT | UDS_SETBUDDYINT, 53, 53, 12, 20
    LTEXT "幅(&W):", -1, 95, 40, 33, 10
    EDITTEXT edt3, 95, 53, 30, 14, ES_NUMBER | ES_RIGHT
    CONTROL "", scr3, "msctls_updown32", UDS_NOTHOUSANDS | UDS_ARROWKEYS | UDS_AUTOBUDDY | UDS_ALIGNRIGHT | UDS_SETBUDDYINT, 129, 56, 12, 20
    LTEXT "高さ(&H):", -1, 142, 40, 33, 10
    EDITTEXT edt4, 142, 53, 30, 14, ES_NUMBER | ES_RIGHT
    CONTROL "", scr4, "msctls_updown32", UDS_NOTHOUSANDS | UDS_ARROWKEYS | UDS_AUTOBUDDY | UDS_ALIGNRIGHT | UDS_SETBUDDYINT, 162, 53, 12, 20
    LTEXT "クラス名(&S):", -1, 5, 73, 85, 11
    COMBOBOX cmb2, 5, 88, 115, 200, CBS_HASSTRINGS | CBS_AUTOHSCROLL | CBS_DROPDOWN | WS_BORDER | WS_VSCROLL | WS_TABSTOP
    LTEXT "ヘルプID(&P):", -1, 125, 73, 64, 11
    COMBOBOX cmb3, 125, 88, 65, 200, CBS_HASSTRINGS | CBS_AUTOHSCROLL | CBS_DROPDOWN | WS_BORDER | WS_VSCROLL | WS_TABSTOP
    LTEXT "フォント名(&F):", -1, 5, 105, 80, 11
    COMBOBOX cmb4, 6, 118, 100, 200, CBS_HASSTRINGS | CBS_SORT | CBS_AUTOHSCROLL | CBS_DROPDOWN | WS_BORDER | WS_VSCROLL | WS_TABSTOP
    LTEXT "サイズ(&Z):", -1, 110, 105, 38, 12
    EDITTEXT edt5, 110, 118, 25, 14, ES_NUMBER
    AUTOCHECKBOX "&B", chx2, 140, 118, 20, 14
    AUTOCHECKBOX "&I", chx3, 165, 118, 20, 14
    LTEXT "文字セット(&R):", -1, 5, 138, 80, 11
    COMBOBOX cmb5, 5, 148, 100, 100, CBS_AUTOHSCROLL | CBS_DROPDOWNLIST | WS_VSCROLL | WS_TABSTOP
    LTEXT "メニュー名(&M):", -1, 110, 138, 55, 11
    COMBOBOX cmb6, 110, 148, 99, 300, CBS_HASSTRINGS | CBS_AUTOHSCROLL | CBS_DROPDOWN | WS_BORDER | WS_VSCROLL | WS_TABSTOP
    LTEXT "スタイル(&T):", -1, 5, 168, 45, 11
    RTEXT "0x", -1, 52, 169, 10, 11
    EDITTEXT edt6, 67, 165, 45, 14, ES_AUTOHSCROLL
    LISTBOX lst1, 5, 183, 110, 110, LBS_DISABLENOSCROLL | LBS_NOINTEGRALHEIGHT | LBS_HASSTRINGS | LBS_MULTIPLESEL | WS_VSCROLL | WS_HSCROLL | WS_TABSTOP
    LTEXT "拡張スタイル(&E):", -1, 120, 168, 48, 11
    RTEXT "0x", -1, 170, 169, 10, 11
    EDITTEXT edt7, 185, 165, 45, 14, ES_AUTOHSCROLL
    LISTBOX lst2, 120, 183, 110, 110, LBS_DISABLENOSCROLL | LBS_NOINTEGRALHEIGHT | LBS_HASSTRINGS | LBS_MULTIPLESEL | WS_VSCROLL | WS_HSCROLL | WS_TABSTOP
    DEFPUSHBUTTON "OK", IDOK, 106, 298, 60, 14
    PUSHBUTTON "キャンセル", IDCANCEL, 171, 298, 60, 14
}

IDD_CTRLPROP DIALOG 0, 0, 235, 330
CAPTION "コントロールのプロパティ"
STYLE DS_MODALFRAME | WS_POPUPWINDOW | WS_CAPTION
FONT 9, "MS UI Gothic"
{
    LTEXT "定義済み&Control:", -1, 5, 7, 68, 12
    COMBOBOX cmb1, 75, 5, 120, 55, CBS_HASSTRINGS | CBS_AUTOHSCROLL | CBS_DROPDOWN | WS_BORDER | WS_VSCROLL | WS_TABSTOP
    CONTROL "", ctl1, "ToolbarWindow32", TBSTYLE_FLAT | TBSTYLE_WRAPABLE | TBSTYLE_TOOLTIPS | CCS_NODIVIDER | CCS_NORESIZE, 5, 22, 185, 30
    LTEXT "キャプション(&A):", -1, 5, 55, 75, 12
    COMBOBOX cmb2, 5, 65, 195, 300, CBS_HASSTRINGS | CBS_AUTOHSCROLL | CBS_DROPDOWN | WS_BORDER | WS_VSCROLL | WS_TABSTOP
    PUSHBUTTON "&OLE...", psh2, 205, 65, 25, 14
    LTEXT "左(&L):", -1, 5, 85, 33, 11
    EDITTEXT edt1, 5, 99, 25, 14, ES_NUMBER | ES_RIGHT
    CONTROL "", scr1, "msctls_updown32", UDS_NOTHOUSANDS | UDS_ARROWKEYS | UDS_AUTOBUDDY | UDS_ALIGNRIGHT | UDS_SETBUDDYINT, 20, 99, 12, 20
    LTEXT "上(&O):", -1, 40, 85, 33, 11
    EDITTEXT edt2, 40, 99, 25, 14, ES_NUMBER | ES_RIGHT
    CONTROL "", scr2, "msctls_updown32", UDS_NOTHOUSANDS | UDS_ARROWKEYS | UDS_AUTOBUDDY | UDS_ALIGNRIGHT | UDS_SETBUDDYINT, 55, 99, 12, 20
    LTEXT "幅(&W):", -1, 75, 85, 33, 11
    EDITTEXT edt3, 75, 99, 25, 14, ES_NUMBER | ES_RIGHT
    CONTROL "", scr3, "msctls_updown32", UDS_NOTHOUSANDS | UDS_ARROWKEYS | UDS_AUTOBUDDY | UDS_ALIGNRIGHT | UDS_SETBUDDYINT, 90, 99, 12, 20
    LTEXT "高さ(&H):", -1, 111, 85, 33, 11
    EDITTEXT edt4, 110, 99, 25, 14, ES_NUMBER | ES_RIGHT
    CONTROL "", scr4, "msctls_updown32", UDS_NOTHOUSANDS | UDS_ARROWKEYS | UDS_AUTOBUDDY | UDS_ALIGNRIGHT | UDS_SETBUDDYINT, 125, 99, 12, 20
    LTEXT "&ID:", -1, 150, 85, 70, 12
    COMBOBOX cmb3, 150, 99, 80, 300, CBS_HASSTRINGS | CBS_AUTOHSCROLL | CBS_DROPDOWN | WS_BORDER | WS_VSCROLL | WS_TABSTOP
    LTEXT "ウィンドウ クラス名(&S):", -1, 5, 119, 100, 12
    COMBOBOX cmb4, 5, 133, 115, 200, CBS_HASSTRINGS | CBS_AUTOHSCROLL | CBS_DROPDOWN | WS_BORDER | WS_VSCROLL | WS_TABSTOP
    LTEXT "ヘルプID(&P):", -1, 125, 119, 70, 12
    COMBOBOX cmb5, 125, 133, 65, 200, CBS_HASSTRINGS | CBS_AUTOHSCROLL | CBS_DROPDOWN | WS_BORDER | WS_VSCROLL | WS_TABSTOP
    LTEXT "スタイル(&T):", -1, 5, 153, 45, 12
    RTEXT "0x", -1, 54, 153, 10, 12
    EDITTEXT edt6, 70, 151, 45, 14, ES_AUTOHSCROLL
    LISTBOX lst1, 5, 167, 110, 120, LBS_DISABLENOSCROLL | LBS_NOINTEGRALHEIGHT | LBS_HASSTRINGS | LBS_MULTIPLESEL | WS_VSCROLL | WS_HSCROLL | WS_TABSTOP
    LTEXT "拡張スタイル(&E):", -1, 120, 153, 50, 12
    RTEXT "0x", -1, 172, 153, 10, 12
    EDITTEXT edt7, 185, 151, 45, 14, ES_AUTOHSCROLL
    LISTBOX lst2, 120, 167, 110, 120, LBS_DISABLENOSCROLL | LBS_NOINTEGRALHEIGHT | LBS_HASSTRINGS | LBS_MULTIPLESEL | WS_VSCROLL | WS_HSCROLL | WS_TABSTOP
    DEFPUSHBUTTON "OK", IDOK, 170, 293, 60, 14
    PUSHBUTTON "キャンセル", IDCANCEL, 170, 309, 60, 14
    PUSHBUTTON "&DATA...", psh1, 5, 293, 90, 14
    PUSHBUTTON "文字列リスト(&I)...", psh3, 5, 309, 90, 14
}

IDD_ADDCTRL DIALOG 0, 0, 235, 330
CAPTION "コントロールの追加"
STYLE DS_MODALFRAME | WS_POPUPWINDOW | WS_CAPTION
FONT 9, "MS UI Gothic"
{
    LTEXT "定義済み&Control:", -1, 5, 7, 68, 12
    COMBOBOX cmb1, 75, 5, 120, 55, CBS_HASSTRINGS | CBS_AUTOHSCROLL | CBS_DROPDOWN | WS_BORDER | WS_VSCROLL | WS_TABSTOP
    CONTROL "", ctl1, "ToolbarWindow32", TBSTYLE_FLAT | TBSTYLE_WRAPABLE | TBSTYLE_TOOLTIPS | CCS_NODIVIDER | CCS_NORESIZE, 5, 22, 185, 30
    LTEXT "キャプション(&A):", -1, 5, 55, 75, 12
    COMBOBOX cmb2, 5, 65, 195, 300, CBS_HASSTRINGS | CBS_AUTOHSCROLL | CBS_DROPDOWN | WS_BORDER | WS_VSCROLL | WS_TABSTOP
    PUSHBUTTON "&OLE...", psh2, 205, 65, 25, 14
    LTEXT "左(&L):", -1, 5, 85, 33, 11
    EDITTEXT edt1, 5, 99, 25, 14, ES_NUMBER | ES_RIGHT
    CONTROL "", scr1, "msctls_updown32", UDS_NOTHOUSANDS | UDS_ARROWKEYS | UDS_AUTOBUDDY | UDS_ALIGNRIGHT | UDS_SETBUDDYINT, 20, 99, 12, 20
    LTEXT "上(&O):", -1, 40, 85, 33, 11
    EDITTEXT edt2, 40, 99, 25, 14, ES_NUMBER | ES_RIGHT
    CONTROL "", scr2, "msctls_updown32", UDS_NOTHOUSANDS | UDS_ARROWKEYS | UDS_AUTOBUDDY | UDS_ALIGNRIGHT | UDS_SETBUDDYINT, 55, 99, 12, 20
    LTEXT "幅(&W):", -1, 75, 85, 33, 11
    EDITTEXT edt3, 75, 99, 25, 14, ES_NUMBER | ES_RIGHT
    CONTROL "", scr3, "msctls_updown32", UDS_NOTHOUSANDS | UDS_ARROWKEYS | UDS_AUTOBUDDY | UDS_ALIGNRIGHT | UDS_SETBUDDYINT, 90, 99, 12, 20
    LTEXT "高さ(&H):", -1, 111, 85, 33, 11
    EDITTEXT edt4, 110, 99, 25, 14, ES_NUMBER | ES_RIGHT
    CONTROL "", scr4, "msctls_updown32", UDS_NOTHOUSANDS | UDS_ARROWKEYS | UDS_AUTOBUDDY | UDS_ALIGNRIGHT | UDS_SETBUDDYINT, 125, 99, 12, 20
    LTEXT "&ID:", -1, 150, 85, 70, 12
    COMBOBOX cmb3, 150, 99, 80, 300, CBS_HASSTRINGS | CBS_AUTOHSCROLL | CBS_DROPDOWN | WS_BORDER | WS_VSCROLL | WS_TABSTOP
    LTEXT "ウィンドウ クラス名(&S):", -1, 5, 119, 100, 12
    COMBOBOX cmb4, 5, 133, 115, 200, CBS_HASSTRINGS | CBS_AUTOHSCROLL | CBS_DROPDOWN | WS_BORDER | WS_VSCROLL | WS_TABSTOP
    LTEXT "ヘルプID(&P):", -1, 125, 119, 70, 12
    COMBOBOX cmb5, 125, 133, 65, 200, CBS_HASSTRINGS | CBS_AUTOHSCROLL | CBS_DROPDOWN | WS_BORDER | WS_VSCROLL | WS_TABSTOP
    LTEXT "スタイル(&T):", -1, 5, 153, 45, 12
    RTEXT "0x", -1, 54, 153, 10, 12
    EDITTEXT edt6, 70, 151, 45, 14, ES_AUTOHSCROLL
    LISTBOX lst1, 5, 167, 110, 120, LBS_DISABLENOSCROLL | LBS_NOINTEGRALHEIGHT | LBS_HASSTRINGS | LBS_MULTIPLESEL | WS_VSCROLL | WS_HSCROLL | WS_TABSTOP
    LTEXT "拡張スタイル(&E):", -1, 120, 153, 50, 12
    RTEXT "0x", -1, 172, 153, 10, 12
    EDITTEXT edt7, 185, 151, 45, 14, ES_AUTOHSCROLL
    LISTBOX lst2, 120, 167, 110, 120, LBS_DISABLENOSCROLL | LBS_NOINTEGRALHEIGHT | LBS_HASSTRINGS | LBS_MULTIPLESEL | WS_VSCROLL | WS_HSCROLL | WS_TABSTOP
    DEFPUSHBUTTON "OK", IDOK, 170, 293, 60, 14
    PUSHBUTTON "キャンセル", IDCANCEL, 170, 309, 60, 14
    PUSHBUTTON "&DATA...", psh1, 5, 293, 90, 14
    PUSHBUTTON "文字列リスト(&I)...", psh3, 5, 309, 90, 14
}

IDD_IDASSOC DIALOG 0, 0, 200, 220
CAPTION "ID の関連付け"
STYLE DS_MODALFRAME | WS_POPUPWINDOW | WS_CAPTION
FONT 9, "MS UI Gothic"
{
    LTEXT "IDの関連付け(&A):", -1, 5, 5, 116, 12
    CONTROL "", lst1, "SysListView32", LVS_SHOWSELALWAYS | LVS_SINGLESEL | LVS_REPORT | WS_BORDER | WS_TABSTOP, 5, 20, 190, 150
    PUSHBUTTON "すべてリセット(&R)", psh2, 5, 175, 85, 14
    PUSHBUTTON "変更(&M)", psh1, 135, 175, 60, 14
    DEFPUSHBUTTON "OK", IDOK, 70, 200, 60, 14
    PUSHBUTTON "キャンセル", IDCANCEL, 135, 200, 60, 14
}

IDD_MODIFYASSOC DIALOG 0, 0, 165, 68
CAPTION "ID関連付けの変更"
STYLE DS_MODALFRAME | WS_POPUPWINDOW | WS_CAPTION
FONT 9, "MS UI Gothic"
{
    RTEXT "IDの種類(&T):", -1, 5, 7, 65, 12
    EDITTEXT edt1, 80, 5, 80, 14, WS_DISABLED
    RTEXT "IDのプレフィックス(&P):", -1, 5, 32, 65, 12
    EDITTEXT edt2, 80, 28, 80, 14, ES_AUTOHSCROLL
    DEFPUSHBUTTON "OK", IDOK, 35, 50, 60, 14
    PUSHBUTTON "キャンセル", IDCANCEL, 100, 50, 60, 14
}

IDD_IDLIST DIALOG 0, 0, 200, 300
CAPTION "リソースIDの一覧"
STYLE WS_OVERLAPPEDWINDOW
EXSTYLE WS_EX_TOOLWINDOW
FONT 9, "MS UI Gothic"
{
    COMBOBOX cmb1, 0, 0, 200, 300, CBS_HASSTRINGS | CBS_SORT | CBS_OWNERDRAWFIXED | CBS_DROPDOWNLIST | WS_VSCROLL | WS_TABSTOP
    CONTROL "", lst1, "SysListView32", LVS_REPORT | WS_BORDER | WS_VSCROLL | WS_HSCROLL | WS_TABSTOP, 0, 15, 200, 285
}

IDD_CONFIG DIALOG 0, 0, 210, 285
CAPTION "設定"
STYLE DS_MODALFRAME | WS_POPUPWINDOW | WS_CAPTION
FONT 9, "MS UI Gothic"
{
    AUTOCHECKBOX "タイトルバーにフルパスを表示する(&F)", chx1, 5, 5, 200, 14
    AUTOCHECKBOX "IDマクロを使わない(&M)", chx2, 5, 25, 200, 14
    AUTOCHECKBOX "次回、ウィンドウ位置を復元する(&P)", chx3, 5, 45, 200, 14
    AUTOCHECKBOX "近くの""&resource.h""を自動的に読み込む", chx4, 5, 65, 200, 14
    AUTOCHECKBOX "自動的にリソースIDの一覧を表示する(&L)", chx5, 5, 85, 200, 14
    AUTOCHECKBOX "ダイアログ編集に点々を表示する(&D)", chx6, 5, 105, 200, 14
    RTEXT "コンボボックスの高さ(&B):", -1, 10, 127, 75, 12
    EDITTEXT edt1, 90, 125, 34, 14, ES_NUMBER | ES_RIGHT
    CONTROL "", scr1, "msctls_updown32", UDS_NOTHOUSANDS | UDS_ARROWKEYS | UDS_AUTOBUDDY | UDS_ALIGNRIGHT | UDS_SETBUDDYINT, 129, 49, 12, 20
    AUTOCHECKBOX "行の折り返し(&W)", chx9, 135, 125, 70, 14
    AUTOCHECKBOX """&resource.h"" の更新を尋ねる", chx7, 5, 145, 200, 14
    AUTOCHECKBOX "EXE保存時に&UPXで圧縮する", chx8, 5, 165, 200, 14
    PUSHBUTTON "フォント設定(&F)...", psh4, 5, 185, 200, 14
    PUSHBUTTON "定義済みマクロ(&M)...", psh1, 5, 205, 93, 14
    PUSHBUTTON "PATHの設定(&T)...", psh2, 107, 205, 98, 14
    RTEXT "&OLEコントロールの名前:", -1, 5, 227, 80, 12
    COMBOBOX cmb1, 90, 225, 75, 300, CBS_HASSTRINGS | CBS_AUTOHSCROLL | CBS_DROPDOWN | WS_VSCROLL | WS_TABSTOP
    AUTOCHECKBOX "バックアップを作成する(&B)", chx10, 5, 245, 89, 14
    RTEXT "サフィックス:", -1, 110, 248, 45, 9
    COMBOBOX cmb2, 159, 245, 45, 300, CBS_HASSTRINGS | CBS_AUTOHSCROLL | CBS_DROPDOWN | WS_VSCROLL | WS_TABSTOP
    DEFPUSHBUTTON "OK", IDOK, 100, 265, 50, 14
    PUSHBUTTON "キャンセル", IDCANCEL, 155, 265, 50, 14
    PUSHBUTTON "すべてリセット(&S)", psh3, 5, 265, 75, 14
}

IDD_ADDRESID DIALOG 0, 0, 165, 90
CAPTION "リソースIDの追加"
STYLE DS_MODALFRAME | WS_POPUPWINDOW | WS_CAPTION
FONT 9, "MS UI Gothic"
{
    RTEXT "IDの種類(&T):", -1, 10, 7, 50, 14
    COMBOBOX cmb1, 65, 5, 95, 300, CBS_AUTOHSCROLL | CBS_DROPDOWNLIST | WS_VSCROLL | WS_TABSTOP
    RTEXT "IDの名前(&N):", -1, 10, 27, 50, 14
    EDITTEXT edt1, 65, 25, 75, 14, ES_AUTOHSCROLL
    RTEXT "整数値(&I):", -1, 10, 47, 50, 14
    EDITTEXT edt2, 65, 45, 48, 14, ES_AUTOHSCROLL
    CONTROL "", scr1, "msctls_updown32", UDS_NOTHOUSANDS | UDS_ARROWKEYS | UDS_AUTOBUDDY | UDS_ALIGNRIGHT | UDS_SETBUDDYINT, 129, 49, 12, 20
    PUSHBUTTON "自動(&A)", psh1, 115, 45, 45, 14
    DEFPUSHBUTTON "OK", IDOK, 20, 70, 60, 14
    PUSHBUTTON "キャンセル", IDCANCEL, 85, 70, 60, 14
}

IDD_MODIFYRESID DIALOG 0, 0, 165, 90
CAPTION "リソースIDの変更"
STYLE DS_MODALFRAME | WS_POPUPWINDOW | WS_CAPTION
FONT 9, "MS UI Gothic"
{
    RTEXT "IDの名前(&N):", -1, 10, 12, 50, 14, SS_REALSIZEIMAGE | NOT WS_GROUP
    EDITTEXT edt1, 65, 10, 95, 14, ES_AUTOHSCROLL
    RTEXT "IDの種類(&T):", -1, 10, 32, 50, 14
    EDITTEXT edt2, 65, 30, 95, 14, ES_READONLY
    RTEXT "整数値(&I):", -1, 10, 52, 50, 14
    EDITTEXT edt3, 65, 50, 48, 14, ES_AUTOHSCROLL
    CONTROL "", scr1, "msctls_updown32", UDS_NOTHOUSANDS | UDS_ARROWKEYS | UDS_AUTOBUDDY | UDS_ALIGNRIGHT | UDS_SETBUDDYINT, 129, 49, 12, 20
    DEFPUSHBUTTON "OK", IDOK, 20, 70, 60, 14
    PUSHBUTTON "キャンセル", IDCANCEL, 85, 70, 60, 14
}

IDD_ADVICERESH DIALOG 0, 0, 209, 184
CAPTION "ファイル 'resource.h' 変更の提案"
STYLE DS_MODALFRAME | WS_POPUPWINDOW | WS_CAPTION
FONT 9, "MS UI Gothic"
{
    LTEXT "次のようにファイル 'resource.h' を変更して下さい。", -1, 10, 10, 195, 20
    EDITTEXT edt1, 10, 30, 190, 130, ES_READONLY | ES_MULTILINE
    DEFPUSHBUTTON "OK", IDOK, 140, 165, 60, 14
    PUSHBUTTON "変更点のクリア(&C)", psh1, 10, 165, 90, 14
}

IDD_CLONEINNEWNAME DIALOG 0, 0, 215, 75
CAPTION "別の名前で複製"
STYLE DS_MODALFRAME | WS_POPUPWINDOW | WS_CAPTION
FONT 9, "MS UI Gothic"
{
    LTEXT "リソースの種類(&T):", -1, 5, 7, 70, 12
    COMBOBOX cmb1, 75, 5, 135, 200, CBS_HASSTRINGS | CBS_AUTOHSCROLL | CBS_DROPDOWN | WS_DISABLED | WS_BORDER | WS_VSCROLL | WS_TABSTOP
    LTEXT "リソースの名前(&N):", -1, 5, 32, 70, 12
    COMBOBOX cmb2, 75, 30, 120, 200, CBS_HASSTRINGS | CBS_AUTOHSCROLL | CBS_DROPDOWN | WS_BORDER | WS_VSCROLL | WS_TABSTOP
    PUSHBUTTON "&...", psh1, 195, 30, 15, 14
    DEFPUSHBUTTON "OK", IDOK, 35, 55, 60, 14
    PUSHBUTTON "キャンセル", IDCANCEL, 115, 55, 60, 14
}

IDD_CLONEINNEWLANG DIALOG 0, 0, 215, 105
CAPTION "別の言語で複製"
STYLE DS_MODALFRAME | WS_POPUPWINDOW | WS_CAPTION
FONT 9, "MS UI Gothic"
{
    LTEXT "リソースの種類(&T):", -1, 5, 7, 70, 12
    COMBOBOX cmb1, 75, 5, 135, 200, CBS_HASSTRINGS | CBS_AUTOHSCROLL | CBS_DROPDOWN | WS_DISABLED | WS_BORDER | WS_VSCROLL | WS_TABSTOP
    LTEXT "リソースの名前(&N):", -1, 5, 32, 70, 12
    COMBOBOX cmb2, 75, 30, 120, 200, CBS_HASSTRINGS | CBS_AUTOHSCROLL | CBS_DROPDOWN | WS_DISABLED | WS_BORDER | WS_VSCROLL | WS_TABSTOP
    LTEXT "リソースの言語(&L):", -1, 5, 57, 70, 12
    COMBOBOX cmb3, 75, 55, 135, 200, CBS_HASSTRINGS | CBS_AUTOHSCROLL | CBS_DROPDOWN | WS_BORDER | WS_VSCROLL | WS_TABSTOP
    DEFPUSHBUTTON "OK", IDOK, 35, 85, 60, 14
    PUSHBUTTON "キャンセル", IDCANCEL, 115, 85, 60, 14
}

IDD_ITEMSEARCH DIALOG 0, 0, 171, 135
CAPTION "検索"
STYLE WS_POPUPWINDOW | WS_CAPTION
FONT 9, "MS UI Gothic"
{
    LTEXT "検索文字列(&S):", -1, 4, 10, 100, 14
    EDITTEXT edt1, 5, 25, 160, 15, ES_AUTOHSCROLL
    AUTOCHECKBOX "大文字小文字を区別する(&C)", chx1, 5, 45, 120, 15
    GROUPBOX "検索する方向", -1, 5, 65, 160, 42
    AUTORADIOBUTTON "上向き(&U)", rad1, 15, 80, 60, 14, WS_TABSTOP
    AUTORADIOBUTTON "下向き(&D)", rad2, 90, 80, 60, 14, WS_TABSTOP
    DEFPUSHBUTTON "検索(&F)", IDOK, 40, 115, 60, 14
    PUSHBUTTON "キャンセル", IDCANCEL, 105, 115, 60, 14
}

IDD_VERSIONINFO DIALOG 0, 0, 174, 150
CAPTION "リソーエディタのバージョン情報"
STYLE DS_MODALFRAME | WS_POPUPWINDOW | WS_CAPTION
FONT 12, "MS UI Gothic"
{
    ICON IDI_MAIN, -1, 5, 5, 0, 0
    LTEXT "...", stc1, 30, 5, 140, 50
    CTEXT "https://katahiromz.web.fc2.com", stc2, 5, 60, 165, 12, SS_CENTERIMAGE | SS_NOTIFY | NOT WS_GROUP
    CONTROL "...", edt1, "EDIT", ES_READONLY | ES_AUTOHSCROLL | ES_AUTOVSCROLL | ES_MULTILINE | WS_BORDER | WS_VSCROLL | WS_HSCROLL, 5, 75, 165, 50
    DEFPUSHBUTTON "OK", IDOK, 55, 130, 60, 14
}

IDD_ADDMSG DIALOG 0, 0, 255, 105
CAPTION "メッセージエントリーの追加"
STYLE DS_MODALFRAME | WS_POPUPWINDOW | WS_CAPTION
FONT 9, "MS UI Gothic"
{
    LTEXT "メッセージ&ID:", -1, 5, 7, 50, 12
    COMBOBOX cmb1, 65, 5, 134, 200, CBS_HASSTRINGS | CBS_AUTOHSCROLL | CBS_DROPDOWN | WS_BORDER | WS_VSCROLL | WS_TABSTOP
    PUSHBUTTON "&...", psh1, 200, 5, 15, 14
    LTEXT "メッセージの値(&V):", -1, 5, 27, 80, 12
    EDITTEXT edt1, 5, 40, 245, 35, ES_WANTRETURN | ES_AUTOHSCROLL | ES_AUTOVSCROLL | ES_MULTILINE
    DEFPUSHBUTTON "OK", IDOK, 125, 85, 60, 14
    PUSHBUTTON "キャンセル", IDCANCEL, 190, 85, 60, 14
}

IDD_MODIFYMSG DIALOG 0, 0, 255, 105
CAPTION "メッセージエントリーの変更"
STYLE DS_MODALFRAME | WS_POPUPWINDOW | WS_CAPTION
FONT 9, "MS UI Gothic"
{
    LTEXT "メッセージ&ID:", -1, 5, 7, 50, 12
    COMBOBOX cmb1, 65, 5, 134, 200, CBS_HASSTRINGS | CBS_AUTOHSCROLL | CBS_DROPDOWN | WS_DISABLED | WS_BORDER | WS_VSCROLL | WS_TABSTOP
    LTEXT "メッセージの値(&V):", -1, 5, 27, 80, 12
    EDITTEXT edt1, 5, 40, 245, 35, ES_WANTRETURN | ES_AUTOHSCROLL | ES_AUTOVSCROLL | ES_MULTILINE
    DEFPUSHBUTTON "OK", IDOK, 125, 85, 60, 14
    PUSHBUTTON "キャンセル", IDCANCEL, 190, 85, 60, 14
}

IDD_MESSAGES DIALOG 0, 0, 325, 160
CAPTION "メッセージテーブル"
STYLE WS_POPUPWINDOW | WS_CAPTION | WS_THICKFRAME
FONT 9, "MS UI Gothic"
{
    LTEXT "メッセージ エントリー(&E):", -1, 5, 7, 80, 12
    CONTROL "", lst1, "SysListView32", LVS_NOSORTHEADER | LVS_AUTOARRANGE | LVS_NOLABELWRAP | LVS_SHOWSELALWAYS | LVS_SINGLESEL | LVS_REPORT | WS_BORDER | WS_VSCROLL | WS_HSCROLL | WS_TABSTOP, 5, 20, 315, 115
    PUSHBUTTON "追加(&A)...", psh1, 130, 3, 60, 14
    PUSHBUTTON "変更(&M)...", psh2, 195, 3, 60, 14
    PUSHBUTTON "削除(&D)", psh3, 260, 3, 60, 14
    DEFPUSHBUTTON "OK", IDOK, 195, 140, 60, 14
    PUSHBUTTON "キャンセル", IDCANCEL, 260, 140, 60, 14
    PUSHBUTTON "すべて削除(&L)", psh4, 5, 140, 75, 14
}

IDD_FONTS DIALOG 0, 0, 195, 110
CAPTION "フォントの設定"
STYLE DS_MODALFRAME | WS_POPUPWINDOW | WS_CAPTION
FONT 9, "MS UI Gothic"
{
    RTEXT "ソース(&S):", -1, 5, 5, 55, 15, SS_CENTERIMAGE | NOT WS_GROUP
    EDITTEXT edt1, 65, 5, 100, 14, ES_READONLY | ES_AUTOHSCROLL
    PUSHBUTTON "...", psh1, 170, 5, 19, 14
    RTEXT "バイナリー(&B):", -1, 5, 25, 55, 15, SS_CENTERIMAGE | NOT WS_GROUP
    EDITTEXT edt2, 65, 25, 100, 14, ES_READONLY | ES_AUTOHSCROLL
    PUSHBUTTON "...", psh2, 170, 25, 19, 14
    GROUPBOX "プレビュー", -1, 5, 45, 185, 39
    CTEXT "ソース", stc1, 15, 55, 80, 25, SS_CENTERIMAGE | NOT WS_GROUP
    CTEXT "バイナリー", stc2, 100, 55, 85, 25, SS_CENTERIMAGE | NOT WS_GROUP
    DEFPUSHBUTTON "OK", IDOK, 65, 90, 60, 14
    PUSHBUTTON "キャンセル", IDCANCEL, 130, 90, 60, 14
}

IDD_MACROS DIALOG 0, 0, 265, 165
CAPTION "定義済みマクロの一覧"
STYLE WS_POPUPWINDOW | WS_CAPTION | WS_THICKFRAME
FONT 9, "MS UI Gothic"
{
    LTEXT "定義済みマクロ(&M):", -1, 5, 0, 100, 15, SS_CENTERIMAGE | NOT WS_GROUP
    CONTROL "", lst1, "SysListView32", LVS_EDITLABELS | LVS_SHOWSELALWAYS | LVS_SINGLESEL | LVS_REPORT | WS_BORDER | WS_TABSTOP, 5, 15, 190, 125
    PUSHBUTTON "追加(&A)...", psh1, 200, 15, 60, 14
    PUSHBUTTON "編集(&E)...", psh2, 200, 35, 60, 14
    PUSHBUTTON "削除(&D)", psh3, 200, 55, 60, 14
    PUSHBUTTON "すべて削除(&L)", psh7, 200, 105, 60, 14
    DEFPUSHBUTTON "OK", IDOK, 135, 145, 60, 14
    PUSHBUTTON "キャンセル", IDCANCEL, 200, 145, 60, 14
    PUSHBUTTON "すべてリセット(&R)", psh6, 5, 145, 60, 14
}

IDD_ADDMACRO DIALOG 0, 0, 190, 80
CAPTION "定義済みマクロの追加"
STYLE DS_MODALFRAME | WS_POPUPWINDOW | WS_CAPTION
FONT 9, "MS UI Gothic"
{
    RTEXT "キー(&K):", -1, 5, 12, 60, 14
    COMBOBOX cmb1, 70, 10, 110, 200, CBS_DROPDOWN | WS_BORDER | WS_VSCROLL | WS_TABSTOP
    RTEXT "値(&V):", -1, 5, 37, 60, 14
    COMBOBOX cmb2, 70, 35, 110, 300, CBS_DROPDOWN | WS_BORDER | WS_VSCROLL | WS_TABSTOP
    DEFPUSHBUTTON "OK", IDOK, 60, 60, 60, 14
    PUSHBUTTON "キャンセル", IDCANCEL, 125, 60, 60, 14
}

IDD_EDITMACRO DIALOG 0, 0, 190, 80
CAPTION "定義済みマクロの編集"
STYLE DS_MODALFRAME | WS_POPUPWINDOW | WS_CAPTION
FONT 9, "MS UI Gothic"
{
    RTEXT "キー(&K):", -1, 5, 12, 60, 14
    COMBOBOX cmb1, 70, 10, 110, 200, CBS_DROPDOWN | WS_DISABLED | WS_BORDER | WS_VSCROLL | WS_TABSTOP
    RTEXT "値(&V):", -1, 5, 37, 60, 14
    COMBOBOX cmb2, 70, 35, 110, 300, CBS_DROPDOWN | WS_BORDER | WS_VSCROLL | WS_TABSTOP
    DEFPUSHBUTTON "OK", IDOK, 60, 60, 60, 14
    PUSHBUTTON "キャンセル", IDCANCEL, 125, 60, 60, 14
}

IDD_CTRLDATA DIALOG 0, 0, 190, 130
CAPTION "コントロール データの編集"
STYLE DS_MODALFRAME | WS_POPUPWINDOW | WS_CAPTION
FONT 9, "MS UI Gothic"
{
    LTEXT "バイナリーデータ(&B):", -1, 5, 2, 87, 12
    EDITTEXT edt1, 5, 15, 180, 60, ES_AUTOVSCROLL | ES_MULTILINE | WS_VSCROLL
    LTEXT "コントロール データをスペース区切りの2バイトの整数の並びで入力して下さい。", -1, 5, 80, 180, 25
    DEFPUSHBUTTON "OK", IDOK, 60, 110, 60, 14
    PUSHBUTTON "キャンセル", IDCANCEL, 125, 110, 60, 14
}

IDD_PATHS DIALOG 0, 0, 295, 220
CAPTION "PATHの設定"
STYLE WS_POPUPWINDOW | WS_CAPTION | WS_THICKFRAME
FONT 9, "MS UI Gothic"
{
    LTEXT "インクルード ディレクトリ(&I):", -1, 5, 5, 102, 12
    LISTBOX lst1, 5, 20, 220, 105, LBS_NOINTEGRALHEIGHT | LBS_HASSTRINGS | LBS_SORT | WS_VSCROLL | WS_HSCROLL | WS_TABSTOP
    PUSHBUTTON "追加(&A)...", psh1, 230, 20, 60, 14
    PUSHBUTTON "編集(&E)...", psh2, 230, 40, 60, 14
    PUSHBUTTON "削除(&D)", psh3, 230, 60, 60, 14
    PUSHBUTTON "↑(&U)", psh4, 230, 80, 60, 14
    PUSHBUTTON "↓(&O)", psh5, 230, 100, 60, 14
    PUSHBUTTON "すべて削除(&L)", psh6, 5, 130, 95, 14
    RTEXT "&windres.exe:", stc1, 5, 157, 55, 12
    COMBOBOX cmb1, 70, 155, 155, 300, CBS_HASSTRINGS | CBS_AUTOHSCROLL | CBS_DROPDOWN | WS_VSCROLL | WS_TABSTOP
    PUSHBUTTON "参照(&B)...", psh7, 230, 155, 60, 14
    RTEXT "&cpp.exe:", stc2, 5, 177, 55, 12
    COMBOBOX cmb2, 70, 175, 155, 300, CBS_HASSTRINGS | CBS_AUTOHSCROLL | CBS_DROPDOWN | WS_VSCROLL | WS_TABSTOP
    PUSHBUTTON "参照(&R)...", psh8, 230, 175, 60, 14
    DEFPUSHBUTTON "OK", IDOK, 165, 200, 60, 14
    PUSHBUTTON "キャンセル", IDCANCEL, 230, 200, 60, 14
    PUSHBUTTON "すべてリセット(&S)", psh9, 5, 200, 95, 14
}

IDD_EXP_OPTIONS DIALOG 0, 0, 250, 225
CAPTION "エクスポート オプション"
STYLE DS_MODALFRAME | WS_POPUPWINDOW | WS_CAPTION
FONT 9, "MS UI Gothic"
{
    ICON IDI_MAIN, -1, 5, 10, 0, 0
    LTEXT "RCファイルを保存すると、関連するファイルも生成されます。以下のオプションを選択できます:", -1, 35, 5, 210, 29
    AUTOCHECKBOX "Microsoft の MESSAGE&TABLE を使用する", chx8, 5, 40, 240, 14
    AUTOCHECKBOX "言語別にファイルを分ける(&L)", chx1, 5, 60, 240, 14
    AUTOCHECKBOX "BEGIN/END キーワードを使う(&E)", chx2, 5, 80, 240, 14
    AUTOCHECKBOX "マクロで言語を選べるようにする(&M)", chx3, 5, 100, 240, 14
    AUTOCHECKBOX "バックアップを作成する(&B)", chx4, 5, 120, 110, 14
    RTEXT "サフィックス:", -1, 120, 122, 75, 12
    COMBOBOX cmb1, 200, 120, 45, 300, CBS_HASSTRINGS | CBS_AUTOHSCROLL | CBS_DROPDOWN | WS_VSCROLL | WS_TABSTOP
    AUTOCHECKBOX "冗長なコメントを出力する(&C)", chx5, 5, 140, 240, 14
    AUTOCHECKBOX "マニフェスト文を#ifndef MSVC ... #endif で囲む(&N)", chx6, 5, 160, 240, 14
    AUTOCHECKBOX "RC ファイルを &UTF-16 で出力する", chx7, 5, 180, 240, 14
    DEFPUSHBUTTON "OK", IDOK, 120, 205, 60, 14
    PUSHBUTTON "キャンセル", IDCANCEL, 185, 205, 60, 14
}

IDD_LANGS DIALOG 0, 0, 250, 235
CAPTION "言語の一覧"
STYLE WS_POPUPWINDOW | WS_CAPTION | WS_THICKFRAME
FONT 9, "MS UI Gothic"
{
    CONTROL "", lst1, "SysListView32", LVS_SHOWSELALWAYS | LVS_SINGLESEL | LVS_REPORT | WS_BORDER | WS_TABSTOP, 5, 5, 240, 179
    RTEXT "検索(&S):", stc1, 5, 192, 45, 12
    COMBOBOX cmb1, 55, 190, 85, 300, CBS_SORT | CBS_DROPDOWN | WS_VSCROLL | WS_TABSTOP
    EDITTEXT edt1, 4, 209, 240, 20, ES_AUTOHSCROLL | ES_AUTOVSCROLL | ES_MULTILINE
}

IDD_CHILD DIALOG 0, 0, 215, 135
CAPTION "子ダイアログ"
STYLE WS_CHILD | WS_OVERLAPPEDWINDOW
FONT 9, "MS UI Gothic"
{
    DEFPUSHBUTTON "OK", IDOK, 35, 115, 60, 14
    PUSHBUTTON "キャンセル", IDCANCEL, 115, 115, 60, 14
}

IDD_DLGINITEDIT DIALOG 0, 0, 325, 165
CAPTION "DLGINITの編集"
STYLE WS_POPUPWINDOW | WS_CAPTION | WS_THICKFRAME
FONT 9, "MS UI Gothic"
{
    LTEXT "メッセージ エントリー(&E):", -1, 5, 7, 100, 12
    CONTROL "", lst1, "SysListView32", LVS_NOSORTHEADER | LVS_AUTOARRANGE | LVS_NOLABELWRAP | LVS_SHOWSELALWAYS | LVS_SINGLESEL | LVS_REPORT | WS_BORDER | WS_VSCROLL | WS_HSCROLL | WS_TABSTOP, 5, 20, 250, 120
    PUSHBUTTON "追加(&A)...", psh1, 260, 20, 60, 14
    PUSHBUTTON "変更(&M)...", psh2, 260, 40, 60, 14
    PUSHBUTTON "削除(&D)", psh3, 260, 60, 60, 14
    PUSHBUTTON "上へ(&U)", psh4, 260, 100, 60, 14
    PUSHBUTTON "下へ(&O)", psh5, 260, 120, 60, 14
    DEFPUSHBUTTON "OK", IDOK, 195, 145, 60, 14
    PUSHBUTTON "キャンセル", IDCANCEL, 260, 145, 60, 14
    PUSHBUTTON "すべて削除(&L)", psh6, 5, 145, 79, 14
}

IDD_ADDDLGINIT DIALOG 0, 0, 184, 137
CAPTION "DLGINITデータの追加"
STYLE DS_MODALFRAME | WS_POPUPWINDOW | WS_CAPTION
FONT 9, "MS UI Gothic"
{
    LTEXT "コントロール&ID:", -1, 5, 7, 56, 12
    COMBOBOX cmb1, 65, 5, 115, 300, CBS_HASSTRINGS | CBS_AUTOHSCROLL | CBS_DROPDOWN | WS_VSCROLL | WS_TABSTOP
    LTEXT "メッセージ(&M):", -1, 5, 32, 55, 12
    COMBOBOX cmb2, 65, 30, 95, 300, CBS_HASSTRINGS | CBS_AUTOHSCROLL | CBS_DROPDOWN | WS_VSCROLL | WS_TABSTOP
    LTEXT "文字列(&S):", -1, 5, 52, 55, 12
    EDITTEXT edt1, 5, 65, 175, 50, ES_WANTRETURN | ES_MULTILINE | WS_VSCROLL | WS_HSCROLL
    DEFPUSHBUTTON "OK", IDOK, 55, 120, 60, 14
    PUSHBUTTON "キャンセル", IDCANCEL, 120, 120, 60, 14
}

IDD_MODIFYDLGINIT DIALOG 0, 0, 184, 137
CAPTION "DLGINITデータの編集"
STYLE DS_MODALFRAME | WS_POPUPWINDOW | WS_CAPTION
FONT 9, "MS UI Gothic"
{
    LTEXT "コントロール&ID:", -1, 5, 7, 56, 12
    COMBOBOX cmb1, 65, 5, 115, 300, CBS_HASSTRINGS | CBS_AUTOHSCROLL | CBS_DROPDOWN | WS_VSCROLL | WS_TABSTOP
    LTEXT "メッセージ(&M):", -1, 5, 32, 55, 12
    COMBOBOX cmb2, 65, 30, 95, 300, CBS_HASSTRINGS | CBS_AUTOHSCROLL | CBS_DROPDOWN | WS_VSCROLL | WS_TABSTOP
    LTEXT "文字列(&S):", -1, 5, 52, 55, 12
    EDITTEXT edt1, 5, 65, 175, 50, ES_WANTRETURN | ES_MULTILINE | WS_VSCROLL | WS_HSCROLL
    DEFPUSHBUTTON "OK", IDOK, 55, 120, 60, 14
    PUSHBUTTON "キャンセル", IDCANCEL, 120, 120, 60, 14
}

IDD_STRINGLIST DIALOG 0, 0, 205, 220
CAPTION "コントロールの文字列リスト"
STYLE WS_POPUPWINDOW | WS_CAPTION | WS_THICKFRAME
FONT 9, "MS UI Gothic"
{
    LTEXT "", stc1, 5, 5, 195, 70
    EDITTEXT edt1, 5, 80, 195, 115, ES_WANTRETURN | ES_MULTILINE | WS_VSCROLL | WS_HSCROLL
    DEFPUSHBUTTON "OK", IDOK, 75, 200, 60, 14
    PUSHBUTTON "キャンセル", IDCANCEL, 140, 200, 60, 14
}

IDD_SAVE_OPTIONS DIALOG 0, 0, 250, 225
CAPTION "保存オプション"
STYLE DS_MODALFRAME | WS_POPUPWINDOW | WS_CAPTION
FONT 9, "MS UI Gothic"
{
    ICON IDI_MAIN, -1, 5, 10, 0, 0
    LTEXT "RCファイルを保存すると、関連するファイルも生成されます。以下のオプションを選択できます:", -1, 35, 5, 210, 29
    AUTOCHECKBOX "Microsoft の MESSAGE&TABLE を使用する", chx8, 5, 40, 240, 14
    AUTOCHECKBOX "言語別にファイルを分ける(&L)", chx1, 5, 60, 240, 14
    AUTOCHECKBOX "BEGIN/END キーワードを使う(&E)", chx2, 5, 80, 240, 14
    AUTOCHECKBOX "マクロで言語を選べるようにする(&M)", chx3, 5, 100, 240, 14
    AUTOCHECKBOX "バックアップを作成する(&B)", chx4, 5, 120, 110, 14
    RTEXT "サフィックス:", -1, 120, 122, 75, 12
    COMBOBOX cmb1, 200, 120, 45, 300, CBS_HASSTRINGS | CBS_AUTOHSCROLL | CBS_DROPDOWN | WS_VSCROLL | WS_TABSTOP
    AUTOCHECKBOX "冗長なコメントを出力する(&C)", chx5, 5, 140, 240, 14
    AUTOCHECKBOX "マニフェスト文を#ifndef MSVC ... #endif で囲む(&N)", chx6, 5, 160, 240, 14
    AUTOCHECKBOX "RC ファイルを &UTF-16 で出力する", chx7, 5, 180, 240, 14
    DEFPUSHBUTTON "OK", IDOK, 120, 205, 60, 14
    PUSHBUTTON "キャンセル", IDCANCEL, 185, 205, 60, 14
}

IDD_ENCODING DIALOG 0, 0, 200, 170
CAPTION "リソース項目のエンコーディング"
STYLE DS_MODALFRAME | WS_POPUPWINDOW | WS_CAPTION
FONT 9, "MS UI Gothic"
{
    CONTROL "", lst1, "SysListView32", LVS_SHOWSELALWAYS | LVS_SINGLESEL | LVS_REPORT | WS_BORDER, 5, 5, 190, 115
    PUSHBUTTON "追加(&A)...", psh1, 5, 125, 60, 14
    PUSHBUTTON "変更(&M)...", psh2, 70, 125, 60, 14
    PUSHBUTTON "削除(&D)", psh3, 135, 125, 60, 14
    DEFPUSHBUTTON "OK", IDOK, 70, 150, 60, 14
    PUSHBUTTON "キャンセル", IDCANCEL, 135, 150, 60, 14
    PUSHBUTTON "リセット(&R)", psh5, 5, 149, 60, 14
}

IDD_ADDENC DIALOG 0, 0, 215, 80
CAPTION "リソース エンコーディングを追加"
STYLE DS_MODALFRAME | WS_POPUPWINDOW | WS_CAPTION
FONT 9, "MS UI Gothic"
{
    LTEXT "リソースの種類(&T):", -1, 5, 7, 70, 12
    COMBOBOX cmb1, 75, 5, 135, 200, CBS_HASSTRINGS | CBS_AUTOHSCROLL | CBS_DROPDOWN | WS_BORDER | WS_VSCROLL | WS_TABSTOP
    LTEXT "エンコーディング(&E):", -1, 5, 30, 70, 12
    COMBOBOX cmb2, 75, 30, 85, 300, CBS_HASSTRINGS | CBS_AUTOHSCROLL | CBS_DROPDOWNLIST | WS_VSCROLL | WS_TABSTOP
    DEFPUSHBUTTON "OK", IDOK, 86, 60, 60, 14
    PUSHBUTTON "キャンセル", IDCANCEL, 150, 60, 60, 14
}

IDD_MODIFYENC DIALOG 0, 0, 215, 80
CAPTION "リソース エンコーディングを変更"
STYLE DS_MODALFRAME | WS_POPUPWINDOW | WS_CAPTION
FONT 9, "MS UI Gothic"
{
    LTEXT "リソースの種類(&T):", -1, 5, 7, 70, 12
    COMBOBOX cmb1, 75, 5, 135, 200, CBS_HASSTRINGS | CBS_AUTOHSCROLL | CBS_DROPDOWN | WS_DISABLED | WS_BORDER | WS_VSCROLL | WS_TABSTOP
    LTEXT "エンコーディング(&E):", -1, 5, 30, 70, 12
    COMBOBOX cmb2, 75, 30, 85, 300, CBS_HASSTRINGS | CBS_AUTOHSCROLL | CBS_DROPDOWNLIST | WS_VSCROLL | WS_TABSTOP
    DEFPUSHBUTTON "OK", IDOK, 86, 60, 60, 14
    PUSHBUTTON "キャンセル", IDCANCEL, 150, 60, 60, 14
}

IDD_CONSTANT DIALOG 0, 0, 205, 75
CAPTION "定数の問い合わせ"
STYLE DS_MODALFRAME | WS_POPUPWINDOW | WS_CAPTION
FONT 9, "MS UI Gothic"
{
    LTEXT "定数の名前(&N):", -1, 5, 7, 80, 12
    COMBOBOX cmb1, 94, 7, 105, 300, CBS_HASSTRINGS | CBS_AUTOHSCROLL | CBS_DROPDOWN | WS_VSCROLL | WS_TABSTOP
    LTEXT "定数の値(&V):", -1, 5, 32, 80, 12
    EDITTEXT edt2, 95, 30, 50, 14, ES_READONLY
    EDITTEXT edt3, 150, 30, 50, 14, ES_READONLY
    DEFPUSHBUTTON "OK", IDOK, 70, 55, 60, 14
}

IDD_EGA DIALOG 0, 0, 400, 225
CAPTION "プログラム言語 EGA"
STYLE WS_POPUPWINDOW | WS_CAPTION | WS_THICKFRAME
FONT 9, "MS UI Gothic"
{
    GROUPBOX "EGA コンソール", grp1, 5, 5, 390, 195
    EDITTEXT edt1, 10, 20, 380, 170, ES_READONLY | ES_AUTOVSCROLL | ES_MULTILINE | WS_VSCROLL | NOT WS_TABSTOP
    RTEXT "EGA>", stc1, 10, 208, 20, 10
    EDITTEXT edt2, 35, 205, 300, 15, ES_WANTRETURN | ES_AUTOHSCROLL | ES_AUTOVSCROLL | ES_MULTILINE
    PUSHBUTTON "&Enter", IDOK, 345, 205, 50, 15
}

IDD_FONTSUBST DIALOG 0, 0, 185, 180
CAPTION "ダイアログ フォントの代替"
STYLE DS_CENTER | DS_MODALFRAME | WS_POPUPWINDOW | WS_CAPTION
FONT 9, "MS UI Gothic"
{
    LTEXT "フォント #&1:", -1, 5, 7, 44, 12
    COMBOBOX cmb1, 55, 5, 125, 300, CBS_HASSTRINGS | CBS_AUTOHSCROLL | CBS_DROPDOWN | WS_VSCROLL | WS_TABSTOP
    ICON IDI_ARROW, -1, 30, 25, 0, 0
    COMBOBOX cmb2, 55, 30, 125, 300, CBS_HASSTRINGS | CBS_AUTOHSCROLL | CBS_DROPDOWN | WS_VSCROLL | WS_TABSTOP
    LTEXT "フォント #&2:", -1, 5, 57, 44, 12
    COMBOBOX cmb3, 55, 55, 125, 300, CBS_HASSTRINGS | CBS_AUTOHSCROLL | CBS_DROPDOWN | WS_VSCROLL | WS_TABSTOP
    ICON IDI_ARROW, -1, 30, 75, 0, 0
    COMBOBOX cmb4, 55, 80, 125, 300, CBS_HASSTRINGS | CBS_AUTOHSCROLL | CBS_DROPDOWN | WS_VSCROLL | WS_TABSTOP
    LTEXT "フォント #&3:", -1, 5, 105, 44, 12
    COMBOBOX cmb5, 55, 105, 125, 300, CBS_HASSTRINGS | CBS_AUTOHSCROLL | CBS_DROPDOWN | WS_VSCROLL | WS_TABSTOP
    ICON IDI_ARROW, -1, 30, 125, 0, 0
    COMBOBOX cmb6, 55, 130, 125, 300, CBS_HASSTRINGS | CBS_AUTOHSCROLL | CBS_DROPDOWN | WS_VSCROLL | WS_TABSTOP
    DEFPUSHBUTTON "OK", IDOK, 75, 160, 50, 14
    PUSHBUTTON "キャンセル", IDCANCEL, 130, 160, 50, 14
    PUSHBUTTON "リセット(&R)", psh1, 5, 160, 55, 14
}

IDD_DROPDOWNPOPUP DIALOG 0, 0, 120, 150
CAPTION " "
STYLE WS_POPUP | WS_DLGFRAME | NOT WS_BORDER
FONT 9, "MS UI Gothic"
{
    LISTBOX lst1, 0, 0, 120, 150, LBS_WANTKEYBOARDINPUT | LBS_NOINTEGRALHEIGHT | LBS_HASSTRINGS | WS_VSCROLL | WS_TABSTOP, WS_EX_CLIENTEDGE
}

IDD_DFMSETTINGS DIALOG 0, 0, 210, 135
CAPTION "Delphi DFM の設定"
STYLE DS_CENTER | DS_MODALFRAME | WS_POPUPWINDOW | WS_CAPTION
FONT 9, "MS UI Gothic"
{
    LTEXT "以下は Delphi DFM に関連した設定です:", -1, 35, 5, 171, 20
    ICON IDI_DFMICON, -1, 5, 5, 0, 0
    RTEXT "コードページ(&C):", -1, 6, 32, 70, 12
    COMBOBOX cmb1, 85, 30, 120, 300, CBS_HASSTRINGS | CBS_AUTOHSCROLL | CBS_DROPDOWN | WS_VSCROLL | WS_TABSTOP
    AUTOCHECKBOX "生文字列のコメントを挿入する(&I)", chx1, 5, 50, 200, 14
    AUTOCHECKBOX "Unicode も UTF-8 も使わない(&U)", chx2, 5, 70, 200, 14
    DEFPUSHBUTTON "OK", IDOK, 80, 115, 60, 14
    PUSHBUTTON "キャンセル", IDCANCEL, 145, 115, 60, 14
}

IDD_COPYTOMULTILANG DIALOG 0, 0, 200, 195
CAPTION "複数の言語へ複製"
STYLE DS_CENTER | DS_MODALFRAME | WS_POPUPWINDOW | WS_CAPTION
FONT 9, "MS UI Gothic"
{
    LTEXT "コピー先の複数の言語を追加して下さい:", -1, 5, 5, 190, 22
    LTEXT "言語(&L):", -1, 5, 35, 82, 12
    LISTBOX lst1, 5, 50, 190, 100, LBS_WANTKEYBOARDINPUT | LBS_NOINTEGRALHEIGHT | LBS_HASSTRINGS | WS_VSCROLL | WS_TABSTOP
    COMBOBOX cmb3, 5, 155, 126, 14, CBS_HASSTRINGS | CBS_AUTOHSCROLL | CBS_DROPDOWN | WS_BORDER | WS_VSCROLL | WS_TABSTOP
    PUSHBUTTON "追加(&A)", psh1, 135, 155, 60, 14
    DEFPUSHBUTTON "OK", IDOK, 5, 175, 60, 14
    PUSHBUTTON "キャンセル", IDCANCEL, 70, 175, 60, 14
}

IDD_TOOLBARRES DIALOG 0, 0, 230, 195
CAPTION "ツールバー リソース"
STYLE DS_CENTER | DS_MODALFRAME | WS_POPUPWINDOW | WS_CAPTION
FONT 9, "MS UI Gothic"
{
    RTEXT "アイコンの幅(&W):", -1, 5, 5, 60, 15, SS_CENTERIMAGE | NOT WS_GROUP
    EDITTEXT edt1, 70, 5, 30, 15, ES_NUMBER | ES_RIGHT
    CONTROL "", scr1, "msctls_updown32", UDS_NOTHOUSANDS | UDS_ARROWKEYS | UDS_AUTOBUDDY | UDS_ALIGNRIGHT | UDS_SETBUDDYINT, 80, 5, 30, 15
    RTEXT "アイコンの高さ(&H):", -1, 110, 5, 60, 15, SS_CENTERIMAGE | NOT WS_GROUP
    EDITTEXT edt2, 180, 5, 30, 15, ES_NUMBER | ES_RIGHT
    CONTROL "", scr2, "msctls_updown32", UDS_NOTHOUSANDS | UDS_ARROWKEYS | UDS_AUTOBUDDY | UDS_ALIGNRIGHT | UDS_SETBUDDYINT, 190, 5, 30, 15
    LTEXT "ツールバー ボタン(&T):", -1, 5, 25, 140, 15, SS_CENTERIMAGE | NOT WS_GROUP
    LISTBOX lst1, 5, 40, 140, 130, LBS_DISABLENOSCROLL | LBS_WANTKEYBOARDINPUT | LBS_NOINTEGRALHEIGHT | LBS_HASSTRINGS | LBS_OWNERDRAWFIXED | WS_VSCROLL | WS_TABSTOP
    PUSHBUTTON "追加(&A)...", psh1, 150, 40, 75, 15
    PUSHBUTTON "変更(&M)...", psh2, 150, 60, 75, 15
    PUSHBUTTON "削除(&D)", psh3, 150, 80, 75, 15
    PUSHBUTTON "上へ(&U)", psh4, 150, 135, 75, 15
    PUSHBUTTON "下へ(&O)", psh5, 150, 155, 75, 15
    DEFPUSHBUTTON "OK", IDOK, 5, 175, 60, 15
    PUSHBUTTON "キャンセル", IDCANCEL, 70, 175, 60, 15
}

IDD_ADDTBBTN DIALOG 0, 0, 177, 92
CAPTION "ツールバー ボタンを追加"
STYLE DS_CENTER | DS_MODALFRAME | WS_POPUPWINDOW | WS_CAPTION
FONT 9, "MS UI Gothic"
{
    LTEXT "ツールバー ボタンのコマンドID(&C):", -1, 5, 5, 160, 15, SS_CENTERIMAGE | NOT WS_GROUP
    COMBOBOX cmb1, 5, 25, 150, 150, CBS_HASSTRINGS | CBS_AUTOHSCROLL | CBS_DROPDOWN | WS_VSCROLL | WS_TABSTOP
    AUTOCHECKBOX "セパレーター(&S)", chx1, 5, 45, 90, 15
    DEFPUSHBUTTON "OK", IDOK, 45, 70, 60, 15
    PUSHBUTTON "キャンセル", IDCANCEL, 110, 70, 60, 15
}

IDD_MODIFYTBBTN DIALOG 0, 0, 177, 92
CAPTION "ツールバー ボタンを変更"
STYLE DS_CENTER | DS_MODALFRAME | WS_POPUPWINDOW | WS_CAPTION
FONT 9, "MS UI Gothic"
{
    LTEXT "ツールバー ボタンのコマンドID(&C):", -1, 5, 5, 160, 15, SS_CENTERIMAGE | NOT WS_GROUP
    COMBOBOX cmb1, 5, 25, 150, 150, CBS_HASSTRINGS | CBS_AUTOHSCROLL | CBS_DROPDOWN | WS_VSCROLL | WS_TABSTOP
    AUTOCHECKBOX "セパレーター(&S)", chx1, 5, 45, 90, 15
    DEFPUSHBUTTON "OK", IDOK, 45, 70, 60, 15
    PUSHBUTTON "キャンセル", IDCANCEL, 110, 70, 60, 15
}

//////////////////////////////////////////////////////////////////////////////
// RT_VERSION

1 VERSIONINFO
FILEVERSION     5, 7, 9, 0
PRODUCTVERSION  5, 7, 9, 0
FILEOS          0x40004
FILETYPE        0x1
FILESUBTYPE     0x0
{
    BLOCK "StringFileInfo"
    {
        BLOCK "041103A4"
        {
            VALUE "CompanyName", "片山博文MZ\0"
            VALUE "FileDescription", "リソーエディタ\0"
            VALUE "FileVersion", "5.7.9\0"
            VALUE "LegalCopyright", "Copyright (C) 2017-2021 片山博文MZ. All rights reserved.\0"
            VALUE "ProductName", "RisohEditor\0"
            VALUE "ProductVersion", "5.7.9\0"
        }
    }
    BLOCK "VarFileInfo"
    {
        VALUE "Translation", 0x0411, 0x03A4
    }
}

//////////////////////////////////////////////////////////////////////////////
// RISOHTEMPLATE

4 RISOHTEMPLATE "res/1041_RISOHTEMPLATE_4.bin"

5 RISOHTEMPLATE "res/1041_RISOHTEMPLATE_5.bin"

//////////////////////////////////////////////////////////////////////////////
// RT_STRING

STRINGTABLE
{
    IDS_APPNAME, "リソーエディタ 5.7.9 by 片山博文MZ"
    IDS_TITLEWITHFILE, "リソーエディタ 5.7.9 - ファイル: %s"
    IDS_EXTRACTRES, "リソースの抽出"
    IDS_RESBINFILTER, "バイナリ リソース (*.res)|*.res|バイナリ ファイル (*.bin)|*.bin|すべてのファイル (*.*)|*.*|"
    IDS_CANNOTSAVE, "保存できませんでした。"
    IDS_REPLACERES, "リソースの置き換え"
    IDS_ALLFILES, "すべてのファイル (*.*)|*.*|"
    IDS_ENTERTYPE, "リソースの種類を入力して下さい。"
    IDS_ENTERNAME, "リソースの名前を入力して下さい。"
    IDS_ENTERLANG, "リソースの言語を入力して下さい。"
    IDS_FILENOTFOUND, "ファイルが見つかりません。"
    IDS_CANNOTREPLACE, "リソースの置き換えができませんでした。"
    IDS_EXERESFILTER, "実行可能ファイル (*.exe;*.dll;*.ocx;*.cpl;*.scr;*.mui)|*.exe;*.dll;*.ocx;*.cpl;*.scr;*.mui|RCファイル (*.rc)|*.rc|バイナリ リソース (*.res)|*.res|すべてのファイル (*.*)|*.*|"
    IDS_SAVEAS, "名前を付けて保存"
    IDS_CANNOTADDICON, "アイコンの追加ができませんでした。"
    IDS_ADDICON, "アイコンの追加"
    IDS_ICOFILTER, "アイコン ファイル (*.ico)|*.ico|アニメ アイコン (*.ani)|*.ani|すべてのファイル (*.*)|*.*|"
    IDS_REPLACEICO, "アイコンの置き換え"
    IDS_CANTREPLACEICO, "アイコンの置き換えができませんでした。"
    IDS_EXISTSOVERWRITE, "項目はすでに存在します。上書きしますか？"
    IDS_OPEN, "開く"
    IDS_CANNOTOPEN, "ファイルが開けません。"
    IDS_ADDBMP, "ビットマップの追加"
    IDS_BMPFILTER, "ビットマップ ファイル (*.bmp)|*.bmp|PNG 画像 (*.png)|*.png|すべてのファイル (*.*)|*.*|"
    IDS_CANTREPLACEBMP, "ビットマップの置き換えができませんでした。"
    IDS_REPLACEBMP, "ビットマップの置き換え"
    IDS_ERRORCODE, "エラーコード %dが発生しました。"
    IDS_VERSIONINFO, "リソーエディタ Version 5.7.9\r\n\r\n片山博文MZ\r\nかたやまひろふみえむぜっど\r\n\r\nライセンス: GPLv3 (フリーソフト)"
    IDS_ADDRES, "リソースの追加"
    IDS_CANNOTADDRES, "リソースの追加ができませんでした。"
    IDS_CANTADDBMP, "ビットマップの追加ができませんでした。"
    IDS_EXTRACTBMP, "ビットマップの抽出"
    IDS_CANTEXTRACTBMP, "ビットマップの抽出ができませんでした。"
    IDS_CANTREPLACECUR, "カーソルの置き換えができませんでした。"
    IDS_CANNOTADDCUR, "カーソルの追加ができませんでした。"
    IDS_CURFILTER, "カーソル ファイル (*.cur)|*.cur|アニメカーソル (*.ani)|*.ani|すべてのファイル (*.*)|*.*|"
    IDS_ADDCUR, "カーソルの追加"
    IDS_REPLACECUR, "カーソルの置き換え"
    IDS_EXTRACTICO, "アイコンの抽出"
    IDS_CANTEXTRACTICO, "アイコンの抽出ができませんでした。"
    IDS_EXTRACTCUR, "カーソルの抽出"
    IDS_CANTEXTRACTCUR, "カーソルの抽出ができませんでした。"
    IDS_RESFILTER, "バイナリ リソース (*.res)|*.res|すべてのファイル (*.*)|*.*|"
    IDS_NEUTRAL, "ニュートラル"
    IDS_IMPORTRES, "インポート"
    IDS_CANNOTIMPORT, "インポートできませんでした。"
    IDS_COMPILE, "コンパイル (F8)"
    IDS_CANCELEDIT, "編集をキャンセル (Ctrl+E)"
    IDS_GUIEDIT, "GUI編集 (Ctrl+G)"
    IDS_CANNOTSTARTUP, "リソースコンパイラが起動できませんでした。"
    IDS_RESMISMATCH, "リソースの種類が一致しません。"
    IDS_SAMPLETEXT, "これはサンプルです。"
    IDS_ALREADYEXISTS, "すでに存在します。"
    IDS_KEY, "キー"
    IDS_FLAGS, "フラグ群"
    IDS_COMMANDID, "コマンドID"
    IDS_INVALIDKEY, "無効なキーです。"
    IDS_COMPILEERROR, "コンパイルに失敗しました。"
    IDS_STRINGID, "文字列ID"
    IDS_STRINGVALUE, "文字列の値"
    IDS_CAPTION, "キャプション"
    IDS_HELPID, "ヘルプID"
    IDS_INDENT, "→ "
    IDS_DATAISEMPTY, "データが空です。"
    IDS_TEST, "テストする"
    IDS_SEPARATOR, "---"
    IDS_COMPILENOW, "データが変更されています。コンパイルしますか？"
    IDS_RADWINDOW, "ダイアログの編集"
    IDS_ENTERCLASS, "正当なウィンドウ クラス名を入力して下さい。"
    IDS_TEXTEDIT, "テキスト編集 (Ctrl+T)"
    IDS_CURSORINFO, "イメージ#%u: 幅 %u, 高さ %u, ビットの深さ %u, xHotSpot %u, yHotSpot %u, ID %u\r\n"
    IDS_IMAGECOUNT, "イメージ数: %u\r\n"
    IDS_ICONINFO, "イメージ#%u: 幅 %u, 高さ %u, ビットの深さ %u, ID %u\r\n"
    IDS_READY, "準備完了"
    IDS_EXECUTINGCMD, "コマンド実行中..."
    IDS_EDITINGBYGUI, "GUI編集中..."
    IDS_COORD, "%d, %d, %d, %d"
    IDS_STARTING, "起動中..."
    IDS_COMPILING, "コンパイル中..."
    IDS_CANNOTLOAD, "読み込めません。"
    IDS_NONE, "(なし)"
    IDS_WAVESOUND, "(WAVE音声)\r\n"
    IDS_IDTYPE, "IDの種類"
    IDS_IDPREFIX, "IDプレフィックス"
    IDS_EMPTYSTR, "文字列を入力して下さい。"
    IDS_ANICURSOR, "(アニメーション カーソル)\r\n"
    IDS_ANIICON, "(アニメーション アイコン)\r\n"
    IDS_HEADFILTER, "ヘッダー ファイル (*.h)|*.h|すべてのファイル (*.*)|*.*|"
    IDS_LOADRESH, "ファイル ""resource.h"" を読み込む"
    IDS_NAME, "名前"
    IDS_VALUE, "値"
    IDS_NOSUCHID, "そのようなIDは見つかりません。"
    IDS_IMAGEINFO, "幅 %u、高さ %u、ビットの深さ %u\r\n"
    IDS_ENTERINT, "正当な整数を入力して下さい。"
    IDS_ENTERTEXT, "正当なテキストを入力して下さい。"
    IDS_ENTERID, "正当なIDを入力して下さい。"
    IDS_ADDNEXTIDS, "次のリソースIDを""resource.h""に追加して下さい。:\r\n\r\n"
    IDS_DELETENEXTIDS, "次のリソースIDを""resource.h""から削除して下さい。:\r\n\r\n"
    IDS_NOCHANGE, "リソースIDの変更点はありません。"
    IDS_DLGFAIL, "RADダイアログを作成するのに失敗しました。"
    IDS_LOADWCLIB, "ウィンドウ クラス ライブラリを読み込む"
    IDS_AVIMOVIE, "(AVI動画)\r\n"
    IDS_ADDDIALOG, "ダイアログの追加"
    IDS_ADDMENU, "メニューの追加"
    IDS_ADDVERINFO, "バージョン情報の追加"
    IDS_ADDCURSOR, "カーソルの追加"
    IDS_NOMOREITEM, "項目はこれ以上ありません。"
    IDS_INVALIDDATA, "(無効なデータ)\r\n"
    IDS_UPDATERESH, """resource.h"" を更新しますか？"
    IDS_CANTWRITERESH, """resource.h"" を書き込めませんでした。"
    IDS_SAVERESH, """resource.h"" ファイルの保存"
    IDS_DLLFILTER, "DLL ファイル (*.dll;*.ocx;*.mui)|*.dll;*.ocx;*.mui|すべてのファイル (*.*)|*.*|"
    IDS_EXERESRCFILTER, "読み込めるファイル (*.exe;*.dll;*.ocx;*.cpl;*.scr;*.mui;*.res;*.rc)|*.exe;*.dll;*.ocx;*.cpl;*.scr;*.mui;*.res;*.rc|実行可能ファイル (*.exe;*.dll;*.ocx;*.cpl;*.scr;*.mui)|*.exe;*.dll;*.ocx;*.cpl;*.scr;*.mui|バイナリ リソース (*.res)|*.res|リソース ファイル (*.rc)|*.rc|すべてのファイル (*.*)|*.*|"
    IDS_CANTTESTCHILDWND, "ダイアログが子ウィンドウのため、テストできません。"
    IDS_CANTTESTCLASSDLG, "ダイアログがクラス付きのため、テストできません。"
    IDS_FILEISUPXED, "ファイル\r\n\r\n'%s'\r\n\r\nは、UPXで圧縮されています。一時ファイルを使って展開しますか？\r\n\r\n展開しなければ正しく読み込めないことがあります。"
    IDS_CANTUPXEXTRACT, "UPXで展開できませんでした。"
    IDS_CANTSAVEUPXED, "UPXで圧縮されたデータがあるので、保存できません。"
    IDS_MESSAGEID, "メッセージID"
    IDS_MESSAGEVALUE, "メッセージの値"
    IDS_RCFILTER, "RC ファイル (*.rc)|*.rc|"
    IDS_EXPORT, "エクスポート"
    IDS_CANTEXPORT, "エクスポートできませんでした。"
    IDS_MUSTBEEMPTYDIR, "外部ファイルがあるのなら、エクスポート先は空フォルダでなければなりません。"
    IDS_FULLWIDTH, "０１２３４５６７８９ＡＢＣＤＥＦＧＨＩＪＫＬＭＮＯＰＱＲＳＴＵＶＷＸＹＺａｂｃｄｅｆｇｈｉｊｋｌｍｎｏｐｑｒｓｔｕｖｗｘｙｚ－＿（）．　"
    IDS_HALFWIDTH, "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz-_(). "
    IDS_MACRONAME, "マクロ名"
    IDS_MACROVALUE, "マクロ値"
    IDS_OPTIONAL, "(オプションです)"
    IDS_ADDINCLUDE, "インクルード ディレクトリの追加"
    IDS_EDITINCLUDE, "インクルード ディレクトリの編集"
    IDS_WINDRESEXE, "windres.exe|windres.exe|"
    IDS_CPPEXE, "cpp.exe|cpp.exe|"
    IDS_INVALIDPATH, "パスが無効です。"
    IDS_DATATOOLONG, "データが長すぎます。"
    IDS_ALL, "(すべて)"
    IDS_UNKNOWNFORMAT, "(未知のデータ形式)\r\n"
    IDS_LANGUAGE, "言語"
    IDS_INTVALUE, "整数値"
    IDS_PARENTWND, "親テストウィンドウ"
    IDS_CHOOSE_OLE_CLSID, "OLE CLSIDの選択"
    IDS_CONTROL, "コントロール"
    IDS_MESSAGE, "メッセージ"
    IDS_STRING, "文字列"
    IDS_DATAISINVALID, "データが無効です。"
    IDS_DLGINIT1, "ダイアログと同名のRT_DLGINITリソースデータに初期化データを設定して、コンボボックスとリストボックスの初期化を指定できます。"
    IDS_DLGINIT2, "WM_INITDIALOGメッセージが来た時に、付属のファイル 'DlgInit/DlgInit.h' のExecuteDlgInitDx関数を呼び出せば、ダイアログの初期化を実行できます。\r\n\r\n"
    IDS_DLGINIT3, "RT_DLGINITに使う改行区切りの文字列のリストを指定して下さい。"
    IDS_SAMELANG, "同じ言語です。"
    IDS_SAMENAME, "同じリソース名です。"
    IDS_CANTSAVETOEXE, "実行可能ではないファイルからEXEに保存できません。"
    IDS_CANTSTARTSEARCH, "検索を開始できません。"
    IDS_AMERICA, "米国"
    IDS_ENGLISH, "英語"
    IDS_CHINA, "中華人民共和国"
    IDS_CHINESE, "中国語"
    IDS_RUSSIA, "ロシア"
    IDS_RUSSIAN, "ロシア語"
    IDS_WANNAGENRESH, "'resource.h' ファイルも出力しますか？"
    IDS_EXEFILTER, "実行可能ファイル (*.exe;*.dll;*.ocx;*.cpl;*.scr;*.mui)|*.exe;*.dll;*.ocx;*.cpl;*.scr;*.mui||すべてのファイル (*.*)|*.*|"
    IDS_SAVEASCOMPRESS, "名前を付けて圧縮保存"
    IDS_TOOL_NEW, "新規作成"
    IDS_TOOL_OPEN, "開く..."
    IDS_TOOL_SAVE, "保存する..."
    IDS_TOOL_EXPAND, "すべて展開"
    IDS_TOOL_COLLAPSE, "すべて折りたたむ"
    IDS_TOOL_PLUS, "項目の追加..."
    IDS_TOOL_MINUS, "項目の削除"
    IDS_TOOL_CHANGE, "名前/言語を変更"
    IDS_TOOL_CLONE, "別の名前/言語で複製"
    IDS_TOOL_RECOMPILE, "再コンパイル"
    IDS_TOOL_CANCELEDIT, "編集をキャンセル"
    IDS_TOOL_IMPORT, "インポート..."
    IDS_TOOL_EXTRACT, "抽出..."
    IDS_TOOL_GUIEDIT, "GUI編集"
    IDS_UNITEDKINGDOM, "英国"
    IDS_GREATBRITAIN, "イギリス"
    IDS_BRITISH, "イギリス語"
    IDS_FRANCE, "フランス"
    IDS_FRENCH, "フランス語"
    IDS_GERMANY, "ドイツ"
    IDS_GERMAN, "ドイツ語"
    IDS_SPAIN, "スペイン"
    IDS_SPANISH, "スペイン語"
    IDS_INVALIDLANG, "認識できない言語です。"
    IDS_INVALIDNAME, "不正なリソース名です。"
    IDS_PNGRESBINFILTER, "PNG画像 (*.png)|*.png|バイナリ リソース (*.res)|*.res|バイナリ ファイル (*.bin)|*.bin|すべてのファイル (*.*)|*.*|"
    IDS_JPEGRESBINFILTER, "JPEG画像 (*.jpg;*.jpeg;*.jpe;*.jfif)|*.jpg;*.jpeg;*.jpe;*.jfif|バイナリ リソース (*.res)|*.res|バイナリ ファイル (*.bin)|*.bin|すべてのファイル (*.*)|*.*|"
    IDS_GIFRESBINFILTER, "GIF画像 (*.gif)|*.gif|バイナリ リソース (*.res)|*.res|バイナリ ファイル (*.bin)|*.bin|すべてのファイル (*.*)|*.*|"
    IDS_TIFFRESBINFILTER, "TIFF画像 (*.tif;*.tiff)|*.tif;*.tiff|バイナリ リソース (*.res)|*.res|バイナリ ファイル (*.bin)|*.bin|すべてのファイル (*.*)|*.*|"
    IDS_AVIRESBINFILTER, "AVI動画 (*.avi)|*.avi|バイナリ リソース (*.res)|*.res|バイナリ ファイル (*.bin)|*.bin|すべてのファイル (*.*)|*.*|"
    IDS_WAVERESBINFILTER, "WAVE音声 (*.wav)|*.wav|バイナリ リソース (*.res)|*.res|バイナリ ファイル (*.bin)|*.bin|すべてのファイル (*.*)|*.*|"
    IDS_COMMENT_SEP, "//////////////////////////////////////////////////////////////////////////////\r\n"
    IDS_NEWLINE, "\r\n"
    IDS_NOTICE, "// This file is automatically generated by RisohEditor 5.7.9.\r\n"
    IDS_DAGGER, "// † <-- This dagger helps UTF-8 detection.\r\n"
    IDS_IMPORTFILTER, "インポート可能なファイル|*.rc;*.res;*.dfm;*.html;*.htm;*.manifest;*.ico;*.cur;*.ani;*.wav;*.bmp;*.dib;*.png;*.gif;*.jpg;*.jpeg;*.jpe;*.jfif;*.tif;*.tiff;*.avi;*.wmf;*.emf|RC ファイル (*.rc)|*.rc|バイナリ リソース (*.res)|*.res|画像ファイル|*.bmp;*.dib;*.png;*.gif;*.jpg;*.jpeg;*.jpe;*.jfif;*.tif;*.tiff;*.wmf;*.emf;*.tlb|カーソル ファイル (*.cur;*.ani)|*.cur;*.ani|アイコン ファイル (*.ico)|*.ico|WAVE音声ファイル (*.wav)|*.wav|HTML ファイル (*.html;*.htm)|*.html;*.htm|マニフェスト ファイル (*.manifest)|*.manifest|Delphi DFM ファイル (*.dfm)|*.dfm|TYPELIB Files (*.tlb)|*.tlb|すべてのファイル (*.*)|*.*|"
    IDS_CANTWRITEBYLOCK, "次のファイルがロックされているため、書き込めません。\r\n\r\n%s"
    IDS_ANSI, "ANSI"
    IDS_WIDE, "Unicode"
    IDS_UTF8, "UTF-8 with BOM"
    IDS_UTF8N, "UTF-8 without BOM"
    IDS_SJIS, "シフトJIS"
    IDS_BINARY, "バイナリ データ"
    IDS_RESTYPE, "リソースの種類"
    IDS_ENCODING, "エンコーディング"
    IDS_INVALIDRESTYPE, "無効なリソースの種類です。"
    IDS_PATHSPACEERROR, "スペース文字がある場所に間違ってインストールされました。リソース コンパイラはスペースを受け付けません。\n\n""C:\\Program Files""を避けて下さい。"
    IDS_LOADEGAPROGRAM, "EGAプログラムを読み込む..."
    IDS_EGAFILTER, "EGA プログラム (*.ega)|*.ega|すべてのファイル (*.*)|*.*|"
    IDS_QUERYSAVECHANGE, "ファイルは変更されています。変更内容を保存しますか?"
    IDS_DFMFILTER, "DFM ファイル (*.dfm)|*.dfm|テキストファイル (*.txt)|*.txt|すべてのファイル (*.*)|*.*|"
    IDS_CANTEXTRACTDFM, "DFM データを抽出できません。"
    IDS_EXTRACTDFM, "DFM データを抽出する"
    IDS_ENTERNONZERONAME, "ゼロではないリソース名を指定して下さい。"
    IDS_ENTERNONZEROTYPE, "ゼロではないリソースの種類を指定して下さい。"
    IDS_HOMEPAGE, "https://katahiromz.web.fc2.com/re/ja/"
    IDS_FILESAVED, "ファイルを保存しました。"
    IDS_RECOMPILEOK, "再コンパイルしました。"
    IDS_RECOMPILEFAILED, "再コンパイルに失敗しました (文法エラー)。"
    IDS_TOOL_EXPORT, "エクスポート..."
    IDS_CODEEDITOR, "コード エディタ"
    IDS_HEXVIEWER, "16進ビュア"
    IDS_INTEGERORIDENTIFIER, "(整数か識別子を入力)"
    IDS_NOTEXT, " "
    IDS_NOUPDATE, "最新のリソーエディタを使用中です。"
    IDS_THEREISUPDATE, "リソーエディタ %s が利用可能です。ダウンロードしますか?"
    IDS_CANTCHECKUPDATE, "リソーエディタの更新の確認に失敗しました。"
    IDS_CODEPAGE1252, "1252 (ラテン1)"
    IDS_CODEPAGE1250, "1250 (ラテン2)"
    IDS_CODEPAGE1251, "1251 (キリル)"
    IDS_CODEPAGE1253, "1253 (ギリシャ語)"
    IDS_CODEPAGE1254, "1254 (トルコ語)"
    IDS_CODEPAGE1255, "1255 (ヘブライ語)"
    IDS_CODEPAGE1256, "1256 (アラビア語)"
    IDS_CODEPAGE1257, "1257 (バルト)"
    IDS_CODEPAGE874, "874 (タイ)"
    IDS_CODEPAGE932, "932 (日本語)"
    IDS_CODEPAGE936, "936 (簡体字中国語)"
    IDS_CODEPAGE949, "949 (韓国語)"
    IDS_CODEPAGE950, "950 (繁体字中国語)"
    IDS_CODEPAGE65001, "65001 (UTF-8)"
    IDS_EXTRACTTLB, "TYPELIB データの抽出"
    IDS_CANTEXTRACTTLB, "TYPELIB データを抽出できませんでした。"
    IDS_TLBRESBINFILTER, "TYPELIB データ (*.tlb)|*.tlb|バイナリー リソース (*.res)|*.res|テキストファイル (*.txt)|*.txt|MIDL ファイル (*.idl)|*.idl|すべてのファイル (*.*)|*.*|"
    IDS_USAGE, "Usage: RisohEditor [options | ""file""]\n\nOptions:\n--help  Show this message.\n--version  Show version info.\n--load ""your-file.rc""  Load the file (without GUI)\n--save ""your-file.res""  Save the file (without GUI)\n--log-file ""log-file.txt""  Specify the log file.\n--load-options OPTIONS  Set load options.\n--save-options OPTIONS  Set save options.\n\nLoad options: (no-load-res-h)\nSave options: (idc-static)(compress)(sep-lang)(no-res-folder)(lang-macro)(less-comments)(wrap-manifest)(begin-end)(utf-16)(backup)(ms-msgtbl)"
    IDS_NOSELECTION, "選択がありません。"
    IDS_TRANSLATORS, "[翻訳者]\r\n英語: 片山博文MZ\r\nフィンランド語: Veikko Muurikainen\r\nインドネシア語: Mas Ahmad Muhammad\r\nイタリア語: R.B.\r\n日本語: 片山博文MZ\r\n韓国語: VenusGirl (비너스걸)\r\nポーランド語: Piotr Hetnarowicz\r\nポルトガル語: JNylson\r\nロシア語: Dmitry Yerokhin\r\n中国語（簡体字）: 林鸿湘\r\n"
}

//////////////////////////////////////////////////////////////////////////////

```

`src/lang/ko_KR.rc`:

```rc
// This file is automatically generated by RisohEditor 5.7.9.
// † <-- This dagger helps UTF-8 detection.

#pragma code_page(65001) // UTF-8

LANGUAGE LANG_KOREAN, SUBLANG_DEFAULT

//////////////////////////////////////////////////////////////////////////////
// RT_MENU

IDR_MAINMENU MENU
{
    POPUP "파일(&F)"
    {
        MENUITEM "새로 만들기(&N)\tCtrl+N", ID_NEW
        MENUITEM SEPARATOR
        MENUITEM "열기(&O)...\tCtrl+O", ID_OPEN
        MENUITEM "저장(&S)...\tCtrl+S", ID_SAVE
        MENUITEM "다른 이름으로 저장(&A)...\tShift+Ctrl+S", ID_SAVEAS
        MENUITEM "압축으로 저장(&M)...", ID_SAVEASCOMPRESS
        MENUITEM SEPARATOR
        MENUITEM "가져오기(&I)...\tCtrl+I", ID_IMPORT
        MENUITEM "내보내기(&E)...\tCtrl+P", ID_EXPORT
        MENUITEM SEPARATOR
        MENUITEM "resource.h 다시 불러오기(&R)...\tCtrl+R", ID_LOADRESH
        MENUITEM "resource.h 저장(&S)...", ID_UPDATERESHBANG
        MENUITEM "resource.h 수정 알림(&V)...", ID_ADVICERESH
        MENUITEM "resource.h 불러오기 해제(&U)", ID_UNLOADRESH
        MENUITEM SEPARATOR
        MENUITEM "Window 클래스 라이브러리 불러오기(&W)...", ID_LOADWCLIB
        MENUITEM SEPARATOR
        POPUP "최근에 사용한 파일"
        {
            MENUITEM "(없음)", -1, GRAYED
        }
        MENUITEM SEPARATOR
        MENUITEM "종료(&X)\tAlt+F4", ID_EXIT
    }
    POPUP "편집(&E)"
    {
        MENUITEM "GUI로 편집(&G)...\tCtrl+G", ID_GUIEDIT
        MENUITEM SEPARATOR
        POPUP "추가(&A)"
        {
            MENUITEM "아이콘 추가(&I)...", ID_ADDICON
            MENUITEM "커서 추가(&C)...", ID_ADDCURSOR
            MENUITEM "비트맵 추가(&B)...", ID_ADDBITMAP
            MENUITEM "대화상자 추가(&D)...", ID_ADDDIALOG
            MENUITEM "메뉴 추가(&M)...", ID_ADDMENU
            MENUITEM "문자열 테이블 추가(&S)...", ID_ADDSTRINGTABLE
            MENUITEM "메시지 테이블 추가(&E)...", ID_ADDMESSAGETABLE
            MENUITEM "HTML 추가(&H)...", ID_ADDHTML
            MENUITEM "액세스 키 추가(&A)...", ID_ADDACCEL
            MENUITEM "버전 정보 추가(&V)...", ID_ADDVERINFO
            MENUITEM "메니페스트 추가(&F)...", ID_ADDMANIFEST
            MENUITEM "도구모음 추가(&T)...", ID_ADDTOOLBAR
            MENUITEM "리소스 항목 추가(&R)...", ID_ADDRES
        }
        POPUP "바꾸기(&R)"
        {
            MENUITEM "아이콘 바꾸기(&I)...", ID_REPLACEICON
            MENUITEM "커서 바꾸기(&C)...", ID_REPLACECURSOR
            MENUITEM "비트맵 바꾸기(&B)...", ID_REPLACEBITMAP
            MENUITEM "바이너리 리소스 항목 바꾸기(&R)...", ID_REPLACEBIN
        }
        POPUP "추출(&E)"
        {
            MENUITEM "아이콘 추출(&I)...", ID_EXTRACTICON
            MENUITEM "커서 추출(&C)...", ID_EXTRACTCURSOR
            MENUITEM "비트맵 추출(&B)...", ID_EXTRACTBITMAP
            MENUITEM "RC 파일로 추출(&A)...", ID_EXTRACTRC
            MENUITEM "바이너리 리소스 항목 추출(&R)...", ID_EXTRACTBIN
        }
        MENUITEM SEPARATOR
        MENUITEM "이름/언어 변경(&H)\tF2", ID_EDITLABEL
        MENUITEM SEPARATOR
        MENUITEM "새 이름으로 복제(&N)...", ID_COPYASNEWNAME
        MENUITEM "새 언어로 복제(&L)...", ID_COPYASNEWLANG
        MENUITEM "여러 언어로 복사...", ID_COPYTOMULTILANG
        MENUITEM SEPARATOR
        MENUITEM "테스트(&T)", ID_TEST
        MENUITEM SEPARATOR
        MENUITEM "삭제(&D)\tDel", ID_DELETERES
        MENUITEM SEPARATOR
        MENUITEM "ID 연결(&I)...", ID_IDASSOC
        MENUITEM "사전 정의 매크로(&M)...", ID_PREDEFMACROS
        MENUITEM "글꼴 설정(&F)...", ID_FONTS
        MENUITEM "경로 설정(&P)...", ID_SETPATHS
        MENUITEM SEPARATOR
        MENUITEM "&UI Language Select (UI语言选择)...", ID_CHOOSEUILANG
        MENUITEM SEPARATOR
        MENUITEM "Delphi DFM 설정(&S)...", ID_DFMSETTINGS
        MENUITEM "구성(&C)...", ID_CONFIG
    }
    POPUP "검색(&S)"
    {
        MENUITEM "찾기(&F)...\tCtrl+F", ID_FIND
        MENUITEM SEPARATOR
        MENUITEM "위로 검색(&U)\tShift+F3", ID_FINDUPWARD
        MENUITEM "아래로 검색(&D)\tF3", ID_FINDDOWNWARD
        MENUITEM SEPARATOR
        MENUITEM "쿼리 상수(&Q)...", ID_QUERYCONSTANT
    }
    POPUP "보기(&V)"
    {
        MENUITEM "상태 표시줄(&S)", ID_STATUSBAR
        MENUITEM "도구모음(&T)", ID_SHOWHIDETOOLBAR
        MENUITEM "바이너리(&B)", ID_BINARYPANE
        MENUITEM SEPARATOR
        MENUITEM "모두 확장(&X)\tCtrl+K", ID_EXPAND_ALL
        MENUITEM "모두 축소(&O)\tCtrl+L", ID_COLLAPSE_ALL
        MENUITEM SEPARATOR
        MENUITEM "리소스 ID 목록(&R)", ID_IDLIST
        MENUITEM "언어 목록(&L)...", ID_SHOWLANGS
        MENUITEM SEPARATOR
        MENUITEM "항상 CONTROL 문(&C)", ID_ALWAYSCONTROL
        MENUITEM "ID 매크로 사용 안 함(&I)", ID_HIDEIDMACROS
        MENUITEM "IDC_STATIC 사용(&A)", ID_USEIDC_STATIC
        MENUITEM "단어 줄바꿈(&W)", ID_WORD_WRAP
        MENUITEM "BEGIN/END 사용(&G)", ID_USEBEGINEND
        MENUITEM "Microsoft 메시지 테이블 사용(&T)", ID_USEMSMSGTBL
        MENUITEM SEPARATOR
        MENUITEM "리소스 항목의 인코딩(&E)...", ID_ENCODING
        MENUITEM "대화 상자 글꼴 대체(&F)...", ID_DIALOG_FONT_SUBSTITUTES
        MENUITEM SEPARATOR
        MENUITEM "새로 고침(&F)", ID_REFRESHALL
    }
    POPUP "자동화(&A)"
    {
        MENUITEM "프로그래밍 언어 EGA(&E)...", ID_EGA
        MENUITEM "EGA 프로그램 실행(&R)...", ID_EGA_PROGRAM
        MENUITEM "EGA 수동 열기(&M)", ID_OPEN_EGA_MANUAL
    }
    POPUP "도움말(&H)"
    {
        MENUITEM "README.txt 열기 (한국어)(&K)", ID_OPENREADMEKO
        MENUITEM "README.txt 열기 (영어)(&R)", ID_OPENREADME
        MENUITEM "HISTORY-KOR.txt", ID_OPENHISTORYKOR
        MENUITEM "HISTORY.txt", ID_OPENHISTORY
        MENUITEM "LICENSE.txt 열기(&L)", ID_OPENLICENSE
        MENUITEM SEPARATOR
        MENUITEM "RisohEditor 안내서(&G)", ID_GUIDE
        MENUITEM "RisohEditor 업데이트 확인(&U)...", ID_CHECKUPDATE
        MENUITEM SEPARATOR
        MENUITEM "정보(&A)...", ID_ABOUT
    }
}

IDR_POPUPMENUS MENU
{
    POPUP "Popup #0"
    {
        MENUITEM "GUI로 편집(&G)...\tCtrl+G", ID_GUIEDIT
        MENUITEM SEPARATOR
        POPUP "추가(&A)"
        {
            MENUITEM "아이콘 추가(&I)...", ID_ADDICON
            MENUITEM "커서 추가(&C)...", ID_ADDCURSOR
            MENUITEM "비트맵 추가(&B)...", ID_ADDBITMAP
            MENUITEM "대화상자 추가(&D)...", ID_ADDDIALOG
            MENUITEM "메뉴 추가(&M)...", ID_ADDMENU
            MENUITEM "문자열 테이블 추가(&S)...", ID_ADDSTRINGTABLE
            MENUITEM "메시지 테이블 추가(&E)...", ID_ADDMESSAGETABLE
            MENUITEM "HTML 추가(&H)...", ID_ADDHTML
            MENUITEM "액세스 키 추가(&A)...", ID_ADDACCEL
            MENUITEM "버전 정보 추가(&V)...", ID_ADDVERINFO
            MENUITEM "메니페스트 추가(&F)...", ID_ADDMANIFEST
            MENUITEM "도구모음 추가(&T)...", ID_ADDTOOLBAR
            MENUITEM "리소스 항목 추가(&R)...", ID_ADDRES
        }
        POPUP "바꾸기(&R)"
        {
            MENUITEM "아이콘 바꾸기(&)...", ID_REPLACEICON
            MENUITEM "커서 바꾸기(&C)...", ID_REPLACECURSOR
            MENUITEM "비트맵 바꾸기(&B)...", ID_REPLACEBITMAP
            MENUITEM "바이너리 리소스 항목 바꾸기(&R)...", ID_REPLACEBIN
        }
        POPUP "추출(&E)"
        {
            MENUITEM "아이콘 추출(&I)...", ID_EXTRACTICON
            MENUITEM "커서 추출(&C)...", ID_EXTRACTCURSOR
            MENUITEM "비트맵 추출(&B)...", ID_EXTRACTBITMAP
            MENUITEM "RC 파일로 추출(&A)...", ID_EXTRACTRC
            MENUITEM "바이너리 리소스 항목 추출(&R)...", ID_EXTRACTBIN
        }
        MENUITEM SEPARATOR
        MENUITEM "이름/언어 변경(&H)\tF2", ID_EDITLABEL
        MENUITEM SEPARATOR
        MENUITEM "새 이름으로 복제(&N)", ID_COPYASNEWNAME
        MENUITEM "새 언어로 복제(&L)...", ID_COPYASNEWLANG
        MENUITEM "여러 언어로 복사...", ID_COPYTOMULTILANG
        MENUITEM SEPARATOR
        MENUITEM "테스트(&T)", ID_TEST
        MENUITEM SEPARATOR
        MENUITEM "삭제(&D)\tDel", ID_DELETERES
    }
    POPUP "Popup #1"
    {
        MENUITEM "제어 추가(&A)...", ID_ADDCTRL
        MENUITEM SEPARATOR
        MENUITEM "잘라내기(&T)\tCtrl+X", ID_CUT
        MENUITEM "복사(&C)\tCtrl+C", ID_COPY
        MENUITEM "붙여넣기(&P)\tCtrl+V", ID_PASTE
        MENUITEM "삭제(&D)\tDel", ID_DELCTRL
        MENUITEM SEPARATOR
        POPUP "색인(&I)"
        {
            MENUITEM "위로 이동(&T)", ID_CTRLINDEXTOP
            MENUITEM SEPARATOR
            MENUITEM "색인 감소(&D)", ID_CTRLINDEXMINUS
            MENUITEM "색인 증가(&I)", ID_CTRLINDEXPLUS
            MENUITEM SEPARATOR
            MENUITEM "아래로 이동((&B)", ID_CTRLINDEXBOTTOM
            MENUITEM SEPARATOR
            MENUITEM "색인 표시/숨기기\tCtrl+D", ID_SHOWHIDEINDEX
        }
        POPUP "정렬(&A)"
        {
            MENUITEM "상단 정렬(&T)", ID_TOPALIGN
            MENUITEM "하단 정렬(&B)", ID_BOTTOMALIGN
            MENUITEM "왼쪽 정렬(&L)", ID_LEFTALIGN
            MENUITEM "오른쪽 정렬(&R)", ID_RIGHTALIGN
            MENUITEM SEPARATOR
            MENUITEM "안내선에 맞추기(&G)", ID_FITTOGRID
        }
        MENUITEM SEPARATOR
        MENUITEM "새로 고침(&R)", ID_REFRESHDIALOG
        MENUITEM SEPARATOR
        MENUITEM "제어 속성(&P)...", ID_CTRLPROP
        MENUITEM "대화상자 속성(&O)...", ID_DLGPROP
    }
    POPUP "Popup #2"
    {
        MENUITEM "수정(&M)...", ID_MODIFYASSOC
    }
    POPUP "Popup #3"
    {
        MENUITEM "이동!(&J)", ID_IDJUMP
        MENUITEM SEPARATOR
        MENUITEM "ID 추가(&A)...", ID_ADDRESID
        MENUITEM "ID 수정(&M)...", ID_MODIFYRESID
        MENUITEM SEPARATOR
        MENUITEM "이름 복사(&N)", ID_COPYRESIDNAME
        MENUITEM "값 복사(&V)", ID_COPYRESIDVALUE
        MENUITEM "정의 복사(&D)\tCtrl+C", ID_COPYIDDEF
        MENUITEM SEPARATOR
        MENUITEM "ID 삭제(&D)\tDel", ID_DELETERESID
        MENUITEM SEPARATOR
        MENUITEM "10진수(&D)", ID_BASE10
        MENUITEM "16진수(&H)", ID_BASE16
        MENUITEM SEPARATOR
        MENUITEM "디시 불러오기(&R)", ID_LOADRESH
    }
    POPUP "Popup #4"
    {
        MENUITEM "추가(&A)...", ID_ADD
        MENUITEM SEPARATOR
        MENUITEM "이름 변경(&N)...\tF2", ID_RENAME
        MENUITEM "값 변경(&V)...", ID_MODIFY
        MENUITEM SEPARATOR
        MENUITEM "삭제(&D)\tDel", ID_DELETE
    }
    POPUP "Popup #5"
    {
        MENUITEM "정수값 복사(&C)", ID_COPY
    }
    POPUP "Popup #6"
    {
        MENUITEM "추가(&A)...", psh1
        MENUITEM "변경(&M)...", psh2
        MENUITEM SEPARATOR
        MENUITEM "위로(&U)", psh4
        MENUITEM "아래로(&D)", psh5
        MENUITEM "왼쪽(&L)", psh6
        MENUITEM "오른쪽(&R)", psh7
        MENUITEM SEPARATOR
        MENUITEM "삭제(&T)\tDel", psh3
    }
    POPUP "Popup #7"
    {
        MENUITEM "추가(&A)...", psh1
        MENUITEM "변경(&M)...", psh2
        MENUITEM SEPARATOR
        MENUITEM "위로(&U)", psh4
        MENUITEM "아래(&D)", psh5
        MENUITEM SEPARATOR
        MENUITEM "삭제(&T)\tDel", psh3
    }
    POPUP "Popup #8"
    {
        MENUITEM "추가(&A)...", ID_ADD
        MENUITEM "수정(&M)...", ID_MODIFY
        MENUITEM SEPARATOR
        MENUITEM "삭제(&D)\tDel", ID_DELETE
    }
}

//////////////////////////////////////////////////////////////////////////////
// RT_DIALOG

IDD_REPLACERES DIALOGEX 0, 0, 215, 170
CAPTION "리소스 바꾸기"
STYLE DS_MODALFRAME | WS_POPUPWINDOW | WS_CAPTION
FONT 9, "Gulim", 0, 0, 1
{
    LTEXT "리소스 유형(&T):", -1, 5, 7, 70, 12
    COMBOBOX cmb1, 75, 5, 135, 200, CBS_HASSTRINGS | CBS_AUTOHSCROLL | CBS_DROPDOWN | WS_BORDER | WS_VSCROLL | WS_TABSTOP
    LTEXT "리소스 이름(&N):", -1, 5, 32, 70, 12
    COMBOBOX cmb2, 75, 30, 135, 200, CBS_HASSTRINGS | CBS_AUTOHSCROLL | CBS_DROPDOWN | WS_DISABLED | WS_BORDER | WS_VSCROLL | WS_TABSTOP
    LTEXT "리소스 언어(&L):", -1, 5, 57, 70, 12
    COMBOBOX cmb3, 75, 55, 135, 200, CBS_HASSTRINGS | CBS_AUTOHSCROLL | CBS_DROPDOWN | WS_DISABLED | WS_BORDER | WS_VSCROLL | WS_TABSTOP
    LTEXT "바이너리 파일(&F):", -1, 5, 85, 100, 12
    EDITTEXT edt1, 5, 97, 205, 14, ES_AUTOHSCROLL
    PUSHBUTTON "찾아보기(&B)...", psh1, 150, 115, 60, 14
    DEFPUSHBUTTON "확인", IDOK, 35, 150, 60, 14
    PUSHBUTTON "취소", IDCANCEL, 115, 150, 60, 14
    {
        0x1234, 0x5678, 0x0011
    }
}

IDD_ADDICON DIALOG 0, 0, 215, 135
CAPTION "아이콘 추가"
STYLE DS_MODALFRAME | WS_POPUPWINDOW | WS_CAPTION
FONT 9, "Gulim"
{
    LTEXT "아이콘 파일(&I):", -1, 5, 7, 100, 12
    EDITTEXT edt1, 5, 18, 205, 14, ES_AUTOHSCROLL
    PUSHBUTTON "찾아보기(&B)...", psh1, 150, 35, 60, 14
    ICON 0, ico1, 5, 35, 0, 0
    LTEXT "리소스 이름(&N):", -1, 5, 67, 70, 12
    COMBOBOX cmb2, 75, 65, 120, 300, CBS_HASSTRINGS | CBS_AUTOHSCROLL | CBS_DROPDOWN | WS_BORDER | WS_VSCROLL | WS_TABSTOP
    PUSHBUTTON "&...", psh2, 195, 65, 15, 14
    LTEXT "리소스 언어(&L):", -1, 5, 92, 70, 12
    COMBOBOX cmb3, 75, 90, 135, 200, CBS_HASSTRINGS | CBS_AUTOHSCROLL | CBS_DROPDOWN | WS_BORDER | WS_VSCROLL | WS_TABSTOP
    DEFPUSHBUTTON "확인", IDOK, 35, 115, 60, 14
    PUSHBUTTON "취소", IDCANCEL, 115, 115, 60, 14
}

IDD_REPLACEICON DIALOG 0, 0, 215, 135
CAPTION "아이콘 바꾸기"
STYLE DS_MODALFRAME | WS_POPUPWINDOW | WS_CAPTION
FONT 9, "Gulim"
{
    LTEXT "아이콘 파일(&I):", -1, 5, 7, 100, 12
    EDITTEXT edt1, 5, 18, 205, 14, ES_AUTOHSCROLL
    PUSHBUTTON "찾아보기(&B)...", psh1, 150, 35, 60, 14
    ICON 0, ico1, 5, 35, 0, 0
    LTEXT "리소스 이름(&N):", -1, 5, 67, 70, 12
    COMBOBOX cmb2, 75, 65, 135, 13, CBS_HASSTRINGS | CBS_AUTOHSCROLL | CBS_DROPDOWN | WS_DISABLED | WS_BORDER | WS_VSCROLL | WS_TABSTOP
    LTEXT "리소스 언어(&L):", -1, 5, 92, 70, 12
    COMBOBOX cmb3, 75, 90, 135, 13, CBS_HASSTRINGS | CBS_AUTOHSCROLL | CBS_DROPDOWN | WS_DISABLED | WS_BORDER | WS_VSCROLL | WS_TABSTOP
    DEFPUSHBUTTON "확인", IDOK, 35, 115, 60, 14
    PUSHBUTTON "취소", IDCANCEL, 115, 115, 60, 14
}

IDD_ADDBITMAP DIALOG 0, 0, 215, 135
CAPTION "비트맵 추가"
STYLE DS_MODALFRAME | WS_POPUPWINDOW | WS_CAPTION
FONT 9, "Gulim"
{
    LTEXT "비트맵 파일(&B):", -1, 5, 7, 100, 12
    EDITTEXT edt1, 5, 18, 205, 14, ES_AUTOHSCROLL
    PUSHBUTTON "찾아보기(&B)...", psh1, 150, 35, 60, 14
    LTEXT "리소스 이름(&N):", -1, 5, 67, 70, 12
    COMBOBOX cmb2, 75, 65, 120, 300, CBS_HASSTRINGS | CBS_AUTOHSCROLL | CBS_DROPDOWN | WS_BORDER | WS_VSCROLL | WS_TABSTOP
    PUSHBUTTON "&...", psh2, 195, 65, 15, 14
    LTEXT "리소스 언어(&L):", -1, 5, 92, 70, 12
    COMBOBOX cmb3, 75, 90, 135, 200, CBS_HASSTRINGS | CBS_AUTOHSCROLL | CBS_DROPDOWN | WS_BORDER | WS_VSCROLL | WS_TABSTOP
    DEFPUSHBUTTON "확인", IDOK, 35, 115, 60, 14
    PUSHBUTTON "취소", IDCANCEL, 115, 115, 60, 14
}

IDD_REPLACEBMP DIALOG 0, 0, 215, 135
CAPTION "비트맵 바꾸기"
STYLE DS_MODALFRAME | WS_POPUPWINDOW | WS_CAPTION
FONT 9, "Gulim"
{
    LTEXT "비트맵 파일(&B):", -1, 5, 7, 100, 12
    EDITTEXT edt1, 5, 18, 205, 14, ES_AUTOHSCROLL
    PUSHBUTTON "찾아보기(&B)...", psh1, 150, 35, 60, 14
    LTEXT "리소스 이름(&L):", -1, 5, 67, 70, 12
    COMBOBOX cmb2, 75, 65, 135, 200, CBS_HASSTRINGS | CBS_AUTOHSCROLL | CBS_DROPDOWN | WS_DISABLED | WS_BORDER | WS_VSCROLL | WS_TABSTOP
    LTEXT "리소스 언어(&L)", -1, 5, 92, 70, 12
    COMBOBOX cmb3, 75, 90, 135, 200, CBS_HASSTRINGS | CBS_AUTOHSCROLL | CBS_DROPDOWN | WS_DISABLED | WS_BORDER | WS_VSCROLL | WS_TABSTOP
    DEFPUSHBUTTON "확인", IDOK, 35, 115, 60, 14
    PUSHBUTTON "취소", IDCANCEL, 115, 115, 60, 14
}

IDD_ADDRES DIALOG 0, 0, 215, 170
CAPTION "리소스 추가"
STYLE DS_MODALFRAME | WS_POPUPWINDOW | WS_CAPTION
FONT 9, "Gulim"
{
    LTEXT "리소스 유형(&T):", -1, 5, 7, 70, 12
    COMBOBOX cmb1, 75, 5, 135, 200, CBS_HASSTRINGS | CBS_AUTOHSCROLL | CBS_DROPDOWN | WS_BORDER | WS_VSCROLL | WS_TABSTOP
    LTEXT "리소스 이름(&L):", -1, 5, 32, 70, 12
    COMBOBOX cmb2, 75, 30, 120, 300, CBS_HASSTRINGS | CBS_AUTOHSCROLL | CBS_DROPDOWN | WS_BORDER | WS_VSCROLL | WS_TABSTOP
    PUSHBUTTON "&...", psh2, 195, 30, 15, 14
    LTEXT "", stc1, 75, 43, 115, 10
    LTEXT "리소스 언어(&L)", -1, 5, 57, 70, 12
    COMBOBOX cmb3, 75, 55, 135, 200, CBS_HASSTRINGS | CBS_AUTOHSCROLL | CBS_DROPDOWN | WS_BORDER | WS_VSCROLL | WS_TABSTOP
    LTEXT "바이너리 파일(&F):", -1, 5, 85, 100, 12
    EDITTEXT edt1, 5, 97, 205, 14, ES_AUTOHSCROLL
    PUSHBUTTON "찾아보기(&B)...", psh1, 150, 115, 60, 14
    LTEXT "", stc2, 5, 112, 100, 10
    DEFPUSHBUTTON "확인", IDOK, 35, 150, 60, 14
    PUSHBUTTON "취소", IDCANCEL, 115, 150, 60, 14
}

IDD_ADDCURSOR DIALOG 0, 0, 215, 135
CAPTION "커서 추가"
STYLE DS_MODALFRAME | WS_POPUPWINDOW | WS_CAPTION
FONT 9, "Gulim"
{
    LTEXT "커서 파일(&C):", -1, 5, 7, 100, 12
    EDITTEXT edt1, 5, 18, 205, 14, ES_AUTOHSCROLL
    PUSHBUTTON "찾아보기(&B)...", psh1, 150, 35, 60, 14
    ICON 0, ico1, 5, 35, 0, 0
    LTEXT "리소스 이름(&L):", -1, 5, 67, 70, 12
    COMBOBOX cmb2, 75, 65, 120, 200, CBS_HASSTRINGS | CBS_AUTOHSCROLL | CBS_DROPDOWN | WS_BORDER | WS_VSCROLL | WS_TABSTOP
    PUSHBUTTON "&...", psh2, 195, 65, 15, 14
    LTEXT "리소스 언어(&L)", -1, 5, 92, 70, 12
    COMBOBOX cmb3, 75, 90, 135, 200, CBS_HASSTRINGS | CBS_AUTOHSCROLL | CBS_DROPDOWN | WS_BORDER | WS_VSCROLL | WS_TABSTOP
    DEFPUSHBUTTON "확인", IDOK, 35, 115, 60, 14
    PUSHBUTTON "취소", IDCANCEL, 115, 115, 60, 14
}

IDD_REPLACECUR DIALOG 0, 0, 215, 135
CAPTION "커서 바꾸기"
STYLE DS_MODALFRAME | WS_POPUPWINDOW | WS_CAPTION
FONT 9, "Gulim"
{
    LTEXT "커서 파일(&C):", -1, 5, 7, 100, 12
    EDITTEXT edt1, 5, 18, 205, 14, ES_AUTOHSCROLL
    PUSHBUTTON "찾아보기(&B)...", psh1, 150, 35, 60, 14
    ICON 0, ico1, 5, 35, 0, 0
    LTEXT "리소스 이름(&L):", -1, 5, 67, 70, 12
    COMBOBOX cmb2, 75, 65, 135, 200, CBS_HASSTRINGS | CBS_AUTOHSCROLL | CBS_DROPDOWN | WS_DISABLED | WS_BORDER | WS_VSCROLL | WS_TABSTOP
    LTEXT "리소스 언어(&L)", -1, 5, 92, 70, 12
    COMBOBOX cmb3, 75, 90, 135, 200, CBS_HASSTRINGS | CBS_AUTOHSCROLL | CBS_DROPDOWN | WS_DISABLED | WS_BORDER | WS_VSCROLL | WS_TABSTOP
    DEFPUSHBUTTON "확인", IDOK, 35, 115, 60, 14
    PUSHBUTTON "취소", IDCANCEL, 115, 115, 60, 14
}

IDD_MENUTEST DIALOG 0, 0, 215, 135
CAPTION "메뉴 테스트"
STYLE DS_MODALFRAME | WS_POPUPWINDOW | WS_CAPTION
FONT 9, "MS Shell Dlg"
{
}

IDD_ADDKEY DIALOG 0, 0, 190, 120
CAPTION "키 추가"
STYLE DS_MODALFRAME | WS_POPUPWINDOW | WS_CAPTION
FONT 9, "Gulim"
{
    RTEXT "키(&K):", -1, 5, 12, 60, 14
    COMBOBOX cmb1, 70, 10, 110, 200, CBS_DROPDOWN | WS_BORDER | WS_VSCROLL | WS_TABSTOP
    RTEXT "명령 ID(&I):", -1, 5, 37, 60, 14
    COMBOBOX cmb2, 70, 35, 95, 300, CBS_DROPDOWN | WS_BORDER | WS_VSCROLL | WS_TABSTOP
    PUSHBUTTON "&...", psh1, 165, 35, 15, 14
    AUTOCHECKBOX "&VIRTKEY", chx1, 5, 60, 60, 14
    AUTOCHECKBOX "&NOINVERT", chx2, 70, 60, 60, 14
    AUTOCHECKBOX "&CONTROL", chx3, 5, 75, 60, 14
    AUTOCHECKBOX "&SHIFT", chx4, 70, 75, 60, 14
    AUTOCHECKBOX "&ALT", chx5, 140, 75, 45, 14
    DEFPUSHBUTTON "확인", IDOK, 60, 100, 60, 14
    PUSHBUTTON "취소", IDCANCEL, 125, 100, 60, 14
}

IDD_MODIFYKEY DIALOG 0, 0, 190, 120
CAPTION "키 수정"
STYLE DS_MODALFRAME | WS_POPUPWINDOW | WS_CAPTION
FONT 9, "Gulim"
{
    RTEXT "키(&K)", -1, 5, 12, 60, 14
    COMBOBOX cmb1, 70, 10, 110, 200, CBS_DROPDOWN | WS_BORDER | WS_VSCROLL | WS_TABSTOP
    RTEXT "명령 ID(&I):", -1, 5, 37, 60, 14
    COMBOBOX cmb2, 70, 35, 95, 200, CBS_DROPDOWN | WS_BORDER | WS_VSCROLL | WS_TABSTOP
    PUSHBUTTON "&...", psh1, 165, 35, 15, 14
    AUTOCHECKBOX "&VIRTKEY", chx1, 5, 60, 60, 14
    AUTOCHECKBOX "&NOINVERT", chx2, 70, 60, 60, 14
    AUTOCHECKBOX "&CONTROL", chx3, 5, 75, 60, 14
    AUTOCHECKBOX "&SHIFT", chx4, 70, 75, 60, 14
    AUTOCHECKBOX "&ALT", chx5, 140, 75, 45, 14
    DEFPUSHBUTTON "확인", IDOK, 60, 100, 60, 14
    PUSHBUTTON "취소", IDCANCEL, 125, 100, 60, 14
}

IDD_EDITACCEL DIALOG 0, 0, 285, 165
CAPTION "액세스 키 편집"
STYLE WS_POPUPWINDOW | WS_CAPTION | WS_THICKFRAME
FONT 9, "Gulim"
{
    LTEXT "키 목록(&L):", -1, 5, 7, 100, 12
    CONTROL "", lst1, "SysListView32", LVS_NOSORTHEADER | LVS_AUTOARRANGE | LVS_NOLABELWRAP | LVS_SHOWSELALWAYS | LVS_SINGLESEL | LVS_REPORT | WS_BORDER | WS_VSCROLL | WS_HSCROLL | WS_TABSTOP, 5, 20, 210, 120
    PUSHBUTTON "추가(&A)...", psh1, 220, 20, 60, 14
    PUSHBUTTON "수정(&M)...", psh2, 220, 40, 60, 14
    PUSHBUTTON "삭제(&D)", psh3, 220, 60, 60, 14
    PUSHBUTTON "위로(&U)", psh4, 220, 100, 60, 14
    PUSHBUTTON "아래로(&O)", psh5, 220, 120, 60, 14
    DEFPUSHBUTTON "확인", IDOK, 155, 145, 60, 14
    PUSHBUTTON "취소", IDCANCEL, 220, 145, 60, 14
    PUSHBUTTON "모두 삭제(&L)...", psh6, 5, 145, 79, 14
}

IDD_ADDSTR DIALOG 0, 0, 255, 115
CAPTION "문자열 항목 추가"
STYLE WS_POPUPWINDOW | WS_CAPTION | WS_THICKFRAME
FONT 9, "Gulim"
{
    LTEXT "문자열 ID(&I):", -1, 5, 7, 50, 12
    COMBOBOX cmb1, 60, 5, 134, 200, CBS_HASSTRINGS | CBS_AUTOHSCROLL | CBS_DROPDOWN | WS_BORDER | WS_VSCROLL | WS_TABSTOP
    PUSHBUTTON "&...", psh1, 195, 5, 15, 14
    LTEXT "문자열 값(&V):", -1, 5, 27, 54, 12
    EDITTEXT edt1, 60, 25, 190, 45, ES_WANTRETURN | ES_AUTOVSCROLL | ES_MULTILINE | WS_VSCROLL
    AUTOCHECKBOX "다음으로 ""\\r\\n"" 바꾸기(&R) ""\\n""", chx1, 60, 75, 190, 14
    DEFPUSHBUTTON "확인", IDOK, 125, 95, 60, 14
    PUSHBUTTON "취소", IDCANCEL, 190, 95, 60, 14
}

IDD_MODIFYSTR DIALOG 0, 0, 255, 115
CAPTION "문자열 항목 수정"
STYLE WS_POPUPWINDOW | WS_CAPTION | WS_THICKFRAME
FONT 9, "Gulim"
{
    LTEXT "문자열 ID(&I):", -1, 5, 7, 50, 12
    COMBOBOX cmb1, 60, 5, 134, 200, CBS_HASSTRINGS | CBS_AUTOHSCROLL | CBS_DROPDOWN | WS_BORDER | WS_VSCROLL | WS_TABSTOP
    PUSHBUTTON "&...", psh1, 195, 5, 15, 14
    LTEXT "문자열 값(&V):", -1, 5, 27, 54, 12
    EDITTEXT edt1, 60, 25, 190, 45, ES_WANTRETURN | ES_AUTOVSCROLL | ES_MULTILINE | WS_VSCROLL
    AUTOCHECKBOX "다음으로 ""\\r\\n"" 바꾸기(&R) ""\\n""", chx1, 60, 75, 190, 14
    DEFPUSHBUTTON "확인", IDOK, 125, 95, 60, 14
    PUSHBUTTON "취소", IDCANCEL, 190, 95, 60, 14
}

IDD_STRINGS DIALOG 0, 0, 325, 160
CAPTION "문자열 테이블"
STYLE WS_POPUPWINDOW | WS_CAPTION | WS_THICKFRAME
FONT 9, "Gulim"
{
    LTEXT "문자열 항목(&E):", -1, 5, 7, 100, 12
    CONTROL "", lst1, "SysListView32", LVS_NOSORTHEADER | LVS_AUTOARRANGE | LVS_NOLABELWRAP | LVS_SHOWSELALWAYS | LVS_SINGLESEL | LVS_REPORT | WS_BORDER | WS_VSCROLL | WS_HSCROLL | WS_TABSTOP, 5, 20, 315, 115
    PUSHBUTTON "추가(&A)...", psh1, 130, 3, 60, 14
    PUSHBUTTON "수정(&M)...", psh2, 195, 3, 60, 14
    PUSHBUTTON "삭제(&D)", psh3, 260, 3, 60, 14
    DEFPUSHBUTTON "확인", IDOK, 195, 140, 60, 14
    PUSHBUTTON "취소", IDCANCEL, 260, 140, 60, 14
    PUSHBUTTON "모두 삭제(&L)...", psh4, 5, 140, 75, 14
}

IDD_ADDMITEM DIALOG 0, 0, 210, 200
CAPTION "메뉴 항목 추가"
STYLE DS_MODALFRAME | WS_POPUPWINDOW | WS_CAPTION
FONT 9, "Gulim"
{
    LTEXT "표제(&A):", -1, 5, 7, 55, 12
    COMBOBOX cmb1, 65, 6, 140, 200, CBS_AUTOHSCROLL | CBS_DROPDOWN | WS_BORDER | WS_VSCROLL | WS_TABSTOP
    LTEXT "명령 ID(&M):", -1, 5, 32, 55, 12
    COMBOBOX cmb2, 65, 30, 125, 200, CBS_AUTOHSCROLL | CBS_DROPDOWN | WS_BORDER | WS_VSCROLL | WS_TABSTOP
    PUSHBUTTON "&...", psh1, 190, 30, 15, 14
    AUTOCHECKBOX "회색(&G)", chx1, 5, 60, 60, 14
    AUTOCHECKBOX "비트맵(&B)", chx3, 135, 60, 60, 14
    AUTOCHECKBOX "소유자표시(&O)", chx4, 5, 80, 65, 14
    AUTOCHECKBOX "체크(&C)", chx5, 75, 80, 60, 14
    AUTOCHECKBOX "구분기호(&P)", chx6, 140, 80, 60, 14
    AUTOCHECKBOX "메뉴줄분리(&B)", chx7, 5, 100, 75, 14
    AUTOCHECKBOX "메뉴분리(&R)", chx8, 85, 100, 70, 14
    AUTOCHECKBOX "기본값(&D)", chx9, 5, 120, 60, 14
    AUTOCHECKBOX "강조(&H)", chx10, 70, 120, 60, 14
    AUTOCHECKBOX "라디오체크(&K)", chx11, 135, 120, 60, 14
    AUTOCHECKBOX "오른쪽순서(&T)", chx12, 5, 139, 60, 14
    AUTOCHECKBOX "오른쪽정렬(&J)", chx13, 70, 140, 70, 14
    LTEXT "도움말 ID(&L):", -1, 5, 162, 45, 12
    COMBOBOX cmb3, 55, 160, 100, 300, CBS_AUTOHSCROLL | CBS_DROPDOWN | WS_BORDER | WS_VSCROLL | WS_TABSTOP
    DEFPUSHBUTTON "확인", IDOK, 80, 180, 60, 14
    PUSHBUTTON "취소", IDCANCEL, 145, 180, 60, 14
}

IDD_MODIFYMITEM DIALOG 0, 0, 210, 200
CAPTION "메뉴 항목 수정"
STYLE DS_MODALFRAME | WS_POPUPWINDOW | WS_CAPTION
FONT 9, "Gulim"
{
    LTEXT "표제(&A):", -1, 5, 7, 55, 12
    COMBOBOX cmb1, 65, 6, 140, 200, CBS_AUTOHSCROLL | CBS_DROPDOWN | WS_BORDER | WS_VSCROLL | WS_TABSTOP
    LTEXT "명령 ID(&M):", -1, 5, 32, 55, 12
    COMBOBOX cmb2, 65, 30, 125, 200, CBS_AUTOHSCROLL | CBS_DROPDOWN | WS_BORDER | WS_VSCROLL | WS_TABSTOP
    PUSHBUTTON "&...", psh1, 190, 30, 15, 14
    AUTOCHECKBOX "회색(&G)", chx1, 5, 60, 60, 14
    AUTOCHECKBOX "비트맵(&B)", chx3, 135, 60, 60, 14
    AUTOCHECKBOX "소유자표시(&O)", chx4, 5, 80, 65, 14
    AUTOCHECKBOX "체크(&C)", chx5, 75, 80, 60, 14
    AUTOCHECKBOX "구분기호(&P)", chx6, 140, 80, 60, 14
    AUTOCHECKBOX "메뉴줄분리(&B)", chx7, 5, 100, 75, 14
    AUTOCHECKBOX "메뉴분리(&R)", chx8, 85, 100, 70, 14
    AUTOCHECKBOX "기본값(&D)", chx9, 5, 120, 60, 14
    AUTOCHECKBOX "강조(&H)", chx10, 70, 120, 60, 14
    AUTOCHECKBOX "라디오체크(&K)", chx11, 135, 120, 60, 14
    AUTOCHECKBOX "오른쪽순서(&T)", chx12, 5, 139, 60, 14
    AUTOCHECKBOX "오른쪽정렬(&J)", chx13, 70, 140, 70, 14
    LTEXT "도움말 ID(&l):", -1, 5, 162, 45, 12
    COMBOBOX cmb3, 55, 160, 100, 300, CBS_AUTOHSCROLL | CBS_DROPDOWN | WS_BORDER | WS_VSCROLL | WS_TABSTOP
    DEFPUSHBUTTON "확인", IDOK, 80, 180, 60, 14
    PUSHBUTTON "취소", IDCANCEL, 145, 180, 60, 14
}

IDD_EDITMENU DIALOG 0, 0, 325, 160
CAPTION "메뉴 리소스 편집"
STYLE WS_POPUPWINDOW | WS_CAPTION | WS_THICKFRAME
FONT 9, "Gulim"
{
    LTEXT "메뉴 리소스(&S):", -1, 5, 7, 85, 12
    CONTROL "", lst1, "SysListView32", LVS_NOSORTHEADER | LVS_AUTOARRANGE | LVS_NOLABELWRAP | LVS_SHOWSELALWAYS | LVS_SINGLESEL | LVS_REPORT | WS_BORDER | WS_VSCROLL | WS_HSCROLL | WS_TABSTOP, 5, 20, 315, 115
    PUSHBUTTON "추가(&A)...", psh1, 95, 3, 50, 14
    PUSHBUTTON "수정(&M)...", psh2, 150, 3, 50, 14
    PUSHBUTTON "삭제(&T)", psh3, 205, 3, 50, 14
    PUSHBUTTON "위로(&U)", psh4, 5, 140, 40, 14
    PUSHBUTTON "아래로(&D)", psh5, 50, 140, 40, 14
    PUSHBUTTON "왼쪽(&L)", psh6, 95, 140, 40, 14
    PUSHBUTTON "오른쪽(&R)", psh7, 140, 140, 41, 14
    AUTOCHECKBOX "확장(&X)", chx1, 260, 3, 60, 14
    DEFPUSHBUTTON "확인", IDOK, 195, 140, 60, 14
    PUSHBUTTON "취소", IDCANCEL, 260, 140, 60, 14
}

IDD_DLGPROP DIALOG 0, 0, 235, 315
CAPTION "대화상자 속성"
STYLE DS_MODALFRAME | WS_POPUPWINDOW | WS_CAPTION
FONT 9, "Gulim"
{
    LTEXT "표제(&A):", -1, 5, 7, 85, 11
    COMBOBOX cmb1, 5, 20, 225, 300, CBS_HASSTRINGS | CBS_AUTOHSCROLL | CBS_DROPDOWN | WS_BORDER | WS_VSCROLL | WS_TABSTOP
    AUTOCHECKBOX "확장된 대화상자(&X)", chx1, 100, 5, 86, 14
    LTEXT "왼쪽(&L):", -1, 5, 40, 33, 10
    EDITTEXT edt1, 5, 53, 30, 14, ES_NUMBER | ES_RIGHT
    CONTROL "", scr1, "msctls_updown32", UDS_NOTHOUSANDS | UDS_ARROWKEYS | UDS_AUTOBUDDY | UDS_ALIGNRIGHT | UDS_SETBUDDYINT, 23, 53, 12, 20
    LTEXT "위쪽(&O):", -1, 50, 40, 33, 10
    EDITTEXT edt2, 50, 53, 30, 14, ES_NUMBER | ES_RIGHT
    CONTROL "", scr2, "msctls_updown32", UDS_NOTHOUSANDS | UDS_ARROWKEYS | UDS_AUTOBUDDY | UDS_ALIGNRIGHT | UDS_SETBUDDYINT, 53, 53, 12, 20
    LTEXT "너비(&W):", -1, 95, 40, 33, 10
    EDITTEXT edt3, 95, 53, 30, 14, ES_NUMBER | ES_RIGHT
    CONTROL "", scr3, "msctls_updown32", UDS_NOTHOUSANDS | UDS_ARROWKEYS | UDS_AUTOBUDDY | UDS_ALIGNRIGHT | UDS_SETBUDDYINT, 129, 56, 12, 20
    LTEXT "높이(&H):", -1, 142, 40, 33, 10
    EDITTEXT edt4, 142, 53, 30, 14, ES_NUMBER | ES_RIGHT
    CONTROL "", scr4, "msctls_updown32", UDS_NOTHOUSANDS | UDS_ARROWKEYS | UDS_AUTOBUDDY | UDS_ALIGNRIGHT | UDS_SETBUDDYINT, 162, 53, 12, 20
    LTEXT "클래스 이름(&S):", -1, 5, 73, 85, 11
    COMBOBOX cmb2, 5, 88, 115, 200, CBS_HASSTRINGS | CBS_AUTOHSCROLL | CBS_DROPDOWN | WS_BORDER | WS_VSCROLL | WS_TABSTOP
    LTEXT "도움말 ID(&P):", -1, 125, 73, 64, 12
    COMBOBOX cmb3, 125, 88, 65, 200, CBS_HASSTRINGS | CBS_AUTOHSCROLL | CBS_DROPDOWN | WS_BORDER | WS_VSCROLL | WS_TABSTOP
    LTEXT "글꼴 이름(&F):", -1, 5, 105, 80, 11
    COMBOBOX cmb4, 6, 118, 100, 200, CBS_HASSTRINGS | CBS_SORT | CBS_AUTOHSCROLL | CBS_DROPDOWN | WS_BORDER | WS_VSCROLL | WS_TABSTOP
    LTEXT "크기(&Z):", -1, 110, 105, 38, 12
    EDITTEXT edt5, 110, 118, 25, 14, ES_NUMBER
    AUTOCHECKBOX "&B", chx2, 140, 118, 20, 14
    AUTOCHECKBOX "&I", chx3, 165, 118, 20, 14
    LTEXT "문자셋(&R):", -1, 5, 138, 80, 11
    COMBOBOX cmb5, 5, 148, 100, 100, CBS_AUTOHSCROLL | CBS_DROPDOWNLIST | WS_VSCROLL | WS_TABSTOP
    LTEXT "메뉴 이름(&M):", -1, 110, 138, 55, 11
    COMBOBOX cmb6, 110, 148, 99, 300, CBS_HASSTRINGS | CBS_AUTOHSCROLL | CBS_DROPDOWN | WS_BORDER | WS_VSCROLL | WS_TABSTOP
    LTEXT "스타일(&T):", -1, 5, 168, 45, 11
    RTEXT "0x", -1, 52, 169, 10, 11
    EDITTEXT edt6, 67, 165, 45, 14, ES_AUTOHSCROLL
    LISTBOX lst1, 5, 183, 110, 110, LBS_DISABLENOSCROLL | LBS_NOINTEGRALHEIGHT | LBS_HASSTRINGS | LBS_MULTIPLESEL | WS_VSCROLL | WS_HSCROLL | WS_TABSTOP
    LTEXT "확장스타일(&E):", -1, 120, 168, 48, 11
    RTEXT "0x", -1, 170, 169, 10, 11
    EDITTEXT edt7, 185, 165, 45, 14, ES_AUTOHSCROLL
    LISTBOX lst2, 120, 183, 110, 110, LBS_DISABLENOSCROLL | LBS_NOINTEGRALHEIGHT | LBS_HASSTRINGS | LBS_MULTIPLESEL | WS_VSCROLL | WS_HSCROLL | WS_TABSTOP
    DEFPUSHBUTTON "확인", IDOK, 106, 298, 60, 14
    PUSHBUTTON "취소", IDCANCEL, 171, 298, 60, 14
}

IDD_CTRLPROP DIALOG 0, 0, 235, 330
CAPTION "제어 속성"
STYLE DS_MODALFRAME | WS_POPUPWINDOW | WS_CAPTION
FONT 9, "Gulim"
{
    LTEXT "정의된 제어(&C):", -1, 5, 7, 68, 12
    COMBOBOX cmb1, 75, 5, 120, 55, CBS_HASSTRINGS | CBS_AUTOHSCROLL | CBS_DROPDOWN | WS_BORDER | WS_VSCROLL | WS_TABSTOP
    CONTROL "", ctl1, "ToolbarWindow32", TBSTYLE_FLAT | TBSTYLE_WRAPABLE | TBSTYLE_TOOLTIPS | CCS_NODIVIDER | CCS_NORESIZE, 5, 22, 185, 30
    LTEXT "표제(&A):", -1, 5, 55, 75, 12
    COMBOBOX cmb2, 5, 65, 195, 300, CBS_HASSTRINGS | CBS_AUTOHSCROLL | CBS_DROPDOWN | WS_BORDER | WS_VSCROLL | WS_TABSTOP
    PUSHBUTTON "&OLE...", psh2, 205, 65, 25, 14
    LTEXT "왼쪽(&L):", -1, 5, 85, 33, 11
    EDITTEXT edt1, 5, 99, 25, 14, ES_NUMBER | ES_RIGHT
    CONTROL "", scr1, "msctls_updown32", UDS_NOTHOUSANDS | UDS_ARROWKEYS | UDS_AUTOBUDDY | UDS_ALIGNRIGHT | UDS_SETBUDDYINT, 20, 99, 12, 20
    LTEXT "상단(&O):", -1, 40, 85, 33, 11
    EDITTEXT edt2, 40, 99, 25, 14, ES_NUMBER | ES_RIGHT
    CONTROL "", scr2, "msctls_updown32", UDS_NOTHOUSANDS | UDS_ARROWKEYS | UDS_AUTOBUDDY | UDS_ALIGNRIGHT | UDS_SETBUDDYINT, 55, 99, 12, 20
    LTEXT "너비(&W):", -1, 75, 85, 33, 11
    EDITTEXT edt3, 75, 99, 25, 14, ES_NUMBER | ES_RIGHT
    CONTROL "", scr3, "msctls_updown32", UDS_NOTHOUSANDS | UDS_ARROWKEYS | UDS_AUTOBUDDY | UDS_ALIGNRIGHT | UDS_SETBUDDYINT, 90, 99, 12, 20
    LTEXT "높이(&H):", -1, 111, 85, 33, 11
    EDITTEXT edt4, 110, 99, 25, 14, ES_NUMBER | ES_RIGHT
    CONTROL "", scr4, "msctls_updown32", UDS_NOTHOUSANDS | UDS_ARROWKEYS | UDS_AUTOBUDDY | UDS_ALIGNRIGHT | UDS_SETBUDDYINT, 125, 99, 12, 20
    LTEXT "&ID:", -1, 150, 85, 70, 12
    COMBOBOX cmb3, 150, 99, 80, 300, CBS_HASSTRINGS | CBS_AUTOHSCROLL | CBS_DROPDOWN | WS_BORDER | WS_VSCROLL | WS_TABSTOP
    LTEXT "창 클래스 이름(&S):", -1, 5, 119, 100, 12
    COMBOBOX cmb4, 5, 133, 115, 200, CBS_HASSTRINGS | CBS_AUTOHSCROLL | CBS_DROPDOWN | WS_BORDER | WS_VSCROLL | WS_TABSTOP
    LTEXT "도움말 ID(&P):", -1, 125, 119, 70, 12
    COMBOBOX cmb5, 125, 133, 65, 200, CBS_HASSTRINGS | CBS_AUTOHSCROLL | CBS_DROPDOWN | WS_BORDER | WS_VSCROLL | WS_TABSTOP
    LTEXT "스타일(&T):", -1, 5, 153, 45, 12
    RTEXT "0x", -1, 54, 153, 10, 12
    EDITTEXT edt6, 70, 151, 45, 14, ES_AUTOHSCROLL
    LISTBOX lst1, 5, 167, 110, 120, LBS_DISABLENOSCROLL | LBS_NOINTEGRALHEIGHT | LBS_HASSTRINGS | LBS_MULTIPLESEL | WS_VSCROLL | WS_HSCROLL | WS_TABSTOP
    LTEXT "확장스타일(&E):", -1, 120, 153, 50, 12
    RTEXT "0x", -1, 172, 153, 10, 12
    EDITTEXT edt7, 185, 151, 45, 14, ES_AUTOHSCROLL
    LISTBOX lst2, 120, 167, 110, 120, LBS_DISABLENOSCROLL | LBS_NOINTEGRALHEIGHT | LBS_HASSTRINGS | LBS_MULTIPLESEL | WS_VSCROLL | WS_HSCROLL | WS_TABSTOP
    DEFPUSHBUTTON "확인", IDOK, 170, 293, 60, 14
    PUSHBUTTON "취소", IDCANCEL, 170, 309, 60, 14
    PUSHBUTTON "데이터(&D)...", psh1, 5, 293, 90, 14
    PUSHBUTTON "문자열 목록(&I)...", psh3, 5, 309, 90, 14
}

IDD_ADDCTRL DIALOG 0, 0, 235, 330
CAPTION "제어 추가"
STYLE DS_MODALFRAME | WS_POPUPWINDOW | WS_CAPTION
FONT 9, "Gulim"
{
    LTEXT "정의된 제어(&C):", -1, 5, 7, 68, 12
    COMBOBOX cmb1, 75, 5, 120, 55, CBS_HASSTRINGS | CBS_AUTOHSCROLL | CBS_DROPDOWN | WS_BORDER | WS_VSCROLL | WS_TABSTOP
    CONTROL "", ctl1, "ToolbarWindow32", TBSTYLE_FLAT | TBSTYLE_WRAPABLE | TBSTYLE_TOOLTIPS | CCS_NODIVIDER | CCS_NORESIZE, 5, 22, 185, 30
    LTEXT "표제(&A):", -1, 5, 55, 75, 12
    COMBOBOX cmb2, 5, 65, 195, 300, CBS_HASSTRINGS | CBS_AUTOHSCROLL | CBS_DROPDOWN | WS_BORDER | WS_VSCROLL | WS_TABSTOP
    PUSHBUTTON "&OLE...", psh2, 205, 65, 25, 14
    LTEXT "왼쪽(&L):", -1, 5, 85, 33, 11
    EDITTEXT edt1, 5, 99, 25, 14, ES_NUMBER | ES_RIGHT
    CONTROL "", scr1, "msctls_updown32", UDS_NOTHOUSANDS | UDS_ARROWKEYS | UDS_AUTOBUDDY | UDS_ALIGNRIGHT | UDS_SETBUDDYINT, 20, 99, 12, 20
    LTEXT "상단(&O):", -1, 40, 85, 33, 11
    EDITTEXT edt2, 40, 99, 25, 14, ES_NUMBER | ES_RIGHT
    CONTROL "", scr2, "msctls_updown32", UDS_NOTHOUSANDS | UDS_ARROWKEYS | UDS_AUTOBUDDY | UDS_ALIGNRIGHT | UDS_SETBUDDYINT, 55, 99, 12, 20
    LTEXT "너비(&W):", -1, 75, 85, 33, 11
    EDITTEXT edt3, 75, 99, 25, 14, ES_NUMBER | ES_RIGHT
    CONTROL "", scr3, "msctls_updown32", UDS_NOTHOUSANDS | UDS_ARROWKEYS | UDS_AUTOBUDDY | UDS_ALIGNRIGHT | UDS_SETBUDDYINT, 90, 99, 12, 20
    LTEXT "높이(&H):", -1, 111, 85, 33, 11
    EDITTEXT edt4, 110, 99, 25, 14, ES_NUMBER | ES_RIGHT
    CONTROL "", scr4, "msctls_updown32", UDS_NOTHOUSANDS | UDS_ARROWKEYS | UDS_AUTOBUDDY | UDS_ALIGNRIGHT | UDS_SETBUDDYINT, 125, 99, 12, 20
    LTEXT "&ID:", -1, 150, 85, 70, 12
    COMBOBOX cmb3, 150, 99, 80, 300, CBS_HASSTRINGS | CBS_AUTOHSCROLL | CBS_DROPDOWN | WS_BORDER | WS_VSCROLL | WS_TABSTOP
    LTEXT "창 클래스 이름(&S):", -1, 5, 119, 100, 12
    COMBOBOX cmb4, 5, 133, 115, 200, CBS_HASSTRINGS | CBS_AUTOHSCROLL | CBS_DROPDOWN | WS_BORDER | WS_VSCROLL | WS_TABSTOP
    LTEXT "도움말 ID(&P):", -1, 125, 119, 70, 12
    COMBOBOX cmb5, 125, 133, 65, 200, CBS_HASSTRINGS | CBS_AUTOHSCROLL | CBS_DROPDOWN | WS_BORDER | WS_VSCROLL | WS_TABSTOP
    LTEXT "스타일(&T):", -1, 5, 153, 45, 12
    RTEXT "0x", -1, 54, 153, 10, 12
    EDITTEXT edt6, 70, 151, 45, 14, ES_AUTOHSCROLL
    LISTBOX lst1, 5, 167, 110, 120, LBS_DISABLENOSCROLL | LBS_NOINTEGRALHEIGHT | LBS_HASSTRINGS | LBS_MULTIPLESEL | WS_VSCROLL | WS_HSCROLL | WS_TABSTOP
    LTEXT "확장스타일(&E):", -1, 120, 153, 50, 12
    RTEXT "0x", -1, 172, 153, 10, 12
    EDITTEXT edt7, 185, 151, 45, 14, ES_AUTOHSCROLL
    LISTBOX lst2, 120, 167, 110, 120, LBS_DISABLENOSCROLL | LBS_NOINTEGRALHEIGHT | LBS_HASSTRINGS | LBS_MULTIPLESEL | WS_VSCROLL | WS_HSCROLL | WS_TABSTOP
    DEFPUSHBUTTON "확인", IDOK, 170, 293, 60, 14
    PUSHBUTTON "취소", IDCANCEL, 170, 309, 60, 14
    PUSHBUTTON "데이터(&D)...", psh1, 5, 293, 90, 14
    PUSHBUTTON "문자열 목록(&I)...", psh3, 5, 309, 90, 14
}

IDD_IDASSOC DIALOG 0, 0, 200, 220
CAPTION "ID 연결"
STYLE DS_MODALFRAME | WS_POPUPWINDOW | WS_CAPTION
FONT 9, "Gulim"
{
    LTEXT "ID 연결(&A):", -1, 5, 5, 116, 12
    CONTROL "", lst1, "SysListView32", LVS_SHOWSELALWAYS | LVS_SINGLESEL | LVS_REPORT | WS_BORDER | WS_TABSTOP, 5, 20, 190, 150
    PUSHBUTTON "모두 선택(&R)", psh2, 5, 175, 85, 14
    PUSHBUTTON "수정(&M)", psh1, 135, 175, 60, 14
    DEFPUSHBUTTON "확인", IDOK, 70, 200, 60, 14
    PUSHBUTTON "취소", IDCANCEL, 135, 200, 60, 14
}

IDD_MODIFYASSOC DIALOG 0, 0, 165, 68
CAPTION "ID 액세스 키 수정"
STYLE DS_MODALFRAME | WS_POPUPWINDOW | WS_CAPTION
FONT 9, "Gulim"
{
    RTEXT "ID의 유형(&T):", -1, 5, 7, 65, 12
    EDITTEXT edt1, 80, 5, 80, 14, WS_DISABLED
    RTEXT "ID의 접두사(&P):", -1, 5, 32, 65, 12
    EDITTEXT edt2, 80, 28, 80, 14, ES_AUTOHSCROLL
    DEFPUSHBUTTON "확인", IDOK, 35, 50, 60, 14
    PUSHBUTTON "취소", IDCANCEL, 100, 50, 60, 14
}

IDD_IDLIST DIALOG 0, 0, 200, 300
CAPTION "리소스 ID 목록"
STYLE WS_OVERLAPPEDWINDOW
EXSTYLE WS_EX_TOOLWINDOW
FONT 9, "Gulim"
{
    COMBOBOX cmb1, 0, 0, 200, 300, CBS_HASSTRINGS | CBS_SORT | CBS_OWNERDRAWFIXED | CBS_DROPDOWNLIST | WS_VSCROLL | WS_TABSTOP
    CONTROL "", lst1, "SysListView32", LVS_REPORT | WS_BORDER | WS_VSCROLL | WS_HSCROLL | WS_TABSTOP, 0, 15, 200, 285
}

IDD_CONFIG DIALOG 0, 0, 210, 285
CAPTION "구성"
STYLE DS_MODALFRAME | WS_POPUPWINDOW | WS_CAPTION
FONT 9, "Gulim"
{
    AUTOCHECKBOX "제목 표시줄에 전체 파일 경로 표시(&F)", chx1, 5, 5, 200, 14
    AUTOCHECKBOX "ID 매크로를 사용하지 않음(&M)", chx2, 5, 25, 200, 14
    AUTOCHECKBOX "이전 창 위치로 다시 시작(&P)", chx3, 5, 45, 200, 14
    AUTOCHECKBOX "주변의 ""resource.h"" 자동 불러오기(&R)", chx4, 5, 65, 200, 14
    AUTOCHECKBOX "리소스 ID 목록을 자동으로 표시(&L)", chx5, 5, 85, 200, 14
    AUTOCHECKBOX "대화상자 편집에 점 표시(&D)", chx6, 5, 105, 200, 14
    RTEXT "콤보박스의 높이(&B):", -1, 10, 127, 75, 12
    EDITTEXT edt1, 90, 125, 34, 14, ES_NUMBER | ES_RIGHT
    CONTROL "", scr1, "msctls_updown32", UDS_NOTHOUSANDS | UDS_ARROWKEYS | UDS_AUTOBUDDY | UDS_ALIGNRIGHT | UDS_SETBUDDYINT, 129, 49, 12, 20
    AUTOCHECKBOX "줄바꿈(&W)", chx9, 135, 125, 70, 14
    AUTOCHECKBOX """resource.h""의 업데이트 묻기(&R)", chx7, 5, 145, 200, 14
    AUTOCHECKBOX "저장시 UPX로 EXE 압축(&U)", chx8, 5, 165, 200, 14
    PUSHBUTTON "글꼴(&F)...", psh4, 5, 185, 200, 14
    PUSHBUTTON "미리 정의된 매크로(&M)...", psh1, 5, 205, 93, 14
    PUSHBUTTON "경로 설정((&T)...", psh2, 107, 205, 98, 14
    RTEXT "OLE 제어의 이름(&O):", -1, 5, 227, 80, 12
    COMBOBOX cmb1, 90, 225, 75, 300, CBS_HASSTRINGS | CBS_AUTOHSCROLL | CBS_DROPDOWN | WS_VSCROLL | WS_TABSTOP
    AUTOCHECKBOX "백업 생성(&B)", chx10, 5, 245, 75, 15
    RTEXT "백업 접두사:", -1, 90, 245, 60, 15
    COMBOBOX cmb2, 158, 244, 45, 300, CBS_HASSTRINGS | CBS_AUTOHSCROLL | CBS_DROPDOWN | WS_VSCROLL | WS_TABSTOP
    DEFPUSHBUTTON "확인", IDOK, 100, 265, 50, 14
    PUSHBUTTON "취소", IDCANCEL, 155, 265, 50, 14
    PUSHBUTTON "모두 초기화(&S)", psh3, 5, 265, 75, 14
}

IDD_ADDRESID DIALOG 0, 0, 165, 90
CAPTION "리소스 ID 추가"
STYLE DS_MODALFRAME | WS_POPUPWINDOW | WS_CAPTION
FONT 9, "Gulim"
{
    RTEXT "ID의 유형(&T):", -1, 10, 7, 50, 14
    COMBOBOX cmb1, 65, 5, 95, 300, CBS_AUTOHSCROLL | CBS_DROPDOWNLIST | WS_VSCROLL | WS_TABSTOP
    RTEXT "ID의 이름(&N):", -1, 10, 27, 50, 14
    EDITTEXT edt1, 65, 25, 75, 14, ES_AUTOHSCROLL
    RTEXT "정수값(&I):", -1, 10, 47, 50, 14
    EDITTEXT edt2, 65, 45, 48, 14, ES_AUTOHSCROLL
    CONTROL "", scr1, "msctls_updown32", UDS_NOTHOUSANDS | UDS_ARROWKEYS | UDS_AUTOBUDDY | UDS_ALIGNRIGHT | UDS_SETBUDDYINT, 129, 49, 12, 20
    PUSHBUTTON "자동(&A)", psh1, 115, 45, 45, 14
    DEFPUSHBUTTON "확인", IDOK, 20, 70, 60, 14
    PUSHBUTTON "취소", IDCANCEL, 85, 70, 60, 14
}

IDD_MODIFYRESID DIALOG 0, 0, 165, 90
CAPTION "리소스 ID 수정"
STYLE DS_MODALFRAME | WS_POPUPWINDOW | WS_CAPTION
FONT 9, "Gulim"
{
    RTEXT "ID의 이름(&N):", -1, 10, 12, 50, 14, SS_REALSIZEIMAGE | NOT WS_GROUP
    EDITTEXT edt1, 65, 10, 95, 14, ES_AUTOHSCROLL
    RTEXT "ID의 유형(&T):", -1, 10, 32, 50, 14
    EDITTEXT edt2, 65, 30, 95, 14, ES_READONLY
    RTEXT "정수값(&I):", -1, 10, 52, 50, 14
    EDITTEXT edt3, 65, 50, 48, 14, ES_AUTOHSCROLL
    CONTROL "", scr1, "msctls_updown32", UDS_NOTHOUSANDS | UDS_ARROWKEYS | UDS_AUTOBUDDY | UDS_ALIGNRIGHT | UDS_SETBUDDYINT, 129, 49, 12, 20
    DEFPUSHBUTTON "확인", IDOK, 20, 70, 60, 14
    PUSHBUTTON "취소", IDCANCEL, 85, 70, 60, 14
}

IDD_ADVICERESH DIALOG 0, 0, 209, 184
CAPTION """resource.h""파일 수정 제안"
STYLE DS_MODALFRAME | WS_POPUPWINDOW | WS_CAPTION
FONT 9, "Gulim"
{
    LTEXT """resource.h""파일을 다음과 같이 수정:", -1, 10, 10, 195, 20
    EDITTEXT edt1, 10, 30, 190, 130, ES_READONLY | ES_MULTILINE
    DEFPUSHBUTTON "확인", IDOK, 140, 165, 60, 14
    PUSHBUTTON "수정 지우기(&C)", psh1, 10, 165, 90, 14
}

IDD_CLONEINNEWNAME DIALOG 0, 0, 215, 75
CAPTION "새 이름으로 복제"
STYLE DS_MODALFRAME | WS_POPUPWINDOW | WS_CAPTION
FONT 9, "Gulim"
{
    LTEXT "리소스 유형(&T):", -1, 5, 7, 70, 12
    COMBOBOX cmb1, 75, 5, 135, 200, CBS_HASSTRINGS | CBS_AUTOHSCROLL | CBS_DROPDOWN | WS_DISABLED | WS_BORDER | WS_VSCROLL | WS_TABSTOP
    LTEXT "리소스 이름(&L):", -1, 5, 32, 70, 12
    COMBOBOX cmb2, 75, 30, 120, 200, CBS_HASSTRINGS | CBS_AUTOHSCROLL | CBS_DROPDOWN | WS_BORDER | WS_VSCROLL | WS_TABSTOP
    PUSHBUTTON "&...", psh1, 195, 30, 15, 14
    DEFPUSHBUTTON "확인", IDOK, 35, 55, 60, 14
    PUSHBUTTON "취소", IDCANCEL, 115, 55, 60, 14
}

IDD_CLONEINNEWLANG DIALOG 0, 0, 215, 105
CAPTION "새 언어로 복제"
STYLE DS_MODALFRAME | WS_POPUPWINDOW | WS_CAPTION
FONT 9, "Gulim"
{
    LTEXT "리소스 유형(&T):", -1, 5, 7, 70, 12
    COMBOBOX cmb1, 75, 5, 135, 200, CBS_HASSTRINGS | CBS_AUTOHSCROLL | CBS_DROPDOWN | WS_DISABLED | WS_BORDER | WS_VSCROLL | WS_TABSTOP
    LTEXT "리소스 이름(&L):", -1, 5, 32, 70, 12
    COMBOBOX cmb2, 75, 30, 120, 200, CBS_HASSTRINGS | CBS_AUTOHSCROLL | CBS_DROPDOWN | WS_DISABLED | WS_BORDER | WS_VSCROLL | WS_TABSTOP
    LTEXT "리소스 언어(&L)", -1, 5, 57, 70, 12
    COMBOBOX cmb3, 75, 55, 135, 200, CBS_HASSTRINGS | CBS_AUTOHSCROLL | CBS_DROPDOWN | WS_BORDER | WS_VSCROLL | WS_TABSTOP
    DEFPUSHBUTTON "확인", IDOK, 35, 85, 60, 14
    PUSHBUTTON "취소", IDCANCEL, 115, 85, 60, 14
}

IDD_ITEMSEARCH DIALOG 0, 0, 171, 135
CAPTION "검색"
STYLE WS_POPUPWINDOW | WS_CAPTION
FONT 9, "Gulim"
{
    LTEXT "검색할 문자열(&S):", -1, 4, 10, 100, 14
    EDITTEXT edt1, 5, 25, 160, 15, ES_AUTOHSCROLL
    AUTOCHECKBOX "대소문자 구분(&C)", chx1, 5, 45, 120, 18
    GROUPBOX "방향", -1, 5, 65, 160, 42
    AUTORADIOBUTTON "위로(&U)", rad1, 15, 80, 60, 14, WS_TABSTOP
    AUTORADIOBUTTON "아래로(&D)", rad2, 90, 80, 60, 14, WS_TABSTOP
    DEFPUSHBUTTON "찾기(&F)", IDOK, 40, 115, 60, 14
    PUSHBUTTON "취소", IDCANCEL, 105, 115, 60, 14
}

IDD_VERSIONINFO DIALOG 0, 0, 174, 150
CAPTION "RisohEditor 정보"
STYLE DS_MODALFRAME | WS_POPUPWINDOW | WS_CAPTION
FONT 12, "Gulim"
{
    ICON IDI_MAIN, -1, 5, 5, 0, 0
    LTEXT "...", stc1, 30, 5, 140, 50
    CTEXT "https://katahiromz.web.fc2.com", stc2, 5, 60, 165, 12, SS_CENTERIMAGE | SS_NOTIFY | NOT WS_GROUP
    CONTROL "...", edt1, "EDIT", ES_READONLY | ES_AUTOHSCROLL | ES_AUTOVSCROLL | ES_MULTILINE | WS_BORDER | WS_VSCROLL | WS_HSCROLL, 5, 75, 165, 50
    DEFPUSHBUTTON "확인", IDOK, 55, 130, 60, 14
}

IDD_ADDMSG DIALOG 0, 0, 255, 105
CAPTION "메시지 항목 추가"
STYLE DS_MODALFRAME | WS_POPUPWINDOW | WS_CAPTION
FONT 9, "Gulim"
{
    LTEXT "메시지 ID(&I):", -1, 5, 7, 50, 12
    COMBOBOX cmb1, 65, 5, 134, 200, CBS_HASSTRINGS | CBS_AUTOHSCROLL | CBS_DROPDOWN | WS_BORDER | WS_VSCROLL | WS_TABSTOP
    PUSHBUTTON "&...", psh1, 200, 5, 15, 14
    LTEXT "메시지 값(&V):", -1, 5, 27, 80, 12
    EDITTEXT edt1, 5, 40, 245, 35, ES_WANTRETURN | ES_AUTOHSCROLL | ES_AUTOVSCROLL | ES_MULTILINE
    DEFPUSHBUTTON "확인", IDOK, 125, 85, 60, 14
    PUSHBUTTON "취소", IDCANCEL, 190, 85, 60, 14
}

IDD_MODIFYMSG DIALOG 0, 0, 255, 105
CAPTION "메시지 항목 수정"
STYLE DS_MODALFRAME | WS_POPUPWINDOW | WS_CAPTION
FONT 9, "Gulim"
{
    LTEXT "메시지 ID(&I):", -1, 5, 7, 50, 12
    COMBOBOX cmb1, 65, 5, 134, 200, CBS_HASSTRINGS | CBS_AUTOHSCROLL | CBS_DROPDOWN | WS_DISABLED | WS_BORDER | WS_VSCROLL | WS_TABSTOP
    LTEXT "메시지 값(&V):", -1, 5, 27, 80, 12
    EDITTEXT edt1, 5, 40, 245, 35, ES_WANTRETURN | ES_AUTOHSCROLL | ES_AUTOVSCROLL | ES_MULTILINE
    DEFPUSHBUTTON "확인", IDOK, 125, 85, 60, 14
    PUSHBUTTON "취소", IDCANCEL, 190, 85, 60, 14
}

IDD_MESSAGES DIALOG 0, 0, 325, 160
CAPTION "메시지 테이블"
STYLE WS_POPUPWINDOW | WS_CAPTION | WS_THICKFRAME
FONT 9, "Gulim"
{
    LTEXT "메시지 항목(&E):", -1, 5, 7, 80, 12
    CONTROL "", lst1, "SysListView32", LVS_NOSORTHEADER | LVS_AUTOARRANGE | LVS_NOLABELWRAP | LVS_SHOWSELALWAYS | LVS_SINGLESEL | LVS_REPORT | WS_BORDER | WS_VSCROLL | WS_HSCROLL | WS_TABSTOP, 5, 20, 315, 115
    PUSHBUTTON "추가(&A)...", psh1, 130, 3, 60, 14
    PUSHBUTTON "수정(&M)...", psh2, 195, 3, 60, 14
    PUSHBUTTON "삭제(&D)", psh3, 260, 3, 60, 14
    DEFPUSHBUTTON "확인", IDOK, 195, 140, 60, 14
    PUSHBUTTON "취소", IDCANCEL, 260, 140, 60, 14
    PUSHBUTTON "모두 삭제(&L)...", psh4, 5, 140, 75, 14
}

IDD_FONTS DIALOG 0, 0, 195, 110
CAPTION "글꼴 설정"
STYLE DS_MODALFRAME | WS_POPUPWINDOW | WS_CAPTION
FONT 9, "Gulim"
{
    RTEXT "소스(&S):", -1, 5, 5, 55, 15, SS_CENTERIMAGE | NOT WS_GROUP
    EDITTEXT edt1, 65, 5, 100, 14, ES_READONLY | ES_AUTOHSCROLL
    PUSHBUTTON "...", psh1, 170, 5, 19, 14
    RTEXT "바이너리(&B):", -1, 5, 25, 55, 15, SS_CENTERIMAGE | NOT WS_GROUP
    EDITTEXT edt2, 65, 25, 100, 14, ES_READONLY | ES_AUTOHSCROLL
    PUSHBUTTON "...", psh2, 170, 25, 19, 14
    GROUPBOX "미리보기", -1, 5, 45, 185, 39
    CTEXT "소스", stc1, 15, 55, 80, 25, SS_CENTERIMAGE | NOT WS_GROUP
    CTEXT "바이너리", stc2, 100, 55, 85, 25, SS_CENTERIMAGE | NOT WS_GROUP
    DEFPUSHBUTTON "확인", IDOK, 65, 90, 60, 14
    PUSHBUTTON "취소", IDCANCEL, 130, 90, 60, 14
}

IDD_MACROS DIALOG 0, 0, 265, 165
CAPTION "미리 정의된 매크로"
STYLE WS_POPUPWINDOW | WS_CAPTION | WS_THICKFRAME
FONT 9, "Gulim"
{
    LTEXT "미리 정의된 매크로(&M):", -1, 5, 0, 100, 15, SS_CENTERIMAGE | NOT WS_GROUP
    CONTROL "", lst1, "SysListView32", LVS_EDITLABELS | LVS_SHOWSELALWAYS | LVS_SINGLESEL | LVS_REPORT | WS_BORDER | WS_TABSTOP, 5, 15, 190, 125
    PUSHBUTTON "추가(&A)...", psh1, 200, 15, 60, 14
    PUSHBUTTON "편집(&E)...", psh2, 200, 35, 60, 14
    PUSHBUTTON "삭제(&D)", psh3, 200, 55, 60, 14
    PUSHBUTTON "모두 삭제(&L)...", psh7, 200, 105, 60, 14
    DEFPUSHBUTTON "확인", IDOK, 135, 145, 60, 14
    PUSHBUTTON "취소", IDCANCEL, 200, 145, 60, 14
    PUSHBUTTON "모두 초기화(&R)", psh6, 5, 145, 60, 14
}

IDD_ADDMACRO DIALOG 0, 0, 190, 80
CAPTION "미리 정의된 매크로 추가"
STYLE DS_MODALFRAME | WS_POPUPWINDOW | WS_CAPTION
FONT 9, "Gulim"
{
    RTEXT "키(&K):", -1, 5, 12, 60, 14
    COMBOBOX cmb1, 70, 10, 110, 200, CBS_DROPDOWN | WS_BORDER | WS_VSCROLL | WS_TABSTOP
    RTEXT "값(&V):", -1, 5, 37, 60, 14
    COMBOBOX cmb2, 70, 35, 110, 300, CBS_DROPDOWN | WS_BORDER | WS_VSCROLL | WS_TABSTOP
    DEFPUSHBUTTON "확인", IDOK, 60, 60, 60, 14
    PUSHBUTTON "취소", IDCANCEL, 125, 60, 60, 14
}

IDD_EDITMACRO DIALOG 0, 0, 190, 80
CAPTION "미리 정의된 매크로 편집"
STYLE DS_MODALFRAME | WS_POPUPWINDOW | WS_CAPTION
FONT 9, "Gulim"
{
    RTEXT "키(&K):", -1, 5, 12, 60, 14
    COMBOBOX cmb1, 70, 10, 110, 200, CBS_DROPDOWN | WS_DISABLED | WS_BORDER | WS_VSCROLL | WS_TABSTOP
    RTEXT "값(&V):", -1, 5, 37, 60, 14
    COMBOBOX cmb2, 70, 35, 110, 300, CBS_DROPDOWN | WS_BORDER | WS_VSCROLL | WS_TABSTOP
    DEFPUSHBUTTON "확인", IDOK, 60, 60, 60, 14
    PUSHBUTTON "취소", IDCANCEL, 125, 60, 60, 14
}

IDD_CTRLDATA DIALOG 0, 0, 190, 130
CAPTION "제어 데이터 편집"
STYLE DS_MODALFRAME | WS_POPUPWINDOW | WS_CAPTION
FONT 9, "Gulim"
{
    LTEXT "바이너리 데이터(&B):", -1, 5, 2, 87, 12
    EDITTEXT edt1, 5, 15, 180, 60, ES_AUTOVSCROLL | ES_MULTILINE | WS_VSCROLL
    LTEXT "제어 데이터는 공백으로 구분된 16비트 정수로 설정할 수 있습니다.", -1, 5, 80, 180, 25
    DEFPUSHBUTTON "확인", IDOK, 60, 110, 60, 14
    PUSHBUTTON "취소", IDCANCEL, 125, 110, 60, 14
}

IDD_PATHS DIALOG 0, 0, 295, 220
CAPTION "경로 설정"
STYLE WS_POPUPWINDOW | WS_CAPTION | WS_THICKFRAME
FONT 9, "Gulim"
{
    LTEXT "디렉터리 포함(&I):", -1, 5, 5, 102, 12
    LISTBOX lst1, 5, 20, 220, 105, LBS_NOINTEGRALHEIGHT | LBS_HASSTRINGS | LBS_SORT | WS_VSCROLL | WS_HSCROLL | WS_TABSTOP
    PUSHBUTTON "추가(&A)...", psh1, 230, 20, 60, 14
    PUSHBUTTON "편집(&E)...", psh2, 230, 40, 60, 14
    PUSHBUTTON "삭제(&D)", psh3, 230, 60, 60, 14
    PUSHBUTTON "위로(&U)", psh4, 230, 80, 60, 14
    PUSHBUTTON "아래로(&O)", psh5, 230, 100, 60, 14
    PUSHBUTTON "모두 삭제(&L)...", psh6, 5, 130, 95, 14
    RTEXT "&windres.exe:", stc1, 5, 157, 55, 12
    COMBOBOX cmb1, 70, 155, 155, 300, CBS_HASSTRINGS | CBS_AUTOHSCROLL | CBS_DROPDOWN | WS_VSCROLL | WS_TABSTOP
    PUSHBUTTON "찾아보기(&B)...", psh7, 230, 155, 60, 14
    RTEXT "&cpp.exe:", stc2, 5, 177, 55, 12
    COMBOBOX cmb2, 70, 175, 155, 300, CBS_HASSTRINGS | CBS_AUTOHSCROLL | CBS_DROPDOWN | WS_VSCROLL | WS_TABSTOP
    PUSHBUTTON "찾아보기(&R)...", psh8, 230, 175, 60, 14
    DEFPUSHBUTTON "확인", IDOK, 165, 200, 60, 14
    PUSHBUTTON "취소", IDCANCEL, 230, 200, 60, 14
    PUSHBUTTON "모두 초기화(&S)", psh9, 5, 200, 95, 14
}

IDD_EXP_OPTIONS DIALOG 0, 0, 250, 225
CAPTION "내보내기 옵션"
STYLE DS_MODALFRAME | WS_POPUPWINDOW | WS_CAPTION
FONT 9, "Gulim"
{
    ICON IDI_MAIN, -1, 5, 10, 0, 0
    LTEXT "RC 파일을 내보내면 일부 관련 파일이 생성됩니다. 다음 옵션을 선택할 수 있습니다:", -1, 35, 5, 210, 29
    AUTOCHECKBOX "Microsoft MESSAGETABLE 사용(&T)", chx8, 5, 40, 240, 14
    AUTOCHECKBOX "언어별로 리소스 파일 분리(&L)", chx1, 5, 60, 240, 14
    AUTOCHECKBOX "BEGIN/END 키워드 사용(&E)", chx2, 5, 80, 240, 14
    AUTOCHECKBOX "LANGUAGE_* 매크로로 언어 선택 가능", chx3, 5, 100, 240, 14
    AUTOCHECKBOX "백업 생성(&B)", chx4, 5, 120, 110, 14
    RTEXT "백업 접미사:", -1, 120, 122, 75, 12
    COMBOBOX cmb1, 200, 120, 45, 300, CBS_HASSTRINGS | CBS_AUTOHSCROLL | CBS_DROPDOWN | WS_VSCROLL | WS_TABSTOP
    AUTOCHECKBOX "중복 주석 출력(&C)", chx5, 5, 140, 240, 14
    AUTOCHECKBOX "#ifndef MSVC ... #endif로 매니페스트 문을 래핑(&N)", chx6, 5, 160, 240, 14
    AUTOCHECKBOX "RC 파일을 UTF-16으로 출력(&U)", chx7, 5, 180, 240, 14
    DEFPUSHBUTTON "확인", IDOK, 120, 205, 60, 14
    PUSHBUTTON "취소", IDCANCEL, 185, 205, 60, 14
}

IDD_LANGS DIALOG 0, 0, 250, 235
CAPTION "언어"
STYLE WS_POPUPWINDOW | WS_CAPTION | WS_THICKFRAME
FONT 9, "Gulim"
{
    CONTROL "", lst1, "SysListView32", LVS_SHOWSELALWAYS | LVS_SINGLESEL | LVS_REPORT | WS_BORDER | WS_TABSTOP, 5, 5, 240, 179
    RTEXT "검색(&S):", stc1, 5, 192, 45, 12
    COMBOBOX cmb1, 55, 190, 85, 300, CBS_SORT | CBS_DROPDOWN | WS_VSCROLL | WS_TABSTOP
    EDITTEXT edt1, 4, 209, 240, 20, ES_AUTOHSCROLL | ES_AUTOVSCROLL | ES_MULTILINE
}

IDD_CHILD DIALOG 0, 0, 215, 135
CAPTION "하위 대화상자"
STYLE WS_CHILD | WS_OVERLAPPEDWINDOW
FONT 9, "Gulim"
{
    DEFPUSHBUTTON "확인", IDOK, 35, 115, 60, 14
    PUSHBUTTON "취소", IDCANCEL, 115, 115, 60, 14
}

IDD_DLGINITEDIT DIALOG 0, 0, 325, 165
CAPTION "DLGINIT 편집"
STYLE WS_POPUPWINDOW | WS_CAPTION | WS_THICKFRAME
FONT 9, "Gulim"
{
    LTEXT "메시지 항목(&E):", -1, 5, 7, 100, 12
    CONTROL "", lst1, "SysListView32", LVS_NOSORTHEADER | LVS_AUTOARRANGE | LVS_NOLABELWRAP | LVS_SHOWSELALWAYS | LVS_SINGLESEL | LVS_REPORT | WS_BORDER | WS_VSCROLL | WS_HSCROLL | WS_TABSTOP, 5, 20, 250, 120
    PUSHBUTTON "추가(&A)...", psh1, 260, 20, 60, 14
    PUSHBUTTON "수정(&M)...", psh2, 260, 40, 60, 14
    PUSHBUTTON "삭제(&D)", psh3, 260, 60, 60, 14
    PUSHBUTTON "위로(&U)", psh4, 260, 100, 60, 14
    PUSHBUTTON "아래로(&O)", psh5, 260, 120, 60, 14
    DEFPUSHBUTTON "확인", IDOK, 195, 145, 60, 14
    PUSHBUTTON "취소", IDCANCEL, 260, 145, 60, 14
    PUSHBUTTON "모두 삭제(&L)...", psh6, 5, 145, 79, 14
}

IDD_ADDDLGINIT DIALOG 0, 0, 184, 137
CAPTION "DLGINIT 데이터 추가"
STYLE DS_MODALFRAME | WS_POPUPWINDOW | WS_CAPTION
FONT 9, "Gulim"
{
    LTEXT "제어 ID(&I):", -1, 5, 7, 56, 12
    COMBOBOX cmb1, 65, 5, 115, 300, CBS_HASSTRINGS | CBS_AUTOHSCROLL | CBS_DROPDOWN | WS_VSCROLL | WS_TABSTOP
    LTEXT "메시지(&M):", -1, 5, 32, 55, 12
    COMBOBOX cmb2, 65, 30, 95, 300, CBS_HASSTRINGS | CBS_AUTOHSCROLL | CBS_DROPDOWN | WS_VSCROLL | WS_TABSTOP
    LTEXT "문자열(&S):", -1, 5, 52, 55, 12
    EDITTEXT edt1, 5, 65, 175, 50, ES_WANTRETURN | ES_MULTILINE | WS_VSCROLL | WS_HSCROLL
    DEFPUSHBUTTON "확인", IDOK, 55, 120, 60, 14
    PUSHBUTTON "취소", IDCANCEL, 120, 120, 60, 14
}

IDD_MODIFYDLGINIT DIALOG 0, 0, 184, 137
CAPTION " DLGINIT 데이터 수정"
STYLE DS_MODALFRAME | WS_POPUPWINDOW | WS_CAPTION
FONT 9, "Gulim"
{
    LTEXT "제어 ID(&I):", -1, 5, 7, 56, 12
    COMBOBOX cmb1, 65, 5, 115, 300, CBS_HASSTRINGS | CBS_AUTOHSCROLL | CBS_DROPDOWN | WS_VSCROLL | WS_TABSTOP
    LTEXT "메시지(&M):", -1, 5, 32, 55, 12
    COMBOBOX cmb2, 65, 30, 95, 300, CBS_HASSTRINGS | CBS_AUTOHSCROLL | CBS_DROPDOWN | WS_VSCROLL | WS_TABSTOP
    LTEXT "문자열(&S):", -1, 5, 52, 55, 12
    EDITTEXT edt1, 5, 65, 175, 50, ES_WANTRETURN | ES_MULTILINE | WS_VSCROLL | WS_HSCROLL
    DEFPUSHBUTTON "확인", IDOK, 55, 120, 60, 14
    PUSHBUTTON "취소", IDCANCEL, 120, 120, 60, 14
}

IDD_STRINGLIST DIALOG 0, 0, 205, 220
CAPTION "제어 문자열 목록"
STYLE WS_POPUPWINDOW | WS_CAPTION | WS_THICKFRAME
FONT 9, "Gulim"
{
    LTEXT "", stc1, 5, 5, 195, 70
    EDITTEXT edt1, 5, 80, 195, 115, ES_WANTRETURN | ES_MULTILINE | WS_VSCROLL | WS_HSCROLL
    DEFPUSHBUTTON "확인", IDOK, 75, 200, 60, 14
    PUSHBUTTON "취소", IDCANCEL, 140, 200, 60, 14
}

IDD_SAVE_OPTIONS DIALOG 0, 0, 250, 225
CAPTION "저장 옵션"
STYLE DS_MODALFRAME | WS_POPUPWINDOW | WS_CAPTION
FONT 9, "Gulim"
{
    ICON IDI_MAIN, -1, 5, 10, 0, 0
    LTEXT "RC 파일을 저장하면 일부 관련 파일이 생성됩니다. 다음 옵션을 선택할 수 있습니다:", -1, 35, 5, 210, 29
    AUTOCHECKBOX "Microsoft MESSAGETABLE 사용(&T)", chx8, 5, 40, 240, 14
    AUTOCHECKBOX "언어별로 리소스 파일 분리(&L)", chx1, 5, 60, 240, 14
    AUTOCHECKBOX "BEGIN/END 키워드 사용(&E)", chx2, 5, 80, 240, 14
    AUTOCHECKBOX "LANGUAGE_* 매크로로 언어 선택 가능", chx3, 5, 100, 240, 14
    AUTOCHECKBOX "백업 생성(&B)", chx4, 5, 120, 110, 14
    RTEXT "백업 접미사:", -1, 120, 122, 75, 12
    COMBOBOX cmb1, 200, 120, 45, 300, CBS_HASSTRINGS | CBS_AUTOHSCROLL | CBS_DROPDOWN | WS_VSCROLL | WS_TABSTOP
    AUTOCHECKBOX "중복 주석 출력(&C)", chx5, 5, 140, 240, 14
    AUTOCHECKBOX "#ifndef MSVC ... #endif로 매니페스트 문을 래핑(&N)", chx6, 5, 160, 240, 14
    AUTOCHECKBOX "RC 파일을 UTF-16으로 출력(&U)", chx7, 5, 180, 240, 14
    DEFPUSHBUTTON "확인", IDOK, 120, 205, 60, 14
    PUSHBUTTON "취소", IDCANCEL, 185, 205, 60, 14
}

IDD_ENCODING DIALOG 0, 0, 200, 170
CAPTION "리소스 항목의 인코딩"
STYLE DS_MODALFRAME | WS_POPUPWINDOW | WS_CAPTION
FONT 9, "Gulim"
{
    CONTROL "", lst1, "SysListView32", LVS_SHOWSELALWAYS | LVS_SINGLESEL | LVS_REPORT | WS_BORDER, 5, 5, 190, 115
    PUSHBUTTON "추가(&A)...", psh1, 5, 125, 60, 14
    PUSHBUTTON "수정(&M)...", psh2, 70, 125, 60, 14
    PUSHBUTTON "삭제(&D)", psh3, 135, 125, 60, 14
    DEFPUSHBUTTON "확인", IDOK, 70, 150, 60, 14
    PUSHBUTTON "취소", IDCANCEL, 135, 150, 60, 14
    PUSHBUTTON "초기화(&R)", psh5, 5, 149, 60, 14
}

IDD_ADDENC DIALOG 0, 0, 215, 80
CAPTION "리소스 인코딩 추가"
STYLE DS_MODALFRAME | WS_POPUPWINDOW | WS_CAPTION
FONT 9, "Gulim"
{
    LTEXT "리소스 유형(&T):", -1, 5, 7, 70, 12
    COMBOBOX cmb1, 75, 5, 135, 200, CBS_HASSTRINGS | CBS_AUTOHSCROLL | CBS_DROPDOWN | WS_BORDER | WS_VSCROLL | WS_TABSTOP
    LTEXT "인코딩(&E):", -1, 5, 30, 70, 12
    COMBOBOX cmb2, 75, 30, 85, 300, CBS_HASSTRINGS | CBS_AUTOHSCROLL | CBS_DROPDOWNLIST | WS_VSCROLL | WS_TABSTOP
    DEFPUSHBUTTON "확인", IDOK, 86, 60, 60, 14
    PUSHBUTTON "취소", IDCANCEL, 150, 60, 60, 14
}

IDD_MODIFYENC DIALOG 0, 0, 215, 80
CAPTION "리소스 인코딩 수정"
STYLE DS_MODALFRAME | WS_POPUPWINDOW | WS_CAPTION
FONT 9, "Gulim"
{
    LTEXT "리소스 유형(&T):", -1, 5, 7, 70, 12
    COMBOBOX cmb1, 75, 5, 135, 200, CBS_HASSTRINGS | CBS_AUTOHSCROLL | CBS_DROPDOWN | WS_DISABLED | WS_BORDER | WS_VSCROLL | WS_TABSTOP
    LTEXT "인코딩(&E):", -1, 5, 30, 70, 12
    COMBOBOX cmb2, 75, 30, 85, 300, CBS_HASSTRINGS | CBS_AUTOHSCROLL | CBS_DROPDOWNLIST | WS_VSCROLL | WS_TABSTOP
    DEFPUSHBUTTON "확인", IDOK, 86, 60, 60, 14
    PUSHBUTTON "취소", IDCANCEL, 150, 60, 60, 14
}

IDD_CONSTANT DIALOG 0, 0, 205, 75
CAPTION "쿼리 상수"
STYLE DS_MODALFRAME | WS_POPUPWINDOW | WS_CAPTION
FONT 9, "Gulim"
{
    LTEXT "상수 이름(&N):", -1, 5, 7, 80, 12
    COMBOBOX cmb1, 94, 7, 105, 300, CBS_HASSTRINGS | CBS_AUTOHSCROLL | CBS_DROPDOWN | WS_VSCROLL | WS_TABSTOP
    LTEXT "상수 값(&V):", -1, 5, 32, 80, 12
    EDITTEXT edt2, 95, 30, 50, 14, ES_READONLY
    EDITTEXT edt3, 150, 30, 50, 14, ES_READONLY
    DEFPUSHBUTTON "확인", IDOK, 70, 55, 60, 14
}

IDD_EGA DIALOG 0, 0, 400, 225
CAPTION "프로그래밍 언어 EGA"
STYLE WS_POPUPWINDOW | WS_CAPTION | WS_THICKFRAME
FONT 9, "Gulim"
{
    GROUPBOX "EGA 콘솔", grp1, 5, 5, 390, 195
    EDITTEXT edt1, 10, 20, 380, 170, ES_READONLY | ES_AUTOVSCROLL | ES_MULTILINE | WS_VSCROLL | NOT WS_TABSTOP
    RTEXT "EGA>", stc1, 10, 208, 20, 10
    EDITTEXT edt2, 35, 205, 300, 15, ES_WANTRETURN | ES_AUTOHSCROLL | ES_AUTOVSCROLL | ES_MULTILINE
    PUSHBUTTON "엔터(&E)", IDOK, 345, 205, 50, 15
}

IDD_FONTSUBST DIALOG 0, 0, 185, 180
CAPTION "대화상자 글꼴 대체"
STYLE DS_CENTER | DS_MODALFRAME | WS_POPUPWINDOW | WS_CAPTION
FONT 9, "Gulim"
{
    LTEXT "글꼴 #&1:", -1, 5, 7, 44, 12
    COMBOBOX cmb1, 55, 5, 125, 300, CBS_HASSTRINGS | CBS_AUTOHSCROLL | CBS_DROPDOWN | WS_VSCROLL | WS_TABSTOP
    ICON IDI_ARROW, -1, 30, 25, 0, 0
    COMBOBOX cmb2, 55, 30, 125, 300, CBS_HASSTRINGS | CBS_AUTOHSCROLL | CBS_DROPDOWN | WS_VSCROLL | WS_TABSTOP
    LTEXT "글꼴 #&2:", -1, 5, 57, 44, 12
    COMBOBOX cmb3, 55, 55, 125, 300, CBS_HASSTRINGS | CBS_AUTOHSCROLL | CBS_DROPDOWN | WS_VSCROLL | WS_TABSTOP
    ICON IDI_ARROW, -1, 30, 75, 0, 0
    COMBOBOX cmb4, 55, 80, 125, 300, CBS_HASSTRINGS | CBS_AUTOHSCROLL | CBS_DROPDOWN | WS_VSCROLL | WS_TABSTOP
    LTEXT "글꼴 #&3:", -1, 5, 105, 44, 12
    COMBOBOX cmb5, 55, 105, 125, 300, CBS_HASSTRINGS | CBS_AUTOHSCROLL | CBS_DROPDOWN | WS_VSCROLL | WS_TABSTOP
    ICON IDI_ARROW, -1, 30, 125, 0, 0
    COMBOBOX cmb6, 55, 130, 125, 300, CBS_HASSTRINGS | CBS_AUTOHSCROLL | CBS_DROPDOWN | WS_VSCROLL | WS_TABSTOP
    DEFPUSHBUTTON "확인", IDOK, 75, 160, 50, 14
    PUSHBUTTON "취소", IDCANCEL, 130, 160, 50, 14
    PUSHBUTTON "초기화(&R)", psh1, 5, 160, 55, 14
}

IDD_DROPDOWNPOPUP DIALOG 0, 0, 120, 150
CAPTION " "
STYLE WS_POPUP | WS_DLGFRAME | NOT WS_BORDER
FONT 9, "Gulim"
{
    LISTBOX lst1, 0, 0, 120, 150, LBS_WANTKEYBOARDINPUT | LBS_NOINTEGRALHEIGHT | LBS_HASSTRINGS | WS_VSCROLL | WS_TABSTOP, WS_EX_CLIENTEDGE
}

IDD_DFMSETTINGS DIALOG 0, 0, 210, 135
CAPTION "Delphi DFM 설정"
STYLE DS_CENTER | DS_MODALFRAME | WS_POPUPWINDOW | WS_CAPTION
FONT 9, "Gulim"
{
    LTEXT "다음 설정은 Delphi DFM과 관련이 있습니다:", -1, 35, 5, 171, 20
    ICON IDI_DFMICON, -1, 5, 5, 0, 0
    RTEXT "코드페이지(&C):", -1, 6, 32, 70, 12
    COMBOBOX cmb1, 85, 30, 120, 300, CBS_HASSTRINGS | CBS_AUTOHSCROLL | CBS_DROPDOWN | WS_VSCROLL | WS_TABSTOP
    AUTOCHECKBOX "원시 문자열 주석 삽입(&I)", chx1, 5, 50, 200, 14
    AUTOCHECKBOX "유니코드와 UTF-8을 사용하지 않음(&U)", chx2, 5, 70, 200, 14
    DEFPUSHBUTTON "확인", IDOK, 80, 115, 60, 14
    PUSHBUTTON "취소", IDCANCEL, 145, 115, 60, 14
}

IDD_COPYTOMULTILANG DIALOG 0, 0, 200, 195
CAPTION "다국어로 복사"
STYLE DS_CENTER | DS_MODALFRAME | WS_POPUPWINDOW | WS_CAPTION
FONT 9, "Gulim"
{
    LTEXT "리소스를 복사할 언어를 추가하세요:", -1, 5, 5, 190, 22
    LTEXT "언어(&L):", -1, 5, 35, 82, 12
    LISTBOX lst1, 5, 50, 190, 100, LBS_WANTKEYBOARDINPUT | LBS_NOINTEGRALHEIGHT | LBS_HASSTRINGS | WS_VSCROLL | WS_TABSTOP
    COMBOBOX cmb3, 5, 155, 126, 14, CBS_HASSTRINGS | CBS_AUTOHSCROLL | CBS_DROPDOWN | WS_BORDER | WS_VSCROLL | WS_TABSTOP
    PUSHBUTTON "추가(&A)", psh1, 135, 155, 60, 14
    DEFPUSHBUTTON "확인", IDOK, 5, 175, 60, 14
    PUSHBUTTON "취소", IDCANCEL, 70, 175, 60, 14
}

IDD_TOOLBARRES DIALOG 0, 0, 230, 195
CAPTION "도구모음 리소스"
STYLE DS_CENTER | DS_MODALFRAME | WS_POPUPWINDOW | WS_CAPTION
FONT 9, "Gulim"
{
    RTEXT "아이콘 너비(&W):", -1, 5, 5, 60, 15, SS_CENTERIMAGE | NOT WS_GROUP
    EDITTEXT edt1, 70, 5, 30, 15, ES_NUMBER | ES_RIGHT
    CONTROL "", scr1, "msctls_updown32", UDS_NOTHOUSANDS | UDS_ARROWKEYS | UDS_AUTOBUDDY | UDS_ALIGNRIGHT | UDS_SETBUDDYINT, 80, 5, 30, 15
    RTEXT "아이콘 높이(&H):", -1, 110, 5, 60, 15, SS_CENTERIMAGE | NOT WS_GROUP
    EDITTEXT edt2, 180, 5, 30, 15, ES_NUMBER | ES_RIGHT
    CONTROL "", scr2, "msctls_updown32", UDS_NOTHOUSANDS | UDS_ARROWKEYS | UDS_AUTOBUDDY | UDS_ALIGNRIGHT | UDS_SETBUDDYINT, 190, 5, 30, 15
    LTEXT "도구모음 버튼(&T):", -1, 5, 25, 140, 15, SS_CENTERIMAGE | NOT WS_GROUP
    LISTBOX lst1, 5, 40, 140, 130, LBS_DISABLENOSCROLL | LBS_WANTKEYBOARDINPUT | LBS_NOINTEGRALHEIGHT | LBS_HASSTRINGS | LBS_OWNERDRAWFIXED | WS_VSCROLL | WS_TABSTOP
    PUSHBUTTON "추가(&A)...", psh1, 150, 40, 75, 15
    PUSHBUTTON "수정(&M)...", psh2, 150, 60, 75, 15
    PUSHBUTTON "삭제(&D)", psh3, 150, 80, 75, 15
    PUSHBUTTON "위로(&U)", psh4, 150, 135, 75, 15
    PUSHBUTTON "아래로(&O)", psh5, 150, 155, 75, 15
    DEFPUSHBUTTON "확인", IDOK, 5, 175, 60, 15
    PUSHBUTTON "취소", IDCANCEL, 70, 175, 60, 15
}

IDD_ADDTBBTN DIALOG 0, 0, 177, 92
CAPTION "도구모음 버튼 추가"
STYLE DS_CENTER | DS_MODALFRAME | WS_POPUPWINDOW | WS_CAPTION
FONT 9, "Gulim"
{
    LTEXT "도구모음 버튼의 명령 ID:(&I)", -1, 5, 5, 160, 15, SS_CENTERIMAGE | NOT WS_GROUP
    COMBOBOX cmb1, 5, 25, 150, 150, CBS_HASSTRINGS | CBS_AUTOHSCROLL | CBS_DROPDOWN | WS_VSCROLL | WS_TABSTOP
    AUTOCHECKBOX "분리 기호(&S)", chx1, 5, 45, 90, 15
    DEFPUSHBUTTON "확인", IDOK, 45, 70, 60, 15
    PUSHBUTTON "취소", IDCANCEL, 110, 70, 60, 15
}

IDD_MODIFYTBBTN DIALOG 0, 0, 177, 92
CAPTION "도구모음 버튼 수정"
STYLE DS_CENTER | DS_MODALFRAME | WS_POPUPWINDOW | WS_CAPTION
FONT 9, "Gulim"
{
    LTEXT "도구모음 버튼의 명령 &ID:", -1, 5, 5, 160, 15, SS_CENTERIMAGE | NOT WS_GROUP
    COMBOBOX cmb1, 5, 25, 150, 150, CBS_HASSTRINGS | CBS_AUTOHSCROLL | CBS_DROPDOWN | WS_VSCROLL | WS_TABSTOP
    AUTOCHECKBOX "분리 기호(&S)", chx1, 5, 45, 90, 15
    DEFPUSHBUTTON "확인", IDOK, 45, 70, 60, 15
    PUSHBUTTON "취소", IDCANCEL, 110, 70, 60, 15
}

//////////////////////////////////////////////////////////////////////////////
// RT_VERSION

1 VERSIONINFO
FILEVERSION     5, 7, 9, 0
PRODUCTVERSION  5, 7, 9, 0
FILEOS          0x40004
FILETYPE        0x1
FILESUBTYPE     0x0
{
    BLOCK "StringFileInfo"
    {
        BLOCK "041203B5"
        {
            VALUE "CompanyName", "카타야마 히로후미 MZ\0"
            VALUE "FileDescription", "RisohEditor\0"
            VALUE "FileVersion", "5.7.9\0"
            VALUE "LegalCopyright", "저작권 (C) 2017-2020 카타야마 히로후미 MZ. 모든 권리 보유.\0"
            VALUE "ProductName", "RisohEditor\0"
            VALUE "ProductVersion", "5.7.9\0"
        }
    }
    BLOCK "VarFileInfo"
    {
        VALUE "Translation", 0x0412, 0x03B5
    }
}

//////////////////////////////////////////////////////////////////////////////
// RISOHTEMPLATE

4 RISOHTEMPLATE "res/1042_RISOHTEMPLATE_4.bin"

5 RISOHTEMPLATE "res/1042_RISOHTEMPLATE_5.bin"

//////////////////////////////////////////////////////////////////////////////
// RT_STRING

STRINGTABLE
{
    IDS_APPNAME, "RisohEditor 5.7.9 by Katayama Hirofumi MZ"
    IDS_TITLEWITHFILE, "RisohEditor 5.7.9 - 파일: %s"
    IDS_EXTRACTRES, "리소스 추출"
    IDS_RESBINFILTER, "바이너리 리소스 (*.res)|*.res|바이너리 파일 (*.bin)|*.bin|모든 파일 (*.*)|*.*|"
    IDS_CANNOTSAVE, "저장할 수 없습니다."
    IDS_REPLACERES, "리소스 바꾸기"
    IDS_ALLFILES, "모든 파일 (*.*)|*.*|"
    IDS_ENTERTYPE, "리소스 유형을 입력하십시오."
    IDS_ENTERNAME, "리소스 이름을 입력하십시오."
    IDS_ENTERLANG, "리소스 언어를 입력하십시오."
    IDS_FILENOTFOUND, "파일을 찾을 수 없습니다."
    IDS_CANNOTREPLACE, "교체할 수 없습니다."
    IDS_EXERESFILTER, "실행 파일 (*.exe;*.dll;*.ocx;*.cpl;*.scr;*.mui)|*.exe;*.dll;*.ocx;*.cpl;*.scr;*.mui|RC Files (*.rc)|*.rc|바이러리 리소스 (*.res)|*.res|모든 파일 (*.*)|*.*|"
    IDS_SAVEAS, "다른 이름으로 저장"
    IDS_CANNOTADDICON, "아이콘을 추가할 수 없습니다."
    IDS_ADDICON, "아이콘 추가"
    IDS_ICOFILTER, "아이콘 파일 (*.ico)|*.ico|모든 파일 (*.*)|*.*|"
    IDS_REPLACEICO, "아이콘 바꾸기"
    IDS_CANTREPLACEICO, "아이콘을 바꿀 수 없습니다."
    IDS_EXISTSOVERWRITE, "항목이 이미 있습니다. 덮어쓰시겠습니까?"
    IDS_OPEN, "열기"
    IDS_CANNOTOPEN, "파일을 열 수 없습니다."
    IDS_ADDBMP, "비트맵 추가"
    IDS_BMPFILTER, "비트맵 파일 (*.bmp)|*.bmp|PNG 이미지 (*.png)|*.png|모든 파일 (*.*)|*.*|"
    IDS_CANTREPLACEBMP, "비트맵을 바꿀 수 없습니다."
    IDS_REPLACEBMP, "비트맵 바꾸기"
    IDS_ERRORCODE, "오류 코드 %d"
    IDS_VERSIONINFO, "RisohEditor 버전 5.7.9\r\n\r\nKatayama Hirofumi MZ\r\n\r\n라이센스: GPLv3 (프리웨어)"
    IDS_ADDRES, "리소스 추가"
    IDS_CANNOTADDRES, "리소스를 추가할 수 없습니다."
    IDS_CANTADDBMP, "비트맵을 추가할 수 없습니다."
    IDS_EXTRACTBMP, "비트맵 추출"
    IDS_CANTEXTRACTBMP, "비트맵을 추출할 수 없습니다."
    IDS_CANTREPLACECUR, "커서를 바꿀 수 없습니다."
    IDS_CANNOTADDCUR, "커서를 추가할 수 없습니다."
    IDS_CURFILTER, "커서 파일 (*.cur)|*.cur|애니메이션 커서 (*.ani)|*.ani|모든 파일 (*.*)|*.*|"
    IDS_ADDCUR, "커서 추가"
    IDS_REPLACECUR, "커서 바꾸기"
    IDS_EXTRACTICO, "아이콘 추출"
    IDS_CANTEXTRACTICO, "아이콘을 추출할 수 없습니다."
    IDS_EXTRACTCUR, "커서 추출"
    IDS_CANTEXTRACTCUR, "커서를 추출할 수 없습니다."
    IDS_RESFILTER, "바이너리 리소스 (*.res)|*.res|모든 파일 (*.*)|*.*|"
    IDS_NEUTRAL, "중립"
    IDS_IMPORTRES, "가져오기"
    IDS_CANNOTIMPORT, "리소스를 가져올 수 없습니다."
    IDS_COMPILE, "컴파일 (F8)"
    IDS_CANCELEDIT, "편집 취소 (Ctrl+E)"
    IDS_GUIEDIT, "GUI로 편집 (Ctrl+G)"
    IDS_CANNOTSTARTUP, "리소스 컴파일러를 시작할 수 없습니다."
    IDS_RESMISMATCH, "리소스 유형이 일치하지 않습니다."
    IDS_SAMPLETEXT, "이것은 예제입니다."
    IDS_ALREADYEXISTS, "이미 존재합니다."
    IDS_KEY, "키"
    IDS_FLAGS, "플래그"
    IDS_COMMANDID, "명령 ID"
    IDS_INVALIDKEY, "잘못된 키입니다."
    IDS_COMPILEERROR, "컴파일하지 못했습니다."
    IDS_STRINGID, "문자열 ID"
    IDS_STRINGVALUE, "문자열 값"
    IDS_CAPTION, "캡션"
    IDS_HELPID, "도움말 ID"
    IDS_INDENT, "» "
    IDS_DATAISEMPTY, "데이터가 비어 있습니다."
    IDS_TEST, "테스트 수행"
    IDS_SEPARATOR, "---"
    IDS_COMPILENOW, "데이터가 변경되었습니다. 지금 컴파일하시겠습니까?"
    IDS_RADWINDOW, "대화상자 편집"
    IDS_ENTERCLASS, "유효한 창 클래스 이름을 입력하십시오."
    IDS_TEXTEDIT, "텍스트로 편집 (Ctrl+T)"
    IDS_CURSORINFO, "이미지 #%u: 너비 %u, 높이 %u, 비트수 %u, x핫스팟 %u, y핫스팟 %u, ID %u\r\n"
    IDS_IMAGECOUNT, "이미지수: %u\r\n"
    IDS_ICONINFO, "이미지 #%u: W너비 %u, 높이 %u, 비트수 %u, ID %u\r\n"
    IDS_READY, "준비"
    IDS_EXECUTINGCMD, "명령 실행 중..."
    IDS_EDITINGBYGUI, "GUI로 편집..."
    IDS_COORD, "%d, %d, %d, %d"
    IDS_STARTING, "시작하는 중..."
    IDS_COMPILING, "컴파일 중..."
    IDS_CANNOTLOAD, "불러올 수 없습니다."
    IDS_NONE, "(없음)"
    IDS_WAVESOUND, "(WAVE 사운드)\r\n"
    IDS_IDTYPE, "ID 유형"
    IDS_IDPREFIX, "ID 접두사"
    IDS_EMPTYSTR, "문자열을 입력하십시오."
    IDS_ANICURSOR, "(애니메이션 커서)\r\n"
    IDS_ANIICON, "(애니메이션 아이콘)\r\n"
    IDS_HEADFILTER, "머리말 파일 (*.h)|*.h|모든 파일 (*.*)|*.*|"
    IDS_LOADRESH, """resource.h"" 파일 불러오기"
    IDS_NAME, "이름"
    IDS_VALUE, "값"
    IDS_NOSUCHID, "해당 ID가 없습니다."
    IDS_IMAGEINFO, "너비 %u, 높이 %u, 비트픽셀 %u\r\n"
    IDS_ENTERINT, "유효한 정수를 입력하십시오."
    IDS_ENTERTEXT, "유효한 텍스트를 입력하십시오."
    IDS_ENTERID, "유효한 ID를 입력하십시오."
    IDS_ADDNEXTIDS, """resource.h""에 다음 ID를 추가하십시오:\r\n\r\n"
    IDS_DELETENEXTIDS, """resource.h""에서 다음 ID를 삭제하십시오:\r\n\r\n"
    IDS_NOCHANGE, "리소스 ID는 변경되지 않습니다."
    IDS_DLGFAIL, "죄송합니다. RAD 대화상자를 만들지 못했습니다."
    IDS_LOADWCLIB, "창 클래스 라이브러리 불러오기"
    IDS_AVIMOVIE, "(AVI 영화)\r\n"
    IDS_ADDDIALOG, "대화상자 추가"
    IDS_ADDMENU, "메뉴 추가"
    IDS_ADDVERINFO, "버전 정보 추가"
    IDS_ADDCURSOR, "커서 추가"
    IDS_NOMOREITEM, "더 이상 항목이 없습니다."
    IDS_INVALIDDATA, "(유효하지 않은 데이터)\r\n"
    IDS_UPDATERESH, """resource.h""를 업데이트 하시겠습니까?"
    IDS_CANTWRITERESH, """resource.h""를 쓸 수 없습니다."
    IDS_SAVERESH, """resource.h"" 파일 저장"
    IDS_DLLFILTER, "DLL 파일 (*.dll;*.ocx;*.mui)|*.dll;*.ocx;*.mui|모든 파일 (*.*)|*.*|"
    IDS_EXERESRCFILTER, "불러오기 가능한 파일 (*.exe;*.dll;*.ocx;*.cpl;*.scr;*.mui;*.res;*.rc)|*.exe;*.dll;*.ocx;*.cpl;*.scr;*.mui;*.res;*.rc|실행 파일 (*.exe;*.dll;*.ocx;*.cpl;*.scr;*.mui)|*.exe;*.dll;*.ocx;*.cpl;*.scr;*.mui|바이너리 리소스 (*.res)|*.res|리소스 파일 (*.rc)|*.rc|모든 파일 (*.*)|*.*|"
    IDS_CANTTESTCHILDWND, "하위 창이므로 대화상자를 테스트할 수 없습니다."
    IDS_CANTTESTCLASSDLG, "대화상자가 분류 되었기 때문에 테스트할 수 없습니다."
    IDS_FILEISUPXED, "'%s'\r\n\r\n파일\r\n\r\n이 UPX로 압축되었습니다. 임시 파일을 사용하여 추출하시겠습니까?\r\n\r\n확장하지 않으면 읽기가 실패할 수 있습니다."
    IDS_CANTUPXEXTRACT, "UPX로 추출할 수 없습니다."
    IDS_CANTSAVEUPXED, "파일이 UPX로 압축 되었기 때문에 저장할 수 없습니다."
    IDS_MESSAGEID, "메시지 ID"
    IDS_MESSAGEVALUE, "메시지 값"
    IDS_RCFILTER, "RC 파일 (*.rc)|*.rc|"
    IDS_EXPORT, "내보내기"
    IDS_CANTEXPORT, "내보내기에 실패했습니다."
    IDS_MUSTBEEMPTYDIR, "외부 파일이 있는 경우 내보내기 대상은 빈 폴더여야 합니다."
    IDS_FULLWIDTH, "０１２３４５６７８９ＡＢＣＤＥＦＧＨＩＪＫＬＭＮＯＰＱＲＳＴＵＶＷＸＹＺａｂｃｄｅｆｇｈｉｊｋｌｍｎｏｐｑｒｓｔｕｖｗｘｙｚ－＿（）．　"
    IDS_HALFWIDTH, "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz-_(). "
    IDS_MACRONAME, "매크로 이름"
    IDS_MACROVALUE, "매크로 값"
    IDS_OPTIONAL, "(옵션)"
    IDS_ADDINCLUDE, "포함 디렉터리 추가"
    IDS_EDITINCLUDE, "포함 디렉터리 편집"
    IDS_WINDRESEXE, "windres.exe|windres.exe|"
    IDS_CPPEXE, "cpp.exe|cpp.exe|"
    IDS_INVALIDPATH, "잘못된 경로입니다."
    IDS_DATATOOLONG, "데이터가 너무 깁니다."
    IDS_ALL, "(모두)"
    IDS_UNKNOWNFORMAT, "(알 수 없는 데이터 형식)\r\n"
    IDS_LANGUAGE, "언어"
    IDS_INTVALUE, "정수값"
    IDS_PARENTWND, "부모 테스트 창"
    IDS_CHOOSE_OLE_CLSID, "OLE CLSID 선택"
    IDS_CONTROL, "제어"
    IDS_MESSAGE, "메시지"
    IDS_STRING, "문자열"
    IDS_DATAISINVALID, "데이터가 유효하지 않습니다."
    IDS_DLGINIT1, "대화 리소스와 동일한 이름의 RT_DLGINIT 리소스 데이터에 초기화 데이터를 설정하여 콤보 상자 및 목록 상자의 초기화를 지정할 수 있습니다. "
    IDS_DLGINIT2, "WM_INITDIALOG 메시지가 도착하면 응용 프로그램은 첨부 파일 ""DlgInit/DlgInit.h""의 ExecuteDlgInitDx 함수를 호출하여 대화상자를 초기화할 수 있습니다.\r\n\r\n"
    IDS_DLGINIT3, "RT_DLGINIT의 경우 줄바꿈으로 구분된 문자열 목록을 지정하십시오."
    IDS_SAMELANG, "같은 언어입니다."
    IDS_SAMENAME, "리소스 이름이 같습니다."
    IDS_CANTSAVETOEXE, "실행 불가능한 파일에서 EXE로 저장할 수 없습니다."
    IDS_CANTSTARTSEARCH, "검색을 시작할 수 없습니다."
    IDS_AMERICA, "미국"
    IDS_ENGLISH, "영어"
    IDS_CHINA, "중국"
    IDS_CHINESE, "중국어"
    IDS_RUSSIA, "러시아"
    IDS_RUSSIAN, "러시아어"
    IDS_WANNAGENRESH, "'resource.h' 파일을 생성하시겠습니까?"
    IDS_EXEFILTER, "실행 파일 (*.exe;*.dll;*.ocx;*.cpl;*.scr;*.mui)|*.exe;*.dll;*.ocx;*.cpl;*.scr;*.mui|모든 파일 (*.*)|*.*|"
    IDS_SAVEASCOMPRESS, "압축된 상태로 저장"
    IDS_TOOL_NEW, "새로 만들기"
    IDS_TOOL_OPEN, "열기..."
    IDS_TOOL_SAVE, "다른 이름으로 저장..."
    IDS_TOOL_EXPAND, "모두 확장"
    IDS_TOOL_COLLAPSE, "모드 축소"
    IDS_TOOL_PLUS, "항목 추가..."
    IDS_TOOL_MINUS, "항목 삭제"
    IDS_TOOL_CHANGE, "이름/언어 변경"
    IDS_TOOL_CLONE, "다른 이름/언어로 복제"
    IDS_TOOL_RECOMPILE, "재컴파일"
    IDS_TOOL_CANCELEDIT, "편집 취소"
    IDS_TOOL_IMPORT, "가져오기..."
    IDS_TOOL_EXTRACT, "추출..."
    IDS_TOOL_GUIEDIT, "GUI로 편집"
    IDS_UNITEDKINGDOM, "영국"
    IDS_GREATBRITAIN, "대영제국"
    IDS_BRITISH, "영국어"
    IDS_FRANCE, "프랑스"
    IDS_FRENCH, "프랑스어"
    IDS_GERMANY, "독일"
    IDS_GERMAN, "독일어"
    IDS_SPAIN, "스페인"
    IDS_SPANISH, "스페인어"
    IDS_INVALIDLANG, "인식할 수 없는 언어입니다."
    IDS_INVALIDNAME, "잘못된 리소스 이름입니다."
    IDS_PNGRESBINFILTER, "PNG 이미지 (*.png)|*.png|바이너리 리소스 (*.res)|*.res|바이너리 파일 (*.bin)|*.bin|모든 파일 (*.*)|*.*|"
    IDS_JPEGRESBINFILTER, "JPEG 이미지 (*.jpg;*.jpeg;*.jpe;*.jfif)|*.jpg;*.jpeg;*.jpe;*.jfif|바이너리 리소스 (*.res)|*.res|바이너리 파일 (*.bin)|*.bin|모든 파일 (*.*)|*.*|"
    IDS_GIFRESBINFILTER, "GIF 이미지 (*.gif)|*.gif|바이너리 리소스 (*.res)|*.res|바이너리 파일 (*.bin)|*.bin|모든 파일 (*.*)|*.*|"
    IDS_TIFFRESBINFILTER, "TIFF 이미지 (*.tif;*.tiff)|*.tif;*.tiff|바이너리 리소스 (*.res)|*.res|바이너리 파일 (*.bin)|*.bin|모든 파일 (*.*)|*.*|"
    IDS_AVIRESBINFILTER, "AVI 영화 (*.avi)|*.avi|바이너리 리소스 (*.res)|*.res|바이너리 파일 (*.bin)|*.bin|All Files (*.*)|*.*|"
    IDS_WAVERESBINFILTER, "WAVE 사운드 (*.wav)|*.wav|바이너리 리소스 (*.res)|*.res|바이너리 파일 (*.bin)|*.bin|모든 파일 (*.*)|*.*|"
    IDS_COMMENT_SEP, "//////////////////////////////////////////////////////////////////////////////\r\n\r\n"
    IDS_NEWLINE, "\r\n"
    IDS_NOTICE, "// 이 파일은 RisohEditor 5.7.9 에 의해 자동으로 생성됩니다.\r\n"
    IDS_DAGGER, "// † <-- 이 단검은 UTF-8 감지에 도움이 됩니다.\r\n"
    IDS_IMPORTFILTER, "가져올 수 있는 파일|*.rc;*.res;*.dfm;*.html;*.htm;*.manifest;*.ico;*.cur;*.ani;*.wav;*.bmp;*.dib;*.png;*.gif;*.jpg;*.jpeg;*.jpe;*.jfif;*.tif;*.tiff;*.avi;*.wmf;*.emf;*.tlb|RC 파일 (*.rc)|*.rc|바이너리 리소스 (*.res)|*.res|이미지 파일|*.bmp;*.dib;*.png;*.gif;*.jpg;*.jpeg;*.jpe;*.jfif;*.tif;*.tiff;*.wmf;*.emf|커서 파일 (*.cur;*.ani)|*.cur;*.ani|아이콘 파일 (*.ico)|*.ico|WAVE 사운드 파일 (*.wav)|*.wav|HTML 파일 (*.html;*.htm)|*.html;*.htm|Manifest 파일 (*.manifest)|*.manifest|델파이 DFM 파일 (*.dfm)|*.dfm|TYPELIB 파일 (*.tlb)|*.tlb|모든 파일 (*.*)|*.*|"
    IDS_CANTWRITEBYLOCK, "다음 파일이 잠겨있기 때문에 파일을 쓸 수 없습니다.\r\n\r\n%s"
    IDS_ANSI, "ANSI"
    IDS_WIDE, "유니코드"
    IDS_UTF8, "UTF-8 (BOM 포함)"
    IDS_UTF8N, "UTF-8 (BOM 없음)"
    IDS_SJIS, "Shift_JIS"
    IDS_BINARY, "(바이너리 데이터)"
    IDS_RESTYPE, "리소스 유형"
    IDS_ENCODING, "인코딩"
    IDS_INVALIDRESTYPE, "잘못된 리소스 유형입니다."
    IDS_PATHSPACEERROR, "공백 문자가 있는 위치에 잘못 설치했습니다! 리소스 컴파일러는 공백을 허용할 수 없습니다.\n\nC:\\Program Files""는 피하십시오."
    IDS_LOADEGAPROGRAM, "EGA 프로그램 불러오기..."
    IDS_EGAFILTER, "EGA 프로그램 (*.ega)|*.ega|모든 파일 (*.*)|*.*|"
    IDS_QUERYSAVECHANGE, "파일이 수정되었습니다. 지금 변경 사항을 저장하시겠습니까?"
    IDS_DFMFILTER, "DFM 파일 (*.dfm)|*.dfm|텍스트 파일 (*.txt)|*.txt|모든 파일 (*.*)|*.*|"
    IDS_CANTEXTRACTDFM, "DFM 데이터를 추출할 수 없습니다."
    IDS_EXTRACTDFM, "DFM 데이터 추출"
    IDS_ENTERNONZERONAME, "파일이 저장되었습니다. 0이 아닌 리소스 이름을 입력하세요."
    IDS_ENTERNONZEROTYPE, "파일이 저장되었습니다. 0이 아닌 리소스 유형을 입력하세요."
    IDS_HOMEPAGE, "https://katahiromz.web.fc2.com/re/ko/"
    IDS_FILESAVED, "파일이 저장되었습니다."
    IDS_RECOMPILEOK, "재컴파일이 완료되었습니다."
    IDS_RECOMPILEFAILED, "재컴파일에 실패했습니다 (구문 오류)."
    IDS_TOOL_EXPORT, "내보내기..."
    IDS_CODEEDITOR, "코드 편집기"
    IDS_HEXVIEWER, "Hex 뷰어"
    IDS_INTEGERORIDENTIFIER, "(정수 또는 식별자)"
    IDS_NOTEXT, " "
    IDS_NOUPDATE, "최신 RisohEditor를 사용하고 있습니다."
    IDS_THEREISUPDATE, "RisohEditor %s를 사용할 수 있습니다. 지금 다운로드하시겠습니까?"
    IDS_CANTCHECKUPDATE, "RisohEditor 업데이트를 확인하지 못했습니다."
    IDS_CODEPAGE1252, "1252 (라틴 1)"
    IDS_CODEPAGE1250, "1250 (라틴 2)"
    IDS_CODEPAGE1251, "1251 (키릴 문자)"
    IDS_CODEPAGE1253, "1253 (그리스어)"
    IDS_CODEPAGE1254, "1254 (터키어)"
    IDS_CODEPAGE1255, "1255 (히브리어)"
    IDS_CODEPAGE1256, "1256 (아랍어)"
    IDS_CODEPAGE1257, "1257 (발트어)"
    IDS_CODEPAGE874, "874 (태국어)"
    IDS_CODEPAGE932, "932 (일본어)"
    IDS_CODEPAGE936, "936 (중국어 간체)"
    IDS_CODEPAGE949, "949 (한국어)"
    IDS_CODEPAGE950, "950 (중국어 번체)"
    IDS_CODEPAGE65001, "65001 (UTF-8)"
    IDS_EXTRACTTLB, "TYPELIB 데이터 추출"
    IDS_CANTEXTRACTTLB, "TYPELIB 데이터를 추출할 수 없습니다."
    IDS_TLBRESBINFILTER, "TYPELIB 데이터 (*.tlb)|*.tlb|바이너리 리소스(*.res)|*.res|텍스트 (*.txt)|*.txt|MIDL 파일 (*.idl)|*.idl|모든 파일 (*.*)|*.*|"
    IDS_USAGE, "사용법: RisohEditor [options | ""파일""]\n\nOptions:\n--help  이 메시지를 표시합니다.\n--version  버전 정보를 표시합니다.\n--load ""your-file.rc""  파일을 로드합니다 (GUI 없이)\n--save ""your-file.res""  파일을 저장합니다 (GUI 없이)\n--log-file ""log-file.txt""  로그 파일을 지정합니다.\n--load-options OPTIONS  로드 옵션을 설정합니다.\n--save-options OPTIONS  저장 옵션을 설정합니다.\n\nLoad options: (no-load-res-h)\nSave options: (idc-static)(compress)(sep-lang)(no-res-folder)(lang-macro)(less-comments)(wrap-manifest)(begin-end)(utf-16)(backup)(ms-msgtbl)"
    IDS_NOSELECTION, "선택 항목이 없습니다."
    IDS_TRANSLATORS, "[번역]\r\n한국어: VenusGirl-비너스걸❤\r\nEnglish: Katayama Hirofumi MZ\r\nFinnish: Veikko Muurikainen\r\nIndonesian: Mas Ahmad Muhammad\r\nItalian: R.B.\r\nJapanese: Katayama Hirofumi MZ\\r\nPolish: Piotr Hetnarowicz\r\nPortuguese: JNylson\r\nRussian: Dmitry Yerokhin\r\nSimplified Chinese: 林鸿湘\r\n"
}

//////////////////////////////////////////////////////////////////////////////

```

`src/lang/pl_PL.rc`:

```rc
// This file is automatically generated by RisohEditor 5.7.9.
// † <-- This dagger helps UTF-8 detection.

#pragma code_page(65001) // UTF-8

LANGUAGE LANG_POLISH, SUBLANG_DEFAULT

//////////////////////////////////////////////////////////////////////////////
// RT_MENU

IDR_MAINMENU MENU
{
    POPUP "&Plik"
    {
        MENUITEM "&Nowy\tCtrl+N", ID_NEW
        MENUITEM SEPARATOR
        MENUITEM "&Otwórz...\tCtrl+O", ID_OPEN
        MENUITEM "&Zapisz...\tCtrl+S", ID_SAVE
        MENUITEM "Zapisz &jako...\tShift+Ctrl+S", ID_SAVEAS
        MENUITEM "Zapisz z Ko&mpresją...", ID_SAVEASCOMPRESS
        MENUITEM SEPARATOR
        MENUITEM "&Importuj...\tCtrl+I", ID_IMPORT
        MENUITEM "&Eksportuj...\tCtrl+P", ID_EXPORT
        MENUITEM SEPARATOR
        MENUITEM "Przeładuj &resource.h...\tCtrl+R", ID_LOADRESH
        MENUITEM "Zapisz re&source.h...", ID_UPDATERESHBANG
        MENUITEM "Ad&vice resource.h Modification...", ID_ADVICERESH
        MENUITEM "&Unload resource.h", ID_UNLOADRESH
        MENUITEM SEPARATOR
        MENUITEM "Load &Window Class Library...", ID_LOADWCLIB
        MENUITEM SEPARATOR
        POPUP "Ostatnio używane pliki"
        {
            MENUITEM "(None)", -1, GRAYED
        }
        MENUITEM SEPARATOR
        MENUITEM "W&yjście\tAlt+F4", ID_EXIT
    }
    POPUP "&Edycja"
    {
        MENUITEM "Edytuj przez &GUI...\tCtrl+G", ID_GUIEDIT
        MENUITEM SEPARATOR
        POPUP "&Dodaj"
        {
            MENUITEM "Dodaj &Ikonę...", ID_ADDICON
            MENUITEM "Dodaj &Kursor...", ID_ADDCURSOR
            MENUITEM "Dodaj &Bitmapę...", ID_ADDBITMAP
            MENUITEM "Dodaj &Okno dialogowe...", ID_ADDDIALOG
            MENUITEM "Dodaj &Menu...", ID_ADDMENU
            MENUITEM "Dodaj Łań&cuch...", ID_ADDSTRINGTABLE
            MENUITEM "Dodaj &Tablicę komunikatów...", ID_ADDMESSAGETABLE
            MENUITEM "Dodaj &HTML...", ID_ADDHTML
            MENUITEM "Dodaj &Skróty klawiaturowe...", ID_ADDACCEL
            MENUITEM "Dodaj &Informacje o wersji...", ID_ADDVERINFO
            MENUITEM "Dodaj Mani&fest...", ID_ADDMANIFEST
            MENUITEM "Dodaj &pasek narzędzi...", ID_ADDTOOLBAR
            MENUITEM "Dodaj Element &zasobów...", ID_ADDRES
        }
        POPUP "&Zamień"
        {
            MENUITEM "Zamień &Ikonę...", ID_REPLACEICON
            MENUITEM "Zamień &Kursor...", ID_REPLACECURSOR
            MENUITEM "Zamień &Bitmapę...", ID_REPLACEBITMAP
            MENUITEM "Zamień Element &Zasobu Binarnego...", ID_REPLACEBIN
        }
        POPUP "&Wypakuj"
        {
            MENUITEM "Wypakuj &Ikonę...", ID_EXTRACTICON
            MENUITEM "Wypakuj &Kursor...", ID_EXTRACTCURSOR
            MENUITEM "Wypakuj &Bitmapę...", ID_EXTRACTBITMAP
            MENUITEM "Wypakuj &jako plik RC...", ID_EXTRACTRC
            MENUITEM "Wypakuj Element &Zasobu Binarnego...", ID_EXTRACTBIN
        }
        MENUITEM SEPARATOR
        MENUITEM "Z&mień Nazwę/Język\tF2", ID_EDITLABEL
        MENUITEM SEPARATOR
        MENUITEM "Klonuj w Nowej &Nazwie...", ID_COPYASNEWNAME
        MENUITEM "Klonuj w Nowym &Języku...", ID_COPYASNEWLANG
        MENUITEM "Skopiuj do wielu języków...", ID_COPYTOMULTILANG
        MENUITEM SEPARATOR
        MENUITEM "&Testuj", ID_TEST
        MENUITEM SEPARATOR
        MENUITEM "&Usuń\tDel", ID_DELETERES
        MENUITEM SEPARATOR
        MENUITEM "Skojarzenia identyfikatorów...", ID_IDASSOC
        MENUITEM "Predefiniowane Mak&ra...", ID_PREDEFMACROS
        MENUITEM "Ustawienia &Czcionki...", ID_FONTS
        MENUITEM "Ustawienia &Katalogów...", ID_SETPATHS
        MENUITEM SEPARATOR
        MENUITEM "&UI Language Select (UI语言选择)...", ID_CHOOSEUILANG
        MENUITEM SEPARATOR
        MENUITEM "Ustawienia Delphi D&FM...", ID_DFMSETTINGS
        MENUITEM "Konfi&guracja...", ID_CONFIG
    }
    POPUP "&Szukaj"
    {
        MENUITEM "&Szukaj...\tCtrl+F", ID_FIND
        MENUITEM SEPARATOR
        MENUITEM "Szukaj &W górę\tShift+F3", ID_FINDUPWARD
        MENUITEM "Szukaj w &dół\tF3", ID_FINDDOWNWARD
        MENUITEM SEPARATOR
        MENUITEM "&Query constant...", ID_QUERYCONSTANT
    }
    POPUP "&Widok"
    {
        MENUITEM "Pasek &stanu", ID_STATUSBAR
        MENUITEM "Pasek &narzędzi", ID_SHOWHIDETOOLBAR
        MENUITEM "&Binarny", ID_BINARYPANE
        MENUITEM SEPARATOR
        MENUITEM "Roz&wiń wszystko\tCtrl+K", ID_EXPAND_ALL
        MENUITEM "&Zwiń wszystko\tCtrl+L", ID_COLLAPSE_ALL
        MENUITEM SEPARATOR
        MENUITEM "Lista &Identyfikatorów Zasobów IDs", ID_IDLIST
        MENUITEM "Lista &języków...", ID_SHOWLANGS
        MENUITEM SEPARATOR
        MENUITEM "Always &CONTROL statement", ID_ALWAYSCONTROL
        MENUITEM "Don't Use &ID Macros", ID_HIDEIDMACROS
        MENUITEM "Use IDC_ST&ATIC", ID_USEIDC_STATIC
        MENUITEM "Zawijanie wy&razów", ID_WORD_WRAP
        MENUITEM "Use BE&GIN/END", ID_USEBEGINEND
        MENUITEM "Use Microsoft Message &Table", ID_USEMSMSGTBL
        MENUITEM SEPARATOR
        MENUITEM "&Encoding of resource item...", ID_ENCODING
        MENUITEM "Dialog &font substitutes...", ID_DIALOG_FONT_SUBSTITUTES
        MENUITEM SEPARATOR
        MENUITEM "O&dśwież", ID_REFRESHALL
    }
    POPUP "&Automatyzacja"
    {
        MENUITEM "Programming Language &EGA...", ID_EGA
        MENUITEM "&Run EGA program...", ID_EGA_PROGRAM
        MENUITEM "Open EGA &Manual", ID_OPEN_EGA_MANUAL
    }
    POPUP "&Pomoc"
    {
        MENUITEM "Otwórz &README.txt (Angielski)", ID_OPENREADME
        MENUITEM "Otwórz &LICENSE.txt", ID_OPENLICENSE
        MENUITEM SEPARATOR
        MENUITEM "Pr&zewodnik po RisohEditor", ID_GUIDE
        MENUITEM "Sprawdź &aktualizacje RisohEditor...", ID_CHECKUPDATE
        MENUITEM SEPARATOR
        MENUITEM "&O programie...", ID_ABOUT
    }
}

IDR_POPUPMENUS MENU
{
    POPUP "Popup #0"
    {
        MENUITEM "Edytuj przez &GUI...\tCtrl+G", ID_GUIEDIT
        MENUITEM SEPARATOR
        POPUP "&Dodaj"
        {
            MENUITEM "Dodaj &Ikonę...", ID_ADDICON
            MENUITEM "Dodaj &Kursor...", ID_ADDCURSOR
            MENUITEM "Dodaj &Bitmapę...", ID_ADDBITMAP
            MENUITEM "Dodaj &Okno dialogowe...", ID_ADDDIALOG
            MENUITEM "Dodaj &Menu...", ID_ADDMENU
            MENUITEM "Dodaj Łań&cuch...", ID_ADDSTRINGTABLE
            MENUITEM "Dodaj &Tablicę komunikatów...", ID_ADDMESSAGETABLE
            MENUITEM "Dodaj &HTML...", ID_ADDHTML
            MENUITEM "Dodaj &Skróty klawiaturowe...", ID_ADDACCEL
            MENUITEM "Dodaj &Informacje o wersji...", ID_ADDVERINFO
            MENUITEM "Dodaj Mani&fest...", ID_ADDMANIFEST
            MENUITEM "Dodaj &pasek narzędzi...", ID_ADDTOOLBAR
            MENUITEM "Dodaj Element &zasobów...", ID_ADDRES
        }
        POPUP "&Zamień"
        {
            MENUITEM "Zamień &Ikonę...", ID_REPLACEICON
            MENUITEM "Zamień &Kursor...", ID_REPLACECURSOR
            MENUITEM "Zamień &Bitmapę...", ID_REPLACEBITMAP
            MENUITEM "Zamień Element &Zasobu Binarnego...", ID_REPLACEBIN
        }
        POPUP "&Wypakuj"
        {
            MENUITEM "Wypakuj &Ikonę...", ID_EXTRACTICON
            MENUITEM "Wypakuj &Kursor...", ID_EXTRACTCURSOR
            MENUITEM "Wypakuj &Bitmapę...", ID_EXTRACTBITMAP
            MENUITEM "Wypakuj &jako plik RC...", ID_EXTRACTRC
            MENUITEM "Wypakuj Element &Zasobu Binarnego...", ID_EXTRACTBIN
        }
        MENUITEM SEPARATOR
        MENUITEM "Z&mień Nazwę/Język\tF2", ID_EDITLABEL
        MENUITEM SEPARATOR
        MENUITEM "Klonuj w Nowej &Nazwie...", ID_COPYASNEWNAME
        MENUITEM "Klonuj w Nowym &Języku...", ID_COPYASNEWLANG
        MENUITEM "Skopiuj do wielu języków...", ID_COPYTOMULTILANG
        MENUITEM SEPARATOR
        MENUITEM "&Testuj", ID_TEST
        MENUITEM SEPARATOR
        MENUITEM "&Usuń\tDel", ID_DELETERES
    }
    POPUP "Popup #1"
    {
        MENUITEM "&Dodaj &formant (Control)...", ID_ADDCTRL
        MENUITEM SEPARATOR
        MENUITEM "Wyt&nij\tCtrl+X", ID_CUT
        MENUITEM "&Kopiuj\tCtrl+C", ID_COPY
        MENUITEM "Wkl&ej\tCtrl+V", ID_PASTE
        MENUITEM "&Usuń\tDel", ID_DELCTRL
        MENUITEM SEPARATOR
        POPUP "&Indeks"
        {
            MENUITEM "Do &góry", ID_CTRLINDEXTOP
            MENUITEM SEPARATOR
            MENUITEM "&Zmniejsz Indeks", ID_CTRLINDEXMINUS
            MENUITEM "Z&większ Indeks", ID_CTRLINDEXPLUS
            MENUITEM SEPARATOR
            MENUITEM "Do &dołu", ID_CTRLINDEXBOTTOM
            MENUITEM SEPARATOR
            MENUITEM "Pokaż/Ukry Indeksy\tCtrl+D", ID_SHOWHIDEINDEX
        }
        POPUP "&Wyrównanie"
        {
            MENUITEM "Wyrównaj do &góry", ID_TOPALIGN
            MENUITEM "Wyrównaj do &dołu", ID_BOTTOMALIGN
            MENUITEM "Wyrównaj do &lewej", ID_LEFTALIGN
            MENUITEM "Wyrównaj do &prawej", ID_RIGHTALIGN
            MENUITEM SEPARATOR
            MENUITEM "Dopasuj do &Siatki", ID_FITTOGRID
        }
        MENUITEM SEPARATOR
        MENUITEM "&Odśwież", ID_REFRESHDIALOG
        MENUITEM SEPARATOR
        MENUITEM "Właściwości &formantu (Control)...", ID_CTRLPROP
        MENUITEM "Właściwości Okna &Dialogowego...", ID_DLGPROP
    }
    POPUP "Popup #2"
    {
        MENUITEM "&Modyfikuj...", ID_MODIFYASSOC
    }
    POPUP "Popup #3"
    {
        MENUITEM "&Jump!", ID_IDJUMP
        MENUITEM SEPARATOR
        MENUITEM "&Dodaj ID...", ID_ADDRESID
        MENUITEM "&Modyfikuj ID...", ID_MODIFYRESID
        MENUITEM SEPARATOR
        MENUITEM "Kopiuj N&azwę", ID_COPYRESIDNAME
        MENUITEM "Kopiuj Wa&rtość", ID_COPYRESIDVALUE
        MENUITEM "Kopiuj De&finicję\tCtrl+C", ID_COPYIDDEF
        MENUITEM SEPARATOR
        MENUITEM "&Usuń ID\tDel", ID_DELETERESID
        MENUITEM SEPARATOR
        MENUITEM "Liczby dziesię&tne", ID_BASE10
        MENUITEM "Liczby szesnastkowe &HEX", ID_BASE16
        MENUITEM SEPARATOR
        MENUITEM "&Przeładuj", ID_LOADRESH
    }
    POPUP "Popup #4"
    {
        MENUITEM "&Dodaj...", ID_ADD
        MENUITEM SEPARATOR
        MENUITEM "Zmień &Nazwę...\tF2", ID_RENAME
        MENUITEM "Zmień &Wartość...", ID_MODIFY
        MENUITEM SEPARATOR
        MENUITEM "&Usuń\tDel", ID_DELETE
    }
    POPUP "Popup #5"
    {
        MENUITEM "&Kopiuj wartość całkowitą", ID_COPY
    }
    POPUP "Popup #6"
    {
        MENUITEM "D&odaj...", psh1
        MENUITEM "&Modyfikuj...", psh2
        MENUITEM SEPARATOR
        MENUITEM "&Góra", psh4
        MENUITEM "&Dół", psh5
        MENUITEM "&Lewa", psh6
        MENUITEM "&Prawa", psh7
        MENUITEM SEPARATOR
        MENUITEM "&Usuń\tDel", psh3
    }
    POPUP "Popup #7"
    {
        MENUITEM "&Dodaj...", psh1
        MENUITEM "&Modyfikuj...", psh2
        MENUITEM SEPARATOR
        MENUITEM "&Góra", psh4
        MENUITEM "&Dół", psh5
        MENUITEM SEPARATOR
        MENUITEM "&Usuń\tDel", psh3
    }
    POPUP "Popup #8"
    {
        MENUITEM "&Dodaj...", ID_ADD
        MENUITEM "&Modyfikuj...", ID_MODIFY
        MENUITEM SEPARATOR
        MENUITEM "&Usuń\tDel", ID_DELETE
    }
}

//////////////////////////////////////////////////////////////////////////////
// RT_DIALOG

IDD_REPLACERES DIALOGEX 0, 0, 215, 170
CAPTION "Zamienianie Zasobu"
STYLE DS_MODALFRAME | WS_POPUPWINDOW | WS_CAPTION
FONT 9, "MS Shell Dlg", 0, 0, 1
{
    LTEXT "&Typ zasobu:", -1, 5, 7, 70, 12
    COMBOBOX cmb1, 75, 5, 135, 200, CBS_HASSTRINGS | CBS_AUTOHSCROLL | CBS_DROPDOWN | WS_BORDER | WS_VSCROLL | WS_TABSTOP
    LTEXT "&Nazwa zasobu:", -1, 5, 32, 70, 12
    COMBOBOX cmb2, 75, 30, 135, 200, CBS_HASSTRINGS | CBS_AUTOHSCROLL | CBS_DROPDOWN | WS_DISABLED | WS_BORDER | WS_VSCROLL | WS_TABSTOP
    LTEXT "&Język zasobu:", -1, 5, 57, 70, 12
    COMBOBOX cmb3, 75, 55, 135, 200, CBS_HASSTRINGS | CBS_AUTOHSCROLL | CBS_DROPDOWN | WS_DISABLED | WS_BORDER | WS_VSCROLL | WS_TABSTOP
    LTEXT "Plik &binarny:", -1, 5, 85, 100, 12
    EDITTEXT edt1, 5, 97, 205, 14, ES_AUTOHSCROLL
    PUSHBUTTON "&Przeglądaj...", psh1, 150, 115, 60, 14
    DEFPUSHBUTTON "OK", IDOK, 35, 150, 60, 14
    PUSHBUTTON "Anuluj", IDCANCEL, 115, 150, 60, 14
    {
        0x1234, 0x5678, 0x0011
    }
}

IDD_ADDICON DIALOG 0, 0, 215, 135
CAPTION "Dodawanie Ikony"
STYLE DS_MODALFRAME | WS_POPUPWINDOW | WS_CAPTION
FONT 9, "MS Shell Dlg"
{
    LTEXT "Plik &ikony:", -1, 5, 7, 100, 12
    EDITTEXT edt1, 5, 18, 205, 14, ES_AUTOHSCROLL
    PUSHBUTTON "&Przeglądaj...", psh1, 150, 35, 60, 14
    ICON 0, ico1, 5, 35, 0, 0
    LTEXT "&Nazwa zasobu:", -1, 5, 67, 70, 12
    COMBOBOX cmb2, 75, 65, 120, 300, CBS_HASSTRINGS | CBS_AUTOHSCROLL | CBS_DROPDOWN | WS_BORDER | WS_VSCROLL | WS_TABSTOP
    PUSHBUTTON "&...", psh2, 195, 65, 15, 14
    LTEXT "&Język zasobu:", -1, 5, 92, 70, 12
    COMBOBOX cmb3, 75, 90, 135, 200, CBS_HASSTRINGS | CBS_AUTOHSCROLL | CBS_DROPDOWN | WS_BORDER | WS_VSCROLL | WS_TABSTOP
    DEFPUSHBUTTON "OK", IDOK, 35, 115, 60, 14
    PUSHBUTTON "Anuluj", IDCANCEL, 115, 115, 60, 14
}

IDD_REPLACEICON DIALOG 0, 0, 215, 135
CAPTION "Zamienianie Ikony"
STYLE DS_MODALFRAME | WS_POPUPWINDOW | WS_CAPTION
FONT 9, "MS Shell Dlg"
{
    LTEXT "Plik &ikony:", -1, 5, 7, 100, 12
    EDITTEXT edt1, 5, 18, 205, 14, ES_AUTOHSCROLL
    PUSHBUTTON "&Przeglądaj...", psh1, 150, 35, 60, 14
    ICON 0, ico1, 5, 35, 0, 0
    LTEXT "&Nazwa zasobu:", -1, 5, 67, 70, 12
    COMBOBOX cmb2, 75, 65, 135, 13, CBS_HASSTRINGS | CBS_AUTOHSCROLL | CBS_DROPDOWN | WS_DISABLED | WS_BORDER | WS_VSCROLL | WS_TABSTOP
    LTEXT "&Język zasobu:", -1, 5, 92, 70, 12
    COMBOBOX cmb3, 75, 90, 135, 13, CBS_HASSTRINGS | CBS_AUTOHSCROLL | CBS_DROPDOWN | WS_DISABLED | WS_BORDER | WS_VSCROLL | WS_TABSTOP
    DEFPUSHBUTTON "OK", IDOK, 35, 115, 60, 14
    PUSHBUTTON "Anuluj", IDCANCEL, 115, 115, 60, 14
}

IDD_ADDBITMAP DIALOG 0, 0, 215, 135
CAPTION "Dodawanie Bitmapy"
STYLE DS_MODALFRAME | WS_POPUPWINDOW | WS_CAPTION
FONT 9, "MS Shell Dlg"
{
    LTEXT "Plik &bitmapy:", -1, 5, 7, 100, 12
    EDITTEXT edt1, 5, 18, 205, 14, ES_AUTOHSCROLL
    PUSHBUTTON "&Przeglądaj...", psh1, 150, 35, 60, 14
    LTEXT "&Nazwa zasobu:", -1, 5, 67, 70, 12
    COMBOBOX cmb2, 75, 65, 120, 300, CBS_HASSTRINGS | CBS_AUTOHSCROLL | CBS_DROPDOWN | WS_BORDER | WS_VSCROLL | WS_TABSTOP
    PUSHBUTTON "&...", psh2, 195, 65, 15, 14
    LTEXT "&Język zasobu:", -1, 5, 92, 70, 12
    COMBOBOX cmb3, 75, 90, 135, 200, CBS_HASSTRINGS | CBS_AUTOHSCROLL | CBS_DROPDOWN | WS_BORDER | WS_VSCROLL | WS_TABSTOP
    DEFPUSHBUTTON "OK", IDOK, 35, 115, 60, 14
    PUSHBUTTON "Anuluj", IDCANCEL, 115, 115, 60, 14
}

IDD_REPLACEBMP DIALOG 0, 0, 215, 135
CAPTION "Zamienianie Bitmapy"
STYLE DS_MODALFRAME | WS_POPUPWINDOW | WS_CAPTION
FONT 9, "MS Shell Dlg"
{
    LTEXT "Plik &bitmapy:", -1, 5, 7, 100, 12
    EDITTEXT edt1, 5, 18, 205, 14, ES_AUTOHSCROLL
    PUSHBUTTON "&Przeglądaj...", psh1, 150, 35, 60, 14
    LTEXT "&Nazwa zasobu:", -1, 5, 67, 70, 12
    COMBOBOX cmb2, 75, 65, 135, 200, CBS_HASSTRINGS | CBS_AUTOHSCROLL | CBS_DROPDOWN | WS_DISABLED | WS_BORDER | WS_VSCROLL | WS_TABSTOP
    LTEXT "&Język zasobu:", -1, 5, 92, 70, 12
    COMBOBOX cmb3, 75, 90, 135, 200, CBS_HASSTRINGS | CBS_AUTOHSCROLL | CBS_DROPDOWN | WS_DISABLED | WS_BORDER | WS_VSCROLL | WS_TABSTOP
    DEFPUSHBUTTON "OK", IDOK, 35, 115, 60, 14
    PUSHBUTTON "Anuluj", IDCANCEL, 115, 115, 60, 14
}

IDD_ADDRES DIALOG 0, 0, 215, 170
CAPTION "Dodawanie Zasobu"
STYLE DS_MODALFRAME | WS_POPUPWINDOW | WS_CAPTION
FONT 9, "MS Shell Dlg"
{
    LTEXT "Typ &zasobu:", -1, 5, 7, 70, 12
    COMBOBOX cmb1, 75, 5, 135, 200, CBS_HASSTRINGS | CBS_AUTOHSCROLL | CBS_DROPDOWN | WS_BORDER | WS_VSCROLL | WS_TABSTOP
    LTEXT "&Nazwa zasobu:", -1, 5, 32, 70, 12
    COMBOBOX cmb2, 75, 30, 120, 300, CBS_HASSTRINGS | CBS_AUTOHSCROLL | CBS_DROPDOWN | WS_BORDER | WS_VSCROLL | WS_TABSTOP
    PUSHBUTTON "&...", psh2, 195, 30, 15, 14
    LTEXT "", stc1, 75, 43, 115, 10
    LTEXT "&Język zasobu:", -1, 5, 57, 70, 12
    COMBOBOX cmb3, 75, 55, 135, 200, CBS_HASSTRINGS | CBS_AUTOHSCROLL | CBS_DROPDOWN | WS_BORDER | WS_VSCROLL | WS_TABSTOP
    LTEXT "Plik &binarny:", -1, 5, 85, 100, 12
    EDITTEXT edt1, 5, 97, 205, 14, ES_AUTOHSCROLL
    PUSHBUTTON "&Przeglądaj...", psh1, 150, 115, 60, 14
    LTEXT "", stc2, 5, 112, 100, 10
    DEFPUSHBUTTON "OK", IDOK, 35, 150, 60, 14
    PUSHBUTTON "Anuluj", IDCANCEL, 115, 150, 60, 14
}

IDD_ADDCURSOR DIALOG 0, 0, 215, 135
CAPTION "Dodawanie Kursora"
STYLE DS_MODALFRAME | WS_POPUPWINDOW | WS_CAPTION
FONT 9, "MS Shell Dlg"
{
    LTEXT "Plik &Kursora:", -1, 5, 7, 100, 12
    EDITTEXT edt1, 5, 18, 205, 14, ES_AUTOHSCROLL
    PUSHBUTTON "&Przeglądaj...", psh1, 150, 35, 60, 14
    ICON 0, ico1, 5, 35, 0, 0
    LTEXT "&Nazwa zasobu:", -1, 5, 67, 70, 12
    COMBOBOX cmb2, 75, 65, 120, 200, CBS_HASSTRINGS | CBS_AUTOHSCROLL | CBS_DROPDOWN | WS_BORDER | WS_VSCROLL | WS_TABSTOP
    PUSHBUTTON "&...", psh2, 195, 65, 15, 14
    LTEXT "&Język zasobu:", -1, 5, 92, 70, 12
    COMBOBOX cmb3, 75, 90, 135, 200, CBS_HASSTRINGS | CBS_AUTOHSCROLL | CBS_DROPDOWN | WS_BORDER | WS_VSCROLL | WS_TABSTOP
    DEFPUSHBUTTON "OK", IDOK, 35, 115, 60, 14
    PUSHBUTTON "Anuluj", IDCANCEL, 115, 115, 60, 14
}

IDD_REPLACECUR DIALOG 0, 0, 215, 135
CAPTION "Zamienianie Kursora"
STYLE DS_MODALFRAME | WS_POPUPWINDOW | WS_CAPTION
FONT 9, "MS Shell Dlg"
{
    LTEXT "Plik &Kursora:", -1, 5, 7, 100, 12
    EDITTEXT edt1, 5, 18, 205, 14, ES_AUTOHSCROLL
    PUSHBUTTON "&Przeglądaj...", psh1, 150, 35, 60, 14
    ICON 0, ico1, 5, 35, 0, 0
    LTEXT "&Nazwa zasobu:", -1, 5, 67, 70, 12
    COMBOBOX cmb2, 75, 65, 135, 200, CBS_HASSTRINGS | CBS_AUTOHSCROLL | CBS_DROPDOWN | WS_DISABLED | WS_BORDER | WS_VSCROLL | WS_TABSTOP
    LTEXT "&Język zasobu:", -1, 5, 92, 70, 12
    COMBOBOX cmb3, 75, 90, 135, 200, CBS_HASSTRINGS | CBS_AUTOHSCROLL | CBS_DROPDOWN | WS_DISABLED | WS_BORDER | WS_VSCROLL | WS_TABSTOP
    DEFPUSHBUTTON "OK", IDOK, 35, 115, 60, 14
    PUSHBUTTON "Anuluj", IDCANCEL, 115, 115, 60, 14
}

IDD_MENUTEST DIALOG 0, 0, 215, 135
CAPTION "Menu Test"
STYLE DS_MODALFRAME | WS_POPUPWINDOW | WS_CAPTION
FONT 9, "MS Shell Dlg"
{
}

IDD_ADDKEY DIALOG 0, 0, 190, 120
CAPTION "Dodawanie Klucza"
STYLE DS_MODALFRAME | WS_POPUPWINDOW | WS_CAPTION
FONT 9, "MS Shell Dlg"
{
    RTEXT "&Klucz:", -1, 5, 12, 60, 14
    COMBOBOX cmb1, 70, 10, 110, 200, CBS_DROPDOWN | WS_BORDER | WS_VSCROLL | WS_TABSTOP
    RTEXT "ID &Polecenia:", -1, 5, 37, 60, 14
    COMBOBOX cmb2, 70, 35, 95, 300, CBS_DROPDOWN | WS_BORDER | WS_VSCROLL | WS_TABSTOP
    PUSHBUTTON "&...", psh1, 165, 35, 15, 14
    AUTOCHECKBOX "&VIRTKEY", chx1, 5, 60, 60, 14
    AUTOCHECKBOX "&NOINVERT", chx2, 70, 60, 60, 14
    AUTOCHECKBOX "&CONTROL", chx3, 5, 75, 60, 14
    AUTOCHECKBOX "&SHIFT", chx4, 70, 75, 60, 14
    AUTOCHECKBOX "&ALT", chx5, 140, 75, 45, 14
    DEFPUSHBUTTON "OK", IDOK, 60, 100, 60, 14
    PUSHBUTTON "Anuluj", IDCANCEL, 125, 100, 60, 14
}

IDD_MODIFYKEY DIALOG 0, 0, 190, 120
CAPTION "Modyfikowanie Klucza"
STYLE DS_MODALFRAME | WS_POPUPWINDOW | WS_CAPTION
FONT 9, "MS Shell Dlg"
{
    RTEXT "&Klucz:", -1, 5, 12, 60, 14
    COMBOBOX cmb1, 70, 10, 110, 200, CBS_DROPDOWN | WS_BORDER | WS_VSCROLL | WS_TABSTOP
    RTEXT "ID &Polecenia:", -1, 5, 37, 60, 14
    COMBOBOX cmb2, 70, 35, 95, 200, CBS_DROPDOWN | WS_BORDER | WS_VSCROLL | WS_TABSTOP
    PUSHBUTTON "&...", psh1, 165, 35, 15, 14
    AUTOCHECKBOX "&VIRTKEY", chx1, 5, 60, 60, 14
    AUTOCHECKBOX "&NOINVERT", chx2, 70, 60, 60, 14
    AUTOCHECKBOX "&CONTROL", chx3, 5, 75, 60, 14
    AUTOCHECKBOX "&SHIFT", chx4, 70, 75, 60, 14
    AUTOCHECKBOX "&ALT", chx5, 140, 75, 45, 14
    DEFPUSHBUTTON "OK", IDOK, 60, 100, 60, 14
    PUSHBUTTON "Anuluj", IDCANCEL, 125, 100, 60, 14
}

IDD_EDITACCEL DIALOG 0, 0, 285, 165
CAPTION "Edycja skrótów klawiaturowych"
STYLE WS_POPUPWINDOW | WS_CAPTION | WS_THICKFRAME
FONT 9, "MS Shell Dlg"
{
    LTEXT "&Lista kluczy:", -1, 5, 7, 100, 12
    CONTROL "", lst1, "SysListView32", LVS_NOSORTHEADER | LVS_AUTOARRANGE | LVS_NOLABELWRAP | LVS_SHOWSELALWAYS | LVS_SINGLESEL | LVS_REPORT | WS_BORDER | WS_VSCROLL | WS_HSCROLL | WS_TABSTOP, 5, 20, 210, 120
    PUSHBUTTON "D&odaj...", psh1, 220, 20, 60, 14
    PUSHBUTTON "&Modyfikuj...", psh2, 220, 40, 60, 14
    PUSHBUTTON "&Usuń", psh3, 220, 60, 60, 14
    PUSHBUTTON "&Góra", psh4, 220, 100, 60, 14
    PUSHBUTTON "&Dół", psh5, 220, 120, 60, 14
    DEFPUSHBUTTON "OK", IDOK, 155, 145, 60, 14
    PUSHBUTTON "Anuluj", IDCANCEL, 220, 145, 60, 14
    PUSHBUTTON "Usuń &wszystko", psh6, 5, 145, 79, 14
}

IDD_ADDSTR DIALOG 0, 0, 255, 115
CAPTION "Dodawanie wpisu Łańcucha"
STYLE WS_POPUPWINDOW | WS_CAPTION | WS_THICKFRAME
FONT 9, "MS Shell Dlg"
{
    LTEXT "&ID łańcucha:", -1, 5, 7, 50, 12
    COMBOBOX cmb1, 60, 5, 134, 200, CBS_HASSTRINGS | CBS_AUTOHSCROLL | CBS_DROPDOWN | WS_BORDER | WS_VSCROLL | WS_TABSTOP
    PUSHBUTTON "&...", psh1, 195, 5, 15, 14
    LTEXT "Wartość &łańcucha:", -1, 5, 27, 54, 16
    EDITTEXT edt1, 60, 25, 190, 45, ES_WANTRETURN | ES_AUTOVSCROLL | ES_MULTILINE | WS_VSCROLL
    AUTOCHECKBOX "&Zamień ""\\r\\n"" with ""\\n""", chx1, 60, 75, 190, 14
    DEFPUSHBUTTON "OK", IDOK, 125, 95, 60, 14
    PUSHBUTTON "Anuluj", IDCANCEL, 190, 95, 60, 14
}

IDD_MODIFYSTR DIALOG 0, 0, 255, 115
CAPTION "Modyfikowanie wpisu Łańcucha"
STYLE WS_POPUPWINDOW | WS_CAPTION | WS_THICKFRAME
FONT 9, "MS Shell Dlg"
{
    LTEXT "&ID łańcucha:", -1, 5, 7, 50, 12
    COMBOBOX cmb1, 60, 5, 134, 200, CBS_HASSTRINGS | CBS_AUTOHSCROLL | CBS_DROPDOWN | WS_BORDER | WS_VSCROLL | WS_TABSTOP
    PUSHBUTTON "&...", psh1, 195, 5, 15, 14
    LTEXT "Wartość &łańcucha:", -1, 5, 27, 54, 16
    EDITTEXT edt1, 60, 25, 190, 45, ES_WANTRETURN | ES_AUTOVSCROLL | ES_MULTILINE | WS_VSCROLL
    AUTOCHECKBOX "&Zamień ""\\r\\n"" with ""\\n""", chx1, 60, 75, 190, 14
    DEFPUSHBUTTON "OK", IDOK, 125, 95, 60, 14
    PUSHBUTTON "Anuluj", IDCANCEL, 190, 95, 60, 14
}

IDD_STRINGS DIALOG 0, 0, 325, 160
CAPTION "Tabela Łańcucha"
STYLE WS_POPUPWINDOW | WS_CAPTION | WS_THICKFRAME
FONT 9, "MS Shell Dlg"
{
    LTEXT "Wpisy ł&ańcucha:", -1, 5, 7, 100, 12
    CONTROL "", lst1, "SysListView32", LVS_NOSORTHEADER | LVS_AUTOARRANGE | LVS_NOLABELWRAP | LVS_SHOWSELALWAYS | LVS_SINGLESEL | LVS_REPORT | WS_BORDER | WS_VSCROLL | WS_HSCROLL | WS_TABSTOP, 5, 20, 315, 115
    PUSHBUTTON "&Dodaj...", psh1, 130, 3, 60, 14
    PUSHBUTTON "&Modyfikuj...", psh2, 195, 3, 60, 14
    PUSHBUTTON "&Usuń", psh3, 260, 3, 60, 14
    DEFPUSHBUTTON "OK", IDOK, 195, 140, 60, 14
    PUSHBUTTON "Anuluj", IDCANCEL, 260, 140, 60, 14
    PUSHBUTTON "Usuń &wszystko", psh4, 5, 140, 75, 14
}

IDD_ADDMITEM DIALOG 0, 0, 210, 200
CAPTION "Dodawanie elementu Menu"
STYLE DS_MODALFRAME | WS_POPUPWINDOW | WS_CAPTION
FONT 9, "MS Shell Dlg"
{
    LTEXT "Opi&s:", -1, 5, 7, 55, 12
    COMBOBOX cmb1, 65, 6, 140, 200, CBS_AUTOHSCROLL | CBS_DROPDOWN | WS_BORDER | WS_VSCROLL | WS_TABSTOP
    LTEXT "&ID polecenia:", -1, 5, 32, 55, 12
    COMBOBOX cmb2, 65, 30, 125, 200, CBS_AUTOHSCROLL | CBS_DROPDOWN | WS_BORDER | WS_VSCROLL | WS_TABSTOP
    PUSHBUTTON "&...", psh1, 190, 30, 15, 14
    AUTOCHECKBOX "&GRAYED", chx1, 5, 60, 60, 14
    AUTOCHECKBOX "&BITMAP", chx3, 135, 60, 60, 14
    AUTOCHECKBOX "&OWNERDRAW", chx4, 5, 80, 65, 14
    AUTOCHECKBOX "&CHECKED", chx5, 75, 80, 60, 14
    AUTOCHECKBOX "SE&PARATOR", chx6, 140, 80, 60, 14
    AUTOCHECKBOX "MENU&BARBREAK", chx7, 5, 100, 75, 14
    AUTOCHECKBOX "MENUB&REAK", chx8, 85, 100, 70, 14
    AUTOCHECKBOX "&DEFAULT", chx9, 5, 120, 60, 14
    AUTOCHECKBOX "&HILITE", chx10, 70, 120, 60, 14
    AUTOCHECKBOX "RADIOCHEC&K", chx11, 135, 120, 60, 14
    AUTOCHECKBOX "RIGH&TORDER", chx12, 5, 139, 60, 14
    AUTOCHECKBOX "RIGHT&JUSTIFY", chx13, 70, 140, 70, 14
    LTEXT "ID &pomocy:", -1, 5, 162, 45, 12
    COMBOBOX cmb3, 55, 160, 100, 300, CBS_AUTOHSCROLL | CBS_DROPDOWN | WS_BORDER | WS_VSCROLL | WS_TABSTOP
    DEFPUSHBUTTON "OK", IDOK, 80, 180, 60, 14
    PUSHBUTTON "Anuluj", IDCANCEL, 145, 180, 60, 14
}

IDD_MODIFYMITEM DIALOG 0, 0, 210, 200
CAPTION "Modyfikowanie elementu Menu"
STYLE DS_MODALFRAME | WS_POPUPWINDOW | WS_CAPTION
FONT 9, "MS Shell Dlg"
{
    LTEXT "Opi&s:", -1, 5, 7, 55, 12
    COMBOBOX cmb1, 65, 6, 140, 200, CBS_AUTOHSCROLL | CBS_DROPDOWN | WS_BORDER | WS_VSCROLL | WS_TABSTOP
    LTEXT "&ID polecenia:", -1, 5, 32, 55, 12
    COMBOBOX cmb2, 65, 30, 125, 200, CBS_AUTOHSCROLL | CBS_DROPDOWN | WS_BORDER | WS_VSCROLL | WS_TABSTOP
    PUSHBUTTON "&...", psh1, 190, 30, 15, 14
    AUTOCHECKBOX "&GRAYED", chx1, 5, 60, 60, 14
    AUTOCHECKBOX "&BITMAP", chx3, 135, 60, 60, 14
    AUTOCHECKBOX "&OWNERDRAW", chx4, 5, 80, 65, 14
    AUTOCHECKBOX "&CHECKED", chx5, 75, 80, 60, 14
    AUTOCHECKBOX "SE&PARATOR", chx6, 140, 80, 60, 14
    AUTOCHECKBOX "MENU&BARBREAK", chx7, 5, 100, 75, 14
    AUTOCHECKBOX "MENUB&REAK", chx8, 85, 100, 70, 14
    AUTOCHECKBOX "&DEFAULT", chx9, 5, 120, 60, 14
    AUTOCHECKBOX "&HILITE", chx10, 70, 120, 60, 14
    AUTOCHECKBOX "RADIOCHEC&K", chx11, 135, 120, 60, 14
    AUTOCHECKBOX "RIGH&TORDER", chx12, 5, 139, 60, 14
    AUTOCHECKBOX "RIGHT&JUSTIFY", chx13, 70, 140, 70, 14
    LTEXT "ID &pomocy:", -1, 5, 162, 45, 12
    COMBOBOX cmb3, 55, 160, 100, 300, CBS_AUTOHSCROLL | CBS_DROPDOWN | WS_BORDER | WS_VSCROLL | WS_TABSTOP
    DEFPUSHBUTTON "OK", IDOK, 80, 180, 60, 14
    PUSHBUTTON "Anuluj", IDCANCEL, 145, 180, 60, 14
}

IDD_EDITMENU DIALOG 0, 0, 325, 160
CAPTION "Edytowanie Zasobu Menu"
STYLE WS_POPUPWINDOW | WS_CAPTION | WS_THICKFRAME
FONT 9, "MS Shell Dlg"
{
    LTEXT "&Zasób menu:", -1, 5, 7, 85, 12
    CONTROL "", lst1, "SysListView32", LVS_NOSORTHEADER | LVS_AUTOARRANGE | LVS_NOLABELWRAP | LVS_SHOWSELALWAYS | LVS_SINGLESEL | LVS_REPORT | WS_BORDER | WS_VSCROLL | WS_HSCROLL | WS_TABSTOP, 5, 20, 315, 115
    PUSHBUTTON "D&odaj...", psh1, 95, 3, 50, 14
    PUSHBUTTON "&Modyfikuj...", psh2, 150, 3, 50, 14
    PUSHBUTTON "&Usuń", psh3, 205, 3, 50, 14
    PUSHBUTTON "&Góra", psh4, 5, 140, 40, 14
    PUSHBUTTON "&Dół", psh5, 50, 140, 40, 14
    PUSHBUTTON "&Lewa", psh6, 95, 140, 40, 14
    PUSHBUTTON "&Prawa", psh7, 140, 140, 41, 14
    AUTOCHECKBOX "Ro&zszerzone", chx1, 260, 3, 60, 14
    DEFPUSHBUTTON "OK", IDOK, 195, 140, 60, 14
    PUSHBUTTON "Anuluj", IDCANCEL, 260, 140, 60, 14
}

IDD_DLGPROP DIALOG 0, 0, 235, 315
CAPTION "Właściwości Okna Dialogowego"
STYLE DS_MODALFRAME | WS_POPUPWINDOW | WS_CAPTION
FONT 9, "MS Shell Dlg"
{
    LTEXT "Opi&s:", -1, 5, 7, 85, 11
    COMBOBOX cmb1, 5, 20, 225, 300, CBS_HASSTRINGS | CBS_AUTOHSCROLL | CBS_DROPDOWN | WS_BORDER | WS_VSCROLL | WS_TABSTOP
    AUTOCHECKBOX "Rozszerzone &okno", chx1, 100, 5, 86, 14
    LTEXT "&Lewa:", -1, 5, 40, 33, 10
    EDITTEXT edt1, 5, 53, 30, 14, ES_NUMBER | ES_RIGHT
    CONTROL "", scr1, "msctls_updown32", UDS_NOTHOUSANDS | UDS_ARROWKEYS | UDS_AUTOBUDDY | UDS_ALIGNRIGHT | UDS_SETBUDDYINT, 23, 53, 12, 20
    LTEXT "&Góra:", -1, 50, 40, 33, 10
    EDITTEXT edt2, 50, 53, 30, 14, ES_NUMBER | ES_RIGHT
    CONTROL "", scr2, "msctls_updown32", UDS_NOTHOUSANDS | UDS_ARROWKEYS | UDS_AUTOBUDDY | UDS_ALIGNRIGHT | UDS_SETBUDDYINT, 53, 53, 12, 20
    LTEXT "S&zerokość:", -1, 95, 40, 33, 10
    EDITTEXT edt3, 95, 53, 30, 14, ES_NUMBER | ES_RIGHT
    CONTROL "", scr3, "msctls_updown32", UDS_NOTHOUSANDS | UDS_ARROWKEYS | UDS_AUTOBUDDY | UDS_ALIGNRIGHT | UDS_SETBUDDYINT, 129, 56, 12, 20
    LTEXT "&Wysokość:", -1, 142, 40, 33, 10
    EDITTEXT edt4, 142, 53, 30, 14, ES_NUMBER | ES_RIGHT
    CONTROL "", scr4, "msctls_updown32", UDS_NOTHOUSANDS | UDS_ARROWKEYS | UDS_AUTOBUDDY | UDS_ALIGNRIGHT | UDS_SETBUDDYINT, 162, 53, 12, 20
    LTEXT "Nazwa k&lasy:", -1, 5, 73, 85, 11
    COMBOBOX cmb2, 5, 88, 115, 200, CBS_HASSTRINGS | CBS_AUTOHSCROLL | CBS_DROPDOWN | WS_BORDER | WS_VSCROLL | WS_TABSTOP
    LTEXT "ID p&omocy:", -1, 125, 73, 64, 11
    COMBOBOX cmb3, 125, 88, 65, 200, CBS_HASSTRINGS | CBS_AUTOHSCROLL | CBS_DROPDOWN | WS_BORDER | WS_VSCROLL | WS_TABSTOP
    LTEXT "Nazwa &czcionki:", -1, 5, 105, 80, 11
    COMBOBOX cmb4, 6, 118, 100, 200, CBS_HASSTRINGS | CBS_SORT | CBS_AUTOHSCROLL | CBS_DROPDOWN | WS_BORDER | WS_VSCROLL | WS_TABSTOP
    LTEXT "&Rozmiar:", -1, 110, 105, 38, 12
    EDITTEXT edt5, 110, 118, 25, 14, ES_NUMBER
    AUTOCHECKBOX "&B", chx2, 140, 118, 20, 14
    AUTOCHECKBOX "&I", chx3, 165, 118, 20, 14
    LTEXT "Cha&rSet:", -1, 5, 138, 80, 11
    COMBOBOX cmb5, 5, 148, 100, 100, CBS_AUTOHSCROLL | CBS_DROPDOWNLIST | WS_VSCROLL | WS_TABSTOP
    LTEXT "Nazwa &menu:", -1, 110, 138, 55, 11
    COMBOBOX cmb6, 110, 148, 99, 300, CBS_HASSTRINGS | CBS_AUTOHSCROLL | CBS_DROPDOWN | WS_BORDER | WS_VSCROLL | WS_TABSTOP
    LTEXT "S&tyl:", -1, 5, 168, 45, 11
    RTEXT "0x", -1, 52, 169, 10, 11
    EDITTEXT edt6, 67, 165, 45, 14, ES_AUTOHSCROLL
    LISTBOX lst1, 5, 183, 110, 110, LBS_DISABLENOSCROLL | LBS_NOINTEGRALHEIGHT | LBS_HASSTRINGS | LBS_MULTIPLESEL | WS_VSCROLL | WS_HSCROLL | WS_TABSTOP
    LTEXT "&ExStyle:", -1, 120, 168, 48, 11
    RTEXT "0x", -1, 170, 169, 10, 11
    EDITTEXT edt7, 185, 165, 45, 14, ES_AUTOHSCROLL
    LISTBOX lst2, 120, 183, 110, 110, LBS_DISABLENOSCROLL | LBS_NOINTEGRALHEIGHT | LBS_HASSTRINGS | LBS_MULTIPLESEL | WS_VSCROLL | WS_HSCROLL | WS_TABSTOP
    DEFPUSHBUTTON "OK", IDOK, 106, 298, 60, 14
    PUSHBUTTON "Anuluj", IDCANCEL, 171, 298, 60, 14
}

IDD_CTRLPROP DIALOG 0, 0, 235, 330
CAPTION "Właściwości formantu (Control)"
STYLE DS_MODALFRAME | WS_POPUPWINDOW | WS_CAPTION
FONT 9, "MS Shell Dlg"
{
    LTEXT "Predef. &Ctrl:", -1, 5, 7, 68, 12
    COMBOBOX cmb1, 75, 5, 120, 55, CBS_HASSTRINGS | CBS_AUTOHSCROLL | CBS_DROPDOWN | WS_BORDER | WS_VSCROLL | WS_TABSTOP
    CONTROL "", ctl1, "ToolbarWindow32", TBSTYLE_FLAT | TBSTYLE_WRAPABLE | TBSTYLE_TOOLTIPS | CCS_NODIVIDER | CCS_NORESIZE, 5, 22, 185, 30
    LTEXT "Opi&s:", -1, 5, 55, 75, 12
    COMBOBOX cmb2, 5, 65, 195, 300, CBS_HASSTRINGS | CBS_AUTOHSCROLL | CBS_DROPDOWN | WS_BORDER | WS_VSCROLL | WS_TABSTOP
    PUSHBUTTON "&OLE...", psh2, 205, 65, 25, 14
    LTEXT "&Lewa:", -1, 5, 85, 33, 11
    EDITTEXT edt1, 5, 99, 25, 14, ES_NUMBER | ES_RIGHT
    CONTROL "", scr1, "msctls_updown32", UDS_NOTHOUSANDS | UDS_ARROWKEYS | UDS_AUTOBUDDY | UDS_ALIGNRIGHT | UDS_SETBUDDYINT, 20, 99, 12, 20
    LTEXT "&G&óra:", -1, 40, 85, 33, 11
    EDITTEXT edt2, 40, 99, 25, 14, ES_NUMBER | ES_RIGHT
    CONTROL "", scr2, "msctls_updown32", UDS_NOTHOUSANDS | UDS_ARROWKEYS | UDS_AUTOBUDDY | UDS_ALIGNRIGHT | UDS_SETBUDDYINT, 55, 99, 12, 20
    LTEXT "S&zerokość:", -1, 75, 85, 33, 11
    EDITTEXT edt3, 75, 99, 25, 14, ES_NUMBER | ES_RIGHT
    CONTROL "", scr3, "msctls_updown32", UDS_NOTHOUSANDS | UDS_ARROWKEYS | UDS_AUTOBUDDY | UDS_ALIGNRIGHT | UDS_SETBUDDYINT, 90, 99, 12, 20
    LTEXT "&Wysokość:", -1, 111, 85, 33, 11
    EDITTEXT edt4, 110, 99, 25, 14, ES_NUMBER | ES_RIGHT
    CONTROL "", scr4, "msctls_updown32", UDS_NOTHOUSANDS | UDS_ARROWKEYS | UDS_AUTOBUDDY | UDS_ALIGNRIGHT | UDS_SETBUDDYINT, 125, 99, 12, 20
    LTEXT "&ID:", -1, 150, 85, 70, 12
    COMBOBOX cmb3, 150, 99, 80, 300, CBS_HASSTRINGS | CBS_AUTOHSCROLL | CBS_DROPDOWN | WS_BORDER | WS_VSCROLL | WS_TABSTOP
    LTEXT "Window Cla&ss Name:", -1, 5, 119, 100, 12
    COMBOBOX cmb4, 5, 133, 115, 200, CBS_HASSTRINGS | CBS_AUTOHSCROLL | CBS_DROPDOWN | WS_BORDER | WS_VSCROLL | WS_TABSTOP
    LTEXT "ID &pomocy:", -1, 125, 119, 70, 12
    COMBOBOX cmb5, 125, 133, 65, 200, CBS_HASSTRINGS | CBS_AUTOHSCROLL | CBS_DROPDOWN | WS_BORDER | WS_VSCROLL | WS_TABSTOP
    LTEXT "S&tyle:", -1, 5, 153, 45, 12
    RTEXT "0x", -1, 54, 153, 10, 12
    EDITTEXT edt6, 70, 151, 45, 14, ES_AUTOHSCROLL
    LISTBOX lst1, 5, 167, 110, 120, LBS_DISABLENOSCROLL | LBS_NOINTEGRALHEIGHT | LBS_HASSTRINGS | LBS_MULTIPLESEL | WS_VSCROLL | WS_HSCROLL | WS_TABSTOP
    LTEXT "&ExStyle:", -1, 120, 153, 50, 12
    RTEXT "0x", -1, 172, 153, 10, 12
    EDITTEXT edt7, 185, 151, 45, 14, ES_AUTOHSCROLL
    LISTBOX lst2, 120, 167, 110, 120, LBS_DISABLENOSCROLL | LBS_NOINTEGRALHEIGHT | LBS_HASSTRINGS | LBS_MULTIPLESEL | WS_VSCROLL | WS_HSCROLL | WS_TABSTOP
    DEFPUSHBUTTON "OK", IDOK, 170, 293, 60, 14
    PUSHBUTTON "Anuluj", IDCANCEL, 170, 309, 60, 14
    PUSHBUTTON "&Data...", psh1, 5, 293, 90, 14
    PUSHBUTTON "The string l&ist...", psh3, 5, 309, 90, 14
}

IDD_ADDCTRL DIALOG 0, 0, 235, 330
CAPTION "Dodawanie formantu (Control)"
STYLE DS_MODALFRAME | WS_POPUPWINDOW | WS_CAPTION
FONT 9, "MS Shell Dlg"
{
    LTEXT "Predef. &Ctrl:", -1, 5, 7, 68, 12
    COMBOBOX cmb1, 75, 5, 120, 55, CBS_HASSTRINGS | CBS_AUTOHSCROLL | CBS_DROPDOWN | WS_BORDER | WS_VSCROLL | WS_TABSTOP
    CONTROL "", ctl1, "ToolbarWindow32", TBSTYLE_FLAT | TBSTYLE_WRAPABLE | TBSTYLE_TOOLTIPS | CCS_NODIVIDER | CCS_NORESIZE, 5, 22, 185, 30
    LTEXT "Opi&s:", -1, 5, 55, 75, 12
    COMBOBOX cmb2, 5, 65, 195, 300, CBS_HASSTRINGS | CBS_AUTOHSCROLL | CBS_DROPDOWN | WS_BORDER | WS_VSCROLL | WS_TABSTOP
    PUSHBUTTON "&OLE...", psh2, 205, 65, 25, 14
    LTEXT "&Lewa:", -1, 5, 85, 33, 11
    EDITTEXT edt1, 5, 99, 25, 14, ES_NUMBER | ES_RIGHT
    CONTROL "", scr1, "msctls_updown32", UDS_NOTHOUSANDS | UDS_ARROWKEYS | UDS_AUTOBUDDY | UDS_ALIGNRIGHT | UDS_SETBUDDYINT, 20, 99, 12, 20
    LTEXT "&G&óra:", -1, 40, 85, 33, 11
    EDITTEXT edt2, 40, 99, 25, 14, ES_NUMBER | ES_RIGHT
    CONTROL "", scr2, "msctls_updown32", UDS_NOTHOUSANDS | UDS_ARROWKEYS | UDS_AUTOBUDDY | UDS_ALIGNRIGHT | UDS_SETBUDDYINT, 55, 99, 12, 20
    LTEXT "S&zerokość:", -1, 75, 85, 33, 11
    EDITTEXT edt3, 75, 99, 25, 14, ES_NUMBER | ES_RIGHT
    CONTROL "", scr3, "msctls_updown32", UDS_NOTHOUSANDS | UDS_ARROWKEYS | UDS_AUTOBUDDY | UDS_ALIGNRIGHT | UDS_SETBUDDYINT, 90, 99, 12, 20
    LTEXT "&Wysokość:", -1, 111, 85, 33, 11
    EDITTEXT edt4, 110, 99, 25, 14, ES_NUMBER | ES_RIGHT
    CONTROL "", scr4, "msctls_updown32", UDS_NOTHOUSANDS | UDS_ARROWKEYS | UDS_AUTOBUDDY | UDS_ALIGNRIGHT | UDS_SETBUDDYINT, 125, 99, 12, 20
    LTEXT "&ID:", -1, 150, 85, 70, 12
    COMBOBOX cmb3, 150, 99, 80, 300, CBS_HASSTRINGS | CBS_AUTOHSCROLL | CBS_DROPDOWN | WS_BORDER | WS_VSCROLL | WS_TABSTOP
    LTEXT "Window Cla&ss Name:", -1, 5, 119, 100, 12
    COMBOBOX cmb4, 5, 133, 115, 200, CBS_HASSTRINGS | CBS_AUTOHSCROLL | CBS_DROPDOWN | WS_BORDER | WS_VSCROLL | WS_TABSTOP
    LTEXT "ID &pomocy:", -1, 125, 119, 70, 12
    COMBOBOX cmb5, 125, 133, 65, 200, CBS_HASSTRINGS | CBS_AUTOHSCROLL | CBS_DROPDOWN | WS_BORDER | WS_VSCROLL | WS_TABSTOP
    LTEXT "S&tyle:", -1, 5, 153, 45, 12
    RTEXT "0x", -1, 54, 153, 10, 12
    EDITTEXT edt6, 70, 151, 45, 14, ES_AUTOHSCROLL
    LISTBOX lst1, 5, 167, 110, 120, LBS_DISABLENOSCROLL | LBS_NOINTEGRALHEIGHT | LBS_HASSTRINGS | LBS_MULTIPLESEL | WS_VSCROLL | WS_HSCROLL | WS_TABSTOP
    LTEXT "&ExStyle:", -1, 120, 153, 50, 12
    RTEXT "0x", -1, 172, 153, 10, 12
    EDITTEXT edt7, 185, 151, 45, 14, ES_AUTOHSCROLL
    LISTBOX lst2, 120, 167, 110, 120, LBS_DISABLENOSCROLL | LBS_NOINTEGRALHEIGHT | LBS_HASSTRINGS | LBS_MULTIPLESEL | WS_VSCROLL | WS_HSCROLL | WS_TABSTOP
    DEFPUSHBUTTON "OK", IDOK, 170, 293, 60, 14
    PUSHBUTTON "Anuluj", IDCANCEL, 170, 309, 60, 14
    PUSHBUTTON "&Data...", psh1, 5, 293, 90, 14
    PUSHBUTTON "The string l&ist...", psh3, 5, 309, 90, 14
}

IDD_IDASSOC DIALOG 0, 0, 200, 220
CAPTION "Skojarzenia identyfikatorów ID"
STYLE DS_MODALFRAME | WS_POPUPWINDOW | WS_CAPTION
FONT 9, "MS Shell Dlg"
{
    LTEXT "&Skojarzenia identyfikatorów:", -1, 5, 5, 116, 12
    CONTROL "", lst1, "SysListView32", LVS_SHOWSELALWAYS | LVS_SINGLESEL | LVS_REPORT | WS_BORDER | WS_TABSTOP, 5, 20, 190, 150
    PUSHBUTTON "&Resetuj wszystko", psh2, 5, 175, 85, 14
    PUSHBUTTON "&Modyfikuj", psh1, 135, 175, 60, 14
    DEFPUSHBUTTON "OK", IDOK, 70, 200, 60, 14
    PUSHBUTTON "Anuluj", IDCANCEL, 135, 200, 60, 14
}

IDD_MODIFYASSOC DIALOG 0, 0, 165, 68
CAPTION "Modyfikowanie skojarzeń identyfikatorów"
STYLE DS_MODALFRAME | WS_POPUPWINDOW | WS_CAPTION
FONT 9, "MS Shell Dlg"
{
    RTEXT "&Typ identyfikatora:", -1, 5, 7, 65, 12
    EDITTEXT edt1, 80, 5, 80, 14, WS_DISABLED
    RTEXT "&Prefiks identyfikatora:", -1, 5, 30, 65, 16
    EDITTEXT edt2, 80, 28, 80, 14, ES_AUTOHSCROLL
    DEFPUSHBUTTON "OK", IDOK, 35, 50, 60, 14
    PUSHBUTTON "Anuluj", IDCANCEL, 100, 50, 60, 14
}

IDD_IDLIST DIALOG 0, 0, 200, 300
CAPTION "Lista identyfikatorów zasobów"
STYLE WS_OVERLAPPEDWINDOW
EXSTYLE WS_EX_TOOLWINDOW
FONT 9, "MS Shell Dlg"
{
    COMBOBOX cmb1, 0, 0, 200, 300, CBS_HASSTRINGS | CBS_SORT | CBS_OWNERDRAWFIXED | CBS_DROPDOWNLIST | WS_VSCROLL | WS_TABSTOP
    CONTROL "", lst1, "SysListView32", LVS_REPORT | WS_BORDER | WS_VSCROLL | WS_HSCROLL | WS_TABSTOP, 0, 15, 200, 285
}

IDD_CONFIG DIALOG 0, 0, 210, 285
CAPTION "Konfiguracja"
STYLE DS_MODALFRAME | WS_POPUPWINDOW | WS_CAPTION
FONT 9, "MS Shell Dlg"
{
    AUTOCHECKBOX "P&okaż pełną ścieżkę do pliku na pasku tytułu", chx1, 5, 5, 200, 14
    AUTOCHECKBOX "Nie używaj identyfikatoró&w makr", chx2, 5, 25, 200, 14
    AUTOCHECKBOX "Przywróć poprzednią pozyc&ję okna", chx3, 5, 45, 200, 14
    AUTOCHECKBOX "Automatyczne załaduj najbliższy ""&resource.h""", chx4, 5, 65, 200, 14
    AUTOCHECKBOX "Automatycznie wyświetl &listę identyfikatorów zasobów", chx5, 5, 85, 200, 14
    AUTOCHECKBOX "Pokaż kro&pki w oknie edycji", chx6, 5, 105, 200, 14
    RTEXT "Wysokość Combo&Box:", -1, 10, 127, 75, 12
    EDITTEXT edt1, 90, 125, 34, 14, ES_NUMBER | ES_RIGHT
    CONTROL "", scr1, "msctls_updown32", UDS_NOTHOUSANDS | UDS_ARROWKEYS | UDS_AUTOBUDDY | UDS_ALIGNRIGHT | UDS_SETBUDDYINT, 129, 49, 12, 20
    AUTOCHECKBOX "Zawijanie &wyrazów", chx9, 130, 125, 75, 14
    AUTOCHECKBOX "Ask ""&resource.h""'s update", chx7, 5, 145, 200, 14
    AUTOCHECKBOX "Skompresuj EXE przez &UPX podczas zapisywania", chx8, 5, 165, 200, 14
    PUSHBUTTON "&Czcionki...", psh4, 5, 185, 200, 14
    PUSHBUTTON "Predefiniowane &makra...", psh1, 5, 205, 93, 14
    PUSHBUTTON "Ustaw &katalogi...", psh2, 107, 205, 98, 14
    RTEXT "Name of &OLE controls:", -1, 5, 227, 80, 12
    COMBOBOX cmb1, 90, 225, 75, 300, CBS_HASSTRINGS | CBS_AUTOHSCROLL | CBS_DROPDOWN | WS_VSCROLL | WS_TABSTOP
    AUTOCHECKBOX "Utwórz kopię &zapasową", chx10, 5, 245, 75, 15
    RTEXT "Sufiks kopii zapasowej:", -1, 90, 245, 60, 15
    COMBOBOX cmb2, 158, 244, 45, 300, CBS_HASSTRINGS | CBS_AUTOHSCROLL | CBS_DROPDOWN | WS_VSCROLL | WS_TABSTOP
    DEFPUSHBUTTON "OK", IDOK, 100, 265, 50, 14
    PUSHBUTTON "Anuluj", IDCANCEL, 155, 265, 50, 14
    PUSHBUTTON "Re&setuj wszystko", psh3, 5, 265, 75, 14
}

IDD_ADDRESID DIALOG 0, 0, 165, 90
CAPTION "Dodawania identyfikatora zasobu"
STYLE DS_MODALFRAME | WS_POPUPWINDOW | WS_CAPTION
FONT 9, "MS Shell Dlg"
{
    RTEXT "&Typ identyfikatora:", -1, 10, 7, 50, 16
    COMBOBOX cmb1, 65, 5, 95, 300, CBS_AUTOHSCROLL | CBS_DROPDOWNLIST | WS_VSCROLL | WS_TABSTOP
    RTEXT "&Nazwa identyfikatora:", -1, 10, 27, 50, 16
    EDITTEXT edt1, 65, 25, 75, 14, ES_AUTOHSCROLL
    RTEXT "&Wartość całkowita:", -1, 10, 47, 50, 16
    EDITTEXT edt2, 65, 45, 48, 14, ES_AUTOHSCROLL
    CONTROL "", scr1, "msctls_updown32", UDS_NOTHOUSANDS | UDS_ARROWKEYS | UDS_AUTOBUDDY | UDS_ALIGNRIGHT | UDS_SETBUDDYINT, 129, 49, 12, 20
    PUSHBUTTON "&Auto", psh1, 115, 45, 45, 14
    DEFPUSHBUTTON "OK", IDOK, 20, 70, 60, 14
    PUSHBUTTON "Anuluj", IDCANCEL, 85, 70, 60, 14
}

IDD_MODIFYRESID DIALOG 0, 0, 165, 90
CAPTION "Modyfikowanie identyfikatora zasobu"
STYLE DS_MODALFRAME | WS_POPUPWINDOW | WS_CAPTION
FONT 9, "MS Shell Dlg"
{
    RTEXT "&Nazwa identyfikatora:", -1, 10, 12, 50, 16, SS_REALSIZEIMAGE | NOT WS_GROUP
    EDITTEXT edt1, 65, 10, 95, 14, ES_AUTOHSCROLL
    RTEXT "&Typ identyfikatora:", -1, 10, 32, 50, 16
    EDITTEXT edt2, 65, 30, 95, 14, ES_READONLY
    RTEXT "&Wartość całkowita:", -1, 10, 52, 50, 16
    EDITTEXT edt3, 65, 50, 48, 14, ES_AUTOHSCROLL
    CONTROL "", scr1, "msctls_updown32", UDS_NOTHOUSANDS | UDS_ARROWKEYS | UDS_AUTOBUDDY | UDS_ALIGNRIGHT | UDS_SETBUDDYINT, 129, 49, 12, 20
    DEFPUSHBUTTON "OK", IDOK, 20, 70, 60, 14
    PUSHBUTTON "Anuluj", IDCANCEL, 85, 70, 60, 14
}

IDD_ADVICERESH DIALOG 0, 0, 209, 184
CAPTION "Porada dotycząca modyfikacji pliku ""resource.h"""
STYLE DS_MODALFRAME | WS_POPUPWINDOW | WS_CAPTION
FONT 9, "MS Shell Dlg"
{
    LTEXT "Zmień plik ""resource.h"" w następujący sposób:", -1, 10, 10, 195, 20
    EDITTEXT edt1, 10, 30, 190, 130, ES_READONLY | ES_MULTILINE
    DEFPUSHBUTTON "OK", IDOK, 140, 165, 60, 14
    PUSHBUTTON "&Wyczyść modyfikację", psh1, 10, 165, 90, 14
}

IDD_CLONEINNEWNAME DIALOG 0, 0, 215, 75
CAPTION "Klonuj w nowej nazwie"
STYLE DS_MODALFRAME | WS_POPUPWINDOW | WS_CAPTION
FONT 9, "MS Shell Dlg"
{
    LTEXT "&Typ zasobu:", -1, 5, 7, 70, 12
    COMBOBOX cmb1, 75, 5, 135, 200, CBS_HASSTRINGS | CBS_AUTOHSCROLL | CBS_DROPDOWN | WS_DISABLED | WS_BORDER | WS_VSCROLL | WS_TABSTOP
    LTEXT "&Nazwa zasobu:", -1, 5, 32, 70, 12
    COMBOBOX cmb2, 75, 30, 120, 200, CBS_HASSTRINGS | CBS_AUTOHSCROLL | CBS_DROPDOWN | WS_BORDER | WS_VSCROLL | WS_TABSTOP
    PUSHBUTTON "&...", psh1, 195, 30, 15, 14
    DEFPUSHBUTTON "OK", IDOK, 35, 55, 60, 14
    PUSHBUTTON "Anuluj", IDCANCEL, 115, 55, 60, 14
}

IDD_CLONEINNEWLANG DIALOG 0, 0, 215, 105
CAPTION "Klonuj w nowym języku"
STYLE DS_MODALFRAME | WS_POPUPWINDOW | WS_CAPTION
FONT 9, "MS Shell Dlg"
{
    LTEXT "&Typ zasobu:", -1, 5, 7, 70, 12
    COMBOBOX cmb1, 75, 5, 135, 200, CBS_HASSTRINGS | CBS_AUTOHSCROLL | CBS_DROPDOWN | WS_DISABLED | WS_BORDER | WS_VSCROLL | WS_TABSTOP
    LTEXT "&Nazwa zasobu:", -1, 5, 32, 70, 12
    COMBOBOX cmb2, 75, 30, 120, 200, CBS_HASSTRINGS | CBS_AUTOHSCROLL | CBS_DROPDOWN | WS_DISABLED | WS_BORDER | WS_VSCROLL | WS_TABSTOP
    LTEXT "&Język  zasobu:", -1, 5, 57, 70, 12
    COMBOBOX cmb3, 75, 55, 135, 200, CBS_HASSTRINGS | CBS_AUTOHSCROLL | CBS_DROPDOWN | WS_BORDER | WS_VSCROLL | WS_TABSTOP
    DEFPUSHBUTTON "OK", IDOK, 35, 85, 60, 14
    PUSHBUTTON "Anuluj", IDCANCEL, 115, 85, 60, 14
}

IDD_ITEMSEARCH DIALOG 0, 0, 171, 135
CAPTION "Szukaj"
STYLE WS_POPUPWINDOW | WS_CAPTION
FONT 9, "MS Shell Dlg"
{
    LTEXT "Szukany &tekst:", -1, 4, 10, 100, 14
    EDITTEXT edt1, 5, 25, 160, 15, ES_AUTOHSCROLL
    AUTOCHECKBOX "&Uwzględnij wielkość liter", chx1, 5, 45, 120, 18
    GROUPBOX "Kierunek", -1, 5, 65, 160, 42
    AUTORADIOBUTTON "&Góra", rad1, 15, 80, 60, 14, WS_TABSTOP
    AUTORADIOBUTTON "&Dół", rad2, 90, 80, 60, 14, WS_TABSTOP
    DEFPUSHBUTTON "&Znajdź", IDOK, 40, 115, 60, 14
    PUSHBUTTON "Anuluj", IDCANCEL, 105, 115, 60, 14
}

IDD_VERSIONINFO DIALOG 0, 0, 174, 150
CAPTION "O programie RisohEditor"
STYLE DS_MODALFRAME | WS_POPUPWINDOW | WS_CAPTION
FONT 12, "MS Shell Dlg"
{
    ICON IDI_MAIN, -1, 5, 5, 0, 0
    LTEXT "...", stc1, 30, 5, 140, 50
    CTEXT "https://katahiromz.web.fc2.com", stc2, 5, 60, 165, 12, SS_CENTERIMAGE | SS_NOTIFY | NOT WS_GROUP
    CONTROL "...", edt1, "EDIT", ES_READONLY | ES_AUTOHSCROLL | ES_AUTOVSCROLL | ES_MULTILINE | WS_BORDER | WS_VSCROLL | WS_HSCROLL, 5, 75, 165, 50
    DEFPUSHBUTTON "OK", IDOK, 55, 130, 60, 14
}

IDD_ADDMSG DIALOG 0, 0, 255, 105
CAPTION "Dodawanie wpisu komunikatu"
STYLE DS_MODALFRAME | WS_POPUPWINDOW | WS_CAPTION
FONT 9, "MS Shell Dlg"
{
    LTEXT "&ID komunikatu:", -1, 5, 7, 50, 12
    COMBOBOX cmb1, 65, 5, 134, 200, CBS_HASSTRINGS | CBS_AUTOHSCROLL | CBS_DROPDOWN | WS_BORDER | WS_VSCROLL | WS_TABSTOP
    PUSHBUTTON "&...", psh1, 200, 5, 15, 14
    LTEXT "&Wartość komunikatu:", -1, 5, 27, 80, 12
    EDITTEXT edt1, 5, 40, 245, 35, ES_WANTRETURN | ES_AUTOHSCROLL | ES_AUTOVSCROLL | ES_MULTILINE
    DEFPUSHBUTTON "OK", IDOK, 125, 85, 60, 14
    PUSHBUTTON "Anuluj", IDCANCEL, 190, 85, 60, 14
}

IDD_MODIFYMSG DIALOG 0, 0, 255, 105
CAPTION "Modyfikowanie wpisu komunikatu"
STYLE DS_MODALFRAME | WS_POPUPWINDOW | WS_CAPTION
FONT 9, "MS Shell Dlg"
{
    LTEXT "&ID komunikatu:", -1, 5, 7, 50, 12
    COMBOBOX cmb1, 65, 5, 134, 200, CBS_HASSTRINGS | CBS_AUTOHSCROLL | CBS_DROPDOWN | WS_DISABLED | WS_BORDER | WS_VSCROLL | WS_TABSTOP
    LTEXT "&Wartość komunikatu:", -1, 5, 27, 80, 12
    EDITTEXT edt1, 5, 40, 245, 35, ES_WANTRETURN | ES_AUTOHSCROLL | ES_AUTOVSCROLL | ES_MULTILINE
    DEFPUSHBUTTON "OK", IDOK, 125, 85, 60, 14
    PUSHBUTTON "Anuluj", IDCANCEL, 190, 85, 60, 14
}

IDD_MESSAGES DIALOG 0, 0, 325, 160
CAPTION "Tabela komunikatów"
STYLE WS_POPUPWINDOW | WS_CAPTION | WS_THICKFRAME
FONT 9, "MS Shell Dlg"
{
    LTEXT "W&pisy komunikatów:", -1, 5, 7, 80, 12
    CONTROL "", lst1, "SysListView32", LVS_NOSORTHEADER | LVS_AUTOARRANGE | LVS_NOLABELWRAP | LVS_SHOWSELALWAYS | LVS_SINGLESEL | LVS_REPORT | WS_BORDER | WS_VSCROLL | WS_HSCROLL | WS_TABSTOP, 5, 20, 315, 115
    PUSHBUTTON "&Dodaj...", psh1, 130, 3, 60, 14
    PUSHBUTTON "&Modyfikuj...", psh2, 195, 3, 60, 14
    PUSHBUTTON "&Usuń", psh3, 260, 3, 60, 14
    DEFPUSHBUTTON "OK", IDOK, 195, 140, 60, 14
    PUSHBUTTON "Anuluj", IDCANCEL, 260, 140, 60, 14
    PUSHBUTTON "Usuń &wszystko", psh4, 5, 140, 75, 14
}

IDD_FONTS DIALOG 0, 0, 195, 110
CAPTION "Ustawienia czcionki"
STYLE DS_MODALFRAME | WS_POPUPWINDOW | WS_CAPTION
FONT 9, "MS Shell Dlg"
{
    RTEXT "Ź&ródło:", -1, 5, 5, 55, 15, SS_CENTERIMAGE | NOT WS_GROUP
    EDITTEXT edt1, 65, 5, 100, 14, ES_READONLY | ES_AUTOHSCROLL
    PUSHBUTTON "...", psh1, 170, 5, 19, 14
    RTEXT "&Binarny:", -1, 5, 25, 55, 15, SS_CENTERIMAGE | NOT WS_GROUP
    EDITTEXT edt2, 65, 25, 100, 14, ES_READONLY | ES_AUTOHSCROLL
    PUSHBUTTON "...", psh2, 170, 25, 19, 14
    GROUPBOX "Podgląd", -1, 5, 45, 185, 39
    CTEXT "Źródło", stc1, 15, 55, 80, 25, SS_CENTERIMAGE | NOT WS_GROUP
    CTEXT "Binarny", stc2, 100, 55, 85, 25, SS_CENTERIMAGE | NOT WS_GROUP
    DEFPUSHBUTTON "OK", IDOK, 65, 90, 60, 14
    PUSHBUTTON "Anuluj", IDCANCEL, 130, 90, 60, 14
}

IDD_MACROS DIALOG 0, 0, 265, 165
CAPTION "Predefiniowane Makra"
STYLE WS_POPUPWINDOW | WS_CAPTION | WS_THICKFRAME
FONT 9, "MS Shell Dlg"
{
    LTEXT "Predefiniowane &Makra:", -1, 5, 0, 100, 15, SS_CENTERIMAGE | NOT WS_GROUP
    CONTROL "", lst1, "SysListView32", LVS_EDITLABELS | LVS_SHOWSELALWAYS | LVS_SINGLESEL | LVS_REPORT | WS_BORDER | WS_TABSTOP, 5, 15, 190, 125
    PUSHBUTTON "&Dodaj...", psh1, 200, 15, 60, 14
    PUSHBUTTON "&Edytuj...", psh2, 200, 35, 60, 14
    PUSHBUTTON "&Usuń", psh3, 200, 55, 60, 14
    PUSHBUTTON "Usuń &wszystko", psh7, 200, 105, 60, 14
    DEFPUSHBUTTON "OK", IDOK, 135, 145, 60, 14
    PUSHBUTTON "Anuluj", IDCANCEL, 200, 145, 60, 14
    PUSHBUTTON "&Resetuj wszystko", psh6, 5, 145, 60, 14
}

IDD_ADDMACRO DIALOG 0, 0, 190, 80
CAPTION "Dodawanie Predefiniowanego Makra"
STYLE DS_MODALFRAME | WS_POPUPWINDOW | WS_CAPTION
FONT 9, "MS Shell Dlg"
{
    RTEXT "&Klucz:", -1, 5, 12, 60, 14
    COMBOBOX cmb1, 70, 10, 110, 200, CBS_DROPDOWN | WS_BORDER | WS_VSCROLL | WS_TABSTOP
    RTEXT "&Wartość:", -1, 5, 37, 60, 14
    COMBOBOX cmb2, 70, 35, 110, 300, CBS_DROPDOWN | WS_BORDER | WS_VSCROLL | WS_TABSTOP
    DEFPUSHBUTTON "OK", IDOK, 60, 60, 60, 14
    PUSHBUTTON "Anuluj", IDCANCEL, 125, 60, 60, 14
}

IDD_EDITMACRO DIALOG 0, 0, 190, 80
CAPTION "Edytowanie Predefiniowanego Makra"
STYLE DS_MODALFRAME | WS_POPUPWINDOW | WS_CAPTION
FONT 9, "MS Shell Dlg"
{
    RTEXT "&Klucz:", -1, 5, 12, 60, 14
    COMBOBOX cmb1, 70, 10, 110, 200, CBS_DROPDOWN | WS_DISABLED | WS_BORDER | WS_VSCROLL | WS_TABSTOP
    RTEXT "&Wartość:", -1, 5, 37, 60, 14
    COMBOBOX cmb2, 70, 35, 110, 300, CBS_DROPDOWN | WS_BORDER | WS_VSCROLL | WS_TABSTOP
    DEFPUSHBUTTON "OK", IDOK, 60, 60, 60, 14
    PUSHBUTTON "Anuluj", IDCANCEL, 125, 60, 60, 14
}

IDD_CTRLDATA DIALOG 0, 0, 190, 130
CAPTION "Edit Control Data"
STYLE DS_MODALFRAME | WS_POPUPWINDOW | WS_CAPTION
FONT 9, "MS Shell Dlg"
{
    LTEXT "&Binary Data:", -1, 5, 2, 87, 12
    EDITTEXT edt1, 5, 15, 180, 60, ES_AUTOVSCROLL | ES_MULTILINE | WS_VSCROLL
    LTEXT "You can set the control data by space-separated 16-bit integers.", -1, 5, 80, 180, 25
    DEFPUSHBUTTON "OK", IDOK, 60, 110, 60, 14
    PUSHBUTTON "Cancel", IDCANCEL, 125, 110, 60, 14
}

IDD_PATHS DIALOG 0, 0, 295, 220
CAPTION "Ustawienia katalogów/ścieżek"
STYLE WS_POPUPWINDOW | WS_CAPTION | WS_THICKFRAME
FONT 9, "MS Shell Dlg"
{
    LTEXT "&Uwzględnij katalogi:", -1, 5, 5, 102, 12
    LISTBOX lst1, 5, 20, 220, 105, LBS_NOINTEGRALHEIGHT | LBS_HASSTRINGS | LBS_SORT | WS_VSCROLL | WS_HSCROLL | WS_TABSTOP
    PUSHBUTTON "D&odaj...", psh1, 230, 20, 60, 14
    PUSHBUTTON "&Edytuj...", psh2, 230, 40, 60, 14
    PUSHBUTTON "&Usuń", psh3, 230, 60, 60, 14
    PUSHBUTTON "&Góra", psh4, 230, 80, 60, 14
    PUSHBUTTON "&Dół", psh5, 230, 100, 60, 14
    PUSHBUTTON "Usuń &wszystko", psh6, 5, 130, 95, 14
    RTEXT "&windres.exe:", stc1, 5, 157, 55, 12
    COMBOBOX cmb1, 70, 155, 155, 300, CBS_HASSTRINGS | CBS_AUTOHSCROLL | CBS_DROPDOWN | WS_VSCROLL | WS_TABSTOP
    PUSHBUTTON "&Przeglądaj...", psh7, 230, 155, 60, 14
    RTEXT "&cpp.exe:", stc2, 5, 177, 55, 12
    COMBOBOX cmb2, 70, 175, 155, 300, CBS_HASSTRINGS | CBS_AUTOHSCROLL | CBS_DROPDOWN | WS_VSCROLL | WS_TABSTOP
    PUSHBUTTON "Przeg&lądaj...", psh8, 230, 175, 60, 14
    DEFPUSHBUTTON "OK", IDOK, 165, 200, 60, 14
    PUSHBUTTON "Anuluj", IDCANCEL, 230, 200, 60, 14
    PUSHBUTTON "&Resetuj wszystko", psh9, 5, 200, 95, 14
}

IDD_EXP_OPTIONS DIALOG 0, 0, 250, 225
CAPTION "Opcje eksportu"
STYLE DS_MODALFRAME | WS_POPUPWINDOW | WS_CAPTION
FONT 9, "MS Shell Dlg"
{
    ICON IDI_MAIN, -1, 5, 10, 0, 0
    LTEXT "Eksportowanie pliku RC wygeneruje kilka powiązanych plików. Możesz wybrać następujące opcje:", -1, 35, 5, 210, 29
    AUTOCHECKBOX "Use Microsoft MESSAGE&TABLE", chx8, 5, 40, 240, 14
    AUTOCHECKBOX "Oddziel pliki zasobów według &języka", chx1, 5, 60, 240, 14
    AUTOCHECKBOX "Użyj słów kluczowych B&EGIN/END POCZĄTEK/KONIEC", chx2, 5, 80, 240, 14
    AUTOCHECKBOX "Wybierz język za pomocą makra LANGUAGE_*", chx3, 5, 100, 240, 14
    AUTOCHECKBOX "Utwórz &kopię", chx4, 5, 120, 110, 14
    RTEXT "sufiksu kopii zapasowej:", -1, 120, 122, 75, 12
    COMBOBOX cmb1, 200, 120, 45, 300, CBS_HASSTRINGS | CBS_AUTOHSCROLL | CBS_DROPDOWN | WS_VSCROLL | WS_TABSTOP
    AUTOCHECKBOX "Output redundant &comments", chx5, 5, 140, 240, 14
    AUTOCHECKBOX "Wrap the ma&nifest statements by #ifndef MSVC ... #endif", chx6, 5, 160, 240, 14
    AUTOCHECKBOX "Wyjściowe pliki RC jako &UTF-16", chx7, 5, 180, 240, 14
    DEFPUSHBUTTON "OK", IDOK, 120, 205, 60, 14
    PUSHBUTTON "Anuluj", IDCANCEL, 185, 205, 60, 14
}

IDD_LANGS DIALOG 0, 0, 250, 235
CAPTION "Języki"
STYLE WS_POPUPWINDOW | WS_CAPTION | WS_THICKFRAME
FONT 9, "MS Shell Dlg"
{
    CONTROL "", lst1, "SysListView32", LVS_SHOWSELALWAYS | LVS_SINGLESEL | LVS_REPORT | WS_BORDER | WS_TABSTOP, 5, 5, 240, 179
    RTEXT "&Szukaj:", stc1, 5, 192, 45, 12
    COMBOBOX cmb1, 55, 190, 85, 300, CBS_SORT | CBS_DROPDOWN | WS_VSCROLL | WS_TABSTOP
    EDITTEXT edt1, 4, 209, 240, 20, ES_AUTOHSCROLL | ES_AUTOVSCROLL | ES_MULTILINE
}

IDD_CHILD DIALOG 0, 0, 215, 135
CAPTION "Okno dialogowe podrzędne"
STYLE WS_CHILD | WS_OVERLAPPEDWINDOW
FONT 9, "MS Shell Dlg"
{
    DEFPUSHBUTTON "OK", IDOK, 35, 115, 60, 14
    PUSHBUTTON "Anuluj", IDCANCEL, 115, 115, 60, 14
}

IDD_DLGINITEDIT DIALOG 0, 0, 325, 165
CAPTION "Edytowanie DLGINIT"
STYLE WS_POPUPWINDOW | WS_CAPTION | WS_THICKFRAME
FONT 9, "MS Shell Dlg"
{
    LTEXT "&Wpisy komunikatów:", -1, 5, 7, 100, 12
    CONTROL "", lst1, "SysListView32", LVS_NOSORTHEADER | LVS_AUTOARRANGE | LVS_NOLABELWRAP | LVS_SHOWSELALWAYS | LVS_SINGLESEL | LVS_REPORT | WS_BORDER | WS_VSCROLL | WS_HSCROLL | WS_TABSTOP, 5, 20, 250, 120
    PUSHBUTTON "D&odaj...", psh1, 260, 20, 60, 14
    PUSHBUTTON "&Modyfikuj...", psh2, 260, 40, 60, 14
    PUSHBUTTON "&Usuń", psh3, 260, 60, 60, 14
    PUSHBUTTON "&Góra", psh4, 260, 100, 60, 14
    PUSHBUTTON "&Dół", psh5, 260, 120, 60, 14
    DEFPUSHBUTTON "OK", IDOK, 195, 145, 60, 14
    PUSHBUTTON "Anuluj", IDCANCEL, 260, 145, 60, 14
    PUSHBUTTON "Usuń &wszystko", psh6, 5, 145, 79, 14
}

IDD_ADDDLGINIT DIALOG 0, 0, 184, 137
CAPTION "Dodawanie danych DLGINIT"
STYLE DS_MODALFRAME | WS_POPUPWINDOW | WS_CAPTION
FONT 9, "MS Shell Dlg"
{
    LTEXT "Control &ID:", -1, 5, 7, 56, 12
    COMBOBOX cmb1, 65, 5, 115, 300, CBS_HASSTRINGS | CBS_AUTOHSCROLL | CBS_DROPDOWN | WS_VSCROLL | WS_TABSTOP
    LTEXT "&Message:", -1, 5, 32, 55, 12
    COMBOBOX cmb2, 65, 30, 95, 300, CBS_HASSTRINGS | CBS_AUTOHSCROLL | CBS_DROPDOWN | WS_VSCROLL | WS_TABSTOP
    LTEXT "&String:", -1, 5, 52, 55, 12
    EDITTEXT edt1, 5, 65, 175, 50, ES_WANTRETURN | ES_MULTILINE | WS_VSCROLL | WS_HSCROLL
    DEFPUSHBUTTON "OK", IDOK, 55, 120, 60, 14
    PUSHBUTTON "Anuluj", IDCANCEL, 120, 120, 60, 14
}

IDD_MODIFYDLGINIT DIALOG 0, 0, 184, 137
CAPTION "Modyfikowanie danych DLGINIT"
STYLE DS_MODALFRAME | WS_POPUPWINDOW | WS_CAPTION
FONT 9, "MS Shell Dlg"
{
    LTEXT "Control &ID:", -1, 5, 7, 56, 12
    COMBOBOX cmb1, 65, 5, 115, 300, CBS_HASSTRINGS | CBS_AUTOHSCROLL | CBS_DROPDOWN | WS_VSCROLL | WS_TABSTOP
    LTEXT "&Message:", -1, 5, 32, 55, 12
    COMBOBOX cmb2, 65, 30, 95, 300, CBS_HASSTRINGS | CBS_AUTOHSCROLL | CBS_DROPDOWN | WS_VSCROLL | WS_TABSTOP
    LTEXT "&String:", -1, 5, 52, 55, 12
    EDITTEXT edt1, 5, 65, 175, 50, ES_WANTRETURN | ES_MULTILINE | WS_VSCROLL | WS_HSCROLL
    DEFPUSHBUTTON "OK", IDOK, 55, 120, 60, 14
    PUSHBUTTON "Anuluj", IDCANCEL, 120, 120, 60, 14
}

IDD_STRINGLIST DIALOG 0, 0, 205, 220
CAPTION "Control String List"
STYLE WS_POPUPWINDOW | WS_CAPTION | WS_THICKFRAME
FONT 9, "MS Shell Dlg"
{
    LTEXT "", stc1, 5, 5, 195, 70
    EDITTEXT edt1, 5, 80, 195, 115, ES_WANTRETURN | ES_MULTILINE | WS_VSCROLL | WS_HSCROLL
    DEFPUSHBUTTON "OK", IDOK, 75, 200, 60, 14
    PUSHBUTTON "Anuluj", IDCANCEL, 140, 200, 60, 14
}

IDD_SAVE_OPTIONS DIALOG 0, 0, 250, 225
CAPTION "Opcje zapisywania"
STYLE DS_MODALFRAME | WS_POPUPWINDOW | WS_CAPTION
FONT 9, "MS Shell Dlg"
{
    ICON IDI_MAIN, -1, 5, 10, 0, 0
    LTEXT "Zapisanie pliku RC wygeneruje kilka powiązanych plików. Możesz wybrać następujące opcje:", -1, 35, 5, 210, 29
    AUTOCHECKBOX "Use Microsoft MESSAGE&TABLE", chx8, 5, 40, 240, 14
    AUTOCHECKBOX "Oddziel pliki zasobów według &języka", chx1, 5, 60, 240, 14
    AUTOCHECKBOX "Użyj słów kluczowych B&EGIN/END POCZĄTEK/KONIEC", chx2, 5, 80, 240, 14
    AUTOCHECKBOX "Wybierz język za pomocą makra LANGUAGE_*", chx3, 5, 100, 240, 14
    AUTOCHECKBOX "Utwórz &kopię", chx4, 5, 120, 110, 14
    RTEXT "sufiksu kopii zapasowej:", -1, 120, 122, 75, 12
    COMBOBOX cmb1, 200, 120, 45, 300, CBS_HASSTRINGS | CBS_AUTOHSCROLL | CBS_DROPDOWN | WS_VSCROLL | WS_TABSTOP
    AUTOCHECKBOX "Output redundant &comments", chx5, 5, 140, 240, 14
    AUTOCHECKBOX "Wrap the ma&nifest statements by #ifndef MSVC ... #endif", chx6, 5, 160, 240, 14
    AUTOCHECKBOX "Wyjściowe pliki RC jako &UTF-16", chx7, 5, 180, 240, 14
    DEFPUSHBUTTON "OK", IDOK, 120, 205, 60, 14
    PUSHBUTTON "Anuluj", IDCANCEL, 185, 205, 60, 14
}

IDD_ENCODING DIALOG 0, 0, 200, 170
CAPTION "Kodowanie elementu zasobu"
STYLE DS_MODALFRAME | WS_POPUPWINDOW | WS_CAPTION
FONT 9, "MS Shell Dlg"
{
    CONTROL "", lst1, "SysListView32", LVS_SHOWSELALWAYS | LVS_SINGLESEL | LVS_REPORT | WS_BORDER, 5, 5, 190, 115
    PUSHBUTTON "&Dodaj...", psh1, 5, 125, 60, 14
    PUSHBUTTON "&Modyfikuj...", psh2, 70, 125, 60, 14
    PUSHBUTTON "&Usuń", psh3, 135, 125, 60, 14
    DEFPUSHBUTTON "OK", IDOK, 70, 150, 60, 14
    PUSHBUTTON "Anuluj", IDCANCEL, 135, 150, 60, 14
    PUSHBUTTON "&Resetuj", psh5, 5, 149, 60, 14
}

IDD_ADDENC DIALOG 0, 0, 215, 80
CAPTION "Dodawanie kodowania zasobów"
STYLE DS_MODALFRAME | WS_POPUPWINDOW | WS_CAPTION
FONT 9, "MS Shell Dlg"
{
    LTEXT "&Typ zasobu:", -1, 5, 7, 70, 12
    COMBOBOX cmb1, 75, 5, 135, 200, CBS_HASSTRINGS | CBS_AUTOHSCROLL | CBS_DROPDOWN | WS_BORDER | WS_VSCROLL | WS_TABSTOP
    LTEXT "&Kodowanie:", -1, 5, 30, 70, 12
    COMBOBOX cmb2, 75, 30, 85, 300, CBS_HASSTRINGS | CBS_AUTOHSCROLL | CBS_DROPDOWNLIST | WS_VSCROLL | WS_TABSTOP
    DEFPUSHBUTTON "OK", IDOK, 86, 60, 60, 14
    PUSHBUTTON "Anuluj", IDCANCEL, 150, 60, 60, 14
}

IDD_MODIFYENC DIALOG 0, 0, 215, 80
CAPTION "Modyfikowanie kodowania zasobów"
STYLE DS_MODALFRAME | WS_POPUPWINDOW | WS_CAPTION
FONT 9, "MS Shell Dlg"
{
    LTEXT "&Typ zasobu:", -1, 5, 7, 70, 12
    COMBOBOX cmb1, 75, 5, 135, 200, CBS_HASSTRINGS | CBS_AUTOHSCROLL | CBS_DROPDOWN | WS_DISABLED | WS_BORDER | WS_VSCROLL | WS_TABSTOP
    LTEXT "&Kodowanie:", -1, 5, 30, 70, 12
    COMBOBOX cmb2, 75, 30, 85, 300, CBS_HASSTRINGS | CBS_AUTOHSCROLL | CBS_DROPDOWNLIST | WS_VSCROLL | WS_TABSTOP
    DEFPUSHBUTTON "OK", IDOK, 86, 60, 60, 14
    PUSHBUTTON "Anuluj", IDCANCEL, 150, 60, 60, 14
}

IDD_CONSTANT DIALOG 0, 0, 205, 75
CAPTION "Query Constant"
STYLE DS_MODALFRAME | WS_POPUPWINDOW | WS_CAPTION
FONT 9, "MS Shell Dlg"
{
    LTEXT "Constant &Name:", -1, 5, 7, 80, 12
    COMBOBOX cmb1, 94, 7, 105, 300, CBS_HASSTRINGS | CBS_AUTOHSCROLL | CBS_DROPDOWN | WS_VSCROLL | WS_TABSTOP
    LTEXT "Constant &Value:", -1, 5, 32, 80, 12
    EDITTEXT edt2, 95, 30, 50, 14, ES_READONLY
    EDITTEXT edt3, 150, 30, 50, 14, ES_READONLY
    DEFPUSHBUTTON "OK", IDOK, 70, 55, 60, 14
}

IDD_EGA DIALOG 0, 0, 400, 225
CAPTION "Język programowania EGA"
STYLE WS_POPUPWINDOW | WS_CAPTION | WS_THICKFRAME
FONT 9, "MS Shell Dlg"
{
    GROUPBOX "Konsola EGA", grp1, 5, 5, 390, 195
    EDITTEXT edt1, 10, 20, 380, 170, ES_READONLY | ES_AUTOVSCROLL | ES_MULTILINE | WS_VSCROLL | NOT WS_TABSTOP
    RTEXT "EGA>", stc1, 10, 208, 20, 10
    EDITTEXT edt2, 35, 205, 300, 15, ES_WANTRETURN | ES_AUTOHSCROLL | ES_AUTOVSCROLL | ES_MULTILINE
    PUSHBUTTON "&Enter", IDOK, 345, 205, 50, 15
}

IDD_FONTSUBST DIALOG 0, 0, 185, 180
CAPTION "Dialog Font Substitutes"
STYLE DS_CENTER | DS_MODALFRAME | WS_POPUPWINDOW | WS_CAPTION
FONT 9, "MS Shell Dlg"
{
    LTEXT "Czcionka #&1:", -1, 5, 7, 44, 12
    COMBOBOX cmb1, 55, 5, 125, 300, CBS_HASSTRINGS | CBS_AUTOHSCROLL | CBS_DROPDOWN | WS_VSCROLL | WS_TABSTOP
    ICON IDI_ARROW, -1, 30, 25, 0, 0
    COMBOBOX cmb2, 55, 30, 125, 300, CBS_HASSTRINGS | CBS_AUTOHSCROLL | CBS_DROPDOWN | WS_VSCROLL | WS_TABSTOP
    LTEXT "Czcionka #&2:", -1, 5, 57, 44, 12
    COMBOBOX cmb3, 55, 55, 125, 300, CBS_HASSTRINGS | CBS_AUTOHSCROLL | CBS_DROPDOWN | WS_VSCROLL | WS_TABSTOP
    ICON IDI_ARROW, -1, 30, 75, 0, 0
    COMBOBOX cmb4, 55, 80, 125, 300, CBS_HASSTRINGS | CBS_AUTOHSCROLL | CBS_DROPDOWN | WS_VSCROLL | WS_TABSTOP
    LTEXT "Czcionka #&3:", -1, 5, 105, 44, 12
    COMBOBOX cmb5, 55, 105, 125, 300, CBS_HASSTRINGS | CBS_AUTOHSCROLL | CBS_DROPDOWN | WS_VSCROLL | WS_TABSTOP
    ICON IDI_ARROW, -1, 30, 125, 0, 0
    COMBOBOX cmb6, 55, 130, 125, 300, CBS_HASSTRINGS | CBS_AUTOHSCROLL | CBS_DROPDOWN | WS_VSCROLL | WS_TABSTOP
    DEFPUSHBUTTON "OK", IDOK, 75, 160, 50, 14
    PUSHBUTTON "Anuluj", IDCANCEL, 130, 160, 50, 14
    PUSHBUTTON "&Resetuj", psh1, 5, 160, 55, 14
}

IDD_DROPDOWNPOPUP DIALOG 0, 0, 120, 150
CAPTION " "
STYLE WS_POPUP | WS_DLGFRAME | NOT WS_BORDER
FONT 9, "MS Shell Dlg"
{
    LISTBOX lst1, 0, 0, 120, 150, LBS_WANTKEYBOARDINPUT | LBS_NOINTEGRALHEIGHT | LBS_HASSTRINGS | WS_VSCROLL | WS_TABSTOP, WS_EX_CLIENTEDGE
}

IDD_DFMSETTINGS DIALOG 0, 0, 210, 135
CAPTION "Ustawienia Delphi DFM"
STYLE DS_CENTER | DS_MODALFRAME | WS_POPUPWINDOW | WS_CAPTION
FONT 9, "MS Shell Dlg"
{
    LTEXT "Poniższe ustawienia dotyczą Delphi DFM:", -1, 35, 5, 171, 20
    ICON IDI_DFMICON, -1, 5, 5, 0, 0
    RTEXT "&Strona kodowa:", -1, 6, 32, 70, 12
    COMBOBOX cmb1, 85, 30, 120, 300, CBS_HASSTRINGS | CBS_AUTOHSCROLL | CBS_DROPDOWN | WS_VSCROLL | WS_TABSTOP
    AUTOCHECKBOX "&Insert raw string comments", chx1, 5, 50, 200, 14
    AUTOCHECKBOX "Nie używaj &Unicode i UTF-8", chx2, 5, 70, 200, 14
    DEFPUSHBUTTON "OK", IDOK, 80, 115, 60, 14
    PUSHBUTTON "Anuluj", IDCANCEL, 145, 115, 60, 14
}

IDD_COPYTOMULTILANG DIALOG 0, 0, 200, 195
CAPTION "Skopiuj do wielu języków"
STYLE DS_CENTER | DS_MODALFRAME | WS_POPUPWINDOW | WS_CAPTION
FONT 9, "MS Shell Dlg"
{
    LTEXT "Dodaj języki, do których chcesz skopiować zasób:", -1, 5, 5, 190, 22
    LTEXT "&Języki:", -1, 5, 35, 82, 12
    LISTBOX lst1, 5, 50, 190, 100, LBS_WANTKEYBOARDINPUT | LBS_NOINTEGRALHEIGHT | LBS_HASSTRINGS | WS_VSCROLL | WS_TABSTOP
    COMBOBOX cmb3, 5, 155, 126, 14, CBS_HASSTRINGS | CBS_AUTOHSCROLL | CBS_DROPDOWN | WS_BORDER | WS_VSCROLL | WS_TABSTOP
    PUSHBUTTON "&Dodać", psh1, 135, 155, 60, 14
    DEFPUSHBUTTON "OK", IDOK, 5, 175, 60, 14
    PUSHBUTTON "Anuluj", IDCANCEL, 70, 175, 60, 14
}

IDD_TOOLBARRES DIALOG 0, 0, 230, 195
CAPTION "Zasób paska narzędzi"
STYLE DS_CENTER | DS_MODALFRAME | WS_POPUPWINDOW | WS_CAPTION
FONT 9, "MS Shell Dlg"
{
    RTEXT "&Szerokość ikony:", -1, 5, 5, 60, 15, SS_CENTERIMAGE | NOT WS_GROUP
    EDITTEXT edt1, 70, 5, 30, 15, ES_NUMBER | ES_RIGHT
    CONTROL "", scr1, "msctls_updown32", UDS_NOTHOUSANDS | UDS_ARROWKEYS | UDS_AUTOBUDDY | UDS_ALIGNRIGHT | UDS_SETBUDDYINT, 80, 5, 30, 15
    RTEXT "&Wysokość ikony:", -1, 110, 5, 60, 15, SS_CENTERIMAGE | NOT WS_GROUP
    EDITTEXT edt2, 180, 5, 30, 15, ES_NUMBER | ES_RIGHT
    CONTROL "", scr2, "msctls_updown32", UDS_NOTHOUSANDS | UDS_ARROWKEYS | UDS_AUTOBUDDY | UDS_ALIGNRIGHT | UDS_SETBUDDYINT, 190, 5, 30, 15
    LTEXT "&Przyciski paska narzędzi:", -1, 5, 25, 140, 15, SS_CENTERIMAGE | NOT WS_GROUP
    LISTBOX lst1, 5, 40, 140, 130, LBS_DISABLENOSCROLL | LBS_WANTKEYBOARDINPUT | LBS_NOINTEGRALHEIGHT | LBS_HASSTRINGS | LBS_OWNERDRAWFIXED | WS_VSCROLL | WS_TABSTOP
    PUSHBUTTON "&Dodać...", psh1, 150, 40, 75, 15
    PUSHBUTTON "&Modyfikować...", psh2, 150, 60, 75, 15
    PUSHBUTTON "&Usuwać", psh3, 150, 80, 75, 15
    PUSHBUTTON "&W górę", psh4, 150, 135, 75, 15
    PUSHBUTTON "&Na dół", psh5, 150, 155, 75, 15
    DEFPUSHBUTTON "OK", IDOK, 5, 175, 60, 15
    PUSHBUTTON "Anuluj", IDCANCEL, 70, 175, 60, 15
}

IDD_ADDTBBTN DIALOG 0, 0, 177, 92
CAPTION "Przycisk Dodaj pasek narzędzi"
STYLE DS_CENTER | DS_MODALFRAME | WS_POPUPWINDOW | WS_CAPTION
FONT 9, "MS Shell Dlg"
{
    LTEXT "&Identyfikator polecenia przycisku paska narzędzi:", -1, 5, 5, 160, 15, SS_CENTERIMAGE | NOT WS_GROUP
    COMBOBOX cmb1, 5, 25, 150, 150, CBS_HASSTRINGS | CBS_AUTOHSCROLL | CBS_DROPDOWN | WS_VSCROLL | WS_TABSTOP
    AUTOCHECKBOX "&Separator", chx1, 5, 45, 90, 15
    DEFPUSHBUTTON "OK", IDOK, 45, 70, 60, 15
    PUSHBUTTON "Anuluj", IDCANCEL, 110, 70, 60, 15
}

IDD_MODIFYTBBTN DIALOG 0, 0, 177, 92
CAPTION "Modify Toolbar button"
STYLE DS_CENTER | DS_MODALFRAME | WS_POPUPWINDOW | WS_CAPTION
FONT 9, "MS Shell Dlg"
{
    LTEXT "&Identyfikator polecenia przycisku paska narzędzi:", -1, 5, 5, 160, 15, SS_CENTERIMAGE | NOT WS_GROUP
    COMBOBOX cmb1, 5, 25, 150, 150, CBS_HASSTRINGS | CBS_AUTOHSCROLL | CBS_DROPDOWN | WS_VSCROLL | WS_TABSTOP
    AUTOCHECKBOX "&Separator", chx1, 5, 45, 90, 15
    DEFPUSHBUTTON "OK", IDOK, 45, 70, 60, 15
    PUSHBUTTON "Anuluj", IDCANCEL, 110, 70, 60, 15
}

//////////////////////////////////////////////////////////////////////////////
// RT_VERSION

1 VERSIONINFO
FILEVERSION     5, 7, 9, 0
PRODUCTVERSION  5, 7, 9, 0
FILEOS          0x40004
FILETYPE        0x1
FILESUBTYPE     0x0
{
    BLOCK "StringFileInfo"
    {
        BLOCK "041504E4"
        {
            VALUE "CompanyName", "Katayama Hirofumi MZ\0"
            VALUE "FileDescription", "RisohEditor\0"
            VALUE "FileVersion", "5.7.9\0"
            VALUE "LegalCopyright", "Copyright (C) 2017-2020 Katayama Hirofumi MZ. Wszelkie prawa zastrzeżone.\0"
            VALUE "ProductName", "RisohEditor\0"
            VALUE "ProductVersion", "5.7.9\0"
        }
    }
    BLOCK "VarFileInfo"
    {
        VALUE "Translation", 0x0415, 0x04E4
    }
}

//////////////////////////////////////////////////////////////////////////////
// RISOHTEMPLATE

4 RISOHTEMPLATE "res/1045_RISOHTEMPLATE_4.bin"

5 RISOHTEMPLATE "res/1045_RISOHTEMPLATE_5.bin"

//////////////////////////////////////////////////////////////////////////////
// RT_STRING

STRINGTABLE
{
    IDS_APPNAME, "RisohEditor 5.7.9 by Katayama Hirofumi MZ"
    IDS_TITLEWITHFILE, "RisohEditor 5.7.9 - Plik: %s"
    IDS_EXTRACTRES, "Wypakuj zasób"
    IDS_RESBINFILTER, "Zasoby binarne (*.res)|*.res|Pliki Binarne (*.bin)|*.bin|Wszystkie pliki (*.*)|*.*|"
    IDS_CANNOTSAVE, "Nie można zapisać."
    IDS_REPLACERES, "Zamień zasób"
    IDS_ALLFILES, "Wszystkie pliki (*.*)|*.*|"
    IDS_ENTERTYPE, "Wprowadź typ zasobu."
    IDS_ENTERNAME, "Wprowadź nazwę zasobu."
    IDS_ENTERLANG, "Wprowadź język zasobu."
    IDS_FILENOTFOUND, "Nie można odnaleźć pliku."
    IDS_CANNOTREPLACE, "Nie można zamienić."
    IDS_EXERESFILTER, "Wykonywalne (*.exe;*.dll;*.ocx;*.cpl;*.scr;*.mui)|*.exe;*.dll;*.ocx;*.cpl;*.scr;*.mui|RC Files (*.rc)|*.rc|Binary Resources (*.res)|*.res|Wszystkie pliki (*.*)|*.*|"
    IDS_SAVEAS, "Zapisz jako"
    IDS_CANNOTADDICON, "Nie można dodać ikony."
    IDS_ADDICON, "Dodaj ikonę"
    IDS_ICOFILTER, "Pliki ikon (*.ico)|*.ico|Wszystkie pliki (*.*)|*.*|"
    IDS_REPLACEICO, "Zamień ikonę"
    IDS_CANTREPLACEICO, "Nie można zamienić ikony."
    IDS_EXISTSOVERWRITE, "Element już istnieje. Nadpisać?"
    IDS_OPEN, "Otwórz"
    IDS_CANNOTOPEN, "Nie można otworzyć pliku."
    IDS_ADDBMP, "Dodaj Bitmapę"
    IDS_BMPFILTER, "Pliki map bitowych (*.bmp)|*.bmp|Obrazy PNG (*.png)|*.png|Wszystkie pliki (*.*)|*.*|"
    IDS_CANTREPLACEBMP, "Nie można zamienić bitmapy."
    IDS_REPLACEBMP, "Zamień Bitmapę"
    IDS_ERRORCODE, "Kod błędu %d"
    IDS_VERSIONINFO, "RisohEditor Wersja 5.7.9\r\n\r\nKatayama Hirofumi MZ\r\n\r\nLicencja: GPLv3 (free software)"
    IDS_ADDRES, "Dodaj zasób"
    IDS_CANNOTADDRES, "Nie można dodać zasobu."
    IDS_CANTADDBMP, "Nie można dodać bitmapy."
    IDS_EXTRACTBMP, "Wypakuj Bitmapę"
    IDS_CANTEXTRACTBMP, "Nie można wypakować bitmapy."
    IDS_CANTREPLACECUR, "Nie można zamienić kursora."
    IDS_CANNOTADDCUR, "Nie można dodać kursora."
    IDS_CURFILTER, "Kursory statyczne (*.cur)|*.cur|Kursory animowane (*.ani)|*.ani|Wszystkie pliki (*.*)|*.*|"
    IDS_ADDCUR, "Dodaj Kursor"
    IDS_REPLACECUR, "Zamień Kursor"
    IDS_EXTRACTICO, "Wypakuj Ikonę"
    IDS_CANTEXTRACTICO, "Nie można wypakować ikony."
    IDS_EXTRACTCUR, "Wypakuj Kursor"
    IDS_CANTEXTRACTCUR, "Nie można wypakować kursora."
    IDS_RESFILTER, "Zasoby Binarne (*.res)|*.res|Wszystkie pliki (*.*)|*.*|"
    IDS_NEUTRAL, "Neutralny"
    IDS_IMPORTRES, "Importuj"
    IDS_CANNOTIMPORT, "Nie można zaimportować zasobu."
    IDS_COMPILE, "Kompiluj (F8)"
    IDS_CANCELEDIT, "Anuluj edycję (Ctrl+E)"
    IDS_GUIEDIT, "Edytuj przez GUI (Ctrl+G)"
    IDS_CANNOTSTARTUP, "Unable to start up the resource compiler."
    IDS_RESMISMATCH, "Niezgodny typ zasobu."
    IDS_SAMPLETEXT, "To jest przykład."
    IDS_ALREADYEXISTS, "Już istnieje."
    IDS_KEY, "Klucz"
    IDS_FLAGS, "Flagi"
    IDS_COMMANDID, "Identyfikator polecenia"
    IDS_INVALIDKEY, "Nieprawidłowy klucz."
    IDS_COMPILEERROR, "Nie można skompilować."
    IDS_STRINGID, "Identyfikator łańcucha (string)"
    IDS_STRINGVALUE, "Wartość łańcucha (string)"
    IDS_CAPTION, "Opis"
    IDS_HELPID, "Identyfikator pomocy"
    IDS_INDENT, "» "
    IDS_DATAISEMPTY, "Dane są puste."
    IDS_TEST, "Wykonaj test"
    IDS_SEPARATOR, "---"
    IDS_COMPILENOW, "Dane zostały zmienione. Skompilować teraz?"
    IDS_RADWINDOW, "Edycja okna dialogowego"
    IDS_ENTERCLASS, "Wprowadź prawidłową nazwę klasy okna."
    IDS_TEXTEDIT, "Edycja tekstowa (Ctrl+T)"
    IDS_CURSORINFO, "Obraz #%u: Szerokość %u, Wysokość %u, BitCount %u, xHotSpot %u, yHotSpot %u, ID %u\r\n"
    IDS_IMAGECOUNT, "ImageCount: %u\r\n"
    IDS_ICONINFO, "Obraz #%u: Szerokość %u, Wysokość %u, BitCount %u, ID %u\r\n"
    IDS_READY, "Gotowy"
    IDS_EXECUTINGCMD, "Wykonywanie polecenia..."
    IDS_EDITINGBYGUI, "Edycja przez Graficzny Interfejs Użytkownika (GUI)..."
    IDS_COORD, "%d, %d, %d, %d"
    IDS_STARTING, "Uruchamianie..."
    IDS_COMPILING, "Kompilowanie..."
    IDS_CANNOTLOAD, "Nie można załadować."
    IDS_NONE, "(Brak)"
    IDS_WAVESOUND, "(Dźwięk typu WAVE)\r\n"
    IDS_IDTYPE, "Typ identyfikatora ID"
    IDS_IDPREFIX, "Prefiks identyfikatora ID"
    IDS_EMPTYSTR, "Wpisz łańcuch (string)."
    IDS_ANICURSOR, "(Kursory animowane)\r\n"
    IDS_ANIICON, "(Ikony animowane)\r\n"
    IDS_HEADFILTER, "Pliki nagłówkowe (*.h)|*.h|Wszystkie pliki (*.*)|*.*|"
    IDS_LOADRESH, "Wczytaj plik ""resource.h"""
    IDS_NAME, "Nazwa"
    IDS_VALUE, "Wartość"
    IDS_NOSUCHID, "Nie znaleziono takiego identyfikatora ID."
    IDS_IMAGEINFO, "Szerokość %u, Wysokość %u, BitsPixel %u\r\n"
    IDS_ENTERINT, "Wprowadź prawidłową liczbę całkowitą."
    IDS_ENTERTEXT, "Wprowadź prawidłowy tekst."
    IDS_ENTERID, "Podaj prawidłowy identyfikator ."
    IDS_ADDNEXTIDS, "Dodaj następujące identyfikatory IDs do ""resource.h"":\r\n\r\n"
    IDS_DELETENEXTIDS, "Usuń następujące identyfikatory IDs z ""resource.h"":\r\n\r\n"
    IDS_NOCHANGE, "Nie ma zmian identyfikatorów IDs zasobów."
    IDS_DLGFAIL, "Ups, nie udało mi się utworzyć okna dialogowego RAD."
    IDS_LOADWCLIB, "Załaduj bibliotekę klas okien (Window Class Library)"
    IDS_AVIMOVIE, "(Film AVI)\r\n"
    IDS_ADDDIALOG, "Dodaj Okno dialogowe"
    IDS_ADDMENU, "Dodaj Menu"
    IDS_ADDVERINFO, "Dodaj informacje o Wersji"
    IDS_ADDCURSOR, "Dodaj Kursor"
    IDS_NOMOREITEM, "Nie ma więcej elementów."
    IDS_INVALIDDATA, "(nieprawidłowe dane)\r\n"
    IDS_UPDATERESH, "Zaktualizować ""resource.h""?"
    IDS_CANTWRITERESH, "Nie można zapisać ""resource.h""."
    IDS_SAVERESH, "Zapisz plik ""resource.h"""
    IDS_DLLFILTER, "Biblioteki DLL (*.dll;*.ocx;*.mui)|*.dll;*.ocx;*.mui|Wszystkie pliki (*.*)|*.*|"
    IDS_EXERESRCFILTER, "Wczytywalne pliki (*.exe;*.dll;*.ocx;*.cpl;*.scr;*.mui;*.res;*.rc)|*.exe;*.dll;*.ocx;*.cpl;*.scr;*.mui;*.res;*.rc|Wykonywalne (*.exe;*.dll;*.ocx;*.cpl;*.scr;*.mui)|*.exe;*.dll;*.ocx;*.cpl;*.scr;*.mui|Zasoby binarne (*.res)|*.res|Pliki zasobów (*.rc)|*.rc|Wszystkie pliki (*.*)|*.*|"
    IDS_CANTTESTCHILDWND, "Unable to test the dialog because it is a child window."
    IDS_CANTTESTCLASSDLG, "Unable to test the dialog because it is classed."
    IDS_FILEISUPXED, "File\r\n\r\n'%s'\r\n\r\nis compressed by UPX. Do you want to extract it by using a temporary file?\r\n\r\nIf you didn't expand it, reading might fail."
    IDS_CANTUPXEXTRACT, "Nie można wypakować przez UPX."
    IDS_CANTSAVEUPXED, "Nie można zapisać pliku, ponieważ został skompresowany przez UPX."
    IDS_MESSAGEID, "ID Wiadomości"
    IDS_MESSAGEVALUE, "Wartość Wiadomości"
    IDS_RCFILTER, "Pliki RC (*.rc)|*.rc|"
    IDS_EXPORT, "Eksport"
    IDS_CANTEXPORT, "Eksport nie powiódł się."
    IDS_MUSTBEEMPTYDIR, "Jeśli istnieje dowolny plik zewnętrzny, miejscem docelowym eksportu musi być pusty folder."
    IDS_FULLWIDTH, "０１２３４５６７８９ＡＢＣＤＥＦＧＨＩＪＫＬＭＮＯＰＱＲＳＴＵＶＷＸＹＺａｂｃｄｅｆｇｈｉｊｋｌｍｎｏｐｑｒｓｔｕｖｗｘｙｚ－＿（）．　"
    IDS_HALFWIDTH, "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz-_(). "
    IDS_MACRONAME, "Nazwa makra"
    IDS_MACROVALUE, "Wartość makra"
    IDS_OPTIONAL, "(Opcjonalne)"
    IDS_ADDINCLUDE, "Dodaj katalog Dołączony"
    IDS_EDITINCLUDE, "Edytuj katalog Dołączony"
    IDS_WINDRESEXE, "windres.exe|windres.exe|"
    IDS_CPPEXE, "cpp.exe|cpp.exe|"
    IDS_INVALIDPATH, "Niewłaściwa ścieżka."
    IDS_DATATOOLONG, "Dane są za długie."
    IDS_ALL, "(Wszystko)"
    IDS_UNKNOWNFORMAT, "(Nieznany format danych)\r\n"
    IDS_LANGUAGE, "Język"
    IDS_INTVALUE, "Wartość całkowita"
    IDS_PARENTWND, "Parent Test Window"
    IDS_CHOOSE_OLE_CLSID, "Choose OLE CLSID"
    IDS_CONTROL, "Control"
    IDS_MESSAGE, "Message"
    IDS_STRING, "String"
    IDS_DATAISINVALID, "Dane są nieprawidłowe."
    IDS_DLGINIT1, "You can specify initialization of combo boxes and list boxes by setting initialization data in the RT_DLGINIT resource data of the same name as the dialog resource. "
    IDS_DLGINIT2, "When the WM_INITDIALOG message arrives, the application can initialize the dialog by calling the ExecuteDlgInitDx function of the attached file ""DlgInit/DlgInit.h"".\r\n\r\n"
    IDS_DLGINIT3, "Please specify a list of character strings separated by line breaks for RT_DLGINIT."
    IDS_SAMELANG, "To ten sam język."
    IDS_SAMENAME, "To ta sama nazwa zasobu."
    IDS_CANTSAVETOEXE, "Nie można zapisać jako EXE z pliku niewykonywalnego."
    IDS_CANTSTARTSEARCH, "Nie można rozpocząć wyszukiwania."
    IDS_AMERICA, "Ameryka"
    IDS_ENGLISH, "Angielski"
    IDS_CHINA, "Chiny"
    IDS_CHINESE, "Chiński"
    IDS_RUSSIA, "Rosja"
    IDS_RUSSIAN, "Rosyjski"
    IDS_WANNAGENRESH, "Czy chcesz wygenerować plik 'resource.h'?"
    IDS_EXEFILTER, "Wykonywalne (*.exe;*.dll;*.ocx;*.cpl;*.scr;*.mui)|*.exe;*.dll;*.ocx;*.cpl;*.scr;*.mui|Wszystkie pliki (*.*)|*.*|"
    IDS_SAVEASCOMPRESS, "Zapisz z kompresją"
    IDS_TOOL_NEW, "Nowy"
    IDS_TOOL_OPEN, "Otwórz..."
    IDS_TOOL_SAVE, "Zapisy jako..."
    IDS_TOOL_EXPAND, "Rozwiń wszystko"
    IDS_TOOL_COLLAPSE, "Zwiń wszystko"
    IDS_TOOL_PLUS, "Dodaj element..."
    IDS_TOOL_MINUS, "Usuń element"
    IDS_TOOL_CHANGE, "Zmień Nazwę/Język"
    IDS_TOOL_CLONE, "Klonuj w innej Nazwie/Języku"
    IDS_TOOL_RECOMPILE, "Rekompiluj"
    IDS_TOOL_CANCELEDIT, "Anuluj edycję"
    IDS_TOOL_IMPORT, "Importuj..."
    IDS_TOOL_EXTRACT, "Wypakuj..."
    IDS_TOOL_GUIEDIT, "Edytuj przez GUI"
    IDS_UNITEDKINGDOM, "Zjednoczone Królestwo"
    IDS_GREATBRITAIN, "Wielka Brytania"
    IDS_BRITISH, "Brytyjski"
    IDS_FRANCE, "Francja"
    IDS_FRENCH, "Frencuski"
    IDS_GERMANY, "Niemcy"
    IDS_GERMAN, "Niemiecki"
    IDS_SPAIN, "Hiszpania"
    IDS_SPANISH, "Hiszpański"
    IDS_INVALIDLANG, "Nierozpoznany język."
    IDS_INVALIDNAME, "Nieprawidłowa nazwa zasobu."
    IDS_PNGRESBINFILTER, "Obraz PNG (*.png)|*.png|Zasoby binarne (*.res)|*.res|Pliki binarne (*.bin)|*.bin|Wszystkie pliki (*.*)|*.*|"
    IDS_JPEGRESBINFILTER, "Obraz JPEG (*.jpg;*.jpeg;*.jpe;*.jfif)|*.jpg;*.jpeg;*.jpe;*.jfif|Zasoby binarne (*.res)|*.res|Pliki binarne (*.bin)|*.bin|Wszystkie pliki (*.*)|*.*|"
    IDS_GIFRESBINFILTER, "Obraz GIF (*.gif)|*.gif|Zasoby binarne (*.res)|*.res|Pliki binarne (*.bin)|*.bin|Wszystkie pliki (*.*)|*.*|"
    IDS_TIFFRESBINFILTER, "Obraz TIFF (*.tif;*.tiff)|*.tif;*.tiff|Zasoby binarne (*.res)|*.res|Pliki binarne (*.bin)|*.bin|Wszystkie pliki (*.*)|*.*|"
    IDS_AVIRESBINFILTER, "Film AVI (*.avi)|*.avi|Zasoby binarne (*.res)|*.res|Pliki binarne (*.bin)|*.bin|Wszystkie pliki (*.*)|*.*|"
    IDS_WAVERESBINFILTER, "Dźwięk typu WAVE (*.wav)|*.wav|Zasoby binarne (*.res)|*.res|Pliki binarne (*.bin)|*.bin|Wszystkie pliki (*.*)|*.*|"
    IDS_COMMENT_SEP, "//////////////////////////////////////////////////////////////////////////////\r\n\r\n"
    IDS_NEWLINE, "\r\n"
    IDS_NOTICE, "// Ten plik jest automatycznie generowany przez RisohEditor 5.7.9.\r\n"
    IDS_DAGGER, "// † <-- Ten sztylet (dagger), pomaga w wykrywaniu UTF-8.\r\n"
    IDS_IMPORTFILTER, "Pliki importowane |*.rc;*.res;*.dfm;*.html;*.htm;*.manifest;*.ico;*.cur;*.ani;*.wav;*.bmp;*.dib;*.png;*.gif;*.jpg;*.jpeg;*.jpe;*.jfif;*.tif;*.tiff;*.avi;*.wmf;*.emf;*.tlb|Pliki RC (*.rc)|*.rc|Zasoby binarne (*.res)|*.res|Pliki obrazów|*.bmp;*.dib;*.png;*.gif;*.jpg;*.jpeg;*.jpe;*.jfif;*.tif;*.tiff;*.wmf;*.emf|Pliki kursorów (*.cur;*.ani)|*.cur;*.ani|Pliki ikon (*.ico)|*.ico|Pliki dźwiękowe WAVE (*.wav)|*.wav|Pliki HTML (*.html;*.htm)|*.html;*.htm|Pliki Manifest (*.manifest)|*.manifest|Pliki Delphi DFM (*.dfm)|*.dfm|Pliki TYPELIB (*.tlb)|*.tlb|Wszystkie pliki (*.*)|*.*|"
    IDS_CANTWRITEBYLOCK, "Nie można zapisać pliku, ponieważ następujący plik jest zablokowany.\r\n\r\n%s"
    IDS_ANSI, "ANSI"
    IDS_WIDE, "Unicode"
    IDS_UTF8, "UTF-8 (z BOM)"
    IDS_UTF8N, "UTF-8 (bez BOM)"
    IDS_SJIS, "Shift_JIS"
    IDS_BINARY, "(dane binarne)"
    IDS_RESTYPE, "Typ zasobu"
    IDS_ENCODING, "Kodowanie"
    IDS_INVALIDRESTYPE, "Nieprawidłowy typ zasobu."
    IDS_PATHSPACEERROR, "Nieprawidłowo zainstalowano w lokalizacji ze znakami spacji! Kompilator zasobów nie może zaakceptować spacji.\n\nNależy unikać ""C:\\Program Files""."
    IDS_LOADEGAPROGRAM, "Załaduj program EGA..."
    IDS_EGAFILTER, "EGA Program (*.ega)|*.ega|Wszystkie pliki (*.*)|*.*|"
    IDS_QUERYSAVECHANGE, "Plik został zmodyfikowany. Czy chcesz teraz zapisać zmiany?"
    IDS_DFMFILTER, "Plik DFM (*.dfm)|*.dfm|Pliki tekstowe (*.txt)|*.txt|Wszystkie pliki (*.*)|*.*|"
    IDS_CANTEXTRACTDFM, "Nie można wypakować danych DFM."
    IDS_EXTRACTDFM, "Wypakuj dane DFM"
    IDS_ENTERNONZERONAME, "Wprowadź niezerową nazwę zasobu."
    IDS_ENTERNONZEROTYPE, "Wprowadź niezerowy typ zasobu."
    IDS_HOMEPAGE, "https://katahiromz.web.fc2.com/re/en/"
    IDS_FILESAVED, "Plik zapisany."
    IDS_RECOMPILEOK, "Rekompilacja zakończona."
    IDS_RECOMPILEFAILED, "Rekompilacja nie powiodła się (błąd składni)."
    IDS_TOOL_EXPORT, "Eksport..."
    IDS_CODEEDITOR, "Edytor kodu"
    IDS_HEXVIEWER, "Widok Szesnastkowy HEX"
    IDS_INTEGERORIDENTIFIER, "(liczba całkowita lub identyfikator)"
    IDS_NOTEXT, " "
    IDS_NOUPDATE, "Używasz najnowszej wersji RisohEditor."
    IDS_THEREISUPDATE, "RisohEditor %s jest dostępny. Pobrać teraz?"
    IDS_CANTCHECKUPDATE, "Nie udało się sprawdzić aktualizacji RisohEditor."
    IDS_CODEPAGE1252, "1252 (Łaciński 1)"
    IDS_CODEPAGE1250, "1250 (Łaciński 2)"
    IDS_CODEPAGE1251, "1251 (Cyrylica)"
    IDS_CODEPAGE1253, "1253 (Grecki)"
    IDS_CODEPAGE1254, "1254 (Turecki)"
    IDS_CODEPAGE1255, "1255 (Hebrajski)"
    IDS_CODEPAGE1256, "1256 (Arabski)"
    IDS_CODEPAGE1257, "1257 (Bałtycki)"
    IDS_CODEPAGE874, "874 (Tajski)"
    IDS_CODEPAGE932, "932 (Japoński)"
    IDS_CODEPAGE936, "936 (Chiński uproszczony)"
    IDS_CODEPAGE949, "949 (Koreański)"
    IDS_CODEPAGE950, "950 (Chiński tradycyjny)"
    IDS_CODEPAGE65001, "65001 (UTF-8)"
    IDS_EXTRACTTLB, "Wypakuj dane TYPELIB"
    IDS_CANTEXTRACTTLB, "Nie można wypakować danych TYPELIB."
    IDS_TLBRESBINFILTER, "Dane TYPELIB (*.tlb)|*.tlb|Zasoby binarne (*.res)|*.res|Pliki tekstowe (*.txt)|*.txt|Pliki MIDL (*.idl)|*.idl|Wszystkie pliki (*.*)|*.*|"
    IDS_USAGE, "Usage: RisohEditor [options | ""file""]\n\nOptions:\n--help  Show this message.\n--version  Show version info.\n--load ""your-file.rc""  Load the file (without GUI)\n--save ""your-file.res""  Save the file (without GUI)\n--log-file ""log-file.txt""  Specify the log file.\n--load-options OPTIONS  Set load options.\n--save-options OPTIONS  Set save options.\n\nLoad options: (no-load-res-h)\nSave options: (idc-static)(compress)(sep-lang)(no-res-folder)(lang-macro)(less-comments)(wrap-manifest)(begin-end)(utf-16)(backup)(ms-msgtbl)"
    IDS_NOSELECTION, "Nie ma wyboru."
    IDS_TRANSLATORS, "[Translators]\r\nEnglish: Katayama Hirofumi MZ\r\nFinnish: Veikko Muurikainen\r\nIndonesian: Mas Ahmad Muhammad\r\nItalian: R.B.\r\nJapanese: Katayama Hirofumi MZ\r\nKorean: VenusGirl (비너스걸)\r\nPolish: Piotr Hetnarowicz\r\nPortuguese: JNylson\r\nRussian: Dmitry Yerokhin\r\nSimplified Chinese: 林鸿湘\r\n"
}

//////////////////////////////////////////////////////////////////////////////

```

`src/lang/pt_BR.rc`:

```rc
// This file is automatically generated by RisohEditor 5.7.9.
// † <-- This dagger helps UTF-8 detection.

#pragma code_page(65001) // UTF-8

LANGUAGE LANG_PORTUGUESE, SUBLANG_DEFAULT

//////////////////////////////////////////////////////////////////////////////
// RT_MENU

IDR_MAINMENU MENU
{
    POPUP "&Arquivo"
    {
        MENUITEM "&Novo\tCtrl+N", ID_NEW
        MENUITEM SEPARATOR
        MENUITEM "&Abrir...\tCtrl+O", ID_OPEN
        MENUITEM "&Salvar...\tCtrl+S", ID_SAVE
        MENUITEM "Salvar &Como...\tShift+Ctrl+S", ID_SAVEAS
        MENUITEM "Salvar com Co&mpressão...", ID_SAVEASCOMPRESS
        MENUITEM SEPARATOR
        MENUITEM "Im&portar...\tCtrl+I", ID_IMPORT
        MENUITEM "&Exportar...\tCtrl+P", ID_EXPORT
        MENUITEM SEPARATOR
        MENUITEM "&Recarregar resource.h...\tCtrl+R", ID_LOADRESH
        MENUITEM "Salvar reso&urce.h...", ID_UPDATERESHBANG
        MENUITEM "C&onselho de Modificação em resource.h...", ID_ADVICERESH
        MENUITEM "&Descarregar resource.h", ID_UNLOADRESH
        MENUITEM SEPARATOR
        MENUITEM "Carregar Biblioteca de Classes do &Windows...", ID_LOADWCLIB
        MENUITEM SEPARATOR
        POPUP "Arquivos Usados Recentemente"
        {
            MENUITEM "(Nenhum)", -1, GRAYED
        }
        MENUITEM SEPARATOR
        MENUITEM "Sa&ir\tAlt+F4", ID_EXIT
    }
    POPUP "&Editar"
    {
        MENUITEM "Editar via &GUI...\tCtrl+G", ID_GUIEDIT
        MENUITEM SEPARATOR
        POPUP "&Adicionar"
        {
            MENUITEM "Adicionar Íc&one...", ID_ADDICON
            MENUITEM "Adicionar &Cursor...", ID_ADDCURSOR
            MENUITEM "Adicionar &Bitmap...", ID_ADDBITMAP
            MENUITEM "Adicionar &Diálogo...", ID_ADDDIALOG
            MENUITEM "Adicionar &Menu...", ID_ADDMENU
            MENUITEM "Adicionar Tabela de &String...", ID_ADDSTRINGTABLE
            MENUITEM "Adicionar Tabela de M&ensagem...", ID_ADDMESSAGETABLE
            MENUITEM "Adicionar &HTML...", ID_ADDHTML
            MENUITEM "Adicionar &Aceleradores...", ID_ADDACCEL
            MENUITEM "Adicionar Informação da &Versão...", ID_ADDVERINFO
            MENUITEM "Adicionar Mani&festo...", ID_ADDMANIFEST
            MENUITEM "Adicionar Barra de Ferramen&tas...", ID_ADDTOOLBAR
            MENUITEM "Adicionar Item de &Recurso...", ID_ADDRES
        }
        POPUP "&Substituir"
        {
            MENUITEM "Substituir Íc&one...", ID_REPLACEICON
            MENUITEM "Substituir &Cursor...", ID_REPLACECURSOR
            MENUITEM "Substituir &Bitmap...", ID_REPLACEBITMAP
            MENUITEM "Substituir Item de &Recurso Binário...", ID_REPLACEBIN
        }
        POPUP "&Extrair"
        {
            MENUITEM "Extrair Íc&one...", ID_EXTRACTICON
            MENUITEM "Extrair &Cursor...", ID_EXTRACTCURSOR
            MENUITEM "Extrair &Bitmap...", ID_EXTRACTBITMAP
            MENUITEM "Extrair como &Arquivo RC...", ID_EXTRACTRC
            MENUITEM "Extrair Item de &Recurso Binário...", ID_EXTRACTBIN
        }
        MENUITEM SEPARATOR
        MENUITEM "A&lterar Nome/Idioma\tF2", ID_EDITLABEL
        MENUITEM SEPARATOR
        MENUITEM "Clonar Para Um Novo &Nome...", ID_COPYASNEWNAME
        MENUITEM "Clonar Para Um Novo &Idioma...", ID_COPYASNEWLANG
        MENUITEM "Copiar Para Vários Idiomas...", ID_COPYTOMULTILANG
        MENUITEM SEPARATOR
        MENUITEM "&Testar", ID_TEST
        MENUITEM SEPARATOR
        MENUITEM "E&xcluir\tDel", ID_DELETERES
        MENUITEM SEPARATOR
        MENUITEM "ID de Ass&ociação...", ID_IDASSOC
        MENUITEM "&Macros Predefinidas...", ID_PREDEFMACROS
        MENUITEM "Configurações de &Fonte...", ID_FONTS
        MENUITEM "Definir Camin&hos...", ID_SETPATHS
        MENUITEM SEPARATOR
        MENUITEM "&UI Language Select (UI语言选择)...", ID_CHOOSEUILANG
        MENUITEM SEPARATOR
        MENUITEM "Configurações DFM do &Delphi...", ID_DFMSETTINGS
        MENUITEM "&Configuração...", ID_CONFIG
    }
    POPUP "&Pesquisar"
    {
        MENUITEM "&Localizar...\tCtrl+F", ID_FIND
        MENUITEM SEPARATOR
        MENUITEM "Pesquisar &Acima\tShift+F3", ID_FINDUPWARD
        MENUITEM "Pesquisar A&baixo\tF3", ID_FINDDOWNWARD
        MENUITEM SEPARATOR
        MENUITEM "&Consultar Constante...", ID_QUERYCONSTANT
    }
    POPUP "E&xibir"
    {
        MENUITEM "Barra de &Status", ID_STATUSBAR
        MENUITEM "Barra de &Ferramentas", ID_SHOWHIDETOOLBAR
        MENUITEM "&Binário", ID_BINARYPANE
        MENUITEM SEPARATOR
        MENUITEM "E&xpandir Todos\tCtrl+K", ID_EXPAND_ALL
        MENUITEM "Rec&olher Todos\tCtrl+L", ID_COLLAPSE_ALL
        MENUITEM SEPARATOR
        MENUITEM "Lista de IDs de &Recursos", ID_IDLIST
        MENUITEM "Lista de &Idiomas...", ID_SHOWLANGS
        MENUITEM SEPARATOR
        MENUITEM "Sempre Declarar &CONTROLE", ID_ALWAYSCONTROL
        MENUITEM "Não Usar &ID de Macros", ID_HIDEIDMACROS
        MENUITEM "Usar IDC_ST&ATIC", ID_USEIDC_STATIC
        MENUITEM "Quebra de &Palavra", ID_WORD_WRAP
        MENUITEM "Usar BE&GIN/END", ID_USEBEGINEND
        MENUITEM "Usar &Tabela de Mensagem da Microsoft", ID_USEMSMSGTBL
        MENUITEM SEPARATOR
        MENUITEM "&Codificação do Item de Recurso...", ID_ENCODING
        MENUITEM "Substituir &Fontes de Diálogo...", ID_DIALOG_FONT_SUBSTITUTES
        MENUITEM SEPARATOR
        MENUITEM "&Atualizar", ID_REFRESHALL
    }
    POPUP "A&utomação"
    {
        MENUITEM "Linguagem de Programação E&GA...", ID_EGA
        MENUITEM "&Executar Programa EGA...", ID_EGA_PROGRAM
        MENUITEM "Abrir &Manual do EGA", ID_OPEN_EGA_MANUAL
    }
    POPUP "A&juda"
    {
        MENUITEM "Abrir &README.txt (Inglês)", ID_OPENREADME
        MENUITEM "Abrir README-&PTB.txt", ID_OPENREADMEPTB
        MENUITEM "Abrir &HISTORY.txt", ID_OPENHISTORY
        MENUITEM "Abrir HISTORY-P&TB.txt", ID_OPENHISTORYPTB
        MENUITEM "Abrir &LICENSE.txt", ID_OPENLICENSE
        MENUITEM SEPARATOR
        MENUITEM "&Guia do RisohEditor", ID_GUIDE
        MENUITEM "Verificar por &Atualização do RisohEditor...", ID_CHECKUPDATE
        MENUITEM SEPARATOR
        MENUITEM "&Sobre...", ID_ABOUT
    }
}

IDR_POPUPMENUS MENU
{
    POPUP "Popup #0"
    {
        MENUITEM "Editar via &GUI...\tCtrl+G", ID_GUIEDIT
        MENUITEM SEPARATOR
        POPUP "&Adicionar"
        {
            MENUITEM "Adicionar Íc&one...", ID_ADDICON
            MENUITEM "Adicionar &Cursor...", ID_ADDCURSOR
            MENUITEM "Adicionar &Bitmap...", ID_ADDBITMAP
            MENUITEM "Adicionar &Diálogo...", ID_ADDDIALOG
            MENUITEM "Adicionar &Menu...", ID_ADDMENU
            MENUITEM "Adicionar Tabela de &String...", ID_ADDSTRINGTABLE
            MENUITEM "Adicionar Tabela de M&ensagem...", ID_ADDMESSAGETABLE
            MENUITEM "Adicionar &HTML...", ID_ADDHTML
            MENUITEM "Adicionar &Aceleradores...", ID_ADDACCEL
            MENUITEM "Adicionar Informação da &Versão...", ID_ADDVERINFO
            MENUITEM "Adicionar Mani&festo...", ID_ADDMANIFEST
            MENUITEM "Adicionar Barra de Ferramen&tas...", ID_ADDTOOLBAR
            MENUITEM "Adicionar Item de &Recurso...", ID_ADDRES
        }
        POPUP "&Substituir"
        {
            MENUITEM "Substituir Íc&one...", ID_REPLACEICON
            MENUITEM "Substituir &Cursor...", ID_REPLACECURSOR
            MENUITEM "Substituir &Bitmap...", ID_REPLACEBITMAP
            MENUITEM "Substituir Item de &Recurso Binário...", ID_REPLACEBIN
        }
        POPUP "&Extrair"
        {
            MENUITEM "Extrair Íc&one...", ID_EXTRACTICON
            MENUITEM "Extrair &Cursor...", ID_EXTRACTCURSOR
            MENUITEM "Extrair &Bitmap...", ID_EXTRACTBITMAP
            MENUITEM "Extrair Como &Arquivo RC...", ID_EXTRACTRC
            MENUITEM "Extrair Item de &Recurso Binário...", ID_EXTRACTBIN
        }
        MENUITEM SEPARATOR
        MENUITEM "A&lterar Nome/Idioma\tF2", ID_EDITLABEL
        MENUITEM SEPARATOR
        MENUITEM "Clonar Para Um Novo &Nome...", ID_COPYASNEWNAME
        MENUITEM "Clonar Para Um Novo &Idioma...", ID_COPYASNEWLANG
        MENUITEM "Copiar Para Vários Idiomas...", ID_COPYTOMULTILANG
        MENUITEM SEPARATOR
        MENUITEM "&Testar", ID_TEST
        MENUITEM SEPARATOR
        MENUITEM "E&xcluir\tDel", ID_DELETERES
    }
    POPUP "Popup #1"
    {
        MENUITEM "A&dicionar Controle...", ID_ADDCTRL
        MENUITEM SEPARATOR
        MENUITEM "Recor&tar\tCtrl+X", ID_CUT
        MENUITEM "&Copiar\tCtrl+C", ID_COPY
        MENUITEM "C&olar\tCtrl+V", ID_PASTE
        MENUITEM "&Excluir\tDel", ID_DELCTRL
        MENUITEM SEPARATOR
        POPUP "Í&ndice"
        {
            MENUITEM "Ir para &Topo", ID_CTRLINDEXTOP
            MENUITEM SEPARATOR
            MENUITEM "&Decrementar Índice", ID_CTRLINDEXMINUS
            MENUITEM "&Incrementar Índice", ID_CTRLINDEXPLUS
            MENUITEM SEPARATOR
            MENUITEM "Ir para I&nferior", ID_CTRLINDEXBOTTOM
            MENUITEM SEPARATOR
            MENUITEM "Mostrar/Ocultar Índices\tCtrl+D", ID_SHOWHIDEINDEX
        }
        POPUP "&Alinhamento"
        {
            MENUITEM "Alinhamento &Superior", ID_TOPALIGN
            MENUITEM "Alinhamento &Inferior", ID_BOTTOMALIGN
            MENUITEM "Alinhar a &Esquerda", ID_LEFTALIGN
            MENUITEM "Alinhar a &Direita", ID_RIGHTALIGN
            MENUITEM SEPARATOR
            MENUITEM "Ajustar à &Grade", ID_FITTOGRID
        }
        MENUITEM SEPARATOR
        MENUITEM "A&tualizar", ID_REFRESHDIALOG
        MENUITEM SEPARATOR
        MENUITEM "&Propriedades do Controle...", ID_CTRLPROP
        MENUITEM "Prop&riedades do Diálogo...", ID_DLGPROP
    }
    POPUP "Popup #2"
    {
        MENUITEM "&Modificar...", ID_MODIFYASSOC
    }
    POPUP "Popup #3"
    {
        MENUITEM "&Pular!", ID_IDJUMP
        MENUITEM SEPARATOR
        MENUITEM "&Adicionar ID...", ID_ADDRESID
        MENUITEM "&Modificar ID...", ID_MODIFYRESID
        MENUITEM SEPARATOR
        MENUITEM "Copiar &Nome", ID_COPYRESIDNAME
        MENUITEM "Copiar &Valor", ID_COPYRESIDVALUE
        MENUITEM "Copiar De&finição\tCtrl+C", ID_COPYIDDEF
        MENUITEM SEPARATOR
        MENUITEM "&Excluir ID\tDel", ID_DELETERESID
        MENUITEM SEPARATOR
        MENUITEM "Números &Decimais", ID_BASE10
        MENUITEM "Números &Hexadecimal", ID_BASE16
        MENUITEM SEPARATOR
        MENUITEM "&Recarregar", ID_LOADRESH
    }
    POPUP "Popup #4"
    {
        MENUITEM "&Adicionar...", ID_ADD
        MENUITEM SEPARATOR
        MENUITEM "Alterar &Nome...\tF2", ID_RENAME
        MENUITEM "Alterar &Valor...", ID_MODIFY
        MENUITEM SEPARATOR
        MENUITEM "&Excluir\tDel", ID_DELETE
    }
    POPUP "Popup #5"
    {
        MENUITEM "&Copiar Valor Inteiro", ID_COPY
    }
    POPUP "Popup #6"
    {
        MENUITEM "&Adicionar...", psh1
        MENUITEM "&Modificar...", psh2
        MENUITEM SEPARATOR
        MENUITEM "A&cima", psh4
        MENUITEM "A&baixo", psh5
        MENUITEM "&Esquerda", psh6
        MENUITEM "D&ireita", psh7
        MENUITEM SEPARATOR
        MENUITEM "E&xcluir\tDel", psh3
    }
    POPUP "Popup #7"
    {
        MENUITEM "&Adicionar...", psh1
        MENUITEM "&Modificar...", psh2
        MENUITEM SEPARATOR
        MENUITEM "A&cima", psh4
        MENUITEM "A&baixo", psh5
        MENUITEM SEPARATOR
        MENUITEM "E&xcluir\tDel", psh3
    }
    POPUP "Popup #8"
    {
        MENUITEM "&Adicionar...", ID_ADD
        MENUITEM "&Modificar...", ID_MODIFY
        MENUITEM SEPARATOR
        MENUITEM "&Excluir\tDel", ID_DELETE
    }
}

//////////////////////////////////////////////////////////////////////////////
// RT_DIALOG

IDD_REPLACERES DIALOGEX 0, 0, 215, 170
CAPTION "Substituir Recurso"
STYLE DS_MODALFRAME | WS_POPUPWINDOW | WS_CAPTION
FONT 9, "MS Shell Dlg", 0, 0, 1
{
    LTEXT "&Tipo de Recurso:", -1, 5, 7, 70, 12
    COMBOBOX cmb1, 75, 5, 135, 200, CBS_HASSTRINGS | CBS_AUTOHSCROLL | CBS_DROPDOWN | WS_BORDER | WS_VSCROLL | WS_TABSTOP
    LTEXT "&Nome do Recurso:", -1, 5, 32, 70, 12
    COMBOBOX cmb2, 75, 30, 135, 200, CBS_HASSTRINGS | CBS_AUTOHSCROLL | CBS_DROPDOWN | WS_DISABLED | WS_BORDER | WS_VSCROLL | WS_TABSTOP
    LTEXT "&Idioma do Recurso:", -1, 5, 57, 70, 12
    COMBOBOX cmb3, 75, 55, 135, 200, CBS_HASSTRINGS | CBS_AUTOHSCROLL | CBS_DROPDOWN | WS_DISABLED | WS_BORDER | WS_VSCROLL | WS_TABSTOP
    LTEXT "&Arquivo Binário:", -1, 5, 85, 100, 12
    EDITTEXT edt1, 5, 97, 205, 14, ES_AUTOHSCROLL
    PUSHBUTTON "&Procurar...", psh1, 150, 115, 60, 14
    DEFPUSHBUTTON "OK", IDOK, 35, 150, 60, 14
    PUSHBUTTON "Cancelar", IDCANCEL, 115, 150, 60, 14
    {
        0x1234, 0x5678, 0x0011
    }
}

IDD_ADDICON DIALOG 0, 0, 215, 135
CAPTION "Adicionar Ícone"
STYLE DS_MODALFRAME | WS_POPUPWINDOW | WS_CAPTION
FONT 9, "MS Shell Dlg"
{
    LTEXT "&Arquivo de Ícone:", -1, 5, 7, 100, 12
    EDITTEXT edt1, 5, 18, 205, 14, ES_AUTOHSCROLL
    PUSHBUTTON "&Procurar...", psh1, 150, 35, 60, 14
    ICON 0, ico1, 5, 35, 0, 0
    LTEXT "&Nome do Recurso:", -1, 5, 67, 70, 12
    COMBOBOX cmb2, 75, 65, 120, 300, CBS_HASSTRINGS | CBS_AUTOHSCROLL | CBS_DROPDOWN | WS_BORDER | WS_VSCROLL | WS_TABSTOP
    PUSHBUTTON "&...", psh2, 195, 65, 15, 14
    LTEXT "&Idioma do Recurso:", -1, 5, 92, 70, 12
    COMBOBOX cmb3, 75, 90, 135, 200, CBS_HASSTRINGS | CBS_AUTOHSCROLL | CBS_DROPDOWN | WS_BORDER | WS_VSCROLL | WS_TABSTOP
    DEFPUSHBUTTON "OK", IDOK, 35, 115, 60, 14
    PUSHBUTTON "Cancelar", IDCANCEL, 115, 115, 60, 14
}

IDD_REPLACEICON DIALOG 0, 0, 215, 135
CAPTION "Substituir Ícone"
STYLE DS_MODALFRAME | WS_POPUPWINDOW | WS_CAPTION
FONT 9, "MS Shell Dlg"
{
    LTEXT "&Arquivo de Ícone:", -1, 5, 7, 100, 12
    EDITTEXT edt1, 5, 18, 205, 14, ES_AUTOHSCROLL
    PUSHBUTTON "&Procurar...", psh1, 150, 35, 60, 14
    ICON 0, ico1, 5, 35, 0, 0
    LTEXT "&Nome do Recurso:", -1, 5, 67, 70, 12
    COMBOBOX cmb2, 75, 65, 135, 13, CBS_HASSTRINGS | CBS_AUTOHSCROLL | CBS_DROPDOWN | WS_DISABLED | WS_BORDER | WS_VSCROLL | WS_TABSTOP
    LTEXT "&Idioma do Recurso:", -1, 5, 92, 70, 12
    COMBOBOX cmb3, 75, 90, 135, 13, CBS_HASSTRINGS | CBS_AUTOHSCROLL | CBS_DROPDOWN | WS_DISABLED | WS_BORDER | WS_VSCROLL | WS_TABSTOP
    DEFPUSHBUTTON "OK", IDOK, 35, 115, 60, 14
    PUSHBUTTON "Cancelar", IDCANCEL, 115, 115, 60, 14
}

IDD_ADDBITMAP DIALOG 0, 0, 215, 135
CAPTION "Adicionar Bitmap"
STYLE DS_MODALFRAME | WS_POPUPWINDOW | WS_CAPTION
FONT 9, "MS Shell Dlg"
{
    LTEXT "Arquivo &Bitmap:", -1, 5, 7, 100, 12
    EDITTEXT edt1, 5, 18, 205, 14, ES_AUTOHSCROLL
    PUSHBUTTON "&Procurar...", psh1, 150, 35, 60, 14
    LTEXT "&Nome do Recurso:", -1, 5, 67, 70, 12
    COMBOBOX cmb2, 75, 65, 120, 300, CBS_HASSTRINGS | CBS_AUTOHSCROLL | CBS_DROPDOWN | WS_BORDER | WS_VSCROLL | WS_TABSTOP
    PUSHBUTTON "&...", psh2, 195, 65, 15, 14
    LTEXT "&Idioma do Recurso:", -1, 5, 92, 70, 12
    COMBOBOX cmb3, 75, 90, 135, 200, CBS_HASSTRINGS | CBS_AUTOHSCROLL | CBS_DROPDOWN | WS_BORDER | WS_VSCROLL | WS_TABSTOP
    DEFPUSHBUTTON "OK", IDOK, 35, 115, 60, 14
    PUSHBUTTON "Cancelar", IDCANCEL, 115, 115, 60, 14
}

IDD_REPLACEBMP DIALOG 0, 0, 215, 135
CAPTION "Substituir Bitmap"
STYLE DS_MODALFRAME | WS_POPUPWINDOW | WS_CAPTION
FONT 9, "MS Shell Dlg"
{
    LTEXT "Arquivo &Bitmap:", -1, 5, 7, 100, 12
    EDITTEXT edt1, 5, 18, 205, 14, ES_AUTOHSCROLL
    PUSHBUTTON "&Procurar...", psh1, 150, 35, 60, 14
    LTEXT "&Nome do Recurso:", -1, 5, 67, 70, 12
    COMBOBOX cmb2, 75, 65, 135, 200, CBS_HASSTRINGS | CBS_AUTOHSCROLL | CBS_DROPDOWN | WS_DISABLED | WS_BORDER | WS_VSCROLL | WS_TABSTOP
    LTEXT "&Idioma do Recurso:", -1, 5, 92, 70, 12
    COMBOBOX cmb3, 75, 90, 135, 200, CBS_HASSTRINGS | CBS_AUTOHSCROLL | CBS_DROPDOWN | WS_DISABLED | WS_BORDER | WS_VSCROLL | WS_TABSTOP
    DEFPUSHBUTTON "OK", IDOK, 35, 115, 60, 14
    PUSHBUTTON "Cancelar", IDCANCEL, 115, 115, 60, 14
}

IDD_ADDRES DIALOG 0, 0, 215, 170
CAPTION "Adicionar Recurso"
STYLE DS_MODALFRAME | WS_POPUPWINDOW | WS_CAPTION
FONT 9, "MS Shell Dlg"
{
    LTEXT "&Tipo de Recurso:", -1, 5, 7, 70, 12
    COMBOBOX cmb1, 75, 5, 135, 200, CBS_HASSTRINGS | CBS_AUTOHSCROLL | CBS_DROPDOWN | WS_BORDER | WS_VSCROLL | WS_TABSTOP
    LTEXT "&Nome do Recurso:", -1, 5, 32, 70, 12
    COMBOBOX cmb2, 75, 30, 120, 300, CBS_HASSTRINGS | CBS_AUTOHSCROLL | CBS_DROPDOWN | WS_BORDER | WS_VSCROLL | WS_TABSTOP
    PUSHBUTTON "&...", psh2, 195, 30, 15, 14
    LTEXT "", stc1, 75, 43, 115, 10
    LTEXT "&Idioma do Recurso:", -1, 5, 57, 70, 12
    COMBOBOX cmb3, 75, 55, 135, 200, CBS_HASSTRINGS | CBS_AUTOHSCROLL | CBS_DROPDOWN | WS_BORDER | WS_VSCROLL | WS_TABSTOP
    LTEXT "&Arquivo Binário:", -1, 5, 85, 100, 12
    EDITTEXT edt1, 5, 97, 205, 14, ES_AUTOHSCROLL
    PUSHBUTTON "&Procurar...", psh1, 150, 115, 60, 14
    LTEXT "", stc2, 5, 112, 100, 10
    DEFPUSHBUTTON "OK", IDOK, 35, 150, 60, 14
    PUSHBUTTON "Cancelar", IDCANCEL, 115, 150, 60, 14
}

IDD_ADDCURSOR DIALOG 0, 0, 215, 135
CAPTION "Adicionar Cursor"
STYLE DS_MODALFRAME | WS_POPUPWINDOW | WS_CAPTION
FONT 9, "MS Shell Dlg"
{
    LTEXT "Arquivo de &Cursor:", -1, 5, 7, 100, 12
    EDITTEXT edt1, 5, 18, 205, 14, ES_AUTOHSCROLL
    PUSHBUTTON "&Procurar...", psh1, 150, 35, 60, 14
    ICON 0, ico1, 5, 35, 0, 0
    LTEXT "&Nome do Recurso:", -1, 5, 67, 70, 12
    COMBOBOX cmb2, 75, 65, 120, 200, CBS_HASSTRINGS | CBS_AUTOHSCROLL | CBS_DROPDOWN | WS_BORDER | WS_VSCROLL | WS_TABSTOP
    PUSHBUTTON "&...", psh2, 195, 65, 15, 14
    LTEXT "&Idioma do Recurso:", -1, 5, 92, 70, 12
    COMBOBOX cmb3, 75, 90, 135, 200, CBS_HASSTRINGS | CBS_AUTOHSCROLL | CBS_DROPDOWN | WS_BORDER | WS_VSCROLL | WS_TABSTOP
    DEFPUSHBUTTON "OK", IDOK, 35, 115, 60, 14
    PUSHBUTTON "Cancelar", IDCANCEL, 115, 115, 60, 14
}

IDD_REPLACECUR DIALOG 0, 0, 215, 135
CAPTION "Substituir Cursor"
STYLE DS_MODALFRAME | WS_POPUPWINDOW | WS_CAPTION
FONT 9, "MS Shell Dlg"
{
    LTEXT "Arquivo de &Cursor:", -1, 5, 7, 100, 12
    EDITTEXT edt1, 5, 18, 205, 14, ES_AUTOHSCROLL
    PUSHBUTTON "&Procurar...", psh1, 150, 35, 60, 14
    ICON 0, ico1, 5, 35, 0, 0
    LTEXT "&Nome do Recurso:", -1, 5, 67, 70, 12
    COMBOBOX cmb2, 75, 65, 135, 200, CBS_HASSTRINGS | CBS_AUTOHSCROLL | CBS_DROPDOWN | WS_DISABLED | WS_BORDER | WS_VSCROLL | WS_TABSTOP
    LTEXT "&Idioma do Recurso:", -1, 5, 92, 70, 12
    COMBOBOX cmb3, 75, 90, 135, 200, CBS_HASSTRINGS | CBS_AUTOHSCROLL | CBS_DROPDOWN | WS_DISABLED | WS_BORDER | WS_VSCROLL | WS_TABSTOP
    DEFPUSHBUTTON "OK", IDOK, 35, 115, 60, 14
    PUSHBUTTON "Cancelar", IDCANCEL, 115, 115, 60, 14
}

IDD_MENUTEST DIALOG 0, 0, 215, 135
CAPTION "Testar Menu"
STYLE DS_MODALFRAME | WS_POPUPWINDOW | WS_CAPTION
FONT 9, "MS Shell Dlg"
{
}

IDD_ADDKEY DIALOG 0, 0, 190, 120
CAPTION "Adicionar Chave"
STYLE DS_MODALFRAME | WS_POPUPWINDOW | WS_CAPTION
FONT 9, "MS Shell Dlg"
{
    RTEXT "&Chave:", -1, 5, 12, 60, 14
    COMBOBOX cmb1, 70, 10, 110, 200, CBS_DROPDOWN | WS_BORDER | WS_VSCROLL | WS_TABSTOP
    RTEXT "&ID do Comando:", -1, 5, 37, 60, 14
    COMBOBOX cmb2, 70, 35, 95, 300, CBS_DROPDOWN | WS_BORDER | WS_VSCROLL | WS_TABSTOP
    PUSHBUTTON "&...", psh1, 165, 35, 15, 14
    AUTOCHECKBOX "&VIRTKEY", chx1, 5, 60, 60, 14
    AUTOCHECKBOX "&NOINVERT", chx2, 70, 60, 60, 14
    AUTOCHECKBOX "&CONTROL", chx3, 5, 75, 60, 14
    AUTOCHECKBOX "&SHIFT", chx4, 70, 75, 60, 14
    AUTOCHECKBOX "&ALT", chx5, 140, 75, 45, 14
    DEFPUSHBUTTON "OK", IDOK, 60, 100, 60, 14
    PUSHBUTTON "Cancelar", IDCANCEL, 125, 100, 60, 14
}

IDD_MODIFYKEY DIALOG 0, 0, 190, 120
CAPTION "Modificar Chave"
STYLE DS_MODALFRAME | WS_POPUPWINDOW | WS_CAPTION
FONT 9, "MS Shell Dlg"
{
    RTEXT "&Chave:", -1, 5, 12, 60, 14
    COMBOBOX cmb1, 70, 10, 110, 200, CBS_DROPDOWN | WS_BORDER | WS_VSCROLL | WS_TABSTOP
    RTEXT "&ID do Comando:", -1, 5, 37, 60, 14
    COMBOBOX cmb2, 70, 35, 95, 200, CBS_DROPDOWN | WS_BORDER | WS_VSCROLL | WS_TABSTOP
    PUSHBUTTON "&...", psh1, 165, 35, 15, 14
    AUTOCHECKBOX "&VIRTKEY", chx1, 5, 60, 60, 14
    AUTOCHECKBOX "&NOINVERT", chx2, 70, 60, 60, 14
    AUTOCHECKBOX "&CONTROL", chx3, 5, 75, 60, 14
    AUTOCHECKBOX "&SHIFT", chx4, 70, 75, 60, 14
    AUTOCHECKBOX "&ALT", chx5, 140, 75, 45, 14
    DEFPUSHBUTTON "OK", IDOK, 60, 100, 60, 14
    PUSHBUTTON "Cancelar", IDCANCEL, 125, 100, 60, 14
}

IDD_EDITACCEL DIALOG 0, 0, 285, 165
CAPTION "Editar Aceleradores"
STYLE WS_POPUPWINDOW | WS_CAPTION | WS_THICKFRAME
FONT 9, "MS Shell Dlg"
{
    LTEXT "&Lista de Chaves:", -1, 5, 7, 100, 12
    CONTROL "", lst1, "SysListView32", LVS_NOSORTHEADER | LVS_AUTOARRANGE | LVS_NOLABELWRAP | LVS_SHOWSELALWAYS | LVS_SINGLESEL | LVS_REPORT | WS_BORDER | WS_VSCROLL | WS_HSCROLL | WS_TABSTOP, 5, 20, 210, 120
    PUSHBUTTON "&Adicionar...", psh1, 220, 20, 60, 14
    PUSHBUTTON "&Modificar...", psh2, 220, 40, 60, 14
    PUSHBUTTON "&Excluir", psh3, 220, 60, 60, 14
    PUSHBUTTON "A&cima", psh4, 220, 100, 60, 14
    PUSHBUTTON "A&baixo", psh5, 220, 120, 60, 14
    DEFPUSHBUTTON "OK", IDOK, 155, 145, 60, 14
    PUSHBUTTON "Cancelar", IDCANCEL, 220, 145, 60, 14
    PUSHBUTTON "Excluir T&odos", psh6, 5, 145, 79, 14
}

IDD_ADDSTR DIALOG 0, 0, 255, 115
CAPTION "Adicionar Entrada de String"
STYLE WS_POPUPWINDOW | WS_CAPTION | WS_THICKFRAME
FONT 9, "MS Shell Dlg"
{
    LTEXT "&ID da String:", -1, 5, 7, 50, 12
    COMBOBOX cmb1, 60, 5, 134, 200, CBS_HASSTRINGS | CBS_AUTOHSCROLL | CBS_DROPDOWN | WS_BORDER | WS_VSCROLL | WS_TABSTOP
    PUSHBUTTON "&...", psh1, 195, 5, 15, 14
    LTEXT "&Valor da String:", -1, 5, 27, 54, 12
    EDITTEXT edt1, 60, 25, 190, 45, ES_WANTRETURN | ES_AUTOVSCROLL | ES_MULTILINE | WS_VSCROLL
    AUTOCHECKBOX "&Substituir ""\\r\\n"" com ""\\n""", chx1, 60, 75, 190, 14
    DEFPUSHBUTTON "OK", IDOK, 125, 95, 60, 14
    PUSHBUTTON "Cancelar", IDCANCEL, 190, 95, 60, 14
}

IDD_MODIFYSTR DIALOG 0, 0, 255, 115
CAPTION "Modificar Entrada de String"
STYLE WS_POPUPWINDOW | WS_CAPTION | WS_THICKFRAME
FONT 9, "MS Shell Dlg"
{
    LTEXT "&ID da String:", -1, 5, 7, 50, 12
    COMBOBOX cmb1, 60, 5, 134, 200, CBS_HASSTRINGS | CBS_AUTOHSCROLL | CBS_DROPDOWN | WS_BORDER | WS_VSCROLL | WS_TABSTOP
    PUSHBUTTON "&...", psh1, 195, 5, 15, 14
    LTEXT "&Valor da String:", -1, 5, 27, 54, 12
    EDITTEXT edt1, 60, 25, 190, 45, ES_WANTRETURN | ES_AUTOVSCROLL | ES_MULTILINE | WS_VSCROLL
    AUTOCHECKBOX "&Substituir ""\\r\\n"" com ""\\n""", chx1, 60, 75, 190, 14
    DEFPUSHBUTTON "OK", IDOK, 125, 95, 60, 14
    PUSHBUTTON "Cancelar", IDCANCEL, 190, 95, 60, 14
}

IDD_STRINGS DIALOG 0, 0, 325, 160
CAPTION "Tabela de Strings"
STYLE WS_POPUPWINDOW | WS_CAPTION | WS_THICKFRAME
FONT 9, "MS Shell Dlg"
{
    LTEXT "&Entradas de String:", -1, 5, 7, 100, 12
    CONTROL "", lst1, "SysListView32", LVS_NOSORTHEADER | LVS_AUTOARRANGE | LVS_NOLABELWRAP | LVS_SHOWSELALWAYS | LVS_SINGLESEL | LVS_REPORT | WS_BORDER | WS_VSCROLL | WS_HSCROLL | WS_TABSTOP, 5, 20, 315, 115
    PUSHBUTTON "&Adicionar...", psh1, 130, 3, 60, 14
    PUSHBUTTON "&Modificar...", psh2, 195, 3, 60, 14
    PUSHBUTTON "&Excluir", psh3, 260, 3, 60, 14
    DEFPUSHBUTTON "OK", IDOK, 195, 140, 60, 14
    PUSHBUTTON "Cancelar", IDCANCEL, 260, 140, 60, 14
    PUSHBUTTON "Excluir T&odos", psh4, 5, 140, 75, 14
}

IDD_ADDMITEM DIALOG 0, 0, 210, 200
CAPTION "Adicionar Item de Menu"
STYLE DS_MODALFRAME | WS_POPUPWINDOW | WS_CAPTION
FONT 9, "MS Shell Dlg"
{
    LTEXT "Legend&a", -1, 5, 7, 55, 12
    COMBOBOX cmb1, 65, 6, 140, 200, CBS_AUTOHSCROLL | CBS_DROPDOWN | WS_BORDER | WS_VSCROLL | WS_TABSTOP
    LTEXT "&ID do Comando:", -1, 5, 32, 55, 12
    COMBOBOX cmb2, 65, 30, 125, 200, CBS_AUTOHSCROLL | CBS_DROPDOWN | WS_BORDER | WS_VSCROLL | WS_TABSTOP
    PUSHBUTTON "&...", psh1, 190, 30, 15, 14
    AUTOCHECKBOX "&GRAYED", chx1, 5, 60, 60, 14
    AUTOCHECKBOX "&BITMAP", chx3, 135, 60, 60, 14
    AUTOCHECKBOX "&OWNERDRAW", chx4, 5, 80, 65, 14
    AUTOCHECKBOX "&CHECKED", chx5, 75, 80, 60, 14
    AUTOCHECKBOX "SE&PARATOR", chx6, 140, 80, 60, 14
    AUTOCHECKBOX "MENU&BARBREAK", chx7, 5, 100, 75, 14
    AUTOCHECKBOX "MENUB&REAK", chx8, 85, 100, 70, 14
    AUTOCHECKBOX "&DEFAULT", chx9, 5, 120, 60, 14
    AUTOCHECKBOX "&HILITE", chx10, 70, 120, 60, 14
    AUTOCHECKBOX "RADIOCHEC&K", chx11, 135, 120, 60, 14
    AUTOCHECKBOX "RIGH&TORDER", chx12, 5, 139, 60, 14
    AUTOCHECKBOX "RIGHT&JUSTIFY", chx13, 70, 140, 70, 14
    LTEXT "ID de Aj&uda:", -1, 5, 162, 45, 12
    COMBOBOX cmb3, 55, 160, 100, 300, CBS_AUTOHSCROLL | CBS_DROPDOWN | WS_BORDER | WS_VSCROLL | WS_TABSTOP
    DEFPUSHBUTTON "OK", IDOK, 80, 180, 60, 14
    PUSHBUTTON "Cancelar", IDCANCEL, 145, 180, 60, 14
}

IDD_MODIFYMITEM DIALOG 0, 0, 210, 200
CAPTION "Modificar Item de Menu"
STYLE DS_MODALFRAME | WS_POPUPWINDOW | WS_CAPTION
FONT 9, "MS Shell Dlg"
{
    LTEXT "Legend&a", -1, 5, 7, 55, 12
    COMBOBOX cmb1, 65, 6, 140, 200, CBS_AUTOHSCROLL | CBS_DROPDOWN | WS_BORDER | WS_VSCROLL | WS_TABSTOP
    LTEXT "&ID do Comando:", -1, 5, 32, 55, 12
    COMBOBOX cmb2, 65, 30, 125, 200, CBS_AUTOHSCROLL | CBS_DROPDOWN | WS_BORDER | WS_VSCROLL | WS_TABSTOP
    PUSHBUTTON "&...", psh1, 190, 30, 15, 14
    AUTOCHECKBOX "&GRAYED", chx1, 5, 60, 60, 14
    AUTOCHECKBOX "BIT&MAP", chx3, 135, 60, 60, 14
    AUTOCHECKBOX "&OWNERDRAW", chx4, 5, 80, 65, 14
    AUTOCHECKBOX "&CHECKED", chx5, 75, 80, 60, 14
    AUTOCHECKBOX "SE&PARATOR", chx6, 140, 80, 60, 14
    AUTOCHECKBOX "MENU&BARBREAK", chx7, 5, 100, 75, 14
    AUTOCHECKBOX "MENUB&REAK", chx8, 85, 100, 70, 14
    AUTOCHECKBOX "&DEFAULT", chx9, 5, 120, 60, 14
    AUTOCHECKBOX "&HILITE", chx10, 70, 120, 60, 14
    AUTOCHECKBOX "RADIOCHEC&K", chx11, 135, 120, 60, 14
    AUTOCHECKBOX "RIGH&TORDER", chx12, 5, 139, 60, 14
    AUTOCHECKBOX "RIGHT&JUSTIFY", chx13, 70, 140, 70, 14
    LTEXT "ID de Aj&uda:", -1, 5, 162, 45, 12
    COMBOBOX cmb3, 55, 160, 100, 300, CBS_AUTOHSCROLL | CBS_DROPDOWN | WS_BORDER | WS_VSCROLL | WS_TABSTOP
    DEFPUSHBUTTON "OK", IDOK, 80, 180, 60, 14
    PUSHBUTTON "Cancelar", IDCANCEL, 145, 180, 60, 14
}

IDD_EDITMENU DIALOG 0, 0, 325, 160
CAPTION "Editar Recurso do Menu"
STYLE WS_POPUPWINDOW | WS_CAPTION | WS_THICKFRAME
FONT 9, "MS Shell Dlg"
{
    LTEXT "Recur&so de Menu:", -1, 5, 7, 85, 12
    CONTROL "", lst1, "SysListView32", LVS_NOSORTHEADER | LVS_AUTOARRANGE | LVS_NOLABELWRAP | LVS_SHOWSELALWAYS | LVS_SINGLESEL | LVS_REPORT | WS_BORDER | WS_VSCROLL | WS_HSCROLL | WS_TABSTOP, 5, 20, 315, 115
    PUSHBUTTON "&Adicionar...", psh1, 95, 3, 50, 14
    PUSHBUTTON "&Modificar...", psh2, 150, 3, 50, 14
    PUSHBUTTON "E&xcluir", psh3, 205, 3, 50, 14
    PUSHBUTTON "A&cima", psh4, 5, 140, 40, 14
    PUSHBUTTON "A&baixo", psh5, 50, 140, 40, 14
    PUSHBUTTON "&Esquerda", psh6, 95, 140, 40, 14
    PUSHBUTTON "&Direita", psh7, 140, 140, 41, 14
    AUTOCHECKBOX "Es&tendido", chx1, 260, 3, 60, 14
    DEFPUSHBUTTON "OK", IDOK, 195, 140, 60, 14
    PUSHBUTTON "Cancelar", IDCANCEL, 260, 140, 60, 14
}

IDD_DLGPROP DIALOG 0, 0, 235, 315
CAPTION "Propriedades do Diálogo"
STYLE DS_MODALFRAME | WS_POPUPWINDOW | WS_CAPTION
FONT 9, "MS Shell Dlg"
{
    LTEXT "Legend&a", -1, 5, 7, 85, 11
    COMBOBOX cmb1, 5, 20, 225, 300, CBS_HASSTRINGS | CBS_AUTOHSCROLL | CBS_DROPDOWN | WS_BORDER | WS_VSCROLL | WS_TABSTOP
    AUTOCHECKBOX "Diálogo Este&ndido", chx1, 100, 5, 86, 14
    LTEXT "&Esquerda:", -1, 5, 40, 33, 10
    EDITTEXT edt1, 5, 53, 30, 14, ES_NUMBER | ES_RIGHT
    CONTROL "", scr1, "msctls_updown32", UDS_NOTHOUSANDS | UDS_ARROWKEYS | UDS_AUTOBUDDY | UDS_ALIGNRIGHT | UDS_SETBUDDYINT, 23, 53, 12, 20
    LTEXT "T&opo:", -1, 50, 40, 33, 10
    EDITTEXT edt2, 50, 53, 30, 14, ES_NUMBER | ES_RIGHT
    CONTROL "", scr2, "msctls_updown32", UDS_NOTHOUSANDS | UDS_ARROWKEYS | UDS_AUTOBUDDY | UDS_ALIGNRIGHT | UDS_SETBUDDYINT, 53, 53, 12, 20
    LTEXT "Lar&gura:", -1, 95, 40, 33, 10
    EDITTEXT edt3, 95, 53, 30, 14, ES_NUMBER | ES_RIGHT
    CONTROL "", scr3, "msctls_updown32", UDS_NOTHOUSANDS | UDS_ARROWKEYS | UDS_AUTOBUDDY | UDS_ALIGNRIGHT | UDS_SETBUDDYINT, 129, 56, 12, 20
    LTEXT "&Altura:", -1, 142, 40, 33, 10
    EDITTEXT edt4, 142, 53, 30, 14, ES_NUMBER | ES_RIGHT
    CONTROL "", scr4, "msctls_updown32", UDS_NOTHOUSANDS | UDS_ARROWKEYS | UDS_AUTOBUDDY | UDS_ALIGNRIGHT | UDS_SETBUDDYINT, 162, 53, 12, 20
    LTEXT "Nome da Cla&sse:", -1, 5, 73, 85, 11
    COMBOBOX cmb2, 5, 88, 115, 200, CBS_HASSTRINGS | CBS_AUTOHSCROLL | CBS_DROPDOWN | WS_BORDER | WS_VSCROLL | WS_TABSTOP
    LTEXT "ID de Aj&uda:", -1, 125, 73, 64, 11
    COMBOBOX cmb3, 125, 88, 65, 200, CBS_HASSTRINGS | CBS_AUTOHSCROLL | CBS_DROPDOWN | WS_BORDER | WS_VSCROLL | WS_TABSTOP
    LTEXT "Nome da &Fonte:", -1, 5, 105, 80, 11
    COMBOBOX cmb4, 6, 118, 100, 200, CBS_HASSTRINGS | CBS_SORT | CBS_AUTOHSCROLL | CBS_DROPDOWN | WS_BORDER | WS_VSCROLL | WS_TABSTOP
    LTEXT "&Tamanho:", -1, 110, 105, 38, 12
    EDITTEXT edt5, 110, 118, 25, 14, ES_NUMBER
    AUTOCHECKBOX "&B", chx2, 140, 118, 20, 14
    AUTOCHECKBOX "&I", chx3, 165, 118, 20, 14
    LTEXT "Cha&rSet:", -1, 5, 138, 80, 11
    COMBOBOX cmb5, 5, 148, 100, 100, CBS_AUTOHSCROLL | CBS_DROPDOWNLIST | WS_VSCROLL | WS_TABSTOP
    LTEXT "Nome do &Menu:", -1, 110, 138, 55, 11
    COMBOBOX cmb6, 110, 148, 99, 300, CBS_HASSTRINGS | CBS_AUTOHSCROLL | CBS_DROPDOWN | WS_BORDER | WS_VSCROLL | WS_TABSTOP
    LTEXT "Esti&lo:", -1, 5, 168, 45, 11
    RTEXT "0x", -1, 52, 169, 10, 11
    EDITTEXT edt6, 67, 165, 45, 14, ES_AUTOHSCROLL
    LISTBOX lst1, 5, 183, 110, 110, LBS_DISABLENOSCROLL | LBS_NOINTEGRALHEIGHT | LBS_HASSTRINGS | LBS_MULTIPLESEL | WS_VSCROLL | WS_HSCROLL | WS_TABSTOP
    LTEXT "&ExStyle:", -1, 120, 168, 48, 11
    RTEXT "0x", -1, 170, 169, 10, 11
    EDITTEXT edt7, 185, 165, 45, 14, ES_AUTOHSCROLL
    LISTBOX lst2, 120, 183, 110, 110, LBS_DISABLENOSCROLL | LBS_NOINTEGRALHEIGHT | LBS_HASSTRINGS | LBS_MULTIPLESEL | WS_VSCROLL | WS_HSCROLL | WS_TABSTOP
    DEFPUSHBUTTON "OK", IDOK, 106, 298, 60, 14
    PUSHBUTTON "Cancelar", IDCANCEL, 171, 298, 60, 14
}

IDD_CTRLPROP DIALOG 0, 0, 235, 330
CAPTION "Propriedades do Controle"
STYLE DS_MODALFRAME | WS_POPUPWINDOW | WS_CAPTION
FONT 9, "MS Shell Dlg"
{
    LTEXT "Predef. &Ctrl:", -1, 5, 7, 68, 12
    COMBOBOX cmb1, 75, 5, 120, 55, CBS_HASSTRINGS | CBS_AUTOHSCROLL | CBS_DROPDOWN | WS_BORDER | WS_VSCROLL | WS_TABSTOP
    CONTROL "", ctl1, "ToolbarWindow32", TBSTYLE_FLAT | TBSTYLE_WRAPABLE | TBSTYLE_TOOLTIPS | CCS_NODIVIDER | CCS_NORESIZE, 5, 22, 185, 30
    LTEXT "Legend&a", -1, 5, 55, 75, 12
    COMBOBOX cmb2, 5, 65, 195, 300, CBS_HASSTRINGS | CBS_AUTOHSCROLL | CBS_DROPDOWN | WS_BORDER | WS_VSCROLL | WS_TABSTOP
    PUSHBUTTON "&OLE...", psh2, 205, 65, 25, 14
    LTEXT "&Esquerda:", -1, 5, 85, 33, 11
    EDITTEXT edt1, 5, 99, 25, 14, ES_NUMBER | ES_RIGHT
    CONTROL "", scr1, "msctls_updown32", UDS_NOTHOUSANDS | UDS_ARROWKEYS | UDS_AUTOBUDDY | UDS_ALIGNRIGHT | UDS_SETBUDDYINT, 20, 99, 12, 20
    LTEXT "T&opo:", -1, 40, 85, 33, 11
    EDITTEXT edt2, 40, 99, 25, 14, ES_NUMBER | ES_RIGHT
    CONTROL "", scr2, "msctls_updown32", UDS_NOTHOUSANDS | UDS_ARROWKEYS | UDS_AUTOBUDDY | UDS_ALIGNRIGHT | UDS_SETBUDDYINT, 55, 99, 12, 20
    LTEXT "&Largura:", -1, 75, 85, 33, 11
    EDITTEXT edt3, 75, 99, 25, 14, ES_NUMBER | ES_RIGHT
    CONTROL "", scr3, "msctls_updown32", UDS_NOTHOUSANDS | UDS_ARROWKEYS | UDS_AUTOBUDDY | UDS_ALIGNRIGHT | UDS_SETBUDDYINT, 90, 99, 12, 20
    LTEXT "&Altura:", -1, 111, 85, 33, 11
    EDITTEXT edt4, 110, 99, 25, 14, ES_NUMBER | ES_RIGHT
    CONTROL "", scr4, "msctls_updown32", UDS_NOTHOUSANDS | UDS_ARROWKEYS | UDS_AUTOBUDDY | UDS_ALIGNRIGHT | UDS_SETBUDDYINT, 125, 99, 12, 20
    LTEXT "&ID:", -1, 150, 85, 70, 12
    COMBOBOX cmb3, 150, 99, 80, 300, CBS_HASSTRINGS | CBS_AUTOHSCROLL | CBS_DROPDOWN | WS_BORDER | WS_VSCROLL | WS_TABSTOP
    LTEXT "Nome da Cla&sse do Windows:", -1, 5, 119, 100, 12
    COMBOBOX cmb4, 5, 133, 115, 200, CBS_HASSTRINGS | CBS_AUTOHSCROLL | CBS_DROPDOWN | WS_BORDER | WS_VSCROLL | WS_TABSTOP
    LTEXT "ID de Aj&uda:", -1, 125, 119, 70, 12
    COMBOBOX cmb5, 125, 133, 65, 200, CBS_HASSTRINGS | CBS_AUTOHSCROLL | CBS_DROPDOWN | WS_BORDER | WS_VSCROLL | WS_TABSTOP
    LTEXT "Es&tilo:", -1, 5, 153, 45, 12
    RTEXT "0x", -1, 54, 153, 10, 12
    EDITTEXT edt6, 70, 151, 45, 14, ES_AUTOHSCROLL
    LISTBOX lst1, 5, 167, 110, 120, LBS_DISABLENOSCROLL | LBS_NOINTEGRALHEIGHT | LBS_HASSTRINGS | LBS_MULTIPLESEL | WS_VSCROLL | WS_HSCROLL | WS_TABSTOP
    LTEXT "&ExStyle:", -1, 120, 153, 50, 12
    RTEXT "0x", -1, 172, 153, 10, 12
    EDITTEXT edt7, 185, 151, 45, 14, ES_AUTOHSCROLL
    LISTBOX lst2, 120, 167, 110, 120, LBS_DISABLENOSCROLL | LBS_NOINTEGRALHEIGHT | LBS_HASSTRINGS | LBS_MULTIPLESEL | WS_VSCROLL | WS_HSCROLL | WS_TABSTOP
    DEFPUSHBUTTON "OK", IDOK, 170, 293, 60, 14
    PUSHBUTTON "Cancelar", IDCANCEL, 170, 309, 60, 14
    PUSHBUTTON "&Dados...", psh1, 5, 293, 90, 14
    PUSHBUTTON "A l&ista de string...", psh3, 5, 309, 90, 14
}

IDD_ADDCTRL DIALOG 0, 0, 235, 330
CAPTION "Adicionar Controle"
STYLE DS_MODALFRAME | WS_POPUPWINDOW | WS_CAPTION
FONT 9, "MS Shell Dlg"
{
    LTEXT "Predef. &Ctrl:", -1, 5, 7, 68, 12
    COMBOBOX cmb1, 75, 5, 120, 55, CBS_HASSTRINGS | CBS_AUTOHSCROLL | CBS_DROPDOWN | WS_BORDER | WS_VSCROLL | WS_TABSTOP
    CONTROL "", ctl1, "ToolbarWindow32", TBSTYLE_FLAT | TBSTYLE_WRAPABLE | TBSTYLE_TOOLTIPS | CCS_NODIVIDER | CCS_NORESIZE, 5, 22, 185, 30
    LTEXT "Legend&a", -1, 5, 55, 75, 12
    COMBOBOX cmb2, 5, 65, 195, 300, CBS_HASSTRINGS | CBS_AUTOHSCROLL | CBS_DROPDOWN | WS_BORDER | WS_VSCROLL | WS_TABSTOP
    PUSHBUTTON "&OLE...", psh2, 205, 65, 25, 14
    LTEXT "&Esquerda:", -1, 5, 85, 33, 11
    EDITTEXT edt1, 5, 99, 25, 14, ES_NUMBER | ES_RIGHT
    CONTROL "", scr1, "msctls_updown32", UDS_NOTHOUSANDS | UDS_ARROWKEYS | UDS_AUTOBUDDY | UDS_ALIGNRIGHT | UDS_SETBUDDYINT, 20, 99, 12, 20
    LTEXT "T&opo:", -1, 40, 85, 33, 11
    EDITTEXT edt2, 40, 99, 25, 14, ES_NUMBER | ES_RIGHT
    CONTROL "", scr2, "msctls_updown32", UDS_NOTHOUSANDS | UDS_ARROWKEYS | UDS_AUTOBUDDY | UDS_ALIGNRIGHT | UDS_SETBUDDYINT, 55, 99, 12, 20
    LTEXT "&Largura:", -1, 75, 85, 33, 11
    EDITTEXT edt3, 75, 99, 25, 14, ES_NUMBER | ES_RIGHT
    CONTROL "", scr3, "msctls_updown32", UDS_NOTHOUSANDS | UDS_ARROWKEYS | UDS_AUTOBUDDY | UDS_ALIGNRIGHT | UDS_SETBUDDYINT, 90, 99, 12, 20
    LTEXT "&Altura:", -1, 111, 85, 33, 11
    EDITTEXT edt4, 110, 99, 25, 14, ES_NUMBER | ES_RIGHT
    CONTROL "", scr4, "msctls_updown32", UDS_NOTHOUSANDS | UDS_ARROWKEYS | UDS_AUTOBUDDY | UDS_ALIGNRIGHT | UDS_SETBUDDYINT, 125, 99, 12, 20
    LTEXT "&ID:", -1, 150, 85, 70, 12
    COMBOBOX cmb3, 150, 99, 80, 300, CBS_HASSTRINGS | CBS_AUTOHSCROLL | CBS_DROPDOWN | WS_BORDER | WS_VSCROLL | WS_TABSTOP
    LTEXT "Nome da Cla&sse do Windows:", -1, 5, 119, 100, 12
    COMBOBOX cmb4, 5, 133, 115, 200, CBS_HASSTRINGS | CBS_AUTOHSCROLL | CBS_DROPDOWN | WS_BORDER | WS_VSCROLL | WS_TABSTOP
    LTEXT "ID de Aj&uda:", -1, 125, 119, 70, 12
    COMBOBOX cmb5, 125, 133, 65, 200, CBS_HASSTRINGS | CBS_AUTOHSCROLL | CBS_DROPDOWN | WS_BORDER | WS_VSCROLL | WS_TABSTOP
    LTEXT "Es&tilo:", -1, 5, 153, 45, 12
    RTEXT "0x", -1, 54, 153, 10, 12
    EDITTEXT edt6, 70, 151, 45, 14, ES_AUTOHSCROLL
    LISTBOX lst1, 5, 167, 110, 120, LBS_DISABLENOSCROLL | LBS_NOINTEGRALHEIGHT | LBS_HASSTRINGS | LBS_MULTIPLESEL | WS_VSCROLL | WS_HSCROLL | WS_TABSTOP
    LTEXT "&ExStyle:", -1, 120, 153, 50, 12
    RTEXT "0x", -1, 172, 153, 10, 12
    EDITTEXT edt7, 185, 151, 45, 14, ES_AUTOHSCROLL
    LISTBOX lst2, 120, 167, 110, 120, LBS_DISABLENOSCROLL | LBS_NOINTEGRALHEIGHT | LBS_HASSTRINGS | LBS_MULTIPLESEL | WS_VSCROLL | WS_HSCROLL | WS_TABSTOP
    DEFPUSHBUTTON "OK", IDOK, 170, 293, 60, 14
    PUSHBUTTON "Cancelar", IDCANCEL, 170, 309, 60, 14
    PUSHBUTTON "&Dados...", psh1, 5, 293, 90, 14
    PUSHBUTTON "A l&ista de string...", psh3, 5, 309, 90, 14
}

IDD_IDASSOC DIALOG 0, 0, 200, 220
CAPTION "ID de Associação"
STYLE DS_MODALFRAME | WS_POPUPWINDOW | WS_CAPTION
FONT 9, "MS Shell Dlg"
{
    LTEXT "ID de &Associação:", -1, 5, 5, 116, 12
    CONTROL "", lst1, "SysListView32", LVS_SHOWSELALWAYS | LVS_SINGLESEL | LVS_REPORT | WS_BORDER | WS_TABSTOP, 5, 20, 190, 150
    PUSHBUTTON "&Redefinir Todos", psh2, 5, 175, 85, 14
    PUSHBUTTON "&Modificar", psh1, 135, 175, 60, 14
    DEFPUSHBUTTON "OK", IDOK, 70, 200, 60, 14
    PUSHBUTTON "Cancelar", IDCANCEL, 135, 200, 60, 14
}

IDD_MODIFYASSOC DIALOG 0, 0, 165, 68
CAPTION "Modificar ID de Associação"
STYLE DS_MODALFRAME | WS_POPUPWINDOW | WS_CAPTION
FONT 9, "MS Shell Dlg"
{
    RTEXT "&Tipo de ID:", -1, 5, 7, 65, 12
    EDITTEXT edt1, 80, 5, 80, 14, WS_DISABLED
    RTEXT "&Prefixo de ID:", -1, 5, 32, 65, 12
    EDITTEXT edt2, 80, 28, 80, 14, ES_AUTOHSCROLL
    DEFPUSHBUTTON "OK", IDOK, 35, 50, 60, 14
    PUSHBUTTON "Cancelar", IDCANCEL, 100, 50, 60, 14
}

IDD_IDLIST DIALOG 0, 0, 200, 300
CAPTION "Lista de IDs de Recursos"
STYLE WS_OVERLAPPEDWINDOW
EXSTYLE WS_EX_TOOLWINDOW
FONT 9, "MS Shell Dlg"
{
    COMBOBOX cmb1, 0, 0, 200, 300, CBS_HASSTRINGS | CBS_SORT | CBS_OWNERDRAWFIXED | CBS_DROPDOWNLIST | WS_VSCROLL | WS_TABSTOP
    CONTROL "", lst1, "SysListView32", LVS_REPORT | WS_BORDER | WS_VSCROLL | WS_HSCROLL | WS_TABSTOP, 0, 15, 200, 285
}

IDD_CONFIG DIALOG 0, 0, 210, 285
CAPTION "Configuração"
STYLE DS_MODALFRAME | WS_POPUPWINDOW | WS_CAPTION
FONT 9, "MS Shell Dlg"
{
    AUTOCHECKBOX "Mostrar &caminho completo do arquivo na barra de título", chx1, 5, 5, 200, 14
    AUTOCHECKBOX "&Não usar macros de ID", chx2, 5, 25, 200, 14
    AUTOCHECKBOX "Re&tomar a posição da janela anterior", chx3, 5, 45, 200, 14
    AUTOCHECKBOX "Carre&gar ""resource.h"" perto automaticamente", chx4, 5, 65, 200, 14
    AUTOCHECKBOX "Mostrar automaticamente a &lista de IDs de recursos", chx5, 5, 85, 200, 14
    AUTOCHECKBOX "Mostrar &pontos na edição de diálogo", chx6, 5, 105, 200, 14
    RTEXT "Altura do Combo&Box:", -1, 10, 127, 75, 12
    EDITTEXT edt1, 90, 125, 34, 14, ES_NUMBER | ES_RIGHT
    CONTROL "", scr1, "msctls_updown32", UDS_NOTHOUSANDS | UDS_ARROWKEYS | UDS_AUTOBUDDY | UDS_ALIGNRIGHT | UDS_SETBUDDYINT, 129, 49, 12, 20
    AUTOCHECKBOX "&Quebra de palavras", chx9, 128, 125, 75, 14
    AUTOCHECKBOX "Perguntar ao atuali&zar ""resource.h""'s", chx7, 5, 145, 200, 14
    AUTOCHECKBOX "Comprimir EXE com &UPX ao salva-lo", chx8, 5, 165, 200, 14
    PUSHBUTTON "&Fontes...", psh4, 5, 185, 200, 14
    PUSHBUTTON "&Macros predefinidas...", psh1, 5, 205, 93, 14
    PUSHBUTTON "Definir camin&hos...", psh2, 107, 205, 98, 14
    RTEXT "Nome de controles &OLE:", -1, 5, 227, 80, 12
    COMBOBOX cmb1, 90, 225, 75, 300, CBS_HASSTRINGS | CBS_AUTOHSCROLL | CBS_DROPDOWN | WS_VSCROLL | WS_TABSTOP
    AUTOCHECKBOX "Criar bac&kup", chx10, 5, 245, 75, 15
    RTEXT "Sufixo de backup:", -1, 90, 245, 60, 15
    COMBOBOX cmb2, 158, 244, 45, 300, CBS_HASSTRINGS | CBS_AUTOHSCROLL | CBS_DROPDOWN | WS_VSCROLL | WS_TABSTOP
    DEFPUSHBUTTON "OK", IDOK, 100, 265, 50, 14
    PUSHBUTTON "Cancelar", IDCANCEL, 155, 265, 50, 14
    PUSHBUTTON "&Redefinir Todos", psh3, 5, 265, 75, 14
}

IDD_ADDRESID DIALOG 0, 0, 165, 90
CAPTION "Adicionar ID de Recurso"
STYLE DS_MODALFRAME | WS_POPUPWINDOW | WS_CAPTION
FONT 9, "MS Shell Dlg"
{
    RTEXT "&Tipo de ID:", -1, 10, 7, 50, 14
    COMBOBOX cmb1, 65, 5, 95, 300, CBS_AUTOHSCROLL | CBS_DROPDOWNLIST | WS_VSCROLL | WS_TABSTOP
    RTEXT "&Nome do ID:", -1, 10, 27, 50, 14
    EDITTEXT edt1, 65, 25, 75, 14, ES_AUTOHSCROLL
    RTEXT "Valor &Inteiro:", -1, 10, 47, 50, 14
    EDITTEXT edt2, 65, 45, 48, 14, ES_AUTOHSCROLL
    CONTROL "", scr1, "msctls_updown32", UDS_NOTHOUSANDS | UDS_ARROWKEYS | UDS_AUTOBUDDY | UDS_ALIGNRIGHT | UDS_SETBUDDYINT, 129, 49, 12, 20
    PUSHBUTTON "&Auto", psh1, 115, 45, 45, 14
    DEFPUSHBUTTON "OK", IDOK, 20, 70, 60, 14
    PUSHBUTTON "Cancelar", IDCANCEL, 85, 70, 60, 14
}

IDD_MODIFYRESID DIALOG 0, 0, 165, 90
CAPTION "Modificar ID de Recurso"
STYLE DS_MODALFRAME | WS_POPUPWINDOW | WS_CAPTION
FONT 9, "MS Shell Dlg"
{
    RTEXT "&Nome do ID:", -1, 10, 12, 50, 14, SS_REALSIZEIMAGE | NOT WS_GROUP
    EDITTEXT edt1, 65, 10, 95, 14, ES_AUTOHSCROLL
    RTEXT "&Tipo de ID:", -1, 10, 32, 50, 14
    EDITTEXT edt2, 65, 30, 95, 14, ES_READONLY
    RTEXT "Valor &Inteiro:", -1, 10, 52, 50, 14
    EDITTEXT edt3, 65, 50, 48, 14, ES_AUTOHSCROLL
    CONTROL "", scr1, "msctls_updown32", UDS_NOTHOUSANDS | UDS_ARROWKEYS | UDS_AUTOBUDDY | UDS_ALIGNRIGHT | UDS_SETBUDDYINT, 129, 49, 12, 20
    DEFPUSHBUTTON "OK", IDOK, 20, 70, 60, 14
    PUSHBUTTON "Cancelar", IDCANCEL, 85, 70, 60, 14
}

IDD_ADVICERESH DIALOG 0, 0, 209, 184
CAPTION "Conselho de modificação do arquivo ""resource.h"""
STYLE DS_MODALFRAME | WS_POPUPWINDOW | WS_CAPTION
FONT 9, "MS Shell Dlg"
{
    LTEXT "Por favor, modifique o arquivo ""resource.h"" Da seguinte forma:", -1, 10, 10, 195, 20
    EDITTEXT edt1, 10, 30, 190, 130, ES_READONLY | ES_MULTILINE
    DEFPUSHBUTTON "OK", IDOK, 140, 165, 60, 14
    PUSHBUTTON "&Limpar Modificação", psh1, 10, 165, 90, 14
}

IDD_CLONEINNEWNAME DIALOG 0, 0, 215, 75
CAPTION "Clonar Para Um Novo Nome"
STYLE DS_MODALFRAME | WS_POPUPWINDOW | WS_CAPTION
FONT 9, "MS Shell Dlg"
{
    LTEXT "&Tipo de Recurso:", -1, 5, 7, 70, 12
    COMBOBOX cmb1, 75, 5, 135, 200, CBS_HASSTRINGS | CBS_AUTOHSCROLL | CBS_DROPDOWN | WS_DISABLED | WS_BORDER | WS_VSCROLL | WS_TABSTOP
    LTEXT "&Nome do Recurso:", -1, 5, 32, 70, 12
    COMBOBOX cmb2, 75, 30, 120, 200, CBS_HASSTRINGS | CBS_AUTOHSCROLL | CBS_DROPDOWN | WS_BORDER | WS_VSCROLL | WS_TABSTOP
    PUSHBUTTON "&...", psh1, 195, 30, 15, 14
    DEFPUSHBUTTON "OK", IDOK, 35, 55, 60, 14
    PUSHBUTTON "Cancelar", IDCANCEL, 115, 55, 60, 14
}

IDD_CLONEINNEWLANG DIALOG 0, 0, 215, 105
CAPTION "Clonar Para Um Novo Idioma"
STYLE DS_MODALFRAME | WS_POPUPWINDOW | WS_CAPTION
FONT 9, "MS Shell Dlg"
{
    LTEXT "&Tipo de Recurso:", -1, 5, 7, 70, 12
    COMBOBOX cmb1, 75, 5, 135, 200, CBS_HASSTRINGS | CBS_AUTOHSCROLL | CBS_DROPDOWN | WS_DISABLED | WS_BORDER | WS_VSCROLL | WS_TABSTOP
    LTEXT "&Nome do Recurso:", -1, 5, 32, 70, 12
    COMBOBOX cmb2, 75, 30, 120, 200, CBS_HASSTRINGS | CBS_AUTOHSCROLL | CBS_DROPDOWN | WS_DISABLED | WS_BORDER | WS_VSCROLL | WS_TABSTOP
    LTEXT "&Idioma do Recurso:", -1, 5, 57, 70, 12
    COMBOBOX cmb3, 75, 55, 135, 200, CBS_HASSTRINGS | CBS_AUTOHSCROLL | CBS_DROPDOWN | WS_BORDER | WS_VSCROLL | WS_TABSTOP
    DEFPUSHBUTTON "OK", IDOK, 35, 85, 60, 14
    PUSHBUTTON "Cancelar", IDCANCEL, 115, 85, 60, 14
}

IDD_ITEMSEARCH DIALOG 0, 0, 171, 135
CAPTION "Pesquisar"
STYLE WS_POPUPWINDOW | WS_CAPTION
FONT 9, "MS Shell Dlg"
{
    LTEXT "&String para pesquisar:", -1, 4, 10, 100, 14
    EDITTEXT edt1, 5, 25, 160, 15, ES_AUTOHSCROLL
    AUTOCHECKBOX "Diferenciar &maiúscula/minúscula", chx1, 5, 45, 120, 18
    GROUPBOX "Direção", -1, 5, 65, 160, 42
    AUTORADIOBUTTON "&Acima", rad1, 15, 80, 60, 14, WS_TABSTOP
    AUTORADIOBUTTON "A&baixo", rad2, 90, 80, 60, 14, WS_TABSTOP
    DEFPUSHBUTTON "&Localizar", IDOK, 40, 115, 60, 14
    PUSHBUTTON "Cancelar", IDCANCEL, 105, 115, 60, 14
}

IDD_VERSIONINFO DIALOG 0, 0, 174, 150
CAPTION "Sobre RisohEditor"
STYLE DS_MODALFRAME | WS_POPUPWINDOW | WS_CAPTION
FONT 12, "MS Shell Dlg"
{
    ICON IDI_MAIN, -1, 5, 5, 0, 0
    LTEXT "...", stc1, 30, 5, 140, 50
    CTEXT "https://katahiromz.web.fc2.com", stc2, 5, 60, 165, 12, SS_CENTERIMAGE | SS_NOTIFY | NOT WS_GROUP
    CONTROL "...", edt1, "EDIT", ES_READONLY | ES_AUTOHSCROLL | ES_AUTOVSCROLL | ES_MULTILINE | WS_BORDER | WS_VSCROLL | WS_HSCROLL, 5, 75, 165, 50
    DEFPUSHBUTTON "OK", IDOK, 55, 130, 60, 14
}

IDD_ADDMSG DIALOG 0, 0, 255, 105
CAPTION "Adicionar Entrada de Mensagem"
STYLE DS_MODALFRAME | WS_POPUPWINDOW | WS_CAPTION
FONT 9, "MS Shell Dlg"
{
    LTEXT "&ID da Mensagem:", -1, 5, 7, 50, 12
    COMBOBOX cmb1, 65, 5, 134, 200, CBS_HASSTRINGS | CBS_AUTOHSCROLL | CBS_DROPDOWN | WS_BORDER | WS_VSCROLL | WS_TABSTOP
    PUSHBUTTON "&...", psh1, 200, 5, 15, 14
    LTEXT "&Valor da Mensagem:", -1, 5, 27, 80, 12
    EDITTEXT edt1, 5, 40, 245, 35, ES_WANTRETURN | ES_AUTOHSCROLL | ES_AUTOVSCROLL | ES_MULTILINE
    DEFPUSHBUTTON "OK", IDOK, 125, 85, 60, 14
    PUSHBUTTON "Cancelar", IDCANCEL, 190, 85, 60, 14
}

IDD_MODIFYMSG DIALOG 0, 0, 255, 105
CAPTION "Modificar Entrada de Mensagem"
STYLE DS_MODALFRAME | WS_POPUPWINDOW | WS_CAPTION
FONT 9, "MS Shell Dlg"
{
    LTEXT "&ID da Mensagem:", -1, 5, 7, 50, 12
    COMBOBOX cmb1, 65, 5, 134, 200, CBS_HASSTRINGS | CBS_AUTOHSCROLL | CBS_DROPDOWN | WS_DISABLED | WS_BORDER | WS_VSCROLL | WS_TABSTOP
    LTEXT "&Valor da Mensagem:", -1, 5, 27, 80, 12
    EDITTEXT edt1, 5, 40, 245, 35, ES_WANTRETURN | ES_AUTOHSCROLL | ES_AUTOVSCROLL | ES_MULTILINE
    DEFPUSHBUTTON "OK", IDOK, 125, 85, 60, 14
    PUSHBUTTON "Cancelar", IDCANCEL, 190, 85, 60, 14
}

IDD_MESSAGES DIALOG 0, 0, 325, 160
CAPTION "Tabela de Mensagens"
STYLE WS_POPUPWINDOW | WS_CAPTION | WS_THICKFRAME
FONT 9, "MS Shell Dlg"
{
    LTEXT "E&ntradas de Mensagem:", -1, 5, 7, 80, 12
    CONTROL "", lst1, "SysListView32", LVS_NOSORTHEADER | LVS_AUTOARRANGE | LVS_NOLABELWRAP | LVS_SHOWSELALWAYS | LVS_SINGLESEL | LVS_REPORT | WS_BORDER | WS_VSCROLL | WS_HSCROLL | WS_TABSTOP, 5, 20, 315, 115
    PUSHBUTTON "&Adicionar...", psh1, 130, 3, 60, 14
    PUSHBUTTON "&Modificar...", psh2, 195, 3, 60, 14
    PUSHBUTTON "&Excluir", psh3, 260, 3, 60, 14
    DEFPUSHBUTTON "OK", IDOK, 195, 140, 60, 14
    PUSHBUTTON "Cancelar", IDCANCEL, 260, 140, 60, 14
    PUSHBUTTON "Excluir T&odos", psh4, 5, 140, 75, 14
}

IDD_FONTS DIALOG 0, 0, 195, 110
CAPTION "Configurações de Fonte"
STYLE DS_MODALFRAME | WS_POPUPWINDOW | WS_CAPTION
FONT 9, "MS Shell Dlg"
{
    RTEXT "&Origem:", -1, 5, 5, 55, 15, SS_CENTERIMAGE | NOT WS_GROUP
    EDITTEXT edt1, 65, 5, 100, 14, ES_READONLY | ES_AUTOHSCROLL
    PUSHBUTTON "...", psh1, 170, 5, 19, 14
    RTEXT "&Binário:", -1, 5, 25, 55, 15, SS_CENTERIMAGE | NOT WS_GROUP
    EDITTEXT edt2, 65, 25, 100, 14, ES_READONLY | ES_AUTOHSCROLL
    PUSHBUTTON "...", psh2, 170, 25, 19, 14
    GROUPBOX "Visualizar", -1, 5, 45, 185, 39
    CTEXT "Origem", stc1, 15, 55, 80, 25, SS_CENTERIMAGE | NOT WS_GROUP
    CTEXT "Binário", stc2, 100, 55, 85, 25, SS_CENTERIMAGE | NOT WS_GROUP
    DEFPUSHBUTTON "OK", IDOK, 65, 90, 60, 14
    PUSHBUTTON "Cancelar", IDCANCEL, 130, 90, 60, 14
}

IDD_MACROS DIALOG 0, 0, 265, 165
CAPTION "Macros Predefinidas"
STYLE WS_POPUPWINDOW | WS_CAPTION | WS_THICKFRAME
FONT 9, "MS Shell Dlg"
{
    LTEXT "&Macros Predefinidas:", -1, 5, 0, 100, 15, SS_CENTERIMAGE | NOT WS_GROUP
    CONTROL "", lst1, "SysListView32", LVS_EDITLABELS | LVS_SHOWSELALWAYS | LVS_SINGLESEL | LVS_REPORT | WS_BORDER | WS_TABSTOP, 5, 15, 190, 125
    PUSHBUTTON "&Adicionar...", psh1, 200, 15, 60, 14
    PUSHBUTTON "&Editar...", psh2, 200, 35, 60, 14
    PUSHBUTTON "E&xcluir", psh3, 200, 55, 60, 14
    PUSHBUTTON "Excluir T&odos", psh7, 200, 105, 60, 14
    DEFPUSHBUTTON "OK", IDOK, 135, 145, 60, 14
    PUSHBUTTON "Cancelar", IDCANCEL, 200, 145, 60, 14
    PUSHBUTTON "&Redefinir Todos", psh6, 5, 145, 60, 14
}

IDD_ADDMACRO DIALOG 0, 0, 190, 80
CAPTION "Adicionar Macro Predefinida"
STYLE DS_MODALFRAME | WS_POPUPWINDOW | WS_CAPTION
FONT 9, "MS Shell Dlg"
{
    RTEXT "&Chave:", -1, 5, 12, 60, 14
    COMBOBOX cmb1, 70, 10, 110, 200, CBS_DROPDOWN | WS_BORDER | WS_VSCROLL | WS_TABSTOP
    RTEXT "&Valor:", -1, 5, 37, 60, 14
    COMBOBOX cmb2, 70, 35, 110, 300, CBS_DROPDOWN | WS_BORDER | WS_VSCROLL | WS_TABSTOP
    DEFPUSHBUTTON "OK", IDOK, 60, 60, 60, 14
    PUSHBUTTON "Cancelar", IDCANCEL, 125, 60, 60, 14
}

IDD_EDITMACRO DIALOG 0, 0, 190, 80
CAPTION "Editar Macro Predefinida"
STYLE DS_MODALFRAME | WS_POPUPWINDOW | WS_CAPTION
FONT 9, "MS Shell Dlg"
{
    RTEXT "&Chave:", -1, 5, 12, 60, 14
    COMBOBOX cmb1, 70, 10, 110, 200, CBS_DROPDOWN | WS_DISABLED | WS_BORDER | WS_VSCROLL | WS_TABSTOP
    RTEXT "&Valor:", -1, 5, 37, 60, 14
    COMBOBOX cmb2, 70, 35, 110, 300, CBS_DROPDOWN | WS_BORDER | WS_VSCROLL | WS_TABSTOP
    DEFPUSHBUTTON "OK", IDOK, 60, 60, 60, 14
    PUSHBUTTON "Cancelar", IDCANCEL, 125, 60, 60, 14
}

IDD_CTRLDATA DIALOG 0, 0, 190, 130
CAPTION "Editar Dados de Controle"
STYLE DS_MODALFRAME | WS_POPUPWINDOW | WS_CAPTION
FONT 9, "MS Shell Dlg"
{
    LTEXT "Dados &Binários:", -1, 5, 2, 87, 12
    EDITTEXT edt1, 5, 15, 180, 60, ES_AUTOVSCROLL | ES_MULTILINE | WS_VSCROLL
    LTEXT "Você pode definir os dados de controle por inteiros de 16 bits separados por espaço.", -1, 5, 80, 180, 25
    DEFPUSHBUTTON "OK", IDOK, 60, 110, 60, 14
    PUSHBUTTON "Cancelar", IDCANCEL, 125, 110, 60, 14
}

IDD_PATHS DIALOG 0, 0, 295, 220
CAPTION "Definir Caminhos"
STYLE WS_POPUPWINDOW | WS_CAPTION | WS_THICKFRAME
FONT 9, "MS Shell Dlg"
{
    LTEXT "Diretórios &Incluídos:", -1, 5, 5, 102, 12
    LISTBOX lst1, 5, 20, 220, 105, LBS_NOINTEGRALHEIGHT | LBS_HASSTRINGS | LBS_SORT | WS_VSCROLL | WS_HSCROLL | WS_TABSTOP
    PUSHBUTTON "&Adicionar...", psh1, 230, 20, 60, 14
    PUSHBUTTON "&Editar...", psh2, 230, 40, 60, 14
    PUSHBUTTON "E&xcluir", psh3, 230, 60, 60, 14
    PUSHBUTTON "Aci&ma", psh4, 230, 80, 60, 14
    PUSHBUTTON "A&baixo", psh5, 230, 100, 60, 14
    PUSHBUTTON "Excluir T&odos", psh6, 5, 130, 95, 14
    RTEXT "&windres.exe:", stc1, 5, 157, 55, 12
    COMBOBOX cmb1, 70, 155, 155, 300, CBS_HASSTRINGS | CBS_AUTOHSCROLL | CBS_DROPDOWN | WS_VSCROLL | WS_TABSTOP
    PUSHBUTTON "&Procurar...", psh7, 230, 155, 60, 14
    RTEXT "&cpp.exe:", stc2, 5, 177, 55, 12
    COMBOBOX cmb2, 70, 175, 155, 300, CBS_HASSTRINGS | CBS_AUTOHSCROLL | CBS_DROPDOWN | WS_VSCROLL | WS_TABSTOP
    PUSHBUTTON "P&rocurar...", psh8, 230, 175, 60, 14
    DEFPUSHBUTTON "OK", IDOK, 165, 200, 60, 14
    PUSHBUTTON "Cancelar", IDCANCEL, 230, 200, 60, 14
    PUSHBUTTON "Redefinir &Todos", psh9, 5, 200, 95, 14
}

IDD_EXP_OPTIONS DIALOG 0, 0, 250, 225
CAPTION "Opções de Exportação"
STYLE DS_MODALFRAME | WS_POPUPWINDOW | WS_CAPTION
FONT 9, "MS Shell Dlg"
{
    ICON IDI_MAIN, -1, 5, 10, 0, 0
    LTEXT "Exportar um arquivo RC gerará alguns arquivos relacionados. Você pode escolher as seguintes opções:", -1, 35, 5, 210, 29
    AUTOCHECKBOX "Usar Microsoft MESSAGE&TABLE", chx8, 5, 40, 240, 14
    AUTOCHECKBOX "Arquivos de recursos separados por &idioma", chx1, 5, 60, 240, 14
    AUTOCHECKBOX "Usar palavras chaves B&EGIN/END", chx2, 5, 80, 240, 14
    AUTOCHECKBOX "Tornar a linguagem selecionável por LANGUAGE_* macro", chx3, 5, 100, 240, 14
    AUTOCHECKBOX "Criar &backup", chx4, 5, 120, 110, 14
    RTEXT "Sufixo de backup:", -1, 120, 122, 75, 12
    COMBOBOX cmb1, 200, 120, 45, 300, CBS_HASSTRINGS | CBS_AUTOHSCROLL | CBS_DROPDOWN | WS_VSCROLL | WS_TABSTOP
    AUTOCHECKBOX "Saída redundante e &comentários", chx5, 5, 140, 240, 14
    AUTOCHECKBOX "Quebrar as declarações de ma&nifesto por #ifndef MSVC ... #endif", chx6, 5, 160, 240, 14
    AUTOCHECKBOX "Saída de arquivo RC como &UTF-16", chx7, 5, 180, 240, 14
    DEFPUSHBUTTON "OK", IDOK, 120, 205, 60, 14
    PUSHBUTTON "Cancelar", IDCANCEL, 185, 205, 60, 14
}

IDD_LANGS DIALOG 0, 0, 250, 235
CAPTION "Idiomas"
STYLE WS_POPUPWINDOW | WS_CAPTION | WS_THICKFRAME
FONT 9, "MS Shell Dlg"
{
    CONTROL "", lst1, "SysListView32", LVS_SHOWSELALWAYS | LVS_SINGLESEL | LVS_REPORT | WS_BORDER | WS_TABSTOP, 5, 5, 240, 179
    RTEXT "&Pesquisar:", stc1, 5, 192, 45, 12
    COMBOBOX cmb1, 55, 190, 85, 300, CBS_SORT | CBS_DROPDOWN | WS_VSCROLL | WS_TABSTOP
    EDITTEXT edt1, 4, 209, 240, 20, ES_AUTOHSCROLL | ES_AUTOVSCROLL | ES_MULTILINE
}

IDD_CHILD DIALOG 0, 0, 215, 135
CAPTION "Diálogo Filho"
STYLE WS_CHILD | WS_OVERLAPPEDWINDOW
FONT 9, "MS Shell Dlg"
{
    DEFPUSHBUTTON "OK", IDOK, 35, 115, 60, 14
    PUSHBUTTON "Cancelar", IDCANCEL, 115, 115, 60, 14
}

IDD_DLGINITEDIT DIALOG 0, 0, 325, 165
CAPTION "Editar DLGINIT"
STYLE WS_POPUPWINDOW | WS_CAPTION | WS_THICKFRAME
FONT 9, "MS Shell Dlg"
{
    LTEXT "E&ntradas de Mensagem:", -1, 5, 7, 100, 12
    CONTROL "", lst1, "SysListView32", LVS_NOSORTHEADER | LVS_AUTOARRANGE | LVS_NOLABELWRAP | LVS_SHOWSELALWAYS | LVS_SINGLESEL | LVS_REPORT | WS_BORDER | WS_VSCROLL | WS_HSCROLL | WS_TABSTOP, 5, 20, 250, 120
    PUSHBUTTON "&Adicionar...", psh1, 260, 20, 60, 14
    PUSHBUTTON "&Modificar...", psh2, 260, 40, 60, 14
    PUSHBUTTON "&Excluir", psh3, 260, 60, 60, 14
    PUSHBUTTON "A&cima", psh4, 260, 100, 60, 14
    PUSHBUTTON "A&baixo", psh5, 260, 120, 60, 14
    DEFPUSHBUTTON "OK", IDOK, 195, 145, 60, 14
    PUSHBUTTON "Cancelar", IDCANCEL, 260, 145, 60, 14
    PUSHBUTTON "Excluir &Todos", psh6, 5, 145, 79, 14
}

IDD_ADDDLGINIT DIALOG 0, 0, 184, 137
CAPTION "Adicionar Dados DLGINIT"
STYLE DS_MODALFRAME | WS_POPUPWINDOW | WS_CAPTION
FONT 9, "MS Shell Dlg"
{
    LTEXT "&ID do Controle:", -1, 5, 7, 56, 12
    COMBOBOX cmb1, 65, 5, 115, 300, CBS_HASSTRINGS | CBS_AUTOHSCROLL | CBS_DROPDOWN | WS_VSCROLL | WS_TABSTOP
    LTEXT "&Mensagem:", -1, 5, 32, 55, 12
    COMBOBOX cmb2, 65, 30, 95, 300, CBS_HASSTRINGS | CBS_AUTOHSCROLL | CBS_DROPDOWN | WS_VSCROLL | WS_TABSTOP
    LTEXT "&String:", -1, 5, 52, 55, 12
    EDITTEXT edt1, 5, 65, 175, 50, ES_WANTRETURN | ES_MULTILINE | WS_VSCROLL | WS_HSCROLL
    DEFPUSHBUTTON "OK", IDOK, 55, 120, 60, 14
    PUSHBUTTON "Cancelar", IDCANCEL, 120, 120, 60, 14
}

IDD_MODIFYDLGINIT DIALOG 0, 0, 184, 137
CAPTION "Modificar Dados DLGINIT"
STYLE DS_MODALFRAME | WS_POPUPWINDOW | WS_CAPTION
FONT 9, "MS Shell Dlg"
{
    LTEXT "&ID do Controle:", -1, 5, 7, 56, 12
    COMBOBOX cmb1, 65, 5, 115, 300, CBS_HASSTRINGS | CBS_AUTOHSCROLL | CBS_DROPDOWN | WS_VSCROLL | WS_TABSTOP
    LTEXT "&Mensagem:", -1, 5, 32, 55, 12
    COMBOBOX cmb2, 65, 30, 95, 300, CBS_HASSTRINGS | CBS_AUTOHSCROLL | CBS_DROPDOWN | WS_VSCROLL | WS_TABSTOP
    LTEXT "&String:", -1, 5, 52, 55, 12
    EDITTEXT edt1, 5, 65, 175, 50, ES_WANTRETURN | ES_MULTILINE | WS_VSCROLL | WS_HSCROLL
    DEFPUSHBUTTON "OK", IDOK, 55, 120, 60, 14
    PUSHBUTTON "Cancelar", IDCANCEL, 120, 120, 60, 14
}

IDD_STRINGLIST DIALOG 0, 0, 205, 220
CAPTION "Lista de String de Controle"
STYLE WS_POPUPWINDOW | WS_CAPTION | WS_THICKFRAME
FONT 9, "MS Shell Dlg"
{
    LTEXT "", stc1, 5, 5, 195, 70
    EDITTEXT edt1, 5, 80, 195, 115, ES_WANTRETURN | ES_MULTILINE | WS_VSCROLL | WS_HSCROLL
    DEFPUSHBUTTON "OK", IDOK, 75, 200, 60, 14
    PUSHBUTTON "Cancelar", IDCANCEL, 140, 200, 60, 14
}

IDD_SAVE_OPTIONS DIALOG 0, 0, 250, 225
CAPTION "Opções ao Salvar"
STYLE DS_MODALFRAME | WS_POPUPWINDOW | WS_CAPTION
FONT 9, "MS Shell Dlg"
{
    ICON IDI_MAIN, -1, 5, 10, 0, 0
    LTEXT "Salvar um arquivo RC gerará alguns arquivos relacionados. Você pode escolher as seguintes opções:", -1, 35, 5, 210, 29
    AUTOCHECKBOX "Usar Microsoft MESSAGE&TABLE", chx8, 5, 40, 240, 14
    AUTOCHECKBOX "Arquivos de recursos separados por &idioma", chx1, 5, 60, 240, 14
    AUTOCHECKBOX "Usar palavras chaves B&EGIN/END", chx2, 5, 80, 240, 14
    AUTOCHECKBOX "Tornar a linguagem selecionável por LANGUAGE_* macro", chx3, 5, 100, 240, 14
    AUTOCHECKBOX "Criar &backup", chx4, 5, 120, 110, 14
    RTEXT "Sufixo de backup:", -1, 120, 122, 75, 12
    COMBOBOX cmb1, 200, 120, 45, 300, CBS_HASSTRINGS | CBS_AUTOHSCROLL | CBS_DROPDOWN | WS_VSCROLL | WS_TABSTOP
    AUTOCHECKBOX "Saída redundante e &comentários", chx5, 5, 140, 240, 14
    AUTOCHECKBOX "Quebrar as declarações de ma&nifesto por #ifndef MSVC ... #endif", chx6, 5, 160, 240, 14
    AUTOCHECKBOX "Saída de arquivo RC como &UTF-16", chx7, 5, 180, 240, 14
    DEFPUSHBUTTON "OK", IDOK, 120, 205, 60, 14
    PUSHBUTTON "Cancelar", IDCANCEL, 185, 205, 60, 14
}

IDD_ENCODING DIALOG 0, 0, 200, 170
CAPTION "Codificação do Item de Recurso"
STYLE DS_MODALFRAME | WS_POPUPWINDOW | WS_CAPTION
FONT 9, "MS Shell Dlg"
{
    CONTROL "", lst1, "SysListView32", LVS_SHOWSELALWAYS | LVS_SINGLESEL | LVS_REPORT | WS_BORDER, 5, 5, 190, 115
    PUSHBUTTON "&Adicionar...", psh1, 5, 125, 60, 14
    PUSHBUTTON "&Modificar...", psh2, 70, 125, 60, 14
    PUSHBUTTON "&Excluir", psh3, 135, 125, 60, 14
    DEFPUSHBUTTON "OK", IDOK, 70, 150, 60, 14
    PUSHBUTTON "Cancelar", IDCANCEL, 135, 150, 60, 14
    PUSHBUTTON "&Redefinir", psh5, 5, 149, 60, 14
}

IDD_ADDENC DIALOG 0, 0, 215, 80
CAPTION "Adicionar Codificação de Recursos"
STYLE DS_MODALFRAME | WS_POPUPWINDOW | WS_CAPTION
FONT 9, "MS Shell Dlg"
{
    LTEXT "&Tipo de Recurso:", -1, 5, 7, 70, 12
    COMBOBOX cmb1, 75, 5, 135, 200, CBS_HASSTRINGS | CBS_AUTOHSCROLL | CBS_DROPDOWN | WS_BORDER | WS_VSCROLL | WS_TABSTOP
    LTEXT "&Codificação:", -1, 5, 30, 70, 12
    COMBOBOX cmb2, 75, 30, 85, 300, CBS_HASSTRINGS | CBS_AUTOHSCROLL | CBS_DROPDOWNLIST | WS_VSCROLL | WS_TABSTOP
    DEFPUSHBUTTON "OK", IDOK, 86, 60, 60, 14
    PUSHBUTTON "Cancelar", IDCANCEL, 150, 60, 60, 14
}

IDD_MODIFYENC DIALOG 0, 0, 215, 80
CAPTION "Modificar Codificação de Recursos"
STYLE DS_MODALFRAME | WS_POPUPWINDOW | WS_CAPTION
FONT 9, "MS Shell Dlg"
{
    LTEXT "&Tipo de Recurso:", -1, 5, 7, 70, 12
    COMBOBOX cmb1, 75, 5, 135, 200, CBS_HASSTRINGS | CBS_AUTOHSCROLL | CBS_DROPDOWN | WS_DISABLED | WS_BORDER | WS_VSCROLL | WS_TABSTOP
    LTEXT "&Codificação:", -1, 5, 30, 70, 12
    COMBOBOX cmb2, 75, 30, 85, 300, CBS_HASSTRINGS | CBS_AUTOHSCROLL | CBS_DROPDOWNLIST | WS_VSCROLL | WS_TABSTOP
    DEFPUSHBUTTON "OK", IDOK, 86, 60, 60, 14
    PUSHBUTTON "Cancelar", IDCANCEL, 150, 60, 60, 14
}

IDD_CONSTANT DIALOG 0, 0, 205, 75
CAPTION "Consultar Constante"
STYLE DS_MODALFRAME | WS_POPUPWINDOW | WS_CAPTION
FONT 9, "MS Shell Dlg"
{
    LTEXT "&Nome da Constante:", -1, 5, 7, 80, 12
    COMBOBOX cmb1, 94, 7, 105, 300, CBS_HASSTRINGS | CBS_AUTOHSCROLL | CBS_DROPDOWN | WS_VSCROLL | WS_TABSTOP
    LTEXT "&Valor da Constante:", -1, 5, 32, 80, 12
    EDITTEXT edt2, 95, 30, 50, 14, ES_READONLY
    EDITTEXT edt3, 150, 30, 50, 14, ES_READONLY
    DEFPUSHBUTTON "OK", IDOK, 70, 55, 60, 14
}

IDD_EGA DIALOG 0, 0, 400, 225
CAPTION "Linguagem de Programação EGA"
STYLE WS_POPUPWINDOW | WS_CAPTION | WS_THICKFRAME
FONT 9, "MS Shell Dlg"
{
    GROUPBOX "Console do EGA", grp1, 5, 5, 390, 195
    EDITTEXT edt1, 10, 20, 380, 170, ES_READONLY | ES_AUTOVSCROLL | ES_MULTILINE | WS_VSCROLL | NOT WS_TABSTOP
    RTEXT "EGA>", stc1, 10, 208, 20, 10
    EDITTEXT edt2, 35, 205, 300, 15, ES_WANTRETURN | ES_AUTOHSCROLL | ES_AUTOVSCROLL | ES_MULTILINE
    PUSHBUTTON "&Inserir", IDOK, 345, 205, 50, 15
}

IDD_FONTSUBST DIALOG 0, 0, 185, 180
CAPTION "Substituir Fontes de Diálogo"
STYLE DS_CENTER | DS_MODALFRAME | WS_POPUPWINDOW | WS_CAPTION
FONT 9, "MS Shell Dlg"
{
    LTEXT "Fonte #&1:", -1, 5, 7, 44, 12
    COMBOBOX cmb1, 55, 5, 125, 300, CBS_HASSTRINGS | CBS_AUTOHSCROLL | CBS_DROPDOWN | WS_VSCROLL | WS_TABSTOP
    ICON IDI_ARROW, -1, 30, 25, 0, 0
    COMBOBOX cmb2, 55, 30, 125, 300, CBS_HASSTRINGS | CBS_AUTOHSCROLL | CBS_DROPDOWN | WS_VSCROLL | WS_TABSTOP
    LTEXT "Fonte #&2:", -1, 5, 57, 44, 12
    COMBOBOX cmb3, 55, 55, 125, 300, CBS_HASSTRINGS | CBS_AUTOHSCROLL | CBS_DROPDOWN | WS_VSCROLL | WS_TABSTOP
    ICON IDI_ARROW, -1, 30, 75, 0, 0
    COMBOBOX cmb4, 55, 80, 125, 300, CBS_HASSTRINGS | CBS_AUTOHSCROLL | CBS_DROPDOWN | WS_VSCROLL | WS_TABSTOP
    LTEXT "Fonte #&3:", -1, 5, 105, 44, 12
    COMBOBOX cmb5, 55, 105, 125, 300, CBS_HASSTRINGS | CBS_AUTOHSCROLL | CBS_DROPDOWN | WS_VSCROLL | WS_TABSTOP
    ICON IDI_ARROW, -1, 30, 125, 0, 0
    COMBOBOX cmb6, 55, 130, 125, 300, CBS_HASSTRINGS | CBS_AUTOHSCROLL | CBS_DROPDOWN | WS_VSCROLL | WS_TABSTOP
    DEFPUSHBUTTON "OK", IDOK, 75, 160, 50, 14
    PUSHBUTTON "Cancelar", IDCANCEL, 130, 160, 50, 14
    PUSHBUTTON "&Redefinir", psh1, 5, 160, 55, 14
}

IDD_DROPDOWNPOPUP DIALOG 0, 0, 120, 150
CAPTION " "
STYLE WS_POPUP | WS_DLGFRAME | NOT WS_BORDER
FONT 9, "MS Shell Dlg"
{
    LISTBOX lst1, 0, 0, 120, 150, LBS_WANTKEYBOARDINPUT | LBS_NOINTEGRALHEIGHT | LBS_HASSTRINGS | WS_VSCROLL | WS_TABSTOP, WS_EX_CLIENTEDGE
}

IDD_DFMSETTINGS DIALOG 0, 0, 210, 135
CAPTION "Configurações DFM do Delphi"
STYLE DS_CENTER | DS_MODALFRAME | WS_POPUPWINDOW | WS_CAPTION
FONT 9, "MS Shell Dlg"
{
    LTEXT "As seguintes configurações são relevantes para o DFM do Delphi:", -1, 35, 5, 171, 20
    ICON IDI_DFMICON, -1, 5, 5, 0, 0
    RTEXT "Código de &Página:", -1, 6, 32, 70, 12
    COMBOBOX cmb1, 85, 30, 120, 300, CBS_HASSTRINGS | CBS_AUTOHSCROLL | CBS_DROPDOWN | WS_VSCROLL | WS_TABSTOP
    AUTOCHECKBOX "&Inserir comentários de string bruta", chx1, 5, 50, 200, 14
    AUTOCHECKBOX "Não usar &Unicode e UTF-8", chx2, 5, 70, 200, 14
    DEFPUSHBUTTON "OK", IDOK, 80, 115, 60, 14
    PUSHBUTTON "Cancelar", IDCANCEL, 145, 115, 60, 14
}

IDD_COPYTOMULTILANG DIALOG 0, 0, 200, 195
CAPTION "Copiar Para Vários Idiomas"
STYLE DS_CENTER | DS_MODALFRAME | WS_POPUPWINDOW | WS_CAPTION
FONT 9, "MS Shell Dlg"
{
    LTEXT "Adicione os idiomas para os quais você deseja copiar o recurso:", -1, 5, 5, 190, 22
    LTEXT "&Idiomas:", -1, 5, 35, 82, 12
    LISTBOX lst1, 5, 50, 190, 100, LBS_WANTKEYBOARDINPUT | LBS_NOINTEGRALHEIGHT | LBS_HASSTRINGS | WS_VSCROLL | WS_TABSTOP
    COMBOBOX cmb3, 5, 155, 126, 14, CBS_HASSTRINGS | CBS_AUTOHSCROLL | CBS_DROPDOWN | WS_BORDER | WS_VSCROLL | WS_TABSTOP
    PUSHBUTTON "&Adicionar", psh1, 135, 155, 60, 14
    DEFPUSHBUTTON "OK", IDOK, 5, 175, 60, 14
    PUSHBUTTON "Cancelar", IDCANCEL, 70, 175, 60, 14
}

IDD_TOOLBARRES DIALOG 0, 0, 230, 195
CAPTION "Recurso da Barra de Ferramentas"
STYLE DS_CENTER | DS_MODALFRAME | WS_POPUPWINDOW | WS_CAPTION
FONT 9, "MS Shell Dlg"
{
    RTEXT "&Largura do ícone:", -1, 5, 5, 60, 15, SS_CENTERIMAGE | NOT WS_GROUP
    EDITTEXT edt1, 70, 5, 30, 15, ES_NUMBER | ES_RIGHT
    CONTROL "", scr1, "msctls_updown32", UDS_NOTHOUSANDS | UDS_ARROWKEYS | UDS_AUTOBUDDY | UDS_ALIGNRIGHT | UDS_SETBUDDYINT, 80, 5, 30, 15
    RTEXT "&Altura do ícone:", -1, 110, 5, 60, 15, SS_CENTERIMAGE | NOT WS_GROUP
    EDITTEXT edt2, 180, 5, 30, 15, ES_NUMBER | ES_RIGHT
    CONTROL "", scr2, "msctls_updown32", UDS_NOTHOUSANDS | UDS_ARROWKEYS | UDS_AUTOBUDDY | UDS_ALIGNRIGHT | UDS_SETBUDDYINT, 190, 5, 30, 15
    LTEXT "&Botões da barra de ferramentas:", -1, 5, 25, 140, 15, SS_CENTERIMAGE | NOT WS_GROUP
    LISTBOX lst1, 5, 40, 140, 130, LBS_DISABLENOSCROLL | LBS_WANTKEYBOARDINPUT | LBS_NOINTEGRALHEIGHT | LBS_HASSTRINGS | LBS_OWNERDRAWFIXED | WS_VSCROLL | WS_TABSTOP
    PUSHBUTTON "&Adicionar...", psh1, 150, 40, 75, 15
    PUSHBUTTON "&Modificar...", psh2, 150, 60, 75, 15
    PUSHBUTTON "&Excluir", psh3, 150, 80, 75, 15
    PUSHBUTTON "&Acima", psh4, 150, 135, 75, 15
    PUSHBUTTON "&Baixo", psh5, 150, 155, 75, 15
    DEFPUSHBUTTON "OK", IDOK, 5, 175, 60, 15
    PUSHBUTTON "Cancelar", IDCANCEL, 70, 175, 60, 15
}

IDD_ADDTBBTN DIALOG 0, 0, 177, 92
CAPTION "Botão Adicionar Barra de Ferramentas"
STYLE DS_CENTER | DS_MODALFRAME | WS_POPUPWINDOW | WS_CAPTION
FONT 9, "MS Shell Dlg"
{
    LTEXT "&ID do comando do botão da barra de ferramentas:", -1, 5, 5, 160, 15, SS_CENTERIMAGE | NOT WS_GROUP
    COMBOBOX cmb1, 5, 25, 150, 150, CBS_HASSTRINGS | CBS_AUTOHSCROLL | CBS_DROPDOWN | WS_VSCROLL | WS_TABSTOP
    AUTOCHECKBOX "&Separador", chx1, 5, 45, 90, 15
    DEFPUSHBUTTON "OK", IDOK, 45, 70, 60, 15
    PUSHBUTTON "Cancelar", IDCANCEL, 110, 70, 60, 15
}

IDD_MODIFYTBBTN DIALOG 0, 0, 177, 92
CAPTION "Modificar Botão da Barra de Ferramentas"
STYLE DS_CENTER | DS_MODALFRAME | WS_POPUPWINDOW | WS_CAPTION
FONT 9, "MS Shell Dlg"
{
    LTEXT "&ID do comando do botão da barra de ferramentas:", -1, 5, 5, 160, 15, SS_CENTERIMAGE | NOT WS_GROUP
    COMBOBOX cmb1, 5, 25, 150, 150, CBS_HASSTRINGS | CBS_AUTOHSCROLL | CBS_DROPDOWN | WS_VSCROLL | WS_TABSTOP
    AUTOCHECKBOX "&Separador", chx1, 5, 45, 90, 15
    DEFPUSHBUTTON "OK", IDOK, 45, 70, 60, 15
    PUSHBUTTON "Cancelar", IDCANCEL, 110, 70, 60, 15
}

//////////////////////////////////////////////////////////////////////////////
// RT_VERSION

1 VERSIONINFO
FILEVERSION     5, 7, 9, 0
PRODUCTVERSION  5, 7, 9, 0
FILEOS          0x40004
FILETYPE        0x1
FILESUBTYPE     0x0
{
    BLOCK "StringFileInfo"
    {
        BLOCK "081604E4"
        {
            VALUE "CompanyName", "Katayama Hirofumi MZ\0"
            VALUE "FileDescription", "RisohEditor\0"
            VALUE "FileVersion", "5.7.9\0"
            VALUE "LegalCopyright", "Copyright (C) 2017-2020 Katayama Hirofumi MZ. Todos os direitos reservados.\0"
            VALUE "ProductName", "RisohEditor\0"
            VALUE "ProductVersion", "5.7.9\0"
        }
    }
    BLOCK "VarFileInfo"
    {
        VALUE "Translation", 0x0816, 0x04E4
    }
}

//////////////////////////////////////////////////////////////////////////////
// RISOHTEMPLATE

4 RISOHTEMPLATE "res/1046_RISOHTEMPLATE_4.bin"

5 RISOHTEMPLATE "res/1046_RISOHTEMPLATE_5.bin"

//////////////////////////////////////////////////////////////////////////////
// RT_STRING

STRINGTABLE
{
    IDS_APPNAME, "RisohEditor 5.7.9 by Katayama Hirofumi MZ"
    IDS_TITLEWITHFILE, "RisohEditor 5.7.9 - Arquivo: %s"
    IDS_EXTRACTRES, "Extrair Recurso"
    IDS_RESBINFILTER, "Recursos Binários (*.res)|*.res|Arquivos Binários (*.bin)|*.bin|Todos os Arquivos (*.*)|*.*|"
    IDS_CANNOTSAVE, "Impossível salvar."
    IDS_REPLACERES, "Substituir Recurso"
    IDS_ALLFILES, "Todos os Arquivos (*.*)|*.*|"
    IDS_ENTERTYPE, "Por favor, insira um tipo de recurso."
    IDS_ENTERNAME, "Por favor, insira um nome de recurso."
    IDS_ENTERLANG, "Por favor, insira um idioma de recurso."
    IDS_FILENOTFOUND, "O arquivo não pôde ser encontrado."
    IDS_CANNOTREPLACE, "Não é possível substituir."
    IDS_EXERESFILTER, "Executável (*.exe;*.dll;*.ocx;*.cpl;*.scr;*.mui)|*.exe;*.dll;*.ocx;*.cpl;*.scr;*.mui|Arquivos RC (*.rc)|*.rc|Recursos Binários (*.res)|*.res|Todos os Arquivos (*.*)|*.*|"
    IDS_SAVEAS, "Salvar Como"
    IDS_CANNOTADDICON, "Não é possível adicionar o ícone."
    IDS_ADDICON, "Adicionar Ícone"
    IDS_ICOFILTER, "Arquivos de Ícone (*.ico)|*.ico|Todos os Arquivos (*.*)|*.*|"
    IDS_REPLACEICO, "Substituir Ícone"
    IDS_CANTREPLACEICO, "Não é possível substituir o ícone."
    IDS_EXISTSOVERWRITE, "O item já existe. Sobrescrever?"
    IDS_OPEN, "Abrir"
    IDS_CANNOTOPEN, "Não é possível abrir o arquivo."
    IDS_ADDBMP, "Adicionar Bitmap"
    IDS_BMPFILTER, "Arquivos Bitmap (*.bmp)|*.bmp|Imagens PNG (*.png)|*.png|Todos os Arquivos (*.*)|*.*|"
    IDS_CANTREPLACEBMP, "Não é possível substituir o bitmap."
    IDS_REPLACEBMP, "Substituir Bitmap"
    IDS_ERRORCODE, "Código de Erro %d"
    IDS_VERSIONINFO, "RisohEditor Versão 5.7.9\r\n\r\nKatayama Hirofumi MZ\r\n\r\nLicença: GPLv3 (free software)"
    IDS_ADDRES, "Adicionar Recurso"
    IDS_CANNOTADDRES, "Não é possível adicionar o recurso."
    IDS_CANTADDBMP, "Não é possível adicionar o bitmap."
    IDS_EXTRACTBMP, "Extrair Bitmap"
    IDS_CANTEXTRACTBMP, "Não é possível extrair o bitmap."
    IDS_CANTREPLACECUR, "Não é possível substituir o cursor."
    IDS_CANNOTADDCUR, "Não é possível adicionar o cursor."
    IDS_CURFILTER, "Arquivos de Cursor (*.cur)|*.cur|Cursor Animado (*.ani)|*.ani|Todos os Arquivos (*.*)|*.*|"
    IDS_ADDCUR, "Adicionar Cursor"
    IDS_REPLACECUR, "Substituir Cursor"
    IDS_EXTRACTICO, "Extrair Ícone"
    IDS_CANTEXTRACTICO, "Não é possível extrair o ícone."
    IDS_EXTRACTCUR, "Extrair Cursor"
    IDS_CANTEXTRACTCUR, "Não é possível extrair o cursor."
    IDS_RESFILTER, "Recursos Binários (*.res)|*.res|Todos os Arquivos (*.*)|*.*|"
    IDS_NEUTRAL, "Neutro"
    IDS_IMPORTRES, "Importar"
    IDS_CANNOTIMPORT, "Não é possível importar o recurso."
    IDS_COMPILE, "Compilar (F8)"
    IDS_CANCELEDIT, "Cancelar Edição (Ctrl+E)"
    IDS_GUIEDIT, "Editar via GUI (Ctrl+G)"
    IDS_CANNOTSTARTUP, "Não é possível iniciar o compilador de recursos."
    IDS_RESMISMATCH, "O tipo de recurso era incompatível."
    IDS_SAMPLETEXT, "Isto é uma amostra."
    IDS_ALREADYEXISTS, "Já existe."
    IDS_KEY, "Chave"
    IDS_FLAGS, "Sinalizadores"
    IDS_COMMANDID, "ID do Comando"
    IDS_INVALIDKEY, "Chave inválida."
    IDS_COMPILEERROR, "Falha ao compilar."
    IDS_STRINGID, "ID da String"
    IDS_STRINGVALUE, "Valor da String"
    IDS_CAPTION, "Legenda"
    IDS_HELPID, "ID de Ajuda"
    IDS_INDENT, "» "
    IDS_DATAISEMPTY, "Os dados estão vazios."
    IDS_TEST, "Testar"
    IDS_SEPARATOR, "---"
    IDS_COMPILENOW, "Os dados foram alterados. Compilar agora?"
    IDS_RADWINDOW, "Editar Diálogo"
    IDS_ENTERCLASS, "Por favor, insira um nome de classe do windows válida."
    IDS_TEXTEDIT, "Editar por Texto (Ctrl+T)"
    IDS_CURSORINFO, "Imagem #%u: Largura %u, Altura %u, BitCount %u, xHotSpot %u, yHotSpot %u, ID %u\r\n"
    IDS_IMAGECOUNT, "ImageCount: %u\r\n"
    IDS_ICONINFO, "Imagem #%u: Largura %u, Altura %u, BitCount %u, ID %u\r\n"
    IDS_READY, "Pronto"
    IDS_EXECUTINGCMD, "Executando comando..."
    IDS_EDITINGBYGUI, "Editando via GUI..."
    IDS_COORD, "%d, %d, %d, %d"
    IDS_STARTING, "Iniciando..."
    IDS_COMPILING, "Compilando..."
    IDS_CANNOTLOAD, "Incapaz de carregar."
    IDS_NONE, "(Nenhum)"
    IDS_WAVESOUND, "(Som WAVE)\r\n"
    IDS_IDTYPE, "Tipo de ID"
    IDS_IDPREFIX, "Prefixo de ID"
    IDS_EMPTYSTR, "Por favor, digite uma string."
    IDS_ANICURSOR, "(Cursor Animado)\r\n"
    IDS_ANIICON, "(Ícone Animado)\r\n"
    IDS_HEADFILTER, "Arquivos de Cabeçalho (*.h)|*.h|Todos os Arquivos (*.*)|*.*|"
    IDS_LOADRESH, "Carregar Arquivo ""resource.h"""
    IDS_NAME, "Nome"
    IDS_VALUE, "Valor"
    IDS_NOSUCHID, "Nenhum ID desse tipo."
    IDS_IMAGEINFO, "Largura %u, Altura %u, BitsPixel %u\r\n"
    IDS_ENTERINT, "Por favor, insira um inteiro válido."
    IDS_ENTERTEXT, "Por favor, insira um texto válido."
    IDS_ENTERID, "Por favor, insira um ID válido."
    IDS_ADDNEXTIDS, "Por favor, adicione os seguintes IDs para ""resource.h"":\r\n\r\n"
    IDS_DELETENEXTIDS, "Por favor, exclua os seguintes IDs de ""resource.h"":\r\n\r\n"
    IDS_NOCHANGE, "Não há alteração de IDs de Recursos."
    IDS_DLGFAIL, "Opa, falhei em criar uma caixa de diálogo RAD."
    IDS_LOADWCLIB, "Carregar uma Biblioteca de Classe do Windows"
    IDS_AVIMOVIE, "(Filme AVI)\r\n"
    IDS_ADDDIALOG, "Adicionar Diálogo"
    IDS_ADDMENU, "Adicionar Menu"
    IDS_ADDVERINFO, "Adicionar Informação da Versão"
    IDS_ADDCURSOR, "Adicionar Cursor"
    IDS_NOMOREITEM, "Não há mais itens."
    IDS_INVALIDDATA, "(dados inválidos)\r\n"
    IDS_UPDATERESH, "Atualizar ""resource.h""?"
    IDS_CANTWRITERESH, "Não é possível gravar ""resource.h""."
    IDS_SAVERESH, "Salvar Arquivo ""resource.h"""
    IDS_DLLFILTER, "Arquivos de DLL (*.dll;*.ocx;*.mui)|*.dll;*.ocx;*.mui|Todos os Arquivos (*.*)|*.*|"
    IDS_EXERESRCFILTER, "Arquivos Carregáveis (*.exe;*.dll;*.ocx;*.cpl;*.scr;*.mui;*.res;*.rc)|*.exe;*.dll;*.ocx;*.cpl;*.scr;*.mui;*.res;*.rc|Executáveis (*.exe;*.dll;*.ocx;*.cpl;*.scr;*.mui)|*.exe;*.dll;*.ocx;*.cpl;*.scr;*.mui|Recursos Binários (*.res)|*.res|Arquivos de Recursos (*.rc)|*.rc|Todos os Arquivos (*.*)|*.*|"
    IDS_CANTTESTCHILDWND, "Não é possível testar o diálogo porque é uma janela filha."
    IDS_CANTTESTCLASSDLG, "Não é possível testar o diálogo porque é classificado."
    IDS_FILEISUPXED, "Arquivo\r\n\r\n'%s'\r\n\r\né comprimido por UPX. Você quer extraí-lo usando um arquivo temporário?\r\n\r\nSe não extraí-lo, a leitura pode falhar."
    IDS_CANTUPXEXTRACT, "Não é possível extrair por UPX."
    IDS_CANTSAVEUPXED, "Não é possível salvar o arquivo porque ele foi comprimido por UPX."
    IDS_MESSAGEID, "ID de Mensagem"
    IDS_MESSAGEVALUE, "Valor da Mensagem"
    IDS_RCFILTER, "Arquivos RC (*.rc)|*.rc|"
    IDS_EXPORT, "Exportar"
    IDS_CANTEXPORT, "Exportação falhou."
    IDS_MUSTBEEMPTYDIR, "Se houver algum arquivo externo, o destino de exportação deve ser uma pasta vazia."
    IDS_FULLWIDTH, "０１２３４５６７８９ＡＢＣＤＥＦＧＨＩＪＫＬＭＮＯＰＱＲＳＴＵＶＷＸＹＺａｂｃｄｅｆｇｈｉｊｋｌｍｎｏｐｑｒｓｔｕｖｗｘｙｚ－＿（）．　"
    IDS_HALFWIDTH, "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz-_(). "
    IDS_MACRONAME, "Nome da Macro"
    IDS_MACROVALUE, "Valor da Macro"
    IDS_OPTIONAL, "(Opcional)"
    IDS_ADDINCLUDE, "Adicionar Diretório Incluído"
    IDS_EDITINCLUDE, "Editar Diretório Incluído"
    IDS_WINDRESEXE, "windres.exe|windres.exe|"
    IDS_CPPEXE, "cpp.exe|cpp.exe|"
    IDS_INVALIDPATH, "Caminho inválido."
    IDS_DATATOOLONG, "Data is too long."
    IDS_ALL, "(Todos)"
    IDS_UNKNOWNFORMAT, "(Formato de Dados Desconhecido)\r\n"
    IDS_LANGUAGE, "Idiomas"
    IDS_INTVALUE, "Valor Inteiro"
    IDS_PARENTWND, "Janela de Teste Pai"
    IDS_CHOOSE_OLE_CLSID, "Escolher OLE CLSID."
    IDS_CONTROL, "Controle"
    IDS_MESSAGE, "Mensagem"
    IDS_STRING, "String"
    IDS_DATAISINVALID, "Os dados são inválidos."
    IDS_DLGINIT1, "Você pode especificar a inicialização de caixas combo e caixas de lista definindo dados de inicialização no RT_DLGINIT dados de recursos de mesmo nome do recurso de diálogo. "
    IDS_DLGINIT2, "Quando a mensagem WM_INITDIALOG chegar, o aplicativo pode inicializar a caixa de diálogo chamando a função ExecuteDlgInitDx do arquivo anexado ""DlgInit/DlgInit.h"".\r\n\r\n"
    IDS_DLGINIT3, "Por favor, especifique uma lista de caracteres de string separadas por quebras de linha para RT_DLGINIT."
    IDS_SAMELANG, "É o mesmo idioma."
    IDS_SAMENAME, "É o mesmo nome de recurso."
    IDS_CANTSAVETOEXE, "Não é possível salvar como EXE de um arquivo não executável."
    IDS_CANTSTARTSEARCH, "Não é possível iniciar a pesquisa."
    IDS_AMERICA, "América"
    IDS_ENGLISH, "Inglês"
    IDS_CHINA, "China"
    IDS_CHINESE, "Chinês"
    IDS_RUSSIA, "Rússia"
    IDS_RUSSIAN, "Russo"
    IDS_WANNAGENRESH, "Deseja gerar o arquivo 'resource.h'?"
    IDS_EXEFILTER, "Executáveis (*.exe;*.dll;*.ocx;*.cpl;*.scr;*.mui)|*.exe;*.dll;*.ocx;*.cpl;*.scr;*.mui|Todos os Arquivos (*.*)|*.*|"
    IDS_SAVEASCOMPRESS, "Salvar Com Compressão"
    IDS_TOOL_NEW, "Novo"
    IDS_TOOL_OPEN, "Abrir..."
    IDS_TOOL_SAVE, "Salvar Como..."
    IDS_TOOL_EXPAND, "Expandir Todos"
    IDS_TOOL_COLLAPSE, "Recolher Todos"
    IDS_TOOL_PLUS, "Adicionar Item..."
    IDS_TOOL_MINUS, "Excluir Item"
    IDS_TOOL_CHANGE, "Alterar Nome/Idioma"
    IDS_TOOL_CLONE, "Clonar Para Um Outro Nome/Idioma"
    IDS_TOOL_RECOMPILE, "Recompilar"
    IDS_TOOL_CANCELEDIT, "Cancelar Edição"
    IDS_TOOL_IMPORT, "Importar..."
    IDS_TOOL_EXTRACT, "Extrair..."
    IDS_TOOL_GUIEDIT, "Editar via GUI"
    IDS_UNITEDKINGDOM, "Reino Unido"
    IDS_GREATBRITAIN, "Grã-Bretanha"
    IDS_BRITISH, "Britânico"
    IDS_FRANCE, "França"
    IDS_FRENCH, "Francês"
    IDS_GERMANY, "Alemanha"
    IDS_GERMAN, "Alemão"
    IDS_SPAIN, "Espanha"
    IDS_SPANISH, "Espanhol"
    IDS_INVALIDLANG, "Idioma irreconhecível."
    IDS_INVALIDNAME, "Nome de recurso inválido."
    IDS_PNGRESBINFILTER, "Imagem PNG (*.png)|*.png|Recursos Binários (*.res)|*.res|Arquivos Binários (*.bin)|*.bin|Todos os Arquivos (*.*)|*.*|"
    IDS_JPEGRESBINFILTER, "Imagem JPEG (*.jpg;*.jpeg;*.jpe;*.jfif)|*.jpg;*.jpeg;*.jpe;*.jfif|Recursos Binários (*.res)|*.res|Arquivos Binários (*.bin)|*.bin|Todos os Arquivos (*.*)|*.*|"
    IDS_GIFRESBINFILTER, "Imagem GIF (*.gif)|*.gif|Recursos Binários (*.res)|*.res|Arquivos Binários (*.bin)|*.bin|Todos os Arquivos (*.*)|*.*|"
    IDS_TIFFRESBINFILTER, "Imagem TIFF (*.tif;*.tiff)|*.tif;*.tiff|Recursos Binários (*.res)|*.res|Arquivos Binários (*.bin)|*.bin|Todos os Arquivos (*.*)|*.*|"
    IDS_AVIRESBINFILTER, "Filme AVI (*.avi)|*.avi|Recursos Binários (*.res)|*.res|Arquivos Binários (*.bin)|*.bin|Todos os Arquivos (*.*)|*.*|"
    IDS_WAVERESBINFILTER, "Som WAVE (*.wav)|*.wav|Recursos Binários (*.res)|*.res|Arquivos Binários (*.bin)|*.bin|Todos os Arquivos (*.*)|*.*|"
    IDS_COMMENT_SEP, "//////////////////////////////////////////////////////////////////////////////\r\n\r\n"
    IDS_NEWLINE, "\r\n"
    IDS_NOTICE, "// Este arquivo é gerado automaticamente por RisohEditor 5.7.9.\r\n"
    IDS_DAGGER, "// † <-- Esta adaga ajuda na detecção de UTF-8.\r\n"
    IDS_IMPORTFILTER, "Arquivos Importados|*.rc;*.res;*.dfm;*.html;*.htm;*.manifest;*.ico;*.cur;*.ani;*.wav;*.bmp;*.dib;*.png;*.gif;*.jpg;*.jpeg;*.jpe;*.jfif;*.tif;*.tiff;*.avi;*.wmf;*.emf;*.tlb|Arquivos RC (*.rc)|*.rc|Recursos Binários (*.res)|*.res|Arquivos de Imagem |*.bmp;*.dib;*.png;*.gif;*.jpg;*.jpeg;*.jpe;*.jfif;*.tif;*.tiff;*.wmf;*.emf|Arquivos de Cursor (*.cur;*.ani)|*.cur;*.ani|Arquivos de Ícone (*.ico)|*.ico|Arquivos de Som WAVE (*.wav)|*.wav|Arquivos HTML (*.html;*.htm)|*.html;*.htm|Arquivos de Manifest (*.manifest)|*.manifest|Arquivos DFM do Delphi (*.dfm)|*.dfm|Arquivos TYPELIB (*.tlb)|*.tlb|Todos os Arquivos (*.*)|*.*|"
    IDS_CANTWRITEBYLOCK, "Não é possível escrever o arquivo porque o arquivo a seguir está bloqueado.\r\n\r\n%s"
    IDS_ANSI, "ANSI"
    IDS_WIDE, "Unicode"
    IDS_UTF8, "UTF-8 (com BOM)"
    IDS_UTF8N, "UTF-8 (sem BOM)"
    IDS_SJIS, "Shift_JIS"
    IDS_BINARY, "(dados binários)"
    IDS_RESTYPE, "Tipo de Recurso"
    IDS_ENCODING, "Codificação"
    IDS_INVALIDRESTYPE, "Tipo de recurso inválido."
    IDS_PATHSPACEERROR, "Você erroneamente instalou no local com caracteres de espaço! O compilador de recursos não pode aceitar espaço.\n\nPor favor, evite ""C:\\Program Files""."
    IDS_LOADEGAPROGRAM, "Carregar Programa EGA..."
    IDS_EGAFILTER, "Programa do EGA (*.ega)|*.ega|Todos os Arquivos (*.*)|*.*|"
    IDS_QUERYSAVECHANGE, "O arquivo foi modificado. Quer salvar as alterações agora?"
    IDS_DFMFILTER, "Arquivo DFM (*.dfm)|*.dfm|Arquivos de Texto (*.txt)|*.txt|Todos os Arquivos (*.*)|*.*|"
    IDS_CANTEXTRACTDFM, "Não é possível extrair os dados do DFM."
    IDS_EXTRACTDFM, "Extrair dados do DFM"
    IDS_ENTERNONZERONAME, "Por favor, insira um nome de recurso diferente de zero."
    IDS_ENTERNONZEROTYPE, "Por favor, insira um tipo de recurso diferente de zero."
    IDS_HOMEPAGE, "https://katahiromz.web.fc2.com/re/en/"
    IDS_FILESAVED, "Arquivo salvo."
    IDS_RECOMPILEOK, "Recompilação concluída."
    IDS_RECOMPILEFAILED, "Falha de recompilação (erro de sintaxe)."
    IDS_TOOL_EXPORT, "Exportar..."
    IDS_CODEEDITOR, "Editor de Código"
    IDS_HEXVIEWER, "Visualizador Hex"
    IDS_INTEGERORIDENTIFIER, "(inteiro ou identificador)"
    IDS_NOTEXT, " "
    IDS_NOUPDATE, "Você está usando o RisohEditor mais recente."
    IDS_THEREISUPDATE, "RisohEditor %s está disponível. Baixe agora?"
    IDS_CANTCHECKUPDATE, "Falha ao verificar a atualização do RisohEditor."
    IDS_CODEPAGE1252, "1252 (Latim 1)"
    IDS_CODEPAGE1250, "1250 (Latim 2)"
    IDS_CODEPAGE1251, "1251 (Cirílico)"
    IDS_CODEPAGE1253, "1253 (Grego)"
    IDS_CODEPAGE1254, "1254 (Turco)"
    IDS_CODEPAGE1255, "1255 (Hebraico)"
    IDS_CODEPAGE1256, "1256 (Árabe)"
    IDS_CODEPAGE1257, "1257 (Báltico)"
    IDS_CODEPAGE874, "874 (Tailandês)"
    IDS_CODEPAGE932, "932 (Japonês)"
    IDS_CODEPAGE936, "936 (Chinês Simplificado)"
    IDS_CODEPAGE949, "949 (Coreano)"
    IDS_CODEPAGE950, "950 (Chinês Tradicional)"
    IDS_CODEPAGE65001, "65001 (UTF-8)"
    IDS_EXTRACTTLB, "Extrair dados TYPELIB"
    IDS_CANTEXTRACTTLB, "Não é possível extrair os dados TYPELIB."
    IDS_TLBRESBINFILTER, "Dados TYPELIB (*.tlb)|*.tlb|Recursos Binários (*.res)|*.res|Arquivos de Texto (*.txt)|*.txt|Arquivos MIDL (*.idl)|*.idl|Todos os Arquivos (*.*)|*.*|"
    IDS_USAGE, "Use: RisohEditor [opções | ""arquivo""]\n\nOpções:\n--help  Mostra esta mensagem.\n--version  Mostra informações da versão.\n--load ""seu-arquivo.rc""  Carrega o arquivo (sem GUI)\n--save ""seu-arquivo.res""  Salva o arquivo (sem GUI)\n--log-file ""arquivo-log.txt""  Especifica o arquivo de log.\n--load-options OPÇÕES  Define opções de carregamento.\n--save-options OPÇÕES  Define opções de salvamento.\n\nOpções de carregamento: (no-load-res-h)\nOpções de salvamento: (idc-static)(compress)(sep-lang)(no-res-folder)(lang-macro)(less-comments)(wrap-manifest)(begin-end)(utf-16)(backup)(ms-msgtbl)"
    IDS_NOSELECTION, "Não há seleção."
    IDS_TRANSLATORS, "[Translators]\r\nEnglish: Katayama Hirofumi MZ\r\nFinnish: Veikko Muurikainen\r\nIndonesian: Mas Ahmad Muhammad\r\nItalian: R.B.\r\nJapanese: Katayama Hirofumi MZ\r\nKorean: VenusGirl (비너스걸)\r\nPolish: Piotr Hetnarowicz\r\nPortuguese: JNylson\r\nRussian: Dmitry Yerokhin\r\nSimplified Chinese: 林鸿湘\r\n"
}

//////////////////////////////////////////////////////////////////////////////

```

`src/lang/ru_RU.rc`:

```rc
// This file is automatically generated by RisohEditor 5.7.9.
// † <-- This dagger helps UTF-8 detection.

#pragma code_page(65001) // UTF-8

LANGUAGE LANG_RUSSIAN, SUBLANG_DEFAULT

//////////////////////////////////////////////////////////////////////////////
// RT_MENU

IDR_MAINMENU MENU
{
    POPUP "&Файл"
    {
        MENUITEM "Со&здать\tCtrl+N", ID_NEW
        MENUITEM SEPARATOR
        MENUITEM "&Открыть...\tCtrl+O", ID_OPEN
        MENUITEM "&Сохранить...\tCtrl+S", ID_SAVE
        MENUITEM "Сохранить &как...\tShift+Ctrl+S", ID_SAVEAS
        MENUITEM "Сохранить со с&жатием...", ID_SAVEASCOMPRESS
        MENUITEM SEPARATOR
        MENUITEM "&Импорт...\tCtrl+I", ID_IMPORT
        MENUITEM "&Экспорт...\tCtrl+P", ID_EXPORT
        MENUITEM SEPARATOR
        MENUITEM "&Перезагрузить resource.h...\tCtrl+R", ID_LOADRESH
        MENUITEM "Со&хранить resource.h...", ID_UPDATERESHBANG
        MENUITEM "&Рекомендовать изменить resource.h...", ID_ADVICERESH
        MENUITEM "&Выгрузить resource.h", ID_UNLOADRESH
        MENUITEM SEPARATOR
        MENUITEM "&Загрузить библиотеку классов окон...", ID_LOADWCLIB
        MENUITEM SEPARATOR
        POPUP "Недавние файлы"
        {
            MENUITEM "(нет)", -1, GRAYED
        }
        MENUITEM SEPARATOR
        MENUITEM "В&ыход\tAlt+F4", ID_EXIT
    }
    POPUP "&Правка"
    {
        MENUITEM "Редактировать в &графическом интерфейсе...\tCtrl+G", ID_GUIEDIT
        MENUITEM SEPARATOR
        POPUP "&Добавить"
        {
            MENUITEM "&Значок...", ID_ADDICON
            MENUITEM "&Курсор...", ID_ADDCURSOR
            MENUITEM "К&артинку...", ID_ADDBITMAP
            MENUITEM "&Диалог...", ID_ADDDIALOG
            MENUITEM "&Меню...", ID_ADDMENU
            MENUITEM "&Таблицу строк...", ID_ADDSTRINGTABLE
            MENUITEM "Та&блицу сообщений...", ID_ADDMESSAGETABLE
            MENUITEM "HTML-&ресурс...", ID_ADDHTML
            MENUITEM "Акс&елераторы...", ID_ADDACCEL
            MENUITEM "&Информацию о версии...", ID_ADDVERINFO
            MENUITEM "Ма&нифест...", ID_ADDMANIFEST
            MENUITEM "&Панель инструментов...", ID_ADDTOOLBAR
            MENUITEM "Ресурсный &элемент...", ID_ADDRES
        }
        POPUP "&Заменить"
        {
            MENUITEM "&Значок...", ID_REPLACEICON
            MENUITEM "&Курсор...", ID_REPLACECURSOR
            MENUITEM "К&артинку...", ID_REPLACEBITMAP
            MENUITEM "&Двоичный ресурсный элемент...", ID_REPLACEBIN
        }
        POPUP "&Извлечь"
        {
            MENUITEM "&Значок...", ID_EXTRACTICON
            MENUITEM "&Курсор...", ID_EXTRACTCURSOR
            MENUITEM "К&артинку...", ID_EXTRACTBITMAP
            MENUITEM "Извлечь &как RC файл...", ID_EXTRACTRC
            MENUITEM "Двоичный ресурсный элемент...", ID_EXTRACTBIN
        }
        MENUITEM SEPARATOR
        MENUITEM "И&зменить имя/язык\tF2", ID_EDITLABEL
        MENUITEM SEPARATOR
        MENUITEM "Клонировать с новым &именем...", ID_COPYASNEWNAME
        MENUITEM "Клонировать с новым &языком...", ID_COPYASNEWLANG
        MENUITEM "Копировать на несколько языков ......", ID_COPYTOMULTILANG
        MENUITEM SEPARATOR
        MENUITEM "Про&тестировать", ID_TEST
        MENUITEM SEPARATOR
        MENUITEM "&Удалить\tDel", ID_DELETERES
        MENUITEM SEPARATOR
        MENUITEM "ID-&ассоциация...", ID_IDASSOC
        MENUITEM "Предопределённые &макросы...", ID_PREDEFMACROS
        MENUITEM "Настройки &шрифта...", ID_FONTS
        MENUITEM "Задать п&ути...", ID_SETPATHS
        MENUITEM SEPARATOR
        MENUITEM "&UI Language Select (UI语言选择)...", ID_CHOOSEUILANG
        MENUITEM SEPARATOR
        MENUITEM "Настройки Delphi DFM...", ID_DFMSETTINGS
        MENUITEM "&Конфигурация...", ID_CONFIG
    }
    POPUP "&Поиск"
    {
        MENUITEM "&Найти...\tCtrl+F", ID_FIND
        MENUITEM SEPARATOR
        MENUITEM "Найти &предыдущее\tShift+F3", ID_FINDUPWARD
        MENUITEM "Найти &следующее\tF3", ID_FINDDOWNWARD
        MENUITEM SEPARATOR
        MENUITEM "&Константа запроса...", ID_QUERYCONSTANT
    }
    POPUP "&Вид"
    {
        MENUITEM "&Строка состояния", ID_STATUSBAR
        MENUITEM "&Панель инструментов", ID_SHOWHIDETOOLBAR
        MENUITEM "&Двоичный", ID_BINARYPANE
        MENUITEM SEPARATOR
        MENUITEM "&Распахнуть все\tCtrl+K", ID_EXPAND_ALL
        MENUITEM "С&вернуть все\tCtrl+L", ID_COLLAPSE_ALL
        MENUITEM SEPARATOR
        MENUITEM "Сп&исок ID ресурсов", ID_IDLIST
        MENUITEM "Список &языков...", ID_SHOWLANGS
        MENUITEM SEPARATOR
        MENUITEM "Все&гда оператор CONTROL", ID_ALWAYSCONTROL
        MENUITEM "&Не использовать ID-макросы", ID_HIDEIDMACROS
        MENUITEM "Испо&льзовать IDC_STATIC", ID_USEIDC_STATIC
        MENUITEM "&Заворачивать строки", ID_WORD_WRAP
        MENUITEM "Использовать BE&GIN/END", ID_USEBEGINEND
        MENUITEM "Использовать &таблицу сообщений Microsoft", ID_USEMSMSGTBL
        MENUITEM SEPARATOR
        MENUITEM "&Кодировка ресурсного элемента...", ID_ENCODING
        MENUITEM "Dialog &font substitutes...", ID_DIALOG_FONT_SUBSTITUTES
        MENUITEM SEPARATOR
        MENUITEM "О&бновить", ID_REFRESHALL
    }
    POPUP "&Автоматизация"
    {
        MENUITEM "Язык программирования &EGA...", ID_EGA
        MENUITEM "&Запустить EGA-программу...", ID_EGA_PROGRAM
        MENUITEM "Открыть &руководство EGA", ID_OPEN_EGA_MANUAL
    }
    POPUP "&Справка"
    {
        MENUITEM "О&ткрыть файл README.txt (английский)", ID_OPENREADME
        MENUITEM "Отк&рыть файл LICENSE.txt", ID_OPENLICENSE
        MENUITEM SEPARATOR
        MENUITEM "&Руководство пользователя RisohEditor", ID_GUIDE
        MENUITEM "&Проверьте обновление RisohEditor...", ID_CHECKUPDATE
        MENUITEM SEPARATOR
        MENUITEM "&О программе...", ID_ABOUT
    }
}

IDR_POPUPMENUS MENU
{
    POPUP "Popup #0"
    {
        MENUITEM "Редактировать в &графическом интерфейсе...\tCtrl+G", ID_GUIEDIT
        MENUITEM SEPARATOR
        POPUP "&Добавить"
        {
            MENUITEM "&Значок...", ID_ADDICON
            MENUITEM "&Курсор...", ID_ADDCURSOR
            MENUITEM "К&артинку...", ID_ADDBITMAP
            MENUITEM "&Диалог...", ID_ADDDIALOG
            MENUITEM "&Меню...", ID_ADDMENU
            MENUITEM "&Таблицу строк...", ID_ADDSTRINGTABLE
            MENUITEM "Та&блицу сообщений...", ID_ADDMESSAGETABLE
            MENUITEM "HTML-&ресурс...", ID_ADDHTML
            MENUITEM "Акс&елераторы...", ID_ADDACCEL
            MENUITEM "&Информацию о версии...", ID_ADDVERINFO
            MENUITEM "Ма&нифест...", ID_ADDMANIFEST
            MENUITEM "&Панель инструментов...", ID_ADDTOOLBAR
            MENUITEM "Ресурсный &элемент...", ID_ADDRES
        }
        POPUP "&Заменить"
        {
            MENUITEM "&Значок...", ID_REPLACEICON
            MENUITEM "&Курсор...", ID_REPLACECURSOR
            MENUITEM "К&артинку...", ID_REPLACEBITMAP
            MENUITEM "&Двоичный ресурсный элемент...", ID_REPLACEBIN
        }
        POPUP "&Извлечь"
        {
            MENUITEM "&Значок...", ID_EXTRACTICON
            MENUITEM "&Курсор...", ID_EXTRACTCURSOR
            MENUITEM "К&артинку...", ID_EXTRACTBITMAP
            MENUITEM "Извлечь &как RC файл...", ID_EXTRACTRC
            MENUITEM "&Двоичный ресурсный элемент...", ID_EXTRACTBIN
        }
        MENUITEM SEPARATOR
        MENUITEM "И&зменить имя/язык\tF2", ID_EDITLABEL
        MENUITEM SEPARATOR
        MENUITEM "Клонировать с новым &именем...", ID_COPYASNEWNAME
        MENUITEM "Клонировать с новым &языком...", ID_COPYASNEWLANG
        MENUITEM "Копировать на несколько языков ......", ID_COPYTOMULTILANG
        MENUITEM SEPARATOR
        MENUITEM "Про&тестировать", ID_TEST
        MENUITEM SEPARATOR
        MENUITEM "&Удалить\tDel", ID_DELETERES
    }
    POPUP "Popup #1"
    {
        MENUITEM "&Добавить управляющий элемент...", ID_ADDCTRL
        MENUITEM SEPARATOR
        MENUITEM "В&ырезать\tCtrl+X", ID_CUT
        MENUITEM "С&копировать\tCtrl+C", ID_COPY
        MENUITEM "&Вставить\tCtrl+V", ID_PASTE
        MENUITEM "&Удалить\tDel", ID_DELCTRL
        MENUITEM SEPARATOR
        POPUP "&Индекс"
        {
            MENUITEM "&Наверх", ID_CTRLINDEXTOP
            MENUITEM SEPARATOR
            MENUITEM "У&меньшение индекса", ID_CTRLINDEXMINUS
            MENUITEM "Ув&еличение индекса", ID_CTRLINDEXPLUS
            MENUITEM SEPARATOR
            MENUITEM "&Вниз", ID_CTRLINDEXBOTTOM
            MENUITEM SEPARATOR
            MENUITEM "&Показать/скрыть индексы\tCtrl+D", ID_SHOWHIDEINDEX
        }
        POPUP "&Выравнивание"
        {
            MENUITEM "В&верх", ID_TOPALIGN
            MENUITEM "В&низ", ID_BOTTOMALIGN
            MENUITEM "В&лево", ID_LEFTALIGN
            MENUITEM "В&право", ID_RIGHTALIGN
            MENUITEM SEPARATOR
            MENUITEM "По &сетке", ID_FITTOGRID
        }
        MENUITEM SEPARATOR
        MENUITEM "О&бновить", ID_REFRESHDIALOG
        MENUITEM SEPARATOR
        MENUITEM "Свойства для &элемента управления...", ID_CTRLPROP
        MENUITEM "Свойства для &диалога...", ID_DLGPROP
    }
    POPUP "Popup #2"
    {
        MENUITEM "&Изменить...", ID_MODIFYASSOC
    }
    POPUP "Popup #3"
    {
        MENUITEM "&Перейти!", ID_IDJUMP
        MENUITEM SEPARATOR
        MENUITEM "&Добавить ID...", ID_ADDRESID
        MENUITEM "Из&менить ID...", ID_MODIFYRESID
        MENUITEM SEPARATOR
        MENUITEM "Скопировать &имя", ID_COPYRESIDNAME
        MENUITEM "Скопировать &значение", ID_COPYRESIDVALUE
        MENUITEM "Скопировать &определение\tCtrl+C", ID_COPYIDDEF
        MENUITEM SEPARATOR
        MENUITEM "&Удалить ID\tDel", ID_DELETERESID
        MENUITEM SEPARATOR
        MENUITEM "Д&есятичные числа", ID_BASE10
        MENUITEM "&Шестнадцатеричные числа", ID_BASE16
        MENUITEM SEPARATOR
        MENUITEM "Перез&агрузить", ID_LOADRESH
    }
    POPUP "Popup #4"
    {
        MENUITEM "&Добавить...", ID_ADD
        MENUITEM SEPARATOR
        MENUITEM "Изменить &имя...\tF2", ID_RENAME
        MENUITEM "Изменить &значение...", ID_MODIFY
        MENUITEM SEPARATOR
        MENUITEM "&Удалить\tDel", ID_DELETE
    }
    POPUP "Popup #5"
    {
        MENUITEM "С&копировать целочисленное значение", ID_COPY
    }
    POPUP "Popup #6"
    {
        MENUITEM "&Добавить...", psh1
        MENUITEM "&Изменить...", psh2
        MENUITEM SEPARATOR
        MENUITEM "&Выше", psh4
        MENUITEM "&Ниже", psh5
        MENUITEM "&Левее", psh6
        MENUITEM "&Правее", psh7
        MENUITEM SEPARATOR
        MENUITEM "&Удалить\tDel", psh3
    }
    POPUP "Popup #7"
    {
        MENUITEM "&Добавить...", psh1
        MENUITEM "&Изменить...", psh2
        MENUITEM SEPARATOR
        MENUITEM "&Выше", psh4
        MENUITEM "&Ниже", psh5
        MENUITEM SEPARATOR
        MENUITEM "&Удалить\tDel", psh3
    }
    POPUP "Popup #8"
    {
        MENUITEM "&Добавить...", ID_ADD
        MENUITEM "&Изменить...", ID_MODIFY
        MENUITEM SEPARATOR
        MENUITEM "&Удалить\tDel", ID_DELETE
    }
}

//////////////////////////////////////////////////////////////////////////////
// RT_DIALOG

IDD_REPLACERES DIALOGEX 0, 0, 215, 170
CAPTION "Заменить ресурс"
STYLE DS_MODALFRAME | WS_POPUPWINDOW | WS_CAPTION
FONT 9, "MS Shell Dlg", 0, 0, 1
{
    LTEXT "&Тип ресурса:", -1, 5, 7, 70, 12
    COMBOBOX cmb1, 75, 5, 135, 200, CBS_HASSTRINGS | CBS_AUTOHSCROLL | CBS_DROPDOWN | WS_BORDER | WS_VSCROLL | WS_TABSTOP
    LTEXT "&Имя ресурса:", -1, 5, 32, 70, 12
    COMBOBOX cmb2, 75, 30, 135, 200, CBS_HASSTRINGS | CBS_AUTOHSCROLL | CBS_DROPDOWN | WS_DISABLED | WS_BORDER | WS_VSCROLL | WS_TABSTOP
    LTEXT "&Язык ресурса:", -1, 5, 57, 70, 12
    COMBOBOX cmb3, 75, 55, 135, 200, CBS_HASSTRINGS | CBS_AUTOHSCROLL | CBS_DROPDOWN | WS_DISABLED | WS_BORDER | WS_VSCROLL | WS_TABSTOP
    LTEXT "&Двоичный файл:", -1, 5, 85, 100, 12
    EDITTEXT edt1, 5, 97, 205, 14, ES_AUTOHSCROLL
    PUSHBUTTON "О&бзор...", psh1, 150, 115, 60, 14
    DEFPUSHBUTTON "OK", IDOK, 35, 150, 60, 14
    PUSHBUTTON "Отмена", IDCANCEL, 115, 150, 60, 14
    {
        0x1234, 0x5678, 0x0011
    }
}

IDD_ADDICON DIALOG 0, 0, 215, 135
CAPTION "Добавить значок"
STYLE DS_MODALFRAME | WS_POPUPWINDOW | WS_CAPTION
FONT 9, "MS Shell Dlg"
{
    LTEXT "&Файл значка:", -1, 5, 7, 100, 12
    EDITTEXT edt1, 5, 18, 205, 14, ES_AUTOHSCROLL
    PUSHBUTTON "О&бзор...", psh1, 150, 35, 60, 14
    ICON 0, ico1, 5, 35, 0, 0
    LTEXT "&Имя ресурса:", -1, 5, 67, 70, 12
    COMBOBOX cmb2, 75, 65, 120, 300, CBS_HASSTRINGS | CBS_AUTOHSCROLL | CBS_DROPDOWN | WS_BORDER | WS_VSCROLL | WS_TABSTOP
    PUSHBUTTON "&...", psh2, 195, 65, 15, 14
    LTEXT "&Язык ресурса:", -1, 5, 92, 70, 12
    COMBOBOX cmb3, 75, 90, 135, 200, CBS_HASSTRINGS | CBS_AUTOHSCROLL | CBS_DROPDOWN | WS_BORDER | WS_VSCROLL | WS_TABSTOP
    DEFPUSHBUTTON "OK", IDOK, 35, 115, 60, 14
    PUSHBUTTON "Отмена", IDCANCEL, 115, 115, 60, 14
}

IDD_REPLACEICON DIALOG 0, 0, 215, 135
CAPTION "Заменить значок"
STYLE DS_MODALFRAME | WS_POPUPWINDOW | WS_CAPTION
FONT 9, "MS Shell Dlg"
{
    LTEXT "&Файл значка:", -1, 5, 7, 100, 12
    EDITTEXT edt1, 5, 18, 205, 14, ES_AUTOHSCROLL
    PUSHBUTTON "О&бзор...", psh1, 150, 35, 60, 14
    ICON 0, ico1, 5, 35, 0, 0
    LTEXT "&Имя ресурса:", -1, 5, 67, 70, 12
    COMBOBOX cmb2, 75, 65, 135, 13, CBS_HASSTRINGS | CBS_AUTOHSCROLL | CBS_DROPDOWN | WS_DISABLED | WS_BORDER | WS_VSCROLL | WS_TABSTOP
    LTEXT "&Язык ресурса:", -1, 5, 92, 70, 12
    COMBOBOX cmb3, 75, 90, 135, 13, CBS_HASSTRINGS | CBS_AUTOHSCROLL | CBS_DROPDOWN | WS_DISABLED | WS_BORDER | WS_VSCROLL | WS_TABSTOP
    DEFPUSHBUTTON "OK", IDOK, 35, 115, 60, 14
    PUSHBUTTON "Отмена", IDCANCEL, 115, 115, 60, 14
}

IDD_ADDBITMAP DIALOG 0, 0, 215, 135
CAPTION "Добавить растровую картинку"
STYLE DS_MODALFRAME | WS_POPUPWINDOW | WS_CAPTION
FONT 9, "MS Shell Dlg"
{
    LTEXT "&Файл картинки:", -1, 5, 7, 100, 12
    EDITTEXT edt1, 5, 18, 205, 14, ES_AUTOHSCROLL
    PUSHBUTTON "О&бзор...", psh1, 150, 35, 60, 14
    LTEXT "&Имя ресурса:", -1, 5, 67, 70, 12
    COMBOBOX cmb2, 75, 65, 120, 300, CBS_HASSTRINGS | CBS_AUTOHSCROLL | CBS_DROPDOWN | WS_BORDER | WS_VSCROLL | WS_TABSTOP
    PUSHBUTTON "&...", psh2, 195, 65, 15, 14
    LTEXT "&Язык ресурса:", -1, 5, 92, 70, 12
    COMBOBOX cmb3, 75, 90, 135, 200, CBS_HASSTRINGS | CBS_AUTOHSCROLL | CBS_DROPDOWN | WS_BORDER | WS_VSCROLL | WS_TABSTOP
    DEFPUSHBUTTON "OK", IDOK, 35, 115, 60, 14
    PUSHBUTTON "Отмена", IDCANCEL, 115, 115, 60, 14
}

IDD_REPLACEBMP DIALOG 0, 0, 215, 135
CAPTION "Заменить растровую картинку"
STYLE DS_MODALFRAME | WS_POPUPWINDOW | WS_CAPTION
FONT 9, "MS Shell Dlg"
{
    LTEXT "&Файл картинки:", -1, 5, 7, 100, 12
    EDITTEXT edt1, 5, 18, 205, 14, ES_AUTOHSCROLL
    PUSHBUTTON "О&бзор...", psh1, 150, 35, 60, 14
    LTEXT "&Имя ресурса:", -1, 5, 67, 70, 12
    COMBOBOX cmb2, 75, 65, 135, 200, CBS_HASSTRINGS | CBS_AUTOHSCROLL | CBS_DROPDOWN | WS_DISABLED | WS_BORDER | WS_VSCROLL | WS_TABSTOP
    LTEXT "&Язык ресурса:", -1, 5, 92, 70, 12
    COMBOBOX cmb3, 75, 90, 135, 200, CBS_HASSTRINGS | CBS_AUTOHSCROLL | CBS_DROPDOWN | WS_DISABLED | WS_BORDER | WS_VSCROLL | WS_TABSTOP
    DEFPUSHBUTTON "OK", IDOK, 35, 115, 60, 14
    PUSHBUTTON "Отмена", IDCANCEL, 115, 115, 60, 14
}

IDD_ADDRES DIALOG 0, 0, 215, 170
CAPTION "Добавить ресурс"
STYLE DS_MODALFRAME | WS_POPUPWINDOW | WS_CAPTION
FONT 9, "MS Shell Dlg"
{
    LTEXT "&Тип ресурса:", -1, 5, 7, 70, 12
    COMBOBOX cmb1, 75, 5, 135, 200, CBS_HASSTRINGS | CBS_AUTOHSCROLL | CBS_DROPDOWN | WS_BORDER | WS_VSCROLL | WS_TABSTOP
    LTEXT "&Имя ресурса:", -1, 5, 32, 70, 12
    COMBOBOX cmb2, 75, 30, 120, 300, CBS_HASSTRINGS | CBS_AUTOHSCROLL | CBS_DROPDOWN | WS_BORDER | WS_VSCROLL | WS_TABSTOP
    PUSHBUTTON "&...", psh2, 195, 30, 15, 14
    LTEXT "", stc1, 75, 43, 115, 10
    LTEXT "&Язык ресурса:", -1, 5, 57, 70, 12
    COMBOBOX cmb3, 75, 55, 135, 200, CBS_HASSTRINGS | CBS_AUTOHSCROLL | CBS_DROPDOWN | WS_BORDER | WS_VSCROLL | WS_TABSTOP
    LTEXT "&Двоичный файл:", -1, 5, 85, 100, 12
    EDITTEXT edt1, 5, 97, 205, 14, ES_AUTOHSCROLL
    PUSHBUTTON "О&бзор...", psh1, 150, 115, 60, 14
    LTEXT "", stc2, 5, 112, 100, 10
    DEFPUSHBUTTON "OK", IDOK, 35, 150, 60, 14
    PUSHBUTTON "Отмена", IDCANCEL, 115, 150, 60, 14
}

IDD_ADDCURSOR DIALOG 0, 0, 215, 135
CAPTION "Добавить курсор"
STYLE DS_MODALFRAME | WS_POPUPWINDOW | WS_CAPTION
FONT 9, "MS Shell Dlg"
{
    LTEXT "&Файл курсора:", -1, 5, 7, 100, 12
    EDITTEXT edt1, 5, 18, 205, 14, ES_AUTOHSCROLL
    PUSHBUTTON "О&бзор...", psh1, 150, 35, 60, 14
    ICON 0, ico1, 5, 35, 0, 0
    LTEXT "&Имя ресурса:", -1, 5, 67, 70, 12
    COMBOBOX cmb2, 75, 65, 120, 200, CBS_HASSTRINGS | CBS_AUTOHSCROLL | CBS_DROPDOWN | WS_BORDER | WS_VSCROLL | WS_TABSTOP
    PUSHBUTTON "&...", psh2, 195, 65, 15, 14
    LTEXT "&Язык ресурса:", -1, 5, 92, 70, 12
    COMBOBOX cmb3, 75, 90, 135, 200, CBS_HASSTRINGS | CBS_AUTOHSCROLL | CBS_DROPDOWN | WS_BORDER | WS_VSCROLL | WS_TABSTOP
    DEFPUSHBUTTON "OK", IDOK, 35, 115, 60, 14
    PUSHBUTTON "Отмена", IDCANCEL, 115, 115, 60, 14
}

IDD_REPLACECUR DIALOG 0, 0, 215, 135
CAPTION "Заменить курсор"
STYLE DS_MODALFRAME | WS_POPUPWINDOW | WS_CAPTION
FONT 9, "MS Shell Dlg"
{
    LTEXT "&Файл курсора:", -1, 5, 7, 100, 12
    EDITTEXT edt1, 5, 18, 205, 14, ES_AUTOHSCROLL
    PUSHBUTTON "О&бзор...", psh1, 150, 35, 60, 14
    ICON 0, ico1, 5, 35, 0, 0
    LTEXT "&Имя ресурса:", -1, 5, 67, 70, 12
    COMBOBOX cmb2, 75, 65, 135, 200, CBS_HASSTRINGS | CBS_AUTOHSCROLL | CBS_DROPDOWN | WS_DISABLED | WS_BORDER | WS_VSCROLL | WS_TABSTOP
    LTEXT "&Язык ресурса:", -1, 5, 92, 70, 12
    COMBOBOX cmb3, 75, 90, 135, 200, CBS_HASSTRINGS | CBS_AUTOHSCROLL | CBS_DROPDOWN | WS_DISABLED | WS_BORDER | WS_VSCROLL | WS_TABSTOP
    DEFPUSHBUTTON "OK", IDOK, 35, 115, 60, 14
    PUSHBUTTON "Отмена", IDCANCEL, 115, 115, 60, 14
}

IDD_MENUTEST DIALOG 0, 0, 215, 135
CAPTION "Тест меню"
STYLE DS_MODALFRAME | WS_POPUPWINDOW | WS_CAPTION
FONT 9, "MS Shell Dlg"
{
}

IDD_ADDKEY DIALOG 0, 0, 190, 120
CAPTION "Добавить клавишу"
STYLE DS_MODALFRAME | WS_POPUPWINDOW | WS_CAPTION
FONT 9, "MS Shell Dlg"
{
    RTEXT "&Клавиша:", -1, 5, 12, 60, 14
    COMBOBOX cmb1, 70, 10, 110, 200, CBS_DROPDOWN | WS_BORDER | WS_VSCROLL | WS_TABSTOP
    RTEXT "ID &команды:", -1, 5, 37, 60, 14
    COMBOBOX cmb2, 70, 35, 95, 300, CBS_DROPDOWN | WS_BORDER | WS_VSCROLL | WS_TABSTOP
    PUSHBUTTON "&...", psh1, 165, 35, 15, 14
    AUTOCHECKBOX "&VIRTKEY", chx1, 5, 60, 60, 14
    AUTOCHECKBOX "&NOINVERT", chx2, 70, 60, 60, 14
    AUTOCHECKBOX "&CONTROL", chx3, 5, 75, 60, 14
    AUTOCHECKBOX "&SHIFT", chx4, 70, 75, 60, 14
    AUTOCHECKBOX "&ALT", chx5, 140, 75, 45, 14
    DEFPUSHBUTTON "OK", IDOK, 60, 100, 60, 14
    PUSHBUTTON "Отмена", IDCANCEL, 125, 100, 60, 14
}

IDD_MODIFYKEY DIALOG 0, 0, 190, 120
CAPTION "Изменить клавишу"
STYLE DS_MODALFRAME | WS_POPUPWINDOW | WS_CAPTION
FONT 9, "MS Shell Dlg"
{
    RTEXT "&Клавиша:", -1, 5, 12, 60, 14
    COMBOBOX cmb1, 70, 10, 110, 200, CBS_DROPDOWN | WS_BORDER | WS_VSCROLL | WS_TABSTOP
    RTEXT "ID &команды:", -1, 5, 37, 60, 14
    COMBOBOX cmb2, 70, 35, 95, 200, CBS_DROPDOWN | WS_BORDER | WS_VSCROLL | WS_TABSTOP
    PUSHBUTTON "&...", psh1, 165, 35, 15, 14
    AUTOCHECKBOX "&VIRTKEY", chx1, 5, 60, 60, 14
    AUTOCHECKBOX "&NOINVERT", chx2, 70, 60, 60, 14
    AUTOCHECKBOX "&CONTROL", chx3, 5, 75, 60, 14
    AUTOCHECKBOX "&SHIFT", chx4, 70, 75, 60, 14
    AUTOCHECKBOX "&ALT", chx5, 140, 75, 45, 14
    DEFPUSHBUTTON "OK", IDOK, 60, 100, 60, 14
    PUSHBUTTON "Отмена", IDCANCEL, 125, 100, 60, 14
}

IDD_EDITACCEL DIALOG 0, 0, 285, 165
CAPTION "Редактировать акселераторы"
STYLE WS_POPUPWINDOW | WS_CAPTION | WS_THICKFRAME
FONT 9, "MS Shell Dlg"
{
    LTEXT "&Список клавишей:", -1, 5, 7, 100, 12
    CONTROL "", lst1, "SysListView32", LVS_NOSORTHEADER | LVS_AUTOARRANGE | LVS_NOLABELWRAP | LVS_SHOWSELALWAYS | LVS_SINGLESEL | LVS_REPORT | WS_BORDER | WS_VSCROLL | WS_HSCROLL | WS_TABSTOP, 5, 20, 210, 120
    PUSHBUTTON "&Добавить...", psh1, 220, 20, 60, 14
    PUSHBUTTON "&Изменить...", psh2, 220, 40, 60, 14
    PUSHBUTTON "&Удалить", psh3, 220, 60, 60, 14
    PUSHBUTTON "&Выше", psh4, 220, 100, 60, 14
    PUSHBUTTON "&Ниже", psh5, 220, 120, 60, 14
    DEFPUSHBUTTON "OK", IDOK, 155, 145, 60, 14
    PUSHBUTTON "Отмена", IDCANCEL, 220, 145, 60, 14
    PUSHBUTTON "У&далить все", psh6, 5, 145, 79, 14
}

IDD_ADDSTR DIALOG 0, 0, 255, 115
CAPTION "Добавить строковый элемент"
STYLE WS_POPUPWINDOW | WS_CAPTION | WS_THICKFRAME
FONT 9, "MS Shell Dlg"
{
    LTEXT "ID &строки:", -1, 5, 7, 50, 12
    COMBOBOX cmb1, 60, 5, 134, 200, CBS_HASSTRINGS | CBS_AUTOHSCROLL | CBS_DROPDOWN | WS_BORDER | WS_VSCROLL | WS_TABSTOP
    PUSHBUTTON "&...", psh1, 195, 5, 15, 14
    LTEXT "&Значение строки:", -1, 5, 27, 54, 16
    EDITTEXT edt1, 60, 25, 190, 45, ES_WANTRETURN | ES_AUTOVSCROLL | ES_MULTILINE | WS_VSCROLL
    AUTOCHECKBOX "З&аменять ""\\r\\n"" на ""\\n""", chx1, 60, 75, 190, 14
    DEFPUSHBUTTON "OK", IDOK, 125, 95, 60, 14
    PUSHBUTTON "Отмена", IDCANCEL, 190, 95, 60, 14
}

IDD_MODIFYSTR DIALOG 0, 0, 255, 115
CAPTION "Изменить строковый элемент"
STYLE WS_POPUPWINDOW | WS_CAPTION | WS_THICKFRAME
FONT 9, "MS Shell Dlg"
{
    LTEXT "ID &строки:", -1, 5, 7, 50, 12
    COMBOBOX cmb1, 60, 5, 134, 200, CBS_HASSTRINGS | CBS_AUTOHSCROLL | CBS_DROPDOWN | WS_BORDER | WS_VSCROLL | WS_TABSTOP
    PUSHBUTTON "&...", psh1, 195, 5, 15, 14
    LTEXT "&Значение строки:", -1, 5, 27, 54, 16
    EDITTEXT edt1, 60, 25, 190, 45, ES_WANTRETURN | ES_AUTOVSCROLL | ES_MULTILINE | WS_VSCROLL
    AUTOCHECKBOX "З&аменять ""\\r\\n"" на ""\\n""", chx1, 60, 75, 190, 14
    DEFPUSHBUTTON "OK", IDOK, 125, 95, 60, 14
    PUSHBUTTON "Отмена", IDCANCEL, 190, 95, 60, 14
}

IDD_STRINGS DIALOG 0, 0, 325, 160
CAPTION "Таблица строк"
STYLE WS_POPUPWINDOW | WS_CAPTION | WS_THICKFRAME
FONT 9, "MS Shell Dlg"
{
    LTEXT "&Строковые записи:", -1, 5, 7, 100, 12
    CONTROL "", lst1, "SysListView32", LVS_NOSORTHEADER | LVS_AUTOARRANGE | LVS_NOLABELWRAP | LVS_SHOWSELALWAYS | LVS_SINGLESEL | LVS_REPORT | WS_BORDER | WS_VSCROLL | WS_HSCROLL | WS_TABSTOP, 5, 20, 315, 115
    PUSHBUTTON "&Добавить...", psh1, 130, 3, 60, 14
    PUSHBUTTON "&Изменить...", psh2, 195, 3, 60, 14
    PUSHBUTTON "&Удалить", psh3, 260, 3, 60, 14
    DEFPUSHBUTTON "OK", IDOK, 195, 140, 60, 14
    PUSHBUTTON "Отмена", IDCANCEL, 260, 140, 60, 14
    PUSHBUTTON "У&далить все", psh4, 5, 140, 75, 14
}

IDD_ADDMITEM DIALOG 0, 0, 210, 200
CAPTION "Добавить элемент меню"
STYLE DS_MODALFRAME | WS_POPUPWINDOW | WS_CAPTION
FONT 9, "MS Shell Dlg"
{
    LTEXT "&Название:", -1, 5, 7, 55, 12
    COMBOBOX cmb1, 65, 6, 140, 200, CBS_AUTOHSCROLL | CBS_DROPDOWN | WS_BORDER | WS_VSCROLL | WS_TABSTOP
    LTEXT "ID &команды:", -1, 5, 32, 55, 12
    COMBOBOX cmb2, 65, 30, 125, 200, CBS_AUTOHSCROLL | CBS_DROPDOWN | WS_BORDER | WS_VSCROLL | WS_TABSTOP
    PUSHBUTTON "&...", psh1, 190, 30, 15, 14
    AUTOCHECKBOX "&GRAYED", chx1, 5, 60, 60, 14
    AUTOCHECKBOX "&BITMAP", chx3, 135, 60, 60, 14
    AUTOCHECKBOX "&OWNERDRAW", chx4, 5, 80, 65, 14
    AUTOCHECKBOX "&CHECKED", chx5, 75, 80, 60, 14
    AUTOCHECKBOX "SE&PARATOR", chx6, 140, 80, 60, 14
    AUTOCHECKBOX "MENU&BARBREAK", chx7, 5, 100, 75, 14
    AUTOCHECKBOX "MENUB&REAK", chx8, 85, 100, 70, 14
    AUTOCHECKBOX "&DEFAULT", chx9, 5, 120, 60, 14
    AUTOCHECKBOX "&HILITE", chx10, 70, 120, 60, 14
    AUTOCHECKBOX "RADIOCHEC&K", chx11, 135, 120, 60, 14
    AUTOCHECKBOX "RIGH&TORDER", chx12, 5, 139, 60, 14
    AUTOCHECKBOX "RIGHT&JUSTIFY", chx13, 70, 140, 70, 14
    LTEXT "ID &справки:", -1, 5, 162, 45, 12
    COMBOBOX cmb3, 55, 160, 100, 300, CBS_AUTOHSCROLL | CBS_DROPDOWN | WS_BORDER | WS_VSCROLL | WS_TABSTOP
    DEFPUSHBUTTON "OK", IDOK, 80, 180, 60, 14
    PUSHBUTTON "Отмена", IDCANCEL, 145, 180, 60, 14
}

IDD_MODIFYMITEM DIALOG 0, 0, 210, 200
CAPTION "Изменить элемент меню"
STYLE DS_MODALFRAME | WS_POPUPWINDOW | WS_CAPTION
FONT 9, "MS Shell Dlg"
{
    LTEXT "&Название:", -1, 5, 7, 55, 12
    COMBOBOX cmb1, 65, 6, 140, 200, CBS_AUTOHSCROLL | CBS_DROPDOWN | WS_BORDER | WS_VSCROLL | WS_TABSTOP
    LTEXT "ID &команды:", -1, 5, 32, 55, 12
    COMBOBOX cmb2, 65, 30, 125, 200, CBS_AUTOHSCROLL | CBS_DROPDOWN | WS_BORDER | WS_VSCROLL | WS_TABSTOP
    PUSHBUTTON "&...", psh1, 190, 30, 15, 14
    AUTOCHECKBOX "&GRAYED", chx1, 5, 60, 60, 14
    AUTOCHECKBOX "&BITMAP", chx3, 135, 60, 60, 14
    AUTOCHECKBOX "&OWNERDRAW", chx4, 5, 80, 65, 14
    AUTOCHECKBOX "&CHECKED", chx5, 75, 80, 60, 14
    AUTOCHECKBOX "SE&PARATOR", chx6, 140, 80, 60, 14
    AUTOCHECKBOX "MENU&BARBREAK", chx7, 5, 100, 75, 14
    AUTOCHECKBOX "MENUB&REAK", chx8, 85, 100, 70, 14
    AUTOCHECKBOX "&DEFAULT", chx9, 5, 120, 60, 14
    AUTOCHECKBOX "&HILITE", chx10, 70, 120, 60, 14
    AUTOCHECKBOX "RADIOCHEC&K", chx11, 135, 120, 60, 14
    AUTOCHECKBOX "RIGH&TORDER", chx12, 5, 139, 60, 14
    AUTOCHECKBOX "RIGHT&JUSTIFY", chx13, 70, 140, 70, 14
    LTEXT "ID &справки:", -1, 5, 162, 45, 12
    COMBOBOX cmb3, 55, 160, 100, 300, CBS_AUTOHSCROLL | CBS_DROPDOWN | WS_BORDER | WS_VSCROLL | WS_TABSTOP
    DEFPUSHBUTTON "OK", IDOK, 80, 180, 60, 14
    PUSHBUTTON "Отмена", IDCANCEL, 145, 180, 60, 14
}

IDD_EDITMENU DIALOG 0, 0, 325, 160
CAPTION "Редактировать ресурс Menu"
STYLE WS_POPUPWINDOW | WS_CAPTION | WS_THICKFRAME
FONT 9, "MS Shell Dlg"
{
    LTEXT "&Ресурс Menu:", -1, 5, 7, 85, 12
    CONTROL "", lst1, "SysListView32", LVS_NOSORTHEADER | LVS_AUTOARRANGE | LVS_NOLABELWRAP | LVS_SHOWSELALWAYS | LVS_SINGLESEL | LVS_REPORT | WS_BORDER | WS_VSCROLL | WS_HSCROLL | WS_TABSTOP, 5, 20, 315, 115
    PUSHBUTTON "&Добавить...", psh1, 95, 3, 50, 14
    PUSHBUTTON "&Изменить...", psh2, 150, 3, 50, 14
    PUSHBUTTON "&Удалить", psh3, 205, 3, 50, 14
    PUSHBUTTON "&Выше", psh4, 5, 140, 40, 14
    PUSHBUTTON "&Ниже", psh5, 50, 140, 40, 14
    PUSHBUTTON "&Левее", psh6, 95, 140, 40, 14
    PUSHBUTTON "&Правее", psh7, 140, 140, 41, 14
    AUTOCHECKBOX "Рас&ширенный", chx1, 260, 3, 60, 14
    DEFPUSHBUTTON "OK", IDOK, 195, 140, 60, 14
    PUSHBUTTON "Отмена", IDCANCEL, 260, 140, 60, 14
}

IDD_DLGPROP DIALOG 0, 0, 235, 315
CAPTION "Свойства диалога"
STYLE DS_MODALFRAME | WS_POPUPWINDOW | WS_CAPTION
FONT 9, "MS Shell Dlg"
{
    LTEXT "&Название:", -1, 5, 7, 85, 11
    COMBOBOX cmb1, 5, 20, 225, 300, CBS_HASSTRINGS | CBS_AUTOHSCROLL | CBS_DROPDOWN | WS_BORDER | WS_VSCROLL | WS_TABSTOP
    AUTOCHECKBOX "Расширенный &диалог", chx1, 100, 5, 86, 14
    LTEXT "С&лева:", -1, 5, 40, 33, 10
    EDITTEXT edt1, 5, 53, 30, 14, ES_NUMBER | ES_RIGHT
    CONTROL "", scr1, "msctls_updown32", UDS_NOTHOUSANDS | UDS_ARROWKEYS | UDS_AUTOBUDDY | UDS_ALIGNRIGHT | UDS_SETBUDDYINT, 23, 53, 12, 20
    LTEXT "С&верху:", -1, 50, 40, 33, 10
    EDITTEXT edt2, 50, 53, 30, 14, ES_NUMBER | ES_RIGHT
    CONTROL "", scr2, "msctls_updown32", UDS_NOTHOUSANDS | UDS_ARROWKEYS | UDS_AUTOBUDDY | UDS_ALIGNRIGHT | UDS_SETBUDDYINT, 53, 53, 12, 20
    LTEXT "Ш&ирина:", -1, 95, 40, 33, 10
    EDITTEXT edt3, 95, 53, 30, 14, ES_NUMBER | ES_RIGHT
    CONTROL "", scr3, "msctls_updown32", UDS_NOTHOUSANDS | UDS_ARROWKEYS | UDS_AUTOBUDDY | UDS_ALIGNRIGHT | UDS_SETBUDDYINT, 129, 56, 12, 20
    LTEXT "В&ысота:", -1, 142, 40, 33, 10
    EDITTEXT edt4, 142, 53, 30, 14, ES_NUMBER | ES_RIGHT
    CONTROL "", scr4, "msctls_updown32", UDS_NOTHOUSANDS | UDS_ARROWKEYS | UDS_AUTOBUDDY | UDS_ALIGNRIGHT | UDS_SETBUDDYINT, 162, 53, 12, 20
    LTEXT "&Класс:", -1, 5, 73, 85, 11
    COMBOBOX cmb2, 5, 88, 115, 200, CBS_HASSTRINGS | CBS_AUTOHSCROLL | CBS_DROPDOWN | WS_BORDER | WS_VSCROLL | WS_TABSTOP
    LTEXT "ID с&правки:", -1, 125, 73, 64, 11
    COMBOBOX cmb3, 125, 88, 65, 200, CBS_HASSTRINGS | CBS_AUTOHSCROLL | CBS_DROPDOWN | WS_BORDER | WS_VSCROLL | WS_TABSTOP
    LTEXT "&Шрифт:", -1, 5, 105, 80, 11
    COMBOBOX cmb4, 6, 118, 100, 200, CBS_HASSTRINGS | CBS_SORT | CBS_AUTOHSCROLL | CBS_DROPDOWN | WS_BORDER | WS_VSCROLL | WS_TABSTOP
    LTEXT "&Размер:", -1, 110, 105, 38, 12
    EDITTEXT edt5, 110, 118, 25, 14, ES_NUMBER
    AUTOCHECKBOX "&Ж", chx2, 140, 118, 20, 14
    AUTOCHECKBOX "&К", chx3, 165, 118, 20, 14
    LTEXT "Симво&лы:", -1, 5, 138, 80, 11
    COMBOBOX cmb5, 5, 148, 100, 100, CBS_AUTOHSCROLL | CBS_DROPDOWNLIST | WS_VSCROLL | WS_TABSTOP
    LTEXT "&Меню:", -1, 110, 138, 55, 11
    COMBOBOX cmb6, 110, 148, 99, 300, CBS_HASSTRINGS | CBS_AUTOHSCROLL | CBS_DROPDOWN | WS_BORDER | WS_VSCROLL | WS_TABSTOP
    LTEXT "С&тиль:", -1, 5, 168, 45, 11
    RTEXT "0x", -1, 52, 169, 10, 11
    EDITTEXT edt6, 67, 165, 45, 14, ES_AUTOHSCROLL
    LISTBOX lst1, 5, 183, 110, 110, LBS_DISABLENOSCROLL | LBS_NOINTEGRALHEIGHT | LBS_HASSTRINGS | LBS_MULTIPLESEL | WS_VSCROLL | WS_HSCROLL | WS_TABSTOP
    LTEXT "Р&асш.ст.:", -1, 120, 168, 48, 11
    RTEXT "0x", -1, 170, 169, 10, 11
    EDITTEXT edt7, 185, 165, 45, 14, ES_AUTOHSCROLL
    LISTBOX lst2, 120, 183, 110, 110, LBS_DISABLENOSCROLL | LBS_NOINTEGRALHEIGHT | LBS_HASSTRINGS | LBS_MULTIPLESEL | WS_VSCROLL | WS_HSCROLL | WS_TABSTOP
    DEFPUSHBUTTON "OK", IDOK, 106, 298, 60, 14
    PUSHBUTTON "Отмена", IDCANCEL, 171, 298, 60, 14
}

IDD_CTRLPROP DIALOG 0, 0, 235, 330
CAPTION "Свойства элемента управления"
STYLE DS_MODALFRAME | WS_POPUPWINDOW | WS_CAPTION
FONT 9, "MS Shell Dlg"
{
    LTEXT "Пр&едопредел. элемент:", -1, 5, 3, 74, 16
    COMBOBOX cmb1, 75, 5, 120, 55, CBS_HASSTRINGS | CBS_AUTOHSCROLL | CBS_DROPDOWN | WS_BORDER | WS_VSCROLL | WS_TABSTOP
    CONTROL "", ctl1, "ToolbarWindow32", TBSTYLE_FLAT | TBSTYLE_WRAPABLE | TBSTYLE_TOOLTIPS | CCS_NODIVIDER | CCS_NORESIZE, 5, 22, 185, 30
    LTEXT "&Название:", -1, 5, 55, 75, 12
    COMBOBOX cmb2, 5, 65, 195, 300, CBS_HASSTRINGS | CBS_AUTOHSCROLL | CBS_DROPDOWN | WS_BORDER | WS_VSCROLL | WS_TABSTOP
    PUSHBUTTON "&OLE...", psh2, 205, 65, 25, 14
    LTEXT "С&лева:", -1, 5, 85, 33, 11
    EDITTEXT edt1, 5, 99, 25, 14, ES_NUMBER | ES_RIGHT
    CONTROL "", scr1, "msctls_updown32", UDS_NOTHOUSANDS | UDS_ARROWKEYS | UDS_AUTOBUDDY | UDS_ALIGNRIGHT | UDS_SETBUDDYINT, 20, 99, 12, 20
    LTEXT "С&верху:", -1, 40, 85, 33, 11
    EDITTEXT edt2, 40, 99, 25, 14, ES_NUMBER | ES_RIGHT
    CONTROL "", scr2, "msctls_updown32", UDS_NOTHOUSANDS | UDS_ARROWKEYS | UDS_AUTOBUDDY | UDS_ALIGNRIGHT | UDS_SETBUDDYINT, 55, 99, 12, 20
    LTEXT "Ш&ирина:", -1, 75, 85, 33, 11
    EDITTEXT edt3, 75, 99, 25, 14, ES_NUMBER | ES_RIGHT
    CONTROL "", scr3, "msctls_updown32", UDS_NOTHOUSANDS | UDS_ARROWKEYS | UDS_AUTOBUDDY | UDS_ALIGNRIGHT | UDS_SETBUDDYINT, 90, 99, 12, 20
    LTEXT "В&ысота:", -1, 111, 85, 33, 11
    EDITTEXT edt4, 110, 99, 25, 14, ES_NUMBER | ES_RIGHT
    CONTROL "", scr4, "msctls_updown32", UDS_NOTHOUSANDS | UDS_ARROWKEYS | UDS_AUTOBUDDY | UDS_ALIGNRIGHT | UDS_SETBUDDYINT, 125, 99, 12, 20
    LTEXT "&ID:", -1, 150, 85, 70, 12
    COMBOBOX cmb3, 150, 99, 80, 300, CBS_HASSTRINGS | CBS_AUTOHSCROLL | CBS_DROPDOWN | WS_BORDER | WS_VSCROLL | WS_TABSTOP
    LTEXT "&Класс окна:", -1, 5, 119, 100, 12
    COMBOBOX cmb4, 5, 133, 115, 200, CBS_HASSTRINGS | CBS_AUTOHSCROLL | CBS_DROPDOWN | WS_BORDER | WS_VSCROLL | WS_TABSTOP
    LTEXT "ID с&правки:", -1, 125, 119, 70, 12
    COMBOBOX cmb5, 125, 133, 65, 200, CBS_HASSTRINGS | CBS_AUTOHSCROLL | CBS_DROPDOWN | WS_BORDER | WS_VSCROLL | WS_TABSTOP
    LTEXT "С&тиль:", -1, 5, 153, 45, 12
    RTEXT "0x", -1, 54, 153, 10, 12
    EDITTEXT edt6, 70, 151, 45, 14, ES_AUTOHSCROLL
    LISTBOX lst1, 5, 167, 110, 120, LBS_DISABLENOSCROLL | LBS_NOINTEGRALHEIGHT | LBS_HASSTRINGS | LBS_MULTIPLESEL | WS_VSCROLL | WS_HSCROLL | WS_TABSTOP
    LTEXT "Р&асш.ст.:", -1, 120, 153, 50, 12
    RTEXT "0x", -1, 172, 153, 10, 12
    EDITTEXT edt7, 185, 151, 45, 14, ES_AUTOHSCROLL
    LISTBOX lst2, 120, 167, 110, 120, LBS_DISABLENOSCROLL | LBS_NOINTEGRALHEIGHT | LBS_HASSTRINGS | LBS_MULTIPLESEL | WS_VSCROLL | WS_HSCROLL | WS_TABSTOP
    DEFPUSHBUTTON "OK", IDOK, 170, 293, 60, 14
    PUSHBUTTON "Отмена", IDCANCEL, 170, 309, 60, 14
    PUSHBUTTON "&Данные...", psh1, 5, 293, 90, 14
    PUSHBUTTON "Списо&к строк...", psh3, 5, 309, 90, 14
}

IDD_ADDCTRL DIALOG 0, 0, 235, 330
CAPTION "Добавить элемент управления"
STYLE DS_MODALFRAME | WS_POPUPWINDOW | WS_CAPTION
FONT 9, "MS Shell Dlg"
{
    LTEXT "Пр&едопредел. элемент:", -1, 5, 3, 74, 16
    COMBOBOX cmb1, 75, 5, 120, 55, CBS_HASSTRINGS | CBS_AUTOHSCROLL | CBS_DROPDOWN | WS_BORDER | WS_VSCROLL | WS_TABSTOP
    CONTROL "", ctl1, "ToolbarWindow32", TBSTYLE_FLAT | TBSTYLE_WRAPABLE | TBSTYLE_TOOLTIPS | CCS_NODIVIDER | CCS_NORESIZE, 5, 22, 185, 30
    LTEXT "&Название:", -1, 5, 55, 75, 12
    COMBOBOX cmb2, 5, 65, 195, 300, CBS_HASSTRINGS | CBS_AUTOHSCROLL | CBS_DROPDOWN | WS_BORDER | WS_VSCROLL | WS_TABSTOP
    PUSHBUTTON "&OLE...", psh2, 205, 65, 25, 14
    LTEXT "С&лева:", -1, 5, 85, 33, 11
    EDITTEXT edt1, 5, 99, 25, 14, ES_NUMBER | ES_RIGHT
    CONTROL "", scr1, "msctls_updown32", UDS_NOTHOUSANDS | UDS_ARROWKEYS | UDS_AUTOBUDDY | UDS_ALIGNRIGHT | UDS_SETBUDDYINT, 20, 99, 12, 20
    LTEXT "С&верху:", -1, 40, 85, 33, 11
    EDITTEXT edt2, 40, 99, 25, 14, ES_NUMBER | ES_RIGHT
    CONTROL "", scr2, "msctls_updown32", UDS_NOTHOUSANDS | UDS_ARROWKEYS | UDS_AUTOBUDDY | UDS_ALIGNRIGHT | UDS_SETBUDDYINT, 55, 99, 12, 20
    LTEXT "Ш&ирина:", -1, 75, 85, 33, 11
    EDITTEXT edt3, 75, 99, 25, 14, ES_NUMBER | ES_RIGHT
    CONTROL "", scr3, "msctls_updown32", UDS_NOTHOUSANDS | UDS_ARROWKEYS | UDS_AUTOBUDDY | UDS_ALIGNRIGHT | UDS_SETBUDDYINT, 90, 99, 12, 20
    LTEXT "В&ысота:", -1, 111, 85, 33, 11
    EDITTEXT edt4, 110, 99, 25, 14, ES_NUMBER | ES_RIGHT
    CONTROL "", scr4, "msctls_updown32", UDS_NOTHOUSANDS | UDS_ARROWKEYS | UDS_AUTOBUDDY | UDS_ALIGNRIGHT | UDS_SETBUDDYINT, 125, 99, 12, 20
    LTEXT "&ID:", -1, 150, 85, 70, 12
    COMBOBOX cmb3, 150, 99, 80, 300, CBS_HASSTRINGS | CBS_AUTOHSCROLL | CBS_DROPDOWN | WS_BORDER | WS_VSCROLL | WS_TABSTOP
    LTEXT "&Класс окна:", -1, 5, 119, 100, 12
    COMBOBOX cmb4, 5, 133, 115, 200, CBS_HASSTRINGS | CBS_AUTOHSCROLL | CBS_DROPDOWN | WS_BORDER | WS_VSCROLL | WS_TABSTOP
    LTEXT "ID с&правки:", -1, 125, 119, 70, 12
    COMBOBOX cmb5, 125, 133, 65, 200, CBS_HASSTRINGS | CBS_AUTOHSCROLL | CBS_DROPDOWN | WS_BORDER | WS_VSCROLL | WS_TABSTOP
    LTEXT "С&тиль:", -1, 5, 153, 45, 12
    RTEXT "0x", -1, 54, 153, 10, 12
    EDITTEXT edt6, 70, 151, 45, 14, ES_AUTOHSCROLL
    LISTBOX lst1, 5, 167, 110, 120, LBS_DISABLENOSCROLL | LBS_NOINTEGRALHEIGHT | LBS_HASSTRINGS | LBS_MULTIPLESEL | WS_VSCROLL | WS_HSCROLL | WS_TABSTOP
    LTEXT "Р&асш.ст.:", -1, 120, 153, 50, 12
    RTEXT "0x", -1, 172, 153, 10, 12
    EDITTEXT edt7, 185, 151, 45, 14, ES_AUTOHSCROLL
    LISTBOX lst2, 120, 167, 110, 120, LBS_DISABLENOSCROLL | LBS_NOINTEGRALHEIGHT | LBS_HASSTRINGS | LBS_MULTIPLESEL | WS_VSCROLL | WS_HSCROLL | WS_TABSTOP
    DEFPUSHBUTTON "OK", IDOK, 170, 293, 60, 14
    PUSHBUTTON "Отмена", IDCANCEL, 170, 309, 60, 14
    PUSHBUTTON "&Данные...", psh1, 5, 293, 90, 14
    PUSHBUTTON "Списо&к строк...", psh3, 5, 309, 90, 14
}

IDD_IDASSOC DIALOG 0, 0, 200, 220
CAPTION "Ассоциация ID"
STYLE DS_MODALFRAME | WS_POPUPWINDOW | WS_CAPTION
FONT 9, "MS Shell Dlg"
{
    LTEXT "&Ассоциация ID:", -1, 5, 5, 116, 12
    CONTROL "", lst1, "SysListView32", LVS_SHOWSELALWAYS | LVS_SINGLESEL | LVS_REPORT | WS_BORDER | WS_TABSTOP, 5, 20, 190, 150
    PUSHBUTTON "&Сбросить все", psh2, 5, 175, 85, 14
    PUSHBUTTON "&Изменить", psh1, 135, 175, 60, 14
    DEFPUSHBUTTON "OK", IDOK, 70, 200, 60, 14
    PUSHBUTTON "Отмена", IDCANCEL, 135, 200, 60, 14
}

IDD_MODIFYASSOC DIALOG 0, 0, 165, 68
CAPTION "Изменить ассоциацию ID"
STYLE DS_MODALFRAME | WS_POPUPWINDOW | WS_CAPTION
FONT 9, "MS Shell Dlg"
{
    RTEXT "&Тип ID:", -1, 5, 7, 65, 12
    EDITTEXT edt1, 80, 5, 80, 14, WS_DISABLED
    RTEXT "&Префикс ID:", -1, 5, 32, 65, 12
    EDITTEXT edt2, 80, 28, 80, 14, ES_AUTOHSCROLL
    DEFPUSHBUTTON "OK", IDOK, 35, 50, 60, 14
    PUSHBUTTON "Отмена", IDCANCEL, 100, 50, 60, 14
}

IDD_IDLIST DIALOG 0, 0, 200, 300
CAPTION "Идентификаторы ресурсов"
STYLE WS_OVERLAPPEDWINDOW
EXSTYLE WS_EX_TOOLWINDOW
FONT 9, "MS Shell Dlg"
{
    COMBOBOX cmb1, 0, 0, 200, 300, CBS_HASSTRINGS | CBS_SORT | CBS_OWNERDRAWFIXED | CBS_DROPDOWNLIST | WS_VSCROLL | WS_TABSTOP
    CONTROL "", lst1, "SysListView32", LVS_REPORT | WS_BORDER | WS_VSCROLL | WS_HSCROLL | WS_TABSTOP, 0, 15, 200, 285
}

IDD_CONFIG DIALOG 0, 0, 210, 285
CAPTION "Конфигурация"
STYLE DS_MODALFRAME | WS_POPUPWINDOW | WS_CAPTION
FONT 9, "MS Shell Dlg"
{
    AUTOCHECKBOX "Показывать &полный путь в заголовке", chx1, 5, 5, 200, 14
    AUTOCHECKBOX "Не использовать ID-&макросы", chx2, 5, 25, 200, 14
    AUTOCHECKBOX "&Продолжать предыдущую позицию окна", chx3, 5, 45, 200, 14
    AUTOCHECKBOX "&Автозагрузка соседнего ""&resource.h""", chx4, 5, 65, 200, 14
    AUTOCHECKBOX "Автопоказ &списка идентификаторов ресурсов", chx5, 5, 85, 200, 14
    AUTOCHECKBOX "То&чки в окне диалога", chx6, 5, 105, 200, 14
    RTEXT "В&ысота комбобокса:", -1, 10, 127, 75, 12
    EDITTEXT edt1, 90, 125, 34, 14, ES_NUMBER | ES_RIGHT
    CONTROL "", scr1, "msctls_updown32", UDS_NOTHOUSANDS | UDS_ARROWKEYS | UDS_AUTOBUDDY | UDS_ALIGNRIGHT | UDS_SETBUDDYINT, 129, 49, 12, 20
    AUTOCHECKBOX "&Заворот строк", chx9, 135, 125, 70, 14
    AUTOCHECKBOX "Зап&рос обновления ""resource.h""", chx7, 5, 145, 200, 14
    AUTOCHECKBOX "С&жимать EXE с помощью UPX при сохранении", chx8, 5, 165, 200, 14
    PUSHBUTTON "&Шрифты...", psh4, 5, 185, 200, 14
    PUSHBUTTON "&Макросы...", psh1, 5, 205, 93, 14
    PUSHBUTTON "П&ути...", psh2, 107, 205, 98, 14
    RTEXT "Имя OLE-&элементов:", -1, 5, 227, 80, 12
    COMBOBOX cmb1, 90, 225, 75, 300, CBS_HASSTRINGS | CBS_AUTOHSCROLL | CBS_DROPDOWN | WS_VSCROLL | WS_TABSTOP
    AUTOCHECKBOX "&Резервную копию", chx10, 5, 245, 75, 15
    RTEXT "Су&ффикс копии:", -1, 92, 248, 60, 15
    COMBOBOX cmb2, 158, 246, 45, 300, CBS_HASSTRINGS | CBS_AUTOHSCROLL | CBS_DROPDOWN | WS_VSCROLL | WS_TABSTOP
    DEFPUSHBUTTON "OK", IDOK, 100, 265, 50, 14
    PUSHBUTTON "Отмена", IDCANCEL, 155, 265, 50, 14
    PUSHBUTTON "С&бросить все", psh3, 5, 265, 75, 14
}

IDD_ADDRESID DIALOG 0, 0, 165, 90
CAPTION "Добавить ID ресурса"
STYLE DS_MODALFRAME | WS_POPUPWINDOW | WS_CAPTION
FONT 9, "MS Shell Dlg"
{
    RTEXT "&Тип ID:", -1, 10, 7, 50, 14
    COMBOBOX cmb1, 65, 5, 95, 300, CBS_AUTOHSCROLL | CBS_DROPDOWNLIST | WS_VSCROLL | WS_TABSTOP
    RTEXT "&Имя ID:", -1, 10, 27, 50, 14
    EDITTEXT edt1, 65, 25, 75, 14, ES_AUTOHSCROLL
    RTEXT "&Целое значение:", -1, 10, 44, 50, 16
    EDITTEXT edt2, 65, 45, 48, 14, ES_AUTOHSCROLL
    CONTROL "", scr1, "msctls_updown32", UDS_NOTHOUSANDS | UDS_ARROWKEYS | UDS_AUTOBUDDY | UDS_ALIGNRIGHT | UDS_SETBUDDYINT, 129, 49, 12, 20
    PUSHBUTTON "&Авто", psh1, 115, 45, 45, 14
    DEFPUSHBUTTON "OK", IDOK, 20, 70, 60, 14
    PUSHBUTTON "Отмена", IDCANCEL, 85, 70, 60, 14
}

IDD_MODIFYRESID DIALOG 0, 0, 165, 90
CAPTION "Изменить ID ресурса"
STYLE DS_MODALFRAME | WS_POPUPWINDOW | WS_CAPTION
FONT 9, "MS Shell Dlg"
{
    RTEXT "&Имя ID:", -1, 10, 12, 50, 14, SS_REALSIZEIMAGE | NOT WS_GROUP
    EDITTEXT edt1, 65, 10, 95, 14, ES_AUTOHSCROLL
    RTEXT "&Тип ID:", -1, 10, 32, 50, 14
    EDITTEXT edt2, 65, 30, 95, 14, ES_READONLY
    RTEXT "&Целое значение:", -1, 10, 49, 50, 16
    EDITTEXT edt3, 65, 50, 48, 14, ES_AUTOHSCROLL
    CONTROL "", scr1, "msctls_updown32", UDS_NOTHOUSANDS | UDS_ARROWKEYS | UDS_AUTOBUDDY | UDS_ALIGNRIGHT | UDS_SETBUDDYINT, 129, 49, 12, 20
    DEFPUSHBUTTON "OK", IDOK, 20, 70, 60, 14
    PUSHBUTTON "Отмена", IDCANCEL, 85, 70, 60, 14
}

IDD_ADVICERESH DIALOG 0, 0, 209, 184
CAPTION "Предложение модификации файла ""resource.h"""
STYLE DS_MODALFRAME | WS_POPUPWINDOW | WS_CAPTION
FONT 9, "MS Shell Dlg"
{
    LTEXT "Измените файл ""resource.h"" следующим образом:", -1, 10, 10, 195, 20
    EDITTEXT edt1, 10, 30, 190, 130, ES_READONLY | ES_MULTILINE
    DEFPUSHBUTTON "OK", IDOK, 140, 165, 60, 14
    PUSHBUTTON "О&чистить изменение", psh1, 10, 165, 90, 14
}

IDD_CLONEINNEWNAME DIALOG 0, 0, 215, 75
CAPTION "Клонировать с новым именем"
STYLE DS_MODALFRAME | WS_POPUPWINDOW | WS_CAPTION
FONT 9, "MS Shell Dlg"
{
    LTEXT "&Тип ресурса:", -1, 5, 7, 70, 12
    COMBOBOX cmb1, 75, 5, 135, 200, CBS_HASSTRINGS | CBS_AUTOHSCROLL | CBS_DROPDOWN | WS_DISABLED | WS_BORDER | WS_VSCROLL | WS_TABSTOP
    LTEXT "&Имя ресурса:", -1, 5, 32, 70, 12
    COMBOBOX cmb2, 75, 30, 120, 200, CBS_HASSTRINGS | CBS_AUTOHSCROLL | CBS_DROPDOWN | WS_BORDER | WS_VSCROLL | WS_TABSTOP
    PUSHBUTTON "&...", psh1, 195, 30, 15, 14
    DEFPUSHBUTTON "OK", IDOK, 35, 55, 60, 14
    PUSHBUTTON "Отмена", IDCANCEL, 115, 55, 60, 14
}

IDD_CLONEINNEWLANG DIALOG 0, 0, 215, 105
CAPTION "Клонировать с новым языком"
STYLE DS_MODALFRAME | WS_POPUPWINDOW | WS_CAPTION
FONT 9, "MS Shell Dlg"
{
    LTEXT "&Тип ресурса:", -1, 5, 7, 70, 12
    COMBOBOX cmb1, 75, 5, 135, 200, CBS_HASSTRINGS | CBS_AUTOHSCROLL | CBS_DROPDOWN | WS_DISABLED | WS_BORDER | WS_VSCROLL | WS_TABSTOP
    LTEXT "&Имя ресурса:", -1, 5, 32, 70, 12
    COMBOBOX cmb2, 75, 30, 120, 200, CBS_HASSTRINGS | CBS_AUTOHSCROLL | CBS_DROPDOWN | WS_DISABLED | WS_BORDER | WS_VSCROLL | WS_TABSTOP
    LTEXT "&Язык ресурса:", -1, 5, 57, 70, 12
    COMBOBOX cmb3, 75, 55, 135, 200, CBS_HASSTRINGS | CBS_AUTOHSCROLL | CBS_DROPDOWN | WS_BORDER | WS_VSCROLL | WS_TABSTOP
    DEFPUSHBUTTON "OK", IDOK, 35, 85, 60, 14
    PUSHBUTTON "Отмена", IDCANCEL, 115, 85, 60, 14
}

IDD_ITEMSEARCH DIALOG 0, 0, 171, 135
CAPTION "Поиск"
STYLE WS_POPUPWINDOW | WS_CAPTION
FONT 9, "MS Shell Dlg"
{
    LTEXT "Искомая &строка:", -1, 4, 10, 100, 14
    EDITTEXT edt1, 5, 25, 160, 15, ES_AUTOHSCROLL
    AUTOCHECKBOX "&Учитывать регистр", chx1, 5, 45, 120, 16
    GROUPBOX "Направление", -1, 5, 65, 160, 42
    AUTORADIOBUTTON "Н&азад", rad1, 15, 80, 60, 14, WS_TABSTOP
    AUTORADIOBUTTON "В&перёд", rad2, 90, 80, 60, 14, WS_TABSTOP
    DEFPUSHBUTTON "&Найти", IDOK, 40, 115, 60, 14
    PUSHBUTTON "Отмена", IDCANCEL, 105, 115, 60, 14
}

IDD_VERSIONINFO DIALOG 0, 0, 174, 150
CAPTION "О программе RisohEditor"
STYLE DS_MODALFRAME | WS_POPUPWINDOW | WS_CAPTION
FONT 12, "MS Shell Dlg"
{
    ICON IDI_MAIN, -1, 5, 5, 0, 0
    LTEXT "...", stc1, 30, 5, 140, 50
    CTEXT "https://katahiromz.web.fc2.com", stc2, 5, 60, 165, 12, SS_CENTERIMAGE | SS_NOTIFY | NOT WS_GROUP
    CONTROL "...", edt1, "EDIT", ES_READONLY | ES_AUTOHSCROLL | ES_AUTOVSCROLL | ES_MULTILINE | WS_BORDER | WS_VSCROLL | WS_HSCROLL, 5, 75, 165, 50
    DEFPUSHBUTTON "OK", IDOK, 55, 130, 60, 14
}

IDD_ADDMSG DIALOG 0, 0, 255, 105
CAPTION "Добавить запись сообщения"
STYLE DS_MODALFRAME | WS_POPUPWINDOW | WS_CAPTION
FONT 9, "MS Shell Dlg"
{
    LTEXT "ID &сообщения:", -1, 5, 7, 50, 12
    COMBOBOX cmb1, 65, 5, 134, 200, CBS_HASSTRINGS | CBS_AUTOHSCROLL | CBS_DROPDOWN | WS_BORDER | WS_VSCROLL | WS_TABSTOP
    PUSHBUTTON "&...", psh1, 200, 5, 15, 14
    LTEXT "&Значение сообщения:", -1, 5, 27, 80, 12
    EDITTEXT edt1, 5, 40, 245, 35, ES_WANTRETURN | ES_AUTOHSCROLL | ES_AUTOVSCROLL | ES_MULTILINE
    DEFPUSHBUTTON "OK", IDOK, 125, 85, 60, 14
    PUSHBUTTON "Отмена", IDCANCEL, 190, 85, 60, 14
}

IDD_MODIFYMSG DIALOG 0, 0, 255, 105
CAPTION "Изменить запись сообщения"
STYLE DS_MODALFRAME | WS_POPUPWINDOW | WS_CAPTION
FONT 9, "MS Shell Dlg"
{
    LTEXT "ID &сообщения:", -1, 5, 7, 50, 12
    COMBOBOX cmb1, 65, 5, 134, 200, CBS_HASSTRINGS | CBS_AUTOHSCROLL | CBS_DROPDOWN | WS_DISABLED | WS_BORDER | WS_VSCROLL | WS_TABSTOP
    LTEXT "&Значение сообщения:", -1, 5, 27, 80, 12
    EDITTEXT edt1, 5, 40, 245, 35, ES_WANTRETURN | ES_AUTOHSCROLL | ES_AUTOVSCROLL | ES_MULTILINE
    DEFPUSHBUTTON "OK", IDOK, 125, 85, 60, 14
    PUSHBUTTON "Отмена", IDCANCEL, 190, 85, 60, 14
}

IDD_MESSAGES DIALOG 0, 0, 325, 160
CAPTION "Таблица сообщений"
STYLE WS_POPUPWINDOW | WS_CAPTION | WS_THICKFRAME
FONT 9, "MS Shell Dlg"
{
    LTEXT "&Элементы сообщений:", -1, 5, 7, 80, 12
    CONTROL "", lst1, "SysListView32", LVS_NOSORTHEADER | LVS_AUTOARRANGE | LVS_NOLABELWRAP | LVS_SHOWSELALWAYS | LVS_SINGLESEL | LVS_REPORT | WS_BORDER | WS_VSCROLL | WS_HSCROLL | WS_TABSTOP, 5, 20, 315, 115
    PUSHBUTTON "&Добавить...", psh1, 130, 3, 60, 14
    PUSHBUTTON "&Изменить...", psh2, 195, 3, 60, 14
    PUSHBUTTON "&Удалить", psh3, 260, 3, 60, 14
    DEFPUSHBUTTON "OK", IDOK, 195, 140, 60, 14
    PUSHBUTTON "Отмена", IDCANCEL, 260, 140, 60, 14
    PUSHBUTTON "У&далить все", psh4, 5, 140, 75, 14
}

IDD_FONTS DIALOG 0, 0, 195, 110
CAPTION "Настройки шрифтов"
STYLE DS_MODALFRAME | WS_POPUPWINDOW | WS_CAPTION
FONT 9, "MS Shell Dlg"
{
    RTEXT "&Источник:", -1, 5, 5, 55, 15, SS_CENTERIMAGE | NOT WS_GROUP
    EDITTEXT edt1, 65, 5, 100, 14, ES_READONLY | ES_AUTOHSCROLL
    PUSHBUTTON "...", psh1, 170, 5, 19, 14
    RTEXT "&Двоичный:", -1, 5, 25, 55, 15, SS_CENTERIMAGE | NOT WS_GROUP
    EDITTEXT edt2, 65, 25, 100, 14, ES_READONLY | ES_AUTOHSCROLL
    PUSHBUTTON "...", psh2, 170, 25, 19, 14
    GROUPBOX "Просмотр", -1, 5, 45, 185, 39
    CTEXT "Источник", stc1, 15, 55, 80, 25, SS_CENTERIMAGE | NOT WS_GROUP
    CTEXT "Двоичный", stc2, 100, 55, 85, 25, SS_CENTERIMAGE | NOT WS_GROUP
    DEFPUSHBUTTON "OK", IDOK, 65, 90, 60, 14
    PUSHBUTTON "Отмена", IDCANCEL, 130, 90, 60, 14
}

IDD_MACROS DIALOG 0, 0, 265, 165
CAPTION "Предопределённые макросы"
STYLE WS_POPUPWINDOW | WS_CAPTION | WS_THICKFRAME
FONT 9, "MS Shell Dlg"
{
    LTEXT "Предопределённые &макросы:", -1, 5, 0, 100, 15, SS_CENTERIMAGE | NOT WS_GROUP
    CONTROL "", lst1, "SysListView32", LVS_EDITLABELS | LVS_SHOWSELALWAYS | LVS_SINGLESEL | LVS_REPORT | WS_BORDER | WS_TABSTOP, 5, 15, 190, 125
    PUSHBUTTON "&Добавить...", psh1, 200, 15, 60, 14
    PUSHBUTTON "&Изменить...", psh2, 200, 35, 60, 14
    PUSHBUTTON "&Удалить", psh3, 200, 55, 60, 14
    PUSHBUTTON "У&далить все", psh7, 200, 105, 60, 14
    DEFPUSHBUTTON "OK", IDOK, 135, 145, 60, 14
    PUSHBUTTON "Отмена", IDCANCEL, 200, 145, 60, 14
    PUSHBUTTON "С&бросить все", psh6, 5, 145, 60, 14
}

IDD_ADDMACRO DIALOG 0, 0, 190, 80
CAPTION "Добавить предопределённый макрос"
STYLE DS_MODALFRAME | WS_POPUPWINDOW | WS_CAPTION
FONT 9, "MS Shell Dlg"
{
    RTEXT "&Ключ:", -1, 5, 12, 60, 14
    COMBOBOX cmb1, 70, 10, 110, 200, CBS_DROPDOWN | WS_BORDER | WS_VSCROLL | WS_TABSTOP
    RTEXT "&Значение:", -1, 5, 37, 60, 14
    COMBOBOX cmb2, 70, 35, 110, 300, CBS_DROPDOWN | WS_BORDER | WS_VSCROLL | WS_TABSTOP
    DEFPUSHBUTTON "OK", IDOK, 60, 60, 60, 14
    PUSHBUTTON "Отмена", IDCANCEL, 125, 60, 60, 14
}

IDD_EDITMACRO DIALOG 0, 0, 190, 80
CAPTION "Изменить предопределённый макрос"
STYLE DS_MODALFRAME | WS_POPUPWINDOW | WS_CAPTION
FONT 9, "MS Shell Dlg"
{
    RTEXT "&Ключ:", -1, 5, 12, 60, 14
    COMBOBOX cmb1, 70, 10, 110, 200, CBS_DROPDOWN | WS_DISABLED | WS_BORDER | WS_VSCROLL | WS_TABSTOP
    RTEXT "&Значение:", -1, 5, 37, 60, 14
    COMBOBOX cmb2, 70, 35, 110, 300, CBS_DROPDOWN | WS_BORDER | WS_VSCROLL | WS_TABSTOP
    DEFPUSHBUTTON "OK", IDOK, 60, 60, 60, 14
    PUSHBUTTON "Отмена", IDCANCEL, 125, 60, 60, 14
}

IDD_CTRLDATA DIALOG 0, 0, 190, 130
CAPTION "Изменить управляющие данные"
STYLE DS_MODALFRAME | WS_POPUPWINDOW | WS_CAPTION
FONT 9, "MS Shell Dlg"
{
    LTEXT "&Двоичные данные:", -1, 5, 2, 87, 12
    EDITTEXT edt1, 5, 15, 180, 60, ES_AUTOVSCROLL | ES_MULTILINE | WS_VSCROLL
    LTEXT "Управляющие данные можно задавать 16-разрядными целыми значениями, разделяя их пробелами.", -1, 5, 80, 180, 25
    DEFPUSHBUTTON "OK", IDOK, 60, 110, 60, 14
    PUSHBUTTON "Отмена", IDCANCEL, 125, 110, 60, 14
}

IDD_PATHS DIALOG 0, 0, 295, 220
CAPTION "Задать пути"
STYLE WS_POPUPWINDOW | WS_CAPTION | WS_THICKFRAME
FONT 9, "MS Shell Dlg"
{
    LTEXT "&Включаемые папки:", -1, 5, 5, 102, 12
    LISTBOX lst1, 5, 20, 220, 105, LBS_NOINTEGRALHEIGHT | LBS_HASSTRINGS | LBS_SORT | WS_VSCROLL | WS_HSCROLL | WS_TABSTOP
    PUSHBUTTON "&Добавить...", psh1, 230, 20, 60, 14
    PUSHBUTTON "&Изменить...", psh2, 230, 40, 60, 14
    PUSHBUTTON "&Удалить", psh3, 230, 60, 60, 14
    PUSHBUTTON "&Выше", psh4, 230, 80, 60, 14
    PUSHBUTTON "&Ниже", psh5, 230, 100, 60, 14
    PUSHBUTTON "У&далить все", psh6, 5, 130, 95, 14
    RTEXT "&windres.exe:", stc1, 5, 157, 55, 12
    COMBOBOX cmb1, 70, 155, 155, 300, CBS_HASSTRINGS | CBS_AUTOHSCROLL | CBS_DROPDOWN | WS_VSCROLL | WS_TABSTOP
    PUSHBUTTON "О&бзор...", psh7, 230, 155, 60, 14
    RTEXT "&cpp.exe:", stc2, 5, 177, 55, 12
    COMBOBOX cmb2, 70, 175, 155, 300, CBS_HASSTRINGS | CBS_AUTOHSCROLL | CBS_DROPDOWN | WS_VSCROLL | WS_TABSTOP
    PUSHBUTTON "Об&зор...", psh8, 230, 175, 60, 14
    DEFPUSHBUTTON "OK", IDOK, 165, 200, 60, 14
    PUSHBUTTON "Отмена", IDCANCEL, 230, 200, 60, 14
    PUSHBUTTON "Сбросит&ь все", psh9, 5, 200, 95, 14
}

IDD_EXP_OPTIONS DIALOG 0, 0, 250, 225
CAPTION "Параметры экспорта"
STYLE DS_MODALFRAME | WS_POPUPWINDOW | WS_CAPTION
FONT 9, "MS Shell Dlg"
{
    ICON IDI_MAIN, -1, 5, 10, 0, 0
    LTEXT "При экспорте RC-файла создаются относящиеся к нему другие файлы. Выберите следующие опции:", -1, 35, 5, 210, 29
    AUTOCHECKBOX "Использовать &таблицу сообщений Microsoft", chx8, 5, 40, 240, 14
    AUTOCHECKBOX "Разделять файлы ресурсов по &языку", chx1, 5, 60, 240, 14
    AUTOCHECKBOX "Используйте ключевые &слова BEGIN/END", chx2, 5, 80, 240, 14
    AUTOCHECKBOX "Язык выбирается макросом LANGUAGE_*", chx3, 5, 100, 240, 14
    AUTOCHECKBOX "Создать &копию", chx4, 5, 120, 110, 14
    RTEXT "Суффикс:", -1, 120, 122, 75, 12
    COMBOBOX cmb1, 200, 120, 45, 300, CBS_HASSTRINGS | CBS_AUTOHSCROLL | CBS_DROPDOWN | WS_VSCROLL | WS_TABSTOP
    AUTOCHECKBOX "&Дополнительные комментарии", chx5, 5, 140, 240, 14
    AUTOCHECKBOX "&Оборачивать manifest в #ifndef MSVC ... #endif", chx6, 5, 160, 240, 14
    AUTOCHECKBOX "Сохранять RC-файлы в UTF-&16", chx7, 5, 180, 240, 14
    DEFPUSHBUTTON "OK", IDOK, 120, 205, 60, 14
    PUSHBUTTON "Отмена", IDCANCEL, 185, 205, 60, 14
}

IDD_LANGS DIALOG 0, 0, 250, 235
CAPTION "Языки"
STYLE WS_POPUPWINDOW | WS_CAPTION | WS_THICKFRAME
FONT 9, "MS Shell Dlg"
{
    CONTROL "", lst1, "SysListView32", LVS_SHOWSELALWAYS | LVS_SINGLESEL | LVS_REPORT | WS_BORDER | WS_TABSTOP, 5, 5, 240, 179
    RTEXT "&Поиск:", stc1, 5, 192, 45, 12
    COMBOBOX cmb1, 55, 190, 85, 300, CBS_SORT | CBS_DROPDOWN | WS_VSCROLL | WS_TABSTOP
    EDITTEXT edt1, 4, 209, 240, 20, ES_AUTOHSCROLL | ES_AUTOVSCROLL | ES_MULTILINE
}

IDD_CHILD DIALOG 0, 0, 215, 135
CAPTION "Дочерний диалог"
STYLE WS_CHILD | WS_OVERLAPPEDWINDOW
FONT 9, "MS Shell Dlg"
{
    DEFPUSHBUTTON "OK", IDOK, 35, 115, 60, 14
    PUSHBUTTON "Отмена", IDCANCEL, 115, 115, 60, 14
}

IDD_DLGINITEDIT DIALOG 0, 0, 325, 165
CAPTION "Изменить DLGINIT"
STYLE WS_POPUPWINDOW | WS_CAPTION | WS_THICKFRAME
FONT 9, "MS Shell Dlg"
{
    LTEXT "&Записи сообщений:", -1, 5, 7, 100, 12
    CONTROL "", lst1, "SysListView32", LVS_NOSORTHEADER | LVS_AUTOARRANGE | LVS_NOLABELWRAP | LVS_SHOWSELALWAYS | LVS_SINGLESEL | LVS_REPORT | WS_BORDER | WS_VSCROLL | WS_HSCROLL | WS_TABSTOP, 5, 20, 250, 120
    PUSHBUTTON "&Добавить...", psh1, 260, 20, 60, 14
    PUSHBUTTON "&Изменить...", psh2, 260, 40, 60, 14
    PUSHBUTTON "&Удалить", psh3, 260, 60, 60, 14
    PUSHBUTTON "&Выше", psh4, 260, 100, 60, 14
    PUSHBUTTON "&Ниже", psh5, 260, 120, 60, 14
    DEFPUSHBUTTON "OK", IDOK, 195, 145, 60, 14
    PUSHBUTTON "Отмена", IDCANCEL, 260, 145, 60, 14
    PUSHBUTTON "У&далить все", psh6, 5, 145, 79, 14
}

IDD_ADDDLGINIT DIALOG 0, 0, 184, 137
CAPTION "Добавить данные DLGINIT"
STYLE DS_MODALFRAME | WS_POPUPWINDOW | WS_CAPTION
FONT 9, "MS Shell Dlg"
{
    LTEXT "ID &элемента управления:", -1, 5, 4, 56, 16
    COMBOBOX cmb1, 65, 5, 115, 300, CBS_HASSTRINGS | CBS_AUTOHSCROLL | CBS_DROPDOWN | WS_VSCROLL | WS_TABSTOP
    LTEXT "&Сообщение:", -1, 5, 32, 55, 12
    COMBOBOX cmb2, 65, 30, 95, 300, CBS_HASSTRINGS | CBS_AUTOHSCROLL | CBS_DROPDOWN | WS_VSCROLL | WS_TABSTOP
    LTEXT "С&трока:", -1, 5, 52, 55, 12
    EDITTEXT edt1, 5, 65, 175, 50, ES_WANTRETURN | ES_MULTILINE | WS_VSCROLL | WS_HSCROLL
    DEFPUSHBUTTON "OK", IDOK, 55, 120, 60, 14
    PUSHBUTTON "Отмена", IDCANCEL, 120, 120, 60, 14
}

IDD_MODIFYDLGINIT DIALOG 0, 0, 184, 137
CAPTION "Изменить данные DLGINIT"
STYLE DS_MODALFRAME | WS_POPUPWINDOW | WS_CAPTION
FONT 9, "MS Shell Dlg"
{
    LTEXT "ID &элемента управления:", -1, 5, 4, 56, 16
    COMBOBOX cmb1, 65, 5, 115, 300, CBS_HASSTRINGS | CBS_AUTOHSCROLL | CBS_DROPDOWN | WS_VSCROLL | WS_TABSTOP
    LTEXT "&Сообщение:", -1, 5, 32, 55, 12
    COMBOBOX cmb2, 65, 30, 95, 300, CBS_HASSTRINGS | CBS_AUTOHSCROLL | CBS_DROPDOWN | WS_VSCROLL | WS_TABSTOP
    LTEXT "С&трока:", -1, 5, 52, 55, 12
    EDITTEXT edt1, 5, 65, 175, 50, ES_WANTRETURN | ES_MULTILINE | WS_VSCROLL | WS_HSCROLL
    DEFPUSHBUTTON "OK", IDOK, 55, 120, 60, 14
    PUSHBUTTON "Отмена", IDCANCEL, 120, 120, 60, 14
}

IDD_STRINGLIST DIALOG 0, 0, 205, 220
CAPTION "Список управляющих строк"
STYLE WS_POPUPWINDOW | WS_CAPTION | WS_THICKFRAME
FONT 9, "MS Shell Dlg"
{
    LTEXT "", stc1, 5, 5, 195, 70
    EDITTEXT edt1, 5, 80, 195, 115, ES_WANTRETURN | ES_MULTILINE | WS_VSCROLL | WS_HSCROLL
    DEFPUSHBUTTON "OK", IDOK, 75, 200, 60, 14
    PUSHBUTTON "Отмена", IDCANCEL, 140, 200, 60, 14
}

IDD_SAVE_OPTIONS DIALOG 0, 0, 250, 225
CAPTION "Параметры сохранения"
STYLE DS_MODALFRAME | WS_POPUPWINDOW | WS_CAPTION
FONT 9, "MS Shell Dlg"
{
    ICON IDI_MAIN, -1, 5, 10, 0, 0
    LTEXT "При сохранении RC-файла создаются относящиеся к нему другие файлы. Выберите следующие опции:", -1, 35, 5, 210, 29
    AUTOCHECKBOX "Использовать &таблицу сообщений Microsoft", chx8, 5, 40, 240, 14
    AUTOCHECKBOX "Разделять файлы ресурсов по &языку", chx1, 5, 60, 240, 14
    AUTOCHECKBOX "Используйте ключевые &слова BEGIN/END", chx2, 5, 80, 240, 14
    AUTOCHECKBOX "Язык выбирается макросом LANGUAGE_*", chx3, 5, 100, 240, 14
    AUTOCHECKBOX "Создать &копию", chx4, 5, 120, 110, 14
    RTEXT "Суффикс:", -1, 120, 122, 75, 12
    COMBOBOX cmb1, 200, 120, 45, 300, CBS_HASSTRINGS | CBS_AUTOHSCROLL | CBS_DROPDOWN | WS_VSCROLL | WS_TABSTOP
    AUTOCHECKBOX "&Дополнительные комментарии", chx5, 5, 140, 240, 14
    AUTOCHECKBOX "&Оборачивать manifest в #ifndef MSVC ... #endif", chx6, 5, 160, 240, 14
    AUTOCHECKBOX "Сохранять RC-файлы в UTF-&16", chx7, 5, 180, 240, 14
    DEFPUSHBUTTON "OK", IDOK, 120, 205, 60, 14
    PUSHBUTTON "Отмена", IDCANCEL, 185, 205, 60, 14
}

IDD_ENCODING DIALOG 0, 0, 200, 170
CAPTION "Кодировка элемента ресурса"
STYLE DS_MODALFRAME | WS_POPUPWINDOW | WS_CAPTION
FONT 9, "MS Shell Dlg"
{
    CONTROL "", lst1, "SysListView32", LVS_SHOWSELALWAYS | LVS_SINGLESEL | LVS_REPORT | WS_BORDER, 5, 5, 190, 115
    PUSHBUTTON "&Добавить...", psh1, 5, 125, 60, 14
    PUSHBUTTON "&Изменить...", psh2, 70, 125, 60, 14
    PUSHBUTTON "&Удалить", psh3, 135, 125, 60, 14
    DEFPUSHBUTTON "OK", IDOK, 70, 150, 60, 14
    PUSHBUTTON "Отмена", IDCANCEL, 135, 150, 60, 14
    PUSHBUTTON "&Сброс", psh5, 5, 149, 60, 14
}

IDD_ADDENC DIALOG 0, 0, 215, 80
CAPTION "Добавить кодировку ресурса"
STYLE DS_MODALFRAME | WS_POPUPWINDOW | WS_CAPTION
FONT 9, "MS Shell Dlg"
{
    LTEXT "&Тип ресурса:", -1, 5, 7, 70, 12
    COMBOBOX cmb1, 75, 5, 135, 200, CBS_HASSTRINGS | CBS_AUTOHSCROLL | CBS_DROPDOWN | WS_BORDER | WS_VSCROLL | WS_TABSTOP
    LTEXT "&Кодировка:", -1, 5, 30, 70, 12
    COMBOBOX cmb2, 75, 30, 85, 300, CBS_HASSTRINGS | CBS_AUTOHSCROLL | CBS_DROPDOWNLIST | WS_VSCROLL | WS_TABSTOP
    DEFPUSHBUTTON "OK", IDOK, 86, 60, 60, 14
    PUSHBUTTON "Отмена", IDCANCEL, 150, 60, 60, 14
}

IDD_MODIFYENC DIALOG 0, 0, 215, 80
CAPTION "Изменить кодировку ресурса"
STYLE DS_MODALFRAME | WS_POPUPWINDOW | WS_CAPTION
FONT 9, "MS Shell Dlg"
{
    LTEXT "&Тип ресурса:", -1, 5, 7, 70, 12
    COMBOBOX cmb1, 75, 5, 135, 200, CBS_HASSTRINGS | CBS_AUTOHSCROLL | CBS_DROPDOWN | WS_DISABLED | WS_BORDER | WS_VSCROLL | WS_TABSTOP
    LTEXT "&Кодировка:", -1, 5, 30, 70, 12
    COMBOBOX cmb2, 75, 30, 85, 300, CBS_HASSTRINGS | CBS_AUTOHSCROLL | CBS_DROPDOWNLIST | WS_VSCROLL | WS_TABSTOP
    DEFPUSHBUTTON "OK", IDOK, 86, 60, 60, 14
    PUSHBUTTON "Отмена", IDCANCEL, 150, 60, 60, 14
}

IDD_CONSTANT DIALOG 0, 0, 205, 75
CAPTION "Константа запроса"
STYLE DS_MODALFRAME | WS_POPUPWINDOW | WS_CAPTION
FONT 9, "MS Shell Dlg"
{
    LTEXT "&Имя константы:", -1, 5, 7, 80, 12
    COMBOBOX cmb1, 94, 7, 105, 300, CBS_HASSTRINGS | CBS_AUTOHSCROLL | CBS_DROPDOWN | WS_VSCROLL | WS_TABSTOP
    LTEXT "&Значение константы:", -1, 5, 32, 80, 12
    EDITTEXT edt2, 95, 30, 50, 14, ES_READONLY
    EDITTEXT edt3, 150, 30, 50, 14, ES_READONLY
    DEFPUSHBUTTON "OK", IDOK, 70, 55, 60, 14
}

IDD_EGA DIALOG 0, 0, 400, 225
CAPTION "Язык программирования EGA"
STYLE WS_POPUPWINDOW | WS_CAPTION | WS_THICKFRAME
FONT 9, "MS Shell Dlg"
{
    GROUPBOX "EGA-консоль", grp1, 5, 5, 390, 195
    EDITTEXT edt1, 10, 20, 380, 170, ES_READONLY | ES_AUTOVSCROLL | ES_MULTILINE | WS_VSCROLL | NOT WS_TABSTOP
    RTEXT "EGA>", stc1, 10, 208, 20, 10
    EDITTEXT edt2, 35, 205, 300, 15, ES_WANTRETURN | ES_AUTOHSCROLL | ES_AUTOVSCROLL | ES_MULTILINE
    PUSHBUTTON "&Enter", IDOK, 345, 205, 50, 15
}

IDD_FONTSUBST DIALOG 0, 0, 185, 180
CAPTION "Dialog Font Substitutes"
STYLE DS_CENTER | DS_MODALFRAME | WS_POPUPWINDOW | WS_CAPTION
FONT 9, "MS Shell Dlg"
{
    LTEXT "Шрифт #&1:", -1, 5, 7, 44, 12
    COMBOBOX cmb1, 55, 5, 125, 300, CBS_HASSTRINGS | CBS_AUTOHSCROLL | CBS_DROPDOWN | WS_VSCROLL | WS_TABSTOP
    ICON IDI_ARROW, -1, 30, 25, 0, 0
    COMBOBOX cmb2, 55, 30, 125, 300, CBS_HASSTRINGS | CBS_AUTOHSCROLL | CBS_DROPDOWN | WS_VSCROLL | WS_TABSTOP
    LTEXT "Шрифт #&2:", -1, 5, 57, 44, 12
    COMBOBOX cmb3, 55, 55, 125, 300, CBS_HASSTRINGS | CBS_AUTOHSCROLL | CBS_DROPDOWN | WS_VSCROLL | WS_TABSTOP
    ICON IDI_ARROW, -1, 30, 75, 0, 0
    COMBOBOX cmb4, 55, 80, 125, 300, CBS_HASSTRINGS | CBS_AUTOHSCROLL | CBS_DROPDOWN | WS_VSCROLL | WS_TABSTOP
    LTEXT "Шрифт #&3:", -1, 5, 105, 44, 12
    COMBOBOX cmb5, 55, 105, 125, 300, CBS_HASSTRINGS | CBS_AUTOHSCROLL | CBS_DROPDOWN | WS_VSCROLL | WS_TABSTOP
    ICON IDI_ARROW, -1, 30, 125, 0, 0
    COMBOBOX cmb6, 55, 130, 125, 300, CBS_HASSTRINGS | CBS_AUTOHSCROLL | CBS_DROPDOWN | WS_VSCROLL | WS_TABSTOP
    DEFPUSHBUTTON "OK", IDOK, 75, 160, 50, 14
    PUSHBUTTON "Отмена", IDCANCEL, 130, 160, 50, 14
    PUSHBUTTON "&Сброс", psh1, 5, 160, 55, 14
}

IDD_DROPDOWNPOPUP DIALOG 0, 0, 120, 150
CAPTION " "
STYLE WS_POPUP | WS_DLGFRAME | NOT WS_BORDER
FONT 9, "MS Shell Dlg"
{
    LISTBOX lst1, 0, 0, 120, 150, LBS_WANTKEYBOARDINPUT | LBS_NOINTEGRALHEIGHT | LBS_HASSTRINGS | WS_VSCROLL | WS_TABSTOP, WS_EX_CLIENTEDGE
}

IDD_DFMSETTINGS DIALOG 0, 0, 210, 135
CAPTION "Установки Delphi DFM"
STYLE DS_CENTER | DS_MODALFRAME | WS_POPUPWINDOW | WS_CAPTION
FONT 9, "MS Shell Dlg"
{
    LTEXT "Следующие установки относятся к Delphi DFM:", -1, 35, 5, 171, 20
    ICON IDI_DFMICON, -1, 5, 5, 0, 0
    RTEXT "&Кодовая страница:", -1, 6, 32, 70, 12
    COMBOBOX cmb1, 85, 30, 120, 300, CBS_HASSTRINGS | CBS_AUTOHSCROLL | CBS_DROPDOWN | WS_VSCROLL | WS_TABSTOP
    AUTOCHECKBOX "&Вставлять необработанные строковые комментарии", chx1, 5, 50, 200, 14
    AUTOCHECKBOX "Не использовать &Юникод и UTF-8", chx2, 5, 70, 200, 14
    DEFPUSHBUTTON "OK", IDOK, 80, 115, 60, 14
    PUSHBUTTON "Отмена", IDCANCEL, 145, 115, 60, 14
}

IDD_COPYTOMULTILANG DIALOG 0, 0, 200, 195
CAPTION "Копировать на несколько языков"
STYLE DS_CENTER | DS_MODALFRAME | WS_POPUPWINDOW | WS_CAPTION
FONT 9, "MS Shell Dlg"
{
    LTEXT "Добавьте языки, на которые вы хотите скопировать ресурс:", -1, 5, 5, 190, 22
    LTEXT "&Языки:", -1, 5, 35, 82, 12
    LISTBOX lst1, 5, 50, 190, 100, LBS_WANTKEYBOARDINPUT | LBS_NOINTEGRALHEIGHT | LBS_HASSTRINGS | WS_VSCROLL | WS_TABSTOP
    COMBOBOX cmb3, 5, 155, 126, 14, CBS_HASSTRINGS | CBS_AUTOHSCROLL | CBS_DROPDOWN | WS_BORDER | WS_VSCROLL | WS_TABSTOP
    PUSHBUTTON "&Добавлять", psh1, 135, 155, 60, 14
    DEFPUSHBUTTON "OK", IDOK, 5, 175, 60, 14
    PUSHBUTTON "Отмена", IDCANCEL, 70, 175, 60, 14
}

IDD_TOOLBARRES DIALOG 0, 0, 230, 195
CAPTION "Ресурс панели инструментов"
STYLE DS_CENTER | DS_MODALFRAME | WS_POPUPWINDOW | WS_CAPTION
FONT 9, "MS Shell Dlg"
{
    RTEXT "&Ширина значка:", -1, 5, 5, 60, 15, SS_CENTERIMAGE | NOT WS_GROUP
    EDITTEXT edt1, 70, 5, 30, 15, ES_NUMBER | ES_RIGHT
    CONTROL "", scr1, "msctls_updown32", UDS_NOTHOUSANDS | UDS_ARROWKEYS | UDS_AUTOBUDDY | UDS_ALIGNRIGHT | UDS_SETBUDDYINT, 80, 5, 30, 15
    RTEXT "&Высота значка:", -1, 110, 5, 60, 15, SS_CENTERIMAGE | NOT WS_GROUP
    EDITTEXT edt2, 180, 5, 30, 15, ES_NUMBER | ES_RIGHT
    CONTROL "", scr2, "msctls_updown32", UDS_NOTHOUSANDS | UDS_ARROWKEYS | UDS_AUTOBUDDY | UDS_ALIGNRIGHT | UDS_SETBUDDYINT, 190, 5, 30, 15
    LTEXT "&Кнопки панели инструментов:", -1, 5, 25, 140, 15, SS_CENTERIMAGE | NOT WS_GROUP
    LISTBOX lst1, 5, 40, 140, 130, LBS_DISABLENOSCROLL | LBS_WANTKEYBOARDINPUT | LBS_NOINTEGRALHEIGHT | LBS_HASSTRINGS | LBS_OWNERDRAWFIXED | WS_VSCROLL | WS_TABSTOP
    PUSHBUTTON "&Добавить...", psh1, 150, 40, 75, 15
    PUSHBUTTON "&Изменить...", psh2, 150, 60, 75, 15
    PUSHBUTTON "&Удалить", psh3, 150, 80, 75, 15
    PUSHBUTTON "&Выше", psh4, 150, 135, 75, 15
    PUSHBUTTON "&Ниже", psh5, 150, 155, 75, 15
    DEFPUSHBUTTON "OK", IDOK, 5, 175, 60, 15
    PUSHBUTTON "Отмена", IDCANCEL, 70, 175, 60, 15
}

IDD_ADDTBBTN DIALOG 0, 0, 177, 92
CAPTION "Добавить кнопку панели инструментов"
STYLE DS_CENTER | DS_MODALFRAME | WS_POPUPWINDOW | WS_CAPTION
FONT 9, "MS Shell Dlg"
{
    LTEXT "&Идентификатор команды кнопки панели инструментов:", -1, 5, 5, 160, 15, SS_CENTERIMAGE | NOT WS_GROUP
    COMBOBOX cmb1, 5, 25, 150, 150, CBS_HASSTRINGS | CBS_AUTOHSCROLL | CBS_DROPDOWN | WS_VSCROLL | WS_TABSTOP
    AUTOCHECKBOX "&Разделитель", chx1, 5, 45, 90, 15
    DEFPUSHBUTTON "OK", IDOK, 45, 70, 60, 15
    PUSHBUTTON "Отмена", IDCANCEL, 110, 70, 60, 15
}

IDD_MODIFYTBBTN DIALOG 0, 0, 177, 92
CAPTION "Кнопка Изменить панель инструментов"
STYLE DS_CENTER | DS_MODALFRAME | WS_POPUPWINDOW | WS_CAPTION
FONT 9, "MS Shell Dlg"
{
    LTEXT "&Идентификатор команды кнопки панели инструментов:", -1, 5, 5, 160, 15, SS_CENTERIMAGE | NOT WS_GROUP
    COMBOBOX cmb1, 5, 25, 150, 150, CBS_HASSTRINGS | CBS_AUTOHSCROLL | CBS_DROPDOWN | WS_VSCROLL | WS_TABSTOP
    AUTOCHECKBOX "&Разделитель", chx1, 5, 45, 90, 15
    DEFPUSHBUTTON "OK", IDOK, 45, 70, 60, 15
    PUSHBUTTON "Отмена", IDCANCEL, 110, 70, 60, 15
}

//////////////////////////////////////////////////////////////////////////////
// RT_VERSION

1 VERSIONINFO
FILEVERSION     5, 7, 9, 0
PRODUCTVERSION  5, 7, 9, 0
FILEOS          0x40004
FILETYPE        0x1
FILESUBTYPE     0x0
{
    BLOCK "StringFileInfo"
    {
        BLOCK "04190376"
        {
            VALUE "CompanyName", "Katayama Hirofumi MZ\0"
            VALUE "FileDescription", "RisohEditor\0"
            VALUE "FileVersion", "5.7.9\0"
            VALUE "LegalCopyright", "Copyright (C) 2017-2020 Katayama Hirofumi MZ and Dmitry Yerokhin. All rights reserved.\0"
            VALUE "ProductName", "RisohEditor\0"
            VALUE "ProductVersion", "5.7.9\0"
        }
    }
    BLOCK "VarFileInfo"
    {
        VALUE "Translation", 0x0419, 0x0376
    }
}

//////////////////////////////////////////////////////////////////////////////
// RISOHTEMPLATE

4 RISOHTEMPLATE "res/1049_RISOHTEMPLATE_4.bin"

5 RISOHTEMPLATE "res/1049_RISOHTEMPLATE_5.bin"

//////////////////////////////////////////////////////////////////////////////
// RT_STRING

STRINGTABLE
{
    IDS_APPNAME, "RisohEditor 5.7.9 (c) Katayama Hirofumi MZ"
    IDS_TITLEWITHFILE, "RisohEditor 5.7.9 - Файл: %s"
    IDS_EXTRACTRES, "Извлечь ресурс"
    IDS_RESBINFILTER, "Двоичные ресурсы (*.res)|*.res|Двоичные файлы (*.bin)|*.bin|Все файлы (*.*)|*.*|"
    IDS_CANNOTSAVE, "Невозможно сохранить."
    IDS_REPLACERES, "Заменить ресурс"
    IDS_ALLFILES, "Все файлы (*.*)|*.*|"
    IDS_ENTERTYPE, "Укажите тип ресурса."
    IDS_ENTERNAME, "Укажите имя ресурса."
    IDS_ENTERLANG, "Укажите язык ресурса."
    IDS_FILENOTFOUND, "Файл не найден."
    IDS_CANNOTREPLACE, "Невозможно заменить."
    IDS_EXERESFILTER, "Исполняемые файлы (*.exe;*.dll;*.ocx;*.cpl;*.scr;*.mui)|*.exe;*.dll;*.ocx;*.cpl;*.scr;*.mui|RC-файлы (*.rc)|*.rc|Двоичные ресурсы (*.res)|*.res|Все файлы (*.*)|*.*|"
    IDS_SAVEAS, "Сохранить как"
    IDS_CANNOTADDICON, "Невозможно добавить значок."
    IDS_ADDICON, "Добавить значок"
    IDS_ICOFILTER, "Значки (*.ico)|*.ico|Все файлы (*.*)|*.*|"
    IDS_REPLACEICO, "Заменить значок"
    IDS_CANTREPLACEICO, "Невозможно заменить значок."
    IDS_EXISTSOVERWRITE, "Элемент уже существует. Перезаписать?"
    IDS_OPEN, "Открыть"
    IDS_CANNOTOPEN, "Невозможно открыть файл."
    IDS_ADDBMP, "Добавить картинку"
    IDS_BMPFILTER, "Растровые картинки (*.bmp)|*.bmp|Изображения PNG (*.png)|*.png|Все файлы (*.*)|*.*|"
    IDS_CANTREPLACEBMP, "Невозможно заменить растровую картинку."
    IDS_REPLACEBMP, "Заменить растровую картинку"
    IDS_ERRORCODE, "Код ошибки %d"
    IDS_VERSIONINFO, "RisohEditor версия 5.7.9\r\n\r\nKatayama Hirofumi MZ\r\n\r\nЛицензия: GPLv3 (free software)"
    IDS_ADDRES, "Добавить ресурс"
    IDS_CANNOTADDRES, "Невозможно добавить ресурс."
    IDS_CANTADDBMP, "Невозможно добавить растровую картинку."
    IDS_EXTRACTBMP, "Извлечь растровые картинки"
    IDS_CANTEXTRACTBMP, "Невозможно извлечь растровую картинку."
    IDS_CANTREPLACECUR, "Невозможно заменить курсор."
    IDS_CANNOTADDCUR, "Невозможно добавить курсор."
    IDS_CURFILTER, "Курсоры (*.cur)|*.cur|Анимированные курсоры (*.ani)|*.ani|Все файлы (*.*)|*.*|"
    IDS_ADDCUR, "Добавить курсор"
    IDS_REPLACECUR, "Заменить курсор"
    IDS_EXTRACTICO, "Извлечь значок"
    IDS_CANTEXTRACTICO, "Невозможно извлечь значок."
    IDS_EXTRACTCUR, "Извлечь курсор"
    IDS_CANTEXTRACTCUR, "Невозможно извлечь курсор."
    IDS_RESFILTER, "Двоичные ресурсы (*.res)|*.res|Все файлы (*.*)|*.*|"
    IDS_NEUTRAL, "Нейтральный"
    IDS_IMPORTRES, "Импорт"
    IDS_CANNOTIMPORT, "Невозможно импортировать ресурс."
    IDS_COMPILE, "Компилировать (F8)"
    IDS_CANCELEDIT, "Отмена правки (Ctrl+E)"
    IDS_GUIEDIT, "Править в GUI (Ctrl+G)"
    IDS_CANNOTSTARTUP, "Невозможно запустить компилятор ресурсов."
    IDS_RESMISMATCH, "Не соответствует тип ресурса."
    IDS_SAMPLETEXT, "Это пример."
    IDS_ALREADYEXISTS, "Уже существует."
    IDS_KEY, "Ключ"
    IDS_FLAGS, "Флаги"
    IDS_COMMANDID, "ID команды"
    IDS_INVALIDKEY, "Неверный ключ."
    IDS_COMPILEERROR, "Ошибка компиляции."
    IDS_STRINGID, "ID строки"
    IDS_STRINGVALUE, "Значение строки"
    IDS_CAPTION, "Название"
    IDS_HELPID, "ID справки"
    IDS_INDENT, "» "
    IDS_DATAISEMPTY, "Данные пусты."
    IDS_TEST, "Протестировать"
    IDS_SEPARATOR, "---"
    IDS_COMPILENOW, "Данные изменились. Откомпилировать?"
    IDS_RADWINDOW, "Правка диалога"
    IDS_ENTERCLASS, "Введите корректное имя класса окна."
    IDS_TEXTEDIT, "Правка как текста (Ctrl+T)"
    IDS_CURSORINFO, "Рисунок #%u: ширина %u, высота %u, бит %u, x-точка %u, y-точка %u, ID %u\r\n"
    IDS_IMAGECOUNT, "Рисунков: %u\r\n"
    IDS_ICONINFO, "Рисунок #%u: ширина %u, высота %u, бит %u, ID %u\r\n"
    IDS_READY, "Готов"
    IDS_EXECUTINGCMD, "Выполнение команды..."
    IDS_EDITINGBYGUI, "Правка в GUI..."
    IDS_COORD, "%d, %d, %d, %d"
    IDS_STARTING, "Запуск..."
    IDS_COMPILING, "Компиляция..."
    IDS_CANNOTLOAD, "Невозможно загрузить."
    IDS_NONE, "(нет)"
    IDS_WAVESOUND, "(звук WAVE)\r\n"
    IDS_IDTYPE, "Тип ID"
    IDS_IDPREFIX, "Префикс ID"
    IDS_EMPTYSTR, "Введите строку."
    IDS_ANICURSOR, "(анимированный курсор)\r\n"
    IDS_ANIICON, "(анимированный значок)\r\n"
    IDS_HEADFILTER, "Файлы заголовков (*.h)|*.h|Все файлы (*.*)|*.*|"
    IDS_LOADRESH, "Загрузить файл ""resource.h"""
    IDS_NAME, "Имя"
    IDS_VALUE, "Значение"
    IDS_NOSUCHID, "Такой ID не найден."
    IDS_IMAGEINFO, "Ширина %u, высота %u, бит %u\r\n"
    IDS_ENTERINT, "Введите корректное целое число."
    IDS_ENTERTEXT, "Введите корректный текст."
    IDS_ENTERID, "Введите корректный ID."
    IDS_ADDNEXTIDS, "Добавьте следующие ID в ""resource.h"":\r\n\r\n"
    IDS_DELETENEXTIDS, "Удалите следующие ID из ""resource.h"":\r\n\r\n"
    IDS_NOCHANGE, "Нет изменений в ID ресурсов."
    IDS_DLGFAIL, "Не удалось создать диалог RAD."
    IDS_LOADWCLIB, "Загрузить библиотеку классов окон"
    IDS_AVIMOVIE, "(AVI-видео)\r\n"
    IDS_ADDDIALOG, "Добавить диалог"
    IDS_ADDMENU, "Добавить меню"
    IDS_ADDVERINFO, "Добавить информацию о версии"
    IDS_ADDCURSOR, "Добавить курсор"
    IDS_NOMOREITEM, "Больше нет элементов."
    IDS_INVALIDDATA, "(неверные данные)\r\n"
    IDS_UPDATERESH, "Обновить ""resource.h""?"
    IDS_CANTWRITERESH, "Невозможно записать ""resource.h""."
    IDS_SAVERESH, "Сохранить файл ""resource.h"""
    IDS_DLLFILTER, "Файлы DLL (*.dll;*.ocx;*.mui)|*.dll;*.ocx;*.mui|Все файлы (*.*)|*.*|"
    IDS_EXERESRCFILTER, "Загружаемые файлы (*.exe;*.dll;*.ocx;*.cpl;*.scr;*.mui;*.res;*.rc)|*.exe;*.dll;*.ocx;*.cpl;*.scr;*.mui;*.res;*.rc|Исполняемые файлы (*.exe;*.dll;*.ocx;*.cpl;*.scr;*.mui)|*.exe;*.dll;*.ocx;*.cpl;*.scr;*.mui|Двоичные ресурсы (*.res)|*.res|Файлы ресурсов (*.rc)|*.rc|Все файлы (*.*)|*.*|"
    IDS_CANTTESTCHILDWND, "Невозможно протестировать диалог, так как это дочернее окно."
    IDS_CANTTESTCLASSDLG, "Невозможно протестировать диалог из-за его класса."
    IDS_FILEISUPXED, "Файл\r\n\r\n'%s'\r\n\r\nсжат с помощью UPX. Распаковать его во временный файл?\r\n\r\nЕсли этого не сделать, возможна ошибка при чтении."
    IDS_CANTUPXEXTRACT, "Невозможно распаковать с помощью UPX."
    IDS_CANTSAVEUPXED, "Невозможно сохранить файл, так как он сжат с помощью UPX."
    IDS_MESSAGEID, "ID сообщения"
    IDS_MESSAGEVALUE, "Значение сообщения"
    IDS_RCFILTER, "RC-файлы (*.rc)|*.rc|"
    IDS_EXPORT, "Экспорт"
    IDS_CANTEXPORT, "Ошибка экспорта."
    IDS_MUSTBEEMPTYDIR, "Если есть внешний файл, экспорт должен выполняться в пустую папку."
    IDS_FULLWIDTH, "０１２３４５６７８９ＡＢＣＤＥＦＧＨＩＪＫＬＭＮＯＰＱＲＳＴＵＶＷＸＹＺａｂｃｄｅｆｇｈｉｊｋｌｍｎｏｐｑｒｓｔｕｖｗｘｙｚ－＿（）．　"
    IDS_HALFWIDTH, "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz-_(). "
    IDS_MACRONAME, "Имя макроса"
    IDS_MACROVALUE, "Значение макроса"
    IDS_OPTIONAL, "(необязательно)"
    IDS_ADDINCLUDE, "Добавить папку включения"
    IDS_EDITINCLUDE, "Изменить папку включения"
    IDS_WINDRESEXE, "windres.exe|windres.exe|"
    IDS_CPPEXE, "cpp.exe|cpp.exe|"
    IDS_INVALIDPATH, "Неверный путь."
    IDS_DATATOOLONG, "Слишком длинные данные."
    IDS_ALL, "(все)"
    IDS_UNKNOWNFORMAT, "(неизвестный формат данных)\r\n"
    IDS_LANGUAGE, "Язык"
    IDS_INTVALUE, "Целочисленное значение"
    IDS_PARENTWND, "Родительское тест-окно"
    IDS_CHOOSE_OLE_CLSID, "Выберите OLE CLSID"
    IDS_CONTROL, "Элемент управления"
    IDS_MESSAGE, "Сообщение"
    IDS_STRING, "Строка"
    IDS_DATAISINVALID, "Неверные данные."
    IDS_DLGINIT1, "Можно указать инициализацию комбобоксов и списков, задав данные инициализации в RT_DLGINIT с тем же именем, что и у ресурса диалога. "
    IDS_DLGINIT2, "При поступлении сообщения WM_INITDIALOG приложение может инициализировать диалог вызовом функции ExecuteDlgInitDx у прикреплённого файла ""DlgInit/DlgInit.h"".\r\n\r\n"
    IDS_DLGINIT3, "Укажите для RT_DLGINIT список строк символов, разделённых переводами строки."
    IDS_SAMELANG, "Это тот же язык."
    IDS_SAMENAME, "Это то же имя ресурса."
    IDS_CANTSAVETOEXE, "Невозможно сохранить как EXE из не-исполняемого файла."
    IDS_CANTSTARTSEARCH, "Невозможно начать поиск."
    IDS_AMERICA, "Америка"
    IDS_ENGLISH, "Английский"
    IDS_CHINA, "Китай"
    IDS_CHINESE, "Китайский"
    IDS_RUSSIA, "Россия"
    IDS_RUSSIAN, "Русский"
    IDS_WANNAGENRESH, "Хотите создать файл 'resource.h'?"
    IDS_EXEFILTER, "Исполняемые файлы (*.exe;*.dll;*.ocx;*.cpl;*.scr;*.mui)|*.exe;*.dll;*.ocx;*.cpl;*.scr;*.mui|Все файлы (*.*)|*.*|"
    IDS_SAVEASCOMPRESS, "Сохранить со сжатием"
    IDS_TOOL_NEW, "Создать"
    IDS_TOOL_OPEN, "Открыть..."
    IDS_TOOL_SAVE, "Сохранить как..."
    IDS_TOOL_EXPAND, "Распахнуть все"
    IDS_TOOL_COLLAPSE, "Свернуть все"
    IDS_TOOL_PLUS, "Добавить элемент..."
    IDS_TOOL_MINUS, "Удалить элемент"
    IDS_TOOL_CHANGE, "Изменить имя/язык"
    IDS_TOOL_CLONE, "Клонировать с другим именем/языком"
    IDS_TOOL_RECOMPILE, "Перекомпилировать"
    IDS_TOOL_CANCELEDIT, "Отмена правки"
    IDS_TOOL_IMPORT, "Импорт..."
    IDS_TOOL_EXTRACT, "Извлечь..."
    IDS_TOOL_GUIEDIT, "Правка в GUI"
    IDS_UNITEDKINGDOM, "Соединённое Королевство"
    IDS_GREATBRITAIN, "Великобритания"
    IDS_BRITISH, "Британский"
    IDS_FRANCE, "Франция"
    IDS_FRENCH, "Французский"
    IDS_GERMANY, "Германия"
    IDS_GERMAN, "Немецкий"
    IDS_SPAIN, "Испания"
    IDS_SPANISH, "Испанский"
    IDS_INVALIDLANG, "Нераспознанный язык."
    IDS_INVALIDNAME, "Неверное имя ресурса."
    IDS_PNGRESBINFILTER, "Изображения PNG (*.png)|*.png|Двоичные ресурсы (*.res)|*.res|Двоичные файлы (*.bin)|*.bin|Все файлы (*.*)|*.*|"
    IDS_JPEGRESBINFILTER, "Изображения JPEG (*.jpg;*.jpeg;*.jpe;*.jfif)|*.jpg;*.jpeg;*.jpe;*.jfif|Двоичные ресурсы (*.res)|*.res|Двоичные файлы (*.bin)|*.bin|Все файлы (*.*)|*.*|"
    IDS_GIFRESBINFILTER, "Изображения GIF (*.gif)|*.gif|Двоичные ресурсы (*.res)|*.res|Двоичные файлы (*.bin)|*.bin|Все файлы (*.*)|*.*|"
    IDS_TIFFRESBINFILTER, "Изображения TIFF (*.tif;*.tiff)|*.tif;*.tiff|Двоичные ресурсы (*.res)|*.res|Двоичные файлы (*.bin)|*.bin|Все файлы (*.*)|*.*|"
    IDS_AVIRESBINFILTER, "Видеофайлы AVI (*.avi)|*.avi|Двоичные ресурсы (*.res)|*.res|Двоичные файлы (*.bin)|*.bin|Все файлы (*.*)|*.*|"
    IDS_WAVERESBINFILTER, "Аудиофайлы WAVE (*.wav)|*.wav|Двоичные ресурсы (*.res)|*.res|Двоичные файлы (*.bin)|*.bin|Все файлы (*.*)|*.*|"
    IDS_COMMENT_SEP, "//////////////////////////////////////////////////////////////////////////////\r\n\r\n"
    IDS_NEWLINE, "\r\n"
    IDS_NOTICE, "// Этот файл был автоматически создан RisohEditor 5.7.9.\r\n"
    IDS_DAGGER, "// † <-- Этот крестик помогает определять UTF-8.\r\n"
    IDS_IMPORTFILTER, "Файлы импорта |*.rc;*.res;*.dfm;*.html;*.htm;*.manifest;*.ico;*.cur;*.ani;*.wav;*.bmp;*.dib;*.png;*.gif;*.jpg;*.jpeg;*.jpe;*.jfif;*.tif;*.tiff;*.avi;*.wmf;*.emf|RC-файлы (*.rc)|*.rc|Двоичные ресурсы (*.res)|*.res|Изображения|*.bmp;*.dib;*.png;*.gif;*.jpg;*.jpeg;*.jpe;*.jfif;*.tif;*.tiff;*.wmf;*.emf;*.tlb|Курсоры (*.cur;*.ani)|*.cur;*.ani|Значки (*.ico)|*.ico|Аудиофайлы WAVE (*.wav)|*.wav|HTML-файлы (*.html;*.htm)|*.html;*.htm|Файлы манифеста (*.manifest)|*.manifest|Delphi DFM файлы (*.dfm)|*.dfm|Файлы TYPELIB (*.tlb)|*.tlb|Все файлы (*.*)|*.*|"
    IDS_CANTWRITEBYLOCK, "Невозможно записать файл, так как заблокирован следующий файл:\r\n\r\n%s"
    IDS_ANSI, "ANSI"
    IDS_WIDE, "Юникод"
    IDS_UTF8, "UTF-8 (с BOM)"
    IDS_UTF8N, "UTF-8 (без BOM)"
    IDS_SJIS, "Shift_JIS"
    IDS_BINARY, "(двоичные данные)"
    IDS_RESTYPE, "Тип ресурса"
    IDS_ENCODING, "Кодировка"
    IDS_INVALIDRESTYPE, "Неверный тип ресурса."
    IDS_PATHSPACEERROR, "Неверная установка программы - в пути содержатся пробелы! Компилятор ресурсов не допускает пробелов.\n\nНе устанавливайте программу в папку ""C:\\Program Files"" и подобные."
    IDS_LOADEGAPROGRAM, "Загрузить программу EGA..."
    IDS_EGAFILTER, "Программа EGA (*.ega)|*.ega|Все файлы (*.*)|*.*|"
    IDS_QUERYSAVECHANGE, "Файл был изменён. Хотите сохранить изменения?"
    IDS_DFMFILTER, "Файл DFM (*.dfm)|*.dfm|Текстовые файлы (*.txt)|*.txt|Все файлы (*.*)|*.*|"
    IDS_CANTEXTRACTDFM, "Невозможно извлечь данные DFM."
    IDS_EXTRACTDFM, "Извлечь данные DFM"
    IDS_ENTERNONZERONAME, "Введите не пустое имя ресурса."
    IDS_ENTERNONZEROTYPE, "Введите не пустой тип ресурса."
    IDS_HOMEPAGE, "https://katahiromz.web.fc2.com/re/ru/"
    IDS_FILESAVED, "Файл успешно сохранён."
    IDS_RECOMPILEOK, "Перекомпиляция успешно выполнена."
    IDS_RECOMPILEFAILED, "Перекомпиляция не выполнена (ошибка синтаксиса)."
    IDS_TOOL_EXPORT, "Экспорт..."
    IDS_CODEEDITOR, "Редактор кода"
    IDS_HEXVIEWER, "16-ричный просмотр"
    IDS_INTEGERORIDENTIFIER, "(целое число или идентификатор)"
    IDS_NOTEXT, " "
    IDS_NOUPDATE, "У вас самая новая версия RisohEditor."
    IDS_THEREISUPDATE, "Доступен RisohEditor версии %s. Хотите загрузить?"
    IDS_CANTCHECKUPDATE, "Не удалось проверить наличие новой версии RisohEditor."
    IDS_CODEPAGE1252, "1252 (Латинская 1)"
    IDS_CODEPAGE1250, "1250 (Латинская 2)"
    IDS_CODEPAGE1251, "1251 (Кириллица)"
    IDS_CODEPAGE1253, "1253 (Греческая)"
    IDS_CODEPAGE1254, "1254 (Турецкая)"
    IDS_CODEPAGE1255, "1255 (Иврит)"
    IDS_CODEPAGE1256, "1256 (Арабская)"
    IDS_CODEPAGE1257, "1257 (Балтийская)"
    IDS_CODEPAGE874, "874 (Тайская)"
    IDS_CODEPAGE932, "932 (Японская)"
    IDS_CODEPAGE936, "936 (Китайская упрощённая)"
    IDS_CODEPAGE949, "949 (Корейская)"
    IDS_CODEPAGE950, "950 (Китайская традиционная)"
    IDS_CODEPAGE65001, "65001 (UTF-8)"
    IDS_EXTRACTTLB, "Извлечь данные TYPELIB"
    IDS_CANTEXTRACTTLB, "Невозможно извлечь данные TYPELIB."
    IDS_TLBRESBINFILTER, "Данные TYPELIB (*.tlb)|*.tlb|Двоичные ресурсы (*.res)|*.res|Текстовые файлы (*.txt)|*.txt|Файлы MIDL (*.idl)|*.idl|Все файлы (*.*)|*.*|"
    IDS_USAGE, "Usage: RisohEditor [options | ""file""]\n\nOptions:\n--help  Show this message.\n--version  Show version info.\n--load ""your-file.rc""  Load the file (without GUI)\n--save ""your-file.res""  Save the file (without GUI)\n--log-file ""log-file.txt""  Specify the log file.\n--load-options OPTIONS  Set load options.\n--save-options OPTIONS  Set save options.\n\nLoad options: (no-load-res-h)\nSave options: (idc-static)(compress)(sep-lang)(no-res-folder)(lang-macro)(less-comments)(wrap-manifest)(begin-end)(utf-16)(backup)(ms-msgtbl)"
    IDS_NOSELECTION, "Нет выбора."
    IDS_TRANSLATORS, "[Translators]\r\nEnglish: Katayama Hirofumi MZ\r\nFinnish: Veikko Muurikainen\r\nIndonesian: Mas Ahmad Muhammad\r\nItalian: R.B.\r\nJapanese: Katayama Hirofumi MZ\r\nKorean: VenusGirl (비너스걸)\r\nPolish: Piotr Hetnarowicz\r\nPortuguese: JNylson\r\nRussian: Dmitry Yerokhin\r\nSimplified Chinese: 林鸿湘\r\n"
}

//////////////////////////////////////////////////////////////////////////////

```

`src/lang/zh_CN.rc`:

```rc
// This file is automatically generated by RisohEditor 5.7.9.
// † <-- This dagger helps UTF-8 detection.

#pragma code_page(65001) // UTF-8

LANGUAGE LANG_CHINESE, SUBLANG_SYS_DEFAULT

//////////////////////////////////////////////////////////////////////////////
// RT_MENU

IDR_MAINMENU MENU
{
    POPUP "文件(&F)"
    {
        MENUITEM "新建(&N)\tCtrl+N", ID_NEW
        MENUITEM SEPARATOR
        MENUITEM "打开(&O)...\tCtrl+O", ID_OPEN
        MENUITEM "覆写(&S)...\tCtrl+S", ID_SAVE
        MENUITEM "另存为(&A)...\tShift+Ctrl+S", ID_SAVEAS
        MENUITEM "另存压缩(&M)...", ID_SAVEASCOMPRESS
        MENUITEM SEPARATOR
        MENUITEM "导入(&I)...\tCtrl+I", ID_IMPORT
        MENUITEM "导出(&E)...\tCtrl+P", ID_EXPORT
        MENUITEM SEPARATOR
        MENUITEM "重新加载 &resource.h...\tCtrl+R", ID_LOADRESH
        MENUITEM "保存 resource.h(&S)...", ID_UPDATERESHBANG
        MENUITEM "修改记录(&V) resource.h ...", ID_ADVICERESH
        MENUITEM "卸载 resource.h (&U)", ID_UNLOADRESH
        MENUITEM SEPARATOR
        MENUITEM "加载窗口类DLL(&W)...", ID_LOADWCLIB
        MENUITEM SEPARATOR
        POPUP "最近使用的文件夹"
        {
            MENUITEM "(无)", -1, GRAYED
        }
        MENUITEM SEPARATOR
        MENUITEM "退出(&X)\tAlt+F4", ID_EXIT
    }
    POPUP "编辑(&E)"
    {
        MENUITEM "&GUI模式编辑...\tCtrl+G", ID_GUIEDIT
        MENUITEM SEPARATOR
        POPUP "添加(&A)"
        {
            MENUITEM "添加图标(&I)...", ID_ADDICON
            MENUITEM "添加光标(&C)...", ID_ADDCURSOR
            MENUITEM "添加位图(&B)...", ID_ADDBITMAP
            MENUITEM "添加对话(&D)...", ID_ADDDIALOG
            MENUITEM "添加菜单(&M)...", ID_ADDMENU
            MENUITEM "添加字符串表(&S)...", ID_ADDSTRINGTABLE
            MENUITEM "添加消息表(&E)...", ID_ADDMESSAGETABLE
            MENUITEM "添加&HTML...", ID_ADDHTML
            MENUITEM "添加加速器(&A)...", ID_ADDACCEL
            MENUITEM "添加版本信息(&V)...", ID_ADDVERINFO
            MENUITEM "添加清单(&F)...", ID_ADDMANIFEST
            MENUITEM "添加工具栏(&T)...", ID_ADDTOOLBAR
            MENUITEM "添加资源项目(&R)...", ID_ADDRES
        }
        POPUP "替换(&R)"
        {
            MENUITEM "替换图标(&I)...", ID_REPLACEICON
            MENUITEM "替换光标(&C)...", ID_REPLACECURSOR
            MENUITEM "替换位图文件(&B)...", ID_REPLACEBITMAP
            MENUITEM "替换二进制资源项目(&R)...", ID_REPLACEBIN
        }
        POPUP "导出(&E)"
        {
            MENUITEM "导出图标(&I)...", ID_EXTRACTICON
            MENUITEM "导出光标(&C)...", ID_EXTRACTCURSOR
            MENUITEM "导出位图文件(&B)...", ID_EXTRACTBITMAP
            MENUITEM "导出 RC 文件(&A)...", ID_EXTRACTRC
            MENUITEM "导出二进制资源文件(&R)...", ID_EXTRACTBIN
        }
        MENUITEM SEPARATOR
        MENUITEM "更改名称/语言(&H)\tF2", ID_EDITLABEL
        MENUITEM SEPARATOR
        MENUITEM "复制为其他名称(&N)...", ID_COPYASNEWNAME
        MENUITEM "复制为其他语言(&L)...", ID_COPYASNEWLANG
        MENUITEM "复制到多种语言...", ID_COPYTOMULTILANG
        MENUITEM SEPARATOR
        MENUITEM "效果测试(&T)", ID_TEST
        MENUITEM SEPARATOR
        MENUITEM "删除(&D)\tDel", ID_DELETERES
        MENUITEM SEPARATOR
        MENUITEM "&ID关联列表...", ID_IDASSOC
        MENUITEM "预定义的宏(&M)...", ID_PREDEFMACROS
        MENUITEM "字体设置(&F)...", ID_FONTS
        MENUITEM "设置PATH(&P)...", ID_SETPATHS
        MENUITEM SEPARATOR
        MENUITEM "&UI Language Select (UI语言选择)...", ID_CHOOSEUILANG
        MENUITEM SEPARATOR
        MENUITEM "Delphi DFM 设置...", ID_DFMSETTINGS
        MENUITEM "设置(&C)...", ID_CONFIG
    }
    POPUP "搜索(&S)"
    {
        MENUITEM "查询(&F)...\tCtrl+F", ID_FIND
        MENUITEM SEPARATOR
        MENUITEM "向上搜索(&U)\tShift+F3", ID_FINDUPWARD
        MENUITEM "向下搜索(&D)\tF3", ID_FINDDOWNWARD
        MENUITEM SEPARATOR
        MENUITEM "查询常量(&Q)...", ID_QUERYCONSTANT
    }
    POPUP "界面显示(&V)"
    {
        MENUITEM "状态栏(&S)", ID_STATUSBAR
        MENUITEM "工具栏(&T)", ID_SHOWHIDETOOLBAR
        MENUITEM "二进制模式(&B)", ID_BINARYPANE
        MENUITEM SEPARATOR
        MENUITEM "全部展开(&X)\tCtrl+K", ID_EXPAND_ALL
        MENUITEM "全部折叠(&O)\tCtrl+L", ID_COLLAPSE_ALL
        MENUITEM SEPARATOR
        MENUITEM "资源ID列表(&R)", ID_IDLIST
        MENUITEM "语言列表(&L)...", ID_SHOWLANGS
        MENUITEM SEPARATOR
        MENUITEM "使用&CONTROL字段", ID_ALWAYSCONTROL
        MENUITEM "不使用&ID宏定义", ID_HIDEIDMACROS
        MENUITEM "使用IDC_ST&ATIC", ID_USEIDC_STATIC
        MENUITEM "自动换行(&W)", ID_WORD_WRAP
        MENUITEM "使用BE&GIN/END", ID_USEBEGINEND
        MENUITEM "使用微软消息表(&T)", ID_USEMSMSGTBL
        MENUITEM SEPARATOR
        MENUITEM "资源项的编码(&E)...", ID_ENCODING
        MENUITEM "Dialog &font substitutes...", ID_DIALOG_FONT_SUBSTITUTES
        MENUITEM SEPARATOR
        MENUITEM "更新到最新信息(&F)", ID_REFRESHALL
    }
    POPUP "自动化(&A)"
    {
        MENUITEM "电脑语言 &EGA...", ID_EGA
        MENUITEM "运行EGA程序(&R)...", ID_EGA_PROGRAM
        MENUITEM "手动 (EGA)", ID_OPEN_EGA_MANUAL
    }
    POPUP "帮助(&H)"
    {
        MENUITEM "打开英文 &README.txt", ID_OPENREADME
        MENUITEM "打开 &LICENSE.txt", ID_OPENLICENSE
        MENUITEM SEPARATOR
        MENUITEM "RisohEditor指南(&G)", ID_GUIDE
        MENUITEM "检查 RisohEditor 更新(&U)...", ID_CHECKUPDATE
        MENUITEM SEPARATOR
        MENUITEM "关于(&A)...", ID_ABOUT
    }
}

IDR_POPUPMENUS MENU
{
    POPUP "Popup #0"
    {
        MENUITEM "&GUI模式...\tCtrl+G", ID_GUIEDIT
        MENUITEM SEPARATOR
        POPUP "添加(&A)"
        {
            MENUITEM "添加图标(&I)...", ID_ADDICON
            MENUITEM "添加光标(&C)...", ID_ADDCURSOR
            MENUITEM "添加位图(&B)...", ID_ADDBITMAP
            MENUITEM "添加对话(&D)...", ID_ADDDIALOG
            MENUITEM "添加菜单(&M)...", ID_ADDMENU
            MENUITEM "添加字符串表(&S)...", ID_ADDSTRINGTABLE
            MENUITEM "添加消息表(&E)...", ID_ADDMESSAGETABLE
            MENUITEM "添加&HTML...", ID_ADDHTML
            MENUITEM "添加加速器(&A)...", ID_ADDACCEL
            MENUITEM "添加版本信息(&V)...", ID_ADDVERINFO
            MENUITEM "添加清单(&F)...", ID_ADDMANIFEST
            MENUITEM "添加工具栏(&T)...", ID_ADDTOOLBAR
            MENUITEM "添加资源项目(&R)...", ID_ADDRES
        }
        POPUP "替换(&R)"
        {
            MENUITEM "替换图标(&I)...", ID_REPLACEICON
            MENUITEM "替换光标(&C)...", ID_REPLACECURSOR
            MENUITEM "替换位图文件(&B)...", ID_REPLACEBITMAP
            MENUITEM "替换二进制资源项目(&R)...", ID_REPLACEBIN
        }
        POPUP "导出(&E)"
        {
            MENUITEM "导出图标(&I)...", ID_EXTRACTICON
            MENUITEM "导出光标(&C)...", ID_EXTRACTCURSOR
            MENUITEM "导出位图文件(&B)...", ID_EXTRACTBITMAP
            MENUITEM "导出 RC 文件(&A)...", ID_EXTRACTRC
            MENUITEM "导出二进制资源文件(&R)...", ID_EXTRACTBIN
        }
        MENUITEM SEPARATOR
        MENUITEM "更改名称/语言(&H)\tF2", ID_EDITLABEL
        MENUITEM SEPARATOR
        MENUITEM "复制为其他名称(&N)...", ID_COPYASNEWNAME
        MENUITEM "复制为其他语言(&L)...", ID_COPYASNEWLANG
        MENUITEM "复制到多种语言...", ID_COPYTOMULTILANG
        MENUITEM SEPARATOR
        MENUITEM "效果测试(&T)", ID_TEST
        MENUITEM SEPARATOR
        MENUITEM "删除(&D)\tDel", ID_DELETERES
    }
    POPUP "Popup #1"
    {
        MENUITEM "增加控件(&A)...", ID_ADDCTRL
        MENUITEM SEPARATOR
        MENUITEM "剪切(&T)\tCtrl+X", ID_CUT
        MENUITEM "复制(&C)\tCtrl+C", ID_COPY
        MENUITEM "黏贴(&P)\tCtrl+V", ID_PASTE
        MENUITEM "删除(&D)\tDel", ID_DELCTRL
        MENUITEM SEPARATOR
        POPUP "索引位置(&I)"
        {
            MENUITEM "置顶(&T)", ID_CTRLINDEXTOP
            MENUITEM SEPARATOR
            MENUITEM "减1(&D)", ID_CTRLINDEXMINUS
            MENUITEM "增1(&I)", ID_CTRLINDEXPLUS
            MENUITEM SEPARATOR
            MENUITEM "置底(&B)", ID_CTRLINDEXBOTTOM
            MENUITEM SEPARATOR
            MENUITEM "切换显示模式(&S)\tCtrl+D", ID_SHOWHIDEINDEX
        }
        POPUP "排列方式(&A)"
        {
            MENUITEM "向上对齐(&T)", ID_TOPALIGN
            MENUITEM "向下对齐(&B)", ID_BOTTOMALIGN
            MENUITEM "左对齐(&L)", ID_LEFTALIGN
            MENUITEM "右对齐(&R)", ID_RIGHTALIGN
            MENUITEM SEPARATOR
            MENUITEM "适应网格(&G)", ID_FITTOGRID
        }
        MENUITEM SEPARATOR
        MENUITEM "刷新(&R)", ID_REFRESHDIALOG
        MENUITEM SEPARATOR
        MENUITEM "控件属性(&P)...", ID_CTRLPROP
        MENUITEM "对话框属性(&O)...", ID_DLGPROP
    }
    POPUP "Popup #2"
    {
        MENUITEM "修改(&M)...", ID_MODIFYASSOC
    }
    POPUP "Popup #3"
    {
        MENUITEM "跳转(&J)!", ID_IDJUMP
        MENUITEM SEPARATOR
        MENUITEM "增加ID(&A)...", ID_ADDRESID
        MENUITEM "修改ID(&M)...", ID_MODIFYRESID
        MENUITEM SEPARATOR
        MENUITEM "复制名称(&N)", ID_COPYRESIDNAME
        MENUITEM "复制值(&V)", ID_COPYRESIDVALUE
        MENUITEM "复制定义(&D)\tCtrl+C", ID_COPYIDDEF
        MENUITEM SEPARATOR
        MENUITEM "删除ID(&D) \tDel", ID_DELETERESID
        MENUITEM SEPARATOR
        MENUITEM "十进制数字(&D)", ID_BASE10
        MENUITEM "十六进制数字(&H)", ID_BASE16
        MENUITEM SEPARATOR
        MENUITEM "重新加载(&R)", ID_LOADRESH
    }
    POPUP "Popup #4"
    {
        MENUITEM "增加(&A)...", ID_ADD
        MENUITEM SEPARATOR
        MENUITEM "名称修改(&N)...\tF2", ID_RENAME
        MENUITEM "值修改(&V)...", ID_MODIFY
        MENUITEM SEPARATOR
        MENUITEM "删除(&D)\tDel", ID_DELETE
    }
    POPUP "Popup #5"
    {
        MENUITEM "复制整数值(&C)", ID_COPY
    }
    POPUP "Popup #6"
    {
        MENUITEM "添加(&A)...", psh1
        MENUITEM "修改(&M)...", psh2
        MENUITEM SEPARATOR
        MENUITEM "上(&U)", psh4
        MENUITEM "下(&D)", psh5
        MENUITEM "左(&L)", psh6
        MENUITEM "右(&R)", psh7
        MENUITEM SEPARATOR
        MENUITEM "删除(&T)\tDel", psh3
    }
    POPUP "Popup #7"
    {
        MENUITEM "添加(&A)...", psh1
        MENUITEM "修改(&M)...", psh2
        MENUITEM SEPARATOR
        MENUITEM "上(&U)", psh4
        MENUITEM "下(&D)", psh5
        MENUITEM SEPARATOR
        MENUITEM "删除(&T)\tDel", psh3
    }
    POPUP "Popup #8"
    {
        MENUITEM "添加(&A)...", ID_ADD
        MENUITEM "修改(&M)...", ID_MODIFY
        MENUITEM SEPARATOR
        MENUITEM "删除(&T)\tDel", ID_DELETE
    }
}

//////////////////////////////////////////////////////////////////////////////
// RT_DIALOG

IDD_REPLACERES DIALOGEX 0, 0, 215, 170
CAPTION "替换资源"
STYLE DS_MODALFRAME | WS_POPUPWINDOW | WS_CAPTION
FONT 9, "宋体", 0, 0, 1
{
    LTEXT "资源类型(&T):", -1, 5, 7, 70, 12
    COMBOBOX cmb1, 75, 5, 135, 200, CBS_HASSTRINGS | CBS_AUTOHSCROLL | CBS_DROPDOWN | WS_BORDER | WS_VSCROLL | WS_TABSTOP
    LTEXT "资源名称(&N):", -1, 5, 32, 70, 12
    COMBOBOX cmb2, 75, 30, 135, 200, CBS_HASSTRINGS | CBS_AUTOHSCROLL | CBS_DROPDOWN | WS_DISABLED | WS_BORDER | WS_VSCROLL | WS_TABSTOP
    LTEXT "资源语言(&L):", -1, 5, 57, 70, 12
    COMBOBOX cmb3, 75, 55, 135, 200, CBS_HASSTRINGS | CBS_AUTOHSCROLL | CBS_DROPDOWN | WS_DISABLED | WS_BORDER | WS_VSCROLL | WS_TABSTOP
    LTEXT "二进制文件(&F):", -1, 5, 85, 100, 12
    EDITTEXT edt1, 5, 97, 205, 14, ES_AUTOHSCROLL
    PUSHBUTTON "浏览(&B)...", psh1, 150, 115, 60, 14
    DEFPUSHBUTTON "OK", IDOK, 35, 150, 60, 14
    PUSHBUTTON "取消", IDCANCEL, 115, 150, 60, 14
    {
        0x1234, 0x5678, 0x0011
    }
}

IDD_ADDICON DIALOG 0, 0, 215, 135
CAPTION "添加图标"
STYLE DS_MODALFRAME | WS_POPUPWINDOW | WS_CAPTION
FONT 9, "宋体"
{
    LTEXT "图标文件(&I):", -1, 5, 7, 100, 12
    EDITTEXT edt1, 5, 18, 205, 14, ES_AUTOHSCROLL
    PUSHBUTTON "浏览(&B)...", psh1, 150, 35, 60, 14
    ICON 0, ico1, 5, 35, 0, 0
    LTEXT "资源名称(&N):", -1, 5, 67, 70, 12
    COMBOBOX cmb2, 75, 65, 120, 300, CBS_HASSTRINGS | CBS_AUTOHSCROLL | CBS_DROPDOWN | WS_BORDER | WS_VSCROLL | WS_TABSTOP
    PUSHBUTTON "&...", psh2, 195, 65, 15, 14
    LTEXT "资源语言(&L):", -1, 5, 92, 70, 12
    COMBOBOX cmb3, 75, 90, 135, 200, CBS_HASSTRINGS | CBS_AUTOHSCROLL | CBS_DROPDOWN | WS_BORDER | WS_VSCROLL | WS_TABSTOP
    DEFPUSHBUTTON "OK", IDOK, 35, 115, 60, 14
    PUSHBUTTON "取消", IDCANCEL, 115, 115, 60, 14
}

IDD_REPLACEICON DIALOG 0, 0, 215, 135
CAPTION "替换图标"
STYLE DS_MODALFRAME | WS_POPUPWINDOW | WS_CAPTION
FONT 9, "宋体"
{
    LTEXT "图标文件(&I):", -1, 5, 7, 100, 12
    EDITTEXT edt1, 5, 18, 205, 14, ES_AUTOHSCROLL
    PUSHBUTTON "浏览(&B)...", psh1, 150, 35, 60, 14
    ICON 0, ico1, 5, 35, 0, 0
    LTEXT "资源名称(&N):", -1, 5, 67, 70, 12
    COMBOBOX cmb2, 75, 65, 135, 13, CBS_HASSTRINGS | CBS_AUTOHSCROLL | CBS_DROPDOWN | WS_DISABLED | WS_BORDER | WS_VSCROLL | WS_TABSTOP
    LTEXT "资源语言(&L):", -1, 5, 92, 70, 12
    COMBOBOX cmb3, 75, 90, 135, 13, CBS_HASSTRINGS | CBS_AUTOHSCROLL | CBS_DROPDOWN | WS_DISABLED | WS_BORDER | WS_VSCROLL | WS_TABSTOP
    DEFPUSHBUTTON "OK", IDOK, 35, 115, 60, 14
    PUSHBUTTON "取消", IDCANCEL, 115, 115, 60, 14
}

IDD_ADDBITMAP DIALOG 0, 0, 215, 135
CAPTION "添加位图"
STYLE DS_MODALFRAME | WS_POPUPWINDOW | WS_CAPTION
FONT 9, "宋体"
{
    LTEXT "位图文件(&B):", -1, 5, 7, 100, 12
    EDITTEXT edt1, 5, 18, 205, 14, ES_AUTOHSCROLL
    PUSHBUTTON "浏览(&B)...", psh1, 150, 35, 60, 14
    LTEXT "资源名称(&N):", -1, 5, 67, 70, 12
    COMBOBOX cmb2, 75, 65, 120, 300, CBS_HASSTRINGS | CBS_AUTOHSCROLL | CBS_DROPDOWN | WS_BORDER | WS_VSCROLL | WS_TABSTOP
    PUSHBUTTON "&...", psh2, 195, 65, 15, 14
    LTEXT "资源语言(&L):", -1, 5, 92, 70, 12
    COMBOBOX cmb3, 75, 90, 135, 200, CBS_HASSTRINGS | CBS_AUTOHSCROLL | CBS_DROPDOWN | WS_BORDER | WS_VSCROLL | WS_TABSTOP
    DEFPUSHBUTTON "OK", IDOK, 35, 115, 60, 14
    PUSHBUTTON "取消", IDCANCEL, 115, 115, 60, 14
}

IDD_REPLACEBMP DIALOG 0, 0, 215, 135
CAPTION "替换位图"
STYLE DS_MODALFRAME | WS_POPUPWINDOW | WS_CAPTION
FONT 9, "宋体"
{
    LTEXT "位图文件(&B):", -1, 5, 7, 100, 12
    EDITTEXT edt1, 5, 18, 205, 14, ES_AUTOHSCROLL
    PUSHBUTTON "浏览(&B)...", psh1, 150, 35, 60, 14
    LTEXT "资源名称(&N):", -1, 5, 67, 70, 12
    COMBOBOX cmb2, 75, 65, 135, 200, CBS_HASSTRINGS | CBS_AUTOHSCROLL | CBS_DROPDOWN | WS_DISABLED | WS_BORDER | WS_VSCROLL | WS_TABSTOP
    LTEXT "资源语言(&L):", -1, 5, 92, 70, 12
    COMBOBOX cmb3, 75, 90, 135, 200, CBS_HASSTRINGS | CBS_AUTOHSCROLL | CBS_DROPDOWN | WS_DISABLED | WS_BORDER | WS_VSCROLL | WS_TABSTOP
    DEFPUSHBUTTON "OK", IDOK, 35, 115, 60, 14
    PUSHBUTTON "取消", IDCANCEL, 115, 115, 60, 14
}

IDD_ADDRES DIALOG 0, 0, 215, 170
CAPTION "添加资源"
STYLE DS_MODALFRAME | WS_POPUPWINDOW | WS_CAPTION
FONT 9, "宋体"
{
    LTEXT "资源类型(&T):", -1, 5, 7, 70, 12
    COMBOBOX cmb1, 75, 5, 135, 200, CBS_HASSTRINGS | CBS_AUTOHSCROLL | CBS_DROPDOWN | WS_BORDER | WS_VSCROLL | WS_TABSTOP
    LTEXT "资源名称(&N):", -1, 5, 32, 70, 12
    COMBOBOX cmb2, 75, 30, 120, 300, CBS_HASSTRINGS | CBS_AUTOHSCROLL | CBS_DROPDOWN | WS_BORDER | WS_VSCROLL | WS_TABSTOP
    PUSHBUTTON "&...", psh2, 195, 30, 15, 14
    LTEXT "", stc1, 75, 43, 115, 10
    LTEXT "资源语言(&L):", -1, 5, 57, 70, 12
    COMBOBOX cmb3, 75, 55, 135, 200, CBS_HASSTRINGS | CBS_AUTOHSCROLL | CBS_DROPDOWN | WS_BORDER | WS_VSCROLL | WS_TABSTOP
    LTEXT "二进制文件(&F):", -1, 5, 85, 100, 12
    EDITTEXT edt1, 5, 97, 205, 14, ES_AUTOHSCROLL
    PUSHBUTTON "浏览(&B)...", psh1, 150, 115, 60, 14
    LTEXT "", stc2, 5, 112, 100, 10
    DEFPUSHBUTTON "OK", IDOK, 35, 150, 60, 14
    PUSHBUTTON "取消", IDCANCEL, 115, 150, 60, 14
}

IDD_ADDCURSOR DIALOG 0, 0, 215, 135
CAPTION "添加光标"
STYLE DS_MODALFRAME | WS_POPUPWINDOW | WS_CAPTION
FONT 9, "宋体"
{
    LTEXT "光标文件(&C):", -1, 5, 7, 100, 12
    EDITTEXT edt1, 5, 18, 205, 14, ES_AUTOHSCROLL
    PUSHBUTTON "浏览(&B)...", psh1, 150, 35, 60, 14
    ICON 0, ico1, 5, 35, 0, 0
    LTEXT "资源名称(&N)：", -1, 5, 67, 70, 12
    COMBOBOX cmb2, 75, 65, 120, 200, CBS_HASSTRINGS | CBS_AUTOHSCROLL | CBS_DROPDOWN | WS_BORDER | WS_VSCROLL | WS_TABSTOP
    PUSHBUTTON "&...", psh2, 195, 65, 15, 14
    LTEXT "资源语言(&L):", -1, 5, 92, 70, 12
    COMBOBOX cmb3, 75, 90, 135, 200, CBS_HASSTRINGS | CBS_AUTOHSCROLL | CBS_DROPDOWN | WS_BORDER | WS_VSCROLL | WS_TABSTOP
    DEFPUSHBUTTON "OK", IDOK, 35, 115, 60, 14
    PUSHBUTTON "取消", IDCANCEL, 115, 115, 60, 14
}

IDD_REPLACECUR DIALOG 0, 0, 215, 135
CAPTION "替换光标"
STYLE DS_MODALFRAME | WS_POPUPWINDOW | WS_CAPTION
FONT 9, "宋体"
{
    LTEXT "光标文件(&C):", -1, 5, 7, 100, 12
    EDITTEXT edt1, 5, 18, 205, 14, ES_AUTOHSCROLL
    PUSHBUTTON "浏览(&B)...", psh1, 150, 35, 60, 14
    ICON 0, ico1, 5, 35, 0, 0
    LTEXT "资源名称(&N):", -1, 5, 67, 70, 12
    COMBOBOX cmb2, 75, 65, 135, 200, CBS_HASSTRINGS | CBS_AUTOHSCROLL | CBS_DROPDOWN | WS_DISABLED | WS_BORDER | WS_VSCROLL | WS_TABSTOP
    LTEXT "资源语言(&L):", -1, 5, 92, 70, 12
    COMBOBOX cmb3, 75, 90, 135, 200, CBS_HASSTRINGS | CBS_AUTOHSCROLL | CBS_DROPDOWN | WS_DISABLED | WS_BORDER | WS_VSCROLL | WS_TABSTOP
    DEFPUSHBUTTON "OK", IDOK, 35, 115, 60, 14
    PUSHBUTTON "取消", IDCANCEL, 115, 115, 60, 14
}

IDD_MENUTEST DIALOG 0, 0, 215, 135
CAPTION "菜单测试"
STYLE DS_MODALFRAME | WS_POPUPWINDOW | WS_CAPTION
FONT 9, "宋体"
{
}

IDD_ADDKEY DIALOG 0, 0, 190, 120
CAPTION "添加键"
STYLE DS_MODALFRAME | WS_POPUPWINDOW | WS_CAPTION
FONT 9, "宋体"
{
    RTEXT "键(&K):", -1, 5, 12, 60, 14
    COMBOBOX cmb1, 70, 10, 110, 200, CBS_DROPDOWN | WS_BORDER | WS_VSCROLL | WS_TABSTOP
    RTEXT "命令 &ID:", -1, 5, 37, 60, 14
    COMBOBOX cmb2, 70, 35, 95, 300, CBS_DROPDOWN | WS_BORDER | WS_VSCROLL | WS_TABSTOP
    PUSHBUTTON "&...", psh1, 165, 35, 15, 14
    AUTOCHECKBOX "&VIRTKEY", chx1, 5, 60, 60, 14
    AUTOCHECKBOX "&NOINVERT", chx2, 70, 60, 60, 14
    AUTOCHECKBOX "&CONTROL", chx3, 5, 75, 60, 14
    AUTOCHECKBOX "&SHIFT", chx4, 70, 75, 60, 14
    AUTOCHECKBOX "&ALT", chx5, 140, 75, 45, 14
    DEFPUSHBUTTON "OK", IDOK, 60, 100, 60, 14
    PUSHBUTTON "取消", IDCANCEL, 125, 100, 60, 14
}

IDD_MODIFYKEY DIALOG 0, 0, 190, 120
CAPTION "修改键"
STYLE DS_MODALFRAME | WS_POPUPWINDOW | WS_CAPTION
FONT 9, "宋体"
{
    RTEXT "键(&K):", -1, 5, 12, 60, 14
    COMBOBOX cmb1, 70, 10, 110, 200, CBS_DROPDOWN | WS_BORDER | WS_VSCROLL | WS_TABSTOP
    RTEXT "命令 &ID:", -1, 5, 37, 60, 14
    COMBOBOX cmb2, 70, 35, 95, 200, CBS_DROPDOWN | WS_BORDER | WS_VSCROLL | WS_TABSTOP
    PUSHBUTTON "&...", psh1, 165, 35, 15, 14
    AUTOCHECKBOX "&VIRTKEY", chx1, 5, 60, 60, 14
    AUTOCHECKBOX "&NOINVERT", chx2, 70, 60, 60, 14
    AUTOCHECKBOX "&CONTROL", chx3, 5, 75, 60, 14
    AUTOCHECKBOX "&SHIFT", chx4, 70, 75, 60, 14
    AUTOCHECKBOX "&ALT", chx5, 140, 75, 45, 14
    DEFPUSHBUTTON "OK", IDOK, 60, 100, 60, 14
    PUSHBUTTON "取消", IDCANCEL, 125, 100, 60, 14
}

IDD_EDITACCEL DIALOG 0, 0, 285, 165
CAPTION "编辑快捷键"
STYLE WS_POPUPWINDOW | WS_CAPTION | WS_THICKFRAME
FONT 9, "宋体"
{
    LTEXT "键列表(&K):", -1, 5, 7, 100, 12
    CONTROL "", lst1, "SysListView32", LVS_NOSORTHEADER | LVS_AUTOARRANGE | LVS_NOLABELWRAP | LVS_SHOWSELALWAYS | LVS_SINGLESEL | LVS_REPORT | WS_BORDER | WS_VSCROLL | WS_HSCROLL | WS_TABSTOP, 5, 20, 210, 120
    PUSHBUTTON "添加(&A)...", psh1, 220, 20, 60, 14
    PUSHBUTTON "修改(&M)...", psh2, 220, 40, 60, 14
    PUSHBUTTON "删除(&D)", psh3, 220, 60, 60, 14
    PUSHBUTTON "上(&U)", psh4, 220, 100, 60, 14
    PUSHBUTTON "下(&O)", psh5, 220, 120, 60, 14
    DEFPUSHBUTTON "OK", IDOK, 155, 145, 60, 14
    PUSHBUTTON "取消", IDCANCEL, 220, 145, 60, 14
    PUSHBUTTON "删除所有(&L)", psh6, 5, 145, 79, 14
}

IDD_ADDSTR DIALOG 0, 0, 255, 115
CAPTION "添加字符串项"
STYLE WS_POPUPWINDOW | WS_CAPTION | WS_THICKFRAME
FONT 9, "宋体"
{
    LTEXT "字符串 &ID:", -1, 5, 7, 50, 12
    COMBOBOX cmb1, 60, 5, 134, 200, CBS_HASSTRINGS | CBS_AUTOHSCROLL | CBS_DROPDOWN | WS_BORDER | WS_VSCROLL | WS_TABSTOP
    PUSHBUTTON "&...", psh1, 195, 5, 15, 14
    LTEXT "字符串值(&V):", -1, 5, 27, 54, 12
    EDITTEXT edt1, 60, 25, 190, 45, ES_WANTRETURN | ES_AUTOVSCROLL | ES_MULTILINE | WS_VSCROLL
    AUTOCHECKBOX "用 ""\\n"" 替换 ""\\r\\n""(&R)", chx1, 60, 75, 190, 14
    DEFPUSHBUTTON "OK", IDOK, 125, 95, 60, 14
    PUSHBUTTON "取消", IDCANCEL, 190, 95, 60, 14
}

IDD_MODIFYSTR DIALOG 0, 0, 255, 115
CAPTION "修改字符串项"
STYLE WS_POPUPWINDOW | WS_CAPTION | WS_THICKFRAME
FONT 9, "宋体"
{
    LTEXT "字符串 &ID:", -1, 5, 7, 50, 12
    COMBOBOX cmb1, 60, 5, 134, 200, CBS_HASSTRINGS | CBS_AUTOHSCROLL | CBS_DROPDOWN | WS_BORDER | WS_VSCROLL | WS_TABSTOP
    PUSHBUTTON "&...", psh1, 195, 5, 15, 14
    LTEXT "字符串值(&V):", -1, 5, 27, 54, 12
    EDITTEXT edt1, 60, 25, 190, 45, ES_WANTRETURN | ES_AUTOVSCROLL | ES_MULTILINE | WS_VSCROLL
    AUTOCHECKBOX "用 ""\\n"" 替换 ""\\r\\n""(&R)", chx1, 60, 75, 190, 14
    DEFPUSHBUTTON "OK", IDOK, 125, 95, 60, 14
    PUSHBUTTON "取消", IDCANCEL, 190, 95, 60, 14
}

IDD_STRINGS DIALOG 0, 0, 325, 160
CAPTION "字符串表"
STYLE WS_POPUPWINDOW | WS_CAPTION | WS_THICKFRAME
FONT 9, "宋体"
{
    LTEXT "字符串的条目(&E):", -1, 5, 7, 100, 12
    CONTROL "", lst1, "SysListView32", LVS_NOSORTHEADER | LVS_AUTOARRANGE | LVS_NOLABELWRAP | LVS_SHOWSELALWAYS | LVS_SINGLESEL | LVS_REPORT | WS_BORDER | WS_VSCROLL | WS_HSCROLL | WS_TABSTOP, 5, 20, 315, 115
    PUSHBUTTON "添加(&A)...", psh1, 130, 3, 60, 14
    PUSHBUTTON "修改(&M)...", psh2, 195, 3, 60, 14
    PUSHBUTTON "删除(&D)", psh3, 260, 3, 60, 14
    DEFPUSHBUTTON "OK", IDOK, 195, 140, 60, 14
    PUSHBUTTON "取消", IDCANCEL, 260, 140, 60, 14
    PUSHBUTTON "删除所有(&L)", psh4, 5, 140, 75, 14
}

IDD_ADDMITEM DIALOG 0, 0, 210, 200
CAPTION "增加菜单栏"
STYLE DS_MODALFRAME | WS_POPUPWINDOW | WS_CAPTION
FONT 9, "宋体"
{
    LTEXT "标题(&A):", -1, 5, 7, 55, 12
    COMBOBOX cmb1, 65, 6, 140, 200, CBS_AUTOHSCROLL | CBS_DROPDOWN | WS_BORDER | WS_VSCROLL | WS_TABSTOP
    LTEXT "命令(&M) ID:", -1, 5, 32, 55, 12
    COMBOBOX cmb2, 65, 30, 125, 200, CBS_AUTOHSCROLL | CBS_DROPDOWN | WS_BORDER | WS_VSCROLL | WS_TABSTOP
    PUSHBUTTON "&...", psh1, 190, 30, 15, 14
    AUTOCHECKBOX "呈灰(&G)", chx1, 5, 60, 60, 14
    AUTOCHECKBOX "位图(&B)", chx3, 135, 60, 60, 14
    AUTOCHECKBOX "&OWNERDRAW", chx4, 5, 80, 65, 14
    AUTOCHECKBOX "勾择(&C)", chx5, 75, 80, 60, 14
    AUTOCHECKBOX "分离(&P)", chx6, 140, 80, 60, 14
    AUTOCHECKBOX "菜单&BARBREAK", chx7, 5, 100, 75, 14
    AUTOCHECKBOX "菜单B&REAK", chx8, 85, 100, 70, 14
    AUTOCHECKBOX "设置(&D)", chx9, 5, 120, 60, 14
    AUTOCHECKBOX "标亮(&H)", chx10, 70, 120, 60, 14
    AUTOCHECKBOX "单选按钮选择(&K)", chx11, 135, 120, 60, 14
    AUTOCHECKBOX "RIGH&TORDER", chx12, 5, 139, 60, 14
    AUTOCHECKBOX "RIGHT&JUSTIFY", chx13, 70, 140, 70, 14
    LTEXT "帮助 ID(&L):", -1, 5, 162, 45, 12
    COMBOBOX cmb3, 55, 160, 100, 300, CBS_AUTOHSCROLL | CBS_DROPDOWN | WS_BORDER | WS_VSCROLL | WS_TABSTOP
    DEFPUSHBUTTON "OK", IDOK, 80, 180, 60, 14
    PUSHBUTTON "取消", IDCANCEL, 145, 180, 60, 14
}

IDD_MODIFYMITEM DIALOG 0, 0, 210, 200
CAPTION "修改菜单栏"
STYLE DS_MODALFRAME | WS_POPUPWINDOW | WS_CAPTION
FONT 9, "宋体"
{
    LTEXT "标题(&A):", -1, 5, 7, 55, 12
    COMBOBOX cmb1, 65, 6, 140, 200, CBS_AUTOHSCROLL | CBS_DROPDOWN | WS_BORDER | WS_VSCROLL | WS_TABSTOP
    LTEXT "命令(&M) ID:", -1, 5, 32, 55, 12
    COMBOBOX cmb2, 65, 30, 125, 200, CBS_AUTOHSCROLL | CBS_DROPDOWN | WS_BORDER | WS_VSCROLL | WS_TABSTOP
    PUSHBUTTON "&...", psh1, 190, 30, 15, 14
    AUTOCHECKBOX "呈灰(&G)", chx1, 5, 60, 60, 14
    AUTOCHECKBOX "位图(&B)", chx3, 135, 60, 60, 14
    AUTOCHECKBOX "&OWNERDRAW", chx4, 5, 80, 65, 14
    AUTOCHECKBOX "勾择(&C)", chx5, 75, 80, 60, 14
    AUTOCHECKBOX "分离(&P)", chx6, 140, 80, 60, 14
    AUTOCHECKBOX "菜单&BARBREAK", chx7, 5, 100, 75, 14
    AUTOCHECKBOX "菜单B&REAK", chx8, 85, 100, 70, 14
    AUTOCHECKBOX "设置(&D)", chx9, 5, 120, 60, 14
    AUTOCHECKBOX "标亮(&H)", chx10, 70, 120, 60, 14
    AUTOCHECKBOX "单选按钮选择(&K)", chx11, 135, 120, 60, 14
    AUTOCHECKBOX "RIGH&TORDER", chx12, 5, 139, 60, 14
    AUTOCHECKBOX "RIGHT&JUSTIFY", chx13, 70, 140, 70, 14
    LTEXT "帮助 ID(&L):", -1, 5, 162, 45, 12
    COMBOBOX cmb3, 55, 160, 100, 300, CBS_AUTOHSCROLL | CBS_DROPDOWN | WS_BORDER | WS_VSCROLL | WS_TABSTOP
    DEFPUSHBUTTON "OK", IDOK, 80, 180, 60, 14
    PUSHBUTTON "取消", IDCANCEL, 145, 180, 60, 14
}

IDD_EDITMENU DIALOG 0, 0, 325, 160
CAPTION "编辑菜单资源"
STYLE WS_POPUPWINDOW | WS_CAPTION | WS_THICKFRAME
FONT 9, "宋体"
{
    LTEXT "菜单资源(&S):", -1, 5, 7, 85, 12
    CONTROL "", lst1, "SysListView32", LVS_NOSORTHEADER | LVS_AUTOARRANGE | LVS_NOLABELWRAP | LVS_SHOWSELALWAYS | LVS_SINGLESEL | LVS_REPORT | WS_BORDER | WS_VSCROLL | WS_HSCROLL | WS_TABSTOP, 5, 20, 315, 115
    PUSHBUTTON "添加(&A)...", psh1, 95, 3, 50, 14
    PUSHBUTTON "修改(&M)...", psh2, 150, 3, 50, 14
    PUSHBUTTON "删除(&T)", psh3, 205, 3, 50, 14
    PUSHBUTTON "上(&U)", psh4, 5, 140, 40, 14
    PUSHBUTTON "下(&D)", psh5, 50, 140, 40, 14
    PUSHBUTTON "左(&L)", psh6, 95, 140, 40, 14
    PUSHBUTTON "右(&R)", psh7, 140, 140, 41, 14
    AUTOCHECKBOX "扩展(&X)", chx1, 260, 3, 60, 14
    DEFPUSHBUTTON "OK", IDOK, 195, 140, 60, 14
    PUSHBUTTON "取消", IDCANCEL, 260, 140, 60, 14
}

IDD_DLGPROP DIALOG 0, 0, 235, 315
CAPTION "对话框属性"
STYLE DS_MODALFRAME | WS_POPUPWINDOW | WS_CAPTION
FONT 9, "宋体"
{
    LTEXT "标题(&A):", -1, 5, 7, 85, 11
    COMBOBOX cmb1, 5, 20, 225, 300, CBS_HASSTRINGS | CBS_AUTOHSCROLL | CBS_DROPDOWN | WS_BORDER | WS_VSCROLL | WS_TABSTOP
    AUTOCHECKBOX "扩展类型(&X)", chx1, 100, 5, 86, 14
    LTEXT "左(&L):", -1, 5, 40, 33, 10
    EDITTEXT edt1, 5, 53, 30, 14, ES_NUMBER | ES_RIGHT
    CONTROL "", scr1, "msctls_updown32", UDS_NOTHOUSANDS | UDS_ARROWKEYS | UDS_AUTOBUDDY | UDS_ALIGNRIGHT | UDS_SETBUDDYINT, 23, 53, 12, 20
    LTEXT "上(&U):", -1, 50, 40, 33, 10
    EDITTEXT edt2, 50, 53, 30, 14, ES_NUMBER | ES_RIGHT
    CONTROL "", scr2, "msctls_updown32", UDS_NOTHOUSANDS | UDS_ARROWKEYS | UDS_AUTOBUDDY | UDS_ALIGNRIGHT | UDS_SETBUDDYINT, 53, 53, 12, 20
    LTEXT "宽度(&W):", -1, 95, 40, 33, 10
    EDITTEXT edt3, 95, 53, 30, 14, ES_NUMBER | ES_RIGHT
    CONTROL "", scr3, "msctls_updown32", UDS_NOTHOUSANDS | UDS_ARROWKEYS | UDS_AUTOBUDDY | UDS_ALIGNRIGHT | UDS_SETBUDDYINT, 129, 56, 12, 20
    LTEXT "高度(&H):", -1, 142, 40, 33, 10
    EDITTEXT edt4, 142, 53, 30, 14, ES_NUMBER | ES_RIGHT
    CONTROL "", scr4, "msctls_updown32", UDS_NOTHOUSANDS | UDS_ARROWKEYS | UDS_AUTOBUDDY | UDS_ALIGNRIGHT | UDS_SETBUDDYINT, 162, 53, 12, 20
    LTEXT "类名(&S):", -1, 5, 73, 85, 11
    COMBOBOX cmb2, 5, 88, 115, 200, CBS_HASSTRINGS | CBS_AUTOHSCROLL | CBS_DROPDOWN | WS_BORDER | WS_VSCROLL | WS_TABSTOP
    LTEXT "帮助 ID(&P):", -1, 125, 73, 64, 11
    COMBOBOX cmb3, 125, 88, 65, 200, CBS_HASSTRINGS | CBS_AUTOHSCROLL | CBS_DROPDOWN | WS_BORDER | WS_VSCROLL | WS_TABSTOP
    LTEXT "文字样式(&F):", -1, 5, 105, 80, 11
    COMBOBOX cmb4, 6, 118, 100, 200, CBS_HASSTRINGS | CBS_SORT | CBS_AUTOHSCROLL | CBS_DROPDOWN | WS_BORDER | WS_VSCROLL | WS_TABSTOP
    LTEXT "大小(&Z):", -1, 110, 105, 38, 12
    EDITTEXT edt5, 110, 118, 25, 14, ES_NUMBER
    AUTOCHECKBOX "&B", chx2, 140, 118, 20, 14
    AUTOCHECKBOX "&I", chx3, 165, 118, 20, 14
    LTEXT "字体类型(&R):", -1, 5, 138, 80, 11
    COMBOBOX cmb5, 5, 148, 100, 100, CBS_AUTOHSCROLL | CBS_DROPDOWNLIST | WS_VSCROLL | WS_TABSTOP
    LTEXT "菜单名称(&M):", -1, 110, 138, 55, 11
    COMBOBOX cmb6, 110, 148, 99, 300, CBS_HASSTRINGS | CBS_AUTOHSCROLL | CBS_DROPDOWN | WS_BORDER | WS_VSCROLL | WS_TABSTOP
    LTEXT "样式(&T):", -1, 5, 168, 45, 11
    RTEXT "0x", -1, 52, 169, 10, 11
    EDITTEXT edt6, 67, 165, 45, 14, ES_AUTOHSCROLL
    LISTBOX lst1, 5, 183, 110, 110, LBS_DISABLENOSCROLL | LBS_NOINTEGRALHEIGHT | LBS_HASSTRINGS | LBS_MULTIPLESEL | WS_VSCROLL | WS_HSCROLL | WS_TABSTOP
    LTEXT "扩展类型(&E)", -1, 120, 168, 48, 11
    RTEXT "0x", -1, 170, 169, 10, 11
    EDITTEXT edt7, 185, 165, 45, 14, ES_AUTOHSCROLL
    LISTBOX lst2, 120, 183, 110, 110, LBS_DISABLENOSCROLL | LBS_NOINTEGRALHEIGHT | LBS_HASSTRINGS | LBS_MULTIPLESEL | WS_VSCROLL | WS_HSCROLL | WS_TABSTOP
    DEFPUSHBUTTON "OK", IDOK, 106, 298, 60, 14
    PUSHBUTTON "取消", IDCANCEL, 171, 298, 60, 14
}

IDD_CTRLPROP DIALOG 0, 0, 235, 330
CAPTION "控件属性"
STYLE DS_MODALFRAME | WS_POPUPWINDOW | WS_CAPTION
FONT 9, "宋体"
{
    LTEXT "定义&Ctrl:", -1, 5, 7, 68, 12
    COMBOBOX cmb1, 75, 5, 120, 55, CBS_HASSTRINGS | CBS_AUTOHSCROLL | CBS_DROPDOWN | WS_BORDER | WS_VSCROLL | WS_TABSTOP
    CONTROL "", ctl1, "ToolbarWindow32", TBSTYLE_FLAT | TBSTYLE_WRAPABLE | TBSTYLE_TOOLTIPS | CCS_NODIVIDER | CCS_NORESIZE, 5, 22, 185, 30
    LTEXT "标题(&A):", -1, 5, 55, 75, 12
    COMBOBOX cmb2, 5, 65, 195, 300, CBS_HASSTRINGS | CBS_AUTOHSCROLL | CBS_DROPDOWN | WS_BORDER | WS_VSCROLL | WS_TABSTOP
    PUSHBUTTON "&OLE...", psh2, 205, 65, 25, 14
    LTEXT "左(&L):", -1, 5, 85, 33, 11
    EDITTEXT edt1, 5, 99, 25, 14, ES_NUMBER | ES_RIGHT
    CONTROL "", scr1, "msctls_updown32", UDS_NOTHOUSANDS | UDS_ARROWKEYS | UDS_AUTOBUDDY | UDS_ALIGNRIGHT | UDS_SETBUDDYINT, 20, 99, 12, 20
    LTEXT "上(&U):", -1, 40, 85, 33, 11
    EDITTEXT edt2, 40, 99, 25, 14, ES_NUMBER | ES_RIGHT
    CONTROL "", scr2, "msctls_updown32", UDS_NOTHOUSANDS | UDS_ARROWKEYS | UDS_AUTOBUDDY | UDS_ALIGNRIGHT | UDS_SETBUDDYINT, 55, 99, 12, 20
    LTEXT "宽度(&W):", -1, 75, 85, 33, 11
    EDITTEXT edt3, 75, 99, 25, 14, ES_NUMBER | ES_RIGHT
    CONTROL "", scr3, "msctls_updown32", UDS_NOTHOUSANDS | UDS_ARROWKEYS | UDS_AUTOBUDDY | UDS_ALIGNRIGHT | UDS_SETBUDDYINT, 90, 99, 12, 20
    LTEXT "高度(&H):", -1, 111, 85, 33, 11
    EDITTEXT edt4, 110, 99, 25, 14, ES_NUMBER | ES_RIGHT
    CONTROL "", scr4, "msctls_updown32", UDS_NOTHOUSANDS | UDS_ARROWKEYS | UDS_AUTOBUDDY | UDS_ALIGNRIGHT | UDS_SETBUDDYINT, 125, 99, 12, 20
    LTEXT "&ID:", -1, 150, 85, 70, 12
    COMBOBOX cmb3, 150, 99, 80, 300, CBS_HASSTRINGS | CBS_AUTOHSCROLL | CBS_DROPDOWN | WS_BORDER | WS_VSCROLL | WS_TABSTOP
    LTEXT "Window类名(&S):", -1, 5, 119, 100, 12
    COMBOBOX cmb4, 5, 133, 115, 200, CBS_HASSTRINGS | CBS_AUTOHSCROLL | CBS_DROPDOWN | WS_BORDER | WS_VSCROLL | WS_TABSTOP
    LTEXT "帮助 ID(&P):", -1, 125, 119, 70, 12
    COMBOBOX cmb5, 125, 133, 65, 200, CBS_HASSTRINGS | CBS_AUTOHSCROLL | CBS_DROPDOWN | WS_BORDER | WS_VSCROLL | WS_TABSTOP
    LTEXT "样式(&T):", -1, 5, 153, 45, 12
    RTEXT "0x", -1, 54, 153, 10, 12
    EDITTEXT edt6, 70, 151, 45, 14, ES_AUTOHSCROLL
    LISTBOX lst1, 5, 167, 110, 120, LBS_DISABLENOSCROLL | LBS_NOINTEGRALHEIGHT | LBS_HASSTRINGS | LBS_MULTIPLESEL | WS_VSCROLL | WS_HSCROLL | WS_TABSTOP
    LTEXT "扩展类型(&E)", -1, 120, 153, 50, 12
    RTEXT "0x", -1, 172, 153, 10, 12
    EDITTEXT edt7, 185, 151, 45, 14, ES_AUTOHSCROLL
    LISTBOX lst2, 120, 167, 110, 120, LBS_DISABLENOSCROLL | LBS_NOINTEGRALHEIGHT | LBS_HASSTRINGS | LBS_MULTIPLESEL | WS_VSCROLL | WS_HSCROLL | WS_TABSTOP
    DEFPUSHBUTTON "OK", IDOK, 170, 293, 60, 14
    PUSHBUTTON "取消", IDCANCEL, 170, 309, 60, 14
    PUSHBUTTON "数据(&D)...", psh1, 5, 293, 90, 14
    PUSHBUTTON "字符串列表(&I)...", psh3, 5, 309, 90, 14
}

IDD_ADDCTRL DIALOG 0, 0, 235, 330
CAPTION "增加控件"
STYLE DS_MODALFRAME | WS_POPUPWINDOW | WS_CAPTION
FONT 9, "宋体"
{
    LTEXT "定义&Ctrl:", -1, 5, 7, 68, 12
    COMBOBOX cmb1, 75, 5, 120, 55, CBS_HASSTRINGS | CBS_AUTOHSCROLL | CBS_DROPDOWN | WS_BORDER | WS_VSCROLL | WS_TABSTOP
    CONTROL "", ctl1, "ToolbarWindow32", TBSTYLE_FLAT | TBSTYLE_WRAPABLE | TBSTYLE_TOOLTIPS | CCS_NODIVIDER | CCS_NORESIZE, 5, 22, 185, 30
    LTEXT "标题(&A):", -1, 5, 55, 75, 12
    COMBOBOX cmb2, 5, 65, 195, 300, CBS_HASSTRINGS | CBS_AUTOHSCROLL | CBS_DROPDOWN | WS_BORDER | WS_VSCROLL | WS_TABSTOP
    PUSHBUTTON "&OLE...", psh2, 205, 65, 25, 14
    LTEXT "左(&L):", -1, 5, 85, 33, 11
    EDITTEXT edt1, 5, 99, 25, 14, ES_NUMBER | ES_RIGHT
    CONTROL "", scr1, "msctls_updown32", UDS_NOTHOUSANDS | UDS_ARROWKEYS | UDS_AUTOBUDDY | UDS_ALIGNRIGHT | UDS_SETBUDDYINT, 20, 99, 12, 20
    LTEXT "上(&U):", -1, 40, 85, 33, 11
    EDITTEXT edt2, 40, 99, 25, 14, ES_NUMBER | ES_RIGHT
    CONTROL "", scr2, "msctls_updown32", UDS_NOTHOUSANDS | UDS_ARROWKEYS | UDS_AUTOBUDDY | UDS_ALIGNRIGHT | UDS_SETBUDDYINT, 55, 99, 12, 20
    LTEXT "宽度(&W):", -1, 75, 85, 33, 11
    EDITTEXT edt3, 75, 99, 25, 14, ES_NUMBER | ES_RIGHT
    CONTROL "", scr3, "msctls_updown32", UDS_NOTHOUSANDS | UDS_ARROWKEYS | UDS_AUTOBUDDY | UDS_ALIGNRIGHT | UDS_SETBUDDYINT, 90, 99, 12, 20
    LTEXT "高度(&H):", -1, 111, 85, 33, 11
    EDITTEXT edt4, 110, 99, 25, 14, ES_NUMBER | ES_RIGHT
    CONTROL "", scr4, "msctls_updown32", UDS_NOTHOUSANDS | UDS_ARROWKEYS | UDS_AUTOBUDDY | UDS_ALIGNRIGHT | UDS_SETBUDDYINT, 125, 99, 12, 20
    LTEXT "&ID:", -1, 150, 85, 70, 12
    COMBOBOX cmb3, 150, 99, 80, 300, CBS_HASSTRINGS | CBS_AUTOHSCROLL | CBS_DROPDOWN | WS_BORDER | WS_VSCROLL | WS_TABSTOP
    LTEXT "Window类名(&S):", -1, 5, 119, 100, 12
    COMBOBOX cmb4, 5, 133, 115, 200, CBS_HASSTRINGS | CBS_AUTOHSCROLL | CBS_DROPDOWN | WS_BORDER | WS_VSCROLL | WS_TABSTOP
    LTEXT "帮助 ID(&P):", -1, 125, 119, 70, 12
    COMBOBOX cmb5, 125, 133, 65, 200, CBS_HASSTRINGS | CBS_AUTOHSCROLL | CBS_DROPDOWN | WS_BORDER | WS_VSCROLL | WS_TABSTOP
    LTEXT "样式(&T):", -1, 5, 153, 45, 12
    RTEXT "0x", -1, 54, 153, 10, 12
    EDITTEXT edt6, 70, 151, 45, 14, ES_AUTOHSCROLL
    LISTBOX lst1, 5, 167, 110, 120, LBS_DISABLENOSCROLL | LBS_NOINTEGRALHEIGHT | LBS_HASSTRINGS | LBS_MULTIPLESEL | WS_VSCROLL | WS_HSCROLL | WS_TABSTOP
    LTEXT "扩展类型(&E)", -1, 120, 153, 50, 12
    RTEXT "0x", -1, 172, 153, 10, 12
    EDITTEXT edt7, 185, 151, 45, 14, ES_AUTOHSCROLL
    LISTBOX lst2, 120, 167, 110, 120, LBS_DISABLENOSCROLL | LBS_NOINTEGRALHEIGHT | LBS_HASSTRINGS | LBS_MULTIPLESEL | WS_VSCROLL | WS_HSCROLL | WS_TABSTOP
    DEFPUSHBUTTON "OK", IDOK, 170, 293, 60, 14
    PUSHBUTTON "取消", IDCANCEL, 170, 309, 60, 14
    PUSHBUTTON "数据(&D)...", psh1, 5, 293, 90, 14
    PUSHBUTTON "字符串列表(&I)...", psh3, 5, 309, 90, 14
}

IDD_IDASSOC DIALOG 0, 0, 200, 220
CAPTION "ID 关联列表"
STYLE DS_MODALFRAME | WS_POPUPWINDOW | WS_CAPTION
FONT 9, "宋体"
{
    LTEXT "ID 关联(&A):", -1, 5, 5, 116, 12
    CONTROL "", lst1, "SysListView32", LVS_SHOWSELALWAYS | LVS_SINGLESEL | LVS_REPORT | WS_BORDER | WS_TABSTOP, 5, 20, 190, 150
    PUSHBUTTON "全部重置(&R)", psh2, 5, 175, 85, 14
    PUSHBUTTON "修改(&M)", psh1, 135, 175, 60, 14
    DEFPUSHBUTTON "OK", IDOK, 70, 200, 60, 14
    PUSHBUTTON "取消", IDCANCEL, 135, 200, 60, 14
}

IDD_MODIFYASSOC DIALOG 0, 0, 165, 68
CAPTION "修改ID关联"
STYLE DS_MODALFRAME | WS_POPUPWINDOW | WS_CAPTION
FONT 9, "宋体"
{
    RTEXT "ID类型(&T):", -1, 5, 7, 65, 12
    EDITTEXT edt1, 80, 5, 80, 14, WS_DISABLED
    RTEXT "&Prefix of ID:", -1, 5, 32, 65, 12
    EDITTEXT edt2, 80, 28, 80, 14, ES_AUTOHSCROLL
    DEFPUSHBUTTON "OK", IDOK, 35, 50, 60, 14
    PUSHBUTTON "取消", IDCANCEL, 100, 50, 60, 14
}

IDD_IDLIST DIALOG 0, 0, 200, 300
CAPTION "资源ID列表"
STYLE WS_OVERLAPPEDWINDOW
EXSTYLE WS_EX_TOOLWINDOW
FONT 9, "宋体"
{
    COMBOBOX cmb1, 0, 0, 200, 300, CBS_HASSTRINGS | CBS_SORT | CBS_OWNERDRAWFIXED | CBS_DROPDOWNLIST | WS_VSCROLL | WS_TABSTOP
    CONTROL "", lst1, "SysListView32", LVS_REPORT | WS_BORDER | WS_VSCROLL | WS_HSCROLL | WS_TABSTOP, 0, 15, 200, 285
}

IDD_CONFIG DIALOG 0, 0, 210, 285
CAPTION "配置"
STYLE DS_MODALFRAME | WS_POPUPWINDOW | WS_CAPTION
FONT 9, "宋体"
{
    AUTOCHECKBOX "在标题栏显示完整路径(&F)", chx1, 5, 5, 200, 14
    AUTOCHECKBOX "不使用ID宏定义(&M)", chx2, 5, 25, 200, 14
    AUTOCHECKBOX "恢复以前的窗口位置(&P)", chx3, 5, 45, 200, 14
    AUTOCHECKBOX "自动加载最近的""&resource.h""", chx4, 5, 65, 200, 14
    AUTOCHECKBOX "自动显示资源ID列表(&L)", chx5, 5, 85, 200, 14
    AUTOCHECKBOX "在对话框编辑上显示点阵(&D)", chx6, 5, 105, 200, 14
    RTEXT "Combo&Box的高度(&B):", -1, 10, 127, 75, 12
    EDITTEXT edt1, 90, 125, 34, 14, ES_NUMBER | ES_RIGHT
    CONTROL "", scr1, "msctls_updown32", UDS_NOTHOUSANDS | UDS_ARROWKEYS | UDS_AUTOBUDDY | UDS_ALIGNRIGHT | UDS_SETBUDDYINT, 129, 49, 12, 20
    AUTOCHECKBOX "自动换行(&W)", chx9, 135, 125, 70, 14
    AUTOCHECKBOX "询问""&resource.h""的更新", chx7, 5, 145, 200, 14
    AUTOCHECKBOX "保存EXE文件时用&UPX压缩", chx8, 5, 165, 200, 14
    PUSHBUTTON "字体(&F)...", psh4, 5, 185, 200, 14
    PUSHBUTTON "预定义的宏(&M)...", psh1, 5, 205, 93, 14
    PUSHBUTTON "设置PATH(&T)...", psh2, 107, 205, 98, 14
    RTEXT "&OLE控件的名称:", -1, 5, 227, 80, 12
    COMBOBOX cmb1, 90, 225, 75, 300, CBS_HASSTRINGS | CBS_AUTOHSCROLL | CBS_DROPDOWN | WS_VSCROLL | WS_TABSTOP
    AUTOCHECKBOX "创建备份(&B)  后缀:", chx10, 5, 245, 123, 14
    COMBOBOX cmb2, 134, 245, 45, 300, CBS_HASSTRINGS | CBS_AUTOHSCROLL | CBS_DROPDOWN | WS_VSCROLL | WS_TABSTOP
    DEFPUSHBUTTON "OK", IDOK, 100, 265, 50, 14
    PUSHBUTTON "取消", IDCANCEL, 155, 265, 50, 14
    PUSHBUTTON "全部重置(&S)", psh3, 5, 265, 75, 14
}

IDD_ADDRESID DIALOG 0, 0, 165, 90
CAPTION "增加资源ID"
STYLE DS_MODALFRAME | WS_POPUPWINDOW | WS_CAPTION
FONT 9, "宋体"
{
    RTEXT "ID类型(&T):", -1, 10, 7, 50, 14
    COMBOBOX cmb1, 65, 5, 95, 300, CBS_AUTOHSCROLL | CBS_DROPDOWNLIST | WS_VSCROLL | WS_TABSTOP
    RTEXT "ID名称(&N):", -1, 10, 27, 50, 14
    EDITTEXT edt1, 65, 25, 75, 14, ES_AUTOHSCROLL
    RTEXT "整型值(&I):", -1, 10, 47, 50, 14
    EDITTEXT edt2, 65, 45, 48, 14, ES_AUTOHSCROLL
    CONTROL "", scr1, "msctls_updown32", UDS_NOTHOUSANDS | UDS_ARROWKEYS | UDS_AUTOBUDDY | UDS_ALIGNRIGHT | UDS_SETBUDDYINT, 129, 49, 12, 20
    PUSHBUTTON "自动(&A)", psh1, 115, 45, 45, 14
    DEFPUSHBUTTON "OK", IDOK, 20, 70, 60, 14
    PUSHBUTTON "取消", IDCANCEL, 85, 70, 60, 14
}

IDD_MODIFYRESID DIALOG 0, 0, 165, 90
CAPTION "修改资源ID"
STYLE DS_MODALFRAME | WS_POPUPWINDOW | WS_CAPTION
FONT 9, "宋体"
{
    RTEXT "ID名称(&N):", -1, 10, 12, 50, 14, SS_REALSIZEIMAGE | NOT WS_GROUP
    EDITTEXT edt1, 65, 10, 95, 14, ES_AUTOHSCROLL
    RTEXT "ID类型(&T):", -1, 10, 32, 50, 14
    EDITTEXT edt2, 65, 30, 95, 14, ES_READONLY
    RTEXT "整型值(&I):", -1, 10, 52, 50, 14
    EDITTEXT edt3, 65, 50, 48, 14, ES_AUTOHSCROLL
    CONTROL "", scr1, "msctls_updown32", UDS_NOTHOUSANDS | UDS_ARROWKEYS | UDS_AUTOBUDDY | UDS_ALIGNRIGHT | UDS_SETBUDDYINT, 129, 49, 12, 20
    DEFPUSHBUTTON "OK", IDOK, 20, 70, 60, 14
    PUSHBUTTON "取消", IDCANCEL, 85, 70, 60, 14
}

IDD_ADVICERESH DIALOG 0, 0, 209, 184
CAPTION "文件的修改情况 ""resource.h"""
STYLE DS_MODALFRAME | WS_POPUPWINDOW | WS_CAPTION
FONT 9, "宋体"
{
    LTEXT "请修改文件 ""resource.h"" As Follows:", -1, 10, 10, 195, 20
    EDITTEXT edt1, 10, 30, 190, 130, ES_READONLY | ES_MULTILINE
    DEFPUSHBUTTON "OK", IDOK, 140, 165, 60, 14
    PUSHBUTTON "清除修改(&C)", psh1, 10, 165, 90, 14
}

IDD_CLONEINNEWNAME DIALOG 0, 0, 215, 75
CAPTION "复制为其他名称"
STYLE DS_MODALFRAME | WS_POPUPWINDOW | WS_CAPTION
FONT 9, "宋体"
{
    LTEXT "资源类型(&T):", -1, 5, 7, 70, 12
    COMBOBOX cmb1, 75, 5, 135, 200, CBS_HASSTRINGS | CBS_AUTOHSCROLL | CBS_DROPDOWN | WS_DISABLED | WS_BORDER | WS_VSCROLL | WS_TABSTOP
    LTEXT "资源名称(&N):", -1, 5, 32, 70, 12
    COMBOBOX cmb2, 75, 30, 120, 200, CBS_HASSTRINGS | CBS_AUTOHSCROLL | CBS_DROPDOWN | WS_BORDER | WS_VSCROLL | WS_TABSTOP
    PUSHBUTTON "&...", psh1, 195, 30, 15, 14
    DEFPUSHBUTTON "OK", IDOK, 35, 55, 60, 14
    PUSHBUTTON "取消", IDCANCEL, 115, 55, 60, 14
}

IDD_CLONEINNEWLANG DIALOG 0, 0, 215, 105
CAPTION "复制为其他语言"
STYLE DS_MODALFRAME | WS_POPUPWINDOW | WS_CAPTION
FONT 9, "宋体"
{
    LTEXT "资源类型(&T):", -1, 5, 7, 70, 12
    COMBOBOX cmb1, 75, 5, 135, 200, CBS_HASSTRINGS | CBS_AUTOHSCROLL | CBS_DROPDOWN | WS_DISABLED | WS_BORDER | WS_VSCROLL | WS_TABSTOP
    LTEXT "资源名称(&N):", -1, 5, 32, 70, 12
    COMBOBOX cmb2, 75, 30, 120, 200, CBS_HASSTRINGS | CBS_AUTOHSCROLL | CBS_DROPDOWN | WS_DISABLED | WS_BORDER | WS_VSCROLL | WS_TABSTOP
    LTEXT "资源语言(&L):", -1, 5, 57, 70, 12
    COMBOBOX cmb3, 75, 55, 135, 200, CBS_HASSTRINGS | CBS_AUTOHSCROLL | CBS_DROPDOWN | WS_BORDER | WS_VSCROLL | WS_TABSTOP
    DEFPUSHBUTTON "OK", IDOK, 35, 85, 60, 14
    PUSHBUTTON "取消", IDCANCEL, 115, 85, 60, 14
}

IDD_ITEMSEARCH DIALOG 0, 0, 171, 135
CAPTION "搜索"
STYLE WS_POPUPWINDOW | WS_CAPTION
FONT 9, "宋体"
{
    LTEXT "搜索字符串(&S):", -1, 4, 10, 100, 14
    EDITTEXT edt1, 5, 25, 160, 15, ES_AUTOHSCROLL
    AUTOCHECKBOX "区分大小写(&C)", chx1, 5, 45, 120, 15
    GROUPBOX "方向", -1, 5, 65, 160, 42
    AUTORADIOBUTTON "向上(&U)", rad1, 15, 80, 60, 14, WS_TABSTOP
    AUTORADIOBUTTON "向下(&D)", rad2, 90, 80, 60, 14, WS_TABSTOP
    DEFPUSHBUTTON "查找(&F)", IDOK, 40, 115, 60, 14
    PUSHBUTTON "取消", IDCANCEL, 105, 115, 60, 14
}

IDD_VERSIONINFO DIALOG 0, 0, 174, 150
CAPTION "关于 RisohEditor"
STYLE DS_MODALFRAME | WS_POPUPWINDOW | WS_CAPTION
FONT 12, "宋体"
{
    ICON IDI_MAIN, -1, 5, 5, 0, 0
    LTEXT "...", stc1, 30, 5, 140, 50
    CTEXT "https://katahiromz.web.fc2.com", stc2, 5, 60, 165, 12, SS_CENTERIMAGE | SS_NOTIFY | NOT WS_GROUP
    CONTROL "...", edt1, "EDIT", ES_READONLY | ES_AUTOHSCROLL | ES_AUTOVSCROLL | ES_MULTILINE | WS_BORDER | WS_VSCROLL | WS_HSCROLL, 5, 75, 165, 50
    DEFPUSHBUTTON "OK", IDOK, 55, 130, 60, 14
}

IDD_ADDMSG DIALOG 0, 0, 255, 105
CAPTION "添加消息条目"
STYLE DS_MODALFRAME | WS_POPUPWINDOW | WS_CAPTION
FONT 9, "宋体"
{
    LTEXT "消息 &ID:", -1, 5, 7, 50, 12
    COMBOBOX cmb1, 65, 5, 134, 200, CBS_HASSTRINGS | CBS_AUTOHSCROLL | CBS_DROPDOWN | WS_BORDER | WS_VSCROLL | WS_TABSTOP
    PUSHBUTTON "&...", psh1, 200, 5, 15, 14
    LTEXT "消息值(&V):", -1, 5, 27, 80, 12
    EDITTEXT edt1, 5, 40, 245, 35, ES_WANTRETURN | ES_AUTOHSCROLL | ES_AUTOVSCROLL | ES_MULTILINE
    DEFPUSHBUTTON "OK", IDOK, 125, 85, 60, 14
    PUSHBUTTON "取消", IDCANCEL, 190, 85, 60, 14
}

IDD_MODIFYMSG DIALOG 0, 0, 255, 105
CAPTION "修改消息条目"
STYLE DS_MODALFRAME | WS_POPUPWINDOW | WS_CAPTION
FONT 9, "宋体"
{
    LTEXT "消息 &ID:", -1, 5, 7, 50, 12
    COMBOBOX cmb1, 65, 5, 134, 200, CBS_HASSTRINGS | CBS_AUTOHSCROLL | CBS_DROPDOWN | WS_DISABLED | WS_BORDER | WS_VSCROLL | WS_TABSTOP
    LTEXT "消息值(&V):", -1, 5, 27, 80, 12
    EDITTEXT edt1, 5, 40, 245, 35, ES_WANTRETURN | ES_AUTOHSCROLL | ES_AUTOVSCROLL | ES_MULTILINE
    DEFPUSHBUTTON "OK", IDOK, 125, 85, 60, 14
    PUSHBUTTON "取消", IDCANCEL, 190, 85, 60, 14
}

IDD_MESSAGES DIALOG 0, 0, 325, 160
CAPTION "字符串表"
STYLE WS_POPUPWINDOW | WS_CAPTION | WS_THICKFRAME
FONT 9, "宋体"
{
    LTEXT "消息条目(&E):", -1, 5, 7, 80, 12
    CONTROL "", lst1, "SysListView32", LVS_NOSORTHEADER | LVS_AUTOARRANGE | LVS_NOLABELWRAP | LVS_SHOWSELALWAYS | LVS_SINGLESEL | LVS_REPORT | WS_BORDER | WS_VSCROLL | WS_HSCROLL | WS_TABSTOP, 5, 20, 315, 115
    PUSHBUTTON "添加(&A)...", psh1, 130, 3, 60, 14
    PUSHBUTTON "修改(&M)...", psh2, 195, 3, 60, 14
    PUSHBUTTON "删除(&D)", psh3, 260, 3, 60, 14
    DEFPUSHBUTTON "OK", IDOK, 195, 140, 60, 14
    PUSHBUTTON "取消", IDCANCEL, 260, 140, 60, 14
    PUSHBUTTON "删除所有(&L)", psh4, 5, 140, 75, 14
}

IDD_FONTS DIALOG 0, 0, 195, 110
CAPTION "字体设置"
STYLE DS_MODALFRAME | WS_POPUPWINDOW | WS_CAPTION
FONT 9, "宋体"
{
    RTEXT "资源(&S):", -1, 5, 5, 55, 15, SS_CENTERIMAGE | NOT WS_GROUP
    EDITTEXT edt1, 65, 5, 100, 14, ES_READONLY | ES_AUTOHSCROLL
    PUSHBUTTON "...", psh1, 170, 5, 19, 14
    RTEXT "二进制(&B):", -1, 5, 25, 55, 15, SS_CENTERIMAGE | NOT WS_GROUP
    EDITTEXT edt2, 65, 25, 100, 14, ES_READONLY | ES_AUTOHSCROLL
    PUSHBUTTON "...", psh2, 170, 25, 19, 14
    GROUPBOX "预览", -1, 5, 45, 185, 39
    CTEXT "资源", stc1, 15, 55, 80, 25, SS_CENTERIMAGE | NOT WS_GROUP
    CTEXT "二进制", stc2, 100, 55, 85, 25, SS_CENTERIMAGE | NOT WS_GROUP
    DEFPUSHBUTTON "OK", IDOK, 65, 90, 60, 14
    PUSHBUTTON "取消", IDCANCEL, 130, 90, 60, 14
}

IDD_MACROS DIALOG 0, 0, 265, 165
CAPTION "预定义的宏"
STYLE WS_POPUPWINDOW | WS_CAPTION | WS_THICKFRAME
FONT 9, "宋体"
{
    LTEXT "预定义的宏(&M):", -1, 5, 0, 100, 15, SS_CENTERIMAGE | NOT WS_GROUP
    CONTROL "", lst1, "SysListView32", LVS_EDITLABELS | LVS_SHOWSELALWAYS | LVS_SINGLESEL | LVS_REPORT | WS_BORDER | WS_TABSTOP, 5, 15, 190, 125
    PUSHBUTTON "加(&A)...", psh1, 200, 15, 60, 14
    PUSHBUTTON "编辑(&E)...", psh2, 200, 35, 60, 14
    PUSHBUTTON "删除(&D)", psh3, 200, 55, 60, 14
    PUSHBUTTON "删除全部(&L)", psh7, 200, 105, 60, 14
    DEFPUSHBUTTON "OK", IDOK, 135, 145, 60, 14
    PUSHBUTTON "取消", IDCANCEL, 200, 145, 60, 14
    PUSHBUTTON "重置全部(&R)", psh6, 5, 145, 60, 14
}

IDD_ADDMACRO DIALOG 0, 0, 190, 80
CAPTION "添加预定义的宏"
STYLE DS_MODALFRAME | WS_POPUPWINDOW | WS_CAPTION
FONT 9, "宋体"
{
    RTEXT "键(&K):", -1, 5, 12, 60, 14
    COMBOBOX cmb1, 70, 10, 110, 200, CBS_DROPDOWN | WS_BORDER | WS_VSCROLL | WS_TABSTOP
    RTEXT "值(&V):", -1, 5, 37, 60, 14
    COMBOBOX cmb2, 70, 35, 110, 300, CBS_DROPDOWN | WS_BORDER | WS_VSCROLL | WS_TABSTOP
    DEFPUSHBUTTON "OK", IDOK, 60, 60, 60, 14
    PUSHBUTTON "取消", IDCANCEL, 125, 60, 60, 14
}

IDD_EDITMACRO DIALOG 0, 0, 190, 80
CAPTION "编辑预定义的宏"
STYLE DS_MODALFRAME | WS_POPUPWINDOW | WS_CAPTION
FONT 9, "宋体"
{
    RTEXT "键(&K):", -1, 5, 12, 60, 14
    COMBOBOX cmb1, 70, 10, 110, 200, CBS_DROPDOWN | WS_DISABLED | WS_BORDER | WS_VSCROLL | WS_TABSTOP
    RTEXT "值(&V):", -1, 5, 37, 60, 14
    COMBOBOX cmb2, 70, 35, 110, 300, CBS_DROPDOWN | WS_BORDER | WS_VSCROLL | WS_TABSTOP
    DEFPUSHBUTTON "OK", IDOK, 60, 60, 60, 14
    PUSHBUTTON "取消", IDCANCEL, 125, 60, 60, 14
}

IDD_CTRLDATA DIALOG 0, 0, 190, 130
CAPTION "编辑控件数据"
STYLE DS_MODALFRAME | WS_POPUPWINDOW | WS_CAPTION
FONT 9, "宋体"
{
    LTEXT "二进制数据(&B):", -1, 5, 2, 87, 12
    EDITTEXT edt1, 5, 15, 180, 60, ES_AUTOVSCROLL | ES_MULTILINE | WS_VSCROLL
    LTEXT "您可以通过空格分隔的16位整数来设置控件数据。", -1, 5, 80, 180, 25
    DEFPUSHBUTTON "OK", IDOK, 60, 110, 60, 14
    PUSHBUTTON "取消", IDCANCEL, 125, 110, 60, 14
}

IDD_PATHS DIALOG 0, 0, 295, 220
CAPTION "设置PATH"
STYLE WS_POPUPWINDOW | WS_CAPTION | WS_THICKFRAME
FONT 9, "宋体"
{
    LTEXT "&Include Directories:", -1, 5, 5, 102, 12
    LISTBOX lst1, 5, 20, 220, 105, LBS_NOINTEGRALHEIGHT | LBS_HASSTRINGS | LBS_SORT | WS_VSCROLL | WS_HSCROLL | WS_TABSTOP
    PUSHBUTTON "加(&A)...", psh1, 230, 5, 60, 14
    PUSHBUTTON "编辑(&E)...", psh2, 230, 25, 60, 14
    PUSHBUTTON "删除(&D)", psh3, 230, 45, 60, 14
    PUSHBUTTON "上(&U)", psh4, 230, 65, 60, 14
    PUSHBUTTON "下(&O)", psh5, 230, 85, 60, 14
    PUSHBUTTON "全部删除(&L)", psh6, 5, 130, 95, 14
    RTEXT "&windres.exe:", stc1, 5, 157, 55, 12
    COMBOBOX cmb1, 70, 155, 155, 300, CBS_HASSTRINGS | CBS_AUTOHSCROLL | CBS_DROPDOWN | WS_VSCROLL | WS_TABSTOP
    PUSHBUTTON "浏览(&B)...", psh7, 230, 155, 60, 14
    RTEXT "&cpp.exe:", stc2, 5, 177, 55, 12
    COMBOBOX cmb2, 70, 175, 155, 300, CBS_HASSTRINGS | CBS_AUTOHSCROLL | CBS_DROPDOWN | WS_VSCROLL | WS_TABSTOP
    PUSHBUTTON "浏览(&R)...", psh8, 230, 175, 60, 14
    DEFPUSHBUTTON "OK", IDOK, 165, 200, 60, 14
    PUSHBUTTON "取消", IDCANCEL, 230, 200, 60, 14
    PUSHBUTTON "重置全部(&S)", psh9, 5, 200, 95, 14
}

IDD_EXP_OPTIONS DIALOG 0, 0, 250, 225
CAPTION "导出选项"
STYLE DS_MODALFRAME | WS_POPUPWINDOW | WS_CAPTION
FONT 9, "宋体"
{
    ICON IDI_MAIN, -1, 5, 10, 0, 0
    LTEXT "导出RC文件将生成一些相关文件。您可以选择以下选项:", -1, 35, 5, 210, 29
    AUTOCHECKBOX "使用微软消息表(&T)", chx8, 5, 40, 240, 14
    AUTOCHECKBOX "按语言分开资源文件(&L)", chx1, 5, 60, 240, 14
    AUTOCHECKBOX "使用 BEGIN/END 关键字(&E)", chx2, 5, 80, 240, 14
    AUTOCHECKBOX "通过 LANGUAGE_ * 宏使语言可选(&M)", chx3, 5, 100, 240, 14
    AUTOCHECKBOX "创建备份(&B)", chx4, 5, 120, 110, 14
    RTEXT "后缀:", -1, 120, 122, 75, 12
    COMBOBOX cmb1, 200, 120, 45, 300, CBS_HASSTRINGS | CBS_AUTOHSCROLL | CBS_DROPDOWN | WS_VSCROLL | WS_TABSTOP
    AUTOCHECKBOX "产出冗余注释(&C)", chx5, 5, 140, 240, 14
    AUTOCHECKBOX "用 #ifndef MSVC ... #endif 包装 ma&nifest", chx6, 5, 160, 240, 14
    AUTOCHECKBOX "产出 RC 文件为 &UTF-16", chx7, 5, 180, 240, 14
    DEFPUSHBUTTON "OK", IDOK, 120, 205, 60, 14
    PUSHBUTTON "取消", IDCANCEL, 185, 205, 60, 14
}

IDD_LANGS DIALOG 0, 0, 250, 235
CAPTION "语言列表"
STYLE WS_POPUPWINDOW | WS_CAPTION | WS_THICKFRAME
FONT 9, "宋体"
{
    CONTROL "", lst1, "SysListView32", LVS_SHOWSELALWAYS | LVS_SINGLESEL | LVS_REPORT | WS_BORDER | WS_TABSTOP, 5, 5, 240, 179
    RTEXT "搜索(&S):", stc1, 5, 192, 45, 12
    COMBOBOX cmb1, 55, 190, 85, 300, CBS_SORT | CBS_DROPDOWN | WS_VSCROLL | WS_TABSTOP
    EDITTEXT edt1, 4, 209, 240, 20, ES_AUTOHSCROLL | ES_AUTOVSCROLL | ES_MULTILINE
}

IDD_CHILD DIALOG 0, 0, 215, 135
CAPTION "子对话框"
STYLE WS_CHILD | WS_OVERLAPPEDWINDOW
FONT 9, "宋体"
{
    DEFPUSHBUTTON "OK", IDOK, 35, 115, 60, 14
    PUSHBUTTON "取消", IDCANCEL, 115, 115, 60, 14
}

IDD_DLGINITEDIT DIALOG 0, 0, 325, 165
CAPTION "编辑DLGINIT"
STYLE WS_POPUPWINDOW | WS_CAPTION | WS_THICKFRAME
FONT 9, "宋体"
{
    LTEXT "消息条目(&E):", -1, 5, 7, 100, 12
    CONTROL "", lst1, "SysListView32", LVS_NOSORTHEADER | LVS_AUTOARRANGE | LVS_NOLABELWRAP | LVS_SHOWSELALWAYS | LVS_SINGLESEL | LVS_REPORT | WS_BORDER | WS_VSCROLL | WS_HSCROLL | WS_TABSTOP, 5, 20, 250, 120
    PUSHBUTTON "加(&A)...", psh1, 260, 20, 60, 14
    PUSHBUTTON "编辑(&M)...", psh2, 260, 40, 60, 14
    PUSHBUTTON "删除(&D)", psh3, 260, 60, 60, 14
    PUSHBUTTON "上(&U)", psh4, 260, 100, 60, 14
    PUSHBUTTON "下(&O)", psh5, 260, 120, 60, 14
    DEFPUSHBUTTON "OK", IDOK, 195, 145, 60, 14
    PUSHBUTTON "取消", IDCANCEL, 260, 145, 60, 14
    PUSHBUTTON "全部删除(&L)", psh6, 5, 145, 79, 14
}

IDD_ADDDLGINIT DIALOG 0, 0, 184, 137
CAPTION "添加DLGINIT数据"
STYLE DS_MODALFRAME | WS_POPUPWINDOW | WS_CAPTION
FONT 9, "宋体"
{
    LTEXT "控件&ID:", -1, 5, 7, 56, 12
    COMBOBOX cmb1, 65, 5, 115, 300, CBS_HASSTRINGS | CBS_AUTOHSCROLL | CBS_DROPDOWN | WS_VSCROLL | WS_TABSTOP
    LTEXT "信息(&M):", -1, 5, 32, 55, 12
    COMBOBOX cmb2, 65, 30, 95, 300, CBS_HASSTRINGS | CBS_AUTOHSCROLL | CBS_DROPDOWN | WS_VSCROLL | WS_TABSTOP
    LTEXT "串(&S):", -1, 5, 52, 55, 12
    EDITTEXT edt1, 5, 65, 175, 50, ES_WANTRETURN | ES_MULTILINE | WS_VSCROLL | WS_HSCROLL
    DEFPUSHBUTTON "OK", IDOK, 55, 120, 60, 14
    PUSHBUTTON "取消", IDCANCEL, 120, 120, 60, 14
}

IDD_MODIFYDLGINIT DIALOG 0, 0, 184, 137
CAPTION "添加DLGINIT数据"
STYLE DS_MODALFRAME | WS_POPUPWINDOW | WS_CAPTION
FONT 9, "宋体"
{
    LTEXT "控件&ID:", -1, 5, 7, 56, 12
    COMBOBOX cmb1, 65, 5, 115, 300, CBS_HASSTRINGS | CBS_AUTOHSCROLL | CBS_DROPDOWN | WS_VSCROLL | WS_TABSTOP
    LTEXT "信息(&M):", -1, 5, 32, 55, 12
    COMBOBOX cmb2, 65, 30, 95, 300, CBS_HASSTRINGS | CBS_AUTOHSCROLL | CBS_DROPDOWN | WS_VSCROLL | WS_TABSTOP
    LTEXT "串(&S):", -1, 5, 52, 55, 12
    EDITTEXT edt1, 5, 65, 175, 50, ES_WANTRETURN | ES_MULTILINE | WS_VSCROLL | WS_HSCROLL
    DEFPUSHBUTTON "OK", IDOK, 55, 120, 60, 14
    PUSHBUTTON "取消", IDCANCEL, 120, 120, 60, 14
}

IDD_STRINGLIST DIALOG 0, 0, 205, 220
CAPTION "Control String List"
STYLE WS_POPUPWINDOW | WS_CAPTION | WS_THICKFRAME
FONT 9, "宋体"
{
    LTEXT "", stc1, 5, 5, 195, 70
    EDITTEXT edt1, 5, 80, 195, 115, ES_WANTRETURN | ES_MULTILINE | WS_VSCROLL | WS_HSCROLL
    DEFPUSHBUTTON "OK", IDOK, 75, 200, 60, 14
    PUSHBUTTON "取消", IDCANCEL, 140, 200, 60, 14
}

IDD_SAVE_OPTIONS DIALOG 0, 0, 250, 225
CAPTION "保存选项"
STYLE DS_MODALFRAME | WS_POPUPWINDOW | WS_CAPTION
FONT 9, "宋体"
{
    ICON IDI_MAIN, -1, 5, 10, 0, 0
    LTEXT "保存RC文件将生成一些相关文件。您可以选择以下选项。", -1, 35, 5, 210, 29
    AUTOCHECKBOX "使用微软消息表(&T)", chx8, 5, 40, 240, 14
    AUTOCHECKBOX "按语言分开资源文件(&L)", chx1, 5, 60, 240, 14
    AUTOCHECKBOX "使用 BEGIN/END 关键字(&E)", chx2, 5, 80, 240, 14
    AUTOCHECKBOX "通过 LANGUAGE_ * 宏使语言可选(&M)", chx3, 5, 100, 240, 14
    AUTOCHECKBOX "创建备份(&B)", chx4, 5, 120, 110, 14
    RTEXT "后缀:", -1, 120, 122, 75, 12
    COMBOBOX cmb1, 200, 120, 45, 300, CBS_HASSTRINGS | CBS_AUTOHSCROLL | CBS_DROPDOWN | WS_VSCROLL | WS_TABSTOP
    AUTOCHECKBOX "产出冗余注释(&C)", chx5, 5, 140, 240, 14
    AUTOCHECKBOX "用 #ifndef MSVC ... #endif 包装 ma&nifest", chx6, 5, 160, 240, 14
    AUTOCHECKBOX "产出 RC 文件为 &UTF-16", chx7, 5, 180, 240, 14
    DEFPUSHBUTTON "OK", IDOK, 120, 205, 60, 14
    PUSHBUTTON "取消", IDCANCEL, 185, 205, 60, 14
}

IDD_ENCODING DIALOG 0, 0, 200, 170
CAPTION "资源项的编码"
STYLE DS_MODALFRAME | WS_POPUPWINDOW | WS_CAPTION
FONT 9, "宋体"
{
    CONTROL "", lst1, "SysListView32", LVS_SHOWSELALWAYS | LVS_SINGLESEL | LVS_REPORT | WS_BORDER, 5, 5, 190, 115
    PUSHBUTTON "加(&A)...", psh1, 5, 125, 60, 14
    PUSHBUTTON "修改(&M)...", psh2, 70, 125, 60, 14
    PUSHBUTTON "删除(&D)", psh3, 135, 125, 60, 14
    DEFPUSHBUTTON "OK", IDOK, 70, 150, 60, 14
    PUSHBUTTON "取消", IDCANCEL, 135, 150, 60, 14
    PUSHBUTTON "重启(&R)", psh5, 5, 149, 60, 14
}

IDD_ADDENC DIALOG 0, 0, 215, 80
CAPTION "添加资源编码"
STYLE DS_MODALFRAME | WS_POPUPWINDOW | WS_CAPTION
FONT 9, "宋体"
{
    LTEXT "资源类型(&T):", -1, 5, 7, 70, 12
    COMBOBOX cmb1, 75, 5, 135, 200, CBS_HASSTRINGS | CBS_AUTOHSCROLL | CBS_DROPDOWN | WS_BORDER | WS_VSCROLL | WS_TABSTOP
    LTEXT "编码(&E):", -1, 5, 30, 70, 12
    COMBOBOX cmb2, 75, 30, 85, 300, CBS_HASSTRINGS | CBS_AUTOHSCROLL | CBS_DROPDOWNLIST | WS_VSCROLL | WS_TABSTOP
    DEFPUSHBUTTON "OK", IDOK, 86, 60, 60, 14
    PUSHBUTTON "取消", IDCANCEL, 150, 60, 60, 14
}

IDD_MODIFYENC DIALOG 0, 0, 215, 80
CAPTION "修改资源编码"
STYLE DS_MODALFRAME | WS_POPUPWINDOW | WS_CAPTION
FONT 9, "宋体"
{
    LTEXT "资源类型(&T):", -1, 5, 7, 70, 12
    COMBOBOX cmb1, 75, 5, 135, 200, CBS_HASSTRINGS | CBS_AUTOHSCROLL | CBS_DROPDOWN | WS_DISABLED | WS_BORDER | WS_VSCROLL | WS_TABSTOP
    LTEXT "编码(&E):", -1, 5, 30, 70, 12
    COMBOBOX cmb2, 75, 30, 85, 300, CBS_HASSTRINGS | CBS_AUTOHSCROLL | CBS_DROPDOWNLIST | WS_VSCROLL | WS_TABSTOP
    DEFPUSHBUTTON "OK", IDOK, 86, 60, 60, 14
    PUSHBUTTON "取消", IDCANCEL, 150, 60, 60, 14
}

IDD_CONSTANT DIALOG 0, 0, 205, 75
CAPTION "查询常量"
STYLE DS_MODALFRAME | WS_POPUPWINDOW | WS_CAPTION
FONT 9, "宋体"
{
    LTEXT "常数的名称(&N):", -1, 5, 7, 80, 12
    COMBOBOX cmb1, 94, 7, 105, 300, CBS_HASSTRINGS | CBS_AUTOHSCROLL | CBS_DROPDOWN | WS_VSCROLL | WS_TABSTOP
    LTEXT "恒定价值(&V):", -1, 5, 32, 80, 12
    EDITTEXT edt2, 95, 30, 50, 14, ES_READONLY
    EDITTEXT edt3, 150, 30, 50, 14, ES_READONLY
    DEFPUSHBUTTON "OK", IDOK, 70, 55, 60, 14
}

IDD_EGA DIALOG 0, 0, 400, 225
CAPTION "电脑语言EGA"
STYLE WS_POPUPWINDOW | WS_CAPTION | WS_THICKFRAME
FONT 9, "宋体"
{
    GROUPBOX "EGA 主控台", grp1, 5, 5, 390, 195
    EDITTEXT edt1, 10, 20, 380, 170, ES_READONLY | ES_AUTOVSCROLL | ES_MULTILINE | WS_VSCROLL | NOT WS_TABSTOP
    RTEXT "EGA>", stc1, 10, 208, 20, 10
    EDITTEXT edt2, 35, 205, 300, 15, ES_WANTRETURN | ES_AUTOHSCROLL | ES_AUTOVSCROLL | ES_MULTILINE
    PUSHBUTTON "&Enter", IDOK, 345, 205, 50, 15
}

IDD_FONTSUBST DIALOG 0, 0, 185, 180
CAPTION "Dialog Font Substitutes"
STYLE DS_CENTER | DS_MODALFRAME | WS_POPUPWINDOW | WS_CAPTION
FONT 9, "宋体"
{
    LTEXT "字形 #&1:", -1, 5, 7, 44, 12
    COMBOBOX cmb1, 55, 5, 125, 300, CBS_HASSTRINGS | CBS_AUTOHSCROLL | CBS_DROPDOWN | WS_VSCROLL | WS_TABSTOP
    ICON IDI_ARROW, -1, 30, 25, 0, 0
    COMBOBOX cmb2, 55, 30, 125, 300, CBS_HASSTRINGS | CBS_AUTOHSCROLL | CBS_DROPDOWN | WS_VSCROLL | WS_TABSTOP
    LTEXT "字形 #&2:", -1, 5, 57, 44, 12
    COMBOBOX cmb3, 55, 55, 125, 300, CBS_HASSTRINGS | CBS_AUTOHSCROLL | CBS_DROPDOWN | WS_VSCROLL | WS_TABSTOP
    ICON IDI_ARROW, -1, 30, 75, 0, 0
    COMBOBOX cmb4, 55, 80, 125, 300, CBS_HASSTRINGS | CBS_AUTOHSCROLL | CBS_DROPDOWN | WS_VSCROLL | WS_TABSTOP
    LTEXT "字形 #&3:", -1, 5, 105, 44, 12
    COMBOBOX cmb5, 55, 105, 125, 300, CBS_HASSTRINGS | CBS_AUTOHSCROLL | CBS_DROPDOWN | WS_VSCROLL | WS_TABSTOP
    ICON IDI_ARROW, -1, 30, 125, 0, 0
    COMBOBOX cmb6, 55, 130, 125, 300, CBS_HASSTRINGS | CBS_AUTOHSCROLL | CBS_DROPDOWN | WS_VSCROLL | WS_TABSTOP
    DEFPUSHBUTTON "OK", IDOK, 75, 160, 50, 14
    PUSHBUTTON "取消", IDCANCEL, 130, 160, 50, 14
    PUSHBUTTON "重启(&R)", psh1, 5, 160, 55, 14
}

IDD_DROPDOWNPOPUP DIALOG 0, 0, 120, 150
CAPTION " "
STYLE WS_POPUP | WS_DLGFRAME | NOT WS_BORDER
FONT 9, "宋体"
{
    LISTBOX lst1, 0, 0, 120, 150, LBS_WANTKEYBOARDINPUT | LBS_NOINTEGRALHEIGHT | LBS_HASSTRINGS | WS_VSCROLL | WS_TABSTOP, WS_EX_CLIENTEDGE
}

IDD_DFMSETTINGS DIALOG 0, 0, 210, 135
CAPTION "Delphi DFM Settings"
STYLE DS_CENTER | DS_MODALFRAME | WS_POPUPWINDOW | WS_CAPTION
FONT 9, "宋体"
{
    LTEXT "以下设置与 Delphi DFM 相关。", -1, 35, 5, 171, 20
    ICON IDI_DFMICON, -1, 5, 5, 0, 0
    RTEXT "代码页(&C)：", -1, 6, 32, 70, 12
    COMBOBOX cmb1, 85, 30, 120, 300, CBS_HASSTRINGS | CBS_AUTOHSCROLL | CBS_DROPDOWN | WS_VSCROLL | WS_TABSTOP
    AUTOCHECKBOX "插入原始字符串注释(&I)", chx1, 5, 50, 200, 14
    AUTOCHECKBOX "不要使用 Unicode 和 UTF-8 (&U)", chx2, 5, 70, 200, 14
    DEFPUSHBUTTON "OK", IDOK, 80, 115, 60, 14
    PUSHBUTTON "取消", IDCANCEL, 145, 115, 60, 14
}

IDD_COPYTOMULTILANG DIALOG 0, 0, 200, 195
CAPTION "复制到多种语言"
STYLE DS_CENTER | DS_MODALFRAME | WS_POPUPWINDOW | WS_CAPTION
FONT 9, "宋体"
{
    LTEXT "请添加您要将资源复制到的语言：", -1, 5, 5, 190, 22
    LTEXT "语言(&L)：", -1, 5, 35, 82, 12
    LISTBOX lst1, 5, 50, 190, 100, LBS_WANTKEYBOARDINPUT | LBS_NOINTEGRALHEIGHT | LBS_HASSTRINGS | WS_VSCROLL | WS_TABSTOP
    COMBOBOX cmb3, 5, 155, 126, 14, CBS_HASSTRINGS | CBS_AUTOHSCROLL | CBS_DROPDOWN | WS_BORDER | WS_VSCROLL | WS_TABSTOP
    PUSHBUTTON "添加(&A)", psh1, 135, 155, 60, 14
    DEFPUSHBUTTON "OK", IDOK, 5, 175, 60, 14
    PUSHBUTTON "取消", IDCANCEL, 70, 175, 60, 14
}

IDD_TOOLBARRES DIALOG 0, 0, 230, 195
CAPTION "工具栏资源"
STYLE DS_CENTER | DS_MODALFRAME | WS_POPUPWINDOW | WS_CAPTION
FONT 9, "宋体"
{
    RTEXT "图标宽度(&W):", -1, 5, 5, 60, 15, SS_CENTERIMAGE | NOT WS_GROUP
    EDITTEXT edt1, 70, 5, 30, 15, ES_NUMBER | ES_RIGHT
    CONTROL "", scr1, "msctls_updown32", UDS_NOTHOUSANDS | UDS_ARROWKEYS | UDS_AUTOBUDDY | UDS_ALIGNRIGHT | UDS_SETBUDDYINT, 80, 5, 30, 15
    RTEXT "图标高度(&H):", -1, 110, 5, 60, 15, SS_CENTERIMAGE | NOT WS_GROUP
    EDITTEXT edt2, 180, 5, 30, 15, ES_NUMBER | ES_RIGHT
    CONTROL "", scr2, "msctls_updown32", UDS_NOTHOUSANDS | UDS_ARROWKEYS | UDS_AUTOBUDDY | UDS_ALIGNRIGHT | UDS_SETBUDDYINT, 190, 5, 30, 15
    LTEXT "工具栏按钮(&T):", -1, 5, 25, 140, 15, SS_CENTERIMAGE | NOT WS_GROUP
    LISTBOX lst1, 5, 40, 140, 130, LBS_DISABLENOSCROLL | LBS_WANTKEYBOARDINPUT | LBS_NOINTEGRALHEIGHT | LBS_HASSTRINGS | LBS_OWNERDRAWFIXED | WS_VSCROLL | WS_TABSTOP
    PUSHBUTTON "添加(&A)...", psh1, 150, 40, 75, 15
    PUSHBUTTON "修改(&M)...", psh2, 150, 60, 75, 15
    PUSHBUTTON "删除(&D)", psh3, 150, 80, 75, 15
    PUSHBUTTON "上(&U)", psh4, 150, 135, 75, 15
    PUSHBUTTON "下(&O)", psh5, 150, 155, 75, 15
    DEFPUSHBUTTON "OK", IDOK, 5, 175, 60, 15
    PUSHBUTTON "取消", IDCANCEL, 70, 175, 60, 15
}

IDD_ADDTBBTN DIALOG 0, 0, 177, 92
CAPTION "添加工具栏按钮"
STYLE DS_CENTER | DS_MODALFRAME | WS_POPUPWINDOW | WS_CAPTION
FONT 9, "宋体"
{
    LTEXT "工具栏按钮的命令ID (&C):", -1, 5, 5, 160, 15, SS_CENTERIMAGE | NOT WS_GROUP
    COMBOBOX cmb1, 5, 25, 150, 150, CBS_HASSTRINGS | CBS_AUTOHSCROLL | CBS_DROPDOWN | WS_VSCROLL | WS_TABSTOP
    AUTOCHECKBOX "分隔器(&S)", chx1, 5, 45, 90, 15
    DEFPUSHBUTTON "OK", IDOK, 45, 70, 60, 15
    PUSHBUTTON "取消", IDCANCEL, 110, 70, 60, 15
}

IDD_MODIFYTBBTN DIALOG 0, 0, 177, 92
CAPTION "修改工具栏按钮"
STYLE DS_CENTER | DS_MODALFRAME | WS_POPUPWINDOW | WS_CAPTION
FONT 9, "宋体"
{
    LTEXT "工具栏按钮的命令ID (&C):", -1, 5, 5, 160, 15, SS_CENTERIMAGE | NOT WS_GROUP
    COMBOBOX cmb1, 5, 25, 150, 150, CBS_HASSTRINGS | CBS_AUTOHSCROLL | CBS_DROPDOWN | WS_VSCROLL | WS_TABSTOP
    AUTOCHECKBOX "分隔器(&S)", chx1, 5, 45, 90, 15
    DEFPUSHBUTTON "OK", IDOK, 45, 70, 60, 15
    PUSHBUTTON "取消", IDCANCEL, 110, 70, 60, 15
}

//////////////////////////////////////////////////////////////////////////////
// RT_VERSION

1 VERSIONINFO
FILEVERSION     5, 7, 9, 0
PRODUCTVERSION  5, 7, 9, 0
FILEOS          0x40004
FILETYPE        0x1
FILESUBTYPE     0x0
{
    BLOCK "StringFileInfo"
    {
        BLOCK "080404B0"
        {
            VALUE "CompanyName", "片山博文MZ\0"
            VALUE "FileDescription", "RisohEditor\0"
            VALUE "FileVersion", "5.7.9\0"
            VALUE "LegalCopyright", "Copyright (C) 2017-2020 片山博文MZ and 林鸿湘. 版权所有.\0"
            VALUE "ProductName", "RisohEditor\0"
            VALUE "ProductVersion", "5.7.9\0"
        }
    }
    BLOCK "VarFileInfo"
    {
        VALUE "Translation", 0x0804, 0x04B0
    }
}

//////////////////////////////////////////////////////////////////////////////
// RISOHTEMPLATE

4 RISOHTEMPLATE "res/2052_RISOHTEMPLATE_4.bin"

5 RISOHTEMPLATE "res/2052_RISOHTEMPLATE_5.bin"

//////////////////////////////////////////////////////////////////////////////
// RT_STRING

STRINGTABLE
{
    IDS_APPNAME, "RisohEditor 5.7.9 by 片山博文MZ"
    IDS_TITLEWITHFILE, "RisohEditor 5.7.9 - 文件: %s"
    IDS_EXTRACTRES, "导出资源"
    IDS_RESBINFILTER, "二进制资源文件 (*.res)|*.res|二进制文件 (*.bin)|*.bin|全部文件 (*.*)|*.*|"
    IDS_CANNOTSAVE, "无法保存。"
    IDS_REPLACERES, "替换资源"
    IDS_ALLFILES, "全部文件 (*.*)|*.*|"
    IDS_ENTERTYPE, "请选择资源类型。"
    IDS_ENTERNAME, "请输入资源名称。"
    IDS_ENTERLANG, "请输入资源语言类型。"
    IDS_FILENOTFOUND, "未找到文件。"
    IDS_CANNOTREPLACE, "替换失败。"
    IDS_EXERESFILTER, "资源配置文件 (*.exe;*.dll;*.ocx;*.cpl;*.scr;*.mui)|*.exe;*.dll;*.ocx;*.cpl;*.scr;*.mui|RC文件 (*.rc)|*.rc|二进制资源文件 (*.res)|*.res|全部文件 (*.*)|*.*|"
    IDS_SAVEAS, "另存为"
    IDS_CANNOTADDICON, "加载图标失败。"
    IDS_ADDICON, "加图标"
    IDS_ICOFILTER, "图标文件 (*.ico)|*.ico|全部文件 (*.*)|*.*|"
    IDS_REPLACEICO, "替换图标"
    IDS_CANTREPLACEICO, "替换图标失败。"
    IDS_EXISTSOVERWRITE, "文件已经存在，替换掉?"
    IDS_OPEN, "打开"
    IDS_CANNOTOPEN, "打开失败。"
    IDS_ADDBMP, "加位图"
    IDS_BMPFILTER, "位图文件 (*.bmp)|*.bmp|PNG 图片 (*.png)|*.png|全部文件 (*.*)|*.*|"
    IDS_CANTREPLACEBMP, "位图打开失败！"
    IDS_REPLACEBMP, "替换位图"
    IDS_ERRORCODE, "错误码 %d"
    IDS_VERSIONINFO, "RisohEditor 版本 5.7.9\r\n\r\n片山博文MZ\r\nKatayama Hirofumi MZ\r\n\r\nLicense: GPLv3 (free software)"
    IDS_ADDRES, "增加资源"
    IDS_CANNOTADDRES, "添加资源失败。"
    IDS_CANTADDBMP, "添加位图失败。"
    IDS_EXTRACTBMP, "导出位图"
    IDS_CANTEXTRACTBMP, "不能导出位图。"
    IDS_CANTREPLACECUR, "不能导出光标。"
    IDS_CANNOTADDCUR, "不能添加光标。"
    IDS_CURFILTER, "光标文件(*.cur)|*.cur|动态光标 (*.ani)|*.ani|全部文件 (*.*)|*.*|"
    IDS_ADDCUR, "增加光标"
    IDS_REPLACECUR, "替换光标"
    IDS_EXTRACTICO, "导出图标"
    IDS_CANTEXTRACTICO, "导出图标失败。"
    IDS_EXTRACTCUR, "导出光标"
    IDS_CANTEXTRACTCUR, "导出光标失败。"
    IDS_RESFILTER, "二进制资源 (*.res)|*.res|全部文件 (*.*)|*.*|"
    IDS_NEUTRAL, "十进制"
    IDS_IMPORTRES, "导入"
    IDS_CANNOTIMPORT, "导入资源失败。"
    IDS_COMPILE, "编译 (F8)"
    IDS_CANCELEDIT, "取消编辑 (Ctrl+E)"
    IDS_GUIEDIT, "GUI编辑模式 (Ctrl+G)"
    IDS_CANNOTSTARTUP, "编译器启动失败。"
    IDS_RESMISMATCH, "资源类型不匹配。"
    IDS_SAMPLETEXT, "这是一个模板"
    IDS_ALREADYEXISTS, "已存在。"
    IDS_KEY, "键"
    IDS_FLAGS, "标识"
    IDS_COMMANDID, "控件 ID"
    IDS_INVALIDKEY, "无效的键。"
    IDS_COMPILEERROR, "编译失败。"
    IDS_STRINGID, "字符型 ID"
    IDS_STRINGVALUE, "字符的值"
    IDS_CAPTION, "标题"
    IDS_HELPID, "帮助 ID"
    IDS_INDENT, "» "
    IDS_DATAISEMPTY, "数据为空。"
    IDS_TEST, "测试一下效果"
    IDS_SEPARATOR, "---"
    IDS_COMPILENOW, "文件已经改变，编译?"
    IDS_RADWINDOW, "编辑对话框"
    IDS_ENTERCLASS, "请输入有效的window类名。"
    IDS_TEXTEDIT, "由Text编辑 (Ctrl+T)"
    IDS_CURSORINFO, "图片 #%u: 宽度 %u, 高度 %u, bit像素点 %u, xHotSpot %u, yHotSpot %u, ID %u\r\n"
    IDS_IMAGECOUNT, "图片数量: %u\r\n"
    IDS_ICONINFO, "图片 #%u: 宽度 %u, 高度 %u, bit像素点 %u, ID %u\r\n"
    IDS_READY, "准备"
    IDS_EXECUTINGCMD, "导出命令..."
    IDS_EDITINGBYGUI, "正由GUI编辑..."
    IDS_COORD, "%d, %d, %d, %d"
    IDS_STARTING, "开始..."
    IDS_COMPILING, "编译..."
    IDS_CANNOTLOAD, "加载失败。"
    IDS_NONE, "(空)"
    IDS_WAVESOUND, "(声波)\r\n"
    IDS_IDTYPE, "ID 类型"
    IDS_IDPREFIX, "ID 前缀"
    IDS_EMPTYSTR, "输入字符。"
    IDS_ANICURSOR, "(动态光标)\r\n"
    IDS_ANIICON, "(动态图标)\r\n"
    IDS_HEADFILTER, "头文件 (*.h)|*.h|全部文件 (*.*)|*.*|"
    IDS_LOADRESH, "加载 ""resource.h"" 文件"
    IDS_NAME, "名称"
    IDS_VALUE, "值"
    IDS_NOSUCHID, "没有该ID。"
    IDS_IMAGEINFO, "宽度 %u, 高度 %u, 二进制像素 %u\r\n"
    IDS_ENTERINT, "请输入有效整数。"
    IDS_ENTERTEXT, "请输入有效文本。"
    IDS_ENTERID, "请输入有效 ID。"
    IDS_ADDNEXTIDS, "请添加下面ID到 ""resource.h"":\r\n\r\n"
    IDS_DELETENEXTIDS, "请从这里删除ID ""resource.h"":\r\n\r\n"
    IDS_NOCHANGE, "资源ID没有改变。"
    IDS_DLGFAIL, "哟，RAD制作失败。"
    IDS_LOADWCLIB, "加载Window类资源"
    IDS_AVIMOVIE, "(AVI 视频)\r\n"
    IDS_ADDDIALOG, "添加对话框"
    IDS_ADDMENU, "添加菜单"
    IDS_ADDVERINFO, "添加版本信息"
    IDS_ADDCURSOR, "添加光标"
    IDS_NOMOREITEM, "没有更多的项目了。"
    IDS_INVALIDDATA, "(无效数据)\r\n"
    IDS_UPDATERESH, "确定更新 ""resource.h"" 吗?"
    IDS_CANTWRITERESH, "无法写入 ""resource.h""。"
    IDS_SAVERESH, "保存 ""resource.h"" 文件"
    IDS_DLLFILTER, "DLL 文件 (*.dll;*.ocx;*.mui)|*.dll;*.ocx;*.mui|全部文件 (*.*)|*.*|"
    IDS_EXERESRCFILTER, "可读文件 (*.exe;*.dll;*.ocx;*.cpl;*.scr;*.mui;*.res;*.rc)|*.exe;*.dll;*.ocx;*.cpl;*.scr;*.mui;*.res;*.rc|资源配置文件 (*.exe;*.dll;*.ocx;*.cpl;*.scr;*.mui)|*.exe;*.dll;*.ocx;*.cpl;*.scr;*.mui|二进制文件 (*.res)|*.res|资源文件 (*.rc)|*.rc|全部文件 (*.*)|*.*|"
    IDS_CANTTESTCHILDWND, "无法测试对话框, 因为它是一个子窗口。"
    IDS_CANTTESTCLASSDLG, "由于对话被分类, 所以不能被测试。"
    IDS_FILEISUPXED, "文件\r\n\r\n'%s'\r\n\r\n被UPX压缩. 你想使用临时文件解压缩吗?\r\n\r\n如果你没有扩展它, 阅读可能会失败。"
    IDS_CANTUPXEXTRACT, "无法由UPX提取。"
    IDS_CANTSAVEUPXED, "无法保存文件, 因为它是由UPX压缩的。"
    IDS_MESSAGEID, "消息 ID"
    IDS_MESSAGEVALUE, "消息值"
    IDS_RCFILTER, "RC 文件 (*.rc)|*.rc|"
    IDS_EXPORT, "导出"
    IDS_CANTEXPORT, "导出失败。"
    IDS_MUSTBEEMPTYDIR, "如果有任何外部文件，则导出目标必须是空文件夹。"
    IDS_FULLWIDTH, "０１２３４５６７８９ＡＢＣＤＥＦＧＨＩＪＫＬＭＮＯＰＱＲＳＴＵＶＷＸＹＺａｂｃｄｅｆｇｈｉｊｋｌｍｎｏｐｑｒｓｔｕｖｗｘｙｚ－＿（）．　"
    IDS_HALFWIDTH, "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz-_(). "
    IDS_MACRONAME, "宏名称"
    IDS_MACROVALUE, "宏值"
    IDS_OPTIONAL, "(可选的)"
    IDS_ADDINCLUDE, "添加包含目录"
    IDS_EDITINCLUDE, "编辑包含目录"
    IDS_WINDRESEXE, "windres.exe|windres.exe|"
    IDS_CPPEXE, "cpp.exe|cpp.exe|"
    IDS_INVALIDPATH, "该路径无效。"
    IDS_DATATOOLONG, "数据太长。"
    IDS_ALL, "(所有)"
    IDS_UNKNOWNFORMAT, "(未知的数据格式)\r\n"
    IDS_LANGUAGE, "语言"
    IDS_INTVALUE, "整数值"
    IDS_PARENTWND, "家长测试窗口"
    IDS_CHOOSE_OLE_CLSID, "选择OLE CLSID"
    IDS_CONTROL, "控制"
    IDS_MESSAGE, "信息"
    IDS_STRING, "串"
    IDS_DATAISINVALID, "数据无效。"
    IDS_DLGINIT1, "您可以通过在与对话框同名的RT_DLGINIT资源数据中设置初始化数据来指定组合框和列表框的初始化。"
    IDS_DLGINIT2, "当WM_INITDIALOG消息到达时, 您可以通过调用附加文件“DlgInit/DlgInit.h”的ExecuteDlgInitDx函数来初始化对话框。\r\n\r\n"
    IDS_DLGINIT3, "请指定用换行符分隔的RT_DLGINIT字符串列表。"
    IDS_SAMELANG, "这是相同的语言。"
    IDS_SAMENAME, "这是相同的资源名称。"
    IDS_CANTSAVETOEXE, "无法从非可执行文件保存为EXE。"
    IDS_CANTSTARTSEARCH, "无法开始搜索。"
    IDS_AMERICA, "美国"
    IDS_ENGLISH, "英语"
    IDS_CHINA, "中国"
    IDS_CHINESE, "中文"
    IDS_RUSSIA, "俄国"
    IDS_RUSSIAN, "俄语"
    IDS_WANNAGENRESH, "你想生成文件 'resource.h' 吗?"
    IDS_EXEFILTER, "资源配置文件 (*.exe;*.dll;*.ocx;*.cpl;*.scr;*.mui)|*.exe;*.dll;*.ocx;*.cpl;*.scr;*.mui|全部文件 (*.*)|*.*|"
    IDS_SAVEASCOMPRESS, "另存压缩"
    IDS_TOOL_NEW, "新建"
    IDS_TOOL_OPEN, "打开..."
    IDS_TOOL_SAVE, "另存为..."
    IDS_TOOL_EXPAND, "全部展开"
    IDS_TOOL_COLLAPSE, "全部折叠"
    IDS_TOOL_PLUS, "新增项目..."
    IDS_TOOL_MINUS, "删除项目"
    IDS_TOOL_CHANGE, "更改名称/语言"
    IDS_TOOL_CLONE, "复制为其他名称/语言"
    IDS_TOOL_RECOMPILE, "重新编译"
    IDS_TOOL_CANCELEDIT, "取消修改"
    IDS_TOOL_IMPORT, "导入..."
    IDS_TOOL_EXTRACT, "导出..."
    IDS_TOOL_GUIEDIT, "GUI编辑"
    IDS_UNITEDKINGDOM, "英国"
    IDS_GREATBRITAIN, "大不列颠"
    IDS_BRITISH, "英国的"
    IDS_FRANCE, "法国"
    IDS_FRENCH, "法语"
    IDS_GERMANY, "德国"
    IDS_GERMAN, "德语"
    IDS_SPAIN, "西班牙"
    IDS_SPANISH, "西班牙语"
    IDS_INVALIDLANG, "无法识别的语言。"
    IDS_INVALIDNAME, "资源名称无效。"
    IDS_PNGRESBINFILTER, "PNG图片 (*.png)|*.png|资源文件(*.res)|*.res|二进制文件 (*.bin)|*.bin|全部文件 (*.*)|*.*|"
    IDS_JPEGRESBINFILTER, "JPEG图片 (*.jpg;*.jpeg;*.jpe;*.jfif)|*.jpg;*.jpeg;*.jpe;*.jfif|资源文件(*.res)|*.res|二进制文件 (*.bin)|*.bin|全部文件 (*.*)|*.*|"
    IDS_GIFRESBINFILTER, "GIF图片 (*.gif)|*.gif|资源文件(*.res)|*.res|二进制文件 (*.bin)|*.bin|全部文件 (*.*)|*.*|"
    IDS_TIFFRESBINFILTER, "TIFF图片 (*.tif;*.tiff)|*.tif;*.tiff|资源文件(*.res)|*.res|二进制文件 (*.bin)|*.bin|全部文件 (*.*)|*.*|"
    IDS_AVIRESBINFILTER, "AVI视频 (*.avi)|*.avi|资源文件(*.res)|*.res|二进制文件 (*.bin)|*.bin|全部文件 (*.*)|*.*|"
    IDS_WAVERESBINFILTER, "WAVE声音 (*.wav)|*.wav|资源文件(*.res)|*.res|二进制文件 (*.bin)|*.bin|全部文件 (*.*)|*.*|"
    IDS_COMMENT_SEP, "//////////////////////////////////////////////////////////////////////////////\r\n\r\n"
    IDS_NEWLINE, "\r\n"
    IDS_NOTICE, "// This file is automatically generated by RisohEditor 5.7.9.\r\n"
    IDS_DAGGER, "// † <-- This dagger helps UTF-8 detection.\r\n"
    IDS_IMPORTFILTER, "可导入文件|*.rc;*.res;*.dfm;*.html;*.htm;*.manifest;*.ico;*.cur;*.ani;*.wav;*.bmp;*.dib;*.png;*.gif;*.jpg;*.jpeg;*.jpe;*.jfif;*.tif;*.tiff;*.avi;*.wmf;*.emf|RC 文件 (*.rc)|*.rc|二进制资源文件 (*.res)|*.res|图片文件|*.bmp;*.dib;*.png;*.gif;*.jpg;*.jpeg;*.jpe;*.jfif;*.tif;*.tiff;*.wmf;*.emf;*.tlb|光标文件(*.cur;*.ani)|*.cur;*.ani|图标文件 (*.ico)|*.ico|WAVE声音 (*.wav)|*.wav|HTML文件 (*.html;*.htm)|*.html;*.htm|清单文件 (*.manifest)|*.manifest|Delphi DFM Files (*.dfm)|*.dfm|Delphi DFM 文件 (*.dfm)|*.dfm|TYPELIB Files (*.tlb)|*.tlb|全部文件 (*.*)|*.*|"
    IDS_CANTWRITEBYLOCK, "无法写入文件, 因为以下文件已被锁定。\r\n\r\n%s"
    IDS_ANSI, "ANSI"
    IDS_WIDE, "Unicode"
    IDS_UTF8, "UTF-8 (with BOM)"
    IDS_UTF8N, "UTF-8 (without BOM)"
    IDS_SJIS, "Shift_JIS"
    IDS_BINARY, "(二进制数据)"
    IDS_RESTYPE, "资源类型"
    IDS_ENCODING, "编码"
    IDS_INVALIDRESTYPE, "资源类型无效。"
    IDS_PATHSPACEERROR, "您错误地使用空格字符安装了该位置！ 资源编译器不能接受空间。\n\n请避免使用“C:\\Program Files”。"
    IDS_LOADEGAPROGRAM, "加载EGA程序..."
    IDS_EGAFILTER, "EGA 计划 (*.ega)|*.ega|全部文件 (*.*)|*.*|"
    IDS_QUERYSAVECHANGE, "该文件已被修改. 您要立即保存更改吗？"
    IDS_DFMFILTER, "DFM 文件 (*.dfm)|*.dfm|文字档案 (*.txt)|*.txt|全部文件 (*.*)|*.*|"
    IDS_CANTEXTRACTDFM, "无法提取DFM数据。"
    IDS_EXTRACTDFM, "提取DFM数据"
    IDS_ENTERNONZERONAME, "请输入不为零的资源名称。"
    IDS_ENTERNONZEROTYPE, "请输入不为零的资源类型名称。"
    IDS_HOMEPAGE, "https://katahiromz.web.fc2.com/re/ch/"
    IDS_FILESAVED, "文件保存确定。"
    IDS_RECOMPILEOK, "重新编译。"
    IDS_RECOMPILEFAILED, "重新编译失败 (语法错误)。"
    IDS_TOOL_EXPORT, "导出..."
    IDS_CODEEDITOR, "代码编辑器"
    IDS_HEXVIEWER, "十六进制查看器"
    IDS_INTEGERORIDENTIFIER, "(整形或标识符)"
    IDS_NOTEXT, " "
    IDS_NOUPDATE, "您正使用最新版本。"
    IDS_THEREISUPDATE, "有一个可以更新的 RisohEditor %s。 您想立即下载更新吗？"
    IDS_CANTCHECKUPDATE, "检查更新失败。"
    IDS_CODEPAGE1252, "1252 (拉丁1)"
    IDS_CODEPAGE1250, "1250 (拉丁2)"
    IDS_CODEPAGE1251, "1251 (西里尔)"
    IDS_CODEPAGE1253, "1253 (希腊语)"
    IDS_CODEPAGE1254, "1254 (土耳其)"
    IDS_CODEPAGE1255, "1255 (希伯来语)"
    IDS_CODEPAGE1256, "1256 (阿拉伯)"
    IDS_CODEPAGE1257, "1257 (波罗的海)"
    IDS_CODEPAGE874, "874 (泰语)"
    IDS_CODEPAGE932, "932 (日本语)"
    IDS_CODEPAGE936, "936 (简体中文)"
    IDS_CODEPAGE949, "949 (韩语)"
    IDS_CODEPAGE950, "950 (繁体中文)"
    IDS_CODEPAGE65001, "65001 (UTF-8)"
    IDS_EXTRACTTLB, "Extract TYPELIB data"
    IDS_CANTEXTRACTTLB, "Unable to extract the TYPELIB data."
    IDS_TLBRESBINFILTER, "TYPELIB data (*.tlb)|*.tlb|Binary Resources (*.res)|*.res|Text Files (*.txt)|*.txt|MIDL Files (*.idl)|*.idl|All Files (*.*)|*.*|"
    IDS_USAGE, "Usage: RisohEditor [options | ""file""]\n\nOptions:\n--help  Show this message.\n--version  Show version info.\n--load ""your-file.rc""  Load the file (without GUI)\n--save ""your-file.res""  Save the file (without GUI)\n--log-file ""log-file.txt""  Specify the log file.\n--load-options OPTIONS  Set load options.\n--save-options OPTIONS  Set save options.\n\nLoad options: (no-load-res-h)\nSave options: (idc-static)(compress)(sep-lang)(no-res-folder)(lang-macro)(less-comments)(wrap-manifest)(begin-end)(utf-16)(backup)(ms-msgtbl)"
    IDS_NOSELECTION, "没有选择。"
    IDS_TRANSLATORS, "[Translators]\r\nEnglish: Katayama Hirofumi MZ\r\nFinnish: Veikko Muurikainen\r\nIndonesian: Mas Ahmad Muhammad\r\nItalian: R.B.\r\nJapanese: Katayama Hirofumi MZ\r\nKorean: VenusGirl (비너스걸)\r\nPolish: Piotr Hetnarowicz\r\nPortuguese: JNylson\r\nRussian: Dmitry Yerokhin\r\nSimplified Chinese: 林鸿湘\r\n"
}

//////////////////////////////////////////////////////////////////////////////

```

`src/lang/zh_TW.rc`:

```rc
// This file is automatically generated by RisohEditor 5.7.9.
// † <-- This dagger helps UTF-8 detection.

#pragma code_page(65001) // UTF-8

LANGUAGE LANG_CHINESE, SUBLANG_DEFAULT

//////////////////////////////////////////////////////////////////////////////
// RT_MENU

IDR_MAINMENU MENU
{
    POPUP "文件(&F)"
    {
        MENUITEM "新建(&N)\tCtrl+N", ID_NEW
        MENUITEM SEPARATOR
        MENUITEM "打開(&O)...\tCtrl+O", ID_OPEN
        MENUITEM "覆寫(&S)...\tCtrl+S", ID_SAVE
        MENUITEM "另存為(&A)...\tShift+Ctrl+S", ID_SAVEAS
        MENUITEM "另存壓縮(&M)...", ID_SAVEASCOMPRESS
        MENUITEM SEPARATOR
        MENUITEM "導入(&I)...\tCtrl+I", ID_IMPORT
        MENUITEM "導出(&E)...\tCtrl+P", ID_EXPORT
        MENUITEM SEPARATOR
        MENUITEM "重新載入 &resource.h...\tCtrl+R", ID_LOADRESH
        MENUITEM "保存 resource.h(&S)...", ID_UPDATERESHBANG
        MENUITEM "修改記錄(&V) resource.h ...", ID_ADVICERESH
        MENUITEM "卸載 resource.h (&U)", ID_UNLOADRESH
        MENUITEM SEPARATOR
        MENUITEM "載入窗口類DLL(&W)...", ID_LOADWCLIB
        MENUITEM SEPARATOR
        POPUP "最近使用的文件夾"
        {
            MENUITEM "(無)", -1, GRAYED
        }
        MENUITEM SEPARATOR
        MENUITEM "退出(&X)\tAlt+F4", ID_EXIT
    }
    POPUP "編輯(&E)"
    {
        MENUITEM "&GUI模式編輯...\tCtrl+G", ID_GUIEDIT
        MENUITEM SEPARATOR
        POPUP "添加(&A)"
        {
            MENUITEM "添加圖示(&I)...", ID_ADDICON
            MENUITEM "添加游標(&C)...", ID_ADDCURSOR
            MENUITEM "添加點陣圖(&B)...", ID_ADDBITMAP
            MENUITEM "添加對話(&D)...", ID_ADDDIALOG
            MENUITEM "添加菜單(&M)...", ID_ADDMENU
            MENUITEM "添加字串表(&S)...", ID_ADDSTRINGTABLE
            MENUITEM "添加消息表(&E)...", ID_ADDMESSAGETABLE
            MENUITEM "添加&HTML...", ID_ADDHTML
            MENUITEM "添加加速器(&A)...", ID_ADDACCEL
            MENUITEM "添加版本資訊(&V)...", ID_ADDVERINFO
            MENUITEM "添加清單(&F)...", ID_ADDMANIFEST
            MENUITEM "添加工具欄(&T)...", ID_ADDTOOLBAR
            MENUITEM "添加資源項目(&R)...", ID_ADDRES
        }
        POPUP "替換(&R)"
        {
            MENUITEM "替換圖示(&I)...", ID_REPLACEICON
            MENUITEM "替換游標(&C)...", ID_REPLACECURSOR
            MENUITEM "替換點陣圖文件(&B)...", ID_REPLACEBITMAP
            MENUITEM "替換二進位制資源項目(&R)...", ID_REPLACEBIN
        }
        POPUP "導出(&E)"
        {
            MENUITEM "導出圖示(&I)...", ID_EXTRACTICON
            MENUITEM "導出游標(&C)...", ID_EXTRACTCURSOR
            MENUITEM "導出點陣圖文件(&B)...", ID_EXTRACTBITMAP
            MENUITEM "導出 RC 文件(&A)...", ID_EXTRACTRC
            MENUITEM "導出二進位制資源文件(&R)...", ID_EXTRACTBIN
        }
        MENUITEM SEPARATOR
        MENUITEM "更改名稱/語言(&H)\tF2", ID_EDITLABEL
        MENUITEM SEPARATOR
        MENUITEM "複製為其他名稱(&N)...", ID_COPYASNEWNAME
        MENUITEM "複製為其他語言(&L)...", ID_COPYASNEWLANG
        MENUITEM "複製到多種語言...", ID_COPYTOMULTILANG
        MENUITEM SEPARATOR
        MENUITEM "效果測試(&T)", ID_TEST
        MENUITEM SEPARATOR
        MENUITEM "刪除(&D)\tDel", ID_DELETERES
        MENUITEM SEPARATOR
        MENUITEM "&ID關聯列表...", ID_IDASSOC
        MENUITEM "預定義的宏(&M)...", ID_PREDEFMACROS
        MENUITEM "字體設置(&F)...", ID_FONTS
        MENUITEM "設置PATH(&P)...", ID_SETPATHS
        MENUITEM SEPARATOR
        MENUITEM "&UI Language Select (UI語言選擇)...", ID_CHOOSEUILANG
        MENUITEM SEPARATOR
        MENUITEM "Delphi DFM 設置...", ID_DFMSETTINGS
        MENUITEM "設置(&C)...", ID_CONFIG
    }
    POPUP "搜索(&S)"
    {
        MENUITEM "查詢(&F)...\tCtrl+F", ID_FIND
        MENUITEM SEPARATOR
        MENUITEM "向上搜索(&U)\tShift+F3", ID_FINDUPWARD
        MENUITEM "向下搜索(&D)\tF3", ID_FINDDOWNWARD
        MENUITEM SEPARATOR
        MENUITEM "查詢常量(&Q)...", ID_QUERYCONSTANT
    }
    POPUP "界面顯示(&V)"
    {
        MENUITEM "狀態欄(&S)", ID_STATUSBAR
        MENUITEM "工具欄(&T)", ID_SHOWHIDETOOLBAR
        MENUITEM "二進位制模式(&B)", ID_BINARYPANE
        MENUITEM SEPARATOR
        MENUITEM "全部展開(&X)\tCtrl+K", ID_EXPAND_ALL
        MENUITEM "全部摺疊(&O)\tCtrl+L", ID_COLLAPSE_ALL
        MENUITEM SEPARATOR
        MENUITEM "資源ID列表(&R)", ID_IDLIST
        MENUITEM "語言列表(&L)...", ID_SHOWLANGS
        MENUITEM SEPARATOR
        MENUITEM "使用&CONTROL欄位", ID_ALWAYSCONTROL
        MENUITEM "不使用&ID宏定義", ID_HIDEIDMACROS
        MENUITEM "使用IDC_ST&ATIC", ID_USEIDC_STATIC
        MENUITEM "自動換行(&W)", ID_WORD_WRAP
        MENUITEM "使用BE&GIN/END", ID_USEBEGINEND
        MENUITEM "使用微軟消息表(&T)", ID_USEMSMSGTBL
        MENUITEM SEPARATOR
        MENUITEM "資源項的編碼(&E)...", ID_ENCODING
        MENUITEM "Dialog &font substitutes...", ID_DIALOG_FONT_SUBSTITUTES
        MENUITEM SEPARATOR
        MENUITEM "更新到最新資訊(&F)", ID_REFRESHALL
    }
    POPUP "自動化(&A)"
    {
        MENUITEM "電腦語言 &EGA...", ID_EGA
        MENUITEM "運行EGA程序(&R)...", ID_EGA_PROGRAM
        MENUITEM "手動 (EGA)", ID_OPEN_EGA_MANUAL
    }
    POPUP "幫助(&H)"
    {
        MENUITEM "打開英文 &README.txt", ID_OPENREADME
        MENUITEM "打開 &LICENSE.txt", ID_OPENLICENSE
        MENUITEM SEPARATOR
        MENUITEM "RisohEditor指南(&G)", ID_GUIDE
        MENUITEM "檢查 RisohEditor 更新(&U)...", ID_CHECKUPDATE
        MENUITEM SEPARATOR
        MENUITEM "關於(&A)...", ID_ABOUT
    }
}

IDR_POPUPMENUS MENU
{
    POPUP "Popup #0"
    {
        MENUITEM "&GUI模式...\tCtrl+G", ID_GUIEDIT
        MENUITEM SEPARATOR
        POPUP "添加(&A)"
        {
            MENUITEM "添加圖示(&I)...", ID_ADDICON
            MENUITEM "添加游標(&C)...", ID_ADDCURSOR
            MENUITEM "添加點陣圖(&B)...", ID_ADDBITMAP
            MENUITEM "添加對話(&D)...", ID_ADDDIALOG
            MENUITEM "添加菜單(&M)...", ID_ADDMENU
            MENUITEM "添加字串表(&S)...", ID_ADDSTRINGTABLE
            MENUITEM "添加消息表(&E)...", ID_ADDMESSAGETABLE
            MENUITEM "添加&HTML...", ID_ADDHTML
            MENUITEM "添加加速器(&A)...", ID_ADDACCEL
            MENUITEM "添加版本資訊(&V)...", ID_ADDVERINFO
            MENUITEM "添加清單(&F)...", ID_ADDMANIFEST
            MENUITEM "添加工具欄(&T)...", ID_ADDTOOLBAR
            MENUITEM "添加資源項目(&R)...", ID_ADDRES
        }
        POPUP "替換(&R)"
        {
            MENUITEM "替換圖示(&I)...", ID_REPLACEICON
            MENUITEM "替換游標(&C)...", ID_REPLACECURSOR
            MENUITEM "替換點陣圖文件(&B)...", ID_REPLACEBITMAP
            MENUITEM "替換二進位制資源項目(&R)...", ID_REPLACEBIN
        }
        POPUP "導出(&E)"
        {
            MENUITEM "導出圖示(&I)...", ID_EXTRACTICON
            MENUITEM "導出游標(&C)...", ID_EXTRACTCURSOR
            MENUITEM "導出點陣圖文件(&B)...", ID_EXTRACTBITMAP
            MENUITEM "導出 RC 文件(&A)...", ID_EXTRACTRC
            MENUITEM "導出二進位制資源文件(&R)...", ID_EXTRACTBIN
        }
        MENUITEM SEPARATOR
        MENUITEM "更改名稱/語言(&H)\tF2", ID_EDITLABEL
        MENUITEM SEPARATOR
        MENUITEM "複製為其他名稱(&N)...", ID_COPYASNEWNAME
        MENUITEM "複製為其他語言(&L)...", ID_COPYASNEWLANG
        MENUITEM "複製到多種語言...", ID_COPYTOMULTILANG
        MENUITEM SEPARATOR
        MENUITEM "效果測試(&T)", ID_TEST
        MENUITEM SEPARATOR
        MENUITEM "刪除(&D)\tDel", ID_DELETERES
    }
    POPUP "Popup #1"
    {
        MENUITEM "增加控制項(&A)...", ID_ADDCTRL
        MENUITEM SEPARATOR
        MENUITEM "剪切(&T)\tCtrl+X", ID_CUT
        MENUITEM "複製(&C)\tCtrl+C", ID_COPY
        MENUITEM "黏貼(&P)\tCtrl+V", ID_PASTE
        MENUITEM "刪除(&D)\tDel", ID_DELCTRL
        MENUITEM SEPARATOR
        POPUP "索引位置(&I)"
        {
            MENUITEM "置頂(&T)", ID_CTRLINDEXTOP
            MENUITEM SEPARATOR
            MENUITEM "減1(&D)", ID_CTRLINDEXMINUS
            MENUITEM "增1(&I)", ID_CTRLINDEXPLUS
            MENUITEM SEPARATOR
            MENUITEM "置底(&B)", ID_CTRLINDEXBOTTOM
            MENUITEM SEPARATOR
            MENUITEM "切換顯示模式(&S)\tCtrl+D", ID_SHOWHIDEINDEX
        }
        POPUP "排列方式(&A)"
        {
            MENUITEM "向上對齊(&T)", ID_TOPALIGN
            MENUITEM "向下對齊(&B)", ID_BOTTOMALIGN
            MENUITEM "左對齊(&L)", ID_LEFTALIGN
            MENUITEM "右對齊(&R)", ID_RIGHTALIGN
            MENUITEM SEPARATOR
            MENUITEM "適應網格(&G)", ID_FITTOGRID
        }
        MENUITEM SEPARATOR
        MENUITEM "刷新(&R)", ID_REFRESHDIALOG
        MENUITEM SEPARATOR
        MENUITEM "控制項屬性(&P)...", ID_CTRLPROP
        MENUITEM "對話框屬性(&O)...", ID_DLGPROP
    }
    POPUP "Popup #2"
    {
        MENUITEM "修改(&M)...", ID_MODIFYASSOC
    }
    POPUP "Popup #3"
    {
        MENUITEM "跳轉(&J)!", ID_IDJUMP
        MENUITEM SEPARATOR
        MENUITEM "增加ID(&A)...", ID_ADDRESID
        MENUITEM "修改ID(&M)...", ID_MODIFYRESID
        MENUITEM SEPARATOR
        MENUITEM "複製名稱(&N)", ID_COPYRESIDNAME
        MENUITEM "複製值(&V)", ID_COPYRESIDVALUE
        MENUITEM "複制定義(&D)\tCtrl+C", ID_COPYIDDEF
        MENUITEM SEPARATOR
        MENUITEM "刪除ID(&D) \tDel", ID_DELETERESID
        MENUITEM SEPARATOR
        MENUITEM "十進位制數位(&D)", ID_BASE10
        MENUITEM "十六進位制數位(&H)", ID_BASE16
        MENUITEM SEPARATOR
        MENUITEM "重新載入(&R)", ID_LOADRESH
    }
    POPUP "Popup #4"
    {
        MENUITEM "增加(&A)...", ID_ADD
        MENUITEM SEPARATOR
        MENUITEM "名稱修改(&N)...\tF2", ID_RENAME
        MENUITEM "值修改(&V)...", ID_MODIFY
        MENUITEM SEPARATOR
        MENUITEM "刪除(&D)\tDel", ID_DELETE
    }
    POPUP "Popup #5"
    {
        MENUITEM "複製整數值(&C)", ID_COPY
    }
    POPUP "Popup #6"
    {
        MENUITEM "添加(&A)...", psh1
        MENUITEM "修改(&M)...", psh2
        MENUITEM SEPARATOR
        MENUITEM "上(&U)", psh4
        MENUITEM "下(&D)", psh5
        MENUITEM "左(&L)", psh6
        MENUITEM "右(&R)", psh7
        MENUITEM SEPARATOR
        MENUITEM "刪除(&T)\tDel", psh3
    }
    POPUP "Popup #7"
    {
        MENUITEM "添加(&A)...", psh1
        MENUITEM "修改(&M)...", psh2
        MENUITEM SEPARATOR
        MENUITEM "上(&U)", psh4
        MENUITEM "下(&D)", psh5
        MENUITEM SEPARATOR
        MENUITEM "刪除(&T)\tDel", psh3
    }
    POPUP "Popup #8"
    {
        MENUITEM "添加(&A)...", ID_ADD
        MENUITEM "修改(&M)...", ID_MODIFY
        MENUITEM SEPARATOR
        MENUITEM "刪除(&T)\tDel", ID_DELETE
    }
}

//////////////////////////////////////////////////////////////////////////////
// RT_DIALOG

IDD_REPLACERES DIALOGEX 0, 0, 215, 170
CAPTION "替換資源"
STYLE DS_MODALFRAME | WS_POPUPWINDOW | WS_CAPTION
FONT 9, "宋體", 0, 0, 1
{
    LTEXT "資源類型(&T):", -1, 5, 7, 70, 12
    COMBOBOX cmb1, 75, 5, 135, 200, CBS_HASSTRINGS | CBS_AUTOHSCROLL | CBS_DROPDOWN | WS_BORDER | WS_VSCROLL | WS_TABSTOP
    LTEXT "資源名稱(&N):", -1, 5, 32, 70, 12
    COMBOBOX cmb2, 75, 30, 135, 200, CBS_HASSTRINGS | CBS_AUTOHSCROLL | CBS_DROPDOWN | WS_DISABLED | WS_BORDER | WS_VSCROLL | WS_TABSTOP
    LTEXT "資源語言(&L):", -1, 5, 57, 70, 12
    COMBOBOX cmb3, 75, 55, 135, 200, CBS_HASSTRINGS | CBS_AUTOHSCROLL | CBS_DROPDOWN | WS_DISABLED | WS_BORDER | WS_VSCROLL | WS_TABSTOP
    LTEXT "二進位制文件(&F):", -1, 5, 85, 100, 12
    EDITTEXT edt1, 5, 97, 205, 14, ES_AUTOHSCROLL
    PUSHBUTTON "瀏覽(&B)...", psh1, 150, 115, 60, 14
    DEFPUSHBUTTON "OK", IDOK, 35, 150, 60, 14
    PUSHBUTTON "取消", IDCANCEL, 115, 150, 60, 14
    {
        0x1234, 0x5678, 0x0011
    }
}

IDD_ADDICON DIALOG 0, 0, 215, 135
CAPTION "添加圖示"
STYLE DS_MODALFRAME | WS_POPUPWINDOW | WS_CAPTION
FONT 9, "宋體"
{
    LTEXT "圖示文件(&I):", -1, 5, 7, 100, 12
    EDITTEXT edt1, 5, 18, 205, 14, ES_AUTOHSCROLL
    PUSHBUTTON "瀏覽(&B)...", psh1, 150, 35, 60, 14
    ICON 0, ico1, 5, 35, 0, 0
    LTEXT "資源名稱(&N):", -1, 5, 67, 70, 12
    COMBOBOX cmb2, 75, 65, 120, 300, CBS_HASSTRINGS | CBS_AUTOHSCROLL | CBS_DROPDOWN | WS_BORDER | WS_VSCROLL | WS_TABSTOP
    PUSHBUTTON "&...", psh2, 195, 65, 15, 14
    LTEXT "資源語言(&L):", -1, 5, 92, 70, 12
    COMBOBOX cmb3, 75, 90, 135, 200, CBS_HASSTRINGS | CBS_AUTOHSCROLL | CBS_DROPDOWN | WS_BORDER | WS_VSCROLL | WS_TABSTOP
    DEFPUSHBUTTON "OK", IDOK, 35, 115, 60, 14
    PUSHBUTTON "取消", IDCANCEL, 115, 115, 60, 14
}

IDD_REPLACEICON DIALOG 0, 0, 215, 135
CAPTION "替換圖示"
STYLE DS_MODALFRAME | WS_POPUPWINDOW | WS_CAPTION
FONT 9, "宋體"
{
    LTEXT "圖示文件(&I):", -1, 5, 7, 100, 12
    EDITTEXT edt1, 5, 18, 205, 14, ES_AUTOHSCROLL
    PUSHBUTTON "瀏覽(&B)...", psh1, 150, 35, 60, 14
    ICON 0, ico1, 5, 35, 0, 0
    LTEXT "資源名稱(&N):", -1, 5, 67, 70, 12
    COMBOBOX cmb2, 75, 65, 135, 13, CBS_HASSTRINGS | CBS_AUTOHSCROLL | CBS_DROPDOWN | WS_DISABLED | WS_BORDER | WS_VSCROLL | WS_TABSTOP
    LTEXT "資源語言(&L):", -1, 5, 92, 70, 12
    COMBOBOX cmb3, 75, 90, 135, 13, CBS_HASSTRINGS | CBS_AUTOHSCROLL | CBS_DROPDOWN | WS_DISABLED | WS_BORDER | WS_VSCROLL | WS_TABSTOP
    DEFPUSHBUTTON "OK", IDOK, 35, 115, 60, 14
    PUSHBUTTON "取消", IDCANCEL, 115, 115, 60, 14
}

IDD_ADDBITMAP DIALOG 0, 0, 215, 135
CAPTION "替換點陣圖"
STYLE DS_MODALFRAME | WS_POPUPWINDOW | WS_CAPTION
FONT 9, "宋體"
{
    LTEXT "點陣圖文件(&B):", -1, 5, 7, 100, 12
    EDITTEXT edt1, 5, 18, 205, 14, ES_AUTOHSCROLL
    PUSHBUTTON "瀏覽(&B)...", psh1, 150, 35, 60, 14
    LTEXT "資源名稱(&N):", -1, 5, 67, 70, 12
    COMBOBOX cmb2, 75, 65, 135, 200, CBS_HASSTRINGS | CBS_AUTOHSCROLL | CBS_DROPDOWN | WS_DISABLED | WS_BORDER | WS_VSCROLL | WS_TABSTOP
    LTEXT "資源語言(&L):", -1, 5, 92, 70, 12
    COMBOBOX cmb3, 75, 90, 135, 200, CBS_HASSTRINGS | CBS_AUTOHSCROLL | CBS_DROPDOWN | WS_DISABLED | WS_BORDER | WS_VSCROLL | WS_TABSTOP
    DEFPUSHBUTTON "OK", IDOK, 35, 115, 60, 14
    PUSHBUTTON "取消", IDCANCEL, 115, 115, 60, 14
}

IDD_REPLACEBMP DIALOG 0, 0, 215, 135
CAPTION "替換點陣圖"
STYLE DS_MODALFRAME | WS_POPUPWINDOW | WS_CAPTION
FONT 9, "宋體"
{
    LTEXT "點陣圖文件(&B):", -1, 5, 7, 100, 12
    EDITTEXT edt1, 5, 18, 205, 14, ES_AUTOHSCROLL
    PUSHBUTTON "瀏覽(&B)...", psh1, 150, 35, 60, 14
    LTEXT "資源名稱(&N):", -1, 5, 67, 70, 12
    COMBOBOX cmb2, 75, 65, 135, 200, CBS_HASSTRINGS | CBS_AUTOHSCROLL | CBS_DROPDOWN | WS_DISABLED | WS_BORDER | WS_VSCROLL | WS_TABSTOP
    LTEXT "資源語言(&L):", -1, 5, 92, 70, 12
    COMBOBOX cmb3, 75, 90, 135, 200, CBS_HASSTRINGS | CBS_AUTOHSCROLL | CBS_DROPDOWN | WS_DISABLED | WS_BORDER | WS_VSCROLL | WS_TABSTOP
    DEFPUSHBUTTON "OK", IDOK, 35, 115, 60, 14
    PUSHBUTTON "取消", IDCANCEL, 115, 115, 60, 14
}

IDD_ADDRES DIALOG 0, 0, 215, 170
CAPTION "添加資源"
STYLE DS_MODALFRAME | WS_POPUPWINDOW | WS_CAPTION
FONT 9, "宋體"
{
    LTEXT "資源類型(&T):", -1, 5, 7, 70, 12
    COMBOBOX cmb1, 75, 5, 135, 200, CBS_HASSTRINGS | CBS_AUTOHSCROLL | CBS_DROPDOWN | WS_BORDER | WS_VSCROLL | WS_TABSTOP
    LTEXT "資源名稱(&N):", -1, 5, 32, 70, 12
    COMBOBOX cmb2, 75, 30, 120, 300, CBS_HASSTRINGS | CBS_AUTOHSCROLL | CBS_DROPDOWN | WS_BORDER | WS_VSCROLL | WS_TABSTOP
    PUSHBUTTON "&...", psh2, 195, 30, 15, 14
    LTEXT "", stc1, 75, 43, 115, 10
    LTEXT "資源語言(&L):", -1, 5, 57, 70, 12
    COMBOBOX cmb3, 75, 55, 135, 200, CBS_HASSTRINGS | CBS_AUTOHSCROLL | CBS_DROPDOWN | WS_BORDER | WS_VSCROLL | WS_TABSTOP
    LTEXT "二進位制文件(&F):", -1, 5, 85, 100, 12
    EDITTEXT edt1, 5, 97, 205, 14, ES_AUTOHSCROLL
    PUSHBUTTON "瀏覽(&B)...", psh1, 150, 115, 60, 14
    LTEXT "", stc2, 5, 112, 100, 10
    DEFPUSHBUTTON "OK", IDOK, 35, 150, 60, 14
    PUSHBUTTON "取消", IDCANCEL, 115, 150, 60, 14
}

IDD_ADDCURSOR DIALOG 0, 0, 215, 135
CAPTION "添加游標"
STYLE DS_MODALFRAME | WS_POPUPWINDOW | WS_CAPTION
FONT 9, "宋體"
{
    LTEXT "游標文件(&C):", -1, 5, 7, 100, 12
    EDITTEXT edt1, 5, 18, 205, 14, ES_AUTOHSCROLL
    PUSHBUTTON "瀏覽(&B)...", psh1, 150, 35, 60, 14
    ICON 0, ico1, 5, 35, 0, 0
    LTEXT "資源名稱(&N)：", -1, 5, 67, 70, 12
    COMBOBOX cmb2, 75, 65, 120, 200, CBS_HASSTRINGS | CBS_AUTOHSCROLL | CBS_DROPDOWN | WS_BORDER | WS_VSCROLL | WS_TABSTOP
    PUSHBUTTON "&...", psh2, 195, 65, 15, 14
    LTEXT "資源語言(&L):", -1, 5, 92, 70, 12
    COMBOBOX cmb3, 75, 90, 135, 200, CBS_HASSTRINGS | CBS_AUTOHSCROLL | CBS_DROPDOWN | WS_BORDER | WS_VSCROLL | WS_TABSTOP
    DEFPUSHBUTTON "OK", IDOK, 35, 115, 60, 14
    PUSHBUTTON "取消", IDCANCEL, 115, 115, 60, 14
}

IDD_REPLACECUR DIALOG 0, 0, 215, 135
CAPTION "替換游標"
STYLE DS_MODALFRAME | WS_POPUPWINDOW | WS_CAPTION
FONT 9, "宋體"
{
    LTEXT "游標文件(&C):", -1, 5, 7, 100, 12
    EDITTEXT edt1, 5, 18, 205, 14, ES_AUTOHSCROLL
    PUSHBUTTON "瀏覽(&B)...", psh1, 150, 35, 60, 14
    ICON 0, ico1, 5, 35, 0, 0
    LTEXT "資源名稱(&N):", -1, 5, 67, 70, 12
    COMBOBOX cmb2, 75, 65, 135, 200, CBS_HASSTRINGS | CBS_AUTOHSCROLL | CBS_DROPDOWN | WS_DISABLED | WS_BORDER | WS_VSCROLL | WS_TABSTOP
    LTEXT "資源語言(&L):", -1, 5, 92, 70, 12
    COMBOBOX cmb3, 75, 90, 135, 200, CBS_HASSTRINGS | CBS_AUTOHSCROLL | CBS_DROPDOWN | WS_DISABLED | WS_BORDER | WS_VSCROLL | WS_TABSTOP
    DEFPUSHBUTTON "OK", IDOK, 35, 115, 60, 14
    PUSHBUTTON "取消", IDCANCEL, 115, 115, 60, 14
}

IDD_MENUTEST DIALOG 0, 0, 215, 135
CAPTION "菜單測試"
STYLE DS_MODALFRAME | WS_POPUPWINDOW | WS_CAPTION
FONT 9, "宋體"
{
}

IDD_ADDKEY DIALOG 0, 0, 190, 120
CAPTION "添加鍵"
STYLE DS_MODALFRAME | WS_POPUPWINDOW | WS_CAPTION
FONT 9, "宋體"
{
    RTEXT "鍵(&K):", -1, 5, 12, 60, 14
    COMBOBOX cmb1, 70, 10, 110, 200, CBS_DROPDOWN | WS_BORDER | WS_VSCROLL | WS_TABSTOP
    RTEXT "命令 &ID:", -1, 5, 37, 60, 14
    COMBOBOX cmb2, 70, 35, 95, 300, CBS_DROPDOWN | WS_BORDER | WS_VSCROLL | WS_TABSTOP
    PUSHBUTTON "&...", psh1, 165, 35, 15, 14
    AUTOCHECKBOX "&VIRTKEY", chx1, 5, 60, 60, 14
    AUTOCHECKBOX "&NOINVERT", chx2, 70, 60, 60, 14
    AUTOCHECKBOX "&CONTROL", chx3, 5, 75, 60, 14
    AUTOCHECKBOX "&SHIFT", chx4, 70, 75, 60, 14
    AUTOCHECKBOX "&ALT", chx5, 140, 75, 45, 14
    DEFPUSHBUTTON "OK", IDOK, 60, 100, 60, 14
    PUSHBUTTON "取消", IDCANCEL, 125, 100, 60, 14
}

IDD_MODIFYKEY DIALOG 0, 0, 190, 120
CAPTION "修改鍵"
STYLE DS_MODALFRAME | WS_POPUPWINDOW | WS_CAPTION
FONT 9, "宋體"
{
    RTEXT "鍵(&K):", -1, 5, 12, 60, 14
    COMBOBOX cmb1, 70, 10, 110, 200, CBS_DROPDOWN | WS_BORDER | WS_VSCROLL | WS_TABSTOP
    RTEXT "命令 &ID:", -1, 5, 37, 60, 14
    COMBOBOX cmb2, 70, 35, 95, 200, CBS_DROPDOWN | WS_BORDER | WS_VSCROLL | WS_TABSTOP
    PUSHBUTTON "&...", psh1, 165, 35, 15, 14
    AUTOCHECKBOX "&VIRTKEY", chx1, 5, 60, 60, 14
    AUTOCHECKBOX "&NOINVERT", chx2, 70, 60, 60, 14
    AUTOCHECKBOX "&CONTROL", chx3, 5, 75, 60, 14
    AUTOCHECKBOX "&SHIFT", chx4, 70, 75, 60, 14
    AUTOCHECKBOX "&ALT", chx5, 140, 75, 45, 14
    DEFPUSHBUTTON "OK", IDOK, 60, 100, 60, 14
    PUSHBUTTON "取消", IDCANCEL, 125, 100, 60, 14
}

IDD_EDITACCEL DIALOG 0, 0, 285, 165
CAPTION "編輯快捷鍵"
STYLE WS_POPUPWINDOW | WS_CAPTION | WS_THICKFRAME
FONT 9, "宋體"
{
    LTEXT "鍵列表(&K):", -1, 5, 7, 100, 12
    CONTROL "", lst1, "SysListView32", LVS_NOSORTHEADER | LVS_AUTOARRANGE | LVS_NOLABELWRAP | LVS_SHOWSELALWAYS | LVS_SINGLESEL | LVS_REPORT | WS_BORDER | WS_VSCROLL | WS_HSCROLL | WS_TABSTOP, 5, 20, 210, 120
    PUSHBUTTON "添加(&A)...", psh1, 220, 20, 60, 14
    PUSHBUTTON "修改(&M)...", psh2, 220, 40, 60, 14
    PUSHBUTTON "刪除(&D)", psh3, 220, 60, 60, 14
    PUSHBUTTON "上(&U)", psh4, 220, 100, 60, 14
    PUSHBUTTON "下(&O)", psh5, 220, 120, 60, 14
    DEFPUSHBUTTON "OK", IDOK, 155, 145, 60, 14
    PUSHBUTTON "取消", IDCANCEL, 220, 145, 60, 14
    PUSHBUTTON "刪除所有(&L)", psh6, 5, 145, 79, 14
}

IDD_ADDSTR DIALOG 0, 0, 255, 115
CAPTION "添加字串項"
STYLE WS_POPUPWINDOW | WS_CAPTION | WS_THICKFRAME
FONT 9, "宋體"
{
    LTEXT "字串 &ID:", -1, 5, 7, 50, 12
    COMBOBOX cmb1, 60, 5, 134, 200, CBS_HASSTRINGS | CBS_AUTOHSCROLL | CBS_DROPDOWN | WS_BORDER | WS_VSCROLL | WS_TABSTOP
    PUSHBUTTON "&...", psh1, 195, 5, 15, 14
    LTEXT "字串值(&V):", -1, 5, 27, 54, 12
    EDITTEXT edt1, 60, 25, 190, 45, ES_WANTRETURN | ES_AUTOVSCROLL | ES_MULTILINE | WS_VSCROLL
    AUTOCHECKBOX "用 ""\\n"" 替換 ""\\r\\n""(&R)", chx1, 60, 75, 190, 14
    DEFPUSHBUTTON "OK", IDOK, 125, 95, 60, 14
    PUSHBUTTON "取消", IDCANCEL, 190, 95, 60, 14
}

IDD_MODIFYSTR DIALOG 0, 0, 255, 115
CAPTION "修改字串項"
STYLE WS_POPUPWINDOW | WS_CAPTION | WS_THICKFRAME
FONT 9, "宋體"
{
    LTEXT "字串 &ID:", -1, 5, 7, 50, 12
    COMBOBOX cmb1, 60, 5, 134, 200, CBS_HASSTRINGS | CBS_AUTOHSCROLL | CBS_DROPDOWN | WS_BORDER | WS_VSCROLL | WS_TABSTOP
    PUSHBUTTON "&...", psh1, 195, 5, 15, 14
    LTEXT "字串值(&V):", -1, 5, 27, 54, 12
    EDITTEXT edt1, 60, 25, 190, 45, ES_WANTRETURN | ES_AUTOVSCROLL | ES_MULTILINE | WS_VSCROLL
    AUTOCHECKBOX "用 ""\\n"" 替換 ""\\r\\n""(&R)", chx1, 60, 75, 190, 14
    DEFPUSHBUTTON "OK", IDOK, 125, 95, 60, 14
    PUSHBUTTON "取消", IDCANCEL, 190, 95, 60, 14
}

IDD_STRINGS DIALOG 0, 0, 325, 160
CAPTION "字串表"
STYLE WS_POPUPWINDOW | WS_CAPTION | WS_THICKFRAME
FONT 9, "宋體"
{
    LTEXT "字串的條目(&E):", -1, 5, 7, 100, 12
    CONTROL "", lst1, "SysListView32", LVS_NOSORTHEADER | LVS_AUTOARRANGE | LVS_NOLABELWRAP | LVS_SHOWSELALWAYS | LVS_SINGLESEL | LVS_REPORT | WS_BORDER | WS_VSCROLL | WS_HSCROLL | WS_TABSTOP, 5, 20, 315, 115
    PUSHBUTTON "添加(&A)...", psh1, 130, 3, 60, 14
    PUSHBUTTON "修改(&M)...", psh2, 195, 3, 60, 14
    PUSHBUTTON "刪除(&D)", psh3, 260, 3, 60, 14
    DEFPUSHBUTTON "OK", IDOK, 195, 140, 60, 14
    PUSHBUTTON "取消", IDCANCEL, 260, 140, 60, 14
    PUSHBUTTON "刪除所有(&L)", psh4, 5, 140, 75, 14
}

IDD_ADDMITEM DIALOG 0, 0, 210, 200
CAPTION "增加選單欄"
STYLE DS_MODALFRAME | WS_POPUPWINDOW | WS_CAPTION
FONT 9, "宋體"
{
    LTEXT "標題(&A):", -1, 5, 7, 55, 12
    COMBOBOX cmb1, 65, 6, 140, 200, CBS_AUTOHSCROLL | CBS_DROPDOWN | WS_BORDER | WS_VSCROLL | WS_TABSTOP
    LTEXT "命令(&M) ID:", -1, 5, 32, 55, 12
    COMBOBOX cmb2, 65, 30, 125, 200, CBS_AUTOHSCROLL | CBS_DROPDOWN | WS_BORDER | WS_VSCROLL | WS_TABSTOP
    PUSHBUTTON "&...", psh1, 190, 30, 15, 14
    AUTOCHECKBOX "呈灰(&G)", chx1, 5, 60, 60, 14
    AUTOCHECKBOX "點陣圖(&B)", chx3, 135, 60, 60, 14
    AUTOCHECKBOX "&OWNERDRAW", chx4, 5, 80, 65, 14
    AUTOCHECKBOX "勾擇(&C)", chx5, 75, 80, 60, 14
    AUTOCHECKBOX "分離(&P)", chx6, 140, 80, 60, 14
    AUTOCHECKBOX "菜單&BARBREAK", chx7, 5, 100, 75, 14
    AUTOCHECKBOX "菜單B&REAK", chx8, 85, 100, 70, 14
    AUTOCHECKBOX "設置(&D)", chx9, 5, 120, 60, 14
    AUTOCHECKBOX "標亮(&H)", chx10, 70, 120, 60, 14
    AUTOCHECKBOX "單選按鈕選擇(&K)", chx11, 135, 120, 60, 14
    AUTOCHECKBOX "RIGH&TORDER", chx12, 5, 139, 60, 14
    AUTOCHECKBOX "RIGHT&JUSTIFY", chx13, 70, 140, 70, 14
    LTEXT "幫助 ID(&L):", -1, 5, 162, 45, 12
    COMBOBOX cmb3, 55, 160, 100, 300, CBS_AUTOHSCROLL | CBS_DROPDOWN | WS_BORDER | WS_VSCROLL | WS_TABSTOP
    DEFPUSHBUTTON "OK", IDOK, 80, 180, 60, 14
    PUSHBUTTON "取消", IDCANCEL, 145, 180, 60, 14
}

IDD_MODIFYMITEM DIALOG 0, 0, 210, 200
CAPTION "修改選單欄"
STYLE DS_MODALFRAME | WS_POPUPWINDOW | WS_CAPTION
FONT 9, "宋體"
{
    LTEXT "標題(&A):", -1, 5, 7, 55, 12
    COMBOBOX cmb1, 65, 6, 140, 200, CBS_AUTOHSCROLL | CBS_DROPDOWN | WS_BORDER | WS_VSCROLL | WS_TABSTOP
    LTEXT "命令(&M) ID:", -1, 5, 32, 55, 12
    COMBOBOX cmb2, 65, 30, 125, 200, CBS_AUTOHSCROLL | CBS_DROPDOWN | WS_BORDER | WS_VSCROLL | WS_TABSTOP
    PUSHBUTTON "&...", psh1, 190, 30, 15, 14
    AUTOCHECKBOX "呈灰(&G)", chx1, 5, 60, 60, 14
    AUTOCHECKBOX "點陣圖(&B)", chx3, 135, 60, 60, 14
    AUTOCHECKBOX "&OWNERDRAW", chx4, 5, 80, 65, 14
    AUTOCHECKBOX "勾擇(&C)", chx5, 75, 80, 60, 14
    AUTOCHECKBOX "分離(&P)", chx6, 140, 80, 60, 14
    AUTOCHECKBOX "菜單&BARBREAK", chx7, 5, 100, 75, 14
    AUTOCHECKBOX "菜單B&REAK", chx8, 85, 100, 70, 14
    AUTOCHECKBOX "設置(&D)", chx9, 5, 120, 60, 14
    AUTOCHECKBOX "標亮(&H)", chx10, 70, 120, 60, 14
    AUTOCHECKBOX "單選按鈕選擇(&K)", chx11, 135, 120, 60, 14
    AUTOCHECKBOX "RIGH&TORDER", chx12, 5, 139, 60, 14
    AUTOCHECKBOX "RIGHT&JUSTIFY", chx13, 70, 140, 70, 14
    LTEXT "幫助 ID(&L):", -1, 5, 162, 45, 12
    COMBOBOX cmb3, 55, 160, 100, 300, CBS_AUTOHSCROLL | CBS_DROPDOWN | WS_BORDER | WS_VSCROLL | WS_TABSTOP
    DEFPUSHBUTTON "OK", IDOK, 80, 180, 60, 14
    PUSHBUTTON "取消", IDCANCEL, 145, 180, 60, 14
}

IDD_EDITMENU DIALOG 0, 0, 325, 160
CAPTION "編輯菜單資源"
STYLE WS_POPUPWINDOW | WS_CAPTION | WS_THICKFRAME
FONT 9, "宋體"
{
    LTEXT "菜單資源(&S):", -1, 5, 7, 85, 12
    CONTROL "", lst1, "SysListView32", LVS_NOSORTHEADER | LVS_AUTOARRANGE | LVS_NOLABELWRAP | LVS_SHOWSELALWAYS | LVS_SINGLESEL | LVS_REPORT | WS_BORDER | WS_VSCROLL | WS_HSCROLL | WS_TABSTOP, 5, 20, 315, 115
    PUSHBUTTON "添加(&A)...", psh1, 95, 3, 50, 14
    PUSHBUTTON "修改(&M)...", psh2, 150, 3, 50, 14
    PUSHBUTTON "刪除(&T)", psh3, 205, 3, 50, 14
    PUSHBUTTON "上(&U)", psh4, 5, 140, 40, 14
    PUSHBUTTON "下(&D)", psh5, 50, 140, 40, 14
    PUSHBUTTON "左(&L)", psh6, 95, 140, 40, 14
    PUSHBUTTON "右(&R)", psh7, 140, 140, 41, 14
    AUTOCHECKBOX "擴展(&X)", chx1, 260, 3, 60, 14
    DEFPUSHBUTTON "OK", IDOK, 195, 140, 60, 14
    PUSHBUTTON "取消", IDCANCEL, 260, 140, 60, 14
}

IDD_DLGPROP DIALOG 0, 0, 235, 315
CAPTION "對話框屬性"
STYLE DS_MODALFRAME | WS_POPUPWINDOW | WS_CAPTION
FONT 9, "宋體"
{
    LTEXT "標題(&A):", -1, 5, 7, 85, 11
    COMBOBOX cmb1, 5, 20, 225, 300, CBS_HASSTRINGS | CBS_AUTOHSCROLL | CBS_DROPDOWN | WS_BORDER | WS_VSCROLL | WS_TABSTOP
    AUTOCHECKBOX "擴展類型(&X)", chx1, 100, 5, 86, 14
    LTEXT "左(&L):", -1, 5, 40, 33, 10
    EDITTEXT edt1, 5, 53, 30, 14, ES_NUMBER | ES_RIGHT
    CONTROL "", scr1, "msctls_updown32", UDS_NOTHOUSANDS | UDS_ARROWKEYS | UDS_AUTOBUDDY | UDS_ALIGNRIGHT | UDS_SETBUDDYINT, 23, 53, 12, 20
    LTEXT "上(&U):", -1, 50, 40, 33, 10
    EDITTEXT edt2, 50, 53, 30, 14, ES_NUMBER | ES_RIGHT
    CONTROL "", scr2, "msctls_updown32", UDS_NOTHOUSANDS | UDS_ARROWKEYS | UDS_AUTOBUDDY | UDS_ALIGNRIGHT | UDS_SETBUDDYINT, 53, 53, 12, 20
    LTEXT "寬度(&W):", -1, 95, 40, 33, 10
    EDITTEXT edt3, 95, 53, 30, 14, ES_NUMBER | ES_RIGHT
    CONTROL "", scr3, "msctls_updown32", UDS_NOTHOUSANDS | UDS_ARROWKEYS | UDS_AUTOBUDDY | UDS_ALIGNRIGHT | UDS_SETBUDDYINT, 129, 56, 12, 20
    LTEXT "高度(&H):", -1, 142, 40, 33, 10
    EDITTEXT edt4, 142, 53, 30, 14, ES_NUMBER | ES_RIGHT
    CONTROL "", scr4, "msctls_updown32", UDS_NOTHOUSANDS | UDS_ARROWKEYS | UDS_AUTOBUDDY | UDS_ALIGNRIGHT | UDS_SETBUDDYINT, 162, 53, 12, 20
    LTEXT "類名(&S):", -1, 5, 73, 85, 11
    COMBOBOX cmb2, 5, 88, 115, 200, CBS_HASSTRINGS | CBS_AUTOHSCROLL | CBS_DROPDOWN | WS_BORDER | WS_VSCROLL | WS_TABSTOP
    LTEXT "幫助 ID(&P):", -1, 125, 73, 64, 11
    COMBOBOX cmb3, 125, 88, 65, 200, CBS_HASSTRINGS | CBS_AUTOHSCROLL | CBS_DROPDOWN | WS_BORDER | WS_VSCROLL | WS_TABSTOP
    LTEXT "文字樣式(&F):", -1, 5, 105, 80, 11
    COMBOBOX cmb4, 6, 118, 100, 200, CBS_HASSTRINGS | CBS_SORT | CBS_AUTOHSCROLL | CBS_DROPDOWN | WS_BORDER | WS_VSCROLL | WS_TABSTOP
    LTEXT "大小(&Z):", -1, 110, 105, 38, 12
    EDITTEXT edt5, 110, 118, 25, 14, ES_NUMBER
    AUTOCHECKBOX "&B", chx2, 140, 118, 20, 14
    AUTOCHECKBOX "&I", chx3, 165, 118, 20, 14
    LTEXT "字體類型(&R):", -1, 5, 138, 80, 11
    COMBOBOX cmb5, 5, 148, 100, 100, CBS_AUTOHSCROLL | CBS_DROPDOWNLIST | WS_VSCROLL | WS_TABSTOP
    LTEXT "菜單名稱(&M):", -1, 110, 138, 55, 11
    COMBOBOX cmb6, 110, 148, 99, 300, CBS_HASSTRINGS | CBS_AUTOHSCROLL | CBS_DROPDOWN | WS_BORDER | WS_VSCROLL | WS_TABSTOP
    LTEXT "樣式(&T):", -1, 5, 168, 45, 11
    RTEXT "0x", -1, 52, 169, 10, 11
    EDITTEXT edt6, 67, 165, 45, 14, ES_AUTOHSCROLL
    LISTBOX lst1, 5, 183, 110, 110, LBS_DISABLENOSCROLL | LBS_NOINTEGRALHEIGHT | LBS_HASSTRINGS | LBS_MULTIPLESEL | WS_VSCROLL | WS_HSCROLL | WS_TABSTOP
    LTEXT "擴展類型(&E)", -1, 120, 168, 48, 11
    RTEXT "0x", -1, 170, 169, 10, 11
    EDITTEXT edt7, 185, 165, 45, 14, ES_AUTOHSCROLL
    LISTBOX lst2, 120, 183, 110, 110, LBS_DISABLENOSCROLL | LBS_NOINTEGRALHEIGHT | LBS_HASSTRINGS | LBS_MULTIPLESEL | WS_VSCROLL | WS_HSCROLL | WS_TABSTOP
    DEFPUSHBUTTON "OK", IDOK, 106, 298, 60, 14
    PUSHBUTTON "取消", IDCANCEL, 171, 298, 60, 14
}

IDD_CTRLPROP DIALOG 0, 0, 235, 330
CAPTION "控制項屬性"
STYLE DS_MODALFRAME | WS_POPUPWINDOW | WS_CAPTION
FONT 9, "宋體"
{
    LTEXT "定義&Ctrl:", -1, 5, 7, 68, 12
    COMBOBOX cmb1, 75, 5, 120, 55, CBS_HASSTRINGS | CBS_AUTOHSCROLL | CBS_DROPDOWN | WS_BORDER | WS_VSCROLL | WS_TABSTOP
    CONTROL "", ctl1, "ToolbarWindow32", TBSTYLE_FLAT | TBSTYLE_WRAPABLE | TBSTYLE_TOOLTIPS | CCS_NODIVIDER | CCS_NORESIZE, 5, 22, 185, 30
    LTEXT "標題(&A):", -1, 5, 55, 75, 12
    COMBOBOX cmb2, 5, 65, 195, 300, CBS_HASSTRINGS | CBS_AUTOHSCROLL | CBS_DROPDOWN | WS_BORDER | WS_VSCROLL | WS_TABSTOP
    PUSHBUTTON "&OLE...", psh2, 205, 65, 25, 14
    LTEXT "左(&L):", -1, 5, 85, 33, 11
    EDITTEXT edt1, 5, 99, 25, 14, ES_NUMBER | ES_RIGHT
    CONTROL "", scr1, "msctls_updown32", UDS_NOTHOUSANDS | UDS_ARROWKEYS | UDS_AUTOBUDDY | UDS_ALIGNRIGHT | UDS_SETBUDDYINT, 20, 99, 12, 20
    LTEXT "上(&U):", -1, 40, 85, 33, 11
    EDITTEXT edt2, 40, 99, 25, 14, ES_NUMBER | ES_RIGHT
    CONTROL "", scr2, "msctls_updown32", UDS_NOTHOUSANDS | UDS_ARROWKEYS | UDS_AUTOBUDDY | UDS_ALIGNRIGHT | UDS_SETBUDDYINT, 55, 99, 12, 20
    LTEXT "寬度(&W):", -1, 75, 85, 33, 11
    EDITTEXT edt3, 75, 99, 25, 14, ES_NUMBER | ES_RIGHT
    CONTROL "", scr3, "msctls_updown32", UDS_NOTHOUSANDS | UDS_ARROWKEYS | UDS_AUTOBUDDY | UDS_ALIGNRIGHT | UDS_SETBUDDYINT, 90, 99, 12, 20
    LTEXT "高度(&H):", -1, 111, 85, 33, 11
    EDITTEXT edt4, 110, 99, 25, 14, ES_NUMBER | ES_RIGHT
    CONTROL "", scr4, "msctls_updown32", UDS_NOTHOUSANDS | UDS_ARROWKEYS | UDS_AUTOBUDDY | UDS_ALIGNRIGHT | UDS_SETBUDDYINT, 125, 99, 12, 20
    LTEXT "&ID:", -1, 150, 85, 70, 12
    COMBOBOX cmb3, 150, 99, 80, 300, CBS_HASSTRINGS | CBS_AUTOHSCROLL | CBS_DROPDOWN | WS_BORDER | WS_VSCROLL | WS_TABSTOP
    LTEXT "Window類名(&S):", -1, 5, 119, 100, 12
    COMBOBOX cmb4, 5, 133, 115, 200, CBS_HASSTRINGS | CBS_AUTOHSCROLL | CBS_DROPDOWN | WS_BORDER | WS_VSCROLL | WS_TABSTOP
    LTEXT "幫助 ID(&P):", -1, 125, 119, 70, 12
    COMBOBOX cmb5, 125, 133, 65, 200, CBS_HASSTRINGS | CBS_AUTOHSCROLL | CBS_DROPDOWN | WS_BORDER | WS_VSCROLL | WS_TABSTOP
    LTEXT "樣式(&T):", -1, 5, 153, 45, 12
    RTEXT "0x", -1, 54, 153, 10, 12
    EDITTEXT edt6, 70, 151, 45, 14, ES_AUTOHSCROLL
    LISTBOX lst1, 5, 167, 110, 120, LBS_DISABLENOSCROLL | LBS_NOINTEGRALHEIGHT | LBS_HASSTRINGS | LBS_MULTIPLESEL | WS_VSCROLL | WS_HSCROLL | WS_TABSTOP
    LTEXT "擴展類型(&E)", -1, 120, 153, 50, 12
    RTEXT "0x", -1, 172, 153, 10, 12
    EDITTEXT edt7, 185, 151, 45, 14, ES_AUTOHSCROLL
    LISTBOX lst2, 120, 167, 110, 120, LBS_DISABLENOSCROLL | LBS_NOINTEGRALHEIGHT | LBS_HASSTRINGS | LBS_MULTIPLESEL | WS_VSCROLL | WS_HSCROLL | WS_TABSTOP
    DEFPUSHBUTTON "OK", IDOK, 170, 293, 60, 14
    PUSHBUTTON "取消", IDCANCEL, 170, 309, 60, 14
    PUSHBUTTON "數據(&D)...", psh1, 5, 293, 90, 14
    PUSHBUTTON "字串列表(&I)...", psh3, 5, 309, 90, 14
}

IDD_ADDCTRL DIALOG 0, 0, 235, 330
CAPTION "增加控制項"
STYLE DS_MODALFRAME | WS_POPUPWINDOW | WS_CAPTION
FONT 9, "宋體"
{
    LTEXT "定義&Ctrl:", -1, 5, 7, 68, 12
    COMBOBOX cmb1, 75, 5, 120, 55, CBS_HASSTRINGS | CBS_AUTOHSCROLL | CBS_DROPDOWN | WS_BORDER | WS_VSCROLL | WS_TABSTOP
    CONTROL "", ctl1, "ToolbarWindow32", TBSTYLE_FLAT | TBSTYLE_WRAPABLE | TBSTYLE_TOOLTIPS | CCS_NODIVIDER | CCS_NORESIZE, 5, 22, 185, 30
    LTEXT "標題(&A):", -1, 5, 55, 75, 12
    COMBOBOX cmb2, 5, 65, 195, 300, CBS_HASSTRINGS | CBS_AUTOHSCROLL | CBS_DROPDOWN | WS_BORDER | WS_VSCROLL | WS_TABSTOP
    PUSHBUTTON "&OLE...", psh2, 205, 65, 25, 14
    LTEXT "左(&L):", -1, 5, 85, 33, 11
    EDITTEXT edt1, 5, 99, 25, 14, ES_NUMBER | ES_RIGHT
    CONTROL "", scr1, "msctls_updown32", UDS_NOTHOUSANDS | UDS_ARROWKEYS | UDS_AUTOBUDDY | UDS_ALIGNRIGHT | UDS_SETBUDDYINT, 20, 99, 12, 20
    LTEXT "上(&U):", -1, 40, 85, 33, 11
    EDITTEXT edt2, 40, 99, 25, 14, ES_NUMBER | ES_RIGHT
    CONTROL "", scr2, "msctls_updown32", UDS_NOTHOUSANDS | UDS_ARROWKEYS | UDS_AUTOBUDDY | UDS_ALIGNRIGHT | UDS_SETBUDDYINT, 55, 99, 12, 20
    LTEXT "寬度(&W):", -1, 75, 85, 33, 11
    EDITTEXT edt3, 75, 99, 25, 14, ES_NUMBER | ES_RIGHT
    CONTROL "", scr3, "msctls_updown32", UDS_NOTHOUSANDS | UDS_ARROWKEYS | UDS_AUTOBUDDY | UDS_ALIGNRIGHT | UDS_SETBUDDYINT, 90, 99, 12, 20
    LTEXT "高度(&H):", -1, 111, 85, 33, 11
    EDITTEXT edt4, 110, 99, 25, 14, ES_NUMBER | ES_RIGHT
    CONTROL "", scr4, "msctls_updown32", UDS_NOTHOUSANDS | UDS_ARROWKEYS | UDS_AUTOBUDDY | UDS_ALIGNRIGHT | UDS_SETBUDDYINT, 125, 99, 12, 20
    LTEXT "&ID:", -1, 150, 85, 70, 12
    COMBOBOX cmb3, 150, 99, 80, 300, CBS_HASSTRINGS | CBS_AUTOHSCROLL | CBS_DROPDOWN | WS_BORDER | WS_VSCROLL | WS_TABSTOP
    LTEXT "Window類名(&S):", -1, 5, 119, 100, 12
    COMBOBOX cmb4, 5, 133, 115, 200, CBS_HASSTRINGS | CBS_AUTOHSCROLL | CBS_DROPDOWN | WS_BORDER | WS_VSCROLL | WS_TABSTOP
    LTEXT "幫助 ID(&P):", -1, 125, 119, 70, 12
    COMBOBOX cmb5, 125, 133, 65, 200, CBS_HASSTRINGS | CBS_AUTOHSCROLL | CBS_DROPDOWN | WS_BORDER | WS_VSCROLL | WS_TABSTOP
    LTEXT "樣式(&T):", -1, 5, 153, 45, 12
    RTEXT "0x", -1, 54, 153, 10, 12
    EDITTEXT edt6, 70, 151, 45, 14, ES_AUTOHSCROLL
    LISTBOX lst1, 5, 167, 110, 120, LBS_DISABLENOSCROLL | LBS_NOINTEGRALHEIGHT | LBS_HASSTRINGS | LBS_MULTIPLESEL | WS_VSCROLL | WS_HSCROLL | WS_TABSTOP
    LTEXT "擴展類型(&E)", -1, 120, 153, 50, 12
    RTEXT "0x", -1, 172, 153, 10, 12
    EDITTEXT edt7, 185, 151, 45, 14, ES_AUTOHSCROLL
    LISTBOX lst2, 120, 167, 110, 120, LBS_DISABLENOSCROLL | LBS_NOINTEGRALHEIGHT | LBS_HASSTRINGS | LBS_MULTIPLESEL | WS_VSCROLL | WS_HSCROLL | WS_TABSTOP
    DEFPUSHBUTTON "OK", IDOK, 170, 293, 60, 14
    PUSHBUTTON "取消", IDCANCEL, 170, 309, 60, 14
    PUSHBUTTON "數據(&D)...", psh1, 5, 293, 90, 14
    PUSHBUTTON "字串列表(&I)...", psh3, 5, 309, 90, 14
}

IDD_IDASSOC DIALOG 0, 0, 200, 220
CAPTION "ID 關聯列表"
STYLE DS_MODALFRAME | WS_POPUPWINDOW | WS_CAPTION
FONT 9, "宋體"
{
    LTEXT "ID 關聯(&A):", -1, 5, 5, 116, 12
    CONTROL "", lst1, "SysListView32", LVS_SHOWSELALWAYS | LVS_SINGLESEL | LVS_REPORT | WS_BORDER | WS_TABSTOP, 5, 20, 190, 150
    PUSHBUTTON "全部重設(&R)", psh2, 5, 175, 85, 14
    PUSHBUTTON "修改(&M)", psh1, 135, 175, 60, 14
    DEFPUSHBUTTON "OK", IDOK, 70, 200, 60, 14
    PUSHBUTTON "取消", IDCANCEL, 135, 200, 60, 14
}

IDD_MODIFYASSOC DIALOG 0, 0, 165, 68
CAPTION "修改ID關聯"
STYLE DS_MODALFRAME | WS_POPUPWINDOW | WS_CAPTION
FONT 9, "宋體"
{
    RTEXT "ID類型(&T):", -1, 5, 7, 65, 12
    EDITTEXT edt1, 80, 5, 80, 14, WS_DISABLED
    RTEXT "&Prefix of ID:", -1, 5, 32, 65, 12
    EDITTEXT edt2, 80, 28, 80, 14, ES_AUTOHSCROLL
    DEFPUSHBUTTON "OK", IDOK, 35, 50, 60, 14
    PUSHBUTTON "取消", IDCANCEL, 100, 50, 60, 14
}

IDD_IDLIST DIALOG 0, 0, 200, 300
CAPTION "資源ID列表"
STYLE WS_OVERLAPPEDWINDOW
EXSTYLE WS_EX_TOOLWINDOW
FONT 9, "宋體"
{
    COMBOBOX cmb1, 0, 0, 200, 300, CBS_HASSTRINGS | CBS_SORT | CBS_OWNERDRAWFIXED | CBS_DROPDOWNLIST | WS_VSCROLL | WS_TABSTOP
    CONTROL "", lst1, "SysListView32", LVS_REPORT | WS_BORDER | WS_VSCROLL | WS_HSCROLL | WS_TABSTOP, 0, 15, 200, 285
}

IDD_CONFIG DIALOG 0, 0, 210, 285
CAPTION "配置"
STYLE DS_MODALFRAME | WS_POPUPWINDOW | WS_CAPTION
FONT 9, "宋體"
{
    AUTOCHECKBOX "在標題欄顯示完整路徑(&F)", chx1, 5, 5, 200, 14
    AUTOCHECKBOX "不使用ID宏定義(&M)", chx2, 5, 25, 200, 14
    AUTOCHECKBOX "恢復以前的窗口位置(&P)", chx3, 5, 45, 200, 14
    AUTOCHECKBOX "自動載入最近的""&resource.h""", chx4, 5, 65, 200, 14
    AUTOCHECKBOX "自動顯示資源ID列表(&L)", chx5, 5, 85, 200, 14
    AUTOCHECKBOX "在對話框編輯上顯示點陣(&D)", chx6, 5, 105, 200, 14
    RTEXT "Combo&Box的高度(&B):", -1, 10, 127, 75, 12
    EDITTEXT edt1, 90, 125, 34, 14, ES_NUMBER | ES_RIGHT
    CONTROL "", scr1, "msctls_updown32", UDS_NOTHOUSANDS | UDS_ARROWKEYS | UDS_AUTOBUDDY | UDS_ALIGNRIGHT | UDS_SETBUDDYINT, 129, 49, 12, 20
    AUTOCHECKBOX "自動換行(&W)", chx9, 135, 125, 70, 14
    AUTOCHECKBOX "詢問""&resource.h""的更新", chx7, 5, 145, 200, 14
    AUTOCHECKBOX "保存EXE文件時用&UPX壓縮", chx8, 5, 165, 200, 14
    PUSHBUTTON "字體(&F)...", psh4, 5, 185, 200, 14
    PUSHBUTTON "預定義的宏(&M)...", psh1, 5, 205, 93, 14
    PUSHBUTTON "設置PATH(&T)...", psh2, 107, 205, 98, 14
    RTEXT "&OLE控制項的名稱:", -1, 5, 227, 80, 12
    COMBOBOX cmb1, 90, 225, 75, 300, CBS_HASSTRINGS | CBS_AUTOHSCROLL | CBS_DROPDOWN | WS_VSCROLL | WS_TABSTOP
    AUTOCHECKBOX "創建備份(&B)  後綴:", chx10, 5, 245, 123, 14
    COMBOBOX cmb2, 134, 245, 45, 300, CBS_HASSTRINGS | CBS_AUTOHSCROLL | CBS_DROPDOWN | WS_VSCROLL | WS_TABSTOP
    DEFPUSHBUTTON "OK", IDOK, 100, 265, 50, 14
    PUSHBUTTON "取消", IDCANCEL, 155, 265, 50, 14
    PUSHBUTTON "全部重設(&S)", psh3, 5, 265, 75, 14
}

IDD_ADDRESID DIALOG 0, 0, 165, 90
CAPTION "增加資源ID"
STYLE DS_MODALFRAME | WS_POPUPWINDOW | WS_CAPTION
FONT 9, "宋體"
{
    RTEXT "ID類型(&T):", -1, 10, 7, 50, 14
    COMBOBOX cmb1, 65, 5, 95, 300, CBS_AUTOHSCROLL | CBS_DROPDOWNLIST | WS_VSCROLL | WS_TABSTOP
    RTEXT "ID名稱(&N):", -1, 10, 27, 50, 14
    EDITTEXT edt1, 65, 25, 75, 14, ES_AUTOHSCROLL
    RTEXT "整型值(&I):", -1, 10, 47, 50, 14
    EDITTEXT edt2, 65, 45, 48, 14, ES_AUTOHSCROLL
    CONTROL "", scr1, "msctls_updown32", UDS_NOTHOUSANDS | UDS_ARROWKEYS | UDS_AUTOBUDDY | UDS_ALIGNRIGHT | UDS_SETBUDDYINT, 129, 49, 12, 20
    PUSHBUTTON "自動(&A)", psh1, 115, 45, 45, 14
    DEFPUSHBUTTON "OK", IDOK, 20, 70, 60, 14
    PUSHBUTTON "取消", IDCANCEL, 85, 70, 60, 14
}

IDD_MODIFYRESID DIALOG 0, 0, 165, 90
CAPTION "修改資源ID"
STYLE DS_MODALFRAME | WS_POPUPWINDOW | WS_CAPTION
FONT 9, "宋體"
{
    RTEXT "ID名稱(&N):", -1, 10, 12, 50, 14, SS_REALSIZEIMAGE | NOT WS_GROUP
    EDITTEXT edt1, 65, 10, 95, 14, ES_AUTOHSCROLL
    RTEXT "ID類型(&T):", -1, 10, 32, 50, 14
    EDITTEXT edt2, 65, 30, 95, 14, ES_READONLY
    RTEXT "整型值(&I):", -1, 10, 52, 50, 14
    EDITTEXT edt3, 65, 50, 48, 14, ES_AUTOHSCROLL
    CONTROL "", scr1, "msctls_updown32", UDS_NOTHOUSANDS | UDS_ARROWKEYS | UDS_AUTOBUDDY | UDS_ALIGNRIGHT | UDS_SETBUDDYINT, 129, 49, 12, 20
    DEFPUSHBUTTON "OK", IDOK, 20, 70, 60, 14
    PUSHBUTTON "取消", IDCANCEL, 85, 70, 60, 14
}

IDD_ADVICERESH DIALOG 0, 0, 209, 184
CAPTION "文件的修改情況 ""resource.h"""
STYLE DS_MODALFRAME | WS_POPUPWINDOW | WS_CAPTION
FONT 9, "宋體"
{
    LTEXT "請修改文件 ""resource.h"" As Follows:", -1, 10, 10, 195, 20
    EDITTEXT edt1, 10, 30, 190, 130, ES_READONLY | ES_MULTILINE
    DEFPUSHBUTTON "OK", IDOK, 140, 165, 60, 14
    PUSHBUTTON "清除修改(&C)", psh1, 10, 165, 90, 14
}

IDD_CLONEINNEWNAME DIALOG 0, 0, 215, 75
CAPTION "複製為其他名稱"
STYLE DS_MODALFRAME | WS_POPUPWINDOW | WS_CAPTION
FONT 9, "宋體"
{
    LTEXT "資源類型(&T):", -1, 5, 7, 70, 12
    COMBOBOX cmb1, 75, 5, 135, 200, CBS_HASSTRINGS | CBS_AUTOHSCROLL | CBS_DROPDOWN | WS_DISABLED | WS_BORDER | WS_VSCROLL | WS_TABSTOP
    LTEXT "資源名稱(&N):", -1, 5, 32, 70, 12
    COMBOBOX cmb2, 75, 30, 120, 200, CBS_HASSTRINGS | CBS_AUTOHSCROLL | CBS_DROPDOWN | WS_BORDER | WS_VSCROLL | WS_TABSTOP
    PUSHBUTTON "&...", psh1, 195, 30, 15, 14
    DEFPUSHBUTTON "OK", IDOK, 35, 55, 60, 14
    PUSHBUTTON "取消", IDCANCEL, 115, 55, 60, 14
}

IDD_CLONEINNEWLANG DIALOG 0, 0, 215, 105
CAPTION "複製為其他語言"
STYLE DS_MODALFRAME | WS_POPUPWINDOW | WS_CAPTION
FONT 9, "宋體"
{
    LTEXT "資源類型(&T):", -1, 5, 7, 70, 12
    COMBOBOX cmb1, 75, 5, 135, 200, CBS_HASSTRINGS | CBS_AUTOHSCROLL | CBS_DROPDOWN | WS_DISABLED | WS_BORDER | WS_VSCROLL | WS_TABSTOP
    LTEXT "資源名稱(&N):", -1, 5, 32, 70, 12
    COMBOBOX cmb2, 75, 30, 120, 200, CBS_HASSTRINGS | CBS_AUTOHSCROLL | CBS_DROPDOWN | WS_DISABLED | WS_BORDER | WS_VSCROLL | WS_TABSTOP
    LTEXT "資源語言(&L):", -1, 5, 57, 70, 12
    COMBOBOX cmb3, 75, 55, 135, 200, CBS_HASSTRINGS | CBS_AUTOHSCROLL | CBS_DROPDOWN | WS_BORDER | WS_VSCROLL | WS_TABSTOP
    DEFPUSHBUTTON "OK", IDOK, 35, 85, 60, 14
    PUSHBUTTON "取消", IDCANCEL, 115, 85, 60, 14
}

IDD_ITEMSEARCH DIALOG 0, 0, 171, 135
CAPTION "搜索"
STYLE WS_POPUPWINDOW | WS_CAPTION
FONT 9, "宋體"
{
    LTEXT "搜索字串(&S):", -1, 4, 10, 100, 14
    EDITTEXT edt1, 5, 25, 160, 15, ES_AUTOHSCROLL
    AUTOCHECKBOX "區分大小寫(&C)", chx1, 5, 45, 120, 15
    GROUPBOX "方向", -1, 5, 65, 160, 42
    AUTORADIOBUTTON "向上(&U)", rad1, 15, 80, 60, 14, WS_TABSTOP
    AUTORADIOBUTTON "向下(&D)", rad2, 90, 80, 60, 14, WS_TABSTOP
    DEFPUSHBUTTON "查找(&F)", IDOK, 40, 115, 60, 14
    PUSHBUTTON "取消", IDCANCEL, 105, 115, 60, 14
}

IDD_VERSIONINFO DIALOG 0, 0, 174, 150
CAPTION "關於 RisohEditor"
STYLE DS_MODALFRAME | WS_POPUPWINDOW | WS_CAPTION
FONT 12, "宋體"
{
    ICON IDI_MAIN, -1, 5, 5, 0, 0
    LTEXT "...", stc1, 30, 5, 140, 50
    CTEXT "https://katahiromz.web.fc2.com", stc2, 5, 60, 165, 12, SS_CENTERIMAGE | SS_NOTIFY | NOT WS_GROUP
    CONTROL "...", edt1, "EDIT", ES_READONLY | ES_AUTOHSCROLL | ES_AUTOVSCROLL | ES_MULTILINE | WS_BORDER | WS_VSCROLL | WS_HSCROLL, 5, 75, 165, 50
    DEFPUSHBUTTON "OK", IDOK, 55, 130, 60, 14
}

IDD_ADDMSG DIALOG 0, 0, 255, 105
CAPTION "添加消息條目"
STYLE DS_MODALFRAME | WS_POPUPWINDOW | WS_CAPTION
FONT 9, "宋體"
{
    LTEXT "消息 &ID:", -1, 5, 7, 50, 12
    COMBOBOX cmb1, 65, 5, 134, 200, CBS_HASSTRINGS | CBS_AUTOHSCROLL | CBS_DROPDOWN | WS_BORDER | WS_VSCROLL | WS_TABSTOP
    PUSHBUTTON "&...", psh1, 200, 5, 15, 14
    LTEXT "消息值(&V):", -1, 5, 27, 80, 12
    EDITTEXT edt1, 5, 40, 245, 35, ES_WANTRETURN | ES_AUTOHSCROLL | ES_AUTOVSCROLL | ES_MULTILINE
    DEFPUSHBUTTON "OK", IDOK, 125, 85, 60, 14
    PUSHBUTTON "取消", IDCANCEL, 190, 85, 60, 14
}

IDD_MODIFYMSG DIALOG 0, 0, 255, 105
CAPTION "修改消息條目"
STYLE DS_MODALFRAME | WS_POPUPWINDOW | WS_CAPTION
FONT 9, "宋體"
{
    LTEXT "消息 &ID:", -1, 5, 7, 50, 12
    COMBOBOX cmb1, 65, 5, 134, 200, CBS_HASSTRINGS | CBS_AUTOHSCROLL | CBS_DROPDOWN | WS_DISABLED | WS_BORDER | WS_VSCROLL | WS_TABSTOP
    LTEXT "消息值(&V):", -1, 5, 27, 80, 12
    EDITTEXT edt1, 5, 40, 245, 35, ES_WANTRETURN | ES_AUTOHSCROLL | ES_AUTOVSCROLL | ES_MULTILINE
    DEFPUSHBUTTON "OK", IDOK, 125, 85, 60, 14
    PUSHBUTTON "取消", IDCANCEL, 190, 85, 60, 14
}

IDD_MESSAGES DIALOG 0, 0, 325, 160
CAPTION "字串表"
STYLE WS_POPUPWINDOW | WS_CAPTION | WS_THICKFRAME
FONT 9, "宋體"
{
    LTEXT "消息條目(&E):", -1, 5, 7, 80, 12
    CONTROL "", lst1, "SysListView32", LVS_NOSORTHEADER | LVS_AUTOARRANGE | LVS_NOLABELWRAP | LVS_SHOWSELALWAYS | LVS_SINGLESEL | LVS_REPORT | WS_BORDER | WS_VSCROLL | WS_HSCROLL | WS_TABSTOP, 5, 20, 315, 115
    PUSHBUTTON "添加(&A)...", psh1, 130, 3, 60, 14
    PUSHBUTTON "修改(&M)...", psh2, 195, 3, 60, 14
    PUSHBUTTON "刪除(&D)", psh3, 260, 3, 60, 14
    DEFPUSHBUTTON "OK", IDOK, 195, 140, 60, 14
    PUSHBUTTON "取消", IDCANCEL, 260, 140, 60, 14
    PUSHBUTTON "刪除所有(&L)", psh4, 5, 140, 75, 14
}

IDD_FONTS DIALOG 0, 0, 195, 110
CAPTION "字體設置"
STYLE DS_MODALFRAME | WS_POPUPWINDOW | WS_CAPTION
FONT 9, "宋體"
{
    RTEXT "資源(&S):", -1, 5, 5, 55, 15, SS_CENTERIMAGE | NOT WS_GROUP
    EDITTEXT edt1, 65, 5, 100, 14, ES_READONLY | ES_AUTOHSCROLL
    PUSHBUTTON "...", psh1, 170, 5, 19, 14
    RTEXT "二進位制(&B):", -1, 5, 25, 55, 15, SS_CENTERIMAGE | NOT WS_GROUP
    EDITTEXT edt2, 65, 25, 100, 14, ES_READONLY | ES_AUTOHSCROLL
    PUSHBUTTON "...", psh2, 170, 25, 19, 14
    GROUPBOX "預覽", -1, 5, 45, 185, 39
    CTEXT "資源", stc1, 15, 55, 80, 25, SS_CENTERIMAGE | NOT WS_GROUP
    CTEXT "二進位制", stc2, 100, 55, 85, 25, SS_CENTERIMAGE | NOT WS_GROUP
    DEFPUSHBUTTON "OK", IDOK, 65, 90, 60, 14
    PUSHBUTTON "取消", IDCANCEL, 130, 90, 60, 14
}

IDD_MACROS DIALOG 0, 0, 265, 165
CAPTION "預定義的宏"
STYLE WS_POPUPWINDOW | WS_CAPTION | WS_THICKFRAME
FONT 9, "宋體"
{
    LTEXT "預定義的宏(&M):", -1, 5, 0, 100, 15, SS_CENTERIMAGE | NOT WS_GROUP
    CONTROL "", lst1, "SysListView32", LVS_EDITLABELS | LVS_SHOWSELALWAYS | LVS_SINGLESEL | LVS_REPORT | WS_BORDER | WS_TABSTOP, 5, 15, 190, 125
    PUSHBUTTON "加(&A)...", psh1, 200, 15, 60, 14
    PUSHBUTTON "編輯(&E)...", psh2, 200, 35, 60, 14
    PUSHBUTTON "刪除(&D)", psh3, 200, 55, 60, 14
    PUSHBUTTON "刪除全部(&L)", psh7, 200, 105, 60, 14
    DEFPUSHBUTTON "OK", IDOK, 135, 145, 60, 14
    PUSHBUTTON "取消", IDCANCEL, 200, 145, 60, 14
    PUSHBUTTON "重設全部(&R)", psh6, 5, 145, 60, 14
}

IDD_ADDMACRO DIALOG 0, 0, 190, 80
CAPTION "添加預定義的宏"
STYLE DS_MODALFRAME | WS_POPUPWINDOW | WS_CAPTION
FONT 9, "宋體"
{
    RTEXT "鍵(&K):", -1, 5, 12, 60, 14
    COMBOBOX cmb1, 70, 10, 110, 200, CBS_DROPDOWN | WS_BORDER | WS_VSCROLL | WS_TABSTOP
    RTEXT "值(&V):", -1, 5, 37, 60, 14
    COMBOBOX cmb2, 70, 35, 110, 300, CBS_DROPDOWN | WS_BORDER | WS_VSCROLL | WS_TABSTOP
    DEFPUSHBUTTON "OK", IDOK, 60, 60, 60, 14
    PUSHBUTTON "取消", IDCANCEL, 125, 60, 60, 14
}

IDD_EDITMACRO DIALOG 0, 0, 190, 80
CAPTION "編輯預定義的宏"
STYLE DS_MODALFRAME | WS_POPUPWINDOW | WS_CAPTION
FONT 9, "宋體"
{
    RTEXT "鍵(&K):", -1, 5, 12, 60, 14
    COMBOBOX cmb1, 70, 10, 110, 200, CBS_DROPDOWN | WS_DISABLED | WS_BORDER | WS_VSCROLL | WS_TABSTOP
    RTEXT "值(&V):", -1, 5, 37, 60, 14
    COMBOBOX cmb2, 70, 35, 110, 300, CBS_DROPDOWN | WS_BORDER | WS_VSCROLL | WS_TABSTOP
    DEFPUSHBUTTON "OK", IDOK, 60, 60, 60, 14
    PUSHBUTTON "取消", IDCANCEL, 125, 60, 60, 14
}

IDD_CTRLDATA DIALOG 0, 0, 190, 130
CAPTION "編輯控制項數據"
STYLE DS_MODALFRAME | WS_POPUPWINDOW | WS_CAPTION
FONT 9, "宋體"
{
    LTEXT "二進位制數據(&B):", -1, 5, 2, 87, 12
    EDITTEXT edt1, 5, 15, 180, 60, ES_AUTOVSCROLL | ES_MULTILINE | WS_VSCROLL
    LTEXT "您可以透過空格分隔的16位整數來設置控制項數據。", -1, 5, 80, 180, 25
    DEFPUSHBUTTON "OK", IDOK, 60, 110, 60, 14
    PUSHBUTTON "取消", IDCANCEL, 125, 110, 60, 14
}

IDD_PATHS DIALOG 0, 0, 295, 220
CAPTION "設置PATH"
STYLE WS_POPUPWINDOW | WS_CAPTION | WS_THICKFRAME
FONT 9, "宋體"
{
    LTEXT "&Include Directories:", -1, 5, 5, 102, 12
    LISTBOX lst1, 5, 20, 220, 105, LBS_NOINTEGRALHEIGHT | LBS_HASSTRINGS | LBS_SORT | WS_VSCROLL | WS_HSCROLL | WS_TABSTOP
    PUSHBUTTON "加(&A)...", psh1, 230, 5, 60, 14
    PUSHBUTTON "編輯(&E)...", psh2, 230, 25, 60, 14
    PUSHBUTTON "刪除(&D)", psh3, 230, 45, 60, 14
    PUSHBUTTON "上(&U)", psh4, 230, 65, 60, 14
    PUSHBUTTON "下(&O)", psh5, 230, 85, 60, 14
    PUSHBUTTON "全部刪除(&L)", psh6, 5, 130, 95, 14
    RTEXT "&windres.exe:", stc1, 5, 157, 55, 12
    COMBOBOX cmb1, 70, 155, 155, 300, CBS_HASSTRINGS | CBS_AUTOHSCROLL | CBS_DROPDOWN | WS_VSCROLL | WS_TABSTOP
    PUSHBUTTON "瀏覽(&B)...", psh7, 230, 155, 60, 14
    RTEXT "&cpp.exe:", stc2, 5, 177, 55, 12
    COMBOBOX cmb2, 70, 175, 155, 300, CBS_HASSTRINGS | CBS_AUTOHSCROLL | CBS_DROPDOWN | WS_VSCROLL | WS_TABSTOP
    PUSHBUTTON "瀏覽(&R)...", psh8, 230, 175, 60, 14
    DEFPUSHBUTTON "OK", IDOK, 165, 200, 60, 14
    PUSHBUTTON "取消", IDCANCEL, 230, 200, 60, 14
    PUSHBUTTON "重設全部(&S)", psh9, 5, 200, 95, 14
}

IDD_EXP_OPTIONS DIALOG 0, 0, 250, 225
CAPTION "導出選項"
STYLE DS_MODALFRAME | WS_POPUPWINDOW | WS_CAPTION
FONT 9, "宋體"
{
    ICON IDI_MAIN, -1, 5, 10, 0, 0
    LTEXT "導出RC文件將生成一些相關文件。您可以選擇以下選項:", -1, 35, 5, 210, 29
    AUTOCHECKBOX "使用微軟消息表(&T)", chx8, 5, 40, 240, 14
    AUTOCHECKBOX "按語言分開資源文件(&L)", chx1, 5, 60, 240, 14
    AUTOCHECKBOX "使用 BEGIN/END 關鍵字(&E)", chx2, 5, 80, 240, 14
    AUTOCHECKBOX "通過 LANGUAGE_ * 宏使語言可選(&M)", chx3, 5, 100, 240, 14
    AUTOCHECKBOX "創建備份(&B)", chx4, 5, 120, 110, 14
    RTEXT "後綴:", -1, 120, 122, 75, 12
    COMBOBOX cmb1, 200, 120, 45, 300, CBS_HASSTRINGS | CBS_AUTOHSCROLL | CBS_DROPDOWN | WS_VSCROLL | WS_TABSTOP
    AUTOCHECKBOX "產出冗餘注釋(&C)", chx5, 5, 140, 240, 14
    AUTOCHECKBOX "用 #ifndef MSVC ... #endif 包裝 ma&nifest", chx6, 5, 160, 240, 14
    AUTOCHECKBOX "產出 RC 文件為 &UTF-16", chx7, 5, 180, 240, 14
    DEFPUSHBUTTON "OK", IDOK, 120, 205, 60, 14
    PUSHBUTTON "取消", IDCANCEL, 185, 205, 60, 14
}

IDD_LANGS DIALOG 0, 0, 250, 235
CAPTION "語言列表"
STYLE WS_POPUPWINDOW | WS_CAPTION | WS_THICKFRAME
FONT 9, "宋體"
{
    CONTROL "", lst1, "SysListView32", LVS_SHOWSELALWAYS | LVS_SINGLESEL | LVS_REPORT | WS_BORDER | WS_TABSTOP, 5, 5, 240, 179
    RTEXT "搜索(&S):", stc1, 5, 192, 45, 12
    COMBOBOX cmb1, 55, 190, 85, 300, CBS_SORT | CBS_DROPDOWN | WS_VSCROLL | WS_TABSTOP
    EDITTEXT edt1, 4, 209, 240, 20, ES_AUTOHSCROLL | ES_AUTOVSCROLL | ES_MULTILINE
}

IDD_CHILD DIALOG 0, 0, 215, 135
CAPTION "子對話框"
STYLE WS_CHILD | WS_OVERLAPPEDWINDOW
FONT 9, "宋體"
{
    DEFPUSHBUTTON "OK", IDOK, 35, 115, 60, 14
    PUSHBUTTON "取消", IDCANCEL, 115, 115, 60, 14
}

IDD_DLGINITEDIT DIALOG 0, 0, 325, 165
CAPTION "編輯DLGINIT"
STYLE WS_POPUPWINDOW | WS_CAPTION | WS_THICKFRAME
FONT 9, "宋體"
{
    LTEXT "消息條目(&E):", -1, 5, 7, 100, 12
    CONTROL "", lst1, "SysListView32", LVS_NOSORTHEADER | LVS_AUTOARRANGE | LVS_NOLABELWRAP | LVS_SHOWSELALWAYS | LVS_SINGLESEL | LVS_REPORT | WS_BORDER | WS_VSCROLL | WS_HSCROLL | WS_TABSTOP, 5, 20, 250, 120
    PUSHBUTTON "加(&A)...", psh1, 260, 20, 60, 14
    PUSHBUTTON "編輯(&M)...", psh2, 260, 40, 60, 14
    PUSHBUTTON "刪除(&D)", psh3, 260, 60, 60, 14
    PUSHBUTTON "上(&U)", psh4, 260, 100, 60, 14
    PUSHBUTTON "下(&O)", psh5, 260, 120, 60, 14
    DEFPUSHBUTTON "OK", IDOK, 195, 145, 60, 14
    PUSHBUTTON "取消", IDCANCEL, 260, 145, 60, 14
    PUSHBUTTON "全部刪除(&L)", psh6, 5, 145, 79, 14
}

IDD_ADDDLGINIT DIALOG 0, 0, 184, 137
CAPTION "添加DLGINIT數據"
STYLE DS_MODALFRAME | WS_POPUPWINDOW | WS_CAPTION
FONT 9, "宋體"
{
    LTEXT "控制項&ID:", -1, 5, 7, 56, 12
    COMBOBOX cmb1, 65, 5, 115, 300, CBS_HASSTRINGS | CBS_AUTOHSCROLL | CBS_DROPDOWN | WS_VSCROLL | WS_TABSTOP
    LTEXT "資訊(&M):", -1, 5, 32, 55, 12
    COMBOBOX cmb2, 65, 30, 95, 300, CBS_HASSTRINGS | CBS_AUTOHSCROLL | CBS_DROPDOWN | WS_VSCROLL | WS_TABSTOP
    LTEXT "串(&S):", -1, 5, 52, 55, 12
    EDITTEXT edt1, 5, 65, 175, 50, ES_WANTRETURN | ES_MULTILINE | WS_VSCROLL | WS_HSCROLL
    DEFPUSHBUTTON "OK", IDOK, 55, 120, 60, 14
    PUSHBUTTON "取消", IDCANCEL, 120, 120, 60, 14
}

IDD_MODIFYDLGINIT DIALOG 0, 0, 184, 137
CAPTION "添加DLGINIT數據"
STYLE DS_MODALFRAME | WS_POPUPWINDOW | WS_CAPTION
FONT 9, "宋體"
{
    LTEXT "控制項&ID:", -1, 5, 7, 56, 12
    COMBOBOX cmb1, 65, 5, 115, 300, CBS_HASSTRINGS | CBS_AUTOHSCROLL | CBS_DROPDOWN | WS_VSCROLL | WS_TABSTOP
    LTEXT "資訊(&M):", -1, 5, 32, 55, 12
    COMBOBOX cmb2, 65, 30, 95, 300, CBS_HASSTRINGS | CBS_AUTOHSCROLL | CBS_DROPDOWN | WS_VSCROLL | WS_TABSTOP
    LTEXT "串(&S):", -1, 5, 52, 55, 12
    EDITTEXT edt1, 5, 65, 175, 50, ES_WANTRETURN | ES_MULTILINE | WS_VSCROLL | WS_HSCROLL
    DEFPUSHBUTTON "OK", IDOK, 55, 120, 60, 14
    PUSHBUTTON "取消", IDCANCEL, 120, 120, 60, 14
}

IDD_STRINGLIST DIALOG 0, 0, 205, 220
CAPTION "Control String List"
STYLE WS_POPUPWINDOW | WS_CAPTION | WS_THICKFRAME
FONT 9, "宋體"
{
    LTEXT "", stc1, 5, 5, 195, 70
    EDITTEXT edt1, 5, 80, 195, 115, ES_WANTRETURN | ES_MULTILINE | WS_VSCROLL | WS_HSCROLL
    DEFPUSHBUTTON "OK", IDOK, 75, 200, 60, 14
    PUSHBUTTON "取消", IDCANCEL, 140, 200, 60, 14
}

IDD_SAVE_OPTIONS DIALOG 0, 0, 250, 225
CAPTION "保存選項"
STYLE DS_MODALFRAME | WS_POPUPWINDOW | WS_CAPTION
FONT 9, "宋體"
{
    ICON IDI_MAIN, -1, 5, 10, 0, 0
    LTEXT "保存RC文件將生成一些相關文件。您可以選擇以下選項。", -1, 35, 5, 210, 29
    AUTOCHECKBOX "使用微軟消息表(&T)", chx8, 5, 40, 240, 14
    AUTOCHECKBOX "按語言分開資源文件(&L)", chx1, 5, 60, 240, 14
    AUTOCHECKBOX "使用 BEGIN/END 關鍵字(&E)", chx2, 5, 80, 240, 14
    AUTOCHECKBOX "通過 LANGUAGE_ * 宏使語言可選(&M)", chx3, 5, 100, 240, 14
    AUTOCHECKBOX "創建備份(&B)", chx4, 5, 120, 110, 14
    RTEXT "後綴:", -1, 120, 122, 75, 12
    COMBOBOX cmb1, 200, 120, 45, 300, CBS_HASSTRINGS | CBS_AUTOHSCROLL | CBS_DROPDOWN | WS_VSCROLL | WS_TABSTOP
    AUTOCHECKBOX "產出冗餘注釋(&C)", chx5, 5, 140, 240, 14
    AUTOCHECKBOX "用 #ifndef MSVC ... #endif 包裝 ma&nifest", chx6, 5, 160, 240, 14
    AUTOCHECKBOX "產出 RC 文件為 &UTF-16", chx7, 5, 180, 240, 14
    DEFPUSHBUTTON "OK", IDOK, 120, 205, 60, 14
    PUSHBUTTON "取消", IDCANCEL, 185, 205, 60, 14
}

IDD_ENCODING DIALOG 0, 0, 200, 170
CAPTION "資源項的編碼"
STYLE DS_MODALFRAME | WS_POPUPWINDOW | WS_CAPTION
FONT 9, "宋體"
{
    CONTROL "", lst1, "SysListView32", LVS_SHOWSELALWAYS | LVS_SINGLESEL | LVS_REPORT | WS_BORDER, 5, 5, 190, 115
    PUSHBUTTON "加(&A)...", psh1, 5, 125, 60, 14
    PUSHBUTTON "修改(&M)...", psh2, 70, 125, 60, 14
    PUSHBUTTON "刪除(&D)", psh3, 135, 125, 60, 14
    DEFPUSHBUTTON "OK", IDOK, 70, 150, 60, 14
    PUSHBUTTON "取消", IDCANCEL, 135, 150, 60, 14
    PUSHBUTTON "重啟(&R)", psh5, 5, 149, 60, 14
}

IDD_ADDENC DIALOG 0, 0, 215, 80
CAPTION "添加資源編碼"
STYLE DS_MODALFRAME | WS_POPUPWINDOW | WS_CAPTION
FONT 9, "宋體"
{
    LTEXT "資源類型(&T):", -1, 5, 7, 70, 12
    COMBOBOX cmb1, 75, 5, 135, 200, CBS_HASSTRINGS | CBS_AUTOHSCROLL | CBS_DROPDOWN | WS_BORDER | WS_VSCROLL | WS_TABSTOP
    LTEXT "編碼(&E):", -1, 5, 30, 70, 12
    COMBOBOX cmb2, 75, 30, 85, 300, CBS_HASSTRINGS | CBS_AUTOHSCROLL | CBS_DROPDOWNLIST | WS_VSCROLL | WS_TABSTOP
    DEFPUSHBUTTON "OK", IDOK, 86, 60, 60, 14
    PUSHBUTTON "取消", IDCANCEL, 150, 60, 60, 14
}

IDD_MODIFYENC DIALOG 0, 0, 215, 80
CAPTION "修改資源編碼"
STYLE DS_MODALFRAME | WS_POPUPWINDOW | WS_CAPTION
FONT 9, "宋體"
{
    LTEXT "資源類型(&T):", -1, 5, 7, 70, 12
    COMBOBOX cmb1, 75, 5, 135, 200, CBS_HASSTRINGS | CBS_AUTOHSCROLL | CBS_DROPDOWN | WS_DISABLED | WS_BORDER | WS_VSCROLL | WS_TABSTOP
    LTEXT "編碼(&E):", -1, 5, 30, 70, 12
    COMBOBOX cmb2, 75, 30, 85, 300, CBS_HASSTRINGS | CBS_AUTOHSCROLL | CBS_DROPDOWNLIST | WS_VSCROLL | WS_TABSTOP
    DEFPUSHBUTTON "OK", IDOK, 86, 60, 60, 14
    PUSHBUTTON "取消", IDCANCEL, 150, 60, 60, 14
}

IDD_CONSTANT DIALOG 0, 0, 205, 75
CAPTION "查詢常量"
STYLE DS_MODALFRAME | WS_POPUPWINDOW | WS_CAPTION
FONT 9, "宋體"
{
    LTEXT "常數的名稱(&N):", -1, 5, 7, 80, 12
    COMBOBOX cmb1, 94, 7, 105, 300, CBS_HASSTRINGS | CBS_AUTOHSCROLL | CBS_DROPDOWN | WS_VSCROLL | WS_TABSTOP
    LTEXT "恆定價值(&V):", -1, 5, 32, 80, 12
    EDITTEXT edt2, 95, 30, 50, 14, ES_READONLY
    EDITTEXT edt3, 150, 30, 50, 14, ES_READONLY
    DEFPUSHBUTTON "OK", IDOK, 70, 55, 60, 14
}

IDD_EGA DIALOG 0, 0, 400, 225
CAPTION "電腦語言EGA"
STYLE WS_POPUPWINDOW | WS_CAPTION | WS_THICKFRAME
FONT 9, "宋體"
{
    GROUPBOX "EGA 主控台", grp1, 5, 5, 390, 195
    EDITTEXT edt1, 10, 20, 380, 170, ES_READONLY | ES_AUTOVSCROLL | ES_MULTILINE | WS_VSCROLL | NOT WS_TABSTOP
    RTEXT "EGA>", stc1, 10, 208, 20, 10
    EDITTEXT edt2, 35, 205, 300, 15, ES_WANTRETURN | ES_AUTOHSCROLL | ES_AUTOVSCROLL | ES_MULTILINE
    PUSHBUTTON "&Enter", IDOK, 345, 205, 50, 15
}

IDD_FONTSUBST DIALOG 0, 0, 185, 180
CAPTION "Dialog Font Substitutes"
STYLE DS_CENTER | DS_MODALFRAME | WS_POPUPWINDOW | WS_CAPTION
FONT 9, "宋體"
{
    LTEXT "字形 #&1:", -1, 5, 7, 44, 12
    COMBOBOX cmb1, 55, 5, 125, 300, CBS_HASSTRINGS | CBS_AUTOHSCROLL | CBS_DROPDOWN | WS_VSCROLL | WS_TABSTOP
    ICON IDI_ARROW, -1, 30, 25, 0, 0
    COMBOBOX cmb2, 55, 30, 125, 300, CBS_HASSTRINGS | CBS_AUTOHSCROLL | CBS_DROPDOWN | WS_VSCROLL | WS_TABSTOP
    LTEXT "字形 #&2:", -1, 5, 57, 44, 12
    COMBOBOX cmb3, 55, 55, 125, 300, CBS_HASSTRINGS | CBS_AUTOHSCROLL | CBS_DROPDOWN | WS_VSCROLL | WS_TABSTOP
    ICON IDI_ARROW, -1, 30, 75, 0, 0
    COMBOBOX cmb4, 55, 80, 125, 300, CBS_HASSTRINGS | CBS_AUTOHSCROLL | CBS_DROPDOWN | WS_VSCROLL | WS_TABSTOP
    LTEXT "字形 #&3:", -1, 5, 105, 44, 12
    COMBOBOX cmb5, 55, 105, 125, 300, CBS_HASSTRINGS | CBS_AUTOHSCROLL | CBS_DROPDOWN | WS_VSCROLL | WS_TABSTOP
    ICON IDI_ARROW, -1, 30, 125, 0, 0
    COMBOBOX cmb6, 55, 130, 125, 300, CBS_HASSTRINGS | CBS_AUTOHSCROLL | CBS_DROPDOWN | WS_VSCROLL | WS_TABSTOP
    DEFPUSHBUTTON "OK", IDOK, 75, 160, 50, 14
    PUSHBUTTON "取消", IDCANCEL, 130, 160, 50, 14
    PUSHBUTTON "重啟(&R)", psh1, 5, 160, 55, 14
}

IDD_DROPDOWNPOPUP DIALOG 0, 0, 120, 150
CAPTION " "
STYLE WS_POPUP | WS_DLGFRAME | NOT WS_BORDER
FONT 9, "宋體"
{
    LISTBOX lst1, 0, 0, 120, 150, LBS_WANTKEYBOARDINPUT | LBS_NOINTEGRALHEIGHT | LBS_HASSTRINGS | WS_VSCROLL | WS_TABSTOP, WS_EX_CLIENTEDGE
}

IDD_DFMSETTINGS DIALOG 0, 0, 210, 135
CAPTION "Delphi DFM Settings"
STYLE DS_CENTER | DS_MODALFRAME | WS_POPUPWINDOW | WS_CAPTION
FONT 9, "宋體"
{
    LTEXT "以下設置與 Delphi DFM 相關。", -1, 35, 5, 171, 20
    ICON IDI_DFMICON, -1, 5, 5, 0, 0
    RTEXT "代碼頁(&C)：", -1, 6, 32, 70, 12
    COMBOBOX cmb1, 85, 30, 120, 300, CBS_HASSTRINGS | CBS_AUTOHSCROLL | CBS_DROPDOWN | WS_VSCROLL | WS_TABSTOP
    AUTOCHECKBOX "插入原始字串注釋(&I)", chx1, 5, 50, 200, 14
    AUTOCHECKBOX "不要使用 Unicode 和 UTF-8 (&U)", chx2, 5, 70, 200, 14
    DEFPUSHBUTTON "OK", IDOK, 80, 115, 60, 14
    PUSHBUTTON "取消", IDCANCEL, 145, 115, 60, 14
}

IDD_COPYTOMULTILANG DIALOG 0, 0, 200, 195
CAPTION "複製到多種語言"
STYLE DS_CENTER | DS_MODALFRAME | WS_POPUPWINDOW | WS_CAPTION
FONT 9, "宋體"
{
    LTEXT "請添加您要將資源複製到的語言：", -1, 5, 5, 190, 22
    LTEXT "語言(&L)：", -1, 5, 35, 82, 12
    LISTBOX lst1, 5, 50, 190, 100, LBS_WANTKEYBOARDINPUT | LBS_NOINTEGRALHEIGHT | LBS_HASSTRINGS | WS_VSCROLL | WS_TABSTOP
    COMBOBOX cmb3, 5, 155, 126, 14, CBS_HASSTRINGS | CBS_AUTOHSCROLL | CBS_DROPDOWN | WS_BORDER | WS_VSCROLL | WS_TABSTOP
    PUSHBUTTON "添加(&A)", psh1, 135, 155, 60, 14
    DEFPUSHBUTTON "OK", IDOK, 5, 175, 60, 14
    PUSHBUTTON "取消", IDCANCEL, 70, 175, 60, 14
}

IDD_TOOLBARRES DIALOG 0, 0, 230, 195
CAPTION "工具欄資源"
STYLE DS_CENTER | DS_MODALFRAME | WS_POPUPWINDOW | WS_CAPTION
FONT 9, "宋體"
{
    RTEXT "圖示寬度(&W):", -1, 5, 5, 60, 15, SS_CENTERIMAGE | NOT WS_GROUP
    EDITTEXT edt1, 70, 5, 30, 15, ES_NUMBER | ES_RIGHT
    CONTROL "", scr1, "msctls_updown32", UDS_NOTHOUSANDS | UDS_ARROWKEYS | UDS_AUTOBUDDY | UDS_ALIGNRIGHT | UDS_SETBUDDYINT, 80, 5, 30, 15
    RTEXT "圖示高度(&H):", -1, 110, 5, 60, 15, SS_CENTERIMAGE | NOT WS_GROUP
    EDITTEXT edt2, 180, 5, 30, 15, ES_NUMBER | ES_RIGHT
    CONTROL "", scr2, "msctls_updown32", UDS_NOTHOUSANDS | UDS_ARROWKEYS | UDS_AUTOBUDDY | UDS_ALIGNRIGHT | UDS_SETBUDDYINT, 190, 5, 30, 15
    LTEXT "工具欄按鈕(&T):", -1, 5, 25, 140, 15, SS_CENTERIMAGE | NOT WS_GROUP
    LISTBOX lst1, 5, 40, 140, 130, LBS_DISABLENOSCROLL | LBS_WANTKEYBOARDINPUT | LBS_NOINTEGRALHEIGHT | LBS_HASSTRINGS | LBS_OWNERDRAWFIXED | WS_VSCROLL | WS_TABSTOP
    PUSHBUTTON "添加(&A)...", psh1, 150, 40, 75, 15
    PUSHBUTTON "修改(&M)...", psh2, 150, 60, 75, 15
    PUSHBUTTON "刪除(&D)", psh3, 150, 80, 75, 15
    PUSHBUTTON "上(&U)", psh4, 150, 135, 75, 15
    PUSHBUTTON "下(&O)", psh5, 150, 155, 75, 15
    DEFPUSHBUTTON "OK", IDOK, 5, 175, 60, 15
    PUSHBUTTON "取消", IDCANCEL, 70, 175, 60, 15
}

IDD_ADDTBBTN DIALOG 0, 0, 177, 92
CAPTION "添加工具欄按鈕"
STYLE DS_CENTER | DS_MODALFRAME | WS_POPUPWINDOW | WS_CAPTION
FONT 9, "宋體"
{
    LTEXT "工具欄按鈕的命令ID (&C):", -1, 5, 5, 160, 15, SS_CENTERIMAGE | NOT WS_GROUP
    COMBOBOX cmb1, 5, 25, 150, 150, CBS_HASSTRINGS | CBS_AUTOHSCROLL | CBS_DROPDOWN | WS_VSCROLL | WS_TABSTOP
    AUTOCHECKBOX "分隔器(&S)", chx1, 5, 45, 90, 15
    DEFPUSHBUTTON "OK", IDOK, 45, 70, 60, 15
    PUSHBUTTON "取消", IDCANCEL, 110, 70, 60, 15
}

IDD_MODIFYTBBTN DIALOG 0, 0, 177, 92
CAPTION "修改工具欄按鈕"
STYLE DS_CENTER | DS_MODALFRAME | WS_POPUPWINDOW | WS_CAPTION
FONT 9, "宋體"
{
    LTEXT "工具欄按鈕的命令ID (&C):", -1, 5, 5, 160, 15, SS_CENTERIMAGE | NOT WS_GROUP
    COMBOBOX cmb1, 5, 25, 150, 150, CBS_HASSTRINGS | CBS_AUTOHSCROLL | CBS_DROPDOWN | WS_VSCROLL | WS_TABSTOP
    AUTOCHECKBOX "分隔器(&S)", chx1, 5, 45, 90, 15
    DEFPUSHBUTTON "OK", IDOK, 45, 70, 60, 15
    PUSHBUTTON "取消", IDCANCEL, 110, 70, 60, 15
}

//////////////////////////////////////////////////////////////////////////////
// RT_VERSION

1 VERSIONINFO
FILEVERSION     5, 7, 9, 0
PRODUCTVERSION  5, 7, 9, 0
FILEOS          0x40004
FILETYPE        0x1
FILESUBTYPE     0x0
{
    BLOCK "StringFileInfo"
    {
        BLOCK "080404B0"
        {
            VALUE "CompanyName", "片山博文MZ\0"
            VALUE "FileDescription", "RisohEditor\0"
            VALUE "FileVersion", "5.7.9\0"
            VALUE "LegalCopyright", "Copyright (C) 2017-2020 片山博文MZ and 林鸿湘. 版权所有.\0"
            VALUE "ProductName", "RisohEditor\0"
            VALUE "ProductVersion", "5.7.9\0"
        }
    }
    BLOCK "VarFileInfo"
    {
        VALUE "Translation", 0x0804, 0x04B0
    }
}

//////////////////////////////////////////////////////////////////////////////
// RISOHTEMPLATE

4 RISOHTEMPLATE "res/1028_RISOHTEMPLATE_4.bin"

5 RISOHTEMPLATE "res/1028_RISOHTEMPLATE_5.bin"

//////////////////////////////////////////////////////////////////////////////
// RT_STRING

STRINGTABLE
{
    IDS_APPNAME, "RisohEditor 5.7.9 by 片山博文MZ"
    IDS_TITLEWITHFILE, "RisohEditor 5.7.9 - 文件: %s"
    IDS_EXTRACTRES, "導出資源"
    IDS_RESBINFILTER, "二進位制資源文件 (*.res)|*.res|二進位制文件 (*.bin)|*.bin|全部文件 (*.*)|*.*|"
    IDS_CANNOTSAVE, "無法保存。"
    IDS_REPLACERES, "替換資源"
    IDS_ALLFILES, "全部文件 (*.*)|*.*|"
    IDS_ENTERTYPE, "請選擇資源類型。"
    IDS_ENTERNAME, "請輸入資源名稱。"
    IDS_ENTERLANG, "請輸入資源語言類型。"
    IDS_FILENOTFOUND, "未找到文件。"
    IDS_CANNOTREPLACE, "替換失敗。"
    IDS_EXERESFILTER, "資源配置文件 (*.exe;*.dll;*.ocx;*.cpl;*.scr;*.mui)|*.exe;*.dll;*.ocx;*.cpl;*.scr;*.mui|RC文件 (*.rc)|*.rc|二進位制資源文件 (*.res)|*.res|全部文件 (*.*)|*.*|"
    IDS_SAVEAS, "另存為"
    IDS_CANNOTADDICON, "載入圖示失敗。"
    IDS_ADDICON, "加圖示"
    IDS_ICOFILTER, "圖示文件 (*.ico)|*.ico|全部文件 (*.*)|*.*|"
    IDS_REPLACEICO, "替換圖示"
    IDS_CANTREPLACEICO, "替換圖示失敗。"
    IDS_EXISTSOVERWRITE, "文件已經存在，替換掉?"
    IDS_OPEN, "打開"
    IDS_CANNOTOPEN, "打開失敗。"
    IDS_ADDBMP, "加點陣圖"
    IDS_BMPFILTER, "點陣圖文件 (*.bmp)|*.bmp|PNG 圖片 (*.png)|*.png|全部文件 (*.*)|*.*|"
    IDS_CANTREPLACEBMP, "點陣圖打開失敗！"
    IDS_REPLACEBMP, "替換點陣圖"
    IDS_ERRORCODE, "錯誤碼 %d"
    IDS_VERSIONINFO, "RisohEditor 版本 5.7.9\r\n\r\n片山博文MZ\r\nKatayama Hirofumi MZ\r\n\r\nLicense: GPLv3 (free software)"
    IDS_ADDRES, "增加資源"
    IDS_CANNOTADDRES, "添加資源失敗。"
    IDS_CANTADDBMP, "添加點陣圖失敗。"
    IDS_EXTRACTBMP, "導出點陣圖"
    IDS_CANTEXTRACTBMP, "不能導出點陣圖。"
    IDS_CANTREPLACECUR, "不能導出游標。"
    IDS_CANNOTADDCUR, "不能添加游標。"
    IDS_CURFILTER, "游標文件(*.cur)|*.cur|動態游標 (*.ani)|*.ani|全部文件 (*.*)|*.*|"
    IDS_ADDCUR, "增加游標"
    IDS_REPLACECUR, "替換游標"
    IDS_EXTRACTICO, "導出圖示"
    IDS_CANTEXTRACTICO, "導出圖示失敗。"
    IDS_EXTRACTCUR, "導出游標"
    IDS_CANTEXTRACTCUR, "導出游標失敗。"
    IDS_RESFILTER, "二進位制資源 (*.res)|*.res|全部文件 (*.*)|*.*|"
    IDS_NEUTRAL, "十進位制"
    IDS_IMPORTRES, "導入"
    IDS_CANNOTIMPORT, "導入資源失敗。"
    IDS_COMPILE, "編譯 (F8)"
    IDS_CANCELEDIT, "取消編輯 (Ctrl+E)"
    IDS_GUIEDIT, "GUI編輯模式 (Ctrl+G)"
    IDS_CANNOTSTARTUP, "編譯器啟動失敗。"
    IDS_RESMISMATCH, "資源類型不匹配。"
    IDS_SAMPLETEXT, "這是一個模板"
    IDS_ALREADYEXISTS, "已存在。"
    IDS_KEY, "鍵"
    IDS_FLAGS, "標識"
    IDS_COMMANDID, "控制項 ID"
    IDS_INVALIDKEY, "無效的鍵。"
    IDS_COMPILEERROR, "編譯失敗。"
    IDS_STRINGID, "字元型 ID"
    IDS_STRINGVALUE, "字元的值"
    IDS_CAPTION, "標題"
    IDS_HELPID, "幫助 ID"
    IDS_INDENT, "» "
    IDS_DATAISEMPTY, "數據為空。"
    IDS_TEST, "測試一下效果"
    IDS_SEPARATOR, "---"
    IDS_COMPILENOW, "文件已經改變，編譯?"
    IDS_RADWINDOW, "編輯對話框"
    IDS_ENTERCLASS, "請輸入有效的window類名。"
    IDS_TEXTEDIT, "由Text編輯 (Ctrl+T)"
    IDS_CURSORINFO, "圖片 #%u: 寬度 %u, 高度 %u, bit像素點 %u, xHotSpot %u, yHotSpot %u, ID %u\r\n"
    IDS_IMAGECOUNT, "圖片數量: %u\r\n"
    IDS_ICONINFO, "圖片 #%u: 寬度 %u, 高度 %u, bit像素點 %u, ID %u\r\n"
    IDS_READY, "準備"
    IDS_EXECUTINGCMD, "導出命令..."
    IDS_EDITINGBYGUI, "正由GUI編輯..."
    IDS_COORD, "%d, %d, %d, %d"
    IDS_STARTING, "開始..."
    IDS_COMPILING, "編譯..."
    IDS_CANNOTLOAD, "載入失敗。"
    IDS_NONE, "(空)"
    IDS_WAVESOUND, "(聲波)\r\n"
    IDS_IDTYPE, "ID 類型"
    IDS_IDPREFIX, "ID 前綴"
    IDS_EMPTYSTR, "輸入字元。"
    IDS_ANICURSOR, "(動態游標)\r\n"
    IDS_ANIICON, "(動態圖示)\r\n"
    IDS_HEADFILTER, "頭文件 (*.h)|*.h|全部文件 (*.*)|*.*|"
    IDS_LOADRESH, "載入 ""resource.h"" 文件"
    IDS_NAME, "名稱"
    IDS_VALUE, "值"
    IDS_NOSUCHID, "沒有該ID。"
    IDS_IMAGEINFO, "寬度 %u, 高度 %u, 二進位制像素 %u\r\n"
    IDS_ENTERINT, "請輸入有效整數。"
    IDS_ENTERTEXT, "請輸入有效文本。"
    IDS_ENTERID, "請輸入有效 ID。"
    IDS_ADDNEXTIDS, "請添加下面ID到 ""resource.h"":\r\n\r\n"
    IDS_DELETENEXTIDS, "請從這裡刪除ID ""resource.h"":\r\n\r\n"
    IDS_NOCHANGE, "資源ID沒有改變。"
    IDS_DLGFAIL, "喲，RAD製作失敗。"
    IDS_LOADWCLIB, "載入Window類資源"
    IDS_AVIMOVIE, "(AVI 影片)\r\n"
    IDS_ADDDIALOG, "添加對話框"
    IDS_ADDMENU, "添加菜單"
    IDS_ADDVERINFO, "添加版本資訊"
    IDS_ADDCURSOR, "添加游標"
    IDS_NOMOREITEM, "沒有更多的項目了。"
    IDS_INVALIDDATA, "(無效數據)\r\n"
    IDS_UPDATERESH, "確定更新 ""resource.h"" 嗎?"
    IDS_CANTWRITERESH, "無法寫入 ""resource.h""。"
    IDS_SAVERESH, "保存 ""resource.h"" 文件"
    IDS_DLLFILTER, "DLL 文件 (*.dll;*.ocx;*.mui)|*.dll;*.ocx;*.mui|全部文件 (*.*)|*.*|"
    IDS_EXERESRCFILTER, "可讀文件 (*.exe;*.dll;*.ocx;*.cpl;*.scr;*.mui;*.res;*.rc)|*.exe;*.dll;*.ocx;*.cpl;*.scr;*.mui;*.res;*.rc|資源配置文件 (*.exe;*.dll;*.ocx;*.cpl;*.scr;*.mui)|*.exe;*.dll;*.ocx;*.cpl;*.scr;*.mui|二進位制文件 (*.res)|*.res|資源文件 (*.rc)|*.rc|全部文件 (*.*)|*.*|"
    IDS_CANTTESTCHILDWND, "無法測試對話框, 因為它是一個子窗口。"
    IDS_CANTTESTCLASSDLG, "由於對話被分類, 所以不能被測試。"
    IDS_FILEISUPXED, "文件\r\n\r\n'%s'\r\n\r\n被UPX壓縮. 你想使用臨時文件解壓縮嗎?\r\n\r\n如果你沒有擴展它, 閱讀可能會失敗。"
    IDS_CANTUPXEXTRACT, "無法由UPX提取。"
    IDS_CANTSAVEUPXED, "無法保存文件, 因為它是由UPX壓縮的。"
    IDS_MESSAGEID, "消息 ID"
    IDS_MESSAGEVALUE, "消息值"
    IDS_RCFILTER, "RC 文件 (*.rc)|*.rc|"
    IDS_EXPORT, "導出"
    IDS_CANTEXPORT, "導出失敗。"
    IDS_MUSTBEEMPTYDIR, "如果有任何外部文件，則導出目標必須是空文件夾。"
    IDS_FULLWIDTH, "０１２３４５６７８９ＡＢＣＤＥＦＧＨＩＪＫＬＭＮＯＰＱＲＳＴＵＶＷＸＹＺａｂｃｄｅｆｇｈｉｊｋｌｍｎｏｐｑｒｓｔｕｖｗｘｙｚ－＿（）．　"
    IDS_HALFWIDTH, "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz-_(). "
    IDS_MACRONAME, "宏名稱"
    IDS_MACROVALUE, "宏值"
    IDS_OPTIONAL, "(可選的)"
    IDS_ADDINCLUDE, "添加包含目錄"
    IDS_EDITINCLUDE, "編輯包含目錄"
    IDS_WINDRESEXE, "windres.exe|windres.exe|"
    IDS_CPPEXE, "cpp.exe|cpp.exe|"
    IDS_INVALIDPATH, "該路徑無效。"
    IDS_DATATOOLONG, "數據太長。"
    IDS_ALL, "(所有)"
    IDS_UNKNOWNFORMAT, "(未知的數據格式)\r\n"
    IDS_LANGUAGE, "語言"
    IDS_INTVALUE, "整數值"
    IDS_PARENTWND, "家長測試窗口"
    IDS_CHOOSE_OLE_CLSID, "選擇OLE CLSID"
    IDS_CONTROL, "控制"
    IDS_MESSAGE, "資訊"
    IDS_STRING, "串"
    IDS_DATAISINVALID, "數據無效。"
    IDS_DLGINIT1, "您可以透過在與對話框同名的RT_DLGINIT資源數據中設置初始化數據來指定組合框和列表框的初始化。"
    IDS_DLGINIT2, "當WM_INITDIALOG消息到達時, 您可以透過調用附加文件“DlgInit/DlgInit.h”的ExecuteDlgInitDx函數來初始化對話框。\r\n\r\n"
    IDS_DLGINIT3, "請指定用換行符分隔的RT_DLGINIT字串列表。"
    IDS_SAMELANG, "這是相同的語言。"
    IDS_SAMENAME, "這是相同的資源名稱。"
    IDS_CANTSAVETOEXE, "無法從非可執行文件保存為EXE。"
    IDS_CANTSTARTSEARCH, "無法開始搜索。"
    IDS_AMERICA, "美國"
    IDS_ENGLISH, "英語"
    IDS_CHINA, "中國"
    IDS_CHINESE, "中文"
    IDS_RUSSIA, "俄國"
    IDS_RUSSIAN, "俄語"
    IDS_WANNAGENRESH, "你想生成文件 'resource.h' 嗎?"
    IDS_EXEFILTER, "資源配置文件 (*.exe;*.dll;*.ocx;*.cpl;*.scr;*.mui)|*.exe;*.dll;*.ocx;*.cpl;*.scr;*.mui|全部文件 (*.*)|*.*|"
    IDS_SAVEASCOMPRESS, "另存壓縮"
    IDS_TOOL_NEW, "新建"
    IDS_TOOL_OPEN, "打開..."
    IDS_TOOL_SAVE, "另存為..."
    IDS_TOOL_EXPAND, "全部展開"
    IDS_TOOL_COLLAPSE, "全部摺疊"
    IDS_TOOL_PLUS, "新增項目..."
    IDS_TOOL_MINUS, "刪除項目"
    IDS_TOOL_CHANGE, "更改名稱/語言"
    IDS_TOOL_CLONE, "複製為其他名稱/語言"
    IDS_TOOL_RECOMPILE, "重新編譯"
    IDS_TOOL_CANCELEDIT, "取消修改"
    IDS_TOOL_IMPORT, "導入..."
    IDS_TOOL_EXTRACT, "導出..."
    IDS_TOOL_GUIEDIT, "GUI編輯"
    IDS_UNITEDKINGDOM, "英國"
    IDS_GREATBRITAIN, "大不列顛"
    IDS_BRITISH, "英國的"
    IDS_FRANCE, "法國"
    IDS_FRENCH, "法語"
    IDS_GERMANY, "德國"
    IDS_GERMAN, "德語"
    IDS_SPAIN, "西班牙"
    IDS_SPANISH, "西班牙語"
    IDS_INVALIDLANG, "無法識別的語言。"
    IDS_INVALIDNAME, "資源名稱無效。"
    IDS_PNGRESBINFILTER, "PNG圖片 (*.png)|*.png|資源文件(*.res)|*.res|二進位制文件 (*.bin)|*.bin|全部文件 (*.*)|*.*|"
    IDS_JPEGRESBINFILTER, "JPEG圖片 (*.jpg;*.jpeg;*.jpe;*.jfif)|*.jpg;*.jpeg;*.jpe;*.jfif|資源文件(*.res)|*.res|二進位制文件 (*.bin)|*.bin|全部文件 (*.*)|*.*|"
    IDS_GIFRESBINFILTER, "GIF圖片 (*.gif)|*.gif|資源文件(*.res)|*.res|二進位制文件 (*.bin)|*.bin|全部文件 (*.*)|*.*|"
    IDS_TIFFRESBINFILTER, "TIFF圖片 (*.tif;*.tiff)|*.tif;*.tiff|資源文件(*.res)|*.res|二進位制文件 (*.bin)|*.bin|全部文件 (*.*)|*.*|"
    IDS_AVIRESBINFILTER, "AVI影片 (*.avi)|*.avi|資源文件(*.res)|*.res|二進位制文件 (*.bin)|*.bin|全部文件 (*.*)|*.*|"
    IDS_WAVERESBINFILTER, "WAVE聲音 (*.wav)|*.wav|資源文件(*.res)|*.res|二進位制文件 (*.bin)|*.bin|全部文件 (*.*)|*.*|"
    IDS_COMMENT_SEP, "//////////////////////////////////////////////////////////////////////////////\r\n\r\n"
    IDS_NEWLINE, "\r\n"
    IDS_NOTICE, "// This file is automatically generated by RisohEditor 5.7.9.\r\n"
    IDS_DAGGER, "// † <-- This dagger helps UTF-8 detection.\r\n"
    IDS_IMPORTFILTER, "可導入文件|*.rc;*.res;*.dfm;*.html;*.htm;*.manifest;*.ico;*.cur;*.ani;*.wav;*.bmp;*.dib;*.png;*.gif;*.jpg;*.jpeg;*.jpe;*.jfif;*.tif;*.tiff;*.avi;*.wmf;*.emf|RC 文件 (*.rc)|*.rc|二進位制資源文件 (*.res)|*.res|圖片文件|*.bmp;*.dib;*.png;*.gif;*.jpg;*.jpeg;*.jpe;*.jfif;*.tif;*.tiff;*.wmf;*.emf;*.tlb|游標文件(*.cur;*.ani)|*.cur;*.ani|圖示文件 (*.ico)|*.ico|WAVE聲音 (*.wav)|*.wav|HTML文件 (*.html;*.htm)|*.html;*.htm|清單文件 (*.manifest)|*.manifest|Delphi DFM Files (*.dfm)|*.dfm|Delphi DFM 文件 (*.dfm)|*.dfm|TYPELIB Files (*.tlb)|*.tlb|全部文件 (*.*)|*.*|"
    IDS_CANTWRITEBYLOCK, "無法寫入檔案, 因為以下文件已被鎖定。\r\n\r\n%s"
    IDS_ANSI, "ANSI"
    IDS_WIDE, "Unicode"
    IDS_UTF8, "UTF-8 (with BOM)"
    IDS_UTF8N, "UTF-8 (without BOM)"
    IDS_SJIS, "Shift_JIS"
    IDS_BINARY, "(二進位制數據)"
    IDS_RESTYPE, "資源類型"
    IDS_ENCODING, "編碼"
    IDS_INVALIDRESTYPE, "資源類型無效。"
    IDS_PATHSPACEERROR, "您錯誤地使用空格字元安裝了該位置！ 資源編譯器不能接受空間。\n\n請避免使用“C:\\Program Files”。"
    IDS_LOADEGAPROGRAM, "載入EGA程序..."
    IDS_EGAFILTER, "EGA 計劃 (*.ega)|*.ega|全部文件 (*.*)|*.*|"
    IDS_QUERYSAVECHANGE, "該文件已被修改. 您要立即保存更改嗎？"
    IDS_DFMFILTER, "DFM 文件 (*.dfm)|*.dfm|文字檔案 (*.txt)|*.txt|全部文件 (*.*)|*.*|"
    IDS_CANTEXTRACTDFM, "無法提取DFM數據。"
    IDS_EXTRACTDFM, "提取DFM數據"
    IDS_ENTERNONZERONAME, "請輸入不為零的資源名稱。"
    IDS_ENTERNONZEROTYPE, "請輸入不為零的資源類型名稱。"
    IDS_HOMEPAGE, "https://katahiromz.web.fc2.com/re/ch/"
    IDS_FILESAVED, "文件保存確定。"
    IDS_RECOMPILEOK, "重新編譯。"
    IDS_RECOMPILEFAILED, "重新編譯失敗 (語法錯誤)。"
    IDS_TOOL_EXPORT, "導出..."
    IDS_CODEEDITOR, "代碼編輯器"
    IDS_HEXVIEWER, "十六進位制查看器"
    IDS_INTEGERORIDENTIFIER, "(整形或標識符)"
    IDS_NOTEXT, " "
    IDS_NOUPDATE, "您正使用最新版本。"
    IDS_THEREISUPDATE, "有一個可以更新的 RisohEditor %s。 您想立即下載更新嗎？"
    IDS_CANTCHECKUPDATE, "檢查更新失敗。"
    IDS_CODEPAGE1252, "1252 (拉丁1)"
    IDS_CODEPAGE1250, "1250 (拉丁2)"
    IDS_CODEPAGE1251, "1251 (西里爾)"
    IDS_CODEPAGE1253, "1253 (希臘語)"
    IDS_CODEPAGE1254, "1254 (土耳其)"
    IDS_CODEPAGE1255, "1255 (希伯來語)"
    IDS_CODEPAGE1256, "1256 (阿拉伯)"
    IDS_CODEPAGE1257, "1257 (波羅的海)"
    IDS_CODEPAGE874, "874 (泰語)"
    IDS_CODEPAGE932, "932 (日本語)"
    IDS_CODEPAGE936, "936 (簡體中文)"
    IDS_CODEPAGE949, "949 (韓語)"
    IDS_CODEPAGE950, "950 (繁體中文)"
    IDS_CODEPAGE65001, "65001 (UTF-8)"
    IDS_EXTRACTTLB, "Extract TYPELIB data"
    IDS_CANTEXTRACTTLB, "Unable to extract the TYPELIB data."
    IDS_TLBRESBINFILTER, "TYPELIB data (*.tlb)|*.tlb|Binary Resources (*.res)|*.res|Text Files (*.txt)|*.txt|MIDL Files (*.idl)|*.idl|All Files (*.*)|*.*|"
    IDS_USAGE, "Usage: RisohEditor [options | ""file""]\n\nOptions:\n--help  Show this message.\n--version  Show version info.\n--load ""your-file.rc""  Load the file (without GUI)\n--save ""your-file.res""  Save the file (without GUI)\n--log-file ""log-file.txt""  Specify the log file.\n--load-options OPTIONS  Set load options.\n--save-options OPTIONS  Set save options.\n\nLoad options: (no-load-res-h)\nSave options: (idc-static)(compress)(sep-lang)(no-res-folder)(lang-macro)(less-comments)(wrap-manifest)(begin-end)(utf-16)(backup)(ms-msgtbl)"
    IDS_NOSELECTION, "沒有選擇。"
    IDS_TRANSLATORS, "[Translators]\r\nEnglish: Katayama Hirofumi MZ\r\nFinnish: Veikko Muurikainen\r\nIndonesian: Mas Ahmad Muhammad\r\nItalian: R.B.\r\nJapanese: Katayama Hirofumi MZ\r\nKorean: VenusGirl (비너스걸)\r\nPolish: Piotr Hetnarowicz\r\nPortuguese: JNylson\r\nRussian: Dmitry Yerokhin\r\nSimplified Chinese: 林鴻湘\r\n"
}

//////////////////////////////////////////////////////////////////////////////

```

`src/pstdbool.h`:

```h
/* pstdbool.h --- MZC4 portable standard boolean */
/* Written by katahiromz <katayama.hirofumi.mz@gmail.com>. */
/* You can use this as replacement of <stdbool.h> and <cstdbool>. */
/* This file is public domain software (PDS). */
#ifndef __bool_true_false_are_defined
    #ifdef __cplusplus
        /* already defined */
    #elif defined(__STDC_VERSION__) && (__STDC_VERSION__ >= 199901L)
        #include <stdbool.h>
    #else
        #define true        1
        #define false       0
        typedef signed char bool;
    #endif
    #define __bool_true_false_are_defined   1
#endif  /* ndef __bool_true_false_are_defined */

```

`src/pstdint.h`:

```h
/* pstdint.h -- portable standard integers                      -*- C++ -*- */
/* This file is part of MZC4.  See file "ReadMe.txt" and "License.txt". */
/****************************************************************************/

#ifndef MZC4_PSTDINT_H_
#define MZC4_PSTDINT_H_     18   /* Version 18 */

#if __cplusplus >= 201103L
    #include <cstdint>
#elif __STDC_VERSION__ >= 199901L
    #include <stdint.h>
#elif defined(_WIN32) && !defined(WONVER)
    #ifndef _INC_WINDOWS
        #include <windows.h>
    #endif
    typedef signed char int8_t;
    typedef SHORT       int16_t;
    typedef INT         int32_t;
    typedef LONGLONG    int64_t;
    typedef BYTE        uint8_t;
    typedef WORD        uint16_t;
    typedef UINT        uint32_t;
    typedef DWORDLONG   uint64_t;
    typedef INT_PTR     intptr_t;
    typedef UINT_PTR    uintptr_t;
#else
    #ifdef __cplusplus
        #include <cstddef>
        #include <climits>
    #else
        #include <stddef.h>
        #include <limits.h>
    #endif
    #ifndef INT8_MIN
        #define INT8_MIN (-128)
        #define INT8_MAX 127
        #define UINT8_MAX 0xFF
    #endif
    #ifndef INT16_MIN
        #define INT16_MIN (-32768)
        #define INT16_MAX 32767
        #define UINT16_MAX 0xFFFF
    #endif
    #ifndef INT32_MIN
        #define INT32_MIN (-2147483647 - 1)
        #define INT32_MAX 2147483647
        #define UINT32_MAX 0xFFFFFFFF
    #endif
    typedef signed char                 int8_t;
    typedef unsigned char               uint8_t;
    typedef short                       int16_t;
    typedef unsigned short              uint16_t;
    #ifdef MSDOS
        typedef long                    int32_t;
        typedef unsigned long           uint32_t;
        typedef int                     intptr_t;
        typedef unsigned int            uintptr_t;
    #else
        typedef int                     int32_t;
        typedef unsigned int            uint32_t;
        #ifndef INT64_MAX
            #ifdef _I64_MAX
                #define INT64_MIN _I64_MIN
                #define INT64_MAX _I64_MAX
                #define UINT64_MAX _UI64_MAX
                typedef __int64             int64_t;
                typedef unsigned __int64    uint64_t;
                typedef __int64             intptr_t;
                typedef unsigned __int64    uintptr_t;
            #else
                #if defined(__LP64__) && !defined(__APPLE__)
                    #define INT64_MIN (-9223372036854775807L - 1)
                    #define INT64_MAX 9223372036854775807L
                    #define UINT64_MAX 0xFFFFFFFFFFFFFFFFL
                    typedef long           int64_t;
                    typedef unsigned long  uint64_t;
                #else
                    #define INT64_MIN (-9223372036854775807LL - 1)
                    #define INT64_MAX 9223372036854775807LL
                    #define UINT64_MAX 0xFFFFFFFFFFFFFFFFLL
                    typedef long long           int64_t;
                    typedef unsigned long long  uint64_t;
                #endif
                typedef long           intptr_t;
                typedef unsigned long  uintptr_t;
            #endif
        #endif
    #endif
#endif

typedef char MZC4_PSTDINT_TEST_01_[(sizeof(int8_t) == 1) ? 1 : -1];
typedef char MZC4_PSTDINT_TEST_02_[(sizeof(uint8_t) == 1) ? 1 : -1];
typedef char MZC4_PSTDINT_TEST_03_[(sizeof(int16_t) == 2) ? 1 : -1];
typedef char MZC4_PSTDINT_TEST_04_[(sizeof(uint16_t) == 2) ? 1 : -1];
typedef char MZC4_PSTDINT_TEST_05_[(sizeof(int32_t) == 4) ? 1 : -1];
typedef char MZC4_PSTDINT_TEST_06_[(sizeof(uint32_t) == 4) ? 1 : -1];
#ifndef MSDOS
    typedef char MZC4_PSTDINT_TEST_07_[(sizeof(int64_t) == 8) ? 1 : -1];
    typedef char MZC4_PSTDINT_TEST_08_[(sizeof(uint64_t) == 8) ? 1 : -1];
#endif
typedef char MZC4_PSTDINT_TEST_09_[(sizeof(intptr_t) == sizeof(void *)) ? 1 : -1];
typedef char MZC4_PSTDINT_TEST_10_[(sizeof(uintptr_t) == sizeof(void *)) ? 1 : -1];

/****************************************************************************/

#endif  /* ndef MZC4_PSTDINT_H_ */

```

`src/res/1028_RISOHTEMPLATE_4.bin`:

```bin
1 MENU
{
    POPUP "文件(&F)"
    {
        MENUITEM "退出(&X)\tAlt+F4", 100
    }
}

```

`src/res/1028_RISOHTEMPLATE_5.bin`:

```bin
1 DIALOG 0, 0, 215, 135
STYLE DS_CENTER | DS_MODALFRAME | WS_POPUP | WS_CAPTION | WS_SYSMENU
CAPTION "示例对话框"
FONT 9, "宋体"
{
    CONTROL "OK", IDOK, "BUTTON", BS_DEFPUSHBUTTON | WS_CHILD | WS_VISIBLE | WS_TABSTOP, 35, 115, 60, 14
    CONTROL "取消", IDCANCEL, "BUTTON", BS_PUSHBUTTON | WS_CHILD | WS_VISIBLE | WS_TABSTOP, 115, 115, 60, 14
}

```

`src/res/1031_RISOHTEMPLATE_4.bin`:

```bin
1 MENU
{
    POPUP "&Datei"
    {
        MENUITEM "Ausgang\tAlt+F4", 100
    }
}

```

`src/res/1031_RISOHTEMPLATE_5.bin`:

```bin
1 DIALOG 0, 0, 215, 135
STYLE DS_CENTER | DS_MODALFRAME | WS_POPUP | WS_CAPTION | WS_SYSMENU
CAPTION "Beispieldialog"
FONT 9, "MS Shell Dlg"
{
    CONTROL "OK", IDOK, "BUTTON", BS_DEFPUSHBUTTON | WS_CHILD | WS_VISIBLE | WS_TABSTOP, 35, 115, 60, 14
    CONTROL "Stornieren", IDCANCEL, "BUTTON", BS_PUSHBUTTON | WS_CHILD | WS_VISIBLE | WS_TABSTOP, 115, 115, 60, 14
}

```

`src/res/1033_RISOHTEMPLATE_4.bin`:

```bin
1 MENU
{
    POPUP "&File"
    {
        MENUITEM "E&xit\tAlt+F4", 100
    }
}

```

`src/res/1033_RISOHTEMPLATE_5.bin`:

```bin
1 DIALOG 0, 0, 215, 135
STYLE DS_CENTER | DS_MODALFRAME | WS_POPUP | WS_CAPTION | WS_SYSMENU
CAPTION "Sample Dialog"
FONT 9, "MS Shell Dlg"
{
    CONTROL "OK", IDOK, "BUTTON", BS_DEFPUSHBUTTON | WS_CHILD | WS_VISIBLE | WS_TABSTOP, 35, 115, 60, 14
    CONTROL "Cancel", IDCANCEL, "BUTTON", BS_PUSHBUTTON | WS_CHILD | WS_VISIBLE | WS_TABSTOP, 115, 115, 60, 14
}

```

`src/res/1035_RISOHTEMPLATE_4.bin`:

```bin
1 MENU
{
    POPUP "&File"
    {
        MENUITEM "E&xit\tAlt+F4", 100
    }
}

```

`src/res/1035_RISOHTEMPLATE_5.bin`:

```bin
1 DIALOG 0, 0, 215, 135
STYLE DS_CENTER | DS_MODALFRAME | WS_POPUP | WS_CAPTION | WS_SYSMENU
CAPTION "Sample Dialog"
FONT 9, "MS Shell Dlg"
{
    CONTROL "OK", IDOK, "BUTTON", BS_DEFPUSHBUTTON | WS_CHILD | WS_VISIBLE | WS_TABSTOP, 35, 115, 60, 14
    CONTROL "Cancel", IDCANCEL, "BUTTON", BS_PUSHBUTTON | WS_CHILD | WS_VISIBLE | WS_TABSTOP, 115, 115, 60, 14
}

```

`src/res/1036_RISOHTEMPLATE_4.bin`:

```bin
1 MENU
{
    POPUP "&Fichier"
    {
        MENUITEM "Sortie\tAlt+F4", 100
    }
}

```

`src/res/1036_RISOHTEMPLATE_5.bin`:

```bin
1 DIALOG 0, 0, 215, 135
STYLE DS_CENTER | DS_MODALFRAME | WS_POPUP | WS_CAPTION | WS_SYSMENU
CAPTION "Exemple de boîte de dialogue"
FONT 9, "MS Shell Dlg"
{
    CONTROL "OK", IDOK, "BUTTON", BS_DEFPUSHBUTTON | WS_CHILD | WS_VISIBLE | WS_TABSTOP, 35, 115, 60, 14
    CONTROL "Annuler", IDCANCEL, "BUTTON", BS_PUSHBUTTON | WS_CHILD | WS_VISIBLE | WS_TABSTOP, 115, 115, 60, 14
}

```

`src/res/1040_RISOHTEMPLATE_4.bin`:

```bin
1 MENU
{
    POPUP "&File"
    {
        MENUITEM "E&xit\tAlt+F4", 100
    }
}

```

`src/res/1040_RISOHTEMPLATE_5.bin`:

```bin
1 DIALOG 0, 0, 215, 135
STYLE DS_CENTER | DS_MODALFRAME | WS_POPUP | WS_CAPTION | WS_SYSMENU
CAPTION "Sample Dialog"
FONT 9, "MS Shell Dlg"
{
    CONTROL "OK", IDOK, "BUTTON", BS_DEFPUSHBUTTON | WS_CHILD | WS_VISIBLE | WS_TABSTOP, 35, 115, 60, 14
    CONTROL "Cancel", IDCANCEL, "BUTTON", BS_PUSHBUTTON | WS_CHILD | WS_VISIBLE | WS_TABSTOP, 115, 115, 60, 14
}

```

`src/res/1041_RISOHTEMPLATE_4.bin`:

```bin
1 MENU
{
    POPUP "ファイル(&F)"
    {
        MENUITEM "終了(&X)\tAlt+F4", 100
    }
}

```

`src/res/1041_RISOHTEMPLATE_5.bin`:

```bin
1 DIALOG 0, 0, 215, 135
STYLE DS_CENTER | DS_MODALFRAME | WS_POPUP | WS_CAPTION | WS_SYSMENU
CAPTION "サンプル ダイアログ"
FONT 9, "MS UI Gothic"
{
    CONTROL "OK", IDOK, "BUTTON", BS_DEFPUSHBUTTON | WS_CHILD | WS_VISIBLE | WS_TABSTOP, 35, 115, 60, 14
    CONTROL "キャンセル", IDCANCEL, "BUTTON", BS_PUSHBUTTON | WS_CHILD | WS_VISIBLE | WS_TABSTOP, 115, 115, 60, 14
}

```

`src/res/1042_RISOHTEMPLATE_4.bin`:

```bin
1 MENU
{
    POPUP "파일(&F)"
    {
        MENUITEM "종료(&X)\tAlt+F4", 100
    }
}

```

`src/res/1042_RISOHTEMPLATE_5.bin`:

```bin
1 DIALOG 0, 0, 215, 135
STYLE DS_CENTER | DS_MODALFRAME | WS_POPUP | WS_CAPTION | WS_SYSMENU
CAPTION "예제 대화상자"
FONT 9, "Gulim"
{
    CONTROL "확인", IDOK, "BUTTON", BS_DEFPUSHBUTTON | WS_CHILD | WS_VISIBLE | WS_TABSTOP, 35, 115, 60, 14
    CONTROL "취소", IDCANCEL, "BUTTON", BS_PUSHBUTTON | WS_CHILD | WS_VISIBLE | WS_TABSTOP, 115, 115, 60, 14
}

```

`src/res/1045_RISOHTEMPLATE_4.bin`:

```bin
1 MENU
{
    POPUP "&Plik"
    {
        MENUITEM "&Wyjście\tAlt+F4", 100
    }
}

```

`src/res/1045_RISOHTEMPLATE_5.bin`:

```bin
1 DIALOG 0, 0, 215, 135
STYLE DS_CENTER | DS_MODALFRAME | WS_POPUP | WS_CAPTION | WS_SYSMENU
CAPTION "Przykładowe okno dialogowe"
FONT 9, "MS Shell Dlg"
{
    CONTROL "OK", IDOK, "BUTTON", BS_DEFPUSHBUTTON | WS_CHILD | WS_VISIBLE | WS_TABSTOP, 35, 115, 60, 14
    CONTROL "Anuluj", IDCANCEL, "BUTTON", BS_PUSHBUTTON | WS_CHILD | WS_VISIBLE | WS_TABSTOP, 115, 115, 60, 14
}

```

`src/res/1046_RISOHTEMPLATE_4.bin`:

```bin
1 MENU
{
    POPUP "&Arquivo"
    {
        MENUITEM "Sa&ir\tAlt+F4", 100
    }
}

```

`src/res/1046_RISOHTEMPLATE_5.bin`:

```bin
1 DIALOG 0, 0, 215, 135
STYLE DS_CENTER | DS_MODALFRAME | WS_POPUP | WS_CAPTION | WS_SYSMENU
CAPTION "Diálogo de Amostra"
FONT 9, "MS Shell Dlg"
{
    CONTROL "OK", IDOK, "BUTTON", BS_DEFPUSHBUTTON | WS_CHILD | WS_VISIBLE | WS_TABSTOP, 35, 115, 60, 14
    CONTROL "Cancelar", IDCANCEL, "BUTTON", BS_PUSHBUTTON | WS_CHILD | WS_VISIBLE | WS_TABSTOP, 115, 115, 60, 14
}

```

`src/res/1049_RISOHTEMPLATE_4.bin`:

```bin
1 MENU
{
    POPUP "&Файл"
    {
        MENUITEM "В&ыход\tAlt+F4", 100
    }
}

```

`src/res/1049_RISOHTEMPLATE_5.bin`:

```bin
1 DIALOG 0, 0, 215, 135
STYLE DS_CENTER | DS_MODALFRAME | WS_POPUP | WS_CAPTION | WS_SYSMENU
CAPTION "Пример диалога"
FONT 9, "MS Shell Dlg"
{
    CONTROL "OK", IDOK, "BUTTON", BS_DEFPUSHBUTTON | WS_CHILD | WS_VISIBLE | WS_TABSTOP, 35, 115, 60, 14
    CONTROL "Отмена", IDCANCEL, "BUTTON", BS_PUSHBUTTON | WS_CHILD | WS_VISIBLE | WS_TABSTOP, 115, 115, 60, 14
}

```

`src/res/1057_RISOHTEMPLATE_4.bin`:

```bin
1 MENU
{
    POPUP "Be&rkas"
    {
        MENUITEM "K&eluar\tAlt+F4", 100
    }
}

```

`src/res/1057_RISOHTEMPLATE_5.bin`:

```bin
1 DIALOG 0, 0, 215, 135
STYLE DS_CENTER | DS_MODALFRAME | WS_POPUP | WS_CAPTION | WS_SYSMENU
CAPTION "Contoh Dialog"
FONT 9, "MS Shell Dlg"
{
    CONTROL "OK", IDOK, "BUTTON", BS_DEFPUSHBUTTON | WS_CHILD | WS_VISIBLE | WS_TABSTOP, 35, 115, 60, 14
    CONTROL "Batal", IDCANCEL, "BUTTON", BS_PUSHBUTTON | WS_CHILD | WS_VISIBLE | WS_TABSTOP, 115, 115, 60, 14
}

```

`src/res/2052_RISOHTEMPLATE_4.bin`:

```bin
1 MENU
{
    POPUP "文件(&F)"
    {
        MENUITEM "退出(&X)\tAlt+F4", 100
    }
}

```

`src/res/2052_RISOHTEMPLATE_5.bin`:

```bin
1 DIALOG 0, 0, 215, 135
STYLE DS_CENTER | DS_MODALFRAME | WS_POPUP | WS_CAPTION | WS_SYSMENU
CAPTION "示例对话框"
FONT 9, "宋体"
{
    CONTROL "OK", IDOK, "BUTTON", BS_DEFPUSHBUTTON | WS_CHILD | WS_VISIBLE | WS_TABSTOP, 35, 115, 60, 14
    CONTROL "取消", IDCANCEL, "BUTTON", BS_PUSHBUTTON | WS_CHILD | WS_VISIBLE | WS_TABSTOP, 115, 115, 60, 14
}

```

`src/res/999_105.bin`:

```bin
999

```

`src/res/Manifest_1.manifest`:

```manifest
<?xml version='1.0' encoding='UTF-8' standalone='yes'?>
<assembly xmlns='urn:schemas-microsoft-com:asm.v1' manifestVersion='1.0'>
  <trustInfo xmlns="urn:schemas-microsoft-com:asm.v3">
    <security>
      <requestedPrivileges>
        <requestedExecutionLevel level='asInvoker' uiAccess='false' />
      </requestedPrivileges>
    </security>
  </trustInfo>
  <dependency>
    <dependentAssembly>
      <assemblyIdentity type='Win32' name='Microsoft.Windows.Common-Controls' version='6.0.0.0' processorArchitecture='*' publicKeyToken='6595b64144ccf1df' language='*' />
    </dependentAssembly>
  </dependency>
</assembly>

```

`src/res/RCData_100.bin`:

```bin
DEADMENWALKING

```

`src/res/RISOHTEMPLATE_11.bin`:

```bin
#ifdef APSTUDIO_INVOKED
    #error Ap Studio cannot edit this message table.
#endif
#ifdef MCDX_INVOKED
MESSAGETABLEDX
{
    100, "Hello, world!\r\n"
    101, "This is a sample message."
}
#endif

```

`src/res/RISOHTEMPLATE_16.bin`:

```bin
VS_VERSION_INFO VERSIONINFO
FILEVERSION     0, 0, 0, 0
PRODUCTVERSION  0, 0, 0, 0
FILEOS          VOS_NT_WINDOWS32
FILETYPE        VFT_APP
{
    // English (U.S.)
    BLOCK "StringFileInfo"
    {
        BLOCK "040904E4"
        {
            VALUE "CompanyName", "My Company\0"
            VALUE "FileDescription", "My Application\0"
            VALUE "FileVersion", "0.0\0"
            VALUE "LegalCopyright", "Copyright (C) 2017 My Company. All rights reserved.\0"
            VALUE "ProductName", "My Product\0"
            VALUE "ProductVersion", "0.0\0"
        }
    }
    BLOCK "VarFileInfo"
    {
        // English (U.S.)
        VALUE "Translation", 0x0409, 0x04E4
    }
}

```

`src/res/RISOHTEMPLATE_23.bin`:

```bin
<!DOCTYPE html>
<html lang="en"><head>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
    <title>This is a title</title>
</head>
<body>
<h1>Sample</h1>
<p>This is a sample</p>
</body></html>

```

`src/res/RISOHTEMPLATE_24.bin`:

```bin
<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<assembly xmlns="urn:schemas-microsoft-com:asm.v1" manifestVersion="1.0">
  <trustInfo xmlns="urn:schemas-microsoft-com:asm.v3">
    <security>
      <requestedPrivileges>
        <requestedExecutionLevel level="asInvoker" uiAccess="false"></requestedExecutionLevel>
      </requestedPrivileges>
    </security>
  </trustInfo>
  <dependency>
    <dependentAssembly>
      <assemblyIdentity type="win32" name="Microsoft.Windows.Common-Controls" version="6.0.0.0" processorArchitecture="*" publicKeyToken="6595b64144ccf1df" language="*"></assemblyIdentity>
    </dependentAssembly>
  </dependency>
</assembly>

```

`src/res/RISOHTEMPLATE_241.bin`:

```bin
1 TOOLBAR 16, 16
{
    BUTTON IDOK
    SEPARATOR
    BUTTON IDCANCEL
}

```

`src/res/RISOHTEMPLATE_6.bin`:

```bin
STRINGTABLE
{
    100, "This is a sample text."
}

```

`src/res/RISOHTEMPLATE_9.bin`:

```bin
1 ACCELERATORS
{
    "N", 100, VIRTKEY, CONTROL
    "O", 101, VIRTKEY, CONTROL
}

```

`src/resource.h`:

```h
//{{NO_DEPENDENCIES}}
// Microsoft Visual C++ Compatible
// This file is automatically generated by RisohEditor 5.7.9.
// RisohEditor_res.rc

#define HID_TEST                            100
#define HID_SAMPLE                          2147483647

#define IDB_BMP                             100
#define IDB_CONTROLS                        101
#define IDB_TOOLBAR                         102

#define IDC_CURSORNS                        101
#define IDC_CURSORWE                        102
#define IDC_DUMMYCONTROLID1                 1000
#define IDC_DUMMYCONTROLID2                 1001

#define IDD_REPLACERES                      100
#define IDD_ADDICON                         101
#define IDD_REPLACEICON                     102
#define IDD_ADDBITMAP                       103
#define IDD_REPLACEBMP                      104
#define IDD_ADDRES                          105
#define IDD_ADDCURSOR                       106
#define IDD_REPLACECUR                      107
#define IDD_MENUTEST                        108
#define IDD_ADDKEY                          109
#define IDD_MODIFYKEY                       110
#define IDD_EDITACCEL                       111
#define IDD_ADDSTR                          112
#define IDD_MODIFYSTR                       113
#define IDD_STRINGS                         114
#define IDD_ADDMITEM                        115
#define IDD_MODIFYMITEM                     116
#define IDD_EDITMENU                        117
#define IDD_DLGPROP                         118
#define IDD_CTRLPROP                        119
#define IDD_ADDCTRL                         120
#define IDD_IDASSOC                         121
#define IDD_MODIFYASSOC                     122
#define IDD_IDLIST                          123
#define IDD_CONFIG                          124
#define IDD_ADDRESID                        125
#define IDD_MODIFYRESID                     126
#define IDD_ADVICERESH                      127
#define IDD_CLONEINNEWNAME                  128
#define IDD_CLONEINNEWLANG                  129
#define IDD_ITEMSEARCH                      130
#define IDD_VERSIONINFO                     140
#define IDD_ADDMSG                          141
#define IDD_MODIFYMSG                       142
#define IDD_MESSAGES                        143
#define IDD_FONTS                           144
#define IDD_MACROS                          145
#define IDD_ADDMACRO                        146
#define IDD_EDITMACRO                       147
#define IDD_CTRLDATA                        148
#define IDD_PATHS                           149
#define IDD_EXP_OPTIONS                     150
#define IDD_LANGS                           151
#define IDD_CHILD                           152
#define IDD_DLGINITEDIT                     153
#define IDD_ADDDLGINIT                      154
#define IDD_MODIFYDLGINIT                   155
#define IDD_STRINGLIST                      156
#define IDD_SAVE_OPTIONS                    157
#define IDD_ENCODING                        158
#define IDD_ADDENC                          159
#define IDD_MODIFYENC                       160
#define IDD_CONSTANT                        161
#define IDD_EGA                             162
#define IDD_FONTSUBST                       163
#define IDD_DROPDOWNPOPUP                   164
#define IDD_DFMSETTINGS                     165
#define IDD_UILANG                          166
#define IDD_COPYTOMULTILANG                 167
#define IDD_TOOLBARRES                      168
#define IDD_ADDTBBTN                        169
#define IDD_MODIFYTBBTN                     170
#define IDD_STRINGID                        "StringID"

#define IDI_MAIN                            100
#define IDI_ICO                             101
#define IDI_SMILY                           102
#define IDI_FIND                            103
#define IDI_FILE                            104
#define IDI_FOLDER                          105
#define IDI_PLAY                            106
#define IDI_DIAMOND                         107
#define IDI_MARK                            108
#define IDI_ARROW                           109
#define IDI_DFMICON                         110

#define IDR_MAINFRAME                       100
#define IDR_MAINMENU                        101
#define IDR_POPUPMENUS                      102
#define IDR_BOUNCEANICUR                    103
#define IDR_MAINACCEL                       104
#define IDR_UNKNOWNRESID                    105
#define IDR_TINYEXE                         106
#define IDR_TINYDLL                         107

#define IDS_APPNAME                         101
#define IDS_TITLEWITHFILE                   102
#define IDS_EXTRACTRES                      103
#define IDS_RESBINFILTER                    104
#define IDS_CANNOTSAVE                      105
#define IDS_REPLACERES                      106
#define IDS_ALLFILES                        107
#define IDS_ENTERTYPE                       108
#define IDS_ENTERNAME                       109
#define IDS_ENTERLANG                       110
#define IDS_FILENOTFOUND                    111
#define IDS_CANNOTREPLACE                   112
#define IDS_EXERESFILTER                    113
#define IDS_SAVEAS                          114
#define IDS_CANNOTADDICON                   115
#define IDS_ADDICON                         116
#define IDS_ICOFILTER                       117
#define IDS_REPLACEICO                      118
#define IDS_CANTREPLACEICO                  119
#define IDS_EXISTSOVERWRITE                 120
#define IDS_OPEN                            121
#define IDS_CANNOTOPEN                      122
#define IDS_ADDBMP                          123
#define IDS_BMPFILTER                       124
#define IDS_CANTREPLACEBMP                  125
#define IDS_REPLACEBMP                      126
#define IDS_ERRORCODE                       127
#define IDS_VERSIONINFO                     128
#define IDS_ADDRES                          129
#define IDS_CANNOTADDRES                    130
#define IDS_CANTADDBMP                      131
#define IDS_EXTRACTBMP                      132
#define IDS_CANTEXTRACTBMP                  133
#define IDS_CANTREPLACECUR                  134
#define IDS_CANNOTADDCUR                    135
#define IDS_CURFILTER                       136
#define IDS_ADDCUR                          137
#define IDS_REPLACECUR                      138
#define IDS_EXTRACTICO                      139
#define IDS_CANTEXTRACTICO                  140
#define IDS_EXTRACTCUR                      141
#define IDS_CANTEXTRACTCUR                  142
#define IDS_RESFILTER                       143
#define IDS_NEUTRAL                         144
#define IDS_IMPORTRES                       145
#define IDS_CANNOTIMPORT                    146
#define IDS_COMPILE                         147
#define IDS_CANCELEDIT                      148
#define IDS_GUIEDIT                         149
#define IDS_CANNOTSTARTUP                   151
#define IDS_RESMISMATCH                     152
#define IDS_SAMPLETEXT                      153
#define IDS_ALREADYEXISTS                   154
#define IDS_KEY                             155
#define IDS_FLAGS                           156
#define IDS_COMMANDID                       157
#define IDS_INVALIDKEY                      158
#define IDS_COMPILEERROR                    159
#define IDS_STRINGID                        160
#define IDS_STRINGVALUE                     161
#define IDS_CAPTION                         162
#define IDS_HELPID                          163
#define IDS_INDENT                          164
#define IDS_DATAISEMPTY                     165
#define IDS_TEST                            166
#define IDS_SEPARATOR                       167
#define IDS_COMPILENOW                      168
#define IDS_RADWINDOW                       169
#define IDS_ENTERCLASS                      170
#define IDS_TEXTEDIT                        171
#define IDS_CURSORINFO                      172
#define IDS_IMAGECOUNT                      173
#define IDS_ICONINFO                        174
#define IDS_READY                           175
#define IDS_EXECUTINGCMD                    176
#define IDS_EDITINGBYGUI                    177
#define IDS_COORD                           178
#define IDS_STARTING                        179
#define IDS_COMPILING                       180
#define IDS_CANNOTLOAD                      181
#define IDS_NONE                            182
#define IDS_WAVESOUND                       183
#define IDS_IDTYPE                          184
#define IDS_IDPREFIX                        185
#define IDS_EMPTYSTR                        186
#define IDS_ANICURSOR                       187
#define IDS_ANIICON                         188
#define IDS_HEADFILTER                      189
#define IDS_LOADRESH                        190
#define IDS_NAME                            191
#define IDS_VALUE                           192
#define IDS_NOSUCHID                        193
#define IDS_IMAGEINFO                       194
#define IDS_ENTERINT                        195
#define IDS_ENTERTEXT                       196
#define IDS_ENTERID                         197
#define IDS_ADDNEXTIDS                      198
#define IDS_DELETENEXTIDS                   199
#define IDS_NOCHANGE                        200
#define IDS_DLGFAIL                         201
#define IDS_LOADWCLIB                       202
#define IDS_AVIMOVIE                        203
#define IDS_ADDDIALOG                       204
#define IDS_ADDMENU                         205
#define IDS_ADDVERINFO                      206
#define IDS_ADDCURSOR                       207
#define IDS_NOMOREITEM                      208
#define IDS_INVALIDDATA                     209
#define IDS_UPDATERESH                      210
#define IDS_CANTWRITERESH                   211
#define IDS_SAVERESH                        212
#define IDS_DLLFILTER                       213
#define IDS_EXERESRCFILTER                  214
#define IDS_CANTTESTCHILDWND                215
#define IDS_CANTTESTCLASSDLG                216
#define IDS_FILEISUPXED                     217
#define IDS_CANTUPXEXTRACT                  218
#define IDS_CANTSAVEUPXED                   219
#define IDS_MESSAGEID                       220
#define IDS_MESSAGEVALUE                    221
#define IDS_RCFILTER                        222
#define IDS_EXPORT                          223
#define IDS_CANTEXPORT                      224
#define IDS_MUSTBEEMPTYDIR                  225
#define IDS_FULLWIDTH                       226
#define IDS_HALFWIDTH                       227
#define IDS_MACRONAME                       228
#define IDS_MACROVALUE                      229
#define IDS_OPTIONAL                        230
#define IDS_ADDINCLUDE                      231
#define IDS_EDITINCLUDE                     232
#define IDS_WINDRESEXE                      233
#define IDS_CPPEXE                          234
#define IDS_INVALIDPATH                     235
#define IDS_DATATOOLONG                     236
#define IDS_ALL                             237
#define IDS_UNKNOWNFORMAT                   238
#define IDS_LANGUAGE                        239
#define IDS_INTVALUE                        240
#define IDS_PARENTWND                       241
#define IDS_CHOOSE_OLE_CLSID                242
#define IDS_CONTROL                         243
#define IDS_MESSAGE                         244
#define IDS_STRING                          245
#define IDS_DATAISINVALID                   246
#define IDS_DLGINIT1                        247
#define IDS_DLGINIT2                        248
#define IDS_DLGINIT3                        249
#define IDS_SAMELANG                        250
#define IDS_SAMENAME                        251
#define IDS_CANTSAVETOEXE                   252
#define IDS_CANTSTARTSEARCH                 253
#define IDS_AMERICA                         254
#define IDS_ENGLISH                         255
#define IDS_CHINA                           256
#define IDS_CHINESE                         257
#define IDS_RUSSIA                          258
#define IDS_RUSSIAN                         259
#define IDS_WANNAGENRESH                    260
#define IDS_EXEFILTER                       261
#define IDS_SAVEASCOMPRESS                  262
#define IDS_TOOL_NEW                        263
#define IDS_TOOL_OPEN                       264
#define IDS_TOOL_SAVE                       265
#define IDS_TOOL_EXPAND                     266
#define IDS_TOOL_COLLAPSE                   267
#define IDS_TOOL_PLUS                       268
#define IDS_TOOL_MINUS                      269
#define IDS_TOOL_CHANGE                     270
#define IDS_TOOL_CLONE                      271
#define IDS_TOOL_RECOMPILE                  272
#define IDS_TOOL_CANCELEDIT                 273
#define IDS_TOOL_IMPORT                     274
#define IDS_TOOL_EXTRACT                    275
#define IDS_TOOL_GUIEDIT                    276
#define IDS_UNITEDKINGDOM                   277
#define IDS_GREATBRITAIN                    278
#define IDS_BRITISH                         279
#define IDS_FRANCE                          280
#define IDS_FRENCH                          281
#define IDS_GERMANY                         282
#define IDS_GERMAN                          283
#define IDS_SPAIN                           284
#define IDS_SPANISH                         285
#define IDS_INVALIDLANG                     286
#define IDS_INVALIDNAME                     287
#define IDS_PNGRESBINFILTER                 288
#define IDS_JPEGRESBINFILTER                289
#define IDS_GIFRESBINFILTER                 290
#define IDS_TIFFRESBINFILTER                291
#define IDS_AVIRESBINFILTER                 292
#define IDS_WAVERESBINFILTER                293
#define IDS_COMMENT_SEP                     294
#define IDS_NEWLINE                         295
#define IDS_NOTICE                          296
#define IDS_DAGGER                          297
#define IDS_IMPORTFILTER                    298
#define IDS_CANTWRITEBYLOCK                 299
#define IDS_ANSI                            300
#define IDS_WIDE                            301
#define IDS_UTF8                            302
#define IDS_UTF8N                           303
#define IDS_SJIS                            304
#define IDS_BINARY                          305
#define IDS_RESTYPE                         306
#define IDS_ENCODING                        307
#define IDS_INVALIDRESTYPE                  308
#define IDS_PATHSPACEERROR                  309
#define IDS_LOADEGAPROGRAM                  310
#define IDS_EGAFILTER                       311
#define IDS_QUERYSAVECHANGE                 312
#define IDS_DFMFILTER                       313
#define IDS_CANTEXTRACTDFM                  314
#define IDS_EXTRACTDFM                      315
#define IDS_ENTERNONZERONAME                316
#define IDS_ENTERNONZEROTYPE                317
#define IDS_HOMEPAGE                        318
#define IDS_FILESAVED                       319
#define IDS_RECOMPILEOK                     320
#define IDS_RECOMPILEFAILED                 321
#define IDS_TOOL_EXPORT                     322
#define IDS_CODEEDITOR                      323
#define IDS_HEXVIEWER                       324
#define IDS_INTEGERORIDENTIFIER             325
#define IDS_NOTEXT                          326
#define IDS_NOUPDATE                        327
#define IDS_THEREISUPDATE                   328
#define IDS_CANTCHECKUPDATE                 329
#define IDS_CODEPAGE1252                    330
#define IDS_CODEPAGE1250                    331
#define IDS_CODEPAGE1251                    332
#define IDS_CODEPAGE1253                    333
#define IDS_CODEPAGE1254                    334
#define IDS_CODEPAGE1255                    335
#define IDS_CODEPAGE1256                    336
#define IDS_CODEPAGE1257                    337
#define IDS_CODEPAGE874                     338
#define IDS_CODEPAGE932                     339
#define IDS_CODEPAGE936                     340
#define IDS_CODEPAGE949                     341
#define IDS_CODEPAGE950                     342
#define IDS_CODEPAGE65001                   343
#define IDS_EXTRACTTLB                      344
#define IDS_CANTEXTRACTTLB                  345
#define IDS_TLBRESBINFILTER                 346
#define IDS_USAGE                           347
#define IDS_NOSELECTION                     348
#define IDS_TRANSLATORS                     349

#define ID_NEW                              100
#define ID_OPEN                             101
#define ID_SAVEAS                           102
#define ID_EXIT                             103
#define ID_ADDICON                          104
#define ID_ADDCURSOR                        105
#define ID_ADDBITMAP                        106
#define ID_ADDRES                           108
#define ID_REPLACEICON                      109
#define ID_REPLACECURSOR                    110
#define ID_REPLACEBITMAP                    111
#define ID_REPLACEBIN                       112
#define ID_DELETERES                        113
#define ID_EDIT                             114
#define ID_EXTRACTICON                      115
#define ID_EXTRACTCURSOR                    116
#define ID_EXTRACTBITMAP                    117
#define ID_EXTRACTBIN                       118
#define ID_ABOUT                            119
#define ID_TEST                             120
#define ID_IMPORT                           121
#define ID_COMPILE                          122
#define ID_CANCELEDIT                       123
#define ID_SHOWDIALOG                       124
#define ID_GUIEDIT                          125
#define ID_ADDCTRL                          126
#define ID_DELCTRL                          127
#define ID_CTRLPROP                         128
#define ID_DLGPROP                          129
#define ID_DESTROYRAD                       130
#define ID_CTRLINDEXTOP                     132
#define ID_CTRLINDEXBOTTOM                  133
#define ID_CTRLINDEXMINUS                   134
#define ID_CTRLINDEXPLUS                    135
#define ID_SHOWHIDEINDEX                    136
#define ID_TOPALIGN                         137
#define ID_BOTTOMALIGN                      138
#define ID_LEFTALIGN                        139
#define ID_RIGHTALIGN                       140
#define ID_TEXTEDIT                         141
#define ID_READY                            142
#define ID_STATUSBAR                        143
#define ID_BINARYPANE                       144
#define ID_ALWAYSCONTROL                    145
#define ID_MRUFILE0                         146
#define ID_MRUFILE1                         147
#define ID_MRUFILE2                         148
#define ID_MRUFILE3                         149
#define ID_MRUFILE4                         150
#define ID_MRUFILE5                         151
#define ID_MRUFILE6                         152
#define ID_MRUFILE7                         153
#define ID_MRUFILE8                         154
#define ID_MRUFILE9                         155
#define ID_MRUFILE10                        156
#define ID_MRUFILE11                        157
#define ID_MRUFILE12                        158
#define ID_MRUFILE13                        159
#define ID_MRUFILE14                        160
#define ID_MRUFILE15                        161
#define ID_PLAY                             162
#define ID_IDASSOC                          163
#define ID_LOADRESH                         164
#define ID_IDLIST                           165
#define ID_UNLOADRESH                       166
#define ID_HIDEIDMACROS                     167
#define ID_CONFIG                           168
#define ID_MODIFYASSOC                      169
#define ID_ADDRESID                         170
#define ID_MODIFYRESID                      171
#define ID_DELETERESID                      172
#define ID_COPYRESIDNAME                    173
#define ID_COPYIDDEF                        174
#define ID_ADVICERESH                       175
#define ID_UPDATEID                         176
#define ID_OPENREADME                       177
#define ID_OPENREADMEJP                     178
#define ID_LOADWCLIB                        179
#define ID_FIND                             180
#define ID_FINDDOWNWARD                     181
#define ID_FINDUPWARD                       182
#define ID_REPLACE                          183
#define ID_ADDMENU                          184
#define ID_ADDVERINFO                       185
#define ID_ADDDIALOG                        186
#define ID_FITTOGRID                        187
#define ID_COPYASNEWNAME                    188
#define ID_COPYASNEWLANG                    189
#define ID_ITEMSEARCH                       190
#define ID_UPDATERESHBANG                   192
#define ID_OPENLICENSE                      193
#define ID_DEBUGTREENODE                    194
#define ID_LOADRESHBANG                     195
#define ID_REFRESHDIALOG                    196
#define ID_IDJUMP                           197
#define ID_REFRESHALL                       198
#define ID_EXPORT                           199
#define ID_FONTS                            200
#define ID_REFRESH                          201
#define ID_PREDEFMACROS                     202
#define ID_ADD                              203
#define ID_MODIFY                           204
#define ID_DELETE                           205
#define ID_RENAME                           206
#define ID_ADDSTRINGTABLE                   207
#define ID_ADDMESSAGETABLE                  208
#define ID_ADDHTML                          209
#define ID_ADDACCEL                         210
#define ID_ADDMANIFEST                      211
#define ID_EDITLABEL                        212
#define ID_SETPATHS                         213
#define ID_SETDEFAULTS                      215
#define ID_BASE10                           216
#define ID_BASE16                           217
#define ID_CUT                              218
#define ID_COPY                             219
#define ID_PASTE                            220
#define ID_IDJUMP00                         221
#define ID_IDJUMP01                         222
#define ID_IDJUMP02                         223
#define ID_IDJUMP03                         224
#define ID_IDJUMP04                         225
#define ID_IDJUMP05                         226
#define ID_IDJUMP06                         227
#define ID_IDJUMP07                         228
#define ID_IDJUMP08                         229
#define ID_IDJUMP09                         230
#define ID_SHOWLANGS                        231
#define ID_SHOWHIDETOOLBAR                  232
#define ID_OPENHYOJUNKA                     233
#define ID_COPYRESIDVALUE                   234
#define ID_CHILDDESTROYED                   235
#define ID_USEIDC_STATIC                    236
#define ID_EXPAND_ALL                       237
#define ID_COLLAPSE_ALL                     238
#define ID_WORD_WRAP                        239
#define ID_SAVEASCOMPRESS                   241
#define ID_CLONE                            242
#define ID_ADDBANG                          243
#define ID_EXTRACTBANG                      245
#define ID_GUIDE                            246
#define ID_ENCODING                         247
#define ID_QUERYCONSTANT                    248
#define ID_USEBEGINEND                      249
#define ID_SAVE                             250
#define ID_EGA                              251
#define ID_EGA_PROGRAM                      252
#define ID_OPENREADMEIT                     253
#define ID_OPEN_EGA_MANUAL                  254
#define ID_DIALOG_FONT_SUBSTITUTES          255
#define ID_HELP                             256
#define ID_NEXTPANE                         257
#define ID_PREVPANE                         258
#define ID_EXTRACTRC                        259
#define ID_EXPORTRES                        260
#define ID_CHECKUPDATE                      261
#define ID_DFMSETTINGS                      262
#define ID_AUTOCOMPLETE                     263
#define ID_AUTOCOMPLETEDONE                 264
#define ID_OPENREADMEKO                     265
#define ID_USEMSMSGTBL                      266
#define ID_CHOOSEUILANG                     267
#define ID_COPYTOMULTILANG                  268
#define ID_OPENHISTORY                      269
#define ID_OPENHISTORYITA                   270
#define ID_OPENHISTORYJPN                   271
#define ID_OPENHISTORYKOR                   272
#define ID_ADDTOOLBAR                       273
#define ID_OPENREADMETR                     274
#define ID_OPENREADMEID                     275
#define ID_OPENHISTORYID                    276
#define ID_OPENREADMEPTB                    277
#define ID_OPENHISTORYPTB                   278

#define MSGID_HELLO                         101
#define MSGID_SAMPLE                        102

#define UNKNOWNRESID1                       999

#ifdef APSTUDIO_INVOKED
    #ifndef APSTUDIO_READONLY_SYMBOLS
        #define _APS_NO_MFC                 1
        #define _APS_NEXT_RESOURCE_VALUE    108
        #define _APS_NEXT_COMMAND_VALUE     279
        #define _APS_NEXT_CONTROL_VALUE     1002
        #define _APS_NEXT_SYMED_VALUE       300
    #endif
#endif

```

`src/svg/RisohEditor.svg`:

```svg
<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!-- Created with Inkscape (http://www.inkscape.org/) -->

<svg
   xmlns:dc="http://purl.org/dc/elements/1.1/"
   xmlns:cc="http://creativecommons.org/ns#"
   xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#"
   xmlns:svg="http://www.w3.org/2000/svg"
   xmlns="http://www.w3.org/2000/svg"
   xmlns:sodipodi="http://sodipodi.sourceforge.net/DTD/sodipodi-0.dtd"
   xmlns:inkscape="http://www.inkscape.org/namespaces/inkscape"
   width="256"
   height="256"
   viewBox="0 0 256 256"
   id="svg2"
   version="1.1"
   inkscape:version="0.91 r13725"
   sodipodi:docname="RisohEditor.svg">
  <defs
     id="defs4" />
  <sodipodi:namedview
     id="base"
     pagecolor="#ffffff"
     bordercolor="#666666"
     borderopacity="1.0"
     inkscape:pageopacity="0.0"
     inkscape:pageshadow="2"
     inkscape:zoom="0.35"
     inkscape:cx="-99.285714"
     inkscape:cy="291.42857"
     inkscape:document-units="px"
     inkscape:current-layer="layer1"
     showgrid="false"
     units="px"
     inkscape:snap-bbox="true"
     inkscape:bbox-paths="true"
     inkscape:bbox-nodes="true"
     inkscape:snap-bbox-edge-midpoints="true"
     inkscape:snap-bbox-midpoints="true"
     inkscape:object-paths="true"
     inkscape:snap-intersection-paths="true"
     inkscape:object-nodes="true"
     inkscape:snap-smooth-nodes="true"
     inkscape:snap-midpoints="true"
     inkscape:snap-others="true"
     inkscape:snap-object-midpoints="true"
     inkscape:snap-center="true"
     inkscape:snap-text-baseline="true"
     inkscape:snap-page="true"
     inkscape:snap-global="false"
     inkscape:window-width="1366"
     inkscape:window-height="705"
     inkscape:window-x="-8"
     inkscape:window-y="-8"
     inkscape:window-maximized="1" />
  <metadata
     id="metadata7">
    <rdf:RDF>
      <cc:Work
         rdf:about="">
        <dc:format>image/svg+xml</dc:format>
        <dc:type
           rdf:resource="http://purl.org/dc/dcmitype/StillImage" />
        <dc:title></dc:title>
      </cc:Work>
    </rdf:RDF>
  </metadata>
  <g
     inkscape:label="レイヤー 1"
     inkscape:groupmode="layer"
     id="layer1"
     transform="translate(0,-796.36216)">
    <rect
       style="opacity:1;fill:#00ff00;fill-opacity:1;stroke:none;stroke-width:10.90200043;stroke-linecap:square;stroke-linejoin:round;stroke-miterlimit:4;stroke-dasharray:none;stroke-dashoffset:0;stroke-opacity:0.50243901"
       id="rect3336"
       width="256"
       height="256"
       x="0"
       y="796.36218" />
    <path
       sodipodi:type="star"
       style="fill:#ffff00;fill-rule:evenodd;stroke:#f50000;stroke-width:16.654;stroke-linecap:butt;stroke-linejoin:miter;stroke-opacity:1;stroke-miterlimit:4;stroke-dasharray:none"
       id="path3338"
       sodipodi:sides="3"
       sodipodi:cx="144.00106"
       sodipodi:cy="938.32806"
       sodipodi:r1="126.94069"
       sodipodi:r2="63.470345"
       sodipodi:arg1="0.77383798"
       sodipodi:arg2="1.8210355"
       inkscape:flatsided="false"
       inkscape:rounded="0"
       inkscape:randomized="0"
       d="M 234.7933,1027.0451 128.28353,999.82151 21.773753,972.59796 98.604926,893.96957 175.4361,815.34117 205.1147,921.19311 Z"
       inkscape:transform-center-x="15.717517"
       inkscape:transform-center-y="-17.134964" />
  </g>
</svg>

```

`src/svg/arrow.svg`:

```svg
<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!-- Created with Inkscape (http://www.inkscape.org/) -->

<svg
   xmlns:dc="http://purl.org/dc/elements/1.1/"
   xmlns:cc="http://creativecommons.org/ns#"
   xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#"
   xmlns:svg="http://www.w3.org/2000/svg"
   xmlns="http://www.w3.org/2000/svg"
   xmlns:xlink="http://www.w3.org/1999/xlink"
   xmlns:sodipodi="http://sodipodi.sourceforge.net/DTD/sodipodi-0.dtd"
   xmlns:inkscape="http://www.inkscape.org/namespaces/inkscape"
   width="32"
   height="32"
   viewBox="0 0 8.4666663 8.4666662"
   version="1.1"
   id="svg8"
   inkscape:version="0.92.3 (2405546, 2018-03-11)"
   sodipodi:docname="arrow.svg"
   inkscape:export-filename="C:\Users\katahiromz\Desktop\arrow.png"
   inkscape:export-xdpi="90"
   inkscape:export-ydpi="90">
  <defs
     id="defs2" />
  <sodipodi:namedview
     id="base"
     pagecolor="#ffffff"
     bordercolor="#666666"
     borderopacity="1.0"
     inkscape:pageopacity="0.0"
     inkscape:pageshadow="2"
     inkscape:zoom="2.8"
     inkscape:cx="51.041882"
     inkscape:cy="-17.494617"
     inkscape:document-units="mm"
     inkscape:current-layer="layer1"
     showgrid="false"
     fit-margin-top="0"
     fit-margin-left="0"
     fit-margin-right="0"
     fit-margin-bottom="0"
     units="px"
     inkscape:window-width="1366"
     inkscape:window-height="705"
     inkscape:window-x="-8"
     inkscape:window-y="-8"
     inkscape:window-maximized="1" />
  <metadata
     id="metadata5">
    <rdf:RDF>
      <cc:Work
         rdf:about="">
        <dc:format>image/svg+xml</dc:format>
        <dc:type
           rdf:resource="http://purl.org/dc/dcmitype/StillImage" />
        <dc:title></dc:title>
      </cc:Work>
    </rdf:RDF>
  </metadata>
  <g
     inkscape:label="レイヤー 1"
     inkscape:groupmode="layer"
     id="layer1"
     transform="translate(1.5685941,-109.82619)">
    <image
       y="111.52882"
       x="-1.1664692"
       id="image18"
       xlink:href="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAG0AAABICAYAAAD8mXvTAAAABHNCSVQICAgIfAhkiAAAB8pJREFU
eJztnG9IG2kex3+TScZJMrG5Skuo1xIRJNnd7sZmF+we9CyCVKjU7frCdWGbwv5poBTTLjTZN9ZX
2jcbXxTSKxznvbn1zd167BXFpWy2sLtKbU3REhGK2fZ0w/aMEzXOZJI496KbJXaeRE0yM/kzn3fm
gZkffvQ7k+T7DMbzPJQ7odiKORT7xWz7Q1PAqDHQcs8jNmq5ByiUUGzF3Dz54Syd2DAaNQa6//VP
BvqaeoflnktMVHIPUChjy/4uOrFhBACgExtGV+BLb/Nk76z/14etMo8mGmUvjU5sGl99LUAv2k77
P/vug6kvvgqzqyY55hKTspeWi9Fnkz3W8e7gUHDELfcsxaTipOHYzhsrOrFh9MzdGrROdAcnwj+e
kWmsolJx0k7pNsBawwheX1gPWTruXxl/74fPvy73yKw4aRpsG97RbsJZwxqY1AnB+tiyv6vhbufS
UHDEzaY4UoYRC6bipKU5iCehnaLhlG4DtNj2jjU2xZHlHJkVKy2NmWDhXG0E3iC3BGuh2Iq54/6V
8Y77V8ZDsRWz9NPlR8VLAwAgMB5OkDE4Z4hAvZoTrE+EfzxjnegO3nhy50Y5RGZVSEtzAE9BGxWF
0/p1ZGQOPLnTb53oDo4t+7tkGnFPVJW0NEc1cTj/W2S++hYhFFsxv/fD51933L8yvrAessg0Yk6q
UhrAy/dzu0Vm87e9s565W4OlFplVKy0NpdqGNioKbVQUKJUwMoeCI+6Gu51Lo88me2QaUUDVS0tT
r+bgnCECbyEiM8yumj6Y+uKr0/7PviuFyFSkZYBjPLxFxuB8bQSOauKCdf+vD1utE91Bz9ytwfQ3
C3KgSEOgxbbhtH4d2qgoHMBTgvWh4IjbOt4dHFn6xiH9dIq0nNSrOThLrcEJMoaMzIsPBv528t7F
nwL0ok3KuRRpu4BjPLxBbsH52giYCVawPrU619I82TvrCnzplSoyFWl7RIttwyndBrRTNDIyhxf/
0Wcd7w7efvrPS2LPgqWLPQF60UZz8l1c8+XvP//nQua1pZ2ikZ/uF5t5VgfzcR1wPCZYa6k7PuW1
XXW11B2fEuPcGJOMkyfvOSTPZbGQShoAAMOr4BGrh6dx9HvvS43v3x5887Kn2A0x/I8f2T7+69K/
Py7mQeWkkWAFb5LFQoPxcEzDwRE1B5GUBhh+59VmZi349l+e/usSiRPxYv7Xqcr9W9xMtNg2HMKT
kp/3kDoJZw1r8I52EwhE3SHdEJtanWspxvkEvcejmjgcRFxoSx0ceDATrODWXEqsNQw0Eiw8YvSw
yGl3rAXoRdvJexd/cjR0jgwev+wxkXXhfM8jkHZMzUFjjfDWVmFvEBgPLbpNaCRYmGEN8CK581c8
svSNY+y//q7rlgs33VbHUD7nUG75ReKQOgkd1Bq06NCRma475FOqVaSJTBPBwPna1awNsXxKtYo0
CSAw/veG2CG18EZp9Nlkz34aYoo0CTmIv4zMP2mzN8Sav+2d3a0hpkiTgcaa7A2xvZRqFWkykdkQ
y1WqRTXEFGkycwBP5SzVphtimZGpSCsRzASbsyGWWapVpJUQ6YbYWWote0Ns8sNZRVoJki7Vtug2
BWt0YsNY9nuuK5EUj0EwroXHcR1yXZFWYiwnCZhhKIimcMGaiawL++wepyKtRGB4FUxtUfA8UYNc
d1sdQ9ctF24aNQZakSYzmVGYQlQXWg/b/b4THqel1ryQfk2RJiPLSQKmtwywuS28HzSRdWGv7Zqr
51j76KtrijQZ2NxWwfSWAZaThGCNxAm2r6l3uP+1TwdIHNHZA0WapKR4DObjOpiPa5FReMb07oTX
dtWVGYUoFGkS8TxRAw8YKmsU+uweZ1d969hejqVIE5loCocZhso7ClEo0kQixWPwOK6DYI4o9Nnd
TrP+SGi/xxZIi/I4hJOa/CaVEQLj4aAM9TkUzxM1MLVFCXqQAABm/ZGQz+52njG9O5Hv8QXS5lkd
zAP645NSp17NQRsVle380RQO04wB+UdP4gR73eK46bY4hvYThSjUpKqwA5QSy0kCIim15P9xXPqu
kEX/sXfVt455bVdd+UQhCuwX5n+mhrudS6W2GTxfpOzyAwCEOBIeMHpkFFpqzQte21VXIVGIAuN5
HhbWQ5bR56WzEXw/fP/i4Z8zu4NSSdstCvtf+3Sgr6l3uNAoRIGV+zOMbzy5c2PgyZ3+9M9iS+N4
DB6zegjGtcj1rvrWMZ/d4yyk9r0byi3/PngaJ+ERK20UolCk7YFISg3TjLCXDwBg1BjoQnr5+aBI
y8FuUdhzrH3Ua7vmEjMKUSjSsrDIaeERo0duz7XUmhd8JzzO1sN2v/STKdIEvEiqkVuUAF5GYSk8
91+R9hscjyE3A6YpxmbAYqFIg9xRaDM2BXx2j1OsJxXkQ1VLe5F8eVcYSZVuFKKoSmlyPUqiWFSd
tGBcC49ZdBSK/dCWYlE10sJJDcwwVNYoHHzzsudS4/u3ZRht31S8NIZXwQNGD6EsX2KUehSiqGhp
uz2/ymf3OG3GpoAMoxVERUoLJzUwzRiy9uEHj1/2OBo6R6SfrDhUnLRs1y0AgL6m3uH+1z8ZKKco
RFFx0lDCWg/b/V7bNVc5RiGKipOWSa4+fDlT9tKyFZMytwZJPZPYlL20V78eQW0NqjT+D7jKlY8b
wIUCAAAAAElFTkSuQmCC
"
       preserveAspectRatio="none"
       height="5.0614128"
       width="7.6624169" />
  </g>
</svg>

```

`src/svg/canceledit.svg`:

```svg
<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!-- Created with Inkscape (http://www.inkscape.org/) -->

<svg
   xmlns:dc="http://purl.org/dc/elements/1.1/"
   xmlns:cc="http://creativecommons.org/ns#"
   xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#"
   xmlns:svg="http://www.w3.org/2000/svg"
   xmlns="http://www.w3.org/2000/svg"
   xmlns:sodipodi="http://sodipodi.sourceforge.net/DTD/sodipodi-0.dtd"
   xmlns:inkscape="http://www.inkscape.org/namespaces/inkscape"
   width="32"
   height="32"
   viewBox="0 0 8.4666665 8.4666669"
   version="1.1"
   id="svg8"
   inkscape:version="0.92.3 (2405546, 2018-03-11)"
   sodipodi:docname="canceledit.svg"
   inkscape:export-filename="C:\Users\katahiromz\Desktop\bitmap.png"
   inkscape:export-xdpi="96"
   inkscape:export-ydpi="96">
  <defs
     id="defs2" />
  <sodipodi:namedview
     id="base"
     pagecolor="#ffffff"
     bordercolor="#666666"
     borderopacity="1.0"
     inkscape:pageopacity="0.0"
     inkscape:pageshadow="2"
     inkscape:zoom="5.6"
     inkscape:cx="67.943811"
     inkscape:cy="5.7464822"
     inkscape:document-units="mm"
     inkscape:current-layer="layer1"
     showgrid="true"
     units="px"
     inkscape:snap-text-baseline="true"
     inkscape:snap-center="true"
     inkscape:snap-object-midpoints="true"
     inkscape:snap-midpoints="true"
     inkscape:snap-smooth-nodes="true"
     inkscape:object-paths="true"
     inkscape:snap-intersection-paths="true"
     inkscape:snap-bbox="true"
     inkscape:bbox-paths="true"
     inkscape:bbox-nodes="true"
     inkscape:snap-bbox-edge-midpoints="true"
     inkscape:snap-bbox-midpoints="true"
     inkscape:window-width="1366"
     inkscape:window-height="705"
     inkscape:window-x="-8"
     inkscape:window-y="-8"
     inkscape:window-maximized="1"
     inkscape:snap-global="true">
    <inkscape:grid
       type="xygrid"
       id="grid10" />
  </sodipodi:namedview>
  <metadata
     id="metadata5">
    <rdf:RDF>
      <cc:Work
         rdf:about="">
        <dc:format>image/svg+xml</dc:format>
        <dc:type
           rdf:resource="http://purl.org/dc/dcmitype/StillImage" />
        <dc:title></dc:title>
      </cc:Work>
    </rdf:RDF>
  </metadata>
  <g
     inkscape:label="レイヤー 1"
     inkscape:groupmode="layer"
     id="layer1"
     transform="translate(0,-288.53332)">
    <rect
       style="fill:#0000ff;fill-opacity:0.10096154;stroke:none;stroke-width:1.05833328;stroke-miterlimit:4;stroke-dasharray:none;stroke-opacity:1"
       id="rect4543"
       width="8.4666662"
       height="8.4666662"
       x="-5.2041704e-016"
       y="288.53333" />
    <g
       id="g4541"
       transform="matrix(0.55023641,0,0,0.55550603,-1.2999053,130.86896)"
       style="fill:#00ffff">
      <path
         style="color:#000000;font-style:normal;font-variant:normal;font-weight:normal;font-stretch:normal;font-size:medium;line-height:normal;font-family:sans-serif;font-variant-ligatures:normal;font-variant-position:normal;font-variant-caps:normal;font-variant-numeric:normal;font-variant-alternates:normal;font-feature-settings:normal;text-indent:0;text-align:start;text-decoration:none;text-decoration-line:none;text-decoration-style:solid;text-decoration-color:#000000;letter-spacing:normal;word-spacing:normal;text-transform:none;writing-mode:lr-tb;direction:ltr;text-orientation:mixed;dominant-baseline:auto;baseline-shift:baseline;text-anchor:start;white-space:normal;shape-padding:0;clip-rule:nonzero;display:inline;overflow:visible;visibility:visible;opacity:1;isolation:auto;mix-blend-mode:normal;color-interpolation:sRGB;color-interpolation-filters:linearRGB;solid-color:#000000;solid-opacity:1;vector-effect:none;fill:#00ffff;fill-opacity:1;fill-rule:nonzero;stroke:#0d0000;stroke-width:2.11666679;stroke-linecap:butt;stroke-linejoin:miter;stroke-miterlimit:4;stroke-dasharray:none;stroke-dashoffset:0;stroke-opacity:1;color-rendering:auto;image-rendering:auto;shape-rendering:auto;text-rendering:auto;enable-background:accumulate"
         d="m 5.4065828,285.2995 -1.5285884,1.46502 4.6793004,4.67931 -4.6793004,4.67981 1.5285884,1.46452 4.6472612,-4.64727 4.64726,4.64727 1.529108,-1.46452 -4.679302,-4.67981 4.679302,-4.67931 -1.529108,-1.46502 -4.64726,4.64777 z"
         id="path4886-3"
         inkscape:connector-curvature="0" />
      <path
         style="color:#000000;font-style:normal;font-variant:normal;font-weight:normal;font-stretch:normal;font-size:medium;line-height:normal;font-family:sans-serif;font-variant-ligatures:normal;font-variant-position:normal;font-variant-caps:normal;font-variant-numeric:normal;font-variant-alternates:normal;font-feature-settings:normal;text-indent:0;text-align:start;text-decoration:none;text-decoration-line:none;text-decoration-style:solid;text-decoration-color:#000000;letter-spacing:normal;word-spacing:normal;text-transform:none;writing-mode:lr-tb;direction:ltr;text-orientation:mixed;dominant-baseline:auto;baseline-shift:baseline;text-anchor:start;white-space:normal;shape-padding:0;clip-rule:nonzero;display:inline;overflow:visible;visibility:visible;opacity:1;isolation:auto;mix-blend-mode:normal;color-interpolation:sRGB;color-interpolation-filters:linearRGB;solid-color:#000000;solid-opacity:1;vector-effect:none;fill:#00ffff;fill-opacity:1;fill-rule:nonzero;stroke:none;stroke-width:2.11666679;stroke-linecap:butt;stroke-linejoin:miter;stroke-miterlimit:4;stroke-dasharray:none;stroke-dashoffset:0;stroke-opacity:1;color-rendering:auto;image-rendering:auto;shape-rendering:auto;text-rendering:auto;enable-background:accumulate"
         d="m 5.4066466,285.2994 -1.5285889,1.46503 4.679301,4.67931 -4.679301,4.67981 1.5285889,1.46451 4.6472614,-4.64726 4.647262,4.64726 1.529106,-1.46451 -4.679302,-4.67981 4.679302,-4.67931 -1.529106,-1.46503 -4.647262,4.64778 z"
         id="path4886"
         inkscape:connector-curvature="0" />
    </g>
  </g>
</svg>

```

`src/svg/change.svg`:

```svg
<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!-- Created with Inkscape (http://www.inkscape.org/) -->

<svg
   xmlns:dc="http://purl.org/dc/elements/1.1/"
   xmlns:cc="http://creativecommons.org/ns#"
   xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#"
   xmlns:svg="http://www.w3.org/2000/svg"
   xmlns="http://www.w3.org/2000/svg"
   xmlns:sodipodi="http://sodipodi.sourceforge.net/DTD/sodipodi-0.dtd"
   xmlns:inkscape="http://www.inkscape.org/namespaces/inkscape"
   width="32"
   height="32"
   viewBox="0 0 8.4666665 8.4666669"
   version="1.1"
   id="svg8"
   inkscape:version="0.92.3 (2405546, 2018-03-11)"
   sodipodi:docname="change.svg"
   inkscape:export-filename="C:\Users\katahiromz\Desktop\bitmap.png"
   inkscape:export-xdpi="96"
   inkscape:export-ydpi="96">
  <defs
     id="defs2" />
  <sodipodi:namedview
     id="base"
     pagecolor="#ffffff"
     bordercolor="#666666"
     borderopacity="1.0"
     inkscape:pageopacity="0.0"
     inkscape:pageshadow="2"
     inkscape:zoom="11.2"
     inkscape:cx="26.734878"
     inkscape:cy="10.454829"
     inkscape:document-units="mm"
     inkscape:current-layer="layer1"
     showgrid="true"
     units="px"
     inkscape:snap-text-baseline="true"
     inkscape:snap-center="true"
     inkscape:snap-object-midpoints="true"
     inkscape:snap-midpoints="true"
     inkscape:snap-smooth-nodes="true"
     inkscape:object-paths="true"
     inkscape:snap-intersection-paths="true"
     inkscape:snap-bbox="true"
     inkscape:bbox-paths="true"
     inkscape:bbox-nodes="true"
     inkscape:snap-bbox-edge-midpoints="true"
     inkscape:snap-bbox-midpoints="true"
     inkscape:window-width="1366"
     inkscape:window-height="705"
     inkscape:window-x="-8"
     inkscape:window-y="-8"
     inkscape:window-maximized="1"
     inkscape:snap-global="true">
    <inkscape:grid
       type="xygrid"
       id="grid10" />
  </sodipodi:namedview>
  <metadata
     id="metadata5">
    <rdf:RDF>
      <cc:Work
         rdf:about="">
        <dc:format>image/svg+xml</dc:format>
        <dc:type
           rdf:resource="http://purl.org/dc/dcmitype/StillImage" />
        <dc:title></dc:title>
      </cc:Work>
    </rdf:RDF>
  </metadata>
  <g
     inkscape:label="レイヤー 1"
     inkscape:groupmode="layer"
     id="layer1"
     transform="translate(0,-288.53332)">
    <rect
       style="fill:#0000ff;fill-opacity:0.10096154;stroke:none;stroke-width:1.05833328;stroke-miterlimit:4;stroke-dasharray:none;stroke-opacity:1"
       id="rect4543"
       width="8.4666662"
       height="8.4666662"
       x="-5.2041704e-016"
       y="288.53333" />
    <path
       style="fill:#00ff00;fill-opacity:1;stroke:#000000;stroke-width:0.99999994;stroke-linecap:round;stroke-miterlimit:4;stroke-dasharray:none;stroke-opacity:1"
       d="M 13.474609 4.4863281 L 13.474609 11.626953 L 7.2910156 8.0566406 L 4.7675781 12.429688 L 10.951172 16 L 4.7675781 19.570312 L 7.2910156 23.943359 L 13.474609 20.373047 L 13.474609 27.513672 L 18.525391 27.513672 L 18.525391 20.373047 L 24.708984 23.943359 L 27.232422 19.570312 L 21.048828 16 L 27.232422 12.429688 L 24.708984 8.0566406 L 18.525391 11.626953 L 18.525391 4.4863281 L 13.474609 4.4863281 z "
       transform="matrix(0.26458333,0,0,0.26458333,0,288.53332)"
       id="rect4544-9" />
  </g>
</svg>

```

`src/svg/clone.svg`:

```svg
<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!-- Created with Inkscape (http://www.inkscape.org/) -->

<svg
   xmlns:dc="http://purl.org/dc/elements/1.1/"
   xmlns:cc="http://creativecommons.org/ns#"
   xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#"
   xmlns:svg="http://www.w3.org/2000/svg"
   xmlns="http://www.w3.org/2000/svg"
   xmlns:sodipodi="http://sodipodi.sourceforge.net/DTD/sodipodi-0.dtd"
   xmlns:inkscape="http://www.inkscape.org/namespaces/inkscape"
   width="32"
   height="32"
   viewBox="0 0 8.4666665 8.4666669"
   version="1.1"
   id="svg8"
   inkscape:version="0.92.3 (2405546, 2018-03-11)"
   sodipodi:docname="clone.svg"
   inkscape:export-filename="C:\Users\katahiromz\Desktop\bitmap.png"
   inkscape:export-xdpi="96"
   inkscape:export-ydpi="96">
  <defs
     id="defs2" />
  <sodipodi:namedview
     id="base"
     pagecolor="#ffffff"
     bordercolor="#666666"
     borderopacity="1.0"
     inkscape:pageopacity="0.0"
     inkscape:pageshadow="2"
     inkscape:zoom="11.2"
     inkscape:cx="26.120548"
     inkscape:cy="14.939909"
     inkscape:document-units="mm"
     inkscape:current-layer="layer1"
     showgrid="true"
     units="px"
     inkscape:snap-text-baseline="true"
     inkscape:snap-center="true"
     inkscape:snap-object-midpoints="true"
     inkscape:snap-midpoints="true"
     inkscape:snap-smooth-nodes="true"
     inkscape:object-paths="true"
     inkscape:snap-intersection-paths="true"
     inkscape:snap-bbox="true"
     inkscape:bbox-paths="true"
     inkscape:bbox-nodes="true"
     inkscape:snap-bbox-edge-midpoints="true"
     inkscape:snap-bbox-midpoints="true"
     inkscape:window-width="1366"
     inkscape:window-height="705"
     inkscape:window-x="-8"
     inkscape:window-y="-8"
     inkscape:window-maximized="1"
     inkscape:snap-global="true"
     inkscape:snap-others="false"
     inkscape:snap-page="true"
     inkscape:snap-nodes="false">
    <inkscape:grid
       type="xygrid"
       id="grid10" />
  </sodipodi:namedview>
  <metadata
     id="metadata5">
    <rdf:RDF>
      <cc:Work
         rdf:about="">
        <dc:format>image/svg+xml</dc:format>
        <dc:type
           rdf:resource="http://purl.org/dc/dcmitype/StillImage" />
        <dc:title></dc:title>
      </cc:Work>
    </rdf:RDF>
  </metadata>
  <g
     inkscape:label="レイヤー 1"
     inkscape:groupmode="layer"
     id="layer1"
     transform="translate(0,-288.53332)">
    <rect
       style="fill:#0000ff;fill-opacity:0.10096154;stroke:none;stroke-width:1.05833328;stroke-miterlimit:4;stroke-dasharray:none;stroke-opacity:1"
       id="rect4543"
       width="8.4666662"
       height="8.4666662"
       x="-5.2041704e-016"
       y="288.53333" />
    <path
       style="fill:#ff0000;fill-opacity:1;stroke:#000000;stroke-width:0.26640061;stroke-linecap:round;stroke-miterlimit:4;stroke-dasharray:none;stroke-opacity:1"
       d="m 1.9854084,289.46039 v 1.5875 H 0.39790846 v 1.32085 H 1.9854084 v 1.5875 h 1.3208497 v -1.5875 h 1.5875 v -1.32085 h -1.5875 v -1.5875 z"
       id="rect4592"
       inkscape:connector-curvature="0" />
    <path
       style="fill:#ff0000;fill-opacity:1;stroke:#000000;stroke-width:0.26640061;stroke-linecap:round;stroke-miterlimit:4;stroke-dasharray:none;stroke-opacity:1"
       d="m 5.1604086,292.10627 v 1.5875 h -1.5875 v 1.32085 h 1.5875 v 1.5875 h 1.3208497 v -1.5875 h 1.5875 v -1.32085 h -1.5875 v -1.5875 z"
       id="rect4592-0"
       inkscape:connector-curvature="0" />
  </g>
</svg>

```

`src/svg/collapse.svg`:

```svg
<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!-- Created with Inkscape (http://www.inkscape.org/) -->

<svg
   xmlns:dc="http://purl.org/dc/elements/1.1/"
   xmlns:cc="http://creativecommons.org/ns#"
   xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#"
   xmlns:svg="http://www.w3.org/2000/svg"
   xmlns="http://www.w3.org/2000/svg"
   xmlns:sodipodi="http://sodipodi.sourceforge.net/DTD/sodipodi-0.dtd"
   xmlns:inkscape="http://www.inkscape.org/namespaces/inkscape"
   width="32"
   height="32"
   viewBox="0 0 8.4666665 8.4666669"
   version="1.1"
   id="svg8"
   inkscape:version="0.92.3 (2405546, 2018-03-11)"
   sodipodi:docname="collapse.svg"
   inkscape:export-filename="C:\Users\katahiromz\Desktop\bitmap.png"
   inkscape:export-xdpi="96"
   inkscape:export-ydpi="96">
  <defs
     id="defs2" />
  <sodipodi:namedview
     id="base"
     pagecolor="#ffffff"
     bordercolor="#666666"
     borderopacity="1.0"
     inkscape:pageopacity="0.0"
     inkscape:pageshadow="2"
     inkscape:zoom="11.2"
     inkscape:cx="25.808048"
     inkscape:cy="15.090711"
     inkscape:document-units="mm"
     inkscape:current-layer="layer1"
     showgrid="true"
     units="px"
     inkscape:snap-text-baseline="true"
     inkscape:snap-center="true"
     inkscape:snap-object-midpoints="true"
     inkscape:snap-midpoints="true"
     inkscape:snap-smooth-nodes="true"
     inkscape:object-paths="true"
     inkscape:snap-intersection-paths="true"
     inkscape:snap-bbox="true"
     inkscape:bbox-paths="true"
     inkscape:bbox-nodes="true"
     inkscape:snap-bbox-edge-midpoints="true"
     inkscape:snap-bbox-midpoints="true"
     inkscape:window-width="1366"
     inkscape:window-height="705"
     inkscape:window-x="-8"
     inkscape:window-y="-8"
     inkscape:window-maximized="1"
     inkscape:snap-global="true"
     inkscape:snap-others="false"
     inkscape:snap-page="true"
     inkscape:snap-nodes="false">
    <inkscape:grid
       type="xygrid"
       id="grid10" />
  </sodipodi:namedview>
  <metadata
     id="metadata5">
    <rdf:RDF>
      <cc:Work
         rdf:about="">
        <dc:format>image/svg+xml</dc:format>
        <dc:type
           rdf:resource="http://purl.org/dc/dcmitype/StillImage" />
        <dc:title></dc:title>
      </cc:Work>
    </rdf:RDF>
  </metadata>
  <g
     inkscape:label="レイヤー 1"
     inkscape:groupmode="layer"
     id="layer1"
     transform="translate(0,-288.53332)">
    <path
       style="fill:#ffff00;fill-opacity:1;stroke:#000000;stroke-width:0.99999994;stroke-linecap:round;stroke-miterlimit:4;stroke-dasharray:none;stroke-opacity:1"
       d="M 6.4628906 6.4628906 L 6.4628906 24.828125 L 11.753906 19.535156 L 20.707031 28.488281 L 28.488281 20.707031 L 19.535156 11.753906 L 24.828125 6.4628906 L 6.4628906 6.4628906 z "
       transform="matrix(0.26458333,0,0,0.26458333,0,288.53332)"
       id="rect4717" />
    <rect
       style="fill:#0000ff;fill-opacity:0.10096154;stroke:none;stroke-width:1.05833328;stroke-miterlimit:4;stroke-dasharray:none;stroke-opacity:1"
       id="rect4543"
       width="8.4666662"
       height="8.4666662"
       x="-5.2041704e-016"
       y="288.53333" />
  </g>
</svg>

```

`src/svg/expand.svg`:

```svg
<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!-- Created with Inkscape (http://www.inkscape.org/) -->

<svg
   xmlns:dc="http://purl.org/dc/elements/1.1/"
   xmlns:cc="http://creativecommons.org/ns#"
   xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#"
   xmlns:svg="http://www.w3.org/2000/svg"
   xmlns="http://www.w3.org/2000/svg"
   xmlns:sodipodi="http://sodipodi.sourceforge.net/DTD/sodipodi-0.dtd"
   xmlns:inkscape="http://www.inkscape.org/namespaces/inkscape"
   width="32"
   height="32"
   viewBox="0 0 8.4666665 8.4666669"
   version="1.1"
   id="svg8"
   inkscape:version="0.92.3 (2405546, 2018-03-11)"
   sodipodi:docname="expand.svg"
   inkscape:export-filename="C:\Users\katahiromz\Desktop\bitmap.png"
   inkscape:export-xdpi="96"
   inkscape:export-ydpi="96">
  <defs
     id="defs2" />
  <sodipodi:namedview
     id="base"
     pagecolor="#ffffff"
     bordercolor="#666666"
     borderopacity="1.0"
     inkscape:pageopacity="0.0"
     inkscape:pageshadow="2"
     inkscape:zoom="11.2"
     inkscape:cx="25.808048"
     inkscape:cy="15.090711"
     inkscape:document-units="mm"
     inkscape:current-layer="layer1"
     showgrid="true"
     units="px"
     inkscape:snap-text-baseline="true"
     inkscape:snap-center="true"
     inkscape:snap-object-midpoints="true"
     inkscape:snap-midpoints="true"
     inkscape:snap-smooth-nodes="true"
     inkscape:object-paths="true"
     inkscape:snap-intersection-paths="true"
     inkscape:snap-bbox="true"
     inkscape:bbox-paths="true"
     inkscape:bbox-nodes="true"
     inkscape:snap-bbox-edge-midpoints="true"
     inkscape:snap-bbox-midpoints="true"
     inkscape:window-width="1366"
     inkscape:window-height="705"
     inkscape:window-x="-8"
     inkscape:window-y="-8"
     inkscape:window-maximized="1"
     inkscape:snap-global="true"
     inkscape:snap-others="false"
     inkscape:snap-page="true"
     inkscape:snap-nodes="false">
    <inkscape:grid
       type="xygrid"
       id="grid10" />
  </sodipodi:namedview>
  <metadata
     id="metadata5">
    <rdf:RDF>
      <cc:Work
         rdf:about="">
        <dc:format>image/svg+xml</dc:format>
        <dc:type
           rdf:resource="http://purl.org/dc/dcmitype/StillImage" />
        <dc:title></dc:title>
      </cc:Work>
    </rdf:RDF>
  </metadata>
  <g
     inkscape:label="レイヤー 1"
     inkscape:groupmode="layer"
     id="layer1"
     transform="translate(0,-288.53332)">
    <path
       style="fill:#ffff00;fill-opacity:1;stroke:#000000;stroke-width:0.26458332;stroke-linecap:round;stroke-miterlimit:4;stroke-dasharray:none;stroke-opacity:1"
       d="m 7.5923213,296.12564 v -4.85914 l -1.3999145,1.40043 -2.3688476,-2.36884 -2.0587891,2.05878 2.3688476,2.36885 -1.4004313,1.39992 z"
       id="rect4717"
       inkscape:connector-curvature="0" />
    <rect
       style="fill:#0000ff;fill-opacity:0.10096154;stroke:none;stroke-width:1.05833328;stroke-miterlimit:4;stroke-dasharray:none;stroke-opacity:1"
       id="rect4543"
       width="8.4666662"
       height="8.4666662"
       x="-5.2041704e-016"
       y="288.53333" />
  </g>
</svg>

```

`src/svg/extract.svg`:

```svg
<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!-- Created with Inkscape (http://www.inkscape.org/) -->

<svg
   xmlns:dc="http://purl.org/dc/elements/1.1/"
   xmlns:cc="http://creativecommons.org/ns#"
   xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#"
   xmlns:svg="http://www.w3.org/2000/svg"
   xmlns="http://www.w3.org/2000/svg"
   xmlns:sodipodi="http://sodipodi.sourceforge.net/DTD/sodipodi-0.dtd"
   xmlns:inkscape="http://www.inkscape.org/namespaces/inkscape"
   width="32"
   height="32"
   viewBox="0 0 8.4666665 8.4666669"
   version="1.1"
   id="svg8"
   inkscape:version="0.92.3 (2405546, 2018-03-11)"
   sodipodi:docname="extract.svg"
   inkscape:export-filename="C:\Users\katahiromz\Desktop\bitmap.png"
   inkscape:export-xdpi="96"
   inkscape:export-ydpi="96">
  <defs
     id="defs2">
    <marker
       inkscape:stockid="Arrow2Mstart"
       orient="auto"
       refY="0"
       refX="0"
       id="Arrow2Mstart-8"
       style="overflow:visible"
       inkscape:isstock="true">
      <path
         inkscape:connector-curvature="0"
         id="path852-4"
         style="fill:#000000;fill-opacity:1;fill-rule:evenodd;stroke:#000000;stroke-width:0.625;stroke-linejoin:round;stroke-opacity:1"
         d="M 8.7185878,4.0337352 -2.2072895,0.01601326 8.7185884,-4.0017078 c -1.7454984,2.3720609 -1.7354408,5.6174519 -6e-7,8.035443 z"
         transform="scale(0.6)" />
    </marker>
  </defs>
  <sodipodi:namedview
     id="base"
     pagecolor="#ffffff"
     bordercolor="#666666"
     borderopacity="1.0"
     inkscape:pageopacity="0.0"
     inkscape:pageshadow="2"
     inkscape:zoom="11.2"
     inkscape:cx="25.808048"
     inkscape:cy="15.090711"
     inkscape:document-units="mm"
     inkscape:current-layer="layer1"
     showgrid="true"
     units="px"
     inkscape:snap-text-baseline="true"
     inkscape:snap-center="true"
     inkscape:snap-object-midpoints="true"
     inkscape:snap-midpoints="true"
     inkscape:snap-smooth-nodes="true"
     inkscape:object-paths="true"
     inkscape:snap-intersection-paths="true"
     inkscape:snap-bbox="true"
     inkscape:bbox-paths="true"
     inkscape:bbox-nodes="true"
     inkscape:snap-bbox-edge-midpoints="true"
     inkscape:snap-bbox-midpoints="true"
     inkscape:window-width="1366"
     inkscape:window-height="705"
     inkscape:window-x="-8"
     inkscape:window-y="-8"
     inkscape:window-maximized="1"
     inkscape:snap-global="true"
     inkscape:snap-others="false"
     inkscape:snap-page="true"
     inkscape:snap-nodes="false">
    <inkscape:grid
       type="xygrid"
       id="grid10" />
  </sodipodi:namedview>
  <metadata
     id="metadata5">
    <rdf:RDF>
      <cc:Work
         rdf:about="">
        <dc:format>image/svg+xml</dc:format>
        <dc:type
           rdf:resource="http://purl.org/dc/dcmitype/StillImage" />
        <dc:title></dc:title>
      </cc:Work>
    </rdf:RDF>
  </metadata>
  <g
     inkscape:label="レイヤー 1"
     inkscape:groupmode="layer"
     id="layer1"
     transform="translate(0,-288.53332)">
    <rect
       style="fill:#0000ff;fill-opacity:0.10096154;stroke:none;stroke-width:1.05833328;stroke-miterlimit:4;stroke-dasharray:none;stroke-opacity:1"
       id="rect4543"
       width="8.4666662"
       height="8.4666662"
       x="-5.2041704e-016"
       y="288.53333" />
    <g
       id="g1519"
       transform="matrix(0.49999998,0,0,-0.49999998,3.9185733e-7,437.03331)">
      <ellipse
         ry="7.4638457"
         rx="3.0623009"
         cy="288.53333"
         cx="8.4666662"
         id="path1513"
         style="fill:#ffffff;fill-opacity:1;stroke:#f3ffff;stroke-width:2.00562859;stroke-linecap:round;stroke-miterlimit:1;stroke-dasharray:none;stroke-opacity:1" />
      <g
         id="g1466-7"
         transform="translate(4.046098e-8,-0.22244403)">
        <path
           style="fill:none;stroke:#000000;stroke-width:1.32291663;stroke-linecap:butt;stroke-linejoin:miter;stroke-miterlimit:1;stroke-dasharray:none;stroke-opacity:1;marker-start:url(#Arrow2Mstart-8)"
           d="m 8.4793778,283.6542 v 9.75533"
           id="path826-4"
           inkscape:connector-curvature="0" />
        <circle
           style="fill:#ffff00;fill-opacity:1;stroke:#000000;stroke-width:1.32291663;stroke-linecap:round;stroke-miterlimit:1;stroke-dasharray:none;stroke-opacity:1"
           id="path1438-1"
           cx="8.4666662"
           cy="293.32501"
           r="1.8708867" />
      </g>
    </g>
  </g>
</svg>

```

`src/svg/guiedit.svg`:

```svg
<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!-- Created with Inkscape (http://www.inkscape.org/) -->

<svg
   xmlns:dc="http://purl.org/dc/elements/1.1/"
   xmlns:cc="http://creativecommons.org/ns#"
   xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#"
   xmlns:svg="http://www.w3.org/2000/svg"
   xmlns="http://www.w3.org/2000/svg"
   xmlns:sodipodi="http://sodipodi.sourceforge.net/DTD/sodipodi-0.dtd"
   xmlns:inkscape="http://www.inkscape.org/namespaces/inkscape"
   width="32"
   height="32"
   viewBox="0 0 8.4666665 8.4666669"
   version="1.1"
   id="svg8"
   inkscape:version="0.92.3 (2405546, 2018-03-11)"
   sodipodi:docname="guiedit.svg"
   inkscape:export-filename="C:\Users\katahiromz\Desktop\bitmap.png"
   inkscape:export-xdpi="96"
   inkscape:export-ydpi="96">
  <defs
     id="defs2">
    <marker
       inkscape:stockid="Arrow2Mstart"
       orient="auto"
       refY="0"
       refX="0"
       id="Arrow2Mstart-8"
       style="overflow:visible"
       inkscape:isstock="true">
      <path
         inkscape:connector-curvature="0"
         id="path852-4"
         style="fill:#000000;fill-opacity:1;fill-rule:evenodd;stroke:#000000;stroke-width:0.625;stroke-linejoin:round;stroke-opacity:1"
         d="M 8.7185878,4.0337352 -2.2072895,0.01601326 8.7185884,-4.0017078 c -1.7454984,2.3720609 -1.7354408,5.6174519 -6e-7,8.035443 z"
         transform="scale(0.6)" />
    </marker>
  </defs>
  <sodipodi:namedview
     id="base"
     pagecolor="#ffffff"
     bordercolor="#666666"
     borderopacity="1.0"
     inkscape:pageopacity="0.0"
     inkscape:pageshadow="2"
     inkscape:zoom="11.2"
     inkscape:cx="25.808048"
     inkscape:cy="15.090711"
     inkscape:document-units="mm"
     inkscape:current-layer="layer1"
     showgrid="true"
     units="px"
     inkscape:snap-text-baseline="true"
     inkscape:snap-center="true"
     inkscape:snap-object-midpoints="true"
     inkscape:snap-midpoints="true"
     inkscape:snap-smooth-nodes="true"
     inkscape:object-paths="true"
     inkscape:snap-intersection-paths="true"
     inkscape:snap-bbox="true"
     inkscape:bbox-paths="true"
     inkscape:bbox-nodes="true"
     inkscape:snap-bbox-edge-midpoints="true"
     inkscape:snap-bbox-midpoints="true"
     inkscape:window-width="1366"
     inkscape:window-height="705"
     inkscape:window-x="-8"
     inkscape:window-y="-8"
     inkscape:window-maximized="1"
     inkscape:snap-global="true"
     inkscape:snap-others="false"
     inkscape:snap-page="true"
     inkscape:snap-nodes="false">
    <inkscape:grid
       type="xygrid"
       id="grid10" />
  </sodipodi:namedview>
  <metadata
     id="metadata5">
    <rdf:RDF>
      <cc:Work
         rdf:about="">
        <dc:format>image/svg+xml</dc:format>
        <dc:type
           rdf:resource="http://purl.org/dc/dcmitype/StillImage" />
        <dc:title></dc:title>
      </cc:Work>
    </rdf:RDF>
  </metadata>
  <g
     inkscape:label="レイヤー 1"
     inkscape:groupmode="layer"
     id="layer1"
     transform="translate(0,-288.53332)">
    <rect
       style="fill:#0000ff;fill-opacity:0.10096154;stroke:none;stroke-width:1.05833328;stroke-miterlimit:4;stroke-dasharray:none;stroke-opacity:1"
       id="rect4543"
       width="8.4666662"
       height="8.4666662"
       x="-5.2041704e-016"
       y="288.53333" />
    <path
       style="fill:none;stroke:#000000;stroke-width:0.5291667;stroke-linecap:butt;stroke-linejoin:miter;stroke-miterlimit:4;stroke-dasharray:none;stroke-opacity:1"
       d="m 0.79464904,290.91457 6.94531256,0.0236"
       id="path4744"
       inkscape:connector-curvature="0" />
    <path
       style="fill:none;stroke:#000000;stroke-width:0.52916676;stroke-linecap:butt;stroke-linejoin:miter;stroke-miterlimit:4;stroke-dasharray:none;stroke-opacity:1"
       d="m 2.4048486,289.29399 -0.0236,6.94532"
       id="path4744-5"
       inkscape:connector-curvature="0" />
    <ellipse
       style="fill:#ffff00;fill-opacity:1;stroke:#000000;stroke-width:0.5291667;stroke-linecap:round;stroke-miterlimit:4;stroke-dasharray:none;stroke-opacity:1"
       id="path4761"
       cx="4.4979167"
       cy="293.03125"
       rx="1.8384194"
       ry="1.8384181" />
  </g>
</svg>

```

`src/svg/guiedit2.svg`:

```svg
<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!-- Created with Inkscape (http://www.inkscape.org/) -->

<svg
   xmlns:dc="http://purl.org/dc/elements/1.1/"
   xmlns:cc="http://creativecommons.org/ns#"
   xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#"
   xmlns:svg="http://www.w3.org/2000/svg"
   xmlns="http://www.w3.org/2000/svg"
   xmlns:sodipodi="http://sodipodi.sourceforge.net/DTD/sodipodi-0.dtd"
   xmlns:inkscape="http://www.inkscape.org/namespaces/inkscape"
   width="32"
   height="32"
   viewBox="0 0 8.4666665 8.4666669"
   version="1.1"
   id="svg8"
   inkscape:version="0.92.3 (2405546, 2018-03-11)"
   sodipodi:docname="guiedit2.svg"
   inkscape:export-filename="C:\Users\katahiromz\Desktop\bitmap.png"
   inkscape:export-xdpi="96"
   inkscape:export-ydpi="96">
  <defs
     id="defs2">
    <marker
       inkscape:stockid="Arrow2Mstart"
       orient="auto"
       refY="0"
       refX="0"
       id="Arrow2Mstart-8"
       style="overflow:visible"
       inkscape:isstock="true">
      <path
         inkscape:connector-curvature="0"
         id="path852-4"
         style="fill:#000000;fill-opacity:1;fill-rule:evenodd;stroke:#000000;stroke-width:0.625;stroke-linejoin:round;stroke-opacity:1"
         d="M 8.7185878,4.0337352 -2.2072895,0.01601326 8.7185884,-4.0017078 c -1.7454984,2.3720609 -1.7354408,5.6174519 -6e-7,8.035443 z"
         transform="scale(0.6)" />
    </marker>
  </defs>
  <sodipodi:namedview
     id="base"
     pagecolor="#ffffff"
     bordercolor="#666666"
     borderopacity="1.0"
     inkscape:pageopacity="0.0"
     inkscape:pageshadow="2"
     inkscape:zoom="9.7006212"
     inkscape:cx="22.370869"
     inkscape:cy="20.575545"
     inkscape:document-units="mm"
     inkscape:current-layer="layer1"
     showgrid="true"
     units="px"
     inkscape:snap-text-baseline="true"
     inkscape:snap-center="true"
     inkscape:snap-object-midpoints="true"
     inkscape:snap-midpoints="true"
     inkscape:snap-smooth-nodes="true"
     inkscape:object-paths="true"
     inkscape:snap-intersection-paths="true"
     inkscape:snap-bbox="true"
     inkscape:bbox-paths="true"
     inkscape:bbox-nodes="true"
     inkscape:snap-bbox-edge-midpoints="true"
     inkscape:snap-bbox-midpoints="true"
     inkscape:window-width="1366"
     inkscape:window-height="705"
     inkscape:window-x="-8"
     inkscape:window-y="-8"
     inkscape:window-maximized="1"
     inkscape:snap-global="true"
     inkscape:snap-others="false"
     inkscape:snap-page="true"
     inkscape:snap-nodes="false">
    <inkscape:grid
       type="xygrid"
       id="grid10" />
  </sodipodi:namedview>
  <metadata
     id="metadata5">
    <rdf:RDF>
      <cc:Work
         rdf:about="">
        <dc:format>image/svg+xml</dc:format>
        <dc:type
           rdf:resource="http://purl.org/dc/dcmitype/StillImage" />
        <dc:title />
      </cc:Work>
    </rdf:RDF>
  </metadata>
  <g
     inkscape:label="レイヤー 1"
     inkscape:groupmode="layer"
     id="layer1"
     transform="translate(0,-288.53332)">
    <g
       id="g32">
      <rect
         y="288.53333"
         x="-5.2041704e-016"
         height="8.4666662"
         width="8.4666662"
         id="rect4543"
         style="fill:#0000ff;fill-opacity:0.10096154;stroke:none;stroke-width:1.05833328;stroke-miterlimit:4;stroke-dasharray:none;stroke-opacity:1" />
      <g
         transform="translate(-1.190625)"
         id="g4597">
        <text
           xml:space="preserve"
           style="font-style:normal;font-weight:normal;font-size:10.58333302px;line-height:1.25;font-family:sans-serif;letter-spacing:0px;word-spacing:0px;fill:#ffffff;fill-opacity:1;stroke:#ffffff;stroke-width:1.05833328;stroke-miterlimit:4;stroke-dasharray:none;stroke-opacity:1"
           x="1.8396809"
           y="295.7608"
           id="text16-4"><tspan
             sodipodi:role="line"
             id="tspan14-0"
             x="1.8396809"
             y="295.7608"
             style="font-size:2.82222223px;fill:#ffffff;fill-opacity:1;stroke:#ffffff;stroke-width:1.05833328;stroke-miterlimit:4;stroke-dasharray:none;stroke-opacity:1">EDIT</tspan></text>
        <text
           xml:space="preserve"
           style="font-style:normal;font-weight:normal;font-size:10.58333302px;line-height:1.25;font-family:sans-serif;letter-spacing:0px;word-spacing:0px;fill:#000000;fill-opacity:1;stroke:none;stroke-width:0.26458332"
           x="1.8396809"
           y="295.7608"
           id="text16-4-7"
           inkscape:transform-center-x="0.16364932"
           inkscape:transform-center-y="-1.0364457"><tspan
             sodipodi:role="line"
             id="tspan14-0-2"
             x="1.8396809"
             y="295.7608"
             style="font-size:2.82222223px;stroke-width:0.26458332">EDIT</tspan></text>
      </g>
      <g
         transform="translate(-1.0583334)"
         id="g4591">
        <text
           xml:space="preserve"
           style="font-style:normal;font-weight:normal;font-size:10.58333302px;line-height:1.25;font-family:sans-serif;letter-spacing:0px;word-spacing:0px;fill:#ffffff;fill-opacity:1;stroke:#ffffff;stroke-width:1.05833328;stroke-miterlimit:4;stroke-dasharray:none;stroke-opacity:1"
           x="2.2468913"
           y="292.19797"
           id="text16"><tspan
             sodipodi:role="line"
             id="tspan14"
             x="2.2468913"
             y="292.19797"
             style="font-size:3.17499995px;fill:#ffffff;fill-opacity:1;stroke:#ffffff;stroke-width:1.05833328;stroke-miterlimit:4;stroke-dasharray:none;stroke-opacity:1">GUI</tspan></text>
        <text
           xml:space="preserve"
           style="font-style:normal;font-weight:normal;font-size:10.58333302px;line-height:1.25;font-family:sans-serif;letter-spacing:0px;word-spacing:0px;fill:#000000;fill-opacity:1;stroke:none;stroke-width:0.26458332"
           x="2.2468913"
           y="292.19797"
           id="text16-5"><tspan
             sodipodi:role="line"
             id="tspan14-4"
             x="2.2468913"
             y="292.19797"
             style="font-size:3.17499995px;stroke-width:0.26458332">GUI</tspan></text>
      </g>
    </g>
  </g>
</svg>

```

`src/svg/import.svg`:

```svg
<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!-- Created with Inkscape (http://www.inkscape.org/) -->

<svg
   xmlns:dc="http://purl.org/dc/elements/1.1/"
   xmlns:cc="http://creativecommons.org/ns#"
   xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#"
   xmlns:svg="http://www.w3.org/2000/svg"
   xmlns="http://www.w3.org/2000/svg"
   xmlns:sodipodi="http://sodipodi.sourceforge.net/DTD/sodipodi-0.dtd"
   xmlns:inkscape="http://www.inkscape.org/namespaces/inkscape"
   width="32"
   height="32"
   viewBox="0 0 8.4666665 8.4666669"
   version="1.1"
   id="svg8"
   inkscape:version="0.92.3 (2405546, 2018-03-11)"
   sodipodi:docname="import.svg"
   inkscape:export-filename="C:\Users\katahiromz\Desktop\bitmap.png"
   inkscape:export-xdpi="96"
   inkscape:export-ydpi="96">
  <defs
     id="defs2">
    <marker
       inkscape:stockid="Arrow2Mstart"
       orient="auto"
       refY="0"
       refX="0"
       id="Arrow2Mstart-8"
       style="overflow:visible"
       inkscape:isstock="true">
      <path
         inkscape:connector-curvature="0"
         id="path852-4"
         style="fill:#000000;fill-opacity:1;fill-rule:evenodd;stroke:#000000;stroke-width:0.625;stroke-linejoin:round;stroke-opacity:1"
         d="M 8.7185878,4.0337352 -2.2072895,0.01601326 8.7185884,-4.0017078 c -1.7454984,2.3720609 -1.7354408,5.6174519 -6e-7,8.035443 z"
         transform="scale(0.6)" />
    </marker>
  </defs>
  <sodipodi:namedview
     id="base"
     pagecolor="#ffffff"
     bordercolor="#666666"
     borderopacity="1.0"
     inkscape:pageopacity="0.0"
     inkscape:pageshadow="2"
     inkscape:zoom="11.2"
     inkscape:cx="25.808048"
     inkscape:cy="15.090711"
     inkscape:document-units="mm"
     inkscape:current-layer="layer1"
     showgrid="true"
     units="px"
     inkscape:snap-text-baseline="true"
     inkscape:snap-center="true"
     inkscape:snap-object-midpoints="true"
     inkscape:snap-midpoints="true"
     inkscape:snap-smooth-nodes="true"
     inkscape:object-paths="true"
     inkscape:snap-intersection-paths="true"
     inkscape:snap-bbox="true"
     inkscape:bbox-paths="true"
     inkscape:bbox-nodes="true"
     inkscape:snap-bbox-edge-midpoints="true"
     inkscape:snap-bbox-midpoints="true"
     inkscape:window-width="1366"
     inkscape:window-height="705"
     inkscape:window-x="-8"
     inkscape:window-y="-8"
     inkscape:window-maximized="1"
     inkscape:snap-global="true"
     inkscape:snap-others="false"
     inkscape:snap-page="true"
     inkscape:snap-nodes="false">
    <inkscape:grid
       type="xygrid"
       id="grid10" />
  </sodipodi:namedview>
  <metadata
     id="metadata5">
    <rdf:RDF>
      <cc:Work
         rdf:about="">
        <dc:format>image/svg+xml</dc:format>
        <dc:type
           rdf:resource="http://purl.org/dc/dcmitype/StillImage" />
        <dc:title></dc:title>
      </cc:Work>
    </rdf:RDF>
  </metadata>
  <g
     inkscape:label="レイヤー 1"
     inkscape:groupmode="layer"
     id="layer1"
     transform="translate(0,-288.53332)">
    <rect
       style="fill:#0000ff;fill-opacity:0.10096154;stroke:none;stroke-width:1.05833328;stroke-miterlimit:4;stroke-dasharray:none;stroke-opacity:1"
       id="rect4543"
       width="8.4666662"
       height="8.4666662"
       x="-5.2041704e-016"
       y="288.53333" />
    <g
       id="g1519"
       transform="matrix(0.49999998,0,0,0.49999998,3.9185734e-7,148.5)">
      <ellipse
         ry="7.4638457"
         rx="3.0623009"
         cy="288.53333"
         cx="8.4666662"
         id="path1513"
         style="fill:#ffffff;fill-opacity:1;stroke:#f3ffff;stroke-width:2.00562859;stroke-linecap:round;stroke-miterlimit:1;stroke-dasharray:none;stroke-opacity:1" />
      <g
         id="g1466-7"
         transform="translate(4.046098e-8,-0.22244403)">
        <path
           style="fill:none;stroke:#000000;stroke-width:1.32291663;stroke-linecap:butt;stroke-linejoin:miter;stroke-miterlimit:1;stroke-dasharray:none;stroke-opacity:1;marker-start:url(#Arrow2Mstart-8)"
           d="m 8.4793778,283.6542 v 9.75533"
           id="path826-4"
           inkscape:connector-curvature="0" />
        <circle
           style="fill:#ffff00;fill-opacity:1;stroke:#000000;stroke-width:1.32291663;stroke-linecap:round;stroke-miterlimit:1;stroke-dasharray:none;stroke-opacity:1"
           id="path1438-1"
           cx="8.4666662"
           cy="293.32501"
           r="1.8708867" />
      </g>
    </g>
  </g>
</svg>

```

`src/svg/minus.svg`:

```svg
<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!-- Created with Inkscape (http://www.inkscape.org/) -->

<svg
   xmlns:dc="http://purl.org/dc/elements/1.1/"
   xmlns:cc="http://creativecommons.org/ns#"
   xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#"
   xmlns:svg="http://www.w3.org/2000/svg"
   xmlns="http://www.w3.org/2000/svg"
   xmlns:sodipodi="http://sodipodi.sourceforge.net/DTD/sodipodi-0.dtd"
   xmlns:inkscape="http://www.inkscape.org/namespaces/inkscape"
   width="32"
   height="32"
   viewBox="0 0 8.4666665 8.4666669"
   version="1.1"
   id="svg8"
   inkscape:version="0.92.3 (2405546, 2018-03-11)"
   sodipodi:docname="minus.svg"
   inkscape:export-filename="C:\Users\katahiromz\Desktop\bitmap.png"
   inkscape:export-xdpi="96"
   inkscape:export-ydpi="96">
  <defs
     id="defs2">
    <marker
       inkscape:stockid="Arrow2Mstart"
       orient="auto"
       refY="0"
       refX="0"
       id="Arrow2Mstart-8"
       style="overflow:visible"
       inkscape:isstock="true">
      <path
         inkscape:connector-curvature="0"
         id="path852-4"
         style="fill:#000000;fill-opacity:1;fill-rule:evenodd;stroke:#000000;stroke-width:0.625;stroke-linejoin:round;stroke-opacity:1"
         d="M 8.7185878,4.0337352 -2.2072895,0.01601326 8.7185884,-4.0017078 c -1.7454984,2.3720609 -1.7354408,5.6174519 -6e-7,8.035443 z"
         transform="scale(0.6)" />
    </marker>
  </defs>
  <sodipodi:namedview
     id="base"
     pagecolor="#ffffff"
     bordercolor="#666666"
     borderopacity="1.0"
     inkscape:pageopacity="0.0"
     inkscape:pageshadow="2"
     inkscape:zoom="11.2"
     inkscape:cx="25.808048"
     inkscape:cy="15.090711"
     inkscape:document-units="mm"
     inkscape:current-layer="layer1"
     showgrid="true"
     units="px"
     inkscape:snap-text-baseline="true"
     inkscape:snap-center="true"
     inkscape:snap-object-midpoints="true"
     inkscape:snap-midpoints="true"
     inkscape:snap-smooth-nodes="true"
     inkscape:object-paths="true"
     inkscape:snap-intersection-paths="true"
     inkscape:snap-bbox="true"
     inkscape:bbox-paths="true"
     inkscape:bbox-nodes="true"
     inkscape:snap-bbox-edge-midpoints="true"
     inkscape:snap-bbox-midpoints="true"
     inkscape:window-width="1366"
     inkscape:window-height="705"
     inkscape:window-x="-8"
     inkscape:window-y="-8"
     inkscape:window-maximized="1"
     inkscape:snap-global="true"
     inkscape:snap-others="false"
     inkscape:snap-page="true"
     inkscape:snap-nodes="false">
    <inkscape:grid
       type="xygrid"
       id="grid10" />
  </sodipodi:namedview>
  <metadata
     id="metadata5">
    <rdf:RDF>
      <cc:Work
         rdf:about="">
        <dc:format>image/svg+xml</dc:format>
        <dc:type
           rdf:resource="http://purl.org/dc/dcmitype/StillImage" />
        <dc:title></dc:title>
      </cc:Work>
    </rdf:RDF>
  </metadata>
  <g
     inkscape:label="レイヤー 1"
     inkscape:groupmode="layer"
     id="layer1"
     transform="translate(0,-288.53332)">
    <rect
       style="fill:#0000ff;fill-opacity:0.10096154;stroke:none;stroke-width:1.05833328;stroke-miterlimit:4;stroke-dasharray:none;stroke-opacity:1"
       id="rect4543"
       width="8.4666662"
       height="8.4666662"
       x="-5.2041704e-016"
       y="288.53333" />
    <rect
       style="fill:#0000ff;fill-opacity:1;stroke:#000000;stroke-width:0.52913481;stroke-linecap:round;stroke-miterlimit:4;stroke-dasharray:none;stroke-opacity:1"
       id="rect4763"
       width="6.8791986"
       height="1.5875404"
       x="0.79373407"
       y="291.97287" />
  </g>
</svg>

```

`src/svg/new.svg`:

```svg
<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!-- Created with Inkscape (http://www.inkscape.org/) -->

<svg
   xmlns:dc="http://purl.org/dc/elements/1.1/"
   xmlns:cc="http://creativecommons.org/ns#"
   xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#"
   xmlns:svg="http://www.w3.org/2000/svg"
   xmlns="http://www.w3.org/2000/svg"
   xmlns:xlink="http://www.w3.org/1999/xlink"
   xmlns:sodipodi="http://sodipodi.sourceforge.net/DTD/sodipodi-0.dtd"
   xmlns:inkscape="http://www.inkscape.org/namespaces/inkscape"
   width="32"
   height="32"
   viewBox="0 0 8.4666665 8.4666669"
   version="1.1"
   id="svg8"
   inkscape:version="0.92.3 (2405546, 2018-03-11)"
   sodipodi:docname="new.svg"
   inkscape:export-filename="C:\Users\katahiromz\Desktop\bitmap.png"
   inkscape:export-xdpi="96"
   inkscape:export-ydpi="96">
  <defs
     id="defs2">
    <linearGradient
       inkscape:collect="always"
       id="linearGradient4858">
      <stop
         style="stop-color:#ffff72;stop-opacity:1"
         offset="0"
         id="stop4854" />
      <stop
         style="stop-color:#ffffff;stop-opacity:1"
         offset="1"
         id="stop4856" />
    </linearGradient>
    <marker
       inkscape:stockid="Arrow2Mstart"
       orient="auto"
       refY="0"
       refX="0"
       id="Arrow2Mstart-8"
       style="overflow:visible"
       inkscape:isstock="true">
      <path
         inkscape:connector-curvature="0"
         id="path852-4"
         style="fill:#000000;fill-opacity:1;fill-rule:evenodd;stroke:#000000;stroke-width:0.625;stroke-linejoin:round;stroke-opacity:1"
         d="M 8.7185878,4.0337352 -2.2072895,0.01601326 8.7185884,-4.0017078 c -1.7454984,2.3720609 -1.7354408,5.6174519 -6e-7,8.035443 z"
         transform="scale(0.6)" />
    </marker>
    <linearGradient
       inkscape:collect="always"
       xlink:href="#linearGradient4858"
       id="linearGradient4860"
       x1="4.9980468"
       y1="16"
       x2="27.001953"
       y2="16"
       gradientUnits="userSpaceOnUse" />
  </defs>
  <sodipodi:namedview
     id="base"
     pagecolor="#ffffff"
     bordercolor="#666666"
     borderopacity="1.0"
     inkscape:pageopacity="0.0"
     inkscape:pageshadow="2"
     inkscape:zoom="11.2"
     inkscape:cx="25.808048"
     inkscape:cy="15.090711"
     inkscape:document-units="mm"
     inkscape:current-layer="layer1"
     showgrid="true"
     units="px"
     inkscape:snap-text-baseline="true"
     inkscape:snap-center="true"
     inkscape:snap-object-midpoints="true"
     inkscape:snap-midpoints="true"
     inkscape:snap-smooth-nodes="true"
     inkscape:object-paths="true"
     inkscape:snap-intersection-paths="true"
     inkscape:snap-bbox="true"
     inkscape:bbox-paths="true"
     inkscape:bbox-nodes="true"
     inkscape:snap-bbox-edge-midpoints="true"
     inkscape:snap-bbox-midpoints="true"
     inkscape:window-width="1366"
     inkscape:window-height="705"
     inkscape:window-x="-8"
     inkscape:window-y="-8"
     inkscape:window-maximized="1"
     inkscape:snap-global="true"
     inkscape:snap-others="false"
     inkscape:snap-page="true"
     inkscape:snap-nodes="false">
    <inkscape:grid
       type="xygrid"
       id="grid10" />
  </sodipodi:namedview>
  <metadata
     id="metadata5">
    <rdf:RDF>
      <cc:Work
         rdf:about="">
        <dc:format>image/svg+xml</dc:format>
        <dc:type
           rdf:resource="http://purl.org/dc/dcmitype/StillImage" />
        <dc:title></dc:title>
      </cc:Work>
    </rdf:RDF>
  </metadata>
  <g
     inkscape:label="レイヤー 1"
     inkscape:groupmode="layer"
     id="layer1"
     transform="translate(0,-288.53332)">
    <rect
       style="fill:#0000ff;fill-opacity:0.10096154;stroke:none;stroke-width:1.05833328;stroke-miterlimit:4;stroke-dasharray:none;stroke-opacity:1"
       id="rect4543"
       width="8.4666662"
       height="8.4666662"
       x="-5.2041704e-016"
       y="288.53333" />
    <path
       style="fill:url(#linearGradient4860);fill-opacity:1;stroke:#000000;stroke-width:2.00000024;stroke-linecap:round;stroke-miterlimit:4;stroke-dasharray:none;stroke-opacity:1"
       d="M 5.9980469 2.9980469 L 5.9980469 29.001953 L 26.001953 29.001953 L 26.001953 11.148438 L 17.851562 2.9980469 L 5.9980469 2.9980469 z "
       transform="matrix(0.26458333,0,0,0.26458333,0,288.53332)"
       id="rect4781" />
    <path
       style="fill:#ffffd5;fill-opacity:1;stroke:#000000;stroke-width:0.52916667;stroke-linecap:butt;stroke-linejoin:bevel;stroke-miterlimit:4;stroke-dasharray:none;stroke-opacity:1"
       d="M 6.8393879,291.44795 4.7595313,289.4348 v 2.01315 z"
       id="rect4799"
       inkscape:connector-curvature="0" />
  </g>
</svg>

```

`src/svg/open.svg`:

```svg
<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!-- Created with Inkscape (http://www.inkscape.org/) -->

<svg
   xmlns:dc="http://purl.org/dc/elements/1.1/"
   xmlns:cc="http://creativecommons.org/ns#"
   xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#"
   xmlns:svg="http://www.w3.org/2000/svg"
   xmlns="http://www.w3.org/2000/svg"
   xmlns:sodipodi="http://sodipodi.sourceforge.net/DTD/sodipodi-0.dtd"
   xmlns:inkscape="http://www.inkscape.org/namespaces/inkscape"
   width="32"
   height="32"
   viewBox="0 0 8.4666665 8.4666669"
   version="1.1"
   id="svg8"
   inkscape:version="0.92.3 (2405546, 2018-03-11)"
   sodipodi:docname="open.svg"
   inkscape:export-filename="C:\Users\katahiromz\Desktop\bitmap.png"
   inkscape:export-xdpi="96"
   inkscape:export-ydpi="96">
  <defs
     id="defs2">
    <marker
       inkscape:stockid="Arrow2Mstart"
       orient="auto"
       refY="0"
       refX="0"
       id="Arrow2Mstart-8"
       style="overflow:visible"
       inkscape:isstock="true">
      <path
         inkscape:connector-curvature="0"
         id="path852-4"
         style="fill:#000000;fill-opacity:1;fill-rule:evenodd;stroke:#000000;stroke-width:0.625;stroke-linejoin:round;stroke-opacity:1"
         d="M 8.7185878,4.0337352 -2.2072895,0.01601326 8.7185884,-4.0017078 c -1.7454984,2.3720609 -1.7354408,5.6174519 -6e-7,8.035443 z"
         transform="scale(0.6)" />
    </marker>
  </defs>
  <sodipodi:namedview
     id="base"
     pagecolor="#ffffff"
     bordercolor="#666666"
     borderopacity="1.0"
     inkscape:pageopacity="0.0"
     inkscape:pageshadow="2"
     inkscape:zoom="11.2"
     inkscape:cx="25.808048"
     inkscape:cy="15.090711"
     inkscape:document-units="mm"
     inkscape:current-layer="layer1"
     showgrid="true"
     units="px"
     inkscape:snap-text-baseline="true"
     inkscape:snap-center="true"
     inkscape:snap-object-midpoints="true"
     inkscape:snap-midpoints="true"
     inkscape:snap-smooth-nodes="true"
     inkscape:object-paths="true"
     inkscape:snap-intersection-paths="true"
     inkscape:snap-bbox="true"
     inkscape:bbox-paths="true"
     inkscape:bbox-nodes="true"
     inkscape:snap-bbox-edge-midpoints="true"
     inkscape:snap-bbox-midpoints="true"
     inkscape:window-width="1366"
     inkscape:window-height="705"
     inkscape:window-x="-8"
     inkscape:window-y="-8"
     inkscape:window-maximized="1"
     inkscape:snap-global="true"
     inkscape:snap-others="false"
     inkscape:snap-page="true"
     inkscape:snap-nodes="false">
    <inkscape:grid
       type="xygrid"
       id="grid10" />
  </sodipodi:namedview>
  <metadata
     id="metadata5">
    <rdf:RDF>
      <cc:Work
         rdf:about="">
        <dc:format>image/svg+xml</dc:format>
        <dc:type
           rdf:resource="http://purl.org/dc/dcmitype/StillImage" />
        <dc:title></dc:title>
      </cc:Work>
    </rdf:RDF>
  </metadata>
  <g
     inkscape:label="レイヤー 1"
     inkscape:groupmode="layer"
     id="layer1"
     transform="translate(0,-288.53332)">
    <rect
       style="fill:#0000ff;fill-opacity:0.10096154;stroke:none;stroke-width:1.05833328;stroke-miterlimit:4;stroke-dasharray:none;stroke-opacity:1"
       id="rect4543"
       width="8.4666662"
       height="8.4666662"
       x="-5.2041704e-016"
       y="288.53333" />
    <path
       style="fill:#ffff00;fill-opacity:1;stroke:#000000;stroke-width:1.95991158;stroke-linecap:butt;stroke-linejoin:bevel;stroke-miterlimit:4;stroke-dasharray:none;stroke-opacity:1"
       d="M 3.3808594 4.0039062 C 2.6179294 4.0039062 2.0039062 4.6536157 2.0039062 5.4609375 L 2.0039062 9.4238281 C 1.99649 9.5079041 1.9804688 9.5895873 1.9804688 9.6757812 L 1.9804688 26.324219 C 1.9804687 27.815597 3.1155522 29.015625 4.5253906 29.015625 L 21.474609 29.015625 C 22.884448 29.015625 24.019531 27.815597 24.019531 26.324219 L 24.019531 9.6757812 C 24.019531 8.1844025 22.884448 6.984375 21.474609 6.984375 L 13.931641 6.984375 L 13.931641 5.4609375 C 13.931641 4.6536157 13.317617 4.0039062 12.554688 4.0039062 L 3.3808594 4.0039062 z "
       transform="matrix(0.26458333,0,0,0.26458333,0,288.53332)"
       id="rect4862" />
    <rect
       style="fill:#ffff00;fill-opacity:1;stroke:#000000;stroke-width:0.48942181;stroke-linecap:butt;stroke-linejoin:bevel;stroke-miterlimit:4;stroke-dasharray:none;stroke-opacity:1"
       id="rect4862-7"
       width="5.9425092"
       height="4.6363621"
       x="59.844238"
       y="297.39392"
       rx="0.68614542"
       ry="0.56647909"
       transform="matrix(1,0,-0.19502072,0.98079912,0,0)" />
  </g>
</svg>

```

`src/svg/plus.svg`:

```svg
<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!-- Created with Inkscape (http://www.inkscape.org/) -->

<svg
   xmlns:dc="http://purl.org/dc/elements/1.1/"
   xmlns:cc="http://creativecommons.org/ns#"
   xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#"
   xmlns:svg="http://www.w3.org/2000/svg"
   xmlns="http://www.w3.org/2000/svg"
   xmlns:sodipodi="http://sodipodi.sourceforge.net/DTD/sodipodi-0.dtd"
   xmlns:inkscape="http://www.inkscape.org/namespaces/inkscape"
   width="32"
   height="32"
   viewBox="0 0 8.4666665 8.4666669"
   version="1.1"
   id="svg8"
   inkscape:version="0.92.3 (2405546, 2018-03-11)"
   sodipodi:docname="plus.svg"
   inkscape:export-filename="C:\Users\katahiromz\Desktop\bitmap.png"
   inkscape:export-xdpi="96"
   inkscape:export-ydpi="96">
  <defs
     id="defs2">
    <marker
       inkscape:stockid="Arrow2Mstart"
       orient="auto"
       refY="0"
       refX="0"
       id="Arrow2Mstart-8"
       style="overflow:visible"
       inkscape:isstock="true">
      <path
         inkscape:connector-curvature="0"
         id="path852-4"
         style="fill:#000000;fill-opacity:1;fill-rule:evenodd;stroke:#000000;stroke-width:0.625;stroke-linejoin:round;stroke-opacity:1"
         d="M 8.7185878,4.0337352 -2.2072895,0.01601326 8.7185884,-4.0017078 c -1.7454984,2.3720609 -1.7354408,5.6174519 -6e-7,8.035443 z"
         transform="scale(0.6)" />
    </marker>
  </defs>
  <sodipodi:namedview
     id="base"
     pagecolor="#ffffff"
     bordercolor="#666666"
     borderopacity="1.0"
     inkscape:pageopacity="0.0"
     inkscape:pageshadow="2"
     inkscape:zoom="11.2"
     inkscape:cx="25.808048"
     inkscape:cy="15.090711"
     inkscape:document-units="mm"
     inkscape:current-layer="layer1"
     showgrid="true"
     units="px"
     inkscape:snap-text-baseline="true"
     inkscape:snap-center="true"
     inkscape:snap-object-midpoints="true"
     inkscape:snap-midpoints="true"
     inkscape:snap-smooth-nodes="true"
     inkscape:object-paths="true"
     inkscape:snap-intersection-paths="true"
     inkscape:snap-bbox="true"
     inkscape:bbox-paths="true"
     inkscape:bbox-nodes="true"
     inkscape:snap-bbox-edge-midpoints="true"
     inkscape:snap-bbox-midpoints="true"
     inkscape:window-width="1366"
     inkscape:window-height="705"
     inkscape:window-x="-8"
     inkscape:window-y="-8"
     inkscape:window-maximized="1"
     inkscape:snap-global="true"
     inkscape:snap-others="false"
     inkscape:snap-page="true"
     inkscape:snap-nodes="false">
    <inkscape:grid
       type="xygrid"
       id="grid10" />
  </sodipodi:namedview>
  <metadata
     id="metadata5">
    <rdf:RDF>
      <cc:Work
         rdf:about="">
        <dc:format>image/svg+xml</dc:format>
        <dc:type
           rdf:resource="http://purl.org/dc/dcmitype/StillImage" />
        <dc:title></dc:title>
      </cc:Work>
    </rdf:RDF>
  </metadata>
  <g
     inkscape:label="レイヤー 1"
     inkscape:groupmode="layer"
     id="layer1"
     transform="translate(0,-288.53332)">
    <rect
       style="fill:#0000ff;fill-opacity:0.10096154;stroke:none;stroke-width:1.05833328;stroke-miterlimit:4;stroke-dasharray:none;stroke-opacity:1"
       id="rect4543"
       width="8.4666662"
       height="8.4666662"
       x="-5.2041704e-016"
       y="288.53333" />
    <path
       style="fill:#ff0000;fill-opacity:1;stroke:#000000;stroke-width:1.9998796;stroke-linecap:round;stroke-miterlimit:4;stroke-dasharray:none;stroke-opacity:1"
       d="M 13 3 L 13 13 L 3 13 L 3 19 L 13 19 L 13 29 L 19 29 L 19 19 L 29 19 L 29 13 L 19 13 L 19 3 L 13 3 z "
       transform="matrix(0.26458333,0,0,0.26458333,0,288.53332)"
       id="rect4763" />
  </g>
</svg>

```

`src/svg/recompile.svg`:

```svg
<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!-- Created with Inkscape (http://www.inkscape.org/) -->

<svg
   xmlns:dc="http://purl.org/dc/elements/1.1/"
   xmlns:cc="http://creativecommons.org/ns#"
   xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#"
   xmlns:svg="http://www.w3.org/2000/svg"
   xmlns="http://www.w3.org/2000/svg"
   xmlns:sodipodi="http://sodipodi.sourceforge.net/DTD/sodipodi-0.dtd"
   xmlns:inkscape="http://www.inkscape.org/namespaces/inkscape"
   width="32"
   height="32"
   viewBox="0 0 8.4666665 8.4666669"
   version="1.1"
   id="svg8"
   inkscape:version="0.92.3 (2405546, 2018-03-11)"
   sodipodi:docname="recompile.svg"
   inkscape:export-filename="C:\Users\katahiromz\Desktop\bitmap.png"
   inkscape:export-xdpi="96"
   inkscape:export-ydpi="96">
  <defs
     id="defs2">
    <marker
       inkscape:stockid="Arrow2Mstart"
       orient="auto"
       refY="0"
       refX="0"
       id="Arrow2Mstart-8"
       style="overflow:visible"
       inkscape:isstock="true">
      <path
         inkscape:connector-curvature="0"
         id="path852-4"
         style="fill:#000000;fill-opacity:1;fill-rule:evenodd;stroke:#000000;stroke-width:0.625;stroke-linejoin:round;stroke-opacity:1"
         d="M 8.7185878,4.0337352 -2.2072895,0.01601326 8.7185884,-4.0017078 c -1.7454984,2.3720609 -1.7354408,5.6174519 -6e-7,8.035443 z"
         transform="scale(0.6)" />
    </marker>
  </defs>
  <sodipodi:namedview
     id="base"
     pagecolor="#ffffff"
     bordercolor="#666666"
     borderopacity="1.0"
     inkscape:pageopacity="0.0"
     inkscape:pageshadow="2"
     inkscape:zoom="11.2"
     inkscape:cx="13.046491"
     inkscape:cy="16.436264"
     inkscape:document-units="mm"
     inkscape:current-layer="layer1"
     showgrid="true"
     units="px"
     inkscape:snap-text-baseline="true"
     inkscape:snap-center="true"
     inkscape:snap-object-midpoints="true"
     inkscape:snap-midpoints="true"
     inkscape:snap-smooth-nodes="true"
     inkscape:object-paths="true"
     inkscape:snap-intersection-paths="true"
     inkscape:snap-bbox="true"
     inkscape:bbox-paths="true"
     inkscape:bbox-nodes="true"
     inkscape:snap-bbox-edge-midpoints="true"
     inkscape:snap-bbox-midpoints="true"
     inkscape:window-width="1366"
     inkscape:window-height="705"
     inkscape:window-x="-8"
     inkscape:window-y="-8"
     inkscape:window-maximized="1"
     inkscape:snap-global="true"
     inkscape:snap-others="false"
     inkscape:snap-page="true"
     inkscape:snap-nodes="false">
    <inkscape:grid
       type="xygrid"
       id="grid10" />
  </sodipodi:namedview>
  <metadata
     id="metadata5">
    <rdf:RDF>
      <cc:Work
         rdf:about="">
        <dc:format>image/svg+xml</dc:format>
        <dc:type
           rdf:resource="http://purl.org/dc/dcmitype/StillImage" />
        <dc:title></dc:title>
      </cc:Work>
    </rdf:RDF>
  </metadata>
  <g
     inkscape:label="レイヤー 1"
     inkscape:groupmode="layer"
     id="layer1"
     transform="translate(0,-288.53332)">
    <rect
       style="fill:#0000ff;fill-opacity:0.10096154;stroke:none;stroke-width:1.05833328;stroke-miterlimit:4;stroke-dasharray:none;stroke-opacity:1"
       id="rect4543"
       width="8.4666662"
       height="8.4666662"
       x="-5.2041704e-016"
       y="288.53333" />
    <g
       transform="matrix(0.53683464,0,0,0.53723528,-0.48887214,137.6356)"
       id="g32"
       style="stroke-width:0.98534871;stroke-miterlimit:4;stroke-dasharray:none">
      <g
         transform="matrix(0.89206652,0,0,0.8611808,0.94941124,40.087264)"
         id="g828"
         style="stroke-width:1.1242015;stroke-miterlimit:4;stroke-dasharray:none">
        <path
           style="fill:none;fill-opacity:1;stroke:#000000;stroke-width:1.1242015;stroke-miterlimit:4;stroke-dasharray:none;stroke-opacity:1"
           d="m 10.098526,284.56577 c 3.434547,0 5.320685,0.55049 5.320685,4.05853 0,3.50804 -3.996704,6.39773 -7.4312508,6.39773 M 7.5088915,292.5088 c -3.4345474,0 -5.3355787,-0.3306 -5.335579,-3.83864 3e-7,-3.50804 2.6495343,-6.21426 6.0840817,-6.21426"
           id="path4872"
           inkscape:connector-curvature="0"
           sodipodi:nodetypes="csccsc" />
        <path
           style="fill:none;stroke:#000000;stroke-width:1.1242015;stroke-linecap:butt;stroke-linejoin:miter;stroke-miterlimit:4;stroke-dasharray:none;stroke-opacity:1"
           d="M 10.942752,296.24609 7.9879602,295.02203 9.9099226,292.9437"
           id="path4877"
           inkscape:connector-curvature="0"
           sodipodi:nodetypes="ccc" />
        <path
           style="fill:none;stroke:#000000;stroke-width:1.1242015;stroke-linecap:butt;stroke-linejoin:miter;stroke-miterlimit:4;stroke-dasharray:none;stroke-opacity:1"
           d="m 4.9703,281.27526 3.2870943,1.18064 -1.9399246,2.4153"
           id="path4879"
           inkscape:connector-curvature="0"
           sodipodi:nodetypes="ccc" />
      </g>
    </g>
  </g>
</svg>

```

`src/svg/save.svg`:

```svg
<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!-- Created with Inkscape (http://www.inkscape.org/) -->

<svg
   xmlns:dc="http://purl.org/dc/elements/1.1/"
   xmlns:cc="http://creativecommons.org/ns#"
   xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#"
   xmlns:svg="http://www.w3.org/2000/svg"
   xmlns="http://www.w3.org/2000/svg"
   xmlns:sodipodi="http://sodipodi.sourceforge.net/DTD/sodipodi-0.dtd"
   xmlns:inkscape="http://www.inkscape.org/namespaces/inkscape"
   width="32"
   height="32"
   viewBox="0 0 8.4666665 8.4666669"
   version="1.1"
   id="svg8"
   inkscape:version="0.92.3 (2405546, 2018-03-11)"
   sodipodi:docname="save.svg"
   inkscape:export-filename="C:\Users\katahiromz\Desktop\bitmap.png"
   inkscape:export-xdpi="96"
   inkscape:export-ydpi="96">
  <defs
     id="defs2">
    <marker
       inkscape:stockid="Arrow2Mstart"
       orient="auto"
       refY="0"
       refX="0"
       id="Arrow2Mstart-8"
       style="overflow:visible"
       inkscape:isstock="true">
      <path
         inkscape:connector-curvature="0"
         id="path852-4"
         style="fill:#000000;fill-opacity:1;fill-rule:evenodd;stroke:#000000;stroke-width:0.625;stroke-linejoin:round;stroke-opacity:1"
         d="M 8.7185878,4.0337352 -2.2072895,0.01601326 8.7185884,-4.0017078 c -1.7454984,2.3720609 -1.7354408,5.6174519 -6e-7,8.035443 z"
         transform="scale(0.6)" />
    </marker>
  </defs>
  <sodipodi:namedview
     id="base"
     pagecolor="#ffffff"
     bordercolor="#666666"
     borderopacity="1.0"
     inkscape:pageopacity="0.0"
     inkscape:pageshadow="2"
     inkscape:zoom="11.2"
     inkscape:cx="14.879315"
     inkscape:cy="18.020463"
     inkscape:document-units="mm"
     inkscape:current-layer="layer1"
     showgrid="true"
     units="px"
     inkscape:snap-text-baseline="true"
     inkscape:snap-center="true"
     inkscape:snap-object-midpoints="true"
     inkscape:snap-midpoints="true"
     inkscape:snap-smooth-nodes="true"
     inkscape:object-paths="true"
     inkscape:snap-intersection-paths="true"
     inkscape:snap-bbox="true"
     inkscape:bbox-paths="true"
     inkscape:bbox-nodes="true"
     inkscape:snap-bbox-edge-midpoints="true"
     inkscape:snap-bbox-midpoints="true"
     inkscape:window-width="1366"
     inkscape:window-height="705"
     inkscape:window-x="-8"
     inkscape:window-y="-8"
     inkscape:window-maximized="1"
     inkscape:snap-global="true"
     inkscape:snap-others="false"
     inkscape:snap-page="true"
     inkscape:snap-nodes="false">
    <inkscape:grid
       type="xygrid"
       id="grid10" />
  </sodipodi:namedview>
  <metadata
     id="metadata5">
    <rdf:RDF>
      <cc:Work
         rdf:about="">
        <dc:format>image/svg+xml</dc:format>
        <dc:type
           rdf:resource="http://purl.org/dc/dcmitype/StillImage" />
        <dc:title></dc:title>
      </cc:Work>
    </rdf:RDF>
  </metadata>
  <g
     inkscape:label="レイヤー 1"
     inkscape:groupmode="layer"
     id="layer1"
     transform="translate(0,-288.53332)">
    <rect
       style="fill:#0000ff;fill-opacity:0.10096154;stroke:none;stroke-width:1.05833328;stroke-miterlimit:4;stroke-dasharray:none;stroke-opacity:1"
       id="rect4543"
       width="8.4666662"
       height="8.4666662"
       x="-5.2041704e-016"
       y="288.53333" />
    <path
       style="fill:#000000;fill-opacity:1;stroke:#000000;stroke-width:0.52911663;stroke-linecap:butt;stroke-linejoin:miter;stroke-miterlimit:4;stroke-dasharray:none;stroke-opacity:1"
       d="m 0.79302544,289.32634 v 6.87992 H 7.6729417 v -5.95331 l -0.9265983,-0.92661 z"
       id="rect4910"
       inkscape:connector-curvature="0" />
    <rect
       style="fill:#ffffff;fill-opacity:1;stroke:#000000;stroke-width:0.26458333;stroke-linecap:butt;stroke-linejoin:miter;stroke-miterlimit:4;stroke-dasharray:none;stroke-opacity:1"
       id="rect4928"
       width="4.4977522"
       height="2.6456583"
       x="1.7198738"
       y="289.19485"
       ry="0.331352"
       rx="0.30016196" />
    <rect
       style="fill:#d7ffff;fill-opacity:1;stroke:#000000;stroke-width:0.26458333;stroke-linecap:butt;stroke-linejoin:miter;stroke-miterlimit:4;stroke-dasharray:none;stroke-opacity:1"
       id="rect4928-1"
       width="5.5545712"
       height="3.7024877"
       x="1.4560479"
       y="292.63519"
       ry="0.28445905"
       rx="0.30831411" />
    <rect
       style="fill:#000000;fill-opacity:1;stroke:#000000;stroke-width:0;stroke-linecap:butt;stroke-linejoin:miter;stroke-miterlimit:4;stroke-dasharray:none;stroke-opacity:1"
       id="rect4928-9"
       width="0.79374933"
       height="1.8520919"
       x="4.4979172"
       y="289.59164" />
    <path
       style="fill:none;stroke:#000000;stroke-width:0.26458332;stroke-linecap:butt;stroke-linejoin:miter;stroke-miterlimit:4;stroke-dasharray:none;stroke-opacity:1"
       d="M 2.1166667,293.42811 H 6.35"
       id="path4975"
       inkscape:connector-curvature="0" />
    <path
       style="fill:none;stroke:#000000;stroke-width:0.26458332;stroke-linecap:butt;stroke-linejoin:miter;stroke-miterlimit:4;stroke-dasharray:none;stroke-opacity:1"
       d="M 2.1166667,294.48645 H 6.35"
       id="path4975-0"
       inkscape:connector-curvature="0" />
    <path
       style="fill:none;stroke:#000000;stroke-width:0.26458332;stroke-linecap:butt;stroke-linejoin:miter;stroke-miterlimit:4;stroke-dasharray:none;stroke-opacity:1"
       d="M 2.1166667,295.54478 H 6.35"
       id="path4975-5"
       inkscape:connector-curvature="0" />
  </g>
</svg>

```

`src/svg/test.svg`:

```svg
<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!-- Created with Inkscape (http://www.inkscape.org/) -->

<svg
   xmlns:dc="http://purl.org/dc/elements/1.1/"
   xmlns:cc="http://creativecommons.org/ns#"
   xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#"
   xmlns:svg="http://www.w3.org/2000/svg"
   xmlns="http://www.w3.org/2000/svg"
   xmlns:sodipodi="http://sodipodi.sourceforge.net/DTD/sodipodi-0.dtd"
   xmlns:inkscape="http://www.inkscape.org/namespaces/inkscape"
   width="32"
   height="32"
   viewBox="0 0 8.4666665 8.4666669"
   version="1.1"
   id="svg8"
   inkscape:version="0.92.3 (2405546, 2018-03-11)"
   sodipodi:docname="test.svg"
   inkscape:export-filename="C:\Users\katahiromz\Desktop\bitmap.png"
   inkscape:export-xdpi="96"
   inkscape:export-ydpi="96">
  <defs
     id="defs2">
    <marker
       inkscape:stockid="Arrow2Mstart"
       orient="auto"
       refY="0"
       refX="0"
       id="Arrow2Mstart-8"
       style="overflow:visible"
       inkscape:isstock="true">
      <path
         inkscape:connector-curvature="0"
         id="path852-4"
         style="fill:#000000;fill-opacity:1;fill-rule:evenodd;stroke:#000000;stroke-width:0.625;stroke-linejoin:round;stroke-opacity:1"
         d="M 8.7185878,4.0337352 -2.2072895,0.01601326 8.7185884,-4.0017078 c -1.7454984,2.3720609 -1.7354408,5.6174519 -6e-7,8.035443 z"
         transform="scale(0.6)" />
    </marker>
  </defs>
  <sodipodi:namedview
     id="base"
     pagecolor="#ffffff"
     bordercolor="#666666"
     borderopacity="1.0"
     inkscape:pageopacity="0.0"
     inkscape:pageshadow="2"
     inkscape:zoom="11.2"
     inkscape:cx="14.338663"
     inkscape:cy="17.079526"
     inkscape:document-units="mm"
     inkscape:current-layer="layer1"
     showgrid="true"
     units="px"
     inkscape:snap-text-baseline="true"
     inkscape:snap-center="true"
     inkscape:snap-object-midpoints="true"
     inkscape:snap-midpoints="true"
     inkscape:snap-smooth-nodes="true"
     inkscape:object-paths="true"
     inkscape:snap-intersection-paths="true"
     inkscape:snap-bbox="true"
     inkscape:bbox-paths="true"
     inkscape:bbox-nodes="true"
     inkscape:snap-bbox-edge-midpoints="true"
     inkscape:snap-bbox-midpoints="true"
     inkscape:window-width="1366"
     inkscape:window-height="705"
     inkscape:window-x="-8"
     inkscape:window-y="-8"
     inkscape:window-maximized="1"
     inkscape:snap-global="true"
     inkscape:snap-others="false"
     inkscape:snap-page="true"
     inkscape:snap-nodes="false">
    <inkscape:grid
       type="xygrid"
       id="grid10" />
  </sodipodi:namedview>
  <metadata
     id="metadata5">
    <rdf:RDF>
      <cc:Work
         rdf:about="">
        <dc:format>image/svg+xml</dc:format>
        <dc:type
           rdf:resource="http://purl.org/dc/dcmitype/StillImage" />
        <dc:title></dc:title>
      </cc:Work>
    </rdf:RDF>
  </metadata>
  <g
     inkscape:label="レイヤー 1"
     inkscape:groupmode="layer"
     id="layer1"
     transform="translate(0,-288.53332)">
    <rect
       style="fill:#0000ff;fill-opacity:0.10096154;stroke:none;stroke-width:1.05833328;stroke-miterlimit:4;stroke-dasharray:none;stroke-opacity:1"
       id="rect4543"
       width="8.4666662"
       height="8.4666662"
       x="-5.2041704e-016"
       y="288.53333" />
    <path
       style="fill:none;stroke:#000000;stroke-width:0.52916667;stroke-linecap:butt;stroke-linejoin:miter;stroke-miterlimit:4;stroke-dasharray:none;stroke-opacity:1"
       d="M 0,291.44374 H 2.1166664"
       id="path4975-0"
       inkscape:connector-curvature="0" />
    <path
       style="fill:none;stroke:#000000;stroke-width:0.52916667;stroke-linecap:butt;stroke-linejoin:miter;stroke-miterlimit:4;stroke-dasharray:none;stroke-opacity:1"
       d="m 1.0583331,291.17916 v 2.64583"
       id="path4975-0-3-5-8"
       inkscape:connector-curvature="0" />
    <path
       style="fill:none;stroke:#000000;stroke-width:0.52916667;stroke-linecap:butt;stroke-linejoin:miter;stroke-miterlimit:4;stroke-dasharray:none;stroke-opacity:1"
       d="M 2.3812499,291.44374 H 3.9687497"
       id="path4975-0-4"
       inkscape:connector-curvature="0" />
    <path
       style="fill:none;stroke:#000000;stroke-width:0.52916667;stroke-linecap:butt;stroke-linejoin:miter;stroke-miterlimit:4;stroke-dasharray:none;stroke-opacity:1"
       d="M 2.3812499,293.5604 H 3.9687498"
       id="path4975-0-4-8"
       inkscape:connector-curvature="0" />
    <path
       style="fill:none;stroke:#000000;stroke-width:0.52916667;stroke-linecap:butt;stroke-linejoin:miter;stroke-miterlimit:4;stroke-dasharray:none;stroke-opacity:1"
       d="m 2.6458332,291.17916 v 2.64583"
       id="path4975-0-3-5"
       inkscape:connector-curvature="0" />
    <path
       style="fill:none;stroke:#000000;stroke-width:0.52916667;stroke-linecap:butt;stroke-linejoin:miter;stroke-miterlimit:4;stroke-dasharray:none;stroke-opacity:1"
       d="M 2.3812499,292.50207 H 3.7041665"
       id="path4975-0-4-9"
       inkscape:connector-curvature="0" />
    <path
       style="fill:none;stroke:#000000;stroke-width:0.5291667;stroke-linecap:butt;stroke-linejoin:miter;stroke-miterlimit:4;stroke-dasharray:none;stroke-opacity:1"
       d="M 4.2333335,291.44374 H 6.0854167"
       id="path4975-0-4-9-7"
       inkscape:connector-curvature="0" />
    <path
       style="fill:none;stroke:#000000;stroke-width:0.52916667;stroke-linecap:butt;stroke-linejoin:miter;stroke-miterlimit:4;stroke-dasharray:none;stroke-opacity:1"
       d="M 4.2333333,293.5604 H 6.0854165"
       id="path4975-0-4-9-7-6"
       inkscape:connector-curvature="0" />
    <path
       style="fill:none;stroke:#000000;stroke-width:0.52916667;stroke-linecap:butt;stroke-linejoin:round;stroke-miterlimit:4;stroke-dasharray:none;stroke-opacity:1"
       d="m 5.845764,293.03789 -1.4141386,-1.6008"
       id="path4975-0-4-9-7-6-9"
       inkscape:connector-curvature="0" />
    <g
       id="g5105-7"
       transform="translate(5.8208331,0.26458668)"
       style="stroke-width:0.52916667;stroke-miterlimit:4;stroke-dasharray:none">
      <path
         inkscape:connector-curvature="0"
         id="path4975-0-1"
         d="M 0.52916693,291.17915 H 2.6458333"
         style="fill:none;stroke:#000000;stroke-width:0.52916667;stroke-linecap:butt;stroke-linejoin:miter;stroke-miterlimit:4;stroke-dasharray:none;stroke-opacity:1" />
      <path
         inkscape:connector-curvature="0"
         id="path4975-0-3-5-8-7"
         d="m 1.5875,290.91457 v 2.64583"
         style="fill:none;stroke:#000000;stroke-width:0.52916667;stroke-linecap:butt;stroke-linejoin:miter;stroke-miterlimit:4;stroke-dasharray:none;stroke-opacity:1" />
    </g>
    <path
       style="fill:none;stroke:#000000;stroke-width:0.52916667;stroke-linecap:butt;stroke-linejoin:bevel;stroke-miterlimit:4;stroke-dasharray:none;stroke-opacity:1"
       d="m 5.8208333,292.76665 v 1.05834"
       id="path4975-0-3-5-8-0"
       inkscape:connector-curvature="0" />
  </g>
</svg>

```

`src/svg/tools.svg`:

```svg
<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!-- Created with Inkscape (http://www.inkscape.org/) -->

<svg
   xmlns:dc="http://purl.org/dc/elements/1.1/"
   xmlns:cc="http://creativecommons.org/ns#"
   xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#"
   xmlns:svg="http://www.w3.org/2000/svg"
   xmlns="http://www.w3.org/2000/svg"
   xmlns:xlink="http://www.w3.org/1999/xlink"
   xmlns:sodipodi="http://sodipodi.sourceforge.net/DTD/sodipodi-0.dtd"
   xmlns:inkscape="http://www.inkscape.org/namespaces/inkscape"
   width="480"
   height="32"
   viewBox="0 0 126.99999 8.466667"
   version="1.1"
   id="svg8"
   inkscape:version="0.92.3 (2405546, 2018-03-11)"
   sodipodi:docname="tools.svg"
   inkscape:export-filename="C:\Users\katahiromz\Documents\DEV\ProjectRisohEditor\RisohEditor\src\res\tools.png"
   inkscape:export-xdpi="96.000008"
   inkscape:export-ydpi="96.000008">
  <defs
     id="defs2">
    <marker
       inkscape:isstock="true"
       style="overflow:visible"
       id="Arrow2Mstart"
       refX="0.0"
       refY="0.0"
       orient="auto"
       inkscape:stockid="Arrow2Mstart">
      <path
         transform="scale(0.6) translate(0,0)"
         d="M 8.7185878,4.0337352 L -2.2072895,0.016013256 L 8.7185884,-4.0017078 C 6.9730900,-1.6296469 6.9831476,1.6157441 8.7185878,4.0337352 z "
         style="fill-rule:evenodd;stroke-width:0.625;stroke-linejoin:round;stroke:#000000;stroke-opacity:1;fill:#000000;fill-opacity:1"
         id="path852" />
    </marker>
    <marker
       inkscape:isstock="true"
       style="overflow:visible"
       id="Arrow1Lstart"
       refX="0.0"
       refY="0.0"
       orient="auto"
       inkscape:stockid="Arrow1Lstart">
      <path
         transform="scale(0.8) translate(12.5,0)"
         style="fill-rule:evenodd;stroke:#000000;stroke-width:1pt;stroke-opacity:1;fill:#000000;fill-opacity:1"
         d="M 0.0,0.0 L 5.0,-5.0 L -12.5,0.0 L 5.0,5.0 L 0.0,0.0 z "
         id="path828" />
    </marker>
    <marker
       inkscape:isstock="true"
       style="overflow:visible"
       id="Arrow2Mstart-8"
       refX="0"
       refY="0"
       orient="auto"
       inkscape:stockid="Arrow2Mstart">
      <path
         transform="scale(0.6)"
         d="M 8.7185878,4.0337352 -2.2072895,0.01601326 8.7185884,-4.0017078 c -1.7454984,2.3720609 -1.7354408,5.6174519 -6e-7,8.035443 z"
         style="fill:#000000;fill-opacity:1;fill-rule:evenodd;stroke:#000000;stroke-width:0.625;stroke-linejoin:round;stroke-opacity:1"
         id="path852-4"
         inkscape:connector-curvature="0" />
    </marker>
    <marker
       inkscape:isstock="true"
       style="overflow:visible"
       id="Arrow2Mstart-8-3"
       refX="0"
       refY="0"
       orient="auto"
       inkscape:stockid="Arrow2Mstart">
      <path
         transform="scale(0.6)"
         d="M 8.7185878,4.0337352 -2.2072895,0.01601326 8.7185884,-4.0017078 c -1.7454984,2.3720609 -1.7354408,5.6174519 -6e-7,8.035443 z"
         style="fill:#000000;fill-opacity:1;fill-rule:evenodd;stroke:#000000;stroke-width:0.625;stroke-linejoin:round;stroke-opacity:1"
         id="path852-4-4"
         inkscape:connector-curvature="0" />
    </marker>
    <linearGradient
       id="linearGradient4858"
       inkscape:collect="always">
      <stop
         id="stop4854"
         offset="0"
         style="stop-color:#ffff72;stop-opacity:1" />
      <stop
         id="stop4856"
         offset="1"
         style="stop-color:#ffffff;stop-opacity:1" />
    </linearGradient>
    <marker
       inkscape:isstock="true"
       style="overflow:visible"
       id="Arrow2Mstart-8-5"
       refX="0"
       refY="0"
       orient="auto"
       inkscape:stockid="Arrow2Mstart">
      <path
         transform="scale(0.6)"
         d="M 8.7185878,4.0337352 -2.2072895,0.01601326 8.7185884,-4.0017078 c -1.7454984,2.3720609 -1.7354408,5.6174519 -6e-7,8.035443 z"
         style="fill:#000000;fill-opacity:1;fill-rule:evenodd;stroke:#000000;stroke-width:0.625;stroke-linejoin:round;stroke-opacity:1"
         id="path852-4-49"
         inkscape:connector-curvature="0" />
    </marker>
    <linearGradient
       gradientUnits="userSpaceOnUse"
       y2="16"
       x2="27.001953"
       y1="16"
       x1="4.9980468"
       id="linearGradient4860"
       xlink:href="#linearGradient4858"
       inkscape:collect="always"
       gradientTransform="matrix(0.26458333,0,0,0.26458333,46.566663,284.29998)" />
    <marker
       inkscape:isstock="true"
       style="overflow:visible"
       id="Arrow2Mstart-8-1"
       refX="0"
       refY="0"
       orient="auto"
       inkscape:stockid="Arrow2Mstart">
      <path
         transform="scale(0.6)"
         d="M 8.7185878,4.0337352 -2.2072895,0.01601326 8.7185884,-4.0017078 c -1.7454984,2.3720609 -1.7354408,5.6174519 -6e-7,8.035443 z"
         style="fill:#000000;fill-opacity:1;fill-rule:evenodd;stroke:#000000;stroke-width:0.625;stroke-linejoin:round;stroke-opacity:1"
         id="path852-4-6"
         inkscape:connector-curvature="0" />
    </marker>
    <marker
       inkscape:isstock="true"
       style="overflow:visible"
       id="Arrow2Mstart-8-6"
       refX="0"
       refY="0"
       orient="auto"
       inkscape:stockid="Arrow2Mstart">
      <path
         transform="scale(0.6)"
         d="M 8.7185878,4.0337352 -2.2072895,0.01601326 8.7185884,-4.0017078 c -1.7454984,2.3720609 -1.7354408,5.6174519 -6e-7,8.035443 z"
         style="fill:#000000;fill-opacity:1;fill-rule:evenodd;stroke:#000000;stroke-width:0.625;stroke-linejoin:round;stroke-opacity:1"
         id="path852-4-0"
         inkscape:connector-curvature="0" />
    </marker>
    <marker
       inkscape:isstock="true"
       style="overflow:visible"
       id="Arrow2Mstart-8-9"
       refX="0"
       refY="0"
       orient="auto"
       inkscape:stockid="Arrow2Mstart">
      <path
         transform="scale(0.6)"
         d="M 8.7185878,4.0337352 -2.2072895,0.01601326 8.7185884,-4.0017078 c -1.7454984,2.3720609 -1.7354408,5.6174519 -6e-7,8.035443 z"
         style="fill:#000000;fill-opacity:1;fill-rule:evenodd;stroke:#000000;stroke-width:0.625;stroke-linejoin:round;stroke-opacity:1"
         id="path852-4-3"
         inkscape:connector-curvature="0" />
    </marker>
    <marker
       inkscape:isstock="true"
       style="overflow:visible"
       id="Arrow2Mstart-8-69"
       refX="0"
       refY="0"
       orient="auto"
       inkscape:stockid="Arrow2Mstart">
      <path
         transform="scale(0.6)"
         d="M 8.7185878,4.0337352 -2.2072895,0.01601326 8.7185884,-4.0017078 c -1.7454984,2.3720609 -1.7354408,5.6174519 -6e-7,8.035443 z"
         style="fill:#000000;fill-opacity:1;fill-rule:evenodd;stroke:#000000;stroke-width:0.625;stroke-linejoin:round;stroke-opacity:1"
         id="path852-4-1"
         inkscape:connector-curvature="0" />
    </marker>
    <marker
       inkscape:isstock="true"
       style="overflow:visible"
       id="Arrow2Mstart-8-99"
       refX="0"
       refY="0"
       orient="auto"
       inkscape:stockid="Arrow2Mstart">
      <path
         transform="scale(0.6)"
         d="M 8.7185878,4.0337352 -2.2072895,0.01601326 8.7185884,-4.0017078 c -1.7454984,2.3720609 -1.7354408,5.6174519 -6e-7,8.035443 z"
         style="fill:#000000;fill-opacity:1;fill-rule:evenodd;stroke:#000000;stroke-width:0.625;stroke-linejoin:round;stroke-opacity:1"
         id="path852-4-65"
         inkscape:connector-curvature="0" />
    </marker>
    <marker
       inkscape:isstock="true"
       style="overflow:visible"
       id="Arrow2Mstart-8-53"
       refX="0"
       refY="0"
       orient="auto"
       inkscape:stockid="Arrow2Mstart">
      <path
         transform="scale(0.6)"
         d="M 8.7185878,4.0337352 -2.2072895,0.01601326 8.7185884,-4.0017078 c -1.7454984,2.3720609 -1.7354408,5.6174519 -6e-7,8.035443 z"
         style="fill:#000000;fill-opacity:1;fill-rule:evenodd;stroke:#000000;stroke-width:0.625;stroke-linejoin:round;stroke-opacity:1"
         id="path852-4-16"
         inkscape:connector-curvature="0" />
    </marker>
    <marker
       inkscape:isstock="true"
       style="overflow:visible"
       id="Arrow2Mstart-8-2"
       refX="0"
       refY="0"
       orient="auto"
       inkscape:stockid="Arrow2Mstart">
      <path
         transform="scale(0.6)"
         d="M 8.7185878,4.0337352 -2.2072895,0.01601326 8.7185884,-4.0017078 c -1.7454984,2.3720609 -1.7354408,5.6174519 -6e-7,8.035443 z"
         style="fill:#000000;fill-opacity:1;fill-rule:evenodd;stroke:#000000;stroke-width:0.625;stroke-linejoin:round;stroke-opacity:1"
         id="path852-4-5"
         inkscape:connector-curvature="0" />
    </marker>
    <marker
       inkscape:isstock="true"
       style="overflow:visible"
       id="Arrow2Mstart-8-8"
       refX="0"
       refY="0"
       orient="auto"
       inkscape:stockid="Arrow2Mstart">
      <path
         transform="scale(0.6)"
         d="M 8.7185878,4.0337352 -2.2072895,0.01601326 8.7185884,-4.0017078 c -1.7454984,2.3720609 -1.7354408,5.6174519 -6e-7,8.035443 z"
         style="fill:#000000;fill-opacity:1;fill-rule:evenodd;stroke:#000000;stroke-width:0.625;stroke-linejoin:round;stroke-opacity:1"
         id="path852-4-7"
         inkscape:connector-curvature="0" />
    </marker>
    <marker
       inkscape:isstock="true"
       style="overflow:visible"
       id="Arrow2Mstart-8-538"
       refX="0"
       refY="0"
       orient="auto"
       inkscape:stockid="Arrow2Mstart">
      <path
         transform="scale(0.6)"
         d="M 8.7185878,4.0337352 -2.2072895,0.01601326 8.7185884,-4.0017078 c -1.7454984,2.3720609 -1.7354408,5.6174519 -6e-7,8.035443 z"
         style="fill:#000000;fill-opacity:1;fill-rule:evenodd;stroke:#000000;stroke-width:0.625;stroke-linejoin:round;stroke-opacity:1"
         id="path852-4-46"
         inkscape:connector-curvature="0" />
    </marker>
  </defs>
  <sodipodi:namedview
     id="base"
     pagecolor="#ffffff"
     bordercolor="#666666"
     borderopacity="1.0"
     inkscape:pageopacity="0.0"
     inkscape:pageshadow="2"
     inkscape:zoom="1.98"
     inkscape:cx="236.14851"
     inkscape:cy="36.248889"
     inkscape:document-units="mm"
     inkscape:current-layer="layer1"
     showgrid="true"
     units="px"
     inkscape:snap-bbox="true"
     inkscape:bbox-paths="true"
     inkscape:bbox-nodes="true"
     inkscape:snap-bbox-midpoints="true"
     inkscape:snap-bbox-edge-midpoints="true"
     inkscape:object-paths="true"
     inkscape:snap-intersection-paths="true"
     inkscape:snap-midpoints="true"
     inkscape:snap-smooth-nodes="true"
     inkscape:snap-object-midpoints="true"
     inkscape:snap-center="true"
     inkscape:snap-text-baseline="true"
     inkscape:snap-page="true"
     inkscape:window-width="1366"
     inkscape:window-height="705"
     inkscape:window-x="-8"
     inkscape:window-y="-8"
     inkscape:window-maximized="1"
     fit-margin-top="0"
     fit-margin-left="0"
     fit-margin-right="0"
     fit-margin-bottom="0"
     inkscape:snap-to-guides="true"
     inkscape:snap-others="true"
     inkscape:object-nodes="true"
     inkscape:snap-nodes="true"
     showguides="false"
     inkscape:snap-global="false">
    <inkscape:grid
       type="xygrid"
       id="grid898"
       spacingx="0.26458333"
       spacingy="0.26458333"
       empspacing="32"
       dotted="false" />
  </sodipodi:namedview>
  <metadata
     id="metadata5">
    <rdf:RDF>
      <cc:Work
         rdf:about="">
        <dc:format>image/svg+xml</dc:format>
        <dc:type
           rdf:resource="http://purl.org/dc/dcmitype/StillImage" />
        <dc:title></dc:title>
      </cc:Work>
    </rdf:RDF>
  </metadata>
  <g
     inkscape:label="レイヤー 1"
     inkscape:groupmode="layer"
     id="layer1"
     transform="translate(-46.566663,-284.29998)">
    <rect
       style="fill:#ff00ff;fill-opacity:1;stroke:none;stroke-width:0.86610311;stroke-miterlimit:4;stroke-dasharray:none;stroke-opacity:1"
       id="rect125"
       width="126.99999"
       height="8.4666662"
       x="46.566662"
       y="284.29999" />
    <g
       id="g4627"
       transform="matrix(0.52606983,0,0,0.51504941,156.23923,139.80787)" />
    <g
       id="g4627-9"
       transform="matrix(0.52606983,0,0,-0.5150494,164.70589,437.25876)" />
    <path
       inkscape:connector-curvature="0"
       style="fill:url(#linearGradient4860);fill-opacity:1;stroke:#000000;stroke-width:0.5291667;stroke-linecap:round;stroke-miterlimit:4;stroke-dasharray:none;stroke-opacity:1"
       d="m 48.153646,285.09321 v 6.8802 h 5.2927 v -4.72374 l -2.156457,-2.15646 z"
       id="rect4781" />
    <path
       style="fill:#ffffd5;fill-opacity:1;stroke:#000000;stroke-width:0.5291667;stroke-linecap:butt;stroke-linejoin:bevel;stroke-miterlimit:4;stroke-dasharray:none;stroke-opacity:1"
       d="m 53.406051,287.21461 -2.079857,-2.01315 v 2.01315 z"
       id="rect4799"
       inkscape:connector-curvature="0" />
    <path
       inkscape:connector-curvature="0"
       style="fill:#ffff00;fill-opacity:1;stroke:#000000;stroke-width:0.51855993;stroke-linecap:butt;stroke-linejoin:bevel;stroke-miterlimit:4;stroke-dasharray:none;stroke-opacity:1"
       d="m 55.927849,285.35935 c -0.201859,0 -0.364319,0.1719 -0.364319,0.3855 v 1.04852 c -0.002,0.0222 -0.0062,0.0439 -0.0062,0.0667 v 4.4049 c 0,0.39459 0.300324,0.7121 0.673344,0.7121 h 4.484481 c 0.373019,0 0.673343,-0.31751 0.673343,-0.7121 v -4.4049 c 0,-0.39459 -0.300324,-0.7121 -0.673343,-0.7121 H 58.71941 v -0.40308 c 0,-0.2136 -0.162461,-0.3855 -0.364319,-0.3855 z"
       id="rect4862" />
    <rect
       style="fill:#ffff00;fill-opacity:1;stroke:#000000;stroke-width:0.48942181;stroke-linecap:butt;stroke-linejoin:bevel;stroke-miterlimit:4;stroke-dasharray:none;stroke-opacity:1"
       id="rect4862-7"
       width="5.9425092"
       height="4.6363621"
       x="114.03581"
       y="293.0777"
       rx="0.68614542"
       ry="0.56647909"
       transform="matrix(1,0,-0.19502072,0.98079912,0,0)" />
    <path
       style="fill:#000000;fill-opacity:1;stroke:#000000;stroke-width:0.52911663;stroke-linecap:butt;stroke-linejoin:miter;stroke-miterlimit:4;stroke-dasharray:none;stroke-opacity:1"
       d="m 64.293021,285.093 v 6.87992 h 6.879917 v -5.95331 L 70.246339,285.093 Z"
       id="rect4910"
       inkscape:connector-curvature="0" />
    <rect
       style="fill:#ffffff;fill-opacity:1;stroke:#000000;stroke-width:0.26458332;stroke-linecap:butt;stroke-linejoin:miter;stroke-miterlimit:4;stroke-dasharray:none;stroke-opacity:1"
       id="rect4928"
       width="4.4977522"
       height="2.6456583"
       x="65.219872"
       y="284.96152"
       ry="0.331352"
       rx="0.30016196" />
    <rect
       style="fill:#d7ffff;fill-opacity:1;stroke:#000000;stroke-width:0.26458332;stroke-linecap:butt;stroke-linejoin:miter;stroke-miterlimit:4;stroke-dasharray:none;stroke-opacity:1"
       id="rect4928-1"
       width="5.5545712"
       height="3.7024877"
       x="64.956047"
       y="288.40186"
       ry="0.28445905"
       rx="0.30831411" />
    <rect
       style="fill:#000000;fill-opacity:1;stroke:#000000;stroke-width:0;stroke-linecap:butt;stroke-linejoin:miter;stroke-miterlimit:4;stroke-dasharray:none;stroke-opacity:1"
       id="rect4928-9"
       width="0.79374933"
       height="1.8520919"
       x="67.99791"
       y="285.35831" />
    <path
       style="fill:none;stroke:#000000;stroke-width:0.26458332;stroke-linecap:butt;stroke-linejoin:miter;stroke-miterlimit:4;stroke-dasharray:none;stroke-opacity:1"
       d="m 65.616663,289.19477 h 4.233333"
       id="path4975"
       inkscape:connector-curvature="0" />
    <path
       style="fill:none;stroke:#000000;stroke-width:0.26458332;stroke-linecap:butt;stroke-linejoin:miter;stroke-miterlimit:4;stroke-dasharray:none;stroke-opacity:1"
       d="m 65.616663,290.25311 h 4.233333"
       id="path4975-0"
       inkscape:connector-curvature="0" />
    <path
       style="fill:none;stroke:#000000;stroke-width:0.26458332;stroke-linecap:butt;stroke-linejoin:miter;stroke-miterlimit:4;stroke-dasharray:none;stroke-opacity:1"
       d="m 65.616663,291.31144 h 4.233333"
       id="path4975-5"
       inkscape:connector-curvature="0" />
    <path
       style="fill:#ffff00;fill-opacity:1;stroke:#000000;stroke-width:0.26458332;stroke-linecap:round;stroke-miterlimit:4;stroke-dasharray:none;stroke-opacity:1"
       d="m 79.558984,291.8923 v -4.85914 l -1.399914,1.40043 -2.368848,-2.36884 -2.058789,2.05878 2.368848,2.36885 -1.400432,1.39992 z"
       id="rect4717"
       inkscape:connector-curvature="0" />
    <path
       inkscape:connector-curvature="0"
       style="fill:#ffff00;fill-opacity:1;stroke:#000000;stroke-width:0.26458332;stroke-linecap:round;stroke-miterlimit:4;stroke-dasharray:none;stroke-opacity:1"
       d="m 82.143303,286.00995 v 4.85914 l 1.399915,-1.40043 2.368847,2.36884 2.058789,-2.05878 -2.368847,-2.36885 1.400431,-1.39992 z"
       id="rect4717-6" />
    <path
       inkscape:connector-curvature="0"
       style="fill:#ff0000;fill-opacity:1;stroke:#000000;stroke-width:0.52913481;stroke-linecap:round;stroke-miterlimit:4;stroke-dasharray:none;stroke-opacity:1"
       d="m 92.339579,285.09373 v 2.64583 h -2.645833 v 1.5875 h 2.645833 v 2.64584 h 1.5875 v -2.64584 h 2.645834 v -1.5875 h -2.645834 v -2.64583 z"
       id="rect4763" />
    <rect
       style="fill:#0000ff;fill-opacity:1;stroke:#000000;stroke-width:0.52913481;stroke-linecap:round;stroke-miterlimit:4;stroke-dasharray:none;stroke-opacity:1"
       id="rect4763-2"
       width="6.8791986"
       height="1.5875404"
       x="98.1604"
       y="287.73953" />
    <path
       inkscape:connector-curvature="0"
       style="fill:#00ff00;fill-opacity:1;stroke:#000000;stroke-width:0.26458332;stroke-linecap:round;stroke-miterlimit:4;stroke-dasharray:none;stroke-opacity:1"
       d="m 109.39849,285.48699 v 1.88929 l -1.63608,-0.94465 -0.66766,1.15704 1.63608,0.94464 -1.63608,0.94465 0.66766,1.15703 1.63608,-0.94464 v 1.88929 h 1.33635 v -1.88929 l 1.63608,0.94464 0.66765,-1.15703 -1.63607,-0.94465 1.63607,-0.94464 -0.66765,-1.15704 -1.63608,0.94465 v -1.88929 z"
       id="rect4544-9" />
    <path
       style="fill:#ff0000;fill-opacity:1;stroke:#000000;stroke-width:0.26640061;stroke-linecap:round;stroke-miterlimit:4;stroke-dasharray:none;stroke-opacity:1"
       d="m 116.28541,285.22705 v 1.5875 h -1.5875 v 1.32085 h 1.5875 v 1.5875 h 1.32085 v -1.5875 h 1.5875 v -1.32085 h -1.5875 v -1.5875 z"
       id="rect4592"
       inkscape:connector-curvature="0" />
    <path
       style="fill:#ff0000;fill-opacity:1;stroke:#000000;stroke-width:0.26640061;stroke-linecap:round;stroke-miterlimit:4;stroke-dasharray:none;stroke-opacity:1"
       d="m 119.46041,287.87293 v 1.5875 h -1.5875 v 1.32085 h 1.5875 v 1.5875 h 1.32085 v -1.5875 h 1.5875 v -1.32085 h -1.5875 v -1.5875 z"
       id="rect4592-0"
       inkscape:connector-curvature="0" />
    <path
       style="fill:none;fill-opacity:1;stroke:#000000;stroke-width:0.5291667;stroke-miterlimit:4;stroke-dasharray:none;stroke-opacity:1"
       d="m 127.62358,286.59481 c 1.64477,0 2.54803,0.25469 2.54803,1.87771 0,1.62302 -1.91399,2.95995 -3.55877,2.95995 m -0.22942,-1.16276 c -1.64478,0 -2.55517,-0.15296 -2.55517,-1.77597 0,-1.62302 1.26884,-2.87507 2.91362,-2.87507"
       id="path4872"
       inkscape:connector-curvature="0"
       sodipodi:nodetypes="csccsc" />
    <path
       style="fill:none;stroke:#000000;stroke-width:0.5291667;stroke-linecap:butt;stroke-linejoin:miter;stroke-miterlimit:4;stroke-dasharray:none;stroke-opacity:1"
       d="m 128.02787,291.99879 -1.41503,-0.56632 0.92041,-0.96155"
       id="path4877"
       inkscape:connector-curvature="0"
       sodipodi:nodetypes="ccc" />
    <path
       style="fill:none;stroke:#000000;stroke-width:0.5291667;stroke-linecap:butt;stroke-linejoin:miter;stroke-miterlimit:4;stroke-dasharray:none;stroke-opacity:1"
       d="m 125.16771,285.07244 1.57416,0.54623 -0.92901,1.11745"
       id="path4879"
       inkscape:connector-curvature="0"
       sodipodi:nodetypes="ccc" />
    <path
       inkscape:connector-curvature="0"
       id="path4886-3"
       d="m 132.90832,285.1212 -0.84109,0.81383 2.57473,2.59938 -2.57473,2.59967 0.84109,0.81355 2.55709,-2.58159 2.55709,2.58159 0.84137,-0.81355 -2.57472,-2.59967 2.57472,-2.59938 -0.84137,-0.81383 -2.55709,2.58187 z"
       style="color:#000000;font-style:normal;font-variant:normal;font-weight:normal;font-stretch:normal;font-size:medium;line-height:normal;font-family:sans-serif;font-variant-ligatures:normal;font-variant-position:normal;font-variant-caps:normal;font-variant-numeric:normal;font-variant-alternates:normal;font-feature-settings:normal;text-indent:0;text-align:start;text-decoration:none;text-decoration-line:none;text-decoration-style:solid;text-decoration-color:#000000;letter-spacing:normal;word-spacing:normal;text-transform:none;writing-mode:lr-tb;direction:ltr;text-orientation:mixed;dominant-baseline:auto;baseline-shift:baseline;text-anchor:start;white-space:normal;shape-padding:0;clip-rule:nonzero;display:inline;overflow:visible;visibility:visible;opacity:1;isolation:auto;mix-blend-mode:normal;color-interpolation:sRGB;color-interpolation-filters:linearRGB;solid-color:#000000;solid-opacity:1;vector-effect:none;fill:#00ffff;fill-opacity:1;fill-rule:nonzero;stroke:#0d0000;stroke-width:1.17023087;stroke-linecap:butt;stroke-linejoin:miter;stroke-miterlimit:4;stroke-dasharray:none;stroke-dashoffset:0;stroke-opacity:1;color-rendering:auto;image-rendering:auto;shape-rendering:auto;text-rendering:auto;enable-background:accumulate" />
    <path
       inkscape:connector-curvature="0"
       id="path4886"
       d="m 132.90835,285.12115 -0.84108,0.81383 2.57472,2.59938 -2.57472,2.59967 0.84108,0.81354 2.5571,-2.58158 2.55709,2.58158 0.84137,-0.81354 -2.57472,-2.59967 2.57472,-2.59938 -0.84137,-0.81383 -2.55709,2.58187 z"
       style="color:#000000;font-style:normal;font-variant:normal;font-weight:normal;font-stretch:normal;font-size:medium;line-height:normal;font-family:sans-serif;font-variant-ligatures:normal;font-variant-position:normal;font-variant-caps:normal;font-variant-numeric:normal;font-variant-alternates:normal;font-feature-settings:normal;text-indent:0;text-align:start;text-decoration:none;text-decoration-line:none;text-decoration-style:solid;text-decoration-color:#000000;letter-spacing:normal;word-spacing:normal;text-transform:none;writing-mode:lr-tb;direction:ltr;text-orientation:mixed;dominant-baseline:auto;baseline-shift:baseline;text-anchor:start;white-space:normal;shape-padding:0;clip-rule:nonzero;display:inline;overflow:visible;visibility:visible;opacity:1;isolation:auto;mix-blend-mode:normal;color-interpolation:sRGB;color-interpolation-filters:linearRGB;solid-color:#000000;solid-opacity:1;vector-effect:none;fill:#00ffff;fill-opacity:1;fill-rule:nonzero;stroke:none;stroke-width:1.17023087;stroke-linecap:butt;stroke-linejoin:miter;stroke-miterlimit:4;stroke-dasharray:none;stroke-dashoffset:0;stroke-opacity:1;color-rendering:auto;image-rendering:auto;shape-rendering:auto;text-rendering:auto;enable-background:accumulate" />
    <ellipse
       style="fill:#00ffff;fill-opacity:1;stroke:#00ffff;stroke-width:1.00281429;stroke-linecap:round;stroke-miterlimit:1;stroke-dasharray:none;stroke-opacity:1"
       id="path1513"
       cx="160.86667"
       cy="288.53329"
       rx="1.5311503"
       ry="3.7319226" />
    <path
       style="fill:none;stroke:#000000;stroke-width:0.66145831;stroke-linecap:butt;stroke-linejoin:miter;stroke-miterlimit:1;stroke-dasharray:none;stroke-opacity:1;marker-start:url(#Arrow2Mstart-8-8)"
       d="m 160.87302,285.98252 v 4.87767"
       id="path826-4"
       inkscape:connector-curvature="0" />
    <circle
       style="fill:#ffff00;fill-opacity:1;stroke:#000000;stroke-width:0.66145831;stroke-linecap:round;stroke-miterlimit:1;stroke-dasharray:none;stroke-opacity:1"
       id="path1438-1"
       cx="160.86667"
       cy="290.81793"
       r="0.93544328" />
    <ellipse
       style="fill:#00ffff;fill-opacity:1;stroke:#00ffff;stroke-width:1.00281429;stroke-linecap:round;stroke-miterlimit:1;stroke-dasharray:none;stroke-opacity:1"
       id="path1513-5"
       cx="169.33333"
       cy="-288.53333"
       rx="1.5311503"
       ry="3.7319226"
       transform="scale(1,-1)" />
    <path
       style="fill:none;stroke:#000000;stroke-width:0.66145831;stroke-linecap:butt;stroke-linejoin:miter;stroke-miterlimit:1;stroke-dasharray:none;stroke-opacity:1;marker-start:url(#Arrow2Mstart-8-538)"
       d="m 169.33969,291.0841 v -4.87767"
       id="path826-4-4"
       inkscape:connector-curvature="0" />
    <circle
       style="fill:#ffff00;fill-opacity:1;stroke:#000000;stroke-width:0.66145831;stroke-linecap:round;stroke-miterlimit:1;stroke-dasharray:none;stroke-opacity:1"
       id="path1438-1-8"
       cx="169.33333"
       cy="-286.24869"
       r="0.93544328"
       transform="scale(1,-1)" />
    <g
       id="g1086">
      <text
         id="text16-4"
         y="291.52747"
         x="140.34904"
         style="font-style:normal;font-weight:normal;font-size:10.58333302px;line-height:1.25;font-family:sans-serif;letter-spacing:0px;word-spacing:0px;fill:#ffffff;fill-opacity:1;stroke:#ffffff;stroke-width:1.05833328;stroke-miterlimit:4;stroke-dasharray:none;stroke-opacity:1"
         xml:space="preserve"><tspan
           style="font-size:2.82222223px;fill:#ffffff;fill-opacity:1;stroke:#ffffff;stroke-width:1.05833328;stroke-miterlimit:4;stroke-dasharray:none;stroke-opacity:1"
           y="291.52747"
           x="140.34904"
           id="tspan14-0"
           sodipodi:role="line">EDIT</tspan></text>
      <text
         inkscape:transform-center-y="-1.0364457"
         inkscape:transform-center-x="0.16364932"
         id="text16-4-7"
         y="291.52747"
         x="140.34904"
         style="font-style:normal;font-weight:normal;font-size:10.58333302px;line-height:1.25;font-family:sans-serif;letter-spacing:0px;word-spacing:0px;fill:#000000;fill-opacity:1;stroke:none;stroke-width:0.26458332"
         xml:space="preserve"><tspan
           style="font-size:2.82222223px;stroke-width:0.26458332"
           y="291.52747"
           x="140.34904"
           id="tspan14-0-2"
           sodipodi:role="line">EDIT</tspan></text>
    </g>
    <g
       id="g1092">
      <text
         id="text16"
         y="287.96463"
         x="140.88857"
         style="font-style:normal;font-weight:normal;font-size:10.58333302px;line-height:1.25;font-family:sans-serif;letter-spacing:0px;word-spacing:0px;fill:#2b1100;fill-opacity:1;stroke:#ffffff;stroke-width:1.05833328;stroke-miterlimit:4;stroke-dasharray:none;stroke-opacity:1;"
         xml:space="preserve"><tspan
           style="font-size:3.17499995px;fill:#2b1100;fill-opacity:1;stroke:#ffffff;stroke-width:1.05833328;stroke-miterlimit:4;stroke-dasharray:none;stroke-opacity:1;"
           y="287.96463"
           x="140.88857"
           id="tspan14"
           sodipodi:role="line">GUI</tspan></text>
      <text
         id="text16-5"
         y="287.96463"
         x="140.88857"
         style="font-style:normal;font-weight:normal;font-size:10.58333302px;line-height:1.25;font-family:sans-serif;letter-spacing:0px;word-spacing:0px;fill:#2b1100;fill-opacity:1;stroke:none;stroke-width:0.26458332;"
         xml:space="preserve"><tspan
           style="font-size:3.17499995px;stroke-width:0.26458332;fill:#2b1100;"
           y="287.96463"
           x="140.88857"
           id="tspan14-4"
           sodipodi:role="line">GUI</tspan></text>
    </g>
    <g
       id="g1080"
       transform="translate(0.14173383,-0.93037687)">
      <text
         id="text16-5-1"
         y="290.59695"
         x="149.06636"
         style="font-style:normal;font-variant:normal;font-weight:normal;font-stretch:normal;font-size:3.17499995px;line-height:1.25;font-family:sans-serif;font-variant-ligatures:normal;font-variant-position:normal;font-variant-caps:normal;font-variant-numeric:normal;font-variant-alternates:normal;font-feature-settings:normal;text-indent:0;text-align:start;text-decoration:none;text-decoration-line:none;text-decoration-style:solid;text-decoration-color:#000000;letter-spacing:0px;word-spacing:0px;text-transform:none;writing-mode:lr-tb;direction:ltr;text-orientation:mixed;dominant-baseline:auto;baseline-shift:baseline;text-anchor:start;white-space:normal;shape-padding:0;opacity:1;vector-effect:none;fill:#2b1100;fill-opacity:1;stroke:#ffffff;stroke-width:1.05833328;stroke-linecap:butt;stroke-linejoin:miter;stroke-miterlimit:4;stroke-dasharray:none;stroke-dashoffset:0;stroke-opacity:1"
         xml:space="preserve"><tspan
           style="font-style:normal;font-variant:normal;font-weight:normal;font-stretch:normal;font-size:3.17499995px;line-height:1.25;font-family:sans-serif;font-variant-ligatures:normal;font-variant-position:normal;font-variant-caps:normal;font-variant-numeric:normal;font-variant-alternates:normal;font-feature-settings:normal;text-indent:0;text-align:start;text-decoration:none;text-decoration-line:none;text-decoration-style:solid;text-decoration-color:#000000;letter-spacing:0px;word-spacing:0px;text-transform:none;writing-mode:lr-tb;direction:ltr;text-orientation:mixed;dominant-baseline:auto;baseline-shift:baseline;text-anchor:start;white-space:normal;shape-padding:0;vector-effect:none;fill:#2b1100;fill-opacity:1;stroke:#ffffff;stroke-width:1.05833328;stroke-linecap:butt;stroke-linejoin:miter;stroke-miterlimit:4;stroke-dasharray:none;stroke-dashoffset:0;stroke-opacity:1"
           y="290.59695"
           x="149.06636"
           id="tspan14-4-8"
           sodipodi:role="line">Test</tspan></text>
      <text
         id="text16-5-1-8"
         y="290.59695"
         x="149.06636"
         style="font-style:normal;font-weight:normal;font-size:10.58333302px;line-height:1.25;font-family:sans-serif;letter-spacing:0px;word-spacing:0px;fill:#2b1100;fill-opacity:1;stroke:none;stroke-width:0.26458332"
         xml:space="preserve"><tspan
           style="font-size:3.17499995px;fill:#2b1100;stroke-width:0.26458332"
           y="290.59695"
           x="149.06636"
           id="tspan14-4-8-6"
           sodipodi:role="line">Test</tspan></text>
    </g>
  </g>
</svg>

```

`src/wondef.h`:

```h
/* wondef.h --- Wonders API by katahiromz */
/**************************************************************************/

#ifndef WONDEF_H
#define WONDEF_H    5  /* Version 5 */

#if defined(_WIN32) && !defined(WONVER)
    #include <windows.h>
#else

#include "wonnt.h"

#define MAX_PATH 260

#ifndef NULL
    #ifdef __cplusplus
        #ifdef _WIN64
            #define NULL 0LL
        #else
            #define NULL 0
        #endif
    #else
        #define NULL ((void *)0)
    #endif
#endif

#ifndef FALSE
    #define FALSE 0
#endif

#ifndef TRUE
    #define TRUE 1
#endif

#ifndef MAKEWORD
    #define MAKEWORD(a,b) \
        ((WORD) (((BYTE) (((DWORD_PTR) (a)) & 0xff)) | \
            ((WORD) ((BYTE) (((DWORD_PTR) (b)) & 0xff))) << 8))
    #define MAKELONG(a, b) \
        ((LONG) (((WORD) (((DWORD_PTR) (a)) & 0xffff)) | \
            ((DWORD) ((WORD) (((DWORD_PTR) (b)) & 0xffff))) << 16))
    #define LOWORD(l) ((WORD) (((DWORD_PTR) (l)) & 0xffff))
    #define HIWORD(l) ((WORD) ((((DWORD_PTR) (l)) >> 16) & 0xffff))
    #define LOBYTE(w) ((BYTE) (((DWORD_PTR) (w)) & 0xff))
    #define HIBYTE(w) ((BYTE) ((((DWORD_PTR) (w)) >> 8) & 0xff))
    #define MAKELANGID(p, s) \
        ((LANGID)((((WORD)(p)) << 10) | ((WORD)(s))))
    #define MAKELCID(langid, sortid) \
        ((LCID)((((WORD)(langid)) << 16) | ((WORD)(sortid))))
    #define PRIMARYLANGID(langid) (((WORD)(langid)) & 0x3FF)
    #define SUBLANGID(langid) ((WORD)((langid) >> 10))
#endif

#endif  /* !(defined(_WIN32) && !defined(WONVER)) */
#endif  /* ndef WONDEF_H */

```

`src/wonnt.h`:

```h
/* wonnt.h --- Wonders API by katahiromz */
/**************************************************************************/

#ifndef WONNT_H
#define WONNT_H     17  /* Version 17 */

#ifndef _INC_WINDOWS
#if defined(_WIN32) && !defined(_WONVER) && !defined(WONVER)
    #include <windows.h>
#else

/**************************************************************************/

#ifndef WINAPI
    #define WINAPI      /*empty*/
    #define WINAPIV     /*empty*/
#endif

#ifndef NTAPI
    #define NTAPI       /*empty*/
#endif

/**************************************************************************/

#if __cplusplus >= 201103L
    #include <cstdint>
#elif __STDC_VERSION__ >= 199901L
    #include <stdint.h>
#else
    #include "pstdint.h"
#endif

typedef char CHAR;
typedef signed char SCHAR;
typedef uint8_t BYTE, UCHAR;
typedef int16_t SHORT;
typedef uint16_t WORD, USHORT;
typedef int32_t LONG;
typedef uint32_t DWORD, ULONG;
typedef int32_t INT, BOOL;
typedef uint32_t UINT;
typedef int64_t LONGLONG;
typedef uint64_t ULONGLONG, DWORDLONG;
typedef void *HANDLE;

// WCHAR
#ifndef __WCHAR_DEFINED
    #define __WCHAR_DEFINED
    #ifdef _WIN32
        typedef wchar_t WCHAR;
    #else
        #if __cplusplus >= 201103L
            typedef char16_t WCHAR;
        #else
            typedef uint16_t WCHAR;
        #endif
    #endif
#endif

typedef intptr_t INT_PTR, LONG_PTR;
typedef uintptr_t UINT_PTR, ULONG_PTR, DWORD_PTR;

typedef BYTE BOOLEAN;

#ifdef UNICODE
    typedef WCHAR TCHAR;
#else
    typedef char TCHAR;
#endif

typedef INT HFILE;

#ifndef _HRESULT_DEFINED
    #define _HRESULT_DEFINED
    typedef LONG HRESULT;
#endif

#ifndef _LCID_DEFINED
    #define _LCID_DEFINED
    typedef DWORD LCID;
#endif

#ifndef _LANGID_DEFINED
    #define _LANGID_DEFINED
    typedef WORD LANGID;
#endif

#define C_ASSERT(x)  typedef char WONNT_STATIC_ASSERT_##__LINE__[(x) ? 1 : -1]

C_ASSERT(sizeof(CHAR) == 1);
C_ASSERT(sizeof(SCHAR) == 1);
C_ASSERT(sizeof(UCHAR) == 1);
C_ASSERT(sizeof(BYTE) == 1);

C_ASSERT(sizeof(SHORT) == 2);
C_ASSERT(sizeof(USHORT) == 2);
C_ASSERT(sizeof(WORD) == 2);

C_ASSERT(sizeof(LONG) == 4);
C_ASSERT(sizeof(ULONG) == 4);
C_ASSERT(sizeof(DWORD) == 4);

C_ASSERT(sizeof(LONGLONG) == 8);
C_ASSERT(sizeof(ULONGLONG) == 8);
C_ASSERT(sizeof(DWORDLONG) == 8);

C_ASSERT(sizeof(INT) == sizeof(int));
C_ASSERT(sizeof(UINT) == sizeof(unsigned int));

C_ASSERT(sizeof(BOOL) == 4);
C_ASSERT(sizeof(BOOLEAN) == 1);

C_ASSERT(sizeof(HANDLE) == sizeof(void *));

C_ASSERT(sizeof(WCHAR) == 2);

C_ASSERT(sizeof(HRESULT) == 4);

C_ASSERT(sizeof(LANGID) == 2);
C_ASSERT(sizeof(LCID) == 4);

C_ASSERT(sizeof(INT_PTR) == sizeof(void *));
C_ASSERT(sizeof(LONG_PTR) == sizeof(void *));
C_ASSERT(sizeof(UINT_PTR) == sizeof(void *));
C_ASSERT(sizeof(ULONG_PTR) == sizeof(void *));
C_ASSERT(sizeof(DWORD_PTR) == sizeof(void *));

/**************************************************************************/

#ifndef S_OK
    #define S_OK ((HRESULT)0x00000000)
    #define S_FALSE ((HRESULT)0x00000001)
    #define E_FAIL ((HRESULT)0x80004005)
#endif

/**************************************************************************/

#define IMAGE_DOS_SIGNATURE 0x5A4D
typedef struct {
    WORD e_magic;
    WORD e_cblp;
    WORD e_cp;
    WORD e_crlc;
    WORD e_cparhdr;
    WORD e_minalloc;
    WORD e_maxalloc;
    WORD e_ss;
    WORD e_sp;
    WORD e_csum;
    WORD e_ip;
    WORD e_cs;
    WORD e_lfarlc;
    WORD e_ovno;
    WORD e_res[4];
    WORD e_oemid;
    WORD e_oeminfo;
    WORD e_res2[10];
    LONG e_lfanew;
} IMAGE_DOS_HEADER;

typedef struct {
    WORD Machine;
    WORD NumberOfSections;
    DWORD TimeDateStamp;
    DWORD PointerToSymbolTable;
    DWORD NumberOfSymbols;
    WORD SizeOfOptionalHeader;
    WORD Characteristics;
} IMAGE_FILE_HEADER;

#define IMAGE_NUMBEROF_DIRECTORY_ENTRIES 16

typedef struct {
    DWORD VirtualAddress;
    DWORD Size;
} IMAGE_DATA_DIRECTORY;

typedef struct {
    WORD Magic;
    BYTE MajorLinkerVersion;
    BYTE MinorLinkerVersion;
    DWORD SizeOfCode;
    DWORD SizeOfInitializedData;
    DWORD SizeOfUninitializedData;
    DWORD AddressOfEntryPoint;
    DWORD BaseOfCode;
    DWORD BaseOfData;
    DWORD ImageBase;
    DWORD SectionAlignment;
    DWORD FileAlignment;
    WORD MajorOperatingSystemVersion;
    WORD MinorOperatingSystemVersion;
    WORD MajorImageVersion;
    WORD MinorImageVersion;
    WORD MajorSubsystemVersion;
    WORD MinorSubsystemVersion;
    DWORD Win32VersionValue;
    DWORD SizeOfImage;
    DWORD SizeOfHeaders;
    DWORD CheckSum;
    WORD Subsystem;
    WORD DllCharacteristics;
    DWORD SizeOfStackReserve;
    DWORD SizeOfStackCommit;
    DWORD SizeOfHeapReserve;
    DWORD SizeOfHeapCommit;
    DWORD LoaderFlags;
    DWORD NumberOfRvaAndSizes;
    IMAGE_DATA_DIRECTORY DataDirectory[IMAGE_NUMBEROF_DIRECTORY_ENTRIES];
} IMAGE_OPTIONAL_HEADER32;

typedef struct {
    WORD Magic;
    BYTE MajorLinkerVersion;
    BYTE MinorLinkerVersion;
    DWORD SizeOfCode;
    DWORD SizeOfInitializedData;
    DWORD SizeOfUninitializedData;
    DWORD AddressOfEntryPoint;
    DWORD BaseOfCode;
    ULONGLONG ImageBase;
    DWORD SectionAlignment;
    DWORD FileAlignment;
    WORD MajorOperatingSystemVersion;
    WORD MinorOperatingSystemVersion;
    WORD MajorImageVersion;
    WORD MinorImageVersion;
    WORD MajorSubsystemVersion;
    WORD MinorSubsystemVersion;
    DWORD Win32VersionValue;
    DWORD SizeOfImage;
    DWORD SizeOfHeaders;
    DWORD CheckSum;
    WORD Subsystem;
    WORD DllCharacteristics;
    ULONGLONG SizeOfStackReserve;
    ULONGLONG SizeOfStackCommit;
    ULONGLONG SizeOfHeapReserve;
    ULONGLONG SizeOfHeapCommit;
    DWORD LoaderFlags;
    DWORD NumberOfRvaAndSizes;
    IMAGE_DATA_DIRECTORY DataDirectory[IMAGE_NUMBEROF_DIRECTORY_ENTRIES];
} IMAGE_OPTIONAL_HEADER64;

#define IMAGE_NT_SIGNATURE 0x00004550
typedef struct {
    DWORD Signature;
    IMAGE_FILE_HEADER FileHeader;
    IMAGE_OPTIONAL_HEADER32 OptionalHeader;
} IMAGE_NT_HEADERS32;
typedef struct {
    DWORD Signature;
    IMAGE_FILE_HEADER FileHeader;
    IMAGE_OPTIONAL_HEADER64 OptionalHeader;
} IMAGE_NT_HEADERS64;

#ifdef _WIN64
    typedef IMAGE_OPTIONAL_HEADER64 IMAGE_OPTIONAL_HEADER;
    typedef IMAGE_NT_HEADERS64 IMAGE_NT_HEADERS;
#else
    typedef IMAGE_OPTIONAL_HEADER32 IMAGE_OPTIONAL_HEADER;
    typedef IMAGE_NT_HEADERS32 IMAGE_NT_HEADERS;
#endif

#define IMAGE_DIRECTORY_ENTRY_EXPORT 0
#define IMAGE_DIRECTORY_ENTRY_IMPORT 1
#define IMAGE_DIRECTORY_ENTRY_RESOURCE 2
#define IMAGE_DIRECTORY_ENTRY_EXCEPTION 3
#define IMAGE_DIRECTORY_ENTRY_SECURITY 4
#define IMAGE_DIRECTORY_ENTRY_BASERELOC 5
#define IMAGE_DIRECTORY_ENTRY_DEBUG 6
#define IMAGE_DIRECTORY_ENTRY_ARCHITECTURE 7
#define IMAGE_DIRECTORY_ENTRY_GLOBALPTR 8
#define IMAGE_DIRECTORY_ENTRY_TLS 9
#define IMAGE_DIRECTORY_ENTRY_LOAD_CONFIG 10
#define IMAGE_DIRECTORY_ENTRY_BOUND_IMPORT 11
#define IMAGE_DIRECTORY_ENTRY_IAT 12
#define IMAGE_DIRECTORY_ENTRY_DELAY_IMPORT 13
#define IMAGE_DIRECTORY_ENTRY_COM_DESCRIPTOR 14

typedef struct {
    union {
        DWORD Characteristics;
        DWORD OriginalFirstThunk;
    };
    DWORD TimeDateStamp;

    DWORD ForwarderChain;
    DWORD Name;
    DWORD FirstThunk;
} IMAGE_IMPORT_DESCRIPTOR;

typedef struct {
    DWORD Characteristics;
    DWORD TimeDateStamp;
    WORD MajorVersion;
    WORD MinorVersion;
    DWORD Name;
    DWORD Base;
    DWORD NumberOfFunctions;
    DWORD NumberOfNames;
    DWORD AddressOfFunctions;
    DWORD AddressOfNames;
    DWORD AddressOfNameOrdinals;
} IMAGE_EXPORT_DIRECTORY;

#define IMAGE_SIZEOF_SHORT_NAME 8

typedef struct {
    BYTE Name[IMAGE_SIZEOF_SHORT_NAME];
    union {
        DWORD PhysicalAddress;
        DWORD VirtualSize;
    } Misc;
    DWORD VirtualAddress;
    DWORD SizeOfRawData;
    DWORD PointerToRawData;
    DWORD PointerToRelocations;
    DWORD PointerToLinenumbers;
    WORD NumberOfRelocations;
    WORD NumberOfLinenumbers;
    DWORD Characteristics;
} IMAGE_SECTION_HEADER;

#define IMAGE_ORDINAL_FLAG64 0x8000000000000000ull
#define IMAGE_ORDINAL_FLAG32 0x80000000
#define IMAGE_ORDINAL64(Ordinal) (Ordinal & 0xffffull)
#define IMAGE_ORDINAL32(Ordinal) (Ordinal & 0xffff)
#define IMAGE_SNAP_BY_ORDINAL64(Ordinal) ((Ordinal & IMAGE_ORDINAL_FLAG64)!=0)
#define IMAGE_SNAP_BY_ORDINAL32(Ordinal) ((Ordinal & IMAGE_ORDINAL_FLAG32)!=0)

typedef struct {
    WORD Hint;
    BYTE Name[1];
} IMAGE_IMPORT_BY_NAME;

#define IMAGE_RESOURCE_NAME_IS_STRING        0x80000000
#define IMAGE_RESOURCE_DATA_IS_DIRECTORY     0x80000000

typedef struct {
    DWORD   Characteristics;
    DWORD   TimeDateStamp;
    WORD    MajorVersion;
    WORD    MinorVersion;
    WORD    NumberOfNamedEntries;
    WORD    NumberOfIdEntries;
} IMAGE_RESOURCE_DIRECTORY;

typedef struct {
    union {
        struct {
            DWORD NameOffset:31;
            DWORD NameIsString:1;
        };
        DWORD   Name;
        WORD    Id;
    };
    union {
        DWORD   OffsetToData;
        struct {
            DWORD   OffsetToDirectory:31;
            DWORD   DataIsDirectory:1;
        };
    };
} IMAGE_RESOURCE_DIRECTORY_ENTRY;

/**************************************************************************/

#ifndef FIELD_OFFSET
    #define FIELD_OFFSET(type, field) \
        ((LONG)(LONG_PTR)&(((type *)0)->field))
#endif

#ifndef RTL_FIELD_SIZE
    #define RTL_FIELD_SIZE(type, field) \
        (sizeof(((type *)0)->field))
#endif

#ifndef RTL_SIZEOF_THROUGH_FIELD
    #define RTL_SIZEOF_THROUGH_FIELD(type, field) \
        (FIELD_OFFSET(type, field) + RTL_FIELD_SIZE(type, field))
#endif

#ifndef IMAGE_FIRST_SECTION
    #define IMAGE_FIRST_SECTION(nt) ((IMAGE_SECTION_HEADER *)             \
        ((ULONG_PTR)nt + FIELD_OFFSET(IMAGE_NT_HEADERS, OptionalHeader) + \
         ((IMAGE_NT_HEADERS *)(nt))->FileHeader.SizeOfOptionalHeader))
#endif

/**************************************************************************/

#endif  /* !(defined(_WIN32) && !defined(_WONVER) && !defined(WONVER)) */
#endif  /* ndef _INC_WINDOWS */
#endif  /* ndef WONNT_H */

```

`tests/CMakeLists.txt`:

```txt
add_subdirectory(cmdline)
add_subdirectory(ResTest)
add_subdirectory(ResTest2)
add_subdirectory(ToolbarTest)

```

`tests/ResTest/CMakeLists.txt`:

```txt
add_executable(ResTest WIN32 ResTest.cpp ResTest_res.rc ResTest.exe.manifest)
target_link_libraries(ResTest comctl32)

# do statically link
set_target_properties(ResTest PROPERTIES LINK_SEARCH_START_STATIC 1)
set_target_properties(ResTest PROPERTIES LINK_SEARCH_END_STATIC 1)

```

`tests/ResTest/ResTest.cpp`:

```cpp
// ResTest.cpp
//////////////////////////////////////////////////////////////////////////////

#include <windows.h>
#include <windowsx.h>
#include <commctrl.h>
#include <dlgs.h>
#include <tchar.h>
#include <cstdio>
#include "resource.h"
using std::FILE;
using std::fopen;
using std::fprintf;

#ifdef _MSC_VER
#pragma comment(linker,"/manifestdependency:\"type='win32' \
    name='Microsoft.Windows.Common-Controls' \
    version='6.0.0.0' \
    processorArchitecture='*' \
    publicKeyToken='6595b64144ccf1df' \
    language='*'\"")
#endif

void DumpBinary(FILE *fp, LPCVOID pv, DWORD Size, const char *VarName)
{
    const BYTE *pb = (const BYTE *)pv;

    fprintf(fp, "static const BYTE %s[] = {\n", VarName);
    for (DWORD i = 0; i < Size; ++i)
    {
        fprintf(fp, "0x%02X, ", pb[i]);
        if (i % 13 == 12)
            fprintf(fp, "\n");
    }
    fprintf(fp, "\n");
    fprintf(fp, "};\n");
}

void DumpResource(FILE *fp, HINSTANCE hInst, LPCTSTR Type, LPCTSTR Name, const char *VarName)
{
    HRSRC hRsrc = FindResourceEx(hInst, Type, Name, 0);
    DWORD Size = SizeofResource(hInst, hRsrc);
    HGLOBAL hGlobal = LoadResource(hInst, hRsrc);
    LPVOID pv = LockResource(hGlobal);
    DumpBinary(fp, pv, Size, VarName);
    UnlockResource(hGlobal);
}

void DumpAll(FILE *fp)
{
    HINSTANCE hInst = GetModuleHandle(NULL);

    DumpResource(fp, hInst, RT_ACCELERATOR, MAKEINTRESOURCE(1), "abAccel");
    DumpResource(fp, hInst, RT_DIALOG, MAKEINTRESOURCE(1), "abDialog");
    DumpResource(fp, hInst, RT_MENU, MAKEINTRESOURCE(1), "abMenu");
    DumpResource(fp, hInst, RT_STRING, MAKEINTRESOURCE(1), "abString");
    DumpResource(fp, hInst, RT_VERSION, MAKEINTRESOURCE(1), "abVersion");

#ifndef RT_HTML
    #define RT_HTML         MAKEINTRESOURCE(23)
#endif
#ifndef RT_MANIFEST
    #define RT_MANIFEST     MAKEINTRESOURCE(24)
#endif
    DumpResource(fp, hInst, RT_HTML, MAKEINTRESOURCE(1), "abHtml");
    DumpResource(fp, hInst, RT_MANIFEST, MAKEINTRESOURCE(1), "abManifest");
}

//////////////////////////////////////////////////////////////////////////////

BOOL OnInitDialog(HWND hwnd, HWND hwndFocus, LPARAM lParam)
{
    return TRUE;
}

void JustDoIt(HWND hwnd)
{
    FILE *fp = fopen("sample-resources.txt", "w");
    if (fp)
    {
        DumpAll(fp);
        fclose(fp);
    }
}

void OnCommand(HWND hwnd, int id, HWND hwndCtl, UINT codeNotify)
{
    switch (id)
    {
    case IDOK:
        EndDialog(hwnd, IDOK);
        break;
    case IDCANCEL:
        EndDialog(hwnd, IDCANCEL);
        break;
    case CMDID_JUSTDOIT:
        JustDoIt(hwnd);
        break;
    }
}

INT_PTR CALLBACK
DialogProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    switch (uMsg)
    {
        HANDLE_MSG(hwnd, WM_INITDIALOG, OnInitDialog);
        HANDLE_MSG(hwnd, WM_COMMAND, OnCommand);
    }
    return 0;
}

//////////////////////////////////////////////////////////////////////////////

extern "C" INT WINAPI
_tWinMain(HINSTANCE   hInstance,
          HINSTANCE   hPrevInstance,
          LPTSTR      lpCmdLine,
          INT         nCmdShow)
{
    InitCommonControls();
    //DialogBox(hInstance, MAKEINTRESOURCE(2), NULL, DialogProc);
    DialogBox(hInstance, MAKEINTRESOURCE(4), NULL, DialogProc);
    return 0;
}

//////////////////////////////////////////////////////////////////////////////

```

`tests/ResTest/ResTest.exe.manifest`:

```manifest
<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<assembly xmlns="urn:schemas-microsoft-com:asm.v1" manifestVersion="1.0">
  <trustInfo xmlns="urn:schemas-microsoft-com:asm.v3">
    <security>
      <requestedPrivileges>
        <requestedExecutionLevel level="asInvoker" uiAccess="false"></requestedExecutionLevel>
      </requestedPrivileges>
    </security>
  </trustInfo>
  <dependency>
    <dependentAssembly>
      <assemblyIdentity type="win32" name="Microsoft.Windows.Common-Controls" version="6.0.0.0" processorArchitecture="*" publicKeyToken="6595b64144ccf1df" language="*"></assemblyIdentity>
    </dependentAssembly>
  </dependency>
</assembly>

```

`tests/ResTest/ResTest_res.rc`:

```rc
// ResTest_res.rc
//////////////////////////////////////////////////////////////////////////////

#include <windows.h>
#include <commctrl.h>
#include <dlgs.h>
#include "resource.h"

//////////////////////////////////////////////////////////////////////////////

1 ICON "smily.ico"
2 ICON "dummy.ico"

2 BITMAP "dummy.bmp"

2 EMF "emf.emf"
2 ENHMETAFILE "emf.emf"
2 ENHMETAPICT "emf.emf"

//////////////////////////////////////////////////////////////////////////////
// Dialogs

1 DIALOG 0, 0, 215, 135
STYLE DS_MODALFRAME | WS_POPUP | WS_CAPTION | WS_SYSMENU
CAPTION "Sample Dialog"
FONT 9, "MS Shell Dlg"
{
    CONTROL "OK", IDOK, "BUTTON", BS_DEFPUSHBUTTON | WS_CHILD | WS_VISIBLE | WS_TABSTOP, 35, 115, 60, 14
    CONTROL "Cancel", IDCANCEL, "BUTTON", BS_PUSHBUTTON | WS_CHILD | WS_VISIBLE | WS_TABSTOP, 115, 115, 60, 14
}

2 DIALOG 0, 0, 100, 50
STYLE DS_MODALFRAME | WS_POPUP | WS_CAPTION | WS_SYSMENU
CAPTION "Test Dialog"
FONT 9, "MS Shell Dlg"
{
    // with text
    AUTO3STATE "", 1000, 0, 0, 5, 5
    AUTOCHECKBOX "", 1001, 5, 0, 5, 5
    AUTORADIOBUTTON "", 1002, 10, 0, 5, 5
    CHECKBOX "", 1003, 15, 0, 5, 5
    //COMBOBOX "", 1004, 20, 0, 5, 5  // syntax error
    CTEXT "", 1005, 25, 0, 5, 5
    DEFPUSHBUTTON "", 1006, 30, 0, 5, 5
    //EDITTEXT "", 1007, 35, 0, 5, 5  // syntax error
    GROUPBOX "", 1008, 40, 0, 5, 5
    ICON "", 1009, 45, 0, 5, 5
    //LISTBOX "", 1010, 50, 0, 5, 5   // syntax error
    LTEXT "", 1011, 55, 0, 5, 5
    PUSHBOX "", 1012, 60, 0, 5, 5
    PUSHBUTTON "", 1013, 65, 0, 5, 5
    RADIOBUTTON "", 1014, 70, 0, 5, 5
    RTEXT "", 1015, 75, 0, 5, 5
    //SCROLLBAR "", 1016, 80, 0, 5, 5 // syntax error
    STATE3 "", 1017, 85, 0, 5, 5
    CONTROL "", 1018, "SysListView32", WS_TABSTOP, 90, 0, 5, 5
    
    // without text
    //AUTO3STATE 2000, 0, 5, 5, 5       // expected numerical dialog constant
    //AUTOCHECKBOX 2001, 5, 5, 5, 5 // expected numerical dialog constant
    //AUTORADIOBUTTON 2002, 10, 5, 5, 5 // expected numerical dialog constant
    //CHECKBOX 2003, 15, 5, 5, 5    // expected numerical dialog constant
    COMBOBOX 2004, 20, 5, 5, 5
    //CTEXT 2005, 25, 5, 5, 5       // expected numerical dialog constant
    //DEFPUSHBUTTON 2006, 30, 5, 5, 5   // expected numerical dialog constant
    EDITTEXT 2007, 35, 5, 5, 5
    //GROUPBOX 2008, 40, 5, 5, 5        // expected numerical dialog constant
    //ICON "", 2009, 45, 5, 5, 5     // syntax error
    LISTBOX 2010, 50, 5, 5, 5
    //LTEXT 2011, 55, 5, 5, 5       // expected numerical dialog constant
    //PUSHBOX 2012, 60, 5, 5, 5     // expected numerical dialog constant
    //PUSHBUTTON 2013, 65, 5, 5, 5  // expected numerical dialog constant
    //RADIOBUTTON 2014, 70, 5, 5, 5 // expected numerical dialog constant
    //RTEXT 2015, 75, 5, 5, 5           // expected numerical dialog constants
    SCROLLBAR 2016, 80, 5, 5, 5
    //STATE3 2017, 85, 5, 5, 5      // expected numerical dialog constants
    //CONTROL 2018, "SysListView32", WS_TABSTOP, 90, 5, 5, 5    // expected numerical dialog constant

    PUSHBUTTON "Just Do It!", CMDID_JUSTDOIT, 5, 25, 50, 14
}

3 DIALOG 0, 0, 100, 50
CAPTION "Test Dialog"
STYLE DS_MODALFRAME | WS_POPUP | WS_CAPTION | WS_SYSMENU
FONT 9, "MS Shell Dlg"
{
    CONTROL "", 1000, "BUTTON", BS_AUTO3STATE | WS_TABSTOP, 0, 0, 5, 5
    CONTROL "", 1001, "BUTTON", BS_AUTOCHECKBOX | WS_TABSTOP, 5, 0, 5, 5
    CONTROL "", 1002, "BUTTON", BS_AUTORADIOBUTTON, 10, 0, 5, 5
    CONTROL "", 1003, "BUTTON", BS_CHECKBOX | WS_TABSTOP, 15, 0, 5, 5
    CONTROL "", 1005, "STATIC", SS_CENTER | WS_GROUP, 25, 0, 5, 5
    CONTROL "", 1006, "BUTTON", BS_DEFPUSHBUTTON | WS_TABSTOP, 30, 0, 5, 5
    CONTROL "", 1008, "BUTTON", BS_GROUPBOX, 40, 0, 5, 5
    CONTROL "", 1009, "STATIC", SS_ICON, 45, 0, 5, 5
    CONTROL "", 1011, "STATIC", WS_GROUP, 55, 0, 5, 5
    CONTROL "", 1012, "BUTTON", BS_PUSHBOX | WS_TABSTOP, 60, 0, 5, 5
    CONTROL "", 1013, "BUTTON", WS_TABSTOP, 65, 0, 5, 5
    CONTROL "", 1014, "BUTTON", BS_RADIOBUTTON, 70, 0, 5, 5
    CONTROL "", 1015, "STATIC", SS_RIGHT | WS_GROUP, 75, 0, 5, 5
    CONTROL "", 1017, "BUTTON", BS_3STATE | WS_TABSTOP, 85, 0, 5, 5
    CONTROL "", 1018, "SysListView32", WS_TABSTOP, 90, 0, 5, 5
    CONTROL "", 2004, "COMBOBOX", 0, 20, 5, 5, 5
    CONTROL "", 2007, "EDIT", WS_BORDER | WS_TABSTOP, 35, 5, 5, 5
    CONTROL "", 2010, "LISTBOX", LBS_NOTIFY | WS_BORDER, 50, 5, 5, 5
    CONTROL "", 2016, "SCROLLBAR", 0, 80, 5, 5, 5

    PUSHBUTTON "Just Do It!", CMDID_JUSTDOIT, 5, 25, 50, 14
}

4 DIALOG 0, 0, 280, 205
CAPTION "Sample Dialog"
STYLE DS_MODALFRAME | WS_POPUPWINDOW | WS_DLGFRAME
FONT 9, "MS Shell Dlg"
{
    // 1
    ICON 2, ico1, 15, 10, 20, 20
    ICON 2, ico2, 65, 10, 20, 20, SS_REALSIZECONTROL
    ICON 2, ico3, 115, 10, 20, 20, SS_REALSIZEIMAGE
    CONTROL 0, ico4, "STATIC", SS_BLACKRECT, 165, 10, 20, 20
    // 2
    CONTROL 2, stc1, "STATIC", SS_BITMAP, 15, 90, 20, 20
    CONTROL 2, stc2, "STATIC", SS_REALSIZECONTROL | SS_BITMAP, 65, 90, 20, 20
    CONTROL 2, stc3, "STATIC", SS_REALSIZEIMAGE | SS_BITMAP, 115, 90, 20, 20
    CONTROL 0, stc4, "STATIC", SS_BLACKRECT, 165, 90, 20, 20
    // 3
    CONTROL 2, psh1, "BUTTON", BS_PUSHBUTTON | BS_BITMAP, 10, 150, 40, 20
    CONTROL 2, psh2, "BUTTON", BS_PUSHBUTTON | BS_ICON, 115, 150, 40, 20
    CONTROL 2, stc5, "STATIC", SS_ENHMETAFILE, 210, 90, 32, 32
    // 4
    DEFPUSHBUTTON "OK", IDOK, 35, 185, 60, 14
    PUSHBUTTON "Cancel", IDCANCEL, 115, 185, 60, 14
    PUSHBUTTON "&Do It!", CMDID_JUSTDOIT, 193, 185, 60, 14
}

//////////////////////////////////////////////////////////////////////////////
// Accelerators

1 ACCELERATORS
{
    "N", 1, VIRTKEY, CONTROL
    "O", 2, VIRTKEY, CONTROL
}

//////////////////////////////////////////////////////////////////////////////
// String Table

STRINGTABLE
{
    1, "This is a sample text."
}

//////////////////////////////////////////////////////////////////////////////
// Menu

1 MENU
{
    POPUP "&File"
    {
        MENUITEM "E&xit", 1
    }
}

//////////////////////////////////////////////////////////////////////////////
// HTML

#ifndef HTML
    #define HTML        23
#endif
1 HTML "html.html"

//////////////////////////////////////////////////////////////////////////////
// Manifest

#ifndef MANIFEST
    #define MANIFEST    24
#endif

//////////////////////////////////////////////////////////////////////////////
// Version Info

VS_VERSION_INFO VERSIONINFO
FILEVERSION     0, 0, 0, 0
PRODUCTVERSION  0, 0, 0, 0
FILEOS          VOS_NT_WINDOWS32
FILETYPE        VFT_APP
{
    // English (U.S.)
    BLOCK "StringFileInfo"
    {
        BLOCK "040904E4"
        {
            VALUE "CompanyName", "Your Company\0"
            VALUE "FileDescription", "Your Application\0"
            VALUE "FileVersion", "0.0\0"
            VALUE "LegalCopyright", "Copyright (C) 2017 Katayama Hirofumi MZ. All rights reserved.\0"
            VALUE "ProductName", "Your Product\0"
            VALUE "ProductVersion", "0.0\0"
        }
    }
    BLOCK "VarFileInfo"
    {
        VALUE "Translation", 0x0409, 0x04E4
    }
}

//////////////////////////////////////////////////////////////////////////////

```

`tests/ResTest/html.html`:

```html
<!DOCTYPE html>
<html lang="en"><head>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
    <title>This is a title</title>
</head>
<body>
<h1>Sample</h1>
<p>This is a sample</p>
</body></html>

```

`tests/ResTest/resource.h`:

```h
#define CMDID_JUSTDOIT  100

```

`tests/ResTest2/CMakeLists.txt`:

```txt
add_executable(ResTest2 WIN32 ResTest2.cpp ResTest2_res.rc)
target_link_libraries(ResTest2 comctl32)

# do statically link
set_target_properties(ResTest2 PROPERTIES LINK_SEARCH_START_STATIC 1)
set_target_properties(ResTest2 PROPERTIES LINK_SEARCH_END_STATIC 1)

```

`tests/ResTest2/ResTest2.cpp`:

```cpp
#include <windows.h>
#include <windowsx.h>

BOOL OnInitDialog(HWND hwnd, HWND hwndFocus, LPARAM lParam)
{
    return TRUE;
}

void OnCommand(HWND hwnd, int id, HWND hwndCtl, UINT codeNotify)
{
    switch (id)
    {
    case IDOK:
    case IDCANCEL:
        EndDialog(hwnd, id);
        break;
    }
}

INT_PTR CALLBACK
DialogProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    switch (uMsg)
    {
        HANDLE_MSG(hwnd, WM_INITDIALOG, OnInitDialog);
        HANDLE_MSG(hwnd, WM_COMMAND, OnCommand);
    }
    return 0;
}

INT WINAPI
WinMain(HINSTANCE   hInstance,
        HINSTANCE   hPrevInstance,
        LPSTR       lpCmdLine,
        INT         nCmdShow)
{
    DialogBox(hInstance, MAKEINTRESOURCE(1), NULL, DialogProc);
    return 0;
}

```

`tests/ResTest2/ResTest2_res.rc`:

```rc
// ResTest2_res.rc
// This file was automatically generated by RisohEditor.
// † <-- This dagger helps UTF-8 detection.

#define APSTUDIO_HIDDEN_SYMBOLS
#include <windows.h>
#include <commctrl.h>
#undef APSTUDIO_HIDDEN_SYMBOLS
#pragma code_page(65001) // UTF-8

//////////////////////////////////////////////////////////////////////////////

LANGUAGE LANG_ENGLISH, SUBLANG_DEFAULT

//////////////////////////////////////////////////////////////////////////////
// RT_DIALOG

1 DIALOG 0, 0, 215, 135
CAPTION "ResTest2"
STYLE DS_MODALFRAME | WS_POPUPWINDOW | WS_CAPTION
FONT 9, "Arial"
{
    AUTOCHECKBOX "chx1", chx1, 5, 5, 80, 14
    AUTORADIOBUTTON "rad1", rad1, 5, 25, 80, 14
    COMBOBOX cmb1, 5, 45, 80, 300, CBS_HASSTRINGS | CBS_AUTOHSCROLL | CBS_DROPDOWN | WS_VSCROLL | WS_TABSTOP
    LISTBOX lst1, 5, 65, 80, 41, LBS_NOINTEGRALHEIGHT | LBS_HASSTRINGS | WS_VSCROLL | WS_TABSTOP
    DEFPUSHBUTTON "OK", IDOK, 35, 115, 60, 14
    PUSHBUTTON "Cancel", IDCANCEL, 115, 115, 60, 14
}

//////////////////////////////////////////////////////////////////////////////
// TEXTINCLUDE

#ifdef APSTUDIO_INVOKED

1 TEXTINCLUDE
BEGIN
    "resource.h\0"
END

2 TEXTINCLUDE
BEGIN
    "#define APSTUDIO_HIDDEN_SYMBOLS\r\n"
    "#include <windows.h>\r\n"
    "#include <commctrl.h>\r\n"
    "#undef APSTUDIO_HIDDEN_SYMBOLS\r\n"
    "\0"
END

3 TEXTINCLUDE
BEGIN
    "\r\n"
    "\0"
END

#endif    // APSTUDIO_INVOKED

//////////////////////////////////////////////////////////////////////////////

```

`tests/ToolbarTest/CMakeLists.txt`:

```txt
add_executable(ToolbarTest WIN32 ToolbarTest.cpp ToolbarTest_res.rc)
target_link_libraries(ToolbarTest comctl32)

# do statically link
set_target_properties(ToolbarTest PROPERTIES LINK_SEARCH_START_STATIC 1)
set_target_properties(ToolbarTest PROPERTIES LINK_SEARCH_END_STATIC 1)

```

`tests/ToolbarTest/ToolbarTest.cpp`:

```cpp
#include <windows.h>
#include <windowsx.h>
#include <commctrl.h>
#include "../../src/Toolbar.h"
#include "resource.h"

HINSTANCE g_hInstance = NULL;
HWND g_hwndTB = NULL;

static INT CALLBACK CommandIdToImageIndex(INT id)
{
    switch (id)
    {
    case 100: return 0;
    case 101: return 1;
    case 102: return 2;
    }
    return -1;
}

static BOOL CALLBACK CommandIdToText(INT id, LPTSTR pszText, INT cchTextMax)
{
    switch (id)
    {
    case 100:
    case 101:
    case 102:
        LoadString(NULL, id, pszText, cchTextMax);
        return TRUE;
    }
    return FALSE;
}

BOOL OnInitDialog(HWND hwnd, HWND hwndFocus, LPARAM lParam)
{
    DWORD style = WS_CHILD | WS_VISIBLE | CCS_TOP | TBS_HORZ | TBS_TOOLTIPS |
                  TBSTYLE_LIST | TBSTYLE_FLAT;
    DWORD exstyle = 0;
    UINT id = IDW_TOOLBAR;
    g_hwndTB = CreateWindowEx(exstyle, TOOLBARCLASSNAME, NULL,
                              style, 0, 0, 0, 0, hwnd, (HMENU)(INT_PTR)id,
                              g_hInstance, NULL);

    LoadToolbarResource(g_hwndTB, g_hInstance, MAKEINTRESOURCE(IDB_TOOLBAR), CommandIdToImageIndex,
                        CommandIdToText);
    //LoadToolbarResource(g_hwndTB, g_hInstance, MAKEINTRESOURCE(IDB_TOOLBAR),
    //                    CommandIdToImageIndex, NULL);

    PostMessage(hwnd, WM_SIZE, 0, 0);

    return TRUE;
}

void OnCommand(HWND hwnd, int id, HWND hwndCtl, UINT codeNotify)
{
    switch (id)
    {
    case IDOK:
    case IDCANCEL:
        EndDialog(hwnd, id);
        break;
    }
}

void OnSize(HWND hwnd, UINT state, int cx, int cy)
{
    SendMessage(g_hwndTB, TB_AUTOSIZE, 0, 0);
}

LRESULT OnNotify(HWND hwnd, int idFrom, LPNMHDR pnmhdr)
{
    assert(pnmhdr != NULL);

    switch (pnmhdr->code)
    {
    case TTN_NEEDTEXT:
        {
            TOOLTIPTEXT *pTTT = (TOOLTIPTEXT *)pnmhdr;
            static TCHAR s_szText[MAX_PATH];
            s_szText[0] = 0;
            if (CommandIdToText(idFrom, s_szText, _countof(s_szText)))
            {
                pTTT->lpszText = s_szText;
            }
        }
    }
    return 0;
}

INT_PTR CALLBACK
DialogProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    switch (uMsg)
    {
        HANDLE_MSG(hwnd, WM_INITDIALOG, OnInitDialog);
        HANDLE_MSG(hwnd, WM_COMMAND, OnCommand);
        HANDLE_MSG(hwnd, WM_NOTIFY, OnNotify);
        HANDLE_MSG(hwnd, WM_SIZE, OnSize);
    }
    return 0;
}

INT WINAPI
WinMain(HINSTANCE   hInstance,
        HINSTANCE   hPrevInstance,
        LPSTR       lpCmdLine,
        INT         nCmdShow)
{
    g_hInstance = hInstance;
    InitCommonControls();

    DialogBox(hInstance, MAKEINTRESOURCE(IDD_MAIN), NULL, DialogProc);
    return 0;
}

```

`tests/ToolbarTest/ToolbarTest_res.rc`:

```rc
// ToolbarTest_res.rc
// This file is automatically generated by RisohEditor.
// † <-- This dagger helps UTF-8 detection.

#include "resource.h"
#define APSTUDIO_HIDDEN_SYMBOLS
#include <windows.h>
#include <commctrl.h>
#undef APSTUDIO_HIDDEN_SYMBOLS
#pragma code_page(65001) // UTF-8

LANGUAGE LANG_NEUTRAL, SUBLANG_NEUTRAL

//////////////////////////////////////////////////////////////////////////////
// RT_BITMAP

IDB_TOOLBAR BITMAP "res/Bitmap_100.bmp"

//////////////////////////////////////////////////////////////////////////////
// RT_TOOLBAR

IDB_TOOLBAR TOOLBAR 24, 24
{
    BUTTON 100
    BUTTON 101
    SEPARATOR
    BUTTON 102
}

//////////////////////////////////////////////////////////////////////////////
// Languages

#include "lang/en_US.rc"

//////////////////////////////////////////////////////////////////////////////
// TEXTINCLUDE

#ifdef APSTUDIO_INVOKED

1 TEXTINCLUDE
BEGIN
    "resource.h\0"
END

2 TEXTINCLUDE
BEGIN
    "#define APSTUDIO_HIDDEN_SYMBOLS\r\n"
    "#include <windows.h>\r\n"
    "#include <commctrl.h>\r\n"
    "#undef APSTUDIO_HIDDEN_SYMBOLS\r\n"
    "\0"
END

3 TEXTINCLUDE
BEGIN
    "\r\n"
    "\0"
END

#endif    // APSTUDIO_INVOKED

//////////////////////////////////////////////////////////////////////////////

```

`tests/ToolbarTest/lang/en_US.rc`:

```rc
// This file is automatically generated by RisohEditor.
// † <-- This dagger helps UTF-8 detection.

#pragma code_page(65001) // UTF-8

LANGUAGE LANG_ENGLISH, SUBLANG_DEFAULT

//////////////////////////////////////////////////////////////////////////////
// RT_DIALOG

IDD_MAIN DIALOG 0, 0, 215, 70
CAPTION "ToolbarTest"
STYLE DS_MODALFRAME | WS_POPUPWINDOW | WS_CAPTION
FONT 9, "Arial"
{
    DEFPUSHBUTTON "OK", IDOK, 35, 45, 60, 15
    PUSHBUTTON "Cancel", IDCANCEL, 120, 45, 60, 15
}

//////////////////////////////////////////////////////////////////////////////
// RT_STRING

STRINGTABLE
{
    100, "Test 1"
    101, "Test 2"
    102, "Test 3"
}

//////////////////////////////////////////////////////////////////////////////

```

`tests/ToolbarTest/resource.h`:

```h
//{{NO_DEPENDENCIES}}
// Microsoft Visual C++ Compatible
// This file is automatically generated by RisohEditor.
// ToolbarTest_res.rc

#define IDB_TOOLBAR                         100

#define IDD_MAIN                            100

#define IDW_TOOLBAR                         1

#ifdef APSTUDIO_INVOKED
    #ifndef APSTUDIO_READONLY_SYMBOLS
        #define _APS_NO_MFC                 1
        #define _APS_NEXT_RESOURCE_VALUE    100
        #define _APS_NEXT_COMMAND_VALUE     100
        #define _APS_NEXT_CONTROL_VALUE     1000
        #define _APS_NEXT_SYMED_VALUE       300
    #endif
#endif

```

`tests/cmdline/CMakeLists.txt`:

```txt
add_executable(cmdline cmdline.cpp)

```

`tests/cmdline/LICENSE.txt`:

```txt
The MIT License (MIT)

Copyright (C) 2021 Katayama Hirofumi MZ <katayama.hirofumi.mz@gmail.com>

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.

```

`tests/cmdline/cmdline.cpp`:

```cpp
#include <stdio.h>

int main(int argc, char **argv)
{
    for (int i = 1; i < argc; ++i)
    {
        fprintf(stderr, "argv[%d] = '%s'\n", i, argv[i]);
    }
    return 0;
}

```

`win32-samples/DialogBox/CMakeLists.txt`:

```txt
# CMakeLists.txt --- CMake project settings
#    ex) cmake -G "Visual Studio 9 2008" .
#    ex) cmake -DCMAKE_BUILD_TYPE=Release -G "MSYS Makefiles" .
##############################################################################

# CMake minimum version
cmake_minimum_required(VERSION 2.4)

# project name and languages
project(DialogBox CXX RC)

if (CMAKE_CXX_COMPILER_ID STREQUAL "Clang")
    # using Clang
    set(CMAKE_C_FLAGS "-static")
    set(CMAKE_CXX_FLAGS "-static")
elseif (CMAKE_CXX_COMPILER_ID STREQUAL "GNU")
    # using GCC
    set(CMAKE_C_FLAGS "-static")
    set(CMAKE_CXX_FLAGS "-static")
elseif (MSVC)
    # replace "/MD" with "/MT" (building without runtime DLLs)
    set(CompilerFlags
        CMAKE_C_FLAGS
        CMAKE_C_FLAGS_DEBUG
        CMAKE_C_FLAGS_RELEASE
        CMAKE_C_FLAGS_RELWITHDEBINFO
        CMAKE_CXX_FLAGS
        CMAKE_CXX_FLAGS_DEBUG
        CMAKE_CXX_FLAGS_RELEASE
        CMAKE_CXX_FLAGS_RELWITHDEBINFO)
    foreach(CompilerFlags ${CompilerFlags})
        string(REPLACE "/MD" "/MT" ${CompilerFlags} "${${CompilerFlags}}")
    endforeach()
endif()

##############################################################################

# DialogBox.exe
add_executable(DialogBox WIN32 DialogBox.cpp DialogBox_res.rc)
target_link_libraries(DialogBox comctl32)

##############################################################################

```

`win32-samples/DialogBox/DialogBox.cpp`:

```cpp
#include <windows.h>
#include <windowsx.h>
#include <commctrl.h>
#include "resource.h"

BOOL OnInitDialog(HWND hwnd, HWND hwndFocus, LPARAM lParam)
{
    SetDlgItemText(hwnd, stc1, TEXT("Hello, Win32 dialog!"));
    return TRUE;
}

void OnCommand(HWND hwnd, int id, HWND hwndCtl, UINT codeNotify)
{
    switch (id)
    {
    case IDOK:
    case IDCANCEL:
        EndDialog(hwnd, id);
        break;
    }
}

INT_PTR CALLBACK
DialogProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    switch (uMsg)
    {
        HANDLE_MSG(hwnd, WM_INITDIALOG, OnInitDialog);
        HANDLE_MSG(hwnd, WM_COMMAND, OnCommand);
    }
    return 0;
}

INT WINAPI
WinMain(HINSTANCE   hInstance,
        HINSTANCE   hPrevInstance,
        LPSTR       lpCmdLine,
        INT         nCmdShow)
{
    InitCommonControls();
    DialogBox(hInstance, MAKEINTRESOURCE(IDD_MAIN), NULL, DialogProc);
    return 0;
}

```

`win32-samples/DialogBox/DialogBox_res.rc`:

```rc
// DialogBox_res.rc
// This file is automatically generated by RisohEditor.
// † <-- This dagger helps UTF-8 detection.

#include "resource.h"
#define APSTUDIO_HIDDEN_SYMBOLS
#include <windows.h>
#include <commctrl.h>
#undef APSTUDIO_HIDDEN_SYMBOLS
#pragma code_page(65001) // UTF-8

//////////////////////////////////////////////////////////////////////////////
// Languages

#include "lang/en_US.rc"

//////////////////////////////////////////////////////////////////////////////
// TEXTINCLUDE

#ifdef APSTUDIO_INVOKED

1 TEXTINCLUDE
BEGIN
    "resource.h\0"
END

2 TEXTINCLUDE
BEGIN
    "#define APSTUDIO_HIDDEN_SYMBOLS\r\n"
    "#include <windows.h>\r\n"
    "#include <commctrl.h>\r\n"
    "#undef APSTUDIO_HIDDEN_SYMBOLS\r\n"
    "\0"
END

3 TEXTINCLUDE
BEGIN
    "\r\n"
    "\0"
END

#endif    // APSTUDIO_INVOKED

//////////////////////////////////////////////////////////////////////////////

```

`win32-samples/DialogBox/lang/en_US.rc`:

```rc
// This file is automatically generated by RisohEditor.
// † <-- This dagger helps UTF-8 detection.

#pragma code_page(65001) // UTF-8

LANGUAGE LANG_ENGLISH, SUBLANG_DEFAULT

//////////////////////////////////////////////////////////////////////////////
// RT_DIALOG

IDD_MAIN DIALOG 0, 0, 215, 135
CAPTION "DialogBox"
STYLE DS_CENTER | DS_MODALFRAME | WS_POPUPWINDOW | WS_CAPTION
FONT 9, "MS Shell Dlg"
{
    LTEXT "This is a sample text.", stc1, 9, 16, 118, 32
    DEFPUSHBUTTON "OK", IDOK, 35, 115, 60, 14
    PUSHBUTTON "Cancel", IDCANCEL, 115, 115, 60, 14
}

//////////////////////////////////////////////////////////////////////////////

```

`win32-samples/DialogBox/resource.h`:

```h
//{{NO_DEPENDENCIES}}
// Microsoft Visual C++ Compatible
// This file is automatically generated by RisohEditor.
// DialogBox_res.rc

#define IDD_MAIN                            100

#ifdef APSTUDIO_INVOKED
    #ifndef APSTUDIO_READONLY_SYMBOLS
        #define _APS_NO_MFC                 1
        #define _APS_NEXT_RESOURCE_VALUE    100
        #define _APS_NEXT_COMMAND_VALUE     100
        #define _APS_NEXT_CONTROL_VALUE     1000
        #define _APS_NEXT_SYMED_VALUE       300
    #endif
#endif

```

`win32-samples/MainWnd/CMakeLists.txt`:

```txt
# CMakeLists.txt --- CMake project settings
#    ex) cmake -G "Visual Studio 9 2008" .
#    ex) cmake -DCMAKE_BUILD_TYPE=Release -G "MSYS Makefiles" .
##############################################################################

# CMake minimum version
cmake_minimum_required(VERSION 2.4)

# project name and languages
project(MainWnd CXX RC)

if (CMAKE_CXX_COMPILER_ID STREQUAL "Clang")
    # using Clang
    set(CMAKE_C_FLAGS "-static")
    set(CMAKE_CXX_FLAGS "-static")
elseif (CMAKE_CXX_COMPILER_ID STREQUAL "GNU")
    # using GCC
    set(CMAKE_C_FLAGS "-static")
    set(CMAKE_CXX_FLAGS "-static")
elseif (MSVC)
    # replace "/MD" with "/MT" (building without runtime DLLs)
    set(CompilerFlags
        CMAKE_C_FLAGS
        CMAKE_C_FLAGS_DEBUG
        CMAKE_C_FLAGS_RELEASE
        CMAKE_C_FLAGS_RELWITHDEBINFO
        CMAKE_CXX_FLAGS
        CMAKE_CXX_FLAGS_DEBUG
        CMAKE_CXX_FLAGS_RELEASE
        CMAKE_CXX_FLAGS_RELWITHDEBINFO)
    foreach(CompilerFlags ${CompilerFlags})
        string(REPLACE "/MD" "/MT" ${CompilerFlags} "${${CompilerFlags}}")
    endforeach()
endif()

##############################################################################

# MainWnd.exe
add_executable(MainWnd WIN32 MainWnd.cpp MainWnd_res.rc)
target_link_libraries(MainWnd comctl32)

##############################################################################

```

`win32-samples/MainWnd/MainWnd.cpp`:

```cpp
#include <windows.h>
#include <windowsx.h>
#include <commctrl.h>
#include "resource.h"

HINSTANCE g_hInst = NULL;
HWND g_hMainWnd = NULL;
static const TCHAR s_szClassName[] = TEXT("RisohEditor MainWnd");
static TCHAR s_szText[64] = TEXT("");
HWND g_hButton = NULL;

#define CX_BUTTON 100
#define CY_BUTTON 24

BOOL OnCreate(HWND hwnd, LPCREATESTRUCT lpCreateStruct)
{
    g_hMainWnd = hwnd;

    LoadString(g_hInst, IDS_TEXT1, s_szText, _countof(s_szText));

    RECT rc;
    GetClientRect(hwnd, &rc);

    INT x = (rc.left + rc.right - CX_BUTTON) / 2;
    INT y = (rc.top + rc.bottom - CY_BUTTON) / 2;

    DWORD style = WS_CHILD | WS_VISIBLE | BS_PUSHBUTTON;
    HMENU id = reinterpret_cast<HMENU>(static_cast<INT_PTR>(psh1));
    g_hButton = CreateWindow(TEXT("BUTTON"), TEXT("psh1"), style,
                             x, y, CX_BUTTON, CY_BUTTON,
                             hwnd, id, g_hInst, NULL);
    if (!g_hButton)
        return FALSE;

    return TRUE;
}

void OnPaint(HWND hwnd)
{
    RECT rc;
    GetClientRect(hwnd, &rc);

    PAINTSTRUCT ps;
    if (HDC hdc = BeginPaint(hwnd, &ps))
    {
        MoveToEx(hdc, rc.left, rc.top, NULL);
        LineTo(hdc, rc.right, rc.bottom);

        MoveToEx(hdc, rc.right, rc.top, NULL);
        LineTo(hdc, rc.left, rc.bottom);

        UINT uFormat = DT_LEFT | DT_TOP | DT_SINGLELINE;
        DrawText(hdc, s_szText, -1, &rc, uFormat);

        EndPaint(hwnd, &ps);
    }
}

void OnCommand(HWND hwnd, int id, HWND hwndCtl, UINT codeNotify)
{
    switch (id)
    {
    case psh1:
        LoadString(g_hInst, IDS_TEXT2, s_szText, _countof(s_szText));
        MessageBox(hwnd, s_szText, TEXT("OnCommand"), MB_ICONINFORMATION);
        InvalidateRect(hwnd, NULL, TRUE);
        break;
    }
}

void OnDestroy(HWND hwnd)
{
    DestroyWindow(g_hButton);
    g_hButton = NULL;

    PostQuitMessage(EXIT_SUCCESS);
}

void OnSize(HWND hwnd, UINT state, int cx, int cy)
{
    if (!g_hButton)
        return;

    RECT rc;
    GetClientRect(hwnd, &rc);

#if 1
    INT x = (rc.left + rc.right - CX_BUTTON) / 2;
    INT y = (rc.top + rc.bottom - CY_BUTTON) / 2;
    MoveWindow(g_hButton, x, y, CX_BUTTON, CY_BUTTON, TRUE);
#endif
}

LRESULT CALLBACK
WindowProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    switch (uMsg)
    {
        HANDLE_MSG(hwnd, WM_CREATE, OnCreate);
        HANDLE_MSG(hwnd, WM_PAINT, OnPaint);
        HANDLE_MSG(hwnd, WM_COMMAND, OnCommand);
        HANDLE_MSG(hwnd, WM_SIZE, OnSize);
        HANDLE_MSG(hwnd, WM_DESTROY, OnDestroy);
    default:
        return DefWindowProc(hwnd, uMsg, wParam, lParam);
    }
    return 0;
}

BOOL InitInstance(HINSTANCE hInstance, INT nCmdShow)
{
    InitCommonControls();

    g_hInst = hInstance;

    WNDCLASSEX wcx = { sizeof(wcx) };
    wcx.style = CS_HREDRAW | CS_VREDRAW | CS_DBLCLKS;
    wcx.lpfnWndProc = WindowProc;
    wcx.hInstance = hInstance;
    //wcx.hIcon = LoadIcon(NULL, IDI_APPLICATION);
    wcx.hIcon = LoadIcon(hInstance, MAKEINTRESOURCE(IDI_MAINICON));
    wcx.hCursor = LoadCursor(NULL, IDC_ARROW);
    wcx.hbrBackground = GetSysColorBrush(COLOR_3DFACE + 1);
    wcx.lpszClassName = s_szClassName;
    //wcx.hIconSm = NULL;
    wcx.hIconSm = reinterpret_cast<HICON>(
        LoadImage(hInstance, MAKEINTRESOURCE(IDI_MAINICON), IMAGE_ICON,
            GetSystemMetrics(SM_CXSMICON), GetSystemMetrics(SM_CYSMICON), 0));
    if (!RegisterClassEx(&wcx))
    {
        MessageBoxA(NULL, "RegisterClassEx failed", NULL, MB_ICONERROR);
        return FALSE;
    }

    DWORD style = WS_OVERLAPPEDWINDOW;
    DWORD exstyle = WS_EX_ACCEPTFILES;
    CreateWindowEx(exstyle, s_szClassName, TEXT("The main window"), style,
                   CW_USEDEFAULT, CW_USEDEFAULT, 300, 200,
                   NULL, NULL, hInstance, NULL);
    if (!g_hMainWnd)
    {
        MessageBoxA(NULL, "CreateWindowEx failed", NULL, MB_ICONERROR);
        return FALSE;
    }

    ShowWindow(g_hMainWnd, nCmdShow);
    UpdateWindow(g_hMainWnd);

    return TRUE;
}

INT ExitInstance(MSG& msg)
{
    return INT(msg.wParam);
}

INT Run(VOID)
{
    MSG msg;

    for (;;)
    {
        INT ret = GetMessage(&msg, NULL, 0, 0);
        if (ret == -1)
        {
            DebugBreak();
            break;
        }
        if (ret == 0)
            break;

        TranslateMessage(&msg);
        DispatchMessage(&msg);
    }

    return ExitInstance(msg);
}

INT WINAPI
WinMain(HINSTANCE   hInstance,
        HINSTANCE   hPrevInstance,
        LPSTR       lpCmdLine,
        INT         nCmdShow)
{
    if (!InitInstance(hInstance, nCmdShow))
        return EXIT_FAILURE;

    return Run();
}

```

`win32-samples/MainWnd/MainWnd_res.rc`:

```rc
// MainWnd_res.rc
// This file is automatically generated by RisohEditor.
// † <-- This dagger helps UTF-8 detection.

#include "resource.h"
#define APSTUDIO_HIDDEN_SYMBOLS
#include <windows.h>
#include <commctrl.h>
#undef APSTUDIO_HIDDEN_SYMBOLS
#pragma code_page(65001) // UTF-8

LANGUAGE LANG_NEUTRAL, SUBLANG_NEUTRAL

//////////////////////////////////////////////////////////////////////////////
// RT_GROUP_ICON

IDI_MAINICON ICON "res/Icon_100.ico"

//////////////////////////////////////////////////////////////////////////////
// Languages

#include "lang/en_US.rc"

//////////////////////////////////////////////////////////////////////////////
// TEXTINCLUDE

#ifdef APSTUDIO_INVOKED

1 TEXTINCLUDE
BEGIN
    "resource.h\0"
END

2 TEXTINCLUDE
BEGIN
    "#define APSTUDIO_HIDDEN_SYMBOLS\r\n"
    "#include <windows.h>\r\n"
    "#include <commctrl.h>\r\n"
    "#undef APSTUDIO_HIDDEN_SYMBOLS\r\n"
    "\0"
END

3 TEXTINCLUDE
BEGIN
    "\r\n"
    "\0"
END

#endif    // APSTUDIO_INVOKED

//////////////////////////////////////////////////////////////////////////////

```

`win32-samples/MainWnd/lang/en_US.rc`:

```rc
// This file is automatically generated by RisohEditor.
// † <-- This dagger helps UTF-8 detection.

#pragma code_page(65001) // UTF-8

LANGUAGE LANG_ENGLISH, SUBLANG_DEFAULT

//////////////////////////////////////////////////////////////////////////////
// RT_STRING

STRINGTABLE
{
    IDS_TEXT1, "This is a sample text."
    IDS_TEXT2, "Hello"
}

//////////////////////////////////////////////////////////////////////////////

```

`win32-samples/MainWnd/resource.h`:

```h
//{{NO_DEPENDENCIES}}
// Microsoft Visual C++ Compatible
// This file is automatically generated by RisohEditor.
// MainWnd_res.rc

#define IDI_MAINICON                        100

#define IDS_TEXT1                           100
#define IDS_TEXT2                           101

#ifdef APSTUDIO_INVOKED
    #ifndef APSTUDIO_READONLY_SYMBOLS
        #define _APS_NO_MFC                 1
        #define _APS_NEXT_RESOURCE_VALUE    100
        #define _APS_NEXT_COMMAND_VALUE     100
        #define _APS_NEXT_CONTROL_VALUE     1000
        #define _APS_NEXT_SYMED_VALUE       300
    #endif
#endif

```

`win32-samples/ToolbarTest/CMakeLists.txt`:

```txt
# CMakeLists.txt --- CMake project settings
#    ex) cmake -G "Visual Studio 9 2008" .
#    ex) cmake -DCMAKE_BUILD_TYPE=Release -G "MSYS Makefiles" .
##############################################################################

# CMake minimum version
cmake_minimum_required(VERSION 2.4)

# project name and languages
project(ToolbarTest CXX RC)

if (CMAKE_CXX_COMPILER_ID STREQUAL "Clang")
    # using Clang
    set(CMAKE_C_FLAGS "-static")
    set(CMAKE_CXX_FLAGS "-static")
elseif (CMAKE_CXX_COMPILER_ID STREQUAL "GNU")
    # using GCC
    set(CMAKE_C_FLAGS "-static")
    set(CMAKE_CXX_FLAGS "-static")
elseif (MSVC)
    # replace "/MD" with "/MT" (building without runtime DLLs)
    set(CompilerFlags
        CMAKE_C_FLAGS
        CMAKE_C_FLAGS_DEBUG
        CMAKE_C_FLAGS_RELEASE
        CMAKE_C_FLAGS_RELWITHDEBINFO
        CMAKE_CXX_FLAGS
        CMAKE_CXX_FLAGS_DEBUG
        CMAKE_CXX_FLAGS_RELEASE
        CMAKE_CXX_FLAGS_RELWITHDEBINFO)
    foreach(CompilerFlags ${CompilerFlags})
        string(REPLACE "/MD" "/MT" ${CompilerFlags} "${${CompilerFlags}}")
    endforeach()
endif()

##############################################################################

# ToolbarTest.exe
add_executable(ToolbarTest WIN32 ToolbarTest.cpp ToolbarTest_res.rc)
target_link_libraries(ToolbarTest comctl32)

##############################################################################

```

`win32-samples/ToolbarTest/ToolbarTest.cpp`:

```cpp
#include <windows.h>
#include <windowsx.h>
#include <commctrl.h>
#include "../../src/Toolbar.h"
#include "resource.h"

HINSTANCE g_hInstance = NULL;
HWND g_hwndTB = NULL;

static INT CALLBACK CommandIdToImageIndex(INT id)
{
    switch (id)
    {
    case 100: return 0;
    case 101: return 1;
    case 102: return 2;
    }
    return -1;
}

static BOOL CALLBACK CommandIdToText(INT id, LPTSTR pszText, INT cchTextMax)
{
    switch (id)
    {
    case 100:
    case 101:
    case 102:
        LoadString(NULL, id, pszText, cchTextMax);
        return TRUE;
    }
    return FALSE;
}

BOOL OnInitDialog(HWND hwnd, HWND hwndFocus, LPARAM lParam)
{
    DWORD style = WS_CHILD | WS_VISIBLE | CCS_TOP | TBS_HORZ | TBS_TOOLTIPS |
                  TBSTYLE_LIST | TBSTYLE_FLAT;
    DWORD exstyle = 0;
    UINT id = IDW_TOOLBAR;
    g_hwndTB = CreateWindowEx(exstyle, TOOLBARCLASSNAME, NULL,
                              style, 0, 0, 0, 0, hwnd, (HMENU)(INT_PTR)id,
                              g_hInstance, NULL);

    LoadToolbarResource(g_hwndTB, g_hInstance, MAKEINTRESOURCE(IDB_TOOLBAR), CommandIdToImageIndex,
                        CommandIdToText);
    //LoadToolbarResource(g_hwndTB, g_hInstance, MAKEINTRESOURCE(IDB_TOOLBAR),
    //                    CommandIdToImageIndex, NULL);

    PostMessage(hwnd, WM_SIZE, 0, 0);

    return TRUE;
}

void OnCommand(HWND hwnd, int id, HWND hwndCtl, UINT codeNotify)
{
    switch (id)
    {
    case IDOK:
    case IDCANCEL:
        EndDialog(hwnd, id);
        break;
    }
}

void OnSize(HWND hwnd, UINT state, int cx, int cy)
{
    SendMessage(g_hwndTB, TB_AUTOSIZE, 0, 0);
}

LRESULT OnNotify(HWND hwnd, int idFrom, LPNMHDR pnmhdr)
{
    assert(pnmhdr != NULL);

    switch (pnmhdr->code)
    {
    case TTN_NEEDTEXT:
        {
            TOOLTIPTEXT *pTTT = (TOOLTIPTEXT *)pnmhdr;
            static TCHAR s_szText[MAX_PATH];
            s_szText[0] = 0;
            if (CommandIdToText(idFrom, s_szText, _countof(s_szText)))
            {
                pTTT->lpszText = s_szText;
            }
        }
    }
    return 0;
}

INT_PTR CALLBACK
DialogProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    switch (uMsg)
    {
        HANDLE_MSG(hwnd, WM_INITDIALOG, OnInitDialog);
        HANDLE_MSG(hwnd, WM_COMMAND, OnCommand);
        HANDLE_MSG(hwnd, WM_NOTIFY, OnNotify);
        HANDLE_MSG(hwnd, WM_SIZE, OnSize);
    }
    return 0;
}

INT WINAPI
WinMain(HINSTANCE   hInstance,
        HINSTANCE   hPrevInstance,
        LPSTR       lpCmdLine,
        INT         nCmdShow)
{
    g_hInstance = hInstance;
    InitCommonControls();

    DialogBox(hInstance, MAKEINTRESOURCE(IDD_MAIN), NULL, DialogProc);
    return 0;
}

```

`win32-samples/ToolbarTest/ToolbarTest_res.rc`:

```rc
// ToolbarTest_res.rc
// This file is automatically generated by RisohEditor.
// † <-- This dagger helps UTF-8 detection.

#include "resource.h"
#define APSTUDIO_HIDDEN_SYMBOLS
#include <windows.h>
#include <commctrl.h>
#undef APSTUDIO_HIDDEN_SYMBOLS
#pragma code_page(65001) // UTF-8

LANGUAGE LANG_NEUTRAL, SUBLANG_NEUTRAL

//////////////////////////////////////////////////////////////////////////////
// RT_BITMAP

IDB_TOOLBAR BITMAP "res/Bitmap_100.bmp"

//////////////////////////////////////////////////////////////////////////////
// RT_TOOLBAR

IDB_TOOLBAR TOOLBAR 24, 24
{
    BUTTON 100
    BUTTON 101
    SEPARATOR
    BUTTON 102
}

//////////////////////////////////////////////////////////////////////////////
// Languages

#include "lang/en_US.rc"

//////////////////////////////////////////////////////////////////////////////
// TEXTINCLUDE

#ifdef APSTUDIO_INVOKED

1 TEXTINCLUDE
BEGIN
    "resource.h\0"
END

2 TEXTINCLUDE
BEGIN
    "#define APSTUDIO_HIDDEN_SYMBOLS\r\n"
    "#include <windows.h>\r\n"
    "#include <commctrl.h>\r\n"
    "#undef APSTUDIO_HIDDEN_SYMBOLS\r\n"
    "\0"
END

3 TEXTINCLUDE
BEGIN
    "\r\n"
    "\0"
END

#endif    // APSTUDIO_INVOKED

//////////////////////////////////////////////////////////////////////////////

```

`win32-samples/ToolbarTest/lang/en_US.rc`:

```rc
// This file is automatically generated by RisohEditor.
// † <-- This dagger helps UTF-8 detection.

#pragma code_page(65001) // UTF-8

LANGUAGE LANG_ENGLISH, SUBLANG_DEFAULT

//////////////////////////////////////////////////////////////////////////////
// RT_DIALOG

IDD_MAIN DIALOG 0, 0, 215, 70
CAPTION "ToolbarTest"
STYLE DS_MODALFRAME | WS_POPUPWINDOW | WS_CAPTION
FONT 9, "Arial"
{
    DEFPUSHBUTTON "OK", IDOK, 35, 45, 60, 15
    PUSHBUTTON "Cancel", IDCANCEL, 120, 45, 60, 15
}

//////////////////////////////////////////////////////////////////////////////
// RT_STRING

STRINGTABLE
{
    100, "Test 1"
    101, "Test 2"
    102, "Test 3"
}

//////////////////////////////////////////////////////////////////////////////

```

`win32-samples/ToolbarTest/resource.h`:

```h
//{{NO_DEPENDENCIES}}
// Microsoft Visual C++ Compatible
// This file is automatically generated by RisohEditor.
// ToolbarTest_res.rc

#define IDB_TOOLBAR                         100

#define IDD_MAIN                            100

#define IDW_TOOLBAR                         1

#ifdef APSTUDIO_INVOKED
    #ifndef APSTUDIO_READONLY_SYMBOLS
        #define _APS_NO_MFC                 1
        #define _APS_NEXT_RESOURCE_VALUE    100
        #define _APS_NEXT_COMMAND_VALUE     100
        #define _APS_NEXT_CONTROL_VALUE     1000
        #define _APS_NEXT_SYMED_VALUE       300
    #endif
#endif

```