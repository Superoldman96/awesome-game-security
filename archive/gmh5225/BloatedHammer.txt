Project Path: arc_gmh5225_BloatedHammer_2hs7k4pw

Source Tree:

```txt
arc_gmh5225_BloatedHammer_2hs7k4pw
├── BloatedHammer
│   ├── BloatedHammer.vcxproj
│   ├── BloatedHammer.vcxproj.filters
│   └── bloat.cpp
├── BloatedHammer.sln
├── LICENSE.txt
└── README.md

```

`BloatedHammer.sln`:

```sln

Microsoft Visual Studio Solution File, Format Version 12.00
# Visual Studio Version 17
VisualStudioVersion = 17.2.32630.192
MinimumVisualStudioVersion = 10.0.40219.1
Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "BloatedHammer", "BloatedHammer\BloatedHammer.vcxproj", "{37ECBB41-2B1B-4E69-AD9C-53CFCB1B9CC4}"
EndProject
Global
	GlobalSection(SolutionConfigurationPlatforms) = preSolution
		Debug|x64 = Debug|x64
		Debug|x86 = Debug|x86
		Release|x64 = Release|x64
		Release|x86 = Release|x86
	EndGlobalSection
	GlobalSection(ProjectConfigurationPlatforms) = postSolution
		{37ECBB41-2B1B-4E69-AD9C-53CFCB1B9CC4}.Debug|x64.ActiveCfg = Debug|x64
		{37ECBB41-2B1B-4E69-AD9C-53CFCB1B9CC4}.Debug|x64.Build.0 = Debug|x64
		{37ECBB41-2B1B-4E69-AD9C-53CFCB1B9CC4}.Debug|x86.ActiveCfg = Debug|Win32
		{37ECBB41-2B1B-4E69-AD9C-53CFCB1B9CC4}.Debug|x86.Build.0 = Debug|Win32
		{37ECBB41-2B1B-4E69-AD9C-53CFCB1B9CC4}.Release|x64.ActiveCfg = Release|x64
		{37ECBB41-2B1B-4E69-AD9C-53CFCB1B9CC4}.Release|x64.Build.0 = Release|x64
		{37ECBB41-2B1B-4E69-AD9C-53CFCB1B9CC4}.Release|x86.ActiveCfg = Release|Win32
		{37ECBB41-2B1B-4E69-AD9C-53CFCB1B9CC4}.Release|x86.Build.0 = Release|Win32
	EndGlobalSection
	GlobalSection(SolutionProperties) = preSolution
		HideSolutionNode = FALSE
	EndGlobalSection
	GlobalSection(ExtensibilityGlobals) = postSolution
		SolutionGuid = {9BA16C06-9820-46CB-9BD1-95D1FEF8EFB8}
	EndGlobalSection
EndGlobal

```

`BloatedHammer/BloatedHammer.vcxproj`:

```vcxproj
<?xml version="1.0" encoding="utf-8"?>
<Project DefaultTargets="Build" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup Label="ProjectConfigurations">
    <ProjectConfiguration Include="Debug|Win32">
      <Configuration>Debug</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|Win32">
      <Configuration>Release</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug|x64">
      <Configuration>Debug</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|x64">
      <Configuration>Release</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
  </ItemGroup>
  <PropertyGroup Label="Globals">
    <VCProjectVersion>16.0</VCProjectVersion>
    <Keyword>Win32Proj</Keyword>
    <ProjectGuid>{37ecbb41-2b1b-4e69-ad9c-53cfcb1b9cc4}</ProjectGuid>
    <RootNamespace>BloatedHammer</RootNamespace>
    <WindowsTargetPlatformVersion>10.0</WindowsTargetPlatformVersion>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v143</PlatformToolset>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v143</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v143</PlatformToolset>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v143</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
  <ImportGroup Label="ExtensionSettings">
  </ImportGroup>
  <ImportGroup Label="Shared">
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <PropertyGroup Label="UserMacros" />
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>WIN32;_DEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>WIN32;NDEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
      <LanguageStandard>stdcpp20</LanguageStandard>
      <RuntimeLibrary>MultiThreaded</RuntimeLibrary>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <GenerateDebugInformation>true</GenerateDebugInformation>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>_DEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
      <LanguageStandard>stdcpp20</LanguageStandard>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>NDEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
      <LanguageStandard>stdcpp20</LanguageStandard>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <GenerateDebugInformation>false</GenerateDebugInformation>
    </Link>
  </ItemDefinitionGroup>
  <ItemGroup>
    <ClCompile Include="bloat.cpp" />
  </ItemGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
  <ImportGroup Label="ExtensionTargets">
  </ImportGroup>
</Project>
```

`BloatedHammer/BloatedHammer.vcxproj.filters`:

```filters
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup>
    <Filter Include="Source Files">
      <UniqueIdentifier>{4FC737F1-C7A5-4376-A066-2A32D752A2FF}</UniqueIdentifier>
      <Extensions>cpp;c;cc;cxx;c++;cppm;ixx;def;odl;idl;hpj;bat;asm;asmx</Extensions>
    </Filter>
    <Filter Include="Header Files">
      <UniqueIdentifier>{93995380-89BD-4b04-88EB-625FBE52EBFB}</UniqueIdentifier>
      <Extensions>h;hh;hpp;hxx;h++;hm;inl;inc;ipp;xsd</Extensions>
    </Filter>
    <Filter Include="Resource Files">
      <UniqueIdentifier>{67DA6AB6-F800-4c08-8B7A-83BB121AAD01}</UniqueIdentifier>
      <Extensions>rc;ico;cur;bmp;dlg;rc2;rct;bin;rgs;gif;jpg;jpeg;jpe;resx;tiff;tif;png;wav;mfcribbon-ms</Extensions>
    </Filter>
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="bloat.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
  </ItemGroup>
</Project>
```

`BloatedHammer/bloat.cpp`:

```cpp
#include <tuple>            
#include <cstdio>

/*++
Routine Description:

	This function is called as a user-mode routine
	normally during the start of execution. It's job
	is to call your function to was the time of
	sandbox, by api hammering without loop...

Arguments:

	size -  The number of times you want your specific
			function to be called. Ideally not too big
			as the compiler will complain.
	Fn   -  A function capturing a size_t value. This
			will be called size times, with an increasing
			value.  (implicit template instantiation)

Comments:
	-   We're essentially unfolding the loop. This generates
		a lot of garbage code in order to evade sandbox by a
		timeout.
	-   Requires on std:c++20 and possibly /O2
	-   Size has to be smaller than 256 if compiling on clang
		https://reviews.llvm.org/rG9c9974c3ccb6468cc83f759240293538cf123fcd


Return Value:

	None.
--*/
template<size_t size, class Fn>
auto bloat(Fn fn) -> void
{
	[&] <auto... Indexes>(std::index_sequence<Indexes...>) {
		(((fn(Indexes))), ...);
	}(std::make_index_sequence<size>{});
}

/*++
Inspirations:
	- https://unit42.paloaltonetworks.com/api-hammering-malware-families/
	- https://www.joesecurity.org/blog/498839998833561473
	- https://www.joesecurity.org/blog/3660886847485093803

Downsides:
	- Bloated file size as the loops are unrolled.
	- Requires C++20 (possible with C++17 but not as clean)
--*/
auto main() -> int
{

	//bloat<512>([&](size_t val) {
	//    // Do whatever here to waste time like printf
	//    // or use a bunch of Windows APIs
	//    auto mod = val % 4;
	//    switch (mod)
	//    {
	//    case 0:
	//        // Nested will change CFG and take more time
	//        bloat<256>([&](size_t val) {
	//            printf("Case 0 recursive.\n");
	//            });
	//    case 1:
	//        bloat<32>([&](size_t val) {
	//            printf("Case 1 recursive.\n");
	//            // Nested^2 is also good
	//            bloat<32>([&](size_t val) {
	//                printf("Case 1 double recursive.\n");
	//                bloat<32>([&](size_t val) {
	//                    printf("Case 1 triple recursive.\n");
	//                    });
	//                });
	//            });
	//    case 2:
	//        bloat<256>([&](size_t val) {
	//            printf("Case 2 recursive.\n");
	//            });

	//    case 3:
	//        bloat<256>([&](size_t val) {
	//            printf("Case 3 recursive.\n");
	//            });

	//    default:
	//        break;
	//    }
	//    });

	bloat<10>([&](size_t val) {
		// Do whatever here to waste time like printf
		// or use a bunch of Windows APIs
		printf("val=%d\n", val);
		auto mod = val % 4;
		switch (mod)
		{
		case 0:
			printf("Case 0 recursive.\n");
			break;
		case 1:
			printf("Case 1 recursive.\n");
			break;
		case 2:
			printf("Case 2 recursive.\n");
			break;

		case 3:
			printf("Case 3 recursive.\n");
			break;

		default:
			break;
		}
		});

}
```

`LICENSE.txt`:

```txt
MIT License

Copyright (c) [year] [fullname]

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.

```

`README.md`:

```md
# BloatedHammer
API Hammering with C++20 by folding (avoiding loops)

This is a PoC to apply modern C++ techniques to compile time API Hammering.

## Why?
- Using a pre-compliation script in order to obfuscate is difficult to develop alongside.
- Having a for loop is lame
- I was interested in this technique having read the [Unit42 report](https://unit42.paloaltonetworks.com/api-hammering-malware-families/) and thought about the best way to replicate it. 


How to use
---
```
bloat<SIZE>([&](size_t val){
  // Our lambda function will capture val which is just an incrementing index value
  // Such as CreateFile or registry stuff anything to waste time
  
  bloat<SIZE>([&](size_t val){
    // You can embed like nested loops, but it'll all be unfolded
    
  });
});
```
The bigger the size, the longer it'll take to compile, and execute.



## Next Steps?
Adding an element of randomness 

References
---
https://unit42.paloaltonetworks.com/api-hammering-malware-families/

https://www.joesecurity.org/blog/498839998833561473

https://www.joesecurity.org/blog/3660886847485093803

```