Project Path: arc_gmh5225_opaque-predicates-detective_9_0zrjrh

Source Tree:

```txt
arc_gmh5225_opaque-predicates-detective_9_0zrjrh
├── LICENSE
├── README.md
├── __init__.py
├── __main__.py
├── current_output.png
├── evaluations
├── op_detective
│   ├── __init__.py
│   ├── non_generic_spec.json
│   ├── rules
│   │   ├── __init__.py
│   │   ├── helpers
│   │   │   ├── __init__.py
│   │   │   ├── llil_helpers.py
│   │   │   └── mlil_helpers.py
│   │   ├── llil_rules.py
│   │   └── mlil_rules.py
│   └── utils
│       ├── __init__.py
│       └── bb_utils.py
├── op_detective.png
├── op_helpers.py
├── plugin.json
├── requirements.txt
└── whole.png

```

`LICENSE`:

```
Copyright (c) 2019 yujyet@uci.edu

Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the "Software"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

```

`README.md`:

```md
# <p align='center'> Opaque Predicates Detective </p>

![OP Detective](op_detective.png)

## Introduction: 
Previous approaches to generically identify opaque predicates work by identifying if a conditional branch contains an invariant expression. Our approach generically identify opaque predicates from a different perspective: __the damage caused by the obfuscation__. The damage is localized at the basic block level (or at the function level) regardless of how an opaque predicate's invariant expression is constructed. This approach allows us to also detect an opaque predicate whose invariant expression is constructed across multiple processes! 

IDA also detects opaque predicates from the damage but its approach cannot identify the exact superfluous branch, [which allows for the creation of stealthier opaque predicates](https://yellowbyte.github.io/blog/2018/the_return_of_disassembly_desynchronization/).

There are two main types of damage resulting from opaque predicates: code bloat or disassembly desynchronization. __Current implementation focuses on detecting opaque predicates when the damage is disassembly desynchronization__. Disassembly desynchronization is a umbrella term for obfuscation techniques that disrupt static disassembly by the creative placement of junk bytes (random data bytes) into the instruction stream such that a disassembler will parse those junk bytes as code instructions. In the case of an opaque predicate, junk bytes are inserted into the target basic block of the opaque predicate's superfluous branch. To identify opaque predicates' superfluous branches, we analyze each conditional branch's outgoing basic blocks for __illogical behaviors__ (which can manifest from code instructions that are actually junk bytes). Note that identifying the superfluous branch will allow us to trace back to the offending opaque predicate.

Future work will look into detecting opaque predicates when the damage is code bloat.

## Identifying Illogical Behaviors
We have a set of rules that checks if a basic block contains the damage performed by opaque predicates. Essentially, the damage translates to illogical code behaviors since current approach is limited to detecting opaque predicates when the damage is [disassembly desynchronization](https://github.com/yellowbyte/reverse-engineering-reference-manual/blob/master/contents/anti-analysis/Anti-Disassembly.md#-disassembly-desynchronization-). 

The names we used for the rules in the [paper](https://archive.bar/pdfs/bar2020-preprint4.pdf) compared to the code are not the same. This means that annoyance might arise if one tries to match a rule described in paper to its actual implementation. 

Below is a Python Dictionary depicting the relationship between the names in code (dictionary key) vs in paper (dictionary value): 

```python
RULES_RELATIONSHIP = {
    # 'names in code'                   'names in paper'
    'weird_cutoff':                     'abrupt_basic_block_end',
    'prob_of_unimpl':                   'unimplemented_BNILs_percentage',
    'priviledged_instructions':         'privileged_instruction_usage',
    'def_no_use_dep':                   'defined_but_unused',
    'memaccess_self':                   'memory_pointer_constraints',
    'conditional_unused':               'defined_but_unused',
    'stack_pointer_oddity':             'memory_pointer_constraints',
    'crazy_mem_offset':                 'unreasonable_memory_offset',
    'type_discrepency_ptr_in_mult_div': 'memory_pointer_constraints',
    'memaccess_nonexist':               'nonexistence_memory_address',
    'memaccess_src_dest_discrepancy':   'memory_pointer_constraints',
    'call_dest_nonexist':               'nonexistence_memory_address',
    'jmp_dest_nonexist':                'nonexistence_memory_address',
}
```

As seen in the dictionary, it is not a one-to-one relationship. The rule names in code is more fine-grained than the rule names in paper. For example, the 'nonexistence\_memory\_address' rule (in paper) corresponds to 'memaccess\_nonexist', 'call\_dest\_nonexist', and 'jmp\_dest\_nonexist' rules (in code). 

## Detective in Action:
Current implementation is a [BinaryNinja](https://binary.ninja) plugin.

How to run plugin: 
![Plugin Run](whole.png)

Output:
![Plugin Output](current_output.png)

Note that the printed virtual addresses (highlighed in green) are the target addresses of the superfluous branches. (The addresses can easily be changed to the addresses of the opaque conditional statements if desired.)

## Reference \[[link to paper](https://www.ndss-symposium.org/wp-content/uploads/2020/04/bar2020-23004-paper.pdf)\]

    @inproceedings{tungheuristic,
      title={A Heuristic Approach to Detect Opaque Predicates that Disrupt Static Disassembly},
      author={Tung, Yu-Jye and Harris, Ian G}
      booktitle={Proceedings of the NDSS Workshop on Binary Analysis Research},
      year={2020}
    }

__NOTE__: Google Scholar has the incorrect BibTex but unfortunately I cannot update it directly on Google Scholar


```

`__init__.py`:

```py
from .op_detective import (bb_llil_analysis, bb_mlil_analysis, bb_analysis,
                                  get_authentic_bbs, get_non_generic_spec)

from .op_helpers import *
from binaryninja import *

from collections import namedtuple, defaultdict


AnalysisMetadata = namedtuple("AnalysisMetadata", "spec good_bbs")
LOGGING = True  # set to False if don't want logging 


def find_op_setup(bv, status=None):
    """
    Perform necessary setup before core analysis
    """
    # --- LOGGING ---
    if LOGGING:
        # debug is the lowest level == LOG EVERYTHING
        log_to_stdout(LogLevel.DebugLog)
    # --- LOGGING ---

    # maybe binja will find more functions
    # same as following in GUI:
    #     Tools -> Run Analysis Module -> Linear Sweep
    bv.update_analysis_and_wait()

    metadata = AnalysisMetadata(spec=get_non_generic_spec(),
                                good_bbs=get_authentic_bbs(bv))
    analysis = [
        bb_analysis,
        bb_llil_analysis,
        bb_mlil_analysis,
    ]

    (total_patch_locations, total_conds) = find_op(bv, analyses=analysis,
            metadata=metadata, status=status)

    # determine OP authenticity
    identify_authentic_op(total_patch_locations, total_conds, 
                          metadata, bv, patch=True)


class FindOpaqueInBackground(BackgroundTaskThread):
    def __init__(self, bv, msg):
        BackgroundTaskThread.__init__(self, msg, True)
        self.bv = bv

    def run(self):
        find_op_setup(self.bv, self)


def find_opaque_in_background(bv):
    """
    Start `FindOpaqueInBackground`
    """
    background_task = FindOpaqueInBackground(bv, "Finding opaque predicates")
    background_task.start()


PluginCommand.register("Opaque Predicate Detective",
                       "find opaque predicate", find_opaque_in_background)

```

`__main__.py`:

```py
###
### Headless execution of OpaquePredicatesDetective
### ex1: python3 -m OpaquePredicatesDetective [binary]  -o [result file]
### ex2: python3 -m OpaquePredicatesDetective [binary]
###

import sys
import click

from OpaquePredicatesDetective import find_op_setup

from binaryninja import *


@click.command()
@click.argument("filepath")
@click.argument("stats_filepath", required=False)
@click.option("--output", "-o", is_flag=True, help="output to file")
def main(filepath, stats_filepath, output):
    """
    """
    bv = BinaryViewType.get_view_of_file(filepath)
    if bv is None:
        print("Couldn't open {}".format(filepath))
        sys.exit()

    if output:
        log_to_file(LogLevel.InfoLog, stats_filepath)
    else:
        log_to_stdout(LogLevel.InfoLog)

    find_op_setup(bv, status=None)


if __name__ == "__main__":
    main()

```

`op_detective/__init__.py`:

```py
import os
import json

from .rules import *  # noqa: F403, F401

from .utils import *  # noqa: F403, F401

from binaryninja.enums import LowLevelILOperation
from binaryninja.log import log_debug  # noqa: F401


def get_non_generic_spec():
    """Return dictionary of non-generic specifications
       like (isa-specific, compiler-specific)

    Returns:
        dict: <look at non_generic_spec.json for layout>
    """
    # import non-generic readonly data
    path = os.path.join(os.path.dirname(__file__),
                        'non_generic_spec.json')
    with open(path, 'r') as f:
        non_generic_spec = json.load(f)

    assert non_generic_spec is not None
    return non_generic_spec


def bb_analysis(bv, bb, og_bb_start, metadata):
    """Check authenticity of `bb` based on instructions used.

    Args:
        bv (BinaryView): top-level binary view handler. Lots of
                         interesting methods can be accessed.
        bb (BasicBlock): BinaryNinja.BasicBlock object.
        og_bb_start (long): address of where original basic block starts.
        isa_specific_data (dict): None or dictionary containing isa-specific
                                  info. Read in from
                                  "storage/non_generic_spec.json".

    Returns:
        bool: True if content of bb doesn't make sense. False if it's a legit.
    """
    # first bb's instruction; instr.address
    faulting_addr = og_bb_start

    # check if isa is supported. If not, do not run this analysis
    isa_specific_data = metadata.spec['isa'].get(bv.arch.name)

    # result
    alerted_rules = list()

    # rule: weird_cutoff
    if weird_cutoff(bb, bv):
        log_debug(('* weird_cutoff: ' + 'bb start( 0x{0:02X} ) ' +
                  'instr addr( 0x{1:02X} )').format(faulting_addr,
                                                    faulting_addr))
        alerted_rules.append('weird_cutoff')

    # rule: prob_of_unimpl
    if prob_of_unimpl(bb, bv, isa_specific_data):
        log_debug(('* prob_of_unimpl: ' + 'bb start( 0x{0:02X} ) ' +
                  'instr addr( 0x{1:02X} )').format(faulting_addr,
                                                    faulting_addr))
        alerted_rules.append('prob_of_unimpl')

    for instr in bb:

        # rule: priviledged_instructions
        if priviledged_instructions(instr, bv, isa_specific_data):
            log_debug(
                ('* priviledged_instructions: ' + 'bb start( 0x{0:02X} ) ' +
                 'instr addr( 0x{1:02X} )').format(faulting_addr,
                                                   faulting_addr))
            alerted_rules.append('priviledged_instructions')

    return alerted_rules


def bb_mlil_analysis(bv, bb, og_bb_start, metadata):
    """Check authenticity of instructions in MLIL.

    Args:
        bv (BinaryView): top-level binary view handler. Lots of
                         interesting methods can be accessed.
        bb (list): list of MLIL instructions.
        og_bb_start (long): address of where original basic block starts.
        isa_specific_data (dict): None or dictionary containing isa-specific
                                  info. Read in from
                                  "storage/non_generic_spec.json".

    Returns:
        bool: True if content of bb doesn't make sense. False if it's a legit.
    """
    bb = bb2ilbb(bb, 'mlil', bv)
    if not bb:
        return False

    # first bb's instruction; instr.address
    faulting_addr = og_bb_start

    # check if isa is supported. If not, do not run this analysis
    isa_specific_data = metadata.spec['isa'].get(bv.arch.name)

    # result
    alerted_rules = list()

#    # rule: def_no_use_dep
#    if def_no_use_dep(bb, bv, isa_specific_data):
#        log_debug(
#            ('* def_no_use_dep: ' + 'bb start( 0x{0:02X} ) ' +
#             'instr addr( 0x{1:02X} )').format(faulting_addr,
#                                               faulting_addr))
#        alerted_rules.append('def_no_use_dep')

    for instr in bb:

        if instr.operation.name == 'MLIL_STORE':

            # rule: memaccess_self
            if memaccess_self(instr.ssa_form):
                log_debug(
                    ('* memaccess_self: ' + 'bb start( 0x{0:02X} ) ' +
                     'instr addr( 0x{1:02X} )').format(faulting_addr,
                                                       instr.address))
                alerted_rules.append('memaccess_self')

#        # rule: conditional_unused
#        if conditional_unused(instr):
#            log_debug(
#                ('* conditional_unused: ' + 'bb start( 0x{0:02X} ) ' +
#                 'instr addr( 0x{1:02X} )').format(faulting_addr,
#                                                   instr.address))
#            alerted_rules.append('conditional_unused')

    return alerted_rules


def bb_llil_analysis(bv, bb, og_bb_start, metadata):
    """Check authenticity of instructions in LLIL.

    Args:
        bv (BinaryView): top-level binary view handler. Lots of
                         interesting methods can be accessed.
        bb (list): list of LLIL instructions.
        og_bb_start (long): address of where original basic block starts.

    Returns:
        bool: True if content of bb doesn't make sense. False if it's a legit.
    """
    bb = bb2ilbb(bb, 'llil', bv)
    if not bb:
        return False

    isa_specific_data = metadata.spec['isa'].get(bv.arch.name)

    # first bb's instruction; instr.address
    faulting_addr = og_bb_start

    # result
    alerted_rules = list()

    for instr in bb:

        # rule: stack_pointer_oddity
        if stack_pointer_oddity(instr, bv, isa_specific_data):
            log_debug(
                ('* stack_pointer_oddity: ' + 'bb start( 0x{0:02X} ) ' +
                 'instr addr( 0x{1:02X} )').format(faulting_addr,
                                                   instr.address))
            alerted_rules.append('stack_pointer_oddity')

        # rule: crazy_mem_offset
        if crazy_mem_offset(instr.ssa_form, bv):
            log_debug(
                ('* crazy_mem_offset: ' + 'bb start( 0x{0:02X} ) ' +
                 'instr addr( 0x{1:02X} )').format(faulting_addr,
                                                   instr.address))
            alerted_rules.append('crazy_mem_offset')

        # rule: type_discrepency_ptr_in_mult_div
        if type_discrepency_ptr_in_mult_div(instr):
            log_debug(
                ('* type_discrepency_ptr_in_mult_div: ' + 'bb start( 0x{0:02X} ) ' +
                 'instr addr( 0x{1:02X} )').format(faulting_addr,
                                                   instr.address))
            alerted_rules.append('type_discrepency_ptr_in_mult_div')

        if instr.operation == LowLevelILOperation.LLIL_STORE:

            # rule: memaccess_nonexist
            if memaccess_nonexist(instr, bv):
                log_debug(
                    ('* memaccess_nonexist: ' + 'bb start( 0x{0:02X} ) ' +
                     'instr addr( 0x{1:02X} )').format(faulting_addr,
                                                       instr.address))
                alerted_rules.append('memaccess_nonexist')

            # rule: memaccess_src_dest_discrepancy
            if memaccess_src_dest_discrepancy(instr, bv):
                log_debug(
                    ('* memaccess_src_dest_discrepancy: ' +
                     'bb start( 0x{0:02X} ) ' +
                     'instr addr( 0x{1:02X} )').format(faulting_addr,
                                                       instr.address))
                alerted_rules.append('memaccess_src_dest_discrepancy')

        if instr.operation == LowLevelILOperation.LLIL_CALL:

            # rule: call_dest_nonexist
            if call_dest_nonexist(instr, bv):
                log_debug(
                    ('* call_dest_nonexist: ' + 'bb start( 0x{0:02X} ) ' +
                     'instr addr( 0x{1:02X} )').format(faulting_addr,
                                                       instr.address))
                alerted_rules.append('call_dest_nonexist')

        # rule: jmp_dest_nonexist
        if instr.operation == LowLevelILOperation.LLIL_JUMP:
            if jmp_dest_nonexist(instr, bv):
                log_debug(
                    ('* jmp_dest_nonexist: ' + 'bb start( 0x{0:02X} ) ' +
                     'instr addr( 0x{1:02X} )').format(faulting_addr,
                                                       instr.address))
                alerted_rules.append('jmp_dest_nonexist')
    return alerted_rules

```

`op_detective/non_generic_spec.json`:

```json
{
    "isa": {
        "x86": {
            "privileged_instructions": [
                "ins",
                "insb",
                "insw",
                "insd",
                "ins",
                "insb",
                "insw",
                "insd",
                "in",
                "out",
                "hlt",
                "cli",
                "sti"
            ],
            "common_unlifted_instructions": [
                "fldcw",
                "fnstcw"
            ],
            "incorrectly_lifted_instructions": [
                "rep cmpsb"
            ],
            "stack_pointers": [
                "ebp",
                "esp"
            ],
            "return_values": [
                "eax"
            ]
        },
        "x86_64": {
            "stack_pointers": [
                "rbp",
                "rsp"
            ],
            "return_values": [
                "rax"
            ]
        }
    }
}

```

`op_detective/rules/__init__.py`:

```py
from __future__ import division

import toolz
import operator

from .llil_rules import *  # noqa: F403, F401
from .mlil_rules import *  # noqa: F403, F401
from binaryninja.log import log_debug  # noqa: F401

from ..utils import bb2ilbb


def prob_of_unimpl(bb, bv, isa_specific_data):
    """
    """
#    log_debug('[prob_of_unimpl]: enter '+hex(bb.start))
    if not isa_specific_data or not \
            isa_specific_data.get('common_unlifted_instructions'):
        # or else could lead to high FP rate
        return False

    ok_unlifted_instructions = isa_specific_data['common_unlifted_instructions']
    addr2ignore = list()
    cur_addr = bb.start
    for instr in bb:
#        log_debug('[prob_of_unimpl]: cur instr '+instr[0][0])
        if str(instr[0][0]) in ok_unlifted_instructions:
            addr2ignore.append(cur_addr)
        cur_addr += instr[1]

    unimpl = 0
    llil_bb = bb2ilbb(bb, 'llil', bv)

    for instr in llil_bb:
        if instr.address in addr2ignore:
            continue
        if instr.operation.value in [81, 82]:
            # 81, 82 = LLIL_UNIMPL, LLIL_UNIMPL_MEM
            unimpl += 1

#    log_debug('[prob_of_unimpl]: addr2ignore '+str(addr2ignore))
#    log_debug('[prob_of_unimpl]: va '+str(bb.instruction_count))
#    log_debug('[prob_of_unimpl]: unimpl '+str(unimpl))
    if unimpl and ((unimpl/bb.instruction_count) >= .2):
        return True
    return False


def bb_start_overlapped(bb, bv):
    """
    """
    bbs = bv.get_basic_blocks_at(bb.start)
    overlapped_bbs = list(toolz.unique(bbs, operator.attrgetter('start')))
    if len(overlapped_bbs) > 1:
        return True
    return False


def priviledged_instructions(instr, bv, isa_specific_data):
    """
    """
    if not isa_specific_data:
        return False
    if isa_specific_data and isa_specific_data.get('privileged_instructions'):
        if instr[0][0].text in isa_specific_data['privileged_instructions']:
            return True
    return False


def weird_cutoff(bb, bv):
    """
    """
#    log_debug('[weird_cuttoff]: enter '+hex(bb.start))

    mlil_bb = bb2ilbb(bb, 'mlil', bv)
    if not mlil_bb:
        return False
    if mlil_bb[-1].operation.name == 'MLIL_UNDEF':
        # disassembly is quick to self-repair
        return True

    # basic block neighbors data bytes
    # and does not end in control-transferring instruction
    if not bb.function.llil.get_instruction_start(bb.end):
        op_code = mlil_bb[-1].operation.value
        if op_code not in range(48, 59) and \
                op_code not in range(74, 76):
            return True
    return False

```

`op_detective/rules/helpers/__init__.py`:

```py
from .llil_helpers import *  # noqa: F401, F403
from .mlil_helpers import *  # noqa: F401, F403

from binaryninja import *


def instr_with_addr_in_bb(bb, addr):
    """

    Return list of instructions in `bb` that have the virtual address `addr`

    Args:
        bb: a BasicBlock object
        addr: virtual address

    Returns:
        list of instructions
    """
    shared_addr = list()
    log_debug('[instr_with_addr_in_bb]: bb type '+str(bb))
    for instr in bb:
        log_debug('[instr_with_addr_in_bb]: cur instr '+str(instr))
        if instr.address == addr:
            shared_addr.append(instr)
    return shared_addr

```

`op_detective/rules/helpers/llil_helpers.py`:

```py
from operator import attrgetter
from collections import namedtuple

from binaryninja import *


class Tree(object):
    """AST Tree

    Args:
        llil_type (str): ex., LLIL_ADD, LLIL_IF
        llil_data (long): ex., for type long, store actual value
        childs (list): list of Tree objects
        indent (int): number of spaces to use when pretty-printing Tree object

    Attributes:
        llil_type (str): ex., LLIL_ADD, LLIL_IF
        llil_data (long): ex., for type long, store actual value
        childs (list): list of Tree objects
        _indent (int): number of spaces to use when pretty-printing Tree object
    """
    def __init__(self, llil_type=None, llil_data=None, childs=None, indent=2):
        self.llil_type = llil_type
        self.llil_data = llil_data
        self.childs = list()
        self._indent = indent
        if childs is not None:
            for child in childs:
                self.add_child(child)

    def add_child(self, node):
        """Add child to Tree object

        Args:
            node (Tree): child to be added
        """
        assert isinstance(node, Tree)
        self.childs.append(node)

    def traverse(self):
        """Pretty-print current Tree object
        """
        def traverse_helper(tree, level=0):
            log_debug(' ' * (level) + tree.llil_type)
            if tree.childs:
                for child in tree.childs:
                    traverse_helper(child, level + 1)

        traverse_helper(tree=self, level=self._indent)


def match_tree(potential_il_tree, og_il_tree):
    """Check if `potential_il_tree` is a subtree of `og_il_tree`.

    wrt. the following special cases:
        llil_type = 'X': free pass. Node can contain anything
        llil_type = 'F': fill in
                         if llil_type == 'long', fill in data to llil_data

    Args:
        potential_il_tree (Tree): self-constructed Tree
        og_il_tree (Tree): Tree created from llil2tree

    Returns:
        bool: True if `potential_il_tree` is a subtree of `og_il_tree`,
              else False.
    """
    # llil_type at respective tree node does not match
    if (potential_il_tree.llil_type != 'X'
            and potential_il_tree.llil_type != 'F') \
            and (potential_il_tree.llil_type != og_il_tree.llil_type):
        return False

    # special case: 'F'
    if potential_il_tree.llil_type == 'F':
        if og_il_tree.llil_type == 'long':
            potential_il_tree.llil_type = og_il_tree.llil_data
        else:
            potential_il_tree.llil_type = og_il_tree.llil_type

    # recurse: BFS
    for i, child in enumerate(potential_il_tree.childs):
        # special case: 'X'
        if child.llil_type == 'X':
            continue
        return True and match_tree(child, og_il_tree.childs[i])
    return True


def llil2tree(il, tree):
    """Create Tree object in `tree` from `il`.

    Args:
        il (LowLevelILInstruction): llil instruction object.
        tree (Tree): Tree object.

    Returns:
        None: output in arg `tree`.
    """
    # root
    if not tree.llil_type:
        tree.llil_type = get_llil_str(il)

    # recurse
    if isinstance(il, LowLevelILInstruction):
        il_ops = il.operands

        for child_il in il_ops:
            # create and add subtree
            cur_type = get_llil_str(child_il)
            if cur_type == 'long':
                cur_node = Tree(llil_type=cur_type, llil_data=child_il)
            else:
                cur_node = Tree(llil_type=cur_type)
            tree.add_child(cur_node)

        # recurse on all subtrees
        for i, tree_node in enumerate(tree.childs):
            # list is positional. works out
            llil2tree(il_ops[i], tree_node)


def contain_type(il, llil_type, val, temp=[]):
    """Check if LowLevelILInstruction `il` contains expression `il_type`
       of value `val`.

    ex: llil_type = LowLevelILInstruction. val = 'ILRegister'.
    ex: llil_type = ILRegister. val = 'eax'.
    ex: llil_type = long. val = 'long'.

    Args:
        il (LowLevelILInstruction): llil instruction object.
        llil_type
            (LowLevelILInstruction, ILRegister, long): objects that made up of
                                                       LowLevelILInstruction.
        val (str): objects that made up of LowLvelILInstruction in string.
        result (list): final output list containing objects of
                       type `llil_type`.

    Returns:
        bool: True if `il` contains expression `il_type` of value `val`,
              else False.
    """
    if isinstance(il, LowLevelILInstruction):
        temp.extend(il.operands)
    if isinstance(il, llil_type):
        if get_llil_str(il) == val:
            return True
    while temp:
        cur_il = temp.pop()
        return True and contain_type(cur_il, llil_type, val, temp)
    return False


def get_type(il, llil_type, val, result=[], method='__str__'):
    """Return list of `llil_type` that exists in `il` with `val`.

    ex: llil_type = LowLevelILInstruction. val = 'ILRegister'.
    ex: llil_type = ILRegister. val = 'eax'.
    ex: llil_type = long. val = 'long'.

    Args:
        il (LowLevelILInstruction): llil instruction object.
        llil_type
            (LowLevelILInstruction, ILRegister, long): objects that made up of
                                                       LowLevelILInstruction.
        val (str): objects that made up of LowLvelILInstruction in string.
        result (list): final output list containing objects of
                       type `llil_type`.

    Returns:
        None: result in arg `result`.
    """
    if isinstance(il, llil_type):
        if attrgetter(method)(il) == val:
            result.append(il)
    if isinstance(il, llil_type):
        for o in il.operands:
            get_type(o, llil_type, val, result=result, method=method)


def get_llil_str(il):
    """Retrieve corresponding string from llil object.

    Args:
        il (LowLevelILInstruction): llil instruction object.

    Returns:
        str: string representation for that llil object.
             (1) LowLevelILInstruction (string).
             (2) ILRegister (string).
             (3) builtin long (string).
    """
    if isinstance(il, LowLevelILInstruction):
        value = il.operation.name
    elif isinstance(il, ILRegister):
        value = str(il)
    else:
        value = 'long'  # else type long
    return value

```

`op_detective/rules/helpers/mlil_helpers.py`:

```py
from binaryninja import *


def is_instr_set_flag(instr):
    """
    """
    # semantic model of a flag
    if not isinstance(instr.dest, SSAVariable):
        return False
    # checking for semantic model of a flag
    ssa_var = instr.dest
    var_name = ssa_var.var.name.split('#')[0]
    if '_' in var_name:
        var_name = var_name.split('_')[0]

    for possible_var in instr.vars_read:
        if hasattr(possible_var, 'var'):
            if possible_var.var.name.startswith(var_name):
                prev_var_ver = possible_var
                break
    else:
        return False
    usages = instr.function.get_ssa_var_uses(prev_var_ver)

    # usage in `instr` and to assign a temp var
    if not any([u for u in usages if u.address == instr.address]):
        return False

    for u in usages:
        if u.address != instr.address:
            continue
        if hasattr(u, 'dest') and isinstance(u.dest, SSAVariable) and \
                u.dest.var.name.startswith('temp'):
            return True

    return False


def is_reg_reassigned_in_bb(cur_func, cur_index, reg_value):
#    log_debug('[is_reg_reassigned_in_bb]: enter '+str(cur_func))
    cur_instr = cur_func.ssa_form[cur_index]
    # instr at index is not
    # last instr of bb
    while (cur_instr.operation.value not in
            [58, 57, 48, 49, 50, 55, 74, 75, 56]):
        # check if current instruction is an assignment to `reg_value`
        # and is not a PHI operation
        if cur_instr.operation.name == 'MLIL_SET_VAR_SSA' and \
                isinstance(cur_instr.dest, SSAVariable):
            if cur_instr.dest.var.source_type.value == 1 and \
                    cur_instr.dest.var.storage == reg_value:
                # reg is used again
                return True
        cur_index += 1
#        log_debug('[is_reg_reassigned_in_bb]: cur_index '+str(cur_index)+' '+'cur_func: '+str(cur_func))
        try:
            cur_instr = cur_func.ssa_form[cur_index]
        except:
            return False
    return False


def is_reg_no_longer_used(ssa_var, instr):
    """Return if it is final variable version used in function that is not part of
    a PHI operation
    """
    # not live. But is it the final used version?
    # NOTE: need to be llil since we do not care
    # about var memory version
    # loop through each basic block
    # check version of register at end
    # if version is greater, check usages
    # if just PHI operation, ignore
    # else, it is not live
    # NOTE: subsequent usage do not always increment version by 1
    if ssa_var.var.source_type.value != 1: # make sure it is RegisterVariableSourceType
        return False
    reg_value = ssa_var.var.storage
    cur_index = instr.instr_index + 1
    cur_func = instr.function
    cur_bb = instr.il_basic_block
    analysis_queue = list()
    seen = set()

    if is_reg_reassigned_in_bb(cur_func, cur_index, reg_value):
        return False
    analysis_queue.extend(cur_bb.outgoing_edges)
    seen.add(cur_bb)

    while len(analysis_queue) != 0:
        cur_bb = analysis_queue.pop(0).target
        cur_index = cur_bb[0].instr_index
        if is_reg_reassigned_in_bb(cur_func, cur_index, reg_value):
            return False

        if cur_bb.outgoing_edges and cur_bb not in seen:
            analysis_queue.extend(cur_bb.outgoing_edges)
            seen.add(cur_bb)
    return True

```

`op_detective/rules/llil_rules.py`:

```py
from .helpers import contain_type, get_type, match_tree, llil2tree, Tree

from binaryninja.enums import LowLevelILOperation, RegisterValueType
from binaryninja.lowlevelil import (LowLevelILInstruction, ILRegister)
from binaryninja.log import log_debug


def stack_pointer_oddity(instr, bv, isa_specific_data):
    """
    (1) stack pointer should not be assigned a constant
    (2) in a memory operation (LLIL_LOAD), stack pointer should only be
        in LLIL_ADD or LLIL_SUB
    (3) usage of stack pointer should be in a memory access
    """
    log_debug("[stack_pointer_oddity]: entry "+hex(instr.address))

    # ignore stack pointer usages relating to function prologue/epilogue
    if not instr.function.get_medium_level_il_instruction_index(instr.instr_index):
        return False

    # ignore stack pointer operations for restoring stack frame
    if instr.il_basic_block[-1].operation.value in [57, 58]:
        return False

    # ignore instructions that are not completely lifted
    if instr.operation.name == 'LLIL_UNIMPL_MEM':
        return False

    stack_ptrs = list()
    if not isa_specific_data:
        stack_ptrs = isa_specific_data['stack_pointers']
    else:
        stack_ptrs.append(bv.arch.stack_pointer) 
    for stack_ptr in stack_ptrs:
        if not contain_type(instr, ILRegister, stack_ptr, temp=[]):
            continue
        log_debug("[stack_pointer_oddity]: contain_type({}, {}, {}) "
            .format(str(instr), str(ILRegister), str(stack_ptr)))
        log_debug("[stack_pointer_oddity]: contains stack_ptr "+str(stack_ptr))

        # check for memory access with stack pointer
        stack_semantics_add = list()
        stack_semantics_load = list()
        stack_semantics_store = list()
        get_type(instr, LowLevelILInstruction,
                 'LLIL_ADD', stack_semantics_add, 'operation.name')
        get_type(instr, LowLevelILInstruction,
                 'LLIL_STORE', stack_semantics_store, 'operation.name')
        get_type(instr, LowLevelILInstruction,
                 'LLIL_LOAD', stack_semantics_load, 'operation.name')
        log_debug("[stack_pointer_oddity]: stack semantics "+str(stack_semantics_add))
        if contain_type(instr, LowLevelILInstruction, 'LLIL_LOAD', temp=[]) or \
                contain_type(instr, LowLevelILInstruction, 'LLIL_STORE', temp=[]):
            # stack pointer used in memory access
            if (not any([il for il in stack_semantics_add if il.left.operation.name == 'LLIL_REG' and il.left.src.name == stack_ptr])) and \
                    (not any([il for il in stack_semantics_store if il.dest.operation.name == 'LLIL_REG' and il.dest.src.name == stack_ptr])) and \
                    (not any([il for il in stack_semantics_load if il.src.operation.name == 'LLIL_REG' and il.src.src.name == stack_ptr])):
                log_debug('[stack_pointer_oddity]: found(1)')
                return True
        # copying stack pointer value is fine
        elif (hasattr(instr, 'dest') and hasattr(instr, 'src') and hasattr(instr.src, 'src') and
                isinstance(instr.dest, ILRegister) and 
                instr.operation.name == 'LLIL_SET_REG' and 
                instr.src.operation.name == 'LLIL_REG' and 
                stack_ptr == instr.src.src.name):
            pass
        else:
            # adding or substracting stack offsets
            # have to take care of 'esp = esp + 4' or 'lea, [esp+0x38]'
            if not (hasattr(instr, 'dest') and hasattr(instr, 'src') and \
                    isinstance(instr.dest, ILRegister) and \
                    instr.src.operation.value in [22, 24] and \
                    stack_ptr in [str(i) for i in instr.src.tokens]):
                # the only other acceptable form: esp = esp + <const>
                # 22, 24 == LLIL_ADD, LLIL_SUB
                log_debug('[stack_pointer_oddity]: found(2) at :'+hex(instr.address))
                return True
    return False


def crazy_mem_offset(instr, bv):
    """
    """
    log_debug("[crazy_mem_offset]: entry "+hex(instr.address))
    # check dest for constant
    if instr.operation.name == 'LLIL_STORE_SSA':
        const_ils = list()
        get_type(instr.dest, LowLevelILInstruction, 'LLIL_CONST',
                 const_ils, 'operation.name')
        log_debug("[crazy_mem_offset]: "+str(const_ils))
        for c in const_ils:
            log_debug("[crazy_mem_offset]: const value "+str(c.value.value))
            if bv.is_offset_readable(c.value.value) or bv.is_offset_writable(c.value.value):
                log_debug("[crazy_mem_offset]: offset is a valid virtual address")
                continue
            # greater than a certain value and less than a certain value
            if c.constant > 0x100000 or c.constant < -0x100000:
                return True

    # check src for constant
    if not hasattr(instr, 'src'):
        return False
    load_ils = list()
    get_type(instr.src, LowLevelILInstruction,
             'LLIL_LOAD_SSA', load_ils, 'operation.name')

    for load_il in load_ils:
        const_ils = list()
        get_type(load_il, LowLevelILInstruction,
                 'LLIL_CONST', const_ils, 'operation.name')
        if not const_ils:
            continue
        for c in const_ils:
            if bv.is_offset_readable(c.value.value) or \
                    bv.is_offset_writable(c.value.value):
                log_debug("[crazy_mem_offset]: offset is a valid virtual address")
                continue
            # greater than a certain value and less than a certain value
            if c.constant > 0x100000 or c.constant < -0x100000:
                return True
    return False


def type_discrepency_ptr_in_mult_div(instr):
    """
    """
    log_debug("[type_discrepency_ptr_in_mult_div]: entry "+hex(instr.address))
    # check if it is multiply or division operation
    if instr.operation.name != 'LLIL_SET_REG':
        return False
    if instr.src.operation.value not in range(36, 43):
        # division and multiply values
        # LLIL_MUL, LLIL_MULU_DP, LLIL_MULS_DP, LLIL_DIVU
        # LLIL_DIVU_DP, LLIL_DIVS, LLIL_DIVS_DP
        return False

    # check if reg is also used as memory pointer
    # reg_oi: register of interest
    reg_oi = instr.ssa_form.dest
    if isinstance(reg_oi, ILRegister):
        return False
    log_debug("[type_discrepency_ptr_in_mult_div]: reg_io "+repr(reg_oi)+" at "+hex(instr.address))
    for reg_use_il in instr.function.get_ssa_reg_uses(reg_oi):
        # dereference in destination
        mem_dest_struct = Tree(
            llil_type='LLIL_STORE',
            childs=[Tree(llil_type='LLIL_REG', childs=[Tree(llil_type='F')])])
        # dereference in source
        mem_src_struct = Tree(
            llil_type='LLIL_LOAD',
            childs=[Tree(llil_type='LLIL_REG', childs=[Tree(llil_type='F')])])

        # check for dereference in destination
        llil_tree = Tree()
        llil2tree(reg_use_il, llil_tree)
        if ((match_tree(mem_dest_struct, llil_tree) and
                mem_dest_struct.childs[0].childs[0].llil_type == str(reg_oi.reg))):
            if reg_use_il.size == 1:
                # memory access size is same as counter size. So, it is okay
                return False
            return True

        # check for dereference in source
        if not hasattr(reg_use_il, 'src'):
            return False
        llil_tree = Tree()
        llil2tree(reg_use_il.src, llil_tree)
        if ( (match_tree(mem_src_struct, llil_tree) and
                mem_src_struct.childs[0].childs[0].llil_type == str(reg_oi.reg)) ):
            load_ils = list()
            get_type(reg_use_il.src, LowLevelILInstruction,
                     'LLIL_LOAD', load_ils, 'operation.name')
            for li in load_ils:
                if li.dest.reg == reg_oi.reg and li.size == 1:
                    return False
            return True
    return False


def jmp_dest_nonexist(instr, bv):
    """Check if jump destination is in mapped address space.

    Args:
        instr (LowLevelILInstruction): llil instruction object.
        bv (BinaryView): top-level binary view handler. Lots of
                         interesting methods can be accessed.

    Returns:
        bool: True if jump destination is not in mapped address space,
              else False.
    """
    if not instr.dest.operation == LowLevelILOperation.LLIL_CONST_PTR:
        return False
    return not bv.is_offset_executable(instr.dest.value.value)


def memaccess_src_dest_discrepancy(instr, bv):
    """Check that memory access on an instruction level is authentic.

    (1) memory pointer not stored in register of correct size.
    (2) memory pointer value accessed in a register of smaller size.

    Args:
        instr (LowLevelILInstruction): llil instruction object.
        bv (BinaryView): top-level binary view handler. Lots of
                         interesting methods can be accessed.

    Returns:
        bool: True if memory access is not authentic, else False.
    """
    llil_tree = Tree()
    llil2tree(instr, llil_tree)
    # create structure we want to match against `llil_tree`
    matching_struct = Tree(
        llil_type='LLIL_STORE',
        childs=[Tree(llil_type='LLIL_REG', childs=[Tree(llil_type='F')])])
    if not match_tree(matching_struct, llil_tree):
        return False

    dest_reg = matching_struct.childs[0].childs[0].llil_type
    if bv.arch.regs[dest_reg].full_width_reg != dest_reg:
        return True

    regs_in_il = list()
    get_type(instr, LowLevelILInstruction, 'ILRegister', result=regs_in_il)
    for reg in regs_in_il:
        reg_name = bv.arch.get_reg_name(reg.index)
        if bv.arch.regs[reg_name].size != bv.arch.address_size and \
                bv.arch.regs[reg_name].full_width_reg == dest_reg:
            return True
    return False


def memaccess_nonexist(instr, bv):
    """Check if instruction is accessing memory that does not exist.

    Args:
        instr (LowLevelILInstruction): llil instruction object.
        bv (BinaryView): top-level binary view handler. Lots of
                         interesting methods can be accessed.

    Returns:
        bool: True if instruction is accessing nonexistent memory, else False.
    """
    if not contain_type(instr.dest, LowLevelILInstruction, 'LLIL_CONST_PTR', temp=[]):
        return False
    if instr.dest.value.type == RegisterValueType.UndeterminedValue:
        return False
    if contain_type(instr.dest, LowLevelILInstruction, 'LLIL_REG', temp=[]):
        return False
    if instr.dest.value.type == RegisterValueType.StackFrameOffset:
        return False
    if not bv.is_offset_writable(instr.dest.value.value):
        return True
    return False


def call_dest_nonexist(instr, bv):
    """Check if destination of CALL exists in address space.

    Args:
        instr (LowLevelILInstruction): llil instruction object.
        bv (BinaryView): top-level binary view handler. Lots of
                         interesting methods can be accessed.

    Returns:
        bool: True if instruction is accessing nonexistent memory, else False.
    """
    if instr.dest.value.type == RegisterValueType.UndeterminedValue:
        return False
    if contain_type(instr, LowLevelILInstruction, 'LLIL_REG', temp=[]):
        return False
    if not bv.get_function_at(instr.dest.value.value):
        return True
    return False

```

`op_detective/rules/mlil_rules.py`:

```py
from __future__ import division

from .helpers import (is_instr_set_flag,
                     is_reg_no_longer_used,
                     instr_with_addr_in_bb)

from .llil_rules import call_dest_nonexist

from binaryninja import *
from binaryninja.log import log_debug  # noqa: F401


def is_not_final_rv(var, instr):
    if instr.function.is_ssa_var_live(var):
        return False

    # return value will not have usage, but make sure it is the final version
    # instructions returned from `get_ssa_var_uses` is only the il of the og 
    # instruction at the address it will not include PHI operation. We can use 
    # this to simulate `is_ssa_var_live`, which we cannot use since there is no 
    # way to differentiate final version of return value
    if hasattr(var, 'var'):
        if not is_reg_no_longer_used(var, instr):
            return True
    return False


def conv2s32(n):
    return ((n & 0xffffffff) ^ 0x80000000) - 0x80000000


def def_no_use_dep(bb, bv, isa_specific_data):
    """Check if register (except return value) assigned value but not used.

    Args:
        instr (MediumLevelILInstruction): mlil instruction object.
        bv (BinaryView): top-level binary view handler. Lots of
                         interesting methods can be accessed.
        isa_specific_data (dict): None or dictionary containing isa-specific
                                  info. Read in from
                                  "storage/non_generic_spec.json"

    Returns:
        bool: True if register assigned value but not used, else False.
    """
    log_debug("enter def_no_use_dep: "+hex(bb[0].address))

    # Early Exit
    # skip analysis if basic block contains unimplemented instructions
    # unimplemented can be the source for why variable usage is not found
    if any([i for i in bb if i.operation.value in [81, 82]]):
        # 81, 82 == 'MLIL_UNIMPL', 'MLIL_UNIMPL_MEM'
        return False

    # Early Exit
    # if no outgoing edges or ret instruction/tail call,
    # ignore bb for analysis
    if bb[-1].operation.value in [50, 55, 74, 75, 56]:
        return False
    if len(bb[-1].il_basic_block.outgoing_edges) == 0:
        return False

    # Special Exception
    # (1) some native instructions can be splitted into multiple instructions
    #     in a different BinaryNinja il
    # (2) keep track of last function call in basic block to ignore later
    #     since sometimes binja does not correctly identify function parameter,
    #     leading to FP
    # (3) some instructions are incorrectly lifted. Keep basic blocks containing
    #     those instructions
    addrs_to_skip = list()
    incorrectly_lifted = isa_specific_data.get('incorrectly_lifted_instructions')
    if not incorrectly_lifted:
        incorrectly_lifted = list()
    for instr in bb:

        # Early Exit
        # check for incorrectly lifted instructions
        native_instr = bv.get_disassembly(instr.address)
        if native_instr:
            for i in incorrectly_lifted:
                if native_instr.startswith(i):
                    return False

        instr = instr.ssa_form
        # assignment to multiple variables. Some will prob not be used
        # ex: IMUL where dividend is put in edx and leftover is put in eax
        #     and sometimes leftover is never looked at
        if instr.operation.name == 'MLIL_SET_VAR_SPLIT_SSA':
            addrs_to_skip.append(instr.address)

        # skip instruction where its source contains
        # MLIL_VAR_SPLIT_SSA variable
        if hasattr(instr, 'src') and  \
                hasattr(instr.src, 'prefix_operands') and  \
                MediumLevelILOperation.MLIL_VAR_SPLIT_SSA in instr.src.prefix_operands:
            addrs_to_skip.append(instr.address)

        if hasattr(instr, 'operation') and \
                instr.operation.value in [51, 53, 122, 54, 121, 115, 52, 116]:
            if not call_dest_nonexist(instr.llil.non_ssa_form, bv):
                # authentic CALL instruction exists
                # push and pop is common before or after function call
                return False

    for instr in bb:
        # changed to ssa form
        instr = instr.ssa_form
        log_debug('[def_no_use_dep]: current instr: '+str(instr))

        if instr.address in addrs_to_skip:
            continue

        # no data written
        if not instr.vars_written:
            continue

        # ignore check for callee's return value
        if instr.operation.name == 'MLIL_CALL_SSA':
            # return value from subroutine may not always be used
            continue

        # for variable involved in PUSH/POP, check if src variable is used
        # the destination of POP instruction will naturally not be live
        if instr.operation.name == 'MLIL_SET_VAR_ALIASED' and instr.src.operation.name == 'MLIL_ADDRESS_OF' and \
                len(instr.vars_read) == 1:
            # authentic stack access because it is aliased
            continue
        if (instr.operation.name == 'MLIL_SET_VAR_SSA' or instr.operation.name == 'MLIL_SET_VAR_ALIASED') and \
                (instr.src.operation.name == 'MLIL_VAR_SSA' or instr.src.operation.name == 'MLIL_LOAD_SSA') and \
                len(instr.vars_read) == 1:
            log_debug('[def_no_use_dep]: possible PUSH/POP')
            # POP semantic
            if (not instr.function.is_ssa_var_live(instr.dest)) and len(instr.vars_read) == 1 and instr.src.operation.name == 'MLIL_LOAD_SSA':
                log_debug('[def_no_use_dep]: filter usages list')
                usages = instr.function.get_ssa_var_uses(instr.vars_read[0])
                usages_wo_phi = list()
                log_debug('[def_no_use_dep]: usages: '+str(usages))
                log_debug('[def_no_use_dep]: first usage: '+str(usages[0].operation.name))
                for u in usages:
                    if u.operation.name != 'MLIL_VAR_PHI':
                        usages_wo_phi.append(u)
                log_debug('[def_no_use_dep]: usages_wo_phi: '+str(usages_wo_phi))
                if len(set([i.address for i in usages_wo_phi])) == 1:
                    log_debug('[def_no_use_dep]: (mlil) POP not live '+hex(instr.address))
                    return True
            # PUSH semantic (catch PUSHAD, PUSHFD)
            # catching only PUSH is hard since sometimes push for function arg is not recognized
            if (not instr.function.is_ssa_var_live(instr.dest)) and \
                    len(instr.vars_read) == 1 and \
                    instr.dest.var.name.startswith('var'):
                # PUSH looks just like stack access. Catch PUSHAD/PUSHFD
                same_va_instrs = instr_with_addr_in_bb(bb, instr.address)
                same_va_instrs_push_semantics = True 
                log_debug('[def_no_use_dep]: same_va_instrs '+str(same_va_instrs))
                for i in same_va_instrs:
                    if (len(i.vars_read) != 1) or (not i.dest.name.startswith('var')):
                        same_va_instrs_push_semantics = False
                if same_va_instrs_push_semantics and len(same_va_instrs) > 1:
                    log_debug('[def_no_use_dep]: (mlil) PUSH not live '+hex(instr.address))
                    return True
            # current PUSH/POP instruction looks good. Next!
            continue

        ### CHECK VARIABLE LIVENESS ###
        # for each var that is overwritten, check if it is live
        if isa_specific_data and isa_specific_data.get('return_values'):
            rvs = isa_specific_data['return_values']
        else:
            rvs = instr.function.source_function.return_regs
        assert len(rvs) == 1
        rv = rvs[0]
        for var in instr.vars_written:
            log_debug('[def_no_use_dep]: (mlil) current var '+str(var))

            # setting var to 0 or 1 or -1 or small constant for no good reason seems to be
            # a thing. Bad compiler optimization? As a result, ignore
            # instruction that simply set rv to 9 (e.g. xor eax, eax)
            if isinstance(instr.dest, SSAVariable):
                if hasattr(instr.src, 'value') and \
                        hasattr(instr.src.value, 'value'):
                    if instr.src.value.is_constant:
                        const_value = conv2s32(instr.src.value.value)
                        log_debug('[def_no_use_dep]: current const value '+hex(const_value))   
                        if const_value >= -1 and const_value <= 100:
                            log_debug('[def_no_use_dep]: (mlil) current var skipped at setting const')
                            continue

            # stack variables heuristics
            if var.var.name.startswith('var'):
                stack_vars = instr.function.source_function.get_stack_vars_referenced_by(instr.address)
                # filter to stack offset with ebp/esp
                # ex: [<ref to var_ac>, <operand 0 ref to var_88>]
                # first is a var to pushed arg and second is a var to ebp offset
                stack_vars = [sv for sv in stack_vars if sv.source_operand is not None]
                if any([sv for sv in stack_vars if sv.var.name == var.var.name]):
                    log_debug('[def_no_use_dep]: (mlil) current var skipped at stack variables heuristics')
                    continue

            # (1) stuff written to stack pointer logically might not be used again
            # (2) binja has mis-identified function as not taking any parameter when in fact it does, leading to
            #     FP 'def_no_use_dep'  rule
            # (3) instruction is not live but used to set flag(s). If so, ignore
            log_debug('[def_no_use_dep] liveness: '+str(instr.function.is_ssa_var_live(var))+' for '+str(var)+' at '+hex(instr.address))
            if not var.var.name.startswith(rv):
                if not instr.function.is_ssa_var_live(var) and not \
                        var.var.name.startswith(
                        bv.arch.stack_pointer) and \
                        not is_instr_set_flag(instr): # and \
                    if var.var.name.startswith('arg'):
                        continue
                    elif var.var.name.startswith('var'):
                        log_debug('[def_no_use_dep]: found(1) '+str(var)+' '+hex(instr.address)+' '+hex(instr.il_basic_block[0].address))
                        return True
                    else: 
                        if is_not_final_rv(var, instr):
                            log_debug('[def_no_use_dep]: found(2) '+str(var)+' '+hex(instr.address)+' '+hex(instr.il_basic_block[0].address))
                            return True
            else:  # return value heuristic
                if not instr.function.is_ssa_var_live(var) and \
                        is_not_final_rv(var, instr) and \
                        not is_instr_set_flag(instr):
                    log_debug('[def_no_use_dep]: found(3) '+str(var)+' '+hex(instr.address)+' '+hex(instr.il_basic_block[0].address))
                    return True
    log_debug('[def_no_use_dep]: did not alert def_no_use_dep')
    return False


def memaccess_self(instr):
    """Check if register used as pointer but also stored its ptr address to itself.

    Args:
        instr (MediumLevelILInstruction): mlil instruction object.

    Returns:
        bool: True if register used as pointer but also stored its ptr address
              to itself, else False.
    """
    log_debug("enter memaccess_self: "+hex(instr.address))
    # get vars read at destination
    # get vars used in memory access
    dest_vars_read = [
        i.var.name for i in instr.dest.vars_read if hasattr(i, 'var')
    ]
    if not dest_vars_read:
        return False
    log_debug("[memaccess_self] dest_vars_read: "+str(dest_vars_read))

    # get vars read at src that is not part of memory load
    # vars in src operands that are not a part of memory load!
    src_vars_read = list()
    # (1) check if it is a mov instruction for a subregister
    if instr.src.operation.name in ['MLIL_CONST', 'MLIL_VAR_SSA', 'MLIL_VAR_SSA_FIELD']:
        if instr.src.operation.name == 'MLIL_VAR_SSA_FIELD':
            src_vars_read.append(instr.src.src)
    # (2) heuristic for all other instructions
    else:
        for operand in instr.src.operands:
            if isinstance(operand, MediumLevelILInstruction):
                if operand.operation.name == 'MLIL_LOAD_SSA':
                    # skip if vars is inside memory access
                    continue
                for i in operand.vars_read:
                    if hasattr(i, 'var'):
                        src_vars_read.append(i.var.name)
            else:  # SSAVariable object
                if hasattr(operand, 'var'):
                    src_vars_read.append(operand.var.name)

    log_debug("[memaccess_self] src_vars_read: "+str(src_vars_read))
    for src_var in src_vars_read:
        if src_var in dest_vars_read:
            return True
    return False


def conditional_unused(instr):
    """Check if conditional flags are set but no usage

    Args:
        instr (MediumLevelILInstruction): mlil instruction object.

    Returns:
        bool: True if conditional flags are set but not used else False.
    """
    log_debug("enter conditional_unused: "+hex(instr.address))

    # link to macro:
    # https://api.binary.ninja/_modules/binaryninja/enums.html#MediumLevelILOperation  # noqa: E501
    if instr.operation.value == 8:  # MLIL_VAR, just a single variable and no assignment
        # ex: test instruction without usage
        # ignore if it is part of bool operation for a JCC instruction
        cur_i = instr.instr_index + 1
        while instr.function[cur_i].address == instr.address:
            # native instruction can be broken down into multiple il instructions
            # if it is broken down, they will still share same VA
            if hasattr(instr.function[cur_i], 'dest') and  \
                    hasattr(instr.function[cur_i].dest, 'type') and  \
                    str(instr.function[cur_i].dest.type) == 'bool':
                return False
            cur_i += 1
        return True

    # check if top level operation is mathematical operations. Should not be
    if instr.operation.value in range(18, 45) or instr.operation.value in range(83, 90):
        # ignore if it is part of bool operation for a JCC instruction
        cur_i = instr.instr_index

        try:
            while instr.function[cur_i].address == instr.address:
                # native instruction can be broken down into multiple il instructions
                # if it is broken down, they will still share same VA
                if hasattr(instr.function[cur_i], 'dest') and  \
                        hasattr(instr.function[cur_i].dest, 'type') and  \
                        str(instr.function[cur_i].dest.type) == 'bool':
                    return False
                cur_i += 1
        except:
            # make sure original instruction index has corresponding instruction
            # if not return True
            pass

        return True
    return False

```

`op_detective/utils/__init__.py`:

```py
from .bb_utils import (bb2ilbb, get_code_ref_bbs, get_last_bb_instr)

from collections import defaultdict

from binaryninja.log import log_debug  # noqa: F401


def get_symbols(bv):
    """Return all symbols in binary.

    Args:
        bv (BinaryView): top-level binary view handler. Lots of
                         interesting methods can be accessed.

    Returns:
        list: list of symbols in binary.
    """
    total_symbols = list()
    for s in bv.symbols.values():
        if isinstance(s, list):
            total_symbols.extend(s)
        else:
            total_symbols.append(s)
    return total_symbols


def get_authentic_bbs(bv):
    """Return set of bbs that we are confident are authentic.

    Args:
        bv (BinaryView): top-level binary view handler. Lots of
                         interesting methods can be accessed.

    Returns:
        set: int set, where each int is a bb start address.
    """
    good_bbs = list()

    total_symbols = get_symbols(bv)
    # filter symbols to those that can be referenced in code
    total_symbols = [
        s for s in total_symbols if s.type.name in
        ['ImportedFunctionSymbol', 'FunctionSymbol', 'DataSymbol']
    ]

    # code refs from strings
    for s in bv.strings:
        good_bbs.extend(get_code_ref_bbs(bv, s.start))

    # code refs from symbols
    for sym in total_symbols:
        good_bbs.extend(get_code_ref_bbs(bv, sym.address))

    # filter out duplicate bb
    return set(good_bbs)

```

`op_detective/utils/bb_utils.py`:

```py
from binaryninja.log import log_debug  # noqa: F401


def get_last_bb_instr(bb):
    """Given BasicBlock `bb`, retrieve address of last instruction.
    `bb.end` gives you the address of the first byte after the current `bb`

    Args:
        bb (BasicBlock): the BasicBlock that you want the last instruction
                         address of.

    Returns:
        VA: VA of last instruction in long
    """
    return bb.start + (bb.length-bb[-1][-1])


def get_code_ref_bbs(bv, addr):
    """Given address `addr`, find all bb starts that references `addr`.

    Args:
        addr (int): VA.

    Returns:
        list: int list, where each int is a bb start address.
    """
    bbs_start = list()
    # `addr` does not have code references in disassembly
    if not bv.get_code_refs(addr):
        return list()

    for code_ref in bv.get_code_refs(addr):
        if not bv.get_functions_containing(code_ref.address):
            continue
        for func in bv.get_functions_containing(code_ref.address):
            # skip overlapped basic blocks
            if len(bv.get_basic_blocks_at(code_ref.address)) != 1:
                continue
            bbs_start.append(func.get_basic_block_at(code_ref.address).start)
    return bbs_start


def bb2ilbb(bb, il_type, bv):
    """Convert bb to specified il bb.

    We want to reason at the original basic block boundaries.
    There is no exposed BinaryNinja API to go from original basic
    block to `il_type` basic block. This function will allow us
    identify original basic block start the il instruction belongs to.

    An easier approach is to use `bv.get_basic_blocks_at(il.address)`,
    but for obfuscated code, overlapping instructions could cause the
    above code to return multiple basic blocks for a VA. In that case,
    we will have no idea which basic block the il instruction being
    analyzed belongs to.

    Args:
        bb (BasicBlock): original basic block object.
        il_type (str): 'llil' or 'mlil'.

    Returns:
        list: il instruction list.
    """
    il_bb = list()
    addr_list = list()
    cur_func = bb.function
    il_func = getattr(cur_func, il_type)

    # retrieve list of instruction addresses in og bb
    current_addr = bb.start
    for instr in bb:
        addr_list.append(current_addr)
        current_addr += instr[1]
    if current_addr != bb.end:
        addr_list.append(current_addr)

    # filter `addr_list` to addr that only exists in `il_type`
    # retrieves list of addresses @ specified il
    addr_list = [a for a in addr_list if il_func.get_instruction_start(a)]
    assert len(addr_list) != 0

    # retrieve il instructions that share the same addresses that exist in og
    # bb's instructions
    cur_il_i = il_func.get_instruction_start(addr_list[0])  # returns il index
    try:
        while True:
            if il_func[cur_il_i].address <= addr_list[-1]:
                if il_func[cur_il_i].address in addr_list:
                    il_bb.append(il_func[cur_il_i])
                cur_il_i += 1
            else:
                break
    except:
        return il_bb

    return il_bb

```

`op_helpers.py`:

```py
from .op_detective import get_last_bb_instr

from collections import namedtuple

from binaryninja import *


OpaquePredicateInfo = namedtuple('OpaquePredicateInfo', 'if_addr bb_edge rules')


def patch_op(patches, total_conds, bv):
    """

    Provide another layer of filter for deciding whether the basic block really
    contains OP or not

    Args: 
        bv (BinaryView): top-level binary view handler. Lots of
                         interesting methods can be accessed.
        patches: identify_authentic_op function's 'total_patch_locations'.
                 List of OpaquePredicateInfo, or basic blocks that contains OP
        total_conds: find_op function's 'total_conds_seen'. Numbers of 
                     conditional statements seen in binary

    Returns: None. Output to log
    """
    for patch in patches:
        # final filter: check if OP basic block still at beginning of a basic block
        # if not, it is not the original OP
        if not patch.bb_edge.target.function.get_basic_block_at \
                (patch.bb_edge.target.start):
            continue
        if patch.bb_edge.target.function.get_basic_block_at \
                (patch.bb_edge.target.start).start != patch.bb_edge.target.start:
            continue

        #log_debug('[authentic op]: 0x{0:02X}'.format(patch.bb_edge.target.start))
        log_info('0x{0:02X}:{1}'.format(patch.bb_edge.target.start, list(set(patch.rules))))
    #log_info('@total_conds:'+str(total_conds))


def identify_authentic_op(total_patch_locations, total_conds, metadata, bv, patch=True):
    """
    
    Future Work.

    Args: 
        bv (BinaryView): top-level binary view handler. Lots of
                         interesting methods can be accessed.
        total_patch_locations: find_op function's 'cur_pass_patch_locations'.
                               List of OpaquePredicateInfo, or basic blocks that contains OP
        total_conds: find_op function's 'total_conds_seen'. Numbers of conditional statements
                     seen in binary
        metadata: an AnalysisMetadata namedtuple object
        patch: whether to physically patch (i.e. update CFG to remove OP). Currently unused

    Returns:
        None.
    """
    patch_op(total_patch_locations, total_conds, bv)
 

def find_op(bv, analyses=list(), metadata=None, status=None):
    """Analysis main().

    Retrieve each basic block from binary and pass each to respective basic
    block analysis: `bb_analysis`, `bb_mlil_analysis`, and `bb_llil_analysis`.

    Args:
        bv (BinaryView): top-level binary view handler. Lots of
                         interesting methods can be accessed.
        status (FindOpaqueInBackground): plugin main.

    Returns:
        None: each analysis will log their respective findings.
    """
    cur_pass_patch_locations = list()
    seen_bbs = set()
    total_conds_seen = 0

    for func in bv.functions:

        for bb in func.basic_blocks:

            # bb does not end with JCC, so ignore
            if len(bb.outgoing_edges) != 2:
                continue

            # evaluate both branches
            # (does not differentiate between True/False branch)
            # but for our purpose, we don't need to
            if bb in seen_bbs:
                continue

            total_conds_seen += 1 
            for branch in bb.outgoing_edges:

                # bb has multiple incoming edges, so ignore
                if len(branch.target.incoming_edges) != 1:
                    continue

                # ignore authentic bb
                if branch.target.start in metadata.good_bbs:
                    continue

                # core analysis
                alerted_rules_in_bb = list()  # reset to empty
                last_instr_addr = get_last_bb_instr(bb)  # if_addr

                for analysis in analyses:
                    analysis_result = analysis(bv, branch.target, 
                                               branch.target.start, metadata)
                    if analysis_result:
                        # add list of rules alerted in current basic block
                        alerted_rules_in_bb.extend(analysis_result)

                if alerted_rules_in_bb:  # list not empty there are alerted
                                         # rules in current basic block
                    # format: (OP addr, binja branch object, rule list)
                    cur_pass_patch_locations.append(
                        OpaquePredicateInfo(last_instr_addr, branch,
                                            alerted_rules_in_bb)
                    )
            seen_bbs.add(bb)
    return (cur_pass_patch_locations, total_conds_seen)

```

`plugin.json`:

```json
{
    "pluginmetadataversion": 2,
    "name": "Opaque Predicates Detective",
    "type": ["helper"],
    "api": ["python2", "python3"],
    "description": "detect opaque predicates",
    "license": {
        "name": "MIT",
        "text": "Copyright (c) 2019 Yu-Jye Tung\n\nPermission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE."
    },
    "platforms": ["Linux"],
    "dependencies": {
    },
    "version": "0.1",
    "author": "Yu-Jye Tung",
    "minimumbinaryninjaversion": 0
}

```

`requirements.txt`:

```txt
toolz==0.10.0
click==7.1.2

```