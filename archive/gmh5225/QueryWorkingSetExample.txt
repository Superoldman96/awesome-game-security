Project Path: arc_gmh5225_QueryWorkingSetExample_0t7p56dt

Source Tree:

```txt
arc_gmh5225_QueryWorkingSetExample_0t7p56dt
‚îú‚îÄ‚îÄ CMakeLists.txt
‚îú‚îÄ‚îÄ LICENSE
‚îú‚îÄ‚îÄ QueryWorkingSetExample.sln
‚îú‚îÄ‚îÄ QueryWorkingSetExample.vcxproj
‚îú‚îÄ‚îÄ README.md
‚îú‚îÄ‚îÄ doc
‚îÇ   ‚îî‚îÄ‚îÄ images
‚îÇ       ‚îú‚îÄ‚îÄ img1.png
‚îÇ       ‚îî‚îÄ‚îÄ img2.png
‚îî‚îÄ‚îÄ main.c

```

`CMakeLists.txt`:

```txt
cmake_minimum_required(VERSION 3.19)
project(QueryWorkingSetExample C)

set(CMAKE_C_STANDARD 11)

add_executable(QueryWorkingSetExample main.c)
```

`LICENSE`:

```
MIT License

Copyright (c) 2022 Midi12

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
```

`QueryWorkingSetExample.sln`:

```sln

Microsoft Visual Studio Solution File, Format Version 12.00
# Visual Studio Version 17
VisualStudioVersion = 17.1.32328.378
MinimumVisualStudioVersion = 10.0.40219.1
Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "QueryWorkingSetExample", "QueryWorkingSetExample.vcxproj", "{6EB3FDB5-620C-4847-ABDF-5914894977D5}"
EndProject
Global
	GlobalSection(SolutionConfigurationPlatforms) = preSolution
		Debug|x64 = Debug|x64
		Debug|x86 = Debug|x86
		Release|x64 = Release|x64
		Release|x86 = Release|x86
	EndGlobalSection
	GlobalSection(ProjectConfigurationPlatforms) = postSolution
		{6EB3FDB5-620C-4847-ABDF-5914894977D5}.Debug|x64.ActiveCfg = Debug|x64
		{6EB3FDB5-620C-4847-ABDF-5914894977D5}.Debug|x64.Build.0 = Debug|x64
		{6EB3FDB5-620C-4847-ABDF-5914894977D5}.Debug|x86.ActiveCfg = Debug|Win32
		{6EB3FDB5-620C-4847-ABDF-5914894977D5}.Debug|x86.Build.0 = Debug|Win32
		{6EB3FDB5-620C-4847-ABDF-5914894977D5}.Release|x64.ActiveCfg = Release|x64
		{6EB3FDB5-620C-4847-ABDF-5914894977D5}.Release|x64.Build.0 = Release|x64
		{6EB3FDB5-620C-4847-ABDF-5914894977D5}.Release|x86.ActiveCfg = Release|Win32
		{6EB3FDB5-620C-4847-ABDF-5914894977D5}.Release|x86.Build.0 = Release|Win32
	EndGlobalSection
	GlobalSection(SolutionProperties) = preSolution
		HideSolutionNode = FALSE
	EndGlobalSection
	GlobalSection(ExtensibilityGlobals) = postSolution
		SolutionGuid = {17111D9E-A3BA-43BA-A74A-6C1CD6327F21}
	EndGlobalSection
EndGlobal

```

`QueryWorkingSetExample.vcxproj`:

```vcxproj
<?xml version="1.0" encoding="utf-8"?>
<Project DefaultTargets="Build" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup Label="ProjectConfigurations">
    <ProjectConfiguration Include="Debug|Win32">
      <Configuration>Debug</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|Win32">
      <Configuration>Release</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug|x64">
      <Configuration>Debug</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|x64">
      <Configuration>Release</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
  </ItemGroup>
  <PropertyGroup Label="Globals">
    <VCProjectVersion>16.0</VCProjectVersion>
    <Keyword>Win32Proj</Keyword>
    <ProjectGuid>{6eb3fdb5-620c-4847-abdf-5914894977d5}</ProjectGuid>
    <RootNamespace>QueryWorkingSetExample</RootNamespace>
    <WindowsTargetPlatformVersion>10.0</WindowsTargetPlatformVersion>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>LLVM-MSVC_v143</PlatformToolset>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>LLVM-MSVC_v143</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>LLVM-MSVC_v143</PlatformToolset>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>LLVM-MSVC_v143</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
  <ImportGroup Label="ExtensionSettings">
  </ImportGroup>
  <ImportGroup Label="Shared">
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <PropertyGroup Label="UserMacros" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <LinkIncremental>true</LinkIncremental>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <LinkIncremental>false</LinkIncremental>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <LinkIncremental>true</LinkIncremental>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <LinkIncremental>false</LinkIncremental>
  </PropertyGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>WIN32;_DEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
      <RuntimeLibrary>MultiThreadedDebug</RuntimeLibrary>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <FixedBaseAddress>true</FixedBaseAddress>
      <RandomizedBaseAddress>false</RandomizedBaseAddress>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>WIN32;NDEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
      <RuntimeLibrary>MultiThreaded</RuntimeLibrary>
      <BufferSecurityCheck>false</BufferSecurityCheck>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <FixedBaseAddress>true</FixedBaseAddress>
      <RandomizedBaseAddress>false</RandomizedBaseAddress>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>_DEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
      <RuntimeLibrary>MultiThreadedDebug</RuntimeLibrary>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <FixedBaseAddress>true</FixedBaseAddress>
      <RandomizedBaseAddress>false</RandomizedBaseAddress>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>NDEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
      <RuntimeLibrary>MultiThreaded</RuntimeLibrary>
      <BufferSecurityCheck>false</BufferSecurityCheck>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <FixedBaseAddress>true</FixedBaseAddress>
      <RandomizedBaseAddress>false</RandomizedBaseAddress>
    </Link>
  </ItemDefinitionGroup>
  <ItemGroup>
    <ClCompile Include="main.c" />
  </ItemGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
  <ImportGroup Label="ExtensionTargets">
  </ImportGroup>
</Project>
```

`README.md`:

```md
# QueryWorkingSet AntiTamper Example

Just an example of a well-known technique to detect memory tampering via Windows Working Sets.

Non-writable pages are being shared among processes that need them. Each process reads the *same copy*.
Once one process modifies the protection of a page to write to it, the system will copy the page and serve the process its own copy. Once in this state, the `Shared` member of the `PSAPI_WORKING_SET_INFORMATION` (returned by QueryWorkingSet(Ex) API(s)) will be `FALSE` (`0`).

A process can check his `.text` section (or any non-writable section) by querying his Working Set (using QueryWorkingSet(Ex) API(s)) and checking the `Shared` member (and may have use of the `ShareCount` member).

- Running without a debugger
  ![img.png](doc/images/img1.png)
  
- Running under a debugger (you need to place a breakpoint somewhere in `main.c` `main()` routine)
  ![img.png](doc/images/img2.png)
  
The page RVA in the screenshot above would be `0x5000`, once you load the built sample into your favorite disassembler you can notice that the page at RVA `0x5000` is where you put the breakpoint.

Have fun üè¥‚Äç‚ò†Ô∏è

```

`main.c`:

```c
#include <stdbool.h>
#include <stdint.h>
#include <stdio.h>

#include <windows.h>

#include <process.h>
#include <psapi.h>

#pragma comment(lib, "Psapi.lib")

bool get_section_by_name(char const *string, IMAGE_SECTION_HEADER *section_hdr);
void __cdecl watch_thread(void *arg);

struct memory_range_t {
  uintptr_t base_address;
  size_t size;
};

typedef struct memory_range_t memory_range_t;

struct thread_params_t {
  memory_range_t memory_range;
  HANDLE wait_evt;
  HANDLE process;
};

typedef struct thread_params_t thread_params_t;

const uint16_t dos_magic = ('M' | 'Z' << 8);
const uint32_t pe_magic = ('P' | 'E' << 8);

const uint32_t max_elapsed = 10 * 1000;

int main() {
  printf("QueryWorkingSet Example\n");

  IMAGE_SECTION_HEADER text_section = {0};
  bool found = get_section_by_name(".text", &text_section);

  if (found != true) {
    printf("Failed to find .text section");
    return -1;
  }

  memory_range_t memory_range = {
      .base_address = (uintptr_t)((uintptr_t)GetModuleHandle(NULL) +
                                  text_section.VirtualAddress),
      .size = text_section.Misc.VirtualSize};

  HANDLE wait_evt = CreateEvent(NULL, TRUE, FALSE, NULL);

  thread_params_t params = {.memory_range = memory_range,
                            .wait_evt = wait_evt,
                            .process = GetCurrentProcess()};

  _beginthread(watch_thread, 0, (void *)&params);

  Sleep(1000);

  WaitForSingleObject(params.wait_evt, INFINITE);

  return 0;
}

bool get_section_by_name(char const *string,
                         IMAGE_SECTION_HEADER *section_hdr) {
  bool ret = false;

  PIMAGE_DOS_HEADER dos_hdr = (PIMAGE_DOS_HEADER)GetModuleHandle(NULL);
  if (dos_hdr != NULL) {
    if (dos_hdr->e_magic == dos_magic) {
      PIMAGE_NT_HEADERS nt_hdrs =
          (PIMAGE_NT_HEADERS)((uintptr_t)dos_hdr + dos_hdr->e_lfanew);
      if (nt_hdrs != NULL) {
        if (nt_hdrs->Signature == pe_magic) {
          PIMAGE_SECTION_HEADER sections =
              (PIMAGE_SECTION_HEADER)((uintptr_t)nt_hdrs + sizeof(uint32_t) +
                                      sizeof(IMAGE_FILE_HEADER) +
                                      nt_hdrs->FileHeader.SizeOfOptionalHeader);
          uint32_t n_sections = nt_hdrs->FileHeader.NumberOfSections;

          for (int i = 0; i < n_sections; i++) {
            IMAGE_SECTION_HEADER section = sections[i];
            if (strcmp((char const *)section.Name, string) == 0) {
              *section_hdr = section;
              ret = true;
              break;
            }
          }
        }
      }
    }
  }

  return ret;
}

void __cdecl watch_thread(void *arg) {
  thread_params_t *params = (thread_params_t *)arg;
  PPSAPI_WORKING_SET_INFORMATION pwsi = NULL;
  uint32_t start = GetTickCount();

  pwsi = malloc(sizeof(PSAPI_WORKING_SET_INFORMATION));

  bool polling = true;
  while (polling) {
    bool ret = QueryWorkingSet(params->process, (PVOID)pwsi,
                               sizeof(PSAPI_WORKING_SET_INFORMATION));

    if (!ret && GetLastError() == ERROR_BAD_LENGTH) {
      uint32_t n_entries = pwsi->NumberOfEntries;
      free(pwsi);
      pwsi = malloc(sizeof(PSAPI_WORKING_SET_BLOCK) * n_entries +
                    sizeof(pwsi->NumberOfEntries));
      QueryWorkingSet(params->process, (PVOID)pwsi,
                      sizeof(PSAPI_WORKING_SET_BLOCK) * n_entries +
                          sizeof(pwsi->NumberOfEntries));
    }

    for (int i = 0; i < pwsi->NumberOfEntries; i++) {
      PSAPI_WORKING_SET_BLOCK wsb = pwsi->WorkingSetInfo[i];
      uintptr_t page_range_start = params->memory_range.base_address / 0x1000;
      uintptr_t page_range_end =
          ((params->memory_range.base_address + params->memory_range.size) +
           0xfff) /
          0x1000;
      if (page_range_start <= wsb.VirtualPage &&
          wsb.VirtualPage <= page_range_end) {
        if (wsb.Shared == 0) {
          printf("Tamper detected in memory range %p - %p (Page VA %p, "
                 "ShareCount %d)\n",
                 (void *)params->memory_range.base_address,
                 (void *)(params->memory_range.base_address +
                          params->memory_range.size),
                 (void *)(wsb.VirtualPage * 0x1000), wsb.ShareCount);
          // polling = false;
          //  break;
        }
      }
    }

    // if (polling) {
    //   uint32_t now = GetTickCount();
    //   if (now - start > max_elapsed) {
    //     printf("Timer elapsed, no tamper :)");
    //     // break;
    //   }

    //  Sleep(500);
    //}
  }

  free(pwsi);
  SetEvent(params->wait_evt);
}

```