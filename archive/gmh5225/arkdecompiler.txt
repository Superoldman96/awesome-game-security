Project Path: arc_gmh5225_arkdecompiler__a_exiqz

Source Tree:

```txt
arc_gmh5225_arkdecompiler__a_exiqz
├── BUILD.gn
├── LICENSE-2.0.txt
├── README.md
├── arkts.cpp
├── arkts.h
├── ast.cpp
├── ast.h
├── astgen.cpp
├── astgen.h
├── astgen_auxiins.cpp
├── astgen_ecma.inl
├── build.sh
├── case
├── complexstmt2body.h
├── demo.png
├── genlogs.sh
├── intrinsicid2name.h
├── intrinsicid2token.h
├── lca.cpp
├── lca.h
├── lexicalenv.cpp
├── lexicalenv.h
├── patches
│   ├── arkcompiler_runtime_core_a94c360.patch
│   └── third_party_protobuf_0e4c27.patch
├── run.sh
├── scripts
│   ├── intrinsic_list.txt
│   ├── pickintrinsics.py
│   ├── picktokens.py
│   ├── prepare.sh
│   ├── removebc.py
│   └── tokens.txt
└── xabc.cpp

```

`BUILD.gn`:

```gn
import("//arkcompiler/ets_frontend/es2panda/es2abc_config.gni")
import("//arkcompiler/runtime_core/ark_config.gni")
import("$ark_root/tests/test_helper.gni")

ohos_shared_library("libarkdecompiler") {
  stack_protector_ret = false
  sources = ["decompiler.cpp"]

  #cflags_cc = [ "-std=c++17", "-frtti" ]
  
  configs = [
    "$ark_root:ark_config",
    "$ark_root/libpandabase:arkbase_public_config",
    "$ark_root/libpandafile:arkfile_public_config",
    "$ark_root/assembler:arkassembler_public_config",
    "$ark_root/bytecode_optimizer:bytecodeopt_public_config",
    "$ark_root/compiler:arkcompiler_public_config",
  ]

  deps = [
    "$ark_root/disassembler:arkdisassembler",
    "$ark_root/assembler:libarkassembler",
    "$ark_root/bytecode_optimizer:libarkbytecodeopt",
    "$ark_root/compiler:libarkcompiler",
    "$ark_root/libpandabase:libarkbase",
    "$ark_root/libpandafile:libarkfile",
  ]

  external_deps = [ sdk_libc_secshared_dep ]

  include_dirs = [ "$ark_root/compiler/optimizer" ]

  output_extension = "so"
  relative_install_dir = "ark"
  part_name = "runtime_core"
  subsystem_name = "arkcompiler"
}

ohos_executable("xabc") {
  #cflags_cc -= [ "-fno-rtti" ]
  #cflags_cc += [ "-frtti" ]
  #cflags_cc += ["-std=c++17"]
  
  sources = [
    "xabc.cpp",
    "astgen.cpp",
    "arkts.cpp",
    "ast.cpp",
    "lexicalenv.cpp",
    "lca.cpp"
  ]
  
  configs =  [
    "$ark_root:ark_config",
    "$ark_root/assembler:arkassembler_public_config",
    "$ark_root/bytecode_optimizer:bytecodeopt_public_config",
    "$ark_root/compiler:arkcompiler_public_config",
    "$ark_root/libpandabase:arkbase_public_config",
    "$ark_root/libpandafile:arkfile_public_config",
    "$ark_root/../ets_frontend/es2panda:es2abc_config_src",
    "$ark_root/../ets_frontend/es2panda:es2abc_config_common",
    "$ark_root/../ets_frontend/merge_abc:panda_assembly_proto_public_config",
    "$ark_root/../ets_frontend/merge_abc:proto_file_cpp_config",
    "$ark_root/../../third_party/protobuf:protobuf_config",
  ]

  deps = [
    "$ark_root/disassembler:arkdisassembler",
    "$ark_root/assembler:libarkassembler",
    "$ark_root/bytecode_optimizer:libarkbytecodeopt",
    "$ark_root/compiler:libarkcompiler",
    "$ark_root/libpandabase:libarkbase",
    "$ark_root/libpandafile:libarkfile",
    "$ark_root/libpandafile:libarkfile",
    "$ark_root/../ets_frontend/es2panda:es2panda_lib",
  ]
  
  external_deps = [ sdk_libc_secshared_dep ]

}


```

`LICENSE-2.0.txt`:

```txt

                                 Apache License
                           Version 2.0, January 2004
                        http://www.apache.org/licenses/

   TERMS AND CONDITIONS FOR USE, REPRODUCTION, AND DISTRIBUTION

   1. Definitions.

      "License" shall mean the terms and conditions for use, reproduction,
      and distribution as defined by Sections 1 through 9 of this document.

      "Licensor" shall mean the copyright owner or entity authorized by
      the copyright owner that is granting the License.

      "Legal Entity" shall mean the union of the acting entity and all
      other entities that control, are controlled by, or are under common
      control with that entity. For the purposes of this definition,
      "control" means (i) the power, direct or indirect, to cause the
      direction or management of such entity, whether by contract or
      otherwise, or (ii) ownership of fifty percent (50%) or more of the
      outstanding shares, or (iii) beneficial ownership of such entity.

      "You" (or "Your") shall mean an individual or Legal Entity
      exercising permissions granted by this License.

      "Source" form shall mean the preferred form for making modifications,
      including but not limited to software source code, documentation
      source, and configuration files.

      "Object" form shall mean any form resulting from mechanical
      transformation or translation of a Source form, including but
      not limited to compiled object code, generated documentation,
      and conversions to other media types.

      "Work" shall mean the work of authorship, whether in Source or
      Object form, made available under the License, as indicated by a
      copyright notice that is included in or attached to the work
      (an example is provided in the Appendix below).

      "Derivative Works" shall mean any work, whether in Source or Object
      form, that is based on (or derived from) the Work and for which the
      editorial revisions, annotations, elaborations, or other modifications
      represent, as a whole, an original work of authorship. For the purposes
      of this License, Derivative Works shall not include works that remain
      separable from, or merely link (or bind by name) to the interfaces of,
      the Work and Derivative Works thereof.

      "Contribution" shall mean any work of authorship, including
      the original version of the Work and any modifications or additions
      to that Work or Derivative Works thereof, that is intentionally
      submitted to Licensor for inclusion in the Work by the copyright owner
      or by an individual or Legal Entity authorized to submit on behalf of
      the copyright owner. For the purposes of this definition, "submitted"
      means any form of electronic, verbal, or written communication sent
      to the Licensor or its representatives, including but not limited to
      communication on electronic mailing lists, source code control systems,
      and issue tracking systems that are managed by, or on behalf of, the
      Licensor for the purpose of discussing and improving the Work, but
      excluding communication that is conspicuously marked or otherwise
      designated in writing by the copyright owner as "Not a Contribution."

      "Contributor" shall mean Licensor and any individual or Legal Entity
      on behalf of whom a Contribution has been received by Licensor and
      subsequently incorporated within the Work.

   2. Grant of Copyright License. Subject to the terms and conditions of
      this License, each Contributor hereby grants to You a perpetual,
      worldwide, non-exclusive, no-charge, royalty-free, irrevocable
      copyright license to reproduce, prepare Derivative Works of,
      publicly display, publicly perform, sublicense, and distribute the
      Work and such Derivative Works in Source or Object form.

   3. Grant of Patent License. Subject to the terms and conditions of
      this License, each Contributor hereby grants to You a perpetual,
      worldwide, non-exclusive, no-charge, royalty-free, irrevocable
      (except as stated in this section) patent license to make, have made,
      use, offer to sell, sell, import, and otherwise transfer the Work,
      where such license applies only to those patent claims licensable
      by such Contributor that are necessarily infringed by their
      Contribution(s) alone or by combination of their Contribution(s)
      with the Work to which such Contribution(s) was submitted. If You
      institute patent litigation against any entity (including a
      cross-claim or counterclaim in a lawsuit) alleging that the Work
      or a Contribution incorporated within the Work constitutes direct
      or contributory patent infringement, then any patent licenses
      granted to You under this License for that Work shall terminate
      as of the date such litigation is filed.

   4. Redistribution. You may reproduce and distribute copies of the
      Work or Derivative Works thereof in any medium, with or without
      modifications, and in Source or Object form, provided that You
      meet the following conditions:

      (a) You must give any other recipients of the Work or
          Derivative Works a copy of this License; and

      (b) You must cause any modified files to carry prominent notices
          stating that You changed the files; and

      (c) You must retain, in the Source form of any Derivative Works
          that You distribute, all copyright, patent, trademark, and
          attribution notices from the Source form of the Work,
          excluding those notices that do not pertain to any part of
          the Derivative Works; and

      (d) If the Work includes a "NOTICE" text file as part of its
          distribution, then any Derivative Works that You distribute must
          include a readable copy of the attribution notices contained
          within such NOTICE file, excluding those notices that do not
          pertain to any part of the Derivative Works, in at least one
          of the following places: within a NOTICE text file distributed
          as part of the Derivative Works; within the Source form or
          documentation, if provided along with the Derivative Works; or,
          within a display generated by the Derivative Works, if and
          wherever such third-party notices normally appear. The contents
          of the NOTICE file are for informational purposes only and
          do not modify the License. You may add Your own attribution
          notices within Derivative Works that You distribute, alongside
          or as an addendum to the NOTICE text from the Work, provided
          that such additional attribution notices cannot be construed
          as modifying the License.

      You may add Your own copyright statement to Your modifications and
      may provide additional or different license terms and conditions
      for use, reproduction, or distribution of Your modifications, or
      for any such Derivative Works as a whole, provided Your use,
      reproduction, and distribution of the Work otherwise complies with
      the conditions stated in this License.

   5. Submission of Contributions. Unless You explicitly state otherwise,
      any Contribution intentionally submitted for inclusion in the Work
      by You to the Licensor shall be under the terms and conditions of
      this License, without any additional terms or conditions.
      Notwithstanding the above, nothing herein shall supersede or modify
      the terms of any separate license agreement you may have executed
      with Licensor regarding such Contributions.

   6. Trademarks. This License does not grant permission to use the trade
      names, trademarks, service marks, or product names of the Licensor,
      except as required for reasonable and customary use in describing the
      origin of the Work and reproducing the content of the NOTICE file.

   7. Disclaimer of Warranty. Unless required by applicable law or
      agreed to in writing, Licensor provides the Work (and each
      Contributor provides its Contributions) on an "AS IS" BASIS,
      WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or
      implied, including, without limitation, any warranties or conditions
      of TITLE, NON-INFRINGEMENT, MERCHANTABILITY, or FITNESS FOR A
      PARTICULAR PURPOSE. You are solely responsible for determining the
      appropriateness of using or redistributing the Work and assume any
      risks associated with Your exercise of permissions under this License.

   8. Limitation of Liability. In no event and under no legal theory,
      whether in tort (including negligence), contract, or otherwise,
      unless required by applicable law (such as deliberate and grossly
      negligent acts) or agreed to in writing, shall any Contributor be
      liable to You for damages, including any direct, indirect, special,
      incidental, or consequential damages of any character arising as a
      result of this License or out of the use or inability to use the
      Work (including but not limited to damages for loss of goodwill,
      work stoppage, computer failure or malfunction, or any and all
      other commercial damages or losses), even if such Contributor
      has been advised of the possibility of such damages.

   9. Accepting Warranty or Additional Liability. While redistributing
      the Work or Derivative Works thereof, You may choose to offer,
      and charge a fee for, acceptance of support, warranty, indemnity,
      or other liability obligations and/or rights consistent with this
      License. However, in accepting such obligations, You may act only
      on Your own behalf and on Your sole responsibility, not on behalf
      of any other Contributor, and only if You agree to indemnify,
      defend, and hold each Contributor harmless for any liability
      incurred by, or claims asserted against, such Contributor by reason
      of your accepting any such warranty or additional liability.

   END OF TERMS AND CONDITIONS

   APPENDIX: How to apply the Apache License to your work.

      To apply the Apache License to your work, attach the following
      boilerplate notice, with the fields enclosed by brackets "[]"
      replaced with your own identifying information. (Don't include
      the brackets!)  The text should be enclosed in the appropriate
      comment syntax for the file format. We also recommend that a
      file or class name and description of purpose be included on the
      same "printed page" as the copyright notice for easier
      identification within third-party archives.

   Copyright [yyyy] [name of copyright owner]

   Licensed under the Apache License, Version 2.0 (the "License");
   you may not use this file except in compliance with the License.
   You may obtain a copy of the License at

       http://www.apache.org/licenses/LICENSE-2.0

   Unless required by applicable law or agreed to in writing, software
   distributed under the License is distributed on an "AS IS" BASIS,
   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   See the License for the specific language governing permissions and
   limitations under the License.

```

`README.md`:

```md
# Description
We developed the HarmonyOS NEXT decompilation tool named arkdecompiler, which takes Panda Binary File as input, parses Panda Bytecode, and then translates it into Panda IR. After having IR, we can do various analyses. Based on IR, we reversely construct the native arkTS AST tree, and then we traverse the AST tree and translate it into native arkTS source code.



- 2025.Q3: [2025 Black Hat, USA](https://www.blackhat.com/us-25/arsenal/schedule/index.html#decompiler-for-harmonyos-next-45569)
- 2026.Q1: Support all instructions and program structures

# Installation
## Tested platform
Ubuntu 18.04

In the future we will adapt to other development platforms such as (windows, macOS) and add a GUI.
## Prepare enviroment
```bash
mkdir harmonyos
cd harmonyos
run scripts/prepare.sh
```

## Clone arkdecompiler in harmonyos
```bash
git clone https://github.com/jd-opensource/arkdecompiler.git
```


## Apply patch in harmonyos/arkcompiler/runtime_core
```bash
git apply --check *.patch
```


## Build & Run
```bash
./build.sh

```

## Usage
### Run
./run.sh
### detailed description
- binary executable is **xabc**,
- default input file is：**demo.abc**
- default output file is：**arkdemo.ts**


## Demo
### Decompile bytecode to arkTS
![demo](demo.png)

### AST
```
{
  "type": "Program",
  "statements": [
    {
      "type": "ExpressionStatement",
      "expression": {
        "type": "AssignmentExpression",
        "operator": "=",
        "left": {
          "type": "Identifier",
          "name": "v254",
          "loc": {
            "start": {
              "line": 1,
              "column": 1
            },
            "end": {
              "line": 1,
              "column": 1
            }
          }
        },
        "right": {
          "type": "Identifier",
          "name": "undefined",
          "loc": {
            "start": {
              "line": 1,
              "column": 1
            },
            "end": {
              "line": 1,
              "column": 1
            }
          }
        },
        "loc": {
          "start": {
            "line": 1,
            "column": 1
          },
          "end": {
            "line": 1,
            "column": 1
          }
        }
      },
      "loc": {
        "start": {
          "line": 1,
          "column": 1
        },
        "end": {
          "line": 1,
          "column": 1
        }
      }
    },
    {
      "type": "ExpressionStatement",
      "expression": {
        "type": "AssignmentExpression",
        "operator": "=",
        "left": {
          "type": "Identifier",
          "name": "c",
          "loc": {
            "start": {
              "line": 1,
              "column": 1
            },
            "end": {
              "line": 1,
              "column": 1
            }
          }
        },
        "right": {
          "type": "Identifier",
          "name": "v254",
          "loc": {
            "start": {
              "line": 1,
              "column": 1
            },
            "end": {
              "line": 1,
              "column": 1
            }
          }
        },
        "loc": {
          "start": {
            "line": 1,
            "column": 1
          },
          "end": {
            "line": 1,
            "column": 1
          }
        }
      },
      "loc": {
        "start": {
          "line": 1,
          "column": 1
        },
        "end": {
          "line": 1,
          "column": 1
        }
      }
    },
    {
      "type": "ExpressionStatement",
      "expression": {
        "type": "AssignmentExpression",
        "operator": "=",
        "left": {
          "type": "Identifier",
          "name": "v0",
          "loc": {
            "start": {
              "line": 1,
              "column": 1
            },
            "end": {
              "line": 1,
              "column": 1
            }
          }
        },
        "right": {
          "type": "NumberLiteral",
          "value": 1,
          "loc": {
            "start": {
              "line": 1,
              "column": 1
            },
            "end": {
              "line": 1,
              "column": 1
            }
          }
        },
        "loc": {
          "start": {
            "line": 1,
            "column": 1
          },
          "end": {
            "line": 1,
            "column": 1
          }
        }
      },
      "loc": {
        "start": {
          "line": 1,
          "column": 1
        },
        "end": {
          "line": 1,
          "column": 1
        }
      }
    },
    {
      "type": "ExpressionStatement",
      "expression": {
        "type": "AssignmentExpression",
        "operator": "=",
        "left": {
          "type": "Identifier",
          "name": "v254",
          "loc": {
            "start": {
              "line": 1,
              "column": 1
            },
            "end": {
              "line": 1,
              "column": 1
            }
          }
        },
        "right": {
          "type": "BinaryExpression",
          "operator": "+",
          "left": {
            "type": "NumberLiteral",
            "value": 1,
            "loc": {
              "start": {
                "line": 1,
                "column": 1
              },
              "end": {
                "line": 1,
                "column": 1
              }
            }
          },
          "right": {
            "type": "Identifier",
            "name": "v0",
            "loc": {
              "start": {
                "line": 1,
                "column": 1
              },
              "end": {
                "line": 1,
                "column": 1
              }
            }
          },
          "loc": {
            "start": {
              "line": 1,
              "column": 1
            },
            "end": {
              "line": 1,
              "column": 1
            }
          }
        },
        "loc": {
          "start": {
            "line": 1,
            "column": 1
          },
          "end": {
            "line": 1,
            "column": 1
          }
        }
      },
      "loc": {
        "start": {
          "line": 1,
          "column": 1
        },
        "end": {
          "line": 1,
          "column": 1
        }
      }
    },
    {
      "type": "ExpressionStatement",
      "expression": {
        "type": "AssignmentExpression",
        "operator": "=",
        "left": {
          "type": "Identifier",
          "name": "c",
          "loc": {
            "start": {
              "line": 1,
              "column": 1
            },
            "end": {
              "line": 1,
              "column": 1
            }
          }
        },
        "right": {
          "type": "Identifier",
          "name": "v254",
          "loc": {
            "start": {
              "line": 1,
              "column": 1
            },
            "end": {
              "line": 1,
              "column": 1
            }
          }
        },
        "loc": {
          "start": {
            "line": 1,
            "column": 1
          },
          "end": {
            "line": 1,
            "column": 1
          }
        }
      },
      "loc": {
        "start": {
          "line": 1,
          "column": 1
        },
        "end": {
          "line": 1,
          "column": 1
        }
      }
    },
    {
      "type": "ExpressionStatement",
      "expression": {
        "type": "AssignmentExpression",
        "operator": "=",
        "left": {
          "type": "Identifier",
          "name": "v254",
          "loc": {
            "start": {
              "line": 1,
              "column": 1
            },
            "end": {
              "line": 1,
              "column": 1
            }
          }
        },
        "right": {
          "type": "Identifier",
          "name": "undefined",
          "loc": {
            "start": {
              "line": 1,
              "column": 1
            },
            "end": {
              "line": 1,
              "column": 1
            }
          }
        },
        "loc": {
          "start": {
            "line": 1,
            "column": 1
          },
          "end": {
            "line": 1,
            "column": 1
          }
        }
      },
      "loc": {
        "start": {
          "line": 1,
          "column": 1
        },
        "end": {
          "line": 1,
          "column": 1
        }
      }
    },
    {
      "type": "ReturnStatement",
      "argument": {
        "type": "Identifier",
        "name": "undefined",
        "loc": {
          "start": {
            "line": 1,
            "column": 1
          },
          "end": {
            "line": 1,
            "column": 1
          }
        }
      },
      "loc": {
        "start": {
          "line": 1,
          "column": 1
        },
        "end": {
          "line": 1,
          "column": 1
        }
      }
    }
  ],
  "loc": {
    "start": {
      "line": 1,
      "column": 1
    },
    "end": {
      "line": 1,
      "column": 1
    }
  }
}

```

```

`arkts.cpp`:

```cpp
#include "arkts.h"

namespace panda::es2panda::ir {

ArkTSGen::ArkTSGen(const BlockStatement *program, util::StringView sourceCode) : index_(sourceCode), indent_(0)
{
    SerializeObject(reinterpret_cast<const ir::AstNode *>(program));
}

ArkTSGen::ArkTSGen(const ir::AstNode *node) : indent_(0), dumpNodeOnly_(true)
{
    EmitStatement(node);
}

void ArkTSGen::EmitBlockStatement(const ir::AstNode *node){
    auto tmp = const_cast<ir::AstNode*>(node);
    auto blockstatement = static_cast<panda::es2panda::ir::BlockStatement*>(tmp);

    const auto &statements = blockstatement->Statements();
    
    if(statements.size() == 0){
       // this->writeNewLine();
    }

    for (const auto *stmt : statements) {
        this->EmitStatement(stmt);
    }
}

void ArkTSGen::writeTrailingSemicolon(){
    ss_ << ";" << std::endl;
}

void ArkTSGen::writeSpace(){
    ss_ << " ";
}

void ArkTSGen::writeLeftBrace(){
    ss_ << "{";
}

void ArkTSGen::writeRightBrace(){
    ss_ << "}";
}

void ArkTSGen::writeLeftBracket(){
    ss_ << "[";
}

void ArkTSGen::writeRightBracket(){
    ss_ << "]";
}

void ArkTSGen::writeLeftParentheses(){
    ss_ << "(";
}

void ArkTSGen::writeRightParentheses(){
    ss_ << ")";
}

void ArkTSGen::writeColon(){
    ss_ << " : ";
}

void ArkTSGen::writeEqual(){
    ss_ << " = ";
}

void ArkTSGen::writeComma(){
    ss_ << ", ";
}

void ArkTSGen::writeDot(){
    ss_ << ".";
}

void ArkTSGen::writeKeyWords(std::string keyword){
    ss_ << keyword ;
}

void ArkTSGen::writeSpreadDot(){
    ss_ << "...";
}

void ArkTSGen::writeNewLine(){
    ss_ << "\n";
}

void ArkTSGen::writeIndent(){
    for (int i = 0; i < this->indent_; ++i) {
        ss_ << " ";
    } 
}

void ArkTSGen::EmitExpression(const ir::AstNode *node){
    if(node == nullptr){
        handleError("#EmitExpression: emitExpression for null astnode");
    }

    switch(node->Type()){ 
        case AstNodeType::BINARY_EXPRESSION:{
            std::cout << "enter BINARY_EXPRESSION >>>>>>>>>>>>>>>>>>>>>>>>>>" << std::endl; 
            auto binexpression = static_cast<const panda::es2panda::ir::BinaryExpression*>(node);
            this->EmitExpression(binexpression->Left());
            writeSpace();
            ss_ << TokenToString(binexpression->OperatorType());
            writeSpace();
            this->EmitExpression(binexpression->Right());
            break;
        }

        case AstNodeType::UNARY_EXPRESSION:{
            std::cout << "enter UNARY_EXPRESSION >>>>>>>>>>>>>>>>>>>>>>>>>>" << std::endl; 
            auto unaryexpression = static_cast<const panda::es2panda::ir::UnaryExpression*>(node);
            ss_ << TokenToString(unaryexpression->OperatorType());
            writeSpace();
            this->EmitExpression(unaryexpression->Argument());
            break;
        }

        case AstNodeType::ASSIGNMENT_EXPRESSION:{
            auto assignexpression = static_cast<const panda::es2panda::ir::AssignmentExpression*>(node);

            std::cout << "enter ASSIGNMENT_EXPRESSION >>>>>>>>>>>>>>>>>>>>>>>>>>" << std::endl; 
            
            this->EmitExpression(assignexpression->Left());
            writeSpace();
            ss_ << TokenToString(assignexpression->OperatorType());
            writeSpace();
            this->EmitExpression(assignexpression->Right());
            break;
        }
        case AstNodeType::IDENTIFIER:{
            auto identifier = static_cast<const panda::es2panda::ir::Identifier*>(node);
            ss_ << identifier->Name();
            break;
        }

        case AstNodeType::NUMBER_LITERAL:{
            auto number_literal = static_cast<const panda::es2panda::ir::NumberLiteral*>(node);
            this->SerializeNumber(number_literal->Number());
            break;
        } 

        case AstNodeType::BIGINT_LITERAL:{
            auto bigint_literal = static_cast<const panda::es2panda::ir::BigIntLiteral*>(node);
            this->SerializeString(bigint_literal->Str());
            break;
        } 

        case AstNodeType::NULL_LITERAL:{
            this->SerializeConstant(Property::Constant::PROP_NULL);
            break;
        }

        case AstNodeType::STRING_LITERAL:{
            auto string_literal = static_cast<const panda::es2panda::ir::StringLiteral*>(node);
            this->SerializeString(string_literal->Str());
            break;
        }
        
        case AstNodeType::BOOLEAN_LITERAL:{
            auto bool_literal = static_cast<const panda::es2panda::ir::BooleanLiteral*>(node);
            this->SerializeBoolean(bool_literal->Value());
            break;
        }
        case AstNodeType::MEMBER_EXPRESSION:{
            auto member_expression = static_cast<const panda::es2panda::ir::MemberExpression*>(node);
            this->EmitExpression(member_expression->Object());
            if(member_expression->IsComputed()){
                this->writeLeftBracket();
                this->EmitExpression(member_expression->Property());
                this->writeRightBracket();
            }else{
                this->writeDot();
                this->EmitExpression(member_expression->Property());
            }
            break;
        }

        case AstNodeType::OBJECT_EXPRESSION:{
            std::cout << "enter OBJECT_EXPRESSION >>>>>>>>>>>>>>>>>>>>>>>>>>" << std::endl; 
            auto objexpression = static_cast<const panda::es2panda::ir::ObjectExpression*>(node);
            
            writeLeftBrace();
            size_t properties_size = objexpression->Properties().size();
            size_t count = 1;
            for (auto *it : objexpression->Properties()) {
                switch (it->Type()) {
                    case AstNodeType::PROPERTY: {
                        this->EmitExpression(it);
                        
                        if(count++ < properties_size)
                            this->writeComma();
                        
                        break;
                    }
                    case AstNodeType::SPREAD_ELEMENT:{
                        this->EmitExpression(it);
                        
                        if(count++ < properties_size)
                            this->writeComma();
                        
                        break;
                    }
                    default: {
                        std::cout << "unsupport AstNodeType >>>>>>>>>>>>>>>>>>>>>>>>>" << std::endl;
                        break;
                    }
                }
            }
            writeRightBrace();

            break;

        }

        case AstNodeType::ARRAY_EXPRESSION:{
            std::cout << "enter OBJECT_EXPRESSION >>>>>>>>>>>>>>>>>>>>>>>>>>" << std::endl; 
            auto arrayexpression = static_cast<const panda::es2panda::ir::ArrayExpression*>(node);
            
            writeLeftBracket();
            int count = 0;
            int array_size = arrayexpression->Elements().size();
            for (auto *it : arrayexpression->Elements()) {
                this->EmitExpression(it);
                if(++count < array_size ){
                    this->writeComma();
                }
            }
            writeRightBracket();

            break;

        }

        case AstNodeType::PROPERTY:{
            auto propertyexpression = static_cast<const panda::es2panda::ir::Property*>(node);

            this->EmitExpression(propertyexpression->Key());
            this->writeColon();
            this->EmitExpression(propertyexpression->Value());
            

            break;
        }

        case AstNodeType::CALL_EXPRESSION:{
            auto callexpression = static_cast<const panda::es2panda::ir::CallExpression*>(node);

            this->EmitExpression(callexpression->Callee());
            this->writeLeftParentheses();

            int count = 1;
            int argumentsize = callexpression->Arguments().size();
            for (const auto *it : callexpression->Arguments()) {
                this->EmitExpression(it);
                if(count ++ < argumentsize){
                    this->writeComma();
                }
            }

            this->writeRightParentheses();

            break;
        }

        case AstNodeType::NEW_EXPRESSION:{
            auto newexpression = static_cast<const panda::es2panda::ir::NewExpression*>(node);

            this->writeKeyWords("new");
            this->writeSpace();
            this->EmitExpression(newexpression->Callee());
            this->writeLeftParentheses();

            int count = 1;
            int argumentsize = newexpression->Arguments().size();
            for (const auto *it : newexpression->Arguments()) {
                this->EmitExpression(it);
                if(count ++ < argumentsize){
                    this->writeComma();
                }
            }

            this->writeRightParentheses();

            break;
        }

        case AstNodeType::SPREAD_ELEMENT:{
            this->writeSpreadDot();
            auto spreadarg = static_cast<const es2panda::ir::SpreadElement*>(node);
            this->EmitExpression(spreadarg->Argument());
            break;
        }

        default:
            handleError("#EmitExpression : unsupport expression");;

    }
}

void ArkTSGen::EmitExpressionStatement(const ir::AstNode *node){
    auto expressionstatement = static_cast<const panda::es2panda::ir::ExpressionStatement*>(node);
    this->EmitExpression(expressionstatement->GetExpression());
    this->writeTrailingSemicolon();
}

void ArkTSGen::EmitVariableDeclarationStatement(const ir::AstNode *node){
    auto vardeclstatement = static_cast<const panda::es2panda::ir::VariableDeclaration*>(node);
    
    int size = vardeclstatement->Declarators().size();
    int count = 1;
    
    if(vardeclstatement->Kind() == es2panda::ir::VariableDeclaration::VariableDeclarationKind::CONST){
        this->writeKeyWords("const");
        this->writeSpace();
    }else if(vardeclstatement->Kind() == es2panda::ir::VariableDeclaration::VariableDeclarationKind::LET){
        this->writeKeyWords("let");
        this->writeSpace();
    }else {
        this->writeKeyWords("var");
        this->writeSpace();
    }

    for (const auto *it : vardeclstatement->Declarators()) {
        this->EmitStatement(it);
        if(++count < size ){
            this->writeColon();
        }
    }
    this->writeTrailingSemicolon();
}

void ArkTSGen::EmitVariableDeclaratorStatement(const ir::AstNode *node){
    auto vardeclstatement = static_cast<const panda::es2panda::ir::VariableDeclarator*>(node);
    this->EmitExpression(vardeclstatement->Id());
    this->writeEqual();
    this->EmitExpression(vardeclstatement->Init());
}


void ArkTSGen::EmitReturnStatement(const ir::AstNode *node){
    auto returnstatement = static_cast<const panda::es2panda::ir::ReturnStatement*>(node);
    this->writeKeyWords("return");
    this->writeSpace();
    this->EmitExpression(returnstatement->Argument());
    this->writeTrailingSemicolon();
}

void ArkTSGen::EmitBreakStatement(const ir::AstNode *node){
    this->writeKeyWords("break");
    this->writeTrailingSemicolon();
}

void  ArkTSGen::EmitDebuggerStatement(const ir::AstNode *node){
    this->writeKeyWords("debugger");
    this->writeTrailingSemicolon();
}

void  ArkTSGen::EmitThrowStatement(const ir::AstNode *node){
    auto throwstatement = static_cast<const panda::es2panda::ir::ThrowStatement*>(node);

    this->writeKeyWords("throw");
    this->writeSpace();
    this->EmitExpression(throwstatement->Argument());
    this->writeTrailingSemicolon();
}


void  ArkTSGen::EmitFunctionDeclaration(const ir::AstNode *node){
    auto fundeclare = static_cast<const panda::es2panda::ir::FunctionDeclaration*>(node);
    auto scriptfunction =  fundeclare->Function();

    this->writeKeyWords("function");
    this->writeSpace();
    this->EmitExpression(scriptfunction->Id());
    this->writeLeftParentheses();

    int count = 1;
    int argumentsize = scriptfunction->Params().size();
    for (const auto *param : scriptfunction->Params()) {
        this->EmitExpression(param);
        if(count ++ < argumentsize){
            this->writeComma();
        }
    }
    this->writeRightParentheses();
    this->writeLeftBrace();
    this->writeNewLine();
    this->indent_ = this->indent_ + this->singleindent_;

    this->EmitStatement(scriptfunction->Body());

    this->indent_ = this->indent_ - this->singleindent_;
    this->writeRightBrace();
    this->writeNewLine();
}

void ArkTSGen::EmitTryStatement(const ir::AstNode *node){
    auto trystatement = static_cast<const panda::es2panda::ir::TryStatement*>(node);
    
    // if(test)
    this->writeKeyWords("try");
    this->writeLeftBrace();
    this->writeNewLine();

    //  statements
    this->indent_ = this->indent_ + this->singleindent_;
    this->EmitStatement(trystatement->Block());
    this->indent_ = this->indent_ - this->singleindent_;
    this->writeIndent();
    this->writeRightBrace();

    // }catch(error){
    this->writeKeyWords("catch");
    this->writeLeftParentheses();
    this->EmitExpression(trystatement->GetCatchClause()->Param());
    this->writeRightParentheses();
    this->writeLeftBrace();
    this->writeNewLine();

    // catch body
    this->indent_ = this->indent_ + this->singleindent_;
    this->EmitStatement(trystatement->GetCatchClause()->Body());
    this->indent_ = this->indent_ - this->singleindent_;

    // }
    this->writeIndent();
    this->writeRightBrace();
    this->writeNewLine();
}

void ArkTSGen::EmitIfStatement(const ir::AstNode *node){
    std::cout << "[+] start EmitIfStatement"  << std::endl;
    auto ifstatement = static_cast<const panda::es2panda::ir::IfStatement*>(node);
    if(ifstatement->Consequent() == nullptr ||  static_cast<const panda::es2panda::ir::BlockStatement*>(ifstatement->Consequent())->Statements().size() == 0){
        return;
    }

    // if(test)
    this->writeKeyWords("if");
    this->writeLeftParentheses();
    this->EmitExpression(ifstatement->Test());
    this->writeRightParentheses();
    this->writeLeftBrace();
    this->writeNewLine();

    // if statements
    this->indent_ = this->indent_ + this->singleindent_;
    this->EmitStatement(ifstatement->Consequent());
    this->indent_ = this->indent_ - this->singleindent_;
    this->writeIndent();
    this->writeRightBrace();

    if(ifstatement->Alternate() != nullptr &&  static_cast<const panda::es2panda::ir::BlockStatement*>(ifstatement->Alternate())->Statements().size() > 0){
        // }else{
        this->writeKeyWords("else");
        this->writeLeftBrace();
        this->writeNewLine();

        // else statements
        this->indent_ = this->indent_ + this->singleindent_;
        this->EmitStatement(ifstatement->Alternate());
        this->indent_ = this->indent_ - this->singleindent_;

        // }
        this->writeIndent();
        this->writeRightBrace();
    }
    this->writeNewLine();
    
    std::cout << "[-] end EmitIfStatement"  << std::endl;
}

void ArkTSGen::EmitWhileStatement(const ir::AstNode *node){
    std::cout << "[+] start emit while statement"  << std::endl;
    auto whilestatement = static_cast<const panda::es2panda::ir::WhileStatement*>(node);
    
    // while(test){
    this->writeKeyWords("while");
    this->writeLeftParentheses();
    this->EmitExpression(whilestatement->Test());
    this->writeRightParentheses();
    this->writeLeftBrace();
    this->writeNewLine();

    // while statement
    this->indent_ = this->indent_ + this->singleindent_;
    this->EmitStatement(whilestatement->Body());
    this->indent_ = this->indent_ - this->singleindent_;

    // }
    this->writeIndent();
    this->writeRightBrace();
    this->writeNewLine();
        
    std::cout << "[-] end emit while statement"  << std::endl;
}

void ArkTSGen::EmitDoWhileStatement(const ir::AstNode *node){
    std::cout << "[+] start emit dowhile statement"  << std::endl;
    auto dowhilestatement = static_cast<const panda::es2panda::ir::DoWhileStatement*>(node);
    
    // do {
    this->writeKeyWords("do");
    this->writeLeftBrace();
    this->writeNewLine();

    // while statement
    this->indent_ = this->indent_ + this->singleindent_;
    this->EmitStatement(dowhilestatement->Body());
    this->indent_ = this->indent_ - this->singleindent_;

    // }while(test)
    this->writeIndent();
    this->writeRightBrace();
    this->writeKeyWords("while");
    this->writeLeftParentheses();
    this->EmitExpression(dowhilestatement->Test());
    this->writeRightParentheses();
    this->writeTrailingSemicolon();        
    std::cout << "[-] end emit dowhile statement"  << std::endl;
}

void ArkTSGen::EmitStatement(const ir::AstNode *node)
{
    if(node == nullptr){
        handleError("#EmitStatement: emitStatement for null astnode");
    }

    if(node->Type() != AstNodeType::BLOCK_STATEMENT && node->Type() != AstNodeType::VARIABLE_DECLARATOR ){
        this->writeIndent();
    }


    std::cout << "emit statement start " << std::endl;
    switch(node->Type()){
        case AstNodeType::EXPRESSION_STATEMENT:
            std::cout << "enter EXPRESSION_STATEMENT >>>>>>>>>>>>>>>>>>>>>>>>>>" << std::endl;
            this->EmitExpressionStatement(node); 
            break;
        case AstNodeType::BLOCK_STATEMENT:
            std::cout << "enter BLOCK_STATEMENT >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>" << std::endl; 
            this->EmitBlockStatement(node);
            break;

        case AstNodeType::VARIABLE_DECLARATION:
            std::cout << "enter VARIABLE_DECLARATION >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>" << std::endl; 
            this->EmitVariableDeclarationStatement(node);
            break;

        case AstNodeType::VARIABLE_DECLARATOR:
            std::cout << "enter VARIABLE_DECLARATO >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>" << std::endl; 
            this->EmitVariableDeclaratorStatement(node);
            break;

        case AstNodeType::RETURN_STATEMENT:
            std::cout << "enter RETURN STATEMENT >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>" << std::endl; 
            this->EmitReturnStatement(node);
            break;

        case AstNodeType::DEBUGGER_STATEMENT:
            std::cout << "enter DEBUGGER STATEMENT >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>" << std::endl; 
            this->EmitDebuggerStatement(node);
            break;

        case AstNodeType::FUNCTION_DECLARATION:
            std::cout << "enter FUNCTION_DECLARATION STATEMENT >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>" << std::endl; 
            this->EmitFunctionDeclaration(node);
            break;

        case AstNodeType::IF_STATEMENT:
            std::cout << "enter IF_STATEMENT STATEMENT >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>" << std::endl; 
            this->EmitIfStatement(node);
            break;
        
        case AstNodeType::TRY_STATEMENT:
            std::cout << "enter TRY_STATEMENT STATEMENT >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>" << std::endl; 
            this->EmitTryStatement(node);
            break;

        case AstNodeType::THROW_STATEMENT:
            std::cout << "enter THROW_STATEMENT STATEMENT >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>" << std::endl; 
            this->EmitThrowStatement(node);
            break;

        case AstNodeType::WHILE_STATEMENT:
            std::cout << "enter WHILE_STATEMENT STATEMENT >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>" << std::endl; 
            this->EmitWhileStatement(node);
            break;
        
        case AstNodeType::DO_WHILE_STATEMENT:
            std::cout << "enter DOWHILE_STATEMENT STATEMENT >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>" << std::endl; 
            this->EmitDoWhileStatement(node);
            break;

        case AstNodeType::BREAK_STATEMENT:
            std::cout << "enter BREAK_STATEMENT STATEMENT >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>" << std::endl; 
            this->EmitBreakStatement(node);
            break;

        default:
            handleError("#EmitStatement : unsupport statement");;
    }



    // Wrap(
    //     [this, node]() -> void {
    //         node->Dump(this);
    //     }
    // );
}




void ArkTSGen::Add(std::initializer_list<ArkTSGen::Property> props){
    AddList<std::initializer_list<ArkTSGen::Property>>(props);
}

void ArkTSGen::Add(const ArkTSGen::Property &prop){
    Serialize(prop);
}

const char *ArkTSGen::ModifierToString(ModifierFlags flags){
    if (flags & ModifierFlags::PRIVATE) {
        return "private";
    }

    if (flags & ModifierFlags::PROTECTED) {
        return "protected";
    }

    if (flags & ModifierFlags::PUBLIC) {
        return "public";
    }

    return nullptr;
}

const char *ArkTSGen::TypeOperatorToString(TSOperatorType operatorType)
{
    if (operatorType == TSOperatorType::KEYOF) {
        return "keyof";
    }

    if (operatorType == TSOperatorType::READONLY) {
        return "readonly";
    }

    if (operatorType == TSOperatorType::UNIQUE) {
        return "unique";
    }

    return nullptr;
}

void ArkTSGen::Serialize(const ArkTSGen::Property &prop)
{
    SerializePropKey(prop.Key());
    const auto &value = prop.Value();

    if (std::holds_alternative<const char *>(value)) {
        SerializeString(std::get<const char *>(value));
    } else if (std::holds_alternative<util::StringView>(value)) {
        SerializeString(std::get<util::StringView>(value));
    } else if (std::holds_alternative<bool>(value)) {
        SerializeBoolean(std::get<bool>(value));
    } else if (std::holds_alternative<double>(value)) {
        SerializeNumber(std::get<double>(value));
    } else if (std::holds_alternative<const ir::AstNode *>(value)) {
        if (dumpNodeOnly_) {
            EmitStatement(std::get<const ir::AstNode *>(value));
        } else {
            SerializeObject(std::get<const ir::AstNode *>(value));
        }
    } else if (std::holds_alternative<std::vector<const ir::AstNode *>>(value)) {
        SerializeArray(std::get<std::vector<const ir::AstNode *>>(value));
    } else if (std::holds_alternative<lexer::TokenType>(value)) {
        SerializeToken(std::get<lexer::TokenType>(value));
    } else if (std::holds_alternative<std::initializer_list<Property>>(value)) {
        SerializePropList(std::get<std::initializer_list<Property>>(value));
    } else if (std::holds_alternative<Property::Constant>(value)) {
        SerializeConstant(std::get<Property::Constant>(value));
    }
}

void ArkTSGen::SerializeToken(lexer::TokenType token)
{
    ss_ << "\"" << lexer::TokenToString(token) << "\"";
}

void ArkTSGen::SerializePropKey(const char *str)
{
    if (dumpNodeOnly_) {
        return;
    }
    ss_ << std::endl;
    Indent();
    SerializeString(str);
    ss_ << ": ";
}

void ArkTSGen::SerializeString(const char *str)
{
    ss_ << "\"" << str << "\"";
}

void ArkTSGen::SerializeString(const util::StringView &str)
{
    ss_ << "\"" << str.Utf8() << "\"";
}

void ArkTSGen::SerializeNumber(size_t number)
{
    ss_ << number;
}

void ArkTSGen::SerializeNumber(double number)
{
    if (std::isinf(number)) {
        ss_ << "\"Infinity\"";
    } else {
        ss_ << number;
    }
}

void ArkTSGen::SerializeBoolean(bool boolean)
{
    ss_ << (boolean ? "true" : "false");
}

void ArkTSGen::SerializeConstant(Property::Constant constant)
{
    switch (constant) {
        case Property::Constant::PROP_NULL: {
            ss_ << "null";
            break;
        }
        case Property::Constant::EMPTY_ARRAY: {
            ss_ << "[]";
            break;
        }
        case Property::Constant::PROP_UNDEFINED: {
            ss_ << "undefined";
            break;
        }
        default: {
            std::cout << "S1" << std::endl;
            UNREACHABLE();
        }
    }
}

void ArkTSGen::SerializePropList(std::initializer_list<ArkTSGen::Property> props)
{
    Wrap(
        [this, &props]() -> void {
            for (const auto *it = props.begin(); it != props.end(); ++it) {
                Serialize(*it);
                if (std::next(it) != props.end()) {
                    ss_ << ',';
                }
            }
        }
    );
}

void ArkTSGen::SerializeArray(std::vector<const ir::AstNode *> array)
{
    Wrap(
        [this, &array]() -> void {
            for (auto it = array.begin(); it != array.end(); ++it) {
                if (dumpNodeOnly_) {
                    EmitStatement(*it);
                } else {
                    ss_ << std::endl;
                    Indent();
                    SerializeObject(*it);
                }

                if (std::next(it) != array.end()) {
                    ss_ << ',';
                }
            }
        },
        '[', ']');
}

void ArkTSGen::SerializeObject(const ir::AstNode *object)
{
    // Wrap(   
    //     [this, object]() -> void {
    //         object->Dump(this);
    //         SerializeLoc(object->Range());
    //     }
    // );
}

void ArkTSGen::Wrap(const WrapperCb &cb, char delimStart, char delimEnd)
{
    ss_ << delimStart;

    if (dumpNodeOnly_) {
        cb();
    } else {
        indent_++;
        cb();
        ss_ << std::endl;
        indent_--;
        Indent();
    }

    ss_ << delimEnd;
}


void ArkTSGen::Indent()
{
    for (int32_t i = 0; i < indent_; i++) {
        ss_ << "  ";
    }
}

}  // namespace panda::es2panda::ir

```

`arkts.h`:

```h
#ifndef ES2PANDA_IR_ASTDUMP_H
#define ES2PANDA_IR_ASTDUMP_H

#include "ir_interface.h"
#include "compiler/optimizer/pass.h"
#include "compiler/optimizer/ir/basicblock.h"
#include "compiler/optimizer/ir/graph.h"
#include "compiler/optimizer/ir/graph_visitor.h"
#include "utils/logger.h"




#include <ir/astNode.h>
#include <lexer/token/sourceLocation.h>
#include <lexer/token/tokenType.h>
#include <util/ustring.h>

#include "ast.h"

#include <sstream>
#include <variant>

namespace panda::es2panda::ir {

class ArkTSGen {
public:
    class Nullable {
    public:
        explicit Nullable(const ir::AstNode *node) : node_(node) {}

        const ir::AstNode *Node() const
        {
            return node_;
        }

    private:
        const ir::AstNode *node_;
    };

    class Optional {
    public:
        using Val = std::variant<const char *, const ir::AstNode *, bool>;
        explicit Optional(const ir::AstNode *node) : value_(node) {}
        explicit Optional(const char *string) : value_(const_cast<char *>(string)) {}
        explicit Optional(bool boolean) : value_(boolean) {}

        const Val &Value() const
        {
            return value_;
        }

    private:
        Val value_;
    };

    class Property {
    public:
        class Ignore {
        public:
            Ignore() = default;
        };

        enum class Constant {
            PROP_NULL,
            EMPTY_ARRAY,
            PROP_UNDEFINED
        };

        using Val =
            std::variant<const char *, lexer::TokenType, std::initializer_list<Property>, util::StringView, bool,
                         double, const ir::AstNode *, std::vector<const ir::AstNode *>, Constant, Nullable, Ignore>;

        Property(const char *string) : value_(string) {}
        Property(util::StringView str) : value_(str) {}
        Property(bool boolean) : value_(boolean) {}
        Property(double number) : value_(number) {}
        Property(lexer::TokenType token) : value_(token) {}
        Property(std::initializer_list<Property> props) : value_(props) {}
        Property(const ir::AstNode *node) : value_(const_cast<ir::AstNode *>(node)) {}

        Property(Constant constant) : value_(constant) {}
        Property(Nullable nullable) 
        {
            if (nullable.Node()) {
                value_ = nullable.Node();
            } else {
                value_ = Property::Constant::PROP_NULL;
            }
        }

        Property(Optional optional)
        {
            const auto &value = optional.Value();
            if (std::holds_alternative<const ir::AstNode *>(value) && std::get<const ir::AstNode *>(value)) {
                value_ = std::get<const ir::AstNode *>(value);
                return;
            }

            if (std::holds_alternative<const char *>(value) && std::get<const char *>(value)) {
                value_ = std::get<const char *>(value);
                return;
            }

            if (std::holds_alternative<bool>(value) && std::get<bool>(value)) {
                value_ = std::get<bool>(value);
                return;
            }

            value_ = Ignore();
        }

        template <typename T>
        Property(const ArenaVector<T> &array)
        {
            if (array.empty()) {
                value_ = Constant::EMPTY_ARRAY;
                return;
            }

            std::vector<const ir::AstNode *> nodes;
            nodes.reserve(array.size());

            for (auto &it : array) {
                nodes.push_back(it);
            }

            value_ = std::move(nodes);
        }

        const char *Key() const
        {
            return key_;
        }

        const Val &Value() const
        {
            return value_;
        }

    private:
        const char *key_;
        Val value_ {false};
    };

    explicit ArkTSGen(const BlockStatement *program, util::StringView sourceCode);
    explicit ArkTSGen(const ir::AstNode *node);

    void EmitStatement(const ir::AstNode *node);

    void Add(std::initializer_list<Property> props);
    void Add(const ArkTSGen::Property &prop);

    static const char *ModifierToString(ModifierFlags flags);
    static const char *TypeOperatorToString(TSOperatorType operatorType);

    std::string Str() const
    {
        return ss_.str();
    }

private:
    using WrapperCb = std::function<void()>;

    template <typename T>
    void AddList(T props)
    {
        for (auto it = props.begin(); it != props.end();) {
            Serialize(*it);

            do {
                if (++it == props.end()) {
                    return;
                }
            } while (std::holds_alternative<Property::Ignore>((*it).Value()));

            ss_ << ',';
        }
    }

    void Indent();

    void EmitBlockStatement(const ir::AstNode *node);

    void writeTrailingSemicolon(); //;
    void writeSpace();
    void writeLeftBrace();    // {
    void writeRightBrace();   // }
    void writeLeftBracket();  // [
    void writeRightBracket(); // ]

    void writeLeftParentheses(); // (
    void writeRightParentheses(); // )
    

    void writeColon();// :
    void writeEqual();// =
    void writeComma();// ,
    void writeDot(); // .
    void writeSpreadDot(); // ...
    void writeKeyWords(std::string keyword); 
    void writeNewLine();
    void writeIndent();

    void EmitExpression(const ir::AstNode *node);
    void EmitExpressionStatement(const ir::AstNode *node);
    void EmitVariableDeclarationStatement(const ir::AstNode *node);
    void EmitVariableDeclaratorStatement(const ir::AstNode *node);
    void EmitReturnStatement(const ir::AstNode *node);
    void EmitBreakStatement(const ir::AstNode *node);

    void EmitDebuggerStatement(const ir::AstNode *node);
    void EmitIfStatement(const ir::AstNode *node);
    void EmitTryStatement(const ir::AstNode *node);
    void EmitThrowStatement(const ir::AstNode *node);
    void EmitWhileStatement(const ir::AstNode *node);
    void EmitDoWhileStatement(const ir::AstNode *node);

    void EmitFunctionDeclaration(const ir::AstNode *node);

    void Serialize(const ArkTSGen::Property &prop);
    void SerializePropKey(const char *str);
    void SerializeString(const char *str);
    void SerializeString(const util::StringView &str);
    void SerializeNumber(size_t number);
    void SerializeNumber(double number);
    void SerializeBoolean(bool boolean);
    void SerializeObject(const ir::AstNode *object);
    void SerializeToken(lexer::TokenType token);
    void SerializePropList(std::initializer_list<ArkTSGen::Property> props);
    void SerializeConstant(Property::Constant constant);
    void Wrap(const WrapperCb &cb, char delimStart = '{', char delimEnd = '}');

    void SerializeArray(std::vector<const ir::AstNode *> array);

    lexer::LineIndex index_;
    std::stringstream ss_;
    int32_t indent_;
    int32_t singleindent_ = 2;
    bool dumpNodeOnly_ = true;





};
}  // namespace panda::es2panda::ir

#endif  // ASTDUMP_H

```

`ast.cpp`:

```cpp
#include "ast.h"

void handleError(const std::string& errorMessage) {
    std::cerr << "Error: " << errorMessage << std::endl;
    std::exit(EXIT_FAILURE); 
}

```

`ast.h`:

```h
#ifndef DECOMPILER_H
#define DECOMPILER_H

#include "../ets_frontend/es2panda/es2panda.h"
#include "../ets_frontend/es2panda/parser/program/program.h"

/////////////////////////////////////////////////////
#include "../ets_frontend/es2panda/ir/base/catchClause.h"
#include "../ets_frontend/es2panda/ir/base/classStaticBlock.h"
#include "../ets_frontend/es2panda/ir/base/decorator.h"
#include "../ets_frontend/es2panda/ir/base/scriptFunction.h"


#include "../ets_frontend/es2panda/ir/expressions/assignmentExpression.h"
#include "../ets_frontend/es2panda/ir/expressions/binaryExpression.h"
#include "../ets_frontend/es2panda/ir/expressions/callExpression.h"
#include "../ets_frontend/es2panda/ir/expressions/classExpression.h"
#include "../ets_frontend/es2panda/ir/expressions/functionExpression.h"
#include "../ets_frontend/es2panda/ir/expressions/memberExpression.h"
#include "../ets_frontend/es2panda/ir/expressions/objectExpression.h"
#include "../ets_frontend/es2panda/ir/expressions/sequenceExpression.h"
#include "../ets_frontend/es2panda/ir/expressions/templateLiteral.h"
#include "../ets_frontend/es2panda/ir/expressions/thisExpression.h"
#include "../ets_frontend/es2panda/ir/expressions/unaryExpression.h"
#include "../ets_frontend/es2panda/ir/expressions/arrayExpression.h"


#include "../ets_frontend/es2panda/ir/base/property.h"
#include "../ets_frontend/es2panda/ir/base/spreadElement.h"


#include "../ets_frontend/es2panda/ir/expressions/literals/bigIntLiteral.h"
#include "../ets_frontend/es2panda/ir/expressions/literals/numberLiteral.h"
#include "../ets_frontend/es2panda/ir/expressions/literals/stringLiteral.h"
#include "../ets_frontend/es2panda/ir/expressions/literals/booleanLiteral.h"
#include "../ets_frontend/es2panda/ir/expressions/literals/nullLiteral.h"
#include "../ets_frontend/es2panda/ir/expressions/literals/regExpLiteral.h"
#include "../ets_frontend/es2panda/ir/expressions/literals/taggedLiteral.h"


#include "../ets_frontend/es2panda/ir/expressions/memberExpression.h"
#include "../ets_frontend/es2panda/ir/expressions/objectExpression.h"
#include "../ets_frontend/es2panda/ir/expressions/sequenceExpression.h"
#include "../ets_frontend/es2panda/ir/expressions/templateLiteral.h"
#include "../ets_frontend/es2panda/ir/expressions/thisExpression.h"

#include "../ets_frontend/es2panda/ir/expressions/newExpression.h"

#include "../ets_frontend/es2panda/ir/module/exportDefaultDeclaration.h"
#include "../ets_frontend/es2panda/ir/module/exportNamedDeclaration.h"
#include "../ets_frontend/es2panda/ir/statements/blockStatement.h"
#include "../ets_frontend/es2panda/ir/statements/classDeclaration.h"
#include "../ets_frontend/es2panda/ir/statements/expressionStatement.h"
#include "../ets_frontend/es2panda/ir/statements/forInStatement.h"
#include "../ets_frontend/es2panda/ir/statements/forOfStatement.h"
#include "../ets_frontend/es2panda/ir/statements/forUpdateStatement.h"
#include "../ets_frontend/es2panda/ir/statements/functionDeclaration.h"
#include "../ets_frontend/es2panda/ir/statements/returnStatement.h"
#include "../ets_frontend/es2panda/ir/statements/switchStatement.h"
#include "../ets_frontend/es2panda/ir/statements/variableDeclaration.h"
#include "../ets_frontend/es2panda/ir/statements/variableDeclarator.h"
#include "../ets_frontend/es2panda/ir/statements/debuggerStatement.h"
#include "../ets_frontend/es2panda/ir/statements/ifStatement.h"
#include "../ets_frontend/es2panda/ir/statements/tryStatement.h"
#include "../ets_frontend/es2panda/ir/statements/throwStatement.h"


#include "../ets_frontend/es2panda/ir/statements/whileStatement.h"
#include "../ets_frontend/es2panda/ir/statements/doWhileStatement.h"

#include "../ets_frontend/es2panda/ir/statements/breakStatement.h"

#include "../ets_frontend/es2panda/ir/ts/tsConstructorType.h"
#include "../ets_frontend/es2panda/ir/ts/tsEnumDeclaration.h"
#include "../ets_frontend/es2panda/ir/ts/tsEnumMember.h"
#include "../ets_frontend/es2panda/ir/ts/tsFunctionType.h"
#include "../ets_frontend/es2panda/ir/ts/tsImportEqualsDeclaration.h"
#include "../ets_frontend/es2panda/ir/ts/tsInterfaceDeclaration.h"
#include "../ets_frontend/es2panda/ir/ts/tsMethodSignature.h"
#include "../ets_frontend/es2panda/ir/ts/tsModuleBlock.h"
#include "../ets_frontend/es2panda/ir/ts/tsModuleDeclaration.h"
#include "../ets_frontend/es2panda/ir/ts/tsParameterProperty.h"
#include "../ets_frontend/es2panda/ir/ts/tsPrivateIdentifier.h"
#include "../ets_frontend/es2panda/ir/ts/tsQualifiedName.h"
#include "../ets_frontend/es2panda/ir/ts/tsSignatureDeclaration.h"
#include "../ets_frontend/es2panda/ir/ts/tsTypeParameterDeclaration.h"


#include "../ets_frontend/es2panda/parser/parserImpl.h"

//////////////////////////////////////////////////////////////////////////////
#include "assembler/annotation.h"
#include "assembler/assembly-function.h"
#include "assembler/assembly-ins.h"

#include "ir_interface.h"
#include "compiler/optimizer/pass.h"
#include "compiler/optimizer/ir/basicblock.h"
#include "compiler/optimizer/ir/graph.h"
#include "compiler/optimizer/ir/graph_visitor.h"
#include "utils/logger.h"

#include "compiler/optimizer/analysis/loop_analyzer.h"


void handleError(const std::string& errorMessage);

#endif



```

`astgen.cpp`:

```cpp
#include "astgen.h"
#include "common.h"

#include "astgen_ecma.inl"
#include "tagged_value.h"

namespace panda::bytecodeopt {

using panda_file::LiteralTag;


void DoLda(compiler::Register reg, std::vector<pandasm::Ins> &result)
{
    if (reg != compiler::ACC_REG_ID) {
        result.emplace_back(pandasm::Create_LDA(reg));
    }
}

void DoSta(compiler::Register reg, std::vector<pandasm::Ins> &result)
{
    if (reg != compiler::ACC_REG_ID) {
        result.emplace_back(pandasm::Create_STA(reg));
    }
}


void AstGen::VisitTryBegin(const compiler::BasicBlock *bb)
{
    std::cout << "[+] VisitTryBegin  >>>>>>>>>>>>>>>>>" << std::endl;
    std::cout << "[-] VisitTryBegin  >>>>>>>>>>>>>>>>>" << std::endl;
}


BasicBlock* AstGen::find_nearest_visited_pred(const std::vector<BasicBlock*>& visited, BasicBlock* block) {
    if (visited.empty()) return nullptr;
    
    ArenaVector<BasicBlock*> preds = block->GetPredsBlocks();
    if (preds.empty()) return nullptr;
    
    std::unordered_set<BasicBlock*> pred_set(preds.begin(), preds.end());
    

    for (auto it = visited.rbegin(); it != visited.rend(); ++it) {
        if (pred_set.find(*it) != pred_set.end()) {
            return *it;  
        }
    }
    
    return nullptr; 
}

bool AstGen::RunImpl()
{
    
    Reserve(function_->ins.size());
    if (!GetGraph()->GetTryBeginBlocks().empty()) {
        // Workaround for AOT and JIT
        result_.emplace_back(pandasm::Create_NOP());
    }

    std::vector<BasicBlock *> visited;

    for (auto *bb : GetGraph()->GetBlocksLinearOrder()) {
        
        if(bb->IsLoopValid() && bb->IsLoopHeader() ){
            judge_looptype(bb);
            /////////////////////////////////////////////////////////////////
            ArenaVector<panda::es2panda::ir::Statement *> statements(this->parser_program_->Allocator()->Adapter());
            auto new_block_statement = this->parser_program_->Allocator()->New<panda::es2panda::ir::BlockStatement>(nullptr, std::move(statements));
            this->whileheader2redundant[bb] = new_block_statement;
        }

        std::cout << "@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@ visit bbid: " << bb->GetId() << std::endl;

        ///////////////////////////////////////////////////////////////////////////////////////////////////

        
        auto nearestpre = this->find_nearest_visited_pred(visited, bb);
        if(nearestpre != nullptr && this->bb2acc2expression[nearestpre] != nullptr){
            std::cout << "!!!!!!!!!!!!!!!!!!!! found pre id for bb2acc2expression: " << nearestpre->GetId() << std::endl;
            this->bb2acc2expression[bb] = this->bb2acc2expression[nearestpre];
        }else{
            std::cout << "!!!!!!!!!!!!!!!!!!!! not found pre id for bb2acc2expression: " << "curid: " << bb->GetId()  << std::endl;
            this->bb2acc2expression[bb] = nullptr;
        }
        ///////////////////////////////////////////////////////////////////////////////////////////////////

        if(bb != this->GetGraph()->GetStartBlock()) {
            if(nearestpre != nullptr && this->bb2lexicalenvstack[nearestpre] != nullptr){
                std::cout << "!!!!!!!!!!!!!!!!!!!! found pre id for bb2lexicalenvstack: " << nearestpre->GetId() << std::endl;
                this->bb2lexicalenvstack[bb] = new LexicalEnvStack(*this->bb2lexicalenvstack[nearestpre]);
                std::cout << "size: " << (*this->bb2lexicalenvstack[nearestpre]).size()  << std::endl;
            }else{
                std::cout << "!!!!!!!!!!!!!!!!!!!! not found pre id for bb2lexicalenvstack: "<< "curid: " << bb->GetId()  << std::endl;
                this->bb2lexicalenvstack[bb] = new LexicalEnvStack();
            }
        }
        visited.push_back(bb);        
        ///////////////////////////////////////////////////////////////////////////////////////////////////
        for (const auto &inst : bb->AllInsts()) {
            [[maybe_unused]] auto start = GetResult().size();

            VisitInstruction(inst);

            if (!GetStatus()) {
                return false;
            }

            [[maybe_unused]] auto end = GetResult().size();

            ASSERT(end >= start);
        }

        // check whehter add break statement
        if(!bb->IsStartBlock()){
            BasicBlock* father = bb->GetPredecessor(0);
            if(father->IsLoopValid() && !father->GetLoop()->IsRoot()){
                if(bb->GetLoop() != father->GetLoop()  ){
                    if(bb->GetSuccsBlocks().size() == 1){
                        //std::cout << "truesucc: " << bb->GetTrueSuccessor()->GetId() << ", falsesucc: " <<  loop2exit[father->GetLoop()]->GetId() << std::endl;
                        if(bb->GetTrueSuccessor() == loop2exit[father->GetLoop()]){ 

                            this->get_blockstatement_byid(bb);
                            auto breakstatement = AllocNode<es2panda::ir::BreakStatement>(this);

                            this->add_insAst_to_blockstatemnt_by_block(bb, breakstatement);

                        }
                    }

                }
            }
        }

    }

    if (!GetStatus()) {
        return false;
    }
    // Visit try-blocks in order they were declared
    for (auto *bb : GetGraph()->GetTryBeginBlocks()) {
        VisitTryBegin(bb);
    }
    function_->ins = std::move(GetResult());
    function_->catch_blocks = catch_blocks_;
    return true;
}


void AstGen::VisitSpillFill(GraphVisitor *visitor, Inst *inst_base)
{
    std::cout << "[+] VisitSpillFill  >>>>>>>>>>>>>>>>>" << std::endl;
    auto *enc = static_cast<AstGen *>(visitor);
    auto inst = inst_base->CastToSpillFill();

    for (auto sf : inst->GetSpillFills()) {
        if(sf.SrcType() != compiler::LocationType::REGISTER || sf.DstType() != compiler::LocationType::REGISTER ){
            handleError("VisitSpillFill # unsupoort SpillFill type");
        }
        auto it = enc->reg2expression.find(sf.SrcValue());
        if (it == enc->reg2expression.end()) {
            std::cout << "VisitSpillFill # SpillFill none register"  << std::endl; 
        }else{
            //enc->set_expression_by_register(inst, sf.DstValue(), *enc->get_expression_by_register(inst, sf.SrcValue()));
        }
    }
    std::cout << "[-] VisitSpillFill  >>>>>>>>>>>>>>>>>" << std::endl;
}


void AstGen::VisitConstant(GraphVisitor *visitor, Inst *inst_base)
{
    std::cout << "[+] VisitConstant  >>>>>>>>>>>>>>>>>" << std::endl;
    auto *enc = static_cast<AstGen *>(visitor);
    auto inst = inst_base->CastToConstant();
    auto type = inst->GetType();
   
    es2panda::ir::Expression* number;
    switch (type) {
        case compiler::DataType::INT64:
        case compiler::DataType::UINT64:
            number = AllocNode<es2panda::ir::NumberLiteral>(enc, 
                                                            inst->GetInt64Value()
                                                        );
            break;
        case compiler::DataType::FLOAT64:
            number = AllocNode<es2panda::ir::NumberLiteral>(enc, 
                                                            inst->GetDoubleValue()
                                                        );
            break;
        case compiler::DataType::INT32:
        case compiler::DataType::UINT32:
            number = AllocNode<es2panda::ir::NumberLiteral>(enc, 
                                                            inst->GetInt32Value()
                                                        );
            break;
        default:
            std::cout << "S3" << std::endl;
            UNREACHABLE();
            LOG(ERROR, BYTECODE_OPTIMIZER) << "VisitConstant with unknown type" << type;
            enc->success_ = false;
    }

    enc->set_expression_by_register(inst, inst->GetDstReg(), number);
    
    std::cout << "[-] VisitConstant  >>>>>>>>>>>>>>>>>" << std::endl;
}


void AstGen::VisitIf(GraphVisitor *v, Inst *inst_base)
{
    std::cout << "[+] VisitIf  >>>>>>>>>>>>>>>>>" << std::endl;
    auto enc = static_cast<AstGen *>(v);
    auto inst = inst_base->CastToIf();

    auto left_expression = *enc->get_expression_by_id(inst, 0);
    auto right_expression = *enc->get_expression_by_id(inst, 1);

    panda::es2panda::ir::Expression* test_expression;

    switch (inst->GetCc()) {
        case compiler::CC_EQ:
            test_expression = AllocNode<es2panda::ir::BinaryExpression>(enc, 
                                                        left_expression,
                                                        right_expression,
                                                        BinIntrinsicIdToToken(compiler::RuntimeInterface::IntrinsicId::EQ_IMM8_V8));
            break;
        case compiler::CC_NE:
            test_expression = AllocNode<es2panda::ir::BinaryExpression>(enc, 
                                                        left_expression,
                                                        right_expression,
                                                        BinIntrinsicIdToToken(compiler::RuntimeInterface::IntrinsicId::NOTEQ_IMM8_V8));
            break;
        default:
            std::cout << "S5" << std::endl;
            UNREACHABLE();
    }
    /////////////////////////////////////////////////////////////////////////////////////////////////
    /////////////////////////////////////////////////////////////////////////////////////////////////
    /// deal with while/do-while
    auto block = inst->GetBasicBlock();
    es2panda::ir::BlockStatement* block_statement = enc->get_blockstatement_byid(block);

    if(block->IsLoopValid() && block->IsLoopHeader()){
        std::cout << "1%%%%%%%%%%%%%%%%%!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!" << std::endl;
        if(enc->loop2type[block->GetLoop()] == 1){
            std::cout << "[+] do-while ===" << std::endl;

            std::cout << "[-] do-while ===" << std::endl;
        }else{
            std::cout << "[+] while ===" << std::endl;

            es2panda::ir::BlockStatement* true_statements =   enc->get_blockstatement_byid(inst->GetBasicBlock()->GetTrueSuccessor());
            es2panda::ir::BlockStatement* false_statements =  enc->get_blockstatement_byid(inst->GetBasicBlock()->GetFalseSuccessor());
    
            if(enc->loop2exit[inst->GetBasicBlock()->GetLoop() ] == inst->GetBasicBlock()->GetTrueSuccessor() ){
                std::swap(true_statements, false_statements);
            }

            auto whilestatement = AllocNode<es2panda::ir::WhileStatement>(enc,
                                    nullptr,
                                    test_expression, 
                                    true_statements);

            enc->add_insAst_to_blockstatemnt_by_inst(inst, whilestatement);
            enc->add_insAst_to_blockstatemnt_by_inst(inst, false_statements);

            std::cout << "[-] while ===" << std::endl;
        }
    }else{
        std::cout << "2%%%%%%%%%%%%%%%%%!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!" << std::endl;
        es2panda::ir::BlockStatement* true_statements =   enc->get_blockstatement_byid(inst->GetBasicBlock()->GetTrueSuccessor());
        es2panda::ir::BlockStatement* false_statements =  enc->get_blockstatement_byid(inst->GetBasicBlock()->GetFalseSuccessor());

        auto ifStatement = AllocNode<es2panda::ir::IfStatement>(enc, test_expression, true_statements, false_statements);
        true_statements->SetParent(block_statement);
        false_statements->SetParent(block_statement);
        
        enc->add_insAst_to_blockstatemnt_by_inst(inst, ifStatement);

    }

    /////////////////////////////////////////////////////////////////////////////////////////////////
    /////////////////////////////////////////////////////////////////////////////////////////////////

    std::cout << "[-] VisitIf  >>>>>>>>>>>>>>>>>" << std::endl;
}

#if defined(ENABLE_BYTECODE_OPT) && defined(PANDA_WITH_ECMASCRIPT)
static std::optional<coretypes::TaggedValue> IsEcmaConstTemplate(Inst const *inst)
{
    if (inst->GetOpcode() != compiler::Opcode::CastValueToAnyType) {
        return {};
    }
    auto cvat_inst = inst->CastToCastValueToAnyType();
    if (!cvat_inst->GetInput(0).GetInst()->IsConst()) {
        return {};
    }
    auto const_inst = cvat_inst->GetInput(0).GetInst()->CastToConstant();

    switch (cvat_inst->GetAnyType()) {
        case compiler::AnyBaseType::ECMASCRIPT_UNDEFINED_TYPE:
            return coretypes::TaggedValue(coretypes::TaggedValue::VALUE_UNDEFINED);
        case compiler::AnyBaseType::ECMASCRIPT_INT_TYPE:
            return coretypes::TaggedValue(static_cast<int32_t>(const_inst->GetIntValue()));
        case compiler::AnyBaseType::ECMASCRIPT_DOUBLE_TYPE:
            return coretypes::TaggedValue(const_inst->GetDoubleValue());
        case compiler::AnyBaseType::ECMASCRIPT_BOOLEAN_TYPE:
            return coretypes::TaggedValue(static_cast<bool>(const_inst->GetInt64Value() != 0));
        case compiler::AnyBaseType::ECMASCRIPT_NULL_TYPE:
            return coretypes::TaggedValue(coretypes::TaggedValue::VALUE_NULL);
        default:
            return {};
    }
}
#endif


uint32_t onlyOneBranch(BasicBlock* father, AstGen * enc){
    //std::cout << "if block: " << std::to_string(father->GetId()) << std::endl;
    auto true_branch = father->GetTrueSuccessor();
    auto false_branch = father->GetFalseSuccessor();

    // 0: if-and-else

    // 1: only if

    // 2: only else

    // loop-header === 0
    if(father->IsLoopValid() && father->IsLoopHeader()){
        return 0;
    }

    BasicBlock* analysis_block = nullptr;
    if(true_branch->GetPredsBlocks().size() == 2){
        analysis_block = true_branch;
    }else if(false_branch->GetPredsBlocks().size() == 2){
        analysis_block = false_branch;
    }else if(true_branch->GetPredsBlocks().size() == 1 && false_branch->GetPredsBlocks().size() == 1){
        return 0;
    }else{
        handleError("onlyOneBranch# not consider this case");
    }

    BasicBlock* other_father = nullptr;
    if(analysis_block->GetPredecessor(0) == father){
        other_father = analysis_block->GetPredecessor(1);
    }else{
        other_father = analysis_block->GetPredecessor(0);
    }
    std::cout << "true branch: " << std::to_string(true_branch->GetId()) << std::endl;
    std::cout << "false_branch: " << std::to_string(false_branch->GetId()) << std::endl;
    std::cout << "other_fater: " << std::to_string(other_father->GetId()) << std::endl;

    while(other_father != father && other_father->GetId() !=0 ){
        other_father = other_father->GetPredecessor(0);
    }


    if(other_father == father ){
        if(analysis_block == true_branch){
            return 2;
        }else{
            return 1;
        }
    }else if(other_father->GetId() ==0 ){
        return 0;
    }else{
        //std::cout << "end other_father: " << std::to_string(other_father->GetId()) << std::endl;
        handleError("onlyOneBranch# found method is bad");
    }
    return 0;
}

void AstGen::VisitIfImm(GraphVisitor *v, Inst *inst_base)
{
    std::cout << "[+] VisitIfImm  >>>>>>>>>>>>>>>>>" << std::endl;
    auto enc = static_cast<AstGen *>(v);
    auto inst = inst_base->CastToIfImm();
    auto imm = inst->GetImm();
    if (imm == 0) {
        auto src_expression = *enc->get_expression_by_id(inst, 0);

        panda::es2panda::ir::Expression* test_expression;


        auto ret = onlyOneBranch(inst->GetBasicBlock(), enc);

        es2panda::ir::BlockStatement* true_statements = nullptr;
        es2panda::ir::BlockStatement* false_statements = nullptr;
        
        if(ret == 0){
            enc->specialblockid.insert(inst->GetBasicBlock()->GetTrueSuccessor()->GetId());
            enc->specialblockid.insert(inst->GetBasicBlock()->GetFalseSuccessor()->GetId());
            true_statements =   enc->get_blockstatement_byid(inst->GetBasicBlock()->GetTrueSuccessor());
            false_statements =  enc->get_blockstatement_byid(inst->GetBasicBlock()->GetFalseSuccessor());
        }else if(ret == 1){
            enc->specialblockid.insert(inst->GetBasicBlock()->GetTrueSuccessor()->GetId());
            true_statements =   enc->get_blockstatement_byid(inst->GetBasicBlock()->GetTrueSuccessor());
        }else{
            enc->specialblockid.insert(inst->GetBasicBlock()->GetFalseSuccessor()->GetId());
            true_statements =   enc->get_blockstatement_byid(inst->GetBasicBlock()->GetFalseSuccessor());
        }

        panda::compiler::RuntimeInterface::IntrinsicId cmpid;
        switch (inst->GetCc()) {
            case compiler::CC_EQ:
                if(ret != 2 ){
                    cmpid = compiler::RuntimeInterface::IntrinsicId::EQ_IMM8_V8;

                }else{
                    cmpid = compiler::RuntimeInterface::IntrinsicId::NOTEQ_IMM8_V8;
                }

                break;
            case compiler::CC_NE:
                if(ret != 2 ){
                    cmpid = compiler::RuntimeInterface::IntrinsicId::NOTEQ_IMM8_V8;

                }else{
                    cmpid = compiler::RuntimeInterface::IntrinsicId::EQ_IMM8_V8;
                }
                break;
            default:
                std::cout << "S5" << std::endl;
                UNREACHABLE();
        }
        test_expression = AllocNode<es2panda::ir::BinaryExpression>(enc, 
                                                    src_expression,
                                                    enc->constant_zero,
                                                    BinIntrinsicIdToToken(cmpid));

        /////////////////////////////////////////////////////////////////////////////////////////////////
        /////////////////////////////////////////////////////////////////////////////////////////////////
        /// deal with while/do-while
        auto block = inst->GetBasicBlock();
        if(enc->backedge2dowhileloop.find(block) != enc->backedge2dowhileloop.end()){
            std::cout << "[+] do-while =====" << std::endl;
            compiler::Loop* loop = block->GetLoop();
            auto back_edges = loop->GetBackEdges();
            enc->logbackedgeid(back_edges);

            es2panda::ir::DoWhileStatement* dowhilestatement;
            if(block->GetTrueSuccessor() == loop->GetHeader()){
                dowhilestatement = AllocNode<es2panda::ir::DoWhileStatement>(enc,
                    nullptr,
                    true_statements,
                    src_expression
                );
            }else{
                dowhilestatement = AllocNode<es2panda::ir::DoWhileStatement>(enc,
                        nullptr,
                        true_statements,
                        test_expression
                        );
            }
            enc->add_insAst_to_blockstatemnt_by_block(loop->GetPreHeader(), dowhilestatement);
            enc->add_insAst_to_blockstatemnt_by_block(loop->GetPreHeader(), false_statements);
            std::cout << "[-] do-while =====" << std::endl;
        }else if(block->IsLoopValid() && block->IsLoopHeader() && enc->loop2type[block->GetLoop()] == 0 ){
            std::cout << "[+] while ===" << std::endl;
            compiler::Loop* loop = block->GetLoop();
            auto back_edges = loop->GetBackEdges();
            enc->logbackedgeid(back_edges);

            es2panda::ir::WhileStatement* whilestatement;
            if( std::find(loop->GetBlocks().begin(), loop->GetBlocks().end(), block->GetFalseSuccessor()) != loop->GetBlocks().end() ){
                if(enc->whileheader2redundant[block]->Statements().size() != 0){
                    // add redundant statement in while-header
                    enc->add_insAst_to_blockstatemnt_by_block(block->GetFalseSuccessor(), enc->whileheader2redundant[block] );
                }

                std::swap(true_statements, false_statements);
                whilestatement = AllocNode<es2panda::ir::WhileStatement>(enc,
                        nullptr,
                        src_expression, 
                        true_statements
                        );
            }else{
                if(enc->whileheader2redundant[block]->Statements().size() != 0){
                    // add redundant statement in while-header
                    enc->add_insAst_to_blockstatemnt_by_block(block->GetTrueSuccessor(), enc->whileheader2redundant[block] );
                }
                whilestatement = AllocNode<es2panda::ir::WhileStatement>(enc,
                        nullptr,
                        test_expression, 
                        true_statements
                        );
            }

            enc->add_insAst_to_blockstatemnt_by_inst(inst, whilestatement);
            enc->add_insAst_to_blockstatemnt_by_block(loop->GetPreHeader(), enc->get_blockstatement_byid(block));
            enc->add_insAst_to_blockstatemnt_by_block(loop->GetPreHeader(), false_statements);

            std::cout << "[-] while ===" << std::endl;
        }else{
            es2panda::ir::IfStatement* ifStatement;

            if(ret == 2){
                ifStatement = AllocNode<es2panda::ir::IfStatement>(enc, test_expression, true_statements, false_statements);
            }else{
                if(inst->GetCc() == compiler::CC_EQ){
                   std::swap(true_statements, false_statements); 
                }

                ifStatement = AllocNode<es2panda::ir::IfStatement>(enc, src_expression, true_statements, false_statements);

            }

            enc->add_insAst_to_blockstatemnt_by_inst(inst, ifStatement);

        }
        /////////////////////////////////////////////////////////////////////////////////////////////////

        //true_statements->SetParent(block);
        //false_statements->SetParent(block);
    }
    std::cout << "[-] VisitIfImm  >>>>>>>>>>>>>>>>>" << std::endl;
}


void AstGen::VisitLoadString(GraphVisitor *v, Inst *inst_base)
{
    std::cout << "[+] VisitLoadString  >>>>>>>>>>>>>>>>>" << std::endl;
    pandasm::Ins ins;
    auto enc = static_cast<AstGen *>(v);
    auto inst = inst_base->CastToLoadString();

    std::string source_str = enc->ir_interface_->GetStringIdByOffset(inst->GetTypeId()); 
    panda::es2panda::util::StringView name_view = panda::es2panda::util::StringView(*new std::string(source_str));
    
    auto src_expression  = AllocNode<es2panda::ir::StringLiteral>(enc, name_view);

    enc->set_expression_by_register(inst, inst->GetDstReg(), src_expression);
   

    std::cout << "[-] VisitLoadString  >>>>>>>>>>>>>>>>>" << std::endl;
}

void AstGen::VisitReturn(GraphVisitor *v, Inst *inst_base)
{
    std::cout << "[+] VisitReturn  >>>>>>>>>>>>>>>>>" << std::endl;
    pandasm::Ins ins;
    auto enc = static_cast<AstGen *>(v);
    auto inst = inst_base->CastToReturn();
    switch (inst->GetType()) {
        case compiler::DataType::ANY: {
#if defined(ENABLE_BYTECODE_OPT) && defined(PANDA_WITH_ECMASCRIPT)
            auto test_arg = IsEcmaConstTemplate(inst->GetInput(0).GetInst());
            if (test_arg.has_value() && test_arg->IsUndefined()) {
                enc->result_.emplace_back(pandasm::Create_RETURNUNDEFINED());
                break;
            }
#endif
            DoLda(inst->GetSrcReg(0), enc->result_);
            enc->result_.emplace_back(pandasm::Create_RETURN());
            break;
        }
        default:
            LOG(ERROR, BYTECODE_OPTIMIZER)
                << "Codegen for " << compiler::GetOpcodeString(inst->GetOpcode()) << " failed";
            enc->success_ = false;
    }
    std::cout << "[-] VisitReturn  >>>>>>>>>>>>>>>>>" << std::endl;
}

void AstGen::VisitCastValueToAnyType([[maybe_unused]] GraphVisitor *visitor, [[maybe_unused]] Inst *inst)
{
    std::cout << "[+] VisitCastValueToAnyType  >>>>>>>>>>>>>>>>>" << std::endl;
    auto enc = static_cast<AstGen *>(visitor);

    auto cvat = inst->CastToCastValueToAnyType();
    auto input = cvat->GetInput(0).GetInst()->CastToConstant();

    es2panda::ir::Expression* source = nullptr;
    switch (cvat->GetAnyType()) {
        case compiler::AnyBaseType::ECMASCRIPT_NULL_TYPE:
            source = enc->constant_null;
            break;

        case compiler::AnyBaseType::ECMASCRIPT_UNDEFINED_TYPE: {
            source = enc->constant_undefined;
            break;
        }

        case compiler::AnyBaseType::ECMASCRIPT_INT_TYPE: {
            source = AllocNode<es2panda::ir::NumberLiteral>(enc, 
                                                                input->CastToConstant()->GetIntValue()
                                            );
            break;
        }

        case compiler::AnyBaseType::ECMASCRIPT_DOUBLE_TYPE: {
            source = AllocNode<es2panda::ir::NumberLiteral>(enc, 
                                                                input->CastToConstant()->GetDoubleValue()
                                                        );
            break;
        }

        case compiler::AnyBaseType::ECMASCRIPT_BOOLEAN_TYPE: {
            uint64_t val = input->GetInt64Value();
            if (val != 0) {
                source = enc->constant_true;
            } else {
                source = enc->constant_false;
            }
            break;
        }

        case compiler::AnyBaseType::ECMASCRIPT_STRING_TYPE: {
            auto ls = cvat->GetInput(0).GetInst()->CastToLoadString();
            // auto ls_dst_reg = ls->GetDstReg();
            // source = *enc->get_expression_by_register(inst, ls_dst_reg);
            source = enc->id2expression[ls->GetId()];           
            break;
        }

        default:
           // UNREACHABLE();
            LOG(ERROR, BYTECODE_OPTIMIZER) << "VisitConstant with unknown type" ;
            enc->success_ = false;
    }

    enc->set_expression_by_register(inst, cvat->GetDstReg(), source);

    std::cout << "[-] VisitCastValueToAnyType  >>>>>>>>>>>>>>>>>" << std::endl;
}


void AstGen::VisitIntrinsic(GraphVisitor *visitor, Inst *inst_base)
{
    std::cout << "[+] VisitIntrinsic  >>>>>>>>>>>>>>>>>" << std::endl;
    ASSERT(inst_base->IsIntrinsic());
    VisitEcma(visitor, inst_base);
    std::cout << "[-] VisitIntrinsic  >>>>>>>>>>>>>>>>>" << std::endl;
}

void AstGen::VisitCatchPhi(GraphVisitor *visitor, Inst *inst)
{
    std::cout << "[+] VisitCatchPhi  >>>>>>>>>>>>>>>>>" << std::endl;
    // The Acc register stores the exception object.
    // Create an STA instruction if the exception is used later in virtual registers.
    
    if (inst->CastToCatchPhi()->IsAcc()) {
        std::cout << "cast to catchphi" << std::endl;
        auto enc = static_cast<AstGen *>(visitor);
        enc->set_expression_by_register(inst, inst->GetDstReg(), enc->constant_catcherror);
        bool hasRealUsers = false;
        for (auto &user : inst->GetUsers()) {
            if (!user.GetInst()->IsSaveState()) {
                hasRealUsers = true;
                break;
            }
        }
        if (hasRealUsers) {
            enc->set_expression_by_register(inst, inst->GetDstReg(), enc->constant_catcherror);
        }
    }
    std::cout << "[-] VisitCatchPhi  >>>>>>>>>>>>>>>>>" << std::endl;
}

#include "astgen_auxiins.cpp"
}  // namespace panda::bytecodeopt

```

`astgen.h`:

```h
#ifndef BYTECODE_OPTIMIZER_CODEGEN_H
#define BYTECODE_OPTIMIZER_CODEGEN_H

#include "ins_create_api.h"
#include "ast.h"
#include "lexicalenv.h"
#include "lca.h"

namespace panda::bytecodeopt {

using compiler::BasicBlock;
using compiler::Inst;
using compiler::Opcode;

void DoLda(compiler::Register reg, std::vector<pandasm::Ins> &result);
void DoSta(compiler::Register reg, std::vector<pandasm::Ins> &result);

class AstGen : public compiler::Optimization, public compiler::GraphVisitor {
public:
    explicit AstGen(compiler::Graph *graph, pandasm::Function *function,
        const BytecodeOptIrInterface *iface, pandasm::Program *prog,  es2panda::parser::Program* parser_program, 
        uint32_t methodoffset, std::map<uint32_t, LexicalEnvStack*>* method2lexicalenvstack, std::string fun_name)
        : compiler::Optimization(graph), function_(function), ir_interface_(iface), program_(prog), methodoffset(methodoffset),
        method2lexicalenvstack(method2lexicalenvstack), parser_program_(parser_program)
    {

        this->closure_count = 0;

        ArenaVector<es2panda::ir::Expression*> arguments(parser_program->Allocator()->Adapter());

        if(method2lexicalenvstack->find(methodoffset) != method2lexicalenvstack->end()){
            //std::cout << "XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX found lexicalenvstack " << std::endl;
            //auto x = (*this->method2lexicalenvstack)[methodoffset];
           // std::cout << "lexicalenvstack size: " << x->size() << std::endl;
        }else{
            //std::cout << "XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX not found lexicalenvstack " << std::endl;
            (*this->method2lexicalenvstack)[methodoffset] = new LexicalEnvStack();
        }
        this->bb2lexicalenvstack[graph->GetStartBlock()] = (*this->method2lexicalenvstack)[methodoffset];

        std::cout << "start id: " << graph->GetStartBlock()->GetId() << " , size: " << (*this->bb2lexicalenvstack[graph->GetStartBlock()]).size() << std::endl;
        

        for (size_t i = 0; i < function->GetParamsNum(); ++i) {
            panda::es2panda::util::StringView tmp_name_view = panda::es2panda::util::StringView(*new std::string("arg"+std::to_string(i)));
            arguments.push_back(parser_program->Allocator()->New<panda::es2panda::ir::Identifier>(tmp_name_view));
        }

        ArenaVector<panda::es2panda::ir::Statement *> func_statements(parser_program->Allocator()->Adapter());
        auto body = parser_program->Allocator()->New<panda::es2panda::ir::BlockStatement>(nullptr, std::move(func_statements));
        panda::es2panda::ir::ScriptFunctionFlags flags_ {panda::es2panda::ir::ScriptFunctionFlags::NONE};
        auto funcNode = parser_program->Allocator()->New<panda::es2panda::ir::ScriptFunction>(nullptr, std::move(arguments), nullptr, body, nullptr, flags_, true, false);
        

        panda::es2panda::util::StringView name_view = panda::es2panda::util::StringView(*new std::string(fun_name));
        auto funname_id = parser_program->Allocator()->New<panda::es2panda::ir::Identifier>(name_view);
                

        funcNode->SetIdent(funname_id);
        auto funcDecl = parser_program->Allocator()->New<panda::es2panda::ir::FunctionDeclaration>(funcNode);

        auto program_block = parser_program->Ast();
        auto program_statements = program_block->Statements();

        // add 0 block statement
        program_block->AddStatementAtPos(program_statements.size(), funcDecl);

        
        this->id2block[0] = body;

        //this->lcaFinder = std::make_unique<LCAFinder>(graph);

    }
    ~AstGen() override = default;
    bool RunImpl() override;
    const char *GetPassName() const override
    {
        return "AstGen";
    }

    void Reserve(size_t res_size = 0)
    {
        if (res_size > 0) {
            result_.reserve(res_size);
        }
    }

    bool GetStatus() const
    {
        return success_;
    }

    const std::vector<pandasm::Ins> &GetResult() const
    {
        return result_;
    }

    std::vector<pandasm::Ins> &&GetResult()
    {
        return std::move(result_);
    }

    const ArenaVector<BasicBlock *> &GetBlocksToVisit() const override
    {
        return GetGraph()->GetBlocksRPO();
    }
    static void VisitSpillFill(GraphVisitor *visitor, Inst *inst);
    static void VisitConstant(GraphVisitor *visitor, Inst *inst);
    static void VisitCatchPhi(GraphVisitor *visitor, Inst *inst);

    static void VisitIf(GraphVisitor *v, Inst *inst_base);
    static void VisitIfImm(GraphVisitor *v, Inst *inst_base);
    static void IfImmZero(GraphVisitor *v, Inst *inst_base);
    static void VisitIntrinsic(GraphVisitor *visitor, Inst *inst_base);
    static void VisitLoadString(GraphVisitor *v, Inst *inst_base);
    static void VisitReturn(GraphVisitor *v, Inst *inst_base);

    static void VisitCastValueToAnyType(GraphVisitor *v, Inst *inst_base);

    static void VisitEcma(GraphVisitor *v, Inst *inst_base);
    static void IfEcma(GraphVisitor *v, compiler::IfInst *inst);

    static void VisitPhi(GraphVisitor* v, Inst* inst_base);
    static void VisitTry(GraphVisitor* v, Inst* inst_base);
    static void VisitSaveState(GraphVisitor* v, Inst* inst_base);
    static void VisitParameter(GraphVisitor* v, Inst* inst_base);
    
    BasicBlock* find_nearest_visited_pred(const std::vector<BasicBlock*>& visited, BasicBlock* block);

    template <typename T, typename... Args>
    static T *AllocNode(AstGen * xx, Args &&... args)
    {
        //[[maybe_unused]] auto *xx = static_cast<AstGen *>(visitor);
        auto ret = xx->parser_program_->Allocator()->New<T>(std::forward<Args>(args)...);
        if (ret == nullptr) {
            std::cout << "Unsuccessful allocation during parsing" << std::endl;;
        }
        return ret;
    }

    void VisitDefault(Inst *inst) override
    {
        LOG(ERROR, BYTECODE_OPTIMIZER) << "Opcode " << compiler::GetOpcodeString(inst->GetOpcode())
                                       << " not yet implemented in codegen";
        success_ = false;
    }

    uint32_t parseHexFromKey(const std::string& key) {
        std::istringstream iss(key);
        std::string temp;
        std::string hexString;

        while (iss >> temp) {
            if (temp.find("0x") == 0 || temp.find("0X") == 0) {
                hexString = temp;
                break;
            }
        }

        uint32_t hexNumber = 0;
        if (!hexString.empty()) {
            std::istringstream(hexString) >> std::hex >> hexNumber;
        }

        return hexNumber;
    }

    std::optional<panda::pandasm::LiteralArray> findLiteralArrayByOffset(uint32_t offset) {
        for (const auto& [key, value] : this->program_->literalarray_table) {
            if (parseHexFromKey(key) == offset) {
                return value;
            }
        }
        return std::nullopt;
    }


    panda::es2panda::ir::NumberLiteral* get_literal_bynum(uint32_t index){
        panda::es2panda::ir::NumberLiteral* literal;
        if (this->num2literals.find(index)  != this->num2literals.end()) {
            literal = this->num2literals[index];
        } else {
            literal = AllocNode<panda::es2panda::ir::NumberLiteral>(this, index);
            this->num2literals[index] = literal;
        }
        return literal;
    }

    panda::es2panda::ir::Identifier* get_identifier_byreg(compiler::Register reg){
        panda::es2panda::ir::Identifier* identifier;
        if (this->identifers.find(reg)  != this->identifers.end()) {
            identifier =  this->identifers[reg];
        } else {
            std::string* raw_name =  new std::string("v" + std::to_string(reg));

            panda::es2panda::util::StringView reg_name = panda::es2panda::util::StringView( *raw_name);
            identifier = AllocNode<panda::es2panda::ir::Identifier>(this, reg_name);
            this->identifers[reg] = identifier;
            this->str2identifers[*raw_name ] = identifier;
        }
        return identifier;
    }

    panda::es2panda::ir::Identifier* get_identifier_byname(std::string* raw_name){
        panda::es2panda::ir::Identifier* identifier;
        if (this->str2identifers.find(*raw_name)  != this->str2identifers.end()) {
            identifier = this->str2identifers[*raw_name];
        } else {
            panda::es2panda::util::StringView name_view = panda::es2panda::util::StringView(*raw_name);
            //std::cout << "@@@ name_view: " << name_view << std::endl;

            identifier = AllocNode<panda::es2panda::ir::Identifier>(this, name_view);
            this->str2identifers[*raw_name] = identifier;
        }
        return identifier;
    }

    std::optional<panda::es2panda::ir::Expression*> get_expression_by_id(Inst* inst, uint32_t index){
        auto id = inst->GetInput(index).GetInst()->GetId();
        
        auto it = this->id2expression.find(id);
        if (it != this->id2expression.end()) {
            std::cout << "#get_expression_by_register: " << std::to_string(id) << std::endl;
            return it->second;  
        }
        

        // @@@###@@@TODO temp test suport for phi
        //return this->get_identifier_byname(new std::string(std::to_string(index))); 
        
        handleError("can't find expression in reg2expression: " + std::to_string(id));
        return std::nullopt;
    }

    void set_expression_by_id(Inst* inst, uint32_t id, panda::es2panda::ir::Expression* value){
        if(value == nullptr){
            handleError("#set_expression_by_register: can't set null expression in reg2expression");
        }
        this->id2expression[id] = value;
    }


    std::optional<panda::es2panda::ir::Expression*> get_expression_by_register(Inst* inst, compiler::Register key){
        if(key == compiler::ACC_REG_ID){
            if(this->bb2acc2expression[inst->GetBasicBlock()] != nullptr){
                return this->bb2acc2expression[inst->GetBasicBlock()];
            }else{
                handleError("#get_expression_by_register: acc point to null");
            }
        }

        auto it = this->reg2expression.find(key);
        if (it != this->reg2expression.end()) {
            std::cout << "#get_expression_by_register: " << std::to_string(key) << std::endl;
            return it->second;  
        }

        handleError("can't find expression in reg2expression: " + std::to_string(key));
        
        return std::nullopt;
    }

    void set_expression_by_register(Inst* inst, compiler::Register key, panda::es2panda::ir::Expression* value){
        /**
            std::map<compiler::Register, panda::es2panda::ir::Expression*> reg2expression;
            std::map<compiler::BasicBlock*, panda::es2panda::ir::Expression*> bb2acc2expression;
         * 
        */

        if(value == nullptr){
            handleError("#set_expression_by_register: can't set null expression in reg2expression");
        }
        this->set_expression_by_id(inst, inst->GetId(), value);

        std::cout << "#set_expression_by_register: " << std::to_string(key) << std::endl;
        
        if(inst->IsAccWrite()){
            this->bb2acc2expression[inst->GetBasicBlock()] = value;
        }

        this->reg2expression[key] = value;
    }

    void logid2blockkeys(){
        std::cout << "id2block keys: ";
        for (const auto& pair : this->id2block) {
            std::cout << pair.first << ", ";
        }
        std::cout << std::endl;
    }

    void logspecialblockid(){
        std::cout << "specialblockid: ";
        for (auto it = this->specialblockid.begin(); it != this->specialblockid.end(); ++it) {
            std::cout << *it;
            if (std::next(it) != this->specialblockid.end()) {
                std::cout << ", ";
            }
        }
        std::cout << std::endl;
    }
 
    void logbackedgeid(ArenaVector<BasicBlock *> backedges){
        std::cout << "backedgeid: ";
        for (auto it = backedges.begin(); it != backedges.end(); ++it) {
            std::cout << (*it)->GetId();
            if (std::next(it) != backedges.end()) {
                std::cout << ", ";
            }
        }
        std::cout << std::endl;
    }

    BasicBlock* search_preheader(BasicBlock* header){
        for (auto pred : header->GetPredsBlocks()) {
            if(pred->IsLoopPreHeader()){
                return pred;
            }
        }
        return nullptr;
    }

    void add_insAst_to_blockstatemnt_by_inst(Inst *inst, es2panda::ir::Statement *statement){
        BasicBlock* block = inst->GetBasicBlock();
        this->add_insAst_to_blockstatemnt_by_block(block, statement);

        if(block->IsLoopValid() && block->IsLoopHeader() && inst->GetOpcode()!= Opcode::If   && inst->GetOpcode()!= Opcode::IfImm ){
            auto headerblockstatements = this->whileheader2redundant[block];
            const auto &statements = headerblockstatements->Statements();
            headerblockstatements->AddStatementAtPos(statements.size(), statement);
        }
    }

    void add_insAst_to_blockstatemnt_by_block(BasicBlock* block, es2panda::ir::Statement *statement){
        es2panda::ir::BlockStatement* block_statements = this->get_blockstatement_byid(block);
        const auto &statements = block_statements->Statements();
        block_statements->AddStatementAtPos(statements.size(), statement);
    }

    void log_loop_bbs(BasicBlock* header){
        ArenaVector<BasicBlock *> bbs = header->GetLoop()->GetBlocks();
        std::cout << "[+] loop list >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> " << std::endl;
        for (size_t i = 0; i < bbs.size(); i++) {
            BasicBlock * bb = bbs[i];
            std::cout << bb->GetId() << " ";
            if(bb->IsLoopValid() && bb->GetLoop()->IsRoot()){
                std::cout << "bbi@ " << bb->GetId() << std::endl;
            }
        } 

        std::cout << std::endl;
        std::cout << "[-] loop list >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> " << std::endl;
    }

    void judge_looptype(BasicBlock* header){
        auto &back_edges = header->GetLoop()->GetBackEdges();
        for (auto back_edge : back_edges) {
            auto succs_size = back_edge->GetSuccsBlocks().size();
            if(succs_size > 1){
                this->loop2type[header->GetLoop()] = 1;  // do-whle
                this->backedge2dowhileloop[back_edge] = header->GetLoop();

                if(back_edge->GetTrueSuccessor()->GetLoop() == header->GetLoop()){
                    this->loop2exit[header->GetLoop()] = back_edge->GetFalseSuccessor();
                }else{
                    this->loop2exit[header->GetLoop()] = back_edge->GetTrueSuccessor();
                }
            }else{
                this->loop2type[header->GetLoop()] = 0;  // while
                if(header->GetTrueSuccessor()->GetLoop() == header->GetLoop()){
                    this->loop2exit[header->GetLoop()] = header->GetFalseSuccessor();
                }else{
                    this->loop2exit[header->GetLoop()] = header->GetTrueSuccessor();
                }
            }
        } 

        //log_loop_bbs(header);
    }

    es2panda::ir::BlockStatement* get_blockstatement_byid(BasicBlock *block){
        auto block_id = block->GetId();
        std::cout << "[*] get_blockstatement_byid bbid: " << block_id << ", ";

        // case1: found blockstatment
        if (this->id2block.find(block_id) != this->id2block.end()) {
            std::cout << "@@ case 1" << std::endl;
            return this->id2block[block_id];
        }
        
        // case2: found loop
        if(block->IsLoopValid() && block->IsLoopHeader() ){
            std::cout << "@@ case 2" << std::endl;
            judge_looptype(block);

            //////////////////////////////////////////////////////////////////////////////////////
            ArenaVector<panda::es2panda::ir::Statement *> statements(this->parser_program_->Allocator()->Adapter());
            auto new_block_statement = this->parser_program_->Allocator()->New<panda::es2panda::ir::BlockStatement>(nullptr, std::move(statements));
            this->id2block[block_id] = new_block_statement;
            return this->id2block[block_id];
        }

        ///////////////////////////////////////////////////////////////////////////////////////////

        // case3: found unique predecessor with unique successor
        if(block->GetPredsBlocks().size() == 1 && block_id != 0 && block->GetPredecessor(0)->GetSuccsBlocks().size() == 1){
            std::cout << "@@ case 3" << std::endl;
            BasicBlock* ancestor_block = block->GetPredecessor(0);
            this->id2block[block_id] =  this->id2block[ancestor_block->GetId()];;
            return this->id2block[block_id];
        }
        
        // case4:create new statements
        std::cout << "@@ case 4" << std::endl;
        ArenaVector<panda::es2panda::ir::Statement *> statements(this->parser_program_->Allocator()->Adapter());
        auto new_block_statement = this->parser_program_->Allocator()->New<panda::es2panda::ir::BlockStatement>(nullptr, std::move(statements));
        this->id2block[block_id] = new_block_statement;

        logspecialblockid();

        // nested if-else
        if(this->specialblockid.find(block_id) == this->specialblockid.end() ){
            BasicBlock* ancestor_block = nullptr;

            ancestor_block = block->GetDominator();

            if(ancestor_block == nullptr){
                handleError("get_blockstatement_byid# find ancestor is nullptr");
            }
            std::cout << "@ ancestor_block: " <<  std::to_string(ancestor_block->GetId()) <<  std::endl;

            auto ancestor_block_statements = this->get_blockstatement_byid(ancestor_block);
            this->id2block[block_id] =  ancestor_block_statements;

            this->add_insAst_to_blockstatemnt_by_block(ancestor_block, new_block_statement);
            

            return this->id2block[block_id];
        }else{
            /**
             * add statement in special statements
             * a) if
             * b) try-catch 
             * c) ...
            */

        }
        
        es2panda::ir::BlockStatement* curstatement = this->id2block[block_id];
        return curstatement;
    }

#include "compiler/optimizer/ir/visitor.inc"

private:
    void VisitTryBegin(const compiler::BasicBlock *bb);

public:
    pandasm::Function *function_;
    const BytecodeOptIrInterface *ir_interface_;
    pandasm::Program *program_;

    uint32_t methodoffset;
    uint32_t closure_count;

    std::vector<pandasm::Ins> res_;
    std::vector<pandasm::Function::CatchBlock> catch_blocks_;

    std::map<uint32_t, LexicalEnvStack*>* method2lexicalenvstack;

    std::stack<uint32_t> waitmethods;


    std::unique_ptr<LCAFinder> lcaFinder;

    bool success_ {true};
    std::vector<pandasm::Ins> result_;
   
    std::string* acc_global_str = NULL;

    panda::es2panda::ir::Expression* acc = NULL;

    panda::es2panda::ir::Expression* thisptr= NULL;

    es2panda::parser::Program* parser_program_;

    std::map<compiler::Loop *, uint32_t> loop2type; // 0-while, 1-dowhile
    std::map<compiler::Loop *, BasicBlock*> loop2exit; 
    std::map<compiler::BasicBlock*, compiler::Loop *> backedge2dowhileloop;

    std::map<compiler::BasicBlock*, es2panda::ir::BlockStatement*> whileheader2redundant;

    std::map<uint32_t, es2panda::ir::BlockStatement*> id2block;

    std::set<uint32_t> specialblockid;

    std::map<compiler::Register, panda::es2panda::ir::Identifier*> identifers;
    

    std::map<std::string, panda::es2panda::ir::Identifier*> str2identifers;
    std::map<uint32_t, panda::es2panda::ir::NumberLiteral*> num2literals;

    std::map<compiler::Register, panda::es2panda::ir::Expression*> reg2expression;
    std::map<compiler::BasicBlock*, panda::es2panda::ir::Expression*> bb2acc2expression;

    LexicalEnv* acc_lexicalenv = NULL;

    std::map<compiler::BasicBlock*, LexicalEnvStack*> bb2lexicalenvstack;

    std::map<uint32_t, panda::es2panda::ir::Expression*> id2expression;
    
    std::map<uint32_t, es2panda::ir::BlockStatement*> tyrid2block;
    std::map<uint32_t, panda::es2panda::ir::TryStatement*> tyridtrystatement;
    std::map<uint32_t, panda::es2panda::ir::CatchClause*> tyrid2catchclause;

    panda::es2panda::ir::Identifier* DEFINEFUNC = AllocNode<panda::es2panda::ir::Identifier>(this, "DEFINEFUNC");

    panda::es2panda::ir::Identifier* constant_undefined = AllocNode<panda::es2panda::ir::Identifier>(this, "undefined");
    panda::es2panda::ir::Identifier* constant_hole = AllocNode<panda::es2panda::ir::Identifier>(this, "hole");

    panda::es2panda::ir::Identifier* constant_nan = AllocNode<panda::es2panda::ir::Identifier>(this, "NaN");
    panda::es2panda::ir::Identifier* constant_infinity = AllocNode<panda::es2panda::ir::Identifier>(this, "infinity");
    panda::es2panda::ir::Identifier* constant_catcherror = AllocNode<panda::es2panda::ir::Identifier>(this, "error");

    panda::es2panda::ir::BooleanLiteral* constant_true = AllocNode<panda::es2panda::ir::BooleanLiteral>(this, true);
    panda::es2panda::ir::BooleanLiteral* constant_false = AllocNode<panda::es2panda::ir::BooleanLiteral>(this, false);
    panda::es2panda::ir::NullLiteral* constant_null = AllocNode<panda::es2panda::ir::NullLiteral>(this);

    panda::es2panda::ir::NumberLiteral* constant_one = AllocNode<panda::es2panda::ir::NumberLiteral>(this, 1);
    panda::es2panda::ir::NumberLiteral* constant_zero = AllocNode<panda::es2panda::ir::NumberLiteral>(this, 0);


};

}  // namespace panda::bytecodeopt

#endif  // BYTECODE_OPTIMIZER_CODEGEN_H

```

`astgen_auxiins.cpp`:

```cpp
void AstGen::VisitPhi(GraphVisitor* v, Inst* inst_base) {
    std::cout << "[+] VisitPhi  >>>>>>>>>>>>>>>>>" << std::endl;
    pandasm::Ins ins;
    [[maybe_unused]] auto enc = static_cast<AstGen*>(v);
    [[maybe_unused]] auto inst = inst_base->CastToPhi();
    panda::es2panda::ir::Expression* funname = enc->get_identifier_byname(new std::string("φ"));
    ArenaVector<es2panda::ir::Expression *> arguments(enc->parser_program_->Allocator()->Adapter());

    for (size_t i = 0; i < inst->GetInputsCount(); i++) {
        std::cout << "[+] phi: end <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<" << std::endl;
        std::cout << "[*] reg " << std::to_string(i) << " , " << std::to_string(inst->GetSrcReg(i-2)) << std::endl;
        arguments.push_back(*enc->get_expression_by_id(inst, i));
        std::cout << "[-] phi: end >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>" << std::endl;
    }

    auto callexpression = AllocNode<es2panda::ir::CallExpression>(enc, 
                                                        funname,
                                                        std::move(arguments),
                                                        nullptr,
                                                        false
                                                        );

    enc->set_expression_by_register(inst, inst->GetDstReg(), callexpression);
    std::cout << "[-] VisitPhi  <<<<<<<<<<<<<<<" << std::endl;
}

void AstGen::VisitSaveState(GraphVisitor* v, Inst* inst_base) {
    std::cout << "[+] VisitSaveState  >>>>>>>>>>>>>>>>>" << std::endl;
    pandasm::Ins ins;
    [[maybe_unused]] auto enc = static_cast<AstGen*>(v);
    [[maybe_unused]] auto inst = inst_base->CastToSaveState();
    std::cout << "[-] VisitSaveState  >>>>>>>>>>>>>>>>>" << std::endl;
}
void AstGen::VisitParameter(GraphVisitor* v, Inst* inst_base) {
    std::cout << "[+] VisitParameter  >>>>>>>>>>>>>>>>>" << std::endl;
    auto enc = static_cast<AstGen *>(v);
    auto inst = inst_base->CastToParameter();

    panda::es2panda::ir::Expression* arg = enc->get_identifier_byname(new std::string("arg" + std::to_string(inst->GetArgNumber())));
    
    enc->set_expression_by_register(inst, inst->GetDstReg(), arg);
    std::cout << "[-] VisitParameter  >>>>>>>>>>>>>>>>>" << std::endl;
}

void AstGen::VisitTry(GraphVisitor* v, Inst* inst_base) {
    std::cout << "[+] VisitTry  >>>>>>>>>>>>>>>>>" << std::endl;
    pandasm::Ins ins;
    auto enc = static_cast<AstGen*>(v);
    auto inst = inst_base->CastToTry();

    // find tryblock
    BasicBlock* tryblock = nullptr;
    if(inst->GetBasicBlock()->GetSuccessor(0)->IsCatchBegin()){
        tryblock = inst->GetBasicBlock()->GetSuccessor(1);
    }else if(inst->GetBasicBlock()->GetSuccessor(1)->IsCatchBegin()){
        tryblock = inst->GetBasicBlock()->GetSuccessor(0);
    }else{
        handleError("can't handle this case  in visitTry for finding try block");
    }

    enc->specialblockid.insert(tryblock->GetId());
    
    panda::es2panda::ir::BlockStatement* tryblock_statement = enc->get_blockstatement_byid(tryblock);

    if(inst->GetBasicBlock()->GetTryId() !=  panda::compiler::INVALID_ID){
        enc->tyrid2block[inst->GetBasicBlock()->GetTryId()] = tryblock_statement;
    }
    

    /// find case block
    auto type_ids = inst->GetCatchTypeIds();
    auto catch_indexes = inst->GetCatchEdgeIndexes();

    panda::es2panda::ir::CatchClause *catchClause = nullptr;
    for (size_t idx = 0; idx < type_ids->size(); idx++) {
        auto succ =  inst->GetBasicBlock()->GetSuccessor(catch_indexes->at(idx));
        
        while (!succ->IsCatchBegin()) {
            succ = succ->GetSuccessor(0);
        }

        enc->specialblockid.insert(succ->GetId());
        auto catch_block = enc->get_blockstatement_byid(succ);
   
        panda::es2panda::ir::Expression *param = enc->constant_catcherror;
        

        catchClause =  AllocNode<panda::es2panda::ir::CatchClause>(enc, nullptr, param, catch_block);
        enc->tyrid2catchclause[inst->GetBasicBlock()->GetTryId()] = catchClause;
    }

    
    if(inst->GetBasicBlock()->GetPredsBlocks().size() == 2){
        handleError("analysis try-catch error for more than one predecessor");
    }
    
    // create null finally case
    ArenaVector<panda::es2panda::ir::Statement *> finally_statements(enc->parser_program_->Allocator()->Adapter());
    panda::es2panda::ir::BlockStatement* finnalyClause = enc->parser_program_->Allocator()->New<panda::es2panda::ir::BlockStatement>(nullptr, std::move(finally_statements));
    
    
    // create try-catch statement
    enc->get_blockstatement_byid(inst->GetBasicBlock());

    auto tryStatement = AllocNode<panda::es2panda::ir::TryStatement>(enc, tryblock_statement, catchClause, finnalyClause);
    enc->tyridtrystatement[inst->GetBasicBlock()->GetTryId()] = tryStatement;
    
    enc->add_insAst_to_blockstatemnt_by_inst(inst_base, tryStatement);

    std::cout << "[-] VisitTry  >>>>>>>>>>>>>>>>>" << std::endl;

}

```

`astgen_ecma.inl`:

```inl
#include "intrinsicid2token.h"

void panda::bytecodeopt::AstGen::VisitEcma(panda::compiler::GraphVisitor *visitor, Inst *inst_base)
{
    ASSERT(inst_base->IsIntrinsic());
    auto inst = inst_base->CastToIntrinsic();
    auto enc = static_cast<AstGen *>(visitor);

    std::ostringstream oss;
    inst->DumpOpcode(&oss);
    std::cout << "VisitIntrinsicInst: " << oss.str() << std::endl;

    switch (inst->GetIntrinsicId()) {
       case compiler::RuntimeInterface::IntrinsicId::RETURNUNDEFINED:
       {
            auto returnstatement = AllocNode<es2panda::ir::ReturnStatement>(enc,  enc->constant_undefined);
            enc->add_insAst_to_blockstatemnt_by_inst(inst, returnstatement);
            break;
        }

       case compiler::RuntimeInterface::IntrinsicId::LDINFINITY:
       {
            enc->set_expression_by_register(inst, inst->GetDstReg(), enc->constant_infinity);
            break;
        }

       case compiler::RuntimeInterface::IntrinsicId::LDBIGINT_ID16:
       {
            panda::es2panda::ir::Identifier* funname = enc->get_identifier_byname(new std::string("BigInt"));
            ArenaVector<es2panda::ir::Expression *> arguments(enc->parser_program_->Allocator()->Adapter());

            auto ir_id0 = static_cast<uint32_t>(inst->GetImms()[0]);
            auto bc_id0 = enc->ir_interface_->GetStringIdByOffset(ir_id0);

            std::string* source_str_ptr = new std::string(bc_id0);
            es2panda::util::StringView literal_strview(*source_str_ptr);

            arguments.push_back( AllocNode<es2panda::ir::StringLiteral>(enc, literal_strview));

            auto callexpression = AllocNode<es2panda::ir::CallExpression>(enc, 
                                                                            funname,
                                                                            std::move(arguments),
                                                                            nullptr,
                                                                            false
                                                                            );

            enc->set_expression_by_register(inst, inst->GetDstReg(), callexpression); 
            break;
        }

       case compiler::RuntimeInterface::IntrinsicId::LDHOLE:
       {
            enc->set_expression_by_register(inst, inst->GetDstReg(), enc->constant_hole);
            break;
        }

       case compiler::RuntimeInterface::IntrinsicId::LDUNDEFINED:
       {
            enc->set_expression_by_register(inst, inst->GetDstReg(), enc->constant_undefined);
            break;
        }

       case compiler::RuntimeInterface::IntrinsicId::LDNULL:
       {
            enc->set_expression_by_register(inst, inst->GetDstReg(), enc->constant_null);
            break;
        }
       case compiler::RuntimeInterface::IntrinsicId::LDTRUE:
       {
            enc->set_expression_by_register(inst, inst->GetDstReg(), enc->constant_true);
            break;
        }
       case compiler::RuntimeInterface::IntrinsicId::LDFALSE:
       {
            enc->set_expression_by_register(inst, inst->GetDstReg(), enc->constant_false);
            break;
        }
       case compiler::RuntimeInterface::IntrinsicId::LDNAN:
       {
            enc->set_expression_by_register(inst, inst->GetDstReg(), enc->constant_nan);
            break;
        }

       case compiler::RuntimeInterface::IntrinsicId::INSTANCEOF_IMM8_V8:
       case compiler::RuntimeInterface::IntrinsicId::ISIN_IMM8_V8:
       case compiler::RuntimeInterface::IntrinsicId::ADD2_IMM8_V8:
       case compiler::RuntimeInterface::IntrinsicId::SUB2_IMM8_V8:
       case compiler::RuntimeInterface::IntrinsicId::MUL2_IMM8_V8:
       case compiler::RuntimeInterface::IntrinsicId::DIV2_IMM8_V8:
       case compiler::RuntimeInterface::IntrinsicId::MOD2_IMM8_V8:
       case compiler::RuntimeInterface::IntrinsicId::EQ_IMM8_V8:
       case compiler::RuntimeInterface::IntrinsicId::NOTEQ_IMM8_V8:
       case compiler::RuntimeInterface::IntrinsicId::LESS_IMM8_V8:
       case compiler::RuntimeInterface::IntrinsicId::LESSEQ_IMM8_V8:
       case compiler::RuntimeInterface::IntrinsicId::GREATER_IMM8_V8:
       case compiler::RuntimeInterface::IntrinsicId::GREATEREQ_IMM8_V8:
       case compiler::RuntimeInterface::IntrinsicId::SHL2_IMM8_V8:
       case compiler::RuntimeInterface::IntrinsicId::SHR2_IMM8_V8:
       case compiler::RuntimeInterface::IntrinsicId::ASHR2_IMM8_V8:
       case compiler::RuntimeInterface::IntrinsicId::AND2_IMM8_V8:
       case compiler::RuntimeInterface::IntrinsicId::OR2_IMM8_V8:
       case compiler::RuntimeInterface::IntrinsicId::XOR2_IMM8_V8:
       case compiler::RuntimeInterface::IntrinsicId::STRICTNOTEQ_IMM8_V8:
       case compiler::RuntimeInterface::IntrinsicId::STRICTEQ_IMM8_V8:
       case compiler::RuntimeInterface::IntrinsicId::EXP_IMM8_V8:{
            panda::es2panda::ir::Expression* source_expression = *enc->get_expression_by_id(inst, inst->GetInputsCount() - 2);  
            auto binexpression = AllocNode<es2panda::ir::BinaryExpression>(enc, 
                                                            *enc->get_expression_by_id(inst, 0),
                                                            source_expression,
                                                            BinIntrinsicIdToToken(inst->GetIntrinsicId())
            );
            enc->set_expression_by_register(inst, inst->GetDstReg(), binexpression);
            break;
        }

       case compiler::RuntimeInterface::IntrinsicId::INC_IMM8:
       case compiler::RuntimeInterface::IntrinsicId::DEC_IMM8:
       {
            panda::es2panda::ir::Expression* source_expression = *enc->get_expression_by_id(inst, inst->GetInputsCount() - 2);
            auto binexpression = AllocNode<es2panda::ir::BinaryExpression>(enc, 
                                                            source_expression,
                                                            enc->constant_one,
                                                            IncDecIntrinsicIdToToken(inst->GetIntrinsicId())
            );

            enc->set_expression_by_register(inst, inst->GetDstReg(), binexpression);
            break;
        }

       case compiler::RuntimeInterface::IntrinsicId::ISTRUE:{
            panda::es2panda::ir::Expression* source_expression = *enc->get_expression_by_id(inst, inst->GetInputsCount() - 2);
            auto binexpression = AllocNode<es2panda::ir::BinaryExpression>(enc, 
                                                            source_expression,
                                                            enc->constant_true,
                                                            BinIntrinsicIdToToken(inst->GetIntrinsicId())
            );

            enc->set_expression_by_register(inst, inst->GetDstReg(), binexpression);
            break;
        }
       case compiler::RuntimeInterface::IntrinsicId::ISFALSE:{
            panda::es2panda::ir::Expression* source_expression = *enc->get_expression_by_id(inst, inst->GetInputsCount() - 2);
            auto binexpression = AllocNode<es2panda::ir::BinaryExpression>(enc, 
                                                            source_expression,
                                                            enc->constant_false,
                                                            BinIntrinsicIdToToken(inst->GetIntrinsicId())
            );

            enc->set_expression_by_register(inst, inst->GetDstReg(), binexpression);
            break;

        }

       case compiler::RuntimeInterface::IntrinsicId::NOT_IMM8:
       case compiler::RuntimeInterface::IntrinsicId::NEG_IMM8:
       case compiler::RuntimeInterface::IntrinsicId::TYPEOF_IMM8:
       case compiler::RuntimeInterface::IntrinsicId::TYPEOF_IMM16: {
            panda::es2panda::ir::Expression* source_expression = *enc->get_expression_by_id(inst, inst->GetInputsCount() - 2);        

            auto unaryexpression = AllocNode<es2panda::ir::UnaryExpression>(enc, 
                                                            source_expression,
                                                            UnaryPrefixIntrinsicIdToToken(inst->GetIntrinsicId())
            );

            enc->set_expression_by_register(inst, inst->GetDstReg(), unaryexpression);
            break;
        }

       case compiler::RuntimeInterface::IntrinsicId::TONUMBER_IMM8:
       case compiler::RuntimeInterface::IntrinsicId::TONUMERIC_IMM8:
       {
            panda::es2panda::ir::Expression* source_expression = *enc->get_expression_by_id(inst, inst->GetInputsCount() - 2);
            panda::es2panda::ir::Identifier* funname = enc->get_identifier_byname(new std::string("Number"));
            ArenaVector<es2panda::ir::Expression *> arguments(enc->parser_program_->Allocator()->Adapter());
            arguments.push_back(source_expression);

            auto callexpression = AllocNode<es2panda::ir::CallExpression>(enc, 
                                                                            funname,
                                                                            std::move(arguments),
                                                                            nullptr,
                                                                            false
                                                                            );

            enc->set_expression_by_register(inst, inst->GetDstReg(), callexpression);
            break;
        }

       case compiler::RuntimeInterface::IntrinsicId::STGLOBALVAR_IMM16_ID16:
       case compiler::RuntimeInterface::IntrinsicId::TRYSTGLOBALBYNAME_IMM8_ID16:
       case compiler::RuntimeInterface::IntrinsicId::TRYSTGLOBALBYNAME_IMM16_ID16:
       {
            panda::es2panda::ir::Expression* src_reg_identifier = *enc->get_expression_by_id(inst, inst->GetInputsCount() - 2);  

            if(src_reg_identifier != enc->DEFINEFUNC){
                auto ir_id0 = static_cast<uint32_t>(inst->GetImms()[1]);
                auto bc_id0 = enc->ir_interface_->GetStringIdByOffset(ir_id0);
                std::string* global_name = new std::string(bc_id0);

                auto globalvar = enc->get_identifier_byname(global_name);

                auto assignexpression = AllocNode<es2panda::ir::AssignmentExpression>(enc, 
                                                                                    globalvar,
                                                                                    src_reg_identifier,
                                                                                    es2panda::lexer::TokenType::PUNCTUATOR_SUBSTITUTION
                                                                                );
                auto assignstatement = AllocNode<es2panda::ir::ExpressionStatement>(enc, assignexpression);
                enc->add_insAst_to_blockstatemnt_by_inst(inst, assignstatement);
            }
            break;
           
        }

        case compiler::RuntimeInterface::IntrinsicId::CREATEEMPTYOBJECT:
        {
            ArenaVector<es2panda::ir::Expression *> properties(enc->parser_program_->Allocator()->Adapter());
            auto objectexpression = AllocNode<es2panda::ir::ObjectExpression>(enc, 
                                                                                es2panda::ir::AstNodeType::OBJECT_EXPRESSION,
                                                                                std::move(properties),
                                                                                false
                                                                            );

            ArenaVector<es2panda::ir::VariableDeclarator *> declarators(enc->parser_program_->Allocator()->Adapter());
            enc->set_expression_by_register(inst, inst->GetDstReg(), objectexpression);
            break;
        }

        case compiler::RuntimeInterface::IntrinsicId::CREATEEMPTYARRAY_IMM16:
        case compiler::RuntimeInterface::IntrinsicId::CREATEEMPTYARRAY_IMM8:
        {
            ArenaVector<es2panda::ir::Expression *> elements(enc->parser_program_->Allocator()->Adapter());
            auto arrayexpression = AllocNode<es2panda::ir::ArrayExpression>(enc, 
                                                                            es2panda::ir::AstNodeType::ARRAY_EXPRESSION,
                                                                            std::move(elements),
                                                                            false
                                                                            );
            ArenaVector<es2panda::ir::VariableDeclarator *> declarators(enc->parser_program_->Allocator()->Adapter());


            enc->set_expression_by_register(inst, inst->GetDstReg(), arrayexpression);
            break;
        }


        case compiler::RuntimeInterface::IntrinsicId::CREATEARRAYWITHBUFFER_IMM8_ID16:
        case compiler::RuntimeInterface::IntrinsicId::CREATEARRAYWITHBUFFER_IMM16_ID16:
        {
            ArenaVector<es2panda::ir::Expression *> elements(enc->parser_program_->Allocator()->Adapter());

            ASSERT(inst->HasImms() && inst->GetImms().size() > 0);
            
            ASSERT(inst->HasImms() && inst->GetImms().size() > 1);
            auto ir_id0 = static_cast<uint32_t>(inst->GetImms()[1]);

            auto literalarray = enc->findLiteralArrayByOffset(ir_id0);
            if(!literalarray){
                handleError("get literalarray error");
            }

            /*
                std::variant<bool, uint8_t, uint16_t, uint32_t, uint64_t, float, double, std::string> value_;

            */
            for (const auto& literal : literalarray->literals_) {
                if(literal.IsBoolValue()){
                    elements.push_back(AllocNode<es2panda::ir::BooleanLiteral>(enc, std::get<bool>(literal.value_)));
                }else if(literal.IsByteValue()){
                    elements.push_back(AllocNode<es2panda::ir::NumberLiteral>(enc, std::get<uint8_t>(literal.value_)));
                }else if(literal.IsShortValue()){
                    elements.push_back(AllocNode<es2panda::ir::NumberLiteral>(enc, std::get<uint16_t>(literal.value_)));
                }else if(literal.IsIntegerValue()){
                    elements.push_back(AllocNode<es2panda::ir::NumberLiteral>(enc, std::get<uint32_t>(literal.value_)));
                }else if(literal.IsLongValue()){
                    elements.push_back(AllocNode<es2panda::ir::NumberLiteral>(enc, std::get<uint64_t>(literal.value_)));
                }else if(literal.IsFloatValue()){
                    elements.push_back(AllocNode<es2panda::ir::NumberLiteral>(enc, std::get<float>(literal.value_)));
                }else if(literal.IsDoubleValue()){
                    elements.push_back(AllocNode<es2panda::ir::NumberLiteral>(enc, std::get<double>(literal.value_)));
                }else if(literal.IsStringValue()){
                    es2panda::util::StringView literal_strview(std::get<std::string>(literal.value_));

                    elements.push_back(AllocNode<es2panda::ir::StringLiteral>(enc, literal_strview));
                }else{
                    handleError("unsupport literal type error");
                }

                // std::visit([](const auto& value) {
                //     std::cout << "The value is: " << value << std::endl;
                // }, literal.value_);
            }

            auto arrayexpression = AllocNode<es2panda::ir::ArrayExpression>(enc, 
                                                                            es2panda::ir::AstNodeType::ARRAY_EXPRESSION,
                                                                            std::move(elements),
                                                                            false
                                                                            );

            enc->set_expression_by_register(inst, inst->GetDstReg(), arrayexpression);
            break;
        }


        case compiler::RuntimeInterface::IntrinsicId::CREATEOBJECTWITHBUFFER_IMM8_ID16:
        case compiler::RuntimeInterface::IntrinsicId::CREATEOBJECTWITHBUFFER_IMM16_ID16:
        {
            ArenaVector<es2panda::ir::Expression *> properties(enc->parser_program_->Allocator()->Adapter());
            
            auto ir_id0 = static_cast<uint32_t>(inst->GetImms()[1]); 
            auto literalarray = enc->findLiteralArrayByOffset(ir_id0);

            int count = 0;
            es2panda::ir::Expression* key;
            es2panda::ir::Expression* value;
            for (const auto& literal : literalarray->literals_) {
                es2panda::ir::Expression *tmp;
                if(literal.IsBoolValue()){
                    tmp = AllocNode<es2panda::ir::BooleanLiteral>(enc, std::get<bool>(literal.value_));
                }else if(literal.IsByteValue()){
                    tmp = AllocNode<es2panda::ir::NumberLiteral>(enc, std::get<uint8_t>(literal.value_));
                }else if(literal.IsShortValue()){
                    tmp = AllocNode<es2panda::ir::NumberLiteral>(enc, std::get<uint16_t>(literal.value_));
                }else if(literal.IsIntegerValue()){
                    tmp = AllocNode<es2panda::ir::NumberLiteral>(enc, std::get<uint32_t>(literal.value_));
                }else if(literal.IsLongValue()){
                    tmp = AllocNode<es2panda::ir::NumberLiteral>(enc, std::get<uint64_t>(literal.value_));
                }else if(literal.IsFloatValue()){
                    tmp = AllocNode<es2panda::ir::NumberLiteral>(enc, std::get<float>(literal.value_));
                }else if(literal.IsDoubleValue()){
                    tmp = AllocNode<es2panda::ir::NumberLiteral>(enc, std::get<double>(literal.value_));
                }else if(literal.IsStringValue()){
                    es2panda::util::StringView literal_strview(std::get<std::string>(literal.value_));
                    tmp = AllocNode<es2panda::ir::StringLiteral>(enc, literal_strview);
                }else{
                    handleError("unsupport literal type error");
                }

                if(count++ % 2==0){
                    key = tmp;    
                }else{
                    value = tmp;
                    properties.push_back(  AllocNode<es2panda::ir::Property>(enc, key, value) );

                }

                // std::visit([](const auto& value) {
                //     std::cout << "The value is: " << value << std::endl;
                // }, literal.value_);
            }


            auto objectexpression = AllocNode<es2panda::ir::ObjectExpression>(enc, 
                                                                                es2panda::ir::AstNodeType::OBJECT_EXPRESSION,
                                                                                std::move(properties),
                                                                                false
                                                                            );

            ArenaVector<es2panda::ir::VariableDeclarator *> declarators(enc->parser_program_->Allocator()->Adapter());


            enc->set_expression_by_register(inst, inst->GetDstReg(), objectexpression);
            break;
        }

        case compiler::RuntimeInterface::IntrinsicId::LDGLOBALVAR_IMM16_ID16:
        case compiler::RuntimeInterface::IntrinsicId::TRYLDGLOBALBYNAME_IMM8_ID16:
        case compiler::RuntimeInterface::IntrinsicId::TRYLDGLOBALBYNAME_IMM16_ID16:
       {
            ASSERT(inst->HasImms() && inst->GetImms().size() > 0); 
            ASSERT(inst->HasImms() && inst->GetImms().size() > 1); 

            auto ir_id0 = static_cast<uint32_t>(inst->GetImms()[1]);
            auto bc_id0 = enc->ir_interface_->GetStringIdByOffset(ir_id0);

            es2panda::ir::Expression* sourceexpression = enc->get_identifier_byname(new std::string(bc_id0));
            enc->set_expression_by_register(inst, inst->GetDstReg(), sourceexpression);

            break;
        }

       case compiler::RuntimeInterface::IntrinsicId::LDOBJBYNAME_IMM8_ID16:
       case compiler::RuntimeInterface::IntrinsicId::LDOBJBYNAME_IMM16_ID16:
       {
            panda::es2panda::ir::Expression* obj_expression = *enc->get_expression_by_id(inst, inst->GetInputsCount() - 2);
            
            auto ir_id0 = static_cast<uint32_t>(inst->GetImms()[1]);
            auto bc_id0 = enc->ir_interface_->GetStringIdByOffset(ir_id0);

            std::string* name_ptr= new std::string(bc_id0);

            panda::es2panda::ir::Expression* attr_expression = enc->get_identifier_byname(name_ptr);

            auto objattrexpression = AllocNode<es2panda::ir::MemberExpression>(enc,
                                                        obj_expression,
                                                        attr_expression, 
                                                        es2panda::ir::MemberExpression::MemberExpressionKind::PROPERTY_ACCESS, 
                                                        false, 
                                                        false);


            enc->set_expression_by_register(inst, inst->GetDstReg(), objattrexpression);
            break;
       }

       case compiler::RuntimeInterface::IntrinsicId::LDOBJBYVALUE_IMM16_V8:
       case compiler::RuntimeInterface::IntrinsicId::LDOBJBYVALUE_IMM8_V8:
       {
            panda::es2panda::ir::Expression* attr_expression = *enc->get_expression_by_id(inst, inst->GetInputsCount() - 2);
            panda::es2panda::ir::Expression* obj_expression = *enc->get_expression_by_id(inst, 0);
            auto objattrexpression = AllocNode<es2panda::ir::MemberExpression>(enc,
                                                        obj_expression,
                                                        attr_expression, 
                                                        es2panda::ir::MemberExpression::MemberExpressionKind::PROPERTY_ACCESS, 
                                                        true, 
                                                        false);

            enc->set_expression_by_register(inst, inst->GetDstReg(), objattrexpression);
            break;
        }

        case compiler::RuntimeInterface::IntrinsicId::STTOGLOBALRECORD_IMM16_ID16:
        case compiler::RuntimeInterface::IntrinsicId::STCONSTTOGLOBALRECORD_IMM16_ID16:
        {
            panda::es2panda::ir::Expression* src_expression = *enc->get_expression_by_id(inst, inst->GetInputsCount() - 2);
            
            auto ir_id0 = static_cast<uint32_t>(inst->GetImms()[1]);
            auto bc_id0 = enc->ir_interface_->GetStringIdByOffset(ir_id0);

            std::string* global_name = new std::string(bc_id0);
            
            auto dst_identifier = enc->get_identifier_byname(global_name);

            ArenaVector<es2panda::ir::VariableDeclarator *> declarators(enc->parser_program_->Allocator()->Adapter());
            auto *declarator = AllocNode<es2panda::ir::VariableDeclarator>(enc,
                                                                                dst_identifier, 
                                                                                src_expression);
            declarators.push_back(declarator);

            if(inst->GetIntrinsicId() == compiler::RuntimeInterface::IntrinsicId::STTOGLOBALRECORD_IMM16_ID16){
                auto variadeclaration = AllocNode<es2panda::ir::VariableDeclaration>(enc, 
                                                                                    es2panda::ir::VariableDeclaration::VariableDeclarationKind::CONST,
                                                                                    std::move(declarators),
                                                                                    true
                                                                                );
                enc->add_insAst_to_blockstatemnt_by_inst(inst, variadeclaration);
            }else{
                auto variadeclaration = AllocNode<es2panda::ir::VariableDeclaration>(enc, 
                                                                                    es2panda::ir::VariableDeclaration::VariableDeclarationKind::LET,
                                                                                    std::move(declarators),
                                                                                    true
                                                                                );
                enc->add_insAst_to_blockstatemnt_by_inst(inst, variadeclaration);
            }

            

            break;
        }

        case compiler::RuntimeInterface::IntrinsicId::CALLARG0_IMM8:
        {
            panda::es2panda::ir::Expression* funname = *enc->get_expression_by_id(inst, inst->GetInputsCount() - 2);

            ArenaVector<es2panda::ir::Expression *> arguments(enc->parser_program_->Allocator()->Adapter());
            es2panda::ir::CallExpression* callarg0expression = AllocNode<es2panda::ir::CallExpression>(enc, 
                                                                                funname,
                                                                                std::move(arguments),
                                                                                nullptr,
                                                                                false
                                                                            );

            if(inst->HasUsers()){
                enc->set_expression_by_register(inst, inst->GetDstReg(), callarg0expression);
            }else{
                auto callarg0statement = AllocNode<es2panda::ir::ExpressionStatement>(enc, callarg0expression);
                enc->add_insAst_to_blockstatemnt_by_inst(inst, callarg0statement);
            }

            break;
        }

        case compiler::RuntimeInterface::IntrinsicId::CALLARG1_IMM8_V8:
        {
            panda::es2panda::ir::Expression* funname = *enc->get_expression_by_id(inst, inst->GetInputsCount() - 2);


            ArenaVector<es2panda::ir::Expression *> arguments(enc->parser_program_->Allocator()->Adapter());
            auto v0 = *enc->get_expression_by_id(inst, 0);
            
            arguments.push_back(v0);
            es2panda::ir::CallExpression* callarg0expression = AllocNode<es2panda::ir::CallExpression>(enc, 
                                                                                funname,
                                                                                std::move(arguments),
                                                                                nullptr,
                                                                                false
                                                                            );

            enc->set_expression_by_register(inst, inst->GetDstReg(), callarg0expression);
            break;
        }

       case compiler::RuntimeInterface::IntrinsicId::CALLARGS2_IMM8_V8_V8:
       {

            panda::es2panda::ir::Expression* funname = *enc->get_expression_by_id(inst, inst->GetInputsCount() - 2);

            ArenaVector<es2panda::ir::Expression *> arguments(enc->parser_program_->Allocator()->Adapter());
            arguments.push_back(*enc->get_expression_by_id(inst, 0));
            arguments.push_back(*enc->get_expression_by_id(inst, 1));


            es2panda::ir::CallExpression* callarg0expression = AllocNode<es2panda::ir::CallExpression>(enc, 
                                                                                funname,
                                                                                std::move(arguments),
                                                                                nullptr,
                                                                                false
                                                                            );

            if(inst->HasUsers()){
                enc->set_expression_by_register(inst, inst->GetDstReg(), callarg0expression);
            }else{
                auto callarg0statement = AllocNode<es2panda::ir::ExpressionStatement>(enc, callarg0expression);
                enc->add_insAst_to_blockstatemnt_by_inst(inst, callarg0statement);
            }

            break;

        }
       case compiler::RuntimeInterface::IntrinsicId::CALLARGS3_IMM8_V8_V8_V8:
       {
            panda::es2panda::ir::Expression* funname = *enc->get_expression_by_id(inst, inst->GetInputsCount() - 2);


            ArenaVector<es2panda::ir::Expression *> arguments(enc->parser_program_->Allocator()->Adapter());

            arguments.push_back(*enc->get_expression_by_id(inst, 0));
            arguments.push_back(*enc->get_expression_by_id(inst, 1));
            arguments.push_back(*enc->get_expression_by_id(inst, 2));

            es2panda::ir::CallExpression* callarg0expression = AllocNode<es2panda::ir::CallExpression>(enc, 
                                                                                funname,
                                                                                std::move(arguments),
                                                                                nullptr,
                                                                                false
                                                                            );

            if(inst->HasUsers()){
                enc->set_expression_by_register(inst, inst->GetDstReg(), callarg0expression);
            }else{
                auto callarg0statement = AllocNode<es2panda::ir::ExpressionStatement>(enc, callarg0expression);
                enc->add_insAst_to_blockstatemnt_by_inst(inst, callarg0statement);
            }

            break;
        }
       
       case compiler::RuntimeInterface::IntrinsicId::CALLTHIS0_IMM8_V8:
       {
            
            panda::es2panda::ir::Expression* funname = *enc->get_expression_by_id(inst, inst->GetInputsCount() - 2);
            enc->thisptr = *enc->get_expression_by_id(inst, 0);

            ArenaVector<es2panda::ir::Expression *> arguments(enc->parser_program_->Allocator()->Adapter());
            es2panda::ir::CallExpression* callarg0expression = AllocNode<es2panda::ir::CallExpression>(enc, 
                                                                                funname,
                                                                                std::move(arguments),
                                                                                nullptr,
                                                                                false
                                                                            );

            
            if(inst->HasUsers()){
                enc->set_expression_by_register(inst, inst->GetDstReg(), callarg0expression);
            }else{
                auto callarg0statement = AllocNode<es2panda::ir::ExpressionStatement>(enc, callarg0expression);
                enc->add_insAst_to_blockstatemnt_by_inst(inst, callarg0statement);
            }
            break;
        }

       case compiler::RuntimeInterface::IntrinsicId::CALLTHIS1_IMM8_V8_V8:
       {
            panda::es2panda::ir::Expression* funname = *enc->get_expression_by_id(inst, inst->GetInputsCount() - 2);
            ArenaVector<es2panda::ir::Expression *> arguments(enc->parser_program_->Allocator()->Adapter());

            enc->thisptr = *enc->get_expression_by_id(inst, 0);
            arguments.push_back(*enc->get_expression_by_id(inst, 1));

            es2panda::ir::CallExpression* callarg0expression = AllocNode<es2panda::ir::CallExpression>(enc, 
                                                                                funname,
                                                                                std::move(arguments),
                                                                                nullptr,
                                                                                false
                                                                            );
            if(inst->HasUsers()){
                enc->set_expression_by_register(inst, inst->GetDstReg(), callarg0expression);
            }else{
                auto callarg0statement = AllocNode<es2panda::ir::ExpressionStatement>(enc, callarg0expression);
                enc->add_insAst_to_blockstatemnt_by_inst(inst, callarg0statement);
            }

            break;
        }
       case compiler::RuntimeInterface::IntrinsicId::CALLTHIS2_IMM8_V8_V8_V8:
       {

            panda::es2panda::ir::Expression* funname = *enc->get_expression_by_id(inst, inst->GetInputsCount() - 2);
            ArenaVector<es2panda::ir::Expression *> arguments(enc->parser_program_->Allocator()->Adapter());

            enc->thisptr = *enc->get_expression_by_id(inst, 0);
            arguments.push_back(*enc->get_expression_by_id(inst, 1));
            arguments.push_back(*enc->get_expression_by_id(inst, 2));

            es2panda::ir::CallExpression* callarg0expression = AllocNode<es2panda::ir::CallExpression>(enc, 
                                                                                funname,
                                                                                std::move(arguments),
                                                                                nullptr,
                                                                                false
                                                                            );

            if(inst->HasUsers()){
                enc->set_expression_by_register(inst, inst->GetDstReg(), callarg0expression);
            }else{
                auto callarg0statement = AllocNode<es2panda::ir::ExpressionStatement>(enc, callarg0expression);
                enc->add_insAst_to_blockstatemnt_by_inst(inst, callarg0statement);
            }

            break;
        }

       case compiler::RuntimeInterface::IntrinsicId::CALLTHIS3_IMM8_V8_V8_V8_V8:
       {

            panda::es2panda::ir::Expression* funname = *enc->get_expression_by_id(inst, inst->GetInputsCount() - 2);
            ArenaVector<es2panda::ir::Expression *> arguments(enc->parser_program_->Allocator()->Adapter());

            enc->thisptr = *enc->get_expression_by_id(inst, 0);
            arguments.push_back(*enc->get_expression_by_id(inst, 1));
            arguments.push_back(*enc->get_expression_by_id(inst, 2));
            arguments.push_back(*enc->get_expression_by_id(inst, 3));

            es2panda::ir::CallExpression* callarg0expression = AllocNode<es2panda::ir::CallExpression>(enc, 
                                                                                funname,
                                                                                std::move(arguments),
                                                                                nullptr,
                                                                                false
                                                                            );

            if(inst->HasUsers()){
                enc->set_expression_by_register(inst, inst->GetDstReg(), callarg0expression);
            }else{
                auto callarg0statement = AllocNode<es2panda::ir::ExpressionStatement>(enc, callarg0expression);
                enc->add_insAst_to_blockstatemnt_by_inst(inst, callarg0statement);
            }

            break;
        }
       
       case compiler::RuntimeInterface::IntrinsicId::STOBJBYVALUE_IMM8_V8_V8:
       case compiler::RuntimeInterface::IntrinsicId::STOBJBYVALUE_IMM16_V8_V8:
       {
            auto objattrexpression = AllocNode<es2panda::ir::MemberExpression>(enc,
                                                        *enc->get_expression_by_id(inst, 0),
                                                        *enc->get_expression_by_id(inst, 1), 
                                                        es2panda::ir::MemberExpression::MemberExpressionKind::PROPERTY_ACCESS, 
                                                        true, 
                                                        false);
            panda::es2panda::ir::Expression* assignexpression =   AllocNode<es2panda::ir::AssignmentExpression>(enc, 
                                                                            objattrexpression,
                                                                            *enc->get_expression_by_id(inst, inst->GetInputsCount() - 2),
                                                                            es2panda::lexer::TokenType::PUNCTUATOR_SUBSTITUTION
                                                                        ); 
            auto assignstatement = AllocNode<es2panda::ir::ExpressionStatement>(enc, 
                                                                                assignexpression);
            enc->add_insAst_to_blockstatemnt_by_inst(inst, assignstatement);
            break;

        }


       case compiler::RuntimeInterface::IntrinsicId::STOBJBYNAME_IMM16_ID16_V8:
       case compiler::RuntimeInterface::IntrinsicId::STOBJBYNAME_IMM8_ID16_V8:
       {
            ASSERT(inst->HasImms() && inst->GetImms().size() > 0); 
            ASSERT(inst->HasImms() && inst->GetImms().size() > 1); 
            auto ir_id0 = static_cast<uint32_t>(inst->GetImms()[1]);
            auto bc_id0 = enc->ir_interface_->GetStringIdByOffset(ir_id0);

            std::string* global_name = new std::string(bc_id0);
            
            auto objattrexpression = AllocNode<es2panda::ir::MemberExpression>(enc,
                                                        *enc->get_expression_by_id(inst, 0),
                                                        enc->get_identifier_byname(global_name),
                                                        es2panda::ir::MemberExpression::MemberExpressionKind::PROPERTY_ACCESS, 
                                                        false, 
                                                        false);


            panda::es2panda::ir::Expression* assignexpression = AllocNode<es2panda::ir::AssignmentExpression>(enc, 
                                                                            objattrexpression,
                                                                            *enc->get_expression_by_id(inst, inst->GetInputsCount() - 2),
                                                                            es2panda::lexer::TokenType::PUNCTUATOR_SUBSTITUTION
                                                                        ); 
                                                                        
            auto assignstatement = AllocNode<es2panda::ir::ExpressionStatement>(enc, 
                                                                                assignexpression);
            enc->add_insAst_to_blockstatemnt_by_inst(inst, assignstatement);
            break;
        }


       case compiler::RuntimeInterface::IntrinsicId::NEWOBJRANGE_IMM8_IMM8_V8:
       case compiler::RuntimeInterface::IntrinsicId::NEWOBJRANGE_IMM16_IMM8_V8:
       case compiler::RuntimeInterface::IntrinsicId::WIDE_NEWOBJRANGE_PREF_IMM16_V8:
       {
            ArenaVector<es2panda::ir::Expression *> arguments(enc->parser_program_->Allocator()->Adapter());
            es2panda::ir::Expression *callee = *enc->get_expression_by_id(inst, 0);

            uint32_t argsum;

            if(inst->GetIntrinsicId() == compiler::RuntimeInterface::IntrinsicId::WIDE_NEWOBJRANGE_PREF_IMM16_V8){
                argsum = static_cast<uint32_t>(inst->GetImms()[0]);
            }else{
                argsum = static_cast<uint32_t>(inst->GetImms()[1]);
            }

            for (uint32_t i = 1; i < argsum; ++i) {
                arguments.push_back(*enc->get_expression_by_id(inst, i));
            }

            es2panda::ir::Expression *newExprNode = AllocNode<es2panda::ir::NewExpression>(enc, callee, nullptr, std::move(arguments));
            enc->set_expression_by_register(inst, inst->GetDstReg(), newExprNode);
            break;

        }

       case compiler::RuntimeInterface::IntrinsicId::COPYDATAPROPERTIES_V8:
       {
            auto src_obj = *enc->get_expression_by_id(inst, inst->GetInputsCount() - 2);
            ArenaVector<es2panda::ir::Expression *> elements(enc->parser_program_->Allocator()->Adapter());
            auto v0 = inst->GetSrcReg(0);

            auto target_obj = *enc->get_expression_by_id(inst, 0);

            auto target_objexpression = static_cast<panda::es2panda::ir::ObjectExpression*>(target_obj);
            auto target_properties = target_objexpression->Properties();
            for (auto *it : target_properties) {
                elements.push_back(it);
            }

            elements.push_back( AllocNode<es2panda::ir::SpreadElement>(enc, es2panda::ir::AstNodeType::SPREAD_ELEMENT, src_obj));
            auto objectexpression = AllocNode<es2panda::ir::ObjectExpression>(enc, 
                                                                                es2panda::ir::AstNodeType::OBJECT_EXPRESSION,
                                                                                std::move(elements),
                                                                                false
                                                                            );

            enc->set_expression_by_register(inst, inst->GetDstReg(), objectexpression);
            enc->set_expression_by_register(inst->GetInput(0).GetInst(), v0, objectexpression);
            break;
        }



       case compiler::RuntimeInterface::IntrinsicId::APPLY_IMM8_V8_V8:
       {
            auto fun = *enc->get_expression_by_id(inst, inst->GetInputsCount() - 2);
            auto raw_expression = *enc->get_expression_by_id(inst, 1);

            auto raw_array_expression = static_cast<const panda::es2panda::ir::ArrayExpression*>(raw_expression);

            ArenaVector<es2panda::ir::Expression *> elements(enc->parser_program_->Allocator()->Adapter());

            for (auto *it :raw_array_expression->Elements()) {
                elements.push_back(it);
            }

            auto this_expression = *enc->get_expression_by_id(inst, 0);
            enc->thisptr = this_expression;
            
            auto callexpression = AllocNode<es2panda::ir::CallExpression>(enc, 
                                                                            fun,
                                                                            std::move(elements),
                                                                            nullptr,
                                                                            false
                                                                            );

            enc->set_expression_by_register(inst, inst->GetDstReg(), callexpression);

            break;
        }

       case compiler::RuntimeInterface::IntrinsicId::STARRAYSPREAD_V8_V8:
       {
            auto element = *enc->get_expression_by_id(inst, inst->GetInputsCount() - 2);
            es2panda::ir::Expression* spreadelement = AllocNode<es2panda::ir::SpreadElement>(enc, es2panda::ir::AstNodeType::SPREAD_ELEMENT, element);

            auto raw_obj = *enc->get_expression_by_id(inst, 0);
            auto raw_arrayexpression = static_cast<panda::es2panda::ir::ArrayExpression*>(raw_obj);

            ArenaVector<es2panda::ir::Expression *> elements(enc->parser_program_->Allocator()->Adapter());
            auto index_expression = *enc->get_expression_by_id(inst, 1);

            auto index_literal = static_cast<panda::es2panda::ir::NumberLiteral*>(index_expression);
            uint32_t index = index_literal->Number();

            for (auto *it : raw_arrayexpression->Elements()) {
                elements.push_back(it);
            }

            elements.insert(elements.begin() + index, spreadelement);
            auto arrayexpression = AllocNode<es2panda::ir::ArrayExpression>(enc, 
                                                                            es2panda::ir::AstNodeType::ARRAY_EXPRESSION,
                                                                            std::move(elements),
                                                                            false
                                                                            );
            enc->set_expression_by_register(inst->GetInput(0).GetInst(), inst->GetSrcReg(0), arrayexpression);

            uint32_t size = elements.size();
            enc->set_expression_by_register(inst, inst->GetDstReg(), enc->get_literal_bynum(size));
            break;
        }


       case compiler::RuntimeInterface::IntrinsicId::DEBUGGER:
       {
            auto debuggerstatement = AllocNode<es2panda::ir::DebuggerStatement>(enc );
            enc->add_insAst_to_blockstatemnt_by_inst(inst, debuggerstatement);
            break;
       }

       case compiler::RuntimeInterface::IntrinsicId::CALLRANGE_IMM8_IMM8_V8:
       case compiler::RuntimeInterface::IntrinsicId::WIDE_CALLRANGE_PREF_IMM16_V8:
       {

            panda::es2panda::ir::Expression* funname = *enc->get_expression_by_id(inst, inst->GetInputsCount() - 2);
            uint32_t argsum;

            if(inst->GetIntrinsicId() == compiler::RuntimeInterface::IntrinsicId::WIDE_CALLRANGE_PREF_IMM16_V8){
                argsum = static_cast<uint32_t>(inst->GetImms()[0]);
            }else{
                argsum = static_cast<uint32_t>(inst->GetImms()[1]);
            }

            ArenaVector<es2panda::ir::Expression *> arguments(enc->parser_program_->Allocator()->Adapter());
            for (uint32_t i = 0; i < argsum; ++i) {
                arguments.push_back(*enc->get_expression_by_id(inst, i));
            }

            
            es2panda::ir::CallExpression* callarg0expression = AllocNode<es2panda::ir::CallExpression>(enc, 
                                                                                funname,
                                                                                std::move(arguments),
                                                                                nullptr,
                                                                                false
                                                                            );
            enc->set_expression_by_register(inst, inst->GetDstReg(), callarg0expression);
            break;
        }

        case compiler::RuntimeInterface::IntrinsicId::WIDE_CALLTHISRANGE_PREF_IMM16_V8:
        case compiler::RuntimeInterface::IntrinsicId::CALLTHISRANGE_IMM8_IMM8_V8:
        {
            panda::es2panda::ir::Expression* funname = *enc->get_expression_by_id(inst, inst->GetInputsCount() - 2);
            enc->thisptr =  *enc->get_expression_by_id(inst, 0);

            uint32_t argsum;

            if(inst->GetIntrinsicId() == compiler::RuntimeInterface::IntrinsicId::WIDE_CALLTHISRANGE_PREF_IMM16_V8){
                argsum = static_cast<uint32_t>(inst->GetImms()[0]);
            }else{
                argsum = static_cast<uint32_t>(inst->GetImms()[1]);
            }

            ArenaVector<es2panda::ir::Expression *> arguments(enc->parser_program_->Allocator()->Adapter());
            for (uint32_t i = 1; i <= argsum; ++i) {
                arguments.push_back(*enc->get_expression_by_id(inst, i));
            }

            
            es2panda::ir::CallExpression* callarg0expression = AllocNode<es2panda::ir::CallExpression>(enc, 
                                                                                funname,
                                                                                std::move(arguments),
                                                                                nullptr,
                                                                                false
                                                                            );
            enc->set_expression_by_register(inst, inst->GetDstReg(), callarg0expression);
            break;
        }

       case compiler::RuntimeInterface::IntrinsicId::DELOBJPROP_V8:
       {
            panda::es2panda::ir::Expression* obj_expression = *enc->get_expression_by_id(inst, 0);
            panda::es2panda::ir::Expression* attr_expression = *enc->get_expression_by_id(inst, inst->GetInputsCount() - 2);

            auto objattrexpression = AllocNode<es2panda::ir::MemberExpression>(enc,
                                                        obj_expression,
                                                        attr_expression, 
                                                        es2panda::ir::MemberExpression::MemberExpressionKind::PROPERTY_ACCESS, 
                                                        true, 
                                                        false);



            auto unaryexpression = AllocNode<es2panda::ir::UnaryExpression>(enc, 
                                                            objattrexpression,
                                                            UnaryPrefixIntrinsicIdToToken(inst->GetIntrinsicId())
            );

            enc->set_expression_by_register(inst, inst->GetDstReg(), unaryexpression);
            break;
        }


       case compiler::RuntimeInterface::IntrinsicId::CALLRUNTIME_ISFALSE_PREF_IMM8:
       {
            panda::es2panda::ir::Expression* funname = enc->get_identifier_byname(new std::string("runtime.isfalse"));
            ArenaVector<es2panda::ir::Expression *> arguments(enc->parser_program_->Allocator()->Adapter());

            arguments.push_back(*enc->get_expression_by_id(inst, inst->GetInputsCount() - 2));

            auto callexpression = AllocNode<es2panda::ir::CallExpression>(enc, 
                                                                funname,
                                                                std::move(arguments),
                                                                nullptr,
                                                                false
                                                                );

            enc->set_expression_by_register(inst, inst->GetDstReg(), callexpression);
            break;
        }

       case compiler::RuntimeInterface::IntrinsicId::CALLRUNTIME_ISTRUE_PREF_IMM8:
       {
            panda::es2panda::ir::Expression* funname = enc->get_identifier_byname(new std::string("runtime.istrue"));
            ArenaVector<es2panda::ir::Expression *> arguments(enc->parser_program_->Allocator()->Adapter());
            arguments.push_back(*enc->get_expression_by_id(inst, inst->GetInputsCount() - 2));

            auto callexpression = AllocNode<es2panda::ir::CallExpression>(enc, 
                                                                funname,
                                                                std::move(arguments),
                                                                nullptr,
                                                                false
                                                                );

            enc->set_expression_by_register(inst, inst->GetDstReg(), callexpression);
            break;
        }


        case compiler::RuntimeInterface::IntrinsicId::RETURN:
        {
            auto returnexpression = *enc->get_expression_by_id(inst, inst->GetInputsCount() - 2); 
            auto returnstatement = AllocNode<es2panda::ir::ReturnStatement>(enc,  returnexpression);
            enc->add_insAst_to_blockstatemnt_by_inst(inst, returnstatement);
            break;
        }

       case compiler::RuntimeInterface::IntrinsicId::THROW_PREF_NONE:
       {
            auto argument = *enc->get_expression_by_id(inst, inst->GetInputsCount() - 2);

            auto throwStatement = AllocNode<es2panda::ir::ThrowStatement>(enc, argument);
            enc->add_insAst_to_blockstatemnt_by_inst(inst, throwStatement);
            break;
        }

       case compiler::RuntimeInterface::IntrinsicId::STOWNBYVALUEWITHNAMESET_IMM16_V8_V8: // tobetested
       case compiler::RuntimeInterface::IntrinsicId::STOWNBYVALUEWITHNAMESET_IMM8_V8_V8:  // tobetested
       case compiler::RuntimeInterface::IntrinsicId::STOWNBYVALUE_IMM16_V8_V8:
       case compiler::RuntimeInterface::IntrinsicId::STOWNBYVALUE_IMM8_V8_V8:
       {
            panda::es2panda::ir::Identifier* obj_reg_identifier = enc->get_identifier_byreg(inst->GetSrcReg(0));
            auto expression1 = *enc->get_expression_by_id(inst, 0);

            enc->set_expression_by_register(inst->GetInput(0).GetInst(), inst->GetSrcReg(0), obj_reg_identifier);
            ArenaVector<es2panda::ir::VariableDeclarator *> declarators1(enc->parser_program_->Allocator()->Adapter());
            auto *declarator1 = AllocNode<es2panda::ir::VariableDeclarator>(enc,
                                                                                obj_reg_identifier, 
                                                                                expression1);
            declarators1.push_back(declarator1);
            auto variadeclaration1 = AllocNode<es2panda::ir::VariableDeclaration>(enc, 
                                                                                    es2panda::ir::VariableDeclaration::VariableDeclarationKind::VAR,
                                                                                    std::move(declarators1),
                                                                                    true
                                                                                );
            enc->add_insAst_to_blockstatemnt_by_inst(inst, variadeclaration1);
            
            
            ///////////////////////////////////////////////////////////////////////////////////////////////////////////////
            panda::es2panda::ir::Identifier* index_reg_identifier = enc->get_identifier_byreg(inst->GetSrcReg(1));
            auto expression2 = *enc->get_expression_by_id(inst, 1);

            enc->set_expression_by_register(inst->GetInput(1).GetInst(), inst->GetSrcReg(0), index_reg_identifier);

            ArenaVector<es2panda::ir::VariableDeclarator *> declarators2(enc->parser_program_->Allocator()->Adapter());
            auto *declarator2 = AllocNode<es2panda::ir::VariableDeclarator>(enc,
                                                                                index_reg_identifier, 
                                                                                expression2);
            declarators2.push_back(declarator2);
            auto variadeclaration2 = AllocNode<es2panda::ir::VariableDeclaration>(enc, 
                                                                                    es2panda::ir::VariableDeclaration::VariableDeclarationKind::VAR,
                                                                                    std::move(declarators2),
                                                                                    true
                                                                                );
            enc->add_insAst_to_blockstatemnt_by_inst(inst, variadeclaration2);

            ///////////////////////////////////////////////////////////////////////////////////////////////////////////////
            auto objattrexpression = AllocNode<es2panda::ir::MemberExpression>(enc,
                                                        obj_reg_identifier,
                                                        index_reg_identifier, 
                                                        es2panda::ir::MemberExpression::MemberExpressionKind::PROPERTY_ACCESS, 
                                                        true, 
                                                        false);   
            panda::es2panda::ir::Expression* assignexpression =   AllocNode<es2panda::ir::AssignmentExpression>(enc, 
                                                                            objattrexpression,
                                                                            *enc->get_expression_by_id(inst, inst->GetInputsCount() - 2),
                                                                            es2panda::lexer::TokenType::PUNCTUATOR_SUBSTITUTION
                                                                        ); 
            auto assignstatement = AllocNode<es2panda::ir::ExpressionStatement>(enc, 
                                                                                assignexpression);
            enc->add_insAst_to_blockstatemnt_by_inst(inst, assignstatement);

            break;
        }

        case compiler::RuntimeInterface::IntrinsicId::STOWNBYINDEX_IMM8_V8_IMM16: // tobetested
        case compiler::RuntimeInterface::IntrinsicId::STOWNBYINDEX_IMM16_V8_IMM16: // tobetested
        case compiler::RuntimeInterface::IntrinsicId::WIDE_STOWNBYINDEX_PREF_V8_IMM32: // tobetested
       {
            uint32_t imm;
            if(inst->GetIntrinsicId() == compiler::RuntimeInterface::IntrinsicId::WIDE_STOWNBYINDEX_PREF_V8_IMM32){
                imm = static_cast<uint32_t>(inst->GetImms()[0]);
            }else{
                imm = static_cast<uint32_t>(inst->GetImms()[1]);
            }

            panda::es2panda::ir::Identifier* obj_reg_identifier = enc->get_identifier_byreg(inst->GetSrcReg(0));
            auto expression1 = *enc->get_expression_by_id(inst, 0);

            enc->set_expression_by_register(inst->GetInput(0).GetInst(), inst->GetSrcReg(0), obj_reg_identifier);
            ArenaVector<es2panda::ir::VariableDeclarator *> declarators1(enc->parser_program_->Allocator()->Adapter());
            auto *declarator1 = AllocNode<es2panda::ir::VariableDeclarator>(enc,
                                                                                obj_reg_identifier, 
                                                                                expression1);
            declarators1.push_back(declarator1);
            auto variadeclaration1 = AllocNode<es2panda::ir::VariableDeclaration>(enc, 
                                                                                    es2panda::ir::VariableDeclaration::VariableDeclarationKind::VAR,
                                                                                    std::move(declarators1),
                                                                                    true
                                                                                );
            enc->add_insAst_to_blockstatemnt_by_inst(inst, variadeclaration1);
            
            ///////////////////////////////////////////////////////////////////////////////////////////////////////////////
            auto objattrexpression = AllocNode<es2panda::ir::MemberExpression>(enc,
                                                        obj_reg_identifier,
                                                        enc->get_literal_bynum(imm),  
                                                        es2panda::ir::MemberExpression::MemberExpressionKind::PROPERTY_ACCESS, 
                                                        true, 
                                                        false);   
            panda::es2panda::ir::Expression* assignexpression =   AllocNode<es2panda::ir::AssignmentExpression>(enc, 
                                                                            objattrexpression,
                                                                            *enc->get_expression_by_id(inst, inst->GetInputsCount() - 2),
                                                                            es2panda::lexer::TokenType::PUNCTUATOR_SUBSTITUTION
                                                                        ); 
            auto assignstatement = AllocNode<es2panda::ir::ExpressionStatement>(enc, 
                                                                                assignexpression);
            enc->add_insAst_to_blockstatemnt_by_inst(inst, assignstatement);

            break;
        }

       case compiler::RuntimeInterface::IntrinsicId::STOWNBYNAME_IMM8_ID16_V8:
       case compiler::RuntimeInterface::IntrinsicId::STOWNBYNAME_IMM16_ID16_V8:
       case compiler::RuntimeInterface::IntrinsicId::STOWNBYNAMEWITHNAMESET_IMM8_ID16_V8:
       case compiler::RuntimeInterface::IntrinsicId::STOWNBYNAMEWITHNAMESET_IMM16_ID16_V8:
       {
            panda::es2panda::ir::Identifier* obj_reg_identifier = enc->get_identifier_byreg(inst->GetSrcReg(0));
            auto expression1 = *enc->get_expression_by_id(inst, 0);

            enc->set_expression_by_register(inst->GetInput(0).GetInst(), inst->GetSrcReg(0), obj_reg_identifier);
            ArenaVector<es2panda::ir::VariableDeclarator *> declarators1(enc->parser_program_->Allocator()->Adapter());
            auto *declarator1 = AllocNode<es2panda::ir::VariableDeclarator>(enc,
                                                                                obj_reg_identifier, 
                                                                                expression1);
            declarators1.push_back(declarator1);
            auto variadeclaration1 = AllocNode<es2panda::ir::VariableDeclaration>(enc, 
                                                                                    es2panda::ir::VariableDeclaration::VariableDeclarationKind::VAR,
                                                                                    std::move(declarators1),
                                                                                    true
                                                                                );
            enc->add_insAst_to_blockstatemnt_by_inst(inst, variadeclaration1);
            
            ///////////////////////////////////////////////////////////////////////////////////////////////////////////////
            auto ir_id0 = static_cast<uint32_t>(inst->GetImms()[1]);
            auto bc_id0 = enc->ir_interface_->GetStringIdByOffset(ir_id0);

            std::string* global_name = new std::string(bc_id0);
            auto objattrexpression = AllocNode<es2panda::ir::MemberExpression>(enc,
                                                        obj_reg_identifier,
                                                        enc->get_identifier_byname(global_name),
                                                        es2panda::ir::MemberExpression::MemberExpressionKind::PROPERTY_ACCESS, 
                                                        false, 
                                                        false);   
            panda::es2panda::ir::Expression* assignexpression =   AllocNode<es2panda::ir::AssignmentExpression>(enc, 
                                                                            objattrexpression,
                                                                            *enc->get_expression_by_id(inst, inst->GetInputsCount() - 2),
                                                                            es2panda::lexer::TokenType::PUNCTUATOR_SUBSTITUTION
                                                                        ); 
            auto assignstatement = AllocNode<es2panda::ir::ExpressionStatement>(enc, 
                                                                                assignexpression);
            enc->add_insAst_to_blockstatemnt_by_inst(inst, assignstatement);

            break;
        }
 

        case compiler::RuntimeInterface::IntrinsicId::DEFINEFUNC_IMM8_ID16_IMM8:
        case compiler::RuntimeInterface::IntrinsicId::DEFINEFUNC_IMM16_ID16_IMM8:
        {
            std::cout << "define function >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>" << std::endl;
            auto methodoffset = static_cast<uint32_t>(inst->GetImms()[1]);
            std::cout << "new func offset: " << methodoffset << std::endl;

            
            std::cout << "before size: " << enc->method2lexicalenvstack->size() <<  std::endl;

            if(!enc->bb2lexicalenvstack[inst->GetBasicBlock()]->empty()){
                if(enc->bb2lexicalenvstack[inst->GetBasicBlock()]->top().IsFull() ){
                    (*enc->method2lexicalenvstack)[methodoffset] = new LexicalEnvStack(*(enc->bb2lexicalenvstack[inst->GetBasicBlock()]));
                    std::cout << "after  size: " << enc->method2lexicalenvstack->size() << ", envsize: " << (*enc->method2lexicalenvstack)[methodoffset]->size()  << std::endl;

                }else{
                    enc->waitmethods.push(methodoffset);
                }
            }

            // enc->set_expression_by_register(inst, inst->GetDstReg(), enc->DEFINEFUNC);

            auto ir_id0 = static_cast<uint32_t>(inst->GetImms()[1]);
            auto bc_id0 = enc->ir_interface_->GetMethodIdByOffset(ir_id0);
 
            enc->set_expression_by_register(inst, inst->GetDstReg(), enc->get_identifier_byname(new std::string(bc_id0)));
            break;
        }

       case compiler::RuntimeInterface::IntrinsicId::WIDE_NEWLEXENVWITHNAME_PREF_IMM16_ID16:// current no use default name
        case compiler::RuntimeInterface::IntrinsicId::NEWLEXENVWITHNAME_IMM8_ID16: // current no use default name
        case compiler::RuntimeInterface::IntrinsicId::WIDE_NEWLEXENV_PREF_IMM16:
        case compiler::RuntimeInterface::IntrinsicId::NEWLEXENV_IMM8:
        {
            std::cout << "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA" << std::endl;
            auto lexenv_size = static_cast<uint32_t>(inst->GetImms()[0]);
            std::cout << "lexenv_size: " << lexenv_size << std::endl;
            auto lexicalenvstack = enc->bb2lexicalenvstack[inst->GetBasicBlock()];
            std::cout << "size: " << lexicalenvstack->size() << std::endl; 
            lexicalenvstack->push(lexenv_size);
            //enc->acc_lexicalenv = lexicalenvstack->push(lexenv_size);
            //std::cout << "size: " << lexicalenvstack->size() << " ,enc->acc_lexicalenv: " << enc->acc_lexicalenv->size() << std::endl; 

            break;
        }

       case compiler::RuntimeInterface::IntrinsicId::STLEXVAR_IMM4_IMM4:
       case compiler::RuntimeInterface::IntrinsicId::STLEXVAR_IMM8_IMM8:
       case compiler::RuntimeInterface::IntrinsicId::WIDE_STLEXVAR_PREF_IMM16_IMM16:
       {
            std::cout << "BBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBB" << std::endl;
            std::cout << enc->methodoffset << std::endl;

            auto tier = static_cast<uint32_t>(inst->GetImms()[0]);
            auto index = static_cast<uint32_t>(inst->GetImms()[1]);

            std::cout << "tier: " << std::to_string(tier) << ", index: " << std::to_string(index) << std::endl;

            auto lexicalenvstack = enc->bb2lexicalenvstack[inst->GetBasicBlock()];
            std::cout << "size: " << lexicalenvstack->size() << std::endl; 
            std::cout << "env size: " << lexicalenvstack->getLexicalEnv(0).size() << std::endl;

            auto raw_expression  = *enc->get_expression_by_id(inst, inst->GetInputsCount() - 2);
            std::string closure_name =  "closure_" + std::to_string(enc->methodoffset) + "_" + std::to_string(enc->closure_count);
            enc->closure_count++;

            panda::es2panda::ir::Expression* assignexpression =   AllocNode<es2panda::ir::AssignmentExpression>(enc, 
                                                                            enc->get_identifier_byname(new std::string(closure_name)),
                                                                            raw_expression,
                                                                            es2panda::lexer::TokenType::PUNCTUATOR_SUBSTITUTION
                                                                        ); 
            auto assignstatement = AllocNode<es2panda::ir::ExpressionStatement>(enc, 
                                                                                assignexpression);
            enc->add_insAst_to_blockstatemnt_by_inst(inst, assignstatement);
            lexicalenvstack->set(tier, index, new std::string(closure_name));

            std::cout << "size: " << lexicalenvstack->size() << std::endl;
            std::cout << "env size: " << lexicalenvstack->getLexicalEnv(0).size() << std::endl;

            ////////////////////////////////////////////////////////////////////////////////
            /// deal forward reference stack
            
            if(enc->bb2lexicalenvstack[inst->GetBasicBlock()]->top().IsFull() ){
                std::cout << "@@@@@@ start deal forward reference stack >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>" << std::endl;
                while(!enc->waitmethods.empty()){
                    auto curmethodoffset = enc->waitmethods.top();
                    (*enc->method2lexicalenvstack)[curmethodoffset] = new LexicalEnvStack(*(enc->bb2lexicalenvstack[inst->GetBasicBlock()]));
                     enc->waitmethods.pop();
                }
            }
            break;
        }

        case compiler::RuntimeInterface::IntrinsicId::LDLEXVAR_IMM4_IMM4:
        case compiler::RuntimeInterface::IntrinsicId::LDLEXVAR_IMM8_IMM8:
        case compiler::RuntimeInterface::IntrinsicId::WIDE_LDLEXVAR_PREF_IMM16_IMM16:
       {
            std::cout << "CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC" << std::endl;
            std::cout << enc->methodoffset << std::endl;
            auto tier = static_cast<uint32_t>(inst->GetImms()[0]);
            auto index = static_cast<uint32_t>(inst->GetImms()[1]);

            std::cout << "tier: " << std::to_string(tier) << ", index: " << std::to_string(index) << std::endl;
            auto lexicalenvstack = enc->bb2lexicalenvstack[inst->GetBasicBlock()];
            std::cout << "size: " << lexicalenvstack->size() << std::endl;

            if(lexicalenvstack->getLexicalEnv(tier)[index] == nullptr){
                std::cout << "lexicalenv null" << std::endl;
            }else{
                std::cout << "lexicalenv not null" << std::endl;
            }

            auto identifier_name = lexicalenvstack->get(tier, index);
            enc->set_expression_by_register(inst, inst->GetDstReg(), enc->get_identifier_byname(new std::string(*identifier_name)));

            break;
        }

        case compiler::RuntimeInterface::IntrinsicId::POPLEXENV:
        {
            auto lexicalenvstack = enc->bb2lexicalenvstack[inst->GetBasicBlock()];
            lexicalenvstack->pop();
            break;
        }


       /////////////////////////////////////////////////////////////////////////////////////
        /////////////////////////////////////////////////////////////////////////////////////
        /////////////////////////////////////////////////////////////////////////////////////
        /////////////////////////////////////////////////////////////////////////////////////
        /////////////////////////////////////////////////////////////////////////////////////
        /////////////////////////////////////////////////////////////////////////////////////

       case compiler::RuntimeInterface::IntrinsicId::GETITERATOR_IMM8:
       case compiler::RuntimeInterface::IntrinsicId::GETITERATOR_IMM16:
       {
            std::cout << "111111111111111111111111111111" << std::endl;
            panda::es2panda::ir::Expression* funname = enc->get_identifier_byname(new std::string("GetIterator"));
            std::cout << "222222222222222222222222222222" << std::endl;
            ArenaVector<es2panda::ir::Expression *> arguments(enc->parser_program_->Allocator()->Adapter());
            std::cout << "333333333333333333333333333333" << std::endl;

            arguments.push_back(*enc->get_expression_by_id(inst, inst->GetInputsCount() - 2));
            std::cout << "555555555555555555555555555555" << std::endl;
            auto callexpression = AllocNode<es2panda::ir::CallExpression>(enc, 
                                                                funname,
                                                                std::move(arguments),
                                                                nullptr,
                                                                false
                                                                );
            std::cout << "666666666666666666666666666666" << std::endl;
            std::cout << "777777777777777777777777777777" << std::endl;
            enc->set_expression_by_register(inst, inst->GetDstReg(), callexpression);
            std::cout << "888888888888888888888888888888" << std::endl;
 

            break;
        }

       case compiler::RuntimeInterface::IntrinsicId::DEFINEMETHOD_IMM8_ID16_IMM8:
       {
            auto acc_src = inst->GetSrcReg(inst->GetInputsCount() - 2);
            if (acc_src != compiler::ACC_REG_ID) {
                DoLda(acc_src, enc->result_);
            }
           ASSERT(inst->HasImms() && inst->GetImms().size() > 0); // NOLINTNEXTLINE(readability-container-size-empty)
            auto imm0 = static_cast<uint32_t>(inst->GetImms()[0]);
            ASSERT(inst->HasImms() && inst->GetImms().size() > 1); // NOLINTNEXTLINE(readability-container-size-empty)
            auto ir_id0 = static_cast<uint32_t>(inst->GetImms()[1]);
            auto bc_id0 = enc->ir_interface_->GetMethodIdByOffset(ir_id0);
           ASSERT(inst->HasImms() && inst->GetImms().size() > 2); // NOLINTNEXTLINE(readability-container-size-empty)
            auto imm2 = static_cast<uint32_t>(inst->GetImms()[2]);
            enc->result_.emplace_back(pandasm::Create_DEFINEMETHOD(imm0, bc_id0, imm2));
            auto acc_dst = inst->GetDstReg();
            if (acc_dst != compiler::ACC_REG_ID) {
                DoSta(inst->GetDstReg(), enc->result_);
            }
            break;
        }
       case compiler::RuntimeInterface::IntrinsicId::DEFINECLASSWITHBUFFER_IMM8_ID16_ID16_IMM16_V8:
       {
           ASSERT(inst->HasImms() && inst->GetImms().size() > 0); // NOLINTNEXTLINE(readability-container-size-empty)
            auto imm0 = static_cast<uint32_t>(inst->GetImms()[0]);
            ASSERT(inst->HasImms() && inst->GetImms().size() > 1); // NOLINTNEXTLINE(readability-container-size-empty)
            auto ir_id0 = static_cast<uint32_t>(inst->GetImms()[1]);
            auto bc_id0 = enc->ir_interface_->GetMethodIdByOffset(ir_id0);
            ASSERT(inst->HasImms() && inst->GetImms().size() > 2); // NOLINTNEXTLINE(readability-container-size-empty)
            auto ir_id1 = static_cast<uint32_t>(inst->GetImms()[2]);
            auto bc_id1 = enc->ir_interface_->GetLiteralArrayByOffset(ir_id1);
           ASSERT(inst->HasImms() && inst->GetImms().size() > 3); // NOLINTNEXTLINE(readability-container-size-empty)
            auto imm3 = static_cast<uint32_t>(inst->GetImms()[3]);
            auto v0 = inst->GetSrcReg(0);
            enc->result_.emplace_back(pandasm::Create_DEFINECLASSWITHBUFFER(imm0, bc_id0, bc_id1, imm3, v0));
            auto acc_dst = inst->GetDstReg();
            if (acc_dst != compiler::ACC_REG_ID) {
                DoSta(inst->GetDstReg(), enc->result_);
            }
            break;
        }
       case compiler::RuntimeInterface::IntrinsicId::GETNEXTPROPNAME_V8:
       {
            auto v0 = inst->GetSrcReg(0);
            enc->result_.emplace_back(pandasm::Create_GETNEXTPROPNAME(v0));
            auto acc_dst = inst->GetDstReg();
            if (acc_dst != compiler::ACC_REG_ID) {
                DoSta(inst->GetDstReg(), enc->result_);
            }
            break;
        }


       case compiler::RuntimeInterface::IntrinsicId::LDSUPERBYVALUE_IMM8_V8:
       {
            auto acc_src = inst->GetSrcReg(inst->GetInputsCount() - 2);
            if (acc_src != compiler::ACC_REG_ID) {
                DoLda(acc_src, enc->result_);
            }
           ASSERT(inst->HasImms() && inst->GetImms().size() > 0); // NOLINTNEXTLINE(readability-container-size-empty)
            auto imm0 = static_cast<uint32_t>(inst->GetImms()[0]);
            auto v0 = inst->GetSrcReg(0);
            enc->result_.emplace_back(pandasm::Create_LDSUPERBYVALUE(imm0, v0));
            auto acc_dst = inst->GetDstReg();
            if (acc_dst != compiler::ACC_REG_ID) {
                DoSta(inst->GetDstReg(), enc->result_);
            }
            break;
        }




       

       case compiler::RuntimeInterface::IntrinsicId::LDSUPERBYNAME_IMM8_ID16:
       {
            auto acc_src = inst->GetSrcReg(inst->GetInputsCount() - 2);
            if (acc_src != compiler::ACC_REG_ID) {
                DoLda(acc_src, enc->result_);
            }
           ASSERT(inst->HasImms() && inst->GetImms().size() > 0); // NOLINTNEXTLINE(readability-container-size-empty)
            auto imm0 = static_cast<uint32_t>(inst->GetImms()[0]);
            ASSERT(inst->HasImms() && inst->GetImms().size() > 1); // NOLINTNEXTLINE(readability-container-size-empty)
            auto ir_id0 = static_cast<uint32_t>(inst->GetImms()[1]);
            auto bc_id0 = enc->ir_interface_->GetStringIdByOffset(ir_id0);
            enc->result_.emplace_back(pandasm::Create_LDSUPERBYNAME(imm0, bc_id0));
            auto acc_dst = inst->GetDstReg();
            if (acc_dst != compiler::ACC_REG_ID) {
                DoSta(inst->GetDstReg(), enc->result_);
            }
            break;
        }


        

       case compiler::RuntimeInterface::IntrinsicId::LDTHISBYNAME_IMM8_ID16:
       {
           ASSERT(inst->HasImms() && inst->GetImms().size() > 0); // NOLINTNEXTLINE(readability-container-size-empty)
            auto imm0 = static_cast<uint32_t>(inst->GetImms()[0]);
            ASSERT(inst->HasImms() && inst->GetImms().size() > 1); // NOLINTNEXTLINE(readability-container-size-empty)
            auto ir_id0 = static_cast<uint32_t>(inst->GetImms()[1]);
            auto bc_id0 = enc->ir_interface_->GetStringIdByOffset(ir_id0);
            enc->result_.emplace_back(pandasm::Create_LDTHISBYNAME(imm0, bc_id0));
            auto acc_dst = inst->GetDstReg();
            if (acc_dst != compiler::ACC_REG_ID) {
                DoSta(inst->GetDstReg(), enc->result_);
            }
            break;
        }
       case compiler::RuntimeInterface::IntrinsicId::STTHISBYNAME_IMM8_ID16:
       {
            auto acc_src = inst->GetSrcReg(inst->GetInputsCount() - 2);
            if (acc_src != compiler::ACC_REG_ID) {
                DoLda(acc_src, enc->result_);
            }
           ASSERT(inst->HasImms() && inst->GetImms().size() > 0); // NOLINTNEXTLINE(readability-container-size-empty)
            auto imm0 = static_cast<uint32_t>(inst->GetImms()[0]);
            ASSERT(inst->HasImms() && inst->GetImms().size() > 1); // NOLINTNEXTLINE(readability-container-size-empty)
            auto ir_id0 = static_cast<uint32_t>(inst->GetImms()[1]);
            auto bc_id0 = enc->ir_interface_->GetStringIdByOffset(ir_id0);
            enc->result_.emplace_back(pandasm::Create_STTHISBYNAME(imm0, bc_id0));
            break;
        }
       case compiler::RuntimeInterface::IntrinsicId::LDTHISBYVALUE_IMM8:
       {
            auto acc_src = inst->GetSrcReg(inst->GetInputsCount() - 2);
            if (acc_src != compiler::ACC_REG_ID) {
                DoLda(acc_src, enc->result_);
            }
           ASSERT(inst->HasImms() && inst->GetImms().size() > 0); // NOLINTNEXTLINE(readability-container-size-empty)
            auto imm0 = static_cast<uint32_t>(inst->GetImms()[0]);
            enc->result_.emplace_back(pandasm::Create_LDTHISBYVALUE(imm0));
            auto acc_dst = inst->GetDstReg();
            if (acc_dst != compiler::ACC_REG_ID) {
                DoSta(inst->GetDstReg(), enc->result_);
            }
            break;
        }
       case compiler::RuntimeInterface::IntrinsicId::STTHISBYVALUE_IMM8_V8:
       {
            auto acc_src = inst->GetSrcReg(inst->GetInputsCount() - 2);
            if (acc_src != compiler::ACC_REG_ID) {
                DoLda(acc_src, enc->result_);
            }
           ASSERT(inst->HasImms() && inst->GetImms().size() > 0); // NOLINTNEXTLINE(readability-container-size-empty)
            auto imm0 = static_cast<uint32_t>(inst->GetImms()[0]);
            auto v0 = inst->GetSrcReg(0);
            enc->result_.emplace_back(pandasm::Create_STTHISBYVALUE(imm0, v0));
            break;
        }


       case compiler::RuntimeInterface::IntrinsicId::GETPROPITERATOR:
       {
            auto acc_src = inst->GetSrcReg(inst->GetInputsCount() - 2);
            if (acc_src != compiler::ACC_REG_ID) {
                DoLda(acc_src, enc->result_);
            }
            enc->result_.emplace_back(pandasm::Create_GETPROPITERATOR());
            auto acc_dst = inst->GetDstReg();
            if (acc_dst != compiler::ACC_REG_ID) {
                DoSta(inst->GetDstReg(), enc->result_);
            }
            break;
        }

       case compiler::RuntimeInterface::IntrinsicId::CLOSEITERATOR_IMM8_V8:
       {
           ASSERT(inst->HasImms() && inst->GetImms().size() > 0); // NOLINTNEXTLINE(readability-container-size-empty)
            auto imm0 = static_cast<uint32_t>(inst->GetImms()[0]);
            auto v0 = inst->GetSrcReg(0);
            enc->result_.emplace_back(pandasm::Create_CLOSEITERATOR(imm0, v0));
            auto acc_dst = inst->GetDstReg();
            if (acc_dst != compiler::ACC_REG_ID) {
                DoSta(inst->GetDstReg(), enc->result_);
            }
            break;
        }

       case compiler::RuntimeInterface::IntrinsicId::GETUNMAPPEDARGS:
       {
            enc->result_.emplace_back(pandasm::Create_GETUNMAPPEDARGS());
            auto acc_dst = inst->GetDstReg();
            if (acc_dst != compiler::ACC_REG_ID) {
                DoSta(inst->GetDstReg(), enc->result_);
            }
            break;
        }
       case compiler::RuntimeInterface::IntrinsicId::LDGLOBAL:
       {
            enc->result_.emplace_back(pandasm::Create_LDGLOBAL());
            auto acc_dst = inst->GetDstReg();
            if (acc_dst != compiler::ACC_REG_ID) {
                DoSta(inst->GetDstReg(), enc->result_);
            }
            break;
        }
       case compiler::RuntimeInterface::IntrinsicId::LDNEWTARGET:
       {
            enc->result_.emplace_back(pandasm::Create_LDNEWTARGET());
            auto acc_dst = inst->GetDstReg();
            if (acc_dst != compiler::ACC_REG_ID) {
                DoSta(inst->GetDstReg(), enc->result_);
            }
            break;
        }
       case compiler::RuntimeInterface::IntrinsicId::LDTHIS:
       {
            enc->result_.emplace_back(pandasm::Create_LDTHIS());
            auto acc_dst = inst->GetDstReg();
            if (acc_dst != compiler::ACC_REG_ID) {
                DoSta(inst->GetDstReg(), enc->result_);
            }
            break;
        }

       case compiler::RuntimeInterface::IntrinsicId::CREATEREGEXPWITHLITERAL_IMM8_ID16_IMM8:
       {
           ASSERT(inst->HasImms() && inst->GetImms().size() > 0); // NOLINTNEXTLINE(readability-container-size-empty)
            auto imm0 = static_cast<uint32_t>(inst->GetImms()[0]);
            ASSERT(inst->HasImms() && inst->GetImms().size() > 1); // NOLINTNEXTLINE(readability-container-size-empty)
            auto ir_id0 = static_cast<uint32_t>(inst->GetImms()[1]);
            auto bc_id0 = enc->ir_interface_->GetStringIdByOffset(ir_id0);
           ASSERT(inst->HasImms() && inst->GetImms().size() > 2); // NOLINTNEXTLINE(readability-container-size-empty)
            auto imm2 = static_cast<uint32_t>(inst->GetImms()[2]);
            enc->result_.emplace_back(pandasm::Create_CREATEREGEXPWITHLITERAL(imm0, bc_id0, imm2));
            auto acc_dst = inst->GetDstReg();
            if (acc_dst != compiler::ACC_REG_ID) {
                DoSta(inst->GetDstReg(), enc->result_);
            }
            break;
        }
       case compiler::RuntimeInterface::IntrinsicId::CREATEREGEXPWITHLITERAL_IMM16_ID16_IMM8:
       {
           ASSERT(inst->HasImms() && inst->GetImms().size() > 0); // NOLINTNEXTLINE(readability-container-size-empty)
            auto imm0 = static_cast<uint32_t>(inst->GetImms()[0]);
            ASSERT(inst->HasImms() && inst->GetImms().size() > 1); // NOLINTNEXTLINE(readability-container-size-empty)
            auto ir_id0 = static_cast<uint32_t>(inst->GetImms()[1]);
            auto bc_id0 = enc->ir_interface_->GetStringIdByOffset(ir_id0);
           ASSERT(inst->HasImms() && inst->GetImms().size() > 2); // NOLINTNEXTLINE(readability-container-size-empty)
            auto imm2 = static_cast<uint32_t>(inst->GetImms()[2]);
            enc->result_.emplace_back(pandasm::Create_CREATEREGEXPWITHLITERAL(imm0, bc_id0, imm2));
            auto acc_dst = inst->GetDstReg();
            if (acc_dst != compiler::ACC_REG_ID) {
                DoSta(inst->GetDstReg(), enc->result_);
            }
            break;
        }

       case compiler::RuntimeInterface::IntrinsicId::DEFINECLASSWITHBUFFER_IMM16_ID16_ID16_IMM16_V8:
       {
           ASSERT(inst->HasImms() && inst->GetImms().size() > 0); // NOLINTNEXTLINE(readability-container-size-empty)
            auto imm0 = static_cast<uint32_t>(inst->GetImms()[0]);
            ASSERT(inst->HasImms() && inst->GetImms().size() > 1); // NOLINTNEXTLINE(readability-container-size-empty)
            auto ir_id0 = static_cast<uint32_t>(inst->GetImms()[1]);
            auto bc_id0 = enc->ir_interface_->GetMethodIdByOffset(ir_id0);
            ASSERT(inst->HasImms() && inst->GetImms().size() > 2); // NOLINTNEXTLINE(readability-container-size-empty)
            auto ir_id1 = static_cast<uint32_t>(inst->GetImms()[2]);
            auto bc_id1 = enc->ir_interface_->GetLiteralArrayByOffset(ir_id1);
           ASSERT(inst->HasImms() && inst->GetImms().size() > 3); // NOLINTNEXTLINE(readability-container-size-empty)
            auto imm3 = static_cast<uint32_t>(inst->GetImms()[3]);
            auto v0 = inst->GetSrcReg(0);
            enc->result_.emplace_back(pandasm::Create_DEFINECLASSWITHBUFFER(imm0, bc_id0, bc_id1, imm3, v0));
            auto acc_dst = inst->GetDstReg();
            if (acc_dst != compiler::ACC_REG_ID) {
                DoSta(inst->GetDstReg(), enc->result_);
            }
            break;
        }
       case compiler::RuntimeInterface::IntrinsicId::GETTEMPLATEOBJECT_IMM8:
       {
            auto acc_src = inst->GetSrcReg(inst->GetInputsCount() - 2);
            if (acc_src != compiler::ACC_REG_ID) {
                DoLda(acc_src, enc->result_);
            }
           ASSERT(inst->HasImms() && inst->GetImms().size() > 0); // NOLINTNEXTLINE(readability-container-size-empty)
            auto imm0 = static_cast<uint32_t>(inst->GetImms()[0]);
            enc->result_.emplace_back(pandasm::Create_GETTEMPLATEOBJECT(imm0));
            auto acc_dst = inst->GetDstReg();
            if (acc_dst != compiler::ACC_REG_ID) {
                DoSta(inst->GetDstReg(), enc->result_);
            }
            break;
        }
       case compiler::RuntimeInterface::IntrinsicId::SETOBJECTWITHPROTO_IMM8_V8:
       {
            auto acc_src = inst->GetSrcReg(inst->GetInputsCount() - 2);
            if (acc_src != compiler::ACC_REG_ID) {
                DoLda(acc_src, enc->result_);
            }
           ASSERT(inst->HasImms() && inst->GetImms().size() > 0); // NOLINTNEXTLINE(readability-container-size-empty)
            auto imm0 = static_cast<uint32_t>(inst->GetImms()[0]);
            auto v0 = inst->GetSrcReg(0);
            enc->result_.emplace_back(pandasm::Create_SETOBJECTWITHPROTO(imm0, v0));
            break;
        }

       case compiler::RuntimeInterface::IntrinsicId::GETMODULENAMESPACE_IMM8:
       {
           ASSERT(inst->HasImms() && inst->GetImms().size() > 0); // NOLINTNEXTLINE(readability-container-size-empty)
            auto imm0 = static_cast<uint32_t>(inst->GetImms()[0]);
            enc->result_.emplace_back(pandasm::Create_GETMODULENAMESPACE(imm0));
            auto acc_dst = inst->GetDstReg();
            if (acc_dst != compiler::ACC_REG_ID) {
                DoSta(inst->GetDstReg(), enc->result_);
            }
            break;
        }
       case compiler::RuntimeInterface::IntrinsicId::STMODULEVAR_IMM8:
       {
            auto acc_src = inst->GetSrcReg(inst->GetInputsCount() - 2);
            if (acc_src != compiler::ACC_REG_ID) {
                DoLda(acc_src, enc->result_);
            }
           ASSERT(inst->HasImms() && inst->GetImms().size() > 0); // NOLINTNEXTLINE(readability-container-size-empty)
            auto imm0 = static_cast<uint32_t>(inst->GetImms()[0]);
            enc->result_.emplace_back(pandasm::Create_STMODULEVAR(imm0));
            break;
        }
       case compiler::RuntimeInterface::IntrinsicId::LDLOCALMODULEVAR_IMM8:
       {
           ASSERT(inst->HasImms() && inst->GetImms().size() > 0); // NOLINTNEXTLINE(readability-container-size-empty)
            auto imm0 = static_cast<uint32_t>(inst->GetImms()[0]);
            enc->result_.emplace_back(pandasm::Create_LDLOCALMODULEVAR(imm0));
            auto acc_dst = inst->GetDstReg();
            if (acc_dst != compiler::ACC_REG_ID) {
                DoSta(inst->GetDstReg(), enc->result_);
            }
            break;
        }
       case compiler::RuntimeInterface::IntrinsicId::LDEXTERNALMODULEVAR_IMM8:
       {
           ASSERT(inst->HasImms() && inst->GetImms().size() > 0); // NOLINTNEXTLINE(readability-container-size-empty)
            auto imm0 = static_cast<uint32_t>(inst->GetImms()[0]);
            enc->result_.emplace_back(pandasm::Create_LDEXTERNALMODULEVAR(imm0));
            auto acc_dst = inst->GetDstReg();
            if (acc_dst != compiler::ACC_REG_ID) {
                DoSta(inst->GetDstReg(), enc->result_);
            }
            break;
        }
 
       case compiler::RuntimeInterface::IntrinsicId::LDSUPERBYVALUE_IMM16_V8:
       {
            auto acc_src = inst->GetSrcReg(inst->GetInputsCount() - 2);
            if (acc_src != compiler::ACC_REG_ID) {
                DoLda(acc_src, enc->result_);
            }
           ASSERT(inst->HasImms() && inst->GetImms().size() > 0); // NOLINTNEXTLINE(readability-container-size-empty)
            auto imm0 = static_cast<uint32_t>(inst->GetImms()[0]);
            auto v0 = inst->GetSrcReg(0);
            enc->result_.emplace_back(pandasm::Create_LDSUPERBYVALUE(imm0, v0));
            auto acc_dst = inst->GetDstReg();
            if (acc_dst != compiler::ACC_REG_ID) {
                DoSta(inst->GetDstReg(), enc->result_);
            }
            break;
        }
       
       case compiler::RuntimeInterface::IntrinsicId::LDSUPERBYNAME_IMM16_ID16:
       {
            auto acc_src = inst->GetSrcReg(inst->GetInputsCount() - 2);
            if (acc_src != compiler::ACC_REG_ID) {
                DoLda(acc_src, enc->result_);
            }
           ASSERT(inst->HasImms() && inst->GetImms().size() > 0); // NOLINTNEXTLINE(readability-container-size-empty)
            auto imm0 = static_cast<uint32_t>(inst->GetImms()[0]);
            ASSERT(inst->HasImms() && inst->GetImms().size() > 1); // NOLINTNEXTLINE(readability-container-size-empty)
            auto ir_id0 = static_cast<uint32_t>(inst->GetImms()[1]);
            auto bc_id0 = enc->ir_interface_->GetStringIdByOffset(ir_id0);
            enc->result_.emplace_back(pandasm::Create_LDSUPERBYNAME(imm0, bc_id0));
            auto acc_dst = inst->GetDstReg();
            if (acc_dst != compiler::ACC_REG_ID) {
                DoSta(inst->GetDstReg(), enc->result_);
            }
            break;
        }
       case compiler::RuntimeInterface::IntrinsicId::LDTHISBYNAME_IMM16_ID16:
       {
           ASSERT(inst->HasImms() && inst->GetImms().size() > 0); // NOLINTNEXTLINE(readability-container-size-empty)
            auto imm0 = static_cast<uint32_t>(inst->GetImms()[0]);
            ASSERT(inst->HasImms() && inst->GetImms().size() > 1); // NOLINTNEXTLINE(readability-container-size-empty)
            auto ir_id0 = static_cast<uint32_t>(inst->GetImms()[1]);
            auto bc_id0 = enc->ir_interface_->GetStringIdByOffset(ir_id0);
            enc->result_.emplace_back(pandasm::Create_LDTHISBYNAME(imm0, bc_id0));
            auto acc_dst = inst->GetDstReg();
            if (acc_dst != compiler::ACC_REG_ID) {
                DoSta(inst->GetDstReg(), enc->result_);
            }
            break;
        }
       case compiler::RuntimeInterface::IntrinsicId::STTHISBYNAME_IMM16_ID16:
       {
            auto acc_src = inst->GetSrcReg(inst->GetInputsCount() - 2);
            if (acc_src != compiler::ACC_REG_ID) {
                DoLda(acc_src, enc->result_);
            }
           ASSERT(inst->HasImms() && inst->GetImms().size() > 0); // NOLINTNEXTLINE(readability-container-size-empty)
            auto imm0 = static_cast<uint32_t>(inst->GetImms()[0]);
            ASSERT(inst->HasImms() && inst->GetImms().size() > 1); // NOLINTNEXTLINE(readability-container-size-empty)
            auto ir_id0 = static_cast<uint32_t>(inst->GetImms()[1]);
            auto bc_id0 = enc->ir_interface_->GetStringIdByOffset(ir_id0);
            enc->result_.emplace_back(pandasm::Create_STTHISBYNAME(imm0, bc_id0));
            break;
        }
       case compiler::RuntimeInterface::IntrinsicId::LDTHISBYVALUE_IMM16:
       {
            auto acc_src = inst->GetSrcReg(inst->GetInputsCount() - 2);
            if (acc_src != compiler::ACC_REG_ID) {
                DoLda(acc_src, enc->result_);
            }
           ASSERT(inst->HasImms() && inst->GetImms().size() > 0); // NOLINTNEXTLINE(readability-container-size-empty)
            auto imm0 = static_cast<uint32_t>(inst->GetImms()[0]);
            enc->result_.emplace_back(pandasm::Create_LDTHISBYVALUE(imm0));
            auto acc_dst = inst->GetDstReg();
            if (acc_dst != compiler::ACC_REG_ID) {
                DoSta(inst->GetDstReg(), enc->result_);
            }
            break;
        }
       case compiler::RuntimeInterface::IntrinsicId::STTHISBYVALUE_IMM16_V8:
       {
            auto acc_src = inst->GetSrcReg(inst->GetInputsCount() - 2);
            if (acc_src != compiler::ACC_REG_ID) {
                DoLda(acc_src, enc->result_);
            }
           ASSERT(inst->HasImms() && inst->GetImms().size() > 0); // NOLINTNEXTLINE(readability-container-size-empty)
            auto imm0 = static_cast<uint32_t>(inst->GetImms()[0]);
            auto v0 = inst->GetSrcReg(0);
            enc->result_.emplace_back(pandasm::Create_STTHISBYVALUE(imm0, v0));
            break;
        }
       case compiler::RuntimeInterface::IntrinsicId::ASYNCGENERATORREJECT_V8:
       {
            auto acc_src = inst->GetSrcReg(inst->GetInputsCount() - 2);
            if (acc_src != compiler::ACC_REG_ID) {
                DoLda(acc_src, enc->result_);
            }
            auto v0 = inst->GetSrcReg(0);
            enc->result_.emplace_back(pandasm::Create_ASYNCGENERATORREJECT(v0));
            auto acc_dst = inst->GetDstReg();
            if (acc_dst != compiler::ACC_REG_ID) {
                DoSta(inst->GetDstReg(), enc->result_);
            }
            break;
        }


       case compiler::RuntimeInterface::IntrinsicId::CLOSEITERATOR_IMM16_V8:
       {
           ASSERT(inst->HasImms() && inst->GetImms().size() > 0); // NOLINTNEXTLINE(readability-container-size-empty)
            auto imm0 = static_cast<uint32_t>(inst->GetImms()[0]);
            auto v0 = inst->GetSrcReg(0);
            enc->result_.emplace_back(pandasm::Create_CLOSEITERATOR(imm0, v0));
            auto acc_dst = inst->GetDstReg();
            if (acc_dst != compiler::ACC_REG_ID) {
                DoSta(inst->GetDstReg(), enc->result_);
            }
            break;
        }
       case compiler::RuntimeInterface::IntrinsicId::LDSYMBOL:
       {
            enc->result_.emplace_back(pandasm::Create_LDSYMBOL());
            auto acc_dst = inst->GetDstReg();
            if (acc_dst != compiler::ACC_REG_ID) {
                DoSta(inst->GetDstReg(), enc->result_);
            }
            break;
        }
       case compiler::RuntimeInterface::IntrinsicId::ASYNCFUNCTIONENTER:
       {
            enc->result_.emplace_back(pandasm::Create_ASYNCFUNCTIONENTER());
            auto acc_dst = inst->GetDstReg();
            if (acc_dst != compiler::ACC_REG_ID) {
                DoSta(inst->GetDstReg(), enc->result_);
            }
            break;
        }
       case compiler::RuntimeInterface::IntrinsicId::LDFUNCTION:
       {
            enc->result_.emplace_back(pandasm::Create_LDFUNCTION());
            auto acc_dst = inst->GetDstReg();
            if (acc_dst != compiler::ACC_REG_ID) {
                DoSta(inst->GetDstReg(), enc->result_);
            }
            break;
        }

       case compiler::RuntimeInterface::IntrinsicId::CREATEGENERATOROBJ_V8:
       {
            auto v0 = inst->GetSrcReg(0);
            enc->result_.emplace_back(pandasm::Create_CREATEGENERATOROBJ(v0));
            auto acc_dst = inst->GetDstReg();
            if (acc_dst != compiler::ACC_REG_ID) {
                DoSta(inst->GetDstReg(), enc->result_);
            }
            break;
        }
       case compiler::RuntimeInterface::IntrinsicId::CREATEITERRESULTOBJ_V8_V8:
       {
            auto v0 = inst->GetSrcReg(0);
            auto v1 = inst->GetSrcReg(1);
            enc->result_.emplace_back(pandasm::Create_CREATEITERRESULTOBJ(v0, v1));
            auto acc_dst = inst->GetDstReg();
            if (acc_dst != compiler::ACC_REG_ID) {
                DoSta(inst->GetDstReg(), enc->result_);
            }
            break;
        }
       case compiler::RuntimeInterface::IntrinsicId::CREATEOBJECTWITHEXCLUDEDKEYS_IMM8_V8_V8:
       {
           ASSERT(inst->HasImms() && inst->GetImms().size() > 0); // NOLINTNEXTLINE(readability-container-size-empty)
            auto imm0 = static_cast<uint32_t>(inst->GetImms()[0]);
            auto v0 = inst->GetSrcReg(0);
            auto v1 = inst->GetSrcReg(1);
            enc->result_.emplace_back(pandasm::Create_CREATEOBJECTWITHEXCLUDEDKEYS(imm0, v0, v1));
            auto acc_dst = inst->GetDstReg();
            if (acc_dst != compiler::ACC_REG_ID) {
                DoSta(inst->GetDstReg(), enc->result_);
            }
            break;
        }
       case compiler::RuntimeInterface::IntrinsicId::NEWOBJAPPLY_IMM8_V8:
       {
            std::cout << "compiler::RuntimeInterface::IntrinsicId::NEWOBJAPPLY_IMM8_V8 " << std::endl;
            auto acc_src = inst->GetSrcReg(inst->GetInputsCount() - 2);
            if (acc_src != compiler::ACC_REG_ID) {
                DoLda(acc_src, enc->result_);
            }
           ASSERT(inst->HasImms() && inst->GetImms().size() > 0); // NOLINTNEXTLINE(readability-container-size-empty)
            auto imm0 = static_cast<uint32_t>(inst->GetImms()[0]);
            auto v0 = inst->GetSrcReg(0);
            enc->result_.emplace_back(pandasm::Create_NEWOBJAPPLY(imm0, v0));
            auto acc_dst = inst->GetDstReg();
            if (acc_dst != compiler::ACC_REG_ID) {
                DoSta(inst->GetDstReg(), enc->result_);
            }
            break;
        }
       case compiler::RuntimeInterface::IntrinsicId::NEWOBJAPPLY_IMM16_V8:
       {
            std::cout << "compiler::RuntimeInterface::IntrinsicId::NEWOBJAPPLY_IMM16_V8 " << std::endl;
            auto acc_src = inst->GetSrcReg(inst->GetInputsCount() - 2);
            if (acc_src != compiler::ACC_REG_ID) {
                DoLda(acc_src, enc->result_);
            }
           ASSERT(inst->HasImms() && inst->GetImms().size() > 0); // NOLINTNEXTLINE(readability-container-size-empty)
            auto imm0 = static_cast<uint32_t>(inst->GetImms()[0]);
            auto v0 = inst->GetSrcReg(0);
            enc->result_.emplace_back(pandasm::Create_NEWOBJAPPLY(imm0, v0));
            auto acc_dst = inst->GetDstReg();
            if (acc_dst != compiler::ACC_REG_ID) {
                DoSta(inst->GetDstReg(), enc->result_);
            }
            break;
        }

       case compiler::RuntimeInterface::IntrinsicId::CREATEASYNCGENERATOROBJ_V8:
       {
            auto v0 = inst->GetSrcReg(0);
            enc->result_.emplace_back(pandasm::Create_CREATEASYNCGENERATOROBJ(v0));
            auto acc_dst = inst->GetDstReg();
            if (acc_dst != compiler::ACC_REG_ID) {
                DoSta(inst->GetDstReg(), enc->result_);
            }
            break;
        }
       case compiler::RuntimeInterface::IntrinsicId::ASYNCGENERATORRESOLVE_V8_V8_V8:
       {
            auto v0 = inst->GetSrcReg(0);
            auto v1 = inst->GetSrcReg(1);
            auto v2 = inst->GetSrcReg(2);
            enc->result_.emplace_back(pandasm::Create_ASYNCGENERATORRESOLVE(v0, v1, v2));
            auto acc_dst = inst->GetDstReg();
            if (acc_dst != compiler::ACC_REG_ID) {
                DoSta(inst->GetDstReg(), enc->result_);
            }
            break;
        }
       case compiler::RuntimeInterface::IntrinsicId::SUPERCALLSPREAD_IMM8_V8:
       {
            auto acc_src = inst->GetSrcReg(inst->GetInputsCount() - 2);
            if (acc_src != compiler::ACC_REG_ID) {
                DoLda(acc_src, enc->result_);
            }
           ASSERT(inst->HasImms() && inst->GetImms().size() > 0); // NOLINTNEXTLINE(readability-container-size-empty)
            auto imm0 = static_cast<uint32_t>(inst->GetImms()[0]);
            auto v0 = inst->GetSrcReg(0);
            enc->result_.emplace_back(pandasm::Create_SUPERCALLSPREAD(imm0, v0));
            auto acc_dst = inst->GetDstReg();
            if (acc_dst != compiler::ACC_REG_ID) {
                DoSta(inst->GetDstReg(), enc->result_);
            }
            break;
        }

       case compiler::RuntimeInterface::IntrinsicId::SUPERCALLARROWRANGE_IMM8_IMM8_V8:
       {
            auto acc_src = inst->GetSrcReg(inst->GetInputsCount() - 2);
            if (acc_src != compiler::ACC_REG_ID) {
                DoLda(acc_src, enc->result_);
            }
           ASSERT(inst->HasImms() && inst->GetImms().size() > 0); // NOLINTNEXTLINE(readability-container-size-empty)
            auto imm0 = static_cast<uint32_t>(inst->GetImms()[0]);
           ASSERT(inst->HasImms() && inst->GetImms().size() > 1); // NOLINTNEXTLINE(readability-container-size-empty)
            auto imm1 = static_cast<uint32_t>(inst->GetImms()[1]);
            auto v0 = inst->GetSrcReg(0);
            enc->result_.emplace_back(pandasm::Create_SUPERCALLARROWRANGE(imm0, imm1, v0));
            auto acc_dst = inst->GetDstReg();
            if (acc_dst != compiler::ACC_REG_ID) {
                DoSta(inst->GetDstReg(), enc->result_);
            }
            break;
        }
       case compiler::RuntimeInterface::IntrinsicId::DEFINEGETTERSETTERBYVALUE_V8_V8_V8_V8:
       {
            auto acc_src = inst->GetSrcReg(inst->GetInputsCount() - 2);
            if (acc_src != compiler::ACC_REG_ID) {
                DoLda(acc_src, enc->result_);
            }
            auto v0 = inst->GetSrcReg(0);
            auto v1 = inst->GetSrcReg(1);
            auto v2 = inst->GetSrcReg(2);
            auto v3 = inst->GetSrcReg(3);
            enc->result_.emplace_back(pandasm::Create_DEFINEGETTERSETTERBYVALUE(v0, v1, v2, v3));
            auto acc_dst = inst->GetDstReg();
            if (acc_dst != compiler::ACC_REG_ID) {
                DoSta(inst->GetDstReg(), enc->result_);
            }
            break;
        }
       case compiler::RuntimeInterface::IntrinsicId::DYNAMICIMPORT:
       {
            auto acc_src = inst->GetSrcReg(inst->GetInputsCount() - 2);
            if (acc_src != compiler::ACC_REG_ID) {
                DoLda(acc_src, enc->result_);
            }
            enc->result_.emplace_back(pandasm::Create_DYNAMICIMPORT());
            auto acc_dst = inst->GetDstReg();
            if (acc_dst != compiler::ACC_REG_ID) {
                DoSta(inst->GetDstReg(), enc->result_);
            }
            break;
        }
       case compiler::RuntimeInterface::IntrinsicId::DEFINEMETHOD_IMM16_ID16_IMM8:
       {
            auto acc_src = inst->GetSrcReg(inst->GetInputsCount() - 2);
            if (acc_src != compiler::ACC_REG_ID) {
                DoLda(acc_src, enc->result_);
            }
           ASSERT(inst->HasImms() && inst->GetImms().size() > 0); // NOLINTNEXTLINE(readability-container-size-empty)
            auto imm0 = static_cast<uint32_t>(inst->GetImms()[0]);
            ASSERT(inst->HasImms() && inst->GetImms().size() > 1); // NOLINTNEXTLINE(readability-container-size-empty)
            auto ir_id0 = static_cast<uint32_t>(inst->GetImms()[1]);
            auto bc_id0 = enc->ir_interface_->GetMethodIdByOffset(ir_id0);
           ASSERT(inst->HasImms() && inst->GetImms().size() > 2); // NOLINTNEXTLINE(readability-container-size-empty)
            auto imm2 = static_cast<uint32_t>(inst->GetImms()[2]);
            enc->result_.emplace_back(pandasm::Create_DEFINEMETHOD(imm0, bc_id0, imm2));
            auto acc_dst = inst->GetDstReg();
            if (acc_dst != compiler::ACC_REG_ID) {
                DoSta(inst->GetDstReg(), enc->result_);
            }
            break;
        }
       case compiler::RuntimeInterface::IntrinsicId::RESUMEGENERATOR:
       {
            auto acc_src = inst->GetSrcReg(inst->GetInputsCount() - 2);
            if (acc_src != compiler::ACC_REG_ID) {
                DoLda(acc_src, enc->result_);
            }
            enc->result_.emplace_back(pandasm::Create_RESUMEGENERATOR());
            auto acc_dst = inst->GetDstReg();
            if (acc_dst != compiler::ACC_REG_ID) {
                DoSta(inst->GetDstReg(), enc->result_);
            }
            break;
        }
       case compiler::RuntimeInterface::IntrinsicId::GETRESUMEMODE:
       {
            auto acc_src = inst->GetSrcReg(inst->GetInputsCount() - 2);
            if (acc_src != compiler::ACC_REG_ID) {
                DoLda(acc_src, enc->result_);
            }
            enc->result_.emplace_back(pandasm::Create_GETRESUMEMODE());
            auto acc_dst = inst->GetDstReg();
            if (acc_dst != compiler::ACC_REG_ID) {
                DoSta(inst->GetDstReg(), enc->result_);
            }
            break;
        }
       case compiler::RuntimeInterface::IntrinsicId::GETTEMPLATEOBJECT_IMM16:
       {
            auto acc_src = inst->GetSrcReg(inst->GetInputsCount() - 2);
            if (acc_src != compiler::ACC_REG_ID) {
                DoLda(acc_src, enc->result_);
            }
           ASSERT(inst->HasImms() && inst->GetImms().size() > 0); // NOLINTNEXTLINE(readability-container-size-empty)
            auto imm0 = static_cast<uint32_t>(inst->GetImms()[0]);
            enc->result_.emplace_back(pandasm::Create_GETTEMPLATEOBJECT(imm0));
            auto acc_dst = inst->GetDstReg();
            if (acc_dst != compiler::ACC_REG_ID) {
                DoSta(inst->GetDstReg(), enc->result_);
            }
            break;
        }

       case compiler::RuntimeInterface::IntrinsicId::SUSPENDGENERATOR_V8:
       {
            auto acc_src = inst->GetSrcReg(inst->GetInputsCount() - 2);
            if (acc_src != compiler::ACC_REG_ID) {
                DoLda(acc_src, enc->result_);
            }
            auto v0 = inst->GetSrcReg(0);
            enc->result_.emplace_back(pandasm::Create_SUSPENDGENERATOR(v0));
            auto acc_dst = inst->GetDstReg();
            if (acc_dst != compiler::ACC_REG_ID) {
                DoSta(inst->GetDstReg(), enc->result_);
            }
            break;
        }
       case compiler::RuntimeInterface::IntrinsicId::ASYNCFUNCTIONAWAITUNCAUGHT_V8:
       {
            auto acc_src = inst->GetSrcReg(inst->GetInputsCount() - 2);
            if (acc_src != compiler::ACC_REG_ID) {
                DoLda(acc_src, enc->result_);
            }
            auto v0 = inst->GetSrcReg(0);
            enc->result_.emplace_back(pandasm::Create_ASYNCFUNCTIONAWAITUNCAUGHT(v0));
            auto acc_dst = inst->GetDstReg();
            if (acc_dst != compiler::ACC_REG_ID) {
                DoSta(inst->GetDstReg(), enc->result_);
            }
            break;
        }

       case compiler::RuntimeInterface::IntrinsicId::SETOBJECTWITHPROTO_IMM16_V8:
       {
            auto acc_src = inst->GetSrcReg(inst->GetInputsCount() - 2);
            if (acc_src != compiler::ACC_REG_ID) {
                DoLda(acc_src, enc->result_);
            }
           ASSERT(inst->HasImms() && inst->GetImms().size() > 0); // NOLINTNEXTLINE(readability-container-size-empty)
            auto imm0 = static_cast<uint32_t>(inst->GetImms()[0]);
            auto v0 = inst->GetSrcReg(0);
            enc->result_.emplace_back(pandasm::Create_SETOBJECTWITHPROTO(imm0, v0));
            break;
        }

       case compiler::RuntimeInterface::IntrinsicId::STSUPERBYVALUE_IMM8_V8_V8:
       {
            auto acc_src = inst->GetSrcReg(inst->GetInputsCount() - 2);
            if (acc_src != compiler::ACC_REG_ID) {
                DoLda(acc_src, enc->result_);
            }
           ASSERT(inst->HasImms() && inst->GetImms().size() > 0); // NOLINTNEXTLINE(readability-container-size-empty)
            auto imm0 = static_cast<uint32_t>(inst->GetImms()[0]);
            auto v0 = inst->GetSrcReg(0);
            auto v1 = inst->GetSrcReg(1);
            enc->result_.emplace_back(pandasm::Create_STSUPERBYVALUE(imm0, v0, v1));
            break;
        }
       case compiler::RuntimeInterface::IntrinsicId::STSUPERBYVALUE_IMM16_V8_V8:
       {
            auto acc_src = inst->GetSrcReg(inst->GetInputsCount() - 2);
            if (acc_src != compiler::ACC_REG_ID) {
                DoLda(acc_src, enc->result_);
            }
           ASSERT(inst->HasImms() && inst->GetImms().size() > 0); // NOLINTNEXTLINE(readability-container-size-empty)
            auto imm0 = static_cast<uint32_t>(inst->GetImms()[0]);
            auto v0 = inst->GetSrcReg(0);
            auto v1 = inst->GetSrcReg(1);
            enc->result_.emplace_back(pandasm::Create_STSUPERBYVALUE(imm0, v0, v1));
            break;
        }

       case compiler::RuntimeInterface::IntrinsicId::ASYNCFUNCTIONRESOLVE_V8:
       {
            auto acc_src = inst->GetSrcReg(inst->GetInputsCount() - 2);
            if (acc_src != compiler::ACC_REG_ID) {
                DoLda(acc_src, enc->result_);
            }
            auto v0 = inst->GetSrcReg(0);
            enc->result_.emplace_back(pandasm::Create_ASYNCFUNCTIONRESOLVE(v0));
            auto acc_dst = inst->GetDstReg();
            if (acc_dst != compiler::ACC_REG_ID) {
                DoSta(inst->GetDstReg(), enc->result_);
            }
            break;
        }
       case compiler::RuntimeInterface::IntrinsicId::ASYNCFUNCTIONREJECT_V8:
       {
            auto acc_src = inst->GetSrcReg(inst->GetInputsCount() - 2);
            if (acc_src != compiler::ACC_REG_ID) {
                DoLda(acc_src, enc->result_);
            }
            auto v0 = inst->GetSrcReg(0);
            enc->result_.emplace_back(pandasm::Create_ASYNCFUNCTIONREJECT(v0));
            auto acc_dst = inst->GetDstReg();
            if (acc_dst != compiler::ACC_REG_ID) {
                DoSta(inst->GetDstReg(), enc->result_);
            }
            break;
        }
       case compiler::RuntimeInterface::IntrinsicId::COPYRESTARGS_IMM8:
       {
           ASSERT(inst->HasImms() && inst->GetImms().size() > 0); // NOLINTNEXTLINE(readability-container-size-empty)
            auto imm0 = static_cast<uint32_t>(inst->GetImms()[0]);
            enc->result_.emplace_back(pandasm::Create_COPYRESTARGS(imm0));
            auto acc_dst = inst->GetDstReg();
            if (acc_dst != compiler::ACC_REG_ID) {
                DoSta(inst->GetDstReg(), enc->result_);
            }
            break;
        }
       case compiler::RuntimeInterface::IntrinsicId::STSUPERBYNAME_IMM8_ID16_V8:
       {
            auto acc_src = inst->GetSrcReg(inst->GetInputsCount() - 2);
            if (acc_src != compiler::ACC_REG_ID) {
                DoLda(acc_src, enc->result_);
            }
           ASSERT(inst->HasImms() && inst->GetImms().size() > 0); // NOLINTNEXTLINE(readability-container-size-empty)
            auto imm0 = static_cast<uint32_t>(inst->GetImms()[0]);
            ASSERT(inst->HasImms() && inst->GetImms().size() > 1); // NOLINTNEXTLINE(readability-container-size-empty)
            auto ir_id0 = static_cast<uint32_t>(inst->GetImms()[1]);
            auto bc_id0 = enc->ir_interface_->GetStringIdByOffset(ir_id0);
            auto v0 = inst->GetSrcReg(0);
            enc->result_.emplace_back(pandasm::Create_STSUPERBYNAME(imm0, bc_id0, v0));
            break;
        }
       case compiler::RuntimeInterface::IntrinsicId::STSUPERBYNAME_IMM16_ID16_V8:
       {
            auto acc_src = inst->GetSrcReg(inst->GetInputsCount() - 2);
            if (acc_src != compiler::ACC_REG_ID) {
                DoLda(acc_src, enc->result_);
            }
           ASSERT(inst->HasImms() && inst->GetImms().size() > 0); // NOLINTNEXTLINE(readability-container-size-empty)
            auto imm0 = static_cast<uint32_t>(inst->GetImms()[0]);
            ASSERT(inst->HasImms() && inst->GetImms().size() > 1); // NOLINTNEXTLINE(readability-container-size-empty)
            auto ir_id0 = static_cast<uint32_t>(inst->GetImms()[1]);
            auto bc_id0 = enc->ir_interface_->GetStringIdByOffset(ir_id0);
            auto v0 = inst->GetSrcReg(0);
            enc->result_.emplace_back(pandasm::Create_STSUPERBYNAME(imm0, bc_id0, v0));
            break;
        }

       case compiler::RuntimeInterface::IntrinsicId::SETGENERATORSTATE_IMM8:
       {
            auto acc_src = inst->GetSrcReg(inst->GetInputsCount() - 2);
            if (acc_src != compiler::ACC_REG_ID) {
                DoLda(acc_src, enc->result_);
            }
           ASSERT(inst->HasImms() && inst->GetImms().size() > 0); // NOLINTNEXTLINE(readability-container-size-empty)
            auto imm0 = static_cast<uint32_t>(inst->GetImms()[0]);
            enc->result_.emplace_back(pandasm::Create_SETGENERATORSTATE(imm0));
            break;
        }
       case compiler::RuntimeInterface::IntrinsicId::GETASYNCITERATOR_IMM8:
       {
            auto acc_src = inst->GetSrcReg(inst->GetInputsCount() - 2);
            if (acc_src != compiler::ACC_REG_ID) {
                DoLda(acc_src, enc->result_);
            }
           ASSERT(inst->HasImms() && inst->GetImms().size() > 0); // NOLINTNEXTLINE(readability-container-size-empty)
            auto imm0 = static_cast<uint32_t>(inst->GetImms()[0]);
            enc->result_.emplace_back(pandasm::Create_GETASYNCITERATOR(imm0));
            auto acc_dst = inst->GetDstReg();
            if (acc_dst != compiler::ACC_REG_ID) {
                DoSta(inst->GetDstReg(), enc->result_);
            }
            break;
        }
       case compiler::RuntimeInterface::IntrinsicId::LDPRIVATEPROPERTY_IMM8_IMM16_IMM16:
       {
            auto acc_src = inst->GetSrcReg(inst->GetInputsCount() - 2);
            if (acc_src != compiler::ACC_REG_ID) {
                DoLda(acc_src, enc->result_);
            }
           ASSERT(inst->HasImms() && inst->GetImms().size() > 0); // NOLINTNEXTLINE(readability-container-size-empty)
            auto imm0 = static_cast<uint32_t>(inst->GetImms()[0]);
           ASSERT(inst->HasImms() && inst->GetImms().size() > 1); // NOLINTNEXTLINE(readability-container-size-empty)
            auto imm1 = static_cast<uint32_t>(inst->GetImms()[1]);
           ASSERT(inst->HasImms() && inst->GetImms().size() > 2); // NOLINTNEXTLINE(readability-container-size-empty)
            auto imm2 = static_cast<uint32_t>(inst->GetImms()[2]);
            enc->result_.emplace_back(pandasm::Create_LDPRIVATEPROPERTY(imm0, imm1, imm2));
            auto acc_dst = inst->GetDstReg();
            if (acc_dst != compiler::ACC_REG_ID) {
                DoSta(inst->GetDstReg(), enc->result_);
            }
            break;
        }
       case compiler::RuntimeInterface::IntrinsicId::STPRIVATEPROPERTY_IMM8_IMM16_IMM16_V8:
       {
            auto acc_src = inst->GetSrcReg(inst->GetInputsCount() - 2);
            if (acc_src != compiler::ACC_REG_ID) {
                DoLda(acc_src, enc->result_);
            }
           ASSERT(inst->HasImms() && inst->GetImms().size() > 0); // NOLINTNEXTLINE(readability-container-size-empty)
            auto imm0 = static_cast<uint32_t>(inst->GetImms()[0]);
           ASSERT(inst->HasImms() && inst->GetImms().size() > 1); // NOLINTNEXTLINE(readability-container-size-empty)
            auto imm1 = static_cast<uint32_t>(inst->GetImms()[1]);
           ASSERT(inst->HasImms() && inst->GetImms().size() > 2); // NOLINTNEXTLINE(readability-container-size-empty)
            auto imm2 = static_cast<uint32_t>(inst->GetImms()[2]);
            auto v0 = inst->GetSrcReg(0);
            enc->result_.emplace_back(pandasm::Create_STPRIVATEPROPERTY(imm0, imm1, imm2, v0));
            break;
        }
       case compiler::RuntimeInterface::IntrinsicId::TESTIN_IMM8_IMM16_IMM16:
       {
            auto acc_src = inst->GetSrcReg(inst->GetInputsCount() - 2);
            if (acc_src != compiler::ACC_REG_ID) {
                DoLda(acc_src, enc->result_);
            }
           ASSERT(inst->HasImms() && inst->GetImms().size() > 0); // NOLINTNEXTLINE(readability-container-size-empty)
            auto imm0 = static_cast<uint32_t>(inst->GetImms()[0]);
           ASSERT(inst->HasImms() && inst->GetImms().size() > 1); // NOLINTNEXTLINE(readability-container-size-empty)
            auto imm1 = static_cast<uint32_t>(inst->GetImms()[1]);
           ASSERT(inst->HasImms() && inst->GetImms().size() > 2); // NOLINTNEXTLINE(readability-container-size-empty)
            auto imm2 = static_cast<uint32_t>(inst->GetImms()[2]);
            enc->result_.emplace_back(pandasm::Create_TESTIN(imm0, imm1, imm2));
            auto acc_dst = inst->GetDstReg();
            if (acc_dst != compiler::ACC_REG_ID) {
                DoSta(inst->GetDstReg(), enc->result_);
            }
            break;
        }
       case compiler::RuntimeInterface::IntrinsicId::DEFINEFIELDBYNAME_IMM8_ID16_V8:
       {
            auto acc_src = inst->GetSrcReg(inst->GetInputsCount() - 2);
            if (acc_src != compiler::ACC_REG_ID) {
                DoLda(acc_src, enc->result_);
            }
           ASSERT(inst->HasImms() && inst->GetImms().size() > 0); // NOLINTNEXTLINE(readability-container-size-empty)
            auto imm0 = static_cast<uint32_t>(inst->GetImms()[0]);
            ASSERT(inst->HasImms() && inst->GetImms().size() > 1); // NOLINTNEXTLINE(readability-container-size-empty)
            auto ir_id0 = static_cast<uint32_t>(inst->GetImms()[1]);
            auto bc_id0 = enc->ir_interface_->GetStringIdByOffset(ir_id0);
            auto v0 = inst->GetSrcReg(0);
            enc->result_.emplace_back(pandasm::Create_DEFINEFIELDBYNAME(imm0, bc_id0, v0));
            break;
        }
       case compiler::RuntimeInterface::IntrinsicId::DEFINEPROPERTYBYNAME_IMM8_ID16_V8:
       {
            auto acc_src = inst->GetSrcReg(inst->GetInputsCount() - 2);
            if (acc_src != compiler::ACC_REG_ID) {
                DoLda(acc_src, enc->result_);
            }
           ASSERT(inst->HasImms() && inst->GetImms().size() > 0); // NOLINTNEXTLINE(readability-container-size-empty)
            auto imm0 = static_cast<uint32_t>(inst->GetImms()[0]);
            ASSERT(inst->HasImms() && inst->GetImms().size() > 1); // NOLINTNEXTLINE(readability-container-size-empty)
            auto ir_id0 = static_cast<uint32_t>(inst->GetImms()[1]);
            auto bc_id0 = enc->ir_interface_->GetStringIdByOffset(ir_id0);
            auto v0 = inst->GetSrcReg(0);
            enc->result_.emplace_back(pandasm::Create_DEFINEPROPERTYBYNAME(imm0, bc_id0, v0));
            break;
        }
       case compiler::RuntimeInterface::IntrinsicId::CALLRUNTIME_NOTIFYCONCURRENTRESULT_PREF_NONE:
       {
            auto acc_src = inst->GetSrcReg(inst->GetInputsCount() - 2);
            if (acc_src != compiler::ACC_REG_ID) {
                DoLda(acc_src, enc->result_);
            }
            enc->result_.emplace_back(pandasm::Create_CALLRUNTIME_NOTIFYCONCURRENTRESULT());
            break;
        }

       case compiler::RuntimeInterface::IntrinsicId::WIDE_CREATEOBJECTWITHEXCLUDEDKEYS_PREF_IMM16_V8_V8:
       {
           ASSERT(inst->HasImms() && inst->GetImms().size() > 0); // NOLINTNEXTLINE(readability-container-size-empty)
            auto imm0 = static_cast<uint32_t>(inst->GetImms()[0]);
            auto v0 = inst->GetSrcReg(0);
            auto v1 = inst->GetSrcReg(1);
            enc->result_.emplace_back(pandasm::Create_WIDE_CREATEOBJECTWITHEXCLUDEDKEYS(imm0, v0, v1));
            auto acc_dst = inst->GetDstReg();
            if (acc_dst != compiler::ACC_REG_ID) {
                DoSta(inst->GetDstReg(), enc->result_);
            }
            break;
        }

       case compiler::RuntimeInterface::IntrinsicId::CALLRUNTIME_DEFINEFIELDBYVALUE_PREF_IMM8_V8_V8:
       {
            auto acc_src = inst->GetSrcReg(inst->GetInputsCount() - 2);
            if (acc_src != compiler::ACC_REG_ID) {
                DoLda(acc_src, enc->result_);
            }
           ASSERT(inst->HasImms() && inst->GetImms().size() > 0); // NOLINTNEXTLINE(readability-container-size-empty)
            auto imm0 = static_cast<uint32_t>(inst->GetImms()[0]);
            auto v0 = inst->GetSrcReg(0);
            auto v1 = inst->GetSrcReg(1);
            enc->result_.emplace_back(pandasm::Create_CALLRUNTIME_DEFINEFIELDBYVALUE(imm0, v0, v1));
            break;
        }


       case compiler::RuntimeInterface::IntrinsicId::THROW_NOTEXISTS_PREF_NONE:
       {
            enc->result_.emplace_back(pandasm::Create_THROW_NOTEXISTS());
            break;
        }
       case compiler::RuntimeInterface::IntrinsicId::CALLRUNTIME_DEFINEFIELDBYINDEX_PREF_IMM8_IMM32_V8:
       {
            auto acc_src = inst->GetSrcReg(inst->GetInputsCount() - 2);
            if (acc_src != compiler::ACC_REG_ID) {
                DoLda(acc_src, enc->result_);
            }
           ASSERT(inst->HasImms() && inst->GetImms().size() > 0); // NOLINTNEXTLINE(readability-container-size-empty)
            auto imm0 = static_cast<uint32_t>(inst->GetImms()[0]);
           ASSERT(inst->HasImms() && inst->GetImms().size() > 1); // NOLINTNEXTLINE(readability-container-size-empty)
            auto imm1 = static_cast<uint32_t>(inst->GetImms()[1]);
            auto v0 = inst->GetSrcReg(0);
            enc->result_.emplace_back(pandasm::Create_CALLRUNTIME_DEFINEFIELDBYINDEX(imm0, imm1, v0));
            break;
        }


       case compiler::RuntimeInterface::IntrinsicId::THROW_PATTERNNONCOERCIBLE_PREF_NONE:
       {
            enc->result_.emplace_back(pandasm::Create_THROW_PATTERNNONCOERCIBLE());
            break;
        }
       case compiler::RuntimeInterface::IntrinsicId::CALLRUNTIME_TOPROPERTYKEY_PREF_NONE:
       {
            auto acc_src = inst->GetSrcReg(inst->GetInputsCount() - 2);
            if (acc_src != compiler::ACC_REG_ID) {
                DoLda(acc_src, enc->result_);
            }
            enc->result_.emplace_back(pandasm::Create_CALLRUNTIME_TOPROPERTYKEY());
            auto acc_dst = inst->GetDstReg();
            if (acc_dst != compiler::ACC_REG_ID) {
                DoSta(inst->GetDstReg(), enc->result_);
            }
            break;
        }


       case compiler::RuntimeInterface::IntrinsicId::THROW_DELETESUPERPROPERTY_PREF_NONE:
       {
            enc->result_.emplace_back(pandasm::Create_THROW_DELETESUPERPROPERTY());
            break;
        }
       case compiler::RuntimeInterface::IntrinsicId::CALLRUNTIME_CREATEPRIVATEPROPERTY_PREF_IMM16_ID16:
       {
           ASSERT(inst->HasImms() && inst->GetImms().size() > 0); // NOLINTNEXTLINE(readability-container-size-empty)
            auto imm0 = static_cast<uint32_t>(inst->GetImms()[0]);
            ASSERT(inst->HasImms() && inst->GetImms().size() > 1); // NOLINTNEXTLINE(readability-container-size-empty)
            auto ir_id0 = static_cast<uint32_t>(inst->GetImms()[1]);
            auto bc_id0 = enc->ir_interface_->GetLiteralArrayByOffset(ir_id0);
            enc->result_.emplace_back(pandasm::Create_CALLRUNTIME_CREATEPRIVATEPROPERTY(imm0, bc_id0));
            break;
        }


       case compiler::RuntimeInterface::IntrinsicId::THROW_CONSTASSIGNMENT_PREF_V8:
       {
            auto v0 = inst->GetSrcReg(0);
            enc->result_.emplace_back(pandasm::Create_THROW_CONSTASSIGNMENT(v0));
            break;
        }
       case compiler::RuntimeInterface::IntrinsicId::CALLRUNTIME_DEFINEPRIVATEPROPERTY_PREF_IMM8_IMM16_IMM16_V8:
       {
            auto acc_src = inst->GetSrcReg(inst->GetInputsCount() - 2);
            if (acc_src != compiler::ACC_REG_ID) {
                DoLda(acc_src, enc->result_);
            }
           ASSERT(inst->HasImms() && inst->GetImms().size() > 0); // NOLINTNEXTLINE(readability-container-size-empty)
            auto imm0 = static_cast<uint32_t>(inst->GetImms()[0]);
           ASSERT(inst->HasImms() && inst->GetImms().size() > 1); // NOLINTNEXTLINE(readability-container-size-empty)
            auto imm1 = static_cast<uint32_t>(inst->GetImms()[1]);
           ASSERT(inst->HasImms() && inst->GetImms().size() > 2); // NOLINTNEXTLINE(readability-container-size-empty)
            auto imm2 = static_cast<uint32_t>(inst->GetImms()[2]);
            auto v0 = inst->GetSrcReg(0);
            enc->result_.emplace_back(pandasm::Create_CALLRUNTIME_DEFINEPRIVATEPROPERTY(imm0, imm1, imm2, v0));
            break;
        }


       case compiler::RuntimeInterface::IntrinsicId::THROW_IFNOTOBJECT_PREF_V8:
       {
            auto v0 = inst->GetSrcReg(0);
            enc->result_.emplace_back(pandasm::Create_THROW_IFNOTOBJECT(v0));
            break;
        }
       case compiler::RuntimeInterface::IntrinsicId::CALLRUNTIME_CALLINIT_PREF_IMM8_V8:
       {
            auto acc_src = inst->GetSrcReg(inst->GetInputsCount() - 2);
            if (acc_src != compiler::ACC_REG_ID) {
                DoLda(acc_src, enc->result_);
            }
           ASSERT(inst->HasImms() && inst->GetImms().size() > 0); // NOLINTNEXTLINE(readability-container-size-empty)
            auto imm0 = static_cast<uint32_t>(inst->GetImms()[0]);
            auto v0 = inst->GetSrcReg(0);
            enc->result_.emplace_back(pandasm::Create_CALLRUNTIME_CALLINIT(imm0, v0));
            break;
        }


       case compiler::RuntimeInterface::IntrinsicId::THROW_UNDEFINEDIFHOLE_PREF_V8_V8:
       {
            auto v0 = inst->GetSrcReg(0);
            auto v1 = inst->GetSrcReg(1);
            enc->result_.emplace_back(pandasm::Create_THROW_UNDEFINEDIFHOLE(v0, v1));
            break;
        }
       case compiler::RuntimeInterface::IntrinsicId::CALLRUNTIME_DEFINESENDABLECLASS_PREF_IMM16_ID16_ID16_IMM16_V8:
       {
           ASSERT(inst->HasImms() && inst->GetImms().size() > 0); // NOLINTNEXTLINE(readability-container-size-empty)
            auto imm0 = static_cast<uint32_t>(inst->GetImms()[0]);
            ASSERT(inst->HasImms() && inst->GetImms().size() > 1); // NOLINTNEXTLINE(readability-container-size-empty)
            auto ir_id0 = static_cast<uint32_t>(inst->GetImms()[1]);
            auto bc_id0 = enc->ir_interface_->GetMethodIdByOffset(ir_id0);
            ASSERT(inst->HasImms() && inst->GetImms().size() > 2); // NOLINTNEXTLINE(readability-container-size-empty)
            auto ir_id1 = static_cast<uint32_t>(inst->GetImms()[2]);
            auto bc_id1 = enc->ir_interface_->GetLiteralArrayByOffset(ir_id1);
           ASSERT(inst->HasImms() && inst->GetImms().size() > 3); // NOLINTNEXTLINE(readability-container-size-empty)
            auto imm3 = static_cast<uint32_t>(inst->GetImms()[3]);
            auto v0 = inst->GetSrcReg(0);
            enc->result_.emplace_back(pandasm::Create_CALLRUNTIME_DEFINESENDABLECLASS(imm0, bc_id0, bc_id1, imm3, v0));
            auto acc_dst = inst->GetDstReg();
            if (acc_dst != compiler::ACC_REG_ID) {
                DoSta(inst->GetDstReg(), enc->result_);
            }
            break;
        }

       case compiler::RuntimeInterface::IntrinsicId::WIDE_SUPERCALLARROWRANGE_PREF_IMM16_V8:
       {
            auto acc_src = inst->GetSrcReg(inst->GetInputsCount() - 2);
            if (acc_src != compiler::ACC_REG_ID) {
                DoLda(acc_src, enc->result_);
            }
           ASSERT(inst->HasImms() && inst->GetImms().size() > 0); // NOLINTNEXTLINE(readability-container-size-empty)
            auto imm0 = static_cast<uint32_t>(inst->GetImms()[0]);
            auto v0 = inst->GetSrcReg(0);
            enc->result_.emplace_back(pandasm::Create_WIDE_SUPERCALLARROWRANGE(imm0, v0));
            auto acc_dst = inst->GetDstReg();
            if (acc_dst != compiler::ACC_REG_ID) {
                DoSta(inst->GetDstReg(), enc->result_);
            }
            break;
        }
       case compiler::RuntimeInterface::IntrinsicId::THROW_IFSUPERNOTCORRECTCALL_PREF_IMM8:
       {
            auto acc_src = inst->GetSrcReg(inst->GetInputsCount() - 2);
            if (acc_src != compiler::ACC_REG_ID) {
                DoLda(acc_src, enc->result_);
            }
           ASSERT(inst->HasImms() && inst->GetImms().size() > 0); // NOLINTNEXTLINE(readability-container-size-empty)
            auto imm0 = static_cast<uint32_t>(inst->GetImms()[0]);
            enc->result_.emplace_back(pandasm::Create_THROW_IFSUPERNOTCORRECTCALL(imm0));
            break;
        }
       case compiler::RuntimeInterface::IntrinsicId::CALLRUNTIME_LDSENDABLECLASS_PREF_IMM16:
       {
           ASSERT(inst->HasImms() && inst->GetImms().size() > 0); // NOLINTNEXTLINE(readability-container-size-empty)
            auto imm0 = static_cast<uint32_t>(inst->GetImms()[0]);
            enc->result_.emplace_back(pandasm::Create_CALLRUNTIME_LDSENDABLECLASS(imm0));
            auto acc_dst = inst->GetDstReg();
            if (acc_dst != compiler::ACC_REG_ID) {
                DoSta(inst->GetDstReg(), enc->result_);
            }
            break;
        }


       case compiler::RuntimeInterface::IntrinsicId::THROW_IFSUPERNOTCORRECTCALL_PREF_IMM16:
       {
            auto acc_src = inst->GetSrcReg(inst->GetInputsCount() - 2);
            if (acc_src != compiler::ACC_REG_ID) {
                DoLda(acc_src, enc->result_);
            }
           ASSERT(inst->HasImms() && inst->GetImms().size() > 0); // NOLINTNEXTLINE(readability-container-size-empty)
            auto imm0 = static_cast<uint32_t>(inst->GetImms()[0]);
            enc->result_.emplace_back(pandasm::Create_THROW_IFSUPERNOTCORRECTCALL(imm0));
            break;
        }
       case compiler::RuntimeInterface::IntrinsicId::CALLRUNTIME_LDSENDABLEEXTERNALMODULEVAR_PREF_IMM8:
       {
           ASSERT(inst->HasImms() && inst->GetImms().size() > 0); // NOLINTNEXTLINE(readability-container-size-empty)
            auto imm0 = static_cast<uint32_t>(inst->GetImms()[0]);
            enc->result_.emplace_back(pandasm::Create_CALLRUNTIME_LDSENDABLEEXTERNALMODULEVAR(imm0));
            auto acc_dst = inst->GetDstReg();
            if (acc_dst != compiler::ACC_REG_ID) {
                DoSta(inst->GetDstReg(), enc->result_);
            }
            break;
        }


       case compiler::RuntimeInterface::IntrinsicId::THROW_UNDEFINEDIFHOLEWITHNAME_PREF_ID16:
       {
            auto acc_src = inst->GetSrcReg(inst->GetInputsCount() - 2);
            if (acc_src != compiler::ACC_REG_ID) {
                DoLda(acc_src, enc->result_);
            }
            ASSERT(inst->HasImms() && inst->GetImms().size() > 0); // NOLINTNEXTLINE(readability-container-size-empty)
            auto ir_id0 = static_cast<uint32_t>(inst->GetImms()[0]);
            auto bc_id0 = enc->ir_interface_->GetStringIdByOffset(ir_id0);
            enc->result_.emplace_back(pandasm::Create_THROW_UNDEFINEDIFHOLEWITHNAME(bc_id0));
            break;
        }
       case compiler::RuntimeInterface::IntrinsicId::CALLRUNTIME_WIDELDSENDABLEEXTERNALMODULEVAR_PREF_IMM16:
       {
           ASSERT(inst->HasImms() && inst->GetImms().size() > 0); // NOLINTNEXTLINE(readability-container-size-empty)
            auto imm0 = static_cast<uint32_t>(inst->GetImms()[0]);
            enc->result_.emplace_back(pandasm::Create_CALLRUNTIME_WIDELDSENDABLEEXTERNALMODULEVAR(imm0));
            auto acc_dst = inst->GetDstReg();
            if (acc_dst != compiler::ACC_REG_ID) {
                DoSta(inst->GetDstReg(), enc->result_);
            }
            break;
        }


       case compiler::RuntimeInterface::IntrinsicId::CALLRUNTIME_NEWSENDABLEENV_PREF_IMM8:
       {
           ASSERT(inst->HasImms() && inst->GetImms().size() > 0); // NOLINTNEXTLINE(readability-container-size-empty)
            auto imm0 = static_cast<uint32_t>(inst->GetImms()[0]);
            enc->result_.emplace_back(pandasm::Create_CALLRUNTIME_NEWSENDABLEENV(imm0));
            break;
        }

       case compiler::RuntimeInterface::IntrinsicId::WIDE_COPYRESTARGS_PREF_IMM16:
       {
           ASSERT(inst->HasImms() && inst->GetImms().size() > 0); // NOLINTNEXTLINE(readability-container-size-empty)
            auto imm0 = static_cast<uint32_t>(inst->GetImms()[0]);
            enc->result_.emplace_back(pandasm::Create_WIDE_COPYRESTARGS(imm0));
            auto acc_dst = inst->GetDstReg();
            if (acc_dst != compiler::ACC_REG_ID) {
                DoSta(inst->GetDstReg(), enc->result_);
            }
            break;
        }
       case compiler::RuntimeInterface::IntrinsicId::CALLRUNTIME_WIDENEWSENDABLEENV_PREF_IMM16:
       {
           ASSERT(inst->HasImms() && inst->GetImms().size() > 0); // NOLINTNEXTLINE(readability-container-size-empty)
            auto imm0 = static_cast<uint32_t>(inst->GetImms()[0]);
            enc->result_.emplace_back(pandasm::Create_CALLRUNTIME_WIDENEWSENDABLEENV(imm0));
            break;
        }


       case compiler::RuntimeInterface::IntrinsicId::CALLRUNTIME_STSENDABLEVAR_PREF_IMM4_IMM4:
       {
            auto acc_src = inst->GetSrcReg(inst->GetInputsCount() - 2);
            if (acc_src != compiler::ACC_REG_ID) {
                DoLda(acc_src, enc->result_);
            }
           ASSERT(inst->HasImms() && inst->GetImms().size() > 0); // NOLINTNEXTLINE(readability-container-size-empty)
            auto imm0 = static_cast<uint32_t>(inst->GetImms()[0]);
           ASSERT(inst->HasImms() && inst->GetImms().size() > 1); // NOLINTNEXTLINE(readability-container-size-empty)
            auto imm1 = static_cast<uint32_t>(inst->GetImms()[1]);
            enc->result_.emplace_back(pandasm::Create_CALLRUNTIME_STSENDABLEVAR(imm0, imm1));
            break;
        }


       case compiler::RuntimeInterface::IntrinsicId::CALLRUNTIME_STSENDABLEVAR_PREF_IMM8_IMM8:
       {
            auto acc_src = inst->GetSrcReg(inst->GetInputsCount() - 2);
            if (acc_src != compiler::ACC_REG_ID) {
                DoLda(acc_src, enc->result_);
            }
           ASSERT(inst->HasImms() && inst->GetImms().size() > 0); // NOLINTNEXTLINE(readability-container-size-empty)
            auto imm0 = static_cast<uint32_t>(inst->GetImms()[0]);
           ASSERT(inst->HasImms() && inst->GetImms().size() > 1); // NOLINTNEXTLINE(readability-container-size-empty)
            auto imm1 = static_cast<uint32_t>(inst->GetImms()[1]);
            enc->result_.emplace_back(pandasm::Create_CALLRUNTIME_STSENDABLEVAR(imm0, imm1));
            break;
        }

       case compiler::RuntimeInterface::IntrinsicId::WIDE_GETMODULENAMESPACE_PREF_IMM16:
       {
           ASSERT(inst->HasImms() && inst->GetImms().size() > 0); // NOLINTNEXTLINE(readability-container-size-empty)
            auto imm0 = static_cast<uint32_t>(inst->GetImms()[0]);
            enc->result_.emplace_back(pandasm::Create_WIDE_GETMODULENAMESPACE(imm0));
            auto acc_dst = inst->GetDstReg();
            if (acc_dst != compiler::ACC_REG_ID) {
                DoSta(inst->GetDstReg(), enc->result_);
            }
            break;
        }
       case compiler::RuntimeInterface::IntrinsicId::CALLRUNTIME_WIDESTSENDABLEVAR_PREF_IMM16_IMM16:
       {
            auto acc_src = inst->GetSrcReg(inst->GetInputsCount() - 2);
            if (acc_src != compiler::ACC_REG_ID) {
                DoLda(acc_src, enc->result_);
            }
           ASSERT(inst->HasImms() && inst->GetImms().size() > 0); // NOLINTNEXTLINE(readability-container-size-empty)
            auto imm0 = static_cast<uint32_t>(inst->GetImms()[0]);
           ASSERT(inst->HasImms() && inst->GetImms().size() > 1); // NOLINTNEXTLINE(readability-container-size-empty)
            auto imm1 = static_cast<uint32_t>(inst->GetImms()[1]);
            enc->result_.emplace_back(pandasm::Create_CALLRUNTIME_WIDESTSENDABLEVAR(imm0, imm1));
            break;
        }

       case compiler::RuntimeInterface::IntrinsicId::WIDE_STMODULEVAR_PREF_IMM16:
       {
            auto acc_src = inst->GetSrcReg(inst->GetInputsCount() - 2);
            if (acc_src != compiler::ACC_REG_ID) {
                DoLda(acc_src, enc->result_);
            }
           ASSERT(inst->HasImms() && inst->GetImms().size() > 0); // NOLINTNEXTLINE(readability-container-size-empty)
            auto imm0 = static_cast<uint32_t>(inst->GetImms()[0]);
            enc->result_.emplace_back(pandasm::Create_WIDE_STMODULEVAR(imm0));
            break;
        }
       case compiler::RuntimeInterface::IntrinsicId::CALLRUNTIME_LDSENDABLEVAR_PREF_IMM4_IMM4:
       {
           ASSERT(inst->HasImms() && inst->GetImms().size() > 0); // NOLINTNEXTLINE(readability-container-size-empty)
            auto imm0 = static_cast<uint32_t>(inst->GetImms()[0]);
           ASSERT(inst->HasImms() && inst->GetImms().size() > 1); // NOLINTNEXTLINE(readability-container-size-empty)
            auto imm1 = static_cast<uint32_t>(inst->GetImms()[1]);
            enc->result_.emplace_back(pandasm::Create_CALLRUNTIME_LDSENDABLEVAR(imm0, imm1));
            auto acc_dst = inst->GetDstReg();
            if (acc_dst != compiler::ACC_REG_ID) {
                DoSta(inst->GetDstReg(), enc->result_);
            }
            break;
        }

       case compiler::RuntimeInterface::IntrinsicId::WIDE_LDLOCALMODULEVAR_PREF_IMM16:
       {
           ASSERT(inst->HasImms() && inst->GetImms().size() > 0); // NOLINTNEXTLINE(readability-container-size-empty)
            auto imm0 = static_cast<uint32_t>(inst->GetImms()[0]);
            enc->result_.emplace_back(pandasm::Create_WIDE_LDLOCALMODULEVAR(imm0));
            auto acc_dst = inst->GetDstReg();
            if (acc_dst != compiler::ACC_REG_ID) {
                DoSta(inst->GetDstReg(), enc->result_);
            }
            break;
        }
       case compiler::RuntimeInterface::IntrinsicId::CALLRUNTIME_LDSENDABLEVAR_PREF_IMM8_IMM8:
       {
           ASSERT(inst->HasImms() && inst->GetImms().size() > 0); // NOLINTNEXTLINE(readability-container-size-empty)
            auto imm0 = static_cast<uint32_t>(inst->GetImms()[0]);
           ASSERT(inst->HasImms() && inst->GetImms().size() > 1); // NOLINTNEXTLINE(readability-container-size-empty)
            auto imm1 = static_cast<uint32_t>(inst->GetImms()[1]);
            enc->result_.emplace_back(pandasm::Create_CALLRUNTIME_LDSENDABLEVAR(imm0, imm1));
            auto acc_dst = inst->GetDstReg();
            if (acc_dst != compiler::ACC_REG_ID) {
                DoSta(inst->GetDstReg(), enc->result_);
            }
            break;
        }

       case compiler::RuntimeInterface::IntrinsicId::WIDE_LDEXTERNALMODULEVAR_PREF_IMM16:
       {
           ASSERT(inst->HasImms() && inst->GetImms().size() > 0); // NOLINTNEXTLINE(readability-container-size-empty)
            auto imm0 = static_cast<uint32_t>(inst->GetImms()[0]);
            enc->result_.emplace_back(pandasm::Create_WIDE_LDEXTERNALMODULEVAR(imm0));
            auto acc_dst = inst->GetDstReg();
            if (acc_dst != compiler::ACC_REG_ID) {
                DoSta(inst->GetDstReg(), enc->result_);
            }
            break;
        }
       case compiler::RuntimeInterface::IntrinsicId::CALLRUNTIME_WIDELDSENDABLEVAR_PREF_IMM16_IMM16:
       {
           ASSERT(inst->HasImms() && inst->GetImms().size() > 0); // NOLINTNEXTLINE(readability-container-size-empty)
            auto imm0 = static_cast<uint32_t>(inst->GetImms()[0]);
           ASSERT(inst->HasImms() && inst->GetImms().size() > 1); // NOLINTNEXTLINE(readability-container-size-empty)
            auto imm1 = static_cast<uint32_t>(inst->GetImms()[1]);
            enc->result_.emplace_back(pandasm::Create_CALLRUNTIME_WIDELDSENDABLEVAR(imm0, imm1));
            auto acc_dst = inst->GetDstReg();
            if (acc_dst != compiler::ACC_REG_ID) {
                DoSta(inst->GetDstReg(), enc->result_);
            }
            break;
        }

       case compiler::RuntimeInterface::IntrinsicId::WIDE_LDPATCHVAR_PREF_IMM16:
       {
           ASSERT(inst->HasImms() && inst->GetImms().size() > 0); // NOLINTNEXTLINE(readability-container-size-empty)
            auto imm0 = static_cast<uint32_t>(inst->GetImms()[0]);
            enc->result_.emplace_back(pandasm::Create_WIDE_LDPATCHVAR(imm0));
            auto acc_dst = inst->GetDstReg();
            if (acc_dst != compiler::ACC_REG_ID) {
                DoSta(inst->GetDstReg(), enc->result_);
            }
            break;
        }


       case compiler::RuntimeInterface::IntrinsicId::WIDE_STPATCHVAR_PREF_IMM16:
       {
            auto acc_src = inst->GetSrcReg(inst->GetInputsCount() - 2);
            if (acc_src != compiler::ACC_REG_ID) {
                DoLda(acc_src, enc->result_);
            }
           ASSERT(inst->HasImms() && inst->GetImms().size() > 0); // NOLINTNEXTLINE(readability-container-size-empty)
            auto imm0 = static_cast<uint32_t>(inst->GetImms()[0]);
            enc->result_.emplace_back(pandasm::Create_WIDE_STPATCHVAR(imm0));
            break;
        }

       case compiler::RuntimeInterface::IntrinsicId::CALLRUNTIME_LDLAZYMODULEVAR_PREF_IMM8:
       {
           ASSERT(inst->HasImms() && inst->GetImms().size() > 0); // NOLINTNEXTLINE(readability-container-size-empty)
            auto imm0 = static_cast<uint32_t>(inst->GetImms()[0]);
            enc->result_.emplace_back(pandasm::Create_CALLRUNTIME_LDLAZYMODULEVAR(imm0));
            auto acc_dst = inst->GetDstReg();
            if (acc_dst != compiler::ACC_REG_ID) {
                DoSta(inst->GetDstReg(), enc->result_);
            }
            break;
        }

       case compiler::RuntimeInterface::IntrinsicId::CALLRUNTIME_WIDELDLAZYMODULEVAR_PREF_IMM16:
       {
           ASSERT(inst->HasImms() && inst->GetImms().size() > 0); // NOLINTNEXTLINE(readability-container-size-empty)
            auto imm0 = static_cast<uint32_t>(inst->GetImms()[0]);
            enc->result_.emplace_back(pandasm::Create_CALLRUNTIME_WIDELDLAZYMODULEVAR(imm0));
            auto acc_dst = inst->GetDstReg();
            if (acc_dst != compiler::ACC_REG_ID) {
                DoSta(inst->GetDstReg(), enc->result_);
            }
            break;
        }

       case compiler::RuntimeInterface::IntrinsicId::CALLRUNTIME_LDLAZYSENDABLEMODULEVAR_PREF_IMM8:
       {
           ASSERT(inst->HasImms() && inst->GetImms().size() > 0); // NOLINTNEXTLINE(readability-container-size-empty)
            auto imm0 = static_cast<uint32_t>(inst->GetImms()[0]);
            enc->result_.emplace_back(pandasm::Create_CALLRUNTIME_LDLAZYSENDABLEMODULEVAR(imm0));
            auto acc_dst = inst->GetDstReg();
            if (acc_dst != compiler::ACC_REG_ID) {
                DoSta(inst->GetDstReg(), enc->result_);
            }
            break;
        }

       case compiler::RuntimeInterface::IntrinsicId::CALLRUNTIME_WIDELDLAZYSENDABLEMODULEVAR_PREF_IMM16:
       {
           ASSERT(inst->HasImms() && inst->GetImms().size() > 0); // NOLINTNEXTLINE(readability-container-size-empty)
            auto imm0 = static_cast<uint32_t>(inst->GetImms()[0]);
            enc->result_.emplace_back(pandasm::Create_CALLRUNTIME_WIDELDLAZYSENDABLEMODULEVAR(imm0));
            auto acc_dst = inst->GetDstReg();
            if (acc_dst != compiler::ACC_REG_ID) {
                DoSta(inst->GetDstReg(), enc->result_);
            }
            break;
        }

       case compiler::RuntimeInterface::IntrinsicId::CALLRUNTIME_SUPERCALLFORWARDALLARGS_PREF_V8:
       {
            auto v0 = inst->GetSrcReg(0);
            enc->result_.emplace_back(pandasm::Create_CALLRUNTIME_SUPERCALLFORWARDALLARGS(v0));
            auto acc_dst = inst->GetDstReg();
            if (acc_dst != compiler::ACC_REG_ID) {
                DoSta(inst->GetDstReg(), enc->result_);
            }
            break;
        }


        //////////////////////////////////////////////////////////////////////////////////////
        // hard trigger to be tested
        case compiler::RuntimeInterface::IntrinsicId::LDOBJBYINDEX_IMM8_IMM16:
        case compiler::RuntimeInterface::IntrinsicId::LDOBJBYINDEX_IMM16_IMM16:
        {
            panda::es2panda::ir::Expression* obj_expression = *enc->get_expression_by_id(inst, inst->GetInputsCount() - 2);
            
            uint32_t imm;

            if(inst->GetIntrinsicId() == compiler::RuntimeInterface::IntrinsicId::WIDE_LDOBJBYINDEX_PREF_IMM32){
                imm = static_cast<uint32_t>(inst->GetImms()[0]);
            }else{
                imm = static_cast<uint32_t>(inst->GetImms()[1]);
            }

            panda::es2panda::ir::Expression* attr_expression = enc->get_literal_bynum(imm);

            auto objattrexpression = AllocNode<es2panda::ir::MemberExpression>(enc,
                                                        obj_expression,
                                                        attr_expression, 
                                                        es2panda::ir::MemberExpression::MemberExpressionKind::PROPERTY_ACCESS, 
                                                        true, 
                                                        false);

            enc->set_expression_by_register(inst, inst->GetDstReg(), objattrexpression);
            break;

        }

       case compiler::RuntimeInterface::IntrinsicId::STOBJBYINDEX_IMM8_V8_IMM16:
       case compiler::RuntimeInterface::IntrinsicId::STOBJBYINDEX_IMM16_V8_IMM16:
       case compiler::RuntimeInterface::IntrinsicId::WIDE_STOBJBYINDEX_PREF_V8_IMM32:
       {
            uint32_t imm;

            if(inst->GetIntrinsicId() == compiler::RuntimeInterface::IntrinsicId::WIDE_STOBJBYINDEX_PREF_V8_IMM32){
                imm = static_cast<uint32_t>(inst->GetImms()[0]);
            }else{
                imm = static_cast<uint32_t>(inst->GetImms()[1]);
            }

            auto objattrexpression = AllocNode<es2panda::ir::MemberExpression>(enc,
                                                        *enc->get_expression_by_id(inst, 0),
                                                        enc->get_literal_bynum(imm), 
                                                        es2panda::ir::MemberExpression::MemberExpressionKind::PROPERTY_ACCESS, 
                                                        true, 
                                                        false);

             panda::es2panda::ir::Expression* assignexpression =   AllocNode<es2panda::ir::AssignmentExpression>(enc, 
                                                                            objattrexpression,
                                                                            *enc->get_expression_by_id(inst, inst->GetInputsCount() - 2),
                                                                            es2panda::lexer::TokenType::PUNCTUATOR_SUBSTITUTION
                                                                        ); 

            auto assignstatement = AllocNode<es2panda::ir::ExpressionStatement>(enc, 
                                                                                assignexpression);
            enc->add_insAst_to_blockstatemnt_by_inst(inst, assignstatement);
            break;        
        
        }
       
       case compiler::RuntimeInterface::IntrinsicId::SUPERCALLTHISRANGE_IMM8_IMM8_V8:
       case compiler::RuntimeInterface::IntrinsicId::WIDE_SUPERCALLTHISRANGE_PREF_IMM16_V8:
       {
            panda::es2panda::ir::Expression* funname = enc->get_identifier_byname(new std::string("super"));
            enc->thisptr =  *enc->get_expression_by_id(inst, 0);

            uint32_t argsum;

            if(inst->GetIntrinsicId() == compiler::RuntimeInterface::IntrinsicId::WIDE_SUPERCALLTHISRANGE_PREF_IMM16_V8){
                argsum = static_cast<uint32_t>(inst->GetImms()[0]);
            }else{
                argsum = static_cast<uint32_t>(inst->GetImms()[1]);
            }

            ArenaVector<es2panda::ir::Expression *> arguments(enc->parser_program_->Allocator()->Adapter());
            for (uint32_t i = 0; i <= argsum; ++i) {
                arguments.push_back(*enc->get_expression_by_id(inst, i));
            }

            
            es2panda::ir::CallExpression* callarg0expression = AllocNode<es2panda::ir::CallExpression>(enc, 
                                                                                funname,
                                                                                std::move(arguments),
                                                                                nullptr,
                                                                                false
                                                                            );

            enc->set_expression_by_register(inst, inst->GetDstReg(), callarg0expression);
            break;
        }

        default:
            std::cout << "@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@" << std::endl;
            enc->success_ = false;
            LOG(ERROR,COMPILER) << "Unsupported ecma opcode";
    }
}

```

`build.sh`:

```sh
../prebuilts/build-tools/linux-x86/bin/gn gen out --args='target_os="linux" target_cpu="x64" is_debug=false '
ninja -C out -w dupbuild=warn xabc

```

`case`:

```
// 1. CONST
// const pi: number = 3.14159;

// 2. Bin and Unary
// let c;
// let c;
// c = 1 + 1;
// let d = true;
// let e = false;
// let f = null;
// let g = undefined;
// var obj9 = NaN;
// var obj10 = Infinity;
// c = 3 * 9;
// let h = ~ 1;
// let i = 2;
// i--;
// i++;

// 3. typeof
// let j = 3;
// let h = typeof j;

// 4. instanceof
// var str = "Hello, World!";
// var b = str instanceof Number;

// 5. createemptyarray  createarraywithbuffer  createemptyobject createobjectwithbuffer
// var obj2 = {}; 
// var obj3 = []; 
// var obj4 = [1, 2, 3];
// var obj5 = {"a":1, "b":2, "c":3};


// 6. callargs callthis
// var x1 = clearTimeout();
// var x2 = parseInt("42");
// var x3 = parseInt("1010", 2); 
// var x4 = parseInt("10", 10, 0);
// var x5 = Math.random();
// var x6 = console.log("hello");

// 7. stobjbyvalue ldobjbyvalue
// var obj6 = {"a":1, "b":2, "c":3};
// var c = obj6["a"];
// obj6["d"] = 4;

// 8. isin stobjbyname 
// var obj7 = {"a":1, "b":2, "c":3};
// var obj8 = "a" in obj7;
// obj7.a = 5;


// 9. callarg1 tLoadString
// var obj11 = BigInt("1234567890123456789012345678901234567890");


// 10. NEWOBJRANGE
// const regex = new RegExp('pattern', 'flags');


// 11. COPYDATAPROPERTIES
// const obj1 = { a: 1, b: 2, c: 3 };
// const obj2 = { b: 4, d: 5 };
// var merged = { e: 6, ...obj1, ...obj2 };



// 12. NEWOBJAPPLY
// const numbers = [5, 6, 2, 3, 7];
// const max = Math.max.apply(null, numbers);


// 13. starrayspread apply
// const numbers = [10, 20, 30, 5, 15];
// const maxNumber = Math.max(1,2,3,...numbers); 

// 14. callthisrange callrange
// var x= setInterval(Math.max, 2000, "Bob", "Hi");
// const maxNumber = Math.max(1,2,3,4,5,6,7);

// 15. DELOBJPROP
// let obj = { a: 1, b: 2 };
// let result = delete obj.c; 

// 16. IfImm
// var x;
// var y;
// if(x){
//     y = console.log("true");
//     y = console.log("1");
// }else{
//     y = console.log("false");
// }

// const array = [10, 20, 30];
// for (const value of array.values()) {
//     console.log(value); 
// }

// 16. function declaration and DEFINEFUNC
// function add(a: number, b: number): number {
//     return a + b;
// }
// var x = add(2, 3);

// 17. enum
// enum Role {
//     A,
//     B,
//     C
// }

```

`complexstmt2body.h`:

```h
#include "ast.h"


es2panda::ir::BlockStatement* complexstmt2body(panda::es2panda::compiler::ir *astnode){
    switch(astnode->Type()){
        case AstNodeType::DO_WHILE_STATEMENT:
            return astnode->AsDoWhileStatement()->Body();
            break;
        case AstNodeType::FOR_IN_STATEMENT:
            return astnode->AsForInStatement()->Body();
            break;
        case AstNodeType::FOR_OF_STATEMENT:
            return astnode->AsForOfStatement()->Body();
            break;

        default :;
    }
}
```

`genlogs.sh`:

```sh
#!/bin/bash
../out/x64.debug/arkcompiler/ets_frontend/es2abc --dump-assembly  demo.ts  --output demo.abc > $1/demo.pa.raw
../out/x64.debug/arkcompiler/ets_frontend/es2abc --dump-ast demo.ts --output demo.abc > $1/demo.ast
../out/x64.debug/arkcompiler/runtime_core/ark_disasm demo.abc demo.pa

```

`intrinsicid2name.h`:

```h
namespace panda::compiler {
std::string GetIntrinsicOpcodeName(compiler::RuntimeInterface::IntrinsicId id) {
    switch(id) {
        case compiler::RuntimeInterface::IntrinsicId::LDUNDEFINED: {
            return "ldundefined";
        }
        case compiler::RuntimeInterface::IntrinsicId::LDNULL: {
            return "ldnull";
        }
        case compiler::RuntimeInterface::IntrinsicId::LDTRUE: {
            return "ldtrue";
        }
        case compiler::RuntimeInterface::IntrinsicId::LDFALSE: {
            return "ldfalse";
        }
        case compiler::RuntimeInterface::IntrinsicId::CREATEEMPTYOBJECT: {
            return "createemptyobject";
        }
        case compiler::RuntimeInterface::IntrinsicId::CREATEEMPTYARRAY_IMM8: {
            return "createemptyarray";
        }
        case compiler::RuntimeInterface::IntrinsicId::CREATEARRAYWITHBUFFER_IMM8_ID16: {
            return "createarraywithbuffer";
        }
        case compiler::RuntimeInterface::IntrinsicId::CREATEOBJECTWITHBUFFER_IMM8_ID16: {
            return "createobjectwithbuffer";
        }
        case compiler::RuntimeInterface::IntrinsicId::NEWOBJRANGE_IMM8_IMM8_V8: {
            return "newobjrange";
        }
        case compiler::RuntimeInterface::IntrinsicId::NEWLEXENV_IMM8: {
            return "newlexenv";
        }
        case compiler::RuntimeInterface::IntrinsicId::ADD2_IMM8_V8: {
            return "add2";
        }
        case compiler::RuntimeInterface::IntrinsicId::SUB2_IMM8_V8: {
            return "sub2";
        }
        case compiler::RuntimeInterface::IntrinsicId::MUL2_IMM8_V8: {
            return "mul2";
        }
        case compiler::RuntimeInterface::IntrinsicId::DIV2_IMM8_V8: {
            return "div2";
        }
        case compiler::RuntimeInterface::IntrinsicId::MOD2_IMM8_V8: {
            return "mod2";
        }
        case compiler::RuntimeInterface::IntrinsicId::EQ_IMM8_V8: {
            return "eq";
        }
        case compiler::RuntimeInterface::IntrinsicId::NOTEQ_IMM8_V8: {
            return "noteq";
        }
        case compiler::RuntimeInterface::IntrinsicId::LESS_IMM8_V8: {
            return "less";
        }
        case compiler::RuntimeInterface::IntrinsicId::LESSEQ_IMM8_V8: {
            return "lesseq";
        }
        case compiler::RuntimeInterface::IntrinsicId::GREATER_IMM8_V8: {
            return "greater";
        }
        case compiler::RuntimeInterface::IntrinsicId::GREATEREQ_IMM8_V8: {
            return "greatereq";
        }
        case compiler::RuntimeInterface::IntrinsicId::SHL2_IMM8_V8: {
            return "shl2";
        }
        case compiler::RuntimeInterface::IntrinsicId::SHR2_IMM8_V8: {
            return "shr2";
        }
        case compiler::RuntimeInterface::IntrinsicId::ASHR2_IMM8_V8: {
            return "ashr2";
        }
        case compiler::RuntimeInterface::IntrinsicId::AND2_IMM8_V8: {
            return "and2";
        }
        case compiler::RuntimeInterface::IntrinsicId::OR2_IMM8_V8: {
            return "or2";
        }
        case compiler::RuntimeInterface::IntrinsicId::XOR2_IMM8_V8: {
            return "xor2";
        }
        case compiler::RuntimeInterface::IntrinsicId::EXP_IMM8_V8: {
            return "exp";
        }
        case compiler::RuntimeInterface::IntrinsicId::TYPEOF_IMM8: {
            return "typeof";
        }
        case compiler::RuntimeInterface::IntrinsicId::TONUMBER_IMM8: {
            return "tonumber";
        }
        case compiler::RuntimeInterface::IntrinsicId::TONUMERIC_IMM8: {
            return "tonumeric";
        }
        case compiler::RuntimeInterface::IntrinsicId::NEG_IMM8: {
            return "neg";
        }
        case compiler::RuntimeInterface::IntrinsicId::NOT_IMM8: {
            return "not";
        }
        case compiler::RuntimeInterface::IntrinsicId::INC_IMM8: {
            return "inc";
        }
        case compiler::RuntimeInterface::IntrinsicId::DEC_IMM8: {
            return "dec";
        }
        case compiler::RuntimeInterface::IntrinsicId::ISTRUE: {
            return "istrue";
        }
        case compiler::RuntimeInterface::IntrinsicId::ISFALSE: {
            return "isfalse";
        }
        case compiler::RuntimeInterface::IntrinsicId::ISIN_IMM8_V8: {
            return "isin";
        }
        case compiler::RuntimeInterface::IntrinsicId::INSTANCEOF_IMM8_V8: {
            return "instanceof";
        }
        case compiler::RuntimeInterface::IntrinsicId::STRICTNOTEQ_IMM8_V8: {
            return "strictnoteq";
        }
        case compiler::RuntimeInterface::IntrinsicId::STRICTEQ_IMM8_V8: {
            return "stricteq";
        }
        case compiler::RuntimeInterface::IntrinsicId::CALLARG0_IMM8: {
            return "callarg0";
        }
        case compiler::RuntimeInterface::IntrinsicId::CALLARG1_IMM8_V8: {
            return "callarg1";
        }
        case compiler::RuntimeInterface::IntrinsicId::CALLARGS2_IMM8_V8_V8: {
            return "callargs2";
        }
        case compiler::RuntimeInterface::IntrinsicId::CALLARGS3_IMM8_V8_V8_V8: {
            return "callargs3";
        }
        case compiler::RuntimeInterface::IntrinsicId::CALLTHIS0_IMM8_V8: {
            return "callthis0";
        }
        case compiler::RuntimeInterface::IntrinsicId::CALLTHIS1_IMM8_V8_V8: {
            return "callthis1";
        }
        case compiler::RuntimeInterface::IntrinsicId::CALLTHIS2_IMM8_V8_V8_V8: {
            return "callthis2";
        }
        case compiler::RuntimeInterface::IntrinsicId::CALLTHIS3_IMM8_V8_V8_V8_V8: {
            return "callthis3";
        }
        case compiler::RuntimeInterface::IntrinsicId::CALLTHISRANGE_IMM8_IMM8_V8: {
            return "callthisrange";
        }
        case compiler::RuntimeInterface::IntrinsicId::SUPERCALLTHISRANGE_IMM8_IMM8_V8: {
            return "supercallthisrange";
        }
        case compiler::RuntimeInterface::IntrinsicId::DEFINEFUNC_IMM8_ID16_IMM8: {
            return "definefunc";
        }
        case compiler::RuntimeInterface::IntrinsicId::DEFINEMETHOD_IMM8_ID16_IMM8: {
            return "definemethod";
        }
        case compiler::RuntimeInterface::IntrinsicId::DEFINECLASSWITHBUFFER_IMM8_ID16_ID16_IMM16_V8: {
            return "defineclasswithbuffer";
        }
        case compiler::RuntimeInterface::IntrinsicId::GETNEXTPROPNAME_V8: {
            return "getnextpropname";
        }
        case compiler::RuntimeInterface::IntrinsicId::LDOBJBYVALUE_IMM8_V8: {
            return "ldobjbyvalue";
        }
        case compiler::RuntimeInterface::IntrinsicId::STOBJBYVALUE_IMM8_V8_V8: {
            return "stobjbyvalue";
        }
        case compiler::RuntimeInterface::IntrinsicId::LDSUPERBYVALUE_IMM8_V8: {
            return "ldsuperbyvalue";
        }
        case compiler::RuntimeInterface::IntrinsicId::LDOBJBYINDEX_IMM8_IMM16: {
            return "ldobjbyindex";
        }
        case compiler::RuntimeInterface::IntrinsicId::STOBJBYINDEX_IMM8_V8_IMM16: {
            return "stobjbyindex";
        }
        case compiler::RuntimeInterface::IntrinsicId::LDLEXVAR_IMM4_IMM4: {
            return "ldlexvar";
        }
        case compiler::RuntimeInterface::IntrinsicId::STLEXVAR_IMM4_IMM4: {
            return "stlexvar";
        }
        case compiler::RuntimeInterface::IntrinsicId::TRYLDGLOBALBYNAME_IMM8_ID16: {
            return "tryldglobalbyname";
        }
        case compiler::RuntimeInterface::IntrinsicId::TRYSTGLOBALBYNAME_IMM8_ID16: {
            return "trystglobalbyname";
        }
        case compiler::RuntimeInterface::IntrinsicId::LDGLOBALVAR_IMM16_ID16: {
            return "ldglobalvar";
        }
        case compiler::RuntimeInterface::IntrinsicId::LDOBJBYNAME_IMM8_ID16: {
            return "ldobjbyname";
        }
        case compiler::RuntimeInterface::IntrinsicId::STOBJBYNAME_IMM8_ID16_V8: {
            return "stobjbyname";
        }
        case compiler::RuntimeInterface::IntrinsicId::LDSUPERBYNAME_IMM8_ID16: {
            return "ldsuperbyname";
        }
        case compiler::RuntimeInterface::IntrinsicId::STCONSTTOGLOBALRECORD_IMM16_ID16: {
            return "stconsttoglobalrecord";
        }
        case compiler::RuntimeInterface::IntrinsicId::STTOGLOBALRECORD_IMM16_ID16: {
            return "sttoglobalrecord";
        }
        case compiler::RuntimeInterface::IntrinsicId::LDTHISBYNAME_IMM8_ID16: {
            return "ldthisbyname";
        }
        case compiler::RuntimeInterface::IntrinsicId::STTHISBYNAME_IMM8_ID16: {
            return "stthisbyname";
        }
        case compiler::RuntimeInterface::IntrinsicId::LDTHISBYVALUE_IMM8: {
            return "ldthisbyvalue";
        }
        case compiler::RuntimeInterface::IntrinsicId::STTHISBYVALUE_IMM8_V8: {
            return "stthisbyvalue";
        }
        case compiler::RuntimeInterface::IntrinsicId::RETURN: {
            return "return";
        }
        case compiler::RuntimeInterface::IntrinsicId::RETURNUNDEFINED: {
            return "returnundefined";
        }
        case compiler::RuntimeInterface::IntrinsicId::GETPROPITERATOR: {
            return "getpropiterator";
        }
        case compiler::RuntimeInterface::IntrinsicId::GETITERATOR_IMM8: {
            return "getiterator";
        }
        case compiler::RuntimeInterface::IntrinsicId::CLOSEITERATOR_IMM8_V8: {
            return "closeiterator";
        }
        case compiler::RuntimeInterface::IntrinsicId::POPLEXENV: {
            return "poplexenv";
        }
        case compiler::RuntimeInterface::IntrinsicId::LDNAN: {
            return "ldnan";
        }
        case compiler::RuntimeInterface::IntrinsicId::LDINFINITY: {
            return "ldinfinity";
        }
        case compiler::RuntimeInterface::IntrinsicId::GETUNMAPPEDARGS: {
            return "getunmappedargs";
        }
        case compiler::RuntimeInterface::IntrinsicId::LDGLOBAL: {
            return "ldglobal";
        }
        case compiler::RuntimeInterface::IntrinsicId::LDNEWTARGET: {
            return "ldnewtarget";
        }
        case compiler::RuntimeInterface::IntrinsicId::LDTHIS: {
            return "ldthis";
        }
        case compiler::RuntimeInterface::IntrinsicId::LDHOLE: {
            return "ldhole";
        }
        case compiler::RuntimeInterface::IntrinsicId::CREATEREGEXPWITHLITERAL_IMM8_ID16_IMM8: {
            return "createregexpwithliteral";
        }
        case compiler::RuntimeInterface::IntrinsicId::CREATEREGEXPWITHLITERAL_IMM16_ID16_IMM8: {
            return "createregexpwithliteral";
        }
        case compiler::RuntimeInterface::IntrinsicId::CALLRANGE_IMM8_IMM8_V8: {
            return "callrange";
        }
        case compiler::RuntimeInterface::IntrinsicId::DEFINEFUNC_IMM16_ID16_IMM8: {
            return "definefunc";
        }
        case compiler::RuntimeInterface::IntrinsicId::DEFINECLASSWITHBUFFER_IMM16_ID16_ID16_IMM16_V8: {
            return "defineclasswithbuffer";
        }
        case compiler::RuntimeInterface::IntrinsicId::GETTEMPLATEOBJECT_IMM8: {
            return "gettemplateobject";
        }
        case compiler::RuntimeInterface::IntrinsicId::SETOBJECTWITHPROTO_IMM8_V8: {
            return "setobjectwithproto";
        }
        case compiler::RuntimeInterface::IntrinsicId::STOWNBYVALUE_IMM8_V8_V8: {
            return "stownbyvalue";
        }
        case compiler::RuntimeInterface::IntrinsicId::STOWNBYINDEX_IMM8_V8_IMM16: {
            return "stownbyindex";
        }
        case compiler::RuntimeInterface::IntrinsicId::STOWNBYNAME_IMM8_ID16_V8: {
            return "stownbyname";
        }
        case compiler::RuntimeInterface::IntrinsicId::GETMODULENAMESPACE_IMM8: {
            return "getmodulenamespace";
        }
        case compiler::RuntimeInterface::IntrinsicId::STMODULEVAR_IMM8: {
            return "stmodulevar";
        }
        case compiler::RuntimeInterface::IntrinsicId::LDLOCALMODULEVAR_IMM8: {
            return "ldlocalmodulevar";
        }
        case compiler::RuntimeInterface::IntrinsicId::LDEXTERNALMODULEVAR_IMM8: {
            return "ldexternalmodulevar";
        }
        case compiler::RuntimeInterface::IntrinsicId::STGLOBALVAR_IMM16_ID16: {
            return "stglobalvar";
        }
        case compiler::RuntimeInterface::IntrinsicId::CREATEEMPTYARRAY_IMM16: {
            return "createemptyarray";
        }
        case compiler::RuntimeInterface::IntrinsicId::CREATEARRAYWITHBUFFER_IMM16_ID16: {
            return "createarraywithbuffer";
        }
        case compiler::RuntimeInterface::IntrinsicId::CREATEOBJECTWITHBUFFER_IMM16_ID16: {
            return "createobjectwithbuffer";
        }
        case compiler::RuntimeInterface::IntrinsicId::NEWOBJRANGE_IMM16_IMM8_V8: {
            return "newobjrange";
        }
        case compiler::RuntimeInterface::IntrinsicId::TYPEOF_IMM16: {
            return "typeof";
        }
        case compiler::RuntimeInterface::IntrinsicId::LDOBJBYVALUE_IMM16_V8: {
            return "ldobjbyvalue";
        }
        case compiler::RuntimeInterface::IntrinsicId::STOBJBYVALUE_IMM16_V8_V8: {
            return "stobjbyvalue";
        }
        case compiler::RuntimeInterface::IntrinsicId::LDSUPERBYVALUE_IMM16_V8: {
            return "ldsuperbyvalue";
        }
        case compiler::RuntimeInterface::IntrinsicId::LDOBJBYINDEX_IMM16_IMM16: {
            return "ldobjbyindex";
        }
        case compiler::RuntimeInterface::IntrinsicId::STOBJBYINDEX_IMM16_V8_IMM16: {
            return "stobjbyindex";
        }
        case compiler::RuntimeInterface::IntrinsicId::LDLEXVAR_IMM8_IMM8: {
            return "ldlexvar";
        }
        case compiler::RuntimeInterface::IntrinsicId::STLEXVAR_IMM8_IMM8: {
            return "stlexvar";
        }
        case compiler::RuntimeInterface::IntrinsicId::TRYLDGLOBALBYNAME_IMM16_ID16: {
            return "tryldglobalbyname";
        }
        case compiler::RuntimeInterface::IntrinsicId::TRYSTGLOBALBYNAME_IMM16_ID16: {
            return "trystglobalbyname";
        }
        case compiler::RuntimeInterface::IntrinsicId::STOWNBYNAMEWITHNAMESET_IMM8_ID16_V8: {
            return "stownbynamewithnameset";
        }
        case compiler::RuntimeInterface::IntrinsicId::LDOBJBYNAME_IMM16_ID16: {
            return "ldobjbyname";
        }
        case compiler::RuntimeInterface::IntrinsicId::STOBJBYNAME_IMM16_ID16_V8: {
            return "stobjbyname";
        }
        case compiler::RuntimeInterface::IntrinsicId::LDSUPERBYNAME_IMM16_ID16: {
            return "ldsuperbyname";
        }
        case compiler::RuntimeInterface::IntrinsicId::LDTHISBYNAME_IMM16_ID16: {
            return "ldthisbyname";
        }
        case compiler::RuntimeInterface::IntrinsicId::STTHISBYNAME_IMM16_ID16: {
            return "stthisbyname";
        }
        case compiler::RuntimeInterface::IntrinsicId::LDTHISBYVALUE_IMM16: {
            return "ldthisbyvalue";
        }
        case compiler::RuntimeInterface::IntrinsicId::STTHISBYVALUE_IMM16_V8: {
            return "stthisbyvalue";
        }
        case compiler::RuntimeInterface::IntrinsicId::ASYNCGENERATORREJECT_V8: {
            return "asyncgeneratorreject";
        }
        case compiler::RuntimeInterface::IntrinsicId::STOWNBYVALUEWITHNAMESET_IMM8_V8_V8: {
            return "stownbyvaluewithnameset";
        }
        case compiler::RuntimeInterface::IntrinsicId::GETITERATOR_IMM16: {
            return "getiterator";
        }
        case compiler::RuntimeInterface::IntrinsicId::CLOSEITERATOR_IMM16_V8: {
            return "closeiterator";
        }
        case compiler::RuntimeInterface::IntrinsicId::LDSYMBOL: {
            return "ldsymbol";
        }
        case compiler::RuntimeInterface::IntrinsicId::ASYNCFUNCTIONENTER: {
            return "asyncfunctionenter";
        }
        case compiler::RuntimeInterface::IntrinsicId::LDFUNCTION: {
            return "ldfunction";
        }
        case compiler::RuntimeInterface::IntrinsicId::DEBUGGER: {
            return "debugger";
        }
        case compiler::RuntimeInterface::IntrinsicId::CREATEGENERATOROBJ_V8: {
            return "creategeneratorobj";
        }
        case compiler::RuntimeInterface::IntrinsicId::CREATEITERRESULTOBJ_V8_V8: {
            return "createiterresultobj";
        }
        case compiler::RuntimeInterface::IntrinsicId::CREATEOBJECTWITHEXCLUDEDKEYS_IMM8_V8_V8: {
            return "createobjectwithexcludedkeys";
        }
        case compiler::RuntimeInterface::IntrinsicId::NEWOBJAPPLY_IMM8_V8: {
            return "newobjapply";
        }
        case compiler::RuntimeInterface::IntrinsicId::NEWOBJAPPLY_IMM16_V8: {
            return "newobjapply";
        }
        case compiler::RuntimeInterface::IntrinsicId::NEWLEXENVWITHNAME_IMM8_ID16: {
            return "newlexenvwithname";
        }
        case compiler::RuntimeInterface::IntrinsicId::CREATEASYNCGENERATOROBJ_V8: {
            return "createasyncgeneratorobj";
        }
        case compiler::RuntimeInterface::IntrinsicId::ASYNCGENERATORRESOLVE_V8_V8_V8: {
            return "asyncgeneratorresolve";
        }
        case compiler::RuntimeInterface::IntrinsicId::SUPERCALLSPREAD_IMM8_V8: {
            return "supercallspread";
        }
        case compiler::RuntimeInterface::IntrinsicId::APPLY_IMM8_V8_V8: {
            return "apply";
        }
        case compiler::RuntimeInterface::IntrinsicId::SUPERCALLARROWRANGE_IMM8_IMM8_V8: {
            return "supercallarrowrange";
        }
        case compiler::RuntimeInterface::IntrinsicId::DEFINEGETTERSETTERBYVALUE_V8_V8_V8_V8: {
            return "definegettersetterbyvalue";
        }
        case compiler::RuntimeInterface::IntrinsicId::DYNAMICIMPORT: {
            return "dynamicimport";
        }
        case compiler::RuntimeInterface::IntrinsicId::DEFINEMETHOD_IMM16_ID16_IMM8: {
            return "definemethod";
        }
        case compiler::RuntimeInterface::IntrinsicId::RESUMEGENERATOR: {
            return "resumegenerator";
        }
        case compiler::RuntimeInterface::IntrinsicId::GETRESUMEMODE: {
            return "getresumemode";
        }
        case compiler::RuntimeInterface::IntrinsicId::GETTEMPLATEOBJECT_IMM16: {
            return "gettemplateobject";
        }
        case compiler::RuntimeInterface::IntrinsicId::DELOBJPROP_V8: {
            return "delobjprop";
        }
        case compiler::RuntimeInterface::IntrinsicId::SUSPENDGENERATOR_V8: {
            return "suspendgenerator";
        }
        case compiler::RuntimeInterface::IntrinsicId::ASYNCFUNCTIONAWAITUNCAUGHT_V8: {
            return "asyncfunctionawaituncaught";
        }
        case compiler::RuntimeInterface::IntrinsicId::COPYDATAPROPERTIES_V8: {
            return "copydataproperties";
        }
        case compiler::RuntimeInterface::IntrinsicId::STARRAYSPREAD_V8_V8: {
            return "starrayspread";
        }
        case compiler::RuntimeInterface::IntrinsicId::SETOBJECTWITHPROTO_IMM16_V8: {
            return "setobjectwithproto";
        }
        case compiler::RuntimeInterface::IntrinsicId::STOWNBYVALUE_IMM16_V8_V8: {
            return "stownbyvalue";
        }
        case compiler::RuntimeInterface::IntrinsicId::STSUPERBYVALUE_IMM8_V8_V8: {
            return "stsuperbyvalue";
        }
        case compiler::RuntimeInterface::IntrinsicId::STSUPERBYVALUE_IMM16_V8_V8: {
            return "stsuperbyvalue";
        }
        case compiler::RuntimeInterface::IntrinsicId::STOWNBYINDEX_IMM16_V8_IMM16: {
            return "stownbyindex";
        }
        case compiler::RuntimeInterface::IntrinsicId::STOWNBYNAME_IMM16_ID16_V8: {
            return "stownbyname";
        }
        case compiler::RuntimeInterface::IntrinsicId::ASYNCFUNCTIONRESOLVE_V8: {
            return "asyncfunctionresolve";
        }
        case compiler::RuntimeInterface::IntrinsicId::ASYNCFUNCTIONREJECT_V8: {
            return "asyncfunctionreject";
        }
        case compiler::RuntimeInterface::IntrinsicId::COPYRESTARGS_IMM8: {
            return "copyrestargs";
        }
        case compiler::RuntimeInterface::IntrinsicId::STSUPERBYNAME_IMM8_ID16_V8: {
            return "stsuperbyname";
        }
        case compiler::RuntimeInterface::IntrinsicId::STSUPERBYNAME_IMM16_ID16_V8: {
            return "stsuperbyname";
        }
        case compiler::RuntimeInterface::IntrinsicId::STOWNBYVALUEWITHNAMESET_IMM16_V8_V8: {
            return "stownbyvaluewithnameset";
        }
        case compiler::RuntimeInterface::IntrinsicId::LDBIGINT_ID16: {
            return "ldbigint";
        }
        case compiler::RuntimeInterface::IntrinsicId::STOWNBYNAMEWITHNAMESET_IMM16_ID16_V8: {
            return "stownbynamewithnameset";
        }
        case compiler::RuntimeInterface::IntrinsicId::SETGENERATORSTATE_IMM8: {
            return "setgeneratorstate";
        }
        case compiler::RuntimeInterface::IntrinsicId::GETASYNCITERATOR_IMM8: {
            return "getasynciterator";
        }
        case compiler::RuntimeInterface::IntrinsicId::LDPRIVATEPROPERTY_IMM8_IMM16_IMM16: {
            return "ldprivateproperty";
        }
        case compiler::RuntimeInterface::IntrinsicId::STPRIVATEPROPERTY_IMM8_IMM16_IMM16_V8: {
            return "stprivateproperty";
        }
        case compiler::RuntimeInterface::IntrinsicId::TESTIN_IMM8_IMM16_IMM16: {
            return "testin";
        }
        case compiler::RuntimeInterface::IntrinsicId::DEFINEFIELDBYNAME_IMM8_ID16_V8: {
            return "definefieldbyname";
        }
        case compiler::RuntimeInterface::IntrinsicId::DEFINEPROPERTYBYNAME_IMM8_ID16_V8: {
            return "definepropertybyname";
        }
        case compiler::RuntimeInterface::IntrinsicId::CALLRUNTIME_NOTIFYCONCURRENTRESULT_PREF_NONE: {
            return "callruntime.notifyconcurrentresult";
        }
        case compiler::RuntimeInterface::IntrinsicId::DEPRECATED_LDLEXENV_PREF_NONE: {
            return "deprecated.ldlexenv";
        }
        case compiler::RuntimeInterface::IntrinsicId::WIDE_CREATEOBJECTWITHEXCLUDEDKEYS_PREF_IMM16_V8_V8: {
            return "wide.createobjectwithexcludedkeys";
        }
        case compiler::RuntimeInterface::IntrinsicId::THROW_PREF_NONE: {
            return "throw";
        }
        case compiler::RuntimeInterface::IntrinsicId::CALLRUNTIME_DEFINEFIELDBYVALUE_PREF_IMM8_V8_V8: {
            return "callruntime.definefieldbyvalue";
        }
        case compiler::RuntimeInterface::IntrinsicId::DEPRECATED_POPLEXENV_PREF_NONE: {
            return "deprecated.poplexenv";
        }
        case compiler::RuntimeInterface::IntrinsicId::WIDE_NEWOBJRANGE_PREF_IMM16_V8: {
            return "wide.newobjrange";
        }
        case compiler::RuntimeInterface::IntrinsicId::THROW_NOTEXISTS_PREF_NONE: {
            return "throw.notexists";
        }
        case compiler::RuntimeInterface::IntrinsicId::CALLRUNTIME_DEFINEFIELDBYINDEX_PREF_IMM8_IMM32_V8: {
            return "callruntime.definefieldbyindex";
        }
        case compiler::RuntimeInterface::IntrinsicId::DEPRECATED_GETITERATORNEXT_PREF_V8_V8: {
            return "deprecated.getiteratornext";
        }
        case compiler::RuntimeInterface::IntrinsicId::WIDE_NEWLEXENV_PREF_IMM16: {
            return "wide.newlexenv";
        }
        case compiler::RuntimeInterface::IntrinsicId::THROW_PATTERNNONCOERCIBLE_PREF_NONE: {
            return "throw.patternnoncoercible";
        }
        case compiler::RuntimeInterface::IntrinsicId::CALLRUNTIME_TOPROPERTYKEY_PREF_NONE: {
            return "callruntime.topropertykey";
        }
        case compiler::RuntimeInterface::IntrinsicId::DEPRECATED_CREATEARRAYWITHBUFFER_PREF_IMM16: {
            return "deprecated.createarraywithbuffer";
        }
        case compiler::RuntimeInterface::IntrinsicId::WIDE_NEWLEXENVWITHNAME_PREF_IMM16_ID16: {
            return "wide.newlexenvwithname";
        }
        case compiler::RuntimeInterface::IntrinsicId::THROW_DELETESUPERPROPERTY_PREF_NONE: {
            return "throw.deletesuperproperty";
        }
        case compiler::RuntimeInterface::IntrinsicId::CALLRUNTIME_CREATEPRIVATEPROPERTY_PREF_IMM16_ID16: {
            return "callruntime.createprivateproperty";
        }
        case compiler::RuntimeInterface::IntrinsicId::DEPRECATED_CREATEOBJECTWITHBUFFER_PREF_IMM16: {
            return "deprecated.createobjectwithbuffer";
        }
        case compiler::RuntimeInterface::IntrinsicId::WIDE_CALLRANGE_PREF_IMM16_V8: {
            return "wide.callrange";
        }
        case compiler::RuntimeInterface::IntrinsicId::THROW_CONSTASSIGNMENT_PREF_V8: {
            return "throw.constassignment";
        }
        case compiler::RuntimeInterface::IntrinsicId::CALLRUNTIME_DEFINEPRIVATEPROPERTY_PREF_IMM8_IMM16_IMM16_V8: {
            return "callruntime.defineprivateproperty";
        }
        case compiler::RuntimeInterface::IntrinsicId::DEPRECATED_TONUMBER_PREF_V8: {
            return "deprecated.tonumber";
        }
        case compiler::RuntimeInterface::IntrinsicId::WIDE_CALLTHISRANGE_PREF_IMM16_V8: {
            return "wide.callthisrange";
        }
        case compiler::RuntimeInterface::IntrinsicId::THROW_IFNOTOBJECT_PREF_V8: {
            return "throw.ifnotobject";
        }
        case compiler::RuntimeInterface::IntrinsicId::CALLRUNTIME_CALLINIT_PREF_IMM8_V8: {
            return "callruntime.callinit";
        }
        case compiler::RuntimeInterface::IntrinsicId::DEPRECATED_TONUMERIC_PREF_V8: {
            return "deprecated.tonumeric";
        }
        case compiler::RuntimeInterface::IntrinsicId::WIDE_SUPERCALLTHISRANGE_PREF_IMM16_V8: {
            return "wide.supercallthisrange";
        }
        case compiler::RuntimeInterface::IntrinsicId::THROW_UNDEFINEDIFHOLE_PREF_V8_V8: {
            return "throw.undefinedifhole";
        }
        case compiler::RuntimeInterface::IntrinsicId::CALLRUNTIME_DEFINESENDABLECLASS_PREF_IMM16_ID16_ID16_IMM16_V8: {
            return "callruntime.definesendableclass";
        }
        case compiler::RuntimeInterface::IntrinsicId::DEPRECATED_NEG_PREF_V8: {
            return "deprecated.neg";
        }
        case compiler::RuntimeInterface::IntrinsicId::WIDE_SUPERCALLARROWRANGE_PREF_IMM16_V8: {
            return "wide.supercallarrowrange";
        }
        case compiler::RuntimeInterface::IntrinsicId::THROW_IFSUPERNOTCORRECTCALL_PREF_IMM8: {
            return "throw.ifsupernotcorrectcall";
        }
        case compiler::RuntimeInterface::IntrinsicId::CALLRUNTIME_LDSENDABLECLASS_PREF_IMM16: {
            return "callruntime.ldsendableclass";
        }
        case compiler::RuntimeInterface::IntrinsicId::DEPRECATED_NOT_PREF_V8: {
            return "deprecated.not";
        }
        case compiler::RuntimeInterface::IntrinsicId::WIDE_LDOBJBYINDEX_PREF_IMM32: {
            return "wide.ldobjbyindex";
        }
        case compiler::RuntimeInterface::IntrinsicId::THROW_IFSUPERNOTCORRECTCALL_PREF_IMM16: {
            return "throw.ifsupernotcorrectcall";
        }
        case compiler::RuntimeInterface::IntrinsicId::CALLRUNTIME_LDSENDABLEEXTERNALMODULEVAR_PREF_IMM8: {
            return "callruntime.ldsendableexternalmodulevar";
        }
        case compiler::RuntimeInterface::IntrinsicId::DEPRECATED_INC_PREF_V8: {
            return "deprecated.inc";
        }
        case compiler::RuntimeInterface::IntrinsicId::WIDE_STOBJBYINDEX_PREF_V8_IMM32: {
            return "wide.stobjbyindex";
        }
        case compiler::RuntimeInterface::IntrinsicId::THROW_UNDEFINEDIFHOLEWITHNAME_PREF_ID16: {
            return "throw.undefinedifholewithname";
        }
        case compiler::RuntimeInterface::IntrinsicId::CALLRUNTIME_WIDELDSENDABLEEXTERNALMODULEVAR_PREF_IMM16: {
            return "callruntime.wideldsendableexternalmodulevar";
        }
        case compiler::RuntimeInterface::IntrinsicId::DEPRECATED_DEC_PREF_V8: {
            return "deprecated.dec";
        }
        case compiler::RuntimeInterface::IntrinsicId::WIDE_STOWNBYINDEX_PREF_V8_IMM32: {
            return "wide.stownbyindex";
        }
        case compiler::RuntimeInterface::IntrinsicId::CALLRUNTIME_NEWSENDABLEENV_PREF_IMM8: {
            return "callruntime.newsendableenv";
        }
        case compiler::RuntimeInterface::IntrinsicId::DEPRECATED_CALLARG0_PREF_V8: {
            return "deprecated.callarg0";
        }
        case compiler::RuntimeInterface::IntrinsicId::WIDE_COPYRESTARGS_PREF_IMM16: {
            return "wide.copyrestargs";
        }
        case compiler::RuntimeInterface::IntrinsicId::CALLRUNTIME_WIDENEWSENDABLEENV_PREF_IMM16: {
            return "callruntime.widenewsendableenv";
        }
        case compiler::RuntimeInterface::IntrinsicId::DEPRECATED_CALLARG1_PREF_V8_V8: {
            return "deprecated.callarg1";
        }
        case compiler::RuntimeInterface::IntrinsicId::WIDE_LDLEXVAR_PREF_IMM16_IMM16: {
            return "wide.ldlexvar";
        }
        case compiler::RuntimeInterface::IntrinsicId::CALLRUNTIME_STSENDABLEVAR_PREF_IMM4_IMM4: {
            return "callruntime.stsendablevar";
        }
        case compiler::RuntimeInterface::IntrinsicId::DEPRECATED_CALLARGS2_PREF_V8_V8_V8: {
            return "deprecated.callargs2";
        }
        case compiler::RuntimeInterface::IntrinsicId::WIDE_STLEXVAR_PREF_IMM16_IMM16: {
            return "wide.stlexvar";
        }
        case compiler::RuntimeInterface::IntrinsicId::CALLRUNTIME_STSENDABLEVAR_PREF_IMM8_IMM8: {
            return "callruntime.stsendablevar";
        }
        case compiler::RuntimeInterface::IntrinsicId::DEPRECATED_CALLARGS3_PREF_V8_V8_V8_V8: {
            return "deprecated.callargs3";
        }
        case compiler::RuntimeInterface::IntrinsicId::WIDE_GETMODULENAMESPACE_PREF_IMM16: {
            return "wide.getmodulenamespace";
        }
        case compiler::RuntimeInterface::IntrinsicId::CALLRUNTIME_WIDESTSENDABLEVAR_PREF_IMM16_IMM16: {
            return "callruntime.widestsendablevar";
        }
        case compiler::RuntimeInterface::IntrinsicId::DEPRECATED_CALLRANGE_PREF_IMM16_V8: {
            return "deprecated.callrange";
        }
        case compiler::RuntimeInterface::IntrinsicId::WIDE_STMODULEVAR_PREF_IMM16: {
            return "wide.stmodulevar";
        }
        case compiler::RuntimeInterface::IntrinsicId::CALLRUNTIME_LDSENDABLEVAR_PREF_IMM4_IMM4: {
            return "callruntime.ldsendablevar";
        }
        case compiler::RuntimeInterface::IntrinsicId::DEPRECATED_CALLSPREAD_PREF_V8_V8_V8: {
            return "deprecated.callspread";
        }
        case compiler::RuntimeInterface::IntrinsicId::WIDE_LDLOCALMODULEVAR_PREF_IMM16: {
            return "wide.ldlocalmodulevar";
        }
        case compiler::RuntimeInterface::IntrinsicId::CALLRUNTIME_LDSENDABLEVAR_PREF_IMM8_IMM8: {
            return "callruntime.ldsendablevar";
        }
        case compiler::RuntimeInterface::IntrinsicId::DEPRECATED_CALLTHISRANGE_PREF_IMM16_V8: {
            return "deprecated.callthisrange";
        }
        case compiler::RuntimeInterface::IntrinsicId::WIDE_LDEXTERNALMODULEVAR_PREF_IMM16: {
            return "wide.ldexternalmodulevar";
        }
        case compiler::RuntimeInterface::IntrinsicId::CALLRUNTIME_WIDELDSENDABLEVAR_PREF_IMM16_IMM16: {
            return "callruntime.wideldsendablevar";
        }
        case compiler::RuntimeInterface::IntrinsicId::DEPRECATED_DEFINECLASSWITHBUFFER_PREF_ID16_IMM16_IMM16_V8_V8: {
            return "deprecated.defineclasswithbuffer";
        }
        case compiler::RuntimeInterface::IntrinsicId::WIDE_LDPATCHVAR_PREF_IMM16: {
            return "wide.ldpatchvar";
        }
        case compiler::RuntimeInterface::IntrinsicId::CALLRUNTIME_ISTRUE_PREF_IMM8: {
            return "callruntime.istrue";
        }
        case compiler::RuntimeInterface::IntrinsicId::DEPRECATED_RESUMEGENERATOR_PREF_V8: {
            return "deprecated.resumegenerator";
        }
        case compiler::RuntimeInterface::IntrinsicId::WIDE_STPATCHVAR_PREF_IMM16: {
            return "wide.stpatchvar";
        }
        case compiler::RuntimeInterface::IntrinsicId::CALLRUNTIME_ISFALSE_PREF_IMM8: {
            return "callruntime.isfalse";
        }
        case compiler::RuntimeInterface::IntrinsicId::DEPRECATED_GETRESUMEMODE_PREF_V8: {
            return "deprecated.getresumemode";
        }
        case compiler::RuntimeInterface::IntrinsicId::CALLRUNTIME_LDLAZYMODULEVAR_PREF_IMM8: {
            return "callruntime.ldlazymodulevar";
        }
        case compiler::RuntimeInterface::IntrinsicId::DEPRECATED_GETTEMPLATEOBJECT_PREF_V8: {
            return "deprecated.gettemplateobject";
        }
        case compiler::RuntimeInterface::IntrinsicId::CALLRUNTIME_WIDELDLAZYMODULEVAR_PREF_IMM16: {
            return "callruntime.wideldlazymodulevar";
        }
        case compiler::RuntimeInterface::IntrinsicId::DEPRECATED_DELOBJPROP_PREF_V8_V8: {
            return "deprecated.delobjprop";
        }
        case compiler::RuntimeInterface::IntrinsicId::CALLRUNTIME_LDLAZYSENDABLEMODULEVAR_PREF_IMM8: {
            return "callruntime.ldlazysendablemodulevar";
        }
        case compiler::RuntimeInterface::IntrinsicId::DEPRECATED_SUSPENDGENERATOR_PREF_V8_V8: {
            return "deprecated.suspendgenerator";
        }
        case compiler::RuntimeInterface::IntrinsicId::CALLRUNTIME_WIDELDLAZYSENDABLEMODULEVAR_PREF_IMM16: {
            return "callruntime.wideldlazysendablemodulevar";
        }
        case compiler::RuntimeInterface::IntrinsicId::DEPRECATED_ASYNCFUNCTIONAWAITUNCAUGHT_PREF_V8_V8: {
            return "deprecated.asyncfunctionawaituncaught";
        }
        case compiler::RuntimeInterface::IntrinsicId::CALLRUNTIME_SUPERCALLFORWARDALLARGS_PREF_V8: {
            return "callruntime.supercallforwardallargs";
        }
        case compiler::RuntimeInterface::IntrinsicId::DEPRECATED_COPYDATAPROPERTIES_PREF_V8_V8: {
            return "deprecated.copydataproperties";
        }
        case compiler::RuntimeInterface::IntrinsicId::CALLRUNTIME_LDSENDABLELOCALMODULEVAR_PREF_IMM8: {
            return "callruntime.ldsendablelocalmodulevar";
        }
        case compiler::RuntimeInterface::IntrinsicId::DEPRECATED_SETOBJECTWITHPROTO_PREF_V8_V8: {
            return "deprecated.setobjectwithproto";
        }
        case compiler::RuntimeInterface::IntrinsicId::CALLRUNTIME_WIDELDSENDABLELOCALMODULEVAR_PREF_IMM16: {
            return "callruntime.wideldsendablelocalmodulevar";
        }
        case compiler::RuntimeInterface::IntrinsicId::DEPRECATED_LDOBJBYVALUE_PREF_V8_V8: {
            return "deprecated.ldobjbyvalue";
        }
        case compiler::RuntimeInterface::IntrinsicId::DEPRECATED_LDSUPERBYVALUE_PREF_V8_V8: {
            return "deprecated.ldsuperbyvalue";
        }
        case compiler::RuntimeInterface::IntrinsicId::DEPRECATED_LDOBJBYINDEX_PREF_V8_IMM32: {
            return "deprecated.ldobjbyindex";
        }
        case compiler::RuntimeInterface::IntrinsicId::DEPRECATED_ASYNCFUNCTIONRESOLVE_PREF_V8_V8_V8: {
            return "deprecated.asyncfunctionresolve";
        }
        case compiler::RuntimeInterface::IntrinsicId::DEPRECATED_ASYNCFUNCTIONREJECT_PREF_V8_V8_V8: {
            return "deprecated.asyncfunctionreject";
        }
        case compiler::RuntimeInterface::IntrinsicId::DEPRECATED_STLEXVAR_PREF_IMM4_IMM4_V8: {
            return "deprecated.stlexvar";
        }
        case compiler::RuntimeInterface::IntrinsicId::DEPRECATED_STLEXVAR_PREF_IMM8_IMM8_V8: {
            return "deprecated.stlexvar";
        }
        case compiler::RuntimeInterface::IntrinsicId::DEPRECATED_STLEXVAR_PREF_IMM16_IMM16_V8: {
            return "deprecated.stlexvar";
        }
        case compiler::RuntimeInterface::IntrinsicId::DEPRECATED_GETMODULENAMESPACE_PREF_ID32: {
            return "deprecated.getmodulenamespace";
        }
        case compiler::RuntimeInterface::IntrinsicId::DEPRECATED_STMODULEVAR_PREF_ID32: {
            return "deprecated.stmodulevar";
        }
        case compiler::RuntimeInterface::IntrinsicId::DEPRECATED_LDOBJBYNAME_PREF_ID32_V8: {
            return "deprecated.ldobjbyname";
        }
        case compiler::RuntimeInterface::IntrinsicId::DEPRECATED_LDSUPERBYNAME_PREF_ID32_V8: {
            return "deprecated.ldsuperbyname";
        }
        case compiler::RuntimeInterface::IntrinsicId::DEPRECATED_LDMODULEVAR_PREF_ID32_IMM8: {
            return "deprecated.ldmodulevar";
        }
        case compiler::RuntimeInterface::IntrinsicId::DEPRECATED_STCONSTTOGLOBALRECORD_PREF_ID32: {
            return "deprecated.stconsttoglobalrecord";
        }
        case compiler::RuntimeInterface::IntrinsicId::DEPRECATED_STLETTOGLOBALRECORD_PREF_ID32: {
            return "deprecated.stlettoglobalrecord";
        }
        case compiler::RuntimeInterface::IntrinsicId::DEPRECATED_STCLASSTOGLOBALRECORD_PREF_ID32: {
            return "deprecated.stclasstoglobalrecord";
        }
        case compiler::RuntimeInterface::IntrinsicId::DEPRECATED_LDHOMEOBJECT_PREF_NONE: {
            return "deprecated.ldhomeobject";
        }
        case compiler::RuntimeInterface::IntrinsicId::DEPRECATED_CREATEOBJECTHAVINGMETHOD_PREF_IMM16: {
            return "deprecated.createobjecthavingmethod";
        }
        case compiler::RuntimeInterface::IntrinsicId::DEPRECATED_DYNAMICIMPORT_PREF_V8: {
            return "deprecated.dynamicimport";
        }
        case compiler::RuntimeInterface::IntrinsicId::DEPRECATED_ASYNCGENERATORREJECT_PREF_V8_V8: {
            return "deprecated.asyncgeneratorreject";
        }
        default: {
            return "";
        }
    }
}
}
```

`intrinsicid2token.h`:

```h
#include "assembler/annotation.h"
#include "assembler/assembly-function.h"
#include "assembler/assembly-ins.h"
#include "ir_interface.h"
#include "compiler/optimizer/pass.h"
#include "compiler/optimizer/ir/basicblock.h"
#include "compiler/optimizer/ir/graph.h"
#include "compiler/optimizer/ir/graph_visitor.h"
#include "utils/logger.h"

#include "../ets_frontend/es2panda/es2panda.h"
#include "../ets_frontend/es2panda/parser/program/program.h"

/////////////////////////////////////////////////////
#include "../ets_frontend/es2panda/ir/base/catchClause.h"
#include "../ets_frontend/es2panda/ir/base/classStaticBlock.h"
#include "../ets_frontend/es2panda/ir/base/decorator.h"
#include "../ets_frontend/es2panda/ir/base/scriptFunction.h"
#include "../ets_frontend/es2panda/ir/expressions/assignmentExpression.h"
#include "../ets_frontend/es2panda/ir/expressions/binaryExpression.h"
#include "../ets_frontend/es2panda/ir/expressions/callExpression.h"
#include "../ets_frontend/es2panda/ir/expressions/classExpression.h"
#include "../ets_frontend/es2panda/ir/expressions/functionExpression.h"


#include "../ets_frontend/es2panda/ir/expressions/literals/bigIntLiteral.h"
#include "../ets_frontend/es2panda/ir/expressions/literals/numberLiteral.h"
#include "../ets_frontend/es2panda/ir/expressions/literals/stringLiteral.h"
#include "../ets_frontend/es2panda/ir/expressions/literals/booleanLiteral.h"
#include "../ets_frontend/es2panda/ir/expressions/literals/nullLiteral.h"
#include "../ets_frontend/es2panda/ir/expressions/literals/regExpLiteral.h"
#include "../ets_frontend/es2panda/ir/expressions/literals/taggedLiteral.h"



#include "../ets_frontend/es2panda/ir/expressions/memberExpression.h"
#include "../ets_frontend/es2panda/ir/expressions/objectExpression.h"
#include "../ets_frontend/es2panda/ir/expressions/sequenceExpression.h"
#include "../ets_frontend/es2panda/ir/expressions/templateLiteral.h"
#include "../ets_frontend/es2panda/ir/expressions/thisExpression.h"
#include "../ets_frontend/es2panda/ir/module/exportDefaultDeclaration.h"
#include "../ets_frontend/es2panda/ir/module/exportNamedDeclaration.h"
#include "../ets_frontend/es2panda/ir/statements/blockStatement.h"
#include "../ets_frontend/es2panda/ir/statements/classDeclaration.h"
#include "../ets_frontend/es2panda/ir/statements/doWhileStatement.h"
#include "../ets_frontend/es2panda/ir/statements/expressionStatement.h"
#include "../ets_frontend/es2panda/ir/statements/forInStatement.h"
#include "../ets_frontend/es2panda/ir/statements/forOfStatement.h"
#include "../ets_frontend/es2panda/ir/statements/forUpdateStatement.h"
#include "../ets_frontend/es2panda/ir/statements/functionDeclaration.h"
#include "../ets_frontend/es2panda/ir/statements/returnStatement.h"
#include "../ets_frontend/es2panda/ir/statements/switchStatement.h"
#include "../ets_frontend/es2panda/ir/statements/variableDeclaration.h"
#include "../ets_frontend/es2panda/ir/statements/variableDeclarator.h"
#include "../ets_frontend/es2panda/ir/statements/whileStatement.h"
#include "../ets_frontend/es2panda/ir/ts/tsConstructorType.h"
#include "../ets_frontend/es2panda/ir/ts/tsEnumDeclaration.h"
#include "../ets_frontend/es2panda/ir/ts/tsEnumMember.h"
#include "../ets_frontend/es2panda/ir/ts/tsFunctionType.h"
#include "../ets_frontend/es2panda/ir/ts/tsImportEqualsDeclaration.h"
#include "../ets_frontend/es2panda/ir/ts/tsInterfaceDeclaration.h"
#include "../ets_frontend/es2panda/ir/ts/tsMethodSignature.h"
#include "../ets_frontend/es2panda/ir/ts/tsModuleBlock.h"
#include "../ets_frontend/es2panda/ir/ts/tsModuleDeclaration.h"
#include "../ets_frontend/es2panda/ir/ts/tsParameterProperty.h"
#include "../ets_frontend/es2panda/ir/ts/tsPrivateIdentifier.h"
#include "../ets_frontend/es2panda/ir/ts/tsQualifiedName.h"
#include "../ets_frontend/es2panda/ir/ts/tsSignatureDeclaration.h"
#include "../ets_frontend/es2panda/ir/ts/tsTypeParameterDeclaration.h"

#include "../ets_frontend/es2panda/parser/parserImpl.h"

#include "intrinsicid2name.h"


panda::es2panda::lexer::TokenType BinIntrinsicIdToToken(panda::compiler::RuntimeInterface::IntrinsicId id){

    switch (id) {
        case panda::compiler::RuntimeInterface::IntrinsicId::AND2_IMM8_V8:
            return panda::es2panda::lexer::TokenType::PUNCTUATOR_BITWISE_AND;
        case panda::compiler::RuntimeInterface::IntrinsicId::OR2_IMM8_V8:
            return panda::es2panda::lexer::TokenType::PUNCTUATOR_BITWISE_OR;
        case panda::compiler::RuntimeInterface::IntrinsicId::MUL2_IMM8_V8:
            return panda::es2panda::lexer::TokenType::PUNCTUATOR_MULTIPLY;
        case panda::compiler::RuntimeInterface::IntrinsicId::DIV2_IMM8_V8:
            return panda::es2panda::lexer::TokenType::PUNCTUATOR_DIVIDE;
        case panda::compiler::RuntimeInterface::IntrinsicId::SUB2_IMM8_V8:
            return panda::es2panda::lexer::TokenType::PUNCTUATOR_MINUS;
        case panda::compiler::RuntimeInterface::IntrinsicId::NOT_IMM8:
            return panda::es2panda::lexer::TokenType::PUNCTUATOR_TILDE;
        case panda::compiler::RuntimeInterface::IntrinsicId::SHL2_IMM8_V8:
            return panda::es2panda::lexer::TokenType::PUNCTUATOR_LEFT_SHIFT;
        case panda::compiler::RuntimeInterface::IntrinsicId::ASHR2_IMM8_V8:
            return panda::es2panda::lexer::TokenType::PUNCTUATOR_RIGHT_SHIFT;
        case panda::compiler::RuntimeInterface::IntrinsicId::LESSEQ_IMM8_V8:
            return panda::es2panda::lexer::TokenType::PUNCTUATOR_LESS_THAN_EQUAL;
        case panda::compiler::RuntimeInterface::IntrinsicId::GREATEREQ_IMM8_V8:
            return panda::es2panda::lexer::TokenType::PUNCTUATOR_GREATER_THAN_EQUAL;
        case panda::compiler::RuntimeInterface::IntrinsicId::MOD2_IMM8_V8:
            return panda::es2panda::lexer::TokenType::PUNCTUATOR_MOD;
        case panda::compiler::RuntimeInterface::IntrinsicId::XOR2_IMM8_V8:
            return panda::es2panda::lexer::TokenType::PUNCTUATOR_BITWISE_XOR;

        case panda::compiler::RuntimeInterface::IntrinsicId::EXP_IMM8_V8:
            return panda::es2panda::lexer::TokenType::PUNCTUATOR_EXPONENTIATION;

        case panda::compiler::RuntimeInterface::IntrinsicId::SHR2_IMM8_V8:
            return panda::es2panda::lexer::TokenType::PUNCTUATOR_UNSIGNED_RIGHT_SHIFT;

        case panda::compiler::RuntimeInterface::IntrinsicId::ADD2_IMM8_V8:
            return panda::es2panda::lexer::TokenType::PUNCTUATOR_PLUS;

        /////////////////////////
        
        case panda::compiler::RuntimeInterface::IntrinsicId::LESS_IMM8_V8:
            return panda::es2panda::lexer::TokenType::PUNCTUATOR_LESS_THAN;

        case panda::compiler::RuntimeInterface::IntrinsicId::GREATER_IMM8_V8:
            return panda::es2panda::lexer::TokenType::PUNCTUATOR_GREATER_THAN;

        case panda::compiler::RuntimeInterface::IntrinsicId::EQ_IMM8_V8:
            return panda::es2panda::lexer::TokenType::PUNCTUATOR_EQUAL;

        case panda::compiler::RuntimeInterface::IntrinsicId::NOTEQ_IMM8_V8:
            return panda::es2panda::lexer::TokenType::PUNCTUATOR_NOT_EQUAL;

        case panda::compiler::RuntimeInterface::IntrinsicId::STRICTEQ_IMM8_V8:
            return panda::es2panda::lexer::TokenType::PUNCTUATOR_STRICT_EQUAL;

        case panda::compiler::RuntimeInterface::IntrinsicId::STRICTNOTEQ_IMM8_V8:
            return panda::es2panda::lexer::TokenType::PUNCTUATOR_NOT_STRICT_EQUAL;


        case panda::compiler::RuntimeInterface::IntrinsicId::INSTANCEOF_IMM8_V8: 
            return panda::es2panda::lexer::TokenType::KEYW_INSTANCEOF;
        case panda::compiler::RuntimeInterface::IntrinsicId::ISIN_IMM8_V8:
            return panda::es2panda::lexer::TokenType::KEYW_IN;
            
        default:
            std::cout << "S6" << std::endl;
            UNREACHABLE();
    }
}


panda::es2panda::lexer::TokenType UnaryPrefixIntrinsicIdToToken(panda::compiler::RuntimeInterface::IntrinsicId id){

    switch (id) {
        case panda::compiler::RuntimeInterface::IntrinsicId::NEG_IMM8:
            return panda::es2panda::lexer::TokenType::PUNCTUATOR_MINUS;
        case panda::compiler::RuntimeInterface::IntrinsicId::NOT_IMM8:
            return panda::es2panda::lexer::TokenType::PUNCTUATOR_TILDE;
        case panda::compiler::RuntimeInterface::IntrinsicId::TYPEOF_IMM8:
            return panda::es2panda::lexer::TokenType::KEYW_TYPEOF;
        case panda::compiler::RuntimeInterface::IntrinsicId::DELOBJPROP_V8:
            return panda::es2panda::lexer::TokenType::KEYW_DELETE;
        default:
            std::cout << "S7: " << GetIntrinsicOpcodeName(id) << std::endl;
            UNREACHABLE();
    }
}


panda::es2panda::lexer::TokenType IncDecIntrinsicIdToToken(panda::compiler::RuntimeInterface::IntrinsicId id){
    switch (id) {
        case panda::compiler::RuntimeInterface::IntrinsicId::DEC_IMM8:
            return panda::es2panda::lexer::TokenType::PUNCTUATOR_MINUS;

        case panda::compiler::RuntimeInterface::IntrinsicId::INC_IMM8:
            return panda::es2panda::lexer::TokenType::PUNCTUATOR_PLUS;
        default:
            std::cout << "S8" << std::endl;
            UNREACHABLE();

    }
}
```

`lca.cpp`:

```cpp
#include "lca.h"


LCAFinder::LCAFinder(panda::compiler::Graph* graph) : graph(graph) {
        initialize();
}

panda::compiler::BasicBlock* LCAFinder::findLCA(panda::compiler::BasicBlock* u, panda::compiler::BasicBlock* v) {
    std::unordered_set<panda::compiler::BasicBlock*> commonAncestors;
    const auto& ancestorsU = ancestors[u];
    const auto& ancestorsV = ancestors[v];

    for (auto ancestor : ancestorsU) {
        if (ancestorsV.count(ancestor)) {
            commonAncestors.insert(ancestor);
        }
    }

    panda::compiler::BasicBlock* lca = nullptr;
    int maxDepth = -1;
    for (auto ancestor : commonAncestors) {
        int depth = ancestors[ancestor].size();
        if (depth > maxDepth) {
            maxDepth = depth;
            lca = ancestor;
        }
    }
    return lca;
}

void LCAFinder::initialize() {
    for (auto node : graph->GetBlocksRPO()) {
        std::unordered_set<panda::compiler::BasicBlock*> nodeAncestors;
        for (auto parent : node->GetPredsBlocks()) {
            nodeAncestors.insert(parent);
            nodeAncestors.insert(ancestors[parent].begin(), ancestors[parent].end());
        }
        ancestors[node] = nodeAncestors;
    }
}
```

`lca.h`:

```h
#include "ast.h"

class LCAFinder {
public:
    LCAFinder(panda::compiler::Graph* graph);
    panda::compiler::BasicBlock* findLCA(panda::compiler::BasicBlock* u, panda::compiler::BasicBlock* v);

private:
    panda::compiler::Graph* graph;
    std::unordered_map<panda::compiler::BasicBlock*, std::unordered_set<panda::compiler::BasicBlock*>> ancestors;

    void initialize();
};
```

`lexicalenv.cpp`:

```cpp
#include "lexicalenv.h"
#include <algorithm>
#include <utility>


LexicalEnv::LexicalEnv(size_t capacity) 
    : expressions_(capacity, nullptr), capacity_(capacity) {
}

bool LexicalEnv::IsFull() {
    for (size_t i = 0; i < capacity_; ++i) {
        if(expressions_[i] == nullptr){
            return false;
        }
    }
    return true;
}

LexicalEnv::LexicalEnv(const LexicalEnv& other) 
    : expressions_(other.capacity_), capacity_(other.capacity_) {
    
    for (size_t i = 0; i < capacity_; ++i) {
        std::cout << "aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa" << std::endl;
        if(other.expressions_[i] == nullptr){
            std::cout << "null" << std::endl;
        }else{
            std::cout << "not null" << std::endl;
            expressions_[i] = new std::string(*(other.expressions_[i]));
        }
        
        std::cout << "bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb" << std::endl;
    }
}

LexicalEnv& LexicalEnv::operator=(const LexicalEnv& other) {
    std::cout << "+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++" << std::endl;
    if (this != &other) {
        expressions_.clear();
        capacity_ = other.capacity_;
        expressions_.resize(capacity_);
        
        for (size_t i = 0; i < capacity_; ++i) {
            expressions_[i] = new std::string(*other.expressions_[i]);
        }
    }
    return *this;
}

LexicalEnv::LexicalEnv(LexicalEnv&& other) noexcept 
    : expressions_(std::move(other.expressions_)), 
      capacity_(other.capacity_) {
    
    other.capacity_ = 0;
}

LexicalEnv& LexicalEnv::operator=(LexicalEnv&& other) noexcept {
    if (this != &other) {
        expressions_ = std::move(other.expressions_);
        capacity_ = other.capacity_;
        other.capacity_ = 0;
    }
    return *this;
}

std::string*& LexicalEnv::operator[](size_t index) {
    checkIndex(index);
    return expressions_[index];
}

const std::string* LexicalEnv::operator[](size_t index) const {
    checkIndex(index);
    return expressions_[index];
}

std::string* LexicalEnv::get(size_t index) const {
    checkIndex(index);
    return expressions_[index];
}

void LexicalEnv::set(size_t index, std::string* expr) {
    checkIndex(index);
    expressions_[index] = expr;
}

size_t LexicalEnv::capacity() const {
    return capacity_;
}

size_t LexicalEnv::size() const {
    return capacity_;
}


bool LexicalEnv::isValidIndex(size_t index) const {
    return index < capacity_;
}

void LexicalEnv::checkIndex(size_t index) const {
    if (index >= capacity_) {
        throw std::out_of_range("LexicalEnv index out of range");
    }
}

LexicalEnvStack::LexicalEnvStack() {
}

LexicalEnvStack::LexicalEnvStack(const LexicalEnvStack& other) 
    : stack_(other.stack_) {
}

LexicalEnvStack& LexicalEnvStack::operator=(const LexicalEnvStack& other) {
    if (this != &other) {
        stack_ = other.stack_;
    }
    return *this;
}

LexicalEnvStack::LexicalEnvStack(LexicalEnvStack&& other) noexcept 
    : stack_(std::move(other.stack_)) {
}

LexicalEnvStack& LexicalEnvStack::operator=(LexicalEnvStack&& other) noexcept {
    if (this != &other) {
        stack_ = std::move(other.stack_);
    }
    return *this;
}

LexicalEnvStack::~LexicalEnvStack() {
}

LexicalEnv* LexicalEnvStack::push(size_t capacity) {
    stack_.emplace_back(capacity);
    return &stack_.back();
}

void LexicalEnvStack::pop() {
    if (stack_.empty()) {
        throw std::runtime_error("Cannot pop from empty stack");
    }
    stack_.pop_back();
}

size_t LexicalEnvStack::size() const {
    return stack_.size();
}

bool LexicalEnvStack::empty() const {
    return stack_.empty();
}

std::string* LexicalEnvStack::get(size_t A, size_t B) const {
    checkIndex(A, B);
    
    size_t actualIndex = stack_.size() - 1 - A;
    return stack_[actualIndex].get(B);
}

void LexicalEnvStack::set(size_t A, size_t B, std::string* expr) {
    checkIndex(A, B);
    
    size_t actualIndex = stack_.size() - 1 - A;
    stack_[actualIndex].set(B, expr);
}

const LexicalEnv& LexicalEnvStack::getLexicalEnv(size_t A) const {
    checkStackIndex(A);
    
    size_t actualIndex = stack_.size() - 1 - A;
    return stack_[actualIndex];
}

LexicalEnv& LexicalEnvStack::getLexicalEnv(size_t A) {
    checkStackIndex(A);
    
    size_t actualIndex = stack_.size() - 1 - A;
    return stack_[actualIndex];
}

const LexicalEnv& LexicalEnvStack::top() const {
    if (stack_.empty()) {
        throw std::runtime_error("Stack is empty");
    }
    return stack_.back();
}

LexicalEnv& LexicalEnvStack::top() {
    if (stack_.empty()) {
        throw std::runtime_error("Stack is empty");
    }
    return stack_.back();
}

void LexicalEnvStack::clear() {
    stack_.clear();
}

void LexicalEnvStack::checkIndex(size_t A, size_t B) const {
    checkStackIndex(A);
    
    size_t actualIndex = stack_.size() - 1 - A;
    if (!stack_[actualIndex].isValidIndex(B)) {
        throw std::out_of_range("LexicalEnv index B out of range");
    }
}

void LexicalEnvStack::checkStackIndex(size_t A) const {
    if (stack_.empty()) {
        throw std::runtime_error("Stack is empty");
    }
    
    if (A >= stack_.size()) {
        throw std::out_of_range("Stack index A out of range");
    }
}
```

`lexicalenv.h`:

```h
#ifndef LEXICAL_ENV_STACK_H
#define LEXICAL_ENV_STACK_H

#include <vector>
#include <memory>
#include <stdexcept>
#include "ast.h"


class LexicalEnv {
private:
    std::vector<std::string*> expressions_;
    size_t capacity_;

public:
    explicit LexicalEnv(size_t capacity = 256);
    
    LexicalEnv(const LexicalEnv& other);
    
    LexicalEnv& operator=(const LexicalEnv& other);
    
    LexicalEnv(LexicalEnv&& other) noexcept;
    
    LexicalEnv& operator=(LexicalEnv&& other) noexcept;
    
    std::string *& operator[](size_t index);
    const std::string* operator[](size_t index) const;
    
    bool IsFull();
    std::string* get(size_t index) const;
    void set(size_t index, std::string* expr);
    
    size_t capacity() const;
    size_t size() const;
    
    bool isValidIndex(size_t index) const;

private:
    void checkIndex(size_t index) const;
};


class LexicalEnvStack {
private:
    std::vector<LexicalEnv> stack_;

public:
    LexicalEnvStack();
    LexicalEnvStack(const LexicalEnvStack& other);
    
    LexicalEnvStack& operator=(const LexicalEnvStack& other);
    
    LexicalEnvStack(LexicalEnvStack&& other) noexcept;
    
    LexicalEnvStack& operator=(LexicalEnvStack&& other) noexcept;
    
    ~LexicalEnvStack();
    LexicalEnv* push(size_t capacity);
    
    void pop();
    
    size_t size() const;
    
    bool empty() const;
    
    std::string* get(size_t A, size_t B) const;
    void set(size_t A, size_t B, std::string* expr);
    
    const LexicalEnv& getLexicalEnv(size_t A) const;
    LexicalEnv& getLexicalEnv(size_t A);
    
    const LexicalEnv& top() const;
    
    LexicalEnv& top();
    void clear();

private:
    void checkIndex(size_t A, size_t B) const;
    void checkStackIndex(size_t A) const;
};

#endif // LEXICAL_ENV_STACK_H
```

`patches/arkcompiler_runtime_core_a94c360.patch`:

```patch
diff --git a/BUILD.gn b/BUILD.gn
index dfffd707e..8099f59ea 100755
--- a/BUILD.gn
+++ b/BUILD.gn
@@ -120,6 +120,7 @@ if (!ark_standalone_build) {
 # Common config for ark source
 config("ark_config") {
   visibility = [
+    "*",
     "./*",
     "//arkcompiler/ets_frontend/*",
   ]
@@ -364,6 +365,14 @@ group("ark_host_mac_defectscanaux_unittest") {
   }
 }
 
+group("xabc") {
+  testonly = true
+  deps = [
+    "//arkdecompiler:xabc",
+  ]
+}
+
+
 group("runtime_core_host_unittest") {
   testonly = true
   deps = [
diff --git a/disassembler/disassembler.h b/disassembler/disassembler.h
index e96089bdb..baee93007 100644
--- a/disassembler/disassembler.h
+++ b/disassembler/disassembler.h
@@ -87,7 +87,7 @@ public:
     std::vector<size_t> GetColumnNumber();
     std::vector<size_t> GetLineNumber();
 
-private:
+public:
     void GetLiteralArrays();
     void FillLiteralArrayTable(panda_file::File::EntityId &id, size_t index);
     void FillLiteralData(pandasm::LiteralArray *lit_array, const panda_file::LiteralDataAccessor::LiteralValue &value,
@@ -234,7 +234,7 @@ private:
     bool skip_strings_;
     std::unordered_set<uint32_t> module_literals_;
     std::unordered_set<uint32_t> module_request_phase_literals_;
-#include "disasm_plugins.inc"
+//#include "disasm_plugins.inc"
 };
 }  // namespace panda::disasm
 

```

`patches/third_party_protobuf_0e4c27.patch`:

```patch
diff --git a/BUILD.gn b/BUILD.gn
index 212ac82..6864bc1 100644
--- a/BUILD.gn
+++ b/BUILD.gn
@@ -11,7 +11,8 @@
 # See the License for the specific language governing permissions and
 # limitations under the License.
 
-import("//build/ohos.gni")
+import("//arkcompiler/runtime_core/gn/build/ohos.gni")
+
 
 THIRDPARTY_PROTOBUF_SUBSYS_NAME = "thirdparty"
 THIRDPARTY_PROTOBUF_PART_NAME = "protobuf"
@@ -50,9 +51,9 @@ ohos_shared_library("protobuf_lite") {
     "src/google/protobuf/stubs/time.cc",
     "src/google/protobuf/wire_format_lite.cc",
   ]
-  if (!is_asan && !is_debug) {
-    version_script = "libprotobuf_lite.map"
-  }
+  #if (!is_asan && !is_debug) {
+  #  version_script = "libprotobuf_lite.map"
+  #}
   include_dirs = [
     "src/google/protobuf/**/*.h",
     "src/google/protobuf/**/*.inc",
@@ -74,10 +75,10 @@ ohos_shared_library("protobuf_lite") {
 
   public_configs = [ ":protobuf_config" ]
   install_enable = true
-  innerapi_tags = [
-    "platformsdk_indirect",
-    "chipsetsdk",
-  ]
+  #innerapi_tags = [
+  #  "platformsdk_indirect",
+  #  "chipsetsdk",
+  #]
   subsystem_name = "${THIRDPARTY_PROTOBUF_SUBSYS_NAME}"
   part_name = "${THIRDPARTY_PROTOBUF_PART_NAME}"
 }
@@ -121,7 +122,7 @@ ohos_static_library("protobuf_lite_static") {
     if (default_toolchain == current_toolchain) {
       # target build, not host build
       defines = [ "HAVE_HILOG" ]
-      external_deps = [ "hilog:libhilog" ]
+      #external_deps = [ "hilog:libhilog" ]
     }
   } else {
     defines = [ "_FILE_OFFSET_BITS_SET_LSEEK" ]
@@ -142,7 +143,7 @@ ohos_static_library("protobuf_lite_static") {
   }
   public_configs = [ ":protobuf_config" ]
   subsystem_name = "${THIRDPARTY_PROTOBUF_SUBSYS_NAME}"
-  part_name = "${THIRDPARTY_PROTOBUF_PART_NAME}"
+  #part_name = "${THIRDPARTY_PROTOBUF_PART_NAME}"
 }
 
 ohos_shared_library("protobuf") {
@@ -216,9 +217,9 @@ ohos_shared_library("protobuf") {
   ]
 
   deps = [ ":protobuf_lite" ]
-  if (!is_asan && !is_debug) {
-    version_script = "libprotobuf.map"
-  }
+  #if (!is_asan && !is_debug) {
+  #  version_script = "libprotobuf.map"
+  #}
 
   public_configs = [ ":protobuf_config" ]
   install_enable = true
@@ -300,7 +301,7 @@ ohos_static_library("protobuf_static") {
 
   public_configs = [ ":protobuf_config" ]
   subsystem_name = "${THIRDPARTY_PROTOBUF_SUBSYS_NAME}"
-  part_name = "${THIRDPARTY_PROTOBUF_PART_NAME}"
+  #part_name = "${THIRDPARTY_PROTOBUF_PART_NAME}"
 }
 
 if (current_toolchain == host_toolchain) {
@@ -525,7 +526,7 @@ if (current_toolchain == host_toolchain) {
 
     public_configs = [ ":protobuf_config" ]
     subsystem_name = "${THIRDPARTY_PROTOBUF_SUBSYS_NAME}"
-    part_name = "${THIRDPARTY_PROTOBUF_PART_NAME}"
+    #part_name = "${THIRDPARTY_PROTOBUF_PART_NAME}"
   }
 }
 
@@ -549,6 +550,6 @@ if (current_toolchain == host_toolchain) {
       "-Wno-deprecated-declarations",
     ]
     subsystem_name = "${THIRDPARTY_PROTOBUF_SUBSYS_NAME}"
-    part_name = "${THIRDPARTY_PROTOBUF_PART_NAME}"
+    #part_name = "${THIRDPARTY_PROTOBUF_PART_NAME}"
   }
 }

```

`run.sh`:

```sh
#!/bin/bash
logdir=logs 
./genlogs.sh $logdir

ninja -w dupbuild=warn xabc -C out 
LD_LIBRARY_PATH=./out/arkcompiler/runtime_core:./out/thirdparty/zlib  ./out/arkcompiler/common/xabc
python3 scripts/removebc.py
```

`scripts/intrinsic_list.txt`:

```txt
LDUNDEFINED
LDNULL
LDTRUE
LDFALSE
CREATEEMPTYOBJECT
CREATEEMPTYARRAY_IMM8
CREATEARRAYWITHBUFFER_IMM8_ID16
CREATEOBJECTWITHBUFFER_IMM8_ID16
NEWOBJRANGE_IMM8_IMM8_V8
NEWLEXENV_IMM8
ADD2_IMM8_V8
SUB2_IMM8_V8
MUL2_IMM8_V8
DIV2_IMM8_V8
MOD2_IMM8_V8
EQ_IMM8_V8
NOTEQ_IMM8_V8
LESS_IMM8_V8
LESSEQ_IMM8_V8
GREATER_IMM8_V8
GREATEREQ_IMM8_V8
SHL2_IMM8_V8
SHR2_IMM8_V8
ASHR2_IMM8_V8
AND2_IMM8_V8
OR2_IMM8_V8
XOR2_IMM8_V8
EXP_IMM8_V8
TYPEOF_IMM8
TONUMBER_IMM8
TONUMERIC_IMM8
NEG_IMM8
NOT_IMM8
INC_IMM8
DEC_IMM8
ISTRUE
ISFALSE
ISIN_IMM8_V8
INSTANCEOF_IMM8_V8
STRICTNOTEQ_IMM8_V8
STRICTEQ_IMM8_V8
CALLARG0_IMM8
CALLARG1_IMM8_V8
CALLARGS2_IMM8_V8_V8
CALLARGS3_IMM8_V8_V8_V8
CALLTHIS0_IMM8_V8
CALLTHIS1_IMM8_V8_V8
CALLTHIS2_IMM8_V8_V8_V8
CALLTHIS3_IMM8_V8_V8_V8_V8
CALLTHISRANGE_IMM8_IMM8_V8
SUPERCALLTHISRANGE_IMM8_IMM8_V8
DEFINEFUNC_IMM8_ID16_IMM8
DEFINEMETHOD_IMM8_ID16_IMM8
DEFINECLASSWITHBUFFER_IMM8_ID16_ID16_IMM16_V8
GETNEXTPROPNAME_V8
LDOBJBYVALUE_IMM8_V8
STOBJBYVALUE_IMM8_V8_V8
LDSUPERBYVALUE_IMM8_V8
LDOBJBYINDEX_IMM8_IMM16
STOBJBYINDEX_IMM8_V8_IMM16
LDLEXVAR_IMM4_IMM4
STLEXVAR_IMM4_IMM4
LDA_STR_ID16
TRYLDGLOBALBYNAME_IMM8_ID16
TRYSTGLOBALBYNAME_IMM8_ID16
LDGLOBALVAR_IMM16_ID16
LDOBJBYNAME_IMM8_ID16
STOBJBYNAME_IMM8_ID16_V8
MOV_V4_V4
MOV_V8_V8
LDSUPERBYNAME_IMM8_ID16
STCONSTTOGLOBALRECORD_IMM16_ID16
STTOGLOBALRECORD_IMM16_ID16
LDTHISBYNAME_IMM8_ID16
STTHISBYNAME_IMM8_ID16
LDTHISBYVALUE_IMM8
STTHISBYVALUE_IMM8_V8
JMP_IMM8
JMP_IMM16
JEQZ_IMM8
JEQZ_IMM16
JNEZ_IMM8
JSTRICTEQZ_IMM8
JNSTRICTEQZ_IMM8
JEQNULL_IMM8
JNENULL_IMM8
JSTRICTEQNULL_IMM8
JNSTRICTEQNULL_IMM8
JEQUNDEFINED_IMM8
JNEUNDEFINED_IMM8
JSTRICTEQUNDEFINED_IMM8
JNSTRICTEQUNDEFINED_IMM8
JEQ_V8_IMM8
JNE_V8_IMM8
JSTRICTEQ_V8_IMM8
JNSTRICTEQ_V8_IMM8
LDA_V8
STA_V8
LDAI_IMM32
FLDAI_IMM64
RETURN
RETURNUNDEFINED
GETPROPITERATOR
GETITERATOR_IMM8
CLOSEITERATOR_IMM8_V8
POPLEXENV
LDNAN
LDINFINITY
GETUNMAPPEDARGS
LDGLOBAL
LDNEWTARGET
LDTHIS
LDHOLE
CREATEREGEXPWITHLITERAL_IMM8_ID16_IMM8
CREATEREGEXPWITHLITERAL_IMM16_ID16_IMM8
CALLRANGE_IMM8_IMM8_V8
DEFINEFUNC_IMM16_ID16_IMM8
DEFINECLASSWITHBUFFER_IMM16_ID16_ID16_IMM16_V8
GETTEMPLATEOBJECT_IMM8
SETOBJECTWITHPROTO_IMM8_V8
STOWNBYVALUE_IMM8_V8_V8
STOWNBYINDEX_IMM8_V8_IMM16
STOWNBYNAME_IMM8_ID16_V8
GETMODULENAMESPACE_IMM8
STMODULEVAR_IMM8
LDLOCALMODULEVAR_IMM8
LDEXTERNALMODULEVAR_IMM8
STGLOBALVAR_IMM16_ID16
CREATEEMPTYARRAY_IMM16
CREATEARRAYWITHBUFFER_IMM16_ID16
CREATEOBJECTWITHBUFFER_IMM16_ID16
NEWOBJRANGE_IMM16_IMM8_V8
TYPEOF_IMM16
LDOBJBYVALUE_IMM16_V8
STOBJBYVALUE_IMM16_V8_V8
LDSUPERBYVALUE_IMM16_V8
LDOBJBYINDEX_IMM16_IMM16
STOBJBYINDEX_IMM16_V8_IMM16
LDLEXVAR_IMM8_IMM8
STLEXVAR_IMM8_IMM8
TRYLDGLOBALBYNAME_IMM16_ID16
TRYSTGLOBALBYNAME_IMM16_ID16
STOWNBYNAMEWITHNAMESET_IMM8_ID16_V8
MOV_V16_V16
LDOBJBYNAME_IMM16_ID16
STOBJBYNAME_IMM16_ID16_V8
LDSUPERBYNAME_IMM16_ID16
LDTHISBYNAME_IMM16_ID16
STTHISBYNAME_IMM16_ID16
LDTHISBYVALUE_IMM16
STTHISBYVALUE_IMM16_V8
ASYNCGENERATORREJECT_V8
JMP_IMM32
STOWNBYVALUEWITHNAMESET_IMM8_V8_V8
JEQZ_IMM32
JNEZ_IMM16
JNEZ_IMM32
JSTRICTEQZ_IMM16
JNSTRICTEQZ_IMM16
JEQNULL_IMM16
JNENULL_IMM16
JSTRICTEQNULL_IMM16
JNSTRICTEQNULL_IMM16
JEQUNDEFINED_IMM16
JNEUNDEFINED_IMM16
JSTRICTEQUNDEFINED_IMM16
JNSTRICTEQUNDEFINED_IMM16
JEQ_V8_IMM16
JNE_V8_IMM16
JSTRICTEQ_V8_IMM16
JNSTRICTEQ_V8_IMM16
GETITERATOR_IMM16
CLOSEITERATOR_IMM16_V8
LDSYMBOL
ASYNCFUNCTIONENTER
LDFUNCTION
DEBUGGER
CREATEGENERATOROBJ_V8
CREATEITERRESULTOBJ_V8_V8
CREATEOBJECTWITHEXCLUDEDKEYS_IMM8_V8_V8
NEWOBJAPPLY_IMM8_V8
NEWOBJAPPLY_IMM16_V8
NEWLEXENVWITHNAME_IMM8_ID16
CREATEASYNCGENERATOROBJ_V8
ASYNCGENERATORRESOLVE_V8_V8_V8
SUPERCALLSPREAD_IMM8_V8
APPLY_IMM8_V8_V8
SUPERCALLARROWRANGE_IMM8_IMM8_V8
DEFINEGETTERSETTERBYVALUE_V8_V8_V8_V8
DYNAMICIMPORT
DEFINEMETHOD_IMM16_ID16_IMM8
RESUMEGENERATOR
GETRESUMEMODE
GETTEMPLATEOBJECT_IMM16
DELOBJPROP_V8
SUSPENDGENERATOR_V8
ASYNCFUNCTIONAWAITUNCAUGHT_V8
COPYDATAPROPERTIES_V8
STARRAYSPREAD_V8_V8
SETOBJECTWITHPROTO_IMM16_V8
STOWNBYVALUE_IMM16_V8_V8
STSUPERBYVALUE_IMM8_V8_V8
STSUPERBYVALUE_IMM16_V8_V8
STOWNBYINDEX_IMM16_V8_IMM16
STOWNBYNAME_IMM16_ID16_V8
ASYNCFUNCTIONRESOLVE_V8
ASYNCFUNCTIONREJECT_V8
COPYRESTARGS_IMM8
STSUPERBYNAME_IMM8_ID16_V8
STSUPERBYNAME_IMM16_ID16_V8
STOWNBYVALUEWITHNAMESET_IMM16_V8_V8
LDBIGINT_ID16
STOWNBYNAMEWITHNAMESET_IMM16_ID16_V8
NOP
SETGENERATORSTATE_IMM8
GETASYNCITERATOR_IMM8
LDPRIVATEPROPERTY_IMM8_IMM16_IMM16
STPRIVATEPROPERTY_IMM8_IMM16_IMM16_V8
TESTIN_IMM8_IMM16_IMM16
DEFINEFIELDBYNAME_IMM8_ID16_V8
DEFINEPROPERTYBYNAME_IMM8_ID16_V8
CALLRUNTIME_NOTIFYCONCURRENTRESULT_PREF_NONE
WIDE_CREATEOBJECTWITHEXCLUDEDKEYS_PREF_IMM16_V8_V8
THROW_PREF_NONE
CALLRUNTIME_DEFINEFIELDBYVALUE_PREF_IMM8_V8_V8
WIDE_NEWOBJRANGE_PREF_IMM16_V8
THROW_NOTEXISTS_PREF_NONE
CALLRUNTIME_DEFINEFIELDBYINDEX_PREF_IMM8_IMM32_V8
WIDE_NEWLEXENV_PREF_IMM16
THROW_PATTERNNONCOERCIBLE_PREF_NONE
CALLRUNTIME_TOPROPERTYKEY_PREF_NONE
WIDE_NEWLEXENVWITHNAME_PREF_IMM16_ID16
THROW_DELETESUPERPROPERTY_PREF_NONE
CALLRUNTIME_CREATEPRIVATEPROPERTY_PREF_IMM16_ID16
WIDE_CALLRANGE_PREF_IMM16_V8
THROW_CONSTASSIGNMENT_PREF_V8
CALLRUNTIME_DEFINEPRIVATEPROPERTY_PREF_IMM8_IMM16_IMM16_V8
WIDE_CALLTHISRANGE_PREF_IMM16_V8
THROW_IFNOTOBJECT_PREF_V8
CALLRUNTIME_CALLINIT_PREF_IMM8_V8
WIDE_SUPERCALLTHISRANGE_PREF_IMM16_V8
THROW_UNDEFINEDIFHOLE_PREF_V8_V8
CALLRUNTIME_DEFINESENDABLECLASS_PREF_IMM16_ID16_ID16_IMM16_V8
WIDE_SUPERCALLARROWRANGE_PREF_IMM16_V8
THROW_IFSUPERNOTCORRECTCALL_PREF_IMM8
CALLRUNTIME_LDSENDABLECLASS_PREF_IMM16
WIDE_LDOBJBYINDEX_PREF_IMM32
THROW_IFSUPERNOTCORRECTCALL_PREF_IMM16
CALLRUNTIME_LDSENDABLEEXTERNALMODULEVAR_PREF_IMM8
WIDE_STOBJBYINDEX_PREF_V8_IMM32
THROW_UNDEFINEDIFHOLEWITHNAME_PREF_ID16
CALLRUNTIME_WIDELDSENDABLEEXTERNALMODULEVAR_PREF_IMM16
WIDE_STOWNBYINDEX_PREF_V8_IMM32
CALLRUNTIME_NEWSENDABLEENV_PREF_IMM8
WIDE_COPYRESTARGS_PREF_IMM16
CALLRUNTIME_WIDENEWSENDABLEENV_PREF_IMM16
WIDE_LDLEXVAR_PREF_IMM16_IMM16
CALLRUNTIME_STSENDABLEVAR_PREF_IMM4_IMM4
WIDE_STLEXVAR_PREF_IMM16_IMM16
CALLRUNTIME_STSENDABLEVAR_PREF_IMM8_IMM8
WIDE_GETMODULENAMESPACE_PREF_IMM16
CALLRUNTIME_WIDESTSENDABLEVAR_PREF_IMM16_IMM16
WIDE_STMODULEVAR_PREF_IMM16
CALLRUNTIME_LDSENDABLEVAR_PREF_IMM4_IMM4
WIDE_LDLOCALMODULEVAR_PREF_IMM16
CALLRUNTIME_LDSENDABLEVAR_PREF_IMM8_IMM8
WIDE_LDEXTERNALMODULEVAR_PREF_IMM16
CALLRUNTIME_WIDELDSENDABLEVAR_PREF_IMM16_IMM16
WIDE_LDPATCHVAR_PREF_IMM16
CALLRUNTIME_ISTRUE_PREF_IMM8
WIDE_STPATCHVAR_PREF_IMM16
CALLRUNTIME_ISFALSE_PREF_IMM8
CALLRUNTIME_LDLAZYMODULEVAR_PREF_IMM8
CALLRUNTIME_WIDELDLAZYMODULEVAR_PREF_IMM16
CALLRUNTIME_LDLAZYSENDABLEMODULEVAR_PREF_IMM8
CALLRUNTIME_WIDELDLAZYSENDABLEMODULEVAR_PREF_IMM16
CALLRUNTIME_SUPERCALLFORWARDALLARGS_PREF_V8
CALLRUNTIME_LDSENDABLELOCALMODULEVAR_PREF_IMM8
CALLRUNTIME_WIDELDSENDABLELOCALMODULEVAR_PREF_IMM16
DEPRECATED_LDLEXENV_PREF_NONE
DEPRECATED_POPLEXENV_PREF_NONE
DEPRECATED_GETITERATORNEXT_PREF_V8_V8
DEPRECATED_CREATEARRAYWITHBUFFER_PREF_IMM16
DEPRECATED_CREATEOBJECTWITHBUFFER_PREF_IMM16
DEPRECATED_TONUMBER_PREF_V8
DEPRECATED_TONUMERIC_PREF_V8
DEPRECATED_NEG_PREF_V8
DEPRECATED_NOT_PREF_V8
DEPRECATED_INC_PREF_V8
DEPRECATED_DEC_PREF_V8
DEPRECATED_CALLARG0_PREF_V8
DEPRECATED_CALLARG1_PREF_V8_V8
DEPRECATED_CALLARGS2_PREF_V8_V8_V8
DEPRECATED_CALLARGS3_PREF_V8_V8_V8_V8
DEPRECATED_CALLRANGE_PREF_IMM16_V8
DEPRECATED_CALLSPREAD_PREF_V8_V8_V8
DEPRECATED_CALLTHISRANGE_PREF_IMM16_V8
DEPRECATED_DEFINECLASSWITHBUFFER_PREF_ID16_IMM16_IMM16_V8_V8
DEPRECATED_RESUMEGENERATOR_PREF_V8
DEPRECATED_GETRESUMEMODE_PREF_V8
DEPRECATED_GETTEMPLATEOBJECT_PREF_V8
DEPRECATED_DELOBJPROP_PREF_V8_V8
DEPRECATED_SUSPENDGENERATOR_PREF_V8_V8
DEPRECATED_ASYNCFUNCTIONAWAITUNCAUGHT_PREF_V8_V8
DEPRECATED_COPYDATAPROPERTIES_PREF_V8_V8
DEPRECATED_SETOBJECTWITHPROTO_PREF_V8_V8
DEPRECATED_LDOBJBYVALUE_PREF_V8_V8
DEPRECATED_LDSUPERBYVALUE_PREF_V8_V8
DEPRECATED_LDOBJBYINDEX_PREF_V8_IMM32
DEPRECATED_ASYNCFUNCTIONRESOLVE_PREF_V8_V8_V8
DEPRECATED_ASYNCFUNCTIONREJECT_PREF_V8_V8_V8
DEPRECATED_STLEXVAR_PREF_IMM4_IMM4_V8
DEPRECATED_STLEXVAR_PREF_IMM8_IMM8_V8
DEPRECATED_STLEXVAR_PREF_IMM16_IMM16_V8
DEPRECATED_GETMODULENAMESPACE_PREF_ID32
DEPRECATED_STMODULEVAR_PREF_ID32
DEPRECATED_LDOBJBYNAME_PREF_ID32_V8
DEPRECATED_LDSUPERBYNAME_PREF_ID32_V8
DEPRECATED_LDMODULEVAR_PREF_ID32_IMM8
DEPRECATED_STCONSTTOGLOBALRECORD_PREF_ID32
DEPRECATED_STLETTOGLOBALRECORD_PREF_ID32
DEPRECATED_STCLASSTOGLOBALRECORD_PREF_ID32
DEPRECATED_LDHOMEOBJECT_PREF_NONE
DEPRECATED_CREATEOBJECTHAVINGMETHOD_PREF_IMM16
DEPRECATED_DYNAMICIMPORT_PREF_V8
DEPRECATED_ASYNCGENERATORREJECT_PREF_V8_V8

```

`scripts/pickintrinsics.py`:

```py
import re
import argparse
from collections import OrderedDict
import ipdb

def process_intrinsic_cases(input_file, output_file):
    with open(input_file, 'r') as file:
        content = file.read()

    # Regular expression to match case statements
    case_pattern = re.compile(r'case\s+BytecodeInstruction::Opcode::(\w+):')

    # Find all matches and store them in an OrderedDict to maintain order and ensure uniqueness
    matches = list(OrderedDict.fromkeys(case_pattern.findall(content)))

    # Separate matches into regular and deprecated
    regular_matches = [match for match in matches if not match.startswith('DEPRECATED')]
    deprecated_matches = [match for match in matches if match.startswith('DEPRECATED')]

    # Combine lists with regular matches first
    sorted_matches = regular_matches + deprecated_matches

    with open(output_file, 'w') as file:
        for match in sorted_matches:
            file.write(match + '\n')

if __name__ == "__main__":
    parser = argparse.ArgumentParser(
        description='Process compiler intrinsic case statements with default file paths',
        formatter_class=argparse.RawTextHelpFormatter)
    
    parser.add_argument('input', 
                        nargs='?', 
                        default='../out/gen/arkcompiler/runtime_core/compiler/generated/inst_builder_gen.cpp',
                        help='Input file path (default: %(default)s)')
    
    parser.add_argument('output', 
                        nargs='?', 
                        default='intrinsic_list.txt',
                        help='Output file path (default: %(default)s)')
    
    args = parser.parse_args()
    process_intrinsic_cases(args.input, args.output)


```

`scripts/picktokens.py`:

```py
import re
import argparse
from collections import OrderedDict
import ipdb

def process_intrinsic_cases(input_file, output_file):
    with open(input_file, 'r') as file:
        content = file.read()

    pattern = r'case\s+TokenType::(\w+):\s*return\s*"([^"]+)";'
    matches = re.findall(pattern, content)
 
    with open(output_file, 'w') as file:
        for match in matches:
            file.write(f"{match[0]}, {match[1]}\n")

if __name__ == "__main__":
    parser = argparse.ArgumentParser(
        description='Process compiler intrinsic case statements with default file paths',
        formatter_class=argparse.RawTextHelpFormatter)
    

    #es2panda/lexer/token/token.cpp
    parser.add_argument('input', 
                        nargs='?', 
                        default='../../arkcompiler/ets_frontend/es2panda/lexer/token/token.cpp',
                        help='Input file path (default: %(default)s)')
    
    parser.add_argument('output', 
                        nargs='?', 
                        default='tokens.txt',
                        help='Output file path (default: %(default)s)')
    
    args = parser.parse_args()
    process_intrinsic_cases(args.input, args.output)


```

`scripts/prepare.sh`:

```sh

# https://gitee.com/openharmony/docs/blob/master/zh-cn/device-dev/subsystems/subsys-arkcompiler-guide.md

intall_deps(){
    sudo apt-get update && sudo apt-get install python ruby python3-pip git-lfs gcc-multilib g++-multilib zlib1g-dev libc++1 curl nodejs
}

intall_repo(){
    mkdir ~/bin/
    curl https://gitee.com/oschina/repo/raw/fork_flow/repo-py3 > ~/bin/repo
    chmod a+x ~/bin/repo
    export PATH=~/bin:$PATH
    pip3 install -i https://pypi.tuna.tsinghua.edu.cn/simple requests
}

download_source(){

    repo init -u https://gitee.com/ark-standalone-build/manifest.git -b master
    repo sync -c -j8
    repo forall -c 'git lfs pull'

    ./prebuilts_download.sh
}

intall_deps
intall_repo
download_source

#python3 ark.py x64.release




```

`scripts/removebc.py`:

```py
import argparse
import os
import shutil

def remove_bc_data(input_file):
    temp_file = input_file + '.tmp'
    
    with open(input_file, 'r') as infile, open(temp_file, 'w') as outfile:
        for line in infile:
            bc_index = line.find('bc:')
            if bc_index != -1:
                line = line[:bc_index]
            line = line.rstrip() + '\n'
            outfile.write(line)
    
    shutil.move(temp_file, input_file)

def main():
    parser = argparse.ArgumentParser(description='Remove data after "bc:" in each line of a file and strip trailing whitespace.')
    parser.add_argument('-f', '--file', type=str, help='Input file name', default='logs/func_main_0:(any,any,any).ir')

    args = parser.parse_args()
    
    input_filename = args.file

    if not os.path.exists(input_filename):
        print(f"Error: The file '{input_filename}' does not exist.")
        return

    remove_bc_data(input_filename)
    print(f"Processing complete. Changes applied to '{input_filename}'.")

if __name__ == '__main__':
    main()

```

`scripts/tokens.txt`:

```txt
PUNCTUATOR_BITWISE_AND, &
PUNCTUATOR_BITWISE_OR, |
PUNCTUATOR_MULTIPLY, *
PUNCTUATOR_DIVIDE, /
PUNCTUATOR_MINUS, -
PUNCTUATOR_EXCLAMATION_MARK, !
PUNCTUATOR_TILDE, ~
PUNCTUATOR_MINUS_MINUS, --
PUNCTUATOR_LEFT_SHIFT, <<
PUNCTUATOR_RIGHT_SHIFT, >>
PUNCTUATOR_LESS_THAN_EQUAL, <=
PUNCTUATOR_GREATER_THAN_EQUAL, >=
PUNCTUATOR_MOD, %
PUNCTUATOR_BITWISE_XOR, ^
PUNCTUATOR_EXPONENTIATION, **
PUNCTUATOR_MULTIPLY_EQUAL, *=
PUNCTUATOR_EXPONENTIATION_EQUAL, **=
PUNCTUATOR_DIVIDE_EQUAL, /=
PUNCTUATOR_MOD_EQUAL, %=
PUNCTUATOR_MINUS_EQUAL, -=
PUNCTUATOR_LEFT_SHIFT_EQUAL, <<=
PUNCTUATOR_RIGHT_SHIFT_EQUAL, >>=
PUNCTUATOR_UNSIGNED_RIGHT_SHIFT, >>>
PUNCTUATOR_UNSIGNED_RIGHT_SHIFT_EQUAL, >>>=
PUNCTUATOR_BITWISE_AND_EQUAL, &=
PUNCTUATOR_BITWISE_OR_EQUAL, |=
PUNCTUATOR_LOGICAL_AND_EQUAL, &&=
PUNCTUATOR_NULLISH_COALESCING, ??
PUNCTUATOR_LOGICAL_OR_EQUAL, ||=
PUNCTUATOR_LOGICAL_NULLISH_EQUAL, \?\?=
PUNCTUATOR_BITWISE_XOR_EQUAL, ^=
PUNCTUATOR_PLUS, +
PUNCTUATOR_PLUS_PLUS, ++
PUNCTUATOR_PLUS_EQUAL, +=
PUNCTUATOR_LESS_THAN, <
PUNCTUATOR_GREATER_THAN, >
PUNCTUATOR_EQUAL, ==
PUNCTUATOR_NOT_EQUAL, !=
PUNCTUATOR_STRICT_EQUAL, ===
PUNCTUATOR_NOT_STRICT_EQUAL, !==
KEYW_INSTANCEOF, instanceof
KEYW_IN, in
PUNCTUATOR_LOGICAL_AND, &&
PUNCTUATOR_LOGICAL_OR, ||
PUNCTUATOR_SUBSTITUTION, =
PUNCTUATOR_QUESTION_MARK, ?
PUNCTUATOR_AT, @
KEYW_ANY, any
KEYW_UNKNOWN, unknown
KEYW_NEVER, never
KEYW_NUMBER, number
KEYW_BIGINT, bigint
KEYW_BOOLEAN, boolean
KEYW_STRING, string
KEYW_VOID, void
KEYW_OBJECT, object
KEYW_TYPEOF, typeof
KEYW_DELETE, delete
KEYW_OUT, out

```

`xabc.cpp`:

```cpp

#define PANDA_USE_FUTEX 1
#define PANDA_TARGET_UNIX 1

#include "bytecode_optimizer/ir_interface.h"
#include "bytecode_optimizer/runtime_adapter.h"

#include "libpandabase/mem/arena_allocator.h"
#include "libpandabase/mem/pool_manager.h"

#include "libpandafile/class_data_accessor.h"
#include "libpandafile/class_data_accessor-inl.h"
#include "libpandafile/method_data_accessor.h"

#include "libpandafile/file.h"

#include "compiler/optimizer/ir/graph.h"


#include "optimizer/ir/inst.h"
#include "optimizer/ir/runtime_interface.h"
#include "optimizer/ir_builder/ir_builder.h"
#include "optimize_bytecode.h"

#include "astgen.h"

#include "assembly-parser.h"
#include "assembler/assembly-parser.h"
#include "compiler/optimizer/ir/basicblock.h"

#include "mem/pool_manager.h"

#include "disassembler/disassembler.h"

#include "bytecodeopt_options.h"
#include "bytecode_analysis_results.h"

#include "compiler/optimizer/ir_builder/ir_builder.h"
#include "compiler/optimizer/optimizations/branch_elimination.h"
#include "compiler/optimizer/optimizations/cleanup.h"
#include "compiler/optimizer/optimizations/lowering.h"
#include "compiler/optimizer/optimizations/move_constants.h"
#include "compiler/optimizer/optimizations/regalloc/reg_alloc.h"
#include "compiler/optimizer/optimizations/vn.h"
#include "constant_propagation/constant_propagation.h"

#include "libpandabase/mem/pool_manager.h"
#include "libpandafile/class_data_accessor-inl.h"
#include "libpandafile/module_data_accessor-inl.h"
#include "reg_acc_alloc.h"
#include "reg_encoder.h"
#include "runtime_adapter.h"

#include <string>
#include <typeinfo>
#include "codegen.h"
#include "common.h"


#include "arkts.h"
#include "ast.h"

#include "lexicalenv.h"

using namespace std;
using namespace panda;
using namespace bytecodeopt;

std::string inputFileName = "demo.abc";
std::string outputFileName = "arkdemo.ts";
std::string outputAstFileName = "arkdemo.ast";

template <typename T>
constexpr void RunOpts(compiler::Graph *graph)
{
    graph->RunPass<compiler::Cleanup>();
    graph->RunPass<T>();
}

template <typename First, typename Second, typename... Rest>
constexpr void RunOpts(compiler::Graph *graph)
{
    RunOpts<First>(graph);
    RunOpts<Second, Rest...>(graph);
}


static void SetCompilerOptions()
{
    compiler::options.SetCompilerUseSafepoint(false);
    compiler::options.SetCompilerSupportInitObjectInst(true);
    if (!compiler::options.WasSetCompilerMaxBytecodeSize()) {
        compiler::options.SetCompilerMaxBytecodeSize(MAX_BYTECODE_SIZE);
    }
}

void BuildMapFromPcToIns(pandasm::Function &function, BytecodeOptIrInterface &ir_interface,
                         const compiler::Graph *graph, compiler::RuntimeInterface::MethodPtr method_ptr)
{
    CHECK_NOT_NULL(graph);
    function.local_variable_debug.clear();
    auto *pc_ins_map = ir_interface.GetPcInsMap();
    pc_ins_map->reserve(function.ins.size());
    auto instructions_buf = graph->GetRuntime()->GetMethodCode(method_ptr);
    compiler::BytecodeInstructions instructions(instructions_buf, graph->GetRuntime()->GetMethodCodeSize(method_ptr));
    compiler::BytecodeIterator insn_iter = instructions.begin();
    for (pandasm::Ins &ins : function.ins) {
        if (ins.opcode == pandasm::Opcode::INVALID) {
            continue;
        }
        pc_ins_map->emplace(instructions.GetPc(*insn_iter), &ins);
        ++insn_iter;
        if (insn_iter == instructions.end()) {
            break;
        }
    }
}

static bool SkipFunction(const pandasm::Function &function, const std::string &func_name)
{
    if (panda::bytecodeopt::options.WasSetMethodRegex()) {
        static std::regex rgx(panda::bytecodeopt::options.GetMethodRegex());
        if (!std::regex_match(func_name, rgx)) {
            LOG(INFO, BYTECODE_OPTIMIZER) << "Skip Function " << func_name << ": Function's name doesn't match regex";
            return true;
        }
    }

    if (panda::bytecodeopt::options.IsSkipMethodsWithEh() && !function.catch_blocks.empty()) {
        LOG(INFO, BYTECODE_OPTIMIZER) << "Was not optimized " << func_name << ": Function has catch blocks";
        return true;
    }

    if ((function.regs_num + function.GetParamsNum()) > compiler::VIRTUAL_FRAME_SIZE) {
        LOG(ERROR, BYTECODE_OPTIMIZER) << "Unable to optimize " << func_name
                                       << ": Function frame size is larger than allowed one";
        return true;
    }
    return false;
}

bool DecompileRunOptimizations(compiler::Graph *graph, BytecodeOptIrInterface *iface)
{
    std::cout <<  "@@@ 111111111111111111111111111111111111111111"  << std::endl;
    constexpr int OPT_LEVEL_0 = 0;
    if (panda::bytecodeopt::options.GetOptLevel() == OPT_LEVEL_0) {
        return false;
    }

    graph->RunPass<compiler::Cleanup>();
    ASSERT(graph->IsDynamicMethod());
    std::cout <<  "@@@ 22222222222222222222222222222222222222222"  << std::endl;
    if (compiler::options.IsCompilerBranchElimination()) {
       graph->RunPass<ConstantPropagation>(iface);
       RunOpts<compiler::BranchElimination>(graph);
    }
    
    RunOpts<compiler::ValNum, compiler::Lowering, compiler::MoveConstants>(graph);
    std::cout <<  "@@@ 33333333333333333333333333333333333333333"  << std::endl;

    graph->RunPass<compiler::Cleanup>();
    graph->RunPass<RegAccAlloc>();

    graph->RunPass<compiler::Cleanup>();
    if (!RegAlloc(graph)) {
        LOG(ERROR, BYTECODE_OPTIMIZER) << "Failed compiler::RegAlloc";
        return false;
    }
    std::cout <<  "@@@ 444444444444444444444444444444444444444444"  << std::endl;
    graph->RunPass<compiler::Cleanup>();
    if (!graph->RunPass<RegEncoder>()) {
        LOG(ERROR, BYTECODE_OPTIMIZER) << "Failed RegEncoder";
        return false;
    }
    std::cout <<  "@@@ 55555555555555555555555555555555555555555"  << std::endl;
    return true;
}

std::string extractTrueFunName(const std::string& input) {
    size_t start = input.find("#*#");
    if (start == std::string::npos) {
        return input; 
    }

    size_t colon = input.find(":", start);
    if (colon == std::string::npos) {
        return input; 
    }

    return input.substr(start + 3, colon - (start + 3));
}

bool DecompileFunction(pandasm::Program *prog, panda::es2panda::parser::Program *parser_program, 
                        const pandasm::AsmEmitter::PandaFileToPandaAsmMaps *maps,
                        const panda_file::MethodDataAccessor &mda, bool is_dynamic,
                        std::map<uint32_t, LexicalEnvStack*>* method2lexicalenvstack)
{

    ArenaAllocator allocator {SpaceType::SPACE_TYPE_COMPILER};
    ArenaAllocator local_allocator {SpaceType::SPACE_TYPE_COMPILER, nullptr, true};

    SetCompilerOptions();

    auto ir_interface = BytecodeOptIrInterface(maps, prog);

    auto func_name = ir_interface.GetMethodIdByOffset(mda.GetMethodId().GetOffset() );
    std::cout << ">>>>>>>>>>>>>>>>>>>>>>>>>>>> "  << func_name << " <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<" << std::endl;
    [[maybe_unused]] auto it = prog->function_table.find(func_name);
    if (it == prog->function_table.end()) {
        LOG(ERROR, BYTECODE_OPTIMIZER) << "Cannot find function: " << func_name;
        return false;
    }

    LOG(INFO, BYTECODE_OPTIMIZER) << "Optimizing function: " << func_name;

    auto method_ptr = reinterpret_cast<compiler::RuntimeInterface::MethodPtr>(mda.GetMethodId().GetOffset());
    
    panda::BytecodeOptimizerRuntimeAdapter adapter(mda.GetPandaFile());
    auto graph = allocator.New<compiler::Graph>(&allocator, &local_allocator, Arch::NONE, method_ptr, &adapter, false,
                                                nullptr, is_dynamic, true);
    
    if(graph->GetParentGraph() != nullptr){
        std::cout << "################################################################################################# parent graph exist !!!" << std::endl;
    }else{
        std::cout << "################################################################################################# parent graph is null !!!" << std::endl;
    }

    panda::pandasm::Function &function = it->second;

    if (SkipFunction(function, func_name)) {
        return false;
    }

    // build map from pc to pandasm::ins (to re-build line-number info in BytecodeGen)
    BuildMapFromPcToIns(function, ir_interface, graph, method_ptr);
    
    if ((graph == nullptr) || !graph->RunPass<panda::compiler::IrBuilder>()) {
        LOG(ERROR, BYTECODE_OPTIMIZER) << "Optimizing " << func_name << ": IR builder failed!";
        std::cout << "Optimizing " << func_name << ": IR builder failed!" << std::endl;
        return false;
    }

    if (graph->HasIrreducibleLoop()) {
        LOG(ERROR, BYTECODE_OPTIMIZER) << "Optimizing " << func_name << ": Graph has irreducible loop!";
        std::cout << "Optimizing " << func_name << ": Graph has irreducible loop!" << std::endl;
        return false;
    }

    if (!DecompileRunOptimizations(graph, &ir_interface)) {
        LOG(ERROR, BYTECODE_OPTIMIZER) << "Optimizing " << func_name << ": Running optimizations failed!";
        std::cout << "Optimizing " << func_name << ": Running optimizations failed!" << std::endl;
        return false;
    }
    
    std::ofstream dump_out("logs/" + func_name+ ".ir");
    graph->Dump(&dump_out);

    

    if (!graph->RunPass<AstGen>(&function, &ir_interface, prog, parser_program, mda.GetMethodId().GetOffset(), method2lexicalenvstack, extractTrueFunName(func_name))) {
        LOG(ERROR, BYTECODE_OPTIMIZER) << "Optimizing " << func_name << ": Code generation failed!";

        std::cout << "Decompiling " << func_name << ": Code generation failed!" << std::endl;

        return false;
    }

    std::cout << "Decompiled: " << func_name << std::endl;

    return true;
}

void LogAst(panda::es2panda::parser::Program *parser_program, std::string outputFileName){
    std::cout << "[+] log raw ast start >>>>>>>>>>>>>>>>>>>>>>>>>>>" << std::endl;
    std::string res = parser_program->Dump();
    //std::cout << res << std::endl;
    std::cout << "+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++" << std::endl;
    std::ofstream outputFile(outputFileName);
    if (!outputFile.is_open()) {
        std::cerr << "can't open output file: " << outputFileName << std::endl;
    }else{
        outputFile << res;
        outputFile.close();
    }
    std::cout << "[-] log raw ast end >>>>>>>>>>>>>>>>>>>>>>>>>>>" << std::endl;
}

void LogArkTS2File(panda::es2panda::parser::Program *parser_program, std::string outputFileName){
    std::cout << "[+] log arkTS  start >>>>>>>>>>>>>>>>>>>>>>>>>>>" << std::endl;
    auto astsgen = panda::es2panda::ir::ArkTSGen(parser_program->Ast());
    

    std::cout << astsgen.Str() << std::endl;
    std::cout << "+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++" << std::endl;
    std::ofstream outputFile(outputFileName);
    if (!outputFile.is_open()) {
        std::cerr << "can't open output file: " << outputFileName << std::endl;
    }else{
        outputFile << astsgen.Str();
        outputFile.close();
    }
    std::cout << "[-] log arkTS  end >>>>>>>>>>>>>>>>>>>>>>>>>>>" << std::endl;
}

bool DecompilePandaFile(pandasm::Program *prog, const pandasm::AsmEmitter::PandaFileToPandaAsmMaps *maps,
                       const std::string &pfile_name, bool is_dynamic)
{
    auto pfile = panda_file::OpenPandaFile(pfile_name);
    if (!pfile) {
        LOG(FATAL, BYTECODE_OPTIMIZER) << "Can not open binary file: " << pfile_name;
    }

    bool result = true;
    panda::es2panda::parser::Program *parser_program = new panda::es2panda::parser::Program(panda::es2panda::ScriptExtension::TS);
    
    ArenaVector<panda::es2panda::ir::Statement *> program_statements(parser_program->Allocator()->Adapter());
    auto program_ast = parser_program->Allocator()->New<panda::es2panda::ir::BlockStatement>(nullptr, std::move(program_statements));
    parser_program->SetAst(program_ast);

    std::map<uint32_t, LexicalEnvStack*> method2lexicalenvstack;

    for (uint32_t id : pfile->GetClasses()) {
        panda_file::File::EntityId record_id {id};

        if (pfile->IsExternal(record_id)) {
            continue;
        }

        panda_file::ClassDataAccessor cda {*pfile, record_id};

        int count = 0;

        cda.EnumerateMethods([&count, prog, parser_program, maps, is_dynamic, &result, &method2lexicalenvstack](panda_file::MethodDataAccessor &mda)  {
            count = count + 1;
            std::cout << "<<<<<<<<<<<<<<<<<<<<   "<< "enumerate method index: " << count << "  >>>>>>>>>>>>>>>>>>>>" << std::endl;
            if (!mda.IsExternal()) {
                result = DecompileFunction(prog, parser_program, maps, mda, is_dynamic, &method2lexicalenvstack) && result;
                if(result){
                    LogAst(parser_program, outputAstFileName);
                    LogArkTS2File(parser_program, outputFileName);
                }
            }
            
        });

    }

    // LogAst(parser_program);
    // LogArkTS2File(parser_program, pfile_name);


    return result;
}


bool DecompileBytecode(pandasm::Program *prog, const pandasm::AsmEmitter::PandaFileToPandaAsmMaps *maps,
                      const std::string &pandafile_name, bool is_dynamic, bool has_memory_pool)
{
    ASSERT(prog != nullptr);
    ASSERT(maps != nullptr);
    
    if (!has_memory_pool) {
        PoolManager::Initialize(PoolType::MALLOC);
    }
    
    auto res = DecompilePandaFile(prog, maps, pandafile_name, is_dynamic);
    
    if (!has_memory_pool) {
        PoolManager::Finalize();
    }

    return res;
}




void startDecompile(std::string &abc_file_name, panda::pandasm::Program &program, panda::pandasm::AsmEmitter::PandaFileToPandaAsmMaps& panda_file_to_asm_maps) {
   
    DecompileBytecode(&program, &panda_file_to_asm_maps, abc_file_name, true, false);
}

void construct_PandaFileToPandaAsmMaps(panda::disasm::Disassembler& disas, pandasm::AsmEmitter::PandaFileToPandaAsmMaps* maps){
    for (const auto &[offset, name_value] : disas.string_offset_to_name_) {
        std::cout << "1 @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@: " <<  offset.GetOffset()  << " % " << std::string(name_value)  << std::endl;
        maps->strings[offset.GetOffset()] = std::string(name_value);
    }

    //////////////////////////////////////////////////////////////////////////
    for (const auto &[name_value, offset] : disas.method_name_to_id_) {
        std::cout << "2 @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@: " << std::string(name_value)  << std::endl;
        maps->methods[offset.GetOffset()] = std::string(name_value);
    }
    
    //////////////////////////////////////////////////////////////////////////
    for (const auto &[name_value, offset] : disas.record_name_to_id_) {
        std::cout << "3 @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@: " << std::string(name_value)  << std::endl;
        maps->classes[offset.GetOffset()] = std::string(name_value);
    }
}


int main(int argc, char* argv[]) {
    if (argc > 1) {
        inputFileName = argv[1]; 
    }
    if (argc > 2) {
        outputFileName = argv[2]; 
    }

    panda::disasm::Disassembler disasm {};
    disasm.Disassemble(inputFileName, false, false);
    disasm.CollectInfo();

    // const auto source = R"(
    //     .language ECMAScript
    //     .function any foo(any a0, any a1, any a2) {
    //         mov v0, a0
    //         mov v1, a1
    //         mov v2, a2
    //     try_begin:
    //         ldai 0x1
    //         trystglobalbyname 0x0, "a"
    //     try_end:
    //         jmp catch_end
    //     catch_begin:
    //         sta v4
    //         tryldglobalbyname 0x1, "a"
    //     catch_end:
    //         returnundefined
    //     }
    // )";

    // panda::pandasm::Parser parser;
    // auto res = parser.Parse(source);
    // auto &prog = res.Value();

    panda::pandasm::Program* program = &disasm.prog_;
    pandasm::AsmEmitter::PandaFileToPandaAsmMaps maps_;


    /////////////////////////////////////////////////////////
    construct_PandaFileToPandaAsmMaps(disasm, &maps_);

    startDecompile(inputFileName, *program, maps_);

    return 0;
}

```