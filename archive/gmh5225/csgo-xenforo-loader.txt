Project Path: arc_gmh5225_csgo-xenforo-loader_q_74773v

Source Tree:

```txt
arc_gmh5225_csgo-xenforo-loader_q_74773v
├── README.md
├── client
│   ├── Loader
│   │   ├── Loader.vcxproj
│   │   ├── Loader.vcxproj.filters
│   │   ├── Loader.vcxproj.user
│   │   ├── headers
│   │   │   └── globals.hpp
│   │   ├── libs
│   │   │   └── th32.lib
│   │   ├── main.cpp
│   │   ├── main.hpp
│   │   ├── protection
│   │   │   ├── AntiDebug
│   │   │   │   ├── AntiDebug.cpp
│   │   │   │   └── AntiDebug.hpp
│   │   │   ├── ErasePEHeaders.hpp
│   │   │   └── LazyImporter.hpp
│   │   └── utils
│   │       ├── Helpers
│   │       │   ├── io.cpp
│   │       │   ├── io.h
│   │       │   ├── util.cpp
│   │       │   └── util.h
│   │       ├── advanced-utils
│   │       │   ├── advanced_utils.cpp
│   │       │   └── advanced_utils.hpp
│   │       ├── encrypt-decrypt
│   │       │   └── xorstr.hpp
│   │       ├── inject
│   │       │   ├── Helpers
│   │       │   │   ├── GetProcId.cpp
│   │       │   │   └── GetProcId.hpp
│   │       │   ├── inject.cpp
│   │       │   └── inject.hpp
│   │       ├── lazy-importer
│   │       │   └── lazy_importer.hpp
│   │       └── webclient
│   │           ├── webclient.cpp
│   │           └── webclient.hpp
│   └── Loader.sln
└── server
    ├── client
    │   ├── client.php
    │   ├── config.php
    │   └── download.php
    ├── loader.php
    └── pastaware.sql

```

`README.md`:

```md
# csgo-xenforo-loader
C++ Loader with LLA injection and authorization with xenforo api

#Info
Inject: LoadLibrary
Bindings: hwid, xenforo account
Protection: AntiDebug, ErasePEheaders (You can add VMProtect)
String encryptor: xorstr

#Client side setup
Compile - Release x86
Settings - headers/globals.hpp

#Server side setup
Setup mysql connection in loader.php file ($sql = mysqli_connect("host", "name", "pass", "database"))
Setup and sync config.php with globals.hpp
Upload the dll in your client folder

```

`client/Loader.sln`:

```sln

Microsoft Visual Studio Solution File, Format Version 12.00
# Visual Studio Version 16
VisualStudioVersion = 16.0.30907.101
MinimumVisualStudioVersion = 10.0.40219.1
Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "Loader", "Loader\Loader.vcxproj", "{FB66BA86-5F04-4D62-8800-BEBF49CD5FBB}"
EndProject
Global
	GlobalSection(SolutionConfigurationPlatforms) = preSolution
		Debug|Any CPU = Debug|Any CPU
		Debug|x64 = Debug|x64
		Debug|x86 = Debug|x86
		Release|Any CPU = Release|Any CPU
		Release|x64 = Release|x64
		Release|x86 = Release|x86
	EndGlobalSection
	GlobalSection(ProjectConfigurationPlatforms) = postSolution
		{FB66BA86-5F04-4D62-8800-BEBF49CD5FBB}.Debug|Any CPU.ActiveCfg = Debug|Win32
		{FB66BA86-5F04-4D62-8800-BEBF49CD5FBB}.Debug|x64.ActiveCfg = Debug|x64
		{FB66BA86-5F04-4D62-8800-BEBF49CD5FBB}.Debug|x64.Build.0 = Debug|x64
		{FB66BA86-5F04-4D62-8800-BEBF49CD5FBB}.Debug|x86.ActiveCfg = Debug|Win32
		{FB66BA86-5F04-4D62-8800-BEBF49CD5FBB}.Debug|x86.Build.0 = Debug|Win32
		{FB66BA86-5F04-4D62-8800-BEBF49CD5FBB}.Release|Any CPU.ActiveCfg = Release|Win32
		{FB66BA86-5F04-4D62-8800-BEBF49CD5FBB}.Release|x64.ActiveCfg = Release|x64
		{FB66BA86-5F04-4D62-8800-BEBF49CD5FBB}.Release|x64.Build.0 = Release|x64
		{FB66BA86-5F04-4D62-8800-BEBF49CD5FBB}.Release|x86.ActiveCfg = Release|Win32
		{FB66BA86-5F04-4D62-8800-BEBF49CD5FBB}.Release|x86.Build.0 = Release|Win32
	EndGlobalSection
	GlobalSection(SolutionProperties) = preSolution
		HideSolutionNode = FALSE
	EndGlobalSection
	GlobalSection(ExtensibilityGlobals) = postSolution
		SolutionGuid = {F1B350F1-C92F-43AD-8487-62A5CCC7F4F5}
	EndGlobalSection
EndGlobal

```

`client/Loader/Loader.vcxproj`:

```vcxproj
<?xml version="1.0" encoding="utf-8"?>
<Project DefaultTargets="Build" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup Label="ProjectConfigurations">
    <ProjectConfiguration Include="Debug|Win32">
      <Configuration>Debug</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|Win32">
      <Configuration>Release</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug|x64">
      <Configuration>Debug</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|x64">
      <Configuration>Release</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
  </ItemGroup>
  <PropertyGroup Label="Globals">
    <VCProjectVersion>16.0</VCProjectVersion>
    <Keyword>Win32Proj</Keyword>
    <ProjectGuid>{fb66ba86-5f04-4d62-8800-bebf49cd5fbb}</ProjectGuid>
    <RootNamespace>Loader</RootNamespace>
    <WindowsTargetPlatformVersion>10.0.18362.0</WindowsTargetPlatformVersion>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v142</PlatformToolset>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v142</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>MultiByte</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v142</PlatformToolset>
    <CharacterSet>Unicode</CharacterSet>
    <WholeProgramOptimization>true</WholeProgramOptimization>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v142</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
  <ImportGroup Label="ExtensionSettings">
  </ImportGroup>
  <ImportGroup Label="Shared">
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <PropertyGroup Label="UserMacros" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <LinkIncremental>true</LinkIncremental>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <LinkIncremental>false</LinkIncremental>
    <LibraryPath>$(ProjectDir)libs;$(LibraryPath)</LibraryPath>
    <OutDir>$(SolutionDir)exe\</OutDir>
    <IntDir>$(ProjectDir)\bin\</IntDir>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <LinkIncremental>true</LinkIncremental>
    <OutDir>$(SolutionDir)exe\</OutDir>
    <IntDir>$(ProjectDir)\bin\</IntDir>
    <LibraryPath>$(ProjectDir)\ext;$(ProjectDir)\libs;$(LibraryPath)</LibraryPath>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <LinkIncremental>false</LinkIncremental>
    <OutDir>$(SolutionDir)exe\</OutDir>
    <IntDir>$(ProjectDir)\bin\</IntDir>
    <LibraryPath>$(ProjectDir)\ext;$(ProjectDir)\libs;$(LibraryPath)</LibraryPath>
  </PropertyGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>WIN32;_DEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>WIN32;NDEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
      <LanguageStandard>stdcpp17</LanguageStandard>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <UACExecutionLevel>RequireAdministrator</UACExecutionLevel>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>_DEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
      <LanguageStandard>stdcpp17</LanguageStandard>
      <SupportJustMyCode>false</SupportJustMyCode>
      <DebugInformationFormat>ProgramDatabase</DebugInformationFormat>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>NDEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
      <LanguageStandard>stdcpp17</LanguageStandard>
      <RuntimeLibrary>MultiThreaded</RuntimeLibrary>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <AdditionalDependencies>%(AdditionalDependencies)</AdditionalDependencies>
      <SpecifySectionAttributes>
      </SpecifySectionAttributes>
      <UACExecutionLevel>RequireAdministrator</UACExecutionLevel>
    </Link>
  </ItemDefinitionGroup>
  <ItemGroup>
    <ClCompile Include="main.cpp" />
    <ClCompile Include="protection\AntiDebug\AntiDebug.cpp" />
    <ClCompile Include="utils\advanced-utils\advanced_utils.cpp" />
    <ClCompile Include="utils\inject\Helpers\GetProcId.cpp" />
    <ClCompile Include="utils\inject\inject.cpp" />
    <ClCompile Include="utils\webclient\webclient.cpp" />
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="headers\globals.hpp" />
    <ClInclude Include="include.h" />
    <ClInclude Include="main.hpp" />
    <ClInclude Include="protection\AntiDebug\AntiDebug.hpp" />
    <ClInclude Include="protection\ErasePEHeaders.hpp" />
    <ClInclude Include="protection\LazyImporter.hpp" />
    <ClInclude Include="utils\advanced-utils\advanced_utils.hpp" />
    <ClInclude Include="utils\encrypt-decrypt\xorstr.hpp" />
    <ClInclude Include="utils\inject\Helpers\GetProcId.hpp" />
    <ClInclude Include="utils\inject\inject.hpp" />
    <ClInclude Include="utils\lazy-importer\lazy_importer.hpp" />
    <ClInclude Include="utils\webclient\webclient.hpp" />
  </ItemGroup>
  <ItemGroup>
    <Library Include="libs\th32.lib" />
  </ItemGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
  <ImportGroup Label="ExtensionTargets">
  </ImportGroup>
</Project>
```

`client/Loader/Loader.vcxproj.filters`:

```filters
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup>
    <Filter Include="headers">
      <UniqueIdentifier>{df954bfc-5695-43d0-bd44-3b1516eb9d64}</UniqueIdentifier>
    </Filter>
    <Filter Include="utils">
      <UniqueIdentifier>{f5107e85-2d23-44f0-a43b-6a8df6e04717}</UniqueIdentifier>
    </Filter>
    <Filter Include="utils\advanced-utils">
      <UniqueIdentifier>{b19797d4-865f-4edb-875b-65bded6e3f30}</UniqueIdentifier>
    </Filter>
    <Filter Include="src">
      <UniqueIdentifier>{4FC737F1-C7A5-4376-A066-2A32D752A2FF}</UniqueIdentifier>
      <Extensions>cpp;c;cc;cxx;c++;cppm;ixx;def;odl;idl;hpj;bat;asm;asmx</Extensions>
    </Filter>
    <Filter Include="libs">
      <UniqueIdentifier>{d847e87e-f83e-436e-ad1e-42b779109db1}</UniqueIdentifier>
    </Filter>
    <Filter Include="utils\lazy-importer">
      <UniqueIdentifier>{af10716d-cb69-4e11-b242-850fefce2fcc}</UniqueIdentifier>
    </Filter>
    <Filter Include="utils\webclient">
      <UniqueIdentifier>{9eb2c2aa-e0f4-4464-9bbf-c0f2c4c49add}</UniqueIdentifier>
    </Filter>
    <Filter Include="utils\inject">
      <UniqueIdentifier>{101ef8d2-4efd-4f2e-b711-e5ccef78bda4}</UniqueIdentifier>
    </Filter>
    <Filter Include="utils\inject\Helpers">
      <UniqueIdentifier>{6ce94a2c-d7f3-499e-b034-eccb07a01c09}</UniqueIdentifier>
    </Filter>
    <Filter Include="utils\encrypt-decrypt">
      <UniqueIdentifier>{1a39fb61-d80c-4c86-a563-ae55f6d1e184}</UniqueIdentifier>
    </Filter>
    <Filter Include="protection">
      <UniqueIdentifier>{2000f3db-5577-456f-a050-73394f0c7bf7}</UniqueIdentifier>
    </Filter>
    <Filter Include="protection\AntiDebug">
      <UniqueIdentifier>{cab881bc-461c-4327-948d-59676ce24949}</UniqueIdentifier>
    </Filter>
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="utils\advanced-utils\advanced_utils.cpp">
      <Filter>utils\advanced-utils</Filter>
    </ClCompile>
    <ClCompile Include="main.cpp">
      <Filter>src</Filter>
    </ClCompile>
    <ClCompile Include="utils\webclient\webclient.cpp">
      <Filter>utils\webclient</Filter>
    </ClCompile>
    <ClCompile Include="utils\inject\inject.cpp">
      <Filter>utils\inject</Filter>
    </ClCompile>
    <ClCompile Include="utils\inject\Helpers\GetProcId.cpp">
      <Filter>utils\inject\Helpers</Filter>
    </ClCompile>
    <ClCompile Include="protection\AntiDebug\AntiDebug.cpp">
      <Filter>protection\AntiDebug</Filter>
    </ClCompile>
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="headers\globals.hpp">
      <Filter>headers</Filter>
    </ClInclude>
    <ClInclude Include="utils\advanced-utils\advanced_utils.hpp">
      <Filter>utils\advanced-utils</Filter>
    </ClInclude>
    <ClInclude Include="main.hpp">
      <Filter>src</Filter>
    </ClInclude>
    <ClInclude Include="utils\lazy-importer\lazy_importer.hpp">
      <Filter>utils\lazy-importer</Filter>
    </ClInclude>
    <ClInclude Include="utils\webclient\webclient.hpp">
      <Filter>utils\webclient</Filter>
    </ClInclude>
    <ClInclude Include="utils\inject\inject.hpp">
      <Filter>utils\inject</Filter>
    </ClInclude>
    <ClInclude Include="utils\inject\Helpers\GetProcId.hpp">
      <Filter>utils\inject\Helpers</Filter>
    </ClInclude>
    <ClInclude Include="include.h">
      <Filter>src</Filter>
    </ClInclude>
    <ClInclude Include="utils\encrypt-decrypt\xorstr.hpp">
      <Filter>utils\encrypt-decrypt</Filter>
    </ClInclude>
    <ClInclude Include="protection\ErasePEHeaders.hpp">
      <Filter>protection</Filter>
    </ClInclude>
    <ClInclude Include="protection\LazyImporter.hpp">
      <Filter>protection</Filter>
    </ClInclude>
    <ClInclude Include="protection\AntiDebug\AntiDebug.hpp">
      <Filter>protection\AntiDebug</Filter>
    </ClInclude>
  </ItemGroup>
  <ItemGroup>
    <Library Include="libs\th32.lib">
      <Filter>libs</Filter>
    </Library>
  </ItemGroup>
</Project>
```

`client/Loader/Loader.vcxproj.user`:

```user
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="Current" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <PropertyGroup />
</Project>
```

`client/Loader/headers/globals.hpp`:

```hpp
#pragma once
#include <string>
#include "../utils/advanced-utils/advanced_utils.hpp"

using namespace utilities;

namespace Globals
{
	static struct
	{
		std::string server = xorstr_("mysite.com");
		std::string forum_dir = xorstr_("/");
		std::string secret_key = xorstr_("1234567890");
	} server_side;

	static struct
	{
		std::string version = xorstr_("1.0");
		std::string client_key = xorstr_("0987654321");
		std::string cheat = xorstr_("Pastaware");
	} client_side;
};
```

`client/Loader/main.cpp`:

```cpp
#include "main.hpp"

using namespace std;

static string username;
static string password;
static string stop;

namespace uLoader
{
    bool check_version()
    {
        string server_version = WebClient::DownloadString(xorstr_("https://") + Globals::server_side.server + xorstr_("/client/client.php?key=") + Globals::client_side.client_key + xorstr_("&check_version=1"));
        if (server_version == Globals::client_side.version) {
            return true;
        }
        else {
            return false;
        }
    }
    void setup_loader()
    {
        cout << xorstr_("Welcome to ") + Globals::client_side.cheat + xorstr_("\n");
        SetConsoleTitleA(utilities::get_random_string(15).c_str());
    }
    int checkUser()
    {
        string output = WebClient::DownloadString(xorstr_("https://") + Globals::server_side.server + xorstr_("/") + Globals::server_side.forum_dir + xorstr_("loader.php?username=") + username + xorstr_("&password=") + password + xorstr_("&hwid=") + utilities::get_hwid());
        if (output == xorstr_("success")) {
            return 1;
        }
        else if (output == xorstr_("hwid:fail")) {
            return 2;
        }
        else {
            return 0;
        }
    }
    void userPanel()
    {
        system("CLS");
        static string inject;
        cout << xorstr_("Welcome to Swiftware, ") + username + xorstr_("\n");
        cout << xorstr_("Inject cheat? (y/n): ");
        cin >> inject;
        if (inject == xorstr_("y")) {
            if (helpers::GetProcId(xorstr_("csgo.exe")) == 0) {
                MessageBox(NULL, xorstr_("Launch csgo before loading cheat!"), Globals::client_side.cheat.c_str(), MB_ICONINFORMATION | MB_DEFBUTTON2);
                ErasePEHeaderFromMemory();
                return;
            }
            else {
                cout << xorstr_("Injecting...\n");

                uLoaderInjector::inject_cheat();
                ErasePEHeaderFromMemory();
                return;
            }
        }
        else {
            ErasePEHeaderFromMemory();
            return;
        }
    }
    void authPanel()
    {
        cout << xorstr_("Username: ");
        cin >> username;
        cout << xorstr_("Password: ");
        cin >> password;
    }
}

int main()
{
    if (protection::check_security() != protection::debug_results::none)
        return 0;

    if (!uLoader::check_version()) {
        MessageBox(NULL, xorstr_("Please, download new loader version!"), Globals::client_side.cheat.c_str(), MB_ICONINFORMATION | MB_DEFBUTTON2);
        ErasePEHeaderFromMemory();
        return 0;
    }

    uLoader::setup_loader();
    uLoader::authPanel();

    if (uLoader::checkUser() == 1) {
        uLoader::userPanel();
    }
    if (uLoader::checkUser() == 2) {
        MessageBox(NULL, xorstr_("HWID Error"), Globals::client_side.cheat.c_str(), MB_ICONERROR | MB_DEFBUTTON2);
        ErasePEHeaderFromMemory();
        return 0;
    }
    else {
        ErasePEHeaderFromMemory();
        return 0;
    }
}
```

`client/Loader/main.hpp`:

```hpp
#pragma once
#define _CRT_SECURE_NO_WARNINGS
#include <Windows.h>
#include "headers/globals.hpp"
#include "utils/webclient/webclient.hpp"
#include "utils/encrypt-decrypt/xorstr.hpp"
#include "utils/inject/Helpers/GetProcId.hpp"
#include "utils/inject/inject.hpp"
#include "protection/ErasePEHeaders.hpp"
#include "protection/AntiDebug/AntiDebug.hpp"

namespace uLoader
{
	extern bool check_version();
	extern void setup_loader();
	extern int checkUser();
	extern void userPanel();
	extern void authPanel();
}
```

`client/Loader/protection/AntiDebug/AntiDebug.cpp`:

```cpp
#include "AntiDebug.hpp"

BOOL IsProcessRunning(DWORD pid)
{
    HANDLE process = OpenProcess(SYNCHRONIZE, FALSE, pid);
    DWORD ret = WaitForSingleObject(process, 0);
    CloseHandle(process);
    return ret == WAIT_TIMEOUT;
}

bool found = true;

namespace protection {
    int check_process()
    {
        DWORD ida = helpers::GetProcId("ida.exe");
        DWORD ida64 = helpers::GetProcId("ida64.exe");
        DWORD ida32 = helpers::GetProcId("ida32.exe");
        DWORD ollydbg = helpers::GetProcId("ollydbg.exe");
        DWORD ollydbg64 = helpers::GetProcId("ollydbg64.exe");
        DWORD loaddll = helpers::GetProcId("loaddll.exe");
        DWORD httpdebugger = helpers::GetProcId("httpdebugger.exe");
        DWORD windowrenamer = helpers::GetProcId("windowrenamer.exe");
        DWORD processhacker = helpers::GetProcId("processhacker.exe");
        DWORD processhacker2 = helpers::GetProcId("Process Hacker.exe");
        DWORD processhacker3 = helpers::GetProcId("ProcessHacker.exe");
        DWORD HxD = helpers::GetProcId("HxD.exe");
        DWORD parsecd = helpers::GetProcId("parsecd.exe");
        DWORD dnSpy = helpers::GetProcId("dnSpy.exe");

        if (IsProcessRunning(ida) || IsProcessRunning(ida64) || IsProcessRunning(ida32) || IsProcessRunning(ollydbg) || IsProcessRunning(ollydbg64)
            || IsProcessRunning(loaddll) || IsProcessRunning(httpdebugger) || IsProcessRunning(windowrenamer) || IsProcessRunning(windowrenamer)
            || IsProcessRunning(processhacker) || IsProcessRunning(processhacker2) || IsProcessRunning(processhacker3) || IsProcessRunning(HxD)
            || IsProcessRunning(parsecd) || IsProcessRunning(dnSpy)) {
            return debug_results::being_debugged_peb;
        }
        else {
            return debug_results::none;
        }
    }

    int __cdecl vm_handler(EXCEPTION_RECORD* p_rec, void* est, unsigned char* p_context, void* disp)
    {
        found = true;
        (*(unsigned long*)(p_context + 0xB8)) += 4;
        return ExceptionContinueExecution;
    }

    void to_lower(unsigned char* input)
    {
        char* p = (char*)input;
        unsigned long length = strlen(p);
        for (unsigned long i = 0; i < length; i++) p[i] = tolower(p[i]);
    }

    const wchar_t* get_string(int index) {
        std::string value = "";

        switch (index) {
        case 0: value = xorstr_("Qt5QWindowIcon"); break;
        case 1: value = xorstr_("OLLYDBG"); break;
        case 2: value = xorstr_("SunAwtFrame"); break;
        case 3: value = xorstr_("ID"); break;
        case 4: value = xorstr_("ntdll.dll"); break;
        case 5: value = xorstr_("antidbg"); break;
        case 6: value = xorstr_("%random_environment_var_name_that_doesnt_exist?[]<>@\\;*!-{}#:/~%"); break;
        case 7: value = xorstr_("%random_file_name_that_doesnt_exist?[]<>@\\;*!-{}#:/~%"); break;
        }

        return std::wstring(value.begin(), value.end()).c_str();
    }

    int memory::being_debugged_peb() {
        BOOL found = FALSE;
        _asm
        {
            xor eax, eax;			//clear the eax register
            mov eax, fs: [0x30] ;	//reference start of the process environment block
            mov eax, [eax + 0x02];	//beingdebugged is stored in peb + 2
            and eax, 0x000000FF;	//reference one byte
            mov found, eax;			//copy value to found
        }

        return (found) ? debug_results::being_debugged_peb : debug_results::none;
    }

    int memory::remote_debugger_present() {
        //declare variables to hold the process handle & bool to check if it was found
        HANDLE h_process = INVALID_HANDLE_VALUE;
        BOOL found = FALSE;

        //set the process handle to the current process
        h_process = GetCurrentProcess();
        //check if a remote debugger is present
        CheckRemoteDebuggerPresent(h_process, &found);

        //if found is true, we return the right code.
        return (found) ? debug_results::remote_debugger_present : debug_results::none;
    }

    int memory::check_window_name() {
        const wchar_t* names[4] = { get_string(0), get_string(1), get_string(2), get_string(3) };

        for (const wchar_t* name : names) {
            if (FindWindow((LPCSTR)name, 0)) { return debug_results::find_window; }
        }

        return debug_results::none;
    }

    int memory::is_debugger_present() {
        //if debugger is found, we return the right code.
        return (IsDebuggerPresent()) ? debug_results::debugger_is_present : debug_results::none;
    }

    int memory::nt_global_flag_peb() {
        //bool to indicate find status
        BOOL found = FALSE;
        _asm
        {
            xor eax, eax;			//clear the eax register
            mov eax, fs: [0x30] ;   //reference start of the peb
            mov eax, [eax + 0x68];	//peb+0x68 points to NtGlobalFlags
            and eax, 0x00000070;	//check three flags
            mov found, eax;			//copy value to found
        }

        //if found is true, we return the right code.
        return (found) ? debug_results::being_debugged_peb : debug_results::none;
    }

    int memory::nt_query_information_process() {
        HANDLE h_process = INVALID_HANDLE_VALUE;
        DWORD found = FALSE;
        DWORD process_debug_port = 0x07;	//first method, check msdn for details
        DWORD process_debug_flags = 0x1F;	//second method, check msdn for details

        //get a handle to ntdll.dll so we can use NtQueryInformationProcess
        HMODULE h_ntdll = LoadLibraryW(get_string(4));

        //if we cant get the handle for some reason, we return none
        if (h_ntdll == INVALID_HANDLE_VALUE || h_ntdll == NULL) { return debug_results::none; }

        //dynamically acquire the address of NtQueryInformationProcess
        _NtQueryInformationProcess NtQueryInformationProcess = NULL;
        NtQueryInformationProcess = (_NtQueryInformationProcess)GetProcAddress(h_ntdll, xorstr_("NtQueryInformationProcess"));

        //if we cant get access for some reason, we return none
        if (NtQueryInformationProcess == NULL) { return debug_results::none; }

        //method 1: query ProcessDebugPort
        h_process = GetCurrentProcess();
        NTSTATUS status = NtQueryInformationProcess(h_process, ProcessDebugPort, &found, sizeof(DWORD), NULL);

        //found something
        if (!status && found) { return debug_results::nt_query_information_process; }

        //method 2: query ProcessDebugFlags
        status = NtQueryInformationProcess(h_process, process_debug_flags, &found, sizeof(DWORD), NULL);

        //the ProcessDebugFlags set found to 1 if no debugger is found, so we check !found.
        if (!status && !found) { return debug_results::nt_query_information_process; }

        return debug_results::none;
    }

    int memory::nt_set_information_thread() {
        DWORD thread_hide_from_debugger = 0x11;

        //get a handle to ntdll.dll so we can use NtQueryInformationProcess
        HMODULE h_ntdll = LoadLibraryW(get_string(4));

        //if we cant get the handle for some reason, we return none
        if (h_ntdll == INVALID_HANDLE_VALUE || h_ntdll == NULL) { return debug_results::none; }

        //dynamically acquire the address of NtQueryInformationProcess
        _NtQueryInformationProcess NtQueryInformationProcess = NULL;
        NtQueryInformationProcess = (_NtQueryInformationProcess)GetProcAddress(h_ntdll, xorstr_("NtQueryInformationProcess"));

        //if we cant get access for some reason, we return none
        if (NtQueryInformationProcess == NULL) { return debug_results::none; }

        //make call to deattach a debugger :moyai:
        (_NtSetInformationThread)(GetCurrentThread(), thread_hide_from_debugger, 0, 0, 0);

        return debug_results::none;
    }

    int memory::debug_active_process() {
        BOOL found = FALSE;
        STARTUPINFOA si = { 0 };
        PROCESS_INFORMATION pi = { 0 };
        si.cb = sizeof(si);
        TCHAR sz_path[MAX_PATH];
        DWORD exit_code = 0;

        DWORD proc_id = GetCurrentProcessId();
        std::stringstream stream;
        stream << proc_id;
        std::string args = stream.str();

        const char* cp_id = args.c_str();
        CreateMutex(NULL, FALSE, (LPCSTR)get_string(5));
        if (GetLastError() != ERROR_SUCCESS)
        {
            //if we get here, we're in the child process
            if (DebugActiveProcess((DWORD)atoi(cp_id)))
            {
                //no debugger found
                return debug_results::none;
            }
            else
            {
                //debugger found, exit child with unique code that we can check for
                exit(555);
            }
        }

        //parent process
        DWORD pid = GetCurrentProcessId();
        GetModuleFileName(NULL, sz_path, MAX_PATH);

        char cmdline[MAX_PATH + 1 + sizeof(int)];
        snprintf(cmdline, sizeof(cmdline), xorstr_("%ws %d"), sz_path, pid);

        //start child process
        BOOL success = CreateProcessA(
            NULL,		//path (NULL means use cmdline instead)
            cmdline,	//command line
            NULL,		//process handle not inheritable
            NULL,		//thread handle not inheritable
            FALSE,		//set handle inheritance to FALSE
            0,			//no creation flags
            NULL,		//use parent's environment block
            NULL,		//use parent's starting directory 
            &si,		//pointer to STARTUPINFO structure
            &pi);		//pointer to PROCESS_INFORMATION structure

        //wait until child process exits and get the code
        WaitForSingleObject(pi.hProcess, INFINITE);

        //check for our unique exit code
        if (GetExitCodeProcess(pi.hProcess, &exit_code) == 555) { found = TRUE; }

        // Close process and thread handles. 
        CloseHandle(pi.hProcess);
        CloseHandle(pi.hThread);
        //if found is true, we return the right code.
        return (found) ? debug_results::being_debugged_peb : debug_results::none;
    }

    int memory::write_buffer() {
        //first option

        //vars to store the amount of accesses to the buffer and the granularity for GetWriteWatch()
        ULONG_PTR hits;
        DWORD granularity;

        PVOID* addresses = static_cast<PVOID*>(VirtualAlloc(NULL, 4096 * sizeof(PVOID), MEM_RESERVE | MEM_COMMIT, PAGE_READWRITE));
        if (addresses == NULL) {
            return debug_results::write_buffer;
        }

        int* buffer = static_cast<int*>(VirtualAlloc(NULL, 4096 * 4096, MEM_RESERVE | MEM_COMMIT | MEM_WRITE_WATCH, PAGE_READWRITE));
        if (buffer == NULL) {
            VirtualFree(addresses, 0, MEM_RELEASE);
            return debug_results::write_buffer;
        }

        //read the buffer once
        buffer[0] = 1234;

        hits = 4096;
        if (GetWriteWatch(0, buffer, 4096, addresses, &hits, &granularity) != 0) { return debug_results::write_buffer; }
        else
        {
            //free the memory again
            VirtualFree(addresses, 0, MEM_RELEASE);
            VirtualFree(buffer, 0, MEM_RELEASE);

            //we should have 1 hit if everything is fine
            return (hits == 1) ? debug_results::none : debug_results::write_buffer;
        }

        //second option

        BOOL result = FALSE, error = FALSE;

        addresses = static_cast<PVOID*>(VirtualAlloc(NULL, 4096 * sizeof(PVOID), MEM_RESERVE | MEM_COMMIT, PAGE_READWRITE));
        if (addresses == NULL) { return debug_results::write_buffer; }

        buffer = static_cast<int*>(VirtualAlloc(NULL, 4096 * 4096, MEM_RESERVE | MEM_COMMIT | MEM_WRITE_WATCH, PAGE_READWRITE));
        if (buffer == NULL) {
            VirtualFree(addresses, 0, MEM_RELEASE);
            return debug_results::write_buffer;
        }

        //make some calls where a buffer *can* be written to, but isn't actually edited because we pass invalid parameters	
        if (GlobalGetAtomName(INVALID_ATOM, (LPTSTR)buffer, 1) != FALSE || GetEnvironmentVariable((LPSTR)get_string(6), (LPSTR)buffer, 4096 * 4096) != FALSE || GetBinaryType((LPSTR)get_string(7), (LPDWORD)buffer) != FALSE
            || HeapQueryInformation(0, (HEAP_INFORMATION_CLASS)69, buffer, 4096, NULL) != FALSE || ReadProcessMemory(INVALID_HANDLE_VALUE, (LPCVOID)0x69696969, buffer, 4096, NULL) != FALSE
            || GetThreadContext(INVALID_HANDLE_VALUE, (LPCONTEXT)buffer) != FALSE || GetWriteWatch(0, &memory::write_buffer, 0, NULL, NULL, (PULONG)buffer) == 0) {
            result = false;
            error = true;
        }

        if (error == FALSE)
        {
            //all calles failed as they're supposed to
            hits = 4096;
            if (GetWriteWatch(0, buffer, 4096, addresses, &hits, &granularity) != 0)
            {
                result = FALSE;
            }
            else
            {
                //should have zero reads here because GlobalGetAtomName doesn't probe the buffer until other checks have succeeded
                //if there's an API hook or debugger in here it'll probably try to probe the buffer, which will be caught here
                result = hits != 0;
            }
        }

        VirtualFree(addresses, 0, MEM_RELEASE);
        VirtualFree(buffer, 0, MEM_RELEASE);

        return result;
    }

    int exceptions::close_handle_exception() {
        //invalid handle
        HANDLE h_invalid = (HANDLE)0xDEADBEEF;

        __try
        {
            CloseHandle(h_invalid);
        }
        __except (EXCEPTION_EXECUTE_HANDLER)
        {
            //if we get the exception, we return the right code.
            return debug_results::close_handle_exception;
        }

        return debug_results::none;
    }

    int exceptions::single_step_exception() {
        BOOL debugger_present = TRUE;
        __try
        {
            __asm
            {
                pushfd						//save flag register
                or dword ptr[esp], 0x100	//set trap flag in EFlags
                popfd						//restore flag register
                nop							//does nothing
            }
        }
        __except (EXCEPTION_EXECUTE_HANDLER) { debugger_present = FALSE; }

        //if the exception was raised, return none
        //if a debugger handled the exception (no exception for us to handle), return detection
        return (debugger_present) ? debug_results::single_step : debug_results::none;
    }

    int exceptions::int_3() {
        __try
        {
            _asm
            {
                int 3;	//0xCC / standard software breakpoint
            }
        }
        //exception is handled by our app = debugger did not attempt to intervene
        __except (EXCEPTION_EXECUTE_HANDLER) { return debug_results::none; }

        //if we don't get the exception, we return the right code.
        return debug_results::int_3_cc;
    }

    int exceptions::int_2d() {
        BOOL found = false;
        __try
        {
            _asm
            {
                int 0x2D;	//kernel breakpoint
            }
        }

        __except (EXCEPTION_EXECUTE_HANDLER) { return debug_results::none; }

        __try
        {
            __asm
            {
                xor eax, eax; //clear the eax register
                int  2dh;     //try to get the debugger to bypass the instruction
                inc  eax;     //set the eax register to 1
                mov found, eax;
            }
        }

        __except (EXCEPTION_EXECUTE_HANDLER) { return debug_results::none; }

        //if we don't get the exception, we return the right code.
        return debug_results::int_2;
    }

    int exceptions::prefix_hop() {
        __try
        {
            _asm
            {
                __emit 0xF3;	//0xF3 0x64 is the prefix rep
                __emit 0x64;
                __emit 0xCC;	//this gets skipped over if being debugged (read exceptions::int_3())
            }
        }

        __except (EXCEPTION_EXECUTE_HANDLER) { return debug_results::none; }

        //if we don't get the exception, we return the right code.
        return debug_results::prefix_hop;
    }

    /*int exceptions::debug_string() {
        SetLastError(0);
        OutputDebugStringA(xorstr_("anti-debugging test."));

        return (GetLastError() != 0) ? debug_results::debug_string : debug_results::none;
    }*/

    /*int timing::rdtsc() {
        //integers for time values
        UINT64 time_a, time_b = 0;
        int time_upper_a, time_lower_a = 0;
        int time_upper_b, time_lower_b = 0;

        _asm
        {
            //rdtsc stores result across EDX:EAX
            rdtsc;
            mov time_upper_a, edx;
            mov time_lower_a, eax;

            //junk code -> skip through breakpoint
            xor eax, eax;
            mov eax, 5;
            shr eax, 2;
            sub eax, ebx;
            cmp eax, ecx

                rdtsc;
            mov time_upper_b, edx;
            mov time_lower_b, eax;
        }

        time_a = time_upper_a;
        time_a = (time_a << 32) | time_lower_a;

        time_b = time_upper_b;
        time_b = (time_b << 32) | time_lower_b;

        //0x10000 is purely empirical and is based on the computer's clock cycle, could be less if the cpu clocks really fast etc.
        //should change depending on the length and complexity of the code between each rdtsc operation (-> asm code inbetween needs longer to execute but takes A LOT longer if its being debugged / someone is stepping through it)
        return (time_b - time_a > 0x10000) ? debug_results::rdtsc : debug_results::none;
    }

    int timing::query_performance_counter() {
        LARGE_INTEGER t1;
        LARGE_INTEGER t2;

        QueryPerformanceCounter(&t1);

        //junk code
        _asm
        {
            xor eax, eax;
            push eax;
            push ecx;
            pop eax;
            pop ecx;
            sub ecx, eax;
            shl ecx, 4;
        }

        QueryPerformanceCounter(&t2);

        //30 is a random value
        return ((t2.QuadPart - t1.QuadPart) > 30) ? debug_results::query_performance_counter : debug_results::none;
    }*/

    int timing::get_tick_count() {
        DWORD t1;
        DWORD t2;

        t1 = GetTickCount64();

        //junk code to keep the cpu busy for a few cycles so that time passes and the return value of GetTickCount() changes (so we can detect if it runs at "normal" speed or is being checked through by a human)
        _asm
        {
            xor eax, eax;
            push eax;
            push ecx;
            pop eax;
            pop ecx;
            sub ecx, eax;
            shl ecx, 4;
        }

        t2 = GetTickCount64();

        //30 ms seems ok
        return ((t2 - t1) > 30) ? debug_results::query_performance_counter : debug_results::none;
    }

    int cpu::hardware_debug_registers() {
        CONTEXT ctx = { 0 };
        HANDLE h_thread = GetCurrentThread();

        ctx.ContextFlags = CONTEXT_DEBUG_REGISTERS;
        if (GetThreadContext(h_thread, &ctx))
        {
            return ((ctx.Dr0 != 0x00) || (ctx.Dr1 != 0x00) || (ctx.Dr2 != 0x00) || (ctx.Dr3 != 0x00) || (ctx.Dr6 != 0x00) || (ctx.Dr7 != 0x00)) ? debug_results::hardware_debug_registers : debug_results::none;
        }

        return debug_results::none;
    }

    int cpu::mov_ss() {
        BOOL found = FALSE;

        _asm
        {
            push ss;
            pop ss;
            pushfd;
            test byte ptr[esp + 1], 1;
            jne fnd;
            jmp end;
        fnd:
            mov found, 1;
        end:
            nop;
        }

        return (found) ? debug_results::mov_ss : debug_results::none;
    }

    int virtualization::check_cpuid() {
        bool found = false;
        __asm {
            xor eax, eax
            mov    eax, 0x40000000
            cpuid
            cmp ecx, 0x4D566572
            jne nop_instr
            cmp edx, 0x65726177
            jne nop_instr
            mov found, 0x1
            nop_instr:
            nop
        }

        return (found) ? debug_results::check_cpuid : debug_results::none;
    }

    int virtualization::check_registry() {
        HKEY h_key = 0;
        if (RegOpenKeyEx(HKEY_LOCAL_MACHINE, xorstr_("HARDWARE\\ACPI\\DSDT\\VBOX__"), 0, KEY_READ, &h_key) == ERROR_SUCCESS) { return debug_results::check_registry; }

        return debug_results::none;
    }

    debug_results check_security() {
        if (memory::being_debugged_peb() != debug_results::none) {
            return debug_results::being_debugged_peb;
        }
        if (memory::remote_debugger_present() != debug_results::none) {
            return debug_results::remote_debugger_present;
        }
        if (memory::check_window_name() != debug_results::none) {
            return debug_results::find_window;
        }
        if (memory::is_debugger_present() != debug_results::none) {
            return debug_results::debugger_is_present;
        }
        if (memory::nt_global_flag_peb() != debug_results::none) {
            return debug_results::being_debugged_peb;
        }
        if (memory::nt_query_information_process() != debug_results::none) {
            return debug_results::nt_query_information_process;
        }
        if (memory::debug_active_process() != debug_results::none) {
            return debug_results::debug_active_process;
        }
        if (memory::write_buffer() != debug_results::none) {
            return debug_results::write_buffer;
        }
        if (exceptions::close_handle_exception() != debug_results::none) {
            return debug_results::close_handle_exception;
        }
        if (exceptions::single_step_exception() != debug_results::none) {
            return debug_results::single_step;
        }
        if (exceptions::int_3() != debug_results::none) {
            return debug_results::int_3_cc;
        }
        if (exceptions::int_2d() != debug_results::none) {
            return debug_results::int_2;
        }
        if (exceptions::prefix_hop() != debug_results::none) {
            return debug_results::prefix_hop;
        }
        /*if (exceptions::debug_string() != debug_results::none) {
            return debug_results::debug_string;
        }
        /*if (timing::rdtsc() != debug_results::none) {
            return debug_results::rdtsc;
        }
        if (timing::query_performance_counter() != debug_results::none) {
            return debug_results::query_performance_counter;
        }*/
        if (timing::get_tick_count() != debug_results::none) {
            return debug_results::get_tick_count;
        }
        if (cpu::hardware_debug_registers() != debug_results::none) {
            return debug_results::hardware_debug_registers;
        }
        if (cpu::mov_ss() != debug_results::none) {
            return debug_results::mov_ss;
        }
        if (virtualization::check_cpuid() != debug_results::none) {
            return debug_results::check_cpuid;
        }
        if (virtualization::check_registry() != debug_results::none) {
            return debug_results::check_registry;
        }
        if (check_process() != debug_results::none) {
            return debug_results::debug_active_process;
        }

        return debug_results::none;
    }
}
```

`client/Loader/protection/AntiDebug/AntiDebug.hpp`:

```hpp
#pragma once
#define _CRT_SECURE_NO_WARNINGS
#include <Windows.h>
#include <Winternl.h>
#include <string>
#include <cstdio>
#include <functional>
#include <vector>
#include <string>
#include <sstream>
#include <iostream>
#include <filesystem>
#pragma warning(disable : 4091)
#pragma warning(disable : 6387)
#pragma warning(disable : 4244)
#pragma warning(disable : 6262)
#pragma warning(disable : 4733)
#pragma warning(disable : 4731)
#include "../../utils/inject/Helpers/GetProcId.hpp"
#include "../../utils/encrypt-decrypt/xorstr.hpp"

namespace protection {
	int check_process();
	int __cdecl vm_handler(EXCEPTION_RECORD* p_rec, void* est, unsigned char* p_context, void* disp);
	void to_lower(unsigned char* input);
	const wchar_t* get_string(int index);
	typedef NTSTATUS(__stdcall* _NtQueryInformationProcess)(_In_ HANDLE, _In_  unsigned int, _Out_ PVOID, _In_ ULONG, _Out_ PULONG);
	typedef NTSTATUS(__stdcall* _NtSetInformationThread)(_In_ HANDLE, _In_ THREAD_INFORMATION_CLASS, _In_ PVOID, _In_ ULONG);

	extern enum debug_results
	{
		//nothing was caught, value = 0
		none = 0x0000,

		//something caught in memory (0x1000 - 0x1009)
		being_debugged_peb = 0x1000,
		remote_debugger_present = 0x1001,
		debugger_is_present = 0x1002,
		dbg_global_flag = 0x1003,
		nt_query_information_process = 0x0004,
		find_window = 0x1005,
		output_debug_string = 0x1006,
		nt_set_information_thread = 0x1007,
		debug_active_process = 0x1008,
		write_buffer = 0x1009,

		//something caught in exceptions (0x2000 - 0x2005)
		close_handle_exception = 0x2000,
		single_step = 0x2001,
		int_3_cc = 0x2002,
		int_2 = 0x2003,
		prefix_hop = 0x2004,
		debug_string = 0x2005,

		//something caught with timings (0x3000 - 0x3002)
		rdtsc = 0x3000,
		query_performance_counter = 0x3001,
		get_tick_count = 0x3002,

		//something caught in cpu (0x4000 - 0x4001)
		hardware_debug_registers = 0x4000,
		mov_ss = 0x4001,

		//virtualization (0x5000 - 0x5003)
		check_cpuid = 0x5000,
		check_registry = 0x5001,
		vm = 0x5002,
	};

	namespace memory {
		int being_debugged_peb();
		int remote_debugger_present();
		int check_window_name();
		int is_debugger_present();
		int nt_global_flag_peb();
		int nt_query_information_process();
		int nt_set_information_thread();
		int debug_active_process();
		int write_buffer();
	}

	namespace exceptions {
		int close_handle_exception();
		int single_step_exception();
		int int_3();
		int int_2d();
		int prefix_hop();
		int debug_string();
	}

	namespace timing {
		int rdtsc();
		int query_performance_counter();
		int get_tick_count();
	}

	namespace cpu {
		int hardware_debug_registers();
		int mov_ss();
	}

	namespace virtualization {
		int check_cpuid();
		int check_registry();
	}

	debug_results check_security();
}
```

`client/Loader/protection/ErasePEHeaders.hpp`:

```hpp
#pragma once
#include <Windows.h>
#include <tchar.h>

VOID ErasePEHeaderFromMemory()
{
	DWORD OldProtect = 0;

	char* pBaseAddr = (char*)GetModuleHandle(NULL);

	VirtualProtect(pBaseAddr, 4096, PAGE_READWRITE, &OldProtect);

	SecureZeroMemory(pBaseAddr, 4096);
}
```

`client/Loader/protection/LazyImporter.hpp`:

```hpp
/*
 * Copyright 2018 Justas Masiulis
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

 // documentation is available at https://github.com/JustasMasiulis/lazy_importer

#ifndef LAZY_IMPORTER_HPP
#define LAZY_IMPORTER_HPP

#define LI_FN(name) \
    ::li::detail::lazy_function<::li::detail::khash(#name), decltype(&name)>()

#define LI_FN_DEF(name) ::li::detail::lazy_function<::li::detail::khash(#name), name>()

#define LI_MODULE(name) ::li::detail::lazy_module<::li::detail::khash(name)>()

// NOTE only std::forward is used from this header.
// If there is a need to eliminate this dependency the function itself is very small.
#include <utility>
#include <cstddef>
#include <intrin.h>

#ifndef LAZY_IMPORTER_NO_FORCEINLINE
#if defined(_MSC_VER)
#define LAZY_IMPORTER_FORCEINLINE __forceinline
#elif defined(__GNUC__) && __GNUC__ > 3
#define LAZY_IMPORTER_FORCEINLINE inline __attribute__((__always_inline__))
#else
#define LAZY_IMPORTER_FORCEINLINE inline
#endif
#else
#define LAZY_IMPORTER_FORCEINLINE inline
#endif

#ifdef LAZY_IMPORTER_CASE_INSENSITIVE
#define LAZY_IMPORTER_TOLOWER(c) (c >= 'A' && c <= 'Z' ? (c | (1 << 5)) : c)
#else
#define LAZY_IMPORTER_TOLOWER(c) (c)
#endif

namespace li {
	namespace detail {

		template<class First, class Second>
		struct pair {
			First  first;
			Second second;
		};

		namespace win {

			struct LIST_ENTRY_T {
				const char* Flink;
				const char* Blink;
			};

			struct UNICODE_STRING_T {
				unsigned short Length;
				unsigned short MaximumLength;
				wchar_t* Buffer;
			};

			struct PEB_LDR_DATA_T {
				unsigned long Length;
				unsigned long Initialized;
				const char* SsHandle;
				LIST_ENTRY_T  InLoadOrderModuleList;
			};

			struct PEB_T {
				unsigned char   Reserved1[2];
				unsigned char   BeingDebugged;
				unsigned char   Reserved2[1];
				const char* Reserved3[2];
				PEB_LDR_DATA_T* Ldr;
			};

			struct LDR_DATA_TABLE_ENTRY_T {
				LIST_ENTRY_T InLoadOrderLinks;
				LIST_ENTRY_T InMemoryOrderLinks;
				LIST_ENTRY_T InInitializationOrderLinks;
				const char* DllBase;
				const char* EntryPoint;
				union {
					unsigned long SizeOfImage;
					const char* _dummy;
				};
				UNICODE_STRING_T FullDllName;
				UNICODE_STRING_T BaseDllName;

				LAZY_IMPORTER_FORCEINLINE const LDR_DATA_TABLE_ENTRY_T*
					load_order_next() const noexcept
				{
					return reinterpret_cast<const LDR_DATA_TABLE_ENTRY_T*>(
						InLoadOrderLinks.Flink);
				}
			};

			struct IMAGE_DOS_HEADER { // DOS .EXE header
				unsigned short e_magic; // Magic number
				unsigned short e_cblp; // Bytes on last page of file
				unsigned short e_cp; // Pages in file
				unsigned short e_crlc; // Relocations
				unsigned short e_cparhdr; // Size of header in paragraphs
				unsigned short e_minalloc; // Minimum extra paragraphs needed
				unsigned short e_maxalloc; // Maximum extra paragraphs needed
				unsigned short e_ss; // Initial (relative) SS value
				unsigned short e_sp; // Initial SP value
				unsigned short e_csum; // Checksum
				unsigned short e_ip; // Initial IP value
				unsigned short e_cs; // Initial (relative) CS value
				unsigned short e_lfarlc; // File address of relocation table
				unsigned short e_ovno; // Overlay number
				unsigned short e_res[4]; // Reserved words
				unsigned short e_oemid; // OEM identifier (for e_oeminfo)
				unsigned short e_oeminfo; // OEM information; e_oemid specific
				unsigned short e_res2[10]; // Reserved words
				long           e_lfanew; // File address of new exe header
			};

			struct IMAGE_FILE_HEADER {
				unsigned short Machine;
				unsigned short NumberOfSections;
				unsigned long  TimeDateStamp;
				unsigned long  PointerToSymbolTable;
				unsigned long  NumberOfSymbols;
				unsigned short SizeOfOptionalHeader;
				unsigned short Characteristics;
			};

			struct IMAGE_EXPORT_DIRECTORY {
				unsigned long  Characteristics;
				unsigned long  TimeDateStamp;
				unsigned short MajorVersion;
				unsigned short MinorVersion;
				unsigned long  Name;
				unsigned long  Base;
				unsigned long  NumberOfFunctions;
				unsigned long  NumberOfNames;
				unsigned long  AddressOfFunctions; // RVA from base of image
				unsigned long  AddressOfNames; // RVA from base of image
				unsigned long  AddressOfNameOrdinals; // RVA from base of image
			};

			struct IMAGE_DATA_DIRECTORY {
				unsigned long VirtualAddress;
				unsigned long Size;
			};

			struct IMAGE_OPTIONAL_HEADER64 {
				unsigned short       Magic;
				unsigned char        MajorLinkerVersion;
				unsigned char        MinorLinkerVersion;
				unsigned long        SizeOfCode;
				unsigned long        SizeOfInitializedData;
				unsigned long        SizeOfUninitializedData;
				unsigned long        AddressOfEntryPoint;
				unsigned long        BaseOfCode;
				unsigned long long   ImageBase;
				unsigned long        SectionAlignment;
				unsigned long        FileAlignment;
				unsigned short       MajorOperatingSystemVersion;
				unsigned short       MinorOperatingSystemVersion;
				unsigned short       MajorImageVersion;
				unsigned short       MinorImageVersion;
				unsigned short       MajorSubsystemVersion;
				unsigned short       MinorSubsystemVersion;
				unsigned long        Win32VersionValue;
				unsigned long        SizeOfImage;
				unsigned long        SizeOfHeaders;
				unsigned long        CheckSum;
				unsigned short       Subsystem;
				unsigned short       DllCharacteristics;
				unsigned long long   SizeOfStackReserve;
				unsigned long long   SizeOfStackCommit;
				unsigned long long   SizeOfHeapReserve;
				unsigned long long   SizeOfHeapCommit;
				unsigned long        LoaderFlags;
				unsigned long        NumberOfRvaAndSizes;
				IMAGE_DATA_DIRECTORY DataDirectory[16];
			};

			struct IMAGE_OPTIONAL_HEADER32 {
				unsigned short       Magic;
				unsigned char        MajorLinkerVersion;
				unsigned char        MinorLinkerVersion;
				unsigned long        SizeOfCode;
				unsigned long        SizeOfInitializedData;
				unsigned long        SizeOfUninitializedData;
				unsigned long        AddressOfEntryPoint;
				unsigned long        BaseOfCode;
				unsigned long        BaseOfData;
				unsigned long        ImageBase;
				unsigned long        SectionAlignment;
				unsigned long        FileAlignment;
				unsigned short       MajorOperatingSystemVersion;
				unsigned short       MinorOperatingSystemVersion;
				unsigned short       MajorImageVersion;
				unsigned short       MinorImageVersion;
				unsigned short       MajorSubsystemVersion;
				unsigned short       MinorSubsystemVersion;
				unsigned long        Win32VersionValue;
				unsigned long        SizeOfImage;
				unsigned long        SizeOfHeaders;
				unsigned long        CheckSum;
				unsigned short       Subsystem;
				unsigned short       DllCharacteristics;
				unsigned long        SizeOfStackReserve;
				unsigned long        SizeOfStackCommit;
				unsigned long        SizeOfHeapReserve;
				unsigned long        SizeOfHeapCommit;
				unsigned long        LoaderFlags;
				unsigned long        NumberOfRvaAndSizes;
				IMAGE_DATA_DIRECTORY DataDirectory[16];
			};

			struct IMAGE_NT_HEADERS {
				unsigned long     Signature;
				IMAGE_FILE_HEADER FileHeader;
#ifdef _WIN64
				IMAGE_OPTIONAL_HEADER64 OptionalHeader;
#else
				IMAGE_OPTIONAL_HEADER32 OptionalHeader;
#endif
			};

		} // namespace win

		// hashing stuff
		struct hash_t {
			using value_type                            = unsigned long;
			constexpr static value_type         offset = 2166136261;
			constexpr static value_type         prime = 16777619;
			constexpr static unsigned long long prime64 = prime;

			LAZY_IMPORTER_FORCEINLINE constexpr static value_type single(value_type value,
				char c) noexcept
			{
				return static_cast<hash_t::value_type>(
					(value ^ LAZY_IMPORTER_TOLOWER(c)) *
					static_cast<unsigned long long>(prime));
			}
		};

		template<class CharT = char>
		LAZY_IMPORTER_FORCEINLINE constexpr hash_t::value_type
			khash(const CharT * str, hash_t::value_type value = hash_t::offset) noexcept
		{
			return (*str ? khash(str + 1, hash_t::single(value, *str)) : value);
		}

		template<class CharT = char>
		LAZY_IMPORTER_FORCEINLINE hash_t::value_type hash(const CharT * str) noexcept
		{
			hash_t::value_type value = hash_t::offset;

			for (;;) {
				char c = *str++;
				if (!c)
					return value;
				value = hash_t::single(value, c);
			}
		}

		LAZY_IMPORTER_FORCEINLINE hash_t::value_type hash(
			const win::UNICODE_STRING_T& str) noexcept
		{
			auto       first = str.Buffer;
			const auto last = first + (str.Length / sizeof(wchar_t));
			auto       value = hash_t::offset;
			for (; first != last; ++first)
				value = hash_t::single(value, static_cast<char>(*first));

			return value;
		}

		LAZY_IMPORTER_FORCEINLINE pair<hash_t::value_type, hash_t::value_type> hash_forwarded(
			const char* str) noexcept
		{
			pair<hash_t::value_type, hash_t::value_type> module_and_function{
				hash_t::offset, hash_t::offset
			};

			for (; *str != '.'; ++str)
				hash_t::single(module_and_function.first, *str);

			++str;

			for (; *str; ++str)
				hash_t::single(module_and_function.second, *str);

			return module_and_function;
		}


		// some helper functions
		LAZY_IMPORTER_FORCEINLINE const win::PEB_T* peb() noexcept
		{
#if defined(_WIN64)
			return reinterpret_cast<const win::PEB_T*>(__readgsqword(0x60));
#elif defined(_WIN32)
			return reinterpret_cast<const win::PEB_T*>(__readfsdword(0x30));
#else
#error Unsupported platform. Open an issue and I'll probably add support.
#endif
		}

		LAZY_IMPORTER_FORCEINLINE const win::PEB_LDR_DATA_T* ldr()
		{
			return reinterpret_cast<const win::PEB_LDR_DATA_T*>(peb()->Ldr);
		}

		LAZY_IMPORTER_FORCEINLINE const win::IMAGE_NT_HEADERS* nt_headers(
			const char* base) noexcept
		{
			return reinterpret_cast<const win::IMAGE_NT_HEADERS*>(
				base + reinterpret_cast<const win::IMAGE_DOS_HEADER*>(base)->e_lfanew);
		}

		LAZY_IMPORTER_FORCEINLINE const win::IMAGE_EXPORT_DIRECTORY* image_export_dir(
			const char* base) noexcept
		{
			return reinterpret_cast<const win::IMAGE_EXPORT_DIRECTORY*>(
				base + nt_headers(base)->OptionalHeader.DataDirectory->VirtualAddress);
		}

		LAZY_IMPORTER_FORCEINLINE const win::LDR_DATA_TABLE_ENTRY_T* ldr_data_entry() noexcept
		{
			return reinterpret_cast<const win::LDR_DATA_TABLE_ENTRY_T*>(
				ldr()->InLoadOrderModuleList.Flink);
		}

		struct exports_directory {
			const char* _base;
			const win::IMAGE_EXPORT_DIRECTORY* _ied;
			unsigned long                      _ied_size;

		public:
			using size_type = unsigned long;

			LAZY_IMPORTER_FORCEINLINE
				exports_directory(const char* base) noexcept : _base(base)
			{
				const auto ied_data_dir = nt_headers(base)->OptionalHeader.DataDirectory[0];
				_ied = reinterpret_cast<const win::IMAGE_EXPORT_DIRECTORY*>(
					base + ied_data_dir.VirtualAddress);
				_ied_size = ied_data_dir.Size;
			}

			LAZY_IMPORTER_FORCEINLINE explicit operator bool() const noexcept
			{
				return reinterpret_cast<const char*>(_ied) != _base;
			}

			LAZY_IMPORTER_FORCEINLINE size_type size() const noexcept
			{
				return _ied->NumberOfNames;
			}

			LAZY_IMPORTER_FORCEINLINE const char* base() const noexcept { return _base; }
			LAZY_IMPORTER_FORCEINLINE const win::IMAGE_EXPORT_DIRECTORY* ied() const noexcept
			{
				return _ied;
			}

			LAZY_IMPORTER_FORCEINLINE const char* name(size_type index) const noexcept
			{
				return reinterpret_cast<const char*>(
					_base + reinterpret_cast<const unsigned long*>(
						_base + _ied->AddressOfNames)[index]);
			}

			LAZY_IMPORTER_FORCEINLINE const char* address(size_type index) const noexcept
			{
				const auto* const rva_table =
					reinterpret_cast<const unsigned long*>(_base + _ied->AddressOfFunctions);

				const auto* const ord_table = reinterpret_cast<const unsigned short*>(
					_base + _ied->AddressOfNameOrdinals);

				return _base + rva_table[ord_table[index]];
			}

			LAZY_IMPORTER_FORCEINLINE bool is_forwarded(const char* export_address) const
				noexcept
			{
				const auto ui_ied = reinterpret_cast<const char*>(_ied);
				return (export_address > ui_ied && export_address < ui_ied + _ied_size);
			}
		};

		struct safe_module_enumerator {
			using value_type = const detail::win::LDR_DATA_TABLE_ENTRY_T;
			value_type* value;
			value_type* const head;

			LAZY_IMPORTER_FORCEINLINE safe_module_enumerator() noexcept
				: value(ldr_data_entry()), head(value)
			{}

			LAZY_IMPORTER_FORCEINLINE void reset() noexcept { value = head; }

			LAZY_IMPORTER_FORCEINLINE bool next() noexcept
			{
				value = value->load_order_next();
				return value != head && value->DllBase;
			}
		};

		struct unsafe_module_enumerator {
			using value_type = const detail::win::LDR_DATA_TABLE_ENTRY_T*;
			value_type value;

			LAZY_IMPORTER_FORCEINLINE unsafe_module_enumerator() noexcept
				: value(ldr_data_entry())
			{}

			LAZY_IMPORTER_FORCEINLINE void reset() noexcept { value = ldr_data_entry(); }

			LAZY_IMPORTER_FORCEINLINE bool next() noexcept
			{
				value = value->load_order_next();
				return true;
			}
		};

		// provides the cached functions which use Derive classes methods
		template<class Derived, class DefaultType = void*>
		class lazy_base {
		protected:
			// This function is needed because every templated function
			// with different args has its own static buffer
			LAZY_IMPORTER_FORCEINLINE static void*& _cache() noexcept
			{
				static void* value = nullptr;
				return value;
			}

		public:
			template<class T = DefaultType>
			LAZY_IMPORTER_FORCEINLINE static T safe() noexcept
			{
				return Derived::template get<T, safe_module_enumerator>();
			}

			template<class T = DefaultType, class Enum = unsafe_module_enumerator>
			LAZY_IMPORTER_FORCEINLINE static T cached() noexcept
			{
				auto& cached = _cache();
				if (!cached)
					cached = Derived::template get<void*, Enum>();

				return (T)(cached);
			}

			template<class T = DefaultType>
			LAZY_IMPORTER_FORCEINLINE static T safe_cached() noexcept
			{
				return cached<T, safe_module_enumerator>();
			}
		};

		template<hash_t::value_type Hash>
		struct lazy_module : lazy_base<lazy_module<Hash>> {
			template<class T = void*, class Enum = unsafe_module_enumerator>
			LAZY_IMPORTER_FORCEINLINE static T get() noexcept
			{
				Enum e;
				do {
					if (hash(e.value->BaseDllName) == Hash)
						return (T)(e.value->DllBase);
				} while (e.next());
				return {};
			}
		};

		template<hash_t::value_type Hash, class T>
		struct lazy_function : lazy_base<lazy_function<Hash, T>, T> {
			using base_type = lazy_base<lazy_function<Hash, T>, T>;

			template<class... Args>
			LAZY_IMPORTER_FORCEINLINE decltype(auto) operator()(Args&& ... args) const
			{
#ifndef LAZY_IMPORTER_CACHE_OPERATOR_PARENS
				return get()(std::forward<Args>(args)...);
#else
				return this->cached()(std::forward<Args>(args)...);
#endif
			}

			template<class F = T, class Enum = unsafe_module_enumerator>
			LAZY_IMPORTER_FORCEINLINE static F get() noexcept
			{
				// for backwards compatability.
				// Before 2.0 it was only possible to resolve forwarded exports when
				// this macro was enabled
#ifdef LAZY_IMPORTER_RESOLVE_FORWARDED_EXPORTS
				return forwarded<F, Enum>();
#else
				Enum e;
				do {
					const exports_directory exports(e.value->DllBase);

					if (exports) {
						auto export_index = exports.size();
						while (export_index--)
							if (hash(exports.name(export_index)) == Hash)
								return (F)(exports.address(export_index));
					}
				} while (e.next());
				return {};
#endif
			}

			template<class F = T, class Enum = unsafe_module_enumerator>
			LAZY_IMPORTER_FORCEINLINE static F forwarded() noexcept
			{
				detail::win::UNICODE_STRING_T name;
				hash_t::value_type            module_hash = 0;
				auto                          function_hash = Hash;

				Enum e;
				do {
					name = e.value->BaseDllName;
					name.Length -= 8; // get rid of .dll extension

					if (!module_hash || hash(name) == module_hash) {
						const exports_directory exports(e.value->DllBase);

						if (exports) {
							auto export_index = exports.size();
							while (export_index--)
								if (hash(exports.name(export_index)) == function_hash) {
									const auto addr = exports.address(export_index);

									if (exports.is_forwarded(addr)) {
										auto hashes = hash_forwarded(
											reinterpret_cast<const char*>(addr));

										function_hash = hashes.second;
										module_hash = hashes.first;

										e.reset();
										break;
									}
									return (F)(addr);
								}
						}
					}
				} while (e.next());
				return {};
			}

			template<class F = T>
			LAZY_IMPORTER_FORCEINLINE static F forwarded_safe() noexcept
			{
				return forwarded<F, safe_module_enumerator>();
			}

			template<class F = T, class Enum = unsafe_module_enumerator>
			LAZY_IMPORTER_FORCEINLINE static F forwarded_cached() noexcept
			{
				auto& value = base_type::_cache();
				if (!value)
					value = forwarded<void*, Enum>();
				return (F)(value);
			}

			template<class F = T>
			LAZY_IMPORTER_FORCEINLINE static F forwarded_safe_cached() noexcept
			{
				return forwarded_cached<F, safe_module_enumerator>();
			}

			template<class F = T, bool IsSafe = false, class Module>
			LAZY_IMPORTER_FORCEINLINE static F in(Module m) noexcept
			{
				if (IsSafe && !m)
					return {};

				const exports_directory exports((const char*)(m));
				if (IsSafe && !exports)
					return {};

				for (unsigned long i{};; ++i) {
					if (IsSafe && i == exports.size())
						break;

					if (hash(exports.name(i)) == Hash)
						return (F)(exports.address(i));
				}
				return {};
			}

			template<class F = T, class Module>
			LAZY_IMPORTER_FORCEINLINE static F in_safe(Module m) noexcept
			{
				return in<F, true>(m);
			}

			template<class F = T, bool IsSafe = false, class Module>
			LAZY_IMPORTER_FORCEINLINE static F in_cached(Module m) noexcept
			{
				auto& value = base_type::_cache();
				if (!value)
					value = in<void*, IsSafe>(m);
				return (F)(value);
			}

			template<class F = T, class Module>
			LAZY_IMPORTER_FORCEINLINE static F in_safe_cached(Module m) noexcept
			{
				return in_cached<F, true>(m);
			}

			template<class F = T>
			LAZY_IMPORTER_FORCEINLINE static F nt() noexcept
			{
				return in<F>(ldr_data_entry()->load_order_next()->DllBase);
			}

			template<class F = T>
			LAZY_IMPORTER_FORCEINLINE static F nt_safe() noexcept
			{
				return in_safe<F>(ldr_data_entry()->load_order_next()->DllBase);
			}

			template<class F = T>
			LAZY_IMPORTER_FORCEINLINE static F nt_cached() noexcept
			{
				return in_cached<F>(ldr_data_entry()->load_order_next()->DllBase);
			}

			template<class F = T>
			LAZY_IMPORTER_FORCEINLINE static F nt_safe_cached() noexcept
			{
				return in_safe_cached<F>(ldr_data_entry()->load_order_next()->DllBase);
			}
		};

	}
} // namespace li::detail

#endif // include guard
```

`client/Loader/utils/Helpers/io.cpp`:

```cpp
#include "../include.h"
#include "io.h"

bool io::read_file(const std::string_view path, std::vector<char>& out) {
	std::ifstream file(path.data(), std::ios::binary);
	if (!file.good()) {
		log_error("{} isnt valid.", path);
		return false;
	}

	file.unsetf(std::ios::skipws);

	file.seekg(0, std::ios::end);
	const size_t size = file.tellg();
	file.seekg(0, std::ios::beg);

	out.resize(size);

	file.read(&out[0], size);

	file.close();

	return true;
}
```

`client/Loader/utils/Helpers/io.h`:

```h
#pragma once

#include <fmt/format.h>
#include <fmt/color.h>

#include "../client/enc.h"

namespace io {

	template<typename... Args>
	void log(const std::string_view str, Args... params) {
#ifndef _REL
		static auto handle = GetStdHandle(STD_OUTPUT_HANDLE);
		SetConsoleTextAttribute(handle, FOREGROUND_GREEN);
		fmt::print("[+] ");
		SetConsoleTextAttribute(handle, FOREGROUND_GREEN | FOREGROUND_BLUE | FOREGROUND_RED);

		std::string msg{ str };
		msg.append("\n");

		fmt::print(msg, std::forward<Args>(params)...);
#endif
	}

	template<typename... Args>
	void log_error(const std::string_view str, Args... params) {
#ifndef _REL
		static auto handle = GetStdHandle(STD_OUTPUT_HANDLE);
		SetConsoleTextAttribute(handle, FOREGROUND_RED);
		fmt::print("[!] ");
		SetConsoleTextAttribute(handle, FOREGROUND_GREEN | FOREGROUND_BLUE | FOREGROUND_RED);

		std::string msg{ str };
		msg.append("\n");

		fmt::print(msg, std::forward<Args>(params)...);
#endif
	}

	bool read_file(const std::string_view path, std::vector<char>& out);
};  // namespace io
```

`client/Loader/utils/Helpers/util.cpp`:

```cpp
#include "../../include.h"
#include "util.h"
#include "io.h"
#include "syscalls.h"

std::string util::wide_to_multibyte(const std::wstring& str) {
	std::string ret;
	size_t str_len;

	// check if not empty str
	if (str.empty())
		return{};

	// count size
	str_len = WideCharToMultiByte(CP_UTF8, 0, &str[0], str.size(), 0, 0, 0, 0);

	// setup return value
	ret.resize(str_len);

	// final conversion
	WideCharToMultiByte(CP_UTF8, 0, &str[0], str.size(), &ret[0], str_len, 0, 0);

	return ret;
}

std::wstring util::multibyte_to_wide(const std::string& str) {
	size_t      size;
	std::wstring out;

	// get size
	size = MultiByteToWideChar(CP_UTF8, 0, str.c_str(), str.size() + 1, 0, 0);

	out.resize(size);

	// finally convert
	MultiByteToWideChar(CP_UTF8, 0, str.c_str(), str.size() + 1, &out[0], size);

	return out;
}

bool util::close_handle(HANDLE handle) {
	static auto nt_close = g_syscalls.get<native::NtClose>("NtClose");

	auto status = nt_close(handle);
	if (!NT_SUCCESS(status)) {
		io::log_error("failed to close {}, status {:#X}.", handle, (status & 0xFFFFFFFF));
		return false;
	}

	return true;
}


bool pe::get_all_modules(std::unordered_map<std::string, virtual_image>& modules) {
	modules.clear();

	auto peb = util::peb();
	if (!peb) return false;

	if (!peb->Ldr->InMemoryOrderModuleList.Flink) return false;

	auto* list = &peb->Ldr->InMemoryOrderModuleList;

	for (auto i = list->Flink; i != list; i = i->Flink) {
		auto entry = CONTAINING_RECORD(i, native::LDR_DATA_TABLE_ENTRY, InMemoryOrderLinks);
		if (!entry)
			continue;

		auto name = util::wide_to_multibyte(entry->BaseDllName.Buffer);
		std::transform(name.begin(), name.end(), name.begin(), ::tolower);

		modules[name] = virtual_image(entry->DllBase);
	}

	return !modules.empty();
}
```

`client/Loader/utils/Helpers/util.h`:

```h
#pragma once

#include "native.h"

namespace util {
	std::string wide_to_multibyte(const std::wstring& str);
	std::wstring multibyte_to_wide(const std::string& str);

	__forceinline native::_PEB* peb() {
		return reinterpret_cast<native::_PEB*>(__readgsqword(0x60));
	}

	bool close_handle(HANDLE handle);

};  // namespace util

#include "../injection/pe.h"
```

`client/Loader/utils/advanced-utils/advanced_utils.cpp`:

```cpp
/*
			ADVANCED UTILITIES LIBRARY BY FLOWXRC
			MADE FOR SWIFTWARE
*/
#include "advanced_utils.hpp"

namespace utilities
{
	BOOL IsProcessRunning(DWORD pid)
	{
		HANDLE process = OpenProcess(SYNCHRONIZE, FALSE, pid);
		DWORD ret = WaitForSingleObject(process, 0);
		CloseHandle(process);
		return ret == WAIT_TIMEOUT;
	}
	_forceinline std::string get_random_string(size_t length)
	{
		const static std::string chrs = xorstr_("0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ");

		thread_local static std::mt19937 rg{ std::random_device{}() };
		thread_local static std::uniform_int_distribution<std::string::size_type> pick(0, sizeof(chrs) - 2);

		std::string s;

		s.reserve(length);

		while (length--)
			s += chrs[pick(rg)];

		return s;
	}

	__forceinline std::string get_hwid()
	{
		std::string m_sResult;

		HANDLE m_hFile = CreateFileW(L"\\\\.\\PhysicalDrive0", 0, FILE_SHARE_READ | FILE_SHARE_WRITE, NULL, OPEN_EXISTING, 0, NULL);
		if (m_hFile == INVALID_HANDLE_VALUE)
			return { };

		std::unique_ptr< std::remove_pointer <HANDLE >::type, void(*)(HANDLE) > m_hDevice
		{
			m_hFile, [](HANDLE handle)
			{
				CloseHandle(handle);
			}
		};

		STORAGE_PROPERTY_QUERY m_PropertyQuery;
		m_PropertyQuery.PropertyId = StorageDeviceProperty;
		m_PropertyQuery.QueryType = PropertyStandardQuery;

		STORAGE_DESCRIPTOR_HEADER m_DescHeader;
		DWORD m_dwBytesReturned = 0;
		if (!DeviceIoControl(m_hDevice.get(), IOCTL_STORAGE_QUERY_PROPERTY, &m_PropertyQuery, sizeof(STORAGE_PROPERTY_QUERY),
			&m_DescHeader, sizeof(STORAGE_DESCRIPTOR_HEADER), &m_dwBytesReturned, NULL))
			return { };

		const DWORD m_dwOutBufferSize = m_DescHeader.Size;
		std::unique_ptr< BYTE[] > m_pOutBuffer{ new BYTE[m_dwOutBufferSize] { } };

		if (!DeviceIoControl(m_hDevice.get(), IOCTL_STORAGE_QUERY_PROPERTY, &m_PropertyQuery, sizeof(STORAGE_PROPERTY_QUERY),
			m_pOutBuffer.get(), m_dwOutBufferSize, &m_dwBytesReturned, NULL))
			return { };

		STORAGE_DEVICE_DESCRIPTOR* m_pDeviceDescriptor = reinterpret_cast<STORAGE_DEVICE_DESCRIPTOR*>(m_pOutBuffer.get());
		const DWORD m_dwSerialNumberOffset = m_pDeviceDescriptor->SerialNumberOffset;
		if (m_dwSerialNumberOffset == 0)
			return { };

		m_sResult = reinterpret_cast<const char*>(m_pOutBuffer.get() + m_dwSerialNumberOffset);
		m_sResult.erase(std::remove_if(m_sResult.begin(), m_sResult.end(), std::isspace), m_sResult.end());

		return m_sResult;
	}

	HANDLE GetProcessByName(const char* name)
	{
		HANDLE hSnapshot = CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, NULL);

		PROCESSENTRY32 entry;
		entry.dwSize = sizeof(entry);
		HANDLE process;
		ZeroMemory(&process, sizeof(HANDLE));

		do {
			if (!strcmp(name, _bstr_t(entry.szExeFile)))
			{
				process = OpenProcess(PROCESS_ALL_ACCESS, false, entry.th32ProcessID);
				CloseHandle(hSnapshot);
			}
		} while (Process32Next(hSnapshot, &entry));

		return process;
	}
}
```

`client/Loader/utils/advanced-utils/advanced_utils.hpp`:

```hpp
/*
			ADVANCED UTILITIES LIBRARY BY FLOWXRC
			MADE FOR SWIFTWARE
*/
#pragma once
#include <string>
#include <random>
#define VC_EXTRALEAN
#include <Windows.h>
#include <tlhelp32.h>
#include <stdio.h>
#include <shlwapi.h>
#include <memory>
#include <comdef.h>
#pragma comment(lib, "th32.lib")
#include "../lazy-importer/lazy_importer.hpp"

namespace utilities
{
	extern __forceinline std::string get_random_string(size_t length);
	extern __forceinline std::string get_hwid();
	extern HANDLE GetProcessByName(const char* name);
	BOOL IsProcessRunning(DWORD pid);
}
```

`client/Loader/utils/encrypt-decrypt/xorstr.hpp`:

```hpp
/*
 * Copyright 2017 - 2018 Justas Masiulis
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

#ifndef JM_XORSTR_HPP
#define JM_XORSTR_HPP

#include <immintrin.h>
#include <cstdint>
#include <cstddef>
#include <utility>

#define xorstr(str)                                              \
    ::jm::make_xorstr(                                           \
        []() { return str; },                                    \
        std::make_index_sequence<sizeof(str) / sizeof(*str)>{},  \
        std::make_index_sequence<::jm::detail::_buffer_size<sizeof(str)>()>{})
#define xorstr_(str) xorstr(str).crypt_get()

#ifdef _MSC_VER
#define XORSTR_FORCEINLINE __forceinline
#else
#define XORSTR_FORCEINLINE __attribute__((always_inline))
#endif

 // you can define this macro to get possibly faster code on gcc/clang
 // at the expense of constants being put into data section.
#if !defined(XORSTR_ALLOW_DATA)
// MSVC - no volatile
// GCC and clang - volatile everywhere
#if defined(__clang__) || defined(__GNUC__)
#define XORSTR_VOLATILE volatile
#endif

#endif
#ifndef XORSTR_VOLATILE
#define XORSTR_VOLATILE
#endif

namespace jm {

	namespace detail {

		template<std::size_t S>
		struct unsigned_;

		template<>
		struct unsigned_<1> {
			using type = std::uint8_t;
		};
		template<>
		struct unsigned_<2> {
			using type = std::uint16_t;
		};
		template<>
		struct unsigned_<4> {
			using type = std::uint32_t;
		};

		template<auto C, auto...>
		struct pack_value_type {
			using type = decltype(C);
		};

		template<std::size_t Size>
		constexpr std::size_t _buffer_size()
		{
			return ((Size / 16) + (Size % 16 != 0)) * 2;
		}

		template<auto... Cs>
		struct tstring_ {
			using value_type = typename pack_value_type<Cs...>::type;
			constexpr static std::size_t size = sizeof...(Cs);
			constexpr static value_type  str[size] = { Cs... };

			constexpr static std::size_t buffer_size = _buffer_size<sizeof(str)>();
			constexpr static std::size_t buffer_align =
#ifndef JM_XORSTR_DISABLE_AVX_INTRINSICS
			((sizeof(str) > 16) ? 32 : 16);
#else
				16;
#endif
		};

		template<std::size_t I, std::uint64_t K>
		struct _ki {
			constexpr static std::size_t   idx = I;
			constexpr static std::uint64_t key = K;
		};

		template<std::uint32_t Seed>
		constexpr std::uint32_t key4() noexcept
		{
			std::uint32_t value = Seed;
			for (char c : __TIME__)
				value = static_cast<std::uint32_t>((value ^ c) * 16777619ull);
			return value;
		}

		template<std::size_t S>
		constexpr std::uint64_t key8()
		{
			constexpr auto first_part = key4<2166136261 + S>();
			constexpr auto second_part = key4<first_part>();
			return (static_cast<std::uint64_t>(first_part) << 32) | second_part;
		}

		// clang and gcc try really hard to place the constants in data
		// sections. to counter that there was a need to create an intermediate
		// constexpr string and then copy it into a non constexpr container with
		// volatile storage so that the constants would be placed directly into
		// code.
		template<class T, std::uint64_t... Keys>
		struct string_storage {
			std::uint64_t storage[T::buffer_size];

			XORSTR_FORCEINLINE constexpr string_storage() noexcept : storage{ Keys... }
			{
				using cast_type =
					typename unsigned_<sizeof(typename T::value_type)>::type;
				constexpr auto value_size = sizeof(typename T::value_type);
				// puts the string into 64 bit integer blocks in a constexpr
				// fashion
				for (std::size_t i = 0; i < T::size; ++i)
					storage[i / (8 / value_size)] ^=
					(std::uint64_t{ static_cast<cast_type>(T::str[i]) }
				<< ((i % (8 / value_size)) * 8 * value_size));
			}
		};

	} // namespace detail

	template<class T, class... Keys>
	class xor_string {
		alignas(T::buffer_align) std::uint64_t _storage[T::buffer_size];

		// _single functions needed because MSVC crashes without them
		XORSTR_FORCEINLINE void _crypt_256_single(const std::uint64_t* keys,
			std::uint64_t* storage) noexcept

		{
			_mm256_store_si256(
				reinterpret_cast<__m256i*>(storage),
				_mm256_xor_si256(
					_mm256_load_si256(reinterpret_cast<const __m256i*>(storage)),
					_mm256_load_si256(reinterpret_cast<const __m256i*>(keys))));
		}

		template<std::size_t... Idxs>
		XORSTR_FORCEINLINE void _crypt_256(const std::uint64_t* keys,
			std::index_sequence<Idxs...>) noexcept
		{
			(_crypt_256_single(keys + Idxs * 4, _storage + Idxs * 4), ...);
		}

		XORSTR_FORCEINLINE void _crypt_128_single(const std::uint64_t* keys,
			std::uint64_t* storage) noexcept
		{
			_mm_store_si128(
				reinterpret_cast<__m128i*>(storage),
				_mm_xor_si128(_mm_load_si128(reinterpret_cast<const __m128i*>(storage)),
					_mm_load_si128(reinterpret_cast<const __m128i*>(keys))));
		}

		template<std::size_t... Idxs>
		XORSTR_FORCEINLINE void _crypt_128(const std::uint64_t* keys,
			std::index_sequence<Idxs...>) noexcept
		{
			(_crypt_128_single(keys + Idxs * 2, _storage + Idxs * 2), ...);
		}

		// loop generates vectorized code which places constants in data dir
		XORSTR_FORCEINLINE constexpr void _copy() noexcept
		{
			constexpr detail::string_storage<T, Keys::key...> storage;
			static_cast<void>(std::initializer_list<std::uint64_t>{
				(const_cast<XORSTR_VOLATILE std::uint64_t*>(_storage))[Keys::idx] =
					storage.storage[Keys::idx]... });
		}

	public:
		using value_type = typename T::value_type;
		using size_type = std::size_t;
		using pointer = value_type*;
		using const_pointer = const pointer;

		XORSTR_FORCEINLINE xor_string() noexcept { _copy(); }

		XORSTR_FORCEINLINE constexpr size_type size() const noexcept
		{
			return T::size - 1;
		}

		XORSTR_FORCEINLINE void crypt() noexcept
		{
			alignas(T::buffer_align) std::uint64_t keys[T::buffer_size];
			static_cast<void>(std::initializer_list<std::uint64_t>{
				(const_cast<XORSTR_VOLATILE std::uint64_t*>(keys))[Keys::idx] =
					Keys::key... });

			_copy();

#ifndef JM_XORSTR_DISABLE_AVX_INTRINSICS
			_crypt_256(keys, std::make_index_sequence<T::buffer_size / 4>{});
			if constexpr (T::buffer_size % 4 != 0)
				_crypt_128(keys, std::index_sequence<T::buffer_size / 2 - 1>{});
#else
			_crypt_128(keys, std::make_index_sequence<T::buffer_size / 2>{});
#endif
		}

		XORSTR_FORCEINLINE const_pointer get() const noexcept
		{
			return reinterpret_cast<const_pointer>(_storage);
		}

		XORSTR_FORCEINLINE const_pointer crypt_get() noexcept
		{
			crypt();
			return reinterpret_cast<const_pointer>(_storage);
		}
	};

	template<class Tstr, std::size_t... StringIndices, std::size_t... KeyIndices>
	XORSTR_FORCEINLINE constexpr auto
		make_xorstr(Tstr str_lambda,
			std::index_sequence<StringIndices...>,
			std::index_sequence<KeyIndices...>) noexcept
	{
		return xor_string<detail::tstring_<str_lambda()[StringIndices]...>,
			detail::_ki<KeyIndices, detail::key8<KeyIndices>()>...>{};
	}

} // namespace jm

#endif // include guard

#define _xor_(s) std::string(xorstr_(s))
```

`client/Loader/utils/inject/Helpers/GetProcId.cpp`:

```cpp
#include "GetProcId.hpp"

namespace helpers {
    DWORD GetProcId(const char* procName)
	{
        DWORD procId = 0;
        HANDLE hSnap = CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, 0);

        if (hSnap != INVALID_HANDLE_VALUE)
        {
            PROCESSENTRY32 procEntry;
            procEntry.dwSize = sizeof(procEntry);

            if (Process32First(hSnap, &procEntry))
            {
                do
                {
                    if (!_stricmp(procEntry.szExeFile, procName))
                    {
                        procId = procEntry.th32ProcessID;
                        break;
                    }
                } while (Process32Next(hSnap, &procEntry));
            }
        }
        CloseHandle(hSnap);
        return procId;
	}
}
```

`client/Loader/utils/inject/Helpers/GetProcId.hpp`:

```hpp
#pragma once
#include <string>
#include <Windows.h>
#define RC_INVOKED
#include <handleapi.h>
#include <TlHelp32.h>

namespace helpers
{
	extern DWORD GetProcId(const char* procName);
}
```

`client/Loader/utils/inject/inject.cpp`:

```cpp
// for swiftware

#include "inject.hpp"

std::string getPath(int csidl) {
    char out[MAX_PATH];
    if (SHGetSpecialFolderPathA(NULL, out, csidl, 0))
        return out;
    return NULL;
}

void HideConsole()
{
    ::ShowWindow(::GetConsoleWindow(), SW_HIDE);
}

namespace uLoaderInjector
{
	int inject_cheat()
	{
        std::string dllPath = getPath(CSIDL_APPDATA);
        dllPath += "\\";
        dllPath += utilities::get_random_string(16);
        dllPath += ".dll";
        string link = xorstr_("https://") + Globals::server_side.server + xorstr_("/client/download.php?key=") + Globals::server_side.secret_key;
        WebClient::DownloadFile(link.c_str(), dllPath.c_str());
        DWORD procId = helpers::GetProcId("csgo.exe");
        HANDLE hProcessId = CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, 0);

        auto h_proc = OpenProcess(PROCESS_ALL_ACCESS, 0, procId);

        if (h_proc && h_proc != INVALID_HANDLE_VALUE)
        {
            const LPVOID nt_open_file = GetProcAddress(LoadLibraryW(L"ntdll"), "NtOpenFile");
            if (nt_open_file)
            {
                char original_bytes[5];
                memcpy(original_bytes, nt_open_file, 5);
                WriteProcessMemory(h_proc, nt_open_file, original_bytes, 5, nullptr);
            }
            auto* loc = VirtualAllocEx(h_proc, nullptr, MAX_PATH, MEM_COMMIT | MEM_RESERVE, PAGE_READWRITE);
            WriteProcessMemory(h_proc, loc, dllPath.c_str(), strlen(dllPath.c_str()) + 1, nullptr);
            auto* const h_thread = CreateRemoteThread(h_proc, nullptr, 0, reinterpret_cast<LPTHREAD_START_ROUTINE>(LoadLibraryA), loc, 0, nullptr);
            if (h_thread) CloseHandle(h_thread);
        }
        cout << xorstr_("[+] Cheat Loaded. Have Fun!\n");
        Sleep(3000);
        HideConsole();
        while (true)
        {
            if (!utilities::IsProcessRunning(helpers::GetProcId("csgo.exe"))) {
                std::remove(dllPath.c_str());
                break;
            }
            Sleep(500);
        }
        return 0;
	}
}
```

`client/Loader/utils/inject/inject.hpp`:

```hpp
#pragma once
#define _CRT_SECURE_NO_WARNINGS
#include <iostream>
#include <string>
#include <Windows.h>
#include <TlHelp32.h>
#include <io.h>
#define RC_INVOKED
#include <handleapi.h>
#include <wininet.h>
#include <string>
#include <tchar.h>
#include <vector>
#include <urlmon.h>
#include <shlobj.h>
#include <filesystem>
#include <fstream>
#include <cstdio>
#pragma comment(lib, "WinINet.lib")
#pragma comment(lib, "Ws2_32.lib")
#pragma comment(lib, "urlmon.lib")
#include "Helpers/GetProcId.hpp"
#include "../webclient/webclient.hpp"
#include "../encrypt-decrypt/xorstr.hpp"
#include "../../headers/globals.hpp"

namespace uLoaderInjector {
	extern int inject_cheat();
}
```

`client/Loader/utils/lazy-importer/lazy_importer.hpp`:

```hpp
/*
 * Copyright 2018 Justas Masiulis
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

// documentation is available at https://github.com/JustasMasiulis/lazy_importer

#ifndef LAZY_IMPORTER_HPP
#define LAZY_IMPORTER_HPP

#define li(s) LI_FN(s).get()

#define LI_FN(name) \
    ::li::detail::lazy_function<::li::detail::khash(#name), decltype(&name)>()

#define LI_FN_DEF(name) ::li::detail::lazy_function<::li::detail::khash(#name), name>()

#define LI_MODULE(name) ::li::detail::lazy_module<::li::detail::khash(name)>()

// NOTE only std::forward is used from this header.
// If there is a need to eliminate this dependency the function itself is very small.
#include <utility>
#include <cstddef>
#include <intrin.h>

#define JM_XORSTR_DISABLE_AVX_INTRINSICS

#include "../encrypt-decrypt/xorstr.hpp"

#define _xor_(s) std::string(xorstr_(s))

#ifndef LAZY_IMPORTER_NO_FORCEINLINE
#if defined(_MSC_VER)
#define LAZY_IMPORTER_FORCEINLINE __forceinline
#elif defined(__GNUC__) && __GNUC__ > 3
#define LAZY_IMPORTER_FORCEINLINE inline __attribute__((__always_inline__))
#else
#define LAZY_IMPORTER_FORCEINLINE inline
#endif
#else
#define LAZY_IMPORTER_FORCEINLINE inline
#endif

#ifdef LAZY_IMPORTER_CASE_INSENSITIVE
#define LAZY_IMPORTER_TOLOWER(c) (c >= 'A' && c <= 'Z' ? (c | (1 << 5)) : c)
#else
#define LAZY_IMPORTER_TOLOWER(c) (c)
#endif

namespace li { namespace detail {

    template<class First, class Second>
    struct pair {
        First  first;
        Second second;
    };

    namespace win {

        struct LIST_ENTRY_T {
            const char* Flink;
            const char* Blink;
        };

        struct UNICODE_STRING_T {
            unsigned short Length;
            unsigned short MaximumLength;
            wchar_t*       Buffer;
        };

        struct PEB_LDR_DATA_T {
            unsigned long Length;
            unsigned long Initialized;
            const char*   SsHandle;
            LIST_ENTRY_T  InLoadOrderModuleList;
        };

        struct PEB_T {
            unsigned char   Reserved1[2];
            unsigned char   BeingDebugged;
            unsigned char   Reserved2[1];
            const char*     Reserved3[2];
            PEB_LDR_DATA_T* Ldr;
        };

        struct LDR_DATA_TABLE_ENTRY_T {
            LIST_ENTRY_T InLoadOrderLinks;
            LIST_ENTRY_T InMemoryOrderLinks;
            LIST_ENTRY_T InInitializationOrderLinks;
            const char*  DllBase;
            const char*  EntryPoint;
            union {
                unsigned long SizeOfImage;
                const char*   _dummy;
            };
            UNICODE_STRING_T FullDllName;
            UNICODE_STRING_T BaseDllName;

            LAZY_IMPORTER_FORCEINLINE const LDR_DATA_TABLE_ENTRY_T*
                                            load_order_next() const noexcept
            {
                return reinterpret_cast<const LDR_DATA_TABLE_ENTRY_T*>(
                    InLoadOrderLinks.Flink);
            }
        };

        struct IMAGE_DOS_HEADER { // DOS .EXE header
            unsigned short e_magic; // Magic number
            unsigned short e_cblp; // BYTEs on last page of file
            unsigned short e_cp; // Pages in file
            unsigned short e_crlc; // Relocations
            unsigned short e_cparhdr; // Size of header in paragraphs
            unsigned short e_minalloc; // Minimum extra paragraphs needed
            unsigned short e_maxalloc; // Maximum extra paragraphs needed
            unsigned short e_ss; // Initial (relative) SS value
            unsigned short e_sp; // Initial SP value
            unsigned short e_csum; // Checksum
            unsigned short e_ip; // Initial IP value
            unsigned short e_cs; // Initial (relative) CS value
            unsigned short e_lfarlc; // File address of relocation table
            unsigned short e_ovno; // Overlay number
            unsigned short e_res[4]; // Reserved words
            unsigned short e_oemid; // OEM identifier (for e_oeminfo)
            unsigned short e_oeminfo; // OEM information; e_oemid specific
            unsigned short e_res2[10]; // Reserved words
            long           e_lfanew; // File address of new exe header
        };

        struct IMAGE_FILE_HEADER {
            unsigned short Machine;
            unsigned short NumberOfSections;
            unsigned long  TimeDateStamp;
            unsigned long  PointerToSymbolTable;
            unsigned long  NumberOfSymbols;
            unsigned short SizeOfOptionalHeader;
            unsigned short Characteristics;
        };

        struct IMAGE_EXPORT_DIRECTORY {
            unsigned long  Characteristics;
            unsigned long  TimeDateStamp;
            unsigned short MajorVersion;
            unsigned short MinorVersion;
            unsigned long  Name;
            unsigned long  Base;
            unsigned long  NumberOfFunctions;
            unsigned long  NumberOfNames;
            unsigned long  AddressOfFunctions; // RVA from base of image
            unsigned long  AddressOfNames; // RVA from base of image
            unsigned long  AddressOfNameOrdinals; // RVA from base of image
        };

        struct IMAGE_DATA_DIRECTORY {
            unsigned long VirtualAddress;
            unsigned long Size;
        };

        struct IMAGE_OPTIONAL_HEADER64 {
            unsigned short       Magic;
            unsigned char        MajorLinkerVersion;
            unsigned char        MinorLinkerVersion;
            unsigned long        SizeOfCode;
            unsigned long        SizeOfInitializedData;
            unsigned long        SizeOfUninitializedData;
            unsigned long        AddressOfEntryPoint;
            unsigned long        BaseOfCode;
            unsigned long long   ImageBase;
            unsigned long        SectionAlignment;
            unsigned long        FileAlignment;
            unsigned short       MajorOperatingSystemVersion;
            unsigned short       MinorOperatingSystemVersion;
            unsigned short       MajorImageVersion;
            unsigned short       MinorImageVersion;
            unsigned short       MajorSubsystemVersion;
            unsigned short       MinorSubsystemVersion;
            unsigned long        Win32VersionValue;
            unsigned long        SizeOfImage;
            unsigned long        SizeOfHeaders;
            unsigned long        CheckSum;
            unsigned short       Subsystem;
            unsigned short       DllCharacteristics;
            unsigned long long   SizeOfStackReserve;
            unsigned long long   SizeOfStackCommit;
            unsigned long long   SizeOfHeapReserve;
            unsigned long long   SizeOfHeapCommit;
            unsigned long        LoaderFlags;
            unsigned long        NumberOfRvaAndSizes;
            IMAGE_DATA_DIRECTORY DataDirectory[16];
        };

        struct IMAGE_OPTIONAL_HEADER32 {
            unsigned short       Magic;
            unsigned char        MajorLinkerVersion;
            unsigned char        MinorLinkerVersion;
            unsigned long        SizeOfCode;
            unsigned long        SizeOfInitializedData;
            unsigned long        SizeOfUninitializedData;
            unsigned long        AddressOfEntryPoint;
            unsigned long        BaseOfCode;
            unsigned long        BaseOfData;
            unsigned long        ImageBase;
            unsigned long        SectionAlignment;
            unsigned long        FileAlignment;
            unsigned short       MajorOperatingSystemVersion;
            unsigned short       MinorOperatingSystemVersion;
            unsigned short       MajorImageVersion;
            unsigned short       MinorImageVersion;
            unsigned short       MajorSubsystemVersion;
            unsigned short       MinorSubsystemVersion;
            unsigned long        Win32VersionValue;
            unsigned long        SizeOfImage;
            unsigned long        SizeOfHeaders;
            unsigned long        CheckSum;
            unsigned short       Subsystem;
            unsigned short       DllCharacteristics;
            unsigned long        SizeOfStackReserve;
            unsigned long        SizeOfStackCommit;
            unsigned long        SizeOfHeapReserve;
            unsigned long        SizeOfHeapCommit;
            unsigned long        LoaderFlags;
            unsigned long        NumberOfRvaAndSizes;
            IMAGE_DATA_DIRECTORY DataDirectory[16];
        };

        struct IMAGE_NT_HEADERS {
            unsigned long     Signature;
            IMAGE_FILE_HEADER FileHeader;
#ifdef _WIN64
            IMAGE_OPTIONAL_HEADER64 OptionalHeader;
#else
            IMAGE_OPTIONAL_HEADER32 OptionalHeader;
#endif
        };

    } // namespace win

    // hashing stuff
    struct hash_t {
        using value_type                            = unsigned long;
        constexpr static value_type         offset  = 2166136261;
        constexpr static value_type         prime   = 16777619;
        constexpr static unsigned long long prime64 = prime;

        LAZY_IMPORTER_FORCEINLINE constexpr static value_type single(value_type value,
                                                                     char c) noexcept
        {
            return static_cast<hash_t::value_type>(
                (value ^ LAZY_IMPORTER_TOLOWER(c)) *
                static_cast<unsigned long long>(prime));
        }
    };

    template<class CharT = char>
    LAZY_IMPORTER_FORCEINLINE constexpr hash_t::value_type
    khash(const CharT* str, hash_t::value_type value = hash_t::offset) noexcept
    {
        return (*str ? khash(str + 1, hash_t::single(value, *str)) : value);
    }

    template<class CharT = char>
    LAZY_IMPORTER_FORCEINLINE hash_t::value_type hash(const CharT* str) noexcept
    {
        hash_t::value_type value = hash_t::offset;

        for(;;) {
            char c = *str++;
            if(!c)
                return value;
            value = hash_t::single(value, c);
        }
    }

    LAZY_IMPORTER_FORCEINLINE hash_t::value_type hash(
        const win::UNICODE_STRING_T& str) noexcept
    {
        auto       first = str.Buffer;
        const auto last  = first + (str.Length / sizeof(wchar_t));
        auto       value = hash_t::offset;
        for(; first != last; ++first)
            value = hash_t::single(value, static_cast<char>(*first));

        return value;
    }

    LAZY_IMPORTER_FORCEINLINE pair<hash_t::value_type, hash_t::value_type> hash_forwarded(
        const char* str) noexcept
    {
        pair<hash_t::value_type, hash_t::value_type> module_and_function{
            hash_t::offset, hash_t::offset
        };

        for(; *str != '.'; ++str)
            hash_t::single(module_and_function.first, *str);

        ++str;

        for(; *str; ++str)
            hash_t::single(module_and_function.second, *str);

        return module_and_function;
    }


    // some helper functions
    LAZY_IMPORTER_FORCEINLINE const win::PEB_T* peb() noexcept
    {
#if defined(_WIN64)
        return reinterpret_cast<const win::PEB_T*>(__readgsqword(0x60));
#elif defined(_WIN32)
        return reinterpret_cast<const win::PEB_T*>(__readfsdword(0x30));
#else
#error Unsupported platform. Open an issue and I'll probably add support.
#endif
    }

    LAZY_IMPORTER_FORCEINLINE const win::PEB_LDR_DATA_T* ldr()
    {
        return reinterpret_cast<const win::PEB_LDR_DATA_T*>(peb()->Ldr);
    }

    LAZY_IMPORTER_FORCEINLINE const win::IMAGE_NT_HEADERS* nt_headers(
        const char* base) noexcept
    {
        return reinterpret_cast<const win::IMAGE_NT_HEADERS*>(
            base + reinterpret_cast<const win::IMAGE_DOS_HEADER*>(base)->e_lfanew);
    }

    LAZY_IMPORTER_FORCEINLINE const win::IMAGE_EXPORT_DIRECTORY* image_export_dir(
        const char* base) noexcept
    {
        return reinterpret_cast<const win::IMAGE_EXPORT_DIRECTORY*>(
            base + nt_headers(base)->OptionalHeader.DataDirectory->VirtualAddress);
    }

    LAZY_IMPORTER_FORCEINLINE const win::LDR_DATA_TABLE_ENTRY_T* ldr_data_entry() noexcept
    {
        return reinterpret_cast<const win::LDR_DATA_TABLE_ENTRY_T*>(
            ldr()->InLoadOrderModuleList.Flink);
    }

    struct exports_directory {
        const char*                        _base;
        const win::IMAGE_EXPORT_DIRECTORY* _ied;
        unsigned long                      _ied_size;

    public:
        using size_type = unsigned long;

        LAZY_IMPORTER_FORCEINLINE
        exports_directory(const char* base) noexcept : _base(base)
        {
            const auto ied_data_dir = nt_headers(base)->OptionalHeader.DataDirectory[0];
            _ied = reinterpret_cast<const win::IMAGE_EXPORT_DIRECTORY*>(
                base + ied_data_dir.VirtualAddress);
            _ied_size = ied_data_dir.Size;
        }

        LAZY_IMPORTER_FORCEINLINE explicit operator bool() const noexcept
        {
            return reinterpret_cast<const char*>(_ied) != _base;
        }

        LAZY_IMPORTER_FORCEINLINE size_type size() const noexcept
        {
            return _ied->NumberOfNames;
        }

        LAZY_IMPORTER_FORCEINLINE const char* base() const noexcept { return _base; }
        LAZY_IMPORTER_FORCEINLINE const win::IMAGE_EXPORT_DIRECTORY* ied() const noexcept
        {
            return _ied;
        }

        LAZY_IMPORTER_FORCEINLINE const char* name(size_type index) const noexcept
        {
            return reinterpret_cast<const char*>(
                _base + reinterpret_cast<const unsigned long*>(
                            _base + _ied->AddressOfNames)[index]);
        }

        LAZY_IMPORTER_FORCEINLINE const char* address(size_type index) const noexcept
        {
            const auto* const rva_table =
                reinterpret_cast<const unsigned long*>(_base + _ied->AddressOfFunctions);

            const auto* const ord_table = reinterpret_cast<const unsigned short*>(
                _base + _ied->AddressOfNameOrdinals);

            return _base + rva_table[ord_table[index]];
        }

        LAZY_IMPORTER_FORCEINLINE bool is_forwarded(const char* export_address) const
            noexcept
        {
            const auto ui_ied = reinterpret_cast<const char*>(_ied);
            return (export_address > ui_ied && export_address < ui_ied + _ied_size);
        }
    };

    struct safe_module_enumerator {
        using value_type = const detail::win::LDR_DATA_TABLE_ENTRY_T;
        value_type*       value;
        value_type* const head;

        LAZY_IMPORTER_FORCEINLINE safe_module_enumerator() noexcept
            : value(ldr_data_entry()), head(value)
        {}

        LAZY_IMPORTER_FORCEINLINE void reset() noexcept { value = head; }

        LAZY_IMPORTER_FORCEINLINE bool next() noexcept
        {
            value = value->load_order_next();
            return value != head;
        }
    };

    struct unsafe_module_enumerator {
        using value_type = const detail::win::LDR_DATA_TABLE_ENTRY_T*;
        value_type value;

        LAZY_IMPORTER_FORCEINLINE unsafe_module_enumerator() noexcept
            : value(ldr_data_entry())
        {}

        LAZY_IMPORTER_FORCEINLINE void reset() noexcept { value = ldr_data_entry(); }

        LAZY_IMPORTER_FORCEINLINE bool next() noexcept
        {
            value = value->load_order_next();
            return true;
        }
    };

    // provides the cached functions which use Derive classes methods
    template<class Derived, class DefaultType = void*>
    class lazy_base {
    protected:
        // This function is needed because every templated function
        // with different args has its own static buffer
        LAZY_IMPORTER_FORCEINLINE static void*& _cache() noexcept
        {
            static void* value = nullptr;
            return value;
        }

    public:
        template<class T = DefaultType>
        LAZY_IMPORTER_FORCEINLINE static T safe() noexcept
        {
            return Derived::template get<T, safe_module_enumerator>();
        }

        template<class T = DefaultType, class Enum = unsafe_module_enumerator>
        LAZY_IMPORTER_FORCEINLINE static T cached() noexcept
        {
            auto& cached = _cache();
            if(!cached)
                cached = Derived::template get<void*, Enum>();

            return (T)(cached);
        }

        template<class T = DefaultType>
        LAZY_IMPORTER_FORCEINLINE static T safe_cached() noexcept
        {
            return cached<T, safe_module_enumerator>();
        }
    };

    template<hash_t::value_type Hash>
    struct lazy_module : lazy_base<lazy_module<Hash>> {
        template<class T = void*, class Enum = unsafe_module_enumerator>
        LAZY_IMPORTER_FORCEINLINE static T get() noexcept
        {
            Enum e;
            do {
                if(hash(e.value->BaseDllName) == Hash)
                    return (T)(e.value->DllBase);
            } while(e.next());
            return {};
        }
    };

    template<hash_t::value_type Hash, class T>
    struct lazy_function : lazy_base<lazy_function<Hash, T>, T> {
        using base_type = lazy_base<lazy_function<Hash, T>, T>;

        template<class... Args>
        LAZY_IMPORTER_FORCEINLINE decltype(auto) operator()(Args&&... args) const
        {
#ifndef LAZY_IMPORTER_CACHE_OPERATOR_PARENS
            return get()(std::forward<Args>(args)...);
#else
            return this->cached()(std::forward<Args>(args)...);
#endif
        }

        template<class F = T, class Enum = unsafe_module_enumerator>
        LAZY_IMPORTER_FORCEINLINE static F get() noexcept
        {
            // for backwards compatability.
            // Before 2.0 it was only possible to resolve forwarded exports when
            // this macro was enabled
#ifdef LAZY_IMPORTER_RESOLVE_FORWARDED_EXPORTS
            return forwarded<F, Enum>();
#else
            Enum e;
            do {
                const exports_directory exports(e.value->DllBase);

                if(exports) {
                    auto export_index = exports.size();
                    while(export_index--)
                        if(hash(exports.name(export_index)) == Hash)
                            return (F)(exports.address(export_index));
                }
            } while(e.next());
            return {};
#endif
        }

        template<class F = T, class Enum = unsafe_module_enumerator>
        LAZY_IMPORTER_FORCEINLINE static F forwarded() noexcept
        {
            detail::win::UNICODE_STRING_T name;
            hash_t::value_type            module_hash   = 0;
            auto                          function_hash = Hash;

            Enum e;
            do {
                name = e.value->BaseDllName;
                name.Length -= 8; // get rid of .dll extension

                if(!module_hash || hash(name) == module_hash) {
                    const exports_directory exports(e.value->DllBase);

                    if(exports) {
                        auto export_index = exports.size();
                        while(export_index--)
                            if(hash(exports.name(export_index)) == function_hash) {
                                const auto addr = exports.address(export_index);

                                if(exports.is_forwarded(addr)) {
                                    auto hashes = hash_forwarded(
                                        reinterpret_cast<const char*>(addr));

                                    function_hash = hashes.second;
                                    module_hash   = hashes.first;

                                    e.reset();
                                    break;
                                }
                                return (F)(addr);
                            }
                    }
                }
            } while(e.next());
            return {};
        }

        template<class F = T>
        LAZY_IMPORTER_FORCEINLINE static F forwarded_safe() noexcept
        {
            return forwarded<F, safe_module_enumerator>();
        }

        template<class F = T, class Enum = unsafe_module_enumerator>
        LAZY_IMPORTER_FORCEINLINE static F forwarded_cached() noexcept
        {
            auto& value = base_type::_cache();
            if(!value)
                value = forwarded<void*, Enum>();
            return (F)(value);
        }

        template<class F = T>
        LAZY_IMPORTER_FORCEINLINE static F forwarded_safe_cached() noexcept
        {
            return forwarded_cached<F, safe_module_enumerator>();
        }

        template<class F = T, bool IsSafe = false, class Module>
        LAZY_IMPORTER_FORCEINLINE static F in(Module m) noexcept
        {
            if(IsSafe && !m)
                return {};

            const exports_directory exports((const char*)(m));
            if(IsSafe && !exports)
                return {};

            for(unsigned long i{};; ++i) {
                if(IsSafe && i == exports.size())
                    break;

                if(hash(exports.name(i)) == Hash)
                    return (F)(exports.address(i));
            }
            return {};
        }

        template<class F = T, class Module>
        LAZY_IMPORTER_FORCEINLINE static F in_safe(Module m) noexcept
        {
            return in<F, true>(m);
        }

        template<class F = T, bool IsSafe = false, class Module>
        LAZY_IMPORTER_FORCEINLINE static F in_cached(Module m) noexcept
        {
            auto& value = base_type::_cache();
            if(!value)
                value = in<void*, IsSafe>(m);
            return (F)(value);
        }

        template<class F = T, class Module>
        LAZY_IMPORTER_FORCEINLINE static F in_safe_cached(Module m) noexcept
        {
            return in_cached<F, true>(m);
        }

        template<class F = T>
        LAZY_IMPORTER_FORCEINLINE static F nt() noexcept
        {
            return in<F>(ldr_data_entry()->load_order_next()->DllBase);
        }

        template<class F = T>
        LAZY_IMPORTER_FORCEINLINE static F nt_safe() noexcept
        {
            return in_safe<F>(ldr_data_entry()->load_order_next()->DllBase);
        }

        template<class F = T>
        LAZY_IMPORTER_FORCEINLINE static F nt_cached() noexcept
        {
            return in_cached<F>(ldr_data_entry()->load_order_next()->DllBase);
        }

        template<class F = T>
        LAZY_IMPORTER_FORCEINLINE static F nt_safe_cached() noexcept
        {
            return in_safe_cached<F>(ldr_data_entry()->load_order_next()->DllBase);
        }
    };

}} // namespace li::detail

#endif // include guard

```

`client/Loader/utils/webclient/webclient.cpp`:

```cpp
#include "webclient.hpp"

namespace WebClient
{
    string replaceAll(string subject, const string& search,
        const string& replace) {
        size_t pos = 0;
        while ((pos = subject.find(search, pos)) != string::npos) {
            subject.replace(pos, search.length(), replace);
            pos += replace.length();
        }
        return subject;
    }

    string DownloadString(string URL) {
        HINTERNET interwebs = InternetOpenA("Mozilla/5.0", INTERNET_OPEN_TYPE_DIRECT, NULL, NULL, NULL);
        HINTERNET urlFile;
        string rtn;
        if (interwebs) {
            urlFile = InternetOpenUrlA(interwebs, URL.c_str(), NULL, NULL, NULL, NULL);
            if (urlFile) {
                char buffer[2000];
                DWORD bytesRead;
                do {
                    InternetReadFile(urlFile, buffer, 2000, &bytesRead);
                    rtn.append(buffer, bytesRead);
                    memset(buffer, 0, 2000);
                } while (bytesRead);
                InternetCloseHandle(interwebs);
                InternetCloseHandle(urlFile);
                string p = replaceAll(rtn, "|n", "\r\n");
                return p;
            }
        }
        InternetCloseHandle(interwebs);
        string p = replaceAll(rtn, "|n", "\r\n");
        return p;
    }

    void DownloadFile(LPCSTR URL, LPCSTR file_loc) {
        URLDownloadToFileA(0, URL, file_loc, 0, 0);
    }
}
```

`client/Loader/utils/webclient/webclient.hpp`:

```hpp
/*
			WEBCLIENT LIBRARY BY FLOWXRC
			MADE FOR SWIFTWARE
*/
#pragma once
#include <Windows.h>
#include <string>
#include <iostream>
#include <wininet.h>
#include <string>
#include <tchar.h>
#include <tlhelp32.h>
#include <vector>
#include <urlmon.h>
#pragma comment(lib, "WinINet.lib")
#pragma comment(lib, "Ws2_32.lib")
#pragma comment(lib, "urlmon.lib")
using namespace std;

namespace WebClient {
	extern string replaceAll(string subject, const string& search, const string& replace);
	extern string DownloadString(string URL);
	extern void DownloadFile(LPCSTR URL, LPCSTR file_loc);
}
```

`server/client/client.php`:

```php
<?php
require_once('config.php');
if ($_GET['key']) {
    if ($_GET['key'] === $config['client_key']) {
        if ($_GET['check_version'] == 1) {
            echo $config['version'];
        }
    }
    else {
        echo "incorrect client key.";
    }
}
?>
```

`server/client/config.php`:

```php
<?php
$config = [
    'version' => '1.0',
    'secret_key' => 'secret_N4QCMWupcOxZW0XZelam1DGR4RQrwOD2MZguyVf9',
    'client_key' => 'public_NHtCNhEPwTcAxcguJZbs'
];
?>
```

`server/client/download.php`:

```php
<?php
require_once('config.php');
if ($_GET['key']) {
    if ($_GET['key'] === $config['secret_key']) {
        $name = "cheat.dll";
        $fp = fopen($name, 'r');
        header("Content-Type: application/octet-stream");
        header("Content-Length: " . filesize($name));
        header('Content-Disposition: attachment; filename="cheat.dll"');
        fpassthru($fp);
    }
    else {
        echo "incorrect server key";
    }
}
else {
    if (!file_exists("loader.exe")) {
        echo "Loader not found";
    }
    else {
        $name = "loader.exe";
        $fp = fopen($name, 'r');
        header("Content-Type: application/octet-stream");
        header("Content-Length: " . filesize($name));
        header('Content-Disposition: attachment; filename="loader.exe"');
        fpassthru($fp);
    }
}
```

`server/loader.php`:

```php
<?php
if ($_GET['username']) {
    require('src/XF.php');
    XF::start( $fileDir );
	$app = \XF::setupApp('XF\App');
    
    $ip = $_SERVER['REMOTE_HOST'];

	if ( isset( $_GET[ "password" ] ) )
	{
		$loginService = $app->service('XF:User\Login', $_GET["username"], $ip);
		$userValidate = $loginService->validate($_GET["password"], $error);
		if($userValidate)
		{
		    $username = $_GET['username'];
		    $hwid = $_GET['hwid'];
		    $sql = mysqli_connect("host", "name", "pass", "database");
		    $query = mysqli_query($sql, "SELECT * FROM hwids WHERE username='$username'");
		    $count = mysqli_num_rows($query);
		    $row = mysqli_fetch_assoc($query);
		    if ($count > 0) {
		        if ($row['hwid'] == $hwid) {
		            echo "success";
		        }
		        else {
		            echo "hwid:fail";
		        }
		    }
		    else {
		        $query = mysqli_query($sql, "INSERT INTO hwids (username, hwid) VALUES ('$username', '$hwid')");
		        echo "success";
		    }
		}
		else {
		    echo "fail";
		}
	}
	else {
	    echo "fail";
	}
}
?>
```

`server/pastaware.sql`:

```sql
-- phpMyAdmin SQL Dump
-- version 4.9.4
-- https://www.phpmyadmin.net/
--
-- Хост: 127.0.0.1
-- Время создания: Фев 01 2021 г., 18:22
-- Версия сервера: 8.0.13
-- Версия PHP: 5.6.40

SET SQL_MODE = "NO_AUTO_VALUE_ON_ZERO";
SET AUTOCOMMIT = 0;
START TRANSACTION;
SET time_zone = "+00:00";


/*!40101 SET @OLD_CHARACTER_SET_CLIENT=@@CHARACTER_SET_CLIENT */;
/*!40101 SET @OLD_CHARACTER_SET_RESULTS=@@CHARACTER_SET_RESULTS */;
/*!40101 SET @OLD_COLLATION_CONNECTION=@@COLLATION_CONNECTION */;
/*!40101 SET NAMES utf8mb4 */;

--
-- База данных: `swiftware`
--

-- --------------------------------------------------------

--
-- Структура таблицы `hwids`
--

CREATE TABLE `hwids` (
  `id` int(11) NOT NULL,
  `username` varchar(255) NOT NULL,
  `hwid` varchar(255) NOT NULL
) ENGINE=MyISAM DEFAULT CHARSET=utf8;

--
-- Дамп данных таблицы `hwids`
--

INSERT INTO `hwids` (`id`, `username`, `hwid`) VALUES
(1, 'flowxrc', '150505RB254A1C16NPMJ');

--
-- Индексы сохранённых таблиц
--

--
-- Индексы таблицы `hwids`
--
ALTER TABLE `hwids`
  ADD PRIMARY KEY (`id`);

--
-- AUTO_INCREMENT для сохранённых таблиц
--

--
-- AUTO_INCREMENT для таблицы `hwids`
--
ALTER TABLE `hwids`
  MODIFY `id` int(11) NOT NULL AUTO_INCREMENT, AUTO_INCREMENT=2;
COMMIT;

/*!40101 SET CHARACTER_SET_CLIENT=@OLD_CHARACTER_SET_CLIENT */;
/*!40101 SET CHARACTER_SET_RESULTS=@OLD_CHARACTER_SET_RESULTS */;
/*!40101 SET COLLATION_CONNECTION=@OLD_COLLATION_CONNECTION */;

```