Project Path: arc_gmh5225_MMInject_294b8zko

Source Tree:

```txt
arc_gmh5225_MMInject_294b8zko
├── MMInject
│   ├── BlackBone
│   │   ├── Loader.c
│   │   ├── Loader.h
│   │   ├── Private.h
│   │   ├── VadHelpers.c
│   │   └── VadHelpers.h
│   ├── DynData.c
│   ├── Encryption.c
│   ├── IO.c
│   ├── LoadCfg.c
│   ├── MMInject.c
│   ├── MMInject.h
│   ├── MMInject.vcxproj
│   ├── MMInject.vcxproj.filters
│   ├── MMInject.vcxproj.user
│   ├── Native
│   │   ├── NativeEnums.h
│   │   ├── NativeStructs.h
│   │   ├── NativeStructs10.h
│   │   ├── NativeStructs7.h
│   │   └── NativeStructs81.h
│   ├── PE.c
│   ├── Process.c
│   ├── SSDT.c
│   ├── StringEncryptor.h
│   ├── Utils.c
│   ├── Utils.h
│   ├── VAD.c
│   ├── VMProtectDDK
│   │   ├── VMProtectDDK.h
│   │   ├── VMProtectDDK.patch
│   │   └── VMProtectStub.h
│   ├── main.c
│   ├── s20.c
│   ├── s20.h
│   ├── vad.h
│   └── zwapi.h
├── MMInject.sln
└── README.md

```

`MMInject.sln`:

```sln
Microsoft Visual Studio Solution File, Format Version 12.00
# Visual Studio Version 19
VisualStudioVersion = 16.0.28729.10
MinimumVisualStudioVersion = 10.0.40219.1
Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "MMInject", "MMInject\MMInject.vcxproj", "{C3E92B7A-36D7-4F85-BFFA-8D3707EE7F2A}"
EndProject
Global
	GlobalSection(SolutionConfigurationPlatforms) = preSolution
		Debug Win 10|Win32 = Debug Win 10|Win32
		Debug Win 10|x64 = Debug Win 10|x64
		Debug Win 7|Win32 = Debug Win 7|Win32
		Debug Win 7|x64 = Debug Win 7|x64
		Debug Win 8.1|Win32 = Debug Win 8.1|Win32
		Debug Win 8.1|x64 = Debug Win 8.1|x64
		Debug|Win32 = Debug|Win32
		Debug|x64 = Debug|x64
		Release Win 10|Win32 = Release Win 10|Win32
		Release Win 10|x64 = Release Win 10|x64
		Release Win 7|Win32 = Release Win 7|Win32
		Release Win 7|x64 = Release Win 7|x64
		Release Win 8.1|Win32 = Release Win 8.1|Win32
		Release Win 8.1|x64 = Release Win 8.1|x64
		Release|Win32 = Release|Win32
		Release|x64 = Release|x64
	EndGlobalSection
	GlobalSection(ProjectConfigurationPlatforms) = postSolution
		{C3E92B7A-36D7-4F85-BFFA-8D3707EE7F2A}.Debug Win 10|Win32.ActiveCfg = Debug Win 10|Win32
		{C3E92B7A-36D7-4F85-BFFA-8D3707EE7F2A}.Debug Win 10|Win32.Build.0 = Debug Win 10|Win32
		{C3E92B7A-36D7-4F85-BFFA-8D3707EE7F2A}.Debug Win 10|x64.ActiveCfg = Debug Win 10|x64
		{C3E92B7A-36D7-4F85-BFFA-8D3707EE7F2A}.Debug Win 10|x64.Build.0 = Debug Win 10|x64
		{C3E92B7A-36D7-4F85-BFFA-8D3707EE7F2A}.Debug Win 7|Win32.ActiveCfg = Debug Win 7|Win32
		{C3E92B7A-36D7-4F85-BFFA-8D3707EE7F2A}.Debug Win 7|Win32.Build.0 = Debug Win 7|Win32
		{C3E92B7A-36D7-4F85-BFFA-8D3707EE7F2A}.Debug Win 7|x64.ActiveCfg = Debug Win 7|x64
		{C3E92B7A-36D7-4F85-BFFA-8D3707EE7F2A}.Debug Win 7|x64.Build.0 = Debug Win 7|x64
		{C3E92B7A-36D7-4F85-BFFA-8D3707EE7F2A}.Debug Win 8.1|Win32.ActiveCfg = Debug Win 8.1|Win32
		{C3E92B7A-36D7-4F85-BFFA-8D3707EE7F2A}.Debug Win 8.1|Win32.Build.0 = Debug Win 8.1|Win32
		{C3E92B7A-36D7-4F85-BFFA-8D3707EE7F2A}.Debug Win 8.1|x64.ActiveCfg = Debug Win 8.1|x64
		{C3E92B7A-36D7-4F85-BFFA-8D3707EE7F2A}.Debug Win 8.1|x64.Build.0 = Debug Win 8.1|x64
		{C3E92B7A-36D7-4F85-BFFA-8D3707EE7F2A}.Debug|Win32.ActiveCfg = Debug Win 8.1|Win32
		{C3E92B7A-36D7-4F85-BFFA-8D3707EE7F2A}.Debug|Win32.Build.0 = Debug Win 8.1|Win32
		{C3E92B7A-36D7-4F85-BFFA-8D3707EE7F2A}.Debug|Win32.Deploy.0 = Debug Win 8.1|Win32
		{C3E92B7A-36D7-4F85-BFFA-8D3707EE7F2A}.Debug|x64.ActiveCfg = Debug Win 8.1|x64
		{C3E92B7A-36D7-4F85-BFFA-8D3707EE7F2A}.Debug|x64.Build.0 = Debug Win 8.1|x64
		{C3E92B7A-36D7-4F85-BFFA-8D3707EE7F2A}.Debug|x64.Deploy.0 = Debug Win 8.1|x64
		{C3E92B7A-36D7-4F85-BFFA-8D3707EE7F2A}.Release Win 10|Win32.ActiveCfg = Release Win 10|Win32
		{C3E92B7A-36D7-4F85-BFFA-8D3707EE7F2A}.Release Win 10|Win32.Build.0 = Release Win 10|Win32
		{C3E92B7A-36D7-4F85-BFFA-8D3707EE7F2A}.Release Win 10|x64.ActiveCfg = Release Win 10|x64
		{C3E92B7A-36D7-4F85-BFFA-8D3707EE7F2A}.Release Win 10|x64.Build.0 = Release Win 10|x64
		{C3E92B7A-36D7-4F85-BFFA-8D3707EE7F2A}.Release Win 10|x64.Deploy.0 = Release Win 10|x64
		{C3E92B7A-36D7-4F85-BFFA-8D3707EE7F2A}.Release Win 7|Win32.ActiveCfg = Release Win 7|Win32
		{C3E92B7A-36D7-4F85-BFFA-8D3707EE7F2A}.Release Win 7|Win32.Build.0 = Release Win 7|Win32
		{C3E92B7A-36D7-4F85-BFFA-8D3707EE7F2A}.Release Win 7|x64.ActiveCfg = Release Win 7|x64
		{C3E92B7A-36D7-4F85-BFFA-8D3707EE7F2A}.Release Win 7|x64.Build.0 = Release Win 7|x64
		{C3E92B7A-36D7-4F85-BFFA-8D3707EE7F2A}.Release Win 8.1|Win32.ActiveCfg = Release Win 8.1|Win32
		{C3E92B7A-36D7-4F85-BFFA-8D3707EE7F2A}.Release Win 8.1|Win32.Build.0 = Release Win 8.1|Win32
		{C3E92B7A-36D7-4F85-BFFA-8D3707EE7F2A}.Release Win 8.1|x64.ActiveCfg = Release Win 8.1|x64
		{C3E92B7A-36D7-4F85-BFFA-8D3707EE7F2A}.Release Win 8.1|x64.Build.0 = Release Win 8.1|x64
		{C3E92B7A-36D7-4F85-BFFA-8D3707EE7F2A}.Release|Win32.ActiveCfg = Release Win 8.1|Win32
		{C3E92B7A-36D7-4F85-BFFA-8D3707EE7F2A}.Release|Win32.Build.0 = Release Win 8.1|Win32
		{C3E92B7A-36D7-4F85-BFFA-8D3707EE7F2A}.Release|Win32.Deploy.0 = Release Win 8.1|Win32
		{C3E92B7A-36D7-4F85-BFFA-8D3707EE7F2A}.Release|x64.ActiveCfg = Release Win 8.1|x64
		{C3E92B7A-36D7-4F85-BFFA-8D3707EE7F2A}.Release|x64.Build.0 = Release Win 8.1|x64
		{C3E92B7A-36D7-4F85-BFFA-8D3707EE7F2A}.Release|x64.Deploy.0 = Release Win 8.1|x64
	EndGlobalSection
	GlobalSection(SolutionProperties) = preSolution
		HideSolutionNode = FALSE
	EndGlobalSection
	GlobalSection(ExtensibilityGlobals) = postSolution
		SolutionGuid = {17823792-EED5-431C-986C-83636B334553}
	EndGlobalSection
EndGlobal

```

`MMInject/BlackBone/Loader.c`:

```c
#include "MMInject.h"
#include "StringEncryptor.h"
#include "Loader.h"
#include "Utils.h"
#include <ntstrsafe.h>

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, FindModule)
#pragma alloc_text(PAGE, GetModuleExport)
#pragma alloc_text(PAGE, ResolveImagePath)
#endif

PVOID
FindModule(
	_In_ PEPROCESS Process,
	_In_ PUNICODE_STRING ModuleName
	)
{
	PAGED_CODE();

#ifdef _M_AMD64
	const PPEB32 Peb32 = static_cast<PPEB32>(PsGetProcessWow64Process(Process));
	const BOOLEAN IsWow64 = Peb32 != nullptr;
#else
	constexpr PPEB32 Peb32 = nullptr;
	constexpr BOOLEAN IsWow64 = FALSE;
#endif

	CONSTEXPR LONGLONG LoaderTimeoutMs = 300LL;
	CONSTEXPR ULONG LoaderRetries = 15;

	__try
	{
		if (IsWow64)
		{
			for (ULONG i = 0; !Peb32->Ldr && i < LoaderRetries; ++i)
			{
				Printf("FindModule: Loader not initialized, waiting...\n");
				LARGE_INTEGER Timeout;
				Timeout.QuadPart = -10LL * 1000LL * LoaderTimeoutMs;
				KeDelayExecutionThread(KernelMode, FALSE, &Timeout);
			}
			
			if (Peb32->Ldr == 0)
			{
				Printf("FindModule: Loader was not initialized in time. Aborting\n");
				return nullptr;
			}

			for (PLIST_ENTRY32 ListEntry = reinterpret_cast<PLIST_ENTRY32>(reinterpret_cast<PPEB_LDR_DATA32>(Peb32->Ldr)->InLoadOrderModuleList.Flink);
				ListEntry != &reinterpret_cast<PPEB_LDR_DATA32>(Peb32->Ldr)->InLoadOrderModuleList;
				ListEntry = reinterpret_cast<PLIST_ENTRY32>(ListEntry->Flink))
			{
				const PLDR_DATA_TABLE_ENTRY32 Entry = CONTAINING_RECORD(ListEntry, LDR_DATA_TABLE_ENTRY32, InLoadOrderLinks);
				DECLARE_UNICODE_STRING_SIZE(BaseDllName, MAX_PATH);

				RtlxInitUnicodeString(&BaseDllName, reinterpret_cast<PWCHAR>(Entry->BaseDllName.Buffer));
				if (RtlCompareUnicodeString(&BaseDllName, ModuleName, TRUE) == 0)
					return reinterpret_cast<PVOID>(Entry->DllBase);
			}
		}
		else
		{
			PPEB Peb = PsGetProcessPeb(Process);
			if (Peb == nullptr)
			{
				Printf("FindModule: No PEB present. Aborting\n");
				return nullptr;
			}

			for (ULONG i = 0; !Peb->Ldr && i < LoaderRetries; ++i)
			{
				Printf("FindModule: Loader not initialized, waiting...\n");
				LARGE_INTEGER Timeout;
				Timeout.QuadPart = -10LL * 1000LL * LoaderTimeoutMs;
				KeDelayExecutionThread(KernelMode, FALSE, &Timeout);
			}
		
			if (Peb->Ldr == nullptr)
			{
				Printf("FindModule: Loader was not initialized in time. Aborting\n");
				return nullptr;
			}

			for (PLIST_ENTRY ListEntry = Peb->Ldr->InLoadOrderModuleList.Flink;
				 ListEntry != &Peb->Ldr->InLoadOrderModuleList;
				 ListEntry = ListEntry->Flink)
			{
				PLDR_DATA_TABLE_ENTRY Entry = CONTAINING_RECORD(ListEntry, LDR_DATA_TABLE_ENTRY, InLoadOrderLinks);
				if (RtlCompareUnicodeString(&Entry->BaseDllName, ModuleName, TRUE) == 0)
					return Entry->DllBase;
			}
		}
	}
	__except (EXCEPTION_EXECUTE_HANDLER)
	{
		Printf("FindModule: exception %08X\n", GetExceptionCode());
	}
	return nullptr;
}

PVOID
GetModuleExport(
	_In_ PVOID Base,
	_In_ PCCHAR NameOrOrdinal,
	_In_ PEPROCESS Process
	)
{
	PAGED_CODE();
	
	PIMAGE_EXPORT_DIRECTORY ExportDir;
	ULONG ExportDirSize;
	ULONG_PTR FunctionAddress = 0;
	
	const PIMAGE_DOS_HEADER DosHeaders = static_cast<PIMAGE_DOS_HEADER>(Base);
	if (DosHeaders->e_magic != IMAGE_DOS_SIGNATURE)
		return nullptr;

	const PIMAGE_NT_HEADERS32 NtHeaders32 = reinterpret_cast<PIMAGE_NT_HEADERS32>(static_cast<PUCHAR>(Base) + DosHeaders->e_lfanew);
	const PIMAGE_NT_HEADERS64 NtHeaders64 = reinterpret_cast<PIMAGE_NT_HEADERS64>(static_cast<PUCHAR>(Base) + DosHeaders->e_lfanew);
	
	if (NtHeaders32->Signature != IMAGE_NT_SIGNATURE)
		return nullptr;

	if (NtHeaders32->OptionalHeader.Magic == IMAGE_NT_OPTIONAL_HDR64_MAGIC)
	{
		// x64 image
		ExportDir = reinterpret_cast<PIMAGE_EXPORT_DIRECTORY>(NtHeaders64->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_EXPORT].VirtualAddress +
			reinterpret_cast<ULONG_PTR>(Base));
		ExportDirSize = NtHeaders64->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_EXPORT].Size;
	}
	else
	{
		// x86 image
		ExportDir = reinterpret_cast<PIMAGE_EXPORT_DIRECTORY>(NtHeaders32->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_EXPORT].VirtualAddress +
			reinterpret_cast<ULONG_PTR>(Base));
		ExportDirSize = NtHeaders32->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_EXPORT].Size;
	}

	const PUSHORT AddressOfOrdinals = reinterpret_cast<PUSHORT>(ExportDir->AddressOfNameOrdinals + reinterpret_cast<ULONG_PTR>(Base));
	const PULONG AddressOfNames = reinterpret_cast<PULONG>(ExportDir->AddressOfNames + reinterpret_cast<ULONG_PTR>(Base));
	const PULONG AddressOfFunctions = reinterpret_cast<PULONG>(ExportDir->AddressOfFunctions + reinterpret_cast<ULONG_PTR>(Base));

	for (ULONG i = 0; i < ExportDir->NumberOfFunctions; ++i)
	{
		USHORT OrdinalIndex;
		PCHAR Name = nullptr;
		
		if (reinterpret_cast<ULONG_PTR>(NameOrOrdinal) <= 0xFFFF)
		{
			OrdinalIndex = static_cast<USHORT>(i);
		}
		else if (reinterpret_cast<ULONG_PTR>(NameOrOrdinal) > 0xFFFF && i < ExportDir->NumberOfNames)
		{
			Name = reinterpret_cast<PCHAR>(AddressOfNames[i] + reinterpret_cast<ULONG_PTR>(Base));
			OrdinalIndex = AddressOfOrdinals[i];
		}
		else
			return nullptr;

		if ((reinterpret_cast<ULONG_PTR>(NameOrOrdinal) <= 0xFFFF &&
			static_cast<USHORT>(reinterpret_cast<ULONG_PTR>(NameOrOrdinal)) == OrdinalIndex + ExportDir->Base) ||
			(reinterpret_cast<ULONG_PTR>(NameOrOrdinal) > 0xFFFF && strcmp(Name, NameOrOrdinal) == 0))
		{
			FunctionAddress = AddressOfFunctions[OrdinalIndex] + reinterpret_cast<ULONG_PTR>(Base);

			if (FunctionAddress >= reinterpret_cast<ULONG_PTR>(ExportDir) &&
				FunctionAddress <= reinterpret_cast<ULONG_PTR>(ExportDir) + ExportDirSize)
			{
				ANSI_STRING AnsiForwarderDll = { 0 };
				DECLARE_UNICODE_STRING_SIZE(ForwarderDll, 256);

				RtlxInitAnsiString(&AnsiForwarderDll, reinterpret_cast<PCSZ>(FunctionAddress));
				RtlAnsiStringToUnicodeString(&ForwarderDll, &AnsiForwarderDll, FALSE);

				ULONG DelimPos = 0;
				for (ULONG j = 0; j < ForwarderDll.Length / sizeof(WCHAR); j++)
				{
					if (ForwarderDll.Buffer[j] == L'.')
					{
						ForwarderDll.Length = static_cast<USHORT>(j * sizeof(WCHAR));
						ForwarderDll.Buffer[j] = UNICODE_NULL;
						DelimPos = j;
						break;
					}
				}

				ANSI_STRING ImportName = { 0 };
				RtlxInitAnsiString(&ImportName, AnsiForwarderDll.Buffer + DelimPos + 1);

				PWCHAR ForwarderBuffer = &ForwarderDll.Buffer[ForwarderDll.Length / sizeof(WCHAR)];
				*ForwarderBuffer++ = L'.';
				*ForwarderBuffer++ = L'd';
				*ForwarderBuffer++ = L'l';
				*ForwarderBuffer++ = L'l';
				*ForwarderBuffer = UNICODE_NULL;
				ForwarderDll.Length += sizeof(L".dll") - sizeof(WCHAR);

				UNICODE_STRING ResolvedForwarderDllPath = { 0 }, ResolvedName = { 0 };
				ResolveImagePath(Process, &ForwarderDll, &ResolvedForwarderDllPath);
				if (ResolvedForwarderDllPath.Length == 0)
					return nullptr;

				RtlStripPath(&ResolvedForwarderDllPath, &ResolvedName);

				const PVOID ForwardBase = FindModule(Process, &ResolvedName);
				const PVOID Result = ForwardBase != nullptr
					? GetModuleExport(ForwardBase, ImportName.Buffer, Process)
					: nullptr;

				RtlxFreeUnicodeString(&ResolvedForwarderDllPath);

				return Result;
			}

			break;
		}
	}
	return reinterpret_cast<PVOID>(FunctionAddress);
}

NTSTATUS
ResolveImagePath(
	_In_ PEPROCESS Process,
	_In_ PUNICODE_STRING Path,
	_Inout_ PUNICODE_STRING Resolved
	)
{
	PAGED_CODE();

#ifndef _WIN64
	UNREFERENCED_PARAMETER(Process);
#endif

	UNICODE_STRING FileName = { 0 };
	RtlStripPath(Path, &FileName);

	UNICODE_STRING FullResolved =
	{
		0,
		512 * sizeof(WCHAR),
		static_cast<PWCH>(ExAllocatePoolWithTag(NonPagedPoolNx, 512 * sizeof(WCHAR), GetPoolTag()))
	};
	RtlZeroMemory(FullResolved.Buffer, FullResolved.MaximumLength);

	if (NT_SUCCESS(NtQueryInformationProcess(NtCurrentProcess(),
											ProcessImageFileName,
											FullResolved.Buffer + 256,
											FullResolved.MaximumLength / sizeof(WCHAR),
											nullptr)))
	{
		const PUNICODE_STRING PathString = reinterpret_cast<PUNICODE_STRING>(FullResolved.Buffer + 256);
		UNICODE_STRING ParentDir;
		RtlStripFilename(PathString, &ParentDir);

		RtlxCopyUnicodeString(&FullResolved, &ParentDir);
		RtlUnicodeStringCat(&FullResolved, &FileName);
		BOOLEAN FileExists = FALSE;

		if (NT_SUCCESS(RtlFileExists(&FullResolved)))
		{
			RtlxFreeUnicodeString(Resolved);

			*Resolved = FullResolved;
			FileExists = TRUE;
		}

		if (FileExists)
			return STATUS_SUCCESS;
	}

	FullResolved.Length = 0;
	RtlSecureZeroMemory(FullResolved.Buffer, FullResolved.MaximumLength);

#ifdef _WIN64
	if (PsGetProcessWow64Process(Process) != nullptr)
	{
#endif
		WCHAR SysWOW64Path[decltype(EncryptedSysWOW64PathString)::Length];
		DecryptString(EncryptedSysWOW64PathString, SysWOW64Path);
		RtlUnicodeStringCatString(&FullResolved, SysWOW64Path);
		RtlSecureZeroMemory(SysWOW64Path, decltype(EncryptedSysWOW64PathString)::Length);
#ifdef _WIN64
	}
	else
	{
#endif
		WCHAR System32Path[decltype(EncryptedSystem32PathString)::Length];
		DecryptString(EncryptedSystem32PathString, System32Path);
		RtlUnicodeStringCatString(&FullResolved, System32Path);
		RtlSecureZeroMemory(System32Path, decltype(EncryptedSystem32PathString)::Length);
#ifdef _WIN64
	}
#endif

	RtlUnicodeStringCat(&FullResolved, &FileName);

	if (NT_SUCCESS(RtlFileExists(&FullResolved)))
	{
		RtlxFreeUnicodeString(Resolved);

		*Resolved = FullResolved;
	}
	else
	{
		RtlxFreeUnicodeString(&FullResolved);

		Resolved->Length = 0;
	}

	return STATUS_SUCCESS;
}

```

`MMInject/BlackBone/Loader.h`:

```h
#pragma once

#ifdef __cplusplus
extern "C" {
#endif

PVOID
FindModule(
	_In_ PEPROCESS Process,
	_In_ PUNICODE_STRING ModuleName
	);

PVOID
GetModuleExport(
	_In_ PVOID Base,
	_In_ PCCHAR NameOrOrdinal,
	_In_ PEPROCESS Process
	);

NTSTATUS
ResolveImagePath(
	_In_ PEPROCESS Process,
	_In_ PUNICODE_STRING Path,
	_Inout_ PUNICODE_STRING Resolved
	);

#ifdef __cplusplus
}
#endif

```

`MMInject/BlackBone/Private.h`:

```h
#pragma once

#ifdef __cplusplus
extern "C" {
#endif

#define MM_ZERO_ACCESS				0
#define MM_READONLY					1
#define MM_EXECUTE					2
#define MM_EXECUTE_READ				3
#define MM_READWRITE				4
#define MM_WRITECOPY				5
#define MM_EXECUTE_READWRITE		6
#define MM_EXECUTE_WRITECOPY		7

#define MM_NOCACHE					0x8
#define MM_GUARD_PAGE				0x10
#define MM_DECOMMIT					0x10
#define MM_NOACCESS					0x18

#define MM_PTE_VALID_MASK			0x1
#define MM_PTE_WRITE_MASK			0x800
#define MM_PTE_OWNER_MASK			0x4
#define MM_PTE_WRITE_THROUGH_MASK	0x8
#define MM_PTE_CACHE_DISABLE_MASK	0x10
#define MM_PTE_ACCESS_MASK			0x20
#define MM_PTE_DIRTY_MASK			0x42
#define MM_PTE_LARGE_PAGE_MASK		0x80
#define MM_PTE_GLOBAL_MASK			0x100
#define MM_PTE_COPY_ON_WRITE_MASK	0x200
#define MM_PTE_PROTOTYPE_MASK		0x400
#define MM_PTE_TRANSITION_MASK		0x800

#define VIRTUAL_ADDRESS_BITS 48
#define VIRTUAL_ADDRESS_MASK ((((ULONG_PTR)1) << VIRTUAL_ADDRESS_BITS) - 1)

#define THREAD_CREATE_FLAGS_CREATE_SUSPENDED		0x00000001
#define THREAD_CREATE_FLAGS_SKIP_THREAD_ATTACH		0x00000002
#define THREAD_CREATE_FLAGS_HIDE_FROM_DEBUGGER		0x00000004

#define EX_ADDITIONAL_INFO_SIGNATURE (ULONG_PTR)(-2)

#ifndef KI_USER_SHARED_DATA
#define KI_USER_SHARED_DATA 0xFFFFF78000000000UI64
#endif

#ifndef SharedUserData
#define SharedUserData ((KUSER_SHARED_DATA *const)KI_USER_SHARED_DATA)
#endif

#ifndef PTE_SHIFT
#define PTE_SHIFT 3
#endif
#ifndef PTI_SHIFT
#define PTI_SHIFT 12
#endif
#ifndef PDI_SHIFT
#define PDI_SHIFT 21
#endif
#ifndef PPI_SHIFT
#define PPI_SHIFT 30
#endif
#ifndef PXI_SHIFT
#define PXI_SHIFT 39
#endif

#ifdef _WIN64
#ifndef PXE_BASE
#define PXE_BASE 0xFFFFF6FB7DBED000UI64
#endif
#ifndef PXE_SELFMAP
#define PXE_SELFMAP 0xFFFFF6FB7DBEDF68UI64
#endif
#ifndef PPE_BASE
#define PPE_BASE 0xFFFFF6FB7DA00000UI64
#endif
#endif
#ifndef PDE_BASE
#ifdef _WIN64
#define PDE_BASE 0xFFFFF6FB40000000UI64
#else
#define PDE_BASE 0xC0600000
#endif
#endif
#ifndef PTE_BASE
#ifdef _WIN64
#define PTE_BASE 0xFFFFF68000000000UI64
#else
#define PTE_BASE 0xC0000000
#endif
#endif

#define PTE_PER_PAGE 512
#define PDE_PER_PAGE 512
#define PPE_PER_PAGE 512
#define PXE_PER_PAGE 512

#define PPI_MASK (PPE_PER_PAGE - 1)
#define PXI_MASK (PXE_PER_PAGE - 1)

#define MiGetPxeOffset(va) \
	((ULONG)(((ULONG_PTR)(va) >> PXI_SHIFT) & PXI_MASK))

#ifdef _WIN64
#define MiGetPxeAddress(va) \
	((PMMPTE)PXE_BASE + MiGetPxeOffset(va))

#define MiGetPpeAddress(va) \
	((PMMPTE)(((((ULONG_PTR)(va)&VIRTUAL_ADDRESS_MASK) >> PPI_SHIFT) << PTE_SHIFT) + PPE_BASE)) // PPE_BASE is probably also relocated, and we don't have it
#endif

#define MiGetPdeAddress(va) \
	((PMMPTE)(((((ULONG_PTR)(va)&VIRTUAL_ADDRESS_MASK) >> PDI_SHIFT) << PTE_SHIFT) + DynData.DYN_PDE_BASE))

#define MiGetPteAddress(va) \
	((PMMPTE)(((((ULONG_PTR)(va)&VIRTUAL_ADDRESS_MASK) >> PTI_SHIFT) << PTE_SHIFT) + DynData.DYN_PTE_BASE))

#ifdef _WIN64
#define MI_IS_PHYSICAL_ADDRESS(Va)							\
	((MiGetPxeAddress(Va)->u.Hard.Valid == 1) &&			\
		(MiGetPpeAddress(Va)->u.Hard.Valid == 1) &&			\
		((MiGetPdeAddress(Va)->u.Long & 0x81) == 0x81) ||	\
	(MiGetPteAddress(Va)->u.Hard.Valid == 1))
#else
#define MI_IS_PHYSICAL_ADDRESS(Va)							\
	((MiGetPdeAddress(Va)->u.Long & 0x81) == 0x81 ||		\
	(MiGetPteAddress(Va)->u.Hard.Valid == 1))
#endif

typedef ULONG WIN32_PROTECTION_MASK;
typedef PULONG PWIN32_PROTECTION_MASK;

typedef struct _UNLOADED_DRIVER
{
	UNICODE_STRING Name;
	PVOID StartAddress;
	PVOID EndAddress;
	LARGE_INTEGER CurrentTime;
} UNLOADED_DRIVER, *PUNLOADED_DRIVER;

typedef struct _PIDDBCACHE_ENTRY
{
	LIST_ENTRY List;
	UNICODE_STRING DriverName;
	ULONG TimeDateStamp;
	NTSTATUS LoadStatus;
	CHAR Data[16];
} PIDDBCACHE_ENTRY, *PPIDDBCACHE_ENTRY;

typedef enum _WinVer
{
	WINVER_7		= 0x0610,
	WINVER_7_SP1	= 0x0611,
	WINVER_8		= 0x0620, 
	WINVER_81		= 0x0630,
	WINVER_10		= 0x0A00,
	WINVER_10_RS1	= 0x0A01,
	WINVER_10_RS2	= 0x0A02,
	WINVER_10_RS3	= 0x0A03,
	WINVER_10_RS4	= 0x0A04,
	WINVER_10_RS5	= 0x0A05,
	WINVER_10_19H1	= 0x0A06,
} WinVer;

typedef struct _DYNAMIC_DATA
{
	WinVer Version;

	ULONG ProtectionOffset;					// EPROCESS::Protection
	ULONG ObjectTableOffset;				// EPROCESS::ObjectTable
	ULONG EProcessFlagsOffset;				// EPROCESS::Flags
	ULONG EProcessFlags2Offset;				// EPROCESS::Flags2
	ULONG MitigationFlagsOffset;			// EPROCESS::MitigationFlags (Win10 RS3+)
	ULONG MitigationFlags2Offset;			// EPROCESS::MitigationFlags2 (Win10 RS3+)
	ULONG VadRootOffset;					// EPROCESS::VadRoot
	ULONG PreviousModeOffset;				// KTHREAD::PreviousMode

	ULONG_PTR DYN_PDE_BASE;
	ULONG_PTR DYN_PTE_BASE;

	PULONG pPspNotifyEnableMask;			// &nt!PspNotifyEnableMask
	PUNLOADED_DRIVER *MmUnloadedDrivers;	// &nt!MmUnloadedDrivers
	PULONG MmLastUnloadedDriver;			// &nt!MmLastUnloadedDriver
	PERESOURCE PiDDBLock;					// &nt!PiDDBLock
	PRTL_AVL_TABLE PiDDBCacheTable;			// &nt!PiDDBCacheTable
} DYNAMIC_DATA, *PDYNAMIC_DATA;

NTSTATUS
InitDynamicData(
	_Out_ PDYNAMIC_DATA Data
	);

#ifdef __cplusplus
}
#endif

```

`MMInject/BlackBone/VadHelpers.c`:

```c
#include "MMInject.h"
#include "VadHelpers.h"


#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, MiPromoteNode)
#pragma alloc_text(PAGE, MiRebalanceNode)
#pragma alloc_text(PAGE, MiRemoveNode)
#pragma alloc_text(PAGE, MiFindNodeOrParent)
#pragma alloc_text(PAGE, MiCheckForConflictingVad)
#endif

extern DYNAMIC_DATA DynData;

VOID
MiPromoteNode(
	_In_ PMMADDRESS_NODE C
	)

{
	PAGED_CODE();

	PMMADDRESS_NODE P;
	PMMADDRESS_NODE G;

	P = SANITIZE_PARENT_NODE(C->u1.Parent);
	G = SANITIZE_PARENT_NODE(P->u1.Parent);

	if (P->LeftChild == C)
	{
		
		P->LeftChild = C->RightChild;

		if (P->LeftChild != NULL)
		{
			P->LeftChild->u1.Parent = MI_MAKE_PARENT(P, P->LeftChild->u1.Balance);
		}

		C->RightChild = P;

		
	}
	else
	{
		
		P->RightChild = C->LeftChild;

		if (P->RightChild != NULL)
		{
			P->RightChild->u1.Parent = MI_MAKE_PARENT(P, P->RightChild->u1.Balance);
		}

		C->LeftChild = P;
	}

	
	P->u1.Parent = MI_MAKE_PARENT(C, P->u1.Balance);

	
	if (G->LeftChild == P)
	{
		G->LeftChild = C;
	}
	else
	{
		G->RightChild = C;
	}
	C->u1.Parent = MI_MAKE_PARENT(G, C->u1.Balance);
}

ULONG
MiRebalanceNode(
	_In_ PMMADDRESS_NODE S
	)


{
	PAGED_CODE();

	PMMADDRESS_NODE R, P;
	SCHAR a;

	a = (SCHAR)S->u1.Balance;

	if (a == +1)
	{
		R = S->RightChild;
	}
	else
	{
		R = S->LeftChild;
	}

	
	if ((SCHAR)R->u1.Balance == a)
	{
		MiPromoteNode(R);
		R->u1.Balance = 0;
		S->u1.Balance = 0;

		return FALSE;
	}

	if ((SCHAR)R->u1.Balance == -a)
	{
		
		if (a == 1)
		{
			P = R->LeftChild;
		}
		else
		{
			P = R->RightChild;
		}

		
		MiPromoteNode(P);
		MiPromoteNode(P);
		S->u1.Balance = 0;
		R->u1.Balance = 0;
		if ((SCHAR)P->u1.Balance == a)
		{
			COUNT_BALANCE_MAX((SCHAR)-a);
			S->u1.Balance = (ULONG_PTR)-a;
		}
		else if ((SCHAR)P->u1.Balance == -a)
		{
			COUNT_BALANCE_MAX((SCHAR)a);
			R->u1.Balance = (ULONG_PTR)a;
		}

		P->u1.Balance = 0;
		return FALSE;
	}

	MiPromoteNode(R);
	COUNT_BALANCE_MAX((SCHAR)-a);
	R->u1.Balance = -a;

	return TRUE;
}

VOID
MiRemoveNode(
	_In_ PMMADDRESS_NODE NodeToDelete,
	_In_ PMM_AVL_TABLE Table
	)

{
	PAGED_CODE();

	PMMADDRESS_NODE Parent;
	PMMADDRESS_NODE EasyDelete;
	PMMADDRESS_NODE P;
	SCHAR a;

	if ((NodeToDelete->LeftChild == NULL) ||
		(NodeToDelete->RightChild == NULL))
	{
		EasyDelete = NodeToDelete;
	}

	
	else if ((SCHAR)NodeToDelete->u1.Balance >= 0)
	{
		
		EasyDelete = NodeToDelete->RightChild;
		while (EasyDelete->LeftChild != NULL)
		{
			EasyDelete = EasyDelete->LeftChild;
		}
	}
	else
	{

		EasyDelete = NodeToDelete->LeftChild;
		while (EasyDelete->RightChild != NULL)
		{
			EasyDelete = EasyDelete->RightChild;
		}
	}


	a = -1;

	if (EasyDelete->LeftChild == NULL)
	{
		Parent = SANITIZE_PARENT_NODE(EasyDelete->u1.Parent);

		if (MiIsLeftChild(EasyDelete))
		{
			Parent->LeftChild = EasyDelete->RightChild;
		}
		else
		{
			Parent->RightChild = EasyDelete->RightChild;
			a = 1;
		}

		if (EasyDelete->RightChild != NULL)
		{
			EasyDelete->RightChild->u1.Parent = MI_MAKE_PARENT(Parent, EasyDelete->RightChild->u1.Balance);
		}

	}
	else
	{
		Parent = SANITIZE_PARENT_NODE(EasyDelete->u1.Parent);

		if (MiIsLeftChild(EasyDelete))
		{
			Parent->LeftChild = EasyDelete->LeftChild;
		}
		else
		{
			Parent->RightChild = EasyDelete->LeftChild;
			a = 1;
		}

		EasyDelete->LeftChild->u1.Parent = MI_MAKE_PARENT(Parent,
														EasyDelete->LeftChild->u1.Balance);
	}

#if NTDDI_VERSION >= NTDDI_WINBLUE
	Table->BalancedRoot->u1.Balance = 0;
#else
	Table->BalancedRoot.u1.Balance = 0;
#endif
	P = SANITIZE_PARENT_NODE(EasyDelete->u1.Parent);

	for (;;)
	{
		if (P == nullptr)
			break;

		
		if ((SCHAR)P->u1.Balance == a)
		{
			P->u1.Balance = 0;

			
		}
		else if ((SCHAR)P->u1.Balance == 0)
		{
			COUNT_BALANCE_MAX((SCHAR)-a);
			P->u1.Balance = -a;

#if NTDDI_VERSION < NTDDI_WINBLUE
			if (Table->BalancedRoot.u1.Balance != 0)
			{
				Table->DepthOfTree -= 1;
			}
#endif

			break;

			
		}
		else
		{
			
			if (MiRebalanceNode(P))
			{
				break;
			}

			P = SANITIZE_PARENT_NODE(P->u1.Parent);
		}

		a = -1;
		if (MiIsRightChild(P))
		{
			a = 1;
		}

		P = SANITIZE_PARENT_NODE(P->u1.Parent);
	}

	
	if (NodeToDelete != EasyDelete)
	{
		
		EasyDelete->u1.Parent = NodeToDelete->u1.Parent;
		EasyDelete->LeftChild = NodeToDelete->LeftChild;
		EasyDelete->RightChild = NodeToDelete->RightChild;

		if (MiIsLeftChild(NodeToDelete))
		{
			Parent = SANITIZE_PARENT_NODE(EasyDelete->u1.Parent);
			Parent->LeftChild = EasyDelete;
		}
		else
		{
			Parent = SANITIZE_PARENT_NODE(EasyDelete->u1.Parent);
			Parent->RightChild = EasyDelete;
		}
		if (EasyDelete->LeftChild != NULL)
		{
			EasyDelete->LeftChild->u1.Parent = MI_MAKE_PARENT(EasyDelete,
															EasyDelete->LeftChild->u1.Balance);
		}
		if (EasyDelete->RightChild != NULL)
		{
			EasyDelete->RightChild->u1.Parent = MI_MAKE_PARENT(EasyDelete,
															EasyDelete->RightChild->u1.Balance);
		}
	}
}

TABLE_SEARCH_RESULT
MiFindNodeOrParent(
	_In_ PMM_AVL_TABLE Table,
	_In_ ULONG_PTR StartingVpn,
	_Out_ PMMADDRESS_NODE *NodeOrParent
	)


{
	PAGED_CODE();

	PMMADDRESS_NODE Child;
	PMMADDRESS_NODE NodeToExamine;

	*NodeOrParent = nullptr;

	if (Table->NumberGenericTableElements == 0)
	{
		return TableEmptyTree;
	}

	NodeToExamine = (PMMADDRESS_NODE)GET_VAD_ROOT(Table);

	TABLE_SEARCH_RESULT Result;

	for (;;)
	{
		PMMVAD_SHORT VpnCompare = (PMMVAD_SHORT)NodeToExamine;
#if NTDDI_VERSION >= NTDDI_WIN10
		PMMVAD_SHORT_19H1 VpnCompare19H1 = (PMMVAD_SHORT_19H1)NodeToExamine;
		ULONG_PTR startVpn = DynData.Version >= WINVER_10_19H1 ? VpnCompare19H1->StartingVpn : VpnCompare->StartingVpn;
		ULONG_PTR endVpn = DynData.Version >= WINVER_10_19H1 ? VpnCompare19H1->EndingVpn : VpnCompare->EndingVpn;
#else
		ULONG_PTR startVpn = VpnCompare->StartingVpn;
		ULONG_PTR endVpn = VpnCompare->EndingVpn;
#endif

#if NTDDI_VERSION >= NTDDI_WINBLUE

#if NTDDI_VERSION >= NTDDI_WIN10
		startVpn |= DynData.Version >= WINVER_10_19H1 ? ((ULONG64)VpnCompare19H1->StartingVpnHigh << 32) : ((ULONG64)VpnCompare->StartingVpnHigh << 32);
		endVpn |= DynData.Version >= WINVER_10_19H1 ? ((ULONG64)VpnCompare19H1->EndingVpnHigh << 32) : ((ULONG64)VpnCompare->EndingVpnHigh << 32);
#else
		startVpn |= (ULONG_PTR)VpnCompare->StartingVpnHigh << 32;
		endVpn |= (ULONG_PTR)VpnCompare->EndingVpnHigh << 32;
#endif

#endif

		if (StartingVpn < startVpn)
		{
			Child = NodeToExamine->LeftChild;

			if (Child != NULL)
			{
				NodeToExamine = Child;
			}
			else
			{
				
				*NodeOrParent = NodeToExamine;
				Result = TableInsertAsLeft;
				break;
			}
		}
		else if (StartingVpn <= endVpn)
		{
			*NodeOrParent = NodeToExamine;
			Result = TableFoundNode;
			break;
		}
		else
		{
			Child = NodeToExamine->RightChild;

			if (Child != NULL)
			{
				NodeToExamine = Child;
			}
			else
			{
				
				*NodeOrParent = NodeToExamine;
				Result = TableInsertAsRight;
				break;
			}
		}
	}

	return Result;
}

PMMVAD_SHORT
MiCheckForConflictingVad(
	_In_ PMM_AVL_TABLE Table,
	_In_ ULONG_PTR StartingVpn,
	_In_ ULONG_PTR EndingVpn
	)

{
	PAGED_CODE();

	PMM_AVL_NODE NodeToExamine = GET_VAD_ROOT(Table);
	if (NodeToExamine == nullptr)
	{
		return nullptr;
	}

	while (true)
	{
		PMMVAD_SHORT VpnCompare = (PMMVAD_SHORT)NodeToExamine;
#if NTDDI_VERSION >= NTDDI_WIN10
		PMMVAD_SHORT_19H1 VpnCompare19H1 = (PMMVAD_SHORT_19H1)NodeToExamine;
		ULONG_PTR StartVpnCompare = DynData.Version >= WINVER_10_19H1 ? VpnCompare19H1->StartingVpn : VpnCompare->StartingVpn;
		ULONG_PTR EndVpnCompare = DynData.Version >= WINVER_10_19H1 ? VpnCompare19H1->EndingVpn : VpnCompare->EndingVpn;
#else
		ULONG_PTR StartVpnCompare = VpnCompare->StartingVpn;
		ULONG_PTR EndVpnCompare = VpnCompare->EndingVpn;
#endif

#if NTDDI_VERSION >= NTDDI_WINBLUE

#if NTDDI_VERSION >= NTDDI_WIN10
		StartVpnCompare |= DynData.Version >= WINVER_10_19H1 ? ((ULONG64)VpnCompare19H1->StartingVpnHigh << 32) : ((ULONG64)VpnCompare->StartingVpnHigh << 32);
		EndVpnCompare |= DynData.Version >= WINVER_10_19H1 ? ((ULONG64)VpnCompare19H1->EndingVpnHigh << 32) : ((ULONG64)VpnCompare->EndingVpnHigh << 32);
#else
		StartVpnCompare |= (ULONG_PTR)VpnCompare->StartingVpnHigh << 32;
		EndVpnCompare |= (ULONG_PTR)VpnCompare->EndingVpnHigh << 32;
#endif

#endif

		if (EndingVpn < StartVpnCompare)
		{
			NodeToExamine = NodeToExamine->LeftChild;

			if (NodeToExamine == nullptr)
				return nullptr;
			continue;
		}

		if (StartingVpn > EndVpnCompare)
		{
			NodeToExamine = NodeToExamine->RightChild;

			if (NodeToExamine == nullptr)
				return nullptr;
			continue;
		}

		break;
	}

	return (PMMVAD_SHORT)NodeToExamine;
}

```

`MMInject/BlackBone/VadHelpers.h`:

```h
#pragma once

#include "MMInject.h"

#ifdef __cplusplus
extern "C" {
#endif

#define SANITIZE_PARENT_NODE(Parent) ((PMMADDRESS_NODE)(((ULONG_PTR)(Parent)) & ~0x3))

#define MiParent(Links) ( \
	(PRTL_SPLAY_LINKS)(SANITIZE_PARENT_NODE((Links)->u1.Parent)))

#define MiIsLeftChild(Links) ( \
	(RtlLeftChild(MiParent(Links)) == (PRTL_SPLAY_LINKS)(Links)))

#define MiIsRightChild(Links) ( \
	(RtlRightChild(MiParent(Links)) == (PRTL_SPLAY_LINKS)(Links)))

#define MI_MAKE_PARENT(ParentNode, ExistingBalance) \
	(PMMADDRESS_NODE)((ULONG_PTR)(ParentNode) | (((ULONG_PTR)ExistingBalance) & 0x3))

#define COUNT_BALANCE_MAX(a)


TABLE_SEARCH_RESULT
MiFindNodeOrParent(
	_In_ PMM_AVL_TABLE Table,
	_In_ ULONG_PTR StartingVpn,
	_Out_ PMMADDRESS_NODE *NodeOrParent
	);

VOID
MiPromoteNode(
	_In_ PMMADDRESS_NODE C
	);

ULONG
MiRebalanceNode(
	_In_ PMMADDRESS_NODE S
	);

VOID
MiRemoveNode(
	_In_ PMMADDRESS_NODE NodeToDelete,
	_In_ PMM_AVL_TABLE Table
	);

PMMVAD_SHORT
MiCheckForConflictingVad(
	_In_ PMM_AVL_TABLE Table,
	_In_ ULONG_PTR StartingVpn,
	_In_ ULONG_PTR EndingVpn
	);

#ifdef __cplusplus
}
#endif

```

`MMInject/DynData.c`:

```c
#include "MMInject.h"
#include "StringEncryptor.h
#include "Utils.h"

ULONG_PTR NtoskrnlBase = 0;
ULONG NtoskrnlSize = 0;

static CONSTEXPR const UCHAR MiGetPteAddressStartPattern[] = { 0x48, 0xC1, 0xE9, 0x09, 0x48, 0xB8, 0xF8, 0xFF, 0xFF, 0xFF, 0x7F, 0x00, 0x00, 0x00, 0x48, 0x23, 0xC8, 0x48, 0xB8 };
static CONSTEXPR const UCHAR MiGetPdeAddressStartPattern[] = { 0x48, 0xC1, 0xE9, 0x12, 0x81, 0xE1, 0xF8, 0xFF, 0xFF, 0x3F, 0x48, 0xB8 };
static CONSTEXPR const UCHAR CommonReturnPattern[] = { 0x48, 0x03, 0xC1, 0xC3 };

	DECLSPEC_NOINLINE
	static
	ULONG_PTR
	FindPattern(
		_In_ ULONG_PTR Base,
		_In_ ULONG Size,
		_In_ const UCHAR *Pattern,
		_In_ ULONG PatternLength
		);

	DECLSPEC_NOINLINE
	static
	ULONG_PTR
	BacktrackToFunctionStart(
		_In_ PUCHAR StartAddress,
		_In_ PUCHAR LowerBound
		);

	static
	NTSTATUS
	FindNtoskrnl(
		_Out_ PULONG_PTR KernelBase,
		_Out_ PULONG KernelSize
		);

#ifdef ALLOC_PRAGMA
#pragma alloc_text(INIT, FindPattern)
#pragma alloc_text(INIT, BacktrackToFunctionStart)
#pragma alloc_text(INIT, FindNtoskrnl)
#pragma alloc_text(INIT, LocatePageTables)
#pragma alloc_text(INIT, LocatePspNotifyEnableMask)
#pragma alloc_text(INIT, LocateMmUnloadedDrivers)
#pragma alloc_text(INIT, LocatePiDDBCacheTable)
#endif

DECLSPEC_NOINLINE
static
ULONG_PTR
FindPattern(
	_In_ ULONG_PTR Base,
	_In_ ULONG Size,
	_In_ const UCHAR *Pattern,
	_In_ ULONG PatternLength
	)
{
	for (PUCHAR Address = reinterpret_cast<PUCHAR>(Base);
		Address < reinterpret_cast<PUCHAR>(Base + Size - PatternLength);
		++Address)
	{
		ULONG i;
		for (i = 0; i < PatternLength; ++i)
		{
			if (Pattern[i] != 0xCC && (*(Address + i) != Pattern[i]))
				break;
		}

		if (i == PatternLength)
			return reinterpret_cast<ULONG_PTR>(Address);
	}
	return 0;
}

DECLSPEC_NOINLINE
static
ULONG_PTR
BacktrackToFunctionStart(
	_In_ PUCHAR StartAddress,
	_In_ PUCHAR LowerBound
	)
{
	NT_ASSERT(StartAddress > LowerBound);

	PUCHAR Address;
	BOOLEAN Found = FALSE;
	for (Address = StartAddress; Address >= LowerBound; --Address)
	{
		if ((*(Address - 1) == 0xCC ||										
			(*(Address - 2) == 0x90 && *(Address - 1) == 0x90) ||			
			(*(Address - 4) == 0x00 && *(Address - 3) == 0x00 &&			
				*(Address - 2) == 0x00 && *(Address - 1) == 0x00) ||
			(*(Address - 1) == 0xC3 && *(Address - 3) != 0x8D)				
#ifdef _M_IX86
			|| (*(Address - 3) == 0xC2 && *(Address - 1) == 0x00)			
#endif
			)
			&&																
			(*Address == 0x40 || *Address == 0x55 ||						
				(Address < StartAddress && *Address == 0x44 && *(Address + 1) == 0x89) ||
				(Address < StartAddress && *Address == 0x48 && *(Address + 1) == 0x83) ||
				(Address < StartAddress && *Address == 0x48 && *(Address + 1) == 0x89) ||
				(Address < StartAddress && *Address == 0x48 && *(Address + 1) == 0x8B) ||
				(Address < StartAddress && *Address == 0x49 && *(Address + 1) == 0x89) ||
				(Address < StartAddress && *Address == 0x4C && *(Address + 1) == 0x8B)))
		{
			Found = TRUE;
			break;
		}
	}

	return Found ? reinterpret_cast<ULONG_PTR>(Address) : 0;
}

static
NTSTATUS
FindNtoskrnl(
	_Out_ PULONG_PTR KernelBase,
	_Out_ PULONG KernelSize
	)
{
	PAGED_CODE();

	*KernelBase = 0;
	*KernelSize = 0;

	NTSTATUS Status;
	ULONG Size;
	if ((Status = NtQuerySystemInformation(SystemModuleInformation, nullptr, 0, &Size)) != STATUS_INFO_LENGTH_MISMATCH)
		return Status;
	const PRTL_PROCESS_MODULES Modules =
		static_cast<PRTL_PROCESS_MODULES>(ExAllocatePoolWithTag(NonPagedPoolNx, 2 * Size, GetPoolTag()));
	if (Modules == nullptr)
		return STATUS_NO_MEMORY;

	Status = NtQuerySystemInformation(SystemModuleInformation,
										Modules,
										2 * Size,
										&Size);
	if (NT_SUCCESS(Status))
	{
		*KernelBase = reinterpret_cast<ULONG_PTR>(Modules->Modules[0].ImageBase);
		*KernelSize = Modules->Modules[0].ImageSize;
	}

	ExFreePool(Modules);

	return Status;
}

NTSTATUS
LocatePageTables(
	_Inout_ PDYNAMIC_DATA Data
	)
{
	PAGED_CODE();

	Data->DYN_PDE_BASE = 0;
	Data->DYN_PTE_BASE = 0;

	const PIMAGE_NT_HEADERS NtHeaders = RtlpImageNtHeaderEx(reinterpret_cast<PVOID>(NtoskrnlBase), NtoskrnlSize);
	if (NtHeaders == nullptr)
		return STATUS_INVALID_IMAGE_FORMAT;

	const PIMAGE_SECTION_HEADER TextSection = IMAGE_FIRST_SECTION(NtHeaders);

	for (PUCHAR Address = reinterpret_cast<PUCHAR>(NtoskrnlBase + TextSection->VirtualAddress);
		reinterpret_cast<ULONG_PTR>(Address) < NtoskrnlBase + TextSection->Misc.VirtualSize;
		Address += 2)
	{
		if (memcmp(Address, MiGetPdeAddressStartPattern, sizeof(MiGetPdeAddressStartPattern)) == 0 &&
			memcmp(Address + sizeof(MiGetPdeAddressStartPattern) + sizeof(PVOID), CommonReturnPattern, sizeof(CommonReturnPattern)) == 0)
		{
			if (Data->DYN_PDE_BASE != 0)
			{
				Printf("Found one or more duplicate matches for MiGetPdeAddress at 0x%p! Not trusting found data.\n", Address);
				Data->DYN_PDE_BASE = 0xFFFFFFFF;
			}
			else
			{
				Printf("Found MiGetPdeAddress at 0x%p\n", Address);
				Data->DYN_PDE_BASE = *reinterpret_cast<PULONG_PTR>(Address + sizeof(MiGetPdeAddressStartPattern));
			}
		}
		else if (memcmp(Address, MiGetPteAddressStartPattern, sizeof(MiGetPteAddressStartPattern)) == 0 &&
			memcmp(Address + sizeof(MiGetPteAddressStartPattern) + sizeof(PVOID), CommonReturnPattern, sizeof(CommonReturnPattern)) == 0)
		{
			if (Data->DYN_PTE_BASE != 0)
			{
				Printf("Found one or more duplicate matches for MiGetPteAddress at 0x%p! Not trusting found data.\n", Address);
				Data->DYN_PTE_BASE = 0xFFFFFFFF;
			}
			else
			{
				Printf("Found MiGetPteAddress at 0x%p\n", Address);
				Data->DYN_PTE_BASE = *reinterpret_cast<PULONG_PTR>(Address + sizeof(MiGetPteAddressStartPattern));
			}
		}

		if (Data->DYN_PDE_BASE != 0 && Data->DYN_PTE_BASE != 0)
			break;
	}

	if (Data->DYN_PDE_BASE == 0xFFFFFFFF || Data->DYN_PTE_BASE == 0xFFFFFFFF)
		Data->DYN_PDE_BASE = Data->DYN_PTE_BASE = 0;

	if (Data->DYN_PDE_BASE == 0 || Data->DYN_PTE_BASE == 0)
		Printf("Failed to find PDE_BASE and PTE_BASE.\n");
	else
		Printf("PDE_BASE: 0x%p, PTE_BASE: 0x%p\n",
			reinterpret_cast<PVOID>(Data->DYN_PDE_BASE),
			reinterpret_cast<PVOID>(Data->DYN_PTE_BASE));

	return Data->DYN_PTE_BASE != 0 && Data->DYN_PDE_BASE != 0
		? STATUS_SUCCESS
		: STATUS_NOT_FOUND;
}

NTSTATUS
LocatePspNotifyEnableMask(
	_Inout_ PDYNAMIC_DATA Data
	)
{
	PAGED_CODE();

	Data->pPspNotifyEnableMask = nullptr;

	
	const NTSTATUS Status = FindNtoskrnl(&NtoskrnlBase, &NtoskrnlSize);
	if (!NT_SUCCESS(Status))
		return Status;

	CHAR PsSetCreateThreadNotifyRoutineBuffer[decltype(EncryptedPsSetCreateThreadNotifyRoutineString)::Length];
	DecryptString(EncryptedPsSetCreateThreadNotifyRoutineString, PsSetCreateThreadNotifyRoutineBuffer);
	const ULONG_PTR RoutineAddress = reinterpret_cast<ULONG_PTR>(GetProcedureAddress(NtoskrnlBase, PsSetCreateThreadNotifyRoutineBuffer));
	if (RoutineAddress == 0)
	{
		Printf("Failed to obtain address for %hs\n", PsSetCreateThreadNotifyRoutineBuffer);
		return STATUS_PROCEDURE_NOT_FOUND;
	}
	RtlSecureZeroMemory(PsSetCreateThreadNotifyRoutineBuffer, decltype(EncryptedPsSetCreateThreadNotifyRoutineString)::Length);

	constexpr const SIZE_T MAX_SEARCH_SIZE = 0x200;
	constexpr const UCHAR PspNotifyEnableMaskSearchPattern[] =
	{
		0xA8, 0x08,									// test al, 8
		0x75, 0x09,									// jnz +9
		0xF0, 0x0F, 0xBA, 0x2D, // [XX XX XX XX 03]	// lock bts cs:PspNotifyEnableMask, 3
	};

	for (PUCHAR Address = reinterpret_cast<PUCHAR>(max(RoutineAddress - MAX_SEARCH_SIZE, NtoskrnlBase + PAGE_SIZE));
		reinterpret_cast<ULONG_PTR>(Address) < RoutineAddress + MAX_SEARCH_SIZE;
		++Address)
	{
		if (memcmp(Address, PspNotifyEnableMaskSearchPattern, sizeof(PspNotifyEnableMaskSearchPattern)) == 0)
		{
			const LONG RelativeOffset = *reinterpret_cast<PLONG>(Address + sizeof(PspNotifyEnableMaskSearchPattern));
			Data->pPspNotifyEnableMask = reinterpret_cast<PULONG>(Address + sizeof(PspNotifyEnableMaskSearchPattern) + 5 + RelativeOffset);
			break;
		}
	}

	if (Data->pPspNotifyEnableMask == nullptr)
		Printf("Failed to find address of PspNotifyEnableMask\n");
	else
		Printf("Found PspNotifyEnableMask at 0x%p\n", Data->pPspNotifyEnableMask);

	return Data->pPspNotifyEnableMask != nullptr
		? STATUS_SUCCESS
		: STATUS_NOT_FOUND;
}

NTSTATUS
LocateMmUnloadedDrivers(
	_Inout_ PDYNAMIC_DATA Data
	)
{
	PAGED_CODE();

	Data->MmUnloadedDrivers = nullptr;
	Data->MmLastUnloadedDriver = nullptr;

	if (NtoskrnlBase == 0 || NtoskrnlSize == 0)
		return STATUS_INVALID_IMAGE_FORMAT;

	const UCHAR MovMmUnloadedDriversPattern[] = { 0x4C, 0x8B, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0x4C, 0x8B, 0xC9, 0x4D, 0x85, 0xCC, 0x74 };
	const ULONG_PTR MovMmUnloadedDrivers = FindPattern(NtoskrnlBase, NtoskrnlSize, MovMmUnloadedDriversPattern, sizeof(MovMmUnloadedDriversPattern));
	if (MovMmUnloadedDrivers != 0)
	{
		Data->MmUnloadedDrivers = reinterpret_cast<PUNLOADED_DRIVER*>(reinterpret_cast<PUCHAR>(MovMmUnloadedDrivers) +
			*reinterpret_cast<PLONG>(reinterpret_cast<PUCHAR>(MovMmUnloadedDrivers) + 3) + 7);

		const UCHAR MovMmLastUnloadedDriverPattern[] = { 0x8B, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xFF };
		const ULONG_PTR MovMmLastUnloadedDriver = FindPattern(MovMmUnloadedDrivers, 32, MovMmLastUnloadedDriverPattern, sizeof(MovMmLastUnloadedDriverPattern));
		if (MovMmLastUnloadedDriver != 0)
		{
			Data->MmLastUnloadedDriver = reinterpret_cast<PULONG>(reinterpret_cast<PUCHAR>(MovMmLastUnloadedDriver) +
				*reinterpret_cast<PLONG>(reinterpret_cast<PUCHAR>(MovMmLastUnloadedDriver) + 2) + 6); // 2 mov bytes before offset, instruction length 6
		}
	}

	if (Data->MmUnloadedDrivers == nullptr)
		Printf("Failed to find address of MmUnloadedDrivers\n");
	else
	{
		Printf("Found MmUnloadedDrivers at 0x%p\n", Data->MmUnloadedDrivers);

		if (Data->MmLastUnloadedDriver == nullptr)
			Printf("Failed to find address of MmLastUnloadedDriver\n");
		else
		{
			Printf("Found MmLastUnloadedDriver at 0x%p\n", Data->MmLastUnloadedDriver);
			if (*Data->MmLastUnloadedDriver > 50) // Sanity check
			{
				Printf("Bogus value for MmLastUnloadedDriver: expected <= 50, actual value = %u\n", *Data->MmLastUnloadedDriver);
				return STATUS_DATA_NOT_ACCEPTED;
			}
		}
	}

	return Data->MmUnloadedDrivers != nullptr && Data->MmLastUnloadedDriver != nullptr
		? STATUS_SUCCESS
		: STATUS_NOT_FOUND;
}

NTSTATUS
LocatePiDDBCacheTable(
	_Inout_ PDYNAMIC_DATA Data
	)
{
	PAGED_CODE();

	Data->PiDDBLock = nullptr;
	Data->PiDDBCacheTable = nullptr;

	if (NtoskrnlBase == 0 || NtoskrnlSize == 0)
		return STATUS_INVALID_IMAGE_FORMAT;

	PIMAGE_NT_HEADERS NtHeaders = RtlpImageNtHeaderEx(reinterpret_cast<PVOID>(NtoskrnlBase), NtoskrnlSize);
	if (NtHeaders == nullptr)
		return STATUS_INVALID_IMAGE_FORMAT;

	PIMAGE_SECTION_HEADER PageSection = nullptr;
	PIMAGE_SECTION_HEADER Section = IMAGE_FIRST_SECTION(NtHeaders);
	for (USHORT i = 0; i < NtHeaders->FileHeader.NumberOfSections; ++i)
	{
		CHAR SectionName[IMAGE_SIZEOF_SHORT_NAME + 1];
		RtlCopyMemory(SectionName, Section->Name, IMAGE_SIZEOF_SHORT_NAME);
		SectionName[IMAGE_SIZEOF_SHORT_NAME] = '\0';
		if (strcmp(SectionName, "PAGE") == 0)
		{
			PageSection = Section;
			break;
		}
		Section++;
	}

	NT_ASSERT(PageSection != nullptr);

	const UCHAR PiLookupInDDBCachePattern[] = { 0xBB, 0x01, 0x00, 0x00, 0xC0, 0xE8, 0xCC, 0xCC, 0xCC, 0xCC, 0x84, 0xC0 };
	const ULONG_PTR PiLookupInDDBCacheAddress = FindPattern(NtoskrnlBase + PageSection->VirtualAddress,
		NtoskrnlSize - PageSection->VirtualAddress, PiLookupInDDBCachePattern, sizeof(PiLookupInDDBCachePattern));
	if (PiLookupInDDBCacheAddress != 0)
	{
		const ULONG_PTR PiLookupInDDBCache = BacktrackToFunctionStart(reinterpret_cast<PUCHAR>(PiLookupInDDBCacheAddress),
			reinterpret_cast<PUCHAR>(PiLookupInDDBCacheAddress) - 512);
		if (PiLookupInDDBCache != 0)
		{
			const UCHAR LeaRcxPiDDBCacheTablePattern[] = { 0x48, 0x8D, 0x0D, 0xCC, 0xCC, 0xCC, 0xCC };
			const ULONG_PTR LeaRcxPiDDBCacheTable = FindPattern(PiLookupInDDBCache, 128, LeaRcxPiDDBCacheTablePattern, sizeof(LeaRcxPiDDBCacheTablePattern));
			if (LeaRcxPiDDBCacheTable != 0)
			{
				Data->PiDDBCacheTable = reinterpret_cast<PRTL_AVL_TABLE>(reinterpret_cast<PUCHAR>(LeaRcxPiDDBCacheTable) +
					*reinterpret_cast<PLONG>(reinterpret_cast<PUCHAR>(LeaRcxPiDDBCacheTable) + 3) + 7);
			}
		}
	}

	const UCHAR PpCheckInDriverDatabasePattern[] = { 0x8B, 0xD8, 0x3D, 0x01, 0x00, 0x00, 0xC0, 0x75, 0xCC, 0x4C, 0x8B, 0x8C, 0x24, 0xCC, 0x00, 0x00, 0x00, 0x48, 0x8D };
	const ULONG_PTR PpCheckInDriverDatabaseAddress = FindPattern(NtoskrnlBase + PageSection->VirtualAddress,
		NtoskrnlSize - PageSection->VirtualAddress, PpCheckInDriverDatabasePattern, sizeof(PpCheckInDriverDatabasePattern));
	if (Data->PiDDBCacheTable != nullptr && PpCheckInDriverDatabaseAddress != 0)
	{
		const ULONG_PTR PpCheckInDriverDatabase = BacktrackToFunctionStart(reinterpret_cast<PUCHAR>(PpCheckInDriverDatabaseAddress),
			reinterpret_cast<PUCHAR>(PpCheckInDriverDatabaseAddress) - 512);
		if (PpCheckInDriverDatabase != 0)
		{
			const UCHAR LeaRcxPiDDBLockPattern[] = { 0x48, 0x8D, 0x0D, 0xCC, 0xCC, 0xCC, 0xFF };
			const ULONG_PTR LeaRcxPiDDBLock = FindPattern(PpCheckInDriverDatabase, 128, LeaRcxPiDDBLockPattern, sizeof(LeaRcxPiDDBLockPattern));
			if (LeaRcxPiDDBLock != 0)
			{
				Data->PiDDBLock = reinterpret_cast<PERESOURCE>(reinterpret_cast<PUCHAR>(LeaRcxPiDDBLock) +
					*reinterpret_cast<PLONG>(reinterpret_cast<PUCHAR>(LeaRcxPiDDBLock) + 3) + 7);
			}
		}
	}

	if (Data->PiDDBCacheTable == nullptr)
		Printf("Failed to find address of PiDDBCacheTable\n");
	else
	{
		Printf("Found PiDDBCacheTable at 0x%p\n", Data->PiDDBCacheTable);
		if (Data->PiDDBLock == nullptr)
			Printf("WARNING: PiDDBLock was not found. PiDDBCacheTable will not be locked during entry removal!\n");
		else
			Printf("Found PiDDBLock at 0x%p\n", Data->PiDDBLock);
	}

	return Data->PiDDBCacheTable != nullptr
		? STATUS_SUCCESS
		: STATUS_NOT_FOUND;
}

#if 0
static
PVOID
MemMem(
	_In_ const void* SearchBase,
	_In_ SIZE_T SearchSize,
	_In_ const void* Pattern,
	_In_ SIZE_T PatternSize)
{
	if (PatternSize > SearchSize)
	{
		return nullptr;
	}

	auto Base = static_cast<PCCH>(SearchBase);
	for (SIZE_T i = 0; i <= SearchSize - PatternSize; i++)
	{
		if (RtlCompareMemory(Pattern, &Base[i], PatternSize) == PatternSize)
		{
			return const_cast<PCHAR>(&Base[i]);
		}
	}
	return nullptr;
}

static
VOID
LocatePageTablesForRS4(
	_Inout_ PDYNAMIC_DATA Data,
	_In_ CONST PUCHAR MiGetPhysicalAddress
	)
{
	static const UCHAR CallMI_IS_PHYSICAL_ADDRESSPattern[] =
	{
		0x49, 0x8B, 0xF8,	// mov	rdi, r8
		0x48, 0x8B, 0xF2,	// mov	rsi, rdx
		0x48, 0x8B, 0xD9,	// mov	rbx, rcx
		0xE8,				// call	MI_IS_PHYSICAL_ADDRESS
	};
	auto FoundAddress = reinterpret_cast<PCUCHAR>(MemMem(
		MiGetPhysicalAddress, 0x20, CallMI_IS_PHYSICAL_ADDRESSPattern, sizeof(CallMI_IS_PHYSICAL_ADDRESSPattern)));
	if (FoundAddress == nullptr)
	{
		return;
	}

	PCUCHAR offsetToCallInstruction = FoundAddress + 9;
	LONG offsetToMI_IS_PHYSICAL_ADDRESS = *reinterpret_cast<CONST LONG*>(offsetToCallInstruction + 1);
	PCUCHAR AddressOfMI_IS_PHYSICAL_ADDRESS = offsetToCallInstruction + 5 + offsetToMI_IS_PHYSICAL_ADDRESS;

	static const UCHAR PteBasePattern[] =
	{
		0x49, 0xB8, 0xF8, 0xFF, 0xFF, 0xFF, 0x7F, 0x00, 0x00, 0x00,	// mov	r8, 7FFFFFFFF8h
		0x49, 0x23, 0xC8,											// and	rcx, r8
		0x48, 0xBA,													// mov	rdx, 0FFFFF68000000000h
	};
	FoundAddress = reinterpret_cast<PCUCHAR>(MemMem(
		AddressOfMI_IS_PHYSICAL_ADDRESS, 0x20, PteBasePattern, sizeof(PteBasePattern)));
	if (FoundAddress == nullptr)
	{
		return;
	}

	ULONG_PTR PteBase = *reinterpret_cast<CONST ULONG_PTR*>(FoundAddress + 15);
	ULONG_PTR Index = (PteBase >> PXI_SHIFT) & PXI_MASK;
	ULONG_PTR PdeBase = PteBase | (Index << PPI_SHIFT);

	Data->DYN_PDE_BASE = PdeBase;
	Data->DYN_PTE_BASE = PteBase;
}
#endif

```

`MMInject/Encryption.c`:

```c
#include "MMInject.h"
#include "Utils.h"
#include "StringEncryptor.h"
#include <bcrypt.h>

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, DecryptPeFile)
#endif

#define BLOCK_SIZE		128
#define KEY_SIZE		128

static const UCHAR SecretKey[] =
{
	0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07,
	0x08, 0x09, 0x0A, 0x0B, 0x0C, 0x0D, 0x0E, 0x0F
};

NTSTATUS
DecryptPeFile(
	_In_ PUCHAR EncryptedDllBuffer,
	_In_ SIZE_T EncryptedDllSize,
	_Out_ PUCHAR *DecryptedDllBuffer,
	_Out_ PSIZE_T DecryptedDllSize,
	_Out_ PIMAGE_NT_HEADERS *NtHeaders
	)
{
	PAGED_CODE();

	*DecryptedDllBuffer = nullptr;
	*DecryptedDllSize = 0;
	*NtHeaders = nullptr;

	const PIMAGE_NT_HEADERS Headers = RtlpImageNtHeaderEx(EncryptedDllBuffer, EncryptedDllSize);
	if (Headers != nullptr)
	{
		*DecryptedDllBuffer = static_cast<PUCHAR>(ExAllocatePoolWithTag(NonPagedPoolNx, EncryptedDllSize, GetPoolTag()));
		if (*DecryptedDllBuffer == nullptr)
			return STATUS_NO_MEMORY;

		RtlCopyMemory(*DecryptedDllBuffer, EncryptedDllBuffer, EncryptedDllSize);
		*DecryptedDllSize = EncryptedDllSize;
		*NtHeaders = Headers;

		return STATUS_SUCCESS;
	}

	const ULONG BlockLength = BLOCK_SIZE / CHAR_BIT;
	BCRYPT_ALG_HANDLE AlgorithmHandle = nullptr;
	BCRYPT_KEY_HANDLE KeyHandle = nullptr;
	PUCHAR KeyObject = nullptr, PaddedPlaintextBuffer = nullptr;
	ULONG KeyObjectLength = 0, PaddedPlaintextLength = 0;
	UCHAR Iv[BLOCK_SIZE / CHAR_BIT];

	WCHAR AESName[decltype(EncryptedAESString)::Length];
	WCHAR BlockLengthName[decltype(EncryptedBlockLengthString)::Length];
	WCHAR ChainingModeName[decltype(EncryptedChainingModeString)::Length];
	WCHAR ChainingModeCBCName[decltype(EncryptedChainingModeCBCString)::Length];
	WCHAR ObjectLengthName[decltype(EncryptedObjectLengthString)::Length];
	DecryptString(EncryptedAESString, AESName);
	DecryptString(EncryptedBlockLengthString, BlockLengthName);
	DecryptString(EncryptedChainingModeString, ChainingModeName);
	DecryptString(EncryptedChainingModeCBCString, ChainingModeCBCName);
	DecryptString(EncryptedObjectLengthString, ObjectLengthName);

	NTSTATUS Status = BCryptOpenAlgorithmProvider(&AlgorithmHandle,
												AESName,
												nullptr,
												BCRYPT_PROV_DISPATCH);
	if (!NT_SUCCESS(Status))
	{
		Printf("BCryptOpenAlgorithmProvider: error 0x%08X\n", Status);
		goto Exit;
	}

	ULONG BlockLengthCheck, ResultSize;
	Status = BCryptGetProperty(AlgorithmHandle,
								BlockLengthName,
								reinterpret_cast<PUCHAR>(&BlockLengthCheck),
								sizeof(BlockLengthCheck),
								&ResultSize,
								0);
	if (!NT_SUCCESS(Status))
	{
		Printf("BCryptGetProperty(BCRYPT_BLOCK_LENGTH): error 0x%08X\n", Status);
		goto Exit;
	}
	if (BlockLengthCheck != BlockLength)
	{
		Printf("BCryptGetProperty(BCRYPT_BLOCK_LENGTH) returned %u bytes; expected %u.\n", BlockLengthCheck, BlockLength);
		goto Exit;
	}

	Status = BCryptSetProperty(AlgorithmHandle,
								ChainingModeName, 
								reinterpret_cast<PUCHAR>(ChainingModeCBCName),
								sizeof(BCRYPT_CHAIN_MODE_CBC),
								0);
	if (!NT_SUCCESS(Status))
	{
		Printf("BCryptSetProperty(BCRYPT_CHAINING_MODE): error 0x%08X\n", Status);
		goto Exit;
	}

	Status = BCryptGetProperty(AlgorithmHandle,
								ObjectLengthName,
								reinterpret_cast<PUCHAR>(&KeyObjectLength),
								sizeof(KeyObjectLength),
								&ResultSize,
								0);
	if (!NT_SUCCESS(Status))
	{
		Printf("BCryptGetProperty(BCRYPT_OBJECT_LENGTH): error 0x%08X\n", Status);
		goto Exit;
	}

	KeyObject = static_cast<PUCHAR>(ExAllocatePoolWithTag(NonPagedPoolNx, KeyObjectLength, GetPoolTag()));
	RtlZeroMemory(KeyObject, KeyObjectLength);

	Status = BCryptGenerateSymmetricKey(AlgorithmHandle,
										&KeyHandle,
										KeyObject,
										KeyObjectLength,
										const_cast<PUCHAR>(SecretKey),
										sizeof(SecretKey),
										0);
	if (!NT_SUCCESS(Status))
	{
		Printf("BCryptGenerateSymmetricKey: error 0x%08X\n", Status);
		goto Exit;
	}

	Status = BCryptDecrypt(KeyHandle,
							EncryptedDllBuffer,
							static_cast<ULONG>(EncryptedDllSize),
							nullptr,
							Iv,
							BlockLength,
							nullptr,
							0,
							&PaddedPlaintextLength,
							BCRYPT_BLOCK_PADDING);
	if (!NT_SUCCESS(Status))
	{
		Printf("BCryptDecrypt (1): error 0x%08X\n", Status);
		goto Exit;
	}

	const ULONG PlaintextLength = PaddedPlaintextLength - BlockLength;
	PaddedPlaintextBuffer = static_cast<PUCHAR>(ExAllocatePoolWithTag(NonPagedPoolNx, PaddedPlaintextLength, GetPoolTag()));
	const PUCHAR PlaintextBuffer = static_cast<PUCHAR>(ExAllocatePoolWithTag(NonPagedPoolNx, PlaintextLength, GetPoolTag()));
	if (PaddedPlaintextBuffer == nullptr || PlaintextBuffer == nullptr)
	{
		Status = STATUS_NO_MEMORY;
		goto Exit;
	}
	RtlZeroMemory(PaddedPlaintextBuffer, PaddedPlaintextLength);
	RtlZeroMemory(PlaintextBuffer, PlaintextLength);

	Status = BCryptDecrypt(KeyHandle,
							EncryptedDllBuffer,
							static_cast<ULONG>(EncryptedDllSize),
							nullptr,
							Iv,
							BlockLength,
							PaddedPlaintextBuffer,
							PlaintextLength + BlockLength,
							&PaddedPlaintextLength,
							BCRYPT_BLOCK_PADDING);
	if (!NT_SUCCESS(Status))
	{
		Printf("BCryptDecrypt (2): error 0x%08X\n", Status);
		goto Exit;
	}

	RtlCopyMemory(PlaintextBuffer, PaddedPlaintextBuffer + BlockLength, PlaintextLength);

	*DecryptedDllBuffer = PlaintextBuffer;
	*DecryptedDllSize = PlaintextLength;
	*NtHeaders = RtlpImageNtHeaderEx(PlaintextBuffer, PlaintextLength);

	if (*NtHeaders == nullptr)
	{
		Printf("Decrypted buffer is not a valid PE file!\n");
		Status = STATUS_INVALID_IMAGE_NOT_MZ;
		goto Exit;
	}

	Status = STATUS_SUCCESS;

Exit:
	RtlSecureZeroMemory(AESName, decltype(EncryptedAESString)::Length);
	RtlSecureZeroMemory(BlockLengthName, decltype(EncryptedBlockLengthString)::Length);
	RtlSecureZeroMemory(ChainingModeName, decltype(EncryptedChainingModeString)::Length);
	RtlSecureZeroMemory(ChainingModeCBCName, decltype(EncryptedChainingModeCBCString)::Length);
	RtlSecureZeroMemory(ObjectLengthName, decltype(EncryptedObjectLengthString)::Length);

	if (AlgorithmHandle != nullptr)
	{
		BCryptCloseAlgorithmProvider(AlgorithmHandle, 0);
	}

	if (KeyHandle != nullptr)
	{
		BCryptDestroyKey(KeyHandle);
	}

	if (KeyObject != nullptr)
	{
		RtlSecureZeroMemory(KeyObject, KeyObjectLength);
		ExFreePool(KeyObject);
	}

	if (PaddedPlaintextBuffer != nullptr)
	{
		RtlSecureZeroMemory(PaddedPlaintextBuffer, PaddedPlaintextLength);
		ExFreePool(PaddedPlaintextBuffer);
	}

	return Status;
}

```

`MMInject/IO.c`:

```c
#include "MMInject.h"
#include "Utils.h"

extern "C"
_Function_class_(IO_COMPLETION_ROUTINE)
_IRQL_requires_same_
_IRQL_requires_max_(DISPATCH_LEVEL)
IO_COMPLETION_ROUTINE
IoCompletionRoutine;

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, IopGetFileSize)
#pragma alloc_text(PAGE, IopReadFile)
#pragma alloc_text(PAGE, IopGetBaseFsDeviceObject)
#pragma alloc_text(PAGE, RtlReadFileToBytes)
#endif

_IRQL_requires_max_(DISPATCH_LEVEL)
FORCEINLINE
VOID
IopSetCompletionRoutine(
	_In_ PIRP Irp,
	_In_ PIO_COMPLETION_ROUTINE CompletionRoutine
	)
{
	const PIO_STACK_LOCATION IrpStackPointer = Irp->Tail.Overlay.CurrentStackLocation - 1;
	IrpStackPointer->CompletionRoutine = CompletionRoutine;
	IrpStackPointer->Context = IrpStackPointer->FileObject;
	IrpStackPointer->Control = (SL_INVOKE_ON_SUCCESS | SL_INVOKE_ON_ERROR | SL_INVOKE_ON_CANCEL);
}

_Use_decl_annotations_
NTSTATUS
IoCompletionRoutine(
	_In_ PDEVICE_OBJECT DeviceObject,
	_In_ PIRP Irp,
	_In_reads_opt_(_Inexpressible_("varies")) PVOID Context
	)
{
	UNREFERENCED_PARAMETER(DeviceObject);

	PFILE_OBJECT FileObject = static_cast<PFILE_OBJECT>(Context);
	NT_ASSERT(FileObject != nullptr);

	if (Irp->PendingReturned)
	{
		Irp->Tail.Overlay.CurrentStackLocation->Control |= SL_PENDING_RETURNED;
	}

	FileObject->FinalStatus = !NT_ERROR(Irp->IoStatus.Status) ? STATUS_SUCCESS : Irp->IoStatus.Status;
	KeSetEvent(&FileObject->Event, EVENT_INCREMENT, FALSE);

	IoFreeIrp(Irp);

	return STATUS_MORE_PROCESSING_REQUIRED;
}

FORCEINLINE
VOID
IopAcquireFileObjectLock(
	_In_ PFILE_OBJECT FileObject
	)
{
	
	while (_InterlockedExchange(reinterpret_cast<PLONG>(&FileObject->Busy),
		static_cast<ULONG>(TRUE)) != FALSE)
	{
		_mm_pause();
	}
	ObfReferenceObjectWithTag(FileObject, GetPoolTag());
}

FORCEINLINE
VOID
IopReleaseFileObjectLock(
	_In_ PFILE_OBJECT FileObject
	)
{
	_InterlockedExchange(reinterpret_cast<PLONG>(&FileObject->Busy), FALSE);
	if (FileObject->Waiters != 0)
		KeSetEvent(&FileObject->Lock, 0, FALSE);
	ObfDereferenceObject(FileObject);
}

FORCEINLINE
NTSTATUS
IopCallDriver(
	_In_ PDEVICE_OBJECT DeviceObject,
	_Inout_ PIRP Irp
	)
{
	Irp->CurrentLocation--;

	const PIO_STACK_LOCATION IrpStackPointer = Irp->Tail.Overlay.CurrentStackLocation - 1;
	Irp->Tail.Overlay.CurrentStackLocation = IrpStackPointer;
	IrpStackPointer->DeviceObject = DeviceObject;

	return DeviceObject->DriverObject->MajorFunction[IrpStackPointer->MajorFunction](DeviceObject, Irp);
}

NTSTATUS
NTAPI
IopGetFileSize(
	_In_ PFILE_OBJECT FileObject,
	_Inout_ PLARGE_INTEGER FileSize
	)
{
	PAGED_CODE();

	const PDEVICE_OBJECT DeviceObject = IoGetBaseFileSystemDeviceObject(FileObject);
	const PIRP Irp = IoAllocateIrp(DeviceObject->StackSize, FALSE);

	KEVENT Event;
	KeInitializeEvent(&Event, NotificationEvent, FALSE);

	IO_STATUS_BLOCK IoStatusBlock;
	FILE_STANDARD_INFORMATION FileInformation;
	Irp->Flags = IRP_PAGING_IO | IRP_SYNCHRONOUS_PAGING_IO;
	Irp->RequestorMode = KernelMode;
	Irp->UserIosb = &IoStatusBlock;
	Irp->UserEvent = &Event;
	Irp->Tail.Overlay.OriginalFileObject = FileObject;
	Irp->Tail.Overlay.Thread = KiGetCurrentThread();
	Irp->AssociatedIrp.SystemBuffer = &FileInformation;

	NT_ASSERT(Irp->CurrentLocation > 0);
	PIO_STACK_LOCATION IrpStackPointer = Irp->Tail.Overlay.CurrentStackLocation - 1;
	IrpStackPointer->MajorFunction = IRP_MJ_QUERY_INFORMATION;
	IrpStackPointer->FileObject = FileObject;
	IrpStackPointer->DeviceObject = DeviceObject;
	IrpStackPointer->Parameters.SetFile.Length = sizeof(FILE_STANDARD_INFORMATION);
	IrpStackPointer->Parameters.SetFile.FileInformationClass = FileStandardInformation;

	const NTSTATUS Status = IopCallDriver(DeviceObject, Irp);

	if (Status == STATUS_PENDING)
	{
		KeWaitForSingleObject(&Event,
							Executive,
							KernelMode,
							FALSE,
							nullptr);
	}

	if (!NT_SUCCESS(Status))
		IoStatusBlock.Status = Status;

	NT_ASSERT(!FileInformation.Directory || !NT_SUCCESS(IoStatusBlock.Status));
	*FileSize = FileInformation.EndOfFile;

	return IoStatusBlock.Status;
}

NTSTATUS
NTAPI
IopReadFile(
	_In_ PFILE_OBJECT FileObject,
	_Out_ PIO_STATUS_BLOCK IoStatusBlock,
	_Out_ PVOID Buffer,
	_In_ ULONG Length,
	_In_ PLARGE_INTEGER ByteOffset
	)
{
	PAGED_CODE();

	const PDEVICE_OBJECT DeviceObject = IoGetBaseFileSystemDeviceObject(FileObject);
	if (DeviceObject->Flags & DO_BUFFERED_IO ||
		DeviceObject->Flags & DO_DIRECT_IO)
		return STATUS_NOT_SUPPORTED;
	if (!(FileObject->Flags & FO_SYNCHRONOUS_IO))
		return STATUS_NOT_SUPPORTED;

	constexpr ULONG FileObjectFlags = FO_SYNCHRONOUS_IO;
	FileObject->Flags |= FileObjectFlags;

	if constexpr ((FileObjectFlags & FO_SYNCHRONOUS_IO) != 0)
		IopAcquireFileObjectLock(FileObject);

	KeClearEvent(&FileObject->Event);

	const PIRP Irp = IoAllocateIrp(DeviceObject->StackSize, FALSE);

	Irp->Tail.Overlay.OriginalFileObject = FileObject;
	Irp->Tail.Overlay.Thread = KiGetCurrentThread();
	Irp->Tail.Overlay.AuxiliaryBuffer = nullptr;
	Irp->RequestorMode = KernelMode;
	Irp->PendingReturned = FALSE;
	Irp->Cancel = FALSE;
	Irp->CancelRoutine = nullptr;
	Irp->UserEvent = nullptr;
	Irp->UserIosb = IoStatusBlock;
	Irp->Overlay.AsynchronousParameters.UserApcRoutine = nullptr;
	Irp->Overlay.AsynchronousParameters.UserApcContext = nullptr;

	NT_ASSERT(Irp->CurrentLocation > 0);
	PIO_STACK_LOCATION IrpStackPointer = Irp->Tail.Overlay.CurrentStackLocation - 1;
	*reinterpret_cast<PULONG>(&IrpStackPointer->MajorFunction) = IRP_MJ_READ;
	IrpStackPointer->FileObject = FileObject;

	IopSetCompletionRoutine(Irp, IoCompletionRoutine);
	Irp->AssociatedIrp.SystemBuffer = nullptr;
	Irp->MdlAddress = nullptr;
	Irp->UserBuffer = Buffer;
	constexpr ULONG IrpFlags = IRP_READ_OPERATION | IRP_DEFER_IO_COMPLETION;
	Irp->Flags = IrpFlags;

	IrpStackPointer->Parameters.Read.Length = Length;
	IrpStackPointer->Parameters.Read.Key = 0;
	IrpStackPointer->Parameters.Read.ByteOffset = *ByteOffset;

	NTSTATUS Status = IopCallDriver(DeviceObject, Irp);

	if constexpr ((IrpFlags & IRP_DEFER_IO_COMPLETION) != 0)
	{
		if (Status != STATUS_PENDING)
		{
			NT_ASSERT(FileObject->Event.Header.SignalState != 0);
		}
	}

	if constexpr ((FileObjectFlags & FO_SYNCHRONOUS_IO) != 0)
	{
		if (Status == STATUS_PENDING)
		{
			
			KeWaitForSingleObject(&FileObject->Event,
									Executive,
									KernelMode,
									static_cast<BOOLEAN>((FileObject->Flags & FO_ALERTABLE_IO) != 0),
									nullptr);
		}

		IopReleaseFileObjectLock(FileObject);
	}

	Status = FileObject->FinalStatus;

	return Status;
}

PDEVICE_OBJECT
IopGetBaseFsDeviceObject(
	_In_ PUNICODE_STRING FileName
	)

{
	PAGED_CODE();

	UNICODE_STRING Directory;
	NTSTATUS Status = RtlStripFilename(FileName, &Directory);
	if (!NT_SUCCESS(Status))
		return nullptr;

	OBJECT_ATTRIBUTES ObjectAttributes = RTL_CONSTANT_OBJECT_ATTRIBUTES(&Directory, OBJ_CASE_INSENSITIVE | OBJ_KERNEL_HANDLE);
	IO_STATUS_BLOCK IoStatusBlock;
	HANDLE FileHandle;
	Status = IoCreateFileEx(&FileHandle,
							FILE_GENERIC_READ,
							&ObjectAttributes,
							&IoStatusBlock,
							nullptr,
							FILE_ATTRIBUTE_DIRECTORY,
							FILE_SHARE_READ | FILE_SHARE_DELETE,
							FILE_OPEN,
							FILE_DIRECTORY_FILE | FILE_SYNCHRONOUS_IO_NONALERT | FILE_OPEN_REPARSE_POINT | FILE_OPEN_FOR_BACKUP_INTENT,
							nullptr,
							0,
							CreateFileTypeNone,
							nullptr,
							IO_NO_PARAMETER_CHECKING | IO_IGNORE_SHARE_ACCESS_CHECK,
							nullptr);
	if (!NT_SUCCESS(Status))
		return nullptr;

	PFILE_OBJECT FileObject = nullptr;
	Status = ObReferenceObjectByHandleWithTag(FileHandle,
											FILE_GENERIC_READ,
											*IoFileObjectType,
											KernelMode,
											GetPoolTag(),
											reinterpret_cast<PVOID*>(&FileObject),
											nullptr);
	if (!NT_SUCCESS(Status))
	{
		ObCloseHandle(FileHandle, KernelMode);
		return nullptr;
	}

	
	const PDEVICE_OBJECT DeviceObject = IoGetRelatedDeviceObject(FileObject);
	PDEVICE_OBJECT BaseFsDeviceObject = DeviceObject;
	if (DeviceObject != nullptr)
	{
		BaseFsDeviceObject = IoGetDeviceAttachmentBaseRef(DeviceObject);
	}

	ObfDereferenceObject(FileObject);
	ObCloseHandle(FileHandle, KernelMode);

	return BaseFsDeviceObject;
}

NTSTATUS
RtlReadFileToBytes(
	_In_ PUNICODE_STRING NtPath,
	_Out_ PUCHAR *Buffer,
	_Out_opt_ PSIZE_T FileSize
	)
{
	PAGED_CODE();

	IO_DRIVER_CREATE_CONTEXT DriverCreateContext;
	IoInitializeDriverCreateContext(&DriverCreateContext);
	const PDEVICE_OBJECT BaseFsDeviceObject = IopGetBaseFsDeviceObject(NtPath);
	DriverCreateContext.DeviceObjectHint = BaseFsDeviceObject;

#ifdef _DEBUG
	Printf("Opening file \"%wZ\"... [bypassing FS minifilter drivers: %hs]\n", NtPath, BaseFsDeviceObject != nullptr ? "yes" : "no");
#endif
	OBJECT_ATTRIBUTES ObjectAttributes = RTL_CONSTANT_OBJECT_ATTRIBUTES(NtPath, OBJ_CASE_INSENSITIVE | OBJ_KERNEL_HANDLE);
	IO_STATUS_BLOCK IoStatusBlock;
	HANDLE FileHandle = nullptr;
	PFILE_OBJECT FileObject = nullptr;

	NTSTATUS Status = IoCreateFileEx(&FileHandle,
									FILE_GENERIC_READ,
									&ObjectAttributes,
									&IoStatusBlock,
									nullptr,
									FILE_ATTRIBUTE_NORMAL,
									FILE_SHARE_READ | FILE_SHARE_DELETE,
									FILE_OPEN,
									FILE_NON_DIRECTORY_FILE | FILE_SYNCHRONOUS_IO_NONALERT | FILE_OPEN_REPARSE_POINT | FILE_OPEN_FOR_BACKUP_INTENT,
									nullptr,
									0,
									CreateFileTypeNone,
									nullptr,
									IO_NO_PARAMETER_CHECKING | IO_IGNORE_SHARE_ACCESS_CHECK,
									BaseFsDeviceObject != nullptr
										? &DriverCreateContext
										: nullptr);
	if (!NT_SUCCESS(Status))
	{
		Printf("IoCreateFileEx: %08X\n", Status);
		goto finished;
	}
	
	Status = ObReferenceObjectByHandleWithTag(FileHandle,
											FILE_GENERIC_READ,
											*IoFileObjectType,
											KernelMode,
											GetPoolTag(),
											reinterpret_cast<PVOID*>(&FileObject),
											nullptr);
	if (!NT_SUCCESS(Status))
		goto finished;

	LARGE_INTEGER SizeOnDisk;
	Status = IopGetFileSize(FileObject, &SizeOnDisk);
	if (!NT_SUCCESS(Status))
		goto finished;
	
	*Buffer = static_cast<PUCHAR>(ExAllocatePoolWithTag(NonPagedPoolNx, static_cast<SIZE_T>(SizeOnDisk.QuadPart), GetPoolTag()));
	if (*Buffer == nullptr)
	{
		Status = STATUS_NO_MEMORY;
		goto finished;
	}
	
	LARGE_INTEGER Offset;
	Offset.QuadPart = 0;
	Status = IopReadFile(FileObject,
						&IoStatusBlock,
						*Buffer,
						SizeOnDisk.LowPart,
						&Offset);

	if (FileSize != nullptr)
		*FileSize = static_cast<SIZE_T>(SizeOnDisk.QuadPart);

finished:
	if (FileObject != nullptr)
		ObfDereferenceObject(FileObject);
	if (FileHandle != nullptr)
		ObCloseHandle(FileHandle, KernelMode);
	if (BaseFsDeviceObject != nullptr)
		ObfDereferenceObject(BaseFsDeviceObject);

	return Status;
}

```

`MMInject/LoadCfg.c`:

```c
#if !defined(_DEBUG) && (!defined(DBG) || !DBG)

#include "MMInject.h"
#include <ntimage.h>

extern "C"
{
#ifdef _M_IX86
	extern ULONG __safe_se_handler_table;
	extern ULONG __safe_se_handler_count;

	uintptr_t __security_cookie = 0xBB40E64E;

	#ifdef _KERNEL_MODE
		void __fastcall __security_check_cookie(uintptr_t) {}
		__declspec(noreturn) void __cdecl __report_rangecheckfailure() {}
	#endif
#else
	uintptr_t __security_cookie = 0x2B992DDFA232;
#endif

	extern "C" const IMAGE_LOAD_CONFIG_DIRECTORY _load_config_used =
	{
		
		FIELD_OFFSET(IMAGE_LOAD_CONFIG_DIRECTORY, GuardFlags) + sizeof(IMAGE_LOAD_CONFIG_DIRECTORY::GuardFlags),
		0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		reinterpret_cast<decltype(IMAGE_LOAD_CONFIG_DIRECTORY::SecurityCookie)>(&__security_cookie),
#ifdef _M_IX86
		reinterpret_cast<ULONG>(&__safe_se_handler_table),
		reinterpret_cast<ULONG>(&__safe_se_handler_count),
#else
		0,		
		0,		
#endif
		0,		
		0,		
		0,		
		0,		
		IMAGE_GUARD_SECURITY_COOKIE_UNUSED

	};
}

#endif

```

`MMInject/MMInject.c`:

```c
#include "MMInject.h"
#include "StringEncryptor.h"
#include "vad.h"
#include "BlackBone/Loader.h"
#include "Utils.h"

	static
	BOOLEAN
	NTAPI
	HandleEnumerationCallback(
	#if NTDDI_VERSION > NTDDI_WIN7
		_In_ PHANDLE_TABLE HandleTable,
	#endif
		_Inout_ PHANDLE_TABLE_ENTRY HandleTableEntry,
		_In_ HANDLE Handle,
		_In_ PVOID EnumParameter
		);

	static
	NTSTATUS
	SetCSRSSWindowStation(
		_In_ PEPROCESS Process,
		_Out_ PBOOLEAN ProcessIsCsrss
		);

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, HandleEnumerationCallback)
#pragma alloc_text(PAGE, SetCSRSSWindowStation)
#pragma alloc_text(PAGE, StartDllThread)
#pragma alloc_text(PAGE, InjectDll)
#endif

CONSTEXPR UCHAR DllInitializer64[] =
{
	
	0x65, 0x48, 0x8B, 0x04, 0x25, 0x30, 0x00, 0x00, 0x00,		// mov rax, gs:[30h]
	0xBE, 0xF7, 0xFF, 0x00, 0x00,								// mov esi, 0FFF7h
	0x66, 0x21, 0xB0, 0xEE, 0x17, 0x00, 0x00,					// and [rax+17EEh], si

	0x40, 0x53,						// push rbx
	0x48, 0x83, 0xEC, 0x20,			// sub rsp, 20h
	0x4C, 0x8B, 0x41, 0x18,			// mov r8, [rcx+18h]
	0x48, 0x8B, 0xD9,				// mov rbx, rcx
	0x8B, 0x51, 0x10,				// mov edx, [rcx+10h]
	0x48, 0x8B, 0x49, 0x08,			// mov rcx, [rcx+8]
	0x48, 0x85, 0xC9,				// test rcx, rcx
	0x74, 0x02,						// jz +2
	0xFF, 0x13,						// call [rbx]
	0x48, 0x8B, 0x4B, 0x18,			// mov rcx, [rbx+18h]
	0x45, 0x33, 0xC0,				// xor r8d, r8d	
	0xBA, 0x01, 0x00, 0x00, 0x00,	// mov edx, 1
	0x48, 0x8B, 0x43, 0x20,			// mov rax, [rbx+20h]
	0x48, 0x83, 0xC4, 0x20,			// add rsp, 20h
	0x5B,							// pop rbx
	0x48, 0xFF, 0xE0				// jmp rax
};

CONSTEXPR UCHAR DllInitializer32[] =
{
	0x64, 0xA1, 0x18, 0x00, 0x00, 0x00,							// mov eax, fs:[18h]
	0xB9, 0xF7, 0xFF, 0x00, 0x00,								// mov ecx, 0FFF7h
	0x66, 0x21, 0x88, 0xCA, 0x0F, 0x00, 0x00,					// and [eax+0FCAh], cx

	0x8B, 0x44, 0x24, 0x04,			// mov eax, [esp+4h]
	0x6A, 0x00,						// push 0
	0x6A, 0x01,						// push 1
	0xFF, 0x70, 0x18,				// push [eax+18h]
	0xFF, 0x75, 0xF4,				// push [ebp-0Ch]			
	0xFF, 0x60, 0x20				// jmp [eax+20h]
};

typedef struct _DLL_INIT_DATA
{
	PVOID RtlAddFunctionTable;
	PRUNTIME_FUNCTION FunctionTable;
	ULONG EntryCount;
	PVOID ImageBase;
	PVOID EntryPoint;
	UCHAR InitFunction[sizeof(DllInitializer64)];
} DLL_INIT_DATA, *PDLL_INIT_DATA;

typedef struct _ENUM_HANDLES_CONTEXT
{
	ULONG NormalAccessBits;
	ULONG DesiredAccessBits;
	HANDLE Handle;
} ENUM_HANDLES_CONTEXT, *PENUM_HANDLES_CONTEXT;

extern ULONG MmProtectToValue[32];
extern DYNAMIC_DATA DynData;
extern t_NtCreateThreadEx NtCreateThreadEx;
extern t_NtResumeThread NtResumeThread;
extern t_NtTerminateThread NtTerminateThread;
extern t_NtProtectVirtualMemory NtProtectVirtualMemory;

PVOID RegionBase = nullptr, MappedPages = nullptr;
PMDL Mdl = nullptr;

static
NTSTATUS
AllocatePhysicalMemory(
	_In_ PVOID *RequestedBaseAddress,
	_In_ SIZE_T Size,
	_In_ ULONG Protection
	)
{
	PVOID BaseAddress = PAGE_ALIGN(*RequestedBaseAddress);
	*RequestedBaseAddress = nullptr;
	Size = ADDRESS_AND_SIZE_TO_SPAN_PAGES(BaseAddress, Size) << PAGE_SHIFT;

	RegionBase = ExAllocatePoolWithTag(NonPagedPoolNx, Size, GetPoolTag());
	if (RegionBase == nullptr)
		return STATUS_NO_MEMORY;

	RtlZeroMemory(RegionBase, Size);

	Mdl = IoAllocateMdl(RegionBase, static_cast<ULONG>(Size), FALSE, FALSE, nullptr);
	if (Mdl == nullptr)
	{
		ExFreePool(RegionBase);
		return STATUS_NO_MEMORY;
	}

	MmBuildMdlForNonPagedPool(Mdl);

	__try
	{
		*RequestedBaseAddress = MmMapLockedPagesSpecifyCache(Mdl,
															UserMode,
															MmCached,
															BaseAddress,
															FALSE,
															NormalPagePriority | MdlMappingNoExecute);
	}
	__except (EXCEPTION_EXECUTE_HANDLER) { }

	if (*RequestedBaseAddress == nullptr)
	{
		__try
		{
			*RequestedBaseAddress = MmMapLockedPagesSpecifyCache(Mdl,
																UserMode,
																MmCached,
																nullptr,
																FALSE,
																NormalPagePriority | MdlMappingNoExecute);
		}
		__except (EXCEPTION_EXECUTE_HANDLER) { }
	}

	if (*RequestedBaseAddress == nullptr)
	{
		IoFreeMdl(Mdl);
		ExFreePool(RegionBase);
		return STATUS_NONE_MAPPED;
	}

	MappedPages = *RequestedBaseAddress;
	const ULONG_PTR FinalBaseAddress = reinterpret_cast<ULONG_PTR>(MappedPages);
	ProtectVAD(PsGetCurrentProcess(), FinalBaseAddress, MmProtectToValue[Protection]);

	if ((Protection & (PAGE_EXECUTE | PAGE_EXECUTE_READ | PAGE_EXECUTE_READWRITE | PAGE_EXECUTE_WRITECOPY)) != 0)
	{
		for (ULONG_PTR pAddress = FinalBaseAddress; pAddress < FinalBaseAddress + Size; pAddress += PAGE_SIZE)
		{
			GetPTEForVA(reinterpret_cast<PVOID>(pAddress))->u.Hard.NoExecute = 0;
		}
	}

	return STATUS_SUCCESS;
}

static
BOOLEAN
HandleEnumerationCallback(
#if NTDDI_VERSION > NTDDI_WIN7
	_In_ PHANDLE_TABLE HandleTable,
#endif
	_Inout_ PHANDLE_TABLE_ENTRY HandleTableEntry,
	_In_ HANDLE Handle,
	_In_ PVOID EnumParameter
	)
{
	PAGED_CODE();

	const PENUM_HANDLES_CONTEXT Context = static_cast<PENUM_HANDLES_CONTEXT>(EnumParameter);
	BOOLEAN Result = FALSE;

	if (HandleTableEntry->GrantedAccessBits == Context->DesiredAccessBits)
	{
		Context->Handle = Handle;
		Result = TRUE;
	}
	else if (HandleTableEntry->GrantedAccessBits == Context->NormalAccessBits)
	{
		HandleTableEntry->GrantedAccessBits = Context->DesiredAccessBits;
		Printf("Upgraded access mask of handle %02X from 0x%04X to 0x%04X.\n",
			HandleToULong(Handle), Context->NormalAccessBits, Context->DesiredAccessBits);

		Context->Handle = Handle;
		Result = TRUE;
	}

#if NTDDI_VERSION > NTDDI_WIN7
	_InterlockedExchangeAdd8(reinterpret_cast<PCHAR>(&HandleTableEntry->VolatileLowValue), 1);
	if (HandleTable != nullptr && HandleTable->HandleContentionEvent != 0)
		ExfUnblockPushLock(&HandleTable->HandleContentionEvent, nullptr);
#endif

	return Result;
}

static
NTSTATUS
SetCSRSSWindowStation(
	_In_ PEPROCESS Process,
	_Out_ PBOOLEAN ProcessIsCsrss
	)
{
	PAGED_CODE();

	*ProcessIsCsrss = FALSE;

	const PCHAR ProcessFileName = PsGetProcessImageFileName(Process);
	if (ProcessFileName == nullptr ||
		ProcessFileName[0] != 'c' || ProcessFileName[1] != 's' || ProcessFileName[2] != 'r' ||
		ProcessFileName[3] != 's' || ProcessFileName[4] != 's' || ProcessFileName[5] != '.' ||
		ProcessFileName[6] != 'e' || ProcessFileName[7] != 'x' || ProcessFileName[8] != 'e')
		return STATUS_SUCCESS;

	*ProcessIsCsrss = TRUE;

	const NTSTATUS Status = PsAcquireProcessExitSynchronization(Process);
	if (!NT_SUCCESS(Status))
		return Status;
	const PHANDLE_TABLE HandleTable = *reinterpret_cast<PHANDLE_TABLE*>(reinterpret_cast<PUCHAR>(Process) +
		DynData.ObjectTableOffset);
	if (HandleTable == nullptr)
	{
		PsReleaseProcessExitSynchronization(Process);
		return STATUS_NOT_FOUND;
	}

	ENUM_HANDLES_CONTEXT Context;
	Context.NormalAccessBits = (READ_CONTROL | DELETE | WRITE_DAC | WRITE_OWNER |
								0x1 /*WINSTA_ENUMDESKTOPS*/ | 0x2 /*WINSTA_READATTRIBUTES*/);	// 0xF0003
	Context.DesiredAccessBits = (READ_CONTROL | DELETE | WRITE_DAC | WRITE_OWNER |
								0x37F /*WINSTA_ALL_ACCESS*/);									// 0xF037F
	Context.Handle = nullptr;

	const BOOLEAN Found = ExEnumHandleTable(HandleTable,
										reinterpret_cast<PEX_ENUM_HANDLE_CALLBACK>(HandleEnumerationCallback),
										&Context,
										nullptr);

	PsReleaseProcessExitSynchronization(Process);

	if (!Found)
	{
		Printf("Could not find a useable window station handle in the CSRSS process handle table.\n");
		return STATUS_NOT_FOUND;
	}

	
	return STATUS_SUCCESS;
}

VOID
GetThreadStartName(
	_Out_ PANSI_STRING ThreadStartName
	)
{
	RtlZeroMemory(ThreadStartName->Buffer, ThreadStartName->MaximumLength);
	ThreadStartName->Length = 0;

	CONSTEXPR const ULONG NumThreadStartNames = 8;
	const ULONG Index = RtlNextRandom(0, NumThreadStartNames);
	NT_ASSERT(Index <= NumThreadStartNames - 1);

	switch (Index)
	{
		case 0:
		{
			DecryptString(EncryptedEtwpCreateEtwThreadString, ThreadStartName->Buffer);
			ThreadStartName->Length = decltype(EncryptedEtwpCreateEtwThreadString)::Length - sizeof(CHAR);
			break;
		}
		case 1:
		{
			DecryptString(EncryptedRtlActivateActivationContextExString, ThreadStartName->Buffer);
			ThreadStartName->Length = decltype(EncryptedRtlActivateActivationContextExString)::Length - sizeof(CHAR);
			break;
		}
		case 2:
		{
			DecryptString(EncryptedRtlCreateActivationContextString, ThreadStartName->Buffer);
			ThreadStartName->Length = decltype(EncryptedRtlCreateActivationContextString)::Length - sizeof(CHAR);
			break;
		}
		case 3:
		{
			DecryptString(EncryptedRtlQueryActivationContextApplicationSettingsString, ThreadStartName->Buffer);
			ThreadStartName->Length = decltype(EncryptedRtlQueryActivationContextApplicationSettingsString)::Length - sizeof(CHAR);
			break;
		}
		case 4:
		{
			DecryptString(EncryptedRtlValidateHeapString, ThreadStartName->Buffer);
			ThreadStartName->Length = decltype(EncryptedRtlValidateHeapString)::Length - sizeof(CHAR);
			break;
		}
		case 5:
		{
			DecryptString(EncryptedTpStartAsyncIoOperationString, ThreadStartName->Buffer);
			ThreadStartName->Length = decltype(EncryptedTpStartAsyncIoOperationString)::Length - sizeof(CHAR);
			break;
		}
		case 6:
		{
			DecryptString(EncryptedTpWaitForWorkString, ThreadStartName->Buffer);
			ThreadStartName->Length = decltype(EncryptedTpWaitForWorkString)::Length - sizeof(CHAR);
			break;
		}
		case 7:
		{
			DecryptString(EncryptedWinSqmEventWriteString, ThreadStartName->Buffer);
			ThreadStartName->Length = decltype(EncryptedWinSqmEventWriteString)::Length - sizeof(CHAR);
			break;
		}
		default:
			NT_ASSERT(FALSE);
			break;
	}
}

NTSTATUS
StartDllThread(
	_In_ PVOID ImageBase,
	_In_ ULONG EntryPointRva,
	_In_ BOOLEAN IsWow64
	)
{
	PAGED_CODE();

	PDLL_INIT_DATA DllInitData = nullptr;
	SIZE_T DllInitDataSize = sizeof(*DllInitData);
	PCONTEXT Context = nullptr;
	NTSTATUS Status;

	ULONG FunctionTableSize = 0;
	const PIMAGE_RUNTIME_FUNCTION_ENTRY ExceptionDirectory = !IsWow64 ? static_cast<PIMAGE_RUNTIME_FUNCTION_ENTRY>(
		RtlpImageDirectoryEntryToDataEx(ImageBase,
										TRUE,
										IMAGE_DIRECTORY_ENTRY_EXCEPTION,
										&FunctionTableSize))
		: nullptr;

	
	WCHAR NtdllNameBuffer[decltype(EncryptedNtdllString)::Length];
	DecryptString(EncryptedNtdllString, NtdllNameBuffer);
	UNICODE_STRING NtdllName = { decltype(EncryptedNtdllString)::Length - sizeof(WCHAR), decltype(EncryptedNtdllString)::Length, NtdllNameBuffer };
	const PVOID Ntdll = FindModule(PsGetCurrentProcess(), &NtdllName);

	CHAR RtlAddFunctionTableName[decltype(EncryptedRtlAddFunctionTableString)::Length];
	DecryptString(EncryptedRtlAddFunctionTableString, RtlAddFunctionTableName);
	const PVOID RtlAddFunctionTable = !IsWow64
									? GetModuleExport(Ntdll,
										RtlAddFunctionTableName,
										PsGetCurrentProcess())
									: nullptr;

	CHAR ThreadStartNameBuffer[128];
	ANSI_STRING ThreadStartName = { 0, sizeof(ThreadStartNameBuffer), ThreadStartNameBuffer };
	GetThreadStartName(&ThreadStartName);
	const PVOID ThreadStartRoutine = GetModuleExport(Ntdll,
													ThreadStartName.Buffer,
													PsGetCurrentProcess());

	RtlSecureZeroMemory(NtdllNameBuffer, decltype(EncryptedNtdllString)::Length);
	RtlSecureZeroMemory(RtlAddFunctionTableName, decltype(EncryptedRtlAddFunctionTableString)::Length);
	if ((!IsWow64 && RtlAddFunctionTable == nullptr) || ThreadStartRoutine == nullptr)
	{
		Printf("Failed to find required ntdll.dll exports RtlAddFunctionTable and/or %Z.\n", &ThreadStartName);
		Status = STATUS_PROCEDURE_NOT_FOUND;
		goto finished;
	}

	Status = NtAllocateVirtualMemory(NtCurrentProcess(),
									reinterpret_cast<PVOID*>(&DllInitData),
									0,
									&DllInitDataSize,
									MEM_COMMIT | MEM_RESERVE,
									PAGE_READWRITE);
	if (!NT_SUCCESS(Status))
	{
		Printf("NtAllocateVirtualMemory (DLL init data): %08X\n", Status);
		goto finished;
	}

	SIZE_T ContextSize = IsWow64 ? sizeof(WOW64_CONTEXT) : sizeof(CONTEXT);
	Status = NtAllocateVirtualMemory(NtCurrentProcess(),
									reinterpret_cast<PVOID*>(&Context),
									0,
									&ContextSize,
									MEM_COMMIT | MEM_RESERVE,
									PAGE_READWRITE);
	if (!NT_SUCCESS(Status))
	{
		Printf("NtAllocateVirtualMemory (context): %08X\n", Status);
		goto finished;
	}

	DllInitData->RtlAddFunctionTable = RtlAddFunctionTable;
	DllInitData->FunctionTable = reinterpret_cast<PRUNTIME_FUNCTION>(ExceptionDirectory);
	DllInitData->EntryCount = FunctionTableSize / sizeof(IMAGE_RUNTIME_FUNCTION_ENTRY);
	DllInitData->ImageBase = ImageBase;
	DllInitData->EntryPoint = static_cast<PUCHAR>(ImageBase) + EntryPointRva;
	RtlCopyMemory(DllInitData->InitFunction, IsWow64 ? DllInitializer32 : DllInitializer64,
		IsWow64 ? sizeof(DllInitializer32) : sizeof(DllInitializer64));

	if (IsWow64)
	{
		NT_ASSERT(DllInitData->InitFunction[31] == 0xF4);
		if (DynData.Version < WINVER_10_19H1)
		{
			DllInitData->InitFunction[31] = 0xF8;
		}
	}

	ULONG OldProtect;
	Status = NtProtectVirtualMemory(NtCurrentProcess(),
									reinterpret_cast<PVOID*>(&DllInitData),
									&DllInitDataSize,
									PAGE_EXECUTE,
									&OldProtect);
	if (!NT_SUCCESS(Status))
	{
		Printf("NtProtectVirtualMemory: %08X\n", Status);
		goto finished;
	}

	constexpr SIZE_T NumAttributes = 1;
	constexpr SIZE_T AttributesSize = sizeof(SIZE_T) + NumAttributes * sizeof(PS_ATTRIBUTE);
	PS_ATTRIBUTE_LIST AttributeList;
	RtlZeroMemory(&AttributeList, AttributesSize);
	AttributeList.TotalLength = AttributesSize;

	CLIENT_ID ClientId;
	RtlZeroMemory(&ClientId, sizeof(ClientId));
	AttributeList.Attributes[0].Attribute = PS_ATTRIBUTE_CLIENT_ID;
	AttributeList.Attributes[0].Size = sizeof(ClientId);
	AttributeList.Attributes[0].Value = reinterpret_cast<ULONG_PTR>(&ClientId);

	Printf("Creating thread with fake entry point 0x%p (ntdll!%Z).\n", ThreadStartRoutine, &ThreadStartName);
	OBJECT_ATTRIBUTES ObjectAttributes;
	InitializeObjectAttributes(&ObjectAttributes,
								nullptr,
								IsWow64 ? 0 : OBJ_KERNEL_HANDLE,
								nullptr,
								nullptr);

	const ULONG PspNotifyEnableMask = *DynData.pPspNotifyEnableMask;
	*DynData.pPspNotifyEnableMask = 0;

	HANDLE ThreadHandle;
	Status = NtCreateThreadEx(&ThreadHandle,
							THREAD_ALL_ACCESS,
							&ObjectAttributes,
							NtCurrentProcess(),
							reinterpret_cast<PUSER_THREAD_START_ROUTINE>(ThreadStartRoutine),
							DllInitData,
							THREAD_CREATE_FLAGS_CREATE_SUSPENDED |
							(DynData.Version <= WINVER_7_SP1 ? 0 : THREAD_CREATE_FLAGS_SUPPRESS_DLLMAINS),
							0,
							0,
							0,
							&AttributeList);

	*DynData.pPspNotifyEnableMask |= PspNotifyEnableMask;

	if (!NT_SUCCESS(Status))
	{
		Printf("NtCreateThreadEx: %08X\n", Status);
		goto finished;
	}

	InitializeStackCookie(ImageBase, &ClientId);

	if (IsWow64)
	{
		const KPROCESSOR_MODE PreviousMode = KeSetPreviousMode(UserMode);
		PWOW64_CONTEXT Wow64Context = reinterpret_cast<PWOW64_CONTEXT>(Context);
		RtlZeroMemory(Wow64Context, sizeof(*Wow64Context));
		Wow64Context->ContextFlags = CONTEXT_INTEGER | CONTEXT_CONTROL;

		Status = NtQueryInformationThread(ThreadHandle,
										ThreadWow64Context,
										Wow64Context,
										sizeof(*Wow64Context),
										nullptr);
		if (NT_SUCCESS(Status))
		{
			Wow64Context->Eax = static_cast<ULONG>(reinterpret_cast<ULONG_PTR>(static_cast<PVOID>(DllInitData->InitFunction)));

			Status = NtSetInformationThread(ThreadHandle,
											ThreadWow64Context,
											Wow64Context,
											sizeof(*Wow64Context));
			if (NT_SUCCESS(Status))
				Printf("Updated WOW64 thread context. Entry point: 0x%p, DllMain: 0x%p.\n",
					reinterpret_cast<PVOID>(DllInitData->InitFunction), DllInitData->EntryPoint);
		}

		KeSetPreviousMode(PreviousMode);
	}
	else
	{
		PETHREAD Thread = nullptr;
		Status = ObReferenceObjectByHandleWithTag(ThreadHandle,
												THREAD_ALL_ACCESS,
												*PsThreadType,
												KernelMode,
												GetPoolTag(),
												reinterpret_cast<PVOID*>(&Thread),
												nullptr);
		if (NT_SUCCESS(Status))
		{
			RtlZeroMemory(Context, sizeof(*Context));
			Context->ContextFlags = CONTEXT_INTEGER | CONTEXT_CONTROL;

			Status = PsGetContextThread(Thread, Context, UserMode);
			if (NT_SUCCESS(Status))
			{
#ifdef _M_AMD64
				Context->Rcx = reinterpret_cast<ULONG64>(static_cast<PVOID>(DllInitData->InitFunction));
#else
				Context->Eax = static_cast<ULONG>(reinterpret_cast<ULONG64>(static_cast<PVOID>(DllInitData->InitFunction)));
#endif

				Status = PsSetContextThread(Thread, Context, UserMode);
				if (NT_SUCCESS(Status))
					Printf("Updated thread context. Entry point: 0x%p, DllMain: 0x%p.\n",
						reinterpret_cast<PVOID>(DllInitData->InitFunction), DllInitData->EntryPoint);
			}
			ObfDereferenceObject(Thread);
		}
	}

	if (!NT_SUCCESS(Status))
	{
		Printf("Failed to set %s thread context: %08X\n", IsWow64 ? "WOW64" : "", Status);
		NtTerminateThread(ThreadHandle, Status);
		Printf("Thread terminated.\n");
	}
	else
	{
		NtResumeThread(ThreadHandle, nullptr);
		Printf("Thread resumed.\n");
	}

	ObCloseHandle(ThreadHandle, static_cast<KPROCESSOR_MODE>(IsWow64 ? UserMode : KernelMode));

	RtlSleep(250);

	__try
	{
		ProbeForWrite(ImageBase, sizeof(PVOID), alignof(PVOID));
	}
	__except (EXCEPTION_EXECUTE_HANDLER)
	{
		Printf("Process died! Returning immediately without cleanup.\n");
		return STATUS_PROCESS_IS_TERMINATING;
	}

finished:
	if (Context != nullptr)
	{
		RtlFillGarbageMemory(Context, sizeof(*Context));
		ContextSize = 0;
		NtFreeVirtualMemory(NtCurrentProcess(),
							reinterpret_cast<PVOID*>(&Context),
							&ContextSize,
							MEM_RELEASE);
	}
	if (DllInitData != nullptr)
	{
		if (NT_SUCCESS(NtProtectVirtualMemory(NtCurrentProcess(),
											reinterpret_cast<PVOID*>(&DllInitData),
											&DllInitDataSize,
											PAGE_READWRITE,
											&OldProtect)))
		{
			RtlFillGarbageMemory(DllInitData, sizeof(*DllInitData));
		}
		DllInitDataSize = 0;
		NtFreeVirtualMemory(NtCurrentProcess(),
							reinterpret_cast<PVOID*>(&DllInitData),
							&DllInitDataSize,
							MEM_RELEASE);
	}

	return Status;
}

NTSTATUS
InjectDll(
	_In_opt_ ULONG ProcessId,
	_In_opt_ PUNICODE_STRING ProcessName,
	_In_opt_ BOOLEAN WaitForNamedProcess,
	_In_ PUNICODE_STRING DllNtPath,
	_In_ BOOLEAN DeleteDll,
	_In_ BOOLEAN WipeImageHeaders
	)
{
	PAGED_CODE();
	
	PEPROCESS Process = nullptr;
	PEPROCESS_FLAGS2 Flags2 = nullptr;
	PEPROCESS_MITIGATION_FLAGS MitigationFlags = nullptr;
	UCHAR DisableDynamicCode = 0, RestrictSetThreadContext = 0;
	NTSTATUS Status;

	if (ProcessId != 0)
	{
		Printf("Opening process with PID %u...\n", ProcessId);
		Status = PsLookupProcessByProcessId(ULongToHandle(ProcessId), &Process);
	}
	else
	{
		Printf("Opening process %wZ...\n", ProcessName);
		Status = OpenSessionProcess(&Process,
									ProcessName,
									1,
									WaitForNamedProcess);
	}

	if (!NT_SUCCESS(Status))
	{
		if (Status == STATUS_INVALID_CID)
			Printf("Process with PID %u not found.\n", ProcessId);
		else if (Status != STATUS_CANCELLED)
			Printf("%s error %08X\n", (ProcessId != 0 ? "PsLookupProcessByProcessId" : "OpenSessionProcess"), Status);
		return Status;
	}
	else
		Printf("Process with PID %u found.\n", Process);

	if (Process != nullptr && PsGetProcessDebugPort(Process) != nullptr)
	{
		
		Printf("If you're reading this message, it means you're an idiot and got defeated by your own anti-debug check. Recompile and try again\n");
		ObfDereferenceObject(Process);
		return STATUS_SUCCESS;
	}

#ifdef _M_AMD64
	const BOOLEAN IsWow64 = PsGetProcessWow64Process(Process) != nullptr;
#else
	constexpr const BOOLEAN IsWow64 = FALSE;
#endif

	if (DynData.Version >= WINVER_81)
	{
		UCHAR CfgEnabled;
		Flags2 = reinterpret_cast<PEPROCESS_FLAGS2>(reinterpret_cast<PUCHAR>(Process) + DynData.EProcessFlags2Offset);
		if (DynData.Version <= WINVER_10_RS2)
		{
			CONST PEPROCESS_FLAGS Flags = reinterpret_cast<PEPROCESS_FLAGS>(reinterpret_cast<PUCHAR>(Process) + DynData.EProcessFlagsOffset);
			CfgEnabled = Flags->ControlFlowGuardEnabled;
			DisableDynamicCode = Flags2->DisableDynamicCode;
		}
		else
		{
			MitigationFlags = reinterpret_cast<PEPROCESS_MITIGATION_FLAGS>(reinterpret_cast<PUCHAR>(Process) + DynData.MitigationFlagsOffset);
			CfgEnabled = MitigationFlags->ControlFlowGuardEnabled;
			DisableDynamicCode = MitigationFlags->DisableDynamicCode;

			if (DynData.Version >= WINVER_10_RS4)
			{
				RestrictSetThreadContext = reinterpret_cast<PEPROCESS_FLAGS2_RS4_PLUS>(Flags2)->RestrictSetThreadContext;
			}
		}

		Printf("Process prohibits dynamic code execution? %s\n", DisableDynamicCode ? "YES. Removing..." : "no");
		if (DisableDynamicCode)
		{
			if (DynData.Version <= WINVER_10_RS2)
				Flags2->DisableDynamicCode = 0;
			else
				MitigationFlags->DisableDynamicCode = 0;
			Printf("\tRestriction removed.\n");
		}

		Printf("Process has Control Flow Guard? %s\n", CfgEnabled ? "YES. Patching..." : "no");
		if (CfgEnabled)
		{
			Status = PatchGuardCFCheckFunctionPointers(Process);
			Printf("%s\n", (NT_SUCCESS(Status)
				? "\tSuccesfully patched CFG guard check pointers."
				: "\tError: failed to patch CFG guard check pointers."));
			if (!NT_SUCCESS(Status))
				return Status;
		}
		
		Printf("Process restricts SetThreadContext? %s\n", RestrictSetThreadContext ? "YES. Handling it..." : "no");
		if (RestrictSetThreadContext)
		{
			reinterpret_cast<PEPROCESS_FLAGS2_RS4_PLUS>(Flags2)->RestrictSetThreadContext = 0;
			Printf("\tRestriction removed. Note that (un)setting RestrictSetThreadContext is *untested* because there is currently no documented interface and even system processes do not use it\n");
		}
	}

	bool Attached = false;
	Printf("Injecting %ls...\n", DllNtPath->Buffer + 4);

	PUCHAR EncryptedDllMemory = nullptr, DecryptedDllMemory = nullptr;
	SIZE_T EncryptedDllFileSize = 0, DecryptedDllFileSize = 0;
	Status = RtlReadFileToBytes(DllNtPath,
								&EncryptedDllMemory,
								&EncryptedDllFileSize);
	if (!NT_SUCCESS(Status))
		goto finished;

	if (DeleteDll)
	{
		Printf("Deleting DLL file... \n");
		OBJECT_ATTRIBUTES ObjectAttributes = RTL_CONSTANT_OBJECT_ATTRIBUTES(DllNtPath, OBJ_CASE_INSENSITIVE | OBJ_KERNEL_HANDLE);
		Status = NtDeleteFile(&ObjectAttributes);
		if (!NT_SUCCESS(Status))
		{
			Printf("failure (NtDeleteFile error %08X). Aborting injection.\n", Status);
			goto finished;
		}
		Printf("done.\n");
	}

	PIMAGE_NT_HEADERS NtHeaders;
	Status = DecryptPeFile(EncryptedDllMemory,
							EncryptedDllFileSize,
							&DecryptedDllMemory,
							&DecryptedDllFileSize,
							&NtHeaders);
	if (!NT_SUCCESS(Status))
	{
		Printf("Failed to decrypt DLL file: 0x%08X\n", Status);
		goto finished;
	}

	if ((IsWow64 && NtHeaders->FileHeader.Machine != IMAGE_FILE_MACHINE_I386) ||
		(!IsWow64 && NtHeaders->FileHeader.Machine != IMAGE_FILE_MACHINE_AMD64))
	{
		Printf("Error: wrong executable bitness (%u) for host process (%u).\n",
			NtHeaders->FileHeader.Machine == IMAGE_FILE_MACHINE_I386 ? 32 : 64,
			IsWow64 ? 32 : 64);
		Status = STATUS_INVALID_IMAGE_FORMAT;
		goto finished;
	}

	const PVOID HeadersImageBase = reinterpret_cast<PVOID>(HEADER_FIELD(NtHeaders, ImageBase));
	const SIZE_T HeadersSizeOfHeaders = static_cast<SIZE_T>(HEADER_FIELD(NtHeaders, SizeOfHeaders));
	SIZE_T HeadersSizeOfImage = static_cast<SIZE_T>(HEADER_FIELD(NtHeaders, SizeOfImage));
	const ULONG HeadersAddressOfEntryPoint = static_cast<ULONG>(HEADER_FIELD(NtHeaders, AddressOfEntryPoint));
	const PIMAGE_SECTION_HEADER SectionHeaders = reinterpret_cast<PIMAGE_SECTION_HEADER>(reinterpret_cast<PUCHAR>(NtHeaders) +
		sizeof(ULONG) + sizeof(IMAGE_FILE_HEADER) + NtHeaders->FileHeader.SizeOfOptionalHeader);

	BOOLEAN ProcessIsCsrss;
	Status = SetCSRSSWindowStation(Process, &ProcessIsCsrss);
	if (!NT_SUCCESS(Status))
		goto finished;

	if (!ProcessIsCsrss)
	{
		
		Status = RtlAdjustProcessPrivilege(Process,
										SE_LOAD_DRIVER_PRIVILEGE,
										TRUE);
		if (!NT_SUCCESS(Status))
		{
			Printf("Failed to enable SeLoadDriverPrivilege for target process: 0x%08X\n", Status);
			goto finished;
		}
	}

	const PVOID RandomisedImageBase = RandomiseSystemImageBase(Process, NtHeaders);
	PVOID RemoteImageBase = RandomisedImageBase;

	KAPC_STATE ApcState;
	KeStackAttachProcess(Process, &ApcState);
	Attached = true;

	BOOLEAN AllocatedPhysical = TRUE;
	Status = AllocatePhysicalMemory(&RemoteImageBase,
									HeadersSizeOfImage,
									PAGE_READWRITE);
	if (!NT_SUCCESS(Status))
	{
		AllocatedPhysical = FALSE;
		RemoteImageBase = RandomisedImageBase;
		Status = NtAllocateVirtualMemory(NtCurrentProcess(),
										&RemoteImageBase,
										0,
										&HeadersSizeOfImage,
										MEM_COMMIT | MEM_RESERVE,
										PAGE_READWRITE);
		if (Status == STATUS_CONFLICTING_ADDRESSES)
		{
			RemoteImageBase = nullptr;
			Status = NtAllocateVirtualMemory(NtCurrentProcess(),
											&RemoteImageBase,
											0,
											&HeadersSizeOfImage,
											MEM_COMMIT | MEM_RESERVE,
											PAGE_READWRITE);
		}
		if (!NT_SUCCESS(Status))
		{
			Printf("NtAllocateVirtualMemory: %08X\n", Status);
			goto finished;
		}
	}
	Printf("Allocated 0x%X bytes of %s memory in process at 0x%p.\n",
		static_cast<ULONG>(HeadersSizeOfImage), (AllocatedPhysical ? "PHYSICAL" : "VIRTUAL"), RemoteImageBase);

	if (RemoteImageBase != HeadersImageBase)
	{
		Printf("Relocating image from 0x%p to 0x%p...\n", HeadersImageBase, RemoteImageBase);
		Status = LdrRelocateImageData(DecryptedDllMemory, RemoteImageBase);
		if (!NT_SUCCESS(Status))
		{
			Printf("Failed to relocate image: %08X\n", Status);
			goto finished;
		}

		const PULONG_PTR ImageBaseRva = reinterpret_cast<PULONG_PTR>(IMAGE64(NtHeaders)
			? reinterpret_cast<ULONG_PTR>(&reinterpret_cast<PIMAGE_NT_HEADERS32>(NtHeaders)->OptionalHeader.ImageBase)
			: reinterpret_cast<ULONG_PTR>(&NtHeaders->OptionalHeader.ImageBase));
		if (IMAGE64(NtHeaders))
			*ImageBaseRva = reinterpret_cast<ULONG_PTR>(RemoteImageBase);
		else
			*reinterpret_cast<PULONG>(ImageBaseRva) = static_cast<ULONG>(reinterpret_cast<ULONG_PTR>(RemoteImageBase));
	}

	__try
	{
		RtlCopyMemory(RemoteImageBase, DecryptedDllMemory, HeadersSizeOfHeaders);
	}
	__except (EXCEPTION_EXECUTE_HANDLER)
	{
		Status = GetExceptionCode();
		Printf("RtlCopyMemory exception %08X\n", Status);
		goto finished;
	}

	ULONG OldProtect;
	if (!WipeImageHeaders)
	{
		if (AllocatedPhysical)
		{
			const PMMPTE PTE = GetPTEForVA(reinterpret_cast<PVOID>(RemoteImageBase));
			PTE->u.Hard.Dirty1 = PTE->u.Hard.Write = 0;
			PTE->u.Hard.NoExecute = 1;
		}
		else
		{
			PVOID HeaderPage = RemoteImageBase;
			SIZE_T HeaderSize = HeadersSizeOfHeaders;
			Status = NtProtectVirtualMemory(NtCurrentProcess(),
											&HeaderPage,
											&HeaderSize,
											PAGE_READONLY,
											&OldProtect);
			if (!NT_SUCCESS(Status))
			{
				Printf("NtProtectVirtualMemory (PE headers): %08X\n", Status);
				goto finished;
			}
		}
	}

	for (ULONG i = 0; i < NtHeaders->FileHeader.NumberOfSections; i++)
	{
		if (!(SectionHeaders[i].Characteristics & (IMAGE_SCN_MEM_READ | IMAGE_SCN_MEM_WRITE | IMAGE_SCN_MEM_EXECUTE)) ||
			SectionHeaders[i].PointerToRawData == 0)
			continue;

		const PVOID SectionVa = static_cast<PVOID>(static_cast<PUCHAR>(RemoteImageBase) + SectionHeaders[i].VirtualAddress);
		const PVOID SectionData = static_cast<PVOID>(DecryptedDllMemory + SectionHeaders[i].PointerToRawData);

		__try
		{
			RtlCopyMemory(SectionVa, SectionData, SectionHeaders[i].SizeOfRawData);
		}
		__except (EXCEPTION_EXECUTE_HANDLER)
		{
			Status = GetExceptionCode();
			Printf("RtlCopyMemory (section %u/%u): exception %08X\n",
				(i + 1), NtHeaders->FileHeader.NumberOfSections, Status);
			goto finished;
		}
	}
	Printf("Wrote %u PE sections to process.\n\n", NtHeaders->FileHeader.NumberOfSections);

	Status = ResolveImports(Process, RemoteImageBase, TRUE);
	if (!NT_SUCCESS(Status))
	{
		Printf("Failed to resolve imports for module; error %08X.\n", Status);
		goto finished;
	}

	Printf("Successfully resolved imports for module. \n", Status);

	if (AllocatedPhysical)
	{
		Status = ProtectVAD(Process, reinterpret_cast<ULONG_PTR>(RemoteImageBase), MM_READWRITE);
		if (!NT_SUCCESS(Status))
		{
			Printf("Failed to change VAD protection to MM_READWRITE; error %08X.\n", Status);
			goto finished;
		}
		Printf("Changed VAD protection to MM_READWRITE.\n");
	}

	for (ULONG i = 0; i < NtHeaders->FileHeader.NumberOfSections; i++)
	{
		if (!(SectionHeaders[i].Characteristics & (IMAGE_SCN_MEM_READ | IMAGE_SCN_MEM_WRITE | IMAGE_SCN_MEM_EXECUTE)) ||
			SectionHeaders[i].PointerToRawData == 0)
			continue;

		ULONG Characteristics = SectionHeaders[i].Characteristics;
		if ((Characteristics & IMAGE_SCN_MEM_DISCARDABLE) != 0)
			Characteristics |= IMAGE_SCN_MEM_WRITE;

		const ULONG Protection = CharacteristicsToPageProtection(Characteristics);
		SIZE_T SectionVirtualSize = SectionHeaders[i].Misc.VirtualSize > 0
			? SectionHeaders[i].Misc.VirtualSize
			: SectionHeaders[i].SizeOfRawData;
		PVOID SectionVa = static_cast<PVOID>(static_cast<PUCHAR>(RemoteImageBase) + SectionHeaders[i].VirtualAddress);

		if (AllocatedPhysical)
		{
			SectionVa = reinterpret_cast<PVOID>(ROUND_TO_PAGES(SectionVa));

			for (ULONG_PTR Address = reinterpret_cast<ULONG_PTR>(SectionVa);
				Address < reinterpret_cast<ULONG_PTR>(SectionVa) + SectionVirtualSize;
				Address += PAGE_SIZE)
			{
				const PMMPTE PTE = GetPTEForVA(reinterpret_cast<PVOID>(Address));
				if ((Characteristics & IMAGE_SCN_MEM_WRITE) == 0)
					PTE->u.Hard.Dirty1 = PTE->u.Hard.Write = 0;
				if ((Characteristics & IMAGE_SCN_MEM_EXECUTE) != 0)
					PTE->u.Hard.NoExecute = 0;
				else
					PTE->u.Hard.NoExecute = 1;
			}
		}
		else if (Protection != PAGE_NOACCESS)
		{
			Status = NtProtectVirtualMemory(NtCurrentProcess(),
											&SectionVa,
											&SectionVirtualSize,
											Protection,
											&OldProtect);
			if (!NT_SUCCESS(Status))
			{
				Printf("NtProtectVirtualMemory (section %u/%u): %08X\n",
					(i + 1), NtHeaders->FileHeader.NumberOfSections, Status);
				goto finished;
			}
		}
		else
		{
			NtFreeVirtualMemory(NtCurrentProcess(),
								&SectionVa,
								&SectionVirtualSize,
								MEM_DECOMMIT);
		}
	}

	Status = StartDllThread(RemoteImageBase,
							HeadersAddressOfEntryPoint,
							IsWow64);
	if (!NT_SUCCESS(Status))
		goto finished;

	WipeImageSections(RemoteImageBase,
						AllocatedPhysical,
						SectionHeaders,
						WipeImageHeaders);

finished:
	if (Attached)
		KeUnstackDetachProcess(&ApcState);

	if (DecryptedDllMemory != nullptr)
	{
		RtlFillGarbageMemory(DecryptedDllMemory, DecryptedDllFileSize);
		ExFreePool(DecryptedDllMemory);
	}

	if (EncryptedDllMemory != nullptr)
	{
		RtlFillGarbageMemory(EncryptedDllMemory, EncryptedDllFileSize);
		ExFreePool(EncryptedDllMemory);
	}

	if (DynData.Version >= WINVER_10_RS4 && RestrictSetThreadContext)
	{
		reinterpret_cast<PEPROCESS_FLAGS2_RS4_PLUS>(Flags2)->RestrictSetThreadContext = 1;
		Printf("Restored SetThreadContext restriction.\n");
	}

	if (DynData.Version >= WINVER_81 && DisableDynamicCode)
	{
		if (DynData.Version <= WINVER_10_RS2)
			Flags2->DisableDynamicCode = 1;
		else
			MitigationFlags->DisableDynamicCode = 1;
		Printf("Restored dynamic code restriction.\n");
	}

	if (Process != nullptr)
		ObfDereferenceObject(Process);

	if (NT_SUCCESS(Status))
		Printf("DLL injection successful.\n");

	return Status;
}

```

`MMInject/MMInject.h`:

```h
#pragma once

#if defined(__INTELLISENSE__) || defined(__RESHARPER__) || defined(__clang__)
#define _KERNEL_MODE 1
#if (defined(_WIN64) || defined(_AMD64_) || defined(AMD64)) && (!defined(_M_AMD64))
#define _M_AMD64 1
#endif
#endif

#include <intrin.h>
#include <ntifs.h>
#include "zwapi.h"
#include "BlackBone/Private.h"
#include <ntimage.h>

#if ((NTDDI_VERSION >= NTDDI_WIN8 && defined(_M_AMD64) && defined(NT_INLINE_IRQL)) && \
	!defined(NTDDI_WIN10_RS5))
	#error You need to update your WDK installation so that NT_INLINE_IRQL will work
#endif

#if !defined(NTDDI_WIN10_19H1)
	#define NTDDI_WIN10_19H1 (NTDDI_WIN10_RS5 + 1)
#endif

#if OBFUSCATE
#include "VMProtectDDK.h"
#else
#include "VMProtectStub.h"
#endif

#ifdef __cplusplus
extern "C" {
#endif

#if defined(__INTELLISENSE__) && defined(NT_ASSERT_ACTION)
	#undef NT_ASSERT_ACTION
	#undef NT_ASSERTMSG_ASSUME
	#undef NT_ASSERTMSGW_ASSUME
	#define NT_ASSERT_ACTION(exp)			(NT_ANALYSIS_ASSUME(exp), 0)
	#define NT_ASSERTMSG_ASSUME(msg, exp)	(NT_ANALYSIS_ASSUME(exp), 0)
	#define NT_ASSERTMSGW_ASSUME(msg, exp)	(NT_ANALYSIS_ASSUME(exp), 0)
#elif defined(__clang__)
	#ifdef PAGED_CODE
		#undef PAGED_CODE
		#define PAGED_CODE()				((void)0)
	#endif
	#ifdef ALLOC_PRAGMA
		
		#undef ALLOC_PRAGMA
		#undef ALLOC_DATA_PRAGMA
	#endif

	#pragma clang diagnostic ignored "-Wunknown-pragmas"
	#pragma clang diagnostic ignored "-Wmissing-field-initializers"
#endif
#if defined(__RESHARPER__)
	#undef DECLSPEC_IMPORT
	#define DECLSPEC_IMPORT extern
#endif

#ifdef __cplusplus
#define CONSTEXPR constexpr
#else
#define CONSTEXPR
#endif

#if defined(__RESHARPER__) || defined(__GNUC__)
#define PRINTF_ATTR(FormatIndex, FirstToCheck) \
	[[gnu::format(printf, FormatIndex, FirstToCheck)]]
#else
#define PRINTF_ATTR(FormatIndex, FirstToCheck)
#endif

#if defined(__RESHARPER__)
#define WPRINTF_ATTR(FormatIndex, FirstToCheck) \
	[[rscpp::format(wprintf, FormatIndex, FirstToCheck)]]
#else
#define WPRINTF_ATTR(FormatIndex, FirstToCheck)
#endif

#define IMAGE32(NtHeaders) ((NtHeaders)->OptionalHeader.Magic == IMAGE_NT_OPTIONAL_HDR32_MAGIC)
#define IMAGE64(NtHeaders) ((NtHeaders)->OptionalHeader.Magic == IMAGE_NT_OPTIONAL_HDR64_MAGIC)

#define HEADER_FIELD(NtHeaders, Field) (IMAGE64(NtHeaders) \
	? ((PIMAGE_NT_HEADERS64)(NtHeaders))->OptionalHeader.Field \
	: ((PIMAGE_NT_HEADERS32)(NtHeaders))->OptionalHeader.Field)
#define THUNK_VAL(NtHeaders, Ptr, Val) (IMAGE64(NtHeaders) \
	? ((PIMAGE_THUNK_DATA64)(Ptr))->Val \
	: ((PIMAGE_THUNK_DATA32)(Ptr))->Val)

#define ALIGN_TO_SECTIONS(Size, SectionAlign)	(((ULONG)(Size) + (SectionAlign) - 1) & ~((SectionAlign) - 1))

#ifndef ExFreePool
#define ExFreePool(P) ExFreePoolWithTag(P, 0UL)
#endif
#define ObfDereferenceObject(Object) ObfDereferenceObjectWithTag(Object, 'tlfD')

NTSYSAPI
ULONG
NtBuildNumber;

FORCEINLINE
PKTHREAD
KiGetCurrentThread(
	)
{
#ifdef _M_IX86
	return reinterpret_cast<PKTHREAD>(static_cast<ULONG_PTR>(__readfsdword(0x124)));
#else
	return reinterpret_cast<PKTHREAD>(static_cast<ULONG_PTR>(__readgsqword(0x188)));
#endif
}

CONSTEXPR
FORCEINLINE
LONGLONG
RtlMsToTicks(
	_In_ ULONG Milliseconds
	)
{
	return 10000LL * static_cast<LONGLONG>(Milliseconds);
}

FORCEINLINE
VOID
RtlSleep(
	_In_ ULONG Milliseconds
	)
{
	LARGE_INTEGER Timeout;
	Timeout.QuadPart = -1 * RtlMsToTicks(Milliseconds);
	KeDelayExecutionThread(KernelMode, FALSE, &Timeout);
}

CONSTEXPR
FORCEINLINE
BOOLEAN
IsWin64(
	)
{
#if defined(_WIN64) || defined(_M_AMD64)
	return TRUE;
#else
	return FALSE;
#endif
}

CONSTEXPR
FORCEINLINE
BOOLEAN
RtlIsCanonicalAddress(
	ULONG_PTR Address
	)
{
#if !defined(_WIN64) && !defined(_M_AMD64)
	UNREFERENCED_PARAMETER(Address);
	return true;
#else

	return (((Address & 0xFFFF800000000000) + 0x800000000000) & ~0x800000000000) == 0;
#endif
}

typedef
NTSTATUS
(NTAPI*
t_NtCreateThreadEx)(
	_Out_ PHANDLE ThreadHandle,
	_In_ ACCESS_MASK DesiredAccess,
	_In_opt_ POBJECT_ATTRIBUTES ObjectAttributes,
	_In_ HANDLE ProcessHandle,
	_In_ PUSER_THREAD_START_ROUTINE StartRoutine,
	_In_opt_ PVOID Argument,
	_In_ ULONG CreateFlags,
	_In_opt_ ULONG_PTR ZeroBits,
	_In_opt_ SIZE_T StackSize,
	_In_opt_ SIZE_T MaximumStackSize,
	_In_opt_ PPS_ATTRIBUTE_LIST AttributeList
	);

typedef
NTSTATUS
(NTAPI*
t_NtResumeThread)(
	_In_ HANDLE ThreadHandle,
	_Out_opt_ PULONG PreviousSuspendCount
	);

typedef
NTSTATUS
(NTAPI*
t_NtTerminateThread)(
	_In_opt_ HANDLE ThreadHandle,
	_In_ NTSTATUS ExitStatus
	);

typedef
NTSTATUS
(NTAPI*
t_NtProtectVirtualMemory)(
	_In_ HANDLE ProcessHandle,
	_Inout_ PVOID *BaseAddress,
	_Inout_ PSIZE_T RegionSize,
	_In_ ULONG NewProtect,
	_Out_ PULONG OldProtect
	);

#if !OBFUSCATE
PRINTF_ATTR(1, 2)
VOID
Printf(
	_In_ PCCH Format,
	_In_ ...
	);
#else
#define Printf(...) NT_ANALYSIS_ASSUME(__VA_ARGS__)
#endif

_Function_class_(DRIVER_INITIALIZE)
_IRQL_requires_(PASSIVE_LEVEL)
DRIVER_INITIALIZE
DriverEntry;

_Function_class_(DRIVER_UNLOAD)
_IRQL_requires_(PASSIVE_LEVEL)
DRIVER_UNLOAD
DriverUnload;

_Function_class_(IO_WORKITEM_ROUTINE_EX)
_IRQL_requires_(PASSIVE_LEVEL)
_IRQL_requires_same_
IO_WORKITEM_ROUTINE_EX
InjectDllWorker;

_Function_class_(IO_WORKITEM_ROUTINE_EX)
_IRQL_requires_(PASSIVE_LEVEL)
_IRQL_requires_same_
IO_WORKITEM_ROUTINE_EX
CleanMmUnloadedDriversWorker;

NTSTATUS
StartDllThread(
	_In_ PVOID ImageBase,
	_In_ ULONG EntryPointRva,
	_In_ BOOLEAN IsWow64
	);

NTSTATUS
InjectDll(
	_In_opt_ ULONG ProcessId,
	_In_opt_ PUNICODE_STRING ProcessName,
	_In_opt_ BOOLEAN WaitForNamedProcess,
	_In_ PUNICODE_STRING DllNtPath,
	_In_ BOOLEAN DeleteDll,
	_In_ BOOLEAN WipeImageHeaders
	);

PIMAGE_NT_HEADERS
NTAPI
RtlpImageNtHeaderEx(
	_In_ PVOID Base,
	_In_opt_ SIZE_T Size
	);

PVOID
GetProcedureAddress(
	_In_ ULONG_PTR DllBase,
	_In_ PCSTR RoutineName
	);

PVOID
GetFileDataProcedureAddress(
	_In_ ULONG_PTR FileData,
	_In_ PCSTR RoutineName
	);

ULONG
RvaToOffset(
	_In_ PIMAGE_NT_HEADERS NtHeaders,
	_In_ ULONG Rva
	);

PVOID
NTAPI
RtlpImageDirectoryEntryToDataEx(
	_In_ PVOID Base,
	_In_ BOOLEAN MappedAsImage,
	_In_ USHORT DirectoryEntry,
	_Out_ PULONG Size
	);

#ifdef __cplusplus
extern "C++"
CONSTEXPR
#endif
ULONG
CharacteristicsToPageProtection(
	_In_ ULONG SectionCharacteristics
	);

#ifdef __cplusplus
extern "C++"
CONSTEXPR
#endif
BOOLEAN
IsVadProtectionChangeAllowed(
	_In_ PMMVAD_SHORT VadShort
	);

#if NTDDI_VERSION >= NTDDI_WIN10

#ifdef __cplusplus
extern "C++"
CONSTEXPR
#endif
BOOLEAN
IsVadProtectionChangeAllowed19H1(
	_In_ PMMVAD_SHORT_19H1 VadShort
	);

#endif

NTSTATUS
LdrRelocateImageData(
	_In_ PVOID FileData,
	_In_ PVOID NewBase
	);

NTSTATUS
PatchGuardCFCheckFunctionPointers(
	_In_ PEPROCESS Process
	);

VOID
InitializeStackCookie(
	_In_ PVOID ImageBase,
	_In_ PCLIENT_ID ClientId
	);

PVOID
RandomiseImageBase(
	_In_ PIMAGE_NT_HEADERS NtHeaders,
	_In_opt_ PVOID PreferredBase
	);

PVOID
RandomiseSystemImageBase(
	_In_ PEPROCESS Process,
	_In_ PIMAGE_NT_HEADERS NtHeaders
	);

NTSTATUS
ResolveImports(
	_In_ PEPROCESS Process,
	_In_ PVOID ImageBase,
	_In_ BOOLEAN WipeNames
	);

VOID
WipeImageSections(
	_In_ PVOID ImageBase,
	_In_ BOOLEAN PhysicalAllocation,
	_In_ PIMAGE_SECTION_HEADER SectionHeaders,
	_In_ BOOLEAN WipeHeaders
	);

NTSTATUS
NTAPI
IopGetFileSize(
	_In_ PFILE_OBJECT FileObject,
	_Inout_ PLARGE_INTEGER FileSize
	);

NTSTATUS
NTAPI
IopReadFile(
	_In_ PFILE_OBJECT FileObject,
	_Out_ PIO_STATUS_BLOCK IoStatusBlock,
	_Out_ PVOID Buffer,
	_In_ ULONG Length,
	_In_ PLARGE_INTEGER ByteOffset
	);

PDEVICE_OBJECT
IopGetBaseFsDeviceObject(
	_In_ PUNICODE_STRING FileName
	);

NTSTATUS
RtlReadFileToBytes(
	_In_ PUNICODE_STRING NtPath,
	_Out_ PUCHAR *Buffer,
	_Out_opt_ PSIZE_T FileSize
	);

VOID
CreateProcessNotifyRoutine(
	_Inout_ PEPROCESS Process,
	_In_ HANDLE ProcessId,
	_Inout_opt_ PPS_CREATE_NOTIFY_INFO CreateInfo
	);

NTSTATUS
OpenSessionProcess(
	_Out_ PEPROCESS *Process,
	_In_ PUNICODE_STRING ProcessName,
	_In_ ULONG SessionId,
	_In_ BOOLEAN Wait
	);

VOID
CancelAllProcessWaits(
	);

KPROCESSOR_MODE
KeSetPreviousMode(
	_In_ KPROCESSOR_MODE ProcessorMode
	);

PVOID
GetSyscallAddress(
	_In_ PCSTR FunctionName
	);

NTSTATUS
SsdtInitialize(
	);

VOID
SsdtUninitialize(
	);

NTSTATUS
LocatePageTables(
	_Inout_ PDYNAMIC_DATA Data
	);

NTSTATUS
LocatePspNotifyEnableMask(
	_Inout_ PDYNAMIC_DATA Data
	);

NTSTATUS
LocateMmUnloadedDrivers(
	_Inout_ PDYNAMIC_DATA Data
	);

NTSTATUS
LocatePiDDBCacheTable(
	_Inout_ PDYNAMIC_DATA Data
	);

NTSTATUS
DecryptPeFile(
	_In_ PUCHAR EncryptedDllBuffer,
	_In_ SIZE_T EncryptedDllSize,
	_Out_ PUCHAR *DecryptedDllBuffer,
	_Out_ PSIZE_T DecryptedDllSize,
	_Out_ PIMAGE_NT_HEADERS *NtHeaders
	);

#ifdef __cplusplus
}
#endif

```

`MMInject/MMInject.vcxproj`:

```vcxproj
<?xml version="1.0" encoding="utf-8"?>
<Project DefaultTargets="Build" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup Label="ProjectConfigurations">
    <ProjectConfiguration Include="Debug Win 8.1|Win32">
      <Configuration>Debug Win 8.1</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug Win 8.1|x64">
      <Configuration>Debug Win 8.1</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug Win 10|Win32">
      <Configuration>Debug Win 10</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug Win 10|x64">
      <Configuration>Debug Win 10</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug Win 7|Win32">
      <Configuration>Debug Win 7</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug Win 7|x64">
      <Configuration>Debug Win 7</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release Win 10 Obfuscated|Win32">
      <Configuration>Release Win 10 Obfuscated</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release Win 10 Obfuscated|x64">
      <Configuration>Release Win 10 Obfuscated</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release Win 7 Obfuscated|Win32">
      <Configuration>Release Win 7 Obfuscated</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release Win 7 Obfuscated|x64">
      <Configuration>Release Win 7 Obfuscated</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release Win 8.1 Obfuscated|Win32">
      <Configuration>Release Win 8.1 Obfuscated</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release Win 8.1 Obfuscated|x64">
      <Configuration>Release Win 8.1 Obfuscated</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release Win 8.1|Win32">
      <Configuration>Release Win 8.1</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release Win 8.1|x64">
      <Configuration>Release Win 8.1</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release Win 10|Win32">
      <Configuration>Release Win 10</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release Win 10|x64">
      <Configuration>Release Win 10</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release Win 7|Win32">
      <Configuration>Release Win 7</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release Win 7|x64">
      <Configuration>Release Win 7</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
  </ItemGroup>
  <PropertyGroup Label="Globals">
    <VCProjectVersion>16.0</VCProjectVersion>
    <ProjectGuid>{C3E92B7A-36D7-4f85-BFFA-8D3707EE7F2A}</ProjectGuid>
    <TemplateGuid>{1bc93793-694f-48fe-9372-81e2b05556fd}</TemplateGuid>
    <TargetFrameworkVersion>v4.6.2</TargetFrameworkVersion>
    <MinimumVisualStudioVersion>14.0</MinimumVisualStudioVersion>
    <Configuration>Debug Win 10</Configuration>
    <WindowsTargetPlatformVersion>$(LatestTargetPlatformVersion)</WindowsTargetPlatformVersion>
    <Platform Condition="'$(Platform)' == ''">x64</Platform>
    <RootNamespace>injector</RootNamespace>
    <KMDF_VERSION_MAJOR>1</KMDF_VERSION_MAJOR>
    <KMDF_VERSION_MINOR>9</KMDF_VERSION_MINOR>
    <ProjectName>MMInject</ProjectName>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug Win 7|Win32'" Label="Configuration">
    <TargetVersion>Windows7</TargetVersion>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>WDM</DriverType>
    <SupportsPackaging>false</SupportsPackaging>
    <DriverTargetPlatform>Desktop</DriverTargetPlatform>
    <SpectreMitigation>false</SpectreMitigation>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug Win 10|Win32'" Label="Configuration">
    <TargetVersion />
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>WDM</DriverType>
    <SupportsPackaging>false</SupportsPackaging>
    <DriverTargetPlatform>Desktop</DriverTargetPlatform>
    <SpectreMitigation>false</SpectreMitigation>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug Win 8.1|Win32'" Label="Configuration">
    <TargetVersion>WindowsV6.3</TargetVersion>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>WDM</DriverType>
    <SupportsPackaging>false</SupportsPackaging>
    <DriverTargetPlatform>Desktop</DriverTargetPlatform>
    <SpectreMitigation>false</SpectreMitigation>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug Win 7|x64'" Label="Configuration">
    <TargetVersion>Windows7</TargetVersion>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>WDM</DriverType>
    <SupportsPackaging>false</SupportsPackaging>
    <DriverTargetPlatform>Desktop</DriverTargetPlatform>
    <SpectreMitigation>false</SpectreMitigation>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug Win 10|x64'" Label="Configuration">
    <TargetVersion />
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>WDM</DriverType>
    <SupportsPackaging>false</SupportsPackaging>
    <DriverTargetPlatform>Desktop</DriverTargetPlatform>
    <SpectreMitigation>false</SpectreMitigation>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug Win 8.1|x64'" Label="Configuration">
    <TargetVersion>WindowsV6.3</TargetVersion>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>WDM</DriverType>
    <SupportsPackaging>false</SupportsPackaging>
    <DriverTargetPlatform>Desktop</DriverTargetPlatform>
    <SpectreMitigation>false</SpectreMitigation>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release Win 7|Win32'" Label="Configuration">
    <TargetVersion>Windows7</TargetVersion>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>WDM</DriverType>
    <SupportsPackaging>false</SupportsPackaging>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <DriverTargetPlatform>Desktop</DriverTargetPlatform>
    <SpectreMitigation>false</SpectreMitigation>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release Win 7 Obfuscated|Win32'" Label="Configuration">
    <TargetVersion>Windows7</TargetVersion>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>WDM</DriverType>
    <SupportsPackaging>false</SupportsPackaging>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <DriverTargetPlatform>Desktop</DriverTargetPlatform>
    <SpectreMitigation>false</SpectreMitigation>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release Win 10|Win32'" Label="Configuration">
    <TargetVersion />
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>WDM</DriverType>
    <SupportsPackaging>false</SupportsPackaging>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <DriverTargetPlatform>Desktop</DriverTargetPlatform>
    <SpectreMitigation>false</SpectreMitigation>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release Win 10 Obfuscated|Win32'" Label="Configuration">
    <TargetVersion />
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>WDM</DriverType>
    <SupportsPackaging>false</SupportsPackaging>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <DriverTargetPlatform>Desktop</DriverTargetPlatform>
    <SpectreMitigation>false</SpectreMitigation>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release Win 8.1|Win32'" Label="Configuration">
    <TargetVersion>WindowsV6.3</TargetVersion>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>WDM</DriverType>
    <SupportsPackaging>false</SupportsPackaging>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <DriverTargetPlatform>Desktop</DriverTargetPlatform>
    <SpectreMitigation>false</SpectreMitigation>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release Win 8.1 Obfuscated|Win32'" Label="Configuration">
    <TargetVersion>WindowsV6.3</TargetVersion>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>WDM</DriverType>
    <SupportsPackaging>false</SupportsPackaging>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <DriverTargetPlatform>Desktop</DriverTargetPlatform>
    <SpectreMitigation>false</SpectreMitigation>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release Win 7|x64'" Label="Configuration">
    <TargetVersion>Windows7</TargetVersion>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>WDM</DriverType>
    <SupportsPackaging>false</SupportsPackaging>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <DriverTargetPlatform>Desktop</DriverTargetPlatform>
    <SpectreMitigation>false</SpectreMitigation>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release Win 7 Obfuscated|x64'" Label="Configuration">
    <TargetVersion>Windows7</TargetVersion>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>WDM</DriverType>
    <SupportsPackaging>false</SupportsPackaging>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <DriverTargetPlatform>Desktop</DriverTargetPlatform>
    <SpectreMitigation>false</SpectreMitigation>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release Win 10|x64'" Label="Configuration">
    <TargetVersion />
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>WDM</DriverType>
    <SupportsPackaging>false</SupportsPackaging>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <DriverTargetPlatform>Desktop</DriverTargetPlatform>
    <SpectreMitigation>false</SpectreMitigation>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release Win 10 Obfuscated|x64'" Label="Configuration">
    <TargetVersion />
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>WDM</DriverType>
    <SupportsPackaging>false</SupportsPackaging>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <DriverTargetPlatform>Desktop</DriverTargetPlatform>
    <SpectreMitigation>false</SpectreMitigation>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release Win 8.1|x64'" Label="Configuration">
    <TargetVersion>WindowsV6.3</TargetVersion>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>WDM</DriverType>
    <SupportsPackaging>false</SupportsPackaging>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <DriverTargetPlatform>Desktop</DriverTargetPlatform>
    <SpectreMitigation>false</SpectreMitigation>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release Win 8.1 Obfuscated|x64'" Label="Configuration">
    <TargetVersion>WindowsV6.3</TargetVersion>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>WDM</DriverType>
    <SupportsPackaging>false</SupportsPackaging>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <DriverTargetPlatform>Desktop</DriverTargetPlatform>
    <SpectreMitigation>false</SpectreMitigation>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
  <ImportGroup Label="ExtensionSettings">
  </ImportGroup>
  <ImportGroup Label="Shared">
  </ImportGroup>
  <ImportGroup Label="PropertySheets">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <PropertyGroup Label="UserMacros" />
  <PropertyGroup Label="PropertySheets">
    <DisableProductionSignDebugWarnings>true</DisableProductionSignDebugWarnings>
  </PropertyGroup>
  <PropertyGroup />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug Win 7|Win32'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
    <TimeStampServer />
    <OutDir>$(SolutionDir)bin\Win7\</OutDir>
    <IntDir>obj\$(Platform)-$(Configuration)\</IntDir>
    <EnableInf2cat>false</EnableInf2cat>
    <CodeAnalysisRuleSet>..\..\..\..\..\..\..\Program Files (x86)\Windows Kits\10\CodeAnalysis\DriverRecommendedRules.ruleset</CodeAnalysisRuleSet>
    <LibraryPath>C:\Program Files (x86)\Windows Kits\10\Lib\10.0.17763.0\km\x86;$(DDK_LibraryPath_DDKPlatform);$(LibraryPath)</LibraryPath>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug Win 10|Win32'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
    <TimeStampServer />
    <OutDir>$(SolutionDir)bin\Win10\</OutDir>
    <IntDir>obj\$(Platform)-$(Configuration)\</IntDir>
    <EnableInf2cat>false</EnableInf2cat>
    <CodeAnalysisRuleSet>..\..\..\..\..\..\..\Program Files (x86)\Windows Kits\10\CodeAnalysis\DriverRecommendedRules.ruleset</CodeAnalysisRuleSet>
    <LibraryPath>C:\Program Files (x86)\Windows Kits\10\Lib\10.0.17763.0\km\x86;$(DDK_LibraryPath_DDKPlatform);$(LibraryPath)</LibraryPath>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug Win 8.1|Win32'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
    <TimeStampServer />
    <OutDir>$(SolutionDir)bin\Win8.1\</OutDir>
    <IntDir>obj\$(Platform)-$(Configuration)\</IntDir>
    <EnableInf2cat>false</EnableInf2cat>
    <CodeAnalysisRuleSet>..\..\..\..\..\..\..\Program Files (x86)\Windows Kits\10\CodeAnalysis\DriverRecommendedRules.ruleset</CodeAnalysisRuleSet>
    <LibraryPath>C:\Program Files (x86)\Windows Kits\10\Lib\10.0.17763.0\km\x86;$(DDK_LibraryPath_DDKPlatform);$(LibraryPath)</LibraryPath>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug Win 7|x64'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
    <TimeStampServer />
    <OutDir>$(SolutionDir)bin\Win7\</OutDir>
    <IntDir>obj\$(Platform)-$(Configuration)\</IntDir>
    <EnableInf2cat>false</EnableInf2cat>
    <CodeAnalysisRuleSet>..\..\..\..\..\..\..\Program Files (x86)\Windows Kits\10\CodeAnalysis\DriverRecommendedRules.ruleset</CodeAnalysisRuleSet>
    <LibraryPath>C:\Program Files (x86)\Windows Kits\10\Lib\10.0.17763.0\km\x64;$(DDK_LibraryPath_DDKPlatform);$(LibraryPath)</LibraryPath>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug Win 10|x64'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
    <TimeStampServer />
    <OutDir>$(SolutionDir)bin\Win10\</OutDir>
    <IntDir>obj\$(Platform)-$(Configuration)\</IntDir>
    <EnableInf2cat>false</EnableInf2cat>
    <CodeAnalysisRuleSet>..\..\..\..\..\..\..\Program Files (x86)\Windows Kits\10\CodeAnalysis\DriverRecommendedRules.ruleset</CodeAnalysisRuleSet>
    <LibraryPath>C:\Program Files (x86)\Windows Kits\10\Lib\10.0.17763.0\km\x64;$(DDK_LibraryPath_DDKPlatform);$(LibraryPath)</LibraryPath>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug Win 8.1|x64'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
    <TimeStampServer />
    <OutDir>$(SolutionDir)bin\Win8.1\</OutDir>
    <IntDir>obj\$(Platform)-$(Configuration)\</IntDir>
    <EnableInf2cat>false</EnableInf2cat>
    <CodeAnalysisRuleSet>..\..\..\..\..\..\..\Program Files (x86)\Windows Kits\10\CodeAnalysis\DriverRecommendedRules.ruleset</CodeAnalysisRuleSet>
    <LibraryPath>C:\Program Files (x86)\Windows Kits\10\Lib\10.0.17763.0\km\x64;$(DDK_LibraryPath_DDKPlatform);$(LibraryPath)</LibraryPath>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release Win 7|Win32'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
    <TimeStampServer />
    <OutDir>$(SolutionDir)bin\Win7\</OutDir>
    <IntDir>obj\$(Platform)-$(Configuration)\</IntDir>
    <EnableInf2cat>false</EnableInf2cat>
    <CodeAnalysisRuleSet>..\..\..\..\..\..\..\Program Files (x86)\Windows Kits\10\CodeAnalysis\DriverRecommendedRules.ruleset</CodeAnalysisRuleSet>
    <LibraryPath>C:\Program Files (x86)\Windows Kits\10\Lib\10.0.17763.0\km\x86;$(DDK_LibraryPath_DDKPlatform);$(LibraryPath)</LibraryPath>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release Win 7 Obfuscated|Win32'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
    <TimeStampServer />
    <OutDir>$(SolutionDir)bin\Win7\</OutDir>
    <IntDir>obj\$(Platform)-$(Configuration)\</IntDir>
    <EnableInf2cat>false</EnableInf2cat>
    <CodeAnalysisRuleSet>..\..\..\..\..\..\..\Program Files (x86)\Windows Kits\10\CodeAnalysis\DriverRecommendedRules.ruleset</CodeAnalysisRuleSet>
    <LibraryPath>C:\Program Files (x86)\Windows Kits\10\Lib\10.0.17763.0\km\x86;$(DDK_LibraryPath_DDKPlatform);$(LibraryPath)</LibraryPath>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release Win 10|Win32'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
    <TimeStampServer />
    <OutDir>$(SolutionDir)bin\Win10\</OutDir>
    <IntDir>obj\$(Platform)-$(Configuration)\</IntDir>
    <EnableInf2cat>false</EnableInf2cat>
    <CodeAnalysisRuleSet>..\..\..\..\..\..\..\Program Files (x86)\Windows Kits\10\CodeAnalysis\DriverRecommendedRules.ruleset</CodeAnalysisRuleSet>
    <LibraryPath>C:\Program Files (x86)\Windows Kits\10\Lib\10.0.17763.0\km\x86;$(DDK_LibraryPath_DDKPlatform);$(LibraryPath)</LibraryPath>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release Win 10 Obfuscated|Win32'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
    <TimeStampServer />
    <OutDir>$(SolutionDir)bin\Win10\</OutDir>
    <IntDir>obj\$(Platform)-$(Configuration)\</IntDir>
    <EnableInf2cat>false</EnableInf2cat>
    <CodeAnalysisRuleSet>..\..\..\..\..\..\..\Program Files (x86)\Windows Kits\10\CodeAnalysis\DriverRecommendedRules.ruleset</CodeAnalysisRuleSet>
    <LibraryPath>C:\Program Files (x86)\Windows Kits\10\Lib\10.0.17763.0\km\x86;$(DDK_LibraryPath_DDKPlatform);$(LibraryPath)</LibraryPath>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release Win 8.1|Win32'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
    <TimeStampServer />
    <OutDir>$(SolutionDir)bin\Win8.1\</OutDir>
    <IntDir>obj\$(Platform)-$(Configuration)\</IntDir>
    <EnableInf2cat>false</EnableInf2cat>
    <CodeAnalysisRuleSet>..\..\..\..\..\..\..\Program Files (x86)\Windows Kits\10\CodeAnalysis\DriverRecommendedRules.ruleset</CodeAnalysisRuleSet>
    <LibraryPath>C:\Program Files (x86)\Windows Kits\10\Lib\10.0.17763.0\km\x86;$(DDK_LibraryPath_DDKPlatform);$(LibraryPath)</LibraryPath>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release Win 8.1 Obfuscated|Win32'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
    <TimeStampServer />
    <OutDir>$(SolutionDir)bin\Win8.1\</OutDir>
    <IntDir>obj\$(Platform)-$(Configuration)\</IntDir>
    <EnableInf2cat>false</EnableInf2cat>
    <CodeAnalysisRuleSet>..\..\..\..\..\..\..\Program Files (x86)\Windows Kits\10\CodeAnalysis\DriverRecommendedRules.ruleset</CodeAnalysisRuleSet>
    <LibraryPath>C:\Program Files (x86)\Windows Kits\10\Lib\10.0.17763.0\km\x86;$(DDK_LibraryPath_DDKPlatform);$(LibraryPath)</LibraryPath>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release Win 7|x64'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
    <TimeStampServer />
    <OutDir>$(SolutionDir)bin\Win7\</OutDir>
    <IntDir>obj\$(Platform)-$(Configuration)\</IntDir>
    <EnableInf2cat>false</EnableInf2cat>
    <CodeAnalysisRuleSet>..\..\..\..\..\..\..\Program Files (x86)\Windows Kits\10\CodeAnalysis\DriverRecommendedRules.ruleset</CodeAnalysisRuleSet>
    <LibraryPath>C:\Program Files (x86)\Windows Kits\10\Lib\10.0.17763.0\km\x64;$(DDK_LibraryPath_DDKPlatform);$(LibraryPath)</LibraryPath>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release Win 7 Obfuscated|x64'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
    <TimeStampServer />
    <OutDir>$(SolutionDir)bin\Win7\</OutDir>
    <IntDir>obj\$(Platform)-$(Configuration)\</IntDir>
    <EnableInf2cat>false</EnableInf2cat>
    <CodeAnalysisRuleSet>..\..\..\..\..\..\..\Program Files (x86)\Windows Kits\10\CodeAnalysis\DriverRecommendedRules.ruleset</CodeAnalysisRuleSet>
    <LibraryPath>C:\Program Files (x86)\Windows Kits\10\Lib\10.0.17763.0\km\x64;$(DDK_LibraryPath_DDKPlatform);$(LibraryPath)</LibraryPath>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release Win 10|x64'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
    <TimeStampServer />
    <OutDir>$(SolutionDir)bin\Win10\</OutDir>
    <IntDir>obj\$(Platform)-$(Configuration)\</IntDir>
    <EnableInf2cat>false</EnableInf2cat>
    <CodeAnalysisRuleSet>..\..\..\..\..\..\..\Program Files (x86)\Windows Kits\10\CodeAnalysis\DriverRecommendedRules.ruleset</CodeAnalysisRuleSet>
    <LibraryPath>C:\Program Files (x86)\Windows Kits\10\Lib\10.0.17763.0\km\x64;$(DDK_LibraryPath_DDKPlatform);$(LibraryPath)</LibraryPath>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release Win 10 Obfuscated|x64'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
    <TimeStampServer />
    <OutDir>$(SolutionDir)bin\Win10\</OutDir>
    <IntDir>obj\$(Platform)-$(Configuration)\</IntDir>
    <EnableInf2cat>false</EnableInf2cat>
    <CodeAnalysisRuleSet>..\..\..\..\..\..\..\Program Files (x86)\Windows Kits\10\CodeAnalysis\DriverRecommendedRules.ruleset</CodeAnalysisRuleSet>
    <LibraryPath>C:\Program Files (x86)\Windows Kits\10\Lib\10.0.17763.0\km\x64;$(DDK_LibraryPath_DDKPlatform);$(LibraryPath)</LibraryPath>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release Win 8.1|x64'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
    <TimeStampServer />
    <OutDir>$(SolutionDir)bin\Win8.1\</OutDir>
    <IntDir>obj\$(Platform)-$(Configuration)\</IntDir>
    <EnableInf2cat>false</EnableInf2cat>
    <CodeAnalysisRuleSet>..\..\..\..\..\..\..\Program Files (x86)\Windows Kits\10\CodeAnalysis\DriverRecommendedRules.ruleset</CodeAnalysisRuleSet>
    <LibraryPath>C:\Program Files (x86)\Windows Kits\10\Lib\10.0.17763.0\km\x64;$(DDK_LibraryPath_DDKPlatform);$(LibraryPath)</LibraryPath>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release Win 8.1 Obfuscated|x64'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
    <TimeStampServer />
    <OutDir>$(SolutionDir)bin\Win8.1\</OutDir>
    <IntDir>obj\$(Platform)-$(Configuration)\</IntDir>
    <EnableInf2cat>false</EnableInf2cat>
    <CodeAnalysisRuleSet>..\..\..\..\..\..\..\Program Files (x86)\Windows Kits\10\CodeAnalysis\DriverRecommendedRules.ruleset</CodeAnalysisRuleSet>
    <LibraryPath>C:\Program Files (x86)\Windows Kits\10\Lib\10.0.17763.0\km\x64;$(DDK_LibraryPath_DDKPlatform);$(LibraryPath)</LibraryPath>
  </PropertyGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug Win 7|Win32'">
    <ClCompile>
      <WppScanConfigurationData Condition="'%(ClCompile. ScanConfigurationData)'  == ''">trace.h</WppScanConfigurationData>
      <WppKernelMode>true</WppKernelMode>
      <PrecompiledHeader>NotUsing</PrecompiledHeader>
      <PreprocessorDefinitions>NT_INLINE_IRQL;KERNEL_MODE_CNG;OBFUSCATE=0;_X86_=1;i386=1;STD_CALL;DBG;_DEBUG;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <MinimalRebuild>false</MinimalRebuild>
      <AdditionalOptions>/Gw %(AdditionalOptions)</AdditionalOptions>
      <DisableSpecificWarnings>4201;4748;%(DisableSpecificWarnings)</DisableSpecificWarnings>
      <TreatWarningAsError>false</TreatWarningAsError>
      <DiagnosticsFormat>Caret</DiagnosticsFormat>
      <LanguageStandard>stdcpp17</LanguageStandard>
      <TreatWChar_tAsBuiltInType>true</TreatWChar_tAsBuiltInType>
      <AdditionalIncludeDirectories>$(ProjectDir);$(IntDir);$(ProjectDir)VMProtectDDK;%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
      <ControlFlowGuard>false</ControlFlowGuard>
    </ClCompile>
    <Link>
      <ProfileGuidedDatabase />
      <Version>6.01</Version>
      <Profile>false</Profile>
      <AdditionalOptions>/NOVCFEATURE /NOCOFFGRPINFO /INTEGRITYCHECK %(AdditionalOptions)</AdditionalOptions>
      <GenerateMapFile>true</GenerateMapFile>
      <RandomizedBaseAddress>true</RandomizedBaseAddress>
      <DataExecutionPrevention>true</DataExecutionPrevention>
      <GenerateDebugInformation>DebugFull</GenerateDebugInformation>
      <AdditionalDependencies>%(AdditionalDependencies);$(KernelBufferOverflowLib);ntoskrnl.lib;hal.lib;cng.lib;wmilib.lib;</AdditionalDependencies>
    </Link>
    <DriverSign>
      <FileDigestAlgorithm>sha256</FileDigestAlgorithm>
      <AdditionalOptions>/tr "http://sha256timestamp.ws.symantec.com/sha256/timestamp" /td sha256 %(AdditionalOptions)</AdditionalOptions>
    </DriverSign>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug Win 10|Win32'">
    <ClCompile>
      <WppScanConfigurationData Condition="'%(ClCompile. ScanConfigurationData)'  == ''">trace.h</WppScanConfigurationData>
      <WppKernelMode>true</WppKernelMode>
      <PrecompiledHeader>NotUsing</PrecompiledHeader>
      <PreprocessorDefinitions>NT_INLINE_IRQL;KERNEL_MODE_CNG;POOL_NX_OPTIN_AUTO=1;OBFUSCATE=0;_X86_=1;i386=1;STD_CALL;DBG;_DEBUG;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <MinimalRebuild>false</MinimalRebuild>
      <AdditionalOptions>/Gw %(AdditionalOptions)</AdditionalOptions>
      <DisableSpecificWarnings>4201;4748;%(DisableSpecificWarnings)</DisableSpecificWarnings>
      <TreatWarningAsError>false</TreatWarningAsError>
      <DiagnosticsFormat>Caret</DiagnosticsFormat>
      <LanguageStandard>stdcpp17</LanguageStandard>
      <TreatWChar_tAsBuiltInType>true</TreatWChar_tAsBuiltInType>
      <AdditionalIncludeDirectories>$(ProjectDir);$(IntDir);$(ProjectDir)VMProtectDDK;%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
      <ControlFlowGuard>false</ControlFlowGuard>
    </ClCompile>
    <Link>
      <ProfileGuidedDatabase>
      </ProfileGuidedDatabase>
      <Profile>false</Profile>
      <AdditionalOptions>/NOVCFEATURE /NOCOFFGRPINFO /INTEGRITYCHECK %(AdditionalOptions)</AdditionalOptions>
      <GenerateMapFile>true</GenerateMapFile>
      <RandomizedBaseAddress>true</RandomizedBaseAddress>
      <DataExecutionPrevention>true</DataExecutionPrevention>
      <GenerateDebugInformation>DebugFull</GenerateDebugInformation>
      <AdditionalDependencies>%(AdditionalDependencies);$(KernelBufferOverflowLib);ntoskrnl.lib;hal.lib;cng.lib;wmilib.lib;</AdditionalDependencies>
    </Link>
    <DriverSign>
      <FileDigestAlgorithm>sha256</FileDigestAlgorithm>
      <AdditionalOptions>/tr "http://sha256timestamp.ws.symantec.com/sha256/timestamp" /td sha256 %(AdditionalOptions)</AdditionalOptions>
    </DriverSign>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug Win 8.1|Win32'">
    <ClCompile>
      <WppScanConfigurationData Condition="'%(ClCompile. ScanConfigurationData)'  == ''">trace.h</WppScanConfigurationData>
      <WppKernelMode>true</WppKernelMode>
      <PrecompiledHeader>NotUsing</PrecompiledHeader>
      <PreprocessorDefinitions>NT_INLINE_IRQL;KERNEL_MODE_CNG;POOL_NX_OPTIN_AUTO=1;OBFUSCATE=0;_X86_=1;i386=1;STD_CALL;DBG;_DEBUG;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <MinimalRebuild>false</MinimalRebuild>
      <AdditionalOptions>/Gw %(AdditionalOptions)</AdditionalOptions>
      <DisableSpecificWarnings>4201;4748;%(DisableSpecificWarnings)</DisableSpecificWarnings>
      <TreatWarningAsError>false</TreatWarningAsError>
      <DiagnosticsFormat>Caret</DiagnosticsFormat>
      <LanguageStandard>stdcpp17</LanguageStandard>
      <TreatWChar_tAsBuiltInType>true</TreatWChar_tAsBuiltInType>
      <AdditionalIncludeDirectories>$(ProjectDir);$(IntDir);$(ProjectDir)VMProtectDDK;%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
      <ControlFlowGuard>false</ControlFlowGuard>
    </ClCompile>
    <Link>
      <ProfileGuidedDatabase>
      </ProfileGuidedDatabase>
      <Version>6.03</Version>
      <Profile>false</Profile>
      <AdditionalOptions>/NOVCFEATURE /NOCOFFGRPINFO /INTEGRITYCHECK %(AdditionalOptions)</AdditionalOptions>
      <GenerateMapFile>true</GenerateMapFile>
      <RandomizedBaseAddress>true</RandomizedBaseAddress>
      <DataExecutionPrevention>true</DataExecutionPrevention>
      <GenerateDebugInformation>DebugFull</GenerateDebugInformation>
      <AdditionalDependencies>%(AdditionalDependencies);$(KernelBufferOverflowLib);ntoskrnl.lib;hal.lib;cng.lib;wmilib.lib;</AdditionalDependencies>
    </Link>
    <DriverSign>
      <FileDigestAlgorithm>sha256</FileDigestAlgorithm>
      <AdditionalOptions>/tr "http://sha256timestamp.ws.symantec.com/sha256/timestamp" /td sha256 %(AdditionalOptions)</AdditionalOptions>
    </DriverSign>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug Win 7|x64'">
    <ClCompile>
      <WppScanConfigurationData Condition="'%(ClCompile. ScanConfigurationData)'  == ''">trace.h</WppScanConfigurationData>
      <WppKernelMode>true</WppKernelMode>
      <PrecompiledHeader>NotUsing</PrecompiledHeader>
      <PreprocessorDefinitions>NT_INLINE_IRQL;KERNEL_MODE_CNG;OBFUSCATE=0;_WIN64;_AMD64_;AMD64;DBG;_DEBUG;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <MinimalRebuild>false</MinimalRebuild>
      <AdditionalOptions>/Gw %(AdditionalOptions)</AdditionalOptions>
      <DisableSpecificWarnings>4201;4748;%(DisableSpecificWarnings)</DisableSpecificWarnings>
      <TreatWarningAsError>false</TreatWarningAsError>
      <DiagnosticsFormat>Caret</DiagnosticsFormat>
      <LanguageStandard>stdcpp17</LanguageStandard>
      <TreatWChar_tAsBuiltInType>true</TreatWChar_tAsBuiltInType>
      <AdditionalIncludeDirectories>$(ProjectDir);$(IntDir);$(ProjectDir)VMProtectDDK;%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
      <ControlFlowGuard>false</ControlFlowGuard>
    </ClCompile>
    <Link>
      <ProfileGuidedDatabase />
      <Version>6.01</Version>
      <Profile>false</Profile>
      <AdditionalOptions>/NOVCFEATURE /NOCOFFGRPINFO /INTEGRITYCHECK %(AdditionalOptions)</AdditionalOptions>
      <GenerateMapFile>true</GenerateMapFile>
      <RandomizedBaseAddress>true</RandomizedBaseAddress>
      <DataExecutionPrevention>true</DataExecutionPrevention>
      <GenerateDebugInformation>DebugFull</GenerateDebugInformation>
      <AdditionalDependencies>%(AdditionalDependencies);$(KernelBufferOverflowLib);ntoskrnl.lib;hal.lib;cng.lib;wmilib.lib;</AdditionalDependencies>
    </Link>
    <DriverSign>
      <FileDigestAlgorithm>sha256</FileDigestAlgorithm>
      <AdditionalOptions>/tr "http://sha256timestamp.ws.symantec.com/sha256/timestamp" /td sha256 %(AdditionalOptions)</AdditionalOptions>
    </DriverSign>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug Win 10|x64'">
    <ClCompile>
      <WppScanConfigurationData Condition="'%(ClCompile. ScanConfigurationData)'  == ''">trace.h</WppScanConfigurationData>
      <WppKernelMode>true</WppKernelMode>
      <PrecompiledHeader>NotUsing</PrecompiledHeader>
      <PreprocessorDefinitions>NT_INLINE_IRQL;KERNEL_MODE_CNG;POOL_NX_OPTIN_AUTO=1;OBFUSCATE=0;_WIN64;_AMD64_;AMD64;DBG;_DEBUG;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <MinimalRebuild>false</MinimalRebuild>
      <AdditionalOptions>/Gw %(AdditionalOptions)</AdditionalOptions>
      <DisableSpecificWarnings>4201;4748;%(DisableSpecificWarnings)</DisableSpecificWarnings>
      <TreatWarningAsError>false</TreatWarningAsError>
      <DiagnosticsFormat>Caret</DiagnosticsFormat>
      <LanguageStandard>stdcpp17</LanguageStandard>
      <TreatWChar_tAsBuiltInType>true</TreatWChar_tAsBuiltInType>
      <AdditionalIncludeDirectories>$(ProjectDir);$(IntDir);$(ProjectDir)VMProtectDDK;%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
      <ControlFlowGuard>false</ControlFlowGuard>
    </ClCompile>
    <Link>
      <ProfileGuidedDatabase>
      </ProfileGuidedDatabase>
      <Profile>false</Profile>
      <AdditionalOptions>/NOVCFEATURE /NOCOFFGRPINFO /INTEGRITYCHECK %(AdditionalOptions)</AdditionalOptions>
      <GenerateMapFile>true</GenerateMapFile>
      <RandomizedBaseAddress>true</RandomizedBaseAddress>
      <DataExecutionPrevention>true</DataExecutionPrevention>
      <GenerateDebugInformation>DebugFull</GenerateDebugInformation>
      <AdditionalDependencies>%(AdditionalDependencies);$(KernelBufferOverflowLib);ntoskrnl.lib;hal.lib;cng.lib;wmilib.lib;</AdditionalDependencies>
    </Link>
    <DriverSign>
      <FileDigestAlgorithm>sha256</FileDigestAlgorithm>
      <AdditionalOptions>/tr "http://sha256timestamp.ws.symantec.com/sha256/timestamp" /td sha256 %(AdditionalOptions)</AdditionalOptions>
    </DriverSign>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug Win 8.1|x64'">
    <ClCompile>
      <WppScanConfigurationData Condition="'%(ClCompile. ScanConfigurationData)'  == ''">trace.h</WppScanConfigurationData>
      <WppKernelMode>true</WppKernelMode>
      <PrecompiledHeader>NotUsing</PrecompiledHeader>
      <PreprocessorDefinitions>NT_INLINE_IRQL;KERNEL_MODE_CNG;POOL_NX_OPTIN_AUTO=1;OBFUSCATE=0;_WIN64;_AMD64_;AMD64;DBG;_DEBUG;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <MinimalRebuild>false</MinimalRebuild>
      <AdditionalOptions>/Gw %(AdditionalOptions)</AdditionalOptions>
      <DisableSpecificWarnings>4201;4748;%(DisableSpecificWarnings)</DisableSpecificWarnings>
      <TreatWarningAsError>false</TreatWarningAsError>
      <DiagnosticsFormat>Caret</DiagnosticsFormat>
      <LanguageStandard>stdcpp17</LanguageStandard>
      <TreatWChar_tAsBuiltInType>true</TreatWChar_tAsBuiltInType>
      <AdditionalIncludeDirectories>$(ProjectDir);$(IntDir);$(ProjectDir)VMProtectDDK;%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
      <ControlFlowGuard>false</ControlFlowGuard>
    </ClCompile>
    <Link>
      <ProfileGuidedDatabase>
      </ProfileGuidedDatabase>
      <Version>6.03</Version>
      <Profile>false</Profile>
      <AdditionalOptions>/NOVCFEATURE /NOCOFFGRPINFO /INTEGRITYCHECK %(AdditionalOptions)</AdditionalOptions>
      <GenerateMapFile>true</GenerateMapFile>
      <RandomizedBaseAddress>true</RandomizedBaseAddress>
      <DataExecutionPrevention>true</DataExecutionPrevention>
      <GenerateDebugInformation>DebugFull</GenerateDebugInformation>
      <AdditionalDependencies>%(AdditionalDependencies);$(KernelBufferOverflowLib);ntoskrnl.lib;hal.lib;cng.lib;wmilib.lib;</AdditionalDependencies>
    </Link>
    <DriverSign>
      <FileDigestAlgorithm>sha256</FileDigestAlgorithm>
      <AdditionalOptions>/tr "http://sha256timestamp.ws.symantec.com/sha256/timestamp" /td sha256 %(AdditionalOptions)</AdditionalOptions>
    </DriverSign>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release Win 7|Win32'">
    <ClCompile>
      <WppScanConfigurationData Condition="'%(ClCompile. ScanConfigurationData)'  == ''">trace.h</WppScanConfigurationData>
      <WppKernelMode>true</WppKernelMode>
      <PrecompiledHeader>NotUsing</PrecompiledHeader>
      <PreprocessorDefinitions>NT_INLINE_IRQL;KERNEL_MODE_CNG;OBFUSCATE=0;_X86_=1;i386=1;STD_CALL;NDEBUG;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <MinimalRebuild>false</MinimalRebuild>
      <AdditionalOptions>/Gw %(AdditionalOptions)</AdditionalOptions>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <DisableSpecificWarnings>4201;4603;4627;4986;4987;4996;%(DisableSpecificWarnings)</DisableSpecificWarnings>
      <TreatWarningAsError>false</TreatWarningAsError>
      <DiagnosticsFormat>Caret</DiagnosticsFormat>
      <LanguageStandard>stdcpp17</LanguageStandard>
      <TreatWChar_tAsBuiltInType>true</TreatWChar_tAsBuiltInType>
      <DebugInformationFormat>ProgramDatabase</DebugInformationFormat>
      <AdditionalIncludeDirectories>$(ProjectDir);$(IntDir);$(ProjectDir)VMProtectDDK;%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
      <OmitFramePointers>true</OmitFramePointers>
      <ControlFlowGuard>false</ControlFlowGuard>
    </ClCompile>
    <Link>
      <ProfileGuidedDatabase />
      <LinkTimeCodeGeneration>UseLinkTimeCodeGeneration</LinkTimeCodeGeneration>
      <EntryPointSymbol>DriverEntry@8</EntryPointSymbol>
      <Version>6.01</Version>
      <Profile>false</Profile>
      <GenerateDebugInformation>DebugFull</GenerateDebugInformation>
      <AdditionalOptions>/NOVCFEATURE /NOCOFFGRPINFO /INTEGRITYCHECK %(AdditionalOptions)</AdditionalOptions>
      <GenerateMapFile>true</GenerateMapFile>
      <RandomizedBaseAddress>true</RandomizedBaseAddress>
      <DataExecutionPrevention>true</DataExecutionPrevention>
      <AdditionalDependencies>%(AdditionalDependencies);$(KernelBufferOverflowLib);ntoskrnl.lib;hal.lib;cng.lib;wmilib.lib;</AdditionalDependencies>
    </Link>
    <DriverSign>
      <FileDigestAlgorithm>sha256</FileDigestAlgorithm>
      <AdditionalOptions>/tr "http://sha256timestamp.ws.symantec.com/sha256/timestamp" /td sha256 %(AdditionalOptions)</AdditionalOptions>
    </DriverSign>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release Win 7 Obfuscated|Win32'">
    <ClCompile>
      <WppScanConfigurationData Condition="'%(ClCompile. ScanConfigurationData)'  == ''">trace.h</WppScanConfigurationData>
      <WppKernelMode>true</WppKernelMode>
      <PrecompiledHeader>NotUsing</PrecompiledHeader>
      <PreprocessorDefinitions>NT_INLINE_IRQL;KERNEL_MODE_CNG;POOL_NX_OPTIN=1;OBFUSCATE=1;_X86_=1;i386=1;STD_CALL;NDEBUG;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <MinimalRebuild>false</MinimalRebuild>
      <AdditionalOptions>/Gw %(AdditionalOptions)</AdditionalOptions>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <DisableSpecificWarnings>4201;4603;4627;4986;4987;4996;%(DisableSpecificWarnings)</DisableSpecificWarnings>
      <TreatWarningAsError>false</TreatWarningAsError>
      <DiagnosticsFormat>Caret</DiagnosticsFormat>
      <LanguageStandard>stdcpp17</LanguageStandard>
      <TreatWChar_tAsBuiltInType>true</TreatWChar_tAsBuiltInType>
      <DebugInformationFormat>None</DebugInformationFormat>
      <AdditionalIncludeDirectories>$(ProjectDir);$(IntDir);$(ProjectDir)VMProtectDDK;%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
      <OmitFramePointers>true</OmitFramePointers>
      <ControlFlowGuard>false</ControlFlowGuard>
    </ClCompile>
    <Link>
      <ProfileGuidedDatabase>
      </ProfileGuidedDatabase>
      <LinkTimeCodeGeneration>UseLinkTimeCodeGeneration</LinkTimeCodeGeneration>
      <EntryPointSymbol>DriverEntry@8</EntryPointSymbol>
      <Version>6.01</Version>
      <Profile>false</Profile>
      <GenerateDebugInformation>false</GenerateDebugInformation>
      <AdditionalOptions>/NOVCFEATURE /NOCOFFGRPINFO /INTEGRITYCHECK %(AdditionalOptions)</AdditionalOptions>
      <AdditionalDependencies>%(AdditionalDependencies);$(KernelBufferOverflowLib);ntoskrnl.lib;hal.lib;cng.lib;wmilib.lib;VMProtectDDK32.lib</AdditionalDependencies>
      <AdditionalLibraryDirectories>$(SolutionDir)lib\x86;%(AdditionalLibraryDirectories)</AdditionalLibraryDirectories>
      <GenerateMapFile>true</GenerateMapFile>
      <RandomizedBaseAddress>true</RandomizedBaseAddress>
      <DataExecutionPrevention>true</DataExecutionPrevention>
    </Link>
    <DriverSign>
      <FileDigestAlgorithm>sha256</FileDigestAlgorithm>
      <AdditionalOptions>/tr "http://sha256timestamp.ws.symantec.com/sha256/timestamp" /td sha256 %(AdditionalOptions)</AdditionalOptions>
    </DriverSign>
    <PostBuildEvent>
      <Command>"$(SolutionDir)protect.cmd" "$(TargetPath)" "$(OutDir)$(TargetName).vmp$(TargetExt)" "$(SolutionDir)injector.sys.vmp"</Command>
    </PostBuildEvent>
    <PostBuildEvent>
      <Message>Running VMProtect...</Message>
    </PostBuildEvent>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release Win 10|Win32'">
    <ClCompile>
      <WppScanConfigurationData Condition="'%(ClCompile. ScanConfigurationData)'  == ''">trace.h</WppScanConfigurationData>
      <WppKernelMode>true</WppKernelMode>
      <PrecompiledHeader>NotUsing</PrecompiledHeader>
      <PreprocessorDefinitions>NT_INLINE_IRQL;KERNEL_MODE_CNG;POOL_NX_OPTIN_AUTO=1;OBFUSCATE=0;_X86_=1;i386=1;STD_CALL;NDEBUG;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <MinimalRebuild>false</MinimalRebuild>
      <AdditionalOptions>/Gw %(AdditionalOptions)</AdditionalOptions>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <DisableSpecificWarnings>4201;4603;4627;4986;4987;4996;%(DisableSpecificWarnings)</DisableSpecificWarnings>
      <TreatWarningAsError>false</TreatWarningAsError>
      <DiagnosticsFormat>Caret</DiagnosticsFormat>
      <LanguageStandard>stdcpp17</LanguageStandard>
      <TreatWChar_tAsBuiltInType>true</TreatWChar_tAsBuiltInType>
      <DebugInformationFormat>ProgramDatabase</DebugInformationFormat>
      <AdditionalIncludeDirectories>$(ProjectDir);$(IntDir);$(ProjectDir)VMProtectDDK;%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
      <ControlFlowGuard>false</ControlFlowGuard>
      <OmitFramePointers>true</OmitFramePointers>
    </ClCompile>
    <Link>
      <ProfileGuidedDatabase>
      </ProfileGuidedDatabase>
      <LinkTimeCodeGeneration>UseLinkTimeCodeGeneration</LinkTimeCodeGeneration>
      <EntryPointSymbol>DriverEntry@8</EntryPointSymbol>
      <Profile>false</Profile>
      <GenerateDebugInformation>DebugFull</GenerateDebugInformation>
      <AdditionalOptions>/NOVCFEATURE /NOCOFFGRPINFO /INTEGRITYCHECK %(AdditionalOptions)</AdditionalOptions>
      <GenerateMapFile>true</GenerateMapFile>
      <RandomizedBaseAddress>true</RandomizedBaseAddress>
      <DataExecutionPrevention>true</DataExecutionPrevention>
      <AdditionalDependencies>%(AdditionalDependencies);$(KernelBufferOverflowLib);ntoskrnl.lib;hal.lib;cng.lib;wmilib.lib;</AdditionalDependencies>
    </Link>
    <DriverSign>
      <FileDigestAlgorithm>sha256</FileDigestAlgorithm>
      <AdditionalOptions>/tr "http://sha256timestamp.ws.symantec.com/sha256/timestamp" /td sha256 %(AdditionalOptions)</AdditionalOptions>
    </DriverSign>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release Win 10 Obfuscated|Win32'">
    <ClCompile>
      <WppScanConfigurationData Condition="'%(ClCompile. ScanConfigurationData)'  == ''">trace.h</WppScanConfigurationData>
      <WppKernelMode>true</WppKernelMode>
      <PrecompiledHeader>NotUsing</PrecompiledHeader>
      <PreprocessorDefinitions>NT_INLINE_IRQL;KERNEL_MODE_CNG;POOL_NX_OPTIN_AUTO=1;OBFUSCATE=1;_X86_=1;i386=1;STD_CALL;NDEBUG;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <MinimalRebuild>false</MinimalRebuild>
      <AdditionalOptions>/Gw %(AdditionalOptions)</AdditionalOptions>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <DisableSpecificWarnings>4201;4603;4627;4986;4987;4996;%(DisableSpecificWarnings)</DisableSpecificWarnings>
      <TreatWarningAsError>false</TreatWarningAsError>
      <DiagnosticsFormat>Caret</DiagnosticsFormat>
      <LanguageStandard>stdcpp17</LanguageStandard>
      <TreatWChar_tAsBuiltInType>true</TreatWChar_tAsBuiltInType>
      <DebugInformationFormat>None</DebugInformationFormat>
      <AdditionalIncludeDirectories>$(ProjectDir);$(IntDir);$(ProjectDir)VMProtectDDK;%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
      <ControlFlowGuard>false</ControlFlowGuard>
      <OmitFramePointers>true</OmitFramePointers>
    </ClCompile>
    <Link>
      <ProfileGuidedDatabase>
      </ProfileGuidedDatabase>
      <LinkTimeCodeGeneration>UseLinkTimeCodeGeneration</LinkTimeCodeGeneration>
      <EntryPointSymbol>DriverEntry@8</EntryPointSymbol>
      <Profile>false</Profile>
      <GenerateDebugInformation>false</GenerateDebugInformation>
      <AdditionalOptions>/NOVCFEATURE /NOCOFFGRPINFO /INTEGRITYCHECK %(AdditionalOptions)</AdditionalOptions>
      <AdditionalDependencies>%(AdditionalDependencies);$(KernelBufferOverflowLib);ntoskrnl.lib;hal.lib;cng.lib;wmilib.lib;VMProtectDDK32.lib</AdditionalDependencies>
      <AdditionalLibraryDirectories>$(SolutionDir)lib\x86;%(AdditionalLibraryDirectories)</AdditionalLibraryDirectories>
      <GenerateMapFile>true</GenerateMapFile>
      <RandomizedBaseAddress>true</RandomizedBaseAddress>
      <DataExecutionPrevention>true</DataExecutionPrevention>
    </Link>
    <DriverSign>
      <FileDigestAlgorithm>sha256</FileDigestAlgorithm>
      <AdditionalOptions>/tr "http://sha256timestamp.ws.symantec.com/sha256/timestamp" /td sha256 %(AdditionalOptions)</AdditionalOptions>
    </DriverSign>
    <PostBuildEvent>
      <Command>"$(SolutionDir)protect.cmd" "$(TargetPath)" "$(OutDir)$(TargetName).vmp$(TargetExt)" "$(SolutionDir)injector.sys.vmp"</Command>
      <Message>Running VMProtect...</Message>
    </PostBuildEvent>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release Win 8.1|Win32'">
    <ClCompile>
      <WppScanConfigurationData Condition="'%(ClCompile. ScanConfigurationData)'  == ''">trace.h</WppScanConfigurationData>
      <WppKernelMode>true</WppKernelMode>
      <PrecompiledHeader>NotUsing</PrecompiledHeader>
      <PreprocessorDefinitions>NT_INLINE_IRQL;KERNEL_MODE_CNG;POOL_NX_OPTIN_AUTO=1;OBFUSCATE=0;_X86_=1;i386=1;STD_CALL;NDEBUG;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <MinimalRebuild>false</MinimalRebuild>
      <AdditionalOptions>/Gw %(AdditionalOptions)</AdditionalOptions>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <DisableSpecificWarnings>4201;4603;4627;4986;4987;4996;%(DisableSpecificWarnings)</DisableSpecificWarnings>
      <TreatWarningAsError>false</TreatWarningAsError>
      <DiagnosticsFormat>Caret</DiagnosticsFormat>
      <LanguageStandard>stdcpp17</LanguageStandard>
      <TreatWChar_tAsBuiltInType>true</TreatWChar_tAsBuiltInType>
      <DebugInformationFormat>ProgramDatabase</DebugInformationFormat>
      <AdditionalIncludeDirectories>$(ProjectDir);$(IntDir);$(ProjectDir)VMProtectDDK;%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
      <OmitFramePointers>true</OmitFramePointers>
      <ControlFlowGuard>false</ControlFlowGuard>
    </ClCompile>
    <Link>
      <ProfileGuidedDatabase>
      </ProfileGuidedDatabase>
      <LinkTimeCodeGeneration>UseLinkTimeCodeGeneration</LinkTimeCodeGeneration>
      <EntryPointSymbol>DriverEntry@8</EntryPointSymbol>
      <Version>6.03</Version>
      <Profile>false</Profile>
      <GenerateDebugInformation>DebugFull</GenerateDebugInformation>
      <AdditionalOptions>/NOVCFEATURE /NOCOFFGRPINFO /INTEGRITYCHECK %(AdditionalOptions)</AdditionalOptions>
      <GenerateMapFile>true</GenerateMapFile>
      <RandomizedBaseAddress>true</RandomizedBaseAddress>
      <DataExecutionPrevention>true</DataExecutionPrevention>
      <AdditionalDependencies>%(AdditionalDependencies);$(KernelBufferOverflowLib);ntoskrnl.lib;hal.lib;cng.lib;wmilib.lib;</AdditionalDependencies>
    </Link>
    <DriverSign>
      <FileDigestAlgorithm>sha256</FileDigestAlgorithm>
      <AdditionalOptions>/tr "http://sha256timestamp.ws.symantec.com/sha256/timestamp" /td sha256 %(AdditionalOptions)</AdditionalOptions>
    </DriverSign>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release Win 8.1 Obfuscated|Win32'">
    <ClCompile>
      <WppScanConfigurationData Condition="'%(ClCompile. ScanConfigurationData)'  == ''">trace.h</WppScanConfigurationData>
      <WppKernelMode>true</WppKernelMode>
      <PrecompiledHeader>NotUsing</PrecompiledHeader>
      <PreprocessorDefinitions>NT_INLINE_IRQL;KERNEL_MODE_CNG;POOL_NX_OPTIN_AUTO=1;OBFUSCATE=1;_X86_=1;i386=1;STD_CALL;NDEBUG;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <MinimalRebuild>false</MinimalRebuild>
      <AdditionalOptions>/Gw %(AdditionalOptions)</AdditionalOptions>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <DisableSpecificWarnings>4201;4603;4627;4986;4987;4996;%(DisableSpecificWarnings)</DisableSpecificWarnings>
      <TreatWarningAsError>false</TreatWarningAsError>
      <DiagnosticsFormat>Caret</DiagnosticsFormat>
      <LanguageStandard>stdcpp17</LanguageStandard>
      <TreatWChar_tAsBuiltInType>true</TreatWChar_tAsBuiltInType>
      <DebugInformationFormat>None</DebugInformationFormat>
      <AdditionalIncludeDirectories>$(ProjectDir);$(IntDir);$(ProjectDir)VMProtectDDK;%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
      <OmitFramePointers>true</OmitFramePointers>
      <ControlFlowGuard>false</ControlFlowGuard>
    </ClCompile>
    <Link>
      <ProfileGuidedDatabase>
      </ProfileGuidedDatabase>
      <LinkTimeCodeGeneration>UseLinkTimeCodeGeneration</LinkTimeCodeGeneration>
      <EntryPointSymbol>DriverEntry@8</EntryPointSymbol>
      <Version>6.03</Version>
      <Profile>false</Profile>
      <GenerateDebugInformation>false</GenerateDebugInformation>
      <AdditionalOptions>/NOVCFEATURE /NOCOFFGRPINFO /INTEGRITYCHECK %(AdditionalOptions)</AdditionalOptions>
      <AdditionalDependencies>%(AdditionalDependencies);$(KernelBufferOverflowLib);ntoskrnl.lib;hal.lib;cng.lib;wmilib.lib;VMProtectDDK32.lib</AdditionalDependencies>
      <AdditionalLibraryDirectories>$(SolutionDir)lib\x86;%(AdditionalLibraryDirectories)</AdditionalLibraryDirectories>
      <GenerateMapFile>true</GenerateMapFile>
      <RandomizedBaseAddress>true</RandomizedBaseAddress>
      <DataExecutionPrevention>true</DataExecutionPrevention>
    </Link>
    <DriverSign>
      <FileDigestAlgorithm>sha256</FileDigestAlgorithm>
      <AdditionalOptions>/tr "http://sha256timestamp.ws.symantec.com/sha256/timestamp" /td sha256 %(AdditionalOptions)</AdditionalOptions>
    </DriverSign>
    <PostBuildEvent>
      <Command>"$(SolutionDir)protect.cmd" "$(TargetPath)" "$(OutDir)$(TargetName).vmp$(TargetExt)" "$(SolutionDir)injector.sys.vmp"</Command>
      <Message>Running VMProtect...</Message>
    </PostBuildEvent>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release Win 7|x64'">
    <ClCompile>
      <WppScanConfigurationData Condition="'%(ClCompile. ScanConfigurationData)'  == ''">trace.h</WppScanConfigurationData>
      <WppKernelMode>true</WppKernelMode>
      <PrecompiledHeader>NotUsing</PrecompiledHeader>
      <PreprocessorDefinitions>NT_INLINE_IRQL;KERNEL_MODE_CNG;OBFUSCATE=0;_WIN64;_AMD64_;AMD64;NDEBUG;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <MinimalRebuild>false</MinimalRebuild>
      <AdditionalOptions>/Gw %(AdditionalOptions)</AdditionalOptions>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <DisableSpecificWarnings>4201;4603;4627;4986;4987;4996;%(DisableSpecificWarnings)</DisableSpecificWarnings>
      <TreatWarningAsError>false</TreatWarningAsError>
      <DiagnosticsFormat>Caret</DiagnosticsFormat>
      <LanguageStandard>stdcpp17</LanguageStandard>
      <TreatWChar_tAsBuiltInType>true</TreatWChar_tAsBuiltInType>
      <DebugInformationFormat>ProgramDatabase</DebugInformationFormat>
      <AdditionalIncludeDirectories>$(ProjectDir);$(IntDir);$(ProjectDir)VMProtectDDK;%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
      <ControlFlowGuard>false</ControlFlowGuard>
      <BufferSecurityCheck>false</BufferSecurityCheck>
      <OmitFramePointers>true</OmitFramePointers>
    </ClCompile>
    <Link>
      <ProfileGuidedDatabase />
      <LinkTimeCodeGeneration>UseLinkTimeCodeGeneration</LinkTimeCodeGeneration>
      <EntryPointSymbol>DriverEntry</EntryPointSymbol>
      <Version>6.01</Version>
      <Profile>false</Profile>
      <GenerateDebugInformation>DebugFull</GenerateDebugInformation>
      <AdditionalOptions>/NOVCFEATURE /NOCOFFGRPINFO /INTEGRITYCHECK %(AdditionalOptions)</AdditionalOptions>
      <GenerateMapFile>true</GenerateMapFile>
      <RandomizedBaseAddress>true</RandomizedBaseAddress>
      <DataExecutionPrevention>true</DataExecutionPrevention>
      <AdditionalDependencies>%(AdditionalDependencies);$(KernelBufferOverflowLib);ntoskrnl.lib;hal.lib;cng.lib;wmilib.lib;</AdditionalDependencies>
    </Link>
    <DriverSign>
      <FileDigestAlgorithm>sha256</FileDigestAlgorithm>
      <AdditionalOptions>/tr "http://sha256timestamp.ws.symantec.com/sha256/timestamp" /td sha256 %(AdditionalOptions)</AdditionalOptions>
    </DriverSign>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release Win 7 Obfuscated|x64'">
    <ClCompile>
      <WppScanConfigurationData Condition="'%(ClCompile. ScanConfigurationData)'  == ''">trace.h</WppScanConfigurationData>
      <WppKernelMode>true</WppKernelMode>
      <PrecompiledHeader>NotUsing</PrecompiledHeader>
      <PreprocessorDefinitions>NT_INLINE_IRQL;KERNEL_MODE_CNG;POOL_NX_OPTIN=1;OBFUSCATE=1;_WIN64;_AMD64_;AMD64;NDEBUG;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <MinimalRebuild>false</MinimalRebuild>
      <AdditionalOptions>/Gw %(AdditionalOptions)</AdditionalOptions>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <DisableSpecificWarnings>4201;4603;4627;4986;4987;4996;%(DisableSpecificWarnings)</DisableSpecificWarnings>
      <TreatWarningAsError>false</TreatWarningAsError>
      <DiagnosticsFormat>Caret</DiagnosticsFormat>
      <LanguageStandard>stdcpp17</LanguageStandard>
      <TreatWChar_tAsBuiltInType>true</TreatWChar_tAsBuiltInType>
      <DebugInformationFormat>None</DebugInformationFormat>
      <AdditionalIncludeDirectories>$(ProjectDir);$(IntDir);$(ProjectDir)VMProtectDDK;%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
      <ControlFlowGuard>false</ControlFlowGuard>
      <BufferSecurityCheck>false</BufferSecurityCheck>
      <OmitFramePointers>true</OmitFramePointers>
    </ClCompile>
    <Link>
      <ProfileGuidedDatabase>
      </ProfileGuidedDatabase>
      <LinkTimeCodeGeneration>UseLinkTimeCodeGeneration</LinkTimeCodeGeneration>
      <EntryPointSymbol>DriverEntry</EntryPointSymbol>
      <Version>6.01</Version>
      <Profile>false</Profile>
      <GenerateDebugInformation>false</GenerateDebugInformation>
      <AdditionalOptions>/NOVCFEATURE /NOCOFFGRPINFO /INTEGRITYCHECK %(AdditionalOptions)</AdditionalOptions>
      <AdditionalDependencies>%(AdditionalDependencies);$(KernelBufferOverflowLib);ntoskrnl.lib;hal.lib;cng.lib;wmilib.lib;VMProtectDDK64.lib</AdditionalDependencies>
      <AdditionalLibraryDirectories>$(SolutionDir)lib\x64;%(AdditionalLibraryDirectories)</AdditionalLibraryDirectories>
      <GenerateMapFile>true</GenerateMapFile>
      <RandomizedBaseAddress>true</RandomizedBaseAddress>
      <DataExecutionPrevention>true</DataExecutionPrevention>
    </Link>
    <DriverSign>
      <FileDigestAlgorithm>sha256</FileDigestAlgorithm>
      <AdditionalOptions>/tr "http://sha256timestamp.ws.symantec.com/sha256/timestamp" /td sha256 %(AdditionalOptions)</AdditionalOptions>
    </DriverSign>
    <PostBuildEvent>
      <Command>"$(SolutionDir)protect.cmd" "$(TargetPath)" "$(OutDir)$(TargetName).vmp$(TargetExt)" "$(SolutionDir)injector.sys.vmp"</Command>
    </PostBuildEvent>
    <PostBuildEvent>
      <Message>Running VMProtect...</Message>
    </PostBuildEvent>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release Win 10|x64'">
    <ClCompile>
      <WppScanConfigurationData Condition="'%(ClCompile. ScanConfigurationData)'  == ''">trace.h</WppScanConfigurationData>
      <WppKernelMode>true</WppKernelMode>
      <PrecompiledHeader>NotUsing</PrecompiledHeader>
      <PreprocessorDefinitions>NT_INLINE_IRQL;KERNEL_MODE_CNG;POOL_NX_OPTIN_AUTO=1;OBFUSCATE=0;_WIN64;_AMD64_;AMD64;NDEBUG;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <MinimalRebuild>false</MinimalRebuild>
      <AdditionalOptions>/Gw %(AdditionalOptions)</AdditionalOptions>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <DisableSpecificWarnings>4201;4603;4627;4986;4987;4996;%(DisableSpecificWarnings)</DisableSpecificWarnings>
      <TreatWarningAsError>false</TreatWarningAsError>
      <DiagnosticsFormat>Caret</DiagnosticsFormat>
      <LanguageStandard>stdcpp17</LanguageStandard>
      <TreatWChar_tAsBuiltInType>true</TreatWChar_tAsBuiltInType>
      <DebugInformationFormat>ProgramDatabase</DebugInformationFormat>
      <AdditionalIncludeDirectories>$(ProjectDir);$(IntDir);$(ProjectDir)VMProtectDDK;%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
      <ControlFlowGuard>false</ControlFlowGuard>
      <BufferSecurityCheck>false</BufferSecurityCheck>
      <OmitFramePointers>true</OmitFramePointers>
    </ClCompile>
    <Link>
      <ProfileGuidedDatabase>
      </ProfileGuidedDatabase>
      <LinkTimeCodeGeneration>UseLinkTimeCodeGeneration</LinkTimeCodeGeneration>
      <Profile>false</Profile>
      <GenerateDebugInformation>DebugFull</GenerateDebugInformation>
      <AdditionalOptions>/NOVCFEATURE /NOCOFFGRPINFO /INTEGRITYCHECK %(AdditionalOptions)</AdditionalOptions>
      <GenerateMapFile>true</GenerateMapFile>
      <RandomizedBaseAddress>true</RandomizedBaseAddress>
      <DataExecutionPrevention>true</DataExecutionPrevention>
      <AdditionalDependencies>%(AdditionalDependencies);$(KernelBufferOverflowLib);ntoskrnl.lib;hal.lib;cng.lib;wmilib.lib;</AdditionalDependencies>
      <EntryPointSymbol>DriverEntry</EntryPointSymbol>
    </Link>
    <DriverSign>
      <FileDigestAlgorithm>sha256</FileDigestAlgorithm>
      <AdditionalOptions>/tr "http://sha256timestamp.ws.symantec.com/sha256/timestamp" /td sha256 %(AdditionalOptions)</AdditionalOptions>
    </DriverSign>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release Win 10 Obfuscated|x64'">
    <ClCompile>
      <WppScanConfigurationData Condition="'%(ClCompile. ScanConfigurationData)'  == ''">trace.h</WppScanConfigurationData>
      <WppKernelMode>true</WppKernelMode>
      <PrecompiledHeader>NotUsing</PrecompiledHeader>
      <PreprocessorDefinitions>NT_INLINE_IRQL;KERNEL_MODE_CNG;POOL_NX_OPTIN_AUTO=1;OBFUSCATE=1;_WIN64;_AMD64_;AMD64;NDEBUG;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <MinimalRebuild>false</MinimalRebuild>
      <AdditionalOptions>/Gw %(AdditionalOptions)</AdditionalOptions>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <DisableSpecificWarnings>4201;4603;4627;4986;4987;4996;%(DisableSpecificWarnings)</DisableSpecificWarnings>
      <TreatWarningAsError>false</TreatWarningAsError>
      <DiagnosticsFormat>Caret</DiagnosticsFormat>
      <LanguageStandard>stdcpp17</LanguageStandard>
      <TreatWChar_tAsBuiltInType>true</TreatWChar_tAsBuiltInType>
      <DebugInformationFormat>None</DebugInformationFormat>
      <AdditionalIncludeDirectories>$(ProjectDir);$(IntDir);$(ProjectDir)VMProtectDDK;%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
      <ControlFlowGuard>false</ControlFlowGuard>
      <BufferSecurityCheck>false</BufferSecurityCheck>
      <OmitFramePointers>true</OmitFramePointers>
    </ClCompile>
    <Link>
      <ProfileGuidedDatabase>
      </ProfileGuidedDatabase>
      <LinkTimeCodeGeneration>UseLinkTimeCodeGeneration</LinkTimeCodeGeneration>
      <EntryPointSymbol>DriverEntry</EntryPointSymbol>
      <Profile>false</Profile>
      <GenerateDebugInformation>false</GenerateDebugInformation>
      <AdditionalOptions>/NOVCFEATURE /NOCOFFGRPINFO /INTEGRITYCHECK %(AdditionalOptions)</AdditionalOptions>
      <AdditionalDependencies>%(AdditionalDependencies);$(KernelBufferOverflowLib);ntoskrnl.lib;hal.lib;cng.lib;wmilib.lib;VMProtectDDK64.lib</AdditionalDependencies>
      <AdditionalLibraryDirectories>$(SolutionDir)lib\x64;%(AdditionalLibraryDirectories)</AdditionalLibraryDirectories>
      <GenerateMapFile>true</GenerateMapFile>
      <RandomizedBaseAddress>true</RandomizedBaseAddress>
      <DataExecutionPrevention>true</DataExecutionPrevention>
    </Link>
    <DriverSign>
      <FileDigestAlgorithm>sha256</FileDigestAlgorithm>
      <AdditionalOptions>/tr "http://sha256timestamp.ws.symantec.com/sha256/timestamp" /td sha256 %(AdditionalOptions)</AdditionalOptions>
    </DriverSign>
    <PostBuildEvent>
      <Command>"$(SolutionDir)protect.cmd" "$(TargetPath)" "$(OutDir)$(TargetName).vmp$(TargetExt)" "$(SolutionDir)injector.sys.vmp"</Command>
      <Message>Running VMProtect...</Message>
    </PostBuildEvent>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release Win 8.1|x64'">
    <ClCompile>
      <WppScanConfigurationData Condition="'%(ClCompile. ScanConfigurationData)'  == ''">trace.h</WppScanConfigurationData>
      <WppKernelMode>true</WppKernelMode>
      <PrecompiledHeader>NotUsing</PrecompiledHeader>
      <PreprocessorDefinitions>NT_INLINE_IRQL;KERNEL_MODE_CNG;POOL_NX_OPTIN_AUTO=1;OBFUSCATE=0;_WIN64;_AMD64_;AMD64;NDEBUG;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <MinimalRebuild>false</MinimalRebuild>
      <AdditionalOptions>/Gw %(AdditionalOptions)</AdditionalOptions>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <DisableSpecificWarnings>4201;4603;4627;4986;4987;4996;%(DisableSpecificWarnings)</DisableSpecificWarnings>
      <TreatWarningAsError>false</TreatWarningAsError>
      <DiagnosticsFormat>Caret</DiagnosticsFormat>
      <LanguageStandard>stdcpp17</LanguageStandard>
      <TreatWChar_tAsBuiltInType>true</TreatWChar_tAsBuiltInType>
      <DebugInformationFormat>ProgramDatabase</DebugInformationFormat>
      <AdditionalIncludeDirectories>$(ProjectDir);$(IntDir);$(ProjectDir)VMProtectDDK;%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
      <ControlFlowGuard>false</ControlFlowGuard>
      <BufferSecurityCheck>false</BufferSecurityCheck>
      <OmitFramePointers>true</OmitFramePointers>
    </ClCompile>
    <Link>
      <ProfileGuidedDatabase>
      </ProfileGuidedDatabase>
      <LinkTimeCodeGeneration>UseLinkTimeCodeGeneration</LinkTimeCodeGeneration>
      <EntryPointSymbol>DriverEntry</EntryPointSymbol>
      <Version>6.03</Version>
      <Profile>false</Profile>
      <GenerateDebugInformation>DebugFull</GenerateDebugInformation>
      <AdditionalOptions>/NOVCFEATURE /NOCOFFGRPINFO /INTEGRITYCHECK %(AdditionalOptions)</AdditionalOptions>
      <GenerateMapFile>true</GenerateMapFile>
      <RandomizedBaseAddress>true</RandomizedBaseAddress>
      <DataExecutionPrevention>true</DataExecutionPrevention>
      <AdditionalDependencies>%(AdditionalDependencies);$(KernelBufferOverflowLib);ntoskrnl.lib;hal.lib;cng.lib;wmilib.lib;</AdditionalDependencies>
    </Link>
    <DriverSign>
      <FileDigestAlgorithm>sha256</FileDigestAlgorithm>
      <AdditionalOptions>/tr "http://sha256timestamp.ws.symantec.com/sha256/timestamp" /td sha256 %(AdditionalOptions)</AdditionalOptions>
    </DriverSign>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release Win 8.1 Obfuscated|x64'">
    <ClCompile>
      <WppScanConfigurationData Condition="'%(ClCompile. ScanConfigurationData)'  == ''">trace.h</WppScanConfigurationData>
      <WppKernelMode>true</WppKernelMode>
      <PrecompiledHeader>NotUsing</PrecompiledHeader>
      <PreprocessorDefinitions>NT_INLINE_IRQL;KERNEL_MODE_CNG;POOL_NX_OPTIN_AUTO=1;OBFUSCATE=1;_WIN64;_AMD64_;AMD64;NDEBUG;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <MinimalRebuild>false</MinimalRebuild>
      <AdditionalOptions>/Gw %(AdditionalOptions)</AdditionalOptions>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <DisableSpecificWarnings>4201;4603;4627;4986;4987;4996;%(DisableSpecificWarnings)</DisableSpecificWarnings>
      <TreatWarningAsError>false</TreatWarningAsError>
      <DiagnosticsFormat>Caret</DiagnosticsFormat>
      <LanguageStandard>stdcpp17</LanguageStandard>
      <TreatWChar_tAsBuiltInType>true</TreatWChar_tAsBuiltInType>
      <DebugInformationFormat>None</DebugInformationFormat>
      <AdditionalIncludeDirectories>$(ProjectDir);$(IntDir);$(ProjectDir)VMProtectDDK;%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
      <ControlFlowGuard>false</ControlFlowGuard>
      <BufferSecurityCheck>false</BufferSecurityCheck>
      <OmitFramePointers>true</OmitFramePointers>
    </ClCompile>
    <Link>
      <ProfileGuidedDatabase>
      </ProfileGuidedDatabase>
      <LinkTimeCodeGeneration>UseLinkTimeCodeGeneration</LinkTimeCodeGeneration>
      <EntryPointSymbol>DriverEntry</EntryPointSymbol>
      <Version>6.03</Version>
      <Profile>false</Profile>
      <GenerateDebugInformation>false</GenerateDebugInformation>
      <AdditionalOptions>/NOVCFEATURE /NOCOFFGRPINFO /INTEGRITYCHECK %(AdditionalOptions)</AdditionalOptions>
      <AdditionalDependencies>%(AdditionalDependencies);$(KernelBufferOverflowLib);ntoskrnl.lib;hal.lib;cng.lib;wmilib.lib;VMProtectDDK64.lib</AdditionalDependencies>
      <AdditionalLibraryDirectories>$(SolutionDir)lib\x64;%(AdditionalLibraryDirectories)</AdditionalLibraryDirectories>
      <GenerateMapFile>true</GenerateMapFile>
      <RandomizedBaseAddress>true</RandomizedBaseAddress>
      <DataExecutionPrevention>true</DataExecutionPrevention>
    </Link>
    <DriverSign>
      <FileDigestAlgorithm>sha256</FileDigestAlgorithm>
      <AdditionalOptions>/tr "http://sha256timestamp.ws.symantec.com/sha256/timestamp" /td sha256 %(AdditionalOptions)</AdditionalOptions>
    </DriverSign>
    <PostBuildEvent>
      <Command>"$(SolutionDir)protect.cmd" "$(TargetPath)" "$(OutDir)$(TargetName).vmp$(TargetExt)" "$(SolutionDir)injector.sys.vmp"</Command>
      <Message>Running VMProtect...</Message>
    </PostBuildEvent>
  </ItemDefinitionGroup>
  <ItemGroup>
    <Inf Exclude="@(Inf)" Include="*.inf" />
    <FilesToPackage Include="$(TargetPath)" Condition="'$(ConfigurationType)'=='Driver' or '$(ConfigurationType)'=='DynamicLibrary'" />
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="BlackBone\Loader.c" />
    <ClCompile Include="BlackBone\VadHelpers.c" />
    <ClCompile Include="Encryption.c" />
    <ClCompile Include="LoadCfg.c" />
    <ClCompile Include="main.c" />
    <ClCompile Include="Process.c" />
    <ClCompile Include="DynData.c" />
    <ClCompile Include="s20.c" />
    <ClCompile Include="SSDT.c" />
    <ClCompile Include="IO.c" />
    <ClCompile Include="MMInject.c" />
    <ClCompile Include="PE.c" />
    <ClCompile Include="Utils.c" />
    <ClCompile Include="VAD.c" />
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="MMInject.h" />
    <ClInclude Include="s20.h" />
    <ClInclude Include="StringEncryptor.h" />
    <ClInclude Include="Utils.h" />
    <ClInclude Include="vad.h" />
    <ClInclude Include="zwapi.h" />
    <ClInclude Include="BlackBone\Loader.h" />
    <ClInclude Include="BlackBone\Private.h" />
    <ClInclude Include="BlackBone\VadHelpers.h" />
    <ClInclude Include="Native\NativeEnums.h" />
    <ClInclude Include="Native\NativeStructs.h" />
    <ClInclude Include="Native\NativeStructs10.h" />
    <ClInclude Include="Native\NativeStructs7.h" />
    <ClInclude Include="Native\NativeStructs81.h" />
  </ItemGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
  <ImportGroup Label="ExtensionTargets">
  </ImportGroup>
</Project>
```

`MMInject/MMInject.vcxproj.filters`:

```filters
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup>
    <Filter Include="Source Files">
      <UniqueIdentifier>{0A1730E2-EAF5-496d-A2EE-04D86096C9DB}</UniqueIdentifier>
      <Extensions>cpp;c;cc;cxx;def;odl;idl;hpj;bat;asm;asmx</Extensions>
    </Filter>
    <Filter Include="Header Files">
      <UniqueIdentifier>{E2D5A56E-FFBF-4f04-BEE1-C2E57B07F692}</UniqueIdentifier>
      <Extensions>h;hh;hpp;hxx;hm;inl;inc;xsd</Extensions>
    </Filter>
    <Filter Include="Resource Files">
      <UniqueIdentifier>{B8056672-74DD-4e8f-9077-63DF818EA87D}</UniqueIdentifier>
      <Extensions>rc;ico;cur;bmp;dlg;rc2;rct;bin;rgs;gif;jpg;jpeg;jpe;resx;tiff;tif;png;wav;mfcribbon-ms</Extensions>
    </Filter>
    <Filter Include="Header Files\Native">
      <UniqueIdentifier>{01b69644-7c84-4e7f-b2c0-4f16702886a7}</UniqueIdentifier>
    </Filter>
    <Filter Include="Header Files\BlackBone">
      <UniqueIdentifier>{7837851d-1c61-4e6c-8365-4b1a4d69f0b3}</UniqueIdentifier>
    </Filter>
    <Filter Include="Source Files\BlackBone">
      <UniqueIdentifier>{7b3b591b-75e1-4fa2-baa5-2deceb7bf247}</UniqueIdentifier>
    </Filter>
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="DynData.c">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="Encryption.c">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="IO.c">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="main.c">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="MMInject.c">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="LoadCfg.c">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="PE.c">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="s20.c">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="Utils.c">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="VAD.c">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="SSDT.c">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="Process.c">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="BlackBone\Loader.c">
      <Filter>Source Files\BlackBone</Filter>
    </ClCompile>
    <ClCompile Include="BlackBone\VadHelpers.c">
      <Filter>Source Files\BlackBone</Filter>
    </ClCompile>
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="zwapi.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="Native\NativeStructs.h">
      <Filter>Header Files\Native</Filter>
    </ClInclude>
    <ClInclude Include="Native\NativeStructs7.h">
      <Filter>Header Files\Native</Filter>
    </ClInclude>
    <ClInclude Include="Native\NativeStructs10.h">
      <Filter>Header Files\Native</Filter>
    </ClInclude>
    <ClInclude Include="Native\NativeStructs81.h">
      <Filter>Header Files\Native</Filter>
    </ClInclude>
    <ClInclude Include="Native\NativeEnums.h">
      <Filter>Header Files\Native</Filter>
    </ClInclude>
    <ClInclude Include="BlackBone\Private.h">
      <Filter>Header Files\BlackBone</Filter>
    </ClInclude>
    <ClInclude Include="BlackBone\VadHelpers.h">
      <Filter>Header Files\BlackBone</Filter>
    </ClInclude>
    <ClInclude Include="BlackBone\Loader.h">
      <Filter>Header Files\BlackBone</Filter>
    </ClInclude>
    <ClInclude Include="vad.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="MMInject.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="s20.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="StringEncryptor.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="Utils.h">
      <Filter>Header Files</Filter>
    </ClInclude>
  </ItemGroup>
</Project>
```

`MMInject/MMInject.vcxproj.user`:

```user
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="Current" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug Win 10|Win32'">
    <SignMode>Off</SignMode>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug Win 7|Win32'">
    <SignMode>Off</SignMode>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug Win 8.1|Win32'">
    <SignMode>Off</SignMode>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release Win 10|Win32'">
    <SignMode>Off</SignMode>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release Win 10 Obfuscated|Win32'">
    <SignMode>Off</SignMode>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release Win 7|Win32'">
    <SignMode>Off</SignMode>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release Win 7 Obfuscated|Win32'">
    <SignMode>Off</SignMode>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release Win 8.1|Win32'">
    <SignMode>Off</SignMode>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release Win 8.1 Obfuscated|Win32'">
    <SignMode>Off</SignMode>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug Win 10|x64'">
    <SignMode>Off</SignMode>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug Win 7|x64'">
    <SignMode>Off</SignMode>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug Win 8.1|x64'">
    <SignMode>Off</SignMode>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release Win 10|x64'">
    <SignMode>Off</SignMode>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release Win 10 Obfuscated|x64'">
    <SignMode>Off</SignMode>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release Win 7|x64'">
    <SignMode>Off</SignMode>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release Win 7 Obfuscated|x64'">
    <SignMode>Off</SignMode>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release Win 8.1|x64'">
    <SignMode>Off</SignMode>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release Win 8.1 Obfuscated|x64'">
    <SignMode>Off</SignMode>
  </PropertyGroup>
</Project>
```

`MMInject/Native/NativeEnums.h`:

```h
#pragma once

typedef enum _PS_PROTECTED_SIGNER : UCHAR
{
	PsProtectedSignerNone = 0,
	PsProtectedSignerAuthenticode = 1,
	PsProtectedSignerCodeGen = 2,
	PsProtectedSignerAntimalware = 3,
	PsProtectedSignerLsa = 4,
	PsProtectedSignerWindows = 5,
	PsProtectedSignerWinTcb = 6,
	PsProtectedSignerWinSystem = 7,
	PsProtectedSignerMax = 8
} PS_PROTECTED_SIGNER;

typedef enum _PS_PROTECTED_TYPE : UCHAR
{
	PsProtectedTypeNone = 0,
	PsProtectedTypeProtectedLight = 1,
	PsProtectedTypeProtected = 2,
	PsProtectedTypeMax = 3
} PS_PROTECTED_TYPE;

typedef enum _SYSTEM_INFORMATION_CLASS
{
	SystemBasicInformation, // q: SYSTEM_BASIC_INFORMATION
	SystemProcessorInformation, // q: SYSTEM_PROCESSOR_INFORMATION
	SystemPerformanceInformation, // q: SYSTEM_PERFORMANCE_INFORMATION
	SystemTimeOfDayInformation, // q: SYSTEM_TIMEOFDAY_INFORMATION
	SystemPathInformation, // not implemented
	SystemProcessInformation, // q: SYSTEM_PROCESS_INFORMATION
	SystemCallCountInformation, // q: SYSTEM_CALL_COUNT_INFORMATION
	SystemDeviceInformation, // q: SYSTEM_DEVICE_INFORMATION
	SystemProcessorPerformanceInformation, // q: SYSTEM_PROCESSOR_PERFORMANCE_INFORMATION
	SystemFlagsInformation, // q: SYSTEM_FLAGS_INFORMATION
	SystemCallTimeInformation, // not implemented // SYSTEM_CALL_TIME_INFORMATION // 10
	SystemModuleInformation, // q: RTL_PROCESS_MODULES
	SystemLocksInformation, // q: SYSTEM_LOCK_INFORMATION
	SystemStackTraceInformation,
	SystemPagedPoolInformation, // not implemented
	SystemNonPagedPoolInformation, // not implemented
	SystemHandleInformation, // q: SYSTEM_HANDLE_INFORMATION
	SystemObjectInformation, // q: SYSTEM_OBJECTTYPE_INFORMATION mixed with SYSTEM_OBJECT_INFORMATION
	SystemPageFileInformation, // q: SYSTEM_PAGEFILE_INFORMATION
	SystemVdmInstemulInformation, // q
	SystemVdmBopInformation, // not implemented // 20
	SystemFileCacheInformation, // q: SYSTEM_FILECACHE_INFORMATION; s (requires SeIncreaseQuotaPrivilege) (info for WorkingSetTypeSystemCache)
	SystemPoolTagInformation, // q: SYSTEM_POOLTAG_INFORMATION
	SystemInterruptInformation, // q: SYSTEM_INTERRUPT_INFORMATION
	SystemDpcBehaviorInformation, // q: SYSTEM_DPC_BEHAVIOR_INFORMATION; s: SYSTEM_DPC_BEHAVIOR_INFORMATION (requires SeLoadDriverPrivilege)
	SystemFullMemoryInformation, // not implemented
	SystemLoadGdiDriverInformation, // s (kernel-mode only)
	SystemUnloadGdiDriverInformation, // s (kernel-mode only)
	SystemTimeAdjustmentInformation, // q: SYSTEM_QUERY_TIME_ADJUST_INFORMATION; s: SYSTEM_SET_TIME_ADJUST_INFORMATION (requires SeSystemtimePrivilege)
	SystemSummaryMemoryInformation, // not implemented
	SystemMirrorMemoryInformation, // s (requires license value "Kernel-MemoryMirroringSupported") (requires SeShutdownPrivilege) // 30
	SystemPerformanceTraceInformation, // s
	SystemObsolete0, // not implemented
	SystemExceptionInformation, // q: SYSTEM_EXCEPTION_INFORMATION
	SystemCrashDumpStateInformation, // s (requires SeDebugPrivilege)
	SystemKernelDebuggerInformation, // q: SYSTEM_KERNEL_DEBUGGER_INFORMATION
	SystemContextSwitchInformation, // q: SYSTEM_CONTEXT_SWITCH_INFORMATION
	SystemRegistryQuotaInformation, // q: SYSTEM_REGISTRY_QUOTA_INFORMATION; s (requires SeIncreaseQuotaPrivilege)
	SystemExtendServiceTableInformation, // s (requires SeLoadDriverPrivilege) // loads win32k only
	SystemPrioritySeperation, // s (requires SeTcbPrivilege)
	SystemVerifierAddDriverInformation, // s (requires SeDebugPrivilege) // 40
	SystemVerifierRemoveDriverInformation, // s (requires SeDebugPrivilege)
	SystemProcessorIdleInformation, // q: SYSTEM_PROCESSOR_IDLE_INFORMATION
	SystemLegacyDriverInformation, // q: SYSTEM_LEGACY_DRIVER_INFORMATION
	SystemCurrentTimeZoneInformation, // q
	SystemLookasideInformation, // q: SYSTEM_LOOKASIDE_INFORMATION
	SystemTimeSlipNotification, // s (requires SeSystemtimePrivilege)
	SystemSessionCreate, // not implemented
	SystemSessionDetach, // not implemented
	SystemSessionInformation, // not implemented
	SystemRangeStartInformation, // q: SYSTEM_RANGE_START_INFORMATION // 50
	SystemVerifierInformation, // q: SYSTEM_VERIFIER_INFORMATION; s (requires SeDebugPrivilege)
	SystemVerifierThunkExtend, // s (kernel-mode only)
	SystemSessionProcessInformation, // q: SYSTEM_SESSION_PROCESS_INFORMATION
	SystemLoadGdiDriverInSystemSpace, // s (kernel-mode only) (same as SystemLoadGdiDriverInformation)
	SystemNumaProcessorMap, // q
	SystemPrefetcherInformation, // q: PREFETCHER_INFORMATION; s: PREFETCHER_INFORMATION // PfSnQueryPrefetcherInformation
	SystemExtendedProcessInformation, // q: SYSTEM_PROCESS_INFORMATION
	SystemRecommendedSharedDataAlignment, // q
	SystemComPlusPackage, // q; s
	SystemNumaAvailableMemory, // 60
	SystemProcessorPowerInformation, // q: SYSTEM_PROCESSOR_POWER_INFORMATION
	SystemEmulationBasicInformation, // q
	SystemEmulationProcessorInformation,
	SystemExtendedHandleInformation, // q: SYSTEM_HANDLE_INFORMATION_EX
	SystemLostDelayedWriteInformation, // q: ULONG
	SystemBigPoolInformation, // q: SYSTEM_BIGPOOL_INFORMATION
	SystemSessionPoolTagInformation, // q: SYSTEM_SESSION_POOLTAG_INFORMATION
	SystemSessionMappedViewInformation, // q: SYSTEM_SESSION_MAPPED_VIEW_INFORMATION
	SystemHotpatchInformation, // q; s
	SystemObjectSecurityMode, // q // 70
	SystemWatchdogTimerHandler, // s (kernel-mode only)
	SystemWatchdogTimerInformation, // q (kernel-mode only); s (kernel-mode only)
	SystemLogicalProcessorInformation, // q: SYSTEM_LOGICAL_PROCESSOR_INFORMATION
	SystemWow64SharedInformationObsolete, // not implemented
	SystemRegisterFirmwareTableInformationHandler, // s (kernel-mode only)
	SystemFirmwareTableInformation, // SYSTEM_FIRMWARE_TABLE_INFORMATION
	SystemModuleInformationEx, // q: RTL_PROCESS_MODULE_INFORMATION_EX
	SystemVerifierTriageInformation, // not implemented
	SystemSuperfetchInformation, // q; s: SUPERFETCH_INFORMATION // PfQuerySuperfetchInformation
	SystemMemoryListInformation, // q: SYSTEM_MEMORY_LIST_INFORMATION; s: SYSTEM_MEMORY_LIST_COMMAND (requires SeProfileSingleProcessPrivilege) // 80
	SystemFileCacheInformationEx, // q: SYSTEM_FILECACHE_INFORMATION; s (requires SeIncreaseQuotaPrivilege) (same as SystemFileCacheInformation)
	SystemThreadPriorityClientIdInformation, // s: SYSTEM_THREAD_CID_PRIORITY_INFORMATION (requires SeIncreaseBasePriorityPrivilege)
	SystemProcessorIdleCycleTimeInformation, // q: SYSTEM_PROCESSOR_IDLE_CYCLE_TIME_INFORMATION[]
	SystemVerifierCancellationInformation, // not implemented // name:wow64:whNT32QuerySystemVerifierCancellationInformation
	SystemProcessorPowerInformationEx, // not implemented
	SystemRefTraceInformation, // q; s: SYSTEM_REF_TRACE_INFORMATION // ObQueryRefTraceInformation
	SystemSpecialPoolInformation, // q; s (requires SeDebugPrivilege) // MmSpecialPoolTag, then MmSpecialPoolCatchOverruns != 0
	SystemProcessIdInformation, // q: SYSTEM_PROCESS_ID_INFORMATION
	SystemErrorPortInformation, // s (requires SeTcbPrivilege)
	SystemBootEnvironmentInformation, // q: SYSTEM_BOOT_ENVIRONMENT_INFORMATION // 90
	SystemHypervisorInformation, // q; s (kernel-mode only)
	SystemVerifierInformationEx, // q; s: SYSTEM_VERIFIER_INFORMATION_EX
	SystemTimeZoneInformation, // s (requires SeTimeZonePrivilege)
	SystemImageFileExecutionOptionsInformation, // s: SYSTEM_IMAGE_FILE_EXECUTION_OPTIONS_INFORMATION (requires SeTcbPrivilege)
	SystemCoverageInformation, // q; s // name:wow64:whNT32QuerySystemCoverageInformation; ExpCovQueryInformation
	SystemPrefetchPatchInformation, // not implemented
	SystemVerifierFaultsInformation, // s (requires SeDebugPrivilege)
	SystemSystemPartitionInformation, // q: SYSTEM_SYSTEM_PARTITION_INFORMATION
	SystemSystemDiskInformation, // q: SYSTEM_SYSTEM_DISK_INFORMATION
	SystemProcessorPerformanceDistribution, // q: SYSTEM_PROCESSOR_PERFORMANCE_DISTRIBUTION // 100
	SystemNumaProximityNodeInformation, // q
	SystemDynamicTimeZoneInformation, // q; s (requires SeTimeZonePrivilege)
	SystemCodeIntegrityInformation, // q: SYSTEM_CODEINTEGRITY_INFORMATION // SeCodeIntegrityQueryInformation
	SystemProcessorMicrocodeUpdateInformation, // s
	SystemProcessorBrandString, // q // HaliQuerySystemInformation -> HalpGetProcessorBrandString, info class 23
	SystemVirtualAddressInformation, // q: SYSTEM_VA_LIST_INFORMATION[]; s: SYSTEM_VA_LIST_INFORMATION[] (requires SeIncreaseQuotaPrivilege) // MmQuerySystemVaInformation
	SystemLogicalProcessorAndGroupInformation, // q: SYSTEM_LOGICAL_PROCESSOR_INFORMATION_EX // since WIN7 // KeQueryLogicalProcessorRelationship
	SystemProcessorCycleTimeInformation, // q: SYSTEM_PROCESSOR_CYCLE_TIME_INFORMATION[]
	SystemStoreInformation, // q; s // SmQueryStoreInformation
	SystemRegistryAppendString, // s: SYSTEM_REGISTRY_APPEND_STRING_PARAMETERS // 110
	SystemAitSamplingValue, // s: ULONG (requires SeProfileSingleProcessPrivilege)
	SystemVhdBootInformation, // q: SYSTEM_VHD_BOOT_INFORMATION
	SystemCpuQuotaInformation, // q; s // PsQueryCpuQuotaInformation
	SystemNativeBasicInformation, // not implemented
	SystemSpare1, // not implemented
	SystemLowPriorityIoInformation, // q: SYSTEM_LOW_PRIORITY_IO_INFORMATION
	SystemTpmBootEntropyInformation, // q: TPM_BOOT_ENTROPY_NT_RESULT // ExQueryTpmBootEntropyInformation
	SystemVerifierCountersInformation, // q: SYSTEM_VERIFIER_COUNTERS_INFORMATION
	SystemPagedPoolInformationEx, // q: SYSTEM_FILECACHE_INFORMATION; s (requires SeIncreaseQuotaPrivilege) (info for WorkingSetTypePagedPool)
	SystemSystemPtesInformationEx, // q: SYSTEM_FILECACHE_INFORMATION; s (requires SeIncreaseQuotaPrivilege) (info for WorkingSetTypeSystemPtes) // 120
	SystemNodeDistanceInformation, // q
	SystemAcpiAuditInformation, // q: SYSTEM_ACPI_AUDIT_INFORMATION // HaliQuerySystemInformation -> HalpAuditQueryResults, info class 26
	SystemBasicPerformanceInformation, // q: SYSTEM_BASIC_PERFORMANCE_INFORMATION // name:wow64:whNtQuerySystemInformation_SystemBasicPerformanceInformation
	SystemQueryPerformanceCounterInformation, // q: SYSTEM_QUERY_PERFORMANCE_COUNTER_INFORMATION // since WIN7 SP1
	SystemSessionBigPoolInformation, // q: SYSTEM_SESSION_POOLTAG_INFORMATION // since WIN8
	SystemBootGraphicsInformation, // q; s: SYSTEM_BOOT_GRAPHICS_INFORMATION (kernel-mode only)
	SystemScrubPhysicalMemoryInformation,
	SystemBadPageInformation,
	SystemProcessorProfileControlArea,
	SystemCombinePhysicalMemoryInformation, // 130
	SystemEntropyInterruptTimingCallback,
	SystemConsoleInformation, // q: SYSTEM_CONSOLE_INFORMATION
	SystemPlatformBinaryInformation, // q: SYSTEM_PLATFORM_BINARY_INFORMATION
	SystemThrottleNotificationInformation,
	SystemHypervisorProcessorCountInformation, // q: SYSTEM_HYPERVISOR_PROCESSOR_COUNT_INFORMATION
	SystemDeviceDataInformation, // q: SYSTEM_DEVICE_DATA_INFORMATION
	SystemDeviceDataEnumerationInformation,
	SystemMemoryTopologyInformation, // q: SYSTEM_MEMORY_TOPOLOGY_INFORMATION
	SystemMemoryChannelInformation, // q: SYSTEM_MEMORY_CHANNEL_INFORMATION
	SystemBootLogoInformation, // q: SYSTEM_BOOT_LOGO_INFORMATION // 140
	SystemProcessorPerformanceInformationEx, // q: SYSTEM_PROCESSOR_PERFORMANCE_INFORMATION_EX // since WINBLUE
	SystemSpare0,
	SystemSecureBootPolicyInformation, // q: SYSTEM_SECUREBOOT_POLICY_INFORMATION
	SystemPageFileInformationEx, // q: SYSTEM_PAGEFILE_INFORMATION_EX
	SystemSecureBootInformation, // q: SYSTEM_SECUREBOOT_INFORMATION
	SystemEntropyInterruptTimingRawInformation,
	SystemPortableWorkspaceEfiLauncherInformation, // q: SYSTEM_PORTABLE_WORKSPACE_EFI_LAUNCHER_INFORMATION
	SystemFullProcessInformation, // q: SYSTEM_PROCESS_INFORMATION with SYSTEM_PROCESS_INFORMATION_EXTENSION (requires admin)
	SystemKernelDebuggerInformationEx, // q: SYSTEM_KERNEL_DEBUGGER_INFORMATION_EX
	SystemBootMetadataInformation, // 150
	SystemSoftRebootInformation,
	SystemElamCertificateInformation, // s: SYSTEM_ELAM_CERTIFICATE_INFORMATION
	SystemOfflineDumpConfigInformation,
	SystemProcessorFeaturesInformation, // q: SYSTEM_PROCESSOR_FEATURES_INFORMATION
	SystemRegistryReconciliationInformation,
	SystemEdidInformation,
	SystemManufacturingInformation, // q: SYSTEM_MANUFACTURING_INFORMATION // since THRESHOLD
	SystemEnergyEstimationConfigInformation, // q: SYSTEM_ENERGY_ESTIMATION_CONFIG_INFORMATION
	SystemHypervisorDetailInformation, // q: SYSTEM_HYPERVISOR_DETAIL_INFORMATION
	SystemProcessorCycleStatsInformation, // q: SYSTEM_PROCESSOR_CYCLE_STATS_INFORMATION // 160
	SystemVmGenerationCountInformation,
	SystemTrustedPlatformModuleInformation, // q: SYSTEM_TPM_INFORMATION
	SystemKernelDebuggerFlags,
	SystemCodeIntegrityPolicyInformation, // q: SYSTEM_CODEINTEGRITYPOLICY_INFORMATION
	SystemIsolatedUserModeInformation, // q: SYSTEM_ISOLATED_USER_MODE_INFORMATION
	SystemHardwareSecurityTestInterfaceResultsInformation,
	SystemSingleModuleInformation, // q: SYSTEM_SINGLE_MODULE_INFORMATION
	SystemAllowedCpuSetsInformation,
	SystemDmaProtectionInformation, // q: SYSTEM_DMA_PROTECTION_INFORMATION
	SystemInterruptCpuSetsInformation, // q: SYSTEM_INTERRUPT_CPU_SET_INFORMATION // 170
	SystemSecureBootPolicyFullInformation, // q: SYSTEM_SECUREBOOT_POLICY_FULL_INFORMATION
	SystemCodeIntegrityPolicyFullInformation,
	SystemAffinitizedInterruptProcessorInformation,
	SystemRootSiloInformation, // q: SYSTEM_ROOT_SILO_INFORMATION
	SystemCpuSetInformation, // q: SYSTEM_CPU_SET_INFORMATION // since THRESHOLD2
	SystemCpuSetTagInformation, // q: SYSTEM_CPU_SET_TAG_INFORMATION
	SystemWin32WerStartCallout,
	SystemSecureKernelProfileInformation, // q: SYSTEM_SECURE_KERNEL_HYPERGUARD_PROFILE_INFORMATION
	SystemCodeIntegrityPlatformManifestInformation, // q: SYSTEM_SECUREBOOT_PLATFORM_MANIFEST_INFORMATION // since REDSTONE
	SystemInterruptSteeringInformation, // 180
	SystemSupportedProcessorArchitectures,
	SystemMemoryUsageInformation, // q: SYSTEM_MEMORY_USAGE_INFORMATION
	SystemCodeIntegrityCertificateInformation, // q: SYSTEM_CODEINTEGRITY_CERTIFICATE_INFORMATION
	MaxSystemInfoClass
} SYSTEM_INFORMATION_CLASS;

typedef enum _KAPC_ENVIRONMENT
{
	OriginalApcEnvironment,
	AttachedApcEnvironment,
	CurrentApcEnvironment,
	InsertApcEnvironment
} KAPC_ENVIRONMENT, *PKAPC_ENVIRONMENT;

typedef enum _MI_VAD_TYPE
{
	VadNone,
	VadDevicePhysicalMemory,
	VadImageMap,
	VadAwe,
	VadWriteWatch,
	VadLargePages,
	VadRotatePhysical,
	VadLargePageSection
} MI_VAD_TYPE, *PMI_VAD_TYPE;

typedef enum _MMSYSTEM_PTE_POOL_TYPE
{
	SystemPteSpace,
	NonPagedPoolExpansion,
	MaximumPtePoolTypes
} MMSYSTEM_PTE_POOL_TYPE;
```

`MMInject/Native/NativeStructs.h`:

```h
#pragma once

#include "NativeEnums.h"
#include <ntimage.h>

#if NTDDI_VERSION >= NTDDI_WIN10
#include "NativeStructs10.h"
#elif NTDDI_VERSION == NTDDI_WINBLUE
#include "NativeStructs81.h"
#elif NTDDI_VERSION == NTDDI_WIN7
#include "NativeStructs7.h"
#else
#error Unsupported OS build version
#endif

#define MAKEINTRESOURCEW(i) ((PWCH)((ULONG_PTR)((USHORT)(i))))

typedef struct _SYSTEM_SERVICE_DESCRIPTOR_TABLE
{
	PULONG_PTR ServiceTableBase;
	PULONG ServiceCounterTableBase;
	ULONG_PTR NumberOfServices;
	PUCHAR ParamTableBase;
} SYSTEM_SERVICE_DESCRIPTOR_TABLE, *PSYSTEM_SERVICE_DESCRIPTOR_TABLE;

typedef union _PS_PROTECTION {
	UCHAR Level;
	struct
	{
		PS_PROTECTED_TYPE Type : 3;
		BOOLEAN Audit : 1;
		PS_PROTECTED_SIGNER Signer : 4;
	} Flags;
} PS_PROTECTION, *PPS_PROTECTION;

typedef struct _EPROCESS_FLAGS // Correct for <= RS2. In RS3+ this contains nothing relevant
{
	UCHAR CreateReported : 1;
	UCHAR NoDebugInherit : 1;
	UCHAR ProcessExiting : 1;
	UCHAR ProcessDelete : 1;
	UCHAR ControlFlowGuardEnabled : 1;
	UCHAR VmDeleted : 1;
	UCHAR OutswapEnabled : 1;
	UCHAR Outswapped : 1;
	UCHAR FailFastOnCommitFail : 1;
	UCHAR Wow64VaSpace4Gb : 1;
	UCHAR AddressSpaceInitialized : 2;
	UCHAR SetTimerResolution : 1;
	UCHAR BreakOnTermination : 1;
	UCHAR DeprioritizeViews : 1;
	UCHAR WriteWatch : 1;
	UCHAR ProcessInSession : 1;
	UCHAR OverrideAddressSpace : 1;
	UCHAR HasAddressSpace : 1;
	UCHAR LaunchPrefetched : 1;
	UCHAR Background : 1;
	UCHAR VmTopDown : 1;
	UCHAR ImageNotifyDone : 1;
	UCHAR PdeUpdateNeeded : 1;
	UCHAR VdmAllowed : 1;
	UCHAR ProcessRundown : 1;
	UCHAR ProcessInserted : 1;
	UCHAR DefaultIoPriority : 3;
	UCHAR ProcessSelfDelete : 1;
	UCHAR SetTimerResolutionLink : 1;
} EPROCESS_FLAGS, *PEPROCESS_FLAGS;

typedef struct _EPROCESS_FLAGS2 // Correct for <= RS2. In RS3 this contains nothing relevant
{
	unsigned int JobNotReallyActive : 1;
	unsigned int AccountingFolded : 1;
	unsigned int NewProcessReported : 1;
	unsigned int ExitProcessReported : 1;
	unsigned int ReportCommitChanges : 1;
	unsigned int LastReportMemory : 1;
	unsigned int ForceWakeCharge : 1;
	unsigned int CrossSessionCreate : 1;
	unsigned int NeedsHandleRundown : 1;
	unsigned int RefTraceEnabled : 1;
	unsigned int DisableDynamicCode : 1;
	unsigned int EmptyJobEvaluated : 1;
	unsigned int DefaultPagePriority : 3;
	unsigned int PrimaryTokenFrozen : 1;
	unsigned int ProcessVerifierTarget : 1;
	unsigned int StackRandomizationDisabled : 1;
	unsigned int AffinityPermanent : 1;
	unsigned int AffinityUpdateEnable : 1;
	unsigned int PropagateNode : 1;
	unsigned int ExplicitAffinity : 1;
	unsigned int ProcessExecutionState : 2;
	unsigned int DisallowStrippedImages : 1;
	unsigned int HighEntropyASLREnabled : 1;
	unsigned int ExtensionPointDisable : 1;
	unsigned int ForceRelocateImages : 1;
	unsigned int ProcessStateChangeRequest : 2;
	unsigned int ProcessStateChangeInProgress : 1;
	unsigned int DisallowWin32kSystemCalls : 1;
} EPROCESS_FLAGS2, *PEPROCESS_FLAGS2;

typedef struct _EPROCESS_FLAGS2_RS4_PLUS // RS4/RS5 version. Almost irrelevant, except for...
{
	unsigned int JobNotReallyActive : 1;
	unsigned int AccountingFolded : 1;
	unsigned int NewProcessReported : 1;
	unsigned int ExitProcessReported : 1;
	unsigned int ReportCommitChanges : 1;
	unsigned int LastReportMemory : 1;
	unsigned int ForceWakeCharge : 1;
	unsigned int CrossSessionCreate : 1;
	unsigned int NeedsHandleRundown : 1;
	unsigned int RefTraceEnabled : 1;
	unsigned int PicoCreated : 1;
	unsigned int EmptyJobEvaluated : 1;
	unsigned int DefaultPagePriority : 3;
	unsigned int PrimaryTokenFrozen : 1;
	unsigned int ProcessVerifierTarget : 1;
	unsigned int RestrictSetThreadContext : 1; // ...this guy
	unsigned int AffinityPermanent : 1;
	unsigned int AffinityUpdateEnable : 1;
	unsigned int PropagateNode : 1;
	unsigned int ExplicitAffinity : 1;
	unsigned int ProcessExecutionState : 2;
	unsigned int EnableReadVmLogging : 1;	// and maybe
	unsigned int EnableWriteVmLogging : 1;	// these two?
	unsigned int FatalAccessTerminationRequested : 1;
	unsigned int DisableSystemAllowedCpuSet : 1;
	unsigned int ProcessStateChangeRequest : 2;
	unsigned int ProcessStateChangeInProgress : 1;
	unsigned int InPrivate : 1;
} EPROCESS_FLAGS2_RS4_PLUS, *PEPROCESS_FLAGS2_RS4_PLUS;

typedef struct _EPROCESS_MITIGATION_FLAGS // Since RS3
{
	unsigned int ControlFlowGuardEnabled : 1;
	unsigned int ControlFlowGuardExportSuppressionEnabled : 1;
	unsigned int ControlFlowGuardStrict : 1;
	unsigned int DisallowStrippedImages : 1;
	unsigned int ForceRelocateImages : 1;
	unsigned int HighEntropyASLREnabled : 1;
	unsigned int StackRandomizationDisabled : 1;
	unsigned int ExtensionPointDisable : 1;
	unsigned int DisableDynamicCode : 1;
	unsigned int DisableDynamicCodeAllowOptOut : 1;
	unsigned int DisableDynamicCodeAllowRemoteDowngrade : 1;
	unsigned int AuditDisableDynamicCode : 1;
	unsigned int DisallowWin32kSystemCalls : 1;
	unsigned int AuditDisallowWin32kSystemCalls : 1;
	unsigned int EnableFilteredWin32kAPIs : 1;
	unsigned int AuditFilteredWin32kAPIs : 1;
	unsigned int DisableNonSystemFonts : 1;
	unsigned int AuditNonSystemFontLoading : 1;
	unsigned int PreferSystem32Images : 1;
	unsigned int ProhibitRemoteImageMap : 1;
	unsigned int AuditProhibitRemoteImageMap : 1;
	unsigned int ProhibitLowILImageMap : 1;
	unsigned int AuditProhibitLowILImageMap : 1;
	unsigned int SignatureMitigationOptIn : 1;
	unsigned int AuditBlockNonMicrosoftBinaries : 1;
	unsigned int AuditBlockNonMicrosoftBinariesAllowStore : 1;
	unsigned int LoaderIntegrityContinuityEnabled : 1;
	unsigned int AuditLoaderIntegrityContinuity : 1;
	unsigned int EnableModuleTamperingProtection : 1;
	unsigned int EnableModuleTamperingProtectionNoInherit : 1;
	unsigned int RestrictIndirectBranchPrediction : 1;
	unsigned int IsolateSecurityDomain : 1;
} EPROCESS_MITIGATION_FLAGS, *PEPROCESS_MITIGATION_FLAGS;

typedef struct _EPROCESS_MITIGATION_FLAGS2 // Since RS3
{
	unsigned int EnableExportAddressFilter : 1;
	unsigned int AuditExportAddressFilter : 1;
	unsigned int EnableExportAddressFilterPlus : 1;
	unsigned int AuditExportAddressFilterPlus : 1;
	unsigned int EnableRopStackPivot : 1;
	unsigned int AuditRopStackPivot : 1;
	unsigned int EnableRopCallerCheck : 1;
	unsigned int AuditRopCallerCheck : 1;
	unsigned int EnableRopSimExec : 1;
	unsigned int AuditRopSimExec : 1;
	unsigned int EnableImportAddressFilter : 1;
	unsigned int AuditImportAddressFilter : 1;
	unsigned int DisablePageCombine : 1; // Since 19H1
	unsigned int SpeculativeStoreBypassDisable : 1;
	unsigned int CetUserShadowStacks : 1;
} EPROCESS_MITIGATION_FLAGS2, *PEPROCESS_MITIGATION_FLAGS2;

typedef union _EXHANDLE {
	struct
	{
		int TagBits : 2;
		int Index : 30;
	} u;
	void *GenericHandleOverlay;
	ULONG_PTR Value;
} EXHANDLE, *PEXHANDLE;

#pragma warning(disable : 4214 4201)


typedef struct _HANDLE_TABLE_ENTRY // Size=16
{
	union {
		ULONG_PTR VolatileLowValue; // Size=8 Offset=0
		ULONG_PTR LowValue; // Size=8 Offset=0
		struct _HANDLE_TABLE_ENTRY_INFO *InfoTable; // Size=8 Offset=0
		struct
		{
			ULONG_PTR Unlocked : 1; // Size=8 Offset=0 BitOffset=0 BitCount=1
#ifdef _WIN64
			ULONG_PTR RefCnt : 16; // Size=8 Offset=0 BitOffset=1 BitCount=16
			ULONG_PTR Attributes : 3; // Size=8 Offset=0 BitOffset=17 BitCount=3
			ULONG_PTR ObjectPointerBits : 44; // Size=8 Offset=0 BitOffset=20 BitCount=44
#else
			ULONG_PTR Attributes : 2; // Size=8 Offset=0 BitOffset=17 BitCount=3
			ULONG_PTR ObjectPointerBits : 29; // Size=8 Offset=0 BitOffset=3 BitCount=29
#endif
		};
	};
	union {
		ULONG_PTR HighValue; // Size=8 Offset=8
		struct _HANDLE_TABLE_ENTRY *NextFreeHandleEntry; // Size=8 Offset=8
		union _EXHANDLE LeafHandleValue; // Size=8 Offset=8
		struct
		{
			ULONG GrantedAccessBits : 25; // Size=4 Offset=8 BitOffset=0 BitCount=25
			ULONG NoRightsUpgrade : 1; // Size=4 Offset=8 BitOffset=25 BitCount=1
			ULONG Spare : 6; // Size=4 Offset=8 BitOffset=26 BitCount=6
		};
	};
	ULONG TypeInfo; // Size=4 Offset=12
} HANDLE_TABLE_ENTRY, *PHANDLE_TABLE_ENTRY;


typedef struct _OBJECT_HEADER // Size=56
{
	ULONG_PTR PointerCount; // Size=8 Offset=0
	union {
		ULONG_PTR HandleCount; // Size=8 Offset=8
		void *NextToFree; // Size=8 Offset=8
	};
	void *Lock; // Size=8 Offset=16
	UCHAR TypeIndex; // Size=1 Offset=24
	union {
		UCHAR TraceFlags; // Size=1 Offset=25
		struct
		{
			UCHAR DbgRefTrace : 1; // Size=1 Offset=25 BitOffset=0 BitCount=1
			UCHAR DbgTracePermanent : 1; // Size=1 Offset=25 BitOffset=1 BitCount=1
		};
	};
	UCHAR InfoMask; // Size=1 Offset=26
	union {
		UCHAR Flags; // Size=1 Offset=27
		struct
		{
			UCHAR NewObject : 1; // Size=1 Offset=27 BitOffset=0 BitCount=1
			UCHAR KernelObject : 1; // Size=1 Offset=27 BitOffset=1 BitCount=1
			UCHAR KernelOnlyAccess : 1; // Size=1 Offset=27 BitOffset=2 BitCount=1
			UCHAR ExclusiveObject : 1; // Size=1 Offset=27 BitOffset=3 BitCount=1
			UCHAR PermanentObject : 1; // Size=1 Offset=27 BitOffset=4 BitCount=1
			UCHAR DefaultSecurityQuota : 1; // Size=1 Offset=27 BitOffset=5 BitCount=1
			UCHAR SingleHandleEntry : 1; // Size=1 Offset=27 BitOffset=6 BitCount=1
			UCHAR DeletedInline : 1; // Size=1 Offset=27 BitOffset=7 BitCount=1
		};
	};
	ULONG Spare; // Size=4 Offset=28
	union {
		struct _OBJECT_CREATE_INFORMATION *ObjectCreateInfo; // Size=8 Offset=32
		void *QuotaBlockCharged; // Size=8 Offset=32
	};
	void *SecurityDescriptor; // Size=8 Offset=40
	struct _QUAD Body; // Size=8 Offset=48
} OBJECT_HEADER, *POBJECT_HEADER;

typedef union _EX_FAST_REF // Size=8
{
	void *Object;
	struct
	{
		unsigned __int64 RefCnt : 4;
	};
	unsigned __int64 Value;
} EX_FAST_REF, *PEX_FAST_REF;

typedef struct _SEGMENT
{
	PVOID ControlArea;
	ULONG TotalNumberOfPtes;
	UCHAR SegmentFlags;
	ULONG64 NumberOfCommittedPages;
	ULONG64 SizeOfSegment;
	union
	{
		PVOID ExtendInfo;
		PVOID BasedAddress;
	} u1;
	ULONG64 u2;
	ULONG64 u3;
	PVOID PrototypePte;
} SEGMENT, *PSEGMENT;

typedef struct _CONTROL_AREA // Size=120
{
	struct _SEGMENT *Segment;
	struct _LIST_ENTRY ListHead;
	unsigned __int64 NumberOfSectionReferences;
	unsigned __int64 NumberOfPfnReferences;
	unsigned __int64 NumberOfMappedViews;
	unsigned __int64 NumberOfUserReferences;
	unsigned long f1;
	unsigned long f2;
	EX_FAST_REF FilePointer;
	// Other fields
} CONTROL_AREA, *PCONTROL_AREA;

typedef struct _SUBSECTION // Size=56
{
	PCONTROL_AREA ControlArea;
	// Other fields
} SUBSECTION, *PSUBSECTION;

typedef struct _MEMORY_BASIC_INFORMATION_EX
{
	PVOID BaseAddress;
	PVOID AllocationBase;
	ULONG AllocationProtect;
	SIZE_T RegionSize;
	ULONG State;
	ULONG Protect;
	ULONG Type;
} MEMORY_BASIC_INFORMATION_EX, *PMEMORY_BASIC_INFORMATION_EX;

typedef struct _SYSTEM_CALL_COUNT_INFORMATION
{
	ULONG Length;
	ULONG NumberOfTables;
	ULONG limits[2];
} SYSTEM_CALL_COUNT_INFORMATION, *PSYSTEM_CALL_COUNT_INFORMATION;

typedef struct _SYSTEM_THREAD_INFORMATION
{
	LARGE_INTEGER KernelTime;
	LARGE_INTEGER UserTime;
	LARGE_INTEGER CreateTime;
	ULONG WaitTime;
	PVOID StartAddress;
	CLIENT_ID ClientId;
	KPRIORITY Priority;
	LONG BasePriority;
	ULONG ContextSwitches;
	ULONG ThreadState;
	KWAIT_REASON WaitReason;
} SYSTEM_THREAD_INFORMATION, *PSYSTEM_THREAD_INFORMATION;

typedef struct _THREAD_BASIC_INFORMATION
{
	NTSTATUS ExitStatus;
	PVOID TebBaseAddress;
	CLIENT_ID ClientId;
	ULONG_PTR AffinityMask;
	LONG Priority;
	LONG BasePriority;
} THREAD_BASIC_INFORMATION, *PTHREAD_BASIC_INFORMATION;

typedef struct _SYSTEM_PROCESS_INFO
{
	ULONG NextEntryOffset;
	ULONG NumberOfThreads;
	LARGE_INTEGER WorkingSetPrivateSize;
	ULONG HardFaultCount;
	ULONG NumberOfThreadsHighWatermark;
	ULONGLONG CycleTime;
	LARGE_INTEGER CreateTime;
	LARGE_INTEGER UserTime;
	LARGE_INTEGER KernelTime;
	UNICODE_STRING ImageName;
	KPRIORITY BasePriority;
	HANDLE UniqueProcessId;
	HANDLE InheritedFromUniqueProcessId;
	ULONG HandleCount;
	ULONG SessionId;
	ULONG_PTR UniqueProcessKey;
	SIZE_T PeakVirtualSize;
	SIZE_T VirtualSize;
	ULONG PageFaultCount;
	SIZE_T PeakWorkingSetSize;
	SIZE_T WorkingSetSize;
	SIZE_T QuotaPeakPagedPoolUsage;
	SIZE_T QuotaPagedPoolUsage;
	SIZE_T QuotaPeakNonPagedPoolUsage;
	SIZE_T QuotaNonPagedPoolUsage;
	SIZE_T PagefileUsage;
	SIZE_T PeakPagefileUsage;
	SIZE_T PrivatePageCount;
	LARGE_INTEGER ReadOperationCount;
	LARGE_INTEGER WriteOperationCount;
	LARGE_INTEGER OtherOperationCount;
	LARGE_INTEGER ReadTransferCount;
	LARGE_INTEGER WriteTransferCount;
	LARGE_INTEGER OtherTransferCount;
	SYSTEM_THREAD_INFORMATION Threads[1];
} SYSTEM_PROCESS_INFO, *PSYSTEM_PROCESS_INFO;

#pragma warning(disable : 4214)
typedef struct _MMPTE_HARDWARE64
{
	ULONGLONG Valid : 1;
	ULONGLONG Dirty1 : 1;
	ULONGLONG Owner : 1;
	ULONGLONG WriteThrough : 1;
	ULONGLONG CacheDisable : 1;
	ULONGLONG Accessed : 1;
	ULONGLONG Dirty : 1;
	ULONGLONG LargePage : 1;
	ULONGLONG Global : 1;
	ULONGLONG CopyOnWrite : 1;
	ULONGLONG Unused : 1;
	ULONGLONG Write : 1;
	ULONGLONG PageFrameNumber : 36;
	ULONGLONG ReservedForHardware : 4;
	ULONGLONG ReservedForSoftware : 4;
	ULONGLONG WsleAge : 4;
	ULONGLONG WsleProtection : 3;
	ULONGLONG NoExecute : 1;
} MMPTE_HARDWARE64, *PMMPTE_HARDWARE64;

typedef struct _MMPTE
{
	union {
		ULONG_PTR Long;
		MMPTE_HARDWARE64 Hard;
	} u;
} MMPTE;
typedef MMPTE *PMMPTE;

#pragma warning(default : 4214)

typedef struct _RTL_PROCESS_MODULE_INFORMATION
{
	HANDLE Section; // Not filled in
	PVOID MappedBase;
	PVOID ImageBase;
	ULONG ImageSize;
	ULONG Flags;
	USHORT LoadOrderIndex;
	USHORT InitOrderIndex;
	USHORT LoadCount;
	USHORT OffsetToFileName;
	UCHAR FullPathName[MAXIMUM_FILENAME_LENGTH];
} RTL_PROCESS_MODULE_INFORMATION, *PRTL_PROCESS_MODULE_INFORMATION;

typedef struct _RTL_PROCESS_MODULES
{
	ULONG NumberOfModules;
	RTL_PROCESS_MODULE_INFORMATION Modules[1];
} RTL_PROCESS_MODULES, *PRTL_PROCESS_MODULES;

typedef struct _PEB_LDR_DATA
{
	ULONG Length;
	BOOLEAN Initialized;
	HANDLE SsHandle;
	LIST_ENTRY InLoadOrderModuleList;
	LIST_ENTRY InMemoryOrderModuleList;
	LIST_ENTRY InInitializationOrderModuleList;
	PVOID EntryInProgress;
	BOOLEAN ShutdownInProgress;
	HANDLE ShutdownThreadId;
} PEB_LDR_DATA, *PPEB_LDR_DATA;

typedef struct _LDR_SERVICE_TAG_RECORD
{
	struct _LDR_SERVICE_TAG_RECORD *Next;
	ULONG ServiceTag;
} LDR_SERVICE_TAG_RECORD, *PLDR_SERVICE_TAG_RECORD;

typedef struct _LDRP_CSLIST
{
	PSINGLE_LIST_ENTRY Tail;
} LDRP_CSLIST, *PLDRP_CSLIST;

typedef enum _LDR_DDAG_STATE {
	LdrModulesMerged = -5,
	LdrModulesInitError = -4,
	LdrModulesSnapError = -3,
	LdrModulesUnloaded = -2,
	LdrModulesUnloading = -1,
	LdrModulesPlaceHolder = 0,
	LdrModulesMapping = 1,
	LdrModulesMapped = 2,
	LdrModulesWaitingForDependencies = 3,
	LdrModulesSnapping = 4,
	LdrModulesSnapped = 5,
	LdrModulesCondensed = 6,
	LdrModulesReadyToInit = 7,
	LdrModulesInitializing = 8,
	LdrModulesReadyToRun = 9
} LDR_DDAG_STATE;

typedef struct _LDR_DDAG_NODE
{
	LIST_ENTRY Modules;
	PLDR_SERVICE_TAG_RECORD ServiceTagList;
	ULONG LoadCount;
	ULONG LoadWhileUnloadingCount;
	ULONG LowestLink;
	union {
		LDRP_CSLIST Dependencies;
		SINGLE_LIST_ENTRY RemovalLink;
	};
	LDRP_CSLIST IncomingDependencies;
	LDR_DDAG_STATE State;
	SINGLE_LIST_ENTRY CondenseLink;
	ULONG PreorderNumber;
} LDR_DDAG_NODE, *PLDR_DDAG_NODE;

typedef struct _LDR_DEPENDENCY_RECORD
{
	SINGLE_LIST_ENTRY DependencyLink;
	PLDR_DDAG_NODE DependencyNode;
	SINGLE_LIST_ENTRY IncomingDependencyLink;
	PLDR_DDAG_NODE IncomingDependencyNode;
} LDR_DEPENDENCY_RECORD, *PLDR_DEPENDENCY_RECORD;

typedef enum _LDR_DLL_LOAD_REASON {
	LoadReasonStaticDependency,
	LoadReasonStaticForwarderDependency,
	LoadReasonDynamicForwarderDependency,
	LoadReasonDelayloadDependency,
	LoadReasonDynamicLoad,
	LoadReasonAsImageLoad,
	LoadReasonAsDataLoad,
	LoadReasonUnknown = -1
} LDR_DLL_LOAD_REASON,
	*PLDR_DLL_LOAD_REASON;

typedef struct _LDR_DATA_TABLE_ENTRY
{
	LIST_ENTRY InLoadOrderLinks;
	LIST_ENTRY InMemoryOrderLinks;
	union {
		LIST_ENTRY InInitializationOrderLinks;
		LIST_ENTRY InProgressLinks;
	};
	PVOID DllBase;
	PVOID EntryPoint;
	ULONG SizeOfImage;
	UNICODE_STRING FullDllName;
	UNICODE_STRING BaseDllName;
	union {
		UCHAR FlagGroup[4];
		ULONG Flags;
		struct
		{
			ULONG PackagedBinary : 1;
			ULONG MarkedForRemoval : 1;
			ULONG ImageDll : 1;
			ULONG LoadNotificationsSent : 1;
			ULONG TelemetryEntryProcessed : 1;
			ULONG ProcessStaticImport : 1;
			ULONG InLegacyLists : 1;
			ULONG InIndexes : 1;
			ULONG ShimDll : 1;
			ULONG InExceptionTable : 1;
			ULONG ReservedFlags1 : 2;
			ULONG LoadInProgress : 1;
			ULONG LoadConfigProcessed : 1;
			ULONG EntryProcessed : 1;
			ULONG ProtectDelayLoad : 1;
			ULONG ReservedFlags3 : 2;
			ULONG DontCallForThreads : 1;
			ULONG ProcessAttachCalled : 1;
			ULONG ProcessAttachFailed : 1;
			ULONG CorDeferredValidate : 1;
			ULONG CorImage : 1;
			ULONG DontRelocate : 1;
			ULONG CorILOnly : 1;
			ULONG ReservedFlags5 : 3;
			ULONG Redirected : 1;
			ULONG ReservedFlags6 : 2;
			ULONG CompatDatabaseProcessed : 1;
		};
	};
	USHORT ObsoleteLoadCount;
	USHORT TlsIndex;
	LIST_ENTRY HashLinks;
	ULONG TimeDateStamp;
	struct _ACTIVATION_CONTEXT *EntryPointActivationContext;
	PVOID Lock;
	PLDR_DDAG_NODE DdagNode;
	LIST_ENTRY NodeModuleLink;
	struct _LDRP_LOAD_CONTEXT *LoadContext;
	PVOID ParentDllBase;
	PVOID SwitchBackContext;
	RTL_BALANCED_NODE BaseAddressIndexNode;
	RTL_BALANCED_NODE MappingInfoIndexNode;
	ULONG_PTR OriginalBase;
	LARGE_INTEGER LoadTime;
	ULONG BaseNameHashValue;
	LDR_DLL_LOAD_REASON LoadReason;
	ULONG ImplicitPathOptions;
	ULONG ReferenceCount;
	ULONG DependentLoadFlags;
} LDR_DATA_TABLE_ENTRY, *PLDR_DATA_TABLE_ENTRY;

typedef struct _PEB_LDR_DATA32
{
	ULONG Length;
	UCHAR Initialized;
	ULONG SsHandle;
	LIST_ENTRY32 InLoadOrderModuleList;
	LIST_ENTRY32 InMemoryOrderModuleList;
	LIST_ENTRY32 InInitializationOrderModuleList;
} PEB_LDR_DATA32, *PPEB_LDR_DATA32;

typedef struct _LDR_DATA_TABLE_ENTRY32
{
	LIST_ENTRY32 InLoadOrderLinks;
	LIST_ENTRY32 InMemoryOrderLinks;
	LIST_ENTRY32 InInitializationOrderLinks;
	ULONG DllBase;
	ULONG EntryPoint;
	ULONG SizeOfImage;
	UNICODE_STRING32 FullDllName;
	UNICODE_STRING32 BaseDllName;
	ULONG Flags;
	USHORT LoadCount;
	USHORT TlsIndex;
	LIST_ENTRY32 HashLinks;
	ULONG TimeDateStamp;
} LDR_DATA_TABLE_ENTRY32, *PLDR_DATA_TABLE_ENTRY32;

typedef struct _PEB32
{
	UCHAR InheritedAddressSpace;
	UCHAR ReadImageFileExecOptions;
	UCHAR BeingDebugged;
	UCHAR BitField;
	ULONG Mutant;
	ULONG ImageBaseAddress;
	ULONG Ldr;
	ULONG ProcessParameters;
	ULONG SubSystemData;
	ULONG ProcessHeap;
	ULONG FastPebLock;
	ULONG AtlThunkSListPtr;
	ULONG IFEOKey;
	ULONG CrossProcessFlags;
	ULONG KernelCallbackTable;
	ULONG SystemReserved;
	ULONG AtlThunkSListPtr32;
	ULONG ApiSetMap;
} PEB32, *PPEB32;

typedef struct _SEP_TOKEN_PRIVILEGES
{
	ULONG64 Present;
	ULONG64 Enabled;
	ULONG64 EnabledByDefault;
} SEP_TOKEN_PRIVILEGES, * PSEP_TOKEN_PRIVILEGES;

typedef struct _SEP_AUDIT_POLICY
{
	TOKEN_AUDIT_POLICY AdtTokenPolicy;
	UCHAR PolicySetStatus;
} SEP_AUDIT_POLICY, * PSEP_AUDIT_POLICY;

typedef struct _TOKEN
{
	TOKEN_SOURCE TokenSource;
	LUID TokenId;
	LUID AuthenticationId;
	LUID ParentTokenId;
	LARGE_INTEGER ExpirationTime;
	PERESOURCE TokenLock;
	LUID ModifiedId;
	SEP_TOKEN_PRIVILEGES Privileges;
	SEP_AUDIT_POLICY AuditPolicy;
	ULONG SessionId;
	ULONG UserAndGroupCount;
	ULONG RestrictedSidCount;
	ULONG VariableLength;
	ULONG DynamicCharged;
	ULONG DynamicAvailable;
	ULONG DefaultOwnerIndex;
	PSID_AND_ATTRIBUTES UserAndGroups;
	PSID_AND_ATTRIBUTES RestrictedSids;
	PVOID PrimaryGroup;
	PULONG DynamicPart;
	PACL DefaultDacl;
	TOKEN_TYPE TokenType;
	SECURITY_IMPERSONATION_LEVEL ImpersonationLevel;
	ULONG TokenFlags;
	UCHAR TokenInUse;
	ULONG IntegrityLevelIndex;
	ULONG MandatoryPolicy;
	struct _SEP_LOGON_SESSION_REFERENCES* LogonSession;
	LUID OriginatingLogonSession;
	SID_AND_ATTRIBUTES_HASH SidHash;
	SID_AND_ATTRIBUTES_HASH RestrictedSidHash;
	struct _AUTHZBASEP_SECURITY_ATTRIBUTES_INFORMATION* pSecurityAttributes;

	// Begin Windows 8/8.1/10+ only fields
	PVOID Package;
	PSID_AND_ATTRIBUTES Capabilities;
	ULONG CapabilityCount;
	SID_AND_ATTRIBUTES_HASH CapabilitiesHash;
	struct _SEP_LOWBOX_NUMBER_ENTRY* LowboxNumberEntry;
	struct _SEP_CACHED_HANDLES_ENTRY* LowboxHandlesEntry;
	struct _AUTHZBASEP_CLAIM_ATTRIBUTES_COLLECTION* pClaimAttributes;
	PVOID TrustLevelSid;
	struct _TOKEN* TrustLinkedToken;
	PVOID IntegrityLevelSidValue;
	struct _SEP_SID_VALUES_BLOCK* TokenSidValues;
	struct _SEP_LUID_TO_INDEX_MAP_ENTRY* IndexEntry;
	struct _SEP_TOKEN_DIAG_TRACK_ENTRY* DiagnosticInfo;
	struct _SEP_CACHED_HANDLES_ENTRY* BnoIsolationHandlesEntry;
	// End Windows 8/8.1/10+ only fields

	PVOID SessionObject;
	ULONG64 VariablePart;
} TOKEN, * PTOKEN;

typedef struct _WOW64_PROCESS
{
	PPEB32 Wow64;
} WOW64_PROCESS, *PWOW64_PROCESS;

typedef union _WOW64_APC_CONTEXT {
	struct
	{
		ULONG Apc32BitContext;
		ULONG Apc32BitRoutine;
	};

	PVOID Apc64BitContext;

} WOW64_APC_CONTEXT, *PWOW64_APC_CONTEXT;

#define WOW64_SIZE_OF_80387_REGISTERS		80
#define WOW64_MAXIMUM_SUPPORTED_EXTENSION	512

typedef struct _WOW64_FLOATING_SAVE_AREA
{
	ULONG	ControlWord;
	ULONG	StatusWord;
	ULONG	TagWord;
	ULONG	ErrorOffset;
	ULONG	ErrorSelector;
	ULONG	DataOffset;
	ULONG	DataSelector;
	UCHAR	RegisterArea[WOW64_SIZE_OF_80387_REGISTERS];
	ULONG	Cr0NpxState;
} WOW64_FLOATING_SAVE_AREA;

#pragma pack(push, 4)

typedef struct _WOW64_CONTEXT {
	ULONG ContextFlags;

	ULONG	Dr0;
	ULONG	Dr1;
	ULONG	Dr2;
	ULONG	Dr3;
	ULONG	Dr6;
	ULONG	Dr7;

	WOW64_FLOATING_SAVE_AREA FloatSave;

	ULONG	SegGs;
	ULONG	SegFs;
	ULONG	SegEs;
	ULONG	SegDs;

	ULONG	Edi;
	ULONG	Esi;
	ULONG	Ebx;
	ULONG	Edx;
	ULONG	Ecx;
	ULONG	Eax;

	ULONG	Ebp;
	ULONG	Eip;
	ULONG	SegCs;
	ULONG	EFlags;
	ULONG	Esp;
	ULONG	SegSs;

	UCHAR	ExtendedRegisters[WOW64_MAXIMUM_SUPPORTED_EXTENSION];
} WOW64_CONTEXT, *PWOW64_CONTEXT;

#pragma pack(pop)

typedef struct _KLDR_DATA_TABLE_ENTRY
{
	LIST_ENTRY InLoadOrderLinks;
	PVOID ExceptionTable;
	ULONG ExceptionTableSize;
	// ULONG padding on IA64
	PVOID GpValue;
	PNON_PAGED_DEBUG_INFO NonPagedDebugInfo;
	PVOID DllBase;
	PVOID EntryPoint;
	ULONG SizeOfImage;
	UNICODE_STRING FullDllName;
	UNICODE_STRING BaseDllName;
	ULONG Flags;
	USHORT LoadCount;
	USHORT __Unused5;
	PVOID SectionPointer;
	ULONG CheckSum;
	// ULONG padding on IA64
	PVOID LoadedImports;
	PVOID PatchInformation;
} KLDR_DATA_TABLE_ENTRY, *PKLDR_DATA_TABLE_ENTRY;

```

`MMInject/Native/NativeStructs10.h`:

```h
#pragma once

//
// Native structures W10
//
#pragma warning(disable : 4214 4201)
#pragma pack(push, 1)

typedef struct _MM_AVL_NODE // Size=24
{
	struct _MM_AVL_NODE *LeftChild; // Size=8 Offset=0
	struct _MM_AVL_NODE *RightChild; // Size=8 Offset=8

	union ___unnamed1666 // Size=8
	{
		struct
		{
			__int64 Balance : 2; // Size=8 Offset=0 BitOffset=0 BitCount=2
		};
		struct _MM_AVL_NODE *Parent; // Size=8 Offset=0
	} u1;
} MM_AVL_NODE, *PMM_AVL_NODE, *PMMADDRESS_NODE;

typedef struct _RTL_AVL_TREE // Size=8
{
	PMM_AVL_NODE BalancedRoot;
	void *NodeHint;
	unsigned __int64 NumberGenericTableElements;
} RTL_AVL_TREE, *PRTL_AVL_TREE, MM_AVL_TABLE, *PMM_AVL_TABLE;

union _EX_PUSH_LOCK // Size=8
{
	struct
	{
		unsigned __int64 Locked : 1; // Size=8 Offset=0 BitOffset=0 BitCount=1
		unsigned __int64 Waiting : 1; // Size=8 Offset=0 BitOffset=1 BitCount=1
		unsigned __int64 Waking : 1; // Size=8 Offset=0 BitOffset=2 BitCount=1
		unsigned __int64 MultipleShared : 1; // Size=8 Offset=0 BitOffset=3 BitCount=1
		unsigned __int64 Shared : 60; // Size=8 Offset=0 BitOffset=4 BitCount=60
	};
	unsigned __int64 Value; // Size=8 Offset=0
	void *Ptr; // Size=8 Offset=0
};

struct _MMVAD_FLAGS // Size=4 // PRE 19H1
{
	unsigned long VadType : 3; // Size=4 Offset=0 BitOffset=0 BitCount=3
	unsigned long Protection : 5; // Size=4 Offset=0 BitOffset=3 BitCount=5
	unsigned long PreferredNode : 6; // Size=4 Offset=0 BitOffset=8 BitCount=6
	unsigned long NoChange : 1; // Size=4 Offset=0 BitOffset=14 BitCount=1
	unsigned long PrivateMemory : 1; // Size=4 Offset=0 BitOffset=15 BitCount=1
	unsigned long Teb : 1; // Size=4 Offset=0 BitOffset=16 BitCount=1
	unsigned long PrivateFixup : 1; // Size=4 Offset=0 BitOffset=17 BitCount=1
	unsigned long ManySubsections : 1; // Size=4 Offset=0 BitOffset=18 BitCount=1
	unsigned long Spare : 12; // Size=4 Offset=0 BitOffset=19 BitCount=12
	unsigned long DeleteInProgress : 1; // Size=4 Offset=0 BitOffset=31 BitCount=1
};

struct _MMVAD_FLAGS_19H1
{
	unsigned long Lock : 1;
	unsigned long LockContended : 1;
	unsigned long DeleteInProgress : 1;
	unsigned long NoChange : 1;
	unsigned long VadType : 3;
	unsigned long Protection : 5;
	unsigned long PreferredNode : 6;
	unsigned long PageSize : 2;
	unsigned long PrivateMemory : 1;
};

struct _MMVAD_FLAGS1 // Size=4
{
	unsigned long CommitCharge : 31; // Size=4 Offset=0 BitOffset=0 BitCount=31
	unsigned long MemCommit : 1; // Size=4 Offset=0 BitOffset=31 BitCount=1
};

struct _MMVAD_FLAGS2 // Size=4 // PRE 19H1
{
	unsigned long FileOffset : 24; // Size=4 Offset=0 BitOffset=0 BitCount=24
	unsigned long Large : 1; // Size=4 Offset=0 BitOffset=24 BitCount=1
	unsigned long TrimBehind : 1; // Size=4 Offset=0 BitOffset=25 BitCount=1
	unsigned long Inherit : 1; // Size=4 Offset=0 BitOffset=26 BitCount=1
	unsigned long CopyOnWrite : 1; // Size=4 Offset=0 BitOffset=27 BitCount=1
	unsigned long NoValidationNeeded : 1; // Size=4 Offset=0 BitOffset=28 BitCount=1
	unsigned long Spare : 3; // Size=4 Offset=0 BitOffset=29 BitCount=3
};

struct _MMVAD_FLAGS2_19H1
{
	unsigned long FileOffset : 24;
	unsigned long Large : 1;
	unsigned long TrimBehind : 1;
	unsigned long Inherit : 1;
	unsigned long NoValidationNeeded : 1;
	unsigned long PrivateDemandZero : 1;
	unsigned long Spare : 3;
};

struct _MI_VAD_SEQUENTIAL_INFO // Size=8
{
	unsigned __int64 Length : 12; // Size=8 Offset=0 BitOffset=0 BitCount=12
	unsigned __int64 Vpn : 52; // Size=8 Offset=0 BitOffset=12 BitCount=52
};

union ___unnamed1951 // Size=4
{
	unsigned long LongFlags; // Size=4 Offset=0
	struct _MMVAD_FLAGS VadFlags; // Size=4 Offset=0
};

union ___unnamed1952 // Size=4
{
	unsigned long LongFlags1; // Size=4 Offset=0
	struct _MMVAD_FLAGS1 VadFlags1; // Size=4 Offset=0
};

union ___unnamed2047 // Size=4
{
	unsigned long LongFlags2; // Size=4 Offset=0
	union
	{
		struct _MMVAD_FLAGS2 VadFlags2; // Size=4 Offset=0 // PRE 19H1
		struct _MMVAD_FLAGS2_19H1 VadFlags219H1; // Size=4 Offset=0
	};
};

union ___unnamed2048 // Size=8
{
	struct _MI_VAD_SEQUENTIAL_INFO SequentialVa; // Size=8 Offset=0
	struct _MMEXTEND_INFO *ExtendedInfo; // Size=8 Offset=0
};

typedef struct _MM_PRIVATE_VAD_FLAGS
{
	/* 0x0000 */ unsigned long Lock : 1; /* bit position: 0 */
	/* 0x0000 */ unsigned long LockContended : 1; /* bit position: 1 */
	/* 0x0000 */ unsigned long DeleteInProgress : 1; /* bit position: 2 */
	/* 0x0000 */ unsigned long NoChange : 1; /* bit position: 3 */
	/* 0x0000 */ unsigned long VadType : 3; /* bit position: 4 */
	/* 0x0000 */ unsigned long Protection : 5; /* bit position: 7 */
	/* 0x0000 */ unsigned long PreferredNode : 6; /* bit position: 12 */
	/* 0x0000 */ unsigned long PageSize : 2; /* bit position: 18 */
	/* 0x0000 */ unsigned long PrivateMemoryAlwaysSet : 1; /* bit position: 20 */
	/* 0x0000 */ unsigned long WriteWatch : 1; /* bit position: 21 */
	/* 0x0000 */ unsigned long FixedLargePageSize : 1; /* bit position: 22 */
	/* 0x0000 */ unsigned long ZeroFillPagesOptional : 1; /* bit position: 23 */
	/* 0x0000 */ unsigned long Graphics : 1; /* bit position: 24 */
	/* 0x0000 */ unsigned long Enclave : 1; /* bit position: 25 */
	/* 0x0000 */ unsigned long ShadowStack : 1; /* bit position: 26 */
} MM_PRIVATE_VAD_FLAGS, *PMM_PRIVATE_VAD_FLAGS; /* size: 0x0004 */

typedef struct _MM_GRAPHICS_VAD_FLAGS
{
	/* 0x0000 */ unsigned long Lock : 1; /* bit position: 0 */
	/* 0x0000 */ unsigned long LockContended : 1; /* bit position: 1 */
	/* 0x0000 */ unsigned long DeleteInProgress : 1; /* bit position: 2 */
	/* 0x0000 */ unsigned long NoChange : 1; /* bit position: 3 */
	/* 0x0000 */ unsigned long VadType : 3; /* bit position: 4 */
	/* 0x0000 */ unsigned long Protection : 5; /* bit position: 7 */
	/* 0x0000 */ unsigned long PreferredNode : 6; /* bit position: 12 */
	/* 0x0000 */ unsigned long PageSize : 2; /* bit position: 18 */
	/* 0x0000 */ unsigned long PrivateMemoryAlwaysSet : 1; /* bit position: 20 */
	/* 0x0000 */ unsigned long WriteWatch : 1; /* bit position: 21 */
	/* 0x0000 */ unsigned long FixedLargePageSize : 1; /* bit position: 22 */
	/* 0x0000 */ unsigned long ZeroFillPagesOptional : 1; /* bit position: 23 */
	/* 0x0000 */ unsigned long GraphicsAlwaysSet : 1; /* bit position: 24 */
	/* 0x0000 */ unsigned long GraphicsUseCoherentBus : 1; /* bit position: 25 */
	/* 0x0000 */ unsigned long GraphicsPageProtection : 3; /* bit position: 26 */
} MM_GRAPHICS_VAD_FLAGS, *PMM_GRAPHICS_VAD_FLAGS; /* size: 0x0004 */

typedef struct _MM_SHARED_VAD_FLAGS
{
	/* 0x0000 */ unsigned long Lock : 1; /* bit position: 0 */
	/* 0x0000 */ unsigned long LockContended : 1; /* bit position: 1 */
	/* 0x0000 */ unsigned long DeleteInProgress : 1; /* bit position: 2 */
	/* 0x0000 */ unsigned long NoChange : 1; /* bit position: 3 */
	/* 0x0000 */ unsigned long VadType : 3; /* bit position: 4 */
	/* 0x0000 */ unsigned long Protection : 5; /* bit position: 7 */
	/* 0x0000 */ unsigned long PreferredNode : 6; /* bit position: 12 */
	/* 0x0000 */ unsigned long PageSize : 2; /* bit position: 18 */
	/* 0x0000 */ unsigned long PrivateMemoryAlwaysClear : 1; /* bit position: 20 */
	/* 0x0000 */ unsigned long PrivateFixup : 1; /* bit position: 21 */
	/* 0x0000 */ unsigned long HotPatchAllowed : 1; /* bit position: 22 */
} MM_SHARED_VAD_FLAGS, *PMM_SHARED_VAD_FLAGS; /* size: 0x0004 */

typedef struct _MMVAD_SHORT // Size=64 // PRE 19H1
{
	union
	{
		struct _RTL_BALANCED_NODE VadNode; // Size=24 Offset=0
		struct _MMVAD_SHORT *NextVad; // Size=8 Offset=0
	};
	unsigned long StartingVpn; // Size=4 Offset=24
	unsigned long EndingVpn; // Size=4 Offset=28
	unsigned char StartingVpnHigh; // Size=1 Offset=32
	unsigned char EndingVpnHigh; // Size=1 Offset=33
	unsigned char CommitChargeHigh; // Size=1 Offset=34
	unsigned char SpareNT64VadUChar; // Size=1 Offset=35
	long ReferenceCount; // Size=4 Offset=36
	union _EX_PUSH_LOCK PushLock; // Size=8 Offset=40
	union ___unnamed1951 u; // Size=4 Offset=48
	union ___unnamed1952 u1; // Size=4 Offset=52
	struct _MI_VAD_EVENT_BLOCK *EventList; // Size=8 Offset=56
} MMVAD_SHORT, *PMMVAD_SHORT;

typedef struct _MMVAD_SHORT_19H1
{
	union
	{
		struct
		{
			/* 0x0000 */ struct _MMVAD_SHORT_19H1* NextVad;
			/* 0x0008 */ void* ExtraCreateInfo;
		}; /* size: 0x0010 */
		/* 0x0000 */ _RTL_BALANCED_NODE VadNode;
	}; /* size: 0x0018 */
	/* 0x0018 */ unsigned long StartingVpn;
	/* 0x001c */ unsigned long EndingVpn;
	/* 0x0020 */ unsigned char StartingVpnHigh;
	/* 0x0021 */ unsigned char EndingVpnHigh;
	/* 0x0022 */ unsigned char CommitChargeHigh;
	/* 0x0023 */ unsigned char SpareNT64VadUChar;
	/* 0x0024 */ long ReferenceCount;
	/* 0x0028 */ _EX_PUSH_LOCK PushLock;
	union
	{
		union
		{
			/* 0x0030 */ unsigned long LongFlags;
			/* 0x0030 */ _MMVAD_FLAGS_19H1 VadFlags;
			/* 0x0030 */ _MM_PRIVATE_VAD_FLAGS PrivateVadFlags;
			/* 0x0030 */ _MM_GRAPHICS_VAD_FLAGS GraphicsVadFlags;
			/* 0x0030 */ _MM_SHARED_VAD_FLAGS SharedVadFlags;
			/* 0x0030 */ volatile unsigned long VolatileVadLong;
		}; /* size: 0x0004 */
	} /* size: 0x0004 */ u;
	union
	{
		union
		{
			/* 0x0034 */ unsigned long LongFlags1;
			/* 0x0034 */ struct _MMVAD_FLAGS1 VadFlags1;
		}; /* size: 0x0004 */
	} /* size: 0x0004 */ u1;
	/* 0x0038 */ struct _MI_VAD_EVENT_BLOCK* EventList;
} MMVAD_SHORT_19H1, *PMMVAD_SHORT_19H1; /* size: 0x0040 */

typedef struct _MMVAD // Size=128
{
	struct _MMVAD_SHORT Core; // Size=64 Offset=0
	union ___unnamed2047 u2; // Size=4 Offset=64
	unsigned long pad0; // Size=4 Offset=68
	struct _SUBSECTION *Subsection; // Size=8 Offset=72
	struct _MMPTE *FirstPrototypePte; // Size=8 Offset=80
	struct _MMPTE *LastContiguousPte; // Size=8 Offset=88
	struct _LIST_ENTRY ViewLinks; // Size=16 Offset=96
	struct _EPROCESS *VadsProcess; // Size=8 Offset=112
	union ___unnamed2048 u4; // Size=8 Offset=120
	struct _FILE_OBJECT *FileObject; // Size=8 Offset=128
} MMVAD, *PMMVAD;
#pragma pack(pop)

typedef struct _HANDLE_TABLE
{
	ULONG NextHandleNeedingPool;
	long ExtraInfoPages;
	LONG_PTR TableCode;
	PEPROCESS QuotaProcess;
	LIST_ENTRY HandleTableList;
	ULONG UniqueProcessId;
	ULONG Flags;
	EX_PUSH_LOCK HandleContentionEvent;
	EX_PUSH_LOCK HandleTableLock;
	// More fields here...
} HANDLE_TABLE, *PHANDLE_TABLE;

#pragma warning(default : 4214 4201)

#define GET_VAD_ROOT(Table) Table->BalancedRoot

```

`MMInject/Native/NativeStructs7.h`:

```h
#pragma once

//
// Native structures W7 x64 SP1
//
#pragma warning(disable : 4214 4201)

struct _MMVAD_FLAGS // Size=8
{
	unsigned __int64 CommitCharge : 51; // Size=8 Offset=0 BitOffset=0 BitCount=51
	unsigned __int64 NoChange : 1; // Size=8 Offset=0 BitOffset=51 BitCount=1
	unsigned __int64 VadType : 3; // Size=8 Offset=0 BitOffset=52 BitCount=3
	unsigned __int64 MemCommit : 1; // Size=8 Offset=0 BitOffset=55 BitCount=1
	unsigned __int64 Protection : 5; // Size=8 Offset=0 BitOffset=56 BitCount=5
	unsigned __int64 Spare : 2; // Size=8 Offset=0 BitOffset=61 BitCount=2
	unsigned __int64 PrivateMemory : 1; // Size=8 Offset=0 BitOffset=63 BitCount=1
};

struct _MMVAD_FLAGS3 // Size=8
{
	unsigned __int64 PreferredNode : 6; // Size=8 Offset=0 BitOffset=0 BitCount=6
	unsigned __int64 Teb : 1; // Size=8 Offset=0 BitOffset=6 BitCount=1
	unsigned __int64 Spare : 1; // Size=8 Offset=0 BitOffset=7 BitCount=1
	unsigned __int64 SequentialAccess : 1; // Size=8 Offset=0 BitOffset=8 BitCount=1
	unsigned __int64 LastSequentialTrim : 15; // Size=8 Offset=0 BitOffset=9 BitCount=15
	unsigned __int64 Spare2 : 8; // Size=8 Offset=0 BitOffset=24 BitCount=8
	unsigned __int64 LargePageCreating : 1; // Size=8 Offset=0 BitOffset=32 BitCount=1
	unsigned __int64 Spare3 : 31; // Size=8 Offset=0 BitOffset=33 BitCount=31
};

struct _MMVAD_FLAGS2 // Size=4
{
	unsigned int FileOffset : 24; // Size=4 Offset=0 BitOffset=0 BitCount=24
	unsigned int SecNoChange : 1; // Size=4 Offset=0 BitOffset=24 BitCount=1
	unsigned int OneSecured : 1; // Size=4 Offset=0 BitOffset=25 BitCount=1
	unsigned int MultipleSecured : 1; // Size=4 Offset=0 BitOffset=26 BitCount=1
	unsigned int Spare : 1; // Size=4 Offset=0 BitOffset=27 BitCount=1
	unsigned int LongVad : 1; // Size=4 Offset=0 BitOffset=28 BitCount=1
	unsigned int ExtendableFile : 1; // Size=4 Offset=0 BitOffset=29 BitCount=1
	unsigned int Inherit : 1; // Size=4 Offset=0 BitOffset=30 BitCount=1
	unsigned int CopyOnWrite : 1; // Size=4 Offset=0 BitOffset=31 BitCount=1
};

struct _MMSECURE_FLAGS // Size=4
{
	unsigned long ReadOnly : 1; // Size=4 Offset=0 BitOffset=0 BitCount=1
	unsigned long NoWrite : 1; // Size=4 Offset=0 BitOffset=1 BitCount=1
	unsigned long Spare : 10; // Size=4 Offset=0 BitOffset=2 BitCount=10
};

union ___unnamed710 // Size=8
{
	struct
	{
		__int64 Balance : 2; // Size=8 Offset=0 BitOffset=0 BitCount=2
	};
	struct _MMADDRESS_NODE *Parent; // Size=8 Offset=0
};

union ___unnamed712 // Size=8
{
	unsigned __int64 LongFlags; // Size=8 Offset=0
	struct _MMVAD_FLAGS VadFlags; // Size=8 Offset=0
};
union ___unnamed713 // Size=8
{
	unsigned __int64 LongFlags3; // Size=8 Offset=0
	struct _MMVAD_FLAGS3 VadFlags3; // Size=8 Offset=0
};

union ___unnamed715 // Size=4
{
	unsigned long LongFlags2; // Size=4 Offset=0
	struct _MMVAD_FLAGS2 VadFlags2; // Size=4 Offset=0
};

union ___unnamed1322 // Size=8
{
	struct _MMSECURE_FLAGS Flags; // Size=4 Offset=0
	void *StartVa; // Size=8 Offset=0
};

struct _MMADDRESS_LIST // Size=16
{
	union ___unnamed1322 u1; // Size=8 Offset=0
	void *EndVa; // Size=8 Offset=8
};

union ___unnamed1319 // Size=16
{
	struct _LIST_ENTRY List; // Size=16 Offset=0
	struct _MMADDRESS_LIST Secured; // Size=16 Offset=0
};

union ___unnamed1320 // Size=8
{
	struct _MMBANKED_SECTION *Banked; // Size=8 Offset=0
	struct _MMEXTEND_INFO *ExtendedInfo; // Size=8 Offset=0
};

typedef struct _MMADDRESS_NODE // Size=40
{
	union ___unnamed710 u1;
	struct _MMADDRESS_NODE *LeftChild; // Size=8 Offset=8
	struct _MMADDRESS_NODE *RightChild; // Size=8 Offset=16
	unsigned __int64 StartingVpn; // Size=8 Offset=24
	unsigned __int64 EndingVpn; // Size=8 Offset=32

} MMADDRESS_NODE, *PMMADDRESS_NODE, *PMM_AVL_NODE;

typedef struct _MM_AVL_TABLE // Size=64
{
	struct _MMADDRESS_NODE BalancedRoot; // Size=40 Offset=0
	struct
	{
		unsigned __int64 DepthOfTree : 5; // Size=8 Offset=40 BitOffset=0 BitCount=5
		unsigned __int64 Unused : 3; // Size=8 Offset=40 BitOffset=5 BitCount=3
		unsigned __int64 NumberGenericTableElements : 56; // Size=8 Offset=40 BitOffset=8 BitCount=56
	};
	void *NodeHint; // Size=8 Offset=48
	void *NodeFreeHint; // Size=8 Offset=56

} MM_AVL_TABLE, *PMM_AVL_TABLE;

typedef struct _MMVAD_SHORT // Size=64
{
	union ___unnamed710 u1; // Size=8 Offset=0
	struct _MMVAD *LeftChild; // Size=8 Offset=8
	struct _MMVAD *RightChild; // Size=8 Offset=16
	unsigned __int64 StartingVpn; // Size=8 Offset=24
	unsigned __int64 EndingVpn; // Size=8 Offset=32
	union ___unnamed712 u; // Size=8 Offset=40
	void *PushLock; // Size=8 Offset=48
	union ___unnamed713 u5; // Size=8 Offset=56
} MMVAD_SHORT, *PMMVAD_SHORT;

typedef struct _MMVAD // Size=120
{
	MMVAD_SHORT vadShort;
	union ___unnamed715 u2; // Size=4 Offset=64
	unsigned long pad0; // Size=4 Offset=68
	struct _SUBSECTION *Subsection; // Size=8 Offset=72
	struct _MMPTE *FirstPrototypePte; // Size=8 Offset=80
	struct _MMPTE *LastContiguousPte; // Size=8 Offset=88
	struct _LIST_ENTRY ViewLinks; // Size=16 Offset=96
	struct _EPROCESS *VadsProcess; // Size=8 Offset=112
} MMVAD, *PMMVAD;

typedef struct _MMVAD_LONG // Size=144
{
	MMVAD vad;
	union ___unnamed1319 u3; // Size=16 Offset=120
	union ___unnamed1320 u4; // Size=8 Offset=136
} MMVAD_LONG, *PMMVAD_LONG;

typedef struct _POOL_HEADER // Size=16
{
	union
	{
		struct
		{
			unsigned long PreviousSize : 8; // Size=4 Offset=0 BitOffset=0 BitCount=8
			unsigned long PoolIndex : 8; // Size=4 Offset=0 BitOffset=8 BitCount=8
			unsigned long BlockSize : 8; // Size=4 Offset=0 BitOffset=16 BitCount=8
			unsigned long PoolType : 8; // Size=4 Offset=0 BitOffset=24 BitCount=8
		};
		unsigned long Ulong1; // Size=4 Offset=0
	};
	unsigned long PoolTag; // Size=4 Offset=4
	union
	{
		struct _EPROCESS *ProcessBilled; // Size=8 Offset=8
		struct
		{
			unsigned short AllocatorBackTraceIndex; // Size=2 Offset=8
			unsigned short PoolTagHash; // Size=2 Offset=10
		};
	};
} POOL_HEADER, *PPOOL_HEADER;

typedef struct _HANDLE_TABLE
{
	ULONG_PTR TableCode;
	struct _EPROCESS *QuotaProcess;
	HANDLE UniqueProcessId;
	void *HandleLock;
	struct _LIST_ENTRY HandleTableList;
	EX_PUSH_LOCK HandleContentionEvent;
	struct _HANDLE_TRACE_DEBUG_INFO *DebugInfo;
	int ExtraInfoPages;
	ULONG Flags;
	ULONG FirstFreeHandle;
	struct _HANDLE_TABLE_ENTRY *LastFreeHandleEntry;
	ULONG HandleCount;
	ULONG NextHandleNeedingPool;
	// More fields here...
} HANDLE_TABLE, *PHANDLE_TABLE;

#pragma warning(default : 4214 4201)

#define GET_VAD_ROOT(Table) &Table->BalancedRoot
```

`MMInject/Native/NativeStructs81.h`:

```h
#pragma once

//
// Native structures W8.1 x64
//
#pragma warning(disable : 4214 4201)
#pragma pack(push, 1)

typedef struct _MM_AVL_NODE // Size=24
{
	struct _MM_AVL_NODE *LeftChild; // Size=8 Offset=0
	struct _MM_AVL_NODE *RightChild; // Size=8 Offset=8

	union ___unnamed1666 // Size=8
	{
		struct
		{
			__int64 Balance : 2; // Size=8 Offset=0 BitOffset=0 BitCount=2
		};
		struct _MM_AVL_NODE *Parent; // Size=8 Offset=0
	} u1;
} MM_AVL_NODE, *PMM_AVL_NODE, *PMMADDRESS_NODE;

typedef struct _RTL_AVL_TREE // Size=8
{
	PMM_AVL_NODE BalancedRoot; // Size=8 Offset=0
	void *NodeHint; // Size=8 Offset=1504
	unsigned __int64 NumberGenericTableElements; // Size=8 Offset=1512
} RTL_AVL_TREE, *PRTL_AVL_TREE, *PMM_AVL_TABLE;

union _EX_PUSH_LOCK // Size=8
{
	struct
	{
		unsigned __int64 Locked : 1; // Size=8 Offset=0 BitOffset=0 BitCount=1
		unsigned __int64 Waiting : 1; // Size=8 Offset=0 BitOffset=1 BitCount=1
		unsigned __int64 Waking : 1; // Size=8 Offset=0 BitOffset=2 BitCount=1
		unsigned __int64 MultipleShared : 1; // Size=8 Offset=0 BitOffset=3 BitCount=1
		unsigned __int64 Shared : 60; // Size=8 Offset=0 BitOffset=4 BitCount=60
	};
	unsigned __int64 Value; // Size=8 Offset=0
	void *Ptr; // Size=8 Offset=0
};

struct _MMVAD_FLAGS // Size=4
{
	unsigned long VadType : 3; // Size=4 Offset=0 BitOffset=0 BitCount=3
	unsigned long Protection : 5; // Size=4 Offset=0 BitOffset=3 BitCount=5
	unsigned long PreferredNode : 6; // Size=4 Offset=0 BitOffset=8 BitCount=6
	unsigned long NoChange : 1; // Size=4 Offset=0 BitOffset=14 BitCount=1
	unsigned long PrivateMemory : 1; // Size=4 Offset=0 BitOffset=15 BitCount=1
	unsigned long Teb : 1; // Size=4 Offset=0 BitOffset=16 BitCount=1
	unsigned long PrivateFixup : 1; // Size=4 Offset=0 BitOffset=17 BitCount=1
	unsigned long Spare : 13; // Size=4 Offset=0 BitOffset=18 BitCount=13
	unsigned long DeleteInProgress : 1; // Size=4 Offset=0 BitOffset=31 BitCount=1
};
struct _MMVAD_FLAGS1 // Size=4
{
	unsigned long CommitCharge : 31; // Size=4 Offset=0 BitOffset=0 BitCount=31
	unsigned long MemCommit : 1; // Size=4 Offset=0 BitOffset=31 BitCount=1
};

struct _MMVAD_FLAGS2 // Size=4
{
	unsigned long FileOffset : 24; // Size=4 Offset=0 BitOffset=0 BitCount=24
	unsigned long Large : 1; // Size=4 Offset=0 BitOffset=24 BitCount=1
	unsigned long TrimBehind : 1; // Size=4 Offset=0 BitOffset=25 BitCount=1
	unsigned long Inherit : 1; // Size=4 Offset=0 BitOffset=26 BitCount=1
	unsigned long CopyOnWrite : 1; // Size=4 Offset=0 BitOffset=27 BitCount=1
	unsigned long NoValidationNeeded : 1; // Size=4 Offset=0 BitOffset=28 BitCount=1
	unsigned long Spare : 3; // Size=4 Offset=0 BitOffset=29 BitCount=3
};

struct _MI_VAD_SEQUENTIAL_INFO // Size=8
{
	unsigned __int64 Length : 12; // Size=8 Offset=0 BitOffset=0 BitCount=12
	unsigned __int64 Vpn : 52; // Size=8 Offset=0 BitOffset=12 BitCount=52
};

union ___unnamed1859 // Size=4
{
	unsigned long LongFlags; // Size=4 Offset=0
	struct _MMVAD_FLAGS VadFlags; // Size=4 Offset=0
};
union ___unnamed1860 // Size=4
{
	unsigned long LongFlags1; // Size=4 Offset=0
	struct _MMVAD_FLAGS1 VadFlags1; // Size=4 Offset=0
};

union ___unnamed1956 // Size=4
{
	unsigned long LongFlags2; // Size=4 Offset=0
	struct _MMVAD_FLAGS2 VadFlags2; // Size=4 Offset=0
};

union ___unnamed1957 // Size=8
{
	struct _MI_VAD_SEQUENTIAL_INFO SequentialVa; // Size=8 Offset=0
	struct _MMEXTEND_INFO *ExtendedInfo; // Size=8 Offset=0
};

typedef struct _MMVAD_SHORT // Size=64
{
	union
	{
		struct _MM_AVL_NODE VadNode; // Size=24 Offset=0
		struct _MMVAD_SHORT *NextVad; // Size=8 Offset=0
	};
	unsigned long StartingVpn; // Size=4 Offset=24
	unsigned long EndingVpn; // Size=4 Offset=28
	unsigned char StartingVpnHigh; // Size=1 Offset=32
	unsigned char EndingVpnHigh; // Size=1 Offset=33
	unsigned char CommitChargeHigh; // Size=1 Offset=34
	unsigned char LargeImageBias; // Size=1 Offset=35
	long ReferenceCount; // Size=4 Offset=36
	union _EX_PUSH_LOCK PushLock; // Size=8 Offset=40
	union ___unnamed1859 u; // Size=4 Offset=48
	union ___unnamed1860 u1; // Size=4 Offset=52
	struct _MI_VAD_EVENT_BLOCK *EventList; // Size=8 Offset=56
} MMVAD_SHORT, *PMMVAD_SHORT;

typedef struct _MMVAD // Size=128
{
	struct _MMVAD_SHORT Core; // Size=64 Offset=0
	union ___unnamed1956 u2; // Size=4 Offset=64
	unsigned long pad0; // Size=4 Offset=68
	struct _SUBSECTION *Subsection; // Size=8 Offset=72
	struct _MMPTE *FirstPrototypePte; // Size=8 Offset=80
	struct _MMPTE *LastContiguousPte; // Size=8 Offset=88
	struct _LIST_ENTRY ViewLinks; // Size=16 Offset=96
	struct _EPROCESS *VadsProcess; // Size=8 Offset=112
	union ___unnamed1957 u4; // Size=8 Offset=120
} MMVAD, *PMMVAD;

typedef struct _POOL_HEADER // Size=16
{
	union
	{
		struct
		{
			unsigned short PreviousSize : 8; // Size=2 Offset=0 BitOffset=0 BitCount=8
			unsigned short PoolIndex : 8; // Size=2 Offset=0 BitOffset=8 BitCount=8
		};
		unsigned long Ulong1; // Size=4 Offset=0
	};
	struct
	{
		unsigned short BlockSize : 8; // Size=2 Offset=2 BitOffset=0 BitCount=8
		unsigned short PoolType : 8; // Size=2 Offset=2 BitOffset=8 BitCount=8
	};
	unsigned long PoolTag; // Size=4 Offset=4
	union
	{
		struct _EPROCESS *ProcessBilled; // Size=8 Offset=8
		struct
		{
			unsigned short AllocatorBackTraceIndex; // Size=2 Offset=8
			unsigned short PoolTagHash; // Size=2 Offset=10
		};
	};
} POOL_HEADER, *PPOOL_HEADER;
#pragma pack(pop)

typedef struct _HANDLE_TABLE
{
	ULONG NextHandleNeedingPool;
	long ExtraInfoPages;
	LONG_PTR TableCode;
	struct _EPROCESS *QuotaProcess;
	LIST_ENTRY HandleTableList;
	ULONG UniqueProcessId;
	ULONG Flags;
	EX_PUSH_LOCK HandleContentionEvent;
	EX_PUSH_LOCK HandleTableLock;
	// More fields here...
} HANDLE_TABLE, *PHANDLE_TABLE;

#pragma warning(default : 4214 4201)

#define GET_VAD_ROOT(Table) Table->BalancedRoot
```

`MMInject/PE.c`:

```c
#include "MMInject.h"
#include "vad.h"
#include "Utils.h"
#include "BlackBone/Loader.h"

#define IGNORE_IMPORT_HOOKS			0

#define LDR_IS_DATAFILE(x)			(((ULONG_PTR)(x)) & (ULONG_PTR)1)
#define LDR_DATAFILE_TO_VIEW(x)		((PVOID)(((ULONG_PTR)(x)) & ~(ULONG_PTR)1))

extern "C"
FORCEINLINE
PIMAGE_BASE_RELOCATION
LdrProcessRelocationBlock(
	_In_ ULONG_PTR VA,
	_In_ ULONG SizeOfBlock,
	_In_ PUSHORT NextOffset,
	_In_ LONGLONG Delta
	);

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, LdrRelocateImageData)
#pragma alloc_text(PAGE, LdrProcessRelocationBlock)
#pragma alloc_text(PAGE, PatchGuardCFCheckFunctionPointers)
#pragma alloc_text(PAGE, InitializeStackCookie)
#pragma alloc_text(PAGE, ResolveImports)
#pragma alloc_text(PAGE, WipeImageSections)
#endif

extern DYNAMIC_DATA DynData;
extern t_NtProtectVirtualMemory NtProtectVirtualMemory;

PIMAGE_NT_HEADERS
NTAPI
RtlpImageNtHeaderEx(
	_In_ PVOID Base,
	_In_opt_ SIZE_T Size
	)
{
	const BOOLEAN RangeCheck = Size > 0;
	constexpr ULONG SizeOfPeSignature = 4;

	if (RangeCheck && Size < sizeof(IMAGE_DOS_HEADER))
		return nullptr;
	if (static_cast<PIMAGE_DOS_HEADER>(Base)->e_magic != IMAGE_DOS_SIGNATURE)
		return nullptr;

	const ULONG e_lfanew = static_cast<PIMAGE_DOS_HEADER>(Base)->e_lfanew;
	if (RangeCheck &&
		(e_lfanew >= Size ||
		e_lfanew >= (MAXULONG - SizeOfPeSignature - sizeof(IMAGE_FILE_HEADER)) ||
		e_lfanew + SizeOfPeSignature + sizeof(IMAGE_FILE_HEADER) >= Size))
	{
		return nullptr;
	}

	const PIMAGE_NT_HEADERS NtHeaders = reinterpret_cast<PIMAGE_NT_HEADERS>(static_cast<PCHAR>(Base) + e_lfanew);

	if (!RtlIsCanonicalAddress(reinterpret_cast<ULONG_PTR>(NtHeaders)))
		return nullptr;

#if (defined(_KERNEL_MODE) && (_KERNEL_MODE))
	if (reinterpret_cast<ULONG_PTR>(Base) < reinterpret_cast<ULONG_PTR>(MM_HIGHEST_USER_ADDRESS))
	{
		if (reinterpret_cast<ULONG_PTR>(NtHeaders) >= reinterpret_cast<ULONG_PTR>(MM_HIGHEST_USER_ADDRESS))
			return nullptr;

		if (reinterpret_cast<ULONG_PTR>(reinterpret_cast<PCHAR>(NtHeaders) + sizeof(IMAGE_NT_HEADERS)) >=
			reinterpret_cast<ULONG_PTR>(MM_HIGHEST_USER_ADDRESS))
			return nullptr;
	}
#endif

	if (NtHeaders->Signature != IMAGE_NT_SIGNATURE)
		return nullptr;

	return NtHeaders;
}

PVOID
GetProcedureAddress(
	_In_ ULONG_PTR DllBase,
	_In_ PCSTR RoutineName
	)
{
	const PIMAGE_DOS_HEADER DosHeader = reinterpret_cast<PIMAGE_DOS_HEADER>(DllBase);
	if (DosHeader->e_magic != IMAGE_DOS_SIGNATURE)
		return nullptr;
	const PIMAGE_NT_HEADERS NtHeaders = reinterpret_cast<PIMAGE_NT_HEADERS>(DllBase + DosHeader->e_lfanew);
	if (NtHeaders->Signature != IMAGE_NT_SIGNATURE)
		return nullptr;

	PIMAGE_DATA_DIRECTORY ImageDirectories;
	if (NtHeaders->OptionalHeader.Magic == IMAGE_NT_OPTIONAL_HDR64_MAGIC)
		ImageDirectories = reinterpret_cast<PIMAGE_NT_HEADERS64>(NtHeaders)->OptionalHeader.DataDirectory;
	else
		ImageDirectories = reinterpret_cast<PIMAGE_NT_HEADERS32>(NtHeaders)->OptionalHeader.DataDirectory;

	const ULONG ExportDirRva = ImageDirectories[IMAGE_DIRECTORY_ENTRY_EXPORT].VirtualAddress;
	const ULONG ExportDirSize = ImageDirectories[IMAGE_DIRECTORY_ENTRY_EXPORT].Size;

	const PIMAGE_EXPORT_DIRECTORY ExportDirectory = reinterpret_cast<PIMAGE_EXPORT_DIRECTORY>(DllBase + ExportDirRva);
	const PULONG AddressOfFunctions = reinterpret_cast<PULONG>(DllBase + ExportDirectory->AddressOfFunctions);
	const PUSHORT AddressOfNameOrdinals = reinterpret_cast<PUSHORT>(DllBase + ExportDirectory->AddressOfNameOrdinals);
	const PULONG AddressOfNames = reinterpret_cast<PULONG>(DllBase + ExportDirectory->AddressOfNames);

	LONG Low = 0;
	LONG Middle = 0;
	LONG High = ExportDirectory->NumberOfNames - 1;

	while (High >= Low)
	{
		Middle = (Low + High) >> 1;
		const LONG Result = strcmp(RoutineName, reinterpret_cast<PCHAR>(DllBase + AddressOfNames[Middle]));
		if (Result < 0)
			High = Middle - 1;
		else if (Result > 0)
			Low = Middle + 1;
		else
			break;
	}

	if (High < Low || Middle >= static_cast<LONG>(ExportDirectory->NumberOfFunctions))
		return nullptr;
	const ULONG FunctionRva = AddressOfFunctions[AddressOfNameOrdinals[Middle]];
	if (FunctionRva >= ExportDirRva && FunctionRva < ExportDirRva + ExportDirSize)
		return nullptr;

	return reinterpret_cast<PVOID>(DllBase + FunctionRva);
}

PVOID
GetFileDataProcedureAddress(
	_In_ ULONG_PTR FileData,
	_In_ PCSTR RoutineName
	)
{
	const PIMAGE_DOS_HEADER DosHeader = reinterpret_cast<PIMAGE_DOS_HEADER>(FileData);
	if (DosHeader->e_magic != IMAGE_DOS_SIGNATURE)
		return nullptr;
	const PIMAGE_NT_HEADERS NtHeaders = reinterpret_cast<PIMAGE_NT_HEADERS>(FileData + DosHeader->e_lfanew);
	if (NtHeaders->Signature != IMAGE_NT_SIGNATURE)
		return nullptr;

	PIMAGE_DATA_DIRECTORY ImageDirectories;
	if (NtHeaders->OptionalHeader.Magic == IMAGE_NT_OPTIONAL_HDR64_MAGIC)
		ImageDirectories = reinterpret_cast<PIMAGE_NT_HEADERS64>(NtHeaders)->OptionalHeader.DataDirectory;
	else
		ImageDirectories = reinterpret_cast<PIMAGE_NT_HEADERS32>(NtHeaders)->OptionalHeader.DataDirectory;

	const ULONG ExportDirRva = ImageDirectories[IMAGE_DIRECTORY_ENTRY_EXPORT].VirtualAddress;
	const ULONG ExportDirSize = ImageDirectories[IMAGE_DIRECTORY_ENTRY_EXPORT].Size;
	const ULONG ExportDirOffset = RvaToOffset(NtHeaders, ExportDirRva);
	if (ExportDirOffset == 0)
		return nullptr;

	const PIMAGE_EXPORT_DIRECTORY ExportDirectory = reinterpret_cast<PIMAGE_EXPORT_DIRECTORY>(FileData + ExportDirOffset);
	const ULONG AddressOfFunctionsOffset = RvaToOffset(NtHeaders, ExportDirectory->AddressOfFunctions);
	const ULONG AddressOfNameOrdinalsOffset = RvaToOffset(NtHeaders, ExportDirectory->AddressOfNameOrdinals);
	const ULONG AddressOfNamesOffset = RvaToOffset(NtHeaders, ExportDirectory->AddressOfNames);
	if (AddressOfFunctionsOffset == 0 || AddressOfNameOrdinalsOffset == 0 || AddressOfNamesOffset == 0)
		return nullptr;

	const PULONG AddressOfFunctions = reinterpret_cast<PULONG>(FileData + AddressOfFunctionsOffset);
	const PUSHORT AddressOfNameOrdinals = reinterpret_cast<PUSHORT>(FileData + AddressOfNameOrdinalsOffset);
	const PULONG AddressOfNames = reinterpret_cast<PULONG>(FileData + AddressOfNamesOffset);

	for (ULONG i = 0; i < ExportDirectory->NumberOfNames; ++i)
	{
		const ULONG NameOffset = RvaToOffset(NtHeaders, AddressOfNames[i]);
		if (NameOffset == 0)
			continue;

		const PCSTR FunctionName = reinterpret_cast<PSTR>(FileData + NameOffset);
		const ULONG FunctionRva = AddressOfFunctions[AddressOfNameOrdinals[i]];
		if (FunctionRva >= ExportDirRva && FunctionRva < ExportDirRva + ExportDirSize)
			continue;

		if (strcmp(FunctionName, RoutineName) == 0)
		{
			const ULONG ExportOffset = RvaToOffset(NtHeaders, FunctionRva);
			return ExportOffset != 0 ? reinterpret_cast<PVOID>(FileData + ExportOffset) : nullptr;
		}
	}

	return nullptr;
}

ULONG
RvaToOffset(
	_In_ PIMAGE_NT_HEADERS NtHeaders,
	_In_ ULONG Rva
	)
{
	PIMAGE_SECTION_HEADER SectionHeaders = IMAGE_FIRST_SECTION(NtHeaders);
	const USHORT NumberOfSections = NtHeaders->FileHeader.NumberOfSections;
	ULONG Result = 0;
	for (USHORT i = 0; i < NumberOfSections; ++i)
	{
		if (SectionHeaders->VirtualAddress <= Rva &&
			SectionHeaders->VirtualAddress + SectionHeaders->Misc.VirtualSize > Rva)
		{
			Result = Rva - SectionHeaders->VirtualAddress +
							SectionHeaders->PointerToRawData;
			break;
		}
		SectionHeaders++;
	}
	return Result;
}

PVOID
NTAPI
RtlpImageDirectoryEntryToDataEx(
	_In_ PVOID Base,
	_In_ BOOLEAN MappedAsImage,
	_In_ USHORT DirectoryEntry,
	_Out_ PULONG Size
	)
{
	if (LDR_IS_DATAFILE(Base))
	{
		Base = LDR_DATAFILE_TO_VIEW(Base);
		MappedAsImage = FALSE;
	}

	const PIMAGE_NT_HEADERS NtHeaders = RtlpImageNtHeaderEx(Base, 0);
	if (NtHeaders == nullptr)
		return nullptr;

	if (DirectoryEntry >= HEADER_FIELD(NtHeaders, NumberOfRvaAndSizes))
		return nullptr;

	const PIMAGE_DATA_DIRECTORY Directories = HEADER_FIELD(NtHeaders, DataDirectory);
	const ULONG Rva = Directories[DirectoryEntry].VirtualAddress;
	if (Rva == 0)
		return nullptr;

	if (reinterpret_cast<ULONG_PTR>(Base) < reinterpret_cast<ULONG_PTR>(MM_HIGHEST_USER_ADDRESS) &&
		reinterpret_cast<ULONG_PTR>(static_cast<PCHAR>(Base) + Rva) >= reinterpret_cast<ULONG_PTR>(MM_HIGHEST_USER_ADDRESS))
	{
		return nullptr;
	}

	*Size = Directories[DirectoryEntry].Size;
	if (MappedAsImage || Rva < HEADER_FIELD(NtHeaders, SizeOfHeaders))
	{
		return static_cast<PVOID>(static_cast<PCHAR>(Base) + Rva);
	}

	return static_cast<PVOID>(static_cast<PCHAR>(Base) + RvaToOffset(NtHeaders, Rva));
}

CONSTEXPR
ULONG
CharacteristicsToPageProtection(
	_In_ ULONG SectionCharacteristics
	)
{
	if ((SectionCharacteristics & IMAGE_SCN_MEM_WRITE) != 0)
	{
		return ((SectionCharacteristics & IMAGE_SCN_MEM_EXECUTE) != 0)
			? PAGE_EXECUTE_READWRITE
			: PAGE_READWRITE;
	}
	if ((SectionCharacteristics & IMAGE_SCN_MEM_EXECUTE) != 0)
	{
		return ((SectionCharacteristics & IMAGE_SCN_MEM_READ) != 0)
			? PAGE_EXECUTE_READ
			: PAGE_EXECUTE;
	}
	return ((SectionCharacteristics & IMAGE_SCN_MEM_READ) != 0)
			? PAGE_READONLY
			: PAGE_NOACCESS;
}

CONSTEXPR
BOOLEAN
IsVadProtectionChangeAllowed(
	_In_ PMMVAD_SHORT VadShort
	)
{
	if (VadShort->u.VadFlags.NoChange == 1UL)
		return FALSE;
	return VadShort->u.VadFlags.VadType == static_cast<ULONG>(VadNone) ||
		VadShort->u.VadFlags.VadType == static_cast<ULONG>(VadImageMap) ||
		VadShort->u.VadFlags.VadType == static_cast<ULONG>(VadAwe) ||
		VadShort->u.VadFlags.VadType == static_cast<ULONG>(VadRotatePhysical);
}

#if NTDDI_VERSION >= NTDDI_WIN10

CONSTEXPR
BOOLEAN
IsVadProtectionChangeAllowed19H1(
	_In_ PMMVAD_SHORT_19H1 VadShort
	)
{
	if (VadShort->u.VadFlags.NoChange == 1UL)
		return FALSE;
	return VadShort->u.VadFlags.VadType == static_cast<ULONG>(VadNone) ||
		VadShort->u.VadFlags.VadType == static_cast<ULONG>(VadImageMap) ||
		VadShort->u.VadFlags.VadType == static_cast<ULONG>(VadAwe) ||
		VadShort->u.VadFlags.VadType == static_cast<ULONG>(VadRotatePhysical);
}

#endif

FORCEINLINE
PIMAGE_BASE_RELOCATION
LdrProcessRelocationBlock(
	_In_ ULONG_PTR VA,
	_In_ ULONG SizeOfBlock,
	_In_ PUSHORT NextOffset,
	_In_ LONGLONG Delta
	)
{
	PAGED_CODE();

	LONG Temp;

	while (SizeOfBlock--)
	{
		const USHORT Offset = *NextOffset & static_cast<USHORT>(0xfff);
		const PUCHAR FixupVA = reinterpret_cast<PUCHAR>(VA + Offset);

		switch ((*NextOffset) >> 12)
		{
			case IMAGE_REL_BASED_HIGHLOW:

				*reinterpret_cast<LONG UNALIGNED *>(FixupVA) += static_cast<ULONG>(Delta);
				break;

			case IMAGE_REL_BASED_HIGH:
				Temp = *reinterpret_cast<PUSHORT>(FixupVA) << 16;
				Temp += static_cast<ULONG>(Delta);
				*reinterpret_cast<PUSHORT>(FixupVA) = static_cast<USHORT>(Temp >> 16);
				break;

			case IMAGE_REL_BASED_HIGHADJ:
				if (Offset & /*LDRP_RELOCATION_FINAL*/ 0x2)
				{
					++NextOffset;
					--SizeOfBlock;
					break;
				}

				Temp = *reinterpret_cast<PUSHORT>(FixupVA) << 16;
				++NextOffset;
				--SizeOfBlock;
				Temp += static_cast<LONG>(*reinterpret_cast<PSHORT>(NextOffset));
				Temp += static_cast<ULONG>(Delta);
				Temp += 0x8000;
				*reinterpret_cast<PUSHORT>(FixupVA) = static_cast<USHORT>(Temp >> 16);

				break;

			case IMAGE_REL_BASED_LOW:
				Temp = *reinterpret_cast<PSHORT>(FixupVA);
				Temp += static_cast<ULONG>(Delta);
				*reinterpret_cast<PUSHORT>(FixupVA) = static_cast<USHORT>(Temp);
				break;

			case IMAGE_REL_BASED_DIR64:
				*reinterpret_cast<ULONGLONG UNALIGNED*>(FixupVA) += Delta;
				break;

			case IMAGE_REL_BASED_ABSOLUTE:
				break;

			default:
				return nullptr;
		}
		++NextOffset;
	}

	return reinterpret_cast<PIMAGE_BASE_RELOCATION>(NextOffset);
}

NTSTATUS
LdrRelocateImageData(
	_In_ PVOID FileData,
	_In_ PVOID NewBase
	)
{
	PAGED_CODE();

	const PIMAGE_NT_HEADERS NtHeaders = RtlpImageNtHeaderEx(FileData, 0);
	const ULONG_PTR OldBase = static_cast<ULONG_PTR>(HEADER_FIELD(NtHeaders, ImageBase));

	ULONG NumBytes = 0;
	PIMAGE_BASE_RELOCATION NextBlock = static_cast<PIMAGE_BASE_RELOCATION>(
		RtlpImageDirectoryEntryToDataEx(FileData,
										FALSE,
										IMAGE_DIRECTORY_ENTRY_BASERELOC,
										&NumBytes));

	if (NextBlock == nullptr || NumBytes == 0)
	{
		return (NtHeaders->FileHeader.Characteristics & IMAGE_FILE_RELOCS_STRIPPED)
			? STATUS_CONFLICTING_ADDRESSES
			: STATUS_SUCCESS;
	}
	if (!(HEADER_FIELD(NtHeaders, DllCharacteristics) & IMAGE_DLLCHARACTERISTICS_DYNAMIC_BASE))
	{
		Printf("Warning: force relocating an image without IMAGE_DLLCHARACTERISTICS_DYNAMIC_BASE but which does contain relocation data!\n");
		Printf("Either recompile with /DYNAMICBASE:YES, or (if this is intended) remove the relocation directory.\n");
	}

	const LONG_PTR Delta = reinterpret_cast<ULONG_PTR>(NewBase) - OldBase;

	while (NumBytes > 0)
	{
		ULONG SizeOfBlock = NextBlock->SizeOfBlock;
		if (SizeOfBlock == 0)
			return STATUS_INVALID_IMAGE_FORMAT;

		NumBytes -= SizeOfBlock;
		SizeOfBlock -= sizeof(IMAGE_BASE_RELOCATION);
		SizeOfBlock /= sizeof(USHORT);
		const PUSHORT NextOffset = reinterpret_cast<PUSHORT>(reinterpret_cast<PCHAR>(NextBlock) +
														sizeof(IMAGE_BASE_RELOCATION));

		const ULONG_PTR Offset = RvaToOffset(NtHeaders, NextBlock->VirtualAddress);
		const ULONG_PTR Address = reinterpret_cast<ULONG_PTR>(FileData) + Offset;

		NextBlock = LdrProcessRelocationBlock(Address,
											SizeOfBlock,
											NextOffset,
											Delta);
		if (NextBlock == nullptr)
			return STATUS_INVALID_IMAGE_FORMAT;
	}
	return STATUS_SUCCESS;
}

NTSTATUS
PatchGuardCFCheckFunctionPointers(
	_In_ PEPROCESS Process
	)
{
	PAGED_CODE();

	CONST PPEB Peb = PsGetProcessPeb(Process);
#ifdef _M_AMD64
	const PPEB32 Peb32 = static_cast<PPEB32>(PsGetProcessWow64Process(Process));
	const BOOLEAN IsWow64 = Peb32 != nullptr;
#else
	constexpr const PPEB32 Peb32 = nullptr;
	constexpr const BOOLEAN IsWow64 = FALSE;
#endif
	if (Peb == nullptr)
		return STATUS_NOT_FOUND;

	KAPC_STATE ApcState;
	KeStackAttachProcess(Process, &ApcState);

	CONST PIMAGE_NT_HEADERS NtHeaders = IsWow64
		? RtlpImageNtHeaderEx(reinterpret_cast<PVOID>(Peb32->ImageBaseAddress), 0)
		: RtlpImageNtHeaderEx(Peb->ImageBaseAddress, 0);
	NTSTATUS Status;
	if (NtHeaders == nullptr || HEADER_FIELD(NtHeaders, NumberOfRvaAndSizes) < IMAGE_DIRECTORY_ENTRY_LOAD_CONFIG)
	{
		Status = STATUS_NOT_FOUND;
		goto finished;
	}

	ULONG Size = 0;
	CONST PIMAGE_LOAD_CONFIG_DIRECTORY32 LoadConfigDirectory32 = static_cast<PIMAGE_LOAD_CONFIG_DIRECTORY32>(
		RtlpImageDirectoryEntryToDataEx(Peb->ImageBaseAddress,
										TRUE,
										IMAGE_DIRECTORY_ENTRY_LOAD_CONFIG,
										&Size));
	const PIMAGE_LOAD_CONFIG_DIRECTORY64 LoadConfigDirectory64 = reinterpret_cast<PIMAGE_LOAD_CONFIG_DIRECTORY64>(LoadConfigDirectory32);

	if (LoadConfigDirectory32 == nullptr ||
		(IMAGE32(NtHeaders) && (LoadConfigDirectory32->Size < FIELD_OFFSET(IMAGE_LOAD_CONFIG_DIRECTORY32, GuardCFCheckFunctionPointer) ||
			LoadConfigDirectory32->GuardCFCheckFunctionPointer == 0)) ||
		(IMAGE64(NtHeaders) && (LoadConfigDirectory64->Size < FIELD_OFFSET(IMAGE_LOAD_CONFIG_DIRECTORY64, GuardCFCheckFunctionPointer) ||
			LoadConfigDirectory64->GuardCFCheckFunctionPointer == 0))
		)
	{
		Status = STATUS_NOT_FOUND;
		goto finished;
	}

	PVOID LdrpValidateUserCallTarget, LdrpDispatchUserCallTarget = nullptr;
	__try
	{
		if (IsWow64)
		{
			const PULONG GuardCFCheckFunctionPointer = reinterpret_cast<PULONG>(LoadConfigDirectory32->GuardCFCheckFunctionPointer);
			LdrpValidateUserCallTarget = GuardCFCheckFunctionPointer != nullptr ? reinterpret_cast<PVOID>(static_cast<ULONG_PTR>(*GuardCFCheckFunctionPointer)) : nullptr;
			Printf("\tGuardCFCheckFunctionPointer: 0x%04X -> 0x%04X\n",
				static_cast<ULONG>(reinterpret_cast<ULONG_PTR>(GuardCFCheckFunctionPointer)), static_cast<ULONG>(reinterpret_cast<ULONG_PTR>(LdrpValidateUserCallTarget)));
		}
		else
		{
			const PVOID* GuardCFCheckFunctionPointer = reinterpret_cast<PVOID*>(LoadConfigDirectory64->GuardCFCheckFunctionPointer);
			LdrpValidateUserCallTarget = GuardCFCheckFunctionPointer != nullptr ? *GuardCFCheckFunctionPointer : nullptr;
			Printf("\tGuardCFCheckFunctionPointer: 0x%p -> 0x%p\n",
				GuardCFCheckFunctionPointer, LdrpValidateUserCallTarget);
		}

#ifdef _M_AMD64
		if (!IsWow64)
		{
			PVOID* GuardCFDispatchFunctionPointer = reinterpret_cast<PVOID*>(LoadConfigDirectory64->GuardCFDispatchFunctionPointer);
			LdrpDispatchUserCallTarget = GuardCFDispatchFunctionPointer != nullptr ? *GuardCFDispatchFunctionPointer : nullptr;
			Printf("\tGuardCFDispatchFunctionPointer: 0x%p -> 0x%p\n",
				GuardCFDispatchFunctionPointer, LdrpDispatchUserCallTarget);
		}
#endif
	}
	__except (EXCEPTION_EXECUTE_HANDLER)
	{
		Status = GetExceptionCode();
		goto finished;
	}

	if (LdrpValidateUserCallTarget == nullptr && LdrpDispatchUserCallTarget == nullptr)
	{
		Status = STATUS_SUCCESS;
		goto finished;
	}

	PVOID TargetPage = LdrpValidateUserCallTarget != nullptr ? LdrpValidateUserCallTarget : LdrpDispatchUserCallTarget;
	SIZE_T RegionSize = PAGE_SIZE;
	ULONG OldProtect;
	Status = NtProtectVirtualMemory(NtCurrentProcess(),
									&TargetPage,
									&RegionSize,
									PAGE_EXECUTE_READWRITE,
									&OldProtect);
	if (!NT_SUCCESS(Status))
		goto finished;

	UCHAR Validate64[] =
	{
		0x48, 0x8B, 0xC1,		// mov rax, rcx
		0x48, 0xC1, 0xE8, 0x03,	// shr rax, 3
		0xC3					// ret
	};

	UCHAR Validate32[] =
	{
		0xC2, 0x00, 0x00		// ret 0
	};

	if (LdrpValidateUserCallTarget != nullptr)
		RtlCopyMemory(LdrpValidateUserCallTarget, IsWow64 ? Validate32 : Validate64, IsWow64 ? sizeof(Validate32) : sizeof(Validate64));

#ifdef _WIN64
	UCHAR Dispatch[] = { 0x48, 0xFF, 0xE0 }; // jmp rax
	if (LdrpDispatchUserCallTarget != nullptr)
		RtlCopyMemory(LdrpDispatchUserCallTarget, Dispatch, sizeof(Dispatch));
#endif

	Status = NtProtectVirtualMemory(NtCurrentProcess(),
									&TargetPage,
									&RegionSize,
									OldProtect,
									&OldProtect);

finished:
	KeUnstackDetachProcess(&ApcState);

	return Status;
}

FORCEINLINE
LARGE_INTEGER
RtlQueryPerformanceCounter(
	_Out_opt_ PLARGE_INTEGER PerformanceFrequency
	)
{
	const UCHAR QpcShift = SharedUserData->QpcShift != 0 ? SharedUserData->QpcShift : 0xA;
	const ULONG64 Tsc = __rdtsc();
	LARGE_INTEGER Result;
	Result.QuadPart = (SharedUserData->QpcBias +
		((static_cast<ULONG64>(static_cast<ULONG>((Tsc >> 32) & 0xFFFFFFFF)) << 32) |
			static_cast<ULONG>(Tsc))) >> QpcShift;
	if (PerformanceFrequency != nullptr)
#ifdef _WIN64
		PerformanceFrequency->QuadPart = static_cast<ULONG_PTR>(__readgsqword(0x0C0)) >> QpcShift;
#else
		PerformanceFrequency->QuadPart = SharedUserData->QpcFrequency;
#endif
	return Result;
}

VOID
InitializeStackCookie(
	_In_ PVOID ImageBase,
	_In_ PCLIENT_ID ClientId
	)
{
	PAGED_CODE();
	
	const PIMAGE_NT_HEADERS NtHeaders = RtlpImageNtHeaderEx(ImageBase, 0);
	if (HEADER_FIELD(NtHeaders, MajorSubsystemVersion) < 6 || (HEADER_FIELD(NtHeaders, MajorSubsystemVersion) == 6 && HEADER_FIELD(NtHeaders, MinorSubsystemVersion < 3)))
		return; 

	ULONG ConfigDirSize = 0;
	const PIMAGE_LOAD_CONFIG_DIRECTORY32 LoadConfigDirectory32 = static_cast<PIMAGE_LOAD_CONFIG_DIRECTORY32>(
		RtlpImageDirectoryEntryToDataEx(ImageBase,
										TRUE,
										IMAGE_DIRECTORY_ENTRY_LOAD_CONFIG,
										&ConfigDirSize));
	const PIMAGE_LOAD_CONFIG_DIRECTORY64 LoadConfigDirectory64 = reinterpret_cast<PIMAGE_LOAD_CONFIG_DIRECTORY64>(LoadConfigDirectory32);

	if (LoadConfigDirectory32 == nullptr || ConfigDirSize == 0)
		return;

	const ULONG SizeOfCookie = IMAGE64(NtHeaders) ? sizeof(ULONG64) : sizeof(ULONG);
	ULONG_PTR CookieVA, DefaultSecurityCookie;
	UINT_PTR Cookie;

	if (IMAGE64(NtHeaders))
	{
		if ((CookieVA = LoadConfigDirectory64->SecurityCookie) == 0)
			return;

		Cookie = static_cast<ULONG64>(SharedUserData->SystemTime.High1Time) << 32 |
				static_cast<ULONG64>(SharedUserData->SystemTime.LowPart);
	}
	else
	{
		if ((CookieVA = LoadConfigDirectory32->SecurityCookie) == 0)
			return;
		
		Cookie = SharedUserData->SystemTime.LowPart;
		Cookie ^= SharedUserData->SystemTime.High1Time;
	}

	Cookie ^= HandleToULong(ClientId->UniqueThread);
	Cookie ^= HandleToULong(ClientId->UniqueProcess);

	const ULONG64 TickCount64 = (SharedUserData->TickCountMultiplier * SharedUserData->TickCountQuad >> 24) +
						(SharedUserData->TickCountMultiplier * (SharedUserData->TickCountQuad >> 32) << 8);
	Cookie ^= (IMAGE64(NtHeaders) ? (TickCount64 << 56) : TickCount64);

	const LARGE_INTEGER PerfCounter = RtlQueryPerformanceCounter(nullptr);

	if (IMAGE64(NtHeaders))
	{
		Cookie ^= (static_cast<ULONG64>(PerfCounter.LowPart) << 32) ^ PerfCounter.QuadPart;

		Cookie ^= CookieVA;

		Cookie &= 0x0000FFFFFFFFFFFFi64;

		DefaultSecurityCookie = static_cast<ULONG_PTR>(0x00002B992DDFA232ULL);
		if (Cookie == DefaultSecurityCookie)
			Cookie++;
	}
	else
	{
		Cookie ^= PerfCounter.LowPart;
		Cookie ^= PerfCounter.HighPart;

		Cookie ^= CookieVA;

		DefaultSecurityCookie = 0xBB40E64E;
		if (Cookie == DefaultSecurityCookie)
			Cookie++;
		else if ((Cookie & 0xFFFF0000) == 0)
			Cookie |= ((Cookie | 0x4711) << 16);
	}

	ULONG_PTR CookieComplementVA = CookieVA + SizeOfCookie;
	if ((IMAGE64(NtHeaders) && *reinterpret_cast<PULONG_PTR>(CookieComplementVA) != ~DefaultSecurityCookie) ||
		(IMAGE32(NtHeaders) && *reinterpret_cast<PULONG>(CookieComplementVA) != ~DefaultSecurityCookie))
	{
		CookieComplementVA = CookieVA - SizeOfCookie;
		if ((IMAGE64(NtHeaders) && *reinterpret_cast<PULONG_PTR>(CookieComplementVA) != ~DefaultSecurityCookie) ||
			(IMAGE32(NtHeaders) && *reinterpret_cast<PULONG>(CookieComplementVA) != ~DefaultSecurityCookie))
			CookieComplementVA = 0; 
	}

	if (IMAGE64(NtHeaders))
	{
		*reinterpret_cast<PULONG_PTR>(CookieVA) = Cookie;
		if (CookieComplementVA != 0)
			*reinterpret_cast<PULONG_PTR>(CookieComplementVA) = ~Cookie;
	}
	else
	{
		*reinterpret_cast<PULONG>(CookieVA) = static_cast<ULONG>(Cookie);
		if (CookieComplementVA != 0)
			*reinterpret_cast<PULONG>(CookieComplementVA) = ~static_cast<ULONG>(Cookie);
	}
}

PVOID
RandomiseImageBase(
	_In_ PIMAGE_NT_HEADERS NtHeaders,
	_In_opt_ PVOID PreferredBase
	)
{
	PreferredBase = PreferredBase != nullptr ? PreferredBase : reinterpret_cast<PVOID>(HEADER_FIELD(NtHeaders, ImageBase));

	
	const ULONG MaxBias = IMAGE64(NtHeaders) ? 0x20000000UL : 0x20000UL;
	const ULONG Bias = RtlNextRandom(0, MaxBias);

	
	const ULONG_PTR Multiplier = IMAGE64(NtHeaders) ? 0x10 : 0x1;
	const ULONG_PTR ShiftedImageBase = reinterpret_cast<ULONG_PTR>(PreferredBase) + (Bias << 1);
	return reinterpret_cast<PVOID>((ShiftedImageBase + (Multiplier * PAGE_SIZE) - 1) & ~((Multiplier * PAGE_SIZE) - 1));
}

PVOID
RandomiseSystemImageBase(
	_In_ PEPROCESS Process,
	_In_ PIMAGE_NT_HEADERS NtHeaders
	)
{
	ULONG_PTR Start = static_cast<ULONG_PTR>(IMAGE64(NtHeaders) ?
		(DynData.Version >= WINVER_81 ? 0x7f0000000000 : 0x7f000000000) :
		0x70000000);

	const ULONG_PTR MmHighestVadAddress = reinterpret_cast<ULONG_PTR>(MM_HIGHEST_USER_ADDRESS) - (64 * 1024);
	while (true)
	{
		const ULONG_PTR End = Start + ROUND_TO_PAGES(HEADER_FIELD(NtHeaders, SizeOfImage));
		if (End > MmHighestVadAddress)
		{
			Printf("Failed to find available system DLL range for image! Falling back to default image base\n");
			return RandomiseImageBase(NtHeaders, nullptr);
		}

		if (!DoesVADConflict(Process, Start, End))
		{
			const ULONG_PTR ShiftedStart = reinterpret_cast<ULONG_PTR>(RandomiseImageBase(NtHeaders, reinterpret_cast<PVOID>(Start)));
			const ULONG_PTR ShiftedEnd = ShiftedStart + ROUND_TO_PAGES(HEADER_FIELD(NtHeaders, SizeOfImage));

			if (!DoesVADConflict(Process, ShiftedStart, ShiftedEnd))
			{
				return reinterpret_cast<PVOID>(ShiftedStart);
			}

			
			Printf("Could not apply ASLR (0x%p -> 0x%p): virtual address range conflicts with an existing VAD\n",
				reinterpret_cast<PVOID>(Start), reinterpret_cast<PVOID>(ShiftedStart));
			return reinterpret_cast<PVOID>(Start);
		}

		Start += ((IMAGE64(NtHeaders) ? 128 : 16) * 1024 * 1024);
	}
}

NTSTATUS
ResolveImports(
	_In_ PEPROCESS Process,
	_In_ PVOID ImageBase,
	_In_ BOOLEAN WipeNames
	)
{
	PAGED_CODE();

	NTSTATUS Status = STATUS_SUCCESS;
	ULONG ImportsSize = 0;
	const PIMAGE_NT_HEADERS NtHeaders = RtlpImageNtHeaderEx(ImageBase, 0);
	PIMAGE_IMPORT_DESCRIPTOR ImportTable = static_cast<PIMAGE_IMPORT_DESCRIPTOR>(
		RtlpImageDirectoryEntryToDataEx(ImageBase,
										TRUE,
										IMAGE_DIRECTORY_ENTRY_IMPORT,
										&ImportsSize));

	if (ImportTable == nullptr)
		return STATUS_SUCCESS;

	BOOLEAN Hooked = FALSE;

	for ( ; ImportTable->Name && NT_SUCCESS(Status); ++ImportTable)
	{
		PVOID Thunk = static_cast<PUCHAR>(ImageBase) + (ImportTable->OriginalFirstThunk
			? ImportTable->OriginalFirstThunk
			: ImportTable->FirstThunk);

		DECLARE_UNICODE_STRING_SIZE(UnicodeDllName, 1024);
		UNICODE_STRING ResolvedDllPath = { 0 }, ResolvedDllName = { 0 };
		ANSI_STRING AnsiDllName;
		PUCHAR VerificationDllBuffer = nullptr;
		ULONG IatIndex = 0;

		RtlxInitAnsiString(&AnsiDllName, static_cast<PCHAR>(ImageBase) + ImportTable->Name);
		RtlAnsiStringToUnicodeString(&UnicodeDllName, &AnsiDllName, FALSE);

		if (WipeNames)
		{
			RtlFillGarbageMemory(static_cast<PCHAR>(ImageBase) + ImportTable->Name, AnsiDllName.MaximumLength);
		}

		Status = ResolveImagePath(Process, &UnicodeDllName, &ResolvedDllPath);
		if (!NT_SUCCESS(Status))
		{
			Printf("Failed to resolve full path for DLL %wZ: %08X\n", &UnicodeDllName, Status);
			return Status;
		}

		RtlStripPath(&ResolvedDllPath, &ResolvedDllName);
		Printf("Processing imports for %wZ...\n", &ResolvedDllName);

		const PVOID ModuleAddress = FindModule(Process, &ResolvedDllName);
		if (ModuleAddress == nullptr)
		{
			NT_ASSERT(FALSE);
		}

		if (ModuleAddress == nullptr)
		{
			Printf("Failed to find loaded DLL '%wZ': status 0x%08X\n", &UnicodeDllName, Status);
			RtlxFreeUnicodeString(&ResolvedDllPath);
			return STATUS_NOT_FOUND;
		}

		Status = RtlReadFileToBytes(&ResolvedDllPath, &VerificationDllBuffer, nullptr);
		if (!NT_SUCCESS(Status))
		{
			Printf("Failed to read DLL '%wZ' from disk for hook checking: status 0x%08X\n", &UnicodeDllName, Status);
			RtlxFreeUnicodeString(&ResolvedDllPath);
			return Status;
		}

		while (THUNK_VAL(NtHeaders, Thunk, u1.AddressOfData) != 0)
		{
			ANSI_STRING AnsiFunctionName;
			CHAR ImportFunctionNameBuffer[1024] = { '\0' }, *ImportFunctionName;
			BOOLEAN ImportByOrdinal = FALSE;

			const PIMAGE_IMPORT_BY_NAME AddressTable = reinterpret_cast<PIMAGE_IMPORT_BY_NAME>(
				static_cast<PUCHAR>(ImageBase) + THUNK_VAL(NtHeaders, Thunk, u1.AddressOfData));
			
			if (THUNK_VAL(NtHeaders, Thunk, u1.AddressOfData) < (IMAGE64(NtHeaders) ? IMAGE_ORDINAL_FLAG64 : IMAGE_ORDINAL_FLAG32) &&
				 AddressTable->Name[0] != '\0')
			{
				RtlxInitAnsiString(&AnsiFunctionName, AddressTable->Name);
				strncpy_s(ImportFunctionNameBuffer, sizeof(ImportFunctionNameBuffer), AddressTable->Name, AnsiFunctionName.Length);
				ImportFunctionName = ImportFunctionNameBuffer;

				if (WipeNames)
				{
					RtlFillGarbageMemory(AddressTable->Name - FIELD_OFFSET(IMAGE_IMPORT_BY_NAME, Name),
						AnsiFunctionName.MaximumLength + FIELD_OFFSET(IMAGE_IMPORT_BY_NAME, Name));
				}
			}
			else
			{
				ImportByOrdinal = TRUE;
				ImportFunctionName = reinterpret_cast<PCCHAR>(THUNK_VAL(NtHeaders, Thunk, u1.AddressOfData) & 0xFFFF);
			}

			PVOID Function = GetModuleExport(ModuleAddress,
											ImportFunctionName,
											Process);
			
			if (Function == nullptr)
			{
				if (THUNK_VAL(NtHeaders, Thunk, u1.AddressOfData) <
					(IMAGE64(NtHeaders) ? IMAGE_ORDINAL_FLAG64 : IMAGE_ORDINAL_FLAG32) && ImportFunctionNameBuffer[0] != '\0')
					Printf(" Failed to resolve import '%wZ!%hs'\n",
						&UnicodeDllName, ImportFunctionNameBuffer);
				else
					Printf("Failed to resolve import '%wZ!#%zu'\n",
						&UnicodeDllName, THUNK_VAL(NtHeaders, Thunk, u1.AddressOfData) & 0xFFFF);

				Status = STATUS_NOT_FOUND;
				break;
			}

			const PVOID FunctionOnDisk = ImportByOrdinal
				? nullptr
				: GetFileDataProcedureAddress(reinterpret_cast<ULONG_PTR>(VerificationDllBuffer), ImportFunctionNameBuffer);

			if (FunctionOnDisk != nullptr)
			{
				for (ULONG i = 0; i < 3; ++i)
				{
					const UCHAR ByteOnDisk = static_cast<PUCHAR>(FunctionOnDisk)[i];
					const UCHAR ByteInProcess = static_cast<PUCHAR>(Function)[i];

					if (ByteOnDisk != ByteInProcess)
					{
						Printf("%wZ!%hs[%lu]: expected 0x%02X, found 0x%02X. Imported function is HOOKED!\n",
							&UnicodeDllName, ImportFunctionNameBuffer, i, ByteOnDisk, ByteInProcess);
						Hooked = TRUE;
					}
				}
			}

			if (IMAGE64(NtHeaders))
			{
				if (ImportTable->FirstThunk != 0)
					*reinterpret_cast<PULONG_PTR>(static_cast<PUCHAR>(ImageBase) + ImportTable->FirstThunk + IatIndex) =
					reinterpret_cast<ULONG_PTR>(Function);
				else
					*reinterpret_cast<PULONG_PTR>(static_cast<PUCHAR>(ImageBase) + THUNK_VAL(NtHeaders, Thunk, u1.AddressOfData)) =
					reinterpret_cast<ULONG_PTR>(Function);
			}
			else
			{
				if (ImportTable->FirstThunk != 0)
					*reinterpret_cast<PULONG>(static_cast<PUCHAR>(ImageBase) + ImportTable->FirstThunk + IatIndex) =
					static_cast<ULONG>(reinterpret_cast<ULONG_PTR>(Function));
				else
					*reinterpret_cast<PULONG>(static_cast<PUCHAR>(ImageBase) + THUNK_VAL(NtHeaders, Thunk, u1.AddressOfData)) =
					static_cast<ULONG>(reinterpret_cast<ULONG_PTR>(Function));
			}

			Thunk = static_cast<PUCHAR>(Thunk) + (IMAGE64(NtHeaders) ? sizeof(IMAGE_THUNK_DATA64) : sizeof(IMAGE_THUNK_DATA32));
			IatIndex += (IMAGE64(NtHeaders) ? sizeof(ULONGLONG) : sizeof(ULONG));
		}

		RtlxFreeUnicodeString(&ResolvedDllPath);

		if (VerificationDllBuffer != nullptr)
			ExFreePool(VerificationDllBuffer);
	}

#if !IGNORE_IMPORT_HOOKS
	if (NT_SUCCESS(Status) && Hooked)
	{
		Printf("Aborting import resolution; DLL imports one or more hooked function(s)\n");
		Status = STATUS_DATA_NOT_ACCEPTED;
	}
#endif

	return Status;
}

VOID
WipeImageSections(
	_In_ PVOID ImageBase,
	_In_ BOOLEAN PhysicalAllocation,
	_In_ PIMAGE_SECTION_HEADER SectionHeaders,
	_In_ BOOLEAN WipeHeaders
	)
{
	PAGED_CODE();

	const PIMAGE_NT_HEADERS NtHeaders = RtlpImageNtHeaderEx(ImageBase, 0);
	const int NumberOfSections = static_cast<int>(NtHeaders->FileHeader.NumberOfSections);

	for (LONG i = NumberOfSections - 1; i >= -1; --i)
	{
		if ((i == -1 && !WipeHeaders) ||
			(i >= 0 && (SectionHeaders[i].Characteristics & IMAGE_SCN_MEM_DISCARDABLE) == 0))
			continue;

		PVOID SectionVa;
		SIZE_T SectionVirtualSize;
		if (i == -1)
		{
			SectionVa = ImageBase;
			SectionVirtualSize = ALIGN_TO_SECTIONS(HEADER_FIELD(NtHeaders, SizeOfHeaders), HEADER_FIELD(NtHeaders, SectionAlignment));
			Printf("Wiping PE headers at 0x%p (size 0x%X)...\n", SectionVa, static_cast<ULONG>(SectionVirtualSize));
		}
		else
		{
			SectionVa = static_cast<PVOID>(static_cast<PUCHAR>(ImageBase) + SectionHeaders[i].VirtualAddress);
			SectionVirtualSize = SectionHeaders[i].Misc.VirtualSize > 0
				? SectionHeaders[i].Misc.VirtualSize
				: SectionHeaders[i].SizeOfRawData;
			SectionVirtualSize = ALIGN_TO_SECTIONS(SectionVirtualSize, HEADER_FIELD(NtHeaders, SectionAlignment));
			SectionHeaders[i].Name[IMAGE_SIZEOF_SHORT_NAME - 1] = '\0';
			Printf("Wiping section \"%hs\" at 0x%p (size 0x%X)...\n",
				reinterpret_cast<PCCH>(SectionHeaders[i].Name), SectionVa, static_cast<ULONG>(SectionVirtualSize));
		}

		RtlFillGarbageMemory(SectionVa, SectionVirtualSize);

		if (PhysicalAllocation)
		{
			PMMVAD_SHORT VadShort;
			if (!NT_SUCCESS(FindVAD(PsGetCurrentProcess(), reinterpret_cast<ULONG_PTR>(SectionVa), &VadShort)))
				continue;

#if NTDDI_VERSION >= NTDDI_WIN10
			if ((DynData.Version >= WINVER_10_19H1 && !IsVadProtectionChangeAllowed19H1(reinterpret_cast<PMMVAD_SHORT_19H1>(VadShort))) ||
				(DynData.Version < WINVER_10_19H1 && !IsVadProtectionChangeAllowed(VadShort)))
#else
			if (!IsVadProtectionChangeAllowed(VadShort))
#endif
			{
				if (i == -1)
				{
					const PMMPTE PTE = GetPTEForVA(reinterpret_cast<PVOID>(SectionVa));
					PTE->u.Hard.Dirty1 = PTE->u.Hard.Write = 0;
					PTE->u.Hard.NoExecute = 1;
				}
				continue;
			}
		}

		ULONG OldProtect;
		if (NT_SUCCESS(NtProtectVirtualMemory(NtCurrentProcess(),
											&SectionVa,
											&SectionVirtualSize,
											PAGE_NOACCESS,
											&OldProtect)))
		{
			NtFreeVirtualMemory(NtCurrentProcess(),
								&SectionVa,
								&SectionVirtualSize,
								MEM_DECOMMIT);
		}
	}
}

```

`MMInject/Process.c`:

```c
#include "MMInject.h"
#include "Utils.h"

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, CreateProcessNotifyRoutine)
#pragma alloc_text(PAGE, OpenSessionProcess)
#pragma alloc_text(PAGE, CancelAllProcessWaits)
#endif

static KEVENT ProcessCreatedEvent;
static PUNICODE_STRING NotifyProcessName = nullptr;
static PEPROCESS NotifyProcess = nullptr;

VOID
CreateProcessNotifyRoutine(
	_Inout_ PEPROCESS Process,
	_In_ HANDLE ProcessId,
	_Inout_opt_ PPS_CREATE_NOTIFY_INFO CreateInfo
	)
{
	PAGED_CODE();

	UNREFERENCED_PARAMETER(ProcessId);

	if (CreateInfo == nullptr || CreateInfo->ImageFileName == nullptr ||
		!RtlUnicodeStringEndsIn(CreateInfo->ImageFileName, NotifyProcessName))
		return;

	ObfReferenceObjectWithTag(Process, GetPoolTag());
	NotifyProcess = Process;
	KeSetEvent(&ProcessCreatedEvent,
				IO_NO_INCREMENT,
				FALSE);
}

NTSTATUS
OpenSessionProcess(
	_Out_ PEPROCESS *Process,
	_In_ PUNICODE_STRING ProcessName,
	_In_ ULONG SessionId,
	_In_ BOOLEAN Wait
	)
{
	PAGED_CODE();

	ULONG Size;
	if (NtQuerySystemInformation(SystemProcessInformation, nullptr, 0, &Size) != STATUS_INFO_LENGTH_MISMATCH)
		return STATUS_UNSUCCESSFUL;
	const PSYSTEM_PROCESS_INFORMATION SystemProcessInfo =
		static_cast<PSYSTEM_PROCESS_INFORMATION>(ExAllocatePoolWithTag(NonPagedPoolNx, 2 * Size, GetPoolTag()));
	if (SystemProcessInfo == nullptr)
		return STATUS_NO_MEMORY;
	NTSTATUS Status = NtQuerySystemInformation(SystemProcessInformation,
												SystemProcessInfo,
												2 * Size,
												nullptr);
	if (!NT_SUCCESS(Status))
	{
		ExFreePool(SystemProcessInfo);
		return Status;
	}

	PSYSTEM_PROCESS_INFORMATION Entry = SystemProcessInfo;
	Status = STATUS_NOT_FOUND;

	while (true)
	{
		if (Entry->ImageName.Buffer != nullptr &&
			RtlCompareUnicodeString(&Entry->ImageName, ProcessName, TRUE) == 0)
		{
			Status = PsLookupProcessByProcessId(Entry->UniqueProcessId, Process);
			if (NT_SUCCESS(Status))
			{
				if (PsGetProcessSessionIdEx(*Process) == SessionId)
					break;
				
				ObfDereferenceObject(*Process);
			}
		}

		if (Entry->NextEntryOffset == 0)
			break;

		Entry = reinterpret_cast<PSYSTEM_PROCESS_INFORMATION>(reinterpret_cast<ULONG_PTR>(Entry) +
																Entry->NextEntryOffset);
	}
	ExFreePool(SystemProcessInfo);

	if (Status == STATUS_NOT_FOUND && Wait)
	{
		Printf("Waiting for process %wZ...\n", ProcessName);
		NotifyProcessName = ProcessName;
		NotifyProcess = nullptr;

		KeInitializeEvent(&ProcessCreatedEvent,
						NotificationEvent,
						FALSE);

		PsSetCreateProcessNotifyRoutineEx(CreateProcessNotifyRoutine, FALSE);

		KeWaitForSingleObject(&ProcessCreatedEvent,
							Executive,
							KernelMode,
							FALSE,
							nullptr);

		PsSetCreateProcessNotifyRoutineEx(CreateProcessNotifyRoutine, TRUE);

		if (NotifyProcess == nullptr)
		{
			Status = STATUS_CANCELLED;
			*Process = nullptr;
		}
		else
		{
			Status = STATUS_SUCCESS;
			*Process = NotifyProcess;

			RtlSleep(50);
		}
	}

	NotifyProcessName = nullptr;
	NotifyProcess = nullptr;

	return Status;
}

VOID
CancelAllProcessWaits(
	)
{
	PAGED_CODE();

	if (NotifyProcessName == nullptr)
	{
		return;
	}

	NotifyProcess = nullptr;
	KeSetEvent(&ProcessCreatedEvent,
				IO_NO_INCREMENT,
				FALSE);
}

```

`MMInject/SSDT.c`:

```c
#include "MMInject.h"
#include "StringEncryptor.h"
#include <stdio.h>
#include "Utils.h"

#define HOOK_SHADOW_SSDT	0	
								

typedef struct _KSERVICE_TABLE_DESCRIPTOR
{
	PLONG ServiceTable;
	PULONG Count;
	SIZE_T Limit;
	PUCHAR ArgumentTable;
} KSERVICE_TABLE_DESCRIPTOR, *PKSERVICE_TABLE_DESCRIPTOR;

typedef struct _SERVICE_TABLE_ENTRY
{
	CHAR Name[64];
	PVOID Address;
} SERVICE_TABLE_ENTRY, *PSERVICE_TABLE_ENTRY;

extern DYNAMIC_DATA DynData;

extern ULONG_PTR NtoskrnlBase;
extern ULONG NtoskrnlSize;

static KSERVICE_TABLE_DESCRIPTOR KeServiceDescriptorTable = { nullptr };
#if HOOK_SHADOW_SSDT
static KSERVICE_TABLE_DESCRIPTOR KeServiceDescriptorTableShadow = { nullptr };
#endif
static PSERVICE_TABLE_ENTRY SsdtEntries = nullptr;
#if HOOK_SHADOW_SSDT
static PSERVICE_TABLE_ENTRY SsdtEntriesShadow = nullptr;
#endif

static CONSTEXPR CONST UCHAR KiSystemServiceStartPattern[] = { 0x8B, 0xF8, 0xC1, 0xEF, 0x07, 0x83, 0xE7, 0x20, 0x25, 0xFF, 0x0F, 0x00, 0x00 };
static PUCHAR NtdllData = nullptr;

extern "C"
{
	static
	NTSTATUS
	FindKeServiceDescriptorTables(
		);

	static
	NTSTATUS
	FindSsdtNames(
		);

	static
	NTSTATUS
	FindSsdtAddresses(
		);
}

#ifdef ALLOC_PRAGMA
#pragma alloc_text(INIT, FindKeServiceDescriptorTables)
#pragma alloc_text(INIT, FindSsdtNames)
#pragma alloc_text(INIT, FindSsdtAddresses)
#pragma alloc_text(INIT, SsdtInitialize)
#pragma alloc_text(PAGE, SsdtUninitialize)
#endif

VOID
SsdtUninitialize(
	)
{
	PAGED_CODE();

	if (SsdtEntries != nullptr)
		ExFreePool(SsdtEntries);
#if HOOK_SHADOW_SSDT
	if (SsdtEntriesShadow != nullptr)
		ExFreePool(SsdtEntriesShadow);
#endif
}

KPROCESSOR_MODE
KeSetPreviousMode(
	_In_ KPROCESSOR_MODE ProcessorMode
	)
{
#ifdef _M_AMD64
	// mov rax, gs:188h, mov tmp, [rax + offset]
	KPROCESSOR_MODE *pPreviousMode = reinterpret_cast<KPROCESSOR_MODE*>(reinterpret_cast<PUCHAR>(__readgsqword(392)) + DynData.PreviousModeOffset);
#else
	// mov eax, large fs:124h, mov tmp, [eax + offset]
	KPROCESSOR_MODE *pPreviousMode = reinterpret_cast<KPROCESSOR_MODE*>(reinterpret_cast<PUCHAR>(__readfsdword(292)) + DynData.PreviousModeOffset);
#endif

	const KPROCESSOR_MODE OldPreviousMode = *pPreviousMode;
	*pPreviousMode = ProcessorMode;
	return OldPreviousMode;
}

static
NTSTATUS
FindKeServiceDescriptorTables(
	)
{
	PAGED_CODE();
	
	__try
	{
#ifndef _M_AMD64
		UNICODE_STRING KeServiceDescriptorTableName = RTL_CONSTANT_STRING(L"KeServiceDescriptorTable");
		PVOID KeServiceDescriptorTableAddress = MmGetSystemRoutineAddress(&KeServiceDescriptorTableName);
		if (KeServiceDescriptorTableAddress == nullptr)
			return STATUS_NOT_FOUND;
#else
		constexpr const ULONG SignatureSize = sizeof(KiSystemServiceStartPattern);
		BOOLEAN Found = FALSE;
		ULONG KiSSSOffset;

		for (KiSSSOffset = 0; KiSSSOffset < NtoskrnlSize - SignatureSize; ++KiSSSOffset)
		{
			if (memcmp((reinterpret_cast<PUCHAR>(NtoskrnlBase) + KiSSSOffset),
								KiSystemServiceStartPattern,
								SignatureSize) == 0)
			{
				Found = TRUE;
				break;
			}
		}
		if (!Found)
			return STATUS_NOT_FOUND;

		const ULONG_PTR Address = NtoskrnlBase + KiSSSOffset + SignatureSize;
		LONG RelativeOffset = 0;
		if ((*reinterpret_cast<PUCHAR>(Address) == 0x4c) &&
			(*reinterpret_cast<PUCHAR>(Address + 1) == 0x8d) &&
			(*reinterpret_cast<PUCHAR>(Address + 2) == 0x15))
		{
			RelativeOffset = *reinterpret_cast<PLONG>(Address + 3);
		}
		const ULONG_PTR KeServiceDescriptorTableAddress = Address + RelativeOffset + 7;
		if (RelativeOffset == 0)
			return STATUS_NOT_FOUND;

#if HOOK_SHADOW_SSDT
		Address += 7;
		RelativeOffset = 0;
		if ((*reinterpret_cast<PUCHAR>(Address) == 0x4c) &&
			(*reinterpret_cast<PUCHAR>(Address + 1) == 0x8d) &&
			(*reinterpret_cast<PUCHAR>(Address + 2) == 0x1d))
		{
			RelativeOffset = *reinterpret_cast<PLONG>(Address + 3);
		}
		ULONG_PTR KeServiceDescriptorTableShadowAddress = Address + RelativeOffset + 7 + sizeof(KSERVICE_TABLE_DESCRIPTOR);
		if (RelativeOffset == 0)
			return STATUS_NOT_FOUND;

		if (KeServiceDescriptorTableAddress < reinterpret_cast<ULONG_PTR>(MmSystemRangeStart) ||
			KeServiceDescriptorTableShadowAddress < reinterpret_cast<ULONG_PTR>(MmSystemRangeStart))
			return STATUS_NOT_FOUND;
#endif
#endif

		RtlCopyMemory(&KeServiceDescriptorTable,
					reinterpret_cast<PVOID>(KeServiceDescriptorTableAddress),
					sizeof(KeServiceDescriptorTable));

		if (reinterpret_cast<ULONG_PTR>(KeServiceDescriptorTable.ServiceTable) < reinterpret_cast<ULONG_PTR>(MmSystemRangeStart) ||
			KeServiceDescriptorTable.Limit == 0 ||
			KeServiceDescriptorTable.ArgumentTable < MmSystemRangeStart)
		{
			Printf("KeServiceDescriptorTable at 0x%p is NOT valid!\n",
				reinterpret_cast<PVOID>(KeServiceDescriptorTableAddress));
			return STATUS_NOT_FOUND;
		}

		Printf("KeServiceDescriptorTable: 0x%p\n", reinterpret_cast<PVOID>(KeServiceDescriptorTableAddress));
		Printf("ServiceTable: 0x%p, Limit: %llu, ArgumentTable: 0x%p\n",
			KeServiceDescriptorTable.ServiceTable, KeServiceDescriptorTable.Limit,
			reinterpret_cast<PVOID>(KeServiceDescriptorTable.ArgumentTable));

#ifdef _M_AMD64
#if HOOK_SHADOW_SSDT
		RtlCopyMemory(&KeServiceDescriptorTableShadow,
					reinterpret_cast<PVOID>(KeServiceDescriptorTableShadowAddress),
					sizeof(KeServiceDescriptorTableShadow));

		if (reinterpret_cast<ULONG_PTR>(KeServiceDescriptorTableShadow.ServiceTable) < reinterpret_cast<ULONG_PTR>(MmSystemRangeStart) ||
			KeServiceDescriptorTableShadow.Limit == 0 ||
			KeServiceDescriptorTableShadow.ArgumentTable < MmSystemRangeStart)
		{
			Printf("KeServiceDescriptorTableShadow at 0x%p is NOT valid!\n",
				reinterpret_cast<PVOID>(KeServiceDescriptorTableShadowAddress));
			return STATUS_NOT_FOUND;
		}

		Printf("KeServiceDescriptorTableShadow: 0x%p\n", reinterpret_cast<PVOID>(KeServiceDescriptorTableShadowAddress));
		Printf("ServiceTable: 0x%p, Limit: %llu, ArgumentTable: 0x%p\n",
			KeServiceDescriptorTableShadow.ServiceTable, KeServiceDescriptorTableShadow.Limit,
			reinterpret_cast<PVOID>(KeServiceDescriptorTableShadow.ArgumentTable));
#endif
#endif
	}
	__except (GetExceptionCode() == STATUS_ACCESS_VIOLATION
		? EXCEPTION_EXECUTE_HANDLER
		: EXCEPTION_CONTINUE_SEARCH)
	{
		return STATUS_ACCESS_VIOLATION;
	}
	return STATUS_SUCCESS;
}

static
NTSTATUS
FindSsdtNames(
	)
{
	PAGED_CODE();
	
	const PIMAGE_DOS_HEADER DosHeader = reinterpret_cast<PIMAGE_DOS_HEADER>(NtdllData);
	if (DosHeader->e_magic != IMAGE_DOS_SIGNATURE)
		return STATUS_INVALID_IMAGE_NOT_MZ;
	const PIMAGE_NT_HEADERS NtHeaders = reinterpret_cast<PIMAGE_NT_HEADERS>(NtdllData + DosHeader->e_lfanew);
	if (NtHeaders->Signature != IMAGE_NT_SIGNATURE)
		return STATUS_INVALID_IMAGE_FORMAT;

	PIMAGE_DATA_DIRECTORY ImageDirectories;
	if (NtHeaders->OptionalHeader.Magic == IMAGE_NT_OPTIONAL_HDR64_MAGIC)
		ImageDirectories = reinterpret_cast<PIMAGE_NT_HEADERS64>(NtHeaders)->OptionalHeader.DataDirectory;
	else
		ImageDirectories = reinterpret_cast<PIMAGE_NT_HEADERS32>(NtHeaders)->OptionalHeader.DataDirectory;

	const ULONG ExportDirRva = ImageDirectories[IMAGE_DIRECTORY_ENTRY_EXPORT].VirtualAddress;
	const ULONG ExportDirSize = ImageDirectories[IMAGE_DIRECTORY_ENTRY_EXPORT].Size;
	const ULONG ExportDirOffset = RvaToOffset(NtHeaders, ExportDirRva);
	if (ExportDirOffset == 0)
		return STATUS_INVALID_IMAGE_FORMAT;

	const PIMAGE_EXPORT_DIRECTORY ExportDirectory = reinterpret_cast<PIMAGE_EXPORT_DIRECTORY>(NtdllData + ExportDirOffset);
	const ULONG AddressOfFunctionsOffset = RvaToOffset(NtHeaders, ExportDirectory->AddressOfFunctions);
	const ULONG AddressOfNameOrdinalsOffset = RvaToOffset(NtHeaders, ExportDirectory->AddressOfNameOrdinals);
	const ULONG AddressOfNamesOffset = RvaToOffset(NtHeaders, ExportDirectory->AddressOfNames);
	if (AddressOfFunctionsOffset == 0 || AddressOfNameOrdinalsOffset == 0 || AddressOfNamesOffset == 0)
		return STATUS_INVALID_IMAGE_FORMAT;

	const PULONG AddressOfFunctions = reinterpret_cast<PULONG>(NtdllData + AddressOfFunctionsOffset);
	const PUSHORT AddressOfNameOrdinals = reinterpret_cast<PUSHORT>(NtdllData + AddressOfNameOrdinalsOffset);
	const PULONG AddressOfNames = reinterpret_cast<PULONG>(NtdllData + AddressOfNamesOffset);

	for (ULONG i = 0; i < ExportDirectory->NumberOfNames; ++i)
	{
		const ULONG NameOffset = RvaToOffset(NtHeaders, AddressOfNames[i]);
		if (NameOffset == 0)
			continue;

		const PCSTR FunctionName = reinterpret_cast<PSTR>(NtdllData + NameOffset);
		const ULONG FunctionRva = AddressOfFunctions[AddressOfNameOrdinals[i]];
		if (FunctionRva >= ExportDirRva && FunctionRva < ExportDirRva + ExportDirSize)
			continue;

		if (FunctionName[0] == 'N' && FunctionName[1] == 't' &&
			(!(FunctionName[2] == 'd' && FunctionName[3] == 'l' && FunctionName[4] == 'l')))
		{
			const ULONG ExportOffset = RvaToOffset(NtHeaders, FunctionRva);
			if (ExportOffset != 0)
			{
				ULONG ServiceId = *reinterpret_cast<PULONG>(NtdllData + ExportOffset + 4);
				if (ServiceId >= KeServiceDescriptorTable.Limit)
					continue;
				strncpy_s(SsdtEntries[ServiceId].Name, sizeof(SsdtEntries[ServiceId].Name), FunctionName, sizeof(SsdtEntries[ServiceId].Name) - sizeof(CHAR));
			}
		}
	}
	return STATUS_SUCCESS;
}

static
NTSTATUS
FindSsdtAddresses(
	)
{
	PAGED_CODE();

	for (ULONG ServiceId = 0; ServiceId < KeServiceDescriptorTable.Limit; ++ServiceId)
	{
#ifndef _M_AMD64
		SsdtEntries[ServiceId].Address = reinterpret_cast<PVOID>(
										KeServiceDescriptorTable.ServiceTable[ServiceId]);
#else
		SsdtEntries[ServiceId].Address = reinterpret_cast<PVOID>(reinterpret_cast<ULONG_PTR>(
										KeServiceDescriptorTable.ServiceTable) +
										(KeServiceDescriptorTable.ServiceTable[ServiceId] >> 4));
#endif
	}

#ifdef _M_AMD64
#if HOOK_SHADOW_SSDT
	PEPROCESS Process;
	WCHAR CsrssExe[EncryptedCsrssString.Length];
	DecryptString(EncryptedCsrssString, CsrssExe);
	UNICODE_STRING ProcessName = { EncryptedCsrssString.Length - sizeof(WCHAR), EncryptedCsrssString.Length, CsrssExe };
	const NTSTATUS Status = OpenSessionProcess(&Process,
												&ProcessName,
												1,
												FALSE);
	RtlSecureZeroMemory(CsrssExe, EncryptedCsrssString.Length);
	if (!NT_SUCCESS(Status))
		return Status;

	KAPC_STATE ApcState;
	KeStackAttachProcess(Process, &ApcState);

	for (ULONG ServiceId = 0; ServiceId < KeServiceDescriptorTableShadow.Limit; ++ServiceId)
	{
		SsdtEntriesShadow[ServiceId].Address = reinterpret_cast<PVOID>(reinterpret_cast<ULONG_PTR>(
			KeServiceDescriptorTableShadow.ServiceTable) +
			(KeServiceDescriptorTableShadow.ServiceTable[ServiceId] >> 4));

		ULONG_PTR Address = reinterpret_cast<ULONG_PTR>(SsdtEntriesShadow[ServiceId].Address);
		if (*reinterpret_cast<PUCHAR>(Address) == 0xFF &&
			*reinterpret_cast<PUCHAR>(Address + 1) == 0x25)
		{
			LONG RelativeOffset = *reinterpret_cast<PLONG>(Address + 2);
			Address = Address + RelativeOffset + 6;

			SsdtEntriesShadow[ServiceId].Address = *reinterpret_cast<PVOID*>(Address);
		}
	}

	KeUnstackDetachProcess(&ApcState);

	ObfDereferenceObject(Process);
#endif
#endif

	return STATUS_SUCCESS;
}

PVOID
GetSyscallAddress(
	_In_ PCSTR FunctionName
	)
{
	for (ULONG ServiceId = 0; ServiceId < KeServiceDescriptorTable.Limit; ++ServiceId)
	{
		if (strcmp(FunctionName, SsdtEntries[ServiceId].Name) == 0)
		{
			return SsdtEntries[ServiceId].Address;
		}
	}
	return nullptr;
}

NTSTATUS
SsdtInitialize(
	)
{
	PAGED_CODE();

	WCHAR NtdllPath[decltype(EncryptedNtdllPathString)::Length];
	UNICODE_STRING NtdllFilename = { decltype(EncryptedNtdllPathString)::Length - sizeof(WCHAR), decltype(EncryptedNtdllPathString)::Length, NtdllPath };
	SIZE_T NtdllSize = 0;

	NT_ASSERT(NtoskrnlBase != 0);
	NT_ASSERT(NtoskrnlSize != 0);

	RtlZeroMemory(&KeServiceDescriptorTable, sizeof(KeServiceDescriptorTable));
#if HOOK_SHADOW_SSDT
	RtlZeroMemory(&KeServiceDescriptorTableShadow, sizeof(KeServiceDescriptorTableShadow));
#endif
	NTSTATUS Status = FindKeServiceDescriptorTables();
	if (!NT_SUCCESS(Status))
		goto finished;

	DecryptString(EncryptedNtdllPathString, NtdllPath);
	Status = RtlReadFileToBytes(&NtdllFilename,
								&NtdllData,
								&NtdllSize);
	RtlSecureZeroMemory(NtdllFilename.Buffer, decltype(EncryptedNtdllPathString)::Length);
	if (!NT_SUCCESS(Status))
		goto finished;

	SsdtEntries = static_cast<PSERVICE_TABLE_ENTRY>(
		ExAllocatePoolWithTag(NonPagedPoolNx,
							sizeof(SERVICE_TABLE_ENTRY) * KeServiceDescriptorTable.Limit,
							GetPoolTag()));
#if HOOK_SHADOW_SSDT
	SsdtEntriesShadow = static_cast<PSERVICE_TABLE_ENTRY>(
		ExAllocatePoolWithTag(NonPagedPoolNx,
							sizeof(SERVICE_TABLE_ENTRY) * KeServiceDescriptorTableShadow.Limit,
							GetPoolTag()));
#endif
	if (SsdtEntries == nullptr
#if HOOK_SHADOW_SSDT
		|| SsdtEntriesShadow == nullptr
#endif
		)
	{
		Status = STATUS_NO_MEMORY;
		goto finished;
	}
	RtlZeroMemory(SsdtEntries, sizeof(SERVICE_TABLE_ENTRY) * KeServiceDescriptorTable.Limit);
#if HOOK_SHADOW_SSDT
	RtlZeroMemory(SsdtEntriesShadow, sizeof(SERVICE_TABLE_ENTRY) * KeServiceDescriptorTableShadow.Limit);
#endif

	Status = FindSsdtNames();
	if (!NT_SUCCESS(Status))
		goto finished;
	Status = FindSsdtAddresses();

finished:
	if (NtdllData != nullptr)
	{
		RtlSecureZeroMemory(NtdllData, NtdllSize);
		ExFreePool(NtdllData);
	}
	if (!NT_SUCCESS(Status))
	{
		if (SsdtEntries != nullptr)
			ExFreePool(SsdtEntries);
#if HOOK_SHADOW_SSDT
		if (SsdtEntriesShadow != nullptr)
			ExFreePool(SsdtEntriesShadow);
#endif
	}
	return Status;
}

```

`MMInject/StringEncryptor.h`:

```h
#pragma once

#include "s20.h"

constexpr UCHAR EncryptionKey[] = { 0x48, 0x7a, 0x65, 0x90, 0xd3, 0x44, 0x5e, 0x81, 0xda, 0xf1, 0x22, 0xd7, 0xf6, 0x90, 0xce, 0x5e };

template<SIZE_T N>
struct ENCRYPTED_STRING
{
	static_assert(N <= MAX_PATH * sizeof(WCHAR), "Maximum length exceeded");
	static constexpr ULONG32 Length = N;
	ULONG64 Nonce;
	const UCHAR EncryptedData[N];

	ENCRYPTED_STRING() = default;
};

constexpr ENCRYPTED_STRING<sizeof(L"DLL")> EncryptedDllString =
{
	0x58cb67fa57e51c25,
	{ 0xed, 0x15, 0x5d, 0x52, 0x3b, 0x85, 0x33, 0x8f }
};

constexpr ENCRYPTED_STRING<sizeof(L"EXE")> EncryptedExeString =
{
	0x58cb67fa57e51c26,
	{ 0x39, 0x6, 0x21, 0x27, 0x35, 0x48, 0x75, 0xf5 }
};

constexpr ENCRYPTED_STRING<sizeof(L"\\Registry\\Machine\\SOFTWARE\\Microsoft\\DRM\\CUSTOMEXE")> EncryptedExeRegString =
{
	0x58cb67fa57e51c27,
	{ 0x11, 0x3c, 0xb5, 0xc6, 0x11, 0x84, 0x4e, 0xe2, 0xa9, 0x5d, 0x8, 0x3e, 0xd, 0xa4, 0x3f, 0xcb, 0x7e, 0x40, 0xf6, 0xa8, 0x7c, 0x1, 0xf4, 0xcb, 0xa1, 0xc5, 0x57, 0x9, 0xc4, 0x11, 0x2f, 0xe5, 0xf6, 0xaa, 0x1e, 0x5e, 0x1f, 0xe, 0xa, 0x6a, 0xab, 0x75, 0xb1, 0x78, 0xf6, 0x56, 0x1, 0xbb, 0xda, 0x21, 0xd8, 0xed, 0x68, 0x5c, 0x9b, 0xb6, 0x8d, 0x92, 0xd, 0x57, 0xb5, 0x86, 0x4a, 0xcc, 0x9f, 0x23, 0xe2, 0x7d, 0x8a, 0x85, 0x62, 0x6d, 0xfd, 0x44, 0xb0, 0xd, 0xe0, 0xe8, 0xcf, 0xe7, 0x9, 0x45, 0xfd, 0x38, 0x90, 0x9b, 0xf8, 0x37, 0x40, 0x64, 0x79, 0x8b, 0xe7, 0xe4, 0xd3, 0xc5, 0x88, 0x26, 0xd7, 0x54, 0x92, 0x10 }
};

constexpr ENCRYPTED_STRING<sizeof(L"\\Registry\\Machine\\SOFTWARE\\Microsoft\\DRM")> EncryptedDllRegString =
{
	0x58cb67fa57e51c28,
	{ 0x7d, 0xf1, 0x45, 0xfd, 0x5, 0xee, 0xd, 0x8c, 0xde, 0x91, 0x2b, 0x15, 0xdf, 0x94, 0x50, 0xaf, 0xaa, 0x65, 0xb3, 0xf9, 0xb8, 0x3, 0x1f, 0xdc, 0xaa, 0xa, 0x7f, 0x7c, 0x51, 0xc7, 0x70, 0x56, 0xfe, 0x4f, 0x85, 0x90, 0x4, 0xd7, 0x4b, 0x37, 0xdf, 0x3b, 0x5c, 0xa6, 0xb, 0xce, 0x85, 0xb1, 0x71, 0xfd, 0xa7, 0xf6, 0xea, 0x24, 0x74, 0xd9, 0xe6, 0xb8, 0x64, 0x84, 0xc8, 0xd0, 0x2a, 0xa6, 0xaa, 0x9c, 0x54, 0x6e, 0x96, 0xbd, 0x98, 0xdd, 0xb6, 0xe9, 0xfe, 0x25, 0x5f, 0x92, 0xac, 0xdf, 0xdb, 0xee }
};

constexpr ENCRYPTED_STRING<sizeof(L"CSRSS.EXE")> EncryptedCsrssString =
{
	0x58cb67fa57e51c29,
	{ 0x2a, 0xf7, 0xb4, 0xee, 0x6a, 0x2, 0xb4, 0x96, 0x67, 0x95, 0xa1, 0x26, 0xcc, 0x8, 0xf6, 0x6f, 0x86, 0x35, 0x23, 0x5b }
};

constexpr ENCRYPTED_STRING<sizeof(L"\\SystemRoot\\System32\\ntdll.dll")> EncryptedNtdllPathString =
{
	0x58cb67fa57e51c2a,
	{ 0x22, 0x32, 0xe1, 0x24, 0x3a, 0x38, 0xc3, 0x0d, 0x75, 0xc6, 0xaa, 0xca, 0xf9, 0xcd, 0x2c, 0x50, 0x94, 0xdc, 0xe4, 0x74, 0x77, 0xd0, 0xf4, 0xbb, 0xa3, 0x53, 0x86, 0xe1, 0x1d, 0x15, 0x16, 0x3b, 0xc3, 0x4d, 0xd9, 0xb6, 0xfe, 0xa8, 0x02, 0xd8, 0xe7, 0x7e, 0xf0, 0xb4, 0xca, 0x40, 0xbf, 0xc8, 0x33, 0x7c, 0x51, 0xcf, 0x6e, 0x35, 0x22, 0x91, 0x6d, 0x62, 0xff, 0x92, 0xb1, 0x89 }
};

constexpr ENCRYPTED_STRING<sizeof("NtCreateThreadEx")> EncryptedNtCreateThreadExString =
{
	0x58cb67fa57e51c2b,
	{ 0xe4, 0x44, 0x1c, 0x03, 0x8f, 0x5b, 0x4c, 0x09, 0x50, 0x7d, 0x4a, 0xcd, 0xce, 0x90, 0x35, 0xf8, 0x2c }
};

constexpr ENCRYPTED_STRING<sizeof("NtResumeThread")> EncryptedNtResumeThreadString =
{
	0x58cb67fa57e51c2c,
	{ 0xf7, 0x40, 0x6b, 0x73, 0x9a, 0x14, 0x4f, 0xc9, 0x89, 0xde, 0x02, 0x1f, 0xaa, 0xc3, 0xb7 }
};

constexpr ENCRYPTED_STRING<sizeof("NtTerminateThread")> EncryptedNtTerminateThreadString =
{
	0x58cb67fa57e51c2d,
	{ 0x21, 0x3c, 0x5a, 0x5b, 0x97, 0xd4, 0xd0, 0xa0, 0x03, 0x5c, 0xc9, 0x05, 0x84, 0x55, 0xb9, 0x0f, 0xb8, 0x73 }
};

constexpr ENCRYPTED_STRING<sizeof("NtProtectVirtualMemory")> EncryptedNtProtectVirtualMemoryString =
{
	0x58cb67fa57e51c2e,
	{ 0xb1, 0xa2, 0x13, 0x8c, 0xa1, 0xd2, 0xe5, 0xf3, 0x2c, 0xc9, 0xf6, 0x4c, 0x92, 0x03, 0x57, 0x2b, 0xf5, 0x04, 0xf3, 0x50, 0x66, 0x05, 0x58 }
};

/* // String no longer used, but this nonce is taken
constexpr ENCRYPTED_STRING<sizeof("NtRemoveIoCompletion")> EncryptedNtRemoveIoCompletionString =
{
	0x58cb67fa57e51c2f,
	{ 0x48, 0x94, 0x1e, 0xe5, 0xac, 0xa7, 0xc3, 0x32, 0x10, 0x29, 0xf1, 0x4f, 0x02, 0x17, 0x8c, 0x1b, 0x82, 0x4e, 0x84, 0x37, 0x9c }
};
*/

constexpr ENCRYPTED_STRING<sizeof("RtlAddFunctionTable")> EncryptedRtlAddFunctionTableString =
{
	0x58cb67fa57e51c30,
	{ 0xe1, 0xfa, 0x6a, 0x5f, 0x5c, 0xeb, 0xfc, 0xaf, 0xe2, 0xc5, 0x26, 0x18, 0xef, 0x1e, 0x29, 0x59, 0xd3, 0x81, 0x58, 0x8b }
};

constexpr ENCRYPTED_STRING<sizeof("DbgUiRemoteBreakin")> EncryptedDbgUiRemoteBreakinString =
{
	0x58cb67fa57e51c31,
	{ 0x36, 0xbb, 0x0c, 0x49, 0xfa, 0x0f, 0x8c, 0x4f, 0xc8, 0xe1, 0x24, 0x40, 0x42, 0xb0, 0x52, 0x7b, 0xdc, 0x3a, 0x46 }
};

constexpr ENCRYPTED_STRING<sizeof(L"\\SystemRoot\\SysWOW64\\")> EncryptedSysWOW64PathString =
{
	0x58cb67fa57e51c32,
	{ 0x9c, 0xf8, 0xa5, 0x3e, 0x61, 0x87, 0xca, 0x2b, 0x7e, 0x30, 0x1d, 0x4c, 0xfb, 0xea, 0x71, 0xe8, 0x38, 0x40, 0x62, 0x55, 0x11, 0x66, 0x38, 0x37, 0x9f, 0x80, 0x71, 0x2d, 0x03, 0x0f, 0xf1, 0x06, 0x8f, 0x16, 0x51, 0x11, 0x5e, 0xb1, 0xe9, 0x13, 0xe6, 0xfc, 0x61, 0x5c }
};

constexpr ENCRYPTED_STRING<sizeof(L"\\SystemRoot\\System32\\")> EncryptedSystem32PathString =
{
	0x58cb67fa57e51c33,
	{ 0xbe, 0x71, 0x86, 0x54, 0xdc, 0x0a, 0x9f, 0xd1, 0xca, 0xc2, 0xf4, 0xc9, 0x4d, 0xb8, 0xa9, 0xb9, 0xa8, 0x72, 0x4c, 0x7c, 0xa9, 0x08, 0xdc, 0xf6, 0xbe, 0xdf, 0xc9, 0x6e, 0x19, 0x84, 0x30, 0x67, 0xd7, 0x59, 0x43, 0x42, 0x18, 0x2c, 0x13, 0x37, 0x4a, 0x88, 0xf8, 0x96 }
};

constexpr ENCRYPTED_STRING<sizeof(L"ntdll.dll")> EncryptedNtdllString =
{
	0x58cb67fa57e51c34,
	{ 0x1d, 0xee, 0xf0, 0x6a, 0x0d, 0x5e, 0xde, 0x27, 0xc2, 0x3f, 0xf3, 0x2a, 0xc4, 0x09, 0x6c, 0x89, 0x87, 0x6c, 0x4d, 0x5f }
};

constexpr ENCRYPTED_STRING<sizeof(L"EXENAME")> EncryptedExeNameString =
{
	0x58cb67fa57e51c35,
	{ 0x9f, 0xa0, 0x61, 0x4f, 0xec, 0xf7, 0x41, 0xc3, 0x77, 0x25, 0xf1, 0xd6, 0xd9, 0x5f, 0xdc, 0xf0 }
};

constexpr ENCRYPTED_STRING<sizeof(L"WAIT")> EncryptedWaitString =
{
	0x58cb67fa57e51c36,
	{ 0x44, 0x87, 0x83, 0xf2, 0x69, 0x6d, 0x9b, 0x14, 0x5d, 0xb5 }
};

constexpr ENCRYPTED_STRING<sizeof(L"DELETE")> EncryptedDeleteString =
{
	0x58cb67fa57e51c37,
	{ 0x4f, 0x62, 0x84, 0x6c, 0x5a, 0xf4, 0x54, 0x31, 0x4c, 0xc3, 0xff, 0x26, 0xe8, 0x72 }
};

constexpr ENCRYPTED_STRING<sizeof(L"DRVDEL")> EncryptedDriverDeleteString =
{
	0x58cb67fa57e51c38,
	{ 0x25, 0x40, 0x13, 0x9D, 0xC9, 0x09, 0x1A, 0x86, 0x85, 0x7E, 0x31, 0xF9, 0x95, 0x21 }
};

constexpr ENCRYPTED_STRING<sizeof("EtwpCreateEtwThread")> EncryptedEtwpCreateEtwThreadString =
{
	0x58cb67fa57e51c39,
	{ 0xCA, 0x17, 0xF3, 0x1E, 0x88, 0x24, 0x5A, 0xC6, 0x7B, 0x4B, 0x8E, 0x42, 0x06, 0xED, 0xBC, 0x63, 0xF0, 0x22, 0x51, 0x15 }
};

constexpr ENCRYPTED_STRING<sizeof("RtlActivateActivationContextEx")> EncryptedRtlActivateActivationContextExString =
{
	0x58cb67fa57e51c3a,
	{ 0xF6, 0x64, 0x4E, 0xA3, 0x04, 0xDA, 0x67, 0x09, 0xC0, 0xDF, 0x4C, 0x14, 0x78, 0x7C, 0x73, 0x66, 0x8F, 0x02, 0x44, 0xBA, 0x62, 0xDD, 0x13, 0xED, 0x43, 0x82, 0xF0, 0xE4, 0xE4, 0xEB, 0x47 }
};

constexpr ENCRYPTED_STRING<sizeof("RtlCreateActivationContext")> EncryptedRtlCreateActivationContextString =
{
	0x58cb67fa57e51c3b,
	{ 0x58, 0x73, 0x9B, 0x3B, 0xB4, 0x6F, 0x96, 0x89, 0x48, 0x4A, 0xF1, 0x91, 0x37, 0x75, 0xE3, 0x7A, 0x03, 0x9C, 0xAC, 0x9D, 0x82, 0xE9, 0x24, 0xC3, 0x1E, 0x6E, 0xDE }
};

constexpr ENCRYPTED_STRING<sizeof("RtlQueryActivationContextApplicationSettings")> EncryptedRtlQueryActivationContextApplicationSettingsString =
{
	0x58cb67fa57e51c3c,
	{ 0x8C, 0x56, 0x9C, 0xEC, 0x5C, 0xD9, 0x38, 0x0D, 0xF5, 0x63, 0x56, 0x99, 0x31, 0x84, 0xA9, 0x6B, 0x39, 0x0A, 0x4B, 0x37, 0x79, 0xE4, 0x93, 0xF5, 0x12, 0x5B, 0x18, 0x63, 0x1F, 0xB1, 0x1B, 0xDA, 0x9A, 0x57, 0x75, 0xF1, 0x13, 0x11, 0xA2, 0x49, 0xC3, 0x16, 0x11, 0x16, 0x6E }
};

constexpr ENCRYPTED_STRING<sizeof("RtlValidateHeap")> EncryptedRtlValidateHeapString =
{
	0x58cb67fa57e51c3d,
	{ 0x50, 0x0C, 0xAA, 0x00, 0x2B, 0xFA, 0x2B, 0x47, 0xD2, 0x35, 0xF6, 0x3D, 0x82, 0xB1, 0x16, 0x3B }
};

constexpr ENCRYPTED_STRING<sizeof("TpStartAsyncIoOperation")> EncryptedTpStartAsyncIoOperationString =
{
	0x58cb67fa57e51c3e,
	{ 0x4D, 0x84, 0xC1, 0x40, 0x52, 0xEB, 0x94, 0x1E, 0x90, 0x8F, 0x45, 0xD8, 0x18, 0x00, 0x0F, 0xF4, 0xBD, 0x04, 0x1C, 0x90, 0x5E, 0x15, 0xDD, 0x3A }
};

constexpr ENCRYPTED_STRING<sizeof("TpWaitForWork")> EncryptedTpWaitForWorkString =
{
	0x58cb67fa57e51c3f,
	{ 0x0E, 0xDB, 0x85, 0x55, 0x61, 0xCD, 0xBF, 0x88, 0x30, 0xF4, 0xF6, 0x9E, 0xBC, 0x45 }
};

constexpr ENCRYPTED_STRING<sizeof("WinSqmEventWrite")> EncryptedWinSqmEventWriteString =
{
	0x58cb67fa57e51c40,
	{ 0xDA, 0x61, 0x05, 0xFA, 0xDD, 0xEE, 0x9F, 0x5E, 0xBC, 0x8A, 0x09, 0x6B, 0xA2, 0xA8, 0xB5, 0x01, 0x80 }
};

constexpr ENCRYPTED_STRING<sizeof("PsSetCreateThreadNotifyRoutine")> EncryptedPsSetCreateThreadNotifyRoutineString =
{
	0x58cb67fa57e51c41,
	{ 0xCC, 0x8F, 0x89, 0xBF, 0xA6, 0x1F, 0xAE, 0xCD, 0x50, 0x04, 0x1D, 0x14, 0x73, 0x06, 0x08, 0x45, 0xB2, 0xCD, 0x69, 0xC8, 0x98, 0x1E, 0x6B, 0xAC, 0x07, 0x03, 0xDD, 0xB4, 0x48, 0x94, 0xDA }
};

constexpr ENCRYPTED_STRING<sizeof("PsLoadedModuleResource")> EncryptedPsLoadedModuleResourceString =
{
	0x58cb67fa57e51c42,
	{ 0xAF, 0xDA, 0xB9, 0xFB, 0xFD, 0x81, 0x6F, 0x30, 0x23, 0x09, 0xF0, 0x69, 0xB6, 0xEE, 0xF1, 0x01, 0x49, 0x34, 0x9B, 0x7A, 0x2E, 0x53, 0x68 }
};

constexpr ENCRYPTED_STRING<sizeof(L"AES")> EncryptedAESString =
{
	0x58cb67fa57e51c43,
	{ 0x7B, 0x95, 0x08, 0x17, 0x14, 0x96, 0xFC, 0x87 }
};

constexpr ENCRYPTED_STRING<sizeof(L"BlockLength")> EncryptedBlockLengthString =
{
	0x58cb67fa57e51c44,
	{ 0x42, 0x61, 0xF0, 0x32, 0x28, 0x5A, 0x61, 0xE1, 0x12, 0x08, 0xF2, 0xE2, 0xBB, 0x3A, 0x2E, 0x86, 0xAB, 0xBF, 0xEE, 0x8E, 0x20, 0xFB, 0xE1, 0x87 }
};

constexpr ENCRYPTED_STRING<sizeof(L"ChainingMode")> EncryptedChainingModeString =
{
	0x58cb67fa57e51c45,
	{ 0xE6, 0x49, 0x96, 0x95, 0x6B, 0x88, 0xD3, 0x87, 0x10, 0x1E, 0xB7, 0xA1, 0x16, 0x4C, 0x86, 0xA3, 0xE2, 0x40, 0x5F, 0x9C, 0xF2, 0x64, 0x3D, 0xB9, 0x0C, 0xD0 }
};

constexpr ENCRYPTED_STRING<sizeof(L"ChainingModeCBC")> EncryptedChainingModeCBCString =
{
	0x58cb67fa57e51c46,
	{ 0xDD, 0x47, 0x02, 0x42, 0x73, 0x16, 0xC8, 0x2B, 0x4D, 0x49, 0x67, 0x6B, 0xC1, 0x1D, 0x8E, 0xD5, 0x8B, 0x8A, 0xC1, 0x5A, 0xBB, 0xFA, 0xA7, 0x82, 0xF7, 0x06, 0xFD, 0x5E, 0x82, 0x90, 0xDE, 0xD4 }
};

constexpr ENCRYPTED_STRING<sizeof(L"ObjectLength")> EncryptedObjectLengthString =
{
	0x58cb67fa57e51c47,
	{ 0x4C, 0xA0, 0x35, 0x77, 0x8C, 0x2E, 0xC9, 0x42, 0xC9, 0x0B, 0x08, 0xD6, 0xCF, 0x6A, 0x7A, 0x6B, 0x55, 0x9A, 0x79, 0x7C, 0xD3, 0xE3, 0x4A, 0xD4, 0x64, 0x50 }
};

template<SIZE_T N>
FORCEINLINE
VOID
DecryptString(
	_In_ CONST ENCRYPTED_STRING<N>& Encrypted,
	_Out_ PCHAR Decrypted
	)
{
	constexpr ULONG32 Length = Encrypted.Length;
	PUCHAR Buffer[Length];

	RtlCopyMemory(Buffer, Encrypted.EncryptedData, Length);

	if (s20_crypt(const_cast<PUCHAR>(EncryptionKey),
		S20_KEYLEN_128,
		PUCHAR(&Encrypted.Nonce),
		0,
		reinterpret_cast<PUCHAR>(Buffer),
		Length) != S20_SUCCESS)
	{
		NT_ASSERT(FALSE);
	}

	RtlCopyMemory(Decrypted, Buffer, Length);
	RtlSecureZeroMemory(Buffer, Length);
}

template<SIZE_T N>
FORCEINLINE
VOID
DecryptString(
	_In_ CONST ENCRYPTED_STRING<N>& Encrypted,
	_Out_ PWCHAR Decrypted
	)
{
	DecryptString(Encrypted, reinterpret_cast<PCHAR>(Decrypted));
}

```

`MMInject/Utils.c`:

```c
#include "MMInject.h"
#include "Utils.h"

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, RtlAdjustProcessPrivilege)
#pragma alloc_text(PAGE, RegQueryValueString)
#pragma alloc_text(PAGE, RegQueryValueBoolean)
#pragma alloc_text(PAGE, RtlUnicodeStringEndsIn)
#pragma alloc_text(PAGE, RtlStripPath)
#pragma alloc_text(PAGE, RtlStripFilename)
#pragma alloc_text(PAGE, RtlFileExists)
#endif

#define RANDOM_SEED_INIT 0x3AF84E05
static ULONG RandomSeed = RANDOM_SEED_INIT;

ULONG
RtlNextRandom(
	_In_ ULONG Min,
	_In_ ULONG Max
	)
{
	if (RandomSeed == RANDOM_SEED_INIT)
		RandomSeed = static_cast<ULONG>(__rdtsc());

	const ULONG Scale = static_cast<ULONG>(MAXINT32) / (Max - Min);
	return RtlRandomEx(&RandomSeed) / Scale + Min;
}

static
FORCEINLINE
ULONG64
XorShift64(
	_Inout_ PULONG64 State
	)
{
	ULONG64 Val = *State;
	Val ^= Val << 13;
	Val ^= Val >> 7;
	Val ^= Val << 17;
	*State = Val;
	return Val;
}

VOID
RtlFillGarbageMemory(
	_In_ PVOID Destination,
	_In_ SIZE_T Size
	)
{
	ULONG64 State = __rdtsc();

	SIZE_T AlignedSize = (Size + sizeof(ULONG64) - 1) & ~(sizeof(ULONG64) - 1);
	if (AlignedSize > Size)
	{
		const PUCHAR NewDestination = static_cast<PUCHAR>(Destination) + sizeof(ULONG64) - (AlignedSize - Size);
		const SIZE_T Skip = NewDestination - static_cast<PUCHAR>(Destination);
		for (SIZE_T i = 0; i < Skip; ++i)
		{
			*(static_cast<PUCHAR>(Destination) + i) = reinterpret_cast<PUCHAR>(&State)[i];
		}
		Destination = NewDestination;
		AlignedSize -= sizeof(ULONG64);
	}

	for (SIZE_T i = 0; i < AlignedSize / sizeof(ULONG64); ++i)
	{
		static_cast<PULONG64>(Destination)[i] = XorShift64(&State);
	}
}

ULONG
GetPoolTag(
	)
{
	CONSTEXPR const ULONG PoolTags[] =
	{
		' prI',
		'+prI',
		'eliF',
		'atuM',
		'sFtN',
		'ameS',
		'RwtE',
		'nevE',
		' daV',
		'sdaV',
		'aCmM',
		'  oI',
		'tiaW',
		'eSmM',
		'CPLA',
		'GwtE',
		' ldM',
		'erhT',
		'cScC',
		'KgxD',
	};

	CONSTEXPR const ULONG NumPoolTags = ARRAYSIZE(PoolTags);
	const ULONG Index = RtlNextRandom(0, NumPoolTags);
	NT_ASSERT(Index <= NumPoolTags - 1);
	return PoolTags[Index];
}

NTSTATUS
RtlFuckingCopyMemory(
	_In_ PVOID Destination,
	_In_ CONST VOID* Source,
	_In_ ULONG Length
	)
{
	NTSTATUS Status;
	CSHORT OriginalMdlFlags = 0;
	PVOID Mapped = nullptr;

	const KIRQL Kirql = KeRaiseIrqlToDpcLevel();
	const SIZE_T MdlSize = sizeof(MDL) + sizeof(PFN_NUMBER) * ADDRESS_AND_SIZE_TO_SPAN_PAGES(Destination, Length);
#pragma prefast(push)
#pragma prefast(disable:__WARNING_MEMORY_LEAK, "False positive - IoFreeMdl frees this memory")
	PMDL Mdl = static_cast<PMDL>(ExAllocatePoolWithTag(NonPagedPoolNx, MdlSize, GetPoolTag()));
#pragma prefast(pop)
	if (Mdl == nullptr)
	{
		Status = STATUS_NO_MEMORY;
		goto finished;
	}
	RtlZeroMemory(Mdl, MdlSize);
	MmInitializeMdl(Mdl, Destination, Length);

#pragma prefast(push)
#pragma prefast(disable:__WARNING_MODIFYING_MDL, "Trust me, I'm a scientist")
	Mdl->MdlFlags |= MDL_IO_SPACE;
	MmBuildMdlForNonPagedPool(Mdl);
	Mdl->MdlFlags &= ~MDL_IO_SPACE;

	OriginalMdlFlags = Mdl->MdlFlags;
	Mdl->MdlFlags |= MDL_PAGES_LOCKED;
	Mdl->MdlFlags &= ~MDL_SOURCE_IS_NONPAGED_POOL;

	Mapped = MmMapLockedPagesSpecifyCache(Mdl,
										KernelMode,
										MmCached,
										nullptr,
										FALSE,
										HighPagePriority | MdlMappingNoExecute);
	if (Mapped == nullptr)
	{
		Status = STATUS_NONE_MAPPED;
		goto finished;
	}

	RtlCopyMemory(Mapped, Source, Length);
	Status = STATUS_SUCCESS;

finished:
	if (Mapped != nullptr)
		MmUnmapLockedPages(Mapped, Mdl);
	if (Mdl != nullptr)
	{
		Mdl->MdlFlags = OriginalMdlFlags;
		IoFreeMdl(Mdl);
	}
#pragma prefast(pop)

	KeLowerIrql(Kirql);

	return Status;
}

NTSTATUS
RtlAdjustProcessPrivilege(
	_In_ PEPROCESS Process,
	_In_ ULONG Privilege,
	_In_ BOOLEAN Enable
	)
{
	PAGED_CODE();

	const ULONG64 QuadPrivilege = (1ULL << static_cast<ULONG64>(Privilege));

	PTOKEN Token = static_cast<PTOKEN>(PsReferencePrimaryToken(Process));

	ExAcquireResourceExclusiveLite(Token->TokenLock, TRUE);

	PSEP_TOKEN_PRIVILEGES TokenPrivileges = &Token->Privileges;
	TokenPrivileges->Present |= QuadPrivilege;
	if ((TokenPrivileges->EnabledByDefault & QuadPrivilege) == 0)
	{
		if (Enable)
		{
			TokenPrivileges->Enabled |= QuadPrivilege;
		}
		else
		{
			TokenPrivileges->Enabled &= ~QuadPrivilege;
		}
	}

	ExReleaseResourceLite(Token->TokenLock);

	PsDereferencePrimaryToken(Token);

	return STATUS_SUCCESS;
}

NTSTATUS
RegQueryValueString(
	_In_ PWSTR KeyNameBuffer,
	_In_ PWSTR ValueNameBuffer,
	_Inout_ PUNICODE_STRING ValueString
	)
{
	PAGED_CODE();

	UNICODE_STRING KeyName, ValueName;
	RtlxInitUnicodeString(&KeyName, KeyNameBuffer);
	RtlxInitUnicodeString(&ValueName, ValueNameBuffer);
	OBJECT_ATTRIBUTES ObjectAttributes = RTL_CONSTANT_OBJECT_ATTRIBUTES(&KeyName, OBJ_CASE_INSENSITIVE | OBJ_KERNEL_HANDLE);
	HANDLE KeyHandle = nullptr;
	PKEY_VALUE_PARTIAL_INFORMATION KeyValuePartialInfo = nullptr;
	NTSTATUS Status = ZwOpenKey(&KeyHandle,
								KEY_ALL_ACCESS,
								&ObjectAttributes);
	if (!NT_SUCCESS(Status))
		return Status;

	ULONG Size;
	Status = ZwQueryValueKey(KeyHandle,
							&ValueName,
							KeyValuePartialInformation,
							nullptr,
							0,
							&Size);
	if (Status == STATUS_OBJECT_NAME_NOT_FOUND || Size == 0)
	{
		Status = STATUS_UNSUCCESSFUL;
		goto finished;
	}

	KeyValuePartialInfo = static_cast<PKEY_VALUE_PARTIAL_INFORMATION>(
		ExAllocatePoolWithTag(NonPagedPoolNx, Size, GetPoolTag()));
	Status = ZwQueryValueKey(KeyHandle,
							&ValueName,
							KeyValuePartialInformation,
							KeyValuePartialInfo,
							Size,
							&Size);
	if (!NT_SUCCESS(Status))
		goto finished;

	if (KeyValuePartialInfo == nullptr || KeyValuePartialInfo->Type != REG_SZ ||
		KeyValuePartialInfo->DataLength > ValueString->MaximumLength)
	{
		Status = STATUS_DATA_NOT_ACCEPTED;
		goto finished;
	}

	RtlZeroMemory(ValueString->Buffer, ValueString->MaximumLength);
	RtlCopyMemory(ValueString->Buffer, KeyValuePartialInfo->Data, KeyValuePartialInfo->DataLength);
	ValueString->Length = static_cast<USHORT>(KeyValuePartialInfo->DataLength) - sizeof(WCHAR);

finished:
	if (KeyHandle != nullptr)
		ObCloseHandle(KeyHandle, KernelMode);
	if (KeyValuePartialInfo != nullptr)
	{
		RtlSecureZeroMemory(KeyValuePartialInfo, KeyValuePartialInfo->DataLength);
		ExFreePool(KeyValuePartialInfo);
	}

	return Status;
}

NTSTATUS
RegQueryValueBoolean(
	_In_ PWSTR KeyNameBuffer,
	_In_ PWSTR ValueNameBuffer,
	_Out_ PBOOLEAN Value
	)
{
	PAGED_CODE();

	DECLARE_UNICODE_STRING_SIZE(ValueString, 2);
	DECLARE_UNICODE_STRING_SIZE(TrueString, 2);
	TrueString.Buffer[0] = L'1';
	TrueString.Buffer[1] = UNICODE_NULL;
	TrueString.Length = sizeof(L'1');

	const NTSTATUS Status = RegQueryValueString(KeyNameBuffer,
											ValueNameBuffer,
											&ValueString);
	*Value = RtlCompareUnicodeString(&ValueString,
									&TrueString,
									FALSE) == 0;
	return Status;
}

BOOLEAN
RtlUnicodeStringEndsIn(
	_In_ PCUNICODE_STRING String,
	_In_ PCUNICODE_STRING Substring
	)
{
	PAGED_CODE();

	if (Substring->Length > String->Length)
		return FALSE;

	const USHORT NumCharsDiff = (String->Length - Substring->Length) / sizeof(WCHAR);
	const PWCHAR EndOfString = String->Buffer + NumCharsDiff;
	return _wcsnicmp(EndOfString, Substring->Buffer, Substring->Length / sizeof(WCHAR)) == 0;
}

NTSTATUS
RtlStripPath(
	_In_ PUNICODE_STRING Path,
	_Out_ PUNICODE_STRING Name
	)
{
	PAGED_CODE();

	if (Path == nullptr || Name == nullptr)
		return STATUS_INVALID_PARAMETER;

	if (Path->Length < 2)
	{
		*Name = *Path;
		return STATUS_NOT_FOUND;
	}

	NTSTATUS Status = STATUS_NOT_FOUND;
	for (USHORT i = (Path->Length / sizeof(WCHAR)) - 1; i != 0; i--)
	{
		if (Path->Buffer[i] == L'\\' || Path->Buffer[i] == L'/')
		{
			Name->Buffer = &Path->Buffer[i + 1];
			Name->Length = Name->MaximumLength = Path->Length - (i + 1) * sizeof(WCHAR);
			Status = STATUS_SUCCESS;
			break;
		}
	}

	if (!NT_SUCCESS(Status))
		*Name = *Path;

	return Status;
}

NTSTATUS
RtlStripFilename(
	_In_ PUNICODE_STRING Path,
	_Out_ PUNICODE_STRING Directory
	)
{
	PAGED_CODE();

	if (Path == nullptr || Directory == nullptr)
		return STATUS_INVALID_PARAMETER;

	if (Path->Length < sizeof(WCHAR))
	{
		*Directory = *Path;
		return STATUS_NOT_FOUND;
	}

	for (USHORT i = (Path->Length / sizeof(WCHAR)) - 1; i != 0; i--)
	{
		if (Path->Buffer[i] == L'\\')
		{
			Directory->Length = Directory->MaximumLength = (i + 1) * sizeof(WCHAR);
			Directory->Buffer = Path->Buffer;
			return STATUS_SUCCESS;
		}
	}

	*Directory = *Path;
	return STATUS_NOT_FOUND;
}

NTSTATUS
RtlFileExists(
	_In_ PUNICODE_STRING NtPath
	)
{
	PAGED_CODE();

	OBJECT_ATTRIBUTES ObjectAttributes = RTL_CONSTANT_OBJECT_ATTRIBUTES(NtPath, OBJ_CASE_INSENSITIVE | OBJ_KERNEL_HANDLE);
	FILE_NETWORK_OPEN_INFORMATION FileInfo;
	const NTSTATUS Status = ZwQueryFullAttributesFile(&ObjectAttributes,
													&FileInfo);

	return ((FileInfo.FileAttributes & FILE_ATTRIBUTE_DIRECTORY) != 0)
		? STATUS_FILE_IS_A_DIRECTORY
		: Status;
}

```

`MMInject/Utils.h`:

```h
#pragma once

#include "MMInject.h"

#ifdef __cplusplus
extern "C" {
#endif

ULONG
RtlNextRandom(
	_In_ ULONG Min,
	_In_ ULONG Max
	);

VOID
RtlFillGarbageMemory(
	_In_ PVOID Destination,
	_In_ SIZE_T Size
	);

ULONG
GetPoolTag(
	);

NTSTATUS
RtlFuckingCopyMemory(
	_In_ PVOID Destination,
	_In_ CONST VOID* Source,
	_In_ ULONG Length
	);

NTSTATUS
RtlAdjustProcessPrivilege(
	_In_ PEPROCESS Process,
	_In_ ULONG Privilege,
	_In_ BOOLEAN Enable
	);

NTSTATUS
RegQueryValueString(
	_In_ PWSTR KeyNameBuffer,
	_In_ PWSTR ValueNameBuffer,
	_Inout_ PUNICODE_STRING ValueString
	);

NTSTATUS
RegQueryValueBoolean(
	_In_ PWSTR KeyNameBuffer,
	_In_ PWSTR ValueNameBuffer,
	_Out_ PBOOLEAN Value
	);

BOOLEAN
RtlUnicodeStringEndsIn(
	_In_ PCUNICODE_STRING String,
	_In_ PCUNICODE_STRING Substring
	);

NTSTATUS
RtlStripPath(
	_In_ PUNICODE_STRING Path,
	_Out_ PUNICODE_STRING Name
	);

NTSTATUS
RtlStripFilename(
	_In_ PUNICODE_STRING Path,
	_Out_ PUNICODE_STRING Directory
	);

NTSTATUS
RtlFileExists(
	_In_ PUNICODE_STRING NtPath
	);

inline
VOID
RtlxInitAnsiString(
	_Out_ PANSI_STRING DestinationString,
	_In_opt_ PCSZ SourceString
	)
{
	DestinationString->Buffer = const_cast<PCHAR>(SourceString);
	if (SourceString == nullptr)
	{
		DestinationString->Length = 0;
		DestinationString->MaximumLength = 0;
	}
	else
	{
		const USHORT Length = static_cast<USHORT>(strlen(SourceString));
		DestinationString->Length = Length;
		DestinationString->MaximumLength = Length + sizeof('\0');
	}
}

inline
VOID
RtlxInitUnicodeString(
	_Out_ PUNICODE_STRING DestinationString,
	_In_opt_ PCWSTR SourceString
	)
{
	DestinationString->Buffer = const_cast<PWSTR>(SourceString);
	if (SourceString == nullptr)
	{
		DestinationString->Length = 0;
		DestinationString->MaximumLength = 0;
	}
	else
	{
		const USHORT Length = static_cast<USHORT>(wcslen(SourceString) * sizeof(WCHAR));
		DestinationString->Length = Length;
		DestinationString->MaximumLength = Length + sizeof(UNICODE_NULL);
	}
}

inline
VOID
RtlxFreeUnicodeString(
	_Inout_ PUNICODE_STRING UnicodeString
	)
{
	if (UnicodeString->Buffer != nullptr)
	{
		ExFreePool(UnicodeString->Buffer);
		RtlZeroMemory(UnicodeString, sizeof(*UnicodeString));
	}
}

inline
VOID
RtlxCopyUnicodeString(
	_Out_ PUNICODE_STRING DestinationString,
	_In_opt_ PCUNICODE_STRING SourceString
	)
{
	if (SourceString == nullptr)
	{
		DestinationString->Length = 0;
		return;
	}

	const PWCHAR Src = SourceString->Buffer;
	const PWCHAR Dst = DestinationString->Buffer;
	ULONG N = SourceString->Length;
	if (static_cast<USHORT>(N) > DestinationString->MaximumLength)
	{
		N = DestinationString->MaximumLength;
	}

	DestinationString->Length = static_cast<USHORT>(N);
	RtlCopyMemory(Dst, Src, N);
	if ((DestinationString->Length + sizeof (WCHAR)) <= DestinationString->MaximumLength)
	{
		Dst[N / sizeof(WCHAR)] = UNICODE_NULL;
	}
}

#ifdef __cplusplus
}
#endif

```

`MMInject/VAD.c`:

```c
#include "MMInject.h"
#include "vad.h"
#include "BlackBone/VadHelpers.h"

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, ProtectVAD)
#pragma alloc_text(PAGE, FindVAD)
#pragma alloc_text(PAGE, HideVAD)
#pragma alloc_text(PAGE, DoesVADConflict)
#endif

extern DYNAMIC_DATA DynData;

ULONG MmProtectToValue[32] =
{
	PAGE_NOACCESS,
	PAGE_READONLY,
	PAGE_EXECUTE,
	PAGE_EXECUTE_READ,
	PAGE_READWRITE,
	PAGE_WRITECOPY,
	PAGE_EXECUTE_READWRITE,
	PAGE_EXECUTE_WRITECOPY,
	PAGE_NOACCESS,
	PAGE_NOCACHE | PAGE_READONLY,
	PAGE_NOCACHE | PAGE_EXECUTE,
	PAGE_NOCACHE | PAGE_EXECUTE_READ,
	PAGE_NOCACHE | PAGE_READWRITE,
	PAGE_NOCACHE | PAGE_WRITECOPY,
	PAGE_NOCACHE | PAGE_EXECUTE_READWRITE,
	PAGE_NOCACHE | PAGE_EXECUTE_WRITECOPY,
	PAGE_NOACCESS,
	PAGE_GUARD | PAGE_READONLY,
	PAGE_GUARD | PAGE_EXECUTE,
	PAGE_GUARD | PAGE_EXECUTE_READ,
	PAGE_GUARD | PAGE_READWRITE,
	PAGE_GUARD | PAGE_WRITECOPY,
	PAGE_GUARD | PAGE_EXECUTE_READWRITE,
	PAGE_GUARD | PAGE_EXECUTE_WRITECOPY,
	PAGE_NOACCESS,
	PAGE_WRITECOMBINE | PAGE_READONLY,
	PAGE_WRITECOMBINE | PAGE_EXECUTE,
	PAGE_WRITECOMBINE | PAGE_EXECUTE_READ,
	PAGE_WRITECOMBINE | PAGE_READWRITE,
	PAGE_WRITECOMBINE | PAGE_WRITECOPY,
	PAGE_WRITECOMBINE | PAGE_EXECUTE_READWRITE,
	PAGE_WRITECOMBINE | PAGE_EXECUTE_WRITECOPY
};

NTSTATUS
ProtectVAD(
	_In_ PEPROCESS Process,
	_In_ ULONG_PTR Address,
	_In_ ULONG Protection
	)
{
	PAGED_CODE();

	PMMVAD_SHORT VadShort = nullptr;
	const NTSTATUS Status = FindVAD(Process, Address, &VadShort);
	if (NT_SUCCESS(Status))
	{
#if NTDDI_VERSION >= NTDDI_WIN10
		const PMMVAD_SHORT_19H1 VadShort19H1 = reinterpret_cast<PMMVAD_SHORT_19H1>(VadShort);
		if (DynData.Version >= WINVER_10_19H1)
			VadShort19H1->u.VadFlags.Protection = Protection;
		else
			VadShort->u.VadFlags.Protection = Protection;
#else
		VadShort->u.VadFlags.Protection = Protection;
#endif
	}

	return Status;
}

NTSTATUS
FindVAD(
	_In_ PEPROCESS Process,
	_In_ ULONG_PTR Address,
	_Out_ PMMVAD_SHORT *Result
	)
{
	PAGED_CODE();

	const ULONG_PTR VpnStart = Address >> PAGE_SHIFT;
	const PMM_AVL_TABLE Table = reinterpret_cast<PMM_AVL_TABLE>(reinterpret_cast<PUCHAR>(Process) + DynData.VadRootOffset);
	PMM_AVL_NODE Node = GET_VAD_ROOT(Table);

	if (MiFindNodeOrParent(Table, VpnStart, &Node) == TableFoundNode)
	{
		*Result = reinterpret_cast<PMMVAD_SHORT>(Node);
		return STATUS_SUCCESS;
	}

	return STATUS_NOT_FOUND;
}

BOOLEAN
DoesVADConflict(
	_In_ PEPROCESS Process,
	_In_ ULONG_PTR StartingAddress,
	_In_ ULONG_PTR EndingAddress
	)
{
	PAGED_CODE();

	const ULONG_PTR StartVpn = StartingAddress >> PAGE_SHIFT;
	const ULONG_PTR EndVpn = EndingAddress >> PAGE_SHIFT;
	const PMM_AVL_TABLE Table = reinterpret_cast<PMM_AVL_TABLE>(reinterpret_cast<PUCHAR>(Process) + DynData.VadRootOffset);

	return MiCheckForConflictingVad(Table, StartVpn, EndVpn) != nullptr;
}

NTSTATUS
HideVAD(
	_In_ PEPROCESS Process,
	_In_ ULONG_PTR Address
	)
{
	PAGED_CODE();

	PMMVAD_SHORT VadShort = nullptr;
	const NTSTATUS Status = FindVAD(Process, Address, &VadShort);
	if (!NT_SUCCESS(Status))
		return Status;

#if NTDDI_VERSION >= NTDDI_WINBLUE
	RtlAvlRemoveNode(reinterpret_cast<PMM_AVL_TABLE>(reinterpret_cast<PUCHAR>(Process) + DynData.VadRootOffset), reinterpret_cast<PMMADDRESS_NODE>(VadShort));
#else
	MiRemoveNode(reinterpret_cast<PMMADDRESS_NODE>(VadShort), reinterpret_cast<PMM_AVL_TABLE>(reinterpret_cast<PUCHAR>(Process) + DynData.VadRootOffset));
#endif
	return STATUS_SUCCESS;
}

PMMPTE
GetPTEForVA(
	_In_ PVOID Address
	)
{
	if (DynData.Version >= WINVER_10_RS1)
	{
		const PMMPTE Pde = reinterpret_cast<PMMPTE>((((reinterpret_cast<ULONG_PTR>(Address) >> PDI_SHIFT) << PTE_SHIFT) & 0x3FFFFFF8ull) + DynData.DYN_PDE_BASE);
		if (Pde->u.Hard.LargePage)
			return Pde;

		return reinterpret_cast<PMMPTE>((((reinterpret_cast<ULONG_PTR>(Address) >> PTI_SHIFT) << PTE_SHIFT) & 0x7FFFFFFFF8ull) + DynData.DYN_PTE_BASE);
	}

	const PMMPTE Pde = MiGetPdeAddress(Address);
	if (Pde->u.Hard.LargePage)
		return Pde;

	return MiGetPteAddress(Address);
}

```

`MMInject/VMProtectDDK/VMProtectDDK.h`:

```h
#pragma once

#if OBFUSCATE
#define VMP_IMPORT __declspec(dllimport)
#else
#define VMP_IMPORT
#endif
#define VMP_API __stdcall
#define VMP_WCHAR wchar_t
#if OBFUSCATE
	#ifdef _WIN64
		#pragma comment(lib, "VMProtectDDK64.lib")
	#else
		#pragma comment(lib, "VMProtectDDK32.lib")
	#endif // _WIN64
#endif

#ifdef __cplusplus
extern "C" {
#endif

// protection
VMP_IMPORT void VMP_API VMProtectBegin(const char *);
VMP_IMPORT void VMP_API VMProtectBeginVirtualization(const char *);
VMP_IMPORT void VMP_API VMProtectBeginMutation(const char *);
VMP_IMPORT void VMP_API VMProtectBeginUltra(const char *);
VMP_IMPORT void VMP_API VMProtectBeginVirtualizationLockByKey(const char *);
VMP_IMPORT void VMP_API VMProtectBeginUltraLockByKey(const char *);
VMP_IMPORT void VMP_API VMProtectEnd(void);

// utils
VMP_IMPORT BOOLEAN VMP_API VMProtectIsProtected();
VMP_IMPORT BOOLEAN VMP_API VMProtectIsDebuggerPresent(BOOLEAN); // IRQL = PASSIVE_LEVEL
VMP_IMPORT BOOLEAN VMP_API VMProtectIsVirtualMachinePresent(void); // IRQL = PASSIVE_LEVEL
VMP_IMPORT BOOLEAN VMP_API VMProtectIsValidImageCRC(void);
VMP_IMPORT const char * VMP_API VMProtectDecryptStringA(const char *value);
VMP_IMPORT const VMP_WCHAR * VMP_API VMProtectDecryptStringW(const VMP_WCHAR *value);
VMP_IMPORT BOOLEAN VMP_API VMProtectFreeString(const void *value);

// licensing
enum VMProtectSerialStateFlags
{
	SERIAL_STATE_SUCCESS				= 0,
	SERIAL_STATE_FLAG_CORRUPTED			= 0x00000001,
	SERIAL_STATE_FLAG_INVALID			= 0x00000002,
	SERIAL_STATE_FLAG_BLACKLISTED		= 0x00000004,
	SERIAL_STATE_FLAG_DATE_EXPIRED		= 0x00000008,
	SERIAL_STATE_FLAG_RUNNING_TIME_OVER	= 0x00000010,
	SERIAL_STATE_FLAG_BAD_HWID			= 0x00000020,
	SERIAL_STATE_FLAG_MAX_BUILD_EXPIRED	= 0x00000040,
};

#pragma pack(push, 1)
typedef struct
{
	unsigned short	wYear;
	unsigned char	bMonth;
	unsigned char	bDay;
} VMProtectDate;

typedef struct
{
	int				nState;				// VMProtectSerialStateFlags
	VMP_WCHAR		wUserName[256];		// user name
	VMP_WCHAR		wEMail[256];		// email
	VMProtectDate	dtExpire;			// date of serial number expiration
	VMProtectDate	dtMaxBuild;			// max date of build, that will accept this key
	int				bRunningTime;		// running time in minutes
	unsigned char	nUserDataLength;	// length of user data in bUserData
	unsigned char	bUserData[255];		// up to 255 bytes of user data
} VMProtectSerialNumberData;
#pragma pack(pop)

VMP_IMPORT int VMP_API VMProtectSetSerialNumber(const char *serial);
VMP_IMPORT int VMP_API VMProtectGetSerialNumberState();
VMP_IMPORT BOOLEAN VMP_API VMProtectGetSerialNumberData(VMProtectSerialNumberData *data, int size);
VMP_IMPORT int VMP_API VMProtectGetCurrentHWID(char *hwid, int size);

// activation
enum VMProtectActivationFlags
{
	ACTIVATION_OK = 0,
	ACTIVATION_SMALL_BUFFER,
	ACTIVATION_NO_CONNECTION,
	ACTIVATION_BAD_REPLY,
	ACTIVATION_BANNED,
	ACTIVATION_CORRUPTED,
	ACTIVATION_BAD_CODE,
	ACTIVATION_ALREADY_USED,
	ACTIVATION_SERIAL_UNKNOWN,
	ACTIVATION_EXPIRED,
	ACTIVATION_NOT_AVAILABLE
};

VMP_IMPORT int VMP_API VMProtectActivateLicense(const char *code, char *serial, int size);
VMP_IMPORT int VMP_API VMProtectDeactivateLicense(const char *serial);
VMP_IMPORT int VMP_API VMProtectGetOfflineActivationString(const char *code, char *buf, int size);
VMP_IMPORT int VMP_API VMProtectGetOfflineDeactivationString(const char *serial, char *buf, int size);

#ifdef __cplusplus
}
#endif

```

`MMInject/VMProtectDDK/VMProtectDDK.patch`:

```patch
API patches to make the VMP API work (or not) depending on #if OBFUSCATE
--- VMProtectDDK.h	2018-09-19 18:24:49.603500000 +0200
+++ VMProtectDDK.h	2018-09-19 18:25:02.554500000 +0200
@@ -1,13 +1,19 @@
 #pragma once
 
+#if OBFUSCATE
 #define VMP_IMPORT __declspec(dllimport)
+#else
+#define VMP_IMPORT
+#endif
 #define VMP_API __stdcall
 #define VMP_WCHAR wchar_t
-#ifdef _WIN64
-	#pragma comment(lib, "VMProtectDDK64.lib")
-#else
-	#pragma comment(lib, "VMProtectDDK32.lib")
-#endif // _WIN64
+#if OBFUSCATE
+	#ifdef _WIN64
+		#pragma comment(lib, "VMProtectDDK64.lib")
+	#else
+		#pragma comment(lib, "VMProtectDDK32.lib")
+	#endif // _WIN64
+#endif
 
 #ifdef __cplusplus
 extern "C" {

```

`MMInject/VMProtectDDK/VMProtectStub.h`:

```h
#pragma once

#include "VMProtectDDK.h"

#undef VMP_IMPORT
#define VMP_IMPORT inline

#ifdef __cplusplus
extern "C" {
#endif

VMP_IMPORT void VMP_API VMProtectBegin(const char *) { }
VMP_IMPORT void VMP_API VMProtectBeginVirtualization(const char *) { }
VMP_IMPORT void VMP_API VMProtectBeginMutation(const char *) { }
VMP_IMPORT void VMP_API VMProtectBeginUltra(const char *) { }
VMP_IMPORT void VMP_API VMProtectBeginVirtualizationLockByKey(const char *) { }
VMP_IMPORT void VMP_API VMProtectBeginUltraLockByKey(const char *) { }
VMP_IMPORT void VMP_API VMProtectEnd(void) { }

VMP_IMPORT BOOLEAN VMP_API VMProtectIsProtected() { return FALSE; }
VMP_IMPORT BOOLEAN VMP_API VMProtectIsDebuggerPresent(BOOLEAN) { return FALSE; }
VMP_IMPORT BOOLEAN VMP_API VMProtectIsVirtualMachinePresent(void) { return FALSE; }
VMP_IMPORT BOOLEAN VMP_API VMProtectIsValidImageCRC(void) { return TRUE; }
VMP_IMPORT const char * VMP_API VMProtectDecryptStringA(const char *value) { return value; }
VMP_IMPORT const VMP_WCHAR * VMP_API VMProtectDecryptStringW(const VMP_WCHAR *value) { return value; }
VMP_IMPORT BOOLEAN VMP_API VMProtectFreeString(const void *value) { UNREFERENCED_PARAMETER(value); return TRUE; }

VMP_IMPORT int VMP_API VMProtectSetSerialNumber(const char *serial) { UNREFERENCED_PARAMETER(serial); return SERIAL_STATE_SUCCESS; }
VMP_IMPORT int VMP_API VMProtectGetSerialNumberState() { return SERIAL_STATE_SUCCESS; }
VMP_IMPORT BOOLEAN VMP_API VMProtectGetSerialNumberData(VMProtectSerialNumberData *data, int size) { if (size >= (int)sizeof(VMProtectSerialStateFlags)) data->nState = SERIAL_STATE_SUCCESS; return TRUE; }
VMP_IMPORT int VMP_API VMProtectGetCurrentHWID(char *hwid, int size)
{
	if (hwid != NULL && size > 0)
		*hwid = '\0';
	return sizeof('\0');
}

VMP_IMPORT int VMP_API VMProtectActivateLicense(const char *code, char *serial, int size)
{
	UNREFERENCED_PARAMETER(code); UNREFERENCED_PARAMETER(serial); UNREFERENCED_PARAMETER(size); return ACTIVATION_OK;
}
VMP_IMPORT int VMP_API VMProtectDeactivateLicense(const char *serial) { UNREFERENCED_PARAMETER(serial); return ACTIVATION_OK; }
VMP_IMPORT int VMP_API VMProtectGetOfflineActivationString(const char *code, char *buf, int size)
{
	if (code != NULL && buf != NULL && size > 0)
		*buf = '\0';
	return sizeof('\0');
}
VMP_IMPORT int VMP_API VMProtectGetOfflineDeactivationString(const char *serial, char *buf, int size)
{
	if (serial != NULL && buf != NULL && size > 0)
		*buf = '\0';
	return sizeof('\0');
}

#ifdef __cplusplus
}
#endif

```

`MMInject/main.c`:

```c
#include "MMInject.h"
#include "util.h"
#include "strings.h"
#include <stdarg.h>
#include <stdio.h>

#define DEALLOCATE_ON_UNLOAD	0

typedef struct _INJECT_DLL_PARAMS
{
	ULONG Pid;
	UNICODE_STRING ProcessName;
	UNICODE_STRING DllPath;
	BOOLEAN DeleteDll;
	BOOLEAN WaitForProcess;
	BOOLEAN WipePeHeaders;

	_INJECT_DLL_PARAMS() = default;

	VOID Init()
	{
		Pid = 0;
		ProcessName = { 0, sizeof(ProcessNameBuffer), ProcessNameBuffer };
		DllPath = { 0, sizeof(DllPathBuffer), DllPathBuffer };
		DeleteDll = FALSE;
		WaitForProcess = FALSE;
		WipePeHeaders = TRUE;
	}

private:
	WCHAR ProcessNameBuffer[MAX_PATH];
	WCHAR DllPathBuffer[MAX_PATH];
} INJECT_DLL_PARAMS, *PINJECT_DLL_PARAMS;

static
BOOLEAN
IsDriverExpired(
	);

static
BOOLEAN
DeletePiDDBCacheTableEntry(
	_In_ PUNICODE_STRING DriverFileName,
	_In_opt_ ULONG DriverTimeDateStamp
	);

static
VOID
CleanMmUnloadedDrivers(
	);

static
BOOLEAN
DestroyDriverFile(
	_In_ PDRIVER_OBJECT DriverObject
	);

static
BOOLEAN
DestroyDriverInformation(
	_In_ PDRIVER_OBJECT DriverObject
	);

#ifdef ALLOC_PRAGMA
#pragma alloc_text(INIT, InitDynamicData)
#pragma alloc_text(INIT, IsDriverExpired)
#pragma alloc_text(INIT, DriverEntry)
#pragma alloc_text(PAGE, InjectDllWorker)
#pragma alloc_text(PAGE, DeletePiDDBCacheTableEntry)
#pragma alloc_text(PAGE, CleanMmUnloadedDrivers)
#pragma alloc_text(PAGE, CleanMmUnloadedDriversWorker)
#pragma alloc_text(PAGE, DestroyDriverFile)
#pragma alloc_text(PAGE, DestroyDriverInformation)
#pragma alloc_text(PAGE, DriverUnload)
#endif

extern PVOID RegionBase, MappedPages;
extern PMDL Mdl;
extern ULONG_PTR NtoskrnlBase;

DYNAMIC_DATA DynData;
t_NtCreateThreadEx NtCreateThreadEx = nullptr;
t_NtResumeThread NtResumeThread = nullptr;
t_NtTerminateThread NtTerminateThread = nullptr;
t_NtProtectVirtualMemory NtProtectVirtualMemory = nullptr;

static INJECT_DLL_PARAMS InjectDllParameters;
static KEVENT UnloadAllowed;

#if !OBFUSCATE
VOID
Printf(
	_In_ PCCH Format,
	_In_ ...
	)
{
	CHAR Message[512];
	va_list VaList;
	va_start(VaList, Format);
	const ULONG N = _vsnprintf_s(Message, sizeof(Message), Format, VaList);
	Message[N] = '\0';
	vDbgPrintExWithPrefix("[INJECTOR] ", DPFLTR_IHVDRIVER_ID, DPFLTR_ERROR_LEVEL, Message, VaList);
	va_end(VaList);
}
#endif

NTSTATUS
InitDynamicData(
	_Out_ PDYNAMIC_DATA Data
	)
{
	RtlZeroMemory(Data, sizeof(*Data));
	Data->DYN_PDE_BASE = PDE_BASE;
	Data->DYN_PTE_BASE = PTE_BASE;

	RTL_OSVERSIONINFOEXW VersionInfo = { sizeof(RTL_OSVERSIONINFOEXW) };
	NTSTATUS Status = RtlGetVersion(reinterpret_cast<PRTL_OSVERSIONINFOW>(&VersionInfo));
	if (!NT_SUCCESS(Status))
		return Status;
	ULONG ShortVersion = (VersionInfo.dwMajorVersion << 8) | (VersionInfo.dwMinorVersion << 4) | VersionInfo.wServicePackMajor;
	Data->Version = static_cast<WinVer>(ShortVersion);

	if (ShortVersion < WINVER_7 || ShortVersion == WINVER_8)
		return STATUS_NOT_SUPPORTED;
#if NTDDI_VERSION == NTDDI_WIN7
	if (ShortVersion != WINVER_7 && ShortVersion != WINVER_7_SP1)
		return STATUS_NOT_SUPPORTED;
#elif NTDDI_VERSION == NTDDI_WINBLUE
	if (ShortVersion != WINVER_81)
		return STATUS_NOT_SUPPORTED;
#elif NTDDI_VERSION >= NTDDI_WIN10 && NTDDI_VERSION <= NTDDI_WIN10_19H1
	if (ShortVersion != WINVER_10 || VersionInfo.dwBuildNumber < 16299)
		return STATUS_NOT_SUPPORTED;
#else
	#error Unsupported OS build version
#endif

	Status = LocatePspNotifyEnableMask(Data);
	if (!NT_SUCCESS(Status))
		return Status;

	Status = LocateMmUnloadedDrivers(Data);
	if (!NT_SUCCESS(Status))
		return Status;

	Status = LocatePiDDBCacheTable(Data);
	if (!NT_SUCCESS(Status))
		return Status;

	if (VersionInfo.dwBuildNumber <= 15063)
	{
		// These only exist in Win 10 RS3+
		Data->MitigationFlagsOffset = 0;
		Data->MitigationFlags2Offset = 0;
	}

	switch (ShortVersion)
	{
	// Windows 7
	// Windows 7 SP1
	case WINVER_7:
	case WINVER_7_SP1:
		Data->ProtectionOffset = 0x43C; // Bitfield, bit index - 0xB
		Data->ObjectTableOffset = 0x200;
		Data->EProcessFlagsOffset = 0x440;
		Data->EProcessFlags2Offset = 0x43C;
		Data->VadRootOffset = 0x448;
		Data->PreviousModeOffset = 0x1F6;
		break;

	// Windows 8.1
	case WINVER_81:
		Data->ProtectionOffset = 0x67A;
		Data->ObjectTableOffset = 0x408;
		Data->EProcessFlagsOffset = 0x2FC;
		Data->EProcessFlags2Offset = 0x2F8;
		Data->VadRootOffset = 0x5D8;
		Data->PreviousModeOffset = 0x232;
		break;
	
	case WINVER_10:
		// Windows 10, build 16299/17134/17763
		if (VersionInfo.dwBuildNumber == 16299 || VersionInfo.dwBuildNumber == 17134 || VersionInfo.dwBuildNumber == 17763)
		{
			Data->Version = VersionInfo.dwBuildNumber == 16299 ? WINVER_10_RS3 : (VersionInfo.dwBuildNumber == 17134 ? WINVER_10_RS4 : WINVER_10_RS5);
			Data->ProtectionOffset = 0x6CA;
			Data->ObjectTableOffset = 0x418;
			Data->EProcessFlagsOffset = 0x304;
			Data->EProcessFlags2Offset = 0x300;
			Data->MitigationFlagsOffset = VersionInfo.dwBuildNumber <= 17134 ? 0x828 : 0x820;
			Data->MitigationFlags2Offset = VersionInfo.dwBuildNumber <= 17134 ? 0x82C : 0x824;
			Data->VadRootOffset = 0x628;
			Data->PreviousModeOffset = 0x232;
			Status = LocatePageTables(Data);
			break;
		}
		// Windows 10 19H1
		if (VersionInfo.dwBuildNumber == 18362)
		{
			Data->Version = WINVER_10_19H1;
			Data->ProtectionOffset = 0x6FA;
			Data->ObjectTableOffset = 0x418;
			Data->EProcessFlagsOffset = 0x30C;
			Data->EProcessFlags2Offset = 0x308;
			Data->MitigationFlagsOffset = 0x850;
			Data->MitigationFlags2Offset = 0x854;
			Data->VadRootOffset = 0x658;
			Data->PreviousModeOffset = 0x232;
			Status = LocatePageTables(Data);
			break;
		}
		return STATUS_NOT_SUPPORTED;
	default:
		break;
	}

	return Data->VadRootOffset != 0
		? Status
		: STATUS_INVALID_KERNEL_INFO_VERSION;
}

static
BOOLEAN
IsDriverExpired(
	)
{
	TIME_FIELDS ExpirationDate;
	RtlZeroMemory(&ExpirationDate, sizeof(ExpirationDate));
	ExpirationDate.Year = 2020;
	ExpirationDate.Month = 01;
	ExpirationDate.Day = 01;

	LARGE_INTEGER ExpirationTime;
	if (!RtlTimeFieldsToTime(&ExpirationDate, &ExpirationTime))
		return TRUE;

	LARGE_INTEGER CurrentTime;
	KeQuerySystemTime(&CurrentTime);
	if ((CurrentTime.QuadPart > ExpirationTime.QuadPart))
		return TRUE;

	return FALSE;
}

static
BOOLEAN
DeletePiDDBCacheTableEntry(
	_In_ PUNICODE_STRING DriverFileName,
	_In_opt_ ULONG DriverTimeDateStamp
	)
{
	PAGED_CODE();

	PIDDBCACHE_ENTRY LookupEntry;
	RtlZeroMemory(&LookupEntry, sizeof(LookupEntry));
	LookupEntry.DriverName = *DriverFileName;
	LookupEntry.TimeDateStamp = DriverTimeDateStamp;

	if (DynData.PiDDBLock != nullptr)
		ExAcquireResourceExclusiveLite(DynData.PiDDBLock, TRUE);

	const PVOID OldTableContext = DynData.PiDDBCacheTable->TableContext;
	if (DriverTimeDateStamp == 0)
		DynData.PiDDBCacheTable->TableContext = reinterpret_cast<PVOID>(1);

	BOOLEAN Deleted = FALSE;
	const PPIDDBCACHE_ENTRY FoundEntry = static_cast<PPIDDBCACHE_ENTRY>(RtlLookupElementGenericTableAvl(DynData.PiDDBCacheTable, &LookupEntry));
	if (FoundEntry != nullptr)
	{
		RemoveEntryList(&FoundEntry->List);
		Deleted = RtlDeleteElementGenericTableAvl(DynData.PiDDBCacheTable, FoundEntry);
		if (Deleted)
		{
			ExFreePool(FoundEntry->DriverName.Buffer);
		}
	}

	DynData.PiDDBCacheTable->TableContext = OldTableContext;

	if (DynData.PiDDBLock != nullptr)
		ExReleaseResourceLite(DynData.PiDDBLock);
	
	return Deleted;
}

static
VOID
CleanMmUnloadedDrivers(
	)
{
	PAGED_CODE();

	ULONG NumberOfUnloadedModules = *DynData.MmLastUnloadedDriver;
	if (NumberOfUnloadedModules == 0)
	{
		Printf("MmLastUnloadedDriver is 0: no modules in MmUnloadedDrivers\n");
		return;
	}
	if (NumberOfUnloadedModules == 1)
	{
		Printf("MmLastUnloadedDriver is 1: leaving this driver alone\n");
		return;
	}

	CHAR PsLoadedModuleResourceName[decltype(EncryptedPsLoadedModuleResourceString)::Length];
	DecryptString(EncryptedPsLoadedModuleResourceString, PsLoadedModuleResourceName);
	const PERESOURCE PsLoadedModuleResource = static_cast<PERESOURCE>(GetProcedureAddress(NtoskrnlBase, PsLoadedModuleResourceName));
	RtlSecureZeroMemory(PsLoadedModuleResourceName, decltype(EncryptedPsLoadedModuleResourceString)::Length);

	KeEnterGuardedRegion();

	if (PsLoadedModuleResource != nullptr)
		ExAcquireResourceExclusiveLite(PsLoadedModuleResource, TRUE);

	NumberOfUnloadedModules = *DynData.MmLastUnloadedDriver;

	const PUNLOADED_DRIVER UnloadedDrivers = *DynData.MmUnloadedDrivers;
	Printf("CleanMmUnloadedDrivers: UNLOADED_DRIVER[%u] start address: 0x%p\n", NumberOfUnloadedModules, UnloadedDrivers);

	const ULONG Start = NumberOfUnloadedModules > 5 ? NumberOfUnloadedModules - 5 : 1;
	const ULONG End = max(1, NumberOfUnloadedModules);
	for (ULONG i = Start; i < End; ++i)
	{
		if (UnloadedDrivers[i].Name.Buffer == nullptr)
			continue;

		Printf("CleanMmUnloadedDrivers: [i=%u] %wZ. Start: 0x%p, end: 0x%p. Removing...\n", i,
			&UnloadedDrivers[i].Name, UnloadedDrivers[i].StartAddress, UnloadedDrivers[i].EndAddress);

		if (!DeletePiDDBCacheTableEntry(&UnloadedDrivers[i].Name, 0))
			Printf("WARNING: failed to delete %wZ from PiDDBCacheTable!\n", &UnloadedDrivers[i].Name);

		RtlSecureZeroMemory(UnloadedDrivers[i].Name.Buffer, UnloadedDrivers[i].Name.MaximumLength);
		UnloadedDrivers[i].Name.Length = UnloadedDrivers[i].Name.MaximumLength = 0;
		ExFreePoolWithTag(UnloadedDrivers[i].Name.Buffer, 'TDmM');
		UnloadedDrivers[i].Name.Buffer = nullptr;

		(*DynData.MmLastUnloadedDriver)--;
	}

	if (PsLoadedModuleResource != nullptr)
		ExReleaseResourceLite(PsLoadedModuleResource);

	KeLeaveGuardedRegion();
}

NTSTATUS
DriverEntry(
	_In_ PDRIVER_OBJECT DriverObject,
	_In_ PUNICODE_STRING RegistryPath
	)
{
	UNREFERENCED_PARAMETER(RegistryPath);

	PAGED_CODE();

	WCHAR DllRegKey[decltype(EncryptedDllRegString)::Length], DriverDeleteRegValue[decltype(EncryptedDriverDeleteString)::Length];
	DecryptString(EncryptedDllRegString, DllRegKey);
	DecryptString(EncryptedDriverDeleteString, DriverDeleteRegValue);
	BOOLEAN DeleteDriver = FALSE;
	if (NT_SUCCESS(RegQueryValueBoolean(DllRegKey,
										DriverDeleteRegValue,
										&DeleteDriver))
		&& DeleteDriver)
	{
		if (!DestroyDriverFile(DriverObject))
		{
			Printf("Failed to delete driver file!\n");
			return STATUS_DRIVER_UNABLE_TO_LOAD;
		}
	}

	RtlSecureZeroMemory(DriverDeleteRegValue, decltype(EncryptedDriverDeleteString)::Length);

	if (IsDriverExpired())
		return STATUS_ACCESS_DENIED;

	KeInitializeEvent(&UnloadAllowed,
						NotificationEvent,
						FALSE);

	NTSTATUS Status = InitDynamicData(&DynData);
	if (!NT_SUCCESS(Status))
	{
		Printf("Failed to initialize dynamic data: %08X\n", Status);
		return Status;
	}

	Status = SsdtInitialize();
	if (!NT_SUCCESS(Status))
	{
		Printf("Failed to initialize SSDT: %08X\n", Status);
		return Status;
	}

	CHAR NtCreateThreadExName[decltype(EncryptedNtCreateThreadExString)::Length];
	DecryptString(EncryptedNtCreateThreadExString, NtCreateThreadExName);
	NtCreateThreadEx = reinterpret_cast<t_NtCreateThreadEx>(GetSyscallAddress(NtCreateThreadExName));
	RtlSecureZeroMemory(NtCreateThreadExName, decltype(EncryptedNtCreateThreadExString)::Length);

	CHAR NtResumeThreadName[decltype(EncryptedNtResumeThreadString)::Length];
	DecryptString(EncryptedNtResumeThreadString, NtResumeThreadName);
	NtResumeThread = reinterpret_cast<t_NtResumeThread>(GetSyscallAddress(NtResumeThreadName));
	RtlSecureZeroMemory(NtResumeThreadName, decltype(EncryptedNtResumeThreadString)::Length);

	CHAR NtTerminateThreadName[decltype(EncryptedNtTerminateThreadString)::Length];
	DecryptString(EncryptedNtTerminateThreadString, NtTerminateThreadName);
	NtTerminateThread = reinterpret_cast<t_NtTerminateThread>(GetSyscallAddress(NtTerminateThreadName));
	RtlSecureZeroMemory(NtTerminateThreadName, decltype(EncryptedNtTerminateThreadString)::Length);

	CHAR NtProtectVirtualMemoryName[decltype(EncryptedNtProtectVirtualMemoryString)::Length];
	DecryptString(EncryptedNtProtectVirtualMemoryString, NtProtectVirtualMemoryName);
	NtProtectVirtualMemory = reinterpret_cast<t_NtProtectVirtualMemory>(GetSyscallAddress(NtProtectVirtualMemoryName));
	RtlSecureZeroMemory(NtProtectVirtualMemoryName, decltype(EncryptedNtProtectVirtualMemoryString)::Length);

	if (NtCreateThreadEx == nullptr || NtResumeThread == nullptr || NtTerminateThread == nullptr || NtProtectVirtualMemory == nullptr)
	{
		SsdtUninitialize();
		return STATUS_PROCEDURE_NOT_FOUND;
	}

	RtlSecureZeroMemory(&InjectDllParameters, sizeof(InjectDllParameters));
	InjectDllParameters.Init();

	WCHAR System32Path[decltype(EncryptedSystem32PathString)::Length];
	UNICODE_STRING System32FileName = { decltype(EncryptedSystem32PathString)::Length - sizeof(WCHAR), decltype(EncryptedSystem32PathString)::Length, System32Path };

	WCHAR DllRegValue[decltype(EncryptedDllString)::Length],
		DeleteRegValue[decltype(EncryptedDeleteString)::Length];
	DecryptString(EncryptedDllString, DllRegValue);
	DecryptString(EncryptedDeleteString, DeleteRegValue);

	DECLARE_UNICODE_STRING_SIZE(ProcessId, 16);
	Status = RegQueryValueString(DllRegKey,
								DllRegValue,
								&InjectDllParameters.DllPath);
	if (NT_SUCCESS(Status))
	{
		Status = RegQueryValueBoolean(DllRegKey,
								DeleteRegValue,
								&InjectDllParameters.DeleteDll);
	}

	RtlSecureZeroMemory(DllRegKey, decltype(EncryptedDllRegString)::Length);
	RtlSecureZeroMemory(DllRegValue, decltype(EncryptedDllString)::Length);
	RtlSecureZeroMemory(DeleteRegValue, decltype(EncryptedDeleteString)::Length);
	if (!NT_SUCCESS(Status))
		goto finished;

	WCHAR ExeRegKey[decltype(EncryptedExeRegString)::Length], ExeRegValue[decltype(EncryptedExeString)::Length],
		ExeRegNameValue[decltype(EncryptedExeNameString)::Length], WaitForProcessRegValue[decltype(EncryptedWaitString)::Length];
	DecryptString(EncryptedExeRegString, ExeRegKey);
	DecryptString(EncryptedExeString, ExeRegValue);
	DecryptString(EncryptedExeNameString, ExeRegNameValue);
	DecryptString(EncryptedWaitString, WaitForProcessRegValue);
	Status = RegQueryValueString(ExeRegKey,
								ExeRegValue,
								&ProcessId);
	if (NT_SUCCESS(Status))
		Status = RtlUnicodeStringToInteger(&ProcessId, 10, &InjectDllParameters.Pid);

	if (InjectDllParameters.Pid == 0)
	{
		Status = RegQueryValueString(ExeRegKey,
									ExeRegNameValue,
									&InjectDllParameters.ProcessName);
		if (NT_SUCCESS(Status))
		{
			Status = RegQueryValueBoolean(ExeRegKey,
										WaitForProcessRegValue,
										&InjectDllParameters.WaitForProcess);
		}
	}

	RtlSecureZeroMemory(ExeRegKey, decltype(EncryptedExeRegString)::Length);
	RtlSecureZeroMemory(ExeRegValue, decltype(EncryptedExeString)::Length);
	RtlSecureZeroMemory(ExeRegNameValue, decltype(EncryptedExeNameString)::Length);
	RtlSecureZeroMemory(WaitForProcessRegValue, decltype(EncryptedWaitString)::Length);
	if (!NT_SUCCESS(Status))
		goto finished;

	DecryptString(EncryptedSystem32PathString, System32FileName.Buffer);
	const PDEVICE_OBJECT System32FsDevice = IopGetBaseFsDeviceObject(&System32FileName);
	if (System32FsDevice == nullptr)
	{
		Printf("Failed to get base FS device object for %wZ needed to queue work item. Aborting\n", &System32FileName);
		Status = STATUS_NOT_FOUND;
		goto finished;
	}
	const PIO_WORKITEM InjectDllWorkItem = IoAllocateWorkItem(System32FsDevice);
	const PIO_WORKITEM CleanMmUnloadedDriversWorkItem = IoAllocateWorkItem(System32FsDevice);
	RtlSecureZeroMemory(System32FileName.Buffer, decltype(EncryptedSystem32PathString)::Length);
	ObfDereferenceObject(System32FsDevice);
	if (InjectDllWorkItem == nullptr || CleanMmUnloadedDriversWorkItem == nullptr)
	{
		Status = STATUS_NO_MEMORY;
		goto finished;
	}

	InjectDllParameters.WipePeHeaders = TRUE;
	IoQueueWorkItemEx(InjectDllWorkItem,
					InjectDllWorker,
					CriticalWorkQueue,
					&InjectDllParameters);

	IoQueueWorkItemEx(CleanMmUnloadedDriversWorkItem,
					CleanMmUnloadedDriversWorker,
					CriticalWorkQueue,
					&UnloadAllowed);

	DriverObject->DriverUnload = DriverUnload;

finished:
	if (!NT_SUCCESS(Status))
	{
		KeSetEvent(&UnloadAllowed,
					EVENT_INCREMENT,
					FALSE);
		DriverUnload(DriverObject);
	}

	return Status;
}

_Use_decl_annotations_
VOID
InjectDllWorker(
	_In_ PVOID IoObject,
	_In_opt_ PVOID Context,
	_In_ PIO_WORKITEM IoWorkItem
	)
{
	PAGED_CODE();

	UNREFERENCED_PARAMETER(IoObject);

	IoFreeWorkItem(IoWorkItem);

	NT_ASSERT(KeSetPreviousMode(KernelMode) == KernelMode);

	const PINJECT_DLL_PARAMS DllParams = static_cast<PINJECT_DLL_PARAMS>(Context);
	InjectDll(DllParams->Pid,
			&DllParams->ProcessName,
			DllParams->WaitForProcess,
			&DllParams->DllPath,
			DllParams->DeleteDll,
			DllParams->WipePeHeaders);
}

_Use_decl_annotations_
VOID
CleanMmUnloadedDriversWorker(
	_In_ PVOID IoObject,
	_In_opt_ PVOID Context,
	_In_ PIO_WORKITEM IoWorkItem
	)
{
	PAGED_CODE();

	UNREFERENCED_PARAMETER(IoObject);

	IoFreeWorkItem(IoWorkItem);

	const PKEVENT AllowUnloadEvent = static_cast<PKEVENT>(Context);

	
	RtlSleep(1500);

	CleanMmUnloadedDrivers();

	KeSetEvent(AllowUnloadEvent,
				EVENT_INCREMENT,
				FALSE);
}

static
BOOLEAN
DestroyDriverFile(
	_In_ PDRIVER_OBJECT DriverObject
	)
{
	PAGED_CODE();

	if (DriverObject == nullptr || DriverObject->DriverSection == nullptr)
		return FALSE;

	const PKLDR_DATA_TABLE_ENTRY Entry = static_cast<PKLDR_DATA_TABLE_ENTRY>(DriverObject->DriverSection);
	UNICODE_STRING DriverPath = Entry->FullDllName;
	if (DriverPath.Length <= 5 * sizeof(WCHAR) || DriverPath.Buffer == nullptr)
		return FALSE;

	OBJECT_ATTRIBUTES ObjectAttributes = RTL_CONSTANT_OBJECT_ATTRIBUTES(&DriverPath, OBJ_CASE_INSENSITIVE | OBJ_KERNEL_HANDLE);
	NTSTATUS Status = NtDeleteFile(&ObjectAttributes);
	if (NT_SUCCESS(Status))
	{
		Printf("Driver file \"%wZ\" has been deleted.\n", &DriverPath);
		return TRUE;
	}

	IO_DRIVER_CREATE_CONTEXT DriverCreateContext;
	IoInitializeDriverCreateContext(&DriverCreateContext);
	const PDEVICE_OBJECT BaseFsDeviceObject = IopGetBaseFsDeviceObject(&DriverPath);
	DriverCreateContext.DeviceObjectHint = BaseFsDeviceObject;

	IO_STATUS_BLOCK IoStatusBlock;
	HANDLE FileHandle;
	Status = IoCreateFileEx(&FileHandle,
							SYNCHRONIZE | DELETE,
							&ObjectAttributes,
							&IoStatusBlock,
							nullptr,
							FILE_ATTRIBUTE_NORMAL,
							FILE_SHARE_DELETE,
							FILE_OPEN,
							FILE_NON_DIRECTORY_FILE | FILE_SYNCHRONOUS_IO_NONALERT | FILE_OPEN_REPARSE_POINT | FILE_OPEN_FOR_BACKUP_INTENT,
							nullptr,
							0,
							CreateFileTypeNone,
							nullptr,
							IO_NO_PARAMETER_CHECKING | IO_IGNORE_SHARE_ACCESS_CHECK,
							BaseFsDeviceObject != nullptr
								? &DriverCreateContext
								: nullptr);

	if (BaseFsDeviceObject != nullptr)
		ObfDereferenceObject(BaseFsDeviceObject);

	if (!NT_SUCCESS(Status))
		return FALSE;

	PFILE_OBJECT FileObject;
	Status = ObReferenceObjectByHandleWithTag(FileHandle,
											SYNCHRONIZE | DELETE,
											*IoFileObjectType,
											KernelMode,
											GetPoolTag(),
											reinterpret_cast<PVOID*>(&FileObject),
											nullptr);
	if (!NT_SUCCESS(Status))
	{
		ObCloseHandle(FileHandle, KernelMode);
		return FALSE;
	}

	const PSECTION_OBJECT_POINTERS SectionObjectPointer = FileObject->SectionObjectPointer;
	SectionObjectPointer->ImageSectionObject = nullptr;

	const BOOLEAN ImageSectionFlushed = MmFlushImageSection(SectionObjectPointer, MmFlushForDelete);

	ObfDereferenceObject(FileObject);
	ObCloseHandle(FileHandle, KernelMode);

	if (ImageSectionFlushed)
	{
		Status = NtDeleteFile(&ObjectAttributes);
		if (NT_SUCCESS(Status))
		{
			Printf("Driver file \"%wZ\" has been deleted.\n", &DriverPath);
		}
	}

	return ImageSectionFlushed && NT_SUCCESS(Status);
}

static
BOOLEAN
DestroyDriverInformation(
	_In_ PDRIVER_OBJECT DriverObject
	)
{
	PAGED_CODE();

	const ULONG_PTR DriverAddress = reinterpret_cast<ULONG_PTR>(_ReturnAddress());
	const PKLDR_DATA_TABLE_ENTRY Entry = static_cast<PKLDR_DATA_TABLE_ENTRY>(DriverObject->DriverSection);
	if (Entry == nullptr)
		return FALSE;

	UNICODE_STRING DriverFileName = Entry->BaseDllName;
	if (DriverFileName.Length <= sizeof(WCHAR) || DriverFileName.Buffer == nullptr)
		return FALSE;

	const PIMAGE_NT_HEADERS NtHeaders = RtlpImageNtHeaderEx(Entry->DllBase, Entry->SizeOfImage);
	if (NtHeaders == nullptr)
		return FALSE;

	__try
	{
		if (Entry->DllBase != nullptr &&
			reinterpret_cast<ULONG_PTR>(Entry->DllBase) >= reinterpret_cast<ULONG_PTR>(MmSystemRangeStart) &&
			DriverAddress >= reinterpret_cast<ULONG_PTR>(Entry->DllBase) &&
			DriverAddress < reinterpret_cast<ULONG_PTR>(Entry->DllBase) + Entry->SizeOfImage)
		{
			if (!DeletePiDDBCacheTableEntry(&DriverFileName, NtHeaders->FileHeader.TimeDateStamp))
				Printf("WARNING: failed to delete %wZ from PiDDBCacheTable!\n", &DriverFileName);
			RtlSecureZeroMemory(Entry->BaseDllName.Buffer, Entry->BaseDllName.MaximumLength);
			Entry->BaseDllName.Length = Entry->BaseDllName.MaximumLength = 0;
			return TRUE;
		}
	}
	__except (EXCEPTION_EXECUTE_HANDLER)
	{
		NOTHING;
	}
	return FALSE;
}

VOID
DriverUnload(
	_In_ PDRIVER_OBJECT DriverObject
	)
{
	PAGED_CODE();

	CancelAllProcessWaits();

	KeWaitForSingleObject(&UnloadAllowed,
						Executive,
						KernelMode,
						FALSE,
						nullptr);

	if (DestroyDriverInformation(DriverObject))
		Printf("Destroyed driver information.\n");
	else
		Printf("Failed to destroy driver information.\n");

#if DEALLOCATE_ON_UNLOAD
	if (MappedPages != nullptr)
		MmUnmapLockedPages(MappedPages, Mdl);
	if (Mdl != nullptr)
		IoFreeMdl(Mdl);
	if (RegionBase != nullptr)
		ExFreePool(RegionBase);
#endif

	SsdtUninitialize();
	Printf("Driver unloaded.\n");
}

```

`MMInject/s20.c`:

```c
#include "MMInject.h"
#include "s20.h"

static uint32_t rotl(uint32_t value, int shift)
{
	return (value << shift) | (value >> (32 - shift));
}

static void s20_quarterround(uint32_t *y0, uint32_t *y1, uint32_t *y2, uint32_t *y3)
{
	*y1 = *y1 ^ rotl(*y0 + *y3, 7);
	*y2 = *y2 ^ rotl(*y1 + *y0, 9);
	*y3 = *y3 ^ rotl(*y2 + *y1, 13);
	*y0 = *y0 ^ rotl(*y3 + *y2, 18);
}

static void s20_rowround(uint32_t y[16])
{
	s20_quarterround(&y[0], &y[1], &y[2], &y[3]);
	s20_quarterround(&y[5], &y[6], &y[7], &y[4]);
	s20_quarterround(&y[10], &y[11], &y[8], &y[9]);
	s20_quarterround(&y[15], &y[12], &y[13], &y[14]);
}

static void s20_columnround(uint32_t x[16])
{
	s20_quarterround(&x[0], &x[4], &x[8], &x[12]);
	s20_quarterround(&x[5], &x[9], &x[13], &x[1]);
	s20_quarterround(&x[10], &x[14], &x[2], &x[6]);
	s20_quarterround(&x[15], &x[3], &x[7], &x[11]);
}

static void s20_doubleround(uint32_t x[16])
{
	s20_columnround(x);
	s20_rowround(x);
}

static uint32_t s20_littleendian(uint8_t *b)
{
	return b[0] +
		   ((uint16_t)b[1] << 8) +
		   ((uint32_t)b[2] << 16) +
		   ((uint32_t)b[3] << 24);
}

static void s20_rev_littleendian(uint8_t *b, uint32_t w)
{

	*(uint32_t *)b = w;
}

static void s20_hash(uint8_t seq[64])
{
	int i;
	uint32_t x[16];
	uint32_t z[16];

	for (i = 0; i < 16; ++i)
		x[i] = z[i] = s20_littleendian(seq + (4 * i));

	for (i = 0; i < 10; ++i)
		s20_doubleround(z);

	for (i = 0; i < 16; ++i)
	{
		z[i] += x[i];
		s20_rev_littleendian(seq + (4 * i), z[i]);
	}
}

static void s20_expand16(uint8_t *k,
						 uint8_t n[16],
						 uint8_t keystream[64])
{
	int i, j;
	uint8_t t[4][4] = {
		{ 'e', 'x', 'p', 'a' },
		{ 'n', 'd', ' ', '1' },
		{ '6', '-', 'b', 'y' },
		{ 't', 'e', ' ', 'k' }
	};

	for (i = 0; i < 64; i += 20)
		for (j = 0; j < 4; ++j)
			keystream[i + j] = t[i / 20][j];

	for (i = 0; i < 16; ++i)
	{
		keystream[4 + i] = k[i];
		keystream[44 + i] = k[i];
		keystream[24 + i] = n[i];
	}

	s20_hash(keystream);
}

static void s20_expand32(uint8_t *k,
						 uint8_t n[16],
						 uint8_t keystream[64])
{
	int i, j;
	uint8_t o[4][4] = {
		{ 'e', 'x', 'p', 'a' },
		{ 'n', 'd', ' ', '3' },
		{ '2', '-', 'b', 'y' },
		{ 't', 'e', ' ', 'k' }
	};

	for (i = 0; i < 64; i += 20)
		for (j = 0; j < 4; ++j)
			keystream[i + j] = o[i / 20][j];

	for (i = 0; i < 16; ++i)
	{
		keystream[4 + i] = k[i];
		keystream[44 + i] = k[i + 16];
		keystream[24 + i] = n[i];
	}

	s20_hash(keystream);
}

enum s20_status_t s20_crypt(uint8_t *key,
							enum s20_keylen_t keylen,
							uint8_t nonce[8],
							uint32_t si,
							uint8_t *buf,
							uint32_t buflen)
{
	uint8_t keystream[64];
	uint8_t n[16] = { 0 };
	uint32_t i;

	void (*expand)(uint8_t *, uint8_t *, uint8_t *) = NULL;
	if (keylen == S20_KEYLEN_256)
		expand = s20_expand32;
	if (keylen == S20_KEYLEN_128)
		expand = s20_expand16;

	if (expand == NULL || key == NULL || nonce == NULL || buf == NULL)
		return S20_FAILURE;

	for (i = 0; i < 8; ++i)
		n[i] = nonce[i];

	if (si % 64 != 0)
	{
		s20_rev_littleendian(n + 8, si / 64);
		(*expand)(key, n, keystream);
	}

	for (i = 0; i < buflen; ++i)
	{
		if ((si + i) % 64 == 0)
		{
			s20_rev_littleendian(n + 8, ((si + i) / 64));
			(*expand)(key, n, keystream);
		}

		buf[i] ^= keystream[(si + i) % 64];
	}

	return S20_SUCCESS;
}

```

`MMInject/s20.h`:

```h
#pragma once

enum s20_status_t
{
	S20_SUCCESS,
	S20_FAILURE
};

enum s20_keylen_t
{
	S20_KEYLEN_256,
	S20_KEYLEN_128
};


typedef UINT8 uint8_t;
typedef UINT16 uint16_t;
typedef UINT32 uint32_t;
typedef UINT64 uint64_t;

enum
s20_status_t
s20_crypt(
	uint8_t *key,
	enum s20_keylen_t keylen,
	uint8_t nonce[8],
	uint32_t si,
	uint8_t *buf,
	uint32_t buflen
	);

```

`MMInject/vad.h`:

```h
#pragma once

#include "MMInject.h"

#ifdef __cplusplus
extern "C" {
#endif

NTSTATUS
ProtectVAD(
	_In_ PEPROCESS Process,
	_In_ ULONG_PTR Address,
	_In_ ULONG Protection
	);

NTSTATUS
FindVAD(
	_In_ PEPROCESS Process,
	_In_ ULONG_PTR Address,
	_Out_ PMMVAD_SHORT *Result
	);

BOOLEAN
DoesVADConflict(
	_In_ PEPROCESS Process,
	_In_ ULONG_PTR StartingAddress,
	_In_ ULONG_PTR EndingAddress
	);

NTSTATUS
HideVAD(
	_In_ PEPROCESS Process,
	_In_ ULONG_PTR Address
	);

PMMPTE
GetPTEForVA(
	_In_ PVOID Address
	);

#ifdef __cplusplus
}
#endif

```

`MMInject/zwapi.h`:

```h
#pragma once

#include "Native/NativeStructs.h"

#define PTR_ADD_OFFSET(Pointer, Offset) ((PVOID)((ULONG_PTR)(Pointer) + (ULONG_PTR)(Offset)))
#define PTR_SUB_OFFSET(Pointer, Offset) ((PVOID)((ULONG_PTR)(Pointer) - (ULONG_PTR)(Offset)))

#ifndef MAX_PATH
#define MAX_PATH 260
#endif

extern "C" {

typedef struct _KNONVOLATILE_CONTEXT_POINTERS
{
	union
	{
		PM128A FloatingContext[16];
		struct
		{
			PM128A Xmm0;
			PM128A Xmm1;
			PM128A Xmm2;
			PM128A Xmm3;
			PM128A Xmm4;
			PM128A Xmm5;
			PM128A Xmm6;
			PM128A Xmm7;
			PM128A Xmm8;
			PM128A Xmm9;
			PM128A Xmm10;
			PM128A Xmm11;
			PM128A Xmm12;
			PM128A Xmm13;
			PM128A Xmm14;
			PM128A Xmm15;
		};
	};

	union
	{
		PULONG64 IntegerContext[16];
		struct
		{
			PULONG64 Rax;
			PULONG64 Rcx;
			PULONG64 Rdx;
			PULONG64 Rbx;
			PULONG64 Rsp;
			PULONG64 Rbp;
			PULONG64 Rsi;
			PULONG64 Rdi;
			PULONG64 R8;
			PULONG64 R9;
			PULONG64 R10;
			PULONG64 R11;
			PULONG64 R12;
			PULONG64 R13;
			PULONG64 R14;
			PULONG64 R15;
		};
	};
} KNONVOLATILE_CONTEXT_POINTERS, *PKNONVOLATILE_CONTEXT_POINTERS;

typedef struct _RUNTIME_FUNCTION
{
	ULONG BeginAddress;
	ULONG EndAddress;
	ULONG UnwindData;
} RUNTIME_FUNCTION, *PRUNTIME_FUNCTION;

#define UNWIND_HISTORY_TABLE_SIZE 12

typedef struct _UNWIND_HISTORY_TABLE_ENTRY
{
	ULONG64 ImageBase;
	PRUNTIME_FUNCTION FunctionEntry;
} UNWIND_HISTORY_TABLE_ENTRY, *PUNWIND_HISTORY_TABLE_ENTRY;

typedef struct _UNWIND_HISTORY_TABLE
{
	ULONG Count;
	UCHAR Search;
	ULONG64 LowAddress;
	ULONG64 HighAddress;
	UNWIND_HISTORY_TABLE_ENTRY Entry[UNWIND_HISTORY_TABLE_SIZE];
} UNWIND_HISTORY_TABLE, *PUNWIND_HISTORY_TABLE;

typedef enum _PORT_INFORMATION_CLASS
{
	PortBasicInformation,
	PortDumpInformation
} PORT_INFORMATION_CLASS;

typedef enum _EVENT_INFORMATION_CLASS
{
	EventBasicInformation
} EVENT_INFORMATION_CLASS;

typedef enum _SEMAPHORE_INFORMATION_CLASS
{
	SemaphoreBasicInformation
} SEMAPHORE_INFORMATION_CLASS;

typedef enum _MUTANT_INFORMATION_CLASS
{
	MutantBasicInformation,
	MutantOwnerInformation
} MUTANT_INFORMATION_CLASS;

typedef enum _TIMER_INFORMATION_CLASS
{
	TimerBasicInformation
} TIMER_INFORMATION_CLASS;

typedef struct _TIMER_BASIC_INFORMATION
{
	LARGE_INTEGER RemainingTime;
	BOOLEAN TimerState;
} TIMER_BASIC_INFORMATION, *PTIMER_BASIC_INFORMATION;

typedef VOID(NTAPI *PTIMER_APC_ROUTINE)(
	_In_ PVOID TimerContext,
	_In_ ULONG TimerLowValue,
	_In_ LONG TimerHighValue
	);

typedef struct _MUTANT_BASIC_INFORMATION
{
	LONG CurrentCount;
	BOOLEAN OwnedByCaller;
	BOOLEAN AbandonedState;
} MUTANT_BASIC_INFORMATION, *PMUTANT_BASIC_INFORMATION;

typedef struct _MUTANT_OWNER_INFORMATION
{
	CLIENT_ID ClientId;
} MUTANT_OWNER_INFORMATION, *PMUTANT_OWNER_INFORMATION;

typedef struct _EVENT_BASIC_INFORMATION
{
	EVENT_TYPE EventType;
	LONG EventState;
} EVENT_BASIC_INFORMATION, *PEVENT_BASIC_INFORMATION;

typedef struct _FILE_IO_COMPLETION_INFORMATION
{
	PVOID KeyContext;
	PVOID ApcContext;
	IO_STATUS_BLOCK IoStatusBlock;
} FILE_IO_COMPLETION_INFORMATION, *PFILE_IO_COMPLETION_INFORMATION;

typedef struct _SYSTEM_PROCESS_INFORMATION
{
	ULONG NextEntryOffset;
	ULONG NumberOfThreads;
	LARGE_INTEGER SpareLi1;
	LARGE_INTEGER SpareLi2;
	LARGE_INTEGER SpareLi3;
	LARGE_INTEGER CreateTime;
	LARGE_INTEGER UserTime;
	LARGE_INTEGER KernelTime;
	UNICODE_STRING ImageName;
	KPRIORITY BasePriority;
	HANDLE UniqueProcessId;
	HANDLE InheritedFromUniqueProcessId;
	ULONG HandleCount;
	ULONG SessionId;
	ULONG_PTR PageDirectoryBase;
	SIZE_T PeakVirtualSize;
	SIZE_T VirtualSize;
	ULONG PageFaultCount;
	SIZE_T PeakWorkingSetSize;
	SIZE_T WorkingSetSize;
	SIZE_T QuotaPeakPagedPoolUsage;
	SIZE_T QuotaPagedPoolUsage;
	SIZE_T QuotaPeakNonPagedPoolUsage;
	SIZE_T QuotaNonPagedPoolUsage;
	SIZE_T PagefileUsage;
	SIZE_T PeakPagefileUsage;
	SIZE_T PrivatePageCount;
	LARGE_INTEGER ReadOperationCount;
	LARGE_INTEGER WriteOperationCount;
	LARGE_INTEGER OtherOperationCount;
	LARGE_INTEGER ReadTransferCount;
	LARGE_INTEGER WriteTransferCount;
	LARGE_INTEGER OtherTransferCount;
	SYSTEM_THREAD_INFORMATION Threads[1];
} SYSTEM_PROCESS_INFORMATION, *PSYSTEM_PROCESS_INFORMATION;

#define IO_COMPLETION_QUERY_STATE	0x0001
#define IO_COMPLETION_MODIFY_STATE	0x0002
#define IO_COMPLETION_ALL_ACCESS	(STANDARD_RIGHTS_REQUIRED | SYNCHRONIZE| \
									IO_COMPLETION_QUERY_STATE | IO_COMPLETION_MODIFY_STATE)

typedef struct _OVERLAPPED
{
	ULONG_PTR Internal;
	ULONG_PTR InternalHigh;
	union
	{
		struct
		{
			ULONG Offset;
			ULONG OffsetHigh;
		} s;
		PVOID Pointer;
	} u;
	HANDLE hEvent;
} OVERLAPPED, *LPOVERLAPPED;

#define PROCESS_TERMINATE					(0x0001)
#define PROCESS_CREATE_THREAD				(0x0002)
#define PROCESS_SET_SESSIONID				(0x0004)
#define PROCESS_VM_OPERATION				(0x0008)
#define PROCESS_VM_READ						(0x0010)
#define PROCESS_VM_WRITE					(0x0020)
#define PROCESS_DUP_HANDLE					(0x0040)
#define PROCESS_CREATE_PROCESS				(0x0080)
#define PROCESS_SET_QUOTA					(0x0100)
#define PROCESS_SET_INFORMATION				(0x0200)
#define PROCESS_QUERY_INFORMATION			(0x0400)
#define PROCESS_SUSPEND_RESUME				(0x0800)
#define PROCESS_QUERY_LIMITED_INFORMATION	(0x1000)
#define PROCESS_SET_LIMITED_INFORMATION		(0x2000)
#if (NTDDI_VERSION >= NTDDI_VISTA)
#define PROCESS_ALL_ACCESS					(STANDARD_RIGHTS_REQUIRED | SYNCHRONIZE | \
											0xFFFF)
#else
#define PROCESS_ALL_ACCESS					(STANDARD_RIGHTS_REQUIRED | SYNCHRONIZE | \
											0xFFF)
#endif

typedef struct _PS_ATTRIBUTE
{
	ULONG_PTR Attribute;				// PROC_THREAD_ATTRIBUTE_XXX | PROC_THREAD_ATTRIBUTE_XXX modifiers, see ProcThreadAttributeValue macro and Windows Internals 6 (372)
	SIZE_T Size;						// Size of Value or *ValuePtr
	union
	{
		ULONG_PTR Value;				// Reserve 8 bytes for data (such as a Handle or a data pointer)
		PVOID ValuePtr;					// data pointer
	};
	PSIZE_T ReturnLength;				// Either 0 or specifies size of data returned to caller via "ValuePtr"
} PS_ATTRIBUTE, *PPS_ATTRIBUTE;

typedef struct _PS_ATTRIBUTE_LIST
{
	SIZE_T TotalLength;					// sizeof(PS_ATTRIBUTE_LIST)
	PS_ATTRIBUTE Attributes[2];			// Depends on how many attribute entries should be supplied to NtCreateUserProcess
} PS_ATTRIBUTE_LIST, *PPS_ATTRIBUTE_LIST;

typedef struct _PS_MEMORY_RESERVE
{
	PVOID ReserveAddress;
	SIZE_T ReserveSize;
} PS_MEMORY_RESERVE, *PPS_MEMORY_RESERVE;

#define PS_ATTRIBUTE_NUMBER_MASK	0x0000ffff
#define PS_ATTRIBUTE_THREAD			0x00010000 // Attribute may be used with thread creation
#define PS_ATTRIBUTE_INPUT			0x00020000 // Attribute is input only
#define PS_ATTRIBUTE_ADDITIVE		0x00040000 // Attribute may be "accumulated", e.g. bitmasks, counters, etc.

typedef enum _PS_ATTRIBUTE_NUM
{
	PsAttributeParentProcess,					// in HANDLE
	PsAttributeDebugPort,						// in HANDLE
	PsAttributeToken,							// in HANDLE
	PsAttributeClientId,						// out PCLIENT_ID
	PsAttributeTebAddress,						// out PTEB
	PsAttributeImageName,						// in PWSTR
	PsAttributeImageInfo,						// out PSECTION_IMAGE_INFORMATION
	PsAttributeMemoryReserve,					// in PPS_MEMORY_RESERVE
	PsAttributePriorityClass,					// in UCHAR
	PsAttributeErrorMode,						// in ULONG
	PsAttributeStdHandleInfo,					// in PPS_STD_HANDLE_INFO
	PsAttributeHandleList,						// in PHANDLE
	PsAttributeGroupAffinity,					// in PGROUP_AFFINITY
	PsAttributePreferredNode,					// in PUSHORT
	PsAttributeIdealProcessor,					// in PPROCESSOR_NUMBER
	PsAttributeUmsThread,						// see MSDN UpdateProceThreadAttributeList (CreateProcessW) - in PUMS_CREATE_THREAD_ATTRIBUTES
	PsAttributeMitigationOptions,				// in UCHAR
	PsAttributeProtectionLevel,					// in ULONG
	PsAttributeSecureProcess,					// since THRESHOLD (Virtual Secure Mode, Device Guard)
	PsAttributeJobList,
	PsAttributeChildProcessPolicy,				// since THRESHOLD2
	PsAttributeAllApplicationPackagesPolicy,	// since REDSTONE
	PsAttributeWin32kFilter,
	PsAttributeSafeOpenPromptOriginClaim,
	PsAttributeBnoIsolation,
	PsAttributeDesktopAppPolicy,
	PsAttributeMax
} PS_ATTRIBUTE_NUM;

#define PsAttributeValue(Number, Thread, Input, Additive) \
	(((Number) & PS_ATTRIBUTE_NUMBER_MASK) | \
	((Thread) ? PS_ATTRIBUTE_THREAD : 0) | \
	((Input) ? PS_ATTRIBUTE_INPUT : 0) | \
	((Additive) ? PS_ATTRIBUTE_ADDITIVE : 0))

#define PS_ATTRIBUTE_PARENT_PROCESS \
	PsAttributeValue(PsAttributeParentProcess, FALSE, TRUE, TRUE) // 0x60000
#define PS_ATTRIBUTE_DEBUG_PORT \
	PsAttributeValue(PsAttributeDebugPort, FALSE, TRUE, TRUE) // 0x60001
#define PS_ATTRIBUTE_TOKEN \
	PsAttributeValue(PsAttributeToken, FALSE, TRUE, TRUE) // 0x60002
#define PS_ATTRIBUTE_CLIENT_ID \
	PsAttributeValue(PsAttributeClientId, TRUE, FALSE, FALSE) // 0x10003
#define PS_ATTRIBUTE_TEB_ADDRESS \
	PsAttributeValue(PsAttributeTebAddress, TRUE, FALSE, FALSE) // 0x10004
#define PS_ATTRIBUTE_IMAGE_NAME \
	PsAttributeValue(PsAttributeImageName, FALSE, TRUE, FALSE) // 0x20005
#define PS_ATTRIBUTE_IMAGE_INFO \
	PsAttributeValue(PsAttributeImageInfo, FALSE, FALSE, FALSE) // 0x6
#define PS_ATTRIBUTE_MEMORY_RESERVE \
	PsAttributeValue(PsAttributeMemoryReserve, FALSE, TRUE, FALSE) // 0x20007
#define PS_ATTRIBUTE_PRIORITY_CLASS \
	PsAttributeValue(PsAttributePriorityClass, FALSE, TRUE, FALSE) // 0x20008
#define PS_ATTRIBUTE_ERROR_MODE \
	PsAttributeValue(PsAttributeErrorMode, FALSE, TRUE, FALSE) // 0x20009
#define PS_ATTRIBUTE_STD_HANDLE_INFO \
	PsAttributeValue(PsAttributeStdHandleInfo, FALSE, TRUE, FALSE) // 0x2000A
#define PS_ATTRIBUTE_HANDLE_LIST \
	PsAttributeValue(PsAttributeHandleList, FALSE, TRUE, FALSE) // 0x2000B
#define PS_ATTRIBUTE_GROUP_AFFINITY \
	PsAttributeValue(PsAttributeGroupAffinity, TRUE, TRUE, FALSE) // 0x2000C
#define PS_ATTRIBUTE_PREFERRED_NODE \
	PsAttributeValue(PsAttributePreferredNode, FALSE, TRUE, FALSE) // 0x2000D
#define PS_ATTRIBUTE_IDEAL_PROCESSOR \
	PsAttributeValue(PsAttributeIdealProcessor, TRUE, TRUE, FALSE) // 0x2000E
#define PS_ATTRIBUTE_MITIGATION_OPTIONS \
	PsAttributeValue(PsAttributeMitigationOptions, FALSE, TRUE, TRUE) // 0x60010
#define PS_ATTRIBUTE_PROTECTION_LEVEL \
	PsAttributeValue(PsAttributeProtectionLevel, FALSE, TRUE, FALSE) // 0x20011

typedef enum _PS_STD_HANDLE_STATE {
	PsNeverDuplicate,
	PsRequestDuplicate, // Duplicate standard handles specified by PseudoHandleMask, and only if StdHandleSubsystemType matches the image subsystem
	PsAlwaysDuplicate, // Always duplicate standard handles
	PsMaxStdHandleStates
} PS_STD_HANDLE_STATE;

#define HANDLE_DETACHED_PROCESS		((HANDLE)-1)
#define HANDLE_CREATE_NEW_CONSOLE	((HANDLE)-2)
#define HANDLE_CREATE_NO_WINDOW		((HANDLE)-3)

#define PS_STD_INPUT_HANDLE			0x1
#define PS_STD_OUTPUT_HANDLE		0x2
#define PS_STD_ERROR_HANDLE			0x4

typedef struct _PS_STD_HANDLE_INFO
{
	union
	{
		ULONG Flags;
		struct
		{
			ULONG StdHandleState : 2; // PS_STD_HANDLE_STATE
			ULONG PseudoHandleMask : 3; // PS_STD_*
		} s;
	};
	ULONG StdHandleSubsystemType;
} PS_STD_HANDLE_INFO, *PPS_STD_HANDLE_INFO;

typedef struct _PS_BNO_ISOLATION_PARAMETERS
{
	UNICODE_STRING IsolationPrefix;
	ULONG HandleCount;
	PVOID *Handles;
	BOOLEAN IsolationEnabled;
} PS_BNO_ISOLATION_PARAMETERS, *PPS_BNO_ISOLATION_PARAMETERS;

typedef enum _PS_MITIGATION_OPTION
{
	PS_MITIGATION_OPTION_NX,
	PS_MITIGATION_OPTION_SEHOP,
	PS_MITIGATION_OPTION_FORCE_RELOCATE_IMAGES,
	PS_MITIGATION_OPTION_HEAP_TERMINATE,
	PS_MITIGATION_OPTION_BOTTOM_UP_ASLR,
	PS_MITIGATION_OPTION_HIGH_ENTROPY_ASLR,
	PS_MITIGATION_OPTION_STRICT_HANDLE_CHECKS,
	PS_MITIGATION_OPTION_WIN32K_SYSTEM_CALL_DISABLE,
	PS_MITIGATION_OPTION_EXTENSION_POINT_DISABLE,
	PS_MITIGATION_OPTION_PROHIBIT_DYNAMIC_CODE,
	PS_MITIGATION_OPTION_CONTROL_FLOW_GUARD,
	PS_MITIGATION_OPTION_BLOCK_NON_MICROSOFT_BINARIES,
	PS_MITIGATION_OPTION_FONT_DISABLE,
	PS_MITIGATION_OPTION_IMAGE_LOAD_NO_REMOTE,
	PS_MITIGATION_OPTION_IMAGE_LOAD_NO_LOW_LABEL,
	PS_MITIGATION_OPTION_IMAGE_LOAD_PREFER_SYSTEM32,
	PS_MITIGATION_OPTION_RETURN_FLOW_GUARD,
	PS_MITIGATION_OPTION_LOADER_INTEGRITY_CONTINUITY,
	PS_MITIGATION_OPTION_STRICT_CONTROL_FLOW_GUARD,
	PS_MITIGATION_OPTION_RESTRICT_SET_THREAD_CONTEXT
} PS_MITIGATION_OPTION;

typedef enum _PS_CREATE_STATE
{
	PsCreateInitialState,
	PsCreateFailOnFileOpen,
	PsCreateFailOnSectionCreate,
	PsCreateFailExeFormat,
	PsCreateFailMachineMismatch,
	PsCreateFailExeName, // Debugger specified
	PsCreateSuccess,
	PsCreateMaximumStates
} PS_CREATE_STATE;

typedef struct _PS_CREATE_INFO
{
	SIZE_T Size;
	PS_CREATE_STATE State;
	union
	{
		// PsCreateInitialState
		struct
		{
			union
			{
				ULONG InitFlags;
				struct
				{
					UCHAR WriteOutputOnExit : 1;
					UCHAR DetectManifest : 1;
					UCHAR IFEOSkipDebugger : 1;
					UCHAR IFEODoNotPropagateKeyState : 1;
					UCHAR SpareBits1 : 4;
					UCHAR SpareBits2 : 8;
					USHORT ProhibitedImageCharacteristics : 16;
				} s1;
			} u1;
			ACCESS_MASK AdditionalFileAccess;
		} InitState;

		// PsCreateFailOnSectionCreate
		struct
		{
			HANDLE FileHandle;
		} FailSection;

		// PsCreateFailExeFormat
		struct
		{
			USHORT DllCharacteristics;
		} ExeFormat;

		// PsCreateFailExeName
		struct
		{
			HANDLE IFEOKey;
		} ExeName;

		// PsCreateSuccess
		struct
		{
			union
			{
				ULONG OutputFlags;
				struct
				{
					UCHAR ProtectedProcess : 1;
					UCHAR AddressSpaceOverride : 1;
					UCHAR DevOverrideEnabled : 1; // From Image File Execution Options
					UCHAR ManifestDetected : 1;
					UCHAR ProtectedProcessLight : 1;
					UCHAR SpareBits1 : 3;
					UCHAR SpareBits2 : 8;
					USHORT SpareBits3 : 16;
				} s2;
			} u2;
			HANDLE FileHandle;
			HANDLE SectionHandle;
			ULONGLONG UserProcessParametersNative;
			ULONG UserProcessParametersWow64;
			ULONG CurrentParameterFlags;
			ULONGLONG PebAddressNative;
			ULONG PebAddressWow64;
			ULONGLONG ManifestAddress;
			ULONG ManifestSize;
		} SuccessState;
	};
} PS_CREATE_INFO, *PPS_CREATE_INFO;

#define THREAD_CREATE_FLAGS_CREATE_SUSPENDED		0x00000001
#define THREAD_CREATE_FLAGS_SUPPRESS_DLLMAINS		0x00000002
#define THREAD_CREATE_FLAGS_HIDE_FROM_DEBUGGER		0x00000004
#define THREAD_CREATE_FLAGS_HAS_SECURITY_DESCRIPTOR	0x00000010 // ?
#define THREAD_CREATE_FLAGS_ACCESS_CHECK_IN_TARGET	0x00000020 // ?
#define THREAD_CREATE_FLAGS_INITIAL_THREAD			0x00000080

#define PROCESS_CREATE_FLAGS_BREAKAWAY				0x00000001
#define PROCESS_CREATE_FLAGS_NO_DEBUG_INHERIT		0x00000002
#define PROCESS_CREATE_FLAGS_INHERIT_HANDLES		0x00000004
#define PROCESS_CREATE_FLAGS_OVERRIDE_ADDRESS_SPACE 0x00000008
#define PROCESS_CREATE_FLAGS_LARGE_PAGES			0x00000010

// Only usable with NtCreateUserProcess (Vista+):
#define PROCESS_CREATE_FLAGS_LARGE_PAGE_SYSTEM_DLL	0x00000020
#define PROCESS_CREATE_FLAGS_PROTECTED_PROCESS		0x00000040 // Only allowed if the calling process is itself protected
#define PROCESS_CREATE_FLAGS_CREATE_SESSION			0x00000080
#define PROCESS_CREATE_FLAGS_INHERIT_FROM_PARENT	0x00000100

// This is an internal type, but it hasn't changed in some 20 years or so
#define DEBUG_OBJECT_DELETE_PENDING			0x1
#define DEBUG_OBJECT_KILL_ON_CLOSE			0x2

typedef struct _DEBUG_OBJECT
{
	// Event that's set when EventList is populated.
	KEVENT EventsPresent;

	// Mutex to protect the structure
	FAST_MUTEX Mutex;

	// Queue of events waiting for debugger intervention
	LIST_ENTRY EventList;

	// Flags for the object
	ULONG Flags;
} DEBUG_OBJECT, *PDEBUG_OBJECT;

#define DEBUG_READ_EVENT					0x0001
#define DEBUG_PROCESS_ASSIGN				0x0002
#define DEBUG_SET_INFORMATION				0x0004
#define DEBUG_QUERY_INFORMATION				0x0008
#define DEBUG_ALL_ACCESS					(STANDARD_RIGHTS_REQUIRED | SYNCHRONIZE | \
											DEBUG_READ_EVENT | DEBUG_PROCESS_ASSIGN | DEBUG_SET_INFORMATION | \
											DEBUG_QUERY_INFORMATION)

#define ObjectNameInformation				1
#define ObjectTypesInformation				3
#define ObjectHandleFlagInformation			4
#define ObjectSessionInformation			5

typedef struct _OBJECT_BASIC_INFORMATION
{
	ULONG Attributes;
	ACCESS_MASK GrantedAccess;
	ULONG HandleCount;
	ULONG PointerCount;
	ULONG PagedPoolCharge;
	ULONG NonPagedPoolCharge;
	ULONG Reserved[3];
	ULONG NameInfoSize;
	ULONG TypeInfoSize;
	ULONG SecurityDescriptorSize;
	LARGE_INTEGER CreationTime;
} OBJECT_BASIC_INFORMATION, *POBJECT_BASIC_INFORMATION;

typedef struct _OBJECT_TYPE_INFORMATION
{
	UNICODE_STRING TypeName;
	ULONG TotalNumberOfObjects;
	ULONG TotalNumberOfHandles;
	ULONG TotalPagedPoolUsage;
	ULONG TotalNonPagedPoolUsage;
	ULONG TotalNamePoolUsage;
	ULONG TotalHandleTableUsage;
	ULONG HighWaterNumberOfObjects;
	ULONG HighWaterNumberOfHandles;
	ULONG HighWaterPagedPoolUsage;
	ULONG HighWaterNonPagedPoolUsage;
	ULONG HighWaterNamePoolUsage;
	ULONG HighWaterHandleTableUsage;
	ULONG InvalidAttributes;
	GENERIC_MAPPING GenericMapping;
	ULONG ValidAccessMask;
	BOOLEAN SecurityRequired;
	BOOLEAN MaintainHandleCount;
	UCHAR TypeIndex; // since WINBLUE
	CHAR ReservedByte;
	ULONG PoolType;
	ULONG DefaultPagedPoolCharge;
	ULONG DefaultNonPagedPoolCharge;
} OBJECT_TYPE_INFORMATION, *POBJECT_TYPE_INFORMATION;

typedef struct _OBJECT_TYPES_INFORMATION
{
	ULONG NumberOfTypes;
} OBJECT_TYPES_INFORMATION, *POBJECT_TYPES_INFORMATION;

typedef struct _OBJECT_HANDLE_FLAG_INFORMATION
{
	BOOLEAN Inherit;
	BOOLEAN ProtectFromClose;
} OBJECT_HANDLE_FLAG_INFORMATION, *POBJECT_HANDLE_FLAG_INFORMATION;

typedef struct _SE_AUDIT_PROCESS_CREATION_INFO
{
	OBJECT_NAME_INFORMATION *ImageFileName;
} SE_AUDIT_PROCESS_CREATION_INFO, *PSE_AUDIT_PROCESS_CREATION_INFO;

#define PAGE_NOACCESS					0x01
#define PAGE_READONLY					0x02
#define PAGE_READWRITE					0x04
#define PAGE_WRITECOPY					0x08
#define PAGE_EXECUTE					0x10
#define PAGE_EXECUTE_READ				0x20
#define PAGE_EXECUTE_READWRITE			0x40
#define PAGE_EXECUTE_WRITECOPY			0x80
#define PAGE_GUARD						0x100
#define PAGE_NOCACHE					0x200
#define PAGE_WRITECOMBINE				0x400

//
// PAGE_REVERT_TO_FILE_MAP can be combined with other protection
// values to specify to VirtualProtect that the argument range
// should be reverted to point back to the backing file. This
// means the contents of any private (copy on write) pages in the
// range will be discarded. Any reverted pages that were locked
// into the working set are unlocked as well.
//

#define PAGE_ENCLAVE_THREAD_CONTROL		0x80000000
#define PAGE_REVERT_TO_FILE_MAP			0x80000000
#define PAGE_TARGETS_NO_UPDATE			0x40000000
#define PAGE_TARGETS_INVALID			0x40000000
#define PAGE_ENCLAVE_UNVALIDATED		0x20000000
#define PAGE_ENCLAVE_NO_CHANGE			0x20000000
#define PAGE_ENCLAVE_DECOMMIT			0x10000000

#define MEM_COMMIT						0x00001000
#define MEM_RESERVE						0x00002000
#define MEM_DECOMMIT					0x00004000
#define MEM_RELEASE						0x00008000
#define MEM_FREE						0x00010000
#define MEM_PRIVATE						0x00020000
#define MEM_MAPPED						0x00040000
#define MEM_RESET						0x00080000
#define MEM_TOP_DOWN					0x00100000
#define MEM_WRITE_WATCH					0x00200000
#define MEM_PHYSICAL					0x00400000
#define MEM_ROTATE						0x00800000
#define MEM_DIFFERENT_IMAGE_BASE_OK		0x00800000
#define MEM_RESET_UNDO					0x01000000
#define MEM_LARGE_PAGES					0x20000000
#define MEM_4MB_PAGES					0x80000000
#define MEM_64K_PAGES 					(MEM_LARGE_PAGES | MEM_PHYSICAL)
#define SEC_64K_PAGES					0x00080000
#define SEC_FILE						0x00800000
#define SEC_IMAGE						0x01000000
#define SEC_PROTECTED_IMAGE				0x02000000
#define SEC_RESERVE						0x04000000
#define SEC_COMMIT						0x08000000
#define SEC_NOCACHE						0x10000000
#define SEC_WRITECOMBINE				0x40000000
#define SEC_LARGE_PAGES					0x80000000
#define SEC_IMAGE_NO_EXECUTE			(SEC_IMAGE | SEC_NOCACHE)
#define MEM_IMAGE 						SEC_IMAGE
#define WRITE_WATCH_FLAG_RESET			0x01
#define MEM_UNMAP_WITH_TRANSIENT_BOOST	0x01

typedef struct _RTL_USER_PROCESS_PARAMETERS *PRTL_USER_PROCESS_PARAMETERS;
typedef struct _RTL_CRITICAL_SECTION *PRTL_CRITICAL_SECTION;

#define GDI_HANDLE_BUFFER_SIZE32 34
#define GDI_HANDLE_BUFFER_SIZE64 60
#ifndef WIN64
#define GDI_HANDLE_BUFFER_SIZE GDI_HANDLE_BUFFER_SIZE32
#else
#define GDI_HANDLE_BUFFER_SIZE GDI_HANDLE_BUFFER_SIZE64
#endif
typedef ULONG GDI_HANDLE_BUFFER[GDI_HANDLE_BUFFER_SIZE];
typedef ULONG GDI_HANDLE_BUFFER32[GDI_HANDLE_BUFFER_SIZE32];
typedef ULONG GDI_HANDLE_BUFFER64[GDI_HANDLE_BUFFER_SIZE64];

#define FLS_MAXIMUM_AVAILABLE 128
#define TLS_MINIMUM_AVAILABLE 64
#define TLS_EXPANSION_SLOTS 1024

#define LDR_DATA_TABLE_ENTRY_SIZE_WINXP FIELD_OFFSET(LDR_DATA_TABLE_ENTRY, DdagNode)
#define LDR_DATA_TABLE_ENTRY_SIZE_WIN7 FIELD_OFFSET(LDR_DATA_TABLE_ENTRY, BaseNameHashValue)
#define LDR_DATA_TABLE_ENTRY_SIZE_WIN8 FIELD_OFFSET(LDR_DATA_TABLE_ENTRY, ImplicitPathOptions)

typedef struct _PEB
{
	BOOLEAN InheritedAddressSpace;
	BOOLEAN ReadImageFileExecOptions;
	BOOLEAN BeingDebugged;
	union
	{
		BOOLEAN BitField;
		struct
		{
			BOOLEAN ImageUsesLargePages : 1;
			BOOLEAN IsProtectedProcess : 1;
			BOOLEAN IsImageDynamicallyRelocated : 1;
			BOOLEAN SkipPatchingUser32Forwarders : 1;
			BOOLEAN IsPackagedProcess : 1;
			BOOLEAN IsAppContainer : 1;
			BOOLEAN IsProtectedProcessLight : 1;
			BOOLEAN IsLongPathAwareProcess : 1;
		};
	};

	HANDLE Mutant;

	PVOID ImageBaseAddress;
	PPEB_LDR_DATA Ldr;
	PRTL_USER_PROCESS_PARAMETERS ProcessParameters;
	PVOID SubSystemData;
	PVOID ProcessHeap;
	PRTL_CRITICAL_SECTION FastPebLock;
	PVOID AtlThunkSListPtr;
	PVOID IFEOKey;
	union
	{
		ULONG CrossProcessFlags;
		struct
		{
			ULONG ProcessInJob : 1;
			ULONG ProcessInitializing : 1;
			ULONG ProcessUsingVEH : 1;
			ULONG ProcessUsingVCH : 1;
			ULONG ProcessUsingFTH : 1;
			ULONG ReservedBits0 : 27;
		};
	};
	union
	{
		PVOID KernelCallbackTable;
		PVOID UserSharedInfoPtr;
	};
	ULONG SystemReserved[1];
	ULONG AtlThunkSListPtr32;
	PVOID ApiSetMap;
	ULONG TlsExpansionCounter;
	PVOID TlsBitmap;
	ULONG TlsBitmapBits[2];
	PVOID ReadOnlySharedMemoryBase;
	PVOID HotpatchInformation;
	PVOID *ReadOnlyStaticServerData;
	PVOID AnsiCodePageData;
	PVOID OemCodePageData;
	PVOID UnicodeCaseTableData;

	ULONG NumberOfProcessors;
	ULONG NtGlobalFlag;

	LARGE_INTEGER CriticalSectionTimeout;
	SIZE_T HeapSegmentReserve;
	SIZE_T HeapSegmentCommit;
	SIZE_T HeapDeCommitTotalFreeThreshold;
	SIZE_T HeapDeCommitFreeBlockThreshold;

	ULONG NumberOfHeaps;
	ULONG MaximumNumberOfHeaps;
	PVOID *ProcessHeaps;

	PVOID GdiSharedHandleTable;
	PVOID ProcessStarterHelper;
	ULONG GdiDCAttributeList;

	PRTL_CRITICAL_SECTION LoaderLock;

	ULONG OSMajorVersion;
	ULONG OSMinorVersion;
	USHORT OSBuildNumber;
	USHORT OSCSDVersion;
	ULONG OSPlatformId;
	ULONG ImageSubsystem;
	ULONG ImageSubsystemMajorVersion;
	ULONG ImageSubsystemMinorVersion;
	ULONG_PTR ActiveProcessAffinityMask;
	GDI_HANDLE_BUFFER GdiHandleBuffer;
	PVOID PostProcessInitRoutine;

	PVOID TlsExpansionBitmap;
	ULONG TlsExpansionBitmapBits[32];

	ULONG SessionId;

	ULARGE_INTEGER AppCompatFlags;
	ULARGE_INTEGER AppCompatFlagsUser;
	PVOID pShimData;
	PVOID AppCompatInfo;

	UNICODE_STRING CSDVersion;

	PVOID ActivationContextData;
	PVOID ProcessAssemblyStorageMap;
	PVOID SystemDefaultActivationContextData;
	PVOID SystemAssemblyStorageMap;

	SIZE_T MinimumStackCommit;

	PVOID *FlsCallback;
	LIST_ENTRY FlsListHead;
	PVOID FlsBitmap;
	ULONG FlsBitmapBits[FLS_MAXIMUM_AVAILABLE / (sizeof(ULONG) * 8)];
	ULONG FlsHighIndex;

	PVOID WerRegistrationData;
	PVOID WerShipAssertPtr;
	PVOID pContextData;
	PVOID pImageHeaderHash;
	union
	{
		ULONG TracingFlags;
		struct
		{
			ULONG HeapTracingEnabled : 1;
			ULONG CritSecTracingEnabled : 1;
			ULONG LibLoaderTracingEnabled : 1;
			ULONG SpareTracingBits : 29;
		};
	};
	ULONGLONG CsrServerReadOnlySharedMemoryBase;
	PVOID TppWorkerpListLock;
	LIST_ENTRY TppWorkerpList;
	PVOID WaitOnAddressHashTable[128];
} PEB, *PPEB;

#define GDI_BATCH_BUFFER_SIZE 310

typedef struct _GDI_TEB_BATCH
{
	ULONG Offset;
	ULONG_PTR HDC;
	ULONG Buffer[GDI_BATCH_BUFFER_SIZE];
} GDI_TEB_BATCH, *PGDI_TEB_BATCH;

typedef struct _TEB_ACTIVE_FRAME_CONTEXT
{
	ULONG Flags;
	PSTR FrameName;
} TEB_ACTIVE_FRAME_CONTEXT, *PTEB_ACTIVE_FRAME_CONTEXT;

typedef struct _TEB_ACTIVE_FRAME
{
	ULONG Flags;
	struct _TEB_ACTIVE_FRAME *Previous;
	PTEB_ACTIVE_FRAME_CONTEXT Context;
} TEB_ACTIVE_FRAME, *PTEB_ACTIVE_FRAME;

typedef struct _TEB
{
	NT_TIB NtTib;

	PVOID EnvironmentPointer;
	CLIENT_ID ClientId;
	PVOID ActiveRpcHandle;
	PVOID ThreadLocalStoragePointer;
	PPEB ProcessEnvironmentBlock;

	ULONG LastErrorValue;
	ULONG CountOfOwnedCriticalSections;
	PVOID CsrClientThread;
	PVOID Win32ThreadInfo;
	ULONG User32Reserved[26];
	ULONG UserReserved[5];
	PVOID WOW32Reserved;
	LCID CurrentLocale;
	ULONG FpSoftwareStatusRegister;
	PVOID ReservedForDebuggerInstrumentation[16];
	PVOID SystemReserved1[37];
	UCHAR WorkingOnBehalfTicket[8];
	NTSTATUS ExceptionCode;

	PVOID ActivationContextStackPointer;
	ULONG_PTR InstrumentationCallbackSp;
	ULONG_PTR InstrumentationCallbackPreviousPc;
	ULONG_PTR InstrumentationCallbackPreviousSp;
	ULONG TxFsContext;

	BOOLEAN InstrumentationCallbackDisabled;
	GDI_TEB_BATCH GdiTebBatch;
	CLIENT_ID RealClientId;
	HANDLE GdiCachedProcessHandle;
	ULONG GdiClientPID;
	ULONG GdiClientTID;
	PVOID GdiThreadLocalInfo;
	ULONG_PTR Win32ClientInfo[62];
	PVOID glDispatchTable[233];
	ULONG_PTR glReserved1[29];
	PVOID glReserved2;
	PVOID glSectionInfo;
	PVOID glSection;
	PVOID glTable;
	PVOID glCurrentRC;
	PVOID glContext;

	NTSTATUS LastStatusValue;
	UNICODE_STRING StaticUnicodeString;
	WCHAR StaticUnicodeBuffer[261];

	PVOID DeallocationStack;
	PVOID TlsSlots[64];
	LIST_ENTRY TlsLinks;

	PVOID Vdm;
	PVOID ReservedForNtRpc;
	PVOID DbgSsReserved[2];

	ULONG HardErrorMode;
#ifdef _WIN64
	PVOID Instrumentation[11];
#else
	PVOID Instrumentation[9];
#endif
	GUID ActivityId;

	PVOID SubProcessTag;
	PVOID PerflibData;
	PVOID EtwTraceData;
	PVOID WinSockData;
	ULONG GdiBatchCount;

	union
	{
		PROCESSOR_NUMBER CurrentIdealProcessor;
		ULONG IdealProcessorValue;
		struct
		{
			UCHAR ReservedPad0;
			UCHAR ReservedPad1;
			UCHAR ReservedPad2;
			UCHAR IdealProcessor;
		};
	};

	ULONG GuaranteedStackBytes;
	PVOID ReservedForPerf;
	PVOID ReservedForOle;
	ULONG WaitingOnLoaderLock;
	PVOID SavedPriorityState;
	ULONG_PTR ReservedForCodeCoverage;
	PVOID ThreadPoolData;
	PVOID *TlsExpansionSlots;
#ifdef _WIN64
	PVOID DeallocationBStore;
	PVOID BStoreLimit;
#endif
	ULONG MuiGeneration;
	ULONG IsImpersonating;
	PVOID NlsCache;
	PVOID pShimData;
	USHORT HeapVirtualAffinity;
	USHORT LowFragHeapDataSlot;
	HANDLE CurrentTransactionHandle;
	PTEB_ACTIVE_FRAME ActiveFrame;
	PVOID FlsData;

	PVOID PreferredLanguages;
	PVOID UserPrefLanguages;
	PVOID MergedPrefLanguages;
	ULONG MuiImpersonation;

	union
	{
		USHORT CrossTebFlags;
		USHORT SpareCrossTebBits : 16;
	};
	union
	{
		USHORT SameTebFlags;
		struct
		{
			USHORT SafeThunkCall : 1;
			USHORT InDebugPrint : 1;
			USHORT HasFiberData : 1;
			USHORT SkipThreadAttach : 1;
			USHORT WerInShipAssertCode : 1;
			USHORT RanProcessInit : 1;
			USHORT ClonedThread : 1;
			USHORT SuppressDebugMsg : 1;
			USHORT DisableUserStackWalk : 1;
			USHORT RtlExceptionAttached : 1;
			USHORT InitialThread : 1;
			USHORT SessionAware : 1;
			USHORT LoadOwner : 1;
			USHORT LoaderWorker : 1;
			USHORT SpareSameTebBits : 2;
		};
	};

	PVOID TxnScopeEnterCallback;
	PVOID TxnScopeExitCallback;
	PVOID TxnScopeContext;
	ULONG LockCount;
	LONG WowTebOffset;
	PVOID ResourceRetValue;
	PVOID ReservedForWdf;
	ULONGLONG ReservedForCrt;
	GUID EffectiveContainerId;
} TEB, *PTEB;

typedef enum _APPHELPCACHESERVICECLASS
{
	ApphelpCacheLookupEntry,
	ApphelpCacheRemoveEntry,
	ApphelpCacheInsertEntry,
	ApphelpCacheFlush,
	ApphelpCacheMax
} APPHELPCACHESERVICECLASS;

typedef struct _AHCACHE_SERVICE_DATA {
	UNICODE_STRING FileName;
	PVOID FileHandle;
} AHCACHE_SERVICE_DATA, *PAHCACHE_SERVICE_DATA;

typedef enum _MEMORY_RESERVE_TYPE
{
	MemoryReserveUserApc,
	MemoryReserveIoCompletion,
	MemoryReserveTypeMax
} MEMORY_RESERVE_TYPE;

typedef struct _TOKEN_SECURITY_ATTRIBUTE_FQBN_VALUE
{
	ULONG64 Version;
	UNICODE_STRING Name;
} TOKEN_SECURITY_ATTRIBUTE_FQBN_VALUE, *PTOKEN_SECURITY_ATTRIBUTE_FQBN_VALUE;

typedef struct _TOKEN_SECURITY_ATTRIBUTE_OCTET_STRING_VALUE
{
	PVOID pValue;
	ULONG ValueLength;
} TOKEN_SECURITY_ATTRIBUTE_OCTET_STRING_VALUE, *PTOKEN_SECURITY_ATTRIBUTE_OCTET_STRING_VALUE;

typedef struct _TOKEN_SECURITY_ATTRIBUTE_V1
{
	UNICODE_STRING Name;
	USHORT ValueType;
	USHORT Reserved;
	ULONG Flags;
	ULONG ValueCount;
	union
	{
		PLONG64 pInt64;
		PULONG64 pUint64;
		PUNICODE_STRING pString;
		PTOKEN_SECURITY_ATTRIBUTE_FQBN_VALUE pFqbn;
		PTOKEN_SECURITY_ATTRIBUTE_OCTET_STRING_VALUE pOctetString;
	} Values;
} TOKEN_SECURITY_ATTRIBUTE_V1, *PTOKEN_SECURITY_ATTRIBUTE_V1;

typedef struct _TOKEN_SECURITY_ATTRIBUTES_INFORMATION
{
	USHORT Version;
	USHORT Reserved;
	ULONG AttributeCount;
	union
	{
		PTOKEN_SECURITY_ATTRIBUTE_V1 pAttributeV1;
	} Attribute;
} TOKEN_SECURITY_ATTRIBUTES_INFORMATION, *PTOKEN_SECURITY_ATTRIBUTES_INFORMATION;

typedef struct _FILE_PATH
{
	ULONG Version;
	ULONG Length;
	ULONG Type;
	UCHAR FilePath[1];
} FILE_PATH, *PFILE_PATH;

typedef const WNF_STATE_NAME *PCWNF_STATE_NAME;

typedef enum _WNF_STATE_NAME_LIFETIME
{
	WnfWellKnownStateName,
	WnfPermanentStateName,
	WnfPersistentStateName,
	WnfTemporaryStateName
} WNF_STATE_NAME_LIFETIME;

typedef enum _WNF_STATE_NAME_INFORMATION
{
	WnfInfoStateNameExist,
	WnfInfoSubscribersPresent,
	WnfInfoIsQuiescent
} WNF_STATE_NAME_INFORMATION;

typedef enum _WNF_DATA_SCOPE
{
	WnfDataScopeSystem,
	WnfDataScopeSession,
	WnfDataScopeUser,
	WnfDataScopeProcess
} WNF_DATA_SCOPE;

typedef struct _WNF_TYPE_ID
{
	GUID TypeId;
} WNF_TYPE_ID, *PWNF_TYPE_ID;

typedef const WNF_TYPE_ID *PCWNF_TYPE_ID;

typedef enum _FILTER_BOOT_OPTION_OPERATION
{
	FilterBootOptionOperationOpenSystemStore,
	FilterBootOptionOperationSetElement,
	FilterBootOptionOperationDeleteElement,
	FilterBootOptionOperationMax
} FILTER_BOOT_OPTION_OPERATION;

typedef UCHAR SE_SIGNING_LEVEL, *PSE_SIGNING_LEVEL;

typedef enum _VdmServiceClass {
	VdmStartExecution,
	VdmQueueInterrupt,
	VdmDelayInterrupt,
	VdmInitialize,
	VdmFeatures,
	VdmSetInt21Handler,
	VdmQueryDir,
	VdmPrinterDirectIoOpen,
	VdmPrinterDirectIoClose,
	VdmPrinterInitialize,
	VdmSetLdtEntries,
	VdmSetProcessLdtInfo,
	VdmAdlibEmulation,
	VdmPMCliControl,
	VdmQueryVdmProcess
} VDMSERVICECLASS, *PVDMSERVICECLASS;

typedef enum _DEBUGOBJECTINFOCLASS {
	DebugObjectFlags = 1,
	MaxDebugObjectInfoClass
} DEBUGOBJECTINFOCLASS, *PDEBUGOBJECTINFOCLASS;

typedef enum _IO_COMPLETION_INFORMATION_CLASS
{
	IoCompletionBasicInformation
} IO_COMPLETION_INFORMATION_CLASS;

#define JOB_OBJECT_CPU_RATE_CONTROL_ENABLE 0x1
#define JOB_OBJECT_CPU_RATE_CONTROL_WEIGHT_BASED 0x2
#define JOB_OBJECT_CPU_RATE_CONTROL_HARD_CAP 0x4
#define JOB_OBJECT_CPU_RATE_CONTROL_NOTIFY 0x8
#define JOB_OBJECT_CPU_RATE_CONTROL_MIN_MAX_RATE 0x10
#define JOB_OBJECT_CPU_RATE_CONTROL_VALID_FLAGS 0x1f

typedef enum _JOBOBJECTINFOCLASS
{
	JobObjectBasicAccountingInformation = 1,
	JobObjectBasicLimitInformation,
	JobObjectBasicProcessIdList,
	JobObjectBasicUIRestrictions,
	JobObjectSecurityLimitInformation,  // deprecated
	JobObjectEndOfJobTimeInformation,
	JobObjectAssociateCompletionPortInformation,
	JobObjectBasicAndIoAccountingInformation,
	JobObjectExtendedLimitInformation,
	JobObjectJobSetInformation,
	JobObjectGroupInformation,
	JobObjectNotificationLimitInformation,
	JobObjectLimitViolationInformation,
	JobObjectGroupInformationEx,
	JobObjectCpuRateControlInformation,
	JobObjectCompletionFilter,
	JobObjectCompletionCounter,
	JobObjectReserved1Information = 18,
	JobObjectReserved2Information,
	JobObjectReserved3Information,
	JobObjectReserved4Information,
	JobObjectReserved5Information,
	JobObjectReserved6Information,
	JobObjectReserved7Information,
	JobObjectReserved8Information,
	JobObjectReserved9Information,
	JobObjectReserved10Information,
	JobObjectReserved11Information,
	JobObjectReserved12Information,
	JobObjectReserved13Information,
	JobObjectReserved14Information = 31,
	JobObjectNetRateControlInformation,
	JobObjectNotificationLimitInformation2,
	JobObjectLimitViolationInformation2,
	JobObjectCreateSilo,
	JobObjectSiloBasicInformation,
	JobObjectReserved15Information = 37,
	JobObjectReserved16Information = 38,
	JobObjectReserved17Information = 39,
	JobObjectReserved18Information = 40,
	JobObjectReserved19Information = 41,
	JobObjectReserved20Information = 42,
	JobObjectReserved21Information = 43,
	JobObjectReserved22Information = 44,
	JobObjectReserved23Information = 45,
	JobObjectReserved24Information = 46,
	JobObjectReserved25Information = 47,
	MaxJobObjectInfoClass
} JOBOBJECTINFOCLASS;

typedef enum _SECTION_INFORMATION_CLASS
{
	SectionBasicInformation,
	SectionImageInformation,
	SectionRelocationInformation, // name:wow64:whNtQuerySection_SectionRelocationInformation
	SectionOriginalBaseInformation, // PVOID BaseAddress
	MaxSectionInfoClass
} SECTION_INFORMATION_CLASS;

typedef enum _SYSDBG_COMMAND
{
	SysDbgQueryModuleInformation,
	SysDbgQueryTraceInformation,
	SysDbgSetTracepoint,
	SysDbgSetSpecialCall,
	SysDbgClearSpecialCalls,
	SysDbgQuerySpecialCalls,
	SysDbgBreakPoint,
	SysDbgQueryVersion,
	SysDbgReadVirtual,
	SysDbgWriteVirtual,
	SysDbgReadPhysical,
	SysDbgWritePhysical,
	SysDbgReadControlSpace,
	SysDbgWriteControlSpace,
	SysDbgReadIoSpace,
	SysDbgWriteIoSpace,
	SysDbgReadMsr,
	SysDbgWriteMsr,
	SysDbgReadBusData,
	SysDbgWriteBusData,
	SysDbgCheckLowMemory,
	SysDbgEnableKernelDebugger,
	SysDbgDisableKernelDebugger,
	SysDbgGetAutoKdEnable,
	SysDbgSetAutoKdEnable,
	SysDbgGetPrintBufferSize,
	SysDbgSetPrintBufferSize,
	SysDbgGetKdUmExceptionEnable,
	SysDbgSetKdUmExceptionEnable,
	SysDbgGetTriageDump,
	SysDbgGetKdBlockEnable,
	SysDbgSetKdBlockEnable,
	SysDbgRegisterForUmBreakInfo,
	SysDbgGetUmBreakPid,
	SysDbgClearUmBreakPid,
	SysDbgGetUmAttachPid,
	SysDbgClearUmAttachPid,
	SysDbgGetLiveKernelDump
} SYSDBG_COMMAND, *PSYSDBG_COMMAND;

typedef enum _ATOM_INFORMATION_CLASS
{
	AtomBasicInformation,
	AtomTableInformation
} ATOM_INFORMATION_CLASS;

typedef enum _SHUTDOWN_ACTION
{
	ShutdownNoReboot,
	ShutdownReboot,
	ShutdownPowerOff
} SHUTDOWN_ACTION;

typedef VOID (*PPS_APC_ROUTINE)(
	_In_opt_ PVOID ApcArgument1,
	_In_opt_ PVOID ApcArgument2,
	_In_opt_ PVOID ApcArgument3
	);

typedef struct _INITIAL_TEB
{
	struct
	{
		PVOID OldStackBase;
		PVOID OldStackLimit;
	} OldInitialTeb;
	PVOID StackBase;
	PVOID StackLimit;
	PVOID StackAllocationBase;
} INITIAL_TEB, *PINITIAL_TEB;

typedef USHORT RTL_ATOM, *PRTL_ATOM;

// The syscall declarations below were autogenerated from the entire list of syscalls, and then culled to remove WDM/ntddk collisions. So:
// (1) Some declarations are missing
// (2) Not all of the Zw* declarations are actually exported by the kernel. If you use one, hit compile first to check for linker errors
// The Nt* declarations on the other hand *are* all exported, and *only* as Nt, not Zw.
// Update: I've made an exception to this for some syscalls that can be imported as either: static Nt* imports have a slight advantage if
// you know for certain that PreviousMode will be Kernel (e.g. in DriverEntry context), as they can't be hooked as easily through e.g. the SSDT.
// Imports that exist in both Nt* and Zw* versions will be in the regular list further below, with Nt appearing first followed by Zw.

NTSYSCALLAPI
NTSTATUS
NTAPI
NtAddAtom(
	_In_ PWSTR AtomName,
	_In_ ULONG Length,
	_Out_opt_ PRTL_ATOM Atom
	);

NTSYSCALLAPI
NTSTATUS
NTAPI
NtAllocateUuids(
	_Out_ PULARGE_INTEGER Time,
	_Out_ PULONG Range,
	_Out_ PULONG Sequence,
	_Out_ PCHAR Seed
	);

NTSYSCALLAPI
NTSTATUS
NTAPI
NtDeleteAtom(
	_In_ RTL_ATOM Atom
	);

NTSYSCALLAPI
NTSTATUS
NTAPI
NtFindAtom(
	_In_ PWSTR AtomName,
	_In_ ULONG Length,
	_Out_opt_ PRTL_ATOM Atom
	);

NTSYSCALLAPI
NTSTATUS
NTAPI
NtFreezeTransactions(
	_In_ PLARGE_INTEGER FreezeTimeout,
	_In_ PLARGE_INTEGER ThawTimeout
	);

NTSYSCALLAPI
NTSTATUS
NTAPI
NtMakePermanentObject(
	_In_ HANDLE Handle
	);

NTSYSCALLAPI
NTSTATUS
NTAPI
NtNotifyChangeDirectoryFile(
	_In_ HANDLE FileHandle,
	_In_opt_ HANDLE Event,
	_In_opt_ PIO_APC_ROUTINE ApcRoutine,
	_In_opt_ PVOID ApcContext,
	_Out_ PIO_STATUS_BLOCK IoStatusBlock,
	_Out_ FILE_NOTIFY_INFORMATION Buffer,
	_In_ ULONG Length,
	_In_ ULONG CompletionFilter,
	_In_ BOOLEAN WatchTree
	);

NTSYSCALLAPI
NTSTATUS
NTAPI
NtQueryInformationAtom(
	_In_ RTL_ATOM Atom,
	_In_ ATOM_INFORMATION_CLASS AtomInformationClass,
	_Out_ PVOID AtomInformation,
	_In_ ULONG AtomInformationLength,
	_Out_opt_ PULONG ReturnLength
	);

NTSYSCALLAPI
NTSTATUS
NTAPI
NtQuerySystemInformationEx(
	_In_ SYSTEM_INFORMATION_CLASS SystemInformationClass,
	_In_ PVOID InputBuffer,
	_In_ ULONG InputBufferLength,
	_Out_opt_ PVOID SystemInformation,
	_In_ ULONG SystemInformationLength,
	_Out_opt_ PULONG ReturnLength
	);

// Added even though it is available as Zw*, because ThreadInformationClass = ThreadWow64Context gives very
// different results depending on previous mode. (Also goes for NtSetInformationThread but that is in ntifs.h.)
_IRQL_requires_max_(PASSIVE_LEVEL)
NTSYSCALLAPI
NTSTATUS
NTAPI
NtQueryInformationThread(
	_In_ HANDLE ThreadHandle,
	_In_ THREADINFOCLASS ThreadInformationClass,
	_Out_writes_bytes_(ThreadInformationLength) PVOID ThreadInformation,
	_In_ ULONG ThreadInformationLength,
	_Out_opt_ PULONG ReturnLength
	);

NTSYSCALLAPI
NTSTATUS
NTAPI
NtShutdownSystem(
	_In_ SHUTDOWN_ACTION Action
	);

NTSYSCALLAPI
NTSTATUS
NTAPI
NtThawTransactions(
	);

NTSYSCALLAPI
NTSTATUS
NTAPI
NtTraceControl(
	_In_ ULONG FunctionCode,
	_In_ PVOID InBuffer,
	_In_ ULONG InBufferLen,
	_Out_opt_ PVOID OutBuffer,
	_In_ ULONG OutBufferLen,
	_Out_ PULONG ReturnLength
	);

NTSYSCALLAPI
NTSTATUS
NTAPI
NtVdmControl(
	_In_ VDMSERVICECLASS Service,
	_Inout_ PVOID ServiceData
	);

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwAccessCheck(
	_In_ PSECURITY_DESCRIPTOR SecurityDescriptor,
	_In_ HANDLE ClientToken,
	_In_ ACCESS_MASK DesiredAccess,
	_In_ PGENERIC_MAPPING GenericMapping,
	_Out_ PPRIVILEGE_SET PrivilegeSet,
	_Inout_ PULONG PrivilegeSetLength,
	_Out_ PACCESS_MASK GrantedAccess,
	_Out_ PNTSTATUS AccessStatus
	);

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwAccessCheckAndAuditAlarm(
	_In_ PUNICODE_STRING SubsystemName,
	_In_opt_ PVOID HandleId,
	_In_ PUNICODE_STRING ObjectTypeName,
	_In_ PUNICODE_STRING ObjectName,
	_In_ PSECURITY_DESCRIPTOR SecurityDescriptor,
	_In_ ACCESS_MASK DesiredAccess,
	_In_ PGENERIC_MAPPING GenericMapping,
	_In_ BOOLEAN ObjectCreation,
	_Out_ PACCESS_MASK GrantedAccess,
	_Out_ PNTSTATUS AccessStatus,
	_Out_ PBOOLEAN GenerateOnClose
	);

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwAcquireCMFViewOwnership(
	_Out_ PULONGLONG TimeStamp,
	_Out_ PBOOLEAN tokenTaken,
	_In_ BOOLEAN replaceExisting
	);

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwAdjustPrivilegesToken(
	_In_ HANDLE TokenHandle,
	_In_ BOOLEAN DisableAllPrivileges,
	_In_opt_ PTOKEN_PRIVILEGES NewState,
	_In_ ULONG BufferLength,
	_Out_writes_bytes_to_opt_(BufferLength, *ReturnLength) PTOKEN_PRIVILEGES PreviousState,
	_Out_ _When_(PreviousState == NULL, _Out_opt_) PULONG ReturnLength
	);

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwAlertResumeThread(
	_In_ HANDLE ThreadHandle,
	_Out_opt_ PULONG PreviousSuspendCount
	);

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwAlertThread(
	_In_ HANDLE ThreadHandle
	);

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwAlertThreadByThreadId(
	_In_ HANDLE ThreadId
	);

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwAllocateReserveObject(
	_Out_ PHANDLE MemoryReserveHandle,
	_In_ POBJECT_ATTRIBUTES ObjectAttributes,
	_In_ MEMORY_RESERVE_TYPE Type
	);

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwAllocateUserPhysicalPages(
	_In_ HANDLE ProcessHandle,
	_Inout_ PULONG_PTR NumberOfPages,
	_Out_ PULONG_PTR UserPfnArray
	);

#if (NTDDI_VERSION >= NTDDI_WIN10_RS5)
_Must_inspect_result_
_IRQL_requires_max_(PASSIVE_LEVEL)
_When_(return == 0, __drv_allocatesMem(Region))
NTSYSAPI
NTSTATUS
NTAPI
ZwAllocateVirtualMemoryEx(
	_In_ HANDLE ProcessHandle,
	_Inout_ _At_(*BaseAddress, _Readable_bytes_(*RegionSize) _Writable_bytes_(*RegionSize) _Post_readable_byte_size_(*RegionSize)) PVOID* BaseAddress,
	_Inout_ PSIZE_T RegionSize,
	_In_ ULONG AllocationType,
	_In_ ULONG PageProtection,
	_Inout_updates_opt_(ExtendedParameterCount) PMEM_EXTENDED_PARAMETER ExtendedParameters,
	_In_ ULONG ExtendedParameterCount
	);
#endif

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwApphelpCacheControl(
	_In_ APPHELPCACHESERVICECLASS Service,
	_In_ PAHCACHE_SERVICE_DATA ServiceData
	);

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwAreMappedFilesTheSame(
	_In_ PVOID File1MappedAsAnImage,
	_In_ PVOID File2MappedAsFile
	);

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwAssignProcessToJobObject(
	_In_ HANDLE JobHandle,
	_In_ HANDLE ProcessHandle
	);

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwAssociateWaitCompletionPacket(
	_In_ HANDLE WaitCompletionPacketHandle,
	_In_ HANDLE IoCompletionHandle,
	_In_ HANDLE TargetObjectHandle,
	_In_opt_ PVOID KeyContext,
	_In_opt_ PVOID ApcContext,
	_In_ NTSTATUS IoStatus,
	_In_ ULONG_PTR IoStatusInformation,
	_Out_opt_ PBOOLEAN AlreadySignaled
	);

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwCallbackReturn(
	_In_ PVOID OutputBuffer,
	_In_ ULONG OutputLength,
	_In_ NTSTATUS Status
	);

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwCancelDeviceWakeupRequest(
	_In_ HANDLE Device
	);

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwCancelIoFile(
	_In_ HANDLE FileHandle,
	_Out_ PIO_STATUS_BLOCK IoStatusBlock
	);

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwCancelIoFileEx(
	_In_ HANDLE FileHandle,
	_In_opt_ PIO_STATUS_BLOCK IoRequestToCancel,
	_Out_ PIO_STATUS_BLOCK IoStatusBlock
	);

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwCancelSynchronousIoFile(
	_In_ HANDLE ThreadHandle,
	_In_opt_ PIO_STATUS_BLOCK IoRequestToCancel,
	_Out_ PIO_STATUS_BLOCK IoStatusBlock
	);

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwCancelWaitCompletionPacket(
	_In_ HANDLE WaitCompletionPacketHandle,
	_In_ BOOLEAN RemoveSignaledPacket
	);

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwClearEvent(
	_In_ HANDLE EventHandle
	);

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwCloseObjectAuditAlarm(
	_In_ PUNICODE_STRING SubsystemName,
	_In_opt_ PVOID HandleId,
	_In_ BOOLEAN GenerateOnClose
	);

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwCompactKeys(
	_In_ ULONG Count,
	_In_ HANDLE KeyArray[]
	);

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwCompareObjects(
	_In_ HANDLE FirstObjectHandle,
	_In_ HANDLE SecondObjectHandle
	);

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwCompareTokens(
	_In_ HANDLE FirstTokenHandle,
	_In_ HANDLE SecondTokenHandle,
	_Out_ PBOOLEAN Equal
	);

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwCompressKey(
	_In_ HANDLE Key
	);

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwContinue(
	_In_ PCONTEXT ContextRecord,
	_In_ BOOLEAN TestAlert
	);

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwCreateDebugObject(
	_Out_ PHANDLE DebugObjectHandle,
	_In_ ACCESS_MASK DesiredAccess,
	_In_ POBJECT_ATTRIBUTES ObjectAttributes,
	_In_ ULONG Flags
	);

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwCreateDirectoryObjectEx(
	_Out_ PHANDLE DirectoryHandle,
	_In_ ACCESS_MASK DesiredAccess,
	_In_ POBJECT_ATTRIBUTES ObjectAttributes,
	_In_ HANDLE ShadowDirectoryHandle,
	_In_ ULONG Flags
	);

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwCreateEventPair(
	_Out_ PHANDLE EventPairHandle,
	_In_ ACCESS_MASK DesiredAccess,
	_In_opt_ POBJECT_ATTRIBUTES ObjectAttributes
	);

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwCreateIRTimer(
	_Out_ PHANDLE TimerHandle,
	_In_ ACCESS_MASK DesiredAccess
	);

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwCreateIoCompletion(
	_Out_ PHANDLE IoCompletionHandle,
	_In_ ACCESS_MASK DesiredAccess,
	_In_opt_ POBJECT_ATTRIBUTES ObjectAttributes,
	_In_opt_ ULONG Count
	);

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwCreateJobObject(
	_Out_ PHANDLE JobHandle,
	_In_ ACCESS_MASK DesiredAccess,
	_In_opt_ POBJECT_ATTRIBUTES ObjectAttributes
	);

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwCreateKeyedEvent(
	_Out_ PHANDLE KeyedEventHandle,
	_In_ ACCESS_MASK DesiredAccess,
	_In_opt_ POBJECT_ATTRIBUTES ObjectAttributes,
	_In_ ULONG Flags
	);

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwCreateMailslotFile(
	_Out_ PHANDLE FileHandle,
	_In_ ULONG DesiredAccess,
	_In_ POBJECT_ATTRIBUTES ObjectAttributes,
	_Out_ PIO_STATUS_BLOCK IoStatusBlock,
	_In_ ULONG CreateOptions,
	_In_ ULONG MailslotQuota,
	_In_ ULONG MaximumMessageSize,
	_In_ PLARGE_INTEGER ReadTimeout
	);

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwCreateMutant(
	_Out_ PHANDLE MutantHandle,
	_In_ ACCESS_MASK DesiredAccess,
	_In_opt_ POBJECT_ATTRIBUTES ObjectAttributes,
	_In_ BOOLEAN InitialOwner
	);

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwCreateNamedPipeFile(
	_Out_ PHANDLE FileHandle,
	_In_ ULONG DesiredAccess,
	_In_ POBJECT_ATTRIBUTES ObjectAttributes,
	_Out_ PIO_STATUS_BLOCK IoStatusBlock,
	_In_ ULONG ShareAccess,
	_In_ ULONG CreateDisposition,
	_In_ ULONG CreateOptions,
	_In_ ULONG NamedPipeType,
	_In_ ULONG ReadMode,
	_In_ ULONG CompletionMode,
	_In_ ULONG MaximumInstances,
	_In_ ULONG InboundQuota,
	_In_ ULONG OutboundQuota,
	_In_opt_ PLARGE_INTEGER DefaultTimeout
	);

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwCreatePagingFile(
	_In_ PUNICODE_STRING PageFileName,
	_In_ PLARGE_INTEGER MinimumSize,
	_In_ PLARGE_INTEGER MaximumSize,
	_In_ ULONG Priority
	);

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwCreatePartition(
	_Out_ PHANDLE PartitionHandle,
	_In_ ACCESS_MASK DesiredAccess,
	_In_opt_ POBJECT_ATTRIBUTES ObjectAttributes,
	_In_ ULONG PreferredNode
	);

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwCreatePrivateNamespace(
	_Out_ PHANDLE NamespaceHandle,
	_In_ ACCESS_MASK DesiredAccess,
	_In_ POBJECT_ATTRIBUTES ObjectAttributes,
	_In_ PVOID BoundaryDescriptor
	);

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwCreateProcess(
	_Out_ PHANDLE ProcessHandle,
	_In_ ACCESS_MASK DesiredAccess,
	_In_opt_ POBJECT_ATTRIBUTES ObjectAttributes,
	_In_ HANDLE ParentProcess,
	_In_ BOOLEAN InheritObjectTable,
	_In_opt_ HANDLE SectionHandle,
	_In_opt_ HANDLE DebugPort,
	_In_opt_ HANDLE ExceptionPort
	);

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwCreateProcessEx(
	_Out_ PHANDLE ProcessHandle,
	_In_ ACCESS_MASK DesiredAccess,
	_In_opt_ POBJECT_ATTRIBUTES ObjectAttributes,
	_In_ HANDLE ParentProcess,
	_In_ ULONG Flags,
	_In_opt_ HANDLE SectionHandle,
	_In_opt_ HANDLE DebugPort,
	_In_opt_ HANDLE ExceptionPort,
	_In_ ULONG JobMemberLevel
	);

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwCreateProfile(
	_Out_ PHANDLE ProfileHandle,
	_In_opt_ HANDLE Process,
	_In_ PVOID ProfileBase,
	_In_ SIZE_T ProfileSize,
	_In_ ULONG BucketSize,
	_In_ PULONG Buffer,
	_In_ ULONG BufferSize,
	_In_ KPROFILE_SOURCE ProfileSource,
	_In_ KAFFINITY Affinity
	);

#if (NTDDI_VERSION >= NTDDI_WIN10_RS5)
_Must_inspect_result_
NTSYSCALLAPI
NTSTATUS
NTAPI
NtCreateSectionEx(
	_Out_ PHANDLE SectionHandle,
	_In_ ACCESS_MASK DesiredAccess,
	_In_opt_ POBJECT_ATTRIBUTES ObjectAttributes,
	_In_opt_ PLARGE_INTEGER MaximumSize,
	_In_ ULONG SectionPageProtection,
	_In_ ULONG AllocationAttributes,
	_In_opt_ HANDLE FileHandle,
	_Inout_updates_opt_(ExtendedParameterCount) PMEM_EXTENDED_PARAMETER ExtendedParameters,
	_In_ ULONG ExtendedParameterCount
	);
#endif

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwCreateSemaphore(
	_Out_ PHANDLE SemaphoreHandle,
	_In_ ACCESS_MASK DesiredAccess,
	_In_opt_ POBJECT_ATTRIBUTES ObjectAttributes,
	_In_ LONG InitialCount,
	_In_ LONG MaximumCount
	);

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwCreateSymbolicLinkObject(
	_Out_ PHANDLE LinkHandle,
	_In_ ACCESS_MASK DesiredAccess,
	_In_ POBJECT_ATTRIBUTES ObjectAttributes,
	_In_ PUNICODE_STRING LinkTarget
	);

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwCreateThread(
	_Out_ PHANDLE ThreadHandle,
	_In_ ACCESS_MASK DesiredAccess,
	_In_opt_ POBJECT_ATTRIBUTES ObjectAttributes,
	_In_ HANDLE ProcessHandle,
	_Out_ PCLIENT_ID ClientId,
	_In_ PCONTEXT ThreadContext,
	_In_ PINITIAL_TEB InitialTeb,
	_In_ BOOLEAN CreateSuspended
	);

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwCreateThreadEx(
	_Out_ PHANDLE ThreadHandle,
	_In_ ACCESS_MASK DesiredAccess,
	_In_opt_ POBJECT_ATTRIBUTES ObjectAttributes,
	_In_ HANDLE ProcessHandle,
	_In_ PVOID StartRoutine, // PUSER_THREAD_START_ROUTINE
	_In_opt_ PVOID Argument,
	_In_ ULONG CreateFlags, // THREAD_CREATE_FLAGS_*
	_In_ SIZE_T ZeroBits,
	_In_ SIZE_T StackSize,
	_In_ SIZE_T MaximumStackSize,
	_In_opt_ PPS_ATTRIBUTE_LIST AttributeList
	);

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwCreateTimer2(
	_Out_ PHANDLE TimerHandle,
	_In_opt_ PVOID Reserved1,
	_In_opt_ PVOID Reserved2,
	_In_ ULONG Attributes,
	_In_ ACCESS_MASK DesiredAccess
	);

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwCreateToken(
	_Out_ PHANDLE TokenHandle,
	_In_ ACCESS_MASK DesiredAccess,
	_In_opt_ POBJECT_ATTRIBUTES ObjectAttributes,
	_In_ TOKEN_TYPE TokenType,
	_In_ PLUID AuthenticationId,
	_In_ PLARGE_INTEGER ExpirationTime,
	_In_ PTOKEN_USER User,
	_In_ PTOKEN_GROUPS Groups,
	_In_ PTOKEN_PRIVILEGES Privileges,
	_In_opt_ PTOKEN_OWNER Owner,
	_In_ PTOKEN_PRIMARY_GROUP PrimaryGroup,
	_In_opt_ PTOKEN_DEFAULT_DACL DefaultDacl,
	_In_ PTOKEN_SOURCE TokenSource
	);

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwCreateTokenEx(
	_Out_ PHANDLE TokenHandle,
	_In_ ACCESS_MASK DesiredAccess,
	_In_opt_ POBJECT_ATTRIBUTES ObjectAttributes,
	_In_ TOKEN_TYPE TokenType,
	_In_ PLUID AuthenticationId,
	_In_ PLARGE_INTEGER ExpirationTime,
	_In_ PTOKEN_USER User,
	_In_ PTOKEN_GROUPS Groups,
	_In_ PTOKEN_PRIVILEGES Privileges,
	_In_opt_ PTOKEN_SECURITY_ATTRIBUTES_INFORMATION UserAttributes,
	_In_opt_ PTOKEN_SECURITY_ATTRIBUTES_INFORMATION DeviceAttributes,
	_In_opt_ PTOKEN_GROUPS DeviceGroups,
	_In_opt_ PTOKEN_MANDATORY_POLICY TokenMandatoryPolicy,
	_In_opt_ PTOKEN_OWNER Owner,
	_In_ PTOKEN_PRIMARY_GROUP PrimaryGroup,
	_In_opt_ PTOKEN_DEFAULT_DACL DefaultDacl,
	_In_ PTOKEN_SOURCE TokenSource
	);

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwCreateUserProcess(
	_Out_ PHANDLE ProcessHandle,
	_Out_ PHANDLE ThreadHandle,
	_In_ ACCESS_MASK ProcessDesiredAccess,
	_In_ ACCESS_MASK ThreadDesiredAccess,
	_In_opt_ POBJECT_ATTRIBUTES ProcessObjectAttributes,
	_In_opt_ POBJECT_ATTRIBUTES ThreadObjectAttributes,
	_In_ ULONG ProcessFlags, // PROCESS_CREATE_FLAGS_*
	_In_ ULONG ThreadFlags, // THREAD_CREATE_FLAGS_*
	_In_opt_ PVOID ProcessParameters, // PRTL_USER_PROCESS_PARAMETERS
	_Inout_ PPS_CREATE_INFO CreateInfo,
	_In_opt_ PPS_ATTRIBUTE_LIST AttributeList
	);

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwCreateWaitCompletionPacket(
	_Out_ PHANDLE WaitCompletionPacketHandle,
	_In_ ACCESS_MASK DesiredAccess,
	_In_opt_ POBJECT_ATTRIBUTES ObjectAttributes
	);

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwCreateWnfStateName(
	_Out_ PWNF_STATE_NAME StateName,
	_In_ WNF_STATE_NAME_LIFETIME NameLifetime,
	_In_ WNF_DATA_SCOPE DataScope,
	_In_ BOOLEAN PersistData,
	_In_opt_ PCWNF_TYPE_ID TypeId,
	_In_ ULONG MaximumStateSize,
	_In_ PSECURITY_DESCRIPTOR SecurityDescriptor
	);

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwDebugActiveProcess(
	_In_ HANDLE ProcessHandle,
	_In_ HANDLE DebugObjectHandle
	);

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwDebugContinue(
	_In_ HANDLE DebugObjectHandle,
	_In_ PCLIENT_ID ClientId,
	_In_ NTSTATUS ContinueStatus
	);

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwDelayExecution(
	_In_ BOOLEAN Alertable,
	_In_ PLARGE_INTEGER DelayInterval
	);

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwDeleteBootEntry(
	_In_ ULONG Id
	);

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwDeleteDriverEntry(
	_In_ ULONG Id
	);

_IRQL_requires_max_(PASSIVE_LEVEL)
NTSYSAPI
NTSTATUS
NTAPI
NtDeleteFile( // The Zw version is in ntifs.h
	_In_ POBJECT_ATTRIBUTES ObjectAttributes
	);

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwDeleteObjectAuditAlarm(
	_In_ PUNICODE_STRING SubsystemName,
	_In_opt_ PVOID HandleId,
	_In_ BOOLEAN GenerateOnClose
	);

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwDeletePrivateNamespace(
	_In_ HANDLE NamespaceHandle
	);

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwDeleteWnfStateData(
	_In_ PCWNF_STATE_NAME StateName,
	_In_opt_ const VOID *ExplicitScope
	);

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwDeleteWnfStateName(
	_In_ PCWNF_STATE_NAME StateName
	);

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwDisableLastKnownGood(
	);

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwDrawText(
	_In_ PUNICODE_STRING String
	);

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwEnableLastKnownGood(
	);

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwEnumerateBootEntries(
	_Out_ PVOID Buffer,
	_Inout_ PULONG BufferLength
	);

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwEnumerateDriverEntries(
	_Out_ PVOID Buffer,
	_Inout_ PULONG BufferLength
	);

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwEnumerateSystemEnvironmentValuesEx(
	_In_ ULONG InformationClass,
	_Out_ PVOID Buffer,
	_Inout_ PULONG BufferLength
	);

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwExtendSection(
	_In_ HANDLE SectionHandle,
	_Inout_ PLARGE_INTEGER NewSectionSize
	);

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwFilterBootOption(
	_In_ FILTER_BOOT_OPTION_OPERATION FilterOperation,
	_In_ ULONG ObjectType,
	_In_ ULONG ElementType,
	_In_ PVOID Data,
	_In_ ULONG DataSize
	);

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwFilterToken(
	_In_ HANDLE ExistingTokenHandle,
	_In_ ULONG Flags,
	_In_opt_ PTOKEN_GROUPS SidsToDisable,
	_In_opt_ PTOKEN_PRIVILEGES PrivilegesToDelete,
	_In_opt_ PTOKEN_GROUPS RestrictedSids,
	_Out_ PHANDLE NewTokenHandle
	);

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwFilterTokenEx(
	_In_ HANDLE ExistingTokenHandle,
	_In_ ULONG Flags,
	_In_opt_ PTOKEN_GROUPS SidsToDisable,
	_In_opt_ PTOKEN_PRIVILEGES PrivilegesToDelete,
	_In_opt_ PTOKEN_GROUPS RestrictedSids,
	_In_ ULONG DisableUserClaimsCount,
	_In_opt_ PUNICODE_STRING UserClaimsToDisable,
	_In_ ULONG DisableDeviceClaimsCount,
	_In_opt_ PUNICODE_STRING DeviceClaimsToDisable,
	_In_opt_ PTOKEN_GROUPS DeviceGroupsToDisable,
	_In_opt_ PTOKEN_SECURITY_ATTRIBUTES_INFORMATION RestrictedUserAttributes,
	_In_opt_ PTOKEN_SECURITY_ATTRIBUTES_INFORMATION RestrictedDeviceAttributes,
	_In_opt_ PTOKEN_GROUPS RestrictedDeviceGroups,
	_Out_ PHANDLE NewTokenHandle
	);

_IRQL_requires_max_(PASSIVE_LEVEL)
NTSYSCALLAPI
NTSTATUS
NTAPI
ZwFlushBuffersFileEx(
	_In_ HANDLE FileHandle,
	_In_ ULONG Flags,
	_In_reads_bytes_(ParametersSize) PVOID Parameters,
	_In_ ULONG ParametersSize,
	_Out_ PIO_STATUS_BLOCK IoStatusBlock
	);

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwFlushInstallUILanguage(
	_In_ LANGID InstallUILanguage,
	_In_ ULONG SetComittedFlag
	);

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwFlushInstructionCache(
	_In_ HANDLE ProcessHandle,
	_In_opt_ PVOID BaseAddress,
	_In_ SIZE_T Length
	);

NTSYSCALLAPI
VOID
NTAPI
ZwFlushProcessWriteBuffers(
	);

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwFlushWriteBuffer(
	);

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwFreeUserPhysicalPages(
	_In_ HANDLE ProcessHandle,
	_Inout_ PULONG_PTR NumberOfPages,
	_In_ PULONG_PTR UserPfnArray
	);

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwFreezeRegistry(
	_In_ ULONG TimeOutInSeconds
	);

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwGetCachedSigningLevel(
	_In_ HANDLE File,
	_Out_ PULONG Flags,
	_Out_ PSE_SIGNING_LEVEL SigningLevel,
	_Out_ PUCHAR Thumbprint,
	_Inout_opt_ PULONG ThumbprintSize,
	_Out_opt_ PULONG ThumbprintAlgorithm
	);

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwGetContextThread(
	_In_ HANDLE ThreadHandle,
	_Inout_ PCONTEXT ThreadContext
	);

NTSYSCALLAPI
ULONG
NTAPI
ZwGetCurrentProcessorNumber(
	);

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwGetDevicePowerState(
	_In_ HANDLE Device,
	_Out_ PDEVICE_POWER_STATE State
	);

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwGetEnvironmentVariableEx(
	_In_ PWSTR VariableName,
	_In_ LPGUID VendorGuid,
	_Out_ PVOID Value,
	_Inout_ PULONG ValueLength,
	_Out_opt_ PULONG Attributes
	);

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwGetMUIRegistryInfo(
	_In_ ULONG Flags,
	_Inout_ PULONG DataSize,
	_Out_ PVOID Data
	);

#if NTDDI_VERSION >= NTDDI_WIN10
NTSYSCALLAPI
NTSTATUS
NTAPI
ZwGetNextProcess(
	_In_ HANDLE ProcessHandle,
	_In_ ACCESS_MASK DesiredAccess,
	_In_ ULONG HandleAttributes,
	_In_ ULONG Flags,
	_Out_ PHANDLE NewProcessHandle
	);
#endif

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwGetNextThread(
	_In_ HANDLE ProcessHandle,
	_In_ HANDLE ThreadHandle,
	_In_ ACCESS_MASK DesiredAccess,
	_In_ ULONG HandleAttributes,
	_In_ ULONG Flags,
	_Out_ PHANDLE NewThreadHandle
	);

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwGetNlsSectionPtr(
	_In_ ULONG SectionType,
	_In_ ULONG SectionData,
	_In_ PVOID ContextData,
	_Out_ PVOID *SectionPointer,
	_Out_ PULONG SectionSize
	);

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwGetWriteWatch(
	_In_ HANDLE ProcessHandle,
	_In_ ULONG Flags,
	_In_ PVOID BaseAddress,
	_In_ SIZE_T RegionSize,
	_Out_ PVOID *UserAddressArray,
	_Inout_ PULONG_PTR EntriesInUserAddressArray,
	_Out_ PULONG Granularity
	);

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwImpersonateAnonymousToken(
	_In_ HANDLE ThreadHandle
	);

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwImpersonateThread(
	_In_ HANDLE ServerThreadHandle,
	_In_ HANDLE ClientThreadHandle,
	_In_ PSECURITY_QUALITY_OF_SERVICE SecurityQos
	);

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwInitializeNlsFiles(
	_Out_ PVOID *BaseAddress,
	_Out_ PLCID DefaultLocaleId,
	_Out_ PLARGE_INTEGER DefaultCasingTableSize
	);

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwInitializeRegistry(
	_In_ USHORT BootCondition
	);

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwInitiatePowerAction(
	_In_ POWER_ACTION SystemAction,
	_In_ SYSTEM_POWER_STATE LightestSystemState,
	_In_ ULONG Flags, // POWER_ACTION_* flags
	_In_ BOOLEAN Asynchronous
	);

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwIsProcessInJob(
	_In_ HANDLE ProcessHandle,
	_In_opt_ HANDLE JobHandle
	);

NTSYSCALLAPI
BOOLEAN
NTAPI
ZwIsSystemResumeAutomatic(
	);

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwIsUILanguageComitted(
	);

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwLoadKey(
	_In_ POBJECT_ATTRIBUTES TargetKey,
	_In_ POBJECT_ATTRIBUTES SourceFile
	);

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwLoadKey2(
	_In_ POBJECT_ATTRIBUTES TargetKey,
	_In_ POBJECT_ATTRIBUTES SourceFile,
	_In_ ULONG Flags
	);

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwLoadKeyEx(
	_In_ POBJECT_ATTRIBUTES TargetKey,
	_In_ POBJECT_ATTRIBUTES SourceFile,
	_In_ ULONG Flags,
	_In_opt_ HANDLE TrustClassKey,
	_In_opt_ HANDLE Event,
	_In_opt_ ACCESS_MASK DesiredAccess,
	_Out_opt_ PHANDLE RootHandle,
	_Out_opt_ PIO_STATUS_BLOCK IoStatus
	);

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwLockProductActivationKeys(
	_Inout_opt_ ULONG *pPrivateVer,
	_Out_opt_ ULONG *pSafeMode
	);

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwLockRegistryKey(
	_In_ HANDLE KeyHandle
	);

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwLockVirtualMemory(
	_In_ HANDLE ProcessHandle,
	_Inout_ PVOID *BaseAddress,
	_Inout_ PSIZE_T RegionSize,
	_In_ ULONG MapType
	);

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwMapCMFModule(
	_In_ ULONG What,
	_In_ ULONG Index,
	_Out_opt_ PULONG CacheIndexOut,
	_Out_opt_ PULONG CacheFlagsOut,
	_Out_opt_ PULONG ViewSizeOut,
	_Out_opt_ PVOID *BaseAddress
	);

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwMapUserPhysicalPages(
	_In_ PVOID VirtualAddress,
	_In_ ULONG_PTR NumberOfPages,
	_In_ PULONG_PTR UserPfnArray
	);

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwMapUserPhysicalPagesScatter(
	_In_ PVOID *VirtualAddresses,
	_In_ ULONG_PTR NumberOfPages,
	_In_ PULONG_PTR UserPfnArray
	);

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwNotifyChangeMultipleKeys(
	_In_ HANDLE MasterKeyHandle,
	_In_opt_ ULONG Count,
	_In_ OBJECT_ATTRIBUTES SubordinateObjects[],
	_In_opt_ HANDLE Event,
	_In_opt_ PIO_APC_ROUTINE ApcRoutine,
	_In_opt_ PVOID ApcContext,
	_Out_ PIO_STATUS_BLOCK IoStatusBlock,
	_In_ ULONG CompletionFilter,
	_In_ BOOLEAN WatchTree,
	_Out_ PVOID Buffer,
	_In_ ULONG BufferSize,
	_In_ BOOLEAN Asynchronous
	);

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwOpenEventPair(
	_Out_ PHANDLE EventPairHandle,
	_In_ ACCESS_MASK DesiredAccess,
	_In_ POBJECT_ATTRIBUTES ObjectAttributes
	);

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwOpenIoCompletion(
	_Out_ PHANDLE IoCompletionHandle,
	_In_ ACCESS_MASK DesiredAccess,
	_In_ POBJECT_ATTRIBUTES ObjectAttributes
	);

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwOpenJobObject(
	_Out_ PHANDLE JobHandle,
	_In_ ACCESS_MASK DesiredAccess,
	_In_ POBJECT_ATTRIBUTES ObjectAttributes
	);

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwOpenKeyedEvent(
	_Out_ PHANDLE KeyedEventHandle,
	_In_ ACCESS_MASK DesiredAccess,
	_In_ POBJECT_ATTRIBUTES ObjectAttributes
	);

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwOpenMutant(
	_Out_ PHANDLE MutantHandle,
	_In_ ACCESS_MASK DesiredAccess,
	_In_ POBJECT_ATTRIBUTES ObjectAttributes
	);

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwOpenObjectAuditAlarm(
	_In_ PUNICODE_STRING SubsystemName,
	_In_opt_ PVOID HandleId,
	_In_ PUNICODE_STRING ObjectTypeName,
	_In_ PUNICODE_STRING ObjectName,
	_In_opt_ PSECURITY_DESCRIPTOR SecurityDescriptor,
	_In_ HANDLE ClientToken,
	_In_ ACCESS_MASK DesiredAccess,
	_In_ ACCESS_MASK GrantedAccess,
	_In_opt_ PPRIVILEGE_SET Privileges,
	_In_ BOOLEAN ObjectCreation,
	_In_ BOOLEAN AccessGranted,
	_Out_ PBOOLEAN GenerateOnClose
	);

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwOpenPartition(
	_Out_ PHANDLE PartitionHandle,
	_In_ ACCESS_MASK DesiredAccess,
	_In_ POBJECT_ATTRIBUTES ObjectAttributes
	);

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwOpenPrivateNamespace(
	_Out_ PHANDLE NamespaceHandle,
	_In_ ACCESS_MASK DesiredAccess,
	_In_opt_ POBJECT_ATTRIBUTES ObjectAttributes,
	_In_ PVOID BoundaryDescriptor
	);

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwOpenProcessToken(
	_In_ HANDLE ProcessHandle,
	_In_ ACCESS_MASK DesiredAccess,
	_Out_ PHANDLE TokenHandle
	);

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwOpenSemaphore(
	_Out_ PHANDLE SemaphoreHandle,
	_In_ ACCESS_MASK DesiredAccess,
	_In_ POBJECT_ATTRIBUTES ObjectAttributes
	);

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwOpenSession(
	_Out_ PHANDLE SessionHandle,
	_In_ ACCESS_MASK DesiredAccess,
	_In_ POBJECT_ATTRIBUTES ObjectAttributes
	);

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwOpenThread(
	_Out_ PHANDLE ThreadHandle,
	_In_ ACCESS_MASK DesiredAccess,
	_In_ POBJECT_ATTRIBUTES ObjectAttributes,
	_In_opt_ PCLIENT_ID ClientId
	);

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwOpenThreadToken(
	_In_ HANDLE ThreadHandle,
	_In_ ACCESS_MASK DesiredAccess,
	_In_ BOOLEAN OpenAsSelf,
	_Out_ PHANDLE TokenHandle
	);

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwPrivilegeCheck(
	_In_ HANDLE ClientToken,
	_Inout_ PPRIVILEGE_SET RequiredPrivileges,
	_Out_ PBOOLEAN Result
	);

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwPrivilegeObjectAuditAlarm(
	_In_ PUNICODE_STRING SubsystemName,
	_In_opt_ PVOID HandleId,
	_In_ HANDLE ClientToken,
	_In_ ACCESS_MASK DesiredAccess,
	_In_ PPRIVILEGE_SET Privileges,
	_In_ BOOLEAN AccessGranted
	);

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwPrivilegedServiceAuditAlarm(
	_In_ PUNICODE_STRING SubsystemName,
	_In_ PUNICODE_STRING ServiceName,
	_In_ HANDLE ClientToken,
	_In_ PPRIVILEGE_SET Privileges,
	_In_ BOOLEAN AccessGranted
	);

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwPropagationComplete(
	_In_ HANDLE ResourceManagerHandle,
	_In_ ULONG RequestCookie,
	_In_ ULONG BufferLength,
	_In_ PVOID Buffer
	);

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwPropagationFailed(
	_In_ HANDLE ResourceManagerHandle,
	_In_ ULONG RequestCookie,
	_In_ NTSTATUS PropStatus
	);

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwPulseEvent(
	_In_ HANDLE EventHandle,
	_Out_opt_ PLONG PreviousState
	);

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwQueryAttributesFile(
	_In_ POBJECT_ATTRIBUTES ObjectAttributes,
	_Out_ PFILE_BASIC_INFORMATION FileInformation
	);

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwQueryBootEntryOrder(
	_Out_ PULONG Ids,
	_Inout_ PULONG Count
	);

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwQueryDebugFilterState(
	_In_ ULONG ComponentId,
	_In_ ULONG Level
	);

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwQueryDefaultLocale(
	_In_ BOOLEAN UserProfile,
	_Out_ PLCID DefaultLocaleId
	);

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwQueryDefaultUILanguage(
	_Out_ LANGID *DefaultUILanguageId
	);

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwQueryDirectoryObject(
	_In_ HANDLE DirectoryHandle,
	_Out_ PVOID Buffer,
	_In_ ULONG Length,
	_In_ BOOLEAN ReturnSingleEntry,
	_In_ BOOLEAN RestartScan,
	_Inout_ PULONG Context,
	_Out_opt_ PULONG ReturnLength
	);

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwQueryDriverEntryOrder(
	_Out_ PULONG Ids,
	_Inout_ PULONG Count
	);

NTSYSCALLAPI
NTSTATUS
NTAPI
NtQueryInformationProcess(
	_In_ HANDLE ProcessHandle,
	_In_ PROCESSINFOCLASS ProcessInformationClass,
	_Out_ PVOID ProcessInformation,
	_In_ ULONG ProcessInformationLength,
	_Out_opt_ PULONG ReturnLength
	);

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwQueryInformationProcess(
	_In_ HANDLE ProcessHandle,
	_In_ PROCESSINFOCLASS ProcessInformationClass,
	_Out_ PVOID ProcessInformation,
	_In_ ULONG ProcessInformationLength,
	_Out_opt_ PULONG ReturnLength
	);

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwQueryInformationThread(
	_In_ HANDLE ThreadHandle,
	_In_ THREADINFOCLASS ThreadInformationClass,
	_Out_ PVOID ThreadInformation,
	_In_ ULONG ThreadInformationLength,
	_Out_opt_ PULONG ReturnLength
	);

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwQueryInstallUILanguage(
	_Out_ LANGID *InstallUILanguageId
	);

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwQueryIntervalProfile(
	_In_ KPROFILE_SOURCE ProfileSource,
	_Out_ PULONG Interval
	);

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwQueryIoCompletion(
	_In_ HANDLE IoCompletionHandle,
	_In_ IO_COMPLETION_INFORMATION_CLASS IoCompletionInformationClass,
	_Out_ PVOID IoCompletionInformation,
	_In_ ULONG IoCompletionInformationLength,
	_Out_opt_ PULONG ReturnLength
	);

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwQueryLicenseValue(
	_In_ PUNICODE_STRING ValueName,
	_Out_opt_ PULONG Type,
	_Out_ PVOID Data,
	_In_ ULONG DataSize,
	_Out_ PULONG ResultDataSize
	);

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwQueryMultipleValueKey(
	_In_ HANDLE KeyHandle,
	_Inout_opt_ PKEY_VALUE_ENTRY ValueEntries,
	_In_ ULONG EntryCount,
	_Out_ PVOID ValueBuffer,
	_Inout_ PULONG BufferLength,
	_Out_opt_ PULONG RequiredBufferLength
	);

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwQueryOpenSubKeys(
	_In_ POBJECT_ATTRIBUTES TargetKey,
	_Out_ PULONG HandleCount
	);

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwQueryOpenSubKeysEx(
	_In_ POBJECT_ATTRIBUTES TargetKey,
	_In_ ULONG BufferLength,
	_Out_ PVOID Buffer,
	_Out_ PULONG RequiredSize
	);

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwQueryPerformanceCounter(
	_Out_ PLARGE_INTEGER PerformanceCounter,
	_Out_opt_ PLARGE_INTEGER PerformanceFrequency
	);

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwQueryPortInformationProcess(
	);

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwQuerySection(
	_In_ HANDLE SectionHandle,
	_In_ SECTION_INFORMATION_CLASS SectionInformationClass,
	_Out_ PVOID SectionInformation,
	_In_ SIZE_T SectionInformationLength,
	_Out_opt_ PSIZE_T ReturnLength
	);

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwQuerySecurityAttributesToken(
	_In_ HANDLE TokenHandle,
	_In_ PUNICODE_STRING Attributes,
	_In_ ULONG NumberOfAttributes,
	_Out_ PVOID Buffer, // PTOKEN_SECURITY_ATTRIBUTES_INFORMATION
	_In_ ULONG Length,
	_Out_ PULONG ReturnLength
	);

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwQuerySystemEnvironmentValue(
	_In_ PUNICODE_STRING VariableName,
	_Out_ PWSTR VariableValue,
	_In_ USHORT ValueLength,
	_Out_opt_ PUSHORT ReturnLength
	);

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwQuerySystemEnvironmentValueEx(
	_In_ PUNICODE_STRING VariableName,
	_In_ LPGUID VendorGuid,
	_Out_opt_ PVOID Value,
	_Inout_ PULONG ValueLength,
	_Out_opt_ PULONG Attributes
	);

NTSYSCALLAPI
NTSTATUS
NTAPI
NtQuerySystemInformation(
	_In_ SYSTEM_INFORMATION_CLASS SystemInformationClass,
	_Out_opt_ PVOID SystemInformation,
	_In_ ULONG SystemInformationLength,
	_Out_opt_ PULONG ReturnLength
	);

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwQuerySystemInformation(
	_In_ SYSTEM_INFORMATION_CLASS SystemInformationClass,
	_Out_opt_ PVOID SystemInformation,
	_In_ ULONG SystemInformationLength,
	_Out_opt_ PULONG ReturnLength
	);

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwQuerySystemTime(
	_Out_ PLARGE_INTEGER SystemTime
	);

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwQueryTimerResolution(
	_Out_ PULONG MaximumTime,
	_Out_ PULONG MinimumTime,
	_Out_ PULONG CurrentTime
	);

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwQueryWnfStateNameInformation(
	_In_ PCWNF_STATE_NAME StateName,
	_In_ WNF_STATE_NAME_INFORMATION NameInfoClass,
	_In_opt_ const VOID *ExplicitScope,
	_Out_ PVOID InfoBuffer,
	_In_ ULONG InfoBufferSize
	);

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwQueueApcThread(
	_In_ HANDLE ThreadHandle,
	_In_ PPS_APC_ROUTINE ApcRoutine,
	_In_opt_ PVOID ApcArgument1,
	_In_opt_ PVOID ApcArgument2,
	_In_opt_ PVOID ApcArgument3
	);

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwQueueApcThreadEx(
	_In_ HANDLE ThreadHandle,
	_In_opt_ HANDLE UserApcReserveHandle,
	_In_ PPS_APC_ROUTINE ApcRoutine,
	_In_opt_ PVOID ApcArgument1,
	_In_opt_ PVOID ApcArgument2,
	_In_opt_ PVOID ApcArgument3
	);

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwRaiseException(
	_In_ PEXCEPTION_RECORD ExceptionRecord,
	_In_ PCONTEXT ContextRecord,
	_In_ BOOLEAN FirstChance
	);

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwRaiseHardError(
	_In_ NTSTATUS ErrorStatus,
	_In_ ULONG NumberOfParameters,
	_In_ ULONG UnicodeStringParameterMask,
	_In_ PULONG_PTR Parameters,
	_In_ ULONG ValidResponseOptions,
	_Out_ PULONG Response
	);

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwReadFileScatter(
	_In_ HANDLE FileHandle,
	_In_opt_ HANDLE Event,
	_In_opt_ PIO_APC_ROUTINE ApcRoutine,
	_In_opt_ PVOID ApcContext,
	_Out_ PIO_STATUS_BLOCK IoStatusBlock,
	_In_ PFILE_SEGMENT_ELEMENT SegmentArray,
	_In_ ULONG Length,
	_In_opt_ PLARGE_INTEGER ByteOffset,
	_In_opt_ PULONG Key
	);

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwRegisterThreadTerminatePort(
	_In_ HANDLE PortHandle
	);

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwReleaseCMFViewOwnership(
	);

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwReleaseKeyedEvent(
	_In_ HANDLE KeyedEventHandle,
	_In_ PVOID KeyValue,
	_In_ BOOLEAN Alertable,
	_In_opt_ PLARGE_INTEGER Timeout
	);

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwReleaseMutant(
	_In_ HANDLE MutantHandle,
	_Out_opt_ PLONG PreviousCount
	);

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwReleaseSemaphore(
	_In_ HANDLE SemaphoreHandle,
	_In_ LONG ReleaseCount,
	_Out_opt_ PLONG PreviousCount
	);

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwReleaseWorkerFactoryWorker(
	_In_ HANDLE WorkerFactoryHandle
	);

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwRemoveIoCompletion(
	_In_ HANDLE IoCompletionHandle,
	_Out_ PVOID *KeyContext,
	_Out_ PVOID *ApcContext,
	_Out_ PIO_STATUS_BLOCK IoStatusBlock,
	_In_opt_ PLARGE_INTEGER Timeout
	);

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwRemoveIoCompletionEx(
	_In_ HANDLE IoCompletionHandle,
	PFILE_IO_COMPLETION_INFORMATION IoCompletionInformation,
	_In_ ULONG Count,
	_Out_ PULONG NumEntriesRemoved,
	_In_opt_ PLARGE_INTEGER Timeout,
	_In_ BOOLEAN Alertable
	);

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwRemoveProcessDebug(
	_In_ HANDLE ProcessHandle,
	_In_ HANDLE DebugObjectHandle
	);

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwRenameTransactionManager(
	_In_ PUNICODE_STRING LogFileName,
	_In_ LPGUID ExistingTransactionManagerGuid
	);

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwReplaceKey(
	_In_ POBJECT_ATTRIBUTES NewFile,
	_In_ HANDLE TargetHandle,
	_In_ POBJECT_ATTRIBUTES OldFile
	);

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwReplacePartitionUnit(
	_In_ PUNICODE_STRING TargetInstancePath,
	_In_ PUNICODE_STRING SpareInstancePath,
	_In_ ULONG Flags
	);

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwRequestDeviceWakeup(
	_In_ HANDLE Device
	);

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwRequestWakeupLatency(
	_In_ LATENCY_TIME latency
	);

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwResetEvent(
	_In_ HANDLE EventHandle,
	_Out_opt_ PLONG PreviousState
	);

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwResetWriteWatch(
	_In_ HANDLE ProcessHandle,
	_In_ PVOID BaseAddress,
	_In_ SIZE_T RegionSize
	);

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwResumeProcess(
	_In_ HANDLE ProcessHandle
	);

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwRevertContainerImpersonation(
	);

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwSaveMergedKeys(
	_In_ HANDLE HighPrecedenceKeyHandle,
	_In_ HANDLE LowPrecedenceKeyHandle,
	_In_ HANDLE FileHandle
	);

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwSerializeBoot(
	);

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwSetBootEntryOrder(
	_In_ PULONG Ids,
	_In_ ULONG Count
	);

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwSetCachedSigningLevel(
	_In_ ULONG Flags,
	_In_ SE_SIGNING_LEVEL InputSigningLevel,
	_In_ PHANDLE SourceFiles,
	_In_ ULONG SourceFileCount,
	_In_opt_ HANDLE TargetFile
	);

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwSetContextThread(
	_In_ HANDLE ThreadHandle,
	_In_ PCONTEXT ThreadContext
	);

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwSetDebugFilterState(
	_In_ ULONG ComponentId,
	_In_ ULONG Level,
	_In_ BOOLEAN State
	);

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwSetDefaultLocale(
	_In_ BOOLEAN UserProfile,
	_In_ LCID DefaultLocaleId
	);

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwSetDefaultUILanguage(
	_In_ LANGID DefaultUILanguageId
	);

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwSetDriverEntryOrder(
	_In_ PULONG Ids,
	_In_ ULONG Count
	);

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwSetEventBoostPriority(
	_In_ HANDLE EventHandle
	);

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwSetHighEventPair(
	_In_ HANDLE EventPairHandle
	);

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwSetHighWaitLowEventPair(
	_In_ HANDLE EventPairHandle
	);

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwSetIRTimer(
	_In_ HANDLE TimerHandle,
	_In_opt_ PLARGE_INTEGER DueTime
	);

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwSetInformationDebugObject(
	_In_ HANDLE DebugObjectHandle,
	_In_ DEBUGOBJECTINFOCLASS DebugObjectInformationClass,
	_In_ PVOID DebugInformation,
	_In_ ULONG DebugInformationLength,
	_Out_opt_ PULONG ReturnLength
	);

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwSetInformationObject(
	_In_ HANDLE Handle,
	_In_ OBJECT_INFORMATION_CLASS ObjectInformationClass,
	_In_ PVOID ObjectInformation,
	_In_ ULONG ObjectInformationLength
	);

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwSetInformationProcess(
	_In_ HANDLE ProcessHandle,
	_In_ PROCESSINFOCLASS ProcessInformationClass,
	_In_ PVOID ProcessInformation,
	_In_ ULONG ProcessInformationLength
	);

_IRQL_requires_max_(PASSIVE_LEVEL)
_Must_inspect_result_ 
NTSYSCALLAPI
NTSTATUS
NTAPI
ZwSetInformationVirtualMemory(
	_In_ HANDLE ProcessHandle,
	_In_ VIRTUAL_MEMORY_INFORMATION_CLASS VmInformationClass,
	_In_ ULONG_PTR NumberOfEntries,
	_In_reads_(NumberOfEntries) PMEMORY_RANGE_ENTRY VirtualAddresses,
	_In_reads_bytes_(VmInformationLength) PVOID VmInformation,
	_In_ ULONG VmInformationLength
	);

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwSetIntervalProfile(
	_In_ ULONG Interval,
	_In_ KPROFILE_SOURCE Source
	);

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwSetIoCompletion(
	_In_ HANDLE IoCompletionHandle,
	_In_opt_ PVOID KeyContext,
	_In_opt_ PVOID ApcContext,
	_In_ NTSTATUS IoStatus,
	_In_ ULONG_PTR IoStatusInformation
	);

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwSetIoCompletionEx(
	_In_ HANDLE IoCompletionHandle,
	_In_ HANDLE IoCompletionPacketHandle,
	_In_opt_ PVOID KeyContext,
	_In_opt_ PVOID ApcContext,
	_In_ NTSTATUS IoStatus,
	_In_ ULONG_PTR IoStatusInformation
	);

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwSetLdtEntries(
	_In_ ULONG Selector0,
	_In_ ULONG Entry0Low,
	_In_ ULONG Entry0Hi,
	_In_ ULONG Selector1,
	_In_ ULONG Entry1Low,
	_In_ ULONG Entry1Hi
	);

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwSetLowEventPair(
	_In_ HANDLE EventPairHandle
	);

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwSetLowWaitHighEventPair(
	_In_ HANDLE EventPairHandle
	);

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwSetSystemEnvironmentValue(
	_In_ PUNICODE_STRING VariableName,
	_In_ PUNICODE_STRING VariableValue
	);

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwSetSystemEnvironmentValueEx(
	_In_ PUNICODE_STRING VariableName,
	_In_ LPGUID VendorGuid,
	_In_ PVOID Value,
	_In_ ULONG ValueLength,
	_In_ ULONG Attributes
	);

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwSetSystemInformation(
	_In_ SYSTEM_INFORMATION_CLASS SystemInformationClass,
	_In_ PVOID SystemInformation,
	_In_ ULONG SystemInformationLength
	);

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwSetSystemPowerState(
	_In_ POWER_ACTION SystemAction,
	_In_ SYSTEM_POWER_STATE LightestSystemState,
	_In_ ULONG Flags // POWER_ACTION_* flags
	);

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwSetSystemTime(
	_In_opt_ PLARGE_INTEGER SystemTime,
	_Out_opt_ PLARGE_INTEGER PreviousTime
	);

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwSetThreadExecutionState(
	_In_ EXECUTION_STATE NewFlags, // ES_* flags
	_Out_ EXECUTION_STATE *PreviousFlags
	);

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwSetTimerResolution(
	_In_ ULONG DesiredTime,
	_In_ BOOLEAN SetResolution,
	_Out_ PULONG ActualTime
	);

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwSetUuidSeed(
	_In_ PCHAR Seed
	);

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwSetWnfProcessNotificationEvent(
	_In_ HANDLE NotificationEvent
	);

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwShutdownWorkerFactory(
	_In_ HANDLE WorkerFactoryHandle,
	_Inout_ volatile LONG *PendingWorkerCount
	);

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwSignalAndWaitForSingleObject(
	_In_ HANDLE SignalHandle,
	_In_ HANDLE WaitHandle,
	_In_ BOOLEAN Alertable,
	_In_opt_ PLARGE_INTEGER Timeout
	);

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwStartProfile(
	_In_ HANDLE ProfileHandle
	);

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwStopProfile(
	_In_ HANDLE ProfileHandle
	);

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwSuspendProcess(
	_In_ HANDLE ProcessHandle
	);

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwSystemDebugControl(
	_In_ SYSDBG_COMMAND Command,
	_Inout_opt_ PVOID InputBuffer,
	_In_ ULONG InputBufferLength,
	_Out_opt_ PVOID OutputBuffer,
	_In_ ULONG OutputBufferLength,
	_Out_opt_ PULONG ReturnLength
	);

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwTerminateJobObject(
	_In_ HANDLE JobHandle,
	_In_ NTSTATUS ExitStatus
	);

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwTerminateThread(
	_In_opt_ HANDLE ThreadHandle,
	_In_ NTSTATUS ExitStatus
	);

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwTestAlert(
	);

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwThawRegistry(
	);

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwTraceEvent(
	_In_ HANDLE TraceHandle,
	_In_ ULONG Flags,
	_In_ ULONG FieldSize,
	_In_ PVOID Fields
	);

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwTranslateFilePath(
	_In_ PFILE_PATH InputFilePath,
	_In_ ULONG OutputType,
	_Out_opt_ PFILE_PATH OutputFilePath,
	_Inout_opt_ PULONG OutputFilePathLength
	);

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwUmsThreadYield(
	_In_ PVOID SchedulerParam
	);

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwUnloadKey(
	_In_ POBJECT_ATTRIBUTES TargetKey
	);

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwUnloadKey2(
	_In_ POBJECT_ATTRIBUTES TargetKey,
	_In_ ULONG Flags
	);

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwUnloadKeyEx(
	_In_ POBJECT_ATTRIBUTES TargetKey,
	_In_opt_ HANDLE Event
	);

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwUnlockVirtualMemory(
	_In_ HANDLE ProcessHandle,
	_Inout_ PVOID *BaseAddress,
	_Inout_ PSIZE_T RegionSize,
	_In_ ULONG MapType
	);

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwUnmapViewOfSectionEx(
	_In_ HANDLE ProcessHandle,
	_In_opt_ PVOID BaseAddress,
	_In_ ULONG Flags
	);

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwUnsubscribeWnfStateChange(
	_In_ PCWNF_STATE_NAME StateName
	);

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwWaitForAlertByThreadId(
	_In_ PVOID Address,
	_In_opt_ PLARGE_INTEGER Timeout
	);

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwWaitForDebugEvent(
	_In_ HANDLE DebugObjectHandle,
	_In_ BOOLEAN Alertable,
	_In_opt_ PLARGE_INTEGER Timeout,
	_Out_ PVOID WaitStateChange
	);

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwWaitForKeyedEvent(
	_In_ HANDLE KeyedEventHandle,
	_In_ PVOID KeyValue,
	_In_ BOOLEAN Alertable,
	_In_opt_ PLARGE_INTEGER Timeout
	);

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwWaitForMultipleObjects(
	_In_ ULONG Count,
	_In_ HANDLE Handles[],
	_In_ WAIT_TYPE WaitType,
	_In_ BOOLEAN Alertable,
	_In_opt_ PLARGE_INTEGER Timeout
	);

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwWaitForMultipleObjects32(
	_In_ ULONG Count,
	_In_ LONG Handles[],
	_In_ WAIT_TYPE WaitType,
	_In_ BOOLEAN Alertable,
	_In_opt_ PLARGE_INTEGER Timeout
	);

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwWaitForWorkViaWorkerFactory(
	_In_ HANDLE WorkerFactoryHandle,
	_Out_ struct _FILE_IO_COMPLETION_INFORMATION *MiniPacket,
	_In_ ULONG NumberOfMiniPackets,
	_Out_ PULONG NumberOfMiniPacketsReturned,
	_In_opt_ PHANDLE Handles,
	_In_ PULONG Flags
	);

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwWaitHighEventPair(
	_In_ HANDLE EventPairHandle
	);

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwWaitLowEventPair(
	_In_ HANDLE EventPairHandle
	);

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwWorkerFactoryWorkerReady(
	_In_ HANDLE WorkerFactoryHandle
	);

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwWriteFileGather(
	_In_ HANDLE FileHandle,
	_In_opt_ HANDLE Event,
	_In_opt_ PIO_APC_ROUTINE ApcRoutine,
	_In_opt_ PVOID ApcContext,
	_Out_ PIO_STATUS_BLOCK IoStatusBlock,
	_In_ PFILE_SEGMENT_ELEMENT SegmentArray,
	_In_ ULONG Length,
	_In_opt_ PLARGE_INTEGER ByteOffset,
	_In_opt_ PULONG Key
	);

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwWriteVirtualMemory(
	_In_ HANDLE ProcessHandle,
	_In_opt_ PVOID BaseAddress,
	_In_ PVOID Buffer,
	_In_ SIZE_T BufferSize,
	_Out_opt_ PSIZE_T NumberOfBytesWritten
	);

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwYieldExecution(
	);

// DBGK

typedef enum _DBG_STATE
{
	DbgIdle,
	DbgReplyPending,
	DbgCreateThreadStateChange,
	DbgCreateProcessStateChange,
	DbgExitThreadStateChange,
	DbgExitProcessStateChange,
	DbgExceptionStateChange,
	DbgBreakpointStateChange,
	DbgSingleStepStateChange,
	DbgLoadDllStateChange,
	DbgUnloadDllStateChange
} DBG_STATE, *PDBG_STATE;

typedef struct _DBGKM_EXCEPTION
{
	EXCEPTION_RECORD ExceptionRecord;
	ULONG FirstChance;
} DBGKM_EXCEPTION, *PDBGKM_EXCEPTION;

typedef struct _DBGKM_CREATE_THREAD
{
	ULONG SubSystemKey;
	PVOID StartAddress;
} DBGKM_CREATE_THREAD, *PDBGKM_CREATE_THREAD;

typedef struct _DBGKM_CREATE_PROCESS
{
	ULONG SubSystemKey;
	HANDLE FileHandle;
	PVOID BaseOfImage;
	ULONG DebugInfoFileOffset;
	ULONG DebugInfoSize;
	DBGKM_CREATE_THREAD InitialThread;
} DBGKM_CREATE_PROCESS, *PDBGKM_CREATE_PROCESS;

typedef struct _DBGKM_EXIT_THREAD
{
	NTSTATUS ExitStatus;
} DBGKM_EXIT_THREAD, *PDBGKM_EXIT_THREAD;

typedef struct _DBGKM_EXIT_PROCESS
{
	NTSTATUS ExitStatus;
} DBGKM_EXIT_PROCESS, *PDBGKM_EXIT_PROCESS;

typedef struct _DBGKM_LOAD_DLL
{
	HANDLE FileHandle;
	PVOID BaseOfDll;
	ULONG DebugInfoFileOffset;
	ULONG DebugInfoSize;
	PVOID NamePointer;
} DBGKM_LOAD_DLL, *PDBGKM_LOAD_DLL;

typedef struct _DBGKM_UNLOAD_DLL
{
	PVOID BaseAddress;
} DBGKM_UNLOAD_DLL, *PDBGKM_UNLOAD_DLL;

typedef struct _DBGUI_CREATE_THREAD
{
	HANDLE HandleToThread;
	DBGKM_CREATE_THREAD NewThread;
} DBGUI_CREATE_THREAD, *PDBGUI_CREATE_THREAD;

typedef struct _DBGUI_CREATE_PROCESS
{
	HANDLE HandleToProcess;
	HANDLE HandleToThread;
	DBGKM_CREATE_PROCESS NewProcess;
} DBGUI_CREATE_PROCESS, *PDBGUI_CREATE_PROCESS;

typedef struct _DBGUI_WAIT_STATE_CHANGE
{
	DBG_STATE NewState;
	CLIENT_ID AppClientId;
	union
	{
		DBGKM_EXCEPTION Exception;
		DBGUI_CREATE_THREAD CreateThread;
		DBGUI_CREATE_PROCESS CreateProcessInfo;
		DBGKM_EXIT_THREAD ExitThread;
		DBGKM_EXIT_PROCESS ExitProcess;
		DBGKM_LOAD_DLL LoadDll;
		DBGKM_UNLOAD_DLL UnloadDll;
	} StateInfo;
} DBGUI_WAIT_STATE_CHANGE, *PDBGUI_WAIT_STATE_CHANGE;


// EX

typedef struct _EX_PUSH_LOCK_WAIT_BLOCK *PEX_PUSH_LOCK_WAIT_BLOCK;

NTKERNELAPI
VOID
FASTCALL
ExfUnblockPushLock(
	_Inout_ PEX_PUSH_LOCK PushLock,
	_Inout_opt_ PEX_PUSH_LOCK_WAIT_BLOCK WaitBlock
	);

typedef struct _HANDLE_TABLE HANDLE_TABLE, *PHANDLE_TABLE;

typedef BOOLEAN(NTAPI *PEX_ENUM_HANDLE_CALLBACK)(
	_Inout_ PHANDLE_TABLE_ENTRY HandleTableEntry,
	_In_ HANDLE Handle,
	_In_ PVOID Context
	);

NTKERNELAPI
BOOLEAN
NTAPI
ExEnumHandleTable(
	_In_ PHANDLE_TABLE HandleTable,
	_In_ PEX_ENUM_HANDLE_CALLBACK EnumHandleProcedure,
	_Inout_ PVOID Context,
	_Out_opt_ PHANDLE Handle
	);

// This is from XP era times, don't use it
typedef struct _BOOT_ENTRY
{
	ULONG Version;
	ULONG Length;
	ULONG Id;
	ULONG Attributes;
	ULONG FriendlyNameOffset;
	ULONG BootFilePathOffset;
	ULONG OsOptionsLength;
	UCHAR OsOptions[ANYSIZE_ARRAY];
	//WCHAR FriendlyName[ANYSIZE_ARRAY];
	//FILE_PATH BootFilePath;
} BOOT_ENTRY, *PBOOT_ENTRY;

typedef struct _EFI_DRIVER_ENTRY
{
	ULONG Version;
	ULONG Length;
	ULONG Id;
	ULONG FriendlyNameOffset;
	ULONG DriverFilePathOffset;
	//WCHAR FriendlyName[ANYSIZE_ARRAY];
	//FILE_PATH DriverFilePath;
} EFI_DRIVER_ENTRY, *PEFI_DRIVER_ENTRY;

typedef struct _BOOT_OPTIONS
{
	ULONG Version;
	ULONG Length;
	ULONG Timeout;
	ULONG CurrentBootEntryId;
	ULONG NextBootEntryId;
	WCHAR HeadlessRedirection[ANYSIZE_ARRAY];
} BOOT_OPTIONS, *PBOOT_OPTIONS;

#define HARDERROR_OVERRIDE_ERRORMODE		0x10000000

typedef enum _HARDERROR_RESPONSE_OPTION
{
	OptionAbortRetryIgnore,
	OptionOk,
	OptionOkCancel,
	OptionRetryCancel,
	OptionYesNo,
	OptionYesNoCancel,
	OptionShutdownSystem,
	OptionOkNoWait,
	OptionCancelTryContinue
} HARDERROR_RESPONSE_OPTION, *PHARDERROR_RESPONSE_OPTION;

typedef enum _HARDERROR_RESPONSE
{
	ResponseReturnToCaller,
	ResponseNotHandled,
	ResponseAbort,
	ResponseCancel,
	ResponseIgnore,
	ResponseNo,
	ResponseOk,
	ResponseRetry,
	ResponseYes,
	ResponseTryAgain,
	ResponseContinue
} HARDERROR_RESPONSE, *PHARDERROR_RESPONSE;

// IO

extern POBJECT_TYPE *IoDriverObjectType;

typedef enum _WORKERFACTORYINFOCLASS
{
	WorkerFactoryTimeout,
	WorkerFactoryRetryTimeout,
	WorkerFactoryIdleTimeout,
	WorkerFactoryBindingCount,
	WorkerFactoryThreadMinimum,
	WorkerFactoryThreadMaximum,
	WorkerFactoryPaused,
	WorkerFactoryBasicInformation,
	WorkerFactoryAdjustThreadGoal,
	WorkerFactoryCallbackType,
	WorkerFactoryStackInformation, // 10
	WorkerFactoryThreadBasePriority,
	WorkerFactoryTimeoutWaiters, // since THRESHOLD
	WorkerFactoryFlags,
	WorkerFactoryThreadSoftMaximum,
	MaxWorkerFactoryInfoClass
} WORKERFACTORYINFOCLASS, *PWORKERFACTORYINFOCLASS;

// KE

typedef VOID(NTAPI *PKNORMAL_ROUTINE)(
	_In_ PVOID NormalContext,
	_In_ PVOID SystemArgument1,
	_In_ PVOID SystemArgument2
	);

typedef VOID KKERNEL_ROUTINE(
	_In_ PRKAPC Apc,
	_Inout_ PKNORMAL_ROUTINE *NormalRoutine,
	_Inout_ PVOID *NormalContext,
	_Inout_ PVOID *SystemArgument1,
	_Inout_ PVOID *SystemArgument2
);

typedef KKERNEL_ROUTINE(NTAPI *PKKERNEL_ROUTINE);

typedef VOID(NTAPI *PKRUNDOWN_ROUTINE)(
	_In_ PRKAPC Apc
	);

NTKERNELAPI
VOID
NTAPI
KeInitializeApc(
	_Out_ PRKAPC Apc,
	_In_ PRKTHREAD Thread,
	_In_ KAPC_ENVIRONMENT Environment,
	_In_ PKKERNEL_ROUTINE KernelRoutine,
	_In_opt_ PKRUNDOWN_ROUTINE RundownRoutine,
	_In_opt_ PKNORMAL_ROUTINE NormalRoutine,
	_In_opt_ KPROCESSOR_MODE ProcessorMode,
	_In_opt_ PVOID NormalContext
	);

NTKERNELAPI
BOOLEAN
NTAPI
KeInsertQueueApc(
	_Inout_ PRKAPC Apc,
	_In_opt_ PVOID SystemArgument1,
	_In_opt_ PVOID SystemArgument2,
	_In_ KPRIORITY Increment
	);

NTKERNELAPI
BOOLEAN
NTAPI
KeTestAlertThread(
	_In_ KPROCESSOR_MODE AlertMode
	);

// LDR

typedef struct _LDR_RESOURCE_INFO
{
	ULONG_PTR Type;
	ULONG_PTR Name;
	ULONG_PTR Language;
} LDR_RESOURCE_INFO, *PLDR_RESOURCE_INFO;

typedef NTSTATUS(NTAPI *PUSER_THREAD_START_ROUTINE)(
	_In_ PVOID Parameter
	);

// LPC/ALPC (enough to get the driver to compile, but if you actually want to use it use ntlpcapi.h from Process Hacker)

typedef struct _PORT_MESSAGE
{
	union
	{
		struct
		{
			SHORT DataLength;
			SHORT TotalLength;
		} s1;
		ULONG Length;
	} u1;
	union
	{
		struct
		{
			SHORT Type;
			SHORT DataInfoOffset;
		} s2;
		ULONG ZeroInit;
	} u2;
	union
	{
		CLIENT_ID ClientId;
		double DoNotUseThisField;
	};
	ULONG MessageId;
	union
	{
		SIZE_T ClientViewSize; // only valid for LPC_CONNECTION_REQUEST messages
		ULONG CallbackId; // only valid for LPC_REQUEST messages
	};
} PORT_MESSAGE, *PPORT_MESSAGE;

typedef struct _PORT_VIEW
{
	ULONG Length;
	HANDLE SectionHandle;
	ULONG SectionOffset;
	SIZE_T ViewSize;
	PVOID ViewBase;
	PVOID ViewRemoteBase;
} PORT_VIEW, *PPORT_VIEW;

typedef struct _REMOTE_PORT_VIEW
{
	ULONG Length;
	SIZE_T ViewSize;
	PVOID ViewBase;
} REMOTE_PORT_VIEW, *PREMOTE_PORT_VIEW;

typedef enum _ALPC_PORT_INFORMATION_CLASS
{
	AlpcBasicInformation, // q: out ALPC_BASIC_INFORMATION
	AlpcPortInformation, // s: in ALPC_PORT_ATTRIBUTES
	AlpcAssociateCompletionPortInformation, // s: in ALPC_PORT_ASSOCIATE_COMPLETION_PORT
	AlpcConnectedSIDInformation, // q: in SID
	AlpcServerInformation, // q: inout ALPC_SERVER_INFORMATION
	AlpcMessageZoneInformation, // s: in ALPC_PORT_MESSAGE_ZONE_INFORMATION // no-op since 8.1
	AlpcRegisterCompletionListInformation, // s: in ALPC_PORT_COMPLETION_LIST_INFORMATION
	AlpcUnregisterCompletionListInformation, // s: VOID
	AlpcAdjustCompletionListConcurrencyCountInformation, // s: in ULONG
	AlpcRegisterCallbackInformation, // kernel-mode only
	AlpcCompletionListRundownInformation, // s: VOID
	AlpcWaitForPortReferences
} ALPC_PORT_INFORMATION_CLASS;

typedef enum _ALPC_MESSAGE_INFORMATION_CLASS
{
	AlpcMessageSidInformation, // q: out SID
	AlpcMessageTokenModifiedIdInformation, // q: out LUID
	AlpcMessageDirectStatusInformation,
	AlpcMessageHandleInformation, // ALPC_MESSAGE_HANDLE_INFORMATION
	MaxAlpcMessageInfoClass
} ALPC_MESSAGE_INFORMATION_CLASS, *PALPC_MESSAGE_INFORMATION_CLASS;

typedef HANDLE ALPC_HANDLE, *PALPC_HANDLE;

// MM

NTKERNELAPI
NTSTATUS
NTAPI
MmCopyVirtualMemory(
	_In_ PEPROCESS FromProcess,
	_In_ CONST VOID *FromAddress,
	_In_ PEPROCESS ToProcess,
	_Out_ PVOID ToAddress,
	_In_ SIZE_T BufferSize,
	_In_ KPROCESSOR_MODE PreviousMode,
	_Out_ PSIZE_T NumberOfBytesCopied
	);

NTKERNELAPI
NTSTATUS
NTAPI
MmCreateSection(
	_Out_ PVOID *SectionObject,
	_In_ ACCESS_MASK DesiredAccess,
	_In_opt_ POBJECT_ATTRIBUTES ObjectAttributes,
	_In_ PLARGE_INTEGER InputMaximumSize,
	_In_ ULONG Win32SectionPageProtection,
	_In_ ULONG AllocationAttributes,
	_In_opt_ HANDLE FileHandle,
	_In_opt_ PFILE_OBJECT FileObject
	);

// OB

// These definitions are no longer correct, but they produce correct results.

#define OBJ_PROTECT_CLOSE 0x00000001
#define OBJ_HANDLE_ATTRIBUTES (OBJ_PROTECT_CLOSE | OBJ_INHERIT | OBJ_AUDIT_OBJECT_CLOSE)

// This attribute is now stored in the GrantedAccess field.
#define ObpAccessProtectCloseBit 0x2000000

#define ObpDecodeGrantedAccess(Access) \
	((Access) & ~ObpAccessProtectCloseBit)

typedef struct _OBJECT_CREATE_INFORMATION OBJECT_CREATE_INFORMATION, *POBJECT_CREATE_INFORMATION;

#define OBJECT_TO_OBJECT_HEADER(Object) CONTAINING_RECORD((Object), OBJECT_HEADER, Body)

NTKERNELAPI
POBJECT_TYPE
NTAPI
ObGetObjectType(
	_In_ PVOID Object
	);

NTKERNELAPI
NTSTATUS
NTAPI
ObOpenObjectByName(
	_In_ POBJECT_ATTRIBUTES ObjectAttributes,
	_In_ POBJECT_TYPE ObjectType,
	_In_ KPROCESSOR_MODE PreviousMode,
	_In_opt_ PACCESS_STATE AccessState,
	_In_opt_ ACCESS_MASK DesiredAccess,
	_In_ PVOID ParseContext,
	_Out_ PHANDLE Handle
	);

NTKERNELAPI
NTSTATUS
NTAPI
ObSetHandleAttributes(
	_In_ HANDLE Handle,
	_In_ POBJECT_HANDLE_FLAG_INFORMATION HandleFlags,
	_In_ KPROCESSOR_MODE PreviousMode
	);

NTKERNELAPI
NTSTATUS
ObCloseHandle(
	_In_ _Post_ptr_invalid_ HANDLE Handle,
	_In_ KPROCESSOR_MODE PreviousMode
	);

// PS

NTKERNELAPI
NTSTATUS
NTAPI
PsLookupProcessThreadByCid(
	_In_ PCLIENT_ID ClientId,
	_Out_opt_ PEPROCESS *Process,
	_Out_ PETHREAD *Thread
	);

NTKERNELAPI
NTSTATUS
PsGetContextThread(
	_In_ PETHREAD Thread,
	_Inout_ PCONTEXT ThreadContext,
	_In_ KPROCESSOR_MODE Mode
	);

NTKERNELAPI
NTSTATUS
PsSetContextThread(
	_In_ PETHREAD Thread,
	_In_ PCONTEXT ThreadContext,
	_In_ KPROCESSOR_MODE Mode
	);

NTKERNELAPI
PVOID
NTAPI
PsGetCurrentProcessWow64Process(
	);

NTKERNELAPI
PVOID
NTAPI
PsGetThreadWin32Thread(
	_In_ PETHREAD Thread
	);

NTKERNELAPI
NTSTATUS
PsResumeProcess(
	_In_ PEPROCESS Process
	);

NTKERNELAPI
NTSTATUS
PsSuspendProcess(
	_In_ PEPROCESS Process
	);

NTKERNELAPI
ULONG
PsGetProcessSessionId(
	_In_ PEPROCESS Process
	);

NTKERNELAPI
ULONG
PsGetProcessSessionIdEx(
	_In_ PEPROCESS Process
	);

_IRQL_requires_max_(DISPATCH_LEVEL)
NTKERNELAPI
HANDLE
PsGetProcessId(
	_In_ PEPROCESS Process
	);

NTKERNELAPI
PPEB
PsGetProcessPeb(
	_In_ PEPROCESS Process
	);

NTKERNELAPI
PVOID
PsGetProcessWow64Process(
	_In_ PEPROCESS Process
	);

NTKERNELAPI
PCHAR
PsGetProcessImageFileName(
	_In_ PEPROCESS Process
	);

_IRQL_requires_max_(DISPATCH_LEVEL)
NTKERNELAPI
HANDLE
PsGetThreadId(
	_In_ PETHREAD Thread
	);

NTKERNELAPI
PEPROCESS
PsGetThreadProcess(
	_In_ PETHREAD Thread
	);

NTKERNELAPI
PEPROCESS
PsGetCurrentThreadProcess(
	);

NTKERNELAPI
HANDLE
PsGetThreadProcessId(
	_In_ PETHREAD Thread
	);

NTKERNELAPI
HANDLE
PsGetCurrentThreadProcessId(
	);

NTKERNELAPI
PVOID
PsGetThreadTeb(
	_In_ PETHREAD Thread
	);

NTKERNELAPI
PVOID
PsGetCurrentThreadTeb(
	);

#if NTDDI_VERSION >= NTDDI_VISTA
NTKERNELAPI
BOOLEAN
PsIsProtectedProcess(
	_In_ PEPROCESS Process
	);
#endif

#if NTDDI_VERSION >= NTDDI_WINBLUE
NTKERNELAPI
BOOLEAN
PsIsProtectedProcessLight(
	_In_ PEPROCESS Process
	);
#endif

_Must_inspect_result_
_IRQL_requires_max_(APC_LEVEL)
NTKERNELAPI
NTSTATUS
PsLookupProcessByProcessId(
	_In_ HANDLE ProcessId,
	_Outptr_ PEPROCESS *Process
	);

NTKERNELAPI
HANDLE
PsGetProcessWin32WindowStation(
	_In_ PEPROCESS Process
	);

NTKERNELAPI
VOID
PsSetProcessWindowStation(
	_Out_ PEPROCESS Process,
	_In_ HANDLE Win32WindowStation
	);

typedef struct _EJOB *PEJOB;

extern POBJECT_TYPE *PsJobType;

NTKERNELAPI
PVOID
NTAPI
PsGetProcessDebugPort(
	_In_ PEPROCESS Process
	);

NTKERNELAPI
PEJOB
NTAPI
PsGetProcessJob(
	_In_ PEPROCESS Process
	);

NTKERNELAPI
NTSTATUS
NTAPI
PsAcquireProcessExitSynchronization(
	_In_ PEPROCESS Process
	);

NTKERNELAPI
VOID
NTAPI
PsReleaseProcessExitSynchronization(
	_In_ PEPROCESS Process
	);

// RTL

NTSYSAPI
VOID
NTAPI
RtlAvlRemoveNode(
	_Inout_ PMM_AVL_TABLE Table,
	_In_ PMMADDRESS_NODE Node
	);

#define UNW_FLAG_NHANDLER 0x0
#define UNW_FLAG_EHANDLER 0x1
#define UNW_FLAG_UHANDLER 0x2
#define UNW_FLAG_CHAININFO 0x4

NTSYSAPI
PEXCEPTION_ROUTINE
NTAPI
RtlVirtualUnwind(
	_In_ ULONG HandlerType,
	_In_ DWORD64 ImageBase,
	_In_ DWORD64 ControlPc,
	_In_ PRUNTIME_FUNCTION FunctionEntry,
	_Inout_ PCONTEXT ContextRecord,
	_Out_ PVOID *HandlerData,
	_Out_ PDWORD64 EstablisherFrame,
	_Inout_opt_ PKNONVOLATILE_CONTEXT_POINTERS ContextPointers
	);

NTSYSAPI
PIMAGE_NT_HEADERS
NTAPI
RtlImageNtHeader(
	_In_ PVOID ImageBase
	);

NTSYSAPI
PVOID
NTAPI
RtlImageDirectoryEntryToData(
	_In_ PVOID ImageBase,
	_In_ BOOLEAN MappedAsImage,
	_In_ USHORT DirectoryEntry,
	_Out_ PULONG Size
	);

NTSYSAPI
PRUNTIME_FUNCTION
NTAPI
RtlLookupFunctionEntry (
	_In_ DWORD64 ControlPc,
	_Out_ PDWORD64 ImageBase,
	_Inout_opt_ PUNWIND_HISTORY_TABLE HistoryTable
	);

// RtlWalkFrameChain (ntddk.h)
// Sensible limit that may or may not correspond to the actual Windows value.
#define RTL_WALK_MAX_STACK_DEPTH	128

// These are not bitmask flags - choose one
#define RTL_WALK_KERNEL_MODE_STACK		0x00000000
#define RTL_WALK_USER_MODE_STACK		0x00000001
#define RTL_WALK_TRACE_HANDLES			0x00000300

}

```

`README.md`:

```md
# MMInject

Kernel DLL Injector using NX Bit Swapping and VAD hide for hiding injected DLL

## Method

1) allocate pages with only read and write permission
2) get the physical page table entry's of your allocated pages
3) add execute permission to your page under the covers

## NOTE

Physical regions can be enumerated using NtQuery* APIs and then tested for the correctness of corresponding protection flags.

```