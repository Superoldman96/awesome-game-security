Project Path: arc_gmh5225_mandibule_zsg5h5ry

Source Tree:

```txt
arc_gmh5225_mandibule_zsg5h5ry
├── Makefile
├── code
│   ├── elfload.h
│   ├── fakestack.h
│   ├── ptinject.h
│   └── shargs.h
├── icrt
│   ├── icrt.h
│   ├── icrt_asm.h
│   ├── icrt_mem.h
│   ├── icrt_std.h
│   ├── icrt_syscall.h
│   └── icrt_utils.h
├── mandibule.c
├── readme.md
└── samples
    ├── target.c
    └── toinject.c

```

`Makefile`:

```
# ======================================================================== #
# author:  ixty                                                       2018 #
# project: mandibule                                                       #
# licence: beerware                                                        #
# ======================================================================== #

# mandibule makefile

CFLAGS 	+= -D_GNU_SOURCE -std=gnu99
CFLAGS 	+= -static-libgcc -lgcc
CFLAGS 	+= -I icrt/ -I code/
CFLAGS 	+= -fno-common -fno-stack-protector -fomit-frame-pointer -fno-exceptions -fno-asynchronous-unwind-tables -fno-unwind-tables
# CFLAGS  += -Wall -Werror -Wpedantic
PORTABLE = -pie -fPIE -fno-builtin
MACHINE  = $(shell uname -m)

# automaticaly target current arch
all: $(MACHINE)

# PC 32 bits
# add -m32 so we can compile it on amd64 as well
i386: x86
i486: x86
i686: x86
x86: clean
	$(CC) $(CFLAGS) $(PORTABLE) -nostdlib -m32 -o mandibule mandibule.c
	$(CC) $(CFLAGS) $(PORTABLE) -m32 -o toinject samples/toinject.c
	$(CC) $(CFLAGS) -m32 -o target samples/target.c

# PC 64 bits
amd64: x86_64
x86_64: clean
	$(CC) $(CFLAGS) $(PORTABLE) -nostdlib -o mandibule mandibule.c
	$(CC) $(CFLAGS) $(PORTABLE) -o toinject samples/toinject.c
	$(CC) $(CFLAGS) -o target samples/target.c


# ARM 32 bits
# unable to compile arm without nostdlib (uidiv divmod ...)
arm: armv7l
armhf: armv7l
armv7: armv7l
armv7l: clean
	$(CC) $(CFLAGS) $(PORTABLE) -nostartfiles -o mandibule mandibule.c
	$(CC) $(CFLAGS) $(PORTABLE) -o toinject samples/toinject.c
	$(CC) $(CFLAGS) -o target samples/target.c

# ARM 64 bits
arm64: aarch64
armv8: aarch64
armv8l: aarch64
aarch64: clean
	$(CC) $(CFLAGS) $(PORTABLE) -nostdlib -o mandibule mandibule.c
	$(CC) $(CFLAGS) $(PORTABLE) -o toinject samples/toinject.c
	$(CC) $(CFLAGS) -o target samples/target.c

clean:
	rm -rf mandibule target toinject


```

`code/elfload.h`:

```h
// ======================================================================== //
// author:  ixty                                                       2018 //
// project: mandibule                                                       //
// licence: beerware                                                        //
// ======================================================================== //

// code to manually map an executable ELF in local memory
// uses mmap & mprotect to map segments in memory
// this code does not process relocations
// this code loads the loader to handle dependencies

#ifndef _ELFLOAD_H
#define _ELFLOAD_H

#include <stdint.h>
#include <elf.h>
#include <sys/types.h>

#if defined(__i386__) || defined(__arm__)
    // 32 bits elf
    #define elf_ehdr Elf32_Ehdr
    #define elf_phdr Elf32_Phdr

#elif defined(__x86_64__) || defined(__aarch64__)
    // 64 bits elf
    #define elf_ehdr Elf64_Ehdr
    #define elf_phdr Elf64_Phdr
#endif

// some defines..
#define PAGE_SIZE           0x1000
#define MOD_OFFSET_NEXT    0x10000
#define MOD_OFFSET_BIN    0x100000

#define ALIGN_PAGE_UP(x)    do { if((x) % PAGE_SIZE) (x) += (PAGE_SIZE - ((x) % PAGE_SIZE)); } while(0)
#define ALIGN_PAGE_DOWN(x)  do { if((x) % PAGE_SIZE) (x) -= ((x) % PAGE_SIZE); } while(0)

// utility to set AUX values
static inline int set_auxv(unsigned long * auxv, unsigned long at_type, unsigned long at_val)
{
    int i = 0;
    while(auxv[i] && auxv[i] != at_type)
        i += 2;

    if(!auxv[i])
    {
        printf("> error setting auxv[%d] to 0x%llx\n", at_type, at_val);
        return -1;
    }

    auxv[i+1] = at_val;
    printf("> set auxv[%d] to 0x%llx\n", at_type, at_val);
    return 0;
}

// load a single segment in memory & set perms
static inline int load_segment(uint8_t * elf, elf_ehdr * ehdr, elf_phdr * phdr, unsigned long base_off)
{
    unsigned long seg_addr = phdr->p_vaddr + base_off;
    unsigned long seg_len  = phdr->p_memsz;
    unsigned long seg_off  = seg_addr & (PAGE_SIZE - 1);
    int prot = 0;
    long addr;

    // align segment
    ALIGN_PAGE_UP(seg_len);

    // get memory at fixed addr
    addr = (unsigned long)_mmap((void*)(seg_addr - seg_off), seg_len + seg_off, PROT_READ|PROT_WRITE, MAP_FIXED|MAP_PRIVATE|MAP_ANONYMOUS, -1, 0);

    // all good?
    printf("> load segment addr 0x%llx len 0x%llx => 0x%llx\n", seg_addr, seg_len, addr);
    if(addr != seg_addr - seg_off)
        return -1;

    // load up the segment with code/data
    memcpy((void*)seg_addr, elf + phdr->p_offset, phdr->p_filesz);

    // set correct permission
    if(phdr->p_flags & PF_R) prot |= PROT_READ;
    if(phdr->p_flags & PF_W) prot |= PROT_WRITE;
    if(phdr->p_flags & PF_X) prot |= PROT_EXEC;
    if(_mprotect((void*)(seg_addr - seg_off), seg_len + seg_off, prot) < 0)
        return -1;

    // all good
    return 0;
}

// load an elf in memory at specified base address
// will load and run interpreter if any
static inline int map_elf(char * path, unsigned long base_mod, unsigned long * auxv, unsigned long * out_eop)
{
    uint8_t *       elf_buf = NULL;
    size_t          elf_len = 0;
    unsigned long   base_off  = 0;
    unsigned long   base_next = 0;
    unsigned long   base_seg  = 0;
    unsigned long   base_intp = 0;
    unsigned long   eop_elf   = 0;
    unsigned long   eop_ldr   = 0;
    elf_ehdr *      ehdr;
    elf_phdr *      phdr;

    printf("> reading elf file '%s'\n", path);
    if(read_file(path, &elf_buf, &elf_len))
    {
        printf("> read_file failed\n");
        return -1;
    }

    printf("> loading elf at: 0x%llx\n", base_mod);
    ehdr = (elf_ehdr *)elf_buf;
    if(ehdr->e_type == ET_DYN)
        base_off = base_mod;

    eop_elf = base_off + ehdr->e_entry;

    // load segments
    for(int i=0; i<ehdr->e_phnum; i++)
    {
        phdr = (elf_phdr *)(elf_buf + ehdr->e_phoff + i * ehdr->e_phentsize);
        // printf("> seg[%d] load: %d addr 0x%llx size 0x%llx\n", i, phdr->p_type == PT_LOAD, phdr->p_vaddr, phdr->p_memsz);
        if(phdr->p_type == PT_LOAD && load_segment(elf_buf, ehdr, phdr, base_off))
            return -1;
        if(!base_seg)
            base_seg = phdr->p_vaddr;
        base_next = phdr->p_vaddr + phdr->p_memsz > base_next ? phdr->p_vaddr + phdr->p_memsz : base_next;
    }

    ALIGN_PAGE_DOWN(base_seg);

    if(ehdr->e_type == ET_DYN)
        base_seg += base_off;
    // printf("> program base: 0x%llx\n", base_seg);

    base_next += MOD_OFFSET_NEXT;
    ALIGN_PAGE_UP(base_next);

    printf("> max vaddr 0x%llx\n", base_mod + base_next);

    // load interp
    for(int i=0; i<ehdr->e_phnum; i++)
    {
        char * interp;

        phdr = (elf_phdr *)(elf_buf + ehdr->e_phoff + i * ehdr->e_phentsize);

        if(phdr->p_type != PT_INTERP)
            continue;

        base_intp = base_mod + base_next;
        interp = (char*)(ehdr->e_type == ET_DYN ? base_seg : 0) + phdr->p_vaddr;

        printf("> loading interp '%s'\n", interp);
        if(map_elf(interp, base_intp, NULL, &eop_ldr))
            return -1;
    }

    // set auxv phdr / phent / phnum / pagesz / entry
    if(auxv)
    {
        printf("> setting auxv\n");
        set_auxv(auxv, AT_PHDR,  base_seg + ehdr->e_phoff);
        set_auxv(auxv, AT_PHNUM, ehdr->e_phnum);
        set_auxv(auxv, AT_ENTRY, eop_elf);
        set_auxv(auxv, AT_BASE,  base_seg);
    }

    *out_eop = eop_ldr ? eop_ldr : eop_elf;
    printf("> eop 0x%llx\n", *out_eop);
    return 0;
}


#endif

```

`code/fakestack.h`:

```h
// ======================================================================== //
// author:  ixty                                                       2018 //
// project: mandibule                                                       //
// licence: beerware                                                        //
// ======================================================================== //

// this code is used to generate a stack with auxv envv argv argc
// this stack will be given to ld-linux after our manual ELF mapping

#ifndef _FAKESTACK_H
#define _FAKESTACK_H

// utilities to build a fake "pristine stack" as if we were just loaded by the kernel

#define FSTACK_PUSH_STR(sp, s)                  \
{                                               \
    unsigned long l = strlen(s) + 1;            \
    unsigned long a = (unsigned long)sp - l;    \
    while((a % sizeof(unsigned long)) != 0)     \
        a -= 1;                                 \
    memcpy((void*)a, s, l);                     \
    sp = (void*)a;                              \
}

#define FSTACK_PUSH_LONG(sp, n)                 \
{                                               \
    unsigned long l = sizeof(unsigned long);    \
    unsigned long v = n;                        \
    sp -= l;                                    \
    memcpy(sp, &v, l);                          \
}

#define FSTACK_PUSH_AUXV(sp, auxv)              \
{                                               \
    unsigned long * a = auxv;                   \
    FSTACK_PUSH_LONG(sp, 0);                    \
    FSTACK_PUSH_LONG(sp, 0);                    \
    while(*a)                                   \
    {                                           \
        FSTACK_PUSH_LONG(sp, a[1]);             \
        FSTACK_PUSH_LONG(sp, a[0]);             \
        a += 2;                                 \
    }                                           \
}

static inline uint8_t * fake_stack(uint8_t * sp, int ac, char ** av, char ** env, unsigned long * auxv)
{
    uint8_t *   env_ptrs[256];
    int         env_max = 0;
    char *      av_0    = NULL;
    memset(env_ptrs, 0, sizeof(env_ptrs));

    // align stack
    FSTACK_PUSH_STR(sp, "");

    // copy original env
    while(*env && env_max < 254)
    {
        FSTACK_PUSH_STR(sp, *env);
        env_ptrs[env_max++] = sp;
        env ++;
    }

    // add to envdata
    FSTACK_PUSH_STR(sp, "MANMAP=1");
    env_ptrs[env_max++] = sp;

    // argv data
    for(int i=0; i<ac; i++)
        FSTACK_PUSH_STR(sp, av[ac - i - 1]);
    av_0 = (char*)sp;

    // auxv
    FSTACK_PUSH_AUXV(sp, auxv);

    // envp
    FSTACK_PUSH_LONG(sp, 0);
    for(int i=0; i<env_max; i++)
        FSTACK_PUSH_LONG(sp, (unsigned long)env_ptrs[i]);

    // argp
    FSTACK_PUSH_LONG(sp, 0);
    for(int i=0; i<ac; i++)
        FSTACK_PUSH_LONG(sp, (unsigned long)av_0 + (ac - i - 1) * sizeof(unsigned long));
    // argc
    FSTACK_PUSH_LONG(sp, ac);

    return sp;
}


#endif

```

`code/ptinject.h`:

```h
// ======================================================================== //
// author:  ixty                                                       2018 //
// project: mandibule                                                       //
// licence: beerware                                                        //
// ======================================================================== //

// code to inject code in a remote process using ptrace
// entry point is:
    // int pt_inject(pid_t pid, uint8_t * sc_buf, size_t sc_len, size_t start_offset);

#ifndef _PTRACE_H
#define _PTRACE_H

#include <asm/ptrace.h>
#include <sys/user.h>
#include <sys/uio.h>

// ======================================================================== //
// arch specific defines
// ======================================================================== //
#if defined(__i386__)
    #define REG_TYPE    user_regs_struct
    #define REG_PC      eip
    #define PC_OFF      2
    #define REG_SYSCALL orig_eax

#elif defined(__x86_64__)
    #define REG_TYPE    user_regs_struct
    #define REG_PC      rip
    #define PC_OFF      2
    #define REG_SYSCALL orig_rax

#elif defined(__arm__)
    #define REG_TYPE    user_regs
    #define REG_PC      uregs[15]
    #define PC_OFF      4
    #define REG_SYSCALL uregs[7]

#elif defined(__aarch64__)
    #define REG_TYPE    user_regs_struct
    #define REG_PC      pc
    #define PC_OFF      4
    #define REG_SYSCALL regs[8]

#else
    #error "unknown arch"
#endif


// ======================================================================== //
// tools
// ======================================================================== //

// error macro
#define _pt_fail(...) do { printf(__VA_ARGS__); return -1; } while(0)

// returns the first executable segment of a process
int _pt_getxzone(pid_t pid, unsigned long * addr, size_t * size)
{
    size_t min_size = *size;

    if(get_section(pid, "r-xp", addr, size) == 0 && *size > min_size)
        return 0;
    if(get_section(pid, "rwxp", addr, size) == 0 && *size > min_size)
        return 0;
    _pt_fail("> no executable section is large enough :/\n");
}

// read remote memory lword by lword
int _pt_read(int pid, void * addr, void * dst, size_t len)
{
    size_t n = 0;
    long r;

    while(n < len)
    {
        if( (r = _ptrace(PTRACE_PEEKTEXT, pid, (uint8_t*)addr + n, (uint8_t*)dst + n)) < 0)
            _pt_fail("_pt_read error %d\n", r);
        n += sizeof(long);
    }
    return 0;
}

// write remote memory lword by lword
int _pt_write(int pid, void * addr, void * src, size_t len)
{
    size_t n = 0;
    long r;

    while(n < len)
    {
        if( (r = _ptrace(PTRACE_POKETEXT, pid, (uint8_t*)addr + n, (void*)*(long*)((uint8_t*)src + n))) < 0)
            _pt_fail("_pt_write error %d", r);
        n += sizeof(long);
    }
    return 0;
}

// arm64 doesnt support PTRACE_GETREGS, so we use getregset
int _pt_getregs(int pid, struct REG_TYPE * regs)
{
    struct iovec io;
    io.iov_base = regs;
    io.iov_len = sizeof(*regs);

    if(_ptrace(PTRACE_GETREGSET, pid, (void*)NT_PRSTATUS, (void*)&io) == -1)
        _pt_fail("> PTRACE_GETREGSET error\n");
    return 0;
}

// arm64 doesnt support PTRACE_GETREGS, so we use getregset
int _pt_setregs(int pid, struct REG_TYPE * regs)
{
    struct iovec io;
    io.iov_base = regs;
    io.iov_len = sizeof(*regs);

    if(_ptrace(PTRACE_SETREGSET, pid, (void*)NT_PRSTATUS, (void*)&io) == -1)
        _pt_fail("> PTRACE_SETREGSET error\n");
    return 0;
}

int _pt_cancel_syscall(int pid)
{
#ifdef __arm__
    if(_ptrace(PTRACE_SET_SYSCALL, pid, NULL, (void*)-1) < 0)
        _pt_fail("> PTRACE_SET_SYSCALL err\n");

#elif __aarch64__
    struct iovec iov;
    long sysnbr = -1;

    iov.iov_base = &sysnbr;
    iov.iov_len = sizeof(long);
    if(_ptrace(PTRACE_SETREGSET, pid, (void*)NT_ARM_SYSTEM_CALL, &iov) < 0)
        _pt_fail("> PTRACE_SETREGSET NT_ARM_SYSTEM_CALL err\n");
#else
    // nothing specific to do on x86 & amd64
#endif
    return 0;
}

// inject shellcode via ptrace into remote process
int pt_inject(pid_t pid, uint8_t * sc_buf, size_t sc_len, size_t start_offset)
{
    struct REG_TYPE regs;
    struct REG_TYPE regs_backup;
    unsigned long   rvm_a = 0;
    size_t          rvm_l = sc_len;
    uint8_t *       mem_backup = NULL;
    int             s;

    memset(&regs, 0, sizeof(regs));
    memset(&regs_backup, 0, sizeof(regs_backup));

    // get executable section large enough for our injected code
    if(_pt_getxzone(pid, &rvm_a, &rvm_l) < 0)
        return -1;
    printf("> shellcode injection addr: 0x%lx size: 0x%lx (available: 0x%lx)\n", rvm_a, sc_len, rvm_l);

    // attach process & wait for break
    if(_ptrace(PTRACE_ATTACH, pid, NULL, NULL) < 0)
        _pt_fail("> PTRACE_ATTACH error");
    if(_wait4(pid, &s, WUNTRACED, NULL) != pid)
        _pt_fail("> wait4(%d) error\n", pid);
    printf("> success attaching to pid %d\n", pid);

    // backup registers
    if(_pt_getregs(pid, &regs))
        return -1;
    memcpy(&regs_backup, &regs, sizeof(struct REG_TYPE));

    // backup memory
    if(!(mem_backup = malloc(sc_len + sizeof(long))))
        _pt_fail("> malloc failed to allocate memory for remote mem backup\n");

    if(_pt_read(pid, (void*)rvm_a, mem_backup, sc_len) < 0)
        _pt_fail("> failed to read remote memory\n");
    printf("> backed up mem & registers\n");

    // inject shellcode
    if(_pt_write(pid, (void*)rvm_a, sc_buf, sc_len))
        return -1;
    printf("> injected shellcode at 0x%lx\n", rvm_a);

    // adjust PC / eip / rip to our injected code
    regs.REG_PC = rvm_a + PC_OFF + start_offset;
    if(_pt_setregs(pid, &regs))
        return -1;

    // execute code now
    printf("> running shellcode..\n");

    // wait until the target process calls exit() / exit_group()
    while(1)
    {
        if(_ptrace(PTRACE_SYSCALL, pid, NULL, NULL) < 0)
            _pt_fail("> PTRACE_SYSCALL error\n");

        if(_wait4(pid, &s, 0, NULL) < 0 || WIFEXITED(s))
            _pt_fail("> wait4 error\n");

        if(_pt_getregs(pid, &regs))
            return -1;

        if(regs.REG_SYSCALL == SYS_exit || regs.REG_SYSCALL == SYS_exit_group)
        {
            _pt_cancel_syscall(pid);
            break;
        }

    }

    printf("> shellcode executed!\n");

    // restore reg & mem backup
    if(_pt_write(pid, (void*)rvm_a, mem_backup, sc_len))
        return -1;
    if(_pt_setregs(pid, &regs_backup))
        return -1;
    printf("> restored memory & registers\n");

    // all done, detach now
    if(_ptrace(PTRACE_DETACH, pid, NULL, NULL) < 0)
        _pt_fail("> _pt_detach error\n");

    return 0;
}

#endif

```

`code/shargs.h`:

```h
// ======================================================================== //
// author:  ixty                                                       2018 //
// project: mandibule                                                       //
// licence: beerware                                                        //
// ======================================================================== //

#ifndef _ARGS_H
#define _ARGS_H

// code to build / parse / manipulate a shared arguments structure
// used to pass info from injector to injected code
// we hijack the ELF header (+ section header ...) to pass arguments to the injected copy of our code

// fwd declarations
void usage(char * argv0, char * msg);

// small error macro
#define _ashared_error(...) do { printf(__VA_ARGS__); _exit(1); } while(0)

// shared arguments between injector & injectee
typedef struct ashared_s
{
    // internals
    size_t          size_max;       // total size in bytes of header + data
    size_t          size_used;      // currently used memory

    // payload
    unsigned long   pid;            // pid to inject into
    unsigned long   base_addr;      // address where we want to load binary in memory - 0 for auto
    int             count_arg;      // number of arguments
    int             count_env;      // number of env values
    char            data[];         // data where args & envs are stored, list of null terminated strings
} ashared_t;

// allocates memory & prepares structure
ashared_t * _ashared_new(size_t size)
{
    ashared_t * a = (ashared_t *)malloc(size);
    if(!a)
        return NULL;

    memset(a, 0, size);
    a->base_addr    = -1;
    a->size_max     = size;
    a->size_used    = sizeof(ashared_t);
    return a;
}

// add a string (either arg or env) to our shared data struct
int _ashared_add(ashared_t * a, char * arg, int is_arg_not_env)
{
    // size of data to be added (including null byte)
    size_t l = strlen(arg) + 1;
    // trying to add an argument after we started adding env?
    if(is_arg_not_env && a->count_env)
        return -1;

    // check that we have the required space
    if(a->size_max - a->size_used < l)
        return -1;

    char * p = a->data + a->size_used - sizeof(ashared_t);
    memcpy(p, arg, l);
    a->size_used += l;
    if(is_arg_not_env)
        a->count_arg += 1;
    else
        a->count_env += 1;
    return 0;
}

// get an envvar or argval from index
char * _ashared_get(ashared_t * a, int ind, int is_arg_not_env)
{
    char * p = a->data;

    // sanity checks
    if(is_arg_not_env && ind >= a->count_arg)
        return NULL;
    if(!is_arg_not_env && ind >= a->count_env)
        return NULL;

    // convert env index to string (arg + env) index in data
    if(!is_arg_not_env)
        ind += a->count_arg;

    // enumerate argvs
    for(int i=0; i<a->count_arg + a->count_env; i++)
    {
        // found what we're looking for?
        if(i == ind)    return p;

        // goto next string
        while(*p)       p++;
        p++;
    }

    return NULL;
}

// print recap of settings
void _ashared_print(ashared_t * args)
{
    printf("> target pid: %d\n", args->pid);

    for(int i=0; i<args->count_arg; i++)
        printf("> arg[%d]: %s\n", i, _ashared_get(args, i, 1));
    for(int i=0; i<args->count_env; i++)
        printf("> env[%d]: %s\n", i, _ashared_get(args, i, 0));
    if(args->base_addr != (unsigned long)-1)
        printf("> base address: 0x%lx\n", args->base_addr);

    printf("> args size: %d\n", args->size_used);
}

// parse argc & argv to fill info
ashared_t * _ashared_parse(int ac, char ** av)
{
    // allocate struct to pass info to injected code in remote process
    ashared_t * args = _ashared_new(0x1000);
    int optind = 1;
    if(!args)
        _ashared_error("> error allocating memory for arguments\n");

    // parse arguments
    if(ac < 3)
        usage(av[0], "at least 2 arguments are required (<elf> + <pid>)");

    // add argv[0] (path of elf to inject)
    if(_ashared_add(args, av[optind++], 1) < 0)
        _ashared_error("> error setting elf path (too long?)\n");

    // add arguments
    while(!strcmp(av[optind], "-a"))
    {
        if(optind + 1 + 1 >= ac)
            usage(av[0], "missing string for option -a");
        if(_ashared_add(args, av[optind+1], 1) < 0)
            _ashared_error("> error setting argument '%s'\n", av[optind+1]);
        optind += 2;
    }

    // add environment
    while(!strcmp(av[optind], "-e"))
    {
        if(optind + 1 + 1 >= ac)
            usage(av[0], "missing string for option -e");
        if(_ashared_add(args, av[optind + 1], 0) < 0)
            _ashared_error("> error setting envvar '%s'\n", av[optind + 1]);
        optind += 2;
    }

    // specify memory addr ?
    if(!strcmp(av[optind], "-m"))
    {
        if(optind + 1 + 1 >= ac)
            usage(av[0], "missing address for option -m");
        args->base_addr = strtoul(av[optind + 1], NULL, 0);
        optind += 2;
    }

    // and finally, the pid to inject into
    args->pid = strtoul(av[optind], NULL, 10);

    // print a recap now
    _ashared_print(args);

    // parsing finished - trim struct
    args->size_max = args->size_used;
    return args;
}

#endif

```

`icrt/icrt.h`:

```h
// ======================================================================== //
// author:  ixty                                                       2018 //
// project: inline c runtime library                                        //
// licence: beerware                                                        //
// ======================================================================== //

#ifndef _ICRT_H
#define _ICRT_H

// small inline C runtime library
// defines its syscalls using inline assembly
// defines a few standard functions str* mem* ...

#include "icrt_asm.h"
#include "icrt_syscall.h"
#include "icrt_std.h"
#include "icrt_utils.h"
#include "icrt_mem.h"

#endif

```

`icrt/icrt_asm.h`:

```h
// ======================================================================== //
// author:  ixty                                                       2018 //
// project: inline c runtime library                                        //
// licence: beerware                                                        //
// ======================================================================== //

#ifndef _ICRT_ASM_H
#define _ICRT_ASM_H

// in there we define a few inline asm utilities:
    // 32/64 bits define
    // macro to call a func with stack pointer as argument
    // macro to define the injection entrypoint (nops + call)
    // macro to set SP & jump to specified address

// arch currently supported:
    // x86
    // x86_64
    // arm
    // arm64

#ifdef __i386__
    #define BITS32

    // x86: code to call a function with stack pointer as argument
    #define CALL_SP(addr) \
    asm volatile("push %%esp; call *%%eax;" : : "a"(addr) );

    // x86: entry point of code injected into remote process
    #define INJ_ENTRY(name, func) \
    asm(".text; .global " #name "; " #name ":; nop; nop; call " #func "; int3;"); \
    extern void name(void);

    // x86: code to set stack pointer and jump to address
    #define FIX_SP_JMP(stack, addr) \
    asm volatile("xchg %%esp, %0; jmp *%%eax;" : "=r"(stack) : "0"(stack), "a"(addr) );

#elif __x86_64__
    #define BITS64

    // x86_64: code to call a function with stack pointer as argument
    #define CALL_SP(addr) \
    asm volatile("mov %%rsp, %%rdi; call *%%rax;" : : "a"(addr) );

    // x86_64: entry point of code injected into remote process
    #define INJ_ENTRY(name, func) \
    asm(".text; .global " #name "; " #name ":; nop; nop; call " #func "; int3;"); \
    extern void name(void);

    // x86_64: code to set stack pointer and jump to address
    #define FIX_SP_JMP(stack, addr) \
    asm volatile("xchg %%rsp, %0; jmp *%%rax;" : "=r"(stack) : "0"(stack), "a"(addr) );

#elif __arm__
    #define BITS32

    // arm: code to call a function with stack pointer as argument
    #define CALL_SP(addr) \
    asm volatile("mov r0, sp; mov pc, %0;" : : "r"(addr) );

    // arm: entry point of code injected into remote process
    // .inst 0xe7f001f0 = bkpt
    #define INJ_ENTRY(name, func) \
    asm(".text; .global " #name "; " #name ":; nop; bl " #func ";.inst 0xe7f001f0;"); \
    extern void name(void);

    // arm: code to set stack pointer and jump to address
    #define FIX_SP_JMP(stack, addrp) \
    asm volatile("mov %%sp, %0; bx %[addr];" : "=r"(stack) : "0"(stack), [addr] "r"(addrp) );

#elif __aarch64__
    #define BITS64

    // arm64: code to call a function with stack pointer as argument
    #define CALL_SP(func) \
    asm volatile("mov x0, sp; bl " #func"; ");

    // arm64: entry point of code injected into remote process
    #define INJ_ENTRY(name, func) \
    asm(".text; .global " #name "; " #name ":; nop; bl " #func ";.inst 0xd4200000;"); \
    extern void name(void);

    // arm64: code to set stack pointer and jump to address
    #define FIX_SP_JMP(stackp, addrp) \
    asm volatile("mov x0, sp; mov x1, %[stack]; sub x0, x1, x0; add sp, sp, x0; br %[addr]" \
        : : [stack] "r"(stackp), [addr] "r"(addrp) : "x0", "x1");

#endif

// small defines for auto detect injection address
#ifdef BITS32
    #define MAPS_ADDR_MASK 0xf0000000
    #define MAPS_ADDR_ALIGN(x) (x + 0x00010000 - (x % 0x00010000))
#else
    #define MAPS_ADDR_MASK 0x7f0000000000
    #define MAPS_ADDR_ALIGN(x) (x + 0x01000000 - (x % 0x01000000))
#endif


#endif

```

`icrt/icrt_mem.h`:

```h
// ======================================================================== //
// author:  ixty                                                       2018 //
// project: inline c runtime library                                        //
// licence: beerware                                                        //
// ======================================================================== //

// ixty malloc
// use mmap for every required block
// block header = [unsigned long user_size] [unsigned long allocd_size]

// some defines
#define IXTY_PAGE_SIZE          0x1000
#define IXTY_SIZE_USER(ptr)     (*(unsigned long *) ((unsigned long)(ptr) - 2 * sizeof(unsigned long)))
#define IXTY_SIZE_ALLOC(ptr)    (*(unsigned long *) ((unsigned long)(ptr) - 1 * sizeof(unsigned long)))
#define IXTY_SIZE_HDR           (2 * sizeof(unsigned long))

// this realloc will use the current mapped page if it is big enough
void * realloc(void * addr, size_t size)
{
    size_t alloc_size;
    unsigned long mem;

    if(!size)
        return NULL;

    if(addr && size < 0x1000 - IXTY_SIZE_HDR)
    {
        IXTY_SIZE_USER(addr) = size;
        return addr;
    }

    alloc_size = size + IXTY_SIZE_HDR;
    if(alloc_size % IXTY_PAGE_SIZE)
        alloc_size = ((alloc_size / IXTY_PAGE_SIZE) + 1) * IXTY_PAGE_SIZE;

    mem = (unsigned long)_mmap(NULL, alloc_size, PROT_READ|PROT_WRITE, MAP_ANONYMOUS | MAP_PRIVATE, -1, 0);
    if(mem < 0)
    {
        printf("> memory allocation error (0x%x bytes)\n", alloc_size);
        return NULL;
    }

    mem += IXTY_SIZE_HDR;
    IXTY_SIZE_USER(mem) = size;
    IXTY_SIZE_ALLOC(mem) = alloc_size;

    if(addr && IXTY_SIZE_USER(addr))
        memcpy((void*)mem, addr, IXTY_SIZE_USER(addr));
    if(addr)
        free(addr);

    return (void*)mem;
}

// wrapper around realloc
void * malloc(size_t len)
{
    return realloc(NULL, len);
}

// free mmapped page
void free(void * ptr)
{
    char * page = (char *)(ptr) - IXTY_SIZE_HDR;

    if(!ptr)
        return;

    _munmap(page, IXTY_SIZE_ALLOC(ptr));
}


```

`icrt/icrt_std.h`:

```h
// ======================================================================== //
// author:  ixty                                                       2018 //
// project: inline c runtime library                                        //
// licence: beerware                                                        //
// ======================================================================== //

// standard utilities (mem*, str*, ...)
#ifndef _ICRT_STD_H
#define _ICRT_STD_H

void memset(void * dst, unsigned char c, unsigned int len)
{
    unsigned char * p = (unsigned char *) dst;

    while(len--)
        *p++ = c;
}

int memcmp(void * dst, void * src, unsigned int len)
{
    unsigned char * d = (unsigned char *) dst;
    unsigned char * s = (unsigned char *) src;

    while(len-- > 0)
        if(*d++ != *s++)
            return 1;

    return 0;
}

void memcpy(void *dst, void *src, unsigned int len)
{
    unsigned char * d = (unsigned char *) dst;
    unsigned char * s = (unsigned char *) src;

    while(len--)
        *d++ = *s++;
}

void * memmem(void * haystack, size_t n, void * needle, size_t m)
{
    for(int i=0; i<n-m; i++)
        if(!memcmp((uint8_t*)haystack + i, needle, m))
            return (uint8_t*)haystack + i;
    return NULL;
}

int strlen(char * str)
{
    int n = 0;
    while(*str++)
        n++;
    return n;
}

int strnlen(char * str, int maxlen)
{
    int l = strlen(str);
    return l > maxlen ? maxlen : l;
}

int strncmp(char * s1, char * s2, size_t l)
{
    for(size_t i=0; i<l && *s1 && *s2; i++)
        if(s1[i] != s2[i])
            return -1;
    return 0;
}

int strcmp(char * s1, char * s2)
{
    int l1 = strlen(s1);
    int l2 = strlen(s2);

    if(l1 == l2 && !strncmp(s1, s2, l1))
        return 0;
    return -1;
}

size_t strlcat(char * dst, char * src, size_t maxlen)
{
    size_t srclen = strlen(src);
    size_t dstlen = strnlen(dst, maxlen);
    if(dstlen == maxlen)
        return maxlen + srclen;
    if(srclen < maxlen-dstlen)
        memcpy(dst+dstlen, src, srclen+1);
    else
    {
        memcpy(dst+dstlen, src, maxlen-1);
        dst[dstlen+maxlen-1] = 0;
    }
    return dstlen + srclen;
}

#ifndef ULONG_MAX
#define ULONG_MAX   ((unsigned long)(~0L))
#endif
#ifndef LONG_MAX
#define LONG_MAX    ((long)(ULONG_MAX >> 1))
#endif
#ifndef LONG_MIN
#define LONG_MIN    ((long)(~LONG_MAX))
#endif

#define ISSPACE(c) (c == ' ' || c == '\r' || c == '\t' || c == '\n')
#define ISDIGIT(c) (c >= '0' && c <= '9')
#define ISALPHA(c) ((c >= 'a' && c <= 'z') || (c >= 'A' && c <= 'Z'))
#define ISUPPER(c) (c >= 'A' && c <= 'Z')

unsigned long strtoul(const char * nptr, char ** endptr, int base)
{
    const char *s = nptr;
    unsigned long acc;
    unsigned long cutoff;
    int neg = 0, any, cutlim, c;

    do
    {
        c = *s++;
    }
    while (ISSPACE(c));

    if (c == '-')
    {
        neg = 1;
        c = *s++;
    }
    else if (c == '+')
        c = *s++;
    if ((base == 0 || base == 16) && c == '0' && (*s == 'x' || *s == 'X'))
    {
        c = s[1];
        s += 2;
        base = 16;
    }
    if (base == 0)
        base = c == '0' ? 8 : 10;
    cutoff = (unsigned long)ULONG_MAX / (unsigned long)base;
    cutlim = (unsigned long)ULONG_MAX % (unsigned long)base;
    for (acc = 0, any = 0;; c = *s++)
    {
        if (ISDIGIT(c))
            c -= '0';
        else if (ISALPHA(c))
            c -= ISUPPER(c) ? 'A' - 10 : 'a' - 10;
        else
            break;
        if (c >= base)
            break;
        if (any < 0 || acc > cutoff || (acc == cutoff && c > cutlim))
            any = -1;
        else
        {
            any = 1;
            acc *= base;
            acc += c;
        }
    }
    if (any < 0)
        acc = ULONG_MAX;
    else if (neg)
        acc = -acc;
    if (endptr != 0)
        *endptr = (char *) (any ? s - 1 : nptr);
    return (acc);
}

int fmt_num(char * buf, size_t len, unsigned long val, int base)
{
    unsigned long v = val;
    size_t n = 0;

    memset(buf, 0, len);

    // validate base first
    if(base != 0 && base != 8 && base != 10 && base != 16)
        return -1;
    if(base == 0)
        base = 10;

    // count required number of chars
    while(v)
    {
        v /= base;
        n += 1;
    }
    if(!n)
        n = 1;

    // check that we have enought room for string + null byte
    if(len < n + 1)
        return -1;

    for(int i=n-1; i>=0; i--)
    {
        if(base != 16 || val % 16 < 10)
            buf[i] = '0' + (val % base);
        else
            buf[i] = 'a' + ((val % 16) - 10);

        val /= base;
    }
    return 0;
}

// ugly AF but i dont want to include snprintf which has tons of globals / code / etc.
// only supports %x %d %s
// some modifiers are accepted but arent taken into account
void printf(char * str, ...)
{
    char tmp[32];
    char *  s = str;
    char *  p = str;
    va_list args;
    va_start(args, str);

    while(1)
    {
        // end of string reached, output everything left to display
        if(!*p)
        {
            if(p - s > 0)
                _write(1, s, p - s);
            goto exit;
        }

        // format string?
        if(*p == '%' && *(p+1) != '%')
        {
            // output current string
            _write(1, s, p - s);

            // handle (and ignore :)) format string modifiers
            p += 1;
            while(ISDIGIT(*p) || *p == '.')
                p++;
            while(*p == 'l' || *p == 'h' || *p == 'b')
                p++;

            // we ignore sign aswell, unsigned only :)
            if(*p == 'i' || *p == 'I' || *p == 'd' || *p == 'D')
            {
                fmt_num(tmp, sizeof(tmp), va_arg(args, unsigned long), 10);
                _write(1, tmp, strlen(tmp));
            }
            else if(*p == 'x' || *p == 'X')
            {
                fmt_num(tmp, sizeof(tmp), va_arg(args, unsigned long), 16);
                _write(1, tmp, strlen(tmp));
            }
            else if(*p == 's')
            {
                char * fstr = va_arg(args, char *);
                _write(1, fstr, strlen(fstr));
            }
            else
                _write(1, "<?>", 3);

            p++;
            s = p;
        }
        // nope, skip
        else if(*p == '%')
            p++;

        p++;
    }

exit:
    va_end(args);
    return;
}

#endif

```

`icrt/icrt_syscall.h`:

```h
// ======================================================================== //
// author:  ixty                                                       2018 //
// project: inline c runtime library                                        //
// licence: beerware                                                        //
// ======================================================================== //

// inline assembly implementation of linux syscalls
// we define a _syscall_do() macro which calls a syscall with up to 6 arguments
// arguments are assumed to be declared as a1, a2, ..., a6

// we then use this macro to define macros for syscalls with specifid number of args
// finally, we use those macros to define the functions that are of interest to us

#ifndef _ICRT_SYSCALL_H
#define _ICRT_SYSCALL_H

// syscall numbers
#include <sys/syscall.h>


// ========================================================================== //
// define syscall asm stub for all archs here
// ========================================================================== //

// x86
#ifdef __i386__
    #define _syscall_do(sys_nbr, rettype)                                   \
    {                                                                       \
        rettype ret = 0;                                                    \
        register int r0 asm ("ebx") = (int)a1;                              \
        register int r1 asm ("ecx") = (int)a2;                              \
        register int r2 asm ("edx") = (int)a3;                              \
        register int r3 asm ("esi") = (int)a4;                              \
        register int r4 asm ("edi") = (int)a5;                              \
        register int r5 asm ("ebp") = (int)a6;                              \
        register int r7 asm ("eax") = sys_nbr;                              \
        asm volatile                                                        \
        (                                                                   \
            "int $0x80;"                                                    \
            : "=r" (ret)                                                    \
            : "r"(r7), "r"(r0), "r"(r1), "r"(r2), "r"(r3), "r"(r4), "r"(r5) \
        );                                                                  \
        return ret;                                                         \
    }

// x86_64 aka amd64
#elif __x86_64__
    #define _syscall_do(sys_nbr, rettype)                                   \
    {                                                                       \
        register long r10 asm("r10") = (long)a4;                            \
        register long r8  asm("r8")  = (long)a5;                            \
        register long r9  asm("r9")  = (long)a6;                            \
        rettype ret = 0;                                                    \
        asm volatile                                                        \
        (                                                                   \
            "syscall"                                                       \
            : "=a" (ret)                                                    \
            : "0"(sys_nbr), "D"(a1),  "S"(a2),                              \
              "d"(a3),      "r"(r10), "r"(r8), "r"(r9)                      \
            : "cc", "rcx", "r11", "memory"                                  \
        );                                                                  \
        return ret;                                                         \
    }


// arm
#elif __arm__
    #define _syscall_do(sys_nbr, rettype)                                   \
    {                                                                       \
        rettype ret = 0;                                                    \
        register int r0 asm ("r0") = (int)a1;                               \
        register int r1 asm ("r1") = (int)a2;                               \
        register int r2 asm ("r2") = (int)a3;                               \
        register int r3 asm ("r3") = (int)a4;                               \
        register int r4 asm ("r4") = (int)a5;                               \
        register int r5 asm ("r5") = (int)a6;                               \
        register int r7 asm ("r7") = sys_nbr;                               \
        asm volatile                                                        \
        (                                                                   \
            "swi #0; mov %0, r0"                                            \
            : "=r" (ret)                                                    \
            : "r"(r7), "r"(r0), "r"(r1), "r"(r2), "r"(r3), "r"(r4), "r"(r5) \
        );                                                                  \
        return ret;                                                         \
    }


// arm64
#elif __aarch64__
    #define _syscall_do(sys_nbr, rettype)                                   \
    {                                                                       \
        rettype ret = 0;                                                    \
        register long x0 asm ("x0") = (long)a1;                             \
        register long x1 asm ("x1") = (long)a2;                             \
        register long x2 asm ("x2") = (long)a3;                             \
        register long x3 asm ("x3") = (long)a4;                             \
        register long x4 asm ("x4") = (long)a5;                             \
        register long x5 asm ("x5") = (long)a6;                             \
        register long x8 asm ("x8") = sys_nbr;                              \
        asm volatile                                                        \
        (                                                                   \
            "svc #0; mov %0, x0"                                            \
            : "=r" (ret)                                                    \
            : "r"(x8), "r"(x0), "r"(x1), "r"(x2), "r"(x3), "r"(x4), "r"(x5) \
        );                                                                  \
        return ret;                                                         \
    }

// something else?
#else
    #error "unknown arch"
#endif


// ========================================================================== //
// defines to generate syscall wrappers
// ========================================================================== //

#define _syscall6(sys_nbr, sys_name, rettype, t1, t2, t3, t4, t5, t6)       \
static inline rettype sys_name(t1 a1, t2 a2, t3 a3, t4 a4, t5 a5, t6 a6)    \
{                                                                           \
    _syscall_do(sys_nbr, rettype)                                           \
}

#define _syscall5(sys_nbr, sys_name, rettype, t1, t2, t3, t4, t5)           \
static inline rettype sys_name(t1 a1, t2 a2, t3 a3, t4 a4, t5 a5)           \
{                                                                           \
    long a6=0;                                                              \
    _syscall_do(sys_nbr, rettype)                                           \
}

#define _syscall4(sys_nbr, sys_name, rettype, t1, t2, t3, t4)               \
static inline rettype sys_name(t1 a1, t2 a2, t3 a3, t4 a4)                  \
{                                                                           \
    long a6=0, a5=0;                                                        \
    _syscall_do(sys_nbr, rettype)                                           \
}

#define _syscall3(sys_nbr, sys_name, rettype, t1, t2, t3)                   \
static inline rettype sys_name(t1 a1, t2 a2, t3 a3)                         \
{                                                                           \
    long a6=0, a5=0, a4=0;                                                  \
    _syscall_do(sys_nbr, rettype)                                           \
}

#define _syscall2(sys_nbr, sys_name, rettype, t1, t2)                       \
static inline rettype sys_name(t1 a1, t2 a2)                                \
{                                                                           \
    long a6=0, a5=0, a4=0, a3=0;                                            \
    _syscall_do(sys_nbr, rettype)                                           \
}

#define _syscall1(sys_nbr, sys_name, rettype, t1)                           \
static inline rettype sys_name(t1 a1)                                       \
{                                                                           \
    long a6=0, a5=0, a4=0, a3=0, a2=0;                                      \
    _syscall_do(sys_nbr, rettype)                                           \
}

#define _syscall0(sys_nbr, sys_name, rettype)                               \
static inline rettype sys_name(void)                                        \
{                                                                           \
    long a6=0, a5=0, a4=0, a3=0, a2=0, a1=0;                                \
    _syscall_do(sys_nbr, rettype)                                           \
}


// ========================================================================== //
// define desired syscalls
// ========================================================================== //

_syscall0(SYS_getpid,   _getpid,    int)

_syscall1(SYS_exit,     __exit,     int,        int)
void _exit(int c) { __exit(c); }

_syscall1(SYS_close,    _close,     int,        int)
_syscall1(SYS_brk,      _brk,       long,       unsigned long)

_syscall2(SYS_munmap,   _munmap,    long,       char*, int)

_syscall3(SYS_read,     _read,      ssize_t,    int, void *, size_t)
_syscall3(SYS_write,    _write,     ssize_t,    int, const void *, size_t)
_syscall3(SYS_lseek,    _lseek,     long,       int, long, int)
_syscall3(SYS_mprotect, _mprotect,  long,       void*, long, int)

#if __i386__ || __arm__ || __x86_64__
_syscall3(SYS_open,     _open,      int,        char *, int, int)
#else
_syscall4(SYS_openat,   _openat,    int,        int, char *, int, int)
#define AT_FDCWD        -100
#define _open(a, b, c) _openat(AT_FDCWD, a, b, c)
#endif

_syscall4(SYS_ptrace,   _ptrace,    long,       int, int, void*, void*)
_syscall4(SYS_wait4,    _wait4,     int,        int, int*, int, void*)

#if __i386__ || __arm__
    _syscall6(SYS_mmap2, _mmap, void *, void *, long, int, int, int, long)
#else
    _syscall6(SYS_mmap, _mmap, void *, void *, long, int, int, int, long)
#endif


// ========================================================================== //
// usefull constants for common syscalls
// ========================================================================== //
#define O_RDONLY        00
#define O_WRONLY        01
#define O_RDWR          02
#define O_CREAT         0100
#define O_TRUNC         01000
#define O_APPEND        02000

#define F_DUPFD         0
#define F_GETFD         1
#define F_SETFD         2
#define F_GETFL         3
#define F_SETFL         4

#define SEEK_SET        0
#define SEEK_CUR        1
#define SEEK_END        2

#define PROT_READ       0x1
#define PROT_WRITE      0x2
#define PROT_EXEC       0x4
#define PROT_NONE       0x0

#define MAP_SHARED      0x01
#define MAP_PRIVATE     0x02
#define MAP_TYPE        0x0f
#define MAP_FIXED       0x10
#define MAP_ANONYMOUS   0x20


#define PTRACE_TRACEME      0
#define PTRACE_PEEKTEXT     1
#define PTRACE_PEEKDATA     2
#define PTRACE_PEEKUSER     3
#define PTRACE_POKETEXT     4
#define PTRACE_POKEDATA     5
#define PTRACE_POKEUSER     6
#define PTRACE_CONT         7
#define PTRACE_KILL         8
#define PTRACE_SINGLESTEP   9
#define PTRACE_GETREGS      12
#define PTRACE_SETREGS      13
#define PTRACE_GETFPREGS    14
#define PTRACE_SETFPREGS    15
#define PTRACE_ATTACH       16
#define PTRACE_DETACH       17
#define PTRACE_GETFPXREGS   18
#define PTRACE_SETFPXREGS   19
#define PTRACE_SET_SYSCALL  23
#define PTRACE_SYSCALL      24
#define PTRACE_SYSEMU       31

#define PTRACE_GETREGSET    0x4204
#define PTRACE_SETREGSET    0x4205

#define NT_ARM_SYSTEM_CALL  0x404

#define NT_PRSTATUS         1
#define NT_PRFPREG          2
#define NT_PRPSINFO         3
#define NT_TASKSTRUCT       4
#define NT_AUXV             6

#endif

```

`icrt/icrt_utils.h`:

```h
// ======================================================================== //
// author:  ixty                                                       2018 //
// project: inline c runtime library                                        //
// licence: beerware                                                        //
// ======================================================================== //

// utilities (read_file, read /proc/pid/maps, ...)

#ifndef _ICRT_UTILS_H
#define _ICRT_UTILS_H

// get file size, supports fds with no seek_end (such as /proc/pid/maps apparently...)
long _get_file_size(int fd)
{
    long fs, r;
    char tmp[0x1000];

    // can seek to end?
    fs = _lseek(fd, 0, SEEK_END);
    if(fs > 0)
    {
        _lseek(fd, 0, SEEK_SET);
        return fs;
    }

    fs = 0;
    do
    {
        r = _read(fd, tmp, 0x1000);
        if(r < 0)
            return -1;
        else
            fs += r;
    } while(r > 0);

    _lseek(fd, 0, SEEK_SET);
    return fs;
}

// allocate memory + read a file
int read_file(char * path, uint8_t ** out_buf, size_t * out_len)
{
    long fs, r, n=0;
    int fd;

    *out_buf = 0;
    *out_len = 0;

    // open file
    if((fd = _open(path, O_RDONLY, 0)) < 0)
        return -1;

    // get file size
    if(!(fs = _get_file_size(fd)))
        return -1;
    *out_len = fs;

    // allocate mem
    if((*out_buf = realloc(0, fs)) == NULL)
        goto exit;

    // read file
    while(n < fs)
    {
        r = _read(fd, *out_buf + n, fs);
        if(r < 0)
            goto exit;
        n += r;
        if(r == 0 && n != fs)
            goto exit;
    }
    _close(fd);
    return 0;

exit:
    if(*out_buf)
    {
        free(*out_buf);
        *out_buf = 0;
    }
    _close(fd);
    return -1;
}

int get_memmaps(int pid, uint8_t ** maps_buf, size_t * maps_len)
{
    char path[256];
    char pids[24];

    // convert pid to string
    if(fmt_num(pids, sizeof(pids), pid, 10) < 0)
        return -1;

    // build /proc/pid/maps string
    memset(path, 0, sizeof(path));
    strlcat(path, "/proc/", sizeof(path));
    strlcat(path, pids, sizeof(path));
    strlcat(path, "/maps", sizeof(path));

    // read file
    if(read_file(path, maps_buf, maps_len) < 0)
        return -1;

    return 0;
}

// returns the address & size of the first section that matches _filter_
int get_section(int pid, char * filter, unsigned long * sec_start, size_t * sec_size)
{
    uint8_t *   maps_buf    = NULL;
    size_t      maps_len    = 0;
    size_t      off         = 0;
    size_t      min_len     = *sec_size;
    char *      p;

    // read /proc/pid/maps
    if(get_memmaps(pid, &maps_buf, &maps_len) < 0)
        return -1;

    // find first line that matches _filter_
    do
    {
        if(!(p = memmem(maps_buf + off, maps_len - off, filter, strlen(filter))))
            goto fail;
        off = (size_t)p - (size_t)maps_buf + 1;

        while(*p && p >= (char*)maps_buf && *p != '\n')
            p--;
        p++;

        // extract section addr & size
        *sec_start  = strtoul(p, &p, 16);  p++;
        *sec_size   = strtoul(p, &p, 16) - (size_t)*sec_start;

    } while(*sec_size < min_len);


    free(maps_buf);
    return 0;

fail:
    free(maps_buf);
    return -1;
}

// returns max - low address (doesnt start with F or 7F) used by the process
unsigned long get_mapmax(int pid)
{
    char * maps_buf = NULL;
    size_t maps_len = 0;
    char * p;
    unsigned long max = 0;

    // read /proc/pid/maps
    if(get_memmaps(pid, (uint8_t**)&maps_buf, &maps_len) < 0)
        return -1;

    // parse all maps
    for(p = (char*)maps_buf; p >= maps_buf && p < maps_buf + maps_len; )
    {
        char *          endline = memmem(p, maps_len - (p - maps_buf), "\n", 1);
        char *          tmp     = NULL;
        unsigned long   e;
        unsigned long   t;

        strtoul(p, &tmp, 16);
        if(!tmp)
            continue;
        tmp ++;
        e = strtoul(tmp, NULL, 16);
        t = e;

        while(t > 0xff)
            t >>= 8;
        if(t != 0xff && t != 0x7f)
            max = e;

        p = endline + 1;
    }
    free(maps_buf);
    printf("> auto-detected manual mapping address 0x%lx\n", MAPS_ADDR_ALIGN(max));
    return MAPS_ADDR_ALIGN(max);
}

#endif

```

`mandibule.c`:

```c
// ======================================================================== //
// author:  ixty                                                       2018 //
// project: mandibule                                                       //
// licence: beerware                                                        //
// ======================================================================== //

// only c file of our code injector
// it includes directly all other code to be able to wrap all generated code
// between start/end boundaries

#include <stdint.h>
#include <stdlib.h>
#include <stdarg.h>
#include <linux/unistd.h>

// first function in generated code - returns its own address aligned to page size
unsigned long mandibule_beg(int aligned)
{
    if(!aligned)
        return (unsigned long)mandibule_beg;
    return (unsigned long)mandibule_beg - ((unsigned long)mandibule_beg % 0x1000);
}

// include minimal inline c runtime + support code
#include "icrt.h"
#include "elfload.h"
#include "fakestack.h"
#include "ptinject.h"
#include "shargs.h"

// forward declarations
unsigned long mandibule_end(void);
void _main(unsigned long * sp);
void payload_loadelf(ashared_t * args);

// small macro for print + exit
#define error(...) do { printf(__VA_ARGS__); _exit(1); } while(0)

// define injected code entry point - which calls payload_main()
INJ_ENTRY(payload_start, payload_main)

// define injector entry point - which calls main()
void _start(void)
{
    CALL_SP(_main);
}

// show program usage & exit
void usage(char * argv0, char * msg)
{
    if(msg)
        printf("error: %s\n\n", msg);

    printf("usage: %s <elf> [-a arg]* [-e env]* [-m addr] <pid>\n", argv0);
    printf("\n");
    printf("loads an ELF binary into a remote process.\n");
    printf("\n");
    printf("arguments:\n");
    printf("    - elf: path of binary to inject into <pid>\n");
    printf("    - pid: pid of process to inject into\n");
    printf("\n");
    printf("options:\n");
    printf("    -a arg: argument to send to injected program - can be repeated\n");
    printf("    -e env: environment value sent to injected program - can be repeated\n");
    printf("    -m mem: base address at which program is loaded in remote process, default=AUTO\n");
    printf("\n");
    printf("Note: order of arguments must be respected (no getopt sry)\n");
    printf("\n");
    _exit(1);
}

// injector main code
void _main(unsigned long * sp)
{
    // argument parsing stuff
    int             ac          = *sp;
    char **         av          = (char **)(sp + 1);
    ashared_t *     args        = NULL;

    // injection vars
    void *          inj_addr    = (void*)mandibule_beg(1);
    size_t          inj_size    = mandibule_end() - (unsigned long)inj_addr;
    size_t          inj_off     = (size_t)payload_start - (size_t)inj_addr;
    size_t          inj_opts    = mandibule_beg(0) - mandibule_beg(1);
    uint8_t *       inj_code    = malloc(inj_size);

    // parse arguments & build shared arguments struct
    args = _ashared_parse(ac, av);
    if(inj_opts < args->size_used)
        error("> shared arguments too big (%d/ max %d)\n", args->size_max, inj_opts);

    // prepare code that will be injected into the process
    if(!inj_code)
        error("> malloc for injected code failed\n");
    memcpy(inj_code, inj_addr, inj_size);
    memcpy(inj_code, args, args->size_used);

    // self injection test
    if(args->pid == 0)
    {
        args->pid = _getpid();
        printf("> self inject pid: %d - bypassing ptrace altogether\n", args->pid);
        payload_loadelf(args);
    }
    else
    {
        // inject our own code into <pid> & execute code at <inj_off>
        if(pt_inject(args->pid, inj_code, inj_size, inj_off) < 0)
            error("> failed to inject shellcode into pid %d\n", args->pid);

        printf("> successfully injected shellcode into pid %d\n", args->pid);
    }
    _exit(0);
}

void payload_loadelf(ashared_t * args)
{
    char            pids[24];
    char            path[256];
    uint8_t *       auxv_buf;
    size_t          auxv_len;
    char **         av;
    char **         env;
    uint8_t         fakestack[4096 * 16];
    uint8_t *       stackptr = fakestack + sizeof(fakestack);
    unsigned long   eop;
    unsigned long   base_addr;

    // convert pid to string
    if(fmt_num(pids, sizeof(pids), args->pid, 10) < 0)
        return;

    // read auxv
    memset(path, 0, sizeof(path));
    strlcat(path, "/proc/", sizeof(path));
    strlcat(path, pids,     sizeof(path));
    strlcat(path, "/auxv",  sizeof(path));
    if(read_file(path, &auxv_buf, &auxv_len) < 0)
        return;
    printf("> auxv len: %d\n", auxv_len);

    // build argv from args
    av = malloc((args->count_arg + 1) * sizeof(char*));
    memset(av, 0, (args->count_arg + 1) * sizeof(char*));
    for(int i=0; i<args->count_arg; i++)
        av[i] = _ashared_get(args, i, 1);

    // build envp from args
    env = malloc((args->count_env + 1) * sizeof(char*));
    for(int i=0; i<args->count_env; i++)
        env[i] = _ashared_get(args, i, 0);

    // autodetect binary mapping address?
    base_addr = args->base_addr == -1 ? get_mapmax(args->pid) : args->base_addr;
    printf("> mapping '%s' into memory at 0x%lx\n", av[0], base_addr);

    // load the elf into memory!
    if(map_elf(av[0], base_addr, (unsigned long *)auxv_buf, &eop) < 0)
         error("> failed to load elf\n");

    // build a stack for loader entry
    memset(fakestack, 0, sizeof(fakestack));
    stackptr = fake_stack(stackptr, args->count_arg, av, env, (unsigned long *)auxv_buf);

    // all done
    printf("> starting ...\n\n");
    FIX_SP_JMP(stackptr, eop);

    // never reached if everything goes well
    printf("> returned from loader\n");
    free(auxv_buf);
    free(av);
    free(env);
    _exit(1);
}

// main function for injected code
// executed in remote process
void payload_main(void)
{
    // get the arguments from memory
    // we overwrite the ELF header with the arguments for the injected copy of our code
    ashared_t * args = (ashared_t*)mandibule_beg(1);
    _ashared_print(args);

    // load elf into memory
    payload_loadelf(args);
    _exit(0);
}

// must be the last function in the .c file
unsigned long mandibule_end(void)
{
    uint8_t * p = (uint8_t*)"-= end_rodata =-";
    p += 0x1000 - ((unsigned long)p % 0x1000);
    return (unsigned long)p;
}

```

`readme.md`:

```md
# mandibule: linux elf injector

## intro
Mandibule is a program that allows to inject an ELF file into a remote process.

Both static & dynamically linked programs can be targetted.
Supported archs:

- x86
- x86_64
- arm
- aarch64

Example usage: https://asciinema.org/a/KkOHP2Jef0E6wViPCglkXLRcV

@ixty 2018


## installation
```shell
git clone https://github.com/ixty/mandibule
make
```


## usage
```shell
usage: ./mandibule <elf> [-a arg]* [-e env]* [-m addr] <pid>

loads an ELF binary into a remote process.

arguments:
    - elf: path of binary to inject into <pid>
    - pid: pid of process to inject into

options:
    -a arg: argument to send to injected program - can be repeated
    -e env: environment value sent to injected program - can be repeated
    -m mem: base address at which program is loaded in remote process, default=AUTO

Note: order of arguments must be respected (no getopt sry)
```


## example run
```shell
$ make x86_64

# in shell 1
$ ./target
> started.
......

# in shell 2
$ ./mandibule ./toinject `pidof target`
> target pid: 6266
> arg[0]: ./toinject
> args size: 51
> shellcode injection addr: 0x7f0f4719c000 size: 0x5000 (available: 0x195000)
> success attaching to pid 6266
> backed up mem & registers
> injected shellcode at 0x7f0f4719c000
> running shellcode..
> shellcode executed!
> restored memory & registers
> successfully injected shellcode into pid 6266

# back to shell 1
...
> target pid: 6266
> arg[0]: ./toinject
> args size: 51
> auxv len: 304
> auto-detected manual mapping address 0x55f6e1000000
> mapping './toinject' into memory at 0x55f6e1000000
> reading elf file './toinject'
> loading elf at: 0x55f6e1000000
> load segment addr 0x55f6e1000000 len 0x1000 => 0x55f6e1000000
> load segment addr 0x55f6e1200dd8 len 0x1000 => 0x55f6e1200000
> max vaddr 0x55f6e1212000
> loading interp '/lib64/ld-linux-x86-64.so.2'
> reading elf file '/lib64/ld-linux-x86-64.so.2'
> loading elf at: 0x55f6e1212000
> load segment addr 0x55f6e1212000 len 0x23000 => 0x55f6e1212000
> load segment addr 0x55f6e1435bc0 len 0x2000 => 0x55f6e1435000
> max vaddr 0x55f6e1448000
> eop 0x55f6e1212c20
> setting auxv
> set auxv[3] to 0x55f6e1000040
> set auxv[5] to 0x9
> set auxv[9] to 0x55f6e10006e0
> set auxv[7] to 0x55f6e1000000
> eop 0x55f6e1212c20
> starting ...

# oh hai from pid 6266
# arg[0]: ./toinject
# :)
# :)
# :)
# bye!
...........


```


## injection proces
mandibule has no dependency (not even libc) and is compiled with pie and fpie in order to make it fully relocatable.

This way we can copy mandibule's code into any process and it will be able to run as if it were a totally independant shellcode.

Here is how mandibule works:

- find an executable section in target process with enough space (~5Kb)
- attach to process with ptrace
- backup register state
- backup executable section
- inject mandibule code into executable section
- let the execution resume on our own injected code
- wait until exit() is called by the remote process
- restore registers & memory
- detach from process

In the remote process, mandibule does the following:

- read arguments, environment variables and other options from its own memory
- find a suitable memory address to load the target elf file if needed
- manually load & map the elf file into memory using only syscalls
- load the ld-linux interpreter if needed
- call the main function of the manually loaded binary


## tested on

- __x86__:      Linux debian 4.9.0-3-amd64 #1 SMP Debian 4.9.30-2+deb9u5 (2017-09-19) x86_64 GNU/Linux
- __x86_64__:   Linux debian 4.9.0-3-amd64 #1 SMP Debian 4.9.30-2+deb9u5 (2017-09-19) x86_64 GNU/Linux
- __arm64__:    Linux buildroot 4.13.6 #1 SMP Sat Mar 3 16:40:18 UTC 2018 aarch64 GNU/Linux
- __arm__:      Linux buildroot 4.11.3 #1 SMP Sun Mar 4 02:36:56 UTC 2018 armv7l GNU/Linux

arm & arm64 where tested using [arm_now](https://github.com/nongiach/arm_now) by [@chaignc](https://twitter.com/chaignc) to easily spawn qemu vms with the desired arch.

```

`samples/target.c`:

```c
// ======================================================================== //
// author:  ixty                                                       2018 //
// project: mandibule                                                       //
// licence: beerware                                                        //
// ======================================================================== //

// small example of a target program we inject code into

#include <stdio.h>
#include <time.h>
#include <unistd.h>

int main(int ac, char ** av, char ** env)
{
    printf("> started.\n");

    while(1)
    {
        printf(".");
        fflush(stdout);
        sleep(1);
    }

    printf("> done.\n");
    return 0;
}

```

`samples/toinject.c`:

```c
// ======================================================================== //
// author:  ixty                                                       2018 //
// project: mandibule                                                       //
// licence: beerware                                                        //
// ======================================================================== //

// small example of code that we inject into a remote process

#include <stdio.h>
#include <time.h>
#include <sys/types.h>
#include <unistd.h>
#include <signal.h>

int main(int ac, char ** av, char ** env)
{
    printf("# oh hai from pid %d\n", getpid());
    for(int i=0; i<ac; i++)
        printf("# arg[%d]: %s\n", i, av[i]);

    for(int i=0; i<3; i++)
    {
        printf("# :)\n");
        fflush(stdout);
        sleep(1);
    }

    printf("# bye!\n");
    return 44;
}

```